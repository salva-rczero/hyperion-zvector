; Listing generated by Microsoft (R) Optimizing Compiler Version 19.34.31937.0 

include listing.inc

INCLUDELIB MSVCRTD
INCLUDELIB OLDNAMES

PUBLIC	lcs_device_hndinfo
PUBLIC	LCS_Init
PUBLIC	LCS_Close
PUBLIC	LCS_Query
PUBLIC	LCS_ExecuteCCW
PUBLIC	LCS_StartChannelProgram
PUBLIC	LCS_EndChannelProgram
_DATA	SEGMENT
$SG172716 DB	'mode', 00H
	ORG $+3
$SG172717 DB	'dev', 00H
$SG172718 DB	'mac', 00H
$SG172719 DB	'oat', 00H
$SG172720 DB	'distrc', 00H
	ORG $+1
$SG172721 DB	'maxtrc', 00H
	ORG $+1
$SG172722 DB	'debug', 00H
	ORG $+2
$SG172723 DB	'kbuff', 00H
	ORG $+2
$SG172724 DB	'ibuff', 00H
	ORG $+2
$SG172725 DB	'swrite', 00H
	ORG $+13
lcs_device_hndinfo DQ FLAT:LCS_Init
	DQ	FLAT:LCS_ExecuteCCW
	DQ	FLAT:LCS_Close
	DQ	FLAT:LCS_Query
	DQ	0000000000000000H
	DQ	FLAT:LCS_StartChannelProgram
	DQ	FLAT:LCS_EndChannelProgram
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	FLAT:lcs_halt_or_clear
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	FLAT:CTC_Immed_Commands
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	ORG $+8
CTC_Immed_Commands DB 00H
	DB	00H
	DB	00H
	DB	01H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	01H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	01H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	01H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
_DATA	ENDS
CONST	SEGMENT
CKD_ENDTRK DB	0ffH
	DB	0ffH
	DB	0ffH
	DB	0ffH
	DB	0ffH
	DB	0ffH
	DB	0ffH
	DB	0ffH
?Inbound_CC0A@?1??Process_0C0A@@9@9 DB 00H		; `Process_0C0A'::`2'::Inbound_CC0A
	DB	024H
	DB	04H
	DB	00H
	DB	00H
	DB	01cH
	DB	0ccH
	DB	0aH
	DB	00H
	DB	03H
	DB	060H
	DB	01H
	DB	0ffH
	DB	0ffH
	DB	0ffH
	DB	0ffH
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	070H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	0ffH
	DB	0ffH
	DB	0ffH
	DB	0ffH
	DB	01H
	DB	0ffH
	DB	0ffH
	DB	00H
mcast3	DB	01H
	DB	00H
	DB	05eH
	ORG $+1
?Inbound_CC0B@?1??Process_0C0B@@9@9 DB 00H		; `Process_0C0B'::`2'::Inbound_CC0B
	DB	020H
	DB	04H
	DB	00H
	DB	00H
	DB	018H
	DB	0ccH
	DB	0bH
	DB	00H
	DB	03H
	DB	060H
	DB	01H
	DB	0ffH
	DB	0ffH
	DB	0ffH
	DB	0ffH
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	070H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	01H
	DB	0ffH
	DB	0ffH
	DB	00H
?Inbound_CC99@?1??Process_0C99@@9@9 DB 00H		; `Process_0C99'::`2'::Inbound_CC99
	DB	032H
	DB	04H
	DB	00H
	DB	00H
	DB	018H
	DB	0ccH
	DB	099H
	DB	00H
	DB	015H
	DB	0c0H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	020H
	DB	01eH
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	01H
	DB	0ffH
	DB	0ffH
	DB	00H
	DB	00H
	DB	03H
	DB	00H
	DB	00H
	DB	06H
	DB	0ffH
	DB	0ffH
	DB	0ffH
	DB	0ffH
	DB	0ffH
	DB	0ffH
	DB	00H
	DB	00H
	DB	05H
	DB	0d5H
	DB	00H
	DB	00H
	DB	00H
	ORG $+6
?Inbound_CC0D@?1??Process_0C0D@@9@9 DB 00H		; `Process_0C0D'::`2'::Inbound_CC0D
	DB	038H
	DB	04H
	DB	00H
	DB	00H
	DB	02cH
	DB	0ccH
	DB	0dH
	DB	00H
	DB	07H
	DB	060H
	DB	03H
	DB	00H
	DB	00H
	DB	00H
	DB	01H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	070H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	040H
	DB	00H
	DB	00H
	DB	0dcH
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	01H
	DB	0ffH
	DB	0ffH
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
?Inbound_CC0E@?1??Process_0C0E@@9@9 DB 00H		; `Process_0C0E'::`2'::Inbound_CC0E
	DB	020H
	DB	04H
	DB	00H
	DB	00H
	DB	018H
	DB	0ccH
	DB	0eH
	DB	00H
	DB	03H
	DB	060H
	DB	03H
	DB	00H
	DB	00H
	DB	00H
	DB	01H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	070H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	01H
	DB	0ffH
	DB	0ffH
	DB	00H
?Inbound_CC98@?1??Process_0C98@@9@9 DB 00H		; `Process_0C98'::`2'::Inbound_CC98
	DB	020H
	DB	04H
	DB	00H
	DB	00H
	DB	018H
	DB	0ccH
	DB	098H
	DB	00H
	DB	03H
	DB	0c0H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	070H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	01H
	DB	0ffH
	DB	0ffH
	DB	00H
?Inbound_4D10@?1??LCS_ProcessAccepted_SNA@@9@9 DB 0ffH	; `LCS_ProcessAccepted_SNA'::`2'::Inbound_4D10
	DB	0ffH
	DB	04H
	DB	00H
	DB	00H
	DB	014H
	DB	04dH
	DB	010H
	DB	00H
	DB	09H
	DB	060H
	DB	01H
	DB	00H
	DB	00H
	DB	01H
	DB	01H
	DB	01H
	DB	00H
	DB	00H
	DB	040H
	DB	00H
	DB	00H
	DB	0ffH
	DB	00H
	DB	01H
	DB	0ffH
	DB	0ffH
	DB	00H
	DB	00H
	DB	0ffH
	DB	0ffH
	DB	0ffH
	DB	0ffH
	ORG $+3
zeromac	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	ORG $+6
?Inbound_4C25@?1??LCS_ProcessAccepted_SNA@@9@9 DB 00H	; `LCS_ProcessAccepted_SNA'::`2'::Inbound_4C25
	DB	02eH
	DB	04H
	DB	00H
	DB	00H
	DB	0dH
	DB	04cH
	DB	025H
	DB	00H
	DB	01cH
	DB	060H
	DB	03H
	DB	00H
	DB	00H
	DB	00H
	DB	01H
	DB	00H
	DB	01H
	DB	0ffH
	DB	0ffH
	DB	0c0H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	0ffH
	DB	0ffH
	DB	0ffH
	DB	0ffH
	DB	0ffH
	DB	0ffH
	DB	0ffH
	DB	0ffH
	DB	0ffH
	DB	0ffH
	DB	0ffH
	DB	0ffH
	DB	0ffH
	DB	0ffH
	DB	0ffH
	DB	04H
	DB	00H
	ORG $+2
?Inbound_4C22@?1??LCS_ProcessAccepted_SNA@@9@9 DB 00H	; `LCS_ProcessAccepted_SNA'::`2'::Inbound_4C22
	DB	01dH
	DB	04H
	DB	00H
	DB	00H
	DB	0dH
	DB	04cH
	DB	022H
	DB	00H
	DB	0cH
	DB	060H
	DB	03H
	DB	00H
	DB	00H
	DB	00H
	DB	01H
	DB	00H
	DB	01H
	DB	0ffH
	DB	0ffH
	DB	0c0H
	DB	00H
	DB	00H
	DB	00H
	DB	0ffH
	DB	08H
	DB	00H
	DB	00H
	DB	00H
	ORG $+3
?Inbound_4D00@?1??LCS_ProcessAccepted_SNA@@9@9 DB 00H	; `LCS_ProcessAccepted_SNA'::`2'::Inbound_4D00
	DB	018H
	DB	04H
	DB	00H
	DB	00H
	DB	0cH
	DB	04dH
	DB	00H
	DB	00H
	DB	08H
	DB	060H
	DB	01H
	DB	0ffH
	DB	0ffH
	DB	0ffH
	DB	0ffH
	DB	01H
	DB	0ffH
	DB	0ffH
	DB	0ffH
	DB	0ffH
	DB	0ffH
	DB	0ffH
	DB	00H
?Inbound_4C0B@?1??LCS_ProcessAccepted_SNA@@9@9 DB 00H	; `LCS_ProcessAccepted_SNA'::`2'::Inbound_4C0B
	DB	020H
	DB	04H
	DB	00H
	DB	00H
	DB	018H
	DB	04cH
	DB	0bH
	DB	00H
	DB	03H
	DB	060H
	DB	01H
	DB	0ffH
	DB	0ffH
	DB	0ffH
	DB	0ffH
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	076H
	DB	056H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	01H
	DB	040H
	DB	00H
	DB	00H
?Inbound_CD00@?1??LCS_ProcessAccepted_SNA@@9@9 DB 00H	; `LCS_ProcessAccepted_SNA'::`2'::Inbound_CD00
	DB	020H
	DB	04H
	DB	00H
	DB	00H
	DB	018H
	DB	0cdH
	DB	00H
	DB	00H
	DB	03H
	DB	060H
	DB	01H
	DB	0ffH
	DB	0ffH
	DB	0ffH
	DB	0ffH
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	070H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	01H
	DB	0ffH
	DB	0ffH
	DB	00H
CONST	ENDS
PUBLIC	__local_stdio_printf_options
PUBLIC	__local_stdio_scanf_options
PUBLIC	_vsnprintf_s_l
PUBLIC	_vsnprintf_s
PUBLIC	_vsscanf_l
PUBLIC	sscanf
PUBLIC	fetch_hw_noswap
PUBLIC	store_hw_noswap
PUBLIC	store_fw_noswap
PUBLIC	fetch_f3_noswap
PUBLIC	hdl_check_depends_ep
PUBLIC	hdl_register_symbols_ep
PUBLIC	hdl_define_devtypes_ep
EXTRN	__report_rangecheckfailure:PROC
EXTRN	__imp__errno:PROC
EXTRN	strcmp:PROC
EXTRN	__imp__stricmp:PROC
EXTRN	strlen:PROC
EXTRN	__imp_strdup:PROC
EXTRN	__imp_IsDebuggerPresent:PROC
EXTRN	__imp_OutputDebugStringA:PROC
EXTRN	__imp_calloc:PROC
EXTRN	__imp_free:PROC
EXTRN	__imp_malloc:PROC
EXTRN	__imp_exit:PROC
EXTRN	_byteswap_ushort:PROC
EXTRN	_byteswap_ulong:PROC
EXTRN	__imp_atoi:PROC
EXTRN	__imp_ntohl:PROC
EXTRN	__imp_WSAGetLastError:PROC
EXTRN	__imp_close:PROC
EXTRN	__imp___acrt_iob_func:PROC
EXTRN	__imp_ferror:PROC
EXTRN	__imp_fgetc:PROC
EXTRN	__imp_fopen:PROC
EXTRN	__imp___stdio_common_vsnprintf_s:PROC
EXTRN	__imp___stdio_common_vsscanf:PROC
EXTRN	__imp__time64:PROC
EXTRN	__imp_getpid:PROC
EXTRN	__imp_hthread_initialize_lock:PROC
EXTRN	__imp_hthread_obtain_lock:PROC
EXTRN	__imp_hthread_release_lock:PROC
EXTRN	__imp_hthread_initialize_condition:PROC
EXTRN	__imp_hthread_signal_condition:PROC
EXTRN	__imp_hthread_timed_wait_condition:PROC
EXTRN	__imp_hthread_create_thread:PROC
EXTRN	__imp_hthread_join_thread:PROC
EXTRN	__imp_hthread_detach_thread:PROC
EXTRN	__imp_ptt_pthread_trace:PROC
EXTRN	__imp_resolve_symbol_string:PROC
EXTRN	__imp_set_symbol:PROC
EXTRN	__imp_strlcpy:PROC
EXTRN	__imp_strlcat:PROC
EXTRN	__imp_timed_wait_condition_relative_usecs_impl:PROC
EXTRN	__imp_rtrim:PROC
EXTRN	__imp_w32_strerror:PROC
EXTRN	__imp_strtok_r:PROC
EXTRN	__imp_gettimeofday:PROC
EXTRN	__imp_usleep:PROC
EXTRN	__imp_inet_aton:PROC
EXTRN	__imp_hostpath:PROC
EXTRN	__imp_w32_socket:PROC
EXTRN	__imp_w32_snprintf:PROC
EXTRN	__imp_w32_fclose:PROC
EXTRN	__imp_w32_basename:PROC
EXTRN	tt32_write:PROC
EXTRN	tt32_beg_write_multi:PROC
EXTRN	tt32_end_write_multi:PROC
EXTRN	tt32_close:PROC
EXTRN	tt32_ioctl:PROC
EXTRN	display_tt32_stats:PROC
EXTRN	enable_tt32_debug_tracing:PROC
EXTRN	__imp_init_sysblk_netdev:PROC
EXTRN	__imp_group_device:PROC
EXTRN	__imp_getopt_long:PROC
EXTRN	__imp_device_attention:PROC
EXTRN	__imp_fwritemsg:PROC
EXTRN	__imp_logmsg:PROC
EXTRN	MACTabAdd:PROC
EXTRN	MACTabRem:PROC
EXTRN	IsMACTab:PROC
EXTRN	EtherIpv4CkSumOffload:PROC
EXTRN	read_tuntap:PROC
EXTRN	TUNTAP_CreateInterface:PROC
EXTRN	TUNTAP_SetIPAddr:PROC
EXTRN	TUNTAP_SetMTU:PROC
EXTRN	TUNTAP_SetMACAddr:PROC
EXTRN	TUNTAP_SetFlags:PROC
EXTRN	ParseMAC:PROC
EXTRN	FormatMAC:PROC
EXTRN	net_data_trace:PROC
EXTRN	__GSHandlerCheck:PROC
EXTRN	__chkstk:PROC
EXTRN	__security_check_cookie:PROC
EXTRN	memcmp:PROC
EXTRN	__imp_pttclass:QWORD
EXTRN	ctci_device_hndinfo:BYTE
EXTRN	ctct_device_hndinfo:BYTE
EXTRN	ctce_device_hndinfo:BYTE
EXTRN	__imp_sysblk:BYTE
EXTRN	__imp_optind:DWORD
EXTRN	__imp_optarg:QWORD
EXTRN	__ImageBase:BYTE
EXTRN	__security_cookie:QWORD
_DATA	SEGMENT
COMM	?_OptionsStorage@?1??__local_stdio_printf_options@@9@9:QWORD							; `__local_stdio_printf_options'::`2'::_OptionsStorage
COMM	?_OptionsStorage@?1??__local_stdio_scanf_options@@9@9:QWORD							; `__local_stdio_scanf_options'::`2'::_OptionsStorage
_DATA	ENDS
_BSS	SEGMENT
TokenLock DQ	01H DUP (?)
TokenLockInitialized DD 01H DUP (?)
$SG170274 DB	01H DUP (?)
	ALIGN	4

$SG170290 DB	01H DUP (?)
_BSS	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$_vsnprintf_s_l DD imagerel $LN5
	DD	imagerel $LN5+127
	DD	imagerel $unwind$_vsnprintf_s_l
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$_vsnprintf_s DD imagerel $LN3
	DD	imagerel $LN3+73
	DD	imagerel $unwind$_vsnprintf_s
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$_vsscanf_l DD imagerel $LN3
	DD	imagerel $LN3+80
	DD	imagerel $unwind$_vsscanf_l
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$sscanf DD imagerel $LN3
	DD	imagerel $LN3+79
	DD	imagerel $unwind$sscanf
pdata	ENDS
pdata	SEGMENT
$pdata$time DD	imagerel time
	DD	imagerel time+25
	DD	imagerel $unwind$time
$pdata$DebuggerTrace DD imagerel DebuggerTrace
	DD	imagerel DebuggerTrace+247
	DD	imagerel $unwind$DebuggerTrace
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$fetch_hw_noswap DD imagerel $LN3
	DD	imagerel $LN3+30
	DD	imagerel $unwind$fetch_hw_noswap
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$fetch_f3_noswap DD imagerel $LN3
	DD	imagerel $LN3+49
	DD	imagerel $unwind$fetch_f3_noswap
pdata	ENDS
pdata	SEGMENT
$pdata$LCS_Init DD imagerel $LN68
	DD	imagerel $LN68+5381
	DD	imagerel $unwind$LCS_Init
$pdata$LCS_Close DD imagerel $LN116
	DD	imagerel $LN116+3456
	DD	imagerel $unwind$LCS_Close
$pdata$LCS_Query DD imagerel $LN16
	DD	imagerel $LN16+666
	DD	imagerel $unwind$LCS_Query
$pdata$LCS_ExecuteCCW DD imagerel $LN78
	DD	imagerel $LN78+2336
	DD	imagerel $unwind$LCS_ExecuteCCW
$pdata$SetSIDInfo DD imagerel SetSIDInfo
	DD	imagerel SetSIDInfo+269
	DD	imagerel $unwind$SetSIDInfo
$pdata$LCS_Read DD imagerel LCS_Read
	DD	imagerel LCS_Read+2671
	DD	imagerel $unwind$LCS_Read
$pdata$LCS_Write DD imagerel LCS_Write
	DD	imagerel LCS_Write+7473
	DD	imagerel $unwind$LCS_Write
$pdata$LCS_Assist DD imagerel LCS_Assist
	DD	imagerel LCS_Assist+849
	DD	imagerel $unwind$LCS_Assist
$pdata$LCS_Startup DD imagerel LCS_Startup
	DD	imagerel LCS_Startup+912
	DD	imagerel $unwind$LCS_Startup
$pdata$LCS_Shutdown DD imagerel LCS_Shutdown
	DD	imagerel LCS_Shutdown+307
	DD	imagerel $unwind$LCS_Shutdown
$pdata$LCS_StartLan DD imagerel LCS_StartLan
	DD	imagerel LCS_StartLan+1176
	DD	imagerel $unwind$LCS_StartLan
$pdata$LCS_StopLan DD imagerel LCS_StopLan
	DD	imagerel LCS_StopLan+865
	DD	imagerel $unwind$LCS_StopLan
$pdata$LCS_QueryIPAssists DD imagerel LCS_QueryIPAssists
	DD	imagerel LCS_QueryIPAssists+414
	DD	imagerel $unwind$LCS_QueryIPAssists
$pdata$LCS_LanStats DD imagerel LCS_LanStats
	DD	imagerel LCS_LanStats+349
	DD	imagerel $unwind$LCS_LanStats
$pdata$LCS_AddMulticast DD imagerel LCS_AddMulticast
	DD	imagerel LCS_AddMulticast+49
	DD	imagerel $unwind$LCS_AddMulticast
$pdata$LCS_DelMulticast DD imagerel LCS_DelMulticast
	DD	imagerel LCS_DelMulticast+49
	DD	imagerel $unwind$LCS_DelMulticast
$pdata$LCS_DefaultCmdProc DD imagerel LCS_DefaultCmdProc
	DD	imagerel LCS_DefaultCmdProc+282
	DD	imagerel $unwind$LCS_DefaultCmdProc
$pdata$LCS_PortThread DD imagerel LCS_PortThread
	DD	imagerel LCS_PortThread+6768
	DD	imagerel $unwind$LCS_PortThread
$pdata$LCS_AttnThread DD imagerel LCS_AttnThread
	DD	imagerel LCS_AttnThread+2331
	DD	imagerel $unwind$LCS_AttnThread
$pdata$LCS_EnqueueEthFrame DD imagerel LCS_EnqueueEthFrame
	DD	imagerel LCS_EnqueueEthFrame+1272
	DD	imagerel $unwind$LCS_EnqueueEthFrame
$pdata$LCS_DoEnqueueEthFrame DD imagerel LCS_DoEnqueueEthFrame
	DD	imagerel LCS_DoEnqueueEthFrame+1589
	DD	imagerel $unwind$LCS_DoEnqueueEthFrame
$pdata$LCS_EnqueueReplyFrame DD imagerel LCS_EnqueueReplyFrame
	DD	imagerel LCS_EnqueueReplyFrame+1322
	DD	imagerel $unwind$LCS_EnqueueReplyFrame
$pdata$LCS_DoEnqueueReplyFrame DD imagerel LCS_DoEnqueueReplyFrame
	DD	imagerel LCS_DoEnqueueReplyFrame+1393
	DD	imagerel $unwind$LCS_DoEnqueueReplyFrame
$pdata$GetFrameInfo DD imagerel GetFrameInfo
	DD	imagerel GetFrameInfo+990
	DD	imagerel $unwind$GetFrameInfo
$pdata$GetIfMACAddress DD imagerel GetIfMACAddress
	DD	imagerel GetIfMACAddress+1290
	DD	imagerel $unwind$GetIfMACAddress
$pdata$BuildOAT DD imagerel BuildOAT
	DD	imagerel BuildOAT+4547
	DD	imagerel $unwind$BuildOAT
$pdata$ReadOAT DD imagerel ReadOAT
	DD	imagerel ReadOAT+611
	DD	imagerel $unwind$ReadOAT
$pdata$ParseArgs DD imagerel ParseArgs
	DD	imagerel ParseArgs+3496
	DD	imagerel $unwind$ParseArgs
$pdata$LCS_Read_SNA DD imagerel LCS_Read_SNA
	DD	imagerel LCS_Read_SNA+2073
	DD	imagerel $unwind$LCS_Read_SNA
$pdata$LCS_Write_SNA DD imagerel LCS_Write_SNA
	DD	imagerel LCS_Write_SNA+7416
	DD	imagerel $unwind$LCS_Write_SNA
$pdata$LCS_StartLan_SNA DD imagerel LCS_StartLan_SNA
	DD	imagerel LCS_StartLan_SNA+1278
	DD	imagerel $unwind$LCS_StartLan_SNA
$pdata$LCS_StopLan_SNA DD imagerel LCS_StopLan_SNA
	DD	imagerel LCS_StopLan_SNA+1363
	DD	imagerel $unwind$LCS_StopLan_SNA
$pdata$LCS_LanStats_SNA DD imagerel LCS_LanStats_SNA
	DD	imagerel LCS_LanStats_SNA+413
	DD	imagerel $unwind$LCS_LanStats_SNA
$pdata$LCS_UnsuppCmd_SNA DD imagerel LCS_UnsuppCmd_SNA
	DD	imagerel LCS_UnsuppCmd_SNA+324
	DD	imagerel $unwind$LCS_UnsuppCmd_SNA
$pdata$LCS_ProcessAccepted_SNA DD imagerel LCS_ProcessAccepted_SNA
	DD	imagerel LCS_ProcessAccepted_SNA+11550
	DD	imagerel $unwind$LCS_ProcessAccepted_SNA
$pdata$ExtractLLC DD imagerel ExtractLLC
	DD	imagerel ExtractLLC+1151
	DD	imagerel $unwind$ExtractLLC
$pdata$BuildLLC DD imagerel BuildLLC
	DD	imagerel BuildLLC+1039
	DD	imagerel $unwind$BuildLLC
$pdata$Process_0D10 DD imagerel Process_0D10
	DD	imagerel Process_0D10+1805
	DD	imagerel $unwind$Process_0D10
$pdata$Process_0D00 DD imagerel Process_0D00
	DD	imagerel Process_0D00+1237
	DD	imagerel $unwind$Process_0D00
$pdata$Process_8C0B DD imagerel Process_8C0B
	DD	imagerel Process_8C0B+1247
	DD	imagerel $unwind$Process_8C0B
$pdata$Process_0C0A DD imagerel Process_0C0A
	DD	imagerel Process_0C0A+1761
	DD	imagerel $unwind$Process_0C0A
$pdata$Process_0C25 DD imagerel Process_0C25
	DD	imagerel Process_0C25+1200
	DD	imagerel $unwind$Process_0C25
$pdata$Process_0C22 DD imagerel Process_0C22
	DD	imagerel Process_0C22+1643
	DD	imagerel $unwind$Process_0C22
$pdata$Process_8D00 DD imagerel Process_8D00
	DD	imagerel Process_8D00+1230
	DD	imagerel $unwind$Process_8D00
$pdata$Process_0C0B DD imagerel Process_0C0B
	DD	imagerel Process_0C0B+493
	DD	imagerel $unwind$Process_0C0B
$pdata$Process_0C99 DD imagerel Process_0C99
	DD	imagerel Process_0C99+318
	DD	imagerel $unwind$Process_0C99
$pdata$Process_0C0D DD imagerel Process_0C0D
	DD	imagerel Process_0C0D+226
	DD	imagerel $unwind$Process_0C0D
$pdata$Process_0C0E DD imagerel Process_0C0E
	DD	imagerel Process_0C0E+226
	DD	imagerel $unwind$Process_0C0E
$pdata$Process_0C98 DD imagerel Process_0C98
	DD	imagerel Process_0C98+226
	DD	imagerel $unwind$Process_0C98
$pdata$alloc_lcs_buffer DD imagerel alloc_lcs_buffer
	DD	imagerel alloc_lcs_buffer+366
	DD	imagerel $unwind$alloc_lcs_buffer
$pdata$add_lcs_buffer_to_chain DD imagerel add_lcs_buffer_to_chain
	DD	imagerel add_lcs_buffer_to_chain+167
	DD	imagerel $unwind$add_lcs_buffer_to_chain
$pdata$remove_lcs_buffer_from_chain DD imagerel remove_lcs_buffer_from_chain
	DD	imagerel remove_lcs_buffer_from_chain+145
	DD	imagerel $unwind$remove_lcs_buffer_from_chain
$pdata$remove_and_free_any_lcs_buffers_on_chain DD imagerel remove_and_free_any_lcs_buffers_on_chain
	DD	imagerel remove_and_free_any_lcs_buffers_on_chain+159
	DD	imagerel $unwind$remove_and_free_any_lcs_buffers_on_chain
$pdata$free_lcs_buffer DD imagerel free_lcs_buffer
	DD	imagerel free_lcs_buffer+36
	DD	imagerel $unwind$free_lcs_buffer
$pdata$alloc_connection DD imagerel alloc_connection
	DD	imagerel alloc_connection+322
	DD	imagerel $unwind$alloc_connection
$pdata$add_connection_to_chain DD imagerel add_connection_to_chain
	DD	imagerel add_connection_to_chain+132
	DD	imagerel $unwind$add_connection_to_chain
$pdata$find_connection_by_remote_mac DD imagerel find_connection_by_remote_mac
	DD	imagerel find_connection_by_remote_mac+100
	DD	imagerel $unwind$find_connection_by_remote_mac
$pdata$find_connection_by_outbound_token DD imagerel find_connection_by_outbound_token
	DD	imagerel find_connection_by_outbound_token+100
	DD	imagerel $unwind$find_connection_by_outbound_token
$pdata$find_connection_by_inbound_token DD imagerel find_connection_by_inbound_token
	DD	imagerel find_connection_by_inbound_token+100
	DD	imagerel $unwind$find_connection_by_inbound_token
$pdata$remove_connection_from_chain DD imagerel remove_connection_from_chain
	DD	imagerel remove_connection_from_chain+221
	DD	imagerel $unwind$remove_connection_from_chain
$pdata$remove_and_free_any_connections_on_chain DD imagerel remove_and_free_any_connections_on_chain
	DD	imagerel remove_and_free_any_connections_on_chain+146
	DD	imagerel $unwind$remove_and_free_any_connections_on_chain
$pdata$free_connection DD imagerel free_connection
	DD	imagerel free_connection+55
	DD	imagerel $unwind$free_connection
$pdata$find_group_device DD imagerel find_group_device
	DD	imagerel find_group_device+96
	DD	imagerel $unwind$find_group_device
$pdata$LCS_StartChannelProgram DD imagerel $LN5
	DD	imagerel $LN5+77
	DD	imagerel $unwind$LCS_StartChannelProgram
$pdata$LCS_EndChannelProgram DD imagerel $LN39
	DD	imagerel $LN39+1077
	DD	imagerel $unwind$LCS_EndChannelProgram
$pdata$LCS_BegMWrite DD imagerel LCS_BegMWrite
	DD	imagerel LCS_BegMWrite+231
	DD	imagerel $unwind$LCS_BegMWrite
$pdata$LCS_EndMWrite DD imagerel LCS_EndMWrite
	DD	imagerel LCS_EndMWrite+247
	DD	imagerel $unwind$LCS_EndMWrite
$pdata$UpdatePortStarted DD imagerel UpdatePortStarted
	DD	imagerel UpdatePortStarted+1292
	DD	imagerel $unwind$UpdatePortStarted
$pdata$LCS_DoMulticast DD imagerel LCS_DoMulticast
	DD	imagerel LCS_DoMulticast+2447
	DD	imagerel $unwind$LCS_DoMulticast
$pdata$lcs_halt_or_clear DD imagerel lcs_halt_or_clear
	DD	imagerel lcs_halt_or_clear+143
	DD	imagerel $unwind$lcs_halt_or_clear
$pdata$hdl_check_depends_ep DD imagerel $LN11
	DD	imagerel $LN11+110
	DD	imagerel $unwind$hdl_check_depends_ep
$pdata$hdl_register_symbols_ep DD imagerel $LN3
	DD	imagerel $LN3+50
	DD	imagerel $unwind$hdl_register_symbols_ep
$pdata$hdl_define_devtypes_ep DD imagerel $LN3
	DD	imagerel $LN3+86
	DD	imagerel $unwind$hdl_define_devtypes_ep
pdata	ENDS
_DATA	SEGMENT
uToken	DD	040000240H
$SG169533 DB	'E', 00H
	ORG $+2
$SG169532 DB	'malloc(%d)', 00H
	ORG $+1
$SG169558 DB	'E', 00H
	ORG $+2
$SG169534 DB	'HHC00900%s %1d:%04X %s: Error in function %s: %s', 0aH, 00H
	ORG $+2
$SG169564 DB	'E', 00H
	ORG $+2
$SG169535 DB	'LCS_Init', 00H
	ORG $+3
$SG169582 DB	'E', 00H
	ORG $+2
$SG169536 DB	'ctc_lcs.c', 00H
	ORG $+2
$SG169586 DB	'TAP', 00H
$SG169537 DB	'ctc_lcs.c:267', 00H
	ORG $+2
$SG169538 DB	'&pLCSBLK->AttnLock', 00H
	ORG $+1
$SG169587 DB	'I', 00H
	ORG $+2
$SG169539 DB	'ctc_lcs.c:268', 00H
	ORG $+2
$SG169540 DB	'&pLCSBLK->AttnEventLock', 00H
$SG169541 DB	'ctc_lcs.c:269', 00H
	ORG $+2
$SG169542 DB	'ctc_lcs.c:280', 00H
	ORG $+2
$SG169543 DB	'&pLCSPORT->PortDataLock', 00H
$SG169544 DB	'ctc_lcs.c:281', 00H
	ORG $+2
$SG169545 DB	'&pLCSPORT->PortEventLock', 00H
	ORG $+3
$SG169624 DB	'W', 00H
	ORG $+2
$SG169546 DB	'ctc_lcs.c:282', 00H
	ORG $+2
$SG169559 DB	'HHC00920%s %1d:%04X CTC: lcs device %04X not in configur'
	DB	'ation', 0aH, 00H
	ORG $+1
$SG169560 DB	'LCS_Init', 00H
	ORG $+3
$SG169630 DB	'W', 00H
	ORG $+2
$SG169561 DB	'ctc_lcs.c', 00H
	ORG $+2
$SG169637 DB	'E', 00H
	ORG $+2
$SG169565 DB	'HHC00920%s %1d:%04X CTC: lcs device %04X not in configur'
	DB	'ation', 0aH, 00H
	ORG $+1
$SG169566 DB	'LCS_Init', 00H
	ORG $+3
$SG169647 DB	'E', 00H
	ORG $+2
$SG169567 DB	'ctc_lcs.c', 00H
	ORG $+2
$SG169664 DB	'manual', 00H
	ORG $+1
$SG169666 DB	'I', 00H
	ORG $+2
$SG169568 DB	'ctc_lcs.c:424', 00H
	ORG $+2
$SG169569 DB	'&pLCSDev->DevDataLock', 00H
	ORG $+2
$SG169570 DB	'ctc_lcs.c:425', 00H
	ORG $+2
$SG169571 DB	'&pLCSDev->DevEventLock', 00H
	ORG $+1
$SG169572 DB	'ctc_lcs.c:426', 00H
	ORG $+2
$SG169573 DB	'ctc_lcs.c:427', 00H
	ORG $+2
$SG169574 DB	'&pLCSDev->LCSIBHChainLock', 00H
	ORG $+2
$SG169665 DB	'tuntap', 00H
	ORG $+1
$SG169672 DB	'I', 00H
	ORG $+2
$SG169575 DB	'ctc_lcs.c:428', 00H
	ORG $+2
$SG169576 DB	'&pLCSDev->LCSCONNChainLock', 00H
	ORG $+1
$SG170180 DB	'I', 00H
	ORG $+2
$SG169577 DB	'ctc_lcs.c:429', 00H
	ORG $+2
$SG169578 DB	'&pLCSDev->InOutLock', 00H
$SG170286 DB	'.', 00H
	ORG $+2
$SG169581 DB	'TUNTAP_CreateInterface', 00H
	ORG $+1
$SG169583 DB	'HHC00900%s %1d:%04X %s: Error in function %s: %s', 0aH, 00H
	ORG $+2
$SG169670 DB	'manual', 00H
	ORG $+1
$SG170289 DB	' -d', 00H
$SG169584 DB	'LCS_Init', 00H
	ORG $+3
$SG169671 DB	'tuntap', 00H
	ORG $+1
$SG170291 DB	'IP', 00H
	ORG $+1
$SG169585 DB	'ctc_lcs.c', 00H
	ORG $+2
$SG170292 DB	'SNA', 00H
$SG169588 DB	'HHC00901%s %1d:%04X %s: Interface %s, type %s opened', 0aH
	DB	00H
	ORG $+2
$SG169589 DB	'LCS_Init', 00H
	ORG $+3
$SG170652 DB	'D', 00H
	ORG $+2
$SG169590 DB	'ctc_lcs.c', 00H
	ORG $+2
$SG170658 DB	'D', 00H
	ORG $+2
$SG169594 DB	'LCS_Init', 00H
	ORG $+3
$SG170683 DB	'D', 00H
	ORG $+2
$SG169595 DB	'ctc_lcs.c', 00H
	ORG $+2
$SG169603 DB	'1500', 00H
	ORG $+7
$SG169596 DB	'%s(%d) : warning HHC90999W : *** Assertion Failed! *** f'
	DB	'unction: %s', 0aH, 00H
	ORG $+3
$SG169598 DB	'LCS_Init', 00H
	ORG $+3
$SG170689 DB	'D', 00H
	ORG $+2
$SG169599 DB	'ctc_lcs.c', 00H
	ORG $+6
$SG169613 DB	'0.0.0.0', 00H
$SG169600 DB	'%s(%d) : warning HHC90999W : *** Assertion Failed! *** f'
	DB	'unction: %s', 0aH, 00H
	ORG $+3
$SG169604 DB	'LCS_Init', 00H
	ORG $+3
$SG170704 DB	'E', 00H
	ORG $+2
$SG169605 DB	'ctc_lcs.c', 00H
	ORG $+6
$SG169623 DB	'TT32SDEVBUFF', 00H
	ORG $+3
$SG169634 DB	'%s %4.4X Port %d Thread', 00H
$SG169606 DB	'%s(%d) : warning HHC90999W : *** Assertion Failed! *** f'
	DB	'unction: %s', 0aH, 00H
	ORG $+3
$SG169608 DB	'LCS_Init', 00H
	ORG $+3
$SG170719 DB	'D', 00H
	ORG $+2
$SG169609 DB	'ctc_lcs.c', 00H
	ORG $+6
$SG169625 DB	'HHC00902%s %1d:%04X %s: ioctl %s failed for device %s: %'
	DB	's', 0aH, 00H
	ORG $+5
$SG169629 DB	'TT32SIOBUFF', 00H
$SG170276 DB	' Pri', 00H
	ORG $+7
$SG169610 DB	'%s(%d) : warning HHC90999W : *** Assertion Failed! *** f'
	DB	'unction: %s', 0aH, 00H
	ORG $+3
$SG169614 DB	'LCS_Init', 00H
	ORG $+3
$SG170729 DB	'D', 00H
	ORG $+2
$SG169615 DB	'ctc_lcs.c', 00H
	ORG $+6
$SG169631 DB	'HHC00902%s %1d:%04X %s: ioctl %s failed for device %s: %'
	DB	's', 0aH, 00H
	ORG $+5
$SG169635 DB	'ctc_lcs.c:524', 00H
	ORG $+2
$SG169638 DB	'HHC00102%s Error in function create_thread(): %s', 0aH, 00H
	ORG $+6
$SG169616 DB	'%s(%d) : warning HHC90999W : *** Assertion Failed! *** f'
	DB	'unction: %s', 0aH, 00H
	ORG $+3
$SG169618 DB	'LCS_Init', 00H
	ORG $+3
$SG170739 DB	'D', 00H
	ORG $+2
$SG169619 DB	'ctc_lcs.c', 00H
	ORG $+6
$SG169644 DB	'%s %4.4X AttnThread', 00H
	ORG $+4
$SG169620 DB	'%s(%d) : warning HHC90999W : *** Assertion Failed! *** f'
	DB	'unction: %s', 0aH, 00H
	ORG $+3
$SG169626 DB	'LCS_Init', 00H
	ORG $+3
$SG170749 DB	'D', 00H
	ORG $+2
$SG169627 DB	'ctc_lcs.c', 00H
	ORG $+2
$SG170759 DB	'D', 00H
	ORG $+2
$SG169632 DB	'LCS_Init', 00H
	ORG $+3
$SG170769 DB	'D', 00H
	ORG $+2
$SG169633 DB	'ctc_lcs.c', 00H
	ORG $+2
$SG170779 DB	'D', 00H
	ORG $+2
$SG169639 DB	'LCS_Init', 00H
	ORG $+3
$SG170789 DB	'D', 00H
	ORG $+2
$SG169640 DB	'ctc_lcs.c', 00H
	ORG $+2
$SG170799 DB	'D', 00H
	ORG $+2
$SG169645 DB	'ctc_lcs.c:558', 00H
	ORG $+2
$SG169648 DB	'HHC00102%s Error in function create_thread(): %s', 0aH, 00H
	ORG $+2
$SG170809 DB	'D', 00H
	ORG $+2
$SG169649 DB	'LCS_Init', 00H
	ORG $+3
$SG170819 DB	'D', 00H
	ORG $+2
$SG169650 DB	'ctc_lcs.c', 00H
	ORG $+2
$SG170827 DB	'E', 00H
	ORG $+2
$SG169652 DB	'ctc_lcs.c:569', 00H
	ORG $+2
$SG169653 DB	'&TokenLock', 00H
	ORG $+5
$SG169667 DB	'HHC00921%s CTC: lcs device port %2.2X: %s Multicast assi'
	DB	'st enabled', 0aH, 00H
$SG170876 DB	'LCS', 00H
$SG169668 DB	'LCS_Assist', 00H
	ORG $+1
$SG170877 DB	'W', 00H
	ORG $+2
$SG169669 DB	'ctc_lcs.c', 00H
	ORG $+6
$SG169674 DB	'LCS_Assist', 00H
	ORG $+5
$SG169779 DB	'ctc_lcs.c:846', 00H
	ORG $+2
$SG169780 DB	'GET  DevDataLock  ', 00H
	ORG $+5
$SG169673 DB	'HHC00935%s CTC: lcs device port %2.2X: %s Checksum Offlo'
	DB	'ad enabled', 0aH, 00H
$SG170882 DB	'LCS', 00H
$SG169675 DB	'ctc_lcs.c', 00H
	ORG $+2
$SG170883 DB	'W', 00H
	ORG $+2
$SG169781 DB	'ctc_lcs.c:847', 00H
	ORG $+2
$SG169783 DB	'ctc_lcs.c:848', 00H
	ORG $+2
$SG169784 DB	'GOT  DevDataLock  ', 00H
	ORG $+1
$SG171009 DB	'I', 00H
	ORG $+2
$SG169786 DB	'ctc_lcs.c:853', 00H
	ORG $+2
$SG169787 DB	'REL  DevDataLock  ', 00H
	ORG $+1
$SG171325 DB	'???', 00H
$SG169788 DB	'ctc_lcs.c:854', 00H
	ORG $+2
$SG169891 DB	'ctc_lcs.c:1000', 00H
	ORG $+1
$SG169892 DB	'GET  AttnLock', 00H
	ORG $+2
$SG169893 DB	'ctc_lcs.c:1001', 00H
	ORG $+1
$SG169895 DB	'ctc_lcs.c:1002', 00H
	ORG $+1
$SG169896 DB	'GOT  AttnLock', 00H
	ORG $+2
$SG169898 DB	'ctc_lcs.c:1004', 00H
	ORG $+1
$SG169899 DB	'ADD  Attn', 00H
	ORG $+2
$SG171340 DB	'D', 00H
	ORG $+2
$SG169901 DB	'ctc_lcs.c:1008', 00H
	ORG $+1
$SG169902 DB	'REL  AttnLock', 00H
	ORG $+2
$SG169903 DB	'ctc_lcs.c:1009', 00H
	ORG $+1
$SG169905 DB	'ctc_lcs.c:1012', 00H
	ORG $+1
$SG169906 DB	'GET  AttnEventLock ', 00H
$SG171356 DB	'D', 00H
	ORG $+2
$SG169907 DB	'ctc_lcs.c:1013', 00H
	ORG $+1
$SG169909 DB	'ctc_lcs.c:1014', 00H
	ORG $+1
$SG169910 DB	'GOT  AttnEventLock ', 00H
$SG171361 DB	'E', 00H
	ORG $+2
$SG169912 DB	'ctc_lcs.c:1016', 00H
	ORG $+1
$SG169913 DB	'SIG  AttnEvent', 00H
	ORG $+1
$SG169914 DB	'ctc_lcs.c:1017', 00H
	ORG $+1
$SG169916 DB	'ctc_lcs.c:1019', 00H
	ORG $+1
$SG169917 DB	'REL  AttnEventLock ', 00H
$SG171367 DB	'???', 00H
$SG169918 DB	'ctc_lcs.c:1020', 00H
	ORG $+1
$SG170160 DB	'ctc_lcs.c:1048', 00H
	ORG $+1
$SG170161 DB	'CLOSE: ENTRY      ', 00H
	ORG $+1
$SG171380 DB	'D', 00H
	ORG $+2
$SG170165 DB	'ctc_lcs.c:1053', 00H
	ORG $+1
$SG170166 DB	'CLOSE: is last    ', 00H
	ORG $+1
$SG171385 DB	'E', 00H
	ORG $+2
$SG170169 DB	'ctc_lcs.c:1078', 00H
	ORG $+1
$SG170170 DB	'CLOSE: closing... ', 00H
	ORG $+1
$SG171497 DB	'D', 00H
	ORG $+2
$SG170172 DB	'ctc_lcs.c:1079', 00H
	ORG $+1
$SG170173 DB	'GET  PortEventLock', 00H
	ORG $+1
$SG171511 DB	'D', 00H
	ORG $+2
$SG170174 DB	'ctc_lcs.c:1080', 00H
	ORG $+1
$SG170176 DB	'ctc_lcs.c:1081', 00H
	ORG $+1
$SG170177 DB	'GOT  PortEventLock', 00H
	ORG $+1
$SG171891 DB	'D', 00H
	ORG $+2
$SG170181 DB	'HHC00966%s %1d:%04X CTC: lcs triggering port %2.2X event'
	DB	0aH, 00H
	ORG $+2
$SG171895 DB	'D', 00H
	ORG $+2
$SG170182 DB	'LCS_Close', 00H
	ORG $+2
$SG171922 DB	'D', 00H
	ORG $+2
$SG170183 DB	'ctc_lcs.c', 00H
	ORG $+2
$SG171942 DB	'E', 00H
	ORG $+2
$SG170185 DB	'ctc_lcs.c:1087', 00H
	ORG $+1
$SG170186 DB	'CLOSING started=NO', 00H
	ORG $+1
$SG171947 DB	'D', 00H
	ORG $+2
$SG170188 DB	'ctc_lcs.c:1089', 00H
	ORG $+1
$SG170189 DB	'SET  closeInProg  ', 00H
	ORG $+1
$SG171953 DB	'D', 00H
	ORG $+2
$SG170191 DB	'ctc_lcs.c:1091', 00H
	ORG $+1
$SG170192 DB	'SIG  PortEvent    ', 00H
	ORG $+1
$SG171964 DB	'D', 00H
	ORG $+2
$SG170193 DB	'ctc_lcs.c:1092', 00H
	ORG $+1
$SG170195 DB	'ctc_lcs.c:1094', 00H
	ORG $+1
$SG170196 DB	'REL  PortEventLock', 00H
	ORG $+1
$SG171979 DB	'D', 00H
	ORG $+2
$SG170197 DB	'ctc_lcs.c:1095', 00H
	ORG $+1
$SG170199 DB	'ctc_lcs.c:1096', 00H
	ORG $+1
$SG170200 DB	'join_thread       ', 00H
	ORG $+1
$SG171993 DB	'D', 00H
	ORG $+2
$SG170201 DB	'ctc_lcs.c:1097', 00H
	ORG $+1
$SG170203 DB	'ctc_lcs.c:1098', 00H
	ORG $+1
$SG170204 DB	'detach_thread     ', 00H
	ORG $+1
$SG172004 DB	'D', 00H
	ORG $+2
$SG170205 DB	'ctc_lcs.c:1099', 00H
	ORG $+1
$SG170209 DB	'ctc_lcs.c:1107', 00H
	ORG $+1
$SG170210 DB	'CLOSE: closed     ', 00H
	ORG $+1
$SG172016 DB	'D', 00H
	ORG $+2
$SG170212 DB	'ctc_lcs.c:1110', 00H
	ORG $+1
$SG170213 DB	'CLOSE: not last   ', 00H
	ORG $+1
$SG172027 DB	'D', 00H
	ORG $+2
$SG170215 DB	'ctc_lcs.c:1112', 00H
	ORG $+1
$SG170216 DB	'CLOSE: cleaning up', 00H
	ORG $+1
$SG172037 DB	'D', 00H
	ORG $+2
$SG170228 DB	'ctc_lcs.c:1159', 00H
	ORG $+1
$SG170229 DB	'CLOSE: closing... ', 00H
	ORG $+1
$SG172154 DB	'W', 00H
	ORG $+2
$SG170231 DB	'ctc_lcs.c:1160', 00H
	ORG $+1
$SG170232 DB	'GET  AttnEventLock', 00H
	ORG $+1
$SG172164 DB	'D', 00H
	ORG $+2
$SG170233 DB	'ctc_lcs.c:1161', 00H
	ORG $+1
$SG170235 DB	'ctc_lcs.c:1162', 00H
	ORG $+1
$SG170236 DB	'GOT  AttnEventLock', 00H
	ORG $+1
$SG172535 DB	'I', 00H
	ORG $+2
$SG170238 DB	'ctc_lcs.c:1164', 00H
	ORG $+1
$SG170239 DB	'SET  closeInProg  ', 00H
	ORG $+1
$SG172547 DB	'D', 00H
	ORG $+2
$SG170241 DB	'ctc_lcs.c:1166', 00H
	ORG $+1
$SG170242 DB	'SIG  AttnEvent', 00H
	ORG $+1
$SG170243 DB	'ctc_lcs.c:1167', 00H
	ORG $+1
$SG170245 DB	'ctc_lcs.c:1169', 00H
	ORG $+1
$SG170246 DB	'REL  AttnEventLock', 00H
	ORG $+1
$SG172553 DB	'D', 00H
	ORG $+2
$SG170247 DB	'ctc_lcs.c:1170', 00H
	ORG $+1
$SG170249 DB	'ctc_lcs.c:1171', 00H
	ORG $+1
$SG170250 DB	'join_thread       ', 00H
	ORG $+1
$SG172597 DB	'ARP', 00H
$SG170251 DB	'ctc_lcs.c:1172', 00H
	ORG $+1
$SG170253 DB	'ctc_lcs.c:1173', 00H
	ORG $+1
$SG170254 DB	'detach_thread     ', 00H
	ORG $+1
$SG172603 DB	'SNA', 00H
$SG170255 DB	'ctc_lcs.c:1174', 00H
	ORG $+1
$SG170257 DB	'ctc_lcs.c:1183', 00H
	ORG $+1
$SG170258 DB	'CLOSE: EXIT       ', 00H
	ORG $+1
$SG170278 DB	' Sec', 00H
	ORG $+3
$SG170280 DB	'CTCA', 00H
	ORG $+3
$SG171501 DB	'reply', 00H
	ORG $+2
$SG172605 DB	'802.3 ', 00H
	ORG $+1
$SG172617 DB	'ARP', 00H
$SG170288 DB	'*Uninitialized', 00H
	ORG $+1
$SG170293 DB	'LCS Port %2.2X %s%s (%s)%s IO[%llu]', 00H
$SG172623 DB	'SNA', 00H
$SG170319 DB	'ctc_lcs.c:1229', 00H
	ORG $+1
$SG170320 DB	'b4 begmw', 00H
	ORG $+3
$SG172608 DB	'SNAP ', 00H
	ORG $+2
$SG172628 DB	'SNA', 00H
$SG170322 DB	'ctc_lcs.c:1231', 00H
	ORG $+1
$SG170323 DB	'af begmw', 00H
	ORG $+3
$SG172645 DB	'E', 00H
	ORG $+2
$SG170353 DB	'ctc_lcs.c:1237', 00H
	ORG $+1
$SG170354 DB	'b4 endmw', 00H
	ORG $+3
$SG172651 DB	'E', 00H
	ORG $+2
$SG170356 DB	'ctc_lcs.c:1239', 00H
	ORG $+1
$SG170357 DB	'af endmw', 00H
	ORG $+7
$SG170653 DB	'HHC00981%s %1d:%04X %s: Accept data of size %d bytes fro'
	DB	'm guest', 0aH, 00H
	ORG $+3
$SG172655 DB	'I', 00H
	ORG $+2
$SG170654 DB	'LCS_Write', 00H
	ORG $+2
$SG172661 DB	'W', 00H
	ORG $+2
$SG170655 DB	'ctc_lcs.c', 00H
	ORG $+2
$SG170662 DB	'data', 00H
	ORG $+7
$SG170659 DB	'HHC00980%s %1d:%04X %s: Data of size %d bytes displayed,'
	DB	' data of size %d bytes not displayed', 0aH, 00H
	ORG $+2
$SG170660 DB	'LCS_Write', 00H
	ORG $+2
$SG172731 DB	'SNA', 00H
$SG170661 DB	'ctc_lcs.c', 00H
	ORG $+2
$SG172734 DB	'IP', 00H
	ORG $+1
$SG170664 DB	'ctc_lcs.c:1335', 00H
	ORG $+1
$SG170665 DB	'WRIT ENTRY        ', 00H
	ORG $+1
$SG172736 DB	'E', 00H
	ORG $+2
$SG170667 DB	'ctc_lcs.c:1336', 00H
	ORG $+1
$SG170668 DB	'beg write', 00H
	ORG $+2
$SG172743 DB	'E', 00H
	ORG $+2
$SG170672 DB	'ctc_lcs.c:1361', 00H
	ORG $+1
$SG170673 DB	'WRIT: Eth frame   ', 00H
	ORG $+1
$SG172751 DB	'E', 00H
	ORG $+2
$SG170677 DB	'ctc_lcs.c:1381', 00H
	ORG $+1
$SG170678 DB	'beg csumoff', 00H
$SG172760 DB	'E', 00H
	ORG $+2
$SG170680 DB	'ctc_lcs.c:1383', 00H
	ORG $+1
$SG170681 DB	'end csumoff', 00H
	ORG $+4
$SG170684 DB	'HHC00983%s %1d:%04X %s: port %2.2X: Send frame of size %'
	DB	'd bytes (with %s packet) to device %s', 0aH, 00H
	ORG $+1
$SG170685 DB	'LCS_Write', 00H
	ORG $+2
$SG172768 DB	'E', 00H
	ORG $+2
$SG170686 DB	'ctc_lcs.c', 00H
	ORG $+6
$SG170690 DB	'HHC00980%s %1d:%04X %s: Data of size %d bytes displayed,'
	DB	' data of size %d bytes not displayed', 0aH, 00H
	ORG $+2
$SG170691 DB	'LCS_Write', 00H
	ORG $+2
$SG172777 DB	'E', 00H
	ORG $+2
$SG170692 DB	'ctc_lcs.c', 00H
	ORG $+2
$SG172785 DB	'E', 00H
	ORG $+2
$SG170693 DB	'eth frame', 00H
	ORG $+2
$SG172793 DB	'E', 00H
	ORG $+2
$SG170695 DB	'ctc_lcs.c:1410', 00H
	ORG $+1
$SG170696 DB	'WRIT: writing...  ', 00H
	ORG $+1
$SG172802 DB	'E', 00H
	ORG $+2
$SG170698 DB	'ctc_lcs.c:1411', 00H
	ORG $+1
$SG170699 DB	'b4 write', 00H
	ORG $+3
$SG172808 DB	'E', 00H
	ORG $+2
$SG170702 DB	'ctc_lcs.c:1414', 00H
	ORG $+1
$SG170703 DB	'*WRITE ERR', 00H
	ORG $+1
$SG172881 DB	'r', 00H
	ORG $+2
$SG170705 DB	'HHC00936%s %1d:%04X CTC: error writing to file %s: %s', 0aH
	DB	00H
	ORG $+1
$SG170706 DB	'LCS_Write', 00H
	ORG $+2
$SG172884 DB	'E', 00H
	ORG $+2
$SG170707 DB	'ctc_lcs.c', 00H
	ORG $+2
$SG172890 DB	'$(CUU)', 00H
	ORG $+1
$SG172891 DB	'CUU', 00H
$SG170709 DB	'ctc_lcs.c:1422', 00H
	ORG $+1
$SG170710 DB	'WRIT EXIT         ', 00H
	ORG $+1
$SG172897 DB	' ', 09H, 00H
	ORG $+1
$SG170712 DB	'ctc_lcs.c:1425', 00H
	ORG $+1
$SG170713 DB	'af write', 00H
	ORG $+3
$SG172898 DB	' ', 09H, 00H
	ORG $+1
$SG170716 DB	'ctc_lcs.c:1432', 00H
	ORG $+1
$SG170717 DB	'WRIT: Cmd frame   ', 00H
	ORG $+1
$SG172899 DB	' ', 09H, 00H
	ORG $+1
$SG170720 DB	'HHC00922%s %1d:%04X CTC: lcs command packet received', 0aH
	DB	00H
	ORG $+2
$SG170721 DB	'LCS_Write', 00H
	ORG $+2
$SG172907 DB	'E', 00H
	ORG $+2
$SG170722 DB	'ctc_lcs.c', 00H
	ORG $+2
$SG172914 DB	'MAC', 00H
$SG170723 DB	'command', 00H
$SG170726 DB	'ctc_lcs.c:1466', 00H
	ORG $+1
$SG170727 DB	'CMD initiator LGW', 00H
	ORG $+6
$SG170730 DB	'HHC00977%s %1d:%04X CTC: lcs command packet ignored (bIn'
	DB	'itiator == LGW)', 0aH, 00H
	ORG $+3
$SG172902 DB	'HWADD', 00H
	ORG $+2
$SG172915 DB	'E', 00H
	ORG $+2
$SG170731 DB	'LCS_Write', 00H
	ORG $+2
$SG172926 DB	'E', 00H
	ORG $+2
$SG170732 DB	'ctc_lcs.c', 00H
	ORG $+2
$SG172933 DB	'E', 00H
	ORG $+2
$SG170735 DB	'ctc_lcs.c:1478', 00H
	ORG $+1
$SG170736 DB	'CMD=StartUp       ', 00H
	ORG $+1
$SG172940 DB	'E', 00H
	ORG $+2
$SG170738 DB	'startup', 00H
$SG170740 DB	'HHC00933%s %1d:%04X CTC: executing command %s', 0aH, 00H
	ORG $+1
$SG170741 DB	'LCS_Write', 00H
	ORG $+2
$SG172948 DB	'E', 00H
	ORG $+2
$SG170742 DB	'ctc_lcs.c', 00H
	ORG $+2
$SG172956 DB	'E', 00H
	ORG $+2
$SG170745 DB	'ctc_lcs.c:1485', 00H
	ORG $+1
$SG170746 DB	'CMD=Shutdown      ', 00H
	ORG $+1
$SG172962 DB	'IP', 00H
	ORG $+1
$SG170748 DB	'shutdown', 00H
	ORG $+3
$SG172905 DB	'%hi%c', 00H
	ORG $+2
$SG172964 DB	'E', 00H
	ORG $+2
$SG170750 DB	'HHC00933%s %1d:%04X CTC: executing command %s', 0aH, 00H
	ORG $+1
$SG170751 DB	'LCS_Write', 00H
	ORG $+2
$SG172971 DB	'E', 00H
	ORG $+2
$SG170752 DB	'ctc_lcs.c', 00H
	ORG $+2
$SG172978 DB	'PRI', 00H
$SG170755 DB	'ctc_lcs.c:1492', 00H
	ORG $+1
$SG170756 DB	'CMD=Start LAN     ', 00H
	ORG $+1
$SG172981 DB	'SEC', 00H
$SG170758 DB	'start lan', 00H
	ORG $+2
$SG172984 DB	'NO', 00H
	ORG $+1
$SG170760 DB	'HHC00933%s %1d:%04X CTC: executing command %s', 0aH, 00H
	ORG $+1
$SG170761 DB	'LCS_Write', 00H
	ORG $+2
$SG172985 DB	'E', 00H
	ORG $+2
$SG170762 DB	'ctc_lcs.c', 00H
	ORG $+2
$SG172992 DB	'E', 00H
	ORG $+2
$SG170765 DB	'ctc_lcs.c:1499', 00H
	ORG $+1
$SG170766 DB	'CMD=Stop LAN      ', 00H
	ORG $+1
$SG172998 DB	'SNA', 00H
$SG170768 DB	'stop lan', 00H
	ORG $+3
$SG172906 DB	'HWADD', 00H
	ORG $+2
$SG173000 DB	'E', 00H
	ORG $+2
$SG170770 DB	'HHC00933%s %1d:%04X CTC: executing command %s', 0aH, 00H
	ORG $+1
$SG170771 DB	'LCS_Write', 00H
	ORG $+2
$SG173007 DB	'E', 00H
	ORG $+2
$SG170772 DB	'ctc_lcs.c', 00H
	ORG $+2
$SG173012 DB	'E', 00H
	ORG $+2
$SG170775 DB	'ctc_lcs.c:1506', 00H
	ORG $+1
$SG170776 DB	'CMD=Query IPAssist', 00H
	ORG $+1
$SG173016 DB	'E', 00H
	ORG $+2
$SG170778 DB	'query IP assist', 00H
$SG170780 DB	'HHC00933%s %1d:%04X CTC: executing command %s', 0aH, 00H
	ORG $+1
$SG170781 DB	'LCS_Write', 00H
	ORG $+2
$SG173043 DB	'E', 00H
	ORG $+2
$SG170782 DB	'ctc_lcs.c', 00H
	ORG $+2
$SG173056 DB	'E', 00H
	ORG $+2
$SG170785 DB	'ctc_lcs.c:1513', 00H
	ORG $+1
$SG170786 DB	'CMD=LAN Statistics', 00H
	ORG $+1
$SG173312 DB	'D', 00H
	ORG $+2
$SG170788 DB	'lan statistics', 00H
	ORG $+1
$SG170790 DB	'HHC00933%s %1d:%04X CTC: executing command %s', 0aH, 00H
	ORG $+1
$SG170791 DB	'LCS_Write', 00H
	ORG $+2
$SG173060 DB	' ', 09H, 0aH, 0bH, 0cH, 0dH, 00H
	ORG $+1
$SG173644 DB	'D', 00H
	ORG $+2
$SG170792 DB	'ctc_lcs.c', 00H
	ORG $+2
$SG173650 DB	'D', 00H
	ORG $+2
$SG170795 DB	'ctc_lcs.c:1520', 00H
	ORG $+1
$SG170796 DB	'CMD=Set IP Multicast', 00H
	ORG $+3
$SG170798 DB	'set multicast', 00H
	ORG $+2
$SG170800 DB	'HHC00933%s %1d:%04X CTC: executing command %s', 0aH, 00H
	ORG $+1
$SG170801 DB	'LCS_Write', 00H
	ORG $+2
$SG173698 DB	'W', 00H
	ORG $+2
$SG170802 DB	'ctc_lcs.c', 00H
	ORG $+2
$SG173712 DB	'D', 00H
	ORG $+2
$SG170805 DB	'ctc_lcs.c:1527', 00H
	ORG $+1
$SG170806 DB	'CMD=Delete IP Multicast', 00H
$SG170808 DB	'delete multicast', 00H
	ORG $+3
$SG172913 DB	'HWADD', 00H
	ORG $+2
$SG173722 DB	'D', 00H
	ORG $+2
$SG170810 DB	'HHC00933%s %1d:%04X CTC: executing command %s', 0aH, 00H
	ORG $+1
$SG170811 DB	'LCS_Write', 00H
	ORG $+2
$SG173730 DB	'E', 00H
	ORG $+2
$SG170812 DB	'ctc_lcs.c', 00H
	ORG $+2
$SG173775 DB	'D', 00H
	ORG $+2
$SG170815 DB	'ctc_lcs.c:1538', 00H
	ORG $+1
$SG170816 DB	'*CMD=Unsupported! ', 00H
	ORG $+1
$SG173785 DB	'D', 00H
	ORG $+2
$SG170818 DB	'other (0x%2.2X)', 00H
$SG170820 DB	'HHC00933%s %1d:%04X CTC: executing command %s', 0aH, 00H
	ORG $+1
$SG170821 DB	'LCS_Write', 00H
	ORG $+2
$SG173795 DB	'D', 00H
	ORG $+2
$SG170822 DB	'ctc_lcs.c', 00H
	ORG $+2
$SG173803 DB	'E', 00H
	ORG $+2
$SG170825 DB	'ctc_lcs.c:1553', 00H
	ORG $+1
$SG170826 DB	'*WRIT Unsupp frame', 00H
	ORG $+5
$SG170841 DB	'ctc_lcs.c:1560', 00H
	ORG $+1
$SG170845 DB	'WRIT EXIT         ', 00H
	ORG $+5
$SG170828 DB	'HHC00937%s %1d:%04X CTC: lcs write: unsupported frame ty'
	DB	'pe 0x%2.2X', 0aH, 00H
$SG173824 DB	'E', 00H
	ORG $+2
$SG170829 DB	'LCS_Write', 00H
	ORG $+2
$SG173881 DB	'W', 00H
	ORG $+2
$SG170830 DB	'ctc_lcs.c', 00H
	ORG $+2
$SG173889 DB	'W', 00H
	ORG $+2
$SG170832 DB	'LCS_Write', 00H
	ORG $+2
$SG173896 DB	'D', 00H
	ORG $+2
$SG170833 DB	'ctc_lcs.c', 00H
	ORG $+6
$SG170844 DB	'ctc_lcs.c:1561', 00H
	ORG $+1
$SG170851 DB	'WRIT EXIT         ', 00H
	ORG $+5
$SG170834 DB	'%s(%d) : warning HHC90999W : *** Assertion Failed! *** f'
	DB	'unction: %s', 0aH, 00H
	ORG $+3
$SG170836 DB	'LCS_Write', 00H
	ORG $+2
$SG173902 DB	'D', 00H
	ORG $+2
$SG170837 DB	'ctc_lcs.c', 00H
	ORG $+6
$SG170847 DB	'ctc_lcs.c:1577', 00H
	ORG $+1
$SG170995 DB	'GET  PortDataLock ', 00H
	ORG $+5
$SG170838 DB	'%s(%d) : warning HHC90999W : *** Assertion Failed! *** f'
	DB	'unction: %s', 0aH, 00H
	ORG $+3
$SG170842 DB	'end write', 00H
	ORG $+2
$SG173911 DB	'D', 00H
	ORG $+2
$SG170848 DB	'end write', 00H
	ORG $+2
$SG173974 DB	'W', 00H
	ORG $+2
$SG170850 DB	'ctc_lcs.c:1578', 00H
	ORG $+1
$SG170999 DB	'GOT  PortDataLock ', 00H
	ORG $+5
$SG170878 DB	'HHC00939%s %1d:%04X CTC: lcs startup: frame buffer size '
	DB	'0x%4.4X %s compiled size 0x%4.4X: ignored', 0aH, 00H
	ORG $+1
$SG173980 DB	'D', 00H
	ORG $+2
$SG170879 DB	'LCS_Startup', 00H
$SG173990 DB	'D', 00H
	ORG $+2
$SG170880 DB	'ctc_lcs.c', 00H
	ORG $+6
$SG170885 DB	'LCS_Startup', 00H
$SG172557 DB	'data', 00H
	ORG $+7
$SG170884 DB	'HHC00939%s %1d:%04X CTC: lcs startup: frame buffer size '
	DB	'0x%4.4X %s compiled size 0x%4.4X: ignored', 0aH, 00H
	ORG $+1
$SG174050 DB	'W', 00H
	ORG $+2
$SG170886 DB	'ctc_lcs.c', 00H
	ORG $+2
$SG174056 DB	'D', 00H
	ORG $+2
$SG170994 DB	'ctc_lcs.c:1664', 00H
	ORG $+1
$SG170996 DB	'ctc_lcs.c:1665', 00H
	ORG $+1
$SG170998 DB	'ctc_lcs.c:1666', 00H
	ORG $+1
$SG171001 DB	'ctc_lcs.c:1671', 00H
	ORG $+1
$SG171002 DB	'UPDTPORTSTARTED   ', 00H
	ORG $+1
$SG174064 DB	'UA', 00H
	ORG $+1
$SG171004 DB	'ctc_lcs.c:1674', 00H
	ORG $+1
$SG171005 DB	'REL  PortDataLock ', 00H
	ORG $+1
$SG174066 DB	'D', 00H
	ORG $+2
$SG171006 DB	'ctc_lcs.c:1675', 00H
	ORG $+1
$SG171010 DB	'HHC00966%s %1d:%04X CTC: lcs triggering port %2.2X event'
	DB	0aH, 00H
	ORG $+2
$SG174132 DB	'I', 00H
	ORG $+2
$SG171011 DB	'UpdatePortStarted', 00H
	ORG $+2
$SG174141 DB	'I', 00H
	ORG $+2
$SG171012 DB	'ctc_lcs.c', 00H
	ORG $+2
$SG174150 DB	'I', 00H
	ORG $+2
$SG171014 DB	'ctc_lcs.c:1681', 00H
	ORG $+1
$SG171015 DB	'GET  PortEventLock', 00H
	ORG $+1
$SG174157 DB	'E', 00H
	ORG $+2
$SG171016 DB	'ctc_lcs.c:1682', 00H
	ORG $+1
$SG171018 DB	'ctc_lcs.c:1683', 00H
	ORG $+1
$SG171019 DB	'GOT  PortEventLock', 00H
	ORG $+1
$SG174166 DB	'I', 00H
	ORG $+2
$SG171021 DB	'ctc_lcs.c:1687', 00H
	ORG $+1
$SG171022 DB	'SIG  PortEvent    ', 00H
	ORG $+1
$SG174222 DB	'W', 00H
	ORG $+2
$SG171023 DB	'ctc_lcs.c:1688', 00H
	ORG $+1
$SG171025 DB	'ctc_lcs.c:1690', 00H
	ORG $+1
$SG171026 DB	'REL  PortEventLock', 00H
	ORG $+1
$SG174228 DB	'D', 00H
	ORG $+2
$SG171027 DB	'ctc_lcs.c:1691', 00H
	ORG $+1
$SG171029 DB	'ctc_lcs.c:1693', 00H
	ORG $+1
$SG171030 DB	'UPDTPORT pause 150', 00H
	ORG $+1
$SG174238 DB	'D', 00H
	ORG $+2
$SG171105 DB	'ctc_lcs.c:1722', 00H
	ORG $+1
$SG171106 DB	'GET  PortDataLock ', 00H
	ORG $+1
$SG174296 DB	'W', 00H
	ORG $+2
$SG171107 DB	'ctc_lcs.c:1723', 00H
	ORG $+1
$SG171109 DB	'ctc_lcs.c:1724', 00H
	ORG $+1
$SG171110 DB	'GOT  PortDataLock ', 00H
	ORG $+1
$SG174305 DB	'D', 00H
	ORG $+2
$SG171112 DB	'ctc_lcs.c:1727', 00H
	ORG $+1
$SG171113 DB	'STRTLAN if started', 00H
	ORG $+1
$SG174311 DB	'D', 00H
	ORG $+2
$SG171116 DB	'ctc_lcs.c:1730', 00H
	ORG $+1
$SG171117 DB	'STRTLAN started=NO', 00H
	ORG $+1
$SG174319 DB	'XID', 00H
$SG171120 DB	'LCS_StartLan', 00H
	ORG $+3
$SG171121 DB	'ctc_lcs.c', 00H
	ORG $+6
$SG171124 DB	'LCS_StartLan', 00H
	ORG $+3
$SG171129 DB	'ctc_lcs.c:1774', 00H
	ORG $+1
$SG171130 DB	'REL  PortDataLock ', 00H
	ORG $+5
$SG171122 DB	'%s(%d) : warning HHC90999W : *** Assertion Failed! *** f'
	DB	'unction: %s', 0aH, 00H
	ORG $+3
$SG171125 DB	'ctc_lcs.c', 00H
	ORG $+6
$SG171131 DB	'ctc_lcs.c:1775', 00H
	ORG $+1
$SG171188 DB	'GET  PortDataLock ', 00H
	ORG $+5
$SG171126 DB	'%s(%d) : warning HHC90999W : *** Assertion Failed! *** f'
	DB	'unction: %s', 0aH, 00H
	ORG $+3
$SG171187 DB	'ctc_lcs.c:1830', 00H
	ORG $+1
$SG171189 DB	'ctc_lcs.c:1831', 00H
	ORG $+1
$SG171191 DB	'ctc_lcs.c:1832', 00H
	ORG $+1
$SG171192 DB	'GOT  PortDataLock ', 00H
	ORG $+1
$SG174321 DB	'D', 00H
	ORG $+2
$SG171195 DB	'LCS_StopLan', 00H
$SG174381 DB	'W', 00H
	ORG $+2
$SG171196 DB	'ctc_lcs.c', 00H
	ORG $+6
$SG171197 DB	'%s(%d) : warning HHC90999W : *** Assertion Failed! *** f'
	DB	'unction: %s', 0aH, 00H
	ORG $+3
$SG171199 DB	'LCS_StopLan', 00H
$SG174387 DB	'D', 00H
	ORG $+2
$SG171200 DB	'ctc_lcs.c', 00H
	ORG $+6
$SG171204 DB	'ctc_lcs.c:1874', 00H
	ORG $+1
$SG171205 DB	'REL  PortDataLock ', 00H
	ORG $+5
$SG171201 DB	'%s(%d) : warning HHC90999W : *** Assertion Failed! *** f'
	DB	'unction: %s', 0aH, 00H
	ORG $+3
$SG171206 DB	'ctc_lcs.c:1875', 00H
	ORG $+1
$SG171323 DB	'MACTabAdd', 00H
	ORG $+2
$SG174395 DB	'UA', 00H
	ORG $+1
$SG171324 DB	'MACTabRem', 00H
	ORG $+2
$SG174397 DB	'D', 00H
	ORG $+2
$SG171332 DB	'LCS_DoMulticast', 00H
$SG171333 DB	'ctc_lcs.c', 00H
	ORG $+6
$SG171336 DB	'LCS_DoMulticast', 00H
$SG171341 DB	'HHC00964%s CTC: lcs device ''%s'' port %2.2X: %s %s: ok', 0aH
	DB	00H
	ORG $+1
$SG171334 DB	'%s(%d) : warning HHC90999W : *** Assertion Failed! *** f'
	DB	'unction: %s', 0aH, 00H
	ORG $+3
$SG171337 DB	'ctc_lcs.c', 00H
	ORG $+6
$SG171342 DB	'LCS_DoMulticast', 00H
$SG171357 DB	'HHC00964%s CTC: lcs device ''%s'' port %2.2X: %s %s: ok', 0aH
	DB	00H
	ORG $+1
$SG171338 DB	'%s(%d) : warning HHC90999W : *** Assertion Failed! *** f'
	DB	'unction: %s', 0aH, 00H
	ORG $+3
$SG171343 DB	'ctc_lcs.c', 00H
	ORG $+2
$SG174450 DB	'W', 00H
	ORG $+2
$SG171348 DB	'LCS_DoMulticast', 00H
$SG171349 DB	'ctc_lcs.c', 00H
	ORG $+6
$SG171352 DB	'LCS_DoMulticast', 00H
$SG171381 DB	'HHC00964%s CTC: lcs device ''%s'' port %2.2X: %s %s: ok', 0aH
	DB	00H
	ORG $+1
$SG171350 DB	'%s(%d) : warning HHC90999W : *** Assertion Failed! *** f'
	DB	'unction: %s', 0aH, 00H
	ORG $+3
$SG171353 DB	'ctc_lcs.c', 00H
	ORG $+6
$SG171358 DB	'LCS_DoMulticast', 00H
$SG171386 DB	'HHC00941%s CTC: ioctl %s failed for device %s: %s', 0aH, 00H
	ORG $+5
$SG171354 DB	'%s(%d) : warning HHC90999W : *** Assertion Failed! *** f'
	DB	'unction: %s', 0aH, 00H
	ORG $+3
$SG171359 DB	'ctc_lcs.c', 00H
	ORG $+2
$SG175104 DB	'D', 00H
	ORG $+2
$SG171362 DB	'HHC00940%s CTC: error in function %s: %s', 0aH, 00H
	ORG $+2
$SG175110 DB	'W', 00H
	ORG $+2
$SG171363 DB	'LCS_DoMulticast', 00H
$SG171364 DB	'ctc_lcs.c', 00H
	ORG $+2
$SG175125 DB	'D', 00H
	ORG $+2
$SG171365 DB	'SIOCADDMULTI', 00H
	ORG $+3
$SG171366 DB	'SIOCDELMULTI', 00H
	ORG $+3
$SG171372 DB	'LCS_DoMulticast', 00H
$SG171373 DB	'ctc_lcs.c', 00H
	ORG $+6
$SG171376 DB	'LCS_DoMulticast', 00H
$SG171498 DB	'HHC00923%s %1d:%04X CTC: lcs command reply enqueue', 0aH
	DB	00H
	ORG $+4
$SG171374 DB	'%s(%d) : warning HHC90999W : *** Assertion Failed! *** f'
	DB	'unction: %s', 0aH, 00H
	ORG $+3
$SG171377 DB	'ctc_lcs.c', 00H
	ORG $+6
$SG171382 DB	'LCS_DoMulticast', 00H
$SG171499 DB	'LCS_EnqueueReplyFrame', 00H
	ORG $+2
$SG171378 DB	'%s(%d) : warning HHC90999W : *** Assertion Failed! *** f'
	DB	'unction: %s', 0aH, 00H
	ORG $+3
$SG171383 DB	'ctc_lcs.c', 00H
	ORG $+2
$SG175135 DB	'D', 00H
	ORG $+2
$SG171387 DB	'LCS_DoMulticast', 00H
$SG171388 DB	'ctc_lcs.c', 00H
	ORG $+2
$SG175151 DB	'D', 00H
	ORG $+2
$SG171500 DB	'ctc_lcs.c', 00H
	ORG $+2
$SG175157 DB	'W', 00H
	ORG $+2
$SG171503 DB	'ctc_lcs.c:2155', 00H
	ORG $+1
$SG171504 DB	'ENQ RepFrame ENTRY', 00H
	ORG $+1
$SG175165 DB	'D', 00H
	ORG $+2
$SG171506 DB	'ctc_lcs.c:2159', 00H
	ORG $+1
$SG171507 DB	'b4 repNQ', 00H
	ORG $+3
$SG172921 DB	'ROUTE', 00H
	ORG $+2
$SG175175 DB	'D', 00H
	ORG $+2
$SG171510 DB	'%8.08X %d.%d.%d.%d', 00H
	ORG $+5
$SG171512 DB	'HHC00978%s CTC: lcs device port %2.2X: STILL trying to e'
	DB	'nqueue REPLY frame to device %4.4X %s', 0aH, 00H
	ORG $+1
$SG171513 DB	'LCS_EnqueueReplyFrame', 00H
	ORG $+2
$SG171514 DB	'ctc_lcs.c', 00H
	ORG $+2
$SG175186 DB	'D', 00H
	ORG $+2
$SG171516 DB	'ctc_lcs.c:2189', 00H
	ORG $+1
$SG171517 DB	'*repNQ wait', 00H
$SG175194 DB	'D', 00H
	ORG $+2
$SG171519 DB	'LCS_EnqueueReplyFrame', 00H
	ORG $+2
$SG171520 DB	'ctc_lcs.c', 00H
	ORG $+6
$SG171521 DB	'%s(%d) : warning HHC90999W : *** Assertion Failed! *** f'
	DB	'unction: %s', 0aH, 00H
	ORG $+3
$SG171523 DB	'LCS_EnqueueReplyFrame', 00H
	ORG $+2
$SG171524 DB	'ctc_lcs.c', 00H
	ORG $+6
$SG171525 DB	'%s(%d) : warning HHC90999W : *** Assertion Failed! *** f'
	DB	'unction: %s', 0aH, 00H
	ORG $+3
$SG171528 DB	'ctc_lcs.c:2196', 00H
	ORG $+1
$SG171529 DB	'af repNQ', 00H
	ORG $+3
$SG172924 DB	'%hi%c', 00H
	ORG $+2
$SG175192 DB	'Reject', 00H
	ORG $+1
$SG175202 DB	'DM', 00H
	ORG $+1
$SG171531 DB	'ctc_lcs.c:2197', 00H
	ORG $+1
$SG171532 DB	'ENQ RepFrame EXIT ', 00H
	ORG $+1
$SG175204 DB	'D', 00H
	ORG $+2
$SG171636 DB	'ctc_lcs.c:2219', 00H
	ORG $+1
$SG171637 DB	'GET  DevDataLock  ', 00H
	ORG $+1
$SG175212 DB	'D', 00H
	ORG $+2
$SG171638 DB	'ctc_lcs.c:2220', 00H
	ORG $+1
$SG171640 DB	'ctc_lcs.c:2221', 00H
	ORG $+1
$SG171641 DB	'GOT  DevDataLock  ', 00H
	ORG $+1
$SG175218 DB	'W', 00H
	ORG $+2
$SG171644 DB	'ctc_lcs.c:2229', 00H
	ORG $+1
$SG171645 DB	'*DoENQRep ENOBUFS ', 00H
	ORG $+1
$SG175224 DB	'UA', 00H
	ORG $+1
$SG171647 DB	'ctc_lcs.c:2230', 00H
	ORG $+1
$SG171648 DB	'REL  DevDataLock  ', 00H
	ORG $+1
$SG175226 DB	'D', 00H
	ORG $+2
$SG171649 DB	'ctc_lcs.c:2231', 00H
	ORG $+1
$SG171651 DB	'ctc_lcs.c:2250', 00H
	ORG $+1
$SG171652 DB	'SET  ReplyPending ', 00H
	ORG $+1
$SG175232 DB	'W', 00H
	ORG $+2
$SG171654 DB	'ctc_lcs.c:2253', 00H
	ORG $+1
$SG171655 DB	'REL  DevDataLock  ', 00H
	ORG $+1
$SG175240 DB	'D', 00H
	ORG $+2
$SG171656 DB	'ctc_lcs.c:2254', 00H
	ORG $+1
$SG171658 DB	'ctc_lcs.c:2257', 00H
	ORG $+1
$SG171659 DB	'GET  DevEventLock ', 00H
	ORG $+1
$SG175246 DB	'W', 00H
	ORG $+2
$SG171660 DB	'ctc_lcs.c:2258', 00H
	ORG $+1
$SG171662 DB	'ctc_lcs.c:2259', 00H
	ORG $+1
$SG171663 DB	'GOT  DevEventLock ', 00H
	ORG $+1
$SG175254 DB	'D', 00H
	ORG $+2
$SG171665 DB	'ctc_lcs.c:2261', 00H
	ORG $+1
$SG171666 DB	'SIG  DevEvent     ', 00H
	ORG $+1
$SG175259 DB	'D', 00H
	ORG $+2
$SG171667 DB	'ctc_lcs.c:2262', 00H
	ORG $+1
$SG171669 DB	'ctc_lcs.c:2264', 00H
	ORG $+1
$SG171670 DB	'REL  DevEventLock ', 00H
	ORG $+1
$SG175265 DB	'XID', 00H
$SG171671 DB	'ctc_lcs.c:2265', 00H
	ORG $+1
$SG171879 DB	'ctc_lcs.c:2308', 00H
	ORG $+1
$SG171880 DB	'PORTHRD: ENTRY    ', 00H
	ORG $+1
$SG175267 DB	'D', 00H
	ORG $+2
$SG171882 DB	'ctc_lcs.c:2312', 00H
	ORG $+1
$SG171883 DB	'GET  PortEventLock', 00H
	ORG $+1
$SG175275 DB	'W', 00H
	ORG $+2
$SG171884 DB	'ctc_lcs.c:2313', 00H
	ORG $+1
$SG171886 DB	'ctc_lcs.c:2314', 00H
	ORG $+1
$SG171887 DB	'GOT  PortEventLock', 00H
	ORG $+5
$SG171893 DB	'LCS_PortThread', 00H
	ORG $+1
$SG171901 DB	'PORTHRD if started', 00H
	ORG $+5
$SG171892 DB	'HHC00969%s CTC: lcs device port %2.2X: read thread: port'
	DB	' stopped', 0aH, 00H
	ORG $+2
$SG175283 DB	'W', 00H
	ORG $+2
$SG171894 DB	'ctc_lcs.c', 00H
	ORG $+6
$SG171897 DB	'LCS_PortThread', 00H
	ORG $+1
$SG171909 DB	'PORTHRD is closing', 00H
	ORG $+5
$SG171896 DB	'HHC00967%s CTC: lcs device port %2.2X: read thread: wait'
	DB	'ing for start event', 0aH, 00H
	ORG $+3
$SG171898 DB	'ctc_lcs.c', 00H
	ORG $+2
$SG175289 DB	'I', 00H
	ORG $+2
$SG171900 DB	'ctc_lcs.c:2334', 00H
	ORG $+1
$SG171908 DB	'ctc_lcs.c:2342', 00H
	ORG $+1
$SG171911 DB	'ctc_lcs.c:2344', 00H
	ORG $+1
$SG171912 DB	'PORTHRD is started', 00H
	ORG $+1
$SG175298 DB	'I', 00H
	ORG $+2
$SG171914 DB	'ctc_lcs.c:2348', 00H
	ORG $+1
$SG171915 DB	'WAIT PortEventLock', 00H
	ORG $+1
$SG175305 DB	'W', 00H
	ORG $+2
$SG171916 DB	'ctc_lcs.c:2355', 00H
	ORG $+1
$SG171918 DB	'ctc_lcs.c:2356', 00H
	ORG $+1
$SG171919 DB	'WOKE PortEventLock', 00H
	ORG $+5
$SG171924 DB	'LCS_PortThread', 00H
	ORG $+1
$SG171928 DB	'REL  PortEventLock', 00H
	ORG $+5
$SG171923 DB	'HHC00968%s CTC: lcs device port %2.2X: read thread: port'
	DB	' started', 0aH, 00H
	ORG $+2
$SG175318 DB	'D', 00H
	ORG $+2
$SG171925 DB	'ctc_lcs.c', 00H
	ORG $+2
$SG175326 DB	'W', 00H
	ORG $+2
$SG171927 DB	'ctc_lcs.c:2368', 00H
	ORG $+1
$SG171929 DB	'ctc_lcs.c:2369', 00H
	ORG $+1
$SG171933 DB	'ctc_lcs.c:2377', 00H
	ORG $+1
$SG171934 DB	'b4 tt read', 00H
	ORG $+1
$SG175332 DB	'D', 00H
	ORG $+2
$SG171936 DB	'ctc_lcs.c:2379', 00H
	ORG $+1
$SG171937 DB	'af tt read', 00H
	ORG $+5
$SG171944 DB	'LCS_PortThread', 00H
	ORG $+1
$SG171963 DB	'%8.08X %d.%d.%d.%d', 00H
	ORG $+5
$SG171943 DB	'HHC00944%s CTC: lcs interface %s read error from port %2'
	DB	'.2X: %s', 0aH, 00H
	ORG $+3
$SG172925 DB	'ROUTE', 00H
	ORG $+2
$SG175342 DB	'D', 00H
	ORG $+2
$SG171945 DB	'ctc_lcs.c', 00H
	ORG $+6
$SG171948 DB	'HHC00984%s %1d:%04X %s: port %2.2X: Receive frame of siz'
	DB	'e %d bytes (with %s packet) from device %s', 0aH, 00H
$SG175383 DB	'W', 00H
	ORG $+2
$SG171949 DB	'LCS_PortThread', 00H
	ORG $+1
$SG171950 DB	'ctc_lcs.c', 00H
	ORG $+6
$SG171955 DB	'LCS_PortThread', 00H
	ORG $+1
$SG171978 DB	'%8.08X %d.%d.%d.%d', 00H
	ORG $+5
$SG171954 DB	'HHC00945%s CTC: lcs device port %2.2X: MCAST not in tabl'
	DB	'e, discarding frame', 0aH, 00H
	ORG $+3
$SG171956 DB	'ctc_lcs.c', 00H
	ORG $+6
$SG171965 DB	'HHC00946%s CTC: lcs device port %2.2X: IPv4 frame receiv'
	DB	'ed for %s', 0aH, 00H
	ORG $+1
$SG175481 DB	'D', 00H
	ORG $+2
$SG171966 DB	'LCS_PortThread', 00H
	ORG $+1
$SG171967 DB	'ctc_lcs.c', 00H
	ORG $+6
$SG171981 DB	'LCS_PortThread', 00H
	ORG $+1
$SG172046 DB	'PORTHRD Closing...', 00H
	ORG $+5
$SG171980 DB	'HHC00947%s CTC: lcs device port %2.2X: ARP frame receive'
	DB	'd for %s', 0aH, 00H
	ORG $+2
$SG175487 DB	'D', 00H
	ORG $+2
$SG171982 DB	'ctc_lcs.c', 00H
	ORG $+6
$SG171995 DB	'LCS_PortThread', 00H
	ORG $+1
$SG172058 DB	'PORTHRD started=NO', 00H
	ORG $+5
$SG171994 DB	'HHC00948%s CTC: lcs device port %2.2X: RARP frame receiv'
	DB	'ed for %2.2X:%2.2X:%2.2X:%2.2X:%2.2X:%2.2X', 0aH, 00H
$SG175560 DB	'E', 00H
	ORG $+2
$SG171996 DB	'ctc_lcs.c', 00H
	ORG $+6
$SG172006 DB	'LCS_PortThread', 00H
	ORG $+1
$SG172061 DB	'PORTHRD: EXIT     ', 00H
	ORG $+5
$SG172005 DB	'HHC00949%s CTC: lcs device port %2.2X: SNA frame receive'
	DB	'd for %2.2X:%2.2X:%2.2X:%2.2X:%2.2X:%2.2X', 0aH, 00H
	ORG $+1
$SG175616 DB	'E', 00H
	ORG $+2
$SG172007 DB	'ctc_lcs.c', 00H
	ORG $+6
$SG172018 DB	'LCS_PortThread', 00H
	ORG $+1
$SG172149 DB	'ENQ EthFrame ENTRY', 00H
	ORG $+5
$SG172017 DB	'HHC00951%s CTC: lcs device port %2.2X: no match found, d'
	DB	'iscarding frame', 0aH, 00H
	ORG $+3
$SG172931 DB	'ROUTE', 00H
	ORG $+2
$SG175728 DB	'DEVBLK', 00H
	ORG $+1
$SG175741 DB	'LCS', 00H
$SG172019 DB	'ctc_lcs.c', 00H
	ORG $+6
$SG172022 DB	'discarding', 00H
	ORG $+5
$SG172028 DB	'HHC00951%s CTC: lcs device port %2.2X: no match found, d'
	DB	'iscarding frame', 0aH, 00H
	ORG $+7
$SG172029 DB	'LCS_PortThread', 00H
	ORG $+1
$SG172030 DB	'ctc_lcs.c', 00H
	ORG $+6
$SG172033 DB	'discarding', 00H
	ORG $+5
$SG172038 DB	'HHC00980%s %1d:%04X %s: Data of size %d bytes displayed,'
	DB	' data of size %d bytes not displayed', 0aH, 00H
	ORG $+2
$SG172039 DB	'LCS_PortThread', 00H
	ORG $+1
$SG172040 DB	'ctc_lcs.c', 00H
	ORG $+6
$SG172041 DB	'eth frame', 00H
	ORG $+6
$SG172045 DB	'ctc_lcs.c:2696', 00H
	ORG $+1
$SG172048 DB	'LCS_PortThread', 00H
	ORG $+1
$SG172049 DB	'ctc_lcs.c', 00H
	ORG $+6
$SG172050 DB	'%s(%d) : warning HHC90999W : *** Assertion Failed! *** f'
	DB	'unction: %s', 0aH, 00H
	ORG $+3
$SG172052 DB	'LCS_PortThread', 00H
	ORG $+1
$SG172053 DB	'ctc_lcs.c', 00H
	ORG $+6
$SG172057 DB	'ctc_lcs.c:2723', 00H
	ORG $+1
$SG172156 DB	'LCS_EnqueueEthFrame', 00H
	ORG $+4
$SG172054 DB	'%s(%d) : warning HHC90999W : *** Assertion Failed! *** f'
	DB	'unction: %s', 0aH, 00H
	ORG $+3
$SG172060 DB	'ctc_lcs.c:2728', 00H
	ORG $+1
$SG172148 DB	'ctc_lcs.c:2754', 00H
	ORG $+1
$SG172151 DB	'ctc_lcs.c:2758', 00H
	ORG $+1
$SG172152 DB	'b4 enqueue', 00H
	ORG $+5
$SG172159 DB	'ctc_lcs.c:2772', 00H
	ORG $+1
$SG172163 DB	'%8.08X %d.%d.%d.%d', 00H
	ORG $+5
$SG172155 DB	'HHC00953%s CTC: lcs device port %2.2X: packet frame too '
	DB	'big, dropped', 0aH, 00H
	ORG $+2
$SG172157 DB	'ctc_lcs.c', 00H
	ORG $+6
$SG172160 DB	'*enq drop', 00H
	ORG $+6
$SG172166 DB	'LCS_EnqueueEthFrame', 00H
	ORG $+4
$SG172165 DB	'HHC00965%s CTC: lcs device port %2.2X: STILL trying to e'
	DB	'nqueue frame to device %4.4X %s', 0aH, 00H
	ORG $+7
$SG172167 DB	'ctc_lcs.c', 00H
	ORG $+6
$SG172169 DB	'ctc_lcs.c:2796', 00H
	ORG $+1
$SG172170 DB	'*enq wait', 00H
	ORG $+6
$SG172172 DB	'LCS_EnqueueEthFrame', 00H
	ORG $+4
$SG172173 DB	'ctc_lcs.c', 00H
	ORG $+6
$SG172176 DB	'LCS_EnqueueEthFrame', 00H
	ORG $+4
$SG172174 DB	'%s(%d) : warning HHC90999W : *** Assertion Failed! *** f'
	DB	'unction: %s', 0aH, 00H
	ORG $+3
$SG172177 DB	'ctc_lcs.c', 00H
	ORG $+6
$SG172181 DB	'ctc_lcs.c:2803', 00H
	ORG $+1
$SG172185 DB	'ENQ EthFrame EXIT ', 00H
	ORG $+5
$SG172178 DB	'%s(%d) : warning HHC90999W : *** Assertion Failed! *** f'
	DB	'unction: %s', 0aH, 00H
	ORG $+3
$SG172182 DB	'af enqueue', 00H
	ORG $+5
$SG172184 DB	'ctc_lcs.c:2804', 00H
	ORG $+1
$SG172306 DB	'ctc_lcs.c:2840', 00H
	ORG $+1
$SG172307 DB	'*DoENQEth EMSGSIZE', 00H
	ORG $+5
$SG172309 DB	'ctc_lcs.c:2845', 00H
	ORG $+1
$SG172310 DB	'GET  DevDataLock  ', 00H
	ORG $+5
$SG172311 DB	'ctc_lcs.c:2846', 00H
	ORG $+1
$SG172313 DB	'ctc_lcs.c:2847', 00H
	ORG $+1
$SG172314 DB	'GOT  DevDataLock  ', 00H
	ORG $+5
$SG172317 DB	'ctc_lcs.c:2856', 00H
	ORG $+1
$SG172318 DB	'*DoENQEth ENOBUFS ', 00H
	ORG $+5
$SG172320 DB	'ctc_lcs.c:2857', 00H
	ORG $+1
$SG172321 DB	'REL  DevDataLock  ', 00H
	ORG $+5
$SG172322 DB	'ctc_lcs.c:2858', 00H
	ORG $+1
$SG172324 DB	'ctc_lcs.c:2881', 00H
	ORG $+1
$SG172325 DB	'SET  DataPending  ', 00H
	ORG $+5
$SG172327 DB	'ctc_lcs.c:2884', 00H
	ORG $+1
$SG172328 DB	'REL  DevDataLock  ', 00H
	ORG $+5
$SG172329 DB	'ctc_lcs.c:2885', 00H
	ORG $+1
$SG172331 DB	'ctc_lcs.c:2888', 00H
	ORG $+1
$SG172332 DB	'GET  DevEventLock ', 00H
	ORG $+5
$SG172333 DB	'ctc_lcs.c:2889', 00H
	ORG $+1
$SG172335 DB	'ctc_lcs.c:2890', 00H
	ORG $+1
$SG172336 DB	'GOT  DevEventLock ', 00H
	ORG $+5
$SG172338 DB	'ctc_lcs.c:2892', 00H
	ORG $+1
$SG172339 DB	'SIG  DevEvent     ', 00H
	ORG $+5
$SG172340 DB	'ctc_lcs.c:2893', 00H
	ORG $+1
$SG172342 DB	'ctc_lcs.c:2895', 00H
	ORG $+1
$SG172343 DB	'REL  DevEventLock ', 00H
	ORG $+5
$SG172344 DB	'ctc_lcs.c:2896', 00H
	ORG $+1
$SG172351 DB	'ctc_lcs.c:2912', 00H
	ORG $+1
$SG172353 DB	'ctc_lcs.c:2917', 00H
	ORG $+1
$SG172354 DB	'ctc_lcs.c:2920', 00H
	ORG $+1
$SG172500 DB	'ctc_lcs.c:2946', 00H
	ORG $+1
$SG172501 DB	'READ: ENTRY       ', 00H
	ORG $+5
$SG172503 DB	'ctc_lcs.c:2952', 00H
	ORG $+1
$SG172504 DB	'GET  DevDataLock  ', 00H
	ORG $+5
$SG172505 DB	'ctc_lcs.c:2953', 00H
	ORG $+1
$SG172507 DB	'ctc_lcs.c:2954', 00H
	ORG $+1
$SG172508 DB	'GOT  DevDataLock  ', 00H
	ORG $+5
$SG172512 DB	'ctc_lcs.c:2959', 00H
	ORG $+1
$SG172513 DB	'REL  DevDataLock  ', 00H
	ORG $+5
$SG172514 DB	'ctc_lcs.c:2960', 00H
	ORG $+1
$SG172516 DB	'ctc_lcs.c:2969', 00H
	ORG $+1
$SG172517 DB	'GET  DevEventLock ', 00H
	ORG $+5
$SG172518 DB	'ctc_lcs.c:2970', 00H
	ORG $+1
$SG172520 DB	'ctc_lcs.c:2971', 00H
	ORG $+1
$SG172521 DB	'GOT  DevEventLock ', 00H
	ORG $+5
$SG172523 DB	'ctc_lcs.c:2973', 00H
	ORG $+1
$SG172524 DB	'WAIT DevEventLock ', 00H
	ORG $+5
$SG172525 DB	'ctc_lcs.c:2977', 00H
	ORG $+1
$SG172527 DB	'ctc_lcs.c:2981', 00H
	ORG $+1
$SG172528 DB	'WOKE DevEventLock ', 00H
	ORG $+5
$SG172531 DB	'ctc_lcs.c:2991', 00H
	ORG $+1
$SG172532 DB	'*HALT or CLEAR*   ', 00H
	ORG $+5
$SG172536 DB	'HHC00904%s %1d:%04X %s: Halt or clear recognized', 0aH, 00H
	ORG $+6
$SG172537 DB	'LCS_Read', 00H
	ORG $+7
$SG172538 DB	'ctc_lcs.c', 00H
	ORG $+6
$SG172539 DB	'ctc_lcs.c:2996', 00H
	ORG $+1
$SG172540 DB	'ctc_lcs.c:2999', 00H
	ORG $+1
$SG172542 DB	'ctc_lcs.c:3006', 00H
	ORG $+1
$SG172543 DB	'READ using buffer ', 00H
	ORG $+5
$SG172559 DB	'ctc_lcs.c:3092', 00H
	ORG $+1
$SG172560 DB	'READ empty buffer ', 00H
	ORG $+5
$SG172548 DB	'HHC00982%s %1d:%04X %s: Present data of size %d bytes to'
	DB	' guest', 0aH, 00H
$SG172549 DB	'LCS_Read', 00H
	ORG $+7
$SG172550 DB	'ctc_lcs.c', 00H
	ORG $+6
$SG172554 DB	'HHC00980%s %1d:%04X %s: Data of size %d bytes displayed,'
	DB	' data of size %d bytes not displayed', 0aH, 00H
	ORG $+2
$SG172555 DB	'LCS_Read', 00H
	ORG $+7
$SG172556 DB	'ctc_lcs.c', 00H
	ORG $+6
$SG172562 DB	'ctc_lcs.c:3097', 00H
	ORG $+1
$SG172563 DB	'REL  DevDataLock  ', 00H
	ORG $+5
$SG172564 DB	'ctc_lcs.c:3098', 00H
	ORG $+1
$SG172566 DB	'ctc_lcs.c:3100', 00H
	ORG $+1
$SG172567 DB	'READ: EXIT        ', 00H
	ORG $+1
$SG172591 DB	'IPv4', 00H
	ORG $+3
$SG172594 DB	'IPv6', 00H
	ORG $+3
$SG172600 DB	'RARP', 00H
	ORG $+7
$SG172604 DB	'unknown', 00H
$SG172611 DB	'IPv4', 00H
	ORG $+3
$SG172614 DB	'IPv6', 00H
	ORG $+3
$SG172620 DB	'RARP', 00H
	ORG $+3
$SG172624 DB	'unknown', 00H
$SG172629 DB	'unknown', 00H
$SG172644 DB	'socket()', 00H
	ORG $+7
$SG172646 DB	'HHC00940%s CTC: error in function %s: %s', 0aH, 00H
	ORG $+6
$SG172647 DB	'GetIfMACAddress', 00H
$SG172648 DB	'ctc_lcs.c', 00H
	ORG $+6
$SG172650 DB	'SIOCGIFHWADDR', 00H
	ORG $+2
$SG172652 DB	'HHC00941%s CTC: ioctl %s failed for device %s: %s', 0aH, 00H
	ORG $+5
$SG172653 DB	'GetIfMACAddress', 00H
$SG172654 DB	'ctc_lcs.c', 00H
	ORG $+6
$SG172656 DB	'HHC00942%s CTC: lcs interface %s using mac %2.2X:%2.2X:%'
	DB	'2.2X:%2.2X:%2.2X:%2.2X', 0aH, 00H
$SG172657 DB	'GetIfMACAddress', 00H
$SG172658 DB	'ctc_lcs.c', 00H
	ORG $+6
$SG172662 DB	'HHC00943%s CTC: lcs interface %s not using mac %2.2X:%2.'
	DB	'2X:%2.2X:%2.2X:%2.2X:%2.2X', 0aH, 00H
	ORG $+4
$SG172663 DB	'GetIfMACAddress', 00H
$SG172664 DB	'ctc_lcs.c', 00H
	ORG $+6
$SG172665 DB	'%2.2X:%2.2X:%2.2X:%2.2X:%2.2X:%2.2X', 00H
	ORG $+4
?options@?3??ParseArgs@@9@9 DQ FLAT:$SG172716		; `ParseArgs'::`4'::options
	DD	01H
	ORG $+4
	DQ	0000000000000000H
	DD	065H
	ORG $+4
	DQ	FLAT:$SG172717
	DD	01H
	ORG $+4
	DQ	0000000000000000H
	DD	06eH
	ORG $+4
	DQ	FLAT:$SG172718
	DD	01H
	ORG $+4
	DQ	0000000000000000H
	DD	06dH
	ORG $+4
	DQ	FLAT:$SG172719
	DD	01H
	ORG $+4
	DQ	0000000000000000H
	DD	06fH
	ORG $+4
	DQ	FLAT:$SG172720
	DD	01H
	ORG $+4
	DQ	0000000000000000H
	DD	073H
	ORG $+4
	DQ	FLAT:$SG172721
	DD	01H
	ORG $+4
	DQ	0000000000000000H
	DD	074H
	ORG $+4
	DQ	FLAT:$SG172722
	DD	00H
	ORG $+4
	DQ	0000000000000000H
	DD	064H
	ORG $+4
	DQ	FLAT:$SG172723
	DD	01H
	ORG $+4
	DQ	0000000000000000H
	DD	06bH
	ORG $+4
	DQ	FLAT:$SG172724
	DD	01H
	ORG $+4
	DQ	0000000000000000H
	DD	069H
	ORG $+4
	DQ	FLAT:$SG172725
	DD	00H
	ORG $+4
	DQ	0000000000000000H
	DD	077H
	ORG $+4
	DQ	0000000000000000H
	DD	00H
	ORG $+4
	DQ	0000000000000000H
	DD	00H
	ORG $+4
$SG172726 DB	'e:n:m:o:s:t:dk:i:w', 00H
	ORG $+5
$SG172735 DB	'device mode', 00H
	ORG $+4
$SG172737 DB	'HHC00916%s %1d:%04X %s: Option %s value %s invalid', 0aH
	DB	00H
	ORG $+4
$SG172738 DB	'ParseArgs', 00H
	ORG $+6
$SG172739 DB	'ctc_lcs.c', 00H
	ORG $+6
$SG172742 DB	'device name', 00H
	ORG $+4
$SG172744 DB	'HHC00916%s %1d:%04X %s: Option %s value %s invalid', 0aH
	DB	00H
	ORG $+4
$SG172745 DB	'ParseArgs', 00H
	ORG $+6
$SG172746 DB	'ctc_lcs.c', 00H
	ORG $+6
$SG172750 DB	'MAC address', 00H
	ORG $+4
$SG172752 DB	'HHC00916%s %1d:%04X %s: Option %s value %s invalid', 0aH
	DB	00H
	ORG $+4
$SG172753 DB	'ParseArgs', 00H
	ORG $+6
$SG172754 DB	'ctc_lcs.c', 00H
	ORG $+6
$SG172759 DB	'discard trace size', 00H
	ORG $+5
$SG172761 DB	'HHC00916%s %1d:%04X %s: Option %s value %s invalid', 0aH
	DB	00H
	ORG $+4
$SG172762 DB	'ParseArgs', 00H
	ORG $+6
$SG172763 DB	'ctc_lcs.c', 00H
	ORG $+6
$SG172767 DB	'maximum trace size', 00H
	ORG $+5
$SG172769 DB	'HHC00916%s %1d:%04X %s: Option %s value %s invalid', 0aH
	DB	00H
	ORG $+4
$SG172770 DB	'ParseArgs', 00H
	ORG $+6
$SG172771 DB	'ctc_lcs.c', 00H
	ORG $+6
$SG172776 DB	'kernel buffer size', 00H
	ORG $+5
$SG172778 DB	'HHC00916%s %1d:%04X %s: Option %s value %s invalid', 0aH
	DB	00H
	ORG $+4
$SG172779 DB	'ParseArgs', 00H
	ORG $+6
$SG172780 DB	'ctc_lcs.c', 00H
	ORG $+6
$SG172784 DB	'dll i/o buffer size', 00H
	ORG $+4
$SG172786 DB	'HHC00916%s %1d:%04X %s: Option %s value %s invalid', 0aH
	DB	00H
	ORG $+4
$SG172787 DB	'ParseArgs', 00H
	ORG $+6
$SG172788 DB	'ctc_lcs.c', 00H
	ORG $+6
$SG172794 DB	'HHC00915%s %1d:%04X %s: Incorrect number of parameters', 0aH
	DB	00H
$SG172795 DB	'ParseArgs', 00H
	ORG $+6
$SG172796 DB	'ctc_lcs.c', 00H
	ORG $+6
$SG172801 DB	'IP address', 00H
	ORG $+5
$SG172803 DB	'HHC00916%s %1d:%04X %s: Option %s value %s invalid', 0aH
	DB	00H
	ORG $+4
$SG172804 DB	'ParseArgs', 00H
	ORG $+6
$SG172805 DB	'ctc_lcs.c', 00H
	ORG $+6
$SG172807 DB	'IP address', 00H
	ORG $+5
$SG172809 DB	'HHC00916%s %1d:%04X %s: Option %s value %s invalid', 0aH
	DB	00H
	ORG $+4
$SG172810 DB	'ParseArgs', 00H
	ORG $+6
$SG172811 DB	'ctc_lcs.c', 00H
	ORG $+6
$SG172883 DB	'fopen( "%s", "r" )', 00H
	ORG $+5
$SG172885 DB	'HHC00940%s CTC: error in function %s: %s', 0aH, 00H
	ORG $+6
$SG172886 DB	'BuildOAT', 00H
	ORG $+7
$SG172887 DB	'ctc_lcs.c', 00H
	ORG $+6
$SG172892 DB	'$(CCUU)', 00H
$SG172893 DB	'CCUU', 00H
	ORG $+3
$SG172894 DB	'$(DEVN)', 00H
$SG172895 DB	'DEVN', 00H
	ORG $+3
$SG172908 DB	'HHC00954%s CTC: invalid statement %s in file %s: %s', 0aH
	DB	00H
	ORG $+3
$SG172909 DB	'BuildOAT', 00H
	ORG $+7
$SG172910 DB	'ctc_lcs.c', 00H
	ORG $+6
$SG172916 DB	'HHC00955%s CTC: invalid %s %s in statement %s in file %s'
	DB	': %s', 0aH, 00H
	ORG $+2
$SG172917 DB	'BuildOAT', 00H
	ORG $+7
$SG172918 DB	'ctc_lcs.c', 00H
	ORG $+6
$SG172927 DB	'HHC00954%s CTC: invalid statement %s in file %s: %s', 0aH
	DB	00H
	ORG $+3
$SG172928 DB	'BuildOAT', 00H
	ORG $+7
$SG172929 DB	'ctc_lcs.c', 00H
	ORG $+6
$SG172932 DB	'net address', 00H
	ORG $+4
$SG172934 DB	'HHC00955%s CTC: invalid %s %s in statement %s in file %s'
	DB	': %s', 0aH, 00H
	ORG $+2
$SG172935 DB	'BuildOAT', 00H
	ORG $+7
$SG172936 DB	'ctc_lcs.c', 00H
	ORG $+2
$SG172938 DB	'ROUTE', 00H
	ORG $+6
$SG172939 DB	'netmask', 00H
$SG172941 DB	'HHC00955%s CTC: invalid %s %s in statement %s in file %s'
	DB	': %s', 0aH, 00H
	ORG $+2
$SG172942 DB	'BuildOAT', 00H
	ORG $+7
$SG172943 DB	'ctc_lcs.c', 00H
	ORG $+6
$SG172949 DB	'HHC00956%s CTC: error in file %s: missing device number '
	DB	'or mode', 0aH, 00H
	ORG $+7
$SG172950 DB	'BuildOAT', 00H
	ORG $+7
$SG172951 DB	'ctc_lcs.c', 00H
	ORG $+2
$SG172954 DB	'%hx%c', 00H
	ORG $+6
$SG172955 DB	'device number', 00H
	ORG $+2
$SG172957 DB	'HHC00957%s CTC: error in file %s: invalid %s value %s', 0aH
	DB	00H
	ORG $+1
$SG172958 DB	'BuildOAT', 00H
	ORG $+7
$SG172959 DB	'ctc_lcs.c', 00H
	ORG $+6
$SG172965 DB	'HHC00958%s CTC: error in file %s: %s: missing port numbe'
	DB	'r', 0aH, 00H
	ORG $+5
$SG172966 DB	'BuildOAT', 00H
	ORG $+7
$SG172967 DB	'ctc_lcs.c', 00H
	ORG $+2
$SG172969 DB	'%hi%c', 00H
	ORG $+6
$SG172970 DB	'port number', 00H
	ORG $+4
$SG172972 DB	'HHC00957%s CTC: error in file %s: invalid %s value %s', 0aH
	DB	00H
	ORG $+1
$SG172973 DB	'BuildOAT', 00H
	ORG $+7
$SG172974 DB	'ctc_lcs.c', 00H
	ORG $+6
$SG172991 DB	'IP address', 00H
	ORG $+5
$SG172993 DB	'HHC00957%s CTC: error in file %s: invalid %s value %s', 0aH
	DB	00H
	ORG $+1
$SG172986 DB	'HHC00959%s CTC: error in file %s: %s: invalid entry star'
	DB	'ting at %s', 0aH, 00H
	ORG $+4
$SG172987 DB	'BuildOAT', 00H
	ORG $+7
$SG172988 DB	'ctc_lcs.c', 00H
	ORG $+6
$SG172994 DB	'BuildOAT', 00H
	ORG $+7
$SG172995 DB	'ctc_lcs.c', 00H
	ORG $+6
$SG173001 DB	'HHC00958%s CTC: error in file %s: %s: missing port numbe'
	DB	'r', 0aH, 00H
	ORG $+5
$SG173002 DB	'BuildOAT', 00H
	ORG $+7
$SG173003 DB	'ctc_lcs.c', 00H
	ORG $+2
$SG173005 DB	'%hi%c', 00H
	ORG $+6
$SG173006 DB	'port number', 00H
	ORG $+4
$SG173008 DB	'HHC00957%s CTC: error in file %s: invalid %s value %s', 0aH
	DB	00H
	ORG $+1
$SG173009 DB	'BuildOAT', 00H
	ORG $+7
$SG173010 DB	'ctc_lcs.c', 00H
	ORG $+6
$SG173017 DB	'HHC00961%s CTC: error in file %s: %s: invalid mode', 0aH
	DB	00H
	ORG $+4
$SG173013 DB	'HHC00960%s CTC: error in file %s: %s: SNA does not accep'
	DB	't any arguments', 0aH, 00H
	ORG $+7
$SG173014 DB	'BuildOAT', 00H
	ORG $+7
$SG173015 DB	'ctc_lcs.c', 00H
	ORG $+6
$SG173018 DB	'BuildOAT', 00H
	ORG $+7
$SG173019 DB	'ctc_lcs.c', 00H
	ORG $+6
$SG173044 DB	'HHC00962%s CTC: error in file %s: reading line %d: %s', 0aH
	DB	00H
	ORG $+1
$SG173045 DB	'ReadOAT', 00H
$SG173046 DB	'ctc_lcs.c', 00H
	ORG $+6
$SG173057 DB	'HHC00963%s CTC: error in file %s: line %d is too long', 0aH
	DB	00H
	ORG $+1
$SG173058 DB	'ReadOAT', 00H
$SG173059 DB	'ctc_lcs.c', 00H
	ORG $+6
$SG173251 DB	'ctc_lcs.c:4043', 00H
	ORG $+1
$SG173252 DB	'ATTNTHRD: ENTRY', 00H
$SG173254 DB	'ctc_lcs.c:4053', 00H
	ORG $+1
$SG173255 DB	'GET  AttnEventLock', 00H
	ORG $+5
$SG173256 DB	'ctc_lcs.c:4054', 00H
	ORG $+1
$SG173258 DB	'ctc_lcs.c:4055', 00H
	ORG $+1
$SG173259 DB	'GOT  AttnEventLock', 00H
	ORG $+5
$SG173262 DB	'ctc_lcs.c:4061', 00H
	ORG $+1
$SG173263 DB	'ATTNTHRD Closing...', 00H
	ORG $+4
$SG173266 DB	'ctc_lcs.c:4067', 00H
	ORG $+1
$SG173267 DB	'ATTNTHRD Attn...', 00H
	ORG $+7
$SG173269 DB	'ctc_lcs.c:4071', 00H
	ORG $+1
$SG173270 DB	'WAIT AttnEventLock', 00H
	ORG $+5
$SG173271 DB	'ctc_lcs.c:4078', 00H
	ORG $+1
$SG173273 DB	'ctc_lcs.c:4079', 00H
	ORG $+1
$SG173274 DB	'WOKE AttnEventLock', 00H
	ORG $+5
$SG173276 DB	'ctc_lcs.c:4082', 00H
	ORG $+1
$SG173277 DB	'REL  AttnEventLock', 00H
	ORG $+5
$SG173278 DB	'ctc_lcs.c:4083', 00H
	ORG $+1
$SG173281 DB	'ctc_lcs.c:4088', 00H
	ORG $+1
$SG173282 DB	'ATTNTHRD Closing...', 00H
	ORG $+4
$SG173284 DB	'ctc_lcs.c:4093', 00H
	ORG $+1
$SG173285 DB	'GET  AttnLock', 00H
	ORG $+2
$SG173286 DB	'ctc_lcs.c:4094', 00H
	ORG $+1
$SG173288 DB	'ctc_lcs.c:4095', 00H
	ORG $+1
$SG173289 DB	'GOT  AttnLock', 00H
	ORG $+2
$SG173293 DB	'ctc_lcs.c:4101', 00H
	ORG $+1
$SG173294 DB	'REM  Attn (All)', 00H
$SG173296 DB	'ctc_lcs.c:4105', 00H
	ORG $+1
$SG173297 DB	'REM  Attn (Non)', 00H
$SG173299 DB	'ctc_lcs.c:4108', 00H
	ORG $+1
$SG173300 DB	'REL  AttnLock', 00H
	ORG $+2
$SG173301 DB	'ctc_lcs.c:4109', 00H
	ORG $+1
$SG173305 DB	'ctc_lcs.c:4140', 00H
	ORG $+1
$SG173306 DB	'PRC  Attn', 00H
	ORG $+6
$SG173308 DB	'ctc_lcs.c:4163', 00H
	ORG $+1
$SG173309 DB	'Raise Attn   ', 00H
	ORG $+2
$SG173311 DB	'device_attention rc=%d  %d  %d', 00H
	ORG $+1
$SG173313 DB	'HHC03991%s %1d:%04X %s: %s', 0aH, 00H
	ORG $+4
$SG173314 DB	'LCS_AttnThread', 00H
	ORG $+1
$SG173315 DB	'ctc_lcs.c', 00H
	ORG $+6
$SG173319 DB	'ctc_lcs.c:4205', 00H
	ORG $+1
$SG173320 DB	'ATTNTHRD: EXIT', 00H
	ORG $+1
$SG173645 DB	'HHC00981%s %1d:%04X %s: Accept data of size %d bytes fro'
	DB	'm guest', 0aH, 00H
	ORG $+7
$SG173646 DB	'LCS_Write_SNA', 00H
	ORG $+2
$SG173647 DB	'ctc_lcs.c', 00H
	ORG $+6
$SG173652 DB	'LCS_Write_SNA', 00H
	ORG $+2
$SG173654 DB	'data', 00H
	ORG $+3
$SG173651 DB	'HHC00980%s %1d:%04X %s: Data of size %d bytes displayed,'
	DB	' data of size %d bytes not displayed', 0aH, 00H
	ORG $+2
$SG173653 DB	'ctc_lcs.c', 00H
	ORG $+6
$SG173656 DB	'ctc_lcs.c:4290', 00H
	ORG $+1
$SG173657 DB	'WSNA ENTRY        ', 00H
	ORG $+5
$SG173659 DB	'ctc_lcs.c:4291', 00H
	ORG $+1
$SG173660 DB	'beg write', 00H
	ORG $+6
$SG173666 DB	'ctc_lcs.c:4326', 00H
	ORG $+1
$SG173667 DB	'WSNA: OCTL & data ', 00H
	ORG $+5
$SG173669 DB	'ctc_lcs.c:4329', 00H
	ORG $+1
$SG173670 DB	'GET  InOutLock    ', 00H
	ORG $+5
$SG173671 DB	'ctc_lcs.c:4330', 00H
	ORG $+1
$SG173673 DB	'ctc_lcs.c:4331', 00H
	ORG $+1
$SG173674 DB	'GOT  InOutLock    ', 00H
	ORG $+5
$SG173679 DB	'ctc_lcs.c:4360', 00H
	ORG $+1
$SG173680 DB	'WSNA: Baffle 1    ', 00H
	ORG $+5
$SG173695 DB	'ctc_lcs.c:4442', 00H
	ORG $+1
$SG173696 DB	'*BAF=Unsupported! ', 00H
	ORG $+5
$SG173697 DB	'LCS: lcs write: unsupported baffle type 0x%4.4X', 00H
$SG173699 DB	'HHC03984%s %s', 0aH, 00H
	ORG $+1
$SG173700 DB	'LCS_Write_SNA', 00H
	ORG $+2
$SG173701 DB	'ctc_lcs.c', 00H
	ORG $+6
$SG173704 DB	'ctc_lcs.c:4455', 00H
	ORG $+1
$SG173705 DB	'WSNA: Cmd frame O ', 00H
	ORG $+5
$SG173708 DB	'ctc_lcs.c:4461', 00H
	ORG $+1
$SG173709 DB	'CMD=Stop LAN SNA  ', 00H
	ORG $+5
$SG173711 DB	'stop lan sna', 00H
	ORG $+3
$SG173713 DB	'HHC00933%s %1d:%04X CTC: executing command %s', 0aH, 00H
	ORG $+1
$SG173714 DB	'LCS_Write_SNA', 00H
	ORG $+2
$SG173715 DB	'ctc_lcs.c', 00H
	ORG $+6
$SG173718 DB	'ctc_lcs.c:4472', 00H
	ORG $+1
$SG173719 DB	'*CMD=Unsupported! ', 00H
	ORG $+5
$SG173721 DB	'other (0x%2.2X)', 00H
$SG173723 DB	'HHC00933%s %1d:%04X CTC: executing command %s', 0aH, 00H
	ORG $+1
$SG173724 DB	'LCS_Write_SNA', 00H
	ORG $+2
$SG173725 DB	'ctc_lcs.c', 00H
	ORG $+6
$SG173728 DB	'ctc_lcs.c:4488', 00H
	ORG $+1
$SG173729 DB	'*WRIT Unsupp frame', 00H
	ORG $+5
$SG173731 DB	'HHC00937%s %1d:%04X CTC: lcs write: unsupported frame ty'
	DB	'pe 0x%2.2X', 0aH, 00H
	ORG $+4
$SG173732 DB	'LCS_Write_SNA', 00H
	ORG $+2
$SG173733 DB	'ctc_lcs.c', 00H
	ORG $+6
$SG173735 DB	'ctc_lcs.c:4491', 00H
	ORG $+1
$SG173736 DB	'REL  InOutLock    ', 00H
	ORG $+5
$SG173737 DB	'ctc_lcs.c:4492', 00H
	ORG $+1
$SG173739 DB	'LCS_Write_SNA', 00H
	ORG $+2
$SG173740 DB	'ctc_lcs.c', 00H
	ORG $+6
$SG173741 DB	'%s(%d) : warning HHC90999W : *** Assertion Failed! *** f'
	DB	'unction: %s', 0aH, 00H
	ORG $+3
$SG173743 DB	'LCS_Write_SNA', 00H
	ORG $+2
$SG173744 DB	'ctc_lcs.c', 00H
	ORG $+6
$SG173748 DB	'ctc_lcs.c:4497', 00H
	ORG $+1
$SG173752 DB	'WSNA EXIT         ', 00H
	ORG $+5
$SG173745 DB	'%s(%d) : warning HHC90999W : *** Assertion Failed! *** f'
	DB	'unction: %s', 0aH, 00H
	ORG $+3
$SG173749 DB	'end write', 00H
	ORG $+6
$SG173751 DB	'ctc_lcs.c:4498', 00H
	ORG $+1
$SG173754 DB	'ctc_lcs.c:4506', 00H
	ORG $+1
$SG173755 DB	'REL  InOutLock    ', 00H
	ORG $+5
$SG173756 DB	'ctc_lcs.c:4507', 00H
	ORG $+1
$SG173758 DB	'ctc_lcs.c:4515', 00H
	ORG $+1
$SG173759 DB	'WSNA: OCTL only   ', 00H
	ORG $+5
$SG173761 DB	'ctc_lcs.c:4540', 00H
	ORG $+1
$SG173762 DB	'WSNA: command     ', 00H
	ORG $+5
$SG173767 DB	'ctc_lcs.c:4570', 00H
	ORG $+1
$SG173768 DB	'WSNA: Cmd frame   ', 00H
	ORG $+5
$SG173771 DB	'ctc_lcs.c:4577', 00H
	ORG $+1
$SG173772 DB	'CMD=Start LAN SNA ', 00H
	ORG $+5
$SG173774 DB	'start lan sna', 00H
	ORG $+2
$SG173776 DB	'HHC00933%s %1d:%04X CTC: executing command %s', 0aH, 00H
	ORG $+1
$SG173777 DB	'LCS_Write_SNA', 00H
	ORG $+2
$SG173778 DB	'ctc_lcs.c', 00H
	ORG $+6
$SG173781 DB	'ctc_lcs.c:4585', 00H
	ORG $+1
$SG173782 DB	'CMD=LAN Stats SNA ', 00H
	ORG $+5
$SG173784 DB	'lan statistics sna', 00H
	ORG $+5
$SG173786 DB	'HHC00933%s %1d:%04X CTC: executing command %s', 0aH, 00H
	ORG $+1
$SG173787 DB	'LCS_Write_SNA', 00H
	ORG $+2
$SG173788 DB	'ctc_lcs.c', 00H
	ORG $+6
$SG173791 DB	'ctc_lcs.c:4594', 00H
	ORG $+1
$SG173792 DB	'*CMD=Unsupported! ', 00H
	ORG $+5
$SG173794 DB	'other (0x%2.2X)', 00H
$SG173796 DB	'HHC00933%s %1d:%04X CTC: executing command %s', 0aH, 00H
	ORG $+1
$SG173797 DB	'LCS_Write_SNA', 00H
	ORG $+2
$SG173798 DB	'ctc_lcs.c', 00H
	ORG $+6
$SG173801 DB	'ctc_lcs.c:4610', 00H
	ORG $+1
$SG173802 DB	'*WRIT Unsupp frame', 00H
	ORG $+5
$SG173804 DB	'HHC00937%s %1d:%04X CTC: lcs write: unsupported frame ty'
	DB	'pe 0x%2.2X', 0aH, 00H
	ORG $+4
$SG173805 DB	'LCS_Write_SNA', 00H
	ORG $+2
$SG173806 DB	'ctc_lcs.c', 00H
	ORG $+6
$SG173808 DB	'LCS_Write_SNA', 00H
	ORG $+2
$SG173809 DB	'ctc_lcs.c', 00H
	ORG $+6
$SG173812 DB	'LCS_Write_SNA', 00H
	ORG $+2
$SG173817 DB	'ctc_lcs.c:4617', 00H
	ORG $+1
$SG173821 DB	'WSNA EXIT         ', 00H
	ORG $+5
$SG173810 DB	'%s(%d) : warning HHC90999W : *** Assertion Failed! *** f'
	DB	'unction: %s', 0aH, 00H
	ORG $+3
$SG173813 DB	'ctc_lcs.c', 00H
	ORG $+6
$SG173820 DB	'ctc_lcs.c:4618', 00H
	ORG $+1
$SG173825 DB	'HHC00936%s %1d:%04X CTC: error writing to file %s: %s', 0aH
	DB	00H
	ORG $+1
$SG173814 DB	'%s(%d) : warning HHC90999W : *** Assertion Failed! *** f'
	DB	'unction: %s', 0aH, 00H
	ORG $+3
$SG173818 DB	'end write', 00H
	ORG $+6
$SG173826 DB	'LCS_Write_SNA', 00H
	ORG $+2
$SG173827 DB	'ctc_lcs.c', 00H
	ORG $+6
$SG173829 DB	'ctc_lcs.c:4649', 00H
	ORG $+1
$SG173830 DB	'end write', 00H
	ORG $+6
$SG173832 DB	'ctc_lcs.c:4650', 00H
	ORG $+1
$SG173833 DB	'WSNA EXIT         ', 00H
	ORG $+5
$SG173880 DB	'LCSCONN not found', 00H
	ORG $+6
$SG173882 DB	'HHC03984%s %s', 0aH, 00H
	ORG $+1
$SG173883 DB	'Process_0D10', 00H
	ORG $+3
$SG173884 DB	'ctc_lcs.c', 00H
	ORG $+6
$SG173888 DB	'LCS: Ignoring over long data of %d bytes!!!', 00H
	ORG $+4
$SG173890 DB	'HHC03984%s %s', 0aH, 00H
	ORG $+1
$SG173891 DB	'Process_0D10', 00H
	ORG $+3
$SG173892 DB	'ctc_lcs.c', 00H
	ORG $+6
$SG173895 DB	'802.3 SNA', 00H
	ORG $+6
$SG173898 DB	'Process_0D10', 00H
	ORG $+3
$SG173910 DB	'LCS: LLC information frame sent: CR=%u, NR=%u, NS=%u', 00H
	ORG $+3
$SG173897 DB	'HHC00983%s %1d:%04X %s: port %2.2X: Send frame of size %'
	DB	'd bytes (with %s packet) to device %s', 0aH, 00H
	ORG $+1
$SG173899 DB	'ctc_lcs.c', 00H
	ORG $+6
$SG173903 DB	'HHC00980%s %1d:%04X %s: Data of size %d bytes displayed,'
	DB	' data of size %d bytes not displayed', 0aH, 00H
	ORG $+2
$SG173904 DB	'Process_0D10', 00H
	ORG $+3
$SG173905 DB	'ctc_lcs.c', 00H
	ORG $+6
$SG173906 DB	'eth frame', 00H
	ORG $+6
$SG173912 DB	'HHC03984%s %s', 0aH, 00H
	ORG $+1
$SG173913 DB	'Process_0D10', 00H
	ORG $+3
$SG173914 DB	'ctc_lcs.c', 00H
	ORG $+6
$SG173916 DB	'ctc_lcs.c:4770', 00H
	ORG $+1
$SG173917 DB	'*WRITE ERR', 00H
	ORG $+5
$SG173973 DB	'LCSCONN not found', 00H
	ORG $+6
$SG173975 DB	'HHC03984%s %s', 0aH, 00H
	ORG $+1
$SG173976 DB	'Process_0D00', 00H
	ORG $+3
$SG173977 DB	'ctc_lcs.c', 00H
	ORG $+6
$SG173979 DB	'802.3 SNA', 00H
	ORG $+6
$SG173982 DB	'Process_0D00', 00H
	ORG $+3
$SG173988 DB	'SABME', 00H
	ORG $+2
$SG173981 DB	'HHC00983%s %1d:%04X %s: port %2.2X: Send frame of size %'
	DB	'd bytes (with %s packet) to device %s', 0aH, 00H
	ORG $+1
$SG173983 DB	'ctc_lcs.c', 00H
	ORG $+6
$SG173984 DB	'eth frame', 00H
	ORG $+6
$SG173989 DB	'LCS: LLC unnumbered frame sent: CR=%u, M=%s', 00H
	ORG $+4
$SG173991 DB	'HHC03984%s %s', 0aH, 00H
	ORG $+1
$SG173992 DB	'Process_0D00', 00H
	ORG $+3
$SG173993 DB	'ctc_lcs.c', 00H
	ORG $+6
$SG173995 DB	'ctc_lcs.c:4864', 00H
	ORG $+1
$SG173996 DB	'*WRITE ERR', 00H
	ORG $+5
$SG174049 DB	'LCSCONN not found', 00H
	ORG $+6
$SG174051 DB	'HHC03984%s %s', 0aH, 00H
	ORG $+1
$SG174052 DB	'Process_8C0B', 00H
	ORG $+3
$SG174053 DB	'ctc_lcs.c', 00H
	ORG $+6
$SG174055 DB	'802.3 SNA', 00H
	ORG $+6
$SG174058 DB	'Process_8C0B', 00H
	ORG $+3
$SG174067 DB	'HHC03984%s %s', 0aH, 00H
	ORG $+1
$SG174136 DB	'LCSCONN', 00H
$SG174057 DB	'HHC00983%s %1d:%04X %s: port %2.2X: Send frame of size %'
	DB	'd bytes (with %s packet) to device %s', 0aH, 00H
	ORG $+1
$SG174059 DB	'ctc_lcs.c', 00H
	ORG $+6
$SG174060 DB	'eth frame', 00H
	ORG $+6
$SG174065 DB	'LCS: LLC unnumbered frame sent: CR=%u, M=%s', 00H
	ORG $+4
$SG174068 DB	'Process_8C0B', 00H
	ORG $+3
$SG174069 DB	'ctc_lcs.c', 00H
	ORG $+6
$SG174071 DB	'ctc_lcs.c:4955', 00H
	ORG $+1
$SG174072 DB	'*WRITE ERR', 00H
	ORG $+5
$SG174128 DB	'ctc_lcs.c:5029', 00H
	ORG $+1
$SG174129 DB	'ctc_lcs.c:5032', 00H
	ORG $+1
$SG174131 DB	'Created LCSCONN Outbound', 00H
	ORG $+7
$SG174133 DB	'HHC03984%s %s', 0aH, 00H
	ORG $+1
$SG174134 DB	'Process_0C0A', 00H
	ORG $+3
$SG174135 DB	'ctc_lcs.c', 00H
	ORG $+6
$SG174140 DB	'Found LCSCONN Inbound', 00H
	ORG $+2
$SG174142 DB	'HHC03984%s %s', 0aH, 00H
	ORG $+1
$SG174143 DB	'Process_0C0A', 00H
	ORG $+3
$SG174144 DB	'ctc_lcs.c', 00H
	ORG $+6
$SG174145 DB	'LCSCONN', 00H
$SG174146 DB	'ctc_lcs.c:5053', 00H
	ORG $+1
$SG174147 DB	'ctc_lcs.c:5056', 00H
	ORG $+1
$SG174149 DB	'Updated LCSCONN Inbound', 00H
$SG174151 DB	'HHC03984%s %s', 0aH, 00H
	ORG $+1
$SG174152 DB	'Process_0C0A', 00H
	ORG $+3
$SG174153 DB	'ctc_lcs.c', 00H
	ORG $+6
$SG174154 DB	'LCSCONN', 00H
$SG174156 DB	'Found and released existing LCSCONN Outbound', 00H
	ORG $+3
$SG174158 DB	'HHC03984%s %s', 0aH, 00H
	ORG $+1
$SG174159 DB	'Process_0C0A', 00H
	ORG $+3
$SG174160 DB	'ctc_lcs.c', 00H
	ORG $+6
$SG174161 DB	'LCSCONN', 00H
$SG174162 DB	'ctc_lcs.c:5087', 00H
	ORG $+1
$SG174163 DB	'ctc_lcs.c:5090', 00H
	ORG $+1
$SG174165 DB	'Created LCSCONN Outbound', 00H
	ORG $+7
$SG174167 DB	'HHC03984%s %s', 0aH, 00H
	ORG $+1
$SG174168 DB	'Process_0C0A', 00H
	ORG $+3
$SG174169 DB	'ctc_lcs.c', 00H
	ORG $+6
$SG174170 DB	'LCSCONN', 00H
$SG174221 DB	'LCSCONN not found', 00H
	ORG $+6
$SG174223 DB	'HHC03984%s %s', 0aH, 00H
	ORG $+1
$SG174224 DB	'Process_0C25', 00H
	ORG $+3
$SG174225 DB	'ctc_lcs.c', 00H
	ORG $+6
$SG174227 DB	'802.3 SNA', 00H
	ORG $+6
$SG174230 DB	'Process_0C25', 00H
	ORG $+3
$SG174236 DB	'TEST', 00H
	ORG $+3
$SG174229 DB	'HHC00983%s %1d:%04X %s: port %2.2X: Send frame of size %'
	DB	'd bytes (with %s packet) to device %s', 0aH, 00H
	ORG $+1
$SG174231 DB	'ctc_lcs.c', 00H
	ORG $+6
$SG174232 DB	'eth frame', 00H
	ORG $+6
$SG174237 DB	'LCS: LLC unnumbered frame sent: CR=%u, M=%s', 00H
	ORG $+4
$SG174239 DB	'HHC03984%s %s', 0aH, 00H
	ORG $+1
$SG174240 DB	'Process_0C25', 00H
	ORG $+3
$SG174241 DB	'ctc_lcs.c', 00H
	ORG $+6
$SG174243 DB	'ctc_lcs.c:5207', 00H
	ORG $+1
$SG174244 DB	'*WRITE ERR', 00H
	ORG $+5
$SG174295 DB	'LCSCONN not found', 00H
	ORG $+6
$SG174297 DB	'HHC03984%s %s', 0aH, 00H
	ORG $+1
$SG174298 DB	'Process_0C22', 00H
	ORG $+3
$SG174299 DB	'ctc_lcs.c', 00H
	ORG $+6
$SG174304 DB	'802.3 SNA', 00H
	ORG $+6
$SG174307 DB	'Process_0C22', 00H
	ORG $+3
$SG174322 DB	'HHC03984%s %s', 0aH, 00H
	ORG $+1
$SG174380 DB	'LCSCONN not found', 00H
	ORG $+6
$SG174306 DB	'HHC00983%s %1d:%04X %s: port %2.2X: Send frame of size %'
	DB	'd bytes (with %s packet) to device %s', 0aH, 00H
	ORG $+1
$SG174308 DB	'ctc_lcs.c', 00H
	ORG $+6
$SG174312 DB	'HHC00980%s %1d:%04X %s: Data of size %d bytes displayed,'
	DB	' data of size %d bytes not displayed', 0aH, 00H
	ORG $+2
$SG174313 DB	'Process_0C22', 00H
	ORG $+3
$SG174314 DB	'ctc_lcs.c', 00H
	ORG $+6
$SG174315 DB	'eth frame', 00H
	ORG $+6
$SG174320 DB	'LCS: LLC unnumbered frame sent: CR=%u, M=%s', 00H
	ORG $+4
$SG174323 DB	'Process_0C22', 00H
	ORG $+3
$SG174324 DB	'ctc_lcs.c', 00H
	ORG $+6
$SG174326 DB	'ctc_lcs.c:5325', 00H
	ORG $+1
$SG174327 DB	'*WRITE ERR', 00H
	ORG $+5
$SG174382 DB	'HHC03984%s %s', 0aH, 00H
	ORG $+1
$SG174383 DB	'Process_8D00', 00H
	ORG $+3
$SG174384 DB	'ctc_lcs.c', 00H
	ORG $+6
$SG174386 DB	'802.3 SNA', 00H
	ORG $+6
$SG174388 DB	'HHC00983%s %1d:%04X %s: port %2.2X: Send frame of size %'
	DB	'd bytes (with %s packet) to device %s', 0aH, 00H
	ORG $+1
$SG174389 DB	'Process_8D00', 00H
	ORG $+3
$SG174390 DB	'ctc_lcs.c', 00H
	ORG $+6
$SG174391 DB	'eth frame', 00H
	ORG $+6
$SG174396 DB	'LCS: LLC unnumbered frame sent: CR=%u, M=%s', 00H
	ORG $+4
$SG174398 DB	'HHC03984%s %s', 0aH, 00H
	ORG $+1
$SG174399 DB	'Process_8D00', 00H
	ORG $+3
$SG174400 DB	'ctc_lcs.c', 00H
	ORG $+6
$SG174402 DB	'ctc_lcs.c:5420', 00H
	ORG $+1
$SG174403 DB	'*WRITE ERR', 00H
	ORG $+5
$SG174449 DB	'LCSCONN not found', 00H
	ORG $+6
$SG174451 DB	'HHC03984%s %s', 0aH, 00H
	ORG $+1
$SG174452 DB	'Process_0C0B', 00H
	ORG $+3
$SG174453 DB	'ctc_lcs.c', 00H
	ORG $+6
$SG174684 DB	'ctc_lcs.c:5792', 00H
	ORG $+1
$SG174685 DB	'GET  PortDataLock ', 00H
	ORG $+5
$SG174686 DB	'ctc_lcs.c:5793', 00H
	ORG $+1
$SG174688 DB	'ctc_lcs.c:5794', 00H
	ORG $+1
$SG174689 DB	'GOT  PortDataLock ', 00H
	ORG $+5
$SG174691 DB	'ctc_lcs.c:5797', 00H
	ORG $+1
$SG174692 DB	'STRTLAN if started', 00H
	ORG $+5
$SG174695 DB	'ctc_lcs.c:5800', 00H
	ORG $+1
$SG174696 DB	'STRTLAN started=NO', 00H
	ORG $+5
$SG174699 DB	'LCS_StartLan_SNA', 00H
	ORG $+7
$SG174700 DB	'ctc_lcs.c', 00H
	ORG $+6
$SG174701 DB	'%s(%d) : warning HHC90999W : *** Assertion Failed! *** f'
	DB	'unction: %s', 0aH, 00H
	ORG $+3
$SG174703 DB	'LCS_StartLan_SNA', 00H
	ORG $+7
$SG174704 DB	'ctc_lcs.c', 00H
	ORG $+6
$SG174705 DB	'%s(%d) : warning HHC90999W : *** Assertion Failed! *** f'
	DB	'unction: %s', 0aH, 00H
	ORG $+3
$SG174708 DB	'ctc_lcs.c:5825', 00H
	ORG $+1
$SG174709 DB	'REL  PortDataLock ', 00H
	ORG $+5
$SG174710 DB	'ctc_lcs.c:5826', 00H
	ORG $+1
$SG174812 DB	'ctc_lcs.c:5922', 00H
	ORG $+1
$SG174813 DB	'GET  PortDataLock ', 00H
	ORG $+5
$SG174814 DB	'ctc_lcs.c:5923', 00H
	ORG $+1
$SG174816 DB	'ctc_lcs.c:5924', 00H
	ORG $+1
$SG174817 DB	'GOT  PortDataLock ', 00H
	ORG $+5
$SG174820 DB	'LCS_StopLan_SNA', 00H
$SG174821 DB	'ctc_lcs.c', 00H
	ORG $+6
$SG174822 DB	'%s(%d) : warning HHC90999W : *** Assertion Failed! *** f'
	DB	'unction: %s', 0aH, 00H
	ORG $+3
$SG174824 DB	'LCS_StopLan_SNA', 00H
$SG174825 DB	'ctc_lcs.c', 00H
	ORG $+6
$SG174829 DB	'ctc_lcs.c:5931', 00H
	ORG $+1
$SG174830 DB	'REL  PortDataLock ', 00H
	ORG $+5
$SG174826 DB	'%s(%d) : warning HHC90999W : *** Assertion Failed! *** f'
	DB	'unction: %s', 0aH, 00H
	ORG $+3
$SG174831 DB	'ctc_lcs.c:5932', 00H
	ORG $+1
$SG174833 DB	'ctc_lcs.c:5946', 00H
	ORG $+1
$SG174834 DB	'GET  DevDataLock  ', 00H
	ORG $+5
$SG174835 DB	'ctc_lcs.c:5947', 00H
	ORG $+1
$SG174837 DB	'ctc_lcs.c:5948', 00H
	ORG $+1
$SG174838 DB	'GOT  DevDataLock  ', 00H
	ORG $+5
$SG174840 DB	'ctc_lcs.c:5953', 00H
	ORG $+1
$SG174841 DB	'REL  DevDataLock  ', 00H
	ORG $+5
$SG174842 DB	'ctc_lcs.c:5954', 00H
	ORG $+1
$SG175103 DB	'LCS: LLC information frame received: CR=%u, NR=%u, NS=%u'
	DB	00H
	ORG $+7
$SG175105 DB	'HHC03984%s %s', 0aH, 00H
	ORG $+1
$SG175106 DB	'LCS_ProcessAccepted_SNA', 00H
$SG175107 DB	'ctc_lcs.c', 00H
	ORG $+6
$SG175109 DB	'LCSCONN not found', 00H
	ORG $+6
$SG175111 DB	'HHC03984%s %s', 0aH, 00H
	ORG $+1
$SG175112 DB	'LCS_ProcessAccepted_SNA', 00H
$SG175113 DB	'ctc_lcs.c', 00H
	ORG $+6
$SG175115 DB	'ctc_lcs.c:6150', 00H
	ORG $+1
$SG175116 DB	'GET  InOutLock    ', 00H
	ORG $+5
$SG175117 DB	'ctc_lcs.c:6151', 00H
	ORG $+1
$SG175119 DB	'ctc_lcs.c:6152', 00H
	ORG $+1
$SG175120 DB	'GOT  InOutLock    ', 00H
	ORG $+5
$SG175124 DB	'802.3 SNA', 00H
	ORG $+6
$SG175127 DB	'LCS_ProcessAccepted_SNA', 00H
$SG175126 DB	'HHC00983%s %1d:%04X %s: port %2.2X: Send frame of size %'
	DB	'd bytes (with %s packet) to device %s', 0aH, 00H
	ORG $+1
$SG175128 DB	'ctc_lcs.c', 00H
	ORG $+6
$SG175129 DB	'eth frame', 00H
	ORG $+6
$SG175133 DB	'Receiver Ready', 00H
	ORG $+1
$SG175134 DB	'LCS: LLC supervisory frame sent: CR=%u, SS=%s, PF=%u, NR'
	DB	'=%u', 00H
	ORG $+4
$SG175136 DB	'HHC03984%s %s', 0aH, 00H
	ORG $+1
$SG175137 DB	'LCS_ProcessAccepted_SNA', 00H
$SG175138 DB	'ctc_lcs.c', 00H
	ORG $+6
$SG175140 DB	'ctc_lcs.c:6259', 00H
	ORG $+1
$SG175141 DB	'*WRITE ERR', 00H
	ORG $+5
$SG175143 DB	'ctc_lcs.c:6263', 00H
	ORG $+1
$SG175144 DB	'REL  InOutLock    ', 00H
	ORG $+5
$SG175145 DB	'ctc_lcs.c:6264', 00H
	ORG $+1
$SG175149 DB	'Receiver Ready', 00H
	ORG $+1
$SG175150 DB	'LCS: LLC supervisory frame received: CR=%u, SS=%s, PF=%u'
	DB	', NR=%u', 00H
$SG175152 DB	'HHC03984%s %s', 0aH, 00H
	ORG $+1
$SG175153 DB	'LCS_ProcessAccepted_SNA', 00H
$SG175154 DB	'ctc_lcs.c', 00H
	ORG $+6
$SG175156 DB	'LCSCONN not found', 00H
	ORG $+6
$SG175158 DB	'HHC03984%s %s', 0aH, 00H
	ORG $+1
$SG175159 DB	'LCS_ProcessAccepted_SNA', 00H
$SG175160 DB	'ctc_lcs.c', 00H
	ORG $+6
$SG175164 DB	'802.3 SNA', 00H
	ORG $+6
$SG175167 DB	'LCS_ProcessAccepted_SNA', 00H
$SG175166 DB	'HHC00983%s %1d:%04X %s: port %2.2X: Send frame of size %'
	DB	'd bytes (with %s packet) to device %s', 0aH, 00H
	ORG $+1
$SG175168 DB	'ctc_lcs.c', 00H
	ORG $+6
$SG175169 DB	'eth frame', 00H
	ORG $+6
$SG175173 DB	'Receiver Ready', 00H
	ORG $+1
$SG175174 DB	'LCS: LLC supervisory frame sent: CR=%u, SS=%s, PF=%u, NR'
	DB	'=%u', 00H
	ORG $+4
$SG175176 DB	'HHC03984%s %s', 0aH, 00H
	ORG $+1
$SG175177 DB	'LCS_ProcessAccepted_SNA', 00H
$SG175178 DB	'ctc_lcs.c', 00H
	ORG $+6
$SG175180 DB	'ctc_lcs.c:6343', 00H
	ORG $+1
$SG175181 DB	'*WRITE ERR', 00H
	ORG $+5
$SG175184 DB	'Receiver Not Ready', 00H
	ORG $+5
$SG175185 DB	'LCS: LLC supervisory frame received: CR=%u, SS=%s, PF=%u'
	DB	', NR=%u', 00H
$SG175187 DB	'HHC03984%s %s', 0aH, 00H
	ORG $+1
$SG175188 DB	'LCS_ProcessAccepted_SNA', 00H
$SG175189 DB	'ctc_lcs.c', 00H
	ORG $+6
$SG175195 DB	'HHC03984%s %s', 0aH, 00H
	ORG $+1
$SG175196 DB	'LCS_ProcessAccepted_SNA', 00H
$SG175193 DB	'LCS: LLC supervisory frame received: CR=%u, SS=%s, PF=%u'
	DB	', NR=%u', 00H
$SG175197 DB	'ctc_lcs.c', 00H
	ORG $+6
$SG175203 DB	'LCS: LLC unnumbered frame received: CR=%u, M=%s', 00H
$SG175205 DB	'HHC03984%s %s', 0aH, 00H
	ORG $+1
$SG175206 DB	'LCS_ProcessAccepted_SNA', 00H
$SG175207 DB	'ctc_lcs.c', 00H
	ORG $+2
$SG175210 DB	'DISC', 00H
	ORG $+7
$SG175211 DB	'LCS: LLC unnumbered frame received: CR=%u, M=%s', 00H
$SG175213 DB	'HHC03984%s %s', 0aH, 00H
	ORG $+1
$SG175214 DB	'LCS_ProcessAccepted_SNA', 00H
$SG175215 DB	'ctc_lcs.c', 00H
	ORG $+6
$SG175217 DB	'LCSCONN not found', 00H
	ORG $+6
$SG175219 DB	'HHC03984%s %s', 0aH, 00H
	ORG $+1
$SG175220 DB	'LCS_ProcessAccepted_SNA', 00H
$SG175221 DB	'ctc_lcs.c', 00H
	ORG $+6
$SG175225 DB	'LCS: LLC unnumbered frame received: CR=%u, M=%s', 00H
$SG175227 DB	'HHC03984%s %s', 0aH, 00H
	ORG $+1
$SG175228 DB	'LCS_ProcessAccepted_SNA', 00H
$SG175229 DB	'ctc_lcs.c', 00H
	ORG $+6
$SG175231 DB	'LCSCONN not found', 00H
	ORG $+6
$SG175233 DB	'HHC03984%s %s', 0aH, 00H
	ORG $+1
$SG175234 DB	'LCS_ProcessAccepted_SNA', 00H
$SG175235 DB	'ctc_lcs.c', 00H
	ORG $+2
$SG175238 DB	'SABME', 00H
	ORG $+6
$SG175239 DB	'LCS: LLC unnumbered frame received: CR=%u, M=%s', 00H
$SG175241 DB	'HHC03984%s %s', 0aH, 00H
	ORG $+1
$SG175242 DB	'LCS_ProcessAccepted_SNA', 00H
$SG175243 DB	'ctc_lcs.c', 00H
	ORG $+6
$SG175245 DB	'LCSCONN not found', 00H
	ORG $+6
$SG175247 DB	'HHC03984%s %s', 0aH, 00H
	ORG $+1
$SG175248 DB	'LCS_ProcessAccepted_SNA', 00H
$SG175249 DB	'ctc_lcs.c', 00H
	ORG $+2
$SG175252 DB	'FRMR', 00H
	ORG $+7
$SG175253 DB	'LCS: LLC unnumbered frame received: CR=%u, M=%s', 00H
$SG175255 DB	'HHC03984%s %s', 0aH, 00H
	ORG $+1
$SG175256 DB	'LCS_ProcessAccepted_SNA', 00H
$SG175257 DB	'ctc_lcs.c', 00H
	ORG $+6
$SG175258 DB	'     CF=%4.4X, NR=%u, NS=%u, V=%u, Z=%u, Y=%u, X=%u, W=%'
	DB	'u', 00H
	ORG $+6
$SG175260 DB	'HHC03984%s %s', 0aH, 00H
	ORG $+1
$SG175261 DB	'LCS_ProcessAccepted_SNA', 00H
$SG175262 DB	'ctc_lcs.c', 00H
	ORG $+6
$SG175266 DB	'LCS: LLC unnumbered frame received: CR=%u, M=%s', 00H
$SG175268 DB	'HHC03984%s %s', 0aH, 00H
	ORG $+1
$SG175269 DB	'LCS_ProcessAccepted_SNA', 00H
$SG175270 DB	'ctc_lcs.c', 00H
	ORG $+6
$SG175274 DB	'LCSCONN not found', 00H
	ORG $+6
$SG175276 DB	'HHC03984%s %s', 0aH, 00H
	ORG $+1
$SG175277 DB	'LCS_ProcessAccepted_SNA', 00H
$SG175278 DB	'ctc_lcs.c', 00H
	ORG $+6
$SG175282 DB	'LCSCONN not found', 00H
	ORG $+6
$SG175284 DB	'HHC03984%s %s', 0aH, 00H
	ORG $+1
$SG175285 DB	'LCS_ProcessAccepted_SNA', 00H
$SG175286 DB	'ctc_lcs.c', 00H
	ORG $+6
$SG175288 DB	'Created LCSCONN Inbound', 00H
$SG175290 DB	'HHC03984%s %s', 0aH, 00H
	ORG $+1
$SG175291 DB	'LCS_ProcessAccepted_SNA', 00H
$SG175292 DB	'ctc_lcs.c', 00H
	ORG $+6
$SG175293 DB	'LCSCONN', 00H
$SG175297 DB	'Found LCSCONN Inbound', 00H
	ORG $+2
$SG175299 DB	'HHC03984%s %s', 0aH, 00H
	ORG $+1
$SG175300 DB	'LCS_ProcessAccepted_SNA', 00H
$SG175301 DB	'ctc_lcs.c', 00H
	ORG $+6
$SG175302 DB	'LCSCONN', 00H
$SG175304 DB	'Found existing LCSCONN Outbound, changed to LCSCONN Inbo'
	DB	'und', 00H
	ORG $+4
$SG175306 DB	'HHC03984%s %s', 0aH, 00H
	ORG $+1
$SG175307 DB	'LCS_ProcessAccepted_SNA', 00H
$SG175308 DB	'ctc_lcs.c', 00H
	ORG $+6
$SG175309 DB	'LCSCONN', 00H
$SG175316 DB	'TEST', 00H
	ORG $+3
$SG175317 DB	'LCS: LLC unnumbered frame received: CR=%u, M=%s', 00H
$SG175319 DB	'HHC03984%s %s', 0aH, 00H
	ORG $+1
$SG175320 DB	'LCS_ProcessAccepted_SNA', 00H
$SG175321 DB	'ctc_lcs.c', 00H
	ORG $+6
$SG175325 DB	'LCSCONN not found', 00H
	ORG $+6
$SG175327 DB	'HHC03984%s %s', 0aH, 00H
	ORG $+1
$SG175328 DB	'LCS_ProcessAccepted_SNA', 00H
$SG175329 DB	'ctc_lcs.c', 00H
	ORG $+6
$SG175331 DB	'802.3 SNA', 00H
	ORG $+6
$SG175333 DB	'HHC00983%s %1d:%04X %s: port %2.2X: Send frame of size %'
	DB	'd bytes (with %s packet) to device %s', 0aH, 00H
	ORG $+1
$SG175334 DB	'LCS_ProcessAccepted_SNA', 00H
$SG175335 DB	'ctc_lcs.c', 00H
	ORG $+6
$SG175336 DB	'eth frame', 00H
	ORG $+2
$SG175340 DB	'TEST', 00H
	ORG $+7
$SG175341 DB	'LCS: LLC unnumbered frame sent: CR=%u, M=%s', 00H
	ORG $+4
$SG175343 DB	'HHC03984%s %s', 0aH, 00H
	ORG $+1
$SG175344 DB	'LCS_ProcessAccepted_SNA', 00H
$SG175345 DB	'ctc_lcs.c', 00H
	ORG $+6
$SG175347 DB	'ctc_lcs.c:6830', 00H
	ORG $+1
$SG175348 DB	'*WRITE ERR', 00H
	ORG $+5
$SG175354 DB	'ctc_lcs.c:6865', 00H
	ORG $+1
$SG175355 DB	'GET  AttnLock', 00H
	ORG $+2
$SG175356 DB	'ctc_lcs.c:6866', 00H
	ORG $+1
$SG175358 DB	'ctc_lcs.c:6867', 00H
	ORG $+1
$SG175359 DB	'GOT  AttnLock', 00H
	ORG $+2
$SG175361 DB	'ctc_lcs.c:6869', 00H
	ORG $+1
$SG175362 DB	'ADD  Attn', 00H
	ORG $+6
$SG175364 DB	'ctc_lcs.c:6873', 00H
	ORG $+1
$SG175365 DB	'REL  AttnLock', 00H
	ORG $+2
$SG175366 DB	'ctc_lcs.c:6874', 00H
	ORG $+1
$SG175368 DB	'ctc_lcs.c:6877', 00H
	ORG $+1
$SG175369 DB	'GET  AttnEventLock ', 00H
	ORG $+4
$SG175370 DB	'ctc_lcs.c:6878', 00H
	ORG $+1
$SG175372 DB	'ctc_lcs.c:6879', 00H
	ORG $+1
$SG175373 DB	'GOT  AttnEventLock ', 00H
	ORG $+4
$SG175375 DB	'ctc_lcs.c:6881', 00H
	ORG $+1
$SG175376 DB	'SIG  AttnEvent', 00H
	ORG $+1
$SG175377 DB	'ctc_lcs.c:6882', 00H
	ORG $+1
$SG175379 DB	'ctc_lcs.c:6884', 00H
	ORG $+1
$SG175380 DB	'REL  AttnEventLock ', 00H
	ORG $+4
$SG175381 DB	'ctc_lcs.c:6885', 00H
	ORG $+1
$SG175384 DB	'HHC00970%s CTC: lcs device port %2.2X: 802.2 LLC error, '
	DB	'discarding frame', 0aH, 00H
	ORG $+6
$SG175385 DB	'LCS_ProcessAccepted_SNA', 00H
$SG175386 DB	'ctc_lcs.c', 00H
	ORG $+6
$SG175457 DB	'ctc_lcs.c:6933', 00H
	ORG $+1
$SG175458 DB	'RSNA: ENTRY       ', 00H
	ORG $+5
$SG175482 DB	'HHC00982%s %1d:%04X %s: Present data of size %d bytes to'
	DB	' guest', 0aH, 00H
$SG175483 DB	'LCS_Read_SNA', 00H
	ORG $+3
$SG175484 DB	'ctc_lcs.c', 00H
	ORG $+6
$SG175488 DB	'HHC00980%s %1d:%04X %s: Data of size %d bytes displayed,'
	DB	' data of size %d bytes not displayed', 0aH, 00H
	ORG $+2
$SG175489 DB	'LCS_Read_SNA', 00H
	ORG $+3
$SG175490 DB	'ctc_lcs.c', 00H
	ORG $+2
$SG175491 DB	'data', 00H
	ORG $+7
$SG175493 DB	'ctc_lcs.c:7155', 00H
	ORG $+1
$SG175494 DB	'RSNA empty buffer ', 00H
	ORG $+5
$SG175496 DB	'ctc_lcs.c:7164', 00H
	ORG $+1
$SG175497 DB	'RSNA: EXIT        ', 00H
	ORG $+5
$SG175559 DB	'malloc(%d)', 00H
	ORG $+5
$SG175561 DB	'HHC00900%s %1d:%04X %s: Error in function %s: %s', 0aH, 00H
	ORG $+6
$SG175562 DB	'alloc_lcs_buffer', 00H
	ORG $+7
$SG175563 DB	'ctc_lcs.c', 00H
	ORG $+6
$SG175571 DB	'ctc_lcs.c:7495', 00H
	ORG $+1
$SG175574 DB	'ctc_lcs.c:7510', 00H
	ORG $+1
$SG175581 DB	'ctc_lcs.c:7523', 00H
	ORG $+1
$SG175584 DB	'ctc_lcs.c:7541', 00H
	ORG $+1
$SG175594 DB	'ctc_lcs.c:7554', 00H
	ORG $+1
$SG175595 DB	'ctc_lcs.c:7570', 00H
	ORG $+1
$SG175615 DB	'malloc(%d)', 00H
	ORG $+5
$SG175617 DB	'HHC00900%s %1d:%04X %s: Error in function %s: %s', 0aH, 00H
	ORG $+6
$SG175618 DB	'alloc_connection', 00H
	ORG $+7
$SG175619 DB	'ctc_lcs.c', 00H
	ORG $+6
$SG175627 DB	'ctc_lcs.c:7623', 00H
	ORG $+1
$SG175628 DB	'ctc_lcs.c:7630', 00H
	ORG $+1
$SG175672 DB	'ctc_lcs.c:7798', 00H
	ORG $+1
$SG175674 DB	'ctc_lcs.c:7816', 00H
	ORG $+1
$SG175682 DB	'ctc_lcs.c:7829', 00H
	ORG $+1
$SG175683 DB	'ctc_lcs.c:7841', 00H
	ORG $+1
$SG175724 DB	'SDL 4.60', 00H
	ORG $+7
$SG175725 DB	'HERCULES', 00H
	ORG $+7
$SG175727 DB	'SDL 4.00', 00H
	ORG $+7
$SG175735 DB	'debug_tt32_stats', 00H
	ORG $+7
$SG175736 DB	'debug_tt32_tracing', 00H
	ORG $+1
$SG175742 DB	'CTCI', 00H
	ORG $+3
$SG175743 DB	'CTCT', 00H
	ORG $+3
$SG175744 DB	'CTCE', 00H
_DATA	ENDS
voltbl	SEGMENT
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:LCS_DoMulticast
	DD	026H
	DD	0975H
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:alloc_connection
	DD	016H
	DD	012aH
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:alloc_lcs_buffer
	DD	01aH
	DD	0156H
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:Process_8D00
	DD	027H
	DD	04b4H
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:Process_0C22
	DD	027H
	DD	0651H
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:Process_0C25
	DD	027H
	DD	0496H
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:Process_8C0B
	DD	027H
	DD	04c5H
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:Process_0D00
	DD	027H
	DD	04bbH
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:Process_0D10
	DD	027H
	DD	06f3H
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:BuildLLC
	DD	01aH
	DD	03fbH
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:LCS_ProcessAccepted_SNA
	DD	027H
	DD	02cc8H
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:LCS_Write_SNA
	DD	025H
	DD	01ca6H
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:ParseArgs
	DD	02dH
	DD	0d3eH
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:BuildOAT
	DD	022H
	DD	011aaH
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:GetIfMACAddress
	DD	018H
	DD	04f0H
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:GetFrameInfo
	DD	024H
	DD	03caH
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:LCS_EnqueueReplyFrame
	DD	020H
	DD	0512H
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:LCS_EnqueueEthFrame
	DD	025H
	DD	04e0H
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:LCS_AttnThread
	DD	016H
	DD	0903H
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:LCS_PortThread
	DD	018H
	DD	01a56H
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:LCS_DefaultCmdProc
	DD	01fH
	DD	0106H
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:LCS_LanStats
	DD	022H
	DD	0143H
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:LCS_QueryIPAssists
	DD	01fH
	DD	018aH
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:LCS_StopLan
	DD	022H
	DD	0347H
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:LCS_StartLan
	DD	022H
	DD	047eH
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:LCS_Shutdown
	DD	01fH
	DD	011fH
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:LCS_Startup
	DD	022H
	DD	0376H
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:LCS_Assist
	DD	018H
	DD	0337H
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:LCS_Write
	DD	026H
	DD	01c3eH
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:LCS_Read
	DD	026H
	DD	0a55H
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:LCS_Query
	DD	025H
	DD	0282H
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:LCS_Init
	DD	020H
	DD	014ecH
voltbl	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$fetch_f3_noswap DD 030b01H
	DD	07007220bH
	DD	06006H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$fetch_hw_noswap DD 010901H
	DD	02209H
xdata	ENDS
xdata	SEGMENT
$unwind$time DD	010901H
	DD	04209H
$unwind$DebuggerTrace DD 011801H
	DD	0a218H
$unwind$LCS_Init DD 032819H
	DD	0340116H
	DD	0700fH
	DD	imagerel __GSHandlerCheck
	DD	0198H
$unwind$LCS_Close DD 020c01H
	DD	013010cH
$unwind$LCS_Query DD 022d19H
	DD	037011bH
	DD	imagerel __GSHandlerCheck
	DD	01a0H
$unwind$LCS_ExecuteCCW DD 031901H
	DD	07015c219H
	DD	06014H
$unwind$SetSIDInfo DD 021a01H
	DD	07016121aH
$unwind$LCS_Read DD 042e19H
	DD	019011cH
	DD	060147015H
	DD	imagerel __GSHandlerCheck
	DD	0b8H
$unwind$LCS_Write DD 042e19H
	DD	039011cH
	DD	060147015H
	DD	imagerel __GSHandlerCheck
	DD	01b8H
$unwind$LCS_Assist DD 042019H
	DD	015010eH
	DD	060067007H
	DD	imagerel __GSHandlerCheck
	DD	090H
$unwind$LCS_Startup DD 042a19H
	DD	0170118H
	DD	060107011H
	DD	imagerel __GSHandlerCheck
	DD	0a8H
$unwind$LCS_Shutdown DD 032419H
	DD	07011c215H
	DD	06010H
	DD	imagerel __GSHandlerCheck
	DD	050H
$unwind$LCS_StartLan DD 042a19H
	DD	0150118H
	DD	060107011H
	DD	imagerel __GSHandlerCheck
	DD	090H
$unwind$LCS_StopLan DD 042a19H
	DD	0130118H
	DD	060107011H
	DD	imagerel __GSHandlerCheck
	DD	080H
$unwind$LCS_QueryIPAssists DD 032419H
	DD	07011c215H
	DD	06010H
	DD	imagerel __GSHandlerCheck
	DD	058H
$unwind$LCS_LanStats DD 042a19H
	DD	0130118H
	DD	060107011H
	DD	imagerel __GSHandlerCheck
	DD	080H
$unwind$LCS_AddMulticast DD 011301H
	DD	04213H
$unwind$LCS_DelMulticast DD 011301H
	DD	04213H
$unwind$LCS_DefaultCmdProc DD 032419H
	DD	07011c215H
	DD	06010H
	DD	imagerel __GSHandlerCheck
	DD	050H
$unwind$LCS_PortThread DD 042019H
	DD	0141010eH
	DD	060067007H
	DD	imagerel __GSHandlerCheck
	DD	09f0H
$unwind$LCS_AttnThread DD 021e19H
	DD	039010cH
	DD	imagerel __GSHandlerCheck
	DD	01b0H
$unwind$LCS_EnqueueEthFrame DD 022d19H
	DD	017011bH
	DD	imagerel __GSHandlerCheck
	DD	0a8H
$unwind$LCS_DoEnqueueEthFrame DD 031a01H
	DD	07016c21aH
	DD	06015H
$unwind$LCS_EnqueueReplyFrame DD 022819H
	DD	0190116H
	DD	imagerel __GSHandlerCheck
	DD	0b0H
$unwind$LCS_DoEnqueueReplyFrame DD 031501H
	DD	07011c215H
	DD	06010H
$unwind$GetFrameInfo DD 032919H
	DD	07016a21aH
	DD	06015H
	DD	imagerel __GSHandlerCheck
	DD	048H
$unwind$GetIfMACAddress DD 042019H
	DD	023010eH
	DD	060067007H
	DD	imagerel __GSHandlerCheck
	DD	0108H
$unwind$BuildOAT DD 032a19H
	DD	04960118H
	DD	0700bH
	DD	imagerel __GSHandlerCheck
	DD	024a0H
$unwind$ReadOAT DD 011301H
	DD	0e213H
$unwind$ParseArgs DD 043519H
	DD	04210123H
	DD	060157016H
	DD	imagerel __GSHandlerCheck
	DD	020f8H
$unwind$LCS_Read_SNA DD 041c01H
	DD	019011cH
	DD	060147015H
$unwind$LCS_Write_SNA DD 032d19H
	DD	050011bH
	DD	07014H
	DD	imagerel __GSHandlerCheck
	DD	0270H
$unwind$LCS_StartLan_SNA DD 031501H
	DD	07011e215H
	DD	06010H
$unwind$LCS_StopLan_SNA DD 031501H
	DD	07011e215H
	DD	06010H
$unwind$LCS_LanStats_SNA DD 031501H
	DD	070118215H
	DD	06010H
$unwind$LCS_UnsuppCmd_SNA DD 031501H
	DD	070118215H
	DD	06010H
$unwind$LCS_ProcessAccepted_SNA DD 042f19H
	DD	05f011dH
	DD	060157016H
	DD	imagerel __GSHandlerCheck
	DD	02e0H
$unwind$ExtractLLC DD 031501H
	DD	070116215H
	DD	06010H
$unwind$BuildLLC DD 031f19H
	DD	0700c8210H
	DD	0600bH
	DD	imagerel __GSHandlerCheck
	DD	038H
$unwind$Process_0D10 DD 042f19H
	DD	0109011dH
	DD	060157016H
	DD	imagerel __GSHandlerCheck
	DD	0830H
$unwind$Process_0D00 DD 042f19H
	DD	047011dH
	DD	060157016H
	DD	imagerel __GSHandlerCheck
	DD	0220H
$unwind$Process_8C0B DD 042f19H
	DD	047011dH
	DD	060157016H
	DD	imagerel __GSHandlerCheck
	DD	0220H
$unwind$Process_0C0A DD 041d01H
	DD	011011dH
	DD	060157016H
$unwind$Process_0C25 DD 042f19H
	DD	047011dH
	DD	060157016H
	DD	imagerel __GSHandlerCheck
	DD	0220H
$unwind$Process_0C22 DD 042f19H
	DD	081011dH
	DD	060157016H
	DD	imagerel __GSHandlerCheck
	DD	03f0H
$unwind$Process_8D00 DD 042f19H
	DD	047011dH
	DD	060157016H
	DD	imagerel __GSHandlerCheck
	DD	0220H
$unwind$Process_0C0B DD 031a01H
	DD	07016e21aH
	DD	06015H
$unwind$Process_0C99 DD 031a01H
	DD	07016c21aH
	DD	06015H
$unwind$Process_0C0D DD 031a01H
	DD	07016a21aH
	DD	06015H
$unwind$Process_0C0E DD 031a01H
	DD	07016a21aH
	DD	06015H
$unwind$Process_0C98 DD 031a01H
	DD	07016a21aH
	DD	06015H
$unwind$alloc_lcs_buffer DD 022219H
	DD	0190110H
	DD	imagerel __GSHandlerCheck
	DD	0b0H
$unwind$add_lcs_buffer_to_chain DD 010e01H
	DD	0420eH
$unwind$remove_lcs_buffer_from_chain DD 010901H
	DD	06209H
$unwind$remove_and_free_any_lcs_buffers_on_chain DD 010901H
	DD	06209H
$unwind$free_lcs_buffer DD 010e01H
	DD	0420eH
$unwind$alloc_connection DD 021e19H
	DD	017010cH
	DD	imagerel __GSHandlerCheck
	DD	0a8H
$unwind$add_connection_to_chain DD 010e01H
	DD	0420eH
$unwind$find_connection_by_remote_mac DD 010e01H
	DD	0620eH
$unwind$find_connection_by_outbound_token DD 010e01H
	DD	0620eH
$unwind$find_connection_by_inbound_token DD 010e01H
	DD	0620eH
$unwind$remove_connection_from_chain DD 010e01H
	DD	0820eH
$unwind$remove_and_free_any_connections_on_chain DD 010901H
	DD	06209H
$unwind$free_connection DD 020f01H
	DD	0700b320fH
$unwind$find_group_device DD 010e01H
	DD	0220eH
$unwind$LCS_StartChannelProgram DD 010901H
	DD	02209H
$unwind$LCS_EndChannelProgram DD 010901H
	DD	0c209H
$unwind$LCS_BegMWrite DD 010901H
	DD	08209H
$unwind$LCS_EndMWrite DD 011201H
	DD	08212H
$unwind$UpdatePortStarted DD 011201H
	DD	0c212H
$unwind$LCS_DoMulticast DD 042e19H
	DD	05d011cH
	DD	060147015H
	DD	imagerel __GSHandlerCheck
	DD	02d0H
$unwind$lcs_halt_or_clear DD 010901H
	DD	06209H
$unwind$hdl_check_depends_ep DD 010901H
	DD	06209H
$unwind$hdl_register_symbols_ep DD 010901H
	DD	04209H
$unwind$hdl_define_devtypes_ep DD 010901H
	DD	04209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$sscanf DD 011801H
	DD	06218H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$_vsscanf_l DD 011801H
	DD	06218H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$_vsnprintf_s DD 011801H
	DD	06218H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$_vsnprintf_s_l DD 011801H
	DD	0a218H
xdata	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\ctc_lcs.c
_TEXT	SEGMENT
defdev$ = 48
hdl_define_devtypes_ep PROC

; 7929 : HDL_DEVICE_SECTION;

$LN3:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 7930 : {
; 7931 :     HDL_DEVICE( LCS, lcs_device_hndinfo );

  00009	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:lcs_device_hndinfo
  00010	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG175741
  00017	ff 54 24 30	 call	 QWORD PTR defdev$[rsp]

; 7932 : 
; 7933 : // ZZ the following device types should be moved to
; 7934 : // ZZ their own loadable modules
; 7935 : 
; 7936 :     HDL_DEVICE( CTCI, ctci_device_hndinfo );

  0001b	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:ctci_device_hndinfo
  00022	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG175742
  00029	ff 54 24 30	 call	 QWORD PTR defdev$[rsp]

; 7937 :     HDL_DEVICE( CTCT, ctct_device_hndinfo );

  0002d	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:ctct_device_hndinfo
  00034	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG175743
  0003b	ff 54 24 30	 call	 QWORD PTR defdev$[rsp]

; 7938 :     HDL_DEVICE( CTCE, ctce_device_hndinfo );

  0003f	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:ctce_device_hndinfo
  00046	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG175744
  0004d	ff 54 24 30	 call	 QWORD PTR defdev$[rsp]

; 7939 : }
; 7940 : END_DEVICE_SECTION

  00051	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00055	c3		 ret	 0
hdl_define_devtypes_ep ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\ctc_lcs.c
_TEXT	SEGMENT
regsym$ = 48
hdl_register_symbols_ep PROC

; 7912 : HDL_REGISTER_SECTION;       // ("Register" our entry-points)

$LN3:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 7913 : 
; 7914 : //                 Hercules's          Our
; 7915 : //                 registered          overriding
; 7916 : //                 entry-point         entry-point
; 7917 : //                 name                value
; 7918 : 
; 7919 : #if defined( WIN32 )
; 7920 :   HDL_REGISTER ( debug_tt32_stats,   display_tt32_stats        );

  00009	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:display_tt32_stats
  00010	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG175735
  00017	ff 54 24 30	 call	 QWORD PTR regsym$[rsp]

; 7921 :   HDL_REGISTER ( debug_tt32_tracing, enable_tt32_debug_tracing );

  0001b	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:enable_tt32_debug_tracing
  00022	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG175736
  00029	ff 54 24 30	 call	 QWORD PTR regsym$[rsp]

; 7922 : #else
; 7923 :   UNREFERENCED( regsym );   // (HDL_REGISTER_SECTION parameter)
; 7924 : #endif
; 7925 : 
; 7926 : END_REGISTER_SECTION

  0002d	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00031	c3		 ret	 0
hdl_register_symbols_ep ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\ctc_lcs.c
_TEXT	SEGMENT
depchk_rc$ = 32
depchk$ = 64
hdl_check_depends_ep PROC

; 7905 : HDL_DEPENDENCY_SECTION;

$LN11:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 38	 sub	 rsp, 56			; 00000038H
  00009	c7 44 24 20 00
	00 00 00	 mov	 DWORD PTR depchk_rc$[rsp], 0
$LN4@hdl_check_:

; 7906 : {
; 7907 :      HDL_DEPENDENCY(HERCULES);

  00011	41 b8 08 00 00
	00		 mov	 r8d, 8
  00017	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG175724
  0001e	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG175725
  00025	ff 54 24 40	 call	 QWORD PTR depchk$[rsp]
  00029	85 c0		 test	 eax, eax
  0002b	74 08		 je	 SHORT $LN8@hdl_check_
  0002d	c7 44 24 20 01
	00 00 00	 mov	 DWORD PTR depchk_rc$[rsp], 1
$LN8@hdl_check_:
  00035	33 c0		 xor	 eax, eax
  00037	85 c0		 test	 eax, eax
  00039	75 d6		 jne	 SHORT $LN4@hdl_check_
$LN7@hdl_check_:

; 7908 :      HDL_DEPENDENCY(DEVBLK);

  0003b	41 b8 a0 1b 00
	00		 mov	 r8d, 7072		; 00001ba0H
  00041	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG175727
  00048	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG175728
  0004f	ff 54 24 40	 call	 QWORD PTR depchk$[rsp]
  00053	85 c0		 test	 eax, eax
  00055	74 08		 je	 SHORT $LN9@hdl_check_
  00057	c7 44 24 20 01
	00 00 00	 mov	 DWORD PTR depchk_rc$[rsp], 1
$LN9@hdl_check_:
  0005f	33 c0		 xor	 eax, eax
  00061	85 c0		 test	 eax, eax
  00063	75 d6		 jne	 SHORT $LN7@hdl_check_

; 7909 : }
; 7910 : END_DEPENDENCY_SECTION

  00065	8b 44 24 20	 mov	 eax, DWORD PTR depchk_rc$[rsp]
  00069	48 83 c4 38	 add	 rsp, 56			; 00000038H
  0006d	c3		 ret	 0
hdl_check_depends_ep ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\ctc_lcs.c
_TEXT	SEGMENT
pLCSDEV$ = 32
pDEVBLK$ = 64
lcs_halt_or_clear PROC

; 2910 : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 2911 :     PLCSDEV pLCSDEV = (PLCSDEV) pDEVBLK->dev_data;

  00009	48 8b 44 24 40	 mov	 rax, QWORD PTR pDEVBLK$[rsp]
  0000e	48 8b 80 08 06
	00 00		 mov	 rax, QWORD PTR [rax+1544]
  00015	48 89 44 24 20	 mov	 QWORD PTR pLCSDEV$[rsp], rax

; 2912 :     obtain_lock( &pLCSDEV->DevEventLock );

  0001a	48 8b 44 24 20	 mov	 rax, QWORD PTR pLCSDEV$[rsp]
  0001f	48 83 c0 31	 add	 rax, 49			; 00000031H
  00023	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG172351
  0002a	48 8b c8	 mov	 rcx, rax
  0002d	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_obtain_lock

; 2913 :     {
; 2914 :         if (pLCSDEV->fReadWaiting)

  00033	48 8b 44 24 20	 mov	 rax, QWORD PTR pLCSDEV$[rsp]
  00038	8b 40 41	 mov	 eax, DWORD PTR [rax+65]
  0003b	c1 e8 05	 shr	 eax, 5
  0003e	83 e0 01	 and	 eax, 1
  00041	85 c0		 test	 eax, eax
  00043	74 2c		 je	 SHORT $LN2@lcs_halt_o

; 2915 :         {
; 2916 :             pLCSDEV->fHaltOrClear = 1;

  00045	48 8b 44 24 20	 mov	 rax, QWORD PTR pLCSDEV$[rsp]
  0004a	8b 40 41	 mov	 eax, DWORD PTR [rax+65]
  0004d	83 c8 40	 or	 eax, 64			; 00000040H
  00050	48 8b 4c 24 20	 mov	 rcx, QWORD PTR pLCSDEV$[rsp]
  00055	89 41 41	 mov	 DWORD PTR [rcx+65], eax

; 2917 :             signal_condition( &pLCSDEV->DevEvent );

  00058	48 8b 44 24 20	 mov	 rax, QWORD PTR pLCSDEV$[rsp]
  0005d	48 83 c0 39	 add	 rax, 57			; 00000039H
  00061	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG172353
  00068	48 8b c8	 mov	 rcx, rax
  0006b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_signal_condition
$LN2@lcs_halt_o:

; 2918 :         }
; 2919 :     }
; 2920 :     release_lock( &pLCSDEV->DevEventLock );

  00071	48 8b 44 24 20	 mov	 rax, QWORD PTR pLCSDEV$[rsp]
  00076	48 83 c0 31	 add	 rax, 49			; 00000031H
  0007a	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG172354
  00081	48 8b c8	 mov	 rcx, rax
  00084	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_release_lock

; 2921 : }

  0008a	48 83 c4 38	 add	 rsp, 56			; 00000038H
  0008e	c3		 ret	 0
lcs_halt_or_clear ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\ctc_lcs.c
_TEXT	SEGMENT
i$ = 96
numpairs$ = 100
rc$ = 104
badrc$ = 108
pLCSPORT$ = 112
iReplyLen$ = 120
errnum$ = 124
pszMAC$ = 128
pLCSIPMFRM$ = 136
pMAC$ = 144
what$ = 152
tv195 = 160
tv244 = 164
tv364 = 168
pIPMFrame$ = 176
tv148 = 184
tv149 = 192
tv280 = 200
tv281 = 208
tv77 = 216
tv197 = 224
tv246 = 232
tv260 = 240
tv366 = 248
tv380 = 256
tv383 = 264
ifr$ = 272
Reply$ = 304
__$ArrayPad$ = 720
ioctlcode$ = 768
pLCSDEV$ = 776
pCmdFrame$ = 784
iCmdLen$ = 792
LCS_DoMulticast PROC

; 1951 : {

  00000	44 89 4c 24 20	 mov	 DWORD PTR [rsp+32], r9d
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	89 4c 24 08	 mov	 DWORD PTR [rsp+8], ecx
  00013	56		 push	 rsi
  00014	57		 push	 rdi
  00015	48 81 ec e8 02
	00 00		 sub	 rsp, 744		; 000002e8H
  0001c	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00023	48 33 c4	 xor	 rax, rsp
  00026	48 89 84 24 d0
	02 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 1952 : 
; 1953 :     LCSIPMFRM         Reply;
; 1954 :     int               iReplyLen = sizeof(Reply);  /* Used and changed by INIT_REPLY_FRAME */

  0002e	c7 44 24 78 98
	01 00 00	 mov	 DWORD PTR iReplyLen$[rsp], 408 ; 00000198H

; 1955 :     PLCSIPMFRM        pLCSIPMFRM = (PLCSIPMFRM)&Reply;

  00036	48 8d 84 24 30
	01 00 00	 lea	 rax, QWORD PTR Reply$[rsp]
  0003e	48 89 84 24 88
	00 00 00	 mov	 QWORD PTR pLCSIPMFRM$[rsp], rax

; 1956 :     const LCSIPMFRM*  pIPMFrame;
; 1957 :     LCSPORT*          pLCSPORT;
; 1958 :     const MAC*        pMAC;
; 1959 :     ifreq             ifr = {0};

  00046	48 8d 84 24 10
	01 00 00	 lea	 rax, QWORD PTR ifr$[rsp]
  0004e	48 8b f8	 mov	 rdi, rax
  00051	33 c0		 xor	 eax, eax
  00053	b9 20 00 00 00	 mov	 ecx, 32			; 00000020H
  00058	f3 aa		 rep stosb

; 1960 :     int               rc, badrc = 0, errnum = 0;

  0005a	c7 44 24 6c 00
	00 00 00	 mov	 DWORD PTR badrc$[rsp], 0
  00062	c7 44 24 7c 00
	00 00 00	 mov	 DWORD PTR errnum$[rsp], 0
$LN4@LCS_DoMult:

; 1961 :     U16               i, numpairs;
; 1962 :     char*             pszMAC;
; 1963 :     const char*       what;
; 1964 : 
; 1965 :     // Initialize reply frame
; 1966 : 
; 1967 :     INIT_REPLY_FRAME( pLCSIPMFRM, iReplyLen, pCmdFrame, iCmdLen );

  0006a	8b 44 24 78	 mov	 eax, DWORD PTR iReplyLen$[rsp]
  0006e	39 84 24 18 03
	00 00		 cmp	 DWORD PTR iCmdLen$[rsp], eax
  00075	7c 1c		 jl	 SHORT $LN29@LCS_DoMult
  00077	48 63 44 24 78	 movsxd	 rax, DWORD PTR iReplyLen$[rsp]
  0007c	48 8b bc 24 88
	00 00 00	 mov	 rdi, QWORD PTR pLCSIPMFRM$[rsp]
  00084	48 8b b4 24 10
	03 00 00	 mov	 rsi, QWORD PTR pCmdFrame$[rsp]
  0008c	48 8b c8	 mov	 rcx, rax
  0008f	f3 a4		 rep movsb
  00091	eb 49		 jmp	 SHORT $LN30@LCS_DoMult
$LN29@LCS_DoMult:
  00093	48 63 44 24 78	 movsxd	 rax, DWORD PTR iReplyLen$[rsp]
  00098	48 89 84 24 d8
	00 00 00	 mov	 QWORD PTR tv77[rsp], rax
  000a0	48 8b bc 24 88
	00 00 00	 mov	 rdi, QWORD PTR pLCSIPMFRM$[rsp]
  000a8	33 c0		 xor	 eax, eax
  000aa	48 8b 8c 24 d8
	00 00 00	 mov	 rcx, QWORD PTR tv77[rsp]
  000b2	f3 aa		 rep stosb
  000b4	48 63 84 24 18
	03 00 00	 movsxd	 rax, DWORD PTR iCmdLen$[rsp]
  000bc	48 8b bc 24 88
	00 00 00	 mov	 rdi, QWORD PTR pLCSIPMFRM$[rsp]
  000c4	48 8b b4 24 10
	03 00 00	 mov	 rsi, QWORD PTR pCmdFrame$[rsp]
  000cc	48 8b c8	 mov	 rcx, rax
  000cf	f3 a4		 rep movsb
  000d1	8b 84 24 18 03
	00 00		 mov	 eax, DWORD PTR iCmdLen$[rsp]
  000d8	89 44 24 78	 mov	 DWORD PTR iReplyLen$[rsp], eax
$LN30@LCS_DoMult:
  000dc	33 c9		 xor	 ecx, ecx
  000de	e8 00 00 00 00	 call	 _byteswap_ushort
  000e3	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR pLCSIPMFRM$[rsp]
  000eb	0f b7 d0	 movzx	 edx, ax
  000ee	e8 00 00 00 00	 call	 store_hw_noswap
  000f3	33 c9		 xor	 ecx, ecx
  000f5	e8 00 00 00 00	 call	 _byteswap_ushort
  000fa	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR pLCSIPMFRM$[rsp]
  00102	48 83 c1 08	 add	 rcx, 8
  00106	0f b7 d0	 movzx	 edx, ax
  00109	e8 00 00 00 00	 call	 store_hw_noswap
  0010e	33 c0		 xor	 eax, eax
  00110	85 c0		 test	 eax, eax
  00112	0f 85 52 ff ff
	ff		 jne	 $LN4@LCS_DoMult

; 1968 :     pIPMFrame = (const LCSIPMFRM*) pCmdFrame;

  00118	48 8b 84 24 10
	03 00 00	 mov	 rax, QWORD PTR pCmdFrame$[rsp]
  00120	48 89 84 24 b0
	00 00 00	 mov	 QWORD PTR pIPMFrame$[rsp], rax

; 1969 :     pLCSPORT  = &pLCSDEV->pLCSBLK->Port[ pLCSDEV->bPort ];

  00128	48 8b 84 24 08
	03 00 00	 mov	 rax, QWORD PTR pLCSDEV$[rsp]
  00130	48 8b 40 08	 mov	 rax, QWORD PTR [rax+8]
  00134	48 8b 8c 24 08
	03 00 00	 mov	 rcx, QWORD PTR pLCSDEV$[rsp]
  0013c	0f b6 49 23	 movzx	 ecx, BYTE PTR [rcx+35]
  00140	48 69 c9 98 01
	00 00		 imul	 rcx, rcx, 408		; 00000198H
  00147	48 8d 44 08 60	 lea	 rax, QWORD PTR [rax+rcx+96]
  0014c	48 89 44 24 70	 mov	 QWORD PTR pLCSPORT$[rsp], rax

; 1970 : 
; 1971 :     // Retrieve number of MAC addresses in their request
; 1972 : 
; 1973 :     FETCH_HW( numpairs, pIPMFrame->hwNumIPPairs );

  00151	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR pIPMFrame$[rsp]
  00159	48 83 c0 0c	 add	 rax, 12
  0015d	48 8b c8	 mov	 rcx, rax
  00160	e8 00 00 00 00	 call	 fetch_hw_noswap
  00165	0f b7 c8	 movzx	 ecx, ax
  00168	e8 00 00 00 00	 call	 _byteswap_ushort
  0016d	66 89 44 24 64	 mov	 WORD PTR numpairs$[rsp], ax

; 1974 :     if (numpairs > MAX_IP_MAC_PAIRS)

  00172	0f b7 44 24 64	 movzx	 eax, WORD PTR numpairs$[rsp]
  00177	83 f8 20	 cmp	 eax, 32			; 00000020H
  0017a	7e 0a		 jle	 SHORT $LN31@LCS_DoMult

; 1975 :         numpairs = MAX_IP_MAC_PAIRS;

  0017c	b8 20 00 00 00	 mov	 eax, 32			; 00000020H
  00181	66 89 44 24 64	 mov	 WORD PTR numpairs$[rsp], ax
$LN31@LCS_DoMult:

; 1976 : 
; 1977 :     // If tuntap multicast assist is available, use it.
; 1978 :     // Otherwise keep track of guest's request manually.
; 1979 : 
; 1980 :     if (pLCSPORT->fDoMCastAssist)  // (manual multicast assist?)

  00186	48 8b 44 24 70	 mov	 rax, QWORD PTR pLCSPORT$[rsp]
  0018b	8b 80 34 01 00
	00		 mov	 eax, DWORD PTR [rax+308]
  00191	c1 e8 08	 shr	 eax, 8
  00194	83 e0 01	 and	 eax, 1
  00197	85 c0		 test	 eax, eax
  00199	0f 84 8b 04 00
	00		 je	 $LN32@LCS_DoMult

; 1981 :     {
; 1982 :         what = (U32) SIOCADDMULTI == (U32) ioctlcode ? "MACTabAdd"

  0019f	81 bc 24 00 03
	00 00 31 89 00
	00		 cmp	 DWORD PTR ioctlcode$[rsp], 35121 ; 00008931H
  001aa	75 11		 jne	 SHORT $LN59@LCS_DoMult
  001ac	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG171323
  001b3	48 89 84 24 c0
	00 00 00	 mov	 QWORD PTR tv149[rsp], rax
  001bb	eb 3d		 jmp	 SHORT $LN60@LCS_DoMult
$LN59@LCS_DoMult:
  001bd	81 bc 24 00 03
	00 00 32 89 00
	00		 cmp	 DWORD PTR ioctlcode$[rsp], 35122 ; 00008932H
  001c8	75 11		 jne	 SHORT $LN57@LCS_DoMult
  001ca	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG171324
  001d1	48 89 84 24 b8
	00 00 00	 mov	 QWORD PTR tv148[rsp], rax
  001d9	eb 0f		 jmp	 SHORT $LN58@LCS_DoMult
$LN57@LCS_DoMult:
  001db	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG171325
  001e2	48 89 84 24 b8
	00 00 00	 mov	 QWORD PTR tv148[rsp], rax
$LN58@LCS_DoMult:
  001ea	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR tv148[rsp]
  001f2	48 89 84 24 c0
	00 00 00	 mov	 QWORD PTR tv149[rsp], rax
$LN60@LCS_DoMult:
  001fa	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR tv149[rsp]
  00202	48 89 84 24 98
	00 00 00	 mov	 QWORD PTR what$[rsp], rax

; 1983 :              : (U32) SIOCDELMULTI == (U32) ioctlcode ? "MACTabRem" : "???";
; 1984 : 
; 1985 :         for (i=0, badrc=0; i < numpairs; i++)

  0020a	33 c0		 xor	 eax, eax
  0020c	66 89 44 24 60	 mov	 WORD PTR i$[rsp], ax
  00211	c7 44 24 6c 00
	00 00 00	 mov	 DWORD PTR badrc$[rsp], 0
  00219	eb 0d		 jmp	 SHORT $LN7@LCS_DoMult
$LN5@LCS_DoMult:
  0021b	0f b7 44 24 60	 movzx	 eax, WORD PTR i$[rsp]
  00220	66 ff c0	 inc	 ax
  00223	66 89 44 24 60	 mov	 WORD PTR i$[rsp], ax
$LN7@LCS_DoMult:
  00228	0f b7 44 24 60	 movzx	 eax, WORD PTR i$[rsp]
  0022d	0f b7 4c 24 64	 movzx	 ecx, WORD PTR numpairs$[rsp]
  00232	3b c1		 cmp	 eax, ecx
  00234	0f 8d 48 03 00
	00		 jge	 $LN6@LCS_DoMult

; 1986 :         {
; 1987 :             pMAC = &pIPMFrame->IP_MAC_Pair[i].MAC_Address;

  0023a	0f b7 44 24 60	 movzx	 eax, WORD PTR i$[rsp]
  0023f	48 6b c0 0c	 imul	 rax, rax, 12
  00243	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR pIPMFrame$[rsp]
  0024b	48 8d 44 01 18	 lea	 rax, QWORD PTR [rcx+rax+24]
  00250	48 89 84 24 90
	00 00 00	 mov	 QWORD PTR pMAC$[rsp], rax

; 1988 : 
; 1989 :             // Remember (or forget) this MAC for later
; 1990 : 
; 1991 :             if ((U32) SIOCADDMULTI == (U32) ioctlcode)

  00258	81 bc 24 00 03
	00 00 31 89 00
	00		 cmp	 DWORD PTR ioctlcode$[rsp], 35121 ; 00008931H
  00263	0f 85 8e 01 00
	00		 jne	 $LN34@LCS_DoMult

; 1992 :             {
; 1993 :                 if ((rc = MACTabAdd( pLCSPORT->MCastTab, (BYTE*) pMAC, 0 )) == 0)

  00269	48 8b 44 24 70	 mov	 rax, QWORD PTR pLCSPORT$[rsp]
  0026e	48 83 c0 18	 add	 rax, 24
  00272	45 33 c0	 xor	 r8d, r8d
  00275	48 8b 94 24 90
	00 00 00	 mov	 rdx, QWORD PTR pMAC$[rsp]
  0027d	48 8b c8	 mov	 rcx, rax
  00280	e8 00 00 00 00	 call	 MACTabAdd
  00285	89 44 24 68	 mov	 DWORD PTR rc$[rsp], eax
  00289	83 7c 24 68 00	 cmp	 DWORD PTR rc$[rsp], 0
  0028e	0f 85 54 01 00
	00		 jne	 $LN36@LCS_DoMult

; 1994 :                 {
; 1995 :                     pLCSPORT->nMCastCount++;

  00294	48 8b 44 24 70	 mov	 rax, QWORD PTR pLCSPORT$[rsp]
  00299	0f b6 40 01	 movzx	 eax, BYTE PTR [rax+1]
  0029d	fe c0		 inc	 al
  0029f	48 8b 4c 24 70	 mov	 rcx, QWORD PTR pLCSPORT$[rsp]
  002a4	88 41 01	 mov	 BYTE PTR [rcx+1], al

; 1996 : 
; 1997 :                     if (pLCSDEV->pLCSBLK->fDebug)

  002a7	48 8b 84 24 08
	03 00 00	 mov	 rax, QWORD PTR pLCSDEV$[rsp]
  002af	48 8b 40 08	 mov	 rax, QWORD PTR [rax+8]
  002b3	8b 40 18	 mov	 eax, DWORD PTR [rax+24]
  002b6	83 e0 01	 and	 eax, 1
  002b9	85 c0		 test	 eax, eax
  002bb	0f 84 25 01 00
	00		 je	 $LN38@LCS_DoMult
$LN10@LCS_DoMult:

; 1998 :                     {
; 1999 :                         VERIFY( FormatMAC( &pszMAC, (BYTE*) pMAC ) == 0);

  002c1	48 8b 94 24 90
	00 00 00	 mov	 rdx, QWORD PTR pMAC$[rsp]
  002c9	48 8d 8c 24 80
	00 00 00	 lea	 rcx, QWORD PTR pszMAC$[rsp]
  002d1	e8 00 00 00 00	 call	 FormatMAC
  002d6	85 c0		 test	 eax, eax
  002d8	74 5c		 je	 SHORT $LN39@LCS_DoMult
$LN13@LCS_DoMult:
  002da	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG171332
  002e1	41 b8 cf 07 00
	00		 mov	 r8d, 1999		; 000007cfH
  002e7	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG171333
  002ee	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG171334
  002f5	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_logmsg
  002fb	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_IsDebuggerPresent
  00301	85 c0		 test	 eax, eax
  00303	74 20		 je	 SHORT $LN40@LCS_DoMult
  00305	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG171336
  0030c	41 b8 cf 07 00
	00		 mov	 r8d, 1999		; 000007cfH
  00312	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG171337
  00319	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG171338
  00320	e8 00 00 00 00	 call	 DebuggerTrace
$LN40@LCS_DoMult:
  00325	33 c0		 xor	 eax, eax
  00327	85 c0		 test	 eax, eax
  00329	75 af		 jne	 SHORT $LN13@LCS_DoMult
  0032b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_IsDebuggerPresent
  00331	85 c0		 test	 eax, eax
  00333	74 01		 je	 SHORT $LN41@LCS_DoMult
  00335	cc		 int	 3
$LN41@LCS_DoMult:
$LN39@LCS_DoMult:
  00336	33 c0		 xor	 eax, eax
  00338	85 c0		 test	 eax, eax
  0033a	75 85		 jne	 SHORT $LN10@LCS_DoMult

; 2000 :                         // "CTC: lcs device '%s' port %2.2X: %s %s: ok"
; 2001 :                         WRMSG( HHC00964, "D", pLCSPORT->szNetIfName, pLCSPORT->bPort,

  0033c	48 8b 44 24 70	 mov	 rax, QWORD PTR pLCSPORT$[rsp]
  00341	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  00344	89 84 24 a0 00
	00 00		 mov	 DWORD PTR tv195[rsp], eax
  0034b	48 8b 4c 24 70	 mov	 rcx, QWORD PTR pLCSPORT$[rsp]
  00350	48 81 c1 48 01
	00 00		 add	 rcx, 328		; 00000148H
  00357	48 89 8c 24 e0
	00 00 00	 mov	 QWORD PTR tv197[rsp], rcx
  0035f	b9 01 00 00 00	 mov	 ecx, 1
  00364	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  0036a	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR pszMAC$[rsp]
  00372	48 89 4c 24 50	 mov	 QWORD PTR [rsp+80], rcx
  00377	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR what$[rsp]
  0037f	48 89 4c 24 48	 mov	 QWORD PTR [rsp+72], rcx
  00384	8b 8c 24 a0 00
	00 00		 mov	 ecx, DWORD PTR tv195[rsp]
  0038b	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  0038f	48 8b 8c 24 e0
	00 00 00	 mov	 rcx, QWORD PTR tv197[rsp]
  00397	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  0039c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG171340
  003a3	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  003a8	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG171341
  003af	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  003b4	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  003b9	41 b9 03 00 00
	00		 mov	 r9d, 3
  003bf	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG171342
  003c6	ba d2 07 00 00	 mov	 edx, 2002		; 000007d2H
  003cb	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG171343
  003d2	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 2002 :                             what, pszMAC );
; 2003 :                         free( pszMAC );

  003d8	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR pszMAC$[rsp]
  003e0	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free
$LN38@LCS_DoMult:

; 2004 :                     }
; 2005 :                 }

  003e6	eb 0a		 jmp	 SHORT $LN37@LCS_DoMult
$LN36@LCS_DoMult:

; 2006 :                 else
; 2007 :                     badrc = -rc;    // (convert to errno)

  003e8	8b 44 24 68	 mov	 eax, DWORD PTR rc$[rsp]
  003ec	f7 d8		 neg	 eax
  003ee	89 44 24 6c	 mov	 DWORD PTR badrc$[rsp], eax
$LN37@LCS_DoMult:

; 2008 :             }

  003f2	e9 86 01 00 00	 jmp	 $LN35@LCS_DoMult
$LN34@LCS_DoMult:

; 2009 :             else // ((U32) SIOCDELMULTI == (U32) ioctlcode)
; 2010 :             {
; 2011 :                 if ((rc = MACTabRem( pLCSPORT->MCastTab, (BYTE*) pMAC )) == 0)

  003f7	48 8b 44 24 70	 mov	 rax, QWORD PTR pLCSPORT$[rsp]
  003fc	48 83 c0 18	 add	 rax, 24
  00400	48 8b 94 24 90
	00 00 00	 mov	 rdx, QWORD PTR pMAC$[rsp]
  00408	48 8b c8	 mov	 rcx, rax
  0040b	e8 00 00 00 00	 call	 MACTabRem
  00410	89 44 24 68	 mov	 DWORD PTR rc$[rsp], eax
  00414	83 7c 24 68 00	 cmp	 DWORD PTR rc$[rsp], 0
  00419	0f 85 54 01 00
	00		 jne	 $LN42@LCS_DoMult

; 2012 :                 {
; 2013 :                     pLCSPORT->nMCastCount--;

  0041f	48 8b 44 24 70	 mov	 rax, QWORD PTR pLCSPORT$[rsp]
  00424	0f b6 40 01	 movzx	 eax, BYTE PTR [rax+1]
  00428	fe c8		 dec	 al
  0042a	48 8b 4c 24 70	 mov	 rcx, QWORD PTR pLCSPORT$[rsp]
  0042f	88 41 01	 mov	 BYTE PTR [rcx+1], al

; 2014 : 
; 2015 :                     if (pLCSDEV->pLCSBLK->fDebug)

  00432	48 8b 84 24 08
	03 00 00	 mov	 rax, QWORD PTR pLCSDEV$[rsp]
  0043a	48 8b 40 08	 mov	 rax, QWORD PTR [rax+8]
  0043e	8b 40 18	 mov	 eax, DWORD PTR [rax+24]
  00441	83 e0 01	 and	 eax, 1
  00444	85 c0		 test	 eax, eax
  00446	0f 84 25 01 00
	00		 je	 $LN44@LCS_DoMult
$LN16@LCS_DoMult:

; 2016 :                     {
; 2017 :                         VERIFY( FormatMAC( &pszMAC, (BYTE*) pMAC ) == 0);

  0044c	48 8b 94 24 90
	00 00 00	 mov	 rdx, QWORD PTR pMAC$[rsp]
  00454	48 8d 8c 24 80
	00 00 00	 lea	 rcx, QWORD PTR pszMAC$[rsp]
  0045c	e8 00 00 00 00	 call	 FormatMAC
  00461	85 c0		 test	 eax, eax
  00463	74 5c		 je	 SHORT $LN45@LCS_DoMult
$LN19@LCS_DoMult:
  00465	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG171348
  0046c	41 b8 e1 07 00
	00		 mov	 r8d, 2017		; 000007e1H
  00472	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG171349
  00479	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG171350
  00480	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_logmsg
  00486	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_IsDebuggerPresent
  0048c	85 c0		 test	 eax, eax
  0048e	74 20		 je	 SHORT $LN46@LCS_DoMult
  00490	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG171352
  00497	41 b8 e1 07 00
	00		 mov	 r8d, 2017		; 000007e1H
  0049d	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG171353
  004a4	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG171354
  004ab	e8 00 00 00 00	 call	 DebuggerTrace
$LN46@LCS_DoMult:
  004b0	33 c0		 xor	 eax, eax
  004b2	85 c0		 test	 eax, eax
  004b4	75 af		 jne	 SHORT $LN19@LCS_DoMult
  004b6	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_IsDebuggerPresent
  004bc	85 c0		 test	 eax, eax
  004be	74 01		 je	 SHORT $LN47@LCS_DoMult
  004c0	cc		 int	 3
$LN47@LCS_DoMult:
$LN45@LCS_DoMult:
  004c1	33 c0		 xor	 eax, eax
  004c3	85 c0		 test	 eax, eax
  004c5	75 85		 jne	 SHORT $LN16@LCS_DoMult

; 2018 :                         // "CTC: lcs device '%s' port %2.2X: %s %s: ok"
; 2019 :                         WRMSG( HHC00964, "D", pLCSPORT->szNetIfName, pLCSPORT->bPort,

  004c7	48 8b 44 24 70	 mov	 rax, QWORD PTR pLCSPORT$[rsp]
  004cc	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  004cf	89 84 24 a4 00
	00 00		 mov	 DWORD PTR tv244[rsp], eax
  004d6	48 8b 4c 24 70	 mov	 rcx, QWORD PTR pLCSPORT$[rsp]
  004db	48 81 c1 48 01
	00 00		 add	 rcx, 328		; 00000148H
  004e2	48 89 8c 24 e8
	00 00 00	 mov	 QWORD PTR tv246[rsp], rcx
  004ea	b9 01 00 00 00	 mov	 ecx, 1
  004ef	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  004f5	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR pszMAC$[rsp]
  004fd	48 89 4c 24 50	 mov	 QWORD PTR [rsp+80], rcx
  00502	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR what$[rsp]
  0050a	48 89 4c 24 48	 mov	 QWORD PTR [rsp+72], rcx
  0050f	8b 8c 24 a4 00
	00 00		 mov	 ecx, DWORD PTR tv244[rsp]
  00516	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  0051a	48 8b 8c 24 e8
	00 00 00	 mov	 rcx, QWORD PTR tv246[rsp]
  00522	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  00527	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG171356
  0052e	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  00533	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG171357
  0053a	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  0053f	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00544	41 b9 03 00 00
	00		 mov	 r9d, 3
  0054a	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG171358
  00551	ba e4 07 00 00	 mov	 edx, 2020		; 000007e4H
  00556	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG171359
  0055d	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 2020 :                             what, pszMAC );
; 2021 :                         free( pszMAC );

  00563	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR pszMAC$[rsp]
  0056b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free
$LN44@LCS_DoMult:

; 2022 :                     }
; 2023 :                 }

  00571	eb 0a		 jmp	 SHORT $LN43@LCS_DoMult
$LN42@LCS_DoMult:

; 2024 :                 else
; 2025 :                     badrc = -rc;    // (convert to errno)

  00573	8b 44 24 68	 mov	 eax, DWORD PTR rc$[rsp]
  00577	f7 d8		 neg	 eax
  00579	89 44 24 6c	 mov	 DWORD PTR badrc$[rsp], eax
$LN43@LCS_DoMult:
$LN35@LCS_DoMult:

; 2026 :             }
; 2027 :         }

  0057d	e9 99 fc ff ff	 jmp	 $LN5@LCS_DoMult
$LN6@LCS_DoMult:

; 2028 : 
; 2029 :         // Set return code and issue message if any requests failed.
; 2030 : 
; 2031 :         if (badrc)

  00582	83 7c 24 6c 00	 cmp	 DWORD PTR badrc$[rsp], 0
  00587	0f 84 98 00 00
	00		 je	 $LN48@LCS_DoMult

; 2032 :         {
; 2033 :             errnum = badrc;  // (get errno)

  0058d	8b 44 24 6c	 mov	 eax, DWORD PTR badrc$[rsp]
  00591	89 44 24 7c	 mov	 DWORD PTR errnum$[rsp], eax

; 2034 :             // "CTC: error in function %s: %s"
; 2035 :             WRMSG( HHC00940, "E", what, strerror( errnum ));

  00595	8b 4c 24 7c	 mov	 ecx, DWORD PTR errnum$[rsp]
  00599	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_strerror
  0059f	48 89 84 24 f0
	00 00 00	 mov	 QWORD PTR tv260[rsp], rax
  005a7	b9 01 00 00 00	 mov	 ecx, 1
  005ac	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  005b2	48 8b 8c 24 f0
	00 00 00	 mov	 rcx, QWORD PTR tv260[rsp]
  005ba	48 89 4c 24 40	 mov	 QWORD PTR [rsp+64], rcx
  005bf	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR what$[rsp]
  005c7	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  005cc	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG171361
  005d3	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  005d8	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG171362
  005df	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  005e4	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  005e9	41 b9 03 00 00
	00		 mov	 r9d, 3
  005ef	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG171363
  005f6	ba f3 07 00 00	 mov	 edx, 2035		; 000007f3H
  005fb	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG171364
  00602	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 2036 :             STORE_HW( pLCSIPMFRM->bLCSCmdHdr.hwReturnCode, 0xFFFF );

  00608	66 b9 ff ff	 mov	 cx, 65535		; 0000ffffH
  0060c	e8 00 00 00 00	 call	 _byteswap_ushort
  00611	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR pLCSIPMFRM$[rsp]
  00619	48 83 c1 08	 add	 rcx, 8
  0061d	0f b7 d0	 movzx	 edx, ax
  00620	e8 00 00 00 00	 call	 store_hw_noswap
$LN48@LCS_DoMult:

; 2037 :         }
; 2038 :     }

  00625	e9 2e 03 00 00	 jmp	 $LN33@LCS_DoMult
$LN32@LCS_DoMult:

; 2039 :     else // (!pLCSPORT->fDoMCastAssist): let tuntap do it for us
; 2040 :     {
; 2041 :         // Issue ioctl for each MAC address in their request
; 2042 : 
; 2043 :         what = (U32) SIOCADDMULTI == (U32) ioctlcode ? "SIOCADDMULTI"

  0062a	81 bc 24 00 03
	00 00 31 89 00
	00		 cmp	 DWORD PTR ioctlcode$[rsp], 35121 ; 00008931H
  00635	75 11		 jne	 SHORT $LN63@LCS_DoMult
  00637	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG171365
  0063e	48 89 84 24 d0
	00 00 00	 mov	 QWORD PTR tv281[rsp], rax
  00646	eb 3d		 jmp	 SHORT $LN64@LCS_DoMult
$LN63@LCS_DoMult:
  00648	81 bc 24 00 03
	00 00 32 89 00
	00		 cmp	 DWORD PTR ioctlcode$[rsp], 35122 ; 00008932H
  00653	75 11		 jne	 SHORT $LN61@LCS_DoMult
  00655	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG171366
  0065c	48 89 84 24 c8
	00 00 00	 mov	 QWORD PTR tv280[rsp], rax
  00664	eb 0f		 jmp	 SHORT $LN62@LCS_DoMult
$LN61@LCS_DoMult:
  00666	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG171367
  0066d	48 89 84 24 c8
	00 00 00	 mov	 QWORD PTR tv280[rsp], rax
$LN62@LCS_DoMult:
  00675	48 8b 84 24 c8
	00 00 00	 mov	 rax, QWORD PTR tv280[rsp]
  0067d	48 89 84 24 d0
	00 00 00	 mov	 QWORD PTR tv281[rsp], rax
$LN64@LCS_DoMult:
  00685	48 8b 84 24 d0
	00 00 00	 mov	 rax, QWORD PTR tv281[rsp]
  0068d	48 89 84 24 98
	00 00 00	 mov	 QWORD PTR what$[rsp], rax

; 2044 :              : (U32) SIOCDELMULTI == (U32) ioctlcode ? "SIOCDELMULTI" : "???";
; 2045 : 
; 2046 :         STRLCPY( ifr.ifr_name, pLCSPORT->szNetIfName );

  00695	48 8b 44 24 70	 mov	 rax, QWORD PTR pLCSPORT$[rsp]
  0069a	48 05 48 01 00
	00		 add	 rax, 328		; 00000148H
  006a0	41 b8 10 00 00
	00		 mov	 r8d, 16
  006a6	48 8b d0	 mov	 rdx, rax
  006a9	48 8d 8c 24 10
	01 00 00	 lea	 rcx, QWORD PTR ifr$[rsp]
  006b1	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_strlcpy

; 2047 : 
; 2048 : #if defined( SIOCGIFHWADDR )
; 2049 :         for (i=0, badrc=0; i < numpairs; i++)

  006b7	33 c0		 xor	 eax, eax
  006b9	66 89 44 24 60	 mov	 WORD PTR i$[rsp], ax
  006be	c7 44 24 6c 00
	00 00 00	 mov	 DWORD PTR badrc$[rsp], 0
  006c6	eb 0d		 jmp	 SHORT $LN22@LCS_DoMult
$LN20@LCS_DoMult:
  006c8	0f b7 44 24 60	 movzx	 eax, WORD PTR i$[rsp]
  006cd	66 ff c0	 inc	 ax
  006d0	66 89 44 24 60	 mov	 WORD PTR i$[rsp], ax
$LN22@LCS_DoMult:
  006d5	0f b7 44 24 60	 movzx	 eax, WORD PTR i$[rsp]
  006da	0f b7 4c 24 64	 movzx	 ecx, WORD PTR numpairs$[rsp]
  006df	3b c1		 cmp	 eax, ecx
  006e1	0f 8d b5 01 00
	00		 jge	 $LN21@LCS_DoMult

; 2050 :         {
; 2051 :             pMAC = &pIPMFrame->IP_MAC_Pair[i].MAC_Address;

  006e7	0f b7 44 24 60	 movzx	 eax, WORD PTR i$[rsp]
  006ec	48 6b c0 0c	 imul	 rax, rax, 12
  006f0	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR pIPMFrame$[rsp]
  006f8	48 8d 44 01 18	 lea	 rax, QWORD PTR [rcx+rax+24]
  006fd	48 89 84 24 90
	00 00 00	 mov	 QWORD PTR pMAC$[rsp], rax

; 2052 :             memcpy( ifr.ifr_hwaddr.sa_data, pMAC, sizeof( MAC ));

  00705	48 8d 84 24 22
	01 00 00	 lea	 rax, QWORD PTR ifr$[rsp+18]
  0070d	48 8b f8	 mov	 rdi, rax
  00710	48 8b b4 24 90
	00 00 00	 mov	 rsi, QWORD PTR pMAC$[rsp]
  00718	b9 06 00 00 00	 mov	 ecx, 6
  0071d	f3 a4		 rep movsb

; 2053 : 
; 2054 :             if ((rc = TUNTAP_IOCtl( 0, ioctlcode, (char*) &ifr )) == 0)

  0071f	4c 8d 84 24 10
	01 00 00	 lea	 r8, QWORD PTR ifr$[rsp]
  00727	8b 94 24 00 03
	00 00		 mov	 edx, DWORD PTR ioctlcode$[rsp]
  0072e	33 c9		 xor	 ecx, ecx
  00730	e8 00 00 00 00	 call	 tt32_ioctl
  00735	89 44 24 68	 mov	 DWORD PTR rc$[rsp], eax
  00739	83 7c 24 68 00	 cmp	 DWORD PTR rc$[rsp], 0
  0073e	0f 85 41 01 00
	00		 jne	 $LN49@LCS_DoMult

; 2055 :             {
; 2056 :                 if (pLCSDEV->pLCSBLK->fDebug)

  00744	48 8b 84 24 08
	03 00 00	 mov	 rax, QWORD PTR pLCSDEV$[rsp]
  0074c	48 8b 40 08	 mov	 rax, QWORD PTR [rax+8]
  00750	8b 40 18	 mov	 eax, DWORD PTR [rax+24]
  00753	83 e0 01	 and	 eax, 1
  00756	85 c0		 test	 eax, eax
  00758	0f 84 25 01 00
	00		 je	 $LN51@LCS_DoMult
$LN25@LCS_DoMult:

; 2057 :                 {
; 2058 :                     VERIFY( FormatMAC( &pszMAC, (BYTE*) pMAC ) == 0);

  0075e	48 8b 94 24 90
	00 00 00	 mov	 rdx, QWORD PTR pMAC$[rsp]
  00766	48 8d 8c 24 80
	00 00 00	 lea	 rcx, QWORD PTR pszMAC$[rsp]
  0076e	e8 00 00 00 00	 call	 FormatMAC
  00773	85 c0		 test	 eax, eax
  00775	74 5c		 je	 SHORT $LN52@LCS_DoMult
$LN28@LCS_DoMult:
  00777	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG171372
  0077e	41 b8 0a 08 00
	00		 mov	 r8d, 2058		; 0000080aH
  00784	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG171373
  0078b	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG171374
  00792	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_logmsg
  00798	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_IsDebuggerPresent
  0079e	85 c0		 test	 eax, eax
  007a0	74 20		 je	 SHORT $LN53@LCS_DoMult
  007a2	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG171376
  007a9	41 b8 0a 08 00
	00		 mov	 r8d, 2058		; 0000080aH
  007af	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG171377
  007b6	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG171378
  007bd	e8 00 00 00 00	 call	 DebuggerTrace
$LN53@LCS_DoMult:
  007c2	33 c0		 xor	 eax, eax
  007c4	85 c0		 test	 eax, eax
  007c6	75 af		 jne	 SHORT $LN28@LCS_DoMult
  007c8	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_IsDebuggerPresent
  007ce	85 c0		 test	 eax, eax
  007d0	74 01		 je	 SHORT $LN54@LCS_DoMult
  007d2	cc		 int	 3
$LN54@LCS_DoMult:
$LN52@LCS_DoMult:
  007d3	33 c0		 xor	 eax, eax
  007d5	85 c0		 test	 eax, eax
  007d7	75 85		 jne	 SHORT $LN25@LCS_DoMult

; 2059 :                     // "CTC: lcs device '%s' port %2.2X: %s %s: ok"
; 2060 :                     WRMSG( HHC00964, "D", pLCSPORT->szNetIfName, pLCSPORT->bPort,

  007d9	48 8b 44 24 70	 mov	 rax, QWORD PTR pLCSPORT$[rsp]
  007de	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  007e1	89 84 24 a8 00
	00 00		 mov	 DWORD PTR tv364[rsp], eax
  007e8	48 8b 4c 24 70	 mov	 rcx, QWORD PTR pLCSPORT$[rsp]
  007ed	48 81 c1 48 01
	00 00		 add	 rcx, 328		; 00000148H
  007f4	48 89 8c 24 f8
	00 00 00	 mov	 QWORD PTR tv366[rsp], rcx
  007fc	b9 01 00 00 00	 mov	 ecx, 1
  00801	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  00807	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR pszMAC$[rsp]
  0080f	48 89 4c 24 50	 mov	 QWORD PTR [rsp+80], rcx
  00814	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR what$[rsp]
  0081c	48 89 4c 24 48	 mov	 QWORD PTR [rsp+72], rcx
  00821	8b 8c 24 a8 00
	00 00		 mov	 ecx, DWORD PTR tv364[rsp]
  00828	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  0082c	48 8b 8c 24 f8
	00 00 00	 mov	 rcx, QWORD PTR tv366[rsp]
  00834	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  00839	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG171380
  00840	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  00845	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG171381
  0084c	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00851	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00856	41 b9 03 00 00
	00		 mov	 r9d, 3
  0085c	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG171382
  00863	ba 0d 08 00 00	 mov	 edx, 2061		; 0000080dH
  00868	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG171383
  0086f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 2061 :                         what, pszMAC );
; 2062 :                     free( pszMAC );

  00875	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR pszMAC$[rsp]
  0087d	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free
$LN51@LCS_DoMult:

; 2063 :                 }
; 2064 :             }

  00883	eb 12		 jmp	 SHORT $LN50@LCS_DoMult
$LN49@LCS_DoMult:

; 2065 :             else
; 2066 :             {
; 2067 :                 badrc = rc;

  00885	8b 44 24 68	 mov	 eax, DWORD PTR rc$[rsp]
  00889	89 44 24 6c	 mov	 DWORD PTR badrc$[rsp], eax

; 2068 :                 errnum = HSO_errno;

  0088d	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_WSAGetLastError
  00893	89 44 24 7c	 mov	 DWORD PTR errnum$[rsp], eax
$LN50@LCS_DoMult:

; 2069 :             }
; 2070 :         }

  00897	e9 2c fe ff ff	 jmp	 $LN20@LCS_DoMult
$LN21@LCS_DoMult:

; 2071 : 
; 2072 :         // Issue error message if any of the requests failed.
; 2073 : 
; 2074 :         if (badrc)

  0089c	83 7c 24 6c 00	 cmp	 DWORD PTR badrc$[rsp], 0
  008a1	0f 84 b1 00 00
	00		 je	 $LN55@LCS_DoMult

; 2075 :         {
; 2076 :             // "CTC: ioctl %s failed for device %s: %s"
; 2077 :             WRMSG( HHC00941, "E", what, pLCSPORT->szNetIfName, strerror( errnum ));

  008a7	8b 4c 24 7c	 mov	 ecx, DWORD PTR errnum$[rsp]
  008ab	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_strerror
  008b1	48 89 84 24 00
	01 00 00	 mov	 QWORD PTR tv380[rsp], rax
  008b9	48 8b 4c 24 70	 mov	 rcx, QWORD PTR pLCSPORT$[rsp]
  008be	48 81 c1 48 01
	00 00		 add	 rcx, 328		; 00000148H
  008c5	48 89 8c 24 08
	01 00 00	 mov	 QWORD PTR tv383[rsp], rcx
  008cd	b9 01 00 00 00	 mov	 ecx, 1
  008d2	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  008d8	48 8b 8c 24 00
	01 00 00	 mov	 rcx, QWORD PTR tv380[rsp]
  008e0	48 89 4c 24 48	 mov	 QWORD PTR [rsp+72], rcx
  008e5	48 8b 8c 24 08
	01 00 00	 mov	 rcx, QWORD PTR tv383[rsp]
  008ed	48 89 4c 24 40	 mov	 QWORD PTR [rsp+64], rcx
  008f2	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR what$[rsp]
  008fa	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  008ff	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG171385
  00906	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  0090b	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG171386
  00912	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00917	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  0091c	41 b9 03 00 00
	00		 mov	 r9d, 3
  00922	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG171387
  00929	ba 1d 08 00 00	 mov	 edx, 2077		; 0000081dH
  0092e	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG171388
  00935	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 2078 :             STORE_HW( pLCSIPMFRM->bLCSCmdHdr.hwReturnCode, 0xFFFF );

  0093b	66 b9 ff ff	 mov	 cx, 65535		; 0000ffffH
  0093f	e8 00 00 00 00	 call	 _byteswap_ushort
  00944	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR pLCSIPMFRM$[rsp]
  0094c	48 83 c1 08	 add	 rcx, 8
  00950	0f b7 d0	 movzx	 edx, ax
  00953	e8 00 00 00 00	 call	 store_hw_noswap
$LN55@LCS_DoMult:
$LN33@LCS_DoMult:

; 2079 :         }
; 2080 : #endif // defined( SIOCGIFHWADDR )
; 2081 :     }
; 2082 : 
; 2083 :     // Queue response back to caller
; 2084 : 
; 2085 :     LCS_EnqueueReplyFrame( pLCSDEV, (PLCSCMDHDR)pLCSIPMFRM, iReplyLen );

  00958	48 63 44 24 78	 movsxd	 rax, DWORD PTR iReplyLen$[rsp]
  0095d	4c 8b c0	 mov	 r8, rax
  00960	48 8b 94 24 88
	00 00 00	 mov	 rdx, QWORD PTR pLCSIPMFRM$[rsp]
  00968	48 8b 8c 24 08
	03 00 00	 mov	 rcx, QWORD PTR pLCSDEV$[rsp]
  00970	e8 00 00 00 00	 call	 LCS_EnqueueReplyFrame

; 2086 : }

  00975	48 8b 8c 24 d0
	02 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  0097d	48 33 cc	 xor	 rcx, rsp
  00980	e8 00 00 00 00	 call	 __security_check_cookie
  00985	48 81 c4 e8 02
	00 00		 add	 rsp, 744		; 000002e8H
  0098c	5f		 pop	 rdi
  0098d	5e		 pop	 rsi
  0098e	c3		 ret	 0
LCS_DoMulticast ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\ctc_lcs.c
_TEXT	SEGMENT
tv174 = 80
tv177 = 84
tv181 = 88
bStarted$ = 112
pDEVBLK$ = 120
pLCSPORT$ = 128
UpdatePortStarted PROC

; 1663 : {

  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	89 4c 24 08	 mov	 DWORD PTR [rsp+8], ecx
  0000e	48 83 ec 68	 sub	 rsp, 104		; 00000068H
$LN4@UpdatePort:

; 1664 :     PTT_DEBUG(        "GET  PortDataLock ", 000, pDEVBLK->devnum, pLCSPORT->bPort );

  00012	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_pttclass
  00019	48 8b 00	 mov	 rax, QWORD PTR [rax]
  0001c	48 25 00 00 02
	00		 and	 rax, 131072		; 00020000H
  00022	48 85 c0	 test	 rax, rax
  00025	74 46		 je	 SHORT $LN29@UpdatePort
  00027	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR pLCSPORT$[rsp]
  0002f	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  00032	48 8b 4c 24 78	 mov	 rcx, QWORD PTR pDEVBLK$[rsp]
  00037	0f b7 49 48	 movzx	 ecx, WORD PTR [rcx+72]
  0003b	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR [rsp+48], 0
  00044	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  00049	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG170994
  00050	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00055	44 8b c9	 mov	 r9d, ecx
  00058	45 33 c0	 xor	 r8d, r8d
  0005b	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG170995
  00062	b9 00 00 02 00	 mov	 ecx, 131072		; 00020000H
  00067	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ptt_pthread_trace
$LN29@UpdatePort:
  0006d	33 c0		 xor	 eax, eax
  0006f	85 c0		 test	 eax, eax
  00071	75 9f		 jne	 SHORT $LN4@UpdatePort

; 1665 :     obtain_lock( &pLCSPORT->PortDataLock );

  00073	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR pLCSPORT$[rsp]
  0007b	48 05 1c 01 00
	00		 add	 rax, 284		; 0000011cH
  00081	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG170996
  00088	48 8b c8	 mov	 rcx, rax
  0008b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_obtain_lock
$LN7@UpdatePort:

; 1666 :     PTT_DEBUG(        "GOT  PortDataLock ", 000, pDEVBLK->devnum, pLCSPORT->bPort );

  00091	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_pttclass
  00098	48 8b 00	 mov	 rax, QWORD PTR [rax]
  0009b	48 25 00 00 02
	00		 and	 rax, 131072		; 00020000H
  000a1	48 85 c0	 test	 rax, rax
  000a4	74 46		 je	 SHORT $LN30@UpdatePort
  000a6	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR pLCSPORT$[rsp]
  000ae	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  000b1	48 8b 4c 24 78	 mov	 rcx, QWORD PTR pDEVBLK$[rsp]
  000b6	0f b7 49 48	 movzx	 ecx, WORD PTR [rcx+72]
  000ba	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR [rsp+48], 0
  000c3	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  000c8	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG170998
  000cf	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  000d4	44 8b c9	 mov	 r9d, ecx
  000d7	45 33 c0	 xor	 r8d, r8d
  000da	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG170999
  000e1	b9 00 00 02 00	 mov	 ecx, 131072		; 00020000H
  000e6	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ptt_pthread_trace
$LN30@UpdatePort:
  000ec	33 c0		 xor	 eax, eax
  000ee	85 c0		 test	 eax, eax
  000f0	75 9f		 jne	 SHORT $LN7@UpdatePort
$LN10@UpdatePort:

; 1667 :     {
; 1668 :         // The following will either caise the LCS_PortThread to start
; 1669 :         // reading packets or stop reading packets (fPortStarted = 1/0)
; 1670 : 
; 1671 :         PTT_DEBUG( "UPDTPORTSTARTED   ", bStarted, pDEVBLK->devnum, pLCSPORT->bPort );

  000f2	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_pttclass
  000f9	48 8b 00	 mov	 rax, QWORD PTR [rax]
  000fc	48 25 00 00 02
	00		 and	 rax, 131072		; 00020000H
  00102	48 85 c0	 test	 rax, rax
  00105	74 4b		 je	 SHORT $LN31@UpdatePort
  00107	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR pLCSPORT$[rsp]
  0010f	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  00112	48 8b 4c 24 78	 mov	 rcx, QWORD PTR pDEVBLK$[rsp]
  00117	0f b7 49 48	 movzx	 ecx, WORD PTR [rcx+72]
  0011b	48 63 54 24 70	 movsxd	 rdx, DWORD PTR bStarted$[rsp]
  00120	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR [rsp+48], 0
  00129	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  0012e	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG171001
  00135	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  0013a	44 8b c9	 mov	 r9d, ecx
  0013d	4c 8b c2	 mov	 r8, rdx
  00140	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG171002
  00147	b9 00 00 02 00	 mov	 ecx, 131072		; 00020000H
  0014c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ptt_pthread_trace
$LN31@UpdatePort:
  00152	33 c0		 xor	 eax, eax
  00154	85 c0		 test	 eax, eax
  00156	75 9a		 jne	 SHORT $LN10@UpdatePort

; 1672 :         pLCSPORT->fPortStarted = bStarted;

  00158	8b 44 24 70	 mov	 eax, DWORD PTR bStarted$[rsp]
  0015c	83 e0 01	 and	 eax, 1
  0015f	c1 e0 03	 shl	 eax, 3
  00162	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR pLCSPORT$[rsp]
  0016a	8b 89 34 01 00
	00		 mov	 ecx, DWORD PTR [rcx+308]
  00170	83 e1 f7	 and	 ecx, -9			; fffffff7H
  00173	0b c8		 or	 ecx, eax
  00175	8b c1		 mov	 eax, ecx
  00177	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR pLCSPORT$[rsp]
  0017f	89 81 34 01 00
	00		 mov	 DWORD PTR [rcx+308], eax
$LN13@UpdatePort:

; 1673 :     }
; 1674 :     PTT_DEBUG(         "REL  PortDataLock ", 000, pDEVBLK->devnum, pLCSPORT->bPort );

  00185	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_pttclass
  0018c	48 8b 00	 mov	 rax, QWORD PTR [rax]
  0018f	48 25 00 00 02
	00		 and	 rax, 131072		; 00020000H
  00195	48 85 c0	 test	 rax, rax
  00198	74 46		 je	 SHORT $LN32@UpdatePort
  0019a	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR pLCSPORT$[rsp]
  001a2	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  001a5	48 8b 4c 24 78	 mov	 rcx, QWORD PTR pDEVBLK$[rsp]
  001aa	0f b7 49 48	 movzx	 ecx, WORD PTR [rcx+72]
  001ae	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR [rsp+48], 0
  001b7	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  001bc	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG171004
  001c3	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  001c8	44 8b c9	 mov	 r9d, ecx
  001cb	45 33 c0	 xor	 r8d, r8d
  001ce	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG171005
  001d5	b9 00 00 02 00	 mov	 ecx, 131072		; 00020000H
  001da	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ptt_pthread_trace
$LN32@UpdatePort:
  001e0	33 c0		 xor	 eax, eax
  001e2	85 c0		 test	 eax, eax
  001e4	75 9f		 jne	 SHORT $LN13@UpdatePort

; 1675 :     release_lock( &pLCSPORT->PortDataLock );

  001e6	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR pLCSPORT$[rsp]
  001ee	48 05 1c 01 00
	00		 add	 rax, 284		; 0000011cH
  001f4	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG171006
  001fb	48 8b c8	 mov	 rcx, rax
  001fe	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_release_lock

; 1676 : 
; 1677 :     if (pDEVBLK->ccwtrace || pLCSPORT->pLCSBLK->fDebug)

  00204	48 8b 44 24 78	 mov	 rax, QWORD PTR pDEVBLK$[rsp]
  00209	8b 80 f8 05 00
	00		 mov	 eax, DWORD PTR [rax+1528]
  0020f	c1 e8 0f	 shr	 eax, 15
  00212	83 e0 01	 and	 eax, 1
  00215	85 c0		 test	 eax, eax
  00217	75 1a		 jne	 SHORT $LN34@UpdatePort
  00219	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR pLCSPORT$[rsp]
  00221	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  00225	8b 40 18	 mov	 eax, DWORD PTR [rax+24]
  00228	83 e0 01	 and	 eax, 1
  0022b	85 c0		 test	 eax, eax
  0022d	0f 84 8a 00 00
	00		 je	 $LN33@UpdatePort
$LN34@UpdatePort:

; 1678 :         // "%1d:%04X CTC: lcs triggering port %2.2X event"
; 1679 :         WRMSG( HHC00966, "I", SSID_TO_LCSS( pDEVBLK->ssid ), pDEVBLK->devnum, pLCSPORT->bPort );

  00233	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR pLCSPORT$[rsp]
  0023b	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  0023e	89 44 24 50	 mov	 DWORD PTR tv174[rsp], eax
  00242	48 8b 4c 24 78	 mov	 rcx, QWORD PTR pDEVBLK$[rsp]
  00247	0f b7 49 48	 movzx	 ecx, WORD PTR [rcx+72]
  0024b	89 4c 24 54	 mov	 DWORD PTR tv177[rsp], ecx
  0024f	48 8b 54 24 78	 mov	 rdx, QWORD PTR pDEVBLK$[rsp]
  00254	0f b7 52 44	 movzx	 edx, WORD PTR [rdx+68]
  00258	d1 fa		 sar	 edx, 1
  0025a	89 54 24 58	 mov	 DWORD PTR tv181[rsp], edx
  0025e	b9 01 00 00 00	 mov	 ecx, 1
  00263	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  00269	8b 4c 24 50	 mov	 ecx, DWORD PTR tv174[rsp]
  0026d	89 4c 24 48	 mov	 DWORD PTR [rsp+72], ecx
  00271	8b 4c 24 54	 mov	 ecx, DWORD PTR tv177[rsp]
  00275	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  00279	8b 4c 24 58	 mov	 ecx, DWORD PTR tv181[rsp]
  0027d	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  00281	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG171009
  00288	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  0028d	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG171010
  00294	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00299	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  0029e	41 b9 03 00 00
	00		 mov	 r9d, 3
  002a4	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG171011
  002ab	ba 8f 06 00 00	 mov	 edx, 1679		; 0000068fH
  002b0	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG171012
  002b7	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg
$LN33@UpdatePort:
$LN16@UpdatePort:

; 1680 : 
; 1681 :     PTT_DEBUG(        "GET  PortEventLock", 000, pDEVBLK->devnum, pLCSPORT->bPort );

  002bd	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_pttclass
  002c4	48 8b 00	 mov	 rax, QWORD PTR [rax]
  002c7	48 25 00 00 02
	00		 and	 rax, 131072		; 00020000H
  002cd	48 85 c0	 test	 rax, rax
  002d0	74 46		 je	 SHORT $LN35@UpdatePort
  002d2	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR pLCSPORT$[rsp]
  002da	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  002dd	48 8b 4c 24 78	 mov	 rcx, QWORD PTR pDEVBLK$[rsp]
  002e2	0f b7 49 48	 movzx	 ecx, WORD PTR [rcx+72]
  002e6	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR [rsp+48], 0
  002ef	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  002f4	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG171014
  002fb	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00300	44 8b c9	 mov	 r9d, ecx
  00303	45 33 c0	 xor	 r8d, r8d
  00306	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG171015
  0030d	b9 00 00 02 00	 mov	 ecx, 131072		; 00020000H
  00312	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ptt_pthread_trace
$LN35@UpdatePort:
  00318	33 c0		 xor	 eax, eax
  0031a	85 c0		 test	 eax, eax
  0031c	75 9f		 jne	 SHORT $LN16@UpdatePort

; 1682 :     obtain_lock( &pLCSPORT->PortEventLock );

  0031e	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR pLCSPORT$[rsp]
  00326	48 05 24 01 00
	00		 add	 rax, 292		; 00000124H
  0032c	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG171016
  00333	48 8b c8	 mov	 rcx, rax
  00336	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_obtain_lock
$LN19@UpdatePort:

; 1683 :     PTT_DEBUG(        "GOT  PortEventLock", 000, pDEVBLK->devnum, pLCSPORT->bPort );

  0033c	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_pttclass
  00343	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00346	48 25 00 00 02
	00		 and	 rax, 131072		; 00020000H
  0034c	48 85 c0	 test	 rax, rax
  0034f	74 46		 je	 SHORT $LN36@UpdatePort
  00351	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR pLCSPORT$[rsp]
  00359	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  0035c	48 8b 4c 24 78	 mov	 rcx, QWORD PTR pDEVBLK$[rsp]
  00361	0f b7 49 48	 movzx	 ecx, WORD PTR [rcx+72]
  00365	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR [rsp+48], 0
  0036e	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  00373	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG171018
  0037a	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  0037f	44 8b c9	 mov	 r9d, ecx
  00382	45 33 c0	 xor	 r8d, r8d
  00385	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG171019
  0038c	b9 00 00 02 00	 mov	 ecx, 131072		; 00020000H
  00391	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ptt_pthread_trace
$LN36@UpdatePort:
  00397	33 c0		 xor	 eax, eax
  00399	85 c0		 test	 eax, eax
  0039b	75 9f		 jne	 SHORT $LN19@UpdatePort
$LN22@UpdatePort:

; 1684 :     {
; 1685 :         // Wake up the LCS_PortThread...
; 1686 : 
; 1687 :         PTT_DEBUG(             "SIG  PortEvent    ", 000, pDEVBLK->devnum, pLCSPORT->bPort );

  0039d	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_pttclass
  003a4	48 8b 00	 mov	 rax, QWORD PTR [rax]
  003a7	48 25 00 00 02
	00		 and	 rax, 131072		; 00020000H
  003ad	48 85 c0	 test	 rax, rax
  003b0	74 46		 je	 SHORT $LN37@UpdatePort
  003b2	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR pLCSPORT$[rsp]
  003ba	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  003bd	48 8b 4c 24 78	 mov	 rcx, QWORD PTR pDEVBLK$[rsp]
  003c2	0f b7 49 48	 movzx	 ecx, WORD PTR [rcx+72]
  003c6	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR [rsp+48], 0
  003cf	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  003d4	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG171021
  003db	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  003e0	44 8b c9	 mov	 r9d, ecx
  003e3	45 33 c0	 xor	 r8d, r8d
  003e6	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG171022
  003ed	b9 00 00 02 00	 mov	 ecx, 131072		; 00020000H
  003f2	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ptt_pthread_trace
$LN37@UpdatePort:
  003f8	33 c0		 xor	 eax, eax
  003fa	85 c0		 test	 eax, eax
  003fc	75 9f		 jne	 SHORT $LN22@UpdatePort

; 1688 :         signal_condition( &pLCSPORT->PortEvent );

  003fe	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR pLCSPORT$[rsp]
  00406	48 05 2c 01 00
	00		 add	 rax, 300		; 0000012cH
  0040c	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG171023
  00413	48 8b c8	 mov	 rcx, rax
  00416	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_signal_condition
$LN25@UpdatePort:

; 1689 :     }
; 1690 :     PTT_DEBUG(         "REL  PortEventLock", 000, pDEVBLK->devnum, pLCSPORT->bPort );

  0041c	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_pttclass
  00423	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00426	48 25 00 00 02
	00		 and	 rax, 131072		; 00020000H
  0042c	48 85 c0	 test	 rax, rax
  0042f	74 46		 je	 SHORT $LN38@UpdatePort
  00431	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR pLCSPORT$[rsp]
  00439	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  0043c	48 8b 4c 24 78	 mov	 rcx, QWORD PTR pDEVBLK$[rsp]
  00441	0f b7 49 48	 movzx	 ecx, WORD PTR [rcx+72]
  00445	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR [rsp+48], 0
  0044e	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  00453	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG171025
  0045a	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  0045f	44 8b c9	 mov	 r9d, ecx
  00462	45 33 c0	 xor	 r8d, r8d
  00465	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG171026
  0046c	b9 00 00 02 00	 mov	 ecx, 131072		; 00020000H
  00471	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ptt_pthread_trace
$LN38@UpdatePort:
  00477	33 c0		 xor	 eax, eax
  00479	85 c0		 test	 eax, eax
  0047b	75 9f		 jne	 SHORT $LN25@UpdatePort

; 1691 :     release_lock( &pLCSPORT->PortEventLock );

  0047d	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR pLCSPORT$[rsp]
  00485	48 05 24 01 00
	00		 add	 rax, 292		; 00000124H
  0048b	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG171027
  00492	48 8b c8	 mov	 rcx, rax
  00495	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_release_lock
$LN28@UpdatePort:

; 1692 : 
; 1693 :     PTT_DEBUG( "UPDTPORT pause 150", 000, pDEVBLK->devnum, pLCSPORT->bPort );

  0049b	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_pttclass
  004a2	48 8b 00	 mov	 rax, QWORD PTR [rax]
  004a5	48 25 00 00 02
	00		 and	 rax, 131072		; 00020000H
  004ab	48 85 c0	 test	 rax, rax
  004ae	74 46		 je	 SHORT $LN39@UpdatePort
  004b0	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR pLCSPORT$[rsp]
  004b8	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  004bb	48 8b 4c 24 78	 mov	 rcx, QWORD PTR pDEVBLK$[rsp]
  004c0	0f b7 49 48	 movzx	 ecx, WORD PTR [rcx+72]
  004c4	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR [rsp+48], 0
  004cd	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  004d2	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG171029
  004d9	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  004de	44 8b c9	 mov	 r9d, ecx
  004e1	45 33 c0	 xor	 r8d, r8d
  004e4	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG171030
  004eb	b9 00 00 02 00	 mov	 ecx, 131072		; 00020000H
  004f0	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ptt_pthread_trace
$LN39@UpdatePort:
  004f6	33 c0		 xor	 eax, eax
  004f8	85 c0		 test	 eax, eax
  004fa	75 9f		 jne	 SHORT $LN28@UpdatePort

; 1694 :     usleep( 150*1000 );

  004fc	b9 f0 49 02 00	 mov	 ecx, 150000		; 000249f0H
  00501	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_usleep

; 1695 : }

  00507	48 83 c4 68	 add	 rsp, 104		; 00000068H
  0050b	c3		 ret	 0
UpdatePortStarted ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\ctc_lcs.c
_TEXT	SEGMENT
pDEVBLK$ = 80
nEthBytes$ = 88
nEthFrames$ = 96
LCS_EndMWrite PROC

; 1235 : {

  00000	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  00005	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00009	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000e	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 1236 :     if (((PLCSDEV)pDEVBLK->dev_data)->pLCSBLK->fNoMultiWrite) return;

  00012	48 8b 44 24 50	 mov	 rax, QWORD PTR pDEVBLK$[rsp]
  00017	48 8b 80 08 06
	00 00		 mov	 rax, QWORD PTR [rax+1544]
  0001e	48 8b 40 08	 mov	 rax, QWORD PTR [rax+8]
  00022	8b 40 18	 mov	 eax, DWORD PTR [rax+24]
  00025	c1 e8 02	 shr	 eax, 2
  00028	83 e0 01	 and	 eax, 1
  0002b	85 c0		 test	 eax, eax
  0002d	74 05		 je	 SHORT $LN8@LCS_EndMWr
  0002f	e9 be 00 00 00	 jmp	 $LN1@LCS_EndMWr
$LN8@LCS_EndMWr:
$LN4@LCS_EndMWr:

; 1237 :     PTT_TIMING( "b4 endmw", 0, nEthBytes, nEthFrames );

  00034	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_pttclass
  0003b	48 8b 00	 mov	 rax, QWORD PTR [rax]
  0003e	48 25 00 00 01
	00		 and	 rax, 65536		; 00010000H
  00044	48 85 c0	 test	 rax, rax
  00047	74 3c		 je	 SHORT $LN9@LCS_EndMWr
  00049	48 63 44 24 60	 movsxd	 rax, DWORD PTR nEthFrames$[rsp]
  0004e	48 63 4c 24 58	 movsxd	 rcx, DWORD PTR nEthBytes$[rsp]
  00053	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR [rsp+48], 0
  0005c	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  00061	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG170353
  00068	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  0006d	4c 8b c9	 mov	 r9, rcx
  00070	45 33 c0	 xor	 r8d, r8d
  00073	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG170354
  0007a	b9 00 00 01 00	 mov	 ecx, 65536		; 00010000H
  0007f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ptt_pthread_trace
$LN9@LCS_EndMWr:
  00085	33 c0		 xor	 eax, eax
  00087	85 c0		 test	 eax, eax
  00089	75 a9		 jne	 SHORT $LN4@LCS_EndMWr

; 1238 :     TUNTAP_EndMWrite( pDEVBLK->fd );

  0008b	48 8b 44 24 50	 mov	 rax, QWORD PTR pDEVBLK$[rsp]
  00090	8b 88 ac 01 00
	00		 mov	 ecx, DWORD PTR [rax+428]
  00096	e8 00 00 00 00	 call	 tt32_end_write_multi
$LN7@LCS_EndMWr:

; 1239 :     PTT_TIMING( "af endmw", 0, nEthBytes, nEthFrames );

  0009b	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_pttclass
  000a2	48 8b 00	 mov	 rax, QWORD PTR [rax]
  000a5	48 25 00 00 01
	00		 and	 rax, 65536		; 00010000H
  000ab	48 85 c0	 test	 rax, rax
  000ae	74 3c		 je	 SHORT $LN10@LCS_EndMWr
  000b0	48 63 44 24 60	 movsxd	 rax, DWORD PTR nEthFrames$[rsp]
  000b5	48 63 4c 24 58	 movsxd	 rcx, DWORD PTR nEthBytes$[rsp]
  000ba	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR [rsp+48], 0
  000c3	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  000c8	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG170356
  000cf	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  000d4	4c 8b c9	 mov	 r9, rcx
  000d7	45 33 c0	 xor	 r8d, r8d
  000da	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG170357
  000e1	b9 00 00 01 00	 mov	 ecx, 65536		; 00010000H
  000e6	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ptt_pthread_trace
$LN10@LCS_EndMWr:
  000ec	33 c0		 xor	 eax, eax
  000ee	85 c0		 test	 eax, eax
  000f0	75 a9		 jne	 SHORT $LN7@LCS_EndMWr
$LN1@LCS_EndMWr:

; 1240 : }

  000f2	48 83 c4 48	 add	 rsp, 72			; 00000048H
  000f6	c3		 ret	 0
LCS_EndMWrite ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\ctc_lcs.c
_TEXT	SEGMENT
pDEVBLK$ = 80
LCS_BegMWrite PROC

; 1227 : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 1228 :     if (((PLCSDEV)pDEVBLK->dev_data)->pLCSBLK->fNoMultiWrite) return;

  00009	48 8b 44 24 50	 mov	 rax, QWORD PTR pDEVBLK$[rsp]
  0000e	48 8b 80 08 06
	00 00		 mov	 rax, QWORD PTR [rax+1544]
  00015	48 8b 40 08	 mov	 rax, QWORD PTR [rax+8]
  00019	8b 40 18	 mov	 eax, DWORD PTR [rax+24]
  0001c	c1 e8 02	 shr	 eax, 2
  0001f	83 e0 01	 and	 eax, 1
  00022	85 c0		 test	 eax, eax
  00024	74 05		 je	 SHORT $LN8@LCS_BegMWr
  00026	e9 b7 00 00 00	 jmp	 $LN1@LCS_BegMWr
$LN8@LCS_BegMWr:
$LN4@LCS_BegMWr:

; 1229 :     PTT_TIMING( "b4 begmw", 0, 0, 0 );

  0002b	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_pttclass
  00032	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00035	48 25 00 00 01
	00		 and	 rax, 65536		; 00010000H
  0003b	48 85 c0	 test	 rax, rax
  0003e	74 36		 je	 SHORT $LN9@LCS_BegMWr
  00040	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR [rsp+48], 0
  00049	48 c7 44 24 28
	00 00 00 00	 mov	 QWORD PTR [rsp+40], 0
  00052	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG170319
  00059	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  0005e	45 33 c9	 xor	 r9d, r9d
  00061	45 33 c0	 xor	 r8d, r8d
  00064	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG170320
  0006b	b9 00 00 01 00	 mov	 ecx, 65536		; 00010000H
  00070	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ptt_pthread_trace
$LN9@LCS_BegMWr:
  00076	33 c0		 xor	 eax, eax
  00078	85 c0		 test	 eax, eax
  0007a	75 af		 jne	 SHORT $LN4@LCS_BegMWr

; 1230 :     TUNTAP_BegMWrite( pDEVBLK->fd, CTC_DEF_FRAME_BUFFER_SIZE );

  0007c	ba 00 50 00 00	 mov	 edx, 20480		; 00005000H
  00081	48 8b 44 24 50	 mov	 rax, QWORD PTR pDEVBLK$[rsp]
  00086	8b 88 ac 01 00
	00		 mov	 ecx, DWORD PTR [rax+428]
  0008c	e8 00 00 00 00	 call	 tt32_beg_write_multi
$LN7@LCS_BegMWr:

; 1231 :     PTT_TIMING( "af begmw", 0, 0, 0);

  00091	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_pttclass
  00098	48 8b 00	 mov	 rax, QWORD PTR [rax]
  0009b	48 25 00 00 01
	00		 and	 rax, 65536		; 00010000H
  000a1	48 85 c0	 test	 rax, rax
  000a4	74 36		 je	 SHORT $LN10@LCS_BegMWr
  000a6	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR [rsp+48], 0
  000af	48 c7 44 24 28
	00 00 00 00	 mov	 QWORD PTR [rsp+40], 0
  000b8	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG170322
  000bf	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  000c4	45 33 c9	 xor	 r9d, r9d
  000c7	45 33 c0	 xor	 r8d, r8d
  000ca	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG170323
  000d1	b9 00 00 01 00	 mov	 ecx, 65536		; 00010000H
  000d6	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ptt_pthread_trace
$LN10@LCS_BegMWr:
  000dc	33 c0		 xor	 eax, eax
  000de	85 c0		 test	 eax, eax
  000e0	75 af		 jne	 SHORT $LN7@LCS_BegMWr
$LN1@LCS_BegMWr:

; 1232 : }

  000e2	48 83 c4 48	 add	 rsp, 72			; 00000048H
  000e6	c3		 ret	 0
LCS_BegMWrite ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\ctc_lcs.c
_TEXT	SEGMENT
pLCSDEV$ = 64
pLCSBLK$ = 72
pLCSATTN$ = 80
pDEVBLK$ = 112
LCS_EndChannelProgram PROC

; 969  : {

$LN39:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 68	 sub	 rsp, 104		; 00000068H

; 970  :     PLCSDEV     pLCSDEV;
; 971  :     PLCSBLK     pLCSBLK;
; 972  :     PLCSATTN    pLCSATTN;
; 973  : 
; 974  : 
; 975  :     pLCSDEV = (PLCSDEV)pDEVBLK->dev_data;

  00009	48 8b 44 24 70	 mov	 rax, QWORD PTR pDEVBLK$[rsp]
  0000e	48 8b 80 08 06
	00 00		 mov	 rax, QWORD PTR [rax+1544]
  00015	48 89 44 24 40	 mov	 QWORD PTR pLCSDEV$[rsp], rax

; 976  :     if (!pLCSDEV) return;  // (incomplete group?)

  0001a	48 83 7c 24 40
	00		 cmp	 QWORD PTR pLCSDEV$[rsp], 0
  00020	75 05		 jne	 SHORT $LN26@LCS_EndCha
  00022	e9 09 04 00 00	 jmp	 $LN1@LCS_EndCha
$LN26@LCS_EndCha:

; 977  : 
; 978  :     if (pLCSDEV->bMode == LCSDEV_MODE_SNA)

  00027	48 8b 44 24 40	 mov	 rax, QWORD PTR pLCSDEV$[rsp]
  0002c	0f b6 40 22	 movzx	 eax, BYTE PTR [rax+34]
  00030	83 f8 02	 cmp	 eax, 2
  00033	0f 85 f7 03 00
	00		 jne	 $LN27@LCS_EndCha

; 979  :     {
; 980  : 
; 981  :         if (pLCSDEV->fAttnRequired)

  00039	48 8b 44 24 40	 mov	 rax, QWORD PTR pLCSDEV$[rsp]
  0003e	8b 40 5d	 mov	 eax, DWORD PTR [rax+93]
  00041	d1 e8		 shr	 eax, 1
  00043	83 e0 01	 and	 eax, 1
  00046	85 c0		 test	 eax, eax
  00048	0f 84 c6 03 00
	00		 je	 $LN28@LCS_EndCha

; 982  :         {
; 983  :             // It would have been nice to have simply called function
; 984  :             // device_attention at this point, but the channel program
; 985  :             // is still considered to be busy, and a return code of one
; 986  :             // would be returned to us.
; 987  : 
; 988  :             pLCSBLK = pLCSDEV->pLCSBLK;

  0004e	48 8b 44 24 40	 mov	 rax, QWORD PTR pLCSDEV$[rsp]
  00053	48 8b 40 08	 mov	 rax, QWORD PTR [rax+8]
  00057	48 89 44 24 48	 mov	 QWORD PTR pLCSBLK$[rsp], rax

; 989  : 
; 990  :             /* Create an LCSATTN block */
; 991  :             pLCSATTN = malloc( sizeof( LCSATTN ) );

  0005c	b9 10 00 00 00	 mov	 ecx, 16
  00061	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_malloc
  00067	48 89 44 24 50	 mov	 QWORD PTR pLCSATTN$[rsp], rax

; 992  :             if (!pLCSATTN) return;  /* FixMe! Produce a message? */

  0006c	48 83 7c 24 50
	00		 cmp	 QWORD PTR pLCSATTN$[rsp], 0
  00072	75 05		 jne	 SHORT $LN29@LCS_EndCha
  00074	e9 b7 03 00 00	 jmp	 $LN1@LCS_EndCha
$LN29@LCS_EndCha:

; 993  :             pLCSATTN->pNext = NULL;

  00079	48 8b 44 24 50	 mov	 rax, QWORD PTR pLCSATTN$[rsp]
  0007e	48 c7 00 00 00
	00 00		 mov	 QWORD PTR [rax], 0

; 994  :             pLCSATTN->pDevice = pLCSDEV;

  00085	48 8b 44 24 50	 mov	 rax, QWORD PTR pLCSATTN$[rsp]
  0008a	48 8b 4c 24 40	 mov	 rcx, QWORD PTR pLCSDEV$[rsp]
  0008f	48 89 48 08	 mov	 QWORD PTR [rax+8], rcx
$LN4@LCS_EndCha:

; 995  : 
; 996  : //          if (pLCSBLK->fDebug)                                                                         /* FixMe! Remove! */
; 997  : //            net_data_trace( pDEVBLK, (BYTE*)pLCSATTN, sizeof( LCSATTN ), NO_DIRECTION, 'D', "LCSATTN in", 0 );  /* FixMe! Remove! */
; 998  : 
; 999  :             /* Add LCSATTN block to start of chain */
; 1000 :             PTT_DEBUG( "GET  AttnLock", 000, pDEVBLK->devnum, 000 );

  00093	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_pttclass
  0009a	48 8b 00	 mov	 rax, QWORD PTR [rax]
  0009d	48 25 00 00 02
	00		 and	 rax, 131072		; 00020000H
  000a3	48 85 c0	 test	 rax, rax
  000a6	74 3f		 je	 SHORT $LN30@LCS_EndCha
  000a8	48 8b 44 24 70	 mov	 rax, QWORD PTR pDEVBLK$[rsp]
  000ad	0f b7 40 48	 movzx	 eax, WORD PTR [rax+72]
  000b1	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR [rsp+48], 0
  000ba	48 c7 44 24 28
	00 00 00 00	 mov	 QWORD PTR [rsp+40], 0
  000c3	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169891
  000ca	48 89 4c 24 20	 mov	 QWORD PTR [rsp+32], rcx
  000cf	44 8b c8	 mov	 r9d, eax
  000d2	45 33 c0	 xor	 r8d, r8d
  000d5	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG169892
  000dc	b9 00 00 02 00	 mov	 ecx, 131072		; 00020000H
  000e1	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ptt_pthread_trace
$LN30@LCS_EndCha:
  000e7	33 c0		 xor	 eax, eax
  000e9	85 c0		 test	 eax, eax
  000eb	75 a6		 jne	 SHORT $LN4@LCS_EndCha

; 1001 :             obtain_lock( &pLCSBLK->AttnLock );

  000ed	48 8b 44 24 48	 mov	 rax, QWORD PTR pLCSBLK$[rsp]
  000f2	48 83 c0 30	 add	 rax, 48			; 00000030H
  000f6	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG169893
  000fd	48 8b c8	 mov	 rcx, rax
  00100	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_obtain_lock
$LN7@LCS_EndCha:

; 1002 :             PTT_DEBUG( "GOT  AttnLock", 000, pDEVBLK->devnum, 000 );

  00106	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_pttclass
  0010d	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00110	48 25 00 00 02
	00		 and	 rax, 131072		; 00020000H
  00116	48 85 c0	 test	 rax, rax
  00119	74 3f		 je	 SHORT $LN31@LCS_EndCha
  0011b	48 8b 44 24 70	 mov	 rax, QWORD PTR pDEVBLK$[rsp]
  00120	0f b7 40 48	 movzx	 eax, WORD PTR [rax+72]
  00124	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR [rsp+48], 0
  0012d	48 c7 44 24 28
	00 00 00 00	 mov	 QWORD PTR [rsp+40], 0
  00136	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169895
  0013d	48 89 4c 24 20	 mov	 QWORD PTR [rsp+32], rcx
  00142	44 8b c8	 mov	 r9d, eax
  00145	45 33 c0	 xor	 r8d, r8d
  00148	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG169896
  0014f	b9 00 00 02 00	 mov	 ecx, 131072		; 00020000H
  00154	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ptt_pthread_trace
$LN31@LCS_EndCha:
  0015a	33 c0		 xor	 eax, eax
  0015c	85 c0		 test	 eax, eax
  0015e	75 a6		 jne	 SHORT $LN7@LCS_EndCha
$LN10@LCS_EndCha:

; 1003 :             {
; 1004 :                 PTT_DEBUG( "ADD  Attn", pLCSATTN, pDEVBLK->devnum, 000 );

  00160	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_pttclass
  00167	48 8b 00	 mov	 rax, QWORD PTR [rax]
  0016a	48 25 00 00 02
	00		 and	 rax, 131072		; 00020000H
  00170	48 85 c0	 test	 rax, rax
  00173	74 41		 je	 SHORT $LN32@LCS_EndCha
  00175	48 8b 44 24 70	 mov	 rax, QWORD PTR pDEVBLK$[rsp]
  0017a	0f b7 40 48	 movzx	 eax, WORD PTR [rax+72]
  0017e	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR [rsp+48], 0
  00187	48 c7 44 24 28
	00 00 00 00	 mov	 QWORD PTR [rsp+40], 0
  00190	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169898
  00197	48 89 4c 24 20	 mov	 QWORD PTR [rsp+32], rcx
  0019c	44 8b c8	 mov	 r9d, eax
  0019f	4c 8b 44 24 50	 mov	 r8, QWORD PTR pLCSATTN$[rsp]
  001a4	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG169899
  001ab	b9 00 00 02 00	 mov	 ecx, 131072		; 00020000H
  001b0	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ptt_pthread_trace
$LN32@LCS_EndCha:
  001b6	33 c0		 xor	 eax, eax
  001b8	85 c0		 test	 eax, eax
  001ba	75 a4		 jne	 SHORT $LN10@LCS_EndCha

; 1005 :                 pLCSATTN->pNext = pLCSBLK->pAttns;

  001bc	48 8b 44 24 50	 mov	 rax, QWORD PTR pLCSATTN$[rsp]
  001c1	48 8b 4c 24 48	 mov	 rcx, QWORD PTR pLCSBLK$[rsp]
  001c6	48 8b 49 38	 mov	 rcx, QWORD PTR [rcx+56]
  001ca	48 89 08	 mov	 QWORD PTR [rax], rcx

; 1006 :                 pLCSBLK->pAttns = pLCSATTN;

  001cd	48 8b 44 24 48	 mov	 rax, QWORD PTR pLCSBLK$[rsp]
  001d2	48 8b 4c 24 50	 mov	 rcx, QWORD PTR pLCSATTN$[rsp]
  001d7	48 89 48 38	 mov	 QWORD PTR [rax+56], rcx
$LN13@LCS_EndCha:

; 1007 :             }
; 1008 :             PTT_DEBUG( "REL  AttnLock", 000, pDEVBLK->devnum, 000 );

  001db	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_pttclass
  001e2	48 8b 00	 mov	 rax, QWORD PTR [rax]
  001e5	48 25 00 00 02
	00		 and	 rax, 131072		; 00020000H
  001eb	48 85 c0	 test	 rax, rax
  001ee	74 3f		 je	 SHORT $LN33@LCS_EndCha
  001f0	48 8b 44 24 70	 mov	 rax, QWORD PTR pDEVBLK$[rsp]
  001f5	0f b7 40 48	 movzx	 eax, WORD PTR [rax+72]
  001f9	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR [rsp+48], 0
  00202	48 c7 44 24 28
	00 00 00 00	 mov	 QWORD PTR [rsp+40], 0
  0020b	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169901
  00212	48 89 4c 24 20	 mov	 QWORD PTR [rsp+32], rcx
  00217	44 8b c8	 mov	 r9d, eax
  0021a	45 33 c0	 xor	 r8d, r8d
  0021d	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG169902
  00224	b9 00 00 02 00	 mov	 ecx, 131072		; 00020000H
  00229	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ptt_pthread_trace
$LN33@LCS_EndCha:
  0022f	33 c0		 xor	 eax, eax
  00231	85 c0		 test	 eax, eax
  00233	75 a6		 jne	 SHORT $LN13@LCS_EndCha

; 1009 :             release_lock( &pLCSBLK->AttnLock );

  00235	48 8b 44 24 48	 mov	 rax, QWORD PTR pLCSBLK$[rsp]
  0023a	48 83 c0 30	 add	 rax, 48			; 00000030H
  0023e	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG169903
  00245	48 8b c8	 mov	 rcx, rax
  00248	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_release_lock
$LN16@LCS_EndCha:

; 1010 : 
; 1011 :             /* Signal the LCS_AttnThread to process the LCSATTN block(s) on the chain */
; 1012 :             PTT_DEBUG( "GET  AttnEventLock ", 000, pDEVBLK->devnum, 000 );

  0024e	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_pttclass
  00255	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00258	48 25 00 00 02
	00		 and	 rax, 131072		; 00020000H
  0025e	48 85 c0	 test	 rax, rax
  00261	74 3f		 je	 SHORT $LN34@LCS_EndCha
  00263	48 8b 44 24 70	 mov	 rax, QWORD PTR pDEVBLK$[rsp]
  00268	0f b7 40 48	 movzx	 eax, WORD PTR [rax+72]
  0026c	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR [rsp+48], 0
  00275	48 c7 44 24 28
	00 00 00 00	 mov	 QWORD PTR [rsp+40], 0
  0027e	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169905
  00285	48 89 4c 24 20	 mov	 QWORD PTR [rsp+32], rcx
  0028a	44 8b c8	 mov	 r9d, eax
  0028d	45 33 c0	 xor	 r8d, r8d
  00290	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG169906
  00297	b9 00 00 02 00	 mov	 ecx, 131072		; 00020000H
  0029c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ptt_pthread_trace
$LN34@LCS_EndCha:
  002a2	33 c0		 xor	 eax, eax
  002a4	85 c0		 test	 eax, eax
  002a6	75 a6		 jne	 SHORT $LN16@LCS_EndCha

; 1013 :             obtain_lock( &pLCSBLK->AttnEventLock );

  002a8	48 8b 44 24 48	 mov	 rax, QWORD PTR pLCSBLK$[rsp]
  002ad	48 83 c0 40	 add	 rax, 64			; 00000040H
  002b1	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG169907
  002b8	48 8b c8	 mov	 rcx, rax
  002bb	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_obtain_lock
$LN19@LCS_EndCha:

; 1014 :             PTT_DEBUG( "GOT  AttnEventLock ", 000, pDEVBLK->devnum, 000 );

  002c1	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_pttclass
  002c8	48 8b 00	 mov	 rax, QWORD PTR [rax]
  002cb	48 25 00 00 02
	00		 and	 rax, 131072		; 00020000H
  002d1	48 85 c0	 test	 rax, rax
  002d4	74 3f		 je	 SHORT $LN35@LCS_EndCha
  002d6	48 8b 44 24 70	 mov	 rax, QWORD PTR pDEVBLK$[rsp]
  002db	0f b7 40 48	 movzx	 eax, WORD PTR [rax+72]
  002df	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR [rsp+48], 0
  002e8	48 c7 44 24 28
	00 00 00 00	 mov	 QWORD PTR [rsp+40], 0
  002f1	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169909
  002f8	48 89 4c 24 20	 mov	 QWORD PTR [rsp+32], rcx
  002fd	44 8b c8	 mov	 r9d, eax
  00300	45 33 c0	 xor	 r8d, r8d
  00303	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG169910
  0030a	b9 00 00 02 00	 mov	 ecx, 131072		; 00020000H
  0030f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ptt_pthread_trace
$LN35@LCS_EndCha:
  00315	33 c0		 xor	 eax, eax
  00317	85 c0		 test	 eax, eax
  00319	75 a6		 jne	 SHORT $LN19@LCS_EndCha
$LN22@LCS_EndCha:

; 1015 :             {
; 1016 :                 PTT_DEBUG( "SIG  AttnEvent", 000, pDEVBLK->devnum, 000 );

  0031b	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_pttclass
  00322	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00325	48 25 00 00 02
	00		 and	 rax, 131072		; 00020000H
  0032b	48 85 c0	 test	 rax, rax
  0032e	74 3f		 je	 SHORT $LN36@LCS_EndCha
  00330	48 8b 44 24 70	 mov	 rax, QWORD PTR pDEVBLK$[rsp]
  00335	0f b7 40 48	 movzx	 eax, WORD PTR [rax+72]
  00339	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR [rsp+48], 0
  00342	48 c7 44 24 28
	00 00 00 00	 mov	 QWORD PTR [rsp+40], 0
  0034b	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169912
  00352	48 89 4c 24 20	 mov	 QWORD PTR [rsp+32], rcx
  00357	44 8b c8	 mov	 r9d, eax
  0035a	45 33 c0	 xor	 r8d, r8d
  0035d	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG169913
  00364	b9 00 00 02 00	 mov	 ecx, 131072		; 00020000H
  00369	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ptt_pthread_trace
$LN36@LCS_EndCha:
  0036f	33 c0		 xor	 eax, eax
  00371	85 c0		 test	 eax, eax
  00373	75 a6		 jne	 SHORT $LN22@LCS_EndCha

; 1017 :                 signal_condition( &pLCSBLK->AttnEvent );

  00375	48 8b 44 24 48	 mov	 rax, QWORD PTR pLCSBLK$[rsp]
  0037a	48 83 c0 48	 add	 rax, 72			; 00000048H
  0037e	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG169914
  00385	48 8b c8	 mov	 rcx, rax
  00388	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_signal_condition
$LN25@LCS_EndCha:

; 1018 :             }
; 1019 :             PTT_DEBUG( "REL  AttnEventLock ", 000, pDEVBLK->devnum, 000 );

  0038e	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_pttclass
  00395	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00398	48 25 00 00 02
	00		 and	 rax, 131072		; 00020000H
  0039e	48 85 c0	 test	 rax, rax
  003a1	74 3f		 je	 SHORT $LN37@LCS_EndCha
  003a3	48 8b 44 24 70	 mov	 rax, QWORD PTR pDEVBLK$[rsp]
  003a8	0f b7 40 48	 movzx	 eax, WORD PTR [rax+72]
  003ac	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR [rsp+48], 0
  003b5	48 c7 44 24 28
	00 00 00 00	 mov	 QWORD PTR [rsp+40], 0
  003be	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169916
  003c5	48 89 4c 24 20	 mov	 QWORD PTR [rsp+32], rcx
  003ca	44 8b c8	 mov	 r9d, eax
  003cd	45 33 c0	 xor	 r8d, r8d
  003d0	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG169917
  003d7	b9 00 00 02 00	 mov	 ecx, 131072		; 00020000H
  003dc	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ptt_pthread_trace
$LN37@LCS_EndCha:
  003e2	33 c0		 xor	 eax, eax
  003e4	85 c0		 test	 eax, eax
  003e6	75 a6		 jne	 SHORT $LN25@LCS_EndCha

; 1020 :             release_lock( &pLCSBLK->AttnEventLock );

  003e8	48 8b 44 24 48	 mov	 rax, QWORD PTR pLCSBLK$[rsp]
  003ed	48 83 c0 40	 add	 rax, 64			; 00000040H
  003f1	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG169918
  003f8	48 8b c8	 mov	 rcx, rax
  003fb	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_release_lock

; 1021 : 
; 1022 :             pLCSDEV->fAttnRequired = FALSE;

  00401	48 8b 44 24 40	 mov	 rax, QWORD PTR pLCSDEV$[rsp]
  00406	8b 40 5d	 mov	 eax, DWORD PTR [rax+93]
  00409	83 e0 fd	 and	 eax, -3			; fffffffdH
  0040c	48 8b 4c 24 40	 mov	 rcx, QWORD PTR pLCSDEV$[rsp]
  00411	89 41 5d	 mov	 DWORD PTR [rcx+93], eax
$LN28@LCS_EndCha:

; 1023 :         }
; 1024 : 
; 1025 :         pLCSDEV->bFlipFlop = 0;

  00414	48 8b 44 24 40	 mov	 rax, QWORD PTR pLCSDEV$[rsp]
  00419	c6 40 65 00	 mov	 BYTE PTR [rax+101], 0

; 1026 :         pLCSDEV->fChanProgActive = FALSE;

  0041d	48 8b 44 24 40	 mov	 rax, QWORD PTR pLCSDEV$[rsp]
  00422	8b 40 5d	 mov	 eax, DWORD PTR [rax+93]
  00425	83 e0 fe	 and	 eax, -2			; fffffffeH
  00428	48 8b 4c 24 40	 mov	 rcx, QWORD PTR pLCSDEV$[rsp]
  0042d	89 41 5d	 mov	 DWORD PTR [rcx+93], eax
$LN27@LCS_EndCha:
$LN1@LCS_EndCha:

; 1027 :     }
; 1028 : }

  00430	48 83 c4 68	 add	 rsp, 104		; 00000068H
  00434	c3		 ret	 0
LCS_EndChannelProgram ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\ctc_lcs.c
_TEXT	SEGMENT
pLCSDEV$ = 0
pDEVBLK$ = 32
LCS_StartChannelProgram PROC

; 949  : {

$LN5:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 18	 sub	 rsp, 24

; 950  :     PLCSDEV     pLCSDEV;
; 951  : 
; 952  : 
; 953  :     pLCSDEV = (PLCSDEV)pDEVBLK->dev_data;

  00009	48 8b 44 24 20	 mov	 rax, QWORD PTR pDEVBLK$[rsp]
  0000e	48 8b 80 08 06
	00 00		 mov	 rax, QWORD PTR [rax+1544]
  00015	48 89 04 24	 mov	 QWORD PTR pLCSDEV$[rsp], rax

; 954  :     if (!pLCSDEV) return;  // (incomplete group?)

  00019	48 83 3c 24 00	 cmp	 QWORD PTR pLCSDEV$[rsp], 0
  0001e	75 02		 jne	 SHORT $LN2@LCS_StartC
  00020	eb 26		 jmp	 SHORT $LN1@LCS_StartC
$LN2@LCS_StartC:

; 955  : 
; 956  :     if (pLCSDEV->bMode == LCSDEV_MODE_SNA)

  00022	48 8b 04 24	 mov	 rax, QWORD PTR pLCSDEV$[rsp]
  00026	0f b6 40 22	 movzx	 eax, BYTE PTR [rax+34]
  0002a	83 f8 02	 cmp	 eax, 2
  0002d	75 19		 jne	 SHORT $LN3@LCS_StartC

; 957  :     {
; 958  :         pLCSDEV->fChanProgActive = TRUE;

  0002f	48 8b 04 24	 mov	 rax, QWORD PTR pLCSDEV$[rsp]
  00033	8b 40 5d	 mov	 eax, DWORD PTR [rax+93]
  00036	83 c8 01	 or	 eax, 1
  00039	48 8b 0c 24	 mov	 rcx, QWORD PTR pLCSDEV$[rsp]
  0003d	89 41 5d	 mov	 DWORD PTR [rcx+93], eax

; 959  :         pLCSDEV->bFlipFlop = 0;

  00040	48 8b 04 24	 mov	 rax, QWORD PTR pLCSDEV$[rsp]
  00044	c6 40 65 00	 mov	 BYTE PTR [rax+101], 0
$LN3@LCS_StartC:
$LN1@LCS_StartC:

; 960  :     }
; 961  : 
; 962  : }

  00048	48 83 c4 18	 add	 rsp, 24
  0004c	c3		 ret	 0
LCS_StartChannelProgram ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\ctc_lcs.c
_TEXT	SEGMENT
i$ = 0
group$ = 32
devnum$ = 40
find_group_device PROC

; 214  : {

  00000	66 89 54 24 10	 mov	 WORD PTR [rsp+16], dx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 18	 sub	 rsp, 24

; 215  :     int i;
; 216  : 
; 217  :     for (i = 0; i < group->acount; i++)

  0000e	c7 04 24 00 00
	00 00		 mov	 DWORD PTR i$[rsp], 0
  00015	eb 08		 jmp	 SHORT $LN4@find_group
$LN2@find_group:
  00017	8b 04 24	 mov	 eax, DWORD PTR i$[rsp]
  0001a	ff c0		 inc	 eax
  0001c	89 04 24	 mov	 DWORD PTR i$[rsp], eax
$LN4@find_group:
  0001f	48 8b 44 24 20	 mov	 rax, QWORD PTR group$[rsp]
  00024	8b 40 04	 mov	 eax, DWORD PTR [rax+4]
  00027	39 04 24	 cmp	 DWORD PTR i$[rsp], eax
  0002a	7d 2d		 jge	 SHORT $LN3@find_group

; 218  :         if (group->memdev[i]->devnum == devnum)

  0002c	48 63 04 24	 movsxd	 rax, DWORD PTR i$[rsp]
  00030	48 8b 4c 24 20	 mov	 rcx, QWORD PTR group$[rsp]
  00035	48 8b 44 c1 10	 mov	 rax, QWORD PTR [rcx+rax*8+16]
  0003a	0f b7 40 48	 movzx	 eax, WORD PTR [rax+72]
  0003e	0f b7 4c 24 28	 movzx	 ecx, WORD PTR devnum$[rsp]
  00043	3b c1		 cmp	 eax, ecx
  00045	75 10		 jne	 SHORT $LN5@find_group

; 219  :             return group->memdev[i];

  00047	48 63 04 24	 movsxd	 rax, DWORD PTR i$[rsp]
  0004b	48 8b 4c 24 20	 mov	 rcx, QWORD PTR group$[rsp]
  00050	48 8b 44 c1 10	 mov	 rax, QWORD PTR [rcx+rax*8+16]
  00055	eb 04		 jmp	 SHORT $LN1@find_group
$LN5@find_group:
  00057	eb be		 jmp	 SHORT $LN2@find_group
$LN3@find_group:

; 220  : 
; 221  :     return NULL;

  00059	33 c0		 xor	 eax, eax
$LN1@find_group:

; 222  : }

  0005b	48 83 c4 18	 add	 rsp, 24
  0005f	c3		 ret	 0
find_group_device ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\ctc_lcs.c
_TEXT	SEGMENT
pLCSDEV$ = 48
pLCSCONN$ = 56
free_connection PROC

; 7850 : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	57		 push	 rdi
  0000b	48 83 ec 20	 sub	 rsp, 32			; 00000020H
$LN4@free_conne:

; 7851 :     UNREFERENCED( pLCSDEV );

  0000f	33 c0		 xor	 eax, eax
  00011	85 c0		 test	 eax, eax
  00013	75 fa		 jne	 SHORT $LN4@free_conne

; 7852 : 
; 7853 :     memset( pLCSCONN, 0x4f, sizeof(LCSCONN) );

  00015	48 8b 7c 24 38	 mov	 rdi, QWORD PTR pLCSCONN$[rsp]
  0001a	b8 4f 00 00 00	 mov	 eax, 79			; 0000004fH
  0001f	b9 30 00 00 00	 mov	 ecx, 48			; 00000030H
  00024	f3 aa		 rep stosb

; 7854 :     free( pLCSCONN );

  00026	48 8b 4c 24 38	 mov	 rcx, QWORD PTR pLCSCONN$[rsp]
  0002b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free

; 7855 :     return;
; 7856 : }

  00031	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00035	5f		 pop	 rdi
  00036	c3		 ret	 0
free_connection ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\ctc_lcs.c
_TEXT	SEGMENT
pLCSCONN$ = 32
pLCSDEV$ = 64
remove_and_free_any_connections_on_chain PROC

; 7825 : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 7826 :     PLCSCONN    pLCSCONN;
; 7827 : 
; 7828 :     // Obtain the connection chain lock.
; 7829 :     obtain_lock( &pLCSDEV->LCSCONNChainLock );

  00009	48 8b 44 24 40	 mov	 rax, QWORD PTR pLCSDEV$[rsp]
  0000e	48 05 82 00 00
	00		 add	 rax, 130		; 00000082H
  00014	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG175682
  0001b	48 8b c8	 mov	 rcx, rax
  0001e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_obtain_lock
$LN2@remove_and:

; 7830 : 
; 7831 :     // Remove and free the first LCSCONN on the chain, if there is one...
; 7832 :     while( pLCSDEV->pFirstLCSCONN )

  00024	48 8b 44 24 40	 mov	 rax, QWORD PTR pLCSDEV$[rsp]
  00029	48 83 b8 8a 00
	00 00 00	 cmp	 QWORD PTR [rax+138], 0
  00031	74 3f		 je	 SHORT $LN3@remove_and

; 7833 :     {
; 7834 :         pLCSCONN = pLCSDEV->pFirstLCSCONN;                 // Pointer to first LCSCONN

  00033	48 8b 44 24 40	 mov	 rax, QWORD PTR pLCSDEV$[rsp]
  00038	48 8b 80 8a 00
	00 00		 mov	 rax, QWORD PTR [rax+138]
  0003f	48 89 44 24 20	 mov	 QWORD PTR pLCSCONN$[rsp], rax

; 7835 :         pLCSDEV->pFirstLCSCONN = pLCSCONN->pNextLCSCONN;   // Make the next the first LCSCONN

  00044	48 8b 44 24 40	 mov	 rax, QWORD PTR pLCSDEV$[rsp]
  00049	48 8b 4c 24 20	 mov	 rcx, QWORD PTR pLCSCONN$[rsp]
  0004e	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  00051	48 89 88 8a 00
	00 00		 mov	 QWORD PTR [rax+138], rcx

; 7836 :         free_connection( pLCSDEV, pLCSCONN );              // Free the connection

  00058	48 8b 54 24 20	 mov	 rdx, QWORD PTR pLCSCONN$[rsp]
  0005d	48 8b 4c 24 40	 mov	 rcx, QWORD PTR pLCSDEV$[rsp]
  00062	e8 00 00 00 00	 call	 free_connection

; 7837 :         pLCSCONN = NULL;

  00067	48 c7 44 24 20
	00 00 00 00	 mov	 QWORD PTR pLCSCONN$[rsp], 0

; 7838 :     }

  00070	eb b2		 jmp	 SHORT $LN2@remove_and
$LN3@remove_and:

; 7839 : 
; 7840 :     // Release the connection chain lock.
; 7841 :     release_lock( &pLCSDEV->LCSCONNChainLock );

  00072	48 8b 44 24 40	 mov	 rax, QWORD PTR pLCSDEV$[rsp]
  00077	48 05 82 00 00
	00		 add	 rax, 130		; 00000082H
  0007d	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG175683
  00084	48 8b c8	 mov	 rcx, rax
  00087	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_release_lock

; 7842 : 
; 7843 :     return;
; 7844 : }

  0008d	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00091	c3		 ret	 0
remove_and_free_any_connections_on_chain ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\ctc_lcs.c
_TEXT	SEGMENT
rc$ = 32
pCurrLCSCONN$ = 40
ppPrevLCSCONN$ = 48
pLCSDEV$ = 80
pLCSCONN$ = 88
remove_connection_from_chain PROC

; 7788 : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 7789 :     PLCSCONN   pCurrLCSCONN;
; 7790 :     PLCSCONN* ppPrevLCSCONN;
; 7791 :     int        rc;
; 7792 : 
; 7793 :     // Prepare LCSCONN for removing from chain.
; 7794 :     if (!pLCSCONN)                                    // Any LCSCONN been passed?

  0000e	48 83 7c 24 58
	00		 cmp	 QWORD PTR pLCSCONN$[rsp], 0
  00014	75 0a		 jne	 SHORT $LN5@remove_con

; 7795 :         return -1;                                    // No, the caller is a fool

  00016	b8 ff ff ff ff	 mov	 eax, -1
  0001b	e9 b8 00 00 00	 jmp	 $LN1@remove_con
$LN5@remove_con:

; 7796 : 
; 7797 :     // Obtain the connection chain lock.
; 7798 :     obtain_lock( &pLCSDEV->LCSCONNChainLock );

  00020	48 8b 44 24 50	 mov	 rax, QWORD PTR pLCSDEV$[rsp]
  00025	48 05 82 00 00
	00		 add	 rax, 130		; 00000082H
  0002b	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG175672
  00032	48 8b c8	 mov	 rcx, rax
  00035	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_obtain_lock

; 7799 : 
; 7800 :     // Remove the LCSCONN from the chain.
; 7801 :     rc = 1;

  0003b	c7 44 24 20 01
	00 00 00	 mov	 DWORD PTR rc$[rsp], 1

; 7802 :     ppPrevLCSCONN = &pLCSDEV->pFirstLCSCONN;

  00043	48 8b 44 24 50	 mov	 rax, QWORD PTR pLCSDEV$[rsp]
  00048	48 05 8a 00 00
	00		 add	 rax, 138		; 0000008aH
  0004e	48 89 44 24 30	 mov	 QWORD PTR ppPrevLCSCONN$[rsp], rax

; 7803 :     for (pCurrLCSCONN = pLCSDEV->pFirstLCSCONN; pCurrLCSCONN; pCurrLCSCONN = pCurrLCSCONN->pNextLCSCONN)

  00053	48 8b 44 24 50	 mov	 rax, QWORD PTR pLCSDEV$[rsp]
  00058	48 8b 80 8a 00
	00 00		 mov	 rax, QWORD PTR [rax+138]
  0005f	48 89 44 24 28	 mov	 QWORD PTR pCurrLCSCONN$[rsp], rax
  00064	eb 0d		 jmp	 SHORT $LN4@remove_con
$LN2@remove_con:
  00066	48 8b 44 24 28	 mov	 rax, QWORD PTR pCurrLCSCONN$[rsp]
  0006b	48 8b 00	 mov	 rax, QWORD PTR [rax]
  0006e	48 89 44 24 28	 mov	 QWORD PTR pCurrLCSCONN$[rsp], rax
$LN4@remove_con:
  00073	48 83 7c 24 28
	00		 cmp	 QWORD PTR pCurrLCSCONN$[rsp], 0
  00079	74 3e		 je	 SHORT $LN3@remove_con

; 7804 :     {
; 7805 :         if (pCurrLCSCONN == pLCSCONN)

  0007b	48 8b 44 24 58	 mov	 rax, QWORD PTR pLCSCONN$[rsp]
  00080	48 39 44 24 28	 cmp	 QWORD PTR pCurrLCSCONN$[rsp], rax
  00085	75 26		 jne	 SHORT $LN6@remove_con

; 7806 :         {
; 7807 :             *ppPrevLCSCONN = pCurrLCSCONN->pNextLCSCONN;

  00087	48 8b 44 24 30	 mov	 rax, QWORD PTR ppPrevLCSCONN$[rsp]
  0008c	48 8b 4c 24 28	 mov	 rcx, QWORD PTR pCurrLCSCONN$[rsp]
  00091	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  00094	48 89 08	 mov	 QWORD PTR [rax], rcx

; 7808 :             pCurrLCSCONN->pNextLCSCONN = NULL;

  00097	48 8b 44 24 28	 mov	 rax, QWORD PTR pCurrLCSCONN$[rsp]
  0009c	48 c7 00 00 00
	00 00		 mov	 QWORD PTR [rax], 0

; 7809 :             rc = 0;

  000a3	c7 44 24 20 00
	00 00 00	 mov	 DWORD PTR rc$[rsp], 0

; 7810 :             break;

  000ab	eb 0c		 jmp	 SHORT $LN3@remove_con
$LN6@remove_con:

; 7811 :         }
; 7812 :         ppPrevLCSCONN = &pCurrLCSCONN->pNextLCSCONN;

  000ad	48 8b 44 24 28	 mov	 rax, QWORD PTR pCurrLCSCONN$[rsp]
  000b2	48 89 44 24 30	 mov	 QWORD PTR ppPrevLCSCONN$[rsp], rax

; 7813 :     }

  000b7	eb ad		 jmp	 SHORT $LN2@remove_con
$LN3@remove_con:

; 7814 : 
; 7815 :     // Release the connection chain lock.
; 7816 :     release_lock( &pLCSDEV->LCSCONNChainLock );

  000b9	48 8b 44 24 50	 mov	 rax, QWORD PTR pLCSDEV$[rsp]
  000be	48 05 82 00 00
	00		 add	 rax, 130		; 00000082H
  000c4	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG175674
  000cb	48 8b c8	 mov	 rcx, rax
  000ce	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_release_lock

; 7817 : 
; 7818 :     return rc;

  000d4	8b 44 24 20	 mov	 eax, DWORD PTR rc$[rsp]
$LN1@remove_con:

; 7819 : }

  000d8	48 83 c4 48	 add	 rsp, 72			; 00000048H
  000dc	c3		 ret	 0
remove_connection_from_chain ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\ctc_lcs.c
_TEXT	SEGMENT
pLCSCONN$ = 32
pLCSDEV$ = 64
pToken$ = 72
find_connection_by_inbound_token PROC

; 7676 : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 7677 :     PLCSCONN   pLCSCONN;
; 7678 : 
; 7679 :     for (pLCSCONN = pLCSDEV->pFirstLCSCONN; pLCSCONN; pLCSCONN = pLCSCONN->pNextLCSCONN)

  0000e	48 8b 44 24 40	 mov	 rax, QWORD PTR pLCSDEV$[rsp]
  00013	48 8b 80 8a 00
	00 00		 mov	 rax, QWORD PTR [rax+138]
  0001a	48 89 44 24 20	 mov	 QWORD PTR pLCSCONN$[rsp], rax
  0001f	eb 0d		 jmp	 SHORT $LN4@find_conne
$LN2@find_conne:
  00021	48 8b 44 24 20	 mov	 rax, QWORD PTR pLCSCONN$[rsp]
  00026	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00029	48 89 44 24 20	 mov	 QWORD PTR pLCSCONN$[rsp], rax
$LN4@find_conne:
  0002e	48 83 7c 24 20
	00		 cmp	 QWORD PTR pLCSCONN$[rsp], 0
  00034	74 24		 je	 SHORT $LN3@find_conne

; 7680 :     {
; 7681 :         if ( memcmp( &pLCSCONN->bInToken, pToken, sizeof(pLCSCONN->bInToken) ) == 0 )

  00036	48 8b 44 24 20	 mov	 rax, QWORD PTR pLCSCONN$[rsp]
  0003b	48 83 c0 08	 add	 rax, 8
  0003f	41 b8 04 00 00
	00		 mov	 r8d, 4
  00045	48 8b 54 24 48	 mov	 rdx, QWORD PTR pToken$[rsp]
  0004a	48 8b c8	 mov	 rcx, rax
  0004d	e8 00 00 00 00	 call	 memcmp
  00052	85 c0		 test	 eax, eax
  00054	75 02		 jne	 SHORT $LN5@find_conne

; 7682 :         {
; 7683 :             break;

  00056	eb 02		 jmp	 SHORT $LN3@find_conne
$LN5@find_conne:

; 7684 :         }
; 7685 :     }

  00058	eb c7		 jmp	 SHORT $LN2@find_conne
$LN3@find_conne:

; 7686 : 
; 7687 :     return pLCSCONN;

  0005a	48 8b 44 24 20	 mov	 rax, QWORD PTR pLCSCONN$[rsp]

; 7688 : }

  0005f	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00063	c3		 ret	 0
find_connection_by_inbound_token ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\ctc_lcs.c
_TEXT	SEGMENT
pLCSCONN$ = 32
pLCSDEV$ = 64
pToken$ = 72
find_connection_by_outbound_token PROC

; 7658 : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 7659 :     PLCSCONN   pLCSCONN;
; 7660 : 
; 7661 :     for (pLCSCONN = pLCSDEV->pFirstLCSCONN; pLCSCONN; pLCSCONN = pLCSCONN->pNextLCSCONN)

  0000e	48 8b 44 24 40	 mov	 rax, QWORD PTR pLCSDEV$[rsp]
  00013	48 8b 80 8a 00
	00 00		 mov	 rax, QWORD PTR [rax+138]
  0001a	48 89 44 24 20	 mov	 QWORD PTR pLCSCONN$[rsp], rax
  0001f	eb 0d		 jmp	 SHORT $LN4@find_conne
$LN2@find_conne:
  00021	48 8b 44 24 20	 mov	 rax, QWORD PTR pLCSCONN$[rsp]
  00026	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00029	48 89 44 24 20	 mov	 QWORD PTR pLCSCONN$[rsp], rax
$LN4@find_conne:
  0002e	48 83 7c 24 20
	00		 cmp	 QWORD PTR pLCSCONN$[rsp], 0
  00034	74 24		 je	 SHORT $LN3@find_conne

; 7662 :     {
; 7663 :         if ( memcmp( &pLCSCONN->bOutToken, pToken, sizeof(pLCSCONN->bOutToken) ) == 0 )

  00036	48 8b 44 24 20	 mov	 rax, QWORD PTR pLCSCONN$[rsp]
  0003b	48 83 c0 0c	 add	 rax, 12
  0003f	41 b8 04 00 00
	00		 mov	 r8d, 4
  00045	48 8b 54 24 48	 mov	 rdx, QWORD PTR pToken$[rsp]
  0004a	48 8b c8	 mov	 rcx, rax
  0004d	e8 00 00 00 00	 call	 memcmp
  00052	85 c0		 test	 eax, eax
  00054	75 02		 jne	 SHORT $LN5@find_conne

; 7664 :         {
; 7665 :             break;

  00056	eb 02		 jmp	 SHORT $LN3@find_conne
$LN5@find_conne:

; 7666 :         }
; 7667 :     }

  00058	eb c7		 jmp	 SHORT $LN2@find_conne
$LN3@find_conne:

; 7668 : 
; 7669 :     return pLCSCONN;

  0005a	48 8b 44 24 20	 mov	 rax, QWORD PTR pLCSCONN$[rsp]

; 7670 : }

  0005f	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00063	c3		 ret	 0
find_connection_by_outbound_token ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\ctc_lcs.c
_TEXT	SEGMENT
pLCSCONN$ = 32
pLCSDEV$ = 64
pMAC$ = 72
find_connection_by_remote_mac PROC

; 7639 : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 7640 :     PLCSCONN   pLCSCONN;
; 7641 : 
; 7642 :     // Locate the LCSCONN on the chain.
; 7643 :     for (pLCSCONN = pLCSDEV->pFirstLCSCONN; pLCSCONN; pLCSCONN = pLCSCONN->pNextLCSCONN)

  0000e	48 8b 44 24 40	 mov	 rax, QWORD PTR pLCSDEV$[rsp]
  00013	48 8b 80 8a 00
	00 00		 mov	 rax, QWORD PTR [rax+138]
  0001a	48 89 44 24 20	 mov	 QWORD PTR pLCSCONN$[rsp], rax
  0001f	eb 0d		 jmp	 SHORT $LN4@find_conne
$LN2@find_conne:
  00021	48 8b 44 24 20	 mov	 rax, QWORD PTR pLCSCONN$[rsp]
  00026	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00029	48 89 44 24 20	 mov	 QWORD PTR pLCSCONN$[rsp], rax
$LN4@find_conne:
  0002e	48 83 7c 24 20
	00		 cmp	 QWORD PTR pLCSCONN$[rsp], 0
  00034	74 24		 je	 SHORT $LN3@find_conne

; 7644 :     {
; 7645 :         if ( ( memcmp( &pLCSCONN->bRemoteMAC, pMAC, IFHWADDRLEN ) == 0 ) )

  00036	48 8b 44 24 20	 mov	 rax, QWORD PTR pLCSCONN$[rsp]
  0003b	48 83 c0 16	 add	 rax, 22
  0003f	41 b8 06 00 00
	00		 mov	 r8d, 6
  00045	48 8b 54 24 48	 mov	 rdx, QWORD PTR pMAC$[rsp]
  0004a	48 8b c8	 mov	 rcx, rax
  0004d	e8 00 00 00 00	 call	 memcmp
  00052	85 c0		 test	 eax, eax
  00054	75 02		 jne	 SHORT $LN5@find_conne

; 7646 :         {
; 7647 :             break;

  00056	eb 02		 jmp	 SHORT $LN3@find_conne
$LN5@find_conne:

; 7648 :         }
; 7649 :     }

  00058	eb c7		 jmp	 SHORT $LN2@find_conne
$LN3@find_conne:

; 7650 : 
; 7651 :     return pLCSCONN;

  0005a	48 8b 44 24 20	 mov	 rax, QWORD PTR pLCSCONN$[rsp]

; 7652 : }

  0005f	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00063	c3		 ret	 0
find_connection_by_remote_mac ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\ctc_lcs.c
_TEXT	SEGMENT
pLCSDEV$ = 48
pLCSCONN$ = 56
add_connection_to_chain PROC

; 7615 : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 7616 : 
; 7617 :     // Prepare LCSCONN for adding to chain.
; 7618 :     if (!pLCSCONN)                                       // Any LCSCONN been passed?

  0000e	48 83 7c 24 38
	00		 cmp	 QWORD PTR pLCSCONN$[rsp], 0
  00014	75 02		 jne	 SHORT $LN2@add_connec

; 7619 :         return;                                          // No, the caller is a fool

  00016	eb 67		 jmp	 SHORT $LN1@add_connec
$LN2@add_connec:

; 7620 :     pLCSCONN->pNextLCSCONN = NULL;                       // Clear the pointer to next LCSCONN

  00018	48 8b 44 24 38	 mov	 rax, QWORD PTR pLCSCONN$[rsp]
  0001d	48 c7 00 00 00
	00 00		 mov	 QWORD PTR [rax], 0

; 7621 : 
; 7622 :     // Obtain the connection chain lock.
; 7623 :     obtain_lock( &pLCSDEV->LCSCONNChainLock );

  00024	48 8b 44 24 30	 mov	 rax, QWORD PTR pLCSDEV$[rsp]
  00029	48 05 82 00 00
	00		 add	 rax, 130		; 00000082H
  0002f	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG175627
  00036	48 8b c8	 mov	 rcx, rax
  00039	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_obtain_lock

; 7624 : 
; 7625 :     // Add the LCSCONN to the start of the chain.
; 7626 :     pLCSCONN->pNextLCSCONN = pLCSDEV->pFirstLCSCONN;

  0003f	48 8b 44 24 38	 mov	 rax, QWORD PTR pLCSCONN$[rsp]
  00044	48 8b 4c 24 30	 mov	 rcx, QWORD PTR pLCSDEV$[rsp]
  00049	48 8b 89 8a 00
	00 00		 mov	 rcx, QWORD PTR [rcx+138]
  00050	48 89 08	 mov	 QWORD PTR [rax], rcx

; 7627 :     pLCSDEV->pFirstLCSCONN = pLCSCONN;

  00053	48 8b 44 24 30	 mov	 rax, QWORD PTR pLCSDEV$[rsp]
  00058	48 8b 4c 24 38	 mov	 rcx, QWORD PTR pLCSCONN$[rsp]
  0005d	48 89 88 8a 00
	00 00		 mov	 QWORD PTR [rax+138], rcx

; 7628 : 
; 7629 :     // Release the connection chain lock.
; 7630 :     release_lock( &pLCSDEV->LCSCONNChainLock );

  00064	48 8b 44 24 30	 mov	 rax, QWORD PTR pLCSDEV$[rsp]
  00069	48 05 82 00 00
	00		 add	 rax, 130		; 00000082H
  0006f	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG175628
  00076	48 8b c8	 mov	 rcx, rax
  00079	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_release_lock
$LN1@add_connec:

; 7631 : 
; 7632 :     return;
; 7633 : }

  0007f	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00083	c3		 ret	 0
add_connection_to_chain ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\ctc_lcs.c
_TEXT	SEGMENT
tv86 = 96
tv90 = 100
pDEVBLK$ = 104
pLCSCONN$ = 112
tv74 = 120
etext$ = 128
__$ArrayPad$ = 168
pLCSDEV$ = 192
alloc_connection PROC

; 7591 : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 81 ec b8 00
	00 00		 sub	 rsp, 184		; 000000b8H
  0000c	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00013	48 33 c4	 xor	 rax, rsp
  00016	48 89 84 24 a8
	00 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 7592 :     DEVBLK*    pDEVBLK;
; 7593 :     PLCSCONN   pLCSCONN;
; 7594 :     char       etext[40];              // malloc text
; 7595 : 
; 7596 : 
; 7597 :     // Allocate the connection.                                                                                                                                                                        d
; 7598 :     pLCSCONN = calloc( sizeof(LCSCONN), 1 );     // Allocate and clear the connection

  0001e	ba 01 00 00 00	 mov	 edx, 1
  00023	b9 30 00 00 00	 mov	 ecx, 48			; 00000030H
  00028	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_calloc
  0002e	48 89 44 24 70	 mov	 QWORD PTR pLCSCONN$[rsp], rax

; 7599 :     if (!pLCSCONN)                               // if the allocate was not successful...

  00033	48 83 7c 24 70
	00		 cmp	 QWORD PTR pLCSCONN$[rsp], 0
  00039	0f 85 e6 00 00
	00		 jne	 $LN2@alloc_conn

; 7600 :     {
; 7601 :         pDEVBLK = pLCSDEV->pDEVBLK[ LCS_READ_SUBCHANN ];

  0003f	b8 08 00 00 00	 mov	 eax, 8
  00044	48 6b c0 00	 imul	 rax, rax, 0
  00048	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR pLCSDEV$[rsp]
  00050	48 8b 44 01 10	 mov	 rax, QWORD PTR [rcx+rax+16]
  00055	48 89 44 24 68	 mov	 QWORD PTR pDEVBLK$[rsp], rax

; 7602 :         // Report the bad news.
; 7603 :         MSGBUF( etext, "malloc(%d)", (int)sizeof(LCSCONN) );

  0005a	41 b9 30 00 00
	00		 mov	 r9d, 48			; 00000030H
  00060	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG175615
  00067	ba 28 00 00 00	 mov	 edx, 40			; 00000028H
  0006c	48 8d 8c 24 80
	00 00 00	 lea	 rcx, QWORD PTR etext$[rsp]
  00074	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_snprintf

; 7604 :         // HHC00900 "%1d:%04X %s: error in function %s: %s"
; 7605 :         WRMSG(HHC00900, "E", SSID_TO_LCSS(pDEVBLK->ssid), pDEVBLK->devnum, pDEVBLK->typname,

  0007a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno
  00080	8b 08		 mov	 ecx, DWORD PTR [rax]
  00082	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_strerror
  00088	48 89 44 24 78	 mov	 QWORD PTR tv74[rsp], rax
  0008d	48 8b 4c 24 68	 mov	 rcx, QWORD PTR pDEVBLK$[rsp]
  00092	0f b7 49 48	 movzx	 ecx, WORD PTR [rcx+72]
  00096	89 4c 24 60	 mov	 DWORD PTR tv86[rsp], ecx
  0009a	48 8b 54 24 68	 mov	 rdx, QWORD PTR pDEVBLK$[rsp]
  0009f	0f b7 52 44	 movzx	 edx, WORD PTR [rdx+68]
  000a3	d1 fa		 sar	 edx, 1
  000a5	89 54 24 64	 mov	 DWORD PTR tv90[rsp], edx
  000a9	b9 01 00 00 00	 mov	 ecx, 1
  000ae	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  000b4	48 8b 4c 24 78	 mov	 rcx, QWORD PTR tv74[rsp]
  000b9	48 89 4c 24 58	 mov	 QWORD PTR [rsp+88], rcx
  000be	48 8d 8c 24 80
	00 00 00	 lea	 rcx, QWORD PTR etext$[rsp]
  000c6	48 89 4c 24 50	 mov	 QWORD PTR [rsp+80], rcx
  000cb	48 8b 4c 24 68	 mov	 rcx, QWORD PTR pDEVBLK$[rsp]
  000d0	48 8b 49 50	 mov	 rcx, QWORD PTR [rcx+80]
  000d4	48 89 4c 24 48	 mov	 QWORD PTR [rsp+72], rcx
  000d9	8b 4c 24 60	 mov	 ecx, DWORD PTR tv86[rsp]
  000dd	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  000e1	8b 4c 24 64	 mov	 ecx, DWORD PTR tv90[rsp]
  000e5	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  000e9	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG175616
  000f0	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  000f5	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG175617
  000fc	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00101	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00106	41 b9 03 00 00
	00		 mov	 r9d, 3
  0010c	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG175618
  00113	ba b6 1d 00 00	 mov	 edx, 7606		; 00001db6H
  00118	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG175619
  0011f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg
$LN2@alloc_conn:

; 7606 :                              etext, strerror(errno) );
; 7607 :     }
; 7608 :     return pLCSCONN;

  00125	48 8b 44 24 70	 mov	 rax, QWORD PTR pLCSCONN$[rsp]

; 7609 : }

  0012a	48 8b 8c 24 a8
	00 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  00132	48 33 cc	 xor	 rcx, rsp
  00135	e8 00 00 00 00	 call	 __security_check_cookie
  0013a	48 81 c4 b8 00
	00 00		 add	 rsp, 184		; 000000b8H
  00141	c3		 ret	 0
alloc_connection ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\ctc_lcs.c
_TEXT	SEGMENT
pLCSDEV$ = 48
pLCSIBH$ = 56
free_lcs_buffer PROC

; 7579 : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 28	 sub	 rsp, 40			; 00000028H
$LN4@free_lcs_b:

; 7580 :     UNREFERENCED( pLCSDEV );

  0000e	33 c0		 xor	 eax, eax
  00010	85 c0		 test	 eax, eax
  00012	75 fa		 jne	 SHORT $LN4@free_lcs_b

; 7581 : 
; 7582 :     free( pLCSIBH );

  00014	48 8b 4c 24 38	 mov	 rcx, QWORD PTR pLCSIBH$[rsp]
  00019	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free

; 7583 :     return;
; 7584 : }

  0001f	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00023	c3		 ret	 0
free_lcs_buffer ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\ctc_lcs.c
_TEXT	SEGMENT
pLCSIBH$ = 32
pLCSDEV$ = 64
remove_and_free_any_lcs_buffers_on_chain PROC

; 7550 : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 7551 :     PLCSIBH    pLCSIBH;                                // LCSIBH
; 7552 : 
; 7553 :     // Obtain the buffer chain lock.
; 7554 :     obtain_lock( &pLCSDEV->LCSIBHChainLock );

  00009	48 8b 44 24 40	 mov	 rax, QWORD PTR pLCSDEV$[rsp]
  0000e	48 83 c0 6a	 add	 rax, 106		; 0000006aH
  00012	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG175594
  00019	48 8b c8	 mov	 rcx, rax
  0001c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_obtain_lock
$LN2@remove_and:

; 7555 : 
; 7556 :     // Remove and free the first LCSIBH on the chain, if there is one...
; 7557 :     while(pLCSDEV->pFirstLCSIBH)

  00022	48 8b 44 24 40	 mov	 rax, QWORD PTR pLCSDEV$[rsp]
  00027	48 83 78 72 00	 cmp	 QWORD PTR [rax+114], 0
  0002c	74 39		 je	 SHORT $LN3@remove_and

; 7558 :     {
; 7559 :         pLCSIBH = pLCSDEV->pFirstLCSIBH;               // Pointer to first LCSIBH

  0002e	48 8b 44 24 40	 mov	 rax, QWORD PTR pLCSDEV$[rsp]
  00033	48 8b 40 72	 mov	 rax, QWORD PTR [rax+114]
  00037	48 89 44 24 20	 mov	 QWORD PTR pLCSIBH$[rsp], rax

; 7560 :         pLCSDEV->pFirstLCSIBH = pLCSIBH->pNextLCSIBH;  // Make the next the first LCSIBH

  0003c	48 8b 44 24 40	 mov	 rax, QWORD PTR pLCSDEV$[rsp]
  00041	48 8b 4c 24 20	 mov	 rcx, QWORD PTR pLCSIBH$[rsp]
  00046	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  00049	48 89 48 72	 mov	 QWORD PTR [rax+114], rcx

; 7561 :         free_lcs_buffer( pLCSDEV, pLCSIBH );           // Free the buffer

  0004d	48 8b 54 24 20	 mov	 rdx, QWORD PTR pLCSIBH$[rsp]
  00052	48 8b 4c 24 40	 mov	 rcx, QWORD PTR pLCSDEV$[rsp]
  00057	e8 00 00 00 00	 call	 free_lcs_buffer

; 7562 :         pLCSIBH = NULL;

  0005c	48 c7 44 24 20
	00 00 00 00	 mov	 QWORD PTR pLCSIBH$[rsp], 0

; 7563 :     }

  00065	eb bb		 jmp	 SHORT $LN2@remove_and
$LN3@remove_and:

; 7564 : 
; 7565 :     // Reset the chain pointers.
; 7566 :     pLCSDEV->pFirstLCSIBH = NULL;                      // Clear the

  00067	48 8b 44 24 40	 mov	 rax, QWORD PTR pLCSDEV$[rsp]
  0006c	48 c7 40 72 00
	00 00 00	 mov	 QWORD PTR [rax+114], 0

; 7567 :     pLCSDEV->pLastLCSIBH = NULL;                       // chain pointers

  00074	48 8b 44 24 40	 mov	 rax, QWORD PTR pLCSDEV$[rsp]
  00079	48 c7 40 7a 00
	00 00 00	 mov	 QWORD PTR [rax+122], 0

; 7568 : 
; 7569 :     // Release the buffer chain lock.
; 7570 :     release_lock( &pLCSDEV->LCSIBHChainLock );

  00081	48 8b 44 24 40	 mov	 rax, QWORD PTR pLCSDEV$[rsp]
  00086	48 83 c0 6a	 add	 rax, 106		; 0000006aH
  0008a	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG175595
  00091	48 8b c8	 mov	 rcx, rax
  00094	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_release_lock

; 7571 : 
; 7572 :     return;
; 7573 : }

  0009a	48 83 c4 38	 add	 rsp, 56			; 00000038H
  0009e	c3		 ret	 0
remove_and_free_any_lcs_buffers_on_chain ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\ctc_lcs.c
_TEXT	SEGMENT
pLCSIBH$ = 32
pLCSDEV$ = 64
remove_lcs_buffer_from_chain PROC

; 7519 : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 7520 :     PLCSIBH    pLCSIBH;                                // LCSIBH
; 7521 : 
; 7522 :     // Obtain the buffer chain lock.
; 7523 :     obtain_lock( &pLCSDEV->LCSIBHChainLock );

  00009	48 8b 44 24 40	 mov	 rax, QWORD PTR pLCSDEV$[rsp]
  0000e	48 83 c0 6a	 add	 rax, 106		; 0000006aH
  00012	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG175581
  00019	48 8b c8	 mov	 rcx, rax
  0001c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_obtain_lock

; 7524 : 
; 7525 :     // Point to first LCSIBH on the chain.
; 7526 :     pLCSIBH = pLCSDEV->pFirstLCSIBH;                   // Pointer to first LCSIBH

  00022	48 8b 44 24 40	 mov	 rax, QWORD PTR pLCSDEV$[rsp]
  00027	48 8b 40 72	 mov	 rax, QWORD PTR [rax+114]
  0002b	48 89 44 24 20	 mov	 QWORD PTR pLCSIBH$[rsp], rax

; 7527 : 
; 7528 :     // Remove the first LCSIBH from the chain, if there is one...
; 7529 :     if (pLCSIBH)                                       // If there is a LCSIBH

  00030	48 83 7c 24 20
	00		 cmp	 QWORD PTR pLCSIBH$[rsp], 0
  00036	74 36		 je	 SHORT $LN2@remove_lcs

; 7530 :     {
; 7531 :         pLCSDEV->pFirstLCSIBH = pLCSIBH->pNextLCSIBH;  // Make the next the first LCSIBH

  00038	48 8b 44 24 40	 mov	 rax, QWORD PTR pLCSDEV$[rsp]
  0003d	48 8b 4c 24 20	 mov	 rcx, QWORD PTR pLCSIBH$[rsp]
  00042	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  00045	48 89 48 72	 mov	 QWORD PTR [rax+114], rcx

; 7532 :         if (!pLCSDEV->pFirstLCSIBH)                    // if there are no more LCSIBHs

  00049	48 8b 44 24 40	 mov	 rax, QWORD PTR pLCSDEV$[rsp]
  0004e	48 83 78 72 00	 cmp	 QWORD PTR [rax+114], 0
  00053	75 0d		 jne	 SHORT $LN3@remove_lcs

; 7533 :         {
; 7534 : //          pLCSDEV->pFirstLCSIBH = NULL;              // Clear
; 7535 :             pLCSDEV->pLastLCSIBH = NULL;               // the chain

  00055	48 8b 44 24 40	 mov	 rax, QWORD PTR pLCSDEV$[rsp]
  0005a	48 c7 40 7a 00
	00 00 00	 mov	 QWORD PTR [rax+122], 0
$LN3@remove_lcs:

; 7536 :         }
; 7537 :         pLCSIBH->pNextLCSIBH = NULL;                   // Clear the pointer to next LCSIBH

  00062	48 8b 44 24 20	 mov	 rax, QWORD PTR pLCSIBH$[rsp]
  00067	48 c7 00 00 00
	00 00		 mov	 QWORD PTR [rax], 0
$LN2@remove_lcs:

; 7538 :     }
; 7539 : 
; 7540 :     // Release the buffer chain lock.
; 7541 :     release_lock( &pLCSDEV->LCSIBHChainLock );

  0006e	48 8b 44 24 40	 mov	 rax, QWORD PTR pLCSDEV$[rsp]
  00073	48 83 c0 6a	 add	 rax, 106		; 0000006aH
  00077	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG175584
  0007e	48 8b c8	 mov	 rcx, rax
  00081	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_release_lock

; 7542 : 
; 7543 :     return pLCSIBH;

  00087	48 8b 44 24 20	 mov	 rax, QWORD PTR pLCSIBH$[rsp]

; 7544 : }

  0008c	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00090	c3		 ret	 0
remove_lcs_buffer_from_chain ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\ctc_lcs.c
_TEXT	SEGMENT
pLCSDEV$ = 48
pLCSIBH$ = 56
add_lcs_buffer_to_chain PROC

; 7487 : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 7488 : 
; 7489 :     // Prepare LCSIBH for adding to chain.
; 7490 :     if (!pLCSIBH)                                      // Any LCSIBH been passed?

  0000e	48 83 7c 24 38
	00		 cmp	 QWORD PTR pLCSIBH$[rsp], 0
  00014	75 05		 jne	 SHORT $LN2@add_lcs_bu

; 7491 :         return;

  00016	e9 87 00 00 00	 jmp	 $LN1@add_lcs_bu
$LN2@add_lcs_bu:

; 7492 :     pLCSIBH->pNextLCSIBH = NULL;                       // Clear the pointer to next LCSIBH

  0001b	48 8b 44 24 38	 mov	 rax, QWORD PTR pLCSIBH$[rsp]
  00020	48 c7 00 00 00
	00 00		 mov	 QWORD PTR [rax], 0

; 7493 : 
; 7494 :     // Obtain the buffer chain lock.
; 7495 :     obtain_lock( &pLCSDEV->LCSIBHChainLock );

  00027	48 8b 44 24 30	 mov	 rax, QWORD PTR pLCSDEV$[rsp]
  0002c	48 83 c0 6a	 add	 rax, 106		; 0000006aH
  00030	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG175571
  00037	48 8b c8	 mov	 rcx, rax
  0003a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_obtain_lock

; 7496 : 
; 7497 :     // Add LCSIBH to end of chain.
; 7498 :     if (pLCSDEV->pFirstLCSIBH)                         // if there are already LCSIBHs

  00040	48 8b 44 24 30	 mov	 rax, QWORD PTR pLCSDEV$[rsp]
  00045	48 83 78 72 00	 cmp	 QWORD PTR [rax+114], 0
  0004a	74 21		 je	 SHORT $LN3@add_lcs_bu

; 7499 :     {
; 7500 :         pLCSDEV->pLastLCSIBH->pNextLCSIBH = pLCSIBH;   // Add the LCSIBH to

  0004c	48 8b 44 24 30	 mov	 rax, QWORD PTR pLCSDEV$[rsp]
  00051	48 8b 40 7a	 mov	 rax, QWORD PTR [rax+122]
  00055	48 8b 4c 24 38	 mov	 rcx, QWORD PTR pLCSIBH$[rsp]
  0005a	48 89 08	 mov	 QWORD PTR [rax], rcx

; 7501 :         pLCSDEV->pLastLCSIBH = pLCSIBH;                // the end of the chain

  0005d	48 8b 44 24 30	 mov	 rax, QWORD PTR pLCSDEV$[rsp]
  00062	48 8b 4c 24 38	 mov	 rcx, QWORD PTR pLCSIBH$[rsp]
  00067	48 89 48 7a	 mov	 QWORD PTR [rax+122], rcx

; 7502 :     }

  0006b	eb 1c		 jmp	 SHORT $LN4@add_lcs_bu
$LN3@add_lcs_bu:

; 7503 :     else
; 7504 :     {
; 7505 :         pLCSDEV->pFirstLCSIBH = pLCSIBH;               // Make the LCSIBH

  0006d	48 8b 44 24 30	 mov	 rax, QWORD PTR pLCSDEV$[rsp]
  00072	48 8b 4c 24 38	 mov	 rcx, QWORD PTR pLCSIBH$[rsp]
  00077	48 89 48 72	 mov	 QWORD PTR [rax+114], rcx

; 7506 :         pLCSDEV->pLastLCSIBH = pLCSIBH;                // the only LCSIBH

  0007b	48 8b 44 24 30	 mov	 rax, QWORD PTR pLCSDEV$[rsp]
  00080	48 8b 4c 24 38	 mov	 rcx, QWORD PTR pLCSIBH$[rsp]
  00085	48 89 48 7a	 mov	 QWORD PTR [rax+122], rcx
$LN4@add_lcs_bu:

; 7507 :     }
; 7508 : 
; 7509 :     // Release the buffer chain lock.
; 7510 :     release_lock( &pLCSDEV->LCSIBHChainLock );

  00089	48 8b 44 24 30	 mov	 rax, QWORD PTR pLCSDEV$[rsp]
  0008e	48 83 c0 6a	 add	 rax, 106		; 0000006aH
  00092	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG175574
  00099	48 8b c8	 mov	 rcx, rax
  0009c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_release_lock
$LN1@add_lcs_bu:

; 7511 : 
; 7512 :     return;
; 7513 : }

  000a2	48 83 c4 28	 add	 rsp, 40			; 00000028H
  000a6	c3		 ret	 0
add_lcs_buffer_to_chain ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\ctc_lcs.c
_TEXT	SEGMENT
iBufLen$ = 96
tv91 = 100
tv95 = 104
pDEVBLK$ = 112
pLCSIBH$ = 120
tv79 = 128
etext$ = 136
__$ArrayPad$ = 176
pLCSDEV$ = 208
iSize$ = 216
alloc_lcs_buffer PROC

; 7456 : {

  00000	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00004	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00009	48 81 ec c8 00
	00 00		 sub	 rsp, 200		; 000000c8H
  00010	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00017	48 33 c4	 xor	 rax, rsp
  0001a	48 89 84 24 b0
	00 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 7457 :     DEVBLK*    pDEVBLK;
; 7458 :     PLCSIBH    pLCSIBH;                // LCSIBH
; 7459 :     int        iBufLen;                // Buffer length
; 7460 :     char       etext[40];              // malloc error text
; 7461 : 
; 7462 : 
; 7463 :     // Allocate the buffer.
; 7464 :     iBufLen = sizeof(LCSIBH) + iSize;

  00022	48 63 84 24 d8
	00 00 00	 movsxd	 rax, DWORD PTR iSize$[rsp]
  0002a	48 83 c0 10	 add	 rax, 16
  0002e	89 44 24 60	 mov	 DWORD PTR iBufLen$[rsp], eax

; 7465 :     pLCSIBH = calloc( iBufLen, 1 );    // Allocate and clear the buffer

  00032	48 63 44 24 60	 movsxd	 rax, DWORD PTR iBufLen$[rsp]
  00037	ba 01 00 00 00	 mov	 edx, 1
  0003c	48 8b c8	 mov	 rcx, rax
  0003f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_calloc
  00045	48 89 44 24 78	 mov	 QWORD PTR pLCSIBH$[rsp], rax

; 7466 :     if (pLCSIBH)                       // if the allocate was successful...

  0004a	48 83 7c 24 78
	00		 cmp	 QWORD PTR pLCSIBH$[rsp], 0
  00050	74 14		 je	 SHORT $LN2@alloc_lcs_

; 7467 :     {
; 7468 :         pLCSIBH->iAreaLen = iSize;

  00052	48 8b 44 24 78	 mov	 rax, QWORD PTR pLCSIBH$[rsp]
  00057	8b 8c 24 d8 00
	00 00		 mov	 ecx, DWORD PTR iSize$[rsp]
  0005e	89 48 08	 mov	 DWORD PTR [rax+8], ecx

; 7469 :     }

  00061	e9 eb 00 00 00	 jmp	 $LN3@alloc_lcs_
$LN2@alloc_lcs_:

; 7470 :     else                               // ohdear, the allocate was not successful...
; 7471 :     {
; 7472 :         pDEVBLK = pLCSDEV->pDEVBLK[ LCS_READ_SUBCHANN ];

  00066	b8 08 00 00 00	 mov	 eax, 8
  0006b	48 6b c0 00	 imul	 rax, rax, 0
  0006f	48 8b 8c 24 d0
	00 00 00	 mov	 rcx, QWORD PTR pLCSDEV$[rsp]
  00077	48 8b 44 01 10	 mov	 rax, QWORD PTR [rcx+rax+16]
  0007c	48 89 44 24 70	 mov	 QWORD PTR pDEVBLK$[rsp], rax

; 7473 :         // Report the bad news.
; 7474 :         MSGBUF( etext, "malloc(%d)", iBufLen );

  00081	44 8b 4c 24 60	 mov	 r9d, DWORD PTR iBufLen$[rsp]
  00086	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG175559
  0008d	ba 28 00 00 00	 mov	 edx, 40			; 00000028H
  00092	48 8d 8c 24 88
	00 00 00	 lea	 rcx, QWORD PTR etext$[rsp]
  0009a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_snprintf

; 7475 :         // HHC00900 "%1d:%04X %s: error in function %s: %s"
; 7476 :         WRMSG(HHC00900, "E", SSID_TO_LCSS(pDEVBLK->ssid), pDEVBLK->devnum, pDEVBLK->typname,

  000a0	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno
  000a6	8b 08		 mov	 ecx, DWORD PTR [rax]
  000a8	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_strerror
  000ae	48 89 84 24 80
	00 00 00	 mov	 QWORD PTR tv79[rsp], rax
  000b6	48 8b 4c 24 70	 mov	 rcx, QWORD PTR pDEVBLK$[rsp]
  000bb	0f b7 49 48	 movzx	 ecx, WORD PTR [rcx+72]
  000bf	89 4c 24 64	 mov	 DWORD PTR tv91[rsp], ecx
  000c3	48 8b 54 24 70	 mov	 rdx, QWORD PTR pDEVBLK$[rsp]
  000c8	0f b7 52 44	 movzx	 edx, WORD PTR [rdx+68]
  000cc	d1 fa		 sar	 edx, 1
  000ce	89 54 24 68	 mov	 DWORD PTR tv95[rsp], edx
  000d2	b9 01 00 00 00	 mov	 ecx, 1
  000d7	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  000dd	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR tv79[rsp]
  000e5	48 89 4c 24 58	 mov	 QWORD PTR [rsp+88], rcx
  000ea	48 8d 8c 24 88
	00 00 00	 lea	 rcx, QWORD PTR etext$[rsp]
  000f2	48 89 4c 24 50	 mov	 QWORD PTR [rsp+80], rcx
  000f7	48 8b 4c 24 70	 mov	 rcx, QWORD PTR pDEVBLK$[rsp]
  000fc	48 8b 49 50	 mov	 rcx, QWORD PTR [rcx+80]
  00100	48 89 4c 24 48	 mov	 QWORD PTR [rsp+72], rcx
  00105	8b 4c 24 64	 mov	 ecx, DWORD PTR tv91[rsp]
  00109	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  0010d	8b 4c 24 68	 mov	 ecx, DWORD PTR tv95[rsp]
  00111	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  00115	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG175560
  0011c	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  00121	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG175561
  00128	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  0012d	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00132	41 b9 03 00 00
	00		 mov	 r9d, 3
  00138	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG175562
  0013f	ba 35 1d 00 00	 mov	 edx, 7477		; 00001d35H
  00144	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG175563
  0014b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg
$LN3@alloc_lcs_:

; 7477 :                              etext, strerror(errno) );
; 7478 :     }
; 7479 : 
; 7480 :     return pLCSIBH;

  00151	48 8b 44 24 78	 mov	 rax, QWORD PTR pLCSIBH$[rsp]

; 7481 : }

  00156	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  0015e	48 33 cc	 xor	 rcx, rsp
  00161	e8 00 00 00 00	 call	 __security_check_cookie
  00166	48 81 c4 c8 00
	00 00		 add	 rsp, 200		; 000000c8H
  0016d	c3		 ret	 0
alloc_lcs_buffer ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\ctc_lcs.c
_TEXT	SEGMENT
hwLenInBaf1$ = 32
pLCSIBH$ = 40
pInBAF1$ = 48
pInHDR$ = 56
pInBAF2$ = 64
pLCSDEV$ = 112
pOutHDR$ = 120
pOutBAF1$ = 128
pOutBAF2$ = 136
hwLenOutBaf1$ = 144
hwLenOutBaf2$ = 152
Process_0C98 PROC

; 5706 : {

  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	56		 push	 rsi
  00015	57		 push	 rdi
  00016	48 83 ec 58	 sub	 rsp, 88			; 00000058H
$LN4@Process_0C:

; 5707 : #define INBOUND_CC98_SIZE 32
; 5708 : static const BYTE Inbound_CC98[INBOUND_CC98_SIZE] =
; 5709 :                  {
; 5710 :                    0x00, 0x20, 0x04, 0x00,                           /* LCSHDR  */
; 5711 :                    0x00, 0x18, 0xCC, 0x98, 0x00, 0x03, 0xC0, 0x00,   /* LCSBAF1 */
; 5712 :                    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
; 5713 :                    0x00, 0x00, 0x70, 0x00, 0x00, 0x00, 0x00, 0x00,
; 5714 :                    0x01, 0xff, 0xff,                                 /* LCSBAF2 */
; 5715 :                    0x00                                              /* Filler  */
; 5716 :                  };
; 5717 : 
; 5718 :     PLCSIBH     pLCSIBH;
; 5719 :     PLCSHDR     pInHDR;
; 5720 :     PLCSBAF1    pInBAF1;
; 5721 :     PLCSBAF2    pInBAF2;
; 5722 :     U16         hwLenInBaf1;
; 5723 : //  U16         hwLenInBaf2;
; 5724 : 
; 5725 :     UNREFERENCED( pOutHDR      );

  0001a	33 c0		 xor	 eax, eax
  0001c	85 c0		 test	 eax, eax
  0001e	75 fa		 jne	 SHORT $LN4@Process_0C
$LN7@Process_0C:

; 5726 :     UNREFERENCED( pOutBAF1     );

  00020	33 c0		 xor	 eax, eax
  00022	85 c0		 test	 eax, eax
  00024	75 fa		 jne	 SHORT $LN7@Process_0C
$LN10@Process_0C:

; 5727 :     UNREFERENCED( hwLenOutBaf1 );

  00026	33 c0		 xor	 eax, eax
  00028	85 c0		 test	 eax, eax
  0002a	75 fa		 jne	 SHORT $LN10@Process_0C
$LN13@Process_0C:

; 5728 :     UNREFERENCED( hwLenOutBaf2 );

  0002c	33 c0		 xor	 eax, eax
  0002e	85 c0		 test	 eax, eax
  00030	75 fa		 jne	 SHORT $LN13@Process_0C

; 5729 : 
; 5730 :     pLCSIBH = alloc_lcs_buffer( pLCSDEV, ( INBOUND_CC98_SIZE * 2 ) );

  00032	ba 40 00 00 00	 mov	 edx, 64			; 00000040H
  00037	48 8b 4c 24 70	 mov	 rcx, QWORD PTR pLCSDEV$[rsp]
  0003c	e8 00 00 00 00	 call	 alloc_lcs_buffer
  00041	48 89 44 24 28	 mov	 QWORD PTR pLCSIBH$[rsp], rax

; 5731 : 
; 5732 :     memcpy( &pLCSIBH->bData, Inbound_CC98, INBOUND_CC98_SIZE );

  00046	48 8b 44 24 28	 mov	 rax, QWORD PTR pLCSIBH$[rsp]
  0004b	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:?Inbound_CC98@?1??Process_0C98@@9@9
  00052	48 8d 78 10	 lea	 rdi, QWORD PTR [rax+16]
  00056	48 8b f1	 mov	 rsi, rcx
  00059	b9 20 00 00 00	 mov	 ecx, 32			; 00000020H
  0005e	f3 a4		 rep movsb

; 5733 :     pLCSIBH->iDataLen = INBOUND_CC98_SIZE;

  00060	48 8b 44 24 28	 mov	 rax, QWORD PTR pLCSIBH$[rsp]
  00065	c7 40 0c 20 00
	00 00		 mov	 DWORD PTR [rax+12], 32	; 00000020H

; 5734 : 
; 5735 :     pInHDR = (PLCSHDR)&pLCSIBH->bData;

  0006c	48 8b 44 24 28	 mov	 rax, QWORD PTR pLCSIBH$[rsp]
  00071	48 83 c0 10	 add	 rax, 16
  00075	48 89 44 24 38	 mov	 QWORD PTR pInHDR$[rsp], rax

; 5736 :     pInBAF1 = (PLCSBAF1)( (BYTE*)pInHDR + sizeof(LCSHDR) );

  0007a	48 8b 44 24 38	 mov	 rax, QWORD PTR pInHDR$[rsp]
  0007f	48 83 c0 04	 add	 rax, 4
  00083	48 89 44 24 30	 mov	 QWORD PTR pInBAF1$[rsp], rax

; 5737 :     FETCH_HW( hwLenInBaf1, pInBAF1->hwLenBaf1 );

  00088	48 8b 44 24 30	 mov	 rax, QWORD PTR pInBAF1$[rsp]
  0008d	48 8b c8	 mov	 rcx, rax
  00090	e8 00 00 00 00	 call	 fetch_hw_noswap
  00095	0f b7 c8	 movzx	 ecx, ax
  00098	e8 00 00 00 00	 call	 _byteswap_ushort
  0009d	66 89 44 24 20	 mov	 WORD PTR hwLenInBaf1$[rsp], ax

; 5738 : //  FETCH_HW( hwLenInBaf2, pInBAF1->hwLenBaf2 );
; 5739 :     pInBAF2 = (PLCSBAF2)( (BYTE*)pInBAF1 + hwLenInBaf1 );

  000a2	0f b7 44 24 20	 movzx	 eax, WORD PTR hwLenInBaf1$[rsp]
  000a7	48 8b 4c 24 30	 mov	 rcx, QWORD PTR pInBAF1$[rsp]
  000ac	48 03 c8	 add	 rcx, rax
  000af	48 8b c1	 mov	 rax, rcx
  000b2	48 89 44 24 40	 mov	 QWORD PTR pInBAF2$[rsp], rax

; 5740 : 
; 5741 :     memcpy( &pInBAF2->hwSeqNum, &pOutBAF2->hwSeqNum, sizeof(pInBAF2->hwSeqNum) );

  000b7	48 8b 44 24 40	 mov	 rax, QWORD PTR pInBAF2$[rsp]
  000bc	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR pOutBAF2$[rsp]
  000c4	0f b7 49 01	 movzx	 ecx, WORD PTR [rcx+1]
  000c8	66 89 48 01	 mov	 WORD PTR [rax+1], cx

; 5742 : 
; 5743 :     add_lcs_buffer_to_chain( pLCSDEV, pLCSIBH );

  000cc	48 8b 54 24 28	 mov	 rdx, QWORD PTR pLCSIBH$[rsp]
  000d1	48 8b 4c 24 70	 mov	 rcx, QWORD PTR pLCSDEV$[rsp]
  000d6	e8 00 00 00 00	 call	 add_lcs_buffer_to_chain

; 5744 : 
; 5745 :     return;
; 5746 : }

  000db	48 83 c4 58	 add	 rsp, 88			; 00000058H
  000df	5f		 pop	 rdi
  000e0	5e		 pop	 rsi
  000e1	c3		 ret	 0
Process_0C98 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\ctc_lcs.c
_TEXT	SEGMENT
hwLenInBaf1$ = 32
pLCSIBH$ = 40
pInBAF1$ = 48
pInHDR$ = 56
pInBAF2$ = 64
pLCSDEV$ = 112
pOutHDR$ = 120
pOutBAF1$ = 128
pOutBAF2$ = 136
hwLenOutBaf1$ = 144
hwLenOutBaf2$ = 152
Process_0C0E PROC

; 5652 : {

  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	56		 push	 rsi
  00015	57		 push	 rdi
  00016	48 83 ec 58	 sub	 rsp, 88			; 00000058H
$LN4@Process_0C:

; 5653 : #define INBOUND_CC0E_SIZE 32
; 5654 : static const BYTE Inbound_CC0E[INBOUND_CC0E_SIZE] =
; 5655 :                  {
; 5656 :                    0x00, 0x20, 0x04, 0x00,                           /* LCSHDR  */
; 5657 :                    0x00, 0x18, 0xCC, 0x0E, 0x00, 0x03, 0x60, 0x03,   /* LCSBAF1 */
; 5658 :                    0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00,
; 5659 :                    0x00, 0x00, 0x70, 0x00, 0x00, 0x00, 0x00, 0x00,
; 5660 :                    0x01, 0xff, 0xff,                                 /* LCSBAF2 */
; 5661 :                    0x00,                                             /* Filler  */
; 5662 :                  };
; 5663 : 
; 5664 :     PLCSIBH     pLCSIBH;
; 5665 :     PLCSHDR     pInHDR;
; 5666 :     PLCSBAF1    pInBAF1;
; 5667 :     PLCSBAF2    pInBAF2;
; 5668 :     U16         hwLenInBaf1;
; 5669 : //  U16         hwLenInBaf2;
; 5670 : 
; 5671 :     UNREFERENCED( pOutHDR      );

  0001a	33 c0		 xor	 eax, eax
  0001c	85 c0		 test	 eax, eax
  0001e	75 fa		 jne	 SHORT $LN4@Process_0C
$LN7@Process_0C:

; 5672 :     UNREFERENCED( pOutBAF1     );

  00020	33 c0		 xor	 eax, eax
  00022	85 c0		 test	 eax, eax
  00024	75 fa		 jne	 SHORT $LN7@Process_0C
$LN10@Process_0C:

; 5673 :     UNREFERENCED( hwLenOutBaf1 );

  00026	33 c0		 xor	 eax, eax
  00028	85 c0		 test	 eax, eax
  0002a	75 fa		 jne	 SHORT $LN10@Process_0C
$LN13@Process_0C:

; 5674 :     UNREFERENCED( hwLenOutBaf2 );

  0002c	33 c0		 xor	 eax, eax
  0002e	85 c0		 test	 eax, eax
  00030	75 fa		 jne	 SHORT $LN13@Process_0C

; 5675 : 
; 5676 :     pLCSIBH = alloc_lcs_buffer( pLCSDEV, ( INBOUND_CC0E_SIZE * 2 ) );

  00032	ba 40 00 00 00	 mov	 edx, 64			; 00000040H
  00037	48 8b 4c 24 70	 mov	 rcx, QWORD PTR pLCSDEV$[rsp]
  0003c	e8 00 00 00 00	 call	 alloc_lcs_buffer
  00041	48 89 44 24 28	 mov	 QWORD PTR pLCSIBH$[rsp], rax

; 5677 : 
; 5678 :     memcpy( &pLCSIBH->bData, Inbound_CC0E, INBOUND_CC0E_SIZE );

  00046	48 8b 44 24 28	 mov	 rax, QWORD PTR pLCSIBH$[rsp]
  0004b	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:?Inbound_CC0E@?1??Process_0C0E@@9@9
  00052	48 8d 78 10	 lea	 rdi, QWORD PTR [rax+16]
  00056	48 8b f1	 mov	 rsi, rcx
  00059	b9 20 00 00 00	 mov	 ecx, 32			; 00000020H
  0005e	f3 a4		 rep movsb

; 5679 :     pLCSIBH->iDataLen = INBOUND_CC0E_SIZE;

  00060	48 8b 44 24 28	 mov	 rax, QWORD PTR pLCSIBH$[rsp]
  00065	c7 40 0c 20 00
	00 00		 mov	 DWORD PTR [rax+12], 32	; 00000020H

; 5680 : 
; 5681 :     pInHDR = (PLCSHDR)&pLCSIBH->bData;

  0006c	48 8b 44 24 28	 mov	 rax, QWORD PTR pLCSIBH$[rsp]
  00071	48 83 c0 10	 add	 rax, 16
  00075	48 89 44 24 38	 mov	 QWORD PTR pInHDR$[rsp], rax

; 5682 :     pInBAF1 = (PLCSBAF1)( (BYTE*)pInHDR + sizeof(LCSHDR) );

  0007a	48 8b 44 24 38	 mov	 rax, QWORD PTR pInHDR$[rsp]
  0007f	48 83 c0 04	 add	 rax, 4
  00083	48 89 44 24 30	 mov	 QWORD PTR pInBAF1$[rsp], rax

; 5683 :     FETCH_HW( hwLenInBaf1, pInBAF1->hwLenBaf1 );

  00088	48 8b 44 24 30	 mov	 rax, QWORD PTR pInBAF1$[rsp]
  0008d	48 8b c8	 mov	 rcx, rax
  00090	e8 00 00 00 00	 call	 fetch_hw_noswap
  00095	0f b7 c8	 movzx	 ecx, ax
  00098	e8 00 00 00 00	 call	 _byteswap_ushort
  0009d	66 89 44 24 20	 mov	 WORD PTR hwLenInBaf1$[rsp], ax

; 5684 : //  FETCH_HW( hwLenInBaf2, pInBAF1->hwLenBaf2 );
; 5685 :     pInBAF2 = (PLCSBAF2)( (BYTE*)pInBAF1 + hwLenInBaf1 );

  000a2	0f b7 44 24 20	 movzx	 eax, WORD PTR hwLenInBaf1$[rsp]
  000a7	48 8b 4c 24 30	 mov	 rcx, QWORD PTR pInBAF1$[rsp]
  000ac	48 03 c8	 add	 rcx, rax
  000af	48 8b c1	 mov	 rax, rcx
  000b2	48 89 44 24 40	 mov	 QWORD PTR pInBAF2$[rsp], rax

; 5686 : 
; 5687 :     memcpy( &pInBAF2->hwSeqNum, &pOutBAF2->hwSeqNum, sizeof(pInBAF2->hwSeqNum) );

  000b7	48 8b 44 24 40	 mov	 rax, QWORD PTR pInBAF2$[rsp]
  000bc	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR pOutBAF2$[rsp]
  000c4	0f b7 49 01	 movzx	 ecx, WORD PTR [rcx+1]
  000c8	66 89 48 01	 mov	 WORD PTR [rax+1], cx

; 5688 : 
; 5689 :     add_lcs_buffer_to_chain( pLCSDEV, pLCSIBH );

  000cc	48 8b 54 24 28	 mov	 rdx, QWORD PTR pLCSIBH$[rsp]
  000d1	48 8b 4c 24 70	 mov	 rcx, QWORD PTR pLCSDEV$[rsp]
  000d6	e8 00 00 00 00	 call	 add_lcs_buffer_to_chain

; 5690 : 
; 5691 :     return;
; 5692 : }

  000db	48 83 c4 58	 add	 rsp, 88			; 00000058H
  000df	5f		 pop	 rdi
  000e0	5e		 pop	 rsi
  000e1	c3		 ret	 0
Process_0C0E ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\ctc_lcs.c
_TEXT	SEGMENT
hwLenInBaf1$ = 32
pLCSIBH$ = 40
pInBAF1$ = 48
pInHDR$ = 56
pInBAF2$ = 64
pLCSDEV$ = 112
pOutHDR$ = 120
pOutBAF1$ = 128
pOutBAF2$ = 136
hwLenOutBaf1$ = 144
hwLenOutBaf2$ = 152
Process_0C0D PROC

; 5595 : {

  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	56		 push	 rsi
  00015	57		 push	 rdi
  00016	48 83 ec 58	 sub	 rsp, 88			; 00000058H
$LN4@Process_0C:

; 5596 : #define INBOUND_CC0D_SIZE 56
; 5597 : static const BYTE Inbound_CC0D[INBOUND_CC0D_SIZE] =
; 5598 :                  {
; 5599 :                    0x00, 0x38, 0x04, 0x00,                           /* LCSHDR  */
; 5600 :                    0x00, 0x2C, 0xCC, 0x0D, 0x00, 0x07, 0x60, 0x03,   /* LCSBAF1 */
; 5601 :                    0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00,
; 5602 :                    0x00, 0x00, 0x70, 0x00, 0x00, 0x00, 0x00, 0x00,
; 5603 :                    0x40, 0x00, 0x00, 0xDC, 0x00, 0x00, 0x00, 0x00,
; 5604 :                    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
; 5605 :                    0x00, 0x00, 0x00, 0x00,
; 5606 :                    0x01, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00,         /* LCSBAF2 */
; 5607 :                    0x00                                              /* Filler  */
; 5608 :                  };
; 5609 : 
; 5610 :     PLCSIBH     pLCSIBH;
; 5611 :     PLCSHDR     pInHDR;
; 5612 :     PLCSBAF1    pInBAF1;
; 5613 :     PLCSBAF2    pInBAF2;
; 5614 :     U16         hwLenInBaf1;
; 5615 : //  U16         hwLenInBaf2;
; 5616 : 
; 5617 :     UNREFERENCED( pOutHDR      );

  0001a	33 c0		 xor	 eax, eax
  0001c	85 c0		 test	 eax, eax
  0001e	75 fa		 jne	 SHORT $LN4@Process_0C
$LN7@Process_0C:

; 5618 :     UNREFERENCED( pOutBAF1     );

  00020	33 c0		 xor	 eax, eax
  00022	85 c0		 test	 eax, eax
  00024	75 fa		 jne	 SHORT $LN7@Process_0C
$LN10@Process_0C:

; 5619 :     UNREFERENCED( hwLenOutBaf1 );

  00026	33 c0		 xor	 eax, eax
  00028	85 c0		 test	 eax, eax
  0002a	75 fa		 jne	 SHORT $LN10@Process_0C
$LN13@Process_0C:

; 5620 :     UNREFERENCED( hwLenOutBaf2 );

  0002c	33 c0		 xor	 eax, eax
  0002e	85 c0		 test	 eax, eax
  00030	75 fa		 jne	 SHORT $LN13@Process_0C

; 5621 : 
; 5622 :     pLCSIBH = alloc_lcs_buffer( pLCSDEV, ( INBOUND_CC0D_SIZE * 2 ) );

  00032	ba 70 00 00 00	 mov	 edx, 112		; 00000070H
  00037	48 8b 4c 24 70	 mov	 rcx, QWORD PTR pLCSDEV$[rsp]
  0003c	e8 00 00 00 00	 call	 alloc_lcs_buffer
  00041	48 89 44 24 28	 mov	 QWORD PTR pLCSIBH$[rsp], rax

; 5623 : 
; 5624 :     memcpy( &pLCSIBH->bData, Inbound_CC0D, INBOUND_CC0D_SIZE );

  00046	48 8b 44 24 28	 mov	 rax, QWORD PTR pLCSIBH$[rsp]
  0004b	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:?Inbound_CC0D@?1??Process_0C0D@@9@9
  00052	48 8d 78 10	 lea	 rdi, QWORD PTR [rax+16]
  00056	48 8b f1	 mov	 rsi, rcx
  00059	b9 38 00 00 00	 mov	 ecx, 56			; 00000038H
  0005e	f3 a4		 rep movsb

; 5625 :     pLCSIBH->iDataLen = INBOUND_CC0D_SIZE;

  00060	48 8b 44 24 28	 mov	 rax, QWORD PTR pLCSIBH$[rsp]
  00065	c7 40 0c 38 00
	00 00		 mov	 DWORD PTR [rax+12], 56	; 00000038H

; 5626 : 
; 5627 :     pInHDR = (PLCSHDR)&pLCSIBH->bData;

  0006c	48 8b 44 24 28	 mov	 rax, QWORD PTR pLCSIBH$[rsp]
  00071	48 83 c0 10	 add	 rax, 16
  00075	48 89 44 24 38	 mov	 QWORD PTR pInHDR$[rsp], rax

; 5628 :     pInBAF1 = (PLCSBAF1)( (BYTE*)pInHDR + sizeof(LCSHDR) );

  0007a	48 8b 44 24 38	 mov	 rax, QWORD PTR pInHDR$[rsp]
  0007f	48 83 c0 04	 add	 rax, 4
  00083	48 89 44 24 30	 mov	 QWORD PTR pInBAF1$[rsp], rax

; 5629 :     FETCH_HW( hwLenInBaf1, pInBAF1->hwLenBaf1 );

  00088	48 8b 44 24 30	 mov	 rax, QWORD PTR pInBAF1$[rsp]
  0008d	48 8b c8	 mov	 rcx, rax
  00090	e8 00 00 00 00	 call	 fetch_hw_noswap
  00095	0f b7 c8	 movzx	 ecx, ax
  00098	e8 00 00 00 00	 call	 _byteswap_ushort
  0009d	66 89 44 24 20	 mov	 WORD PTR hwLenInBaf1$[rsp], ax

; 5630 : //  FETCH_HW( hwLenInBaf2, pInBAF1->hwLenBaf2 );
; 5631 :     pInBAF2 = (PLCSBAF2)( (BYTE*)pInBAF1 + hwLenInBaf1 );

  000a2	0f b7 44 24 20	 movzx	 eax, WORD PTR hwLenInBaf1$[rsp]
  000a7	48 8b 4c 24 30	 mov	 rcx, QWORD PTR pInBAF1$[rsp]
  000ac	48 03 c8	 add	 rcx, rax
  000af	48 8b c1	 mov	 rax, rcx
  000b2	48 89 44 24 40	 mov	 QWORD PTR pInBAF2$[rsp], rax

; 5632 : 
; 5633 :     memcpy( &pInBAF2->hwSeqNum, &pOutBAF2->hwSeqNum, sizeof(pInBAF2->hwSeqNum) );

  000b7	48 8b 44 24 40	 mov	 rax, QWORD PTR pInBAF2$[rsp]
  000bc	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR pOutBAF2$[rsp]
  000c4	0f b7 49 01	 movzx	 ecx, WORD PTR [rcx+1]
  000c8	66 89 48 01	 mov	 WORD PTR [rax+1], cx

; 5634 : 
; 5635 :     add_lcs_buffer_to_chain( pLCSDEV, pLCSIBH );

  000cc	48 8b 54 24 28	 mov	 rdx, QWORD PTR pLCSIBH$[rsp]
  000d1	48 8b 4c 24 70	 mov	 rcx, QWORD PTR pLCSDEV$[rsp]
  000d6	e8 00 00 00 00	 call	 add_lcs_buffer_to_chain

; 5636 : 
; 5637 :     return;
; 5638 : }

  000db	48 83 c4 58	 add	 rsp, 88			; 00000058H
  000df	5f		 pop	 rdi
  000e0	5e		 pop	 rsi
  000e1	c3		 ret	 0
Process_0C0D ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\ctc_lcs.c
_TEXT	SEGMENT
hwLenInBaf1$ = 32
pLCSIBH$ = 40
pInBAF1$ = 48
pInBAF2$ = 56
pLCSBLK$ = 64
pInHDR$ = 72
pInMAC$ = 80
pLCSPORT$ = 88
pLCSDEV$ = 128
pOutHDR$ = 136
pOutBAF1$ = 144
pOutBAF2$ = 152
hwLenOutBaf1$ = 160
hwLenOutBaf2$ = 168
Process_0C99 PROC

; 5527 : {

  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	56		 push	 rsi
  00015	57		 push	 rdi
  00016	48 83 ec 68	 sub	 rsp, 104		; 00000068H
$LN4@Process_0C:

; 5528 : #define INBOUND_CC99_SIZE 50
; 5529 : static const BYTE Inbound_CC99[INBOUND_CC99_SIZE] =
; 5530 :                  {
; 5531 :                    0x00, 0x32, 0x04, 0x00,                           /* LCSHDR  */
; 5532 :                    0x00, 0x18, 0xCC, 0x99, 0x00, 0x15, 0xC0, 0x00,   /* LCSBAF1 */
; 5533 :                    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
; 5534 :                    0x00, 0x00, 0x20, 0x1E, 0x00, 0x00, 0x00, 0x00,
; 5535 :                    0x01, 0xff, 0xff, 0x00, 0x00, 0x03, 0x00, 0x00,   /* LCSBAF2 */
; 5536 :                    0x06, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x00,
; 5537 :                    0x00, 0x05, 0xD5, 0x00, 0x00,                                   /* 0x5D5 = 1493 */
; 5538 :                    0x00                                              /* Filler  */
; 5539 :                  };
; 5540 : 
; 5541 :     PLCSBLK     pLCSBLK;
; 5542 :     PLCSPORT    pLCSPORT;
; 5543 :     PLCSIBH     pLCSIBH;
; 5544 :     PLCSHDR     pInHDR;
; 5545 :     PLCSBAF1    pInBAF1;
; 5546 :     PLCSBAF2    pInBAF2;
; 5547 :     U16         hwLenInBaf1;
; 5548 : //  U16         hwLenInBaf2;
; 5549 :     BYTE*       pInMAC;
; 5550 : 
; 5551 :     UNREFERENCED( pOutHDR      );

  0001a	33 c0		 xor	 eax, eax
  0001c	85 c0		 test	 eax, eax
  0001e	75 fa		 jne	 SHORT $LN4@Process_0C
$LN7@Process_0C:

; 5552 :     UNREFERENCED( pOutBAF1     );

  00020	33 c0		 xor	 eax, eax
  00022	85 c0		 test	 eax, eax
  00024	75 fa		 jne	 SHORT $LN7@Process_0C
$LN10@Process_0C:

; 5553 :     UNREFERENCED( hwLenOutBaf1 );

  00026	33 c0		 xor	 eax, eax
  00028	85 c0		 test	 eax, eax
  0002a	75 fa		 jne	 SHORT $LN10@Process_0C
$LN13@Process_0C:

; 5554 :     UNREFERENCED( hwLenOutBaf2 );

  0002c	33 c0		 xor	 eax, eax
  0002e	85 c0		 test	 eax, eax
  00030	75 fa		 jne	 SHORT $LN13@Process_0C

; 5555 : 
; 5556 :     pLCSBLK = pLCSDEV->pLCSBLK;

  00032	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR pLCSDEV$[rsp]
  0003a	48 8b 40 08	 mov	 rax, QWORD PTR [rax+8]
  0003e	48 89 44 24 40	 mov	 QWORD PTR pLCSBLK$[rsp], rax

; 5557 :     pLCSPORT = &pLCSBLK->Port[ pLCSDEV->bPort ];

  00043	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR pLCSDEV$[rsp]
  0004b	0f b6 40 23	 movzx	 eax, BYTE PTR [rax+35]
  0004f	48 69 c0 98 01
	00 00		 imul	 rax, rax, 408		; 00000198H
  00056	48 8b 4c 24 40	 mov	 rcx, QWORD PTR pLCSBLK$[rsp]
  0005b	48 8d 44 01 60	 lea	 rax, QWORD PTR [rcx+rax+96]
  00060	48 89 44 24 58	 mov	 QWORD PTR pLCSPORT$[rsp], rax

; 5558 : 
; 5559 :     pLCSIBH = alloc_lcs_buffer( pLCSDEV, ( INBOUND_CC99_SIZE * 2 ) );

  00065	ba 64 00 00 00	 mov	 edx, 100		; 00000064H
  0006a	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR pLCSDEV$[rsp]
  00072	e8 00 00 00 00	 call	 alloc_lcs_buffer
  00077	48 89 44 24 28	 mov	 QWORD PTR pLCSIBH$[rsp], rax

; 5560 : 
; 5561 :     memcpy( &pLCSIBH->bData, Inbound_CC99, INBOUND_CC99_SIZE );

  0007c	48 8b 44 24 28	 mov	 rax, QWORD PTR pLCSIBH$[rsp]
  00081	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:?Inbound_CC99@?1??Process_0C99@@9@9
  00088	48 8d 78 10	 lea	 rdi, QWORD PTR [rax+16]
  0008c	48 8b f1	 mov	 rsi, rcx
  0008f	b9 32 00 00 00	 mov	 ecx, 50			; 00000032H
  00094	f3 a4		 rep movsb

; 5562 :     pLCSIBH->iDataLen = INBOUND_CC99_SIZE;

  00096	48 8b 44 24 28	 mov	 rax, QWORD PTR pLCSIBH$[rsp]
  0009b	c7 40 0c 32 00
	00 00		 mov	 DWORD PTR [rax+12], 50	; 00000032H

; 5563 : 
; 5564 :     pInHDR = (PLCSHDR)&pLCSIBH->bData;

  000a2	48 8b 44 24 28	 mov	 rax, QWORD PTR pLCSIBH$[rsp]
  000a7	48 83 c0 10	 add	 rax, 16
  000ab	48 89 44 24 48	 mov	 QWORD PTR pInHDR$[rsp], rax

; 5565 :     pInBAF1 = (PLCSBAF1)( (BYTE*)pInHDR + sizeof(LCSHDR) );

  000b0	48 8b 44 24 48	 mov	 rax, QWORD PTR pInHDR$[rsp]
  000b5	48 83 c0 04	 add	 rax, 4
  000b9	48 89 44 24 30	 mov	 QWORD PTR pInBAF1$[rsp], rax

; 5566 :     FETCH_HW( hwLenInBaf1, pInBAF1->hwLenBaf1 );

  000be	48 8b 44 24 30	 mov	 rax, QWORD PTR pInBAF1$[rsp]
  000c3	48 8b c8	 mov	 rcx, rax
  000c6	e8 00 00 00 00	 call	 fetch_hw_noswap
  000cb	0f b7 c8	 movzx	 ecx, ax
  000ce	e8 00 00 00 00	 call	 _byteswap_ushort
  000d3	66 89 44 24 20	 mov	 WORD PTR hwLenInBaf1$[rsp], ax

; 5567 : //  FETCH_HW( hwLenInBaf2, pInBAF1->hwLenBaf2 );
; 5568 :     pInBAF2 = (PLCSBAF2)( (BYTE*)pInBAF1 + hwLenInBaf1 );

  000d8	0f b7 44 24 20	 movzx	 eax, WORD PTR hwLenInBaf1$[rsp]
  000dd	48 8b 4c 24 30	 mov	 rcx, QWORD PTR pInBAF1$[rsp]
  000e2	48 03 c8	 add	 rcx, rax
  000e5	48 8b c1	 mov	 rax, rcx
  000e8	48 89 44 24 38	 mov	 QWORD PTR pInBAF2$[rsp], rax

; 5569 : 
; 5570 :     memcpy( &pInBAF2->hwSeqNum, &pOutBAF2->hwSeqNum, sizeof(pInBAF2->hwSeqNum) );

  000ed	48 8b 44 24 38	 mov	 rax, QWORD PTR pInBAF2$[rsp]
  000f2	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR pOutBAF2$[rsp]
  000fa	0f b7 49 01	 movzx	 ecx, WORD PTR [rcx+1]
  000fe	66 89 48 01	 mov	 WORD PTR [rax+1], cx

; 5571 : 
; 5572 :     pInMAC = (BYTE*)pInBAF2;

  00102	48 8b 44 24 38	 mov	 rax, QWORD PTR pInBAF2$[rsp]
  00107	48 89 44 24 50	 mov	 QWORD PTR pInMAC$[rsp], rax

; 5573 :     memcpy( pInMAC+9, pLCSPORT->MAC_Address, IFHWADDRLEN );

  0010c	48 8b 44 24 50	 mov	 rax, QWORD PTR pInMAC$[rsp]
  00111	48 8b 4c 24 58	 mov	 rcx, QWORD PTR pLCSPORT$[rsp]
  00116	48 8d 78 09	 lea	 rdi, QWORD PTR [rax+9]
  0011a	48 8d 71 02	 lea	 rsi, QWORD PTR [rcx+2]
  0011e	b9 06 00 00 00	 mov	 ecx, 6
  00123	f3 a4		 rep movsb

; 5574 : #if !defined( OPTION_TUNTAP_LCS_SAME_ADDR )
; 5575 :     pInMAC[9+5]++;
; 5576 : #endif
; 5577 : 
; 5578 :     add_lcs_buffer_to_chain( pLCSDEV, pLCSIBH );

  00125	48 8b 54 24 28	 mov	 rdx, QWORD PTR pLCSIBH$[rsp]
  0012a	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR pLCSDEV$[rsp]
  00132	e8 00 00 00 00	 call	 add_lcs_buffer_to_chain

; 5579 : 
; 5580 :     return;
; 5581 : }

  00137	48 83 c4 68	 add	 rsp, 104		; 00000068H
  0013b	5f		 pop	 rdi
  0013c	5e		 pop	 rsi
  0013d	c3		 ret	 0
Process_0C99 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\ctc_lcs.c
_TEXT	SEGMENT
hwLenInBaf1$ = 64
pLCSCONN$ = 72
pLCSIBH$ = 80
pInBAF1$ = 88
pInHDR$ = 96
pInBAF2$ = 104
pLCSDEV$ = 144
pOutHDR$ = 152
pOutBAF1$ = 160
pOutBAF2$ = 168
hwLenOutBaf1$ = 176
hwLenOutBaf2$ = 184
Process_0C0B PROC

; 5438 : {

  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	56		 push	 rsi
  00015	57		 push	 rdi
  00016	48 83 ec 78	 sub	 rsp, 120		; 00000078H
$LN4@Process_0C:

; 5439 : //                   Token
; 5440 : //  00110C0B00076002 40000240 0000000000
; 5441 : //  0 1 2 3 4 5 6 7  8 9 A B  C
; 5442 : //
; 5443 : //  01000900000000
; 5444 : //  0 1 2 3 4 5 6
; 5445 : 
; 5446 : #define INBOUND_CC0B_SIZE 32
; 5447 : static const BYTE Inbound_CC0B[INBOUND_CC0B_SIZE] =
; 5448 :                  {
; 5449 :                    0x00, 0x20, 0x04, 0x00,                           /* LCSHDR  */
; 5450 :                    0x00, 0x18, 0xCC, 0x0B, 0x00, 0x03, 0x60, 0x01,   /* LCSBAF1 */
; 5451 :                    0xff, 0xff, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00,
; 5452 :                    0x00, 0x00, 0x70, 0x00, 0x00, 0x00, 0x00, 0x00,
; 5453 :                    0x01, 0xff, 0xff,                                 /* LCSBAF2 */
; 5454 :                    0x00                                              /* Filler  */
; 5455 :                  };
; 5456 : 
; 5457 :     PLCSCONN    pLCSCONN;
; 5458 :     PLCSIBH     pLCSIBH;
; 5459 :     PLCSHDR     pInHDR;
; 5460 :     PLCSBAF1    pInBAF1;
; 5461 :     PLCSBAF2    pInBAF2;
; 5462 :     U16         hwLenInBaf1;
; 5463 : //  U16         hwLenInBaf2;
; 5464 : 
; 5465 :     UNREFERENCED( pOutHDR      );

  0001a	33 c0		 xor	 eax, eax
  0001c	85 c0		 test	 eax, eax
  0001e	75 fa		 jne	 SHORT $LN4@Process_0C
$LN7@Process_0C:

; 5466 :     UNREFERENCED( pOutBAF1     );

  00020	33 c0		 xor	 eax, eax
  00022	85 c0		 test	 eax, eax
  00024	75 fa		 jne	 SHORT $LN7@Process_0C
$LN10@Process_0C:

; 5467 :     UNREFERENCED( hwLenOutBaf1 );

  00026	33 c0		 xor	 eax, eax
  00028	85 c0		 test	 eax, eax
  0002a	75 fa		 jne	 SHORT $LN10@Process_0C
$LN13@Process_0C:

; 5468 :     UNREFERENCED( hwLenOutBaf2 );

  0002c	33 c0		 xor	 eax, eax
  0002e	85 c0		 test	 eax, eax
  00030	75 fa		 jne	 SHORT $LN13@Process_0C

; 5469 : 
; 5470 :     // Find the connection block.
; 5471 :     // I wish I knew what bByte07 == 0x02 or 0x04 actually meant!
; 5472 :     if (pOutBAF1->bByte07 == 0x02)

  00032	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR pOutBAF1$[rsp]
  0003a	0f b6 40 07	 movzx	 eax, BYTE PTR [rax+7]
  0003e	83 f8 02	 cmp	 eax, 2
  00041	75 23		 jne	 SHORT $LN14@Process_0C

; 5473 :     {
; 5474 :         pLCSCONN = find_connection_by_outbound_token( pLCSDEV, pOutBAF1->bTokenA );

  00043	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR pOutBAF1$[rsp]
  0004b	48 83 c0 08	 add	 rax, 8
  0004f	48 8b d0	 mov	 rdx, rax
  00052	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR pLCSDEV$[rsp]
  0005a	e8 00 00 00 00	 call	 find_connection_by_outbound_token
  0005f	48 89 44 24 48	 mov	 QWORD PTR pLCSCONN$[rsp], rax

; 5475 :     }

  00064	eb 3d		 jmp	 SHORT $LN15@Process_0C
$LN14@Process_0C:

; 5476 :     else if (pOutBAF1->bByte07 == 0x04)

  00066	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR pOutBAF1$[rsp]
  0006e	0f b6 40 07	 movzx	 eax, BYTE PTR [rax+7]
  00072	83 f8 04	 cmp	 eax, 4
  00075	75 23		 jne	 SHORT $LN16@Process_0C

; 5477 :     {
; 5478 :         pLCSCONN = find_connection_by_inbound_token( pLCSDEV, pOutBAF1->bTokenB );

  00077	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR pOutBAF1$[rsp]
  0007f	48 83 c0 0c	 add	 rax, 12
  00083	48 8b d0	 mov	 rdx, rax
  00086	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR pLCSDEV$[rsp]
  0008e	e8 00 00 00 00	 call	 find_connection_by_inbound_token
  00093	48 89 44 24 48	 mov	 QWORD PTR pLCSCONN$[rsp], rax

; 5479 :     }

  00098	eb 09		 jmp	 SHORT $LN17@Process_0C
$LN16@Process_0C:

; 5480 :     else
; 5481 :     {
; 5482 :         pLCSCONN = NULL;

  0009a	48 c7 44 24 48
	00 00 00 00	 mov	 QWORD PTR pLCSCONN$[rsp], 0
$LN17@Process_0C:
$LN15@Process_0C:

; 5483 :     }
; 5484 :     if (!pLCSCONN)

  000a3	48 83 7c 24 48
	00		 cmp	 QWORD PTR pLCSCONN$[rsp], 0
  000a9	75 58		 jne	 SHORT $LN18@Process_0C

; 5485 :     {
; 5486 :         WRMSG( HHC03984, "W", "LCSCONN not found");

  000ab	b9 01 00 00 00	 mov	 ecx, 1
  000b0	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  000b6	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG174449
  000bd	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  000c2	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG174450
  000c9	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  000ce	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG174451
  000d5	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  000da	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  000df	41 b9 03 00 00
	00		 mov	 r9d, 3
  000e5	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG174452
  000ec	ba 6e 15 00 00	 mov	 edx, 5486		; 0000156eH
  000f1	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG174453
  000f8	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 5487 :         /* FixMe! Need a proper error message here! */
; 5488 :         return;

  000fe	e9 e3 00 00 00	 jmp	 $LN1@Process_0C
$LN18@Process_0C:

; 5489 :     }
; 5490 : 
; 5491 :     //
; 5492 :     pLCSIBH = alloc_lcs_buffer( pLCSDEV, ( INBOUND_CC0B_SIZE * 2 ) );

  00103	ba 40 00 00 00	 mov	 edx, 64			; 00000040H
  00108	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR pLCSDEV$[rsp]
  00110	e8 00 00 00 00	 call	 alloc_lcs_buffer
  00115	48 89 44 24 50	 mov	 QWORD PTR pLCSIBH$[rsp], rax

; 5493 : 
; 5494 :     memcpy( &pLCSIBH->bData, Inbound_CC0B, INBOUND_CC0B_SIZE );

  0011a	48 8b 44 24 50	 mov	 rax, QWORD PTR pLCSIBH$[rsp]
  0011f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:?Inbound_CC0B@?1??Process_0C0B@@9@9
  00126	48 8d 78 10	 lea	 rdi, QWORD PTR [rax+16]
  0012a	48 8b f1	 mov	 rsi, rcx
  0012d	b9 20 00 00 00	 mov	 ecx, 32			; 00000020H
  00132	f3 a4		 rep movsb

; 5495 :     pLCSIBH->iDataLen = INBOUND_CC0B_SIZE;

  00134	48 8b 44 24 50	 mov	 rax, QWORD PTR pLCSIBH$[rsp]
  00139	c7 40 0c 20 00
	00 00		 mov	 DWORD PTR [rax+12], 32	; 00000020H

; 5496 : 
; 5497 :     pInHDR = (PLCSHDR)&pLCSIBH->bData;

  00140	48 8b 44 24 50	 mov	 rax, QWORD PTR pLCSIBH$[rsp]
  00145	48 83 c0 10	 add	 rax, 16
  00149	48 89 44 24 60	 mov	 QWORD PTR pInHDR$[rsp], rax

; 5498 :     pInBAF1 = (PLCSBAF1)( (BYTE*)pInHDR + sizeof(LCSHDR) );

  0014e	48 8b 44 24 60	 mov	 rax, QWORD PTR pInHDR$[rsp]
  00153	48 83 c0 04	 add	 rax, 4
  00157	48 89 44 24 58	 mov	 QWORD PTR pInBAF1$[rsp], rax

; 5499 :     FETCH_HW( hwLenInBaf1, pInBAF1->hwLenBaf1 );

  0015c	48 8b 44 24 58	 mov	 rax, QWORD PTR pInBAF1$[rsp]
  00161	48 8b c8	 mov	 rcx, rax
  00164	e8 00 00 00 00	 call	 fetch_hw_noswap
  00169	0f b7 c8	 movzx	 ecx, ax
  0016c	e8 00 00 00 00	 call	 _byteswap_ushort
  00171	66 89 44 24 40	 mov	 WORD PTR hwLenInBaf1$[rsp], ax

; 5500 : //  FETCH_HW( hwLenInBaf2, pInBAF1->hwLenBaf2 );
; 5501 :     pInBAF2 = (PLCSBAF2)( (BYTE*)pInBAF1 + hwLenInBaf1 );

  00176	0f b7 44 24 40	 movzx	 eax, WORD PTR hwLenInBaf1$[rsp]
  0017b	48 8b 4c 24 58	 mov	 rcx, QWORD PTR pInBAF1$[rsp]
  00180	48 03 c8	 add	 rcx, rax
  00183	48 8b c1	 mov	 rax, rcx
  00186	48 89 44 24 68	 mov	 QWORD PTR pInBAF2$[rsp], rax

; 5502 : 
; 5503 :     memcpy( &pInBAF1->bTokenA, &pLCSCONN->bInToken, sizeof(pLCSCONN->bInToken) );        // Set Inbound token

  0018b	48 8b 44 24 58	 mov	 rax, QWORD PTR pInBAF1$[rsp]
  00190	48 8b 4c 24 48	 mov	 rcx, QWORD PTR pLCSCONN$[rsp]
  00195	8b 49 08	 mov	 ecx, DWORD PTR [rcx+8]
  00198	89 48 08	 mov	 DWORD PTR [rax+8], ecx

; 5504 : 
; 5505 :     memcpy( &pInBAF2->hwSeqNum, &pOutBAF2->hwSeqNum, sizeof(pInBAF2->hwSeqNum) );

  0019b	48 8b 44 24 68	 mov	 rax, QWORD PTR pInBAF2$[rsp]
  001a0	48 8b 8c 24 a8
	00 00 00	 mov	 rcx, QWORD PTR pOutBAF2$[rsp]
  001a8	0f b7 49 01	 movzx	 ecx, WORD PTR [rcx+1]
  001ac	66 89 48 01	 mov	 WORD PTR [rax+1], cx

; 5506 : 
; 5507 :     add_lcs_buffer_to_chain( pLCSDEV, pLCSIBH );

  001b0	48 8b 54 24 50	 mov	 rdx, QWORD PTR pLCSIBH$[rsp]
  001b5	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR pLCSDEV$[rsp]
  001bd	e8 00 00 00 00	 call	 add_lcs_buffer_to_chain

; 5508 : 
; 5509 :     remove_connection_from_chain( pLCSDEV, pLCSCONN );

  001c2	48 8b 54 24 48	 mov	 rdx, QWORD PTR pLCSCONN$[rsp]
  001c7	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR pLCSDEV$[rsp]
  001cf	e8 00 00 00 00	 call	 remove_connection_from_chain

; 5510 :     free_connection( pLCSDEV, pLCSCONN );

  001d4	48 8b 54 24 48	 mov	 rdx, QWORD PTR pLCSCONN$[rsp]
  001d9	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR pLCSDEV$[rsp]
  001e1	e8 00 00 00 00	 call	 free_connection
$LN1@Process_0C:

; 5511 : 
; 5512 :     return;
; 5513 : }

  001e6	48 83 c4 78	 add	 rsp, 120		; 00000078H
  001ea	5f		 pop	 rdi
  001eb	5e		 pop	 rsi
  001ec	c3		 ret	 0
Process_0C0B ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\ctc_lcs.c
_TEXT	SEGMENT
iEthLen$ = 112
pEthFrame$ = 120
pLCSCONN$ = 128
pDEVBLK$ = 136
iLPDULen$ = 144
tv174 = 148
tv179 = 152
pLCSPORT$ = 160
tv169 = 168
llc$ = 176
frame$ = 224
llcmsg$ = 288
__$ArrayPad$ = 544
pLCSDEV$ = 592
pLCSHDR$ = 600
pLCSBAF1$ = 608
pLCSBAF2$ = 616
hwLenBaf1$ = 624
hwLenBaf2$ = 632
Process_8D00 PROC

; 5342 : {

  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	56		 push	 rsi
  00015	57		 push	 rdi
  00016	48 81 ec 38 02
	00 00		 sub	 rsp, 568		; 00000238H
  0001d	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00024	48 33 c4	 xor	 rax, rsp
  00027	48 89 84 24 20
	02 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax
$LN4@Process_8D:

; 5343 : //                   Token
; 5344 : //  00108D00001A6002 40000240 00000000
; 5345 : //  0 1 2 3 4 5 6 7  8 9 A B  C D E F
; 5346 : //
; 5347 : //  0100000000000000000000000000000000000000000000000000
; 5348 : //  0 1 2 3 4 5 6 7 8 9 A B C D E F 0 1 2 3 4 5 6 7 8 9
; 5349 : 
; 5350 :     DEVBLK*   pDEVBLK;
; 5351 :     PLCSPORT  pLCSPORT;
; 5352 :     PLCSCONN  pLCSCONN;
; 5353 :     PETHFRM   pEthFrame;
; 5354 :     int       iEthLen;
; 5355 :     int       iLPDULen;
; 5356 :     LLC       llc;
; 5357 :     BYTE      frame[64];
; 5358 :     char      llcmsg[256];
; 5359 : 
; 5360 :     UNREFERENCED( pLCSHDR   );

  0002f	33 c0		 xor	 eax, eax
  00031	85 c0		 test	 eax, eax
  00033	75 fa		 jne	 SHORT $LN4@Process_8D
$LN7@Process_8D:

; 5361 :     UNREFERENCED( pLCSBAF1  );

  00035	33 c0		 xor	 eax, eax
  00037	85 c0		 test	 eax, eax
  00039	75 fa		 jne	 SHORT $LN7@Process_8D
$LN10@Process_8D:

; 5362 :     UNREFERENCED( pLCSBAF2  );

  0003b	33 c0		 xor	 eax, eax
  0003d	85 c0		 test	 eax, eax
  0003f	75 fa		 jne	 SHORT $LN10@Process_8D
$LN13@Process_8D:

; 5363 :     UNREFERENCED( hwLenBaf1 );

  00041	33 c0		 xor	 eax, eax
  00043	85 c0		 test	 eax, eax
  00045	75 fa		 jne	 SHORT $LN13@Process_8D
$LN16@Process_8D:

; 5364 :     UNREFERENCED( hwLenBaf2 );

  00047	33 c0		 xor	 eax, eax
  00049	85 c0		 test	 eax, eax
  0004b	75 fa		 jne	 SHORT $LN16@Process_8D

; 5365 : 
; 5366 :     pDEVBLK = pLCSDEV->pDEVBLK[ LCS_READ_SUBCHANN ];

  0004d	b8 08 00 00 00	 mov	 eax, 8
  00052	48 6b c0 00	 imul	 rax, rax, 0
  00056	48 8b 8c 24 50
	02 00 00	 mov	 rcx, QWORD PTR pLCSDEV$[rsp]
  0005e	48 8b 44 01 10	 mov	 rax, QWORD PTR [rcx+rax+16]
  00063	48 89 84 24 88
	00 00 00	 mov	 QWORD PTR pDEVBLK$[rsp], rax

; 5367 :     pLCSPORT = &pLCSDEV->pLCSBLK->Port[pLCSDEV->bPort];

  0006b	48 8b 84 24 50
	02 00 00	 mov	 rax, QWORD PTR pLCSDEV$[rsp]
  00073	48 8b 40 08	 mov	 rax, QWORD PTR [rax+8]
  00077	48 8b 8c 24 50
	02 00 00	 mov	 rcx, QWORD PTR pLCSDEV$[rsp]
  0007f	0f b6 49 23	 movzx	 ecx, BYTE PTR [rcx+35]
  00083	48 69 c9 98 01
	00 00		 imul	 rcx, rcx, 408		; 00000198H
  0008a	48 8d 44 08 60	 lea	 rax, QWORD PTR [rax+rcx+96]
  0008f	48 89 84 24 a0
	00 00 00	 mov	 QWORD PTR pLCSPORT$[rsp], rax

; 5368 :     memset( frame, 0, sizeof(frame) );                               // Clear area for ethernet fram

  00097	48 8d 84 24 e0
	00 00 00	 lea	 rax, QWORD PTR frame$[rsp]
  0009f	48 8b f8	 mov	 rdi, rax
  000a2	33 c0		 xor	 eax, eax
  000a4	b9 40 00 00 00	 mov	 ecx, 64			; 00000040H
  000a9	f3 aa		 rep stosb

; 5369 :     pEthFrame = (PETHFRM)&frame[0];

  000ab	b8 01 00 00 00	 mov	 eax, 1
  000b0	48 6b c0 00	 imul	 rax, rax, 0
  000b4	48 8d 84 04 e0
	00 00 00	 lea	 rax, QWORD PTR frame$[rsp+rax]
  000bc	48 89 44 24 78	 mov	 QWORD PTR pEthFrame$[rsp], rax

; 5370 :     iEthLen = 60;                                                    // Minimum ethernet frame length

  000c1	c7 44 24 70 3c
	00 00 00	 mov	 DWORD PTR iEthLen$[rsp], 60 ; 0000003cH

; 5371 : 
; 5372 :     // Find the connection block.
; 5373 :     pLCSCONN = find_connection_by_outbound_token( pLCSDEV, pLCSBAF1->bTokenA );

  000c9	48 8b 84 24 60
	02 00 00	 mov	 rax, QWORD PTR pLCSBAF1$[rsp]
  000d1	48 83 c0 08	 add	 rax, 8
  000d5	48 8b d0	 mov	 rdx, rax
  000d8	48 8b 8c 24 50
	02 00 00	 mov	 rcx, QWORD PTR pLCSDEV$[rsp]
  000e0	e8 00 00 00 00	 call	 find_connection_by_outbound_token
  000e5	48 89 84 24 80
	00 00 00	 mov	 QWORD PTR pLCSCONN$[rsp], rax

; 5374 :     if (!pLCSCONN)

  000ed	48 83 bc 24 80
	00 00 00 00	 cmp	 QWORD PTR pLCSCONN$[rsp], 0
  000f6	75 58		 jne	 SHORT $LN20@Process_8D

; 5375 :     {
; 5376 :         WRMSG( HHC03984, "W", "LCSCONN not found");

  000f8	b9 01 00 00 00	 mov	 ecx, 1
  000fd	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  00103	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG174380
  0010a	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  0010f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG174381
  00116	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  0011b	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG174382
  00122	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00127	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  0012c	41 b9 03 00 00
	00		 mov	 r9d, 3
  00132	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG174383
  00139	ba 00 15 00 00	 mov	 edx, 5376		; 00001500H
  0013e	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG174384
  00145	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 5377 :         /* FixMe! Need a proper error message here! */
; 5378 :         return;

  0014b	e9 64 03 00 00	 jmp	 $LN1@Process_8D
$LN20@Process_8D:

; 5379 :     }
; 5380 : 
; 5381 :     pLCSCONN->fIframe = FALSE;

  00150	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR pLCSCONN$[rsp]
  00158	8b 40 2c	 mov	 eax, DWORD PTR [rax+44]
  0015b	83 e0 fe	 and	 eax, -2			; fffffffeH
  0015e	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR pLCSCONN$[rsp]
  00166	89 41 2c	 mov	 DWORD PTR [rcx+44], eax

; 5382 : 
; 5383 :     //
; 5384 :     memset( &llc, 0, sizeof(LLC) );

  00169	48 8d 84 24 b0
	00 00 00	 lea	 rax, QWORD PTR llc$[rsp]
  00171	48 8b f8	 mov	 rdi, rax
  00174	33 c0		 xor	 eax, eax
  00176	b9 2e 00 00 00	 mov	 ecx, 46			; 0000002eH
  0017b	f3 aa		 rep stosb

; 5385 :     llc.hwDSAP    = LSAP_SNA_Path_Control;

  0017d	b8 04 00 00 00	 mov	 eax, 4
  00182	66 89 84 24 be
	00 00 00	 mov	 WORD PTR llc$[rsp+14], ax

; 5386 :     llc.hwSSAP    = LSAP_SNA_Path_Control;

  0018a	b8 04 00 00 00	 mov	 eax, 4
  0018f	66 89 84 24 c2
	00 00 00	 mov	 WORD PTR llc$[rsp+18], ax

; 5387 :     llc.hwCR      = 1;

  00197	b8 01 00 00 00	 mov	 eax, 1
  0019c	66 89 84 24 c4
	00 00 00	 mov	 WORD PTR llc$[rsp+20], ax

; 5388 :     llc.hwPF      = 1;

  001a4	b8 01 00 00 00	 mov	 eax, 1
  001a9	66 89 84 24 ca
	00 00 00	 mov	 WORD PTR llc$[rsp+26], ax

; 5389 :     llc.hwM       = M_UA_Response;

  001b1	b8 0c 00 00 00	 mov	 eax, 12
  001b6	66 89 84 24 ce
	00 00 00	 mov	 WORD PTR llc$[rsp+30], ax

; 5390 :     llc.hwType    = Type_Unnumbered_Frame;

  001be	b8 03 00 00 00	 mov	 eax, 3
  001c3	66 89 84 24 dc
	00 00 00	 mov	 WORD PTR llc$[rsp+44], ax

; 5391 : 
; 5392 :     // Construct Ethernet frame
; 5393 :     memcpy( &pEthFrame->bDestMAC, &pLCSCONN->bRemoteMAC, IFHWADDRLEN );   // Copy destination MAC address

  001cb	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR pLCSCONN$[rsp]
  001d3	48 8b 7c 24 78	 mov	 rdi, QWORD PTR pEthFrame$[rsp]
  001d8	48 8d 70 16	 lea	 rsi, QWORD PTR [rax+22]
  001dc	b9 06 00 00 00	 mov	 ecx, 6
  001e1	f3 a4		 rep movsb

; 5394 :     memcpy( &pEthFrame->bSrcMAC, &pLCSCONN->bLocalMAC, IFHWADDRLEN );     // Copy source MAC address

  001e3	48 8b 44 24 78	 mov	 rax, QWORD PTR pEthFrame$[rsp]
  001e8	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR pLCSCONN$[rsp]
  001f0	48 8d 78 06	 lea	 rdi, QWORD PTR [rax+6]
  001f4	48 8d 71 10	 lea	 rsi, QWORD PTR [rcx+16]
  001f8	b9 06 00 00 00	 mov	 ecx, 6
  001fd	f3 a4		 rep movsb

; 5395 :     iLPDULen = BuildLLC( &llc, pEthFrame->bData);                         // Build LLC PDU

  001ff	48 8b 44 24 78	 mov	 rax, QWORD PTR pEthFrame$[rsp]
  00204	48 83 c0 0e	 add	 rax, 14
  00208	48 8b d0	 mov	 rdx, rax
  0020b	48 8d 8c 24 b0
	00 00 00	 lea	 rcx, QWORD PTR llc$[rsp]
  00213	e8 00 00 00 00	 call	 BuildLLC
  00218	89 84 24 90 00
	00 00		 mov	 DWORD PTR iLPDULen$[rsp], eax

; 5396 :     STORE_HW( pEthFrame->hwEthernetType, (U16)iLPDULen );                 // Set data length

  0021f	0f b7 8c 24 90
	00 00 00	 movzx	 ecx, WORD PTR iLPDULen$[rsp]
  00227	e8 00 00 00 00	 call	 _byteswap_ushort
  0022c	48 8b 4c 24 78	 mov	 rcx, QWORD PTR pEthFrame$[rsp]
  00231	48 83 c1 0c	 add	 rcx, 12
  00235	0f b7 d0	 movzx	 edx, ax
  00238	e8 00 00 00 00	 call	 store_hw_noswap

; 5397 : 
; 5398 :     // Trace Ethernet frame before sending to TAP device
; 5399 :     if (pLCSPORT->pLCSBLK->fDebug)

  0023d	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR pLCSPORT$[rsp]
  00245	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  00249	8b 40 18	 mov	 eax, DWORD PTR [rax+24]
  0024c	83 e0 01	 and	 eax, 1
  0024f	85 c0		 test	 eax, eax
  00251	0f 84 10 01 00
	00		 je	 $LN21@Process_8D

; 5400 :     {
; 5401 :         // "%1d:%04X %s: port %2.2X: Send frame of size %d bytes (with %s packet) to device %s"
; 5402 :         WRMSG(HHC00983, "D", SSID_TO_LCSS(pDEVBLK->ssid), pDEVBLK->devnum, pDEVBLK->typname,

  00257	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR pLCSPORT$[rsp]
  0025f	48 05 48 01 00
	00		 add	 rax, 328		; 00000148H
  00265	48 89 84 24 a8
	00 00 00	 mov	 QWORD PTR tv169[rsp], rax
  0026d	48 8b 8c 24 50
	02 00 00	 mov	 rcx, QWORD PTR pLCSDEV$[rsp]
  00275	0f b6 49 23	 movzx	 ecx, BYTE PTR [rcx+35]
  00279	89 8c 24 94 00
	00 00		 mov	 DWORD PTR tv174[rsp], ecx
  00280	48 8b 94 24 88
	00 00 00	 mov	 rdx, QWORD PTR pDEVBLK$[rsp]
  00288	0f b7 52 48	 movzx	 edx, WORD PTR [rdx+72]
  0028c	89 94 24 98 00
	00 00		 mov	 DWORD PTR tv179[rsp], edx
  00293	48 8b bc 24 88
	00 00 00	 mov	 rdi, QWORD PTR pDEVBLK$[rsp]
  0029b	0f b7 7f 44	 movzx	 edi, WORD PTR [rdi+68]
  0029f	d1 ff		 sar	 edi, 1
  002a1	b9 01 00 00 00	 mov	 ecx, 1
  002a6	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  002ac	48 8b 8c 24 a8
	00 00 00	 mov	 rcx, QWORD PTR tv169[rsp]
  002b4	48 89 4c 24 68	 mov	 QWORD PTR [rsp+104], rcx
  002b9	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG174386
  002c0	48 89 4c 24 60	 mov	 QWORD PTR [rsp+96], rcx
  002c5	8b 4c 24 70	 mov	 ecx, DWORD PTR iEthLen$[rsp]
  002c9	89 4c 24 58	 mov	 DWORD PTR [rsp+88], ecx
  002cd	8b 8c 24 94 00
	00 00		 mov	 ecx, DWORD PTR tv174[rsp]
  002d4	89 4c 24 50	 mov	 DWORD PTR [rsp+80], ecx
  002d8	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR pDEVBLK$[rsp]
  002e0	48 8b 49 50	 mov	 rcx, QWORD PTR [rcx+80]
  002e4	48 89 4c 24 48	 mov	 QWORD PTR [rsp+72], rcx
  002e9	8b 8c 24 98 00
	00 00		 mov	 ecx, DWORD PTR tv179[rsp]
  002f0	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  002f4	89 7c 24 38	 mov	 DWORD PTR [rsp+56], edi
  002f8	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG174387
  002ff	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  00304	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG174388
  0030b	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00310	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00315	41 b9 03 00 00
	00		 mov	 r9d, 3
  0031b	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG174389
  00322	ba 1b 15 00 00	 mov	 edx, 5403		; 0000151bH
  00327	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG174390
  0032e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 5403 :                              pLCSDEV->bPort, iEthLen, "802.3 SNA", pLCSPORT->szNetIfName );
; 5404 :         net_data_trace( pDEVBLK, (BYTE*)pEthFrame, iEthLen, FROM_GUEST, 'D', "eth frame", 0 );

  00334	c7 44 24 30 00
	00 00 00	 mov	 DWORD PTR [rsp+48], 0
  0033c	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG174391
  00343	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  00348	c6 44 24 20 44	 mov	 BYTE PTR [rsp+32], 68	; 00000044H
  0034d	41 b1 3c	 mov	 r9b, 60			; 0000003cH
  00350	44 8b 44 24 70	 mov	 r8d, DWORD PTR iEthLen$[rsp]
  00355	48 8b 54 24 78	 mov	 rdx, QWORD PTR pEthFrame$[rsp]
  0035a	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR pDEVBLK$[rsp]
  00362	e8 00 00 00 00	 call	 net_data_trace
$LN21@Process_8D:

; 5405 :     }
; 5406 : 
; 5407 :     // Write the Ethernet frame to the TAP device
; 5408 :     if (TUNTAP_Write( pDEVBLK->fd, (BYTE*)pEthFrame, iEthLen ) == iEthLen)

  00367	44 8b 44 24 70	 mov	 r8d, DWORD PTR iEthLen$[rsp]
  0036c	48 8b 54 24 78	 mov	 rdx, QWORD PTR pEthFrame$[rsp]
  00371	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR pDEVBLK$[rsp]
  00379	8b 88 ac 01 00
	00		 mov	 ecx, DWORD PTR [rax+428]
  0037f	e8 00 00 00 00	 call	 tt32_write
  00384	3b 44 24 70	 cmp	 eax, DWORD PTR iEthLen$[rsp]
  00388	0f 85 a4 00 00
	00		 jne	 $LN22@Process_8D

; 5409 :     {
; 5410 :         if (pLCSPORT->pLCSBLK->fDebug)

  0038e	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR pLCSPORT$[rsp]
  00396	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  0039a	8b 40 18	 mov	 eax, DWORD PTR [rax+24]
  0039d	83 e0 01	 and	 eax, 1
  003a0	85 c0		 test	 eax, eax
  003a2	0f 84 85 00 00
	00		 je	 $LN24@Process_8D

; 5411 :         {
; 5412 :             snprintf( llcmsg, sizeof(llcmsg), "LCS: LLC unnumbered frame sent: CR=%u, M=%s", llc.hwCR, "UA" );

  003a8	0f b7 84 24 c4
	00 00 00	 movzx	 eax, WORD PTR llc$[rsp+20]
  003b0	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG174395
  003b7	48 89 4c 24 20	 mov	 QWORD PTR [rsp+32], rcx
  003bc	44 8b c8	 mov	 r9d, eax
  003bf	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG174396
  003c6	ba 00 01 00 00	 mov	 edx, 256		; 00000100H
  003cb	48 8d 8c 24 20
	01 00 00	 lea	 rcx, QWORD PTR llcmsg$[rsp]
  003d3	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_snprintf

; 5413 :             WRMSG(HHC03984, "D", llcmsg );  /* FixMe! */

  003d9	b9 01 00 00 00	 mov	 ecx, 1
  003de	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  003e4	48 8d 8c 24 20
	01 00 00	 lea	 rcx, QWORD PTR llcmsg$[rsp]
  003ec	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  003f1	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG174397
  003f8	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  003fd	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG174398
  00404	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00409	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  0040e	41 b9 03 00 00
	00		 mov	 r9d, 3
  00414	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG174399
  0041b	ba 25 15 00 00	 mov	 edx, 5413		; 00001525H
  00420	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG174400
  00427	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg
$LN24@Process_8D:

; 5414 :         }
; 5415 :     }

  0042d	e9 82 00 00 00	 jmp	 $LN23@Process_8D
$LN22@Process_8D:

; 5416 :     else
; 5417 :     {
; 5418 :         pLCSDEV->iTuntapErrno = errno;

  00432	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno
  00438	48 8b 8c 24 50
	02 00 00	 mov	 rcx, QWORD PTR pLCSDEV$[rsp]
  00440	8b 00		 mov	 eax, DWORD PTR [rax]
  00442	89 41 61	 mov	 DWORD PTR [rcx+97], eax

; 5419 :         pLCSDEV->fTuntapError = TRUE;

  00445	48 8b 84 24 50
	02 00 00	 mov	 rax, QWORD PTR pLCSDEV$[rsp]
  0044d	8b 40 5d	 mov	 eax, DWORD PTR [rax+93]
  00450	83 c8 10	 or	 eax, 16
  00453	48 8b 8c 24 50
	02 00 00	 mov	 rcx, QWORD PTR pLCSDEV$[rsp]
  0045b	89 41 5d	 mov	 DWORD PTR [rcx+93], eax
$LN19@Process_8D:

; 5420 :         PTT_TIMING( "*WRITE ERR", 0, iEthLen, 1 );

  0045e	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_pttclass
  00465	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00468	48 25 00 00 01
	00		 and	 rax, 65536		; 00010000H
  0046e	48 85 c0	 test	 rax, rax
  00471	74 3b		 je	 SHORT $LN25@Process_8D
  00473	48 63 44 24 70	 movsxd	 rax, DWORD PTR iEthLen$[rsp]
  00478	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR [rsp+48], 0
  00481	48 c7 44 24 28
	01 00 00 00	 mov	 QWORD PTR [rsp+40], 1
  0048a	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG174402
  00491	48 89 4c 24 20	 mov	 QWORD PTR [rsp+32], rcx
  00496	4c 8b c8	 mov	 r9, rax
  00499	45 33 c0	 xor	 r8d, r8d
  0049c	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG174403
  004a3	b9 00 00 01 00	 mov	 ecx, 65536		; 00010000H
  004a8	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ptt_pthread_trace
$LN25@Process_8D:
  004ae	33 c0		 xor	 eax, eax
  004b0	85 c0		 test	 eax, eax
  004b2	75 aa		 jne	 SHORT $LN19@Process_8D
$LN23@Process_8D:
$LN1@Process_8D:

; 5421 :     }
; 5422 : 
; 5423 :     return;
; 5424 : }

  004b4	48 8b 8c 24 20
	02 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  004bc	48 33 cc	 xor	 rcx, rsp
  004bf	e8 00 00 00 00	 call	 __security_check_cookie
  004c4	48 81 c4 38 02
	00 00		 add	 rsp, 568		; 00000238H
  004cb	5f		 pop	 rdi
  004cc	5e		 pop	 rsi
  004cd	c3		 ret	 0
Process_8D00 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\ctc_lcs.c
_TEXT	SEGMENT
iEthLen$ = 112
iLPDULen$ = 116
iXIDlen$ = 120
iTraceLen$ = 124
pEthFrame$ = 128
pDEVBLK$ = 136
pLCSPORT$ = 144
tv202 = 152
tv207 = 156
tv230 = 160
tv236 = 164
tv240 = 168
pLCSCONN$ = 176
tv197 = 184
llc$ = 192
llcmsg$ = 240
frame$ = 496
__$ArrayPad$ = 1008
pLCSDEV$ = 1056
pLCSHDR$ = 1064
pLCSBAF1$ = 1072
pLCSBAF2$ = 1080
hwLenBaf1$ = 1088
hwLenBaf2$ = 1096
Process_0C22 PROC

; 5222 : {

  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	56		 push	 rsi
  00015	57		 push	 rdi
  00016	48 81 ec 08 04
	00 00		 sub	 rsp, 1032		; 00000408H
  0001d	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00024	48 33 c4	 xor	 rax, rsp
  00027	48 89 84 24 f0
	03 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax
$LN4@Process_0C:

; 5223 : //                   Token
; 5224 : //  000D0C22001A6004 400000DC 00
; 5225 : //  0 1 2 3 4 5 6 7  8 9 A B  C
; 5226 : //                         DMAC         SMAC         LLC ?  TH etc.
; 5227 : //  0100000000030408000000 000CCE4B4740 400074700001 040400 xxxxxxxx...........
; 5228 : //  0 1 2 3 4 5 6 7 8 9 A  B C D E F 0  1 2 3 4 5 6  7 8 9  A B C D E F 0 1 ...
; 5229 : //  0100000000030808000000 080027195BFE 400074700001 040400 xxxxxxxx...........
; 5230 : 
; 5231 :     DEVBLK*   pDEVBLK;
; 5232 :     PLCSPORT  pLCSPORT;
; 5233 :     PLCSCONN  pLCSCONN;
; 5234 :     int       iLPDULen;
; 5235 :     LLC       llc;
; 5236 :     PETHFRM   pEthFrame;
; 5237 :     int       iEthLen;
; 5238 :     int       iXIDlen;
; 5239 :     int       iTraceLen;
; 5240 :     BYTE      frame[512];
; 5241 :     char      llcmsg[256];
; 5242 : 
; 5243 :     UNREFERENCED( pLCSHDR   );

  0002f	33 c0		 xor	 eax, eax
  00031	85 c0		 test	 eax, eax
  00033	75 fa		 jne	 SHORT $LN4@Process_0C
$LN7@Process_0C:

; 5244 :     UNREFERENCED( pLCSBAF1  );

  00035	33 c0		 xor	 eax, eax
  00037	85 c0		 test	 eax, eax
  00039	75 fa		 jne	 SHORT $LN7@Process_0C
$LN10@Process_0C:

; 5245 :     UNREFERENCED( hwLenBaf1 );

  0003b	33 c0		 xor	 eax, eax
  0003d	85 c0		 test	 eax, eax
  0003f	75 fa		 jne	 SHORT $LN10@Process_0C

; 5246 : 
; 5247 :     pDEVBLK = pLCSDEV->pDEVBLK[ LCS_READ_SUBCHANN ];

  00041	b8 08 00 00 00	 mov	 eax, 8
  00046	48 6b c0 00	 imul	 rax, rax, 0
  0004a	48 8b 8c 24 20
	04 00 00	 mov	 rcx, QWORD PTR pLCSDEV$[rsp]
  00052	48 8b 44 01 10	 mov	 rax, QWORD PTR [rcx+rax+16]
  00057	48 89 84 24 88
	00 00 00	 mov	 QWORD PTR pDEVBLK$[rsp], rax

; 5248 :     pLCSPORT = &pLCSDEV->pLCSBLK->Port[pLCSDEV->bPort];

  0005f	48 8b 84 24 20
	04 00 00	 mov	 rax, QWORD PTR pLCSDEV$[rsp]
  00067	48 8b 40 08	 mov	 rax, QWORD PTR [rax+8]
  0006b	48 8b 8c 24 20
	04 00 00	 mov	 rcx, QWORD PTR pLCSDEV$[rsp]
  00073	0f b6 49 23	 movzx	 ecx, BYTE PTR [rcx+35]
  00077	48 69 c9 98 01
	00 00		 imul	 rcx, rcx, 408		; 00000198H
  0007e	48 8d 44 08 60	 lea	 rax, QWORD PTR [rax+rcx+96]
  00083	48 89 84 24 90
	00 00 00	 mov	 QWORD PTR pLCSPORT$[rsp], rax

; 5249 :     memset( frame, 0, sizeof(frame) );                               // Clear area for ethernet fram

  0008b	48 8d 84 24 f0
	01 00 00	 lea	 rax, QWORD PTR frame$[rsp]
  00093	48 8b f8	 mov	 rdi, rax
  00096	33 c0		 xor	 eax, eax
  00098	b9 00 02 00 00	 mov	 ecx, 512		; 00000200H
  0009d	f3 aa		 rep stosb

; 5250 :     pEthFrame = (PETHFRM)&frame[0];

  0009f	b8 01 00 00 00	 mov	 eax, 1
  000a4	48 6b c0 00	 imul	 rax, rax, 0
  000a8	48 8d 84 04 f0
	01 00 00	 lea	 rax, QWORD PTR frame$[rsp+rax]
  000b0	48 89 84 24 80
	00 00 00	 mov	 QWORD PTR pEthFrame$[rsp], rax

; 5251 :     iEthLen = 60;                                                    // Minimum ethernet frame length

  000b8	c7 44 24 70 3c
	00 00 00	 mov	 DWORD PTR iEthLen$[rsp], 60 ; 0000003cH

; 5252 : 
; 5253 :     // Find the connection block.
; 5254 :     pLCSCONN = find_connection_by_remote_mac( pLCSDEV, (MAC*)&pLCSBAF2->bByte11 );

  000c0	48 8b 84 24 38
	04 00 00	 mov	 rax, QWORD PTR pLCSBAF2$[rsp]
  000c8	48 83 c0 0b	 add	 rax, 11
  000cc	48 8b d0	 mov	 rdx, rax
  000cf	48 8b 8c 24 20
	04 00 00	 mov	 rcx, QWORD PTR pLCSDEV$[rsp]
  000d7	e8 00 00 00 00	 call	 find_connection_by_remote_mac
  000dc	48 89 84 24 b0
	00 00 00	 mov	 QWORD PTR pLCSCONN$[rsp], rax

; 5255 :     if (!pLCSCONN)

  000e4	48 83 bc 24 b0
	00 00 00 00	 cmp	 QWORD PTR pLCSCONN$[rsp], 0
  000ed	75 58		 jne	 SHORT $LN14@Process_0C

; 5256 :     {
; 5257 :         WRMSG( HHC03984, "W", "LCSCONN not found");

  000ef	b9 01 00 00 00	 mov	 ecx, 1
  000f4	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  000fa	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG174295
  00101	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  00106	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG174296
  0010d	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  00112	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG174297
  00119	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  0011e	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00123	41 b9 03 00 00
	00		 mov	 r9d, 3
  00129	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG174298
  00130	ba 89 14 00 00	 mov	 edx, 5257		; 00001489H
  00135	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG174299
  0013c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 5258 :         /* FixMe! Need a proper error message here! */
; 5259 :         return;

  00142	e9 0a 05 00 00	 jmp	 $LN1@Process_0C
$LN14@Process_0C:

; 5260 :     }
; 5261 : 
; 5262 :     //
; 5263 :     memset( &llc, 0, sizeof(LLC) );

  00147	48 8d 84 24 c0
	00 00 00	 lea	 rax, QWORD PTR llc$[rsp]
  0014f	48 8b f8	 mov	 rdi, rax
  00152	33 c0		 xor	 eax, eax
  00154	b9 2e 00 00 00	 mov	 ecx, 46			; 0000002eH
  00159	f3 aa		 rep stosb

; 5264 :     llc.hwDSAP    = pLCSBAF2->bByte23;                               // Copy LLC DSAP

  0015b	48 8b 84 24 38
	04 00 00	 mov	 rax, QWORD PTR pLCSBAF2$[rsp]
  00163	0f b6 40 17	 movzx	 eax, BYTE PTR [rax+23]
  00167	66 89 84 24 ce
	00 00 00	 mov	 WORD PTR llc$[rsp+14], ax

; 5265 :     llc.hwSSAP    = pLCSBAF2->bByte24;                               // Copy LLC SSAP

  0016f	48 8b 84 24 38
	04 00 00	 mov	 rax, QWORD PTR pLCSBAF2$[rsp]
  00177	0f b6 40 18	 movzx	 eax, BYTE PTR [rax+24]
  0017b	66 89 84 24 d2
	00 00 00	 mov	 WORD PTR llc$[rsp+18], ax

; 5266 :     if ( pLCSCONN->hwCreated == LCSCONN_CREATED_INBOUND )

  00183	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR pLCSCONN$[rsp]
  0018b	0f b7 40 1c	 movzx	 eax, WORD PTR [rax+28]
  0018f	83 f8 01	 cmp	 eax, 1
  00192	75 0d		 jne	 SHORT $LN15@Process_0C

; 5267 :     {
; 5268 :         llc.hwCR  = 1;

  00194	b8 01 00 00 00	 mov	 eax, 1
  00199	66 89 84 24 d4
	00 00 00	 mov	 WORD PTR llc$[rsp+20], ax
$LN15@Process_0C:

; 5269 :     }
; 5270 :     llc.hwPF      = 1;

  001a1	b8 01 00 00 00	 mov	 eax, 1
  001a6	66 89 84 24 da
	00 00 00	 mov	 WORD PTR llc$[rsp+26], ax

; 5271 :     llc.hwM       = M_XID_Command_or_Response;

  001ae	b8 17 00 00 00	 mov	 eax, 23
  001b3	66 89 84 24 de
	00 00 00	 mov	 WORD PTR llc$[rsp+30], ax

; 5272 :     llc.hwType    = Type_Unnumbered_Frame;

  001bb	b8 03 00 00 00	 mov	 eax, 3
  001c0	66 89 84 24 ec
	00 00 00	 mov	 WORD PTR llc$[rsp+44], ax

; 5273 : 
; 5274 :     // Construct Ethernet frame
; 5275 :     memcpy( &pEthFrame->bDestMAC, &pLCSBAF2->bByte11, IFHWADDRLEN ); // Copy destination MAC address

  001c8	48 8b 84 24 38
	04 00 00	 mov	 rax, QWORD PTR pLCSBAF2$[rsp]
  001d0	48 8b bc 24 80
	00 00 00	 mov	 rdi, QWORD PTR pEthFrame$[rsp]
  001d8	48 8d 70 0b	 lea	 rsi, QWORD PTR [rax+11]
  001dc	b9 06 00 00 00	 mov	 ecx, 6
  001e1	f3 a4		 rep movsb

; 5276 :     memcpy( &pEthFrame->bSrcMAC, &pLCSBAF2->bByte17, IFHWADDRLEN );  // Copy source MAC address

  001e3	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR pEthFrame$[rsp]
  001eb	48 8b 8c 24 38
	04 00 00	 mov	 rcx, QWORD PTR pLCSBAF2$[rsp]
  001f3	48 8d 78 06	 lea	 rdi, QWORD PTR [rax+6]
  001f7	48 8d 71 11	 lea	 rsi, QWORD PTR [rcx+17]
  001fb	b9 06 00 00 00	 mov	 ecx, 6
  00200	f3 a4		 rep movsb

; 5277 :     iLPDULen = BuildLLC( &llc, pEthFrame->bData);                    // Build LLC PDU

  00202	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR pEthFrame$[rsp]
  0020a	48 83 c0 0e	 add	 rax, 14
  0020e	48 8b d0	 mov	 rdx, rax
  00211	48 8d 8c 24 c0
	00 00 00	 lea	 rcx, QWORD PTR llc$[rsp]
  00219	e8 00 00 00 00	 call	 BuildLLC
  0021e	89 44 24 74	 mov	 DWORD PTR iLPDULen$[rsp], eax

; 5278 :     STORE_HW( pEthFrame->hwEthernetType, (U16)iLPDULen );            // Set data length

  00222	0f b7 4c 24 74	 movzx	 ecx, WORD PTR iLPDULen$[rsp]
  00227	e8 00 00 00 00	 call	 _byteswap_ushort
  0022c	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR pEthFrame$[rsp]
  00234	48 83 c1 0c	 add	 rcx, 12
  00238	0f b7 d0	 movzx	 edx, ax
  0023b	e8 00 00 00 00	 call	 store_hw_noswap

; 5279 : 
; 5280 :     // Continue Ethernet frame construction if there is an XID0 or an XID3 and CV's.
; 5281 :     iXIDlen = ( hwLenBaf2 - 26 );                                    // Calculate length of XID0 or XID3 and CV's

  00240	0f b7 84 24 48
	04 00 00	 movzx	 eax, WORD PTR hwLenBaf2$[rsp]
  00248	83 e8 1a	 sub	 eax, 26
  0024b	89 44 24 78	 mov	 DWORD PTR iXIDlen$[rsp], eax

; 5282 :     if ( iXIDlen > 0 )                                               // Any XID0 or XID3 an CV's?

  0024f	83 7c 24 78 00	 cmp	 DWORD PTR iXIDlen$[rsp], 0
  00254	7e 78		 jle	 SHORT $LN16@Process_0C

; 5283 :     {
; 5284 :         STORE_HW( pEthFrame->hwEthernetType, (U16)( iLPDULen + iXIDlen ) );    // Set LLC and XID0 or XID3 and CV's length

  00256	8b 44 24 78	 mov	 eax, DWORD PTR iXIDlen$[rsp]
  0025a	8b 4c 24 74	 mov	 ecx, DWORD PTR iLPDULen$[rsp]
  0025e	03 c8		 add	 ecx, eax
  00260	8b c1		 mov	 eax, ecx
  00262	0f b7 c8	 movzx	 ecx, ax
  00265	e8 00 00 00 00	 call	 _byteswap_ushort
  0026a	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR pEthFrame$[rsp]
  00272	48 83 c1 0c	 add	 rcx, 12
  00276	0f b7 d0	 movzx	 edx, ax
  00279	e8 00 00 00 00	 call	 store_hw_noswap

; 5285 :         memcpy( &pEthFrame->bData[iLPDULen], &pLCSBAF2->bByte26, iXIDlen );    // Copy XID0 or XID3 and CV's.

  0027e	48 63 44 24 78	 movsxd	 rax, DWORD PTR iXIDlen$[rsp]
  00283	48 8b 8c 24 38
	04 00 00	 mov	 rcx, QWORD PTR pLCSBAF2$[rsp]
  0028b	48 83 c1 1a	 add	 rcx, 26
  0028f	48 63 54 24 74	 movsxd	 rdx, DWORD PTR iLPDULen$[rsp]
  00294	48 8b bc 24 80
	00 00 00	 mov	 rdi, QWORD PTR pEthFrame$[rsp]
  0029c	48 8d 54 17 0e	 lea	 rdx, QWORD PTR [rdi+rdx+14]
  002a1	48 8b fa	 mov	 rdi, rdx
  002a4	48 8b f1	 mov	 rsi, rcx
  002a7	48 8b c8	 mov	 rcx, rax
  002aa	f3 a4		 rep movsb

; 5286 :         if ( iEthLen < ((IFHWADDRLEN * 2) + 2 + iLPDULen + iXIDlen) )

  002ac	8b 44 24 74	 mov	 eax, DWORD PTR iLPDULen$[rsp]
  002b0	8b 4c 24 78	 mov	 ecx, DWORD PTR iXIDlen$[rsp]
  002b4	8d 44 08 0e	 lea	 eax, DWORD PTR [rax+rcx+14]
  002b8	39 44 24 70	 cmp	 DWORD PTR iEthLen$[rsp], eax
  002bc	7d 10		 jge	 SHORT $LN17@Process_0C

; 5287 :         {
; 5288 :             iEthLen = ((IFHWADDRLEN * 2) + 2 + iLPDULen + iXIDlen);

  002be	8b 44 24 74	 mov	 eax, DWORD PTR iLPDULen$[rsp]
  002c2	8b 4c 24 78	 mov	 ecx, DWORD PTR iXIDlen$[rsp]
  002c6	8d 44 08 0e	 lea	 eax, DWORD PTR [rax+rcx+14]
  002ca	89 44 24 70	 mov	 DWORD PTR iEthLen$[rsp], eax
$LN17@Process_0C:
$LN16@Process_0C:

; 5289 :         }
; 5290 :     }
; 5291 : 
; 5292 :     // Trace Ethernet frame before sending to TAP device
; 5293 :     if (pLCSPORT->pLCSBLK->fDebug)

  002ce	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR pLCSPORT$[rsp]
  002d6	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  002da	8b 40 18	 mov	 eax, DWORD PTR [rax+24]
  002dd	83 e0 01	 and	 eax, 1
  002e0	85 c0		 test	 eax, eax
  002e2	0f 84 19 02 00
	00		 je	 $LN18@Process_0C

; 5294 :     {
; 5295 :         // "%1d:%04X %s: port %2.2X: Send frame of size %d bytes (with %s packet) to device %s"
; 5296 :         WRMSG(HHC00983, "D", SSID_TO_LCSS(pDEVBLK->ssid), pDEVBLK->devnum, pDEVBLK->typname,

  002e8	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR pLCSPORT$[rsp]
  002f0	48 05 48 01 00
	00		 add	 rax, 328		; 00000148H
  002f6	48 89 84 24 b8
	00 00 00	 mov	 QWORD PTR tv197[rsp], rax
  002fe	48 8b 8c 24 20
	04 00 00	 mov	 rcx, QWORD PTR pLCSDEV$[rsp]
  00306	0f b6 49 23	 movzx	 ecx, BYTE PTR [rcx+35]
  0030a	89 8c 24 98 00
	00 00		 mov	 DWORD PTR tv202[rsp], ecx
  00311	48 8b 94 24 88
	00 00 00	 mov	 rdx, QWORD PTR pDEVBLK$[rsp]
  00319	0f b7 52 48	 movzx	 edx, WORD PTR [rdx+72]
  0031d	89 94 24 9c 00
	00 00		 mov	 DWORD PTR tv207[rsp], edx
  00324	48 8b bc 24 88
	00 00 00	 mov	 rdi, QWORD PTR pDEVBLK$[rsp]
  0032c	0f b7 7f 44	 movzx	 edi, WORD PTR [rdi+68]
  00330	d1 ff		 sar	 edi, 1
  00332	b9 01 00 00 00	 mov	 ecx, 1
  00337	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  0033d	48 8b 8c 24 b8
	00 00 00	 mov	 rcx, QWORD PTR tv197[rsp]
  00345	48 89 4c 24 68	 mov	 QWORD PTR [rsp+104], rcx
  0034a	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG174304
  00351	48 89 4c 24 60	 mov	 QWORD PTR [rsp+96], rcx
  00356	8b 4c 24 70	 mov	 ecx, DWORD PTR iEthLen$[rsp]
  0035a	89 4c 24 58	 mov	 DWORD PTR [rsp+88], ecx
  0035e	8b 8c 24 98 00
	00 00		 mov	 ecx, DWORD PTR tv202[rsp]
  00365	89 4c 24 50	 mov	 DWORD PTR [rsp+80], ecx
  00369	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR pDEVBLK$[rsp]
  00371	48 8b 49 50	 mov	 rcx, QWORD PTR [rcx+80]
  00375	48 89 4c 24 48	 mov	 QWORD PTR [rsp+72], rcx
  0037a	8b 8c 24 9c 00
	00 00		 mov	 ecx, DWORD PTR tv207[rsp]
  00381	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  00385	89 7c 24 38	 mov	 DWORD PTR [rsp+56], edi
  00389	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG174305
  00390	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  00395	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG174306
  0039c	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  003a1	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  003a6	41 b9 03 00 00
	00		 mov	 r9d, 3
  003ac	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG174307
  003b3	ba b1 14 00 00	 mov	 edx, 5297		; 000014b1H
  003b8	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG174308
  003bf	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 5297 :                              pLCSDEV->bPort, iEthLen, "802.3 SNA", pLCSPORT->szNetIfName );
; 5298 :         if (pLCSPORT->pLCSBLK->iTraceLen)

  003c5	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR pLCSPORT$[rsp]
  003cd	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  003d1	83 78 28 00	 cmp	 DWORD PTR [rax+40], 0
  003d5	0f 84 26 01 00
	00		 je	 $LN19@Process_0C

; 5299 :         {
; 5300 :             iTraceLen = iEthLen;

  003db	8b 44 24 70	 mov	 eax, DWORD PTR iEthLen$[rsp]
  003df	89 44 24 7c	 mov	 DWORD PTR iTraceLen$[rsp], eax

; 5301 :             if (iTraceLen > pLCSPORT->pLCSBLK->iTraceLen)

  003e3	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR pLCSPORT$[rsp]
  003eb	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  003ef	8b 40 28	 mov	 eax, DWORD PTR [rax+40]
  003f2	39 44 24 7c	 cmp	 DWORD PTR iTraceLen$[rsp], eax
  003f6	0f 8e cf 00 00
	00		 jle	 $LN20@Process_0C

; 5302 :             {
; 5303 :                 iTraceLen = pLCSPORT->pLCSBLK->iTraceLen;

  003fc	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR pLCSPORT$[rsp]
  00404	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  00408	8b 40 28	 mov	 eax, DWORD PTR [rax+40]
  0040b	89 44 24 7c	 mov	 DWORD PTR iTraceLen$[rsp], eax

; 5304 :                 // HHC00980 "%1d:%04X %s: Data of size %d bytes displayed, data of size %d bytes not displayed"
; 5305 :                 WRMSG(HHC00980, "D", SSID_TO_LCSS(pDEVBLK->ssid), pDEVBLK->devnum, pDEVBLK->typname,

  0040f	8b 44 24 7c	 mov	 eax, DWORD PTR iTraceLen$[rsp]
  00413	8b 4c 24 70	 mov	 ecx, DWORD PTR iEthLen$[rsp]
  00417	2b c8		 sub	 ecx, eax
  00419	8b c1		 mov	 eax, ecx
  0041b	89 84 24 a0 00
	00 00		 mov	 DWORD PTR tv230[rsp], eax
  00422	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR pDEVBLK$[rsp]
  0042a	0f b7 49 48	 movzx	 ecx, WORD PTR [rcx+72]
  0042e	89 8c 24 a4 00
	00 00		 mov	 DWORD PTR tv236[rsp], ecx
  00435	48 8b 94 24 88
	00 00 00	 mov	 rdx, QWORD PTR pDEVBLK$[rsp]
  0043d	0f b7 52 44	 movzx	 edx, WORD PTR [rdx+68]
  00441	d1 fa		 sar	 edx, 1
  00443	89 94 24 a8 00
	00 00		 mov	 DWORD PTR tv240[rsp], edx
  0044a	b9 01 00 00 00	 mov	 ecx, 1
  0044f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  00455	8b 8c 24 a0 00
	00 00		 mov	 ecx, DWORD PTR tv230[rsp]
  0045c	89 4c 24 58	 mov	 DWORD PTR [rsp+88], ecx
  00460	8b 4c 24 7c	 mov	 ecx, DWORD PTR iTraceLen$[rsp]
  00464	89 4c 24 50	 mov	 DWORD PTR [rsp+80], ecx
  00468	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR pDEVBLK$[rsp]
  00470	48 8b 49 50	 mov	 rcx, QWORD PTR [rcx+80]
  00474	48 89 4c 24 48	 mov	 QWORD PTR [rsp+72], rcx
  00479	8b 8c 24 a4 00
	00 00		 mov	 ecx, DWORD PTR tv236[rsp]
  00480	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  00484	8b 8c 24 a8 00
	00 00		 mov	 ecx, DWORD PTR tv240[rsp]
  0048b	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  0048f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG174311
  00496	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  0049b	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG174312
  004a2	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  004a7	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  004ac	41 b9 03 00 00
	00		 mov	 r9d, 3
  004b2	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG174313
  004b9	ba ba 14 00 00	 mov	 edx, 5306		; 000014baH
  004be	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG174314
  004c5	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg
$LN20@Process_0C:

; 5306 :                                      iTraceLen, (iEthLen - iTraceLen) );
; 5307 :             }
; 5308 :             net_data_trace( pDEVBLK, (BYTE*)pEthFrame, iTraceLen, FROM_GUEST, 'D', "eth frame", 0 );

  004cb	c7 44 24 30 00
	00 00 00	 mov	 DWORD PTR [rsp+48], 0
  004d3	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG174315
  004da	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  004df	c6 44 24 20 44	 mov	 BYTE PTR [rsp+32], 68	; 00000044H
  004e4	41 b1 3c	 mov	 r9b, 60			; 0000003cH
  004e7	44 8b 44 24 7c	 mov	 r8d, DWORD PTR iTraceLen$[rsp]
  004ec	48 8b 94 24 80
	00 00 00	 mov	 rdx, QWORD PTR pEthFrame$[rsp]
  004f4	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR pDEVBLK$[rsp]
  004fc	e8 00 00 00 00	 call	 net_data_trace
$LN19@Process_0C:
$LN18@Process_0C:

; 5309 :         }
; 5310 :     }
; 5311 : 
; 5312 :     // Write the Ethernet frame to the TAP device
; 5313 :     if (TUNTAP_Write( pDEVBLK->fd, (BYTE*)pEthFrame, iEthLen ) == iEthLen)

  00501	44 8b 44 24 70	 mov	 r8d, DWORD PTR iEthLen$[rsp]
  00506	48 8b 94 24 80
	00 00 00	 mov	 rdx, QWORD PTR pEthFrame$[rsp]
  0050e	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR pDEVBLK$[rsp]
  00516	8b 88 ac 01 00
	00		 mov	 ecx, DWORD PTR [rax+428]
  0051c	e8 00 00 00 00	 call	 tt32_write
  00521	3b 44 24 70	 cmp	 eax, DWORD PTR iEthLen$[rsp]
  00525	0f 85 a4 00 00
	00		 jne	 $LN21@Process_0C

; 5314 :     {
; 5315 :         if (pLCSPORT->pLCSBLK->fDebug)

  0052b	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR pLCSPORT$[rsp]
  00533	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  00537	8b 40 18	 mov	 eax, DWORD PTR [rax+24]
  0053a	83 e0 01	 and	 eax, 1
  0053d	85 c0		 test	 eax, eax
  0053f	0f 84 85 00 00
	00		 je	 $LN23@Process_0C

; 5316 :         {
; 5317 :             snprintf( llcmsg, sizeof(llcmsg), "LCS: LLC unnumbered frame sent: CR=%u, M=%s", llc.hwCR, "XID" );

  00545	0f b7 84 24 d4
	00 00 00	 movzx	 eax, WORD PTR llc$[rsp+20]
  0054d	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG174319
  00554	48 89 4c 24 20	 mov	 QWORD PTR [rsp+32], rcx
  00559	44 8b c8	 mov	 r9d, eax
  0055c	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG174320
  00563	ba 00 01 00 00	 mov	 edx, 256		; 00000100H
  00568	48 8d 8c 24 f0
	00 00 00	 lea	 rcx, QWORD PTR llcmsg$[rsp]
  00570	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_snprintf

; 5318 :             WRMSG(HHC03984, "D", llcmsg );  /* FixMe! */

  00576	b9 01 00 00 00	 mov	 ecx, 1
  0057b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  00581	48 8d 8c 24 f0
	00 00 00	 lea	 rcx, QWORD PTR llcmsg$[rsp]
  00589	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  0058e	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG174321
  00595	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  0059a	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG174322
  005a1	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  005a6	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  005ab	41 b9 03 00 00
	00		 mov	 r9d, 3
  005b1	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG174323
  005b8	ba c6 14 00 00	 mov	 edx, 5318		; 000014c6H
  005bd	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG174324
  005c4	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg
$LN23@Process_0C:

; 5319 :         }
; 5320 :     }

  005ca	e9 82 00 00 00	 jmp	 $LN22@Process_0C
$LN21@Process_0C:

; 5321 :     else
; 5322 :     {
; 5323 :         pLCSDEV->iTuntapErrno = errno;

  005cf	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno
  005d5	48 8b 8c 24 20
	04 00 00	 mov	 rcx, QWORD PTR pLCSDEV$[rsp]
  005dd	8b 00		 mov	 eax, DWORD PTR [rax]
  005df	89 41 61	 mov	 DWORD PTR [rcx+97], eax

; 5324 :         pLCSDEV->fTuntapError = TRUE;

  005e2	48 8b 84 24 20
	04 00 00	 mov	 rax, QWORD PTR pLCSDEV$[rsp]
  005ea	8b 40 5d	 mov	 eax, DWORD PTR [rax+93]
  005ed	83 c8 10	 or	 eax, 16
  005f0	48 8b 8c 24 20
	04 00 00	 mov	 rcx, QWORD PTR pLCSDEV$[rsp]
  005f8	89 41 5d	 mov	 DWORD PTR [rcx+93], eax
$LN13@Process_0C:

; 5325 :         PTT_TIMING( "*WRITE ERR", 0, iEthLen, 1 );

  005fb	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_pttclass
  00602	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00605	48 25 00 00 01
	00		 and	 rax, 65536		; 00010000H
  0060b	48 85 c0	 test	 rax, rax
  0060e	74 3b		 je	 SHORT $LN24@Process_0C
  00610	48 63 44 24 70	 movsxd	 rax, DWORD PTR iEthLen$[rsp]
  00615	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR [rsp+48], 0
  0061e	48 c7 44 24 28
	01 00 00 00	 mov	 QWORD PTR [rsp+40], 1
  00627	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG174326
  0062e	48 89 4c 24 20	 mov	 QWORD PTR [rsp+32], rcx
  00633	4c 8b c8	 mov	 r9, rax
  00636	45 33 c0	 xor	 r8d, r8d
  00639	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG174327
  00640	b9 00 00 01 00	 mov	 ecx, 65536		; 00010000H
  00645	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ptt_pthread_trace
$LN24@Process_0C:
  0064b	33 c0		 xor	 eax, eax
  0064d	85 c0		 test	 eax, eax
  0064f	75 aa		 jne	 SHORT $LN13@Process_0C
$LN22@Process_0C:
$LN1@Process_0C:

; 5326 :     }
; 5327 : 
; 5328 :     return;
; 5329 : }

  00651	48 8b 8c 24 f0
	03 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  00659	48 33 cc	 xor	 rcx, rsp
  0065c	e8 00 00 00 00	 call	 __security_check_cookie
  00661	48 81 c4 08 04
	00 00		 add	 rsp, 1032		; 00000408H
  00668	5f		 pop	 rdi
  00669	5e		 pop	 rsi
  0066a	c3		 ret	 0
Process_0C22 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\ctc_lcs.c
_TEXT	SEGMENT
iEthLen$ = 112
pEthFrame$ = 120
pDEVBLK$ = 128
iLPDULen$ = 136
tv174 = 140
tv179 = 144
pLCSPORT$ = 152
pLCSCONN$ = 160
tv169 = 168
llc$ = 176
frame$ = 224
llcmsg$ = 288
__$ArrayPad$ = 544
pLCSDEV$ = 592
pLCSHDR$ = 600
pLCSBAF1$ = 608
pLCSBAF2$ = 616
hwLenBaf1$ = 624
hwLenBaf2$ = 632
Process_0C25 PROC

; 5133 : {

  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	56		 push	 rsi
  00015	57		 push	 rdi
  00016	48 81 ec 38 02
	00 00		 sub	 rsp, 568		; 00000238H
  0001d	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00024	48 33 c4	 xor	 rax, rsp
  00027	48 89 84 24 20
	02 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax
$LN4@Process_0C:

; 5134 : //                   Token
; 5135 : //  000D0C25001B6004 400000DC 00
; 5136 : //  0 1 2 3 4 5 6 7  8 9 A B  C
; 5137 : //                         DMAC         SMAC         LLC    Filler
; 5138 : //  0100000000030000000000 000CCE4B4740 400074700001 000400 xx
; 5139 : //  0 1 2 3 4 5 6 7 8 9 A  B C D E F 0  1 2 3 4 5 6  7 8 9
; 5140 : 
; 5141 :     DEVBLK*   pDEVBLK;
; 5142 :     PLCSPORT  pLCSPORT;
; 5143 :     PLCSCONN  pLCSCONN;
; 5144 :     int       iLPDULen;
; 5145 :     LLC       llc;
; 5146 :     PETHFRM   pEthFrame;
; 5147 :     int       iEthLen;
; 5148 :     BYTE      frame[64];
; 5149 :     char      llcmsg[256];
; 5150 : 
; 5151 :     UNREFERENCED( pLCSHDR   );

  0002f	33 c0		 xor	 eax, eax
  00031	85 c0		 test	 eax, eax
  00033	75 fa		 jne	 SHORT $LN4@Process_0C
$LN7@Process_0C:

; 5152 :     UNREFERENCED( pLCSBAF1  );

  00035	33 c0		 xor	 eax, eax
  00037	85 c0		 test	 eax, eax
  00039	75 fa		 jne	 SHORT $LN7@Process_0C
$LN10@Process_0C:

; 5153 :     UNREFERENCED( hwLenBaf1 );

  0003b	33 c0		 xor	 eax, eax
  0003d	85 c0		 test	 eax, eax
  0003f	75 fa		 jne	 SHORT $LN10@Process_0C
$LN13@Process_0C:

; 5154 :     UNREFERENCED( hwLenBaf2 );

  00041	33 c0		 xor	 eax, eax
  00043	85 c0		 test	 eax, eax
  00045	75 fa		 jne	 SHORT $LN13@Process_0C

; 5155 : 
; 5156 :     pDEVBLK = pLCSDEV->pDEVBLK[ LCS_READ_SUBCHANN ];

  00047	b8 08 00 00 00	 mov	 eax, 8
  0004c	48 6b c0 00	 imul	 rax, rax, 0
  00050	48 8b 8c 24 50
	02 00 00	 mov	 rcx, QWORD PTR pLCSDEV$[rsp]
  00058	48 8b 44 01 10	 mov	 rax, QWORD PTR [rcx+rax+16]
  0005d	48 89 84 24 80
	00 00 00	 mov	 QWORD PTR pDEVBLK$[rsp], rax

; 5157 :     pLCSPORT = &pLCSDEV->pLCSBLK->Port[pLCSDEV->bPort];

  00065	48 8b 84 24 50
	02 00 00	 mov	 rax, QWORD PTR pLCSDEV$[rsp]
  0006d	48 8b 40 08	 mov	 rax, QWORD PTR [rax+8]
  00071	48 8b 8c 24 50
	02 00 00	 mov	 rcx, QWORD PTR pLCSDEV$[rsp]
  00079	0f b6 49 23	 movzx	 ecx, BYTE PTR [rcx+35]
  0007d	48 69 c9 98 01
	00 00		 imul	 rcx, rcx, 408		; 00000198H
  00084	48 8d 44 08 60	 lea	 rax, QWORD PTR [rax+rcx+96]
  00089	48 89 84 24 98
	00 00 00	 mov	 QWORD PTR pLCSPORT$[rsp], rax

; 5158 :     memset( frame, 0, sizeof(frame) );                               // Clear area for ethernet fram

  00091	48 8d 84 24 e0
	00 00 00	 lea	 rax, QWORD PTR frame$[rsp]
  00099	48 8b f8	 mov	 rdi, rax
  0009c	33 c0		 xor	 eax, eax
  0009e	b9 40 00 00 00	 mov	 ecx, 64			; 00000040H
  000a3	f3 aa		 rep stosb

; 5159 :     pEthFrame = (PETHFRM)&frame[0];

  000a5	b8 01 00 00 00	 mov	 eax, 1
  000aa	48 6b c0 00	 imul	 rax, rax, 0
  000ae	48 8d 84 04 e0
	00 00 00	 lea	 rax, QWORD PTR frame$[rsp+rax]
  000b6	48 89 44 24 78	 mov	 QWORD PTR pEthFrame$[rsp], rax

; 5160 :     iEthLen = 60;                                                    // Minimum ethernet frame length

  000bb	c7 44 24 70 3c
	00 00 00	 mov	 DWORD PTR iEthLen$[rsp], 60 ; 0000003cH

; 5161 : 
; 5162 :     // Find the connection block.
; 5163 :     pLCSCONN = find_connection_by_remote_mac( pLCSDEV, (MAC*)&pLCSBAF2->bByte11 );

  000c3	48 8b 84 24 68
	02 00 00	 mov	 rax, QWORD PTR pLCSBAF2$[rsp]
  000cb	48 83 c0 0b	 add	 rax, 11
  000cf	48 8b d0	 mov	 rdx, rax
  000d2	48 8b 8c 24 50
	02 00 00	 mov	 rcx, QWORD PTR pLCSDEV$[rsp]
  000da	e8 00 00 00 00	 call	 find_connection_by_remote_mac
  000df	48 89 84 24 a0
	00 00 00	 mov	 QWORD PTR pLCSCONN$[rsp], rax

; 5164 :     if (!pLCSCONN)

  000e7	48 83 bc 24 a0
	00 00 00 00	 cmp	 QWORD PTR pLCSCONN$[rsp], 0
  000f0	75 58		 jne	 SHORT $LN17@Process_0C

; 5165 :     {
; 5166 :         WRMSG( HHC03984, "W", "LCSCONN not found");

  000f2	b9 01 00 00 00	 mov	 ecx, 1
  000f7	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  000fd	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG174221
  00104	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  00109	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG174222
  00110	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  00115	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG174223
  0011c	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00121	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00126	41 b9 03 00 00
	00		 mov	 r9d, 3
  0012c	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG174224
  00133	ba 2e 14 00 00	 mov	 edx, 5166		; 0000142eH
  00138	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG174225
  0013f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 5167 :         /* FixMe! Need a proper error message here! */
; 5168 :         return;

  00145	e9 4c 03 00 00	 jmp	 $LN1@Process_0C
$LN17@Process_0C:

; 5169 :     }
; 5170 : 
; 5171 :     //
; 5172 :     memset( &llc, 0, sizeof(LLC) );

  0014a	48 8d 84 24 b0
	00 00 00	 lea	 rax, QWORD PTR llc$[rsp]
  00152	48 8b f8	 mov	 rdi, rax
  00155	33 c0		 xor	 eax, eax
  00157	b9 2e 00 00 00	 mov	 ecx, 46			; 0000002eH
  0015c	f3 aa		 rep stosb

; 5173 :     llc.hwDSAP    = pLCSBAF2->bByte23;                               // Copy LLC DSAP

  0015e	48 8b 84 24 68
	02 00 00	 mov	 rax, QWORD PTR pLCSBAF2$[rsp]
  00166	0f b6 40 17	 movzx	 eax, BYTE PTR [rax+23]
  0016a	66 89 84 24 be
	00 00 00	 mov	 WORD PTR llc$[rsp+14], ax

; 5174 :     llc.hwSSAP    = pLCSBAF2->bByte24;                               // Copy LLC SSAP

  00172	48 8b 84 24 68
	02 00 00	 mov	 rax, QWORD PTR pLCSBAF2$[rsp]
  0017a	0f b6 40 18	 movzx	 eax, BYTE PTR [rax+24]
  0017e	66 89 84 24 c2
	00 00 00	 mov	 WORD PTR llc$[rsp+18], ax

; 5175 :     llc.hwPF      = 1;

  00186	b8 01 00 00 00	 mov	 eax, 1
  0018b	66 89 84 24 ca
	00 00 00	 mov	 WORD PTR llc$[rsp+26], ax

; 5176 :     llc.hwM       = M_TEST_Command_or_Response;

  00193	b8 1c 00 00 00	 mov	 eax, 28
  00198	66 89 84 24 ce
	00 00 00	 mov	 WORD PTR llc$[rsp+30], ax

; 5177 :     llc.hwType    = Type_Unnumbered_Frame;

  001a0	b8 03 00 00 00	 mov	 eax, 3
  001a5	66 89 84 24 dc
	00 00 00	 mov	 WORD PTR llc$[rsp+44], ax

; 5178 : 
; 5179 :     // Construct Ethernet frame
; 5180 :     memcpy( &pEthFrame->bDestMAC, &pLCSBAF2->bByte11, IFHWADDRLEN ); // Copy destination MAC address

  001ad	48 8b 84 24 68
	02 00 00	 mov	 rax, QWORD PTR pLCSBAF2$[rsp]
  001b5	48 8b 7c 24 78	 mov	 rdi, QWORD PTR pEthFrame$[rsp]
  001ba	48 8d 70 0b	 lea	 rsi, QWORD PTR [rax+11]
  001be	b9 06 00 00 00	 mov	 ecx, 6
  001c3	f3 a4		 rep movsb

; 5181 :     memcpy( &pEthFrame->bSrcMAC, &pLCSBAF2->bByte17, IFHWADDRLEN );  // Copy source MAC address

  001c5	48 8b 44 24 78	 mov	 rax, QWORD PTR pEthFrame$[rsp]
  001ca	48 8b 8c 24 68
	02 00 00	 mov	 rcx, QWORD PTR pLCSBAF2$[rsp]
  001d2	48 8d 78 06	 lea	 rdi, QWORD PTR [rax+6]
  001d6	48 8d 71 11	 lea	 rsi, QWORD PTR [rcx+17]
  001da	b9 06 00 00 00	 mov	 ecx, 6
  001df	f3 a4		 rep movsb

; 5182 :     iLPDULen = BuildLLC( &llc, pEthFrame->bData);                    // Build LLC PDU

  001e1	48 8b 44 24 78	 mov	 rax, QWORD PTR pEthFrame$[rsp]
  001e6	48 83 c0 0e	 add	 rax, 14
  001ea	48 8b d0	 mov	 rdx, rax
  001ed	48 8d 8c 24 b0
	00 00 00	 lea	 rcx, QWORD PTR llc$[rsp]
  001f5	e8 00 00 00 00	 call	 BuildLLC
  001fa	89 84 24 88 00
	00 00		 mov	 DWORD PTR iLPDULen$[rsp], eax

; 5183 :     STORE_HW( pEthFrame->hwEthernetType, (U16)iLPDULen );            // Set data length

  00201	0f b7 8c 24 88
	00 00 00	 movzx	 ecx, WORD PTR iLPDULen$[rsp]
  00209	e8 00 00 00 00	 call	 _byteswap_ushort
  0020e	48 8b 4c 24 78	 mov	 rcx, QWORD PTR pEthFrame$[rsp]
  00213	48 83 c1 0c	 add	 rcx, 12
  00217	0f b7 d0	 movzx	 edx, ax
  0021a	e8 00 00 00 00	 call	 store_hw_noswap

; 5184 : 
; 5185 :     // Trace Ethernet frame before sending to TAP device
; 5186 :     if (pLCSPORT->pLCSBLK->fDebug)

  0021f	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR pLCSPORT$[rsp]
  00227	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  0022b	8b 40 18	 mov	 eax, DWORD PTR [rax+24]
  0022e	83 e0 01	 and	 eax, 1
  00231	85 c0		 test	 eax, eax
  00233	0f 84 10 01 00
	00		 je	 $LN18@Process_0C

; 5187 :     {
; 5188 :         // "%1d:%04X %s: port %2.2X: Send frame of size %d bytes (with %s packet) to device %s"
; 5189 :         WRMSG(HHC00983, "D", SSID_TO_LCSS(pDEVBLK->ssid), pDEVBLK->devnum, pDEVBLK->typname,

  00239	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR pLCSPORT$[rsp]
  00241	48 05 48 01 00
	00		 add	 rax, 328		; 00000148H
  00247	48 89 84 24 a8
	00 00 00	 mov	 QWORD PTR tv169[rsp], rax
  0024f	48 8b 8c 24 50
	02 00 00	 mov	 rcx, QWORD PTR pLCSDEV$[rsp]
  00257	0f b6 49 23	 movzx	 ecx, BYTE PTR [rcx+35]
  0025b	89 8c 24 8c 00
	00 00		 mov	 DWORD PTR tv174[rsp], ecx
  00262	48 8b 94 24 80
	00 00 00	 mov	 rdx, QWORD PTR pDEVBLK$[rsp]
  0026a	0f b7 52 48	 movzx	 edx, WORD PTR [rdx+72]
  0026e	89 94 24 90 00
	00 00		 mov	 DWORD PTR tv179[rsp], edx
  00275	48 8b bc 24 80
	00 00 00	 mov	 rdi, QWORD PTR pDEVBLK$[rsp]
  0027d	0f b7 7f 44	 movzx	 edi, WORD PTR [rdi+68]
  00281	d1 ff		 sar	 edi, 1
  00283	b9 01 00 00 00	 mov	 ecx, 1
  00288	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  0028e	48 8b 8c 24 a8
	00 00 00	 mov	 rcx, QWORD PTR tv169[rsp]
  00296	48 89 4c 24 68	 mov	 QWORD PTR [rsp+104], rcx
  0029b	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG174227
  002a2	48 89 4c 24 60	 mov	 QWORD PTR [rsp+96], rcx
  002a7	8b 4c 24 70	 mov	 ecx, DWORD PTR iEthLen$[rsp]
  002ab	89 4c 24 58	 mov	 DWORD PTR [rsp+88], ecx
  002af	8b 8c 24 8c 00
	00 00		 mov	 ecx, DWORD PTR tv174[rsp]
  002b6	89 4c 24 50	 mov	 DWORD PTR [rsp+80], ecx
  002ba	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR pDEVBLK$[rsp]
  002c2	48 8b 49 50	 mov	 rcx, QWORD PTR [rcx+80]
  002c6	48 89 4c 24 48	 mov	 QWORD PTR [rsp+72], rcx
  002cb	8b 8c 24 90 00
	00 00		 mov	 ecx, DWORD PTR tv179[rsp]
  002d2	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  002d6	89 7c 24 38	 mov	 DWORD PTR [rsp+56], edi
  002da	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG174228
  002e1	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  002e6	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG174229
  002ed	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  002f2	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  002f7	41 b9 03 00 00
	00		 mov	 r9d, 3
  002fd	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG174230
  00304	ba 46 14 00 00	 mov	 edx, 5190		; 00001446H
  00309	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG174231
  00310	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 5190 :                              pLCSDEV->bPort, iEthLen, "802.3 SNA", pLCSPORT->szNetIfName );
; 5191 :         net_data_trace( pDEVBLK, (BYTE*)pEthFrame, iEthLen, FROM_GUEST, 'D', "eth frame", 0 );

  00316	c7 44 24 30 00
	00 00 00	 mov	 DWORD PTR [rsp+48], 0
  0031e	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG174232
  00325	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  0032a	c6 44 24 20 44	 mov	 BYTE PTR [rsp+32], 68	; 00000044H
  0032f	41 b1 3c	 mov	 r9b, 60			; 0000003cH
  00332	44 8b 44 24 70	 mov	 r8d, DWORD PTR iEthLen$[rsp]
  00337	48 8b 54 24 78	 mov	 rdx, QWORD PTR pEthFrame$[rsp]
  0033c	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR pDEVBLK$[rsp]
  00344	e8 00 00 00 00	 call	 net_data_trace
$LN18@Process_0C:

; 5192 :     }
; 5193 : 
; 5194 :     // Write the Ethernet frame to the TAP device
; 5195 :     if (TUNTAP_Write( pDEVBLK->fd, (BYTE*)pEthFrame, iEthLen ) == iEthLen)

  00349	44 8b 44 24 70	 mov	 r8d, DWORD PTR iEthLen$[rsp]
  0034e	48 8b 54 24 78	 mov	 rdx, QWORD PTR pEthFrame$[rsp]
  00353	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR pDEVBLK$[rsp]
  0035b	8b 88 ac 01 00
	00		 mov	 ecx, DWORD PTR [rax+428]
  00361	e8 00 00 00 00	 call	 tt32_write
  00366	3b 44 24 70	 cmp	 eax, DWORD PTR iEthLen$[rsp]
  0036a	0f 85 a4 00 00
	00		 jne	 $LN19@Process_0C

; 5196 :     {
; 5197 :         if (pLCSPORT->pLCSBLK->fDebug)

  00370	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR pLCSPORT$[rsp]
  00378	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  0037c	8b 40 18	 mov	 eax, DWORD PTR [rax+24]
  0037f	83 e0 01	 and	 eax, 1
  00382	85 c0		 test	 eax, eax
  00384	0f 84 85 00 00
	00		 je	 $LN21@Process_0C

; 5198 :         {
; 5199 :             snprintf( llcmsg, sizeof(llcmsg), "LCS: LLC unnumbered frame sent: CR=%u, M=%s", llc.hwCR, "TEST" );

  0038a	0f b7 84 24 c4
	00 00 00	 movzx	 eax, WORD PTR llc$[rsp+20]
  00392	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG174236
  00399	48 89 4c 24 20	 mov	 QWORD PTR [rsp+32], rcx
  0039e	44 8b c8	 mov	 r9d, eax
  003a1	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG174237
  003a8	ba 00 01 00 00	 mov	 edx, 256		; 00000100H
  003ad	48 8d 8c 24 20
	01 00 00	 lea	 rcx, QWORD PTR llcmsg$[rsp]
  003b5	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_snprintf

; 5200 :             WRMSG(HHC03984, "D", llcmsg );  /* FixMe! */

  003bb	b9 01 00 00 00	 mov	 ecx, 1
  003c0	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  003c6	48 8d 8c 24 20
	01 00 00	 lea	 rcx, QWORD PTR llcmsg$[rsp]
  003ce	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  003d3	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG174238
  003da	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  003df	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG174239
  003e6	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  003eb	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  003f0	41 b9 03 00 00
	00		 mov	 r9d, 3
  003f6	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG174240
  003fd	ba 50 14 00 00	 mov	 edx, 5200		; 00001450H
  00402	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG174241
  00409	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg
$LN21@Process_0C:

; 5201 :         }
; 5202 :     }

  0040f	e9 82 00 00 00	 jmp	 $LN20@Process_0C
$LN19@Process_0C:

; 5203 :     else
; 5204 :     {
; 5205 :         pLCSDEV->iTuntapErrno = errno;

  00414	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno
  0041a	48 8b 8c 24 50
	02 00 00	 mov	 rcx, QWORD PTR pLCSDEV$[rsp]
  00422	8b 00		 mov	 eax, DWORD PTR [rax]
  00424	89 41 61	 mov	 DWORD PTR [rcx+97], eax

; 5206 :         pLCSDEV->fTuntapError = TRUE;

  00427	48 8b 84 24 50
	02 00 00	 mov	 rax, QWORD PTR pLCSDEV$[rsp]
  0042f	8b 40 5d	 mov	 eax, DWORD PTR [rax+93]
  00432	83 c8 10	 or	 eax, 16
  00435	48 8b 8c 24 50
	02 00 00	 mov	 rcx, QWORD PTR pLCSDEV$[rsp]
  0043d	89 41 5d	 mov	 DWORD PTR [rcx+93], eax
$LN16@Process_0C:

; 5207 :         PTT_TIMING( "*WRITE ERR", 0, iEthLen, 1 );

  00440	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_pttclass
  00447	48 8b 00	 mov	 rax, QWORD PTR [rax]
  0044a	48 25 00 00 01
	00		 and	 rax, 65536		; 00010000H
  00450	48 85 c0	 test	 rax, rax
  00453	74 3b		 je	 SHORT $LN22@Process_0C
  00455	48 63 44 24 70	 movsxd	 rax, DWORD PTR iEthLen$[rsp]
  0045a	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR [rsp+48], 0
  00463	48 c7 44 24 28
	01 00 00 00	 mov	 QWORD PTR [rsp+40], 1
  0046c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG174243
  00473	48 89 4c 24 20	 mov	 QWORD PTR [rsp+32], rcx
  00478	4c 8b c8	 mov	 r9, rax
  0047b	45 33 c0	 xor	 r8d, r8d
  0047e	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG174244
  00485	b9 00 00 01 00	 mov	 ecx, 65536		; 00010000H
  0048a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ptt_pthread_trace
$LN22@Process_0C:
  00490	33 c0		 xor	 eax, eax
  00492	85 c0		 test	 eax, eax
  00494	75 aa		 jne	 SHORT $LN16@Process_0C
$LN20@Process_0C:
$LN1@Process_0C:

; 5208 :     }
; 5209 : 
; 5210 :     return;
; 5211 : }

  00496	48 8b 8c 24 20
	02 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  0049e	48 33 cc	 xor	 rcx, rsp
  004a1	e8 00 00 00 00	 call	 __security_check_cookie
  004a6	48 81 c4 38 02
	00 00		 add	 rsp, 568		; 00000238H
  004ad	5f		 pop	 rdi
  004ae	5e		 pop	 rsi
  004af	c3		 ret	 0
Process_0C25 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\ctc_lcs.c
_TEXT	SEGMENT
hwLenInBaf1$ = 64
pLCSCONN$ = 72
pDEVBLK$ = 80
pInBAF1$ = 88
pLCSIBH$ = 96
pLCSPORT$ = 104
pInHDR$ = 112
pInBAF2$ = 120
pLCSDEV$ = 160
pOutHDR$ = 168
pOutBAF1$ = 176
pOutBAF2$ = 184
hwLenOutBaf1$ = 192
hwLenOutBaf2$ = 200
Process_0C0A PROC

; 4983 : {

  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	56		 push	 rsi
  00015	57		 push	 rdi
  00016	48 81 ec 88 00
	00 00		 sub	 rsp, 136		; 00000088H
$LN4@Process_0C:

; 4984 : #define INBOUND_CC0A_SIZE 36
; 4985 : static const BYTE Inbound_CC0A[INBOUND_CC0A_SIZE] =
; 4986 :                  {
; 4987 :                    0x00, 0x24, 0x04, 0x00,                           /* LCSHDR  */
; 4988 :                    0x00, 0x1C, 0xCC, 0x0A, 0x00, 0x03, 0x60, 0x01,   /* LCSBAF1 */
; 4989 :                    0xff, 0xff, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00,
; 4990 :                    0x00, 0x00, 0x70, 0x00, 0x00, 0x00, 0x00, 0x00,
; 4991 :                    0xff, 0xff, 0xff, 0xff,
; 4992 :                    0x01, 0xff, 0xff,                                 /* LCSBAF2 */
; 4993 :                    0x00                                              /* Filler  */
; 4994 :                  };
; 4995 : 
; 4996 :     DEVBLK*     pDEVBLK;
; 4997 :     PLCSPORT    pLCSPORT;
; 4998 :     PLCSCONN    pLCSCONN;
; 4999 :     PLCSIBH     pLCSIBH;
; 5000 :     PLCSHDR     pInHDR;
; 5001 :     PLCSBAF1    pInBAF1;
; 5002 :     PLCSBAF2    pInBAF2;
; 5003 :     U16         hwLenInBaf1;
; 5004 : //  U16         hwLenInBaf2;
; 5005 : 
; 5006 :     UNREFERENCED( pOutHDR      );

  0001d	33 c0		 xor	 eax, eax
  0001f	85 c0		 test	 eax, eax
  00021	75 fa		 jne	 SHORT $LN4@Process_0C
$LN7@Process_0C:

; 5007 :     UNREFERENCED( pOutBAF1     );

  00023	33 c0		 xor	 eax, eax
  00025	85 c0		 test	 eax, eax
  00027	75 fa		 jne	 SHORT $LN7@Process_0C
$LN10@Process_0C:

; 5008 :     UNREFERENCED( hwLenOutBaf1 );

  00029	33 c0		 xor	 eax, eax
  0002b	85 c0		 test	 eax, eax
  0002d	75 fa		 jne	 SHORT $LN10@Process_0C
$LN13@Process_0C:

; 5009 :     UNREFERENCED( hwLenOutBaf2 );

  0002f	33 c0		 xor	 eax, eax
  00031	85 c0		 test	 eax, eax
  00033	75 fa		 jne	 SHORT $LN13@Process_0C

; 5010 : 
; 5011 :     pDEVBLK = pLCSDEV->pDEVBLK[ LCS_READ_SUBCHANN ];

  00035	b8 08 00 00 00	 mov	 eax, 8
  0003a	48 6b c0 00	 imul	 rax, rax, 0
  0003e	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR pLCSDEV$[rsp]
  00046	48 8b 44 01 10	 mov	 rax, QWORD PTR [rcx+rax+16]
  0004b	48 89 44 24 50	 mov	 QWORD PTR pDEVBLK$[rsp], rax

; 5012 :     pLCSPORT = &pLCSDEV->pLCSBLK->Port[ pLCSDEV->bPort ];

  00050	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR pLCSDEV$[rsp]
  00058	48 8b 40 08	 mov	 rax, QWORD PTR [rax+8]
  0005c	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR pLCSDEV$[rsp]
  00064	0f b6 49 23	 movzx	 ecx, BYTE PTR [rcx+35]
  00068	48 69 c9 98 01
	00 00		 imul	 rcx, rcx, 408		; 00000198H
  0006f	48 8d 44 08 60	 lea	 rax, QWORD PTR [rax+rcx+96]
  00074	48 89 44 24 68	 mov	 QWORD PTR pLCSPORT$[rsp], rax

; 5013 : 
; 5014 :     // Find the connection block.
; 5015 :     pLCSCONN = find_connection_by_remote_mac( pLCSDEV, (MAC*)&pOutBAF2->bByte03 );

  00079	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR pOutBAF2$[rsp]
  00081	48 83 c0 03	 add	 rax, 3
  00085	48 8b d0	 mov	 rdx, rax
  00088	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR pLCSDEV$[rsp]
  00090	e8 00 00 00 00	 call	 find_connection_by_remote_mac
  00095	48 89 44 24 48	 mov	 QWORD PTR pLCSCONN$[rsp], rax

; 5016 :     if (!pLCSCONN)  // There isn't an existing LCSCONN.

  0009a	48 83 7c 24 48
	00		 cmp	 QWORD PTR pLCSCONN$[rsp], 0
  000a0	0f 85 71 01 00
	00		 jne	 $LN14@Process_0C

; 5017 :     {
; 5018 :         // Create the LCSCONN for the new outbound connection.
; 5019 :         pLCSCONN = alloc_connection( pLCSDEV );

  000a6	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR pLCSDEV$[rsp]
  000ae	e8 00 00 00 00	 call	 alloc_connection
  000b3	48 89 44 24 48	 mov	 QWORD PTR pLCSCONN$[rsp], rax

; 5020 :         pLCSCONN->hwCreated = LCSCONN_CREATED_OUTBOUND;

  000b8	b8 02 00 00 00	 mov	 eax, 2
  000bd	48 8b 4c 24 48	 mov	 rcx, QWORD PTR pLCSCONN$[rsp]
  000c2	66 89 41 1c	 mov	 WORD PTR [rcx+28], ax

; 5021 : 
; 5022 :         memcpy( &pLCSCONN->bLocalMAC, &pLCSPORT->MAC_Address, IFHWADDRLEN );

  000c6	48 8b 44 24 48	 mov	 rax, QWORD PTR pLCSCONN$[rsp]
  000cb	48 8b 4c 24 68	 mov	 rcx, QWORD PTR pLCSPORT$[rsp]
  000d0	48 8d 78 10	 lea	 rdi, QWORD PTR [rax+16]
  000d4	48 8d 71 02	 lea	 rsi, QWORD PTR [rcx+2]
  000d8	b9 06 00 00 00	 mov	 ecx, 6
  000dd	f3 a4		 rep movsb

; 5023 : #if !defined( OPTION_TUNTAP_LCS_SAME_ADDR )
; 5024 :         pLCSCONN->bLocalMAC[5]++;
; 5025 : #endif
; 5026 :         memcpy( &pLCSCONN->bRemoteMAC, &pOutBAF2->bByte03, IFHWADDRLEN );

  000df	48 8b 44 24 48	 mov	 rax, QWORD PTR pLCSCONN$[rsp]
  000e4	48 8b 8c 24 b8
	00 00 00	 mov	 rcx, QWORD PTR pOutBAF2$[rsp]
  000ec	48 8d 78 16	 lea	 rdi, QWORD PTR [rax+22]
  000f0	48 8d 71 03	 lea	 rsi, QWORD PTR [rcx+3]
  000f4	b9 06 00 00 00	 mov	 ecx, 6
  000f9	f3 a4		 rep movsb

; 5027 : 
; 5028 :         memcpy( &pLCSCONN->bInToken, &pOutBAF1->bTokenB, sizeof(pLCSCONN->bInToken) );  // Copy Inbound token

  000fb	48 8b 44 24 48	 mov	 rax, QWORD PTR pLCSCONN$[rsp]
  00100	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR pOutBAF1$[rsp]
  00108	8b 49 0c	 mov	 ecx, DWORD PTR [rcx+12]
  0010b	89 48 08	 mov	 DWORD PTR [rax+8], ecx

; 5029 :         obtain_lock( &TokenLock );

  0010e	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG174128
  00115	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:TokenLock
  0011c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_obtain_lock

; 5030 :         STORE_FW( pLCSCONN->bOutToken, uToken );                                        // Outbound token

  00122	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR uToken
  00128	e8 00 00 00 00	 call	 _byteswap_ulong
  0012d	48 8b 4c 24 48	 mov	 rcx, QWORD PTR pLCSCONN$[rsp]
  00132	48 83 c1 0c	 add	 rcx, 12
  00136	8b d0		 mov	 edx, eax
  00138	e8 00 00 00 00	 call	 store_fw_noswap

; 5031 :         uToken += INCREMENT_TOKEN;

  0013d	8b 05 00 00 00
	00		 mov	 eax, DWORD PTR uToken
  00143	05 00 01 00 00	 add	 eax, 256		; 00000100H
  00148	89 05 00 00 00
	00		 mov	 DWORD PTR uToken, eax

; 5032 :         release_lock( &TokenLock );

  0014e	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG174129
  00155	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:TokenLock
  0015c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_release_lock

; 5033 : 
; 5034 :         if (pLCSDEV->pLCSBLK->fDebug)

  00162	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR pLCSDEV$[rsp]
  0016a	48 8b 40 08	 mov	 rax, QWORD PTR [rax+8]
  0016e	8b 40 18	 mov	 eax, DWORD PTR [rax+24]
  00171	83 e0 01	 and	 eax, 1
  00174	85 c0		 test	 eax, eax
  00176	0f 84 84 00 00
	00		 je	 $LN16@Process_0C

; 5035 :         {
; 5036 :             WRMSG( HHC03984, "I", "Created LCSCONN Outbound");

  0017c	b9 01 00 00 00	 mov	 ecx, 1
  00181	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  00187	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG174131
  0018e	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  00193	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG174132
  0019a	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  0019f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG174133
  001a6	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  001ab	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  001b0	41 b9 03 00 00
	00		 mov	 r9d, 3
  001b6	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG174134
  001bd	ba ac 13 00 00	 mov	 edx, 5036		; 000013acH
  001c2	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG174135
  001c9	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 5037 :             net_data_trace( pDEVBLK, (BYTE*)pLCSCONN, sizeof(LCSCONN), NO_DIRECTION, 'D', "LCSCONN", 0 );

  001cf	c7 44 24 30 00
	00 00 00	 mov	 DWORD PTR [rsp+48], 0
  001d7	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG174136
  001de	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  001e3	c6 44 24 20 44	 mov	 BYTE PTR [rsp+32], 68	; 00000044H
  001e8	41 b1 20	 mov	 r9b, 32			; 00000020H
  001eb	41 b8 30 00 00
	00		 mov	 r8d, 48			; 00000030H
  001f1	48 8b 54 24 48	 mov	 rdx, QWORD PTR pLCSCONN$[rsp]
  001f6	48 8b 4c 24 50	 mov	 rcx, QWORD PTR pDEVBLK$[rsp]
  001fb	e8 00 00 00 00	 call	 net_data_trace
$LN16@Process_0C:

; 5038 :         }
; 5039 : 
; 5040 :         add_connection_to_chain( pLCSDEV, pLCSCONN );

  00200	48 8b 54 24 48	 mov	 rdx, QWORD PTR pLCSCONN$[rsp]
  00205	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR pLCSDEV$[rsp]
  0020d	e8 00 00 00 00	 call	 add_connection_to_chain

; 5041 :     }

  00212	e9 f1 03 00 00	 jmp	 $LN15@Process_0C
$LN14@Process_0C:

; 5042 :     else  // There is an existing LCSCONN.
; 5043 :     {
; 5044 :         if ( pLCSCONN->hwCreated == LCSCONN_CREATED_INBOUND )  // The existing LSCCONN is for an inbound connection.

  00217	48 8b 44 24 48	 mov	 rax, QWORD PTR pLCSCONN$[rsp]
  0021c	0f b7 40 1c	 movzx	 eax, WORD PTR [rax+28]
  00220	83 f8 01	 cmp	 eax, 1
  00223	0f 85 a8 01 00
	00		 jne	 $LN17@Process_0C

; 5045 :         {
; 5046 :             if (pLCSDEV->pLCSBLK->fDebug)

  00229	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR pLCSDEV$[rsp]
  00231	48 8b 40 08	 mov	 rax, QWORD PTR [rax+8]
  00235	8b 40 18	 mov	 eax, DWORD PTR [rax+24]
  00238	83 e0 01	 and	 eax, 1
  0023b	85 c0		 test	 eax, eax
  0023d	0f 84 84 00 00
	00		 je	 $LN19@Process_0C

; 5047 :             {
; 5048 :                 WRMSG( HHC03984, "I", "Found LCSCONN Inbound");

  00243	b9 01 00 00 00	 mov	 ecx, 1
  00248	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  0024e	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG174140
  00255	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  0025a	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG174141
  00261	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  00266	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG174142
  0026d	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00272	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00277	41 b9 03 00 00
	00		 mov	 r9d, 3
  0027d	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG174143
  00284	ba b8 13 00 00	 mov	 edx, 5048		; 000013b8H
  00289	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG174144
  00290	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 5049 :                 net_data_trace( pDEVBLK, (BYTE*)pLCSCONN, sizeof(LCSCONN), NO_DIRECTION, 'D', "LCSCONN", 0 );

  00296	c7 44 24 30 00
	00 00 00	 mov	 DWORD PTR [rsp+48], 0
  0029e	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG174145
  002a5	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  002aa	c6 44 24 20 44	 mov	 BYTE PTR [rsp+32], 68	; 00000044H
  002af	41 b1 20	 mov	 r9b, 32			; 00000020H
  002b2	41 b8 30 00 00
	00		 mov	 r8d, 48			; 00000030H
  002b8	48 8b 54 24 48	 mov	 rdx, QWORD PTR pLCSCONN$[rsp]
  002bd	48 8b 4c 24 50	 mov	 rcx, QWORD PTR pDEVBLK$[rsp]
  002c2	e8 00 00 00 00	 call	 net_data_trace
$LN19@Process_0C:

; 5050 :             }
; 5051 : 
; 5052 :             memcpy( &pLCSCONN->bInToken, &pOutBAF1->bTokenB, sizeof(pLCSCONN->bInToken) );  // Copy Inbound token

  002c7	48 8b 44 24 48	 mov	 rax, QWORD PTR pLCSCONN$[rsp]
  002cc	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR pOutBAF1$[rsp]
  002d4	8b 49 0c	 mov	 ecx, DWORD PTR [rcx+12]
  002d7	89 48 08	 mov	 DWORD PTR [rax+8], ecx

; 5053 :             obtain_lock( &TokenLock );

  002da	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG174146
  002e1	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:TokenLock
  002e8	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_obtain_lock

; 5054 :             STORE_FW( pLCSCONN->bOutToken, uToken );                                        // Outbound token

  002ee	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR uToken
  002f4	e8 00 00 00 00	 call	 _byteswap_ulong
  002f9	48 8b 4c 24 48	 mov	 rcx, QWORD PTR pLCSCONN$[rsp]
  002fe	48 83 c1 0c	 add	 rcx, 12
  00302	8b d0		 mov	 edx, eax
  00304	e8 00 00 00 00	 call	 store_fw_noswap

; 5055 :             uToken += INCREMENT_TOKEN;

  00309	8b 05 00 00 00
	00		 mov	 eax, DWORD PTR uToken
  0030f	05 00 01 00 00	 add	 eax, 256		; 00000100H
  00314	89 05 00 00 00
	00		 mov	 DWORD PTR uToken, eax

; 5056 :             release_lock( &TokenLock );

  0031a	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG174147
  00321	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:TokenLock
  00328	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_release_lock

; 5057 : 
; 5058 :             if (pLCSDEV->pLCSBLK->fDebug)

  0032e	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR pLCSDEV$[rsp]
  00336	48 8b 40 08	 mov	 rax, QWORD PTR [rax+8]
  0033a	8b 40 18	 mov	 eax, DWORD PTR [rax+24]
  0033d	83 e0 01	 and	 eax, 1
  00340	85 c0		 test	 eax, eax
  00342	0f 84 84 00 00
	00		 je	 $LN20@Process_0C

; 5059 :             {
; 5060 :                 WRMSG( HHC03984, "I", "Updated LCSCONN Inbound");

  00348	b9 01 00 00 00	 mov	 ecx, 1
  0034d	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  00353	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG174149
  0035a	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  0035f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG174150
  00366	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  0036b	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG174151
  00372	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00377	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  0037c	41 b9 03 00 00
	00		 mov	 r9d, 3
  00382	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG174152
  00389	ba c4 13 00 00	 mov	 edx, 5060		; 000013c4H
  0038e	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG174153
  00395	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 5061 :                 net_data_trace( pDEVBLK, (BYTE*)pLCSCONN, sizeof(LCSCONN), NO_DIRECTION, 'D', "LCSCONN", 0 );

  0039b	c7 44 24 30 00
	00 00 00	 mov	 DWORD PTR [rsp+48], 0
  003a3	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG174154
  003aa	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  003af	c6 44 24 20 44	 mov	 BYTE PTR [rsp+32], 68	; 00000044H
  003b4	41 b1 20	 mov	 r9b, 32			; 00000020H
  003b7	41 b8 30 00 00
	00		 mov	 r8d, 48			; 00000030H
  003bd	48 8b 54 24 48	 mov	 rdx, QWORD PTR pLCSCONN$[rsp]
  003c2	48 8b 4c 24 50	 mov	 rcx, QWORD PTR pDEVBLK$[rsp]
  003c7	e8 00 00 00 00	 call	 net_data_trace
$LN20@Process_0C:

; 5062 :             }
; 5063 :         }

  003cc	e9 37 02 00 00	 jmp	 $LN18@Process_0C
$LN17@Process_0C:

; 5064 :         else  // The existing LCSCONN is for an outbound connection.
; 5065 :         {
; 5066 :             if (pLCSDEV->pLCSBLK->fDebug)

  003d1	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR pLCSDEV$[rsp]
  003d9	48 8b 40 08	 mov	 rax, QWORD PTR [rax+8]
  003dd	8b 40 18	 mov	 eax, DWORD PTR [rax+24]
  003e0	83 e0 01	 and	 eax, 1
  003e3	85 c0		 test	 eax, eax
  003e5	0f 84 84 00 00
	00		 je	 $LN21@Process_0C

; 5067 :             {
; 5068 :                 WRMSG( HHC03984, "E", "Found and released existing LCSCONN Outbound");

  003eb	b9 01 00 00 00	 mov	 ecx, 1
  003f0	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  003f6	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG174156
  003fd	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  00402	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG174157
  00409	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  0040e	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG174158
  00415	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  0041a	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  0041f	41 b9 03 00 00
	00		 mov	 r9d, 3
  00425	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG174159
  0042c	ba cc 13 00 00	 mov	 edx, 5068		; 000013ccH
  00431	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG174160
  00438	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 5069 :                 net_data_trace( pDEVBLK, (BYTE*)pLCSCONN, sizeof(LCSCONN), NO_DIRECTION, 'D', "LCSCONN", 0 );

  0043e	c7 44 24 30 00
	00 00 00	 mov	 DWORD PTR [rsp+48], 0
  00446	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG174161
  0044d	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  00452	c6 44 24 20 44	 mov	 BYTE PTR [rsp+32], 68	; 00000044H
  00457	41 b1 20	 mov	 r9b, 32			; 00000020H
  0045a	41 b8 30 00 00
	00		 mov	 r8d, 48			; 00000030H
  00460	48 8b 54 24 48	 mov	 rdx, QWORD PTR pLCSCONN$[rsp]
  00465	48 8b 4c 24 50	 mov	 rcx, QWORD PTR pDEVBLK$[rsp]
  0046a	e8 00 00 00 00	 call	 net_data_trace
$LN21@Process_0C:

; 5070 :             }
; 5071 : 
; 5072 :             remove_connection_from_chain( pLCSDEV, pLCSCONN );

  0046f	48 8b 54 24 48	 mov	 rdx, QWORD PTR pLCSCONN$[rsp]
  00474	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR pLCSDEV$[rsp]
  0047c	e8 00 00 00 00	 call	 remove_connection_from_chain

; 5073 :             free_connection( pLCSDEV, pLCSCONN );

  00481	48 8b 54 24 48	 mov	 rdx, QWORD PTR pLCSCONN$[rsp]
  00486	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR pLCSDEV$[rsp]
  0048e	e8 00 00 00 00	 call	 free_connection

; 5074 :             pLCSCONN = NULL;

  00493	48 c7 44 24 48
	00 00 00 00	 mov	 QWORD PTR pLCSCONN$[rsp], 0

; 5075 : 
; 5076 :             // Create the LCSCONN for the new outbound connection.
; 5077 :             pLCSCONN = alloc_connection( pLCSDEV );

  0049c	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR pLCSDEV$[rsp]
  004a4	e8 00 00 00 00	 call	 alloc_connection
  004a9	48 89 44 24 48	 mov	 QWORD PTR pLCSCONN$[rsp], rax

; 5078 :             pLCSCONN->hwCreated = LCSCONN_CREATED_OUTBOUND;

  004ae	b8 02 00 00 00	 mov	 eax, 2
  004b3	48 8b 4c 24 48	 mov	 rcx, QWORD PTR pLCSCONN$[rsp]
  004b8	66 89 41 1c	 mov	 WORD PTR [rcx+28], ax

; 5079 : 
; 5080 :             memcpy( &pLCSCONN->bLocalMAC, &pLCSPORT->MAC_Address, IFHWADDRLEN );

  004bc	48 8b 44 24 48	 mov	 rax, QWORD PTR pLCSCONN$[rsp]
  004c1	48 8b 4c 24 68	 mov	 rcx, QWORD PTR pLCSPORT$[rsp]
  004c6	48 8d 78 10	 lea	 rdi, QWORD PTR [rax+16]
  004ca	48 8d 71 02	 lea	 rsi, QWORD PTR [rcx+2]
  004ce	b9 06 00 00 00	 mov	 ecx, 6
  004d3	f3 a4		 rep movsb

; 5081 : #if !defined( OPTION_TUNTAP_LCS_SAME_ADDR )
; 5082 :             pLCSCONN->bLocalMAC[5]++;
; 5083 : #endif
; 5084 :             memcpy( &pLCSCONN->bRemoteMAC, &pOutBAF2->bByte03, IFHWADDRLEN );

  004d5	48 8b 44 24 48	 mov	 rax, QWORD PTR pLCSCONN$[rsp]
  004da	48 8b 8c 24 b8
	00 00 00	 mov	 rcx, QWORD PTR pOutBAF2$[rsp]
  004e2	48 8d 78 16	 lea	 rdi, QWORD PTR [rax+22]
  004e6	48 8d 71 03	 lea	 rsi, QWORD PTR [rcx+3]
  004ea	b9 06 00 00 00	 mov	 ecx, 6
  004ef	f3 a4		 rep movsb

; 5085 : 
; 5086 :             memcpy( &pLCSCONN->bInToken, &pOutBAF1->bTokenB, sizeof(pLCSCONN->bInToken) );  // Copy Inbound token

  004f1	48 8b 44 24 48	 mov	 rax, QWORD PTR pLCSCONN$[rsp]
  004f6	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR pOutBAF1$[rsp]
  004fe	8b 49 0c	 mov	 ecx, DWORD PTR [rcx+12]
  00501	89 48 08	 mov	 DWORD PTR [rax+8], ecx

; 5087 :             obtain_lock( &TokenLock );

  00504	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG174162
  0050b	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:TokenLock
  00512	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_obtain_lock

; 5088 :             STORE_FW( pLCSCONN->bOutToken, uToken );                                        // Outbound token

  00518	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR uToken
  0051e	e8 00 00 00 00	 call	 _byteswap_ulong
  00523	48 8b 4c 24 48	 mov	 rcx, QWORD PTR pLCSCONN$[rsp]
  00528	48 83 c1 0c	 add	 rcx, 12
  0052c	8b d0		 mov	 edx, eax
  0052e	e8 00 00 00 00	 call	 store_fw_noswap

; 5089 :             uToken += INCREMENT_TOKEN;

  00533	8b 05 00 00 00
	00		 mov	 eax, DWORD PTR uToken
  00539	05 00 01 00 00	 add	 eax, 256		; 00000100H
  0053e	89 05 00 00 00
	00		 mov	 DWORD PTR uToken, eax

; 5090 :             release_lock( &TokenLock );

  00544	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG174163
  0054b	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:TokenLock
  00552	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_release_lock

; 5091 : 
; 5092 :             if (pLCSDEV->pLCSBLK->fDebug)

  00558	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR pLCSDEV$[rsp]
  00560	48 8b 40 08	 mov	 rax, QWORD PTR [rax+8]
  00564	8b 40 18	 mov	 eax, DWORD PTR [rax+24]
  00567	83 e0 01	 and	 eax, 1
  0056a	85 c0		 test	 eax, eax
  0056c	0f 84 84 00 00
	00		 je	 $LN22@Process_0C

; 5093 :             {
; 5094 :                 WRMSG( HHC03984, "I", "Created LCSCONN Outbound");

  00572	b9 01 00 00 00	 mov	 ecx, 1
  00577	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  0057d	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG174165
  00584	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  00589	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG174166
  00590	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  00595	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG174167
  0059c	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  005a1	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  005a6	41 b9 03 00 00
	00		 mov	 r9d, 3
  005ac	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG174168
  005b3	ba e6 13 00 00	 mov	 edx, 5094		; 000013e6H
  005b8	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG174169
  005bf	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 5095 :                 net_data_trace( pDEVBLK, (BYTE*)pLCSCONN, sizeof(LCSCONN), NO_DIRECTION, 'D', "LCSCONN", 0 );

  005c5	c7 44 24 30 00
	00 00 00	 mov	 DWORD PTR [rsp+48], 0
  005cd	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG174170
  005d4	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  005d9	c6 44 24 20 44	 mov	 BYTE PTR [rsp+32], 68	; 00000044H
  005de	41 b1 20	 mov	 r9b, 32			; 00000020H
  005e1	41 b8 30 00 00
	00		 mov	 r8d, 48			; 00000030H
  005e7	48 8b 54 24 48	 mov	 rdx, QWORD PTR pLCSCONN$[rsp]
  005ec	48 8b 4c 24 50	 mov	 rcx, QWORD PTR pDEVBLK$[rsp]
  005f1	e8 00 00 00 00	 call	 net_data_trace
$LN22@Process_0C:

; 5096 :             }
; 5097 : 
; 5098 :             add_connection_to_chain( pLCSDEV, pLCSCONN );

  005f6	48 8b 54 24 48	 mov	 rdx, QWORD PTR pLCSCONN$[rsp]
  005fb	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR pLCSDEV$[rsp]
  00603	e8 00 00 00 00	 call	 add_connection_to_chain
$LN18@Process_0C:
$LN15@Process_0C:

; 5099 :         }
; 5100 :     }
; 5101 : 
; 5102 :     //
; 5103 :     pLCSIBH = alloc_lcs_buffer( pLCSDEV, ( INBOUND_CC0A_SIZE * 2 ) );

  00608	ba 48 00 00 00	 mov	 edx, 72			; 00000048H
  0060d	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR pLCSDEV$[rsp]
  00615	e8 00 00 00 00	 call	 alloc_lcs_buffer
  0061a	48 89 44 24 60	 mov	 QWORD PTR pLCSIBH$[rsp], rax

; 5104 : 
; 5105 :     memcpy( &pLCSIBH->bData, Inbound_CC0A, INBOUND_CC0A_SIZE );

  0061f	48 8b 44 24 60	 mov	 rax, QWORD PTR pLCSIBH$[rsp]
  00624	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:?Inbound_CC0A@?1??Process_0C0A@@9@9
  0062b	48 8d 78 10	 lea	 rdi, QWORD PTR [rax+16]
  0062f	48 8b f1	 mov	 rsi, rcx
  00632	b9 24 00 00 00	 mov	 ecx, 36			; 00000024H
  00637	f3 a4		 rep movsb

; 5106 :     pLCSIBH->iDataLen = INBOUND_CC0A_SIZE;

  00639	48 8b 44 24 60	 mov	 rax, QWORD PTR pLCSIBH$[rsp]
  0063e	c7 40 0c 24 00
	00 00		 mov	 DWORD PTR [rax+12], 36	; 00000024H

; 5107 : 
; 5108 :     pInHDR = (PLCSHDR)&pLCSIBH->bData;

  00645	48 8b 44 24 60	 mov	 rax, QWORD PTR pLCSIBH$[rsp]
  0064a	48 83 c0 10	 add	 rax, 16
  0064e	48 89 44 24 70	 mov	 QWORD PTR pInHDR$[rsp], rax

; 5109 :     pInBAF1 = (PLCSBAF1)( (BYTE*)pInHDR + sizeof(LCSHDR) );

  00653	48 8b 44 24 70	 mov	 rax, QWORD PTR pInHDR$[rsp]
  00658	48 83 c0 04	 add	 rax, 4
  0065c	48 89 44 24 58	 mov	 QWORD PTR pInBAF1$[rsp], rax

; 5110 :     FETCH_HW( hwLenInBaf1, pInBAF1->hwLenBaf1 );

  00661	48 8b 44 24 58	 mov	 rax, QWORD PTR pInBAF1$[rsp]
  00666	48 8b c8	 mov	 rcx, rax
  00669	e8 00 00 00 00	 call	 fetch_hw_noswap
  0066e	0f b7 c8	 movzx	 ecx, ax
  00671	e8 00 00 00 00	 call	 _byteswap_ushort
  00676	66 89 44 24 40	 mov	 WORD PTR hwLenInBaf1$[rsp], ax

; 5111 : //  FETCH_HW( hwLenInBaf2, pInBAF1->hwLenBaf2 );
; 5112 :     pInBAF2 = (PLCSBAF2)( (BYTE*)pInBAF1 + hwLenInBaf1 );

  0067b	0f b7 44 24 40	 movzx	 eax, WORD PTR hwLenInBaf1$[rsp]
  00680	48 8b 4c 24 58	 mov	 rcx, QWORD PTR pInBAF1$[rsp]
  00685	48 03 c8	 add	 rcx, rax
  00688	48 8b c1	 mov	 rax, rcx
  0068b	48 89 44 24 78	 mov	 QWORD PTR pInBAF2$[rsp], rax

; 5113 : 
; 5114 :     memcpy( &pInBAF1->bTokenA, &pLCSCONN->bInToken, sizeof(pLCSCONN->bInToken) );        // Set Inbound token

  00690	48 8b 44 24 58	 mov	 rax, QWORD PTR pInBAF1$[rsp]
  00695	48 8b 4c 24 48	 mov	 rcx, QWORD PTR pLCSCONN$[rsp]
  0069a	8b 49 08	 mov	 ecx, DWORD PTR [rcx+8]
  0069d	89 48 08	 mov	 DWORD PTR [rax+8], ecx

; 5115 :     memcpy( &pInBAF1->bTokenC, &pLCSCONN->bOutToken, sizeof(pLCSCONN->bOutToken) );      // Outbound token

  006a0	48 8b 44 24 58	 mov	 rax, QWORD PTR pInBAF1$[rsp]
  006a5	48 8b 4c 24 48	 mov	 rcx, QWORD PTR pLCSCONN$[rsp]
  006aa	8b 49 0c	 mov	 ecx, DWORD PTR [rcx+12]
  006ad	89 48 18	 mov	 DWORD PTR [rax+24], ecx

; 5116 : 
; 5117 :     memcpy( &pInBAF2->hwSeqNum, &pOutBAF2->hwSeqNum, sizeof(pInBAF2->hwSeqNum) );

  006b0	48 8b 44 24 78	 mov	 rax, QWORD PTR pInBAF2$[rsp]
  006b5	48 8b 8c 24 b8
	00 00 00	 mov	 rcx, QWORD PTR pOutBAF2$[rsp]
  006bd	0f b7 49 01	 movzx	 ecx, WORD PTR [rcx+1]
  006c1	66 89 48 01	 mov	 WORD PTR [rax+1], cx

; 5118 : 
; 5119 :     add_lcs_buffer_to_chain( pLCSDEV, pLCSIBH );

  006c5	48 8b 54 24 60	 mov	 rdx, QWORD PTR pLCSIBH$[rsp]
  006ca	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR pLCSDEV$[rsp]
  006d2	e8 00 00 00 00	 call	 add_lcs_buffer_to_chain

; 5120 : 
; 5121 :     return;
; 5122 : }

  006d7	48 81 c4 88 00
	00 00		 add	 rsp, 136		; 00000088H
  006de	5f		 pop	 rdi
  006df	5e		 pop	 rsi
  006e0	c3		 ret	 0
Process_0C0A ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\ctc_lcs.c
_TEXT	SEGMENT
iEthLen$ = 112
pEthFrame$ = 120
pDEVBLK$ = 128
pLCSCONN$ = 136
iLPDULen$ = 144
tv171 = 148
tv176 = 152
pLCSPORT$ = 160
tv166 = 168
llc$ = 176
frame$ = 224
llcmsg$ = 288
__$ArrayPad$ = 544
pLCSDEV$ = 592
pLCSHDR$ = 600
pLCSBAF1$ = 608
pLCSBAF2$ = 616
hwLenBaf1$ = 624
hwLenBaf2$ = 632
Process_8C0B PROC

; 4879 : {

  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	56		 push	 rsi
  00015	57		 push	 rdi
  00016	48 81 ec 38 02
	00 00		 sub	 rsp, 568		; 00000238H
  0001d	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00024	48 33 c4	 xor	 rax, rsp
  00027	48 89 84 24 20
	02 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax
$LN4@Process_8C:

; 4880 : //                   Token
; 4881 : //  000C8C0B00036002 40000240
; 4882 : //  0 1 2 3 4 5 6 7  8 9 A B
; 4883 : //
; 4884 : //  010000
; 4885 : //  0 1 2
; 4886 : 
; 4887 :     DEVBLK*     pDEVBLK;
; 4888 :     PLCSPORT    pLCSPORT;
; 4889 :     PLCSCONN    pLCSCONN;
; 4890 :     int         iLPDULen;
; 4891 :     LLC         llc;
; 4892 :     PETHFRM     pEthFrame;
; 4893 :     int         iEthLen;
; 4894 :     BYTE        frame[64];
; 4895 :     char        llcmsg[256];
; 4896 : 
; 4897 :     UNREFERENCED( pLCSHDR   );

  0002f	33 c0		 xor	 eax, eax
  00031	85 c0		 test	 eax, eax
  00033	75 fa		 jne	 SHORT $LN4@Process_8C
$LN7@Process_8C:

; 4898 :     UNREFERENCED( pLCSBAF1  );

  00035	33 c0		 xor	 eax, eax
  00037	85 c0		 test	 eax, eax
  00039	75 fa		 jne	 SHORT $LN7@Process_8C
$LN10@Process_8C:

; 4899 :     UNREFERENCED( hwLenBaf1 );

  0003b	33 c0		 xor	 eax, eax
  0003d	85 c0		 test	 eax, eax
  0003f	75 fa		 jne	 SHORT $LN10@Process_8C
$LN13@Process_8C:

; 4900 :     UNREFERENCED( hwLenBaf2 );

  00041	33 c0		 xor	 eax, eax
  00043	85 c0		 test	 eax, eax
  00045	75 fa		 jne	 SHORT $LN13@Process_8C
$LN16@Process_8C:

; 4901 :     UNREFERENCED( pLCSBAF2  );

  00047	33 c0		 xor	 eax, eax
  00049	85 c0		 test	 eax, eax
  0004b	75 fa		 jne	 SHORT $LN16@Process_8C

; 4902 : 
; 4903 :     pDEVBLK = pLCSDEV->pDEVBLK[ LCS_READ_SUBCHANN ];

  0004d	b8 08 00 00 00	 mov	 eax, 8
  00052	48 6b c0 00	 imul	 rax, rax, 0
  00056	48 8b 8c 24 50
	02 00 00	 mov	 rcx, QWORD PTR pLCSDEV$[rsp]
  0005e	48 8b 44 01 10	 mov	 rax, QWORD PTR [rcx+rax+16]
  00063	48 89 84 24 80
	00 00 00	 mov	 QWORD PTR pDEVBLK$[rsp], rax

; 4904 :     pLCSPORT = &pLCSDEV->pLCSBLK->Port[pLCSDEV->bPort];

  0006b	48 8b 84 24 50
	02 00 00	 mov	 rax, QWORD PTR pLCSDEV$[rsp]
  00073	48 8b 40 08	 mov	 rax, QWORD PTR [rax+8]
  00077	48 8b 8c 24 50
	02 00 00	 mov	 rcx, QWORD PTR pLCSDEV$[rsp]
  0007f	0f b6 49 23	 movzx	 ecx, BYTE PTR [rcx+35]
  00083	48 69 c9 98 01
	00 00		 imul	 rcx, rcx, 408		; 00000198H
  0008a	48 8d 44 08 60	 lea	 rax, QWORD PTR [rax+rcx+96]
  0008f	48 89 84 24 a0
	00 00 00	 mov	 QWORD PTR pLCSPORT$[rsp], rax

; 4905 :     memset( frame, 0, sizeof(frame) );                               // Clear area for ethernet fram

  00097	48 8d 84 24 e0
	00 00 00	 lea	 rax, QWORD PTR frame$[rsp]
  0009f	48 8b f8	 mov	 rdi, rax
  000a2	33 c0		 xor	 eax, eax
  000a4	b9 40 00 00 00	 mov	 ecx, 64			; 00000040H
  000a9	f3 aa		 rep stosb

; 4906 :     pEthFrame = (PETHFRM)&frame[0];

  000ab	b8 01 00 00 00	 mov	 eax, 1
  000b0	48 6b c0 00	 imul	 rax, rax, 0
  000b4	48 8d 84 04 e0
	00 00 00	 lea	 rax, QWORD PTR frame$[rsp+rax]
  000bc	48 89 44 24 78	 mov	 QWORD PTR pEthFrame$[rsp], rax

; 4907 :     iEthLen = 60;                                                    // Minimum ethernet frame length

  000c1	c7 44 24 70 3c
	00 00 00	 mov	 DWORD PTR iEthLen$[rsp], 60 ; 0000003cH

; 4908 : 
; 4909 :     // Find the connection block.
; 4910 :     pLCSCONN = find_connection_by_outbound_token( pLCSDEV, pLCSBAF1->bTokenA );

  000c9	48 8b 84 24 60
	02 00 00	 mov	 rax, QWORD PTR pLCSBAF1$[rsp]
  000d1	48 83 c0 08	 add	 rax, 8
  000d5	48 8b d0	 mov	 rdx, rax
  000d8	48 8b 8c 24 50
	02 00 00	 mov	 rcx, QWORD PTR pLCSDEV$[rsp]
  000e0	e8 00 00 00 00	 call	 find_connection_by_outbound_token
  000e5	48 89 84 24 88
	00 00 00	 mov	 QWORD PTR pLCSCONN$[rsp], rax

; 4911 :     if (!pLCSCONN)

  000ed	48 83 bc 24 88
	00 00 00 00	 cmp	 QWORD PTR pLCSCONN$[rsp], 0
  000f6	75 58		 jne	 SHORT $LN20@Process_8C

; 4912 :     {
; 4913 :         WRMSG( HHC03984, "W", "LCSCONN not found");

  000f8	b9 01 00 00 00	 mov	 ecx, 1
  000fd	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  00103	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG174049
  0010a	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  0010f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG174050
  00116	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  0011b	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG174051
  00122	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00127	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  0012c	41 b9 03 00 00
	00		 mov	 r9d, 3
  00132	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG174052
  00139	ba 31 13 00 00	 mov	 edx, 4913		; 00001331H
  0013e	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG174053
  00145	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 4914 :         /* FixMe! Need a proper error message here! */
; 4915 :         return;

  0014b	e9 75 03 00 00	 jmp	 $LN1@Process_8C
$LN20@Process_8C:

; 4916 :     }
; 4917 : 
; 4918 :     //
; 4919 :     memset( &llc, 0, sizeof(LLC) );

  00150	48 8d 84 24 b0
	00 00 00	 lea	 rax, QWORD PTR llc$[rsp]
  00158	48 8b f8	 mov	 rdi, rax
  0015b	33 c0		 xor	 eax, eax
  0015d	b9 2e 00 00 00	 mov	 ecx, 46			; 0000002eH
  00162	f3 aa		 rep stosb

; 4920 :     llc.hwDSAP    = LSAP_SNA_Path_Control;

  00164	b8 04 00 00 00	 mov	 eax, 4
  00169	66 89 84 24 be
	00 00 00	 mov	 WORD PTR llc$[rsp+14], ax

; 4921 :     llc.hwSSAP    = LSAP_SNA_Path_Control;

  00171	b8 04 00 00 00	 mov	 eax, 4
  00176	66 89 84 24 c2
	00 00 00	 mov	 WORD PTR llc$[rsp+18], ax

; 4922 :     llc.hwCR      = 1;

  0017e	b8 01 00 00 00	 mov	 eax, 1
  00183	66 89 84 24 c4
	00 00 00	 mov	 WORD PTR llc$[rsp+20], ax

; 4923 :     llc.hwPF      = 1;

  0018b	b8 01 00 00 00	 mov	 eax, 1
  00190	66 89 84 24 ca
	00 00 00	 mov	 WORD PTR llc$[rsp+26], ax

; 4924 :     llc.hwM       = M_UA_Response;

  00198	b8 0c 00 00 00	 mov	 eax, 12
  0019d	66 89 84 24 ce
	00 00 00	 mov	 WORD PTR llc$[rsp+30], ax

; 4925 :     llc.hwType    = Type_Unnumbered_Frame;

  001a5	b8 03 00 00 00	 mov	 eax, 3
  001aa	66 89 84 24 dc
	00 00 00	 mov	 WORD PTR llc$[rsp+44], ax

; 4926 : 
; 4927 :     // Construct Ethernet frame
; 4928 :     memcpy( &pEthFrame->bDestMAC, &pLCSCONN->bRemoteMAC, IFHWADDRLEN );   // Copy destination MAC address

  001b2	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR pLCSCONN$[rsp]
  001ba	48 8b 7c 24 78	 mov	 rdi, QWORD PTR pEthFrame$[rsp]
  001bf	48 8d 70 16	 lea	 rsi, QWORD PTR [rax+22]
  001c3	b9 06 00 00 00	 mov	 ecx, 6
  001c8	f3 a4		 rep movsb

; 4929 :     memcpy( &pEthFrame->bSrcMAC, &pLCSCONN->bLocalMAC, IFHWADDRLEN );     // Copy source MAC address

  001ca	48 8b 44 24 78	 mov	 rax, QWORD PTR pEthFrame$[rsp]
  001cf	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR pLCSCONN$[rsp]
  001d7	48 8d 78 06	 lea	 rdi, QWORD PTR [rax+6]
  001db	48 8d 71 10	 lea	 rsi, QWORD PTR [rcx+16]
  001df	b9 06 00 00 00	 mov	 ecx, 6
  001e4	f3 a4		 rep movsb

; 4930 :     iLPDULen = BuildLLC( &llc, pEthFrame->bData);                         // Build LLC PDU

  001e6	48 8b 44 24 78	 mov	 rax, QWORD PTR pEthFrame$[rsp]
  001eb	48 83 c0 0e	 add	 rax, 14
  001ef	48 8b d0	 mov	 rdx, rax
  001f2	48 8d 8c 24 b0
	00 00 00	 lea	 rcx, QWORD PTR llc$[rsp]
  001fa	e8 00 00 00 00	 call	 BuildLLC
  001ff	89 84 24 90 00
	00 00		 mov	 DWORD PTR iLPDULen$[rsp], eax

; 4931 :     STORE_HW( pEthFrame->hwEthernetType, (U16)iLPDULen );                 // Set data length

  00206	0f b7 8c 24 90
	00 00 00	 movzx	 ecx, WORD PTR iLPDULen$[rsp]
  0020e	e8 00 00 00 00	 call	 _byteswap_ushort
  00213	48 8b 4c 24 78	 mov	 rcx, QWORD PTR pEthFrame$[rsp]
  00218	48 83 c1 0c	 add	 rcx, 12
  0021c	0f b7 d0	 movzx	 edx, ax
  0021f	e8 00 00 00 00	 call	 store_hw_noswap

; 4932 : 
; 4933 :     // Trace Ethernet frame before sending to TAP device
; 4934 :     if (pLCSPORT->pLCSBLK->fDebug)

  00224	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR pLCSPORT$[rsp]
  0022c	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  00230	8b 40 18	 mov	 eax, DWORD PTR [rax+24]
  00233	83 e0 01	 and	 eax, 1
  00236	85 c0		 test	 eax, eax
  00238	0f 84 10 01 00
	00		 je	 $LN21@Process_8C

; 4935 :     {
; 4936 :         // "%1d:%04X %s: port %2.2X: Send frame of size %d bytes (with %s packet) to device %s"
; 4937 :         WRMSG(HHC00983, "D", SSID_TO_LCSS(pDEVBLK->ssid), pDEVBLK->devnum, pDEVBLK->typname,

  0023e	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR pLCSPORT$[rsp]
  00246	48 05 48 01 00
	00		 add	 rax, 328		; 00000148H
  0024c	48 89 84 24 a8
	00 00 00	 mov	 QWORD PTR tv166[rsp], rax
  00254	48 8b 8c 24 50
	02 00 00	 mov	 rcx, QWORD PTR pLCSDEV$[rsp]
  0025c	0f b6 49 23	 movzx	 ecx, BYTE PTR [rcx+35]
  00260	89 8c 24 94 00
	00 00		 mov	 DWORD PTR tv171[rsp], ecx
  00267	48 8b 94 24 80
	00 00 00	 mov	 rdx, QWORD PTR pDEVBLK$[rsp]
  0026f	0f b7 52 48	 movzx	 edx, WORD PTR [rdx+72]
  00273	89 94 24 98 00
	00 00		 mov	 DWORD PTR tv176[rsp], edx
  0027a	48 8b bc 24 80
	00 00 00	 mov	 rdi, QWORD PTR pDEVBLK$[rsp]
  00282	0f b7 7f 44	 movzx	 edi, WORD PTR [rdi+68]
  00286	d1 ff		 sar	 edi, 1
  00288	b9 01 00 00 00	 mov	 ecx, 1
  0028d	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  00293	48 8b 8c 24 a8
	00 00 00	 mov	 rcx, QWORD PTR tv166[rsp]
  0029b	48 89 4c 24 68	 mov	 QWORD PTR [rsp+104], rcx
  002a0	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG174055
  002a7	48 89 4c 24 60	 mov	 QWORD PTR [rsp+96], rcx
  002ac	8b 4c 24 70	 mov	 ecx, DWORD PTR iEthLen$[rsp]
  002b0	89 4c 24 58	 mov	 DWORD PTR [rsp+88], ecx
  002b4	8b 8c 24 94 00
	00 00		 mov	 ecx, DWORD PTR tv171[rsp]
  002bb	89 4c 24 50	 mov	 DWORD PTR [rsp+80], ecx
  002bf	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR pDEVBLK$[rsp]
  002c7	48 8b 49 50	 mov	 rcx, QWORD PTR [rcx+80]
  002cb	48 89 4c 24 48	 mov	 QWORD PTR [rsp+72], rcx
  002d0	8b 8c 24 98 00
	00 00		 mov	 ecx, DWORD PTR tv176[rsp]
  002d7	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  002db	89 7c 24 38	 mov	 DWORD PTR [rsp+56], edi
  002df	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG174056
  002e6	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  002eb	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG174057
  002f2	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  002f7	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  002fc	41 b9 03 00 00
	00		 mov	 r9d, 3
  00302	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG174058
  00309	ba 4a 13 00 00	 mov	 edx, 4938		; 0000134aH
  0030e	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG174059
  00315	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 4938 :                              pLCSDEV->bPort, iEthLen, "802.3 SNA", pLCSPORT->szNetIfName );
; 4939 :         net_data_trace( pDEVBLK, (BYTE*)pEthFrame, iEthLen, FROM_GUEST, 'D', "eth frame", 0 );

  0031b	c7 44 24 30 00
	00 00 00	 mov	 DWORD PTR [rsp+48], 0
  00323	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG174060
  0032a	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  0032f	c6 44 24 20 44	 mov	 BYTE PTR [rsp+32], 68	; 00000044H
  00334	41 b1 3c	 mov	 r9b, 60			; 0000003cH
  00337	44 8b 44 24 70	 mov	 r8d, DWORD PTR iEthLen$[rsp]
  0033c	48 8b 54 24 78	 mov	 rdx, QWORD PTR pEthFrame$[rsp]
  00341	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR pDEVBLK$[rsp]
  00349	e8 00 00 00 00	 call	 net_data_trace
$LN21@Process_8C:

; 4940 :     }
; 4941 : 
; 4942 :     // Write the Ethernet frame to the TAP device
; 4943 :     if (TUNTAP_Write( pDEVBLK->fd, (BYTE*)pEthFrame, iEthLen ) == iEthLen)

  0034e	44 8b 44 24 70	 mov	 r8d, DWORD PTR iEthLen$[rsp]
  00353	48 8b 54 24 78	 mov	 rdx, QWORD PTR pEthFrame$[rsp]
  00358	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR pDEVBLK$[rsp]
  00360	8b 88 ac 01 00
	00		 mov	 ecx, DWORD PTR [rax+428]
  00366	e8 00 00 00 00	 call	 tt32_write
  0036b	3b 44 24 70	 cmp	 eax, DWORD PTR iEthLen$[rsp]
  0036f	0f 85 a4 00 00
	00		 jne	 $LN22@Process_8C

; 4944 :     {
; 4945 :         if (pLCSPORT->pLCSBLK->fDebug)

  00375	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR pLCSPORT$[rsp]
  0037d	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  00381	8b 40 18	 mov	 eax, DWORD PTR [rax+24]
  00384	83 e0 01	 and	 eax, 1
  00387	85 c0		 test	 eax, eax
  00389	0f 84 85 00 00
	00		 je	 $LN24@Process_8C

; 4946 :         {
; 4947 :             snprintf( llcmsg, sizeof(llcmsg), "LCS: LLC unnumbered frame sent: CR=%u, M=%s", llc.hwCR, "UA" );

  0038f	0f b7 84 24 c4
	00 00 00	 movzx	 eax, WORD PTR llc$[rsp+20]
  00397	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG174064
  0039e	48 89 4c 24 20	 mov	 QWORD PTR [rsp+32], rcx
  003a3	44 8b c8	 mov	 r9d, eax
  003a6	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG174065
  003ad	ba 00 01 00 00	 mov	 edx, 256		; 00000100H
  003b2	48 8d 8c 24 20
	01 00 00	 lea	 rcx, QWORD PTR llcmsg$[rsp]
  003ba	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_snprintf

; 4948 :             WRMSG(HHC03984, "D", llcmsg );  /* FixMe! */

  003c0	b9 01 00 00 00	 mov	 ecx, 1
  003c5	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  003cb	48 8d 8c 24 20
	01 00 00	 lea	 rcx, QWORD PTR llcmsg$[rsp]
  003d3	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  003d8	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG174066
  003df	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  003e4	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG174067
  003eb	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  003f0	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  003f5	41 b9 03 00 00
	00		 mov	 r9d, 3
  003fb	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG174068
  00402	ba 54 13 00 00	 mov	 edx, 4948		; 00001354H
  00407	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG174069
  0040e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg
$LN24@Process_8C:

; 4949 :         }
; 4950 :     }

  00414	e9 82 00 00 00	 jmp	 $LN23@Process_8C
$LN22@Process_8C:

; 4951 :     else
; 4952 :     {
; 4953 :         pLCSDEV->iTuntapErrno = errno;

  00419	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno
  0041f	48 8b 8c 24 50
	02 00 00	 mov	 rcx, QWORD PTR pLCSDEV$[rsp]
  00427	8b 00		 mov	 eax, DWORD PTR [rax]
  00429	89 41 61	 mov	 DWORD PTR [rcx+97], eax

; 4954 :         pLCSDEV->fTuntapError = TRUE;

  0042c	48 8b 84 24 50
	02 00 00	 mov	 rax, QWORD PTR pLCSDEV$[rsp]
  00434	8b 40 5d	 mov	 eax, DWORD PTR [rax+93]
  00437	83 c8 10	 or	 eax, 16
  0043a	48 8b 8c 24 50
	02 00 00	 mov	 rcx, QWORD PTR pLCSDEV$[rsp]
  00442	89 41 5d	 mov	 DWORD PTR [rcx+93], eax
$LN19@Process_8C:

; 4955 :         PTT_TIMING( "*WRITE ERR", 0, iEthLen, 1 );

  00445	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_pttclass
  0044c	48 8b 00	 mov	 rax, QWORD PTR [rax]
  0044f	48 25 00 00 01
	00		 and	 rax, 65536		; 00010000H
  00455	48 85 c0	 test	 rax, rax
  00458	74 3b		 je	 SHORT $LN25@Process_8C
  0045a	48 63 44 24 70	 movsxd	 rax, DWORD PTR iEthLen$[rsp]
  0045f	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR [rsp+48], 0
  00468	48 c7 44 24 28
	01 00 00 00	 mov	 QWORD PTR [rsp+40], 1
  00471	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG174071
  00478	48 89 4c 24 20	 mov	 QWORD PTR [rsp+32], rcx
  0047d	4c 8b c8	 mov	 r9, rax
  00480	45 33 c0	 xor	 r8d, r8d
  00483	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG174072
  0048a	b9 00 00 01 00	 mov	 ecx, 65536		; 00010000H
  0048f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ptt_pthread_trace
$LN25@Process_8C:
  00495	33 c0		 xor	 eax, eax
  00497	85 c0		 test	 eax, eax
  00499	75 aa		 jne	 SHORT $LN19@Process_8C
$LN23@Process_8C:

; 4956 :     }
; 4957 : 
; 4958 :     remove_connection_from_chain( pLCSDEV, pLCSCONN );

  0049b	48 8b 94 24 88
	00 00 00	 mov	 rdx, QWORD PTR pLCSCONN$[rsp]
  004a3	48 8b 8c 24 50
	02 00 00	 mov	 rcx, QWORD PTR pLCSDEV$[rsp]
  004ab	e8 00 00 00 00	 call	 remove_connection_from_chain

; 4959 :     free_connection( pLCSDEV, pLCSCONN );

  004b0	48 8b 94 24 88
	00 00 00	 mov	 rdx, QWORD PTR pLCSCONN$[rsp]
  004b8	48 8b 8c 24 50
	02 00 00	 mov	 rcx, QWORD PTR pLCSDEV$[rsp]
  004c0	e8 00 00 00 00	 call	 free_connection
$LN1@Process_8C:

; 4960 : 
; 4961 :     return;
; 4962 : }

  004c5	48 8b 8c 24 20
	02 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  004cd	48 33 cc	 xor	 rcx, rsp
  004d0	e8 00 00 00 00	 call	 __security_check_cookie
  004d5	48 81 c4 38 02
	00 00		 add	 rsp, 568		; 00000238H
  004dc	5f		 pop	 rdi
  004dd	5e		 pop	 rsi
  004de	c3		 ret	 0
Process_8C0B ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\ctc_lcs.c
_TEXT	SEGMENT
iEthLen$ = 112
pEthFrame$ = 120
pDEVBLK$ = 128
pLCSCONN$ = 136
iLPDULen$ = 144
tv178 = 148
tv183 = 152
pLCSPORT$ = 160
tv173 = 168
llc$ = 176
frame$ = 224
llcmsg$ = 288
__$ArrayPad$ = 544
pLCSDEV$ = 592
pLCSHDR$ = 600
pLCSBAF1$ = 608
pLCSBAF2$ = 616
hwLenBaf1$ = 624
hwLenBaf2$ = 632
Process_0D00 PROC

; 4785 : {

  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	56		 push	 rsi
  00015	57		 push	 rdi
  00016	48 81 ec 38 02
	00 00		 sub	 rsp, 568		; 00000238H
  0001d	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00024	48 33 c4	 xor	 rax, rsp
  00027	48 89 84 24 20
	02 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax
$LN4@Process_0D:

; 4786 : //                   Token
; 4787 : //  000F0D00001A6002 40000240 000000
; 4788 : //  0 1 2 3 4 5 6 7  8 9 A B  C D E
; 4789 : //
; 4790 : //  01000300 00000000 00000000 00000000 00000000 00000000 0000
; 4791 : //  0 1 2 3  4 5 6 7  8 9 A B  C ...
; 4792 : 
; 4793 :     DEVBLK*     pDEVBLK;
; 4794 :     PLCSPORT    pLCSPORT;
; 4795 :     PLCSCONN    pLCSCONN;
; 4796 :     int         iLPDULen;
; 4797 :     LLC         llc;
; 4798 :     PETHFRM     pEthFrame;
; 4799 :     int         iEthLen;
; 4800 :     BYTE        frame[64];
; 4801 :     char        llcmsg[256];
; 4802 : 
; 4803 :     UNREFERENCED( pLCSDEV   );

  0002f	33 c0		 xor	 eax, eax
  00031	85 c0		 test	 eax, eax
  00033	75 fa		 jne	 SHORT $LN4@Process_0D
$LN7@Process_0D:

; 4804 :     UNREFERENCED( pLCSHDR   );

  00035	33 c0		 xor	 eax, eax
  00037	85 c0		 test	 eax, eax
  00039	75 fa		 jne	 SHORT $LN7@Process_0D
$LN10@Process_0D:

; 4805 :     UNREFERENCED( pLCSBAF1  );

  0003b	33 c0		 xor	 eax, eax
  0003d	85 c0		 test	 eax, eax
  0003f	75 fa		 jne	 SHORT $LN10@Process_0D
$LN13@Process_0D:

; 4806 :     UNREFERENCED( pLCSBAF2  );

  00041	33 c0		 xor	 eax, eax
  00043	85 c0		 test	 eax, eax
  00045	75 fa		 jne	 SHORT $LN13@Process_0D
$LN16@Process_0D:

; 4807 :     UNREFERENCED( hwLenBaf1 );

  00047	33 c0		 xor	 eax, eax
  00049	85 c0		 test	 eax, eax
  0004b	75 fa		 jne	 SHORT $LN16@Process_0D
$LN19@Process_0D:

; 4808 :     UNREFERENCED( hwLenBaf2 );

  0004d	33 c0		 xor	 eax, eax
  0004f	85 c0		 test	 eax, eax
  00051	75 fa		 jne	 SHORT $LN19@Process_0D

; 4809 : 
; 4810 :     pDEVBLK = pLCSDEV->pDEVBLK[ LCS_READ_SUBCHANN ];

  00053	b8 08 00 00 00	 mov	 eax, 8
  00058	48 6b c0 00	 imul	 rax, rax, 0
  0005c	48 8b 8c 24 50
	02 00 00	 mov	 rcx, QWORD PTR pLCSDEV$[rsp]
  00064	48 8b 44 01 10	 mov	 rax, QWORD PTR [rcx+rax+16]
  00069	48 89 84 24 80
	00 00 00	 mov	 QWORD PTR pDEVBLK$[rsp], rax

; 4811 :     pLCSPORT = &pLCSDEV->pLCSBLK->Port[pLCSDEV->bPort];

  00071	48 8b 84 24 50
	02 00 00	 mov	 rax, QWORD PTR pLCSDEV$[rsp]
  00079	48 8b 40 08	 mov	 rax, QWORD PTR [rax+8]
  0007d	48 8b 8c 24 50
	02 00 00	 mov	 rcx, QWORD PTR pLCSDEV$[rsp]
  00085	0f b6 49 23	 movzx	 ecx, BYTE PTR [rcx+35]
  00089	48 69 c9 98 01
	00 00		 imul	 rcx, rcx, 408		; 00000198H
  00090	48 8d 44 08 60	 lea	 rax, QWORD PTR [rax+rcx+96]
  00095	48 89 84 24 a0
	00 00 00	 mov	 QWORD PTR pLCSPORT$[rsp], rax

; 4812 :     memset( frame, 0, sizeof(frame) );                               // Clear area for ethernet fram

  0009d	48 8d 84 24 e0
	00 00 00	 lea	 rax, QWORD PTR frame$[rsp]
  000a5	48 8b f8	 mov	 rdi, rax
  000a8	33 c0		 xor	 eax, eax
  000aa	b9 40 00 00 00	 mov	 ecx, 64			; 00000040H
  000af	f3 aa		 rep stosb

; 4813 :     pEthFrame = (PETHFRM)&frame[0];

  000b1	b8 01 00 00 00	 mov	 eax, 1
  000b6	48 6b c0 00	 imul	 rax, rax, 0
  000ba	48 8d 84 04 e0
	00 00 00	 lea	 rax, QWORD PTR frame$[rsp+rax]
  000c2	48 89 44 24 78	 mov	 QWORD PTR pEthFrame$[rsp], rax

; 4814 :     iEthLen = 60;                                                    // Minimum ethernet frame length

  000c7	c7 44 24 70 3c
	00 00 00	 mov	 DWORD PTR iEthLen$[rsp], 60 ; 0000003cH

; 4815 : 
; 4816 :     // Find the connection block.
; 4817 :     pLCSCONN = find_connection_by_outbound_token( pLCSDEV, pLCSBAF1->bTokenA );

  000cf	48 8b 84 24 60
	02 00 00	 mov	 rax, QWORD PTR pLCSBAF1$[rsp]
  000d7	48 83 c0 08	 add	 rax, 8
  000db	48 8b d0	 mov	 rdx, rax
  000de	48 8b 8c 24 50
	02 00 00	 mov	 rcx, QWORD PTR pLCSDEV$[rsp]
  000e6	e8 00 00 00 00	 call	 find_connection_by_outbound_token
  000eb	48 89 84 24 88
	00 00 00	 mov	 QWORD PTR pLCSCONN$[rsp], rax

; 4818 :     if (!pLCSCONN)

  000f3	48 83 bc 24 88
	00 00 00 00	 cmp	 QWORD PTR pLCSCONN$[rsp], 0
  000fc	75 58		 jne	 SHORT $LN23@Process_0D

; 4819 :     {
; 4820 :         WRMSG( HHC03984, "W", "LCSCONN not found");

  000fe	b9 01 00 00 00	 mov	 ecx, 1
  00103	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  00109	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG173973
  00110	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  00115	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG173974
  0011c	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  00121	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG173975
  00128	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  0012d	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00132	41 b9 03 00 00
	00		 mov	 r9d, 3
  00138	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG173976
  0013f	ba d4 12 00 00	 mov	 edx, 4820		; 000012d4H
  00144	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG173977
  0014b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 4821 :         /* FixMe! Need a proper error message here! */
; 4822 :         return;

  00151	e9 65 03 00 00	 jmp	 $LN1@Process_0D
$LN23@Process_0D:

; 4823 :     }
; 4824 : 
; 4825 :     //
; 4826 :     FETCH_HW( pLCSCONN->hwDataSeqNum, pLCSBAF2->hwSeqNum );

  00156	48 8b 84 24 68
	02 00 00	 mov	 rax, QWORD PTR pLCSBAF2$[rsp]
  0015e	48 ff c0	 inc	 rax
  00161	48 8b c8	 mov	 rcx, rax
  00164	e8 00 00 00 00	 call	 fetch_hw_noswap
  00169	0f b7 c8	 movzx	 ecx, ax
  0016c	e8 00 00 00 00	 call	 _byteswap_ushort
  00171	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR pLCSCONN$[rsp]
  00179	66 89 41 22	 mov	 WORD PTR [rcx+34], ax

; 4827 : 
; 4828 :     //
; 4829 :     memset( &llc, 0, sizeof(LLC) );

  0017d	48 8d 84 24 b0
	00 00 00	 lea	 rax, QWORD PTR llc$[rsp]
  00185	48 8b f8	 mov	 rdi, rax
  00188	33 c0		 xor	 eax, eax
  0018a	b9 2e 00 00 00	 mov	 ecx, 46			; 0000002eH
  0018f	f3 aa		 rep stosb

; 4830 :     llc.hwDSAP    = LSAP_SNA_Path_Control;

  00191	b8 04 00 00 00	 mov	 eax, 4
  00196	66 89 84 24 be
	00 00 00	 mov	 WORD PTR llc$[rsp+14], ax

; 4831 :     llc.hwSSAP    = LSAP_SNA_Path_Control;

  0019e	b8 04 00 00 00	 mov	 eax, 4
  001a3	66 89 84 24 c2
	00 00 00	 mov	 WORD PTR llc$[rsp+18], ax

; 4832 :     llc.hwPF      = 1;

  001ab	b8 01 00 00 00	 mov	 eax, 1
  001b0	66 89 84 24 ca
	00 00 00	 mov	 WORD PTR llc$[rsp+26], ax

; 4833 :     llc.hwM       = M_SABME_Command;

  001b8	b8 0f 00 00 00	 mov	 eax, 15
  001bd	66 89 84 24 ce
	00 00 00	 mov	 WORD PTR llc$[rsp+30], ax

; 4834 :     llc.hwType    = Type_Unnumbered_Frame;

  001c5	b8 03 00 00 00	 mov	 eax, 3
  001ca	66 89 84 24 dc
	00 00 00	 mov	 WORD PTR llc$[rsp+44], ax

; 4835 : 
; 4836 :     // Construct Ethernet frame
; 4837 :     memcpy( &pEthFrame->bDestMAC, &pLCSCONN->bRemoteMAC, IFHWADDRLEN );   // Copy destination MAC address

  001d2	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR pLCSCONN$[rsp]
  001da	48 8b 7c 24 78	 mov	 rdi, QWORD PTR pEthFrame$[rsp]
  001df	48 8d 70 16	 lea	 rsi, QWORD PTR [rax+22]
  001e3	b9 06 00 00 00	 mov	 ecx, 6
  001e8	f3 a4		 rep movsb

; 4838 :     memcpy( &pEthFrame->bSrcMAC, &pLCSCONN->bLocalMAC, IFHWADDRLEN );     // Copy source MAC address

  001ea	48 8b 44 24 78	 mov	 rax, QWORD PTR pEthFrame$[rsp]
  001ef	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR pLCSCONN$[rsp]
  001f7	48 8d 78 06	 lea	 rdi, QWORD PTR [rax+6]
  001fb	48 8d 71 10	 lea	 rsi, QWORD PTR [rcx+16]
  001ff	b9 06 00 00 00	 mov	 ecx, 6
  00204	f3 a4		 rep movsb

; 4839 :     iLPDULen = BuildLLC( &llc, pEthFrame->bData);                         // Build LLC PDU

  00206	48 8b 44 24 78	 mov	 rax, QWORD PTR pEthFrame$[rsp]
  0020b	48 83 c0 0e	 add	 rax, 14
  0020f	48 8b d0	 mov	 rdx, rax
  00212	48 8d 8c 24 b0
	00 00 00	 lea	 rcx, QWORD PTR llc$[rsp]
  0021a	e8 00 00 00 00	 call	 BuildLLC
  0021f	89 84 24 90 00
	00 00		 mov	 DWORD PTR iLPDULen$[rsp], eax

; 4840 :     STORE_HW( pEthFrame->hwEthernetType, (U16)iLPDULen );                 // Set data length

  00226	0f b7 8c 24 90
	00 00 00	 movzx	 ecx, WORD PTR iLPDULen$[rsp]
  0022e	e8 00 00 00 00	 call	 _byteswap_ushort
  00233	48 8b 4c 24 78	 mov	 rcx, QWORD PTR pEthFrame$[rsp]
  00238	48 83 c1 0c	 add	 rcx, 12
  0023c	0f b7 d0	 movzx	 edx, ax
  0023f	e8 00 00 00 00	 call	 store_hw_noswap

; 4841 : 
; 4842 :     // Trace Ethernet frame before sending to TAP device
; 4843 :     if (pLCSPORT->pLCSBLK->fDebug)

  00244	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR pLCSPORT$[rsp]
  0024c	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  00250	8b 40 18	 mov	 eax, DWORD PTR [rax+24]
  00253	83 e0 01	 and	 eax, 1
  00256	85 c0		 test	 eax, eax
  00258	0f 84 10 01 00
	00		 je	 $LN24@Process_0D

; 4844 :     {
; 4845 :         // "%1d:%04X %s: port %2.2X: Send frame of size %d bytes (with %s packet) to device %s"
; 4846 :         WRMSG(HHC00983, "D", SSID_TO_LCSS(pDEVBLK->ssid), pDEVBLK->devnum, pDEVBLK->typname,

  0025e	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR pLCSPORT$[rsp]
  00266	48 05 48 01 00
	00		 add	 rax, 328		; 00000148H
  0026c	48 89 84 24 a8
	00 00 00	 mov	 QWORD PTR tv173[rsp], rax
  00274	48 8b 8c 24 50
	02 00 00	 mov	 rcx, QWORD PTR pLCSDEV$[rsp]
  0027c	0f b6 49 23	 movzx	 ecx, BYTE PTR [rcx+35]
  00280	89 8c 24 94 00
	00 00		 mov	 DWORD PTR tv178[rsp], ecx
  00287	48 8b 94 24 80
	00 00 00	 mov	 rdx, QWORD PTR pDEVBLK$[rsp]
  0028f	0f b7 52 48	 movzx	 edx, WORD PTR [rdx+72]
  00293	89 94 24 98 00
	00 00		 mov	 DWORD PTR tv183[rsp], edx
  0029a	48 8b bc 24 80
	00 00 00	 mov	 rdi, QWORD PTR pDEVBLK$[rsp]
  002a2	0f b7 7f 44	 movzx	 edi, WORD PTR [rdi+68]
  002a6	d1 ff		 sar	 edi, 1
  002a8	b9 01 00 00 00	 mov	 ecx, 1
  002ad	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  002b3	48 8b 8c 24 a8
	00 00 00	 mov	 rcx, QWORD PTR tv173[rsp]
  002bb	48 89 4c 24 68	 mov	 QWORD PTR [rsp+104], rcx
  002c0	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG173979
  002c7	48 89 4c 24 60	 mov	 QWORD PTR [rsp+96], rcx
  002cc	8b 4c 24 70	 mov	 ecx, DWORD PTR iEthLen$[rsp]
  002d0	89 4c 24 58	 mov	 DWORD PTR [rsp+88], ecx
  002d4	8b 8c 24 94 00
	00 00		 mov	 ecx, DWORD PTR tv178[rsp]
  002db	89 4c 24 50	 mov	 DWORD PTR [rsp+80], ecx
  002df	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR pDEVBLK$[rsp]
  002e7	48 8b 49 50	 mov	 rcx, QWORD PTR [rcx+80]
  002eb	48 89 4c 24 48	 mov	 QWORD PTR [rsp+72], rcx
  002f0	8b 8c 24 98 00
	00 00		 mov	 ecx, DWORD PTR tv183[rsp]
  002f7	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  002fb	89 7c 24 38	 mov	 DWORD PTR [rsp+56], edi
  002ff	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG173980
  00306	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  0030b	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG173981
  00312	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00317	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  0031c	41 b9 03 00 00
	00		 mov	 r9d, 3
  00322	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG173982
  00329	ba ef 12 00 00	 mov	 edx, 4847		; 000012efH
  0032e	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG173983
  00335	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 4847 :                              pLCSDEV->bPort, iEthLen, "802.3 SNA", pLCSPORT->szNetIfName );
; 4848 :         net_data_trace( pDEVBLK, (BYTE*)pEthFrame, iEthLen, FROM_GUEST, 'D', "eth frame", 0 );

  0033b	c7 44 24 30 00
	00 00 00	 mov	 DWORD PTR [rsp+48], 0
  00343	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG173984
  0034a	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  0034f	c6 44 24 20 44	 mov	 BYTE PTR [rsp+32], 68	; 00000044H
  00354	41 b1 3c	 mov	 r9b, 60			; 0000003cH
  00357	44 8b 44 24 70	 mov	 r8d, DWORD PTR iEthLen$[rsp]
  0035c	48 8b 54 24 78	 mov	 rdx, QWORD PTR pEthFrame$[rsp]
  00361	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR pDEVBLK$[rsp]
  00369	e8 00 00 00 00	 call	 net_data_trace
$LN24@Process_0D:

; 4849 :     }
; 4850 : 
; 4851 :     // Write the Ethernet frame to the TAP device
; 4852 :     if (TUNTAP_Write( pDEVBLK->fd, (BYTE*)pEthFrame, iEthLen ) == iEthLen)

  0036e	44 8b 44 24 70	 mov	 r8d, DWORD PTR iEthLen$[rsp]
  00373	48 8b 54 24 78	 mov	 rdx, QWORD PTR pEthFrame$[rsp]
  00378	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR pDEVBLK$[rsp]
  00380	8b 88 ac 01 00
	00		 mov	 ecx, DWORD PTR [rax+428]
  00386	e8 00 00 00 00	 call	 tt32_write
  0038b	3b 44 24 70	 cmp	 eax, DWORD PTR iEthLen$[rsp]
  0038f	0f 85 a4 00 00
	00		 jne	 $LN25@Process_0D

; 4853 :     {
; 4854 :         if (pLCSPORT->pLCSBLK->fDebug)

  00395	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR pLCSPORT$[rsp]
  0039d	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  003a1	8b 40 18	 mov	 eax, DWORD PTR [rax+24]
  003a4	83 e0 01	 and	 eax, 1
  003a7	85 c0		 test	 eax, eax
  003a9	0f 84 85 00 00
	00		 je	 $LN27@Process_0D

; 4855 :         {
; 4856 :             snprintf( llcmsg, sizeof(llcmsg), "LCS: LLC unnumbered frame sent: CR=%u, M=%s", llc.hwCR, "SABME" );

  003af	0f b7 84 24 c4
	00 00 00	 movzx	 eax, WORD PTR llc$[rsp+20]
  003b7	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG173988
  003be	48 89 4c 24 20	 mov	 QWORD PTR [rsp+32], rcx
  003c3	44 8b c8	 mov	 r9d, eax
  003c6	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG173989
  003cd	ba 00 01 00 00	 mov	 edx, 256		; 00000100H
  003d2	48 8d 8c 24 20
	01 00 00	 lea	 rcx, QWORD PTR llcmsg$[rsp]
  003da	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_snprintf

; 4857 :             WRMSG(HHC03984, "D", llcmsg );  /* FixMe! Proper message number! */

  003e0	b9 01 00 00 00	 mov	 ecx, 1
  003e5	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  003eb	48 8d 8c 24 20
	01 00 00	 lea	 rcx, QWORD PTR llcmsg$[rsp]
  003f3	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  003f8	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG173990
  003ff	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  00404	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG173991
  0040b	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00410	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00415	41 b9 03 00 00
	00		 mov	 r9d, 3
  0041b	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG173992
  00422	ba f9 12 00 00	 mov	 edx, 4857		; 000012f9H
  00427	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG173993
  0042e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg
$LN27@Process_0D:

; 4858 :         }
; 4859 :     }

  00434	e9 82 00 00 00	 jmp	 $LN26@Process_0D
$LN25@Process_0D:

; 4860 :     else
; 4861 :     {
; 4862 :         pLCSDEV->iTuntapErrno = errno;

  00439	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno
  0043f	48 8b 8c 24 50
	02 00 00	 mov	 rcx, QWORD PTR pLCSDEV$[rsp]
  00447	8b 00		 mov	 eax, DWORD PTR [rax]
  00449	89 41 61	 mov	 DWORD PTR [rcx+97], eax

; 4863 :         pLCSDEV->fTuntapError = TRUE;

  0044c	48 8b 84 24 50
	02 00 00	 mov	 rax, QWORD PTR pLCSDEV$[rsp]
  00454	8b 40 5d	 mov	 eax, DWORD PTR [rax+93]
  00457	83 c8 10	 or	 eax, 16
  0045a	48 8b 8c 24 50
	02 00 00	 mov	 rcx, QWORD PTR pLCSDEV$[rsp]
  00462	89 41 5d	 mov	 DWORD PTR [rcx+93], eax
$LN22@Process_0D:

; 4864 :         PTT_TIMING( "*WRITE ERR", 0, iEthLen, 1 );

  00465	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_pttclass
  0046c	48 8b 00	 mov	 rax, QWORD PTR [rax]
  0046f	48 25 00 00 01
	00		 and	 rax, 65536		; 00010000H
  00475	48 85 c0	 test	 rax, rax
  00478	74 3b		 je	 SHORT $LN28@Process_0D
  0047a	48 63 44 24 70	 movsxd	 rax, DWORD PTR iEthLen$[rsp]
  0047f	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR [rsp+48], 0
  00488	48 c7 44 24 28
	01 00 00 00	 mov	 QWORD PTR [rsp+40], 1
  00491	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG173995
  00498	48 89 4c 24 20	 mov	 QWORD PTR [rsp+32], rcx
  0049d	4c 8b c8	 mov	 r9, rax
  004a0	45 33 c0	 xor	 r8d, r8d
  004a3	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG173996
  004aa	b9 00 00 01 00	 mov	 ecx, 65536		; 00010000H
  004af	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ptt_pthread_trace
$LN28@Process_0D:
  004b5	33 c0		 xor	 eax, eax
  004b7	85 c0		 test	 eax, eax
  004b9	75 aa		 jne	 SHORT $LN22@Process_0D
$LN26@Process_0D:
$LN1@Process_0D:

; 4865 :     }
; 4866 : 
; 4867 :     return;
; 4868 : }

  004bb	48 8b 8c 24 20
	02 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  004c3	48 33 cc	 xor	 rcx, rsp
  004c6	e8 00 00 00 00	 call	 __security_check_cookie
  004cb	48 81 c4 38 02
	00 00		 add	 rsp, 568		; 00000238H
  004d2	5f		 pop	 rdi
  004d3	5e		 pop	 rsi
  004d4	c3		 ret	 0
Process_0D00 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\ctc_lcs.c
_TEXT	SEGMENT
iEthLen$ = 112
iTHetcLen$ = 116
iLPDULen$ = 120
iTraceLen$ = 124
pLCSCONN$ = 128
pEthFrame$ = 136
pDEVBLK$ = 144
pLCSPORT$ = 152
tv224 = 160
tv229 = 164
tv252 = 168
tv258 = 172
tv262 = 176
tv219 = 184
llc$ = 192
llcmsg$ = 240
frame$ = 496
__$ArrayPad$ = 2096
pLCSDEV$ = 2144
pLCSHDR$ = 2152
pLCSBAF1$ = 2160
pLCSBAF2$ = 2168
hwLenBaf1$ = 2176
hwLenBaf2$ = 2184
Process_0D10 PROC

; 4662 : {

  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	56		 push	 rsi
  00015	57		 push	 rdi
  00016	48 81 ec 48 08
	00 00		 sub	 rsp, 2120		; 00000848H
  0001d	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00024	48 33 c4	 xor	 rax, rsp
  00027	48 89 84 24 30
	08 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax
$LN4@Process_0D:

; 4663 : //                   Token
; 4664 : //  000F0D1000426002 40000240 00FF00
; 4665 : //  0 1 2 3 4 5 6 7  8 9 A B  C D E
; 4666 : //
; 4667 : //             TH etc
; 4668 : //  0100000000 xxxxxxxx...........
; 4669 : //  0 1 2 3 4  5 6 7 8 9 A B C ...
; 4670 : 
; 4671 :     DEVBLK*   pDEVBLK;
; 4672 :     PLCSPORT  pLCSPORT;
; 4673 :     PLCSCONN  pLCSCONN;
; 4674 :     PETHFRM   pEthFrame;
; 4675 :     int       iEthLen;
; 4676 :     int       iLPDULen;
; 4677 :     LLC       llc;
; 4678 :     int       iTHetcLen;
; 4679 :     int       iTraceLen;
; 4680 :     BYTE      frame[1600];
; 4681 :     char      llcmsg[256];
; 4682 : 
; 4683 :     UNREFERENCED( pLCSHDR   );

  0002f	33 c0		 xor	 eax, eax
  00031	85 c0		 test	 eax, eax
  00033	75 fa		 jne	 SHORT $LN4@Process_0D
$LN7@Process_0D:

; 4684 :     UNREFERENCED( hwLenBaf1 );

  00035	33 c0		 xor	 eax, eax
  00037	85 c0		 test	 eax, eax
  00039	75 fa		 jne	 SHORT $LN7@Process_0D

; 4685 : 
; 4686 :     pDEVBLK = pLCSDEV->pDEVBLK[ LCS_READ_SUBCHANN ];

  0003b	b8 08 00 00 00	 mov	 eax, 8
  00040	48 6b c0 00	 imul	 rax, rax, 0
  00044	48 8b 8c 24 60
	08 00 00	 mov	 rcx, QWORD PTR pLCSDEV$[rsp]
  0004c	48 8b 44 01 10	 mov	 rax, QWORD PTR [rcx+rax+16]
  00051	48 89 84 24 90
	00 00 00	 mov	 QWORD PTR pDEVBLK$[rsp], rax

; 4687 :     pLCSPORT = &pLCSDEV->pLCSBLK->Port[pLCSDEV->bPort];

  00059	48 8b 84 24 60
	08 00 00	 mov	 rax, QWORD PTR pLCSDEV$[rsp]
  00061	48 8b 40 08	 mov	 rax, QWORD PTR [rax+8]
  00065	48 8b 8c 24 60
	08 00 00	 mov	 rcx, QWORD PTR pLCSDEV$[rsp]
  0006d	0f b6 49 23	 movzx	 ecx, BYTE PTR [rcx+35]
  00071	48 69 c9 98 01
	00 00		 imul	 rcx, rcx, 408		; 00000198H
  00078	48 8d 44 08 60	 lea	 rax, QWORD PTR [rax+rcx+96]
  0007d	48 89 84 24 98
	00 00 00	 mov	 QWORD PTR pLCSPORT$[rsp], rax

; 4688 :     memset( frame, 0, sizeof(frame) );                               // Clear area for ethernet fram

  00085	48 8d 84 24 f0
	01 00 00	 lea	 rax, QWORD PTR frame$[rsp]
  0008d	48 8b f8	 mov	 rdi, rax
  00090	33 c0		 xor	 eax, eax
  00092	b9 40 06 00 00	 mov	 ecx, 1600		; 00000640H
  00097	f3 aa		 rep stosb

; 4689 :     pEthFrame = (PETHFRM)&frame[0];

  00099	b8 01 00 00 00	 mov	 eax, 1
  0009e	48 6b c0 00	 imul	 rax, rax, 0
  000a2	48 8d 84 04 f0
	01 00 00	 lea	 rax, QWORD PTR frame$[rsp+rax]
  000aa	48 89 84 24 88
	00 00 00	 mov	 QWORD PTR pEthFrame$[rsp], rax

; 4690 :     iEthLen = 60;                                                    // Minimum ethernet frame length

  000b2	c7 44 24 70 3c
	00 00 00	 mov	 DWORD PTR iEthLen$[rsp], 60 ; 0000003cH

; 4691 : 
; 4692 :     // Find the connection block.
; 4693 :     pLCSCONN = find_connection_by_outbound_token( pLCSDEV, pLCSBAF1->bTokenA );

  000ba	48 8b 84 24 70
	08 00 00	 mov	 rax, QWORD PTR pLCSBAF1$[rsp]
  000c2	48 83 c0 08	 add	 rax, 8
  000c6	48 8b d0	 mov	 rdx, rax
  000c9	48 8b 8c 24 60
	08 00 00	 mov	 rcx, QWORD PTR pLCSDEV$[rsp]
  000d1	e8 00 00 00 00	 call	 find_connection_by_outbound_token
  000d6	48 89 84 24 80
	00 00 00	 mov	 QWORD PTR pLCSCONN$[rsp], rax

; 4694 :     if (!pLCSCONN)

  000de	48 83 bc 24 80
	00 00 00 00	 cmp	 QWORD PTR pLCSCONN$[rsp], 0
  000e7	75 58		 jne	 SHORT $LN11@Process_0D

; 4695 :     {
; 4696 :         WRMSG( HHC03984, "W", "LCSCONN not found");

  000e9	b9 01 00 00 00	 mov	 ecx, 1
  000ee	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  000f4	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG173880
  000fb	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  00100	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG173881
  00107	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  0010c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG173882
  00113	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00118	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  0011d	41 b9 03 00 00
	00		 mov	 r9d, 3
  00123	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG173883
  0012a	ba 58 12 00 00	 mov	 edx, 4696		; 00001258H
  0012f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG173884
  00136	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 4697 :         /* FixMe! Need a proper error message here! */
; 4698 :         return;

  0013c	e9 b2 05 00 00	 jmp	 $LN1@Process_0D
$LN11@Process_0D:

; 4699 :     }
; 4700 : 
; 4701 :     //
; 4702 :     memset( &llc, 0, sizeof(LLC) );

  00141	48 8d 84 24 c0
	00 00 00	 lea	 rax, QWORD PTR llc$[rsp]
  00149	48 8b f8	 mov	 rdi, rax
  0014c	33 c0		 xor	 eax, eax
  0014e	b9 2e 00 00 00	 mov	 ecx, 46			; 0000002eH
  00153	f3 aa		 rep stosb

; 4703 :     llc.hwDSAP    = LSAP_SNA_Path_Control;

  00155	b8 04 00 00 00	 mov	 eax, 4
  0015a	66 89 84 24 ce
	00 00 00	 mov	 WORD PTR llc$[rsp+14], ax

; 4704 :     llc.hwSSAP    = LSAP_SNA_Path_Control;

  00162	b8 04 00 00 00	 mov	 eax, 4
  00167	66 89 84 24 d2
	00 00 00	 mov	 WORD PTR llc$[rsp+18], ax

; 4705 :     llc.hwNS      = pLCSCONN->hwLocalNS;

  0016f	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR pLCSCONN$[rsp]
  00177	0f b7 40 24	 movzx	 eax, WORD PTR [rax+36]
  0017b	66 89 84 24 d6
	00 00 00	 mov	 WORD PTR llc$[rsp+22], ax

; 4706 :     pLCSCONN->hwLocalNS = ((pLCSCONN->hwLocalNS + 1) & 0x7F);

  00183	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR pLCSCONN$[rsp]
  0018b	0f b7 40 24	 movzx	 eax, WORD PTR [rax+36]
  0018f	ff c0		 inc	 eax
  00191	83 e0 7f	 and	 eax, 127		; 0000007fH
  00194	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR pLCSCONN$[rsp]
  0019c	66 89 41 24	 mov	 WORD PTR [rcx+36], ax

; 4707 :     if (pLCSCONN->fIframe)

  001a0	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR pLCSCONN$[rsp]
  001a8	8b 40 2c	 mov	 eax, DWORD PTR [rax+44]
  001ab	83 e0 01	 and	 eax, 1
  001ae	85 c0		 test	 eax, eax
  001b0	74 19		 je	 SHORT $LN12@Process_0D

; 4708 :     {
; 4709 :          llc.hwNR  = ((pLCSCONN->hwRemoteNS + 1) & 0x7F);

  001b2	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR pLCSCONN$[rsp]
  001ba	0f b7 40 28	 movzx	 eax, WORD PTR [rax+40]
  001be	ff c0		 inc	 eax
  001c0	83 e0 7f	 and	 eax, 127		; 0000007fH
  001c3	66 89 84 24 d8
	00 00 00	 mov	 WORD PTR llc$[rsp+24], ax
$LN12@Process_0D:

; 4710 :     }
; 4711 :     llc.hwType    = Type_Information_Frame;

  001cb	b8 01 00 00 00	 mov	 eax, 1
  001d0	66 89 84 24 ec
	00 00 00	 mov	 WORD PTR llc$[rsp+44], ax

; 4712 : 
; 4713 :     // Construct Ethernet frame
; 4714 :     memcpy( &pEthFrame->bDestMAC, &pLCSCONN->bRemoteMAC, IFHWADDRLEN );   // Copy destination MAC address

  001d8	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR pLCSCONN$[rsp]
  001e0	48 8b bc 24 88
	00 00 00	 mov	 rdi, QWORD PTR pEthFrame$[rsp]
  001e8	48 8d 70 16	 lea	 rsi, QWORD PTR [rax+22]
  001ec	b9 06 00 00 00	 mov	 ecx, 6
  001f1	f3 a4		 rep movsb

; 4715 :     memcpy( &pEthFrame->bSrcMAC, &pLCSCONN->bLocalMAC, IFHWADDRLEN );     // Copy source MAC address

  001f3	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR pEthFrame$[rsp]
  001fb	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR pLCSCONN$[rsp]
  00203	48 8d 78 06	 lea	 rdi, QWORD PTR [rax+6]
  00207	48 8d 71 10	 lea	 rsi, QWORD PTR [rcx+16]
  0020b	b9 06 00 00 00	 mov	 ecx, 6
  00210	f3 a4		 rep movsb

; 4716 :     iLPDULen = BuildLLC( &llc, pEthFrame->bData);                         // Build LLC PDU

  00212	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR pEthFrame$[rsp]
  0021a	48 83 c0 0e	 add	 rax, 14
  0021e	48 8b d0	 mov	 rdx, rax
  00221	48 8d 8c 24 c0
	00 00 00	 lea	 rcx, QWORD PTR llc$[rsp]
  00229	e8 00 00 00 00	 call	 BuildLLC
  0022e	89 44 24 78	 mov	 DWORD PTR iLPDULen$[rsp], eax

; 4717 :     STORE_HW( pEthFrame->hwEthernetType, (U16)iLPDULen );                 // Set data length

  00232	0f b7 4c 24 78	 movzx	 ecx, WORD PTR iLPDULen$[rsp]
  00237	e8 00 00 00 00	 call	 _byteswap_ushort
  0023c	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR pEthFrame$[rsp]
  00244	48 83 c1 0c	 add	 rcx, 12
  00248	0f b7 d0	 movzx	 edx, ax
  0024b	e8 00 00 00 00	 call	 store_hw_noswap

; 4718 : 
; 4719 :     // Continue Ethernet frame construction if there is a TH etc.
; 4720 :     iTHetcLen = ( hwLenBaf2 - 5 );                                        // Calculate length of TH etc

  00250	0f b7 84 24 88
	08 00 00	 movzx	 eax, WORD PTR hwLenBaf2$[rsp]
  00258	83 e8 05	 sub	 eax, 5
  0025b	89 44 24 74	 mov	 DWORD PTR iTHetcLen$[rsp], eax

; 4721 :     if ( iTHetcLen > 0 )                                                  // Any TH etc?

  0025f	83 7c 24 74 00	 cmp	 DWORD PTR iTHetcLen$[rsp], 0
  00264	0f 8e fa 00 00
	00		 jle	 $LN13@Process_0D

; 4722 :     {
; 4723 :         if ( iTHetcLen > 1493 )                                           // 1493 = 0x5D5

  0026a	81 7c 24 74 d5
	05 00 00	 cmp	 DWORD PTR iTHetcLen$[rsp], 1493 ; 000005d5H
  00272	7e 78		 jle	 SHORT $LN14@Process_0D

; 4724 :         {
; 4725 :             snprintf( llcmsg, sizeof(llcmsg), "LCS: Ignoring over long data of %d bytes!!!", iTHetcLen );

  00274	44 8b 4c 24 74	 mov	 r9d, DWORD PTR iTHetcLen$[rsp]
  00279	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG173888
  00280	ba 00 01 00 00	 mov	 edx, 256		; 00000100H
  00285	48 8d 8c 24 f0
	00 00 00	 lea	 rcx, QWORD PTR llcmsg$[rsp]
  0028d	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_snprintf

; 4726 :             WRMSG(HHC03984, "W", llcmsg );  /* FixMe! Proper message number! */

  00293	b9 01 00 00 00	 mov	 ecx, 1
  00298	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  0029e	48 8d 8c 24 f0
	00 00 00	 lea	 rcx, QWORD PTR llcmsg$[rsp]
  002a6	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  002ab	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG173889
  002b2	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  002b7	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG173890
  002be	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  002c3	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  002c8	41 b9 03 00 00
	00		 mov	 r9d, 3
  002ce	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG173891
  002d5	ba 76 12 00 00	 mov	 edx, 4726		; 00001276H
  002da	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG173892
  002e1	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 4727 :             return;

  002e7	e9 07 04 00 00	 jmp	 $LN1@Process_0D
$LN14@Process_0D:

; 4728 :         }
; 4729 :         STORE_HW( pEthFrame->hwEthernetType, (U16)(iLPDULen + iTHetcLen) );     // Set LLC and TH etc length

  002ec	8b 44 24 74	 mov	 eax, DWORD PTR iTHetcLen$[rsp]
  002f0	8b 4c 24 78	 mov	 ecx, DWORD PTR iLPDULen$[rsp]
  002f4	03 c8		 add	 ecx, eax
  002f6	8b c1		 mov	 eax, ecx
  002f8	0f b7 c8	 movzx	 ecx, ax
  002fb	e8 00 00 00 00	 call	 _byteswap_ushort
  00300	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR pEthFrame$[rsp]
  00308	48 83 c1 0c	 add	 rcx, 12
  0030c	0f b7 d0	 movzx	 edx, ax
  0030f	e8 00 00 00 00	 call	 store_hw_noswap

; 4730 :         memcpy( &pEthFrame->bData[iLPDULen], &pLCSBAF2->bByte05, iTHetcLen );   // Copy TH etc

  00314	48 63 44 24 74	 movsxd	 rax, DWORD PTR iTHetcLen$[rsp]
  00319	48 8b 8c 24 78
	08 00 00	 mov	 rcx, QWORD PTR pLCSBAF2$[rsp]
  00321	48 83 c1 05	 add	 rcx, 5
  00325	48 63 54 24 78	 movsxd	 rdx, DWORD PTR iLPDULen$[rsp]
  0032a	48 8b bc 24 88
	00 00 00	 mov	 rdi, QWORD PTR pEthFrame$[rsp]
  00332	48 8d 54 17 0e	 lea	 rdx, QWORD PTR [rdi+rdx+14]
  00337	48 8b fa	 mov	 rdi, rdx
  0033a	48 8b f1	 mov	 rsi, rcx
  0033d	48 8b c8	 mov	 rcx, rax
  00340	f3 a4		 rep movsb

; 4731 :         if ( iEthLen < ((IFHWADDRLEN * 2) + 2 + iLPDULen + iTHetcLen) )

  00342	8b 44 24 78	 mov	 eax, DWORD PTR iLPDULen$[rsp]
  00346	8b 4c 24 74	 mov	 ecx, DWORD PTR iTHetcLen$[rsp]
  0034a	8d 44 08 0e	 lea	 eax, DWORD PTR [rax+rcx+14]
  0034e	39 44 24 70	 cmp	 DWORD PTR iEthLen$[rsp], eax
  00352	7d 10		 jge	 SHORT $LN15@Process_0D

; 4732 :         {
; 4733 :             iEthLen = ((IFHWADDRLEN * 2) + 2 + iLPDULen + iTHetcLen);

  00354	8b 44 24 78	 mov	 eax, DWORD PTR iLPDULen$[rsp]
  00358	8b 4c 24 74	 mov	 ecx, DWORD PTR iTHetcLen$[rsp]
  0035c	8d 44 08 0e	 lea	 eax, DWORD PTR [rax+rcx+14]
  00360	89 44 24 70	 mov	 DWORD PTR iEthLen$[rsp], eax
$LN15@Process_0D:
$LN13@Process_0D:

; 4734 :         }
; 4735 :     }
; 4736 : 
; 4737 :     // Trace Ethernet frame before sending to TAP device
; 4738 :     if (pLCSPORT->pLCSBLK->fDebug)

  00364	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR pLCSPORT$[rsp]
  0036c	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  00370	8b 40 18	 mov	 eax, DWORD PTR [rax+24]
  00373	83 e0 01	 and	 eax, 1
  00376	85 c0		 test	 eax, eax
  00378	0f 84 19 02 00
	00		 je	 $LN16@Process_0D

; 4739 :     {
; 4740 :         // "%1d:%04X %s: port %2.2X: Send frame of size %d bytes (with %s packet) to device %s"
; 4741 :         WRMSG(HHC00983, "D", SSID_TO_LCSS(pDEVBLK->ssid), pDEVBLK->devnum, pDEVBLK->typname,

  0037e	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR pLCSPORT$[rsp]
  00386	48 05 48 01 00
	00		 add	 rax, 328		; 00000148H
  0038c	48 89 84 24 b8
	00 00 00	 mov	 QWORD PTR tv219[rsp], rax
  00394	48 8b 8c 24 60
	08 00 00	 mov	 rcx, QWORD PTR pLCSDEV$[rsp]
  0039c	0f b6 49 23	 movzx	 ecx, BYTE PTR [rcx+35]
  003a0	89 8c 24 a0 00
	00 00		 mov	 DWORD PTR tv224[rsp], ecx
  003a7	48 8b 94 24 90
	00 00 00	 mov	 rdx, QWORD PTR pDEVBLK$[rsp]
  003af	0f b7 52 48	 movzx	 edx, WORD PTR [rdx+72]
  003b3	89 94 24 a4 00
	00 00		 mov	 DWORD PTR tv229[rsp], edx
  003ba	48 8b bc 24 90
	00 00 00	 mov	 rdi, QWORD PTR pDEVBLK$[rsp]
  003c2	0f b7 7f 44	 movzx	 edi, WORD PTR [rdi+68]
  003c6	d1 ff		 sar	 edi, 1
  003c8	b9 01 00 00 00	 mov	 ecx, 1
  003cd	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  003d3	48 8b 8c 24 b8
	00 00 00	 mov	 rcx, QWORD PTR tv219[rsp]
  003db	48 89 4c 24 68	 mov	 QWORD PTR [rsp+104], rcx
  003e0	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG173895
  003e7	48 89 4c 24 60	 mov	 QWORD PTR [rsp+96], rcx
  003ec	8b 4c 24 70	 mov	 ecx, DWORD PTR iEthLen$[rsp]
  003f0	89 4c 24 58	 mov	 DWORD PTR [rsp+88], ecx
  003f4	8b 8c 24 a0 00
	00 00		 mov	 ecx, DWORD PTR tv224[rsp]
  003fb	89 4c 24 50	 mov	 DWORD PTR [rsp+80], ecx
  003ff	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR pDEVBLK$[rsp]
  00407	48 8b 49 50	 mov	 rcx, QWORD PTR [rcx+80]
  0040b	48 89 4c 24 48	 mov	 QWORD PTR [rsp+72], rcx
  00410	8b 8c 24 a4 00
	00 00		 mov	 ecx, DWORD PTR tv229[rsp]
  00417	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  0041b	89 7c 24 38	 mov	 DWORD PTR [rsp+56], edi
  0041f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG173896
  00426	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  0042b	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG173897
  00432	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00437	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  0043c	41 b9 03 00 00
	00		 mov	 r9d, 3
  00442	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG173898
  00449	ba 86 12 00 00	 mov	 edx, 4742		; 00001286H
  0044e	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG173899
  00455	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 4742 :                              pLCSDEV->bPort, iEthLen, "802.3 SNA", pLCSPORT->szNetIfName );
; 4743 :         if (pLCSPORT->pLCSBLK->iTraceLen)

  0045b	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR pLCSPORT$[rsp]
  00463	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  00467	83 78 28 00	 cmp	 DWORD PTR [rax+40], 0
  0046b	0f 84 26 01 00
	00		 je	 $LN17@Process_0D

; 4744 :         {
; 4745 :             iTraceLen = iEthLen;

  00471	8b 44 24 70	 mov	 eax, DWORD PTR iEthLen$[rsp]
  00475	89 44 24 7c	 mov	 DWORD PTR iTraceLen$[rsp], eax

; 4746 :             if (iTraceLen > pLCSPORT->pLCSBLK->iTraceLen)

  00479	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR pLCSPORT$[rsp]
  00481	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  00485	8b 40 28	 mov	 eax, DWORD PTR [rax+40]
  00488	39 44 24 7c	 cmp	 DWORD PTR iTraceLen$[rsp], eax
  0048c	0f 8e cf 00 00
	00		 jle	 $LN18@Process_0D

; 4747 :             {
; 4748 :                 iTraceLen = pLCSPORT->pLCSBLK->iTraceLen;

  00492	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR pLCSPORT$[rsp]
  0049a	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  0049e	8b 40 28	 mov	 eax, DWORD PTR [rax+40]
  004a1	89 44 24 7c	 mov	 DWORD PTR iTraceLen$[rsp], eax

; 4749 :                 // HHC00980 "%1d:%04X %s: Data of size %d bytes displayed, data of size %d bytes not displayed"
; 4750 :                 WRMSG(HHC00980, "D", SSID_TO_LCSS(pDEVBLK->ssid), pDEVBLK->devnum, pDEVBLK->typname,

  004a5	8b 44 24 7c	 mov	 eax, DWORD PTR iTraceLen$[rsp]
  004a9	8b 4c 24 70	 mov	 ecx, DWORD PTR iEthLen$[rsp]
  004ad	2b c8		 sub	 ecx, eax
  004af	8b c1		 mov	 eax, ecx
  004b1	89 84 24 a8 00
	00 00		 mov	 DWORD PTR tv252[rsp], eax
  004b8	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR pDEVBLK$[rsp]
  004c0	0f b7 49 48	 movzx	 ecx, WORD PTR [rcx+72]
  004c4	89 8c 24 ac 00
	00 00		 mov	 DWORD PTR tv258[rsp], ecx
  004cb	48 8b 94 24 90
	00 00 00	 mov	 rdx, QWORD PTR pDEVBLK$[rsp]
  004d3	0f b7 52 44	 movzx	 edx, WORD PTR [rdx+68]
  004d7	d1 fa		 sar	 edx, 1
  004d9	89 94 24 b0 00
	00 00		 mov	 DWORD PTR tv262[rsp], edx
  004e0	b9 01 00 00 00	 mov	 ecx, 1
  004e5	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  004eb	8b 8c 24 a8 00
	00 00		 mov	 ecx, DWORD PTR tv252[rsp]
  004f2	89 4c 24 58	 mov	 DWORD PTR [rsp+88], ecx
  004f6	8b 4c 24 7c	 mov	 ecx, DWORD PTR iTraceLen$[rsp]
  004fa	89 4c 24 50	 mov	 DWORD PTR [rsp+80], ecx
  004fe	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR pDEVBLK$[rsp]
  00506	48 8b 49 50	 mov	 rcx, QWORD PTR [rcx+80]
  0050a	48 89 4c 24 48	 mov	 QWORD PTR [rsp+72], rcx
  0050f	8b 8c 24 ac 00
	00 00		 mov	 ecx, DWORD PTR tv258[rsp]
  00516	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  0051a	8b 8c 24 b0 00
	00 00		 mov	 ecx, DWORD PTR tv262[rsp]
  00521	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  00525	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG173902
  0052c	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  00531	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG173903
  00538	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  0053d	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00542	41 b9 03 00 00
	00		 mov	 r9d, 3
  00548	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG173904
  0054f	ba 8f 12 00 00	 mov	 edx, 4751		; 0000128fH
  00554	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG173905
  0055b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg
$LN18@Process_0D:

; 4751 :                                      iTraceLen, (iEthLen - iTraceLen) );
; 4752 :             }
; 4753 :             net_data_trace( pDEVBLK, (BYTE*)pEthFrame, iTraceLen, FROM_GUEST, 'D', "eth frame", 0 );

  00561	c7 44 24 30 00
	00 00 00	 mov	 DWORD PTR [rsp+48], 0
  00569	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG173906
  00570	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  00575	c6 44 24 20 44	 mov	 BYTE PTR [rsp+32], 68	; 00000044H
  0057a	41 b1 3c	 mov	 r9b, 60			; 0000003cH
  0057d	44 8b 44 24 7c	 mov	 r8d, DWORD PTR iTraceLen$[rsp]
  00582	48 8b 94 24 88
	00 00 00	 mov	 rdx, QWORD PTR pEthFrame$[rsp]
  0058a	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR pDEVBLK$[rsp]
  00592	e8 00 00 00 00	 call	 net_data_trace
$LN17@Process_0D:
$LN16@Process_0D:

; 4754 :         }
; 4755 :     }
; 4756 : 
; 4757 :     // Write the Ethernet frame to the TAP device
; 4758 :     if (TUNTAP_Write( pDEVBLK->fd, (BYTE*)pEthFrame, iEthLen ) == iEthLen)

  00597	44 8b 44 24 70	 mov	 r8d, DWORD PTR iEthLen$[rsp]
  0059c	48 8b 94 24 88
	00 00 00	 mov	 rdx, QWORD PTR pEthFrame$[rsp]
  005a4	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR pDEVBLK$[rsp]
  005ac	8b 88 ac 01 00
	00		 mov	 ecx, DWORD PTR [rax+428]
  005b2	e8 00 00 00 00	 call	 tt32_write
  005b7	3b 44 24 70	 cmp	 eax, DWORD PTR iEthLen$[rsp]
  005bb	0f 85 b0 00 00
	00		 jne	 $LN19@Process_0D

; 4759 :     {
; 4760 :         if (pLCSPORT->pLCSBLK->fDebug)

  005c1	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR pLCSPORT$[rsp]
  005c9	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  005cd	8b 40 18	 mov	 eax, DWORD PTR [rax+24]
  005d0	83 e0 01	 and	 eax, 1
  005d3	85 c0		 test	 eax, eax
  005d5	0f 84 91 00 00
	00		 je	 $LN21@Process_0D

; 4761 :         {
; 4762 :             snprintf( llcmsg, sizeof(llcmsg), "LCS: LLC information frame sent: CR=%u, NR=%u, NS=%u", llc.hwCR, llc.hwNR, llc.hwNS );

  005db	0f b7 84 24 d6
	00 00 00	 movzx	 eax, WORD PTR llc$[rsp+22]
  005e3	0f b7 8c 24 d8
	00 00 00	 movzx	 ecx, WORD PTR llc$[rsp+24]
  005eb	0f b7 94 24 d4
	00 00 00	 movzx	 edx, WORD PTR llc$[rsp+20]
  005f3	89 44 24 28	 mov	 DWORD PTR [rsp+40], eax
  005f7	89 4c 24 20	 mov	 DWORD PTR [rsp+32], ecx
  005fb	44 8b ca	 mov	 r9d, edx
  005fe	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG173910
  00605	ba 00 01 00 00	 mov	 edx, 256		; 00000100H
  0060a	48 8d 8c 24 f0
	00 00 00	 lea	 rcx, QWORD PTR llcmsg$[rsp]
  00612	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_snprintf

; 4763 :             WRMSG(HHC03984, "D", llcmsg );  /* FixMe! Proper message number! */

  00618	b9 01 00 00 00	 mov	 ecx, 1
  0061d	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  00623	48 8d 8c 24 f0
	00 00 00	 lea	 rcx, QWORD PTR llcmsg$[rsp]
  0062b	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  00630	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG173911
  00637	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  0063c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG173912
  00643	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00648	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  0064d	41 b9 03 00 00
	00		 mov	 r9d, 3
  00653	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG173913
  0065a	ba 9b 12 00 00	 mov	 edx, 4763		; 0000129bH
  0065f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG173914
  00666	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg
$LN21@Process_0D:

; 4764 :         }
; 4765 :     }

  0066c	e9 82 00 00 00	 jmp	 $LN20@Process_0D
$LN19@Process_0D:

; 4766 :     else
; 4767 :     {
; 4768 :         pLCSDEV->iTuntapErrno = errno;

  00671	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno
  00677	48 8b 8c 24 60
	08 00 00	 mov	 rcx, QWORD PTR pLCSDEV$[rsp]
  0067f	8b 00		 mov	 eax, DWORD PTR [rax]
  00681	89 41 61	 mov	 DWORD PTR [rcx+97], eax

; 4769 :         pLCSDEV->fTuntapError = TRUE;

  00684	48 8b 84 24 60
	08 00 00	 mov	 rax, QWORD PTR pLCSDEV$[rsp]
  0068c	8b 40 5d	 mov	 eax, DWORD PTR [rax+93]
  0068f	83 c8 10	 or	 eax, 16
  00692	48 8b 8c 24 60
	08 00 00	 mov	 rcx, QWORD PTR pLCSDEV$[rsp]
  0069a	89 41 5d	 mov	 DWORD PTR [rcx+93], eax
$LN10@Process_0D:

; 4770 :         PTT_TIMING( "*WRITE ERR", 0, iEthLen, 1 );

  0069d	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_pttclass
  006a4	48 8b 00	 mov	 rax, QWORD PTR [rax]
  006a7	48 25 00 00 01
	00		 and	 rax, 65536		; 00010000H
  006ad	48 85 c0	 test	 rax, rax
  006b0	74 3b		 je	 SHORT $LN22@Process_0D
  006b2	48 63 44 24 70	 movsxd	 rax, DWORD PTR iEthLen$[rsp]
  006b7	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR [rsp+48], 0
  006c0	48 c7 44 24 28
	01 00 00 00	 mov	 QWORD PTR [rsp+40], 1
  006c9	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG173916
  006d0	48 89 4c 24 20	 mov	 QWORD PTR [rsp+32], rcx
  006d5	4c 8b c8	 mov	 r9, rax
  006d8	45 33 c0	 xor	 r8d, r8d
  006db	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG173917
  006e2	b9 00 00 01 00	 mov	 ecx, 65536		; 00010000H
  006e7	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ptt_pthread_trace
$LN22@Process_0D:
  006ed	33 c0		 xor	 eax, eax
  006ef	85 c0		 test	 eax, eax
  006f1	75 aa		 jne	 SHORT $LN10@Process_0D
$LN20@Process_0D:
$LN1@Process_0D:

; 4771 :     }
; 4772 : 
; 4773 :     return;
; 4774 : }

  006f3	48 8b 8c 24 30
	08 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  006fb	48 33 cc	 xor	 rcx, rsp
  006fe	e8 00 00 00 00	 call	 __security_check_cookie
  00703	48 81 c4 48 08
	00 00		 add	 rsp, 2120		; 00000848H
  0070a	5f		 pop	 rdi
  0070b	5e		 pop	 rsi
  0070c	c3		 ret	 0
Process_0D10 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\ctc_lcs.c
_TEXT	SEGMENT
pLPDU$ = 32
iLPDUsize$ = 40
tv128 = 44
bInfo$ = 48
__$ArrayPad$ = 56
pLLC$ = 96
pStart$ = 104
BuildLLC PROC

; 7352 : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	56		 push	 rsi
  0000b	57		 push	 rdi
  0000c	48 83 ec 48	 sub	 rsp, 72			; 00000048H
  00010	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00017	48 33 c4	 xor	 rax, rsp
  0001a	48 89 44 24 38	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 7353 :     PLPDU     pLPDU;
; 7354 :     int       iLPDUsize;
; 7355 :     char      bInfo[6];
; 7356 : 
; 7357 : 
; 7358 :     pLPDU = (PLPDU)pStart;

  0001f	48 8b 44 24 68	 mov	 rax, QWORD PTR pStart$[rsp]
  00024	48 89 44 24 20	 mov	 QWORD PTR pLPDU$[rsp], rax

; 7359 : 
; 7360 :     pLPDU->bDSAP[0] = pLLC->hwDSAP;

  00029	b8 01 00 00 00	 mov	 eax, 1
  0002e	48 6b c0 00	 imul	 rax, rax, 0
  00032	48 8b 4c 24 20	 mov	 rcx, QWORD PTR pLPDU$[rsp]
  00037	48 8b 54 24 60	 mov	 rdx, QWORD PTR pLLC$[rsp]
  0003c	0f b6 52 0e	 movzx	 edx, BYTE PTR [rdx+14]
  00040	88 14 01	 mov	 BYTE PTR [rcx+rax], dl

; 7361 :     pLPDU->bDSAP[0] |= pLLC->hwIG;

  00043	b8 01 00 00 00	 mov	 eax, 1
  00048	48 6b c0 00	 imul	 rax, rax, 0
  0004c	48 8b 4c 24 60	 mov	 rcx, QWORD PTR pLLC$[rsp]
  00051	0f b7 49 10	 movzx	 ecx, WORD PTR [rcx+16]
  00055	48 8b 54 24 20	 mov	 rdx, QWORD PTR pLPDU$[rsp]
  0005a	0f b6 04 02	 movzx	 eax, BYTE PTR [rdx+rax]
  0005e	0b c1		 or	 eax, ecx
  00060	b9 01 00 00 00	 mov	 ecx, 1
  00065	48 6b c9 00	 imul	 rcx, rcx, 0
  00069	48 8b 54 24 20	 mov	 rdx, QWORD PTR pLPDU$[rsp]
  0006e	88 04 0a	 mov	 BYTE PTR [rdx+rcx], al

; 7362 :     pLPDU->bSSAP[0] = pLLC->hwSSAP;

  00071	b8 01 00 00 00	 mov	 eax, 1
  00076	48 6b c0 00	 imul	 rax, rax, 0
  0007a	48 8b 4c 24 20	 mov	 rcx, QWORD PTR pLPDU$[rsp]
  0007f	48 8b 54 24 60	 mov	 rdx, QWORD PTR pLLC$[rsp]
  00084	0f b6 52 12	 movzx	 edx, BYTE PTR [rdx+18]
  00088	88 54 01 01	 mov	 BYTE PTR [rcx+rax+1], dl

; 7363 :     pLPDU->bSSAP[0] |= pLLC->hwCR;

  0008c	b8 01 00 00 00	 mov	 eax, 1
  00091	48 6b c0 00	 imul	 rax, rax, 0
  00095	48 8b 4c 24 60	 mov	 rcx, QWORD PTR pLLC$[rsp]
  0009a	0f b7 49 14	 movzx	 ecx, WORD PTR [rcx+20]
  0009e	48 8b 54 24 20	 mov	 rdx, QWORD PTR pLPDU$[rsp]
  000a3	0f b6 44 02 01	 movzx	 eax, BYTE PTR [rdx+rax+1]
  000a8	0b c1		 or	 eax, ecx
  000aa	b9 01 00 00 00	 mov	 ecx, 1
  000af	48 6b c9 00	 imul	 rcx, rcx, 0
  000b3	48 8b 54 24 20	 mov	 rdx, QWORD PTR pLPDU$[rsp]
  000b8	88 44 0a 01	 mov	 BYTE PTR [rdx+rcx+1], al

; 7364 : 
; 7365 :     switch (pLLC->hwType)

  000bc	48 8b 44 24 60	 mov	 rax, QWORD PTR pLLC$[rsp]
  000c1	0f b7 40 2c	 movzx	 eax, WORD PTR [rax+44]
  000c5	89 44 24 2c	 mov	 DWORD PTR tv128[rsp], eax
  000c9	83 7c 24 2c 01	 cmp	 DWORD PTR tv128[rsp], 1
  000ce	0f 84 ab 02 00
	00		 je	 $LN8@BuildLLC
  000d4	83 7c 24 2c 02	 cmp	 DWORD PTR tv128[rsp], 2
  000d9	0f 84 03 02 00
	00		 je	 $LN7@BuildLLC
  000df	83 7c 24 2c 03	 cmp	 DWORD PTR tv128[rsp], 3
  000e4	74 05		 je	 SHORT $LN4@BuildLLC
  000e6	e9 08 03 00 00	 jmp	 $LN9@BuildLLC
$LN4@BuildLLC:

; 7366 :     {
; 7367 :     case Type_Unnumbered_Frame:
; 7368 :         // Unnumbered Frame.
; 7369 :         // The control field should be 1 byte.
; 7370 :         // Unnumbered frames provide link control functions, for
; 7371 :         // example, mode setting commands and responses. In some
; 7372 :         // cases, unnumbered information frames can also be sent.
; 7373 :         // They do not contain fields for NR or NS counts. Here is
; 7374 :         // the format of an unnumbered control:
; 7375 :         //   M-M-M-P/F-M-M-1-1
; 7376 : 
; 7377 :         pLPDU->bControl[0] = ((pLLC->hwM & 0x1C) << 3);

  000eb	48 8b 44 24 60	 mov	 rax, QWORD PTR pLLC$[rsp]
  000f0	0f b7 40 1e	 movzx	 eax, WORD PTR [rax+30]
  000f4	83 e0 1c	 and	 eax, 28
  000f7	c1 e0 03	 shl	 eax, 3
  000fa	b9 01 00 00 00	 mov	 ecx, 1
  000ff	48 6b c9 00	 imul	 rcx, rcx, 0
  00103	48 8b 54 24 20	 mov	 rdx, QWORD PTR pLPDU$[rsp]
  00108	88 44 0a 02	 mov	 BYTE PTR [rdx+rcx+2], al

; 7378 :         pLPDU->bControl[0] |= (pLLC->hwPF << 4);

  0010c	b8 01 00 00 00	 mov	 eax, 1
  00111	48 6b c0 00	 imul	 rax, rax, 0
  00115	48 8b 4c 24 60	 mov	 rcx, QWORD PTR pLLC$[rsp]
  0011a	0f b7 49 1a	 movzx	 ecx, WORD PTR [rcx+26]
  0011e	c1 e1 04	 shl	 ecx, 4
  00121	48 8b 54 24 20	 mov	 rdx, QWORD PTR pLPDU$[rsp]
  00126	0f b6 44 02 02	 movzx	 eax, BYTE PTR [rdx+rax+2]
  0012b	0b c1		 or	 eax, ecx
  0012d	b9 01 00 00 00	 mov	 ecx, 1
  00132	48 6b c9 00	 imul	 rcx, rcx, 0
  00136	48 8b 54 24 20	 mov	 rdx, QWORD PTR pLPDU$[rsp]
  0013b	88 44 0a 02	 mov	 BYTE PTR [rdx+rcx+2], al

; 7379 :         pLPDU->bControl[0] |= ((pLLC->hwM & 0x03) << 2);

  0013f	b8 01 00 00 00	 mov	 eax, 1
  00144	48 6b c0 00	 imul	 rax, rax, 0
  00148	48 8b 4c 24 60	 mov	 rcx, QWORD PTR pLLC$[rsp]
  0014d	0f b7 49 1e	 movzx	 ecx, WORD PTR [rcx+30]
  00151	83 e1 03	 and	 ecx, 3
  00154	c1 e1 02	 shl	 ecx, 2
  00157	48 8b 54 24 20	 mov	 rdx, QWORD PTR pLPDU$[rsp]
  0015c	0f b6 44 02 02	 movzx	 eax, BYTE PTR [rdx+rax+2]
  00161	0b c1		 or	 eax, ecx
  00163	b9 01 00 00 00	 mov	 ecx, 1
  00168	48 6b c9 00	 imul	 rcx, rcx, 0
  0016c	48 8b 54 24 20	 mov	 rdx, QWORD PTR pLPDU$[rsp]
  00171	88 44 0a 02	 mov	 BYTE PTR [rdx+rcx+2], al

; 7380 :         pLPDU->bControl[0] |= 0x03;

  00175	b8 01 00 00 00	 mov	 eax, 1
  0017a	48 6b c0 00	 imul	 rax, rax, 0
  0017e	48 8b 4c 24 20	 mov	 rcx, QWORD PTR pLPDU$[rsp]
  00183	0f b6 44 01 02	 movzx	 eax, BYTE PTR [rcx+rax+2]
  00188	83 c8 03	 or	 eax, 3
  0018b	b9 01 00 00 00	 mov	 ecx, 1
  00190	48 6b c9 00	 imul	 rcx, rcx, 0
  00194	48 8b 54 24 20	 mov	 rdx, QWORD PTR pLPDU$[rsp]
  00199	88 44 0a 02	 mov	 BYTE PTR [rdx+rcx+2], al

; 7381 : 
; 7382 :         if (pLLC->hwM == M_FRMR_Response)

  0019d	48 8b 44 24 60	 mov	 rax, QWORD PTR pLLC$[rsp]
  001a2	0f b7 40 1e	 movzx	 eax, WORD PTR [rax+30]
  001a6	83 f8 11	 cmp	 eax, 17
  001a9	0f 85 26 01 00
	00		 jne	 $LN5@BuildLLC

; 7383 :         {
; 7384 :             STORE_HW( bInfo, pLLC->hwCF );

  001af	48 8b 44 24 60	 mov	 rax, QWORD PTR pLLC$[rsp]
  001b4	0f b7 48 2a	 movzx	 ecx, WORD PTR [rax+42]
  001b8	e8 00 00 00 00	 call	 _byteswap_ushort
  001bd	0f b7 d0	 movzx	 edx, ax
  001c0	48 8d 4c 24 30	 lea	 rcx, QWORD PTR bInfo$[rsp]
  001c5	e8 00 00 00 00	 call	 store_hw_noswap

; 7385 :             bInfo[2] =  (pLLC->hwNS << 1);

  001ca	48 8b 44 24 60	 mov	 rax, QWORD PTR pLLC$[rsp]
  001cf	0f b7 40 16	 movzx	 eax, WORD PTR [rax+22]
  001d3	d1 e0		 shl	 eax, 1
  001d5	b9 01 00 00 00	 mov	 ecx, 1
  001da	48 6b c9 02	 imul	 rcx, rcx, 2
  001de	88 44 0c 30	 mov	 BYTE PTR bInfo$[rsp+rcx], al

; 7386 :             bInfo[3] =  (pLLC->hwNR << 1);

  001e2	48 8b 44 24 60	 mov	 rax, QWORD PTR pLLC$[rsp]
  001e7	0f b7 40 18	 movzx	 eax, WORD PTR [rax+24]
  001eb	d1 e0		 shl	 eax, 1
  001ed	b9 01 00 00 00	 mov	 ecx, 1
  001f2	48 6b c9 03	 imul	 rcx, rcx, 3
  001f6	88 44 0c 30	 mov	 BYTE PTR bInfo$[rsp+rcx], al

; 7387 :             bInfo[4] =  (pLLC->hwV << 4);

  001fa	48 8b 44 24 60	 mov	 rax, QWORD PTR pLLC$[rsp]
  001ff	0f b7 40 20	 movzx	 eax, WORD PTR [rax+32]
  00203	c1 e0 04	 shl	 eax, 4
  00206	b9 01 00 00 00	 mov	 ecx, 1
  0020b	48 6b c9 04	 imul	 rcx, rcx, 4
  0020f	88 44 0c 30	 mov	 BYTE PTR bInfo$[rsp+rcx], al

; 7388 :             bInfo[4] |= (pLLC->hwZ << 3);

  00213	b8 01 00 00 00	 mov	 eax, 1
  00218	48 6b c0 04	 imul	 rax, rax, 4
  0021c	48 8b 4c 24 60	 mov	 rcx, QWORD PTR pLLC$[rsp]
  00221	0f b7 49 22	 movzx	 ecx, WORD PTR [rcx+34]
  00225	c1 e1 03	 shl	 ecx, 3
  00228	0f be 44 04 30	 movsx	 eax, BYTE PTR bInfo$[rsp+rax]
  0022d	0b c1		 or	 eax, ecx
  0022f	b9 01 00 00 00	 mov	 ecx, 1
  00234	48 6b c9 04	 imul	 rcx, rcx, 4
  00238	88 44 0c 30	 mov	 BYTE PTR bInfo$[rsp+rcx], al

; 7389 :             bInfo[4] |= (pLLC->hwY << 2);

  0023c	b8 01 00 00 00	 mov	 eax, 1
  00241	48 6b c0 04	 imul	 rax, rax, 4
  00245	48 8b 4c 24 60	 mov	 rcx, QWORD PTR pLLC$[rsp]
  0024a	0f b7 49 24	 movzx	 ecx, WORD PTR [rcx+36]
  0024e	c1 e1 02	 shl	 ecx, 2
  00251	0f be 44 04 30	 movsx	 eax, BYTE PTR bInfo$[rsp+rax]
  00256	0b c1		 or	 eax, ecx
  00258	b9 01 00 00 00	 mov	 ecx, 1
  0025d	48 6b c9 04	 imul	 rcx, rcx, 4
  00261	88 44 0c 30	 mov	 BYTE PTR bInfo$[rsp+rcx], al

; 7390 :             bInfo[4] |= (pLLC->hwX << 1);

  00265	b8 01 00 00 00	 mov	 eax, 1
  0026a	48 6b c0 04	 imul	 rax, rax, 4
  0026e	48 8b 4c 24 60	 mov	 rcx, QWORD PTR pLLC$[rsp]
  00273	0f b7 49 26	 movzx	 ecx, WORD PTR [rcx+38]
  00277	d1 e1		 shl	 ecx, 1
  00279	0f be 44 04 30	 movsx	 eax, BYTE PTR bInfo$[rsp+rax]
  0027e	0b c1		 or	 eax, ecx
  00280	b9 01 00 00 00	 mov	 ecx, 1
  00285	48 6b c9 04	 imul	 rcx, rcx, 4
  00289	88 44 0c 30	 mov	 BYTE PTR bInfo$[rsp+rcx], al

; 7391 :             bInfo[4] |= (pLLC->hwW);

  0028d	b8 01 00 00 00	 mov	 eax, 1
  00292	48 6b c0 04	 imul	 rax, rax, 4
  00296	48 8b 4c 24 60	 mov	 rcx, QWORD PTR pLLC$[rsp]
  0029b	0f b7 49 28	 movzx	 ecx, WORD PTR [rcx+40]
  0029f	0f be 44 04 30	 movsx	 eax, BYTE PTR bInfo$[rsp+rax]
  002a4	0b c1		 or	 eax, ecx
  002a6	b9 01 00 00 00	 mov	 ecx, 1
  002ab	48 6b c9 04	 imul	 rcx, rcx, 4
  002af	88 44 0c 30	 mov	 BYTE PTR bInfo$[rsp+rcx], al

; 7392 :             memcpy( (BYTE*)pLPDU + 3, bInfo, 5);

  002b3	48 8b 44 24 20	 mov	 rax, QWORD PTR pLPDU$[rsp]
  002b8	48 8d 4c 24 30	 lea	 rcx, QWORD PTR bInfo$[rsp]
  002bd	48 8d 78 03	 lea	 rdi, QWORD PTR [rax+3]
  002c1	48 8b f1	 mov	 rsi, rcx
  002c4	b9 05 00 00 00	 mov	 ecx, 5
  002c9	f3 a4		 rep movsb

; 7393 :             iLPDUsize = 8;

  002cb	c7 44 24 28 08
	00 00 00	 mov	 DWORD PTR iLPDUsize$[rsp], 8

; 7394 :         }

  002d3	eb 08		 jmp	 SHORT $LN6@BuildLLC
$LN5@BuildLLC:

; 7395 :         else
; 7396 :         {
; 7397 :             iLPDUsize = 3;

  002d5	c7 44 24 28 03
	00 00 00	 mov	 DWORD PTR iLPDUsize$[rsp], 3
$LN6@BuildLLC:

; 7398 :         }
; 7399 : 
; 7400 :         break;

  002dd	e9 15 01 00 00	 jmp	 $LN2@BuildLLC
$LN7@BuildLLC:

; 7401 : 
; 7402 :     case Type_Supervisory_Frame:
; 7403 :         // Supervisory Frame.
; 7404 :         // The control field should be 2 bytes.
; 7405 :         // Supervisory frames perform supervisory control functions,
; 7406 :         // for example, to acknowledge I Frames (RR), to request
; 7407 :         // retransmission of I frames (REJ), and to request temporary
; 7408 :         // suspension (RNR) of I frames. Supervisory frames do not
; 7409 :         // contain an information field. Therefore, supervisory frames
; 7410 :         // do not affect the NS in the sending station, and so do not
; 7411 :         // contain an NS field. Here is the format of a supervisory
; 7412 :         // control:-
; 7413 :         //   0-0-0-0-S-S-0-1-NR-NR-NR-NR-NR-NR-NR-P/F
; 7414 : 
; 7415 :         pLPDU->bControl[0] = (pLLC->hwSS << 2);

  002e2	48 8b 44 24 60	 mov	 rax, QWORD PTR pLLC$[rsp]
  002e7	0f b7 40 1c	 movzx	 eax, WORD PTR [rax+28]
  002eb	c1 e0 02	 shl	 eax, 2
  002ee	b9 01 00 00 00	 mov	 ecx, 1
  002f3	48 6b c9 00	 imul	 rcx, rcx, 0
  002f7	48 8b 54 24 20	 mov	 rdx, QWORD PTR pLPDU$[rsp]
  002fc	88 44 0a 02	 mov	 BYTE PTR [rdx+rcx+2], al

; 7416 :         pLPDU->bControl[0] |= 0x01;

  00300	b8 01 00 00 00	 mov	 eax, 1
  00305	48 6b c0 00	 imul	 rax, rax, 0
  00309	48 8b 4c 24 20	 mov	 rcx, QWORD PTR pLPDU$[rsp]
  0030e	0f b6 44 01 02	 movzx	 eax, BYTE PTR [rcx+rax+2]
  00313	83 c8 01	 or	 eax, 1
  00316	b9 01 00 00 00	 mov	 ecx, 1
  0031b	48 6b c9 00	 imul	 rcx, rcx, 0
  0031f	48 8b 54 24 20	 mov	 rdx, QWORD PTR pLPDU$[rsp]
  00324	88 44 0a 02	 mov	 BYTE PTR [rdx+rcx+2], al

; 7417 :         pLPDU->bControl[1] = (pLLC->hwNR << 1);

  00328	48 8b 44 24 60	 mov	 rax, QWORD PTR pLLC$[rsp]
  0032d	0f b7 40 18	 movzx	 eax, WORD PTR [rax+24]
  00331	d1 e0		 shl	 eax, 1
  00333	b9 01 00 00 00	 mov	 ecx, 1
  00338	48 6b c9 01	 imul	 rcx, rcx, 1
  0033c	48 8b 54 24 20	 mov	 rdx, QWORD PTR pLPDU$[rsp]
  00341	88 44 0a 02	 mov	 BYTE PTR [rdx+rcx+2], al

; 7418 :         pLPDU->bControl[1] |= pLLC->hwPF;

  00345	b8 01 00 00 00	 mov	 eax, 1
  0034a	48 6b c0 01	 imul	 rax, rax, 1
  0034e	48 8b 4c 24 60	 mov	 rcx, QWORD PTR pLLC$[rsp]
  00353	0f b7 49 1a	 movzx	 ecx, WORD PTR [rcx+26]
  00357	48 8b 54 24 20	 mov	 rdx, QWORD PTR pLPDU$[rsp]
  0035c	0f b6 44 02 02	 movzx	 eax, BYTE PTR [rdx+rax+2]
  00361	0b c1		 or	 eax, ecx
  00363	b9 01 00 00 00	 mov	 ecx, 1
  00368	48 6b c9 01	 imul	 rcx, rcx, 1
  0036c	48 8b 54 24 20	 mov	 rdx, QWORD PTR pLPDU$[rsp]
  00371	88 44 0a 02	 mov	 BYTE PTR [rdx+rcx+2], al

; 7419 : 
; 7420 :         iLPDUsize = 4;

  00375	c7 44 24 28 04
	00 00 00	 mov	 DWORD PTR iLPDUsize$[rsp], 4

; 7421 : 
; 7422 :         break;

  0037d	eb 78		 jmp	 SHORT $LN2@BuildLLC
$LN8@BuildLLC:

; 7423 : 
; 7424 :     case Type_Information_Frame:
; 7425 :         // Information Frame (I Frame).
; 7426 :         // The control field should be 2 bytes.
; 7427 :         // The format of the I frame contains an NS and NR count. The
; 7428 :         // NS count is the sequence number (modulo 128) of the LPDU
; 7429 :         // currently in transmission. The NR count is the sequence
; 7430 :         // number of the next LPDU I frame that the sender expects to
; 7431 :         // receive. To help you later, remember that NR means "next
; 7432 :         // receive." Here is the format of an information control:
; 7433 :         //   NS-NS-NS-NS-NS-NS-NS-0-NR-NR-NR-NR-NR-NR-P/F
; 7434 : 
; 7435 :         pLPDU->bControl[0] = (pLLC->hwNS << 1);

  0037f	48 8b 44 24 60	 mov	 rax, QWORD PTR pLLC$[rsp]
  00384	0f b7 40 16	 movzx	 eax, WORD PTR [rax+22]
  00388	d1 e0		 shl	 eax, 1
  0038a	b9 01 00 00 00	 mov	 ecx, 1
  0038f	48 6b c9 00	 imul	 rcx, rcx, 0
  00393	48 8b 54 24 20	 mov	 rdx, QWORD PTR pLPDU$[rsp]
  00398	88 44 0a 02	 mov	 BYTE PTR [rdx+rcx+2], al

; 7436 :         pLPDU->bControl[1] = (pLLC->hwNR << 1);

  0039c	48 8b 44 24 60	 mov	 rax, QWORD PTR pLLC$[rsp]
  003a1	0f b7 40 18	 movzx	 eax, WORD PTR [rax+24]
  003a5	d1 e0		 shl	 eax, 1
  003a7	b9 01 00 00 00	 mov	 ecx, 1
  003ac	48 6b c9 01	 imul	 rcx, rcx, 1
  003b0	48 8b 54 24 20	 mov	 rdx, QWORD PTR pLPDU$[rsp]
  003b5	88 44 0a 02	 mov	 BYTE PTR [rdx+rcx+2], al

; 7437 :         pLPDU->bControl[1] |= pLLC->hwPF;

  003b9	b8 01 00 00 00	 mov	 eax, 1
  003be	48 6b c0 01	 imul	 rax, rax, 1
  003c2	48 8b 4c 24 60	 mov	 rcx, QWORD PTR pLLC$[rsp]
  003c7	0f b7 49 1a	 movzx	 ecx, WORD PTR [rcx+26]
  003cb	48 8b 54 24 20	 mov	 rdx, QWORD PTR pLPDU$[rsp]
  003d0	0f b6 44 02 02	 movzx	 eax, BYTE PTR [rdx+rax+2]
  003d5	0b c1		 or	 eax, ecx
  003d7	b9 01 00 00 00	 mov	 ecx, 1
  003dc	48 6b c9 01	 imul	 rcx, rcx, 1
  003e0	48 8b 54 24 20	 mov	 rdx, QWORD PTR pLPDU$[rsp]
  003e5	88 44 0a 02	 mov	 BYTE PTR [rdx+rcx+2], al

; 7438 : 
; 7439 :         iLPDUsize = 4;

  003e9	c7 44 24 28 04
	00 00 00	 mov	 DWORD PTR iLPDUsize$[rsp], 4

; 7440 : 
; 7441 :         break;

  003f1	eb 04		 jmp	 SHORT $LN2@BuildLLC
$LN9@BuildLLC:

; 7442 : 
; 7443 :     default:
; 7444 :         return 0;    // Err...

  003f3	33 c0		 xor	 eax, eax
  003f5	eb 04		 jmp	 SHORT $LN1@BuildLLC
$LN2@BuildLLC:

; 7445 : 
; 7446 :     }
; 7447 : 
; 7448 :     return iLPDUsize;

  003f7	8b 44 24 28	 mov	 eax, DWORD PTR iLPDUsize$[rsp]
$LN1@BuildLLC:

; 7449 : }

  003fb	48 8b 4c 24 38	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  00400	48 33 cc	 xor	 rcx, rsp
  00403	e8 00 00 00 00	 call	 __security_check_cookie
  00408	48 83 c4 48	 add	 rsp, 72			; 00000048H
  0040c	5f		 pop	 rdi
  0040d	5e		 pop	 rsi
  0040e	c3		 ret	 0
BuildLLC ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\ctc_lcs.c
_TEXT	SEGMENT
iLPDUsize$ = 32
tv146 = 36
pLPDU$ = 40
pLLC$ = 80
pStart$ = 88
iSize$ = 96
ExtractLLC PROC

; 7194 : {

  00000	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	56		 push	 rsi
  00010	57		 push	 rdi
  00011	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 7195 :     PLPDU     pLPDU;
; 7196 :     int       iLPDUsize;
; 7197 : 
; 7198 : 
; 7199 :     memset( pLLC, 0, sizeof(LLC) );

  00015	48 8b 7c 24 50	 mov	 rdi, QWORD PTR pLLC$[rsp]
  0001a	33 c0		 xor	 eax, eax
  0001c	b9 2e 00 00 00	 mov	 ecx, 46			; 0000002eH
  00021	f3 aa		 rep stosb

; 7200 : 
; 7201 :     pLPDU = (PLPDU)pStart;

  00023	48 8b 44 24 58	 mov	 rax, QWORD PTR pStart$[rsp]
  00028	48 89 44 24 28	 mov	 QWORD PTR pLPDU$[rsp], rax

; 7202 :     iLPDUsize = iSize;

  0002d	8b 44 24 60	 mov	 eax, DWORD PTR iSize$[rsp]
  00031	89 44 24 20	 mov	 DWORD PTR iLPDUsize$[rsp], eax

; 7203 : 
; 7204 :     if (iLPDUsize < 3)

  00035	83 7c 24 20 03	 cmp	 DWORD PTR iLPDUsize$[rsp], 3
  0003a	7d 07		 jge	 SHORT $LN4@ExtractLLC

; 7205 :     {
; 7206 :         return 0;    // Less than 3 bytes!

  0003c	33 c0		 xor	 eax, eax
  0003e	e9 35 04 00 00	 jmp	 $LN1@ExtractLLC
$LN4@ExtractLLC:

; 7207 :     }
; 7208 : 
; 7209 :     pLLC->hwDSAP = (pLPDU->bDSAP[0] & 0xFE);

  00043	b8 01 00 00 00	 mov	 eax, 1
  00048	48 6b c0 00	 imul	 rax, rax, 0
  0004c	48 8b 4c 24 28	 mov	 rcx, QWORD PTR pLPDU$[rsp]
  00051	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00055	25 fe 00 00 00	 and	 eax, 254		; 000000feH
  0005a	48 8b 4c 24 50	 mov	 rcx, QWORD PTR pLLC$[rsp]
  0005f	66 89 41 0e	 mov	 WORD PTR [rcx+14], ax

; 7210 :     pLLC->hwIG = (pLPDU->bDSAP[0] & 0x01);

  00063	b8 01 00 00 00	 mov	 eax, 1
  00068	48 6b c0 00	 imul	 rax, rax, 0
  0006c	48 8b 4c 24 28	 mov	 rcx, QWORD PTR pLPDU$[rsp]
  00071	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00075	83 e0 01	 and	 eax, 1
  00078	48 8b 4c 24 50	 mov	 rcx, QWORD PTR pLLC$[rsp]
  0007d	66 89 41 10	 mov	 WORD PTR [rcx+16], ax

; 7211 :     pLLC->hwSSAP = (pLPDU->bSSAP[0] & 0xFE);

  00081	b8 01 00 00 00	 mov	 eax, 1
  00086	48 6b c0 00	 imul	 rax, rax, 0
  0008a	48 8b 4c 24 28	 mov	 rcx, QWORD PTR pLPDU$[rsp]
  0008f	0f b6 44 01 01	 movzx	 eax, BYTE PTR [rcx+rax+1]
  00094	25 fe 00 00 00	 and	 eax, 254		; 000000feH
  00099	48 8b 4c 24 50	 mov	 rcx, QWORD PTR pLLC$[rsp]
  0009e	66 89 41 12	 mov	 WORD PTR [rcx+18], ax

; 7212 :     pLLC->hwCR = (pLPDU->bSSAP[0] & 0x01);

  000a2	b8 01 00 00 00	 mov	 eax, 1
  000a7	48 6b c0 00	 imul	 rax, rax, 0
  000ab	48 8b 4c 24 28	 mov	 rcx, QWORD PTR pLPDU$[rsp]
  000b0	0f b6 44 01 01	 movzx	 eax, BYTE PTR [rcx+rax+1]
  000b5	83 e0 01	 and	 eax, 1
  000b8	48 8b 4c 24 50	 mov	 rcx, QWORD PTR pLLC$[rsp]
  000bd	66 89 41 14	 mov	 WORD PTR [rcx+20], ax

; 7213 : 
; 7214 :     if ((pLPDU->bControl[0] & 0x01) == 0x00)               // Control low-order bit = 0?

  000c1	b8 01 00 00 00	 mov	 eax, 1
  000c6	48 6b c0 00	 imul	 rax, rax, 0
  000ca	48 8b 4c 24 28	 mov	 rcx, QWORD PTR pLPDU$[rsp]
  000cf	0f b6 44 01 02	 movzx	 eax, BYTE PTR [rcx+rax+2]
  000d4	83 e0 01	 and	 eax, 1
  000d7	85 c0		 test	 eax, eax
  000d9	75 10		 jne	 SHORT $LN5@ExtractLLC

; 7215 :     {
; 7216 :         pLLC->hwType = Type_Information_Frame;             // LLC Information frame

  000db	b8 01 00 00 00	 mov	 eax, 1
  000e0	48 8b 4c 24 50	 mov	 rcx, QWORD PTR pLLC$[rsp]
  000e5	66 89 41 2c	 mov	 WORD PTR [rcx+44], ax

; 7217 :     }

  000e9	eb 39		 jmp	 SHORT $LN6@ExtractLLC
$LN5@ExtractLLC:

; 7218 :     else
; 7219 :     {
; 7220 :         if ((pLPDU->bControl[0] & 0x03) == 0x01)           // Control low-order 2 bits = 01?

  000eb	b8 01 00 00 00	 mov	 eax, 1
  000f0	48 6b c0 00	 imul	 rax, rax, 0
  000f4	48 8b 4c 24 28	 mov	 rcx, QWORD PTR pLPDU$[rsp]
  000f9	0f b6 44 01 02	 movzx	 eax, BYTE PTR [rcx+rax+2]
  000fe	83 e0 03	 and	 eax, 3
  00101	83 f8 01	 cmp	 eax, 1
  00104	75 10		 jne	 SHORT $LN7@ExtractLLC

; 7221 :         {
; 7222 :             pLLC->hwType = Type_Supervisory_Frame;         // LLC Supervisory frame

  00106	b8 02 00 00 00	 mov	 eax, 2
  0010b	48 8b 4c 24 50	 mov	 rcx, QWORD PTR pLLC$[rsp]
  00110	66 89 41 2c	 mov	 WORD PTR [rcx+44], ax

; 7223 :         }

  00114	eb 0e		 jmp	 SHORT $LN8@ExtractLLC
$LN7@ExtractLLC:

; 7224 :         else  //  ((pLPDU->bControl[0] & 0x03) == 0x03)    // Control low-order 2 bits are = 11.
; 7225 :         {
; 7226 :             pLLC->hwType = Type_Unnumbered_Frame;          // LLC Unnumbered frame

  00116	b8 03 00 00 00	 mov	 eax, 3
  0011b	48 8b 4c 24 50	 mov	 rcx, QWORD PTR pLLC$[rsp]
  00120	66 89 41 2c	 mov	 WORD PTR [rcx+44], ax
$LN8@ExtractLLC:
$LN6@ExtractLLC:

; 7227 :         }
; 7228 :     }
; 7229 : 
; 7230 :     switch (pLLC->hwType)

  00124	48 8b 44 24 50	 mov	 rax, QWORD PTR pLLC$[rsp]
  00129	0f b7 40 2c	 movzx	 eax, WORD PTR [rax+44]
  0012d	89 44 24 24	 mov	 DWORD PTR tv146[rsp], eax
  00131	83 7c 24 24 01	 cmp	 DWORD PTR tv146[rsp], 1
  00136	74 1b		 je	 SHORT $LN9@ExtractLLC
  00138	83 7c 24 24 02	 cmp	 DWORD PTR tv146[rsp], 2
  0013d	0f 84 a2 00 00
	00		 je	 $LN11@ExtractLLC
  00143	83 7c 24 24 03	 cmp	 DWORD PTR tv146[rsp], 3
  00148	0f 84 2d 01 00
	00		 je	 $LN13@ExtractLLC
  0014e	e9 1d 03 00 00	 jmp	 $LN17@ExtractLLC
$LN9@ExtractLLC:

; 7231 :     {
; 7232 :     case Type_Information_Frame:
; 7233 :         // Information Frame (I Frame).
; 7234 :         // The control field should be 2 bytes.
; 7235 :         // The format of the I frame contains an NS and NR count. The
; 7236 :         // NS count is the sequence number (modulo 128) of the LPDU
; 7237 :         // currently in transmission. The NR count is the sequence
; 7238 :         // number of the next LPDU I frame that the sender expects to
; 7239 :         // receive. To help you later, remember that NR means "next
; 7240 :         // receive." Here is the format of an information control:
; 7241 :         //   NS-NS-NS-NS-NS-NS-NS-0-NR-NR-NR-NR-NR-NR-P/F
; 7242 : 
; 7243 :         if (iLPDUsize < 4)

  00153	83 7c 24 20 04	 cmp	 DWORD PTR iLPDUsize$[rsp], 4
  00158	7d 07		 jge	 SHORT $LN10@ExtractLLC

; 7244 :         {
; 7245 :             return 0;    // Less than 4 bytes!

  0015a	33 c0		 xor	 eax, eax
  0015c	e9 17 03 00 00	 jmp	 $LN1@ExtractLLC
$LN10@ExtractLLC:

; 7246 :         }
; 7247 : 
; 7248 :         memcpy( &pLLC->bLpdu, (BYTE*)pLPDU, 4);

  00161	48 8b 44 24 50	 mov	 rax, QWORD PTR pLLC$[rsp]
  00166	48 8b 4c 24 28	 mov	 rcx, QWORD PTR pLPDU$[rsp]
  0016b	8b 09		 mov	 ecx, DWORD PTR [rcx]
  0016d	89 08		 mov	 DWORD PTR [rax], ecx

; 7249 :         pLLC->hwLpduSize = 4;

  0016f	b8 04 00 00 00	 mov	 eax, 4
  00174	48 8b 4c 24 50	 mov	 rcx, QWORD PTR pLLC$[rsp]
  00179	66 89 41 0a	 mov	 WORD PTR [rcx+10], ax

; 7250 : 
; 7251 :         pLLC->hwNS = (pLPDU->bControl[0] >> 1);

  0017d	b8 01 00 00 00	 mov	 eax, 1
  00182	48 6b c0 00	 imul	 rax, rax, 0
  00186	48 8b 4c 24 28	 mov	 rcx, QWORD PTR pLPDU$[rsp]
  0018b	0f b6 44 01 02	 movzx	 eax, BYTE PTR [rcx+rax+2]
  00190	d1 f8		 sar	 eax, 1
  00192	48 8b 4c 24 50	 mov	 rcx, QWORD PTR pLLC$[rsp]
  00197	66 89 41 16	 mov	 WORD PTR [rcx+22], ax

; 7252 :         pLLC->hwNR = (pLPDU->bControl[1] >> 1);

  0019b	b8 01 00 00 00	 mov	 eax, 1
  001a0	48 6b c0 01	 imul	 rax, rax, 1
  001a4	48 8b 4c 24 28	 mov	 rcx, QWORD PTR pLPDU$[rsp]
  001a9	0f b6 44 01 02	 movzx	 eax, BYTE PTR [rcx+rax+2]
  001ae	d1 f8		 sar	 eax, 1
  001b0	48 8b 4c 24 50	 mov	 rcx, QWORD PTR pLLC$[rsp]
  001b5	66 89 41 18	 mov	 WORD PTR [rcx+24], ax

; 7253 :         pLLC->hwPF = (pLPDU->bControl[1] & 0x01);

  001b9	b8 01 00 00 00	 mov	 eax, 1
  001be	48 6b c0 01	 imul	 rax, rax, 1
  001c2	48 8b 4c 24 28	 mov	 rcx, QWORD PTR pLPDU$[rsp]
  001c7	0f b6 44 01 02	 movzx	 eax, BYTE PTR [rcx+rax+2]
  001cc	83 e0 01	 and	 eax, 1
  001cf	48 8b 4c 24 50	 mov	 rcx, QWORD PTR pLLC$[rsp]
  001d4	66 89 41 1a	 mov	 WORD PTR [rcx+26], ax

; 7254 : 
; 7255 :         iLPDUsize = 4;

  001d8	c7 44 24 20 04
	00 00 00	 mov	 DWORD PTR iLPDUsize$[rsp], 4

; 7256 : 
; 7257 :         break;

  001e0	e9 8f 02 00 00	 jmp	 $LN2@ExtractLLC
$LN11@ExtractLLC:

; 7258 : 
; 7259 :     case Type_Supervisory_Frame:
; 7260 :         // Supervisory Frame.
; 7261 :         // The control field should be 2 bytes.
; 7262 :         // Supervisory frames perform supervisory control functions,
; 7263 :         // for example, to acknowledge I Frames (RR), to request
; 7264 :         // retransmission of I frames (REJ), and to request temporary
; 7265 :         // suspension (RNR) of I frames. Supervisory frames do not
; 7266 :         // contain an information field. Therefore, supervisory frames
; 7267 :         // do not affect the NS in the sending station, and so do not
; 7268 :         // contain an NS field. Here is the format of a supervisory
; 7269 :         // control:-
; 7270 :         //   0-0-0-0-S-S-0-1-NR-NR-NR-NR-NR-NR-NR-P/F
; 7271 : 
; 7272 :         if (iLPDUsize < 4)

  001e5	83 7c 24 20 04	 cmp	 DWORD PTR iLPDUsize$[rsp], 4
  001ea	7d 07		 jge	 SHORT $LN12@ExtractLLC

; 7273 :         {
; 7274 :             return 0;    // Less than 4 bytes!

  001ec	33 c0		 xor	 eax, eax
  001ee	e9 85 02 00 00	 jmp	 $LN1@ExtractLLC
$LN12@ExtractLLC:

; 7275 :         }
; 7276 : 
; 7277 :         memcpy( &pLLC->bLpdu, (BYTE*)pLPDU, 4);

  001f3	48 8b 44 24 50	 mov	 rax, QWORD PTR pLLC$[rsp]
  001f8	48 8b 4c 24 28	 mov	 rcx, QWORD PTR pLPDU$[rsp]
  001fd	8b 09		 mov	 ecx, DWORD PTR [rcx]
  001ff	89 08		 mov	 DWORD PTR [rax], ecx

; 7278 :         pLLC->hwLpduSize = 4;

  00201	b8 04 00 00 00	 mov	 eax, 4
  00206	48 8b 4c 24 50	 mov	 rcx, QWORD PTR pLLC$[rsp]
  0020b	66 89 41 0a	 mov	 WORD PTR [rcx+10], ax

; 7279 : 
; 7280 :         pLLC->hwSS = ((pLPDU->bControl[0] & 0x0C) >> 2);

  0020f	b8 01 00 00 00	 mov	 eax, 1
  00214	48 6b c0 00	 imul	 rax, rax, 0
  00218	48 8b 4c 24 28	 mov	 rcx, QWORD PTR pLPDU$[rsp]
  0021d	0f b6 44 01 02	 movzx	 eax, BYTE PTR [rcx+rax+2]
  00222	83 e0 0c	 and	 eax, 12
  00225	c1 f8 02	 sar	 eax, 2
  00228	48 8b 4c 24 50	 mov	 rcx, QWORD PTR pLLC$[rsp]
  0022d	66 89 41 1c	 mov	 WORD PTR [rcx+28], ax

; 7281 :         pLLC->hwNR = (pLPDU->bControl[1] >> 1);

  00231	b8 01 00 00 00	 mov	 eax, 1
  00236	48 6b c0 01	 imul	 rax, rax, 1
  0023a	48 8b 4c 24 28	 mov	 rcx, QWORD PTR pLPDU$[rsp]
  0023f	0f b6 44 01 02	 movzx	 eax, BYTE PTR [rcx+rax+2]
  00244	d1 f8		 sar	 eax, 1
  00246	48 8b 4c 24 50	 mov	 rcx, QWORD PTR pLLC$[rsp]
  0024b	66 89 41 18	 mov	 WORD PTR [rcx+24], ax

; 7282 :         pLLC->hwPF = (pLPDU->bControl[1] & 0x01);

  0024f	b8 01 00 00 00	 mov	 eax, 1
  00254	48 6b c0 01	 imul	 rax, rax, 1
  00258	48 8b 4c 24 28	 mov	 rcx, QWORD PTR pLPDU$[rsp]
  0025d	0f b6 44 01 02	 movzx	 eax, BYTE PTR [rcx+rax+2]
  00262	83 e0 01	 and	 eax, 1
  00265	48 8b 4c 24 50	 mov	 rcx, QWORD PTR pLLC$[rsp]
  0026a	66 89 41 1a	 mov	 WORD PTR [rcx+26], ax

; 7283 : 
; 7284 :         iLPDUsize = 4;

  0026e	c7 44 24 20 04
	00 00 00	 mov	 DWORD PTR iLPDUsize$[rsp], 4

; 7285 : 
; 7286 :         break;

  00276	e9 f9 01 00 00	 jmp	 $LN2@ExtractLLC
$LN13@ExtractLLC:

; 7287 : 
; 7288 :     case Type_Unnumbered_Frame:
; 7289 :         // Unnumbered Frame.
; 7290 :         // The control field should be 1 byte.
; 7291 :         // Unnumbered frames provide link control functions, for
; 7292 :         // example, mode setting commands and responses. In some
; 7293 :         // cases, unnumbered information frames can also be sent.
; 7294 :         // They do not contain fields for NR or NS counts. Here is
; 7295 :         // the format of an unnumbered control:
; 7296 :         //   M-M-M-P/F-M-M-1-1
; 7297 : 
; 7298 :         memcpy( &pLLC->bLpdu, (BYTE*)pLPDU, 3);

  0027b	48 8b 7c 24 50	 mov	 rdi, QWORD PTR pLLC$[rsp]
  00280	48 8b 74 24 28	 mov	 rsi, QWORD PTR pLPDU$[rsp]
  00285	b9 03 00 00 00	 mov	 ecx, 3
  0028a	f3 a4		 rep movsb

; 7299 :         pLLC->hwLpduSize = 3;

  0028c	b8 03 00 00 00	 mov	 eax, 3
  00291	48 8b 4c 24 50	 mov	 rcx, QWORD PTR pLLC$[rsp]
  00296	66 89 41 0a	 mov	 WORD PTR [rcx+10], ax

; 7300 : 
; 7301 :         pLLC->hwPF = ((pLPDU->bControl[0] & 0x10) >> 4);

  0029a	b8 01 00 00 00	 mov	 eax, 1
  0029f	48 6b c0 00	 imul	 rax, rax, 0
  002a3	48 8b 4c 24 28	 mov	 rcx, QWORD PTR pLPDU$[rsp]
  002a8	0f b6 44 01 02	 movzx	 eax, BYTE PTR [rcx+rax+2]
  002ad	83 e0 10	 and	 eax, 16
  002b0	c1 f8 04	 sar	 eax, 4
  002b3	48 8b 4c 24 50	 mov	 rcx, QWORD PTR pLLC$[rsp]
  002b8	66 89 41 1a	 mov	 WORD PTR [rcx+26], ax

; 7302 :         pLLC->hwM =  ((pLPDU->bControl[0] & 0xE0) >> 3);

  002bc	b8 01 00 00 00	 mov	 eax, 1
  002c1	48 6b c0 00	 imul	 rax, rax, 0
  002c5	48 8b 4c 24 28	 mov	 rcx, QWORD PTR pLPDU$[rsp]
  002ca	0f b6 44 01 02	 movzx	 eax, BYTE PTR [rcx+rax+2]
  002cf	25 e0 00 00 00	 and	 eax, 224		; 000000e0H
  002d4	c1 f8 03	 sar	 eax, 3
  002d7	48 8b 4c 24 50	 mov	 rcx, QWORD PTR pLLC$[rsp]
  002dc	66 89 41 1e	 mov	 WORD PTR [rcx+30], ax

; 7303 :         pLLC->hwM |= ((pLPDU->bControl[0] & 0x0C) >> 2);

  002e0	b8 01 00 00 00	 mov	 eax, 1
  002e5	48 6b c0 00	 imul	 rax, rax, 0
  002e9	48 8b 4c 24 28	 mov	 rcx, QWORD PTR pLPDU$[rsp]
  002ee	0f b6 44 01 02	 movzx	 eax, BYTE PTR [rcx+rax+2]
  002f3	83 e0 0c	 and	 eax, 12
  002f6	c1 f8 02	 sar	 eax, 2
  002f9	48 8b 4c 24 50	 mov	 rcx, QWORD PTR pLLC$[rsp]
  002fe	0f b7 49 1e	 movzx	 ecx, WORD PTR [rcx+30]
  00302	0b c8		 or	 ecx, eax
  00304	8b c1		 mov	 eax, ecx
  00306	48 8b 4c 24 50	 mov	 rcx, QWORD PTR pLLC$[rsp]
  0030b	66 89 41 1e	 mov	 WORD PTR [rcx+30], ax

; 7304 : 
; 7305 :         if (pLLC->hwM == M_FRMR_Response)

  0030f	48 8b 44 24 50	 mov	 rax, QWORD PTR pLLC$[rsp]
  00314	0f b7 40 1e	 movzx	 eax, WORD PTR [rax+30]
  00318	83 f8 11	 cmp	 eax, 17
  0031b	0f 85 45 01 00
	00		 jne	 $LN14@ExtractLLC

; 7306 :         {
; 7307 :             if (iLPDUsize < 8)

  00321	83 7c 24 20 08	 cmp	 DWORD PTR iLPDUsize$[rsp], 8
  00326	7d 07		 jge	 SHORT $LN16@ExtractLLC

; 7308 :             {
; 7309 :                 return 0;    // Less than 8 bytes!

  00328	33 c0		 xor	 eax, eax
  0032a	e9 49 01 00 00	 jmp	 $LN1@ExtractLLC
$LN16@ExtractLLC:

; 7310 :             }
; 7311 :             memcpy( pLLC->bInfo, (BYTE*)pLPDU + 3, 5);

  0032f	48 8b 44 24 50	 mov	 rax, QWORD PTR pLLC$[rsp]
  00334	48 8b 4c 24 28	 mov	 rcx, QWORD PTR pLPDU$[rsp]
  00339	48 8d 78 04	 lea	 rdi, QWORD PTR [rax+4]
  0033d	48 8d 71 03	 lea	 rsi, QWORD PTR [rcx+3]
  00341	b9 05 00 00 00	 mov	 ecx, 5
  00346	f3 a4		 rep movsb

; 7312 :             pLLC->hwInfoSize = 5;

  00348	b8 05 00 00 00	 mov	 eax, 5
  0034d	48 8b 4c 24 50	 mov	 rcx, QWORD PTR pLLC$[rsp]
  00352	66 89 41 0c	 mov	 WORD PTR [rcx+12], ax

; 7313 : 
; 7314 :             pLLC->hwNS = (pLLC->bInfo[2] >> 1);

  00356	b8 01 00 00 00	 mov	 eax, 1
  0035b	48 6b c0 02	 imul	 rax, rax, 2
  0035f	48 8b 4c 24 50	 mov	 rcx, QWORD PTR pLLC$[rsp]
  00364	0f b6 44 01 04	 movzx	 eax, BYTE PTR [rcx+rax+4]
  00369	d1 f8		 sar	 eax, 1
  0036b	48 8b 4c 24 50	 mov	 rcx, QWORD PTR pLLC$[rsp]
  00370	66 89 41 16	 mov	 WORD PTR [rcx+22], ax

; 7315 :             pLLC->hwNR = (pLLC->bInfo[3] >> 1);

  00374	b8 01 00 00 00	 mov	 eax, 1
  00379	48 6b c0 03	 imul	 rax, rax, 3
  0037d	48 8b 4c 24 50	 mov	 rcx, QWORD PTR pLLC$[rsp]
  00382	0f b6 44 01 04	 movzx	 eax, BYTE PTR [rcx+rax+4]
  00387	d1 f8		 sar	 eax, 1
  00389	48 8b 4c 24 50	 mov	 rcx, QWORD PTR pLLC$[rsp]
  0038e	66 89 41 18	 mov	 WORD PTR [rcx+24], ax

; 7316 :             pLLC->hwV  = ((pLLC->bInfo[4] & 0x80) >> 4);

  00392	b8 01 00 00 00	 mov	 eax, 1
  00397	48 6b c0 04	 imul	 rax, rax, 4
  0039b	48 8b 4c 24 50	 mov	 rcx, QWORD PTR pLLC$[rsp]
  003a0	0f b6 44 01 04	 movzx	 eax, BYTE PTR [rcx+rax+4]
  003a5	25 80 00 00 00	 and	 eax, 128		; 00000080H
  003aa	c1 f8 04	 sar	 eax, 4
  003ad	48 8b 4c 24 50	 mov	 rcx, QWORD PTR pLLC$[rsp]
  003b2	66 89 41 20	 mov	 WORD PTR [rcx+32], ax

; 7317 :             pLLC->hwZ  = ((pLLC->bInfo[4] & 0x08) >> 3);

  003b6	b8 01 00 00 00	 mov	 eax, 1
  003bb	48 6b c0 04	 imul	 rax, rax, 4
  003bf	48 8b 4c 24 50	 mov	 rcx, QWORD PTR pLLC$[rsp]
  003c4	0f b6 44 01 04	 movzx	 eax, BYTE PTR [rcx+rax+4]
  003c9	83 e0 08	 and	 eax, 8
  003cc	c1 f8 03	 sar	 eax, 3
  003cf	48 8b 4c 24 50	 mov	 rcx, QWORD PTR pLLC$[rsp]
  003d4	66 89 41 22	 mov	 WORD PTR [rcx+34], ax

; 7318 :             pLLC->hwY  = ((pLLC->bInfo[4] & 0x04) >> 2);

  003d8	b8 01 00 00 00	 mov	 eax, 1
  003dd	48 6b c0 04	 imul	 rax, rax, 4
  003e1	48 8b 4c 24 50	 mov	 rcx, QWORD PTR pLLC$[rsp]
  003e6	0f b6 44 01 04	 movzx	 eax, BYTE PTR [rcx+rax+4]
  003eb	83 e0 04	 and	 eax, 4
  003ee	c1 f8 02	 sar	 eax, 2
  003f1	48 8b 4c 24 50	 mov	 rcx, QWORD PTR pLLC$[rsp]
  003f6	66 89 41 24	 mov	 WORD PTR [rcx+36], ax

; 7319 :             pLLC->hwX  = ((pLLC->bInfo[4] & 0x02) >> 1);

  003fa	b8 01 00 00 00	 mov	 eax, 1
  003ff	48 6b c0 04	 imul	 rax, rax, 4
  00403	48 8b 4c 24 50	 mov	 rcx, QWORD PTR pLLC$[rsp]
  00408	0f b6 44 01 04	 movzx	 eax, BYTE PTR [rcx+rax+4]
  0040d	83 e0 02	 and	 eax, 2
  00410	d1 f8		 sar	 eax, 1
  00412	48 8b 4c 24 50	 mov	 rcx, QWORD PTR pLLC$[rsp]
  00417	66 89 41 26	 mov	 WORD PTR [rcx+38], ax

; 7320 :             pLLC->hwW  = (pLLC->bInfo[4] & 0x01);

  0041b	b8 01 00 00 00	 mov	 eax, 1
  00420	48 6b c0 04	 imul	 rax, rax, 4
  00424	48 8b 4c 24 50	 mov	 rcx, QWORD PTR pLLC$[rsp]
  00429	0f b6 44 01 04	 movzx	 eax, BYTE PTR [rcx+rax+4]
  0042e	83 e0 01	 and	 eax, 1
  00431	48 8b 4c 24 50	 mov	 rcx, QWORD PTR pLLC$[rsp]
  00436	66 89 41 28	 mov	 WORD PTR [rcx+40], ax

; 7321 :             FETCH_HW( pLLC->hwCF, pLLC->bInfo );

  0043a	48 8b 44 24 50	 mov	 rax, QWORD PTR pLLC$[rsp]
  0043f	48 83 c0 04	 add	 rax, 4
  00443	48 8b c8	 mov	 rcx, rax
  00446	e8 00 00 00 00	 call	 fetch_hw_noswap
  0044b	0f b7 c8	 movzx	 ecx, ax
  0044e	e8 00 00 00 00	 call	 _byteswap_ushort
  00453	48 8b 4c 24 50	 mov	 rcx, QWORD PTR pLLC$[rsp]
  00458	66 89 41 2a	 mov	 WORD PTR [rcx+42], ax

; 7322 : 
; 7323 :             iLPDUsize = 8;

  0045c	c7 44 24 20 08
	00 00 00	 mov	 DWORD PTR iLPDUsize$[rsp], 8

; 7324 :         }

  00464	eb 08		 jmp	 SHORT $LN15@ExtractLLC
$LN14@ExtractLLC:

; 7325 :         else
; 7326 :         {
; 7327 :             iLPDUsize = 3;

  00466	c7 44 24 20 03
	00 00 00	 mov	 DWORD PTR iLPDUsize$[rsp], 3
$LN15@ExtractLLC:

; 7328 :         }
; 7329 : 
; 7330 :         break;

  0046e	eb 04		 jmp	 SHORT $LN2@ExtractLLC
$LN17@ExtractLLC:

; 7331 : 
; 7332 :     default:
; 7333 :         // Unreachable!
; 7334 :         return 0;    // Err...

  00470	33 c0		 xor	 eax, eax
  00472	eb 04		 jmp	 SHORT $LN1@ExtractLLC
$LN2@ExtractLLC:

; 7335 : 
; 7336 :     }
; 7337 : 
; 7338 :     return iLPDUsize;

  00474	8b 44 24 20	 mov	 eax, DWORD PTR iLPDUsize$[rsp]
$LN1@ExtractLLC:

; 7339 : }

  00478	48 83 c4 38	 add	 rsp, 56			; 00000038H
  0047c	5f		 pop	 rdi
  0047d	5e		 pop	 rsi
  0047e	c3		 ret	 0
ExtractLLC ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\ctc_lcs.c
_TEXT	SEGMENT
hwOffset$ = 112
fAttnRequired$ = 116
hwLenBaf2$ = 120
pLCSCONN$ = 128
pLCSIBH$ = 136
hwLenBaf1$ = 144
iEthLenOut$ = 148
pLCSBAF1$ = 152
pDEVBLK$ = 160
iDatasize$ = 168
pEthFrame$ = 176
pLCSBAF2$ = 184
pLCSHDR$ = 192
pLCSBLK$ = 200
pEthFrameOut$ = 208
iLPDULenOut$ = 216
tv744 = 220
illcsize$ = 224
tv84 = 228
tv468 = 232
iLLCandDatasize$ = 236
pLCSATTN$ = 240
tv599 = 248
tv1612 = 252
tv1617 = 256
tv1842 = 260
tv384 = 264
tv389 = 268
tv594 = 272
pLLCandData$ = 280
tv379 = 288
tv589 = 296
tv1607 = 304
llc$ = 312
llcout$ = 360
llcmsg$ = 416
frameout$ = 672
__$ArrayPad$ = 736
pLCSPORT$ = 784
pLCSDEV$ = 792
pData$ = 800
iSize$ = 808
LCS_ProcessAccepted_SNA PROC

; 6002 : {

  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	56		 push	 rsi
  00015	57		 push	 rdi
  00016	48 81 ec f8 02
	00 00		 sub	 rsp, 760		; 000002f8H
  0001d	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00024	48 33 c4	 xor	 rax, rsp
  00027	48 89 84 24 e0
	02 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 6003 : #define Inbound_4D10_Size  33
; 6004 : static const BYTE Inbound_4D10[Inbound_4D10_Size] =
; 6005 :                  {
; 6006 :                    0xff, 0xff, 0x04, 0x00,                           /* LCSHDR  */
; 6007 :                    0x00, 0x14, 0x4D, 0x10, 0x00, 0x09, 0x60, 0x01,   /* LCSBAF1 */
; 6008 :                    0x00, 0x00, 0x01, 0x01, 0x01, 0x00, 0x00, 0x40,
; 6009 :                    0x00, 0x00, 0xFF, 0x00,
; 6010 :                    0x01, 0xff, 0xff, 0x00, 0x00, 0xff, 0xff, 0xff,   /* LCSBAF2 */
; 6011 :                    0xff
; 6012 :                  };
; 6013 : //  00A80400  00144D10 008F6001 00000101 01000040 0000FF00  01 0001 00 00 40007470 2D00000288CA6B810031001307B0B05033078797978707
; 6014 : //            0 1 2 3  4 5 6 7  8 9 A B  C D E F  0 1 2 3   0  1 2  3  4  5 6 7 8  9 A B C D E F 0 1 2 3 4 5 6 7 8 9 A B C D E F
; 6015 : 
; 6016 : #define INBOUND_4C25_SIZE  46
; 6017 : static const BYTE Inbound_4C25[INBOUND_4C25_SIZE] =
; 6018 :                  {
; 6019 :                     0x00, 0x2E, 0x04, 0x00,                          /* LCSHDR  */
; 6020 :                     0x00, 0x0D, 0x4C, 0x25, 0x00, 0x1C, 0x60, 0x03,  /* LCSBAF1 */
; 6021 :                     0x00, 0x00, 0x00, 0x01, 0x00,
; 6022 :                     0x01, 0xff, 0xff, 0xC0, 0x00, 0x00, 0x00, 0x00,  /* LCSBAF2 */
; 6023 :                     0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff,
; 6024 :                     0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
; 6025 :                     0xff, 0xff, 0xff, 0x04,
; 6026 :                     0x00                                             /* Filler  */
; 6027 :                  };
; 6028 : //  002E0400  000D4C25 001C6003 00000001 00  01 0001 C0000000 00000000 00 400074700001 000CCE4B4740 0401F3 04 00
; 6029 : //            0 1 2 3  4 5 6 7  8 9 A B  C   0  1 2  3 4 5 6  7 8 9 A  B  C D E F 0 1  2 3 4 5 6 7  8 9 A  B  C
; 6030 : 
; 6031 : #define INBOUND_4C22_SIZE  29
; 6032 : static const BYTE Inbound_4C22[INBOUND_4C22_SIZE] =
; 6033 :                  {
; 6034 :                     0x00, 0x1D, 0x04, 0x00,                          /* LCSHDR  */
; 6035 :                     0x00, 0x0D, 0x4C, 0x22, 0x00, 0x0C, 0x60, 0x03,  /* LCSBAF1 */
; 6036 :                     0x00, 0x00, 0x00, 0x01, 0x00,
; 6037 :                     0x01, 0xff, 0xff, 0xC0, 0x00, 0x00, 0x00, 0xff,  /* LCSBAF2 */
; 6038 :                     0x08, 0x00, 0x00, 0x00
; 6039 :                  };
; 6040 : //  002C0400  000D4C22 001B6003 00000001 00  01 0002 C0000000 08080000 00 destination. source...... LLC... TH etc...
; 6041 : //            0 1 2 3  4 5 6 7  8 9 A B  C   0  1 2  3 4 5 6  7 8 9 A  B  C D E F 0 1  2 3 4 5 6 7  8 9 A  B C D ...
; 6042 : 
; 6043 : #define INBOUND_4D00_SIZE  24
; 6044 : static const BYTE Inbound_4D00[INBOUND_4D00_SIZE] =
; 6045 :                  {
; 6046 :                     0x00, 0x18, 0x04, 0x00,                          /* LCSHDR  */
; 6047 :                     0x00, 0x0C, 0x4D, 0x00, 0x00, 0x08, 0x60, 0x01,  /* LCSBAF1 */
; 6048 :                     0xff, 0xff, 0xff, 0xff,
; 6049 :                     0x01, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x00   /* LCSBAF2 */
; 6050 :                  };
; 6051 : //  00180400  000C4D00 00086001 00000101  01 0000 40000240 00
; 6052 : //            0 1 2 3  4 5 6 7  8 9 A B   0  1 2  3 4 5 6  7
; 6053 : 
; 6054 : #define INBOUND_4C0B_SIZE  32
; 6055 : static const BYTE Inbound_4C0B[INBOUND_4C0B_SIZE] =
; 6056 :                  {
; 6057 :                     0x00, 0x20, 0x04, 0x00,                          /* LCSHDR  */
; 6058 :                     0x00, 0x18, 0x4C, 0x0B, 0x00, 0x03, 0x60, 0x01,  /* LCSBAF1 */
; 6059 :                     0xff, 0xff, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00,
; 6060 :                     0x00, 0x00, 0x76, 0x56, 0x00, 0x00, 0x00, 0x00,
; 6061 :                     0x01, 0x40, 0x00,                                /* LCSBAF2 */
; 6062 :                     0x00                                             /* Filler  */
; 6063 :                  };
; 6064 : //  00200400  00184C0B 00036001 00000101 00000000 00007656 00000000  014000  00
; 6065 : //            0 1 2 3  4 5 6 7  8 9 A B  C D E F  0 1 2 3  4 5 6 7   0  1 2  3
; 6066 : 
; 6067 : #define INBOUND_CD00_SIZE  32
; 6068 : static const BYTE Inbound_CD00[INBOUND_CD00_SIZE] =
; 6069 :                  {
; 6070 :                     0x00, 0x20, 0x04, 0x00,                          /* LCSHDR  */
; 6071 :                     0x00, 0x18, 0xCD, 0x00, 0x00, 0x03, 0x60, 0x01,  /* LCSBAF1 */
; 6072 :                     0xff, 0xff, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00,
; 6073 :                     0x00, 0x00, 0x70, 0x00, 0x00, 0x00, 0x00, 0x00,
; 6074 :                     0x01, 0xff, 0xff,                                /* LCSBAF2 */
; 6075 :                     0x00                                             /* Filler  */
; 6076 :                  };
; 6077 : //  00200400  0018CD00 00036001 00000101  00000000 00007000 00000000  010037  00
; 6078 : //            0 1 2 3  4 5 6 7  8 9 A B   C D E F  1 2 3 4  5 6 7 8   0 1 2
; 6079 : 
; 6080 : 
; 6081 :     LLC         llc;
; 6082 :     int         illcsize;
; 6083 :     DEVBLK*     pDEVBLK;
; 6084 :     PLCSBLK     pLCSBLK;
; 6085 :     PLCSATTN    pLCSATTN;
; 6086 :     PETHFRM     pEthFrame;
; 6087 :     BYTE*       pLLCandData;
; 6088 :     int         iLLCandDatasize;
; 6089 :     int         iDatasize;
; 6090 :     PLCSCONN    pLCSCONN;
; 6091 :     PLCSIBH     pLCSIBH;
; 6092 :     PLCSHDR     pLCSHDR;
; 6093 :     PLCSBAF1    pLCSBAF1;
; 6094 :     PLCSBAF2    pLCSBAF2;
; 6095 :     U16         hwOffset;
; 6096 :     U16         hwLenBaf1;
; 6097 :     U16         hwLenBaf2;
; 6098 :     BYTE        fAttnRequired = FALSE;

  0002f	c6 44 24 74 00	 mov	 BYTE PTR fAttnRequired$[rsp], 0
$LN4@LCS_Proces:

; 6099 :     PETHFRM     pEthFrameOut;
; 6100 :     int         iEthLenOut;
; 6101 :     int         iLPDULenOut;
; 6102 :     LLC         llcout;
; 6103 :     BYTE        frameout[64];
; 6104 :     char        llcmsg[256];
; 6105 : 
; 6106 :     UNREFERENCED( iSize );

  00034	33 c0		 xor	 eax, eax
  00036	85 c0		 test	 eax, eax
  00038	75 fa		 jne	 SHORT $LN4@LCS_Proces

; 6107 : 
; 6108 :     pDEVBLK = pLCSDEV->pDEVBLK[ LCS_READ_SUBCHANN ];  /* SNA has only one device */

  0003a	b8 08 00 00 00	 mov	 eax, 8
  0003f	48 6b c0 00	 imul	 rax, rax, 0
  00043	48 8b 8c 24 18
	03 00 00	 mov	 rcx, QWORD PTR pLCSDEV$[rsp]
  0004b	48 8b 44 01 10	 mov	 rax, QWORD PTR [rcx+rax+16]
  00050	48 89 84 24 a0
	00 00 00	 mov	 QWORD PTR pDEVBLK$[rsp], rax

; 6109 :     pLCSBLK = pLCSDEV->pLCSBLK;

  00058	48 8b 84 24 18
	03 00 00	 mov	 rax, QWORD PTR pLCSDEV$[rsp]
  00060	48 8b 40 08	 mov	 rax, QWORD PTR [rax+8]
  00064	48 89 84 24 c8
	00 00 00	 mov	 QWORD PTR pLCSBLK$[rsp], rax

; 6110 : 
; 6111 :     // Point to the accepted Ethernet frame, point to the LLC
; 6112 :     // and data, and get the length of the LLC and data.
; 6113 :     pEthFrame = (PETHFRM)pData;

  0006c	48 8b 84 24 20
	03 00 00	 mov	 rax, QWORD PTR pData$[rsp]
  00074	48 89 84 24 b0
	00 00 00	 mov	 QWORD PTR pEthFrame$[rsp], rax

; 6114 :     pLLCandData = &pEthFrame->bData[0];

  0007c	b8 01 00 00 00	 mov	 eax, 1
  00081	48 6b c0 00	 imul	 rax, rax, 0
  00085	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR pEthFrame$[rsp]
  0008d	48 8d 44 01 0e	 lea	 rax, QWORD PTR [rcx+rax+14]
  00092	48 89 84 24 18
	01 00 00	 mov	 QWORD PTR pLLCandData$[rsp], rax

; 6115 :     FETCH_HW( iLLCandDatasize, pEthFrame->hwEthernetType );

  0009a	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR pEthFrame$[rsp]
  000a2	48 83 c0 0c	 add	 rax, 12
  000a6	48 8b c8	 mov	 rcx, rax
  000a9	e8 00 00 00 00	 call	 fetch_hw_noswap
  000ae	0f b7 c8	 movzx	 ecx, ax
  000b1	e8 00 00 00 00	 call	 _byteswap_ushort
  000b6	0f b7 c0	 movzx	 eax, ax
  000b9	89 84 24 ec 00
	00 00		 mov	 DWORD PTR iLLCandDatasize$[rsp], eax

; 6116 : 
; 6117 :     // Extract the bits and bytes from the 802.2 LLC.
; 6118 :     illcsize = ExtractLLC( &llc, pLLCandData, iLLCandDatasize );

  000c0	44 8b 84 24 ec
	00 00 00	 mov	 r8d, DWORD PTR iLLCandDatasize$[rsp]
  000c8	48 8b 94 24 18
	01 00 00	 mov	 rdx, QWORD PTR pLLCandData$[rsp]
  000d0	48 8d 8c 24 38
	01 00 00	 lea	 rcx, QWORD PTR llc$[rsp]
  000d8	e8 00 00 00 00	 call	 ExtractLLC
  000dd	89 84 24 e0 00
	00 00		 mov	 DWORD PTR illcsize$[rsp], eax

; 6119 : 
; 6120 : //??    net_data_trace( pDEVBLK, pLLCandData, iLLCandDatasize, NO_DIRECTION, 'D', "LLC and data", 0 );
; 6121 : //??    net_data_trace( pDEVBLK, &illcsize, sizeof(illcsize), NO_DIRECTION, 'D', "illcsize", 0 );
; 6122 : //??    net_data_trace( pDEVBLK, &llc, sizeof(LLC), NO_DIRECTION, 'D', "llc", 0 );
; 6123 : 
; 6124 :     // Discard the frame if the 802.2 LLC appears to be questionable.
; 6125 :     if ( !illcsize ) goto msg970_return;

  000e4	83 bc 24 e0 00
	00 00 00	 cmp	 DWORD PTR illcsize$[rsp], 0
  000ec	75 05		 jne	 SHORT $LN53@LCS_Proces
  000ee	e9 5b 2b 00 00	 jmp	 $msg970_return$140
$LN53@LCS_Proces:

; 6126 : 
; 6127 :     //
; 6128 :     switch (llc.hwType)

  000f3	0f b7 84 24 64
	01 00 00	 movzx	 eax, WORD PTR llc$[rsp+44]
  000fb	89 84 24 e4 00
	00 00		 mov	 DWORD PTR tv84[rsp], eax
  00102	83 bc 24 e4 00
	00 00 01	 cmp	 DWORD PTR tv84[rsp], 1
  0010a	74 21		 je	 SHORT $LN54@LCS_Proces
  0010c	83 bc 24 e4 00
	00 00 02	 cmp	 DWORD PTR tv84[rsp], 2
  00114	0f 84 3e 09 00
	00		 je	 $LN67@LCS_Proces
  0011a	83 bc 24 e4 00
	00 00 03	 cmp	 DWORD PTR tv84[rsp], 3
  00122	0f 84 e4 0f 00
	00		 je	 $LN83@LCS_Proces
  00128	e9 23 27 00 00	 jmp	 $LN125@LCS_Proces
$LN54@LCS_Proces:

; 6129 :     {
; 6130 : 
; 6131 :     // Information Frame.
; 6132 :     case Type_Information_Frame:
; 6133 : 
; 6134 :         if (pLCSBLK->fDebug)

  0012d	48 8b 84 24 c8
	00 00 00	 mov	 rax, QWORD PTR pLCSBLK$[rsp]
  00135	8b 40 18	 mov	 eax, DWORD PTR [rax+24]
  00138	83 e0 01	 and	 eax, 1
  0013b	85 c0		 test	 eax, eax
  0013d	0f 84 91 00 00
	00		 je	 $LN55@LCS_Proces

; 6135 :         {
; 6136 :           snprintf( llcmsg, sizeof(llcmsg), "LCS: LLC information frame received: CR=%u, NR=%u, NS=%u", llc.hwCR, llc.hwNR, llc.hwNS );

  00143	0f b7 84 24 4e
	01 00 00	 movzx	 eax, WORD PTR llc$[rsp+22]
  0014b	0f b7 8c 24 50
	01 00 00	 movzx	 ecx, WORD PTR llc$[rsp+24]
  00153	0f b7 94 24 4c
	01 00 00	 movzx	 edx, WORD PTR llc$[rsp+20]
  0015b	89 44 24 28	 mov	 DWORD PTR [rsp+40], eax
  0015f	89 4c 24 20	 mov	 DWORD PTR [rsp+32], ecx
  00163	44 8b ca	 mov	 r9d, edx
  00166	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG175103
  0016d	ba 00 01 00 00	 mov	 edx, 256		; 00000100H
  00172	48 8d 8c 24 a0
	01 00 00	 lea	 rcx, QWORD PTR llcmsg$[rsp]
  0017a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_snprintf

; 6137 :           WRMSG(HHC03984, "D", llcmsg );

  00180	b9 01 00 00 00	 mov	 ecx, 1
  00185	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  0018b	48 8d 8c 24 a0
	01 00 00	 lea	 rcx, QWORD PTR llcmsg$[rsp]
  00193	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  00198	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG175104
  0019f	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  001a4	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG175105
  001ab	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  001b0	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  001b5	41 b9 03 00 00
	00		 mov	 r9d, 3
  001bb	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG175106
  001c2	ba f9 17 00 00	 mov	 edx, 6137		; 000017f9H
  001c7	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG175107
  001ce	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg
$LN55@LCS_Proces:

; 6138 :         }
; 6139 : 
; 6140 :         // Inbound TH etc, find the connection block.
; 6141 :         pLCSCONN = find_connection_by_remote_mac( pLCSDEV, &pEthFrame->bSrcMAC );

  001d4	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR pEthFrame$[rsp]
  001dc	48 83 c0 06	 add	 rax, 6
  001e0	48 8b d0	 mov	 rdx, rax
  001e3	48 8b 8c 24 18
	03 00 00	 mov	 rcx, QWORD PTR pLCSDEV$[rsp]
  001eb	e8 00 00 00 00	 call	 find_connection_by_remote_mac
  001f0	48 89 84 24 80
	00 00 00	 mov	 QWORD PTR pLCSCONN$[rsp], rax

; 6142 :         if (!pLCSCONN)

  001f8	48 83 bc 24 80
	00 00 00 00	 cmp	 QWORD PTR pLCSCONN$[rsp], 0
  00201	75 58		 jne	 SHORT $LN56@LCS_Proces

; 6143 :         {
; 6144 :             WRMSG( HHC03984, "W", "LCSCONN not found");

  00203	b9 01 00 00 00	 mov	 ecx, 1
  00208	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  0020e	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG175109
  00215	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  0021a	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG175110
  00221	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  00226	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG175111
  0022d	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00232	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00237	41 b9 03 00 00
	00		 mov	 r9d, 3
  0023d	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG175112
  00244	ba 00 18 00 00	 mov	 edx, 6144		; 00001800H
  00249	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG175113
  00250	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 6145 :             /* FixMe! Need a proper error message here! */
; 6146 :             break;

  00256	e9 fa 25 00 00	 jmp	 $LN5@LCS_Proces
$LN56@LCS_Proces:
$LN9@LCS_Proces:

; 6147 :         }
; 6148 : 
; 6149 :         //
; 6150 :         PTT_DEBUG(       "GET  InOutLock    ", 000, pDEVBLK->devnum, -1 );

  0025b	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_pttclass
  00262	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00265	48 25 00 00 02
	00		 and	 rax, 131072		; 00020000H
  0026b	48 85 c0	 test	 rax, rax
  0026e	74 42		 je	 SHORT $LN57@LCS_Proces
  00270	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR pDEVBLK$[rsp]
  00278	0f b7 40 48	 movzx	 eax, WORD PTR [rax+72]
  0027c	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR [rsp+48], 0
  00285	48 c7 44 24 28
	ff ff ff ff	 mov	 QWORD PTR [rsp+40], -1
  0028e	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG175115
  00295	48 89 4c 24 20	 mov	 QWORD PTR [rsp+32], rcx
  0029a	44 8b c8	 mov	 r9d, eax
  0029d	45 33 c0	 xor	 r8d, r8d
  002a0	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG175116
  002a7	b9 00 00 02 00	 mov	 ecx, 131072		; 00020000H
  002ac	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ptt_pthread_trace
$LN57@LCS_Proces:
  002b2	33 c0		 xor	 eax, eax
  002b4	85 c0		 test	 eax, eax
  002b6	75 a3		 jne	 SHORT $LN9@LCS_Proces

; 6151 :         obtain_lock( &pLCSDEV->InOutLock   );

  002b8	48 8b 84 24 18
	03 00 00	 mov	 rax, QWORD PTR pLCSDEV$[rsp]
  002c0	48 05 92 00 00
	00		 add	 rax, 146		; 00000092H
  002c6	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG175117
  002cd	48 8b c8	 mov	 rcx, rax
  002d0	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_obtain_lock
$LN12@LCS_Proces:

; 6152 :         PTT_DEBUG(       "GOT  InOutLock    ", 000, pDEVBLK->devnum, -1 );

  002d6	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_pttclass
  002dd	48 8b 00	 mov	 rax, QWORD PTR [rax]
  002e0	48 25 00 00 02
	00		 and	 rax, 131072		; 00020000H
  002e6	48 85 c0	 test	 rax, rax
  002e9	74 42		 je	 SHORT $LN58@LCS_Proces
  002eb	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR pDEVBLK$[rsp]
  002f3	0f b7 40 48	 movzx	 eax, WORD PTR [rax+72]
  002f7	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR [rsp+48], 0
  00300	48 c7 44 24 28
	ff ff ff ff	 mov	 QWORD PTR [rsp+40], -1
  00309	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG175119
  00310	48 89 4c 24 20	 mov	 QWORD PTR [rsp+32], rcx
  00315	44 8b c8	 mov	 r9d, eax
  00318	45 33 c0	 xor	 r8d, r8d
  0031b	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG175120
  00322	b9 00 00 02 00	 mov	 ecx, 131072		; 00020000H
  00327	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ptt_pthread_trace
$LN58@LCS_Proces:
  0032d	33 c0		 xor	 eax, eax
  0032f	85 c0		 test	 eax, eax
  00331	75 a3		 jne	 SHORT $LN12@LCS_Proces

; 6153 : 
; 6154 :         pLCSCONN->fIframe = TRUE;

  00333	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR pLCSCONN$[rsp]
  0033b	8b 40 2c	 mov	 eax, DWORD PTR [rax+44]
  0033e	83 c8 01	 or	 eax, 1
  00341	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR pLCSCONN$[rsp]
  00349	89 41 2c	 mov	 DWORD PTR [rcx+44], eax

; 6155 : 
; 6156 :         // Check that the remote NS value has incremented by one.
; 6157 :         /* FixMe! Add some code here! */
; 6158 : 
; 6159 :         // Save the remote NS and NR values.
; 6160 :         pLCSCONN->hwRemoteNS = llc.hwNS;

  0034c	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR pLCSCONN$[rsp]
  00354	0f b7 8c 24 4e
	01 00 00	 movzx	 ecx, WORD PTR llc$[rsp+22]
  0035c	66 89 48 28	 mov	 WORD PTR [rax+40], cx

; 6161 :         pLCSCONN->hwRemoteNR = llc.hwNR;

  00360	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR pLCSCONN$[rsp]
  00368	0f b7 8c 24 50
	01 00 00	 movzx	 ecx, WORD PTR llc$[rsp+24]
  00370	66 89 48 2a	 mov	 WORD PTR [rax+42], cx

; 6162 : 
; 6163 :         // Obtain a buffer in which to construct the data to be passed to VTAM.
; 6164 :         pLCSIBH = alloc_lcs_buffer( pLCSDEV, 2032 );

  00374	ba f0 07 00 00	 mov	 edx, 2032		; 000007f0H
  00379	48 8b 8c 24 18
	03 00 00	 mov	 rcx, QWORD PTR pLCSDEV$[rsp]
  00381	e8 00 00 00 00	 call	 alloc_lcs_buffer
  00386	48 89 84 24 88
	00 00 00	 mov	 QWORD PTR pLCSIBH$[rsp], rax

; 6165 : 
; 6166 :         memcpy( &pLCSIBH->bData, Inbound_4D10, Inbound_4D10_Size );

  0038e	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR pLCSIBH$[rsp]
  00396	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:?Inbound_4D10@?1??LCS_ProcessAccepted_SNA@@9@9
  0039d	48 8d 78 10	 lea	 rdi, QWORD PTR [rax+16]
  003a1	48 8b f1	 mov	 rsi, rcx
  003a4	b9 21 00 00 00	 mov	 ecx, 33			; 00000021H
  003a9	f3 a4		 rep movsb

; 6167 :         pLCSIBH->iDataLen = Inbound_4D10_Size;

  003ab	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR pLCSIBH$[rsp]
  003b3	c7 40 0c 21 00
	00 00		 mov	 DWORD PTR [rax+12], 33	; 00000021H

; 6168 : 
; 6169 :         pLCSHDR = (PLCSHDR)&pLCSIBH->bData;

  003ba	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR pLCSIBH$[rsp]
  003c2	48 83 c0 10	 add	 rax, 16
  003c6	48 89 84 24 c0
	00 00 00	 mov	 QWORD PTR pLCSHDR$[rsp], rax

; 6170 :         pLCSBAF1 = (PLCSBAF1)( (BYTE*)pLCSHDR + sizeof(LCSHDR) );

  003ce	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR pLCSHDR$[rsp]
  003d6	48 83 c0 04	 add	 rax, 4
  003da	48 89 84 24 98
	00 00 00	 mov	 QWORD PTR pLCSBAF1$[rsp], rax

; 6171 :         FETCH_HW( hwLenBaf1, pLCSBAF1->hwLenBaf1 );

  003e2	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR pLCSBAF1$[rsp]
  003ea	48 8b c8	 mov	 rcx, rax
  003ed	e8 00 00 00 00	 call	 fetch_hw_noswap
  003f2	0f b7 c8	 movzx	 ecx, ax
  003f5	e8 00 00 00 00	 call	 _byteswap_ushort
  003fa	66 89 84 24 90
	00 00 00	 mov	 WORD PTR hwLenBaf1$[rsp], ax

; 6172 :         FETCH_HW( hwLenBaf2, pLCSBAF1->hwLenBaf2 );

  00402	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR pLCSBAF1$[rsp]
  0040a	48 83 c0 04	 add	 rax, 4
  0040e	48 8b c8	 mov	 rcx, rax
  00411	e8 00 00 00 00	 call	 fetch_hw_noswap
  00416	0f b7 c8	 movzx	 ecx, ax
  00419	e8 00 00 00 00	 call	 _byteswap_ushort
  0041e	66 89 44 24 78	 mov	 WORD PTR hwLenBaf2$[rsp], ax

; 6173 :         pLCSBAF2 = (PLCSBAF2)( (BYTE*)pLCSBAF1 + hwLenBaf1 );

  00423	0f b7 84 24 90
	00 00 00	 movzx	 eax, WORD PTR hwLenBaf1$[rsp]
  0042b	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR pLCSBAF1$[rsp]
  00433	48 03 c8	 add	 rcx, rax
  00436	48 8b c1	 mov	 rax, rcx
  00439	48 89 84 24 b8
	00 00 00	 mov	 QWORD PTR pLCSBAF2$[rsp], rax

; 6174 : 
; 6175 :         //
; 6176 :         memcpy( pLCSBAF1->bTokenA, &pLCSCONN->bInToken, sizeof(pLCSCONN->bInToken) );      // Set Outbound token

  00441	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR pLCSBAF1$[rsp]
  00449	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR pLCSCONN$[rsp]
  00451	8b 49 08	 mov	 ecx, DWORD PTR [rcx+8]
  00454	89 48 08	 mov	 DWORD PTR [rax+8], ecx

; 6177 : 
; 6178 :         //
; 6179 :         pLCSCONN->hwDataSeqNum++;

  00457	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR pLCSCONN$[rsp]
  0045f	0f b7 40 22	 movzx	 eax, WORD PTR [rax+34]
  00463	66 ff c0	 inc	 ax
  00466	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR pLCSCONN$[rsp]
  0046e	66 89 41 22	 mov	 WORD PTR [rcx+34], ax

; 6180 :         STORE_HW( pLCSBAF2->hwSeqNum, pLCSCONN->hwDataSeqNum );

  00472	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR pLCSCONN$[rsp]
  0047a	0f b7 48 22	 movzx	 ecx, WORD PTR [rax+34]
  0047e	e8 00 00 00 00	 call	 _byteswap_ushort
  00483	48 8b 8c 24 b8
	00 00 00	 mov	 rcx, QWORD PTR pLCSBAF2$[rsp]
  0048b	48 ff c1	 inc	 rcx
  0048e	0f b7 d0	 movzx	 edx, ax
  00491	e8 00 00 00 00	 call	 store_hw_noswap

; 6181 : 
; 6182 :         memcpy( &pLCSBAF2->bByte05, pLCSPORT->MAC_Address, 4 );      // Just the first 4-bytes!

  00496	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR pLCSBAF2$[rsp]
  0049e	48 8b 8c 24 10
	03 00 00	 mov	 rcx, QWORD PTR pLCSPORT$[rsp]
  004a6	8b 49 02	 mov	 ecx, DWORD PTR [rcx+2]
  004a9	89 48 05	 mov	 DWORD PTR [rax+5], ecx

; 6183 : 
; 6184 :         // Copy the TH etc to the buffer.
; 6185 :         iDatasize = (iLLCandDatasize - illcsize);

  004ac	8b 84 24 e0 00
	00 00		 mov	 eax, DWORD PTR illcsize$[rsp]
  004b3	8b 8c 24 ec 00
	00 00		 mov	 ecx, DWORD PTR iLLCandDatasize$[rsp]
  004ba	2b c8		 sub	 ecx, eax
  004bc	8b c1		 mov	 eax, ecx
  004be	89 84 24 a8 00
	00 00		 mov	 DWORD PTR iDatasize$[rsp], eax

; 6186 :         if ( iDatasize > 0 )

  004c5	83 bc 24 a8 00
	00 00 00	 cmp	 DWORD PTR iDatasize$[rsp], 0
  004cd	0f 8e e9 00 00
	00		 jle	 $LN59@LCS_Proces

; 6187 :         {
; 6188 :             memcpy( &pLCSBAF2->bByte09, &pEthFrame->bData[illcsize], iDatasize );

  004d3	48 63 84 24 a8
	00 00 00	 movsxd	 rax, DWORD PTR iDatasize$[rsp]
  004db	48 63 8c 24 e0
	00 00 00	 movsxd	 rcx, DWORD PTR illcsize$[rsp]
  004e3	48 8b 94 24 b0
	00 00 00	 mov	 rdx, QWORD PTR pEthFrame$[rsp]
  004eb	48 8d 4c 0a 0e	 lea	 rcx, QWORD PTR [rdx+rcx+14]
  004f0	48 8b 94 24 b8
	00 00 00	 mov	 rdx, QWORD PTR pLCSBAF2$[rsp]
  004f8	48 83 c2 09	 add	 rdx, 9
  004fc	48 8b fa	 mov	 rdi, rdx
  004ff	48 8b f1	 mov	 rsi, rcx
  00502	48 8b c8	 mov	 rcx, rax
  00505	f3 a4		 rep movsb

; 6189 : 
; 6190 :             pLCSIBH->iDataLen += iDatasize;

  00507	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR pLCSIBH$[rsp]
  0050f	8b 40 0c	 mov	 eax, DWORD PTR [rax+12]
  00512	03 84 24 a8 00
	00 00		 add	 eax, DWORD PTR iDatasize$[rsp]
  00519	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR pLCSIBH$[rsp]
  00521	89 41 0c	 mov	 DWORD PTR [rcx+12], eax

; 6191 : 
; 6192 :             FETCH_HW( hwLenBaf2, pLCSBAF1->hwLenBaf2 );

  00524	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR pLCSBAF1$[rsp]
  0052c	48 83 c0 04	 add	 rax, 4
  00530	48 8b c8	 mov	 rcx, rax
  00533	e8 00 00 00 00	 call	 fetch_hw_noswap
  00538	0f b7 c8	 movzx	 ecx, ax
  0053b	e8 00 00 00 00	 call	 _byteswap_ushort
  00540	66 89 44 24 78	 mov	 WORD PTR hwLenBaf2$[rsp], ax

; 6193 :             hwLenBaf2 += iDatasize;

  00545	0f b7 44 24 78	 movzx	 eax, WORD PTR hwLenBaf2$[rsp]
  0054a	03 84 24 a8 00
	00 00		 add	 eax, DWORD PTR iDatasize$[rsp]
  00551	66 89 44 24 78	 mov	 WORD PTR hwLenBaf2$[rsp], ax

; 6194 :             STORE_HW( pLCSBAF1->hwLenBaf2, hwLenBaf2 );

  00556	0f b7 4c 24 78	 movzx	 ecx, WORD PTR hwLenBaf2$[rsp]
  0055b	e8 00 00 00 00	 call	 _byteswap_ushort
  00560	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR pLCSBAF1$[rsp]
  00568	48 83 c1 04	 add	 rcx, 4
  0056c	0f b7 d0	 movzx	 edx, ax
  0056f	e8 00 00 00 00	 call	 store_hw_noswap

; 6195 : 
; 6196 :             FETCH_HW( hwOffset, pLCSHDR->hwOffset );

  00574	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR pLCSHDR$[rsp]
  0057c	48 8b c8	 mov	 rcx, rax
  0057f	e8 00 00 00 00	 call	 fetch_hw_noswap
  00584	0f b7 c8	 movzx	 ecx, ax
  00587	e8 00 00 00 00	 call	 _byteswap_ushort
  0058c	66 89 44 24 70	 mov	 WORD PTR hwOffset$[rsp], ax

; 6197 :             hwOffset += iDatasize;

  00591	0f b7 44 24 70	 movzx	 eax, WORD PTR hwOffset$[rsp]
  00596	03 84 24 a8 00
	00 00		 add	 eax, DWORD PTR iDatasize$[rsp]
  0059d	66 89 44 24 70	 mov	 WORD PTR hwOffset$[rsp], ax

; 6198 :             STORE_HW( pLCSHDR->hwOffset, hwOffset );

  005a2	0f b7 4c 24 70	 movzx	 ecx, WORD PTR hwOffset$[rsp]
  005a7	e8 00 00 00 00	 call	 _byteswap_ushort
  005ac	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR pLCSHDR$[rsp]
  005b4	0f b7 d0	 movzx	 edx, ax
  005b7	e8 00 00 00 00	 call	 store_hw_noswap
$LN59@LCS_Proces:

; 6199 :         }
; 6200 : 
; 6201 :         // Add a padding byte to the buffer, if necessary.
; 6202 :         if  ( pLCSIBH->iDataLen & 0x01 )

  005bc	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR pLCSIBH$[rsp]
  005c4	8b 40 0c	 mov	 eax, DWORD PTR [rax+12]
  005c7	83 e0 01	 and	 eax, 1
  005ca	85 c0		 test	 eax, eax
  005cc	74 5c		 je	 SHORT $LN60@LCS_Proces

; 6203 :         {
; 6204 :             pLCSIBH->iDataLen++;

  005ce	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR pLCSIBH$[rsp]
  005d6	8b 40 0c	 mov	 eax, DWORD PTR [rax+12]
  005d9	ff c0		 inc	 eax
  005db	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR pLCSIBH$[rsp]
  005e3	89 41 0c	 mov	 DWORD PTR [rcx+12], eax

; 6205 : 
; 6206 :             FETCH_HW( hwOffset, pLCSHDR->hwOffset );

  005e6	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR pLCSHDR$[rsp]
  005ee	48 8b c8	 mov	 rcx, rax
  005f1	e8 00 00 00 00	 call	 fetch_hw_noswap
  005f6	0f b7 c8	 movzx	 ecx, ax
  005f9	e8 00 00 00 00	 call	 _byteswap_ushort
  005fe	66 89 44 24 70	 mov	 WORD PTR hwOffset$[rsp], ax

; 6207 :             hwOffset++;

  00603	0f b7 44 24 70	 movzx	 eax, WORD PTR hwOffset$[rsp]
  00608	66 ff c0	 inc	 ax
  0060b	66 89 44 24 70	 mov	 WORD PTR hwOffset$[rsp], ax

; 6208 :             STORE_HW( pLCSHDR->hwOffset, hwOffset );

  00610	0f b7 4c 24 70	 movzx	 ecx, WORD PTR hwOffset$[rsp]
  00615	e8 00 00 00 00	 call	 _byteswap_ushort
  0061a	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR pLCSHDR$[rsp]
  00622	0f b7 d0	 movzx	 edx, ax
  00625	e8 00 00 00 00	 call	 store_hw_noswap
$LN60@LCS_Proces:

; 6209 :         }
; 6210 : 
; 6211 :         // Add the buffer containing the inbond TH etc to the chain.
; 6212 :         add_lcs_buffer_to_chain( pLCSDEV, pLCSIBH );

  0062a	48 8b 94 24 88
	00 00 00	 mov	 rdx, QWORD PTR pLCSIBH$[rsp]
  00632	48 8b 8c 24 18
	03 00 00	 mov	 rcx, QWORD PTR pLCSDEV$[rsp]
  0063a	e8 00 00 00 00	 call	 add_lcs_buffer_to_chain

; 6213 : 
; 6214 :         fAttnRequired = TRUE;

  0063f	c6 44 24 74 01	 mov	 BYTE PTR fAttnRequired$[rsp], 1

; 6215 : 
; 6216 :         // We have done everything to let VTAM know that data has arrived,
; 6217 :         // now we need to let the remote end know the data has arrived.
; 6218 :         memset( frameout, 0, sizeof(frameout) );       // Clear area for ethernet fram

  00644	48 8d 84 24 a0
	02 00 00	 lea	 rax, QWORD PTR frameout$[rsp]
  0064c	48 8b f8	 mov	 rdi, rax
  0064f	33 c0		 xor	 eax, eax
  00651	b9 40 00 00 00	 mov	 ecx, 64			; 00000040H
  00656	f3 aa		 rep stosb

; 6219 :         pEthFrameOut = (PETHFRM)&frameout[0];

  00658	b8 01 00 00 00	 mov	 eax, 1
  0065d	48 6b c0 00	 imul	 rax, rax, 0
  00661	48 8d 84 04 a0
	02 00 00	 lea	 rax, QWORD PTR frameout$[rsp+rax]
  00669	48 89 84 24 d0
	00 00 00	 mov	 QWORD PTR pEthFrameOut$[rsp], rax

; 6220 :         iEthLenOut = 60;                               // Minimum ethernet frame length

  00671	c7 84 24 94 00
	00 00 3c 00 00
	00		 mov	 DWORD PTR iEthLenOut$[rsp], 60 ; 0000003cH

; 6221 : 
; 6222 :         //
; 6223 :         memset( &llcout, 0, sizeof(LLC) );

  0067c	48 8d 84 24 68
	01 00 00	 lea	 rax, QWORD PTR llcout$[rsp]
  00684	48 8b f8	 mov	 rdi, rax
  00687	33 c0		 xor	 eax, eax
  00689	b9 2e 00 00 00	 mov	 ecx, 46			; 0000002eH
  0068e	f3 aa		 rep stosb

; 6224 :         llcout.hwDSAP    = llc.hwSSAP;                 // Copy LLC inbound SSAP as outbound DSAP

  00690	0f b7 84 24 4a
	01 00 00	 movzx	 eax, WORD PTR llc$[rsp+18]
  00698	66 89 84 24 76
	01 00 00	 mov	 WORD PTR llcout$[rsp+14], ax

; 6225 :         llcout.hwSSAP    = llc.hwDSAP;                 // Copy LLC inbound DSAP as outbound SSAP

  006a0	0f b7 84 24 46
	01 00 00	 movzx	 eax, WORD PTR llc$[rsp+14]
  006a8	66 89 84 24 7a
	01 00 00	 mov	 WORD PTR llcout$[rsp+18], ax

; 6226 :         llcout.hwCR      = 1;

  006b0	b8 01 00 00 00	 mov	 eax, 1
  006b5	66 89 84 24 7c
	01 00 00	 mov	 WORD PTR llcout$[rsp+20], ax

; 6227 :         llcout.hwNR      = ((pLCSCONN->hwRemoteNS + 1) & 0x7F);

  006bd	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR pLCSCONN$[rsp]
  006c5	0f b7 40 28	 movzx	 eax, WORD PTR [rax+40]
  006c9	ff c0		 inc	 eax
  006cb	83 e0 7f	 and	 eax, 127		; 0000007fH
  006ce	66 89 84 24 80
	01 00 00	 mov	 WORD PTR llcout$[rsp+24], ax

; 6228 :         llcout.hwSS      = SS_Receiver_Ready;

  006d6	33 c0		 xor	 eax, eax
  006d8	66 89 84 24 84
	01 00 00	 mov	 WORD PTR llcout$[rsp+28], ax

; 6229 :         llcout.hwType    = Type_Supervisory_Frame;

  006e0	b8 02 00 00 00	 mov	 eax, 2
  006e5	66 89 84 24 94
	01 00 00	 mov	 WORD PTR llcout$[rsp+44], ax

; 6230 : 
; 6231 :         // Construct Ethernet frame
; 6232 :         memcpy( &pEthFrameOut->bDestMAC, &pEthFrame->bSrcMAC, IFHWADDRLEN );  // Copy destination MAC address

  006ed	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR pEthFrame$[rsp]
  006f5	48 8b bc 24 d0
	00 00 00	 mov	 rdi, QWORD PTR pEthFrameOut$[rsp]
  006fd	48 8d 70 06	 lea	 rsi, QWORD PTR [rax+6]
  00701	b9 06 00 00 00	 mov	 ecx, 6
  00706	f3 a4		 rep movsb

; 6233 :         memcpy( &pEthFrameOut->bSrcMAC, &pEthFrame->bDestMAC, IFHWADDRLEN );  // Copy source MAC address

  00708	48 8b 84 24 d0
	00 00 00	 mov	 rax, QWORD PTR pEthFrameOut$[rsp]
  00710	48 8d 78 06	 lea	 rdi, QWORD PTR [rax+6]
  00714	48 8b b4 24 b0
	00 00 00	 mov	 rsi, QWORD PTR pEthFrame$[rsp]
  0071c	b9 06 00 00 00	 mov	 ecx, 6
  00721	f3 a4		 rep movsb

; 6234 :         iLPDULenOut = BuildLLC( &llcout, pEthFrameOut->bData);                // Build LLC PDU

  00723	48 8b 84 24 d0
	00 00 00	 mov	 rax, QWORD PTR pEthFrameOut$[rsp]
  0072b	48 83 c0 0e	 add	 rax, 14
  0072f	48 8b d0	 mov	 rdx, rax
  00732	48 8d 8c 24 68
	01 00 00	 lea	 rcx, QWORD PTR llcout$[rsp]
  0073a	e8 00 00 00 00	 call	 BuildLLC
  0073f	89 84 24 d8 00
	00 00		 mov	 DWORD PTR iLPDULenOut$[rsp], eax

; 6235 :         STORE_HW( pEthFrameOut->hwEthernetType, (U16)iLPDULenOut );           // Set data length

  00746	0f b7 8c 24 d8
	00 00 00	 movzx	 ecx, WORD PTR iLPDULenOut$[rsp]
  0074e	e8 00 00 00 00	 call	 _byteswap_ushort
  00753	48 8b 8c 24 d0
	00 00 00	 mov	 rcx, QWORD PTR pEthFrameOut$[rsp]
  0075b	48 83 c1 0c	 add	 rcx, 12
  0075f	0f b7 d0	 movzx	 edx, ax
  00762	e8 00 00 00 00	 call	 store_hw_noswap

; 6236 : 
; 6237 :         // Trace Ethernet frame before sending to TAP device
; 6238 :         if (pLCSBLK->fDebug)

  00767	48 8b 84 24 c8
	00 00 00	 mov	 rax, QWORD PTR pLCSBLK$[rsp]
  0076f	8b 40 18	 mov	 eax, DWORD PTR [rax+24]
  00772	83 e0 01	 and	 eax, 1
  00775	85 c0		 test	 eax, eax
  00777	0f 84 19 01 00
	00		 je	 $LN61@LCS_Proces

; 6239 :         {
; 6240 :             // "%1d:%04X %s: port %2.2X: Send frame of size %d bytes (with %s packet) to device %s"
; 6241 :             WRMSG(HHC00983, "D", SSID_TO_LCSS(pDEVBLK->ssid), pDEVBLK->devnum, pDEVBLK->typname,

  0077d	48 8b 84 24 10
	03 00 00	 mov	 rax, QWORD PTR pLCSPORT$[rsp]
  00785	48 05 48 01 00
	00		 add	 rax, 328		; 00000148H
  0078b	48 89 84 24 20
	01 00 00	 mov	 QWORD PTR tv379[rsp], rax
  00793	48 8b 8c 24 18
	03 00 00	 mov	 rcx, QWORD PTR pLCSDEV$[rsp]
  0079b	0f b6 49 23	 movzx	 ecx, BYTE PTR [rcx+35]
  0079f	89 8c 24 08 01
	00 00		 mov	 DWORD PTR tv384[rsp], ecx
  007a6	48 8b 94 24 a0
	00 00 00	 mov	 rdx, QWORD PTR pDEVBLK$[rsp]
  007ae	0f b7 52 48	 movzx	 edx, WORD PTR [rdx+72]
  007b2	89 94 24 0c 01
	00 00		 mov	 DWORD PTR tv389[rsp], edx
  007b9	48 8b bc 24 a0
	00 00 00	 mov	 rdi, QWORD PTR pDEVBLK$[rsp]
  007c1	0f b7 7f 44	 movzx	 edi, WORD PTR [rdi+68]
  007c5	d1 ff		 sar	 edi, 1
  007c7	b9 01 00 00 00	 mov	 ecx, 1
  007cc	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  007d2	48 8b 8c 24 20
	01 00 00	 mov	 rcx, QWORD PTR tv379[rsp]
  007da	48 89 4c 24 68	 mov	 QWORD PTR [rsp+104], rcx
  007df	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG175124
  007e6	48 89 4c 24 60	 mov	 QWORD PTR [rsp+96], rcx
  007eb	8b 8c 24 94 00
	00 00		 mov	 ecx, DWORD PTR iEthLenOut$[rsp]
  007f2	89 4c 24 58	 mov	 DWORD PTR [rsp+88], ecx
  007f6	8b 8c 24 08 01
	00 00		 mov	 ecx, DWORD PTR tv384[rsp]
  007fd	89 4c 24 50	 mov	 DWORD PTR [rsp+80], ecx
  00801	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR pDEVBLK$[rsp]
  00809	48 8b 49 50	 mov	 rcx, QWORD PTR [rcx+80]
  0080d	48 89 4c 24 48	 mov	 QWORD PTR [rsp+72], rcx
  00812	8b 8c 24 0c 01
	00 00		 mov	 ecx, DWORD PTR tv389[rsp]
  00819	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  0081d	89 7c 24 38	 mov	 DWORD PTR [rsp+56], edi
  00821	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG175125
  00828	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  0082d	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG175126
  00834	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00839	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  0083e	41 b9 03 00 00
	00		 mov	 r9d, 3
  00844	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG175127
  0084b	ba 62 18 00 00	 mov	 edx, 6242		; 00001862H
  00850	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG175128
  00857	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 6242 :                                  pLCSDEV->bPort, iEthLenOut, "802.3 SNA", pLCSPORT->szNetIfName );
; 6243 :             net_data_trace( pDEVBLK, (BYTE*)pEthFrameOut, iEthLenOut, FROM_GUEST, 'D', "eth frame", 0 );

  0085d	c7 44 24 30 00
	00 00 00	 mov	 DWORD PTR [rsp+48], 0
  00865	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG175129
  0086c	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  00871	c6 44 24 20 44	 mov	 BYTE PTR [rsp+32], 68	; 00000044H
  00876	41 b1 3c	 mov	 r9b, 60			; 0000003cH
  00879	44 8b 84 24 94
	00 00 00	 mov	 r8d, DWORD PTR iEthLenOut$[rsp]
  00881	48 8b 94 24 d0
	00 00 00	 mov	 rdx, QWORD PTR pEthFrameOut$[rsp]
  00889	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR pDEVBLK$[rsp]
  00891	e8 00 00 00 00	 call	 net_data_trace
$LN61@LCS_Proces:

; 6244 :         }
; 6245 : 
; 6246 :         // Write the Ethernet frame to the TAP device
; 6247 :         if (TUNTAP_Write( pDEVBLK->fd, (BYTE*)pEthFrameOut, iEthLenOut ) == iEthLenOut)

  00896	44 8b 84 24 94
	00 00 00	 mov	 r8d, DWORD PTR iEthLenOut$[rsp]
  0089e	48 8b 94 24 d0
	00 00 00	 mov	 rdx, QWORD PTR pEthFrameOut$[rsp]
  008a6	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR pDEVBLK$[rsp]
  008ae	8b 88 ac 01 00
	00		 mov	 ecx, DWORD PTR [rax+428]
  008b4	e8 00 00 00 00	 call	 tt32_write
  008b9	3b 84 24 94 00
	00 00		 cmp	 eax, DWORD PTR iEthLenOut$[rsp]
  008c0	0f 85 b9 00 00
	00		 jne	 $LN62@LCS_Proces

; 6248 :         {
; 6249 :             if (pLCSPORT->pLCSBLK->fDebug)

  008c6	48 8b 84 24 10
	03 00 00	 mov	 rax, QWORD PTR pLCSPORT$[rsp]
  008ce	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  008d2	8b 40 18	 mov	 eax, DWORD PTR [rax+24]
  008d5	83 e0 01	 and	 eax, 1
  008d8	85 c0		 test	 eax, eax
  008da	0f 84 9d 00 00
	00		 je	 $LN64@LCS_Proces

; 6250 :             {
; 6251 :                 snprintf( llcmsg, sizeof(llcmsg), "LCS: LLC supervisory frame sent: CR=%u, SS=%s, PF=%u, NR=%u", llcout.hwCR, "Receiver Ready", llcout.hwPF, llcout.hwNR );

  008e0	0f b7 84 24 80
	01 00 00	 movzx	 eax, WORD PTR llcout$[rsp+24]
  008e8	0f b7 8c 24 82
	01 00 00	 movzx	 ecx, WORD PTR llcout$[rsp+26]
  008f0	0f b7 94 24 7c
	01 00 00	 movzx	 edx, WORD PTR llcout$[rsp+20]
  008f8	89 44 24 30	 mov	 DWORD PTR [rsp+48], eax
  008fc	89 4c 24 28	 mov	 DWORD PTR [rsp+40], ecx
  00900	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG175133
  00907	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  0090c	44 8b ca	 mov	 r9d, edx
  0090f	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG175134
  00916	ba 00 01 00 00	 mov	 edx, 256		; 00000100H
  0091b	48 8d 8c 24 a0
	01 00 00	 lea	 rcx, QWORD PTR llcmsg$[rsp]
  00923	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_snprintf

; 6252 :                 WRMSG(HHC03984, "D", llcmsg );

  00929	b9 01 00 00 00	 mov	 ecx, 1
  0092e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  00934	48 8d 8c 24 a0
	01 00 00	 lea	 rcx, QWORD PTR llcmsg$[rsp]
  0093c	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  00941	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG175135
  00948	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  0094d	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG175136
  00954	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00959	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  0095e	41 b9 03 00 00
	00		 mov	 r9d, 3
  00964	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG175137
  0096b	ba 6c 18 00 00	 mov	 edx, 6252		; 0000186cH
  00970	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG175138
  00977	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg
$LN64@LCS_Proces:

; 6253 :             }
; 6254 :         }

  0097d	eb 59		 jmp	 SHORT $LN63@LCS_Proces
$LN62@LCS_Proces:
$LN15@LCS_Proces:

; 6255 :         else
; 6256 :         {
; 6257 : //??        pLCSDEV->iTuntapErrno = errno;
; 6258 : //??        pLCSDEV->fTuntapError = TRUE;
; 6259 :             PTT_TIMING( "*WRITE ERR", 0, iEthLenOut, 1 );

  0097f	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_pttclass
  00986	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00989	48 25 00 00 01
	00		 and	 rax, 65536		; 00010000H
  0098f	48 85 c0	 test	 rax, rax
  00992	74 3e		 je	 SHORT $LN65@LCS_Proces
  00994	48 63 84 24 94
	00 00 00	 movsxd	 rax, DWORD PTR iEthLenOut$[rsp]
  0099c	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR [rsp+48], 0
  009a5	48 c7 44 24 28
	01 00 00 00	 mov	 QWORD PTR [rsp+40], 1
  009ae	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG175140
  009b5	48 89 4c 24 20	 mov	 QWORD PTR [rsp+32], rcx
  009ba	4c 8b c8	 mov	 r9, rax
  009bd	45 33 c0	 xor	 r8d, r8d
  009c0	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG175141
  009c7	b9 00 00 01 00	 mov	 ecx, 65536		; 00010000H
  009cc	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ptt_pthread_trace
$LN65@LCS_Proces:
  009d2	33 c0		 xor	 eax, eax
  009d4	85 c0		 test	 eax, eax
  009d6	75 a7		 jne	 SHORT $LN15@LCS_Proces
$LN63@LCS_Proces:
$LN18@LCS_Proces:

; 6260 :         }
; 6261 : 
; 6262 :         //
; 6263 :         PTT_DEBUG(        "REL  InOutLock    ", 000, pDEVBLK->devnum, -1 );

  009d8	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_pttclass
  009df	48 8b 00	 mov	 rax, QWORD PTR [rax]
  009e2	48 25 00 00 02
	00		 and	 rax, 131072		; 00020000H
  009e8	48 85 c0	 test	 rax, rax
  009eb	74 42		 je	 SHORT $LN66@LCS_Proces
  009ed	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR pDEVBLK$[rsp]
  009f5	0f b7 40 48	 movzx	 eax, WORD PTR [rax+72]
  009f9	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR [rsp+48], 0
  00a02	48 c7 44 24 28
	ff ff ff ff	 mov	 QWORD PTR [rsp+40], -1
  00a0b	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG175143
  00a12	48 89 4c 24 20	 mov	 QWORD PTR [rsp+32], rcx
  00a17	44 8b c8	 mov	 r9d, eax
  00a1a	45 33 c0	 xor	 r8d, r8d
  00a1d	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG175144
  00a24	b9 00 00 02 00	 mov	 ecx, 131072		; 00020000H
  00a29	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ptt_pthread_trace
$LN66@LCS_Proces:
  00a2f	33 c0		 xor	 eax, eax
  00a31	85 c0		 test	 eax, eax
  00a33	75 a3		 jne	 SHORT $LN18@LCS_Proces

; 6264 :         release_lock( &pLCSDEV->InOutLock   );

  00a35	48 8b 84 24 18
	03 00 00	 mov	 rax, QWORD PTR pLCSDEV$[rsp]
  00a3d	48 05 92 00 00
	00		 add	 rax, 146		; 00000092H
  00a43	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG175145
  00a4a	48 8b c8	 mov	 rcx, rax
  00a4d	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_release_lock

; 6265 : 
; 6266 :         break;

  00a53	e9 fd 1d 00 00	 jmp	 $LN5@LCS_Proces
$LN67@LCS_Proces:

; 6267 : 
; 6268 :     // Supervisory Frame.
; 6269 :     case Type_Supervisory_Frame:
; 6270 : 
; 6271 :         switch (llc.hwSS)

  00a58	0f b7 84 24 54
	01 00 00	 movzx	 eax, WORD PTR llc$[rsp+28]
  00a60	89 84 24 e8 00
	00 00		 mov	 DWORD PTR tv468[rsp], eax
  00a67	83 bc 24 e8 00
	00 00 00	 cmp	 DWORD PTR tv468[rsp], 0
  00a6f	74 21		 je	 SHORT $LN68@LCS_Proces
  00a71	83 bc 24 e8 00
	00 00 01	 cmp	 DWORD PTR tv468[rsp], 1
  00a79	0f 84 16 05 00
	00		 je	 $LN78@LCS_Proces
  00a7f	83 bc 24 e8 00
	00 00 02	 cmp	 DWORD PTR tv468[rsp], 2
  00a87	0f 84 c0 05 00
	00		 je	 $LN80@LCS_Proces
  00a8d	e9 70 06 00 00	 jmp	 $LN82@LCS_Proces
$LN68@LCS_Proces:

; 6272 :         {
; 6273 : 
; 6274 :         // Supervisory Frame: Receiver Ready.
; 6275 :         case SS_Receiver_Ready:
; 6276 : 
; 6277 :             if (pLCSBLK->fDebug)

  00a92	48 8b 84 24 c8
	00 00 00	 mov	 rax, QWORD PTR pLCSBLK$[rsp]
  00a9a	8b 40 18	 mov	 eax, DWORD PTR [rax+24]
  00a9d	83 e0 01	 and	 eax, 1
  00aa0	85 c0		 test	 eax, eax
  00aa2	0f 84 9d 00 00
	00		 je	 $LN69@LCS_Proces

; 6278 :             {
; 6279 :               snprintf( llcmsg, sizeof(llcmsg), "LCS: LLC supervisory frame received: CR=%u, SS=%s, PF=%u, NR=%u", llc.hwCR, "Receiver Ready", llc.hwPF, llc.hwNR );

  00aa8	0f b7 84 24 50
	01 00 00	 movzx	 eax, WORD PTR llc$[rsp+24]
  00ab0	0f b7 8c 24 52
	01 00 00	 movzx	 ecx, WORD PTR llc$[rsp+26]
  00ab8	0f b7 94 24 4c
	01 00 00	 movzx	 edx, WORD PTR llc$[rsp+20]
  00ac0	89 44 24 30	 mov	 DWORD PTR [rsp+48], eax
  00ac4	89 4c 24 28	 mov	 DWORD PTR [rsp+40], ecx
  00ac8	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG175149
  00acf	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00ad4	44 8b ca	 mov	 r9d, edx
  00ad7	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG175150
  00ade	ba 00 01 00 00	 mov	 edx, 256		; 00000100H
  00ae3	48 8d 8c 24 a0
	01 00 00	 lea	 rcx, QWORD PTR llcmsg$[rsp]
  00aeb	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_snprintf

; 6280 :               WRMSG(HHC03984, "D", llcmsg );

  00af1	b9 01 00 00 00	 mov	 ecx, 1
  00af6	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  00afc	48 8d 8c 24 a0
	01 00 00	 lea	 rcx, QWORD PTR llcmsg$[rsp]
  00b04	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  00b09	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG175151
  00b10	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  00b15	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG175152
  00b1c	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00b21	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00b26	41 b9 03 00 00
	00		 mov	 r9d, 3
  00b2c	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG175153
  00b33	ba 88 18 00 00	 mov	 edx, 6280		; 00001888H
  00b38	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG175154
  00b3f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg
$LN69@LCS_Proces:

; 6281 :             }
; 6282 : 
; 6283 :             // Find the connection block.
; 6284 :             pLCSCONN = find_connection_by_remote_mac( pLCSDEV, &pEthFrame->bSrcMAC );

  00b45	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR pEthFrame$[rsp]
  00b4d	48 83 c0 06	 add	 rax, 6
  00b51	48 8b d0	 mov	 rdx, rax
  00b54	48 8b 8c 24 18
	03 00 00	 mov	 rcx, QWORD PTR pLCSDEV$[rsp]
  00b5c	e8 00 00 00 00	 call	 find_connection_by_remote_mac
  00b61	48 89 84 24 80
	00 00 00	 mov	 QWORD PTR pLCSCONN$[rsp], rax

; 6285 :             if (!pLCSCONN)

  00b69	48 83 bc 24 80
	00 00 00 00	 cmp	 QWORD PTR pLCSCONN$[rsp], 0
  00b72	75 58		 jne	 SHORT $LN70@LCS_Proces

; 6286 :             {
; 6287 :                 WRMSG( HHC03984, "W", "LCSCONN not found");

  00b74	b9 01 00 00 00	 mov	 ecx, 1
  00b79	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  00b7f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG175156
  00b86	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  00b8b	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG175157
  00b92	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  00b97	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG175158
  00b9e	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00ba3	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00ba8	41 b9 03 00 00
	00		 mov	 r9d, 3
  00bae	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG175159
  00bb5	ba 8f 18 00 00	 mov	 edx, 6287		; 0000188fH
  00bba	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG175160
  00bc1	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 6288 :                 /* FixMe! Need a proper error message here! */
; 6289 :                 break;

  00bc7	e9 3b 05 00 00	 jmp	 $LN19@LCS_Proces
$LN70@LCS_Proces:

; 6290 :             }
; 6291 : 
; 6292 :             // ??
; 6293 :             if (!llc.hwPF)

  00bcc	0f b7 84 24 52
	01 00 00	 movzx	 eax, WORD PTR llc$[rsp+26]
  00bd4	85 c0		 test	 eax, eax
  00bd6	75 05		 jne	 SHORT $LN71@LCS_Proces

; 6294 :             {
; 6295 :                 break;

  00bd8	e9 2a 05 00 00	 jmp	 $LN19@LCS_Proces
$LN71@LCS_Proces:

; 6296 :             }
; 6297 : 
; 6298 :             memset( frameout, 0, sizeof(frameout) );       // Clear area for ethernet fram

  00bdd	48 8d 84 24 a0
	02 00 00	 lea	 rax, QWORD PTR frameout$[rsp]
  00be5	48 8b f8	 mov	 rdi, rax
  00be8	33 c0		 xor	 eax, eax
  00bea	b9 40 00 00 00	 mov	 ecx, 64			; 00000040H
  00bef	f3 aa		 rep stosb

; 6299 :             pEthFrameOut = (PETHFRM)&frameout[0];

  00bf1	b8 01 00 00 00	 mov	 eax, 1
  00bf6	48 6b c0 00	 imul	 rax, rax, 0
  00bfa	48 8d 84 04 a0
	02 00 00	 lea	 rax, QWORD PTR frameout$[rsp+rax]
  00c02	48 89 84 24 d0
	00 00 00	 mov	 QWORD PTR pEthFrameOut$[rsp], rax

; 6300 :             iEthLenOut = 60;                               // Minimum ethernet frame length

  00c0a	c7 84 24 94 00
	00 00 3c 00 00
	00		 mov	 DWORD PTR iEthLenOut$[rsp], 60 ; 0000003cH

; 6301 : 
; 6302 :             //
; 6303 :             memset( &llcout, 0, sizeof(LLC) );

  00c15	48 8d 84 24 68
	01 00 00	 lea	 rax, QWORD PTR llcout$[rsp]
  00c1d	48 8b f8	 mov	 rdi, rax
  00c20	33 c0		 xor	 eax, eax
  00c22	b9 2e 00 00 00	 mov	 ecx, 46			; 0000002eH
  00c27	f3 aa		 rep stosb

; 6304 :             llcout.hwDSAP    = llc.hwSSAP;                 // Copy LLC inbound SSAP as outbound DSAP

  00c29	0f b7 84 24 4a
	01 00 00	 movzx	 eax, WORD PTR llc$[rsp+18]
  00c31	66 89 84 24 76
	01 00 00	 mov	 WORD PTR llcout$[rsp+14], ax

; 6305 :             llcout.hwSSAP    = llc.hwDSAP;                 // Copy LLC inbound DSAP as outbound SSAP

  00c39	0f b7 84 24 46
	01 00 00	 movzx	 eax, WORD PTR llc$[rsp+14]
  00c41	66 89 84 24 7a
	01 00 00	 mov	 WORD PTR llcout$[rsp+18], ax

; 6306 :             llcout.hwCR      = 1;

  00c49	b8 01 00 00 00	 mov	 eax, 1
  00c4e	66 89 84 24 7c
	01 00 00	 mov	 WORD PTR llcout$[rsp+20], ax

; 6307 :             llcout.hwPF      = 1;

  00c56	b8 01 00 00 00	 mov	 eax, 1
  00c5b	66 89 84 24 82
	01 00 00	 mov	 WORD PTR llcout$[rsp+26], ax

; 6308 :             if (pLCSCONN->fIframe)

  00c63	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR pLCSCONN$[rsp]
  00c6b	8b 40 2c	 mov	 eax, DWORD PTR [rax+44]
  00c6e	83 e0 01	 and	 eax, 1
  00c71	85 c0		 test	 eax, eax
  00c73	74 19		 je	 SHORT $LN72@LCS_Proces

; 6309 :             {
; 6310 :                 llcout.hwNR  = ((pLCSCONN->hwRemoteNS + 1) & 0x7F);

  00c75	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR pLCSCONN$[rsp]
  00c7d	0f b7 40 28	 movzx	 eax, WORD PTR [rax+40]
  00c81	ff c0		 inc	 eax
  00c83	83 e0 7f	 and	 eax, 127		; 0000007fH
  00c86	66 89 84 24 80
	01 00 00	 mov	 WORD PTR llcout$[rsp+24], ax
$LN72@LCS_Proces:

; 6311 :             }
; 6312 :             llcout.hwSS      = SS_Receiver_Ready;

  00c8e	33 c0		 xor	 eax, eax
  00c90	66 89 84 24 84
	01 00 00	 mov	 WORD PTR llcout$[rsp+28], ax

; 6313 :             llcout.hwType    = Type_Supervisory_Frame;

  00c98	b8 02 00 00 00	 mov	 eax, 2
  00c9d	66 89 84 24 94
	01 00 00	 mov	 WORD PTR llcout$[rsp+44], ax

; 6314 : 
; 6315 :             // Construct Ethernet frame
; 6316 :             memcpy( &pEthFrameOut->bDestMAC, &pEthFrame->bSrcMAC, IFHWADDRLEN );  // Copy destination MAC address

  00ca5	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR pEthFrame$[rsp]
  00cad	48 8b bc 24 d0
	00 00 00	 mov	 rdi, QWORD PTR pEthFrameOut$[rsp]
  00cb5	48 8d 70 06	 lea	 rsi, QWORD PTR [rax+6]
  00cb9	b9 06 00 00 00	 mov	 ecx, 6
  00cbe	f3 a4		 rep movsb

; 6317 :             memcpy( &pEthFrameOut->bSrcMAC, &pEthFrame->bDestMAC, IFHWADDRLEN );  // Copy source MAC address

  00cc0	48 8b 84 24 d0
	00 00 00	 mov	 rax, QWORD PTR pEthFrameOut$[rsp]
  00cc8	48 8d 78 06	 lea	 rdi, QWORD PTR [rax+6]
  00ccc	48 8b b4 24 b0
	00 00 00	 mov	 rsi, QWORD PTR pEthFrame$[rsp]
  00cd4	b9 06 00 00 00	 mov	 ecx, 6
  00cd9	f3 a4		 rep movsb

; 6318 :             iLPDULenOut = BuildLLC( &llcout, pEthFrameOut->bData);                // Build LLC PDU

  00cdb	48 8b 84 24 d0
	00 00 00	 mov	 rax, QWORD PTR pEthFrameOut$[rsp]
  00ce3	48 83 c0 0e	 add	 rax, 14
  00ce7	48 8b d0	 mov	 rdx, rax
  00cea	48 8d 8c 24 68
	01 00 00	 lea	 rcx, QWORD PTR llcout$[rsp]
  00cf2	e8 00 00 00 00	 call	 BuildLLC
  00cf7	89 84 24 d8 00
	00 00		 mov	 DWORD PTR iLPDULenOut$[rsp], eax

; 6319 :             STORE_HW( pEthFrameOut->hwEthernetType, (U16)iLPDULenOut );           // Set data length

  00cfe	0f b7 8c 24 d8
	00 00 00	 movzx	 ecx, WORD PTR iLPDULenOut$[rsp]
  00d06	e8 00 00 00 00	 call	 _byteswap_ushort
  00d0b	48 8b 8c 24 d0
	00 00 00	 mov	 rcx, QWORD PTR pEthFrameOut$[rsp]
  00d13	48 83 c1 0c	 add	 rcx, 12
  00d17	0f b7 d0	 movzx	 edx, ax
  00d1a	e8 00 00 00 00	 call	 store_hw_noswap

; 6320 : 
; 6321 :             // Trace Ethernet frame before sending to TAP device
; 6322 :             if (pLCSBLK->fDebug)

  00d1f	48 8b 84 24 c8
	00 00 00	 mov	 rax, QWORD PTR pLCSBLK$[rsp]
  00d27	8b 40 18	 mov	 eax, DWORD PTR [rax+24]
  00d2a	83 e0 01	 and	 eax, 1
  00d2d	85 c0		 test	 eax, eax
  00d2f	0f 84 19 01 00
	00		 je	 $LN73@LCS_Proces

; 6323 :             {
; 6324 :                 // "%1d:%04X %s: port %2.2X: Send frame of size %d bytes (with %s packet) to device %s"
; 6325 :                 WRMSG(HHC00983, "D", SSID_TO_LCSS(pDEVBLK->ssid), pDEVBLK->devnum, pDEVBLK->typname,

  00d35	48 8b 84 24 10
	03 00 00	 mov	 rax, QWORD PTR pLCSPORT$[rsp]
  00d3d	48 05 48 01 00
	00		 add	 rax, 328		; 00000148H
  00d43	48 89 84 24 28
	01 00 00	 mov	 QWORD PTR tv589[rsp], rax
  00d4b	48 8b 8c 24 18
	03 00 00	 mov	 rcx, QWORD PTR pLCSDEV$[rsp]
  00d53	0f b6 49 23	 movzx	 ecx, BYTE PTR [rcx+35]
  00d57	89 8c 24 10 01
	00 00		 mov	 DWORD PTR tv594[rsp], ecx
  00d5e	48 8b 94 24 a0
	00 00 00	 mov	 rdx, QWORD PTR pDEVBLK$[rsp]
  00d66	0f b7 52 48	 movzx	 edx, WORD PTR [rdx+72]
  00d6a	89 94 24 f8 00
	00 00		 mov	 DWORD PTR tv599[rsp], edx
  00d71	48 8b bc 24 a0
	00 00 00	 mov	 rdi, QWORD PTR pDEVBLK$[rsp]
  00d79	0f b7 7f 44	 movzx	 edi, WORD PTR [rdi+68]
  00d7d	d1 ff		 sar	 edi, 1
  00d7f	b9 01 00 00 00	 mov	 ecx, 1
  00d84	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  00d8a	48 8b 8c 24 28
	01 00 00	 mov	 rcx, QWORD PTR tv589[rsp]
  00d92	48 89 4c 24 68	 mov	 QWORD PTR [rsp+104], rcx
  00d97	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG175164
  00d9e	48 89 4c 24 60	 mov	 QWORD PTR [rsp+96], rcx
  00da3	8b 8c 24 94 00
	00 00		 mov	 ecx, DWORD PTR iEthLenOut$[rsp]
  00daa	89 4c 24 58	 mov	 DWORD PTR [rsp+88], ecx
  00dae	8b 8c 24 10 01
	00 00		 mov	 ecx, DWORD PTR tv594[rsp]
  00db5	89 4c 24 50	 mov	 DWORD PTR [rsp+80], ecx
  00db9	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR pDEVBLK$[rsp]
  00dc1	48 8b 49 50	 mov	 rcx, QWORD PTR [rcx+80]
  00dc5	48 89 4c 24 48	 mov	 QWORD PTR [rsp+72], rcx
  00dca	8b 8c 24 f8 00
	00 00		 mov	 ecx, DWORD PTR tv599[rsp]
  00dd1	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  00dd5	89 7c 24 38	 mov	 DWORD PTR [rsp+56], edi
  00dd9	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG175165
  00de0	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  00de5	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG175166
  00dec	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00df1	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00df6	41 b9 03 00 00
	00		 mov	 r9d, 3
  00dfc	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG175167
  00e03	ba b6 18 00 00	 mov	 edx, 6326		; 000018b6H
  00e08	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG175168
  00e0f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 6326 :                                      pLCSDEV->bPort, iEthLenOut, "802.3 SNA", pLCSPORT->szNetIfName );
; 6327 :                 net_data_trace( pDEVBLK, (BYTE*)pEthFrameOut, iEthLenOut, FROM_GUEST, 'D', "eth frame", 0 );

  00e15	c7 44 24 30 00
	00 00 00	 mov	 DWORD PTR [rsp+48], 0
  00e1d	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG175169
  00e24	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  00e29	c6 44 24 20 44	 mov	 BYTE PTR [rsp+32], 68	; 00000044H
  00e2e	41 b1 3c	 mov	 r9b, 60			; 0000003cH
  00e31	44 8b 84 24 94
	00 00 00	 mov	 r8d, DWORD PTR iEthLenOut$[rsp]
  00e39	48 8b 94 24 d0
	00 00 00	 mov	 rdx, QWORD PTR pEthFrameOut$[rsp]
  00e41	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR pDEVBLK$[rsp]
  00e49	e8 00 00 00 00	 call	 net_data_trace
$LN73@LCS_Proces:

; 6328 :             }
; 6329 : 
; 6330 :             // Write the Ethernet frame to the TAP device
; 6331 :             if (TUNTAP_Write( pDEVBLK->fd, (BYTE*)pEthFrameOut, iEthLenOut ) == iEthLenOut)

  00e4e	44 8b 84 24 94
	00 00 00	 mov	 r8d, DWORD PTR iEthLenOut$[rsp]
  00e56	48 8b 94 24 d0
	00 00 00	 mov	 rdx, QWORD PTR pEthFrameOut$[rsp]
  00e5e	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR pDEVBLK$[rsp]
  00e66	8b 88 ac 01 00
	00		 mov	 ecx, DWORD PTR [rax+428]
  00e6c	e8 00 00 00 00	 call	 tt32_write
  00e71	3b 84 24 94 00
	00 00		 cmp	 eax, DWORD PTR iEthLenOut$[rsp]
  00e78	0f 85 b9 00 00
	00		 jne	 $LN74@LCS_Proces

; 6332 :             {
; 6333 :                 if (pLCSPORT->pLCSBLK->fDebug)

  00e7e	48 8b 84 24 10
	03 00 00	 mov	 rax, QWORD PTR pLCSPORT$[rsp]
  00e86	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  00e8a	8b 40 18	 mov	 eax, DWORD PTR [rax+24]
  00e8d	83 e0 01	 and	 eax, 1
  00e90	85 c0		 test	 eax, eax
  00e92	0f 84 9d 00 00
	00		 je	 $LN76@LCS_Proces

; 6334 :                 {
; 6335 :                     snprintf( llcmsg, sizeof(llcmsg), "LCS: LLC supervisory frame sent: CR=%u, SS=%s, PF=%u, NR=%u", llcout.hwCR, "Receiver Ready", llcout.hwPF, llcout.hwNR );

  00e98	0f b7 84 24 80
	01 00 00	 movzx	 eax, WORD PTR llcout$[rsp+24]
  00ea0	0f b7 8c 24 82
	01 00 00	 movzx	 ecx, WORD PTR llcout$[rsp+26]
  00ea8	0f b7 94 24 7c
	01 00 00	 movzx	 edx, WORD PTR llcout$[rsp+20]
  00eb0	89 44 24 30	 mov	 DWORD PTR [rsp+48], eax
  00eb4	89 4c 24 28	 mov	 DWORD PTR [rsp+40], ecx
  00eb8	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG175173
  00ebf	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00ec4	44 8b ca	 mov	 r9d, edx
  00ec7	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG175174
  00ece	ba 00 01 00 00	 mov	 edx, 256		; 00000100H
  00ed3	48 8d 8c 24 a0
	01 00 00	 lea	 rcx, QWORD PTR llcmsg$[rsp]
  00edb	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_snprintf

; 6336 :                     WRMSG(HHC03984, "D", llcmsg );

  00ee1	b9 01 00 00 00	 mov	 ecx, 1
  00ee6	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  00eec	48 8d 8c 24 a0
	01 00 00	 lea	 rcx, QWORD PTR llcmsg$[rsp]
  00ef4	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  00ef9	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG175175
  00f00	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  00f05	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG175176
  00f0c	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00f11	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00f16	41 b9 03 00 00
	00		 mov	 r9d, 3
  00f1c	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG175177
  00f23	ba c0 18 00 00	 mov	 edx, 6336		; 000018c0H
  00f28	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG175178
  00f2f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg
$LN76@LCS_Proces:

; 6337 :                 }
; 6338 :             }

  00f35	eb 59		 jmp	 SHORT $LN75@LCS_Proces
$LN74@LCS_Proces:
$LN23@LCS_Proces:

; 6339 :             else
; 6340 :             {
; 6341 : //??            pLCSDEV->iTuntapErrno = errno;
; 6342 : //??            pLCSDEV->fTuntapError = TRUE;
; 6343 :                 PTT_TIMING( "*WRITE ERR", 0, iEthLenOut, 1 );

  00f37	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_pttclass
  00f3e	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00f41	48 25 00 00 01
	00		 and	 rax, 65536		; 00010000H
  00f47	48 85 c0	 test	 rax, rax
  00f4a	74 3e		 je	 SHORT $LN77@LCS_Proces
  00f4c	48 63 84 24 94
	00 00 00	 movsxd	 rax, DWORD PTR iEthLenOut$[rsp]
  00f54	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR [rsp+48], 0
  00f5d	48 c7 44 24 28
	01 00 00 00	 mov	 QWORD PTR [rsp+40], 1
  00f66	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG175180
  00f6d	48 89 4c 24 20	 mov	 QWORD PTR [rsp+32], rcx
  00f72	4c 8b c8	 mov	 r9, rax
  00f75	45 33 c0	 xor	 r8d, r8d
  00f78	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG175181
  00f7f	b9 00 00 01 00	 mov	 ecx, 65536		; 00010000H
  00f84	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ptt_pthread_trace
$LN77@LCS_Proces:
  00f8a	33 c0		 xor	 eax, eax
  00f8c	85 c0		 test	 eax, eax
  00f8e	75 a7		 jne	 SHORT $LN23@LCS_Proces
$LN75@LCS_Proces:

; 6344 :             }
; 6345 : 
; 6346 :             break;

  00f90	e9 72 01 00 00	 jmp	 $LN19@LCS_Proces
$LN78@LCS_Proces:

; 6347 : 
; 6348 :         // Supervisory Frame: Receiver Not Ready.
; 6349 :         case SS_Receiver_Not_Ready:
; 6350 : 
; 6351 :             if (pLCSBLK->fDebug)

  00f95	48 8b 84 24 c8
	00 00 00	 mov	 rax, QWORD PTR pLCSBLK$[rsp]
  00f9d	8b 40 18	 mov	 eax, DWORD PTR [rax+24]
  00fa0	83 e0 01	 and	 eax, 1
  00fa3	85 c0		 test	 eax, eax
  00fa5	0f 84 9d 00 00
	00		 je	 $LN79@LCS_Proces

; 6352 :             {
; 6353 :               snprintf( llcmsg, sizeof(llcmsg), "LCS: LLC supervisory frame received: CR=%u, SS=%s, PF=%u, NR=%u", llc.hwCR, "Receiver Not Ready", llc.hwPF, llc.hwNR );

  00fab	0f b7 84 24 50
	01 00 00	 movzx	 eax, WORD PTR llc$[rsp+24]
  00fb3	0f b7 8c 24 52
	01 00 00	 movzx	 ecx, WORD PTR llc$[rsp+26]
  00fbb	0f b7 94 24 4c
	01 00 00	 movzx	 edx, WORD PTR llc$[rsp+20]
  00fc3	89 44 24 30	 mov	 DWORD PTR [rsp+48], eax
  00fc7	89 4c 24 28	 mov	 DWORD PTR [rsp+40], ecx
  00fcb	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG175184
  00fd2	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00fd7	44 8b ca	 mov	 r9d, edx
  00fda	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG175185
  00fe1	ba 00 01 00 00	 mov	 edx, 256		; 00000100H
  00fe6	48 8d 8c 24 a0
	01 00 00	 lea	 rcx, QWORD PTR llcmsg$[rsp]
  00fee	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_snprintf

; 6354 :               WRMSG(HHC03984, "D", llcmsg );

  00ff4	b9 01 00 00 00	 mov	 ecx, 1
  00ff9	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  00fff	48 8d 8c 24 a0
	01 00 00	 lea	 rcx, QWORD PTR llcmsg$[rsp]
  01007	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  0100c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG175186
  01013	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  01018	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG175187
  0101f	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  01024	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  01029	41 b9 03 00 00
	00		 mov	 r9d, 3
  0102f	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG175188
  01036	ba d2 18 00 00	 mov	 edx, 6354		; 000018d2H
  0103b	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG175189
  01042	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg
$LN79@LCS_Proces:

; 6355 :             }
; 6356 : 
; 6357 :             break;

  01048	e9 ba 00 00 00	 jmp	 $LN19@LCS_Proces
$LN80@LCS_Proces:

; 6358 : 
; 6359 :         // Supervisory Frame: Reject
; 6360 :         case SS_Reject:
; 6361 : 
; 6362 :             if (pLCSBLK->fDebug)

  0104d	48 8b 84 24 c8
	00 00 00	 mov	 rax, QWORD PTR pLCSBLK$[rsp]
  01055	8b 40 18	 mov	 eax, DWORD PTR [rax+24]
  01058	83 e0 01	 and	 eax, 1
  0105b	85 c0		 test	 eax, eax
  0105d	0f 84 9d 00 00
	00		 je	 $LN81@LCS_Proces

; 6363 :             {
; 6364 :               snprintf( llcmsg, sizeof(llcmsg), "LCS: LLC supervisory frame received: CR=%u, SS=%s, PF=%u, NR=%u", llc.hwCR, "Reject", llc.hwPF, llc.hwNR );

  01063	0f b7 84 24 50
	01 00 00	 movzx	 eax, WORD PTR llc$[rsp+24]
  0106b	0f b7 8c 24 52
	01 00 00	 movzx	 ecx, WORD PTR llc$[rsp+26]
  01073	0f b7 94 24 4c
	01 00 00	 movzx	 edx, WORD PTR llc$[rsp+20]
  0107b	89 44 24 30	 mov	 DWORD PTR [rsp+48], eax
  0107f	89 4c 24 28	 mov	 DWORD PTR [rsp+40], ecx
  01083	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG175192
  0108a	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  0108f	44 8b ca	 mov	 r9d, edx
  01092	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG175193
  01099	ba 00 01 00 00	 mov	 edx, 256		; 00000100H
  0109e	48 8d 8c 24 a0
	01 00 00	 lea	 rcx, QWORD PTR llcmsg$[rsp]
  010a6	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_snprintf

; 6365 :               WRMSG(HHC03984, "D", llcmsg );

  010ac	b9 01 00 00 00	 mov	 ecx, 1
  010b1	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  010b7	48 8d 8c 24 a0
	01 00 00	 lea	 rcx, QWORD PTR llcmsg$[rsp]
  010bf	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  010c4	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG175194
  010cb	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  010d0	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG175195
  010d7	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  010dc	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  010e1	41 b9 03 00 00
	00		 mov	 r9d, 3
  010e7	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG175196
  010ee	ba dd 18 00 00	 mov	 edx, 6365		; 000018ddH
  010f3	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG175197
  010fa	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg
$LN81@LCS_Proces:

; 6366 :             }
; 6367 : 
; 6368 :             break;

  01100	eb 05		 jmp	 SHORT $LN19@LCS_Proces
$LN82@LCS_Proces:

; 6369 : 
; 6370 :         // Supervisory Frame: Unknown.
; 6371 :         default:
; 6372 :             goto msg970_return;

  01102	e9 47 1b 00 00	 jmp	 $msg970_return$140
$LN19@LCS_Proces:

; 6373 : 
; 6374 :         }
; 6375 : 
; 6376 :         break;

  01107	e9 49 17 00 00	 jmp	 $LN5@LCS_Proces
$LN83@LCS_Proces:

; 6377 : 
; 6378 :     // Unnumbered Frame.
; 6379 :     case Type_Unnumbered_Frame:
; 6380 : 
; 6381 :         switch (llc.hwM)

  0110c	0f b7 84 24 56
	01 00 00	 movzx	 eax, WORD PTR llc$[rsp+30]
  01114	89 84 24 dc 00
	00 00		 mov	 DWORD PTR tv744[rsp], eax
  0111b	8b 84 24 dc 00
	00 00		 mov	 eax, DWORD PTR tv744[rsp]
  01122	83 e8 03	 sub	 eax, 3
  01125	89 84 24 dc 00
	00 00		 mov	 DWORD PTR tv744[rsp], eax
  0112c	83 bc 24 dc 00
	00 00 19	 cmp	 DWORD PTR tv744[rsp], 25
  01134	0f 87 0f 17 00
	00		 ja	 $LN124@LCS_Proces
  0113a	48 63 84 24 dc
	00 00 00	 movsxd	 rax, DWORD PTR tv744[rsp]
  01142	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__ImageBase
  01149	0f b6 84 01 00
	00 00 00	 movzx	 eax, BYTE PTR $LN138@LCS_Proces[rcx+rax]
  01151	8b 84 81 00 00
	00 00		 mov	 eax, DWORD PTR $LN139@LCS_Proces[rcx+rax*4]
  01158	48 03 c1	 add	 rax, rcx
  0115b	ff e0		 jmp	 rax
$LN84@LCS_Proces:

; 6382 :         {
; 6383 : 
; 6384 :         // Unnumbered Frame: DM Response (B'00011', 0x03, 0x0F or 0x1F).
; 6385 :         case M_DM_Response:
; 6386 : 
; 6387 :             if (pLCSBLK->fDebug)

  0115d	48 8b 84 24 c8
	00 00 00	 mov	 rax, QWORD PTR pLCSBLK$[rsp]
  01165	8b 40 18	 mov	 eax, DWORD PTR [rax+24]
  01168	83 e0 01	 and	 eax, 1
  0116b	85 c0		 test	 eax, eax
  0116d	0f 84 85 00 00
	00		 je	 $LN85@LCS_Proces

; 6388 :             {
; 6389 :               snprintf( llcmsg, sizeof(llcmsg), "LCS: LLC unnumbered frame received: CR=%u, M=%s", llc.hwCR, "DM" );

  01173	0f b7 84 24 4c
	01 00 00	 movzx	 eax, WORD PTR llc$[rsp+20]
  0117b	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG175202
  01182	48 89 4c 24 20	 mov	 QWORD PTR [rsp+32], rcx
  01187	44 8b c8	 mov	 r9d, eax
  0118a	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG175203
  01191	ba 00 01 00 00	 mov	 edx, 256		; 00000100H
  01196	48 8d 8c 24 a0
	01 00 00	 lea	 rcx, QWORD PTR llcmsg$[rsp]
  0119e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_snprintf

; 6390 :               WRMSG(HHC03984, "D", llcmsg );

  011a4	b9 01 00 00 00	 mov	 ecx, 1
  011a9	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  011af	48 8d 8c 24 a0
	01 00 00	 lea	 rcx, QWORD PTR llcmsg$[rsp]
  011b7	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  011bc	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG175204
  011c3	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  011c8	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG175205
  011cf	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  011d4	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  011d9	41 b9 03 00 00
	00		 mov	 r9d, 3
  011df	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG175206
  011e6	ba f6 18 00 00	 mov	 edx, 6390		; 000018f6H
  011eb	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG175207
  011f2	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg
$LN85@LCS_Proces:

; 6391 :             }
; 6392 : 
; 6393 :             break;

  011f8	e9 51 16 00 00	 jmp	 $LN24@LCS_Proces
$LN86@LCS_Proces:

; 6394 : 
; 6395 :         // Unnumbered Frame: DISC Command (B'01000', 0x10, 0x43 or 0x53).
; 6396 :         case M_DISC_Command:
; 6397 : 
; 6398 :             if (pLCSBLK->fDebug)

  011fd	48 8b 84 24 c8
	00 00 00	 mov	 rax, QWORD PTR pLCSBLK$[rsp]
  01205	8b 40 18	 mov	 eax, DWORD PTR [rax+24]
  01208	83 e0 01	 and	 eax, 1
  0120b	85 c0		 test	 eax, eax
  0120d	0f 84 85 00 00
	00		 je	 $LN87@LCS_Proces

; 6399 :             {
; 6400 :               snprintf( llcmsg, sizeof(llcmsg), "LCS: LLC unnumbered frame received: CR=%u, M=%s", llc.hwCR, "DISC" );

  01213	0f b7 84 24 4c
	01 00 00	 movzx	 eax, WORD PTR llc$[rsp+20]
  0121b	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG175210
  01222	48 89 4c 24 20	 mov	 QWORD PTR [rsp+32], rcx
  01227	44 8b c8	 mov	 r9d, eax
  0122a	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG175211
  01231	ba 00 01 00 00	 mov	 edx, 256		; 00000100H
  01236	48 8d 8c 24 a0
	01 00 00	 lea	 rcx, QWORD PTR llcmsg$[rsp]
  0123e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_snprintf

; 6401 :               WRMSG(HHC03984, "D", llcmsg );

  01244	b9 01 00 00 00	 mov	 ecx, 1
  01249	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  0124f	48 8d 8c 24 a0
	01 00 00	 lea	 rcx, QWORD PTR llcmsg$[rsp]
  01257	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  0125c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG175212
  01263	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  01268	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG175213
  0126f	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  01274	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  01279	41 b9 03 00 00
	00		 mov	 r9d, 3
  0127f	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG175214
  01286	ba 01 19 00 00	 mov	 edx, 6401		; 00001901H
  0128b	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG175215
  01292	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg
$LN87@LCS_Proces:

; 6402 :             }
; 6403 : 
; 6404 :             // Find the connection block.
; 6405 :             pLCSCONN = find_connection_by_remote_mac( pLCSDEV, &pEthFrame->bSrcMAC );

  01298	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR pEthFrame$[rsp]
  012a0	48 83 c0 06	 add	 rax, 6
  012a4	48 8b d0	 mov	 rdx, rax
  012a7	48 8b 8c 24 18
	03 00 00	 mov	 rcx, QWORD PTR pLCSDEV$[rsp]
  012af	e8 00 00 00 00	 call	 find_connection_by_remote_mac
  012b4	48 89 84 24 80
	00 00 00	 mov	 QWORD PTR pLCSCONN$[rsp], rax

; 6406 :             if (!pLCSCONN)

  012bc	48 83 bc 24 80
	00 00 00 00	 cmp	 QWORD PTR pLCSCONN$[rsp], 0
  012c5	75 58		 jne	 SHORT $LN88@LCS_Proces

; 6407 :             {
; 6408 :                 WRMSG( HHC03984, "W", "LCSCONN not found");

  012c7	b9 01 00 00 00	 mov	 ecx, 1
  012cc	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  012d2	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG175217
  012d9	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  012de	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG175218
  012e5	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  012ea	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG175219
  012f1	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  012f6	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  012fb	41 b9 03 00 00
	00		 mov	 r9d, 3
  01301	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG175220
  01308	ba 08 19 00 00	 mov	 edx, 6408		; 00001908H
  0130d	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG175221
  01314	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 6409 :                 /* FixMe! Need a proper error message here! */
; 6410 :                 break;

  0131a	e9 2f 15 00 00	 jmp	 $LN24@LCS_Proces
$LN88@LCS_Proces:

; 6411 :             }
; 6412 : 
; 6413 :             // Obtain a buffer in which to construct the data to be passed to VTAM.
; 6414 :             pLCSIBH = alloc_lcs_buffer( pLCSDEV, ( INBOUND_4C0B_SIZE * 2 ) );

  0131f	ba 40 00 00 00	 mov	 edx, 64			; 00000040H
  01324	48 8b 8c 24 18
	03 00 00	 mov	 rcx, QWORD PTR pLCSDEV$[rsp]
  0132c	e8 00 00 00 00	 call	 alloc_lcs_buffer
  01331	48 89 84 24 88
	00 00 00	 mov	 QWORD PTR pLCSIBH$[rsp], rax

; 6415 : 
; 6416 :             memcpy( &pLCSIBH->bData, Inbound_4C0B, INBOUND_4C0B_SIZE );

  01339	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR pLCSIBH$[rsp]
  01341	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:?Inbound_4C0B@?1??LCS_ProcessAccepted_SNA@@9@9
  01348	48 8d 78 10	 lea	 rdi, QWORD PTR [rax+16]
  0134c	48 8b f1	 mov	 rsi, rcx
  0134f	b9 20 00 00 00	 mov	 ecx, 32			; 00000020H
  01354	f3 a4		 rep movsb

; 6417 :             pLCSIBH->iDataLen = INBOUND_4C0B_SIZE;

  01356	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR pLCSIBH$[rsp]
  0135e	c7 40 0c 20 00
	00 00		 mov	 DWORD PTR [rax+12], 32	; 00000020H

; 6418 : 
; 6419 :             pLCSHDR = (PLCSHDR)&pLCSIBH->bData;

  01365	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR pLCSIBH$[rsp]
  0136d	48 83 c0 10	 add	 rax, 16
  01371	48 89 84 24 c0
	00 00 00	 mov	 QWORD PTR pLCSHDR$[rsp], rax

; 6420 :             pLCSBAF1 = (PLCSBAF1)( (BYTE*)pLCSHDR + sizeof(LCSHDR) );

  01379	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR pLCSHDR$[rsp]
  01381	48 83 c0 04	 add	 rax, 4
  01385	48 89 84 24 98
	00 00 00	 mov	 QWORD PTR pLCSBAF1$[rsp], rax

; 6421 : //          FETCH_HW( hwLenBaf1, pLCSBAF1->hwLenBaf1 );
; 6422 : //          FETCH_HW( hwLenBaf2, pLCSBAF1->hwLenBaf2 );
; 6423 : //          pLCSBAF2 = (PLCSBAF2)( (BYTE*)pLCSBAF1 + hwLenBaf1 );
; 6424 : 
; 6425 :             //
; 6426 :             memcpy( pLCSBAF1->bTokenA, &pLCSCONN->bInToken, sizeof(pLCSCONN->bInToken) );  // Set Inbound token

  0138d	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR pLCSBAF1$[rsp]
  01395	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR pLCSCONN$[rsp]
  0139d	8b 49 08	 mov	 ecx, DWORD PTR [rcx+8]
  013a0	89 48 08	 mov	 DWORD PTR [rax+8], ecx

; 6427 : 
; 6428 :             // Add the buffer containing the XID response to the chain.
; 6429 :             add_lcs_buffer_to_chain( pLCSDEV, pLCSIBH );

  013a3	48 8b 94 24 88
	00 00 00	 mov	 rdx, QWORD PTR pLCSIBH$[rsp]
  013ab	48 8b 8c 24 18
	03 00 00	 mov	 rcx, QWORD PTR pLCSDEV$[rsp]
  013b3	e8 00 00 00 00	 call	 add_lcs_buffer_to_chain

; 6430 : 
; 6431 :             fAttnRequired = TRUE;

  013b8	c6 44 24 74 01	 mov	 BYTE PTR fAttnRequired$[rsp], 1

; 6432 : 
; 6433 :             break;

  013bd	e9 8c 14 00 00	 jmp	 $LN24@LCS_Proces
$LN89@LCS_Proces:

; 6434 : 
; 6435 :         // Unnumbered Frame: UA Response (B'01100', 0x18, 0x63 or 0x73).
; 6436 :         case M_UA_Response:
; 6437 : 
; 6438 :             if (pLCSBLK->fDebug)

  013c2	48 8b 84 24 c8
	00 00 00	 mov	 rax, QWORD PTR pLCSBLK$[rsp]
  013ca	8b 40 18	 mov	 eax, DWORD PTR [rax+24]
  013cd	83 e0 01	 and	 eax, 1
  013d0	85 c0		 test	 eax, eax
  013d2	0f 84 85 00 00
	00		 je	 $LN90@LCS_Proces

; 6439 :             {
; 6440 :               snprintf( llcmsg, sizeof(llcmsg), "LCS: LLC unnumbered frame received: CR=%u, M=%s", llc.hwCR, "UA" );

  013d8	0f b7 84 24 4c
	01 00 00	 movzx	 eax, WORD PTR llc$[rsp+20]
  013e0	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG175224
  013e7	48 89 4c 24 20	 mov	 QWORD PTR [rsp+32], rcx
  013ec	44 8b c8	 mov	 r9d, eax
  013ef	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG175225
  013f6	ba 00 01 00 00	 mov	 edx, 256		; 00000100H
  013fb	48 8d 8c 24 a0
	01 00 00	 lea	 rcx, QWORD PTR llcmsg$[rsp]
  01403	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_snprintf

; 6441 :               WRMSG(HHC03984, "D", llcmsg );

  01409	b9 01 00 00 00	 mov	 ecx, 1
  0140e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  01414	48 8d 8c 24 a0
	01 00 00	 lea	 rcx, QWORD PTR llcmsg$[rsp]
  0141c	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  01421	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG175226
  01428	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  0142d	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG175227
  01434	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  01439	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  0143e	41 b9 03 00 00
	00		 mov	 r9d, 3
  01444	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG175228
  0144b	ba 29 19 00 00	 mov	 edx, 6441		; 00001929H
  01450	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG175229
  01457	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg
$LN90@LCS_Proces:

; 6442 :             }
; 6443 : 
; 6444 :             // Find the connection block.
; 6445 :             pLCSCONN = find_connection_by_remote_mac( pLCSDEV, &pEthFrame->bSrcMAC );

  0145d	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR pEthFrame$[rsp]
  01465	48 83 c0 06	 add	 rax, 6
  01469	48 8b d0	 mov	 rdx, rax
  0146c	48 8b 8c 24 18
	03 00 00	 mov	 rcx, QWORD PTR pLCSDEV$[rsp]
  01474	e8 00 00 00 00	 call	 find_connection_by_remote_mac
  01479	48 89 84 24 80
	00 00 00	 mov	 QWORD PTR pLCSCONN$[rsp], rax

; 6446 :             if (!pLCSCONN)

  01481	48 83 bc 24 80
	00 00 00 00	 cmp	 QWORD PTR pLCSCONN$[rsp], 0
  0148a	75 58		 jne	 SHORT $LN91@LCS_Proces

; 6447 :             {
; 6448 :                 WRMSG( HHC03984, "W", "LCSCONN not found");

  0148c	b9 01 00 00 00	 mov	 ecx, 1
  01491	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  01497	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG175231
  0149e	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  014a3	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG175232
  014aa	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  014af	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG175233
  014b6	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  014bb	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  014c0	41 b9 03 00 00
	00		 mov	 r9d, 3
  014c6	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG175234
  014cd	ba 30 19 00 00	 mov	 edx, 6448		; 00001930H
  014d2	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG175235
  014d9	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 6449 :                 /* FixMe! Need a proper error message here! */
; 6450 :                 break;

  014df	e9 6a 13 00 00	 jmp	 $LN24@LCS_Proces
$LN91@LCS_Proces:

; 6451 :             }
; 6452 : 
; 6453 :             // Obtain a buffer in which to construct the data to be passed to VTAM.
; 6454 :             pLCSIBH = alloc_lcs_buffer( pLCSDEV, ( INBOUND_CD00_SIZE * 2 ) );

  014e4	ba 40 00 00 00	 mov	 edx, 64			; 00000040H
  014e9	48 8b 8c 24 18
	03 00 00	 mov	 rcx, QWORD PTR pLCSDEV$[rsp]
  014f1	e8 00 00 00 00	 call	 alloc_lcs_buffer
  014f6	48 89 84 24 88
	00 00 00	 mov	 QWORD PTR pLCSIBH$[rsp], rax

; 6455 : 
; 6456 :             memcpy( &pLCSIBH->bData, Inbound_CD00, INBOUND_CD00_SIZE );

  014fe	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR pLCSIBH$[rsp]
  01506	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:?Inbound_CD00@?1??LCS_ProcessAccepted_SNA@@9@9
  0150d	48 8d 78 10	 lea	 rdi, QWORD PTR [rax+16]
  01511	48 8b f1	 mov	 rsi, rcx
  01514	b9 20 00 00 00	 mov	 ecx, 32			; 00000020H
  01519	f3 a4		 rep movsb

; 6457 :             pLCSIBH->iDataLen = INBOUND_CD00_SIZE;

  0151b	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR pLCSIBH$[rsp]
  01523	c7 40 0c 20 00
	00 00		 mov	 DWORD PTR [rax+12], 32	; 00000020H

; 6458 : 
; 6459 :             pLCSHDR = (PLCSHDR)&pLCSIBH->bData;

  0152a	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR pLCSIBH$[rsp]
  01532	48 83 c0 10	 add	 rax, 16
  01536	48 89 84 24 c0
	00 00 00	 mov	 QWORD PTR pLCSHDR$[rsp], rax

; 6460 :             pLCSBAF1 = (PLCSBAF1)( (BYTE*)pLCSHDR + sizeof(LCSHDR) );

  0153e	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR pLCSHDR$[rsp]
  01546	48 83 c0 04	 add	 rax, 4
  0154a	48 89 84 24 98
	00 00 00	 mov	 QWORD PTR pLCSBAF1$[rsp], rax

; 6461 :             FETCH_HW( hwLenBaf1, pLCSBAF1->hwLenBaf1 );

  01552	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR pLCSBAF1$[rsp]
  0155a	48 8b c8	 mov	 rcx, rax
  0155d	e8 00 00 00 00	 call	 fetch_hw_noswap
  01562	0f b7 c8	 movzx	 ecx, ax
  01565	e8 00 00 00 00	 call	 _byteswap_ushort
  0156a	66 89 84 24 90
	00 00 00	 mov	 WORD PTR hwLenBaf1$[rsp], ax

; 6462 :             FETCH_HW( hwLenBaf2, pLCSBAF1->hwLenBaf2 );

  01572	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR pLCSBAF1$[rsp]
  0157a	48 83 c0 04	 add	 rax, 4
  0157e	48 8b c8	 mov	 rcx, rax
  01581	e8 00 00 00 00	 call	 fetch_hw_noswap
  01586	0f b7 c8	 movzx	 ecx, ax
  01589	e8 00 00 00 00	 call	 _byteswap_ushort
  0158e	66 89 44 24 78	 mov	 WORD PTR hwLenBaf2$[rsp], ax

; 6463 :             pLCSBAF2 = (PLCSBAF2)( (BYTE*)pLCSBAF1 + hwLenBaf1 );

  01593	0f b7 84 24 90
	00 00 00	 movzx	 eax, WORD PTR hwLenBaf1$[rsp]
  0159b	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR pLCSBAF1$[rsp]
  015a3	48 03 c8	 add	 rcx, rax
  015a6	48 8b c1	 mov	 rax, rcx
  015a9	48 89 84 24 b8
	00 00 00	 mov	 QWORD PTR pLCSBAF2$[rsp], rax

; 6464 : 
; 6465 :             //
; 6466 :             memcpy( pLCSBAF1->bTokenA, &pLCSCONN->bInToken, sizeof(pLCSCONN->bInToken) );  // Set Inbound token

  015b1	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR pLCSBAF1$[rsp]
  015b9	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR pLCSCONN$[rsp]
  015c1	8b 49 08	 mov	 ecx, DWORD PTR [rcx+8]
  015c4	89 48 08	 mov	 DWORD PTR [rax+8], ecx

; 6467 : 
; 6468 :             //
; 6469 :             STORE_HW( pLCSBAF2->hwSeqNum, pLCSCONN->hwDataSeqNum );

  015c7	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR pLCSCONN$[rsp]
  015cf	0f b7 48 22	 movzx	 ecx, WORD PTR [rax+34]
  015d3	e8 00 00 00 00	 call	 _byteswap_ushort
  015d8	48 8b 8c 24 b8
	00 00 00	 mov	 rcx, QWORD PTR pLCSBAF2$[rsp]
  015e0	48 ff c1	 inc	 rcx
  015e3	0f b7 d0	 movzx	 edx, ax
  015e6	e8 00 00 00 00	 call	 store_hw_noswap

; 6470 :             pLCSCONN->hwDataSeqNum++;

  015eb	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR pLCSCONN$[rsp]
  015f3	0f b7 40 22	 movzx	 eax, WORD PTR [rax+34]
  015f7	66 ff c0	 inc	 ax
  015fa	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR pLCSCONN$[rsp]
  01602	66 89 41 22	 mov	 WORD PTR [rcx+34], ax

; 6471 : 
; 6472 :             // Add the buffer containing the XID response to the chain.
; 6473 :             add_lcs_buffer_to_chain( pLCSDEV, pLCSIBH );

  01606	48 8b 94 24 88
	00 00 00	 mov	 rdx, QWORD PTR pLCSIBH$[rsp]
  0160e	48 8b 8c 24 18
	03 00 00	 mov	 rcx, QWORD PTR pLCSDEV$[rsp]
  01616	e8 00 00 00 00	 call	 add_lcs_buffer_to_chain

; 6474 : 
; 6475 :             fAttnRequired = TRUE;

  0161b	c6 44 24 74 01	 mov	 BYTE PTR fAttnRequired$[rsp], 1

; 6476 : 
; 6477 :             break;

  01620	e9 29 12 00 00	 jmp	 $LN24@LCS_Proces
$LN92@LCS_Proces:

; 6478 : 
; 6479 : 
; 6480 :         // Unnumbered Frame: SABME Command (B'01111', 0x1B, 0x6F or 0x7F).
; 6481 :         case M_SABME_Command:
; 6482 : 
; 6483 :             if (pLCSBLK->fDebug)

  01625	48 8b 84 24 c8
	00 00 00	 mov	 rax, QWORD PTR pLCSBLK$[rsp]
  0162d	8b 40 18	 mov	 eax, DWORD PTR [rax+24]
  01630	83 e0 01	 and	 eax, 1
  01633	85 c0		 test	 eax, eax
  01635	0f 84 85 00 00
	00		 je	 $LN93@LCS_Proces

; 6484 :             {
; 6485 :               snprintf( llcmsg, sizeof(llcmsg), "LCS: LLC unnumbered frame received: CR=%u, M=%s", llc.hwCR, "SABME" );

  0163b	0f b7 84 24 4c
	01 00 00	 movzx	 eax, WORD PTR llc$[rsp+20]
  01643	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG175238
  0164a	48 89 4c 24 20	 mov	 QWORD PTR [rsp+32], rcx
  0164f	44 8b c8	 mov	 r9d, eax
  01652	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG175239
  01659	ba 00 01 00 00	 mov	 edx, 256		; 00000100H
  0165e	48 8d 8c 24 a0
	01 00 00	 lea	 rcx, QWORD PTR llcmsg$[rsp]
  01666	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_snprintf

; 6486 :               WRMSG(HHC03984, "D", llcmsg );

  0166c	b9 01 00 00 00	 mov	 ecx, 1
  01671	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  01677	48 8d 8c 24 a0
	01 00 00	 lea	 rcx, QWORD PTR llcmsg$[rsp]
  0167f	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  01684	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG175240
  0168b	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  01690	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG175241
  01697	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  0169c	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  016a1	41 b9 03 00 00
	00		 mov	 r9d, 3
  016a7	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG175242
  016ae	ba 56 19 00 00	 mov	 edx, 6486		; 00001956H
  016b3	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG175243
  016ba	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg
$LN93@LCS_Proces:

; 6487 :             }
; 6488 : 
; 6489 :             // Find the connection block.
; 6490 :             pLCSCONN = find_connection_by_remote_mac( pLCSDEV, &pEthFrame->bSrcMAC );

  016c0	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR pEthFrame$[rsp]
  016c8	48 83 c0 06	 add	 rax, 6
  016cc	48 8b d0	 mov	 rdx, rax
  016cf	48 8b 8c 24 18
	03 00 00	 mov	 rcx, QWORD PTR pLCSDEV$[rsp]
  016d7	e8 00 00 00 00	 call	 find_connection_by_remote_mac
  016dc	48 89 84 24 80
	00 00 00	 mov	 QWORD PTR pLCSCONN$[rsp], rax

; 6491 :             if (!pLCSCONN)

  016e4	48 83 bc 24 80
	00 00 00 00	 cmp	 QWORD PTR pLCSCONN$[rsp], 0
  016ed	75 58		 jne	 SHORT $LN94@LCS_Proces

; 6492 :             {
; 6493 :                 WRMSG( HHC03984, "W", "LCSCONN not found");

  016ef	b9 01 00 00 00	 mov	 ecx, 1
  016f4	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  016fa	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG175245
  01701	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  01706	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG175246
  0170d	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  01712	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG175247
  01719	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  0171e	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  01723	41 b9 03 00 00
	00		 mov	 r9d, 3
  01729	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG175248
  01730	ba 5d 19 00 00	 mov	 edx, 6493		; 0000195dH
  01735	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG175249
  0173c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 6494 :                 /* FixMe! Need a proper error message here! */
; 6495 :                 break;

  01742	e9 07 11 00 00	 jmp	 $LN24@LCS_Proces
$LN94@LCS_Proces:

; 6496 :             }
; 6497 : 
; 6498 :             // Obtain a buffer in which to construct the data to be passed to VTAM.
; 6499 :             pLCSIBH = alloc_lcs_buffer( pLCSDEV, ( INBOUND_4D00_SIZE * 2 ) );

  01747	ba 30 00 00 00	 mov	 edx, 48			; 00000030H
  0174c	48 8b 8c 24 18
	03 00 00	 mov	 rcx, QWORD PTR pLCSDEV$[rsp]
  01754	e8 00 00 00 00	 call	 alloc_lcs_buffer
  01759	48 89 84 24 88
	00 00 00	 mov	 QWORD PTR pLCSIBH$[rsp], rax

; 6500 : 
; 6501 :             memcpy( &pLCSIBH->bData, Inbound_4D00, INBOUND_4D00_SIZE );

  01761	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR pLCSIBH$[rsp]
  01769	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:?Inbound_4D00@?1??LCS_ProcessAccepted_SNA@@9@9
  01770	48 8d 78 10	 lea	 rdi, QWORD PTR [rax+16]
  01774	48 8b f1	 mov	 rsi, rcx
  01777	b9 18 00 00 00	 mov	 ecx, 24
  0177c	f3 a4		 rep movsb

; 6502 :             pLCSIBH->iDataLen = INBOUND_4D00_SIZE;

  0177e	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR pLCSIBH$[rsp]
  01786	c7 40 0c 18 00
	00 00		 mov	 DWORD PTR [rax+12], 24

; 6503 : 
; 6504 :             pLCSHDR = (PLCSHDR)&pLCSIBH->bData;

  0178d	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR pLCSIBH$[rsp]
  01795	48 83 c0 10	 add	 rax, 16
  01799	48 89 84 24 c0
	00 00 00	 mov	 QWORD PTR pLCSHDR$[rsp], rax

; 6505 :             pLCSBAF1 = (PLCSBAF1)( (BYTE*)pLCSHDR + sizeof(LCSHDR) );

  017a1	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR pLCSHDR$[rsp]
  017a9	48 83 c0 04	 add	 rax, 4
  017ad	48 89 84 24 98
	00 00 00	 mov	 QWORD PTR pLCSBAF1$[rsp], rax

; 6506 :             FETCH_HW( hwLenBaf1, pLCSBAF1->hwLenBaf1 );

  017b5	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR pLCSBAF1$[rsp]
  017bd	48 8b c8	 mov	 rcx, rax
  017c0	e8 00 00 00 00	 call	 fetch_hw_noswap
  017c5	0f b7 c8	 movzx	 ecx, ax
  017c8	e8 00 00 00 00	 call	 _byteswap_ushort
  017cd	66 89 84 24 90
	00 00 00	 mov	 WORD PTR hwLenBaf1$[rsp], ax

; 6507 :             FETCH_HW( hwLenBaf2, pLCSBAF1->hwLenBaf2 );

  017d5	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR pLCSBAF1$[rsp]
  017dd	48 83 c0 04	 add	 rax, 4
  017e1	48 8b c8	 mov	 rcx, rax
  017e4	e8 00 00 00 00	 call	 fetch_hw_noswap
  017e9	0f b7 c8	 movzx	 ecx, ax
  017ec	e8 00 00 00 00	 call	 _byteswap_ushort
  017f1	66 89 44 24 78	 mov	 WORD PTR hwLenBaf2$[rsp], ax

; 6508 :             pLCSBAF2 = (PLCSBAF2)( (BYTE*)pLCSBAF1 + hwLenBaf1 );

  017f6	0f b7 84 24 90
	00 00 00	 movzx	 eax, WORD PTR hwLenBaf1$[rsp]
  017fe	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR pLCSBAF1$[rsp]
  01806	48 03 c8	 add	 rcx, rax
  01809	48 8b c1	 mov	 rax, rcx
  0180c	48 89 84 24 b8
	00 00 00	 mov	 QWORD PTR pLCSBAF2$[rsp], rax

; 6509 : 
; 6510 :             //
; 6511 :             memcpy( pLCSBAF1->bTokenA, &pLCSCONN->bInToken, sizeof(pLCSCONN->bInToken) );  // Set Inbound token

  01814	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR pLCSBAF1$[rsp]
  0181c	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR pLCSCONN$[rsp]
  01824	8b 49 08	 mov	 ecx, DWORD PTR [rcx+8]
  01827	89 48 08	 mov	 DWORD PTR [rax+8], ecx

; 6512 : 
; 6513 :             //
; 6514 :             STORE_HW( pLCSBAF2->hwSeqNum, pLCSCONN->hwDataSeqNum );

  0182a	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR pLCSCONN$[rsp]
  01832	0f b7 48 22	 movzx	 ecx, WORD PTR [rax+34]
  01836	e8 00 00 00 00	 call	 _byteswap_ushort
  0183b	48 8b 8c 24 b8
	00 00 00	 mov	 rcx, QWORD PTR pLCSBAF2$[rsp]
  01843	48 ff c1	 inc	 rcx
  01846	0f b7 d0	 movzx	 edx, ax
  01849	e8 00 00 00 00	 call	 store_hw_noswap

; 6515 : //??        pLCSCONN->hwDataSeqNum++;
; 6516 : 
; 6517 :             memcpy( &pLCSBAF2->bByte03, &pLCSCONN->bOutToken, sizeof(pLCSCONN->bOutToken) ); // Outbound token

  0184e	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR pLCSBAF2$[rsp]
  01856	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR pLCSCONN$[rsp]
  0185e	8b 49 0c	 mov	 ecx, DWORD PTR [rcx+12]
  01861	89 48 03	 mov	 DWORD PTR [rax+3], ecx

; 6518 : 
; 6519 :             // Add the buffer containing the XID response to the chain.
; 6520 :             add_lcs_buffer_to_chain( pLCSDEV, pLCSIBH );

  01864	48 8b 94 24 88
	00 00 00	 mov	 rdx, QWORD PTR pLCSIBH$[rsp]
  0186c	48 8b 8c 24 18
	03 00 00	 mov	 rcx, QWORD PTR pLCSDEV$[rsp]
  01874	e8 00 00 00 00	 call	 add_lcs_buffer_to_chain

; 6521 : 
; 6522 :             fAttnRequired = TRUE;

  01879	c6 44 24 74 01	 mov	 BYTE PTR fAttnRequired$[rsp], 1

; 6523 : 
; 6524 :             break;

  0187e	e9 cb 0f 00 00	 jmp	 $LN24@LCS_Proces
$LN95@LCS_Proces:

; 6525 : 
; 6526 :         // Unnumbered Frame: FRMR Response (B'10001', 0x11, 0x87 or 0x97).
; 6527 :         //
; 6528 :         // A link station sends a Frame Reject response to report an error in an
; 6529 :         // incoming LPDU from the other link station. When you see a FRMR, the
; 6530 :         // station that sends the FRMR has detected an unrecoverable error. It
; 6531 :         // is not the cause of the error. Any frames that arrive after the FRMR
; 6532 :         // error has occurred are ignored until a DISC or SABME is received.
; 6533 :         // A FRMR response contains information about the cause of the FRMR
; 6534 :         // condition.
; 6535 :         // Bytes 0 and 1 contain the contents of the control field of the LPDU
; 6536 :         // which caused the frame reject. Bytes 2 and 3 contain the NS an NR
; 6537 :         // counts, respectively. Byte 4 contains several bits that identify the
; 6538 :         // type of error as shown here:
; 6539 :         //   0-0-0-V-Z-Y-W-X
; 6540 :         // The V bit indicates that the NS number carried by the control field
; 6541 :         // in bytes 0 and 1 is invalid. An NS is invalid if greater than or
; 6542 :         // equal to the last NS plus the maximum receive window size. When this
; 6543 :         // condition occurs, the link station sends a REJ LPDU, not a FRMR
; 6544 :         // response.
; 6545 :         // The Z bit indicates that the NR that the control field carries
; 6546 :         // indicated in bytes 0 and 1 does not refer to either the next I frame
; 6547 :         // or an I frame that has already been transmitted but not acknowledged.
; 6548 :         //   Note: It is all right to receive the the same NR count multiple
; 6549 :         //   times.
; 6550 :         //   The NR count is only invalid if the count references an I frame
; 6551 :         //   that has already been acknowledged or if the count skips ahead to
; 6552 :         //   one that has not been transmitted yet. The former is the most
; 6553 :         //   common case of this type of error. When you see this type of error,
; 6554 :         //   it usually means frames were received out of sequence, and you
; 6555 :         //   should look for the network that delivers frames out of order. It
; 6556 :         //   is possible that the sending link station transmitted them out of
; 6557 :         //   order, but very unlikely.
; 6558 :         // The Y bit indicates that the length of the I field in the received
; 6559 :         // LPDU exceeded the available buffer capacity. If this situation
; 6560 :         // occurs, look for problems in the end stations, not the network.
; 6561 :         // The X bit indicates that the LPDU contained an I field when it must
; 6562 :         // not have, or a FRMR response was received that did not contain 5
; 6563 :         // bytes. This appears to be an end station problem, not a network
; 6564 :         // problem.
; 6565 :         // The W bit indicates that an unsupported LPDU was received. This is an
; 6566 :         // end station problem.
; 6567 :         case M_FRMR_Response:
; 6568 : 
; 6569 :             if (pLCSBLK->fDebug)

  01883	48 8b 84 24 c8
	00 00 00	 mov	 rax, QWORD PTR pLCSBLK$[rsp]
  0188b	8b 40 18	 mov	 eax, DWORD PTR [rax+24]
  0188e	83 e0 01	 and	 eax, 1
  01891	85 c0		 test	 eax, eax
  01893	0f 84 57 01 00
	00		 je	 $LN96@LCS_Proces

; 6570 :             {
; 6571 :               snprintf( llcmsg, sizeof(llcmsg), "LCS: LLC unnumbered frame received: CR=%u, M=%s", llc.hwCR, "FRMR" );

  01899	0f b7 84 24 4c
	01 00 00	 movzx	 eax, WORD PTR llc$[rsp+20]
  018a1	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG175252
  018a8	48 89 4c 24 20	 mov	 QWORD PTR [rsp+32], rcx
  018ad	44 8b c8	 mov	 r9d, eax
  018b0	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG175253
  018b7	ba 00 01 00 00	 mov	 edx, 256		; 00000100H
  018bc	48 8d 8c 24 a0
	01 00 00	 lea	 rcx, QWORD PTR llcmsg$[rsp]
  018c4	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_snprintf

; 6572 :               WRMSG(HHC03984, "D", llcmsg );

  018ca	b9 01 00 00 00	 mov	 ecx, 1
  018cf	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  018d5	48 8d 8c 24 a0
	01 00 00	 lea	 rcx, QWORD PTR llcmsg$[rsp]
  018dd	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  018e2	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG175254
  018e9	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  018ee	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG175255
  018f5	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  018fa	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  018ff	41 b9 03 00 00
	00		 mov	 r9d, 3
  01905	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG175256
  0190c	ba ac 19 00 00	 mov	 edx, 6572		; 000019acH
  01911	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG175257
  01918	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 6573 :               snprintf( llcmsg, sizeof(llcmsg), "     CF=%4.4X, NR=%u, NS=%u, V=%u, Z=%u, Y=%u, X=%u, W=%u",

  0191e	0f b7 84 24 60
	01 00 00	 movzx	 eax, WORD PTR llc$[rsp+40]
  01926	0f b7 8c 24 5e
	01 00 00	 movzx	 ecx, WORD PTR llc$[rsp+38]
  0192e	0f b7 94 24 5c
	01 00 00	 movzx	 edx, WORD PTR llc$[rsp+36]
  01936	0f b7 bc 24 5a
	01 00 00	 movzx	 edi, WORD PTR llc$[rsp+34]
  0193e	0f b7 b4 24 58
	01 00 00	 movzx	 esi, WORD PTR llc$[rsp+32]
  01946	44 0f b7 84 24
	4e 01 00 00	 movzx	 r8d, WORD PTR llc$[rsp+22]
  0194f	44 0f b7 8c 24
	50 01 00 00	 movzx	 r9d, WORD PTR llc$[rsp+24]
  01958	44 0f b7 94 24
	62 01 00 00	 movzx	 r10d, WORD PTR llc$[rsp+42]
  01961	89 44 24 50	 mov	 DWORD PTR [rsp+80], eax
  01965	89 4c 24 48	 mov	 DWORD PTR [rsp+72], ecx
  01969	89 54 24 40	 mov	 DWORD PTR [rsp+64], edx
  0196d	89 7c 24 38	 mov	 DWORD PTR [rsp+56], edi
  01971	89 74 24 30	 mov	 DWORD PTR [rsp+48], esi
  01975	44 89 44 24 28	 mov	 DWORD PTR [rsp+40], r8d
  0197a	44 89 4c 24 20	 mov	 DWORD PTR [rsp+32], r9d
  0197f	45 8b ca	 mov	 r9d, r10d
  01982	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG175258
  01989	ba 00 01 00 00	 mov	 edx, 256		; 00000100H
  0198e	48 8d 8c 24 a0
	01 00 00	 lea	 rcx, QWORD PTR llcmsg$[rsp]
  01996	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_snprintf

; 6574 :                                           llc.hwCF, llc.hwNR, llc.hwNS, llc.hwV, llc.hwZ, llc.hwY, llc.hwX, llc.hwW );
; 6575 :               WRMSG(HHC03984, "D", llcmsg );

  0199c	b9 01 00 00 00	 mov	 ecx, 1
  019a1	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  019a7	48 8d 8c 24 a0
	01 00 00	 lea	 rcx, QWORD PTR llcmsg$[rsp]
  019af	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  019b4	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG175259
  019bb	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  019c0	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG175260
  019c7	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  019cc	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  019d1	41 b9 03 00 00
	00		 mov	 r9d, 3
  019d7	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG175261
  019de	ba af 19 00 00	 mov	 edx, 6575		; 000019afH
  019e3	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG175262
  019ea	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg
$LN96@LCS_Proces:

; 6576 :             }
; 6577 : 
; 6578 :             break;

  019f0	e9 59 0e 00 00	 jmp	 $LN24@LCS_Proces
$LN97@LCS_Proces:

; 6579 : 
; 6580 :         // Unnumbered Frame: XID Command or Response (B'10111', 0x2B, 0xAF or 0xBF).
; 6581 :         // Command.  A remote system has initiated the exchange of identifiers.
; 6582 :         //           The remote system has sent this XID command, which we will
; 6583 :         //           pass to VTAM, and to which VTAM will eventually send an
; 6584 :         //           XID response to the remote system.
; 6585 :         // Response. The local system has initiated the exchange of identifiers.
; 6586 :         //           Earlier, VTAM sent an XID command to the remote system, to
; 6587 :         //           which the remote system has responded with this XID response,
; 6588 :         //           which we will pass to VTAM.
; 6589 :         case M_XID_Command_or_Response:
; 6590 : 
; 6591 :             if (pLCSBLK->fDebug)

  019f5	48 8b 84 24 c8
	00 00 00	 mov	 rax, QWORD PTR pLCSBLK$[rsp]
  019fd	8b 40 18	 mov	 eax, DWORD PTR [rax+24]
  01a00	83 e0 01	 and	 eax, 1
  01a03	85 c0		 test	 eax, eax
  01a05	0f 84 85 00 00
	00		 je	 $LN98@LCS_Proces

; 6592 :             {
; 6593 :               snprintf( llcmsg, sizeof(llcmsg), "LCS: LLC unnumbered frame received: CR=%u, M=%s", llc.hwCR, "XID" );

  01a0b	0f b7 84 24 4c
	01 00 00	 movzx	 eax, WORD PTR llc$[rsp+20]
  01a13	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG175265
  01a1a	48 89 4c 24 20	 mov	 QWORD PTR [rsp+32], rcx
  01a1f	44 8b c8	 mov	 r9d, eax
  01a22	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG175266
  01a29	ba 00 01 00 00	 mov	 edx, 256		; 00000100H
  01a2e	48 8d 8c 24 a0
	01 00 00	 lea	 rcx, QWORD PTR llcmsg$[rsp]
  01a36	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_snprintf

; 6594 :               WRMSG(HHC03984, "D", llcmsg );

  01a3c	b9 01 00 00 00	 mov	 ecx, 1
  01a41	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  01a47	48 8d 8c 24 a0
	01 00 00	 lea	 rcx, QWORD PTR llcmsg$[rsp]
  01a4f	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  01a54	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG175267
  01a5b	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  01a60	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG175268
  01a67	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  01a6c	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  01a71	41 b9 03 00 00
	00		 mov	 r9d, 3
  01a77	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG175269
  01a7e	ba c2 19 00 00	 mov	 edx, 6594		; 000019c2H
  01a83	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG175270
  01a8a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg
$LN98@LCS_Proces:

; 6595 :             }
; 6596 : 
; 6597 :             // Calculate the size of the XID0 or the XID3 and CV's.
; 6598 :             iDatasize = (iLLCandDatasize - illcsize);

  01a90	8b 84 24 e0 00
	00 00		 mov	 eax, DWORD PTR illcsize$[rsp]
  01a97	8b 8c 24 ec 00
	00 00		 mov	 ecx, DWORD PTR iLLCandDatasize$[rsp]
  01a9e	2b c8		 sub	 ecx, eax
  01aa0	8b c1		 mov	 eax, ecx
  01aa2	89 84 24 a8 00
	00 00		 mov	 DWORD PTR iDatasize$[rsp], eax

; 6599 : 
; 6600 :             // Find the connection block.
; 6601 :             pLCSCONN = find_connection_by_remote_mac( pLCSDEV, &pEthFrame->bSrcMAC );

  01aa9	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR pEthFrame$[rsp]
  01ab1	48 83 c0 06	 add	 rax, 6
  01ab5	48 8b d0	 mov	 rdx, rax
  01ab8	48 8b 8c 24 18
	03 00 00	 mov	 rcx, QWORD PTR pLCSDEV$[rsp]
  01ac0	e8 00 00 00 00	 call	 find_connection_by_remote_mac
  01ac5	48 89 84 24 80
	00 00 00	 mov	 QWORD PTR pLCSCONN$[rsp], rax

; 6602 :             if (llc.hwCR)  // Response.

  01acd	0f b7 84 24 4c
	01 00 00	 movzx	 eax, WORD PTR llc$[rsp+20]
  01ad5	85 c0		 test	 eax, eax
  01ad7	74 68		 je	 SHORT $LN99@LCS_Proces

; 6603 :             {
; 6604 :                 if (!pLCSCONN)

  01ad9	48 83 bc 24 80
	00 00 00 00	 cmp	 QWORD PTR pLCSCONN$[rsp], 0
  01ae2	75 58		 jne	 SHORT $LN101@LCS_Proces

; 6605 :                 {
; 6606 :                     WRMSG( HHC03984, "W", "LCSCONN not found");

  01ae4	b9 01 00 00 00	 mov	 ecx, 1
  01ae9	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  01aef	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG175274
  01af6	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  01afb	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG175275
  01b02	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  01b07	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG175276
  01b0e	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  01b13	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  01b18	41 b9 03 00 00
	00		 mov	 r9d, 3
  01b1e	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG175277
  01b25	ba ce 19 00 00	 mov	 edx, 6606		; 000019ceH
  01b2a	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG175278
  01b31	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 6607 :                     /* FixMe! Need a proper error message here! */
; 6608 :                     break;

  01b37	e9 12 0d 00 00	 jmp	 $LN24@LCS_Proces
$LN101@LCS_Proces:

; 6609 :                 }
; 6610 :             }

  01b3c	e9 06 03 00 00	 jmp	 $LN100@LCS_Proces
$LN99@LCS_Proces:

; 6611 :             else  // Command.
; 6612 :             {
; 6613 :                 if (!pLCSCONN)  // There isn't an existing LCSCONN.

  01b41	48 83 bc 24 80
	00 00 00 00	 cmp	 QWORD PTR pLCSCONN$[rsp], 0
  01b4a	0f 85 84 01 00
	00		 jne	 $LN102@LCS_Proces

; 6614 :                 {
; 6615 :                     if ( iDatasize > 0 )  // Is there an XID0 or an XID3 and CV's?

  01b50	83 bc 24 a8 00
	00 00 00	 cmp	 DWORD PTR iDatasize$[rsp], 0
  01b58	7e 58		 jle	 SHORT $LN104@LCS_Proces

; 6616 :                     {
; 6617 :                         WRMSG( HHC03984, "W", "LCSCONN not found");

  01b5a	b9 01 00 00 00	 mov	 ecx, 1
  01b5f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  01b65	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG175282
  01b6c	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  01b71	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG175283
  01b78	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  01b7d	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG175284
  01b84	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  01b89	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  01b8e	41 b9 03 00 00
	00		 mov	 r9d, 3
  01b94	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG175285
  01b9b	ba d9 19 00 00	 mov	 edx, 6617		; 000019d9H
  01ba0	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG175286
  01ba7	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 6618 :                         /* FixMe! Need a proper error message here! */
; 6619 :                         break;

  01bad	e9 9c 0c 00 00	 jmp	 $LN24@LCS_Proces
$LN104@LCS_Proces:

; 6620 :                     }
; 6621 : 
; 6622 :                     // Create the LCSCONN for the new inbound connection.
; 6623 :                     pLCSCONN = alloc_connection( pLCSDEV );

  01bb2	48 8b 8c 24 18
	03 00 00	 mov	 rcx, QWORD PTR pLCSDEV$[rsp]
  01bba	e8 00 00 00 00	 call	 alloc_connection
  01bbf	48 89 84 24 80
	00 00 00	 mov	 QWORD PTR pLCSCONN$[rsp], rax

; 6624 :                     pLCSCONN->hwCreated = LCSCONN_CREATED_INBOUND;

  01bc7	b8 01 00 00 00	 mov	 eax, 1
  01bcc	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR pLCSCONN$[rsp]
  01bd4	66 89 41 1c	 mov	 WORD PTR [rcx+28], ax

; 6625 : 
; 6626 :                     memcpy( &pLCSCONN->bLocalMAC, &pLCSPORT->MAC_Address, IFHWADDRLEN );

  01bd8	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR pLCSCONN$[rsp]
  01be0	48 8b 8c 24 10
	03 00 00	 mov	 rcx, QWORD PTR pLCSPORT$[rsp]
  01be8	48 8d 78 10	 lea	 rdi, QWORD PTR [rax+16]
  01bec	48 8d 71 02	 lea	 rsi, QWORD PTR [rcx+2]
  01bf0	b9 06 00 00 00	 mov	 ecx, 6
  01bf5	f3 a4		 rep movsb

; 6627 : #if !defined( OPTION_TUNTAP_LCS_SAME_ADDR )
; 6628 :                     pLCSCONN->bLocalMAC[5]++;
; 6629 : #endif
; 6630 :                     memcpy( &pLCSCONN->bRemoteMAC, &pEthFrame->bSrcMAC, IFHWADDRLEN );

  01bf7	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR pLCSCONN$[rsp]
  01bff	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR pEthFrame$[rsp]
  01c07	48 8d 78 16	 lea	 rdi, QWORD PTR [rax+22]
  01c0b	48 8d 71 06	 lea	 rsi, QWORD PTR [rcx+6]
  01c0f	b9 06 00 00 00	 mov	 ecx, 6
  01c14	f3 a4		 rep movsb

; 6631 : 
; 6632 :                     if (pLCSDEV->pLCSBLK->fDebug)

  01c16	48 8b 84 24 18
	03 00 00	 mov	 rax, QWORD PTR pLCSDEV$[rsp]
  01c1e	48 8b 40 08	 mov	 rax, QWORD PTR [rax+8]
  01c22	8b 40 18	 mov	 eax, DWORD PTR [rax+24]
  01c25	83 e0 01	 and	 eax, 1
  01c28	85 c0		 test	 eax, eax
  01c2a	0f 84 8a 00 00
	00		 je	 $LN105@LCS_Proces

; 6633 :                     {
; 6634 :                         WRMSG( HHC03984, "I", "Created LCSCONN Inbound");

  01c30	b9 01 00 00 00	 mov	 ecx, 1
  01c35	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  01c3b	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG175288
  01c42	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  01c47	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG175289
  01c4e	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  01c53	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG175290
  01c5a	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  01c5f	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  01c64	41 b9 03 00 00
	00		 mov	 r9d, 3
  01c6a	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG175291
  01c71	ba ea 19 00 00	 mov	 edx, 6634		; 000019eaH
  01c76	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG175292
  01c7d	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 6635 :                         net_data_trace( pDEVBLK, (BYTE*)pLCSCONN, sizeof(LCSCONN), NO_DIRECTION, 'D', "LCSCONN", 0 );

  01c83	c7 44 24 30 00
	00 00 00	 mov	 DWORD PTR [rsp+48], 0
  01c8b	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG175293
  01c92	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  01c97	c6 44 24 20 44	 mov	 BYTE PTR [rsp+32], 68	; 00000044H
  01c9c	41 b1 20	 mov	 r9b, 32			; 00000020H
  01c9f	41 b8 30 00 00
	00		 mov	 r8d, 48			; 00000030H
  01ca5	48 8b 94 24 80
	00 00 00	 mov	 rdx, QWORD PTR pLCSCONN$[rsp]
  01cad	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR pDEVBLK$[rsp]
  01cb5	e8 00 00 00 00	 call	 net_data_trace
$LN105@LCS_Proces:

; 6636 :                     }
; 6637 : 
; 6638 :                     add_connection_to_chain( pLCSDEV, pLCSCONN );

  01cba	48 8b 94 24 80
	00 00 00	 mov	 rdx, QWORD PTR pLCSCONN$[rsp]
  01cc2	48 8b 8c 24 18
	03 00 00	 mov	 rcx, QWORD PTR pLCSDEV$[rsp]
  01cca	e8 00 00 00 00	 call	 add_connection_to_chain

; 6639 :                 }

  01ccf	e9 73 01 00 00	 jmp	 $LN103@LCS_Proces
$LN102@LCS_Proces:

; 6640 :                 else  // There is an existing LCSCONN.
; 6641 :                 {
; 6642 :                     if ( pLCSCONN->hwCreated == LCSCONN_CREATED_INBOUND )  // The existing LSCCONN is for an inbound connection.

  01cd4	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR pLCSCONN$[rsp]
  01cdc	0f b7 40 1c	 movzx	 eax, WORD PTR [rax+28]
  01ce0	83 f8 01	 cmp	 eax, 1
  01ce3	0f 85 a9 00 00
	00		 jne	 $LN106@LCS_Proces

; 6643 :                     {
; 6644 :                         if (pLCSDEV->pLCSBLK->fDebug)

  01ce9	48 8b 84 24 18
	03 00 00	 mov	 rax, QWORD PTR pLCSDEV$[rsp]
  01cf1	48 8b 40 08	 mov	 rax, QWORD PTR [rax+8]
  01cf5	8b 40 18	 mov	 eax, DWORD PTR [rax+24]
  01cf8	83 e0 01	 and	 eax, 1
  01cfb	85 c0		 test	 eax, eax
  01cfd	0f 84 8a 00 00
	00		 je	 $LN108@LCS_Proces

; 6645 :                         {
; 6646 :                             WRMSG( HHC03984, "I", "Found LCSCONN Inbound");

  01d03	b9 01 00 00 00	 mov	 ecx, 1
  01d08	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  01d0e	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG175297
  01d15	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  01d1a	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG175298
  01d21	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  01d26	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG175299
  01d2d	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  01d32	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  01d37	41 b9 03 00 00
	00		 mov	 r9d, 3
  01d3d	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG175300
  01d44	ba f6 19 00 00	 mov	 edx, 6646		; 000019f6H
  01d49	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG175301
  01d50	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 6647 :                             net_data_trace( pDEVBLK, (BYTE*)pLCSCONN, sizeof(LCSCONN), NO_DIRECTION, 'D', "LCSCONN", 0 );

  01d56	c7 44 24 30 00
	00 00 00	 mov	 DWORD PTR [rsp+48], 0
  01d5e	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG175302
  01d65	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  01d6a	c6 44 24 20 44	 mov	 BYTE PTR [rsp+32], 68	; 00000044H
  01d6f	41 b1 20	 mov	 r9b, 32			; 00000020H
  01d72	41 b8 30 00 00
	00		 mov	 r8d, 48			; 00000030H
  01d78	48 8b 94 24 80
	00 00 00	 mov	 rdx, QWORD PTR pLCSCONN$[rsp]
  01d80	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR pDEVBLK$[rsp]
  01d88	e8 00 00 00 00	 call	 net_data_trace
$LN108@LCS_Proces:

; 6648 :                         }
; 6649 :                     }

  01d8d	e9 b5 00 00 00	 jmp	 $LN107@LCS_Proces
$LN106@LCS_Proces:

; 6650 :                     else  // The existing LCSCONN is for an outbound connection.
; 6651 :                     {
; 6652 :                         if (pLCSDEV->pLCSBLK->fDebug)

  01d92	48 8b 84 24 18
	03 00 00	 mov	 rax, QWORD PTR pLCSDEV$[rsp]
  01d9a	48 8b 40 08	 mov	 rax, QWORD PTR [rax+8]
  01d9e	8b 40 18	 mov	 eax, DWORD PTR [rax+24]
  01da1	83 e0 01	 and	 eax, 1
  01da4	85 c0		 test	 eax, eax
  01da6	0f 84 8a 00 00
	00		 je	 $LN109@LCS_Proces

; 6653 :                         {
; 6654 :                             WRMSG( HHC03984, "W", "Found existing LCSCONN Outbound, changed to LCSCONN Inbound");

  01dac	b9 01 00 00 00	 mov	 ecx, 1
  01db1	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  01db7	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG175304
  01dbe	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  01dc3	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG175305
  01dca	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  01dcf	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG175306
  01dd6	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  01ddb	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  01de0	41 b9 03 00 00
	00		 mov	 r9d, 3
  01de6	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG175307
  01ded	ba fe 19 00 00	 mov	 edx, 6654		; 000019feH
  01df2	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG175308
  01df9	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 6655 :                             net_data_trace( pDEVBLK, (BYTE*)pLCSCONN, sizeof(LCSCONN), NO_DIRECTION, 'D', "LCSCONN", 0 );

  01dff	c7 44 24 30 00
	00 00 00	 mov	 DWORD PTR [rsp+48], 0
  01e07	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG175309
  01e0e	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  01e13	c6 44 24 20 44	 mov	 BYTE PTR [rsp+32], 68	; 00000044H
  01e18	41 b1 20	 mov	 r9b, 32			; 00000020H
  01e1b	41 b8 30 00 00
	00		 mov	 r8d, 48			; 00000030H
  01e21	48 8b 94 24 80
	00 00 00	 mov	 rdx, QWORD PTR pLCSCONN$[rsp]
  01e29	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR pDEVBLK$[rsp]
  01e31	e8 00 00 00 00	 call	 net_data_trace
$LN109@LCS_Proces:

; 6656 :                         }
; 6657 : 
; 6658 :                         pLCSCONN->hwCreated = LCSCONN_CREATED_INBOUND;

  01e36	b8 01 00 00 00	 mov	 eax, 1
  01e3b	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR pLCSCONN$[rsp]
  01e43	66 89 41 1c	 mov	 WORD PTR [rcx+28], ax
$LN107@LCS_Proces:
$LN103@LCS_Proces:
$LN100@LCS_Proces:

; 6659 :                     }
; 6660 :                 }
; 6661 :             }
; 6662 : 
; 6663 :             // Obtain a buffer in which to construct the data to be passed to VTAM.
; 6664 :             // Note: The largest XID3 and CV's seen has been less than 160-bytes.
; 6665 :             pLCSIBH = alloc_lcs_buffer( pLCSDEV, 496 );

  01e47	ba f0 01 00 00	 mov	 edx, 496		; 000001f0H
  01e4c	48 8b 8c 24 18
	03 00 00	 mov	 rcx, QWORD PTR pLCSDEV$[rsp]
  01e54	e8 00 00 00 00	 call	 alloc_lcs_buffer
  01e59	48 89 84 24 88
	00 00 00	 mov	 QWORD PTR pLCSIBH$[rsp], rax

; 6666 : 
; 6667 :             memcpy( &pLCSIBH->bData, Inbound_4C22, INBOUND_4C22_SIZE );

  01e61	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR pLCSIBH$[rsp]
  01e69	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:?Inbound_4C22@?1??LCS_ProcessAccepted_SNA@@9@9
  01e70	48 8d 78 10	 lea	 rdi, QWORD PTR [rax+16]
  01e74	48 8b f1	 mov	 rsi, rcx
  01e77	b9 1d 00 00 00	 mov	 ecx, 29
  01e7c	f3 a4		 rep movsb

; 6668 :             pLCSIBH->iDataLen = INBOUND_4C22_SIZE;

  01e7e	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR pLCSIBH$[rsp]
  01e86	c7 40 0c 1d 00
	00 00		 mov	 DWORD PTR [rax+12], 29

; 6669 : 
; 6670 :             pLCSHDR = (PLCSHDR)&pLCSIBH->bData;

  01e8d	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR pLCSIBH$[rsp]
  01e95	48 83 c0 10	 add	 rax, 16
  01e99	48 89 84 24 c0
	00 00 00	 mov	 QWORD PTR pLCSHDR$[rsp], rax

; 6671 :             pLCSBAF1 = (PLCSBAF1)( (BYTE*)pLCSHDR + sizeof(LCSHDR) );

  01ea1	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR pLCSHDR$[rsp]
  01ea9	48 83 c0 04	 add	 rax, 4
  01ead	48 89 84 24 98
	00 00 00	 mov	 QWORD PTR pLCSBAF1$[rsp], rax

; 6672 :             FETCH_HW( hwLenBaf1, pLCSBAF1->hwLenBaf1 );

  01eb5	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR pLCSBAF1$[rsp]
  01ebd	48 8b c8	 mov	 rcx, rax
  01ec0	e8 00 00 00 00	 call	 fetch_hw_noswap
  01ec5	0f b7 c8	 movzx	 ecx, ax
  01ec8	e8 00 00 00 00	 call	 _byteswap_ushort
  01ecd	66 89 84 24 90
	00 00 00	 mov	 WORD PTR hwLenBaf1$[rsp], ax

; 6673 : //          FETCH_HW( hwLenBaf2, pLCSBAF1->hwLenBaf2 );
; 6674 :             pLCSBAF2 = (PLCSBAF2)( (BYTE*)pLCSBAF1 + hwLenBaf1 );

  01ed5	0f b7 84 24 90
	00 00 00	 movzx	 eax, WORD PTR hwLenBaf1$[rsp]
  01edd	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR pLCSBAF1$[rsp]
  01ee5	48 03 c8	 add	 rcx, rax
  01ee8	48 8b c1	 mov	 rax, rcx
  01eeb	48 89 84 24 b8
	00 00 00	 mov	 QWORD PTR pLCSBAF2$[rsp], rax

; 6675 : 
; 6676 :             //
; 6677 :             if (llc.hwCR)  // Response.

  01ef3	0f b7 84 24 4c
	01 00 00	 movzx	 eax, WORD PTR llc$[rsp+20]
  01efb	85 c0		 test	 eax, eax
  01efd	74 4d		 je	 SHORT $LN110@LCS_Proces

; 6678 :             {
; 6679 :                 pLCSCONN->hwXIDSeqNum++;

  01eff	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR pLCSCONN$[rsp]
  01f07	0f b7 40 20	 movzx	 eax, WORD PTR [rax+32]
  01f0b	66 ff c0	 inc	 ax
  01f0e	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR pLCSCONN$[rsp]
  01f16	66 89 41 20	 mov	 WORD PTR [rcx+32], ax

; 6680 :                 STORE_HW( pLCSBAF2->hwSeqNum, pLCSCONN->hwXIDSeqNum );

  01f1a	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR pLCSCONN$[rsp]
  01f22	0f b7 48 20	 movzx	 ecx, WORD PTR [rax+32]
  01f26	e8 00 00 00 00	 call	 _byteswap_ushort
  01f2b	48 8b 8c 24 b8
	00 00 00	 mov	 rcx, QWORD PTR pLCSBAF2$[rsp]
  01f33	48 ff c1	 inc	 rcx
  01f36	0f b7 d0	 movzx	 edx, ax
  01f39	e8 00 00 00 00	 call	 store_hw_noswap

; 6681 :                 pLCSBAF2->bByte07 = 0x08;  // ???

  01f3e	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR pLCSBAF2$[rsp]
  01f46	c6 40 07 08	 mov	 BYTE PTR [rax+7], 8

; 6682 :             }

  01f4a	eb 4b		 jmp	 SHORT $LN111@LCS_Proces
$LN110@LCS_Proces:

; 6683 :             else  // Command.
; 6684 :             {
; 6685 :                 pLCSDEV->hwInXIDSeqNum++;

  01f4c	48 8b 84 24 18
	03 00 00	 mov	 rax, QWORD PTR pLCSDEV$[rsp]
  01f54	0f b7 40 66	 movzx	 eax, WORD PTR [rax+102]
  01f58	66 ff c0	 inc	 ax
  01f5b	48 8b 8c 24 18
	03 00 00	 mov	 rcx, QWORD PTR pLCSDEV$[rsp]
  01f63	66 89 41 66	 mov	 WORD PTR [rcx+102], ax

; 6686 :                 STORE_HW( pLCSBAF2->hwSeqNum, pLCSDEV->hwInXIDSeqNum );

  01f67	48 8b 84 24 18
	03 00 00	 mov	 rax, QWORD PTR pLCSDEV$[rsp]
  01f6f	0f b7 48 66	 movzx	 ecx, WORD PTR [rax+102]
  01f73	e8 00 00 00 00	 call	 _byteswap_ushort
  01f78	48 8b 8c 24 b8
	00 00 00	 mov	 rcx, QWORD PTR pLCSBAF2$[rsp]
  01f80	48 ff c1	 inc	 rcx
  01f83	0f b7 d0	 movzx	 edx, ax
  01f86	e8 00 00 00 00	 call	 store_hw_noswap

; 6687 :                 pLCSBAF2->bByte07 = 0x04;  // ???

  01f8b	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR pLCSBAF2$[rsp]
  01f93	c6 40 07 04	 mov	 BYTE PTR [rax+7], 4
$LN111@LCS_Proces:

; 6688 :             }
; 6689 : 
; 6690 :             // Copy the destination MAC address, the source MAC addresses, and the LLC to the buffer.
; 6691 :             memcpy( &pLCSBAF2->bByte12, &pEthFrame->bDestMAC, IFHWADDRLEN );

  01f97	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR pLCSBAF2$[rsp]
  01f9f	48 8d 78 0c	 lea	 rdi, QWORD PTR [rax+12]
  01fa3	48 8b b4 24 b0
	00 00 00	 mov	 rsi, QWORD PTR pEthFrame$[rsp]
  01fab	b9 06 00 00 00	 mov	 ecx, 6
  01fb0	f3 a4		 rep movsb

; 6692 :             memcpy( &pLCSBAF2->bByte18, &pEthFrame->bSrcMAC, IFHWADDRLEN );

  01fb2	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR pLCSBAF2$[rsp]
  01fba	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR pEthFrame$[rsp]
  01fc2	48 8d 78 12	 lea	 rdi, QWORD PTR [rax+18]
  01fc6	48 8d 71 06	 lea	 rsi, QWORD PTR [rcx+6]
  01fca	b9 06 00 00 00	 mov	 ecx, 6
  01fcf	f3 a4		 rep movsb

; 6693 :             memcpy( &pLCSBAF2->bByte24, &pEthFrame->bData, 3 );

  01fd1	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR pLCSBAF2$[rsp]
  01fd9	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR pEthFrame$[rsp]
  01fe1	48 8d 78 18	 lea	 rdi, QWORD PTR [rax+24]
  01fe5	48 8d 71 0e	 lea	 rsi, QWORD PTR [rcx+14]
  01fe9	b9 03 00 00 00	 mov	 ecx, 3
  01fee	f3 a4		 rep movsb

; 6694 : 
; 6695 :             pLCSIBH->iDataLen += (6 + 6 + 3);

  01ff0	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR pLCSIBH$[rsp]
  01ff8	8b 40 0c	 mov	 eax, DWORD PTR [rax+12]
  01ffb	83 c0 0f	 add	 eax, 15
  01ffe	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR pLCSIBH$[rsp]
  02006	89 41 0c	 mov	 DWORD PTR [rcx+12], eax

; 6696 : 
; 6697 :             FETCH_HW( hwLenBaf2, pLCSBAF1->hwLenBaf2 );

  02009	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR pLCSBAF1$[rsp]
  02011	48 83 c0 04	 add	 rax, 4
  02015	48 8b c8	 mov	 rcx, rax
  02018	e8 00 00 00 00	 call	 fetch_hw_noswap
  0201d	0f b7 c8	 movzx	 ecx, ax
  02020	e8 00 00 00 00	 call	 _byteswap_ushort
  02025	66 89 44 24 78	 mov	 WORD PTR hwLenBaf2$[rsp], ax

; 6698 :             hwLenBaf2 += (6 + 6 + 3);

  0202a	0f b7 44 24 78	 movzx	 eax, WORD PTR hwLenBaf2$[rsp]
  0202f	83 c0 0f	 add	 eax, 15
  02032	66 89 44 24 78	 mov	 WORD PTR hwLenBaf2$[rsp], ax

; 6699 :             STORE_HW( pLCSBAF1->hwLenBaf2, hwLenBaf2 );

  02037	0f b7 4c 24 78	 movzx	 ecx, WORD PTR hwLenBaf2$[rsp]
  0203c	e8 00 00 00 00	 call	 _byteswap_ushort
  02041	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR pLCSBAF1$[rsp]
  02049	48 83 c1 04	 add	 rcx, 4
  0204d	0f b7 d0	 movzx	 edx, ax
  02050	e8 00 00 00 00	 call	 store_hw_noswap

; 6700 : 
; 6701 :             FETCH_HW( hwOffset, pLCSHDR->hwOffset );

  02055	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR pLCSHDR$[rsp]
  0205d	48 8b c8	 mov	 rcx, rax
  02060	e8 00 00 00 00	 call	 fetch_hw_noswap
  02065	0f b7 c8	 movzx	 ecx, ax
  02068	e8 00 00 00 00	 call	 _byteswap_ushort
  0206d	66 89 44 24 70	 mov	 WORD PTR hwOffset$[rsp], ax

; 6702 :             hwOffset += (6 + 6 + 3);

  02072	0f b7 44 24 70	 movzx	 eax, WORD PTR hwOffset$[rsp]
  02077	83 c0 0f	 add	 eax, 15
  0207a	66 89 44 24 70	 mov	 WORD PTR hwOffset$[rsp], ax

; 6703 :             STORE_HW( pLCSHDR->hwOffset, hwOffset );

  0207f	0f b7 4c 24 70	 movzx	 ecx, WORD PTR hwOffset$[rsp]
  02084	e8 00 00 00 00	 call	 _byteswap_ushort
  02089	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR pLCSHDR$[rsp]
  02091	0f b7 d0	 movzx	 edx, ax
  02094	e8 00 00 00 00	 call	 store_hw_noswap

; 6704 : 
; 6705 :             // Copy the XID0 or the XID3 and CV's to the buffer.
; 6706 :             if ( iDatasize > 0 )

  02099	83 bc 24 a8 00
	00 00 00	 cmp	 DWORD PTR iDatasize$[rsp], 0
  020a1	0f 8e ea 00 00
	00		 jle	 $LN112@LCS_Proces

; 6707 :             {
; 6708 :                 memcpy( &pLCSBAF2->bByte27, &pEthFrame->bData[3], iDatasize );

  020a7	48 63 84 24 a8
	00 00 00	 movsxd	 rax, DWORD PTR iDatasize$[rsp]
  020af	b9 01 00 00 00	 mov	 ecx, 1
  020b4	48 6b c9 03	 imul	 rcx, rcx, 3
  020b8	48 8b 94 24 b0
	00 00 00	 mov	 rdx, QWORD PTR pEthFrame$[rsp]
  020c0	48 8d 4c 0a 0e	 lea	 rcx, QWORD PTR [rdx+rcx+14]
  020c5	48 8b 94 24 b8
	00 00 00	 mov	 rdx, QWORD PTR pLCSBAF2$[rsp]
  020cd	48 83 c2 1b	 add	 rdx, 27
  020d1	48 8b fa	 mov	 rdi, rdx
  020d4	48 8b f1	 mov	 rsi, rcx
  020d7	48 8b c8	 mov	 rcx, rax
  020da	f3 a4		 rep movsb

; 6709 : 
; 6710 :                 pLCSIBH->iDataLen += iDatasize;

  020dc	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR pLCSIBH$[rsp]
  020e4	8b 40 0c	 mov	 eax, DWORD PTR [rax+12]
  020e7	03 84 24 a8 00
	00 00		 add	 eax, DWORD PTR iDatasize$[rsp]
  020ee	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR pLCSIBH$[rsp]
  020f6	89 41 0c	 mov	 DWORD PTR [rcx+12], eax

; 6711 : 
; 6712 :                 FETCH_HW( hwLenBaf2, pLCSBAF1->hwLenBaf2 );

  020f9	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR pLCSBAF1$[rsp]
  02101	48 83 c0 04	 add	 rax, 4
  02105	48 8b c8	 mov	 rcx, rax
  02108	e8 00 00 00 00	 call	 fetch_hw_noswap
  0210d	0f b7 c8	 movzx	 ecx, ax
  02110	e8 00 00 00 00	 call	 _byteswap_ushort
  02115	66 89 44 24 78	 mov	 WORD PTR hwLenBaf2$[rsp], ax

; 6713 :                 hwLenBaf2 += iDatasize;

  0211a	0f b7 44 24 78	 movzx	 eax, WORD PTR hwLenBaf2$[rsp]
  0211f	03 84 24 a8 00
	00 00		 add	 eax, DWORD PTR iDatasize$[rsp]
  02126	66 89 44 24 78	 mov	 WORD PTR hwLenBaf2$[rsp], ax

; 6714 :                 STORE_HW( pLCSBAF1->hwLenBaf2, hwLenBaf2 );

  0212b	0f b7 4c 24 78	 movzx	 ecx, WORD PTR hwLenBaf2$[rsp]
  02130	e8 00 00 00 00	 call	 _byteswap_ushort
  02135	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR pLCSBAF1$[rsp]
  0213d	48 83 c1 04	 add	 rcx, 4
  02141	0f b7 d0	 movzx	 edx, ax
  02144	e8 00 00 00 00	 call	 store_hw_noswap

; 6715 : 
; 6716 :                 FETCH_HW( hwOffset, pLCSHDR->hwOffset );

  02149	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR pLCSHDR$[rsp]
  02151	48 8b c8	 mov	 rcx, rax
  02154	e8 00 00 00 00	 call	 fetch_hw_noswap
  02159	0f b7 c8	 movzx	 ecx, ax
  0215c	e8 00 00 00 00	 call	 _byteswap_ushort
  02161	66 89 44 24 70	 mov	 WORD PTR hwOffset$[rsp], ax

; 6717 :                 hwOffset += iDatasize;

  02166	0f b7 44 24 70	 movzx	 eax, WORD PTR hwOffset$[rsp]
  0216b	03 84 24 a8 00
	00 00		 add	 eax, DWORD PTR iDatasize$[rsp]
  02172	66 89 44 24 70	 mov	 WORD PTR hwOffset$[rsp], ax

; 6718 :                 STORE_HW( pLCSHDR->hwOffset, hwOffset );

  02177	0f b7 4c 24 70	 movzx	 ecx, WORD PTR hwOffset$[rsp]
  0217c	e8 00 00 00 00	 call	 _byteswap_ushort
  02181	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR pLCSHDR$[rsp]
  02189	0f b7 d0	 movzx	 edx, ax
  0218c	e8 00 00 00 00	 call	 store_hw_noswap
$LN112@LCS_Proces:

; 6719 :             }
; 6720 : 
; 6721 :             // Add a padding byte to the buffer, if necessary.
; 6722 :             if  ( pLCSIBH->iDataLen & 0x01 )

  02191	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR pLCSIBH$[rsp]
  02199	8b 40 0c	 mov	 eax, DWORD PTR [rax+12]
  0219c	83 e0 01	 and	 eax, 1
  0219f	85 c0		 test	 eax, eax
  021a1	74 5c		 je	 SHORT $LN113@LCS_Proces

; 6723 :             {
; 6724 :                 pLCSIBH->iDataLen++;

  021a3	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR pLCSIBH$[rsp]
  021ab	8b 40 0c	 mov	 eax, DWORD PTR [rax+12]
  021ae	ff c0		 inc	 eax
  021b0	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR pLCSIBH$[rsp]
  021b8	89 41 0c	 mov	 DWORD PTR [rcx+12], eax

; 6725 : 
; 6726 :                 FETCH_HW( hwOffset, pLCSHDR->hwOffset );

  021bb	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR pLCSHDR$[rsp]
  021c3	48 8b c8	 mov	 rcx, rax
  021c6	e8 00 00 00 00	 call	 fetch_hw_noswap
  021cb	0f b7 c8	 movzx	 ecx, ax
  021ce	e8 00 00 00 00	 call	 _byteswap_ushort
  021d3	66 89 44 24 70	 mov	 WORD PTR hwOffset$[rsp], ax

; 6727 :                 hwOffset++;

  021d8	0f b7 44 24 70	 movzx	 eax, WORD PTR hwOffset$[rsp]
  021dd	66 ff c0	 inc	 ax
  021e0	66 89 44 24 70	 mov	 WORD PTR hwOffset$[rsp], ax

; 6728 :                 STORE_HW( pLCSHDR->hwOffset, hwOffset );

  021e5	0f b7 4c 24 70	 movzx	 ecx, WORD PTR hwOffset$[rsp]
  021ea	e8 00 00 00 00	 call	 _byteswap_ushort
  021ef	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR pLCSHDR$[rsp]
  021f7	0f b7 d0	 movzx	 edx, ax
  021fa	e8 00 00 00 00	 call	 store_hw_noswap
$LN113@LCS_Proces:

; 6729 :             }
; 6730 : 
; 6731 :             // Add the buffer containing the XID response to the chain.
; 6732 :             add_lcs_buffer_to_chain( pLCSDEV, pLCSIBH );

  021ff	48 8b 94 24 88
	00 00 00	 mov	 rdx, QWORD PTR pLCSIBH$[rsp]
  02207	48 8b 8c 24 18
	03 00 00	 mov	 rcx, QWORD PTR pLCSDEV$[rsp]
  0220f	e8 00 00 00 00	 call	 add_lcs_buffer_to_chain

; 6733 : 
; 6734 :             fAttnRequired = TRUE;

  02214	c6 44 24 74 01	 mov	 BYTE PTR fAttnRequired$[rsp], 1

; 6735 : 
; 6736 :             break;

  02219	e9 30 06 00 00	 jmp	 $LN24@LCS_Proces
$LN114@LCS_Proces:

; 6737 : 
; 6738 :         // Unnumbered Frame: TEST Command or Response (B'11100, 0x38, 0xE3 or 0xF3).
; 6739 :         case M_TEST_Command_or_Response:
; 6740 : 
; 6741 :             if (pLCSBLK->fDebug)

  0221e	48 8b 84 24 c8
	00 00 00	 mov	 rax, QWORD PTR pLCSBLK$[rsp]
  02226	8b 40 18	 mov	 eax, DWORD PTR [rax+24]
  02229	83 e0 01	 and	 eax, 1
  0222c	85 c0		 test	 eax, eax
  0222e	0f 84 85 00 00
	00		 je	 $LN115@LCS_Proces

; 6742 :             {
; 6743 :               snprintf( llcmsg, sizeof(llcmsg), "LCS: LLC unnumbered frame received: CR=%u, M=%s", llc.hwCR, "TEST" );

  02234	0f b7 84 24 4c
	01 00 00	 movzx	 eax, WORD PTR llc$[rsp+20]
  0223c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG175316
  02243	48 89 4c 24 20	 mov	 QWORD PTR [rsp+32], rcx
  02248	44 8b c8	 mov	 r9d, eax
  0224b	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG175317
  02252	ba 00 01 00 00	 mov	 edx, 256		; 00000100H
  02257	48 8d 8c 24 a0
	01 00 00	 lea	 rcx, QWORD PTR llcmsg$[rsp]
  0225f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_snprintf

; 6744 :               WRMSG(HHC03984, "D", llcmsg );

  02265	b9 01 00 00 00	 mov	 ecx, 1
  0226a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  02270	48 8d 8c 24 a0
	01 00 00	 lea	 rcx, QWORD PTR llcmsg$[rsp]
  02278	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  0227d	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG175318
  02284	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  02289	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG175319
  02290	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  02295	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  0229a	41 b9 03 00 00
	00		 mov	 r9d, 3
  022a0	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG175320
  022a7	ba 58 1a 00 00	 mov	 edx, 6744		; 00001a58H
  022ac	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG175321
  022b3	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg
$LN115@LCS_Proces:

; 6745 :             }
; 6746 : 
; 6747 :             if (llc.hwCR)  // Response. Tell VTAM the remote system has responded to VTAM's TEST.

  022b9	0f b7 84 24 4c
	01 00 00	 movzx	 eax, WORD PTR llc$[rsp+20]
  022c1	85 c0		 test	 eax, eax
  022c3	0f 84 0b 02 00
	00		 je	 $LN116@LCS_Proces

; 6748 :             {
; 6749 : 
; 6750 :                 // XID response, find the connection block.
; 6751 :                 pLCSCONN = find_connection_by_remote_mac( pLCSDEV, &pEthFrame->bSrcMAC );

  022c9	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR pEthFrame$[rsp]
  022d1	48 83 c0 06	 add	 rax, 6
  022d5	48 8b d0	 mov	 rdx, rax
  022d8	48 8b 8c 24 18
	03 00 00	 mov	 rcx, QWORD PTR pLCSDEV$[rsp]
  022e0	e8 00 00 00 00	 call	 find_connection_by_remote_mac
  022e5	48 89 84 24 80
	00 00 00	 mov	 QWORD PTR pLCSCONN$[rsp], rax

; 6752 :                 if (!pLCSCONN)

  022ed	48 83 bc 24 80
	00 00 00 00	 cmp	 QWORD PTR pLCSCONN$[rsp], 0
  022f6	75 58		 jne	 SHORT $LN118@LCS_Proces

; 6753 :                 {
; 6754 :                     WRMSG( HHC03984, "W", "LCSCONN not found");

  022f8	b9 01 00 00 00	 mov	 ecx, 1
  022fd	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  02303	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG175325
  0230a	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  0230f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG175326
  02316	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  0231b	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG175327
  02322	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  02327	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  0232c	41 b9 03 00 00
	00		 mov	 r9d, 3
  02332	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG175328
  02339	ba 62 1a 00 00	 mov	 edx, 6754		; 00001a62H
  0233e	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG175329
  02345	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 6755 :                     /* FixMe! Need a proper error message here! */
; 6756 :                     break;

  0234b	e9 fe 04 00 00	 jmp	 $LN24@LCS_Proces
$LN118@LCS_Proces:

; 6757 :                 }
; 6758 : 
; 6759 :                 // Obtain a buffer in which to construct the data to be passed to VTAM.
; 6760 :                 pLCSIBH = alloc_lcs_buffer( pLCSDEV, ( INBOUND_4C25_SIZE * 2 ) );

  02350	ba 5c 00 00 00	 mov	 edx, 92			; 0000005cH
  02355	48 8b 8c 24 18
	03 00 00	 mov	 rcx, QWORD PTR pLCSDEV$[rsp]
  0235d	e8 00 00 00 00	 call	 alloc_lcs_buffer
  02362	48 89 84 24 88
	00 00 00	 mov	 QWORD PTR pLCSIBH$[rsp], rax

; 6761 : 
; 6762 :                 memcpy( &pLCSIBH->bData, Inbound_4C25, INBOUND_4C25_SIZE );

  0236a	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR pLCSIBH$[rsp]
  02372	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:?Inbound_4C25@?1??LCS_ProcessAccepted_SNA@@9@9
  02379	48 8d 78 10	 lea	 rdi, QWORD PTR [rax+16]
  0237d	48 8b f1	 mov	 rsi, rcx
  02380	b9 2e 00 00 00	 mov	 ecx, 46			; 0000002eH
  02385	f3 a4		 rep movsb

; 6763 :                 pLCSIBH->iDataLen = INBOUND_4C25_SIZE;

  02387	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR pLCSIBH$[rsp]
  0238f	c7 40 0c 2e 00
	00 00		 mov	 DWORD PTR [rax+12], 46	; 0000002eH

; 6764 : 
; 6765 :                 pLCSHDR = (PLCSHDR)&pLCSIBH->bData;

  02396	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR pLCSIBH$[rsp]
  0239e	48 83 c0 10	 add	 rax, 16
  023a2	48 89 84 24 c0
	00 00 00	 mov	 QWORD PTR pLCSHDR$[rsp], rax

; 6766 :                 pLCSBAF1 = (PLCSBAF1)( (BYTE*)pLCSHDR + sizeof(LCSHDR) );

  023aa	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR pLCSHDR$[rsp]
  023b2	48 83 c0 04	 add	 rax, 4
  023b6	48 89 84 24 98
	00 00 00	 mov	 QWORD PTR pLCSBAF1$[rsp], rax

; 6767 :                 FETCH_HW( hwLenBaf1, pLCSBAF1->hwLenBaf1 );

  023be	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR pLCSBAF1$[rsp]
  023c6	48 8b c8	 mov	 rcx, rax
  023c9	e8 00 00 00 00	 call	 fetch_hw_noswap
  023ce	0f b7 c8	 movzx	 ecx, ax
  023d1	e8 00 00 00 00	 call	 _byteswap_ushort
  023d6	66 89 84 24 90
	00 00 00	 mov	 WORD PTR hwLenBaf1$[rsp], ax

; 6768 :                 FETCH_HW( hwLenBaf2, pLCSBAF1->hwLenBaf2 );

  023de	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR pLCSBAF1$[rsp]
  023e6	48 83 c0 04	 add	 rax, 4
  023ea	48 8b c8	 mov	 rcx, rax
  023ed	e8 00 00 00 00	 call	 fetch_hw_noswap
  023f2	0f b7 c8	 movzx	 ecx, ax
  023f5	e8 00 00 00 00	 call	 _byteswap_ushort
  023fa	66 89 44 24 78	 mov	 WORD PTR hwLenBaf2$[rsp], ax

; 6769 :                 pLCSBAF2 = (PLCSBAF2)( (BYTE*)pLCSBAF1 + hwLenBaf1 );

  023ff	0f b7 84 24 90
	00 00 00	 movzx	 eax, WORD PTR hwLenBaf1$[rsp]
  02407	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR pLCSBAF1$[rsp]
  0240f	48 03 c8	 add	 rcx, rax
  02412	48 8b c1	 mov	 rax, rcx
  02415	48 89 84 24 b8
	00 00 00	 mov	 QWORD PTR pLCSBAF2$[rsp], rax

; 6770 : 
; 6771 :                 //
; 6772 :                 pLCSCONN->hwXIDSeqNum++;

  0241d	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR pLCSCONN$[rsp]
  02425	0f b7 40 20	 movzx	 eax, WORD PTR [rax+32]
  02429	66 ff c0	 inc	 ax
  0242c	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR pLCSCONN$[rsp]
  02434	66 89 41 20	 mov	 WORD PTR [rcx+32], ax

; 6773 :                 STORE_HW( pLCSBAF2->hwSeqNum, pLCSCONN->hwXIDSeqNum );

  02438	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR pLCSCONN$[rsp]
  02440	0f b7 48 20	 movzx	 ecx, WORD PTR [rax+32]
  02444	e8 00 00 00 00	 call	 _byteswap_ushort
  02449	48 8b 8c 24 b8
	00 00 00	 mov	 rcx, QWORD PTR pLCSBAF2$[rsp]
  02451	48 ff c1	 inc	 rcx
  02454	0f b7 d0	 movzx	 edx, ax
  02457	e8 00 00 00 00	 call	 store_hw_noswap

; 6774 : 
; 6775 :                 // Copy the destination MAC address, the source MAC addresses, and the LLC to the buffer.
; 6776 :                 memcpy( &pLCSBAF2->bByte12, &pEthFrame->bDestMAC, IFHWADDRLEN );

  0245c	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR pLCSBAF2$[rsp]
  02464	48 8d 78 0c	 lea	 rdi, QWORD PTR [rax+12]
  02468	48 8b b4 24 b0
	00 00 00	 mov	 rsi, QWORD PTR pEthFrame$[rsp]
  02470	b9 06 00 00 00	 mov	 ecx, 6
  02475	f3 a4		 rep movsb

; 6777 :                 memcpy( &pLCSBAF2->bByte18, &pEthFrame->bSrcMAC, IFHWADDRLEN );

  02477	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR pLCSBAF2$[rsp]
  0247f	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR pEthFrame$[rsp]
  02487	48 8d 78 12	 lea	 rdi, QWORD PTR [rax+18]
  0248b	48 8d 71 06	 lea	 rsi, QWORD PTR [rcx+6]
  0248f	b9 06 00 00 00	 mov	 ecx, 6
  02494	f3 a4		 rep movsb

; 6778 :                 memcpy( &pLCSBAF2->bByte24, &pEthFrame->bData, 3 );

  02496	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR pLCSBAF2$[rsp]
  0249e	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR pEthFrame$[rsp]
  024a6	48 8d 78 18	 lea	 rdi, QWORD PTR [rax+24]
  024aa	48 8d 71 0e	 lea	 rsi, QWORD PTR [rcx+14]
  024ae	b9 03 00 00 00	 mov	 ecx, 3
  024b3	f3 a4		 rep movsb

; 6779 : 
; 6780 :                 // Add the buffer containing the reply to the chain.
; 6781 :                 add_lcs_buffer_to_chain( pLCSDEV, pLCSIBH );

  024b5	48 8b 94 24 88
	00 00 00	 mov	 rdx, QWORD PTR pLCSIBH$[rsp]
  024bd	48 8b 8c 24 18
	03 00 00	 mov	 rcx, QWORD PTR pLCSDEV$[rsp]
  024c5	e8 00 00 00 00	 call	 add_lcs_buffer_to_chain

; 6782 : 
; 6783 :                 fAttnRequired = TRUE;

  024ca	c6 44 24 74 01	 mov	 BYTE PTR fAttnRequired$[rsp], 1

; 6784 : 
; 6785 :             }

  024cf	e9 73 03 00 00	 jmp	 $LN117@LCS_Proces
$LN116@LCS_Proces:

; 6786 :             else  // Command. Respond to the TEST from the remote system.
; 6787 :             {
; 6788 : 
; 6789 :                 memset( frameout, 0, sizeof(frameout) );       // Clear area for ethernet fram

  024d4	48 8d 84 24 a0
	02 00 00	 lea	 rax, QWORD PTR frameout$[rsp]
  024dc	48 8b f8	 mov	 rdi, rax
  024df	33 c0		 xor	 eax, eax
  024e1	b9 40 00 00 00	 mov	 ecx, 64			; 00000040H
  024e6	f3 aa		 rep stosb

; 6790 :                 pEthFrameOut = (PETHFRM)&frameout[0];

  024e8	b8 01 00 00 00	 mov	 eax, 1
  024ed	48 6b c0 00	 imul	 rax, rax, 0
  024f1	48 8d 84 04 a0
	02 00 00	 lea	 rax, QWORD PTR frameout$[rsp+rax]
  024f9	48 89 84 24 d0
	00 00 00	 mov	 QWORD PTR pEthFrameOut$[rsp], rax

; 6791 :                 iEthLenOut = 60;                               // Minimum ethernet frame length

  02501	c7 84 24 94 00
	00 00 3c 00 00
	00		 mov	 DWORD PTR iEthLenOut$[rsp], 60 ; 0000003cH

; 6792 : 
; 6793 :                 //
; 6794 :                 memset( &llcout, 0, sizeof(LLC) );

  0250c	48 8d 84 24 68
	01 00 00	 lea	 rax, QWORD PTR llcout$[rsp]
  02514	48 8b f8	 mov	 rdi, rax
  02517	33 c0		 xor	 eax, eax
  02519	b9 2e 00 00 00	 mov	 ecx, 46			; 0000002eH
  0251e	f3 aa		 rep stosb

; 6795 :                 llcout.hwDSAP    = llc.hwSSAP;                       // Copy LLC command SSAP as response DSAP

  02520	0f b7 84 24 4a
	01 00 00	 movzx	 eax, WORD PTR llc$[rsp+18]
  02528	66 89 84 24 76
	01 00 00	 mov	 WORD PTR llcout$[rsp+14], ax

; 6796 :                 llcout.hwSSAP    = llc.hwDSAP;                       // Copy LLC command DSAP as response SSAP

  02530	0f b7 84 24 46
	01 00 00	 movzx	 eax, WORD PTR llc$[rsp+14]
  02538	66 89 84 24 7a
	01 00 00	 mov	 WORD PTR llcout$[rsp+18], ax

; 6797 :                 llcout.hwCR      = 1;

  02540	b8 01 00 00 00	 mov	 eax, 1
  02545	66 89 84 24 7c
	01 00 00	 mov	 WORD PTR llcout$[rsp+20], ax

; 6798 :                 llcout.hwPF      = 1;

  0254d	b8 01 00 00 00	 mov	 eax, 1
  02552	66 89 84 24 82
	01 00 00	 mov	 WORD PTR llcout$[rsp+26], ax

; 6799 :                 llcout.hwM       = M_TEST_Command_or_Response;

  0255a	b8 1c 00 00 00	 mov	 eax, 28
  0255f	66 89 84 24 86
	01 00 00	 mov	 WORD PTR llcout$[rsp+30], ax

; 6800 :                 llcout.hwType    = Type_Unnumbered_Frame;

  02567	b8 03 00 00 00	 mov	 eax, 3
  0256c	66 89 84 24 94
	01 00 00	 mov	 WORD PTR llcout$[rsp+44], ax

; 6801 : 
; 6802 :                 // Construct Ethernet frame
; 6803 :                 memcpy( &pEthFrameOut->bDestMAC, &pEthFrame->bSrcMAC, IFHWADDRLEN );  // Copy destination MAC address

  02574	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR pEthFrame$[rsp]
  0257c	48 8b bc 24 d0
	00 00 00	 mov	 rdi, QWORD PTR pEthFrameOut$[rsp]
  02584	48 8d 70 06	 lea	 rsi, QWORD PTR [rax+6]
  02588	b9 06 00 00 00	 mov	 ecx, 6
  0258d	f3 a4		 rep movsb

; 6804 :                 memcpy( &pEthFrameOut->bSrcMAC, &pEthFrame->bDestMAC, IFHWADDRLEN );  // Copy source MAC address

  0258f	48 8b 84 24 d0
	00 00 00	 mov	 rax, QWORD PTR pEthFrameOut$[rsp]
  02597	48 8d 78 06	 lea	 rdi, QWORD PTR [rax+6]
  0259b	48 8b b4 24 b0
	00 00 00	 mov	 rsi, QWORD PTR pEthFrame$[rsp]
  025a3	b9 06 00 00 00	 mov	 ecx, 6
  025a8	f3 a4		 rep movsb

; 6805 :                 iLPDULenOut = BuildLLC( &llcout, pEthFrameOut->bData);                // Build LLC PDU

  025aa	48 8b 84 24 d0
	00 00 00	 mov	 rax, QWORD PTR pEthFrameOut$[rsp]
  025b2	48 83 c0 0e	 add	 rax, 14
  025b6	48 8b d0	 mov	 rdx, rax
  025b9	48 8d 8c 24 68
	01 00 00	 lea	 rcx, QWORD PTR llcout$[rsp]
  025c1	e8 00 00 00 00	 call	 BuildLLC
  025c6	89 84 24 d8 00
	00 00		 mov	 DWORD PTR iLPDULenOut$[rsp], eax

; 6806 :                 STORE_HW( pEthFrameOut->hwEthernetType, (U16)iLPDULenOut );           // Set data length

  025cd	0f b7 8c 24 d8
	00 00 00	 movzx	 ecx, WORD PTR iLPDULenOut$[rsp]
  025d5	e8 00 00 00 00	 call	 _byteswap_ushort
  025da	48 8b 8c 24 d0
	00 00 00	 mov	 rcx, QWORD PTR pEthFrameOut$[rsp]
  025e2	48 83 c1 0c	 add	 rcx, 12
  025e6	0f b7 d0	 movzx	 edx, ax
  025e9	e8 00 00 00 00	 call	 store_hw_noswap

; 6807 : 
; 6808 :                 // Trace Ethernet frame before sending to TAP device
; 6809 :                 if (pLCSBLK->fDebug)

  025ee	48 8b 84 24 c8
	00 00 00	 mov	 rax, QWORD PTR pLCSBLK$[rsp]
  025f6	8b 40 18	 mov	 eax, DWORD PTR [rax+24]
  025f9	83 e0 01	 and	 eax, 1
  025fc	85 c0		 test	 eax, eax
  025fe	0f 84 19 01 00
	00		 je	 $LN119@LCS_Proces

; 6810 :                 {
; 6811 :                     // "%1d:%04X %s: port %2.2X: Send frame of size %d bytes (with %s packet) to device %s"
; 6812 :                     WRMSG(HHC00983, "D", SSID_TO_LCSS(pDEVBLK->ssid), pDEVBLK->devnum, pDEVBLK->typname,

  02604	48 8b 84 24 10
	03 00 00	 mov	 rax, QWORD PTR pLCSPORT$[rsp]
  0260c	48 05 48 01 00
	00		 add	 rax, 328		; 00000148H
  02612	48 89 84 24 30
	01 00 00	 mov	 QWORD PTR tv1607[rsp], rax
  0261a	48 8b 8c 24 18
	03 00 00	 mov	 rcx, QWORD PTR pLCSDEV$[rsp]
  02622	0f b6 49 23	 movzx	 ecx, BYTE PTR [rcx+35]
  02626	89 8c 24 fc 00
	00 00		 mov	 DWORD PTR tv1612[rsp], ecx
  0262d	48 8b 94 24 a0
	00 00 00	 mov	 rdx, QWORD PTR pDEVBLK$[rsp]
  02635	0f b7 52 48	 movzx	 edx, WORD PTR [rdx+72]
  02639	89 94 24 00 01
	00 00		 mov	 DWORD PTR tv1617[rsp], edx
  02640	48 8b bc 24 a0
	00 00 00	 mov	 rdi, QWORD PTR pDEVBLK$[rsp]
  02648	0f b7 7f 44	 movzx	 edi, WORD PTR [rdi+68]
  0264c	d1 ff		 sar	 edi, 1
  0264e	b9 01 00 00 00	 mov	 ecx, 1
  02653	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  02659	48 8b 8c 24 30
	01 00 00	 mov	 rcx, QWORD PTR tv1607[rsp]
  02661	48 89 4c 24 68	 mov	 QWORD PTR [rsp+104], rcx
  02666	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG175331
  0266d	48 89 4c 24 60	 mov	 QWORD PTR [rsp+96], rcx
  02672	8b 8c 24 94 00
	00 00		 mov	 ecx, DWORD PTR iEthLenOut$[rsp]
  02679	89 4c 24 58	 mov	 DWORD PTR [rsp+88], ecx
  0267d	8b 8c 24 fc 00
	00 00		 mov	 ecx, DWORD PTR tv1612[rsp]
  02684	89 4c 24 50	 mov	 DWORD PTR [rsp+80], ecx
  02688	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR pDEVBLK$[rsp]
  02690	48 8b 49 50	 mov	 rcx, QWORD PTR [rcx+80]
  02694	48 89 4c 24 48	 mov	 QWORD PTR [rsp+72], rcx
  02699	8b 8c 24 00 01
	00 00		 mov	 ecx, DWORD PTR tv1617[rsp]
  026a0	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  026a4	89 7c 24 38	 mov	 DWORD PTR [rsp+56], edi
  026a8	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG175332
  026af	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  026b4	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG175333
  026bb	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  026c0	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  026c5	41 b9 03 00 00
	00		 mov	 r9d, 3
  026cb	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG175334
  026d2	ba 9d 1a 00 00	 mov	 edx, 6813		; 00001a9dH
  026d7	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG175335
  026de	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 6813 :                                          pLCSDEV->bPort, iEthLenOut, "802.3 SNA", pLCSPORT->szNetIfName );
; 6814 :                     net_data_trace( pDEVBLK, (BYTE*)pEthFrameOut, iEthLenOut, FROM_GUEST, 'D', "eth frame", 0 );

  026e4	c7 44 24 30 00
	00 00 00	 mov	 DWORD PTR [rsp+48], 0
  026ec	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG175336
  026f3	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  026f8	c6 44 24 20 44	 mov	 BYTE PTR [rsp+32], 68	; 00000044H
  026fd	41 b1 3c	 mov	 r9b, 60			; 0000003cH
  02700	44 8b 84 24 94
	00 00 00	 mov	 r8d, DWORD PTR iEthLenOut$[rsp]
  02708	48 8b 94 24 d0
	00 00 00	 mov	 rdx, QWORD PTR pEthFrameOut$[rsp]
  02710	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR pDEVBLK$[rsp]
  02718	e8 00 00 00 00	 call	 net_data_trace
$LN119@LCS_Proces:

; 6815 :                 }
; 6816 : 
; 6817 :                 // Write the Ethernet frame to the TAP device
; 6818 :                 if (TUNTAP_Write( pDEVBLK->fd, (BYTE*)pEthFrameOut, iEthLenOut ) == iEthLenOut)

  0271d	44 8b 84 24 94
	00 00 00	 mov	 r8d, DWORD PTR iEthLenOut$[rsp]
  02725	48 8b 94 24 d0
	00 00 00	 mov	 rdx, QWORD PTR pEthFrameOut$[rsp]
  0272d	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR pDEVBLK$[rsp]
  02735	8b 88 ac 01 00
	00		 mov	 ecx, DWORD PTR [rax+428]
  0273b	e8 00 00 00 00	 call	 tt32_write
  02740	3b 84 24 94 00
	00 00		 cmp	 eax, DWORD PTR iEthLenOut$[rsp]
  02747	0f 85 a1 00 00
	00		 jne	 $LN120@LCS_Proces

; 6819 :                 {
; 6820 :                     if (pLCSPORT->pLCSBLK->fDebug)

  0274d	48 8b 84 24 10
	03 00 00	 mov	 rax, QWORD PTR pLCSPORT$[rsp]
  02755	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  02759	8b 40 18	 mov	 eax, DWORD PTR [rax+24]
  0275c	83 e0 01	 and	 eax, 1
  0275f	85 c0		 test	 eax, eax
  02761	0f 84 85 00 00
	00		 je	 $LN122@LCS_Proces

; 6821 :                     {
; 6822 :                         snprintf( llcmsg, sizeof(llcmsg), "LCS: LLC unnumbered frame sent: CR=%u, M=%s", llc.hwCR, "TEST" );

  02767	0f b7 84 24 4c
	01 00 00	 movzx	 eax, WORD PTR llc$[rsp+20]
  0276f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG175340
  02776	48 89 4c 24 20	 mov	 QWORD PTR [rsp+32], rcx
  0277b	44 8b c8	 mov	 r9d, eax
  0277e	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG175341
  02785	ba 00 01 00 00	 mov	 edx, 256		; 00000100H
  0278a	48 8d 8c 24 a0
	01 00 00	 lea	 rcx, QWORD PTR llcmsg$[rsp]
  02792	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_snprintf

; 6823 :                         WRMSG(HHC03984, "D", llcmsg );

  02798	b9 01 00 00 00	 mov	 ecx, 1
  0279d	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  027a3	48 8d 8c 24 a0
	01 00 00	 lea	 rcx, QWORD PTR llcmsg$[rsp]
  027ab	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  027b0	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG175342
  027b7	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  027bc	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG175343
  027c3	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  027c8	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  027cd	41 b9 03 00 00
	00		 mov	 r9d, 3
  027d3	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG175344
  027da	ba a7 1a 00 00	 mov	 edx, 6823		; 00001aa7H
  027df	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG175345
  027e6	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg
$LN122@LCS_Proces:

; 6824 :                     }
; 6825 :                 }

  027ec	eb 59		 jmp	 SHORT $LN121@LCS_Proces
$LN120@LCS_Proces:
$LN28@LCS_Proces:

; 6826 :                 else
; 6827 :                 {
; 6828 :     //??            pLCSDEV->iTuntapErrno = errno;
; 6829 :     //??            pLCSDEV->fTuntapError = TRUE;
; 6830 :                     PTT_TIMING( "*WRITE ERR", 0, iEthLenOut, 1 );

  027ee	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_pttclass
  027f5	48 8b 00	 mov	 rax, QWORD PTR [rax]
  027f8	48 25 00 00 01
	00		 and	 rax, 65536		; 00010000H
  027fe	48 85 c0	 test	 rax, rax
  02801	74 3e		 je	 SHORT $LN123@LCS_Proces
  02803	48 63 84 24 94
	00 00 00	 movsxd	 rax, DWORD PTR iEthLenOut$[rsp]
  0280b	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR [rsp+48], 0
  02814	48 c7 44 24 28
	01 00 00 00	 mov	 QWORD PTR [rsp+40], 1
  0281d	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG175347
  02824	48 89 4c 24 20	 mov	 QWORD PTR [rsp+32], rcx
  02829	4c 8b c8	 mov	 r9, rax
  0282c	45 33 c0	 xor	 r8d, r8d
  0282f	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG175348
  02836	b9 00 00 01 00	 mov	 ecx, 65536		; 00010000H
  0283b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ptt_pthread_trace
$LN123@LCS_Proces:
  02841	33 c0		 xor	 eax, eax
  02843	85 c0		 test	 eax, eax
  02845	75 a7		 jne	 SHORT $LN28@LCS_Proces
$LN121@LCS_Proces:
$LN117@LCS_Proces:

; 6831 :                 }
; 6832 : 
; 6833 :             }
; 6834 : 
; 6835 :             break;

  02847	eb 05		 jmp	 SHORT $LN24@LCS_Proces
$LN124@LCS_Proces:

; 6836 : 
; 6837 :         // Unnumbered Frame: Unknown.
; 6838 :         default:
; 6839 :             goto msg970_return;

  02849	e9 00 04 00 00	 jmp	 $msg970_return$140
$LN24@LCS_Proces:

; 6840 : 
; 6841 :         }
; 6842 : 
; 6843 :         break;

  0284e	eb 05		 jmp	 SHORT $LN5@LCS_Proces
$LN125@LCS_Proces:

; 6844 : 
; 6845 :     // Unknown frame. This should not occur!
; 6846 :     default:
; 6847 :         goto msg970_return;

  02850	e9 f9 03 00 00	 jmp	 $msg970_return$140
$LN5@LCS_Proces:

; 6848 : 
; 6849 :     }
; 6850 : 
; 6851 :     if (fAttnRequired)

  02855	0f b6 44 24 74	 movzx	 eax, BYTE PTR fAttnRequired$[rsp]
  0285a	85 c0		 test	 eax, eax
  0285c	0f 84 ea 03 00
	00		 je	 $LN126@LCS_Proces

; 6852 :     {
; 6853 :         // It would have been nice to have simply called function
; 6854 :         // device_attention at this point, but the channel program
; 6855 :         // is still considered to be busy, and a return code of one
; 6856 :         // would be returned to us.
; 6857 : 
; 6858 :         /* Create an LCSATTN block */
; 6859 :         pLCSATTN = malloc( sizeof( LCSATTN ) );

  02862	b9 10 00 00 00	 mov	 ecx, 16
  02867	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_malloc
  0286d	48 89 84 24 f0
	00 00 00	 mov	 QWORD PTR pLCSATTN$[rsp], rax

; 6860 :         if (!pLCSATTN) return;  /* FixMe! Produce a message? */

  02875	48 83 bc 24 f0
	00 00 00 00	 cmp	 QWORD PTR pLCSATTN$[rsp], 0
  0287e	75 05		 jne	 SHORT $LN127@LCS_Proces
  02880	e9 43 04 00 00	 jmp	 $LN1@LCS_Proces
$LN127@LCS_Proces:

; 6861 :         pLCSATTN->pNext = NULL;

  02885	48 8b 84 24 f0
	00 00 00	 mov	 rax, QWORD PTR pLCSATTN$[rsp]
  0288d	48 c7 00 00 00
	00 00		 mov	 QWORD PTR [rax], 0

; 6862 :         pLCSATTN->pDevice = pLCSDEV;

  02894	48 8b 84 24 f0
	00 00 00	 mov	 rax, QWORD PTR pLCSATTN$[rsp]
  0289c	48 8b 8c 24 18
	03 00 00	 mov	 rcx, QWORD PTR pLCSDEV$[rsp]
  028a4	48 89 48 08	 mov	 QWORD PTR [rax+8], rcx
$LN31@LCS_Proces:

; 6863 : 
; 6864 :         /* Add LCSATTN block to start of chain */
; 6865 :         PTT_DEBUG( "GET  AttnLock", 000, pDEVBLK->devnum, 000 );

  028a8	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_pttclass
  028af	48 8b 00	 mov	 rax, QWORD PTR [rax]
  028b2	48 25 00 00 02
	00		 and	 rax, 131072		; 00020000H
  028b8	48 85 c0	 test	 rax, rax
  028bb	74 42		 je	 SHORT $LN128@LCS_Proces
  028bd	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR pDEVBLK$[rsp]
  028c5	0f b7 40 48	 movzx	 eax, WORD PTR [rax+72]
  028c9	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR [rsp+48], 0
  028d2	48 c7 44 24 28
	00 00 00 00	 mov	 QWORD PTR [rsp+40], 0
  028db	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG175354
  028e2	48 89 4c 24 20	 mov	 QWORD PTR [rsp+32], rcx
  028e7	44 8b c8	 mov	 r9d, eax
  028ea	45 33 c0	 xor	 r8d, r8d
  028ed	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG175355
  028f4	b9 00 00 02 00	 mov	 ecx, 131072		; 00020000H
  028f9	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ptt_pthread_trace
$LN128@LCS_Proces:
  028ff	33 c0		 xor	 eax, eax
  02901	85 c0		 test	 eax, eax
  02903	75 a3		 jne	 SHORT $LN31@LCS_Proces

; 6866 :         obtain_lock( &pLCSBLK->AttnLock );

  02905	48 8b 84 24 c8
	00 00 00	 mov	 rax, QWORD PTR pLCSBLK$[rsp]
  0290d	48 83 c0 30	 add	 rax, 48			; 00000030H
  02911	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG175356
  02918	48 8b c8	 mov	 rcx, rax
  0291b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_obtain_lock
$LN34@LCS_Proces:

; 6867 :         PTT_DEBUG( "GOT  AttnLock", 000, pDEVBLK->devnum, 000 );

  02921	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_pttclass
  02928	48 8b 00	 mov	 rax, QWORD PTR [rax]
  0292b	48 25 00 00 02
	00		 and	 rax, 131072		; 00020000H
  02931	48 85 c0	 test	 rax, rax
  02934	74 42		 je	 SHORT $LN129@LCS_Proces
  02936	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR pDEVBLK$[rsp]
  0293e	0f b7 40 48	 movzx	 eax, WORD PTR [rax+72]
  02942	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR [rsp+48], 0
  0294b	48 c7 44 24 28
	00 00 00 00	 mov	 QWORD PTR [rsp+40], 0
  02954	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG175358
  0295b	48 89 4c 24 20	 mov	 QWORD PTR [rsp+32], rcx
  02960	44 8b c8	 mov	 r9d, eax
  02963	45 33 c0	 xor	 r8d, r8d
  02966	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG175359
  0296d	b9 00 00 02 00	 mov	 ecx, 131072		; 00020000H
  02972	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ptt_pthread_trace
$LN129@LCS_Proces:
  02978	33 c0		 xor	 eax, eax
  0297a	85 c0		 test	 eax, eax
  0297c	75 a3		 jne	 SHORT $LN34@LCS_Proces
$LN37@LCS_Proces:

; 6868 :         {
; 6869 :             PTT_DEBUG( "ADD  Attn", pLCSATTN, pDEVBLK->devnum, 000 );

  0297e	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_pttclass
  02985	48 8b 00	 mov	 rax, QWORD PTR [rax]
  02988	48 25 00 00 02
	00		 and	 rax, 131072		; 00020000H
  0298e	48 85 c0	 test	 rax, rax
  02991	74 47		 je	 SHORT $LN130@LCS_Proces
  02993	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR pDEVBLK$[rsp]
  0299b	0f b7 40 48	 movzx	 eax, WORD PTR [rax+72]
  0299f	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR [rsp+48], 0
  029a8	48 c7 44 24 28
	00 00 00 00	 mov	 QWORD PTR [rsp+40], 0
  029b1	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG175361
  029b8	48 89 4c 24 20	 mov	 QWORD PTR [rsp+32], rcx
  029bd	44 8b c8	 mov	 r9d, eax
  029c0	4c 8b 84 24 f0
	00 00 00	 mov	 r8, QWORD PTR pLCSATTN$[rsp]
  029c8	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG175362
  029cf	b9 00 00 02 00	 mov	 ecx, 131072		; 00020000H
  029d4	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ptt_pthread_trace
$LN130@LCS_Proces:
  029da	33 c0		 xor	 eax, eax
  029dc	85 c0		 test	 eax, eax
  029de	75 9e		 jne	 SHORT $LN37@LCS_Proces

; 6870 :             pLCSATTN->pNext = pLCSBLK->pAttns;

  029e0	48 8b 84 24 f0
	00 00 00	 mov	 rax, QWORD PTR pLCSATTN$[rsp]
  029e8	48 8b 8c 24 c8
	00 00 00	 mov	 rcx, QWORD PTR pLCSBLK$[rsp]
  029f0	48 8b 49 38	 mov	 rcx, QWORD PTR [rcx+56]
  029f4	48 89 08	 mov	 QWORD PTR [rax], rcx

; 6871 :             pLCSBLK->pAttns = pLCSATTN;

  029f7	48 8b 84 24 c8
	00 00 00	 mov	 rax, QWORD PTR pLCSBLK$[rsp]
  029ff	48 8b 8c 24 f0
	00 00 00	 mov	 rcx, QWORD PTR pLCSATTN$[rsp]
  02a07	48 89 48 38	 mov	 QWORD PTR [rax+56], rcx
$LN40@LCS_Proces:

; 6872 :         }
; 6873 :         PTT_DEBUG( "REL  AttnLock", 000, pDEVBLK->devnum, 000 );

  02a0b	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_pttclass
  02a12	48 8b 00	 mov	 rax, QWORD PTR [rax]
  02a15	48 25 00 00 02
	00		 and	 rax, 131072		; 00020000H
  02a1b	48 85 c0	 test	 rax, rax
  02a1e	74 42		 je	 SHORT $LN131@LCS_Proces
  02a20	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR pDEVBLK$[rsp]
  02a28	0f b7 40 48	 movzx	 eax, WORD PTR [rax+72]
  02a2c	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR [rsp+48], 0
  02a35	48 c7 44 24 28
	00 00 00 00	 mov	 QWORD PTR [rsp+40], 0
  02a3e	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG175364
  02a45	48 89 4c 24 20	 mov	 QWORD PTR [rsp+32], rcx
  02a4a	44 8b c8	 mov	 r9d, eax
  02a4d	45 33 c0	 xor	 r8d, r8d
  02a50	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG175365
  02a57	b9 00 00 02 00	 mov	 ecx, 131072		; 00020000H
  02a5c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ptt_pthread_trace
$LN131@LCS_Proces:
  02a62	33 c0		 xor	 eax, eax
  02a64	85 c0		 test	 eax, eax
  02a66	75 a3		 jne	 SHORT $LN40@LCS_Proces

; 6874 :         release_lock( &pLCSBLK->AttnLock );

  02a68	48 8b 84 24 c8
	00 00 00	 mov	 rax, QWORD PTR pLCSBLK$[rsp]
  02a70	48 83 c0 30	 add	 rax, 48			; 00000030H
  02a74	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG175366
  02a7b	48 8b c8	 mov	 rcx, rax
  02a7e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_release_lock
$LN43@LCS_Proces:

; 6875 : 
; 6876 :         /* Signal the LCS_AttnThread to process the LCSATTN block(s) on the chain */
; 6877 :         PTT_DEBUG( "GET  AttnEventLock ", 000, pDEVBLK->devnum, 000 );

  02a84	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_pttclass
  02a8b	48 8b 00	 mov	 rax, QWORD PTR [rax]
  02a8e	48 25 00 00 02
	00		 and	 rax, 131072		; 00020000H
  02a94	48 85 c0	 test	 rax, rax
  02a97	74 42		 je	 SHORT $LN132@LCS_Proces
  02a99	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR pDEVBLK$[rsp]
  02aa1	0f b7 40 48	 movzx	 eax, WORD PTR [rax+72]
  02aa5	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR [rsp+48], 0
  02aae	48 c7 44 24 28
	00 00 00 00	 mov	 QWORD PTR [rsp+40], 0
  02ab7	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG175368
  02abe	48 89 4c 24 20	 mov	 QWORD PTR [rsp+32], rcx
  02ac3	44 8b c8	 mov	 r9d, eax
  02ac6	45 33 c0	 xor	 r8d, r8d
  02ac9	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG175369
  02ad0	b9 00 00 02 00	 mov	 ecx, 131072		; 00020000H
  02ad5	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ptt_pthread_trace
$LN132@LCS_Proces:
  02adb	33 c0		 xor	 eax, eax
  02add	85 c0		 test	 eax, eax
  02adf	75 a3		 jne	 SHORT $LN43@LCS_Proces

; 6878 :         obtain_lock( &pLCSBLK->AttnEventLock );

  02ae1	48 8b 84 24 c8
	00 00 00	 mov	 rax, QWORD PTR pLCSBLK$[rsp]
  02ae9	48 83 c0 40	 add	 rax, 64			; 00000040H
  02aed	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG175370
  02af4	48 8b c8	 mov	 rcx, rax
  02af7	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_obtain_lock
$LN46@LCS_Proces:

; 6879 :         PTT_DEBUG( "GOT  AttnEventLock ", 000, pDEVBLK->devnum, 000 );

  02afd	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_pttclass
  02b04	48 8b 00	 mov	 rax, QWORD PTR [rax]
  02b07	48 25 00 00 02
	00		 and	 rax, 131072		; 00020000H
  02b0d	48 85 c0	 test	 rax, rax
  02b10	74 42		 je	 SHORT $LN133@LCS_Proces
  02b12	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR pDEVBLK$[rsp]
  02b1a	0f b7 40 48	 movzx	 eax, WORD PTR [rax+72]
  02b1e	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR [rsp+48], 0
  02b27	48 c7 44 24 28
	00 00 00 00	 mov	 QWORD PTR [rsp+40], 0
  02b30	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG175372
  02b37	48 89 4c 24 20	 mov	 QWORD PTR [rsp+32], rcx
  02b3c	44 8b c8	 mov	 r9d, eax
  02b3f	45 33 c0	 xor	 r8d, r8d
  02b42	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG175373
  02b49	b9 00 00 02 00	 mov	 ecx, 131072		; 00020000H
  02b4e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ptt_pthread_trace
$LN133@LCS_Proces:
  02b54	33 c0		 xor	 eax, eax
  02b56	85 c0		 test	 eax, eax
  02b58	75 a3		 jne	 SHORT $LN46@LCS_Proces
$LN49@LCS_Proces:

; 6880 :         {
; 6881 :             PTT_DEBUG( "SIG  AttnEvent", 000, pDEVBLK->devnum, 000 );

  02b5a	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_pttclass
  02b61	48 8b 00	 mov	 rax, QWORD PTR [rax]
  02b64	48 25 00 00 02
	00		 and	 rax, 131072		; 00020000H
  02b6a	48 85 c0	 test	 rax, rax
  02b6d	74 42		 je	 SHORT $LN134@LCS_Proces
  02b6f	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR pDEVBLK$[rsp]
  02b77	0f b7 40 48	 movzx	 eax, WORD PTR [rax+72]
  02b7b	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR [rsp+48], 0
  02b84	48 c7 44 24 28
	00 00 00 00	 mov	 QWORD PTR [rsp+40], 0
  02b8d	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG175375
  02b94	48 89 4c 24 20	 mov	 QWORD PTR [rsp+32], rcx
  02b99	44 8b c8	 mov	 r9d, eax
  02b9c	45 33 c0	 xor	 r8d, r8d
  02b9f	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG175376
  02ba6	b9 00 00 02 00	 mov	 ecx, 131072		; 00020000H
  02bab	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ptt_pthread_trace
$LN134@LCS_Proces:
  02bb1	33 c0		 xor	 eax, eax
  02bb3	85 c0		 test	 eax, eax
  02bb5	75 a3		 jne	 SHORT $LN49@LCS_Proces

; 6882 :             signal_condition( &pLCSBLK->AttnEvent );

  02bb7	48 8b 84 24 c8
	00 00 00	 mov	 rax, QWORD PTR pLCSBLK$[rsp]
  02bbf	48 83 c0 48	 add	 rax, 72			; 00000048H
  02bc3	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG175377
  02bca	48 8b c8	 mov	 rcx, rax
  02bcd	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_signal_condition
$LN52@LCS_Proces:

; 6883 :         }
; 6884 :         PTT_DEBUG( "REL  AttnEventLock ", 000, pDEVBLK->devnum, 000 );

  02bd3	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_pttclass
  02bda	48 8b 00	 mov	 rax, QWORD PTR [rax]
  02bdd	48 25 00 00 02
	00		 and	 rax, 131072		; 00020000H
  02be3	48 85 c0	 test	 rax, rax
  02be6	74 42		 je	 SHORT $LN135@LCS_Proces
  02be8	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR pDEVBLK$[rsp]
  02bf0	0f b7 40 48	 movzx	 eax, WORD PTR [rax+72]
  02bf4	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR [rsp+48], 0
  02bfd	48 c7 44 24 28
	00 00 00 00	 mov	 QWORD PTR [rsp+40], 0
  02c06	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG175379
  02c0d	48 89 4c 24 20	 mov	 QWORD PTR [rsp+32], rcx
  02c12	44 8b c8	 mov	 r9d, eax
  02c15	45 33 c0	 xor	 r8d, r8d
  02c18	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG175380
  02c1f	b9 00 00 02 00	 mov	 ecx, 131072		; 00020000H
  02c24	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ptt_pthread_trace
$LN135@LCS_Proces:
  02c2a	33 c0		 xor	 eax, eax
  02c2c	85 c0		 test	 eax, eax
  02c2e	75 a3		 jne	 SHORT $LN52@LCS_Proces

; 6885 :         release_lock( &pLCSBLK->AttnEventLock );

  02c30	48 8b 84 24 c8
	00 00 00	 mov	 rax, QWORD PTR pLCSBLK$[rsp]
  02c38	48 83 c0 40	 add	 rax, 64			; 00000040H
  02c3c	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG175381
  02c43	48 8b c8	 mov	 rcx, rax
  02c46	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_release_lock
$LN126@LCS_Proces:

; 6886 :     }
; 6887 : 
; 6888 :     return;

  02c4c	eb 7a		 jmp	 SHORT $LN1@LCS_Proces
$msg970_return$140:

; 6889 : 
; 6890 : msg970_return:
; 6891 :     if (pLCSPORT->pLCSBLK->fDebug)

  02c4e	48 8b 84 24 10
	03 00 00	 mov	 rax, QWORD PTR pLCSPORT$[rsp]
  02c56	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  02c5a	8b 40 18	 mov	 eax, DWORD PTR [rax+24]
  02c5d	83 e0 01	 and	 eax, 1
  02c60	85 c0		 test	 eax, eax
  02c62	74 64		 je	 SHORT $LN136@LCS_Proces

; 6892 :         // "CTC: lcs device port %2.2X: 802.2 LLC error, discarding frame"
; 6893 :         WRMSG( HHC00970, "W", pLCSPORT->bPort );

  02c64	48 8b 84 24 10
	03 00 00	 mov	 rax, QWORD PTR pLCSPORT$[rsp]
  02c6c	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  02c6f	89 84 24 04 01
	00 00		 mov	 DWORD PTR tv1842[rsp], eax
  02c76	b9 01 00 00 00	 mov	 ecx, 1
  02c7b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  02c81	8b 8c 24 04 01
	00 00		 mov	 ecx, DWORD PTR tv1842[rsp]
  02c88	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  02c8c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG175383
  02c93	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  02c98	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG175384
  02c9f	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  02ca4	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  02ca9	41 b9 03 00 00
	00		 mov	 r9d, 3
  02caf	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG175385
  02cb6	ba ed 1a 00 00	 mov	 edx, 6893		; 00001aedH
  02cbb	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG175386
  02cc2	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg
$LN136@LCS_Proces:
$LN1@LCS_Proces:

; 6894 : 
; 6895 :     return;
; 6896 : }

  02cc8	48 8b 8c 24 e0
	02 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  02cd0	48 33 cc	 xor	 rcx, rsp
  02cd3	e8 00 00 00 00	 call	 __security_check_cookie
  02cd8	48 81 c4 f8 02
	00 00		 add	 rsp, 760		; 000002f8H
  02cdf	5f		 pop	 rdi
  02ce0	5e		 pop	 rsi
  02ce1	c3		 ret	 0
  02ce2	66 90		 npad	 2
$LN139@LCS_Proces:
  02ce4	00 00 00 00	 DD	 $LN84@LCS_Proces
  02ce8	00 00 00 00	 DD	 $LN86@LCS_Proces
  02cec	00 00 00 00	 DD	 $LN89@LCS_Proces
  02cf0	00 00 00 00	 DD	 $LN92@LCS_Proces
  02cf4	00 00 00 00	 DD	 $LN95@LCS_Proces
  02cf8	00 00 00 00	 DD	 $LN97@LCS_Proces
  02cfc	00 00 00 00	 DD	 $LN114@LCS_Proces
  02d00	00 00 00 00	 DD	 $LN124@LCS_Proces
$LN138@LCS_Proces:
  02d04	00		 DB	 0
  02d05	07		 DB	 7
  02d06	07		 DB	 7
  02d07	07		 DB	 7
  02d08	07		 DB	 7
  02d09	01		 DB	 1
  02d0a	07		 DB	 7
  02d0b	07		 DB	 7
  02d0c	07		 DB	 7
  02d0d	02		 DB	 2
  02d0e	07		 DB	 7
  02d0f	07		 DB	 7
  02d10	03		 DB	 3
  02d11	07		 DB	 7
  02d12	04		 DB	 4
  02d13	07		 DB	 7
  02d14	07		 DB	 7
  02d15	07		 DB	 7
  02d16	07		 DB	 7
  02d17	07		 DB	 7
  02d18	05		 DB	 5
  02d19	07		 DB	 7
  02d1a	07		 DB	 7
  02d1b	07		 DB	 7
  02d1c	07		 DB	 7
  02d1d	06		 DB	 6
LCS_ProcessAccepted_SNA ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\ctc_lcs.c
_TEXT	SEGMENT
pLCSSTDFRM$ = 32
pLCSIBH$ = 40
tv81 = 48
pLCSDEV$ = 96
pCmdFrame$ = 104
iCmdLen$ = 112
LCS_UnsuppCmd_SNA PROC

; 5969 : {

  00000	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	56		 push	 rsi
  00010	57		 push	 rdi
  00011	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 5970 : 
; 5971 : #define REPLY_UNSUPPCMD_SNA_SIZE sizeof(LCSSTDFRM)
; 5972 : 
; 5973 :     PLCSIBH     pLCSIBH;
; 5974 :     PLCSSTDFRM  pLCSSTDFRM;
; 5975 : 
; 5976 : 
; 5977 :     // Get a buffer to hold the reply.
; 5978 :     pLCSIBH = alloc_lcs_buffer( pLCSDEV, REPLY_UNSUPPCMD_SNA_SIZE + 10 );

  00015	ba 1e 00 00 00	 mov	 edx, 30
  0001a	48 8b 4c 24 60	 mov	 rcx, QWORD PTR pLCSDEV$[rsp]
  0001f	e8 00 00 00 00	 call	 alloc_lcs_buffer
  00024	48 89 44 24 28	 mov	 QWORD PTR pLCSIBH$[rsp], rax

; 5979 :     pLCSSTDFRM = (PLCSSTDFRM)&pLCSIBH->bData;

  00029	48 8b 44 24 28	 mov	 rax, QWORD PTR pLCSIBH$[rsp]
  0002e	48 83 c0 10	 add	 rax, 16
  00032	48 89 44 24 20	 mov	 QWORD PTR pLCSSTDFRM$[rsp], rax

; 5980 :     pLCSIBH->iDataLen = REPLY_UNSUPPCMD_SNA_SIZE;

  00037	48 8b 44 24 28	 mov	 rax, QWORD PTR pLCSIBH$[rsp]
  0003c	c7 40 0c 14 00
	00 00		 mov	 DWORD PTR [rax+12], 20
$LN4@LCS_Unsupp:

; 5981 : 
; 5982 :     // Note: the command will be some unpredictable length, and the
; 5983 :     // reply will be 20 (0x14) bytes in length. INIT_REPLY_FRAME will
; 5984 :     // leave pLCSIBH->iDataLen in some unpredictable state.
; 5985 :     INIT_REPLY_FRAME( pLCSSTDFRM, pLCSIBH->iDataLen, pCmdFrame, iCmdLen );

  00043	48 8b 44 24 28	 mov	 rax, QWORD PTR pLCSIBH$[rsp]
  00048	8b 40 0c	 mov	 eax, DWORD PTR [rax+12]
  0004b	39 44 24 70	 cmp	 DWORD PTR iCmdLen$[rsp], eax
  0004f	7c 1a		 jl	 SHORT $LN5@LCS_Unsupp
  00051	48 8b 44 24 28	 mov	 rax, QWORD PTR pLCSIBH$[rsp]
  00056	48 63 40 0c	 movsxd	 rax, DWORD PTR [rax+12]
  0005a	48 8b 7c 24 20	 mov	 rdi, QWORD PTR pLCSSTDFRM$[rsp]
  0005f	48 8b 74 24 68	 mov	 rsi, QWORD PTR pCmdFrame$[rsp]
  00064	48 8b c8	 mov	 rcx, rax
  00067	f3 a4		 rep movsb
  00069	eb 3c		 jmp	 SHORT $LN6@LCS_Unsupp
$LN5@LCS_Unsupp:
  0006b	48 8b 44 24 28	 mov	 rax, QWORD PTR pLCSIBH$[rsp]
  00070	48 63 40 0c	 movsxd	 rax, DWORD PTR [rax+12]
  00074	48 89 44 24 30	 mov	 QWORD PTR tv81[rsp], rax
  00079	48 8b 7c 24 20	 mov	 rdi, QWORD PTR pLCSSTDFRM$[rsp]
  0007e	33 c0		 xor	 eax, eax
  00080	48 8b 4c 24 30	 mov	 rcx, QWORD PTR tv81[rsp]
  00085	f3 aa		 rep stosb
  00087	48 63 44 24 70	 movsxd	 rax, DWORD PTR iCmdLen$[rsp]
  0008c	48 8b 7c 24 20	 mov	 rdi, QWORD PTR pLCSSTDFRM$[rsp]
  00091	48 8b 74 24 68	 mov	 rsi, QWORD PTR pCmdFrame$[rsp]
  00096	48 8b c8	 mov	 rcx, rax
  00099	f3 a4		 rep movsb
  0009b	48 8b 44 24 28	 mov	 rax, QWORD PTR pLCSIBH$[rsp]
  000a0	8b 4c 24 70	 mov	 ecx, DWORD PTR iCmdLen$[rsp]
  000a4	89 48 0c	 mov	 DWORD PTR [rax+12], ecx
$LN6@LCS_Unsupp:
  000a7	33 c9		 xor	 ecx, ecx
  000a9	e8 00 00 00 00	 call	 _byteswap_ushort
  000ae	48 8b 4c 24 20	 mov	 rcx, QWORD PTR pLCSSTDFRM$[rsp]
  000b3	0f b7 d0	 movzx	 edx, ax
  000b6	e8 00 00 00 00	 call	 store_hw_noswap
  000bb	33 c9		 xor	 ecx, ecx
  000bd	e8 00 00 00 00	 call	 _byteswap_ushort
  000c2	48 8b 4c 24 20	 mov	 rcx, QWORD PTR pLCSSTDFRM$[rsp]
  000c7	48 83 c1 08	 add	 rcx, 8
  000cb	0f b7 d0	 movzx	 edx, ax
  000ce	e8 00 00 00 00	 call	 store_hw_noswap
  000d3	33 c0		 xor	 eax, eax
  000d5	85 c0		 test	 eax, eax
  000d7	0f 85 66 ff ff
	ff		 jne	 $LN4@LCS_Unsupp

; 5986 :     pLCSIBH->iDataLen = REPLY_UNSUPPCMD_SNA_SIZE;

  000dd	48 8b 44 24 28	 mov	 rax, QWORD PTR pLCSIBH$[rsp]
  000e2	c7 40 0c 14 00
	00 00		 mov	 DWORD PTR [rax+12], 20

; 5987 : 
; 5988 :     // Initialize the reply fields.
; 5989 :     pLCSSTDFRM->bLCSCmdHdr.bLCSHdr.bSlot = pLCSDEV->bPort;

  000e9	48 8b 44 24 20	 mov	 rax, QWORD PTR pLCSSTDFRM$[rsp]
  000ee	48 8b 4c 24 60	 mov	 rcx, QWORD PTR pLCSDEV$[rsp]
  000f3	0f b6 49 23	 movzx	 ecx, BYTE PTR [rcx+35]
  000f7	88 48 03	 mov	 BYTE PTR [rax+3], cl

; 5990 :     pLCSSTDFRM->bLCSCmdHdr.bInitiator    = LCS_INITIATOR_SNA;

  000fa	48 8b 44 24 20	 mov	 rax, QWORD PTR pLCSSTDFRM$[rsp]
  000ff	c6 40 05 80	 mov	 BYTE PTR [rax+5], 128	; 00000080H

; 5991 :     pLCSSTDFRM->bLCSCmdHdr.bRelAdapterNo = pLCSDEV->bPort;

  00103	48 8b 44 24 20	 mov	 rax, QWORD PTR pLCSSTDFRM$[rsp]
  00108	48 8b 4c 24 60	 mov	 rcx, QWORD PTR pLCSDEV$[rsp]
  0010d	0f b6 49 23	 movzx	 ecx, BYTE PTR [rcx+35]
  00111	88 48 0b	 mov	 BYTE PTR [rax+11], cl

; 5992 :     STORE_HW( pLCSSTDFRM->bLCSCmdHdr.hwReturnCode, 0xFFFF );

  00114	66 b9 ff ff	 mov	 cx, 65535		; 0000ffffH
  00118	e8 00 00 00 00	 call	 _byteswap_ushort
  0011d	48 8b 4c 24 20	 mov	 rcx, QWORD PTR pLCSSTDFRM$[rsp]
  00122	48 83 c1 08	 add	 rcx, 8
  00126	0f b7 d0	 movzx	 edx, ax
  00129	e8 00 00 00 00	 call	 store_hw_noswap

; 5993 : 
; 5994 :     // Add the buffer containing the reply to the chain.
; 5995 :     add_lcs_buffer_to_chain( pLCSDEV, pLCSIBH );

  0012e	48 8b 54 24 28	 mov	 rdx, QWORD PTR pLCSIBH$[rsp]
  00133	48 8b 4c 24 60	 mov	 rcx, QWORD PTR pLCSDEV$[rsp]
  00138	e8 00 00 00 00	 call	 add_lcs_buffer_to_chain

; 5996 : }

  0013d	48 83 c4 48	 add	 rsp, 72			; 00000048H
  00141	5f		 pop	 rdi
  00142	5e		 pop	 rsi
  00143	c3		 ret	 0
LCS_UnsuppCmd_SNA ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\ctc_lcs.c
_TEXT	SEGMENT
pLCSLSSFRM$ = 32
pLCSIBH$ = 40
pLCSPORT$ = 48
tv88 = 56
pLCSDEV$ = 96
pCmdFrame$ = 104
iCmdLen$ = 112
LCS_LanStats_SNA PROC

; 5840 : {

  00000	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	56		 push	 rsi
  00010	57		 push	 rdi
  00011	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 5841 : 
; 5842 : #define REPLY_LANSTATS_SNA_SIZE sizeof(LCSLSSFRM)
; 5843 : 
; 5844 :     PLCSPORT    pLCSPORT;
; 5845 :     PLCSIBH     pLCSIBH;
; 5846 :     PLCSLSSFRM  pLCSLSSFRM;
; 5847 : 
; 5848 : 
; 5849 :     pLCSPORT = &pLCSDEV->pLCSBLK->Port[pLCSDEV->bPort];

  00015	48 8b 44 24 60	 mov	 rax, QWORD PTR pLCSDEV$[rsp]
  0001a	48 8b 40 08	 mov	 rax, QWORD PTR [rax+8]
  0001e	48 8b 4c 24 60	 mov	 rcx, QWORD PTR pLCSDEV$[rsp]
  00023	0f b6 49 23	 movzx	 ecx, BYTE PTR [rcx+35]
  00027	48 69 c9 98 01
	00 00		 imul	 rcx, rcx, 408		; 00000198H
  0002e	48 8d 44 08 60	 lea	 rax, QWORD PTR [rax+rcx+96]
  00033	48 89 44 24 30	 mov	 QWORD PTR pLCSPORT$[rsp], rax

; 5850 : 
; 5851 :     // Get and display the tap interface MAC address.
; 5852 :     GetIfMACAddress( pLCSPORT );

  00038	48 8b 4c 24 30	 mov	 rcx, QWORD PTR pLCSPORT$[rsp]
  0003d	e8 00 00 00 00	 call	 GetIfMACAddress

; 5853 : 
; 5854 :     // Get a buffer to hold the reply.
; 5855 :     pLCSIBH = alloc_lcs_buffer( pLCSDEV, REPLY_LANSTATS_SNA_SIZE + 10 );

  00042	ba 24 00 00 00	 mov	 edx, 36			; 00000024H
  00047	48 8b 4c 24 60	 mov	 rcx, QWORD PTR pLCSDEV$[rsp]
  0004c	e8 00 00 00 00	 call	 alloc_lcs_buffer
  00051	48 89 44 24 28	 mov	 QWORD PTR pLCSIBH$[rsp], rax

; 5856 :     pLCSLSSFRM = (PLCSLSSFRM)&pLCSIBH->bData;

  00056	48 8b 44 24 28	 mov	 rax, QWORD PTR pLCSIBH$[rsp]
  0005b	48 83 c0 10	 add	 rax, 16
  0005f	48 89 44 24 20	 mov	 QWORD PTR pLCSLSSFRM$[rsp], rax

; 5857 :     pLCSIBH->iDataLen = REPLY_LANSTATS_SNA_SIZE;

  00064	48 8b 44 24 28	 mov	 rax, QWORD PTR pLCSIBH$[rsp]
  00069	c7 40 0c 1a 00
	00 00		 mov	 DWORD PTR [rax+12], 26
$LN4@LCS_LanSta:

; 5858 : 
; 5859 :     // Note: the command is usually 20 (0x14) bytes in length, whereas the
; 5860 :     // reply needs to be 26 (0x1A) bytes in length. INIT_REPLY_FRAME will
; 5861 :     // set pLCSIBH->iDataLen equal to the length of the command.
; 5862 :     INIT_REPLY_FRAME( pLCSLSSFRM, pLCSIBH->iDataLen, pCmdFrame, iCmdLen );

  00070	48 8b 44 24 28	 mov	 rax, QWORD PTR pLCSIBH$[rsp]
  00075	8b 40 0c	 mov	 eax, DWORD PTR [rax+12]
  00078	39 44 24 70	 cmp	 DWORD PTR iCmdLen$[rsp], eax
  0007c	7c 1a		 jl	 SHORT $LN5@LCS_LanSta
  0007e	48 8b 44 24 28	 mov	 rax, QWORD PTR pLCSIBH$[rsp]
  00083	48 63 40 0c	 movsxd	 rax, DWORD PTR [rax+12]
  00087	48 8b 7c 24 20	 mov	 rdi, QWORD PTR pLCSLSSFRM$[rsp]
  0008c	48 8b 74 24 68	 mov	 rsi, QWORD PTR pCmdFrame$[rsp]
  00091	48 8b c8	 mov	 rcx, rax
  00094	f3 a4		 rep movsb
  00096	eb 3c		 jmp	 SHORT $LN6@LCS_LanSta
$LN5@LCS_LanSta:
  00098	48 8b 44 24 28	 mov	 rax, QWORD PTR pLCSIBH$[rsp]
  0009d	48 63 40 0c	 movsxd	 rax, DWORD PTR [rax+12]
  000a1	48 89 44 24 38	 mov	 QWORD PTR tv88[rsp], rax
  000a6	48 8b 7c 24 20	 mov	 rdi, QWORD PTR pLCSLSSFRM$[rsp]
  000ab	33 c0		 xor	 eax, eax
  000ad	48 8b 4c 24 38	 mov	 rcx, QWORD PTR tv88[rsp]
  000b2	f3 aa		 rep stosb
  000b4	48 63 44 24 70	 movsxd	 rax, DWORD PTR iCmdLen$[rsp]
  000b9	48 8b 7c 24 20	 mov	 rdi, QWORD PTR pLCSLSSFRM$[rsp]
  000be	48 8b 74 24 68	 mov	 rsi, QWORD PTR pCmdFrame$[rsp]
  000c3	48 8b c8	 mov	 rcx, rax
  000c6	f3 a4		 rep movsb
  000c8	48 8b 44 24 28	 mov	 rax, QWORD PTR pLCSIBH$[rsp]
  000cd	8b 4c 24 70	 mov	 ecx, DWORD PTR iCmdLen$[rsp]
  000d1	89 48 0c	 mov	 DWORD PTR [rax+12], ecx
$LN6@LCS_LanSta:
  000d4	33 c9		 xor	 ecx, ecx
  000d6	e8 00 00 00 00	 call	 _byteswap_ushort
  000db	48 8b 4c 24 20	 mov	 rcx, QWORD PTR pLCSLSSFRM$[rsp]
  000e0	0f b7 d0	 movzx	 edx, ax
  000e3	e8 00 00 00 00	 call	 store_hw_noswap
  000e8	33 c9		 xor	 ecx, ecx
  000ea	e8 00 00 00 00	 call	 _byteswap_ushort
  000ef	48 8b 4c 24 20	 mov	 rcx, QWORD PTR pLCSLSSFRM$[rsp]
  000f4	48 83 c1 08	 add	 rcx, 8
  000f8	0f b7 d0	 movzx	 edx, ax
  000fb	e8 00 00 00 00	 call	 store_hw_noswap
  00100	33 c0		 xor	 eax, eax
  00102	85 c0		 test	 eax, eax
  00104	0f 85 66 ff ff
	ff		 jne	 $LN4@LCS_LanSta

; 5863 :     pLCSIBH->iDataLen = REPLY_LANSTATS_SNA_SIZE;

  0010a	48 8b 44 24 28	 mov	 rax, QWORD PTR pLCSIBH$[rsp]
  0010f	c7 40 0c 1a 00
	00 00		 mov	 DWORD PTR [rax+12], 26

; 5864 : 
; 5865 :     // Initialize the reply fields.
; 5866 :     // Respond with a different MAC address for the guest
; 5867 :     // side unless the TAP mechanism is designed as such
; 5868 :     // cf : hostopts.h for an explanation
; 5869 :     pLCSLSSFRM->bLCSCmdHdr.bLCSHdr.bSlot = pLCSDEV->bPort;

  00116	48 8b 44 24 20	 mov	 rax, QWORD PTR pLCSLSSFRM$[rsp]
  0011b	48 8b 4c 24 60	 mov	 rcx, QWORD PTR pLCSDEV$[rsp]
  00120	0f b6 49 23	 movzx	 ecx, BYTE PTR [rcx+35]
  00124	88 48 03	 mov	 BYTE PTR [rax+3], cl

; 5870 :     pLCSLSSFRM->bLCSCmdHdr.bInitiator    = LCS_INITIATOR_SNA;

  00127	48 8b 44 24 20	 mov	 rax, QWORD PTR pLCSLSSFRM$[rsp]
  0012c	c6 40 05 80	 mov	 BYTE PTR [rax+5], 128	; 00000080H

; 5871 :     pLCSLSSFRM->bLCSCmdHdr.bRelAdapterNo = pLCSDEV->bPort;

  00130	48 8b 44 24 20	 mov	 rax, QWORD PTR pLCSLSSFRM$[rsp]
  00135	48 8b 4c 24 60	 mov	 rcx, QWORD PTR pLCSDEV$[rsp]
  0013a	0f b6 49 23	 movzx	 ecx, BYTE PTR [rcx+35]
  0013e	88 48 0b	 mov	 BYTE PTR [rax+11], cl

; 5872 :     pLCSLSSFRM->bUnknown1                = 0x01;  /* Count? Number of MAC addresses? */

  00141	48 8b 44 24 20	 mov	 rax, QWORD PTR pLCSLSSFRM$[rsp]
  00146	c6 40 0c 01	 mov	 BYTE PTR [rax+12], 1

; 5873 :     pLCSLSSFRM->bUnknown2                = 0x04;  /* This byte is kept by VTAM. SAP? Probably not. 0x04 works, 0x08 doesn't. */

  0014a	48 8b 44 24 20	 mov	 rax, QWORD PTR pLCSLSSFRM$[rsp]
  0014f	c6 40 0d 04	 mov	 BYTE PTR [rax+13], 4

; 5874 :     pLCSLSSFRM->bUnknown3                = 0x00;  /* This byte is kept by VTAM. */

  00153	48 8b 44 24 20	 mov	 rax, QWORD PTR pLCSLSSFRM$[rsp]
  00158	c6 40 0e 00	 mov	 BYTE PTR [rax+14], 0

; 5875 :     pLCSLSSFRM->bUnknown4                = 0x01;  /* No idea! */

  0015c	48 8b 44 24 20	 mov	 rax, QWORD PTR pLCSLSSFRM$[rsp]
  00161	c6 40 0f 01	 mov	 BYTE PTR [rax+15], 1

; 5876 :     pLCSLSSFRM->bMACsize                 = 0x06;  /* Length of MAC address */

  00165	48 8b 44 24 20	 mov	 rax, QWORD PTR pLCSLSSFRM$[rsp]
  0016a	c6 40 12 06	 mov	 BYTE PTR [rax+18], 6

; 5877 :     memcpy( pLCSLSSFRM->MAC_Address, pLCSPORT->MAC_Address, IFHWADDRLEN );

  0016e	48 8b 44 24 20	 mov	 rax, QWORD PTR pLCSLSSFRM$[rsp]
  00173	48 8b 4c 24 30	 mov	 rcx, QWORD PTR pLCSPORT$[rsp]
  00178	48 8d 78 13	 lea	 rdi, QWORD PTR [rax+19]
  0017c	48 8d 71 02	 lea	 rsi, QWORD PTR [rcx+2]
  00180	b9 06 00 00 00	 mov	 ecx, 6
  00185	f3 a4		 rep movsb

; 5878 : #if !defined( OPTION_TUNTAP_LCS_SAME_ADDR )
; 5879 :     pLCSLSSFRM->MAC_Address[5]++;
; 5880 : #endif
; 5881 : 
; 5882 :     // Add the buffer containing the reply to the chain.
; 5883 :     add_lcs_buffer_to_chain( pLCSDEV, pLCSIBH );

  00187	48 8b 54 24 28	 mov	 rdx, QWORD PTR pLCSIBH$[rsp]
  0018c	48 8b 4c 24 60	 mov	 rcx, QWORD PTR pLCSDEV$[rsp]
  00191	e8 00 00 00 00	 call	 add_lcs_buffer_to_chain

; 5884 : 
; 5885 : }

  00196	48 83 c4 48	 add	 rsp, 72			; 00000048H
  0019a	5f		 pop	 rdi
  0019b	5e		 pop	 rsi
  0019c	c3		 ret	 0
LCS_LanStats_SNA ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\ctc_lcs.c
_TEXT	SEGMENT
pLCSSTDFRM$ = 64
pLCSPORT$ = 72
pLCSIBH$ = 80
pDEVBLK$ = 88
tv90 = 96
pLCSDEV$ = 144
pCmdFrame$ = 152
iCmdLen$ = 160
LCS_StopLan_SNA PROC

; 5892 : {

  00000	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	56		 push	 rsi
  00010	57		 push	 rdi
  00011	48 83 ec 78	 sub	 rsp, 120		; 00000078H

; 5893 : 
; 5894 : #define REPLY_STOPLAN_SNA_SIZE sizeof(LCSSTDFRM)
; 5895 : 
; 5896 :     PLCSPORT    pLCSPORT;
; 5897 :     DEVBLK*     pDEVBLK;
; 5898 :     PLCSIBH     pLCSIBH;
; 5899 :     PLCSSTDFRM  pLCSSTDFRM;
; 5900 : 
; 5901 : 
; 5902 :     pLCSPORT = &pLCSDEV->pLCSBLK->Port[ pLCSDEV->bPort ];

  00015	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR pLCSDEV$[rsp]
  0001d	48 8b 40 08	 mov	 rax, QWORD PTR [rax+8]
  00021	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR pLCSDEV$[rsp]
  00029	0f b6 49 23	 movzx	 ecx, BYTE PTR [rcx+35]
  0002d	48 69 c9 98 01
	00 00		 imul	 rcx, rcx, 408		; 00000198H
  00034	48 8d 44 08 60	 lea	 rax, QWORD PTR [rax+rcx+96]
  00039	48 89 44 24 48	 mov	 QWORD PTR pLCSPORT$[rsp], rax

; 5903 :     pDEVBLK  =  pLCSDEV->pDEVBLK[ LCS_READ_SUBCHANN ];  /* SNA has only one device */

  0003e	b8 08 00 00 00	 mov	 eax, 8
  00043	48 6b c0 00	 imul	 rax, rax, 0
  00047	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR pLCSDEV$[rsp]
  0004f	48 8b 44 01 10	 mov	 rax, QWORD PTR [rcx+rax+16]
  00054	48 89 44 24 58	 mov	 QWORD PTR pDEVBLK$[rsp], rax

; 5904 : 
; 5905 :     // Get a buffer to hold the reply.
; 5906 :     pLCSIBH = alloc_lcs_buffer( pLCSDEV, REPLY_STOPLAN_SNA_SIZE + 10 );

  00059	ba 1e 00 00 00	 mov	 edx, 30
  0005e	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR pLCSDEV$[rsp]
  00066	e8 00 00 00 00	 call	 alloc_lcs_buffer
  0006b	48 89 44 24 50	 mov	 QWORD PTR pLCSIBH$[rsp], rax

; 5907 :     pLCSSTDFRM = (PLCSSTDFRM)&pLCSIBH->bData;

  00070	48 8b 44 24 50	 mov	 rax, QWORD PTR pLCSIBH$[rsp]
  00075	48 83 c0 10	 add	 rax, 16
  00079	48 89 44 24 40	 mov	 QWORD PTR pLCSSTDFRM$[rsp], rax

; 5908 :     pLCSIBH->iDataLen = REPLY_STOPLAN_SNA_SIZE;

  0007e	48 8b 44 24 50	 mov	 rax, QWORD PTR pLCSIBH$[rsp]
  00083	c7 40 0c 14 00
	00 00		 mov	 DWORD PTR [rax+12], 20
$LN4@LCS_StopLa:

; 5909 : 
; 5910 :     // Note: the command is usually 20 (0x14) bytes in length, and the
; 5911 :     // reply needs to be 20 (0x14) bytes in length. INIT_REPLY_FRAME will
; 5912 :     // leave pLCSIBH->iDataLen unchanged.
; 5913 :     INIT_REPLY_FRAME( pLCSSTDFRM, pLCSIBH->iDataLen, pCmdFrame, iCmdLen );

  0008a	48 8b 44 24 50	 mov	 rax, QWORD PTR pLCSIBH$[rsp]
  0008f	8b 40 0c	 mov	 eax, DWORD PTR [rax+12]
  00092	39 84 24 a0 00
	00 00		 cmp	 DWORD PTR iCmdLen$[rsp], eax
  00099	7c 1d		 jl	 SHORT $LN29@LCS_StopLa
  0009b	48 8b 44 24 50	 mov	 rax, QWORD PTR pLCSIBH$[rsp]
  000a0	48 63 40 0c	 movsxd	 rax, DWORD PTR [rax+12]
  000a4	48 8b 7c 24 40	 mov	 rdi, QWORD PTR pLCSSTDFRM$[rsp]
  000a9	48 8b b4 24 98
	00 00 00	 mov	 rsi, QWORD PTR pCmdFrame$[rsp]
  000b1	48 8b c8	 mov	 rcx, rax
  000b4	f3 a4		 rep movsb
  000b6	eb 45		 jmp	 SHORT $LN30@LCS_StopLa
$LN29@LCS_StopLa:
  000b8	48 8b 44 24 50	 mov	 rax, QWORD PTR pLCSIBH$[rsp]
  000bd	48 63 40 0c	 movsxd	 rax, DWORD PTR [rax+12]
  000c1	48 89 44 24 60	 mov	 QWORD PTR tv90[rsp], rax
  000c6	48 8b 7c 24 40	 mov	 rdi, QWORD PTR pLCSSTDFRM$[rsp]
  000cb	33 c0		 xor	 eax, eax
  000cd	48 8b 4c 24 60	 mov	 rcx, QWORD PTR tv90[rsp]
  000d2	f3 aa		 rep stosb
  000d4	48 63 84 24 a0
	00 00 00	 movsxd	 rax, DWORD PTR iCmdLen$[rsp]
  000dc	48 8b 7c 24 40	 mov	 rdi, QWORD PTR pLCSSTDFRM$[rsp]
  000e1	48 8b b4 24 98
	00 00 00	 mov	 rsi, QWORD PTR pCmdFrame$[rsp]
  000e9	48 8b c8	 mov	 rcx, rax
  000ec	f3 a4		 rep movsb
  000ee	48 8b 44 24 50	 mov	 rax, QWORD PTR pLCSIBH$[rsp]
  000f3	8b 8c 24 a0 00
	00 00		 mov	 ecx, DWORD PTR iCmdLen$[rsp]
  000fa	89 48 0c	 mov	 DWORD PTR [rax+12], ecx
$LN30@LCS_StopLa:
  000fd	33 c9		 xor	 ecx, ecx
  000ff	e8 00 00 00 00	 call	 _byteswap_ushort
  00104	48 8b 4c 24 40	 mov	 rcx, QWORD PTR pLCSSTDFRM$[rsp]
  00109	0f b7 d0	 movzx	 edx, ax
  0010c	e8 00 00 00 00	 call	 store_hw_noswap
  00111	33 c9		 xor	 ecx, ecx
  00113	e8 00 00 00 00	 call	 _byteswap_ushort
  00118	48 8b 4c 24 40	 mov	 rcx, QWORD PTR pLCSSTDFRM$[rsp]
  0011d	48 83 c1 08	 add	 rcx, 8
  00121	0f b7 d0	 movzx	 edx, ax
  00124	e8 00 00 00 00	 call	 store_hw_noswap
  00129	33 c0		 xor	 eax, eax
  0012b	85 c0		 test	 eax, eax
  0012d	0f 85 57 ff ff
	ff		 jne	 $LN4@LCS_StopLa

; 5914 :     pLCSIBH->iDataLen = REPLY_STOPLAN_SNA_SIZE;

  00133	48 8b 44 24 50	 mov	 rax, QWORD PTR pLCSIBH$[rsp]
  00138	c7 40 0c 14 00
	00 00		 mov	 DWORD PTR [rax+12], 20

; 5915 : 
; 5916 :     // Initialize the reply fields.
; 5917 :     pLCSSTDFRM->bLCSCmdHdr.bLCSHdr.bSlot = pLCSDEV->bPort;

  0013f	48 8b 44 24 40	 mov	 rax, QWORD PTR pLCSSTDFRM$[rsp]
  00144	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR pLCSDEV$[rsp]
  0014c	0f b6 49 23	 movzx	 ecx, BYTE PTR [rcx+35]
  00150	88 48 03	 mov	 BYTE PTR [rax+3], cl

; 5918 :     pLCSSTDFRM->bLCSCmdHdr.bInitiator    = LCS_INITIATOR_SNA;

  00153	48 8b 44 24 40	 mov	 rax, QWORD PTR pLCSSTDFRM$[rsp]
  00158	c6 40 05 80	 mov	 BYTE PTR [rax+5], 128	; 00000080H

; 5919 :     pLCSSTDFRM->bLCSCmdHdr.bRelAdapterNo = pLCSDEV->bPort;

  0015c	48 8b 44 24 40	 mov	 rax, QWORD PTR pLCSSTDFRM$[rsp]
  00161	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR pLCSDEV$[rsp]
  00169	0f b6 49 23	 movzx	 ecx, BYTE PTR [rcx+35]
  0016d	88 48 0b	 mov	 BYTE PTR [rax+11], cl
$LN7@LCS_StopLa:

; 5920 : 
; 5921 :     // Serialize access to eliminate ioctl errors
; 5922 :     PTT_DEBUG(        "GET  PortDataLock ", 000, pDEVBLK->devnum, pLCSPORT->bPort );

  00170	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_pttclass
  00177	48 8b 00	 mov	 rax, QWORD PTR [rax]
  0017a	48 25 00 00 02
	00		 and	 rax, 131072		; 00020000H
  00180	48 85 c0	 test	 rax, rax
  00183	74 43		 je	 SHORT $LN31@LCS_StopLa
  00185	48 8b 44 24 48	 mov	 rax, QWORD PTR pLCSPORT$[rsp]
  0018a	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  0018d	48 8b 4c 24 58	 mov	 rcx, QWORD PTR pDEVBLK$[rsp]
  00192	0f b7 49 48	 movzx	 ecx, WORD PTR [rcx+72]
  00196	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR [rsp+48], 0
  0019f	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  001a4	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG174812
  001ab	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  001b0	44 8b c9	 mov	 r9d, ecx
  001b3	45 33 c0	 xor	 r8d, r8d
  001b6	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG174813
  001bd	b9 00 00 02 00	 mov	 ecx, 131072		; 00020000H
  001c2	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ptt_pthread_trace
$LN31@LCS_StopLa:
  001c8	33 c0		 xor	 eax, eax
  001ca	85 c0		 test	 eax, eax
  001cc	75 a2		 jne	 SHORT $LN7@LCS_StopLa

; 5923 :     obtain_lock( &pLCSPORT->PortDataLock );

  001ce	48 8b 44 24 48	 mov	 rax, QWORD PTR pLCSPORT$[rsp]
  001d3	48 05 1c 01 00
	00		 add	 rax, 284		; 0000011cH
  001d9	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG174814
  001e0	48 8b c8	 mov	 rcx, rax
  001e3	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_obtain_lock
$LN10@LCS_StopLa:

; 5924 :     PTT_DEBUG(        "GOT  PortDataLock ", 000, pDEVBLK->devnum, pLCSPORT->bPort );

  001e9	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_pttclass
  001f0	48 8b 00	 mov	 rax, QWORD PTR [rax]
  001f3	48 25 00 00 02
	00		 and	 rax, 131072		; 00020000H
  001f9	48 85 c0	 test	 rax, rax
  001fc	74 43		 je	 SHORT $LN32@LCS_StopLa
  001fe	48 8b 44 24 48	 mov	 rax, QWORD PTR pLCSPORT$[rsp]
  00203	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  00206	48 8b 4c 24 58	 mov	 rcx, QWORD PTR pDEVBLK$[rsp]
  0020b	0f b7 49 48	 movzx	 ecx, WORD PTR [rcx+72]
  0020f	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR [rsp+48], 0
  00218	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  0021d	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG174816
  00224	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00229	44 8b c9	 mov	 r9d, ecx
  0022c	45 33 c0	 xor	 r8d, r8d
  0022f	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG174817
  00236	b9 00 00 02 00	 mov	 ecx, 131072		; 00020000H
  0023b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ptt_pthread_trace
$LN32@LCS_StopLa:
  00241	33 c0		 xor	 eax, eax
  00243	85 c0		 test	 eax, eax
  00245	75 a2		 jne	 SHORT $LN10@LCS_StopLa

; 5925 :     {
; 5926 :         // Disable the interface by turning off the IFF_UP flag...
; 5927 :         if (!pLCSPORT->fPreconfigured)

  00247	48 8b 44 24 48	 mov	 rax, QWORD PTR pLCSPORT$[rsp]
  0024c	8b 80 34 01 00
	00		 mov	 eax, DWORD PTR [rax+308]
  00252	c1 e8 06	 shr	 eax, 6
  00255	83 e0 01	 and	 eax, 1
  00258	85 c0		 test	 eax, eax
  0025a	75 7b		 jne	 SHORT $LN33@LCS_StopLa
$LN13@LCS_StopLa:

; 5928 :             VERIFY( TUNTAP_SetFlags( pLCSPORT->szNetIfName, 0 ) == 0 );

  0025c	48 8b 44 24 48	 mov	 rax, QWORD PTR pLCSPORT$[rsp]
  00261	48 05 48 01 00
	00		 add	 rax, 328		; 00000148H
  00267	33 d2		 xor	 edx, edx
  00269	48 8b c8	 mov	 rcx, rax
  0026c	e8 00 00 00 00	 call	 TUNTAP_SetFlags
  00271	85 c0		 test	 eax, eax
  00273	74 5c		 je	 SHORT $LN34@LCS_StopLa
$LN16@LCS_StopLa:
  00275	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG174820
  0027c	41 b8 28 17 00
	00		 mov	 r8d, 5928		; 00001728H
  00282	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG174821
  00289	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG174822
  00290	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_logmsg
  00296	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_IsDebuggerPresent
  0029c	85 c0		 test	 eax, eax
  0029e	74 20		 je	 SHORT $LN35@LCS_StopLa
  002a0	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG174824
  002a7	41 b8 28 17 00
	00		 mov	 r8d, 5928		; 00001728H
  002ad	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG174825
  002b4	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG174826
  002bb	e8 00 00 00 00	 call	 DebuggerTrace
$LN35@LCS_StopLa:
  002c0	33 c0		 xor	 eax, eax
  002c2	85 c0		 test	 eax, eax
  002c4	75 af		 jne	 SHORT $LN16@LCS_StopLa
  002c6	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_IsDebuggerPresent
  002cc	85 c0		 test	 eax, eax
  002ce	74 01		 je	 SHORT $LN36@LCS_StopLa
  002d0	cc		 int	 3
$LN36@LCS_StopLa:
$LN34@LCS_StopLa:
  002d1	33 c0		 xor	 eax, eax
  002d3	85 c0		 test	 eax, eax
  002d5	75 85		 jne	 SHORT $LN13@LCS_StopLa
$LN33@LCS_StopLa:
$LN19@LCS_StopLa:

; 5929 : 
; 5930 :     }
; 5931 :     PTT_DEBUG(         "REL  PortDataLock ", 000, pDEVBLK->devnum, pLCSPORT->bPort );

  002d7	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_pttclass
  002de	48 8b 00	 mov	 rax, QWORD PTR [rax]
  002e1	48 25 00 00 02
	00		 and	 rax, 131072		; 00020000H
  002e7	48 85 c0	 test	 rax, rax
  002ea	74 43		 je	 SHORT $LN37@LCS_StopLa
  002ec	48 8b 44 24 48	 mov	 rax, QWORD PTR pLCSPORT$[rsp]
  002f1	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  002f4	48 8b 4c 24 58	 mov	 rcx, QWORD PTR pDEVBLK$[rsp]
  002f9	0f b7 49 48	 movzx	 ecx, WORD PTR [rcx+72]
  002fd	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR [rsp+48], 0
  00306	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  0030b	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG174829
  00312	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00317	44 8b c9	 mov	 r9d, ecx
  0031a	45 33 c0	 xor	 r8d, r8d
  0031d	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG174830
  00324	b9 00 00 02 00	 mov	 ecx, 131072		; 00020000H
  00329	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ptt_pthread_trace
$LN37@LCS_StopLa:
  0032f	33 c0		 xor	 eax, eax
  00331	85 c0		 test	 eax, eax
  00333	75 a2		 jne	 SHORT $LN19@LCS_StopLa

; 5932 :     release_lock( &pLCSPORT->PortDataLock );

  00335	48 8b 44 24 48	 mov	 rax, QWORD PTR pLCSPORT$[rsp]
  0033a	48 05 1c 01 00
	00		 add	 rax, 284		; 0000011cH
  00340	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG174831
  00347	48 8b c8	 mov	 rcx, rax
  0034a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_release_lock

; 5933 : 
; 5934 :     // Now that the tuntap device has been stopped and the packets
; 5935 :     // are no longer flowing, tell the LCS_PortThread to stop trying
; 5936 :     // to read from the tuntap device (adapter).
; 5937 : 
; 5938 :     UpdatePortStarted( FALSE, pDEVBLK, pLCSPORT );

  00350	4c 8b 44 24 48	 mov	 r8, QWORD PTR pLCSPORT$[rsp]
  00355	48 8b 54 24 58	 mov	 rdx, QWORD PTR pDEVBLK$[rsp]
  0035a	33 c9		 xor	 ecx, ecx
  0035c	e8 00 00 00 00	 call	 UpdatePortStarted
$LN22@LCS_StopLa:

; 5939 : 
; 5940 :     // Now that we've stopped new packets from being added to our
; 5941 :     // frame buffer we can now finally enqueue our reply frame
; 5942 :     // to our frame buffer (so LCS_Read can return it to the guest).
; 5943 :     // However, before we do that we must reset the frame buffer to
; 5944 :     // an empty state, losing any waiting input (though there
; 5945 :     // shouldn't be any!) and ensuring the enqueue proceeds smoothly.
; 5946 :     PTT_DEBUG(       "GET  DevDataLock  ", 000, pDEVBLK->devnum, -1 );

  00361	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_pttclass
  00368	48 8b 00	 mov	 rax, QWORD PTR [rax]
  0036b	48 25 00 00 02
	00		 and	 rax, 131072		; 00020000H
  00371	48 85 c0	 test	 rax, rax
  00374	74 3f		 je	 SHORT $LN38@LCS_StopLa
  00376	48 8b 44 24 58	 mov	 rax, QWORD PTR pDEVBLK$[rsp]
  0037b	0f b7 40 48	 movzx	 eax, WORD PTR [rax+72]
  0037f	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR [rsp+48], 0
  00388	48 c7 44 24 28
	ff ff ff ff	 mov	 QWORD PTR [rsp+40], -1
  00391	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG174833
  00398	48 89 4c 24 20	 mov	 QWORD PTR [rsp+32], rcx
  0039d	44 8b c8	 mov	 r9d, eax
  003a0	45 33 c0	 xor	 r8d, r8d
  003a3	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG174834
  003aa	b9 00 00 02 00	 mov	 ecx, 131072		; 00020000H
  003af	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ptt_pthread_trace
$LN38@LCS_StopLa:
  003b5	33 c0		 xor	 eax, eax
  003b7	85 c0		 test	 eax, eax
  003b9	75 a6		 jne	 SHORT $LN22@LCS_StopLa

; 5947 :     obtain_lock( &pLCSDEV->DevDataLock );

  003bb	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR pLCSDEV$[rsp]
  003c3	48 05 9a 00 00
	00		 add	 rax, 154		; 0000009aH
  003c9	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG174835
  003d0	48 8b c8	 mov	 rcx, rax
  003d3	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_obtain_lock
$LN25@LCS_StopLa:

; 5948 :     PTT_DEBUG(       "GOT  DevDataLock  ", 000, pDEVBLK->devnum, -1 );

  003d9	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_pttclass
  003e0	48 8b 00	 mov	 rax, QWORD PTR [rax]
  003e3	48 25 00 00 02
	00		 and	 rax, 131072		; 00020000H
  003e9	48 85 c0	 test	 rax, rax
  003ec	74 3f		 je	 SHORT $LN39@LCS_StopLa
  003ee	48 8b 44 24 58	 mov	 rax, QWORD PTR pDEVBLK$[rsp]
  003f3	0f b7 40 48	 movzx	 eax, WORD PTR [rax+72]
  003f7	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR [rsp+48], 0
  00400	48 c7 44 24 28
	ff ff ff ff	 mov	 QWORD PTR [rsp+40], -1
  00409	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG174837
  00410	48 89 4c 24 20	 mov	 QWORD PTR [rsp+32], rcx
  00415	44 8b c8	 mov	 r9d, eax
  00418	45 33 c0	 xor	 r8d, r8d
  0041b	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG174838
  00422	b9 00 00 02 00	 mov	 ecx, 131072		; 00020000H
  00427	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ptt_pthread_trace
$LN39@LCS_StopLa:
  0042d	33 c0		 xor	 eax, eax
  0042f	85 c0		 test	 eax, eax
  00431	75 a6		 jne	 SHORT $LN25@LCS_StopLa

; 5949 :     pLCSDEV->iFrameOffset  = 0;

  00433	33 c0		 xor	 eax, eax
  00435	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR pLCSDEV$[rsp]
  0043d	66 89 81 a2 00
	00 00		 mov	 WORD PTR [rcx+162], ax

; 5950 :     pLCSDEV->fReplyPending = 0;

  00444	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR pLCSDEV$[rsp]
  0044c	8b 40 41	 mov	 eax, DWORD PTR [rax+65]
  0044f	83 e0 f7	 and	 eax, -9			; fffffff7H
  00452	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR pLCSDEV$[rsp]
  0045a	89 41 41	 mov	 DWORD PTR [rcx+65], eax

; 5951 :     pLCSDEV->fDataPending  = 0;

  0045d	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR pLCSDEV$[rsp]
  00465	8b 40 41	 mov	 eax, DWORD PTR [rax+65]
  00468	83 e0 ef	 and	 eax, -17		; ffffffefH
  0046b	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR pLCSDEV$[rsp]
  00473	89 41 41	 mov	 DWORD PTR [rcx+65], eax

; 5952 :     pLCSDEV->fPendingIctl  = 0;

  00476	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR pLCSDEV$[rsp]
  0047e	8b 40 5d	 mov	 eax, DWORD PTR [rax+93]
  00481	83 e0 fb	 and	 eax, -5			; fffffffbH
  00484	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR pLCSDEV$[rsp]
  0048c	89 41 5d	 mov	 DWORD PTR [rcx+93], eax
$LN28@LCS_StopLa:

; 5953 :     PTT_DEBUG(        "REL  DevDataLock  ", 000, pDEVBLK->devnum, -1 );

  0048f	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_pttclass
  00496	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00499	48 25 00 00 02
	00		 and	 rax, 131072		; 00020000H
  0049f	48 85 c0	 test	 rax, rax
  004a2	74 3f		 je	 SHORT $LN40@LCS_StopLa
  004a4	48 8b 44 24 58	 mov	 rax, QWORD PTR pDEVBLK$[rsp]
  004a9	0f b7 40 48	 movzx	 eax, WORD PTR [rax+72]
  004ad	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR [rsp+48], 0
  004b6	48 c7 44 24 28
	ff ff ff ff	 mov	 QWORD PTR [rsp+40], -1
  004bf	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG174840
  004c6	48 89 4c 24 20	 mov	 QWORD PTR [rsp+32], rcx
  004cb	44 8b c8	 mov	 r9d, eax
  004ce	45 33 c0	 xor	 r8d, r8d
  004d1	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG174841
  004d8	b9 00 00 02 00	 mov	 ecx, 131072		; 00020000H
  004dd	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ptt_pthread_trace
$LN40@LCS_StopLa:
  004e3	33 c0		 xor	 eax, eax
  004e5	85 c0		 test	 eax, eax
  004e7	75 a6		 jne	 SHORT $LN28@LCS_StopLa

; 5954 :     release_lock( &pLCSDEV->DevDataLock );

  004e9	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR pLCSDEV$[rsp]
  004f1	48 05 9a 00 00
	00		 add	 rax, 154		; 0000009aH
  004f7	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG174842
  004fe	48 8b c8	 mov	 rcx, rax
  00501	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_release_lock

; 5955 :     remove_and_free_any_lcs_buffers_on_chain( pLCSDEV );

  00507	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR pLCSDEV$[rsp]
  0050f	e8 00 00 00 00	 call	 remove_and_free_any_lcs_buffers_on_chain

; 5956 :     remove_and_free_any_connections_on_chain( pLCSDEV );

  00514	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR pLCSDEV$[rsp]
  0051c	e8 00 00 00 00	 call	 remove_and_free_any_connections_on_chain

; 5957 : 
; 5958 :     // Add the buffer containing the reply to the chain.
; 5959 :     add_lcs_buffer_to_chain( pLCSDEV, pLCSIBH );

  00521	48 8b 54 24 50	 mov	 rdx, QWORD PTR pLCSIBH$[rsp]
  00526	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR pLCSDEV$[rsp]
  0052e	e8 00 00 00 00	 call	 add_lcs_buffer_to_chain

; 5960 : 
; 5961 :     pLCSDEV->fDevStarted = 0;

  00533	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR pLCSDEV$[rsp]
  0053b	8b 40 41	 mov	 eax, DWORD PTR [rax+65]
  0053e	83 e0 fd	 and	 eax, -3			; fffffffdH
  00541	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR pLCSDEV$[rsp]
  00549	89 41 41	 mov	 DWORD PTR [rcx+65], eax

; 5962 : }

  0054c	48 83 c4 78	 add	 rsp, 120		; 00000078H
  00550	5f		 pop	 rdi
  00551	5e		 pop	 rsi
  00552	c3		 ret	 0
LCS_StopLan_SNA ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\ctc_lcs.c
_TEXT	SEGMENT
fStartPending$ = 64
nIFFlags$ = 68
pLCSPORT$ = 72
pLCSSTRTFRM$ = 80
pLCSIBH$ = 88
pDEVBLK$ = 96
tv90 = 104
pLCSDEV$ = 144
pCmdFrame$ = 152
iCmdLen$ = 160
LCS_StartLan_SNA PROC

; 5754 : {

  00000	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	56		 push	 rsi
  00010	57		 push	 rdi
  00011	48 83 ec 78	 sub	 rsp, 120		; 00000078H

; 5755 : 
; 5756 : #define REPLY_STARTLAN_SNA_SIZE sizeof(LCSSTRTFRM)
; 5757 : 
; 5758 :     PLCSPORT    pLCSPORT;
; 5759 :     DEVBLK*     pDEVBLK;
; 5760 :     PLCSIBH     pLCSIBH;
; 5761 :     PLCSSTRTFRM pLCSSTRTFRM;
; 5762 :     int         nIFFlags;
; 5763 :     U8          fStartPending = 0;

  00015	c6 44 24 40 00	 mov	 BYTE PTR fStartPending$[rsp], 0

; 5764 : 
; 5765 : 
; 5766 :     pLCSPORT = &pLCSDEV->pLCSBLK->Port[pLCSDEV->bPort];

  0001a	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR pLCSDEV$[rsp]
  00022	48 8b 40 08	 mov	 rax, QWORD PTR [rax+8]
  00026	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR pLCSDEV$[rsp]
  0002e	0f b6 49 23	 movzx	 ecx, BYTE PTR [rcx+35]
  00032	48 69 c9 98 01
	00 00		 imul	 rcx, rcx, 408		; 00000198H
  00039	48 8d 44 08 60	 lea	 rax, QWORD PTR [rax+rcx+96]
  0003e	48 89 44 24 48	 mov	 QWORD PTR pLCSPORT$[rsp], rax

; 5767 :     pDEVBLK = pLCSDEV->pDEVBLK[ LCS_READ_SUBCHANN ];  /* SNA has only one device */

  00043	b8 08 00 00 00	 mov	 eax, 8
  00048	48 6b c0 00	 imul	 rax, rax, 0
  0004c	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR pLCSDEV$[rsp]
  00054	48 8b 44 01 10	 mov	 rax, QWORD PTR [rcx+rax+16]
  00059	48 89 44 24 60	 mov	 QWORD PTR pDEVBLK$[rsp], rax

; 5768 : 
; 5769 :     // Get a buffer to hold the reply.
; 5770 :     pLCSIBH = alloc_lcs_buffer( pLCSDEV, REPLY_STARTLAN_SNA_SIZE + 10 );

  0005e	ba 22 00 00 00	 mov	 edx, 34			; 00000022H
  00063	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR pLCSDEV$[rsp]
  0006b	e8 00 00 00 00	 call	 alloc_lcs_buffer
  00070	48 89 44 24 58	 mov	 QWORD PTR pLCSIBH$[rsp], rax

; 5771 :     pLCSSTRTFRM = (PLCSSTRTFRM)&pLCSIBH->bData;

  00075	48 8b 44 24 58	 mov	 rax, QWORD PTR pLCSIBH$[rsp]
  0007a	48 83 c0 10	 add	 rax, 16
  0007e	48 89 44 24 50	 mov	 QWORD PTR pLCSSTRTFRM$[rsp], rax

; 5772 :     pLCSIBH->iDataLen = REPLY_STARTLAN_SNA_SIZE;

  00083	48 8b 44 24 58	 mov	 rax, QWORD PTR pLCSIBH$[rsp]
  00088	c7 40 0c 18 00
	00 00		 mov	 DWORD PTR [rax+12], 24
$LN4@LCS_StartL:

; 5773 : 
; 5774 :     // Note: the command is usually 22 (0x16) bytes in length, whereas the
; 5775 :     // reply needs to be 24 (0x18) bytes in length. INIT_REPLY_FRAME will
; 5776 :     // set pLCSIBH->iDataLen equal to the length of the command.
; 5777 :     INIT_REPLY_FRAME( pLCSSTRTFRM, pLCSIBH->iDataLen, pCmdFrame, iCmdLen );

  0008f	48 8b 44 24 58	 mov	 rax, QWORD PTR pLCSIBH$[rsp]
  00094	8b 40 0c	 mov	 eax, DWORD PTR [rax+12]
  00097	39 84 24 a0 00
	00 00		 cmp	 DWORD PTR iCmdLen$[rsp], eax
  0009e	7c 1d		 jl	 SHORT $LN26@LCS_StartL
  000a0	48 8b 44 24 58	 mov	 rax, QWORD PTR pLCSIBH$[rsp]
  000a5	48 63 40 0c	 movsxd	 rax, DWORD PTR [rax+12]
  000a9	48 8b 7c 24 50	 mov	 rdi, QWORD PTR pLCSSTRTFRM$[rsp]
  000ae	48 8b b4 24 98
	00 00 00	 mov	 rsi, QWORD PTR pCmdFrame$[rsp]
  000b6	48 8b c8	 mov	 rcx, rax
  000b9	f3 a4		 rep movsb
  000bb	eb 45		 jmp	 SHORT $LN27@LCS_StartL
$LN26@LCS_StartL:
  000bd	48 8b 44 24 58	 mov	 rax, QWORD PTR pLCSIBH$[rsp]
  000c2	48 63 40 0c	 movsxd	 rax, DWORD PTR [rax+12]
  000c6	48 89 44 24 68	 mov	 QWORD PTR tv90[rsp], rax
  000cb	48 8b 7c 24 50	 mov	 rdi, QWORD PTR pLCSSTRTFRM$[rsp]
  000d0	33 c0		 xor	 eax, eax
  000d2	48 8b 4c 24 68	 mov	 rcx, QWORD PTR tv90[rsp]
  000d7	f3 aa		 rep stosb
  000d9	48 63 84 24 a0
	00 00 00	 movsxd	 rax, DWORD PTR iCmdLen$[rsp]
  000e1	48 8b 7c 24 50	 mov	 rdi, QWORD PTR pLCSSTRTFRM$[rsp]
  000e6	48 8b b4 24 98
	00 00 00	 mov	 rsi, QWORD PTR pCmdFrame$[rsp]
  000ee	48 8b c8	 mov	 rcx, rax
  000f1	f3 a4		 rep movsb
  000f3	48 8b 44 24 58	 mov	 rax, QWORD PTR pLCSIBH$[rsp]
  000f8	8b 8c 24 a0 00
	00 00		 mov	 ecx, DWORD PTR iCmdLen$[rsp]
  000ff	89 48 0c	 mov	 DWORD PTR [rax+12], ecx
$LN27@LCS_StartL:
  00102	33 c9		 xor	 ecx, ecx
  00104	e8 00 00 00 00	 call	 _byteswap_ushort
  00109	48 8b 4c 24 50	 mov	 rcx, QWORD PTR pLCSSTRTFRM$[rsp]
  0010e	0f b7 d0	 movzx	 edx, ax
  00111	e8 00 00 00 00	 call	 store_hw_noswap
  00116	33 c9		 xor	 ecx, ecx
  00118	e8 00 00 00 00	 call	 _byteswap_ushort
  0011d	48 8b 4c 24 50	 mov	 rcx, QWORD PTR pLCSSTRTFRM$[rsp]
  00122	48 83 c1 08	 add	 rcx, 8
  00126	0f b7 d0	 movzx	 edx, ax
  00129	e8 00 00 00 00	 call	 store_hw_noswap
  0012e	33 c0		 xor	 eax, eax
  00130	85 c0		 test	 eax, eax
  00132	0f 85 57 ff ff
	ff		 jne	 $LN4@LCS_StartL

; 5778 :     pLCSIBH->iDataLen = REPLY_STARTLAN_SNA_SIZE;

  00138	48 8b 44 24 58	 mov	 rax, QWORD PTR pLCSIBH$[rsp]
  0013d	c7 40 0c 18 00
	00 00		 mov	 DWORD PTR [rax+12], 24

; 5779 : 
; 5780 :     // Initialize the reply fields.
; 5781 :     pLCSSTRTFRM->bLCSCmdHdr.bLCSHdr.bSlot = pLCSDEV->bPort;

  00144	48 8b 44 24 50	 mov	 rax, QWORD PTR pLCSSTRTFRM$[rsp]
  00149	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR pLCSDEV$[rsp]
  00151	0f b6 49 23	 movzx	 ecx, BYTE PTR [rcx+35]
  00155	88 48 03	 mov	 BYTE PTR [rax+3], cl

; 5782 :     pLCSSTRTFRM->bLCSCmdHdr.bInitiator    = LCS_INITIATOR_SNA;

  00158	48 8b 44 24 50	 mov	 rax, QWORD PTR pLCSSTRTFRM$[rsp]
  0015d	c6 40 05 80	 mov	 BYTE PTR [rax+5], 128	; 00000080H

; 5783 :     pLCSSTRTFRM->bLCSCmdHdr.bRelAdapterNo = pLCSDEV->bPort;

  00161	48 8b 44 24 50	 mov	 rax, QWORD PTR pLCSSTRTFRM$[rsp]
  00166	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR pLCSDEV$[rsp]
  0016e	0f b6 49 23	 movzx	 ecx, BYTE PTR [rcx+35]
  00172	88 48 0b	 mov	 BYTE PTR [rax+11], cl

; 5784 :     STORE_HW( pLCSSTRTFRM->hwBufferSize, 0x0200 );                        /* >= 0x0200, == 0x02FF */

  00175	66 b9 00 02	 mov	 cx, 512			; 00000200H
  00179	e8 00 00 00 00	 call	 _byteswap_ushort
  0017e	48 8b 4c 24 50	 mov	 rcx, QWORD PTR pLCSSTRTFRM$[rsp]
  00183	48 83 c1 0c	 add	 rcx, 12
  00187	0f b7 d0	 movzx	 edx, ax
  0018a	e8 00 00 00 00	 call	 store_hw_noswap

; 5785 : //  STORE_FW( pLCSSTRTFRM->fwReadLength, pLCSDEV->iMaxFrameBufferSize );  /* Length for Read CCW (0x0800 to 0xFFFF) */
; 5786 :     STORE_FW( pLCSSTRTFRM->fwReadLength, CTC_DEF_FRAME_BUFFER_SIZE );     /* Length for Read CCW (0x0800 to 0xFFFF) */

  0018f	b9 00 50 00 00	 mov	 ecx, 20480		; 00005000H
  00194	e8 00 00 00 00	 call	 _byteswap_ulong
  00199	48 8b 4c 24 50	 mov	 rcx, QWORD PTR pLCSSTRTFRM$[rsp]
  0019e	48 83 c1 14	 add	 rcx, 20
  001a2	8b d0		 mov	 edx, eax
  001a4	e8 00 00 00 00	 call	 store_fw_noswap

; 5787 : 
; 5788 :     // Add the buffer containing the reply to the chain.
; 5789 :     add_lcs_buffer_to_chain( pLCSDEV, pLCSIBH );

  001a9	48 8b 54 24 58	 mov	 rdx, QWORD PTR pLCSIBH$[rsp]
  001ae	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR pLCSDEV$[rsp]
  001b6	e8 00 00 00 00	 call	 add_lcs_buffer_to_chain
$LN7@LCS_StartL:

; 5790 : 
; 5791 :     // Serialize access to eliminate ioctl errors
; 5792 :     PTT_DEBUG(        "GET  PortDataLock ", 000, pDEVBLK->devnum, pLCSPORT->bPort );

  001bb	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_pttclass
  001c2	48 8b 00	 mov	 rax, QWORD PTR [rax]
  001c5	48 25 00 00 02
	00		 and	 rax, 131072		; 00020000H
  001cb	48 85 c0	 test	 rax, rax
  001ce	74 43		 je	 SHORT $LN28@LCS_StartL
  001d0	48 8b 44 24 48	 mov	 rax, QWORD PTR pLCSPORT$[rsp]
  001d5	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  001d8	48 8b 4c 24 60	 mov	 rcx, QWORD PTR pDEVBLK$[rsp]
  001dd	0f b7 49 48	 movzx	 ecx, WORD PTR [rcx+72]
  001e1	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR [rsp+48], 0
  001ea	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  001ef	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG174684
  001f6	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  001fb	44 8b c9	 mov	 r9d, ecx
  001fe	45 33 c0	 xor	 r8d, r8d
  00201	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG174685
  00208	b9 00 00 02 00	 mov	 ecx, 131072		; 00020000H
  0020d	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ptt_pthread_trace
$LN28@LCS_StartL:
  00213	33 c0		 xor	 eax, eax
  00215	85 c0		 test	 eax, eax
  00217	75 a2		 jne	 SHORT $LN7@LCS_StartL

; 5793 :     obtain_lock( &pLCSPORT->PortDataLock );

  00219	48 8b 44 24 48	 mov	 rax, QWORD PTR pLCSPORT$[rsp]
  0021e	48 05 1c 01 00
	00		 add	 rax, 284		; 0000011cH
  00224	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG174686
  0022b	48 8b c8	 mov	 rcx, rax
  0022e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_obtain_lock
$LN10@LCS_StartL:

; 5794 :     PTT_DEBUG(        "GOT  PortDataLock ", 000, pDEVBLK->devnum, pLCSPORT->bPort );

  00234	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_pttclass
  0023b	48 8b 00	 mov	 rax, QWORD PTR [rax]
  0023e	48 25 00 00 02
	00		 and	 rax, 131072		; 00020000H
  00244	48 85 c0	 test	 rax, rax
  00247	74 43		 je	 SHORT $LN29@LCS_StartL
  00249	48 8b 44 24 48	 mov	 rax, QWORD PTR pLCSPORT$[rsp]
  0024e	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  00251	48 8b 4c 24 60	 mov	 rcx, QWORD PTR pDEVBLK$[rsp]
  00256	0f b7 49 48	 movzx	 ecx, WORD PTR [rcx+72]
  0025a	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR [rsp+48], 0
  00263	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  00268	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG174688
  0026f	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00274	44 8b c9	 mov	 r9d, ecx
  00277	45 33 c0	 xor	 r8d, r8d
  0027a	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG174689
  00281	b9 00 00 02 00	 mov	 ecx, 131072		; 00020000H
  00286	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ptt_pthread_trace
$LN29@LCS_StartL:
  0028c	33 c0		 xor	 eax, eax
  0028e	85 c0		 test	 eax, eax
  00290	75 a2		 jne	 SHORT $LN10@LCS_StartL
$LN13@LCS_StartL:

; 5795 :     {
; 5796 :         // Configure the TAP interface if used
; 5797 :         PTT_DEBUG( "STRTLAN if started", pLCSPORT->fPortStarted, pDEVBLK->devnum, pLCSPORT->bPort );

  00292	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_pttclass
  00299	48 8b 00	 mov	 rax, QWORD PTR [rax]
  0029c	48 25 00 00 02
	00		 and	 rax, 131072		; 00020000H
  002a2	48 85 c0	 test	 rax, rax
  002a5	74 56		 je	 SHORT $LN30@LCS_StartL
  002a7	48 8b 44 24 48	 mov	 rax, QWORD PTR pLCSPORT$[rsp]
  002ac	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  002af	48 8b 4c 24 60	 mov	 rcx, QWORD PTR pDEVBLK$[rsp]
  002b4	0f b7 49 48	 movzx	 ecx, WORD PTR [rcx+72]
  002b8	48 8b 54 24 48	 mov	 rdx, QWORD PTR pLCSPORT$[rsp]
  002bd	8b 92 34 01 00
	00		 mov	 edx, DWORD PTR [rdx+308]
  002c3	c1 ea 03	 shr	 edx, 3
  002c6	83 e2 01	 and	 edx, 1
  002c9	8b d2		 mov	 edx, edx
  002cb	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR [rsp+48], 0
  002d4	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  002d9	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG174691
  002e0	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  002e5	44 8b c9	 mov	 r9d, ecx
  002e8	44 8b c2	 mov	 r8d, edx
  002eb	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG174692
  002f2	b9 00 00 02 00	 mov	 ecx, 131072		; 00020000H
  002f7	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ptt_pthread_trace
$LN30@LCS_StartL:
  002fd	33 c0		 xor	 eax, eax
  002ff	85 c0		 test	 eax, eax
  00301	75 8f		 jne	 SHORT $LN13@LCS_StartL

; 5798 :         if (pLCSPORT->fUsed && pLCSPORT->fPortCreated && !pLCSPORT->fPortStarted)

  00303	48 8b 44 24 48	 mov	 rax, QWORD PTR pLCSPORT$[rsp]
  00308	8b 80 34 01 00
	00		 mov	 eax, DWORD PTR [rax+308]
  0030e	83 e0 01	 and	 eax, 1
  00311	85 c0		 test	 eax, eax
  00313	0f 84 2f 01 00
	00		 je	 $LN31@LCS_StartL
  00319	48 8b 44 24 48	 mov	 rax, QWORD PTR pLCSPORT$[rsp]
  0031e	8b 80 34 01 00
	00		 mov	 eax, DWORD PTR [rax+308]
  00324	c1 e8 02	 shr	 eax, 2
  00327	83 e0 01	 and	 eax, 1
  0032a	85 c0		 test	 eax, eax
  0032c	0f 84 16 01 00
	00		 je	 $LN31@LCS_StartL
  00332	48 8b 44 24 48	 mov	 rax, QWORD PTR pLCSPORT$[rsp]
  00337	8b 80 34 01 00
	00		 mov	 eax, DWORD PTR [rax+308]
  0033d	c1 e8 03	 shr	 eax, 3
  00340	83 e0 01	 and	 eax, 1
  00343	85 c0		 test	 eax, eax
  00345	0f 85 fd 00 00
	00		 jne	 $LN31@LCS_StartL
$LN16@LCS_StartL:

; 5799 :         {
; 5800 :             PTT_DEBUG( "STRTLAN started=NO", 000, pDEVBLK->devnum, pLCSPORT->bPort );

  0034b	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_pttclass
  00352	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00355	48 25 00 00 02
	00		 and	 rax, 131072		; 00020000H
  0035b	48 85 c0	 test	 rax, rax
  0035e	74 43		 je	 SHORT $LN32@LCS_StartL
  00360	48 8b 44 24 48	 mov	 rax, QWORD PTR pLCSPORT$[rsp]
  00365	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  00368	48 8b 4c 24 60	 mov	 rcx, QWORD PTR pDEVBLK$[rsp]
  0036d	0f b7 49 48	 movzx	 ecx, WORD PTR [rcx+72]
  00371	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR [rsp+48], 0
  0037a	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  0037f	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG174695
  00386	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  0038b	44 8b c9	 mov	 r9d, ecx
  0038e	45 33 c0	 xor	 r8d, r8d
  00391	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG174696
  00398	b9 00 00 02 00	 mov	 ecx, 131072		; 00020000H
  0039d	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ptt_pthread_trace
$LN32@LCS_StartL:
  003a3	33 c0		 xor	 eax, eax
  003a5	85 c0		 test	 eax, eax
  003a7	75 a2		 jne	 SHORT $LN16@LCS_StartL

; 5801 :             nIFFlags =              // Interface flags

  003a9	c7 44 24 44 03
	00 00 00	 mov	 DWORD PTR nIFFlags$[rsp], 3

; 5802 :                 0
; 5803 :                 | IFF_UP            // (interface is being enabled)
; 5804 :                 | IFF_BROADCAST     // (interface broadcast addr is valid)
; 5805 :                 ;
; 5806 : 
; 5807 : #if defined( TUNTAP_IFF_RUNNING_NEEDED )
; 5808 : 
; 5809 :             nIFFlags |=             // ADDITIONAL Interface flags
; 5810 :                 0
; 5811 :                 | IFF_RUNNING       // (interface is ALSO operational)
; 5812 :                 ;
; 5813 : 
; 5814 : #endif /* defined( TUNTAP_IFF_RUNNING_NEEDED ) */
; 5815 : 
; 5816 :             // Enable the interface by turning on the IFF_UP flag...
; 5817 :             // This lets the packets start flowing...
; 5818 : 
; 5819 :             if (!pLCSPORT->fPreconfigured)

  003b1	48 8b 44 24 48	 mov	 rax, QWORD PTR pLCSPORT$[rsp]
  003b6	8b 80 34 01 00
	00		 mov	 eax, DWORD PTR [rax+308]
  003bc	c1 e8 06	 shr	 eax, 6
  003bf	83 e0 01	 and	 eax, 1
  003c2	85 c0		 test	 eax, eax
  003c4	75 7d		 jne	 SHORT $LN33@LCS_StartL
$LN19@LCS_StartL:

; 5820 :                 VERIFY( TUNTAP_SetFlags( pLCSPORT->szNetIfName, nIFFlags ) == 0 );

  003c6	48 8b 44 24 48	 mov	 rax, QWORD PTR pLCSPORT$[rsp]
  003cb	48 05 48 01 00
	00		 add	 rax, 328		; 00000148H
  003d1	8b 54 24 44	 mov	 edx, DWORD PTR nIFFlags$[rsp]
  003d5	48 8b c8	 mov	 rcx, rax
  003d8	e8 00 00 00 00	 call	 TUNTAP_SetFlags
  003dd	85 c0		 test	 eax, eax
  003df	74 5c		 je	 SHORT $LN34@LCS_StartL
$LN22@LCS_StartL:
  003e1	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG174699
  003e8	41 b8 bc 16 00
	00		 mov	 r8d, 5820		; 000016bcH
  003ee	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG174700
  003f5	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG174701
  003fc	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_logmsg
  00402	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_IsDebuggerPresent
  00408	85 c0		 test	 eax, eax
  0040a	74 20		 je	 SHORT $LN35@LCS_StartL
  0040c	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG174703
  00413	41 b8 bc 16 00
	00		 mov	 r8d, 5820		; 000016bcH
  00419	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG174704
  00420	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG174705
  00427	e8 00 00 00 00	 call	 DebuggerTrace
$LN35@LCS_StartL:
  0042c	33 c0		 xor	 eax, eax
  0042e	85 c0		 test	 eax, eax
  00430	75 af		 jne	 SHORT $LN22@LCS_StartL
  00432	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_IsDebuggerPresent
  00438	85 c0		 test	 eax, eax
  0043a	74 01		 je	 SHORT $LN36@LCS_StartL
  0043c	cc		 int	 3
$LN36@LCS_StartL:
$LN34@LCS_StartL:
  0043d	33 c0		 xor	 eax, eax
  0043f	85 c0		 test	 eax, eax
  00441	75 83		 jne	 SHORT $LN19@LCS_StartL
$LN33@LCS_StartL:

; 5821 : 
; 5822 :             fStartPending = 1;

  00443	c6 44 24 40 01	 mov	 BYTE PTR fStartPending$[rsp], 1
$LN31@LCS_StartL:
$LN25@LCS_StartL:

; 5823 :         }
; 5824 :     }
; 5825 :     PTT_DEBUG(         "REL  PortDataLock ", 000, pDEVBLK->devnum, pLCSPORT->bPort );

  00448	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_pttclass
  0044f	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00452	48 25 00 00 02
	00		 and	 rax, 131072		; 00020000H
  00458	48 85 c0	 test	 rax, rax
  0045b	74 43		 je	 SHORT $LN37@LCS_StartL
  0045d	48 8b 44 24 48	 mov	 rax, QWORD PTR pLCSPORT$[rsp]
  00462	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  00465	48 8b 4c 24 60	 mov	 rcx, QWORD PTR pDEVBLK$[rsp]
  0046a	0f b7 49 48	 movzx	 ecx, WORD PTR [rcx+72]
  0046e	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR [rsp+48], 0
  00477	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  0047c	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG174708
  00483	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00488	44 8b c9	 mov	 r9d, ecx
  0048b	45 33 c0	 xor	 r8d, r8d
  0048e	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG174709
  00495	b9 00 00 02 00	 mov	 ecx, 131072		; 00020000H
  0049a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ptt_pthread_trace
$LN37@LCS_StartL:
  004a0	33 c0		 xor	 eax, eax
  004a2	85 c0		 test	 eax, eax
  004a4	75 a2		 jne	 SHORT $LN25@LCS_StartL

; 5826 :     release_lock( &pLCSPORT->PortDataLock );

  004a6	48 8b 44 24 48	 mov	 rax, QWORD PTR pLCSPORT$[rsp]
  004ab	48 05 1c 01 00
	00		 add	 rax, 284		; 0000011cH
  004b1	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG174710
  004b8	48 8b c8	 mov	 rcx, rax
  004bb	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_release_lock

; 5827 : 
; 5828 :     if (fStartPending)

  004c1	0f b6 44 24 40	 movzx	 eax, BYTE PTR fStartPending$[rsp]
  004c6	85 c0		 test	 eax, eax
  004c8	74 14		 je	 SHORT $LN38@LCS_StartL

; 5829 :         UpdatePortStarted( TRUE, pDEVBLK, pLCSPORT );

  004ca	4c 8b 44 24 48	 mov	 r8, QWORD PTR pLCSPORT$[rsp]
  004cf	48 8b 54 24 60	 mov	 rdx, QWORD PTR pDEVBLK$[rsp]
  004d4	b9 01 00 00 00	 mov	 ecx, 1
  004d9	e8 00 00 00 00	 call	 UpdatePortStarted
$LN38@LCS_StartL:

; 5830 : 
; 5831 :     pLCSDEV->fDevStarted = 1;

  004de	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR pLCSDEV$[rsp]
  004e6	8b 40 41	 mov	 eax, DWORD PTR [rax+65]
  004e9	83 c8 02	 or	 eax, 2
  004ec	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR pLCSDEV$[rsp]
  004f4	89 41 41	 mov	 DWORD PTR [rcx+65], eax

; 5832 : 
; 5833 : }

  004f7	48 83 c4 78	 add	 rsp, 120		; 00000078H
  004fb	5f		 pop	 rdi
  004fc	5e		 pop	 rsi
  004fd	c3		 ret	 0
LCS_StartLan_SNA ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\ctc_lcs.c
_TEXT	SEGMENT
pLCSDEV$ = 96
hwLenBaf1$ = 104
hwLenBaf2$ = 108
hwOffset$ = 112
hwLength$ = 116
pLCSHDR$ = 120
tv287 = 128
pCmdFrame$ = 136
hwPrevOffset$ = 144
pLCSBAF1$ = 152
hwTypeBaf$ = 160
pLCSBAF2$ = 168
iTraceLen$ = 176
pLCSBLK$ = 184
tv255 = 192
tv762 = 196
pIOBufEnd$ = 200
pIOBufStart$ = 208
tv73 = 216
tv77 = 220
tv93 = 224
tv131 = 228
tv135 = 232
tv431 = 236
tv483 = 240
tv786 = 244
tv823 = 248
tv827 = 252
tv873 = 256
tv877 = 260
tv914 = 264
tv917 = 268
tv921 = 272
tv1018 = 276
tv577 = 280
tv573 = 284
tv570 = 288
tv534 = 292
tv530 = 296
tv487 = 300
tv745 = 304
tv782 = 308
tv1011 = 312
tv1015 = 320
buf$ = 328
unsupmsg$ = 368
__$ArrayPad$ = 624
pDEVBLK$ = 656
sCount$ = 664
pIOBuf$ = 672
pUnitStat$ = 680
pResidual$ = 688
LCS_Write_SNA PROC

; 4248 : {

  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  0000e	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00013	57		 push	 rdi
  00014	48 81 ec 80 02
	00 00		 sub	 rsp, 640		; 00000280H
  0001b	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00022	48 33 c4	 xor	 rax, rsp
  00025	48 89 84 24 70
	02 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 4249 : 
; 4250 :     PLCSDEV     pLCSDEV      = (PLCSDEV) pDEVBLK->dev_data;

  0002d	48 8b 84 24 90
	02 00 00	 mov	 rax, QWORD PTR pDEVBLK$[rsp]
  00035	48 8b 80 08 06
	00 00		 mov	 rax, QWORD PTR [rax+1544]
  0003c	48 89 44 24 60	 mov	 QWORD PTR pLCSDEV$[rsp], rax

; 4251 :     PLCSBLK     pLCSBLK      = pLCSDEV->pLCSBLK;

  00041	48 8b 44 24 60	 mov	 rax, QWORD PTR pLCSDEV$[rsp]
  00046	48 8b 40 08	 mov	 rax, QWORD PTR [rax+8]
  0004a	48 89 84 24 b8
	00 00 00	 mov	 QWORD PTR pLCSBLK$[rsp], rax

; 4252 :     PLCSHDR     pLCSHDR      = NULL;

  00052	48 c7 44 24 78
	00 00 00 00	 mov	 QWORD PTR pLCSHDR$[rsp], 0

; 4253 :     PLCSCMDHDR  pCmdFrame    = NULL;

  0005b	48 c7 84 24 88
	00 00 00 00 00
	00 00		 mov	 QWORD PTR pCmdFrame$[rsp], 0

; 4254 :     PLCSBAF1    pLCSBAF1     = NULL;

  00067	48 c7 84 24 98
	00 00 00 00 00
	00 00		 mov	 QWORD PTR pLCSBAF1$[rsp], 0

; 4255 :     PLCSBAF2    pLCSBAF2     = NULL;

  00073	48 c7 84 24 a8
	00 00 00 00 00
	00 00		 mov	 QWORD PTR pLCSBAF2$[rsp], 0

; 4256 :     BYTE*       pIOBufStart  = NULL;

  0007f	48 c7 84 24 d0
	00 00 00 00 00
	00 00		 mov	 QWORD PTR pIOBufStart$[rsp], 0

; 4257 :     BYTE*       pIOBufEnd    = NULL;

  0008b	48 c7 84 24 c8
	00 00 00 00 00
	00 00		 mov	 QWORD PTR pIOBufEnd$[rsp], 0

; 4258 :     U16         hwOffset     = 0;

  00097	33 c0		 xor	 eax, eax
  00099	66 89 44 24 70	 mov	 WORD PTR hwOffset$[rsp], ax

; 4259 :     U16         hwPrevOffset = 0;

  0009e	33 c0		 xor	 eax, eax
  000a0	66 89 84 24 90
	00 00 00	 mov	 WORD PTR hwPrevOffset$[rsp], ax

; 4260 :     U16         hwLength     = 0;

  000a8	33 c0		 xor	 eax, eax
  000aa	66 89 44 24 74	 mov	 WORD PTR hwLength$[rsp], ax

; 4261 :     U16         hwLenBaf1;
; 4262 :     U16         hwLenBaf2;
; 4263 :     U16         hwTypeBaf;
; 4264 :     int         iTraceLen;
; 4265 :     char        buf[32];
; 4266 :     char        unsupmsg[256];
; 4267 : 
; 4268 : 
; 4269 :     // Display up to pLCSBLK->iTraceLen bytes of the data coming from the guest, if debug is active
; 4270 :     if (pLCSBLK->fDebug)

  000af	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR pLCSBLK$[rsp]
  000b7	8b 40 18	 mov	 eax, DWORD PTR [rax+24]
  000ba	83 e0 01	 and	 eax, 1
  000bd	85 c0		 test	 eax, eax
  000bf	0f 84 e9 01 00
	00		 je	 $LN106@LCS_Write_

; 4271 :     {
; 4272 :         // "%1d:%04X %s: Accept data of size %d bytes from guest"
; 4273 :         WRMSG(HHC00981, "D", SSID_TO_LCSS(pDEVBLK->ssid), pDEVBLK->devnum,  pDEVBLK->typname, (int)sCount );

  000c5	48 8b 84 24 90
	02 00 00	 mov	 rax, QWORD PTR pDEVBLK$[rsp]
  000cd	0f b7 40 48	 movzx	 eax, WORD PTR [rax+72]
  000d1	89 84 24 d8 00
	00 00		 mov	 DWORD PTR tv73[rsp], eax
  000d8	48 8b 8c 24 90
	02 00 00	 mov	 rcx, QWORD PTR pDEVBLK$[rsp]
  000e0	0f b7 49 44	 movzx	 ecx, WORD PTR [rcx+68]
  000e4	d1 f9		 sar	 ecx, 1
  000e6	89 8c 24 dc 00
	00 00		 mov	 DWORD PTR tv77[rsp], ecx
  000ed	b9 01 00 00 00	 mov	 ecx, 1
  000f2	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  000f8	8b 8c 24 98 02
	00 00		 mov	 ecx, DWORD PTR sCount$[rsp]
  000ff	89 4c 24 50	 mov	 DWORD PTR [rsp+80], ecx
  00103	48 8b 8c 24 90
	02 00 00	 mov	 rcx, QWORD PTR pDEVBLK$[rsp]
  0010b	48 8b 49 50	 mov	 rcx, QWORD PTR [rcx+80]
  0010f	48 89 4c 24 48	 mov	 QWORD PTR [rsp+72], rcx
  00114	8b 8c 24 d8 00
	00 00		 mov	 ecx, DWORD PTR tv73[rsp]
  0011b	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  0011f	8b 8c 24 dc 00
	00 00		 mov	 ecx, DWORD PTR tv77[rsp]
  00126	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  0012a	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG173644
  00131	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  00136	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG173645
  0013d	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00142	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00147	41 b9 03 00 00
	00		 mov	 r9d, 3
  0014d	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG173646
  00154	ba b1 10 00 00	 mov	 edx, 4273		; 000010b1H
  00159	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG173647
  00160	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 4274 :         if (pLCSBLK->iTraceLen)

  00166	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR pLCSBLK$[rsp]
  0016e	83 78 28 00	 cmp	 DWORD PTR [rax+40], 0
  00172	0f 84 36 01 00
	00		 je	 $LN107@LCS_Write_

; 4275 :         {
; 4276 :             iTraceLen = sCount;

  00178	8b 84 24 98 02
	00 00		 mov	 eax, DWORD PTR sCount$[rsp]
  0017f	89 84 24 b0 00
	00 00		 mov	 DWORD PTR iTraceLen$[rsp], eax

; 4277 :             if (iTraceLen > pLCSBLK->iTraceLen)

  00186	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR pLCSBLK$[rsp]
  0018e	8b 40 28	 mov	 eax, DWORD PTR [rax+40]
  00191	39 84 24 b0 00
	00 00		 cmp	 DWORD PTR iTraceLen$[rsp], eax
  00198	0f 8e d7 00 00
	00		 jle	 $LN108@LCS_Write_

; 4278 :             {
; 4279 :                 iTraceLen = pLCSBLK->iTraceLen;

  0019e	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR pLCSBLK$[rsp]
  001a6	8b 40 28	 mov	 eax, DWORD PTR [rax+40]
  001a9	89 84 24 b0 00
	00 00		 mov	 DWORD PTR iTraceLen$[rsp], eax

; 4280 :                 // HHC00980 "%1d:%04X %s: Data of size %d bytes displayed, data of size %d bytes not displayed"
; 4281 :                 WRMSG(HHC00980, "D", SSID_TO_LCSS(pDEVBLK->ssid), pDEVBLK->devnum, pDEVBLK->typname,

  001b0	8b 84 24 b0 00
	00 00		 mov	 eax, DWORD PTR iTraceLen$[rsp]
  001b7	8b 8c 24 98 02
	00 00		 mov	 ecx, DWORD PTR sCount$[rsp]
  001be	2b c8		 sub	 ecx, eax
  001c0	8b c1		 mov	 eax, ecx
  001c2	89 84 24 e0 00
	00 00		 mov	 DWORD PTR tv93[rsp], eax
  001c9	48 8b 8c 24 90
	02 00 00	 mov	 rcx, QWORD PTR pDEVBLK$[rsp]
  001d1	0f b7 49 48	 movzx	 ecx, WORD PTR [rcx+72]
  001d5	89 8c 24 e4 00
	00 00		 mov	 DWORD PTR tv131[rsp], ecx
  001dc	48 8b 94 24 90
	02 00 00	 mov	 rdx, QWORD PTR pDEVBLK$[rsp]
  001e4	0f b7 52 44	 movzx	 edx, WORD PTR [rdx+68]
  001e8	d1 fa		 sar	 edx, 1
  001ea	89 94 24 e8 00
	00 00		 mov	 DWORD PTR tv135[rsp], edx
  001f1	b9 01 00 00 00	 mov	 ecx, 1
  001f6	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  001fc	8b 8c 24 e0 00
	00 00		 mov	 ecx, DWORD PTR tv93[rsp]
  00203	89 4c 24 58	 mov	 DWORD PTR [rsp+88], ecx
  00207	8b 8c 24 b0 00
	00 00		 mov	 ecx, DWORD PTR iTraceLen$[rsp]
  0020e	89 4c 24 50	 mov	 DWORD PTR [rsp+80], ecx
  00212	48 8b 8c 24 90
	02 00 00	 mov	 rcx, QWORD PTR pDEVBLK$[rsp]
  0021a	48 8b 49 50	 mov	 rcx, QWORD PTR [rcx+80]
  0021e	48 89 4c 24 48	 mov	 QWORD PTR [rsp+72], rcx
  00223	8b 8c 24 e4 00
	00 00		 mov	 ecx, DWORD PTR tv131[rsp]
  0022a	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  0022e	8b 8c 24 e8 00
	00 00		 mov	 ecx, DWORD PTR tv135[rsp]
  00235	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  00239	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG173650
  00240	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  00245	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG173651
  0024c	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00251	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00256	41 b9 03 00 00
	00		 mov	 r9d, 3
  0025c	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG173652
  00263	ba ba 10 00 00	 mov	 edx, 4282		; 000010baH
  00268	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG173653
  0026f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg
$LN108@LCS_Write_:

; 4282 :                                      iTraceLen, (int)(sCount - iTraceLen) );
; 4283 :             }
; 4284 :             net_data_trace( pDEVBLK, pIOBuf, iTraceLen, FROM_GUEST, 'D', "data", 0 );

  00275	c7 44 24 30 00
	00 00 00	 mov	 DWORD PTR [rsp+48], 0
  0027d	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG173654
  00284	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  00289	c6 44 24 20 44	 mov	 BYTE PTR [rsp+32], 68	; 00000044H
  0028e	41 b1 3c	 mov	 r9b, 60			; 0000003cH
  00291	44 8b 84 24 b0
	00 00 00	 mov	 r8d, DWORD PTR iTraceLen$[rsp]
  00299	48 8b 94 24 a0
	02 00 00	 mov	 rdx, QWORD PTR pIOBuf$[rsp]
  002a1	48 8b 8c 24 90
	02 00 00	 mov	 rcx, QWORD PTR pDEVBLK$[rsp]
  002a9	e8 00 00 00 00	 call	 net_data_trace
$LN107@LCS_Write_:
$LN106@LCS_Write_:
$LN4@LCS_Write_:

; 4285 :         }
; 4286 :     }
; 4287 : 
; 4288 :     // Process each frame in the buffer...
; 4289 : 
; 4290 :     PTT_DEBUG( "WSNA ENTRY        ", 000, pDEVBLK->devnum, -1 );

  002ae	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_pttclass
  002b5	48 8b 00	 mov	 rax, QWORD PTR [rax]
  002b8	48 25 00 00 02
	00		 and	 rax, 131072		; 00020000H
  002be	48 85 c0	 test	 rax, rax
  002c1	74 42		 je	 SHORT $LN109@LCS_Write_
  002c3	48 8b 84 24 90
	02 00 00	 mov	 rax, QWORD PTR pDEVBLK$[rsp]
  002cb	0f b7 40 48	 movzx	 eax, WORD PTR [rax+72]
  002cf	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR [rsp+48], 0
  002d8	48 c7 44 24 28
	ff ff ff ff	 mov	 QWORD PTR [rsp+40], -1
  002e1	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG173656
  002e8	48 89 4c 24 20	 mov	 QWORD PTR [rsp+32], rcx
  002ed	44 8b c8	 mov	 r9d, eax
  002f0	45 33 c0	 xor	 r8d, r8d
  002f3	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG173657
  002fa	b9 00 00 02 00	 mov	 ecx, 131072		; 00020000H
  002ff	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ptt_pthread_trace
$LN109@LCS_Write_:
  00305	33 c0		 xor	 eax, eax
  00307	85 c0		 test	 eax, eax
  00309	75 a3		 jne	 SHORT $LN4@LCS_Write_
$LN7@LCS_Write_:

; 4291 :     PTT_TIMING( "beg write", 0, 0, 0 );

  0030b	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_pttclass
  00312	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00315	48 25 00 00 01
	00		 and	 rax, 65536		; 00010000H
  0031b	48 85 c0	 test	 rax, rax
  0031e	74 36		 je	 SHORT $LN110@LCS_Write_
  00320	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR [rsp+48], 0
  00329	48 c7 44 24 28
	00 00 00 00	 mov	 QWORD PTR [rsp+40], 0
  00332	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG173659
  00339	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  0033e	45 33 c9	 xor	 r9d, r9d
  00341	45 33 c0	 xor	 r8d, r8d
  00344	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG173660
  0034b	b9 00 00 01 00	 mov	 ecx, 65536		; 00010000H
  00350	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ptt_pthread_trace
$LN110@LCS_Write_:
  00356	33 c0		 xor	 eax, eax
  00358	85 c0		 test	 eax, eax
  0035a	75 af		 jne	 SHORT $LN7@LCS_Write_

; 4292 : 
; 4293 :     pLCSDEV->fTuntapError = FALSE;

  0035c	48 8b 44 24 60	 mov	 rax, QWORD PTR pLCSDEV$[rsp]
  00361	8b 40 5d	 mov	 eax, DWORD PTR [rax+93]
  00364	83 e0 ef	 and	 eax, -17		; ffffffefH
  00367	48 8b 4c 24 60	 mov	 rcx, QWORD PTR pLCSDEV$[rsp]
  0036c	89 41 5d	 mov	 DWORD PTR [rcx+93], eax

; 4294 :     pLCSDEV->iTuntapErrno = 0;

  0036f	48 8b 44 24 60	 mov	 rax, QWORD PTR pLCSDEV$[rsp]
  00374	c7 40 61 00 00
	00 00		 mov	 DWORD PTR [rax+97], 0

; 4295 : 
; 4296 :     // Check whether the Write CCW is the second of three CCW's in the
; 4297 :     // WCTL or SCB channel programs. The channel program contains Control
; 4298 :     // (0x17) or Sense Command Byte (0x14), Write (0x01) and Read (0x02)
; 4299 :     // CCW's. The first, or only, 8-bytes of the Write data are an LCSOCTL.
; 4300 :     if (pLCSDEV->bFlipFlop)

  0037b	48 8b 44 24 60	 mov	 rax, QWORD PTR pLCSDEV$[rsp]
  00380	0f b6 40 65	 movzx	 eax, BYTE PTR [rax+101]
  00384	85 c0		 test	 eax, eax
  00386	0f 84 ee 0e 00
	00		 je	 $LN111@LCS_Write_

; 4301 :     {
; 4302 : 
; 4303 :         // The following is an example of the data written by a Write
; 4304 :         // CCW in the WCTL channel program, and occasionally in the
; 4305 :         // SCB channel program.
; 4306 :         //    +0000< 00160000 00000000 00140400 000C0C99  ................ ...............r
; 4307 :         //    +0010< 0003C000 00000000 01000000 0000      ..............   ..{...........
; 4308 :         // The first 8-bytes are the LCSOCTL. The next 20-bytes are an
; 4309 :         // LCSHDR and associated LCSBAF1 and LCSBAF2. The final 2-bytes
; 4310 :         // are the end of data marker.
; 4311 : 
; 4312 :         // Copy the OCTL that has just arrived
; 4313 :         pLCSDEV->hwOctlSize = sizeof(LCSOCTL);

  0038c	b8 08 00 00 00	 mov	 eax, 8
  00391	48 8b 4c 24 60	 mov	 rcx, QWORD PTR pLCSDEV$[rsp]
  00396	66 89 41 45	 mov	 WORD PTR [rcx+69], ax

; 4314 :         memcpy( &pLCSDEV->Octl, pIOBuf, sizeof(LCSOCTL) );

  0039a	48 8b 44 24 60	 mov	 rax, QWORD PTR pLCSDEV$[rsp]
  0039f	48 8b 8c 24 a0
	02 00 00	 mov	 rcx, QWORD PTR pIOBuf$[rsp]
  003a7	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  003aa	48 89 48 47	 mov	 QWORD PTR [rax+71], rcx

; 4315 : 
; 4316 :         // Point to whatever follows the OCTL
; 4317 :         pIOBufStart = &pIOBuf[sizeof(LCSOCTL)];

  003ae	b8 01 00 00 00	 mov	 eax, 1
  003b3	48 6b c0 08	 imul	 rax, rax, 8
  003b7	48 8b 8c 24 a0
	02 00 00	 mov	 rcx, QWORD PTR pIOBuf$[rsp]
  003bf	48 03 c8	 add	 rcx, rax
  003c2	48 8b c1	 mov	 rax, rcx
  003c5	48 89 84 24 d0
	00 00 00	 mov	 QWORD PTR pIOBufStart$[rsp], rax

; 4318 :         pIOBufEnd = pIOBuf + sCount;

  003cd	8b 84 24 98 02
	00 00		 mov	 eax, DWORD PTR sCount$[rsp]
  003d4	48 8b 8c 24 a0
	02 00 00	 mov	 rcx, QWORD PTR pIOBuf$[rsp]
  003dc	48 03 c8	 add	 rcx, rax
  003df	48 8b c1	 mov	 rax, rcx
  003e2	48 89 84 24 c8
	00 00 00	 mov	 QWORD PTR pIOBufEnd$[rsp], rax

; 4319 : 
; 4320 :         //
; 4321 :         if (sCount > sizeof(LCSOCTL))

  003ea	8b 84 24 98 02
	00 00		 mov	 eax, DWORD PTR sCount$[rsp]
  003f1	48 83 f8 08	 cmp	 rax, 8
  003f5	0f 86 19 0e 00
	00		 jbe	 $LN113@LCS_Write_
$LN10@LCS_Write_:

; 4322 :         {
; 4323 : 
; 4324 :             // The output is an OCTL followed by data
; 4325 : 
; 4326 :             PTT_DEBUG( "WSNA: OCTL & data ", -1, pDEVBLK->devnum, -1 );

  003fb	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_pttclass
  00402	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00405	48 25 00 00 02
	00		 and	 rax, 131072		; 00020000H
  0040b	48 85 c0	 test	 rax, rax
  0040e	74 46		 je	 SHORT $LN115@LCS_Write_
  00410	48 8b 84 24 90
	02 00 00	 mov	 rax, QWORD PTR pDEVBLK$[rsp]
  00418	0f b7 40 48	 movzx	 eax, WORD PTR [rax+72]
  0041c	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR [rsp+48], 0
  00425	48 c7 44 24 28
	ff ff ff ff	 mov	 QWORD PTR [rsp+40], -1
  0042e	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG173666
  00435	48 89 4c 24 20	 mov	 QWORD PTR [rsp+32], rcx
  0043a	44 8b c8	 mov	 r9d, eax
  0043d	49 c7 c0 ff ff
	ff ff		 mov	 r8, -1
  00444	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG173667
  0044b	b9 00 00 02 00	 mov	 ecx, 131072		; 00020000H
  00450	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ptt_pthread_trace
$LN115@LCS_Write_:
  00456	33 c0		 xor	 eax, eax
  00458	85 c0		 test	 eax, eax
  0045a	75 9f		 jne	 SHORT $LN10@LCS_Write_
$LN13@LCS_Write_:

; 4327 : 
; 4328 :             //
; 4329 :             PTT_DEBUG(       "GET  InOutLock    ", 000, pDEVBLK->devnum, -1 );

  0045c	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_pttclass
  00463	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00466	48 25 00 00 02
	00		 and	 rax, 131072		; 00020000H
  0046c	48 85 c0	 test	 rax, rax
  0046f	74 42		 je	 SHORT $LN116@LCS_Write_
  00471	48 8b 84 24 90
	02 00 00	 mov	 rax, QWORD PTR pDEVBLK$[rsp]
  00479	0f b7 40 48	 movzx	 eax, WORD PTR [rax+72]
  0047d	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR [rsp+48], 0
  00486	48 c7 44 24 28
	ff ff ff ff	 mov	 QWORD PTR [rsp+40], -1
  0048f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG173669
  00496	48 89 4c 24 20	 mov	 QWORD PTR [rsp+32], rcx
  0049b	44 8b c8	 mov	 r9d, eax
  0049e	45 33 c0	 xor	 r8d, r8d
  004a1	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG173670
  004a8	b9 00 00 02 00	 mov	 ecx, 131072		; 00020000H
  004ad	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ptt_pthread_trace
$LN116@LCS_Write_:
  004b3	33 c0		 xor	 eax, eax
  004b5	85 c0		 test	 eax, eax
  004b7	75 a3		 jne	 SHORT $LN13@LCS_Write_

; 4330 :             obtain_lock( &pLCSDEV->InOutLock   );

  004b9	48 8b 44 24 60	 mov	 rax, QWORD PTR pLCSDEV$[rsp]
  004be	48 05 92 00 00
	00		 add	 rax, 146		; 00000092H
  004c4	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG173671
  004cb	48 8b c8	 mov	 rcx, rax
  004ce	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_obtain_lock
$LN16@LCS_Write_:

; 4331 :             PTT_DEBUG(       "GOT  InOutLock    ", 000, pDEVBLK->devnum, -1 );

  004d4	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_pttclass
  004db	48 8b 00	 mov	 rax, QWORD PTR [rax]
  004de	48 25 00 00 02
	00		 and	 rax, 131072		; 00020000H
  004e4	48 85 c0	 test	 rax, rax
  004e7	74 42		 je	 SHORT $LN117@LCS_Write_
  004e9	48 8b 84 24 90
	02 00 00	 mov	 rax, QWORD PTR pDEVBLK$[rsp]
  004f1	0f b7 40 48	 movzx	 eax, WORD PTR [rax+72]
  004f5	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR [rsp+48], 0
  004fe	48 c7 44 24 28
	ff ff ff ff	 mov	 QWORD PTR [rsp+40], -1
  00507	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG173673
  0050e	48 89 4c 24 20	 mov	 QWORD PTR [rsp+32], rcx
  00513	44 8b c8	 mov	 r9d, eax
  00516	45 33 c0	 xor	 r8d, r8d
  00519	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG173674
  00520	b9 00 00 02 00	 mov	 ecx, 131072		; 00020000H
  00525	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ptt_pthread_trace
$LN117@LCS_Write_:
  0052b	33 c0		 xor	 eax, eax
  0052d	85 c0		 test	 eax, eax
  0052f	75 a3		 jne	 SHORT $LN16@LCS_Write_
$LN17@LCS_Write_:

; 4332 : 
; 4333 :             //
; 4334 :             while (1)

  00531	33 c0		 xor	 eax, eax
  00533	83 f8 01	 cmp	 eax, 1
  00536	0f 84 5e 0c 00
	00		 je	 $LN18@LCS_Write_

; 4335 :             {
; 4336 :                 // Save current offset so we can tell how big the next frame is.
; 4337 :                 hwPrevOffset = hwOffset;

  0053c	0f b7 44 24 70	 movzx	 eax, WORD PTR hwOffset$[rsp]
  00541	66 89 84 24 90
	00 00 00	 mov	 WORD PTR hwPrevOffset$[rsp], ax

; 4338 : 
; 4339 :                 // Point to where the LCSHDR at the start of the next frame should be.
; 4340 :                 pLCSHDR = (PLCSHDR)( pIOBufStart + hwOffset );

  00549	0f b7 44 24 70	 movzx	 eax, WORD PTR hwOffset$[rsp]
  0054e	48 8b 8c 24 d0
	00 00 00	 mov	 rcx, QWORD PTR pIOBufStart$[rsp]
  00556	48 03 c8	 add	 rcx, rax
  00559	48 8b c1	 mov	 rax, rcx
  0055c	48 89 44 24 78	 mov	 QWORD PTR pLCSHDR$[rsp], rax

; 4341 : 
; 4342 :                 // Check that there is enough of the LCSHDR to contain the next
; 4343 :                 // frame offset, exit the loop if there isn't.
; 4344 :                 if ((int)(pIOBufEnd - (BYTE*)pLCSHDR) < (int)sizeof(pLCSHDR->hwOffset))

  00561	48 8b 44 24 78	 mov	 rax, QWORD PTR pLCSHDR$[rsp]
  00566	48 8b 8c 24 c8
	00 00 00	 mov	 rcx, QWORD PTR pIOBufEnd$[rsp]
  0056e	48 2b c8	 sub	 rcx, rax
  00571	48 8b c1	 mov	 rax, rcx
  00574	83 f8 02	 cmp	 eax, 2
  00577	7d 05		 jge	 SHORT $LN118@LCS_Write_

; 4345 :                     break;

  00579	e9 1c 0c 00 00	 jmp	 $LN18@LCS_Write_
$LN118@LCS_Write_:

; 4346 : 
; 4347 :                 // Get the next frame offset, exit the loop if zero.
; 4348 :                 FETCH_HW( hwOffset, pLCSHDR->hwOffset );

  0057e	48 8b 44 24 78	 mov	 rax, QWORD PTR pLCSHDR$[rsp]
  00583	48 8b c8	 mov	 rcx, rax
  00586	e8 00 00 00 00	 call	 fetch_hw_noswap
  0058b	0f b7 c8	 movzx	 ecx, ax
  0058e	e8 00 00 00 00	 call	 _byteswap_ushort
  00593	66 89 44 24 70	 mov	 WORD PTR hwOffset$[rsp], ax

; 4349 :                 if (hwOffset == 0)   // ("EOF")

  00598	0f b7 44 24 70	 movzx	 eax, WORD PTR hwOffset$[rsp]
  0059d	85 c0		 test	 eax, eax
  0059f	75 05		 jne	 SHORT $LN119@LCS_Write_

; 4350 :                     break;

  005a1	e9 f4 0b 00 00	 jmp	 $LN18@LCS_Write_
$LN119@LCS_Write_:

; 4351 : 
; 4352 :                 // Calculate size of this LCS Frame
; 4353 :                 hwLength = hwOffset - hwPrevOffset;

  005a6	0f b7 44 24 70	 movzx	 eax, WORD PTR hwOffset$[rsp]
  005ab	0f b7 8c 24 90
	00 00 00	 movzx	 ecx, WORD PTR hwPrevOffset$[rsp]
  005b3	2b c1		 sub	 eax, ecx
  005b5	66 89 44 24 74	 mov	 WORD PTR hwLength$[rsp], ax

; 4354 : 
; 4355 :                 switch (pLCSHDR->bType)

  005ba	48 8b 44 24 78	 mov	 rax, QWORD PTR pLCSHDR$[rsp]
  005bf	0f b6 40 02	 movzx	 eax, BYTE PTR [rax+2]
  005c3	88 84 24 c0 00
	00 00		 mov	 BYTE PTR tv255[rsp], al
  005ca	80 bc 24 c0 00
	00 00 00	 cmp	 BYTE PTR tv255[rsp], 0
  005d2	0f 84 b6 05 00
	00		 je	 $LN136@LCS_Write_
  005d8	80 bc 24 c0 00
	00 00 04	 cmp	 BYTE PTR tv255[rsp], 4
  005e0	74 05		 je	 SHORT $LN120@LCS_Write_
  005e2	e9 ed 08 00 00	 jmp	 $LN144@LCS_Write_
$LN120@LCS_Write_:
$LN23@LCS_Write_:

; 4356 :                 {
; 4357 : 
; 4358 :                 case LCS_FRMTYP_SNA:    // 0x04: LCS Baffle
; 4359 : 
; 4360 :                     PTT_DEBUG( "WSNA: Baffle 1    ", -1, pDEVBLK->devnum, -1 );

  005e7	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_pttclass
  005ee	48 8b 00	 mov	 rax, QWORD PTR [rax]
  005f1	48 25 00 00 02
	00		 and	 rax, 131072		; 00020000H
  005f7	48 85 c0	 test	 rax, rax
  005fa	74 46		 je	 SHORT $LN121@LCS_Write_
  005fc	48 8b 84 24 90
	02 00 00	 mov	 rax, QWORD PTR pDEVBLK$[rsp]
  00604	0f b7 40 48	 movzx	 eax, WORD PTR [rax+72]
  00608	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR [rsp+48], 0
  00611	48 c7 44 24 28
	ff ff ff ff	 mov	 QWORD PTR [rsp+40], -1
  0061a	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG173679
  00621	48 89 4c 24 20	 mov	 QWORD PTR [rsp+32], rcx
  00626	44 8b c8	 mov	 r9d, eax
  00629	49 c7 c0 ff ff
	ff ff		 mov	 r8, -1
  00630	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG173680
  00637	b9 00 00 02 00	 mov	 ecx, 131072		; 00020000H
  0063c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ptt_pthread_trace
$LN121@LCS_Write_:
  00642	33 c0		 xor	 eax, eax
  00644	85 c0		 test	 eax, eax
  00646	75 9f		 jne	 SHORT $LN23@LCS_Write_

; 4361 : 
; 4362 :                     // Point to and get length of the LCSBAF1/LCSBAF2 structures.
; 4363 :                     pLCSBAF1 = (PLCSBAF1)( (BYTE*)pLCSHDR + sizeof(LCSHDR) );

  00648	48 8b 44 24 78	 mov	 rax, QWORD PTR pLCSHDR$[rsp]
  0064d	48 83 c0 04	 add	 rax, 4
  00651	48 89 84 24 98
	00 00 00	 mov	 QWORD PTR pLCSBAF1$[rsp], rax

; 4364 :                     FETCH_HW( hwLenBaf1, pLCSBAF1->hwLenBaf1 );

  00659	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR pLCSBAF1$[rsp]
  00661	48 8b c8	 mov	 rcx, rax
  00664	e8 00 00 00 00	 call	 fetch_hw_noswap
  00669	0f b7 c8	 movzx	 ecx, ax
  0066c	e8 00 00 00 00	 call	 _byteswap_ushort
  00671	66 89 44 24 68	 mov	 WORD PTR hwLenBaf1$[rsp], ax

; 4365 :                     FETCH_HW( hwLenBaf2, pLCSBAF1->hwLenBaf2 );

  00676	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR pLCSBAF1$[rsp]
  0067e	48 83 c0 04	 add	 rax, 4
  00682	48 8b c8	 mov	 rcx, rax
  00685	e8 00 00 00 00	 call	 fetch_hw_noswap
  0068a	0f b7 c8	 movzx	 ecx, ax
  0068d	e8 00 00 00 00	 call	 _byteswap_ushort
  00692	66 89 44 24 6c	 mov	 WORD PTR hwLenBaf2$[rsp], ax

; 4366 :                     pLCSBAF2 = (PLCSBAF2)( (BYTE*)pLCSBAF1 + hwLenBaf1 );

  00697	0f b7 44 24 68	 movzx	 eax, WORD PTR hwLenBaf1$[rsp]
  0069c	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR pLCSBAF1$[rsp]
  006a4	48 03 c8	 add	 rcx, rax
  006a7	48 8b c1	 mov	 rax, rcx
  006aa	48 89 84 24 a8
	00 00 00	 mov	 QWORD PTR pLCSBAF2$[rsp], rax

; 4367 : 
; 4368 :                     // Process the LCSBAF1/LCSBAF2 structures.
; 4369 :                     FETCH_HW( hwTypeBaf, pLCSBAF1->hwTypeBaf );

  006b2	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR pLCSBAF1$[rsp]
  006ba	48 83 c0 02	 add	 rax, 2
  006be	48 8b c8	 mov	 rcx, rax
  006c1	e8 00 00 00 00	 call	 fetch_hw_noswap
  006c6	0f b7 c8	 movzx	 ecx, ax
  006c9	e8 00 00 00 00	 call	 _byteswap_ushort
  006ce	66 89 84 24 a0
	00 00 00	 mov	 WORD PTR hwTypeBaf$[rsp], ax

; 4370 :                     switch (hwTypeBaf)

  006d6	0f b7 84 24 a0
	00 00 00	 movzx	 eax, WORD PTR hwTypeBaf$[rsp]
  006de	89 84 24 80 00
	00 00		 mov	 DWORD PTR tv287[rsp], eax
  006e5	81 bc 24 80 00
	00 00 98 0c 00
	00		 cmp	 DWORD PTR tv287[rsp], 3224 ; 00000c98H
  006f0	7f 55		 jg	 SHORT $LN180@LCS_Write_
  006f2	81 bc 24 80 00
	00 00 98 0c 00
	00		 cmp	 DWORD PTR tv287[rsp], 3224 ; 00000c98H
  006fd	0f 84 5d 03 00
	00		 je	 $LN133@LCS_Write_
  00703	8b 84 24 80 00
	00 00		 mov	 eax, DWORD PTR tv287[rsp]
  0070a	2d 0a 0c 00 00	 sub	 eax, 3082		; 00000c0aH
  0070f	89 84 24 80 00
	00 00		 mov	 DWORD PTR tv287[rsp], eax
  00716	83 bc 24 80 00
	00 00 1b	 cmp	 DWORD PTR tv287[rsp], 27
  0071e	0f 87 87 03 00
	00		 ja	 $LN134@LCS_Write_
  00724	48 63 84 24 80
	00 00 00	 movsxd	 rax, DWORD PTR tv287[rsp]
  0072c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__ImageBase
  00733	0f b6 84 01 00
	00 00 00	 movzx	 eax, BYTE PTR $LN181@LCS_Write_[rcx+rax]
  0073b	8b 84 81 00 00
	00 00		 mov	 eax, DWORD PTR $LN182@LCS_Write_[rcx+rax*4]
  00742	48 03 c1	 add	 rax, rcx
  00745	ff e0		 jmp	 rax
$LN180@LCS_Write_:
  00747	81 bc 24 80 00
	00 00 99 0c 00
	00		 cmp	 DWORD PTR tv287[rsp], 3225 ; 00000c99H
  00752	0f 84 27 02 00
	00		 je	 $LN130@LCS_Write_
  00758	81 bc 24 80 00
	00 00 00 0d 00
	00		 cmp	 DWORD PTR tv287[rsp], 3328 ; 00000d00H
  00763	74 6c		 je	 SHORT $LN123@LCS_Write_
  00765	81 bc 24 80 00
	00 00 10 0d 00
	00		 cmp	 DWORD PTR tv287[rsp], 3344 ; 00000d10H
  00770	74 27		 je	 SHORT $LN122@LCS_Write_
  00772	81 bc 24 80 00
	00 00 0b 8c 00
	00		 cmp	 DWORD PTR tv287[rsp], 35851 ; 00008c0bH
  0077d	0f 84 86 00 00
	00		 je	 $LN124@LCS_Write_
  00783	81 bc 24 80 00
	00 00 00 8d 00
	00		 cmp	 DWORD PTR tv287[rsp], 36096 ; 00008d00H
  0078e	0f 84 68 01 00
	00		 je	 $LN128@LCS_Write_
  00794	e9 12 03 00 00	 jmp	 $LN134@LCS_Write_
$LN122@LCS_Write_:

; 4371 :                     {
; 4372 : 
; 4373 :                     // 0D10 is used when the connection is active for outbound frames.
; 4374 : 
; 4375 :                     case 0x0D10:
; 4376 :                         Process_0D10( pLCSDEV, pLCSHDR, pLCSBAF1, pLCSBAF2, hwLenBaf1, hwLenBaf2 );

  00799	0f b7 44 24 6c	 movzx	 eax, WORD PTR hwLenBaf2$[rsp]
  0079e	66 89 44 24 28	 mov	 WORD PTR [rsp+40], ax
  007a3	0f b7 44 24 68	 movzx	 eax, WORD PTR hwLenBaf1$[rsp]
  007a8	66 89 44 24 20	 mov	 WORD PTR [rsp+32], ax
  007ad	4c 8b 8c 24 a8
	00 00 00	 mov	 r9, QWORD PTR pLCSBAF2$[rsp]
  007b5	4c 8b 84 24 98
	00 00 00	 mov	 r8, QWORD PTR pLCSBAF1$[rsp]
  007bd	48 8b 54 24 78	 mov	 rdx, QWORD PTR pLCSHDR$[rsp]
  007c2	48 8b 4c 24 60	 mov	 rcx, QWORD PTR pLCSDEV$[rsp]
  007c7	e8 00 00 00 00	 call	 Process_0D10

; 4377 :                         break;

  007cc	e9 b8 03 00 00	 jmp	 $LN24@LCS_Write_
$LN123@LCS_Write_:

; 4378 : 
; 4379 :                     // 0D00 is used when the connection is active for ???.
; 4380 : 
; 4381 :                     case 0x0D00:
; 4382 :                         Process_0D00( pLCSDEV, pLCSHDR, pLCSBAF1, pLCSBAF2, hwLenBaf1, hwLenBaf2 );

  007d1	0f b7 44 24 6c	 movzx	 eax, WORD PTR hwLenBaf2$[rsp]
  007d6	66 89 44 24 28	 mov	 WORD PTR [rsp+40], ax
  007db	0f b7 44 24 68	 movzx	 eax, WORD PTR hwLenBaf1$[rsp]
  007e0	66 89 44 24 20	 mov	 WORD PTR [rsp+32], ax
  007e5	4c 8b 8c 24 a8
	00 00 00	 mov	 r9, QWORD PTR pLCSBAF2$[rsp]
  007ed	4c 8b 84 24 98
	00 00 00	 mov	 r8, QWORD PTR pLCSBAF1$[rsp]
  007f5	48 8b 54 24 78	 mov	 rdx, QWORD PTR pLCSHDR$[rsp]
  007fa	48 8b 4c 24 60	 mov	 rcx, QWORD PTR pLCSDEV$[rsp]
  007ff	e8 00 00 00 00	 call	 Process_0D00

; 4383 :                         break;

  00804	e9 80 03 00 00	 jmp	 $LN24@LCS_Write_
$LN124@LCS_Write_:

; 4384 : 
; 4385 :                     // 8C0B is used when a connection is inactivated.
; 4386 : 
; 4387 :                     case 0x8C0B:
; 4388 :                         Process_8C0B( pLCSDEV, pLCSHDR, pLCSBAF1, pLCSBAF2, hwLenBaf1, hwLenBaf2 );

  00809	0f b7 44 24 6c	 movzx	 eax, WORD PTR hwLenBaf2$[rsp]
  0080e	66 89 44 24 28	 mov	 WORD PTR [rsp+40], ax
  00813	0f b7 44 24 68	 movzx	 eax, WORD PTR hwLenBaf1$[rsp]
  00818	66 89 44 24 20	 mov	 WORD PTR [rsp+32], ax
  0081d	4c 8b 8c 24 a8
	00 00 00	 mov	 r9, QWORD PTR pLCSBAF2$[rsp]
  00825	4c 8b 84 24 98
	00 00 00	 mov	 r8, QWORD PTR pLCSBAF1$[rsp]
  0082d	48 8b 54 24 78	 mov	 rdx, QWORD PTR pLCSHDR$[rsp]
  00832	48 8b 4c 24 60	 mov	 rcx, QWORD PTR pLCSDEV$[rsp]
  00837	e8 00 00 00 00	 call	 Process_8C0B

; 4389 :                         break;

  0083c	e9 48 03 00 00	 jmp	 $LN24@LCS_Write_
$LN125@LCS_Write_:

; 4390 : 
; 4391 :                     // 0C0A, 0C25, 0C22 and 8D00 are used when a connection is activated.
; 4392 : 
; 4393 :                     case 0x0C0A:
; 4394 :                         Process_0C0A( pLCSDEV, pLCSHDR, pLCSBAF1, pLCSBAF2, hwLenBaf1, hwLenBaf2 );

  00841	0f b7 44 24 6c	 movzx	 eax, WORD PTR hwLenBaf2$[rsp]
  00846	66 89 44 24 28	 mov	 WORD PTR [rsp+40], ax
  0084b	0f b7 44 24 68	 movzx	 eax, WORD PTR hwLenBaf1$[rsp]
  00850	66 89 44 24 20	 mov	 WORD PTR [rsp+32], ax
  00855	4c 8b 8c 24 a8
	00 00 00	 mov	 r9, QWORD PTR pLCSBAF2$[rsp]
  0085d	4c 8b 84 24 98
	00 00 00	 mov	 r8, QWORD PTR pLCSBAF1$[rsp]
  00865	48 8b 54 24 78	 mov	 rdx, QWORD PTR pLCSHDR$[rsp]
  0086a	48 8b 4c 24 60	 mov	 rcx, QWORD PTR pLCSDEV$[rsp]
  0086f	e8 00 00 00 00	 call	 Process_0C0A

; 4395 :                         pLCSDEV->fAttnRequired = TRUE;

  00874	48 8b 44 24 60	 mov	 rax, QWORD PTR pLCSDEV$[rsp]
  00879	8b 40 5d	 mov	 eax, DWORD PTR [rax+93]
  0087c	83 c8 02	 or	 eax, 2
  0087f	48 8b 4c 24 60	 mov	 rcx, QWORD PTR pLCSDEV$[rsp]
  00884	89 41 5d	 mov	 DWORD PTR [rcx+93], eax

; 4396 :                         break;

  00887	e9 fd 02 00 00	 jmp	 $LN24@LCS_Write_
$LN126@LCS_Write_:

; 4397 : 
; 4398 :                     case 0x0C25:
; 4399 :                         Process_0C25( pLCSDEV, pLCSHDR, pLCSBAF1, pLCSBAF2, hwLenBaf1, hwLenBaf2 );

  0088c	0f b7 44 24 6c	 movzx	 eax, WORD PTR hwLenBaf2$[rsp]
  00891	66 89 44 24 28	 mov	 WORD PTR [rsp+40], ax
  00896	0f b7 44 24 68	 movzx	 eax, WORD PTR hwLenBaf1$[rsp]
  0089b	66 89 44 24 20	 mov	 WORD PTR [rsp+32], ax
  008a0	4c 8b 8c 24 a8
	00 00 00	 mov	 r9, QWORD PTR pLCSBAF2$[rsp]
  008a8	4c 8b 84 24 98
	00 00 00	 mov	 r8, QWORD PTR pLCSBAF1$[rsp]
  008b0	48 8b 54 24 78	 mov	 rdx, QWORD PTR pLCSHDR$[rsp]
  008b5	48 8b 4c 24 60	 mov	 rcx, QWORD PTR pLCSDEV$[rsp]
  008ba	e8 00 00 00 00	 call	 Process_0C25

; 4400 :                         break;

  008bf	e9 c5 02 00 00	 jmp	 $LN24@LCS_Write_
$LN127@LCS_Write_:

; 4401 : 
; 4402 :                     case 0x0C22:
; 4403 :                         Process_0C22( pLCSDEV, pLCSHDR, pLCSBAF1, pLCSBAF2, hwLenBaf1, hwLenBaf2 );

  008c4	0f b7 44 24 6c	 movzx	 eax, WORD PTR hwLenBaf2$[rsp]
  008c9	66 89 44 24 28	 mov	 WORD PTR [rsp+40], ax
  008ce	0f b7 44 24 68	 movzx	 eax, WORD PTR hwLenBaf1$[rsp]
  008d3	66 89 44 24 20	 mov	 WORD PTR [rsp+32], ax
  008d8	4c 8b 8c 24 a8
	00 00 00	 mov	 r9, QWORD PTR pLCSBAF2$[rsp]
  008e0	4c 8b 84 24 98
	00 00 00	 mov	 r8, QWORD PTR pLCSBAF1$[rsp]
  008e8	48 8b 54 24 78	 mov	 rdx, QWORD PTR pLCSHDR$[rsp]
  008ed	48 8b 4c 24 60	 mov	 rcx, QWORD PTR pLCSDEV$[rsp]
  008f2	e8 00 00 00 00	 call	 Process_0C22

; 4404 :                         break;

  008f7	e9 8d 02 00 00	 jmp	 $LN24@LCS_Write_
$LN128@LCS_Write_:

; 4405 : 
; 4406 :                     case 0x8D00:
; 4407 :                         Process_8D00( pLCSDEV, pLCSHDR, pLCSBAF1, pLCSBAF2, hwLenBaf1, hwLenBaf2 );

  008fc	0f b7 44 24 6c	 movzx	 eax, WORD PTR hwLenBaf2$[rsp]
  00901	66 89 44 24 28	 mov	 WORD PTR [rsp+40], ax
  00906	0f b7 44 24 68	 movzx	 eax, WORD PTR hwLenBaf1$[rsp]
  0090b	66 89 44 24 20	 mov	 WORD PTR [rsp+32], ax
  00910	4c 8b 8c 24 a8
	00 00 00	 mov	 r9, QWORD PTR pLCSBAF2$[rsp]
  00918	4c 8b 84 24 98
	00 00 00	 mov	 r8, QWORD PTR pLCSBAF1$[rsp]
  00920	48 8b 54 24 78	 mov	 rdx, QWORD PTR pLCSHDR$[rsp]
  00925	48 8b 4c 24 60	 mov	 rcx, QWORD PTR pLCSDEV$[rsp]
  0092a	e8 00 00 00 00	 call	 Process_8D00

; 4408 :                         break;

  0092f	e9 55 02 00 00	 jmp	 $LN24@LCS_Write_
$LN129@LCS_Write_:

; 4409 : 
; 4410 :                     // 0C0B is used when a connection is inactivated.
; 4411 : 
; 4412 :                     case 0x0C0B:
; 4413 :                         Process_0C0B( pLCSDEV, pLCSHDR, pLCSBAF1, pLCSBAF2, hwLenBaf1, hwLenBaf2 );

  00934	0f b7 44 24 6c	 movzx	 eax, WORD PTR hwLenBaf2$[rsp]
  00939	66 89 44 24 28	 mov	 WORD PTR [rsp+40], ax
  0093e	0f b7 44 24 68	 movzx	 eax, WORD PTR hwLenBaf1$[rsp]
  00943	66 89 44 24 20	 mov	 WORD PTR [rsp+32], ax
  00948	4c 8b 8c 24 a8
	00 00 00	 mov	 r9, QWORD PTR pLCSBAF2$[rsp]
  00950	4c 8b 84 24 98
	00 00 00	 mov	 r8, QWORD PTR pLCSBAF1$[rsp]
  00958	48 8b 54 24 78	 mov	 rdx, QWORD PTR pLCSHDR$[rsp]
  0095d	48 8b 4c 24 60	 mov	 rcx, QWORD PTR pLCSDEV$[rsp]
  00962	e8 00 00 00 00	 call	 Process_0C0B

; 4414 :                         pLCSDEV->fAttnRequired = TRUE;

  00967	48 8b 44 24 60	 mov	 rax, QWORD PTR pLCSDEV$[rsp]
  0096c	8b 40 5d	 mov	 eax, DWORD PTR [rax+93]
  0096f	83 c8 02	 or	 eax, 2
  00972	48 8b 4c 24 60	 mov	 rcx, QWORD PTR pLCSDEV$[rsp]
  00977	89 41 5d	 mov	 DWORD PTR [rcx+93], eax

; 4415 :                         break;

  0097a	e9 0a 02 00 00	 jmp	 $LN24@LCS_Write_
$LN130@LCS_Write_:

; 4416 : 
; 4417 :                     // 0C99 and 0C0D ure used when the XCA is activated.
; 4418 : 
; 4419 :                     case 0x0C99:
; 4420 :                         Process_0C99( pLCSDEV, pLCSHDR, pLCSBAF1, pLCSBAF2, hwLenBaf1, hwLenBaf2 );

  0097f	0f b7 44 24 6c	 movzx	 eax, WORD PTR hwLenBaf2$[rsp]
  00984	66 89 44 24 28	 mov	 WORD PTR [rsp+40], ax
  00989	0f b7 44 24 68	 movzx	 eax, WORD PTR hwLenBaf1$[rsp]
  0098e	66 89 44 24 20	 mov	 WORD PTR [rsp+32], ax
  00993	4c 8b 8c 24 a8
	00 00 00	 mov	 r9, QWORD PTR pLCSBAF2$[rsp]
  0099b	4c 8b 84 24 98
	00 00 00	 mov	 r8, QWORD PTR pLCSBAF1$[rsp]
  009a3	48 8b 54 24 78	 mov	 rdx, QWORD PTR pLCSHDR$[rsp]
  009a8	48 8b 4c 24 60	 mov	 rcx, QWORD PTR pLCSDEV$[rsp]
  009ad	e8 00 00 00 00	 call	 Process_0C99

; 4421 :                         pLCSDEV->fAttnRequired = TRUE;

  009b2	48 8b 44 24 60	 mov	 rax, QWORD PTR pLCSDEV$[rsp]
  009b7	8b 40 5d	 mov	 eax, DWORD PTR [rax+93]
  009ba	83 c8 02	 or	 eax, 2
  009bd	48 8b 4c 24 60	 mov	 rcx, QWORD PTR pLCSDEV$[rsp]
  009c2	89 41 5d	 mov	 DWORD PTR [rcx+93], eax

; 4422 :                         break;

  009c5	e9 bf 01 00 00	 jmp	 $LN24@LCS_Write_
$LN131@LCS_Write_:

; 4423 : 
; 4424 :                     case 0x0C0D:
; 4425 :                         Process_0C0D( pLCSDEV, pLCSHDR, pLCSBAF1, pLCSBAF2, hwLenBaf1, hwLenBaf2 );

  009ca	0f b7 44 24 6c	 movzx	 eax, WORD PTR hwLenBaf2$[rsp]
  009cf	66 89 44 24 28	 mov	 WORD PTR [rsp+40], ax
  009d4	0f b7 44 24 68	 movzx	 eax, WORD PTR hwLenBaf1$[rsp]
  009d9	66 89 44 24 20	 mov	 WORD PTR [rsp+32], ax
  009de	4c 8b 8c 24 a8
	00 00 00	 mov	 r9, QWORD PTR pLCSBAF2$[rsp]
  009e6	4c 8b 84 24 98
	00 00 00	 mov	 r8, QWORD PTR pLCSBAF1$[rsp]
  009ee	48 8b 54 24 78	 mov	 rdx, QWORD PTR pLCSHDR$[rsp]
  009f3	48 8b 4c 24 60	 mov	 rcx, QWORD PTR pLCSDEV$[rsp]
  009f8	e8 00 00 00 00	 call	 Process_0C0D

; 4426 :                         pLCSDEV->fAttnRequired = TRUE;

  009fd	48 8b 44 24 60	 mov	 rax, QWORD PTR pLCSDEV$[rsp]
  00a02	8b 40 5d	 mov	 eax, DWORD PTR [rax+93]
  00a05	83 c8 02	 or	 eax, 2
  00a08	48 8b 4c 24 60	 mov	 rcx, QWORD PTR pLCSDEV$[rsp]
  00a0d	89 41 5d	 mov	 DWORD PTR [rcx+93], eax

; 4427 :                         break;

  00a10	e9 74 01 00 00	 jmp	 $LN24@LCS_Write_
$LN132@LCS_Write_:

; 4428 : 
; 4429 :                     // 0C0E and 0C98 ure used when the XCA is inactivated.
; 4430 : 
; 4431 :                     case 0x0C0E:
; 4432 :                         Process_0C0E( pLCSDEV, pLCSHDR, pLCSBAF1, pLCSBAF2, hwLenBaf1, hwLenBaf2 );

  00a15	0f b7 44 24 6c	 movzx	 eax, WORD PTR hwLenBaf2$[rsp]
  00a1a	66 89 44 24 28	 mov	 WORD PTR [rsp+40], ax
  00a1f	0f b7 44 24 68	 movzx	 eax, WORD PTR hwLenBaf1$[rsp]
  00a24	66 89 44 24 20	 mov	 WORD PTR [rsp+32], ax
  00a29	4c 8b 8c 24 a8
	00 00 00	 mov	 r9, QWORD PTR pLCSBAF2$[rsp]
  00a31	4c 8b 84 24 98
	00 00 00	 mov	 r8, QWORD PTR pLCSBAF1$[rsp]
  00a39	48 8b 54 24 78	 mov	 rdx, QWORD PTR pLCSHDR$[rsp]
  00a3e	48 8b 4c 24 60	 mov	 rcx, QWORD PTR pLCSDEV$[rsp]
  00a43	e8 00 00 00 00	 call	 Process_0C0E

; 4433 :                         pLCSDEV->fAttnRequired = TRUE;

  00a48	48 8b 44 24 60	 mov	 rax, QWORD PTR pLCSDEV$[rsp]
  00a4d	8b 40 5d	 mov	 eax, DWORD PTR [rax+93]
  00a50	83 c8 02	 or	 eax, 2
  00a53	48 8b 4c 24 60	 mov	 rcx, QWORD PTR pLCSDEV$[rsp]
  00a58	89 41 5d	 mov	 DWORD PTR [rcx+93], eax

; 4434 :                         break;

  00a5b	e9 29 01 00 00	 jmp	 $LN24@LCS_Write_
$LN133@LCS_Write_:

; 4435 : 
; 4436 :                     case 0x0C98:
; 4437 :                         Process_0C98( pLCSDEV, pLCSHDR, pLCSBAF1, pLCSBAF2, hwLenBaf1, hwLenBaf2 );

  00a60	0f b7 44 24 6c	 movzx	 eax, WORD PTR hwLenBaf2$[rsp]
  00a65	66 89 44 24 28	 mov	 WORD PTR [rsp+40], ax
  00a6a	0f b7 44 24 68	 movzx	 eax, WORD PTR hwLenBaf1$[rsp]
  00a6f	66 89 44 24 20	 mov	 WORD PTR [rsp+32], ax
  00a74	4c 8b 8c 24 a8
	00 00 00	 mov	 r9, QWORD PTR pLCSBAF2$[rsp]
  00a7c	4c 8b 84 24 98
	00 00 00	 mov	 r8, QWORD PTR pLCSBAF1$[rsp]
  00a84	48 8b 54 24 78	 mov	 rdx, QWORD PTR pLCSHDR$[rsp]
  00a89	48 8b 4c 24 60	 mov	 rcx, QWORD PTR pLCSDEV$[rsp]
  00a8e	e8 00 00 00 00	 call	 Process_0C98

; 4438 :                         pLCSDEV->fAttnRequired = TRUE;

  00a93	48 8b 44 24 60	 mov	 rax, QWORD PTR pLCSDEV$[rsp]
  00a98	8b 40 5d	 mov	 eax, DWORD PTR [rax+93]
  00a9b	83 c8 02	 or	 eax, 2
  00a9e	48 8b 4c 24 60	 mov	 rcx, QWORD PTR pLCSDEV$[rsp]
  00aa3	89 41 5d	 mov	 DWORD PTR [rcx+93], eax

; 4439 :                         break;

  00aa6	e9 de 00 00 00	 jmp	 $LN24@LCS_Write_
$LN134@LCS_Write_:
$LN28@LCS_Write_:

; 4440 : 
; 4441 :                     default:
; 4442 :                         PTT_DEBUG( "*BAF=Unsupported! ", hwTypeBaf, pDEVBLK->devnum, -1 );

  00aab	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_pttclass
  00ab2	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00ab5	48 25 00 00 02
	00		 and	 rax, 131072		; 00020000H
  00abb	48 85 c0	 test	 rax, rax
  00abe	74 4a		 je	 SHORT $LN135@LCS_Write_
  00ac0	48 8b 84 24 90
	02 00 00	 mov	 rax, QWORD PTR pDEVBLK$[rsp]
  00ac8	0f b7 40 48	 movzx	 eax, WORD PTR [rax+72]
  00acc	0f b7 8c 24 a0
	00 00 00	 movzx	 ecx, WORD PTR hwTypeBaf$[rsp]
  00ad4	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR [rsp+48], 0
  00add	48 c7 44 24 28
	ff ff ff ff	 mov	 QWORD PTR [rsp+40], -1
  00ae6	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG173695
  00aed	48 89 54 24 20	 mov	 QWORD PTR [rsp+32], rdx
  00af2	44 8b c8	 mov	 r9d, eax
  00af5	44 8b c1	 mov	 r8d, ecx
  00af8	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG173696
  00aff	b9 00 00 02 00	 mov	 ecx, 131072		; 00020000H
  00b04	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ptt_pthread_trace
$LN135@LCS_Write_:
  00b0a	33 c0		 xor	 eax, eax
  00b0c	85 c0		 test	 eax, eax
  00b0e	75 9b		 jne	 SHORT $LN28@LCS_Write_

; 4443 :                         snprintf( unsupmsg, sizeof(unsupmsg), "LCS: lcs write: unsupported baffle type 0x%4.4X", hwTypeBaf );

  00b10	0f b7 84 24 a0
	00 00 00	 movzx	 eax, WORD PTR hwTypeBaf$[rsp]
  00b18	44 8b c8	 mov	 r9d, eax
  00b1b	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG173697
  00b22	ba 00 01 00 00	 mov	 edx, 256		; 00000100H
  00b27	48 8d 8c 24 70
	01 00 00	 lea	 rcx, QWORD PTR unsupmsg$[rsp]
  00b2f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_snprintf

; 4444 :                         WRMSG(HHC03984, "W", unsupmsg );  /* FixMe! Proper message number! */

  00b35	b9 01 00 00 00	 mov	 ecx, 1
  00b3a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  00b40	48 8d 8c 24 70
	01 00 00	 lea	 rcx, QWORD PTR unsupmsg$[rsp]
  00b48	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  00b4d	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG173698
  00b54	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  00b59	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG173699
  00b60	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00b65	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00b6a	41 b9 03 00 00
	00		 mov	 r9d, 3
  00b70	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG173700
  00b77	ba 5c 11 00 00	 mov	 edx, 4444		; 0000115cH
  00b7c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG173701
  00b83	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg
$LN24@LCS_Write_:

; 4445 :                         break;
; 4446 : 
; 4447 :                     } // End of  switch (hwTypeBaf)
; 4448 : 
; 4449 :                     break;

  00b89	e9 07 06 00 00	 jmp	 $LN19@LCS_Write_
$LN136@LCS_Write_:

; 4450 : 
; 4451 :                 case LCS_FRMTYP_CMD:    // 0x00: LCS Command Frame
; 4452 : 
; 4453 :                     pCmdFrame = (PLCSCMDHDR)pLCSHDR;

  00b8e	48 8b 44 24 78	 mov	 rax, QWORD PTR pLCSHDR$[rsp]
  00b93	48 89 84 24 88
	00 00 00	 mov	 QWORD PTR pCmdFrame$[rsp], rax
$LN31@LCS_Write_:

; 4454 : 
; 4455 :                     PTT_DEBUG( "WSNA: Cmd frame O ", pCmdFrame->bCmdCode, pDEVBLK->devnum, -1 );

  00b9b	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_pttclass
  00ba2	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00ba5	48 25 00 00 02
	00		 and	 rax, 131072		; 00020000H
  00bab	48 85 c0	 test	 rax, rax
  00bae	74 4e		 je	 SHORT $LN137@LCS_Write_
  00bb0	48 8b 84 24 90
	02 00 00	 mov	 rax, QWORD PTR pDEVBLK$[rsp]
  00bb8	0f b7 40 48	 movzx	 eax, WORD PTR [rax+72]
  00bbc	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR pCmdFrame$[rsp]
  00bc4	0f b6 49 04	 movzx	 ecx, BYTE PTR [rcx+4]
  00bc8	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR [rsp+48], 0
  00bd1	48 c7 44 24 28
	ff ff ff ff	 mov	 QWORD PTR [rsp+40], -1
  00bda	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG173704
  00be1	48 89 54 24 20	 mov	 QWORD PTR [rsp+32], rdx
  00be6	44 8b c8	 mov	 r9d, eax
  00be9	44 8b c1	 mov	 r8d, ecx
  00bec	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG173705
  00bf3	b9 00 00 02 00	 mov	 ecx, 131072		; 00020000H
  00bf8	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ptt_pthread_trace
$LN137@LCS_Write_:
  00bfe	33 c0		 xor	 eax, eax
  00c00	85 c0		 test	 eax, eax
  00c02	75 97		 jne	 SHORT $LN31@LCS_Write_

; 4456 : 
; 4457 :                     switch (pCmdFrame->bCmdCode)

  00c04	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR pCmdFrame$[rsp]
  00c0c	0f b6 40 04	 movzx	 eax, BYTE PTR [rax+4]
  00c10	88 84 24 ec 00
	00 00		 mov	 BYTE PTR tv431[rsp], al
  00c17	80 bc 24 ec 00
	00 00 42	 cmp	 BYTE PTR tv431[rsp], 66	; 00000042H
  00c1f	74 05		 je	 SHORT $LN138@LCS_Write_
  00c21	e9 42 01 00 00	 jmp	 $LN141@LCS_Write_
$LN138@LCS_Write_:
$LN36@LCS_Write_:

; 4458 :                     {
; 4459 : 
; 4460 :                     case LCS_CMD_STOPLAN_SNA:   // Stop LAN SNA
; 4461 :                         PTT_DEBUG( "CMD=Stop LAN SNA  ", pCmdFrame->bCmdCode, pDEVBLK->devnum, -1 );

  00c26	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_pttclass
  00c2d	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00c30	48 25 00 00 02
	00		 and	 rax, 131072		; 00020000H
  00c36	48 85 c0	 test	 rax, rax
  00c39	74 4e		 je	 SHORT $LN139@LCS_Write_
  00c3b	48 8b 84 24 90
	02 00 00	 mov	 rax, QWORD PTR pDEVBLK$[rsp]
  00c43	0f b7 40 48	 movzx	 eax, WORD PTR [rax+72]
  00c47	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR pCmdFrame$[rsp]
  00c4f	0f b6 49 04	 movzx	 ecx, BYTE PTR [rcx+4]
  00c53	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR [rsp+48], 0
  00c5c	48 c7 44 24 28
	ff ff ff ff	 mov	 QWORD PTR [rsp+40], -1
  00c65	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG173708
  00c6c	48 89 54 24 20	 mov	 QWORD PTR [rsp+32], rdx
  00c71	44 8b c8	 mov	 r9d, eax
  00c74	44 8b c1	 mov	 r8d, ecx
  00c77	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG173709
  00c7e	b9 00 00 02 00	 mov	 ecx, 131072		; 00020000H
  00c83	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ptt_pthread_trace
$LN139@LCS_Write_:
  00c89	33 c0		 xor	 eax, eax
  00c8b	85 c0		 test	 eax, eax
  00c8d	75 97		 jne	 SHORT $LN36@LCS_Write_

; 4462 :                         if (pLCSBLK->fDebug)

  00c8f	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR pLCSBLK$[rsp]
  00c97	8b 40 18	 mov	 eax, DWORD PTR [rax+24]
  00c9a	83 e0 01	 and	 eax, 1
  00c9d	85 c0		 test	 eax, eax
  00c9f	0f 84 91 00 00
	00		 je	 $LN140@LCS_Write_

; 4463 :                         {
; 4464 :                             // "%1d:%04X CTC: executing command %s"
; 4465 :                             WRMSG( HHC00933, "D", SSID_TO_LCSS(pDEVBLK->ssid), pDEVBLK->devnum, "stop lan sna" );

  00ca5	48 8b 84 24 90
	02 00 00	 mov	 rax, QWORD PTR pDEVBLK$[rsp]
  00cad	0f b7 40 48	 movzx	 eax, WORD PTR [rax+72]
  00cb1	89 84 24 f0 00
	00 00		 mov	 DWORD PTR tv483[rsp], eax
  00cb8	48 8b 8c 24 90
	02 00 00	 mov	 rcx, QWORD PTR pDEVBLK$[rsp]
  00cc0	0f b7 49 44	 movzx	 ecx, WORD PTR [rcx+68]
  00cc4	d1 f9		 sar	 ecx, 1
  00cc6	89 8c 24 2c 01
	00 00		 mov	 DWORD PTR tv487[rsp], ecx
  00ccd	b9 01 00 00 00	 mov	 ecx, 1
  00cd2	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  00cd8	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG173711
  00cdf	48 89 4c 24 48	 mov	 QWORD PTR [rsp+72], rcx
  00ce4	8b 8c 24 f0 00
	00 00		 mov	 ecx, DWORD PTR tv483[rsp]
  00ceb	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  00cef	8b 8c 24 2c 01
	00 00		 mov	 ecx, DWORD PTR tv487[rsp]
  00cf6	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  00cfa	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG173712
  00d01	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  00d06	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG173713
  00d0d	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00d12	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00d17	41 b9 03 00 00
	00		 mov	 r9d, 3
  00d1d	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG173714
  00d24	ba 71 11 00 00	 mov	 edx, 4465		; 00001171H
  00d29	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG173715
  00d30	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg
$LN140@LCS_Write_:

; 4466 :                         }
; 4467 :                         LCS_StopLan_SNA( pLCSDEV, pCmdFrame, (int)hwLength );

  00d36	0f b7 44 24 74	 movzx	 eax, WORD PTR hwLength$[rsp]
  00d3b	44 8b c0	 mov	 r8d, eax
  00d3e	48 8b 94 24 88
	00 00 00	 mov	 rdx, QWORD PTR pCmdFrame$[rsp]
  00d46	48 8b 4c 24 60	 mov	 rcx, QWORD PTR pLCSDEV$[rsp]
  00d4b	e8 00 00 00 00	 call	 LCS_StopLan_SNA

; 4468 :                         pLCSDEV->fAttnRequired = TRUE;

  00d50	48 8b 44 24 60	 mov	 rax, QWORD PTR pLCSDEV$[rsp]
  00d55	8b 40 5d	 mov	 eax, DWORD PTR [rax+93]
  00d58	83 c8 02	 or	 eax, 2
  00d5b	48 8b 4c 24 60	 mov	 rcx, QWORD PTR pLCSDEV$[rsp]
  00d60	89 41 5d	 mov	 DWORD PTR [rcx+93], eax

; 4469 :                         break;

  00d63	e9 67 01 00 00	 jmp	 $LN32@LCS_Write_
$LN141@LCS_Write_:
$LN39@LCS_Write_:

; 4470 : 
; 4471 :                     default:
; 4472 :                         PTT_DEBUG( "*CMD=Unsupported! ", pCmdFrame->bCmdCode, pDEVBLK->devnum, -1 );

  00d68	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_pttclass
  00d6f	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00d72	48 25 00 00 02
	00		 and	 rax, 131072		; 00020000H
  00d78	48 85 c0	 test	 rax, rax
  00d7b	74 4e		 je	 SHORT $LN142@LCS_Write_
  00d7d	48 8b 84 24 90
	02 00 00	 mov	 rax, QWORD PTR pDEVBLK$[rsp]
  00d85	0f b7 40 48	 movzx	 eax, WORD PTR [rax+72]
  00d89	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR pCmdFrame$[rsp]
  00d91	0f b6 49 04	 movzx	 ecx, BYTE PTR [rcx+4]
  00d95	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR [rsp+48], 0
  00d9e	48 c7 44 24 28
	ff ff ff ff	 mov	 QWORD PTR [rsp+40], -1
  00da7	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG173718
  00dae	48 89 54 24 20	 mov	 QWORD PTR [rsp+32], rdx
  00db3	44 8b c8	 mov	 r9d, eax
  00db6	44 8b c1	 mov	 r8d, ecx
  00db9	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG173719
  00dc0	b9 00 00 02 00	 mov	 ecx, 131072		; 00020000H
  00dc5	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ptt_pthread_trace
$LN142@LCS_Write_:
  00dcb	33 c0		 xor	 eax, eax
  00dcd	85 c0		 test	 eax, eax
  00dcf	75 97		 jne	 SHORT $LN39@LCS_Write_

; 4473 :                         if (pLCSBLK->fDebug)

  00dd1	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR pLCSBLK$[rsp]
  00dd9	8b 40 18	 mov	 eax, DWORD PTR [rax+24]
  00ddc	83 e0 01	 and	 eax, 1
  00ddf	85 c0		 test	 eax, eax
  00de1	0f 84 bb 00 00
	00		 je	 $LN143@LCS_Write_

; 4474 :                         {
; 4475 :                             // "%1d:%04X CTC: executing command %s"
; 4476 :                             MSGBUF( buf, "other (0x%2.2X)", pCmdFrame->bCmdCode );

  00de7	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR pCmdFrame$[rsp]
  00def	0f b6 40 04	 movzx	 eax, BYTE PTR [rax+4]
  00df3	44 8b c8	 mov	 r9d, eax
  00df6	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG173721
  00dfd	ba 20 00 00 00	 mov	 edx, 32			; 00000020H
  00e02	48 8d 8c 24 48
	01 00 00	 lea	 rcx, QWORD PTR buf$[rsp]
  00e0a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_snprintf

; 4477 :                             WRMSG( HHC00933, "D", SSID_TO_LCSS(pDEVBLK->ssid), pDEVBLK->devnum, buf );

  00e10	48 8b 84 24 90
	02 00 00	 mov	 rax, QWORD PTR pDEVBLK$[rsp]
  00e18	0f b7 40 48	 movzx	 eax, WORD PTR [rax+72]
  00e1c	89 84 24 28 01
	00 00		 mov	 DWORD PTR tv530[rsp], eax
  00e23	48 8b 8c 24 90
	02 00 00	 mov	 rcx, QWORD PTR pDEVBLK$[rsp]
  00e2b	0f b7 49 44	 movzx	 ecx, WORD PTR [rcx+68]
  00e2f	d1 f9		 sar	 ecx, 1
  00e31	89 8c 24 24 01
	00 00		 mov	 DWORD PTR tv534[rsp], ecx
  00e38	b9 01 00 00 00	 mov	 ecx, 1
  00e3d	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  00e43	48 8d 8c 24 48
	01 00 00	 lea	 rcx, QWORD PTR buf$[rsp]
  00e4b	48 89 4c 24 48	 mov	 QWORD PTR [rsp+72], rcx
  00e50	8b 8c 24 28 01
	00 00		 mov	 ecx, DWORD PTR tv530[rsp]
  00e57	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  00e5b	8b 8c 24 24 01
	00 00		 mov	 ecx, DWORD PTR tv534[rsp]
  00e62	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  00e66	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG173722
  00e6d	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  00e72	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG173723
  00e79	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00e7e	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00e83	41 b9 03 00 00
	00		 mov	 r9d, 3
  00e89	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG173724
  00e90	ba 7d 11 00 00	 mov	 edx, 4477		; 0000117dH
  00e95	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG173725
  00e9c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg
$LN143@LCS_Write_:

; 4478 :                         }
; 4479 :                         LCS_UnsuppCmd_SNA( pLCSDEV, pCmdFrame, (int)hwLength );

  00ea2	0f b7 44 24 74	 movzx	 eax, WORD PTR hwLength$[rsp]
  00ea7	44 8b c0	 mov	 r8d, eax
  00eaa	48 8b 94 24 88
	00 00 00	 mov	 rdx, QWORD PTR pCmdFrame$[rsp]
  00eb2	48 8b 4c 24 60	 mov	 rcx, QWORD PTR pLCSDEV$[rsp]
  00eb7	e8 00 00 00 00	 call	 LCS_UnsuppCmd_SNA

; 4480 :                         pLCSDEV->fAttnRequired = TRUE;

  00ebc	48 8b 44 24 60	 mov	 rax, QWORD PTR pLCSDEV$[rsp]
  00ec1	8b 40 5d	 mov	 eax, DWORD PTR [rax+93]
  00ec4	83 c8 02	 or	 eax, 2
  00ec7	48 8b 4c 24 60	 mov	 rcx, QWORD PTR pLCSDEV$[rsp]
  00ecc	89 41 5d	 mov	 DWORD PTR [rcx+93], eax
$LN32@LCS_Write_:

; 4481 :                         break;
; 4482 : 
; 4483 :                     } // end switch (LCS Command Frame cmd code)
; 4484 : 
; 4485 :                     break; // end case LCS_FRMTYP_CMD

  00ecf	e9 c1 02 00 00	 jmp	 $LN19@LCS_Write_
$LN144@LCS_Write_:
$LN42@LCS_Write_:

; 4486 : 
; 4487 :                 default:
; 4488 :                     PTT_DEBUG( "*WRIT Unsupp frame", pCmdFrame->bCmdCode, pDEVBLK->devnum, -1 );

  00ed4	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_pttclass
  00edb	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00ede	48 25 00 00 02
	00		 and	 rax, 131072		; 00020000H
  00ee4	48 85 c0	 test	 rax, rax
  00ee7	74 4e		 je	 SHORT $LN145@LCS_Write_
  00ee9	48 8b 84 24 90
	02 00 00	 mov	 rax, QWORD PTR pDEVBLK$[rsp]
  00ef1	0f b7 40 48	 movzx	 eax, WORD PTR [rax+72]
  00ef5	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR pCmdFrame$[rsp]
  00efd	0f b6 49 04	 movzx	 ecx, BYTE PTR [rcx+4]
  00f01	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR [rsp+48], 0
  00f0a	48 c7 44 24 28
	ff ff ff ff	 mov	 QWORD PTR [rsp+40], -1
  00f13	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG173728
  00f1a	48 89 54 24 20	 mov	 QWORD PTR [rsp+32], rdx
  00f1f	44 8b c8	 mov	 r9d, eax
  00f22	44 8b c1	 mov	 r8d, ecx
  00f25	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG173729
  00f2c	b9 00 00 02 00	 mov	 ecx, 131072		; 00020000H
  00f31	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ptt_pthread_trace
$LN145@LCS_Write_:
  00f37	33 c0		 xor	 eax, eax
  00f39	85 c0		 test	 eax, eax
  00f3b	75 97		 jne	 SHORT $LN42@LCS_Write_

; 4489 :                     // "%1d:%04X CTC: lcs write: unsupported frame type 0x%2.2X"
; 4490 :                     WRMSG( HHC00937, "E", SSID_TO_LCSS(pDEVBLK->ssid), pDEVBLK->devnum, pLCSHDR->bType );

  00f3d	48 8b 44 24 78	 mov	 rax, QWORD PTR pLCSHDR$[rsp]
  00f42	0f b6 40 02	 movzx	 eax, BYTE PTR [rax+2]
  00f46	89 84 24 20 01
	00 00		 mov	 DWORD PTR tv570[rsp], eax
  00f4d	48 8b 8c 24 90
	02 00 00	 mov	 rcx, QWORD PTR pDEVBLK$[rsp]
  00f55	0f b7 49 48	 movzx	 ecx, WORD PTR [rcx+72]
  00f59	89 8c 24 1c 01
	00 00		 mov	 DWORD PTR tv573[rsp], ecx
  00f60	48 8b 94 24 90
	02 00 00	 mov	 rdx, QWORD PTR pDEVBLK$[rsp]
  00f68	0f b7 52 44	 movzx	 edx, WORD PTR [rdx+68]
  00f6c	d1 fa		 sar	 edx, 1
  00f6e	89 94 24 18 01
	00 00		 mov	 DWORD PTR tv577[rsp], edx
  00f75	b9 01 00 00 00	 mov	 ecx, 1
  00f7a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  00f80	8b 8c 24 20 01
	00 00		 mov	 ecx, DWORD PTR tv570[rsp]
  00f87	89 4c 24 48	 mov	 DWORD PTR [rsp+72], ecx
  00f8b	8b 8c 24 1c 01
	00 00		 mov	 ecx, DWORD PTR tv573[rsp]
  00f92	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  00f96	8b 8c 24 18 01
	00 00		 mov	 ecx, DWORD PTR tv577[rsp]
  00f9d	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  00fa1	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG173730
  00fa8	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  00fad	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG173731
  00fb4	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00fb9	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00fbe	41 b9 03 00 00
	00		 mov	 r9d, 3
  00fc4	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG173732
  00fcb	ba 8a 11 00 00	 mov	 edx, 4490		; 0000118aH
  00fd0	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG173733
  00fd7	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg
$LN45@LCS_Write_:

; 4491 :                     PTT_DEBUG(        "REL  InOutLock    ", 000, pDEVBLK->devnum, -1 );

  00fdd	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_pttclass
  00fe4	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00fe7	48 25 00 00 02
	00		 and	 rax, 131072		; 00020000H
  00fed	48 85 c0	 test	 rax, rax
  00ff0	74 42		 je	 SHORT $LN146@LCS_Write_
  00ff2	48 8b 84 24 90
	02 00 00	 mov	 rax, QWORD PTR pDEVBLK$[rsp]
  00ffa	0f b7 40 48	 movzx	 eax, WORD PTR [rax+72]
  00ffe	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR [rsp+48], 0
  01007	48 c7 44 24 28
	ff ff ff ff	 mov	 QWORD PTR [rsp+40], -1
  01010	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG173735
  01017	48 89 4c 24 20	 mov	 QWORD PTR [rsp+32], rcx
  0101c	44 8b c8	 mov	 r9d, eax
  0101f	45 33 c0	 xor	 r8d, r8d
  01022	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG173736
  01029	b9 00 00 02 00	 mov	 ecx, 131072		; 00020000H
  0102e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ptt_pthread_trace
$LN146@LCS_Write_:
  01034	33 c0		 xor	 eax, eax
  01036	85 c0		 test	 eax, eax
  01038	75 a3		 jne	 SHORT $LN45@LCS_Write_

; 4492 :                     release_lock( &pLCSDEV->InOutLock   );

  0103a	48 8b 44 24 60	 mov	 rax, QWORD PTR pLCSDEV$[rsp]
  0103f	48 05 92 00 00
	00		 add	 rax, 146		; 00000092H
  01045	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG173737
  0104c	48 8b c8	 mov	 rcx, rax
  0104f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_release_lock
$LN48@LCS_Write_:

; 4493 :                     ASSERT( FALSE );

  01055	33 c0		 xor	 eax, eax
  01057	83 f8 01	 cmp	 eax, 1
  0105a	74 5c		 je	 SHORT $LN147@LCS_Write_
$LN51@LCS_Write_:
  0105c	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG173739
  01063	41 b8 8d 11 00
	00		 mov	 r8d, 4493		; 0000118dH
  01069	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG173740
  01070	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG173741
  01077	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_logmsg
  0107d	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_IsDebuggerPresent
  01083	85 c0		 test	 eax, eax
  01085	74 20		 je	 SHORT $LN148@LCS_Write_
  01087	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG173743
  0108e	41 b8 8d 11 00
	00		 mov	 r8d, 4493		; 0000118dH
  01094	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG173744
  0109b	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG173745
  010a2	e8 00 00 00 00	 call	 DebuggerTrace
$LN148@LCS_Write_:
  010a7	33 c0		 xor	 eax, eax
  010a9	85 c0		 test	 eax, eax
  010ab	75 af		 jne	 SHORT $LN51@LCS_Write_
  010ad	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_IsDebuggerPresent
  010b3	85 c0		 test	 eax, eax
  010b5	74 01		 je	 SHORT $LN149@LCS_Write_
  010b7	cc		 int	 3
$LN149@LCS_Write_:
$LN147@LCS_Write_:
  010b8	33 c0		 xor	 eax, eax
  010ba	85 c0		 test	 eax, eax
  010bc	75 97		 jne	 SHORT $LN48@LCS_Write_

; 4494 :                     pDEVBLK->sense[0] = SENSE_EC;

  010be	b8 01 00 00 00	 mov	 eax, 1
  010c3	48 6b c0 00	 imul	 rax, rax, 0
  010c7	48 8b 8c 24 90
	02 00 00	 mov	 rcx, QWORD PTR pDEVBLK$[rsp]
  010cf	c6 84 01 64 03
	00 00 10	 mov	 BYTE PTR [rcx+rax+868], 16

; 4495 :                     *pUnitStat = CSW_CE | CSW_DE | CSW_UC;

  010d7	48 8b 84 24 a8
	02 00 00	 mov	 rax, QWORD PTR pUnitStat$[rsp]
  010df	c6 00 0e	 mov	 BYTE PTR [rax], 14
$LN54@LCS_Write_:

; 4496 : //??                LCS_EndMWrite( pDEVBLK, nEthBytes, nEthFrames );
; 4497 :                     PTT_TIMING( "end write",  0, 0, 0 );

  010e2	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_pttclass
  010e9	48 8b 00	 mov	 rax, QWORD PTR [rax]
  010ec	48 25 00 00 01
	00		 and	 rax, 65536		; 00010000H
  010f2	48 85 c0	 test	 rax, rax
  010f5	74 36		 je	 SHORT $LN150@LCS_Write_
  010f7	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR [rsp+48], 0
  01100	48 c7 44 24 28
	00 00 00 00	 mov	 QWORD PTR [rsp+40], 0
  01109	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG173748
  01110	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  01115	45 33 c9	 xor	 r9d, r9d
  01118	45 33 c0	 xor	 r8d, r8d
  0111b	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG173749
  01122	b9 00 00 01 00	 mov	 ecx, 65536		; 00010000H
  01127	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ptt_pthread_trace
$LN150@LCS_Write_:
  0112d	33 c0		 xor	 eax, eax
  0112f	85 c0		 test	 eax, eax
  01131	75 af		 jne	 SHORT $LN54@LCS_Write_
$LN57@LCS_Write_:

; 4498 :                     PTT_DEBUG( "WSNA EXIT         ", 000, pDEVBLK->devnum, -1 );

  01133	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_pttclass
  0113a	48 8b 00	 mov	 rax, QWORD PTR [rax]
  0113d	48 25 00 00 02
	00		 and	 rax, 131072		; 00020000H
  01143	48 85 c0	 test	 rax, rax
  01146	74 42		 je	 SHORT $LN151@LCS_Write_
  01148	48 8b 84 24 90
	02 00 00	 mov	 rax, QWORD PTR pDEVBLK$[rsp]
  01150	0f b7 40 48	 movzx	 eax, WORD PTR [rax+72]
  01154	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR [rsp+48], 0
  0115d	48 c7 44 24 28
	ff ff ff ff	 mov	 QWORD PTR [rsp+40], -1
  01166	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG173751
  0116d	48 89 4c 24 20	 mov	 QWORD PTR [rsp+32], rcx
  01172	44 8b c8	 mov	 r9d, eax
  01175	45 33 c0	 xor	 r8d, r8d
  01178	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG173752
  0117f	b9 00 00 02 00	 mov	 ecx, 131072		; 00020000H
  01184	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ptt_pthread_trace
$LN151@LCS_Write_:
  0118a	33 c0		 xor	 eax, eax
  0118c	85 c0		 test	 eax, eax
  0118e	75 a3		 jne	 SHORT $LN57@LCS_Write_

; 4499 :                     return;

  01190	e9 11 0b 00 00	 jmp	 $LN1@LCS_Write_
$LN19@LCS_Write_:

; 4500 : 
; 4501 :                 }   // End of  switch (pLCSHDR->bType)
; 4502 : 
; 4503 :             } // end while (1)

  01195	e9 97 f3 ff ff	 jmp	 $LN17@LCS_Write_
$LN18@LCS_Write_:
$LN60@LCS_Write_:

; 4504 : 
; 4505 :             //
; 4506 :             PTT_DEBUG(        "REL  InOutLock    ", 000, pDEVBLK->devnum, -1 );

  0119a	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_pttclass
  011a1	48 8b 00	 mov	 rax, QWORD PTR [rax]
  011a4	48 25 00 00 02
	00		 and	 rax, 131072		; 00020000H
  011aa	48 85 c0	 test	 rax, rax
  011ad	74 42		 je	 SHORT $LN152@LCS_Write_
  011af	48 8b 84 24 90
	02 00 00	 mov	 rax, QWORD PTR pDEVBLK$[rsp]
  011b7	0f b7 40 48	 movzx	 eax, WORD PTR [rax+72]
  011bb	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR [rsp+48], 0
  011c4	48 c7 44 24 28
	ff ff ff ff	 mov	 QWORD PTR [rsp+40], -1
  011cd	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG173754
  011d4	48 89 4c 24 20	 mov	 QWORD PTR [rsp+32], rcx
  011d9	44 8b c8	 mov	 r9d, eax
  011dc	45 33 c0	 xor	 r8d, r8d
  011df	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG173755
  011e6	b9 00 00 02 00	 mov	 ecx, 131072		; 00020000H
  011eb	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ptt_pthread_trace
$LN152@LCS_Write_:
  011f1	33 c0		 xor	 eax, eax
  011f3	85 c0		 test	 eax, eax
  011f5	75 a3		 jne	 SHORT $LN60@LCS_Write_

; 4507 :             release_lock( &pLCSDEV->InOutLock   );

  011f7	48 8b 44 24 60	 mov	 rax, QWORD PTR pLCSDEV$[rsp]
  011fc	48 05 92 00 00
	00		 add	 rax, 146		; 00000092H
  01202	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG173756
  01209	48 8b c8	 mov	 rcx, rax
  0120c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_release_lock

; 4508 : 
; 4509 :         }

  01212	eb 61		 jmp	 SHORT $LN114@LCS_Write_
$LN113@LCS_Write_:
$LN63@LCS_Write_:

; 4510 :         else
; 4511 :         {
; 4512 : 
; 4513 :             // The output is an OCTL with nothing following
; 4514 : 
; 4515 :             PTT_DEBUG( "WSNA: OCTL only   ", -1, pDEVBLK->devnum, -1 );

  01214	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_pttclass
  0121b	48 8b 00	 mov	 rax, QWORD PTR [rax]
  0121e	48 25 00 00 02
	00		 and	 rax, 131072		; 00020000H
  01224	48 85 c0	 test	 rax, rax
  01227	74 46		 je	 SHORT $LN153@LCS_Write_
  01229	48 8b 84 24 90
	02 00 00	 mov	 rax, QWORD PTR pDEVBLK$[rsp]
  01231	0f b7 40 48	 movzx	 eax, WORD PTR [rax+72]
  01235	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR [rsp+48], 0
  0123e	48 c7 44 24 28
	ff ff ff ff	 mov	 QWORD PTR [rsp+40], -1
  01247	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG173758
  0124e	48 89 4c 24 20	 mov	 QWORD PTR [rsp+32], rcx
  01253	44 8b c8	 mov	 r9d, eax
  01256	49 c7 c0 ff ff
	ff ff		 mov	 r8, -1
  0125d	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG173759
  01264	b9 00 00 02 00	 mov	 ecx, 131072		; 00020000H
  01269	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ptt_pthread_trace
$LN153@LCS_Write_:
  0126f	33 c0		 xor	 eax, eax
  01271	85 c0		 test	 eax, eax
  01273	75 9f		 jne	 SHORT $LN63@LCS_Write_
$LN114@LCS_Write_:

; 4516 : 
; 4517 :         }
; 4518 : 
; 4519 :     }   // End of  if (pLCSDEV->bFlipFlop)

  01275	e9 4d 08 00 00	 jmp	 $LN112@LCS_Write_
$LN111@LCS_Write_:

; 4520 : 
; 4521 :     // The Write CCW is the only CCW in the channel program. This
; 4522 :     // is the normal state while the Start LAN and LAN Stats
; 4523 :     // commands are being processed.
; 4524 :     else
; 4525 :     {
; 4526 : 
; 4527 :         // The output should be an LCS command, either Start LAN
; 4528 :         // or LAN Stats.
; 4529 : 
; 4530 :         // Clear the OCTL
; 4531 :         pLCSDEV->hwOctlSize = 0;

  0127a	33 c0		 xor	 eax, eax
  0127c	48 8b 4c 24 60	 mov	 rcx, QWORD PTR pLCSDEV$[rsp]
  01281	66 89 41 45	 mov	 WORD PTR [rcx+69], ax

; 4532 :         memset(&pLCSDEV->Octl, 0, sizeof(LCSOCTL));

  01285	48 8b 44 24 60	 mov	 rax, QWORD PTR pLCSDEV$[rsp]
  0128a	48 83 c0 47	 add	 rax, 71			; 00000047H
  0128e	48 8b f8	 mov	 rdi, rax
  01291	33 c0		 xor	 eax, eax
  01293	b9 08 00 00 00	 mov	 ecx, 8
  01298	f3 aa		 rep stosb

; 4533 : 
; 4534 :         // Point at whatever has just arrived
; 4535 :         pIOBufStart = pIOBuf;

  0129a	48 8b 84 24 a0
	02 00 00	 mov	 rax, QWORD PTR pIOBuf$[rsp]
  012a2	48 89 84 24 d0
	00 00 00	 mov	 QWORD PTR pIOBufStart$[rsp], rax

; 4536 :         pIOBufEnd = pIOBuf + sCount;

  012aa	8b 84 24 98 02
	00 00		 mov	 eax, DWORD PTR sCount$[rsp]
  012b1	48 8b 8c 24 a0
	02 00 00	 mov	 rcx, QWORD PTR pIOBuf$[rsp]
  012b9	48 03 c8	 add	 rcx, rax
  012bc	48 8b c1	 mov	 rax, rcx
  012bf	48 89 84 24 c8
	00 00 00	 mov	 QWORD PTR pIOBufEnd$[rsp], rax
$LN66@LCS_Write_:

; 4537 : 
; 4538 :         // The output is a command
; 4539 : 
; 4540 :         PTT_DEBUG( "WSNA: command     ", -1, pDEVBLK->devnum, -1 );

  012c7	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_pttclass
  012ce	48 8b 00	 mov	 rax, QWORD PTR [rax]
  012d1	48 25 00 00 02
	00		 and	 rax, 131072		; 00020000H
  012d7	48 85 c0	 test	 rax, rax
  012da	74 46		 je	 SHORT $LN154@LCS_Write_
  012dc	48 8b 84 24 90
	02 00 00	 mov	 rax, QWORD PTR pDEVBLK$[rsp]
  012e4	0f b7 40 48	 movzx	 eax, WORD PTR [rax+72]
  012e8	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR [rsp+48], 0
  012f1	48 c7 44 24 28
	ff ff ff ff	 mov	 QWORD PTR [rsp+40], -1
  012fa	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG173761
  01301	48 89 4c 24 20	 mov	 QWORD PTR [rsp+32], rcx
  01306	44 8b c8	 mov	 r9d, eax
  01309	49 c7 c0 ff ff
	ff ff		 mov	 r8, -1
  01310	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG173762
  01317	b9 00 00 02 00	 mov	 ecx, 131072		; 00020000H
  0131c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ptt_pthread_trace
$LN154@LCS_Write_:
  01322	33 c0		 xor	 eax, eax
  01324	85 c0		 test	 eax, eax
  01326	75 9f		 jne	 SHORT $LN66@LCS_Write_
$LN67@LCS_Write_:

; 4541 : 
; 4542 :         //
; 4543 :         while (1)

  01328	33 c0		 xor	 eax, eax
  0132a	83 f8 01	 cmp	 eax, 1
  0132d	0f 84 94 07 00
	00		 je	 $LN68@LCS_Write_

; 4544 :         {
; 4545 :             // Save current offset so we can tell how big the next frame is.
; 4546 :             hwPrevOffset = hwOffset;

  01333	0f b7 44 24 70	 movzx	 eax, WORD PTR hwOffset$[rsp]
  01338	66 89 84 24 90
	00 00 00	 mov	 WORD PTR hwPrevOffset$[rsp], ax

; 4547 : 
; 4548 :             // Point to where the LCSHDR at the start of the next frame should be.
; 4549 :             pLCSHDR = (PLCSHDR)( pIOBufStart + hwOffset );

  01340	0f b7 44 24 70	 movzx	 eax, WORD PTR hwOffset$[rsp]
  01345	48 8b 8c 24 d0
	00 00 00	 mov	 rcx, QWORD PTR pIOBufStart$[rsp]
  0134d	48 03 c8	 add	 rcx, rax
  01350	48 8b c1	 mov	 rax, rcx
  01353	48 89 44 24 78	 mov	 QWORD PTR pLCSHDR$[rsp], rax

; 4550 : 
; 4551 :             // Check that there is enough of the LCSHDR to contain the next
; 4552 :             // frame offset, exit loop if there isn't.
; 4553 :             if ((int)(pIOBufEnd - (BYTE*)pLCSHDR) < (int)sizeof(pLCSHDR->hwOffset))

  01358	48 8b 44 24 78	 mov	 rax, QWORD PTR pLCSHDR$[rsp]
  0135d	48 8b 8c 24 c8
	00 00 00	 mov	 rcx, QWORD PTR pIOBufEnd$[rsp]
  01365	48 2b c8	 sub	 rcx, rax
  01368	48 8b c1	 mov	 rax, rcx
  0136b	83 f8 02	 cmp	 eax, 2
  0136e	7d 05		 jge	 SHORT $LN155@LCS_Write_

; 4554 :                 break;

  01370	e9 52 07 00 00	 jmp	 $LN68@LCS_Write_
$LN155@LCS_Write_:

; 4555 : 
; 4556 :             // Get the next frame offset, exit loop if zero.
; 4557 :             FETCH_HW( hwOffset, pLCSHDR->hwOffset );

  01375	48 8b 44 24 78	 mov	 rax, QWORD PTR pLCSHDR$[rsp]
  0137a	48 8b c8	 mov	 rcx, rax
  0137d	e8 00 00 00 00	 call	 fetch_hw_noswap
  01382	0f b7 c8	 movzx	 ecx, ax
  01385	e8 00 00 00 00	 call	 _byteswap_ushort
  0138a	66 89 44 24 70	 mov	 WORD PTR hwOffset$[rsp], ax

; 4558 :             if (hwOffset == 0)   // ("EOF")

  0138f	0f b7 44 24 70	 movzx	 eax, WORD PTR hwOffset$[rsp]
  01394	85 c0		 test	 eax, eax
  01396	75 05		 jne	 SHORT $LN156@LCS_Write_

; 4559 :                 break;

  01398	e9 2a 07 00 00	 jmp	 $LN68@LCS_Write_
$LN156@LCS_Write_:

; 4560 : 
; 4561 :             // Calculate size of this LCS Frame
; 4562 :             hwLength = hwOffset - hwPrevOffset;

  0139d	0f b7 44 24 70	 movzx	 eax, WORD PTR hwOffset$[rsp]
  013a2	0f b7 8c 24 90
	00 00 00	 movzx	 ecx, WORD PTR hwPrevOffset$[rsp]
  013aa	2b c1		 sub	 eax, ecx
  013ac	66 89 44 24 74	 mov	 WORD PTR hwLength$[rsp], ax

; 4563 : 
; 4564 :             switch (pLCSHDR->bType)

  013b1	48 8b 44 24 78	 mov	 rax, QWORD PTR pLCSHDR$[rsp]
  013b6	0f b6 40 02	 movzx	 eax, BYTE PTR [rax+2]
  013ba	88 84 24 30 01
	00 00		 mov	 BYTE PTR tv745[rsp], al
  013c1	80 bc 24 30 01
	00 00 00	 cmp	 BYTE PTR tv745[rsp], 0
  013c9	74 05		 je	 SHORT $LN157@LCS_Write_
  013cb	e9 a9 04 00 00	 jmp	 $LN168@LCS_Write_
$LN157@LCS_Write_:

; 4565 :             {
; 4566 :             case LCS_FRMTYP_CMD:    // 0x00: LCS Command Frame
; 4567 : 
; 4568 :                 pCmdFrame = (PLCSCMDHDR)pLCSHDR;

  013d0	48 8b 44 24 78	 mov	 rax, QWORD PTR pLCSHDR$[rsp]
  013d5	48 89 84 24 88
	00 00 00	 mov	 QWORD PTR pCmdFrame$[rsp], rax
$LN73@LCS_Write_:

; 4569 : 
; 4570 :                 PTT_DEBUG( "WSNA: Cmd frame   ", pCmdFrame->bCmdCode, pDEVBLK->devnum, -1 );

  013dd	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_pttclass
  013e4	48 8b 00	 mov	 rax, QWORD PTR [rax]
  013e7	48 25 00 00 02
	00		 and	 rax, 131072		; 00020000H
  013ed	48 85 c0	 test	 rax, rax
  013f0	74 4e		 je	 SHORT $LN158@LCS_Write_
  013f2	48 8b 84 24 90
	02 00 00	 mov	 rax, QWORD PTR pDEVBLK$[rsp]
  013fa	0f b7 40 48	 movzx	 eax, WORD PTR [rax+72]
  013fe	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR pCmdFrame$[rsp]
  01406	0f b6 49 04	 movzx	 ecx, BYTE PTR [rcx+4]
  0140a	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR [rsp+48], 0
  01413	48 c7 44 24 28
	ff ff ff ff	 mov	 QWORD PTR [rsp+40], -1
  0141c	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG173767
  01423	48 89 54 24 20	 mov	 QWORD PTR [rsp+32], rdx
  01428	44 8b c8	 mov	 r9d, eax
  0142b	44 8b c1	 mov	 r8d, ecx
  0142e	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG173768
  01435	b9 00 00 02 00	 mov	 ecx, 131072		; 00020000H
  0143a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ptt_pthread_trace
$LN158@LCS_Write_:
  01440	33 c0		 xor	 eax, eax
  01442	85 c0		 test	 eax, eax
  01444	75 97		 jne	 SHORT $LN73@LCS_Write_

; 4571 : 
; 4572 :                 switch (pCmdFrame->bCmdCode)

  01446	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR pCmdFrame$[rsp]
  0144e	0f b6 40 04	 movzx	 eax, BYTE PTR [rax+4]
  01452	88 84 24 c4 00
	00 00		 mov	 BYTE PTR tv762[rsp], al
  01459	80 bc 24 c4 00
	00 00 41	 cmp	 BYTE PTR tv762[rsp], 65	; 00000041H
  01461	74 13		 je	 SHORT $LN159@LCS_Write_
  01463	80 bc 24 c4 00
	00 00 44	 cmp	 BYTE PTR tv762[rsp], 68	; 00000044H
  0146b	0f 84 47 01 00
	00		 je	 $LN162@LCS_Write_
  01471	e9 97 02 00 00	 jmp	 $LN165@LCS_Write_
$LN159@LCS_Write_:
$LN78@LCS_Write_:

; 4573 :                 {
; 4574 :                     //  HHC00933  =  "%1d:%04X CTC: executing command %s"
; 4575 : 
; 4576 :                 case LCS_CMD_STRTLAN_SNA:   // Start LAN SNA
; 4577 :                     PTT_DEBUG( "CMD=Start LAN SNA ", pCmdFrame->bCmdCode, pDEVBLK->devnum, -1 );

  01476	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_pttclass
  0147d	48 8b 00	 mov	 rax, QWORD PTR [rax]
  01480	48 25 00 00 02
	00		 and	 rax, 131072		; 00020000H
  01486	48 85 c0	 test	 rax, rax
  01489	74 4e		 je	 SHORT $LN160@LCS_Write_
  0148b	48 8b 84 24 90
	02 00 00	 mov	 rax, QWORD PTR pDEVBLK$[rsp]
  01493	0f b7 40 48	 movzx	 eax, WORD PTR [rax+72]
  01497	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR pCmdFrame$[rsp]
  0149f	0f b6 49 04	 movzx	 ecx, BYTE PTR [rcx+4]
  014a3	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR [rsp+48], 0
  014ac	48 c7 44 24 28
	ff ff ff ff	 mov	 QWORD PTR [rsp+40], -1
  014b5	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG173771
  014bc	48 89 54 24 20	 mov	 QWORD PTR [rsp+32], rdx
  014c1	44 8b c8	 mov	 r9d, eax
  014c4	44 8b c1	 mov	 r8d, ecx
  014c7	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG173772
  014ce	b9 00 00 02 00	 mov	 ecx, 131072		; 00020000H
  014d3	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ptt_pthread_trace
$LN160@LCS_Write_:
  014d9	33 c0		 xor	 eax, eax
  014db	85 c0		 test	 eax, eax
  014dd	75 97		 jne	 SHORT $LN78@LCS_Write_

; 4578 :                     if (pLCSBLK->fDebug)

  014df	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR pLCSBLK$[rsp]
  014e7	8b 40 18	 mov	 eax, DWORD PTR [rax+24]
  014ea	83 e0 01	 and	 eax, 1
  014ed	85 c0		 test	 eax, eax
  014ef	0f 84 91 00 00
	00		 je	 $LN161@LCS_Write_

; 4579 :                         WRMSG( HHC00933, "D", SSID_TO_LCSS(pDEVBLK->ssid), pDEVBLK->devnum, "start lan sna" );

  014f5	48 8b 84 24 90
	02 00 00	 mov	 rax, QWORD PTR pDEVBLK$[rsp]
  014fd	0f b7 40 48	 movzx	 eax, WORD PTR [rax+72]
  01501	89 84 24 34 01
	00 00		 mov	 DWORD PTR tv782[rsp], eax
  01508	48 8b 8c 24 90
	02 00 00	 mov	 rcx, QWORD PTR pDEVBLK$[rsp]
  01510	0f b7 49 44	 movzx	 ecx, WORD PTR [rcx+68]
  01514	d1 f9		 sar	 ecx, 1
  01516	89 8c 24 f4 00
	00 00		 mov	 DWORD PTR tv786[rsp], ecx
  0151d	b9 01 00 00 00	 mov	 ecx, 1
  01522	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  01528	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG173774
  0152f	48 89 4c 24 48	 mov	 QWORD PTR [rsp+72], rcx
  01534	8b 8c 24 34 01
	00 00		 mov	 ecx, DWORD PTR tv782[rsp]
  0153b	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  0153f	8b 8c 24 f4 00
	00 00		 mov	 ecx, DWORD PTR tv786[rsp]
  01546	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  0154a	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG173775
  01551	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  01556	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG173776
  0155d	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  01562	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  01567	41 b9 03 00 00
	00		 mov	 r9d, 3
  0156d	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG173777
  01574	ba e3 11 00 00	 mov	 edx, 4579		; 000011e3H
  01579	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG173778
  01580	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg
$LN161@LCS_Write_:

; 4580 :                     LCS_StartLan_SNA( pLCSDEV, pCmdFrame, (int)hwLength );

  01586	0f b7 44 24 74	 movzx	 eax, WORD PTR hwLength$[rsp]
  0158b	44 8b c0	 mov	 r8d, eax
  0158e	48 8b 94 24 88
	00 00 00	 mov	 rdx, QWORD PTR pCmdFrame$[rsp]
  01596	48 8b 4c 24 60	 mov	 rcx, QWORD PTR pLCSDEV$[rsp]
  0159b	e8 00 00 00 00	 call	 LCS_StartLan_SNA

; 4581 :                     pLCSDEV->fAttnRequired = TRUE;

  015a0	48 8b 44 24 60	 mov	 rax, QWORD PTR pLCSDEV$[rsp]
  015a5	8b 40 5d	 mov	 eax, DWORD PTR [rax+93]
  015a8	83 c8 02	 or	 eax, 2
  015ab	48 8b 4c 24 60	 mov	 rcx, QWORD PTR pLCSDEV$[rsp]
  015b0	89 41 5d	 mov	 DWORD PTR [rcx+93], eax

; 4582 :                     break;

  015b3	e9 bc 02 00 00	 jmp	 $LN74@LCS_Write_
$LN162@LCS_Write_:
$LN81@LCS_Write_:

; 4583 : 
; 4584 :                 case LCS_CMD_LANSTAT_SNA:   // LAN Stats SNA
; 4585 :                     PTT_DEBUG( "CMD=LAN Stats SNA ", pCmdFrame->bCmdCode, pDEVBLK->devnum, -1 );

  015b8	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_pttclass
  015bf	48 8b 00	 mov	 rax, QWORD PTR [rax]
  015c2	48 25 00 00 02
	00		 and	 rax, 131072		; 00020000H
  015c8	48 85 c0	 test	 rax, rax
  015cb	74 4e		 je	 SHORT $LN163@LCS_Write_
  015cd	48 8b 84 24 90
	02 00 00	 mov	 rax, QWORD PTR pDEVBLK$[rsp]
  015d5	0f b7 40 48	 movzx	 eax, WORD PTR [rax+72]
  015d9	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR pCmdFrame$[rsp]
  015e1	0f b6 49 04	 movzx	 ecx, BYTE PTR [rcx+4]
  015e5	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR [rsp+48], 0
  015ee	48 c7 44 24 28
	ff ff ff ff	 mov	 QWORD PTR [rsp+40], -1
  015f7	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG173781
  015fe	48 89 54 24 20	 mov	 QWORD PTR [rsp+32], rdx
  01603	44 8b c8	 mov	 r9d, eax
  01606	44 8b c1	 mov	 r8d, ecx
  01609	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG173782
  01610	b9 00 00 02 00	 mov	 ecx, 131072		; 00020000H
  01615	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ptt_pthread_trace
$LN163@LCS_Write_:
  0161b	33 c0		 xor	 eax, eax
  0161d	85 c0		 test	 eax, eax
  0161f	75 97		 jne	 SHORT $LN81@LCS_Write_

; 4586 :                     if (pLCSBLK->fDebug)

  01621	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR pLCSBLK$[rsp]
  01629	8b 40 18	 mov	 eax, DWORD PTR [rax+24]
  0162c	83 e0 01	 and	 eax, 1
  0162f	85 c0		 test	 eax, eax
  01631	0f 84 91 00 00
	00		 je	 $LN164@LCS_Write_

; 4587 :                         WRMSG( HHC00933, "D", SSID_TO_LCSS(pDEVBLK->ssid), pDEVBLK->devnum, "lan statistics sna" );

  01637	48 8b 84 24 90
	02 00 00	 mov	 rax, QWORD PTR pDEVBLK$[rsp]
  0163f	0f b7 40 48	 movzx	 eax, WORD PTR [rax+72]
  01643	89 84 24 f8 00
	00 00		 mov	 DWORD PTR tv823[rsp], eax
  0164a	48 8b 8c 24 90
	02 00 00	 mov	 rcx, QWORD PTR pDEVBLK$[rsp]
  01652	0f b7 49 44	 movzx	 ecx, WORD PTR [rcx+68]
  01656	d1 f9		 sar	 ecx, 1
  01658	89 8c 24 fc 00
	00 00		 mov	 DWORD PTR tv827[rsp], ecx
  0165f	b9 01 00 00 00	 mov	 ecx, 1
  01664	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  0166a	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG173784
  01671	48 89 4c 24 48	 mov	 QWORD PTR [rsp+72], rcx
  01676	8b 8c 24 f8 00
	00 00		 mov	 ecx, DWORD PTR tv823[rsp]
  0167d	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  01681	8b 8c 24 fc 00
	00 00		 mov	 ecx, DWORD PTR tv827[rsp]
  01688	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  0168c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG173785
  01693	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  01698	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG173786
  0169f	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  016a4	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  016a9	41 b9 03 00 00
	00		 mov	 r9d, 3
  016af	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG173787
  016b6	ba eb 11 00 00	 mov	 edx, 4587		; 000011ebH
  016bb	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG173788
  016c2	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg
$LN164@LCS_Write_:

; 4588 :                     LCS_LanStats_SNA( pLCSDEV, pCmdFrame, (int)hwLength );

  016c8	0f b7 44 24 74	 movzx	 eax, WORD PTR hwLength$[rsp]
  016cd	44 8b c0	 mov	 r8d, eax
  016d0	48 8b 94 24 88
	00 00 00	 mov	 rdx, QWORD PTR pCmdFrame$[rsp]
  016d8	48 8b 4c 24 60	 mov	 rcx, QWORD PTR pLCSDEV$[rsp]
  016dd	e8 00 00 00 00	 call	 LCS_LanStats_SNA

; 4589 :                     pLCSDEV->fAttnRequired = TRUE;

  016e2	48 8b 44 24 60	 mov	 rax, QWORD PTR pLCSDEV$[rsp]
  016e7	8b 40 5d	 mov	 eax, DWORD PTR [rax+93]
  016ea	83 c8 02	 or	 eax, 2
  016ed	48 8b 4c 24 60	 mov	 rcx, QWORD PTR pLCSDEV$[rsp]
  016f2	89 41 5d	 mov	 DWORD PTR [rcx+93], eax

; 4590 :                     pLCSDEV->fReceiveFrames = TRUE;

  016f5	48 8b 44 24 60	 mov	 rax, QWORD PTR pLCSDEV$[rsp]
  016fa	8b 40 5d	 mov	 eax, DWORD PTR [rax+93]
  016fd	83 c8 08	 or	 eax, 8
  01700	48 8b 4c 24 60	 mov	 rcx, QWORD PTR pLCSDEV$[rsp]
  01705	89 41 5d	 mov	 DWORD PTR [rcx+93], eax

; 4591 :                     break;

  01708	e9 67 01 00 00	 jmp	 $LN74@LCS_Write_
$LN165@LCS_Write_:
$LN84@LCS_Write_:

; 4592 : 
; 4593 :                 default:
; 4594 :                     PTT_DEBUG( "*CMD=Unsupported! ", pCmdFrame->bCmdCode, pDEVBLK->devnum, -1 );

  0170d	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_pttclass
  01714	48 8b 00	 mov	 rax, QWORD PTR [rax]
  01717	48 25 00 00 02
	00		 and	 rax, 131072		; 00020000H
  0171d	48 85 c0	 test	 rax, rax
  01720	74 4e		 je	 SHORT $LN166@LCS_Write_
  01722	48 8b 84 24 90
	02 00 00	 mov	 rax, QWORD PTR pDEVBLK$[rsp]
  0172a	0f b7 40 48	 movzx	 eax, WORD PTR [rax+72]
  0172e	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR pCmdFrame$[rsp]
  01736	0f b6 49 04	 movzx	 ecx, BYTE PTR [rcx+4]
  0173a	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR [rsp+48], 0
  01743	48 c7 44 24 28
	ff ff ff ff	 mov	 QWORD PTR [rsp+40], -1
  0174c	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG173791
  01753	48 89 54 24 20	 mov	 QWORD PTR [rsp+32], rdx
  01758	44 8b c8	 mov	 r9d, eax
  0175b	44 8b c1	 mov	 r8d, ecx
  0175e	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG173792
  01765	b9 00 00 02 00	 mov	 ecx, 131072		; 00020000H
  0176a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ptt_pthread_trace
$LN166@LCS_Write_:
  01770	33 c0		 xor	 eax, eax
  01772	85 c0		 test	 eax, eax
  01774	75 97		 jne	 SHORT $LN84@LCS_Write_

; 4595 :                     if (pLCSBLK->fDebug)

  01776	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR pLCSBLK$[rsp]
  0177e	8b 40 18	 mov	 eax, DWORD PTR [rax+24]
  01781	83 e0 01	 and	 eax, 1
  01784	85 c0		 test	 eax, eax
  01786	0f 84 bb 00 00
	00		 je	 $LN167@LCS_Write_

; 4596 :                     {
; 4597 :                         // "%1d:%04X CTC: executing command %s"
; 4598 :                         MSGBUF( buf, "other (0x%2.2X)", pCmdFrame->bCmdCode );

  0178c	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR pCmdFrame$[rsp]
  01794	0f b6 40 04	 movzx	 eax, BYTE PTR [rax+4]
  01798	44 8b c8	 mov	 r9d, eax
  0179b	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG173794
  017a2	ba 20 00 00 00	 mov	 edx, 32			; 00000020H
  017a7	48 8d 8c 24 48
	01 00 00	 lea	 rcx, QWORD PTR buf$[rsp]
  017af	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_snprintf

; 4599 :                         WRMSG( HHC00933, "D", SSID_TO_LCSS(pDEVBLK->ssid), pDEVBLK->devnum, buf );

  017b5	48 8b 84 24 90
	02 00 00	 mov	 rax, QWORD PTR pDEVBLK$[rsp]
  017bd	0f b7 40 48	 movzx	 eax, WORD PTR [rax+72]
  017c1	89 84 24 00 01
	00 00		 mov	 DWORD PTR tv873[rsp], eax
  017c8	48 8b 8c 24 90
	02 00 00	 mov	 rcx, QWORD PTR pDEVBLK$[rsp]
  017d0	0f b7 49 44	 movzx	 ecx, WORD PTR [rcx+68]
  017d4	d1 f9		 sar	 ecx, 1
  017d6	89 8c 24 04 01
	00 00		 mov	 DWORD PTR tv877[rsp], ecx
  017dd	b9 01 00 00 00	 mov	 ecx, 1
  017e2	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  017e8	48 8d 8c 24 48
	01 00 00	 lea	 rcx, QWORD PTR buf$[rsp]
  017f0	48 89 4c 24 48	 mov	 QWORD PTR [rsp+72], rcx
  017f5	8b 8c 24 00 01
	00 00		 mov	 ecx, DWORD PTR tv873[rsp]
  017fc	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  01800	8b 8c 24 04 01
	00 00		 mov	 ecx, DWORD PTR tv877[rsp]
  01807	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  0180b	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG173795
  01812	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  01817	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG173796
  0181e	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  01823	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  01828	41 b9 03 00 00
	00		 mov	 r9d, 3
  0182e	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG173797
  01835	ba f7 11 00 00	 mov	 edx, 4599		; 000011f7H
  0183a	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG173798
  01841	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg
$LN167@LCS_Write_:

; 4600 :                     }
; 4601 :                     LCS_UnsuppCmd_SNA( pLCSDEV, pCmdFrame, (int)hwLength );

  01847	0f b7 44 24 74	 movzx	 eax, WORD PTR hwLength$[rsp]
  0184c	44 8b c0	 mov	 r8d, eax
  0184f	48 8b 94 24 88
	00 00 00	 mov	 rdx, QWORD PTR pCmdFrame$[rsp]
  01857	48 8b 4c 24 60	 mov	 rcx, QWORD PTR pLCSDEV$[rsp]
  0185c	e8 00 00 00 00	 call	 LCS_UnsuppCmd_SNA

; 4602 :                     pLCSDEV->fAttnRequired = TRUE;

  01861	48 8b 44 24 60	 mov	 rax, QWORD PTR pLCSDEV$[rsp]
  01866	8b 40 5d	 mov	 eax, DWORD PTR [rax+93]
  01869	83 c8 02	 or	 eax, 2
  0186c	48 8b 4c 24 60	 mov	 rcx, QWORD PTR pLCSDEV$[rsp]
  01871	89 41 5d	 mov	 DWORD PTR [rcx+93], eax
$LN74@LCS_Write_:

; 4603 :                     break;
; 4604 : 
; 4605 :                 } // end switch (LCS Command Frame cmd code)
; 4606 : 
; 4607 :                 break; // end case LCS_FRMTYP_CMD

  01874	e9 49 02 00 00	 jmp	 $LN69@LCS_Write_
$LN168@LCS_Write_:
$LN87@LCS_Write_:

; 4608 : 
; 4609 :             default:
; 4610 :                 PTT_DEBUG( "*WRIT Unsupp frame", pCmdFrame->bCmdCode, pDEVBLK->devnum, -1 );

  01879	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_pttclass
  01880	48 8b 00	 mov	 rax, QWORD PTR [rax]
  01883	48 25 00 00 02
	00		 and	 rax, 131072		; 00020000H
  01889	48 85 c0	 test	 rax, rax
  0188c	74 4e		 je	 SHORT $LN169@LCS_Write_
  0188e	48 8b 84 24 90
	02 00 00	 mov	 rax, QWORD PTR pDEVBLK$[rsp]
  01896	0f b7 40 48	 movzx	 eax, WORD PTR [rax+72]
  0189a	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR pCmdFrame$[rsp]
  018a2	0f b6 49 04	 movzx	 ecx, BYTE PTR [rcx+4]
  018a6	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR [rsp+48], 0
  018af	48 c7 44 24 28
	ff ff ff ff	 mov	 QWORD PTR [rsp+40], -1
  018b8	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG173801
  018bf	48 89 54 24 20	 mov	 QWORD PTR [rsp+32], rdx
  018c4	44 8b c8	 mov	 r9d, eax
  018c7	44 8b c1	 mov	 r8d, ecx
  018ca	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG173802
  018d1	b9 00 00 02 00	 mov	 ecx, 131072		; 00020000H
  018d6	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ptt_pthread_trace
$LN169@LCS_Write_:
  018dc	33 c0		 xor	 eax, eax
  018de	85 c0		 test	 eax, eax
  018e0	75 97		 jne	 SHORT $LN87@LCS_Write_

; 4611 :                 // "%1d:%04X CTC: lcs write: unsupported frame type 0x%2.2X"
; 4612 :                 WRMSG( HHC00937, "E", SSID_TO_LCSS(pDEVBLK->ssid), pDEVBLK->devnum, pLCSHDR->bType );

  018e2	48 8b 44 24 78	 mov	 rax, QWORD PTR pLCSHDR$[rsp]
  018e7	0f b6 40 02	 movzx	 eax, BYTE PTR [rax+2]
  018eb	89 84 24 08 01
	00 00		 mov	 DWORD PTR tv914[rsp], eax
  018f2	48 8b 8c 24 90
	02 00 00	 mov	 rcx, QWORD PTR pDEVBLK$[rsp]
  018fa	0f b7 49 48	 movzx	 ecx, WORD PTR [rcx+72]
  018fe	89 8c 24 0c 01
	00 00		 mov	 DWORD PTR tv917[rsp], ecx
  01905	48 8b 94 24 90
	02 00 00	 mov	 rdx, QWORD PTR pDEVBLK$[rsp]
  0190d	0f b7 52 44	 movzx	 edx, WORD PTR [rdx+68]
  01911	d1 fa		 sar	 edx, 1
  01913	89 94 24 10 01
	00 00		 mov	 DWORD PTR tv921[rsp], edx
  0191a	b9 01 00 00 00	 mov	 ecx, 1
  0191f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  01925	8b 8c 24 08 01
	00 00		 mov	 ecx, DWORD PTR tv914[rsp]
  0192c	89 4c 24 48	 mov	 DWORD PTR [rsp+72], ecx
  01930	8b 8c 24 0c 01
	00 00		 mov	 ecx, DWORD PTR tv917[rsp]
  01937	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  0193b	8b 8c 24 10 01
	00 00		 mov	 ecx, DWORD PTR tv921[rsp]
  01942	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  01946	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG173803
  0194d	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  01952	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG173804
  01959	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  0195e	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  01963	41 b9 03 00 00
	00		 mov	 r9d, 3
  01969	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG173805
  01970	ba 04 12 00 00	 mov	 edx, 4612		; 00001204H
  01975	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG173806
  0197c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg
$LN90@LCS_Write_:

; 4613 :                 ASSERT( FALSE );

  01982	33 c0		 xor	 eax, eax
  01984	83 f8 01	 cmp	 eax, 1
  01987	74 5c		 je	 SHORT $LN170@LCS_Write_
$LN93@LCS_Write_:
  01989	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG173808
  01990	41 b8 05 12 00
	00		 mov	 r8d, 4613		; 00001205H
  01996	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG173809
  0199d	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG173810
  019a4	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_logmsg
  019aa	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_IsDebuggerPresent
  019b0	85 c0		 test	 eax, eax
  019b2	74 20		 je	 SHORT $LN171@LCS_Write_
  019b4	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG173812
  019bb	41 b8 05 12 00
	00		 mov	 r8d, 4613		; 00001205H
  019c1	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG173813
  019c8	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG173814
  019cf	e8 00 00 00 00	 call	 DebuggerTrace
$LN171@LCS_Write_:
  019d4	33 c0		 xor	 eax, eax
  019d6	85 c0		 test	 eax, eax
  019d8	75 af		 jne	 SHORT $LN93@LCS_Write_
  019da	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_IsDebuggerPresent
  019e0	85 c0		 test	 eax, eax
  019e2	74 01		 je	 SHORT $LN172@LCS_Write_
  019e4	cc		 int	 3
$LN172@LCS_Write_:
$LN170@LCS_Write_:
  019e5	33 c0		 xor	 eax, eax
  019e7	85 c0		 test	 eax, eax
  019e9	75 97		 jne	 SHORT $LN90@LCS_Write_

; 4614 :                 pDEVBLK->sense[0] = SENSE_EC;

  019eb	b8 01 00 00 00	 mov	 eax, 1
  019f0	48 6b c0 00	 imul	 rax, rax, 0
  019f4	48 8b 8c 24 90
	02 00 00	 mov	 rcx, QWORD PTR pDEVBLK$[rsp]
  019fc	c6 84 01 64 03
	00 00 10	 mov	 BYTE PTR [rcx+rax+868], 16

; 4615 :                 *pUnitStat = CSW_CE | CSW_DE | CSW_UC;

  01a04	48 8b 84 24 a8
	02 00 00	 mov	 rax, QWORD PTR pUnitStat$[rsp]
  01a0c	c6 00 0e	 mov	 BYTE PTR [rax], 14
$LN96@LCS_Write_:

; 4616 : //??            LCS_EndMWrite( pDEVBLK, nEthBytes, nEthFrames );
; 4617 :                 PTT_TIMING( "end write",  0, 0, 0 );

  01a0f	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_pttclass
  01a16	48 8b 00	 mov	 rax, QWORD PTR [rax]
  01a19	48 25 00 00 01
	00		 and	 rax, 65536		; 00010000H
  01a1f	48 85 c0	 test	 rax, rax
  01a22	74 36		 je	 SHORT $LN173@LCS_Write_
  01a24	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR [rsp+48], 0
  01a2d	48 c7 44 24 28
	00 00 00 00	 mov	 QWORD PTR [rsp+40], 0
  01a36	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG173817
  01a3d	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  01a42	45 33 c9	 xor	 r9d, r9d
  01a45	45 33 c0	 xor	 r8d, r8d
  01a48	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG173818
  01a4f	b9 00 00 01 00	 mov	 ecx, 65536		; 00010000H
  01a54	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ptt_pthread_trace
$LN173@LCS_Write_:
  01a5a	33 c0		 xor	 eax, eax
  01a5c	85 c0		 test	 eax, eax
  01a5e	75 af		 jne	 SHORT $LN96@LCS_Write_
$LN99@LCS_Write_:

; 4618 :                 PTT_DEBUG( "WSNA EXIT         ", 000, pDEVBLK->devnum, -1 );

  01a60	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_pttclass
  01a67	48 8b 00	 mov	 rax, QWORD PTR [rax]
  01a6a	48 25 00 00 02
	00		 and	 rax, 131072		; 00020000H
  01a70	48 85 c0	 test	 rax, rax
  01a73	74 42		 je	 SHORT $LN174@LCS_Write_
  01a75	48 8b 84 24 90
	02 00 00	 mov	 rax, QWORD PTR pDEVBLK$[rsp]
  01a7d	0f b7 40 48	 movzx	 eax, WORD PTR [rax+72]
  01a81	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR [rsp+48], 0
  01a8a	48 c7 44 24 28
	ff ff ff ff	 mov	 QWORD PTR [rsp+40], -1
  01a93	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG173820
  01a9a	48 89 4c 24 20	 mov	 QWORD PTR [rsp+32], rcx
  01a9f	44 8b c8	 mov	 r9d, eax
  01aa2	45 33 c0	 xor	 r8d, r8d
  01aa5	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG173821
  01aac	b9 00 00 02 00	 mov	 ecx, 131072		; 00020000H
  01ab1	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ptt_pthread_trace
$LN174@LCS_Write_:
  01ab7	33 c0		 xor	 eax, eax
  01ab9	85 c0		 test	 eax, eax
  01abb	75 a3		 jne	 SHORT $LN99@LCS_Write_

; 4619 :                 return;

  01abd	e9 e4 01 00 00	 jmp	 $LN1@LCS_Write_
$LN69@LCS_Write_:

; 4620 : 
; 4621 :             } // end switch (LCS Frame type)
; 4622 : 
; 4623 :         } // end while (1)

  01ac2	e9 61 f8 ff ff	 jmp	 $LN67@LCS_Write_
$LN68@LCS_Write_:
$LN112@LCS_Write_:

; 4624 : 
; 4625 :     }
; 4626 : 
; 4627 :     // ----------------------------------------------------------------
; 4628 :     //    End of LCS_Write_SNA
; 4629 :     // ----------------------------------------------------------------
; 4630 : 
; 4631 :     if (!pLCSDEV->fTuntapError)

  01ac7	48 8b 44 24 60	 mov	 rax, QWORD PTR pLCSDEV$[rsp]
  01acc	8b 40 5d	 mov	 eax, DWORD PTR [rax+93]
  01acf	c1 e8 04	 shr	 eax, 4
  01ad2	83 e0 01	 and	 eax, 1
  01ad5	85 c0		 test	 eax, eax
  01ad7	75 1e		 jne	 SHORT $LN175@LCS_Write_

; 4632 :     {
; 4633 :         *pResidual = 0;

  01ad9	48 8b 84 24 b0
	02 00 00	 mov	 rax, QWORD PTR pResidual$[rsp]
  01ae1	c7 00 00 00 00
	00		 mov	 DWORD PTR [rax], 0

; 4634 :         *pUnitStat = CSW_CE | CSW_DE;

  01ae7	48 8b 84 24 a8
	02 00 00	 mov	 rax, QWORD PTR pUnitStat$[rsp]
  01aef	c6 00 0c	 mov	 BYTE PTR [rax], 12

; 4635 :     }

  01af2	e9 01 01 00 00	 jmp	 $LN176@LCS_Write_
$LN175@LCS_Write_:

; 4636 :     else
; 4637 :     {
; 4638 :         // "%1d:%04X CTC: error writing to file %s: %s"
; 4639 :         WRMSG( HHC00936, "E", SSID_TO_LCSS(pDEVBLK->ssid), pDEVBLK->devnum,

  01af7	48 8b 44 24 60	 mov	 rax, QWORD PTR pLCSDEV$[rsp]
  01afc	8b 48 61	 mov	 ecx, DWORD PTR [rax+97]
  01aff	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_strerror
  01b05	48 89 84 24 38
	01 00 00	 mov	 QWORD PTR tv1011[rsp], rax
  01b0d	48 8b 8c 24 90
	02 00 00	 mov	 rcx, QWORD PTR pDEVBLK$[rsp]
  01b15	48 81 c1 a4 00
	00 00		 add	 rcx, 164		; 000000a4H
  01b1c	48 89 8c 24 40
	01 00 00	 mov	 QWORD PTR tv1015[rsp], rcx
  01b24	48 8b 94 24 90
	02 00 00	 mov	 rdx, QWORD PTR pDEVBLK$[rsp]
  01b2c	0f b7 52 48	 movzx	 edx, WORD PTR [rdx+72]
  01b30	89 94 24 14 01
	00 00		 mov	 DWORD PTR tv1018[rsp], edx
  01b37	48 8b bc 24 90
	02 00 00	 mov	 rdi, QWORD PTR pDEVBLK$[rsp]
  01b3f	0f b7 7f 44	 movzx	 edi, WORD PTR [rdi+68]
  01b43	d1 ff		 sar	 edi, 1
  01b45	b9 01 00 00 00	 mov	 ecx, 1
  01b4a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  01b50	48 8b 8c 24 38
	01 00 00	 mov	 rcx, QWORD PTR tv1011[rsp]
  01b58	48 89 4c 24 50	 mov	 QWORD PTR [rsp+80], rcx
  01b5d	48 8b 8c 24 40
	01 00 00	 mov	 rcx, QWORD PTR tv1015[rsp]
  01b65	48 89 4c 24 48	 mov	 QWORD PTR [rsp+72], rcx
  01b6a	8b 8c 24 14 01
	00 00		 mov	 ecx, DWORD PTR tv1018[rsp]
  01b71	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  01b75	89 7c 24 38	 mov	 DWORD PTR [rsp+56], edi
  01b79	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG173824
  01b80	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  01b85	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG173825
  01b8c	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  01b91	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  01b96	41 b9 03 00 00
	00		 mov	 r9d, 3
  01b9c	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG173826
  01ba3	ba 20 12 00 00	 mov	 edx, 4640		; 00001220H
  01ba8	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG173827
  01baf	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 4640 :                               pDEVBLK->filename, strerror( pLCSDEV->iTuntapErrno ) );
; 4641 : 
; 4642 :         pDEVBLK->sense[0] = SENSE_EC;

  01bb5	b8 01 00 00 00	 mov	 eax, 1
  01bba	48 6b c0 00	 imul	 rax, rax, 0
  01bbe	48 8b 8c 24 90
	02 00 00	 mov	 rcx, QWORD PTR pDEVBLK$[rsp]
  01bc6	c6 84 01 64 03
	00 00 10	 mov	 BYTE PTR [rcx+rax+868], 16

; 4643 :         *pUnitStat = CSW_CE | CSW_DE | CSW_UC;

  01bce	48 8b 84 24 a8
	02 00 00	 mov	 rax, QWORD PTR pUnitStat$[rsp]
  01bd6	c6 00 0e	 mov	 BYTE PTR [rax], 14

; 4644 : 
; 4645 :         pLCSDEV->iTuntapErrno = 0;

  01bd9	48 8b 44 24 60	 mov	 rax, QWORD PTR pLCSDEV$[rsp]
  01bde	c7 40 61 00 00
	00 00		 mov	 DWORD PTR [rax+97], 0

; 4646 :         pLCSDEV->fTuntapError = FALSE;

  01be5	48 8b 44 24 60	 mov	 rax, QWORD PTR pLCSDEV$[rsp]
  01bea	8b 40 5d	 mov	 eax, DWORD PTR [rax+93]
  01bed	83 e0 ef	 and	 eax, -17		; ffffffefH
  01bf0	48 8b 4c 24 60	 mov	 rcx, QWORD PTR pLCSDEV$[rsp]
  01bf5	89 41 5d	 mov	 DWORD PTR [rcx+93], eax
$LN176@LCS_Write_:
$LN102@LCS_Write_:

; 4647 :     }
; 4648 : 
; 4649 :     PTT_TIMING( "end write",  0, 0, 0 );

  01bf8	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_pttclass
  01bff	48 8b 00	 mov	 rax, QWORD PTR [rax]
  01c02	48 25 00 00 01
	00		 and	 rax, 65536		; 00010000H
  01c08	48 85 c0	 test	 rax, rax
  01c0b	74 36		 je	 SHORT $LN177@LCS_Write_
  01c0d	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR [rsp+48], 0
  01c16	48 c7 44 24 28
	00 00 00 00	 mov	 QWORD PTR [rsp+40], 0
  01c1f	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG173829
  01c26	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  01c2b	45 33 c9	 xor	 r9d, r9d
  01c2e	45 33 c0	 xor	 r8d, r8d
  01c31	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG173830
  01c38	b9 00 00 01 00	 mov	 ecx, 65536		; 00010000H
  01c3d	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ptt_pthread_trace
$LN177@LCS_Write_:
  01c43	33 c0		 xor	 eax, eax
  01c45	85 c0		 test	 eax, eax
  01c47	75 af		 jne	 SHORT $LN102@LCS_Write_
$LN105@LCS_Write_:

; 4650 :     PTT_DEBUG( "WSNA EXIT         ", 000, pDEVBLK->devnum, -1 );

  01c49	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_pttclass
  01c50	48 8b 00	 mov	 rax, QWORD PTR [rax]
  01c53	48 25 00 00 02
	00		 and	 rax, 131072		; 00020000H
  01c59	48 85 c0	 test	 rax, rax
  01c5c	74 42		 je	 SHORT $LN178@LCS_Write_
  01c5e	48 8b 84 24 90
	02 00 00	 mov	 rax, QWORD PTR pDEVBLK$[rsp]
  01c66	0f b7 40 48	 movzx	 eax, WORD PTR [rax+72]
  01c6a	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR [rsp+48], 0
  01c73	48 c7 44 24 28
	ff ff ff ff	 mov	 QWORD PTR [rsp+40], -1
  01c7c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG173832
  01c83	48 89 4c 24 20	 mov	 QWORD PTR [rsp+32], rcx
  01c88	44 8b c8	 mov	 r9d, eax
  01c8b	45 33 c0	 xor	 r8d, r8d
  01c8e	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG173833
  01c95	b9 00 00 02 00	 mov	 ecx, 131072		; 00020000H
  01c9a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ptt_pthread_trace
$LN178@LCS_Write_:
  01ca0	33 c0		 xor	 eax, eax
  01ca2	85 c0		 test	 eax, eax
  01ca4	75 a3		 jne	 SHORT $LN105@LCS_Write_
$LN1@LCS_Write_:

; 4651 : }   // End of LCS_Write_SNA

  01ca6	48 8b 8c 24 70
	02 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  01cae	48 33 cc	 xor	 rcx, rsp
  01cb1	e8 00 00 00 00	 call	 __security_check_cookie
  01cb6	48 81 c4 80 02
	00 00		 add	 rsp, 640		; 00000280H
  01cbd	5f		 pop	 rdi
  01cbe	c3		 ret	 0
  01cbf	90		 npad	 1
$LN182@LCS_Write_:
  01cc0	00 00 00 00	 DD	 $LN125@LCS_Write_
  01cc4	00 00 00 00	 DD	 $LN129@LCS_Write_
  01cc8	00 00 00 00	 DD	 $LN131@LCS_Write_
  01ccc	00 00 00 00	 DD	 $LN132@LCS_Write_
  01cd0	00 00 00 00	 DD	 $LN127@LCS_Write_
  01cd4	00 00 00 00	 DD	 $LN126@LCS_Write_
  01cd8	00 00 00 00	 DD	 $LN134@LCS_Write_
$LN181@LCS_Write_:
  01cdc	00		 DB	 0
  01cdd	01		 DB	 1
  01cde	06		 DB	 6
  01cdf	02		 DB	 2
  01ce0	03		 DB	 3
  01ce1	06		 DB	 6
  01ce2	06		 DB	 6
  01ce3	06		 DB	 6
  01ce4	06		 DB	 6
  01ce5	06		 DB	 6
  01ce6	06		 DB	 6
  01ce7	06		 DB	 6
  01ce8	06		 DB	 6
  01ce9	06		 DB	 6
  01cea	06		 DB	 6
  01ceb	06		 DB	 6
  01cec	06		 DB	 6
  01ced	06		 DB	 6
  01cee	06		 DB	 6
  01cef	06		 DB	 6
  01cf0	06		 DB	 6
  01cf1	06		 DB	 6
  01cf2	06		 DB	 6
  01cf3	06		 DB	 6
  01cf4	04		 DB	 4
  01cf5	06		 DB	 6
  01cf6	06		 DB	 6
  01cf7	05		 DB	 5
LCS_Write_SNA ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\ctc_lcs.c
_TEXT	SEGMENT
pLCSDEV$ = 96
WantLCSICTL$ = 104
WantLCSIBH$ = 105
iLength$ = 108
hwDataSize$ = 112
iTraceLen$ = 116
iFiller$ = 120
pLCSICTL$ = 128
pLCSIBH$ = 136
tv288 = 144
tv292 = 148
tv311 = 152
tv317 = 156
tv321 = 160
pFrameSlot$ = 168
pFrameFiller$ = 176
pLCSHdr$ = 184
pDEVBLK$ = 224
sCount$ = 232
pIOBuf$ = 240
pUnitStat$ = 248
pResidual$ = 256
pMore$ = 264
LCS_Read_SNA PROC

; 6918 : {

  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  0000e	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00013	56		 push	 rsi
  00014	57		 push	 rdi
  00015	48 81 ec c8 00
	00 00		 sub	 rsp, 200		; 000000c8H

; 6919 :     PLCSHDR     pLCSHdr;
; 6920 :     PLCSDEV     pLCSDEV = (PLCSDEV)pDEVBLK->dev_data;

  0001c	48 8b 84 24 e0
	00 00 00	 mov	 rax, QWORD PTR pDEVBLK$[rsp]
  00024	48 8b 80 08 06
	00 00		 mov	 rax, QWORD PTR [rax+1544]
  0002b	48 89 44 24 60	 mov	 QWORD PTR pLCSDEV$[rsp], rax

; 6921 :     PLCSICTL    pLCSICTL;
; 6922 :     PLCSIBH     pLCSIBH;
; 6923 :     PLCSHDR     pFrameSlot;
; 6924 :     BYTE*       pFrameFiller;
; 6925 :     int         iFiller;
; 6926 :     int         iLength = 0;

  00030	c7 44 24 6c 00
	00 00 00	 mov	 DWORD PTR iLength$[rsp], 0
$LN4@LCS_Read_S:

; 6927 :     int         iTraceLen;
; 6928 :     U16         hwDataSize;
; 6929 :     BYTE        WantLCSICTL;
; 6930 :     BYTE        WantLCSIBH;
; 6931 : 
; 6932 : 
; 6933 :     PTT_DEBUG( "RSNA: ENTRY       ", 000, pDEVBLK->devnum, -1 );

  00038	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_pttclass
  0003f	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00042	48 25 00 00 02
	00		 and	 rax, 131072		; 00020000H
  00048	48 85 c0	 test	 rax, rax
  0004b	74 42		 je	 SHORT $LN13@LCS_Read_S
  0004d	48 8b 84 24 e0
	00 00 00	 mov	 rax, QWORD PTR pDEVBLK$[rsp]
  00055	0f b7 40 48	 movzx	 eax, WORD PTR [rax+72]
  00059	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR [rsp+48], 0
  00062	48 c7 44 24 28
	ff ff ff ff	 mov	 QWORD PTR [rsp+40], -1
  0006b	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG175457
  00072	48 89 4c 24 20	 mov	 QWORD PTR [rsp+32], rcx
  00077	44 8b c8	 mov	 r9d, eax
  0007a	45 33 c0	 xor	 r8d, r8d
  0007d	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG175458
  00084	b9 00 00 02 00	 mov	 ecx, 131072		; 00020000H
  00089	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ptt_pthread_trace
$LN13@LCS_Read_S:
  0008f	33 c0		 xor	 eax, eax
  00091	85 c0		 test	 eax, eax
  00093	75 a3		 jne	 SHORT $LN4@LCS_Read_S

; 6934 : 
; 6935 :     // Check whether the Read CCW is the third of three CCW's in the
; 6936 :     // WCTL channel program. The channel program contains Control
; 6937 :     // (0x17), Write (0x01) and Read (0x02) CCW's.
; 6938 :     if (pLCSDEV->bFlipFlop == WCTL)

  00095	48 8b 44 24 60	 mov	 rax, QWORD PTR pLCSDEV$[rsp]
  0009a	0f b6 40 65	 movzx	 eax, BYTE PTR [rax+101]
  0009e	83 f8 17	 cmp	 eax, 23
  000a1	75 0c		 jne	 SHORT $LN14@LCS_Read_S

; 6939 :     {
; 6940 :         WantLCSICTL = TRUE;

  000a3	c6 44 24 68 01	 mov	 BYTE PTR WantLCSICTL$[rsp], 1

; 6941 :         WantLCSIBH = FALSE;

  000a8	c6 44 24 69 00	 mov	 BYTE PTR WantLCSIBH$[rsp], 0

; 6942 :     }

  000ad	eb 24		 jmp	 SHORT $LN15@LCS_Read_S
$LN14@LCS_Read_S:

; 6943 :     // Check whether the Read CCW is the third of three CCW's in the
; 6944 :     // SCB channel program, where the channel program contains Sense
; 6945 :     // Command Byte (0x14), Write (0x01) and Read (0x02) CCW's,
; 6946 :     else if (pLCSDEV->bFlipFlop == SCB)

  000af	48 8b 44 24 60	 mov	 rax, QWORD PTR pLCSDEV$[rsp]
  000b4	0f b6 40 65	 movzx	 eax, BYTE PTR [rax+101]
  000b8	83 f8 14	 cmp	 eax, 20
  000bb	75 0c		 jne	 SHORT $LN16@LCS_Read_S

; 6947 :     {
; 6948 :         WantLCSICTL = TRUE;

  000bd	c6 44 24 68 01	 mov	 BYTE PTR WantLCSICTL$[rsp], 1

; 6949 :         WantLCSIBH = TRUE;

  000c2	c6 44 24 69 01	 mov	 BYTE PTR WantLCSIBH$[rsp], 1

; 6950 :     }

  000c7	eb 0a		 jmp	 SHORT $LN17@LCS_Read_S
$LN16@LCS_Read_S:

; 6951 :     // The Read CCW is the only CCW in the channel program. This
; 6952 :     // is the state while the Start LAN and LAN Stats commands
; 6953 :     // are being processed.
; 6954 :     else
; 6955 :     {
; 6956 :         WantLCSICTL = FALSE;

  000c9	c6 44 24 68 00	 mov	 BYTE PTR WantLCSICTL$[rsp], 0

; 6957 :         WantLCSIBH = TRUE;

  000ce	c6 44 24 69 01	 mov	 BYTE PTR WantLCSIBH$[rsp], 1
$LN17@LCS_Read_S:
$LN15@LCS_Read_S:

; 6958 :     }
; 6959 : 
; 6960 :     //
; 6961 :     if ( WantLCSICTL )

  000d3	0f b6 44 24 68	 movzx	 eax, BYTE PTR WantLCSICTL$[rsp]
  000d8	85 c0		 test	 eax, eax
  000da	74 42		 je	 SHORT $LN18@LCS_Read_S

; 6962 :     {
; 6963 :         // Prepare the ICTL
; 6964 :         pLCSDEV->hwIctlSize = sizeof(LCSICTL);

  000dc	b8 08 00 00 00	 mov	 eax, 8
  000e1	48 8b 4c 24 60	 mov	 rcx, QWORD PTR pLCSDEV$[rsp]
  000e6	66 89 41 4f	 mov	 WORD PTR [rcx+79], ax

; 6965 :         memset(&pLCSDEV->Ictl, 0, sizeof(LCSICTL));

  000ea	48 8b 44 24 60	 mov	 rax, QWORD PTR pLCSDEV$[rsp]
  000ef	48 83 c0 51	 add	 rax, 81			; 00000051H
  000f3	48 8b f8	 mov	 rdi, rax
  000f6	33 c0		 xor	 eax, eax
  000f8	b9 08 00 00 00	 mov	 ecx, 8
  000fd	f3 aa		 rep stosb

; 6966 :         pLCSICTL = &pLCSDEV->Ictl;

  000ff	48 8b 44 24 60	 mov	 rax, QWORD PTR pLCSDEV$[rsp]
  00104	48 83 c0 51	 add	 rax, 81			; 00000051H
  00108	48 89 84 24 80
	00 00 00	 mov	 QWORD PTR pLCSICTL$[rsp], rax

; 6967 :         pLCSICTL->XCNISTAT = XCNIRSVD;

  00110	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR pLCSICTL$[rsp]
  00118	c6 40 02 08	 mov	 BYTE PTR [rax+2], 8

; 6968 :     }

  0011c	eb 2c		 jmp	 SHORT $LN19@LCS_Read_S
$LN18@LCS_Read_S:

; 6969 :     else
; 6970 :     {
; 6971 :         // Clear the ICTL
; 6972 :         pLCSDEV->hwIctlSize = 0;

  0011e	33 c0		 xor	 eax, eax
  00120	48 8b 4c 24 60	 mov	 rcx, QWORD PTR pLCSDEV$[rsp]
  00125	66 89 41 4f	 mov	 WORD PTR [rcx+79], ax

; 6973 :         memset(&pLCSDEV->Ictl, 0, sizeof(LCSICTL));

  00129	48 8b 44 24 60	 mov	 rax, QWORD PTR pLCSDEV$[rsp]
  0012e	48 83 c0 51	 add	 rax, 81			; 00000051H
  00132	48 8b f8	 mov	 rdi, rax
  00135	33 c0		 xor	 eax, eax
  00137	b9 08 00 00 00	 mov	 ecx, 8
  0013c	f3 aa		 rep stosb

; 6974 :         pLCSICTL = NULL;

  0013e	48 c7 84 24 80
	00 00 00 00 00
	00 00		 mov	 QWORD PTR pLCSICTL$[rsp], 0
$LN19@LCS_Read_S:

; 6975 :     }
; 6976 : 
; 6977 :     //
; 6978 :     if ( WantLCSICTL )

  0014a	0f b6 44 24 68	 movzx	 eax, BYTE PTR WantLCSICTL$[rsp]
  0014f	85 c0		 test	 eax, eax
  00151	74 7c		 je	 SHORT $LN20@LCS_Read_S

; 6979 :     {
; 6980 :         if ( !pLCSDEV->iFrameOffset )

  00153	48 8b 44 24 60	 mov	 rax, QWORD PTR pLCSDEV$[rsp]
  00158	0f b7 80 a2 00
	00 00		 movzx	 eax, WORD PTR [rax+162]
  0015f	85 c0		 test	 eax, eax
  00161	75 6c		 jne	 SHORT $LN21@LCS_Read_S

; 6981 :         {
; 6982 :             pLCSICTL = (PLCSICTL)&pLCSDEV->bFrameBuffer;

  00163	48 8b 44 24 60	 mov	 rax, QWORD PTR pLCSDEV$[rsp]
  00168	48 05 a6 00 00
	00		 add	 rax, 166		; 000000a6H
  0016e	48 89 84 24 80
	00 00 00	 mov	 QWORD PTR pLCSICTL$[rsp], rax

; 6983 :             memcpy( pLCSICTL, &pLCSDEV->Ictl, pLCSDEV->hwIctlSize );

  00176	48 8b 44 24 60	 mov	 rax, QWORD PTR pLCSDEV$[rsp]
  0017b	0f b7 40 4f	 movzx	 eax, WORD PTR [rax+79]
  0017f	48 8b 4c 24 60	 mov	 rcx, QWORD PTR pLCSDEV$[rsp]
  00184	48 83 c1 51	 add	 rcx, 81			; 00000051H
  00188	48 8b bc 24 80
	00 00 00	 mov	 rdi, QWORD PTR pLCSICTL$[rsp]
  00190	48 8b f1	 mov	 rsi, rcx
  00193	8b c8		 mov	 ecx, eax
  00195	f3 a4		 rep movsb

; 6984 :             pLCSDEV->iFrameOffset += pLCSDEV->hwIctlSize;

  00197	48 8b 44 24 60	 mov	 rax, QWORD PTR pLCSDEV$[rsp]
  0019c	0f b7 40 4f	 movzx	 eax, WORD PTR [rax+79]
  001a0	48 8b 4c 24 60	 mov	 rcx, QWORD PTR pLCSDEV$[rsp]
  001a5	0f b7 89 a2 00
	00 00		 movzx	 ecx, WORD PTR [rcx+162]
  001ac	03 c8		 add	 ecx, eax
  001ae	8b c1		 mov	 eax, ecx
  001b0	48 8b 4c 24 60	 mov	 rcx, QWORD PTR pLCSDEV$[rsp]
  001b5	66 89 81 a2 00
	00 00		 mov	 WORD PTR [rcx+162], ax

; 6985 :             pLCSDEV->fPendingIctl = 1;

  001bc	48 8b 44 24 60	 mov	 rax, QWORD PTR pLCSDEV$[rsp]
  001c1	8b 40 5d	 mov	 eax, DWORD PTR [rax+93]
  001c4	83 c8 04	 or	 eax, 4
  001c7	48 8b 4c 24 60	 mov	 rcx, QWORD PTR pLCSDEV$[rsp]
  001cc	89 41 5d	 mov	 DWORD PTR [rcx+93], eax
$LN21@LCS_Read_S:
$LN20@LCS_Read_S:

; 6986 :         }
; 6987 :     }
; 6988 : 
; 6989 :     //
; 6990 :     if ( WantLCSIBH )

  001cf	0f b6 44 24 69	 movzx	 eax, BYTE PTR WantLCSIBH$[rsp]
  001d4	85 c0		 test	 eax, eax
  001d6	0f 84 db 01 00
	00		 je	 $LN22@LCS_Read_S
$LN5@LCS_Read_S:

; 6991 :     {
; 6992 :         while (pLCSDEV->pFirstLCSIBH)

  001dc	48 8b 44 24 60	 mov	 rax, QWORD PTR pLCSDEV$[rsp]
  001e1	48 83 78 72 00	 cmp	 QWORD PTR [rax+114], 0
  001e6	0f 84 cb 01 00
	00		 je	 $LN6@LCS_Read_S

; 6993 :         {
; 6994 :             //
; 6995 :             if ( pLCSDEV->pFirstLCSIBH->iDataLen & 0x01 )

  001ec	48 8b 44 24 60	 mov	 rax, QWORD PTR pLCSDEV$[rsp]
  001f1	48 8b 40 72	 mov	 rax, QWORD PTR [rax+114]
  001f5	8b 40 0c	 mov	 eax, DWORD PTR [rax+12]
  001f8	83 e0 01	 and	 eax, 1
  001fb	85 c0		 test	 eax, eax
  001fd	74 0a		 je	 SHORT $LN23@LCS_Read_S

; 6996 :                 iFiller = 1;

  001ff	c7 44 24 78 01
	00 00 00	 mov	 DWORD PTR iFiller$[rsp], 1
  00207	eb 08		 jmp	 SHORT $LN24@LCS_Read_S
$LN23@LCS_Read_S:

; 6997 :             else
; 6998 :                 iFiller = 0;

  00209	c7 44 24 78 00
	00 00 00	 mov	 DWORD PTR iFiller$[rsp], 0
$LN24@LCS_Read_S:

; 6999 : 
; 7000 :             // Ensure the contents of the buffer will fit into the frame buffer
; 7001 :             if ((pLCSDEV->iFrameOffset +            // Current buffer Offset
; 7002 :                  pLCSDEV->pFirstLCSIBH->iDataLen +  // Size of inbound data
; 7003 :                  iFiller +                          // Size of filler
; 7004 :                  sizeof(pFrameSlot->hwOffset))      // Size of Frame terminator
; 7005 :               <= pLCSDEV->iMaxFrameBufferSize)      // Size of Frame buffer

  00211	48 8b 44 24 60	 mov	 rax, QWORD PTR pLCSDEV$[rsp]
  00216	0f b7 80 a2 00
	00 00		 movzx	 eax, WORD PTR [rax+162]
  0021d	48 8b 4c 24 60	 mov	 rcx, QWORD PTR pLCSDEV$[rsp]
  00222	48 8b 49 72	 mov	 rcx, QWORD PTR [rcx+114]
  00226	03 41 0c	 add	 eax, DWORD PTR [rcx+12]
  00229	03 44 24 78	 add	 eax, DWORD PTR iFiller$[rsp]
  0022d	48 98		 cdqe
  0022f	48 83 c0 02	 add	 rax, 2
  00233	48 8b 4c 24 60	 mov	 rcx, QWORD PTR pLCSDEV$[rsp]
  00238	0f b7 89 a4 00
	00 00		 movzx	 ecx, WORD PTR [rcx+164]
  0023f	48 3b c1	 cmp	 rax, rcx
  00242	0f 87 6a 01 00
	00		 ja	 $LN25@LCS_Read_S

; 7006 :             {
; 7007 :                 pLCSIBH = remove_lcs_buffer_from_chain( pLCSDEV );

  00248	48 8b 4c 24 60	 mov	 rcx, QWORD PTR pLCSDEV$[rsp]
  0024d	e8 00 00 00 00	 call	 remove_lcs_buffer_from_chain
  00252	48 89 84 24 88
	00 00 00	 mov	 QWORD PTR pLCSIBH$[rsp], rax

; 7008 : 
; 7009 :                 // Point to next available LCS Frame slot in our buffer...
; 7010 :                 // Copy the inbound frame into the frame buffer slot...
; 7011 :                 // Increment buffer offset to NEXT next-available-slot...
; 7012 :                 pFrameSlot = (PLCSHDR)( pLCSDEV->bFrameBuffer +

  0025a	48 8b 44 24 60	 mov	 rax, QWORD PTR pLCSDEV$[rsp]
  0025f	0f b7 80 a2 00
	00 00		 movzx	 eax, WORD PTR [rax+162]
  00266	48 8b 4c 24 60	 mov	 rcx, QWORD PTR pLCSDEV$[rsp]
  0026b	48 8d 84 01 a6
	00 00 00	 lea	 rax, QWORD PTR [rcx+rax+166]
  00273	48 89 84 24 a8
	00 00 00	 mov	 QWORD PTR pFrameSlot$[rsp], rax

; 7013 :                                         pLCSDEV->iFrameOffset );
; 7014 : 
; 7015 :                 memcpy( pFrameSlot, &pLCSIBH->bData, pLCSIBH->iDataLen );

  0027b	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR pLCSIBH$[rsp]
  00283	48 63 40 0c	 movsxd	 rax, DWORD PTR [rax+12]
  00287	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR pLCSIBH$[rsp]
  0028f	48 83 c1 10	 add	 rcx, 16
  00293	48 8b bc 24 a8
	00 00 00	 mov	 rdi, QWORD PTR pFrameSlot$[rsp]
  0029b	48 8b f1	 mov	 rsi, rcx
  0029e	48 8b c8	 mov	 rcx, rax
  002a1	f3 a4		 rep movsb

; 7016 : 
; 7017 :                 pLCSDEV->iFrameOffset += (U16) pLCSIBH->iDataLen;

  002a3	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR pLCSIBH$[rsp]
  002ab	0f b7 40 0c	 movzx	 eax, WORD PTR [rax+12]
  002af	48 8b 4c 24 60	 mov	 rcx, QWORD PTR pLCSDEV$[rsp]
  002b4	0f b7 89 a2 00
	00 00		 movzx	 ecx, WORD PTR [rcx+162]
  002bb	03 c8		 add	 ecx, eax
  002bd	8b c1		 mov	 eax, ecx
  002bf	48 8b 4c 24 60	 mov	 rcx, QWORD PTR pLCSDEV$[rsp]
  002c4	66 89 81 a2 00
	00 00		 mov	 WORD PTR [rcx+162], ax

; 7018 : 
; 7019 :                 if ( iFiller )

  002cb	83 7c 24 78 00	 cmp	 DWORD PTR iFiller$[rsp], 0
  002d0	74 50		 je	 SHORT $LN26@LCS_Read_S

; 7020 :                 {
; 7021 :                     // Point to the end of the inbound frame just copied to
; 7022 :                     // the frame buffer slot and add a filler byte to the end.
; 7023 :                     // Increment buffer offset to NEXT next-available-slot...
; 7024 :                     pFrameFiller = ( pLCSDEV->bFrameBuffer +

  002d2	48 8b 44 24 60	 mov	 rax, QWORD PTR pLCSDEV$[rsp]
  002d7	0f b7 80 a2 00
	00 00		 movzx	 eax, WORD PTR [rax+162]
  002de	48 8b 4c 24 60	 mov	 rcx, QWORD PTR pLCSDEV$[rsp]
  002e3	48 8d 84 01 a6
	00 00 00	 lea	 rax, QWORD PTR [rcx+rax+166]
  002eb	48 89 84 24 b0
	00 00 00	 mov	 QWORD PTR pFrameFiller$[rsp], rax

; 7025 :                                      pLCSDEV->iFrameOffset );
; 7026 : 
; 7027 :                     pFrameFiller[0] = 0;

  002f3	b8 01 00 00 00	 mov	 eax, 1
  002f8	48 6b c0 00	 imul	 rax, rax, 0
  002fc	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR pFrameFiller$[rsp]
  00304	c6 04 01 00	 mov	 BYTE PTR [rcx+rax], 0

; 7028 : 
; 7029 :                     pLCSDEV->iFrameOffset += 1;

  00308	48 8b 44 24 60	 mov	 rax, QWORD PTR pLCSDEV$[rsp]
  0030d	0f b7 80 a2 00
	00 00		 movzx	 eax, WORD PTR [rax+162]
  00314	ff c0		 inc	 eax
  00316	48 8b 4c 24 60	 mov	 rcx, QWORD PTR pLCSDEV$[rsp]
  0031b	66 89 81 a2 00
	00 00		 mov	 WORD PTR [rcx+162], ax
$LN26@LCS_Read_S:

; 7030 :                 }
; 7031 : 
; 7032 :                 // Store offset of next frame
; 7033 :                 if ( pLCSDEV->hwIctlSize )

  00322	48 8b 44 24 60	 mov	 rax, QWORD PTR pLCSDEV$[rsp]
  00327	0f b7 40 4f	 movzx	 eax, WORD PTR [rax+79]
  0032b	85 c0		 test	 eax, eax
  0032d	74 31		 je	 SHORT $LN27@LCS_Read_S

; 7034 :                     STORE_HW( pFrameSlot->hwOffset, ( pLCSDEV->iFrameOffset - pLCSDEV->hwIctlSize ) );

  0032f	48 8b 44 24 60	 mov	 rax, QWORD PTR pLCSDEV$[rsp]
  00334	0f b7 80 a2 00
	00 00		 movzx	 eax, WORD PTR [rax+162]
  0033b	48 8b 4c 24 60	 mov	 rcx, QWORD PTR pLCSDEV$[rsp]
  00340	0f b7 49 4f	 movzx	 ecx, WORD PTR [rcx+79]
  00344	2b c1		 sub	 eax, ecx
  00346	0f b7 c8	 movzx	 ecx, ax
  00349	e8 00 00 00 00	 call	 _byteswap_ushort
  0034e	48 8b 8c 24 a8
	00 00 00	 mov	 rcx, QWORD PTR pFrameSlot$[rsp]
  00356	0f b7 d0	 movzx	 edx, ax
  00359	e8 00 00 00 00	 call	 store_hw_noswap
  0035e	eb 21		 jmp	 SHORT $LN28@LCS_Read_S
$LN27@LCS_Read_S:

; 7035 :                 else
; 7036 :                     STORE_HW( pFrameSlot->hwOffset, pLCSDEV->iFrameOffset );

  00360	48 8b 44 24 60	 mov	 rax, QWORD PTR pLCSDEV$[rsp]
  00365	0f b7 88 a2 00
	00 00		 movzx	 ecx, WORD PTR [rax+162]
  0036c	e8 00 00 00 00	 call	 _byteswap_ushort
  00371	48 8b 8c 24 a8
	00 00 00	 mov	 rcx, QWORD PTR pFrameSlot$[rsp]
  00379	0f b7 d0	 movzx	 edx, ax
  0037c	e8 00 00 00 00	 call	 store_hw_noswap
$LN28@LCS_Read_S:

; 7037 : 
; 7038 :                 free_lcs_buffer( pLCSDEV, pLCSIBH );

  00381	48 8b 94 24 88
	00 00 00	 mov	 rdx, QWORD PTR pLCSIBH$[rsp]
  00389	48 8b 4c 24 60	 mov	 rcx, QWORD PTR pLCSDEV$[rsp]
  0038e	e8 00 00 00 00	 call	 free_lcs_buffer

; 7039 :                 pLCSIBH = NULL;

  00393	48 c7 84 24 88
	00 00 00 00 00
	00 00		 mov	 QWORD PTR pLCSIBH$[rsp], 0

; 7040 : 
; 7041 :                 pLCSDEV->fDataPending = 1;

  0039f	48 8b 44 24 60	 mov	 rax, QWORD PTR pLCSDEV$[rsp]
  003a4	8b 40 41	 mov	 eax, DWORD PTR [rax+65]
  003a7	83 c8 10	 or	 eax, 16
  003aa	48 8b 4c 24 60	 mov	 rcx, QWORD PTR pLCSDEV$[rsp]
  003af	89 41 41	 mov	 DWORD PTR [rcx+65], eax
$LN25@LCS_Read_S:

; 7042 :             }
; 7043 :         }

  003b2	e9 25 fe ff ff	 jmp	 $LN5@LCS_Read_S
$LN6@LCS_Read_S:
$LN22@LCS_Read_S:

; 7044 :     }
; 7045 : 
; 7046 :     // Point to the end of all buffered LCS Frames (where
; 7047 :     // the next Frame *would* go if there was one), and
; 7048 :     // mark the end of this batch of LCS Frames by setting
; 7049 :     // the "offset to NEXT frame" LCS Header field to zero
; 7050 :     // (a zero "next Frame offset" is like an "EOF" flag).
; 7051 :     if ( pLCSDEV->fDataPending )

  003b7	48 8b 44 24 60	 mov	 rax, QWORD PTR pLCSDEV$[rsp]
  003bc	8b 40 41	 mov	 eax, DWORD PTR [rax+65]
  003bf	c1 e8 04	 shr	 eax, 4
  003c2	83 e0 01	 and	 eax, 1
  003c5	85 c0		 test	 eax, eax
  003c7	74 53		 je	 SHORT $LN29@LCS_Read_S

; 7052 :     {
; 7053 :         pLCSHdr = (PLCSHDR)( pLCSDEV->bFrameBuffer +

  003c9	48 8b 44 24 60	 mov	 rax, QWORD PTR pLCSDEV$[rsp]
  003ce	0f b7 80 a2 00
	00 00		 movzx	 eax, WORD PTR [rax+162]
  003d5	48 8b 4c 24 60	 mov	 rcx, QWORD PTR pLCSDEV$[rsp]
  003da	48 8d 84 01 a6
	00 00 00	 lea	 rax, QWORD PTR [rcx+rax+166]
  003e2	48 89 84 24 b8
	00 00 00	 mov	 QWORD PTR pLCSHdr$[rsp], rax

; 7054 :                              pLCSDEV->iFrameOffset );
; 7055 :         STORE_HW( pLCSHdr->hwOffset, 0x0000 );

  003ea	33 c9		 xor	 ecx, ecx
  003ec	e8 00 00 00 00	 call	 _byteswap_ushort
  003f1	48 8b 8c 24 b8
	00 00 00	 mov	 rcx, QWORD PTR pLCSHdr$[rsp]
  003f9	0f b7 d0	 movzx	 edx, ax
  003fc	e8 00 00 00 00	 call	 store_hw_noswap

; 7056 :         pLCSDEV->iFrameOffset += 2;

  00401	48 8b 44 24 60	 mov	 rax, QWORD PTR pLCSDEV$[rsp]
  00406	0f b7 80 a2 00
	00 00		 movzx	 eax, WORD PTR [rax+162]
  0040d	83 c0 02	 add	 eax, 2
  00410	48 8b 4c 24 60	 mov	 rcx, QWORD PTR pLCSDEV$[rsp]
  00415	66 89 81 a2 00
	00 00		 mov	 WORD PTR [rcx+162], ax
$LN29@LCS_Read_S:

; 7057 :     }
; 7058 : 
; 7059 :     //
; 7060 :     if ( pLCSDEV->fPendingIctl )

  0041c	48 8b 44 24 60	 mov	 rax, QWORD PTR pLCSDEV$[rsp]
  00421	8b 40 5d	 mov	 eax, DWORD PTR [rax+93]
  00424	c1 e8 02	 shr	 eax, 2
  00427	83 e0 01	 and	 eax, 1
  0042a	85 c0		 test	 eax, eax
  0042c	74 64		 je	 SHORT $LN30@LCS_Read_S

; 7061 :     {
; 7062 :         // Calculate how much data we're going to be giving them.
; 7063 :         // Since 'iFrameOffset' points to the next available LCS
; 7064 :         // Frame slot in our buffer, the total amount of LCS Frame
; 7065 :         // data we have is exactly that amount. We give them two
; 7066 :         // extra bytes however so that they can optionally chase
; 7067 :         // the "hwOffset" field in each LCS Frame's LCS Header to
; 7068 :         // eventually reach our zero hwOffset "EOF" flag).
; 7069 :         iLength = pLCSDEV->iFrameOffset;

  0042e	48 8b 44 24 60	 mov	 rax, QWORD PTR pLCSDEV$[rsp]
  00433	0f b7 80 a2 00
	00 00		 movzx	 eax, WORD PTR [rax+162]
  0043a	89 44 24 6c	 mov	 DWORD PTR iLength$[rsp], eax

; 7070 : 
; 7071 :         //
; 7072 :         pLCSICTL = (PLCSICTL)&pLCSDEV->bFrameBuffer;

  0043e	48 8b 44 24 60	 mov	 rax, QWORD PTR pLCSDEV$[rsp]
  00443	48 05 a6 00 00
	00		 add	 rax, 166		; 000000a6H
  00449	48 89 84 24 80
	00 00 00	 mov	 QWORD PTR pLCSICTL$[rsp], rax

; 7073 :         hwDataSize = (U16) ( pLCSDEV->iFrameOffset - pLCSDEV->hwIctlSize );

  00451	48 8b 44 24 60	 mov	 rax, QWORD PTR pLCSDEV$[rsp]
  00456	0f b7 80 a2 00
	00 00		 movzx	 eax, WORD PTR [rax+162]
  0045d	48 8b 4c 24 60	 mov	 rcx, QWORD PTR pLCSDEV$[rsp]
  00462	0f b7 49 4f	 movzx	 ecx, WORD PTR [rcx+79]
  00466	2b c1		 sub	 eax, ecx
  00468	66 89 44 24 70	 mov	 WORD PTR hwDataSize$[rsp], ax

; 7074 :         if ( hwDataSize )

  0046d	0f b7 44 24 70	 movzx	 eax, WORD PTR hwDataSize$[rsp]
  00472	85 c0		 test	 eax, eax
  00474	74 1a		 je	 SHORT $LN32@LCS_Read_S

; 7075 :         {
; 7076 : //          iLength += sizeof(pLCSHdr->hwOffset);
; 7077 : //          hwDataSize += sizeof(pLCSHdr->hwOffset);
; 7078 :             STORE_HW( pLCSICTL, hwDataSize );

  00476	0f b7 4c 24 70	 movzx	 ecx, WORD PTR hwDataSize$[rsp]
  0047b	e8 00 00 00 00	 call	 _byteswap_ushort
  00480	0f b7 d0	 movzx	 edx, ax
  00483	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR pLCSICTL$[rsp]
  0048b	e8 00 00 00 00	 call	 store_hw_noswap
$LN32@LCS_Read_S:

; 7079 :         }
; 7080 :     }

  00490	eb 10		 jmp	 SHORT $LN31@LCS_Read_S
$LN30@LCS_Read_S:

; 7081 :     else
; 7082 :     {
; 7083 :         // Calculate how much data we're going to be giving them.
; 7084 :         // Since 'iFrameOffset' points to the next available LCS
; 7085 :         // Frame slot in our buffer, the total amount of LCS Frame
; 7086 :         // data we have is exactly that amount. We give them two
; 7087 :         // extra bytes however so that they can optionally chase
; 7088 :         // the "hwOffset" field in each LCS Frame's LCS Header to
; 7089 :         // eventually reach our zero hwOffset "EOF" flag).
; 7090 : //      iLength = pLCSDEV->iFrameOffset + sizeof(pLCSHdr->hwOffset);
; 7091 :         iLength = pLCSDEV->iFrameOffset;

  00492	48 8b 44 24 60	 mov	 rax, QWORD PTR pLCSDEV$[rsp]
  00497	0f b7 80 a2 00
	00 00		 movzx	 eax, WORD PTR [rax+162]
  0049e	89 44 24 6c	 mov	 DWORD PTR iLength$[rsp], eax
$LN31@LCS_Read_S:

; 7092 :     }
; 7093 : 
; 7094 :     // (calculate residual and set memcpy amount)
; 7095 : 
; 7096 :     // FIXME: we currently don't support data-chaining but
; 7097 :     // probably should if real LCS devices do (I was unable
; 7098 :     // to determine whether they do or not). -- Fish
; 7099 : 
; 7100 :     if (sCount < (U32)iLength)

  004a2	8b 44 24 6c	 mov	 eax, DWORD PTR iLength$[rsp]
  004a6	39 84 24 e8 00
	00 00		 cmp	 DWORD PTR sCount$[rsp], eax
  004ad	73 26		 jae	 SHORT $LN33@LCS_Read_S

; 7101 :     {
; 7102 :         *pMore     = 1;

  004af	48 8b 84 24 08
	01 00 00	 mov	 rax, QWORD PTR pMore$[rsp]
  004b7	c6 00 01	 mov	 BYTE PTR [rax], 1

; 7103 :         *pResidual = 0;

  004ba	48 8b 84 24 00
	01 00 00	 mov	 rax, QWORD PTR pResidual$[rsp]
  004c2	c7 00 00 00 00
	00		 mov	 DWORD PTR [rax], 0

; 7104 : 
; 7105 :         iLength = sCount;

  004c8	8b 84 24 e8 00
	00 00		 mov	 eax, DWORD PTR sCount$[rsp]
  004cf	89 44 24 6c	 mov	 DWORD PTR iLength$[rsp], eax

; 7106 : 
; 7107 :         // PROGRAMMING NOTE: As a result of the caller asking
; 7108 :         // for less data than we actually have available, the
; 7109 :         // remainder of their unread data they didn't ask for
; 7110 :         // will end up being silently discarded. Refer to the
; 7111 :         // other NOTEs and FIXME's sprinkled throughout this
; 7112 :         // function...
; 7113 :     }

  004d3	eb 25		 jmp	 SHORT $LN34@LCS_Read_S
$LN33@LCS_Read_S:

; 7114 :     else
; 7115 :     {
; 7116 :         *pMore      = 0;

  004d5	48 8b 84 24 08
	01 00 00	 mov	 rax, QWORD PTR pMore$[rsp]
  004dd	c6 00 00	 mov	 BYTE PTR [rax], 0

; 7117 :         *pResidual -= iLength;

  004e0	48 8b 84 24 00
	01 00 00	 mov	 rax, QWORD PTR pResidual$[rsp]
  004e8	8b 4c 24 6c	 mov	 ecx, DWORD PTR iLength$[rsp]
  004ec	8b 00		 mov	 eax, DWORD PTR [rax]
  004ee	2b c1		 sub	 eax, ecx
  004f0	48 8b 8c 24 00
	01 00 00	 mov	 rcx, QWORD PTR pResidual$[rsp]
  004f8	89 01		 mov	 DWORD PTR [rcx], eax
$LN34@LCS_Read_S:

; 7118 :     }
; 7119 : 
; 7120 :     *pUnitStat = CSW_CE | CSW_DE;

  004fa	48 8b 84 24 f8
	00 00 00	 mov	 rax, QWORD PTR pUnitStat$[rsp]
  00502	c6 00 0c	 mov	 BYTE PTR [rax], 12

; 7121 : 
; 7122 :     memcpy( pIOBuf, pLCSDEV->bFrameBuffer, iLength );

  00505	48 63 44 24 6c	 movsxd	 rax, DWORD PTR iLength$[rsp]
  0050a	48 8b 4c 24 60	 mov	 rcx, QWORD PTR pLCSDEV$[rsp]
  0050f	48 81 c1 a6 00
	00 00		 add	 rcx, 166		; 000000a6H
  00516	48 8b bc 24 f0
	00 00 00	 mov	 rdi, QWORD PTR pIOBuf$[rsp]
  0051e	48 8b f1	 mov	 rsi, rcx
  00521	48 8b c8	 mov	 rcx, rax
  00524	f3 a4		 rep movsb

; 7123 : 
; 7124 :     // Display up to pLCSBLK->iTraceLen bytes of the data going to the guest, if debug is active
; 7125 :     if (pLCSDEV->pLCSBLK->fDebug)

  00526	48 8b 44 24 60	 mov	 rax, QWORD PTR pLCSDEV$[rsp]
  0052b	48 8b 40 08	 mov	 rax, QWORD PTR [rax+8]
  0052f	8b 40 18	 mov	 eax, DWORD PTR [rax+24]
  00532	83 e0 01	 and	 eax, 1
  00535	85 c0		 test	 eax, eax
  00537	0f 84 d1 01 00
	00		 je	 $LN35@LCS_Read_S

; 7126 :     {
; 7127 :         // "%1d:%04X %s: Present data of size %d bytes to guest"
; 7128 :         WRMSG(HHC00982, "D", SSID_TO_LCSS(pDEVBLK->ssid), pDEVBLK->devnum, pDEVBLK->typname, (int)iLength );

  0053d	48 8b 84 24 e0
	00 00 00	 mov	 rax, QWORD PTR pDEVBLK$[rsp]
  00545	0f b7 40 48	 movzx	 eax, WORD PTR [rax+72]
  00549	89 84 24 90 00
	00 00		 mov	 DWORD PTR tv288[rsp], eax
  00550	48 8b 8c 24 e0
	00 00 00	 mov	 rcx, QWORD PTR pDEVBLK$[rsp]
  00558	0f b7 49 44	 movzx	 ecx, WORD PTR [rcx+68]
  0055c	d1 f9		 sar	 ecx, 1
  0055e	89 8c 24 94 00
	00 00		 mov	 DWORD PTR tv292[rsp], ecx
  00565	b9 01 00 00 00	 mov	 ecx, 1
  0056a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  00570	8b 4c 24 6c	 mov	 ecx, DWORD PTR iLength$[rsp]
  00574	89 4c 24 50	 mov	 DWORD PTR [rsp+80], ecx
  00578	48 8b 8c 24 e0
	00 00 00	 mov	 rcx, QWORD PTR pDEVBLK$[rsp]
  00580	48 8b 49 50	 mov	 rcx, QWORD PTR [rcx+80]
  00584	48 89 4c 24 48	 mov	 QWORD PTR [rsp+72], rcx
  00589	8b 8c 24 90 00
	00 00		 mov	 ecx, DWORD PTR tv288[rsp]
  00590	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  00594	8b 8c 24 94 00
	00 00		 mov	 ecx, DWORD PTR tv292[rsp]
  0059b	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  0059f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG175481
  005a6	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  005ab	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG175482
  005b2	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  005b7	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  005bc	41 b9 03 00 00
	00		 mov	 r9d, 3
  005c2	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG175483
  005c9	ba d8 1b 00 00	 mov	 edx, 7128		; 00001bd8H
  005ce	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG175484
  005d5	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 7129 :         if (pLCSDEV->pLCSBLK->iTraceLen)

  005db	48 8b 44 24 60	 mov	 rax, QWORD PTR pLCSDEV$[rsp]
  005e0	48 8b 40 08	 mov	 rax, QWORD PTR [rax+8]
  005e4	83 78 28 00	 cmp	 DWORD PTR [rax+40], 0
  005e8	0f 84 20 01 00
	00		 je	 $LN36@LCS_Read_S

; 7130 :         {
; 7131 :             iTraceLen = iLength;

  005ee	8b 44 24 6c	 mov	 eax, DWORD PTR iLength$[rsp]
  005f2	89 44 24 74	 mov	 DWORD PTR iTraceLen$[rsp], eax

; 7132 :             if (iTraceLen > pLCSDEV->pLCSBLK->iTraceLen)

  005f6	48 8b 44 24 60	 mov	 rax, QWORD PTR pLCSDEV$[rsp]
  005fb	48 8b 40 08	 mov	 rax, QWORD PTR [rax+8]
  005ff	8b 40 28	 mov	 eax, DWORD PTR [rax+40]
  00602	39 44 24 74	 cmp	 DWORD PTR iTraceLen$[rsp], eax
  00606	0f 8e cc 00 00
	00		 jle	 $LN37@LCS_Read_S

; 7133 :             {
; 7134 :                 iTraceLen = pLCSDEV->pLCSBLK->iTraceLen;

  0060c	48 8b 44 24 60	 mov	 rax, QWORD PTR pLCSDEV$[rsp]
  00611	48 8b 40 08	 mov	 rax, QWORD PTR [rax+8]
  00615	8b 40 28	 mov	 eax, DWORD PTR [rax+40]
  00618	89 44 24 74	 mov	 DWORD PTR iTraceLen$[rsp], eax

; 7135 :                 // HHC00980 "%1d:%04X %s: Data of size %d bytes displayed, data of size %d bytes not displayed"
; 7136 :                 WRMSG(HHC00980, "D", SSID_TO_LCSS(pDEVBLK->ssid), pDEVBLK->devnum, pDEVBLK->typname,

  0061c	8b 44 24 74	 mov	 eax, DWORD PTR iTraceLen$[rsp]
  00620	8b 4c 24 6c	 mov	 ecx, DWORD PTR iLength$[rsp]
  00624	2b c8		 sub	 ecx, eax
  00626	8b c1		 mov	 eax, ecx
  00628	89 84 24 98 00
	00 00		 mov	 DWORD PTR tv311[rsp], eax
  0062f	48 8b 8c 24 e0
	00 00 00	 mov	 rcx, QWORD PTR pDEVBLK$[rsp]
  00637	0f b7 49 48	 movzx	 ecx, WORD PTR [rcx+72]
  0063b	89 8c 24 9c 00
	00 00		 mov	 DWORD PTR tv317[rsp], ecx
  00642	48 8b 94 24 e0
	00 00 00	 mov	 rdx, QWORD PTR pDEVBLK$[rsp]
  0064a	0f b7 52 44	 movzx	 edx, WORD PTR [rdx+68]
  0064e	d1 fa		 sar	 edx, 1
  00650	89 94 24 a0 00
	00 00		 mov	 DWORD PTR tv321[rsp], edx
  00657	b9 01 00 00 00	 mov	 ecx, 1
  0065c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  00662	8b 8c 24 98 00
	00 00		 mov	 ecx, DWORD PTR tv311[rsp]
  00669	89 4c 24 58	 mov	 DWORD PTR [rsp+88], ecx
  0066d	8b 4c 24 74	 mov	 ecx, DWORD PTR iTraceLen$[rsp]
  00671	89 4c 24 50	 mov	 DWORD PTR [rsp+80], ecx
  00675	48 8b 8c 24 e0
	00 00 00	 mov	 rcx, QWORD PTR pDEVBLK$[rsp]
  0067d	48 8b 49 50	 mov	 rcx, QWORD PTR [rcx+80]
  00681	48 89 4c 24 48	 mov	 QWORD PTR [rsp+72], rcx
  00686	8b 8c 24 9c 00
	00 00		 mov	 ecx, DWORD PTR tv317[rsp]
  0068d	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  00691	8b 8c 24 a0 00
	00 00		 mov	 ecx, DWORD PTR tv321[rsp]
  00698	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  0069c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG175487
  006a3	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  006a8	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG175488
  006af	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  006b4	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  006b9	41 b9 03 00 00
	00		 mov	 r9d, 3
  006bf	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG175489
  006c6	ba e1 1b 00 00	 mov	 edx, 7137		; 00001be1H
  006cb	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG175490
  006d2	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg
$LN37@LCS_Read_S:

; 7137 :                                      iTraceLen, (int)(iLength - iTraceLen) );
; 7138 :             }
; 7139 :             net_data_trace( pDEVBLK, pIOBuf, iTraceLen, TO_GUEST, 'D', "data", 0 );

  006d8	c7 44 24 30 00
	00 00 00	 mov	 DWORD PTR [rsp+48], 0
  006e0	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG175491
  006e7	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  006ec	c6 44 24 20 44	 mov	 BYTE PTR [rsp+32], 68	; 00000044H
  006f1	41 b1 3e	 mov	 r9b, 62			; 0000003eH
  006f4	44 8b 44 24 74	 mov	 r8d, DWORD PTR iTraceLen$[rsp]
  006f9	48 8b 94 24 f0
	00 00 00	 mov	 rdx, QWORD PTR pIOBuf$[rsp]
  00701	48 8b 8c 24 e0
	00 00 00	 mov	 rcx, QWORD PTR pDEVBLK$[rsp]
  00709	e8 00 00 00 00	 call	 net_data_trace
$LN36@LCS_Read_S:
$LN35@LCS_Read_S:
$LN9@LCS_Read_S:

; 7140 :         }
; 7141 :     }
; 7142 : 
; 7143 :     // Reset frame buffer to empty...
; 7144 : 
; 7145 :     // PROGRAMMING NOTE: even though not all available data
; 7146 :     // may have been read by the guest, we don't currently
; 7147 :     // support data-chaining. Thus any unread data is always
; 7148 :     // discarded by resetting all of the iFrameOffset,
; 7149 :     // fDataPending and fReplyPending fields to 0 so that the
; 7150 :     // next read always grabs a new batch of LCS Frames starting
; 7151 :     // at the very beginning of our frame buffer again. (I was
; 7152 :     // unable to determine whether real LCS devices support
; 7153 :     // data-chaining or not, but if they do we should fix this).
; 7154 : 
; 7155 :     PTT_DEBUG( "RSNA empty buffer ", 000, pDEVBLK->devnum, -1 );

  0070e	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_pttclass
  00715	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00718	48 25 00 00 02
	00		 and	 rax, 131072		; 00020000H
  0071e	48 85 c0	 test	 rax, rax
  00721	74 42		 je	 SHORT $LN38@LCS_Read_S
  00723	48 8b 84 24 e0
	00 00 00	 mov	 rax, QWORD PTR pDEVBLK$[rsp]
  0072b	0f b7 40 48	 movzx	 eax, WORD PTR [rax+72]
  0072f	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR [rsp+48], 0
  00738	48 c7 44 24 28
	ff ff ff ff	 mov	 QWORD PTR [rsp+40], -1
  00741	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG175493
  00748	48 89 4c 24 20	 mov	 QWORD PTR [rsp+32], rcx
  0074d	44 8b c8	 mov	 r9d, eax
  00750	45 33 c0	 xor	 r8d, r8d
  00753	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG175494
  0075a	b9 00 00 02 00	 mov	 ecx, 131072		; 00020000H
  0075f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ptt_pthread_trace
$LN38@LCS_Read_S:
  00765	33 c0		 xor	 eax, eax
  00767	85 c0		 test	 eax, eax
  00769	75 a3		 jne	 SHORT $LN9@LCS_Read_S

; 7156 :     pLCSDEV->iFrameOffset  = 0;

  0076b	33 c0		 xor	 eax, eax
  0076d	48 8b 4c 24 60	 mov	 rcx, QWORD PTR pLCSDEV$[rsp]
  00772	66 89 81 a2 00
	00 00		 mov	 WORD PTR [rcx+162], ax

; 7157 :     pLCSDEV->fReplyPending = 0;

  00779	48 8b 44 24 60	 mov	 rax, QWORD PTR pLCSDEV$[rsp]
  0077e	8b 40 41	 mov	 eax, DWORD PTR [rax+65]
  00781	83 e0 f7	 and	 eax, -9			; fffffff7H
  00784	48 8b 4c 24 60	 mov	 rcx, QWORD PTR pLCSDEV$[rsp]
  00789	89 41 41	 mov	 DWORD PTR [rcx+65], eax

; 7158 :     pLCSDEV->fDataPending  = 0;

  0078c	48 8b 44 24 60	 mov	 rax, QWORD PTR pLCSDEV$[rsp]
  00791	8b 40 41	 mov	 eax, DWORD PTR [rax+65]
  00794	83 e0 ef	 and	 eax, -17		; ffffffefH
  00797	48 8b 4c 24 60	 mov	 rcx, QWORD PTR pLCSDEV$[rsp]
  0079c	89 41 41	 mov	 DWORD PTR [rcx+65], eax

; 7159 :     pLCSDEV->fPendingIctl = 0;

  0079f	48 8b 44 24 60	 mov	 rax, QWORD PTR pLCSDEV$[rsp]
  007a4	8b 40 5d	 mov	 eax, DWORD PTR [rax+93]
  007a7	83 e0 fb	 and	 eax, -5			; fffffffbH
  007aa	48 8b 4c 24 60	 mov	 rcx, QWORD PTR pLCSDEV$[rsp]
  007af	89 41 5d	 mov	 DWORD PTR [rcx+93], eax
$LN12@LCS_Read_S:

; 7160 : 
; 7161 : //??    PTT_DEBUG(        "REL  DevDataLock  ", 000, pDEVBLK->devnum, -1 );
; 7162 : //??    release_lock( &pLCSDEV->DevDataLock );
; 7163 : 
; 7164 :     PTT_DEBUG( "RSNA: EXIT        ", 000, pDEVBLK->devnum, -1 );

  007b2	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_pttclass
  007b9	48 8b 00	 mov	 rax, QWORD PTR [rax]
  007bc	48 25 00 00 02
	00		 and	 rax, 131072		; 00020000H
  007c2	48 85 c0	 test	 rax, rax
  007c5	74 42		 je	 SHORT $LN39@LCS_Read_S
  007c7	48 8b 84 24 e0
	00 00 00	 mov	 rax, QWORD PTR pDEVBLK$[rsp]
  007cf	0f b7 40 48	 movzx	 eax, WORD PTR [rax+72]
  007d3	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR [rsp+48], 0
  007dc	48 c7 44 24 28
	ff ff ff ff	 mov	 QWORD PTR [rsp+40], -1
  007e5	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG175496
  007ec	48 89 4c 24 20	 mov	 QWORD PTR [rsp+32], rcx
  007f1	44 8b c8	 mov	 r9d, eax
  007f4	45 33 c0	 xor	 r8d, r8d
  007f7	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG175497
  007fe	b9 00 00 02 00	 mov	 ecx, 131072		; 00020000H
  00803	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ptt_pthread_trace
$LN39@LCS_Read_S:
  00809	33 c0		 xor	 eax, eax
  0080b	85 c0		 test	 eax, eax
  0080d	75 a3		 jne	 SHORT $LN12@LCS_Read_S

; 7165 : }   // End of  LCS_Read_SNA

  0080f	48 81 c4 c8 00
	00 00		 add	 rsp, 200		; 000000c8H
  00816	5f		 pop	 rdi
  00817	5e		 pop	 rsi
  00818	c3		 ret	 0
LCS_Read_SNA ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\ctc_lcs.c
_TEXT	SEGMENT
bMode$ = 96
i$ = 100
tv130 = 104
iDiscTrace$ = 108
iTraceLen$ = 112
iKernBuff$ = 116
iIOBuff$ = 120
argv$ = 128
c$1 = 136
saw_conf$ = 140
tv148 = 144
tv167 = 148
tv171 = 152
tv205 = 156
tv209 = 160
tv260 = 164
tv264 = 168
tv286 = 172
tv290 = 176
tv316 = 180
tv352 = 184
tv376 = 188
tv380 = 192
tv406 = 196
tv410 = 200
addr$ = 204
tv433 = 208
tv437 = 212
tv470 = 216
tv474 = 220
tv144 = 224
iOpt$2 = 228
saw_if$ = 232
argn$ = 240
mac$ = 8432
__$ArrayPad$ = 8440
pDEVBLK$ = 8480
pLCSBLK$ = 8488
argc$ = 8496
argx$ = 8504
ParseArgs PROC

; 3260 : {

  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	56		 push	 rsi
  00015	57		 push	 rdi
  00016	b8 08 21 00 00	 mov	 eax, 8456		; 00002108H
  0001b	e8 00 00 00 00	 call	 __chkstk
  00020	48 2b e0	 sub	 rsp, rax
  00023	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  0002a	48 33 c4	 xor	 rax, rsp
  0002d	48 89 84 24 f8
	20 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 3261 :     struct in_addr  addr;               // Work area for addresses
; 3262 :     MAC             mac;
; 3263 :     int             i;
; 3264 :     int             iDiscTrace;
; 3265 :     int             iTraceLen;
; 3266 : #if defined(OPTION_W32_CTCI)
; 3267 :     int             iKernBuff;
; 3268 :     int             iIOBuff;
; 3269 : #endif
; 3270 :     char            *argn[MAX_ARGS];
; 3271 :     char            **argv = argn;

  00035	48 8d 84 24 f0
	00 00 00	 lea	 rax, QWORD PTR argn$[rsp]
  0003d	48 89 84 24 80
	00 00 00	 mov	 QWORD PTR argv$[rsp], rax

; 3272 :     int             saw_if = 0;        /* -x (or --if) specified */

  00045	c7 84 24 e8 00
	00 00 00 00 00
	00		 mov	 DWORD PTR saw_if$[rsp], 0

; 3273 :     int             saw_conf = 0;      /* Other configuration flags present */

  00050	c7 84 24 8c 00
	00 00 00 00 00
	00		 mov	 DWORD PTR saw_conf$[rsp], 0

; 3274 :     BYTE            bMode = LCSDEV_MODE_IP;      /* Default mode is IP */

  0005b	c6 44 24 60 01	 mov	 BYTE PTR bMode$[rsp], 1

; 3275 : 
; 3276 : 
; 3277 :     // Build a copy of the argv list.
; 3278 :     // getopt() and getopt_long() expect argv[0] to be a program name.
; 3279 :     // We need to shift the arguments and insert a dummy argv[0].
; 3280 :     if (argc > (MAX_ARGS-1))

  00060	81 bc 24 30 21
	00 00 ff 03 00
	00		 cmp	 DWORD PTR argc$[rsp], 1023 ; 000003ffH
  0006b	7e 0b		 jle	 SHORT $LN9@ParseArgs

; 3281 :         argc = (MAX_ARGS-1);

  0006d	c7 84 24 30 21
	00 00 ff 03 00
	00		 mov	 DWORD PTR argc$[rsp], 1023 ; 000003ffH
$LN9@ParseArgs:

; 3282 :     for (i=0; i < argc; i++)

  00078	c7 44 24 64 00
	00 00 00	 mov	 DWORD PTR i$[rsp], 0
  00080	eb 0a		 jmp	 SHORT $LN4@ParseArgs
$LN2@ParseArgs:
  00082	8b 44 24 64	 mov	 eax, DWORD PTR i$[rsp]
  00086	ff c0		 inc	 eax
  00088	89 44 24 64	 mov	 DWORD PTR i$[rsp], eax
$LN4@ParseArgs:
  0008c	8b 84 24 30 21
	00 00		 mov	 eax, DWORD PTR argc$[rsp]
  00093	39 44 24 64	 cmp	 DWORD PTR i$[rsp], eax
  00097	7d 24		 jge	 SHORT $LN3@ParseArgs

; 3283 :         argn[i+1] = argx[i];

  00099	48 63 44 24 64	 movsxd	 rax, DWORD PTR i$[rsp]
  0009e	8b 4c 24 64	 mov	 ecx, DWORD PTR i$[rsp]
  000a2	ff c1		 inc	 ecx
  000a4	48 63 c9	 movsxd	 rcx, ecx
  000a7	48 8b 94 24 38
	21 00 00	 mov	 rdx, QWORD PTR argx$[rsp]
  000af	48 8b 04 c2	 mov	 rax, QWORD PTR [rdx+rax*8]
  000b3	48 89 84 cc f0
	00 00 00	 mov	 QWORD PTR argn$[rsp+rcx*8], rax
  000bb	eb c5		 jmp	 SHORT $LN2@ParseArgs
$LN3@ParseArgs:

; 3284 :     argc++;

  000bd	8b 84 24 30 21
	00 00		 mov	 eax, DWORD PTR argc$[rsp]
  000c4	ff c0		 inc	 eax
  000c6	89 84 24 30 21
	00 00		 mov	 DWORD PTR argc$[rsp], eax

; 3285 :     argn[0] = pDEVBLK->typname;

  000cd	b8 08 00 00 00	 mov	 eax, 8
  000d2	48 6b c0 00	 imul	 rax, rax, 0
  000d6	48 8b 8c 24 20
	21 00 00	 mov	 rcx, QWORD PTR pDEVBLK$[rsp]
  000de	48 8b 49 50	 mov	 rcx, QWORD PTR [rcx+80]
  000e2	48 89 8c 04 f0
	00 00 00	 mov	 QWORD PTR argn$[rsp+rax], rcx

; 3286 : 
; 3287 :     // Housekeeping
; 3288 :     memset( &addr, 0, sizeof( struct in_addr ) );

  000ea	48 8d 84 24 cc
	00 00 00	 lea	 rax, QWORD PTR addr$[rsp]
  000f2	48 8b f8	 mov	 rdi, rax
  000f5	33 c0		 xor	 eax, eax
  000f7	b9 04 00 00 00	 mov	 ecx, 4
  000fc	f3 aa		 rep stosb

; 3289 : 
; 3290 :     // Set some initial defaults
; 3291 :     pLCSBLK->pszTUNDevice   = strdup( DEF_NETDEV );

  000fe	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_init_sysblk_netdev
  00104	48 8b c8	 mov	 rcx, rax
  00107	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_strdup
  0010d	48 8b 8c 24 28
	21 00 00	 mov	 rcx, QWORD PTR pLCSBLK$[rsp]
  00115	48 89 01	 mov	 QWORD PTR [rcx], rax

; 3292 :     pLCSBLK->pszOATFilename = NULL;

  00118	48 8b 84 24 28
	21 00 00	 mov	 rax, QWORD PTR pLCSBLK$[rsp]
  00120	48 c7 40 08 00
	00 00 00	 mov	 QWORD PTR [rax+8], 0

; 3293 :     pLCSBLK->pszIPAddress   = NULL;

  00128	48 8b 84 24 28
	21 00 00	 mov	 rax, QWORD PTR pLCSBLK$[rsp]
  00130	48 c7 40 10 00
	00 00 00	 mov	 QWORD PTR [rax+16], 0

; 3294 : #if defined( OPTION_W32_CTCI )
; 3295 :     pLCSBLK->iKernBuff = DEF_CAPTURE_BUFFSIZE;

  00138	48 8b 84 24 28
	21 00 00	 mov	 rax, QWORD PTR pLCSBLK$[rsp]
  00140	c7 40 20 00 00
	10 00		 mov	 DWORD PTR [rax+32], 1048576 ; 00100000H

; 3296 :     pLCSBLK->iIOBuff   = DEF_PACKET_BUFFSIZE;

  00147	48 8b 84 24 28
	21 00 00	 mov	 rax, QWORD PTR pLCSBLK$[rsp]
  0014f	c7 40 24 00 00
	01 00		 mov	 DWORD PTR [rax+36], 65536 ; 00010000H

; 3297 : #endif
; 3298 : 
; 3299 :     // Initialize getopt's counter. This is necessary in the case
; 3300 :     // that getopt was used previously for another device.
; 3301 :     OPTRESET();
; 3302 :     optind = 0;

  00156	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_optind
  0015d	c7 00 00 00 00
	00		 mov	 DWORD PTR [rax], 0
$LN5@ParseArgs:

; 3303 : 
; 3304 :     // Parse any optional arguments
; 3305 :     while (1)

  00163	33 c0		 xor	 eax, eax
  00165	83 f8 01	 cmp	 eax, 1
  00168	0f 84 a7 08 00
	00		 je	 $LN6@ParseArgs

; 3306 :     {
; 3307 :         int     c;
; 3308 : 
; 3309 : #if defined( OPTION_W32_CTCI )
; 3310 :   #define  LCS_OPTSTRING    "e:n:m:o:s:t:dk:i:w"
; 3311 : #else
; 3312 :   #define  LCS_OPTSTRING    "e:n:x:m:o:s:t:d"
; 3313 : #endif
; 3314 : #if defined( HAVE_GETOPT_LONG )
; 3315 :         int     iOpt;
; 3316 : 
; 3317 :         static struct option options[] =
; 3318 :         {
; 3319 :             { "mode",   required_argument, NULL, 'e' },
; 3320 :             { "dev",    required_argument, NULL, 'n' },
; 3321 : #if !defined(OPTION_W32_CTCI)
; 3322 :             { "if",     required_argument, NULL, 'x' },
; 3323 : #endif /*!defined(OPTION_W32_CTCI)*/
; 3324 :             { "mac",    required_argument, NULL, 'm' },
; 3325 :             { "oat",    required_argument, NULL, 'o' },
; 3326 :             { "distrc", required_argument, NULL, 's' },
; 3327 :             { "maxtrc", required_argument, NULL, 't' },
; 3328 :             { "debug",  no_argument,       NULL, 'd' },
; 3329 : #if defined( OPTION_W32_CTCI )
; 3330 :             { "kbuff",  required_argument, NULL, 'k' },
; 3331 :             { "ibuff",  required_argument, NULL, 'i' },
; 3332 :             { "swrite", no_argument,       NULL, 'w' },
; 3333 : #endif
; 3334 :             { NULL,     0,                 NULL,  0  }
; 3335 :         };
; 3336 : 
; 3337 :         c = getopt_long( argc, argv, LCS_OPTSTRING, options, &iOpt );

  0016e	48 8d 84 24 e4
	00 00 00	 lea	 rax, QWORD PTR iOpt$2[rsp]
  00176	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  0017b	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:?options@?3??ParseArgs@@9@9
  00182	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG172726
  00189	48 8b 94 24 80
	00 00 00	 mov	 rdx, QWORD PTR argv$[rsp]
  00191	8b 8c 24 30 21
	00 00		 mov	 ecx, DWORD PTR argc$[rsp]
  00198	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_getopt_long
  0019e	89 84 24 88 00
	00 00		 mov	 DWORD PTR c$1[rsp], eax

; 3338 : 
; 3339 : #else /* defined( HAVE_GETOPT_LONG ) */
; 3340 : 
; 3341 :         c = getopt( argc, argv, LCS_OPTSTRING );
; 3342 : 
; 3343 : #endif /* defined( HAVE_GETOPT_LONG ) */
; 3344 : 
; 3345 :         if (c == -1)

  001a5	83 bc 24 88 00
	00 00 ff	 cmp	 DWORD PTR c$1[rsp], -1
  001ad	75 05		 jne	 SHORT $LN10@ParseArgs

; 3346 :             break;

  001af	e9 61 08 00 00	 jmp	 $LN6@ParseArgs
$LN10@ParseArgs:

; 3347 : 
; 3348 :         switch (c)

  001b4	8b 84 24 88 00
	00 00		 mov	 eax, DWORD PTR c$1[rsp]
  001bb	89 44 24 68	 mov	 DWORD PTR tv130[rsp], eax
  001bf	8b 44 24 68	 mov	 eax, DWORD PTR tv130[rsp]
  001c3	83 e8 64	 sub	 eax, 100		; 00000064H
  001c6	89 44 24 68	 mov	 DWORD PTR tv130[rsp], eax
  001ca	83 7c 24 68 13	 cmp	 DWORD PTR tv130[rsp], 19
  001cf	0f 87 3b 08 00
	00		 ja	 $LN36@ParseArgs
  001d5	48 63 44 24 68	 movsxd	 rax, DWORD PTR tv130[rsp]
  001da	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__ImageBase
  001e1	8b 84 81 00 00
	00 00		 mov	 eax, DWORD PTR $LN45@ParseArgs[rcx+rax*4]
  001e8	48 03 c1	 add	 rax, rcx
  001eb	ff e0		 jmp	 rax
$LN11@ParseArgs:

; 3349 :         {
; 3350 : 
; 3351 :         case 'e':  /* Mode */
; 3352 :             if (strcmp( optarg, "SNA" ) == 0 )

  001ed	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG172731
  001f4	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_optarg
  001fb	48 8b 08	 mov	 rcx, QWORD PTR [rax]
  001fe	e8 00 00 00 00	 call	 strcmp
  00203	85 c0		 test	 eax, eax
  00205	75 0a		 jne	 SHORT $LN12@ParseArgs

; 3353 :             {
; 3354 :                 bMode = LCSDEV_MODE_SNA;      /* Mode is SNA */

  00207	c6 44 24 60 02	 mov	 BYTE PTR bMode$[rsp], 2

; 3355 :             }

  0020c	e9 df 00 00 00	 jmp	 $LN13@ParseArgs
$LN12@ParseArgs:

; 3356 :             else if (strcmp( optarg, "IP" ) == 0 )

  00211	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG172734
  00218	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_optarg
  0021f	48 8b 08	 mov	 rcx, QWORD PTR [rax]
  00222	e8 00 00 00 00	 call	 strcmp
  00227	85 c0		 test	 eax, eax
  00229	75 0a		 jne	 SHORT $LN14@ParseArgs

; 3357 :             {
; 3358 :                 bMode = LCSDEV_MODE_IP;       /* Mode is IP (the default) */

  0022b	c6 44 24 60 01	 mov	 BYTE PTR bMode$[rsp], 1

; 3359 :             }

  00230	e9 bb 00 00 00	 jmp	 $LN15@ParseArgs
$LN14@ParseArgs:

; 3360 :             else
; 3361 :             {
; 3362 :                 // "%1d:%04X CTC: option %s value %s invalid"
; 3363 :                 WRMSG( HHC00916, "E", SSID_TO_LCSS(pDEVBLK->ssid), pDEVBLK->devnum, pDEVBLK->typname,

  00235	48 8b 84 24 20
	21 00 00	 mov	 rax, QWORD PTR pDEVBLK$[rsp]
  0023d	0f b7 40 48	 movzx	 eax, WORD PTR [rax+72]
  00241	89 84 24 e0 00
	00 00		 mov	 DWORD PTR tv144[rsp], eax
  00248	48 8b 8c 24 20
	21 00 00	 mov	 rcx, QWORD PTR pDEVBLK$[rsp]
  00250	0f b7 49 44	 movzx	 ecx, WORD PTR [rcx+68]
  00254	d1 f9		 sar	 ecx, 1
  00256	89 8c 24 90 00
	00 00		 mov	 DWORD PTR tv148[rsp], ecx
  0025d	b9 01 00 00 00	 mov	 ecx, 1
  00262	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  00268	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_optarg
  0026f	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  00272	48 89 4c 24 58	 mov	 QWORD PTR [rsp+88], rcx
  00277	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG172735
  0027e	48 89 4c 24 50	 mov	 QWORD PTR [rsp+80], rcx
  00283	48 8b 8c 24 20
	21 00 00	 mov	 rcx, QWORD PTR pDEVBLK$[rsp]
  0028b	48 8b 49 50	 mov	 rcx, QWORD PTR [rcx+80]
  0028f	48 89 4c 24 48	 mov	 QWORD PTR [rsp+72], rcx
  00294	8b 8c 24 e0 00
	00 00		 mov	 ecx, DWORD PTR tv144[rsp]
  0029b	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  0029f	8b 8c 24 90 00
	00 00		 mov	 ecx, DWORD PTR tv148[rsp]
  002a6	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  002aa	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG172736
  002b1	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  002b6	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG172737
  002bd	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  002c2	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  002c7	41 b9 03 00 00
	00		 mov	 r9d, 3
  002cd	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG172738
  002d4	ba 24 0d 00 00	 mov	 edx, 3364		; 00000d24H
  002d9	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG172739
  002e0	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 3364 :                        "device mode", optarg );
; 3365 :                 return -1;

  002e6	b8 ff ff ff ff	 mov	 eax, -1
  002eb	e9 4e 0a 00 00	 jmp	 $LN1@ParseArgs
$LN15@ParseArgs:
$LN13@ParseArgs:

; 3366 :             }
; 3367 :             break;

  002f0	e9 1b 07 00 00	 jmp	 $LN7@ParseArgs
$LN16@ParseArgs:

; 3368 : 
; 3369 :         case 'n':
; 3370 : 
; 3371 :             if (strlen( optarg ) > sizeof( pDEVBLK->filename ) - 1)

  002f5	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_optarg
  002fc	48 8b 08	 mov	 rcx, QWORD PTR [rax]
  002ff	e8 00 00 00 00	 call	 strlen
  00304	48 3d 04 01 00
	00		 cmp	 rax, 260		; 00000104H
  0030a	0f 86 bb 00 00
	00		 jbe	 $LN17@ParseArgs

; 3372 :             {
; 3373 :                 // "%1d:%04X CTC: option %s value %s invalid"
; 3374 :                 WRMSG( HHC00916, "E", SSID_TO_LCSS(pDEVBLK->ssid), pDEVBLK->devnum, pDEVBLK->typname,

  00310	48 8b 84 24 20
	21 00 00	 mov	 rax, QWORD PTR pDEVBLK$[rsp]
  00318	0f b7 40 48	 movzx	 eax, WORD PTR [rax+72]
  0031c	89 84 24 94 00
	00 00		 mov	 DWORD PTR tv167[rsp], eax
  00323	48 8b 8c 24 20
	21 00 00	 mov	 rcx, QWORD PTR pDEVBLK$[rsp]
  0032b	0f b7 49 44	 movzx	 ecx, WORD PTR [rcx+68]
  0032f	d1 f9		 sar	 ecx, 1
  00331	89 8c 24 98 00
	00 00		 mov	 DWORD PTR tv171[rsp], ecx
  00338	b9 01 00 00 00	 mov	 ecx, 1
  0033d	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  00343	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_optarg
  0034a	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  0034d	48 89 4c 24 58	 mov	 QWORD PTR [rsp+88], rcx
  00352	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG172742
  00359	48 89 4c 24 50	 mov	 QWORD PTR [rsp+80], rcx
  0035e	48 8b 8c 24 20
	21 00 00	 mov	 rcx, QWORD PTR pDEVBLK$[rsp]
  00366	48 8b 49 50	 mov	 rcx, QWORD PTR [rcx+80]
  0036a	48 89 4c 24 48	 mov	 QWORD PTR [rsp+72], rcx
  0036f	8b 8c 24 94 00
	00 00		 mov	 ecx, DWORD PTR tv167[rsp]
  00376	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  0037a	8b 8c 24 98 00
	00 00		 mov	 ecx, DWORD PTR tv171[rsp]
  00381	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  00385	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG172743
  0038c	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  00391	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG172744
  00398	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  0039d	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  003a2	41 b9 03 00 00
	00		 mov	 r9d, 3
  003a8	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG172745
  003af	ba 2f 0d 00 00	 mov	 edx, 3375		; 00000d2fH
  003b4	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG172746
  003bb	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 3375 :                        "device name", optarg );
; 3376 :                 return -1;

  003c1	b8 ff ff ff ff	 mov	 eax, -1
  003c6	e9 73 09 00 00	 jmp	 $LN1@ParseArgs
$LN17@ParseArgs:

; 3377 :             }
; 3378 : 
; 3379 :             pLCSBLK->pszTUNDevice = strdup( optarg );

  003cb	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_optarg
  003d2	48 8b 08	 mov	 rcx, QWORD PTR [rax]
  003d5	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_strdup
  003db	48 8b 8c 24 28
	21 00 00	 mov	 rcx, QWORD PTR pLCSBLK$[rsp]
  003e3	48 89 01	 mov	 QWORD PTR [rcx], rax

; 3380 :             break;

  003e6	e9 25 06 00 00	 jmp	 $LN7@ParseArgs
$LN18@ParseArgs:

; 3381 : 
; 3382 : #if !defined(OPTION_W32_CTCI)
; 3383 :         case 'x':  /* TAP network interface name */
; 3384 :             if (strlen( optarg ) > sizeof(pLCSBLK->Port[0].szNetIfName)-1)
; 3385 :             {
; 3386 :                 // "%1d:%04X %s: option %s value %s invalid"
; 3387 :                 WRMSG( HHC00916, "E", SSID_TO_LCSS(pDEVBLK->ssid), pDEVBLK->devnum, pDEVBLK->typname,
; 3388 :                        "TAP device name", optarg );
; 3389 :                 return -1;
; 3390 :             }
; 3391 :             STRLCPY( pLCSBLK->Port[0].szNetIfName, optarg );
; 3392 :             saw_if = 1;
; 3393 :             break;
; 3394 : #endif /*!defined(OPTION_W32_CTCI)*/
; 3395 : 
; 3396 :         case 'm':
; 3397 : 
; 3398 :             if (0
; 3399 :                 || ParseMAC( optarg, mac ) != 0 // (invalid format)
; 3400 :                 || !(mac[0] & 0x02)             // (locally assigned MAC bit not ON)
; 3401 :                 ||  (mac[0] & 0x01)             // (broadcast bit is ON)

  003eb	33 c0		 xor	 eax, eax
  003ed	85 c0		 test	 eax, eax
  003ef	75 4f		 jne	 SHORT $LN20@ParseArgs
  003f1	48 8d 94 24 f0
	20 00 00	 lea	 rdx, QWORD PTR mac$[rsp]
  003f9	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_optarg
  00400	48 8b 08	 mov	 rcx, QWORD PTR [rax]
  00403	e8 00 00 00 00	 call	 ParseMAC
  00408	85 c0		 test	 eax, eax
  0040a	75 34		 jne	 SHORT $LN20@ParseArgs
  0040c	b8 01 00 00 00	 mov	 eax, 1
  00411	48 6b c0 00	 imul	 rax, rax, 0
  00415	0f b6 84 04 f0
	20 00 00	 movzx	 eax, BYTE PTR mac$[rsp+rax]
  0041d	83 e0 02	 and	 eax, 2
  00420	85 c0		 test	 eax, eax
  00422	74 1c		 je	 SHORT $LN20@ParseArgs
  00424	b8 01 00 00 00	 mov	 eax, 1
  00429	48 6b c0 00	 imul	 rax, rax, 0
  0042d	0f b6 84 04 f0
	20 00 00	 movzx	 eax, BYTE PTR mac$[rsp+rax]
  00435	83 e0 01	 and	 eax, 1
  00438	85 c0		 test	 eax, eax
  0043a	0f 84 bb 00 00
	00		 je	 $LN19@ParseArgs
$LN20@ParseArgs:

; 3402 :             )
; 3403 :             {
; 3404 :                 // "%1d:%04X %s: Option %s value %s invalid"
; 3405 :                 WRMSG( HHC00916, "E", SSID_TO_LCSS(pDEVBLK->ssid), pDEVBLK->devnum, pDEVBLK->typname,

  00440	48 8b 84 24 20
	21 00 00	 mov	 rax, QWORD PTR pDEVBLK$[rsp]
  00448	0f b7 40 48	 movzx	 eax, WORD PTR [rax+72]
  0044c	89 84 24 9c 00
	00 00		 mov	 DWORD PTR tv205[rsp], eax
  00453	48 8b 8c 24 20
	21 00 00	 mov	 rcx, QWORD PTR pDEVBLK$[rsp]
  0045b	0f b7 49 44	 movzx	 ecx, WORD PTR [rcx+68]
  0045f	d1 f9		 sar	 ecx, 1
  00461	89 8c 24 a0 00
	00 00		 mov	 DWORD PTR tv209[rsp], ecx
  00468	b9 01 00 00 00	 mov	 ecx, 1
  0046d	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  00473	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_optarg
  0047a	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  0047d	48 89 4c 24 58	 mov	 QWORD PTR [rsp+88], rcx
  00482	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG172750
  00489	48 89 4c 24 50	 mov	 QWORD PTR [rsp+80], rcx
  0048e	48 8b 8c 24 20
	21 00 00	 mov	 rcx, QWORD PTR pDEVBLK$[rsp]
  00496	48 8b 49 50	 mov	 rcx, QWORD PTR [rcx+80]
  0049a	48 89 4c 24 48	 mov	 QWORD PTR [rsp+72], rcx
  0049f	8b 8c 24 9c 00
	00 00		 mov	 ecx, DWORD PTR tv205[rsp]
  004a6	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  004aa	8b 8c 24 a0 00
	00 00		 mov	 ecx, DWORD PTR tv209[rsp]
  004b1	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  004b5	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG172751
  004bc	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  004c1	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG172752
  004c8	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  004cd	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  004d2	41 b9 03 00 00
	00		 mov	 r9d, 3
  004d8	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG172753
  004df	ba 4e 0d 00 00	 mov	 edx, 3406		; 00000d4eH
  004e4	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG172754
  004eb	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 3406 :                        "MAC address", optarg );
; 3407 :                 return -1;

  004f1	b8 ff ff ff ff	 mov	 eax, -1
  004f6	e9 43 08 00 00	 jmp	 $LN1@ParseArgs
$LN19@ParseArgs:

; 3408 :             }
; 3409 : 
; 3410 :             STRLCPY( pLCSBLK->Port[0].szMACAddress, optarg );

  004fb	b8 98 01 00 00	 mov	 eax, 408		; 00000198H
  00500	48 6b c0 00	 imul	 rax, rax, 0
  00504	48 8b 8c 24 28
	21 00 00	 mov	 rcx, QWORD PTR pLCSBLK$[rsp]
  0050c	48 8d 84 01 b8
	01 00 00	 lea	 rax, QWORD PTR [rcx+rax+440]
  00514	41 b8 20 00 00
	00		 mov	 r8d, 32			; 00000020H
  0051a	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_optarg
  00521	48 8b 11	 mov	 rdx, QWORD PTR [rcx]
  00524	48 8b c8	 mov	 rcx, rax
  00527	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_strlcpy

; 3411 :             memcpy( pLCSBLK->Port[0].MAC_Address, &mac, IFHWADDRLEN );

  0052d	b8 98 01 00 00	 mov	 eax, 408		; 00000198H
  00532	48 6b c0 00	 imul	 rax, rax, 0
  00536	48 8b 8c 24 28
	21 00 00	 mov	 rcx, QWORD PTR pLCSBLK$[rsp]
  0053e	48 8d 94 24 f0
	20 00 00	 lea	 rdx, QWORD PTR mac$[rsp]
  00546	48 8d 7c 01 62	 lea	 rdi, QWORD PTR [rcx+rax+98]
  0054b	48 8b f2	 mov	 rsi, rdx
  0054e	b9 06 00 00 00	 mov	 ecx, 6
  00553	f3 a4		 rep movsb

; 3412 :             pLCSBLK->Port[0].fLocalMAC = TRUE;

  00555	b8 98 01 00 00	 mov	 eax, 408		; 00000198H
  0055a	48 6b c0 00	 imul	 rax, rax, 0
  0055e	48 8b 8c 24 28
	21 00 00	 mov	 rcx, QWORD PTR pLCSBLK$[rsp]
  00566	8b 84 01 94 01
	00 00		 mov	 eax, DWORD PTR [rcx+rax+404]
  0056d	83 c8 02	 or	 eax, 2
  00570	b9 98 01 00 00	 mov	 ecx, 408		; 00000198H
  00575	48 6b c9 00	 imul	 rcx, rcx, 0
  00579	48 8b 94 24 28
	21 00 00	 mov	 rdx, QWORD PTR pLCSBLK$[rsp]
  00581	89 84 0a 94 01
	00 00		 mov	 DWORD PTR [rdx+rcx+404], eax

; 3413 :             saw_conf = 1;

  00588	c7 84 24 8c 00
	00 00 01 00 00
	00		 mov	 DWORD PTR saw_conf$[rsp], 1

; 3414 :             break;

  00593	e9 78 04 00 00	 jmp	 $LN7@ParseArgs
$LN21@ParseArgs:

; 3415 : 
; 3416 :         case 'o':
; 3417 : 
; 3418 :             pLCSBLK->pszOATFilename = strdup( optarg );

  00598	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_optarg
  0059f	48 8b 08	 mov	 rcx, QWORD PTR [rax]
  005a2	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_strdup
  005a8	48 8b 8c 24 28
	21 00 00	 mov	 rcx, QWORD PTR pLCSBLK$[rsp]
  005b0	48 89 41 08	 mov	 QWORD PTR [rcx+8], rax

; 3419 :             saw_conf = 1;

  005b4	c7 84 24 8c 00
	00 00 01 00 00
	00		 mov	 DWORD PTR saw_conf$[rsp], 1

; 3420 :             break;

  005bf	e9 4c 04 00 00	 jmp	 $LN7@ParseArgs
$LN22@ParseArgs:

; 3421 : 
; 3422 :         case 's':     // Size to be traced when discarding a frame. Default is 0.
; 3423 : 
; 3424 :             iDiscTrace = atoi( optarg );

  005c4	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_optarg
  005cb	48 8b 08	 mov	 rcx, QWORD PTR [rax]
  005ce	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_atoi
  005d4	89 44 24 6c	 mov	 DWORD PTR iDiscTrace$[rsp], eax

; 3425 : 
; 3426 :             if ((iDiscTrace < LCS_DISC_TRACE_MINIMUM || iDiscTrace > LCS_DISC_TRACE_MAXIMUM) && iDiscTrace != LCS_DISC_TRACE_ZERO)

  005d8	83 7c 24 6c 10	 cmp	 DWORD PTR iDiscTrace$[rsp], 16
  005dd	7c 0e		 jl	 SHORT $LN24@ParseArgs
  005df	81 7c 24 6c ff
	ff 00 00	 cmp	 DWORD PTR iDiscTrace$[rsp], 65535 ; 0000ffffH
  005e7	0f 8e c6 00 00
	00		 jle	 $LN23@ParseArgs
$LN24@ParseArgs:
  005ed	83 7c 24 6c 00	 cmp	 DWORD PTR iDiscTrace$[rsp], 0
  005f2	0f 84 bb 00 00
	00		 je	 $LN23@ParseArgs

; 3427 :             {
; 3428 :                 // "%1d:%04X CTC: option %s value %s invalid"
; 3429 :                 WRMSG( HHC00916, "E", SSID_TO_LCSS(pDEVBLK->ssid), pDEVBLK->devnum, pDEVBLK->typname,

  005f8	48 8b 84 24 20
	21 00 00	 mov	 rax, QWORD PTR pDEVBLK$[rsp]
  00600	0f b7 40 48	 movzx	 eax, WORD PTR [rax+72]
  00604	89 84 24 a4 00
	00 00		 mov	 DWORD PTR tv260[rsp], eax
  0060b	48 8b 8c 24 20
	21 00 00	 mov	 rcx, QWORD PTR pDEVBLK$[rsp]
  00613	0f b7 49 44	 movzx	 ecx, WORD PTR [rcx+68]
  00617	d1 f9		 sar	 ecx, 1
  00619	89 8c 24 a8 00
	00 00		 mov	 DWORD PTR tv264[rsp], ecx
  00620	b9 01 00 00 00	 mov	 ecx, 1
  00625	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  0062b	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_optarg
  00632	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  00635	48 89 4c 24 58	 mov	 QWORD PTR [rsp+88], rcx
  0063a	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG172759
  00641	48 89 4c 24 50	 mov	 QWORD PTR [rsp+80], rcx
  00646	48 8b 8c 24 20
	21 00 00	 mov	 rcx, QWORD PTR pDEVBLK$[rsp]
  0064e	48 8b 49 50	 mov	 rcx, QWORD PTR [rcx+80]
  00652	48 89 4c 24 48	 mov	 QWORD PTR [rsp+72], rcx
  00657	8b 8c 24 a4 00
	00 00		 mov	 ecx, DWORD PTR tv260[rsp]
  0065e	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  00662	8b 8c 24 a8 00
	00 00		 mov	 ecx, DWORD PTR tv264[rsp]
  00669	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  0066d	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG172760
  00674	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  00679	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG172761
  00680	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00685	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  0068a	41 b9 03 00 00
	00		 mov	 r9d, 3
  00690	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG172762
  00697	ba 66 0d 00 00	 mov	 edx, 3430		; 00000d66H
  0069c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG172763
  006a3	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 3430 :                        "discard trace size", optarg );
; 3431 :                 return -1;

  006a9	b8 ff ff ff ff	 mov	 eax, -1
  006ae	e9 8b 06 00 00	 jmp	 $LN1@ParseArgs
$LN23@ParseArgs:

; 3432 :             }
; 3433 : 
; 3434 :             pLCSBLK->iDiscTrace = iDiscTrace;

  006b3	48 8b 84 24 28
	21 00 00	 mov	 rax, QWORD PTR pLCSBLK$[rsp]
  006bb	8b 4c 24 6c	 mov	 ecx, DWORD PTR iDiscTrace$[rsp]
  006bf	89 48 2c	 mov	 DWORD PTR [rax+44], ecx

; 3435 :             break;

  006c2	e9 49 03 00 00	 jmp	 $LN7@ParseArgs
$LN25@ParseArgs:

; 3436 : 
; 3437 :         case 't':     // Size to be traced of structures or frames. Default is LCS_TRACE_LEN_DEFAULT, i.e. 128.
; 3438 : 
; 3439 :             iTraceLen = atoi( optarg );

  006c7	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_optarg
  006ce	48 8b 08	 mov	 rcx, QWORD PTR [rax]
  006d1	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_atoi
  006d7	89 44 24 70	 mov	 DWORD PTR iTraceLen$[rsp], eax

; 3440 : 
; 3441 :             if ((iTraceLen < LCS_TRACE_LEN_MINIMUM || iTraceLen > LCS_TRACE_LEN_MAXIMUM) && iTraceLen != LCS_TRACE_LEN_ZERO)

  006db	83 7c 24 70 40	 cmp	 DWORD PTR iTraceLen$[rsp], 64 ; 00000040H
  006e0	7c 0e		 jl	 SHORT $LN27@ParseArgs
  006e2	81 7c 24 70 ff
	ff 00 00	 cmp	 DWORD PTR iTraceLen$[rsp], 65535 ; 0000ffffH
  006ea	0f 8e c6 00 00
	00		 jle	 $LN26@ParseArgs
$LN27@ParseArgs:
  006f0	83 7c 24 70 00	 cmp	 DWORD PTR iTraceLen$[rsp], 0
  006f5	0f 84 bb 00 00
	00		 je	 $LN26@ParseArgs

; 3442 :             {
; 3443 :                 // "%1d:%04X CTC: option %s value %s invalid"
; 3444 :                 WRMSG( HHC00916, "E", SSID_TO_LCSS(pDEVBLK->ssid), pDEVBLK->devnum, pDEVBLK->typname,

  006fb	48 8b 84 24 20
	21 00 00	 mov	 rax, QWORD PTR pDEVBLK$[rsp]
  00703	0f b7 40 48	 movzx	 eax, WORD PTR [rax+72]
  00707	89 84 24 ac 00
	00 00		 mov	 DWORD PTR tv286[rsp], eax
  0070e	48 8b 8c 24 20
	21 00 00	 mov	 rcx, QWORD PTR pDEVBLK$[rsp]
  00716	0f b7 49 44	 movzx	 ecx, WORD PTR [rcx+68]
  0071a	d1 f9		 sar	 ecx, 1
  0071c	89 8c 24 b0 00
	00 00		 mov	 DWORD PTR tv290[rsp], ecx
  00723	b9 01 00 00 00	 mov	 ecx, 1
  00728	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  0072e	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_optarg
  00735	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  00738	48 89 4c 24 58	 mov	 QWORD PTR [rsp+88], rcx
  0073d	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG172767
  00744	48 89 4c 24 50	 mov	 QWORD PTR [rsp+80], rcx
  00749	48 8b 8c 24 20
	21 00 00	 mov	 rcx, QWORD PTR pDEVBLK$[rsp]
  00751	48 8b 49 50	 mov	 rcx, QWORD PTR [rcx+80]
  00755	48 89 4c 24 48	 mov	 QWORD PTR [rsp+72], rcx
  0075a	8b 8c 24 ac 00
	00 00		 mov	 ecx, DWORD PTR tv286[rsp]
  00761	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  00765	8b 8c 24 b0 00
	00 00		 mov	 ecx, DWORD PTR tv290[rsp]
  0076c	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  00770	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG172768
  00777	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  0077c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG172769
  00783	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00788	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  0078d	41 b9 03 00 00
	00		 mov	 r9d, 3
  00793	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG172770
  0079a	ba 75 0d 00 00	 mov	 edx, 3445		; 00000d75H
  0079f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG172771
  007a6	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 3445 :                        "maximum trace size", optarg );
; 3446 :                 return -1;

  007ac	b8 ff ff ff ff	 mov	 eax, -1
  007b1	e9 88 05 00 00	 jmp	 $LN1@ParseArgs
$LN26@ParseArgs:

; 3447 :             }
; 3448 : 
; 3449 :             pLCSBLK->iTraceLen = iTraceLen;

  007b6	48 8b 84 24 28
	21 00 00	 mov	 rax, QWORD PTR pLCSBLK$[rsp]
  007be	8b 4c 24 70	 mov	 ecx, DWORD PTR iTraceLen$[rsp]
  007c2	89 48 28	 mov	 DWORD PTR [rax+40], ecx

; 3450 :             break;

  007c5	e9 46 02 00 00	 jmp	 $LN7@ParseArgs
$LN28@ParseArgs:

; 3451 : 
; 3452 :         case 'd':
; 3453 : 
; 3454 :             pLCSBLK->fDebug = TRUE;

  007ca	48 8b 84 24 28
	21 00 00	 mov	 rax, QWORD PTR pLCSBLK$[rsp]
  007d2	8b 40 18	 mov	 eax, DWORD PTR [rax+24]
  007d5	83 c8 01	 or	 eax, 1
  007d8	48 8b 8c 24 28
	21 00 00	 mov	 rcx, QWORD PTR pLCSBLK$[rsp]
  007e0	89 41 18	 mov	 DWORD PTR [rcx+24], eax

; 3455 :             break;

  007e3	e9 28 02 00 00	 jmp	 $LN7@ParseArgs
$LN29@ParseArgs:

; 3456 : 
; 3457 : #if defined( OPTION_W32_CTCI )
; 3458 : 
; 3459 :         case 'k':     // Kernel Buffer Size (Windows only)
; 3460 : 
; 3461 :             iKernBuff = atoi( optarg );

  007e8	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_optarg
  007ef	48 8b 08	 mov	 rcx, QWORD PTR [rax]
  007f2	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_atoi
  007f8	89 44 24 74	 mov	 DWORD PTR iKernBuff$[rsp], eax

; 3462 : 
; 3463 :             if (iKernBuff * 1024 < MIN_CAPTURE_BUFFSIZE    ||

  007fc	69 44 24 74 00
	04 00 00	 imul	 eax, DWORD PTR iKernBuff$[rsp], 1024 ; 00000400H
  00804	3d 00 00 01 00	 cmp	 eax, 65536		; 00010000H
  00809	7c 13		 jl	 SHORT $LN31@ParseArgs
  0080b	69 44 24 74 00
	04 00 00	 imul	 eax, DWORD PTR iKernBuff$[rsp], 1024 ; 00000400H
  00813	3d 00 00 00 01	 cmp	 eax, 16777216		; 01000000H
  00818	0f 8e bb 00 00
	00		 jle	 $LN30@ParseArgs
$LN31@ParseArgs:

; 3464 :                 iKernBuff * 1024 > MAX_CAPTURE_BUFFSIZE)
; 3465 :             {
; 3466 :                 // "%1d:%04X CTC: option %s value %s invalid"
; 3467 :                 WRMSG( HHC00916, "E", SSID_TO_LCSS(pDEVBLK->ssid), pDEVBLK->devnum, pDEVBLK->typname,

  0081e	48 8b 84 24 20
	21 00 00	 mov	 rax, QWORD PTR pDEVBLK$[rsp]
  00826	0f b7 40 48	 movzx	 eax, WORD PTR [rax+72]
  0082a	89 84 24 b4 00
	00 00		 mov	 DWORD PTR tv316[rsp], eax
  00831	48 8b 8c 24 20
	21 00 00	 mov	 rcx, QWORD PTR pDEVBLK$[rsp]
  00839	0f b7 49 44	 movzx	 ecx, WORD PTR [rcx+68]
  0083d	d1 f9		 sar	 ecx, 1
  0083f	89 8c 24 b8 00
	00 00		 mov	 DWORD PTR tv352[rsp], ecx
  00846	b9 01 00 00 00	 mov	 ecx, 1
  0084b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  00851	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_optarg
  00858	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  0085b	48 89 4c 24 58	 mov	 QWORD PTR [rsp+88], rcx
  00860	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG172776
  00867	48 89 4c 24 50	 mov	 QWORD PTR [rsp+80], rcx
  0086c	48 8b 8c 24 20
	21 00 00	 mov	 rcx, QWORD PTR pDEVBLK$[rsp]
  00874	48 8b 49 50	 mov	 rcx, QWORD PTR [rcx+80]
  00878	48 89 4c 24 48	 mov	 QWORD PTR [rsp+72], rcx
  0087d	8b 8c 24 b4 00
	00 00		 mov	 ecx, DWORD PTR tv316[rsp]
  00884	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  00888	8b 8c 24 b8 00
	00 00		 mov	 ecx, DWORD PTR tv352[rsp]
  0088f	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  00893	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG172777
  0089a	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  0089f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG172778
  008a6	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  008ab	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  008b0	41 b9 03 00 00
	00		 mov	 r9d, 3
  008b6	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG172779
  008bd	ba 8c 0d 00 00	 mov	 edx, 3468		; 00000d8cH
  008c2	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG172780
  008c9	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 3468 :                        "kernel buffer size", optarg );
; 3469 :                 return -1;

  008cf	b8 ff ff ff ff	 mov	 eax, -1
  008d4	e9 65 04 00 00	 jmp	 $LN1@ParseArgs
$LN30@ParseArgs:

; 3470 :             }
; 3471 : 
; 3472 :             pLCSBLK->iKernBuff = iKernBuff * 1024;

  008d9	69 44 24 74 00
	04 00 00	 imul	 eax, DWORD PTR iKernBuff$[rsp], 1024 ; 00000400H
  008e1	48 8b 8c 24 28
	21 00 00	 mov	 rcx, QWORD PTR pLCSBLK$[rsp]
  008e9	89 41 20	 mov	 DWORD PTR [rcx+32], eax

; 3473 :             break;

  008ec	e9 1f 01 00 00	 jmp	 $LN7@ParseArgs
$LN32@ParseArgs:

; 3474 : 
; 3475 :         case 'i':     // I/O Buffer Size (Windows only)
; 3476 : 
; 3477 :             iIOBuff = atoi( optarg );

  008f1	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_optarg
  008f8	48 8b 08	 mov	 rcx, QWORD PTR [rax]
  008fb	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_atoi
  00901	89 44 24 78	 mov	 DWORD PTR iIOBuff$[rsp], eax

; 3478 : 
; 3479 :             if (iIOBuff * 1024 < MIN_PACKET_BUFFSIZE    ||

  00905	69 44 24 78 00
	04 00 00	 imul	 eax, DWORD PTR iIOBuff$[rsp], 1024 ; 00000400H
  0090d	3d 00 40 00 00	 cmp	 eax, 16384		; 00004000H
  00912	7c 13		 jl	 SHORT $LN34@ParseArgs
  00914	69 44 24 78 00
	04 00 00	 imul	 eax, DWORD PTR iIOBuff$[rsp], 1024 ; 00000400H
  0091c	3d 00 00 10 00	 cmp	 eax, 1048576		; 00100000H
  00921	0f 8e bb 00 00
	00		 jle	 $LN33@ParseArgs
$LN34@ParseArgs:

; 3480 :                 iIOBuff * 1024 > MAX_PACKET_BUFFSIZE)
; 3481 :             {
; 3482 :                 // "%1d:%04X CTC: option %s value %s invalid"
; 3483 :                 WRMSG( HHC00916, "E", SSID_TO_LCSS(pDEVBLK->ssid), pDEVBLK->devnum, pDEVBLK->typname,

  00927	48 8b 84 24 20
	21 00 00	 mov	 rax, QWORD PTR pDEVBLK$[rsp]
  0092f	0f b7 40 48	 movzx	 eax, WORD PTR [rax+72]
  00933	89 84 24 bc 00
	00 00		 mov	 DWORD PTR tv376[rsp], eax
  0093a	48 8b 8c 24 20
	21 00 00	 mov	 rcx, QWORD PTR pDEVBLK$[rsp]
  00942	0f b7 49 44	 movzx	 ecx, WORD PTR [rcx+68]
  00946	d1 f9		 sar	 ecx, 1
  00948	89 8c 24 c0 00
	00 00		 mov	 DWORD PTR tv380[rsp], ecx
  0094f	b9 01 00 00 00	 mov	 ecx, 1
  00954	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  0095a	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_optarg
  00961	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  00964	48 89 4c 24 58	 mov	 QWORD PTR [rsp+88], rcx
  00969	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG172784
  00970	48 89 4c 24 50	 mov	 QWORD PTR [rsp+80], rcx
  00975	48 8b 8c 24 20
	21 00 00	 mov	 rcx, QWORD PTR pDEVBLK$[rsp]
  0097d	48 8b 49 50	 mov	 rcx, QWORD PTR [rcx+80]
  00981	48 89 4c 24 48	 mov	 QWORD PTR [rsp+72], rcx
  00986	8b 8c 24 bc 00
	00 00		 mov	 ecx, DWORD PTR tv376[rsp]
  0098d	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  00991	8b 8c 24 c0 00
	00 00		 mov	 ecx, DWORD PTR tv380[rsp]
  00998	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  0099c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG172785
  009a3	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  009a8	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG172786
  009af	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  009b4	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  009b9	41 b9 03 00 00
	00		 mov	 r9d, 3
  009bf	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG172787
  009c6	ba 9c 0d 00 00	 mov	 edx, 3484		; 00000d9cH
  009cb	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG172788
  009d2	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 3484 :                        "dll i/o buffer size", optarg );
; 3485 :                 return -1;

  009d8	b8 ff ff ff ff	 mov	 eax, -1
  009dd	e9 5c 03 00 00	 jmp	 $LN1@ParseArgs
$LN33@ParseArgs:

; 3486 :             }
; 3487 : 
; 3488 :             pLCSBLK->iIOBuff = iIOBuff * 1024;

  009e2	69 44 24 78 00
	04 00 00	 imul	 eax, DWORD PTR iIOBuff$[rsp], 1024 ; 00000400H
  009ea	48 8b 8c 24 28
	21 00 00	 mov	 rcx, QWORD PTR pLCSBLK$[rsp]
  009f2	89 41 24	 mov	 DWORD PTR [rcx+36], eax

; 3489 :             break;

  009f5	eb 19		 jmp	 SHORT $LN7@ParseArgs
$LN35@ParseArgs:

; 3490 : 
; 3491 :         case 'w':     // Single packet writes mode (Windows only)
; 3492 : 
; 3493 :             pLCSBLK->fNoMultiWrite = TRUE;

  009f7	48 8b 84 24 28
	21 00 00	 mov	 rax, QWORD PTR pLCSBLK$[rsp]
  009ff	8b 40 18	 mov	 eax, DWORD PTR [rax+24]
  00a02	83 c8 04	 or	 eax, 4
  00a05	48 8b 8c 24 28
	21 00 00	 mov	 rcx, QWORD PTR pLCSBLK$[rsp]
  00a0d	89 41 18	 mov	 DWORD PTR [rcx+24], eax
$LN36@ParseArgs:
$LN7@ParseArgs:

; 3494 :             break;
; 3495 : 
; 3496 : #endif // defined( OPTION_W32_CTCI )
; 3497 : 
; 3498 :         default:
; 3499 :             break;
; 3500 :         }
; 3501 :     }

  00a10	e9 4e f7 ff ff	 jmp	 $LN5@ParseArgs
$LN6@ParseArgs:

; 3502 : 
; 3503 :     argc -= optind;

  00a15	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_optind
  00a1c	8b 00		 mov	 eax, DWORD PTR [rax]
  00a1e	8b 8c 24 30 21
	00 00		 mov	 ecx, DWORD PTR argc$[rsp]
  00a25	2b c8		 sub	 ecx, eax
  00a27	8b c1		 mov	 eax, ecx
  00a29	89 84 24 30 21
	00 00		 mov	 DWORD PTR argc$[rsp], eax

; 3504 :     argv += optind;

  00a30	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_optind
  00a37	48 63 00	 movsxd	 rax, DWORD PTR [rax]
  00a3a	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR argv$[rsp]
  00a42	48 8d 04 c1	 lea	 rax, QWORD PTR [rcx+rax*8]
  00a46	48 89 84 24 80
	00 00 00	 mov	 QWORD PTR argv$[rsp], rax

; 3505 : 
; 3506 : #if !defined(OPTION_W32_CTCI)
; 3507 :     /* If the -x option and one of the configuration options (e.g. the */
; 3508 :     /* -m or the -o options has been specified, reject the -x option.  */
; 3509 :     if (saw_if && saw_conf)
; 3510 :     {
; 3511 :         /* HHC00916 "%1d:%04X %s: option %s value %s invalid" */
; 3512 :         WRMSG( HHC00916, "E", SSID_TO_LCSS(pDEVBLK->ssid), pDEVBLK->devnum, pDEVBLK->typname,
; 3513 :                "TAP device name", pLCSBLK->Port[0].szNetIfName );
; 3514 :         return -1;
; 3515 :     }
; 3516 : #endif /*!defined(OPTION_W32_CTCI)*/
; 3517 : 
; 3518 :     if (argc > 1)

  00a4e	83 bc 24 30 21
	00 00 01	 cmp	 DWORD PTR argc$[rsp], 1
  00a56	0f 8e a5 00 00
	00		 jle	 $LN37@ParseArgs

; 3519 :     {
; 3520 :         /* There are two or more arguments. */
; 3521 :         /* HHC00915 "%1d:%04X %s: incorrect number of parameters" */
; 3522 :         WRMSG(HHC00915, "E", SSID_TO_LCSS(pDEVBLK->ssid), pDEVBLK->devnum, pDEVBLK->typname );

  00a5c	48 8b 84 24 20
	21 00 00	 mov	 rax, QWORD PTR pDEVBLK$[rsp]
  00a64	0f b7 40 48	 movzx	 eax, WORD PTR [rax+72]
  00a68	89 84 24 c4 00
	00 00		 mov	 DWORD PTR tv406[rsp], eax
  00a6f	48 8b 8c 24 20
	21 00 00	 mov	 rcx, QWORD PTR pDEVBLK$[rsp]
  00a77	0f b7 49 44	 movzx	 ecx, WORD PTR [rcx+68]
  00a7b	d1 f9		 sar	 ecx, 1
  00a7d	89 8c 24 c8 00
	00 00		 mov	 DWORD PTR tv410[rsp], ecx
  00a84	b9 01 00 00 00	 mov	 ecx, 1
  00a89	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  00a8f	48 8b 8c 24 20
	21 00 00	 mov	 rcx, QWORD PTR pDEVBLK$[rsp]
  00a97	48 8b 49 50	 mov	 rcx, QWORD PTR [rcx+80]
  00a9b	48 89 4c 24 48	 mov	 QWORD PTR [rsp+72], rcx
  00aa0	8b 8c 24 c4 00
	00 00		 mov	 ecx, DWORD PTR tv406[rsp]
  00aa7	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  00aab	8b 8c 24 c8 00
	00 00		 mov	 ecx, DWORD PTR tv410[rsp]
  00ab2	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  00ab6	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG172793
  00abd	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  00ac2	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG172794
  00ac9	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00ace	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00ad3	41 b9 03 00 00
	00		 mov	 r9d, 3
  00ad9	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG172795
  00ae0	ba c2 0d 00 00	 mov	 edx, 3522		; 00000dc2H
  00ae5	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG172796
  00aec	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 3523 :         return -1;

  00af2	b8 ff ff ff ff	 mov	 eax, -1
  00af7	e9 42 02 00 00	 jmp	 $LN1@ParseArgs

; 3524 :     }

  00afc	e9 38 02 00 00	 jmp	 $LN38@ParseArgs
$LN37@ParseArgs:

; 3525 :     else if (argc == 1)

  00b01	83 bc 24 30 21
	00 00 01	 cmp	 DWORD PTR argc$[rsp], 1
  00b09	0f 85 2a 02 00
	00		 jne	 $LN39@ParseArgs

; 3526 :     {
; 3527 :         /* There is one argument, check for an IPv4 address. */
; 3528 :         if (inet_aton( *argv, &addr ) != 0)

  00b0f	48 8d 94 24 cc
	00 00 00	 lea	 rdx, QWORD PTR addr$[rsp]
  00b17	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR argv$[rsp]
  00b1f	48 8b 08	 mov	 rcx, QWORD PTR [rax]
  00b22	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_inet_aton
  00b28	85 c0		 test	 eax, eax
  00b2a	0f 84 50 01 00
	00		 je	 $LN40@ParseArgs

; 3529 :         {
; 3530 :             /* The argument is an IPv4 address. If the -x option was specified, */
; 3531 :             /* it has pre-named the TAP interface that LCS will use (*nix).     */
; 3532 :             if ( bMode == LCSDEV_MODE_SNA )      /* Is the mode SNA? */

  00b30	0f b6 44 24 60	 movzx	 eax, BYTE PTR bMode$[rsp]
  00b35	83 f8 02	 cmp	 eax, 2
  00b38	0f 85 bc 00 00
	00		 jne	 $LN42@ParseArgs

; 3533 :             {
; 3534 :                 WRMSG( HHC00916, "E", SSID_TO_LCSS(pDEVBLK->ssid), pDEVBLK->devnum, pDEVBLK->typname,

  00b3e	48 8b 84 24 20
	21 00 00	 mov	 rax, QWORD PTR pDEVBLK$[rsp]
  00b46	0f b7 40 48	 movzx	 eax, WORD PTR [rax+72]
  00b4a	89 84 24 d0 00
	00 00		 mov	 DWORD PTR tv433[rsp], eax
  00b51	48 8b 8c 24 20
	21 00 00	 mov	 rcx, QWORD PTR pDEVBLK$[rsp]
  00b59	0f b7 49 44	 movzx	 ecx, WORD PTR [rcx+68]
  00b5d	d1 f9		 sar	 ecx, 1
  00b5f	89 8c 24 d4 00
	00 00		 mov	 DWORD PTR tv437[rsp], ecx
  00b66	b9 01 00 00 00	 mov	 ecx, 1
  00b6b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  00b71	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR argv$[rsp]
  00b79	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  00b7c	48 89 4c 24 58	 mov	 QWORD PTR [rsp+88], rcx
  00b81	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG172801
  00b88	48 89 4c 24 50	 mov	 QWORD PTR [rsp+80], rcx
  00b8d	48 8b 8c 24 20
	21 00 00	 mov	 rcx, QWORD PTR pDEVBLK$[rsp]
  00b95	48 8b 49 50	 mov	 rcx, QWORD PTR [rcx+80]
  00b99	48 89 4c 24 48	 mov	 QWORD PTR [rsp+72], rcx
  00b9e	8b 8c 24 d0 00
	00 00		 mov	 ecx, DWORD PTR tv433[rsp]
  00ba5	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  00ba9	8b 8c 24 d4 00
	00 00		 mov	 ecx, DWORD PTR tv437[rsp]
  00bb0	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  00bb4	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG172802
  00bbb	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  00bc0	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG172803
  00bc7	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00bcc	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00bd1	41 b9 03 00 00
	00		 mov	 r9d, 3
  00bd7	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG172804
  00bde	ba cf 0d 00 00	 mov	 edx, 3535		; 00000dcfH
  00be3	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG172805
  00bea	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 3535 :                        "IP address", *argv );
; 3536 :                 return -1;

  00bf0	b8 ff ff ff ff	 mov	 eax, -1
  00bf5	e9 44 01 00 00	 jmp	 $LN1@ParseArgs
$LN42@ParseArgs:

; 3537 :             }
; 3538 :             if ( pLCSBLK->pszIPAddress ) { free( pLCSBLK->pszIPAddress ); pLCSBLK->pszIPAddress = NULL; }

  00bfa	48 8b 84 24 28
	21 00 00	 mov	 rax, QWORD PTR pLCSBLK$[rsp]
  00c02	48 83 78 10 00	 cmp	 QWORD PTR [rax+16], 0
  00c07	74 22		 je	 SHORT $LN43@ParseArgs
  00c09	48 8b 84 24 28
	21 00 00	 mov	 rax, QWORD PTR pLCSBLK$[rsp]
  00c11	48 8b 48 10	 mov	 rcx, QWORD PTR [rax+16]
  00c15	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free
  00c1b	48 8b 84 24 28
	21 00 00	 mov	 rax, QWORD PTR pLCSBLK$[rsp]
  00c23	48 c7 40 10 00
	00 00 00	 mov	 QWORD PTR [rax+16], 0
$LN43@ParseArgs:

; 3539 :             pLCSBLK->pszIPAddress = strdup( *argv );

  00c2b	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR argv$[rsp]
  00c33	48 8b 08	 mov	 rcx, QWORD PTR [rax]
  00c36	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_strdup
  00c3c	48 8b 8c 24 28
	21 00 00	 mov	 rcx, QWORD PTR pLCSBLK$[rsp]
  00c44	48 89 41 10	 mov	 QWORD PTR [rcx+16], rax

; 3540 :             pLCSBLK->Port[0].fPreconfigured = FALSE;

  00c48	b8 98 01 00 00	 mov	 eax, 408		; 00000198H
  00c4d	48 6b c0 00	 imul	 rax, rax, 0
  00c51	48 8b 8c 24 28
	21 00 00	 mov	 rcx, QWORD PTR pLCSBLK$[rsp]
  00c59	8b 84 01 94 01
	00 00		 mov	 eax, DWORD PTR [rcx+rax+404]
  00c60	83 e0 bf	 and	 eax, -65		; ffffffbfH
  00c63	b9 98 01 00 00	 mov	 ecx, 408		; 00000198H
  00c68	48 6b c9 00	 imul	 rcx, rcx, 0
  00c6c	48 8b 94 24 28
	21 00 00	 mov	 rdx, QWORD PTR pLCSBLK$[rsp]
  00c74	89 84 0a 94 01
	00 00		 mov	 DWORD PTR [rdx+rcx+404], eax

; 3541 :         } else {

  00c7b	e9 b9 00 00 00	 jmp	 $LN41@ParseArgs
$LN40@ParseArgs:

; 3542 : #if defined(OPTION_W32_CTCI)
; 3543 :             WRMSG( HHC00916, "E", SSID_TO_LCSS(pDEVBLK->ssid), pDEVBLK->devnum, pDEVBLK->typname,

  00c80	48 8b 84 24 20
	21 00 00	 mov	 rax, QWORD PTR pDEVBLK$[rsp]
  00c88	0f b7 40 48	 movzx	 eax, WORD PTR [rax+72]
  00c8c	89 84 24 d8 00
	00 00		 mov	 DWORD PTR tv470[rsp], eax
  00c93	48 8b 8c 24 20
	21 00 00	 mov	 rcx, QWORD PTR pDEVBLK$[rsp]
  00c9b	0f b7 49 44	 movzx	 ecx, WORD PTR [rcx+68]
  00c9f	d1 f9		 sar	 ecx, 1
  00ca1	89 8c 24 dc 00
	00 00		 mov	 DWORD PTR tv474[rsp], ecx
  00ca8	b9 01 00 00 00	 mov	 ecx, 1
  00cad	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  00cb3	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR argv$[rsp]
  00cbb	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  00cbe	48 89 4c 24 58	 mov	 QWORD PTR [rsp+88], rcx
  00cc3	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG172807
  00cca	48 89 4c 24 50	 mov	 QWORD PTR [rsp+80], rcx
  00ccf	48 8b 8c 24 20
	21 00 00	 mov	 rcx, QWORD PTR pDEVBLK$[rsp]
  00cd7	48 8b 49 50	 mov	 rcx, QWORD PTR [rcx+80]
  00cdb	48 89 4c 24 48	 mov	 QWORD PTR [rsp+72], rcx
  00ce0	8b 8c 24 d8 00
	00 00		 mov	 ecx, DWORD PTR tv470[rsp]
  00ce7	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  00ceb	8b 8c 24 dc 00
	00 00		 mov	 ecx, DWORD PTR tv474[rsp]
  00cf2	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  00cf6	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG172808
  00cfd	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  00d02	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG172809
  00d09	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00d0e	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00d13	41 b9 03 00 00
	00		 mov	 r9d, 3
  00d19	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG172810
  00d20	ba d8 0d 00 00	 mov	 edx, 3544		; 00000dd8H
  00d25	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG172811
  00d2c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 3544 :                    "IP address", *argv );
; 3545 :             return -1;

  00d32	b8 ff ff ff ff	 mov	 eax, -1
  00d37	eb 05		 jmp	 SHORT $LN1@ParseArgs
$LN41@ParseArgs:
$LN39@ParseArgs:
$LN38@ParseArgs:

; 3546 : #else /*defined(OPTION_W32_CTCI)*/
; 3547 :             /* The argument is not an IPv4 address. If the -x option was */
; 3548 :             /* specified, the argument shouldn't have been specified.    */
; 3549 :             if (saw_if ) {
; 3550 :                 WRMSG( HHC00916, "E", SSID_TO_LCSS(pDEVBLK->ssid), pDEVBLK->devnum, pDEVBLK->typname,
; 3551 :                        "IP address", *argv );
; 3552 :                 return -1;
; 3553 :             }
; 3554 :             /* The -x option was not specified, so the argument should be the  */
; 3555 :             /* name of the pre-configured TAP interface that LCS will use.     */
; 3556 :             STRLCPY( pLCSBLK->Port[0].szNetIfName, argv[0] );
; 3557 :             pLCSBLK->Port[0].fPreconfigured = TRUE;
; 3558 : #endif /*defined(OPTION_W32_CTCI)*/
; 3559 :         }
; 3560 :     }
; 3561 : #if !defined(OPTION_W32_CTCI)
; 3562 :     else
; 3563 :     {
; 3564 :         /* There are no arguments. If the -x option was specified, it */
; 3565 :         /* named a pre-configured TAP interface that LCS will use.    */
; 3566 :         if (saw_if)
; 3567 :             pLCSBLK->Port[0].fPreconfigured = TRUE;
; 3568 :         else
; 3569 :             pLCSBLK->Port[0].fPreconfigured = FALSE;
; 3570 :     }
; 3571 : #endif /*!defined(OPTION_W32_CTCI)*/
; 3572 : 
; 3573 :     return bMode;

  00d39	0f b6 44 24 60	 movzx	 eax, BYTE PTR bMode$[rsp]
$LN1@ParseArgs:

; 3574 : }

  00d3e	48 8b 8c 24 f8
	20 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  00d46	48 33 cc	 xor	 rcx, rsp
  00d49	e8 00 00 00 00	 call	 __security_check_cookie
  00d4e	48 81 c4 08 21
	00 00		 add	 rsp, 8456		; 00002108H
  00d55	5f		 pop	 rdi
  00d56	5e		 pop	 rsi
  00d57	c3		 ret	 0
$LN45@ParseArgs:
  00d58	00 00 00 00	 DD	 $LN28@ParseArgs
  00d5c	00 00 00 00	 DD	 $LN11@ParseArgs
  00d60	00 00 00 00	 DD	 $LN36@ParseArgs
  00d64	00 00 00 00	 DD	 $LN36@ParseArgs
  00d68	00 00 00 00	 DD	 $LN36@ParseArgs
  00d6c	00 00 00 00	 DD	 $LN32@ParseArgs
  00d70	00 00 00 00	 DD	 $LN36@ParseArgs
  00d74	00 00 00 00	 DD	 $LN29@ParseArgs
  00d78	00 00 00 00	 DD	 $LN36@ParseArgs
  00d7c	00 00 00 00	 DD	 $LN18@ParseArgs
  00d80	00 00 00 00	 DD	 $LN16@ParseArgs
  00d84	00 00 00 00	 DD	 $LN21@ParseArgs
  00d88	00 00 00 00	 DD	 $LN36@ParseArgs
  00d8c	00 00 00 00	 DD	 $LN36@ParseArgs
  00d90	00 00 00 00	 DD	 $LN36@ParseArgs
  00d94	00 00 00 00	 DD	 $LN22@ParseArgs
  00d98	00 00 00 00	 DD	 $LN25@ParseArgs
  00d9c	00 00 00 00	 DD	 $LN36@ParseArgs
  00da0	00 00 00 00	 DD	 $LN36@ParseArgs
  00da4	00 00 00 00	 DD	 $LN35@ParseArgs
ParseArgs ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\ctc_lcs.c
_TEXT	SEGMENT
c$ = 80
iLen$ = 84
iLine$ = 88
tv71 = 96
pszOATName$ = 128
fp$ = 136
pszBuff$ = 144
ReadOAT	PROC

; 3948 : {

  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	48 83 ec 78	 sub	 rsp, 120		; 00000078H

; 3949 :     int     c;                          // Character work area
; 3950 :     int     iLine = 0;                  // Statement number

  00013	c7 44 24 58 00
	00 00 00	 mov	 DWORD PTR iLine$[rsp], 0
$LN2@ReadOAT:

; 3951 :     int     iLen;                       // Statement length
; 3952 : 
; 3953 :     while (1)

  0001b	33 c0		 xor	 eax, eax
  0001d	83 f8 01	 cmp	 eax, 1
  00020	0f 84 30 02 00
	00		 je	 $LN3@ReadOAT

; 3954 :     {
; 3955 :         // Increment statement number
; 3956 :         iLine++;

  00026	8b 44 24 58	 mov	 eax, DWORD PTR iLine$[rsp]
  0002a	ff c0		 inc	 eax
  0002c	89 44 24 58	 mov	 DWORD PTR iLine$[rsp], eax

; 3957 : 
; 3958 :         // Read next statement from OAT
; 3959 :         for (iLen = 0 ; ; )

  00030	c7 44 24 54 00
	00 00 00	 mov	 DWORD PTR iLen$[rsp], 0
$LN4@ReadOAT:

; 3960 :         {
; 3961 :             // Read character from OAT
; 3962 :             c = fgetc( fp );

  00038	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR fp$[rsp]
  00040	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fgetc
  00046	89 44 24 50	 mov	 DWORD PTR c$[rsp], eax

; 3963 : 
; 3964 :             // Check for I/O error
; 3965 :             if (ferror( fp ))

  0004a	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR fp$[rsp]
  00052	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ferror
  00058	85 c0		 test	 eax, eax
  0005a	0f 84 80 00 00
	00		 je	 $LN7@ReadOAT

; 3966 :             {
; 3967 :                 // "CTC: error in file %s: reading line %d: %s"
; 3968 :                 WRMSG( HHC00962, "E", pszOATName, iLine, strerror( errno ) );

  00060	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno
  00066	8b 08		 mov	 ecx, DWORD PTR [rax]
  00068	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_strerror
  0006e	48 89 44 24 60	 mov	 QWORD PTR tv71[rsp], rax
  00073	b9 01 00 00 00	 mov	 ecx, 1
  00078	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  0007e	48 8b 4c 24 60	 mov	 rcx, QWORD PTR tv71[rsp]
  00083	48 89 4c 24 48	 mov	 QWORD PTR [rsp+72], rcx
  00088	8b 4c 24 58	 mov	 ecx, DWORD PTR iLine$[rsp]
  0008c	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  00090	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR pszOATName$[rsp]
  00098	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  0009d	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG173043
  000a4	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  000a9	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG173044
  000b0	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  000b5	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  000ba	41 b9 03 00 00
	00		 mov	 r9d, 3
  000c0	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG173045
  000c7	ba 80 0f 00 00	 mov	 edx, 3968		; 00000f80H
  000cc	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG173046
  000d3	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 3969 :                 return NULL;

  000d9	33 c0		 xor	 eax, eax
  000db	e9 7e 01 00 00	 jmp	 $LN1@ReadOAT
$LN7@ReadOAT:

; 3970 :             }
; 3971 : 
; 3972 :             // Check for end of file
; 3973 :             if (iLen == 0 && ( c == EOF || c == '\x1A' ))

  000e0	83 7c 24 54 00	 cmp	 DWORD PTR iLen$[rsp], 0
  000e5	75 15		 jne	 SHORT $LN8@ReadOAT
  000e7	83 7c 24 50 ff	 cmp	 DWORD PTR c$[rsp], -1
  000ec	74 07		 je	 SHORT $LN9@ReadOAT
  000ee	83 7c 24 50 1a	 cmp	 DWORD PTR c$[rsp], 26
  000f3	75 07		 jne	 SHORT $LN8@ReadOAT
$LN9@ReadOAT:

; 3974 :                 return NULL;

  000f5	33 c0		 xor	 eax, eax
  000f7	e9 62 01 00 00	 jmp	 $LN1@ReadOAT
$LN8@ReadOAT:

; 3975 : 
; 3976 :             // Check for end of line
; 3977 :             if (c == '\n' || c == EOF || c == '\x1A')

  000fc	83 7c 24 50 0a	 cmp	 DWORD PTR c$[rsp], 10
  00101	74 0e		 je	 SHORT $LN11@ReadOAT
  00103	83 7c 24 50 ff	 cmp	 DWORD PTR c$[rsp], -1
  00108	74 07		 je	 SHORT $LN11@ReadOAT
  0010a	83 7c 24 50 1a	 cmp	 DWORD PTR c$[rsp], 26
  0010f	75 05		 jne	 SHORT $LN10@ReadOAT
$LN11@ReadOAT:

; 3978 :                 break;

  00111	e9 c2 00 00 00	 jmp	 $LN5@ReadOAT
$LN10@ReadOAT:

; 3979 : 
; 3980 :             // Ignore leading blanks and tabs
; 3981 :             if (iLen == 0 && ( c == ' ' || c == '\t' ))

  00116	83 7c 24 54 00	 cmp	 DWORD PTR iLen$[rsp], 0
  0011b	75 13		 jne	 SHORT $LN12@ReadOAT
  0011d	83 7c 24 50 20	 cmp	 DWORD PTR c$[rsp], 32	; 00000020H
  00122	74 07		 je	 SHORT $LN13@ReadOAT
  00124	83 7c 24 50 09	 cmp	 DWORD PTR c$[rsp], 9
  00129	75 05		 jne	 SHORT $LN12@ReadOAT
$LN13@ReadOAT:

; 3982 :                 continue;

  0012b	e9 08 ff ff ff	 jmp	 $LN4@ReadOAT
$LN12@ReadOAT:

; 3983 : 
; 3984 :             // Ignore nulls and carriage returns
; 3985 :             if (c == '\0' || c == '\r')

  00130	83 7c 24 50 00	 cmp	 DWORD PTR c$[rsp], 0
  00135	74 07		 je	 SHORT $LN15@ReadOAT
  00137	83 7c 24 50 0d	 cmp	 DWORD PTR c$[rsp], 13
  0013c	75 05		 jne	 SHORT $LN14@ReadOAT
$LN15@ReadOAT:

; 3986 :                 continue;

  0013e	e9 f5 fe ff ff	 jmp	 $LN4@ReadOAT
$LN14@ReadOAT:

; 3987 : 
; 3988 :             // Check that statement does not overflow bufffer
; 3989 :             if (iLen >= OAT_STMT_BUFSZ)

  00143	81 7c 24 54 ff
	00 00 00	 cmp	 DWORD PTR iLen$[rsp], 255 ; 000000ffH
  0014b	7c 67		 jl	 SHORT $LN16@ReadOAT

; 3990 :             {
; 3991 :                 // "CTC: error in file %s: line %d is too long"
; 3992 :                 WRMSG( HHC00963, "E", pszOATName, iLine );

  0014d	b9 01 00 00 00	 mov	 ecx, 1
  00152	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  00158	8b 4c 24 58	 mov	 ecx, DWORD PTR iLine$[rsp]
  0015c	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  00160	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR pszOATName$[rsp]
  00168	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  0016d	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG173056
  00174	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  00179	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG173057
  00180	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00185	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  0018a	41 b9 03 00 00
	00		 mov	 r9d, 3
  00190	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG173058
  00197	ba 98 0f 00 00	 mov	 edx, 3992		; 00000f98H
  0019c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG173059
  001a3	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 3993 :                 exit(1);

  001a9	b9 01 00 00 00	 mov	 ecx, 1
  001ae	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_exit
$LN16@ReadOAT:

; 3994 :             }
; 3995 : 
; 3996 :             // Append character to buffer
; 3997 :             pszBuff[iLen++] = c;

  001b4	48 63 44 24 54	 movsxd	 rax, DWORD PTR iLen$[rsp]
  001b9	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR pszBuff$[rsp]
  001c1	0f b6 54 24 50	 movzx	 edx, BYTE PTR c$[rsp]
  001c6	88 14 01	 mov	 BYTE PTR [rcx+rax], dl
  001c9	8b 44 24 54	 mov	 eax, DWORD PTR iLen$[rsp]
  001cd	ff c0		 inc	 eax
  001cf	89 44 24 54	 mov	 DWORD PTR iLen$[rsp], eax

; 3998 :         }

  001d3	e9 60 fe ff ff	 jmp	 $LN4@ReadOAT
$LN5@ReadOAT:

; 3999 : 
; 4000 :         // Null terminate buffer
; 4001 :         pszBuff[ iLen ] = 0;

  001d8	48 63 44 24 54	 movsxd	 rax, DWORD PTR iLen$[rsp]
  001dd	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR pszBuff$[rsp]
  001e5	c6 04 01 00	 mov	 BYTE PTR [rcx+rax], 0

; 4002 : 
; 4003 :         // Remove trailing whitespace
; 4004 :         RTRIM( pszBuff );

  001e9	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG173060
  001f0	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR pszBuff$[rsp]
  001f8	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_rtrim

; 4005 :         iLen = (int) strlen( pszBuff );

  001fe	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR pszBuff$[rsp]
  00206	e8 00 00 00 00	 call	 strlen
  0020b	89 44 24 54	 mov	 DWORD PTR iLen$[rsp], eax

; 4006 : 
; 4007 :         // Ignore comments and null statements
; 4008 :         if (!iLen || pszBuff[0] == '*' || pszBuff[0] == '#')

  0020f	83 7c 24 54 00	 cmp	 DWORD PTR iLen$[rsp], 0
  00214	74 34		 je	 SHORT $LN18@ReadOAT
  00216	b8 01 00 00 00	 mov	 eax, 1
  0021b	48 6b c0 00	 imul	 rax, rax, 0
  0021f	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR pszBuff$[rsp]
  00227	0f be 04 01	 movsx	 eax, BYTE PTR [rcx+rax]
  0022b	83 f8 2a	 cmp	 eax, 42			; 0000002aH
  0022e	74 1a		 je	 SHORT $LN18@ReadOAT
  00230	b8 01 00 00 00	 mov	 eax, 1
  00235	48 6b c0 00	 imul	 rax, rax, 0
  00239	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR pszBuff$[rsp]
  00241	0f be 04 01	 movsx	 eax, BYTE PTR [rcx+rax]
  00245	83 f8 23	 cmp	 eax, 35			; 00000023H
  00248	75 05		 jne	 SHORT $LN17@ReadOAT
$LN18@ReadOAT:

; 4009 :             continue;

  0024a	e9 cc fd ff ff	 jmp	 $LN2@ReadOAT
$LN17@ReadOAT:

; 4010 : 
; 4011 :         break;

  0024f	eb 05		 jmp	 SHORT $LN3@ReadOAT

; 4012 :     }

  00251	e9 c5 fd ff ff	 jmp	 $LN2@ReadOAT
$LN3@ReadOAT:

; 4013 : 
; 4014 :     return pszBuff;

  00256	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR pszBuff$[rsp]
$LN1@ReadOAT:
$LN19@ReadOAT:

; 4015 : }

  0025e	48 83 c4 78	 add	 rsp, 120		; 00000078H
  00262	c3		 ret	 0
ReadOAT	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\ctc_lcs.c
_TEXT	SEGMENT
c$ = 96
bType$ = 97
bMode$ = 98
sPort$ = 100
argc$ = 104
pLCSPORT$ = 112
sDevNum$ = 120
pLCSDev$ = 128
pLCSRTE$ = 136
i$ = 144
addr$ = 148
pszStatement$ = 152
pszOperand$ = 160
pszKeyword$ = 168
lIPAddr$ = 176
pszIPAddress$ = 184
pszNetAddr$ = 192
pOldLastLCSDEV$1 = 200
fp$ = 208
cl$2 = 216
strtok_str$ = 224
pszNetMask$ = 232
tv164 = 240
tv71 = 248
tv232 = 256
tv324 = 264
tv351 = 272
tv452 = 280
tv517 = 288
tv576 = 296
argv$ = 304
szBuff$ = 8496
pathname$ = 8752
msgbuf$3 = 9024
__$ArrayPad$ = 9376
pszOATName$ = 9408
pLCSBLK$ = 9416
BuildOAT PROC

; 3583 : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	57		 push	 rdi
  0000b	b8 b0 24 00 00	 mov	 eax, 9392		; 000024b0H
  00010	e8 00 00 00 00	 call	 __chkstk
  00015	48 2b e0	 sub	 rsp, rax
  00018	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  0001f	48 33 c4	 xor	 rax, rsp
  00022	48 89 84 24 a0
	24 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 3584 :     FILE*       fp;
; 3585 :     char        szBuff[OAT_STMT_BUFSZ];
; 3586 : 
; 3587 :     int         i;
; 3588 :     char        c;                      // Character work area
; 3589 :     char*       pszStatement = NULL;    // -> Resolved statement

  0002a	48 c7 84 24 98
	00 00 00 00 00
	00 00		 mov	 QWORD PTR pszStatement$[rsp], 0

; 3590 :     char*       pszKeyword;             // -> Statement keyword
; 3591 :     char*       pszOperand;             // -> Statement operand
; 3592 :     int         argc;                   // Number of args
; 3593 :     char*       argv[MAX_ARGS];         // Argument array
; 3594 : 
; 3595 :     PLCSPORT    pLCSPORT;
; 3596 :     PLCSDEV     pLCSDev;
; 3597 :     PLCSRTE     pLCSRTE;
; 3598 : 
; 3599 :     U16         sPort;
; 3600 :     BYTE        bMode;
; 3601 :     U16         sDevNum;
; 3602 :     BYTE        bType;
; 3603 :     U32         lIPAddr      = 0;       // (network byte order)

  00036	c7 84 24 b0 00
	00 00 00 00 00
	00		 mov	 DWORD PTR lIPAddr$[rsp], 0

; 3604 :     char*       pszIPAddress = NULL;

  00041	48 c7 84 24 b8
	00 00 00 00 00
	00 00		 mov	 QWORD PTR pszIPAddress$[rsp], 0

; 3605 :     char*       pszNetAddr   = NULL;

  0004d	48 c7 84 24 c0
	00 00 00 00 00
	00 00		 mov	 QWORD PTR pszNetAddr$[rsp], 0

; 3606 :     char*       pszNetMask   = NULL;

  00059	48 c7 84 24 e8
	00 00 00 00 00
	00 00		 mov	 QWORD PTR pszNetMask$[rsp], 0

; 3607 :     char*       strtok_str = NULL;

  00065	48 c7 84 24 e0
	00 00 00 00 00
	00 00		 mov	 QWORD PTR strtok_str$[rsp], 0

; 3608 : 
; 3609 :     struct in_addr  addr;               // Work area for IPv4 addresses
; 3610 :     char        pathname[MAX_PATH];     // pszOATName in host path format
; 3611 : 
; 3612 : 
; 3613 :     // Open the OAT configuration file
; 3614 :     hostpath(pathname, pszOATName, sizeof(pathname));

  00071	41 b8 04 01 00
	00		 mov	 r8d, 260		; 00000104H
  00077	48 8b 94 24 c0
	24 00 00	 mov	 rdx, QWORD PTR pszOATName$[rsp]
  0007f	48 8d 8c 24 30
	22 00 00	 lea	 rcx, QWORD PTR pathname$[rsp]
  00087	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hostpath

; 3615 :     fp = fopen( pathname, "r" );

  0008d	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG172881
  00094	48 8d 8c 24 30
	22 00 00	 lea	 rcx, QWORD PTR pathname$[rsp]
  0009c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fopen
  000a2	48 89 84 24 d0
	00 00 00	 mov	 QWORD PTR fp$[rsp], rax

; 3616 :     if (!fp)

  000aa	48 83 bc 24 d0
	00 00 00 00	 cmp	 QWORD PTR fp$[rsp], 0
  000b3	0f 85 a3 00 00
	00		 jne	 $LN17@BuildOAT

; 3617 :     {
; 3618 :         char msgbuf[MAX_PATH+80];
; 3619 :         MSGBUF( msgbuf, "fopen( \"%s\", \"r\" )", pathname);

  000b9	4c 8d 8c 24 30
	22 00 00	 lea	 r9, QWORD PTR pathname$[rsp]
  000c1	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG172883
  000c8	ba 54 01 00 00	 mov	 edx, 340		; 00000154H
  000cd	48 8d 8c 24 40
	23 00 00	 lea	 rcx, QWORD PTR msgbuf$3[rsp]
  000d5	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_snprintf

; 3620 :         // "CTC: error in function %s: %s"
; 3621 :         WRMSG( HHC00940, "E", msgbuf, strerror( errno ) );

  000db	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno
  000e1	8b 08		 mov	 ecx, DWORD PTR [rax]
  000e3	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_strerror
  000e9	48 89 84 24 f8
	00 00 00	 mov	 QWORD PTR tv71[rsp], rax
  000f1	b9 01 00 00 00	 mov	 ecx, 1
  000f6	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  000fc	48 8b 8c 24 f8
	00 00 00	 mov	 rcx, QWORD PTR tv71[rsp]
  00104	48 89 4c 24 40	 mov	 QWORD PTR [rsp+64], rcx
  00109	48 8d 8c 24 40
	23 00 00	 lea	 rcx, QWORD PTR msgbuf$3[rsp]
  00111	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  00116	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG172884
  0011d	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  00122	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG172885
  00129	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  0012e	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00133	41 b9 03 00 00
	00		 mov	 r9d, 3
  00139	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG172886
  00140	ba 25 0e 00 00	 mov	 edx, 3621		; 00000e25H
  00145	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG172887
  0014c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 3622 :         return -1;

  00152	b8 ff ff ff ff	 mov	 eax, -1
  00157	e9 4e 10 00 00	 jmp	 $LN1@BuildOAT
$LN17@BuildOAT:
$LN2@BuildOAT:

; 3623 :     }
; 3624 : 
; 3625 :     for (;;)
; 3626 :     {
; 3627 :         // Read next record from the OAT file
; 3628 :         if (!ReadOAT( pszOATName, fp, szBuff ))

  0015c	4c 8d 84 24 30
	21 00 00	 lea	 r8, QWORD PTR szBuff$[rsp]
  00164	48 8b 94 24 d0
	00 00 00	 mov	 rdx, QWORD PTR fp$[rsp]
  0016c	48 8b 8c 24 c0
	24 00 00	 mov	 rcx, QWORD PTR pszOATName$[rsp]
  00174	e8 00 00 00 00	 call	 ReadOAT
  00179	48 85 c0	 test	 rax, rax
  0017c	75 15		 jne	 SHORT $LN18@BuildOAT

; 3629 :         {
; 3630 :             fclose( fp );

  0017e	48 8b 8c 24 d0
	00 00 00	 mov	 rcx, QWORD PTR fp$[rsp]
  00186	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_fclose

; 3631 :             return 0;

  0018c	33 c0		 xor	 eax, eax
  0018e	e9 17 10 00 00	 jmp	 $LN1@BuildOAT
$LN18@BuildOAT:

; 3632 :         }
; 3633 : 
; 3634 :         if (pszStatement)

  00193	48 83 bc 24 98
	00 00 00 00	 cmp	 QWORD PTR pszStatement$[rsp], 0
  0019c	74 1a		 je	 SHORT $LN19@BuildOAT

; 3635 :         {
; 3636 :             free( pszStatement );

  0019e	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR pszStatement$[rsp]
  001a6	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free

; 3637 :             pszStatement = NULL;

  001ac	48 c7 84 24 98
	00 00 00 00 00
	00 00		 mov	 QWORD PTR pszStatement$[rsp], 0
$LN19@BuildOAT:

; 3638 :         }
; 3639 : 
; 3640 :         // Make a copy of the OAT statement
; 3641 :         pszStatement = strdup( szBuff );

  001b8	48 8d 8c 24 30
	21 00 00	 lea	 rcx, QWORD PTR szBuff$[rsp]
  001c0	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_strdup
  001c6	48 89 84 24 98
	00 00 00	 mov	 QWORD PTR pszStatement$[rsp], rax

; 3642 : 
; 3643 :         /* Perform variable substitution */
; 3644 :         {
; 3645 :             char *cl;
; 3646 : 
; 3647 :             set_symbol( "CUU",  "$(CUU)"  );

  001ce	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG172890
  001d5	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG172891
  001dc	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_set_symbol

; 3648 :             set_symbol( "CCUU", "$(CCUU)" );

  001e2	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG172892
  001e9	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG172893
  001f0	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_set_symbol

; 3649 :             set_symbol( "DEVN", "$(DEVN)" );

  001f6	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG172894
  001fd	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG172895
  00204	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_set_symbol

; 3650 : 
; 3651 :             cl = resolve_symbol_string( pszStatement );

  0020a	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR pszStatement$[rsp]
  00212	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_resolve_symbol_string
  00218	48 89 84 24 d8
	00 00 00	 mov	 QWORD PTR cl$2[rsp], rax

; 3652 : 
; 3653 :             if (cl)

  00220	48 83 bc 24 d8
	00 00 00 00	 cmp	 QWORD PTR cl$2[rsp], 0
  00229	74 4e		 je	 SHORT $LN20@BuildOAT

; 3654 :             {
; 3655 :                 STRLCPY( szBuff, cl );

  0022b	41 b8 ff 00 00
	00		 mov	 r8d, 255		; 000000ffH
  00231	48 8b 94 24 d8
	00 00 00	 mov	 rdx, QWORD PTR cl$2[rsp]
  00239	48 8d 8c 24 30
	21 00 00	 lea	 rcx, QWORD PTR szBuff$[rsp]
  00241	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_strlcpy

; 3656 :                 free( cl );

  00247	48 8b 8c 24 d8
	00 00 00	 mov	 rcx, QWORD PTR cl$2[rsp]
  0024f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free

; 3657 :                 free( pszStatement );

  00255	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR pszStatement$[rsp]
  0025d	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free

; 3658 :                 pszStatement = strdup( szBuff );

  00263	48 8d 8c 24 30
	21 00 00	 lea	 rcx, QWORD PTR szBuff$[rsp]
  0026b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_strdup
  00271	48 89 84 24 98
	00 00 00	 mov	 QWORD PTR pszStatement$[rsp], rax
$LN20@BuildOAT:

; 3659 :             }
; 3660 :         }
; 3661 : 
; 3662 :         sPort        = 0;

  00279	33 c0		 xor	 eax, eax
  0027b	66 89 44 24 64	 mov	 WORD PTR sPort$[rsp], ax

; 3663 :         bMode        = 0;

  00280	c6 44 24 62 00	 mov	 BYTE PTR bMode$[rsp], 0

; 3664 :         sDevNum      = 0;

  00285	33 c0		 xor	 eax, eax
  00287	66 89 44 24 78	 mov	 WORD PTR sDevNum$[rsp], ax

; 3665 :         bType        = 0;

  0028c	c6 44 24 61 00	 mov	 BYTE PTR bType$[rsp], 0

; 3666 :         pszIPAddress = NULL;

  00291	48 c7 84 24 b8
	00 00 00 00 00
	00 00		 mov	 QWORD PTR pszIPAddress$[rsp], 0

; 3667 :         pszNetAddr   = NULL;

  0029d	48 c7 84 24 c0
	00 00 00 00 00
	00 00		 mov	 QWORD PTR pszNetAddr$[rsp], 0

; 3668 :         pszNetMask   = NULL;

  002a9	48 c7 84 24 e8
	00 00 00 00 00
	00 00		 mov	 QWORD PTR pszNetMask$[rsp], 0

; 3669 : 
; 3670 :         memset( &addr, 0, sizeof( addr ) );

  002b5	48 8d 84 24 94
	00 00 00	 lea	 rax, QWORD PTR addr$[rsp]
  002bd	48 8b f8	 mov	 rdi, rax
  002c0	33 c0		 xor	 eax, eax
  002c2	b9 04 00 00 00	 mov	 ecx, 4
  002c7	f3 aa		 rep stosb

; 3671 : 
; 3672 :         // Split the statement into keyword and first operand
; 3673 :         pszKeyword = strtok_r( pszStatement, " \t", &strtok_str );

  002c9	4c 8d 84 24 e0
	00 00 00	 lea	 r8, QWORD PTR strtok_str$[rsp]
  002d1	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG172897
  002d8	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR pszStatement$[rsp]
  002e0	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_strtok_r
  002e6	48 89 84 24 a8
	00 00 00	 mov	 QWORD PTR pszKeyword$[rsp], rax

; 3674 :         pszOperand = strtok_r( NULL,   " \t", &strtok_str );

  002ee	4c 8d 84 24 e0
	00 00 00	 lea	 r8, QWORD PTR strtok_str$[rsp]
  002f6	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG172898
  002fd	33 c9		 xor	 ecx, ecx
  002ff	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_strtok_r
  00305	48 89 84 24 a0
	00 00 00	 mov	 QWORD PTR pszOperand$[rsp], rax

; 3675 : 
; 3676 :         // Extract any arguments
; 3677 :         for (argc = 0;

  0030d	c7 44 24 68 00
	00 00 00	 mov	 DWORD PTR argc$[rsp], 0
  00315	eb 0a		 jmp	 SHORT $LN7@BuildOAT
$LN5@BuildOAT:

; 3680 :                  argv[argc][0] != '#';
; 3681 :              argc++)

  00317	8b 44 24 68	 mov	 eax, DWORD PTR argc$[rsp]
  0031b	ff c0		 inc	 eax
  0031d	89 44 24 68	 mov	 DWORD PTR argc$[rsp], eax
$LN7@BuildOAT:

; 3678 :              argc < MAX_ARGS &&
; 3679 :                  ( argv[argc] = strtok_r( NULL, " \t", &strtok_str ) ) != NULL &&

  00321	81 7c 24 68 00
	04 00 00	 cmp	 DWORD PTR argc$[rsp], 1024 ; 00000400H
  00329	7d 60		 jge	 SHORT $LN6@BuildOAT
  0032b	4c 8d 84 24 e0
	00 00 00	 lea	 r8, QWORD PTR strtok_str$[rsp]
  00333	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG172899
  0033a	33 c9		 xor	 ecx, ecx
  0033c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_strtok_r
  00342	48 89 84 24 f0
	00 00 00	 mov	 QWORD PTR tv164[rsp], rax
  0034a	48 63 44 24 68	 movsxd	 rax, DWORD PTR argc$[rsp]
  0034f	48 8b 8c 24 f0
	00 00 00	 mov	 rcx, QWORD PTR tv164[rsp]
  00357	48 89 8c c4 30
	01 00 00	 mov	 QWORD PTR argv$[rsp+rax*8], rcx
  0035f	48 83 bc 24 f0
	00 00 00 00	 cmp	 QWORD PTR tv164[rsp], 0
  00368	74 21		 je	 SHORT $LN6@BuildOAT
  0036a	48 63 44 24 68	 movsxd	 rax, DWORD PTR argc$[rsp]
  0036f	b9 01 00 00 00	 mov	 ecx, 1
  00374	48 6b c9 00	 imul	 rcx, rcx, 0
  00378	48 8b 84 c4 30
	01 00 00	 mov	 rax, QWORD PTR argv$[rsp+rax*8]
  00380	0f be 04 08	 movsx	 eax, BYTE PTR [rax+rcx]
  00384	83 f8 23	 cmp	 eax, 35			; 00000023H
  00387	74 02		 je	 SHORT $LN6@BuildOAT

; 3682 :                  /* nop */
; 3683 :                  ;

  00389	eb 8c		 jmp	 SHORT $LN5@BuildOAT
$LN6@BuildOAT:

; 3684 : 
; 3685 :         // Clear any unused argument pointers
; 3686 :         for (i = argc; i < MAX_ARGS; i++)

  0038b	8b 44 24 68	 mov	 eax, DWORD PTR argc$[rsp]
  0038f	89 84 24 90 00
	00 00		 mov	 DWORD PTR i$[rsp], eax
  00396	eb 10		 jmp	 SHORT $LN10@BuildOAT
$LN8@BuildOAT:
  00398	8b 84 24 90 00
	00 00		 mov	 eax, DWORD PTR i$[rsp]
  0039f	ff c0		 inc	 eax
  003a1	89 84 24 90 00
	00 00		 mov	 DWORD PTR i$[rsp], eax
$LN10@BuildOAT:
  003a8	81 bc 24 90 00
	00 00 00 04 00
	00		 cmp	 DWORD PTR i$[rsp], 1024	; 00000400H
  003b3	7d 16		 jge	 SHORT $LN9@BuildOAT

; 3687 :             argv[i] = NULL;

  003b5	48 63 84 24 90
	00 00 00	 movsxd	 rax, DWORD PTR i$[rsp]
  003bd	48 c7 84 c4 30
	01 00 00 00 00
	00 00		 mov	 QWORD PTR argv$[rsp+rax*8], 0
  003c9	eb cd		 jmp	 SHORT $LN8@BuildOAT
$LN9@BuildOAT:

; 3688 : 
; 3689 :         if (strcasecmp( pszKeyword, "HWADD" ) == 0)

  003cb	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG172902
  003d2	48 8b 8c 24 a8
	00 00 00	 mov	 rcx, QWORD PTR pszKeyword$[rsp]
  003da	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__stricmp
  003e0	85 c0		 test	 eax, eax
  003e2	0f 85 33 02 00
	00		 jne	 $LN21@BuildOAT

; 3690 :         {
; 3691 :             if (!pszOperand        ||
; 3692 :                 argc       != 1    ||

  003e8	48 83 bc 24 a0
	00 00 00 00	 cmp	 QWORD PTR pszOperand$[rsp], 0
  003f1	74 2a		 je	 SHORT $LN24@BuildOAT
  003f3	83 7c 24 68 01	 cmp	 DWORD PTR argc$[rsp], 1
  003f8	75 23		 jne	 SHORT $LN24@BuildOAT
  003fa	4c 8d 4c 24 60	 lea	 r9, QWORD PTR c$[rsp]
  003ff	4c 8d 44 24 64	 lea	 r8, QWORD PTR sPort$[rsp]
  00404	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG172905
  0040b	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR pszOperand$[rsp]
  00413	e8 00 00 00 00	 call	 sscanf
  00418	83 f8 01	 cmp	 eax, 1
  0041b	74 77		 je	 SHORT $LN23@BuildOAT
$LN24@BuildOAT:

; 3693 :                 sscanf( pszOperand, "%hi%c", &sPort, &c ) != 1)
; 3694 :             {
; 3695 :                 // "CTC: invalid statement %s in file %s: %s"
; 3696 :                 WRMSG( HHC00954, "E", "HWADD", pszOATName, szBuff );

  0041d	b9 01 00 00 00	 mov	 ecx, 1
  00422	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  00428	48 8d 8c 24 30
	21 00 00	 lea	 rcx, QWORD PTR szBuff$[rsp]
  00430	48 89 4c 24 48	 mov	 QWORD PTR [rsp+72], rcx
  00435	48 8b 8c 24 c0
	24 00 00	 mov	 rcx, QWORD PTR pszOATName$[rsp]
  0043d	48 89 4c 24 40	 mov	 QWORD PTR [rsp+64], rcx
  00442	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG172906
  00449	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  0044e	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG172907
  00455	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  0045a	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG172908
  00461	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00466	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  0046b	41 b9 03 00 00
	00		 mov	 r9d, 3
  00471	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG172909
  00478	ba 70 0e 00 00	 mov	 edx, 3696		; 00000e70H
  0047d	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG172910
  00484	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 3697 :                 return -1;

  0048a	b8 ff ff ff ff	 mov	 eax, -1
  0048f	e9 16 0d 00 00	 jmp	 $LN1@BuildOAT
$LN23@BuildOAT:

; 3698 :             }
; 3699 : 
; 3700 :             pLCSPORT = &pLCSBLK->Port[sPort];

  00494	0f b7 44 24 64	 movzx	 eax, WORD PTR sPort$[rsp]
  00499	48 69 c0 98 01
	00 00		 imul	 rax, rax, 408		; 00000198H
  004a0	48 8b 8c 24 c8
	24 00 00	 mov	 rcx, QWORD PTR pLCSBLK$[rsp]
  004a8	48 8d 44 01 60	 lea	 rax, QWORD PTR [rcx+rax+96]
  004ad	48 89 44 24 70	 mov	 QWORD PTR pLCSPORT$[rsp], rax

; 3701 : 
; 3702 :             if (0
; 3703 :                 || ParseMAC( argv[0], pLCSPORT->MAC_Address ) != 0
; 3704 :                 || !(pLCSPORT->MAC_Address[0] & 0x02)
; 3705 :                 ||  (pLCSPORT->MAC_Address[0] & 0x01)

  004b2	33 c0		 xor	 eax, eax
  004b4	85 c0		 test	 eax, eax
  004b6	75 5e		 jne	 SHORT $LN26@BuildOAT
  004b8	48 8b 44 24 70	 mov	 rax, QWORD PTR pLCSPORT$[rsp]
  004bd	48 83 c0 02	 add	 rax, 2
  004c1	b9 08 00 00 00	 mov	 ecx, 8
  004c6	48 6b c9 00	 imul	 rcx, rcx, 0
  004ca	48 8b d0	 mov	 rdx, rax
  004cd	48 8b 8c 0c 30
	01 00 00	 mov	 rcx, QWORD PTR argv$[rsp+rcx]
  004d5	e8 00 00 00 00	 call	 ParseMAC
  004da	85 c0		 test	 eax, eax
  004dc	75 38		 jne	 SHORT $LN26@BuildOAT
  004de	b8 01 00 00 00	 mov	 eax, 1
  004e3	48 6b c0 00	 imul	 rax, rax, 0
  004e7	48 8b 4c 24 70	 mov	 rcx, QWORD PTR pLCSPORT$[rsp]
  004ec	0f b6 44 01 02	 movzx	 eax, BYTE PTR [rcx+rax+2]
  004f1	83 e0 02	 and	 eax, 2
  004f4	85 c0		 test	 eax, eax
  004f6	74 1e		 je	 SHORT $LN26@BuildOAT
  004f8	b8 01 00 00 00	 mov	 eax, 1
  004fd	48 6b c0 00	 imul	 rax, rax, 0
  00501	48 8b 4c 24 70	 mov	 rcx, QWORD PTR pLCSPORT$[rsp]
  00506	0f b6 44 01 02	 movzx	 eax, BYTE PTR [rcx+rax+2]
  0050b	83 e0 01	 and	 eax, 1
  0050e	85 c0		 test	 eax, eax
  00510	0f 84 be 00 00
	00		 je	 $LN25@BuildOAT
$LN26@BuildOAT:

; 3706 :             )
; 3707 :             {
; 3708 :                 // "CTC: invalid %s %s in statement %s in file %s: %s"
; 3709 :                 WRMSG( HHC00955, "E", "MAC", argv[0], "HWADD", pszOATName, szBuff );

  00516	b8 08 00 00 00	 mov	 eax, 8
  0051b	48 6b c0 00	 imul	 rax, rax, 0
  0051f	48 89 84 24 00
	01 00 00	 mov	 QWORD PTR tv232[rsp], rax
  00527	b9 01 00 00 00	 mov	 ecx, 1
  0052c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  00532	48 8d 8c 24 30
	21 00 00	 lea	 rcx, QWORD PTR szBuff$[rsp]
  0053a	48 89 4c 24 58	 mov	 QWORD PTR [rsp+88], rcx
  0053f	48 8b 8c 24 c0
	24 00 00	 mov	 rcx, QWORD PTR pszOATName$[rsp]
  00547	48 89 4c 24 50	 mov	 QWORD PTR [rsp+80], rcx
  0054c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG172913
  00553	48 89 4c 24 48	 mov	 QWORD PTR [rsp+72], rcx
  00558	48 8b 8c 24 00
	01 00 00	 mov	 rcx, QWORD PTR tv232[rsp]
  00560	48 8b 8c 0c 30
	01 00 00	 mov	 rcx, QWORD PTR argv$[rsp+rcx]
  00568	48 89 4c 24 40	 mov	 QWORD PTR [rsp+64], rcx
  0056d	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG172914
  00574	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  00579	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG172915
  00580	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  00585	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG172916
  0058c	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00591	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00596	41 b9 03 00 00
	00		 mov	 r9d, 3
  0059c	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG172917
  005a3	ba 7d 0e 00 00	 mov	 edx, 3709		; 00000e7dH
  005a8	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG172918
  005af	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 3710 : 
; 3711 :                 memset( pLCSPORT->MAC_Address, 0, IFHWADDRLEN );

  005b5	48 8b 44 24 70	 mov	 rax, QWORD PTR pLCSPORT$[rsp]
  005ba	48 83 c0 02	 add	 rax, 2
  005be	48 8b f8	 mov	 rdi, rax
  005c1	33 c0		 xor	 eax, eax
  005c3	b9 06 00 00 00	 mov	 ecx, 6
  005c8	f3 aa		 rep stosb

; 3712 :                 return -1;

  005ca	b8 ff ff ff ff	 mov	 eax, -1
  005cf	e9 d6 0b 00 00	 jmp	 $LN1@BuildOAT
$LN25@BuildOAT:

; 3713 :             }
; 3714 : 
; 3715 :             STRLCPY( pLCSPORT->szMACAddress, argv[0] );

  005d4	b8 08 00 00 00	 mov	 eax, 8
  005d9	48 6b c0 00	 imul	 rax, rax, 0
  005dd	48 8b 4c 24 70	 mov	 rcx, QWORD PTR pLCSPORT$[rsp]
  005e2	48 81 c1 58 01
	00 00		 add	 rcx, 344		; 00000158H
  005e9	41 b8 20 00 00
	00		 mov	 r8d, 32			; 00000020H
  005ef	48 8b 94 04 30
	01 00 00	 mov	 rdx, QWORD PTR argv$[rsp+rax]
  005f7	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_strlcpy

; 3716 :             pLCSPORT->fLocalMAC = TRUE;

  005fd	48 8b 44 24 70	 mov	 rax, QWORD PTR pLCSPORT$[rsp]
  00602	8b 80 34 01 00
	00		 mov	 eax, DWORD PTR [rax+308]
  00608	83 c8 02	 or	 eax, 2
  0060b	48 8b 4c 24 70	 mov	 rcx, QWORD PTR pLCSPORT$[rsp]
  00610	89 81 34 01 00
	00		 mov	 DWORD PTR [rcx+308], eax

; 3717 :         }

  00616	e9 8a 0b 00 00	 jmp	 $LN22@BuildOAT
$LN21@BuildOAT:

; 3718 :         else if (strcasecmp( pszKeyword, "ROUTE" ) == 0)

  0061b	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG172921
  00622	48 8b 8c 24 a8
	00 00 00	 mov	 rcx, QWORD PTR pszKeyword$[rsp]
  0062a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__stricmp
  00630	85 c0		 test	 eax, eax
  00632	0f 85 88 03 00
	00		 jne	 $LN27@BuildOAT

; 3719 :         {
; 3720 :             if (!pszOperand        ||
; 3721 :                 argc       != 2    ||

  00638	48 83 bc 24 a0
	00 00 00 00	 cmp	 QWORD PTR pszOperand$[rsp], 0
  00641	74 2a		 je	 SHORT $LN30@BuildOAT
  00643	83 7c 24 68 02	 cmp	 DWORD PTR argc$[rsp], 2
  00648	75 23		 jne	 SHORT $LN30@BuildOAT
  0064a	4c 8d 4c 24 60	 lea	 r9, QWORD PTR c$[rsp]
  0064f	4c 8d 44 24 64	 lea	 r8, QWORD PTR sPort$[rsp]
  00654	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG172924
  0065b	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR pszOperand$[rsp]
  00663	e8 00 00 00 00	 call	 sscanf
  00668	83 f8 01	 cmp	 eax, 1
  0066b	74 77		 je	 SHORT $LN29@BuildOAT
$LN30@BuildOAT:

; 3722 :                 sscanf( pszOperand, "%hi%c", &sPort, &c ) != 1)
; 3723 :             {
; 3724 :                 // "CTC: invalid statement %s in file %s: %s"
; 3725 :                 WRMSG( HHC00954, "E", "ROUTE", pszOATName, szBuff );

  0066d	b9 01 00 00 00	 mov	 ecx, 1
  00672	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  00678	48 8d 8c 24 30
	21 00 00	 lea	 rcx, QWORD PTR szBuff$[rsp]
  00680	48 89 4c 24 48	 mov	 QWORD PTR [rsp+72], rcx
  00685	48 8b 8c 24 c0
	24 00 00	 mov	 rcx, QWORD PTR pszOATName$[rsp]
  0068d	48 89 4c 24 40	 mov	 QWORD PTR [rsp+64], rcx
  00692	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG172925
  00699	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  0069e	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG172926
  006a5	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  006aa	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG172927
  006b1	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  006b6	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  006bb	41 b9 03 00 00
	00		 mov	 r9d, 3
  006c1	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG172928
  006c8	ba 8d 0e 00 00	 mov	 edx, 3725		; 00000e8dH
  006cd	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG172929
  006d4	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 3726 :                 return -1;

  006da	b8 ff ff ff ff	 mov	 eax, -1
  006df	e9 c6 0a 00 00	 jmp	 $LN1@BuildOAT
$LN29@BuildOAT:

; 3727 :             }
; 3728 : 
; 3729 :             if (inet_aton( argv[0], &addr ) == 0)

  006e4	b8 08 00 00 00	 mov	 eax, 8
  006e9	48 6b c0 00	 imul	 rax, rax, 0
  006ed	48 8d 94 24 94
	00 00 00	 lea	 rdx, QWORD PTR addr$[rsp]
  006f5	48 8b 8c 04 30
	01 00 00	 mov	 rcx, QWORD PTR argv$[rsp+rax]
  006fd	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_inet_aton
  00703	85 c0		 test	 eax, eax
  00705	0f 85 a9 00 00
	00		 jne	 $LN31@BuildOAT

; 3730 :             {
; 3731 :                 // "CTC: invalid %s %s in statement %s in file %s: %s"
; 3732 :                 WRMSG( HHC00955, "E", "net address", argv[0], "ROUTE", pszOATName, szBuff );

  0070b	b8 08 00 00 00	 mov	 eax, 8
  00710	48 6b c0 00	 imul	 rax, rax, 0
  00714	48 89 84 24 08
	01 00 00	 mov	 QWORD PTR tv324[rsp], rax
  0071c	b9 01 00 00 00	 mov	 ecx, 1
  00721	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  00727	48 8d 8c 24 30
	21 00 00	 lea	 rcx, QWORD PTR szBuff$[rsp]
  0072f	48 89 4c 24 58	 mov	 QWORD PTR [rsp+88], rcx
  00734	48 8b 8c 24 c0
	24 00 00	 mov	 rcx, QWORD PTR pszOATName$[rsp]
  0073c	48 89 4c 24 50	 mov	 QWORD PTR [rsp+80], rcx
  00741	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG172931
  00748	48 89 4c 24 48	 mov	 QWORD PTR [rsp+72], rcx
  0074d	48 8b 8c 24 08
	01 00 00	 mov	 rcx, QWORD PTR tv324[rsp]
  00755	48 8b 8c 0c 30
	01 00 00	 mov	 rcx, QWORD PTR argv$[rsp+rcx]
  0075d	48 89 4c 24 40	 mov	 QWORD PTR [rsp+64], rcx
  00762	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG172932
  00769	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  0076e	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG172933
  00775	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  0077a	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG172934
  00781	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00786	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  0078b	41 b9 03 00 00
	00		 mov	 r9d, 3
  00791	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG172935
  00798	ba 94 0e 00 00	 mov	 edx, 3732		; 00000e94H
  0079d	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG172936
  007a4	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 3733 :                 return -1;

  007aa	b8 ff ff ff ff	 mov	 eax, -1
  007af	e9 f6 09 00 00	 jmp	 $LN1@BuildOAT
$LN31@BuildOAT:

; 3734 :             }
; 3735 : 
; 3736 :             pszNetAddr = strdup( argv[0] );

  007b4	b8 08 00 00 00	 mov	 eax, 8
  007b9	48 6b c0 00	 imul	 rax, rax, 0
  007bd	48 8b 8c 04 30
	01 00 00	 mov	 rcx, QWORD PTR argv$[rsp+rax]
  007c5	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_strdup
  007cb	48 89 84 24 c0
	00 00 00	 mov	 QWORD PTR pszNetAddr$[rsp], rax

; 3737 : 
; 3738 :             if (inet_aton( argv[1], &addr ) == 0)

  007d3	b8 08 00 00 00	 mov	 eax, 8
  007d8	48 6b c0 01	 imul	 rax, rax, 1
  007dc	48 8d 94 24 94
	00 00 00	 lea	 rdx, QWORD PTR addr$[rsp]
  007e4	48 8b 8c 04 30
	01 00 00	 mov	 rcx, QWORD PTR argv$[rsp+rax]
  007ec	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_inet_aton
  007f2	85 c0		 test	 eax, eax
  007f4	0f 85 b7 00 00
	00		 jne	 $LN32@BuildOAT

; 3739 :             {
; 3740 :                 free(pszNetAddr);

  007fa	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR pszNetAddr$[rsp]
  00802	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free

; 3741 :                 // "CTC: invalid %s %s in statement %s in file %s: %s"
; 3742 :                 WRMSG( HHC00955, "E", "netmask", argv[1], "ROUTE", pszOATName, szBuff );

  00808	b8 08 00 00 00	 mov	 eax, 8
  0080d	48 6b c0 01	 imul	 rax, rax, 1
  00811	48 89 84 24 10
	01 00 00	 mov	 QWORD PTR tv351[rsp], rax
  00819	b9 01 00 00 00	 mov	 ecx, 1
  0081e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  00824	48 8d 8c 24 30
	21 00 00	 lea	 rcx, QWORD PTR szBuff$[rsp]
  0082c	48 89 4c 24 58	 mov	 QWORD PTR [rsp+88], rcx
  00831	48 8b 8c 24 c0
	24 00 00	 mov	 rcx, QWORD PTR pszOATName$[rsp]
  00839	48 89 4c 24 50	 mov	 QWORD PTR [rsp+80], rcx
  0083e	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG172938
  00845	48 89 4c 24 48	 mov	 QWORD PTR [rsp+72], rcx
  0084a	48 8b 8c 24 10
	01 00 00	 mov	 rcx, QWORD PTR tv351[rsp]
  00852	48 8b 8c 0c 30
	01 00 00	 mov	 rcx, QWORD PTR argv$[rsp+rcx]
  0085a	48 89 4c 24 40	 mov	 QWORD PTR [rsp+64], rcx
  0085f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG172939
  00866	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  0086b	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG172940
  00872	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  00877	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG172941
  0087e	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00883	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00888	41 b9 03 00 00
	00		 mov	 r9d, 3
  0088e	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG172942
  00895	ba 9e 0e 00 00	 mov	 edx, 3742		; 00000e9eH
  0089a	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG172943
  008a1	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 3743 :                 return -1;

  008a7	b8 ff ff ff ff	 mov	 eax, -1
  008ac	e9 f9 08 00 00	 jmp	 $LN1@BuildOAT
$LN32@BuildOAT:

; 3744 :             }
; 3745 : 
; 3746 :             pszNetMask = strdup( argv[1] );

  008b1	b8 08 00 00 00	 mov	 eax, 8
  008b6	48 6b c0 01	 imul	 rax, rax, 1
  008ba	48 8b 8c 04 30
	01 00 00	 mov	 rcx, QWORD PTR argv$[rsp+rax]
  008c2	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_strdup
  008c8	48 89 84 24 e8
	00 00 00	 mov	 QWORD PTR pszNetMask$[rsp], rax

; 3747 : 
; 3748 :             pLCSPORT = &pLCSBLK->Port[sPort];

  008d0	0f b7 44 24 64	 movzx	 eax, WORD PTR sPort$[rsp]
  008d5	48 69 c0 98 01
	00 00		 imul	 rax, rax, 408		; 00000198H
  008dc	48 8b 8c 24 c8
	24 00 00	 mov	 rcx, QWORD PTR pLCSBLK$[rsp]
  008e4	48 8d 44 01 60	 lea	 rax, QWORD PTR [rcx+rax+96]
  008e9	48 89 44 24 70	 mov	 QWORD PTR pLCSPORT$[rsp], rax

; 3749 : 
; 3750 :             if (!pLCSPORT->pRoutes)

  008ee	48 8b 44 24 70	 mov	 rax, QWORD PTR pLCSPORT$[rsp]
  008f3	48 83 78 08 00	 cmp	 QWORD PTR [rax+8], 0
  008f8	75 27		 jne	 SHORT $LN33@BuildOAT

; 3751 :             {
; 3752 :                 pLCSPORT->pRoutes = malloc( sizeof( LCSRTE ) );

  008fa	b9 18 00 00 00	 mov	 ecx, 24
  008ff	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_malloc
  00905	48 8b 4c 24 70	 mov	 rcx, QWORD PTR pLCSPORT$[rsp]
  0090a	48 89 41 08	 mov	 QWORD PTR [rcx+8], rax

; 3753 :                 pLCSRTE = pLCSPORT->pRoutes;

  0090e	48 8b 44 24 70	 mov	 rax, QWORD PTR pLCSPORT$[rsp]
  00913	48 8b 40 08	 mov	 rax, QWORD PTR [rax+8]
  00917	48 89 84 24 88
	00 00 00	 mov	 QWORD PTR pLCSRTE$[rsp], rax

; 3754 :             }

  0091f	eb 63		 jmp	 SHORT $LN34@BuildOAT
$LN33@BuildOAT:

; 3755 :             else
; 3756 :             {
; 3757 :                 for (pLCSRTE = pLCSPORT->pRoutes;

  00921	48 8b 44 24 70	 mov	 rax, QWORD PTR pLCSPORT$[rsp]
  00926	48 8b 40 08	 mov	 rax, QWORD PTR [rax+8]
  0092a	48 89 84 24 88
	00 00 00	 mov	 QWORD PTR pLCSRTE$[rsp], rax
  00932	eb 14		 jmp	 SHORT $LN13@BuildOAT
$LN11@BuildOAT:

; 3759 :                      pLCSRTE = pLCSRTE->pNext);

  00934	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR pLCSRTE$[rsp]
  0093c	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  00940	48 89 84 24 88
	00 00 00	 mov	 QWORD PTR pLCSRTE$[rsp], rax
$LN13@BuildOAT:

; 3758 :                      pLCSRTE->pNext;

  00948	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR pLCSRTE$[rsp]
  00950	48 83 78 10 00	 cmp	 QWORD PTR [rax+16], 0
  00955	74 02		 je	 SHORT $LN12@BuildOAT

; 3759 :                      pLCSRTE = pLCSRTE->pNext);

  00957	eb db		 jmp	 SHORT $LN11@BuildOAT
$LN12@BuildOAT:

; 3760 : 
; 3761 :                 pLCSRTE->pNext = malloc( sizeof( LCSRTE ) );

  00959	b9 18 00 00 00	 mov	 ecx, 24
  0095e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_malloc
  00964	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR pLCSRTE$[rsp]
  0096c	48 89 41 10	 mov	 QWORD PTR [rcx+16], rax

; 3762 :                 pLCSRTE = pLCSRTE->pNext;

  00970	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR pLCSRTE$[rsp]
  00978	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  0097c	48 89 84 24 88
	00 00 00	 mov	 QWORD PTR pLCSRTE$[rsp], rax
$LN34@BuildOAT:

; 3763 :             }
; 3764 : 
; 3765 :             pLCSRTE->pszNetAddr = pszNetAddr;

  00984	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR pLCSRTE$[rsp]
  0098c	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR pszNetAddr$[rsp]
  00994	48 89 08	 mov	 QWORD PTR [rax], rcx

; 3766 :             pLCSRTE->pszNetMask = pszNetMask;

  00997	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR pLCSRTE$[rsp]
  0099f	48 8b 8c 24 e8
	00 00 00	 mov	 rcx, QWORD PTR pszNetMask$[rsp]
  009a7	48 89 48 08	 mov	 QWORD PTR [rax+8], rcx

; 3767 :             pLCSRTE->pNext      = NULL;

  009ab	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR pLCSRTE$[rsp]
  009b3	48 c7 40 10 00
	00 00 00	 mov	 QWORD PTR [rax+16], 0

; 3768 :         }

  009bb	e9 e5 07 00 00	 jmp	 $LN28@BuildOAT
$LN27@BuildOAT:

; 3769 :         else // (presumed OAT file device statement)
; 3770 :         {
; 3771 :             if (!pszKeyword || !pszOperand)

  009c0	48 83 bc 24 a8
	00 00 00 00	 cmp	 QWORD PTR pszKeyword$[rsp], 0
  009c9	74 0b		 je	 SHORT $LN36@BuildOAT
  009cb	48 83 bc 24 a0
	00 00 00 00	 cmp	 QWORD PTR pszOperand$[rsp], 0
  009d4	75 5e		 jne	 SHORT $LN35@BuildOAT
$LN36@BuildOAT:

; 3772 :             {
; 3773 :                 // "CTC: error in file %s: missing device number or mode"
; 3774 :                 WRMSG( HHC00956, "E", pszOATName );

  009d6	b9 01 00 00 00	 mov	 ecx, 1
  009db	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  009e1	48 8b 8c 24 c0
	24 00 00	 mov	 rcx, QWORD PTR pszOATName$[rsp]
  009e9	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  009ee	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG172948
  009f5	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  009fa	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG172949
  00a01	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00a06	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00a0b	41 b9 03 00 00
	00		 mov	 r9d, 3
  00a11	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG172950
  00a18	ba be 0e 00 00	 mov	 edx, 3774		; 00000ebeH
  00a1d	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG172951
  00a24	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 3775 :                 return -1;

  00a2a	b8 ff ff ff ff	 mov	 eax, -1
  00a2f	e9 76 07 00 00	 jmp	 $LN1@BuildOAT
$LN35@BuildOAT:

; 3776 :             }
; 3777 : 
; 3778 :             /*                                                       */
; 3779 :             /* The keyword is a device address.                      */
; 3780 :             /*                                                       */
; 3781 :             /* If the operand, i.e. the mode, is IP, the device      */
; 3782 :             /* address can be either the even or the odd address of  */
; 3783 :             /* an even/odd device address pair, e.g. either 0E42 or  */
; 3784 :             /* 0E43. Whichever device address is specified will      */
; 3785 :             /* become the read device, and the other device address  */
; 3786 :             /* of the even/odd pair will become the write device.    */
; 3787 :             /* For example, if device address 0E42 is specified,     */
; 3788 :             /* device address 0E42 will become the read device, and  */
; 3789 :             /* device address 0E43 will become the write device.     */
; 3790 :             /* However, if device address 0E43 is specified, device  */
; 3791 :             /* address 0E43 will become the read device, and device  */
; 3792 :             /* address 0E42 will become the write device.            */
; 3793 :             /*                                                       */
; 3794 :             /* If the operand, i.e. the mode, is SNA, the device     */
; 3795 :             /* address can be any device address, e.g. 0E42 or 0E43. */
; 3796 :             /* SNA uses a single device for both read and write.     */
; 3797 :             /*                                                       */
; 3798 :             /* The following extract from an OAT illustrates the     */
; 3799 :             /* above. The guest will have four interfaces, two IP    */
; 3800 :             /* and two SNA. All four interfaces will use the same    */
; 3801 :             /* port, i.e the tap. The first IP interface will use    */
; 3802 :             /* the even device address 0E40 as the read device and   */
; 3803 :             /* the odd device address 0E41 as the write device.      */
; 3804 :             /* However, the second IP interface will use the odd     */
; 3805 :             /* device address 0E43 as the read device and the even   */
; 3806 :             /* device address 0E42 as the write device. The first    */
; 3807 :             /* SNA interface will use the even device address 0E44,  */
; 3808 :             /* and the second SNA interface will use the odd device  */
; 3809 :             /* address 0E45.                                         */
; 3810 :             /*                                                       */
; 3811 :             /*   0E40  IP   00  NO  192.168.1.1                      */
; 3812 :             /*   0E43  IP   00  NO  192.168.1.2                      */
; 3813 :             /*   0E44  SNA  00                                       */
; 3814 :             /*   0E45  SNA  00                                       */
; 3815 :             /*                                                       */
; 3816 :             if (strlen( pszKeyword ) > 4 ||

  00a34	48 8b 8c 24 a8
	00 00 00	 mov	 rcx, QWORD PTR pszKeyword$[rsp]
  00a3c	e8 00 00 00 00	 call	 strlen
  00a41	48 83 f8 04	 cmp	 rax, 4
  00a45	77 23		 ja	 SHORT $LN38@BuildOAT
  00a47	4c 8d 4c 24 60	 lea	 r9, QWORD PTR c$[rsp]
  00a4c	4c 8d 44 24 78	 lea	 r8, QWORD PTR sDevNum$[rsp]
  00a51	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG172954
  00a58	48 8b 8c 24 a8
	00 00 00	 mov	 rcx, QWORD PTR pszKeyword$[rsp]
  00a60	e8 00 00 00 00	 call	 sscanf
  00a65	83 f8 01	 cmp	 eax, 1
  00a68	74 77		 je	 SHORT $LN37@BuildOAT
$LN38@BuildOAT:

; 3817 :                 sscanf( pszKeyword, "%hx%c", &sDevNum, &c ) != 1)
; 3818 :             {
; 3819 :                 // "CTC: error in file %s: invalid %s value %s"
; 3820 :                 WRMSG( HHC00957, "E", pszOATName, "device number", pszKeyword );

  00a6a	b9 01 00 00 00	 mov	 ecx, 1
  00a6f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  00a75	48 8b 8c 24 a8
	00 00 00	 mov	 rcx, QWORD PTR pszKeyword$[rsp]
  00a7d	48 89 4c 24 48	 mov	 QWORD PTR [rsp+72], rcx
  00a82	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG172955
  00a89	48 89 4c 24 40	 mov	 QWORD PTR [rsp+64], rcx
  00a8e	48 8b 8c 24 c0
	24 00 00	 mov	 rcx, QWORD PTR pszOATName$[rsp]
  00a96	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  00a9b	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG172956
  00aa2	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  00aa7	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG172957
  00aae	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00ab3	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00ab8	41 b9 03 00 00
	00		 mov	 r9d, 3
  00abe	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG172958
  00ac5	ba ec 0e 00 00	 mov	 edx, 3820		; 00000eecH
  00aca	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG172959
  00ad1	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 3821 :                 return -1;

  00ad7	b8 ff ff ff ff	 mov	 eax, -1
  00adc	e9 c9 06 00 00	 jmp	 $LN1@BuildOAT
$LN37@BuildOAT:

; 3822 :             }
; 3823 : 
; 3824 :             if (strcasecmp( pszOperand, "IP" ) == 0)

  00ae1	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG172962
  00ae8	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR pszOperand$[rsp]
  00af0	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__stricmp
  00af6	85 c0		 test	 eax, eax
  00af8	0f 85 25 03 00
	00		 jne	 $LN39@BuildOAT

; 3825 :             {
; 3826 :                 bMode = LCSDEV_MODE_IP;

  00afe	c6 44 24 62 01	 mov	 BYTE PTR bMode$[rsp], 1

; 3827 : 
; 3828 :                 if (argc < 1)

  00b03	83 7c 24 68 01	 cmp	 DWORD PTR argc$[rsp], 1
  00b08	7d 6b		 jge	 SHORT $LN41@BuildOAT

; 3829 :                 {
; 3830 :                     // "CTC: error in file %s: %s: missing port number"
; 3831 :                     WRMSG( HHC00958, "E", pszOATName, szBuff );

  00b0a	b9 01 00 00 00	 mov	 ecx, 1
  00b0f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  00b15	48 8d 8c 24 30
	21 00 00	 lea	 rcx, QWORD PTR szBuff$[rsp]
  00b1d	48 89 4c 24 40	 mov	 QWORD PTR [rsp+64], rcx
  00b22	48 8b 8c 24 c0
	24 00 00	 mov	 rcx, QWORD PTR pszOATName$[rsp]
  00b2a	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  00b2f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG172964
  00b36	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  00b3b	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG172965
  00b42	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00b47	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00b4c	41 b9 03 00 00
	00		 mov	 r9d, 3
  00b52	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG172966
  00b59	ba f7 0e 00 00	 mov	 edx, 3831		; 00000ef7H
  00b5e	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG172967
  00b65	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 3832 :                     return -1;

  00b6b	b8 ff ff ff ff	 mov	 eax, -1
  00b70	e9 35 06 00 00	 jmp	 $LN1@BuildOAT
$LN41@BuildOAT:

; 3833 :                 }
; 3834 : 
; 3835 :                 if (sscanf( argv[0], "%hi%c", &sPort, &c ) != 1)

  00b75	b8 08 00 00 00	 mov	 eax, 8
  00b7a	48 6b c0 00	 imul	 rax, rax, 0
  00b7e	4c 8d 4c 24 60	 lea	 r9, QWORD PTR c$[rsp]
  00b83	4c 8d 44 24 64	 lea	 r8, QWORD PTR sPort$[rsp]
  00b88	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG172969
  00b8f	48 8b 8c 04 30
	01 00 00	 mov	 rcx, QWORD PTR argv$[rsp+rax]
  00b97	e8 00 00 00 00	 call	 sscanf
  00b9c	83 f8 01	 cmp	 eax, 1
  00b9f	0f 84 90 00 00
	00		 je	 $LN42@BuildOAT

; 3836 :                 {
; 3837 :                     // "CTC: error in file %s: invalid %s value %s"
; 3838 :                     WRMSG( HHC00957, "E", pszOATName, "port number", argv[0] );

  00ba5	b8 08 00 00 00	 mov	 eax, 8
  00baa	48 6b c0 00	 imul	 rax, rax, 0
  00bae	48 89 84 24 18
	01 00 00	 mov	 QWORD PTR tv452[rsp], rax
  00bb6	b9 01 00 00 00	 mov	 ecx, 1
  00bbb	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  00bc1	48 8b 8c 24 18
	01 00 00	 mov	 rcx, QWORD PTR tv452[rsp]
  00bc9	48 8b 8c 0c 30
	01 00 00	 mov	 rcx, QWORD PTR argv$[rsp+rcx]
  00bd1	48 89 4c 24 48	 mov	 QWORD PTR [rsp+72], rcx
  00bd6	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG172970
  00bdd	48 89 4c 24 40	 mov	 QWORD PTR [rsp+64], rcx
  00be2	48 8b 8c 24 c0
	24 00 00	 mov	 rcx, QWORD PTR pszOATName$[rsp]
  00bea	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  00bef	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG172971
  00bf6	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  00bfb	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG172972
  00c02	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00c07	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00c0c	41 b9 03 00 00
	00		 mov	 r9d, 3
  00c12	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG172973
  00c19	ba fe 0e 00 00	 mov	 edx, 3838		; 00000efeH
  00c1e	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG172974
  00c25	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 3839 :                     return -1;

  00c2b	b8 ff ff ff ff	 mov	 eax, -1
  00c30	e9 75 05 00 00	 jmp	 $LN1@BuildOAT
$LN42@BuildOAT:

; 3840 :                 }
; 3841 : 
; 3842 :                 if (argc > 1)

  00c35	83 7c 24 68 01	 cmp	 DWORD PTR argc$[rsp], 1
  00c3a	0f 8e de 01 00
	00		 jle	 $LN43@BuildOAT

; 3843 :                 {
; 3844 :                          if (strcasecmp( argv[1], "PRI" ) == 0) bType = LCSDEV_TYPE_PRIMARY;

  00c40	b8 08 00 00 00	 mov	 eax, 8
  00c45	48 6b c0 01	 imul	 rax, rax, 1
  00c49	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG172978
  00c50	48 8b 8c 04 30
	01 00 00	 mov	 rcx, QWORD PTR argv$[rsp+rax]
  00c58	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__stricmp
  00c5e	85 c0		 test	 eax, eax
  00c60	75 0a		 jne	 SHORT $LN44@BuildOAT
  00c62	c6 44 24 61 01	 mov	 BYTE PTR bType$[rsp], 1
  00c67	e9 e9 00 00 00	 jmp	 $LN45@BuildOAT
$LN44@BuildOAT:

; 3845 :                     else if (strcasecmp( argv[1], "SEC" ) == 0) bType = LCSDEV_TYPE_SECONDARY;

  00c6c	b8 08 00 00 00	 mov	 eax, 8
  00c71	48 6b c0 01	 imul	 rax, rax, 1
  00c75	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG172981
  00c7c	48 8b 8c 04 30
	01 00 00	 mov	 rcx, QWORD PTR argv$[rsp+rax]
  00c84	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__stricmp
  00c8a	85 c0		 test	 eax, eax
  00c8c	75 0a		 jne	 SHORT $LN46@BuildOAT
  00c8e	c6 44 24 61 02	 mov	 BYTE PTR bType$[rsp], 2
  00c93	e9 bd 00 00 00	 jmp	 $LN47@BuildOAT
$LN46@BuildOAT:

; 3846 :                     else if (strcasecmp( argv[1], "NO"  ) == 0) bType = LCSDEV_TYPE_NONE;

  00c98	b8 08 00 00 00	 mov	 eax, 8
  00c9d	48 6b c0 01	 imul	 rax, rax, 1
  00ca1	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG172984
  00ca8	48 8b 8c 04 30
	01 00 00	 mov	 rcx, QWORD PTR argv$[rsp+rax]
  00cb0	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__stricmp
  00cb6	85 c0		 test	 eax, eax
  00cb8	75 0a		 jne	 SHORT $LN48@BuildOAT
  00cba	c6 44 24 61 00	 mov	 BYTE PTR bType$[rsp], 0
  00cbf	e9 91 00 00 00	 jmp	 $LN49@BuildOAT
$LN48@BuildOAT:

; 3847 :                     else
; 3848 :                     {
; 3849 :                         // "CTC: error in file %s: %s: invalid entry starting at %s"
; 3850 :                         WRMSG( HHC00959, "E", pszOATName, szBuff, argv[1] );

  00cc4	b8 08 00 00 00	 mov	 eax, 8
  00cc9	48 6b c0 01	 imul	 rax, rax, 1
  00ccd	48 89 84 24 20
	01 00 00	 mov	 QWORD PTR tv517[rsp], rax
  00cd5	b9 01 00 00 00	 mov	 ecx, 1
  00cda	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  00ce0	48 8b 8c 24 20
	01 00 00	 mov	 rcx, QWORD PTR tv517[rsp]
  00ce8	48 8b 8c 0c 30
	01 00 00	 mov	 rcx, QWORD PTR argv$[rsp+rcx]
  00cf0	48 89 4c 24 48	 mov	 QWORD PTR [rsp+72], rcx
  00cf5	48 8d 8c 24 30
	21 00 00	 lea	 rcx, QWORD PTR szBuff$[rsp]
  00cfd	48 89 4c 24 40	 mov	 QWORD PTR [rsp+64], rcx
  00d02	48 8b 8c 24 c0
	24 00 00	 mov	 rcx, QWORD PTR pszOATName$[rsp]
  00d0a	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  00d0f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG172985
  00d16	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  00d1b	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG172986
  00d22	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00d27	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00d2c	41 b9 03 00 00
	00		 mov	 r9d, 3
  00d32	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG172987
  00d39	ba 0a 0f 00 00	 mov	 edx, 3850		; 00000f0aH
  00d3e	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG172988
  00d45	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 3851 :                         return -1;

  00d4b	b8 ff ff ff ff	 mov	 eax, -1
  00d50	e9 55 04 00 00	 jmp	 $LN1@BuildOAT
$LN49@BuildOAT:
$LN47@BuildOAT:
$LN45@BuildOAT:

; 3852 :                     }
; 3853 : 
; 3854 :                     if (argc > 2)

  00d55	83 7c 24 68 02	 cmp	 DWORD PTR argc$[rsp], 2
  00d5a	0f 8e be 00 00
	00		 jle	 $LN50@BuildOAT

; 3855 :                     {
; 3856 :                         pszIPAddress = strdup( argv[2] );

  00d60	b8 08 00 00 00	 mov	 eax, 8
  00d65	48 6b c0 02	 imul	 rax, rax, 2
  00d69	48 8b 8c 04 30
	01 00 00	 mov	 rcx, QWORD PTR argv$[rsp+rax]
  00d71	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_strdup
  00d77	48 89 84 24 b8
	00 00 00	 mov	 QWORD PTR pszIPAddress$[rsp], rax

; 3857 : 
; 3858 :                         if (inet_aton( pszIPAddress, &addr ) == 0)

  00d7f	48 8d 94 24 94
	00 00 00	 lea	 rdx, QWORD PTR addr$[rsp]
  00d87	48 8b 8c 24 b8
	00 00 00	 mov	 rcx, QWORD PTR pszIPAddress$[rsp]
  00d8f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_inet_aton
  00d95	85 c0		 test	 eax, eax
  00d97	75 77		 jne	 SHORT $LN51@BuildOAT

; 3859 :                         {
; 3860 :                             // "CTC: error in file %s: invalid %s value %s"
; 3861 :                             WRMSG( HHC00957, "E", pszOATName, "IP address", pszIPAddress );

  00d99	b9 01 00 00 00	 mov	 ecx, 1
  00d9e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  00da4	48 8b 8c 24 b8
	00 00 00	 mov	 rcx, QWORD PTR pszIPAddress$[rsp]
  00dac	48 89 4c 24 48	 mov	 QWORD PTR [rsp+72], rcx
  00db1	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG172991
  00db8	48 89 4c 24 40	 mov	 QWORD PTR [rsp+64], rcx
  00dbd	48 8b 8c 24 c0
	24 00 00	 mov	 rcx, QWORD PTR pszOATName$[rsp]
  00dc5	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  00dca	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG172992
  00dd1	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  00dd6	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG172993
  00ddd	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00de2	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00de7	41 b9 03 00 00
	00		 mov	 r9d, 3
  00ded	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG172994
  00df4	ba 15 0f 00 00	 mov	 edx, 3861		; 00000f15H
  00df9	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG172995
  00e00	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 3862 :                             return -1;

  00e06	b8 ff ff ff ff	 mov	 eax, -1
  00e0b	e9 9a 03 00 00	 jmp	 $LN1@BuildOAT
$LN51@BuildOAT:

; 3863 :                         }
; 3864 : 
; 3865 :                         lIPAddr = addr.s_addr;  // (network byte order)

  00e10	8b 84 24 94 00
	00 00		 mov	 eax, DWORD PTR addr$[rsp]
  00e17	89 84 24 b0 00
	00 00		 mov	 DWORD PTR lIPAddr$[rsp], eax
$LN50@BuildOAT:
$LN43@BuildOAT:

; 3866 :                     }
; 3867 :                 }
; 3868 :             }

  00e1e	e9 33 02 00 00	 jmp	 $LN40@BuildOAT
$LN39@BuildOAT:

; 3869 :             else if (strcasecmp( pszOperand, "SNA" ) == 0)

  00e23	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG172998
  00e2a	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR pszOperand$[rsp]
  00e32	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__stricmp
  00e38	85 c0		 test	 eax, eax
  00e3a	0f 85 ab 01 00
	00		 jne	 $LN52@BuildOAT

; 3870 :             {
; 3871 :                 bMode = LCSDEV_MODE_SNA;

  00e40	c6 44 24 62 02	 mov	 BYTE PTR bMode$[rsp], 2

; 3872 : 
; 3873 :                 if (argc < 1)

  00e45	83 7c 24 68 01	 cmp	 DWORD PTR argc$[rsp], 1
  00e4a	7d 6b		 jge	 SHORT $LN54@BuildOAT

; 3874 :                 {
; 3875 :                     // "CTC: error in file %s: %s: missing port number"
; 3876 :                     WRMSG( HHC00958, "E", pszOATName, szBuff );

  00e4c	b9 01 00 00 00	 mov	 ecx, 1
  00e51	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  00e57	48 8d 8c 24 30
	21 00 00	 lea	 rcx, QWORD PTR szBuff$[rsp]
  00e5f	48 89 4c 24 40	 mov	 QWORD PTR [rsp+64], rcx
  00e64	48 8b 8c 24 c0
	24 00 00	 mov	 rcx, QWORD PTR pszOATName$[rsp]
  00e6c	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  00e71	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG173000
  00e78	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  00e7d	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG173001
  00e84	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00e89	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00e8e	41 b9 03 00 00
	00		 mov	 r9d, 3
  00e94	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG173002
  00e9b	ba 24 0f 00 00	 mov	 edx, 3876		; 00000f24H
  00ea0	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG173003
  00ea7	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 3877 :                     return -1;

  00ead	b8 ff ff ff ff	 mov	 eax, -1
  00eb2	e9 f3 02 00 00	 jmp	 $LN1@BuildOAT
$LN54@BuildOAT:

; 3878 :                 }
; 3879 : 
; 3880 :                 if (sscanf( argv[0], "%hi%c", &sPort, &c ) != 1)

  00eb7	b8 08 00 00 00	 mov	 eax, 8
  00ebc	48 6b c0 00	 imul	 rax, rax, 0
  00ec0	4c 8d 4c 24 60	 lea	 r9, QWORD PTR c$[rsp]
  00ec5	4c 8d 44 24 64	 lea	 r8, QWORD PTR sPort$[rsp]
  00eca	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG173005
  00ed1	48 8b 8c 04 30
	01 00 00	 mov	 rcx, QWORD PTR argv$[rsp+rax]
  00ed9	e8 00 00 00 00	 call	 sscanf
  00ede	83 f8 01	 cmp	 eax, 1
  00ee1	0f 84 90 00 00
	00		 je	 $LN55@BuildOAT

; 3881 :                 {
; 3882 :                     // "CTC: error in file %s: invalid %s value %s"
; 3883 :                     WRMSG( HHC00957, "E", pszOATName, "port number", argv[0] );

  00ee7	b8 08 00 00 00	 mov	 eax, 8
  00eec	48 6b c0 00	 imul	 rax, rax, 0
  00ef0	48 89 84 24 28
	01 00 00	 mov	 QWORD PTR tv576[rsp], rax
  00ef8	b9 01 00 00 00	 mov	 ecx, 1
  00efd	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  00f03	48 8b 8c 24 28
	01 00 00	 mov	 rcx, QWORD PTR tv576[rsp]
  00f0b	48 8b 8c 0c 30
	01 00 00	 mov	 rcx, QWORD PTR argv$[rsp+rcx]
  00f13	48 89 4c 24 48	 mov	 QWORD PTR [rsp+72], rcx
  00f18	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG173006
  00f1f	48 89 4c 24 40	 mov	 QWORD PTR [rsp+64], rcx
  00f24	48 8b 8c 24 c0
	24 00 00	 mov	 rcx, QWORD PTR pszOATName$[rsp]
  00f2c	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  00f31	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG173007
  00f38	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  00f3d	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG173008
  00f44	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00f49	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00f4e	41 b9 03 00 00
	00		 mov	 r9d, 3
  00f54	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG173009
  00f5b	ba 2b 0f 00 00	 mov	 edx, 3883		; 00000f2bH
  00f60	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG173010
  00f67	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 3884 :                     return -1;

  00f6d	b8 ff ff ff ff	 mov	 eax, -1
  00f72	e9 33 02 00 00	 jmp	 $LN1@BuildOAT
$LN55@BuildOAT:

; 3885 :                 }
; 3886 : 
; 3887 :                 if (argc > 1)

  00f77	83 7c 24 68 01	 cmp	 DWORD PTR argc$[rsp], 1
  00f7c	7e 6b		 jle	 SHORT $LN56@BuildOAT

; 3888 :                 {
; 3889 :                     // "CTC: error in file %s: %s: SNA does not accept any arguments"
; 3890 :                     WRMSG( HHC00960, "E", pszOATName, szBuff );

  00f7e	b9 01 00 00 00	 mov	 ecx, 1
  00f83	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  00f89	48 8d 8c 24 30
	21 00 00	 lea	 rcx, QWORD PTR szBuff$[rsp]
  00f91	48 89 4c 24 40	 mov	 QWORD PTR [rsp+64], rcx
  00f96	48 8b 8c 24 c0
	24 00 00	 mov	 rcx, QWORD PTR pszOATName$[rsp]
  00f9e	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  00fa3	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG173012
  00faa	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  00faf	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG173013
  00fb6	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00fbb	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00fc0	41 b9 03 00 00
	00		 mov	 r9d, 3
  00fc6	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG173014
  00fcd	ba 32 0f 00 00	 mov	 edx, 3890		; 00000f32H
  00fd2	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG173015
  00fd9	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 3891 :                     return -1;

  00fdf	b8 ff ff ff ff	 mov	 eax, -1
  00fe4	e9 c1 01 00 00	 jmp	 $LN1@BuildOAT
$LN56@BuildOAT:

; 3892 :                 }
; 3893 :             }

  00fe9	eb 6b		 jmp	 SHORT $LN53@BuildOAT
$LN52@BuildOAT:

; 3894 :             else
; 3895 :             {
; 3896 :                 // "CTC: error in file %s: %s: invalid mode"
; 3897 :                 WRMSG( HHC00961, "E", pszOATName, pszOperand );

  00feb	b9 01 00 00 00	 mov	 ecx, 1
  00ff0	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  00ff6	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR pszOperand$[rsp]
  00ffe	48 89 4c 24 40	 mov	 QWORD PTR [rsp+64], rcx
  01003	48 8b 8c 24 c0
	24 00 00	 mov	 rcx, QWORD PTR pszOATName$[rsp]
  0100b	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  01010	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG173016
  01017	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  0101c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG173017
  01023	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  01028	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  0102d	41 b9 03 00 00
	00		 mov	 r9d, 3
  01033	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG173018
  0103a	ba 39 0f 00 00	 mov	 edx, 3897		; 00000f39H
  0103f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG173019
  01046	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 3898 :                 return -1;

  0104c	b8 ff ff ff ff	 mov	 eax, -1
  01051	e9 54 01 00 00	 jmp	 $LN1@BuildOAT
$LN53@BuildOAT:
$LN40@BuildOAT:

; 3899 :             }
; 3900 : 
; 3901 :             // Create new LCS Device...
; 3902 : 
; 3903 :             pLCSDev = malloc( sizeof( LCSDEV ) );

  01056	b9 a6 50 00 00	 mov	 ecx, 20646		; 000050a6H
  0105b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_malloc
  01061	48 89 84 24 80
	00 00 00	 mov	 QWORD PTR pLCSDev$[rsp], rax

; 3904 :             memset( pLCSDev, 0, sizeof( LCSDEV ) );

  01069	48 8b bc 24 80
	00 00 00	 mov	 rdi, QWORD PTR pLCSDev$[rsp]
  01071	33 c0		 xor	 eax, eax
  01073	b9 a6 50 00 00	 mov	 ecx, 20646		; 000050a6H
  01078	f3 aa		 rep stosb

; 3905 : 
; 3906 :             pLCSDev->sAddr        = sDevNum;

  0107a	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR pLCSDev$[rsp]
  01082	0f b7 4c 24 78	 movzx	 ecx, WORD PTR sDevNum$[rsp]
  01087	66 89 48 20	 mov	 WORD PTR [rax+32], cx

; 3907 :             pLCSDev->bMode        = bMode;

  0108b	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR pLCSDev$[rsp]
  01093	0f b6 4c 24 62	 movzx	 ecx, BYTE PTR bMode$[rsp]
  01098	88 48 22	 mov	 BYTE PTR [rax+34], cl

; 3908 :             pLCSDev->bPort        = sPort;

  0109b	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR pLCSDev$[rsp]
  010a3	0f b6 4c 24 64	 movzx	 ecx, BYTE PTR sPort$[rsp]
  010a8	88 48 23	 mov	 BYTE PTR [rax+35], cl

; 3909 :             pLCSDev->bType        = bType;

  010ab	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR pLCSDev$[rsp]
  010b3	0f b6 4c 24 61	 movzx	 ecx, BYTE PTR bType$[rsp]
  010b8	88 48 24	 mov	 BYTE PTR [rax+36], cl

; 3910 :             pLCSDev->lIPAddress   = lIPAddr;   // (network byte order)

  010bb	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR pLCSDev$[rsp]
  010c3	8b 8c 24 b0 00
	00 00		 mov	 ecx, DWORD PTR lIPAddr$[rsp]
  010ca	89 48 2d	 mov	 DWORD PTR [rax+45], ecx

; 3911 :             pLCSDev->pszIPAddress = pszIPAddress;

  010cd	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR pLCSDev$[rsp]
  010d5	48 8b 8c 24 b8
	00 00 00	 mov	 rcx, QWORD PTR pszIPAddress$[rsp]
  010dd	48 89 48 25	 mov	 QWORD PTR [rax+37], rcx

; 3912 :             pLCSDev->pNext        = NULL;

  010e1	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR pLCSDev$[rsp]
  010e9	48 c7 00 00 00
	00 00		 mov	 QWORD PTR [rax], 0

; 3913 : 
; 3914 :             // Add it to end of chain...
; 3915 : 
; 3916 :             if (!pLCSBLK->pDevices)

  010f0	48 8b 84 24 c8
	24 00 00	 mov	 rax, QWORD PTR pLCSBLK$[rsp]
  010f8	48 83 78 58 00	 cmp	 QWORD PTR [rax+88], 0
  010fd	75 16		 jne	 SHORT $LN57@BuildOAT

; 3917 :                 pLCSBLK->pDevices = pLCSDev; // (first link in chain)

  010ff	48 8b 84 24 c8
	24 00 00	 mov	 rax, QWORD PTR pLCSBLK$[rsp]
  01107	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR pLCSDev$[rsp]
  0110f	48 89 48 58	 mov	 QWORD PTR [rax+88], rcx
  01113	eb 4c		 jmp	 SHORT $LN58@BuildOAT
$LN57@BuildOAT:

; 3918 :             else
; 3919 :             {
; 3920 :                 PLCSDEV pOldLastLCSDEV;
; 3921 :                 // (find last link in chain)
; 3922 :                 for (pOldLastLCSDEV = pLCSBLK->pDevices;

  01115	48 8b 84 24 c8
	24 00 00	 mov	 rax, QWORD PTR pLCSBLK$[rsp]
  0111d	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  01121	48 89 84 24 c8
	00 00 00	 mov	 QWORD PTR pOldLastLCSDEV$1[rsp], rax
  01129	eb 13		 jmp	 SHORT $LN16@BuildOAT
$LN14@BuildOAT:

; 3924 :                      pOldLastLCSDEV = pOldLastLCSDEV->pNext);

  0112b	48 8b 84 24 c8
	00 00 00	 mov	 rax, QWORD PTR pOldLastLCSDEV$1[rsp]
  01133	48 8b 00	 mov	 rax, QWORD PTR [rax]
  01136	48 89 84 24 c8
	00 00 00	 mov	 QWORD PTR pOldLastLCSDEV$1[rsp], rax
$LN16@BuildOAT:

; 3923 :                      pOldLastLCSDEV->pNext;

  0113e	48 8b 84 24 c8
	00 00 00	 mov	 rax, QWORD PTR pOldLastLCSDEV$1[rsp]
  01146	48 83 38 00	 cmp	 QWORD PTR [rax], 0
  0114a	74 02		 je	 SHORT $LN15@BuildOAT

; 3924 :                      pOldLastLCSDEV = pOldLastLCSDEV->pNext);

  0114c	eb dd		 jmp	 SHORT $LN14@BuildOAT
$LN15@BuildOAT:

; 3925 :                 // (add new link to end of chain)
; 3926 :                 pOldLastLCSDEV->pNext = pLCSDev;

  0114e	48 8b 84 24 c8
	00 00 00	 mov	 rax, QWORD PTR pOldLastLCSDEV$1[rsp]
  01156	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR pLCSDev$[rsp]
  0115e	48 89 08	 mov	 QWORD PTR [rax], rcx
$LN58@BuildOAT:

; 3927 :             }
; 3928 : 
; 3929 :             // Count it...
; 3930 : 
; 3931 :             if (pLCSDev->bMode == LCSDEV_MODE_IP)

  01161	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR pLCSDev$[rsp]
  01169	0f b6 40 22	 movzx	 eax, BYTE PTR [rax+34]
  0116d	83 f8 01	 cmp	 eax, 1
  01170	75 1b		 jne	 SHORT $LN59@BuildOAT

; 3932 :                 pLCSBLK->icDevices += 2;

  01172	48 8b 84 24 c8
	24 00 00	 mov	 rax, QWORD PTR pLCSBLK$[rsp]
  0117a	8b 40 1c	 mov	 eax, DWORD PTR [rax+28]
  0117d	83 c0 02	 add	 eax, 2
  01180	48 8b 8c 24 c8
	24 00 00	 mov	 rcx, QWORD PTR pLCSBLK$[rsp]
  01188	89 41 1c	 mov	 DWORD PTR [rcx+28], eax
  0118b	eb 18		 jmp	 SHORT $LN60@BuildOAT
$LN59@BuildOAT:

; 3933 :             else
; 3934 :                 pLCSBLK->icDevices += 1;

  0118d	48 8b 84 24 c8
	24 00 00	 mov	 rax, QWORD PTR pLCSBLK$[rsp]
  01195	8b 40 1c	 mov	 eax, DWORD PTR [rax+28]
  01198	ff c0		 inc	 eax
  0119a	48 8b 8c 24 c8
	24 00 00	 mov	 rcx, QWORD PTR pLCSBLK$[rsp]
  011a2	89 41 1c	 mov	 DWORD PTR [rcx+28], eax
$LN60@BuildOAT:
$LN28@BuildOAT:
$LN22@BuildOAT:

; 3935 : 
; 3936 :         } // end OAT file statement
; 3937 : 
; 3938 :     } // end for (;;)

  011a5	e9 b2 ef ff ff	 jmp	 $LN2@BuildOAT
$LN1@BuildOAT:
$LN61@BuildOAT:

; 3939 : 
; 3940 :     UNREACHABLE_CODE( return -1 );
; 3941 : }

  011aa	48 8b 8c 24 a0
	24 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  011b2	48 33 cc	 xor	 rcx, rsp
  011b5	e8 00 00 00 00	 call	 __security_check_cookie
  011ba	48 81 c4 b0 24
	00 00		 add	 rsp, 9392		; 000024b0H
  011c1	5f		 pop	 rdi
  011c2	c3		 ret	 0
BuildOAT ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\ctc_lcs.c
_TEXT	SEGMENT
pPortMAC$ = 112
rc$1 = 120
pIFaceMAC$ = 128
fd$2 = 136
tv147 = 140
tv150 = 144
tv153 = 148
tv159 = 152
tv161 = 156
tv186 = 160
tv189 = 164
tv192 = 168
tv198 = 172
tv200 = 176
tv71 = 184
tv131 = 192
tv134 = 200
tv163 = 208
tv202 = 216
tv240 = 224
ifr$ = 232
__$ArrayPad$ = 264
pLCSPORT$ = 304
GetIfMACAddress PROC

; 3190 : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	56		 push	 rsi
  00006	57		 push	 rdi
  00007	48 81 ec 18 01
	00 00		 sub	 rsp, 280		; 00000118H
  0000e	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00015	48 33 c4	 xor	 rax, rsp
  00018	48 89 84 24 08
	01 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 3191 :     BYTE*  pPortMAC   = (BYTE*) &pLCSPORT->MAC_Address;

  00020	48 8b 84 24 30
	01 00 00	 mov	 rax, QWORD PTR pLCSPORT$[rsp]
  00028	48 83 c0 02	 add	 rax, 2
  0002c	48 89 44 24 70	 mov	 QWORD PTR pPortMAC$[rsp], rax

; 3192 :     BYTE*  pIFaceMAC  = pPortMAC;

  00031	48 8b 44 24 70	 mov	 rax, QWORD PTR pPortMAC$[rsp]
  00036	48 89 84 24 80
	00 00 00	 mov	 QWORD PTR pIFaceMAC$[rsp], rax

; 3193 : 
; 3194 :     /* Not all systems can return the hardware address of an interface. */
; 3195 : 
; 3196 : #if defined( SIOCGIFHWADDR )
; 3197 : 
; 3198 :     ifreq  ifr;
; 3199 :     {
; 3200 :         int    fd, rc;
; 3201 : 
; 3202 :         fd = socket( AF_INET, SOCK_STREAM, IPPROTO_IP );

  0003e	45 33 c0	 xor	 r8d, r8d
  00041	ba 01 00 00 00	 mov	 edx, 1
  00046	b9 02 00 00 00	 mov	 ecx, 2
  0004b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_socket
  00051	89 84 24 88 00
	00 00		 mov	 DWORD PTR fd$2[rsp], eax

; 3203 : 
; 3204 :         if (fd == -1)

  00058	83 bc 24 88 00
	00 00 ff	 cmp	 DWORD PTR fd$2[rsp], -1
  00060	0f 85 81 00 00
	00		 jne	 $LN2@GetIfMACAd

; 3205 :         {
; 3206 :             // "CTC: error in function %s: %s"
; 3207 :             rc = HSO_errno;

  00066	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_WSAGetLastError
  0006c	89 44 24 78	 mov	 DWORD PTR rc$1[rsp], eax

; 3208 :             WRMSG( HHC00940, "E", "socket()", strerror( rc ));

  00070	8b 4c 24 78	 mov	 ecx, DWORD PTR rc$1[rsp]
  00074	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_strerror
  0007a	48 89 84 24 b8
	00 00 00	 mov	 QWORD PTR tv71[rsp], rax
  00082	b9 01 00 00 00	 mov	 ecx, 1
  00087	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  0008d	48 8b 8c 24 b8
	00 00 00	 mov	 rcx, QWORD PTR tv71[rsp]
  00095	48 89 4c 24 40	 mov	 QWORD PTR [rsp+64], rcx
  0009a	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG172644
  000a1	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  000a6	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG172645
  000ad	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  000b2	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG172646
  000b9	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  000be	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  000c3	41 b9 03 00 00
	00		 mov	 r9d, 3
  000c9	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG172647
  000d0	ba 88 0c 00 00	 mov	 edx, 3208		; 00000c88H
  000d5	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG172648
  000dc	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 3209 :             return;

  000e2	e9 09 04 00 00	 jmp	 $LN1@GetIfMACAd
$LN2@GetIfMACAd:

; 3210 :         }
; 3211 : 
; 3212 :         memset( &ifr, 0, sizeof( ifr ));

  000e7	48 8d 84 24 e8
	00 00 00	 lea	 rax, QWORD PTR ifr$[rsp]
  000ef	48 8b f8	 mov	 rdi, rax
  000f2	33 c0		 xor	 eax, eax
  000f4	b9 20 00 00 00	 mov	 ecx, 32			; 00000020H
  000f9	f3 aa		 rep stosb

; 3213 :         STRLCPY( ifr.ifr_name, pLCSPORT->szNetIfName );

  000fb	48 8b 84 24 30
	01 00 00	 mov	 rax, QWORD PTR pLCSPORT$[rsp]
  00103	48 05 48 01 00
	00		 add	 rax, 328		; 00000148H
  00109	41 b8 10 00 00
	00		 mov	 r8d, 16
  0010f	48 8b d0	 mov	 rdx, rax
  00112	48 8d 8c 24 e8
	00 00 00	 lea	 rcx, QWORD PTR ifr$[rsp]
  0011a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_strlcpy

; 3214 : 
; 3215 :         rc = TUNTAP_IOCtl( fd, SIOCGIFHWADDR, (char*) &ifr );

  00120	4c 8d 84 24 e8
	00 00 00	 lea	 r8, QWORD PTR ifr$[rsp]
  00128	ba 27 89 00 00	 mov	 edx, 35111		; 00008927H
  0012d	8b 8c 24 88 00
	00 00		 mov	 ecx, DWORD PTR fd$2[rsp]
  00134	e8 00 00 00 00	 call	 tt32_ioctl
  00139	89 44 24 78	 mov	 DWORD PTR rc$1[rsp], eax

; 3216 :         close( fd );

  0013d	8b 8c 24 88 00
	00 00		 mov	 ecx, DWORD PTR fd$2[rsp]
  00144	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_close

; 3217 : 
; 3218 :         if (rc != 0)

  0014a	83 7c 24 78 00	 cmp	 DWORD PTR rc$1[rsp], 0
  0014f	0f 84 a5 00 00
	00		 je	 $LN3@GetIfMACAd

; 3219 :         {
; 3220 :             // "CTC: ioctl %s failed for device %s: %s"
; 3221 :             rc = HSO_errno;

  00155	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_WSAGetLastError
  0015b	89 44 24 78	 mov	 DWORD PTR rc$1[rsp], eax

; 3222 :             WRMSG( HHC00941, "E", "SIOCGIFHWADDR", pLCSPORT->szNetIfName, strerror( rc ));

  0015f	8b 4c 24 78	 mov	 ecx, DWORD PTR rc$1[rsp]
  00163	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_strerror
  00169	48 89 84 24 c0
	00 00 00	 mov	 QWORD PTR tv131[rsp], rax
  00171	48 8b 8c 24 30
	01 00 00	 mov	 rcx, QWORD PTR pLCSPORT$[rsp]
  00179	48 81 c1 48 01
	00 00		 add	 rcx, 328		; 00000148H
  00180	48 89 8c 24 c8
	00 00 00	 mov	 QWORD PTR tv134[rsp], rcx
  00188	b9 01 00 00 00	 mov	 ecx, 1
  0018d	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  00193	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR tv131[rsp]
  0019b	48 89 4c 24 48	 mov	 QWORD PTR [rsp+72], rcx
  001a0	48 8b 8c 24 c8
	00 00 00	 mov	 rcx, QWORD PTR tv134[rsp]
  001a8	48 89 4c 24 40	 mov	 QWORD PTR [rsp+64], rcx
  001ad	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG172650
  001b4	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  001b9	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG172651
  001c0	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  001c5	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG172652
  001cc	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  001d1	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  001d6	41 b9 03 00 00
	00		 mov	 r9d, 3
  001dc	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG172653
  001e3	ba 96 0c 00 00	 mov	 edx, 3222		; 00000c96H
  001e8	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG172654
  001ef	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 3223 :             return;

  001f5	e9 f6 02 00 00	 jmp	 $LN1@GetIfMACAd
$LN3@GetIfMACAd:

; 3224 :         }
; 3225 : 
; 3226 :         pIFaceMAC  = (BYTE*) ifr.ifr_hwaddr.sa_data;

  001fa	48 8d 84 24 fa
	00 00 00	 lea	 rax, QWORD PTR ifr$[rsp+18]
  00202	48 89 84 24 80
	00 00 00	 mov	 QWORD PTR pIFaceMAC$[rsp], rax

; 3227 :     }
; 3228 : 
; 3229 : #endif // defined( SIOCGIFHWADDR )
; 3230 : 
; 3231 :     /* Report what MAC address we will really be using */
; 3232 :     // "CTC: lcs interface '%s' using mac %2.2X:%2.2X:%2.2X:%2.2X:%2.2X:%2.2X"
; 3233 :     WRMSG( HHC00942, "I", pLCSPORT->szNetIfName, *(pIFaceMAC+0), *(pIFaceMAC+1),

  0020a	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR pIFaceMAC$[rsp]
  00212	0f b6 40 05	 movzx	 eax, BYTE PTR [rax+5]
  00216	89 84 24 8c 00
	00 00		 mov	 DWORD PTR tv147[rsp], eax
  0021d	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR pIFaceMAC$[rsp]
  00225	0f b6 49 04	 movzx	 ecx, BYTE PTR [rcx+4]
  00229	89 8c 24 90 00
	00 00		 mov	 DWORD PTR tv150[rsp], ecx
  00230	48 8b 94 24 80
	00 00 00	 mov	 rdx, QWORD PTR pIFaceMAC$[rsp]
  00238	0f b6 52 03	 movzx	 edx, BYTE PTR [rdx+3]
  0023c	89 94 24 94 00
	00 00		 mov	 DWORD PTR tv153[rsp], edx
  00243	48 8b bc 24 80
	00 00 00	 mov	 rdi, QWORD PTR pIFaceMAC$[rsp]
  0024b	0f b6 7f 02	 movzx	 edi, BYTE PTR [rdi+2]
  0024f	4c 8b 84 24 80
	00 00 00	 mov	 r8, QWORD PTR pIFaceMAC$[rsp]
  00257	45 0f b6 40 01	 movzx	 r8d, BYTE PTR [r8+1]
  0025c	44 89 84 24 98
	00 00 00	 mov	 DWORD PTR tv159[rsp], r8d
  00264	4c 8b 8c 24 80
	00 00 00	 mov	 r9, QWORD PTR pIFaceMAC$[rsp]
  0026c	45 0f b6 09	 movzx	 r9d, BYTE PTR [r9]
  00270	44 89 8c 24 9c
	00 00 00	 mov	 DWORD PTR tv161[rsp], r9d
  00278	4c 8b 94 24 30
	01 00 00	 mov	 r10, QWORD PTR pLCSPORT$[rsp]
  00280	49 81 c2 48 01
	00 00		 add	 r10, 328		; 00000148H
  00287	4c 89 94 24 d0
	00 00 00	 mov	 QWORD PTR tv163[rsp], r10
  0028f	b9 01 00 00 00	 mov	 ecx, 1
  00294	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  0029a	8b 8c 24 8c 00
	00 00		 mov	 ecx, DWORD PTR tv147[rsp]
  002a1	89 4c 24 68	 mov	 DWORD PTR [rsp+104], ecx
  002a5	8b 8c 24 90 00
	00 00		 mov	 ecx, DWORD PTR tv150[rsp]
  002ac	89 4c 24 60	 mov	 DWORD PTR [rsp+96], ecx
  002b0	8b 8c 24 94 00
	00 00		 mov	 ecx, DWORD PTR tv153[rsp]
  002b7	89 4c 24 58	 mov	 DWORD PTR [rsp+88], ecx
  002bb	89 7c 24 50	 mov	 DWORD PTR [rsp+80], edi
  002bf	8b 8c 24 98 00
	00 00		 mov	 ecx, DWORD PTR tv159[rsp]
  002c6	89 4c 24 48	 mov	 DWORD PTR [rsp+72], ecx
  002ca	8b 8c 24 9c 00
	00 00		 mov	 ecx, DWORD PTR tv161[rsp]
  002d1	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  002d5	48 8b 8c 24 d0
	00 00 00	 mov	 rcx, QWORD PTR tv163[rsp]
  002dd	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  002e2	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG172655
  002e9	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  002ee	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG172656
  002f5	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  002fa	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  002ff	41 b9 03 00 00
	00		 mov	 r9d, 3
  00305	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG172657
  0030c	ba a2 0c 00 00	 mov	 edx, 3234		; 00000ca2H
  00311	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG172658
  00318	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 3234 :                       *(pIFaceMAC+2), *(pIFaceMAC+3), *(pIFaceMAC+4), *(pIFaceMAC+5));
; 3235 : 
; 3236 :     /* Issue warning if different from specified value */
; 3237 :     if (memcmp( pPortMAC, pIFaceMAC, IFHWADDRLEN ) != 0)

  0031e	41 b8 06 00 00
	00		 mov	 r8d, 6
  00324	48 8b 94 24 80
	00 00 00	 mov	 rdx, QWORD PTR pIFaceMAC$[rsp]
  0032c	48 8b 4c 24 70	 mov	 rcx, QWORD PTR pPortMAC$[rsp]
  00331	e8 00 00 00 00	 call	 memcmp
  00336	85 c0		 test	 eax, eax
  00338	0f 84 b2 01 00
	00		 je	 $LN4@GetIfMACAd

; 3238 :     {
; 3239 :         if (pLCSPORT->fLocalMAC)

  0033e	48 8b 84 24 30
	01 00 00	 mov	 rax, QWORD PTR pLCSPORT$[rsp]
  00346	8b 80 34 01 00
	00		 mov	 eax, DWORD PTR [rax+308]
  0034c	d1 e8		 shr	 eax, 1
  0034e	83 e0 01	 and	 eax, 1
  00351	85 c0		 test	 eax, eax
  00353	0f 84 02 01 00
	00		 je	 $LN5@GetIfMACAd

; 3240 :         {
; 3241 :             // "CTC: lcs interface %s not using mac %2.2X:%2.2X:%2.2X:%2.2X:%2.2X:%2.2X"
; 3242 :             WRMSG( HHC00943, "W", pLCSPORT->szNetIfName, *(pPortMAC+0), *(pPortMAC+1),

  00359	48 8b 44 24 70	 mov	 rax, QWORD PTR pPortMAC$[rsp]
  0035e	0f b6 40 05	 movzx	 eax, BYTE PTR [rax+5]
  00362	89 84 24 a0 00
	00 00		 mov	 DWORD PTR tv186[rsp], eax
  00369	48 8b 4c 24 70	 mov	 rcx, QWORD PTR pPortMAC$[rsp]
  0036e	0f b6 49 04	 movzx	 ecx, BYTE PTR [rcx+4]
  00372	89 8c 24 a4 00
	00 00		 mov	 DWORD PTR tv189[rsp], ecx
  00379	48 8b 54 24 70	 mov	 rdx, QWORD PTR pPortMAC$[rsp]
  0037e	0f b6 52 03	 movzx	 edx, BYTE PTR [rdx+3]
  00382	89 94 24 a8 00
	00 00		 mov	 DWORD PTR tv192[rsp], edx
  00389	48 8b 7c 24 70	 mov	 rdi, QWORD PTR pPortMAC$[rsp]
  0038e	0f b6 7f 02	 movzx	 edi, BYTE PTR [rdi+2]
  00392	4c 8b 44 24 70	 mov	 r8, QWORD PTR pPortMAC$[rsp]
  00397	45 0f b6 40 01	 movzx	 r8d, BYTE PTR [r8+1]
  0039c	44 89 84 24 ac
	00 00 00	 mov	 DWORD PTR tv198[rsp], r8d
  003a4	4c 8b 4c 24 70	 mov	 r9, QWORD PTR pPortMAC$[rsp]
  003a9	45 0f b6 09	 movzx	 r9d, BYTE PTR [r9]
  003ad	44 89 8c 24 b0
	00 00 00	 mov	 DWORD PTR tv200[rsp], r9d
  003b5	4c 8b 94 24 30
	01 00 00	 mov	 r10, QWORD PTR pLCSPORT$[rsp]
  003bd	49 81 c2 48 01
	00 00		 add	 r10, 328		; 00000148H
  003c4	4c 89 94 24 d8
	00 00 00	 mov	 QWORD PTR tv202[rsp], r10
  003cc	b9 01 00 00 00	 mov	 ecx, 1
  003d1	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  003d7	8b 8c 24 a0 00
	00 00		 mov	 ecx, DWORD PTR tv186[rsp]
  003de	89 4c 24 68	 mov	 DWORD PTR [rsp+104], ecx
  003e2	8b 8c 24 a4 00
	00 00		 mov	 ecx, DWORD PTR tv189[rsp]
  003e9	89 4c 24 60	 mov	 DWORD PTR [rsp+96], ecx
  003ed	8b 8c 24 a8 00
	00 00		 mov	 ecx, DWORD PTR tv192[rsp]
  003f4	89 4c 24 58	 mov	 DWORD PTR [rsp+88], ecx
  003f8	89 7c 24 50	 mov	 DWORD PTR [rsp+80], edi
  003fc	8b 8c 24 ac 00
	00 00		 mov	 ecx, DWORD PTR tv198[rsp]
  00403	89 4c 24 48	 mov	 DWORD PTR [rsp+72], ecx
  00407	8b 8c 24 b0 00
	00 00		 mov	 ecx, DWORD PTR tv200[rsp]
  0040e	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  00412	48 8b 8c 24 d8
	00 00 00	 mov	 rcx, QWORD PTR tv202[rsp]
  0041a	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  0041f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG172661
  00426	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  0042b	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG172662
  00432	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00437	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  0043c	41 b9 03 00 00
	00		 mov	 r9d, 3
  00442	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG172663
  00449	ba ab 0c 00 00	 mov	 edx, 3243		; 00000cabH
  0044e	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG172664
  00455	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg
$LN5@GetIfMACAd:

; 3243 :                              *(pPortMAC+2), *(pPortMAC+3), *(pPortMAC+4), *(pPortMAC+5));
; 3244 :         }
; 3245 : 
; 3246 :         memcpy( pPortMAC, pIFaceMAC, IFHWADDRLEN );    // Sets pLCSPORT->MAC_Address

  0045b	48 8b 7c 24 70	 mov	 rdi, QWORD PTR pPortMAC$[rsp]
  00460	48 8b b4 24 80
	00 00 00	 mov	 rsi, QWORD PTR pIFaceMAC$[rsp]
  00468	b9 06 00 00 00	 mov	 ecx, 6
  0046d	f3 a4		 rep movsb

; 3247 : 
; 3248 :         snprintf(pLCSPORT->szMACAddress, sizeof(pLCSPORT->szMACAddress),

  0046f	48 8b 44 24 70	 mov	 rax, QWORD PTR pPortMAC$[rsp]
  00474	0f b6 40 05	 movzx	 eax, BYTE PTR [rax+5]
  00478	48 8b 4c 24 70	 mov	 rcx, QWORD PTR pPortMAC$[rsp]
  0047d	0f b6 49 04	 movzx	 ecx, BYTE PTR [rcx+4]
  00481	48 8b 54 24 70	 mov	 rdx, QWORD PTR pPortMAC$[rsp]
  00486	0f b6 52 03	 movzx	 edx, BYTE PTR [rdx+3]
  0048a	48 8b 7c 24 70	 mov	 rdi, QWORD PTR pPortMAC$[rsp]
  0048f	0f b6 7f 02	 movzx	 edi, BYTE PTR [rdi+2]
  00493	48 8b 74 24 70	 mov	 rsi, QWORD PTR pPortMAC$[rsp]
  00498	0f b6 76 01	 movzx	 esi, BYTE PTR [rsi+1]
  0049c	4c 8b 44 24 70	 mov	 r8, QWORD PTR pPortMAC$[rsp]
  004a1	45 0f b6 00	 movzx	 r8d, BYTE PTR [r8]
  004a5	4c 8b 8c 24 30
	01 00 00	 mov	 r9, QWORD PTR pLCSPORT$[rsp]
  004ad	49 81 c1 58 01
	00 00		 add	 r9, 344			; 00000158H
  004b4	4c 89 8c 24 e0
	00 00 00	 mov	 QWORD PTR tv240[rsp], r9
  004bc	89 44 24 40	 mov	 DWORD PTR [rsp+64], eax
  004c0	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  004c4	89 54 24 30	 mov	 DWORD PTR [rsp+48], edx
  004c8	89 7c 24 28	 mov	 DWORD PTR [rsp+40], edi
  004cc	89 74 24 20	 mov	 DWORD PTR [rsp+32], esi
  004d0	45 8b c8	 mov	 r9d, r8d
  004d3	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG172665
  004da	ba 20 00 00 00	 mov	 edx, 32			; 00000020H
  004df	48 8b 84 24 e0
	00 00 00	 mov	 rax, QWORD PTR tv240[rsp]
  004e7	48 8b c8	 mov	 rcx, rax
  004ea	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_snprintf
$LN4@GetIfMACAd:
$LN1@GetIfMACAd:

; 3249 :             "%2.2X:%2.2X:%2.2X:%2.2X:%2.2X:%2.2X", *(pPortMAC+0), *(pPortMAC+1),
; 3250 :             *(pPortMAC+2), *(pPortMAC+3), *(pPortMAC+4), *(pPortMAC+5));
; 3251 :     }
; 3252 : }

  004f0	48 8b 8c 24 08
	01 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  004f8	48 33 cc	 xor	 rcx, rsp
  004fb	e8 00 00 00 00	 call	 __security_check_cookie
  00500	48 81 c4 18 01
	00 00		 add	 rsp, 280		; 00000118H
  00507	5f		 pop	 rdi
  00508	5e		 pop	 rsi
  00509	c3		 ret	 0
GetIfMACAddress ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\ctc_lcs.c
_TEXT	SEGMENT
ethtyp$ = 32
dsap$ = 36
ssap$ = 37
ieee$ = 38
snap$ = 39
ctl$ = 40
oui$ = 44
pkttyp$ = 48
__$ArrayPad$ = 72
pEthFrame$ = 112
pPktType$ = 120
pEthType$ = 128
pHas8022$ = 136
pHas8022Snap$ = 144
GetFrameInfo PROC

; 3130 : {

  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	56		 push	 rsi
  00015	57		 push	 rdi
  00016	48 83 ec 58	 sub	 rsp, 88			; 00000058H
  0001a	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00021	48 33 c4	 xor	 rax, rsp
  00024	48 89 44 24 48	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 3131 :     char  pkttyp[24];
; 3132 :     U32   oui;
; 3133 :     U16   ethtyp;
; 3134 :     BYTE  ieee, snap, dsap, ssap, ctl;
; 3135 : 
; 3136 :     memset(pkttyp, 0, sizeof(pkttyp));

  00029	48 8d 44 24 30	 lea	 rax, QWORD PTR pkttyp$[rsp]
  0002e	48 8b f8	 mov	 rdi, rax
  00031	33 c0		 xor	 eax, eax
  00033	b9 18 00 00 00	 mov	 ecx, 24
  00038	f3 aa		 rep stosb

; 3137 :     FETCH_HW( ethtyp, pEthFrame->hwEthernetType );

  0003a	48 8b 44 24 70	 mov	 rax, QWORD PTR pEthFrame$[rsp]
  0003f	48 83 c0 0c	 add	 rax, 12
  00043	48 8b c8	 mov	 rcx, rax
  00046	e8 00 00 00 00	 call	 fetch_hw_noswap
  0004b	0f b7 c8	 movzx	 ecx, ax
  0004e	e8 00 00 00 00	 call	 _byteswap_ushort
  00053	66 89 44 24 20	 mov	 WORD PTR ethtyp$[rsp], ax

; 3138 :     ieee = FALSE;

  00058	c6 44 24 26 00	 mov	 BYTE PTR ieee$[rsp], 0

; 3139 :     snap = FALSE;

  0005d	c6 44 24 27 00	 mov	 BYTE PTR snap$[rsp], 0

; 3140 :     if (ethtyp >= ETH_TYPE)

  00062	0f b7 44 24 20	 movzx	 eax, WORD PTR ethtyp$[rsp]
  00067	3d 00 06 00 00	 cmp	 eax, 1536		; 00000600H
  0006c	0f 8c e1 00 00
	00		 jl	 $LN2@GetFrameIn

; 3141 :     {
; 3142 :              if (ethtyp == ETH_TYPE_IP   )    STRLCPY( pkttyp, "IPv4"    );

  00072	0f b7 44 24 20	 movzx	 eax, WORD PTR ethtyp$[rsp]
  00077	3d 00 08 00 00	 cmp	 eax, 2048		; 00000800H
  0007c	75 1d		 jne	 SHORT $LN4@GetFrameIn
  0007e	41 b8 18 00 00
	00		 mov	 r8d, 24
  00084	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG172591
  0008b	48 8d 4c 24 30	 lea	 rcx, QWORD PTR pkttyp$[rsp]
  00090	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_strlcpy
  00096	e9 b3 00 00 00	 jmp	 $LN5@GetFrameIn
$LN4@GetFrameIn:

; 3143 :         else if (ethtyp == ETH_TYPE_IPV6 )    STRLCPY( pkttyp, "IPv6"    );

  0009b	0f b7 44 24 20	 movzx	 eax, WORD PTR ethtyp$[rsp]
  000a0	3d dd 86 00 00	 cmp	 eax, 34525		; 000086ddH
  000a5	75 1d		 jne	 SHORT $LN6@GetFrameIn
  000a7	41 b8 18 00 00
	00		 mov	 r8d, 24
  000ad	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG172594
  000b4	48 8d 4c 24 30	 lea	 rcx, QWORD PTR pkttyp$[rsp]
  000b9	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_strlcpy
  000bf	e9 8a 00 00 00	 jmp	 $LN7@GetFrameIn
$LN6@GetFrameIn:

; 3144 :         else if (ethtyp == ETH_TYPE_ARP  )    STRLCPY( pkttyp, "ARP"     );

  000c4	0f b7 44 24 20	 movzx	 eax, WORD PTR ethtyp$[rsp]
  000c9	3d 06 08 00 00	 cmp	 eax, 2054		; 00000806H
  000ce	75 1a		 jne	 SHORT $LN8@GetFrameIn
  000d0	41 b8 18 00 00
	00		 mov	 r8d, 24
  000d6	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG172597
  000dd	48 8d 4c 24 30	 lea	 rcx, QWORD PTR pkttyp$[rsp]
  000e2	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_strlcpy
  000e8	eb 64		 jmp	 SHORT $LN9@GetFrameIn
$LN8@GetFrameIn:

; 3145 :         else if (ethtyp == ETH_TYPE_RARP )    STRLCPY( pkttyp, "RARP"    );

  000ea	0f b7 44 24 20	 movzx	 eax, WORD PTR ethtyp$[rsp]
  000ef	3d 35 80 00 00	 cmp	 eax, 32821		; 00008035H
  000f4	75 1a		 jne	 SHORT $LN10@GetFrameIn
  000f6	41 b8 18 00 00
	00		 mov	 r8d, 24
  000fc	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG172600
  00103	48 8d 4c 24 30	 lea	 rcx, QWORD PTR pkttyp$[rsp]
  00108	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_strlcpy
  0010e	eb 3e		 jmp	 SHORT $LN11@GetFrameIn
$LN10@GetFrameIn:

; 3146 :         else if (ethtyp == ETH_TYPE_SNA  )    STRLCPY( pkttyp, "SNA"     );

  00110	0f b7 44 24 20	 movzx	 eax, WORD PTR ethtyp$[rsp]
  00115	3d d5 80 00 00	 cmp	 eax, 32981		; 000080d5H
  0011a	75 1a		 jne	 SHORT $LN12@GetFrameIn
  0011c	41 b8 18 00 00
	00		 mov	 r8d, 24
  00122	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG172603
  00129	48 8d 4c 24 30	 lea	 rcx, QWORD PTR pkttyp$[rsp]
  0012e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_strlcpy
  00134	eb 18		 jmp	 SHORT $LN13@GetFrameIn
$LN12@GetFrameIn:

; 3147 :         else                                  STRLCPY( pkttyp, "unknown" );

  00136	41 b8 18 00 00
	00		 mov	 r8d, 24
  0013c	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG172604
  00143	48 8d 4c 24 30	 lea	 rcx, QWORD PTR pkttyp$[rsp]
  00148	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_strlcpy
$LN13@GetFrameIn:
$LN11@GetFrameIn:
$LN9@GetFrameIn:
$LN7@GetFrameIn:
$LN5@GetFrameIn:

; 3148 :     }

  0014e	e9 2a 02 00 00	 jmp	 $LN3@GetFrameIn
$LN2@GetFrameIn:

; 3149 :     else
; 3150 :     {
; 3151 :         ieee = TRUE;

  00153	c6 44 24 26 01	 mov	 BYTE PTR ieee$[rsp], 1

; 3152 :                                               STRLCPY( pkttyp, "802.3 "  );

  00158	41 b8 18 00 00
	00		 mov	 r8d, 24
  0015e	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG172605
  00165	48 8d 4c 24 30	 lea	 rcx, QWORD PTR pkttyp$[rsp]
  0016a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_strlcpy

; 3153 :         dsap = (pEthFrame->bData[0] & 0xFE);

  00170	b8 01 00 00 00	 mov	 eax, 1
  00175	48 6b c0 00	 imul	 rax, rax, 0
  00179	48 8b 4c 24 70	 mov	 rcx, QWORD PTR pEthFrame$[rsp]
  0017e	0f b6 44 01 0e	 movzx	 eax, BYTE PTR [rcx+rax+14]
  00183	25 fe 00 00 00	 and	 eax, 254		; 000000feH
  00188	88 44 24 24	 mov	 BYTE PTR dsap$[rsp], al

; 3154 :         ssap = (pEthFrame->bData[1] & 0xFE);

  0018c	b8 01 00 00 00	 mov	 eax, 1
  00191	48 6b c0 01	 imul	 rax, rax, 1
  00195	48 8b 4c 24 70	 mov	 rcx, QWORD PTR pEthFrame$[rsp]
  0019a	0f b6 44 01 0e	 movzx	 eax, BYTE PTR [rcx+rax+14]
  0019f	25 fe 00 00 00	 and	 eax, 254		; 000000feH
  001a4	88 44 24 25	 mov	 BYTE PTR ssap$[rsp], al

; 3155 :         ctl =   pEthFrame->bData[2];

  001a8	b8 01 00 00 00	 mov	 eax, 1
  001ad	48 6b c0 02	 imul	 rax, rax, 2
  001b1	48 8b 4c 24 70	 mov	 rcx, QWORD PTR pEthFrame$[rsp]
  001b6	0f b6 44 01 0e	 movzx	 eax, BYTE PTR [rcx+rax+14]
  001bb	88 44 24 28	 mov	 BYTE PTR ctl$[rsp], al

; 3156 :         FETCH_F3( oui, pEthFrame->bData+3 );

  001bf	48 8b 44 24 70	 mov	 rax, QWORD PTR pEthFrame$[rsp]
  001c4	48 83 c0 11	 add	 rax, 17
  001c8	48 8b c8	 mov	 rcx, rax
  001cb	e8 00 00 00 00	 call	 fetch_f3_noswap
  001d0	8b c8		 mov	 ecx, eax
  001d2	e8 00 00 00 00	 call	 _byteswap_ulong
  001d7	89 44 24 2c	 mov	 DWORD PTR oui$[rsp], eax

; 3157 :         if ( dsap == LSAP_SNAP  &&  ssap == LSAP_SNAP  &&  ctl == 0x03  &&  !oui )

  001db	0f b6 44 24 24	 movzx	 eax, BYTE PTR dsap$[rsp]
  001e0	3d aa 00 00 00	 cmp	 eax, 170		; 000000aaH
  001e5	0f 85 42 01 00
	00		 jne	 $LN14@GetFrameIn
  001eb	0f b6 44 24 25	 movzx	 eax, BYTE PTR ssap$[rsp]
  001f0	3d aa 00 00 00	 cmp	 eax, 170		; 000000aaH
  001f5	0f 85 32 01 00
	00		 jne	 $LN14@GetFrameIn
  001fb	0f b6 44 24 28	 movzx	 eax, BYTE PTR ctl$[rsp]
  00200	83 f8 03	 cmp	 eax, 3
  00203	0f 85 24 01 00
	00		 jne	 $LN14@GetFrameIn
  00209	83 7c 24 2c 00	 cmp	 DWORD PTR oui$[rsp], 0
  0020e	0f 85 19 01 00
	00		 jne	 $LN14@GetFrameIn

; 3158 :         {
; 3159 :           snap = TRUE;

  00214	c6 44 24 27 01	 mov	 BYTE PTR snap$[rsp], 1

; 3160 :                                               STRLCAT( pkttyp, "SNAP "  );

  00219	41 b8 18 00 00
	00		 mov	 r8d, 24
  0021f	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG172608
  00226	48 8d 4c 24 30	 lea	 rcx, QWORD PTR pkttyp$[rsp]
  0022b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_strlcat

; 3161 :           FETCH_HW(ethtyp, pEthFrame->bData+6 );

  00231	48 8b 44 24 70	 mov	 rax, QWORD PTR pEthFrame$[rsp]
  00236	48 83 c0 14	 add	 rax, 20
  0023a	48 8b c8	 mov	 rcx, rax
  0023d	e8 00 00 00 00	 call	 fetch_hw_noswap
  00242	0f b7 c8	 movzx	 ecx, ax
  00245	e8 00 00 00 00	 call	 _byteswap_ushort
  0024a	66 89 44 24 20	 mov	 WORD PTR ethtyp$[rsp], ax

; 3162 :                if (ethtyp == ETH_TYPE_IP   )  STRLCAT( pkttyp, "IPv4"    );

  0024f	0f b7 44 24 20	 movzx	 eax, WORD PTR ethtyp$[rsp]
  00254	3d 00 08 00 00	 cmp	 eax, 2048		; 00000800H
  00259	75 1d		 jne	 SHORT $LN16@GetFrameIn
  0025b	41 b8 18 00 00
	00		 mov	 r8d, 24
  00261	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG172611
  00268	48 8d 4c 24 30	 lea	 rcx, QWORD PTR pkttyp$[rsp]
  0026d	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_strlcat
  00273	e9 b3 00 00 00	 jmp	 $LN17@GetFrameIn
$LN16@GetFrameIn:

; 3163 :           else if (ethtyp == ETH_TYPE_IPV6 )  STRLCAT( pkttyp, "IPv6"    );

  00278	0f b7 44 24 20	 movzx	 eax, WORD PTR ethtyp$[rsp]
  0027d	3d dd 86 00 00	 cmp	 eax, 34525		; 000086ddH
  00282	75 1d		 jne	 SHORT $LN18@GetFrameIn
  00284	41 b8 18 00 00
	00		 mov	 r8d, 24
  0028a	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG172614
  00291	48 8d 4c 24 30	 lea	 rcx, QWORD PTR pkttyp$[rsp]
  00296	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_strlcat
  0029c	e9 8a 00 00 00	 jmp	 $LN19@GetFrameIn
$LN18@GetFrameIn:

; 3164 :           else if (ethtyp == ETH_TYPE_ARP  )  STRLCAT( pkttyp, "ARP"     );

  002a1	0f b7 44 24 20	 movzx	 eax, WORD PTR ethtyp$[rsp]
  002a6	3d 06 08 00 00	 cmp	 eax, 2054		; 00000806H
  002ab	75 1a		 jne	 SHORT $LN20@GetFrameIn
  002ad	41 b8 18 00 00
	00		 mov	 r8d, 24
  002b3	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG172617
  002ba	48 8d 4c 24 30	 lea	 rcx, QWORD PTR pkttyp$[rsp]
  002bf	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_strlcat
  002c5	eb 64		 jmp	 SHORT $LN21@GetFrameIn
$LN20@GetFrameIn:

; 3165 :           else if (ethtyp == ETH_TYPE_RARP )  STRLCAT( pkttyp, "RARP"    );

  002c7	0f b7 44 24 20	 movzx	 eax, WORD PTR ethtyp$[rsp]
  002cc	3d 35 80 00 00	 cmp	 eax, 32821		; 00008035H
  002d1	75 1a		 jne	 SHORT $LN22@GetFrameIn
  002d3	41 b8 18 00 00
	00		 mov	 r8d, 24
  002d9	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG172620
  002e0	48 8d 4c 24 30	 lea	 rcx, QWORD PTR pkttyp$[rsp]
  002e5	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_strlcat
  002eb	eb 3e		 jmp	 SHORT $LN23@GetFrameIn
$LN22@GetFrameIn:

; 3166 :           else if (ethtyp == ETH_TYPE_SNA  )  STRLCAT( pkttyp, "SNA"     );

  002ed	0f b7 44 24 20	 movzx	 eax, WORD PTR ethtyp$[rsp]
  002f2	3d d5 80 00 00	 cmp	 eax, 32981		; 000080d5H
  002f7	75 1a		 jne	 SHORT $LN24@GetFrameIn
  002f9	41 b8 18 00 00
	00		 mov	 r8d, 24
  002ff	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG172623
  00306	48 8d 4c 24 30	 lea	 rcx, QWORD PTR pkttyp$[rsp]
  0030b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_strlcat
  00311	eb 18		 jmp	 SHORT $LN25@GetFrameIn
$LN24@GetFrameIn:

; 3167 :           else                                STRLCAT( pkttyp, "unknown" );

  00313	41 b8 18 00 00
	00		 mov	 r8d, 24
  00319	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG172624
  00320	48 8d 4c 24 30	 lea	 rcx, QWORD PTR pkttyp$[rsp]
  00325	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_strlcat
$LN25@GetFrameIn:
$LN23@GetFrameIn:
$LN21@GetFrameIn:
$LN19@GetFrameIn:
$LN17@GetFrameIn:

; 3168 :         }

  0032b	eb 50		 jmp	 SHORT $LN15@GetFrameIn
$LN14@GetFrameIn:

; 3169 :         else if ( dsap == LSAP_SNA_Path_Control || ssap == LSAP_SNA_Path_Control )

  0032d	0f b6 44 24 24	 movzx	 eax, BYTE PTR dsap$[rsp]
  00332	83 f8 04	 cmp	 eax, 4
  00335	74 0a		 je	 SHORT $LN28@GetFrameIn
  00337	0f b6 44 24 25	 movzx	 eax, BYTE PTR ssap$[rsp]
  0033c	83 f8 04	 cmp	 eax, 4
  0033f	75 24		 jne	 SHORT $LN26@GetFrameIn
$LN28@GetFrameIn:

; 3170 :         {
; 3171 :           ethtyp = ETH_TYPE_SNA;

  00341	b8 d5 80 00 00	 mov	 eax, 32981		; 000080d5H
  00346	66 89 44 24 20	 mov	 WORD PTR ethtyp$[rsp], ax

; 3172 :                                               STRLCAT( pkttyp, "SNA"     );

  0034b	41 b8 18 00 00
	00		 mov	 r8d, 24
  00351	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG172628
  00358	48 8d 4c 24 30	 lea	 rcx, QWORD PTR pkttyp$[rsp]
  0035d	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_strlcat

; 3173 :         }

  00363	eb 18		 jmp	 SHORT $LN27@GetFrameIn
$LN26@GetFrameIn:

; 3174 :         else
; 3175 :         {
; 3176 :                                               STRLCAT( pkttyp, "unknown" );

  00365	41 b8 18 00 00
	00		 mov	 r8d, 24
  0036b	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG172629
  00372	48 8d 4c 24 30	 lea	 rcx, QWORD PTR pkttyp$[rsp]
  00377	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_strlcat
$LN27@GetFrameIn:
$LN15@GetFrameIn:
$LN3@GetFrameIn:

; 3177 :         }
; 3178 :     }
; 3179 :     memcpy( pPktType, pkttyp, (strlen(pkttyp)+1) );

  0037d	48 8d 4c 24 30	 lea	 rcx, QWORD PTR pkttyp$[rsp]
  00382	e8 00 00 00 00	 call	 strlen
  00387	48 ff c0	 inc	 rax
  0038a	48 8d 4c 24 30	 lea	 rcx, QWORD PTR pkttyp$[rsp]
  0038f	48 8b 7c 24 78	 mov	 rdi, QWORD PTR pPktType$[rsp]
  00394	48 8b f1	 mov	 rsi, rcx
  00397	48 8b c8	 mov	 rcx, rax
  0039a	f3 a4		 rep movsb

; 3180 :     *pEthType = ethtyp;

  0039c	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR pEthType$[rsp]
  003a4	0f b7 4c 24 20	 movzx	 ecx, WORD PTR ethtyp$[rsp]
  003a9	66 89 08	 mov	 WORD PTR [rax], cx

; 3181 :     *pHas8022 = ieee;

  003ac	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR pHas8022$[rsp]
  003b4	0f b6 4c 24 26	 movzx	 ecx, BYTE PTR ieee$[rsp]
  003b9	88 08		 mov	 BYTE PTR [rax], cl

; 3182 :     *pHas8022Snap = snap;

  003bb	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR pHas8022Snap$[rsp]
  003c3	0f b6 4c 24 27	 movzx	 ecx, BYTE PTR snap$[rsp]
  003c8	88 08		 mov	 BYTE PTR [rax], cl

; 3183 : }

  003ca	48 8b 4c 24 48	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  003cf	48 33 cc	 xor	 rcx, rsp
  003d2	e8 00 00 00 00	 call	 __security_check_cookie
  003d7	48 83 c4 58	 add	 rsp, 88			; 00000058H
  003db	5f		 pop	 rdi
  003dc	5e		 pop	 rsi
  003dd	c3		 ret	 0
GetFrameInfo ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\ctc_lcs.c
_TEXT	SEGMENT
bPort$ = 64
pDEVBLK$ = 72
pReplyCmdFrame$ = 80
pLCSDEV$ = 128
pReply$ = 136
iSize$ = 144
LCS_DoEnqueueReplyFrame PROC

; 2212 : {

  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	56		 push	 rsi
  00010	57		 push	 rdi
  00011	48 83 ec 68	 sub	 rsp, 104		; 00000068H

; 2213 :     PLCSCMDHDR  pReplyCmdFrame;
; 2214 :     DEVBLK*     pDEVBLK;
; 2215 :     BYTE        bPort = pLCSDEV->bPort;

  00015	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR pLCSDEV$[rsp]
  0001d	0f b6 40 23	 movzx	 eax, BYTE PTR [rax+35]
  00021	88 44 24 40	 mov	 BYTE PTR bPort$[rsp], al

; 2216 : 
; 2217 :     pDEVBLK = pLCSDEV->pDEVBLK[ LCS_READ_SUBCHANN ];

  00025	b8 08 00 00 00	 mov	 eax, 8
  0002a	48 6b c0 00	 imul	 rax, rax, 0
  0002e	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR pLCSDEV$[rsp]
  00036	48 8b 44 01 10	 mov	 rax, QWORD PTR [rcx+rax+16]
  0003b	48 89 44 24 48	 mov	 QWORD PTR pDEVBLK$[rsp], rax
$LN4@LCS_DoEnqu:

; 2218 : 
; 2219 :     PTT_DEBUG(       "GET  DevDataLock  ", 000, pDEVBLK->devnum, bPort );

  00040	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_pttclass
  00047	48 8b 00	 mov	 rax, QWORD PTR [rax]
  0004a	48 25 00 00 02
	00		 and	 rax, 131072		; 00020000H
  00050	48 85 c0	 test	 rax, rax
  00053	74 40		 je	 SHORT $LN32@LCS_DoEnqu
  00055	0f b6 44 24 40	 movzx	 eax, BYTE PTR bPort$[rsp]
  0005a	48 8b 4c 24 48	 mov	 rcx, QWORD PTR pDEVBLK$[rsp]
  0005f	0f b7 49 48	 movzx	 ecx, WORD PTR [rcx+72]
  00063	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR [rsp+48], 0
  0006c	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  00071	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG171636
  00078	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  0007d	44 8b c9	 mov	 r9d, ecx
  00080	45 33 c0	 xor	 r8d, r8d
  00083	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG171637
  0008a	b9 00 00 02 00	 mov	 ecx, 131072		; 00020000H
  0008f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ptt_pthread_trace
$LN32@LCS_DoEnqu:
  00095	33 c0		 xor	 eax, eax
  00097	85 c0		 test	 eax, eax
  00099	75 a5		 jne	 SHORT $LN4@LCS_DoEnqu

; 2220 :     obtain_lock( &pLCSDEV->DevDataLock );

  0009b	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR pLCSDEV$[rsp]
  000a3	48 05 9a 00 00
	00		 add	 rax, 154		; 0000009aH
  000a9	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG171638
  000b0	48 8b c8	 mov	 rcx, rax
  000b3	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_obtain_lock
$LN7@LCS_DoEnqu:

; 2221 :     PTT_DEBUG(       "GOT  DevDataLock  ", 000, pDEVBLK->devnum, bPort );

  000b9	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_pttclass
  000c0	48 8b 00	 mov	 rax, QWORD PTR [rax]
  000c3	48 25 00 00 02
	00		 and	 rax, 131072		; 00020000H
  000c9	48 85 c0	 test	 rax, rax
  000cc	74 40		 je	 SHORT $LN33@LCS_DoEnqu
  000ce	0f b6 44 24 40	 movzx	 eax, BYTE PTR bPort$[rsp]
  000d3	48 8b 4c 24 48	 mov	 rcx, QWORD PTR pDEVBLK$[rsp]
  000d8	0f b7 49 48	 movzx	 ecx, WORD PTR [rcx+72]
  000dc	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR [rsp+48], 0
  000e5	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  000ea	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG171640
  000f1	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  000f6	44 8b c9	 mov	 r9d, ecx
  000f9	45 33 c0	 xor	 r8d, r8d
  000fc	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG171641
  00103	b9 00 00 02 00	 mov	 ecx, 131072		; 00020000H
  00108	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ptt_pthread_trace
$LN33@LCS_DoEnqu:
  0010e	33 c0		 xor	 eax, eax
  00110	85 c0		 test	 eax, eax
  00112	75 a5		 jne	 SHORT $LN7@LCS_DoEnqu

; 2222 :     {
; 2223 :         // Ensure we dont overflow the buffer
; 2224 :         if ((pLCSDEV->iFrameOffset +            // Current buffer Offset
; 2225 :               iSize +                           // Size of reply frame
; 2226 :               sizeof(pReply->bLCSHdr.hwOffset)) // Size of Frame terminator
; 2227 :             > pLCSDEV->iMaxFrameBufferSize)     // Size of Frame buffer

  00114	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR pLCSDEV$[rsp]
  0011c	0f b7 80 a2 00
	00 00		 movzx	 eax, WORD PTR [rax+162]
  00123	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR iSize$[rsp]
  0012b	48 8d 44 08 02	 lea	 rax, QWORD PTR [rax+rcx+2]
  00130	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR pLCSDEV$[rsp]
  00138	0f b7 89 a4 00
	00 00		 movzx	 ecx, WORD PTR [rcx+164]
  0013f	48 3b c1	 cmp	 rax, rcx
  00142	0f 86 ea 00 00
	00		 jbe	 $LN34@LCS_DoEnqu
$LN10@LCS_DoEnqu:

; 2228 :         {
; 2229 :             PTT_DEBUG( "*DoENQRep ENOBUFS ", 000, pDEVBLK->devnum, bPort );

  00148	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_pttclass
  0014f	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00152	48 25 00 00 02
	00		 and	 rax, 131072		; 00020000H
  00158	48 85 c0	 test	 rax, rax
  0015b	74 40		 je	 SHORT $LN35@LCS_DoEnqu
  0015d	0f b6 44 24 40	 movzx	 eax, BYTE PTR bPort$[rsp]
  00162	48 8b 4c 24 48	 mov	 rcx, QWORD PTR pDEVBLK$[rsp]
  00167	0f b7 49 48	 movzx	 ecx, WORD PTR [rcx+72]
  0016b	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR [rsp+48], 0
  00174	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  00179	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG171644
  00180	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00185	44 8b c9	 mov	 r9d, ecx
  00188	45 33 c0	 xor	 r8d, r8d
  0018b	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG171645
  00192	b9 00 00 02 00	 mov	 ecx, 131072		; 00020000H
  00197	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ptt_pthread_trace
$LN35@LCS_DoEnqu:
  0019d	33 c0		 xor	 eax, eax
  0019f	85 c0		 test	 eax, eax
  001a1	75 a5		 jne	 SHORT $LN10@LCS_DoEnqu
$LN13@LCS_DoEnqu:

; 2230 :             PTT_DEBUG(        "REL  DevDataLock  ", 000, pDEVBLK->devnum, bPort );

  001a3	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_pttclass
  001aa	48 8b 00	 mov	 rax, QWORD PTR [rax]
  001ad	48 25 00 00 02
	00		 and	 rax, 131072		; 00020000H
  001b3	48 85 c0	 test	 rax, rax
  001b6	74 40		 je	 SHORT $LN36@LCS_DoEnqu
  001b8	0f b6 44 24 40	 movzx	 eax, BYTE PTR bPort$[rsp]
  001bd	48 8b 4c 24 48	 mov	 rcx, QWORD PTR pDEVBLK$[rsp]
  001c2	0f b7 49 48	 movzx	 ecx, WORD PTR [rcx+72]
  001c6	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR [rsp+48], 0
  001cf	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  001d4	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG171647
  001db	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  001e0	44 8b c9	 mov	 r9d, ecx
  001e3	45 33 c0	 xor	 r8d, r8d
  001e6	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG171648
  001ed	b9 00 00 02 00	 mov	 ecx, 131072		; 00020000H
  001f2	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ptt_pthread_trace
$LN36@LCS_DoEnqu:
  001f8	33 c0		 xor	 eax, eax
  001fa	85 c0		 test	 eax, eax
  001fc	75 a5		 jne	 SHORT $LN13@LCS_DoEnqu

; 2231 :             release_lock( &pLCSDEV->DevDataLock );

  001fe	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR pLCSDEV$[rsp]
  00206	48 05 9a 00 00
	00		 add	 rax, 154		; 0000009aH
  0020c	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG171649
  00213	48 8b c8	 mov	 rcx, rax
  00216	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_release_lock

; 2232 :             errno = ENOBUFS;                    // No buffer space available

  0021c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno
  00222	c7 00 77 00 00
	00		 mov	 DWORD PTR [rax], 119	; 00000077H

; 2233 :             return -1;                          // (-1==failure)

  00228	b8 ff ff ff ff	 mov	 eax, -1
  0022d	e9 38 03 00 00	 jmp	 $LN1@LCS_DoEnqu
$LN34@LCS_DoEnqu:

; 2234 :         }
; 2235 : 
; 2236 :         // Point to next available LCS Frame slot in our buffer...
; 2237 :         pReplyCmdFrame = (PLCSCMDHDR)( pLCSDEV->bFrameBuffer +

  00232	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR pLCSDEV$[rsp]
  0023a	0f b7 80 a2 00
	00 00		 movzx	 eax, WORD PTR [rax+162]
  00241	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR pLCSDEV$[rsp]
  00249	48 8d 84 01 a6
	00 00 00	 lea	 rax, QWORD PTR [rcx+rax+166]
  00251	48 89 44 24 50	 mov	 QWORD PTR pReplyCmdFrame$[rsp], rax

; 2238 :                                        pLCSDEV->iFrameOffset );
; 2239 : 
; 2240 :         // Copy the reply frame into the frame buffer slot...
; 2241 :         memcpy( pReplyCmdFrame, pReply, iSize );

  00256	48 8b 7c 24 50	 mov	 rdi, QWORD PTR pReplyCmdFrame$[rsp]
  0025b	48 8b b4 24 88
	00 00 00	 mov	 rsi, QWORD PTR pReply$[rsp]
  00263	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR iSize$[rsp]
  0026b	f3 a4		 rep movsb

; 2242 : 
; 2243 :         // Increment buffer offset to NEXT next-available-slot...
; 2244 :         pLCSDEV->iFrameOffset += (U16) iSize;

  0026d	0f b7 84 24 90
	00 00 00	 movzx	 eax, WORD PTR iSize$[rsp]
  00275	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR pLCSDEV$[rsp]
  0027d	0f b7 89 a2 00
	00 00		 movzx	 ecx, WORD PTR [rcx+162]
  00284	03 c8		 add	 ecx, eax
  00286	8b c1		 mov	 eax, ecx
  00288	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR pLCSDEV$[rsp]
  00290	66 89 81 a2 00
	00 00		 mov	 WORD PTR [rcx+162], ax

; 2245 : 
; 2246 :         // Store offset of next frame
; 2247 :         STORE_HW( pReplyCmdFrame->bLCSHdr.hwOffset, pLCSDEV->iFrameOffset );

  00297	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR pLCSDEV$[rsp]
  0029f	0f b7 88 a2 00
	00 00		 movzx	 ecx, WORD PTR [rax+162]
  002a6	e8 00 00 00 00	 call	 _byteswap_ushort
  002ab	48 8b 4c 24 50	 mov	 rcx, QWORD PTR pReplyCmdFrame$[rsp]
  002b0	0f b7 d0	 movzx	 edx, ax
  002b3	e8 00 00 00 00	 call	 store_hw_noswap
$LN16@LCS_DoEnqu:

; 2248 : 
; 2249 :         // Mark reply pending
; 2250 :         PTT_DEBUG( "SET  ReplyPending ", 1, pDEVBLK->devnum, bPort );

  002b8	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_pttclass
  002bf	48 8b 00	 mov	 rax, QWORD PTR [rax]
  002c2	48 25 00 00 02
	00		 and	 rax, 131072		; 00020000H
  002c8	48 85 c0	 test	 rax, rax
  002cb	74 43		 je	 SHORT $LN37@LCS_DoEnqu
  002cd	0f b6 44 24 40	 movzx	 eax, BYTE PTR bPort$[rsp]
  002d2	48 8b 4c 24 48	 mov	 rcx, QWORD PTR pDEVBLK$[rsp]
  002d7	0f b7 49 48	 movzx	 ecx, WORD PTR [rcx+72]
  002db	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR [rsp+48], 0
  002e4	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  002e9	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG171651
  002f0	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  002f5	44 8b c9	 mov	 r9d, ecx
  002f8	41 b8 01 00 00
	00		 mov	 r8d, 1
  002fe	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG171652
  00305	b9 00 00 02 00	 mov	 ecx, 131072		; 00020000H
  0030a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ptt_pthread_trace
$LN37@LCS_DoEnqu:
  00310	33 c0		 xor	 eax, eax
  00312	85 c0		 test	 eax, eax
  00314	75 a2		 jne	 SHORT $LN16@LCS_DoEnqu

; 2251 :         pLCSDEV->fReplyPending = 1;

  00316	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR pLCSDEV$[rsp]
  0031e	8b 40 41	 mov	 eax, DWORD PTR [rax+65]
  00321	83 c8 08	 or	 eax, 8
  00324	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR pLCSDEV$[rsp]
  0032c	89 41 41	 mov	 DWORD PTR [rcx+65], eax
$LN19@LCS_DoEnqu:

; 2252 :     }
; 2253 :     PTT_DEBUG(        "REL  DevDataLock  ", 000, pDEVBLK->devnum, bPort );

  0032f	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_pttclass
  00336	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00339	48 25 00 00 02
	00		 and	 rax, 131072		; 00020000H
  0033f	48 85 c0	 test	 rax, rax
  00342	74 40		 je	 SHORT $LN38@LCS_DoEnqu
  00344	0f b6 44 24 40	 movzx	 eax, BYTE PTR bPort$[rsp]
  00349	48 8b 4c 24 48	 mov	 rcx, QWORD PTR pDEVBLK$[rsp]
  0034e	0f b7 49 48	 movzx	 ecx, WORD PTR [rcx+72]
  00352	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR [rsp+48], 0
  0035b	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  00360	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG171654
  00367	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  0036c	44 8b c9	 mov	 r9d, ecx
  0036f	45 33 c0	 xor	 r8d, r8d
  00372	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG171655
  00379	b9 00 00 02 00	 mov	 ecx, 131072		; 00020000H
  0037e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ptt_pthread_trace
$LN38@LCS_DoEnqu:
  00384	33 c0		 xor	 eax, eax
  00386	85 c0		 test	 eax, eax
  00388	75 a5		 jne	 SHORT $LN19@LCS_DoEnqu

; 2254 :     release_lock( &pLCSDEV->DevDataLock );

  0038a	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR pLCSDEV$[rsp]
  00392	48 05 9a 00 00
	00		 add	 rax, 154		; 0000009aH
  00398	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG171656
  0039f	48 8b c8	 mov	 rcx, rax
  003a2	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_release_lock
$LN22@LCS_DoEnqu:

; 2255 : 
; 2256 :     // (wake up "LCS_Read" function)
; 2257 :     PTT_DEBUG(       "GET  DevEventLock ", 000, pDEVBLK->devnum, bPort );

  003a8	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_pttclass
  003af	48 8b 00	 mov	 rax, QWORD PTR [rax]
  003b2	48 25 00 00 02
	00		 and	 rax, 131072		; 00020000H
  003b8	48 85 c0	 test	 rax, rax
  003bb	74 40		 je	 SHORT $LN39@LCS_DoEnqu
  003bd	0f b6 44 24 40	 movzx	 eax, BYTE PTR bPort$[rsp]
  003c2	48 8b 4c 24 48	 mov	 rcx, QWORD PTR pDEVBLK$[rsp]
  003c7	0f b7 49 48	 movzx	 ecx, WORD PTR [rcx+72]
  003cb	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR [rsp+48], 0
  003d4	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  003d9	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG171658
  003e0	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  003e5	44 8b c9	 mov	 r9d, ecx
  003e8	45 33 c0	 xor	 r8d, r8d
  003eb	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG171659
  003f2	b9 00 00 02 00	 mov	 ecx, 131072		; 00020000H
  003f7	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ptt_pthread_trace
$LN39@LCS_DoEnqu:
  003fd	33 c0		 xor	 eax, eax
  003ff	85 c0		 test	 eax, eax
  00401	75 a5		 jne	 SHORT $LN22@LCS_DoEnqu

; 2258 :     obtain_lock( &pLCSDEV->DevEventLock );

  00403	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR pLCSDEV$[rsp]
  0040b	48 83 c0 31	 add	 rax, 49			; 00000031H
  0040f	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG171660
  00416	48 8b c8	 mov	 rcx, rax
  00419	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_obtain_lock
$LN25@LCS_DoEnqu:

; 2259 :     PTT_DEBUG(       "GOT  DevEventLock ", 000, pDEVBLK->devnum, bPort );

  0041f	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_pttclass
  00426	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00429	48 25 00 00 02
	00		 and	 rax, 131072		; 00020000H
  0042f	48 85 c0	 test	 rax, rax
  00432	74 40		 je	 SHORT $LN40@LCS_DoEnqu
  00434	0f b6 44 24 40	 movzx	 eax, BYTE PTR bPort$[rsp]
  00439	48 8b 4c 24 48	 mov	 rcx, QWORD PTR pDEVBLK$[rsp]
  0043e	0f b7 49 48	 movzx	 ecx, WORD PTR [rcx+72]
  00442	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR [rsp+48], 0
  0044b	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  00450	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG171662
  00457	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  0045c	44 8b c9	 mov	 r9d, ecx
  0045f	45 33 c0	 xor	 r8d, r8d
  00462	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG171663
  00469	b9 00 00 02 00	 mov	 ecx, 131072		; 00020000H
  0046e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ptt_pthread_trace
$LN40@LCS_DoEnqu:
  00474	33 c0		 xor	 eax, eax
  00476	85 c0		 test	 eax, eax
  00478	75 a5		 jne	 SHORT $LN25@LCS_DoEnqu
$LN28@LCS_DoEnqu:

; 2260 :     {
; 2261 :         PTT_DEBUG(            "SIG  DevEvent     ", 000, pDEVBLK->devnum, bPort );

  0047a	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_pttclass
  00481	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00484	48 25 00 00 02
	00		 and	 rax, 131072		; 00020000H
  0048a	48 85 c0	 test	 rax, rax
  0048d	74 40		 je	 SHORT $LN41@LCS_DoEnqu
  0048f	0f b6 44 24 40	 movzx	 eax, BYTE PTR bPort$[rsp]
  00494	48 8b 4c 24 48	 mov	 rcx, QWORD PTR pDEVBLK$[rsp]
  00499	0f b7 49 48	 movzx	 ecx, WORD PTR [rcx+72]
  0049d	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR [rsp+48], 0
  004a6	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  004ab	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG171665
  004b2	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  004b7	44 8b c9	 mov	 r9d, ecx
  004ba	45 33 c0	 xor	 r8d, r8d
  004bd	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG171666
  004c4	b9 00 00 02 00	 mov	 ecx, 131072		; 00020000H
  004c9	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ptt_pthread_trace
$LN41@LCS_DoEnqu:
  004cf	33 c0		 xor	 eax, eax
  004d1	85 c0		 test	 eax, eax
  004d3	75 a5		 jne	 SHORT $LN28@LCS_DoEnqu

; 2262 :         signal_condition( &pLCSDEV->DevEvent );

  004d5	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR pLCSDEV$[rsp]
  004dd	48 83 c0 39	 add	 rax, 57			; 00000039H
  004e1	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG171667
  004e8	48 8b c8	 mov	 rcx, rax
  004eb	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_signal_condition
$LN31@LCS_DoEnqu:

; 2263 :     }
; 2264 :     PTT_DEBUG(        "REL  DevEventLock ", 000, pDEVBLK->devnum, bPort );

  004f1	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_pttclass
  004f8	48 8b 00	 mov	 rax, QWORD PTR [rax]
  004fb	48 25 00 00 02
	00		 and	 rax, 131072		; 00020000H
  00501	48 85 c0	 test	 rax, rax
  00504	74 40		 je	 SHORT $LN42@LCS_DoEnqu
  00506	0f b6 44 24 40	 movzx	 eax, BYTE PTR bPort$[rsp]
  0050b	48 8b 4c 24 48	 mov	 rcx, QWORD PTR pDEVBLK$[rsp]
  00510	0f b7 49 48	 movzx	 ecx, WORD PTR [rcx+72]
  00514	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR [rsp+48], 0
  0051d	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  00522	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG171669
  00529	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  0052e	44 8b c9	 mov	 r9d, ecx
  00531	45 33 c0	 xor	 r8d, r8d
  00534	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG171670
  0053b	b9 00 00 02 00	 mov	 ecx, 131072		; 00020000H
  00540	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ptt_pthread_trace
$LN42@LCS_DoEnqu:
  00546	33 c0		 xor	 eax, eax
  00548	85 c0		 test	 eax, eax
  0054a	75 a5		 jne	 SHORT $LN31@LCS_DoEnqu

; 2265 :     release_lock( &pLCSDEV->DevEventLock );

  0054c	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR pLCSDEV$[rsp]
  00554	48 83 c0 31	 add	 rax, 49			; 00000031H
  00558	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG171671
  0055f	48 8b c8	 mov	 rcx, rax
  00562	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_release_lock

; 2266 : 
; 2267 :     return 0;   // success

  00568	33 c0		 xor	 eax, eax
$LN1@LCS_DoEnqu:

; 2268 : }

  0056a	48 83 c4 68	 add	 rsp, 104		; 00000068H
  0056e	5f		 pop	 rdi
  0056f	5e		 pop	 rsi
  00570	c3		 ret	 0
LCS_DoEnqueueReplyFrame ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\ctc_lcs.c
_TEXT	SEGMENT
bPort$ = 80
c$1 = 84
pDEVBLK$ = 88
tv78 = 96
tv82 = 100
tv194 = 104
tv196 = 108
pLCSPORT$ = 112
t2$ = 120
t1$ = 128
str$2 = 136
__$ArrayPad$ = 176
pLCSDEV$ = 208
pReply$ = 216
iSize$ = 224
LCS_EnqueueReplyFrame PROC

; 2135 : {

  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	48 81 ec c8 00
	00 00		 sub	 rsp, 200		; 000000c8H
  00016	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  0001d	48 33 c4	 xor	 rax, rsp
  00020	48 89 84 24 b0
	00 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 2136 :     PLCSPORT  pLCSPORT;
; 2137 :     DEVBLK*   pDEVBLK;
; 2138 : 
; 2139 :     BYTE      bPort;
; 2140 :     time_t    t1, t2;
; 2141 : 
; 2142 : 
; 2143 :     bPort = pLCSDEV->bPort;

  00028	48 8b 84 24 d0
	00 00 00	 mov	 rax, QWORD PTR pLCSDEV$[rsp]
  00030	0f b6 40 23	 movzx	 eax, BYTE PTR [rax+35]
  00034	88 44 24 50	 mov	 BYTE PTR bPort$[rsp], al

; 2144 :     pLCSPORT = &pLCSDEV->pLCSBLK->Port[ bPort ];

  00038	48 8b 84 24 d0
	00 00 00	 mov	 rax, QWORD PTR pLCSDEV$[rsp]
  00040	48 8b 40 08	 mov	 rax, QWORD PTR [rax+8]
  00044	0f b6 4c 24 50	 movzx	 ecx, BYTE PTR bPort$[rsp]
  00049	48 69 c9 98 01
	00 00		 imul	 rcx, rcx, 408		; 00000198H
  00050	48 8d 44 08 60	 lea	 rax, QWORD PTR [rax+rcx+96]
  00055	48 89 44 24 70	 mov	 QWORD PTR pLCSPORT$[rsp], rax

; 2145 :     pDEVBLK = pLCSDEV->pDEVBLK[ LCS_READ_SUBCHANN ];

  0005a	b8 08 00 00 00	 mov	 eax, 8
  0005f	48 6b c0 00	 imul	 rax, rax, 0
  00063	48 8b 8c 24 d0
	00 00 00	 mov	 rcx, QWORD PTR pLCSDEV$[rsp]
  0006b	48 8b 44 01 10	 mov	 rax, QWORD PTR [rcx+rax+16]
  00070	48 89 44 24 58	 mov	 QWORD PTR pDEVBLK$[rsp], rax

; 2146 : 
; 2147 :     // Trace command reply frame about to be enqueued...
; 2148 :     if (pLCSDEV->pLCSBLK->fDebug)

  00075	48 8b 84 24 d0
	00 00 00	 mov	 rax, QWORD PTR pLCSDEV$[rsp]
  0007d	48 8b 40 08	 mov	 rax, QWORD PTR [rax+8]
  00081	8b 40 18	 mov	 eax, DWORD PTR [rax+24]
  00084	83 e0 01	 and	 eax, 1
  00087	85 c0		 test	 eax, eax
  00089	0f 84 a9 00 00
	00		 je	 $LN25@LCS_Enqueu

; 2149 :     {
; 2150 :         // HHC00923 "%1d:%04X CTC: lcs command reply enqueue"
; 2151 :         WRMSG( HHC00923, "D", SSID_TO_LCSS( pDEVBLK->ssid ), pDEVBLK->devnum );

  0008f	48 8b 44 24 58	 mov	 rax, QWORD PTR pDEVBLK$[rsp]
  00094	0f b7 40 48	 movzx	 eax, WORD PTR [rax+72]
  00098	89 44 24 60	 mov	 DWORD PTR tv78[rsp], eax
  0009c	48 8b 4c 24 58	 mov	 rcx, QWORD PTR pDEVBLK$[rsp]
  000a1	0f b7 49 44	 movzx	 ecx, WORD PTR [rcx+68]
  000a5	d1 f9		 sar	 ecx, 1
  000a7	89 4c 24 64	 mov	 DWORD PTR tv82[rsp], ecx
  000ab	b9 01 00 00 00	 mov	 ecx, 1
  000b0	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  000b6	8b 4c 24 60	 mov	 ecx, DWORD PTR tv78[rsp]
  000ba	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  000be	8b 4c 24 64	 mov	 ecx, DWORD PTR tv82[rsp]
  000c2	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  000c6	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG171497
  000cd	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  000d2	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG171498
  000d9	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  000de	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  000e3	41 b9 03 00 00
	00		 mov	 r9d, 3
  000e9	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG171499
  000f0	ba 67 08 00 00	 mov	 edx, 2151		; 00000867H
  000f5	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG171500
  000fc	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 2152 :         net_data_trace( pDEVBLK, (BYTE*)pReply, iSize, TO_GUEST, 'D', "reply", 0 );

  00102	c7 44 24 30 00
	00 00 00	 mov	 DWORD PTR [rsp+48], 0
  0010a	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG171501
  00111	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  00116	c6 44 24 20 44	 mov	 BYTE PTR [rsp+32], 68	; 00000044H
  0011b	41 b1 3e	 mov	 r9b, 62			; 0000003eH
  0011e	44 8b 84 24 e0
	00 00 00	 mov	 r8d, DWORD PTR iSize$[rsp]
  00126	48 8b 94 24 d8
	00 00 00	 mov	 rdx, QWORD PTR pReply$[rsp]
  0012e	48 8b 4c 24 58	 mov	 rcx, QWORD PTR pDEVBLK$[rsp]
  00133	e8 00 00 00 00	 call	 net_data_trace
$LN25@LCS_Enqueu:
$LN4@LCS_Enqueu:

; 2153 :     }
; 2154 : 
; 2155 :     PTT_DEBUG( "ENQ RepFrame ENTRY", pReply->bCmdCode, pDEVBLK->devnum, bPort );

  00138	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_pttclass
  0013f	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00142	48 25 00 00 02
	00		 and	 rax, 131072		; 00020000H
  00148	48 85 c0	 test	 rax, rax
  0014b	74 4c		 je	 SHORT $LN26@LCS_Enqueu
  0014d	0f b6 44 24 50	 movzx	 eax, BYTE PTR bPort$[rsp]
  00152	48 8b 4c 24 58	 mov	 rcx, QWORD PTR pDEVBLK$[rsp]
  00157	0f b7 49 48	 movzx	 ecx, WORD PTR [rcx+72]
  0015b	48 8b 94 24 d8
	00 00 00	 mov	 rdx, QWORD PTR pReply$[rsp]
  00163	0f b6 52 04	 movzx	 edx, BYTE PTR [rdx+4]
  00167	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR [rsp+48], 0
  00170	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  00175	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG171503
  0017c	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00181	44 8b c9	 mov	 r9d, ecx
  00184	44 8b c2	 mov	 r8d, edx
  00187	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG171504
  0018e	b9 00 00 02 00	 mov	 ecx, 131072		; 00020000H
  00193	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ptt_pthread_trace
$LN26@LCS_Enqueu:
  00199	33 c0		 xor	 eax, eax
  0019b	85 c0		 test	 eax, eax
  0019d	75 99		 jne	 SHORT $LN4@LCS_Enqueu

; 2156 : 
; 2157 :     time( &t1 );

  0019f	48 8d 8c 24 80
	00 00 00	 lea	 rcx, QWORD PTR t1$[rsp]
  001a7	e8 00 00 00 00	 call	 time
$LN7@LCS_Enqueu:

; 2158 : 
; 2159 :     PTT_TIMING( "b4 repNQ", 0, iSize, 0 );

  001ac	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_pttclass
  001b3	48 8b 00	 mov	 rax, QWORD PTR [rax]
  001b6	48 25 00 00 01
	00		 and	 rax, 65536		; 00010000H
  001bc	48 85 c0	 test	 rax, rax
  001bf	74 3b		 je	 SHORT $LN27@LCS_Enqueu
  001c1	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR [rsp+48], 0
  001ca	48 c7 44 24 28
	00 00 00 00	 mov	 QWORD PTR [rsp+40], 0
  001d3	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG171506
  001da	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  001df	4c 8b 8c 24 e0
	00 00 00	 mov	 r9, QWORD PTR iSize$[rsp]
  001e7	45 33 c0	 xor	 r8d, r8d
  001ea	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG171507
  001f1	b9 00 00 01 00	 mov	 ecx, 65536		; 00010000H
  001f6	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ptt_pthread_trace
$LN27@LCS_Enqueu:
  001fc	33 c0		 xor	 eax, eax
  001fe	85 c0		 test	 eax, eax
  00200	75 aa		 jne	 SHORT $LN7@LCS_Enqueu
$LN8@LCS_Enqueu:

; 2160 : 
; 2161 :     // While port open, not close in progress, and frame buffer full...
; 2162 : 
; 2163 :     while (1
; 2164 :         &&  pLCSPORT->fd != -1
; 2165 :         && !pLCSPORT->fCloseInProgress
; 2166 :         && LCS_DoEnqueueReplyFrame( pLCSDEV, pReply, iSize ) < 0

  00202	33 c0		 xor	 eax, eax
  00204	83 f8 01	 cmp	 eax, 1
  00207	0f 84 48 02 00
	00		 je	 $LN9@LCS_Enqueu
  0020d	48 8b 44 24 70	 mov	 rax, QWORD PTR pLCSPORT$[rsp]
  00212	83 b8 38 01 00
	00 ff		 cmp	 DWORD PTR [rax+312], -1
  00219	0f 84 36 02 00
	00		 je	 $LN9@LCS_Enqueu
  0021f	48 8b 44 24 70	 mov	 rax, QWORD PTR pLCSPORT$[rsp]
  00224	8b 80 34 01 00
	00		 mov	 eax, DWORD PTR [rax+308]
  0022a	c1 e8 05	 shr	 eax, 5
  0022d	83 e0 01	 and	 eax, 1
  00230	85 c0		 test	 eax, eax
  00232	0f 85 1d 02 00
	00		 jne	 $LN9@LCS_Enqueu
  00238	4c 8b 84 24 e0
	00 00 00	 mov	 r8, QWORD PTR iSize$[rsp]
  00240	48 8b 94 24 d8
	00 00 00	 mov	 rdx, QWORD PTR pReply$[rsp]
  00248	48 8b 8c 24 d0
	00 00 00	 mov	 rcx, QWORD PTR pLCSDEV$[rsp]
  00250	e8 00 00 00 00	 call	 LCS_DoEnqueueReplyFrame
  00255	85 c0		 test	 eax, eax
  00257	0f 8d f8 01 00
	00		 jge	 $LN9@LCS_Enqueu

; 2167 :     )
; 2168 :     {
; 2169 :         if (pLCSDEV->pLCSBLK->fDebug)

  0025d	48 8b 84 24 d0
	00 00 00	 mov	 rax, QWORD PTR pLCSDEV$[rsp]
  00265	48 8b 40 08	 mov	 rax, QWORD PTR [rax+8]
  00269	8b 40 18	 mov	 eax, DWORD PTR [rax+24]
  0026c	83 e0 01	 and	 eax, 1
  0026f	85 c0		 test	 eax, eax
  00271	0f 84 0b 01 00
	00		 je	 $LN28@LCS_Enqueu

; 2170 :         {
; 2171 :             // Limit message rate to only once every few seconds...
; 2172 : 
; 2173 :             time( &t2 );

  00277	48 8d 4c 24 78	 lea	 rcx, QWORD PTR t2$[rsp]
  0027c	e8 00 00 00 00	 call	 time

; 2174 : 
; 2175 :             if ((t2 - t1) >= 3)     // (only once every 3 seconds)

  00281	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR t1$[rsp]
  00289	48 8b 4c 24 78	 mov	 rcx, QWORD PTR t2$[rsp]
  0028e	48 2b c8	 sub	 rcx, rax
  00291	48 8b c1	 mov	 rax, rcx
  00294	48 83 f8 03	 cmp	 rax, 3
  00298	0f 8c e4 00 00
	00		 jl	 $LN29@LCS_Enqueu

; 2176 :             {
; 2177 :                 union converter { struct { unsigned char a, b, c, d; } b; U32 i; } c;
; 2178 :                 char  str[40];
; 2179 : 
; 2180 :                 t1 = t2;

  0029e	48 8b 44 24 78	 mov	 rax, QWORD PTR t2$[rsp]
  002a3	48 89 84 24 80
	00 00 00	 mov	 QWORD PTR t1$[rsp], rax

; 2181 : 
; 2182 :                 c.i = ntohl( pLCSDEV->lIPAddress );

  002ab	48 8b 84 24 d0
	00 00 00	 mov	 rax, QWORD PTR pLCSDEV$[rsp]
  002b3	8b 48 2d	 mov	 ecx, DWORD PTR [rax+45]
  002b6	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ntohl
  002bc	89 44 24 54	 mov	 DWORD PTR c$1[rsp], eax

; 2183 :                 MSGBUF( str, "%8.08X %d.%d.%d.%d", c.i, c.b.d, c.b.c, c.b.b, c.b.a );

  002c0	0f b6 44 24 54	 movzx	 eax, BYTE PTR c$1[rsp]
  002c5	0f b6 4c 24 55	 movzx	 ecx, BYTE PTR c$1[rsp+1]
  002ca	0f b6 54 24 56	 movzx	 edx, BYTE PTR c$1[rsp+2]
  002cf	44 0f b6 44 24
	57		 movzx	 r8d, BYTE PTR c$1[rsp+3]
  002d5	89 44 24 38	 mov	 DWORD PTR [rsp+56], eax
  002d9	89 4c 24 30	 mov	 DWORD PTR [rsp+48], ecx
  002dd	89 54 24 28	 mov	 DWORD PTR [rsp+40], edx
  002e1	44 89 44 24 20	 mov	 DWORD PTR [rsp+32], r8d
  002e6	44 8b 4c 24 54	 mov	 r9d, DWORD PTR c$1[rsp]
  002eb	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG171510
  002f2	ba 28 00 00 00	 mov	 edx, 40			; 00000028H
  002f7	48 8d 8c 24 88
	00 00 00	 lea	 rcx, QWORD PTR str$2[rsp]
  002ff	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_snprintf

; 2184 : 
; 2185 :                 // "CTC: lcs device port %2.2X: STILL trying to enqueue REPLY frame to device %4.4X %s"
; 2186 :                 WRMSG( HHC00978, "D", bPort, pLCSDEV->sAddr, str );

  00305	48 8b 84 24 d0
	00 00 00	 mov	 rax, QWORD PTR pLCSDEV$[rsp]
  0030d	0f b7 40 20	 movzx	 eax, WORD PTR [rax+32]
  00311	89 44 24 68	 mov	 DWORD PTR tv194[rsp], eax
  00315	0f b6 4c 24 50	 movzx	 ecx, BYTE PTR bPort$[rsp]
  0031a	89 4c 24 6c	 mov	 DWORD PTR tv196[rsp], ecx
  0031e	b9 01 00 00 00	 mov	 ecx, 1
  00323	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  00329	48 8d 8c 24 88
	00 00 00	 lea	 rcx, QWORD PTR str$2[rsp]
  00331	48 89 4c 24 48	 mov	 QWORD PTR [rsp+72], rcx
  00336	8b 4c 24 68	 mov	 ecx, DWORD PTR tv194[rsp]
  0033a	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  0033e	8b 4c 24 6c	 mov	 ecx, DWORD PTR tv196[rsp]
  00342	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  00346	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG171511
  0034d	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  00352	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG171512
  00359	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  0035e	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00363	41 b9 03 00 00
	00		 mov	 r9d, 3
  00369	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG171513
  00370	ba 8a 08 00 00	 mov	 edx, 2186		; 0000088aH
  00375	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG171514
  0037c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg
$LN29@LCS_Enqueu:
$LN28@LCS_Enqueu:
$LN12@LCS_Enqueu:

; 2187 :             }
; 2188 :         }
; 2189 :         PTT_TIMING( "*repNQ wait", 0, iSize, 0 );

  00382	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_pttclass
  00389	48 8b 00	 mov	 rax, QWORD PTR [rax]
  0038c	48 25 00 00 01
	00		 and	 rax, 65536		; 00010000H
  00392	48 85 c0	 test	 rax, rax
  00395	74 3b		 je	 SHORT $LN30@LCS_Enqueu
  00397	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR [rsp+48], 0
  003a0	48 c7 44 24 28
	00 00 00 00	 mov	 QWORD PTR [rsp+40], 0
  003a9	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG171516
  003b0	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  003b5	4c 8b 8c 24 e0
	00 00 00	 mov	 r9, QWORD PTR iSize$[rsp]
  003bd	45 33 c0	 xor	 r8d, r8d
  003c0	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG171517
  003c7	b9 00 00 01 00	 mov	 ecx, 65536		; 00010000H
  003cc	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ptt_pthread_trace
$LN30@LCS_Enqueu:
  003d2	33 c0		 xor	 eax, eax
  003d4	85 c0		 test	 eax, eax
  003d6	75 aa		 jne	 SHORT $LN12@LCS_Enqueu
$LN15@LCS_Enqueu:

; 2190 : 
; 2191 :         // Wait for LCS_Read to empty the buffer...
; 2192 : 
; 2193 :         ASSERT( ENOBUFS == errno );

  003d8	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno
  003de	83 38 77	 cmp	 DWORD PTR [rax], 119	; 00000077H
  003e1	74 5c		 je	 SHORT $LN31@LCS_Enqueu
$LN18@LCS_Enqueu:
  003e3	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG171519
  003ea	41 b8 91 08 00
	00		 mov	 r8d, 2193		; 00000891H
  003f0	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG171520
  003f7	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG171521
  003fe	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_logmsg
  00404	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_IsDebuggerPresent
  0040a	85 c0		 test	 eax, eax
  0040c	74 20		 je	 SHORT $LN32@LCS_Enqueu
  0040e	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG171523
  00415	41 b8 91 08 00
	00		 mov	 r8d, 2193		; 00000891H
  0041b	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG171524
  00422	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG171525
  00429	e8 00 00 00 00	 call	 DebuggerTrace
$LN32@LCS_Enqueu:
  0042e	33 c0		 xor	 eax, eax
  00430	85 c0		 test	 eax, eax
  00432	75 af		 jne	 SHORT $LN18@LCS_Enqueu
  00434	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_IsDebuggerPresent
  0043a	85 c0		 test	 eax, eax
  0043c	74 01		 je	 SHORT $LN33@LCS_Enqueu
  0043e	cc		 int	 3
$LN33@LCS_Enqueu:
$LN31@LCS_Enqueu:
  0043f	33 c0		 xor	 eax, eax
  00441	85 c0		 test	 eax, eax
  00443	75 93		 jne	 SHORT $LN15@LCS_Enqueu

; 2194 :         usleep( CTC_DELAY_USECS );

  00445	b9 64 00 00 00	 mov	 ecx, 100		; 00000064H
  0044a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_usleep

; 2195 :     }

  00450	e9 ad fd ff ff	 jmp	 $LN8@LCS_Enqueu
$LN9@LCS_Enqueu:
$LN21@LCS_Enqueu:

; 2196 :     PTT_TIMING( "af repNQ", 0, iSize, 0 );

  00455	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_pttclass
  0045c	48 8b 00	 mov	 rax, QWORD PTR [rax]
  0045f	48 25 00 00 01
	00		 and	 rax, 65536		; 00010000H
  00465	48 85 c0	 test	 rax, rax
  00468	74 3b		 je	 SHORT $LN34@LCS_Enqueu
  0046a	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR [rsp+48], 0
  00473	48 c7 44 24 28
	00 00 00 00	 mov	 QWORD PTR [rsp+40], 0
  0047c	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG171528
  00483	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00488	4c 8b 8c 24 e0
	00 00 00	 mov	 r9, QWORD PTR iSize$[rsp]
  00490	45 33 c0	 xor	 r8d, r8d
  00493	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG171529
  0049a	b9 00 00 01 00	 mov	 ecx, 65536		; 00010000H
  0049f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ptt_pthread_trace
$LN34@LCS_Enqueu:
  004a5	33 c0		 xor	 eax, eax
  004a7	85 c0		 test	 eax, eax
  004a9	75 aa		 jne	 SHORT $LN21@LCS_Enqueu
$LN24@LCS_Enqueu:

; 2197 :     PTT_DEBUG( "ENQ RepFrame EXIT ", pReply->bCmdCode, pDEVBLK->devnum, bPort );

  004ab	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_pttclass
  004b2	48 8b 00	 mov	 rax, QWORD PTR [rax]
  004b5	48 25 00 00 02
	00		 and	 rax, 131072		; 00020000H
  004bb	48 85 c0	 test	 rax, rax
  004be	74 4c		 je	 SHORT $LN35@LCS_Enqueu
  004c0	0f b6 44 24 50	 movzx	 eax, BYTE PTR bPort$[rsp]
  004c5	48 8b 4c 24 58	 mov	 rcx, QWORD PTR pDEVBLK$[rsp]
  004ca	0f b7 49 48	 movzx	 ecx, WORD PTR [rcx+72]
  004ce	48 8b 94 24 d8
	00 00 00	 mov	 rdx, QWORD PTR pReply$[rsp]
  004d6	0f b6 52 04	 movzx	 edx, BYTE PTR [rdx+4]
  004da	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR [rsp+48], 0
  004e3	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  004e8	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG171531
  004ef	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  004f4	44 8b c9	 mov	 r9d, ecx
  004f7	44 8b c2	 mov	 r8d, edx
  004fa	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG171532
  00501	b9 00 00 02 00	 mov	 ecx, 131072		; 00020000H
  00506	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ptt_pthread_trace
$LN35@LCS_Enqueu:
  0050c	33 c0		 xor	 eax, eax
  0050e	85 c0		 test	 eax, eax
  00510	75 99		 jne	 SHORT $LN24@LCS_Enqueu

; 2198 : }

  00512	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  0051a	48 33 cc	 xor	 rcx, rsp
  0051d	e8 00 00 00 00	 call	 __security_check_cookie
  00522	48 81 c4 c8 00
	00 00		 add	 rsp, 200		; 000000c8H
  00529	c3		 ret	 0
LCS_EnqueueReplyFrame ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\ctc_lcs.c
_TEXT	SEGMENT
bPort$ = 64
pDEVBLK$ = 72
pLCSEthFrame$ = 80
pLCSPORT$ = 128
pLCSDEV$ = 136
pData$ = 144
iSize$ = 152
LCS_DoEnqueueEthFrame PROC

; 2828 : {

  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	56		 push	 rsi
  00015	57		 push	 rdi
  00016	48 83 ec 68	 sub	 rsp, 104		; 00000068H

; 2829 :     PLCSETHFRM  pLCSEthFrame;
; 2830 :     DEVBLK*     pDEVBLK;
; 2831 :     BYTE        bPort;
; 2832 : 
; 2833 : 
; 2834 :     pDEVBLK = pLCSDEV->pDEVBLK[ LCS_READ_SUBCHANN ];

  0001a	b8 08 00 00 00	 mov	 eax, 8
  0001f	48 6b c0 00	 imul	 rax, rax, 0
  00023	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR pLCSDEV$[rsp]
  0002b	48 8b 44 01 10	 mov	 rax, QWORD PTR [rcx+rax+16]
  00030	48 89 44 24 48	 mov	 QWORD PTR pDEVBLK$[rsp], rax

; 2835 :     bPort   = pLCSPORT->bPort;

  00035	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR pLCSPORT$[rsp]
  0003d	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  00040	88 44 24 40	 mov	 BYTE PTR bPort$[rsp], al

; 2836 : 
; 2837 :     // Will frame NEVER fit into buffer??
; 2838 :     if (iSize > MAX_LCS_ETH_FRAME_SIZE( pLCSDEV ) || iSize > 9000)

  00044	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR pLCSDEV$[rsp]
  0004c	0f b7 80 a4 00
	00 00		 movzx	 eax, WORD PTR [rax+164]
  00053	48 83 e8 06	 sub	 rax, 6
  00057	48 39 84 24 98
	00 00 00	 cmp	 QWORD PTR iSize$[rsp], rax
  0005f	77 0e		 ja	 SHORT $LN36@LCS_DoEnqu
  00061	48 81 bc 24 98
	00 00 00 28 23
	00 00		 cmp	 QWORD PTR iSize$[rsp], 9000 ; 00002328H
  0006d	76 71		 jbe	 SHORT $LN35@LCS_DoEnqu
$LN36@LCS_DoEnqu:
$LN4@LCS_DoEnqu:

; 2839 :     {
; 2840 :         PTT_DEBUG( "*DoENQEth EMSGSIZE", 000, pDEVBLK->devnum, bPort );

  0006f	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_pttclass
  00076	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00079	48 25 00 00 02
	00		 and	 rax, 131072		; 00020000H
  0007f	48 85 c0	 test	 rax, rax
  00082	74 40		 je	 SHORT $LN37@LCS_DoEnqu
  00084	0f b6 44 24 40	 movzx	 eax, BYTE PTR bPort$[rsp]
  00089	48 8b 4c 24 48	 mov	 rcx, QWORD PTR pDEVBLK$[rsp]
  0008e	0f b7 49 48	 movzx	 ecx, WORD PTR [rcx+72]
  00092	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR [rsp+48], 0
  0009b	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  000a0	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG172306
  000a7	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  000ac	44 8b c9	 mov	 r9d, ecx
  000af	45 33 c0	 xor	 r8d, r8d
  000b2	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG172307
  000b9	b9 00 00 02 00	 mov	 ecx, 131072		; 00020000H
  000be	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ptt_pthread_trace
$LN37@LCS_DoEnqu:
  000c4	33 c0		 xor	 eax, eax
  000c6	85 c0		 test	 eax, eax
  000c8	75 a5		 jne	 SHORT $LN4@LCS_DoEnqu

; 2841 :         errno = EMSGSIZE;   // Message too long

  000ca	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno
  000d0	c7 00 73 00 00
	00		 mov	 DWORD PTR [rax], 115	; 00000073H

; 2842 :         return -1;          // (-1==failure)

  000d6	b8 ff ff ff ff	 mov	 eax, -1
  000db	e9 4e 05 00 00	 jmp	 $LN1@LCS_DoEnqu
$LN35@LCS_DoEnqu:
$LN7@LCS_DoEnqu:

; 2843 :     }
; 2844 : 
; 2845 :     PTT_DEBUG(       "GET  DevDataLock  ", 000, pDEVBLK->devnum, bPort );

  000e0	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_pttclass
  000e7	48 8b 00	 mov	 rax, QWORD PTR [rax]
  000ea	48 25 00 00 02
	00		 and	 rax, 131072		; 00020000H
  000f0	48 85 c0	 test	 rax, rax
  000f3	74 40		 je	 SHORT $LN38@LCS_DoEnqu
  000f5	0f b6 44 24 40	 movzx	 eax, BYTE PTR bPort$[rsp]
  000fa	48 8b 4c 24 48	 mov	 rcx, QWORD PTR pDEVBLK$[rsp]
  000ff	0f b7 49 48	 movzx	 ecx, WORD PTR [rcx+72]
  00103	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR [rsp+48], 0
  0010c	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  00111	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG172309
  00118	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  0011d	44 8b c9	 mov	 r9d, ecx
  00120	45 33 c0	 xor	 r8d, r8d
  00123	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG172310
  0012a	b9 00 00 02 00	 mov	 ecx, 131072		; 00020000H
  0012f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ptt_pthread_trace
$LN38@LCS_DoEnqu:
  00135	33 c0		 xor	 eax, eax
  00137	85 c0		 test	 eax, eax
  00139	75 a5		 jne	 SHORT $LN7@LCS_DoEnqu

; 2846 :     obtain_lock( &pLCSDEV->DevDataLock );

  0013b	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR pLCSDEV$[rsp]
  00143	48 05 9a 00 00
	00		 add	 rax, 154		; 0000009aH
  00149	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG172311
  00150	48 8b c8	 mov	 rcx, rax
  00153	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_obtain_lock
$LN10@LCS_DoEnqu:

; 2847 :     PTT_DEBUG(       "GOT  DevDataLock  ", 000, pDEVBLK->devnum, bPort );

  00159	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_pttclass
  00160	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00163	48 25 00 00 02
	00		 and	 rax, 131072		; 00020000H
  00169	48 85 c0	 test	 rax, rax
  0016c	74 40		 je	 SHORT $LN39@LCS_DoEnqu
  0016e	0f b6 44 24 40	 movzx	 eax, BYTE PTR bPort$[rsp]
  00173	48 8b 4c 24 48	 mov	 rcx, QWORD PTR pDEVBLK$[rsp]
  00178	0f b7 49 48	 movzx	 ecx, WORD PTR [rcx+72]
  0017c	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR [rsp+48], 0
  00185	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  0018a	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG172313
  00191	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00196	44 8b c9	 mov	 r9d, ecx
  00199	45 33 c0	 xor	 r8d, r8d
  0019c	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG172314
  001a3	b9 00 00 02 00	 mov	 ecx, 131072		; 00020000H
  001a8	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ptt_pthread_trace
$LN39@LCS_DoEnqu:
  001ae	33 c0		 xor	 eax, eax
  001b0	85 c0		 test	 eax, eax
  001b2	75 a5		 jne	 SHORT $LN10@LCS_DoEnqu

; 2848 :     {
; 2849 :         // Ensure we dont overflow the buffer
; 2850 :         if (( pLCSDEV->iFrameOffset +                   // Current buffer Offset
; 2851 :               sizeof(LCSETHFRM) +                       // Size of Frame Header
; 2852 :               iSize +                                   // Size of Ethernet packet
; 2853 :               sizeof(pLCSEthFrame->bLCSHdr.hwOffset) )  // Size of Frame terminator
; 2854 :             > pLCSDEV->iMaxFrameBufferSize)             // Size of Frame buffer

  001b4	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR pLCSDEV$[rsp]
  001bc	0f b7 80 a2 00
	00 00		 movzx	 eax, WORD PTR [rax+162]
  001c3	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR iSize$[rsp]
  001cb	48 8d 44 08 06	 lea	 rax, QWORD PTR [rax+rcx+6]
  001d0	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR pLCSDEV$[rsp]
  001d8	0f b7 89 a4 00
	00 00		 movzx	 ecx, WORD PTR [rcx+164]
  001df	48 3b c1	 cmp	 rax, rcx
  001e2	0f 86 ea 00 00
	00		 jbe	 $LN40@LCS_DoEnqu
$LN13@LCS_DoEnqu:

; 2855 :         {
; 2856 :             PTT_DEBUG( "*DoENQEth ENOBUFS ", 000, pDEVBLK->devnum, bPort );

  001e8	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_pttclass
  001ef	48 8b 00	 mov	 rax, QWORD PTR [rax]
  001f2	48 25 00 00 02
	00		 and	 rax, 131072		; 00020000H
  001f8	48 85 c0	 test	 rax, rax
  001fb	74 40		 je	 SHORT $LN41@LCS_DoEnqu
  001fd	0f b6 44 24 40	 movzx	 eax, BYTE PTR bPort$[rsp]
  00202	48 8b 4c 24 48	 mov	 rcx, QWORD PTR pDEVBLK$[rsp]
  00207	0f b7 49 48	 movzx	 ecx, WORD PTR [rcx+72]
  0020b	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR [rsp+48], 0
  00214	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  00219	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG172317
  00220	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00225	44 8b c9	 mov	 r9d, ecx
  00228	45 33 c0	 xor	 r8d, r8d
  0022b	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG172318
  00232	b9 00 00 02 00	 mov	 ecx, 131072		; 00020000H
  00237	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ptt_pthread_trace
$LN41@LCS_DoEnqu:
  0023d	33 c0		 xor	 eax, eax
  0023f	85 c0		 test	 eax, eax
  00241	75 a5		 jne	 SHORT $LN13@LCS_DoEnqu
$LN16@LCS_DoEnqu:

; 2857 :             PTT_DEBUG(        "REL  DevDataLock  ", 000, pDEVBLK->devnum, bPort );

  00243	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_pttclass
  0024a	48 8b 00	 mov	 rax, QWORD PTR [rax]
  0024d	48 25 00 00 02
	00		 and	 rax, 131072		; 00020000H
  00253	48 85 c0	 test	 rax, rax
  00256	74 40		 je	 SHORT $LN42@LCS_DoEnqu
  00258	0f b6 44 24 40	 movzx	 eax, BYTE PTR bPort$[rsp]
  0025d	48 8b 4c 24 48	 mov	 rcx, QWORD PTR pDEVBLK$[rsp]
  00262	0f b7 49 48	 movzx	 ecx, WORD PTR [rcx+72]
  00266	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR [rsp+48], 0
  0026f	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  00274	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG172320
  0027b	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00280	44 8b c9	 mov	 r9d, ecx
  00283	45 33 c0	 xor	 r8d, r8d
  00286	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG172321
  0028d	b9 00 00 02 00	 mov	 ecx, 131072		; 00020000H
  00292	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ptt_pthread_trace
$LN42@LCS_DoEnqu:
  00298	33 c0		 xor	 eax, eax
  0029a	85 c0		 test	 eax, eax
  0029c	75 a5		 jne	 SHORT $LN16@LCS_DoEnqu

; 2858 :             release_lock( &pLCSDEV->DevDataLock );

  0029e	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR pLCSDEV$[rsp]
  002a6	48 05 9a 00 00
	00		 add	 rax, 154		; 0000009aH
  002ac	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG172322
  002b3	48 8b c8	 mov	 rcx, rax
  002b6	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_release_lock

; 2859 :             errno = ENOBUFS;    // No buffer space available

  002bc	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno
  002c2	c7 00 77 00 00
	00		 mov	 DWORD PTR [rax], 119	; 00000077H

; 2860 :             return -1;          // (-1==failure)

  002c8	b8 ff ff ff ff	 mov	 eax, -1
  002cd	e9 5c 03 00 00	 jmp	 $LN1@LCS_DoEnqu
$LN40@LCS_DoEnqu:

; 2861 :         }
; 2862 : 
; 2863 :         // Point to next available LCS Frame slot in our buffer
; 2864 :         pLCSEthFrame = (PLCSETHFRM)( pLCSDEV->bFrameBuffer +

  002d2	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR pLCSDEV$[rsp]
  002da	0f b7 80 a2 00
	00 00		 movzx	 eax, WORD PTR [rax+162]
  002e1	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR pLCSDEV$[rsp]
  002e9	48 8d 84 01 a6
	00 00 00	 lea	 rax, QWORD PTR [rcx+rax+166]
  002f1	48 89 44 24 50	 mov	 QWORD PTR pLCSEthFrame$[rsp], rax

; 2865 :                                      pLCSDEV->iFrameOffset );
; 2866 : 
; 2867 :         // Increment offset to NEXT available slot (after ours)
; 2868 :         pLCSDEV->iFrameOffset += (U16)(sizeof(LCSETHFRM) + iSize);

  002f6	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR iSize$[rsp]
  002fe	48 83 c0 04	 add	 rax, 4
  00302	0f b7 c0	 movzx	 eax, ax
  00305	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR pLCSDEV$[rsp]
  0030d	0f b7 89 a2 00
	00 00		 movzx	 ecx, WORD PTR [rcx+162]
  00314	03 c8		 add	 ecx, eax
  00316	8b c1		 mov	 eax, ecx
  00318	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR pLCSDEV$[rsp]
  00320	66 89 81 a2 00
	00 00		 mov	 WORD PTR [rcx+162], ax

; 2869 : 
; 2870 :         // Plug updated offset to next frame into our frame header
; 2871 :         STORE_HW( pLCSEthFrame->bLCSHdr.hwOffset, pLCSDEV->iFrameOffset );

  00327	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR pLCSDEV$[rsp]
  0032f	0f b7 88 a2 00
	00 00		 movzx	 ecx, WORD PTR [rax+162]
  00336	e8 00 00 00 00	 call	 _byteswap_ushort
  0033b	48 8b 4c 24 50	 mov	 rcx, QWORD PTR pLCSEthFrame$[rsp]
  00340	0f b7 d0	 movzx	 edx, ax
  00343	e8 00 00 00 00	 call	 store_hw_noswap

; 2872 : 
; 2873 :         // Finish building the LCS Ethernet Passthru frame header
; 2874 :         pLCSEthFrame->bLCSHdr.bType = LCS_FRMTYP_ENET;

  00348	48 8b 44 24 50	 mov	 rax, QWORD PTR pLCSEthFrame$[rsp]
  0034d	c6 40 02 01	 mov	 BYTE PTR [rax+2], 1

; 2875 :         pLCSEthFrame->bLCSHdr.bSlot = bPort;

  00351	48 8b 44 24 50	 mov	 rax, QWORD PTR pLCSEthFrame$[rsp]
  00356	0f b6 4c 24 40	 movzx	 ecx, BYTE PTR bPort$[rsp]
  0035b	88 48 03	 mov	 BYTE PTR [rax+3], cl

; 2876 : 
; 2877 :         // Copy Ethernet packet to LCS Ethernet Passthru frame
; 2878 :         memcpy( pLCSEthFrame->bData, pData, iSize );

  0035e	48 8b 44 24 50	 mov	 rax, QWORD PTR pLCSEthFrame$[rsp]
  00363	48 83 c0 04	 add	 rax, 4
  00367	48 8b f8	 mov	 rdi, rax
  0036a	48 8b b4 24 90
	00 00 00	 mov	 rsi, QWORD PTR pData$[rsp]
  00372	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR iSize$[rsp]
  0037a	f3 a4		 rep movsb
$LN19@LCS_DoEnqu:

; 2879 : 
; 2880 :         // Tell "LCS_Read" function that data is available for reading
; 2881 :         PTT_DEBUG( "SET  DataPending  ", 1, pDEVBLK->devnum, bPort );

  0037c	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_pttclass
  00383	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00386	48 25 00 00 02
	00		 and	 rax, 131072		; 00020000H
  0038c	48 85 c0	 test	 rax, rax
  0038f	74 43		 je	 SHORT $LN43@LCS_DoEnqu
  00391	0f b6 44 24 40	 movzx	 eax, BYTE PTR bPort$[rsp]
  00396	48 8b 4c 24 48	 mov	 rcx, QWORD PTR pDEVBLK$[rsp]
  0039b	0f b7 49 48	 movzx	 ecx, WORD PTR [rcx+72]
  0039f	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR [rsp+48], 0
  003a8	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  003ad	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG172324
  003b4	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  003b9	44 8b c9	 mov	 r9d, ecx
  003bc	41 b8 01 00 00
	00		 mov	 r8d, 1
  003c2	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG172325
  003c9	b9 00 00 02 00	 mov	 ecx, 131072		; 00020000H
  003ce	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ptt_pthread_trace
$LN43@LCS_DoEnqu:
  003d4	33 c0		 xor	 eax, eax
  003d6	85 c0		 test	 eax, eax
  003d8	75 a2		 jne	 SHORT $LN19@LCS_DoEnqu

; 2882 :         pLCSDEV->fDataPending = 1;

  003da	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR pLCSDEV$[rsp]
  003e2	8b 40 41	 mov	 eax, DWORD PTR [rax+65]
  003e5	83 c8 10	 or	 eax, 16
  003e8	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR pLCSDEV$[rsp]
  003f0	89 41 41	 mov	 DWORD PTR [rcx+65], eax
$LN22@LCS_DoEnqu:

; 2883 :     }
; 2884 :     PTT_DEBUG(        "REL  DevDataLock  ", 000, pDEVBLK->devnum, bPort );

  003f3	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_pttclass
  003fa	48 8b 00	 mov	 rax, QWORD PTR [rax]
  003fd	48 25 00 00 02
	00		 and	 rax, 131072		; 00020000H
  00403	48 85 c0	 test	 rax, rax
  00406	74 40		 je	 SHORT $LN44@LCS_DoEnqu
  00408	0f b6 44 24 40	 movzx	 eax, BYTE PTR bPort$[rsp]
  0040d	48 8b 4c 24 48	 mov	 rcx, QWORD PTR pDEVBLK$[rsp]
  00412	0f b7 49 48	 movzx	 ecx, WORD PTR [rcx+72]
  00416	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR [rsp+48], 0
  0041f	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  00424	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG172327
  0042b	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00430	44 8b c9	 mov	 r9d, ecx
  00433	45 33 c0	 xor	 r8d, r8d
  00436	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG172328
  0043d	b9 00 00 02 00	 mov	 ecx, 131072		; 00020000H
  00442	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ptt_pthread_trace
$LN44@LCS_DoEnqu:
  00448	33 c0		 xor	 eax, eax
  0044a	85 c0		 test	 eax, eax
  0044c	75 a5		 jne	 SHORT $LN22@LCS_DoEnqu

; 2885 :     release_lock( &pLCSDEV->DevDataLock );

  0044e	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR pLCSDEV$[rsp]
  00456	48 05 9a 00 00
	00		 add	 rax, 154		; 0000009aH
  0045c	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG172329
  00463	48 8b c8	 mov	 rcx, rax
  00466	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_release_lock
$LN25@LCS_DoEnqu:

; 2886 : 
; 2887 :     // (wake up "LCS_Read" function)
; 2888 :     PTT_DEBUG(       "GET  DevEventLock ", 000, pDEVBLK->devnum, bPort );

  0046c	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_pttclass
  00473	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00476	48 25 00 00 02
	00		 and	 rax, 131072		; 00020000H
  0047c	48 85 c0	 test	 rax, rax
  0047f	74 40		 je	 SHORT $LN45@LCS_DoEnqu
  00481	0f b6 44 24 40	 movzx	 eax, BYTE PTR bPort$[rsp]
  00486	48 8b 4c 24 48	 mov	 rcx, QWORD PTR pDEVBLK$[rsp]
  0048b	0f b7 49 48	 movzx	 ecx, WORD PTR [rcx+72]
  0048f	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR [rsp+48], 0
  00498	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  0049d	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG172331
  004a4	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  004a9	44 8b c9	 mov	 r9d, ecx
  004ac	45 33 c0	 xor	 r8d, r8d
  004af	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG172332
  004b6	b9 00 00 02 00	 mov	 ecx, 131072		; 00020000H
  004bb	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ptt_pthread_trace
$LN45@LCS_DoEnqu:
  004c1	33 c0		 xor	 eax, eax
  004c3	85 c0		 test	 eax, eax
  004c5	75 a5		 jne	 SHORT $LN25@LCS_DoEnqu

; 2889 :     obtain_lock( &pLCSDEV->DevEventLock );

  004c7	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR pLCSDEV$[rsp]
  004cf	48 83 c0 31	 add	 rax, 49			; 00000031H
  004d3	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG172333
  004da	48 8b c8	 mov	 rcx, rax
  004dd	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_obtain_lock
$LN28@LCS_DoEnqu:

; 2890 :     PTT_DEBUG(       "GOT  DevEventLock ", 000, pDEVBLK->devnum, bPort );

  004e3	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_pttclass
  004ea	48 8b 00	 mov	 rax, QWORD PTR [rax]
  004ed	48 25 00 00 02
	00		 and	 rax, 131072		; 00020000H
  004f3	48 85 c0	 test	 rax, rax
  004f6	74 40		 je	 SHORT $LN46@LCS_DoEnqu
  004f8	0f b6 44 24 40	 movzx	 eax, BYTE PTR bPort$[rsp]
  004fd	48 8b 4c 24 48	 mov	 rcx, QWORD PTR pDEVBLK$[rsp]
  00502	0f b7 49 48	 movzx	 ecx, WORD PTR [rcx+72]
  00506	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR [rsp+48], 0
  0050f	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  00514	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG172335
  0051b	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00520	44 8b c9	 mov	 r9d, ecx
  00523	45 33 c0	 xor	 r8d, r8d
  00526	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG172336
  0052d	b9 00 00 02 00	 mov	 ecx, 131072		; 00020000H
  00532	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ptt_pthread_trace
$LN46@LCS_DoEnqu:
  00538	33 c0		 xor	 eax, eax
  0053a	85 c0		 test	 eax, eax
  0053c	75 a5		 jne	 SHORT $LN28@LCS_DoEnqu
$LN31@LCS_DoEnqu:

; 2891 :     {
; 2892 :         PTT_DEBUG(            "SIG  DevEvent     ", 000, pDEVBLK->devnum, bPort );

  0053e	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_pttclass
  00545	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00548	48 25 00 00 02
	00		 and	 rax, 131072		; 00020000H
  0054e	48 85 c0	 test	 rax, rax
  00551	74 40		 je	 SHORT $LN47@LCS_DoEnqu
  00553	0f b6 44 24 40	 movzx	 eax, BYTE PTR bPort$[rsp]
  00558	48 8b 4c 24 48	 mov	 rcx, QWORD PTR pDEVBLK$[rsp]
  0055d	0f b7 49 48	 movzx	 ecx, WORD PTR [rcx+72]
  00561	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR [rsp+48], 0
  0056a	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  0056f	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG172338
  00576	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  0057b	44 8b c9	 mov	 r9d, ecx
  0057e	45 33 c0	 xor	 r8d, r8d
  00581	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG172339
  00588	b9 00 00 02 00	 mov	 ecx, 131072		; 00020000H
  0058d	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ptt_pthread_trace
$LN47@LCS_DoEnqu:
  00593	33 c0		 xor	 eax, eax
  00595	85 c0		 test	 eax, eax
  00597	75 a5		 jne	 SHORT $LN31@LCS_DoEnqu

; 2893 :         signal_condition( &pLCSDEV->DevEvent );

  00599	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR pLCSDEV$[rsp]
  005a1	48 83 c0 39	 add	 rax, 57			; 00000039H
  005a5	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG172340
  005ac	48 8b c8	 mov	 rcx, rax
  005af	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_signal_condition
$LN34@LCS_DoEnqu:

; 2894 :     }
; 2895 :     PTT_DEBUG(        "REL  DevEventLock ", 000, pDEVBLK->devnum, bPort );

  005b5	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_pttclass
  005bc	48 8b 00	 mov	 rax, QWORD PTR [rax]
  005bf	48 25 00 00 02
	00		 and	 rax, 131072		; 00020000H
  005c5	48 85 c0	 test	 rax, rax
  005c8	74 40		 je	 SHORT $LN48@LCS_DoEnqu
  005ca	0f b6 44 24 40	 movzx	 eax, BYTE PTR bPort$[rsp]
  005cf	48 8b 4c 24 48	 mov	 rcx, QWORD PTR pDEVBLK$[rsp]
  005d4	0f b7 49 48	 movzx	 ecx, WORD PTR [rcx+72]
  005d8	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR [rsp+48], 0
  005e1	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  005e6	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG172342
  005ed	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  005f2	44 8b c9	 mov	 r9d, ecx
  005f5	45 33 c0	 xor	 r8d, r8d
  005f8	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG172343
  005ff	b9 00 00 02 00	 mov	 ecx, 131072		; 00020000H
  00604	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ptt_pthread_trace
$LN48@LCS_DoEnqu:
  0060a	33 c0		 xor	 eax, eax
  0060c	85 c0		 test	 eax, eax
  0060e	75 a5		 jne	 SHORT $LN34@LCS_DoEnqu

; 2896 :     release_lock( &pLCSDEV->DevEventLock );

  00610	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR pLCSDEV$[rsp]
  00618	48 83 c0 31	 add	 rax, 49			; 00000031H
  0061c	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG172344
  00623	48 8b c8	 mov	 rcx, rax
  00626	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_release_lock

; 2897 : 
; 2898 :     return 0;       // (success)

  0062c	33 c0		 xor	 eax, eax
$LN1@LCS_DoEnqu:

; 2899 : }

  0062e	48 83 c4 68	 add	 rsp, 104		; 00000068H
  00632	5f		 pop	 rdi
  00633	5e		 pop	 rsi
  00634	c3		 ret	 0
LCS_DoEnqueueEthFrame ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\ctc_lcs.c
_TEXT	SEGMENT
bPort$ = 80
c$1 = 84
tv139 = 88
tv184 = 92
tv186 = 96
t2$ = 104
t1$ = 112
pDEVBLK$ = 120
str$2 = 128
__$ArrayPad$ = 168
pLCSPORT$ = 192
pLCSDEV$ = 200
pData$ = 208
iSize$ = 216
LCS_EnqueueEthFrame PROC

; 2745 : {

  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	48 81 ec b8 00
	00 00		 sub	 rsp, 184		; 000000b8H
  0001b	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00022	48 33 c4	 xor	 rax, rsp
  00025	48 89 84 24 a8
	00 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 2746 :     DEVBLK*   pDEVBLK;
; 2747 :     BYTE      bPort;
; 2748 :     time_t    t1, t2;
; 2749 : 
; 2750 : 
; 2751 :     pDEVBLK = pLCSDEV->pDEVBLK[ LCS_READ_SUBCHANN ];

  0002d	b8 08 00 00 00	 mov	 eax, 8
  00032	48 6b c0 00	 imul	 rax, rax, 0
  00036	48 8b 8c 24 c8
	00 00 00	 mov	 rcx, QWORD PTR pLCSDEV$[rsp]
  0003e	48 8b 44 01 10	 mov	 rax, QWORD PTR [rcx+rax+16]
  00043	48 89 44 24 78	 mov	 QWORD PTR pDEVBLK$[rsp], rax

; 2752 :     bPort   = pLCSPORT->bPort;

  00048	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR pLCSPORT$[rsp]
  00050	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  00053	88 44 24 50	 mov	 BYTE PTR bPort$[rsp], al
$LN4@LCS_Enqueu:

; 2753 : 
; 2754 :     PTT_DEBUG( "ENQ EthFrame ENTRY", 000, pDEVBLK->devnum, bPort );

  00057	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_pttclass
  0005e	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00061	48 25 00 00 02
	00		 and	 rax, 131072		; 00020000H
  00067	48 85 c0	 test	 rax, rax
  0006a	74 40		 je	 SHORT $LN28@LCS_Enqueu
  0006c	0f b6 44 24 50	 movzx	 eax, BYTE PTR bPort$[rsp]
  00071	48 8b 4c 24 78	 mov	 rcx, QWORD PTR pDEVBLK$[rsp]
  00076	0f b7 49 48	 movzx	 ecx, WORD PTR [rcx+72]
  0007a	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR [rsp+48], 0
  00083	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  00088	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG172148
  0008f	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00094	44 8b c9	 mov	 r9d, ecx
  00097	45 33 c0	 xor	 r8d, r8d
  0009a	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG172149
  000a1	b9 00 00 02 00	 mov	 ecx, 131072		; 00020000H
  000a6	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ptt_pthread_trace
$LN28@LCS_Enqueu:
  000ac	33 c0		 xor	 eax, eax
  000ae	85 c0		 test	 eax, eax
  000b0	75 a5		 jne	 SHORT $LN4@LCS_Enqueu

; 2755 : 
; 2756 :     time( &t1 );

  000b2	48 8d 4c 24 70	 lea	 rcx, QWORD PTR t1$[rsp]
  000b7	e8 00 00 00 00	 call	 time
$LN7@LCS_Enqueu:

; 2757 : 
; 2758 :     PTT_TIMING( "b4 enqueue", 0, iSize, 0 );

  000bc	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_pttclass
  000c3	48 8b 00	 mov	 rax, QWORD PTR [rax]
  000c6	48 25 00 00 01
	00		 and	 rax, 65536		; 00010000H
  000cc	48 85 c0	 test	 rax, rax
  000cf	74 3b		 je	 SHORT $LN29@LCS_Enqueu
  000d1	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR [rsp+48], 0
  000da	48 c7 44 24 28
	00 00 00 00	 mov	 QWORD PTR [rsp+40], 0
  000e3	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG172151
  000ea	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  000ef	4c 8b 8c 24 d8
	00 00 00	 mov	 r9, QWORD PTR iSize$[rsp]
  000f7	45 33 c0	 xor	 r8d, r8d
  000fa	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG172152
  00101	b9 00 00 01 00	 mov	 ecx, 65536		; 00010000H
  00106	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ptt_pthread_trace
$LN29@LCS_Enqueu:
  0010c	33 c0		 xor	 eax, eax
  0010e	85 c0		 test	 eax, eax
  00110	75 aa		 jne	 SHORT $LN7@LCS_Enqueu
$LN8@LCS_Enqueu:

; 2759 : 
; 2760 :     // While port open, not close in progress, and frame buffer full...
; 2761 : 
; 2762 :     while (1
; 2763 :         &&  pLCSPORT->fd != -1
; 2764 :         && !pLCSPORT->fCloseInProgress
; 2765 :         && LCS_DoEnqueueEthFrame( pLCSPORT, pLCSDEV, pData, iSize ) < 0

  00112	33 c0		 xor	 eax, eax
  00114	83 f8 01	 cmp	 eax, 1
  00117	0f 84 12 03 00
	00		 je	 $LN9@LCS_Enqueu
  0011d	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR pLCSPORT$[rsp]
  00125	83 b8 38 01 00
	00 ff		 cmp	 DWORD PTR [rax+312], -1
  0012c	0f 84 fd 02 00
	00		 je	 $LN9@LCS_Enqueu
  00132	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR pLCSPORT$[rsp]
  0013a	8b 80 34 01 00
	00		 mov	 eax, DWORD PTR [rax+308]
  00140	c1 e8 05	 shr	 eax, 5
  00143	83 e0 01	 and	 eax, 1
  00146	85 c0		 test	 eax, eax
  00148	0f 85 e1 02 00
	00		 jne	 $LN9@LCS_Enqueu
  0014e	4c 8b 8c 24 d8
	00 00 00	 mov	 r9, QWORD PTR iSize$[rsp]
  00156	4c 8b 84 24 d0
	00 00 00	 mov	 r8, QWORD PTR pData$[rsp]
  0015e	48 8b 94 24 c8
	00 00 00	 mov	 rdx, QWORD PTR pLCSDEV$[rsp]
  00166	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR pLCSPORT$[rsp]
  0016e	e8 00 00 00 00	 call	 LCS_DoEnqueueEthFrame
  00173	85 c0		 test	 eax, eax
  00175	0f 8d b4 02 00
	00		 jge	 $LN9@LCS_Enqueu

; 2766 :     )
; 2767 :     {
; 2768 :         if (EMSGSIZE == errno)

  0017b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno
  00181	83 38 73	 cmp	 DWORD PTR [rax], 115	; 00000073H
  00184	0f 85 b3 00 00
	00		 jne	 $LN30@LCS_Enqueu

; 2769 :         {
; 2770 :             // "CTC: lcs device port %2.2X: packet frame too big, dropped"
; 2771 :             WRMSG( HHC00953, "W", bPort );

  0018a	0f b6 44 24 50	 movzx	 eax, BYTE PTR bPort$[rsp]
  0018f	89 44 24 58	 mov	 DWORD PTR tv139[rsp], eax
  00193	b9 01 00 00 00	 mov	 ecx, 1
  00198	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  0019e	8b 4c 24 58	 mov	 ecx, DWORD PTR tv139[rsp]
  001a2	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  001a6	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG172154
  001ad	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  001b2	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG172155
  001b9	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  001be	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  001c3	41 b9 03 00 00
	00		 mov	 r9d, 3
  001c9	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG172156
  001d0	ba d3 0a 00 00	 mov	 edx, 2771		; 00000ad3H
  001d5	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG172157
  001dc	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg
$LN12@LCS_Enqueu:

; 2772 :             PTT_TIMING( "*enq drop", 0, iSize, 0 );

  001e2	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_pttclass
  001e9	48 8b 00	 mov	 rax, QWORD PTR [rax]
  001ec	48 25 00 00 01
	00		 and	 rax, 65536		; 00010000H
  001f2	48 85 c0	 test	 rax, rax
  001f5	74 3b		 je	 SHORT $LN31@LCS_Enqueu
  001f7	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR [rsp+48], 0
  00200	48 c7 44 24 28
	00 00 00 00	 mov	 QWORD PTR [rsp+40], 0
  00209	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG172159
  00210	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00215	4c 8b 8c 24 d8
	00 00 00	 mov	 r9, QWORD PTR iSize$[rsp]
  0021d	45 33 c0	 xor	 r8d, r8d
  00220	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG172160
  00227	b9 00 00 01 00	 mov	 ecx, 65536		; 00010000H
  0022c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ptt_pthread_trace
$LN31@LCS_Enqueu:
  00232	33 c0		 xor	 eax, eax
  00234	85 c0		 test	 eax, eax
  00236	75 aa		 jne	 SHORT $LN12@LCS_Enqueu

; 2773 :             break;

  00238	e9 f2 01 00 00	 jmp	 $LN9@LCS_Enqueu
$LN30@LCS_Enqueu:

; 2774 :         }
; 2775 : 
; 2776 :         if (pLCSDEV->pLCSBLK->fDebug)

  0023d	48 8b 84 24 c8
	00 00 00	 mov	 rax, QWORD PTR pLCSDEV$[rsp]
  00245	48 8b 40 08	 mov	 rax, QWORD PTR [rax+8]
  00249	8b 40 18	 mov	 eax, DWORD PTR [rax+24]
  0024c	83 e0 01	 and	 eax, 1
  0024f	85 c0		 test	 eax, eax
  00251	0f 84 05 01 00
	00		 je	 $LN32@LCS_Enqueu

; 2777 :         {
; 2778 :             // Limit message rate to only once every few seconds...
; 2779 : 
; 2780 :             time( &t2 );

  00257	48 8d 4c 24 68	 lea	 rcx, QWORD PTR t2$[rsp]
  0025c	e8 00 00 00 00	 call	 time

; 2781 : 
; 2782 :             if ((t2 - t1) >= 3)     // (only once every 3 seconds)

  00261	48 8b 44 24 70	 mov	 rax, QWORD PTR t1$[rsp]
  00266	48 8b 4c 24 68	 mov	 rcx, QWORD PTR t2$[rsp]
  0026b	48 2b c8	 sub	 rcx, rax
  0026e	48 8b c1	 mov	 rax, rcx
  00271	48 83 f8 03	 cmp	 rax, 3
  00275	0f 8c e1 00 00
	00		 jl	 $LN33@LCS_Enqueu

; 2783 :             {
; 2784 :                 union converter { struct { unsigned char a, b, c, d; } b; U32 i; } c;
; 2785 :                 char  str[40];
; 2786 : 
; 2787 :                 t1 = t2;

  0027b	48 8b 44 24 68	 mov	 rax, QWORD PTR t2$[rsp]
  00280	48 89 44 24 70	 mov	 QWORD PTR t1$[rsp], rax

; 2788 : 
; 2789 :                 c.i = ntohl( pLCSDEV->lIPAddress );

  00285	48 8b 84 24 c8
	00 00 00	 mov	 rax, QWORD PTR pLCSDEV$[rsp]
  0028d	8b 48 2d	 mov	 ecx, DWORD PTR [rax+45]
  00290	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ntohl
  00296	89 44 24 54	 mov	 DWORD PTR c$1[rsp], eax

; 2790 :                 MSGBUF( str, "%8.08X %d.%d.%d.%d", c.i, c.b.d, c.b.c, c.b.b, c.b.a );

  0029a	0f b6 44 24 54	 movzx	 eax, BYTE PTR c$1[rsp]
  0029f	0f b6 4c 24 55	 movzx	 ecx, BYTE PTR c$1[rsp+1]
  002a4	0f b6 54 24 56	 movzx	 edx, BYTE PTR c$1[rsp+2]
  002a9	44 0f b6 44 24
	57		 movzx	 r8d, BYTE PTR c$1[rsp+3]
  002af	89 44 24 38	 mov	 DWORD PTR [rsp+56], eax
  002b3	89 4c 24 30	 mov	 DWORD PTR [rsp+48], ecx
  002b7	89 54 24 28	 mov	 DWORD PTR [rsp+40], edx
  002bb	44 89 44 24 20	 mov	 DWORD PTR [rsp+32], r8d
  002c0	44 8b 4c 24 54	 mov	 r9d, DWORD PTR c$1[rsp]
  002c5	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG172163
  002cc	ba 28 00 00 00	 mov	 edx, 40			; 00000028H
  002d1	48 8d 8c 24 80
	00 00 00	 lea	 rcx, QWORD PTR str$2[rsp]
  002d9	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_snprintf

; 2791 : 
; 2792 :                 // "CTC: lcs device port %2.2X: STILL trying to enqueue frame to device %4.4X %s"
; 2793 :                 WRMSG( HHC00965, "D", bPort, pLCSDEV->sAddr, str );

  002df	48 8b 84 24 c8
	00 00 00	 mov	 rax, QWORD PTR pLCSDEV$[rsp]
  002e7	0f b7 40 20	 movzx	 eax, WORD PTR [rax+32]
  002eb	89 44 24 5c	 mov	 DWORD PTR tv184[rsp], eax
  002ef	0f b6 4c 24 50	 movzx	 ecx, BYTE PTR bPort$[rsp]
  002f4	89 4c 24 60	 mov	 DWORD PTR tv186[rsp], ecx
  002f8	b9 01 00 00 00	 mov	 ecx, 1
  002fd	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  00303	48 8d 8c 24 80
	00 00 00	 lea	 rcx, QWORD PTR str$2[rsp]
  0030b	48 89 4c 24 48	 mov	 QWORD PTR [rsp+72], rcx
  00310	8b 4c 24 5c	 mov	 ecx, DWORD PTR tv184[rsp]
  00314	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  00318	8b 4c 24 60	 mov	 ecx, DWORD PTR tv186[rsp]
  0031c	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  00320	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG172164
  00327	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  0032c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG172165
  00333	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00338	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  0033d	41 b9 03 00 00
	00		 mov	 r9d, 3
  00343	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG172166
  0034a	ba e9 0a 00 00	 mov	 edx, 2793		; 00000ae9H
  0034f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG172167
  00356	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg
$LN33@LCS_Enqueu:
$LN32@LCS_Enqueu:
$LN15@LCS_Enqueu:

; 2794 :             }
; 2795 :         }
; 2796 :         PTT_TIMING( "*enq wait", 0, iSize, 0 );

  0035c	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_pttclass
  00363	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00366	48 25 00 00 01
	00		 and	 rax, 65536		; 00010000H
  0036c	48 85 c0	 test	 rax, rax
  0036f	74 3b		 je	 SHORT $LN34@LCS_Enqueu
  00371	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR [rsp+48], 0
  0037a	48 c7 44 24 28
	00 00 00 00	 mov	 QWORD PTR [rsp+40], 0
  00383	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG172169
  0038a	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  0038f	4c 8b 8c 24 d8
	00 00 00	 mov	 r9, QWORD PTR iSize$[rsp]
  00397	45 33 c0	 xor	 r8d, r8d
  0039a	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG172170
  003a1	b9 00 00 01 00	 mov	 ecx, 65536		; 00010000H
  003a6	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ptt_pthread_trace
$LN34@LCS_Enqueu:
  003ac	33 c0		 xor	 eax, eax
  003ae	85 c0		 test	 eax, eax
  003b0	75 aa		 jne	 SHORT $LN15@LCS_Enqueu
$LN18@LCS_Enqueu:

; 2797 : 
; 2798 :         // Wait for LCS_Read to empty the buffer...
; 2799 : 
; 2800 :         ASSERT( ENOBUFS == errno );

  003b2	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno
  003b8	83 38 77	 cmp	 DWORD PTR [rax], 119	; 00000077H
  003bb	74 5c		 je	 SHORT $LN35@LCS_Enqueu
$LN21@LCS_Enqueu:
  003bd	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG172172
  003c4	41 b8 f0 0a 00
	00		 mov	 r8d, 2800		; 00000af0H
  003ca	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG172173
  003d1	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG172174
  003d8	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_logmsg
  003de	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_IsDebuggerPresent
  003e4	85 c0		 test	 eax, eax
  003e6	74 20		 je	 SHORT $LN36@LCS_Enqueu
  003e8	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG172176
  003ef	41 b8 f0 0a 00
	00		 mov	 r8d, 2800		; 00000af0H
  003f5	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG172177
  003fc	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG172178
  00403	e8 00 00 00 00	 call	 DebuggerTrace
$LN36@LCS_Enqueu:
  00408	33 c0		 xor	 eax, eax
  0040a	85 c0		 test	 eax, eax
  0040c	75 af		 jne	 SHORT $LN21@LCS_Enqueu
  0040e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_IsDebuggerPresent
  00414	85 c0		 test	 eax, eax
  00416	74 01		 je	 SHORT $LN37@LCS_Enqueu
  00418	cc		 int	 3
$LN37@LCS_Enqueu:
$LN35@LCS_Enqueu:
  00419	33 c0		 xor	 eax, eax
  0041b	85 c0		 test	 eax, eax
  0041d	75 93		 jne	 SHORT $LN18@LCS_Enqueu

; 2801 :         usleep( CTC_DELAY_USECS );

  0041f	b9 64 00 00 00	 mov	 ecx, 100		; 00000064H
  00424	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_usleep

; 2802 :     }

  0042a	e9 e3 fc ff ff	 jmp	 $LN8@LCS_Enqueu
$LN9@LCS_Enqueu:
$LN24@LCS_Enqueu:

; 2803 :     PTT_TIMING( "af enqueue", 0, iSize, 0 );

  0042f	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_pttclass
  00436	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00439	48 25 00 00 01
	00		 and	 rax, 65536		; 00010000H
  0043f	48 85 c0	 test	 rax, rax
  00442	74 3b		 je	 SHORT $LN38@LCS_Enqueu
  00444	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR [rsp+48], 0
  0044d	48 c7 44 24 28
	00 00 00 00	 mov	 QWORD PTR [rsp+40], 0
  00456	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG172181
  0045d	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00462	4c 8b 8c 24 d8
	00 00 00	 mov	 r9, QWORD PTR iSize$[rsp]
  0046a	45 33 c0	 xor	 r8d, r8d
  0046d	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG172182
  00474	b9 00 00 01 00	 mov	 ecx, 65536		; 00010000H
  00479	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ptt_pthread_trace
$LN38@LCS_Enqueu:
  0047f	33 c0		 xor	 eax, eax
  00481	85 c0		 test	 eax, eax
  00483	75 aa		 jne	 SHORT $LN24@LCS_Enqueu
$LN27@LCS_Enqueu:

; 2804 :     PTT_DEBUG( "ENQ EthFrame EXIT ", 000, pDEVBLK->devnum, bPort );

  00485	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_pttclass
  0048c	48 8b 00	 mov	 rax, QWORD PTR [rax]
  0048f	48 25 00 00 02
	00		 and	 rax, 131072		; 00020000H
  00495	48 85 c0	 test	 rax, rax
  00498	74 40		 je	 SHORT $LN39@LCS_Enqueu
  0049a	0f b6 44 24 50	 movzx	 eax, BYTE PTR bPort$[rsp]
  0049f	48 8b 4c 24 78	 mov	 rcx, QWORD PTR pDEVBLK$[rsp]
  004a4	0f b7 49 48	 movzx	 ecx, WORD PTR [rcx+72]
  004a8	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR [rsp+48], 0
  004b1	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  004b6	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG172184
  004bd	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  004c2	44 8b c9	 mov	 r9d, ecx
  004c5	45 33 c0	 xor	 r8d, r8d
  004c8	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG172185
  004cf	b9 00 00 02 00	 mov	 ecx, 131072		; 00020000H
  004d4	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ptt_pthread_trace
$LN39@LCS_Enqueu:
  004da	33 c0		 xor	 eax, eax
  004dc	85 c0		 test	 eax, eax
  004de	75 a5		 jne	 SHORT $LN27@LCS_Enqueu

; 2805 : }

  004e0	48 8b 8c 24 a8
	00 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  004e8	48 33 cc	 xor	 rcx, rsp
  004eb	e8 00 00 00 00	 call	 __security_check_cookie
  004f0	48 81 c4 b8 00
	00 00		 add	 rsp, 184		; 000000b8H
  004f7	c3		 ret	 0
LCS_EnqueueEthFrame ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\ctc_lcs.c
_TEXT	SEGMENT
pLCSBLK$ = 96
pLCSATTN$ = 104
dev_attn_rc$ = 112
busy_waits$ = 116
interval$ = 120
pDEVBLK$ = 128
pLCSATTNcurr$ = 136
tv357 = 144
tv361 = 148
pLCSATTNprev$ = 152
pLCSDEV$ = 160
pLCSATTNnext$ = 168
tmp$1 = 176
__$ArrayPad$ = 432
arg$ = 464
LCS_AttnThread PROC

; 4028 : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 81 ec c8 01
	00 00		 sub	 rsp, 456		; 000001c8H
  0000c	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00013	48 33 c4	 xor	 rax, rsp
  00016	48 89 84 24 b0
	01 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax
$LN4@LCS_AttnTh:

; 4029 : 
; 4030 :     PLCSBLK     pLCSBLK;
; 4031 :     PLCSATTN    pLCSATTN;
; 4032 :     PLCSATTN    pLCSATTNprev, pLCSATTNcurr, pLCSATTNnext;
; 4033 :     PLCSDEV     pLCSDEV;
; 4034 :     DEVBLK*     pDEVBLK;
; 4035 :     /* --------------------------------------------------------------------- */
; 4036 :     int         interval;              /* interval between attempts  FixMe! Configurable? */
; 4037 :     int         dev_attn_rc;           /* device_attention RC    */
; 4038 :     int         busy_waits;            /* Number of times waited for */
; 4039 :                                        /* a Busy condition to end    */
; 4040 :     /* --------------------------------------------------------------------- */
; 4041 : 
; 4042 : 
; 4043 :     PTT_DEBUG( "ATTNTHRD: ENTRY", 000, 000, 000 );

  0001e	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_pttclass
  00025	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00028	48 25 00 00 02
	00		 and	 rax, 131072		; 00020000H
  0002e	48 85 c0	 test	 rax, rax
  00031	74 36		 je	 SHORT $LN66@LCS_AttnTh
  00033	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR [rsp+48], 0
  0003c	48 c7 44 24 28
	00 00 00 00	 mov	 QWORD PTR [rsp+40], 0
  00045	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG173251
  0004c	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00051	45 33 c9	 xor	 r9d, r9d
  00054	45 33 c0	 xor	 r8d, r8d
  00057	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG173252
  0005e	b9 00 00 02 00	 mov	 ecx, 131072		; 00020000H
  00063	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ptt_pthread_trace
$LN66@LCS_AttnTh:
  00069	33 c0		 xor	 eax, eax
  0006b	85 c0		 test	 eax, eax
  0006d	75 af		 jne	 SHORT $LN4@LCS_AttnTh

; 4044 : 
; 4045 :     /* Point to the LCSBLK and obtain the pid of this thread. */
; 4046 :     pLCSBLK = (PLCSBLK) arg;

  0006f	48 8b 84 24 d0
	01 00 00	 mov	 rax, QWORD PTR arg$[rsp]
  00077	48 89 44 24 60	 mov	 QWORD PTR pLCSBLK$[rsp], rax

; 4047 :     pLCSBLK->AttnPid = getpid();

  0007c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_getpid
  00082	48 8b 4c 24 60	 mov	 rcx, QWORD PTR pLCSBLK$[rsp]
  00087	89 41 54	 mov	 DWORD PTR [rcx+84], eax
$LN5@LCS_AttnTh:
$LN10@LCS_AttnTh:

; 4048 : 
; 4049 :     for ( ; ; )
; 4050 :     {
; 4051 : 
; 4052 :         /* */
; 4053 :         PTT_DEBUG( "GET  AttnEventLock", 000, 000, 000 );

  0008a	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_pttclass
  00091	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00094	48 25 00 00 02
	00		 and	 rax, 131072		; 00020000H
  0009a	48 85 c0	 test	 rax, rax
  0009d	74 36		 je	 SHORT $LN67@LCS_AttnTh
  0009f	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR [rsp+48], 0
  000a8	48 c7 44 24 28
	00 00 00 00	 mov	 QWORD PTR [rsp+40], 0
  000b1	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG173254
  000b8	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  000bd	45 33 c9	 xor	 r9d, r9d
  000c0	45 33 c0	 xor	 r8d, r8d
  000c3	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG173255
  000ca	b9 00 00 02 00	 mov	 ecx, 131072		; 00020000H
  000cf	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ptt_pthread_trace
$LN67@LCS_AttnTh:
  000d5	33 c0		 xor	 eax, eax
  000d7	85 c0		 test	 eax, eax
  000d9	75 af		 jne	 SHORT $LN10@LCS_AttnTh

; 4054 :         obtain_lock( &pLCSBLK->AttnEventLock );

  000db	48 8b 44 24 60	 mov	 rax, QWORD PTR pLCSBLK$[rsp]
  000e0	48 83 c0 40	 add	 rax, 64			; 00000040H
  000e4	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG173256
  000eb	48 8b c8	 mov	 rcx, rax
  000ee	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_obtain_lock
$LN13@LCS_AttnTh:

; 4055 :         PTT_DEBUG( "GOT  AttnEventLock", 000, 000, 000 );

  000f4	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_pttclass
  000fb	48 8b 00	 mov	 rax, QWORD PTR [rax]
  000fe	48 25 00 00 02
	00		 and	 rax, 131072		; 00020000H
  00104	48 85 c0	 test	 rax, rax
  00107	74 36		 je	 SHORT $LN68@LCS_AttnTh
  00109	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR [rsp+48], 0
  00112	48 c7 44 24 28
	00 00 00 00	 mov	 QWORD PTR [rsp+40], 0
  0011b	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG173258
  00122	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00127	45 33 c9	 xor	 r9d, r9d
  0012a	45 33 c0	 xor	 r8d, r8d
  0012d	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG173259
  00134	b9 00 00 02 00	 mov	 ecx, 131072		; 00020000H
  00139	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ptt_pthread_trace
$LN68@LCS_AttnTh:
  0013f	33 c0		 xor	 eax, eax
  00141	85 c0		 test	 eax, eax
  00143	75 af		 jne	 SHORT $LN13@LCS_AttnTh
$LN14@LCS_AttnTh:

; 4056 :         {
; 4057 :             for( ; ; )
; 4058 :             {
; 4059 :                 if ( pLCSBLK->fCloseInProgress )

  00145	48 8b 44 24 60	 mov	 rax, QWORD PTR pLCSBLK$[rsp]
  0014a	8b 40 18	 mov	 eax, DWORD PTR [rax+24]
  0014d	d1 e8		 shr	 eax, 1
  0014f	83 e0 01	 and	 eax, 1
  00152	85 c0		 test	 eax, eax
  00154	74 56		 je	 SHORT $LN69@LCS_AttnTh
$LN19@LCS_AttnTh:

; 4060 :                 {
; 4061 :                     PTT_DEBUG( "ATTNTHRD Closing...", 000, 000, 000 );

  00156	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_pttclass
  0015d	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00160	48 25 00 00 02
	00		 and	 rax, 131072		; 00020000H
  00166	48 85 c0	 test	 rax, rax
  00169	74 36		 je	 SHORT $LN70@LCS_AttnTh
  0016b	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR [rsp+48], 0
  00174	48 c7 44 24 28
	00 00 00 00	 mov	 QWORD PTR [rsp+40], 0
  0017d	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG173262
  00184	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00189	45 33 c9	 xor	 r9d, r9d
  0018c	45 33 c0	 xor	 r8d, r8d
  0018f	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG173263
  00196	b9 00 00 02 00	 mov	 ecx, 131072		; 00020000H
  0019b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ptt_pthread_trace
$LN70@LCS_AttnTh:
  001a1	33 c0		 xor	 eax, eax
  001a3	85 c0		 test	 eax, eax
  001a5	75 af		 jne	 SHORT $LN19@LCS_AttnTh

; 4062 :                     break;

  001a7	e9 39 01 00 00	 jmp	 $LN15@LCS_AttnTh
$LN69@LCS_AttnTh:

; 4063 :                 }
; 4064 : 
; 4065 :                 if ( pLCSBLK->pAttns )

  001ac	48 8b 44 24 60	 mov	 rax, QWORD PTR pLCSBLK$[rsp]
  001b1	48 83 78 38 00	 cmp	 QWORD PTR [rax+56], 0
  001b6	74 56		 je	 SHORT $LN71@LCS_AttnTh
$LN22@LCS_AttnTh:

; 4066 :                 {
; 4067 :                     PTT_DEBUG( "ATTNTHRD Attn...", 000, 000, 000 );

  001b8	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_pttclass
  001bf	48 8b 00	 mov	 rax, QWORD PTR [rax]
  001c2	48 25 00 00 02
	00		 and	 rax, 131072		; 00020000H
  001c8	48 85 c0	 test	 rax, rax
  001cb	74 36		 je	 SHORT $LN72@LCS_AttnTh
  001cd	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR [rsp+48], 0
  001d6	48 c7 44 24 28
	00 00 00 00	 mov	 QWORD PTR [rsp+40], 0
  001df	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG173266
  001e6	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  001eb	45 33 c9	 xor	 r9d, r9d
  001ee	45 33 c0	 xor	 r8d, r8d
  001f1	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG173267
  001f8	b9 00 00 02 00	 mov	 ecx, 131072		; 00020000H
  001fd	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ptt_pthread_trace
$LN72@LCS_AttnTh:
  00203	33 c0		 xor	 eax, eax
  00205	85 c0		 test	 eax, eax
  00207	75 af		 jne	 SHORT $LN22@LCS_AttnTh

; 4068 :                     break;

  00209	e9 d7 00 00 00	 jmp	 $LN15@LCS_AttnTh
$LN71@LCS_AttnTh:
$LN25@LCS_AttnTh:

; 4069 :                 }
; 4070 : 
; 4071 :                 PTT_DEBUG( "WAIT AttnEventLock", 000, 000, 000 );

  0020e	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_pttclass
  00215	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00218	48 25 00 00 02
	00		 and	 rax, 131072		; 00020000H
  0021e	48 85 c0	 test	 rax, rax
  00221	74 36		 je	 SHORT $LN73@LCS_AttnTh
  00223	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR [rsp+48], 0
  0022c	48 c7 44 24 28
	00 00 00 00	 mov	 QWORD PTR [rsp+40], 0
  00235	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG173269
  0023c	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00241	45 33 c9	 xor	 r9d, r9d
  00244	45 33 c0	 xor	 r8d, r8d
  00247	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG173270
  0024e	b9 00 00 02 00	 mov	 ecx, 131072		; 00020000H
  00253	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ptt_pthread_trace
$LN73@LCS_AttnTh:
  00259	33 c0		 xor	 eax, eax
  0025b	85 c0		 test	 eax, eax
  0025d	75 af		 jne	 SHORT $LN25@LCS_AttnTh

; 4072 :                 timed_wait_condition_relative_usecs

  0025f	48 8b 44 24 60	 mov	 rax, QWORD PTR pLCSBLK$[rsp]
  00264	48 83 c0 40	 add	 rax, 64			; 00000040H
  00268	48 8b 4c 24 60	 mov	 rcx, QWORD PTR pLCSBLK$[rsp]
  0026d	48 83 c1 48	 add	 rcx, 72			; 00000048H
  00271	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG173271
  00278	48 89 54 24 20	 mov	 QWORD PTR [rsp+32], rdx
  0027d	45 33 c9	 xor	 r9d, r9d
  00280	41 b8 c0 c6 2d
	00		 mov	 r8d, 3000000		; 002dc6c0H
  00286	48 8b d0	 mov	 rdx, rax
  00289	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_timed_wait_condition_relative_usecs_impl
$LN28@LCS_AttnTh:

; 4073 :                 (
; 4074 :                     &pLCSBLK->AttnEvent,         // ptr to condition to wait on
; 4075 :                     &pLCSBLK->AttnEventLock,     // ptr to controlling lock (must be held!)
; 4076 :                     3*1000*1000,                 // max #of microseconds to wait, i.e. 3 seconds
; 4077 :                     NULL                         // [OPTIONAL] ptr to tod value (may be NULL)
; 4078 :                 );
; 4079 :                 PTT_DEBUG( "WOKE AttnEventLock", 000, 000, 000 );

  0028f	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_pttclass
  00296	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00299	48 25 00 00 02
	00		 and	 rax, 131072		; 00020000H
  0029f	48 85 c0	 test	 rax, rax
  002a2	74 36		 je	 SHORT $LN74@LCS_AttnTh
  002a4	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR [rsp+48], 0
  002ad	48 c7 44 24 28
	00 00 00 00	 mov	 QWORD PTR [rsp+40], 0
  002b6	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG173273
  002bd	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  002c2	45 33 c9	 xor	 r9d, r9d
  002c5	45 33 c0	 xor	 r8d, r8d
  002c8	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG173274
  002cf	b9 00 00 02 00	 mov	 ecx, 131072		; 00020000H
  002d4	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ptt_pthread_trace
$LN74@LCS_AttnTh:
  002da	33 c0		 xor	 eax, eax
  002dc	85 c0		 test	 eax, eax
  002de	75 af		 jne	 SHORT $LN28@LCS_AttnTh

; 4080 :             }

  002e0	e9 60 fe ff ff	 jmp	 $LN14@LCS_AttnTh
$LN15@LCS_AttnTh:
$LN31@LCS_AttnTh:

; 4081 :         }
; 4082 :         PTT_DEBUG( "REL  AttnEventLock", 000, 000, 000 );

  002e5	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_pttclass
  002ec	48 8b 00	 mov	 rax, QWORD PTR [rax]
  002ef	48 25 00 00 02
	00		 and	 rax, 131072		; 00020000H
  002f5	48 85 c0	 test	 rax, rax
  002f8	74 36		 je	 SHORT $LN75@LCS_AttnTh
  002fa	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR [rsp+48], 0
  00303	48 c7 44 24 28
	00 00 00 00	 mov	 QWORD PTR [rsp+40], 0
  0030c	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG173276
  00313	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00318	45 33 c9	 xor	 r9d, r9d
  0031b	45 33 c0	 xor	 r8d, r8d
  0031e	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG173277
  00325	b9 00 00 02 00	 mov	 ecx, 131072		; 00020000H
  0032a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ptt_pthread_trace
$LN75@LCS_AttnTh:
  00330	33 c0		 xor	 eax, eax
  00332	85 c0		 test	 eax, eax
  00334	75 af		 jne	 SHORT $LN31@LCS_AttnTh

; 4083 :         release_lock( &pLCSBLK->AttnEventLock );

  00336	48 8b 44 24 60	 mov	 rax, QWORD PTR pLCSBLK$[rsp]
  0033b	48 83 c0 40	 add	 rax, 64			; 00000040H
  0033f	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG173278
  00346	48 8b c8	 mov	 rcx, rax
  00349	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_release_lock

; 4084 : 
; 4085 :         /* Exit when told... */
; 4086 :         if ( pLCSBLK->fCloseInProgress )

  0034f	48 8b 44 24 60	 mov	 rax, QWORD PTR pLCSBLK$[rsp]
  00354	8b 40 18	 mov	 eax, DWORD PTR [rax+24]
  00357	d1 e8		 shr	 eax, 1
  00359	83 e0 01	 and	 eax, 1
  0035c	85 c0		 test	 eax, eax
  0035e	74 56		 je	 SHORT $LN76@LCS_AttnTh
$LN34@LCS_AttnTh:

; 4087 :         {
; 4088 :             PTT_DEBUG( "ATTNTHRD Closing...", 000, 000, 000 );

  00360	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_pttclass
  00367	48 8b 00	 mov	 rax, QWORD PTR [rax]
  0036a	48 25 00 00 02
	00		 and	 rax, 131072		; 00020000H
  00370	48 85 c0	 test	 rax, rax
  00373	74 36		 je	 SHORT $LN77@LCS_AttnTh
  00375	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR [rsp+48], 0
  0037e	48 c7 44 24 28
	00 00 00 00	 mov	 QWORD PTR [rsp+40], 0
  00387	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG173281
  0038e	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00393	45 33 c9	 xor	 r9d, r9d
  00396	45 33 c0	 xor	 r8d, r8d
  00399	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG173282
  003a0	b9 00 00 02 00	 mov	 ecx, 131072		; 00020000H
  003a5	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ptt_pthread_trace
$LN77@LCS_AttnTh:
  003ab	33 c0		 xor	 eax, eax
  003ad	85 c0		 test	 eax, eax
  003af	75 af		 jne	 SHORT $LN34@LCS_AttnTh

; 4089 :             break;

  003b1	e9 fa 04 00 00	 jmp	 $LN6@LCS_AttnTh
$LN76@LCS_AttnTh:
$LN37@LCS_AttnTh:

; 4090 :         }
; 4091 : 
; 4092 :         /* Remove the chain of LCSATTN blocks */
; 4093 :         PTT_DEBUG( "GET  AttnLock", 000, 000, 000 );

  003b6	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_pttclass
  003bd	48 8b 00	 mov	 rax, QWORD PTR [rax]
  003c0	48 25 00 00 02
	00		 and	 rax, 131072		; 00020000H
  003c6	48 85 c0	 test	 rax, rax
  003c9	74 36		 je	 SHORT $LN78@LCS_AttnTh
  003cb	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR [rsp+48], 0
  003d4	48 c7 44 24 28
	00 00 00 00	 mov	 QWORD PTR [rsp+40], 0
  003dd	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG173284
  003e4	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  003e9	45 33 c9	 xor	 r9d, r9d
  003ec	45 33 c0	 xor	 r8d, r8d
  003ef	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG173285
  003f6	b9 00 00 02 00	 mov	 ecx, 131072		; 00020000H
  003fb	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ptt_pthread_trace
$LN78@LCS_AttnTh:
  00401	33 c0		 xor	 eax, eax
  00403	85 c0		 test	 eax, eax
  00405	75 af		 jne	 SHORT $LN37@LCS_AttnTh

; 4094 :         obtain_lock( &pLCSBLK->AttnLock );

  00407	48 8b 44 24 60	 mov	 rax, QWORD PTR pLCSBLK$[rsp]
  0040c	48 83 c0 30	 add	 rax, 48			; 00000030H
  00410	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG173286
  00417	48 8b c8	 mov	 rcx, rax
  0041a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_obtain_lock
$LN40@LCS_AttnTh:

; 4095 :         PTT_DEBUG( "GOT  AttnLock", 000, 000, 000 );

  00420	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_pttclass
  00427	48 8b 00	 mov	 rax, QWORD PTR [rax]
  0042a	48 25 00 00 02
	00		 and	 rax, 131072		; 00020000H
  00430	48 85 c0	 test	 rax, rax
  00433	74 36		 je	 SHORT $LN79@LCS_AttnTh
  00435	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR [rsp+48], 0
  0043e	48 c7 44 24 28
	00 00 00 00	 mov	 QWORD PTR [rsp+40], 0
  00447	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG173288
  0044e	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00453	45 33 c9	 xor	 r9d, r9d
  00456	45 33 c0	 xor	 r8d, r8d
  00459	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG173289
  00460	b9 00 00 02 00	 mov	 ecx, 131072		; 00020000H
  00465	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ptt_pthread_trace
$LN79@LCS_AttnTh:
  0046b	33 c0		 xor	 eax, eax
  0046d	85 c0		 test	 eax, eax
  0046f	75 af		 jne	 SHORT $LN40@LCS_AttnTh

; 4096 :         {
; 4097 :             pLCSATTN = pLCSBLK->pAttns;

  00471	48 8b 44 24 60	 mov	 rax, QWORD PTR pLCSBLK$[rsp]
  00476	48 8b 40 38	 mov	 rax, QWORD PTR [rax+56]
  0047a	48 89 44 24 68	 mov	 QWORD PTR pLCSATTN$[rsp], rax

; 4098 :             pLCSBLK->pAttns = NULL;

  0047f	48 8b 44 24 60	 mov	 rax, QWORD PTR pLCSBLK$[rsp]
  00484	48 c7 40 38 00
	00 00 00	 mov	 QWORD PTR [rax+56], 0

; 4099 :             if ( pLCSATTN )

  0048c	48 83 7c 24 68
	00		 cmp	 QWORD PTR pLCSATTN$[rsp], 0
  00492	74 55		 je	 SHORT $LN80@LCS_AttnTh
$LN43@LCS_AttnTh:

; 4100 :             {
; 4101 :                 PTT_DEBUG( "REM  Attn (All)", pLCSATTN, 000, 000 );

  00494	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_pttclass
  0049b	48 8b 00	 mov	 rax, QWORD PTR [rax]
  0049e	48 25 00 00 02
	00		 and	 rax, 131072		; 00020000H
  004a4	48 85 c0	 test	 rax, rax
  004a7	74 38		 je	 SHORT $LN82@LCS_AttnTh
  004a9	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR [rsp+48], 0
  004b2	48 c7 44 24 28
	00 00 00 00	 mov	 QWORD PTR [rsp+40], 0
  004bb	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG173293
  004c2	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  004c7	45 33 c9	 xor	 r9d, r9d
  004ca	4c 8b 44 24 68	 mov	 r8, QWORD PTR pLCSATTN$[rsp]
  004cf	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG173294
  004d6	b9 00 00 02 00	 mov	 ecx, 131072		; 00020000H
  004db	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ptt_pthread_trace
$LN82@LCS_AttnTh:
  004e1	33 c0		 xor	 eax, eax
  004e3	85 c0		 test	 eax, eax
  004e5	75 ad		 jne	 SHORT $LN43@LCS_AttnTh

; 4102 :             }

  004e7	eb 51		 jmp	 SHORT $LN81@LCS_AttnTh
$LN80@LCS_AttnTh:
$LN46@LCS_AttnTh:

; 4103 :             else
; 4104 :             {
; 4105 :                 PTT_DEBUG( "REM  Attn (Non)", 000, 000, 000 );

  004e9	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_pttclass
  004f0	48 8b 00	 mov	 rax, QWORD PTR [rax]
  004f3	48 25 00 00 02
	00		 and	 rax, 131072		; 00020000H
  004f9	48 85 c0	 test	 rax, rax
  004fc	74 36		 je	 SHORT $LN83@LCS_AttnTh
  004fe	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR [rsp+48], 0
  00507	48 c7 44 24 28
	00 00 00 00	 mov	 QWORD PTR [rsp+40], 0
  00510	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG173296
  00517	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  0051c	45 33 c9	 xor	 r9d, r9d
  0051f	45 33 c0	 xor	 r8d, r8d
  00522	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG173297
  00529	b9 00 00 02 00	 mov	 ecx, 131072		; 00020000H
  0052e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ptt_pthread_trace
$LN83@LCS_AttnTh:
  00534	33 c0		 xor	 eax, eax
  00536	85 c0		 test	 eax, eax
  00538	75 af		 jne	 SHORT $LN46@LCS_AttnTh
$LN81@LCS_AttnTh:
$LN49@LCS_AttnTh:

; 4106 :             }
; 4107 :         }
; 4108 :         PTT_DEBUG( "REL  AttnLock", 000, 000, 000 );

  0053a	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_pttclass
  00541	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00544	48 25 00 00 02
	00		 and	 rax, 131072		; 00020000H
  0054a	48 85 c0	 test	 rax, rax
  0054d	74 36		 je	 SHORT $LN84@LCS_AttnTh
  0054f	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR [rsp+48], 0
  00558	48 c7 44 24 28
	00 00 00 00	 mov	 QWORD PTR [rsp+40], 0
  00561	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG173299
  00568	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  0056d	45 33 c9	 xor	 r9d, r9d
  00570	45 33 c0	 xor	 r8d, r8d
  00573	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG173300
  0057a	b9 00 00 02 00	 mov	 ecx, 131072		; 00020000H
  0057f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ptt_pthread_trace
$LN84@LCS_AttnTh:
  00585	33 c0		 xor	 eax, eax
  00587	85 c0		 test	 eax, eax
  00589	75 af		 jne	 SHORT $LN49@LCS_AttnTh

; 4109 :         release_lock( &pLCSBLK->AttnLock );

  0058b	48 8b 44 24 60	 mov	 rax, QWORD PTR pLCSBLK$[rsp]
  00590	48 83 c0 30	 add	 rax, 48			; 00000030H
  00594	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG173301
  0059b	48 8b c8	 mov	 rcx, rax
  0059e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_release_lock

; 4110 : 
; 4111 :         /* Reverse the chain of LCSATTN blocks */
; 4112 :         if ( pLCSATTN )

  005a4	48 83 7c 24 68
	00		 cmp	 QWORD PTR pLCSATTN$[rsp], 0
  005aa	74 79		 je	 SHORT $LN85@LCS_AttnTh

; 4113 :         {
; 4114 :             pLCSATTNprev = NULL;

  005ac	48 c7 84 24 98
	00 00 00 00 00
	00 00		 mov	 QWORD PTR pLCSATTNprev$[rsp], 0

; 4115 :             pLCSATTNcurr = pLCSATTN;

  005b8	48 8b 44 24 68	 mov	 rax, QWORD PTR pLCSATTN$[rsp]
  005bd	48 89 84 24 88
	00 00 00	 mov	 QWORD PTR pLCSATTNcurr$[rsp], rax
$LN50@LCS_AttnTh:

; 4116 :             while( pLCSATTNcurr )

  005c5	48 83 bc 24 88
	00 00 00 00	 cmp	 QWORD PTR pLCSATTNcurr$[rsp], 0
  005ce	74 48		 je	 SHORT $LN51@LCS_AttnTh

; 4117 :             {
; 4118 :                 pLCSATTNnext = pLCSATTNcurr->pNext;

  005d0	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR pLCSATTNcurr$[rsp]
  005d8	48 8b 00	 mov	 rax, QWORD PTR [rax]
  005db	48 89 84 24 a8
	00 00 00	 mov	 QWORD PTR pLCSATTNnext$[rsp], rax

; 4119 :                 pLCSATTNcurr->pNext = pLCSATTNprev;

  005e3	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR pLCSATTNcurr$[rsp]
  005eb	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR pLCSATTNprev$[rsp]
  005f3	48 89 08	 mov	 QWORD PTR [rax], rcx

; 4120 :                 pLCSATTNprev = pLCSATTNcurr;

  005f6	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR pLCSATTNcurr$[rsp]
  005fe	48 89 84 24 98
	00 00 00	 mov	 QWORD PTR pLCSATTNprev$[rsp], rax

; 4121 :                 pLCSATTNcurr = pLCSATTNnext;

  00606	48 8b 84 24 a8
	00 00 00	 mov	 rax, QWORD PTR pLCSATTNnext$[rsp]
  0060e	48 89 84 24 88
	00 00 00	 mov	 QWORD PTR pLCSATTNcurr$[rsp], rax

; 4122 :             }

  00616	eb ad		 jmp	 SHORT $LN50@LCS_AttnTh
$LN51@LCS_AttnTh:

; 4123 :             pLCSATTN = pLCSATTNprev;

  00618	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR pLCSATTNprev$[rsp]
  00620	48 89 44 24 68	 mov	 QWORD PTR pLCSATTN$[rsp], rax
$LN85@LCS_AttnTh:
$LN52@LCS_AttnTh:

; 4124 :         }
; 4125 : 
; 4126 :         /* Process the chain of LCSATTN blocks */
; 4127 :         while ( pLCSATTN )

  00625	48 83 7c 24 68
	00		 cmp	 QWORD PTR pLCSATTN$[rsp], 0
  0062b	0f 84 7a 02 00
	00		 je	 $LN53@LCS_AttnTh

; 4128 :         {
; 4129 :             /* Point to the next LCSATTN block in the chain, assuming there is one */
; 4130 :             pLCSATTNnext = pLCSATTN->pNext;

  00631	48 8b 44 24 68	 mov	 rax, QWORD PTR pLCSATTN$[rsp]
  00636	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00639	48 89 84 24 a8
	00 00 00	 mov	 QWORD PTR pLCSATTNnext$[rsp], rax

; 4131 : 
; 4132 :             /* Point to the LCSDEV and the read DEVBLK for the command */
; 4133 :             pLCSDEV = pLCSATTN->pDevice;

  00641	48 8b 44 24 68	 mov	 rax, QWORD PTR pLCSATTN$[rsp]
  00646	48 8b 40 08	 mov	 rax, QWORD PTR [rax+8]
  0064a	48 89 84 24 a0
	00 00 00	 mov	 QWORD PTR pLCSDEV$[rsp], rax

; 4134 :             pDEVBLK = pLCSDEV->pDEVBLK[ LCS_READ_SUBCHANN ];

  00652	b8 08 00 00 00	 mov	 eax, 8
  00657	48 6b c0 00	 imul	 rax, rax, 0
  0065b	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR pLCSDEV$[rsp]
  00663	48 8b 44 01 10	 mov	 rax, QWORD PTR [rcx+rax+16]
  00668	48 89 84 24 80
	00 00 00	 mov	 QWORD PTR pDEVBLK$[rsp], rax

; 4135 : 
; 4136 :             /* Only raise an Attention if there is at least one buffer waiting to be read. */
; 4137 :             if (pLCSDEV->pFirstLCSIBH)

  00670	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR pLCSDEV$[rsp]
  00678	48 83 78 72 00	 cmp	 QWORD PTR [rax+114], 0
  0067d	0f 84 0b 02 00
	00		 je	 $LN86@LCS_AttnTh
$LN56@LCS_AttnTh:

; 4138 :             {
; 4139 : 
; 4140 :                 PTT_DEBUG( "PRC  Attn", pLCSATTN, pDEVBLK->devnum, 000 );

  00683	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_pttclass
  0068a	48 8b 00	 mov	 rax, QWORD PTR [rax]
  0068d	48 25 00 00 02
	00		 and	 rax, 131072		; 00020000H
  00693	48 85 c0	 test	 rax, rax
  00696	74 44		 je	 SHORT $LN87@LCS_AttnTh
  00698	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR pDEVBLK$[rsp]
  006a0	0f b7 40 48	 movzx	 eax, WORD PTR [rax+72]
  006a4	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR [rsp+48], 0
  006ad	48 c7 44 24 28
	00 00 00 00	 mov	 QWORD PTR [rsp+40], 0
  006b6	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG173305
  006bd	48 89 4c 24 20	 mov	 QWORD PTR [rsp+32], rcx
  006c2	44 8b c8	 mov	 r9d, eax
  006c5	4c 8b 44 24 68	 mov	 r8, QWORD PTR pLCSATTN$[rsp]
  006ca	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG173306
  006d1	b9 00 00 02 00	 mov	 ecx, 131072		; 00020000H
  006d6	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ptt_pthread_trace
$LN87@LCS_AttnTh:
  006dc	33 c0		 xor	 eax, eax
  006de	85 c0		 test	 eax, eax
  006e0	75 a1		 jne	 SHORT $LN56@LCS_AttnTh

; 4141 : 
; 4142 :                 /* --------------------------------------------------------------------- */
; 4143 : 
; 4144 :                 interval = 100;

  006e2	c7 44 24 78 64
	00 00 00	 mov	 DWORD PTR interval$[rsp], 100 ; 00000064H

; 4145 :                 dev_attn_rc = 0;       /* device_attention RC    */

  006ea	c7 44 24 70 00
	00 00 00	 mov	 DWORD PTR dev_attn_rc$[rsp], 0

; 4146 :                 busy_waits = 0;        /* Number of times waited for */

  006f2	c7 44 24 74 00
	00 00 00	 mov	 DWORD PTR busy_waits$[rsp], 0
$LN57@LCS_AttnTh:

; 4147 :                                        /* a Busy condition to end    */
; 4148 : 
; 4149 :                 for( ; ; )
; 4150 :                 {
; 4151 : 
; 4152 :                     // Wait a small (but increasing) amount of time.
; 4153 :                     usleep(interval);

  006fa	8b 4c 24 78	 mov	 ecx, DWORD PTR interval$[rsp]
  006fe	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_usleep

; 4154 : 
; 4155 : //??                // is there still something in our frame buffer?
; 4156 : //??                if (!pLCSDEV->fDataPending && !pLCSDEV->fReplyPending)
; 4157 : //??                {
; 4158 : //??                    break;
; 4159 : //??                }
; 4160 : 
; 4161 :                     // Raise Attention
; 4162 :                     dev_attn_rc = device_attention( pDEVBLK, CSW_ATTN );

  00704	b2 80		 mov	 dl, 128			; 00000080H
  00706	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR pDEVBLK$[rsp]
  0070e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_device_attention
  00714	89 44 24 70	 mov	 DWORD PTR dev_attn_rc$[rsp], eax
$LN62@LCS_AttnTh:

; 4163 :                     PTT_DEBUG( "Raise Attn   ", 000, pDEVBLK->devnum, dev_attn_rc );

  00718	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_pttclass
  0071f	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00722	48 25 00 00 02
	00		 and	 rax, 131072		; 00020000H
  00728	48 85 c0	 test	 rax, rax
  0072b	74 43		 je	 SHORT $LN88@LCS_AttnTh
  0072d	48 63 44 24 70	 movsxd	 rax, DWORD PTR dev_attn_rc$[rsp]
  00732	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR pDEVBLK$[rsp]
  0073a	0f b7 49 48	 movzx	 ecx, WORD PTR [rcx+72]
  0073e	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR [rsp+48], 0
  00747	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  0074c	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG173308
  00753	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00758	44 8b c9	 mov	 r9d, ecx
  0075b	45 33 c0	 xor	 r8d, r8d
  0075e	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG173309
  00765	b9 00 00 02 00	 mov	 ecx, 131072		; 00020000H
  0076a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ptt_pthread_trace
$LN88@LCS_AttnTh:
  00770	33 c0		 xor	 eax, eax
  00772	85 c0		 test	 eax, eax
  00774	75 a2		 jne	 SHORT $LN62@LCS_AttnTh

; 4164 : 
; 4165 :                     if (pLCSDEV->pLCSBLK->fDebug)

  00776	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR pLCSDEV$[rsp]
  0077e	48 8b 40 08	 mov	 rax, QWORD PTR [rax+8]
  00782	8b 40 18	 mov	 eax, DWORD PTR [rax+24]
  00785	83 e0 01	 and	 eax, 1
  00788	85 c0		 test	 eax, eax
  0078a	0f 84 d2 00 00
	00		 je	 $LN89@LCS_AttnTh

; 4166 :                     {
; 4167 :                         char    tmp[256];
; 4168 :                         snprintf( (char*)tmp, 256, "device_attention rc=%d  %d  %d", dev_attn_rc, busy_waits, interval );

  00790	8b 44 24 78	 mov	 eax, DWORD PTR interval$[rsp]
  00794	89 44 24 28	 mov	 DWORD PTR [rsp+40], eax
  00798	8b 44 24 74	 mov	 eax, DWORD PTR busy_waits$[rsp]
  0079c	89 44 24 20	 mov	 DWORD PTR [rsp+32], eax
  007a0	44 8b 4c 24 70	 mov	 r9d, DWORD PTR dev_attn_rc$[rsp]
  007a5	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG173311
  007ac	ba 00 01 00 00	 mov	 edx, 256		; 00000100H
  007b1	48 8d 8c 24 b0
	00 00 00	 lea	 rcx, QWORD PTR tmp$1[rsp]
  007b9	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_snprintf

; 4169 :                         WRMSG(HHC03991, "D", SSID_TO_LCSS(pDEVBLK->ssid), pDEVBLK->devnum, pDEVBLK->typname, tmp );

  007bf	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR pDEVBLK$[rsp]
  007c7	0f b7 40 48	 movzx	 eax, WORD PTR [rax+72]
  007cb	89 84 24 90 00
	00 00		 mov	 DWORD PTR tv357[rsp], eax
  007d2	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR pDEVBLK$[rsp]
  007da	0f b7 49 44	 movzx	 ecx, WORD PTR [rcx+68]
  007de	d1 f9		 sar	 ecx, 1
  007e0	89 8c 24 94 00
	00 00		 mov	 DWORD PTR tv361[rsp], ecx
  007e7	b9 01 00 00 00	 mov	 ecx, 1
  007ec	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  007f2	48 8d 8c 24 b0
	00 00 00	 lea	 rcx, QWORD PTR tmp$1[rsp]
  007fa	48 89 4c 24 50	 mov	 QWORD PTR [rsp+80], rcx
  007ff	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR pDEVBLK$[rsp]
  00807	48 8b 49 50	 mov	 rcx, QWORD PTR [rcx+80]
  0080b	48 89 4c 24 48	 mov	 QWORD PTR [rsp+72], rcx
  00810	8b 8c 24 90 00
	00 00		 mov	 ecx, DWORD PTR tv357[rsp]
  00817	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  0081b	8b 8c 24 94 00
	00 00		 mov	 ecx, DWORD PTR tv361[rsp]
  00822	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  00826	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG173312
  0082d	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  00832	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG173313
  00839	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  0083e	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00843	41 b9 03 00 00
	00		 mov	 r9d, 3
  00849	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG173314
  00850	ba 49 10 00 00	 mov	 edx, 4169		; 00001049H
  00855	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG173315
  0085c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg
$LN89@LCS_AttnTh:

; 4170 :                     }
; 4171 : 
; 4172 :                     // ATTN RC=1 means a device busy status did
; 4173 :                     // appear so that the signal did not work.
; 4174 :                     // We will retry after some (increasingly)
; 4175 :                     // small amount of time.
; 4176 :                     if ( dev_attn_rc != 1 )

  00862	83 7c 24 70 01	 cmp	 DWORD PTR dev_attn_rc$[rsp], 1
  00867	74 02		 je	 SHORT $LN90@LCS_AttnTh

; 4177 :                     {
; 4178 :                         break;

  00869	eb 23		 jmp	 SHORT $LN58@LCS_AttnTh
$LN90@LCS_AttnTh:

; 4179 :                     }
; 4180 : 
; 4181 :                     busy_waits++;

  0086b	8b 44 24 74	 mov	 eax, DWORD PTR busy_waits$[rsp]
  0086f	ff c0		 inc	 eax
  00871	89 44 24 74	 mov	 DWORD PTR busy_waits$[rsp], eax

; 4182 : 
; 4183 :                     if ( busy_waits >= 20 )

  00875	83 7c 24 74 14	 cmp	 DWORD PTR busy_waits$[rsp], 20
  0087a	7c 02		 jl	 SHORT $LN91@LCS_AttnTh

; 4184 :                     {
; 4185 :                         break;

  0087c	eb 10		 jmp	 SHORT $LN58@LCS_AttnTh
$LN91@LCS_AttnTh:

; 4186 :                     }
; 4187 : 
; 4188 :                     interval += 100;

  0087e	8b 44 24 78	 mov	 eax, DWORD PTR interval$[rsp]
  00882	83 c0 64	 add	 eax, 100		; 00000064H
  00885	89 44 24 78	 mov	 DWORD PTR interval$[rsp], eax

; 4189 : 
; 4190 :                 }   // end for ( ; ; )

  00889	e9 6c fe ff ff	 jmp	 $LN57@LCS_AttnTh
$LN58@LCS_AttnTh:
$LN86@LCS_AttnTh:

; 4191 : 
; 4192 :                 /* --------------------------------------------------------------------- */
; 4193 : 
; 4194 :             }
; 4195 : 
; 4196 :             /* Free the LCSATTN block that has just been processed */
; 4197 :             free (pLCSATTN);

  0088e	48 8b 4c 24 68	 mov	 rcx, QWORD PTR pLCSATTN$[rsp]
  00893	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free

; 4198 : 
; 4199 :             /* Point to the next LCSATTN block in the chain, assuming there is one */
; 4200 :             pLCSATTN = pLCSATTNnext;

  00899	48 8b 84 24 a8
	00 00 00	 mov	 rax, QWORD PTR pLCSATTNnext$[rsp]
  008a1	48 89 44 24 68	 mov	 QWORD PTR pLCSATTN$[rsp], rax

; 4201 :         }  // end while (pLCSATTN)

  008a6	e9 7a fd ff ff	 jmp	 $LN52@LCS_AttnTh
$LN53@LCS_AttnTh:

; 4202 : 
; 4203 :     }  // end for ( ; ; )

  008ab	e9 da f7 ff ff	 jmp	 $LN5@LCS_AttnTh
$LN6@LCS_AttnTh:
$LN65@LCS_AttnTh:

; 4204 : 
; 4205 :     PTT_DEBUG( "ATTNTHRD: EXIT", 000, 000, 000 );

  008b0	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_pttclass
  008b7	48 8b 00	 mov	 rax, QWORD PTR [rax]
  008ba	48 25 00 00 02
	00		 and	 rax, 131072		; 00020000H
  008c0	48 85 c0	 test	 rax, rax
  008c3	74 36		 je	 SHORT $LN92@LCS_AttnTh
  008c5	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR [rsp+48], 0
  008ce	48 c7 44 24 28
	00 00 00 00	 mov	 QWORD PTR [rsp+40], 0
  008d7	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG173319
  008de	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  008e3	45 33 c9	 xor	 r9d, r9d
  008e6	45 33 c0	 xor	 r8d, r8d
  008e9	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG173320
  008f0	b9 00 00 02 00	 mov	 ecx, 131072		; 00020000H
  008f5	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ptt_pthread_trace
$LN92@LCS_AttnTh:
  008fb	33 c0		 xor	 eax, eax
  008fd	85 c0		 test	 eax, eax
  008ff	75 af		 jne	 SHORT $LN65@LCS_AttnTh

; 4206 : 
; 4207 : //  {                                                                          /* FixMe! Remove! */
; 4208 : //      char    tmp[256];                                                      /* FixMe! Remove! */
; 4209 : //      snprintf( (char*)tmp, 256, "LCS_AttnThread terminated" );              /* FixMe! Remove! */
; 4210 : //      WRMSG(HHC03984, "D", tmp );                                            /* FixMe! Remove! */
; 4211 : //  }                                                                          /* FixMe! Remove! */
; 4212 : 
; 4213 :     return NULL;

  00901	33 c0		 xor	 eax, eax

; 4214 : }   // End of LCS_AttnThread

  00903	48 8b 8c 24 b0
	01 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  0090b	48 33 cc	 xor	 rcx, rsp
  0090e	e8 00 00 00 00	 call	 __security_check_cookie
  00913	48 81 c4 c8 01
	00 00		 add	 rsp, 456		; 000001c8H
  0091a	c3		 ret	 0
LCS_AttnThread ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\ctc_lcs.c
_TEXT	SEGMENT
pLCSPORT$ = 112
bReported$ = 120
bStartReported$ = 121
bHas8022Snap$ = 122
iTraceLen$ = 124
pLCSDev$ = 128
iLength$ = 136
pDEVBLK$ = 144
hwEthernetType$ = 152
pMatchingLCSDEV$ = 160
bHas8022$ = 168
pMAC$ = 176
c$1 = 184
c$2 = 188
lIPAddress$ = 192
pEthFrame$ = 200
pARPFrame$ = 208
pPrimaryLCSDEV$ = 216
pSecondaryLCSDEV$ = 224
pLCSRTE$ = 232
tv643 = 240
tv646 = 244
tv649 = 248
tv652 = 252
tv655 = 256
tv657 = 260
tv660 = 264
tv734 = 268
tv737 = 272
tv740 = 276
tv748 = 280
tv751 = 284
tv799 = 288
tv841 = 292
tv879 = 296
tv885 = 300
tv889 = 304
tv159 = 308
tv171 = 312
tv296 = 316
tv402 = 320
tv431 = 324
tv436 = 328
tv440 = 332
tv478 = 336
tv528 = 340
tv609 = 344
pIPFrame$ = 352
tv397 = 360
tv404 = 368
tv426 = 376
mac$ = 384
cPktType$ = 392
str$3 = 416
str$4 = 456
szBuff$ = 496
__$ArrayPad$ = 2544
arg$ = 2592
LCS_PortThread PROC

; 2280 : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	56		 push	 rsi
  00006	57		 push	 rdi
  00007	48 81 ec 08 0a
	00 00		 sub	 rsp, 2568		; 00000a08H
  0000e	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00015	48 33 c4	 xor	 rax, rsp
  00018	48 89 84 24 f0
	09 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 2281 :     DEVBLK*     pDEVBLK;
; 2282 :     PLCSPORT    pLCSPORT = (PLCSPORT) arg;

  00020	48 8b 84 24 20
	0a 00 00	 mov	 rax, QWORD PTR arg$[rsp]
  00028	48 89 44 24 70	 mov	 QWORD PTR pLCSPORT$[rsp], rax

; 2283 :     PLCSDEV     pLCSDev;
; 2284 :     PLCSDEV     pPrimaryLCSDEV;
; 2285 :     PLCSDEV     pSecondaryLCSDEV;
; 2286 :     PLCSDEV     pMatchingLCSDEV;
; 2287 :     PLCSRTE     pLCSRTE;
; 2288 :     PETHFRM     pEthFrame;
; 2289 :     PIP4FRM     pIPFrame   = NULL;

  0002d	48 c7 84 24 60
	01 00 00 00 00
	00 00		 mov	 QWORD PTR pIPFrame$[rsp], 0

; 2290 :     PARPFRM     pARPFrame  = NULL;

  00039	48 c7 84 24 d0
	00 00 00 00 00
	00 00		 mov	 QWORD PTR pARPFrame$[rsp], 0

; 2291 :     int         iLength;
; 2292 :     U32         lIPAddress;             // (network byte order)
; 2293 :     BYTE*       pMAC;
; 2294 :     BYTE        szBuff[2048];
; 2295 :     char        bReported = 0;

  00045	c6 44 24 78 00	 mov	 BYTE PTR bReported$[rsp], 0

; 2296 :     char        bStartReported = 0;

  0004a	c6 44 24 79 00	 mov	 BYTE PTR bStartReported$[rsp], 0

; 2297 :     char        cPktType[24];
; 2298 :     U16         hwEthernetType;
; 2299 :     BYTE        bHas8022;
; 2300 :     BYTE        bHas8022Snap;
; 2301 :     int         iTraceLen;
; 2302 :     MAC         mac;
; 2303 : 
; 2304 :     pDEVBLK = pLCSPORT->pLCSBLK->pDevices->pDEVBLK[ LCS_READ_SUBCHANN ];

  0004f	48 8b 44 24 70	 mov	 rax, QWORD PTR pLCSPORT$[rsp]
  00054	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  00058	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  0005c	b9 08 00 00 00	 mov	 ecx, 8
  00061	48 6b c9 00	 imul	 rcx, rcx, 0
  00065	48 8b 44 08 10	 mov	 rax, QWORD PTR [rax+rcx+16]
  0006a	48 89 84 24 90
	00 00 00	 mov	 QWORD PTR pDEVBLK$[rsp], rax

; 2305 : 
; 2306 :     pLCSPORT->pid = getpid();

  00072	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_getpid
  00078	48 8b 4c 24 70	 mov	 rcx, QWORD PTR pLCSPORT$[rsp]
  0007d	89 81 40 01 00
	00		 mov	 DWORD PTR [rcx+320], eax
$LN4@LCS_PortTh:

; 2307 : 
; 2308 :     PTT_DEBUG(            "PORTHRD: ENTRY    ", 000, pDEVBLK->devnum, pLCSPORT->bPort );

  00083	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_pttclass
  0008a	48 8b 00	 mov	 rax, QWORD PTR [rax]
  0008d	48 25 00 00 02
	00		 and	 rax, 131072		; 00020000H
  00093	48 85 c0	 test	 rax, rax
  00096	74 46		 je	 SHORT $LN61@LCS_PortTh
  00098	48 8b 44 24 70	 mov	 rax, QWORD PTR pLCSPORT$[rsp]
  0009d	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  000a0	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR pDEVBLK$[rsp]
  000a8	0f b7 49 48	 movzx	 ecx, WORD PTR [rcx+72]
  000ac	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR [rsp+48], 0
  000b5	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  000ba	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG171879
  000c1	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  000c6	44 8b c9	 mov	 r9d, ecx
  000c9	45 33 c0	 xor	 r8d, r8d
  000cc	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG171880
  000d3	b9 00 00 02 00	 mov	 ecx, 131072		; 00020000H
  000d8	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ptt_pthread_trace
$LN61@LCS_PortTh:
  000de	33 c0		 xor	 eax, eax
  000e0	85 c0		 test	 eax, eax
  000e2	75 9f		 jne	 SHORT $LN4@LCS_PortTh
$LN5@LCS_PortTh:
$LN10@LCS_PortTh:

; 2309 : 
; 2310 :     for (;;)
; 2311 :     {
; 2312 :         PTT_DEBUG(        "GET  PortEventLock", 000, pDEVBLK->devnum, pLCSPORT->bPort );

  000e4	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_pttclass
  000eb	48 8b 00	 mov	 rax, QWORD PTR [rax]
  000ee	48 25 00 00 02
	00		 and	 rax, 131072		; 00020000H
  000f4	48 85 c0	 test	 rax, rax
  000f7	74 46		 je	 SHORT $LN62@LCS_PortTh
  000f9	48 8b 44 24 70	 mov	 rax, QWORD PTR pLCSPORT$[rsp]
  000fe	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  00101	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR pDEVBLK$[rsp]
  00109	0f b7 49 48	 movzx	 ecx, WORD PTR [rcx+72]
  0010d	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR [rsp+48], 0
  00116	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  0011b	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG171882
  00122	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00127	44 8b c9	 mov	 r9d, ecx
  0012a	45 33 c0	 xor	 r8d, r8d
  0012d	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG171883
  00134	b9 00 00 02 00	 mov	 ecx, 131072		; 00020000H
  00139	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ptt_pthread_trace
$LN62@LCS_PortTh:
  0013f	33 c0		 xor	 eax, eax
  00141	85 c0		 test	 eax, eax
  00143	75 9f		 jne	 SHORT $LN10@LCS_PortTh

; 2313 :         obtain_lock( &pLCSPORT->PortEventLock );

  00145	48 8b 44 24 70	 mov	 rax, QWORD PTR pLCSPORT$[rsp]
  0014a	48 05 24 01 00
	00		 add	 rax, 292		; 00000124H
  00150	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG171884
  00157	48 8b c8	 mov	 rcx, rax
  0015a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_obtain_lock
$LN13@LCS_PortTh:

; 2314 :         PTT_DEBUG(        "GOT  PortEventLock", 000, pDEVBLK->devnum, pLCSPORT->bPort );

  00160	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_pttclass
  00167	48 8b 00	 mov	 rax, QWORD PTR [rax]
  0016a	48 25 00 00 02
	00		 and	 rax, 131072		; 00020000H
  00170	48 85 c0	 test	 rax, rax
  00173	74 46		 je	 SHORT $LN63@LCS_PortTh
  00175	48 8b 44 24 70	 mov	 rax, QWORD PTR pLCSPORT$[rsp]
  0017a	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  0017d	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR pDEVBLK$[rsp]
  00185	0f b7 49 48	 movzx	 ecx, WORD PTR [rcx+72]
  00189	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR [rsp+48], 0
  00192	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  00197	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG171886
  0019e	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  001a3	44 8b c9	 mov	 r9d, ecx
  001a6	45 33 c0	 xor	 r8d, r8d
  001a9	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG171887
  001b0	b9 00 00 02 00	 mov	 ecx, 131072		; 00020000H
  001b5	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ptt_pthread_trace
$LN63@LCS_PortTh:
  001bb	33 c0		 xor	 eax, eax
  001bd	85 c0		 test	 eax, eax
  001bf	75 9f		 jne	 SHORT $LN13@LCS_PortTh

; 2315 :         {
; 2316 :             // Don't read unless/until port is enabled...
; 2317 : 
; 2318 :             if (!pLCSPORT->fPortStarted)

  001c1	48 8b 44 24 70	 mov	 rax, QWORD PTR pLCSPORT$[rsp]
  001c6	8b 80 34 01 00
	00		 mov	 eax, DWORD PTR [rax+308]
  001cc	c1 e8 03	 shr	 eax, 3
  001cf	83 e0 01	 and	 eax, 1
  001d2	85 c0		 test	 eax, eax
  001d4	0f 85 e7 00 00
	00		 jne	 $LN64@LCS_PortTh

; 2319 :             {
; 2320 :                 if (pLCSPORT->pLCSBLK->fDebug)

  001da	48 8b 44 24 70	 mov	 rax, QWORD PTR pLCSPORT$[rsp]
  001df	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  001e3	8b 40 18	 mov	 eax, DWORD PTR [rax+24]
  001e6	83 e0 01	 and	 eax, 1
  001e9	85 c0		 test	 eax, eax
  001eb	0f 84 cb 00 00
	00		 je	 $LN65@LCS_PortTh

; 2321 :                 {
; 2322 :                     if (bStartReported)

  001f1	0f be 44 24 79	 movsx	 eax, BYTE PTR bStartReported$[rsp]
  001f6	85 c0		 test	 eax, eax
  001f8	74 61		 je	 SHORT $LN66@LCS_PortTh

; 2323 :                         // "CTC: lcs device port %2.2X: read thread: port stopped"
; 2324 :                         WRMSG( HHC00969, "D", pLCSPORT->bPort );

  001fa	48 8b 44 24 70	 mov	 rax, QWORD PTR pLCSPORT$[rsp]
  001ff	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  00202	89 84 24 34 01
	00 00		 mov	 DWORD PTR tv159[rsp], eax
  00209	b9 01 00 00 00	 mov	 ecx, 1
  0020e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  00214	8b 8c 24 34 01
	00 00		 mov	 ecx, DWORD PTR tv159[rsp]
  0021b	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  0021f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG171891
  00226	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  0022b	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG171892
  00232	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00237	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  0023c	41 b9 03 00 00
	00		 mov	 r9d, 3
  00242	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG171893
  00249	ba 14 09 00 00	 mov	 edx, 2324		; 00000914H
  0024e	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG171894
  00255	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg
$LN66@LCS_PortTh:

; 2325 : 
; 2326 :                     // "CTC: lcs device port %2.2X: read thread: waiting for start event"
; 2327 :                     WRMSG( HHC00967, "D", pLCSPORT->bPort );

  0025b	48 8b 44 24 70	 mov	 rax, QWORD PTR pLCSPORT$[rsp]
  00260	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  00263	89 84 24 38 01
	00 00		 mov	 DWORD PTR tv171[rsp], eax
  0026a	b9 01 00 00 00	 mov	 ecx, 1
  0026f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  00275	8b 8c 24 38 01
	00 00		 mov	 ecx, DWORD PTR tv171[rsp]
  0027c	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  00280	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG171895
  00287	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  0028c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG171896
  00293	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00298	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  0029d	41 b9 03 00 00
	00		 mov	 r9d, 3
  002a3	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG171897
  002aa	ba 17 09 00 00	 mov	 edx, 2327		; 00000917H
  002af	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG171898
  002b6	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg
$LN65@LCS_PortTh:

; 2328 :                 }
; 2329 :                 bStartReported = 0;

  002bc	c6 44 24 79 00	 mov	 BYTE PTR bStartReported$[rsp], 0
$LN64@LCS_PortTh:
$LN14@LCS_PortTh:

; 2330 :             }
; 2331 : 
; 2332 :             while (1)

  002c1	33 c0		 xor	 eax, eax
  002c3	83 f8 01	 cmp	 eax, 1
  002c6	0f 84 c4 02 00
	00		 je	 $LN15@LCS_PortTh
$LN18@LCS_PortTh:

; 2333 :             {
; 2334 :                 PTT_DEBUG( "PORTHRD if started", pLCSPORT->fPortStarted, pDEVBLK->devnum, pLCSPORT->bPort );

  002cc	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_pttclass
  002d3	48 8b 00	 mov	 rax, QWORD PTR [rax]
  002d6	48 25 00 00 02
	00		 and	 rax, 131072		; 00020000H
  002dc	48 85 c0	 test	 rax, rax
  002df	74 59		 je	 SHORT $LN67@LCS_PortTh
  002e1	48 8b 44 24 70	 mov	 rax, QWORD PTR pLCSPORT$[rsp]
  002e6	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  002e9	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR pDEVBLK$[rsp]
  002f1	0f b7 49 48	 movzx	 ecx, WORD PTR [rcx+72]
  002f5	48 8b 54 24 70	 mov	 rdx, QWORD PTR pLCSPORT$[rsp]
  002fa	8b 92 34 01 00
	00		 mov	 edx, DWORD PTR [rdx+308]
  00300	c1 ea 03	 shr	 edx, 3
  00303	83 e2 01	 and	 edx, 1
  00306	8b d2		 mov	 edx, edx
  00308	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR [rsp+48], 0
  00311	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  00316	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG171900
  0031d	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00322	44 8b c9	 mov	 r9d, ecx
  00325	44 8b c2	 mov	 r8d, edx
  00328	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG171901
  0032f	b9 00 00 02 00	 mov	 ecx, 131072		; 00020000H
  00334	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ptt_pthread_trace
$LN67@LCS_PortTh:
  0033a	33 c0		 xor	 eax, eax
  0033c	85 c0		 test	 eax, eax
  0033e	75 8c		 jne	 SHORT $LN18@LCS_PortTh

; 2335 :                 if (0
; 2336 :                     || (pLCSPORT->fd < 0)
; 2337 :                     || pLCSPORT->fCloseInProgress
; 2338 :                     || pLCSPORT->fPortStarted

  00340	33 c0		 xor	 eax, eax
  00342	85 c0		 test	 eax, eax
  00344	75 3c		 jne	 SHORT $LN69@LCS_PortTh
  00346	48 8b 44 24 70	 mov	 rax, QWORD PTR pLCSPORT$[rsp]
  0034b	83 b8 38 01 00
	00 00		 cmp	 DWORD PTR [rax+312], 0
  00352	7c 2e		 jl	 SHORT $LN69@LCS_PortTh
  00354	48 8b 44 24 70	 mov	 rax, QWORD PTR pLCSPORT$[rsp]
  00359	8b 80 34 01 00
	00		 mov	 eax, DWORD PTR [rax+308]
  0035f	c1 e8 05	 shr	 eax, 5
  00362	83 e0 01	 and	 eax, 1
  00365	85 c0		 test	 eax, eax
  00367	75 19		 jne	 SHORT $LN69@LCS_PortTh
  00369	48 8b 44 24 70	 mov	 rax, QWORD PTR pLCSPORT$[rsp]
  0036e	8b 80 34 01 00
	00		 mov	 eax, DWORD PTR [rax+308]
  00374	c1 e8 03	 shr	 eax, 3
  00377	83 e0 01	 and	 eax, 1
  0037a	85 c0		 test	 eax, eax
  0037c	0f 84 12 01 00
	00		 je	 $LN68@LCS_PortTh
$LN69@LCS_PortTh:

; 2339 :                 )
; 2340 :                 {
; 2341 :                     if ((pLCSPORT->fd < 0) || pLCSPORT->fCloseInProgress)

  00382	48 8b 44 24 70	 mov	 rax, QWORD PTR pLCSPORT$[rsp]
  00387	83 b8 38 01 00
	00 00		 cmp	 DWORD PTR [rax+312], 0
  0038e	7c 15		 jl	 SHORT $LN72@LCS_PortTh
  00390	48 8b 44 24 70	 mov	 rax, QWORD PTR pLCSPORT$[rsp]
  00395	8b 80 34 01 00
	00		 mov	 eax, DWORD PTR [rax+308]
  0039b	c1 e8 05	 shr	 eax, 5
  0039e	83 e0 01	 and	 eax, 1
  003a1	85 c0		 test	 eax, eax
  003a3	74 76		 je	 SHORT $LN70@LCS_PortTh
$LN72@LCS_PortTh:
$LN21@LCS_PortTh:

; 2342 :                         PTT_DEBUG( "PORTHRD is closing", pLCSPORT->fPortStarted, pDEVBLK->devnum, pLCSPORT->bPort );

  003a5	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_pttclass
  003ac	48 8b 00	 mov	 rax, QWORD PTR [rax]
  003af	48 25 00 00 02
	00		 and	 rax, 131072		; 00020000H
  003b5	48 85 c0	 test	 rax, rax
  003b8	74 59		 je	 SHORT $LN73@LCS_PortTh
  003ba	48 8b 44 24 70	 mov	 rax, QWORD PTR pLCSPORT$[rsp]
  003bf	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  003c2	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR pDEVBLK$[rsp]
  003ca	0f b7 49 48	 movzx	 ecx, WORD PTR [rcx+72]
  003ce	48 8b 54 24 70	 mov	 rdx, QWORD PTR pLCSPORT$[rsp]
  003d3	8b 92 34 01 00
	00		 mov	 edx, DWORD PTR [rdx+308]
  003d9	c1 ea 03	 shr	 edx, 3
  003dc	83 e2 01	 and	 edx, 1
  003df	8b d2		 mov	 edx, edx
  003e1	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR [rsp+48], 0
  003ea	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  003ef	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG171908
  003f6	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  003fb	44 8b c9	 mov	 r9d, ecx
  003fe	44 8b c2	 mov	 r8d, edx
  00401	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG171909
  00408	b9 00 00 02 00	 mov	 ecx, 131072		; 00020000H
  0040d	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ptt_pthread_trace
$LN73@LCS_PortTh:
  00413	33 c0		 xor	 eax, eax
  00415	85 c0		 test	 eax, eax
  00417	75 8c		 jne	 SHORT $LN21@LCS_PortTh
  00419	eb 74		 jmp	 SHORT $LN71@LCS_PortTh
$LN70@LCS_PortTh:
$LN24@LCS_PortTh:

; 2343 :                     else
; 2344 :                         PTT_DEBUG( "PORTHRD is started", pLCSPORT->fPortStarted, pDEVBLK->devnum, pLCSPORT->bPort );

  0041b	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_pttclass
  00422	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00425	48 25 00 00 02
	00		 and	 rax, 131072		; 00020000H
  0042b	48 85 c0	 test	 rax, rax
  0042e	74 59		 je	 SHORT $LN74@LCS_PortTh
  00430	48 8b 44 24 70	 mov	 rax, QWORD PTR pLCSPORT$[rsp]
  00435	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  00438	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR pDEVBLK$[rsp]
  00440	0f b7 49 48	 movzx	 ecx, WORD PTR [rcx+72]
  00444	48 8b 54 24 70	 mov	 rdx, QWORD PTR pLCSPORT$[rsp]
  00449	8b 92 34 01 00
	00		 mov	 edx, DWORD PTR [rdx+308]
  0044f	c1 ea 03	 shr	 edx, 3
  00452	83 e2 01	 and	 edx, 1
  00455	8b d2		 mov	 edx, edx
  00457	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR [rsp+48], 0
  00460	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  00465	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG171911
  0046c	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00471	44 8b c9	 mov	 r9d, ecx
  00474	44 8b c2	 mov	 r8d, edx
  00477	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG171912
  0047e	b9 00 00 02 00	 mov	 ecx, 131072		; 00020000H
  00483	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ptt_pthread_trace
$LN74@LCS_PortTh:
  00489	33 c0		 xor	 eax, eax
  0048b	85 c0		 test	 eax, eax
  0048d	75 8c		 jne	 SHORT $LN24@LCS_PortTh
$LN71@LCS_PortTh:

; 2345 :                     break;

  0048f	e9 fc 00 00 00	 jmp	 $LN15@LCS_PortTh
$LN68@LCS_PortTh:
$LN27@LCS_PortTh:

; 2346 :                 }
; 2347 : 
; 2348 :                 PTT_DEBUG( "WAIT PortEventLock", 000, pDEVBLK->devnum, pLCSPORT->bPort );

  00494	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_pttclass
  0049b	48 8b 00	 mov	 rax, QWORD PTR [rax]
  0049e	48 25 00 00 02
	00		 and	 rax, 131072		; 00020000H
  004a4	48 85 c0	 test	 rax, rax
  004a7	74 46		 je	 SHORT $LN75@LCS_PortTh
  004a9	48 8b 44 24 70	 mov	 rax, QWORD PTR pLCSPORT$[rsp]
  004ae	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  004b1	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR pDEVBLK$[rsp]
  004b9	0f b7 49 48	 movzx	 ecx, WORD PTR [rcx+72]
  004bd	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR [rsp+48], 0
  004c6	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  004cb	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG171914
  004d2	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  004d7	44 8b c9	 mov	 r9d, ecx
  004da	45 33 c0	 xor	 r8d, r8d
  004dd	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG171915
  004e4	b9 00 00 02 00	 mov	 ecx, 131072		; 00020000H
  004e9	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ptt_pthread_trace
$LN75@LCS_PortTh:
  004ef	33 c0		 xor	 eax, eax
  004f1	85 c0		 test	 eax, eax
  004f3	75 9f		 jne	 SHORT $LN27@LCS_PortTh

; 2349 :                 timed_wait_condition_relative_usecs

  004f5	48 8b 44 24 70	 mov	 rax, QWORD PTR pLCSPORT$[rsp]
  004fa	48 05 24 01 00
	00		 add	 rax, 292		; 00000124H
  00500	48 8b 4c 24 70	 mov	 rcx, QWORD PTR pLCSPORT$[rsp]
  00505	48 81 c1 2c 01
	00 00		 add	 rcx, 300		; 0000012cH
  0050c	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG171916
  00513	48 89 54 24 20	 mov	 QWORD PTR [rsp+32], rdx
  00518	45 33 c9	 xor	 r9d, r9d
  0051b	41 b8 90 d0 03
	00		 mov	 r8d, 250000		; 0003d090H
  00521	48 8b d0	 mov	 rdx, rax
  00524	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_timed_wait_condition_relative_usecs_impl
$LN30@LCS_PortTh:

; 2350 :                 (
; 2351 :                     &pLCSPORT->PortEvent,       // ptr to condition to wait on
; 2352 :                     &pLCSPORT->PortEventLock,   // ptr to controlling lock (must be held!)
; 2353 :                     250*1000,                   // max #of microseconds to wait
; 2354 :                     NULL                        // [OPTIONAL] ptr to tod value (may be NULL)
; 2355 :                 );
; 2356 :                 PTT_DEBUG( "WOKE PortEventLock", 000, pDEVBLK->devnum, pLCSPORT->bPort );

  0052a	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_pttclass
  00531	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00534	48 25 00 00 02
	00		 and	 rax, 131072		; 00020000H
  0053a	48 85 c0	 test	 rax, rax
  0053d	74 46		 je	 SHORT $LN76@LCS_PortTh
  0053f	48 8b 44 24 70	 mov	 rax, QWORD PTR pLCSPORT$[rsp]
  00544	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  00547	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR pDEVBLK$[rsp]
  0054f	0f b7 49 48	 movzx	 ecx, WORD PTR [rcx+72]
  00553	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR [rsp+48], 0
  0055c	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  00561	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG171918
  00568	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  0056d	44 8b c9	 mov	 r9d, ecx
  00570	45 33 c0	 xor	 r8d, r8d
  00573	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG171919
  0057a	b9 00 00 02 00	 mov	 ecx, 131072		; 00020000H
  0057f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ptt_pthread_trace
$LN76@LCS_PortTh:
  00585	33 c0		 xor	 eax, eax
  00587	85 c0		 test	 eax, eax
  00589	75 9f		 jne	 SHORT $LN30@LCS_PortTh

; 2357 : 
; 2358 :             } // end while (1)

  0058b	e9 31 fd ff ff	 jmp	 $LN14@LCS_PortTh
$LN15@LCS_PortTh:

; 2359 : 
; 2360 :             if (!bStartReported)

  00590	0f be 44 24 79	 movsx	 eax, BYTE PTR bStartReported$[rsp]
  00595	85 c0		 test	 eax, eax
  00597	75 79		 jne	 SHORT $LN77@LCS_PortTh

; 2361 :             {
; 2362 :                 bStartReported = 1;

  00599	c6 44 24 79 01	 mov	 BYTE PTR bStartReported$[rsp], 1

; 2363 :                 if (pLCSPORT->pLCSBLK->fDebug)

  0059e	48 8b 44 24 70	 mov	 rax, QWORD PTR pLCSPORT$[rsp]
  005a3	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  005a7	8b 40 18	 mov	 eax, DWORD PTR [rax+24]
  005aa	83 e0 01	 and	 eax, 1
  005ad	85 c0		 test	 eax, eax
  005af	74 61		 je	 SHORT $LN78@LCS_PortTh

; 2364 :                     // "CTC: lcs device port %2.2X: read thread: port started"
; 2365 :                     WRMSG( HHC00968, "D", pLCSPORT->bPort );

  005b1	48 8b 44 24 70	 mov	 rax, QWORD PTR pLCSPORT$[rsp]
  005b6	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  005b9	89 84 24 3c 01
	00 00		 mov	 DWORD PTR tv296[rsp], eax
  005c0	b9 01 00 00 00	 mov	 ecx, 1
  005c5	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  005cb	8b 8c 24 3c 01
	00 00		 mov	 ecx, DWORD PTR tv296[rsp]
  005d2	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  005d6	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG171922
  005dd	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  005e2	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG171923
  005e9	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  005ee	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  005f3	41 b9 03 00 00
	00		 mov	 r9d, 3
  005f9	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG171924
  00600	ba 3d 09 00 00	 mov	 edx, 2365		; 0000093dH
  00605	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG171925
  0060c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg
$LN78@LCS_PortTh:
$LN77@LCS_PortTh:
$LN33@LCS_PortTh:

; 2366 :             }
; 2367 :         }
; 2368 :         PTT_DEBUG(         "REL  PortEventLock", 000, pDEVBLK->devnum, pLCSPORT->bPort );

  00612	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_pttclass
  00619	48 8b 00	 mov	 rax, QWORD PTR [rax]
  0061c	48 25 00 00 02
	00		 and	 rax, 131072		; 00020000H
  00622	48 85 c0	 test	 rax, rax
  00625	74 46		 je	 SHORT $LN79@LCS_PortTh
  00627	48 8b 44 24 70	 mov	 rax, QWORD PTR pLCSPORT$[rsp]
  0062c	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  0062f	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR pDEVBLK$[rsp]
  00637	0f b7 49 48	 movzx	 ecx, WORD PTR [rcx+72]
  0063b	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR [rsp+48], 0
  00644	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  00649	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG171927
  00650	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00655	44 8b c9	 mov	 r9d, ecx
  00658	45 33 c0	 xor	 r8d, r8d
  0065b	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG171928
  00662	b9 00 00 02 00	 mov	 ecx, 131072		; 00020000H
  00667	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ptt_pthread_trace
$LN79@LCS_PortTh:
  0066d	33 c0		 xor	 eax, eax
  0066f	85 c0		 test	 eax, eax
  00671	75 9f		 jne	 SHORT $LN33@LCS_PortTh

; 2369 :         release_lock( &pLCSPORT->PortEventLock );

  00673	48 8b 44 24 70	 mov	 rax, QWORD PTR pLCSPORT$[rsp]
  00678	48 05 24 01 00
	00		 add	 rax, 292		; 00000124H
  0067e	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG171929
  00685	48 8b c8	 mov	 rcx, rax
  00688	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_release_lock

; 2370 : 
; 2371 :         // Exit when told...
; 2372 : 
; 2373 :         if ( pLCSPORT->fd < 0 || pLCSPORT->fCloseInProgress )

  0068e	48 8b 44 24 70	 mov	 rax, QWORD PTR pLCSPORT$[rsp]
  00693	83 b8 38 01 00
	00 00		 cmp	 DWORD PTR [rax+312], 0
  0069a	7c 15		 jl	 SHORT $LN81@LCS_PortTh
  0069c	48 8b 44 24 70	 mov	 rax, QWORD PTR pLCSPORT$[rsp]
  006a1	8b 80 34 01 00
	00		 mov	 eax, DWORD PTR [rax+308]
  006a7	c1 e8 05	 shr	 eax, 5
  006aa	83 e0 01	 and	 eax, 1
  006ad	85 c0		 test	 eax, eax
  006af	74 05		 je	 SHORT $LN80@LCS_PortTh
$LN81@LCS_PortTh:

; 2374 :             break;

  006b1	e9 61 10 00 00	 jmp	 $LN6@LCS_PortTh
$LN80@LCS_PortTh:
$LN36@LCS_PortTh:

; 2375 : 
; 2376 :         // Read an IP packet from the TAP device
; 2377 :         PTT_TIMING( "b4 tt read", 0, 0, 0 );

  006b6	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_pttclass
  006bd	48 8b 00	 mov	 rax, QWORD PTR [rax]
  006c0	48 25 00 00 01
	00		 and	 rax, 65536		; 00010000H
  006c6	48 85 c0	 test	 rax, rax
  006c9	74 36		 je	 SHORT $LN82@LCS_PortTh
  006cb	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR [rsp+48], 0
  006d4	48 c7 44 24 28
	00 00 00 00	 mov	 QWORD PTR [rsp+40], 0
  006dd	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG171933
  006e4	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  006e9	45 33 c9	 xor	 r9d, r9d
  006ec	45 33 c0	 xor	 r8d, r8d
  006ef	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG171934
  006f6	b9 00 00 01 00	 mov	 ecx, 65536		; 00010000H
  006fb	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ptt_pthread_trace
$LN82@LCS_PortTh:
  00701	33 c0		 xor	 eax, eax
  00703	85 c0		 test	 eax, eax
  00705	75 af		 jne	 SHORT $LN36@LCS_PortTh

; 2378 :         iLength = read_tuntap( pLCSPORT->fd, szBuff, sizeof( szBuff ), DEF_NET_READ_TIMEOUT_SECS );

  00707	41 b9 05 00 00
	00		 mov	 r9d, 5
  0070d	41 b8 00 08 00
	00		 mov	 r8d, 2048		; 00000800H
  00713	48 8d 94 24 f0
	01 00 00	 lea	 rdx, QWORD PTR szBuff$[rsp]
  0071b	48 8b 44 24 70	 mov	 rax, QWORD PTR pLCSPORT$[rsp]
  00720	8b 88 38 01 00
	00		 mov	 ecx, DWORD PTR [rax+312]
  00726	e8 00 00 00 00	 call	 read_tuntap
  0072b	89 84 24 88 00
	00 00		 mov	 DWORD PTR iLength$[rsp], eax
$LN39@LCS_PortTh:

; 2379 :         PTT_TIMING( "af tt read", 0, 0, iLength );

  00732	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_pttclass
  00739	48 8b 00	 mov	 rax, QWORD PTR [rax]
  0073c	48 25 00 00 01
	00		 and	 rax, 65536		; 00010000H
  00742	48 85 c0	 test	 rax, rax
  00745	74 3a		 je	 SHORT $LN83@LCS_PortTh
  00747	48 63 84 24 88
	00 00 00	 movsxd	 rax, DWORD PTR iLength$[rsp]
  0074f	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR [rsp+48], 0
  00758	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  0075d	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG171936
  00764	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00769	45 33 c9	 xor	 r9d, r9d
  0076c	45 33 c0	 xor	 r8d, r8d
  0076f	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG171937
  00776	b9 00 00 01 00	 mov	 ecx, 65536		; 00010000H
  0077b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ptt_pthread_trace
$LN83@LCS_PortTh:
  00781	33 c0		 xor	 eax, eax
  00783	85 c0		 test	 eax, eax
  00785	75 ab		 jne	 SHORT $LN39@LCS_PortTh

; 2380 : 
; 2381 :         if (iLength == 0)      // (probably EINTR; ignore)

  00787	83 bc 24 88 00
	00 00 00	 cmp	 DWORD PTR iLength$[rsp], 0
  0078f	75 05		 jne	 SHORT $LN84@LCS_PortTh

; 2382 :             continue;

  00791	e9 4e f9 ff ff	 jmp	 $LN5@LCS_PortTh
$LN84@LCS_PortTh:

; 2383 : 
; 2384 :         // Check for other error condition
; 2385 :         if (iLength < 0)

  00796	83 bc 24 88 00
	00 00 00	 cmp	 DWORD PTR iLength$[rsp], 0
  0079e	0f 8d d2 00 00
	00		 jge	 $LN85@LCS_PortTh

; 2386 :         {
; 2387 :             if (pLCSPORT->fd < 0 || pLCSPORT->fCloseInProgress)

  007a4	48 8b 44 24 70	 mov	 rax, QWORD PTR pLCSPORT$[rsp]
  007a9	83 b8 38 01 00
	00 00		 cmp	 DWORD PTR [rax+312], 0
  007b0	7c 15		 jl	 SHORT $LN87@LCS_PortTh
  007b2	48 8b 44 24 70	 mov	 rax, QWORD PTR pLCSPORT$[rsp]
  007b7	8b 80 34 01 00
	00		 mov	 eax, DWORD PTR [rax+308]
  007bd	c1 e8 05	 shr	 eax, 5
  007c0	83 e0 01	 and	 eax, 1
  007c3	85 c0		 test	 eax, eax
  007c5	74 05		 je	 SHORT $LN86@LCS_PortTh
$LN87@LCS_PortTh:

; 2388 :                 break;

  007c7	e9 4b 0f 00 00	 jmp	 $LN6@LCS_PortTh
$LN86@LCS_PortTh:

; 2389 :             // "CTC: lcs interface %s read error from port %2.2X: %s"
; 2390 :             WRMSG( HHC00944, "E", pLCSPORT->szNetIfName, pLCSPORT->bPort, strerror( errno ) );

  007cc	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno
  007d2	8b 08		 mov	 ecx, DWORD PTR [rax]
  007d4	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_strerror
  007da	48 89 84 24 68
	01 00 00	 mov	 QWORD PTR tv397[rsp], rax
  007e2	48 8b 4c 24 70	 mov	 rcx, QWORD PTR pLCSPORT$[rsp]
  007e7	0f b6 09	 movzx	 ecx, BYTE PTR [rcx]
  007ea	89 8c 24 40 01
	00 00		 mov	 DWORD PTR tv402[rsp], ecx
  007f1	48 8b 54 24 70	 mov	 rdx, QWORD PTR pLCSPORT$[rsp]
  007f6	48 81 c2 48 01
	00 00		 add	 rdx, 328		; 00000148H
  007fd	48 89 94 24 70
	01 00 00	 mov	 QWORD PTR tv404[rsp], rdx
  00805	b9 01 00 00 00	 mov	 ecx, 1
  0080a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  00810	48 8b 8c 24 68
	01 00 00	 mov	 rcx, QWORD PTR tv397[rsp]
  00818	48 89 4c 24 48	 mov	 QWORD PTR [rsp+72], rcx
  0081d	8b 8c 24 40 01
	00 00		 mov	 ecx, DWORD PTR tv402[rsp]
  00824	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  00828	48 8b 8c 24 70
	01 00 00	 mov	 rcx, QWORD PTR tv404[rsp]
  00830	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  00835	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG171942
  0083c	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  00841	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG171943
  00848	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  0084d	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00852	41 b9 03 00 00
	00		 mov	 r9d, 3
  00858	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG171944
  0085f	ba 56 09 00 00	 mov	 edx, 2390		; 00000956H
  00864	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG171945
  0086b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 2391 :             break;

  00871	e9 a1 0e 00 00	 jmp	 $LN6@LCS_PortTh
$LN85@LCS_PortTh:

; 2392 :         }
; 2393 : 
; 2394 :         // Point to ethernet frame and determine frame type
; 2395 :         pEthFrame = (PETHFRM)szBuff;

  00876	48 8d 84 24 f0
	01 00 00	 lea	 rax, QWORD PTR szBuff$[rsp]
  0087e	48 89 84 24 c8
	00 00 00	 mov	 QWORD PTR pEthFrame$[rsp], rax

; 2396 : 
; 2397 :         GetFrameInfo( pEthFrame, &cPktType[0], &hwEthernetType, &bHas8022, &bHas8022Snap );

  00886	b8 01 00 00 00	 mov	 eax, 1
  0088b	48 6b c0 00	 imul	 rax, rax, 0
  0088f	48 8d 84 04 88
	01 00 00	 lea	 rax, QWORD PTR cPktType$[rsp+rax]
  00897	48 8d 4c 24 7a	 lea	 rcx, QWORD PTR bHas8022Snap$[rsp]
  0089c	48 89 4c 24 20	 mov	 QWORD PTR [rsp+32], rcx
  008a1	4c 8d 8c 24 a8
	00 00 00	 lea	 r9, QWORD PTR bHas8022$[rsp]
  008a9	4c 8d 84 24 98
	00 00 00	 lea	 r8, QWORD PTR hwEthernetType$[rsp]
  008b1	48 8b d0	 mov	 rdx, rax
  008b4	48 8b 8c 24 c8
	00 00 00	 mov	 rcx, QWORD PTR pEthFrame$[rsp]
  008bc	e8 00 00 00 00	 call	 GetFrameInfo

; 2398 : 
; 2399 :         if (pLCSPORT->pLCSBLK->fDebug)

  008c1	48 8b 44 24 70	 mov	 rax, QWORD PTR pLCSPORT$[rsp]
  008c6	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  008ca	8b 40 18	 mov	 eax, DWORD PTR [rax+24]
  008cd	83 e0 01	 and	 eax, 1
  008d0	85 c0		 test	 eax, eax
  008d2	0f 84 f0 00 00
	00		 je	 $LN88@LCS_PortTh

; 2400 :         {
; 2401 :             // "%1d:%04X %s: port %2.2X: Receive frame of size %d bytes (with %s packet) from device %s"
; 2402 :             WRMSG( HHC00984, "D", SSID_TO_LCSS(pDEVBLK->ssid), pDEVBLK->devnum, pDEVBLK->typname,

  008d8	48 8b 44 24 70	 mov	 rax, QWORD PTR pLCSPORT$[rsp]
  008dd	48 05 48 01 00
	00		 add	 rax, 328		; 00000148H
  008e3	48 89 84 24 78
	01 00 00	 mov	 QWORD PTR tv426[rsp], rax
  008eb	48 8b 4c 24 70	 mov	 rcx, QWORD PTR pLCSPORT$[rsp]
  008f0	0f b6 09	 movzx	 ecx, BYTE PTR [rcx]
  008f3	89 8c 24 44 01
	00 00		 mov	 DWORD PTR tv431[rsp], ecx
  008fa	48 8b 94 24 90
	00 00 00	 mov	 rdx, QWORD PTR pDEVBLK$[rsp]
  00902	0f b7 52 48	 movzx	 edx, WORD PTR [rdx+72]
  00906	89 94 24 48 01
	00 00		 mov	 DWORD PTR tv436[rsp], edx
  0090d	4c 8b 84 24 90
	00 00 00	 mov	 r8, QWORD PTR pDEVBLK$[rsp]
  00915	45 0f b7 40 44	 movzx	 r8d, WORD PTR [r8+68]
  0091a	41 d1 f8	 sar	 r8d, 1
  0091d	44 89 84 24 4c
	01 00 00	 mov	 DWORD PTR tv440[rsp], r8d
  00925	b9 01 00 00 00	 mov	 ecx, 1
  0092a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  00930	48 8b 8c 24 78
	01 00 00	 mov	 rcx, QWORD PTR tv426[rsp]
  00938	48 89 4c 24 68	 mov	 QWORD PTR [rsp+104], rcx
  0093d	48 8d 8c 24 88
	01 00 00	 lea	 rcx, QWORD PTR cPktType$[rsp]
  00945	48 89 4c 24 60	 mov	 QWORD PTR [rsp+96], rcx
  0094a	8b 8c 24 88 00
	00 00		 mov	 ecx, DWORD PTR iLength$[rsp]
  00951	89 4c 24 58	 mov	 DWORD PTR [rsp+88], ecx
  00955	8b 8c 24 44 01
	00 00		 mov	 ecx, DWORD PTR tv431[rsp]
  0095c	89 4c 24 50	 mov	 DWORD PTR [rsp+80], ecx
  00960	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR pDEVBLK$[rsp]
  00968	48 8b 49 50	 mov	 rcx, QWORD PTR [rcx+80]
  0096c	48 89 4c 24 48	 mov	 QWORD PTR [rsp+72], rcx
  00971	8b 8c 24 48 01
	00 00		 mov	 ecx, DWORD PTR tv436[rsp]
  00978	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  0097c	8b 8c 24 4c 01
	00 00		 mov	 ecx, DWORD PTR tv440[rsp]
  00983	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  00987	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG171947
  0098e	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  00993	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG171948
  0099a	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  0099f	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  009a4	41 b9 03 00 00
	00		 mov	 r9d, 3
  009aa	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG171949
  009b1	ba 63 09 00 00	 mov	 edx, 2403		; 00000963H
  009b6	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG171950
  009bd	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 2403 :                                   pLCSPORT->bPort, iLength, cPktType, pLCSPORT->szNetIfName );
; 2404 : //!!            if (pLCSPORT->pLCSBLK->iTraceLen)
; 2405 : //!!            {
; 2406 : //!!                iTraceLen = iLength;
; 2407 : //!!                if (iTraceLen > pLCSPORT->pLCSBLK->iTraceLen)
; 2408 : //!!                {
; 2409 : //!!                    iTraceLen = pLCSPORT->pLCSBLK->iTraceLen;
; 2410 : //!!                    // HHC00980 "%1d:%04X %s: Data of size %d bytes displayed, data of size %d bytes not displayed"
; 2411 : //!!                    WRMSG(HHC00980, "D", SSID_TO_LCSS(pDEVBLK->ssid), pDEVBLK->devnum, pDEVBLK->typname,
; 2412 : //!!                                         iTraceLen, (iLength - iTraceLen) );
; 2413 : //!!                }
; 2414 : //!!                net_data_trace( pDEVBLK, szBuff, iTraceLen, TO_GUEST, 'D', "eth frame", 0 );
; 2415 : //!!            }
; 2416 :             bReported = 0;

  009c3	c6 44 24 78 00	 mov	 BYTE PTR bReported$[rsp], 0
$LN88@LCS_PortTh:

; 2417 :         }
; 2418 : 
; 2419 :         // Perform multicast assist if necessary: discard any multicast
; 2420 :         // packets the guest didn't specifically register. We only need
; 2421 :         // to do this if tuntap said that it was unable to do so for us.
; 2422 : 
; 2423 :         if (1
; 2424 :             && pLCSPORT->fDoMCastAssist                                     // do mcast filtering ourself?
; 2425 :             && pLCSPORT->nMCastCount                                        // we have MACs in our table?
; 2426 :             && memcmp( pEthFrame->bDestMAC, mcast3, sizeof( mcast3 )) == 0  // this is a multicast frame?
; 2427 :             && IsMACTab( pLCSPORT->MCastTab, pEthFrame->bDestMAC ) < 0      // its MAC not in our table?

  009c8	33 c0		 xor	 eax, eax
  009ca	83 f8 01	 cmp	 eax, 1
  009cd	0f 84 e5 00 00
	00		 je	 $LN89@LCS_PortTh
  009d3	48 8b 44 24 70	 mov	 rax, QWORD PTR pLCSPORT$[rsp]
  009d8	8b 80 34 01 00
	00		 mov	 eax, DWORD PTR [rax+308]
  009de	c1 e8 08	 shr	 eax, 8
  009e1	83 e0 01	 and	 eax, 1
  009e4	85 c0		 test	 eax, eax
  009e6	0f 84 cc 00 00
	00		 je	 $LN89@LCS_PortTh
  009ec	48 8b 44 24 70	 mov	 rax, QWORD PTR pLCSPORT$[rsp]
  009f1	0f b6 40 01	 movzx	 eax, BYTE PTR [rax+1]
  009f5	85 c0		 test	 eax, eax
  009f7	0f 84 bb 00 00
	00		 je	 $LN89@LCS_PortTh
  009fd	48 8b 84 24 c8
	00 00 00	 mov	 rax, QWORD PTR pEthFrame$[rsp]
  00a05	41 b8 03 00 00
	00		 mov	 r8d, 3
  00a0b	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:mcast3
  00a12	48 8b c8	 mov	 rcx, rax
  00a15	e8 00 00 00 00	 call	 memcmp
  00a1a	85 c0		 test	 eax, eax
  00a1c	0f 85 96 00 00
	00		 jne	 $LN89@LCS_PortTh
  00a22	48 8b 84 24 c8
	00 00 00	 mov	 rax, QWORD PTR pEthFrame$[rsp]
  00a2a	48 8b 4c 24 70	 mov	 rcx, QWORD PTR pLCSPORT$[rsp]
  00a2f	48 83 c1 18	 add	 rcx, 24
  00a33	48 8b d0	 mov	 rdx, rax
  00a36	e8 00 00 00 00	 call	 IsMACTab
  00a3b	85 c0		 test	 eax, eax
  00a3d	7d 79		 jge	 SHORT $LN89@LCS_PortTh

; 2428 :         )
; 2429 :         {
; 2430 :             if (pLCSPORT->pLCSBLK->fDebug)

  00a3f	48 8b 44 24 70	 mov	 rax, QWORD PTR pLCSPORT$[rsp]
  00a44	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  00a48	8b 40 18	 mov	 eax, DWORD PTR [rax+24]
  00a4b	83 e0 01	 and	 eax, 1
  00a4e	85 c0		 test	 eax, eax
  00a50	74 61		 je	 SHORT $LN90@LCS_PortTh

; 2431 :                 // "CTC: lcs device port %2.2X: MCAST not in table, discarding frame"
; 2432 :                 WRMSG( HHC00945, "D", pLCSPORT->bPort );

  00a52	48 8b 44 24 70	 mov	 rax, QWORD PTR pLCSPORT$[rsp]
  00a57	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  00a5a	89 84 24 50 01
	00 00		 mov	 DWORD PTR tv478[rsp], eax
  00a61	b9 01 00 00 00	 mov	 ecx, 1
  00a66	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  00a6c	8b 8c 24 50 01
	00 00		 mov	 ecx, DWORD PTR tv478[rsp]
  00a73	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  00a77	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG171953
  00a7e	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  00a83	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG171954
  00a8a	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00a8f	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00a94	41 b9 03 00 00
	00		 mov	 r9d, 3
  00a9a	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG171955
  00aa1	ba 80 09 00 00	 mov	 edx, 2432		; 00000980H
  00aa6	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG171956
  00aad	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg
$LN90@LCS_PortTh:

; 2433 :             continue;

  00ab3	e9 2c f6 ff ff	 jmp	 $LN5@LCS_PortTh
$LN89@LCS_PortTh:

; 2434 :         }
; 2435 : 
; 2436 :         // Housekeeping
; 2437 :         pPrimaryLCSDEV   = NULL;

  00ab8	48 c7 84 24 d8
	00 00 00 00 00
	00 00		 mov	 QWORD PTR pPrimaryLCSDEV$[rsp], 0

; 2438 :         pSecondaryLCSDEV = NULL;

  00ac4	48 c7 84 24 e0
	00 00 00 00 00
	00 00		 mov	 QWORD PTR pSecondaryLCSDEV$[rsp], 0

; 2439 :         pMatchingLCSDEV  = NULL;

  00ad0	48 c7 84 24 a0
	00 00 00 00 00
	00 00		 mov	 QWORD PTR pMatchingLCSDEV$[rsp], 0

; 2440 : 
; 2441 :         // Attempt to find the device that this frame belongs to
; 2442 :         for (pLCSDev = pLCSPORT->pLCSBLK->pDevices; pLCSDev; pLCSDev = pLCSDev->pNext)

  00adc	48 8b 44 24 70	 mov	 rax, QWORD PTR pLCSPORT$[rsp]
  00ae1	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  00ae5	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  00ae9	48 89 84 24 80
	00 00 00	 mov	 QWORD PTR pLCSDev$[rsp], rax
  00af1	eb 13		 jmp	 SHORT $LN42@LCS_PortTh
$LN40@LCS_PortTh:
  00af3	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR pLCSDev$[rsp]
  00afb	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00afe	48 89 84 24 80
	00 00 00	 mov	 QWORD PTR pLCSDev$[rsp], rax
$LN42@LCS_PortTh:
  00b06	48 83 bc 24 80
	00 00 00 00	 cmp	 QWORD PTR pLCSDev$[rsp], 0
  00b0f	0f 84 8a 07 00
	00		 je	 $LN41@LCS_PortTh

; 2443 :         {
; 2444 :             // Only process devices that are on this port
; 2445 :             if (pLCSDev->bPort == pLCSPORT->bPort)

  00b15	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR pLCSDev$[rsp]
  00b1d	0f b6 40 23	 movzx	 eax, BYTE PTR [rax+35]
  00b21	48 8b 4c 24 70	 mov	 rcx, QWORD PTR pLCSPORT$[rsp]
  00b26	0f b6 09	 movzx	 ecx, BYTE PTR [rcx]
  00b29	3b c1		 cmp	 eax, ecx
  00b2b	0f 85 69 07 00
	00		 jne	 $LN91@LCS_PortTh

; 2446 :             {
; 2447 :                 // hwEthernetType indicates which protocol is encapsulated in the payload.
; 2448 :                 // bHas8022 indicates whether the payload begins with an 802.2 LLC.
; 2449 :                 // bHas8022Snap indicates whether the payload begins with an 802.2 LLC and SNAP.
; 2450 :                 if (hwEthernetType == ETH_TYPE_IP)

  00b31	0f b7 84 24 98
	00 00 00	 movzx	 eax, WORD PTR hwEthernetType$[rsp]
  00b39	3d 00 08 00 00	 cmp	 eax, 2048		; 00000800H
  00b3e	0f 85 ba 01 00
	00		 jne	 $LN92@LCS_PortTh

; 2451 :                 {
; 2452 :                     if (!bHas8022Snap)

  00b44	0f b6 44 24 7a	 movzx	 eax, BYTE PTR bHas8022Snap$[rsp]
  00b49	85 c0		 test	 eax, eax
  00b4b	75 16		 jne	 SHORT $LN94@LCS_PortTh

; 2453 :                         pIPFrame   = (PIP4FRM)pEthFrame->bData;

  00b4d	48 8b 84 24 c8
	00 00 00	 mov	 rax, QWORD PTR pEthFrame$[rsp]
  00b55	48 83 c0 0e	 add	 rax, 14
  00b59	48 89 84 24 60
	01 00 00	 mov	 QWORD PTR pIPFrame$[rsp], rax
  00b61	eb 16		 jmp	 SHORT $LN95@LCS_PortTh
$LN94@LCS_PortTh:

; 2454 :                     else
; 2455 :                         pIPFrame   = (PIP4FRM)pEthFrame->bData+ETH_LLC_SNAP_SIZE;

  00b63	48 8b 84 24 c8
	00 00 00	 mov	 rax, QWORD PTR pEthFrame$[rsp]
  00b6b	48 05 ae 00 00
	00		 add	 rax, 174		; 000000aeH
  00b71	48 89 84 24 60
	01 00 00	 mov	 QWORD PTR pIPFrame$[rsp], rax
$LN95@LCS_PortTh:

; 2456 :                     lIPAddress = pIPFrame->lDstIP;  // (network byte order)

  00b79	48 8b 84 24 60
	01 00 00	 mov	 rax, QWORD PTR pIPFrame$[rsp]
  00b81	8b 40 10	 mov	 eax, DWORD PTR [rax+16]
  00b84	89 84 24 c0 00
	00 00		 mov	 DWORD PTR lIPAddress$[rsp], eax

; 2457 : 
; 2458 :                     if (pLCSPORT->pLCSBLK->fDebug && !bReported)

  00b8b	48 8b 44 24 70	 mov	 rax, QWORD PTR pLCSPORT$[rsp]
  00b90	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  00b94	8b 40 18	 mov	 eax, DWORD PTR [rax+24]
  00b97	83 e0 01	 and	 eax, 1
  00b9a	85 c0		 test	 eax, eax
  00b9c	0f 84 e8 00 00
	00		 je	 $LN96@LCS_PortTh
  00ba2	0f be 44 24 78	 movsx	 eax, BYTE PTR bReported$[rsp]
  00ba7	85 c0		 test	 eax, eax
  00ba9	0f 85 db 00 00
	00		 jne	 $LN96@LCS_PortTh

; 2459 :                     {
; 2460 :                         union converter { struct { unsigned char a, b, c, d; } b; U32 i; } c;
; 2461 :                         char  str[40];
; 2462 : 
; 2463 :                         c.i = ntohl(lIPAddress);

  00baf	8b 8c 24 c0 00
	00 00		 mov	 ecx, DWORD PTR lIPAddress$[rsp]
  00bb6	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ntohl
  00bbc	89 84 24 b8 00
	00 00		 mov	 DWORD PTR c$1[rsp], eax

; 2464 :                         MSGBUF( str, "%8.08X %d.%d.%d.%d", c.i, c.b.d, c.b.c, c.b.b, c.b.a );

  00bc3	0f b6 84 24 b8
	00 00 00	 movzx	 eax, BYTE PTR c$1[rsp]
  00bcb	0f b6 8c 24 b9
	00 00 00	 movzx	 ecx, BYTE PTR c$1[rsp+1]
  00bd3	0f b6 94 24 ba
	00 00 00	 movzx	 edx, BYTE PTR c$1[rsp+2]
  00bdb	44 0f b6 84 24
	bb 00 00 00	 movzx	 r8d, BYTE PTR c$1[rsp+3]
  00be4	89 44 24 38	 mov	 DWORD PTR [rsp+56], eax
  00be8	89 4c 24 30	 mov	 DWORD PTR [rsp+48], ecx
  00bec	89 54 24 28	 mov	 DWORD PTR [rsp+40], edx
  00bf0	44 89 44 24 20	 mov	 DWORD PTR [rsp+32], r8d
  00bf5	44 8b 8c 24 b8
	00 00 00	 mov	 r9d, DWORD PTR c$1[rsp]
  00bfd	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG171963
  00c04	ba 28 00 00 00	 mov	 edx, 40			; 00000028H
  00c09	48 8d 8c 24 a0
	01 00 00	 lea	 rcx, QWORD PTR str$3[rsp]
  00c11	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_snprintf

; 2465 : 
; 2466 :                         // "CTC: lcs device port %2.2X: IPv4 frame received for %s"
; 2467 :                         WRMSG( HHC00946, "D", pLCSPORT->bPort, str );

  00c17	48 8b 44 24 70	 mov	 rax, QWORD PTR pLCSPORT$[rsp]
  00c1c	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  00c1f	89 84 24 54 01
	00 00		 mov	 DWORD PTR tv528[rsp], eax
  00c26	b9 01 00 00 00	 mov	 ecx, 1
  00c2b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  00c31	48 8d 8c 24 a0
	01 00 00	 lea	 rcx, QWORD PTR str$3[rsp]
  00c39	48 89 4c 24 40	 mov	 QWORD PTR [rsp+64], rcx
  00c3e	8b 8c 24 54 01
	00 00		 mov	 ecx, DWORD PTR tv528[rsp]
  00c45	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  00c49	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG171964
  00c50	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  00c55	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG171965
  00c5c	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00c61	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00c66	41 b9 03 00 00
	00		 mov	 r9d, 3
  00c6c	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG171966
  00c73	ba a3 09 00 00	 mov	 edx, 2467		; 000009a3H
  00c78	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG171967
  00c7f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 2468 :                         bReported = 1;

  00c85	c6 44 24 78 01	 mov	 BYTE PTR bReported$[rsp], 1
$LN96@LCS_PortTh:

; 2469 :                     }
; 2470 : 
; 2471 :                     // If this is an exact match use it
; 2472 :                     // otherwise look for primary and secondary
; 2473 :                     // default devices
; 2474 :                     if (pLCSDev->lIPAddress == lIPAddress)

  00c8a	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR pLCSDev$[rsp]
  00c92	8b 8c 24 c0 00
	00 00		 mov	 ecx, DWORD PTR lIPAddress$[rsp]
  00c99	39 48 2d	 cmp	 DWORD PTR [rax+45], ecx
  00c9c	75 17		 jne	 SHORT $LN97@LCS_PortTh

; 2475 :                     {
; 2476 :                         pMatchingLCSDEV = pLCSDev;

  00c9e	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR pLCSDev$[rsp]
  00ca6	48 89 84 24 a0
	00 00 00	 mov	 QWORD PTR pMatchingLCSDEV$[rsp], rax

; 2477 :                         break;

  00cae	e9 ec 05 00 00	 jmp	 $LN41@LCS_PortTh

; 2478 :                     }

  00cb3	eb 44		 jmp	 SHORT $LN98@LCS_PortTh
$LN97@LCS_PortTh:

; 2479 :                     else if (pLCSDev->bType == LCSDEV_TYPE_PRIMARY)

  00cb5	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR pLCSDev$[rsp]
  00cbd	0f b6 40 24	 movzx	 eax, BYTE PTR [rax+36]
  00cc1	83 f8 01	 cmp	 eax, 1
  00cc4	75 12		 jne	 SHORT $LN99@LCS_PortTh

; 2480 :                         pPrimaryLCSDEV = pLCSDev;

  00cc6	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR pLCSDev$[rsp]
  00cce	48 89 84 24 d8
	00 00 00	 mov	 QWORD PTR pPrimaryLCSDEV$[rsp], rax
  00cd6	eb 21		 jmp	 SHORT $LN100@LCS_PortTh
$LN99@LCS_PortTh:

; 2481 :                     else if (pLCSDev->bType == LCSDEV_TYPE_SECONDARY)

  00cd8	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR pLCSDev$[rsp]
  00ce0	0f b6 40 24	 movzx	 eax, BYTE PTR [rax+36]
  00ce4	83 f8 02	 cmp	 eax, 2
  00ce7	75 10		 jne	 SHORT $LN101@LCS_PortTh

; 2482 :                         pSecondaryLCSDEV = pLCSDev;

  00ce9	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR pLCSDev$[rsp]
  00cf1	48 89 84 24 e0
	00 00 00	 mov	 QWORD PTR pSecondaryLCSDEV$[rsp], rax
$LN101@LCS_PortTh:
$LN100@LCS_PortTh:
$LN98@LCS_PortTh:

; 2483 :                 }

  00cf9	e9 9c 05 00 00	 jmp	 $LN93@LCS_PortTh
$LN92@LCS_PortTh:

; 2484 :                 else if (hwEthernetType == ETH_TYPE_ARP)

  00cfe	0f b7 84 24 98
	00 00 00	 movzx	 eax, WORD PTR hwEthernetType$[rsp]
  00d06	3d 06 08 00 00	 cmp	 eax, 2054		; 00000806H
  00d0b	0f 85 ba 01 00
	00		 jne	 $LN102@LCS_PortTh

; 2485 :                 {
; 2486 :                     if (!bHas8022Snap)

  00d11	0f b6 44 24 7a	 movzx	 eax, BYTE PTR bHas8022Snap$[rsp]
  00d16	85 c0		 test	 eax, eax
  00d18	75 16		 jne	 SHORT $LN104@LCS_PortTh

; 2487 :                         pARPFrame  = (PARPFRM)pEthFrame->bData;

  00d1a	48 8b 84 24 c8
	00 00 00	 mov	 rax, QWORD PTR pEthFrame$[rsp]
  00d22	48 83 c0 0e	 add	 rax, 14
  00d26	48 89 84 24 d0
	00 00 00	 mov	 QWORD PTR pARPFrame$[rsp], rax
  00d2e	eb 16		 jmp	 SHORT $LN105@LCS_PortTh
$LN104@LCS_PortTh:

; 2488 :                     else
; 2489 :                         pARPFrame  = (PARPFRM)pEthFrame->bData+ETH_LLC_SNAP_SIZE;

  00d30	48 8b 84 24 c8
	00 00 00	 mov	 rax, QWORD PTR pEthFrame$[rsp]
  00d38	48 05 ee 00 00
	00		 add	 rax, 238		; 000000eeH
  00d3e	48 89 84 24 d0
	00 00 00	 mov	 QWORD PTR pARPFrame$[rsp], rax
$LN105@LCS_PortTh:

; 2490 :                     lIPAddress = pARPFrame->lTargIPAddr; // (network byte order)

  00d46	48 8b 84 24 d0
	00 00 00	 mov	 rax, QWORD PTR pARPFrame$[rsp]
  00d4e	8b 40 18	 mov	 eax, DWORD PTR [rax+24]
  00d51	89 84 24 c0 00
	00 00		 mov	 DWORD PTR lIPAddress$[rsp], eax

; 2491 : 
; 2492 :                     if (pLCSPORT->pLCSBLK->fDebug && !bReported)

  00d58	48 8b 44 24 70	 mov	 rax, QWORD PTR pLCSPORT$[rsp]
  00d5d	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  00d61	8b 40 18	 mov	 eax, DWORD PTR [rax+24]
  00d64	83 e0 01	 and	 eax, 1
  00d67	85 c0		 test	 eax, eax
  00d69	0f 84 e8 00 00
	00		 je	 $LN106@LCS_PortTh
  00d6f	0f be 44 24 78	 movsx	 eax, BYTE PTR bReported$[rsp]
  00d74	85 c0		 test	 eax, eax
  00d76	0f 85 db 00 00
	00		 jne	 $LN106@LCS_PortTh

; 2493 :                     {
; 2494 :                         union converter { struct { unsigned char a, b, c, d; } b; U32 i; } c;
; 2495 :                         char  str[40];
; 2496 : 
; 2497 :                         c.i = ntohl(lIPAddress);

  00d7c	8b 8c 24 c0 00
	00 00		 mov	 ecx, DWORD PTR lIPAddress$[rsp]
  00d83	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ntohl
  00d89	89 84 24 bc 00
	00 00		 mov	 DWORD PTR c$2[rsp], eax

; 2498 :                         MSGBUF( str, "%8.08X %d.%d.%d.%d", c.i, c.b.d, c.b.c, c.b.b, c.b.a );

  00d90	0f b6 84 24 bc
	00 00 00	 movzx	 eax, BYTE PTR c$2[rsp]
  00d98	0f b6 8c 24 bd
	00 00 00	 movzx	 ecx, BYTE PTR c$2[rsp+1]
  00da0	0f b6 94 24 be
	00 00 00	 movzx	 edx, BYTE PTR c$2[rsp+2]
  00da8	44 0f b6 84 24
	bf 00 00 00	 movzx	 r8d, BYTE PTR c$2[rsp+3]
  00db1	89 44 24 38	 mov	 DWORD PTR [rsp+56], eax
  00db5	89 4c 24 30	 mov	 DWORD PTR [rsp+48], ecx
  00db9	89 54 24 28	 mov	 DWORD PTR [rsp+40], edx
  00dbd	44 89 44 24 20	 mov	 DWORD PTR [rsp+32], r8d
  00dc2	44 8b 8c 24 bc
	00 00 00	 mov	 r9d, DWORD PTR c$2[rsp]
  00dca	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG171978
  00dd1	ba 28 00 00 00	 mov	 edx, 40			; 00000028H
  00dd6	48 8d 8c 24 c8
	01 00 00	 lea	 rcx, QWORD PTR str$4[rsp]
  00dde	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_snprintf

; 2499 : 
; 2500 :                         // "CTC: lcs device port %2.2X: ARP frame received for %s"
; 2501 :                         WRMSG( HHC00947, "D", pLCSPORT->bPort, str );

  00de4	48 8b 44 24 70	 mov	 rax, QWORD PTR pLCSPORT$[rsp]
  00de9	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  00dec	89 84 24 58 01
	00 00		 mov	 DWORD PTR tv609[rsp], eax
  00df3	b9 01 00 00 00	 mov	 ecx, 1
  00df8	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  00dfe	48 8d 8c 24 c8
	01 00 00	 lea	 rcx, QWORD PTR str$4[rsp]
  00e06	48 89 4c 24 40	 mov	 QWORD PTR [rsp+64], rcx
  00e0b	8b 8c 24 58 01
	00 00		 mov	 ecx, DWORD PTR tv609[rsp]
  00e12	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  00e16	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG171979
  00e1d	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  00e22	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG171980
  00e29	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00e2e	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00e33	41 b9 03 00 00
	00		 mov	 r9d, 3
  00e39	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG171981
  00e40	ba c5 09 00 00	 mov	 edx, 2501		; 000009c5H
  00e45	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG171982
  00e4c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 2502 :                         bReported = 1;

  00e52	c6 44 24 78 01	 mov	 BYTE PTR bReported$[rsp], 1
$LN106@LCS_PortTh:

; 2503 :                     }
; 2504 : 
; 2505 :                     // If this is an exact match use it
; 2506 :                     // otherwise look for primary and secondary
; 2507 :                     // default devices
; 2508 :                     if (pLCSDev->lIPAddress == lIPAddress)

  00e57	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR pLCSDev$[rsp]
  00e5f	8b 8c 24 c0 00
	00 00		 mov	 ecx, DWORD PTR lIPAddress$[rsp]
  00e66	39 48 2d	 cmp	 DWORD PTR [rax+45], ecx
  00e69	75 17		 jne	 SHORT $LN107@LCS_PortTh

; 2509 :                     {
; 2510 :                         pMatchingLCSDEV = pLCSDev;

  00e6b	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR pLCSDev$[rsp]
  00e73	48 89 84 24 a0
	00 00 00	 mov	 QWORD PTR pMatchingLCSDEV$[rsp], rax

; 2511 :                         break;

  00e7b	e9 1f 04 00 00	 jmp	 $LN41@LCS_PortTh

; 2512 :                     }

  00e80	eb 44		 jmp	 SHORT $LN108@LCS_PortTh
$LN107@LCS_PortTh:

; 2513 :                     else if (pLCSDev->bType == LCSDEV_TYPE_PRIMARY)

  00e82	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR pLCSDev$[rsp]
  00e8a	0f b6 40 24	 movzx	 eax, BYTE PTR [rax+36]
  00e8e	83 f8 01	 cmp	 eax, 1
  00e91	75 12		 jne	 SHORT $LN109@LCS_PortTh

; 2514 :                         pPrimaryLCSDEV = pLCSDev;

  00e93	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR pLCSDev$[rsp]
  00e9b	48 89 84 24 d8
	00 00 00	 mov	 QWORD PTR pPrimaryLCSDEV$[rsp], rax
  00ea3	eb 21		 jmp	 SHORT $LN110@LCS_PortTh
$LN109@LCS_PortTh:

; 2515 :                     else if (pLCSDev->bType == LCSDEV_TYPE_SECONDARY)

  00ea5	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR pLCSDev$[rsp]
  00ead	0f b6 40 24	 movzx	 eax, BYTE PTR [rax+36]
  00eb1	83 f8 02	 cmp	 eax, 2
  00eb4	75 10		 jne	 SHORT $LN111@LCS_PortTh

; 2516 :                         pSecondaryLCSDEV = pLCSDev;

  00eb6	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR pLCSDev$[rsp]
  00ebe	48 89 84 24 e0
	00 00 00	 mov	 QWORD PTR pSecondaryLCSDEV$[rsp], rax
$LN111@LCS_PortTh:
$LN110@LCS_PortTh:
$LN108@LCS_PortTh:

; 2517 :                 }

  00ec6	e9 cf 03 00 00	 jmp	 $LN103@LCS_PortTh
$LN102@LCS_PortTh:

; 2518 :                 else if (hwEthernetType == ETH_TYPE_RARP)

  00ecb	0f b7 84 24 98
	00 00 00	 movzx	 eax, WORD PTR hwEthernetType$[rsp]
  00ed3	3d 35 80 00 00	 cmp	 eax, 32821		; 00008035H
  00ed8	0f 85 28 02 00
	00		 jne	 $LN112@LCS_PortTh

; 2519 :                 {
; 2520 :                     if (!bHas8022Snap)

  00ede	0f b6 44 24 7a	 movzx	 eax, BYTE PTR bHas8022Snap$[rsp]
  00ee3	85 c0		 test	 eax, eax
  00ee5	75 16		 jne	 SHORT $LN114@LCS_PortTh

; 2521 :                         pARPFrame  = (PARPFRM)pEthFrame->bData;

  00ee7	48 8b 84 24 c8
	00 00 00	 mov	 rax, QWORD PTR pEthFrame$[rsp]
  00eef	48 83 c0 0e	 add	 rax, 14
  00ef3	48 89 84 24 d0
	00 00 00	 mov	 QWORD PTR pARPFrame$[rsp], rax
  00efb	eb 16		 jmp	 SHORT $LN115@LCS_PortTh
$LN114@LCS_PortTh:

; 2522 :                     else
; 2523 :                         pARPFrame  = (PARPFRM)pEthFrame->bData+ETH_LLC_SNAP_SIZE;

  00efd	48 8b 84 24 c8
	00 00 00	 mov	 rax, QWORD PTR pEthFrame$[rsp]
  00f05	48 05 ee 00 00
	00		 add	 rax, 238		; 000000eeH
  00f0b	48 89 84 24 d0
	00 00 00	 mov	 QWORD PTR pARPFrame$[rsp], rax
$LN115@LCS_PortTh:

; 2524 :                     pMAC = pARPFrame->bTargEthAddr;

  00f13	48 8b 84 24 d0
	00 00 00	 mov	 rax, QWORD PTR pARPFrame$[rsp]
  00f1b	48 83 c0 12	 add	 rax, 18
  00f1f	48 89 84 24 b0
	00 00 00	 mov	 QWORD PTR pMAC$[rsp], rax

; 2525 : 
; 2526 :                     if (pLCSPORT->pLCSBLK->fDebug && !bReported)

  00f27	48 8b 44 24 70	 mov	 rax, QWORD PTR pLCSPORT$[rsp]
  00f2c	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  00f30	8b 40 18	 mov	 eax, DWORD PTR [rax+24]
  00f33	83 e0 01	 and	 eax, 1
  00f36	85 c0		 test	 eax, eax
  00f38	0f 84 2e 01 00
	00		 je	 $LN116@LCS_PortTh
  00f3e	0f be 44 24 78	 movsx	 eax, BYTE PTR bReported$[rsp]
  00f43	85 c0		 test	 eax, eax
  00f45	0f 85 21 01 00
	00		 jne	 $LN116@LCS_PortTh

; 2527 :                     {
; 2528 :                         // "CTC: lcs device port %2.2X: RARP frame received for %2.2X:%2.2X:%2.2X:%2.2X:%2.2X:%2.2X"
; 2529 :                         WRMSG( HHC00948, "D" ,pLCSPORT->bPort ,*(pMAC+0) ,*(pMAC+1) ,*(pMAC+2) ,*(pMAC+3) ,*(pMAC+4) ,*(pMAC+5) );

  00f4b	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR pMAC$[rsp]
  00f53	0f b6 40 05	 movzx	 eax, BYTE PTR [rax+5]
  00f57	89 84 24 f0 00
	00 00		 mov	 DWORD PTR tv643[rsp], eax
  00f5e	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR pMAC$[rsp]
  00f66	0f b6 49 04	 movzx	 ecx, BYTE PTR [rcx+4]
  00f6a	89 8c 24 f4 00
	00 00		 mov	 DWORD PTR tv646[rsp], ecx
  00f71	48 8b 94 24 b0
	00 00 00	 mov	 rdx, QWORD PTR pMAC$[rsp]
  00f79	0f b6 52 03	 movzx	 edx, BYTE PTR [rdx+3]
  00f7d	89 94 24 f8 00
	00 00		 mov	 DWORD PTR tv649[rsp], edx
  00f84	4c 8b 84 24 b0
	00 00 00	 mov	 r8, QWORD PTR pMAC$[rsp]
  00f8c	45 0f b6 40 02	 movzx	 r8d, BYTE PTR [r8+2]
  00f91	44 89 84 24 fc
	00 00 00	 mov	 DWORD PTR tv652[rsp], r8d
  00f99	4c 8b 8c 24 b0
	00 00 00	 mov	 r9, QWORD PTR pMAC$[rsp]
  00fa1	45 0f b6 49 01	 movzx	 r9d, BYTE PTR [r9+1]
  00fa6	44 89 8c 24 00
	01 00 00	 mov	 DWORD PTR tv655[rsp], r9d
  00fae	4c 8b 94 24 b0
	00 00 00	 mov	 r10, QWORD PTR pMAC$[rsp]
  00fb6	45 0f b6 12	 movzx	 r10d, BYTE PTR [r10]
  00fba	44 89 94 24 04
	01 00 00	 mov	 DWORD PTR tv657[rsp], r10d
  00fc2	4c 8b 5c 24 70	 mov	 r11, QWORD PTR pLCSPORT$[rsp]
  00fc7	45 0f b6 1b	 movzx	 r11d, BYTE PTR [r11]
  00fcb	44 89 9c 24 08
	01 00 00	 mov	 DWORD PTR tv660[rsp], r11d
  00fd3	b9 01 00 00 00	 mov	 ecx, 1
  00fd8	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  00fde	8b 8c 24 f0 00
	00 00		 mov	 ecx, DWORD PTR tv643[rsp]
  00fe5	89 4c 24 68	 mov	 DWORD PTR [rsp+104], ecx
  00fe9	8b 8c 24 f4 00
	00 00		 mov	 ecx, DWORD PTR tv646[rsp]
  00ff0	89 4c 24 60	 mov	 DWORD PTR [rsp+96], ecx
  00ff4	8b 8c 24 f8 00
	00 00		 mov	 ecx, DWORD PTR tv649[rsp]
  00ffb	89 4c 24 58	 mov	 DWORD PTR [rsp+88], ecx
  00fff	8b 8c 24 fc 00
	00 00		 mov	 ecx, DWORD PTR tv652[rsp]
  01006	89 4c 24 50	 mov	 DWORD PTR [rsp+80], ecx
  0100a	8b 8c 24 00 01
	00 00		 mov	 ecx, DWORD PTR tv655[rsp]
  01011	89 4c 24 48	 mov	 DWORD PTR [rsp+72], ecx
  01015	8b 8c 24 04 01
	00 00		 mov	 ecx, DWORD PTR tv657[rsp]
  0101c	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  01020	8b 8c 24 08 01
	00 00		 mov	 ecx, DWORD PTR tv660[rsp]
  01027	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  0102b	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG171993
  01032	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  01037	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG171994
  0103e	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  01043	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  01048	41 b9 03 00 00
	00		 mov	 r9d, 3
  0104e	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG171995
  01055	ba e1 09 00 00	 mov	 edx, 2529		; 000009e1H
  0105a	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG171996
  01061	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 2530 :                         bReported = 1;

  01067	c6 44 24 78 01	 mov	 BYTE PTR bReported$[rsp], 1
$LN116@LCS_PortTh:

; 2531 :                     }
; 2532 : 
; 2533 :                     // If this is an exact match use it
; 2534 :                     // otherwise look for primary and secondary
; 2535 :                     // default devices
; 2536 :                     memcpy( &mac, pLCSPORT->MAC_Address, IFHWADDRLEN );

  0106c	48 8d 84 24 80
	01 00 00	 lea	 rax, QWORD PTR mac$[rsp]
  01074	48 8b 4c 24 70	 mov	 rcx, QWORD PTR pLCSPORT$[rsp]
  01079	48 8b f8	 mov	 rdi, rax
  0107c	48 8d 71 02	 lea	 rsi, QWORD PTR [rcx+2]
  01080	b9 06 00 00 00	 mov	 ecx, 6
  01085	f3 a4		 rep movsb

; 2537 : #if !defined( OPTION_TUNTAP_LCS_SAME_ADDR )
; 2538 :                     mac[5]++;
; 2539 : #endif
; 2540 :                     if (memcmp( pMAC, &mac, IFHWADDRLEN ) == 0)

  01087	41 b8 06 00 00
	00		 mov	 r8d, 6
  0108d	48 8d 94 24 80
	01 00 00	 lea	 rdx, QWORD PTR mac$[rsp]
  01095	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR pMAC$[rsp]
  0109d	e8 00 00 00 00	 call	 memcmp
  010a2	85 c0		 test	 eax, eax
  010a4	75 17		 jne	 SHORT $LN117@LCS_PortTh

; 2541 :                     {
; 2542 :                         pMatchingLCSDEV = pLCSDev;

  010a6	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR pLCSDev$[rsp]
  010ae	48 89 84 24 a0
	00 00 00	 mov	 QWORD PTR pMatchingLCSDEV$[rsp], rax

; 2543 :                         break;

  010b6	e9 e4 01 00 00	 jmp	 $LN41@LCS_PortTh

; 2544 :                     }

  010bb	eb 44		 jmp	 SHORT $LN118@LCS_PortTh
$LN117@LCS_PortTh:

; 2545 :                     else if (pLCSDev->bType == LCSDEV_TYPE_PRIMARY)

  010bd	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR pLCSDev$[rsp]
  010c5	0f b6 40 24	 movzx	 eax, BYTE PTR [rax+36]
  010c9	83 f8 01	 cmp	 eax, 1
  010cc	75 12		 jne	 SHORT $LN119@LCS_PortTh

; 2546 :                         pPrimaryLCSDEV = pLCSDev;

  010ce	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR pLCSDev$[rsp]
  010d6	48 89 84 24 d8
	00 00 00	 mov	 QWORD PTR pPrimaryLCSDEV$[rsp], rax
  010de	eb 21		 jmp	 SHORT $LN120@LCS_PortTh
$LN119@LCS_PortTh:

; 2547 :                     else if (pLCSDev->bType == LCSDEV_TYPE_SECONDARY)

  010e0	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR pLCSDev$[rsp]
  010e8	0f b6 40 24	 movzx	 eax, BYTE PTR [rax+36]
  010ec	83 f8 02	 cmp	 eax, 2
  010ef	75 10		 jne	 SHORT $LN121@LCS_PortTh

; 2548 :                         pSecondaryLCSDEV = pLCSDev;

  010f1	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR pLCSDev$[rsp]
  010f9	48 89 84 24 e0
	00 00 00	 mov	 QWORD PTR pSecondaryLCSDEV$[rsp], rax
$LN121@LCS_PortTh:
$LN120@LCS_PortTh:
$LN118@LCS_PortTh:

; 2549 :                 }

  01101	e9 94 01 00 00	 jmp	 $LN113@LCS_PortTh
$LN112@LCS_PortTh:

; 2550 :                 else if (hwEthernetType == ETH_TYPE_SNA)

  01106	0f b7 84 24 98
	00 00 00	 movzx	 eax, WORD PTR hwEthernetType$[rsp]
  0110e	3d d5 80 00 00	 cmp	 eax, 32981		; 000080d5H
  01113	0f 85 81 01 00
	00		 jne	 $LN122@LCS_PortTh

; 2551 :                 {
; 2552 :                     pMAC = pEthFrame->bDestMAC;

  01119	48 8b 84 24 c8
	00 00 00	 mov	 rax, QWORD PTR pEthFrame$[rsp]
  01121	48 89 84 24 b0
	00 00 00	 mov	 QWORD PTR pMAC$[rsp], rax

; 2553 : 
; 2554 :                     if (pLCSPORT->pLCSBLK->fDebug && !bReported)

  01129	48 8b 44 24 70	 mov	 rax, QWORD PTR pLCSPORT$[rsp]
  0112e	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  01132	8b 40 18	 mov	 eax, DWORD PTR [rax+24]
  01135	83 e0 01	 and	 eax, 1
  01138	85 c0		 test	 eax, eax
  0113a	0f 84 0e 01 00
	00		 je	 $LN123@LCS_PortTh
  01140	0f be 44 24 78	 movsx	 eax, BYTE PTR bReported$[rsp]
  01145	85 c0		 test	 eax, eax
  01147	0f 85 01 01 00
	00		 jne	 $LN123@LCS_PortTh

; 2555 :                     {
; 2556 :                         // "CTC: lcs device port %2.2X: SNA frame received for %2.2X:%2.2X:%2.2X:%2.2X:%2.2X:%2.2X"
; 2557 :                         WRMSG( HHC00949, "D" ,pLCSPORT->bPort ,*(pMAC+0) ,*(pMAC+1) ,*(pMAC+2) ,*(pMAC+3) ,*(pMAC+4) ,*(pMAC+5) );

  0114d	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR pMAC$[rsp]
  01155	0f b6 40 05	 movzx	 eax, BYTE PTR [rax+5]
  01159	89 84 24 0c 01
	00 00		 mov	 DWORD PTR tv734[rsp], eax
  01160	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR pMAC$[rsp]
  01168	0f b6 49 04	 movzx	 ecx, BYTE PTR [rcx+4]
  0116c	89 8c 24 10 01
	00 00		 mov	 DWORD PTR tv737[rsp], ecx
  01173	48 8b 94 24 b0
	00 00 00	 mov	 rdx, QWORD PTR pMAC$[rsp]
  0117b	0f b6 52 03	 movzx	 edx, BYTE PTR [rdx+3]
  0117f	89 94 24 14 01
	00 00		 mov	 DWORD PTR tv740[rsp], edx
  01186	48 8b bc 24 b0
	00 00 00	 mov	 rdi, QWORD PTR pMAC$[rsp]
  0118e	0f b6 7f 02	 movzx	 edi, BYTE PTR [rdi+2]
  01192	48 8b b4 24 b0
	00 00 00	 mov	 rsi, QWORD PTR pMAC$[rsp]
  0119a	0f b6 76 01	 movzx	 esi, BYTE PTR [rsi+1]
  0119e	4c 8b 84 24 b0
	00 00 00	 mov	 r8, QWORD PTR pMAC$[rsp]
  011a6	45 0f b6 00	 movzx	 r8d, BYTE PTR [r8]
  011aa	44 89 84 24 18
	01 00 00	 mov	 DWORD PTR tv748[rsp], r8d
  011b2	4c 8b 4c 24 70	 mov	 r9, QWORD PTR pLCSPORT$[rsp]
  011b7	45 0f b6 09	 movzx	 r9d, BYTE PTR [r9]
  011bb	44 89 8c 24 1c
	01 00 00	 mov	 DWORD PTR tv751[rsp], r9d
  011c3	b9 01 00 00 00	 mov	 ecx, 1
  011c8	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  011ce	8b 8c 24 0c 01
	00 00		 mov	 ecx, DWORD PTR tv734[rsp]
  011d5	89 4c 24 68	 mov	 DWORD PTR [rsp+104], ecx
  011d9	8b 8c 24 10 01
	00 00		 mov	 ecx, DWORD PTR tv737[rsp]
  011e0	89 4c 24 60	 mov	 DWORD PTR [rsp+96], ecx
  011e4	8b 8c 24 14 01
	00 00		 mov	 ecx, DWORD PTR tv740[rsp]
  011eb	89 4c 24 58	 mov	 DWORD PTR [rsp+88], ecx
  011ef	89 7c 24 50	 mov	 DWORD PTR [rsp+80], edi
  011f3	89 74 24 48	 mov	 DWORD PTR [rsp+72], esi
  011f7	8b 8c 24 18 01
	00 00		 mov	 ecx, DWORD PTR tv748[rsp]
  011fe	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  01202	8b 8c 24 1c 01
	00 00		 mov	 ecx, DWORD PTR tv751[rsp]
  01209	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  0120d	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG172004
  01214	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  01219	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG172005
  01220	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  01225	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  0122a	41 b9 03 00 00
	00		 mov	 r9d, 3
  01230	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG172006
  01237	ba fd 09 00 00	 mov	 edx, 2557		; 000009fdH
  0123c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG172007
  01243	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 2558 :                         bReported = 1;

  01249	c6 44 24 78 01	 mov	 BYTE PTR bReported$[rsp], 1
$LN123@LCS_PortTh:

; 2559 :                     }
; 2560 : 
; 2561 :                     // If this is an exact match use it
; 2562 :                     // Primary and secondary default devicea are IP only
; 2563 :                     memcpy( &mac, pLCSPORT->MAC_Address, IFHWADDRLEN );

  0124e	48 8d 84 24 80
	01 00 00	 lea	 rax, QWORD PTR mac$[rsp]
  01256	48 8b 4c 24 70	 mov	 rcx, QWORD PTR pLCSPORT$[rsp]
  0125b	48 8b f8	 mov	 rdi, rax
  0125e	48 8d 71 02	 lea	 rsi, QWORD PTR [rcx+2]
  01262	b9 06 00 00 00	 mov	 ecx, 6
  01267	f3 a4		 rep movsb

; 2564 : #if !defined( OPTION_TUNTAP_LCS_SAME_ADDR )
; 2565 :                     mac[5]++;
; 2566 : #endif
; 2567 :                     if (memcmp( pMAC, &mac, IFHWADDRLEN ) == 0)

  01269	41 b8 06 00 00
	00		 mov	 r8d, 6
  0126f	48 8d 94 24 80
	01 00 00	 lea	 rdx, QWORD PTR mac$[rsp]
  01277	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR pMAC$[rsp]
  0127f	e8 00 00 00 00	 call	 memcmp
  01284	85 c0		 test	 eax, eax
  01286	75 12		 jne	 SHORT $LN124@LCS_PortTh

; 2568 :                     {
; 2569 :                         pMatchingLCSDEV = pLCSDev;

  01288	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR pLCSDev$[rsp]
  01290	48 89 84 24 a0
	00 00 00	 mov	 QWORD PTR pMatchingLCSDEV$[rsp], rax

; 2570 :                         break;

  01298	eb 05		 jmp	 SHORT $LN41@LCS_PortTh
$LN124@LCS_PortTh:
$LN122@LCS_PortTh:
$LN113@LCS_PortTh:
$LN103@LCS_PortTh:
$LN93@LCS_PortTh:
$LN91@LCS_PortTh:

; 2571 :                     }
; 2572 :                 }
; 2573 :             }
; 2574 :         }

  0129a	e9 54 f8 ff ff	 jmp	 $LN40@LCS_PortTh
$LN41@LCS_PortTh:

; 2575 : 
; 2576 :         // If the matching device is not started
; 2577 :         // nullify the pointer and pass frame to one
; 2578 :         // of the defaults if present
; 2579 :         if (pMatchingLCSDEV && !pMatchingLCSDEV->fDevStarted)

  0129f	48 83 bc 24 a0
	00 00 00 00	 cmp	 QWORD PTR pMatchingLCSDEV$[rsp], 0
  012a8	74 20		 je	 SHORT $LN125@LCS_PortTh
  012aa	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR pMatchingLCSDEV$[rsp]
  012b2	8b 40 41	 mov	 eax, DWORD PTR [rax+65]
  012b5	d1 e8		 shr	 eax, 1
  012b7	83 e0 01	 and	 eax, 1
  012ba	85 c0		 test	 eax, eax
  012bc	75 0c		 jne	 SHORT $LN125@LCS_PortTh

; 2580 :             pMatchingLCSDEV = NULL;

  012be	48 c7 84 24 a0
	00 00 00 00 00
	00 00		 mov	 QWORD PTR pMatchingLCSDEV$[rsp], 0
$LN125@LCS_PortTh:

; 2581 : 
; 2582 :         // Match not found, check for default devices
; 2583 :         // If one is defined and started, use it
; 2584 :         if (!pMatchingLCSDEV)

  012ca	48 83 bc 24 a0
	00 00 00 00	 cmp	 QWORD PTR pMatchingLCSDEV$[rsp], 0
  012d3	75 60		 jne	 SHORT $LN126@LCS_PortTh

; 2585 :         {
; 2586 :             if (pPrimaryLCSDEV && pPrimaryLCSDEV->fDevStarted)

  012d5	48 83 bc 24 d8
	00 00 00 00	 cmp	 QWORD PTR pPrimaryLCSDEV$[rsp], 0
  012de	74 26		 je	 SHORT $LN127@LCS_PortTh
  012e0	48 8b 84 24 d8
	00 00 00	 mov	 rax, QWORD PTR pPrimaryLCSDEV$[rsp]
  012e8	8b 40 41	 mov	 eax, DWORD PTR [rax+65]
  012eb	d1 e8		 shr	 eax, 1
  012ed	83 e0 01	 and	 eax, 1
  012f0	85 c0		 test	 eax, eax
  012f2	74 12		 je	 SHORT $LN127@LCS_PortTh

; 2587 :             {
; 2588 :                 pMatchingLCSDEV = pPrimaryLCSDEV;

  012f4	48 8b 84 24 d8
	00 00 00	 mov	 rax, QWORD PTR pPrimaryLCSDEV$[rsp]
  012fc	48 89 84 24 a0
	00 00 00	 mov	 QWORD PTR pMatchingLCSDEV$[rsp], rax

; 2589 : 
; 2590 : #ifndef LCS_NO_950_952 // (HHC00950 and HHC00952 are rarely interesting)
; 2591 :                 if (pLCSPORT->pLCSBLK->fDebug)
; 2592 :                     // "CTC: lcs device port %2.2X: no match found, selecting %s %4.4X"
; 2593 :                     WRMSG( HHC00950, "D", pLCSPORT->bPort, "primary", pMatchingLCSDEV->sAddr );
; 2594 : #endif // LCS_NO_950_952
; 2595 :             }

  01304	eb 2f		 jmp	 SHORT $LN128@LCS_PortTh
$LN127@LCS_PortTh:

; 2596 :             else if (pSecondaryLCSDEV && pSecondaryLCSDEV->fDevStarted)

  01306	48 83 bc 24 e0
	00 00 00 00	 cmp	 QWORD PTR pSecondaryLCSDEV$[rsp], 0
  0130f	74 24		 je	 SHORT $LN129@LCS_PortTh
  01311	48 8b 84 24 e0
	00 00 00	 mov	 rax, QWORD PTR pSecondaryLCSDEV$[rsp]
  01319	8b 40 41	 mov	 eax, DWORD PTR [rax+65]
  0131c	d1 e8		 shr	 eax, 1
  0131e	83 e0 01	 and	 eax, 1
  01321	85 c0		 test	 eax, eax
  01323	74 10		 je	 SHORT $LN129@LCS_PortTh

; 2597 :             {
; 2598 :                 pMatchingLCSDEV = pSecondaryLCSDEV;

  01325	48 8b 84 24 e0
	00 00 00	 mov	 rax, QWORD PTR pSecondaryLCSDEV$[rsp]
  0132d	48 89 84 24 a0
	00 00 00	 mov	 QWORD PTR pMatchingLCSDEV$[rsp], rax
$LN129@LCS_PortTh:
$LN128@LCS_PortTh:
$LN126@LCS_PortTh:

; 2599 : 
; 2600 : #ifndef LCS_NO_950_952 // (HHC00950 and HHC00952 are rarely interesting)
; 2601 :                 if (pLCSPORT->pLCSBLK->fDebug)
; 2602 :                     // "CTC: lcs device port %2.2X: no match found, selecting %s %4.4X"
; 2603 :                     WRMSG( HHC00950, "D", pLCSPORT->bPort, "secondary", pMatchingLCSDEV->sAddr );
; 2604 : #endif // LCS_NO_950_952
; 2605 :             }
; 2606 :         }
; 2607 : 
; 2608 :         // Discard frame if no matching device was found.
; 2609 :         if (!pMatchingLCSDEV)

  01335	48 83 bc 24 a0
	00 00 00 00	 cmp	 QWORD PTR pMatchingLCSDEV$[rsp], 0
  0133e	0f 85 ef 00 00
	00		 jne	 $LN130@LCS_PortTh

; 2610 :         {
; 2611 :             if (pLCSPORT->pLCSBLK->fDebug)

  01344	48 8b 44 24 70	 mov	 rax, QWORD PTR pLCSPORT$[rsp]
  01349	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  0134d	8b 40 18	 mov	 eax, DWORD PTR [rax+24]
  01350	83 e0 01	 and	 eax, 1
  01353	85 c0		 test	 eax, eax
  01355	0f 84 d3 00 00
	00		 je	 $LN131@LCS_PortTh

; 2612 :             {
; 2613 :                 // "CTC: lcs device port %2.2X: no match found, discarding frame"
; 2614 :                 WRMSG( HHC00951, "D", pLCSPORT->bPort );

  0135b	48 8b 44 24 70	 mov	 rax, QWORD PTR pLCSPORT$[rsp]
  01360	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  01363	89 84 24 20 01
	00 00		 mov	 DWORD PTR tv799[rsp], eax
  0136a	b9 01 00 00 00	 mov	 ecx, 1
  0136f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  01375	8b 8c 24 20 01
	00 00		 mov	 ecx, DWORD PTR tv799[rsp]
  0137c	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  01380	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG172016
  01387	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  0138c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG172017
  01393	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  01398	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  0139d	41 b9 03 00 00
	00		 mov	 r9d, 3
  013a3	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG172018
  013aa	ba 36 0a 00 00	 mov	 edx, 2614		; 00000a36H
  013af	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG172019
  013b6	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 2615 :                 if (pLCSPORT->pLCSBLK->iDiscTrace)

  013bc	48 8b 44 24 70	 mov	 rax, QWORD PTR pLCSPORT$[rsp]
  013c1	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  013c5	83 78 2c 00	 cmp	 DWORD PTR [rax+44], 0
  013c9	74 63		 je	 SHORT $LN132@LCS_PortTh

; 2616 :                 {
; 2617 :                     iTraceLen = iLength;

  013cb	8b 84 24 88 00
	00 00		 mov	 eax, DWORD PTR iLength$[rsp]
  013d2	89 44 24 7c	 mov	 DWORD PTR iTraceLen$[rsp], eax

; 2618 :                     if (iTraceLen > pLCSPORT->pLCSBLK->iDiscTrace)

  013d6	48 8b 44 24 70	 mov	 rax, QWORD PTR pLCSPORT$[rsp]
  013db	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  013df	8b 40 2c	 mov	 eax, DWORD PTR [rax+44]
  013e2	39 44 24 7c	 cmp	 DWORD PTR iTraceLen$[rsp], eax
  013e6	7e 10		 jle	 SHORT $LN133@LCS_PortTh

; 2619 :                     {
; 2620 :                         iTraceLen = pLCSPORT->pLCSBLK->iDiscTrace;

  013e8	48 8b 44 24 70	 mov	 rax, QWORD PTR pLCSPORT$[rsp]
  013ed	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  013f1	8b 40 2c	 mov	 eax, DWORD PTR [rax+44]
  013f4	89 44 24 7c	 mov	 DWORD PTR iTraceLen$[rsp], eax
$LN133@LCS_PortTh:

; 2621 :                     }
; 2622 :                     net_data_trace( pDEVBLK, szBuff, iTraceLen, NO_DIRECTION, 'D', "discarding", 0 );

  013f8	c7 44 24 30 00
	00 00 00	 mov	 DWORD PTR [rsp+48], 0
  01400	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG172022
  01407	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  0140c	c6 44 24 20 44	 mov	 BYTE PTR [rsp+32], 68	; 00000044H
  01411	41 b1 20	 mov	 r9b, 32			; 00000020H
  01414	44 8b 44 24 7c	 mov	 r8d, DWORD PTR iTraceLen$[rsp]
  01419	48 8d 94 24 f0
	01 00 00	 lea	 rdx, QWORD PTR szBuff$[rsp]
  01421	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR pDEVBLK$[rsp]
  01429	e8 00 00 00 00	 call	 net_data_trace
$LN132@LCS_PortTh:
$LN131@LCS_PortTh:

; 2623 :                 }
; 2624 :             }
; 2625 :             continue;

  0142e	e9 b1 ec ff ff	 jmp	 $LN5@LCS_PortTh
$LN130@LCS_PortTh:

; 2626 :         }
; 2627 : 
; 2628 :         // Discard frame if the SNA device isn't receiving frames, or
; 2629 :         // the frames payload does not begin with an 802.2 LLC, or
; 2630 :         // the frames payload begins with an 802.2 LLC and SNAP.
; 2631 :         if (pMatchingLCSDEV->bMode == LCSDEV_MODE_SNA)

  01433	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR pMatchingLCSDEV$[rsp]
  0143b	0f b6 40 22	 movzx	 eax, BYTE PTR [rax+34]
  0143f	83 f8 02	 cmp	 eax, 2
  01442	0f 85 1d 01 00
	00		 jne	 $LN134@LCS_PortTh

; 2632 :         {
; 2633 :             if (!pMatchingLCSDEV->fReceiveFrames || !bHas8022 || bHas8022Snap )

  01448	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR pMatchingLCSDEV$[rsp]
  01450	8b 40 5d	 mov	 eax, DWORD PTR [rax+93]
  01453	c1 e8 03	 shr	 eax, 3
  01456	83 e0 01	 and	 eax, 1
  01459	85 c0		 test	 eax, eax
  0145b	74 19		 je	 SHORT $LN136@LCS_PortTh
  0145d	0f b6 84 24 a8
	00 00 00	 movzx	 eax, BYTE PTR bHas8022$[rsp]
  01465	85 c0		 test	 eax, eax
  01467	74 0d		 je	 SHORT $LN136@LCS_PortTh
  01469	0f b6 44 24 7a	 movzx	 eax, BYTE PTR bHas8022Snap$[rsp]
  0146e	85 c0		 test	 eax, eax
  01470	0f 84 ef 00 00
	00		 je	 $LN135@LCS_PortTh
$LN136@LCS_PortTh:

; 2634 :             {
; 2635 :                 if (pLCSPORT->pLCSBLK->fDebug)

  01476	48 8b 44 24 70	 mov	 rax, QWORD PTR pLCSPORT$[rsp]
  0147b	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  0147f	8b 40 18	 mov	 eax, DWORD PTR [rax+24]
  01482	83 e0 01	 and	 eax, 1
  01485	85 c0		 test	 eax, eax
  01487	0f 84 d3 00 00
	00		 je	 $LN137@LCS_PortTh

; 2636 :                 {
; 2637 :                     // "CTC: lcs device port %2.2X: no match found, discarding frame"
; 2638 :                     WRMSG( HHC00951, "D", pLCSPORT->bPort );

  0148d	48 8b 44 24 70	 mov	 rax, QWORD PTR pLCSPORT$[rsp]
  01492	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  01495	89 84 24 24 01
	00 00		 mov	 DWORD PTR tv841[rsp], eax
  0149c	b9 01 00 00 00	 mov	 ecx, 1
  014a1	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  014a7	8b 8c 24 24 01
	00 00		 mov	 ecx, DWORD PTR tv841[rsp]
  014ae	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  014b2	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG172027
  014b9	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  014be	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG172028
  014c5	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  014ca	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  014cf	41 b9 03 00 00
	00		 mov	 r9d, 3
  014d5	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG172029
  014dc	ba 4e 0a 00 00	 mov	 edx, 2638		; 00000a4eH
  014e1	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG172030
  014e8	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 2639 :                     if (pLCSPORT->pLCSBLK->iDiscTrace)

  014ee	48 8b 44 24 70	 mov	 rax, QWORD PTR pLCSPORT$[rsp]
  014f3	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  014f7	83 78 2c 00	 cmp	 DWORD PTR [rax+44], 0
  014fb	74 63		 je	 SHORT $LN138@LCS_PortTh

; 2640 :                     {
; 2641 :                         iTraceLen = iLength;

  014fd	8b 84 24 88 00
	00 00		 mov	 eax, DWORD PTR iLength$[rsp]
  01504	89 44 24 7c	 mov	 DWORD PTR iTraceLen$[rsp], eax

; 2642 :                         if (iTraceLen > pLCSPORT->pLCSBLK->iDiscTrace)

  01508	48 8b 44 24 70	 mov	 rax, QWORD PTR pLCSPORT$[rsp]
  0150d	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  01511	8b 40 2c	 mov	 eax, DWORD PTR [rax+44]
  01514	39 44 24 7c	 cmp	 DWORD PTR iTraceLen$[rsp], eax
  01518	7e 10		 jle	 SHORT $LN139@LCS_PortTh

; 2643 :                         {
; 2644 :                             iTraceLen = pLCSPORT->pLCSBLK->iDiscTrace;

  0151a	48 8b 44 24 70	 mov	 rax, QWORD PTR pLCSPORT$[rsp]
  0151f	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  01523	8b 40 2c	 mov	 eax, DWORD PTR [rax+44]
  01526	89 44 24 7c	 mov	 DWORD PTR iTraceLen$[rsp], eax
$LN139@LCS_PortTh:

; 2645 :                         }
; 2646 :                         net_data_trace( pDEVBLK, szBuff, iTraceLen, NO_DIRECTION, 'D', "discarding", 0 );

  0152a	c7 44 24 30 00
	00 00 00	 mov	 DWORD PTR [rsp+48], 0
  01532	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG172033
  01539	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  0153e	c6 44 24 20 44	 mov	 BYTE PTR [rsp+32], 68	; 00000044H
  01543	41 b1 20	 mov	 r9b, 32			; 00000020H
  01546	44 8b 44 24 7c	 mov	 r8d, DWORD PTR iTraceLen$[rsp]
  0154b	48 8d 94 24 f0
	01 00 00	 lea	 rdx, QWORD PTR szBuff$[rsp]
  01553	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR pDEVBLK$[rsp]
  0155b	e8 00 00 00 00	 call	 net_data_trace
$LN138@LCS_PortTh:
$LN137@LCS_PortTh:

; 2647 :                     }
; 2648 :                 }
; 2649 :                 continue;

  01560	e9 7f eb ff ff	 jmp	 $LN5@LCS_PortTh
$LN135@LCS_PortTh:
$LN134@LCS_PortTh:

; 2650 :             }
; 2651 :         }
; 2652 : 
; 2653 : #ifndef LCS_NO_950_952 // (HHC00950 and HHC00952 are rarely interesting)
; 2654 :         if (pLCSPORT->pLCSBLK->fDebug)
; 2655 :         {
; 2656 :             union converter { struct { unsigned char a, b, c, d; } b; U32 i; } c;
; 2657 :             char  str[40];
; 2658 : 
; 2659 :             c.i = ntohl(pMatchingLCSDEV->lIPAddress);
; 2660 :             MSGBUF( str, "%8.08X %d.%d.%d.%d", c.i, c.b.d, c.b.c, c.b.b, c.b.a );
; 2661 : 
; 2662 :             // "CTC: lcs device port %2.2X: enqueing frame to device %4.4X %s"
; 2663 :             WRMSG( HHC00952, "D", pLCSPORT->bPort, pMatchingLCSDEV->sAddr, str );
; 2664 :         }
; 2665 : #endif // LCS_NO_950_952
; 2666 : 
; 2667 :         if (pLCSPORT->pLCSBLK->fDebug)

  01565	48 8b 44 24 70	 mov	 rax, QWORD PTR pLCSPORT$[rsp]
  0156a	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  0156e	8b 40 18	 mov	 eax, DWORD PTR [rax+24]
  01571	83 e0 01	 and	 eax, 1
  01574	85 c0		 test	 eax, eax
  01576	0f 84 39 01 00
	00		 je	 $LN140@LCS_PortTh

; 2668 :         {
; 2669 :             if (pLCSPORT->pLCSBLK->iTraceLen)

  0157c	48 8b 44 24 70	 mov	 rax, QWORD PTR pLCSPORT$[rsp]
  01581	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  01585	83 78 28 00	 cmp	 DWORD PTR [rax+40], 0
  01589	0f 84 26 01 00
	00		 je	 $LN141@LCS_PortTh

; 2670 :             {
; 2671 :                 iTraceLen = iLength;

  0158f	8b 84 24 88 00
	00 00		 mov	 eax, DWORD PTR iLength$[rsp]
  01596	89 44 24 7c	 mov	 DWORD PTR iTraceLen$[rsp], eax

; 2672 :                 if (iTraceLen > pLCSPORT->pLCSBLK->iTraceLen)

  0159a	48 8b 44 24 70	 mov	 rax, QWORD PTR pLCSPORT$[rsp]
  0159f	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  015a3	8b 40 28	 mov	 eax, DWORD PTR [rax+40]
  015a6	39 44 24 7c	 cmp	 DWORD PTR iTraceLen$[rsp], eax
  015aa	0f 8e cf 00 00
	00		 jle	 $LN142@LCS_PortTh

; 2673 :                 {
; 2674 :                     iTraceLen = pLCSPORT->pLCSBLK->iTraceLen;

  015b0	48 8b 44 24 70	 mov	 rax, QWORD PTR pLCSPORT$[rsp]
  015b5	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  015b9	8b 40 28	 mov	 eax, DWORD PTR [rax+40]
  015bc	89 44 24 7c	 mov	 DWORD PTR iTraceLen$[rsp], eax

; 2675 :                     // HHC00980 "%1d:%04X %s: Data of size %d bytes displayed, data of size %d bytes not displayed"
; 2676 :                     WRMSG(HHC00980, "D", SSID_TO_LCSS(pDEVBLK->ssid), pDEVBLK->devnum, pDEVBLK->typname,

  015c0	8b 44 24 7c	 mov	 eax, DWORD PTR iTraceLen$[rsp]
  015c4	8b 8c 24 88 00
	00 00		 mov	 ecx, DWORD PTR iLength$[rsp]
  015cb	2b c8		 sub	 ecx, eax
  015cd	8b c1		 mov	 eax, ecx
  015cf	89 84 24 28 01
	00 00		 mov	 DWORD PTR tv879[rsp], eax
  015d6	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR pDEVBLK$[rsp]
  015de	0f b7 49 48	 movzx	 ecx, WORD PTR [rcx+72]
  015e2	89 8c 24 2c 01
	00 00		 mov	 DWORD PTR tv885[rsp], ecx
  015e9	48 8b 94 24 90
	00 00 00	 mov	 rdx, QWORD PTR pDEVBLK$[rsp]
  015f1	0f b7 52 44	 movzx	 edx, WORD PTR [rdx+68]
  015f5	d1 fa		 sar	 edx, 1
  015f7	89 94 24 30 01
	00 00		 mov	 DWORD PTR tv889[rsp], edx
  015fe	b9 01 00 00 00	 mov	 ecx, 1
  01603	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  01609	8b 8c 24 28 01
	00 00		 mov	 ecx, DWORD PTR tv879[rsp]
  01610	89 4c 24 58	 mov	 DWORD PTR [rsp+88], ecx
  01614	8b 4c 24 7c	 mov	 ecx, DWORD PTR iTraceLen$[rsp]
  01618	89 4c 24 50	 mov	 DWORD PTR [rsp+80], ecx
  0161c	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR pDEVBLK$[rsp]
  01624	48 8b 49 50	 mov	 rcx, QWORD PTR [rcx+80]
  01628	48 89 4c 24 48	 mov	 QWORD PTR [rsp+72], rcx
  0162d	8b 8c 24 2c 01
	00 00		 mov	 ecx, DWORD PTR tv885[rsp]
  01634	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  01638	8b 8c 24 30 01
	00 00		 mov	 ecx, DWORD PTR tv889[rsp]
  0163f	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  01643	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG172037
  0164a	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  0164f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG172038
  01656	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  0165b	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  01660	41 b9 03 00 00
	00		 mov	 r9d, 3
  01666	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG172039
  0166d	ba 75 0a 00 00	 mov	 edx, 2677		; 00000a75H
  01672	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG172040
  01679	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg
$LN142@LCS_PortTh:

; 2677 :                                          iTraceLen, (iLength - iTraceLen) );
; 2678 :                 }
; 2679 :                 net_data_trace( pDEVBLK, szBuff, iTraceLen, TO_GUEST, 'D', "eth frame", 0 );

  0167f	c7 44 24 30 00
	00 00 00	 mov	 DWORD PTR [rsp+48], 0
  01687	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG172041
  0168e	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  01693	c6 44 24 20 44	 mov	 BYTE PTR [rsp+32], 68	; 00000044H
  01698	41 b1 3e	 mov	 r9b, 62			; 0000003eH
  0169b	44 8b 44 24 7c	 mov	 r8d, DWORD PTR iTraceLen$[rsp]
  016a0	48 8d 94 24 f0
	01 00 00	 lea	 rdx, QWORD PTR szBuff$[rsp]
  016a8	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR pDEVBLK$[rsp]
  016b0	e8 00 00 00 00	 call	 net_data_trace
$LN141@LCS_PortTh:
$LN140@LCS_PortTh:

; 2680 :             }
; 2681 :         }
; 2682 : 
; 2683 :         // Match was found. Enqueue frame on buffer.
; 2684 : 
; 2685 :         if (pMatchingLCSDEV->bMode == LCSDEV_MODE_IP)

  016b5	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR pMatchingLCSDEV$[rsp]
  016bd	0f b6 40 22	 movzx	 eax, BYTE PTR [rax+34]
  016c1	83 f8 01	 cmp	 eax, 1
  016c4	75 27		 jne	 SHORT $LN143@LCS_PortTh

; 2686 :         {
; 2687 :             LCS_EnqueueEthFrame( pLCSPORT, pMatchingLCSDEV, szBuff, iLength );

  016c6	48 63 84 24 88
	00 00 00	 movsxd	 rax, DWORD PTR iLength$[rsp]
  016ce	4c 8b c8	 mov	 r9, rax
  016d1	4c 8d 84 24 f0
	01 00 00	 lea	 r8, QWORD PTR szBuff$[rsp]
  016d9	48 8b 94 24 a0
	00 00 00	 mov	 rdx, QWORD PTR pMatchingLCSDEV$[rsp]
  016e1	48 8b 4c 24 70	 mov	 rcx, QWORD PTR pLCSPORT$[rsp]
  016e6	e8 00 00 00 00	 call	 LCS_EnqueueEthFrame

; 2688 :         }

  016eb	eb 25		 jmp	 SHORT $LN144@LCS_PortTh
$LN143@LCS_PortTh:

; 2689 :         else  //  (pMatchingLCSDEV->bMode == LCSDEV_MODE_SNA)
; 2690 :         {
; 2691 :             LCS_ProcessAccepted_SNA ( pLCSPORT, pMatchingLCSDEV, szBuff, iLength );

  016ed	48 63 84 24 88
	00 00 00	 movsxd	 rax, DWORD PTR iLength$[rsp]
  016f5	4c 8b c8	 mov	 r9, rax
  016f8	4c 8d 84 24 f0
	01 00 00	 lea	 r8, QWORD PTR szBuff$[rsp]
  01700	48 8b 94 24 a0
	00 00 00	 mov	 rdx, QWORD PTR pMatchingLCSDEV$[rsp]
  01708	48 8b 4c 24 70	 mov	 rcx, QWORD PTR pLCSPORT$[rsp]
  0170d	e8 00 00 00 00	 call	 LCS_ProcessAccepted_SNA
$LN144@LCS_PortTh:

; 2692 :         }
; 2693 : 
; 2694 :     } // end for (;;)

  01712	e9 cd e9 ff ff	 jmp	 $LN5@LCS_PortTh
$LN6@LCS_PortTh:
$LN45@LCS_PortTh:

; 2695 : 
; 2696 :     PTT_DEBUG( "PORTHRD Closing...", pLCSPORT->fPortStarted, pDEVBLK->devnum, pLCSPORT->bPort );

  01717	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_pttclass
  0171e	48 8b 00	 mov	 rax, QWORD PTR [rax]
  01721	48 25 00 00 02
	00		 and	 rax, 131072		; 00020000H
  01727	48 85 c0	 test	 rax, rax
  0172a	74 59		 je	 SHORT $LN145@LCS_PortTh
  0172c	48 8b 44 24 70	 mov	 rax, QWORD PTR pLCSPORT$[rsp]
  01731	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  01734	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR pDEVBLK$[rsp]
  0173c	0f b7 49 48	 movzx	 ecx, WORD PTR [rcx+72]
  01740	48 8b 54 24 70	 mov	 rdx, QWORD PTR pLCSPORT$[rsp]
  01745	8b 92 34 01 00
	00		 mov	 edx, DWORD PTR [rdx+308]
  0174b	c1 ea 03	 shr	 edx, 3
  0174e	83 e2 01	 and	 edx, 1
  01751	8b d2		 mov	 edx, edx
  01753	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR [rsp+48], 0
  0175c	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  01761	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG172045
  01768	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  0176d	44 8b c9	 mov	 r9d, ecx
  01770	44 8b c2	 mov	 r8d, edx
  01773	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG172046
  0177a	b9 00 00 02 00	 mov	 ecx, 131072		; 00020000H
  0177f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ptt_pthread_trace
$LN145@LCS_PortTh:
  01785	33 c0		 xor	 eax, eax
  01787	85 c0		 test	 eax, eax
  01789	75 8c		 jne	 SHORT $LN45@LCS_PortTh
$LN48@LCS_PortTh:

; 2697 : 
; 2698 :     // We must do the close since we were the one doing the i/o...
; 2699 : 
; 2700 :     VERIFY( pLCSPORT->fd == -1 || TUNTAP_Close( pLCSPORT->fd ) == 0 );

  0178b	48 8b 44 24 70	 mov	 rax, QWORD PTR pLCSPORT$[rsp]
  01790	83 b8 38 01 00
	00 ff		 cmp	 DWORD PTR [rax+312], -1
  01797	74 70		 je	 SHORT $LN146@LCS_PortTh
  01799	48 8b 44 24 70	 mov	 rax, QWORD PTR pLCSPORT$[rsp]
  0179e	8b 88 38 01 00
	00		 mov	 ecx, DWORD PTR [rax+312]
  017a4	e8 00 00 00 00	 call	 tt32_close
  017a9	85 c0		 test	 eax, eax
  017ab	74 5c		 je	 SHORT $LN146@LCS_PortTh
$LN51@LCS_PortTh:
  017ad	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG172048
  017b4	41 b8 8c 0a 00
	00		 mov	 r8d, 2700		; 00000a8cH
  017ba	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG172049
  017c1	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG172050
  017c8	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_logmsg
  017ce	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_IsDebuggerPresent
  017d4	85 c0		 test	 eax, eax
  017d6	74 20		 je	 SHORT $LN147@LCS_PortTh
  017d8	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG172052
  017df	41 b8 8c 0a 00
	00		 mov	 r8d, 2700		; 00000a8cH
  017e5	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG172053
  017ec	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG172054
  017f3	e8 00 00 00 00	 call	 DebuggerTrace
$LN147@LCS_PortTh:
  017f8	33 c0		 xor	 eax, eax
  017fa	85 c0		 test	 eax, eax
  017fc	75 af		 jne	 SHORT $LN51@LCS_PortTh
  017fe	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_IsDebuggerPresent
  01804	85 c0		 test	 eax, eax
  01806	74 01		 je	 SHORT $LN148@LCS_PortTh
  01808	cc		 int	 3
$LN148@LCS_PortTh:
$LN146@LCS_PortTh:
  01809	33 c0		 xor	 eax, eax
  0180b	85 c0		 test	 eax, eax
  0180d	0f 85 78 ff ff
	ff		 jne	 $LN48@LCS_PortTh

; 2701 : 
; 2702 :     // Housekeeping - Cleanup Port Block
; 2703 : 
; 2704 :     memset( pLCSPORT->MAC_Address,  0, IFHWADDRLEN );

  01813	48 8b 44 24 70	 mov	 rax, QWORD PTR pLCSPORT$[rsp]
  01818	48 83 c0 02	 add	 rax, 2
  0181c	48 8b f8	 mov	 rdi, rax
  0181f	33 c0		 xor	 eax, eax
  01821	b9 06 00 00 00	 mov	 ecx, 6
  01826	f3 aa		 rep stosb

; 2705 :     memset( pLCSPORT->szNetIfName, 0, IFNAMSIZ );

  01828	48 8b 44 24 70	 mov	 rax, QWORD PTR pLCSPORT$[rsp]
  0182d	48 05 48 01 00
	00		 add	 rax, 328		; 00000148H
  01833	48 8b f8	 mov	 rdi, rax
  01836	33 c0		 xor	 eax, eax
  01838	b9 10 00 00 00	 mov	 ecx, 16
  0183d	f3 aa		 rep stosb

; 2706 :     memset( pLCSPORT->szMACAddress, 0, 32 );

  0183f	48 8b 44 24 70	 mov	 rax, QWORD PTR pLCSPORT$[rsp]
  01844	48 05 58 01 00
	00		 add	 rax, 344		; 00000158H
  0184a	48 8b f8	 mov	 rdi, rax
  0184d	33 c0		 xor	 eax, eax
  0184f	b9 20 00 00 00	 mov	 ecx, 32			; 00000020H
  01854	f3 aa		 rep stosb

; 2707 : 
; 2708 :     for (pLCSRTE = pLCSPORT->pRoutes; pLCSRTE; pLCSRTE = pLCSPORT->pRoutes)

  01856	48 8b 44 24 70	 mov	 rax, QWORD PTR pLCSPORT$[rsp]
  0185b	48 8b 40 08	 mov	 rax, QWORD PTR [rax+8]
  0185f	48 89 84 24 e8
	00 00 00	 mov	 QWORD PTR pLCSRTE$[rsp], rax
  01867	eb 11		 jmp	 SHORT $LN54@LCS_PortTh
$LN52@LCS_PortTh:
  01869	48 8b 44 24 70	 mov	 rax, QWORD PTR pLCSPORT$[rsp]
  0186e	48 8b 40 08	 mov	 rax, QWORD PTR [rax+8]
  01872	48 89 84 24 e8
	00 00 00	 mov	 QWORD PTR pLCSRTE$[rsp], rax
$LN54@LCS_PortTh:
  0187a	48 83 bc 24 e8
	00 00 00 00	 cmp	 QWORD PTR pLCSRTE$[rsp], 0
  01883	74 31		 je	 SHORT $LN53@LCS_PortTh

; 2709 :     {
; 2710 :         pLCSPORT->pRoutes = pLCSRTE->pNext;

  01885	48 8b 44 24 70	 mov	 rax, QWORD PTR pLCSPORT$[rsp]
  0188a	48 8b 8c 24 e8
	00 00 00	 mov	 rcx, QWORD PTR pLCSRTE$[rsp]
  01892	48 8b 49 10	 mov	 rcx, QWORD PTR [rcx+16]
  01896	48 89 48 08	 mov	 QWORD PTR [rax+8], rcx

; 2711 :         free( pLCSRTE );

  0189a	48 8b 8c 24 e8
	00 00 00	 mov	 rcx, QWORD PTR pLCSRTE$[rsp]
  018a2	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free

; 2712 :         pLCSRTE = NULL;

  018a8	48 c7 84 24 e8
	00 00 00 00 00
	00 00		 mov	 QWORD PTR pLCSRTE$[rsp], 0

; 2713 :     }

  018b4	eb b3		 jmp	 SHORT $LN52@LCS_PortTh
$LN53@LCS_PortTh:

; 2714 : 
; 2715 :     pLCSPORT->sIPAssistsSupported = 0;  // (reset)

  018b6	33 c0		 xor	 eax, eax
  018b8	48 8b 4c 24 70	 mov	 rcx, QWORD PTR pLCSPORT$[rsp]
  018bd	66 89 81 18 01
	00 00		 mov	 WORD PTR [rcx+280], ax

; 2716 :     pLCSPORT->sIPAssistsEnabled   = 0;  // (reset)

  018c4	33 c0		 xor	 eax, eax
  018c6	48 8b 4c 24 70	 mov	 rcx, QWORD PTR pLCSPORT$[rsp]
  018cb	66 89 81 1a 01
	00 00		 mov	 WORD PTR [rcx+282], ax

; 2717 :     pLCSPORT->fDoCkSumOffload     = 0;  // (reset)

  018d2	48 8b 44 24 70	 mov	 rax, QWORD PTR pLCSPORT$[rsp]
  018d7	8b 80 34 01 00
	00		 mov	 eax, DWORD PTR [rax+308]
  018dd	0f ba f0 07	 btr	 eax, 7
  018e1	48 8b 4c 24 70	 mov	 rcx, QWORD PTR pLCSPORT$[rsp]
  018e6	89 81 34 01 00
	00		 mov	 DWORD PTR [rcx+308], eax

; 2718 :     pLCSPORT->fDoMCastAssist      = 0;  // (reset)

  018ec	48 8b 44 24 70	 mov	 rax, QWORD PTR pLCSPORT$[rsp]
  018f1	8b 80 34 01 00
	00		 mov	 eax, DWORD PTR [rax+308]
  018f7	0f ba f0 08	 btr	 eax, 8
  018fb	48 8b 4c 24 70	 mov	 rcx, QWORD PTR pLCSPORT$[rsp]
  01900	89 81 34 01 00
	00		 mov	 DWORD PTR [rcx+308], eax

; 2719 : 
; 2720 :     pLCSPORT->fUsed        = 0;

  01906	48 8b 44 24 70	 mov	 rax, QWORD PTR pLCSPORT$[rsp]
  0190b	8b 80 34 01 00
	00		 mov	 eax, DWORD PTR [rax+308]
  01911	83 e0 fe	 and	 eax, -2			; fffffffeH
  01914	48 8b 4c 24 70	 mov	 rcx, QWORD PTR pLCSPORT$[rsp]
  01919	89 81 34 01 00
	00		 mov	 DWORD PTR [rcx+308], eax

; 2721 :     pLCSPORT->fLocalMAC    = 0;

  0191f	48 8b 44 24 70	 mov	 rax, QWORD PTR pLCSPORT$[rsp]
  01924	8b 80 34 01 00
	00		 mov	 eax, DWORD PTR [rax+308]
  0192a	83 e0 fd	 and	 eax, -3			; fffffffdH
  0192d	48 8b 4c 24 70	 mov	 rcx, QWORD PTR pLCSPORT$[rsp]
  01932	89 81 34 01 00
	00		 mov	 DWORD PTR [rcx+308], eax

; 2722 :     pLCSPORT->fPortCreated = 0;

  01938	48 8b 44 24 70	 mov	 rax, QWORD PTR pLCSPORT$[rsp]
  0193d	8b 80 34 01 00
	00		 mov	 eax, DWORD PTR [rax+308]
  01943	83 e0 fb	 and	 eax, -5			; fffffffbH
  01946	48 8b 4c 24 70	 mov	 rcx, QWORD PTR pLCSPORT$[rsp]
  0194b	89 81 34 01 00
	00		 mov	 DWORD PTR [rcx+308], eax
$LN57@LCS_PortTh:

; 2723 :     PTT_DEBUG( "PORTHRD started=NO", 000, pDEVBLK->devnum, pLCSPORT->bPort );

  01951	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_pttclass
  01958	48 8b 00	 mov	 rax, QWORD PTR [rax]
  0195b	48 25 00 00 02
	00		 and	 rax, 131072		; 00020000H
  01961	48 85 c0	 test	 rax, rax
  01964	74 46		 je	 SHORT $LN149@LCS_PortTh
  01966	48 8b 44 24 70	 mov	 rax, QWORD PTR pLCSPORT$[rsp]
  0196b	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  0196e	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR pDEVBLK$[rsp]
  01976	0f b7 49 48	 movzx	 ecx, WORD PTR [rcx+72]
  0197a	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR [rsp+48], 0
  01983	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  01988	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG172057
  0198f	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  01994	44 8b c9	 mov	 r9d, ecx
  01997	45 33 c0	 xor	 r8d, r8d
  0199a	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG172058
  019a1	b9 00 00 02 00	 mov	 ecx, 131072		; 00020000H
  019a6	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ptt_pthread_trace
$LN149@LCS_PortTh:
  019ac	33 c0		 xor	 eax, eax
  019ae	85 c0		 test	 eax, eax
  019b0	75 9f		 jne	 SHORT $LN57@LCS_PortTh

; 2724 :     pLCSPORT->fPortStarted = 0;

  019b2	48 8b 44 24 70	 mov	 rax, QWORD PTR pLCSPORT$[rsp]
  019b7	8b 80 34 01 00
	00		 mov	 eax, DWORD PTR [rax+308]
  019bd	83 e0 f7	 and	 eax, -9			; fffffff7H
  019c0	48 8b 4c 24 70	 mov	 rcx, QWORD PTR pLCSPORT$[rsp]
  019c5	89 81 34 01 00
	00		 mov	 DWORD PTR [rcx+308], eax

; 2725 :     pLCSPORT->fRouteAdded  = 0;

  019cb	48 8b 44 24 70	 mov	 rax, QWORD PTR pLCSPORT$[rsp]
  019d0	8b 80 34 01 00
	00		 mov	 eax, DWORD PTR [rax+308]
  019d6	83 e0 ef	 and	 eax, -17		; ffffffefH
  019d9	48 8b 4c 24 70	 mov	 rcx, QWORD PTR pLCSPORT$[rsp]
  019de	89 81 34 01 00
	00		 mov	 DWORD PTR [rcx+308], eax

; 2726 :     pLCSPORT->fd           = -1;

  019e4	48 8b 44 24 70	 mov	 rax, QWORD PTR pLCSPORT$[rsp]
  019e9	c7 80 38 01 00
	00 ff ff ff ff	 mov	 DWORD PTR [rax+312], -1
$LN60@LCS_PortTh:

; 2727 : 
; 2728 :     PTT_DEBUG( "PORTHRD: EXIT     ", 000, pDEVBLK->devnum, pLCSPORT->bPort );

  019f3	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_pttclass
  019fa	48 8b 00	 mov	 rax, QWORD PTR [rax]
  019fd	48 25 00 00 02
	00		 and	 rax, 131072		; 00020000H
  01a03	48 85 c0	 test	 rax, rax
  01a06	74 46		 je	 SHORT $LN150@LCS_PortTh
  01a08	48 8b 44 24 70	 mov	 rax, QWORD PTR pLCSPORT$[rsp]
  01a0d	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  01a10	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR pDEVBLK$[rsp]
  01a18	0f b7 49 48	 movzx	 ecx, WORD PTR [rcx+72]
  01a1c	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR [rsp+48], 0
  01a25	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  01a2a	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG172060
  01a31	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  01a36	44 8b c9	 mov	 r9d, ecx
  01a39	45 33 c0	 xor	 r8d, r8d
  01a3c	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG172061
  01a43	b9 00 00 02 00	 mov	 ecx, 131072		; 00020000H
  01a48	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ptt_pthread_trace
$LN150@LCS_PortTh:
  01a4e	33 c0		 xor	 eax, eax
  01a50	85 c0		 test	 eax, eax
  01a52	75 9f		 jne	 SHORT $LN60@LCS_PortTh

; 2729 : 
; 2730 :     return NULL;

  01a54	33 c0		 xor	 eax, eax

; 2731 : 
; 2732 : }   // End of LCS_PortThread

  01a56	48 8b 8c 24 f0
	09 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  01a5e	48 33 cc	 xor	 rcx, rsp
  01a61	e8 00 00 00 00	 call	 __security_check_cookie
  01a66	48 81 c4 08 0a
	00 00		 add	 rsp, 2568		; 00000a08H
  01a6d	5f		 pop	 rdi
  01a6e	5e		 pop	 rsi
  01a6f	c3		 ret	 0
LCS_PortThread ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\ctc_lcs.c
_TEXT	SEGMENT
iReplyLen$ = 32
pLCSSTDFRM$ = 40
tv73 = 48
Reply$ = 56
__$ArrayPad$ = 80
pLCSDEV$ = 128
pCmdFrame$ = 136
iCmdLen$ = 144
LCS_DefaultCmdProc PROC

; 2111 : {

  00000	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	56		 push	 rsi
  00010	57		 push	 rdi
  00011	48 83 ec 68	 sub	 rsp, 104		; 00000068H
  00015	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  0001c	48 33 c4	 xor	 rax, rsp
  0001f	48 89 44 24 50	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 2112 :     LCSSTDFRM   Reply;
; 2113 :     int         iReplyLen = sizeof(Reply);  /* Used and changed by INIT_REPLY_FRAME */

  00024	c7 44 24 20 14
	00 00 00	 mov	 DWORD PTR iReplyLen$[rsp], 20

; 2114 :     PLCSSTDFRM  pLCSSTDFRM = (PLCSSTDFRM)&Reply;

  0002c	48 8d 44 24 38	 lea	 rax, QWORD PTR Reply$[rsp]
  00031	48 89 44 24 28	 mov	 QWORD PTR pLCSSTDFRM$[rsp], rax
$LN4@LCS_Defaul:

; 2115 : 
; 2116 :     INIT_REPLY_FRAME( pLCSSTDFRM, iReplyLen, pCmdFrame, iCmdLen );

  00036	8b 44 24 20	 mov	 eax, DWORD PTR iReplyLen$[rsp]
  0003a	39 84 24 90 00
	00 00		 cmp	 DWORD PTR iCmdLen$[rsp], eax
  00041	7c 19		 jl	 SHORT $LN5@LCS_Defaul
  00043	48 63 44 24 20	 movsxd	 rax, DWORD PTR iReplyLen$[rsp]
  00048	48 8b 7c 24 28	 mov	 rdi, QWORD PTR pLCSSTDFRM$[rsp]
  0004d	48 8b b4 24 88
	00 00 00	 mov	 rsi, QWORD PTR pCmdFrame$[rsp]
  00055	48 8b c8	 mov	 rcx, rax
  00058	f3 a4		 rep movsb
  0005a	eb 3d		 jmp	 SHORT $LN6@LCS_Defaul
$LN5@LCS_Defaul:
  0005c	48 63 44 24 20	 movsxd	 rax, DWORD PTR iReplyLen$[rsp]
  00061	48 89 44 24 30	 mov	 QWORD PTR tv73[rsp], rax
  00066	48 8b 7c 24 28	 mov	 rdi, QWORD PTR pLCSSTDFRM$[rsp]
  0006b	33 c0		 xor	 eax, eax
  0006d	48 8b 4c 24 30	 mov	 rcx, QWORD PTR tv73[rsp]
  00072	f3 aa		 rep stosb
  00074	48 63 84 24 90
	00 00 00	 movsxd	 rax, DWORD PTR iCmdLen$[rsp]
  0007c	48 8b 7c 24 28	 mov	 rdi, QWORD PTR pLCSSTDFRM$[rsp]
  00081	48 8b b4 24 88
	00 00 00	 mov	 rsi, QWORD PTR pCmdFrame$[rsp]
  00089	48 8b c8	 mov	 rcx, rax
  0008c	f3 a4		 rep movsb
  0008e	8b 84 24 90 00
	00 00		 mov	 eax, DWORD PTR iCmdLen$[rsp]
  00095	89 44 24 20	 mov	 DWORD PTR iReplyLen$[rsp], eax
$LN6@LCS_Defaul:
  00099	33 c9		 xor	 ecx, ecx
  0009b	e8 00 00 00 00	 call	 _byteswap_ushort
  000a0	48 8b 4c 24 28	 mov	 rcx, QWORD PTR pLCSSTDFRM$[rsp]
  000a5	0f b7 d0	 movzx	 edx, ax
  000a8	e8 00 00 00 00	 call	 store_hw_noswap
  000ad	33 c9		 xor	 ecx, ecx
  000af	e8 00 00 00 00	 call	 _byteswap_ushort
  000b4	48 8b 4c 24 28	 mov	 rcx, QWORD PTR pLCSSTDFRM$[rsp]
  000b9	48 83 c1 08	 add	 rcx, 8
  000bd	0f b7 d0	 movzx	 edx, ax
  000c0	e8 00 00 00 00	 call	 store_hw_noswap
  000c5	33 c0		 xor	 eax, eax
  000c7	85 c0		 test	 eax, eax
  000c9	0f 85 67 ff ff
	ff		 jne	 $LN4@LCS_Defaul

; 2117 : 
; 2118 :     pLCSSTDFRM->bLCSCmdHdr.bLanType      = LCS_FRMTYP_ENET;

  000cf	48 8b 44 24 28	 mov	 rax, QWORD PTR pLCSSTDFRM$[rsp]
  000d4	c6 40 0a 01	 mov	 BYTE PTR [rax+10], 1

; 2119 :     pLCSSTDFRM->bLCSCmdHdr.bRelAdapterNo = pLCSDEV->bPort;

  000d8	48 8b 44 24 28	 mov	 rax, QWORD PTR pLCSSTDFRM$[rsp]
  000dd	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR pLCSDEV$[rsp]
  000e5	0f b6 49 23	 movzx	 ecx, BYTE PTR [rcx+35]
  000e9	88 48 0b	 mov	 BYTE PTR [rax+11], cl

; 2120 : 
; 2121 :     LCS_EnqueueReplyFrame( pLCSDEV, (PLCSCMDHDR)pLCSSTDFRM, iReplyLen );

  000ec	48 63 44 24 20	 movsxd	 rax, DWORD PTR iReplyLen$[rsp]
  000f1	4c 8b c0	 mov	 r8, rax
  000f4	48 8b 54 24 28	 mov	 rdx, QWORD PTR pLCSSTDFRM$[rsp]
  000f9	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR pLCSDEV$[rsp]
  00101	e8 00 00 00 00	 call	 LCS_EnqueueReplyFrame

; 2122 : }

  00106	48 8b 4c 24 50	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  0010b	48 33 cc	 xor	 rcx, rsp
  0010e	e8 00 00 00 00	 call	 __security_check_cookie
  00113	48 83 c4 68	 add	 rsp, 104		; 00000068H
  00117	5f		 pop	 rdi
  00118	5e		 pop	 rsi
  00119	c3		 ret	 0
LCS_DefaultCmdProc ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\ctc_lcs.c
_TEXT	SEGMENT
pLCSDEV$ = 48
pCmdFrame$ = 56
iCmdLen$ = 64
LCS_DelMulticast PROC

; 2102 : {

  00000	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 2103 :     LCS_DoMulticast( SIOCDELMULTI, pLCSDEV, pCmdFrame, iCmdLen );

  00013	44 8b 4c 24 40	 mov	 r9d, DWORD PTR iCmdLen$[rsp]
  00018	4c 8b 44 24 38	 mov	 r8, QWORD PTR pCmdFrame$[rsp]
  0001d	48 8b 54 24 30	 mov	 rdx, QWORD PTR pLCSDEV$[rsp]
  00022	b9 32 89 00 00	 mov	 ecx, 35122		; 00008932H
  00027	e8 00 00 00 00	 call	 LCS_DoMulticast

; 2104 : }

  0002c	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00030	c3		 ret	 0
LCS_DelMulticast ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\ctc_lcs.c
_TEXT	SEGMENT
pLCSDEV$ = 48
pCmdFrame$ = 56
iCmdLen$ = 64
LCS_AddMulticast PROC

; 2093 : {

  00000	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 2094 :     LCS_DoMulticast( SIOCADDMULTI, pLCSDEV, pCmdFrame, iCmdLen );

  00013	44 8b 4c 24 40	 mov	 r9d, DWORD PTR iCmdLen$[rsp]
  00018	4c 8b 44 24 38	 mov	 r8, QWORD PTR pCmdFrame$[rsp]
  0001d	48 8b 54 24 30	 mov	 rdx, QWORD PTR pLCSDEV$[rsp]
  00022	b9 31 89 00 00	 mov	 ecx, 35121		; 00008931H
  00027	e8 00 00 00 00	 call	 LCS_DoMulticast

; 2095 : }

  0002c	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00030	c3		 ret	 0
LCS_AddMulticast ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\ctc_lcs.c
_TEXT	SEGMENT
iReplyLen$ = 32
pLCSLSTFRM$ = 40
pLCSPORT$ = 48
tv80 = 56
Reply$ = 64
__$ArrayPad$ = 128
pLCSDEV$ = 176
pCmdFrame$ = 184
iCmdLen$ = 192
LCS_LanStats PROC

; 1918 : {

  00000	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	56		 push	 rsi
  00010	57		 push	 rdi
  00011	48 81 ec 98 00
	00 00		 sub	 rsp, 152		; 00000098H
  00018	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  0001f	48 33 c4	 xor	 rax, rsp
  00022	48 89 84 24 80
	00 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 1919 : 
; 1920 :     LCSLSTFRM  Reply;
; 1921 :     int        iReplyLen = sizeof(Reply);  /* Used and changed by INIT_REPLY_FRAME */

  0002a	c7 44 24 20 40
	00 00 00	 mov	 DWORD PTR iReplyLen$[rsp], 64 ; 00000040H

; 1922 :     PLCSLSTFRM pLCSLSTFRM = (PLCSLSTFRM)&Reply;

  00032	48 8d 44 24 40	 lea	 rax, QWORD PTR Reply$[rsp]
  00037	48 89 44 24 28	 mov	 QWORD PTR pLCSLSTFRM$[rsp], rax

; 1923 :     PLCSPORT   pLCSPORT;
; 1924 : 
; 1925 : 
; 1926 :     pLCSPORT = &pLCSDEV->pLCSBLK->Port[pLCSDEV->bPort];

  0003c	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR pLCSDEV$[rsp]
  00044	48 8b 40 08	 mov	 rax, QWORD PTR [rax+8]
  00048	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR pLCSDEV$[rsp]
  00050	0f b6 49 23	 movzx	 ecx, BYTE PTR [rcx+35]
  00054	48 69 c9 98 01
	00 00		 imul	 rcx, rcx, 408		; 00000198H
  0005b	48 8d 44 08 60	 lea	 rax, QWORD PTR [rax+rcx+96]
  00060	48 89 44 24 30	 mov	 QWORD PTR pLCSPORT$[rsp], rax

; 1927 : 
; 1928 :     // Get and display the tap interface MAC address.
; 1929 :     GetIfMACAddress( pLCSPORT );

  00065	48 8b 4c 24 30	 mov	 rcx, QWORD PTR pLCSPORT$[rsp]
  0006a	e8 00 00 00 00	 call	 GetIfMACAddress
$LN4@LCS_LanSta:

; 1930 : 
; 1931 :     INIT_REPLY_FRAME( pLCSLSTFRM, iReplyLen, pCmdFrame, iCmdLen );

  0006f	8b 44 24 20	 mov	 eax, DWORD PTR iReplyLen$[rsp]
  00073	39 84 24 c0 00
	00 00		 cmp	 DWORD PTR iCmdLen$[rsp], eax
  0007a	7c 19		 jl	 SHORT $LN5@LCS_LanSta
  0007c	48 63 44 24 20	 movsxd	 rax, DWORD PTR iReplyLen$[rsp]
  00081	48 8b 7c 24 28	 mov	 rdi, QWORD PTR pLCSLSTFRM$[rsp]
  00086	48 8b b4 24 b8
	00 00 00	 mov	 rsi, QWORD PTR pCmdFrame$[rsp]
  0008e	48 8b c8	 mov	 rcx, rax
  00091	f3 a4		 rep movsb
  00093	eb 3d		 jmp	 SHORT $LN6@LCS_LanSta
$LN5@LCS_LanSta:
  00095	48 63 44 24 20	 movsxd	 rax, DWORD PTR iReplyLen$[rsp]
  0009a	48 89 44 24 38	 mov	 QWORD PTR tv80[rsp], rax
  0009f	48 8b 7c 24 28	 mov	 rdi, QWORD PTR pLCSLSTFRM$[rsp]
  000a4	33 c0		 xor	 eax, eax
  000a6	48 8b 4c 24 38	 mov	 rcx, QWORD PTR tv80[rsp]
  000ab	f3 aa		 rep stosb
  000ad	48 63 84 24 c0
	00 00 00	 movsxd	 rax, DWORD PTR iCmdLen$[rsp]
  000b5	48 8b 7c 24 28	 mov	 rdi, QWORD PTR pLCSLSTFRM$[rsp]
  000ba	48 8b b4 24 b8
	00 00 00	 mov	 rsi, QWORD PTR pCmdFrame$[rsp]
  000c2	48 8b c8	 mov	 rcx, rax
  000c5	f3 a4		 rep movsb
  000c7	8b 84 24 c0 00
	00 00		 mov	 eax, DWORD PTR iCmdLen$[rsp]
  000ce	89 44 24 20	 mov	 DWORD PTR iReplyLen$[rsp], eax
$LN6@LCS_LanSta:
  000d2	33 c9		 xor	 ecx, ecx
  000d4	e8 00 00 00 00	 call	 _byteswap_ushort
  000d9	48 8b 4c 24 28	 mov	 rcx, QWORD PTR pLCSLSTFRM$[rsp]
  000de	0f b7 d0	 movzx	 edx, ax
  000e1	e8 00 00 00 00	 call	 store_hw_noswap
  000e6	33 c9		 xor	 ecx, ecx
  000e8	e8 00 00 00 00	 call	 _byteswap_ushort
  000ed	48 8b 4c 24 28	 mov	 rcx, QWORD PTR pLCSLSTFRM$[rsp]
  000f2	48 83 c1 08	 add	 rcx, 8
  000f6	0f b7 d0	 movzx	 edx, ax
  000f9	e8 00 00 00 00	 call	 store_hw_noswap
  000fe	33 c0		 xor	 eax, eax
  00100	85 c0		 test	 eax, eax
  00102	0f 85 67 ff ff
	ff		 jne	 $LN4@LCS_LanSta

; 1932 : 
; 1933 :     /* Respond with a different MAC address for the LCS side */
; 1934 :     /* unless the TAP mechanism is designed as such          */
; 1935 :     /* cf : hostopts.h for an explanation                    */
; 1936 :     iReplyLen = sizeof(Reply);

  00108	c7 44 24 20 40
	00 00 00	 mov	 DWORD PTR iReplyLen$[rsp], 64 ; 00000040H

; 1937 :     memcpy( pLCSLSTFRM->MAC_Address, pLCSPORT->MAC_Address, IFHWADDRLEN );

  00110	48 8b 44 24 28	 mov	 rax, QWORD PTR pLCSLSTFRM$[rsp]
  00115	48 8b 4c 24 30	 mov	 rcx, QWORD PTR pLCSPORT$[rsp]
  0011a	48 8d 78 16	 lea	 rdi, QWORD PTR [rax+22]
  0011e	48 8d 71 02	 lea	 rsi, QWORD PTR [rcx+2]
  00122	b9 06 00 00 00	 mov	 ecx, 6
  00127	f3 a4		 rep movsb

; 1938 : #if !defined( OPTION_TUNTAP_LCS_SAME_ADDR )
; 1939 :     pLCSLSTFRM->MAC_Address[5]++;
; 1940 : #endif
; 1941 :     // FIXME: Really should read /proc/net/dev to retrieve actual stats
; 1942 : 
; 1943 :     LCS_EnqueueReplyFrame( pLCSDEV, (PLCSCMDHDR)pLCSLSTFRM, iReplyLen );

  00129	48 63 44 24 20	 movsxd	 rax, DWORD PTR iReplyLen$[rsp]
  0012e	4c 8b c0	 mov	 r8, rax
  00131	48 8b 54 24 28	 mov	 rdx, QWORD PTR pLCSLSTFRM$[rsp]
  00136	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR pLCSDEV$[rsp]
  0013e	e8 00 00 00 00	 call	 LCS_EnqueueReplyFrame

; 1944 : }

  00143	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  0014b	48 33 cc	 xor	 rcx, rsp
  0014e	e8 00 00 00 00	 call	 __security_check_cookie
  00153	48 81 c4 98 00
	00 00		 add	 rsp, 152		; 00000098H
  0015a	5f		 pop	 rdi
  0015b	5e		 pop	 rsi
  0015c	c3		 ret	 0
LCS_LanStats ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\ctc_lcs.c
_TEXT	SEGMENT
iReplyLen$ = 32
pLCSQIPFRM$ = 40
pLCSPORT$ = 48
tv73 = 56
Reply$ = 64
__$ArrayPad$ = 88
pLCSDEV$ = 128
pCmdFrame$ = 136
iCmdLen$ = 144
LCS_QueryIPAssists PROC

; 1895 : {

  00000	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	56		 push	 rsi
  00010	57		 push	 rdi
  00011	48 83 ec 68	 sub	 rsp, 104		; 00000068H
  00015	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  0001c	48 33 c4	 xor	 rax, rsp
  0001f	48 89 44 24 58	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 1896 :     LCSQIPFRM   Reply;
; 1897 :     int         iReplyLen = sizeof(Reply);  /* Used and changed by INIT_REPLY_FRAME */

  00024	c7 44 24 20 14
	00 00 00	 mov	 DWORD PTR iReplyLen$[rsp], 20

; 1898 :     PLCSQIPFRM  pLCSQIPFRM = (PLCSQIPFRM)&Reply;

  0002c	48 8d 44 24 40	 lea	 rax, QWORD PTR Reply$[rsp]
  00031	48 89 44 24 28	 mov	 QWORD PTR pLCSQIPFRM$[rsp], rax
$LN4@LCS_QueryI:

; 1899 :     PLCSPORT    pLCSPORT;
; 1900 : 
; 1901 :     INIT_REPLY_FRAME( pLCSQIPFRM, iReplyLen, pCmdFrame, iCmdLen );

  00036	8b 44 24 20	 mov	 eax, DWORD PTR iReplyLen$[rsp]
  0003a	39 84 24 90 00
	00 00		 cmp	 DWORD PTR iCmdLen$[rsp], eax
  00041	7c 19		 jl	 SHORT $LN5@LCS_QueryI
  00043	48 63 44 24 20	 movsxd	 rax, DWORD PTR iReplyLen$[rsp]
  00048	48 8b 7c 24 28	 mov	 rdi, QWORD PTR pLCSQIPFRM$[rsp]
  0004d	48 8b b4 24 88
	00 00 00	 mov	 rsi, QWORD PTR pCmdFrame$[rsp]
  00055	48 8b c8	 mov	 rcx, rax
  00058	f3 a4		 rep movsb
  0005a	eb 3d		 jmp	 SHORT $LN6@LCS_QueryI
$LN5@LCS_QueryI:
  0005c	48 63 44 24 20	 movsxd	 rax, DWORD PTR iReplyLen$[rsp]
  00061	48 89 44 24 38	 mov	 QWORD PTR tv73[rsp], rax
  00066	48 8b 7c 24 28	 mov	 rdi, QWORD PTR pLCSQIPFRM$[rsp]
  0006b	33 c0		 xor	 eax, eax
  0006d	48 8b 4c 24 38	 mov	 rcx, QWORD PTR tv73[rsp]
  00072	f3 aa		 rep stosb
  00074	48 63 84 24 90
	00 00 00	 movsxd	 rax, DWORD PTR iCmdLen$[rsp]
  0007c	48 8b 7c 24 28	 mov	 rdi, QWORD PTR pLCSQIPFRM$[rsp]
  00081	48 8b b4 24 88
	00 00 00	 mov	 rsi, QWORD PTR pCmdFrame$[rsp]
  00089	48 8b c8	 mov	 rcx, rax
  0008c	f3 a4		 rep movsb
  0008e	8b 84 24 90 00
	00 00		 mov	 eax, DWORD PTR iCmdLen$[rsp]
  00095	89 44 24 20	 mov	 DWORD PTR iReplyLen$[rsp], eax
$LN6@LCS_QueryI:
  00099	33 c9		 xor	 ecx, ecx
  0009b	e8 00 00 00 00	 call	 _byteswap_ushort
  000a0	48 8b 4c 24 28	 mov	 rcx, QWORD PTR pLCSQIPFRM$[rsp]
  000a5	0f b7 d0	 movzx	 edx, ax
  000a8	e8 00 00 00 00	 call	 store_hw_noswap
  000ad	33 c9		 xor	 ecx, ecx
  000af	e8 00 00 00 00	 call	 _byteswap_ushort
  000b4	48 8b 4c 24 28	 mov	 rcx, QWORD PTR pLCSQIPFRM$[rsp]
  000b9	48 83 c1 08	 add	 rcx, 8
  000bd	0f b7 d0	 movzx	 edx, ax
  000c0	e8 00 00 00 00	 call	 store_hw_noswap
  000c5	33 c0		 xor	 eax, eax
  000c7	85 c0		 test	 eax, eax
  000c9	0f 85 67 ff ff
	ff		 jne	 $LN4@LCS_QueryI

; 1902 : 
; 1903 :     pLCSPORT = &pLCSDEV->pLCSBLK->Port[pLCSDEV->bPort];

  000cf	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR pLCSDEV$[rsp]
  000d7	48 8b 40 08	 mov	 rax, QWORD PTR [rax+8]
  000db	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR pLCSDEV$[rsp]
  000e3	0f b6 49 23	 movzx	 ecx, BYTE PTR [rcx+35]
  000e7	48 69 c9 98 01
	00 00		 imul	 rcx, rcx, 408		; 00000198H
  000ee	48 8d 44 08 60	 lea	 rax, QWORD PTR [rax+rcx+96]
  000f3	48 89 44 24 30	 mov	 QWORD PTR pLCSPORT$[rsp], rax

; 1904 : 
; 1905 :     STORE_HW( pLCSQIPFRM->hwNumIPPairs,         _countof( pLCSPORT->MCastTab ));

  000f8	66 b9 20 00	 mov	 cx, 32			; 00000020H
  000fc	e8 00 00 00 00	 call	 _byteswap_ushort
  00101	48 8b 4c 24 28	 mov	 rcx, QWORD PTR pLCSQIPFRM$[rsp]
  00106	48 83 c1 0c	 add	 rcx, 12
  0010a	0f b7 d0	 movzx	 edx, ax
  0010d	e8 00 00 00 00	 call	 store_hw_noswap

; 1906 :     STORE_HW( pLCSQIPFRM->hwIPAssistsSupported, pLCSPORT->sIPAssistsSupported );

  00112	48 8b 44 24 30	 mov	 rax, QWORD PTR pLCSPORT$[rsp]
  00117	0f b7 88 18 01
	00 00		 movzx	 ecx, WORD PTR [rax+280]
  0011e	e8 00 00 00 00	 call	 _byteswap_ushort
  00123	48 8b 4c 24 28	 mov	 rcx, QWORD PTR pLCSQIPFRM$[rsp]
  00128	48 83 c1 0e	 add	 rcx, 14
  0012c	0f b7 d0	 movzx	 edx, ax
  0012f	e8 00 00 00 00	 call	 store_hw_noswap

; 1907 :     STORE_HW( pLCSQIPFRM->hwIPAssistsEnabled,   pLCSPORT->sIPAssistsEnabled   );

  00134	48 8b 44 24 30	 mov	 rax, QWORD PTR pLCSPORT$[rsp]
  00139	0f b7 88 1a 01
	00 00		 movzx	 ecx, WORD PTR [rax+282]
  00140	e8 00 00 00 00	 call	 _byteswap_ushort
  00145	48 8b 4c 24 28	 mov	 rcx, QWORD PTR pLCSQIPFRM$[rsp]
  0014a	48 83 c1 10	 add	 rcx, 16
  0014e	0f b7 d0	 movzx	 edx, ax
  00151	e8 00 00 00 00	 call	 store_hw_noswap

; 1908 :     STORE_HW( pLCSQIPFRM->hwIPVersion,          0x0004 ); // (IPv4 only)

  00156	66 b9 04 00	 mov	 cx, 4
  0015a	e8 00 00 00 00	 call	 _byteswap_ushort
  0015f	48 8b 4c 24 28	 mov	 rcx, QWORD PTR pLCSQIPFRM$[rsp]
  00164	48 83 c1 12	 add	 rcx, 18
  00168	0f b7 d0	 movzx	 edx, ax
  0016b	e8 00 00 00 00	 call	 store_hw_noswap

; 1909 : 
; 1910 :     LCS_EnqueueReplyFrame( pLCSDEV, (PLCSCMDHDR)pLCSQIPFRM, iReplyLen );

  00170	48 63 44 24 20	 movsxd	 rax, DWORD PTR iReplyLen$[rsp]
  00175	4c 8b c0	 mov	 r8, rax
  00178	48 8b 54 24 28	 mov	 rdx, QWORD PTR pLCSQIPFRM$[rsp]
  0017d	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR pLCSDEV$[rsp]
  00185	e8 00 00 00 00	 call	 LCS_EnqueueReplyFrame

; 1911 : }

  0018a	48 8b 4c 24 58	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  0018f	48 33 cc	 xor	 rcx, rsp
  00192	e8 00 00 00 00	 call	 __security_check_cookie
  00197	48 83 c4 68	 add	 rsp, 104		; 00000068H
  0019b	5f		 pop	 rdi
  0019c	5e		 pop	 rsi
  0019d	c3		 ret	 0
LCS_QueryIPAssists ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\ctc_lcs.c
_TEXT	SEGMENT
iReplyLen$ = 64
pLCSPORT$ = 72
pDEVBLK$ = 80
pLCSSTDFRM$ = 88
tv86 = 96
Reply$ = 104
__$ArrayPad$ = 128
pLCSDEV$ = 176
pCmdFrame$ = 184
iCmdLen$ = 192
LCS_StopLan PROC

; 1812 : {

  00000	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	56		 push	 rsi
  00010	57		 push	 rdi
  00011	48 81 ec 98 00
	00 00		 sub	 rsp, 152		; 00000098H
  00018	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  0001f	48 33 c4	 xor	 rax, rsp
  00022	48 89 84 24 80
	00 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 1813 :     LCSSTDFRM   Reply;
; 1814 :     int         iReplyLen = sizeof(Reply);  /* Used and changed by INIT_REPLY_FRAME */

  0002a	c7 44 24 40 14
	00 00 00	 mov	 DWORD PTR iReplyLen$[rsp], 20

; 1815 :     PLCSSTDFRM  pLCSSTDFRM = (PLCSSTDFRM)&Reply;

  00032	48 8d 44 24 68	 lea	 rax, QWORD PTR Reply$[rsp]
  00037	48 89 44 24 58	 mov	 QWORD PTR pLCSSTDFRM$[rsp], rax

; 1816 :     PLCSPORT    pLCSPORT;
; 1817 : #ifdef OPTION_TUNTAP_DELADD_ROUTES
; 1818 :     PLCSRTE     pLCSRTE;
; 1819 : #endif // OPTION_TUNTAP_DELADD_ROUTES
; 1820 :     DEVBLK*     pDEVBLK;
; 1821 : 
; 1822 : 
; 1823 :     pLCSPORT = &pLCSDEV->pLCSBLK->Port[ pLCSDEV->bPort ];

  0003c	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR pLCSDEV$[rsp]
  00044	48 8b 40 08	 mov	 rax, QWORD PTR [rax+8]
  00048	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR pLCSDEV$[rsp]
  00050	0f b6 49 23	 movzx	 ecx, BYTE PTR [rcx+35]
  00054	48 69 c9 98 01
	00 00		 imul	 rcx, rcx, 408		; 00000198H
  0005b	48 8d 44 08 60	 lea	 rax, QWORD PTR [rax+rcx+96]
  00060	48 89 44 24 48	 mov	 QWORD PTR pLCSPORT$[rsp], rax

; 1824 :     pDEVBLK  =  pLCSDEV->pDEVBLK[ LCS_WRITE_SUBCHANN ];

  00065	b8 08 00 00 00	 mov	 eax, 8
  0006a	48 6b c0 01	 imul	 rax, rax, 1
  0006e	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR pLCSDEV$[rsp]
  00076	48 8b 44 01 10	 mov	 rax, QWORD PTR [rcx+rax+16]
  0007b	48 89 44 24 50	 mov	 QWORD PTR pDEVBLK$[rsp], rax

; 1825 :     if (!pDEVBLK) pDEVBLK = pLCSDEV->pDEVBLK[ LCS_READ_SUBCHANN ];  /* SNA has only one device */

  00080	48 83 7c 24 50
	00		 cmp	 QWORD PTR pDEVBLK$[rsp], 0
  00086	75 1b		 jne	 SHORT $LN20@LCS_StopLa
  00088	b8 08 00 00 00	 mov	 eax, 8
  0008d	48 6b c0 00	 imul	 rax, rax, 0
  00091	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR pLCSDEV$[rsp]
  00099	48 8b 44 01 10	 mov	 rax, QWORD PTR [rcx+rax+16]
  0009e	48 89 44 24 50	 mov	 QWORD PTR pDEVBLK$[rsp], rax
$LN20@LCS_StopLa:
$LN4@LCS_StopLa:

; 1826 : 
; 1827 :     INIT_REPLY_FRAME( pLCSSTDFRM, iReplyLen, pCmdFrame, iCmdLen );

  000a3	8b 44 24 40	 mov	 eax, DWORD PTR iReplyLen$[rsp]
  000a7	39 84 24 c0 00
	00 00		 cmp	 DWORD PTR iCmdLen$[rsp], eax
  000ae	7c 19		 jl	 SHORT $LN21@LCS_StopLa
  000b0	48 63 44 24 40	 movsxd	 rax, DWORD PTR iReplyLen$[rsp]
  000b5	48 8b 7c 24 58	 mov	 rdi, QWORD PTR pLCSSTDFRM$[rsp]
  000ba	48 8b b4 24 b8
	00 00 00	 mov	 rsi, QWORD PTR pCmdFrame$[rsp]
  000c2	48 8b c8	 mov	 rcx, rax
  000c5	f3 a4		 rep movsb
  000c7	eb 3d		 jmp	 SHORT $LN22@LCS_StopLa
$LN21@LCS_StopLa:
  000c9	48 63 44 24 40	 movsxd	 rax, DWORD PTR iReplyLen$[rsp]
  000ce	48 89 44 24 60	 mov	 QWORD PTR tv86[rsp], rax
  000d3	48 8b 7c 24 58	 mov	 rdi, QWORD PTR pLCSSTDFRM$[rsp]
  000d8	33 c0		 xor	 eax, eax
  000da	48 8b 4c 24 60	 mov	 rcx, QWORD PTR tv86[rsp]
  000df	f3 aa		 rep stosb
  000e1	48 63 84 24 c0
	00 00 00	 movsxd	 rax, DWORD PTR iCmdLen$[rsp]
  000e9	48 8b 7c 24 58	 mov	 rdi, QWORD PTR pLCSSTDFRM$[rsp]
  000ee	48 8b b4 24 b8
	00 00 00	 mov	 rsi, QWORD PTR pCmdFrame$[rsp]
  000f6	48 8b c8	 mov	 rcx, rax
  000f9	f3 a4		 rep movsb
  000fb	8b 84 24 c0 00
	00 00		 mov	 eax, DWORD PTR iCmdLen$[rsp]
  00102	89 44 24 40	 mov	 DWORD PTR iReplyLen$[rsp], eax
$LN22@LCS_StopLa:
  00106	33 c9		 xor	 ecx, ecx
  00108	e8 00 00 00 00	 call	 _byteswap_ushort
  0010d	48 8b 4c 24 58	 mov	 rcx, QWORD PTR pLCSSTDFRM$[rsp]
  00112	0f b7 d0	 movzx	 edx, ax
  00115	e8 00 00 00 00	 call	 store_hw_noswap
  0011a	33 c9		 xor	 ecx, ecx
  0011c	e8 00 00 00 00	 call	 _byteswap_ushort
  00121	48 8b 4c 24 58	 mov	 rcx, QWORD PTR pLCSSTDFRM$[rsp]
  00126	48 83 c1 08	 add	 rcx, 8
  0012a	0f b7 d0	 movzx	 edx, ax
  0012d	e8 00 00 00 00	 call	 store_hw_noswap
  00132	33 c0		 xor	 eax, eax
  00134	85 c0		 test	 eax, eax
  00136	0f 85 67 ff ff
	ff		 jne	 $LN4@LCS_StopLa
$LN7@LCS_StopLa:

; 1828 : 
; 1829 :     // Serialize access to eliminate ioctl errors
; 1830 :     PTT_DEBUG(        "GET  PortDataLock ", 000, pDEVBLK->devnum, pLCSPORT->bPort );

  0013c	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_pttclass
  00143	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00146	48 25 00 00 02
	00		 and	 rax, 131072		; 00020000H
  0014c	48 85 c0	 test	 rax, rax
  0014f	74 43		 je	 SHORT $LN23@LCS_StopLa
  00151	48 8b 44 24 48	 mov	 rax, QWORD PTR pLCSPORT$[rsp]
  00156	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  00159	48 8b 4c 24 50	 mov	 rcx, QWORD PTR pDEVBLK$[rsp]
  0015e	0f b7 49 48	 movzx	 ecx, WORD PTR [rcx+72]
  00162	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR [rsp+48], 0
  0016b	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  00170	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG171187
  00177	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  0017c	44 8b c9	 mov	 r9d, ecx
  0017f	45 33 c0	 xor	 r8d, r8d
  00182	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG171188
  00189	b9 00 00 02 00	 mov	 ecx, 131072		; 00020000H
  0018e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ptt_pthread_trace
$LN23@LCS_StopLa:
  00194	33 c0		 xor	 eax, eax
  00196	85 c0		 test	 eax, eax
  00198	75 a2		 jne	 SHORT $LN7@LCS_StopLa

; 1831 :     obtain_lock( &pLCSPORT->PortDataLock );

  0019a	48 8b 44 24 48	 mov	 rax, QWORD PTR pLCSPORT$[rsp]
  0019f	48 05 1c 01 00
	00		 add	 rax, 284		; 0000011cH
  001a5	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG171189
  001ac	48 8b c8	 mov	 rcx, rax
  001af	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_obtain_lock
$LN10@LCS_StopLa:

; 1832 :     PTT_DEBUG(        "GOT  PortDataLock ", 000, pDEVBLK->devnum, pLCSPORT->bPort );

  001b5	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_pttclass
  001bc	48 8b 00	 mov	 rax, QWORD PTR [rax]
  001bf	48 25 00 00 02
	00		 and	 rax, 131072		; 00020000H
  001c5	48 85 c0	 test	 rax, rax
  001c8	74 43		 je	 SHORT $LN24@LCS_StopLa
  001ca	48 8b 44 24 48	 mov	 rax, QWORD PTR pLCSPORT$[rsp]
  001cf	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  001d2	48 8b 4c 24 50	 mov	 rcx, QWORD PTR pDEVBLK$[rsp]
  001d7	0f b7 49 48	 movzx	 ecx, WORD PTR [rcx+72]
  001db	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR [rsp+48], 0
  001e4	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  001e9	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG171191
  001f0	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  001f5	44 8b c9	 mov	 r9d, ecx
  001f8	45 33 c0	 xor	 r8d, r8d
  001fb	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG171192
  00202	b9 00 00 02 00	 mov	 ecx, 131072		; 00020000H
  00207	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ptt_pthread_trace
$LN24@LCS_StopLa:
  0020d	33 c0		 xor	 eax, eax
  0020f	85 c0		 test	 eax, eax
  00211	75 a2		 jne	 SHORT $LN10@LCS_StopLa

; 1833 :     {
; 1834 :         // Disable the interface by turning off the IFF_UP flag...
; 1835 :         if (!pLCSPORT->fPreconfigured)

  00213	48 8b 44 24 48	 mov	 rax, QWORD PTR pLCSPORT$[rsp]
  00218	8b 80 34 01 00
	00		 mov	 eax, DWORD PTR [rax+308]
  0021e	c1 e8 06	 shr	 eax, 6
  00221	83 e0 01	 and	 eax, 1
  00224	85 c0		 test	 eax, eax
  00226	75 7b		 jne	 SHORT $LN25@LCS_StopLa
$LN13@LCS_StopLa:

; 1836 :             VERIFY( TUNTAP_SetFlags( pLCSPORT->szNetIfName, 0 ) == 0 );

  00228	48 8b 44 24 48	 mov	 rax, QWORD PTR pLCSPORT$[rsp]
  0022d	48 05 48 01 00
	00		 add	 rax, 328		; 00000148H
  00233	33 d2		 xor	 edx, edx
  00235	48 8b c8	 mov	 rcx, rax
  00238	e8 00 00 00 00	 call	 TUNTAP_SetFlags
  0023d	85 c0		 test	 eax, eax
  0023f	74 5c		 je	 SHORT $LN26@LCS_StopLa
$LN16@LCS_StopLa:
  00241	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG171195
  00248	41 b8 2c 07 00
	00		 mov	 r8d, 1836		; 0000072cH
  0024e	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG171196
  00255	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG171197
  0025c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_logmsg
  00262	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_IsDebuggerPresent
  00268	85 c0		 test	 eax, eax
  0026a	74 20		 je	 SHORT $LN27@LCS_StopLa
  0026c	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG171199
  00273	41 b8 2c 07 00
	00		 mov	 r8d, 1836		; 0000072cH
  00279	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG171200
  00280	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG171201
  00287	e8 00 00 00 00	 call	 DebuggerTrace
$LN27@LCS_StopLa:
  0028c	33 c0		 xor	 eax, eax
  0028e	85 c0		 test	 eax, eax
  00290	75 af		 jne	 SHORT $LN16@LCS_StopLa
  00292	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_IsDebuggerPresent
  00298	85 c0		 test	 eax, eax
  0029a	74 01		 je	 SHORT $LN28@LCS_StopLa
  0029c	cc		 int	 3
$LN28@LCS_StopLa:
$LN26@LCS_StopLa:
  0029d	33 c0		 xor	 eax, eax
  0029f	85 c0		 test	 eax, eax
  002a1	75 85		 jne	 SHORT $LN13@LCS_StopLa
$LN25@LCS_StopLa:
$LN19@LCS_StopLa:

; 1837 : 
; 1838 : #ifdef OPTION_TUNTAP_DELADD_ROUTES
; 1839 : 
; 1840 :         // Remove routing entries from host's routing table...
; 1841 : 
; 1842 :         // First, remove the Point-To-Point routing entry
; 1843 :         // we added when we brought the interface IFF_UP...
; 1844 : 
; 1845 :         if (!pLCSPORT->fPreconfigured)
; 1846 :         {
; 1847 :             if (pLCSDEV->pszIPAddress)
; 1848 :             {
; 1849 :                 VERIFY( TUNTAP_DelRoute( pLCSPORT->szNetIfName,
; 1850 :                                  pLCSDEV->pszIPAddress,
; 1851 :                                  "255.255.255.255",
; 1852 :                                  NULL,
; 1853 :                                  RTF_HOST ) == 0 );
; 1854 :             }
; 1855 :         }
; 1856 : 
; 1857 :         // Next, remove any extra routing entries
; 1858 :         // (specified by the user in their OAT file)
; 1859 :         // that we may have also added...
; 1860 : 
; 1861 :         if (!pLCSPORT->fPreconfigured)
; 1862 :         {
; 1863 :             for (pLCSRTE = pLCSPORT->pRoutes; pLCSRTE; pLCSRTE = pLCSRTE->pNext)
; 1864 :             {
; 1865 :                 VERIFY( TUNTAP_DelRoute( pLCSPORT->szNetIfName,
; 1866 :                                  pLCSRTE->pszNetAddr,
; 1867 :                                  pLCSRTE->pszNetMask,
; 1868 :                                  NULL,
; 1869 :                                  RTF_UP ) == 0 );
; 1870 :             }
; 1871 :         }
; 1872 : #endif // OPTION_TUNTAP_DELADD_ROUTES
; 1873 :     }
; 1874 :     PTT_DEBUG(         "REL  PortDataLock ", 000, pDEVBLK->devnum, pLCSPORT->bPort );

  002a3	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_pttclass
  002aa	48 8b 00	 mov	 rax, QWORD PTR [rax]
  002ad	48 25 00 00 02
	00		 and	 rax, 131072		; 00020000H
  002b3	48 85 c0	 test	 rax, rax
  002b6	74 43		 je	 SHORT $LN29@LCS_StopLa
  002b8	48 8b 44 24 48	 mov	 rax, QWORD PTR pLCSPORT$[rsp]
  002bd	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  002c0	48 8b 4c 24 50	 mov	 rcx, QWORD PTR pDEVBLK$[rsp]
  002c5	0f b7 49 48	 movzx	 ecx, WORD PTR [rcx+72]
  002c9	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR [rsp+48], 0
  002d2	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  002d7	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG171204
  002de	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  002e3	44 8b c9	 mov	 r9d, ecx
  002e6	45 33 c0	 xor	 r8d, r8d
  002e9	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG171205
  002f0	b9 00 00 02 00	 mov	 ecx, 131072		; 00020000H
  002f5	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ptt_pthread_trace
$LN29@LCS_StopLa:
  002fb	33 c0		 xor	 eax, eax
  002fd	85 c0		 test	 eax, eax
  002ff	75 a2		 jne	 SHORT $LN19@LCS_StopLa

; 1875 :     release_lock( &pLCSPORT->PortDataLock );

  00301	48 8b 44 24 48	 mov	 rax, QWORD PTR pLCSPORT$[rsp]
  00306	48 05 1c 01 00
	00		 add	 rax, 284		; 0000011cH
  0030c	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG171206
  00313	48 8b c8	 mov	 rcx, rax
  00316	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_release_lock

; 1876 : 
; 1877 :     // Now that the tuntap device has been stopped and the packets
; 1878 :     // are no longer flowing, tell the LCS_PortThread to stop trying
; 1879 :     // to read from the tuntap device (adapter).
; 1880 : 
; 1881 :     UpdatePortStarted( FALSE, pDEVBLK, pLCSPORT );

  0031c	4c 8b 44 24 48	 mov	 r8, QWORD PTR pLCSPORT$[rsp]
  00321	48 8b 54 24 50	 mov	 rdx, QWORD PTR pDEVBLK$[rsp]
  00326	33 c9		 xor	 ecx, ecx
  00328	e8 00 00 00 00	 call	 UpdatePortStarted

; 1882 : 
; 1883 :     // Now that we've stopped new packets from being added to our
; 1884 :     // frame buffer we can now finally enqueue our reply frame
; 1885 :     // to our frame buffer (so LCS_Read can return it to the guest).
; 1886 : 
; 1887 :     LCS_EnqueueReplyFrame( pLCSDEV, (PLCSCMDHDR)pLCSSTDFRM, iReplyLen );

  0032d	48 63 44 24 40	 movsxd	 rax, DWORD PTR iReplyLen$[rsp]
  00332	4c 8b c0	 mov	 r8, rax
  00335	48 8b 54 24 58	 mov	 rdx, QWORD PTR pLCSSTDFRM$[rsp]
  0033a	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR pLCSDEV$[rsp]
  00342	e8 00 00 00 00	 call	 LCS_EnqueueReplyFrame

; 1888 : }

  00347	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  0034f	48 33 cc	 xor	 rcx, rsp
  00352	e8 00 00 00 00	 call	 __security_check_cookie
  00357	48 81 c4 98 00
	00 00		 add	 rsp, 152		; 00000098H
  0035e	5f		 pop	 rdi
  0035f	5e		 pop	 rsi
  00360	c3		 ret	 0
LCS_StopLan ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\ctc_lcs.c
_TEXT	SEGMENT
fStartPending$ = 64
pLCSPORT$ = 72
iReplyLen$ = 80
pDEVBLK$ = 88
pLCSSTRTFRM$ = 96
nIFFlags$ = 104
tv86 = 112
Reply$ = 120
__$ArrayPad$ = 144
pLCSDEV$ = 192
pCmdFrame$ = 200
iCmdLen$ = 208
LCS_StartLan PROC

; 1702 : {

  00000	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	56		 push	 rsi
  00010	57		 push	 rdi
  00011	48 81 ec a8 00
	00 00		 sub	 rsp, 168		; 000000a8H
  00018	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  0001f	48 33 c4	 xor	 rax, rsp
  00022	48 89 84 24 90
	00 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 1703 :     LCSSTRTFRM  Reply;
; 1704 :     int         iReplyLen = sizeof(Reply);  /* Used and changed by INIT_REPLY_FRAME */

  0002a	c7 44 24 50 18
	00 00 00	 mov	 DWORD PTR iReplyLen$[rsp], 24

; 1705 :     PLCSSTRTFRM pLCSSTRTFRM = (PLCSSTRTFRM)&Reply;

  00032	48 8d 44 24 78	 lea	 rax, QWORD PTR Reply$[rsp]
  00037	48 89 44 24 60	 mov	 QWORD PTR pLCSSTRTFRM$[rsp], rax

; 1706 :     PLCSPORT    pLCSPORT;
; 1707 : #ifdef OPTION_TUNTAP_DELADD_ROUTES
; 1708 :     PLCSRTE     pLCSRTE;
; 1709 : #endif // OPTION_TUNTAP_DELADD_ROUTES
; 1710 :     DEVBLK*     pDEVBLK;
; 1711 :     int         nIFFlags;
; 1712 :     U8          fStartPending = 0;

  0003c	c6 44 24 40 00	 mov	 BYTE PTR fStartPending$[rsp], 0

; 1713 : 
; 1714 : 
; 1715 :     pLCSPORT = &pLCSDEV->pLCSBLK->Port[pLCSDEV->bPort];

  00041	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR pLCSDEV$[rsp]
  00049	48 8b 40 08	 mov	 rax, QWORD PTR [rax+8]
  0004d	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR pLCSDEV$[rsp]
  00055	0f b6 49 23	 movzx	 ecx, BYTE PTR [rcx+35]
  00059	48 69 c9 98 01
	00 00		 imul	 rcx, rcx, 408		; 00000198H
  00060	48 8d 44 08 60	 lea	 rax, QWORD PTR [rax+rcx+96]
  00065	48 89 44 24 48	 mov	 QWORD PTR pLCSPORT$[rsp], rax

; 1716 :     pDEVBLK  = pLCSDEV->pDEVBLK[ LCS_WRITE_SUBCHANN ];

  0006a	b8 08 00 00 00	 mov	 eax, 8
  0006f	48 6b c0 01	 imul	 rax, rax, 1
  00073	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR pLCSDEV$[rsp]
  0007b	48 8b 44 01 10	 mov	 rax, QWORD PTR [rcx+rax+16]
  00080	48 89 44 24 58	 mov	 QWORD PTR pDEVBLK$[rsp], rax

; 1717 :     if (!pDEVBLK) pDEVBLK = pLCSDEV->pDEVBLK[ LCS_READ_SUBCHANN ];  /* SNA has only one device */

  00085	48 83 7c 24 58
	00		 cmp	 QWORD PTR pDEVBLK$[rsp], 0
  0008b	75 1b		 jne	 SHORT $LN26@LCS_StartL
  0008d	b8 08 00 00 00	 mov	 eax, 8
  00092	48 6b c0 00	 imul	 rax, rax, 0
  00096	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR pLCSDEV$[rsp]
  0009e	48 8b 44 01 10	 mov	 rax, QWORD PTR [rcx+rax+16]
  000a3	48 89 44 24 58	 mov	 QWORD PTR pDEVBLK$[rsp], rax
$LN26@LCS_StartL:
$LN4@LCS_StartL:

; 1718 : 
; 1719 :     INIT_REPLY_FRAME( pLCSSTRTFRM, iReplyLen, pCmdFrame, iCmdLen );

  000a8	8b 44 24 50	 mov	 eax, DWORD PTR iReplyLen$[rsp]
  000ac	39 84 24 d0 00
	00 00		 cmp	 DWORD PTR iCmdLen$[rsp], eax
  000b3	7c 19		 jl	 SHORT $LN27@LCS_StartL
  000b5	48 63 44 24 50	 movsxd	 rax, DWORD PTR iReplyLen$[rsp]
  000ba	48 8b 7c 24 60	 mov	 rdi, QWORD PTR pLCSSTRTFRM$[rsp]
  000bf	48 8b b4 24 c8
	00 00 00	 mov	 rsi, QWORD PTR pCmdFrame$[rsp]
  000c7	48 8b c8	 mov	 rcx, rax
  000ca	f3 a4		 rep movsb
  000cc	eb 3d		 jmp	 SHORT $LN28@LCS_StartL
$LN27@LCS_StartL:
  000ce	48 63 44 24 50	 movsxd	 rax, DWORD PTR iReplyLen$[rsp]
  000d3	48 89 44 24 70	 mov	 QWORD PTR tv86[rsp], rax
  000d8	48 8b 7c 24 60	 mov	 rdi, QWORD PTR pLCSSTRTFRM$[rsp]
  000dd	33 c0		 xor	 eax, eax
  000df	48 8b 4c 24 70	 mov	 rcx, QWORD PTR tv86[rsp]
  000e4	f3 aa		 rep stosb
  000e6	48 63 84 24 d0
	00 00 00	 movsxd	 rax, DWORD PTR iCmdLen$[rsp]
  000ee	48 8b 7c 24 60	 mov	 rdi, QWORD PTR pLCSSTRTFRM$[rsp]
  000f3	48 8b b4 24 c8
	00 00 00	 mov	 rsi, QWORD PTR pCmdFrame$[rsp]
  000fb	48 8b c8	 mov	 rcx, rax
  000fe	f3 a4		 rep movsb
  00100	8b 84 24 d0 00
	00 00		 mov	 eax, DWORD PTR iCmdLen$[rsp]
  00107	89 44 24 50	 mov	 DWORD PTR iReplyLen$[rsp], eax
$LN28@LCS_StartL:
  0010b	33 c9		 xor	 ecx, ecx
  0010d	e8 00 00 00 00	 call	 _byteswap_ushort
  00112	48 8b 4c 24 60	 mov	 rcx, QWORD PTR pLCSSTRTFRM$[rsp]
  00117	0f b7 d0	 movzx	 edx, ax
  0011a	e8 00 00 00 00	 call	 store_hw_noswap
  0011f	33 c9		 xor	 ecx, ecx
  00121	e8 00 00 00 00	 call	 _byteswap_ushort
  00126	48 8b 4c 24 60	 mov	 rcx, QWORD PTR pLCSSTRTFRM$[rsp]
  0012b	48 83 c1 08	 add	 rcx, 8
  0012f	0f b7 d0	 movzx	 edx, ax
  00132	e8 00 00 00 00	 call	 store_hw_noswap
  00137	33 c0		 xor	 eax, eax
  00139	85 c0		 test	 eax, eax
  0013b	0f 85 67 ff ff
	ff		 jne	 $LN4@LCS_StartL
$LN7@LCS_StartL:

; 1720 : 
; 1721 :     // Serialize access to eliminate ioctl errors
; 1722 :     PTT_DEBUG(        "GET  PortDataLock ", 000, pDEVBLK->devnum, pLCSPORT->bPort );

  00141	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_pttclass
  00148	48 8b 00	 mov	 rax, QWORD PTR [rax]
  0014b	48 25 00 00 02
	00		 and	 rax, 131072		; 00020000H
  00151	48 85 c0	 test	 rax, rax
  00154	74 43		 je	 SHORT $LN29@LCS_StartL
  00156	48 8b 44 24 48	 mov	 rax, QWORD PTR pLCSPORT$[rsp]
  0015b	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  0015e	48 8b 4c 24 58	 mov	 rcx, QWORD PTR pDEVBLK$[rsp]
  00163	0f b7 49 48	 movzx	 ecx, WORD PTR [rcx+72]
  00167	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR [rsp+48], 0
  00170	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  00175	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG171105
  0017c	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00181	44 8b c9	 mov	 r9d, ecx
  00184	45 33 c0	 xor	 r8d, r8d
  00187	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG171106
  0018e	b9 00 00 02 00	 mov	 ecx, 131072		; 00020000H
  00193	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ptt_pthread_trace
$LN29@LCS_StartL:
  00199	33 c0		 xor	 eax, eax
  0019b	85 c0		 test	 eax, eax
  0019d	75 a2		 jne	 SHORT $LN7@LCS_StartL

; 1723 :     obtain_lock( &pLCSPORT->PortDataLock );

  0019f	48 8b 44 24 48	 mov	 rax, QWORD PTR pLCSPORT$[rsp]
  001a4	48 05 1c 01 00
	00		 add	 rax, 284		; 0000011cH
  001aa	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG171107
  001b1	48 8b c8	 mov	 rcx, rax
  001b4	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_obtain_lock
$LN10@LCS_StartL:

; 1724 :     PTT_DEBUG(        "GOT  PortDataLock ", 000, pDEVBLK->devnum, pLCSPORT->bPort );

  001ba	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_pttclass
  001c1	48 8b 00	 mov	 rax, QWORD PTR [rax]
  001c4	48 25 00 00 02
	00		 and	 rax, 131072		; 00020000H
  001ca	48 85 c0	 test	 rax, rax
  001cd	74 43		 je	 SHORT $LN30@LCS_StartL
  001cf	48 8b 44 24 48	 mov	 rax, QWORD PTR pLCSPORT$[rsp]
  001d4	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  001d7	48 8b 4c 24 58	 mov	 rcx, QWORD PTR pDEVBLK$[rsp]
  001dc	0f b7 49 48	 movzx	 ecx, WORD PTR [rcx+72]
  001e0	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR [rsp+48], 0
  001e9	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  001ee	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG171109
  001f5	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  001fa	44 8b c9	 mov	 r9d, ecx
  001fd	45 33 c0	 xor	 r8d, r8d
  00200	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG171110
  00207	b9 00 00 02 00	 mov	 ecx, 131072		; 00020000H
  0020c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ptt_pthread_trace
$LN30@LCS_StartL:
  00212	33 c0		 xor	 eax, eax
  00214	85 c0		 test	 eax, eax
  00216	75 a2		 jne	 SHORT $LN10@LCS_StartL
$LN13@LCS_StartL:

; 1725 :     {
; 1726 :         // Configure the TAP interface if used
; 1727 :         PTT_DEBUG( "STRTLAN if started", pLCSPORT->fPortStarted, pDEVBLK->devnum, pLCSPORT->bPort );

  00218	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_pttclass
  0021f	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00222	48 25 00 00 02
	00		 and	 rax, 131072		; 00020000H
  00228	48 85 c0	 test	 rax, rax
  0022b	74 56		 je	 SHORT $LN31@LCS_StartL
  0022d	48 8b 44 24 48	 mov	 rax, QWORD PTR pLCSPORT$[rsp]
  00232	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  00235	48 8b 4c 24 58	 mov	 rcx, QWORD PTR pDEVBLK$[rsp]
  0023a	0f b7 49 48	 movzx	 ecx, WORD PTR [rcx+72]
  0023e	48 8b 54 24 48	 mov	 rdx, QWORD PTR pLCSPORT$[rsp]
  00243	8b 92 34 01 00
	00		 mov	 edx, DWORD PTR [rdx+308]
  00249	c1 ea 03	 shr	 edx, 3
  0024c	83 e2 01	 and	 edx, 1
  0024f	8b d2		 mov	 edx, edx
  00251	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR [rsp+48], 0
  0025a	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  0025f	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG171112
  00266	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  0026b	44 8b c9	 mov	 r9d, ecx
  0026e	44 8b c2	 mov	 r8d, edx
  00271	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG171113
  00278	b9 00 00 02 00	 mov	 ecx, 131072		; 00020000H
  0027d	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ptt_pthread_trace
$LN31@LCS_StartL:
  00283	33 c0		 xor	 eax, eax
  00285	85 c0		 test	 eax, eax
  00287	75 8f		 jne	 SHORT $LN13@LCS_StartL

; 1728 :         if (pLCSPORT->fUsed && pLCSPORT->fPortCreated && !pLCSPORT->fPortStarted)

  00289	48 8b 44 24 48	 mov	 rax, QWORD PTR pLCSPORT$[rsp]
  0028e	8b 80 34 01 00
	00		 mov	 eax, DWORD PTR [rax+308]
  00294	83 e0 01	 and	 eax, 1
  00297	85 c0		 test	 eax, eax
  00299	0f 84 2f 01 00
	00		 je	 $LN32@LCS_StartL
  0029f	48 8b 44 24 48	 mov	 rax, QWORD PTR pLCSPORT$[rsp]
  002a4	8b 80 34 01 00
	00		 mov	 eax, DWORD PTR [rax+308]
  002aa	c1 e8 02	 shr	 eax, 2
  002ad	83 e0 01	 and	 eax, 1
  002b0	85 c0		 test	 eax, eax
  002b2	0f 84 16 01 00
	00		 je	 $LN32@LCS_StartL
  002b8	48 8b 44 24 48	 mov	 rax, QWORD PTR pLCSPORT$[rsp]
  002bd	8b 80 34 01 00
	00		 mov	 eax, DWORD PTR [rax+308]
  002c3	c1 e8 03	 shr	 eax, 3
  002c6	83 e0 01	 and	 eax, 1
  002c9	85 c0		 test	 eax, eax
  002cb	0f 85 fd 00 00
	00		 jne	 $LN32@LCS_StartL
$LN16@LCS_StartL:

; 1729 :         {
; 1730 :             PTT_DEBUG( "STRTLAN started=NO", 000, pDEVBLK->devnum, pLCSPORT->bPort );

  002d1	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_pttclass
  002d8	48 8b 00	 mov	 rax, QWORD PTR [rax]
  002db	48 25 00 00 02
	00		 and	 rax, 131072		; 00020000H
  002e1	48 85 c0	 test	 rax, rax
  002e4	74 43		 je	 SHORT $LN33@LCS_StartL
  002e6	48 8b 44 24 48	 mov	 rax, QWORD PTR pLCSPORT$[rsp]
  002eb	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  002ee	48 8b 4c 24 58	 mov	 rcx, QWORD PTR pDEVBLK$[rsp]
  002f3	0f b7 49 48	 movzx	 ecx, WORD PTR [rcx+72]
  002f7	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR [rsp+48], 0
  00300	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  00305	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG171116
  0030c	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00311	44 8b c9	 mov	 r9d, ecx
  00314	45 33 c0	 xor	 r8d, r8d
  00317	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG171117
  0031e	b9 00 00 02 00	 mov	 ecx, 131072		; 00020000H
  00323	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ptt_pthread_trace
$LN33@LCS_StartL:
  00329	33 c0		 xor	 eax, eax
  0032b	85 c0		 test	 eax, eax
  0032d	75 a2		 jne	 SHORT $LN16@LCS_StartL

; 1731 :             nIFFlags =              // Interface flags

  0032f	c7 44 24 68 03
	00 00 00	 mov	 DWORD PTR nIFFlags$[rsp], 3

; 1732 :                 0
; 1733 :                 | IFF_UP            // (interface is being enabled)
; 1734 :                 | IFF_BROADCAST     // (interface broadcast addr is valid)
; 1735 :                 ;
; 1736 : 
; 1737 : #if defined( TUNTAP_IFF_RUNNING_NEEDED )
; 1738 : 
; 1739 :             nIFFlags |=             // ADDITIONAL Interface flags
; 1740 :                 0
; 1741 :                 | IFF_RUNNING       // (interface is ALSO operational)
; 1742 :                 ;
; 1743 : 
; 1744 : #endif /* defined( TUNTAP_IFF_RUNNING_NEEDED ) */
; 1745 : 
; 1746 :             // Enable the interface by turning on the IFF_UP flag...
; 1747 :             // This lets the packets start flowing...
; 1748 : 
; 1749 :             if (!pLCSPORT->fPreconfigured)

  00337	48 8b 44 24 48	 mov	 rax, QWORD PTR pLCSPORT$[rsp]
  0033c	8b 80 34 01 00
	00		 mov	 eax, DWORD PTR [rax+308]
  00342	c1 e8 06	 shr	 eax, 6
  00345	83 e0 01	 and	 eax, 1
  00348	85 c0		 test	 eax, eax
  0034a	75 7d		 jne	 SHORT $LN34@LCS_StartL
$LN19@LCS_StartL:

; 1750 :                 VERIFY( TUNTAP_SetFlags( pLCSPORT->szNetIfName, nIFFlags ) == 0 );

  0034c	48 8b 44 24 48	 mov	 rax, QWORD PTR pLCSPORT$[rsp]
  00351	48 05 48 01 00
	00		 add	 rax, 328		; 00000148H
  00357	8b 54 24 68	 mov	 edx, DWORD PTR nIFFlags$[rsp]
  0035b	48 8b c8	 mov	 rcx, rax
  0035e	e8 00 00 00 00	 call	 TUNTAP_SetFlags
  00363	85 c0		 test	 eax, eax
  00365	74 5c		 je	 SHORT $LN35@LCS_StartL
$LN22@LCS_StartL:
  00367	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG171120
  0036e	41 b8 d6 06 00
	00		 mov	 r8d, 1750		; 000006d6H
  00374	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG171121
  0037b	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG171122
  00382	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_logmsg
  00388	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_IsDebuggerPresent
  0038e	85 c0		 test	 eax, eax
  00390	74 20		 je	 SHORT $LN36@LCS_StartL
  00392	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG171124
  00399	41 b8 d6 06 00
	00		 mov	 r8d, 1750		; 000006d6H
  0039f	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG171125
  003a6	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG171126
  003ad	e8 00 00 00 00	 call	 DebuggerTrace
$LN36@LCS_StartL:
  003b2	33 c0		 xor	 eax, eax
  003b4	85 c0		 test	 eax, eax
  003b6	75 af		 jne	 SHORT $LN22@LCS_StartL
  003b8	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_IsDebuggerPresent
  003be	85 c0		 test	 eax, eax
  003c0	74 01		 je	 SHORT $LN37@LCS_StartL
  003c2	cc		 int	 3
$LN37@LCS_StartL:
$LN35@LCS_StartL:
  003c3	33 c0		 xor	 eax, eax
  003c5	85 c0		 test	 eax, eax
  003c7	75 83		 jne	 SHORT $LN19@LCS_StartL
$LN34@LCS_StartL:

; 1751 : 
; 1752 :             fStartPending = 1;

  003c9	c6 44 24 40 01	 mov	 BYTE PTR fStartPending$[rsp], 1
$LN32@LCS_StartL:
$LN25@LCS_StartL:

; 1753 : 
; 1754 : #ifdef OPTION_TUNTAP_DELADD_ROUTES
; 1755 : 
; 1756 :             // Add any needed extra routing entries the
; 1757 :             // user may have specified in their OAT file
; 1758 :             // to the host's routing table...
; 1759 : 
; 1760 :             if (!pLCSPORT->fPreconfigured)
; 1761 :             {
; 1762 :                 for (pLCSRTE = pLCSPORT->pRoutes; pLCSRTE; pLCSRTE = pLCSRTE->pNext)
; 1763 :                 {
; 1764 :                     VERIFY( TUNTAP_AddRoute( pLCSPORT->szNetIfName,
; 1765 :                                      pLCSRTE->pszNetAddr,
; 1766 :                                      pLCSRTE->pszNetMask,
; 1767 :                                      NULL,
; 1768 :                                      RTF_UP ) == 0 );
; 1769 :                 }
; 1770 :             }
; 1771 : #endif // OPTION_TUNTAP_DELADD_ROUTES
; 1772 :         }
; 1773 :     }
; 1774 :     PTT_DEBUG(         "REL  PortDataLock ", 000, pDEVBLK->devnum, pLCSPORT->bPort );

  003ce	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_pttclass
  003d5	48 8b 00	 mov	 rax, QWORD PTR [rax]
  003d8	48 25 00 00 02
	00		 and	 rax, 131072		; 00020000H
  003de	48 85 c0	 test	 rax, rax
  003e1	74 43		 je	 SHORT $LN38@LCS_StartL
  003e3	48 8b 44 24 48	 mov	 rax, QWORD PTR pLCSPORT$[rsp]
  003e8	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  003eb	48 8b 4c 24 58	 mov	 rcx, QWORD PTR pDEVBLK$[rsp]
  003f0	0f b7 49 48	 movzx	 ecx, WORD PTR [rcx+72]
  003f4	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR [rsp+48], 0
  003fd	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  00402	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG171129
  00409	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  0040e	44 8b c9	 mov	 r9d, ecx
  00411	45 33 c0	 xor	 r8d, r8d
  00414	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG171130
  0041b	b9 00 00 02 00	 mov	 ecx, 131072		; 00020000H
  00420	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ptt_pthread_trace
$LN38@LCS_StartL:
  00426	33 c0		 xor	 eax, eax
  00428	85 c0		 test	 eax, eax
  0042a	75 a2		 jne	 SHORT $LN25@LCS_StartL

; 1775 :     release_lock( &pLCSPORT->PortDataLock );

  0042c	48 8b 44 24 48	 mov	 rax, QWORD PTR pLCSPORT$[rsp]
  00431	48 05 1c 01 00
	00		 add	 rax, 284		; 0000011cH
  00437	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG171131
  0043e	48 8b c8	 mov	 rcx, rax
  00441	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_release_lock

; 1776 : 
; 1777 : #ifdef OPTION_TUNTAP_DELADD_ROUTES
; 1778 : 
; 1779 :     // Add a Point-To-Point routing entry to the
; 1780 :     // host's routing table for our interface...
; 1781 : 
; 1782 :     if (!pLCSPORT->fPreconfigured)
; 1783 :     {
; 1784 :         if (pLCSDEV->pszIPAddress)
; 1785 :         {
; 1786 :             VERIFY( TUNTAP_AddRoute( pLCSPORT->szNetIfName,
; 1787 :                              pLCSDEV->pszIPAddress,
; 1788 :                              "255.255.255.255",
; 1789 :                              NULL,
; 1790 :                              RTF_UP | RTF_HOST ) == 0 );
; 1791 :         }
; 1792 :     }
; 1793 : #endif // OPTION_TUNTAP_DELADD_ROUTES
; 1794 : 
; 1795 :     // PROGRAMMING NOTE: it's important to enqueue the reply frame BEFORE
; 1796 :     // we trigger the LCS_PortThread to start reading the adapter and
; 1797 :     // begin enqueuing Ethernet frames. This is so the guest receives
; 1798 :     // the reply to its cmd BEFORE it sees any Ethernet packets that might
; 1799 :     // result from its StartLAN cmd.
; 1800 : 
; 1801 :     LCS_EnqueueReplyFrame( pLCSDEV, (PLCSCMDHDR)pLCSSTRTFRM, iReplyLen );

  00447	48 63 44 24 50	 movsxd	 rax, DWORD PTR iReplyLen$[rsp]
  0044c	4c 8b c0	 mov	 r8, rax
  0044f	48 8b 54 24 60	 mov	 rdx, QWORD PTR pLCSSTRTFRM$[rsp]
  00454	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR pLCSDEV$[rsp]
  0045c	e8 00 00 00 00	 call	 LCS_EnqueueReplyFrame

; 1802 : 
; 1803 :     if (fStartPending)

  00461	0f b6 44 24 40	 movzx	 eax, BYTE PTR fStartPending$[rsp]
  00466	85 c0		 test	 eax, eax
  00468	74 14		 je	 SHORT $LN39@LCS_StartL

; 1804 :         UpdatePortStarted( TRUE, pDEVBLK, pLCSPORT );

  0046a	4c 8b 44 24 48	 mov	 r8, QWORD PTR pLCSPORT$[rsp]
  0046f	48 8b 54 24 58	 mov	 rdx, QWORD PTR pDEVBLK$[rsp]
  00474	b9 01 00 00 00	 mov	 ecx, 1
  00479	e8 00 00 00 00	 call	 UpdatePortStarted
$LN39@LCS_StartL:

; 1805 : }

  0047e	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  00486	48 33 cc	 xor	 rcx, rsp
  00489	e8 00 00 00 00	 call	 __security_check_cookie
  0048e	48 81 c4 a8 00
	00 00		 add	 rsp, 168		; 000000a8H
  00495	5f		 pop	 rdi
  00496	5e		 pop	 rsi
  00497	c3		 ret	 0
LCS_StartLan ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\ctc_lcs.c
_TEXT	SEGMENT
iReplyLen$ = 32
pLCSSTDFRM$ = 40
tv73 = 48
Reply$ = 56
__$ArrayPad$ = 80
pLCSDEV$ = 128
pCmdFrame$ = 136
iCmdLen$ = 144
LCS_Shutdown PROC

; 1642 : {

  00000	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	56		 push	 rsi
  00010	57		 push	 rdi
  00011	48 83 ec 68	 sub	 rsp, 104		; 00000068H
  00015	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  0001c	48 33 c4	 xor	 rax, rsp
  0001f	48 89 44 24 50	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 1643 : //    char        Reply[128];
; 1644 :     LCSSTDFRM   Reply;
; 1645 :     int         iReplyLen = sizeof(Reply);  /* Used and changed by INIT_REPLY_FRAME */

  00024	c7 44 24 20 14
	00 00 00	 mov	 DWORD PTR iReplyLen$[rsp], 20

; 1646 :     PLCSSTDFRM  pLCSSTDFRM = (PLCSSTDFRM)&Reply;

  0002c	48 8d 44 24 38	 lea	 rax, QWORD PTR Reply$[rsp]
  00031	48 89 44 24 28	 mov	 QWORD PTR pLCSSTDFRM$[rsp], rax
$LN4@LCS_Shutdo:

; 1647 : 
; 1648 :     INIT_REPLY_FRAME( pLCSSTDFRM, iReplyLen, pCmdFrame, iCmdLen );

  00036	8b 44 24 20	 mov	 eax, DWORD PTR iReplyLen$[rsp]
  0003a	39 84 24 90 00
	00 00		 cmp	 DWORD PTR iCmdLen$[rsp], eax
  00041	7c 19		 jl	 SHORT $LN5@LCS_Shutdo
  00043	48 63 44 24 20	 movsxd	 rax, DWORD PTR iReplyLen$[rsp]
  00048	48 8b 7c 24 28	 mov	 rdi, QWORD PTR pLCSSTDFRM$[rsp]
  0004d	48 8b b4 24 88
	00 00 00	 mov	 rsi, QWORD PTR pCmdFrame$[rsp]
  00055	48 8b c8	 mov	 rcx, rax
  00058	f3 a4		 rep movsb
  0005a	eb 3d		 jmp	 SHORT $LN6@LCS_Shutdo
$LN5@LCS_Shutdo:
  0005c	48 63 44 24 20	 movsxd	 rax, DWORD PTR iReplyLen$[rsp]
  00061	48 89 44 24 30	 mov	 QWORD PTR tv73[rsp], rax
  00066	48 8b 7c 24 28	 mov	 rdi, QWORD PTR pLCSSTDFRM$[rsp]
  0006b	33 c0		 xor	 eax, eax
  0006d	48 8b 4c 24 30	 mov	 rcx, QWORD PTR tv73[rsp]
  00072	f3 aa		 rep stosb
  00074	48 63 84 24 90
	00 00 00	 movsxd	 rax, DWORD PTR iCmdLen$[rsp]
  0007c	48 8b 7c 24 28	 mov	 rdi, QWORD PTR pLCSSTDFRM$[rsp]
  00081	48 8b b4 24 88
	00 00 00	 mov	 rsi, QWORD PTR pCmdFrame$[rsp]
  00089	48 8b c8	 mov	 rcx, rax
  0008c	f3 a4		 rep movsb
  0008e	8b 84 24 90 00
	00 00		 mov	 eax, DWORD PTR iCmdLen$[rsp]
  00095	89 44 24 20	 mov	 DWORD PTR iReplyLen$[rsp], eax
$LN6@LCS_Shutdo:
  00099	33 c9		 xor	 ecx, ecx
  0009b	e8 00 00 00 00	 call	 _byteswap_ushort
  000a0	48 8b 4c 24 28	 mov	 rcx, QWORD PTR pLCSSTDFRM$[rsp]
  000a5	0f b7 d0	 movzx	 edx, ax
  000a8	e8 00 00 00 00	 call	 store_hw_noswap
  000ad	33 c9		 xor	 ecx, ecx
  000af	e8 00 00 00 00	 call	 _byteswap_ushort
  000b4	48 8b 4c 24 28	 mov	 rcx, QWORD PTR pLCSSTDFRM$[rsp]
  000b9	48 83 c1 08	 add	 rcx, 8
  000bd	0f b7 d0	 movzx	 edx, ax
  000c0	e8 00 00 00 00	 call	 store_hw_noswap
  000c5	33 c0		 xor	 eax, eax
  000c7	85 c0		 test	 eax, eax
  000c9	0f 85 67 ff ff
	ff		 jne	 $LN4@LCS_Shutdo

; 1649 : 
; 1650 :     pLCSSTDFRM->bLCSCmdHdr.bLanType      = LCS_FRMTYP_ENET;

  000cf	48 8b 44 24 28	 mov	 rax, QWORD PTR pLCSSTDFRM$[rsp]
  000d4	c6 40 0a 01	 mov	 BYTE PTR [rax+10], 1

; 1651 :     pLCSSTDFRM->bLCSCmdHdr.bRelAdapterNo = pLCSDEV->bPort;

  000d8	48 8b 44 24 28	 mov	 rax, QWORD PTR pLCSSTDFRM$[rsp]
  000dd	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR pLCSDEV$[rsp]
  000e5	0f b6 49 23	 movzx	 ecx, BYTE PTR [rcx+35]
  000e9	88 48 0b	 mov	 BYTE PTR [rax+11], cl

; 1652 : 
; 1653 :     LCS_EnqueueReplyFrame( pLCSDEV, (PLCSCMDHDR)pLCSSTDFRM, iReplyLen );

  000ec	48 63 44 24 20	 movsxd	 rax, DWORD PTR iReplyLen$[rsp]
  000f1	4c 8b c0	 mov	 r8, rax
  000f4	48 8b 54 24 28	 mov	 rdx, QWORD PTR pLCSSTDFRM$[rsp]
  000f9	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR pLCSDEV$[rsp]
  00101	e8 00 00 00 00	 call	 LCS_EnqueueReplyFrame

; 1654 : 
; 1655 :     pLCSDEV->fDevStarted = 0;

  00106	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR pLCSDEV$[rsp]
  0010e	8b 40 41	 mov	 eax, DWORD PTR [rax+65]
  00111	83 e0 fd	 and	 eax, -3			; fffffffdH
  00114	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR pLCSDEV$[rsp]
  0011c	89 41 41	 mov	 DWORD PTR [rcx+65], eax

; 1656 : }

  0011f	48 8b 4c 24 50	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  00124	48 33 cc	 xor	 rcx, rsp
  00127	e8 00 00 00 00	 call	 __security_check_cookie
  0012c	48 83 c4 68	 add	 rsp, 104		; 00000068H
  00130	5f		 pop	 rdi
  00131	5e		 pop	 rsi
  00132	c3		 ret	 0
LCS_Shutdown ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\ctc_lcs.c
_TEXT	SEGMENT
iOrigMaxFrameBufferSize$ = 96
iReplyLen$ = 100
pLCSSTRTFRM$ = 104
tv143 = 112
tv149 = 116
tv156 = 120
tv174 = 124
tv180 = 128
tv187 = 132
tv73 = 136
Reply$ = 144
__$ArrayPad$ = 168
pLCSDEV$ = 208
pCmdFrame$ = 216
iCmdLen$ = 224
LCS_Startup PROC

; 1588 : {

  00000	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	56		 push	 rsi
  00010	57		 push	 rdi
  00011	48 81 ec b8 00
	00 00		 sub	 rsp, 184		; 000000b8H
  00018	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  0001f	48 33 c4	 xor	 rax, rsp
  00022	48 89 84 24 a8
	00 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 1589 :     LCSSTRTFRM  Reply;
; 1590 :     int         iReplyLen = sizeof(Reply);  /* Used and changed by INIT_REPLY_FRAME */

  0002a	c7 44 24 64 18
	00 00 00	 mov	 DWORD PTR iReplyLen$[rsp], 24

; 1591 :     PLCSSTRTFRM pLCSSTRTFRM = (PLCSSTRTFRM)&Reply;

  00032	48 8d 84 24 90
	00 00 00	 lea	 rax, QWORD PTR Reply$[rsp]
  0003a	48 89 44 24 68	 mov	 QWORD PTR pLCSSTRTFRM$[rsp], rax
$LN4@LCS_Startu:

; 1592 :     U16         iOrigMaxFrameBufferSize;
; 1593 : 
; 1594 :     INIT_REPLY_FRAME( pLCSSTRTFRM, iReplyLen, pCmdFrame, iCmdLen );

  0003f	8b 44 24 64	 mov	 eax, DWORD PTR iReplyLen$[rsp]
  00043	39 84 24 e0 00
	00 00		 cmp	 DWORD PTR iCmdLen$[rsp], eax
  0004a	7c 19		 jl	 SHORT $LN5@LCS_Startu
  0004c	48 63 44 24 64	 movsxd	 rax, DWORD PTR iReplyLen$[rsp]
  00051	48 8b 7c 24 68	 mov	 rdi, QWORD PTR pLCSSTRTFRM$[rsp]
  00056	48 8b b4 24 d8
	00 00 00	 mov	 rsi, QWORD PTR pCmdFrame$[rsp]
  0005e	48 8b c8	 mov	 rcx, rax
  00061	f3 a4		 rep movsb
  00063	eb 43		 jmp	 SHORT $LN6@LCS_Startu
$LN5@LCS_Startu:
  00065	48 63 44 24 64	 movsxd	 rax, DWORD PTR iReplyLen$[rsp]
  0006a	48 89 84 24 88
	00 00 00	 mov	 QWORD PTR tv73[rsp], rax
  00072	48 8b 7c 24 68	 mov	 rdi, QWORD PTR pLCSSTRTFRM$[rsp]
  00077	33 c0		 xor	 eax, eax
  00079	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR tv73[rsp]
  00081	f3 aa		 rep stosb
  00083	48 63 84 24 e0
	00 00 00	 movsxd	 rax, DWORD PTR iCmdLen$[rsp]
  0008b	48 8b 7c 24 68	 mov	 rdi, QWORD PTR pLCSSTRTFRM$[rsp]
  00090	48 8b b4 24 d8
	00 00 00	 mov	 rsi, QWORD PTR pCmdFrame$[rsp]
  00098	48 8b c8	 mov	 rcx, rax
  0009b	f3 a4		 rep movsb
  0009d	8b 84 24 e0 00
	00 00		 mov	 eax, DWORD PTR iCmdLen$[rsp]
  000a4	89 44 24 64	 mov	 DWORD PTR iReplyLen$[rsp], eax
$LN6@LCS_Startu:
  000a8	33 c9		 xor	 ecx, ecx
  000aa	e8 00 00 00 00	 call	 _byteswap_ushort
  000af	48 8b 4c 24 68	 mov	 rcx, QWORD PTR pLCSSTRTFRM$[rsp]
  000b4	0f b7 d0	 movzx	 edx, ax
  000b7	e8 00 00 00 00	 call	 store_hw_noswap
  000bc	33 c9		 xor	 ecx, ecx
  000be	e8 00 00 00 00	 call	 _byteswap_ushort
  000c3	48 8b 4c 24 68	 mov	 rcx, QWORD PTR pLCSSTRTFRM$[rsp]
  000c8	48 83 c1 08	 add	 rcx, 8
  000cc	0f b7 d0	 movzx	 edx, ax
  000cf	e8 00 00 00 00	 call	 store_hw_noswap
  000d4	33 c0		 xor	 eax, eax
  000d6	85 c0		 test	 eax, eax
  000d8	0f 85 61 ff ff
	ff		 jne	 $LN4@LCS_Startu

; 1595 : 
; 1596 :     pLCSSTRTFRM->bLCSCmdHdr.bLanType      = LCS_FRMTYP_ENET;

  000de	48 8b 44 24 68	 mov	 rax, QWORD PTR pLCSSTRTFRM$[rsp]
  000e3	c6 40 0a 01	 mov	 BYTE PTR [rax+10], 1

; 1597 :     pLCSSTRTFRM->bLCSCmdHdr.bRelAdapterNo = pLCSDEV->bPort;

  000e7	48 8b 44 24 68	 mov	 rax, QWORD PTR pLCSSTRTFRM$[rsp]
  000ec	48 8b 8c 24 d0
	00 00 00	 mov	 rcx, QWORD PTR pLCSDEV$[rsp]
  000f4	0f b6 49 23	 movzx	 ecx, BYTE PTR [rcx+35]
  000f8	88 48 0b	 mov	 BYTE PTR [rax+11], cl

; 1598 : 
; 1599 :     // Save the max buffer size parameter
; 1600 :     iOrigMaxFrameBufferSize = pLCSDEV->iMaxFrameBufferSize;

  000fb	48 8b 84 24 d0
	00 00 00	 mov	 rax, QWORD PTR pLCSDEV$[rsp]
  00103	0f b7 80 a4 00
	00 00		 movzx	 eax, WORD PTR [rax+164]
  0010a	66 89 44 24 60	 mov	 WORD PTR iOrigMaxFrameBufferSize$[rsp], ax

; 1601 :     // If original is 0 set to compiled in buffer size
; 1602 :     if(!iOrigMaxFrameBufferSize) iOrigMaxFrameBufferSize=(U16)sizeof(pLCSDEV->bFrameBuffer);

  0010f	0f b7 44 24 60	 movzx	 eax, WORD PTR iOrigMaxFrameBufferSize$[rsp]
  00114	85 c0		 test	 eax, eax
  00116	75 0a		 jne	 SHORT $LN7@LCS_Startu
  00118	b8 00 50 00 00	 mov	 eax, 20480		; 00005000H
  0011d	66 89 44 24 60	 mov	 WORD PTR iOrigMaxFrameBufferSize$[rsp], ax
$LN7@LCS_Startu:

; 1603 : 
; 1604 :     FETCH_HW( pLCSDEV->iMaxFrameBufferSize, ((PLCSSTRTFRM)pCmdFrame)->hwBufferSize );

  00122	48 8b 84 24 d8
	00 00 00	 mov	 rax, QWORD PTR pCmdFrame$[rsp]
  0012a	48 83 c0 0c	 add	 rax, 12
  0012e	48 8b c8	 mov	 rcx, rax
  00131	e8 00 00 00 00	 call	 fetch_hw_noswap
  00136	0f b7 c8	 movzx	 ecx, ax
  00139	e8 00 00 00 00	 call	 _byteswap_ushort
  0013e	48 8b 8c 24 d0
	00 00 00	 mov	 rcx, QWORD PTR pLCSDEV$[rsp]
  00146	66 89 81 a4 00
	00 00		 mov	 WORD PTR [rcx+164], ax

; 1605 : 
; 1606 :     // Make sure it doesn't exceed our compiled maximum
; 1607 :     if (pLCSDEV->iMaxFrameBufferSize > sizeof(pLCSDEV->bFrameBuffer))

  0014d	48 8b 84 24 d0
	00 00 00	 mov	 rax, QWORD PTR pLCSDEV$[rsp]
  00155	0f b7 80 a4 00
	00 00		 movzx	 eax, WORD PTR [rax+164]
  0015c	48 3d 00 50 00
	00		 cmp	 rax, 20480		; 00005000H
  00162	0f 86 dd 00 00
	00		 jbe	 $LN8@LCS_Startu

; 1608 :     {
; 1609 :         // "%1d:%04X CTC: lcs startup: frame buffer size 0x%4.4X '%s' compiled size 0x%4.4X: ignored"
; 1610 :         WRMSG(HHC00939, "W", SSID_TO_LCSS(pLCSDEV->pDEVBLK[LCS_WRITE_SUBCHANN]->ssid),

  00168	48 8b 84 24 d0
	00 00 00	 mov	 rax, QWORD PTR pLCSDEV$[rsp]
  00170	0f b7 80 a4 00
	00 00		 movzx	 eax, WORD PTR [rax+164]
  00177	89 44 24 70	 mov	 DWORD PTR tv143[rsp], eax
  0017b	b9 08 00 00 00	 mov	 ecx, 8
  00180	48 6b c9 01	 imul	 rcx, rcx, 1
  00184	48 8b 94 24 d0
	00 00 00	 mov	 rdx, QWORD PTR pLCSDEV$[rsp]
  0018c	48 8b 4c 0a 10	 mov	 rcx, QWORD PTR [rdx+rcx+16]
  00191	0f b7 49 48	 movzx	 ecx, WORD PTR [rcx+72]
  00195	89 4c 24 74	 mov	 DWORD PTR tv149[rsp], ecx
  00199	ba 08 00 00 00	 mov	 edx, 8
  0019e	48 6b d2 01	 imul	 rdx, rdx, 1
  001a2	48 8b bc 24 d0
	00 00 00	 mov	 rdi, QWORD PTR pLCSDEV$[rsp]
  001aa	48 8b 54 17 10	 mov	 rdx, QWORD PTR [rdi+rdx+16]
  001af	0f b7 52 44	 movzx	 edx, WORD PTR [rdx+68]
  001b3	d1 fa		 sar	 edx, 1
  001b5	89 54 24 78	 mov	 DWORD PTR tv156[rsp], edx
  001b9	b9 01 00 00 00	 mov	 ecx, 1
  001be	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  001c4	c7 44 24 58 00
	50 00 00	 mov	 DWORD PTR [rsp+88], 20480 ; 00005000H
  001cc	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170876
  001d3	48 89 4c 24 50	 mov	 QWORD PTR [rsp+80], rcx
  001d8	8b 4c 24 70	 mov	 ecx, DWORD PTR tv143[rsp]
  001dc	89 4c 24 48	 mov	 DWORD PTR [rsp+72], ecx
  001e0	8b 4c 24 74	 mov	 ecx, DWORD PTR tv149[rsp]
  001e4	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  001e8	8b 4c 24 78	 mov	 ecx, DWORD PTR tv156[rsp]
  001ec	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  001f0	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170877
  001f7	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  001fc	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170878
  00203	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00208	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  0020d	41 b9 03 00 00
	00		 mov	 r9d, 3
  00213	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG170879
  0021a	ba 4e 06 00 00	 mov	 edx, 1614		; 0000064eH
  0021f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170880
  00226	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 1611 :             pLCSDEV->pDEVBLK[LCS_WRITE_SUBCHANN]->devnum,
; 1612 :             pLCSDEV->iMaxFrameBufferSize,
; 1613 :             "LCS",
; 1614 :             (int)sizeof( pLCSDEV->bFrameBuffer ) );
; 1615 :         pLCSDEV->iMaxFrameBufferSize = iOrigMaxFrameBufferSize;

  0022c	48 8b 84 24 d0
	00 00 00	 mov	 rax, QWORD PTR pLCSDEV$[rsp]
  00234	0f b7 4c 24 60	 movzx	 ecx, WORD PTR iOrigMaxFrameBufferSize$[rsp]
  00239	66 89 88 a4 00
	00 00		 mov	 WORD PTR [rax+164], cx

; 1616 :     }

  00240	e9 fe 00 00 00	 jmp	 $LN9@LCS_Startu
$LN8@LCS_Startu:

; 1617 :     else
; 1618 :     {
; 1619 :         // Make sure it's not smaller than the compiled minimum size
; 1620 :         if (pLCSDEV->iMaxFrameBufferSize < CTC_MIN_FRAME_BUFFER_SIZE)

  00245	48 8b 84 24 d0
	00 00 00	 mov	 rax, QWORD PTR pLCSDEV$[rsp]
  0024d	0f b7 80 a4 00
	00 00		 movzx	 eax, WORD PTR [rax+164]
  00254	3d 00 40 00 00	 cmp	 eax, 16384		; 00004000H
  00259	0f 8d e4 00 00
	00		 jge	 $LN10@LCS_Startu

; 1621 :         {
; 1622 :             // "%1d:%04X CTC: lcs startup: frame buffer size 0x%4.4X '%s' compiled size 0x%4.4X: ignored"
; 1623 :             WRMSG(HHC00939, "W", SSID_TO_LCSS(pLCSDEV->pDEVBLK[LCS_WRITE_SUBCHANN]->ssid),

  0025f	48 8b 84 24 d0
	00 00 00	 mov	 rax, QWORD PTR pLCSDEV$[rsp]
  00267	0f b7 80 a4 00
	00 00		 movzx	 eax, WORD PTR [rax+164]
  0026e	89 44 24 7c	 mov	 DWORD PTR tv174[rsp], eax
  00272	b9 08 00 00 00	 mov	 ecx, 8
  00277	48 6b c9 01	 imul	 rcx, rcx, 1
  0027b	48 8b 94 24 d0
	00 00 00	 mov	 rdx, QWORD PTR pLCSDEV$[rsp]
  00283	48 8b 4c 0a 10	 mov	 rcx, QWORD PTR [rdx+rcx+16]
  00288	0f b7 49 48	 movzx	 ecx, WORD PTR [rcx+72]
  0028c	89 8c 24 80 00
	00 00		 mov	 DWORD PTR tv180[rsp], ecx
  00293	ba 08 00 00 00	 mov	 edx, 8
  00298	48 6b d2 01	 imul	 rdx, rdx, 1
  0029c	48 8b bc 24 d0
	00 00 00	 mov	 rdi, QWORD PTR pLCSDEV$[rsp]
  002a4	48 8b 54 17 10	 mov	 rdx, QWORD PTR [rdi+rdx+16]
  002a9	0f b7 52 44	 movzx	 edx, WORD PTR [rdx+68]
  002ad	d1 fa		 sar	 edx, 1
  002af	89 94 24 84 00
	00 00		 mov	 DWORD PTR tv187[rsp], edx
  002b6	b9 01 00 00 00	 mov	 ecx, 1
  002bb	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  002c1	c7 44 24 58 00
	40 00 00	 mov	 DWORD PTR [rsp+88], 16384 ; 00004000H
  002c9	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170882
  002d0	48 89 4c 24 50	 mov	 QWORD PTR [rsp+80], rcx
  002d5	8b 4c 24 7c	 mov	 ecx, DWORD PTR tv174[rsp]
  002d9	89 4c 24 48	 mov	 DWORD PTR [rsp+72], ecx
  002dd	8b 8c 24 80 00
	00 00		 mov	 ecx, DWORD PTR tv180[rsp]
  002e4	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  002e8	8b 8c 24 84 00
	00 00		 mov	 ecx, DWORD PTR tv187[rsp]
  002ef	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  002f3	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170883
  002fa	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  002ff	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170884
  00306	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  0030b	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00310	41 b9 03 00 00
	00		 mov	 r9d, 3
  00316	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG170885
  0031d	ba 5b 06 00 00	 mov	 edx, 1627		; 0000065bH
  00322	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170886
  00329	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 1624 :                 pLCSDEV->pDEVBLK[LCS_WRITE_SUBCHANN]->devnum,
; 1625 :                 pLCSDEV->iMaxFrameBufferSize,
; 1626 :                 "LCS",
; 1627 :                 CTC_MIN_FRAME_BUFFER_SIZE );
; 1628 :             pLCSDEV->iMaxFrameBufferSize = iOrigMaxFrameBufferSize;

  0032f	48 8b 84 24 d0
	00 00 00	 mov	 rax, QWORD PTR pLCSDEV$[rsp]
  00337	0f b7 4c 24 60	 movzx	 ecx, WORD PTR iOrigMaxFrameBufferSize$[rsp]
  0033c	66 89 88 a4 00
	00 00		 mov	 WORD PTR [rax+164], cx
$LN10@LCS_Startu:
$LN9@LCS_Startu:

; 1629 :         }
; 1630 :     }
; 1631 : 
; 1632 :     LCS_EnqueueReplyFrame( pLCSDEV, (PLCSCMDHDR)pLCSSTRTFRM, iReplyLen );

  00343	48 63 44 24 64	 movsxd	 rax, DWORD PTR iReplyLen$[rsp]
  00348	4c 8b c0	 mov	 r8, rax
  0034b	48 8b 54 24 68	 mov	 rdx, QWORD PTR pLCSSTRTFRM$[rsp]
  00350	48 8b 8c 24 d0
	00 00 00	 mov	 rcx, QWORD PTR pLCSDEV$[rsp]
  00358	e8 00 00 00 00	 call	 LCS_EnqueueReplyFrame

; 1633 : 
; 1634 :     pLCSDEV->fDevStarted = 1;

  0035d	48 8b 84 24 d0
	00 00 00	 mov	 rax, QWORD PTR pLCSDEV$[rsp]
  00365	8b 40 41	 mov	 eax, DWORD PTR [rax+65]
  00368	83 c8 02	 or	 eax, 2
  0036b	48 8b 8c 24 d0
	00 00 00	 mov	 rcx, QWORD PTR pLCSDEV$[rsp]
  00373	89 41 41	 mov	 DWORD PTR [rcx+65], eax

; 1635 : }

  00376	48 8b 8c 24 a8
	00 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  0037e	48 33 cc	 xor	 rcx, rsp
  00381	e8 00 00 00 00	 call	 __security_check_cookie
  00386	48 81 c4 b8 00
	00 00		 add	 rsp, 184		; 000000b8H
  0038d	5f		 pop	 rdi
  0038e	5e		 pop	 rsi
  0038f	c3		 ret	 0
LCS_Startup ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\ctc_lcs.c
_TEXT	SEGMENT
tv164 = 80
tv185 = 84
tv161 = 88
tv182 = 96
ifr$ = 104
mac$ = 136
__$ArrayPad$ = 144
pLCSPORT$ = 192
LCS_Assist PROC

; 591  : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	56		 push	 rsi
  00006	57		 push	 rdi
  00007	48 81 ec a8 00
	00 00		 sub	 rsp, 168		; 000000a8H
  0000e	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00015	48 33 c4	 xor	 rax, rsp
  00018	48 89 84 24 90
	00 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 592  : #if defined( SIOCGIFHWADDR )
; 593  :     MAC    mac  = { 0x01, 0x00, 0x5e, 0x00, 0x00, 0x01 };

  00020	c6 84 24 88 00
	00 00 01	 mov	 BYTE PTR mac$[rsp], 1
  00028	c6 84 24 89 00
	00 00 00	 mov	 BYTE PTR mac$[rsp+1], 0
  00030	c6 84 24 8a 00
	00 00 5e	 mov	 BYTE PTR mac$[rsp+2], 94 ; 0000005eH
  00038	c6 84 24 8b 00
	00 00 00	 mov	 BYTE PTR mac$[rsp+3], 0
  00040	c6 84 24 8c 00
	00 00 00	 mov	 BYTE PTR mac$[rsp+4], 0
  00048	c6 84 24 8d 00
	00 00 01	 mov	 BYTE PTR mac$[rsp+5], 1

; 594  :     ifreq  ifr  = {0};

  00050	48 8d 44 24 68	 lea	 rax, QWORD PTR ifr$[rsp]
  00055	48 8b f8	 mov	 rdi, rax
  00058	33 c0		 xor	 eax, eax
  0005a	b9 20 00 00 00	 mov	 ecx, 32			; 00000020H
  0005f	f3 aa		 rep stosb

; 595  : #endif
; 596  : 
; 597  :     // We shall always support the following assists for the guest.
; 598  : 
; 599  :     pLCSPORT->sIPAssistsSupported |= LCS_MULTICAST_SUPPORT;

  00061	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR pLCSPORT$[rsp]
  00069	0f b7 80 18 01
	00 00		 movzx	 eax, WORD PTR [rax+280]
  00070	83 c8 40	 or	 eax, 64			; 00000040H
  00073	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR pLCSPORT$[rsp]
  0007b	66 89 81 18 01
	00 00		 mov	 WORD PTR [rcx+280], ax

; 600  :     pLCSPORT->sIPAssistsEnabled   |= LCS_MULTICAST_SUPPORT;

  00082	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR pLCSPORT$[rsp]
  0008a	0f b7 80 1a 01
	00 00		 movzx	 eax, WORD PTR [rax+282]
  00091	83 c8 40	 or	 eax, 64			; 00000040H
  00094	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR pLCSPORT$[rsp]
  0009c	66 89 81 1a 01
	00 00		 mov	 WORD PTR [rcx+282], ax

; 601  : 
; 602  :     pLCSPORT->sIPAssistsSupported |= LCS_INBOUND_CHECKSUM_SUPPORT;

  000a3	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR pLCSPORT$[rsp]
  000ab	0f b7 80 18 01
	00 00		 movzx	 eax, WORD PTR [rax+280]
  000b2	83 c8 02	 or	 eax, 2
  000b5	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR pLCSPORT$[rsp]
  000bd	66 89 81 18 01
	00 00		 mov	 WORD PTR [rcx+280], ax

; 603  :     pLCSPORT->sIPAssistsEnabled   |= LCS_INBOUND_CHECKSUM_SUPPORT;

  000c4	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR pLCSPORT$[rsp]
  000cc	0f b7 80 1a 01
	00 00		 movzx	 eax, WORD PTR [rax+282]
  000d3	83 c8 02	 or	 eax, 2
  000d6	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR pLCSPORT$[rsp]
  000de	66 89 81 1a 01
	00 00		 mov	 WORD PTR [rcx+282], ax

; 604  : 
; 605  :     pLCSPORT->sIPAssistsSupported |= LCS_OUTBOUND_CHECKSUM_SUPPORT;

  000e5	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR pLCSPORT$[rsp]
  000ed	0f b7 80 18 01
	00 00		 movzx	 eax, WORD PTR [rax+280]
  000f4	83 c8 04	 or	 eax, 4
  000f7	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR pLCSPORT$[rsp]
  000ff	66 89 81 18 01
	00 00		 mov	 WORD PTR [rcx+280], ax

; 606  :     pLCSPORT->sIPAssistsEnabled   |= LCS_OUTBOUND_CHECKSUM_SUPPORT;

  00106	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR pLCSPORT$[rsp]
  0010e	0f b7 80 1a 01
	00 00		 movzx	 eax, WORD PTR [rax+282]
  00115	83 c8 04	 or	 eax, 4
  00118	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR pLCSPORT$[rsp]
  00120	66 89 81 1a 01
	00 00		 mov	 WORD PTR [rcx+282], ax

; 607  : 
; 608  :     // Check if tuntap can handle the multicast assist for us.
; 609  : 
; 610  : #if defined( SIOCGIFHWADDR )
; 611  :     STRLCPY( ifr.ifr_name, pLCSPORT->szNetIfName );

  00127	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR pLCSPORT$[rsp]
  0012f	48 05 48 01 00
	00		 add	 rax, 328		; 00000148H
  00135	41 b8 10 00 00
	00		 mov	 r8d, 16
  0013b	48 8b d0	 mov	 rdx, rax
  0013e	48 8d 4c 24 68	 lea	 rcx, QWORD PTR ifr$[rsp]
  00143	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_strlcpy

; 612  :     memcpy( ifr.ifr_hwaddr.sa_data, mac, sizeof( MAC ));

  00149	48 8d 44 24 7a	 lea	 rax, QWORD PTR ifr$[rsp+18]
  0014e	48 8d 8c 24 88
	00 00 00	 lea	 rcx, QWORD PTR mac$[rsp]
  00156	48 8b f8	 mov	 rdi, rax
  00159	48 8b f1	 mov	 rsi, rcx
  0015c	b9 06 00 00 00	 mov	 ecx, 6
  00161	f3 a4		 rep movsb

; 613  : 
; 614  :     if (TUNTAP_IOCtl( pLCSPORT->fd, SIOCADDMULTI, (char*) &ifr ) == 0)

  00163	4c 8d 44 24 68	 lea	 r8, QWORD PTR ifr$[rsp]
  00168	ba 31 89 00 00	 mov	 edx, 35121		; 00008931H
  0016d	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR pLCSPORT$[rsp]
  00175	8b 88 38 01 00
	00		 mov	 ecx, DWORD PTR [rax+312]
  0017b	e8 00 00 00 00	 call	 tt32_ioctl
  00180	85 c0		 test	 eax, eax
  00182	75 3f		 jne	 SHORT $LN2@LCS_Assist

; 615  :     {
; 616  :         TUNTAP_IOCtl( pLCSPORT->fd, SIOCDELMULTI, (char*) &ifr );

  00184	4c 8d 44 24 68	 lea	 r8, QWORD PTR ifr$[rsp]
  00189	ba 32 89 00 00	 mov	 edx, 35122		; 00008932H
  0018e	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR pLCSPORT$[rsp]
  00196	8b 88 38 01 00
	00		 mov	 ecx, DWORD PTR [rax+312]
  0019c	e8 00 00 00 00	 call	 tt32_ioctl

; 617  :         pLCSPORT->fDoMCastAssist = 0;   // (tuntap does it for us)

  001a1	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR pLCSPORT$[rsp]
  001a9	8b 80 34 01 00
	00		 mov	 eax, DWORD PTR [rax+308]
  001af	0f ba f0 08	 btr	 eax, 8
  001b3	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR pLCSPORT$[rsp]
  001bb	89 81 34 01 00
	00		 mov	 DWORD PTR [rcx+308], eax

; 618  :     }

  001c1	eb 20		 jmp	 SHORT $LN3@LCS_Assist
$LN2@LCS_Assist:

; 619  :     else
; 620  : #endif // !defined( SIOCGIFHWADDR )
; 621  :         pLCSPORT->fDoMCastAssist = 1;   // (we must do it ourself)

  001c3	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR pLCSPORT$[rsp]
  001cb	8b 80 34 01 00
	00		 mov	 eax, DWORD PTR [rax+308]
  001d1	0f ba e8 08	 bts	 eax, 8
  001d5	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR pLCSPORT$[rsp]
  001dd	89 81 34 01 00
	00		 mov	 DWORD PTR [rcx+308], eax
$LN3@LCS_Assist:

; 622  : 
; 623  :     // "CTC: lcs device port %2.2X: %s Multicast assist enabled"
; 624  :     WRMSG( HHC00921, "I", pLCSPORT->bPort,

  001e3	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR pLCSPORT$[rsp]
  001eb	8b 80 34 01 00
	00		 mov	 eax, DWORD PTR [rax+308]
  001f1	c1 e8 08	 shr	 eax, 8
  001f4	83 e0 01	 and	 eax, 1
  001f7	85 c0		 test	 eax, eax
  001f9	74 0e		 je	 SHORT $LN5@LCS_Assist
  001fb	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG169664
  00202	48 89 44 24 58	 mov	 QWORD PTR tv161[rsp], rax
  00207	eb 0c		 jmp	 SHORT $LN6@LCS_Assist
$LN5@LCS_Assist:
  00209	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG169665
  00210	48 89 44 24 58	 mov	 QWORD PTR tv161[rsp], rax
$LN6@LCS_Assist:
  00215	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR pLCSPORT$[rsp]
  0021d	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  00220	89 44 24 50	 mov	 DWORD PTR tv164[rsp], eax
  00224	b9 01 00 00 00	 mov	 ecx, 1
  00229	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  0022f	48 8b 4c 24 58	 mov	 rcx, QWORD PTR tv161[rsp]
  00234	48 89 4c 24 40	 mov	 QWORD PTR [rsp+64], rcx
  00239	8b 4c 24 50	 mov	 ecx, DWORD PTR tv164[rsp]
  0023d	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  00241	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169666
  00248	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  0024d	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169667
  00254	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00259	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  0025e	41 b9 03 00 00
	00		 mov	 r9d, 3
  00264	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG169668
  0026b	ba 71 02 00 00	 mov	 edx, 625		; 00000271H
  00270	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169669
  00277	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 625  :         pLCSPORT->fDoMCastAssist ? "manual" : "tuntap" );
; 626  : 
; 627  :     // Check if tuntap can do outbound checksum offloading for us.
; 628  : 
; 629  : #if 0 /* Disable for now. TAP Checksum offload seems broken */
; 630  : #if defined( TUNSETOFFLOAD ) && defined( TUN_F_CSUM )
; 631  :     if (TUNTAP_IOCtl( pLCSPORT->fd, TUNSETOFFLOAD, (char*) TUN_F_CSUM ) == 0)
; 632  :     {
; 633  :         pLCSPORT->fDoCkSumOffload = 0;    // (tuntap does it for us)
; 634  :     }
; 635  :     else
; 636  : #endif
; 637  : #endif
; 638  :         pLCSPORT->fDoCkSumOffload = 1;    // (we must do it ourself)

  0027d	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR pLCSPORT$[rsp]
  00285	8b 80 34 01 00
	00		 mov	 eax, DWORD PTR [rax+308]
  0028b	0f ba e8 07	 bts	 eax, 7
  0028f	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR pLCSPORT$[rsp]
  00297	89 81 34 01 00
	00		 mov	 DWORD PTR [rcx+308], eax

; 639  : 
; 640  :     // "CTC: lcs device port %2.2X: %s Checksum Offload enabled"
; 641  :     WRMSG( HHC00935, "I", pLCSPORT->bPort,

  0029d	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR pLCSPORT$[rsp]
  002a5	8b 80 34 01 00
	00		 mov	 eax, DWORD PTR [rax+308]
  002ab	c1 e8 07	 shr	 eax, 7
  002ae	83 e0 01	 and	 eax, 1
  002b1	85 c0		 test	 eax, eax
  002b3	74 0e		 je	 SHORT $LN7@LCS_Assist
  002b5	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG169670
  002bc	48 89 44 24 60	 mov	 QWORD PTR tv182[rsp], rax
  002c1	eb 0c		 jmp	 SHORT $LN8@LCS_Assist
$LN7@LCS_Assist:
  002c3	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG169671
  002ca	48 89 44 24 60	 mov	 QWORD PTR tv182[rsp], rax
$LN8@LCS_Assist:
  002cf	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR pLCSPORT$[rsp]
  002d7	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  002da	89 44 24 54	 mov	 DWORD PTR tv185[rsp], eax
  002de	b9 01 00 00 00	 mov	 ecx, 1
  002e3	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  002e9	48 8b 4c 24 60	 mov	 rcx, QWORD PTR tv182[rsp]
  002ee	48 89 4c 24 40	 mov	 QWORD PTR [rsp+64], rcx
  002f3	8b 4c 24 54	 mov	 ecx, DWORD PTR tv185[rsp]
  002f7	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  002fb	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169672
  00302	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  00307	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169673
  0030e	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00313	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00318	41 b9 03 00 00
	00		 mov	 r9d, 3
  0031e	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG169674
  00325	ba 82 02 00 00	 mov	 edx, 642		; 00000282H
  0032a	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169675
  00331	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 642  :         pLCSPORT->fDoCkSumOffload ? "manual" : "tuntap" );
; 643  : 
; 644  :     // Check if tuntap can also do segmentation offloading for us.
; 645  : 
; 646  : #if 0 /* Disable for now. TCP Segment Offload needs
; 647  :          to be enabled by stack using LCS */
; 648  : #if defined( TUNSETOFFLOAD ) && defined( TUN_F_TSO4 ) && defined( TUN_F_UFO )
; 649  :     /* Only do offload if doing TAP checksum offload */
; 650  :     if (!pLCSPORT->fDoCkSumOffload)
; 651  :     {
; 652  :         if (TUNTAP_IOCtl( pLCSPORT->fd, TUNSETOFFLOAD, (char*)(TUN_F_CSUM | TUN_F_TSO4 | TUN_F_UFO)) == 0)
; 653  :         {
; 654  :             VERIFY( TUNTAP_IOCtl( pLCSPORT->fd, TUNSETOFFLOAD, (char*) TUN_F_CSUM ) == 0);
; 655  :             pLCSPORT->sIPAssistsSupported |= LCS_IP_FRAG_REASSEMBLY;
; 656  :             /* Do Not ENABLE!! */
; 657  :             // pLCSPORT->sIPAssistsEnabled   |= LCS_IP_FRAG_REASSEMBLY;
; 658  :             // "CTC: lcs device port %2.2X: %s Large Send Offload supported"
; 659  :             WRMSG( HHC00938, "I", pLCSPORT->bPort, "tuntap" );
; 660  :         }
; 661  :     }
; 662  : #endif
; 663  : #endif
; 664  : }

  00337	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  0033f	48 33 cc	 xor	 rcx, rsp
  00342	e8 00 00 00 00	 call	 __security_check_cookie
  00347	48 81 c4 a8 00
	00 00		 add	 rsp, 168		; 000000a8H
  0034e	5f		 pop	 rdi
  0034f	5e		 pop	 rsi
  00350	c3		 ret	 0
LCS_Assist ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\ctc_lcs.c
_TEXT	SEGMENT
iEthLen$ = 112
iLength$ = 116
pCmdFrame$ = 120
iTraceLen$ = 128
iOffset$ = 132
pLCSBLK$ = 136
iPrevOffset$ = 144
nEthFrames$ = 148
nEthBytes$ = 152
pLCSDEV$ = 160
tv538 = 168
bHas8022$ = 172
bHas8022Snap$ = 173
pLCSHDR$ = 176
pEthFrame$ = 184
tv197 = 192
tv140 = 196
tv273 = 200
tv276 = 204
tv303 = 208
tv309 = 212
tv313 = 216
tv415 = 220
tv477 = 224
tv481 = 228
tv521 = 232
tv525 = 236
tv558 = 240
tv562 = 244
tv596 = 248
tv600 = 252
tv666 = 256
tv670 = 260
tv704 = 264
tv708 = 268
tv742 = 272
tv746 = 276
tv780 = 280
tv784 = 284
tv850 = 288
tv854 = 292
tv888 = 296
tv892 = 300
tv932 = 304
tv936 = 308
hwEthernetType$ = 312
tv971 = 316
tv975 = 320
tv78 = 324
tv82 = 328
tv130 = 332
tv136 = 336
tv968 = 340
pLCSPORT$ = 344
pLCSEthFrame$ = 352
tv270 = 360
tv408 = 368
tv412 = 376
cPktType$ = 384
buf$ = 408
__$ArrayPad$ = 440
pDEVBLK$ = 480
sCount$ = 488
pIOBuf$ = 496
pUnitStat$ = 504
pResidual$ = 512
LCS_Write PROC

; 1291 : {

  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  0000e	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00013	56		 push	 rsi
  00014	57		 push	 rdi
  00015	48 81 ec c8 01
	00 00		 sub	 rsp, 456		; 000001c8H
  0001c	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00023	48 33 c4	 xor	 rax, rsp
  00026	48 89 84 24 b8
	01 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 1292 : 
; 1293 :     PLCSDEV     pLCSDEV      = (PLCSDEV) pDEVBLK->dev_data;

  0002e	48 8b 84 24 e0
	01 00 00	 mov	 rax, QWORD PTR pDEVBLK$[rsp]
  00036	48 8b 80 08 06
	00 00		 mov	 rax, QWORD PTR [rax+1544]
  0003d	48 89 84 24 a0
	00 00 00	 mov	 QWORD PTR pLCSDEV$[rsp], rax

; 1294 :     PLCSBLK     pLCSBLK      = pLCSDEV->pLCSBLK;

  00045	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR pLCSDEV$[rsp]
  0004d	48 8b 40 08	 mov	 rax, QWORD PTR [rax+8]
  00051	48 89 84 24 88
	00 00 00	 mov	 QWORD PTR pLCSBLK$[rsp], rax

; 1295 :     PLCSPORT    pLCSPORT     = &pLCSBLK->Port[ pLCSDEV->bPort ];

  00059	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR pLCSDEV$[rsp]
  00061	0f b6 40 23	 movzx	 eax, BYTE PTR [rax+35]
  00065	48 69 c0 98 01
	00 00		 imul	 rax, rax, 408		; 00000198H
  0006c	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR pLCSBLK$[rsp]
  00074	48 8d 44 01 60	 lea	 rax, QWORD PTR [rcx+rax+96]
  00079	48 89 84 24 58
	01 00 00	 mov	 QWORD PTR pLCSPORT$[rsp], rax

; 1296 :     PLCSHDR     pLCSHDR      = NULL;

  00081	48 c7 84 24 b0
	00 00 00 00 00
	00 00		 mov	 QWORD PTR pLCSHDR$[rsp], 0

; 1297 :     PLCSCMDHDR  pCmdFrame    = NULL;

  0008d	48 c7 44 24 78
	00 00 00 00	 mov	 QWORD PTR pCmdFrame$[rsp], 0

; 1298 :     PLCSETHFRM  pLCSEthFrame = NULL;

  00096	48 c7 84 24 60
	01 00 00 00 00
	00 00		 mov	 QWORD PTR pLCSEthFrame$[rsp], 0

; 1299 :     PETHFRM     pEthFrame    = NULL;

  000a2	48 c7 84 24 b8
	00 00 00 00 00
	00 00		 mov	 QWORD PTR pEthFrame$[rsp], 0

; 1300 :     U16         iOffset      = 0;

  000ae	33 c0		 xor	 eax, eax
  000b0	66 89 84 24 84
	00 00 00	 mov	 WORD PTR iOffset$[rsp], ax

; 1301 :     U16         iPrevOffset  = 0;

  000b8	33 c0		 xor	 eax, eax
  000ba	66 89 84 24 90
	00 00 00	 mov	 WORD PTR iPrevOffset$[rsp], ax

; 1302 :     U16         iLength      = 0;

  000c2	33 c0		 xor	 eax, eax
  000c4	66 89 44 24 74	 mov	 WORD PTR iLength$[rsp], ax

; 1303 :     U16         iEthLen      = 0;

  000c9	33 c0		 xor	 eax, eax
  000cb	66 89 44 24 70	 mov	 WORD PTR iEthLen$[rsp], ax

; 1304 :     U16         hwEthernetType;
; 1305 :     BYTE        bHas8022;
; 1306 :     BYTE        bHas8022Snap;
; 1307 :     int         nEthFrames   = 0;

  000d0	c7 84 24 94 00
	00 00 00 00 00
	00		 mov	 DWORD PTR nEthFrames$[rsp], 0

; 1308 :     int         nEthBytes    = 0;

  000db	c7 84 24 98 00
	00 00 00 00 00
	00		 mov	 DWORD PTR nEthBytes$[rsp], 0

; 1309 :     int         iTraceLen;
; 1310 :     char        buf[32];
; 1311 :     char        cPktType[24];
; 1312 : 
; 1313 : 
; 1314 :     // Display up to pLCSBLK->iTraceLen bytes of the data coming from the guest, if debug is active
; 1315 :     if (pLCSBLK->fDebug)

  000e6	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR pLCSBLK$[rsp]
  000ee	8b 40 18	 mov	 eax, DWORD PTR [rax+24]
  000f1	83 e0 01	 and	 eax, 1
  000f4	85 c0		 test	 eax, eax
  000f6	0f 84 e9 01 00
	00		 je	 $LN92@LCS_Write

; 1316 :     {
; 1317 :         // "%1d:%04X %s: Accept data of size %d bytes from guest"
; 1318 :         WRMSG(HHC00981, "D", SSID_TO_LCSS(pDEVBLK->ssid), pDEVBLK->devnum,  pDEVBLK->typname, (int)sCount );

  000fc	48 8b 84 24 e0
	01 00 00	 mov	 rax, QWORD PTR pDEVBLK$[rsp]
  00104	0f b7 40 48	 movzx	 eax, WORD PTR [rax+72]
  00108	89 84 24 44 01
	00 00		 mov	 DWORD PTR tv78[rsp], eax
  0010f	48 8b 8c 24 e0
	01 00 00	 mov	 rcx, QWORD PTR pDEVBLK$[rsp]
  00117	0f b7 49 44	 movzx	 ecx, WORD PTR [rcx+68]
  0011b	d1 f9		 sar	 ecx, 1
  0011d	89 8c 24 48 01
	00 00		 mov	 DWORD PTR tv82[rsp], ecx
  00124	b9 01 00 00 00	 mov	 ecx, 1
  00129	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  0012f	8b 8c 24 e8 01
	00 00		 mov	 ecx, DWORD PTR sCount$[rsp]
  00136	89 4c 24 50	 mov	 DWORD PTR [rsp+80], ecx
  0013a	48 8b 8c 24 e0
	01 00 00	 mov	 rcx, QWORD PTR pDEVBLK$[rsp]
  00142	48 8b 49 50	 mov	 rcx, QWORD PTR [rcx+80]
  00146	48 89 4c 24 48	 mov	 QWORD PTR [rsp+72], rcx
  0014b	8b 8c 24 44 01
	00 00		 mov	 ecx, DWORD PTR tv78[rsp]
  00152	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  00156	8b 8c 24 48 01
	00 00		 mov	 ecx, DWORD PTR tv82[rsp]
  0015d	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  00161	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170652
  00168	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  0016d	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170653
  00174	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00179	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  0017e	41 b9 03 00 00
	00		 mov	 r9d, 3
  00184	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG170654
  0018b	ba 26 05 00 00	 mov	 edx, 1318		; 00000526H
  00190	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170655
  00197	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 1319 :         if (pLCSBLK->iTraceLen)

  0019d	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR pLCSBLK$[rsp]
  001a5	83 78 28 00	 cmp	 DWORD PTR [rax+40], 0
  001a9	0f 84 36 01 00
	00		 je	 $LN93@LCS_Write

; 1320 :         {
; 1321 :             iTraceLen = sCount;

  001af	8b 84 24 e8 01
	00 00		 mov	 eax, DWORD PTR sCount$[rsp]
  001b6	89 84 24 80 00
	00 00		 mov	 DWORD PTR iTraceLen$[rsp], eax

; 1322 :             if (iTraceLen > pLCSBLK->iTraceLen)

  001bd	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR pLCSBLK$[rsp]
  001c5	8b 40 28	 mov	 eax, DWORD PTR [rax+40]
  001c8	39 84 24 80 00
	00 00		 cmp	 DWORD PTR iTraceLen$[rsp], eax
  001cf	0f 8e d7 00 00
	00		 jle	 $LN94@LCS_Write

; 1323 :             {
; 1324 :                 iTraceLen = pLCSBLK->iTraceLen;

  001d5	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR pLCSBLK$[rsp]
  001dd	8b 40 28	 mov	 eax, DWORD PTR [rax+40]
  001e0	89 84 24 80 00
	00 00		 mov	 DWORD PTR iTraceLen$[rsp], eax

; 1325 :                 // HHC00980 "%1d:%04X %s: Data of size %d bytes displayed, data of size %d bytes not displayed"
; 1326 :                 WRMSG(HHC00980, "D", SSID_TO_LCSS(pDEVBLK->ssid), pDEVBLK->devnum, pDEVBLK->typname,

  001e7	8b 84 24 80 00
	00 00		 mov	 eax, DWORD PTR iTraceLen$[rsp]
  001ee	8b 8c 24 e8 01
	00 00		 mov	 ecx, DWORD PTR sCount$[rsp]
  001f5	2b c8		 sub	 ecx, eax
  001f7	8b c1		 mov	 eax, ecx
  001f9	89 84 24 4c 01
	00 00		 mov	 DWORD PTR tv130[rsp], eax
  00200	48 8b 8c 24 e0
	01 00 00	 mov	 rcx, QWORD PTR pDEVBLK$[rsp]
  00208	0f b7 49 48	 movzx	 ecx, WORD PTR [rcx+72]
  0020c	89 8c 24 50 01
	00 00		 mov	 DWORD PTR tv136[rsp], ecx
  00213	48 8b 94 24 e0
	01 00 00	 mov	 rdx, QWORD PTR pDEVBLK$[rsp]
  0021b	0f b7 52 44	 movzx	 edx, WORD PTR [rdx+68]
  0021f	d1 fa		 sar	 edx, 1
  00221	89 94 24 c4 00
	00 00		 mov	 DWORD PTR tv140[rsp], edx
  00228	b9 01 00 00 00	 mov	 ecx, 1
  0022d	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  00233	8b 8c 24 4c 01
	00 00		 mov	 ecx, DWORD PTR tv130[rsp]
  0023a	89 4c 24 58	 mov	 DWORD PTR [rsp+88], ecx
  0023e	8b 8c 24 80 00
	00 00		 mov	 ecx, DWORD PTR iTraceLen$[rsp]
  00245	89 4c 24 50	 mov	 DWORD PTR [rsp+80], ecx
  00249	48 8b 8c 24 e0
	01 00 00	 mov	 rcx, QWORD PTR pDEVBLK$[rsp]
  00251	48 8b 49 50	 mov	 rcx, QWORD PTR [rcx+80]
  00255	48 89 4c 24 48	 mov	 QWORD PTR [rsp+72], rcx
  0025a	8b 8c 24 50 01
	00 00		 mov	 ecx, DWORD PTR tv136[rsp]
  00261	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  00265	8b 8c 24 c4 00
	00 00		 mov	 ecx, DWORD PTR tv140[rsp]
  0026c	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  00270	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170658
  00277	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  0027c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170659
  00283	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00288	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  0028d	41 b9 03 00 00
	00		 mov	 r9d, 3
  00293	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG170660
  0029a	ba 2f 05 00 00	 mov	 edx, 1327		; 0000052fH
  0029f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170661
  002a6	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg
$LN94@LCS_Write:

; 1327 :                                      iTraceLen, (int)(sCount - iTraceLen) );
; 1328 :             }
; 1329 :             net_data_trace( pDEVBLK, pIOBuf, iTraceLen, FROM_GUEST, 'D', "data", 0 );

  002ac	c7 44 24 30 00
	00 00 00	 mov	 DWORD PTR [rsp+48], 0
  002b4	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG170662
  002bb	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  002c0	c6 44 24 20 44	 mov	 BYTE PTR [rsp+32], 68	; 00000044H
  002c5	41 b1 3c	 mov	 r9b, 60			; 0000003cH
  002c8	44 8b 84 24 80
	00 00 00	 mov	 r8d, DWORD PTR iTraceLen$[rsp]
  002d0	48 8b 94 24 f0
	01 00 00	 mov	 rdx, QWORD PTR pIOBuf$[rsp]
  002d8	48 8b 8c 24 e0
	01 00 00	 mov	 rcx, QWORD PTR pDEVBLK$[rsp]
  002e0	e8 00 00 00 00	 call	 net_data_trace
$LN93@LCS_Write:
$LN92@LCS_Write:
$LN4@LCS_Write:

; 1330 :         }
; 1331 :     }
; 1332 : 
; 1333 :     // Process each frame in the buffer...
; 1334 : 
; 1335 :     PTT_DEBUG( "WRIT ENTRY        ", 000, pDEVBLK->devnum, -1 );

  002e5	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_pttclass
  002ec	48 8b 00	 mov	 rax, QWORD PTR [rax]
  002ef	48 25 00 00 02
	00		 and	 rax, 131072		; 00020000H
  002f5	48 85 c0	 test	 rax, rax
  002f8	74 42		 je	 SHORT $LN95@LCS_Write
  002fa	48 8b 84 24 e0
	01 00 00	 mov	 rax, QWORD PTR pDEVBLK$[rsp]
  00302	0f b7 40 48	 movzx	 eax, WORD PTR [rax+72]
  00306	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR [rsp+48], 0
  0030f	48 c7 44 24 28
	ff ff ff ff	 mov	 QWORD PTR [rsp+40], -1
  00318	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170664
  0031f	48 89 4c 24 20	 mov	 QWORD PTR [rsp+32], rcx
  00324	44 8b c8	 mov	 r9d, eax
  00327	45 33 c0	 xor	 r8d, r8d
  0032a	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG170665
  00331	b9 00 00 02 00	 mov	 ecx, 131072		; 00020000H
  00336	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ptt_pthread_trace
$LN95@LCS_Write:
  0033c	33 c0		 xor	 eax, eax
  0033e	85 c0		 test	 eax, eax
  00340	75 a3		 jne	 SHORT $LN4@LCS_Write
$LN7@LCS_Write:

; 1336 :     PTT_TIMING( "beg write", 0, 0, 0 );

  00342	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_pttclass
  00349	48 8b 00	 mov	 rax, QWORD PTR [rax]
  0034c	48 25 00 00 01
	00		 and	 rax, 65536		; 00010000H
  00352	48 85 c0	 test	 rax, rax
  00355	74 36		 je	 SHORT $LN96@LCS_Write
  00357	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR [rsp+48], 0
  00360	48 c7 44 24 28
	00 00 00 00	 mov	 QWORD PTR [rsp+40], 0
  00369	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG170667
  00370	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00375	45 33 c9	 xor	 r9d, r9d
  00378	45 33 c0	 xor	 r8d, r8d
  0037b	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG170668
  00382	b9 00 00 01 00	 mov	 ecx, 65536		; 00010000H
  00387	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ptt_pthread_trace
$LN96@LCS_Write:
  0038d	33 c0		 xor	 eax, eax
  0038f	85 c0		 test	 eax, eax
  00391	75 af		 jne	 SHORT $LN7@LCS_Write

; 1337 : 
; 1338 :     LCS_BegMWrite( pDEVBLK ); // (performance)

  00393	48 8b 8c 24 e0
	01 00 00	 mov	 rcx, QWORD PTR pDEVBLK$[rsp]
  0039b	e8 00 00 00 00	 call	 LCS_BegMWrite
$LN8@LCS_Write:

; 1339 : 
; 1340 :     while (1)

  003a0	33 c0		 xor	 eax, eax
  003a2	83 f8 01	 cmp	 eax, 1
  003a5	0f 84 b0 17 00
	00		 je	 $LN9@LCS_Write

; 1341 :     {
; 1342 :         // Fix-up the LCS header pointer to the current frame
; 1343 :         pLCSHDR = (PLCSHDR)( pIOBuf + iOffset );

  003ab	0f b7 84 24 84
	00 00 00	 movzx	 eax, WORD PTR iOffset$[rsp]
  003b3	48 8b 8c 24 f0
	01 00 00	 mov	 rcx, QWORD PTR pIOBuf$[rsp]
  003bb	48 03 c8	 add	 rcx, rax
  003be	48 8b c1	 mov	 rax, rcx
  003c1	48 89 84 24 b0
	00 00 00	 mov	 QWORD PTR pLCSHDR$[rsp], rax

; 1344 : 
; 1345 :         // Save current offset so we can tell how big next frame is
; 1346 :         iPrevOffset = iOffset;

  003c9	0f b7 84 24 84
	00 00 00	 movzx	 eax, WORD PTR iOffset$[rsp]
  003d1	66 89 84 24 90
	00 00 00	 mov	 WORD PTR iPrevOffset$[rsp], ax

; 1347 : 
; 1348 :         // Get the next frame offset, exit loop if 0
; 1349 :         FETCH_HW( iOffset, pLCSHDR->hwOffset );

  003d9	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR pLCSHDR$[rsp]
  003e1	48 8b c8	 mov	 rcx, rax
  003e4	e8 00 00 00 00	 call	 fetch_hw_noswap
  003e9	0f b7 c8	 movzx	 ecx, ax
  003ec	e8 00 00 00 00	 call	 _byteswap_ushort
  003f1	66 89 84 24 84
	00 00 00	 mov	 WORD PTR iOffset$[rsp], ax

; 1350 : 
; 1351 :         if (iOffset == 0)   // ("EOF")

  003f9	0f b7 84 24 84
	00 00 00	 movzx	 eax, WORD PTR iOffset$[rsp]
  00401	85 c0		 test	 eax, eax
  00403	75 05		 jne	 SHORT $LN97@LCS_Write

; 1352 :             break;

  00405	e9 51 17 00 00	 jmp	 $LN9@LCS_Write
$LN97@LCS_Write:

; 1353 : 
; 1354 :         // Calculate size of this LCS Frame
; 1355 :         iLength = iOffset - iPrevOffset;

  0040a	0f b7 84 24 84
	00 00 00	 movzx	 eax, WORD PTR iOffset$[rsp]
  00412	0f b7 8c 24 90
	00 00 00	 movzx	 ecx, WORD PTR iPrevOffset$[rsp]
  0041a	2b c1		 sub	 eax, ecx
  0041c	66 89 44 24 74	 mov	 WORD PTR iLength$[rsp], ax

; 1356 : 
; 1357 :         switch (pLCSHDR->bType)

  00421	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR pLCSHDR$[rsp]
  00429	0f b6 40 02	 movzx	 eax, BYTE PTR [rax+2]
  0042d	88 84 24 c0 00
	00 00		 mov	 BYTE PTR tv197[rsp], al
  00434	80 bc 24 c0 00
	00 00 00	 cmp	 BYTE PTR tv197[rsp], 0
  0043c	0f 84 4c 07 00
	00		 je	 $LN113@LCS_Write
  00442	80 bc 24 c0 00
	00 00 01	 cmp	 BYTE PTR tv197[rsp], 1
  0044a	74 05		 je	 SHORT $LN98@LCS_Write
  0044c	e9 a0 14 00 00	 jmp	 $LN146@LCS_Write
$LN98@LCS_Write:
$LN14@LCS_Write:

; 1358 :         {
; 1359 :         case LCS_FRMTYP_ENET:   // Ethernet Passthru
; 1360 : 
; 1361 :             PTT_DEBUG( "WRIT: Eth frame   ", 000, pDEVBLK->devnum, -1 );

  00451	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_pttclass
  00458	48 8b 00	 mov	 rax, QWORD PTR [rax]
  0045b	48 25 00 00 02
	00		 and	 rax, 131072		; 00020000H
  00461	48 85 c0	 test	 rax, rax
  00464	74 42		 je	 SHORT $LN99@LCS_Write
  00466	48 8b 84 24 e0
	01 00 00	 mov	 rax, QWORD PTR pDEVBLK$[rsp]
  0046e	0f b7 40 48	 movzx	 eax, WORD PTR [rax+72]
  00472	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR [rsp+48], 0
  0047b	48 c7 44 24 28
	ff ff ff ff	 mov	 QWORD PTR [rsp+40], -1
  00484	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170672
  0048b	48 89 4c 24 20	 mov	 QWORD PTR [rsp+32], rcx
  00490	44 8b c8	 mov	 r9d, eax
  00493	45 33 c0	 xor	 r8d, r8d
  00496	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG170673
  0049d	b9 00 00 02 00	 mov	 ecx, 131072		; 00020000H
  004a2	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ptt_pthread_trace
$LN99@LCS_Write:
  004a8	33 c0		 xor	 eax, eax
  004aa	85 c0		 test	 eax, eax
  004ac	75 a3		 jne	 SHORT $LN14@LCS_Write

; 1362 : 
; 1363 :             pLCSEthFrame = (PLCSETHFRM) pLCSHDR;

  004ae	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR pLCSHDR$[rsp]
  004b6	48 89 84 24 60
	01 00 00	 mov	 QWORD PTR pLCSEthFrame$[rsp], rax

; 1364 :             pEthFrame    = (PETHFRM) pLCSEthFrame->bData;

  004be	48 8b 84 24 60
	01 00 00	 mov	 rax, QWORD PTR pLCSEthFrame$[rsp]
  004c6	48 83 c0 04	 add	 rax, 4
  004ca	48 89 84 24 b8
	00 00 00	 mov	 QWORD PTR pEthFrame$[rsp], rax

; 1365 :             iEthLen      = iLength - sizeof(LCSETHFRM);

  004d2	0f b7 44 24 74	 movzx	 eax, WORD PTR iLength$[rsp]
  004d7	48 83 e8 04	 sub	 rax, 4
  004db	66 89 44 24 70	 mov	 WORD PTR iEthLen$[rsp], ax

; 1366 : 
; 1367 :             GetFrameInfo( pEthFrame, &cPktType[0], &hwEthernetType, &bHas8022, &bHas8022Snap );

  004e0	b8 01 00 00 00	 mov	 eax, 1
  004e5	48 6b c0 00	 imul	 rax, rax, 0
  004e9	48 8d 84 04 80
	01 00 00	 lea	 rax, QWORD PTR cPktType$[rsp+rax]
  004f1	48 8d 8c 24 ad
	00 00 00	 lea	 rcx, QWORD PTR bHas8022Snap$[rsp]
  004f9	48 89 4c 24 20	 mov	 QWORD PTR [rsp+32], rcx
  004fe	4c 8d 8c 24 ac
	00 00 00	 lea	 r9, QWORD PTR bHas8022$[rsp]
  00506	4c 8d 84 24 38
	01 00 00	 lea	 r8, QWORD PTR hwEthernetType$[rsp]
  0050e	48 8b d0	 mov	 rdx, rax
  00511	48 8b 8c 24 b8
	00 00 00	 mov	 rcx, QWORD PTR pEthFrame$[rsp]
  00519	e8 00 00 00 00	 call	 GetFrameInfo

; 1368 : 
; 1369 :             // Fill in LCS source MAC address if not specified by guest program
; 1370 :             if (memcmp( pEthFrame->bSrcMAC, zeromac, sizeof( MAC )) == 0)

  0051e	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR pEthFrame$[rsp]
  00526	48 83 c0 06	 add	 rax, 6
  0052a	41 b8 06 00 00
	00		 mov	 r8d, 6
  00530	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:zeromac
  00537	48 8b c8	 mov	 rcx, rax
  0053a	e8 00 00 00 00	 call	 memcmp
  0053f	85 c0		 test	 eax, eax
  00541	75 1f		 jne	 SHORT $LN100@LCS_Write

; 1371 :             {
; 1372 :                 memcpy( pEthFrame->bSrcMAC, pLCSPORT->MAC_Address, IFHWADDRLEN);

  00543	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR pEthFrame$[rsp]
  0054b	48 8b 8c 24 58
	01 00 00	 mov	 rcx, QWORD PTR pLCSPORT$[rsp]
  00553	48 8d 78 06	 lea	 rdi, QWORD PTR [rax+6]
  00557	48 8d 71 02	 lea	 rsi, QWORD PTR [rcx+2]
  0055b	b9 06 00 00 00	 mov	 ecx, 6
  00560	f3 a4		 rep movsb
$LN100@LCS_Write:

; 1373 : #if !defined( OPTION_TUNTAP_LCS_SAME_ADDR )
; 1374 :                 pEthFrame->bSrcMAC[5]++;    /* Get next MAC address */
; 1375 : #endif
; 1376 :             }
; 1377 : 
; 1378 :             // Perform outbound checksum offloading if necessary
; 1379 :             if (pLCSPORT->fDoCkSumOffload)

  00562	48 8b 84 24 58
	01 00 00	 mov	 rax, QWORD PTR pLCSPORT$[rsp]
  0056a	8b 80 34 01 00
	00		 mov	 eax, DWORD PTR [rax+308]
  00570	c1 e8 07	 shr	 eax, 7
  00573	83 e0 01	 and	 eax, 1
  00576	85 c0		 test	 eax, eax
  00578	0f 84 c0 00 00
	00		 je	 $LN101@LCS_Write
$LN17@LCS_Write:

; 1380 :             {
; 1381 :                 PTT_TIMING( "beg csumoff", 0, iEthLen, 0 );

  0057e	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_pttclass
  00585	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00588	48 25 00 00 01
	00		 and	 rax, 65536		; 00010000H
  0058e	48 85 c0	 test	 rax, rax
  00591	74 3b		 je	 SHORT $LN102@LCS_Write
  00593	0f b7 44 24 70	 movzx	 eax, WORD PTR iEthLen$[rsp]
  00598	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR [rsp+48], 0
  005a1	48 c7 44 24 28
	00 00 00 00	 mov	 QWORD PTR [rsp+40], 0
  005aa	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170677
  005b1	48 89 4c 24 20	 mov	 QWORD PTR [rsp+32], rcx
  005b6	44 8b c8	 mov	 r9d, eax
  005b9	45 33 c0	 xor	 r8d, r8d
  005bc	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG170678
  005c3	b9 00 00 01 00	 mov	 ecx, 65536		; 00010000H
  005c8	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ptt_pthread_trace
$LN102@LCS_Write:
  005ce	33 c0		 xor	 eax, eax
  005d0	85 c0		 test	 eax, eax
  005d2	75 aa		 jne	 SHORT $LN17@LCS_Write

; 1382 :                 EtherIpv4CkSumOffload( (BYTE*) pEthFrame, iEthLen );

  005d4	0f b7 44 24 70	 movzx	 eax, WORD PTR iEthLen$[rsp]
  005d9	8b d0		 mov	 edx, eax
  005db	48 8b 8c 24 b8
	00 00 00	 mov	 rcx, QWORD PTR pEthFrame$[rsp]
  005e3	e8 00 00 00 00	 call	 EtherIpv4CkSumOffload
$LN20@LCS_Write:

; 1383 :                 PTT_TIMING( "end csumoff", 0, iEthLen, 0 );

  005e8	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_pttclass
  005ef	48 8b 00	 mov	 rax, QWORD PTR [rax]
  005f2	48 25 00 00 01
	00		 and	 rax, 65536		; 00010000H
  005f8	48 85 c0	 test	 rax, rax
  005fb	74 3b		 je	 SHORT $LN103@LCS_Write
  005fd	0f b7 44 24 70	 movzx	 eax, WORD PTR iEthLen$[rsp]
  00602	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR [rsp+48], 0
  0060b	48 c7 44 24 28
	00 00 00 00	 mov	 QWORD PTR [rsp+40], 0
  00614	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170680
  0061b	48 89 4c 24 20	 mov	 QWORD PTR [rsp+32], rcx
  00620	44 8b c8	 mov	 r9d, eax
  00623	45 33 c0	 xor	 r8d, r8d
  00626	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG170681
  0062d	b9 00 00 01 00	 mov	 ecx, 65536		; 00010000H
  00632	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ptt_pthread_trace
$LN103@LCS_Write:
  00638	33 c0		 xor	 eax, eax
  0063a	85 c0		 test	 eax, eax
  0063c	75 aa		 jne	 SHORT $LN20@LCS_Write
$LN101@LCS_Write:

; 1384 :             }
; 1385 : 
; 1386 :             // Trace Ethernet frame before sending to TAP device
; 1387 :             if (pLCSBLK->fDebug)

  0063e	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR pLCSBLK$[rsp]
  00646	8b 40 18	 mov	 eax, DWORD PTR [rax+24]
  00649	83 e0 01	 and	 eax, 1
  0064c	85 c0		 test	 eax, eax
  0064e	0f 84 1f 02 00
	00		 je	 $LN104@LCS_Write

; 1388 :             {
; 1389 :                 // "%1d:%04X %s: port %2.2X: Send frame of size %d bytes (with %s packet) to device %s"
; 1390 :                 WRMSG(HHC00983, "D", SSID_TO_LCSS(pDEVBLK->ssid), pDEVBLK->devnum, pDEVBLK->typname,

  00654	48 8b 84 24 58
	01 00 00	 mov	 rax, QWORD PTR pLCSPORT$[rsp]
  0065c	48 05 48 01 00
	00		 add	 rax, 328		; 00000148H
  00662	48 89 84 24 68
	01 00 00	 mov	 QWORD PTR tv270[rsp], rax
  0066a	0f b7 4c 24 70	 movzx	 ecx, WORD PTR iEthLen$[rsp]
  0066f	89 8c 24 c8 00
	00 00		 mov	 DWORD PTR tv273[rsp], ecx
  00676	48 8b 94 24 b0
	00 00 00	 mov	 rdx, QWORD PTR pLCSHDR$[rsp]
  0067e	0f b6 52 03	 movzx	 edx, BYTE PTR [rdx+3]
  00682	89 94 24 cc 00
	00 00		 mov	 DWORD PTR tv276[rsp], edx
  00689	48 8b bc 24 e0
	01 00 00	 mov	 rdi, QWORD PTR pDEVBLK$[rsp]
  00691	0f b7 7f 48	 movzx	 edi, WORD PTR [rdi+72]
  00695	48 8b b4 24 e0
	01 00 00	 mov	 rsi, QWORD PTR pDEVBLK$[rsp]
  0069d	0f b7 76 44	 movzx	 esi, WORD PTR [rsi+68]
  006a1	d1 fe		 sar	 esi, 1
  006a3	b9 01 00 00 00	 mov	 ecx, 1
  006a8	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  006ae	48 8b 8c 24 68
	01 00 00	 mov	 rcx, QWORD PTR tv270[rsp]
  006b6	48 89 4c 24 68	 mov	 QWORD PTR [rsp+104], rcx
  006bb	48 8d 8c 24 80
	01 00 00	 lea	 rcx, QWORD PTR cPktType$[rsp]
  006c3	48 89 4c 24 60	 mov	 QWORD PTR [rsp+96], rcx
  006c8	8b 8c 24 c8 00
	00 00		 mov	 ecx, DWORD PTR tv273[rsp]
  006cf	89 4c 24 58	 mov	 DWORD PTR [rsp+88], ecx
  006d3	8b 8c 24 cc 00
	00 00		 mov	 ecx, DWORD PTR tv276[rsp]
  006da	89 4c 24 50	 mov	 DWORD PTR [rsp+80], ecx
  006de	48 8b 8c 24 e0
	01 00 00	 mov	 rcx, QWORD PTR pDEVBLK$[rsp]
  006e6	48 8b 49 50	 mov	 rcx, QWORD PTR [rcx+80]
  006ea	48 89 4c 24 48	 mov	 QWORD PTR [rsp+72], rcx
  006ef	89 7c 24 40	 mov	 DWORD PTR [rsp+64], edi
  006f3	89 74 24 38	 mov	 DWORD PTR [rsp+56], esi
  006f7	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170683
  006fe	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  00703	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170684
  0070a	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  0070f	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00714	41 b9 03 00 00
	00		 mov	 r9d, 3
  0071a	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG170685
  00721	ba 70 05 00 00	 mov	 edx, 1392		; 00000570H
  00726	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170686
  0072d	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 1391 :                                      pLCSHDR->bSlot, iEthLen, cPktType,
; 1392 :                                      pLCSPORT->szNetIfName );
; 1393 :                 if (pLCSBLK->iTraceLen)

  00733	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR pLCSBLK$[rsp]
  0073b	83 78 28 00	 cmp	 DWORD PTR [rax+40], 0
  0073f	0f 84 2e 01 00
	00		 je	 $LN105@LCS_Write

; 1394 :                 {
; 1395 :                     iTraceLen = iEthLen;

  00745	0f b7 44 24 70	 movzx	 eax, WORD PTR iEthLen$[rsp]
  0074a	89 84 24 80 00
	00 00		 mov	 DWORD PTR iTraceLen$[rsp], eax

; 1396 :                     if (iTraceLen > pLCSBLK->iTraceLen)

  00751	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR pLCSBLK$[rsp]
  00759	8b 40 28	 mov	 eax, DWORD PTR [rax+40]
  0075c	39 84 24 80 00
	00 00		 cmp	 DWORD PTR iTraceLen$[rsp], eax
  00763	0f 8e d1 00 00
	00		 jle	 $LN106@LCS_Write

; 1397 :                     {
; 1398 :                         iTraceLen = pLCSBLK->iTraceLen;

  00769	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR pLCSBLK$[rsp]
  00771	8b 40 28	 mov	 eax, DWORD PTR [rax+40]
  00774	89 84 24 80 00
	00 00		 mov	 DWORD PTR iTraceLen$[rsp], eax

; 1399 :                         // HHC00980 "%1d:%04X %s: Data of size %d bytes displayed, data of size %d bytes not displayed"
; 1400 :                         WRMSG(HHC00980, "D", SSID_TO_LCSS(pDEVBLK->ssid), pDEVBLK->devnum, pDEVBLK->typname,

  0077b	0f b7 44 24 70	 movzx	 eax, WORD PTR iEthLen$[rsp]
  00780	2b 84 24 80 00
	00 00		 sub	 eax, DWORD PTR iTraceLen$[rsp]
  00787	89 84 24 d0 00
	00 00		 mov	 DWORD PTR tv303[rsp], eax
  0078e	48 8b 8c 24 e0
	01 00 00	 mov	 rcx, QWORD PTR pDEVBLK$[rsp]
  00796	0f b7 49 48	 movzx	 ecx, WORD PTR [rcx+72]
  0079a	89 8c 24 d4 00
	00 00		 mov	 DWORD PTR tv309[rsp], ecx
  007a1	48 8b 94 24 e0
	01 00 00	 mov	 rdx, QWORD PTR pDEVBLK$[rsp]
  007a9	0f b7 52 44	 movzx	 edx, WORD PTR [rdx+68]
  007ad	d1 fa		 sar	 edx, 1
  007af	89 94 24 d8 00
	00 00		 mov	 DWORD PTR tv313[rsp], edx
  007b6	b9 01 00 00 00	 mov	 ecx, 1
  007bb	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  007c1	8b 8c 24 d0 00
	00 00		 mov	 ecx, DWORD PTR tv303[rsp]
  007c8	89 4c 24 58	 mov	 DWORD PTR [rsp+88], ecx
  007cc	8b 8c 24 80 00
	00 00		 mov	 ecx, DWORD PTR iTraceLen$[rsp]
  007d3	89 4c 24 50	 mov	 DWORD PTR [rsp+80], ecx
  007d7	48 8b 8c 24 e0
	01 00 00	 mov	 rcx, QWORD PTR pDEVBLK$[rsp]
  007df	48 8b 49 50	 mov	 rcx, QWORD PTR [rcx+80]
  007e3	48 89 4c 24 48	 mov	 QWORD PTR [rsp+72], rcx
  007e8	8b 8c 24 d4 00
	00 00		 mov	 ecx, DWORD PTR tv309[rsp]
  007ef	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  007f3	8b 8c 24 d8 00
	00 00		 mov	 ecx, DWORD PTR tv313[rsp]
  007fa	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  007fe	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170689
  00805	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  0080a	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170690
  00811	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00816	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  0081b	41 b9 03 00 00
	00		 mov	 r9d, 3
  00821	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG170691
  00828	ba 79 05 00 00	 mov	 edx, 1401		; 00000579H
  0082d	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170692
  00834	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg
$LN106@LCS_Write:

; 1401 :                                              iTraceLen, (iEthLen - iTraceLen) );
; 1402 :                     }
; 1403 :                     net_data_trace( pDEVBLK, (BYTE*)pEthFrame, iTraceLen, FROM_GUEST, 'D', "eth frame", 0 );

  0083a	c7 44 24 30 00
	00 00 00	 mov	 DWORD PTR [rsp+48], 0
  00842	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG170693
  00849	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  0084e	c6 44 24 20 44	 mov	 BYTE PTR [rsp+32], 68	; 00000044H
  00853	41 b1 3c	 mov	 r9b, 60			; 0000003cH
  00856	44 8b 84 24 80
	00 00 00	 mov	 r8d, DWORD PTR iTraceLen$[rsp]
  0085e	48 8b 94 24 b8
	00 00 00	 mov	 rdx, QWORD PTR pEthFrame$[rsp]
  00866	48 8b 8c 24 e0
	01 00 00	 mov	 rcx, QWORD PTR pDEVBLK$[rsp]
  0086e	e8 00 00 00 00	 call	 net_data_trace
$LN105@LCS_Write:
$LN104@LCS_Write:

; 1404 :                 }
; 1405 :             }
; 1406 : 
; 1407 :             // Write the Ethernet frame to the TAP device
; 1408 :             nEthBytes += iEthLen;

  00873	0f b7 44 24 70	 movzx	 eax, WORD PTR iEthLen$[rsp]
  00878	8b 8c 24 98 00
	00 00		 mov	 ecx, DWORD PTR nEthBytes$[rsp]
  0087f	03 c8		 add	 ecx, eax
  00881	8b c1		 mov	 eax, ecx
  00883	89 84 24 98 00
	00 00		 mov	 DWORD PTR nEthBytes$[rsp], eax

; 1409 :             nEthFrames++;

  0088a	8b 84 24 94 00
	00 00		 mov	 eax, DWORD PTR nEthFrames$[rsp]
  00891	ff c0		 inc	 eax
  00893	89 84 24 94 00
	00 00		 mov	 DWORD PTR nEthFrames$[rsp], eax
$LN23@LCS_Write:

; 1410 :             PTT_DEBUG( "WRIT: writing...  ", 000, pDEVBLK->devnum, -1 );

  0089a	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_pttclass
  008a1	48 8b 00	 mov	 rax, QWORD PTR [rax]
  008a4	48 25 00 00 02
	00		 and	 rax, 131072		; 00020000H
  008aa	48 85 c0	 test	 rax, rax
  008ad	74 42		 je	 SHORT $LN107@LCS_Write
  008af	48 8b 84 24 e0
	01 00 00	 mov	 rax, QWORD PTR pDEVBLK$[rsp]
  008b7	0f b7 40 48	 movzx	 eax, WORD PTR [rax+72]
  008bb	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR [rsp+48], 0
  008c4	48 c7 44 24 28
	ff ff ff ff	 mov	 QWORD PTR [rsp+40], -1
  008cd	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170695
  008d4	48 89 4c 24 20	 mov	 QWORD PTR [rsp+32], rcx
  008d9	44 8b c8	 mov	 r9d, eax
  008dc	45 33 c0	 xor	 r8d, r8d
  008df	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG170696
  008e6	b9 00 00 02 00	 mov	 ecx, 131072		; 00020000H
  008eb	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ptt_pthread_trace
$LN107@LCS_Write:
  008f1	33 c0		 xor	 eax, eax
  008f3	85 c0		 test	 eax, eax
  008f5	75 a3		 jne	 SHORT $LN23@LCS_Write
$LN26@LCS_Write:

; 1411 :             PTT_TIMING( "b4 write", 0, iEthLen, 1 );

  008f7	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_pttclass
  008fe	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00901	48 25 00 00 01
	00		 and	 rax, 65536		; 00010000H
  00907	48 85 c0	 test	 rax, rax
  0090a	74 3b		 je	 SHORT $LN108@LCS_Write
  0090c	0f b7 44 24 70	 movzx	 eax, WORD PTR iEthLen$[rsp]
  00911	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR [rsp+48], 0
  0091a	48 c7 44 24 28
	01 00 00 00	 mov	 QWORD PTR [rsp+40], 1
  00923	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170698
  0092a	48 89 4c 24 20	 mov	 QWORD PTR [rsp+32], rcx
  0092f	44 8b c8	 mov	 r9d, eax
  00932	45 33 c0	 xor	 r8d, r8d
  00935	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG170699
  0093c	b9 00 00 01 00	 mov	 ecx, 65536		; 00010000H
  00941	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ptt_pthread_trace
$LN108@LCS_Write:
  00947	33 c0		 xor	 eax, eax
  00949	85 c0		 test	 eax, eax
  0094b	75 aa		 jne	 SHORT $LN26@LCS_Write

; 1412 :             if (TUNTAP_Write( pDEVBLK->fd, (BYTE*) pEthFrame, iEthLen ) != iEthLen)

  0094d	0f b7 44 24 70	 movzx	 eax, WORD PTR iEthLen$[rsp]
  00952	44 8b c0	 mov	 r8d, eax
  00955	48 8b 94 24 b8
	00 00 00	 mov	 rdx, QWORD PTR pEthFrame$[rsp]
  0095d	48 8b 84 24 e0
	01 00 00	 mov	 rax, QWORD PTR pDEVBLK$[rsp]
  00965	8b 88 ac 01 00
	00		 mov	 ecx, DWORD PTR [rax+428]
  0096b	e8 00 00 00 00	 call	 tt32_write
  00970	0f b7 4c 24 70	 movzx	 ecx, WORD PTR iEthLen$[rsp]
  00975	3b c1		 cmp	 eax, ecx
  00977	0f 84 b6 01 00
	00		 je	 $LN109@LCS_Write
$LN29@LCS_Write:

; 1413 :             {
; 1414 :                 PTT_TIMING( "*WRITE ERR", 0, iEthLen, 1 );

  0097d	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_pttclass
  00984	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00987	48 25 00 00 01
	00		 and	 rax, 65536		; 00010000H
  0098d	48 85 c0	 test	 rax, rax
  00990	74 3b		 je	 SHORT $LN110@LCS_Write
  00992	0f b7 44 24 70	 movzx	 eax, WORD PTR iEthLen$[rsp]
  00997	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR [rsp+48], 0
  009a0	48 c7 44 24 28
	01 00 00 00	 mov	 QWORD PTR [rsp+40], 1
  009a9	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170702
  009b0	48 89 4c 24 20	 mov	 QWORD PTR [rsp+32], rcx
  009b5	44 8b c8	 mov	 r9d, eax
  009b8	45 33 c0	 xor	 r8d, r8d
  009bb	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG170703
  009c2	b9 00 00 01 00	 mov	 ecx, 65536		; 00010000H
  009c7	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ptt_pthread_trace
$LN110@LCS_Write:
  009cd	33 c0		 xor	 eax, eax
  009cf	85 c0		 test	 eax, eax
  009d1	75 aa		 jne	 SHORT $LN29@LCS_Write

; 1415 :                 // "%1d:%04X CTC: error writing to file %s: %s"
; 1416 :                 WRMSG( HHC00936, "E",

  009d3	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno
  009d9	8b 08		 mov	 ecx, DWORD PTR [rax]
  009db	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_strerror
  009e1	48 89 84 24 70
	01 00 00	 mov	 QWORD PTR tv408[rsp], rax
  009e9	48 8b 8c 24 e0
	01 00 00	 mov	 rcx, QWORD PTR pDEVBLK$[rsp]
  009f1	48 81 c1 a4 00
	00 00		 add	 rcx, 164		; 000000a4H
  009f8	48 89 8c 24 78
	01 00 00	 mov	 QWORD PTR tv412[rsp], rcx
  00a00	48 8b 94 24 e0
	01 00 00	 mov	 rdx, QWORD PTR pDEVBLK$[rsp]
  00a08	0f b7 52 48	 movzx	 edx, WORD PTR [rdx+72]
  00a0c	89 94 24 dc 00
	00 00		 mov	 DWORD PTR tv415[rsp], edx
  00a13	48 8b bc 24 e0
	01 00 00	 mov	 rdi, QWORD PTR pDEVBLK$[rsp]
  00a1b	0f b7 7f 44	 movzx	 edi, WORD PTR [rdi+68]
  00a1f	d1 ff		 sar	 edi, 1
  00a21	b9 01 00 00 00	 mov	 ecx, 1
  00a26	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  00a2c	48 8b 8c 24 70
	01 00 00	 mov	 rcx, QWORD PTR tv408[rsp]
  00a34	48 89 4c 24 50	 mov	 QWORD PTR [rsp+80], rcx
  00a39	48 8b 8c 24 78
	01 00 00	 mov	 rcx, QWORD PTR tv412[rsp]
  00a41	48 89 4c 24 48	 mov	 QWORD PTR [rsp+72], rcx
  00a46	8b 8c 24 dc 00
	00 00		 mov	 ecx, DWORD PTR tv415[rsp]
  00a4d	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  00a51	89 7c 24 38	 mov	 DWORD PTR [rsp+56], edi
  00a55	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170704
  00a5c	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  00a61	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170705
  00a68	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00a6d	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00a72	41 b9 03 00 00
	00		 mov	 r9d, 3
  00a78	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG170706
  00a7f	ba 8a 05 00 00	 mov	 edx, 1418		; 0000058aH
  00a84	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170707
  00a8b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 1417 :                         SSID_TO_LCSS(pDEVBLK->ssid), pDEVBLK->devnum, pDEVBLK->filename,
; 1418 :                         strerror( errno ) );
; 1419 :                 pDEVBLK->sense[0] = SENSE_EC;

  00a91	b8 01 00 00 00	 mov	 eax, 1
  00a96	48 6b c0 00	 imul	 rax, rax, 0
  00a9a	48 8b 8c 24 e0
	01 00 00	 mov	 rcx, QWORD PTR pDEVBLK$[rsp]
  00aa2	c6 84 01 64 03
	00 00 10	 mov	 BYTE PTR [rcx+rax+868], 16

; 1420 :                 *pUnitStat = CSW_CE | CSW_DE | CSW_UC;

  00aaa	48 8b 84 24 f8
	01 00 00	 mov	 rax, QWORD PTR pUnitStat$[rsp]
  00ab2	c6 00 0e	 mov	 BYTE PTR [rax], 14

; 1421 :                 LCS_EndMWrite( pDEVBLK, nEthBytes, nEthFrames );

  00ab5	44 8b 84 24 94
	00 00 00	 mov	 r8d, DWORD PTR nEthFrames$[rsp]
  00abd	8b 94 24 98 00
	00 00		 mov	 edx, DWORD PTR nEthBytes$[rsp]
  00ac4	48 8b 8c 24 e0
	01 00 00	 mov	 rcx, QWORD PTR pDEVBLK$[rsp]
  00acc	e8 00 00 00 00	 call	 LCS_EndMWrite
$LN32@LCS_Write:

; 1422 :                 PTT_DEBUG( "WRIT EXIT         ", 000, pDEVBLK->devnum, -1 );

  00ad1	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_pttclass
  00ad8	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00adb	48 25 00 00 02
	00		 and	 rax, 131072		; 00020000H
  00ae1	48 85 c0	 test	 rax, rax
  00ae4	74 42		 je	 SHORT $LN111@LCS_Write
  00ae6	48 8b 84 24 e0
	01 00 00	 mov	 rax, QWORD PTR pDEVBLK$[rsp]
  00aee	0f b7 40 48	 movzx	 eax, WORD PTR [rax+72]
  00af2	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR [rsp+48], 0
  00afb	48 c7 44 24 28
	ff ff ff ff	 mov	 QWORD PTR [rsp+40], -1
  00b04	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170709
  00b0b	48 89 4c 24 20	 mov	 QWORD PTR [rsp+32], rcx
  00b10	44 8b c8	 mov	 r9d, eax
  00b13	45 33 c0	 xor	 r8d, r8d
  00b16	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG170710
  00b1d	b9 00 00 02 00	 mov	 ecx, 131072		; 00020000H
  00b22	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ptt_pthread_trace
$LN111@LCS_Write:
  00b28	33 c0		 xor	 eax, eax
  00b2a	85 c0		 test	 eax, eax
  00b2c	75 a3		 jne	 SHORT $LN32@LCS_Write

; 1423 :                 return;

  00b2e	e9 0b 11 00 00	 jmp	 $LN1@LCS_Write
$LN109@LCS_Write:
$LN35@LCS_Write:

; 1424 :             }
; 1425 :             PTT_TIMING( "af write", 0, iEthLen, 1 );

  00b33	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_pttclass
  00b3a	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00b3d	48 25 00 00 01
	00		 and	 rax, 65536		; 00010000H
  00b43	48 85 c0	 test	 rax, rax
  00b46	74 3b		 je	 SHORT $LN112@LCS_Write
  00b48	0f b7 44 24 70	 movzx	 eax, WORD PTR iEthLen$[rsp]
  00b4d	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR [rsp+48], 0
  00b56	48 c7 44 24 28
	01 00 00 00	 mov	 QWORD PTR [rsp+40], 1
  00b5f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170712
  00b66	48 89 4c 24 20	 mov	 QWORD PTR [rsp+32], rcx
  00b6b	44 8b c8	 mov	 r9d, eax
  00b6e	45 33 c0	 xor	 r8d, r8d
  00b71	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG170713
  00b78	b9 00 00 01 00	 mov	 ecx, 65536		; 00010000H
  00b7d	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ptt_pthread_trace
$LN112@LCS_Write:
  00b83	33 c0		 xor	 eax, eax
  00b85	85 c0		 test	 eax, eax
  00b87	75 aa		 jne	 SHORT $LN35@LCS_Write

; 1426 :             break;

  00b89	e9 c8 0f 00 00	 jmp	 $LN10@LCS_Write
$LN113@LCS_Write:

; 1427 : 
; 1428 :         case LCS_FRMTYP_CMD:    // LCS Command Frame
; 1429 : 
; 1430 :             pCmdFrame = (PLCSCMDHDR)pLCSHDR;

  00b8e	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR pLCSHDR$[rsp]
  00b96	48 89 44 24 78	 mov	 QWORD PTR pCmdFrame$[rsp], rax
$LN38@LCS_Write:

; 1431 : 
; 1432 :             PTT_DEBUG( "WRIT: Cmd frame   ", pCmdFrame->bCmdCode, pDEVBLK->devnum, -1 );

  00b9b	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_pttclass
  00ba2	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00ba5	48 25 00 00 02
	00		 and	 rax, 131072		; 00020000H
  00bab	48 85 c0	 test	 rax, rax
  00bae	74 4b		 je	 SHORT $LN114@LCS_Write
  00bb0	48 8b 84 24 e0
	01 00 00	 mov	 rax, QWORD PTR pDEVBLK$[rsp]
  00bb8	0f b7 40 48	 movzx	 eax, WORD PTR [rax+72]
  00bbc	48 8b 4c 24 78	 mov	 rcx, QWORD PTR pCmdFrame$[rsp]
  00bc1	0f b6 49 04	 movzx	 ecx, BYTE PTR [rcx+4]
  00bc5	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR [rsp+48], 0
  00bce	48 c7 44 24 28
	ff ff ff ff	 mov	 QWORD PTR [rsp+40], -1
  00bd7	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG170716
  00bde	48 89 54 24 20	 mov	 QWORD PTR [rsp+32], rdx
  00be3	44 8b c8	 mov	 r9d, eax
  00be6	44 8b c1	 mov	 r8d, ecx
  00be9	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG170717
  00bf0	b9 00 00 02 00	 mov	 ecx, 131072		; 00020000H
  00bf5	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ptt_pthread_trace
$LN114@LCS_Write:
  00bfb	33 c0		 xor	 eax, eax
  00bfd	85 c0		 test	 eax, eax
  00bff	75 9a		 jne	 SHORT $LN38@LCS_Write

; 1433 : 
; 1434 :             // Trace received command frame...
; 1435 :             if (pLCSBLK->fDebug)

  00c01	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR pLCSBLK$[rsp]
  00c09	8b 40 18	 mov	 eax, DWORD PTR [rax+24]
  00c0c	83 e0 01	 and	 eax, 1
  00c0f	85 c0		 test	 eax, eax
  00c11	0f 84 bb 00 00
	00		 je	 $LN115@LCS_Write

; 1436 :             {
; 1437 :                 // "%1d:%04X CTC: lcs command packet received"
; 1438 :                 WRMSG( HHC00922, "D", SSID_TO_LCSS( pDEVBLK->ssid ), pDEVBLK->devnum );

  00c17	48 8b 84 24 e0
	01 00 00	 mov	 rax, QWORD PTR pDEVBLK$[rsp]
  00c1f	0f b7 40 48	 movzx	 eax, WORD PTR [rax+72]
  00c23	89 84 24 e0 00
	00 00		 mov	 DWORD PTR tv477[rsp], eax
  00c2a	48 8b 8c 24 e0
	01 00 00	 mov	 rcx, QWORD PTR pDEVBLK$[rsp]
  00c32	0f b7 49 44	 movzx	 ecx, WORD PTR [rcx+68]
  00c36	d1 f9		 sar	 ecx, 1
  00c38	89 8c 24 e4 00
	00 00		 mov	 DWORD PTR tv481[rsp], ecx
  00c3f	b9 01 00 00 00	 mov	 ecx, 1
  00c44	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  00c4a	8b 8c 24 e0 00
	00 00		 mov	 ecx, DWORD PTR tv477[rsp]
  00c51	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  00c55	8b 8c 24 e4 00
	00 00		 mov	 ecx, DWORD PTR tv481[rsp]
  00c5c	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  00c60	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170719
  00c67	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  00c6c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170720
  00c73	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00c78	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00c7d	41 b9 03 00 00
	00		 mov	 r9d, 3
  00c83	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG170721
  00c8a	ba 9e 05 00 00	 mov	 edx, 1438		; 0000059eH
  00c8f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170722
  00c96	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 1439 :                 net_data_trace( pDEVBLK, (BYTE*)pCmdFrame, iLength, FROM_GUEST, 'D', "command", 0 );

  00c9c	0f b7 44 24 74	 movzx	 eax, WORD PTR iLength$[rsp]
  00ca1	c7 44 24 30 00
	00 00 00	 mov	 DWORD PTR [rsp+48], 0
  00ca9	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170723
  00cb0	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00cb5	c6 44 24 20 44	 mov	 BYTE PTR [rsp+32], 68	; 00000044H
  00cba	41 b1 3c	 mov	 r9b, 60			; 0000003cH
  00cbd	44 8b c0	 mov	 r8d, eax
  00cc0	48 8b 54 24 78	 mov	 rdx, QWORD PTR pCmdFrame$[rsp]
  00cc5	48 8b 8c 24 e0
	01 00 00	 mov	 rcx, QWORD PTR pDEVBLK$[rsp]
  00ccd	e8 00 00 00 00	 call	 net_data_trace
$LN115@LCS_Write:

; 1440 :             }
; 1441 : 
; 1442 :             // Ignore packets that appear to be inbound and not outbound.
; 1443 :             //
; 1444 :             // The Linux kernel LCS driver has two values defined that
; 1445 :             // might be found in variable pCmdFrame->bInitiator: #define
; 1446 :             // LCS_INITIATOR_TCPIP (0x00), and #define LCS_INITIATOR_LGW
; 1447 :             // (0x01), where 'LGW' is an abbreviation of 'LAN Gateway'.
; 1448 :             //
; 1449 :             // Older kernel LCS drivers had lots of code related to LGW,
; 1450 :             // but most of it has been removed from modern kernels (4.3,
; 1451 :             // at the time of writing).
; 1452 :             //
; 1453 :             // I'm not sure, but I think that applications, for example
; 1454 :             // IBM's Operator Facility/2, could send commands to a 3172
; 1455 :             // from a host attached to the LAN, and those commands would
; 1456 :             // arrive with pCmdFrame->bInitiator == LCS_INITIATOR_LGW.
; 1457 :             //
; 1458 :             // The current Linux kernel LCS driver only checks for the
; 1459 :             // pCmdFrame->bInitiator == LCS_INITIATOR_LGW in inbound
; 1460 :             // packets arriving from the LCS device; outbound packets
; 1461 :             // sent to the LCS device always have pCmdFrame->bInitiator
; 1462 :             // set to LCS_INITIATOR_TCPIP.
; 1463 : 
; 1464 :             if (pCmdFrame->bInitiator == LCS_INITIATOR_LGW)

  00cd2	48 8b 44 24 78	 mov	 rax, QWORD PTR pCmdFrame$[rsp]
  00cd7	0f b6 40 05	 movzx	 eax, BYTE PTR [rax+5]
  00cdb	83 f8 01	 cmp	 eax, 1
  00cde	0f 85 06 01 00
	00		 jne	 $LN116@LCS_Write
$LN41@LCS_Write:

; 1465 :             {
; 1466 :                 PTT_DEBUG( "CMD initiator LGW", pCmdFrame->bCmdCode, pDEVBLK->devnum, -1 );

  00ce4	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_pttclass
  00ceb	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00cee	48 25 00 00 02
	00		 and	 rax, 131072		; 00020000H
  00cf4	48 85 c0	 test	 rax, rax
  00cf7	74 4b		 je	 SHORT $LN117@LCS_Write
  00cf9	48 8b 84 24 e0
	01 00 00	 mov	 rax, QWORD PTR pDEVBLK$[rsp]
  00d01	0f b7 40 48	 movzx	 eax, WORD PTR [rax+72]
  00d05	48 8b 4c 24 78	 mov	 rcx, QWORD PTR pCmdFrame$[rsp]
  00d0a	0f b6 49 04	 movzx	 ecx, BYTE PTR [rcx+4]
  00d0e	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR [rsp+48], 0
  00d17	48 c7 44 24 28
	ff ff ff ff	 mov	 QWORD PTR [rsp+40], -1
  00d20	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG170726
  00d27	48 89 54 24 20	 mov	 QWORD PTR [rsp+32], rdx
  00d2c	44 8b c8	 mov	 r9d, eax
  00d2f	44 8b c1	 mov	 r8d, ecx
  00d32	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG170727
  00d39	b9 00 00 02 00	 mov	 ecx, 131072		; 00020000H
  00d3e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ptt_pthread_trace
$LN117@LCS_Write:
  00d44	33 c0		 xor	 eax, eax
  00d46	85 c0		 test	 eax, eax
  00d48	75 9a		 jne	 SHORT $LN41@LCS_Write

; 1467 :                 if (pLCSBLK->fDebug)

  00d4a	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR pLCSBLK$[rsp]
  00d52	8b 40 18	 mov	 eax, DWORD PTR [rax+24]
  00d55	83 e0 01	 and	 eax, 1
  00d58	85 c0		 test	 eax, eax
  00d5a	0f 84 85 00 00
	00		 je	 $LN118@LCS_Write

; 1468 :                     // "%1d:%04X CTC: lcs command packet IGNORED (bInitiator == LGW)"
; 1469 :                     WRMSG( HHC00977, "D", SSID_TO_LCSS( pDEVBLK->ssid ), pDEVBLK->devnum );

  00d60	48 8b 84 24 e0
	01 00 00	 mov	 rax, QWORD PTR pDEVBLK$[rsp]
  00d68	0f b7 40 48	 movzx	 eax, WORD PTR [rax+72]
  00d6c	89 84 24 e8 00
	00 00		 mov	 DWORD PTR tv521[rsp], eax
  00d73	48 8b 8c 24 e0
	01 00 00	 mov	 rcx, QWORD PTR pDEVBLK$[rsp]
  00d7b	0f b7 49 44	 movzx	 ecx, WORD PTR [rcx+68]
  00d7f	d1 f9		 sar	 ecx, 1
  00d81	89 8c 24 ec 00
	00 00		 mov	 DWORD PTR tv525[rsp], ecx
  00d88	b9 01 00 00 00	 mov	 ecx, 1
  00d8d	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  00d93	8b 8c 24 e8 00
	00 00		 mov	 ecx, DWORD PTR tv521[rsp]
  00d9a	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  00d9e	8b 8c 24 ec 00
	00 00		 mov	 ecx, DWORD PTR tv525[rsp]
  00da5	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  00da9	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170729
  00db0	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  00db5	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170730
  00dbc	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00dc1	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00dc6	41 b9 03 00 00
	00		 mov	 r9d, 3
  00dcc	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG170731
  00dd3	ba bd 05 00 00	 mov	 edx, 1469		; 000005bdH
  00dd8	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170732
  00ddf	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg
$LN118@LCS_Write:

; 1470 :                 break;

  00de5	e9 6c 0d 00 00	 jmp	 $LN10@LCS_Write
$LN116@LCS_Write:

; 1471 :             }
; 1472 : 
; 1473 :             switch (pCmdFrame->bCmdCode)

  00dea	48 8b 44 24 78	 mov	 rax, QWORD PTR pCmdFrame$[rsp]
  00def	0f b6 40 04	 movzx	 eax, BYTE PTR [rax+4]
  00df3	89 84 24 a8 00
	00 00		 mov	 DWORD PTR tv538[rsp], eax
  00dfa	8b 84 24 a8 00
	00 00		 mov	 eax, DWORD PTR tv538[rsp]
  00e01	ff c8		 dec	 eax
  00e03	89 84 24 a8 00
	00 00		 mov	 DWORD PTR tv538[rsp], eax
  00e0a	81 bc 24 a8 00
	00 00 b4 00 00
	00		 cmp	 DWORD PTR tv538[rsp], 180 ; 000000b4H
  00e15	0f 87 83 09 00
	00		 ja	 $LN143@LCS_Write
  00e1b	48 63 84 24 a8
	00 00 00	 movsxd	 rax, DWORD PTR tv538[rsp]
  00e23	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__ImageBase
  00e2a	0f b6 84 01 00
	00 00 00	 movzx	 eax, BYTE PTR $LN156@LCS_Write[rcx+rax]
  00e32	8b 84 81 00 00
	00 00		 mov	 eax, DWORD PTR $LN157@LCS_Write[rcx+rax*4]
  00e39	48 03 c1	 add	 rax, rcx
  00e3c	ff e0		 jmp	 rax
$LN119@LCS_Write:
$LN46@LCS_Write:

; 1474 :             {
; 1475 :                 //  HHC00933  =  "%1d:%04X CTC: executing command %s"
; 1476 : 
; 1477 :             case LCS_CMD_STARTUP:       // Start Host
; 1478 :                 PTT_DEBUG( "CMD=StartUp       ", pCmdFrame->bCmdCode, pDEVBLK->devnum, -1 );

  00e3e	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_pttclass
  00e45	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00e48	48 25 00 00 02
	00		 and	 rax, 131072		; 00020000H
  00e4e	48 85 c0	 test	 rax, rax
  00e51	74 4b		 je	 SHORT $LN120@LCS_Write
  00e53	48 8b 84 24 e0
	01 00 00	 mov	 rax, QWORD PTR pDEVBLK$[rsp]
  00e5b	0f b7 40 48	 movzx	 eax, WORD PTR [rax+72]
  00e5f	48 8b 4c 24 78	 mov	 rcx, QWORD PTR pCmdFrame$[rsp]
  00e64	0f b6 49 04	 movzx	 ecx, BYTE PTR [rcx+4]
  00e68	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR [rsp+48], 0
  00e71	48 c7 44 24 28
	ff ff ff ff	 mov	 QWORD PTR [rsp+40], -1
  00e7a	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG170735
  00e81	48 89 54 24 20	 mov	 QWORD PTR [rsp+32], rdx
  00e86	44 8b c8	 mov	 r9d, eax
  00e89	44 8b c1	 mov	 r8d, ecx
  00e8c	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG170736
  00e93	b9 00 00 02 00	 mov	 ecx, 131072		; 00020000H
  00e98	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ptt_pthread_trace
$LN120@LCS_Write:
  00e9e	33 c0		 xor	 eax, eax
  00ea0	85 c0		 test	 eax, eax
  00ea2	75 9a		 jne	 SHORT $LN46@LCS_Write

; 1479 :                 if (pLCSBLK->fDebug)

  00ea4	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR pLCSBLK$[rsp]
  00eac	8b 40 18	 mov	 eax, DWORD PTR [rax+24]
  00eaf	83 e0 01	 and	 eax, 1
  00eb2	85 c0		 test	 eax, eax
  00eb4	0f 84 91 00 00
	00		 je	 $LN121@LCS_Write

; 1480 :                     WRMSG( HHC00933, "D", SSID_TO_LCSS(pDEVBLK->ssid), pDEVBLK->devnum, "startup" );

  00eba	48 8b 84 24 e0
	01 00 00	 mov	 rax, QWORD PTR pDEVBLK$[rsp]
  00ec2	0f b7 40 48	 movzx	 eax, WORD PTR [rax+72]
  00ec6	89 84 24 f0 00
	00 00		 mov	 DWORD PTR tv558[rsp], eax
  00ecd	48 8b 8c 24 e0
	01 00 00	 mov	 rcx, QWORD PTR pDEVBLK$[rsp]
  00ed5	0f b7 49 44	 movzx	 ecx, WORD PTR [rcx+68]
  00ed9	d1 f9		 sar	 ecx, 1
  00edb	89 8c 24 f4 00
	00 00		 mov	 DWORD PTR tv562[rsp], ecx
  00ee2	b9 01 00 00 00	 mov	 ecx, 1
  00ee7	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  00eed	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170738
  00ef4	48 89 4c 24 48	 mov	 QWORD PTR [rsp+72], rcx
  00ef9	8b 8c 24 f0 00
	00 00		 mov	 ecx, DWORD PTR tv558[rsp]
  00f00	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  00f04	8b 8c 24 f4 00
	00 00		 mov	 ecx, DWORD PTR tv562[rsp]
  00f0b	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  00f0f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170739
  00f16	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  00f1b	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170740
  00f22	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00f27	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00f2c	41 b9 03 00 00
	00		 mov	 r9d, 3
  00f32	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG170741
  00f39	ba c8 05 00 00	 mov	 edx, 1480		; 000005c8H
  00f3e	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170742
  00f45	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg
$LN121@LCS_Write:

; 1481 :                 LCS_Startup( pLCSDEV, pCmdFrame, iLength );

  00f4b	0f b7 44 24 74	 movzx	 eax, WORD PTR iLength$[rsp]
  00f50	44 8b c0	 mov	 r8d, eax
  00f53	48 8b 54 24 78	 mov	 rdx, QWORD PTR pCmdFrame$[rsp]
  00f58	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR pLCSDEV$[rsp]
  00f60	e8 00 00 00 00	 call	 LCS_Startup

; 1482 :                 break;

  00f65	e9 82 09 00 00	 jmp	 $LN42@LCS_Write
$LN122@LCS_Write:
$LN49@LCS_Write:

; 1483 : 
; 1484 :             case LCS_CMD_SHUTDOWN:      // Shutdown Host
; 1485 :                 PTT_DEBUG( "CMD=Shutdown      ", pCmdFrame->bCmdCode, pDEVBLK->devnum, -1 );

  00f6a	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_pttclass
  00f71	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00f74	48 25 00 00 02
	00		 and	 rax, 131072		; 00020000H
  00f7a	48 85 c0	 test	 rax, rax
  00f7d	74 4b		 je	 SHORT $LN123@LCS_Write
  00f7f	48 8b 84 24 e0
	01 00 00	 mov	 rax, QWORD PTR pDEVBLK$[rsp]
  00f87	0f b7 40 48	 movzx	 eax, WORD PTR [rax+72]
  00f8b	48 8b 4c 24 78	 mov	 rcx, QWORD PTR pCmdFrame$[rsp]
  00f90	0f b6 49 04	 movzx	 ecx, BYTE PTR [rcx+4]
  00f94	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR [rsp+48], 0
  00f9d	48 c7 44 24 28
	ff ff ff ff	 mov	 QWORD PTR [rsp+40], -1
  00fa6	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG170745
  00fad	48 89 54 24 20	 mov	 QWORD PTR [rsp+32], rdx
  00fb2	44 8b c8	 mov	 r9d, eax
  00fb5	44 8b c1	 mov	 r8d, ecx
  00fb8	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG170746
  00fbf	b9 00 00 02 00	 mov	 ecx, 131072		; 00020000H
  00fc4	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ptt_pthread_trace
$LN123@LCS_Write:
  00fca	33 c0		 xor	 eax, eax
  00fcc	85 c0		 test	 eax, eax
  00fce	75 9a		 jne	 SHORT $LN49@LCS_Write

; 1486 :                 if (pLCSBLK->fDebug)

  00fd0	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR pLCSBLK$[rsp]
  00fd8	8b 40 18	 mov	 eax, DWORD PTR [rax+24]
  00fdb	83 e0 01	 and	 eax, 1
  00fde	85 c0		 test	 eax, eax
  00fe0	0f 84 91 00 00
	00		 je	 $LN124@LCS_Write

; 1487 :                     WRMSG( HHC00933, "D", SSID_TO_LCSS(pDEVBLK->ssid), pDEVBLK->devnum, "shutdown" );

  00fe6	48 8b 84 24 e0
	01 00 00	 mov	 rax, QWORD PTR pDEVBLK$[rsp]
  00fee	0f b7 40 48	 movzx	 eax, WORD PTR [rax+72]
  00ff2	89 84 24 f8 00
	00 00		 mov	 DWORD PTR tv596[rsp], eax
  00ff9	48 8b 8c 24 e0
	01 00 00	 mov	 rcx, QWORD PTR pDEVBLK$[rsp]
  01001	0f b7 49 44	 movzx	 ecx, WORD PTR [rcx+68]
  01005	d1 f9		 sar	 ecx, 1
  01007	89 8c 24 fc 00
	00 00		 mov	 DWORD PTR tv600[rsp], ecx
  0100e	b9 01 00 00 00	 mov	 ecx, 1
  01013	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  01019	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170748
  01020	48 89 4c 24 48	 mov	 QWORD PTR [rsp+72], rcx
  01025	8b 8c 24 f8 00
	00 00		 mov	 ecx, DWORD PTR tv596[rsp]
  0102c	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  01030	8b 8c 24 fc 00
	00 00		 mov	 ecx, DWORD PTR tv600[rsp]
  01037	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  0103b	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170749
  01042	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  01047	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170750
  0104e	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  01053	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  01058	41 b9 03 00 00
	00		 mov	 r9d, 3
  0105e	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG170751
  01065	ba cf 05 00 00	 mov	 edx, 1487		; 000005cfH
  0106a	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170752
  01071	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg
$LN124@LCS_Write:

; 1488 :                 LCS_Shutdown( pLCSDEV, pCmdFrame, iLength );

  01077	0f b7 44 24 74	 movzx	 eax, WORD PTR iLength$[rsp]
  0107c	44 8b c0	 mov	 r8d, eax
  0107f	48 8b 54 24 78	 mov	 rdx, QWORD PTR pCmdFrame$[rsp]
  01084	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR pLCSDEV$[rsp]
  0108c	e8 00 00 00 00	 call	 LCS_Shutdown

; 1489 :                 break;

  01091	e9 56 08 00 00	 jmp	 $LN42@LCS_Write
$LN125@LCS_Write:
$LN52@LCS_Write:

; 1490 : 
; 1491 :             case LCS_CMD_STRTLAN:       // Start LAN
; 1492 :                 PTT_DEBUG( "CMD=Start LAN     ", pCmdFrame->bCmdCode, pDEVBLK->devnum, -1 );

  01096	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_pttclass
  0109d	48 8b 00	 mov	 rax, QWORD PTR [rax]
  010a0	48 25 00 00 02
	00		 and	 rax, 131072		; 00020000H
  010a6	48 85 c0	 test	 rax, rax
  010a9	74 4b		 je	 SHORT $LN126@LCS_Write
  010ab	48 8b 84 24 e0
	01 00 00	 mov	 rax, QWORD PTR pDEVBLK$[rsp]
  010b3	0f b7 40 48	 movzx	 eax, WORD PTR [rax+72]
  010b7	48 8b 4c 24 78	 mov	 rcx, QWORD PTR pCmdFrame$[rsp]
  010bc	0f b6 49 04	 movzx	 ecx, BYTE PTR [rcx+4]
  010c0	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR [rsp+48], 0
  010c9	48 c7 44 24 28
	ff ff ff ff	 mov	 QWORD PTR [rsp+40], -1
  010d2	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG170755
  010d9	48 89 54 24 20	 mov	 QWORD PTR [rsp+32], rdx
  010de	44 8b c8	 mov	 r9d, eax
  010e1	44 8b c1	 mov	 r8d, ecx
  010e4	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG170756
  010eb	b9 00 00 02 00	 mov	 ecx, 131072		; 00020000H
  010f0	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ptt_pthread_trace
$LN126@LCS_Write:
  010f6	33 c0		 xor	 eax, eax
  010f8	85 c0		 test	 eax, eax
  010fa	75 9a		 jne	 SHORT $LN52@LCS_Write

; 1493 :                 if (pLCSBLK->fDebug)

  010fc	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR pLCSBLK$[rsp]
  01104	8b 40 18	 mov	 eax, DWORD PTR [rax+24]
  01107	83 e0 01	 and	 eax, 1
  0110a	85 c0		 test	 eax, eax
  0110c	0f 84 91 00 00
	00		 je	 $LN127@LCS_Write

; 1494 :                     WRMSG( HHC00933, "D", SSID_TO_LCSS(pDEVBLK->ssid), pDEVBLK->devnum, "start lan" );

  01112	48 8b 84 24 e0
	01 00 00	 mov	 rax, QWORD PTR pDEVBLK$[rsp]
  0111a	0f b7 40 48	 movzx	 eax, WORD PTR [rax+72]
  0111e	89 84 24 00 01
	00 00		 mov	 DWORD PTR tv666[rsp], eax
  01125	48 8b 8c 24 e0
	01 00 00	 mov	 rcx, QWORD PTR pDEVBLK$[rsp]
  0112d	0f b7 49 44	 movzx	 ecx, WORD PTR [rcx+68]
  01131	d1 f9		 sar	 ecx, 1
  01133	89 8c 24 04 01
	00 00		 mov	 DWORD PTR tv670[rsp], ecx
  0113a	b9 01 00 00 00	 mov	 ecx, 1
  0113f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  01145	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170758
  0114c	48 89 4c 24 48	 mov	 QWORD PTR [rsp+72], rcx
  01151	8b 8c 24 00 01
	00 00		 mov	 ecx, DWORD PTR tv666[rsp]
  01158	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  0115c	8b 8c 24 04 01
	00 00		 mov	 ecx, DWORD PTR tv670[rsp]
  01163	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  01167	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170759
  0116e	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  01173	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170760
  0117a	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  0117f	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  01184	41 b9 03 00 00
	00		 mov	 r9d, 3
  0118a	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG170761
  01191	ba d6 05 00 00	 mov	 edx, 1494		; 000005d6H
  01196	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170762
  0119d	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg
$LN127@LCS_Write:

; 1495 :                 LCS_StartLan( pLCSDEV, pCmdFrame, iLength );

  011a3	0f b7 44 24 74	 movzx	 eax, WORD PTR iLength$[rsp]
  011a8	44 8b c0	 mov	 r8d, eax
  011ab	48 8b 54 24 78	 mov	 rdx, QWORD PTR pCmdFrame$[rsp]
  011b0	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR pLCSDEV$[rsp]
  011b8	e8 00 00 00 00	 call	 LCS_StartLan

; 1496 :                 break;

  011bd	e9 2a 07 00 00	 jmp	 $LN42@LCS_Write
$LN128@LCS_Write:
$LN55@LCS_Write:

; 1497 : 
; 1498 :             case LCS_CMD_STOPLAN:       // Stop LAN
; 1499 :                 PTT_DEBUG( "CMD=Stop LAN      ", pCmdFrame->bCmdCode, pDEVBLK->devnum, -1 );

  011c2	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_pttclass
  011c9	48 8b 00	 mov	 rax, QWORD PTR [rax]
  011cc	48 25 00 00 02
	00		 and	 rax, 131072		; 00020000H
  011d2	48 85 c0	 test	 rax, rax
  011d5	74 4b		 je	 SHORT $LN129@LCS_Write
  011d7	48 8b 84 24 e0
	01 00 00	 mov	 rax, QWORD PTR pDEVBLK$[rsp]
  011df	0f b7 40 48	 movzx	 eax, WORD PTR [rax+72]
  011e3	48 8b 4c 24 78	 mov	 rcx, QWORD PTR pCmdFrame$[rsp]
  011e8	0f b6 49 04	 movzx	 ecx, BYTE PTR [rcx+4]
  011ec	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR [rsp+48], 0
  011f5	48 c7 44 24 28
	ff ff ff ff	 mov	 QWORD PTR [rsp+40], -1
  011fe	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG170765
  01205	48 89 54 24 20	 mov	 QWORD PTR [rsp+32], rdx
  0120a	44 8b c8	 mov	 r9d, eax
  0120d	44 8b c1	 mov	 r8d, ecx
  01210	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG170766
  01217	b9 00 00 02 00	 mov	 ecx, 131072		; 00020000H
  0121c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ptt_pthread_trace
$LN129@LCS_Write:
  01222	33 c0		 xor	 eax, eax
  01224	85 c0		 test	 eax, eax
  01226	75 9a		 jne	 SHORT $LN55@LCS_Write

; 1500 :                 if (pLCSBLK->fDebug)

  01228	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR pLCSBLK$[rsp]
  01230	8b 40 18	 mov	 eax, DWORD PTR [rax+24]
  01233	83 e0 01	 and	 eax, 1
  01236	85 c0		 test	 eax, eax
  01238	0f 84 91 00 00
	00		 je	 $LN130@LCS_Write

; 1501 :                     WRMSG( HHC00933, "D", SSID_TO_LCSS(pDEVBLK->ssid), pDEVBLK->devnum, "stop lan" );

  0123e	48 8b 84 24 e0
	01 00 00	 mov	 rax, QWORD PTR pDEVBLK$[rsp]
  01246	0f b7 40 48	 movzx	 eax, WORD PTR [rax+72]
  0124a	89 84 24 08 01
	00 00		 mov	 DWORD PTR tv704[rsp], eax
  01251	48 8b 8c 24 e0
	01 00 00	 mov	 rcx, QWORD PTR pDEVBLK$[rsp]
  01259	0f b7 49 44	 movzx	 ecx, WORD PTR [rcx+68]
  0125d	d1 f9		 sar	 ecx, 1
  0125f	89 8c 24 0c 01
	00 00		 mov	 DWORD PTR tv708[rsp], ecx
  01266	b9 01 00 00 00	 mov	 ecx, 1
  0126b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  01271	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170768
  01278	48 89 4c 24 48	 mov	 QWORD PTR [rsp+72], rcx
  0127d	8b 8c 24 08 01
	00 00		 mov	 ecx, DWORD PTR tv704[rsp]
  01284	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  01288	8b 8c 24 0c 01
	00 00		 mov	 ecx, DWORD PTR tv708[rsp]
  0128f	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  01293	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170769
  0129a	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  0129f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170770
  012a6	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  012ab	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  012b0	41 b9 03 00 00
	00		 mov	 r9d, 3
  012b6	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG170771
  012bd	ba dd 05 00 00	 mov	 edx, 1501		; 000005ddH
  012c2	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170772
  012c9	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg
$LN130@LCS_Write:

; 1502 :                 LCS_StopLan( pLCSDEV, pCmdFrame, iLength );

  012cf	0f b7 44 24 74	 movzx	 eax, WORD PTR iLength$[rsp]
  012d4	44 8b c0	 mov	 r8d, eax
  012d7	48 8b 54 24 78	 mov	 rdx, QWORD PTR pCmdFrame$[rsp]
  012dc	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR pLCSDEV$[rsp]
  012e4	e8 00 00 00 00	 call	 LCS_StopLan

; 1503 :                 break;

  012e9	e9 fe 05 00 00	 jmp	 $LN42@LCS_Write
$LN131@LCS_Write:
$LN58@LCS_Write:

; 1504 : 
; 1505 :             case LCS_CMD_QIPASSIST:     // Query IP Assists
; 1506 :                 PTT_DEBUG( "CMD=Query IPAssist", pCmdFrame->bCmdCode, pDEVBLK->devnum, -1 );

  012ee	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_pttclass
  012f5	48 8b 00	 mov	 rax, QWORD PTR [rax]
  012f8	48 25 00 00 02
	00		 and	 rax, 131072		; 00020000H
  012fe	48 85 c0	 test	 rax, rax
  01301	74 4b		 je	 SHORT $LN132@LCS_Write
  01303	48 8b 84 24 e0
	01 00 00	 mov	 rax, QWORD PTR pDEVBLK$[rsp]
  0130b	0f b7 40 48	 movzx	 eax, WORD PTR [rax+72]
  0130f	48 8b 4c 24 78	 mov	 rcx, QWORD PTR pCmdFrame$[rsp]
  01314	0f b6 49 04	 movzx	 ecx, BYTE PTR [rcx+4]
  01318	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR [rsp+48], 0
  01321	48 c7 44 24 28
	ff ff ff ff	 mov	 QWORD PTR [rsp+40], -1
  0132a	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG170775
  01331	48 89 54 24 20	 mov	 QWORD PTR [rsp+32], rdx
  01336	44 8b c8	 mov	 r9d, eax
  01339	44 8b c1	 mov	 r8d, ecx
  0133c	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG170776
  01343	b9 00 00 02 00	 mov	 ecx, 131072		; 00020000H
  01348	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ptt_pthread_trace
$LN132@LCS_Write:
  0134e	33 c0		 xor	 eax, eax
  01350	85 c0		 test	 eax, eax
  01352	75 9a		 jne	 SHORT $LN58@LCS_Write

; 1507 :                 if (pLCSBLK->fDebug)

  01354	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR pLCSBLK$[rsp]
  0135c	8b 40 18	 mov	 eax, DWORD PTR [rax+24]
  0135f	83 e0 01	 and	 eax, 1
  01362	85 c0		 test	 eax, eax
  01364	0f 84 91 00 00
	00		 je	 $LN133@LCS_Write

; 1508 :                     WRMSG( HHC00933, "D", SSID_TO_LCSS(pDEVBLK->ssid), pDEVBLK->devnum, "query IP assist" );

  0136a	48 8b 84 24 e0
	01 00 00	 mov	 rax, QWORD PTR pDEVBLK$[rsp]
  01372	0f b7 40 48	 movzx	 eax, WORD PTR [rax+72]
  01376	89 84 24 10 01
	00 00		 mov	 DWORD PTR tv742[rsp], eax
  0137d	48 8b 8c 24 e0
	01 00 00	 mov	 rcx, QWORD PTR pDEVBLK$[rsp]
  01385	0f b7 49 44	 movzx	 ecx, WORD PTR [rcx+68]
  01389	d1 f9		 sar	 ecx, 1
  0138b	89 8c 24 14 01
	00 00		 mov	 DWORD PTR tv746[rsp], ecx
  01392	b9 01 00 00 00	 mov	 ecx, 1
  01397	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  0139d	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170778
  013a4	48 89 4c 24 48	 mov	 QWORD PTR [rsp+72], rcx
  013a9	8b 8c 24 10 01
	00 00		 mov	 ecx, DWORD PTR tv742[rsp]
  013b0	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  013b4	8b 8c 24 14 01
	00 00		 mov	 ecx, DWORD PTR tv746[rsp]
  013bb	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  013bf	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170779
  013c6	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  013cb	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170780
  013d2	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  013d7	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  013dc	41 b9 03 00 00
	00		 mov	 r9d, 3
  013e2	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG170781
  013e9	ba e4 05 00 00	 mov	 edx, 1508		; 000005e4H
  013ee	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170782
  013f5	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg
$LN133@LCS_Write:

; 1509 :                 LCS_QueryIPAssists( pLCSDEV, pCmdFrame, iLength );

  013fb	0f b7 44 24 74	 movzx	 eax, WORD PTR iLength$[rsp]
  01400	44 8b c0	 mov	 r8d, eax
  01403	48 8b 54 24 78	 mov	 rdx, QWORD PTR pCmdFrame$[rsp]
  01408	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR pLCSDEV$[rsp]
  01410	e8 00 00 00 00	 call	 LCS_QueryIPAssists

; 1510 :                 break;

  01415	e9 d2 04 00 00	 jmp	 $LN42@LCS_Write
$LN134@LCS_Write:
$LN61@LCS_Write:

; 1511 : 
; 1512 :             case LCS_CMD_LANSTAT:       // LAN Stats
; 1513 :                 PTT_DEBUG( "CMD=LAN Statistics", pCmdFrame->bCmdCode, pDEVBLK->devnum, -1 );

  0141a	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_pttclass
  01421	48 8b 00	 mov	 rax, QWORD PTR [rax]
  01424	48 25 00 00 02
	00		 and	 rax, 131072		; 00020000H
  0142a	48 85 c0	 test	 rax, rax
  0142d	74 4b		 je	 SHORT $LN135@LCS_Write
  0142f	48 8b 84 24 e0
	01 00 00	 mov	 rax, QWORD PTR pDEVBLK$[rsp]
  01437	0f b7 40 48	 movzx	 eax, WORD PTR [rax+72]
  0143b	48 8b 4c 24 78	 mov	 rcx, QWORD PTR pCmdFrame$[rsp]
  01440	0f b6 49 04	 movzx	 ecx, BYTE PTR [rcx+4]
  01444	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR [rsp+48], 0
  0144d	48 c7 44 24 28
	ff ff ff ff	 mov	 QWORD PTR [rsp+40], -1
  01456	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG170785
  0145d	48 89 54 24 20	 mov	 QWORD PTR [rsp+32], rdx
  01462	44 8b c8	 mov	 r9d, eax
  01465	44 8b c1	 mov	 r8d, ecx
  01468	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG170786
  0146f	b9 00 00 02 00	 mov	 ecx, 131072		; 00020000H
  01474	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ptt_pthread_trace
$LN135@LCS_Write:
  0147a	33 c0		 xor	 eax, eax
  0147c	85 c0		 test	 eax, eax
  0147e	75 9a		 jne	 SHORT $LN61@LCS_Write

; 1514 :                 if (pLCSBLK->fDebug)

  01480	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR pLCSBLK$[rsp]
  01488	8b 40 18	 mov	 eax, DWORD PTR [rax+24]
  0148b	83 e0 01	 and	 eax, 1
  0148e	85 c0		 test	 eax, eax
  01490	0f 84 91 00 00
	00		 je	 $LN136@LCS_Write

; 1515 :                     WRMSG( HHC00933, "D", SSID_TO_LCSS(pDEVBLK->ssid), pDEVBLK->devnum, "lan statistics" );

  01496	48 8b 84 24 e0
	01 00 00	 mov	 rax, QWORD PTR pDEVBLK$[rsp]
  0149e	0f b7 40 48	 movzx	 eax, WORD PTR [rax+72]
  014a2	89 84 24 18 01
	00 00		 mov	 DWORD PTR tv780[rsp], eax
  014a9	48 8b 8c 24 e0
	01 00 00	 mov	 rcx, QWORD PTR pDEVBLK$[rsp]
  014b1	0f b7 49 44	 movzx	 ecx, WORD PTR [rcx+68]
  014b5	d1 f9		 sar	 ecx, 1
  014b7	89 8c 24 1c 01
	00 00		 mov	 DWORD PTR tv784[rsp], ecx
  014be	b9 01 00 00 00	 mov	 ecx, 1
  014c3	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  014c9	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170788
  014d0	48 89 4c 24 48	 mov	 QWORD PTR [rsp+72], rcx
  014d5	8b 8c 24 18 01
	00 00		 mov	 ecx, DWORD PTR tv780[rsp]
  014dc	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  014e0	8b 8c 24 1c 01
	00 00		 mov	 ecx, DWORD PTR tv784[rsp]
  014e7	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  014eb	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170789
  014f2	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  014f7	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170790
  014fe	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  01503	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  01508	41 b9 03 00 00
	00		 mov	 r9d, 3
  0150e	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG170791
  01515	ba eb 05 00 00	 mov	 edx, 1515		; 000005ebH
  0151a	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170792
  01521	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg
$LN136@LCS_Write:

; 1516 :                 LCS_LanStats( pLCSDEV, pCmdFrame, iLength );

  01527	0f b7 44 24 74	 movzx	 eax, WORD PTR iLength$[rsp]
  0152c	44 8b c0	 mov	 r8d, eax
  0152f	48 8b 54 24 78	 mov	 rdx, QWORD PTR pCmdFrame$[rsp]
  01534	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR pLCSDEV$[rsp]
  0153c	e8 00 00 00 00	 call	 LCS_LanStats

; 1517 :                 break;

  01541	e9 a6 03 00 00	 jmp	 $LN42@LCS_Write
$LN137@LCS_Write:
$LN64@LCS_Write:

; 1518 : 
; 1519 :             case LCS_CMD_SETIPM:        // Set IP Multicast
; 1520 :                 PTT_DEBUG( "CMD=Set IP Multicast", pCmdFrame->bCmdCode, pDEVBLK->devnum, -1 );

  01546	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_pttclass
  0154d	48 8b 00	 mov	 rax, QWORD PTR [rax]
  01550	48 25 00 00 02
	00		 and	 rax, 131072		; 00020000H
  01556	48 85 c0	 test	 rax, rax
  01559	74 4b		 je	 SHORT $LN138@LCS_Write
  0155b	48 8b 84 24 e0
	01 00 00	 mov	 rax, QWORD PTR pDEVBLK$[rsp]
  01563	0f b7 40 48	 movzx	 eax, WORD PTR [rax+72]
  01567	48 8b 4c 24 78	 mov	 rcx, QWORD PTR pCmdFrame$[rsp]
  0156c	0f b6 49 04	 movzx	 ecx, BYTE PTR [rcx+4]
  01570	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR [rsp+48], 0
  01579	48 c7 44 24 28
	ff ff ff ff	 mov	 QWORD PTR [rsp+40], -1
  01582	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG170795
  01589	48 89 54 24 20	 mov	 QWORD PTR [rsp+32], rdx
  0158e	44 8b c8	 mov	 r9d, eax
  01591	44 8b c1	 mov	 r8d, ecx
  01594	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG170796
  0159b	b9 00 00 02 00	 mov	 ecx, 131072		; 00020000H
  015a0	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ptt_pthread_trace
$LN138@LCS_Write:
  015a6	33 c0		 xor	 eax, eax
  015a8	85 c0		 test	 eax, eax
  015aa	75 9a		 jne	 SHORT $LN64@LCS_Write

; 1521 :                 if (pLCSBLK->fDebug)

  015ac	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR pLCSBLK$[rsp]
  015b4	8b 40 18	 mov	 eax, DWORD PTR [rax+24]
  015b7	83 e0 01	 and	 eax, 1
  015ba	85 c0		 test	 eax, eax
  015bc	0f 84 91 00 00
	00		 je	 $LN139@LCS_Write

; 1522 :                     WRMSG( HHC00933, "D", SSID_TO_LCSS(pDEVBLK->ssid), pDEVBLK->devnum, "set multicast" );

  015c2	48 8b 84 24 e0
	01 00 00	 mov	 rax, QWORD PTR pDEVBLK$[rsp]
  015ca	0f b7 40 48	 movzx	 eax, WORD PTR [rax+72]
  015ce	89 84 24 20 01
	00 00		 mov	 DWORD PTR tv850[rsp], eax
  015d5	48 8b 8c 24 e0
	01 00 00	 mov	 rcx, QWORD PTR pDEVBLK$[rsp]
  015dd	0f b7 49 44	 movzx	 ecx, WORD PTR [rcx+68]
  015e1	d1 f9		 sar	 ecx, 1
  015e3	89 8c 24 24 01
	00 00		 mov	 DWORD PTR tv854[rsp], ecx
  015ea	b9 01 00 00 00	 mov	 ecx, 1
  015ef	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  015f5	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170798
  015fc	48 89 4c 24 48	 mov	 QWORD PTR [rsp+72], rcx
  01601	8b 8c 24 20 01
	00 00		 mov	 ecx, DWORD PTR tv850[rsp]
  01608	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  0160c	8b 8c 24 24 01
	00 00		 mov	 ecx, DWORD PTR tv854[rsp]
  01613	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  01617	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170799
  0161e	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  01623	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170800
  0162a	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  0162f	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  01634	41 b9 03 00 00
	00		 mov	 r9d, 3
  0163a	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG170801
  01641	ba f2 05 00 00	 mov	 edx, 1522		; 000005f2H
  01646	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170802
  0164d	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg
$LN139@LCS_Write:

; 1523 :                 LCS_AddMulticast( pLCSDEV, pCmdFrame, iLength );

  01653	0f b7 44 24 74	 movzx	 eax, WORD PTR iLength$[rsp]
  01658	44 8b c0	 mov	 r8d, eax
  0165b	48 8b 54 24 78	 mov	 rdx, QWORD PTR pCmdFrame$[rsp]
  01660	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR pLCSDEV$[rsp]
  01668	e8 00 00 00 00	 call	 LCS_AddMulticast

; 1524 :                 break;

  0166d	e9 7a 02 00 00	 jmp	 $LN42@LCS_Write
$LN140@LCS_Write:
$LN67@LCS_Write:

; 1525 : 
; 1526 :             case LCS_CMD_DELIPM:        // Delete IP Multicast
; 1527 :                 PTT_DEBUG( "CMD=Delete IP Multicast", pCmdFrame->bCmdCode, pDEVBLK->devnum, -1 );

  01672	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_pttclass
  01679	48 8b 00	 mov	 rax, QWORD PTR [rax]
  0167c	48 25 00 00 02
	00		 and	 rax, 131072		; 00020000H
  01682	48 85 c0	 test	 rax, rax
  01685	74 4b		 je	 SHORT $LN141@LCS_Write
  01687	48 8b 84 24 e0
	01 00 00	 mov	 rax, QWORD PTR pDEVBLK$[rsp]
  0168f	0f b7 40 48	 movzx	 eax, WORD PTR [rax+72]
  01693	48 8b 4c 24 78	 mov	 rcx, QWORD PTR pCmdFrame$[rsp]
  01698	0f b6 49 04	 movzx	 ecx, BYTE PTR [rcx+4]
  0169c	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR [rsp+48], 0
  016a5	48 c7 44 24 28
	ff ff ff ff	 mov	 QWORD PTR [rsp+40], -1
  016ae	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG170805
  016b5	48 89 54 24 20	 mov	 QWORD PTR [rsp+32], rdx
  016ba	44 8b c8	 mov	 r9d, eax
  016bd	44 8b c1	 mov	 r8d, ecx
  016c0	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG170806
  016c7	b9 00 00 02 00	 mov	 ecx, 131072		; 00020000H
  016cc	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ptt_pthread_trace
$LN141@LCS_Write:
  016d2	33 c0		 xor	 eax, eax
  016d4	85 c0		 test	 eax, eax
  016d6	75 9a		 jne	 SHORT $LN67@LCS_Write

; 1528 :                 if (pLCSBLK->fDebug)

  016d8	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR pLCSBLK$[rsp]
  016e0	8b 40 18	 mov	 eax, DWORD PTR [rax+24]
  016e3	83 e0 01	 and	 eax, 1
  016e6	85 c0		 test	 eax, eax
  016e8	0f 84 91 00 00
	00		 je	 $LN142@LCS_Write

; 1529 :                     WRMSG( HHC00933, "D", SSID_TO_LCSS(pDEVBLK->ssid), pDEVBLK->devnum, "delete multicast" );

  016ee	48 8b 84 24 e0
	01 00 00	 mov	 rax, QWORD PTR pDEVBLK$[rsp]
  016f6	0f b7 40 48	 movzx	 eax, WORD PTR [rax+72]
  016fa	89 84 24 28 01
	00 00		 mov	 DWORD PTR tv888[rsp], eax
  01701	48 8b 8c 24 e0
	01 00 00	 mov	 rcx, QWORD PTR pDEVBLK$[rsp]
  01709	0f b7 49 44	 movzx	 ecx, WORD PTR [rcx+68]
  0170d	d1 f9		 sar	 ecx, 1
  0170f	89 8c 24 2c 01
	00 00		 mov	 DWORD PTR tv892[rsp], ecx
  01716	b9 01 00 00 00	 mov	 ecx, 1
  0171b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  01721	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170808
  01728	48 89 4c 24 48	 mov	 QWORD PTR [rsp+72], rcx
  0172d	8b 8c 24 28 01
	00 00		 mov	 ecx, DWORD PTR tv888[rsp]
  01734	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  01738	8b 8c 24 2c 01
	00 00		 mov	 ecx, DWORD PTR tv892[rsp]
  0173f	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  01743	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170809
  0174a	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  0174f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170810
  01756	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  0175b	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  01760	41 b9 03 00 00
	00		 mov	 r9d, 3
  01766	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG170811
  0176d	ba f9 05 00 00	 mov	 edx, 1529		; 000005f9H
  01772	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170812
  01779	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg
$LN142@LCS_Write:

; 1530 :                 LCS_DelMulticast( pLCSDEV, pCmdFrame, iLength );

  0177f	0f b7 44 24 74	 movzx	 eax, WORD PTR iLength$[rsp]
  01784	44 8b c0	 mov	 r8d, eax
  01787	48 8b 54 24 78	 mov	 rdx, QWORD PTR pCmdFrame$[rsp]
  0178c	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR pLCSDEV$[rsp]
  01794	e8 00 00 00 00	 call	 LCS_DelMulticast

; 1531 :                 break;

  01799	e9 4e 01 00 00	 jmp	 $LN42@LCS_Write
$LN143@LCS_Write:
$LN70@LCS_Write:

; 1532 : 
; 1533 : //          case LCS_CMD_GENSTAT:       // General Stats
; 1534 : //          case LCS_CMD_LISTLAN:       // List LAN
; 1535 : //          case LCS_CMD_LISTLAN2:      // List LAN (another version)
; 1536 : //          case LCS_CMD_TIMING:        // Timing request
; 1537 :             default:
; 1538 :                 PTT_DEBUG( "*CMD=Unsupported! ", pCmdFrame->bCmdCode, pDEVBLK->devnum, -1 );

  0179e	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_pttclass
  017a5	48 8b 00	 mov	 rax, QWORD PTR [rax]
  017a8	48 25 00 00 02
	00		 and	 rax, 131072		; 00020000H
  017ae	48 85 c0	 test	 rax, rax
  017b1	74 4b		 je	 SHORT $LN144@LCS_Write
  017b3	48 8b 84 24 e0
	01 00 00	 mov	 rax, QWORD PTR pDEVBLK$[rsp]
  017bb	0f b7 40 48	 movzx	 eax, WORD PTR [rax+72]
  017bf	48 8b 4c 24 78	 mov	 rcx, QWORD PTR pCmdFrame$[rsp]
  017c4	0f b6 49 04	 movzx	 ecx, BYTE PTR [rcx+4]
  017c8	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR [rsp+48], 0
  017d1	48 c7 44 24 28
	ff ff ff ff	 mov	 QWORD PTR [rsp+40], -1
  017da	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG170815
  017e1	48 89 54 24 20	 mov	 QWORD PTR [rsp+32], rdx
  017e6	44 8b c8	 mov	 r9d, eax
  017e9	44 8b c1	 mov	 r8d, ecx
  017ec	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG170816
  017f3	b9 00 00 02 00	 mov	 ecx, 131072		; 00020000H
  017f8	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ptt_pthread_trace
$LN144@LCS_Write:
  017fe	33 c0		 xor	 eax, eax
  01800	85 c0		 test	 eax, eax
  01802	75 9a		 jne	 SHORT $LN70@LCS_Write

; 1539 :                 if (pLCSBLK->fDebug)

  01804	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR pLCSBLK$[rsp]
  0180c	8b 40 18	 mov	 eax, DWORD PTR [rax+24]
  0180f	83 e0 01	 and	 eax, 1
  01812	85 c0		 test	 eax, eax
  01814	0f 84 b8 00 00
	00		 je	 $LN145@LCS_Write

; 1540 :                 {
; 1541 :                     // "%1d:%04X CTC: executing command %s"
; 1542 :                     MSGBUF( buf, "other (0x%2.2X)", pCmdFrame->bCmdCode );

  0181a	48 8b 44 24 78	 mov	 rax, QWORD PTR pCmdFrame$[rsp]
  0181f	0f b6 40 04	 movzx	 eax, BYTE PTR [rax+4]
  01823	44 8b c8	 mov	 r9d, eax
  01826	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG170818
  0182d	ba 20 00 00 00	 mov	 edx, 32			; 00000020H
  01832	48 8d 8c 24 98
	01 00 00	 lea	 rcx, QWORD PTR buf$[rsp]
  0183a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_snprintf

; 1543 :                     WRMSG( HHC00933, "D", SSID_TO_LCSS(pDEVBLK->ssid), pDEVBLK->devnum, buf );

  01840	48 8b 84 24 e0
	01 00 00	 mov	 rax, QWORD PTR pDEVBLK$[rsp]
  01848	0f b7 40 48	 movzx	 eax, WORD PTR [rax+72]
  0184c	89 84 24 30 01
	00 00		 mov	 DWORD PTR tv932[rsp], eax
  01853	48 8b 8c 24 e0
	01 00 00	 mov	 rcx, QWORD PTR pDEVBLK$[rsp]
  0185b	0f b7 49 44	 movzx	 ecx, WORD PTR [rcx+68]
  0185f	d1 f9		 sar	 ecx, 1
  01861	89 8c 24 34 01
	00 00		 mov	 DWORD PTR tv936[rsp], ecx
  01868	b9 01 00 00 00	 mov	 ecx, 1
  0186d	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  01873	48 8d 8c 24 98
	01 00 00	 lea	 rcx, QWORD PTR buf$[rsp]
  0187b	48 89 4c 24 48	 mov	 QWORD PTR [rsp+72], rcx
  01880	8b 8c 24 30 01
	00 00		 mov	 ecx, DWORD PTR tv932[rsp]
  01887	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  0188b	8b 8c 24 34 01
	00 00		 mov	 ecx, DWORD PTR tv936[rsp]
  01892	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  01896	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170819
  0189d	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  018a2	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170820
  018a9	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  018ae	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  018b3	41 b9 03 00 00
	00		 mov	 r9d, 3
  018b9	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG170821
  018c0	ba 07 06 00 00	 mov	 edx, 1543		; 00000607H
  018c5	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170822
  018cc	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg
$LN145@LCS_Write:

; 1544 :                 }
; 1545 :                 LCS_DefaultCmdProc( pLCSDEV, pCmdFrame, iLength );

  018d2	0f b7 44 24 74	 movzx	 eax, WORD PTR iLength$[rsp]
  018d7	44 8b c0	 mov	 r8d, eax
  018da	48 8b 54 24 78	 mov	 rdx, QWORD PTR pCmdFrame$[rsp]
  018df	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR pLCSDEV$[rsp]
  018e7	e8 00 00 00 00	 call	 LCS_DefaultCmdProc
$LN42@LCS_Write:

; 1546 :                 break;
; 1547 : 
; 1548 :             } // end switch (LCS Command Frame cmd code)
; 1549 : 
; 1550 :             break; // end case LCS_FRMTYP_CMD

  018ec	e9 65 02 00 00	 jmp	 $LN10@LCS_Write
$LN146@LCS_Write:
$LN73@LCS_Write:

; 1551 : 
; 1552 :         default:
; 1553 :             PTT_DEBUG( "*WRIT Unsupp frame", pCmdFrame->bCmdCode, pDEVBLK->devnum, -1 );

  018f1	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_pttclass
  018f8	48 8b 00	 mov	 rax, QWORD PTR [rax]
  018fb	48 25 00 00 02
	00		 and	 rax, 131072		; 00020000H
  01901	48 85 c0	 test	 rax, rax
  01904	74 4b		 je	 SHORT $LN147@LCS_Write
  01906	48 8b 84 24 e0
	01 00 00	 mov	 rax, QWORD PTR pDEVBLK$[rsp]
  0190e	0f b7 40 48	 movzx	 eax, WORD PTR [rax+72]
  01912	48 8b 4c 24 78	 mov	 rcx, QWORD PTR pCmdFrame$[rsp]
  01917	0f b6 49 04	 movzx	 ecx, BYTE PTR [rcx+4]
  0191b	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR [rsp+48], 0
  01924	48 c7 44 24 28
	ff ff ff ff	 mov	 QWORD PTR [rsp+40], -1
  0192d	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG170825
  01934	48 89 54 24 20	 mov	 QWORD PTR [rsp+32], rdx
  01939	44 8b c8	 mov	 r9d, eax
  0193c	44 8b c1	 mov	 r8d, ecx
  0193f	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG170826
  01946	b9 00 00 02 00	 mov	 ecx, 131072		; 00020000H
  0194b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ptt_pthread_trace
$LN147@LCS_Write:
  01951	33 c0		 xor	 eax, eax
  01953	85 c0		 test	 eax, eax
  01955	75 9a		 jne	 SHORT $LN73@LCS_Write

; 1554 :             // "%1d:%04X CTC: lcs write: unsupported frame type 0x%2.2X"
; 1555 :             WRMSG( HHC00937, "E", SSID_TO_LCSS(pDEVBLK->ssid), pDEVBLK->devnum, pLCSHDR->bType );

  01957	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR pLCSHDR$[rsp]
  0195f	0f b6 40 02	 movzx	 eax, BYTE PTR [rax+2]
  01963	89 84 24 54 01
	00 00		 mov	 DWORD PTR tv968[rsp], eax
  0196a	48 8b 8c 24 e0
	01 00 00	 mov	 rcx, QWORD PTR pDEVBLK$[rsp]
  01972	0f b7 49 48	 movzx	 ecx, WORD PTR [rcx+72]
  01976	89 8c 24 3c 01
	00 00		 mov	 DWORD PTR tv971[rsp], ecx
  0197d	48 8b 94 24 e0
	01 00 00	 mov	 rdx, QWORD PTR pDEVBLK$[rsp]
  01985	0f b7 52 44	 movzx	 edx, WORD PTR [rdx+68]
  01989	d1 fa		 sar	 edx, 1
  0198b	89 94 24 40 01
	00 00		 mov	 DWORD PTR tv975[rsp], edx
  01992	b9 01 00 00 00	 mov	 ecx, 1
  01997	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  0199d	8b 8c 24 54 01
	00 00		 mov	 ecx, DWORD PTR tv968[rsp]
  019a4	89 4c 24 48	 mov	 DWORD PTR [rsp+72], ecx
  019a8	8b 8c 24 3c 01
	00 00		 mov	 ecx, DWORD PTR tv971[rsp]
  019af	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  019b3	8b 8c 24 40 01
	00 00		 mov	 ecx, DWORD PTR tv975[rsp]
  019ba	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  019be	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170827
  019c5	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  019ca	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170828
  019d1	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  019d6	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  019db	41 b9 03 00 00
	00		 mov	 r9d, 3
  019e1	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG170829
  019e8	ba 13 06 00 00	 mov	 edx, 1555		; 00000613H
  019ed	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170830
  019f4	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg
$LN76@LCS_Write:

; 1556 :             ASSERT( FALSE );

  019fa	33 c0		 xor	 eax, eax
  019fc	83 f8 01	 cmp	 eax, 1
  019ff	74 5c		 je	 SHORT $LN148@LCS_Write
$LN79@LCS_Write:
  01a01	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG170832
  01a08	41 b8 14 06 00
	00		 mov	 r8d, 1556		; 00000614H
  01a0e	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG170833
  01a15	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170834
  01a1c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_logmsg
  01a22	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_IsDebuggerPresent
  01a28	85 c0		 test	 eax, eax
  01a2a	74 20		 je	 SHORT $LN149@LCS_Write
  01a2c	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG170836
  01a33	41 b8 14 06 00
	00		 mov	 r8d, 1556		; 00000614H
  01a39	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG170837
  01a40	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170838
  01a47	e8 00 00 00 00	 call	 DebuggerTrace
$LN149@LCS_Write:
  01a4c	33 c0		 xor	 eax, eax
  01a4e	85 c0		 test	 eax, eax
  01a50	75 af		 jne	 SHORT $LN79@LCS_Write
  01a52	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_IsDebuggerPresent
  01a58	85 c0		 test	 eax, eax
  01a5a	74 01		 je	 SHORT $LN150@LCS_Write
  01a5c	cc		 int	 3
$LN150@LCS_Write:
$LN148@LCS_Write:
  01a5d	33 c0		 xor	 eax, eax
  01a5f	85 c0		 test	 eax, eax
  01a61	75 97		 jne	 SHORT $LN76@LCS_Write

; 1557 :             pDEVBLK->sense[0] = SENSE_EC;

  01a63	b8 01 00 00 00	 mov	 eax, 1
  01a68	48 6b c0 00	 imul	 rax, rax, 0
  01a6c	48 8b 8c 24 e0
	01 00 00	 mov	 rcx, QWORD PTR pDEVBLK$[rsp]
  01a74	c6 84 01 64 03
	00 00 10	 mov	 BYTE PTR [rcx+rax+868], 16

; 1558 :             *pUnitStat = CSW_CE | CSW_DE | CSW_UC;

  01a7c	48 8b 84 24 f8
	01 00 00	 mov	 rax, QWORD PTR pUnitStat$[rsp]
  01a84	c6 00 0e	 mov	 BYTE PTR [rax], 14

; 1559 :             LCS_EndMWrite( pDEVBLK, nEthBytes, nEthFrames );

  01a87	44 8b 84 24 94
	00 00 00	 mov	 r8d, DWORD PTR nEthFrames$[rsp]
  01a8f	8b 94 24 98 00
	00 00		 mov	 edx, DWORD PTR nEthBytes$[rsp]
  01a96	48 8b 8c 24 e0
	01 00 00	 mov	 rcx, QWORD PTR pDEVBLK$[rsp]
  01a9e	e8 00 00 00 00	 call	 LCS_EndMWrite
$LN82@LCS_Write:

; 1560 :             PTT_TIMING( "end write",  0, 0, 0 );

  01aa3	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_pttclass
  01aaa	48 8b 00	 mov	 rax, QWORD PTR [rax]
  01aad	48 25 00 00 01
	00		 and	 rax, 65536		; 00010000H
  01ab3	48 85 c0	 test	 rax, rax
  01ab6	74 36		 je	 SHORT $LN151@LCS_Write
  01ab8	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR [rsp+48], 0
  01ac1	48 c7 44 24 28
	00 00 00 00	 mov	 QWORD PTR [rsp+40], 0
  01aca	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG170841
  01ad1	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  01ad6	45 33 c9	 xor	 r9d, r9d
  01ad9	45 33 c0	 xor	 r8d, r8d
  01adc	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG170842
  01ae3	b9 00 00 01 00	 mov	 ecx, 65536		; 00010000H
  01ae8	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ptt_pthread_trace
$LN151@LCS_Write:
  01aee	33 c0		 xor	 eax, eax
  01af0	85 c0		 test	 eax, eax
  01af2	75 af		 jne	 SHORT $LN82@LCS_Write
$LN85@LCS_Write:

; 1561 :             PTT_DEBUG( "WRIT EXIT         ", 000, pDEVBLK->devnum, -1 );

  01af4	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_pttclass
  01afb	48 8b 00	 mov	 rax, QWORD PTR [rax]
  01afe	48 25 00 00 02
	00		 and	 rax, 131072		; 00020000H
  01b04	48 85 c0	 test	 rax, rax
  01b07	74 42		 je	 SHORT $LN152@LCS_Write
  01b09	48 8b 84 24 e0
	01 00 00	 mov	 rax, QWORD PTR pDEVBLK$[rsp]
  01b11	0f b7 40 48	 movzx	 eax, WORD PTR [rax+72]
  01b15	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR [rsp+48], 0
  01b1e	48 c7 44 24 28
	ff ff ff ff	 mov	 QWORD PTR [rsp+40], -1
  01b27	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170844
  01b2e	48 89 4c 24 20	 mov	 QWORD PTR [rsp+32], rcx
  01b33	44 8b c8	 mov	 r9d, eax
  01b36	45 33 c0	 xor	 r8d, r8d
  01b39	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG170845
  01b40	b9 00 00 02 00	 mov	 ecx, 131072		; 00020000H
  01b45	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ptt_pthread_trace
$LN152@LCS_Write:
  01b4b	33 c0		 xor	 eax, eax
  01b4d	85 c0		 test	 eax, eax
  01b4f	75 a3		 jne	 SHORT $LN85@LCS_Write

; 1562 :             return;

  01b51	e9 e8 00 00 00	 jmp	 $LN1@LCS_Write
$LN10@LCS_Write:

; 1563 : 
; 1564 :         } // end switch (LCS Frame type)
; 1565 : 
; 1566 :     } // end while (1) for IP

  01b56	e9 45 e8 ff ff	 jmp	 $LN8@LCS_Write
$LN9@LCS_Write:

; 1567 : 
; 1568 :     LCS_EndMWrite( pDEVBLK, nEthBytes, nEthFrames ); // (performance)

  01b5b	44 8b 84 24 94
	00 00 00	 mov	 r8d, DWORD PTR nEthFrames$[rsp]
  01b63	8b 94 24 98 00
	00 00		 mov	 edx, DWORD PTR nEthBytes$[rsp]
  01b6a	48 8b 8c 24 e0
	01 00 00	 mov	 rcx, QWORD PTR pDEVBLK$[rsp]
  01b72	e8 00 00 00 00	 call	 LCS_EndMWrite

; 1569 : 
; 1570 :     // ----------------------------------------------------------------
; 1571 :     //    End of LCS_Write
; 1572 :     // ----------------------------------------------------------------
; 1573 : 
; 1574 :     *pResidual = 0;

  01b77	48 8b 84 24 00
	02 00 00	 mov	 rax, QWORD PTR pResidual$[rsp]
  01b7f	c7 00 00 00 00
	00		 mov	 DWORD PTR [rax], 0

; 1575 :     *pUnitStat = CSW_CE | CSW_DE;

  01b85	48 8b 84 24 f8
	01 00 00	 mov	 rax, QWORD PTR pUnitStat$[rsp]
  01b8d	c6 00 0c	 mov	 BYTE PTR [rax], 12
$LN88@LCS_Write:

; 1576 : 
; 1577 :     PTT_TIMING( "end write",  0, 0, 0 );

  01b90	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_pttclass
  01b97	48 8b 00	 mov	 rax, QWORD PTR [rax]
  01b9a	48 25 00 00 01
	00		 and	 rax, 65536		; 00010000H
  01ba0	48 85 c0	 test	 rax, rax
  01ba3	74 36		 je	 SHORT $LN153@LCS_Write
  01ba5	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR [rsp+48], 0
  01bae	48 c7 44 24 28
	00 00 00 00	 mov	 QWORD PTR [rsp+40], 0
  01bb7	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG170847
  01bbe	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  01bc3	45 33 c9	 xor	 r9d, r9d
  01bc6	45 33 c0	 xor	 r8d, r8d
  01bc9	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG170848
  01bd0	b9 00 00 01 00	 mov	 ecx, 65536		; 00010000H
  01bd5	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ptt_pthread_trace
$LN153@LCS_Write:
  01bdb	33 c0		 xor	 eax, eax
  01bdd	85 c0		 test	 eax, eax
  01bdf	75 af		 jne	 SHORT $LN88@LCS_Write
$LN91@LCS_Write:

; 1578 :     PTT_DEBUG( "WRIT EXIT         ", 000, pDEVBLK->devnum, -1 );

  01be1	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_pttclass
  01be8	48 8b 00	 mov	 rax, QWORD PTR [rax]
  01beb	48 25 00 00 02
	00		 and	 rax, 131072		; 00020000H
  01bf1	48 85 c0	 test	 rax, rax
  01bf4	74 42		 je	 SHORT $LN154@LCS_Write
  01bf6	48 8b 84 24 e0
	01 00 00	 mov	 rax, QWORD PTR pDEVBLK$[rsp]
  01bfe	0f b7 40 48	 movzx	 eax, WORD PTR [rax+72]
  01c02	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR [rsp+48], 0
  01c0b	48 c7 44 24 28
	ff ff ff ff	 mov	 QWORD PTR [rsp+40], -1
  01c14	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170850
  01c1b	48 89 4c 24 20	 mov	 QWORD PTR [rsp+32], rcx
  01c20	44 8b c8	 mov	 r9d, eax
  01c23	45 33 c0	 xor	 r8d, r8d
  01c26	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG170851
  01c2d	b9 00 00 02 00	 mov	 ecx, 131072		; 00020000H
  01c32	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ptt_pthread_trace
$LN154@LCS_Write:
  01c38	33 c0		 xor	 eax, eax
  01c3a	85 c0		 test	 eax, eax
  01c3c	75 a3		 jne	 SHORT $LN91@LCS_Write
$LN1@LCS_Write:

; 1579 : }   // End of LCS_Write

  01c3e	48 8b 8c 24 b8
	01 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  01c46	48 33 cc	 xor	 rcx, rsp
  01c49	e8 00 00 00 00	 call	 __security_check_cookie
  01c4e	48 81 c4 c8 01
	00 00		 add	 rsp, 456		; 000001c8H
  01c55	5f		 pop	 rdi
  01c56	5e		 pop	 rsi
  01c57	c3		 ret	 0
$LN157@LCS_Write:
  01c58	00 00 00 00	 DD	 $LN125@LCS_Write
  01c5c	00 00 00 00	 DD	 $LN128@LCS_Write
  01c60	00 00 00 00	 DD	 $LN134@LCS_Write
  01c64	00 00 00 00	 DD	 $LN119@LCS_Write
  01c68	00 00 00 00	 DD	 $LN122@LCS_Write
  01c6c	00 00 00 00	 DD	 $LN131@LCS_Write
  01c70	00 00 00 00	 DD	 $LN137@LCS_Write
  01c74	00 00 00 00	 DD	 $LN140@LCS_Write
  01c78	00 00 00 00	 DD	 $LN143@LCS_Write
$LN156@LCS_Write:
  01c7c	00		 DB	 0
  01c7d	01		 DB	 1
  01c7e	08		 DB	 8
  01c7f	02		 DB	 2
  01c80	08		 DB	 8
  01c81	08		 DB	 8
  01c82	03		 DB	 3
  01c83	04		 DB	 4
  01c84	08		 DB	 8
  01c85	08		 DB	 8
  01c86	08		 DB	 8
  01c87	08		 DB	 8
  01c88	08		 DB	 8
  01c89	08		 DB	 8
  01c8a	08		 DB	 8
  01c8b	08		 DB	 8
  01c8c	08		 DB	 8
  01c8d	08		 DB	 8
  01c8e	08		 DB	 8
  01c8f	08		 DB	 8
  01c90	08		 DB	 8
  01c91	08		 DB	 8
  01c92	08		 DB	 8
  01c93	08		 DB	 8
  01c94	08		 DB	 8
  01c95	08		 DB	 8
  01c96	08		 DB	 8
  01c97	08		 DB	 8
  01c98	08		 DB	 8
  01c99	08		 DB	 8
  01c9a	08		 DB	 8
  01c9b	08		 DB	 8
  01c9c	08		 DB	 8
  01c9d	08		 DB	 8
  01c9e	08		 DB	 8
  01c9f	08		 DB	 8
  01ca0	08		 DB	 8
  01ca1	08		 DB	 8
  01ca2	08		 DB	 8
  01ca3	08		 DB	 8
  01ca4	08		 DB	 8
  01ca5	08		 DB	 8
  01ca6	08		 DB	 8
  01ca7	08		 DB	 8
  01ca8	08		 DB	 8
  01ca9	08		 DB	 8
  01caa	08		 DB	 8
  01cab	08		 DB	 8
  01cac	08		 DB	 8
  01cad	08		 DB	 8
  01cae	08		 DB	 8
  01caf	08		 DB	 8
  01cb0	08		 DB	 8
  01cb1	08		 DB	 8
  01cb2	08		 DB	 8
  01cb3	08		 DB	 8
  01cb4	08		 DB	 8
  01cb5	08		 DB	 8
  01cb6	08		 DB	 8
  01cb7	08		 DB	 8
  01cb8	08		 DB	 8
  01cb9	08		 DB	 8
  01cba	08		 DB	 8
  01cbb	08		 DB	 8
  01cbc	08		 DB	 8
  01cbd	08		 DB	 8
  01cbe	08		 DB	 8
  01cbf	08		 DB	 8
  01cc0	08		 DB	 8
  01cc1	08		 DB	 8
  01cc2	08		 DB	 8
  01cc3	08		 DB	 8
  01cc4	08		 DB	 8
  01cc5	08		 DB	 8
  01cc6	08		 DB	 8
  01cc7	08		 DB	 8
  01cc8	08		 DB	 8
  01cc9	08		 DB	 8
  01cca	08		 DB	 8
  01ccb	08		 DB	 8
  01ccc	08		 DB	 8
  01ccd	08		 DB	 8
  01cce	08		 DB	 8
  01ccf	08		 DB	 8
  01cd0	08		 DB	 8
  01cd1	08		 DB	 8
  01cd2	08		 DB	 8
  01cd3	08		 DB	 8
  01cd4	08		 DB	 8
  01cd5	08		 DB	 8
  01cd6	08		 DB	 8
  01cd7	08		 DB	 8
  01cd8	08		 DB	 8
  01cd9	08		 DB	 8
  01cda	08		 DB	 8
  01cdb	08		 DB	 8
  01cdc	08		 DB	 8
  01cdd	08		 DB	 8
  01cde	08		 DB	 8
  01cdf	08		 DB	 8
  01ce0	08		 DB	 8
  01ce1	08		 DB	 8
  01ce2	08		 DB	 8
  01ce3	08		 DB	 8
  01ce4	08		 DB	 8
  01ce5	08		 DB	 8
  01ce6	08		 DB	 8
  01ce7	08		 DB	 8
  01ce8	08		 DB	 8
  01ce9	08		 DB	 8
  01cea	08		 DB	 8
  01ceb	08		 DB	 8
  01cec	08		 DB	 8
  01ced	08		 DB	 8
  01cee	08		 DB	 8
  01cef	08		 DB	 8
  01cf0	08		 DB	 8
  01cf1	08		 DB	 8
  01cf2	08		 DB	 8
  01cf3	08		 DB	 8
  01cf4	08		 DB	 8
  01cf5	08		 DB	 8
  01cf6	08		 DB	 8
  01cf7	08		 DB	 8
  01cf8	08		 DB	 8
  01cf9	08		 DB	 8
  01cfa	08		 DB	 8
  01cfb	08		 DB	 8
  01cfc	08		 DB	 8
  01cfd	08		 DB	 8
  01cfe	08		 DB	 8
  01cff	08		 DB	 8
  01d00	08		 DB	 8
  01d01	08		 DB	 8
  01d02	08		 DB	 8
  01d03	08		 DB	 8
  01d04	08		 DB	 8
  01d05	08		 DB	 8
  01d06	08		 DB	 8
  01d07	08		 DB	 8
  01d08	08		 DB	 8
  01d09	08		 DB	 8
  01d0a	08		 DB	 8
  01d0b	08		 DB	 8
  01d0c	08		 DB	 8
  01d0d	08		 DB	 8
  01d0e	08		 DB	 8
  01d0f	08		 DB	 8
  01d10	08		 DB	 8
  01d11	08		 DB	 8
  01d12	08		 DB	 8
  01d13	08		 DB	 8
  01d14	08		 DB	 8
  01d15	08		 DB	 8
  01d16	08		 DB	 8
  01d17	08		 DB	 8
  01d18	08		 DB	 8
  01d19	08		 DB	 8
  01d1a	08		 DB	 8
  01d1b	08		 DB	 8
  01d1c	08		 DB	 8
  01d1d	08		 DB	 8
  01d1e	08		 DB	 8
  01d1f	08		 DB	 8
  01d20	08		 DB	 8
  01d21	08		 DB	 8
  01d22	08		 DB	 8
  01d23	08		 DB	 8
  01d24	08		 DB	 8
  01d25	08		 DB	 8
  01d26	08		 DB	 8
  01d27	08		 DB	 8
  01d28	08		 DB	 8
  01d29	08		 DB	 8
  01d2a	08		 DB	 8
  01d2b	08		 DB	 8
  01d2c	08		 DB	 8
  01d2d	05		 DB	 5
  01d2e	08		 DB	 8
  01d2f	06		 DB	 6
  01d30	07		 DB	 7
LCS_Write ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\ctc_lcs.c
_TEXT	SEGMENT
pLCSDEV$ = 96
iTraceLen$ = 104
iLength$ = 112
tv259 = 120
tv263 = 124
tv324 = 128
tv328 = 132
tv387 = 136
tv391 = 140
now$ = 144
pLCSHdr$ = 152
tv348 = 160
waittime$ = 168
__$ArrayPad$ = 184
pDEVBLK$ = 224
sCount$ = 232
pIOBuf$ = 240
pUnitStat$ = 248
pResidual$ = 256
pMore$ = 264
LCS_Read PROC

; 2933 : {

  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  0000e	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00013	56		 push	 rsi
  00014	57		 push	 rdi
  00015	48 81 ec c8 00
	00 00		 sub	 rsp, 200		; 000000c8H
  0001c	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00023	48 33 c4	 xor	 rax, rsp
  00026	48 89 84 24 b8
	00 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 2934 :     PLCSHDR     pLCSHdr;
; 2935 :     PLCSDEV     pLCSDEV = (PLCSDEV)pDEVBLK->dev_data;

  0002e	48 8b 84 24 e0
	00 00 00	 mov	 rax, QWORD PTR pDEVBLK$[rsp]
  00036	48 8b 80 08 06
	00 00		 mov	 rax, QWORD PTR [rax+1544]
  0003d	48 89 44 24 60	 mov	 QWORD PTR pLCSDEV$[rsp], rax

; 2936 :     size_t      iLength = 0;

  00042	48 c7 44 24 70
	00 00 00 00	 mov	 QWORD PTR iLength$[rsp], 0
$LN4@LCS_Read:

; 2937 :     int         iTraceLen;
; 2938 : 
; 2939 :     struct timespec  waittime;
; 2940 :     struct timeval   now;
; 2941 : 
; 2942 :     // FIXME: we currently don't support data-chaining but
; 2943 :     // probably should if real LCS devices do (I was unable
; 2944 :     // to determine whether they do or not). -- Fish
; 2945 : 
; 2946 :     PTT_DEBUG( "READ: ENTRY       ", 000, pDEVBLK->devnum, -1 );

  0004b	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_pttclass
  00052	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00055	48 25 00 00 02
	00		 and	 rax, 131072		; 00020000H
  0005b	48 85 c0	 test	 rax, rax
  0005e	74 42		 je	 SHORT $LN44@LCS_Read
  00060	48 8b 84 24 e0
	00 00 00	 mov	 rax, QWORD PTR pDEVBLK$[rsp]
  00068	0f b7 40 48	 movzx	 eax, WORD PTR [rax+72]
  0006c	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR [rsp+48], 0
  00075	48 c7 44 24 28
	ff ff ff ff	 mov	 QWORD PTR [rsp+40], -1
  0007e	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG172500
  00085	48 89 4c 24 20	 mov	 QWORD PTR [rsp+32], rcx
  0008a	44 8b c8	 mov	 r9d, eax
  0008d	45 33 c0	 xor	 r8d, r8d
  00090	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG172501
  00097	b9 00 00 02 00	 mov	 ecx, 131072		; 00020000H
  0009c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ptt_pthread_trace
$LN44@LCS_Read:
  000a2	33 c0		 xor	 eax, eax
  000a4	85 c0		 test	 eax, eax
  000a6	75 a3		 jne	 SHORT $LN4@LCS_Read
$LN5@LCS_Read:
$LN10@LCS_Read:

; 2947 : 
; 2948 :     for (;;)
; 2949 :     {
; 2950 :         // Has anything arrived in our frame buffer yet?
; 2951 : 
; 2952 :         PTT_DEBUG(       "GET  DevDataLock  ", 000, pDEVBLK->devnum, -1 );

  000a8	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_pttclass
  000af	48 8b 00	 mov	 rax, QWORD PTR [rax]
  000b2	48 25 00 00 02
	00		 and	 rax, 131072		; 00020000H
  000b8	48 85 c0	 test	 rax, rax
  000bb	74 42		 je	 SHORT $LN45@LCS_Read
  000bd	48 8b 84 24 e0
	00 00 00	 mov	 rax, QWORD PTR pDEVBLK$[rsp]
  000c5	0f b7 40 48	 movzx	 eax, WORD PTR [rax+72]
  000c9	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR [rsp+48], 0
  000d2	48 c7 44 24 28
	ff ff ff ff	 mov	 QWORD PTR [rsp+40], -1
  000db	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG172503
  000e2	48 89 4c 24 20	 mov	 QWORD PTR [rsp+32], rcx
  000e7	44 8b c8	 mov	 r9d, eax
  000ea	45 33 c0	 xor	 r8d, r8d
  000ed	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG172504
  000f4	b9 00 00 02 00	 mov	 ecx, 131072		; 00020000H
  000f9	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ptt_pthread_trace
$LN45@LCS_Read:
  000ff	33 c0		 xor	 eax, eax
  00101	85 c0		 test	 eax, eax
  00103	75 a3		 jne	 SHORT $LN10@LCS_Read

; 2953 :         obtain_lock( &pLCSDEV->DevDataLock );

  00105	48 8b 44 24 60	 mov	 rax, QWORD PTR pLCSDEV$[rsp]
  0010a	48 05 9a 00 00
	00		 add	 rax, 154		; 0000009aH
  00110	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG172505
  00117	48 8b c8	 mov	 rcx, rax
  0011a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_obtain_lock
$LN13@LCS_Read:

; 2954 :         PTT_DEBUG(       "GOT  DevDataLock  ", 000, pDEVBLK->devnum, -1 );

  00120	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_pttclass
  00127	48 8b 00	 mov	 rax, QWORD PTR [rax]
  0012a	48 25 00 00 02
	00		 and	 rax, 131072		; 00020000H
  00130	48 85 c0	 test	 rax, rax
  00133	74 42		 je	 SHORT $LN46@LCS_Read
  00135	48 8b 84 24 e0
	00 00 00	 mov	 rax, QWORD PTR pDEVBLK$[rsp]
  0013d	0f b7 40 48	 movzx	 eax, WORD PTR [rax+72]
  00141	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR [rsp+48], 0
  0014a	48 c7 44 24 28
	ff ff ff ff	 mov	 QWORD PTR [rsp+40], -1
  00153	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG172507
  0015a	48 89 4c 24 20	 mov	 QWORD PTR [rsp+32], rcx
  0015f	44 8b c8	 mov	 r9d, eax
  00162	45 33 c0	 xor	 r8d, r8d
  00165	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG172508
  0016c	b9 00 00 02 00	 mov	 ecx, 131072		; 00020000H
  00171	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ptt_pthread_trace
$LN46@LCS_Read:
  00177	33 c0		 xor	 eax, eax
  00179	85 c0		 test	 eax, eax
  0017b	75 a3		 jne	 SHORT $LN13@LCS_Read

; 2955 :         {
; 2956 :             if (pLCSDEV->fDataPending || pLCSDEV->fReplyPending)

  0017d	48 8b 44 24 60	 mov	 rax, QWORD PTR pLCSDEV$[rsp]
  00182	8b 40 41	 mov	 eax, DWORD PTR [rax+65]
  00185	c1 e8 04	 shr	 eax, 4
  00188	83 e0 01	 and	 eax, 1
  0018b	85 c0		 test	 eax, eax
  0018d	75 12		 jne	 SHORT $LN48@LCS_Read
  0018f	48 8b 44 24 60	 mov	 rax, QWORD PTR pLCSDEV$[rsp]
  00194	8b 40 41	 mov	 eax, DWORD PTR [rax+65]
  00197	c1 e8 03	 shr	 eax, 3
  0019a	83 e0 01	 and	 eax, 1
  0019d	85 c0		 test	 eax, eax
  0019f	74 05		 je	 SHORT $LN47@LCS_Read
$LN48@LCS_Read:

; 2957 :                 break;

  001a1	e9 30 04 00 00	 jmp	 $LN6@LCS_Read
$LN47@LCS_Read:
$LN16@LCS_Read:

; 2958 :         }
; 2959 :         PTT_DEBUG(        "REL  DevDataLock  ", 000, pDEVBLK->devnum, -1 );

  001a6	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_pttclass
  001ad	48 8b 00	 mov	 rax, QWORD PTR [rax]
  001b0	48 25 00 00 02
	00		 and	 rax, 131072		; 00020000H
  001b6	48 85 c0	 test	 rax, rax
  001b9	74 42		 je	 SHORT $LN49@LCS_Read
  001bb	48 8b 84 24 e0
	00 00 00	 mov	 rax, QWORD PTR pDEVBLK$[rsp]
  001c3	0f b7 40 48	 movzx	 eax, WORD PTR [rax+72]
  001c7	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR [rsp+48], 0
  001d0	48 c7 44 24 28
	ff ff ff ff	 mov	 QWORD PTR [rsp+40], -1
  001d9	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG172512
  001e0	48 89 4c 24 20	 mov	 QWORD PTR [rsp+32], rcx
  001e5	44 8b c8	 mov	 r9d, eax
  001e8	45 33 c0	 xor	 r8d, r8d
  001eb	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG172513
  001f2	b9 00 00 02 00	 mov	 ecx, 131072		; 00020000H
  001f7	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ptt_pthread_trace
$LN49@LCS_Read:
  001fd	33 c0		 xor	 eax, eax
  001ff	85 c0		 test	 eax, eax
  00201	75 a3		 jne	 SHORT $LN16@LCS_Read

; 2960 :         release_lock( &pLCSDEV->DevDataLock );

  00203	48 8b 44 24 60	 mov	 rax, QWORD PTR pLCSDEV$[rsp]
  00208	48 05 9a 00 00
	00		 add	 rax, 154		; 0000009aH
  0020e	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG172514
  00215	48 8b c8	 mov	 rcx, rax
  00218	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_release_lock

; 2961 : 
; 2962 :         // Keep waiting for LCS Frames to arrive in our frame buffer...
; 2963 : 
; 2964 :         gettimeofday( &now, NULL );

  0021e	33 d2		 xor	 edx, edx
  00220	48 8d 8c 24 90
	00 00 00	 lea	 rcx, QWORD PTR now$[rsp]
  00228	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_gettimeofday

; 2965 : 
; 2966 :         waittime.tv_sec  = now.tv_sec  + DEF_NET_READ_TIMEOUT_SECS;

  0022e	8b 84 24 90 00
	00 00		 mov	 eax, DWORD PTR now$[rsp]
  00235	83 c0 05	 add	 eax, 5
  00238	48 98		 cdqe
  0023a	48 89 84 24 a8
	00 00 00	 mov	 QWORD PTR waittime$[rsp], rax

; 2967 :         waittime.tv_nsec = now.tv_usec * 1000;

  00242	69 84 24 94 00
	00 00 e8 03 00
	00		 imul	 eax, DWORD PTR now$[rsp+4], 1000 ; 000003e8H
  0024d	89 84 24 b0 00
	00 00		 mov	 DWORD PTR waittime$[rsp+8], eax
$LN19@LCS_Read:

; 2968 : 
; 2969 :         PTT_DEBUG(       "GET  DevEventLock ", 000, pDEVBLK->devnum, -1 );

  00254	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_pttclass
  0025b	48 8b 00	 mov	 rax, QWORD PTR [rax]
  0025e	48 25 00 00 02
	00		 and	 rax, 131072		; 00020000H
  00264	48 85 c0	 test	 rax, rax
  00267	74 42		 je	 SHORT $LN50@LCS_Read
  00269	48 8b 84 24 e0
	00 00 00	 mov	 rax, QWORD PTR pDEVBLK$[rsp]
  00271	0f b7 40 48	 movzx	 eax, WORD PTR [rax+72]
  00275	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR [rsp+48], 0
  0027e	48 c7 44 24 28
	ff ff ff ff	 mov	 QWORD PTR [rsp+40], -1
  00287	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG172516
  0028e	48 89 4c 24 20	 mov	 QWORD PTR [rsp+32], rcx
  00293	44 8b c8	 mov	 r9d, eax
  00296	45 33 c0	 xor	 r8d, r8d
  00299	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG172517
  002a0	b9 00 00 02 00	 mov	 ecx, 131072		; 00020000H
  002a5	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ptt_pthread_trace
$LN50@LCS_Read:
  002ab	33 c0		 xor	 eax, eax
  002ad	85 c0		 test	 eax, eax
  002af	75 a3		 jne	 SHORT $LN19@LCS_Read

; 2970 :         obtain_lock( &pLCSDEV->DevEventLock );

  002b1	48 8b 44 24 60	 mov	 rax, QWORD PTR pLCSDEV$[rsp]
  002b6	48 83 c0 31	 add	 rax, 49			; 00000031H
  002ba	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG172518
  002c1	48 8b c8	 mov	 rcx, rax
  002c4	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_obtain_lock
$LN22@LCS_Read:

; 2971 :         PTT_DEBUG(       "GOT  DevEventLock ", 000, pDEVBLK->devnum, -1 );

  002ca	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_pttclass
  002d1	48 8b 00	 mov	 rax, QWORD PTR [rax]
  002d4	48 25 00 00 02
	00		 and	 rax, 131072		; 00020000H
  002da	48 85 c0	 test	 rax, rax
  002dd	74 42		 je	 SHORT $LN51@LCS_Read
  002df	48 8b 84 24 e0
	00 00 00	 mov	 rax, QWORD PTR pDEVBLK$[rsp]
  002e7	0f b7 40 48	 movzx	 eax, WORD PTR [rax+72]
  002eb	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR [rsp+48], 0
  002f4	48 c7 44 24 28
	ff ff ff ff	 mov	 QWORD PTR [rsp+40], -1
  002fd	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG172520
  00304	48 89 4c 24 20	 mov	 QWORD PTR [rsp+32], rcx
  00309	44 8b c8	 mov	 r9d, eax
  0030c	45 33 c0	 xor	 r8d, r8d
  0030f	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG172521
  00316	b9 00 00 02 00	 mov	 ecx, 131072		; 00020000H
  0031b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ptt_pthread_trace
$LN51@LCS_Read:
  00321	33 c0		 xor	 eax, eax
  00323	85 c0		 test	 eax, eax
  00325	75 a3		 jne	 SHORT $LN22@LCS_Read
$LN25@LCS_Read:

; 2972 :         {
; 2973 :             PTT_DEBUG( "WAIT DevEventLock ", 000, pDEVBLK->devnum, -1 );

  00327	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_pttclass
  0032e	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00331	48 25 00 00 02
	00		 and	 rax, 131072		; 00020000H
  00337	48 85 c0	 test	 rax, rax
  0033a	74 42		 je	 SHORT $LN52@LCS_Read
  0033c	48 8b 84 24 e0
	00 00 00	 mov	 rax, QWORD PTR pDEVBLK$[rsp]
  00344	0f b7 40 48	 movzx	 eax, WORD PTR [rax+72]
  00348	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR [rsp+48], 0
  00351	48 c7 44 24 28
	ff ff ff ff	 mov	 QWORD PTR [rsp+40], -1
  0035a	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG172523
  00361	48 89 4c 24 20	 mov	 QWORD PTR [rsp+32], rcx
  00366	44 8b c8	 mov	 r9d, eax
  00369	45 33 c0	 xor	 r8d, r8d
  0036c	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG172524
  00373	b9 00 00 02 00	 mov	 ecx, 131072		; 00020000H
  00378	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ptt_pthread_trace
$LN52@LCS_Read:
  0037e	33 c0		 xor	 eax, eax
  00380	85 c0		 test	 eax, eax
  00382	75 a3		 jne	 SHORT $LN25@LCS_Read

; 2974 :             pLCSDEV->fReadWaiting = 1;

  00384	48 8b 44 24 60	 mov	 rax, QWORD PTR pLCSDEV$[rsp]
  00389	8b 40 41	 mov	 eax, DWORD PTR [rax+65]
  0038c	83 c8 20	 or	 eax, 32			; 00000020H
  0038f	48 8b 4c 24 60	 mov	 rcx, QWORD PTR pLCSDEV$[rsp]
  00394	89 41 41	 mov	 DWORD PTR [rcx+65], eax

; 2975 :             timed_wait_condition( &pLCSDEV->DevEvent,

  00397	48 8b 44 24 60	 mov	 rax, QWORD PTR pLCSDEV$[rsp]
  0039c	48 83 c0 31	 add	 rax, 49			; 00000031H
  003a0	48 8b 4c 24 60	 mov	 rcx, QWORD PTR pLCSDEV$[rsp]
  003a5	48 83 c1 39	 add	 rcx, 57			; 00000039H
  003a9	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG172525
  003b0	4c 8d 84 24 a8
	00 00 00	 lea	 r8, QWORD PTR waittime$[rsp]
  003b8	48 8b d0	 mov	 rdx, rax
  003bb	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_timed_wait_condition

; 2976 :                                   &pLCSDEV->DevEventLock,
; 2977 :                                   &waittime );
; 2978 :             pLCSDEV->fReadWaiting = 0;

  003c1	48 8b 44 24 60	 mov	 rax, QWORD PTR pLCSDEV$[rsp]
  003c6	8b 40 41	 mov	 eax, DWORD PTR [rax+65]
  003c9	83 e0 df	 and	 eax, -33		; ffffffdfH
  003cc	48 8b 4c 24 60	 mov	 rcx, QWORD PTR pLCSDEV$[rsp]
  003d1	89 41 41	 mov	 DWORD PTR [rcx+65], eax
$LN28@LCS_Read:

; 2979 :         }
; 2980 : 
; 2981 :         PTT_DEBUG(        "WOKE DevEventLock ", 000, pDEVBLK->devnum, -1 );

  003d4	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_pttclass
  003db	48 8b 00	 mov	 rax, QWORD PTR [rax]
  003de	48 25 00 00 02
	00		 and	 rax, 131072		; 00020000H
  003e4	48 85 c0	 test	 rax, rax
  003e7	74 42		 je	 SHORT $LN53@LCS_Read
  003e9	48 8b 84 24 e0
	00 00 00	 mov	 rax, QWORD PTR pDEVBLK$[rsp]
  003f1	0f b7 40 48	 movzx	 eax, WORD PTR [rax+72]
  003f5	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR [rsp+48], 0
  003fe	48 c7 44 24 28
	ff ff ff ff	 mov	 QWORD PTR [rsp+40], -1
  00407	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG172527
  0040e	48 89 4c 24 20	 mov	 QWORD PTR [rsp+32], rcx
  00413	44 8b c8	 mov	 r9d, eax
  00416	45 33 c0	 xor	 r8d, r8d
  00419	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG172528
  00420	b9 00 00 02 00	 mov	 ecx, 131072		; 00020000H
  00425	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ptt_pthread_trace
$LN53@LCS_Read:
  0042b	33 c0		 xor	 eax, eax
  0042d	85 c0		 test	 eax, eax
  0042f	75 a3		 jne	 SHORT $LN28@LCS_Read

; 2982 : 
; 2983 :         // Check for channel conditions...
; 2984 : 
; 2985 :         if (pLCSDEV->fHaltOrClear)

  00431	48 8b 44 24 60	 mov	 rax, QWORD PTR pLCSDEV$[rsp]
  00436	8b 40 41	 mov	 eax, DWORD PTR [rax+65]
  00439	c1 e8 06	 shr	 eax, 6
  0043c	83 e0 01	 and	 eax, 1
  0043f	85 c0		 test	 eax, eax
  00441	0f 84 71 01 00
	00		 je	 $LN54@LCS_Read

; 2986 :         {
; 2987 :             *pUnitStat = 0;

  00447	48 8b 84 24 f8
	00 00 00	 mov	 rax, QWORD PTR pUnitStat$[rsp]
  0044f	c6 00 00	 mov	 BYTE PTR [rax], 0

; 2988 :             *pResidual = sCount;

  00452	48 8b 84 24 00
	01 00 00	 mov	 rax, QWORD PTR pResidual$[rsp]
  0045a	8b 8c 24 e8 00
	00 00		 mov	 ecx, DWORD PTR sCount$[rsp]
  00461	89 08		 mov	 DWORD PTR [rax], ecx

; 2989 :             pLCSDEV->fHaltOrClear=0;

  00463	48 8b 44 24 60	 mov	 rax, QWORD PTR pLCSDEV$[rsp]
  00468	8b 40 41	 mov	 eax, DWORD PTR [rax+65]
  0046b	83 e0 bf	 and	 eax, -65		; ffffffbfH
  0046e	48 8b 4c 24 60	 mov	 rcx, QWORD PTR pLCSDEV$[rsp]
  00473	89 41 41	 mov	 DWORD PTR [rcx+65], eax
$LN31@LCS_Read:

; 2990 : 
; 2991 :             PTT_DEBUG(    "*HALT or CLEAR*   ", *pUnitStat, pDEVBLK->devnum, sCount );

  00476	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_pttclass
  0047d	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00480	48 25 00 00 02
	00		 and	 rax, 131072		; 00020000H
  00486	48 85 c0	 test	 rax, rax
  00489	74 50		 je	 SHORT $LN55@LCS_Read
  0048b	8b 84 24 e8 00
	00 00		 mov	 eax, DWORD PTR sCount$[rsp]
  00492	48 8b 8c 24 e0
	00 00 00	 mov	 rcx, QWORD PTR pDEVBLK$[rsp]
  0049a	0f b7 49 48	 movzx	 ecx, WORD PTR [rcx+72]
  0049e	48 8b 94 24 f8
	00 00 00	 mov	 rdx, QWORD PTR pUnitStat$[rsp]
  004a6	0f b6 12	 movzx	 edx, BYTE PTR [rdx]
  004a9	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR [rsp+48], 0
  004b2	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  004b7	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG172531
  004be	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  004c3	44 8b c9	 mov	 r9d, ecx
  004c6	44 8b c2	 mov	 r8d, edx
  004c9	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG172532
  004d0	b9 00 00 02 00	 mov	 ecx, 131072		; 00020000H
  004d5	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ptt_pthread_trace
$LN55@LCS_Read:
  004db	33 c0		 xor	 eax, eax
  004dd	85 c0		 test	 eax, eax
  004df	75 95		 jne	 SHORT $LN31@LCS_Read

; 2992 : 
; 2993 :             if (pDEVBLK->ccwtrace || pLCSDEV->pLCSBLK->fDebug)

  004e1	48 8b 84 24 e0
	00 00 00	 mov	 rax, QWORD PTR pDEVBLK$[rsp]
  004e9	8b 80 f8 05 00
	00		 mov	 eax, DWORD PTR [rax+1528]
  004ef	c1 e8 0f	 shr	 eax, 15
  004f2	83 e0 01	 and	 eax, 1
  004f5	85 c0		 test	 eax, eax
  004f7	75 17		 jne	 SHORT $LN57@LCS_Read
  004f9	48 8b 44 24 60	 mov	 rax, QWORD PTR pLCSDEV$[rsp]
  004fe	48 8b 40 08	 mov	 rax, QWORD PTR [rax+8]
  00502	8b 40 18	 mov	 eax, DWORD PTR [rax+24]
  00505	83 e0 01	 and	 eax, 1
  00508	85 c0		 test	 eax, eax
  0050a	0f 84 8a 00 00
	00		 je	 $LN56@LCS_Read
$LN57@LCS_Read:

; 2994 :                 // "%1d:%04X %s: halt or clear recognized"
; 2995 :                 WRMSG( HHC00904, "I", SSID_TO_LCSS(pDEVBLK->ssid), pDEVBLK->devnum, pDEVBLK->typname );

  00510	48 8b 84 24 e0
	00 00 00	 mov	 rax, QWORD PTR pDEVBLK$[rsp]
  00518	0f b7 40 48	 movzx	 eax, WORD PTR [rax+72]
  0051c	89 44 24 78	 mov	 DWORD PTR tv259[rsp], eax
  00520	48 8b 8c 24 e0
	00 00 00	 mov	 rcx, QWORD PTR pDEVBLK$[rsp]
  00528	0f b7 49 44	 movzx	 ecx, WORD PTR [rcx+68]
  0052c	d1 f9		 sar	 ecx, 1
  0052e	89 4c 24 7c	 mov	 DWORD PTR tv263[rsp], ecx
  00532	b9 01 00 00 00	 mov	 ecx, 1
  00537	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  0053d	48 8b 8c 24 e0
	00 00 00	 mov	 rcx, QWORD PTR pDEVBLK$[rsp]
  00545	48 8b 49 50	 mov	 rcx, QWORD PTR [rcx+80]
  00549	48 89 4c 24 48	 mov	 QWORD PTR [rsp+72], rcx
  0054e	8b 4c 24 78	 mov	 ecx, DWORD PTR tv259[rsp]
  00552	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  00556	8b 4c 24 7c	 mov	 ecx, DWORD PTR tv263[rsp]
  0055a	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  0055e	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG172535
  00565	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  0056a	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG172536
  00571	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00576	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  0057b	41 b9 03 00 00
	00		 mov	 r9d, 3
  00581	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG172537
  00588	ba b3 0b 00 00	 mov	 edx, 2995		; 00000bb3H
  0058d	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG172538
  00594	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg
$LN56@LCS_Read:

; 2996 :             release_lock( &pLCSDEV->DevEventLock );

  0059a	48 8b 44 24 60	 mov	 rax, QWORD PTR pLCSDEV$[rsp]
  0059f	48 83 c0 31	 add	 rax, 49			; 00000031H
  005a3	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG172539
  005aa	48 8b c8	 mov	 rcx, rax
  005ad	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_release_lock

; 2997 :             return;

  005b3	e9 9d 04 00 00	 jmp	 $LN1@LCS_Read
$LN54@LCS_Read:

; 2998 :         }
; 2999 :         release_lock( &pLCSDEV->DevEventLock );

  005b8	48 8b 44 24 60	 mov	 rax, QWORD PTR pLCSDEV$[rsp]
  005bd	48 83 c0 31	 add	 rax, 49			; 00000031H
  005c1	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG172540
  005c8	48 8b c8	 mov	 rcx, rax
  005cb	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_release_lock

; 3000 : 
; 3001 :     } // end for (;;)

  005d1	e9 d2 fa ff ff	 jmp	 $LN5@LCS_Read
$LN6@LCS_Read:
$LN34@LCS_Read:

; 3002 : 
; 3003 :     // We have frame buffer data to return to the guest...
; 3004 :     // (i.e. Ethernet packets or cmd reply frames)
; 3005 : 
; 3006 :     PTT_DEBUG( "READ using buffer ", 000, pDEVBLK->devnum, -1 );

  005d6	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_pttclass
  005dd	48 8b 00	 mov	 rax, QWORD PTR [rax]
  005e0	48 25 00 00 02
	00		 and	 rax, 131072		; 00020000H
  005e6	48 85 c0	 test	 rax, rax
  005e9	74 42		 je	 SHORT $LN58@LCS_Read
  005eb	48 8b 84 24 e0
	00 00 00	 mov	 rax, QWORD PTR pDEVBLK$[rsp]
  005f3	0f b7 40 48	 movzx	 eax, WORD PTR [rax+72]
  005f7	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR [rsp+48], 0
  00600	48 c7 44 24 28
	ff ff ff ff	 mov	 QWORD PTR [rsp+40], -1
  00609	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG172542
  00610	48 89 4c 24 20	 mov	 QWORD PTR [rsp+32], rcx
  00615	44 8b c8	 mov	 r9d, eax
  00618	45 33 c0	 xor	 r8d, r8d
  0061b	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG172543
  00622	b9 00 00 02 00	 mov	 ecx, 131072		; 00020000H
  00627	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ptt_pthread_trace
$LN58@LCS_Read:
  0062d	33 c0		 xor	 eax, eax
  0062f	85 c0		 test	 eax, eax
  00631	75 a3		 jne	 SHORT $LN34@LCS_Read

; 3007 : 
; 3008 :     // Point to the end of all buffered LCS Frames...
; 3009 :     // (where the next Frame *would* go if there was one)
; 3010 : 
; 3011 :     pLCSHdr = (PLCSHDR)( pLCSDEV->bFrameBuffer +

  00633	48 8b 44 24 60	 mov	 rax, QWORD PTR pLCSDEV$[rsp]
  00638	0f b7 80 a2 00
	00 00		 movzx	 eax, WORD PTR [rax+162]
  0063f	48 8b 4c 24 60	 mov	 rcx, QWORD PTR pLCSDEV$[rsp]
  00644	48 8d 84 01 a6
	00 00 00	 lea	 rax, QWORD PTR [rcx+rax+166]
  0064c	48 89 84 24 98
	00 00 00	 mov	 QWORD PTR pLCSHdr$[rsp], rax

; 3012 :                          pLCSDEV->iFrameOffset );
; 3013 : 
; 3014 :     // Mark the end of this batch of LCS Frames by setting
; 3015 :     // the "offset to NEXT frame" LCS Header field to zero.
; 3016 :     // (a zero "next Frame offset" is like an "EOF" flag)
; 3017 : 
; 3018 :     STORE_HW( pLCSHdr->hwOffset, 0x0000 );

  00654	33 c9		 xor	 ecx, ecx
  00656	e8 00 00 00 00	 call	 _byteswap_ushort
  0065b	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR pLCSHdr$[rsp]
  00663	0f b7 d0	 movzx	 edx, ax
  00666	e8 00 00 00 00	 call	 store_hw_noswap

; 3019 : 
; 3020 :     // Calculate how much data we're going to be giving them.
; 3021 : 
; 3022 :     // Since 'iFrameOffset' points to the next available LCS
; 3023 :     // Frame slot in our buffer, the total amount of LCS Frame
; 3024 :     // data we have is exactly that amount. We give them two
; 3025 :     // extra bytes however so that they can optionally chase
; 3026 :     // the "hwOffset" field in each LCS Frame's LCS Header to
; 3027 :     // eventually reach our zero hwOffset "EOF" flag).
; 3028 : 
; 3029 :     iLength = pLCSDEV->iFrameOffset + sizeof(pLCSHdr->hwOffset);

  0066b	48 8b 44 24 60	 mov	 rax, QWORD PTR pLCSDEV$[rsp]
  00670	0f b7 80 a2 00
	00 00		 movzx	 eax, WORD PTR [rax+162]
  00677	48 83 c0 02	 add	 rax, 2
  0067b	48 89 44 24 70	 mov	 QWORD PTR iLength$[rsp], rax

; 3030 : 
; 3031 :     // (calculate residual and set memcpy amount)
; 3032 : 
; 3033 :     // FIXME: we currently don't support data-chaining but
; 3034 :     // probably should if real LCS devices do (I was unable
; 3035 :     // to determine whether they do or not). -- Fish
; 3036 : 
; 3037 :     if (sCount < iLength)

  00680	8b 84 24 e8 00
	00 00		 mov	 eax, DWORD PTR sCount$[rsp]
  00687	48 3b 44 24 70	 cmp	 rax, QWORD PTR iLength$[rsp]
  0068c	73 27		 jae	 SHORT $LN59@LCS_Read

; 3038 :     {
; 3039 :         *pMore     = 1;

  0068e	48 8b 84 24 08
	01 00 00	 mov	 rax, QWORD PTR pMore$[rsp]
  00696	c6 00 01	 mov	 BYTE PTR [rax], 1

; 3040 :         *pResidual = 0;

  00699	48 8b 84 24 00
	01 00 00	 mov	 rax, QWORD PTR pResidual$[rsp]
  006a1	c7 00 00 00 00
	00		 mov	 DWORD PTR [rax], 0

; 3041 : 
; 3042 :         iLength = sCount;

  006a7	8b 84 24 e8 00
	00 00		 mov	 eax, DWORD PTR sCount$[rsp]
  006ae	48 89 44 24 70	 mov	 QWORD PTR iLength$[rsp], rax

; 3043 : 
; 3044 :         // PROGRAMMING NOTE: As a result of the caller asking
; 3045 :         // for less data than we actually have available, the
; 3046 :         // remainder of their unread data they didn't ask for
; 3047 :         // will end up being silently discarded. Refer to the
; 3048 :         // other NOTEs and FIXME's sprinkled throughout this
; 3049 :         // function...
; 3050 :     }

  006b3	eb 24		 jmp	 SHORT $LN60@LCS_Read
$LN59@LCS_Read:

; 3051 :     else
; 3052 :     {
; 3053 :         *pMore      = 0;

  006b5	48 8b 84 24 08
	01 00 00	 mov	 rax, QWORD PTR pMore$[rsp]
  006bd	c6 00 00	 mov	 BYTE PTR [rax], 0

; 3054 :         *pResidual -= iLength;

  006c0	48 8b 84 24 00
	01 00 00	 mov	 rax, QWORD PTR pResidual$[rsp]
  006c8	8b 00		 mov	 eax, DWORD PTR [rax]
  006ca	48 2b 44 24 70	 sub	 rax, QWORD PTR iLength$[rsp]
  006cf	48 8b 8c 24 00
	01 00 00	 mov	 rcx, QWORD PTR pResidual$[rsp]
  006d7	89 01		 mov	 DWORD PTR [rcx], eax
$LN60@LCS_Read:

; 3055 :     }
; 3056 : 
; 3057 :     *pUnitStat = CSW_CE | CSW_DE;

  006d9	48 8b 84 24 f8
	00 00 00	 mov	 rax, QWORD PTR pUnitStat$[rsp]
  006e1	c6 00 0c	 mov	 BYTE PTR [rax], 12

; 3058 : 
; 3059 :     memcpy( pIOBuf, pLCSDEV->bFrameBuffer, iLength );

  006e4	48 8b 44 24 60	 mov	 rax, QWORD PTR pLCSDEV$[rsp]
  006e9	48 05 a6 00 00
	00		 add	 rax, 166		; 000000a6H
  006ef	48 8b bc 24 f0
	00 00 00	 mov	 rdi, QWORD PTR pIOBuf$[rsp]
  006f7	48 8b f0	 mov	 rsi, rax
  006fa	48 8b 4c 24 70	 mov	 rcx, QWORD PTR iLength$[rsp]
  006ff	f3 a4		 rep movsb

; 3060 : 
; 3061 :     // Display up to pLCSBLK->iTraceLen bytes of the data going to the guest, if debug is active
; 3062 :     if (pLCSDEV->pLCSBLK->fDebug)

  00701	48 8b 44 24 60	 mov	 rax, QWORD PTR pLCSDEV$[rsp]
  00706	48 8b 40 08	 mov	 rax, QWORD PTR [rax+8]
  0070a	8b 40 18	 mov	 eax, DWORD PTR [rax+24]
  0070d	83 e0 01	 and	 eax, 1
  00710	85 c0		 test	 eax, eax
  00712	0f 84 d7 01 00
	00		 je	 $LN61@LCS_Read

; 3063 :     {
; 3064 :         // "%1d:%04X %s: Present data of size %d bytes to guest"
; 3065 :         WRMSG(HHC00982, "D", SSID_TO_LCSS(pDEVBLK->ssid), pDEVBLK->devnum, pDEVBLK->typname, (int)iLength );

  00718	48 8b 84 24 e0
	00 00 00	 mov	 rax, QWORD PTR pDEVBLK$[rsp]
  00720	0f b7 40 48	 movzx	 eax, WORD PTR [rax+72]
  00724	89 84 24 80 00
	00 00		 mov	 DWORD PTR tv324[rsp], eax
  0072b	48 8b 8c 24 e0
	00 00 00	 mov	 rcx, QWORD PTR pDEVBLK$[rsp]
  00733	0f b7 49 44	 movzx	 ecx, WORD PTR [rcx+68]
  00737	d1 f9		 sar	 ecx, 1
  00739	89 8c 24 84 00
	00 00		 mov	 DWORD PTR tv328[rsp], ecx
  00740	b9 01 00 00 00	 mov	 ecx, 1
  00745	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  0074b	8b 4c 24 70	 mov	 ecx, DWORD PTR iLength$[rsp]
  0074f	89 4c 24 50	 mov	 DWORD PTR [rsp+80], ecx
  00753	48 8b 8c 24 e0
	00 00 00	 mov	 rcx, QWORD PTR pDEVBLK$[rsp]
  0075b	48 8b 49 50	 mov	 rcx, QWORD PTR [rcx+80]
  0075f	48 89 4c 24 48	 mov	 QWORD PTR [rsp+72], rcx
  00764	8b 8c 24 80 00
	00 00		 mov	 ecx, DWORD PTR tv324[rsp]
  0076b	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  0076f	8b 8c 24 84 00
	00 00		 mov	 ecx, DWORD PTR tv328[rsp]
  00776	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  0077a	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG172547
  00781	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  00786	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG172548
  0078d	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00792	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00797	41 b9 03 00 00
	00		 mov	 r9d, 3
  0079d	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG172549
  007a4	ba f9 0b 00 00	 mov	 edx, 3065		; 00000bf9H
  007a9	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG172550
  007b0	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 3066 :         if (pLCSDEV->pLCSBLK->iTraceLen)

  007b6	48 8b 44 24 60	 mov	 rax, QWORD PTR pLCSDEV$[rsp]
  007bb	48 8b 40 08	 mov	 rax, QWORD PTR [rax+8]
  007bf	83 78 28 00	 cmp	 DWORD PTR [rax+40], 0
  007c3	0f 84 26 01 00
	00		 je	 $LN62@LCS_Read

; 3067 :         {
; 3068 :             iTraceLen = iLength;

  007c9	8b 44 24 70	 mov	 eax, DWORD PTR iLength$[rsp]
  007cd	89 44 24 68	 mov	 DWORD PTR iTraceLen$[rsp], eax

; 3069 :             if (iTraceLen > pLCSDEV->pLCSBLK->iTraceLen)

  007d1	48 8b 44 24 60	 mov	 rax, QWORD PTR pLCSDEV$[rsp]
  007d6	48 8b 40 08	 mov	 rax, QWORD PTR [rax+8]
  007da	8b 40 28	 mov	 eax, DWORD PTR [rax+40]
  007dd	39 44 24 68	 cmp	 DWORD PTR iTraceLen$[rsp], eax
  007e1	0f 8e d2 00 00
	00		 jle	 $LN63@LCS_Read

; 3070 :             {
; 3071 :                 iTraceLen = pLCSDEV->pLCSBLK->iTraceLen;

  007e7	48 8b 44 24 60	 mov	 rax, QWORD PTR pLCSDEV$[rsp]
  007ec	48 8b 40 08	 mov	 rax, QWORD PTR [rax+8]
  007f0	8b 40 28	 mov	 eax, DWORD PTR [rax+40]
  007f3	89 44 24 68	 mov	 DWORD PTR iTraceLen$[rsp], eax

; 3072 :                 // HHC00980 "%1d:%04X %s: Data of size %d bytes displayed, data of size %d bytes not displayed"
; 3073 :                 WRMSG(HHC00980, "D", SSID_TO_LCSS(pDEVBLK->ssid), pDEVBLK->devnum, pDEVBLK->typname,

  007f7	48 63 44 24 68	 movsxd	 rax, DWORD PTR iTraceLen$[rsp]
  007fc	48 8b 4c 24 70	 mov	 rcx, QWORD PTR iLength$[rsp]
  00801	48 2b c8	 sub	 rcx, rax
  00804	48 8b c1	 mov	 rax, rcx
  00807	48 89 84 24 a0
	00 00 00	 mov	 QWORD PTR tv348[rsp], rax
  0080f	48 8b 8c 24 e0
	00 00 00	 mov	 rcx, QWORD PTR pDEVBLK$[rsp]
  00817	0f b7 49 48	 movzx	 ecx, WORD PTR [rcx+72]
  0081b	89 8c 24 88 00
	00 00		 mov	 DWORD PTR tv387[rsp], ecx
  00822	48 8b 94 24 e0
	00 00 00	 mov	 rdx, QWORD PTR pDEVBLK$[rsp]
  0082a	0f b7 52 44	 movzx	 edx, WORD PTR [rdx+68]
  0082e	d1 fa		 sar	 edx, 1
  00830	89 94 24 8c 00
	00 00		 mov	 DWORD PTR tv391[rsp], edx
  00837	b9 01 00 00 00	 mov	 ecx, 1
  0083c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  00842	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR tv348[rsp]
  0084a	89 4c 24 58	 mov	 DWORD PTR [rsp+88], ecx
  0084e	8b 4c 24 68	 mov	 ecx, DWORD PTR iTraceLen$[rsp]
  00852	89 4c 24 50	 mov	 DWORD PTR [rsp+80], ecx
  00856	48 8b 8c 24 e0
	00 00 00	 mov	 rcx, QWORD PTR pDEVBLK$[rsp]
  0085e	48 8b 49 50	 mov	 rcx, QWORD PTR [rcx+80]
  00862	48 89 4c 24 48	 mov	 QWORD PTR [rsp+72], rcx
  00867	8b 8c 24 88 00
	00 00		 mov	 ecx, DWORD PTR tv387[rsp]
  0086e	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  00872	8b 8c 24 8c 00
	00 00		 mov	 ecx, DWORD PTR tv391[rsp]
  00879	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  0087d	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG172553
  00884	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  00889	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG172554
  00890	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00895	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  0089a	41 b9 03 00 00
	00		 mov	 r9d, 3
  008a0	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG172555
  008a7	ba 02 0c 00 00	 mov	 edx, 3074		; 00000c02H
  008ac	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG172556
  008b3	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg
$LN63@LCS_Read:

; 3074 :                                      iTraceLen, (int)(iLength - iTraceLen) );
; 3075 :             }
; 3076 :             net_data_trace( pDEVBLK, pIOBuf, iTraceLen, TO_GUEST, 'D', "data", 0 );

  008b9	c7 44 24 30 00
	00 00 00	 mov	 DWORD PTR [rsp+48], 0
  008c1	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG172557
  008c8	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  008cd	c6 44 24 20 44	 mov	 BYTE PTR [rsp+32], 68	; 00000044H
  008d2	41 b1 3e	 mov	 r9b, 62			; 0000003eH
  008d5	44 8b 44 24 68	 mov	 r8d, DWORD PTR iTraceLen$[rsp]
  008da	48 8b 94 24 f0
	00 00 00	 mov	 rdx, QWORD PTR pIOBuf$[rsp]
  008e2	48 8b 8c 24 e0
	00 00 00	 mov	 rcx, QWORD PTR pDEVBLK$[rsp]
  008ea	e8 00 00 00 00	 call	 net_data_trace
$LN62@LCS_Read:
$LN61@LCS_Read:
$LN37@LCS_Read:

; 3077 :         }
; 3078 :     }
; 3079 : 
; 3080 :     // Reset frame buffer to empty...
; 3081 : 
; 3082 :     // PROGRAMMING NOTE: even though not all available data
; 3083 :     // may have been read by the guest, we don't currently
; 3084 :     // support data-chaining. Thus any unread data is always
; 3085 :     // discarded by resetting all of the iFrameOffset,
; 3086 :     // fDataPending and fReplyPending fields to 0 so that the
; 3087 :     // next read always grabs a new batch of LCS Frames starting
; 3088 :     // at the very beginning of our frame buffer again. (I was
; 3089 :     // unable to determine whether real LCS devices support
; 3090 :     // data-chaining or not, but if they do we should fix this).
; 3091 : 
; 3092 :     PTT_DEBUG( "READ empty buffer ", 000, pDEVBLK->devnum, -1 );

  008ef	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_pttclass
  008f6	48 8b 00	 mov	 rax, QWORD PTR [rax]
  008f9	48 25 00 00 02
	00		 and	 rax, 131072		; 00020000H
  008ff	48 85 c0	 test	 rax, rax
  00902	74 42		 je	 SHORT $LN64@LCS_Read
  00904	48 8b 84 24 e0
	00 00 00	 mov	 rax, QWORD PTR pDEVBLK$[rsp]
  0090c	0f b7 40 48	 movzx	 eax, WORD PTR [rax+72]
  00910	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR [rsp+48], 0
  00919	48 c7 44 24 28
	ff ff ff ff	 mov	 QWORD PTR [rsp+40], -1
  00922	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG172559
  00929	48 89 4c 24 20	 mov	 QWORD PTR [rsp+32], rcx
  0092e	44 8b c8	 mov	 r9d, eax
  00931	45 33 c0	 xor	 r8d, r8d
  00934	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG172560
  0093b	b9 00 00 02 00	 mov	 ecx, 131072		; 00020000H
  00940	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ptt_pthread_trace
$LN64@LCS_Read:
  00946	33 c0		 xor	 eax, eax
  00948	85 c0		 test	 eax, eax
  0094a	75 a3		 jne	 SHORT $LN37@LCS_Read

; 3093 :     pLCSDEV->iFrameOffset  = 0;

  0094c	33 c0		 xor	 eax, eax
  0094e	48 8b 4c 24 60	 mov	 rcx, QWORD PTR pLCSDEV$[rsp]
  00953	66 89 81 a2 00
	00 00		 mov	 WORD PTR [rcx+162], ax

; 3094 :     pLCSDEV->fReplyPending = 0;

  0095a	48 8b 44 24 60	 mov	 rax, QWORD PTR pLCSDEV$[rsp]
  0095f	8b 40 41	 mov	 eax, DWORD PTR [rax+65]
  00962	83 e0 f7	 and	 eax, -9			; fffffff7H
  00965	48 8b 4c 24 60	 mov	 rcx, QWORD PTR pLCSDEV$[rsp]
  0096a	89 41 41	 mov	 DWORD PTR [rcx+65], eax

; 3095 :     pLCSDEV->fDataPending  = 0;

  0096d	48 8b 44 24 60	 mov	 rax, QWORD PTR pLCSDEV$[rsp]
  00972	8b 40 41	 mov	 eax, DWORD PTR [rax+65]
  00975	83 e0 ef	 and	 eax, -17		; ffffffefH
  00978	48 8b 4c 24 60	 mov	 rcx, QWORD PTR pLCSDEV$[rsp]
  0097d	89 41 41	 mov	 DWORD PTR [rcx+65], eax
$LN40@LCS_Read:

; 3096 : 
; 3097 :     PTT_DEBUG(        "REL  DevDataLock  ", 000, pDEVBLK->devnum, -1 );

  00980	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_pttclass
  00987	48 8b 00	 mov	 rax, QWORD PTR [rax]
  0098a	48 25 00 00 02
	00		 and	 rax, 131072		; 00020000H
  00990	48 85 c0	 test	 rax, rax
  00993	74 42		 je	 SHORT $LN65@LCS_Read
  00995	48 8b 84 24 e0
	00 00 00	 mov	 rax, QWORD PTR pDEVBLK$[rsp]
  0099d	0f b7 40 48	 movzx	 eax, WORD PTR [rax+72]
  009a1	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR [rsp+48], 0
  009aa	48 c7 44 24 28
	ff ff ff ff	 mov	 QWORD PTR [rsp+40], -1
  009b3	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG172562
  009ba	48 89 4c 24 20	 mov	 QWORD PTR [rsp+32], rcx
  009bf	44 8b c8	 mov	 r9d, eax
  009c2	45 33 c0	 xor	 r8d, r8d
  009c5	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG172563
  009cc	b9 00 00 02 00	 mov	 ecx, 131072		; 00020000H
  009d1	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ptt_pthread_trace
$LN65@LCS_Read:
  009d7	33 c0		 xor	 eax, eax
  009d9	85 c0		 test	 eax, eax
  009db	75 a3		 jne	 SHORT $LN40@LCS_Read

; 3098 :     release_lock( &pLCSDEV->DevDataLock );

  009dd	48 8b 44 24 60	 mov	 rax, QWORD PTR pLCSDEV$[rsp]
  009e2	48 05 9a 00 00
	00		 add	 rax, 154		; 0000009aH
  009e8	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG172564
  009ef	48 8b c8	 mov	 rcx, rax
  009f2	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_release_lock
$LN43@LCS_Read:

; 3099 : 
; 3100 :     PTT_DEBUG( "READ: EXIT        ", 000, pDEVBLK->devnum, -1 );

  009f8	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_pttclass
  009ff	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00a02	48 25 00 00 02
	00		 and	 rax, 131072		; 00020000H
  00a08	48 85 c0	 test	 rax, rax
  00a0b	74 42		 je	 SHORT $LN66@LCS_Read
  00a0d	48 8b 84 24 e0
	00 00 00	 mov	 rax, QWORD PTR pDEVBLK$[rsp]
  00a15	0f b7 40 48	 movzx	 eax, WORD PTR [rax+72]
  00a19	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR [rsp+48], 0
  00a22	48 c7 44 24 28
	ff ff ff ff	 mov	 QWORD PTR [rsp+40], -1
  00a2b	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG172566
  00a32	48 89 4c 24 20	 mov	 QWORD PTR [rsp+32], rcx
  00a37	44 8b c8	 mov	 r9d, eax
  00a3a	45 33 c0	 xor	 r8d, r8d
  00a3d	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG172567
  00a44	b9 00 00 02 00	 mov	 ecx, 131072		; 00020000H
  00a49	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ptt_pthread_trace
$LN66@LCS_Read:
  00a4f	33 c0		 xor	 eax, eax
  00a51	85 c0		 test	 eax, eax
  00a53	75 a3		 jne	 SHORT $LN43@LCS_Read
$LN1@LCS_Read:

; 3101 : }

  00a55	48 8b 8c 24 b8
	00 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  00a5d	48 33 cc	 xor	 rcx, rsp
  00a60	e8 00 00 00 00	 call	 __security_check_cookie
  00a65	48 81 c4 c8 00
	00 00		 add	 rsp, 200		; 000000c8H
  00a6c	5f		 pop	 rdi
  00a6d	5e		 pop	 rsi
  00a6e	c3		 ret	 0
LCS_Read ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\ctcadpt.h
_TEXT	SEGMENT
pSIDInfo$ = 0
pDEVBLK$ = 32
wCUType$ = 40
bCUMod$ = 48
wDevType$ = 56
bDevMod$ = 64
SetSIDInfo PROC

; 1343 : {

  00000	66 44 89 4c 24
	20		 mov	 WORD PTR [rsp+32], r9w
  00006	44 88 44 24 18	 mov	 BYTE PTR [rsp+24], r8b
  0000b	66 89 54 24 10	 mov	 WORD PTR [rsp+16], dx
  00010	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00015	57		 push	 rdi
  00016	48 83 ec 10	 sub	 rsp, 16

; 1344 :     BYTE* pSIDInfo = pDEVBLK->devid;

  0001a	48 8b 44 24 20	 mov	 rax, QWORD PTR pDEVBLK$[rsp]
  0001f	48 05 68 04 00
	00		 add	 rax, 1128		; 00000468H
  00025	48 89 04 24	 mov	 QWORD PTR pSIDInfo$[rsp], rax

; 1345 : 
; 1346 :     memset( pSIDInfo, 0, sizeof(pDEVBLK->devid) );

  00029	48 8b 3c 24	 mov	 rdi, QWORD PTR pSIDInfo$[rsp]
  0002d	33 c0		 xor	 eax, eax
  0002f	b9 00 01 00 00	 mov	 ecx, 256		; 00000100H
  00034	f3 aa		 rep stosb

; 1347 : 
; 1348 :     *pSIDInfo++ = 0x0FF;

  00036	48 8b 04 24	 mov	 rax, QWORD PTR pSIDInfo$[rsp]
  0003a	c6 00 ff	 mov	 BYTE PTR [rax], 255	; 000000ffH
  0003d	48 8b 04 24	 mov	 rax, QWORD PTR pSIDInfo$[rsp]
  00041	48 ff c0	 inc	 rax
  00044	48 89 04 24	 mov	 QWORD PTR pSIDInfo$[rsp], rax

; 1349 :     *pSIDInfo++ = (BYTE)(( wCUType >> 8 ) & 0x00FF );

  00048	0f b7 44 24 28	 movzx	 eax, WORD PTR wCUType$[rsp]
  0004d	c1 f8 08	 sar	 eax, 8
  00050	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  00055	48 8b 0c 24	 mov	 rcx, QWORD PTR pSIDInfo$[rsp]
  00059	88 01		 mov	 BYTE PTR [rcx], al
  0005b	48 8b 04 24	 mov	 rax, QWORD PTR pSIDInfo$[rsp]
  0005f	48 ff c0	 inc	 rax
  00062	48 89 04 24	 mov	 QWORD PTR pSIDInfo$[rsp], rax

; 1350 :     *pSIDInfo++ = (BYTE)( wCUType & 0x00FF );

  00066	0f b7 44 24 28	 movzx	 eax, WORD PTR wCUType$[rsp]
  0006b	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  00070	48 8b 0c 24	 mov	 rcx, QWORD PTR pSIDInfo$[rsp]
  00074	88 01		 mov	 BYTE PTR [rcx], al
  00076	48 8b 04 24	 mov	 rax, QWORD PTR pSIDInfo$[rsp]
  0007a	48 ff c0	 inc	 rax
  0007d	48 89 04 24	 mov	 QWORD PTR pSIDInfo$[rsp], rax

; 1351 :     *pSIDInfo++ = bCUMod;

  00081	48 8b 04 24	 mov	 rax, QWORD PTR pSIDInfo$[rsp]
  00085	0f b6 4c 24 30	 movzx	 ecx, BYTE PTR bCUMod$[rsp]
  0008a	88 08		 mov	 BYTE PTR [rax], cl
  0008c	48 8b 04 24	 mov	 rax, QWORD PTR pSIDInfo$[rsp]
  00090	48 ff c0	 inc	 rax
  00093	48 89 04 24	 mov	 QWORD PTR pSIDInfo$[rsp], rax

; 1352 :     *pSIDInfo++ = (BYTE)(( wDevType >> 8 ) & 0x00FF );

  00097	0f b7 44 24 38	 movzx	 eax, WORD PTR wDevType$[rsp]
  0009c	c1 f8 08	 sar	 eax, 8
  0009f	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  000a4	48 8b 0c 24	 mov	 rcx, QWORD PTR pSIDInfo$[rsp]
  000a8	88 01		 mov	 BYTE PTR [rcx], al
  000aa	48 8b 04 24	 mov	 rax, QWORD PTR pSIDInfo$[rsp]
  000ae	48 ff c0	 inc	 rax
  000b1	48 89 04 24	 mov	 QWORD PTR pSIDInfo$[rsp], rax

; 1353 :     *pSIDInfo++ = (BYTE)( wDevType & 0x00FF );

  000b5	0f b7 44 24 38	 movzx	 eax, WORD PTR wDevType$[rsp]
  000ba	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  000bf	48 8b 0c 24	 mov	 rcx, QWORD PTR pSIDInfo$[rsp]
  000c3	88 01		 mov	 BYTE PTR [rcx], al
  000c5	48 8b 04 24	 mov	 rax, QWORD PTR pSIDInfo$[rsp]
  000c9	48 ff c0	 inc	 rax
  000cc	48 89 04 24	 mov	 QWORD PTR pSIDInfo$[rsp], rax

; 1354 :     *pSIDInfo++ = bDevMod;

  000d0	48 8b 04 24	 mov	 rax, QWORD PTR pSIDInfo$[rsp]
  000d4	0f b6 4c 24 40	 movzx	 ecx, BYTE PTR bDevMod$[rsp]
  000d9	88 08		 mov	 BYTE PTR [rax], cl
  000db	48 8b 04 24	 mov	 rax, QWORD PTR pSIDInfo$[rsp]
  000df	48 ff c0	 inc	 rax
  000e2	48 89 04 24	 mov	 QWORD PTR pSIDInfo$[rsp], rax

; 1355 :     *pSIDInfo++ = 0x00;

  000e6	48 8b 04 24	 mov	 rax, QWORD PTR pSIDInfo$[rsp]
  000ea	c6 00 00	 mov	 BYTE PTR [rax], 0
  000ed	48 8b 04 24	 mov	 rax, QWORD PTR pSIDInfo$[rsp]
  000f1	48 ff c0	 inc	 rax
  000f4	48 89 04 24	 mov	 QWORD PTR pSIDInfo$[rsp], rax

; 1356 : 
; 1357 :     pDEVBLK->numdevid = 7;

  000f8	48 8b 44 24 20	 mov	 rax, QWORD PTR pDEVBLK$[rsp]
  000fd	c7 80 64 04 00
	00 07 00 00 00	 mov	 DWORD PTR [rax+1124], 7

; 1358 : }

  00107	48 83 c4 10	 add	 rsp, 16
  0010b	5f		 pop	 rdi
  0010c	c3		 ret	 0
SetSIDInfo ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\ctc_lcs.c
_TEXT	SEGMENT
bOpCode$ = 64
iNum$ = 68
tv146 = 72
tv134 = 76
tv263 = 80
tv282 = 84
pLCSDEV$ = 88
pDEVBLK$ = 128
bCode$ = 136
bFlags$ = 144
bChained$ = 152
sCount$ = 160
bPrevCode$ = 168
iCCWSeq$ = 176
pIOBuf$ = 184
pMore$ = 192
pUnitStat$ = 200
pResidual$ = 208
LCS_ExecuteCCW PROC

; 676  : {

$LN78:
  00000	44 88 4c 24 20	 mov	 BYTE PTR [rsp+32], r9b
  00005	44 88 44 24 18	 mov	 BYTE PTR [rsp+24], r8b
  0000a	88 54 24 10	 mov	 BYTE PTR [rsp+16], dl
  0000e	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00013	56		 push	 rsi
  00014	57		 push	 rdi
  00015	48 83 ec 68	 sub	 rsp, 104		; 00000068H
$LN4@LCS_Execut:

; 677  :     PLCSDEV         pLCSDEV;
; 678  :     int             iNum;               // Number of bytes to move
; 679  :     BYTE            bOpCode;            // CCW opcode with modifier
; 680  :                                         //   bits masked off
; 681  : 
; 682  :     UNREFERENCED( bFlags    );

  00019	33 c0		 xor	 eax, eax
  0001b	85 c0		 test	 eax, eax
  0001d	75 fa		 jne	 SHORT $LN4@LCS_Execut
$LN7@LCS_Execut:

; 683  :     UNREFERENCED( bChained  );

  0001f	33 c0		 xor	 eax, eax
  00021	85 c0		 test	 eax, eax
  00023	75 fa		 jne	 SHORT $LN7@LCS_Execut
$LN10@LCS_Execut:

; 684  :     UNREFERENCED( bPrevCode );

  00025	33 c0		 xor	 eax, eax
  00027	85 c0		 test	 eax, eax
  00029	75 fa		 jne	 SHORT $LN10@LCS_Execut
$LN13@LCS_Execut:

; 685  :     UNREFERENCED( iCCWSeq   );

  0002b	33 c0		 xor	 eax, eax
  0002d	85 c0		 test	 eax, eax
  0002f	75 fa		 jne	 SHORT $LN13@LCS_Execut

; 686  : 
; 687  :     pLCSDEV = (PLCSDEV)pDEVBLK->dev_data;

  00031	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR pDEVBLK$[rsp]
  00039	48 8b 80 08 06
	00 00		 mov	 rax, QWORD PTR [rax+1544]
  00040	48 89 44 24 58	 mov	 QWORD PTR pLCSDEV$[rsp], rax

; 688  :     if (!pLCSDEV)

  00045	48 83 7c 24 58
	00		 cmp	 QWORD PTR pLCSDEV$[rsp], 0
  0004b	75 29		 jne	 SHORT $LN25@LCS_Execut

; 689  :     {
; 690  :         // Set command reject sense byte, and unit check status
; 691  :         pDEVBLK->sense[0] = SENSE_CR;

  0004d	b8 01 00 00 00	 mov	 eax, 1
  00052	48 6b c0 00	 imul	 rax, rax, 0
  00056	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR pDEVBLK$[rsp]
  0005e	c6 84 01 64 03
	00 00 80	 mov	 BYTE PTR [rcx+rax+868], 128 ; 00000080H

; 692  :         *pUnitStat        = CSW_CE | CSW_DE | CSW_UC;

  00066	48 8b 84 24 c8
	00 00 00	 mov	 rax, QWORD PTR pUnitStat$[rsp]
  0006e	c6 00 0e	 mov	 BYTE PTR [rax], 14

; 693  :         return;  // (incomplete group?)

  00071	e9 8a 07 00 00	 jmp	 $LN1@LCS_Execut
$LN25@LCS_Execut:

; 694  :     }
; 695  : 
; 696  :     // Intervention required if the device file is not open
; 697  :     if (1
; 698  :         && pDEVBLK->fd < 0
; 699  :         && !IS_CCW_SENSE  ( bCode )
; 700  :         && !IS_CCW_CONTROL( bCode )

  00076	33 c0		 xor	 eax, eax
  00078	83 f8 01	 cmp	 eax, 1
  0007b	74 5a		 je	 SHORT $LN26@LCS_Execut
  0007d	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR pDEVBLK$[rsp]
  00085	83 b8 ac 01 00
	00 00		 cmp	 DWORD PTR [rax+428], 0
  0008c	7d 49		 jge	 SHORT $LN26@LCS_Execut
  0008e	0f b6 84 24 88
	00 00 00	 movzx	 eax, BYTE PTR bCode$[rsp]
  00096	83 e0 0f	 and	 eax, 15
  00099	83 f8 04	 cmp	 eax, 4
  0009c	74 39		 je	 SHORT $LN26@LCS_Execut
  0009e	0f b6 84 24 88
	00 00 00	 movzx	 eax, BYTE PTR bCode$[rsp]
  000a6	83 e0 03	 and	 eax, 3
  000a9	83 f8 03	 cmp	 eax, 3
  000ac	74 29		 je	 SHORT $LN26@LCS_Execut

; 701  :     )
; 702  :     {
; 703  :         pDEVBLK->sense[0] = SENSE_IR;

  000ae	b8 01 00 00 00	 mov	 eax, 1
  000b3	48 6b c0 00	 imul	 rax, rax, 0
  000b7	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR pDEVBLK$[rsp]
  000bf	c6 84 01 64 03
	00 00 40	 mov	 BYTE PTR [rcx+rax+868], 64 ; 00000040H

; 704  :         *pUnitStat = CSW_CE | CSW_DE | CSW_UC;

  000c7	48 8b 84 24 c8
	00 00 00	 mov	 rax, QWORD PTR pUnitStat$[rsp]
  000cf	c6 00 0e	 mov	 BYTE PTR [rax], 14

; 705  :         return;

  000d2	e9 29 07 00 00	 jmp	 $LN1@LCS_Execut
$LN26@LCS_Execut:

; 706  :     }
; 707  : 
; 708  :     // Mask off the modifier bits in the CCW bOpCode
; 709  :          if ((bCode & 0x07) == 0x07) bOpCode = 0x07;

  000d7	0f b6 84 24 88
	00 00 00	 movzx	 eax, BYTE PTR bCode$[rsp]
  000df	83 e0 07	 and	 eax, 7
  000e2	83 f8 07	 cmp	 eax, 7
  000e5	75 0a		 jne	 SHORT $LN27@LCS_Execut
  000e7	c6 44 24 40 07	 mov	 BYTE PTR bOpCode$[rsp], 7
  000ec	e9 d2 00 00 00	 jmp	 $LN28@LCS_Execut
$LN27@LCS_Execut:

; 710  :     else if ((bCode & 0x03) == 0x02) bOpCode = 0x02;

  000f1	0f b6 84 24 88
	00 00 00	 movzx	 eax, BYTE PTR bCode$[rsp]
  000f9	83 e0 03	 and	 eax, 3
  000fc	83 f8 02	 cmp	 eax, 2
  000ff	75 0a		 jne	 SHORT $LN29@LCS_Execut
  00101	c6 44 24 40 02	 mov	 BYTE PTR bOpCode$[rsp], 2
  00106	e9 b8 00 00 00	 jmp	 $LN30@LCS_Execut
$LN29@LCS_Execut:

; 711  :     else if ((bCode & 0x0F) == 0x0C) bOpCode = 0x0C;

  0010b	0f b6 84 24 88
	00 00 00	 movzx	 eax, BYTE PTR bCode$[rsp]
  00113	83 e0 0f	 and	 eax, 15
  00116	83 f8 0c	 cmp	 eax, 12
  00119	75 0a		 jne	 SHORT $LN31@LCS_Execut
  0011b	c6 44 24 40 0c	 mov	 BYTE PTR bOpCode$[rsp], 12
  00120	e9 9e 00 00 00	 jmp	 $LN32@LCS_Execut
$LN31@LCS_Execut:

; 712  :     else if ((bCode & 0x03) == 0x01) bOpCode = pDEVBLK->ctcxmode ? (bCode & 0x83) : 0x01;

  00125	0f b6 84 24 88
	00 00 00	 movzx	 eax, BYTE PTR bCode$[rsp]
  0012d	83 e0 03	 and	 eax, 3
  00130	83 f8 01	 cmp	 eax, 1
  00133	75 3b		 jne	 SHORT $LN33@LCS_Execut
  00135	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR pDEVBLK$[rsp]
  0013d	8b 80 18 07 00
	00		 mov	 eax, DWORD PTR [rax+1816]
  00143	83 e0 01	 and	 eax, 1
  00146	85 c0		 test	 eax, eax
  00148	74 13		 je	 SHORT $LN70@LCS_Execut
  0014a	0f b6 84 24 88
	00 00 00	 movzx	 eax, BYTE PTR bCode$[rsp]
  00152	25 83 00 00 00	 and	 eax, 131		; 00000083H
  00157	89 44 24 4c	 mov	 DWORD PTR tv134[rsp], eax
  0015b	eb 08		 jmp	 SHORT $LN71@LCS_Execut
$LN70@LCS_Execut:
  0015d	c7 44 24 4c 01
	00 00 00	 mov	 DWORD PTR tv134[rsp], 1
$LN71@LCS_Execut:
  00165	0f b6 44 24 4c	 movzx	 eax, BYTE PTR tv134[rsp]
  0016a	88 44 24 40	 mov	 BYTE PTR bOpCode$[rsp], al
  0016e	eb 53		 jmp	 SHORT $LN34@LCS_Execut
$LN33@LCS_Execut:

; 713  :     else if ((bCode & 0x1F) == 0x14) bOpCode = 0x14;

  00170	0f b6 84 24 88
	00 00 00	 movzx	 eax, BYTE PTR bCode$[rsp]
  00178	83 e0 1f	 and	 eax, 31
  0017b	83 f8 14	 cmp	 eax, 20
  0017e	75 07		 jne	 SHORT $LN35@LCS_Execut
  00180	c6 44 24 40 14	 mov	 BYTE PTR bOpCode$[rsp], 20
  00185	eb 3c		 jmp	 SHORT $LN36@LCS_Execut
$LN35@LCS_Execut:

; 714  :     else if ((bCode & 0x47) == 0x03) bOpCode = 0x03;

  00187	0f b6 84 24 88
	00 00 00	 movzx	 eax, BYTE PTR bCode$[rsp]
  0018f	83 e0 47	 and	 eax, 71			; 00000047H
  00192	83 f8 03	 cmp	 eax, 3
  00195	75 07		 jne	 SHORT $LN37@LCS_Execut
  00197	c6 44 24 40 03	 mov	 BYTE PTR bOpCode$[rsp], 3
  0019c	eb 25		 jmp	 SHORT $LN38@LCS_Execut
$LN37@LCS_Execut:

; 715  :     else if ((bCode & 0xC7) == 0x43) bOpCode = 0x43;

  0019e	0f b6 84 24 88
	00 00 00	 movzx	 eax, BYTE PTR bCode$[rsp]
  001a6	25 c7 00 00 00	 and	 eax, 199		; 000000c7H
  001ab	83 f8 43	 cmp	 eax, 67			; 00000043H
  001ae	75 07		 jne	 SHORT $LN39@LCS_Execut
  001b0	c6 44 24 40 43	 mov	 BYTE PTR bOpCode$[rsp], 67 ; 00000043H
  001b5	eb 0c		 jmp	 SHORT $LN40@LCS_Execut
$LN39@LCS_Execut:

; 716  :     else
; 717  :         bOpCode = bCode;

  001b7	0f b6 84 24 88
	00 00 00	 movzx	 eax, BYTE PTR bCode$[rsp]
  001bf	88 44 24 40	 mov	 BYTE PTR bOpCode$[rsp], al
$LN40@LCS_Execut:
$LN38@LCS_Execut:
$LN36@LCS_Execut:
$LN34@LCS_Execut:
$LN32@LCS_Execut:
$LN30@LCS_Execut:
$LN28@LCS_Execut:

; 718  : 
; 719  : 
; 720  :     // Process depending on CCW bOpCode
; 721  :     switch (bOpCode)

  001c3	0f b6 44 24 40	 movzx	 eax, BYTE PTR bOpCode$[rsp]
  001c8	89 44 24 48	 mov	 DWORD PTR tv146[rsp], eax
  001cc	8b 44 24 48	 mov	 eax, DWORD PTR tv146[rsp]
  001d0	ff c8		 dec	 eax
  001d2	89 44 24 48	 mov	 DWORD PTR tv146[rsp], eax
  001d6	81 7c 24 48 e3
	00 00 00	 cmp	 DWORD PTR tv146[rsp], 227 ; 000000e3H
  001de	0f 87 f8 05 00
	00		 ja	 $LN68@LCS_Execut
  001e4	48 63 44 24 48	 movsxd	 rax, DWORD PTR tv146[rsp]
  001e9	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__ImageBase
  001f0	0f b6 84 01 00
	00 00 00	 movzx	 eax, BYTE PTR $LN76@LCS_Execut[rcx+rax]
  001f8	8b 84 81 00 00
	00 00		 mov	 eax, DWORD PTR $LN77@LCS_Execut[rcx+rax*4]
  001ff	48 03 c1	 add	 rax, rcx
  00202	ff e0		 jmp	 rax
$LN41@LCS_Execut:

; 722  :     {
; 723  :     case 0x01:  // 0MMMMM01  WRITE
; 724  :         //------------------------------------------------------------
; 725  :         // WRITE
; 726  :         //------------------------------------------------------------
; 727  : 
; 728  :         // Return normal status if CCW count is zero
; 729  :         if (sCount == 0)

  00204	83 bc 24 a0 00
	00 00 00	 cmp	 DWORD PTR sCount$[rsp], 0
  0020c	75 10		 jne	 SHORT $LN42@LCS_Execut

; 730  :         {
; 731  :             *pUnitStat = CSW_CE | CSW_DE;

  0020e	48 8b 84 24 c8
	00 00 00	 mov	 rax, QWORD PTR pUnitStat$[rsp]
  00216	c6 00 0c	 mov	 BYTE PTR [rax], 12

; 732  :             break;

  00219	e9 e2 05 00 00	 jmp	 $LN14@LCS_Execut
$LN42@LCS_Execut:

; 733  :         }
; 734  : 
; 735  :         if (pLCSDEV->bMode == LCSDEV_MODE_IP)

  0021e	48 8b 44 24 58	 mov	 rax, QWORD PTR pLCSDEV$[rsp]
  00223	0f b6 40 22	 movzx	 eax, BYTE PTR [rax+34]
  00227	83 f8 01	 cmp	 eax, 1
  0022a	75 33		 jne	 SHORT $LN43@LCS_Execut

; 736  :         {
; 737  :             LCS_Write( pDEVBLK, sCount, pIOBuf, pUnitStat, pResidual );

  0022c	48 8b 84 24 d0
	00 00 00	 mov	 rax, QWORD PTR pResidual$[rsp]
  00234	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00239	4c 8b 8c 24 c8
	00 00 00	 mov	 r9, QWORD PTR pUnitStat$[rsp]
  00241	4c 8b 84 24 b8
	00 00 00	 mov	 r8, QWORD PTR pIOBuf$[rsp]
  00249	8b 94 24 a0 00
	00 00		 mov	 edx, DWORD PTR sCount$[rsp]
  00250	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR pDEVBLK$[rsp]
  00258	e8 00 00 00 00	 call	 LCS_Write

; 738  :         }

  0025d	eb 31		 jmp	 SHORT $LN44@LCS_Execut
$LN43@LCS_Execut:

; 739  :         else  //  (pLCSDEV->bMode == LCSDEV_MODE_SNA)
; 740  :         {
; 741  :             LCS_Write_SNA( pDEVBLK, sCount, pIOBuf, pUnitStat, pResidual );

  0025f	48 8b 84 24 d0
	00 00 00	 mov	 rax, QWORD PTR pResidual$[rsp]
  00267	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  0026c	4c 8b 8c 24 c8
	00 00 00	 mov	 r9, QWORD PTR pUnitStat$[rsp]
  00274	4c 8b 84 24 b8
	00 00 00	 mov	 r8, QWORD PTR pIOBuf$[rsp]
  0027c	8b 94 24 a0 00
	00 00		 mov	 edx, DWORD PTR sCount$[rsp]
  00283	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR pDEVBLK$[rsp]
  0028b	e8 00 00 00 00	 call	 LCS_Write_SNA
$LN44@LCS_Execut:

; 742  :         }
; 743  : 
; 744  :         break;

  00290	e9 6b 05 00 00	 jmp	 $LN14@LCS_Execut
$LN45@LCS_Execut:

; 745  : 
; 746  :     case 0x81:  // 1MMMMM01  WEOF
; 747  :         //------------------------------------------------------------
; 748  :         // WRITE EOF
; 749  :         //------------------------------------------------------------
; 750  : 
; 751  :         // Return normal status
; 752  :         *pUnitStat = CSW_CE | CSW_DE;

  00295	48 8b 84 24 c8
	00 00 00	 mov	 rax, QWORD PTR pUnitStat$[rsp]
  0029d	c6 00 0c	 mov	 BYTE PTR [rax], 12

; 753  :         break;

  002a0	e9 5b 05 00 00	 jmp	 $LN14@LCS_Execut
$LN46@LCS_Execut:
$LN47@LCS_Execut:

; 754  : 
; 755  :     case 0x02:  // MMMMMM10  READ
; 756  :     case 0x0C:  // MMMM1100  RDBACK
; 757  :         // -----------------------------------------------------------
; 758  :         // READ & READ BACKWARDS
; 759  :         // -----------------------------------------------------------
; 760  : 
; 761  :         // Read data and set unit status and residual byte count
; 762  :         if (pLCSDEV->bMode == LCSDEV_MODE_IP)

  002a5	48 8b 44 24 58	 mov	 rax, QWORD PTR pLCSDEV$[rsp]
  002aa	0f b6 40 22	 movzx	 eax, BYTE PTR [rax+34]
  002ae	83 f8 01	 cmp	 eax, 1
  002b1	75 40		 jne	 SHORT $LN48@LCS_Execut

; 763  :         {
; 764  :             LCS_Read( pDEVBLK, sCount, pIOBuf, pUnitStat, pResidual, pMore );

  002b3	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR pMore$[rsp]
  002bb	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  002c0	48 8b 84 24 d0
	00 00 00	 mov	 rax, QWORD PTR pResidual$[rsp]
  002c8	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  002cd	4c 8b 8c 24 c8
	00 00 00	 mov	 r9, QWORD PTR pUnitStat$[rsp]
  002d5	4c 8b 84 24 b8
	00 00 00	 mov	 r8, QWORD PTR pIOBuf$[rsp]
  002dd	8b 94 24 a0 00
	00 00		 mov	 edx, DWORD PTR sCount$[rsp]
  002e4	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR pDEVBLK$[rsp]
  002ec	e8 00 00 00 00	 call	 LCS_Read

; 765  :         }

  002f1	eb 3e		 jmp	 SHORT $LN49@LCS_Execut
$LN48@LCS_Execut:

; 766  :         else  //  (pLCSDEV->bMode == LCSDEV_MODE_SNA)
; 767  :         {
; 768  :             LCS_Read_SNA( pDEVBLK, sCount, pIOBuf, pUnitStat, pResidual, pMore );

  002f3	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR pMore$[rsp]
  002fb	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  00300	48 8b 84 24 d0
	00 00 00	 mov	 rax, QWORD PTR pResidual$[rsp]
  00308	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  0030d	4c 8b 8c 24 c8
	00 00 00	 mov	 r9, QWORD PTR pUnitStat$[rsp]
  00315	4c 8b 84 24 b8
	00 00 00	 mov	 r8, QWORD PTR pIOBuf$[rsp]
  0031d	8b 94 24 a0 00
	00 00		 mov	 edx, DWORD PTR sCount$[rsp]
  00324	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR pDEVBLK$[rsp]
  0032c	e8 00 00 00 00	 call	 LCS_Read_SNA
$LN49@LCS_Execut:

; 769  :         }
; 770  : 
; 771  :         break;

  00331	e9 ca 04 00 00	 jmp	 $LN14@LCS_Execut
$LN50@LCS_Execut:

; 772  : 
; 773  :     case 0x07:  // MMMMM111  CTL
; 774  :         // -----------------------------------------------------------
; 775  :         // CONTROL
; 776  :         // -----------------------------------------------------------
; 777  : 
; 778  :         if (pLCSDEV->bMode == LCSDEV_MODE_SNA)

  00336	48 8b 44 24 58	 mov	 rax, QWORD PTR pLCSDEV$[rsp]
  0033b	0f b6 40 22	 movzx	 eax, BYTE PTR [rax+34]
  0033f	83 f8 02	 cmp	 eax, 2
  00342	75 10		 jne	 SHORT $LN51@LCS_Execut

; 779  :         {
; 780  :             // For SNA this the first CCW in the chain
; 781  :             // Write Control (0x17), Write (0x01), Read (0x02).
; 782  :             pLCSDEV->bFlipFlop = bCode;

  00344	48 8b 44 24 58	 mov	 rax, QWORD PTR pLCSDEV$[rsp]
  00349	0f b6 8c 24 88
	00 00 00	 movzx	 ecx, BYTE PTR bCode$[rsp]
  00351	88 48 65	 mov	 BYTE PTR [rax+101], cl
$LN51@LCS_Execut:

; 783  :         }
; 784  : 
; 785  :         *pUnitStat = CSW_CE | CSW_DE;

  00354	48 8b 84 24 c8
	00 00 00	 mov	 rax, QWORD PTR pUnitStat$[rsp]
  0035c	c6 00 0c	 mov	 BYTE PTR [rax], 12

; 786  :         break;

  0035f	e9 9c 04 00 00	 jmp	 $LN14@LCS_Execut
$LN52@LCS_Execut:

; 787  : 
; 788  :     case 0x14:  // XXX10100  SCB
; 789  :         // -----------------------------------------------------------
; 790  :         // SENSE COMMAND BYTE
; 791  :         // -----------------------------------------------------------
; 792  : 
; 793  :         if (pLCSDEV->bMode == LCSDEV_MODE_SNA)

  00364	48 8b 44 24 58	 mov	 rax, QWORD PTR pLCSDEV$[rsp]
  00369	0f b6 40 22	 movzx	 eax, BYTE PTR [rax+34]
  0036d	83 f8 02	 cmp	 eax, 2
  00370	75 10		 jne	 SHORT $LN53@LCS_Execut

; 794  :         {
; 795  :             // For SNA this the first CCW in the chain
; 796  :             // Sense Command Byte (0x14), Write (0x01), Read (0x02).
; 797  :             // The SCB does not expect any input.
; 798  :             pLCSDEV->bFlipFlop = bCode;

  00372	48 8b 44 24 58	 mov	 rax, QWORD PTR pLCSDEV$[rsp]
  00377	0f b6 8c 24 88
	00 00 00	 movzx	 ecx, BYTE PTR bCode$[rsp]
  0037f	88 48 65	 mov	 BYTE PTR [rax+101], cl
$LN53@LCS_Execut:

; 799  :         }
; 800  : 
; 801  :         *pUnitStat = CSW_CE | CSW_DE;

  00382	48 8b 84 24 c8
	00 00 00	 mov	 rax, QWORD PTR pUnitStat$[rsp]
  0038a	c6 00 0c	 mov	 BYTE PTR [rax], 12

; 802  :         break;

  0038d	e9 6e 04 00 00	 jmp	 $LN14@LCS_Execut
$LN54@LCS_Execut:

; 803  : 
; 804  :     case 0x03:  // M0MMM011  NOP
; 805  :         // -----------------------------------------------------------
; 806  :         // CONTROL NO-OPERATON
; 807  :         // -----------------------------------------------------------
; 808  : 
; 809  :         *pUnitStat = CSW_CE | CSW_DE;

  00392	48 8b 84 24 c8
	00 00 00	 mov	 rax, QWORD PTR pUnitStat$[rsp]
  0039a	c6 00 0c	 mov	 BYTE PTR [rax], 12

; 810  :         break;

  0039d	e9 5e 04 00 00	 jmp	 $LN14@LCS_Execut
$LN55@LCS_Execut:

; 811  : 
; 812  :     case 0x43:  // 00XXX011  SBM
; 813  :         // -----------------------------------------------------------
; 814  :         // SET BASIC MODE
; 815  :         // Also called Enable Compatability Mode (ECM) by SNA,
; 816  :         // ECM is the last CCW issued after the XCA is inactivated.
; 817  :         // -----------------------------------------------------------
; 818  : 
; 819  :         // Command reject if in basic mode
; 820  :         if (pDEVBLK->ctcxmode == 0)

  003a2	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR pDEVBLK$[rsp]
  003aa	8b 80 18 07 00
	00		 mov	 eax, DWORD PTR [rax+1816]
  003b0	83 e0 01	 and	 eax, 1
  003b3	85 c0		 test	 eax, eax
  003b5	75 29		 jne	 SHORT $LN56@LCS_Execut

; 821  :         {
; 822  :             pDEVBLK->sense[0] = SENSE_CR;

  003b7	b8 01 00 00 00	 mov	 eax, 1
  003bc	48 6b c0 00	 imul	 rax, rax, 0
  003c0	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR pDEVBLK$[rsp]
  003c8	c6 84 01 64 03
	00 00 80	 mov	 BYTE PTR [rcx+rax+868], 128 ; 00000080H

; 823  :             *pUnitStat        = CSW_CE | CSW_DE | CSW_UC;

  003d0	48 8b 84 24 c8
	00 00 00	 mov	 rax, QWORD PTR pUnitStat$[rsp]
  003d8	c6 00 0e	 mov	 BYTE PTR [rax], 14

; 824  : 
; 825  :             break;

  003db	e9 20 04 00 00	 jmp	 $LN14@LCS_Execut
$LN56@LCS_Execut:

; 826  :         }
; 827  : 
; 828  :         // Reset extended mode and return normal status
; 829  :         pDEVBLK->ctcxmode = 0;

  003e0	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR pDEVBLK$[rsp]
  003e8	8b 80 18 07 00
	00		 mov	 eax, DWORD PTR [rax+1816]
  003ee	83 e0 fe	 and	 eax, -2			; fffffffeH
  003f1	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR pDEVBLK$[rsp]
  003f9	89 81 18 07 00
	00		 mov	 DWORD PTR [rcx+1816], eax

; 830  : 
; 831  :         *pResidual = 0;

  003ff	48 8b 84 24 d0
	00 00 00	 mov	 rax, QWORD PTR pResidual$[rsp]
  00407	c7 00 00 00 00
	00		 mov	 DWORD PTR [rax], 0

; 832  :         *pUnitStat = CSW_CE | CSW_DE;

  0040d	48 8b 84 24 c8
	00 00 00	 mov	 rax, QWORD PTR pUnitStat$[rsp]
  00415	c6 00 0c	 mov	 BYTE PTR [rax], 12

; 833  : 
; 834  :         break;

  00418	e9 e3 03 00 00	 jmp	 $LN14@LCS_Execut
$LN57@LCS_Execut:

; 835  : 
; 836  :     case 0xC3:  // 11000011  SEM
; 837  :         // -----------------------------------------------------------
; 838  :         // SET EXTENDED MODE
; 839  :         // Also called Disable Compatability Mode (DCM) by SNA.
; 840  :         // DCM is the first CCW issued after the XCA is activated.
; 841  :         // -----------------------------------------------------------
; 842  : 
; 843  :         if (pLCSDEV->bMode == LCSDEV_MODE_SNA)

  0041d	48 8b 44 24 58	 mov	 rax, QWORD PTR pLCSDEV$[rsp]
  00422	0f b6 40 22	 movzx	 eax, BYTE PTR [rax+34]
  00426	83 f8 02	 cmp	 eax, 2
  00429	0f 85 b1 01 00
	00		 jne	 $LN58@LCS_Execut
$LN18@LCS_Execut:

; 844  :         {
; 845  :             // Reset the frame buffer to an empty state.
; 846  :             PTT_DEBUG(       "GET  DevDataLock  ", 000, pDEVBLK->devnum, -1 );

  0042f	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_pttclass
  00436	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00439	48 25 00 00 02
	00		 and	 rax, 131072		; 00020000H
  0043f	48 85 c0	 test	 rax, rax
  00442	74 42		 je	 SHORT $LN59@LCS_Execut
  00444	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR pDEVBLK$[rsp]
  0044c	0f b7 40 48	 movzx	 eax, WORD PTR [rax+72]
  00450	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR [rsp+48], 0
  00459	48 c7 44 24 28
	ff ff ff ff	 mov	 QWORD PTR [rsp+40], -1
  00462	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169779
  00469	48 89 4c 24 20	 mov	 QWORD PTR [rsp+32], rcx
  0046e	44 8b c8	 mov	 r9d, eax
  00471	45 33 c0	 xor	 r8d, r8d
  00474	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG169780
  0047b	b9 00 00 02 00	 mov	 ecx, 131072		; 00020000H
  00480	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ptt_pthread_trace
$LN59@LCS_Execut:
  00486	33 c0		 xor	 eax, eax
  00488	85 c0		 test	 eax, eax
  0048a	75 a3		 jne	 SHORT $LN18@LCS_Execut

; 847  :             obtain_lock( &pLCSDEV->DevDataLock );

  0048c	48 8b 44 24 58	 mov	 rax, QWORD PTR pLCSDEV$[rsp]
  00491	48 05 9a 00 00
	00		 add	 rax, 154		; 0000009aH
  00497	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG169781
  0049e	48 8b c8	 mov	 rcx, rax
  004a1	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_obtain_lock
$LN21@LCS_Execut:

; 848  :             PTT_DEBUG(       "GOT  DevDataLock  ", 000, pDEVBLK->devnum, -1 );

  004a7	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_pttclass
  004ae	48 8b 00	 mov	 rax, QWORD PTR [rax]
  004b1	48 25 00 00 02
	00		 and	 rax, 131072		; 00020000H
  004b7	48 85 c0	 test	 rax, rax
  004ba	74 42		 je	 SHORT $LN60@LCS_Execut
  004bc	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR pDEVBLK$[rsp]
  004c4	0f b7 40 48	 movzx	 eax, WORD PTR [rax+72]
  004c8	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR [rsp+48], 0
  004d1	48 c7 44 24 28
	ff ff ff ff	 mov	 QWORD PTR [rsp+40], -1
  004da	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169783
  004e1	48 89 4c 24 20	 mov	 QWORD PTR [rsp+32], rcx
  004e6	44 8b c8	 mov	 r9d, eax
  004e9	45 33 c0	 xor	 r8d, r8d
  004ec	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG169784
  004f3	b9 00 00 02 00	 mov	 ecx, 131072		; 00020000H
  004f8	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ptt_pthread_trace
$LN60@LCS_Execut:
  004fe	33 c0		 xor	 eax, eax
  00500	85 c0		 test	 eax, eax
  00502	75 a3		 jne	 SHORT $LN21@LCS_Execut

; 849  :             pLCSDEV->iFrameOffset  = 0;

  00504	33 c0		 xor	 eax, eax
  00506	48 8b 4c 24 58	 mov	 rcx, QWORD PTR pLCSDEV$[rsp]
  0050b	66 89 81 a2 00
	00 00		 mov	 WORD PTR [rcx+162], ax

; 850  :             pLCSDEV->fReplyPending = 0;

  00512	48 8b 44 24 58	 mov	 rax, QWORD PTR pLCSDEV$[rsp]
  00517	8b 40 41	 mov	 eax, DWORD PTR [rax+65]
  0051a	83 e0 f7	 and	 eax, -9			; fffffff7H
  0051d	48 8b 4c 24 58	 mov	 rcx, QWORD PTR pLCSDEV$[rsp]
  00522	89 41 41	 mov	 DWORD PTR [rcx+65], eax

; 851  :             pLCSDEV->fDataPending  = 0;

  00525	48 8b 44 24 58	 mov	 rax, QWORD PTR pLCSDEV$[rsp]
  0052a	8b 40 41	 mov	 eax, DWORD PTR [rax+65]
  0052d	83 e0 ef	 and	 eax, -17		; ffffffefH
  00530	48 8b 4c 24 58	 mov	 rcx, QWORD PTR pLCSDEV$[rsp]
  00535	89 41 41	 mov	 DWORD PTR [rcx+65], eax

; 852  :             pLCSDEV->fPendingIctl  = 0;

  00538	48 8b 44 24 58	 mov	 rax, QWORD PTR pLCSDEV$[rsp]
  0053d	8b 40 5d	 mov	 eax, DWORD PTR [rax+93]
  00540	83 e0 fb	 and	 eax, -5			; fffffffbH
  00543	48 8b 4c 24 58	 mov	 rcx, QWORD PTR pLCSDEV$[rsp]
  00548	89 41 5d	 mov	 DWORD PTR [rcx+93], eax
$LN24@LCS_Execut:

; 853  :             PTT_DEBUG(        "REL  DevDataLock  ", 000, pDEVBLK->devnum, -1 );

  0054b	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_pttclass
  00552	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00555	48 25 00 00 02
	00		 and	 rax, 131072		; 00020000H
  0055b	48 85 c0	 test	 rax, rax
  0055e	74 42		 je	 SHORT $LN61@LCS_Execut
  00560	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR pDEVBLK$[rsp]
  00568	0f b7 40 48	 movzx	 eax, WORD PTR [rax+72]
  0056c	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR [rsp+48], 0
  00575	48 c7 44 24 28
	ff ff ff ff	 mov	 QWORD PTR [rsp+40], -1
  0057e	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169786
  00585	48 89 4c 24 20	 mov	 QWORD PTR [rsp+32], rcx
  0058a	44 8b c8	 mov	 r9d, eax
  0058d	45 33 c0	 xor	 r8d, r8d
  00590	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG169787
  00597	b9 00 00 02 00	 mov	 ecx, 131072		; 00020000H
  0059c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ptt_pthread_trace
$LN61@LCS_Execut:
  005a2	33 c0		 xor	 eax, eax
  005a4	85 c0		 test	 eax, eax
  005a6	75 a3		 jne	 SHORT $LN24@LCS_Execut

; 854  :             release_lock( &pLCSDEV->DevDataLock );

  005a8	48 8b 44 24 58	 mov	 rax, QWORD PTR pLCSDEV$[rsp]
  005ad	48 05 9a 00 00
	00		 add	 rax, 154		; 0000009aH
  005b3	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG169788
  005ba	48 8b c8	 mov	 rcx, rax
  005bd	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_release_lock

; 855  :             remove_and_free_any_lcs_buffers_on_chain( pLCSDEV );

  005c3	48 8b 4c 24 58	 mov	 rcx, QWORD PTR pLCSDEV$[rsp]
  005c8	e8 00 00 00 00	 call	 remove_and_free_any_lcs_buffers_on_chain

; 856  :             remove_and_free_any_connections_on_chain( pLCSDEV );

  005cd	48 8b 4c 24 58	 mov	 rcx, QWORD PTR pLCSDEV$[rsp]
  005d2	e8 00 00 00 00	 call	 remove_and_free_any_connections_on_chain

; 857  :             pLCSDEV->bFlipFlop = 0;

  005d7	48 8b 44 24 58	 mov	 rax, QWORD PTR pLCSDEV$[rsp]
  005dc	c6 40 65 00	 mov	 BYTE PTR [rax+101], 0
$LN58@LCS_Execut:

; 858  :         }
; 859  : 
; 860  :         pDEVBLK->ctcxmode = 1;

  005e0	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR pDEVBLK$[rsp]
  005e8	8b 80 18 07 00
	00		 mov	 eax, DWORD PTR [rax+1816]
  005ee	83 c8 01	 or	 eax, 1
  005f1	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR pDEVBLK$[rsp]
  005f9	89 81 18 07 00
	00		 mov	 DWORD PTR [rcx+1816], eax

; 861  : 
; 862  :         *pResidual = 0;

  005ff	48 8b 84 24 d0
	00 00 00	 mov	 rax, QWORD PTR pResidual$[rsp]
  00607	c7 00 00 00 00
	00		 mov	 DWORD PTR [rax], 0

; 863  :         *pUnitStat = CSW_CE | CSW_DE;

  0060d	48 8b 84 24 c8
	00 00 00	 mov	 rax, QWORD PTR pUnitStat$[rsp]
  00615	c6 00 0c	 mov	 BYTE PTR [rax], 12

; 864  : 
; 865  :         break;

  00618	e9 e3 01 00 00	 jmp	 $LN14@LCS_Execut
$LN62@LCS_Execut:

; 866  : 
; 867  :     case 0xE3:  // 11100011
; 868  :         // -----------------------------------------------------------
; 869  :         // PREPARE (PREP)
; 870  :         // -----------------------------------------------------------
; 871  : 
; 872  :         *pUnitStat = CSW_CE | CSW_DE;

  0061d	48 8b 84 24 c8
	00 00 00	 mov	 rax, QWORD PTR pUnitStat$[rsp]
  00625	c6 00 0c	 mov	 BYTE PTR [rax], 12

; 873  : 
; 874  :         break;

  00628	e9 d3 01 00 00	 jmp	 $LN14@LCS_Execut
$LN63@LCS_Execut:

; 875  : 
; 876  :     case 0x04:  // 00000100  SENSE
; 877  :       // -----------------------------------------------------------
; 878  :       // SENSE
; 879  :       // -----------------------------------------------------------
; 880  : 
; 881  :         // Command reject if in basic mode
; 882  :         if (pDEVBLK->ctcxmode == 0)

  0062d	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR pDEVBLK$[rsp]
  00635	8b 80 18 07 00
	00		 mov	 eax, DWORD PTR [rax+1816]
  0063b	83 e0 01	 and	 eax, 1
  0063e	85 c0		 test	 eax, eax
  00640	75 29		 jne	 SHORT $LN64@LCS_Execut

; 883  :         {
; 884  :             pDEVBLK->sense[0] = SENSE_CR;

  00642	b8 01 00 00 00	 mov	 eax, 1
  00647	48 6b c0 00	 imul	 rax, rax, 0
  0064b	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR pDEVBLK$[rsp]
  00653	c6 84 01 64 03
	00 00 80	 mov	 BYTE PTR [rcx+rax+868], 128 ; 00000080H

; 885  :             *pUnitStat        = CSW_CE | CSW_DE | CSW_UC;

  0065b	48 8b 84 24 c8
	00 00 00	 mov	 rax, QWORD PTR pUnitStat$[rsp]
  00663	c6 00 0e	 mov	 BYTE PTR [rax], 14

; 886  :             break;

  00666	e9 95 01 00 00	 jmp	 $LN14@LCS_Execut
$LN64@LCS_Execut:

; 887  :         }
; 888  : 
; 889  :         // Calculate residual byte count
; 890  :         iNum = ( sCount < pDEVBLK->numsense ) ?

  0066b	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR pDEVBLK$[rsp]
  00673	8b 80 60 03 00
	00		 mov	 eax, DWORD PTR [rax+864]
  00679	39 84 24 a0 00
	00 00		 cmp	 DWORD PTR sCount$[rsp], eax
  00680	73 0d		 jae	 SHORT $LN72@LCS_Execut
  00682	8b 84 24 a0 00
	00 00		 mov	 eax, DWORD PTR sCount$[rsp]
  00689	89 44 24 50	 mov	 DWORD PTR tv263[rsp], eax
  0068d	eb 12		 jmp	 SHORT $LN73@LCS_Execut
$LN72@LCS_Execut:
  0068f	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR pDEVBLK$[rsp]
  00697	8b 80 60 03 00
	00		 mov	 eax, DWORD PTR [rax+864]
  0069d	89 44 24 50	 mov	 DWORD PTR tv263[rsp], eax
$LN73@LCS_Execut:
  006a1	8b 44 24 50	 mov	 eax, DWORD PTR tv263[rsp]
  006a5	89 44 24 44	 mov	 DWORD PTR iNum$[rsp], eax

; 891  :             sCount : pDEVBLK->numsense;
; 892  : 
; 893  :         *pResidual = sCount - iNum;

  006a9	8b 44 24 44	 mov	 eax, DWORD PTR iNum$[rsp]
  006ad	8b 8c 24 a0 00
	00 00		 mov	 ecx, DWORD PTR sCount$[rsp]
  006b4	2b c8		 sub	 ecx, eax
  006b6	8b c1		 mov	 eax, ecx
  006b8	48 8b 8c 24 d0
	00 00 00	 mov	 rcx, QWORD PTR pResidual$[rsp]
  006c0	89 01		 mov	 DWORD PTR [rcx], eax

; 894  : 
; 895  :         if (sCount < pDEVBLK->numsense)

  006c2	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR pDEVBLK$[rsp]
  006ca	8b 80 60 03 00
	00		 mov	 eax, DWORD PTR [rax+864]
  006d0	39 84 24 a0 00
	00 00		 cmp	 DWORD PTR sCount$[rsp], eax
  006d7	73 0b		 jae	 SHORT $LN65@LCS_Execut

; 896  :             *pMore = 1;

  006d9	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR pMore$[rsp]
  006e1	c6 00 01	 mov	 BYTE PTR [rax], 1
$LN65@LCS_Execut:

; 897  : 
; 898  :         // Copy device sense bytes to channel I/O buffer
; 899  :         memcpy( pIOBuf, pDEVBLK->sense, iNum );

  006e4	48 63 44 24 44	 movsxd	 rax, DWORD PTR iNum$[rsp]
  006e9	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR pDEVBLK$[rsp]
  006f1	48 81 c1 64 03
	00 00		 add	 rcx, 868		; 00000364H
  006f8	48 8b bc 24 b8
	00 00 00	 mov	 rdi, QWORD PTR pIOBuf$[rsp]
  00700	48 8b f1	 mov	 rsi, rcx
  00703	48 8b c8	 mov	 rcx, rax
  00706	f3 a4		 rep movsb

; 900  : 
; 901  :         // Clear the device sense bytes
; 902  :         memset( pDEVBLK->sense, 0, sizeof( pDEVBLK->sense ) );

  00708	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR pDEVBLK$[rsp]
  00710	48 05 64 03 00
	00		 add	 rax, 868		; 00000364H
  00716	48 8b f8	 mov	 rdi, rax
  00719	33 c0		 xor	 eax, eax
  0071b	b9 00 01 00 00	 mov	 ecx, 256		; 00000100H
  00720	f3 aa		 rep stosb

; 903  : 
; 904  :         // Return unit status
; 905  :         *pUnitStat = CSW_CE | CSW_DE;

  00722	48 8b 84 24 c8
	00 00 00	 mov	 rax, QWORD PTR pUnitStat$[rsp]
  0072a	c6 00 0c	 mov	 BYTE PTR [rax], 12

; 906  : 
; 907  :         break;

  0072d	e9 ce 00 00 00	 jmp	 $LN14@LCS_Execut
$LN66@LCS_Execut:

; 908  : 
; 909  :     case 0xE4:  //  11100100  SID
; 910  :         // -----------------------------------------------------------
; 911  :         // SENSE ID
; 912  :         // -----------------------------------------------------------
; 913  : 
; 914  :         // Calculate residual byte count
; 915  :         iNum = ( sCount < pDEVBLK->numdevid ) ?

  00732	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR pDEVBLK$[rsp]
  0073a	8b 80 64 04 00
	00		 mov	 eax, DWORD PTR [rax+1124]
  00740	39 84 24 a0 00
	00 00		 cmp	 DWORD PTR sCount$[rsp], eax
  00747	73 0d		 jae	 SHORT $LN74@LCS_Execut
  00749	8b 84 24 a0 00
	00 00		 mov	 eax, DWORD PTR sCount$[rsp]
  00750	89 44 24 54	 mov	 DWORD PTR tv282[rsp], eax
  00754	eb 12		 jmp	 SHORT $LN75@LCS_Execut
$LN74@LCS_Execut:
  00756	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR pDEVBLK$[rsp]
  0075e	8b 80 64 04 00
	00		 mov	 eax, DWORD PTR [rax+1124]
  00764	89 44 24 54	 mov	 DWORD PTR tv282[rsp], eax
$LN75@LCS_Execut:
  00768	8b 44 24 54	 mov	 eax, DWORD PTR tv282[rsp]
  0076c	89 44 24 44	 mov	 DWORD PTR iNum$[rsp], eax

; 916  :             sCount : pDEVBLK->numdevid;
; 917  : 
; 918  :         *pResidual = sCount - iNum;

  00770	8b 44 24 44	 mov	 eax, DWORD PTR iNum$[rsp]
  00774	8b 8c 24 a0 00
	00 00		 mov	 ecx, DWORD PTR sCount$[rsp]
  0077b	2b c8		 sub	 ecx, eax
  0077d	8b c1		 mov	 eax, ecx
  0077f	48 8b 8c 24 d0
	00 00 00	 mov	 rcx, QWORD PTR pResidual$[rsp]
  00787	89 01		 mov	 DWORD PTR [rcx], eax

; 919  : 
; 920  :         if (sCount < pDEVBLK->numdevid)

  00789	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR pDEVBLK$[rsp]
  00791	8b 80 64 04 00
	00		 mov	 eax, DWORD PTR [rax+1124]
  00797	39 84 24 a0 00
	00 00		 cmp	 DWORD PTR sCount$[rsp], eax
  0079e	73 0b		 jae	 SHORT $LN67@LCS_Execut

; 921  :             *pMore = 1;

  007a0	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR pMore$[rsp]
  007a8	c6 00 01	 mov	 BYTE PTR [rax], 1
$LN67@LCS_Execut:

; 922  : 
; 923  :         // Copy device identifier bytes to channel I/O buffer
; 924  :         memcpy( pIOBuf, pDEVBLK->devid, iNum );

  007ab	48 63 44 24 44	 movsxd	 rax, DWORD PTR iNum$[rsp]
  007b0	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR pDEVBLK$[rsp]
  007b8	48 81 c1 68 04
	00 00		 add	 rcx, 1128		; 00000468H
  007bf	48 8b bc 24 b8
	00 00 00	 mov	 rdi, QWORD PTR pIOBuf$[rsp]
  007c7	48 8b f1	 mov	 rsi, rcx
  007ca	48 8b c8	 mov	 rcx, rax
  007cd	f3 a4		 rep movsb

; 925  : 
; 926  :         // Return unit status
; 927  :         *pUnitStat = CSW_CE | CSW_DE;

  007cf	48 8b 84 24 c8
	00 00 00	 mov	 rax, QWORD PTR pUnitStat$[rsp]
  007d7	c6 00 0c	 mov	 BYTE PTR [rax], 12

; 928  : 
; 929  :         break;

  007da	eb 24		 jmp	 SHORT $LN14@LCS_Execut
$LN68@LCS_Execut:

; 930  : 
; 931  :     default:
; 932  :         // ------------------------------------------------------------
; 933  :         // INVALID OPERATION
; 934  :         // ------------------------------------------------------------
; 935  : 
; 936  :         // Set command reject sense byte, and unit check status
; 937  :         pDEVBLK->sense[0] = SENSE_CR;

  007dc	b8 01 00 00 00	 mov	 eax, 1
  007e1	48 6b c0 00	 imul	 rax, rax, 0
  007e5	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR pDEVBLK$[rsp]
  007ed	c6 84 01 64 03
	00 00 80	 mov	 BYTE PTR [rcx+rax+868], 128 ; 00000080H

; 938  :         *pUnitStat        = CSW_CE | CSW_DE | CSW_UC;

  007f5	48 8b 84 24 c8
	00 00 00	 mov	 rax, QWORD PTR pUnitStat$[rsp]
  007fd	c6 00 0e	 mov	 BYTE PTR [rax], 14
$LN14@LCS_Execut:
$LN1@LCS_Execut:

; 939  :     }
; 940  : 
; 941  :     return;
; 942  : }

  00800	48 83 c4 68	 add	 rsp, 104		; 00000068H
  00804	5f		 pop	 rdi
  00805	5e		 pop	 rsi
  00806	c3		 ret	 0
  00807	90		 npad	 1
$LN77@LCS_Execut:
  00808	00 00 00 00	 DD	 $LN41@LCS_Execut
  0080c	00 00 00 00	 DD	 $LN46@LCS_Execut
  00810	00 00 00 00	 DD	 $LN54@LCS_Execut
  00814	00 00 00 00	 DD	 $LN63@LCS_Execut
  00818	00 00 00 00	 DD	 $LN50@LCS_Execut
  0081c	00 00 00 00	 DD	 $LN47@LCS_Execut
  00820	00 00 00 00	 DD	 $LN52@LCS_Execut
  00824	00 00 00 00	 DD	 $LN55@LCS_Execut
  00828	00 00 00 00	 DD	 $LN45@LCS_Execut
  0082c	00 00 00 00	 DD	 $LN57@LCS_Execut
  00830	00 00 00 00	 DD	 $LN62@LCS_Execut
  00834	00 00 00 00	 DD	 $LN66@LCS_Execut
  00838	00 00 00 00	 DD	 $LN68@LCS_Execut
$LN76@LCS_Execut:
  0083c	00		 DB	 0
  0083d	01		 DB	 1
  0083e	02		 DB	 2
  0083f	03		 DB	 3
  00840	0c		 DB	 12
  00841	0c		 DB	 12
  00842	04		 DB	 4
  00843	0c		 DB	 12
  00844	0c		 DB	 12
  00845	0c		 DB	 12
  00846	0c		 DB	 12
  00847	05		 DB	 5
  00848	0c		 DB	 12
  00849	0c		 DB	 12
  0084a	0c		 DB	 12
  0084b	0c		 DB	 12
  0084c	0c		 DB	 12
  0084d	0c		 DB	 12
  0084e	0c		 DB	 12
  0084f	06		 DB	 6
  00850	0c		 DB	 12
  00851	0c		 DB	 12
  00852	0c		 DB	 12
  00853	0c		 DB	 12
  00854	0c		 DB	 12
  00855	0c		 DB	 12
  00856	0c		 DB	 12
  00857	0c		 DB	 12
  00858	0c		 DB	 12
  00859	0c		 DB	 12
  0085a	0c		 DB	 12
  0085b	0c		 DB	 12
  0085c	0c		 DB	 12
  0085d	0c		 DB	 12
  0085e	0c		 DB	 12
  0085f	0c		 DB	 12
  00860	0c		 DB	 12
  00861	0c		 DB	 12
  00862	0c		 DB	 12
  00863	0c		 DB	 12
  00864	0c		 DB	 12
  00865	0c		 DB	 12
  00866	0c		 DB	 12
  00867	0c		 DB	 12
  00868	0c		 DB	 12
  00869	0c		 DB	 12
  0086a	0c		 DB	 12
  0086b	0c		 DB	 12
  0086c	0c		 DB	 12
  0086d	0c		 DB	 12
  0086e	0c		 DB	 12
  0086f	0c		 DB	 12
  00870	0c		 DB	 12
  00871	0c		 DB	 12
  00872	0c		 DB	 12
  00873	0c		 DB	 12
  00874	0c		 DB	 12
  00875	0c		 DB	 12
  00876	0c		 DB	 12
  00877	0c		 DB	 12
  00878	0c		 DB	 12
  00879	0c		 DB	 12
  0087a	0c		 DB	 12
  0087b	0c		 DB	 12
  0087c	0c		 DB	 12
  0087d	0c		 DB	 12
  0087e	07		 DB	 7
  0087f	0c		 DB	 12
  00880	0c		 DB	 12
  00881	0c		 DB	 12
  00882	0c		 DB	 12
  00883	0c		 DB	 12
  00884	0c		 DB	 12
  00885	0c		 DB	 12
  00886	0c		 DB	 12
  00887	0c		 DB	 12
  00888	0c		 DB	 12
  00889	0c		 DB	 12
  0088a	0c		 DB	 12
  0088b	0c		 DB	 12
  0088c	0c		 DB	 12
  0088d	0c		 DB	 12
  0088e	0c		 DB	 12
  0088f	0c		 DB	 12
  00890	0c		 DB	 12
  00891	0c		 DB	 12
  00892	0c		 DB	 12
  00893	0c		 DB	 12
  00894	0c		 DB	 12
  00895	0c		 DB	 12
  00896	0c		 DB	 12
  00897	0c		 DB	 12
  00898	0c		 DB	 12
  00899	0c		 DB	 12
  0089a	0c		 DB	 12
  0089b	0c		 DB	 12
  0089c	0c		 DB	 12
  0089d	0c		 DB	 12
  0089e	0c		 DB	 12
  0089f	0c		 DB	 12
  008a0	0c		 DB	 12
  008a1	0c		 DB	 12
  008a2	0c		 DB	 12
  008a3	0c		 DB	 12
  008a4	0c		 DB	 12
  008a5	0c		 DB	 12
  008a6	0c		 DB	 12
  008a7	0c		 DB	 12
  008a8	0c		 DB	 12
  008a9	0c		 DB	 12
  008aa	0c		 DB	 12
  008ab	0c		 DB	 12
  008ac	0c		 DB	 12
  008ad	0c		 DB	 12
  008ae	0c		 DB	 12
  008af	0c		 DB	 12
  008b0	0c		 DB	 12
  008b1	0c		 DB	 12
  008b2	0c		 DB	 12
  008b3	0c		 DB	 12
  008b4	0c		 DB	 12
  008b5	0c		 DB	 12
  008b6	0c		 DB	 12
  008b7	0c		 DB	 12
  008b8	0c		 DB	 12
  008b9	0c		 DB	 12
  008ba	0c		 DB	 12
  008bb	0c		 DB	 12
  008bc	08		 DB	 8
  008bd	0c		 DB	 12
  008be	0c		 DB	 12
  008bf	0c		 DB	 12
  008c0	0c		 DB	 12
  008c1	0c		 DB	 12
  008c2	0c		 DB	 12
  008c3	0c		 DB	 12
  008c4	0c		 DB	 12
  008c5	0c		 DB	 12
  008c6	0c		 DB	 12
  008c7	0c		 DB	 12
  008c8	0c		 DB	 12
  008c9	0c		 DB	 12
  008ca	0c		 DB	 12
  008cb	0c		 DB	 12
  008cc	0c		 DB	 12
  008cd	0c		 DB	 12
  008ce	0c		 DB	 12
  008cf	0c		 DB	 12
  008d0	0c		 DB	 12
  008d1	0c		 DB	 12
  008d2	0c		 DB	 12
  008d3	0c		 DB	 12
  008d4	0c		 DB	 12
  008d5	0c		 DB	 12
  008d6	0c		 DB	 12
  008d7	0c		 DB	 12
  008d8	0c		 DB	 12
  008d9	0c		 DB	 12
  008da	0c		 DB	 12
  008db	0c		 DB	 12
  008dc	0c		 DB	 12
  008dd	0c		 DB	 12
  008de	0c		 DB	 12
  008df	0c		 DB	 12
  008e0	0c		 DB	 12
  008e1	0c		 DB	 12
  008e2	0c		 DB	 12
  008e3	0c		 DB	 12
  008e4	0c		 DB	 12
  008e5	0c		 DB	 12
  008e6	0c		 DB	 12
  008e7	0c		 DB	 12
  008e8	0c		 DB	 12
  008e9	0c		 DB	 12
  008ea	0c		 DB	 12
  008eb	0c		 DB	 12
  008ec	0c		 DB	 12
  008ed	0c		 DB	 12
  008ee	0c		 DB	 12
  008ef	0c		 DB	 12
  008f0	0c		 DB	 12
  008f1	0c		 DB	 12
  008f2	0c		 DB	 12
  008f3	0c		 DB	 12
  008f4	0c		 DB	 12
  008f5	0c		 DB	 12
  008f6	0c		 DB	 12
  008f7	0c		 DB	 12
  008f8	0c		 DB	 12
  008f9	0c		 DB	 12
  008fa	0c		 DB	 12
  008fb	0c		 DB	 12
  008fc	0c		 DB	 12
  008fd	0c		 DB	 12
  008fe	09		 DB	 9
  008ff	0c		 DB	 12
  00900	0c		 DB	 12
  00901	0c		 DB	 12
  00902	0c		 DB	 12
  00903	0c		 DB	 12
  00904	0c		 DB	 12
  00905	0c		 DB	 12
  00906	0c		 DB	 12
  00907	0c		 DB	 12
  00908	0c		 DB	 12
  00909	0c		 DB	 12
  0090a	0c		 DB	 12
  0090b	0c		 DB	 12
  0090c	0c		 DB	 12
  0090d	0c		 DB	 12
  0090e	0c		 DB	 12
  0090f	0c		 DB	 12
  00910	0c		 DB	 12
  00911	0c		 DB	 12
  00912	0c		 DB	 12
  00913	0c		 DB	 12
  00914	0c		 DB	 12
  00915	0c		 DB	 12
  00916	0c		 DB	 12
  00917	0c		 DB	 12
  00918	0c		 DB	 12
  00919	0c		 DB	 12
  0091a	0c		 DB	 12
  0091b	0c		 DB	 12
  0091c	0c		 DB	 12
  0091d	0c		 DB	 12
  0091e	0a		 DB	 10
  0091f	0b		 DB	 11
LCS_ExecuteCCW ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\ctc_lcs.c
_TEXT	SEGMENT
pLCSDEV$ = 80
$T1 = 88
tv135 = 96
tv153 = 104
tv159 = 112
sType$ = 120
filename$ = 144
__$ArrayPad$ = 416
pDEVBLK$ = 448
ppszClass$ = 456
iBufLen$ = 464
pBuffer$ = 472
LCS_Query PROC

; 1194 : {

$LN16:
  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	48 81 ec b8 01
	00 00		 sub	 rsp, 440		; 000001b8H
  0001b	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00022	48 33 c4	 xor	 rax, rsp
  00025	48 89 84 24 a0
	01 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 1195 :     char filename[ PATH_MAX + 1 ];      /* full path or just name    */
; 1196 : 
; 1197 :     char *sType[] = { "", " Pri", " Sec" };

  0002d	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG170274
  00034	48 89 44 24 78	 mov	 QWORD PTR sType$[rsp], rax
  00039	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG170276
  00040	48 89 84 24 80
	00 00 00	 mov	 QWORD PTR sType$[rsp+8], rax
  00048	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG170278
  0004f	48 89 84 24 88
	00 00 00	 mov	 QWORD PTR sType$[rsp+16], rax

; 1198 : 
; 1199 :     PLCSDEV  pLCSDEV;
; 1200 : 
; 1201 :     BEGIN_DEVICE_CLASS_QUERY( "CTCA", pDEVBLK, ppszClass, iBufLen, pBuffer );

  00057	48 83 bc 24 c8
	01 00 00 00	 cmp	 QWORD PTR ppszClass$[rsp], 0
  00060	74 12		 je	 SHORT $LN2@LCS_Query
  00062	48 8b 84 24 c8
	01 00 00	 mov	 rax, QWORD PTR ppszClass$[rsp]
  0006a	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170280
  00071	48 89 08	 mov	 QWORD PTR [rax], rcx
$LN2@LCS_Query:
  00074	48 83 bc 24 c0
	01 00 00 00	 cmp	 QWORD PTR pDEVBLK$[rsp], 0
  0007d	74 20		 je	 SHORT $LN4@LCS_Query
  0007f	48 83 bc 24 c8
	01 00 00 00	 cmp	 QWORD PTR ppszClass$[rsp], 0
  00088	74 15		 je	 SHORT $LN4@LCS_Query
  0008a	83 bc 24 d0 01
	00 00 00	 cmp	 DWORD PTR iBufLen$[rsp], 0
  00092	74 0b		 je	 SHORT $LN4@LCS_Query
  00094	48 83 bc 24 d8
	01 00 00 00	 cmp	 QWORD PTR pBuffer$[rsp], 0
  0009d	75 05		 jne	 SHORT $LN3@LCS_Query
$LN4@LCS_Query:
  0009f	e9 de 01 00 00	 jmp	 $LN1@LCS_Query
$LN3@LCS_Query:
  000a4	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  000ab	8b 80 94 12 00
	00		 mov	 eax, DWORD PTR [rax+4756]
  000b1	c1 e8 1a	 shr	 eax, 26
  000b4	83 e0 01	 and	 eax, 1
  000b7	85 c0		 test	 eax, eax
  000b9	74 75		 je	 SHORT $LN5@LCS_Query
  000bb	48 8b 84 24 c0
	01 00 00	 mov	 rax, QWORD PTR pDEVBLK$[rsp]
  000c3	48 05 a4 00 00
	00		 add	 rax, 164		; 000000a4H
  000c9	48 8b c8	 mov	 rcx, rax
  000cc	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_basename
  000d2	41 b8 05 01 00
	00		 mov	 r8d, 261		; 00000105H
  000d8	48 8b d0	 mov	 rdx, rax
  000db	48 8d 8c 24 90
	00 00 00	 lea	 rcx, QWORD PTR filename$[rsp]
  000e3	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_strlcpy
  000e9	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG170286
  000f0	48 8d 8c 24 90
	00 00 00	 lea	 rcx, QWORD PTR filename$[rsp]
  000f8	e8 00 00 00 00	 call	 strcmp
  000fd	85 c0		 test	 eax, eax
  000ff	75 2d		 jne	 SHORT $LN7@LCS_Query
  00101	b8 01 00 00 00	 mov	 eax, 1
  00106	48 6b c0 00	 imul	 rax, rax, 0
  0010a	48 89 44 24 58	 mov	 QWORD PTR $T1[rsp], rax
  0010f	48 81 7c 24 58
	05 01 00 00	 cmp	 QWORD PTR $T1[rsp], 261	; 00000105H
  00118	73 02		 jae	 SHORT $LN10@LCS_Query
  0011a	eb 05		 jmp	 SHORT $LN11@LCS_Query
$LN10@LCS_Query:
  0011c	e8 00 00 00 00	 call	 __report_rangecheckfailure
$LN11@LCS_Query:
  00121	48 8b 44 24 58	 mov	 rax, QWORD PTR $T1[rsp]
  00126	c6 84 04 90 00
	00 00 00	 mov	 BYTE PTR filename$[rsp+rax], 0
$LN7@LCS_Query:
  0012e	eb 25		 jmp	 SHORT $LN6@LCS_Query
$LN5@LCS_Query:
  00130	48 8b 84 24 c0
	01 00 00	 mov	 rax, QWORD PTR pDEVBLK$[rsp]
  00138	48 05 a4 00 00
	00		 add	 rax, 164		; 000000a4H
  0013e	41 b8 05 01 00
	00		 mov	 r8d, 261		; 00000105H
  00144	48 8b d0	 mov	 rdx, rax
  00147	48 8d 8c 24 90
	00 00 00	 lea	 rcx, QWORD PTR filename$[rsp]
  0014f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_strlcpy
$LN6@LCS_Query:

; 1202 : 
; 1203 :     pLCSDEV = (PLCSDEV) pDEVBLK->dev_data;

  00155	48 8b 84 24 c0
	01 00 00	 mov	 rax, QWORD PTR pDEVBLK$[rsp]
  0015d	48 8b 80 08 06
	00 00		 mov	 rax, QWORD PTR [rax+1544]
  00164	48 89 44 24 50	 mov	 QWORD PTR pLCSDEV$[rsp], rax

; 1204 : 
; 1205 :     if (!pLCSDEV)

  00169	48 83 7c 24 50
	00		 cmp	 QWORD PTR pLCSDEV$[rsp], 0
  0016f	75 25		 jne	 SHORT $LN8@LCS_Query

; 1206 :     {
; 1207 :         strlcpy(pBuffer,"*Uninitialized",iBufLen);

  00171	48 63 84 24 d0
	01 00 00	 movsxd	 rax, DWORD PTR iBufLen$[rsp]
  00179	4c 8b c0	 mov	 r8, rax
  0017c	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG170288
  00183	48 8b 8c 24 d8
	01 00 00	 mov	 rcx, QWORD PTR pBuffer$[rsp]
  0018b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_strlcpy

; 1208 :         return;

  00191	e9 ec 00 00 00	 jmp	 $LN1@LCS_Query
$LN8@LCS_Query:

; 1209 :     }
; 1210 : 
; 1211 :     snprintf( pBuffer, iBufLen, "LCS Port %2.2X %s%s (%s)%s IO[%"PRIu64"]",

  00196	48 8b 44 24 50	 mov	 rax, QWORD PTR pLCSDEV$[rsp]
  0019b	48 8b 40 08	 mov	 rax, QWORD PTR [rax+8]
  0019f	8b 40 18	 mov	 eax, DWORD PTR [rax+24]
  001a2	83 e0 01	 and	 eax, 1
  001a5	85 c0		 test	 eax, eax
  001a7	74 0e		 je	 SHORT $LN12@LCS_Query
  001a9	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG170289
  001b0	48 89 44 24 60	 mov	 QWORD PTR tv135[rsp], rax
  001b5	eb 0c		 jmp	 SHORT $LN13@LCS_Query
$LN12@LCS_Query:
  001b7	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG170290
  001be	48 89 44 24 60	 mov	 QWORD PTR tv135[rsp], rax
$LN13@LCS_Query:
  001c3	48 8b 44 24 50	 mov	 rax, QWORD PTR pLCSDEV$[rsp]
  001c8	0f b6 40 22	 movzx	 eax, BYTE PTR [rax+34]
  001cc	83 f8 01	 cmp	 eax, 1
  001cf	75 0e		 jne	 SHORT $LN14@LCS_Query
  001d1	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG170291
  001d8	48 89 44 24 68	 mov	 QWORD PTR tv153[rsp], rax
  001dd	eb 0c		 jmp	 SHORT $LN15@LCS_Query
$LN14@LCS_Query:
  001df	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG170292
  001e6	48 89 44 24 68	 mov	 QWORD PTR tv153[rsp], rax
$LN15@LCS_Query:
  001eb	48 8b 44 24 50	 mov	 rax, QWORD PTR pLCSDEV$[rsp]
  001f0	48 8b 40 08	 mov	 rax, QWORD PTR [rax+8]
  001f4	48 8b 4c 24 50	 mov	 rcx, QWORD PTR pLCSDEV$[rsp]
  001f9	0f b6 49 23	 movzx	 ecx, BYTE PTR [rcx+35]
  001fd	48 69 c9 98 01
	00 00		 imul	 rcx, rcx, 408		; 00000198H
  00204	48 8d 84 08 a8
	01 00 00	 lea	 rax, QWORD PTR [rax+rcx+424]
  0020c	48 8b 4c 24 50	 mov	 rcx, QWORD PTR pLCSDEV$[rsp]
  00211	0f b6 49 24	 movzx	 ecx, BYTE PTR [rcx+36]
  00215	48 8b 54 24 50	 mov	 rdx, QWORD PTR pLCSDEV$[rsp]
  0021a	0f b6 52 23	 movzx	 edx, BYTE PTR [rdx+35]
  0021e	4c 63 84 24 d0
	01 00 00	 movsxd	 r8, DWORD PTR iBufLen$[rsp]
  00226	4c 89 44 24 70	 mov	 QWORD PTR tv159[rsp], r8
  0022b	4c 8b 8c 24 c0
	01 00 00	 mov	 r9, QWORD PTR pDEVBLK$[rsp]
  00233	4d 8b 89 00 06
	00 00		 mov	 r9, QWORD PTR [r9+1536]
  0023a	4c 89 4c 24 40	 mov	 QWORD PTR [rsp+64], r9
  0023f	4c 8b 4c 24 60	 mov	 r9, QWORD PTR tv135[rsp]
  00244	4c 89 4c 24 38	 mov	 QWORD PTR [rsp+56], r9
  00249	48 89 44 24 30	 mov	 QWORD PTR [rsp+48], rax
  0024e	48 8b 44 cc 78	 mov	 rax, QWORD PTR sType$[rsp+rcx*8]
  00253	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  00258	48 8b 44 24 68	 mov	 rax, QWORD PTR tv153[rsp]
  0025d	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00262	44 8b ca	 mov	 r9d, edx
  00265	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG170293
  0026c	48 8b 44 24 70	 mov	 rax, QWORD PTR tv159[rsp]
  00271	48 8b d0	 mov	 rdx, rax
  00274	48 8b 8c 24 d8
	01 00 00	 mov	 rcx, QWORD PTR pBuffer$[rsp]
  0027c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_snprintf
$LN1@LCS_Query:
$LN9@LCS_Query:

; 1212 :               pLCSDEV->bPort,
; 1213 :               pLCSDEV->bMode == LCSDEV_MODE_IP ? "IP" : "SNA",
; 1214 :               sType[pLCSDEV->bType],
; 1215 :               pLCSDEV->pLCSBLK->Port[pLCSDEV->bPort].szNetIfName,
; 1216 :               pLCSDEV->pLCSBLK->fDebug ? " -d" : "",
; 1217 :               pDEVBLK->excps );
; 1218 : }

  00282	48 8b 8c 24 a0
	01 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  0028a	48 33 cc	 xor	 rcx, rsp
  0028d	e8 00 00 00 00	 call	 __security_check_cookie
  00292	48 81 c4 b8 01
	00 00		 add	 rsp, 440		; 000001b8H
  00299	c3		 ret	 0
LCS_Query ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\ctc_lcs.c
_TEXT	SEGMENT
pLCSPORT$ = 80
pLCSBLK$ = 88
pLCSDEV$ = 96
pCurrLCSDev$1 = 104
tid$2 = 112
tid$3 = 116
tv194 = 120
tv197 = 124
tv201 = 128
ppPrevLCSDev$4 = 136
pDEVBLK$ = 160
LCS_Close PROC

; 1035 : {

$LN116:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 81 ec 98 00
	00 00		 sub	 rsp, 152		; 00000098H

; 1036 :     PLCSDEV     pLCSDEV;
; 1037 :     PLCSBLK     pLCSBLK;
; 1038 :     PLCSPORT    pLCSPORT;
; 1039 : 
; 1040 :     pLCSDEV = (PLCSDEV)pDEVBLK->dev_data;

  0000c	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR pDEVBLK$[rsp]
  00014	48 8b 80 08 06
	00 00		 mov	 rax, QWORD PTR [rax+1544]
  0001b	48 89 44 24 60	 mov	 QWORD PTR pLCSDEV$[rsp], rax

; 1041 :     if (!pLCSDEV) return 0;  // (was incomplete group)

  00020	48 83 7c 24 60
	00		 cmp	 QWORD PTR pLCSDEV$[rsp], 0
  00026	75 07		 jne	 SHORT $LN74@LCS_Close
  00028	33 c0		 xor	 eax, eax
  0002a	e9 49 0d 00 00	 jmp	 $LN1@LCS_Close
$LN74@LCS_Close:

; 1042 : 
; 1043 :     pLCSBLK  = pLCSDEV->pLCSBLK;

  0002f	48 8b 44 24 60	 mov	 rax, QWORD PTR pLCSDEV$[rsp]
  00034	48 8b 40 08	 mov	 rax, QWORD PTR [rax+8]
  00038	48 89 44 24 58	 mov	 QWORD PTR pLCSBLK$[rsp], rax

; 1044 :     pLCSPORT = &pLCSBLK->Port[pLCSDEV->bPort];

  0003d	48 8b 44 24 60	 mov	 rax, QWORD PTR pLCSDEV$[rsp]
  00042	0f b6 40 23	 movzx	 eax, BYTE PTR [rax+35]
  00046	48 69 c0 98 01
	00 00		 imul	 rax, rax, 408		; 00000198H
  0004d	48 8b 4c 24 58	 mov	 rcx, QWORD PTR pLCSBLK$[rsp]
  00052	48 8d 44 01 60	 lea	 rax, QWORD PTR [rcx+rax+96]
  00057	48 89 44 24 50	 mov	 QWORD PTR pLCSPORT$[rsp], rax

; 1045 : 
; 1046 :     pLCSPORT->icDevices--;

  0005c	48 8b 44 24 50	 mov	 rax, QWORD PTR pLCSPORT$[rsp]
  00061	8b 80 44 01 00
	00		 mov	 eax, DWORD PTR [rax+324]
  00067	ff c8		 dec	 eax
  00069	48 8b 4c 24 50	 mov	 rcx, QWORD PTR pLCSPORT$[rsp]
  0006e	89 81 44 01 00
	00		 mov	 DWORD PTR [rcx+324], eax
$LN4@LCS_Close:

; 1047 : 
; 1048 :     PTT_DEBUG( "CLOSE: ENTRY      ", 000, pDEVBLK->devnum, pLCSPORT->bPort );

  00074	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_pttclass
  0007b	48 8b 00	 mov	 rax, QWORD PTR [rax]
  0007e	48 25 00 00 02
	00		 and	 rax, 131072		; 00020000H
  00084	48 85 c0	 test	 rax, rax
  00087	74 46		 je	 SHORT $LN75@LCS_Close
  00089	48 8b 44 24 50	 mov	 rax, QWORD PTR pLCSPORT$[rsp]
  0008e	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  00091	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR pDEVBLK$[rsp]
  00099	0f b7 49 48	 movzx	 ecx, WORD PTR [rcx+72]
  0009d	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR [rsp+48], 0
  000a6	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  000ab	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG170160
  000b2	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  000b7	44 8b c9	 mov	 r9d, ecx
  000ba	45 33 c0	 xor	 r8d, r8d
  000bd	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG170161
  000c4	b9 00 00 02 00	 mov	 ecx, 131072		; 00020000H
  000c9	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ptt_pthread_trace
$LN75@LCS_Close:
  000cf	33 c0		 xor	 eax, eax
  000d1	85 c0		 test	 eax, eax
  000d3	75 9f		 jne	 SHORT $LN4@LCS_Close

; 1049 : 
; 1050 :     // Is this the last device on the port?
; 1051 :     if (!pLCSPORT->icDevices)

  000d5	48 8b 44 24 50	 mov	 rax, QWORD PTR pLCSPORT$[rsp]
  000da	83 b8 44 01 00
	00 00		 cmp	 DWORD PTR [rax+324], 0
  000e1	0f 85 51 06 00
	00		 jne	 $LN76@LCS_Close
$LN7@LCS_Close:

; 1052 :     {
; 1053 :         PTT_DEBUG( "CLOSE: is last    ", 000, pDEVBLK->devnum, pLCSPORT->bPort );

  000e7	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_pttclass
  000ee	48 8b 00	 mov	 rax, QWORD PTR [rax]
  000f1	48 25 00 00 02
	00		 and	 rax, 131072		; 00020000H
  000f7	48 85 c0	 test	 rax, rax
  000fa	74 46		 je	 SHORT $LN78@LCS_Close
  000fc	48 8b 44 24 50	 mov	 rax, QWORD PTR pLCSPORT$[rsp]
  00101	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  00104	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR pDEVBLK$[rsp]
  0010c	0f b7 49 48	 movzx	 ecx, WORD PTR [rcx+72]
  00110	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR [rsp+48], 0
  00119	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  0011e	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG170165
  00125	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  0012a	44 8b c9	 mov	 r9d, ecx
  0012d	45 33 c0	 xor	 r8d, r8d
  00130	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG170166
  00137	b9 00 00 02 00	 mov	 ecx, 131072		; 00020000H
  0013c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ptt_pthread_trace
$LN78@LCS_Close:
  00142	33 c0		 xor	 eax, eax
  00144	85 c0		 test	 eax, eax
  00146	75 9f		 jne	 SHORT $LN7@LCS_Close

; 1054 : 
; 1055 :         // PROGRAMMING NOTE: there's currently no way to interrupt
; 1056 :         // the "LCS_PortThread"s TUNTAP_Read of the adapter. Thus
; 1057 :         // we must simply wait for LCS_PortThread to eventually
; 1058 :         // notice that we're doing a close (via our setting of the
; 1059 :         // fCloseInProgress flag). Its TUNTAP_Read will eventually
; 1060 :         // timeout after a few seconds (currently 5, which is dif-
; 1061 :         // ferent than the DEF_NET_READ_TIMEOUT_SECS timeout value
; 1062 :         // CTCI_Read function uses) and will then do the close of
; 1063 :         // the adapter for us (TUNTAP_Close) so we don't have to.
; 1064 :         // All we need to do is ask it to exit (via our setting of
; 1065 :         // the fCloseInProgress flag) and then wait for it to exit
; 1066 :         // (which, as stated, could take up to a max of 5 seconds).
; 1067 : 
; 1068 :         // All of this is simply because it's poor form to close a
; 1069 :         // device from one thread while another thread is reading
; 1070 :         // from it. Attempting to do so could trip a race condition
; 1071 :         // wherein the internal i/o buffers used to process the
; 1072 :         // read request could have been freed (by the close call)
; 1073 :         // by the time the read request eventually gets serviced.
; 1074 : 
; 1075 :         if (pLCSPORT->fd >= 0)

  00148	48 8b 44 24 50	 mov	 rax, QWORD PTR pLCSPORT$[rsp]
  0014d	83 b8 38 01 00
	00 00		 cmp	 DWORD PTR [rax+312], 0
  00154	0f 8c dd 04 00
	00		 jl	 $LN79@LCS_Close

; 1076 :         {
; 1077 :             TID tid = pLCSPORT->tid;

  0015a	48 8b 44 24 50	 mov	 rax, QWORD PTR pLCSPORT$[rsp]
  0015f	8b 80 3c 01 00
	00		 mov	 eax, DWORD PTR [rax+316]
  00165	89 44 24 70	 mov	 DWORD PTR tid$2[rsp], eax
$LN10@LCS_Close:

; 1078 :             PTT_DEBUG( "CLOSE: closing... ", 000, pDEVBLK->devnum, pLCSPORT->bPort );

  00169	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_pttclass
  00170	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00173	48 25 00 00 02
	00		 and	 rax, 131072		; 00020000H
  00179	48 85 c0	 test	 rax, rax
  0017c	74 46		 je	 SHORT $LN80@LCS_Close
  0017e	48 8b 44 24 50	 mov	 rax, QWORD PTR pLCSPORT$[rsp]
  00183	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  00186	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR pDEVBLK$[rsp]
  0018e	0f b7 49 48	 movzx	 ecx, WORD PTR [rcx+72]
  00192	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR [rsp+48], 0
  0019b	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  001a0	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG170169
  001a7	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  001ac	44 8b c9	 mov	 r9d, ecx
  001af	45 33 c0	 xor	 r8d, r8d
  001b2	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG170170
  001b9	b9 00 00 02 00	 mov	 ecx, 131072		; 00020000H
  001be	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ptt_pthread_trace
$LN80@LCS_Close:
  001c4	33 c0		 xor	 eax, eax
  001c6	85 c0		 test	 eax, eax
  001c8	75 9f		 jne	 SHORT $LN10@LCS_Close
$LN13@LCS_Close:

; 1079 :             PTT_DEBUG(        "GET  PortEventLock", 000, pDEVBLK->devnum, pLCSPORT->bPort );

  001ca	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_pttclass
  001d1	48 8b 00	 mov	 rax, QWORD PTR [rax]
  001d4	48 25 00 00 02
	00		 and	 rax, 131072		; 00020000H
  001da	48 85 c0	 test	 rax, rax
  001dd	74 46		 je	 SHORT $LN81@LCS_Close
  001df	48 8b 44 24 50	 mov	 rax, QWORD PTR pLCSPORT$[rsp]
  001e4	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  001e7	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR pDEVBLK$[rsp]
  001ef	0f b7 49 48	 movzx	 ecx, WORD PTR [rcx+72]
  001f3	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR [rsp+48], 0
  001fc	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  00201	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG170172
  00208	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  0020d	44 8b c9	 mov	 r9d, ecx
  00210	45 33 c0	 xor	 r8d, r8d
  00213	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG170173
  0021a	b9 00 00 02 00	 mov	 ecx, 131072		; 00020000H
  0021f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ptt_pthread_trace
$LN81@LCS_Close:
  00225	33 c0		 xor	 eax, eax
  00227	85 c0		 test	 eax, eax
  00229	75 9f		 jne	 SHORT $LN13@LCS_Close

; 1080 :             obtain_lock( &pLCSPORT->PortEventLock );

  0022b	48 8b 44 24 50	 mov	 rax, QWORD PTR pLCSPORT$[rsp]
  00230	48 05 24 01 00
	00		 add	 rax, 292		; 00000124H
  00236	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG170174
  0023d	48 8b c8	 mov	 rcx, rax
  00240	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_obtain_lock
$LN16@LCS_Close:

; 1081 :             PTT_DEBUG(        "GOT  PortEventLock", 000, pDEVBLK->devnum, pLCSPORT->bPort );

  00246	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_pttclass
  0024d	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00250	48 25 00 00 02
	00		 and	 rax, 131072		; 00020000H
  00256	48 85 c0	 test	 rax, rax
  00259	74 46		 je	 SHORT $LN82@LCS_Close
  0025b	48 8b 44 24 50	 mov	 rax, QWORD PTR pLCSPORT$[rsp]
  00260	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  00263	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR pDEVBLK$[rsp]
  0026b	0f b7 49 48	 movzx	 ecx, WORD PTR [rcx+72]
  0026f	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR [rsp+48], 0
  00278	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  0027d	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG170176
  00284	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00289	44 8b c9	 mov	 r9d, ecx
  0028c	45 33 c0	 xor	 r8d, r8d
  0028f	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG170177
  00296	b9 00 00 02 00	 mov	 ecx, 131072		; 00020000H
  0029b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ptt_pthread_trace
$LN82@LCS_Close:
  002a1	33 c0		 xor	 eax, eax
  002a3	85 c0		 test	 eax, eax
  002a5	75 9f		 jne	 SHORT $LN16@LCS_Close

; 1082 :             {
; 1083 :                 if (pDEVBLK->ccwtrace || pLCSBLK->fDebug)

  002a7	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR pDEVBLK$[rsp]
  002af	8b 80 f8 05 00
	00		 mov	 eax, DWORD PTR [rax+1528]
  002b5	c1 e8 0f	 shr	 eax, 15
  002b8	83 e0 01	 and	 eax, 1
  002bb	85 c0		 test	 eax, eax
  002bd	75 13		 jne	 SHORT $LN84@LCS_Close
  002bf	48 8b 44 24 58	 mov	 rax, QWORD PTR pLCSBLK$[rsp]
  002c4	8b 40 18	 mov	 eax, DWORD PTR [rax+24]
  002c7	83 e0 01	 and	 eax, 1
  002ca	85 c0		 test	 eax, eax
  002cc	0f 84 93 00 00
	00		 je	 $LN83@LCS_Close
$LN84@LCS_Close:

; 1084 :                     // "%1d:%04X CTC: lcs triggering port %2.2X event"
; 1085 :                     WRMSG( HHC00966, "I", SSID_TO_LCSS( pDEVBLK->ssid ), pDEVBLK->devnum, pLCSPORT->bPort );

  002d2	48 8b 44 24 50	 mov	 rax, QWORD PTR pLCSPORT$[rsp]
  002d7	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  002da	89 44 24 78	 mov	 DWORD PTR tv194[rsp], eax
  002de	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR pDEVBLK$[rsp]
  002e6	0f b7 49 48	 movzx	 ecx, WORD PTR [rcx+72]
  002ea	89 4c 24 7c	 mov	 DWORD PTR tv197[rsp], ecx
  002ee	48 8b 94 24 a0
	00 00 00	 mov	 rdx, QWORD PTR pDEVBLK$[rsp]
  002f6	0f b7 52 44	 movzx	 edx, WORD PTR [rdx+68]
  002fa	d1 fa		 sar	 edx, 1
  002fc	89 94 24 80 00
	00 00		 mov	 DWORD PTR tv201[rsp], edx
  00303	b9 01 00 00 00	 mov	 ecx, 1
  00308	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  0030e	8b 4c 24 78	 mov	 ecx, DWORD PTR tv194[rsp]
  00312	89 4c 24 48	 mov	 DWORD PTR [rsp+72], ecx
  00316	8b 4c 24 7c	 mov	 ecx, DWORD PTR tv197[rsp]
  0031a	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  0031e	8b 8c 24 80 00
	00 00		 mov	 ecx, DWORD PTR tv201[rsp]
  00325	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  00329	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170180
  00330	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  00335	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170181
  0033c	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00341	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00346	41 b9 03 00 00
	00		 mov	 r9d, 3
  0034c	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG170182
  00353	ba 3d 04 00 00	 mov	 edx, 1085		; 0000043dH
  00358	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170183
  0035f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg
$LN83@LCS_Close:
$LN19@LCS_Close:

; 1086 : 
; 1087 :                 PTT_DEBUG( "CLOSING started=NO", 000, pDEVBLK->devnum, pLCSPORT->bPort );

  00365	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_pttclass
  0036c	48 8b 00	 mov	 rax, QWORD PTR [rax]
  0036f	48 25 00 00 02
	00		 and	 rax, 131072		; 00020000H
  00375	48 85 c0	 test	 rax, rax
  00378	74 46		 je	 SHORT $LN85@LCS_Close
  0037a	48 8b 44 24 50	 mov	 rax, QWORD PTR pLCSPORT$[rsp]
  0037f	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  00382	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR pDEVBLK$[rsp]
  0038a	0f b7 49 48	 movzx	 ecx, WORD PTR [rcx+72]
  0038e	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR [rsp+48], 0
  00397	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  0039c	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG170185
  003a3	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  003a8	44 8b c9	 mov	 r9d, ecx
  003ab	45 33 c0	 xor	 r8d, r8d
  003ae	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG170186
  003b5	b9 00 00 02 00	 mov	 ecx, 131072		; 00020000H
  003ba	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ptt_pthread_trace
$LN85@LCS_Close:
  003c0	33 c0		 xor	 eax, eax
  003c2	85 c0		 test	 eax, eax
  003c4	75 9f		 jne	 SHORT $LN19@LCS_Close

; 1088 :                 pLCSPORT->fPortStarted = 0;

  003c6	48 8b 44 24 50	 mov	 rax, QWORD PTR pLCSPORT$[rsp]
  003cb	8b 80 34 01 00
	00		 mov	 eax, DWORD PTR [rax+308]
  003d1	83 e0 f7	 and	 eax, -9			; fffffff7H
  003d4	48 8b 4c 24 50	 mov	 rcx, QWORD PTR pLCSPORT$[rsp]
  003d9	89 81 34 01 00
	00		 mov	 DWORD PTR [rcx+308], eax
$LN22@LCS_Close:

; 1089 :                 PTT_DEBUG( "SET  closeInProg  ", 000, pDEVBLK->devnum, pLCSPORT->bPort );

  003df	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_pttclass
  003e6	48 8b 00	 mov	 rax, QWORD PTR [rax]
  003e9	48 25 00 00 02
	00		 and	 rax, 131072		; 00020000H
  003ef	48 85 c0	 test	 rax, rax
  003f2	74 46		 je	 SHORT $LN86@LCS_Close
  003f4	48 8b 44 24 50	 mov	 rax, QWORD PTR pLCSPORT$[rsp]
  003f9	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  003fc	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR pDEVBLK$[rsp]
  00404	0f b7 49 48	 movzx	 ecx, WORD PTR [rcx+72]
  00408	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR [rsp+48], 0
  00411	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  00416	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG170188
  0041d	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00422	44 8b c9	 mov	 r9d, ecx
  00425	45 33 c0	 xor	 r8d, r8d
  00428	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG170189
  0042f	b9 00 00 02 00	 mov	 ecx, 131072		; 00020000H
  00434	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ptt_pthread_trace
$LN86@LCS_Close:
  0043a	33 c0		 xor	 eax, eax
  0043c	85 c0		 test	 eax, eax
  0043e	75 9f		 jne	 SHORT $LN22@LCS_Close

; 1090 :                 pLCSPORT->fCloseInProgress = 1;

  00440	48 8b 44 24 50	 mov	 rax, QWORD PTR pLCSPORT$[rsp]
  00445	8b 80 34 01 00
	00		 mov	 eax, DWORD PTR [rax+308]
  0044b	83 c8 20	 or	 eax, 32			; 00000020H
  0044e	48 8b 4c 24 50	 mov	 rcx, QWORD PTR pLCSPORT$[rsp]
  00453	89 81 34 01 00
	00		 mov	 DWORD PTR [rcx+308], eax
$LN25@LCS_Close:

; 1091 :                 PTT_DEBUG(             "SIG  PortEvent    ", 000, pDEVBLK->devnum, pLCSPORT->bPort );

  00459	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_pttclass
  00460	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00463	48 25 00 00 02
	00		 and	 rax, 131072		; 00020000H
  00469	48 85 c0	 test	 rax, rax
  0046c	74 46		 je	 SHORT $LN87@LCS_Close
  0046e	48 8b 44 24 50	 mov	 rax, QWORD PTR pLCSPORT$[rsp]
  00473	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  00476	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR pDEVBLK$[rsp]
  0047e	0f b7 49 48	 movzx	 ecx, WORD PTR [rcx+72]
  00482	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR [rsp+48], 0
  0048b	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  00490	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG170191
  00497	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  0049c	44 8b c9	 mov	 r9d, ecx
  0049f	45 33 c0	 xor	 r8d, r8d
  004a2	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG170192
  004a9	b9 00 00 02 00	 mov	 ecx, 131072		; 00020000H
  004ae	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ptt_pthread_trace
$LN87@LCS_Close:
  004b4	33 c0		 xor	 eax, eax
  004b6	85 c0		 test	 eax, eax
  004b8	75 9f		 jne	 SHORT $LN25@LCS_Close

; 1092 :                 signal_condition( &pLCSPORT->PortEvent );

  004ba	48 8b 44 24 50	 mov	 rax, QWORD PTR pLCSPORT$[rsp]
  004bf	48 05 2c 01 00
	00		 add	 rax, 300		; 0000012cH
  004c5	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG170193
  004cc	48 8b c8	 mov	 rcx, rax
  004cf	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_signal_condition
$LN28@LCS_Close:

; 1093 :             }
; 1094 :             PTT_DEBUG(         "REL  PortEventLock", 000, pDEVBLK->devnum, pLCSPORT->bPort );

  004d5	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_pttclass
  004dc	48 8b 00	 mov	 rax, QWORD PTR [rax]
  004df	48 25 00 00 02
	00		 and	 rax, 131072		; 00020000H
  004e5	48 85 c0	 test	 rax, rax
  004e8	74 46		 je	 SHORT $LN88@LCS_Close
  004ea	48 8b 44 24 50	 mov	 rax, QWORD PTR pLCSPORT$[rsp]
  004ef	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  004f2	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR pDEVBLK$[rsp]
  004fa	0f b7 49 48	 movzx	 ecx, WORD PTR [rcx+72]
  004fe	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR [rsp+48], 0
  00507	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  0050c	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG170195
  00513	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00518	44 8b c9	 mov	 r9d, ecx
  0051b	45 33 c0	 xor	 r8d, r8d
  0051e	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG170196
  00525	b9 00 00 02 00	 mov	 ecx, 131072		; 00020000H
  0052a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ptt_pthread_trace
$LN88@LCS_Close:
  00530	33 c0		 xor	 eax, eax
  00532	85 c0		 test	 eax, eax
  00534	75 9f		 jne	 SHORT $LN28@LCS_Close

; 1095 :             release_lock( &pLCSPORT->PortEventLock );

  00536	48 8b 44 24 50	 mov	 rax, QWORD PTR pLCSPORT$[rsp]
  0053b	48 05 24 01 00
	00		 add	 rax, 292		; 00000124H
  00541	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG170197
  00548	48 8b c8	 mov	 rcx, rax
  0054b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_release_lock
$LN31@LCS_Close:

; 1096 :             PTT_DEBUG( "join_thread       ", 000, pDEVBLK->devnum, pLCSPORT->bPort );

  00551	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_pttclass
  00558	48 8b 00	 mov	 rax, QWORD PTR [rax]
  0055b	48 25 00 00 02
	00		 and	 rax, 131072		; 00020000H
  00561	48 85 c0	 test	 rax, rax
  00564	74 46		 je	 SHORT $LN89@LCS_Close
  00566	48 8b 44 24 50	 mov	 rax, QWORD PTR pLCSPORT$[rsp]
  0056b	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  0056e	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR pDEVBLK$[rsp]
  00576	0f b7 49 48	 movzx	 ecx, WORD PTR [rcx+72]
  0057a	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR [rsp+48], 0
  00583	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  00588	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG170199
  0058f	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00594	44 8b c9	 mov	 r9d, ecx
  00597	45 33 c0	 xor	 r8d, r8d
  0059a	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG170200
  005a1	b9 00 00 02 00	 mov	 ecx, 131072		; 00020000H
  005a6	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ptt_pthread_trace
$LN89@LCS_Close:
  005ac	33 c0		 xor	 eax, eax
  005ae	85 c0		 test	 eax, eax
  005b0	75 9f		 jne	 SHORT $LN31@LCS_Close

; 1097 :             join_thread( tid, NULL );

  005b2	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG170201
  005b9	33 d2		 xor	 edx, edx
  005bb	8b 4c 24 70	 mov	 ecx, DWORD PTR tid$2[rsp]
  005bf	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_join_thread
$LN34@LCS_Close:

; 1098 :             PTT_DEBUG( "detach_thread     ", 000, pDEVBLK->devnum, pLCSPORT->bPort );

  005c5	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_pttclass
  005cc	48 8b 00	 mov	 rax, QWORD PTR [rax]
  005cf	48 25 00 00 02
	00		 and	 rax, 131072		; 00020000H
  005d5	48 85 c0	 test	 rax, rax
  005d8	74 46		 je	 SHORT $LN90@LCS_Close
  005da	48 8b 44 24 50	 mov	 rax, QWORD PTR pLCSPORT$[rsp]
  005df	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  005e2	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR pDEVBLK$[rsp]
  005ea	0f b7 49 48	 movzx	 ecx, WORD PTR [rcx+72]
  005ee	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR [rsp+48], 0
  005f7	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  005fc	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG170203
  00603	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00608	44 8b c9	 mov	 r9d, ecx
  0060b	45 33 c0	 xor	 r8d, r8d
  0060e	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG170204
  00615	b9 00 00 02 00	 mov	 ecx, 131072		; 00020000H
  0061a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ptt_pthread_trace
$LN90@LCS_Close:
  00620	33 c0		 xor	 eax, eax
  00622	85 c0		 test	 eax, eax
  00624	75 9f		 jne	 SHORT $LN34@LCS_Close

; 1099 :             detach_thread( tid );

  00626	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG170205
  0062d	8b 4c 24 70	 mov	 ecx, DWORD PTR tid$2[rsp]
  00631	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_detach_thread
$LN79@LCS_Close:

; 1100 :         }
; 1101 : 
; 1102 :         if (pLCSDEV->pDEVBLK[ LCS_READ_SUBCHANN  ] && pLCSDEV->pDEVBLK[LCS_READ_SUBCHANN]->fd >= 0)

  00637	b8 08 00 00 00	 mov	 eax, 8
  0063c	48 6b c0 00	 imul	 rax, rax, 0
  00640	48 8b 4c 24 60	 mov	 rcx, QWORD PTR pLCSDEV$[rsp]
  00645	48 83 7c 01 10
	00		 cmp	 QWORD PTR [rcx+rax+16], 0
  0064b	74 39		 je	 SHORT $LN91@LCS_Close
  0064d	b8 08 00 00 00	 mov	 eax, 8
  00652	48 6b c0 00	 imul	 rax, rax, 0
  00656	48 8b 4c 24 60	 mov	 rcx, QWORD PTR pLCSDEV$[rsp]
  0065b	48 8b 44 01 10	 mov	 rax, QWORD PTR [rcx+rax+16]
  00660	83 b8 ac 01 00
	00 00		 cmp	 DWORD PTR [rax+428], 0
  00667	7c 1d		 jl	 SHORT $LN91@LCS_Close

; 1103 :             pLCSDEV->pDEVBLK[ LCS_READ_SUBCHANN  ]->fd = -1;

  00669	b8 08 00 00 00	 mov	 eax, 8
  0066e	48 6b c0 00	 imul	 rax, rax, 0
  00672	48 8b 4c 24 60	 mov	 rcx, QWORD PTR pLCSDEV$[rsp]
  00677	48 8b 44 01 10	 mov	 rax, QWORD PTR [rcx+rax+16]
  0067c	c7 80 ac 01 00
	00 ff ff ff ff	 mov	 DWORD PTR [rax+428], -1
$LN91@LCS_Close:

; 1104 :         if (pLCSDEV->pDEVBLK[ LCS_WRITE_SUBCHANN ] && pLCSDEV->pDEVBLK[LCS_WRITE_SUBCHANN]->fd >= 0)

  00686	b8 08 00 00 00	 mov	 eax, 8
  0068b	48 6b c0 01	 imul	 rax, rax, 1
  0068f	48 8b 4c 24 60	 mov	 rcx, QWORD PTR pLCSDEV$[rsp]
  00694	48 83 7c 01 10
	00		 cmp	 QWORD PTR [rcx+rax+16], 0
  0069a	74 39		 je	 SHORT $LN92@LCS_Close
  0069c	b8 08 00 00 00	 mov	 eax, 8
  006a1	48 6b c0 01	 imul	 rax, rax, 1
  006a5	48 8b 4c 24 60	 mov	 rcx, QWORD PTR pLCSDEV$[rsp]
  006aa	48 8b 44 01 10	 mov	 rax, QWORD PTR [rcx+rax+16]
  006af	83 b8 ac 01 00
	00 00		 cmp	 DWORD PTR [rax+428], 0
  006b6	7c 1d		 jl	 SHORT $LN92@LCS_Close

; 1105 :             pLCSDEV->pDEVBLK[ LCS_WRITE_SUBCHANN ]->fd = -1;

  006b8	b8 08 00 00 00	 mov	 eax, 8
  006bd	48 6b c0 01	 imul	 rax, rax, 1
  006c1	48 8b 4c 24 60	 mov	 rcx, QWORD PTR pLCSDEV$[rsp]
  006c6	48 8b 44 01 10	 mov	 rax, QWORD PTR [rcx+rax+16]
  006cb	c7 80 ac 01 00
	00 ff ff ff ff	 mov	 DWORD PTR [rax+428], -1
$LN92@LCS_Close:
$LN37@LCS_Close:

; 1106 : 
; 1107 :         PTT_DEBUG( "CLOSE: closed     ", 000, pDEVBLK->devnum, pLCSPORT->bPort );

  006d5	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_pttclass
  006dc	48 8b 00	 mov	 rax, QWORD PTR [rax]
  006df	48 25 00 00 02
	00		 and	 rax, 131072		; 00020000H
  006e5	48 85 c0	 test	 rax, rax
  006e8	74 46		 je	 SHORT $LN93@LCS_Close
  006ea	48 8b 44 24 50	 mov	 rax, QWORD PTR pLCSPORT$[rsp]
  006ef	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  006f2	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR pDEVBLK$[rsp]
  006fa	0f b7 49 48	 movzx	 ecx, WORD PTR [rcx+72]
  006fe	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR [rsp+48], 0
  00707	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  0070c	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG170209
  00713	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00718	44 8b c9	 mov	 r9d, ecx
  0071b	45 33 c0	 xor	 r8d, r8d
  0071e	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG170210
  00725	b9 00 00 02 00	 mov	 ecx, 131072		; 00020000H
  0072a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ptt_pthread_trace
$LN93@LCS_Close:
  00730	33 c0		 xor	 eax, eax
  00732	85 c0		 test	 eax, eax
  00734	75 9f		 jne	 SHORT $LN37@LCS_Close

; 1108 :     }

  00736	eb 61		 jmp	 SHORT $LN77@LCS_Close
$LN76@LCS_Close:
$LN40@LCS_Close:

; 1109 :     else
; 1110 :         PTT_DEBUG( "CLOSE: not last   ", 000, pDEVBLK->devnum, pLCSPORT->bPort );

  00738	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_pttclass
  0073f	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00742	48 25 00 00 02
	00		 and	 rax, 131072		; 00020000H
  00748	48 85 c0	 test	 rax, rax
  0074b	74 46		 je	 SHORT $LN94@LCS_Close
  0074d	48 8b 44 24 50	 mov	 rax, QWORD PTR pLCSPORT$[rsp]
  00752	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  00755	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR pDEVBLK$[rsp]
  0075d	0f b7 49 48	 movzx	 ecx, WORD PTR [rcx+72]
  00761	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR [rsp+48], 0
  0076a	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  0076f	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG170212
  00776	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  0077b	44 8b c9	 mov	 r9d, ecx
  0077e	45 33 c0	 xor	 r8d, r8d
  00781	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG170213
  00788	b9 00 00 02 00	 mov	 ecx, 131072		; 00020000H
  0078d	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ptt_pthread_trace
$LN94@LCS_Close:
  00793	33 c0		 xor	 eax, eax
  00795	85 c0		 test	 eax, eax
  00797	75 9f		 jne	 SHORT $LN40@LCS_Close
$LN77@LCS_Close:
$LN43@LCS_Close:

; 1111 : 
; 1112 :     PTT_DEBUG( "CLOSE: cleaning up", 000, pDEVBLK->devnum, pLCSPORT->bPort );

  00799	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_pttclass
  007a0	48 8b 00	 mov	 rax, QWORD PTR [rax]
  007a3	48 25 00 00 02
	00		 and	 rax, 131072		; 00020000H
  007a9	48 85 c0	 test	 rax, rax
  007ac	74 46		 je	 SHORT $LN95@LCS_Close
  007ae	48 8b 44 24 50	 mov	 rax, QWORD PTR pLCSPORT$[rsp]
  007b3	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  007b6	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR pDEVBLK$[rsp]
  007be	0f b7 49 48	 movzx	 ecx, WORD PTR [rcx+72]
  007c2	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR [rsp+48], 0
  007cb	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  007d0	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG170215
  007d7	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  007dc	44 8b c9	 mov	 r9d, ecx
  007df	45 33 c0	 xor	 r8d, r8d
  007e2	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG170216
  007e9	b9 00 00 02 00	 mov	 ecx, 131072		; 00020000H
  007ee	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ptt_pthread_trace
$LN95@LCS_Close:
  007f4	33 c0		 xor	 eax, eax
  007f6	85 c0		 test	 eax, eax
  007f8	75 9f		 jne	 SHORT $LN43@LCS_Close

; 1113 : 
; 1114 :     // Housekeeping
; 1115 :     if (pLCSDEV->pDEVBLK[ LCS_READ_SUBCHANN  ] == pDEVBLK)

  007fa	b8 08 00 00 00	 mov	 eax, 8
  007ff	48 6b c0 00	 imul	 rax, rax, 0
  00803	48 8b 4c 24 60	 mov	 rcx, QWORD PTR pLCSDEV$[rsp]
  00808	48 8b 94 24 a0
	00 00 00	 mov	 rdx, QWORD PTR pDEVBLK$[rsp]
  00810	48 39 54 01 10	 cmp	 QWORD PTR [rcx+rax+16], rdx
  00815	75 17		 jne	 SHORT $LN96@LCS_Close

; 1116 :         pLCSDEV->pDEVBLK[ LCS_READ_SUBCHANN  ] = NULL;

  00817	b8 08 00 00 00	 mov	 eax, 8
  0081c	48 6b c0 00	 imul	 rax, rax, 0
  00820	48 8b 4c 24 60	 mov	 rcx, QWORD PTR pLCSDEV$[rsp]
  00825	48 c7 44 01 10
	00 00 00 00	 mov	 QWORD PTR [rcx+rax+16], 0
$LN96@LCS_Close:

; 1117 :     if (pLCSDEV->pDEVBLK[ LCS_WRITE_SUBCHANN ] == pDEVBLK)

  0082e	b8 08 00 00 00	 mov	 eax, 8
  00833	48 6b c0 01	 imul	 rax, rax, 1
  00837	48 8b 4c 24 60	 mov	 rcx, QWORD PTR pLCSDEV$[rsp]
  0083c	48 8b 94 24 a0
	00 00 00	 mov	 rdx, QWORD PTR pDEVBLK$[rsp]
  00844	48 39 54 01 10	 cmp	 QWORD PTR [rcx+rax+16], rdx
  00849	75 17		 jne	 SHORT $LN97@LCS_Close

; 1118 :         pLCSDEV->pDEVBLK[ LCS_WRITE_SUBCHANN ] = NULL;

  0084b	b8 08 00 00 00	 mov	 eax, 8
  00850	48 6b c0 01	 imul	 rax, rax, 1
  00854	48 8b 4c 24 60	 mov	 rcx, QWORD PTR pLCSDEV$[rsp]
  00859	48 c7 44 01 10
	00 00 00 00	 mov	 QWORD PTR [rcx+rax+16], 0
$LN97@LCS_Close:

; 1119 : 
; 1120 :     if (!pLCSDEV->pDEVBLK[LCS_READ_SUBCHANN] &&

  00862	b8 08 00 00 00	 mov	 eax, 8
  00867	48 6b c0 00	 imul	 rax, rax, 0
  0086b	48 8b 4c 24 60	 mov	 rcx, QWORD PTR pLCSDEV$[rsp]
  00870	48 83 7c 01 10
	00		 cmp	 QWORD PTR [rcx+rax+16], 0
  00876	0f 85 c8 00 00
	00		 jne	 $LN98@LCS_Close
  0087c	b8 08 00 00 00	 mov	 eax, 8
  00881	48 6b c0 01	 imul	 rax, rax, 1
  00885	48 8b 4c 24 60	 mov	 rcx, QWORD PTR pLCSDEV$[rsp]
  0088a	48 83 7c 01 10
	00		 cmp	 QWORD PTR [rcx+rax+16], 0
  00890	0f 85 ae 00 00
	00		 jne	 $LN98@LCS_Close

; 1121 :         !pLCSDEV->pDEVBLK[LCS_WRITE_SUBCHANN])
; 1122 :     {
; 1123 :         // Remove this LCS Device from the chain...
; 1124 : 
; 1125 :         PLCSDEV  pCurrLCSDev  = NULL;

  00896	48 c7 44 24 68
	00 00 00 00	 mov	 QWORD PTR pCurrLCSDev$1[rsp], 0

; 1126 :         PLCSDEV* ppPrevLCSDev = &pLCSBLK->pDevices;

  0089f	48 8b 44 24 58	 mov	 rax, QWORD PTR pLCSBLK$[rsp]
  008a4	48 83 c0 58	 add	 rax, 88			; 00000058H
  008a8	48 89 84 24 88
	00 00 00	 mov	 QWORD PTR ppPrevLCSDev$4[rsp], rax

; 1127 : 
; 1128 :         for (pCurrLCSDev = pLCSBLK->pDevices; pCurrLCSDev; pCurrLCSDev = pCurrLCSDev->pNext)

  008b0	48 8b 44 24 58	 mov	 rax, QWORD PTR pLCSBLK$[rsp]
  008b5	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  008b9	48 89 44 24 68	 mov	 QWORD PTR pCurrLCSDev$1[rsp], rax
  008be	eb 0d		 jmp	 SHORT $LN46@LCS_Close
$LN44@LCS_Close:
  008c0	48 8b 44 24 68	 mov	 rax, QWORD PTR pCurrLCSDev$1[rsp]
  008c5	48 8b 00	 mov	 rax, QWORD PTR [rax]
  008c8	48 89 44 24 68	 mov	 QWORD PTR pCurrLCSDev$1[rsp], rax
$LN46@LCS_Close:
  008cd	48 83 7c 24 68
	00		 cmp	 QWORD PTR pCurrLCSDev$1[rsp], 0
  008d3	74 6f		 je	 SHORT $LN45@LCS_Close

; 1129 :         {
; 1130 :             if (pCurrLCSDev == pLCSDEV)

  008d5	48 8b 44 24 60	 mov	 rax, QWORD PTR pLCSDEV$[rsp]
  008da	48 39 44 24 68	 cmp	 QWORD PTR pCurrLCSDev$1[rsp], rax
  008df	75 51		 jne	 SHORT $LN99@LCS_Close

; 1131 :             {
; 1132 :                 *ppPrevLCSDev = pCurrLCSDev->pNext;

  008e1	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR ppPrevLCSDev$4[rsp]
  008e9	48 8b 4c 24 68	 mov	 rcx, QWORD PTR pCurrLCSDev$1[rsp]
  008ee	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  008f1	48 89 08	 mov	 QWORD PTR [rax], rcx

; 1133 : 
; 1134 :                 if (pCurrLCSDev->pszIPAddress)

  008f4	48 8b 44 24 68	 mov	 rax, QWORD PTR pCurrLCSDev$1[rsp]
  008f9	48 83 78 25 00	 cmp	 QWORD PTR [rax+37], 0
  008fe	74 1c		 je	 SHORT $LN100@LCS_Close

; 1135 :                 {
; 1136 :                     free( pCurrLCSDev->pszIPAddress );

  00900	48 8b 44 24 68	 mov	 rax, QWORD PTR pCurrLCSDev$1[rsp]
  00905	48 8b 48 25	 mov	 rcx, QWORD PTR [rax+37]
  00909	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free

; 1137 :                     pCurrLCSDev->pszIPAddress = NULL;

  0090f	48 8b 44 24 68	 mov	 rax, QWORD PTR pCurrLCSDev$1[rsp]
  00914	48 c7 40 25 00
	00 00 00	 mov	 QWORD PTR [rax+37], 0
$LN100@LCS_Close:

; 1138 :                 }
; 1139 : 
; 1140 :                 free( pLCSDEV );

  0091c	48 8b 4c 24 60	 mov	 rcx, QWORD PTR pLCSDEV$[rsp]
  00921	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free

; 1141 :                 pLCSDEV = NULL;

  00927	48 c7 44 24 60
	00 00 00 00	 mov	 QWORD PTR pLCSDEV$[rsp], 0

; 1142 :                 break;

  00930	eb 12		 jmp	 SHORT $LN45@LCS_Close
$LN99@LCS_Close:

; 1143 :             }
; 1144 : 
; 1145 :             ppPrevLCSDev = &pCurrLCSDev->pNext;

  00932	48 8b 44 24 68	 mov	 rax, QWORD PTR pCurrLCSDev$1[rsp]
  00937	48 89 84 24 88
	00 00 00	 mov	 QWORD PTR ppPrevLCSDev$4[rsp], rax

; 1146 :         }

  0093f	e9 7c ff ff ff	 jmp	 $LN44@LCS_Close
$LN45@LCS_Close:
$LN98@LCS_Close:

; 1147 :     }
; 1148 : 
; 1149 :     if (!pLCSBLK->pDevices)

  00944	48 8b 44 24 58	 mov	 rax, QWORD PTR pLCSBLK$[rsp]
  00949	48 83 78 58 00	 cmp	 QWORD PTR [rax+88], 0
  0094e	0f 85 ae 03 00
	00		 jne	 $LN101@LCS_Close

; 1150 :     {
; 1151 :         if (pLCSBLK->pszTUNDevice  ) { free( pLCSBLK->pszTUNDevice   ); pLCSBLK->pszTUNDevice   = NULL; }

  00954	48 8b 44 24 58	 mov	 rax, QWORD PTR pLCSBLK$[rsp]
  00959	48 83 38 00	 cmp	 QWORD PTR [rax], 0
  0095d	74 1a		 je	 SHORT $LN102@LCS_Close
  0095f	48 8b 44 24 58	 mov	 rax, QWORD PTR pLCSBLK$[rsp]
  00964	48 8b 08	 mov	 rcx, QWORD PTR [rax]
  00967	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free
  0096d	48 8b 44 24 58	 mov	 rax, QWORD PTR pLCSBLK$[rsp]
  00972	48 c7 00 00 00
	00 00		 mov	 QWORD PTR [rax], 0
$LN102@LCS_Close:

; 1152 :         if (pLCSBLK->pszOATFilename) { free( pLCSBLK->pszOATFilename ); pLCSBLK->pszOATFilename = NULL; }

  00979	48 8b 44 24 58	 mov	 rax, QWORD PTR pLCSBLK$[rsp]
  0097e	48 83 78 08 00	 cmp	 QWORD PTR [rax+8], 0
  00983	74 1c		 je	 SHORT $LN103@LCS_Close
  00985	48 8b 44 24 58	 mov	 rax, QWORD PTR pLCSBLK$[rsp]
  0098a	48 8b 48 08	 mov	 rcx, QWORD PTR [rax+8]
  0098e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free
  00994	48 8b 44 24 58	 mov	 rax, QWORD PTR pLCSBLK$[rsp]
  00999	48 c7 40 08 00
	00 00 00	 mov	 QWORD PTR [rax+8], 0
$LN103@LCS_Close:

; 1153 :         if (pLCSBLK->pszIPAddress  ) { free( pLCSBLK->pszIPAddress   ); pLCSBLK->pszIPAddress   = NULL; }

  009a1	48 8b 44 24 58	 mov	 rax, QWORD PTR pLCSBLK$[rsp]
  009a6	48 83 78 10 00	 cmp	 QWORD PTR [rax+16], 0
  009ab	74 1c		 je	 SHORT $LN104@LCS_Close
  009ad	48 8b 44 24 58	 mov	 rax, QWORD PTR pLCSBLK$[rsp]
  009b2	48 8b 48 10	 mov	 rcx, QWORD PTR [rax+16]
  009b6	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free
  009bc	48 8b 44 24 58	 mov	 rax, QWORD PTR pLCSBLK$[rsp]
  009c1	48 c7 40 10 00
	00 00 00	 mov	 QWORD PTR [rax+16], 0
$LN104@LCS_Close:

; 1154 : 
; 1155 : 
; 1156 :         if ( pLCSBLK->AttnTid )

  009c9	48 8b 44 24 58	 mov	 rax, QWORD PTR pLCSBLK$[rsp]
  009ce	83 78 50 00	 cmp	 DWORD PTR [rax+80], 0
  009d2	0f 84 16 03 00
	00		 je	 $LN105@LCS_Close

; 1157 :         {
; 1158 :             TID tid = pLCSBLK->AttnTid;

  009d8	48 8b 44 24 58	 mov	 rax, QWORD PTR pLCSBLK$[rsp]
  009dd	8b 40 50	 mov	 eax, DWORD PTR [rax+80]
  009e0	89 44 24 74	 mov	 DWORD PTR tid$3[rsp], eax
$LN49@LCS_Close:

; 1159 :             PTT_DEBUG( "CLOSE: closing... ", 000, 000,000 );

  009e4	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_pttclass
  009eb	48 8b 00	 mov	 rax, QWORD PTR [rax]
  009ee	48 25 00 00 02
	00		 and	 rax, 131072		; 00020000H
  009f4	48 85 c0	 test	 rax, rax
  009f7	74 36		 je	 SHORT $LN106@LCS_Close
  009f9	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR [rsp+48], 0
  00a02	48 c7 44 24 28
	00 00 00 00	 mov	 QWORD PTR [rsp+40], 0
  00a0b	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG170228
  00a12	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00a17	45 33 c9	 xor	 r9d, r9d
  00a1a	45 33 c0	 xor	 r8d, r8d
  00a1d	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG170229
  00a24	b9 00 00 02 00	 mov	 ecx, 131072		; 00020000H
  00a29	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ptt_pthread_trace
$LN106@LCS_Close:
  00a2f	33 c0		 xor	 eax, eax
  00a31	85 c0		 test	 eax, eax
  00a33	75 af		 jne	 SHORT $LN49@LCS_Close
$LN52@LCS_Close:

; 1160 :             PTT_DEBUG( "GET  AttnEventLock", 000, 000, 000 );

  00a35	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_pttclass
  00a3c	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00a3f	48 25 00 00 02
	00		 and	 rax, 131072		; 00020000H
  00a45	48 85 c0	 test	 rax, rax
  00a48	74 36		 je	 SHORT $LN107@LCS_Close
  00a4a	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR [rsp+48], 0
  00a53	48 c7 44 24 28
	00 00 00 00	 mov	 QWORD PTR [rsp+40], 0
  00a5c	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG170231
  00a63	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00a68	45 33 c9	 xor	 r9d, r9d
  00a6b	45 33 c0	 xor	 r8d, r8d
  00a6e	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG170232
  00a75	b9 00 00 02 00	 mov	 ecx, 131072		; 00020000H
  00a7a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ptt_pthread_trace
$LN107@LCS_Close:
  00a80	33 c0		 xor	 eax, eax
  00a82	85 c0		 test	 eax, eax
  00a84	75 af		 jne	 SHORT $LN52@LCS_Close

; 1161 :             obtain_lock( &pLCSBLK->AttnEventLock );

  00a86	48 8b 44 24 58	 mov	 rax, QWORD PTR pLCSBLK$[rsp]
  00a8b	48 83 c0 40	 add	 rax, 64			; 00000040H
  00a8f	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG170233
  00a96	48 8b c8	 mov	 rcx, rax
  00a99	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_obtain_lock
$LN55@LCS_Close:

; 1162 :             PTT_DEBUG( "GOT  AttnEventLock", 000, 000, 000 );

  00a9f	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_pttclass
  00aa6	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00aa9	48 25 00 00 02
	00		 and	 rax, 131072		; 00020000H
  00aaf	48 85 c0	 test	 rax, rax
  00ab2	74 36		 je	 SHORT $LN108@LCS_Close
  00ab4	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR [rsp+48], 0
  00abd	48 c7 44 24 28
	00 00 00 00	 mov	 QWORD PTR [rsp+40], 0
  00ac6	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG170235
  00acd	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00ad2	45 33 c9	 xor	 r9d, r9d
  00ad5	45 33 c0	 xor	 r8d, r8d
  00ad8	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG170236
  00adf	b9 00 00 02 00	 mov	 ecx, 131072		; 00020000H
  00ae4	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ptt_pthread_trace
$LN108@LCS_Close:
  00aea	33 c0		 xor	 eax, eax
  00aec	85 c0		 test	 eax, eax
  00aee	75 af		 jne	 SHORT $LN55@LCS_Close
$LN58@LCS_Close:

; 1163 :             {
; 1164 :                 PTT_DEBUG( "SET  closeInProg  ", 000, 000, 000 );

  00af0	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_pttclass
  00af7	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00afa	48 25 00 00 02
	00		 and	 rax, 131072		; 00020000H
  00b00	48 85 c0	 test	 rax, rax
  00b03	74 36		 je	 SHORT $LN109@LCS_Close
  00b05	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR [rsp+48], 0
  00b0e	48 c7 44 24 28
	00 00 00 00	 mov	 QWORD PTR [rsp+40], 0
  00b17	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG170238
  00b1e	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00b23	45 33 c9	 xor	 r9d, r9d
  00b26	45 33 c0	 xor	 r8d, r8d
  00b29	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG170239
  00b30	b9 00 00 02 00	 mov	 ecx, 131072		; 00020000H
  00b35	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ptt_pthread_trace
$LN109@LCS_Close:
  00b3b	33 c0		 xor	 eax, eax
  00b3d	85 c0		 test	 eax, eax
  00b3f	75 af		 jne	 SHORT $LN58@LCS_Close

; 1165 :                 pLCSBLK->fCloseInProgress = 1;

  00b41	48 8b 44 24 58	 mov	 rax, QWORD PTR pLCSBLK$[rsp]
  00b46	8b 40 18	 mov	 eax, DWORD PTR [rax+24]
  00b49	83 c8 02	 or	 eax, 2
  00b4c	48 8b 4c 24 58	 mov	 rcx, QWORD PTR pLCSBLK$[rsp]
  00b51	89 41 18	 mov	 DWORD PTR [rcx+24], eax
$LN61@LCS_Close:

; 1166 :                 PTT_DEBUG( "SIG  AttnEvent", 000, 000, 000 );

  00b54	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_pttclass
  00b5b	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00b5e	48 25 00 00 02
	00		 and	 rax, 131072		; 00020000H
  00b64	48 85 c0	 test	 rax, rax
  00b67	74 36		 je	 SHORT $LN110@LCS_Close
  00b69	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR [rsp+48], 0
  00b72	48 c7 44 24 28
	00 00 00 00	 mov	 QWORD PTR [rsp+40], 0
  00b7b	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG170241
  00b82	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00b87	45 33 c9	 xor	 r9d, r9d
  00b8a	45 33 c0	 xor	 r8d, r8d
  00b8d	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG170242
  00b94	b9 00 00 02 00	 mov	 ecx, 131072		; 00020000H
  00b99	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ptt_pthread_trace
$LN110@LCS_Close:
  00b9f	33 c0		 xor	 eax, eax
  00ba1	85 c0		 test	 eax, eax
  00ba3	75 af		 jne	 SHORT $LN61@LCS_Close

; 1167 :                 signal_condition( &pLCSBLK->AttnEvent );

  00ba5	48 8b 44 24 58	 mov	 rax, QWORD PTR pLCSBLK$[rsp]
  00baa	48 83 c0 48	 add	 rax, 72			; 00000048H
  00bae	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG170243
  00bb5	48 8b c8	 mov	 rcx, rax
  00bb8	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_signal_condition
$LN64@LCS_Close:

; 1168 :             }
; 1169 :             PTT_DEBUG( "REL  AttnEventLock", 000, 000, 000 );

  00bbe	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_pttclass
  00bc5	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00bc8	48 25 00 00 02
	00		 and	 rax, 131072		; 00020000H
  00bce	48 85 c0	 test	 rax, rax
  00bd1	74 36		 je	 SHORT $LN111@LCS_Close
  00bd3	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR [rsp+48], 0
  00bdc	48 c7 44 24 28
	00 00 00 00	 mov	 QWORD PTR [rsp+40], 0
  00be5	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG170245
  00bec	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00bf1	45 33 c9	 xor	 r9d, r9d
  00bf4	45 33 c0	 xor	 r8d, r8d
  00bf7	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG170246
  00bfe	b9 00 00 02 00	 mov	 ecx, 131072		; 00020000H
  00c03	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ptt_pthread_trace
$LN111@LCS_Close:
  00c09	33 c0		 xor	 eax, eax
  00c0b	85 c0		 test	 eax, eax
  00c0d	75 af		 jne	 SHORT $LN64@LCS_Close

; 1170 :             release_lock( &pLCSBLK->AttnEventLock );

  00c0f	48 8b 44 24 58	 mov	 rax, QWORD PTR pLCSBLK$[rsp]
  00c14	48 83 c0 40	 add	 rax, 64			; 00000040H
  00c18	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG170247
  00c1f	48 8b c8	 mov	 rcx, rax
  00c22	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_release_lock
$LN67@LCS_Close:

; 1171 :             PTT_DEBUG( "join_thread       ", 000, 000, 000 );

  00c28	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_pttclass
  00c2f	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00c32	48 25 00 00 02
	00		 and	 rax, 131072		; 00020000H
  00c38	48 85 c0	 test	 rax, rax
  00c3b	74 36		 je	 SHORT $LN112@LCS_Close
  00c3d	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR [rsp+48], 0
  00c46	48 c7 44 24 28
	00 00 00 00	 mov	 QWORD PTR [rsp+40], 0
  00c4f	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG170249
  00c56	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00c5b	45 33 c9	 xor	 r9d, r9d
  00c5e	45 33 c0	 xor	 r8d, r8d
  00c61	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG170250
  00c68	b9 00 00 02 00	 mov	 ecx, 131072		; 00020000H
  00c6d	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ptt_pthread_trace
$LN112@LCS_Close:
  00c73	33 c0		 xor	 eax, eax
  00c75	85 c0		 test	 eax, eax
  00c77	75 af		 jne	 SHORT $LN67@LCS_Close

; 1172 :             join_thread( tid, NULL );

  00c79	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG170251
  00c80	33 d2		 xor	 edx, edx
  00c82	8b 4c 24 74	 mov	 ecx, DWORD PTR tid$3[rsp]
  00c86	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_join_thread
$LN70@LCS_Close:

; 1173 :             PTT_DEBUG( "detach_thread     ", 000, 000, 000 );

  00c8c	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_pttclass
  00c93	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00c96	48 25 00 00 02
	00		 and	 rax, 131072		; 00020000H
  00c9c	48 85 c0	 test	 rax, rax
  00c9f	74 36		 je	 SHORT $LN113@LCS_Close
  00ca1	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR [rsp+48], 0
  00caa	48 c7 44 24 28
	00 00 00 00	 mov	 QWORD PTR [rsp+40], 0
  00cb3	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG170253
  00cba	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00cbf	45 33 c9	 xor	 r9d, r9d
  00cc2	45 33 c0	 xor	 r8d, r8d
  00cc5	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG170254
  00ccc	b9 00 00 02 00	 mov	 ecx, 131072		; 00020000H
  00cd1	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ptt_pthread_trace
$LN113@LCS_Close:
  00cd7	33 c0		 xor	 eax, eax
  00cd9	85 c0		 test	 eax, eax
  00cdb	75 af		 jne	 SHORT $LN70@LCS_Close

; 1174 :             detach_thread( tid );

  00cdd	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG170255
  00ce4	8b 4c 24 74	 mov	 ecx, DWORD PTR tid$3[rsp]
  00ce8	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_detach_thread
$LN105@LCS_Close:

; 1175 :         }
; 1176 : 
; 1177 :         free( pLCSBLK );

  00cee	48 8b 4c 24 58	 mov	 rcx, QWORD PTR pLCSBLK$[rsp]
  00cf3	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free

; 1178 :         pLCSBLK = NULL;

  00cf9	48 c7 44 24 58
	00 00 00 00	 mov	 QWORD PTR pLCSBLK$[rsp], 0
$LN101@LCS_Close:

; 1179 :     }
; 1180 : 
; 1181 :     pDEVBLK->dev_data = NULL;

  00d02	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR pDEVBLK$[rsp]
  00d0a	48 c7 80 08 06
	00 00 00 00 00
	00		 mov	 QWORD PTR [rax+1544], 0
$LN73@LCS_Close:

; 1182 : 
; 1183 :     PTT_DEBUG( "CLOSE: EXIT       ", 000, pDEVBLK->devnum, pLCSPORT->bPort );

  00d15	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_pttclass
  00d1c	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00d1f	48 25 00 00 02
	00		 and	 rax, 131072		; 00020000H
  00d25	48 85 c0	 test	 rax, rax
  00d28	74 46		 je	 SHORT $LN114@LCS_Close
  00d2a	48 8b 44 24 50	 mov	 rax, QWORD PTR pLCSPORT$[rsp]
  00d2f	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  00d32	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR pDEVBLK$[rsp]
  00d3a	0f b7 49 48	 movzx	 ecx, WORD PTR [rcx+72]
  00d3e	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR [rsp+48], 0
  00d47	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  00d4c	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG170257
  00d53	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00d58	44 8b c9	 mov	 r9d, ecx
  00d5b	45 33 c0	 xor	 r8d, r8d
  00d5e	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG170258
  00d65	b9 00 00 02 00	 mov	 ecx, 131072		; 00020000H
  00d6a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ptt_pthread_trace
$LN114@LCS_Close:
  00d70	33 c0		 xor	 eax, eax
  00d72	85 c0		 test	 eax, eax
  00d74	75 9f		 jne	 SHORT $LN73@LCS_Close

; 1184 : 
; 1185 :     return 0;

  00d76	33 c0		 xor	 eax, eax
$LN1@LCS_Close:

; 1186 : }

  00d78	48 81 c4 98 00
	00 00		 add	 rsp, 152		; 00000098H
  00d7f	c3		 ret	 0
LCS_Close ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\ctc_lcs.c
_TEXT	SEGMENT
pLCSDev$ = 112
pLCSBLK$ = 120
pLCSPORT$ = 128
bMode$ = 136
i$ = 140
rc$1 = 144
rc$ = 148
tv92 = 152
tv128 = 156
addr$ = 160
tv263 = 164
tv270 = 168
tv278 = 172
tv343 = 176
tv350 = 180
tv358 = 184
tv492 = 188
tv522 = 192
tv676 = 196
tv717 = 200
tv80 = 208
tv447 = 216
tv881 = 224
tv511 = 232
tv878 = 240
tv621 = 248
tv625 = 256
tv875 = 264
tv694 = 272
tv698 = 280
tv872 = 288
tv765 = 296
tv841 = 304
tt32ctl$2 = 312
thread_name$ = 336
buf$3 = 368
__$ArrayPad$ = 408
pDEVBLK$ = 432
argc$ = 440
argv$ = 448
LCS_Init PROC

; 229  : {

$LN68:
  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00009	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000e	57		 push	 rdi
  0000f	48 81 ec a0 01
	00 00		 sub	 rsp, 416		; 000001a0H
  00016	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  0001d	48 33 c4	 xor	 rax, rsp
  00020	48 89 84 24 98
	01 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 230  :     PLCSBLK     pLCSBLK;
; 231  :     PLCSDEV     pLCSDev;
; 232  :     PLCSPORT    pLCSPORT;
; 233  :     int         i;
; 234  :     int         rc;
; 235  :     BYTE        bMode;   /* Either LCSDEV_MODE_IP or LCSDEV_MODE_SNA */
; 236  :     struct in_addr  addr;               // Work area for addresses
; 237  :     char        thread_name[32];        // Thread name
; 238  : 
; 239  : 
; 240  :     pDEVBLK->devtype = 0x3088;

  00028	b8 88 30 00 00	 mov	 eax, 12424		; 00003088H
  0002d	48 8b 8c 24 b0
	01 00 00	 mov	 rcx, QWORD PTR pDEVBLK$[rsp]
  00035	66 89 41 4a	 mov	 WORD PTR [rcx+74], ax

; 241  : 
; 242  :     pDEVBLK->excps   = 0;

  00039	48 8b 84 24 b0
	01 00 00	 mov	 rax, QWORD PTR pDEVBLK$[rsp]
  00041	48 c7 80 00 06
	00 00 00 00 00
	00		 mov	 QWORD PTR [rax+1536], 0

; 243  : 
; 244  :     // Return when an existing group has been joined but is still incomplete
; 245  :     if (!group_device( pDEVBLK, 0 ) && pDEVBLK->group)

  0004c	33 d2		 xor	 edx, edx
  0004e	48 8b 8c 24 b0
	01 00 00	 mov	 rcx, QWORD PTR pDEVBLK$[rsp]
  00056	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_group_device
  0005c	85 c0		 test	 eax, eax
  0005e	75 16		 jne	 SHORT $LN29@LCS_Init
  00060	48 8b 84 24 b0
	01 00 00	 mov	 rax, QWORD PTR pDEVBLK$[rsp]
  00068	48 83 78 60 00	 cmp	 QWORD PTR [rax+96], 0
  0006d	74 07		 je	 SHORT $LN29@LCS_Init

; 246  :         return 0;

  0006f	33 c0		 xor	 eax, eax
  00071	e9 76 14 00 00	 jmp	 $LN1@LCS_Init
$LN29@LCS_Init:

; 247  : 
; 248  :     // We need to create a group, and as such determine the number of devices
; 249  :     if (!pDEVBLK->group)

  00076	48 8b 84 24 b0
	01 00 00	 mov	 rax, QWORD PTR pDEVBLK$[rsp]
  0007e	48 83 78 60 00	 cmp	 QWORD PTR [rax+96], 0
  00083	0f 85 74 04 00
	00		 jne	 $LN30@LCS_Init

; 250  :     {
; 251  : 
; 252  :         // Housekeeping
; 253  :         pLCSBLK = malloc( sizeof( LCSBLK ));

  00089	b9 c0 06 00 00	 mov	 ecx, 1728		; 000006c0H
  0008e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_malloc
  00094	48 89 44 24 78	 mov	 QWORD PTR pLCSBLK$[rsp], rax

; 254  :         if (!pLCSBLK)

  00099	48 83 7c 24 78
	00		 cmp	 QWORD PTR pLCSBLK$[rsp], 0
  0009f	0f 85 f0 00 00
	00		 jne	 $LN32@LCS_Init

; 255  :         {
; 256  :             char buf[40];
; 257  :             MSGBUF(buf, "malloc(%d)", (int) sizeof( LCSBLK ));

  000a5	41 b9 c0 06 00
	00		 mov	 r9d, 1728		; 000006c0H
  000ab	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG169532
  000b2	ba 28 00 00 00	 mov	 edx, 40			; 00000028H
  000b7	48 8d 8c 24 70
	01 00 00	 lea	 rcx, QWORD PTR buf$3[rsp]
  000bf	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_snprintf

; 258  :             // "%1d:%04X %s: error in function %s: %s"
; 259  :             WRMSG( HHC00900, "E", SSID_TO_LCSS( pDEVBLK->ssid ),

  000c5	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno
  000cb	8b 08		 mov	 ecx, DWORD PTR [rax]
  000cd	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_strerror
  000d3	48 89 84 24 d0
	00 00 00	 mov	 QWORD PTR tv80[rsp], rax
  000db	48 8b 8c 24 b0
	01 00 00	 mov	 rcx, QWORD PTR pDEVBLK$[rsp]
  000e3	0f b7 49 48	 movzx	 ecx, WORD PTR [rcx+72]
  000e7	89 8c 24 98 00
	00 00		 mov	 DWORD PTR tv92[rsp], ecx
  000ee	48 8b 94 24 b0
	01 00 00	 mov	 rdx, QWORD PTR pDEVBLK$[rsp]
  000f6	0f b7 52 44	 movzx	 edx, WORD PTR [rdx+68]
  000fa	d1 fa		 sar	 edx, 1
  000fc	89 94 24 9c 00
	00 00		 mov	 DWORD PTR tv128[rsp], edx
  00103	b9 01 00 00 00	 mov	 ecx, 1
  00108	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  0010e	48 8b 8c 24 d0
	00 00 00	 mov	 rcx, QWORD PTR tv80[rsp]
  00116	48 89 4c 24 58	 mov	 QWORD PTR [rsp+88], rcx
  0011b	48 8d 8c 24 70
	01 00 00	 lea	 rcx, QWORD PTR buf$3[rsp]
  00123	48 89 4c 24 50	 mov	 QWORD PTR [rsp+80], rcx
  00128	48 8b 8c 24 b0
	01 00 00	 mov	 rcx, QWORD PTR pDEVBLK$[rsp]
  00130	48 8b 49 50	 mov	 rcx, QWORD PTR [rcx+80]
  00134	48 89 4c 24 48	 mov	 QWORD PTR [rsp+72], rcx
  00139	8b 8c 24 98 00
	00 00		 mov	 ecx, DWORD PTR tv92[rsp]
  00140	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  00144	8b 8c 24 9c 00
	00 00		 mov	 ecx, DWORD PTR tv128[rsp]
  0014b	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  0014f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169533
  00156	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  0015b	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169534
  00162	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00167	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  0016c	41 b9 03 00 00
	00		 mov	 r9d, 3
  00172	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG169535
  00179	ba 04 01 00 00	 mov	 edx, 260		; 00000104H
  0017e	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169536
  00185	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 260  :                 pDEVBLK->devnum, pDEVBLK->typname, buf, strerror(errno) );
; 261  :             return -1;

  0018b	b8 ff ff ff ff	 mov	 eax, -1
  00190	e9 57 13 00 00	 jmp	 $LN1@LCS_Init
$LN32@LCS_Init:

; 262  :         }
; 263  :         memset( pLCSBLK, 0, sizeof( LCSBLK ));

  00195	48 8b 7c 24 78	 mov	 rdi, QWORD PTR pLCSBLK$[rsp]
  0019a	33 c0		 xor	 eax, eax
  0019c	b9 c0 06 00 00	 mov	 ecx, 1728		; 000006c0H
  001a1	f3 aa		 rep stosb

; 264  :         pLCSBLK->iTraceLen = LCS_TRACE_LEN_DEFAULT;

  001a3	48 8b 44 24 78	 mov	 rax, QWORD PTR pLCSBLK$[rsp]
  001a8	c7 40 28 80 00
	00 00		 mov	 DWORD PTR [rax+40], 128	; 00000080H

; 265  : 
; 266  :         // Initialize locking and event mechanisms
; 267  :         initialize_lock( &pLCSBLK->AttnLock );

  001af	48 8b 44 24 78	 mov	 rax, QWORD PTR pLCSBLK$[rsp]
  001b4	48 83 c0 30	 add	 rax, 48			; 00000030H
  001b8	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG169537
  001bf	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG169538
  001c6	48 8b c8	 mov	 rcx, rax
  001c9	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_initialize_lock

; 268  :         initialize_lock( &pLCSBLK->AttnEventLock );

  001cf	48 8b 44 24 78	 mov	 rax, QWORD PTR pLCSBLK$[rsp]
  001d4	48 83 c0 40	 add	 rax, 64			; 00000040H
  001d8	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG169539
  001df	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG169540
  001e6	48 8b c8	 mov	 rcx, rax
  001e9	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_initialize_lock

; 269  :         initialize_condition( &pLCSBLK->AttnEvent );

  001ef	48 8b 44 24 78	 mov	 rax, QWORD PTR pLCSBLK$[rsp]
  001f4	48 83 c0 48	 add	 rax, 72			; 00000048H
  001f8	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG169541
  001ff	48 8b c8	 mov	 rcx, rax
  00202	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_initialize_condition

; 270  : 
; 271  :         for (i=0; i < LCS_MAX_PORTS; i++)

  00208	c7 84 24 8c 00
	00 00 00 00 00
	00		 mov	 DWORD PTR i$[rsp], 0
  00213	eb 10		 jmp	 SHORT $LN4@LCS_Init
$LN2@LCS_Init:
  00215	8b 84 24 8c 00
	00 00		 mov	 eax, DWORD PTR i$[rsp]
  0021c	ff c0		 inc	 eax
  0021e	89 84 24 8c 00
	00 00		 mov	 DWORD PTR i$[rsp], eax
$LN4@LCS_Init:
  00225	83 bc 24 8c 00
	00 00 04	 cmp	 DWORD PTR i$[rsp], 4
  0022d	0f 8d c2 00 00
	00		 jge	 $LN3@LCS_Init

; 272  :         {
; 273  :             pLCSPORT = &pLCSBLK->Port[i];

  00233	48 63 84 24 8c
	00 00 00	 movsxd	 rax, DWORD PTR i$[rsp]
  0023b	48 69 c0 98 01
	00 00		 imul	 rax, rax, 408		; 00000198H
  00242	48 8b 4c 24 78	 mov	 rcx, QWORD PTR pLCSBLK$[rsp]
  00247	48 8d 44 01 60	 lea	 rax, QWORD PTR [rcx+rax+96]
  0024c	48 89 84 24 80
	00 00 00	 mov	 QWORD PTR pLCSPORT$[rsp], rax

; 274  :             memset( pLCSPORT, 0, sizeof ( LCSPORT ));

  00254	48 8b bc 24 80
	00 00 00	 mov	 rdi, QWORD PTR pLCSPORT$[rsp]
  0025c	33 c0		 xor	 eax, eax
  0025e	b9 98 01 00 00	 mov	 ecx, 408		; 00000198H
  00263	f3 aa		 rep stosb

; 275  : 
; 276  :             pLCSPORT->bPort   = i;

  00265	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR pLCSPORT$[rsp]
  0026d	0f b6 8c 24 8c
	00 00 00	 movzx	 ecx, BYTE PTR i$[rsp]
  00275	88 08		 mov	 BYTE PTR [rax], cl

; 277  :             pLCSPORT->pLCSBLK = pLCSBLK;

  00277	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR pLCSPORT$[rsp]
  0027f	48 8b 4c 24 78	 mov	 rcx, QWORD PTR pLCSBLK$[rsp]
  00284	48 89 48 10	 mov	 QWORD PTR [rax+16], rcx

; 278  : 
; 279  :             // Initialize locking and event mechanisms
; 280  :             initialize_lock( &pLCSPORT->PortDataLock );

  00288	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR pLCSPORT$[rsp]
  00290	48 05 1c 01 00
	00		 add	 rax, 284		; 0000011cH
  00296	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG169542
  0029d	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG169543
  002a4	48 8b c8	 mov	 rcx, rax
  002a7	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_initialize_lock

; 281  :             initialize_lock( &pLCSPORT->PortEventLock );

  002ad	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR pLCSPORT$[rsp]
  002b5	48 05 24 01 00
	00		 add	 rax, 292		; 00000124H
  002bb	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG169544
  002c2	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG169545
  002c9	48 8b c8	 mov	 rcx, rax
  002cc	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_initialize_lock

; 282  :             initialize_condition( &pLCSPORT->PortEvent );

  002d2	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR pLCSPORT$[rsp]
  002da	48 05 2c 01 00
	00		 add	 rax, 300		; 0000012cH
  002e0	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG169546
  002e7	48 8b c8	 mov	 rcx, rax
  002ea	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_initialize_condition

; 283  :         }

  002f0	e9 20 ff ff ff	 jmp	 $LN2@LCS_Init
$LN3@LCS_Init:

; 284  : 
; 285  :         // Parse configuration file statement
; 286  :         rc = ParseArgs( pDEVBLK, pLCSBLK, argc, (char**) argv );

  002f5	4c 8b 8c 24 c0
	01 00 00	 mov	 r9, QWORD PTR argv$[rsp]
  002fd	44 8b 84 24 b8
	01 00 00	 mov	 r8d, DWORD PTR argc$[rsp]
  00305	48 8b 54 24 78	 mov	 rdx, QWORD PTR pLCSBLK$[rsp]
  0030a	48 8b 8c 24 b0
	01 00 00	 mov	 rcx, QWORD PTR pDEVBLK$[rsp]
  00312	e8 00 00 00 00	 call	 ParseArgs
  00317	89 84 24 94 00
	00 00		 mov	 DWORD PTR rc$[rsp], eax

; 287  :         if (rc < 0)

  0031e	83 bc 24 94 00
	00 00 00	 cmp	 DWORD PTR rc$[rsp], 0
  00326	7d 1e		 jge	 SHORT $LN33@LCS_Init

; 288  :         {
; 289  :             free( pLCSBLK );

  00328	48 8b 4c 24 78	 mov	 rcx, QWORD PTR pLCSBLK$[rsp]
  0032d	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free

; 290  :             pLCSBLK = NULL;

  00333	48 c7 44 24 78
	00 00 00 00	 mov	 QWORD PTR pLCSBLK$[rsp], 0

; 291  :             return -1;

  0033c	b8 ff ff ff ff	 mov	 eax, -1
  00341	e9 a6 11 00 00	 jmp	 $LN1@LCS_Init
$LN33@LCS_Init:

; 292  :         }
; 293  :         bMode = rc;

  00346	0f b6 84 24 94
	00 00 00	 movzx	 eax, BYTE PTR rc$[rsp]
  0034e	88 84 24 88 00
	00 00		 mov	 BYTE PTR bMode$[rsp], al

; 294  : 
; 295  :         if (pLCSBLK->pszOATFilename)

  00355	48 8b 44 24 78	 mov	 rax, QWORD PTR pLCSBLK$[rsp]
  0035a	48 83 78 08 00	 cmp	 QWORD PTR [rax+8], 0
  0035f	74 3a		 je	 SHORT $LN34@LCS_Init

; 296  :         {
; 297  :             // If an OAT file was specified, Parse it and build the
; 298  :             // OAT table.
; 299  :             if (BuildOAT( pLCSBLK->pszOATFilename, pLCSBLK ) != 0)

  00361	48 8b 54 24 78	 mov	 rdx, QWORD PTR pLCSBLK$[rsp]
  00366	48 8b 44 24 78	 mov	 rax, QWORD PTR pLCSBLK$[rsp]
  0036b	48 8b 48 08	 mov	 rcx, QWORD PTR [rax+8]
  0036f	e8 00 00 00 00	 call	 BuildOAT
  00374	85 c0		 test	 eax, eax
  00376	74 1e		 je	 SHORT $LN36@LCS_Init

; 300  :             {
; 301  :                 free( pLCSBLK );

  00378	48 8b 4c 24 78	 mov	 rcx, QWORD PTR pLCSBLK$[rsp]
  0037d	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free

; 302  :                 pLCSBLK = NULL;

  00383	48 c7 44 24 78
	00 00 00 00	 mov	 QWORD PTR pLCSBLK$[rsp], 0

; 303  :                 return -1;

  0038c	b8 ff ff ff ff	 mov	 eax, -1
  00391	e9 56 11 00 00	 jmp	 $LN1@LCS_Init
$LN36@LCS_Init:

; 304  :             }
; 305  :         }

  00396	e9 13 01 00 00	 jmp	 $LN35@LCS_Init
$LN34@LCS_Init:

; 306  :         else
; 307  :         {
; 308  :             // Otherwise, build an OAT based on the address specified
; 309  :             // in the config file with an assumption of IP mode.
; 310  :             pLCSBLK->pDevices = malloc( sizeof( LCSDEV ));

  0039b	b9 a6 50 00 00	 mov	 ecx, 20646		; 000050a6H
  003a0	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_malloc
  003a6	48 8b 4c 24 78	 mov	 rcx, QWORD PTR pLCSBLK$[rsp]
  003ab	48 89 41 58	 mov	 QWORD PTR [rcx+88], rax

; 311  : 
; 312  :             memset( pLCSBLK->pDevices, 0, sizeof( LCSDEV ));

  003af	48 8b 44 24 78	 mov	 rax, QWORD PTR pLCSBLK$[rsp]
  003b4	48 8b 78 58	 mov	 rdi, QWORD PTR [rax+88]
  003b8	33 c0		 xor	 eax, eax
  003ba	b9 a6 50 00 00	 mov	 ecx, 20646		; 000050a6H
  003bf	f3 aa		 rep stosb

; 313  :             pLCSBLK->pDevices->sAddr        = pDEVBLK->devnum;

  003c1	48 8b 44 24 78	 mov	 rax, QWORD PTR pLCSBLK$[rsp]
  003c6	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  003ca	48 8b 8c 24 b0
	01 00 00	 mov	 rcx, QWORD PTR pDEVBLK$[rsp]
  003d2	0f b7 49 48	 movzx	 ecx, WORD PTR [rcx+72]
  003d6	66 89 48 20	 mov	 WORD PTR [rax+32], cx

; 314  :             pLCSBLK->pDevices->bPort        = 0;

  003da	48 8b 44 24 78	 mov	 rax, QWORD PTR pLCSBLK$[rsp]
  003df	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  003e3	c6 40 23 00	 mov	 BYTE PTR [rax+35], 0

; 315  :             pLCSBLK->pDevices->pNext        = NULL;

  003e7	48 8b 44 24 78	 mov	 rax, QWORD PTR pLCSBLK$[rsp]
  003ec	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  003f0	48 c7 00 00 00
	00 00		 mov	 QWORD PTR [rax], 0

; 316  : 
; 317  :             if (bMode == LCSDEV_MODE_IP)

  003f7	0f b6 84 24 88
	00 00 00	 movzx	 eax, BYTE PTR bMode$[rsp]
  003ff	83 f8 01	 cmp	 eax, 1
  00402	0f 85 8d 00 00
	00		 jne	 $LN37@LCS_Init

; 318  :             {
; 319  :                 if (pLCSBLK->pszIPAddress)

  00408	48 8b 44 24 78	 mov	 rax, QWORD PTR pLCSBLK$[rsp]
  0040d	48 83 78 10 00	 cmp	 QWORD PTR [rax+16], 0
  00412	74 59		 je	 SHORT $LN39@LCS_Init

; 320  :                 {
; 321  :                     pLCSBLK->pDevices->pszIPAddress = strdup( pLCSBLK->pszIPAddress );

  00414	48 8b 44 24 78	 mov	 rax, QWORD PTR pLCSBLK$[rsp]
  00419	48 8b 48 10	 mov	 rcx, QWORD PTR [rax+16]
  0041d	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_strdup
  00423	48 8b 4c 24 78	 mov	 rcx, QWORD PTR pLCSBLK$[rsp]
  00428	48 8b 49 58	 mov	 rcx, QWORD PTR [rcx+88]
  0042c	48 89 41 25	 mov	 QWORD PTR [rcx+37], rax

; 322  :                     inet_aton( pLCSBLK->pDevices->pszIPAddress, &addr );

  00430	48 8b 44 24 78	 mov	 rax, QWORD PTR pLCSBLK$[rsp]
  00435	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  00439	48 8d 94 24 a0
	00 00 00	 lea	 rdx, QWORD PTR addr$[rsp]
  00441	48 8b 48 25	 mov	 rcx, QWORD PTR [rax+37]
  00445	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_inet_aton

; 323  :                     pLCSBLK->pDevices->lIPAddress = addr.s_addr; // (network byte order)

  0044b	48 8b 44 24 78	 mov	 rax, QWORD PTR pLCSBLK$[rsp]
  00450	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  00454	8b 8c 24 a0 00
	00 00		 mov	 ecx, DWORD PTR addr$[rsp]
  0045b	89 48 2d	 mov	 DWORD PTR [rax+45], ecx

; 324  :                     pLCSBLK->pDevices->bType    = LCSDEV_TYPE_NONE;

  0045e	48 8b 44 24 78	 mov	 rax, QWORD PTR pLCSBLK$[rsp]
  00463	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  00467	c6 40 24 00	 mov	 BYTE PTR [rax+36], 0

; 325  :                 }

  0046b	eb 0d		 jmp	 SHORT $LN40@LCS_Init
$LN39@LCS_Init:

; 326  :                 else
; 327  :                     pLCSBLK->pDevices->bType    = LCSDEV_TYPE_PRIMARY;

  0046d	48 8b 44 24 78	 mov	 rax, QWORD PTR pLCSBLK$[rsp]
  00472	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  00476	c6 40 24 01	 mov	 BYTE PTR [rax+36], 1
$LN40@LCS_Init:

; 328  : 
; 329  :                 pLCSBLK->pDevices->bMode        = LCSDEV_MODE_IP;

  0047a	48 8b 44 24 78	 mov	 rax, QWORD PTR pLCSBLK$[rsp]
  0047f	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  00483	c6 40 22 01	 mov	 BYTE PTR [rax+34], 1

; 330  : 
; 331  :                 pLCSBLK->icDevices = 2;

  00487	48 8b 44 24 78	 mov	 rax, QWORD PTR pLCSBLK$[rsp]
  0048c	c7 40 1c 02 00
	00 00		 mov	 DWORD PTR [rax+28], 2

; 332  :             }

  00493	eb 19		 jmp	 SHORT $LN38@LCS_Init
$LN37@LCS_Init:

; 333  :             else
; 334  :             {
; 335  :                 pLCSBLK->pDevices->bMode        = LCSDEV_MODE_SNA;

  00495	48 8b 44 24 78	 mov	 rax, QWORD PTR pLCSBLK$[rsp]
  0049a	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  0049e	c6 40 22 02	 mov	 BYTE PTR [rax+34], 2

; 336  : 
; 337  :                 pLCSBLK->icDevices = 1;

  004a2	48 8b 44 24 78	 mov	 rax, QWORD PTR pLCSBLK$[rsp]
  004a7	c7 40 1c 01 00
	00 00		 mov	 DWORD PTR [rax+28], 1
$LN38@LCS_Init:
$LN35@LCS_Init:

; 338  :             }
; 339  :         }
; 340  : 
; 341  :         // Now we must create the group
; 342  :         if (!group_device( pDEVBLK, pLCSBLK->icDevices ))

  004ae	48 8b 44 24 78	 mov	 rax, QWORD PTR pLCSBLK$[rsp]
  004b3	8b 50 1c	 mov	 edx, DWORD PTR [rax+28]
  004b6	48 8b 8c 24 b0
	01 00 00	 mov	 rcx, QWORD PTR pDEVBLK$[rsp]
  004be	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_group_device
  004c4	85 c0		 test	 eax, eax
  004c6	75 1e		 jne	 SHORT $LN41@LCS_Init

; 343  :         {
; 344  :             pDEVBLK->group->grp_data = pLCSBLK;

  004c8	48 8b 84 24 b0
	01 00 00	 mov	 rax, QWORD PTR pDEVBLK$[rsp]
  004d0	48 8b 40 60	 mov	 rax, QWORD PTR [rax+96]
  004d4	48 8b 4c 24 78	 mov	 rcx, QWORD PTR pLCSBLK$[rsp]
  004d9	48 89 48 08	 mov	 QWORD PTR [rax+8], rcx

; 345  :             return 0;

  004dd	33 c0		 xor	 eax, eax
  004df	e9 08 10 00 00	 jmp	 $LN1@LCS_Init

; 346  :         }

  004e4	eb 15		 jmp	 SHORT $LN42@LCS_Init
$LN41@LCS_Init:

; 347  :         else
; 348  :             pDEVBLK->group->grp_data = pLCSBLK;

  004e6	48 8b 84 24 b0
	01 00 00	 mov	 rax, QWORD PTR pDEVBLK$[rsp]
  004ee	48 8b 40 60	 mov	 rax, QWORD PTR [rax+96]
  004f2	48 8b 4c 24 78	 mov	 rcx, QWORD PTR pLCSBLK$[rsp]
  004f7	48 89 48 08	 mov	 QWORD PTR [rax+8], rcx
$LN42@LCS_Init:

; 349  : 
; 350  :     }

  004fb	eb 15		 jmp	 SHORT $LN31@LCS_Init
$LN30@LCS_Init:

; 351  :     else
; 352  :         pLCSBLK = pDEVBLK->group->grp_data;

  004fd	48 8b 84 24 b0
	01 00 00	 mov	 rax, QWORD PTR pDEVBLK$[rsp]
  00505	48 8b 40 60	 mov	 rax, QWORD PTR [rax+96]
  00509	48 8b 40 08	 mov	 rax, QWORD PTR [rax+8]
  0050d	48 89 44 24 78	 mov	 QWORD PTR pLCSBLK$[rsp], rax
$LN31@LCS_Init:

; 353  : 
; 354  :     // When this code is reached the last devblk has been allocated.
; 355  : 
; 356  :     // Now build the LCSDEV's...
; 357  : 
; 358  :     // If an OAT is specified, the addresses that were specified in the
; 359  :     // hercules.cnf file must match those that are specified in the OAT.
; 360  : 
; 361  :     for (pLCSDev = pLCSBLK->pDevices; pLCSDev; pLCSDev = pLCSDev->pNext)

  00512	48 8b 44 24 78	 mov	 rax, QWORD PTR pLCSBLK$[rsp]
  00517	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  0051b	48 89 44 24 70	 mov	 QWORD PTR pLCSDev$[rsp], rax
  00520	eb 0d		 jmp	 SHORT $LN7@LCS_Init
$LN5@LCS_Init:
  00522	48 8b 44 24 70	 mov	 rax, QWORD PTR pLCSDev$[rsp]
  00527	48 8b 00	 mov	 rax, QWORD PTR [rax]
  0052a	48 89 44 24 70	 mov	 QWORD PTR pLCSDev$[rsp], rax
$LN7@LCS_Init:
  0052f	48 83 7c 24 70
	00		 cmp	 QWORD PTR pLCSDev$[rsp], 0
  00535	0f 84 2d 0e 00
	00		 je	 $LN6@LCS_Init

; 362  :     {
; 363  :         pLCSDev->pDEVBLK[LCS_READ_SUBCHANN] = find_group_device( pDEVBLK->group, pLCSDev->sAddr );

  0053b	48 8b 44 24 70	 mov	 rax, QWORD PTR pLCSDev$[rsp]
  00540	0f b7 50 20	 movzx	 edx, WORD PTR [rax+32]
  00544	48 8b 84 24 b0
	01 00 00	 mov	 rax, QWORD PTR pDEVBLK$[rsp]
  0054c	48 8b 48 60	 mov	 rcx, QWORD PTR [rax+96]
  00550	e8 00 00 00 00	 call	 find_group_device
  00555	b9 08 00 00 00	 mov	 ecx, 8
  0055a	48 6b c9 00	 imul	 rcx, rcx, 0
  0055e	48 8b 54 24 70	 mov	 rdx, QWORD PTR pLCSDev$[rsp]
  00563	48 89 44 0a 10	 mov	 QWORD PTR [rdx+rcx+16], rax

; 364  : 
; 365  :         if (!pLCSDev->pDEVBLK[LCS_READ_SUBCHANN])

  00568	b8 08 00 00 00	 mov	 eax, 8
  0056d	48 6b c0 00	 imul	 rax, rax, 0
  00571	48 8b 4c 24 70	 mov	 rcx, QWORD PTR pLCSDev$[rsp]
  00576	48 83 7c 01 10
	00		 cmp	 QWORD PTR [rcx+rax+16], 0
  0057c	0f 85 ce 00 00
	00		 jne	 $LN43@LCS_Init

; 366  :         {
; 367  :             // "%1d:%04X CTC: lcs device %04X not in configuration"
; 368  :             WRMSG( HHC00920, "E", SSID_TO_LCSS( pDEVBLK->group->memdev[0]->ssid ) ,

  00582	48 8b 44 24 70	 mov	 rax, QWORD PTR pLCSDev$[rsp]
  00587	0f b7 40 20	 movzx	 eax, WORD PTR [rax+32]
  0058b	89 84 24 a4 00
	00 00		 mov	 DWORD PTR tv263[rsp], eax
  00592	48 8b 8c 24 b0
	01 00 00	 mov	 rcx, QWORD PTR pDEVBLK$[rsp]
  0059a	48 8b 49 60	 mov	 rcx, QWORD PTR [rcx+96]
  0059e	ba 08 00 00 00	 mov	 edx, 8
  005a3	48 6b d2 00	 imul	 rdx, rdx, 0
  005a7	48 8b 4c 11 10	 mov	 rcx, QWORD PTR [rcx+rdx+16]
  005ac	0f b7 49 48	 movzx	 ecx, WORD PTR [rcx+72]
  005b0	89 8c 24 a8 00
	00 00		 mov	 DWORD PTR tv270[rsp], ecx
  005b7	48 8b 94 24 b0
	01 00 00	 mov	 rdx, QWORD PTR pDEVBLK$[rsp]
  005bf	48 8b 52 60	 mov	 rdx, QWORD PTR [rdx+96]
  005c3	bf 08 00 00 00	 mov	 edi, 8
  005c8	48 6b ff 00	 imul	 rdi, rdi, 0
  005cc	48 8b 54 3a 10	 mov	 rdx, QWORD PTR [rdx+rdi+16]
  005d1	0f b7 52 44	 movzx	 edx, WORD PTR [rdx+68]
  005d5	d1 fa		 sar	 edx, 1
  005d7	89 94 24 ac 00
	00 00		 mov	 DWORD PTR tv278[rsp], edx
  005de	b9 01 00 00 00	 mov	 ecx, 1
  005e3	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  005e9	8b 8c 24 a4 00
	00 00		 mov	 ecx, DWORD PTR tv263[rsp]
  005f0	89 4c 24 48	 mov	 DWORD PTR [rsp+72], ecx
  005f4	8b 8c 24 a8 00
	00 00		 mov	 ecx, DWORD PTR tv270[rsp]
  005fb	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  005ff	8b 8c 24 ac 00
	00 00		 mov	 ecx, DWORD PTR tv278[rsp]
  00606	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  0060a	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169558
  00611	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  00616	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169559
  0061d	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00622	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00627	41 b9 03 00 00
	00		 mov	 r9d, 3
  0062d	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG169560
  00634	ba 71 01 00 00	 mov	 edx, 369		; 00000171H
  00639	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169561
  00640	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 369  :                   pDEVBLK->group->memdev[0]->devnum, pLCSDev->sAddr );
; 370  :             return -1;

  00646	b8 ff ff ff ff	 mov	 eax, -1
  0064b	e9 9c 0e 00 00	 jmp	 $LN1@LCS_Init
$LN43@LCS_Init:

; 371  :         }
; 372  : 
; 373  :         // Establish SENSE ID and Command Information Word data.
; 374  :         // (In SNA mode VTAM checks the first four bytes of the
; 375  :         // Sense ID for 0xFF308801, 0xFF308860 and 0xFF30881F.)
; 376  :         SetSIDInfo( pLCSDev->pDEVBLK[LCS_READ_SUBCHANN], 0x3088, 0x60, 0x3088, 0x01 );

  00650	b8 08 00 00 00	 mov	 eax, 8
  00655	48 6b c0 00	 imul	 rax, rax, 0
  00659	c6 44 24 20 01	 mov	 BYTE PTR [rsp+32], 1
  0065e	66 41 b9 88 30	 mov	 r9w, 12424		; 00003088H
  00663	41 b0 60	 mov	 r8b, 96			; 00000060H
  00666	66 ba 88 30	 mov	 dx, 12424		; 00003088H
  0066a	48 8b 4c 24 70	 mov	 rcx, QWORD PTR pLCSDev$[rsp]
  0066f	48 8b 4c 01 10	 mov	 rcx, QWORD PTR [rcx+rax+16]
  00674	e8 00 00 00 00	 call	 SetSIDInfo

; 377  : //      SetCIWInfo( pLCSDev->pDEVBLK[LCS_READ_SUBCHANN], 0, 0, 0x72, 0x0080 );
; 378  : //      SetCIWInfo( pLCSDev->pDEVBLK[LCS_READ_SUBCHANN], 1, 1, 0x83, 0x0004 );
; 379  : //      SetCIWInfo( pLCSDev->pDEVBLK[LCS_READ_SUBCHANN], 2, 2, 0x82, 0x0040 );
; 380  : 
; 381  :         pLCSDev->pDEVBLK[LCS_READ_SUBCHANN]->ctctype  = CTC_LCS;

  00679	b8 08 00 00 00	 mov	 eax, 8
  0067e	48 6b c0 00	 imul	 rax, rax, 0
  00682	48 8b 4c 24 70	 mov	 rcx, QWORD PTR pLCSDev$[rsp]
  00687	48 8b 44 01 10	 mov	 rax, QWORD PTR [rcx+rax+16]
  0068c	c6 80 1c 07 00
	00 01		 mov	 BYTE PTR [rax+1820], 1

; 382  :         pLCSDev->pDEVBLK[LCS_READ_SUBCHANN]->ctcxmode = 1;

  00693	b8 08 00 00 00	 mov	 eax, 8
  00698	48 6b c0 00	 imul	 rax, rax, 0
  0069c	48 8b 4c 24 70	 mov	 rcx, QWORD PTR pLCSDev$[rsp]
  006a1	48 8b 44 01 10	 mov	 rax, QWORD PTR [rcx+rax+16]
  006a6	8b 80 18 07 00
	00		 mov	 eax, DWORD PTR [rax+1816]
  006ac	83 c8 01	 or	 eax, 1
  006af	b9 08 00 00 00	 mov	 ecx, 8
  006b4	48 6b c9 00	 imul	 rcx, rcx, 0
  006b8	48 8b 54 24 70	 mov	 rdx, QWORD PTR pLCSDev$[rsp]
  006bd	48 8b 4c 0a 10	 mov	 rcx, QWORD PTR [rdx+rcx+16]
  006c2	89 81 18 07 00
	00		 mov	 DWORD PTR [rcx+1816], eax

; 383  :         pLCSDev->pDEVBLK[LCS_READ_SUBCHANN]->dev_data = pLCSDev;

  006c8	b8 08 00 00 00	 mov	 eax, 8
  006cd	48 6b c0 00	 imul	 rax, rax, 0
  006d1	48 8b 4c 24 70	 mov	 rcx, QWORD PTR pLCSDev$[rsp]
  006d6	48 8b 44 01 10	 mov	 rax, QWORD PTR [rcx+rax+16]
  006db	48 8b 4c 24 70	 mov	 rcx, QWORD PTR pLCSDev$[rsp]
  006e0	48 89 88 08 06
	00 00		 mov	 QWORD PTR [rax+1544], rcx

; 384  :         pLCSDev->pLCSBLK              = pLCSBLK;

  006e7	48 8b 44 24 70	 mov	 rax, QWORD PTR pLCSDev$[rsp]
  006ec	48 8b 4c 24 78	 mov	 rcx, QWORD PTR pLCSBLK$[rsp]
  006f1	48 89 48 08	 mov	 QWORD PTR [rax+8], rcx

; 385  :         STRLCPY( pLCSDev->pDEVBLK[LCS_READ_SUBCHANN]->filename, pLCSBLK->pszTUNDevice );

  006f5	b8 08 00 00 00	 mov	 eax, 8
  006fa	48 6b c0 00	 imul	 rax, rax, 0
  006fe	48 8b 4c 24 70	 mov	 rcx, QWORD PTR pLCSDev$[rsp]
  00703	48 8b 44 01 10	 mov	 rax, QWORD PTR [rcx+rax+16]
  00708	48 05 a4 00 00
	00		 add	 rax, 164		; 000000a4H
  0070e	41 b8 05 01 00
	00		 mov	 r8d, 261		; 00000105H
  00714	48 8b 4c 24 78	 mov	 rcx, QWORD PTR pLCSBLK$[rsp]
  00719	48 8b 11	 mov	 rdx, QWORD PTR [rcx]
  0071c	48 8b c8	 mov	 rcx, rax
  0071f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_strlcpy

; 386  : 
; 387  :         // If this is an IP Passthru address, we need a write address
; 388  :         if (pLCSDev->bMode == LCSDEV_MODE_IP)

  00725	48 8b 44 24 70	 mov	 rax, QWORD PTR pLCSDev$[rsp]
  0072a	0f b6 40 22	 movzx	 eax, BYTE PTR [rax+34]
  0072e	83 f8 01	 cmp	 eax, 1
  00731	0f 85 e5 01 00
	00		 jne	 $LN44@LCS_Init

; 389  :         {
; 390  :             // (the write device is the inverse of the read device)
; 391  :             pLCSDev->pDEVBLK[LCS_WRITE_SUBCHANN] = find_group_device( pDEVBLK->group, pLCSDev->sAddr ^ 1 );

  00737	48 8b 44 24 70	 mov	 rax, QWORD PTR pLCSDev$[rsp]
  0073c	0f b7 40 20	 movzx	 eax, WORD PTR [rax+32]
  00740	83 f0 01	 xor	 eax, 1
  00743	0f b7 d0	 movzx	 edx, ax
  00746	48 8b 84 24 b0
	01 00 00	 mov	 rax, QWORD PTR pDEVBLK$[rsp]
  0074e	48 8b 48 60	 mov	 rcx, QWORD PTR [rax+96]
  00752	e8 00 00 00 00	 call	 find_group_device
  00757	b9 08 00 00 00	 mov	 ecx, 8
  0075c	48 6b c9 01	 imul	 rcx, rcx, 1
  00760	48 8b 54 24 70	 mov	 rdx, QWORD PTR pLCSDev$[rsp]
  00765	48 89 44 0a 10	 mov	 QWORD PTR [rdx+rcx+16], rax

; 392  : 
; 393  :             if (!pLCSDev->pDEVBLK[LCS_WRITE_SUBCHANN])

  0076a	b8 08 00 00 00	 mov	 eax, 8
  0076f	48 6b c0 01	 imul	 rax, rax, 1
  00773	48 8b 4c 24 70	 mov	 rcx, QWORD PTR pLCSDev$[rsp]
  00778	48 83 7c 01 10
	00		 cmp	 QWORD PTR [rcx+rax+16], 0
  0077e	0f 85 d1 00 00
	00		 jne	 $LN45@LCS_Init

; 394  :             {
; 395  :                 // "%1d:%04X CTC: lcs device %04X not in configuration"
; 396  :                 WRMSG( HHC00920, "E", SSID_TO_LCSS( pDEVBLK->group->memdev[0]->ssid ),

  00784	48 8b 44 24 70	 mov	 rax, QWORD PTR pLCSDev$[rsp]
  00789	0f b7 40 20	 movzx	 eax, WORD PTR [rax+32]
  0078d	83 f0 01	 xor	 eax, 1
  00790	89 84 24 b0 00
	00 00		 mov	 DWORD PTR tv343[rsp], eax
  00797	48 8b 8c 24 b0
	01 00 00	 mov	 rcx, QWORD PTR pDEVBLK$[rsp]
  0079f	48 8b 49 60	 mov	 rcx, QWORD PTR [rcx+96]
  007a3	ba 08 00 00 00	 mov	 edx, 8
  007a8	48 6b d2 00	 imul	 rdx, rdx, 0
  007ac	48 8b 4c 11 10	 mov	 rcx, QWORD PTR [rcx+rdx+16]
  007b1	0f b7 49 48	 movzx	 ecx, WORD PTR [rcx+72]
  007b5	89 8c 24 b4 00
	00 00		 mov	 DWORD PTR tv350[rsp], ecx
  007bc	48 8b 94 24 b0
	01 00 00	 mov	 rdx, QWORD PTR pDEVBLK$[rsp]
  007c4	48 8b 52 60	 mov	 rdx, QWORD PTR [rdx+96]
  007c8	bf 08 00 00 00	 mov	 edi, 8
  007cd	48 6b ff 00	 imul	 rdi, rdi, 0
  007d1	48 8b 54 3a 10	 mov	 rdx, QWORD PTR [rdx+rdi+16]
  007d6	0f b7 52 44	 movzx	 edx, WORD PTR [rdx+68]
  007da	d1 fa		 sar	 edx, 1
  007dc	89 94 24 b8 00
	00 00		 mov	 DWORD PTR tv358[rsp], edx
  007e3	b9 01 00 00 00	 mov	 ecx, 1
  007e8	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  007ee	8b 8c 24 b0 00
	00 00		 mov	 ecx, DWORD PTR tv343[rsp]
  007f5	89 4c 24 48	 mov	 DWORD PTR [rsp+72], ecx
  007f9	8b 8c 24 b4 00
	00 00		 mov	 ecx, DWORD PTR tv350[rsp]
  00800	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  00804	8b 8c 24 b8 00
	00 00		 mov	 ecx, DWORD PTR tv358[rsp]
  0080b	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  0080f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169564
  00816	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  0081b	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169565
  00822	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00827	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  0082c	41 b9 03 00 00
	00		 mov	 r9d, 3
  00832	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG169566
  00839	ba 8d 01 00 00	 mov	 edx, 397		; 0000018dH
  0083e	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169567
  00845	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 397  :                       pDEVBLK->group->memdev[0]->devnum, pLCSDev->sAddr ^ 1 );
; 398  :                 return -1;

  0084b	b8 ff ff ff ff	 mov	 eax, -1
  00850	e9 97 0c 00 00	 jmp	 $LN1@LCS_Init
$LN45@LCS_Init:

; 399  :             }
; 400  : 
; 401  :             // Establish SENSE ID and Command Information Word data.
; 402  :             SetSIDInfo( pLCSDev->pDEVBLK[LCS_WRITE_SUBCHANN], 0x3088, 0x60, 0x3088, 0x01 );

  00855	b8 08 00 00 00	 mov	 eax, 8
  0085a	48 6b c0 01	 imul	 rax, rax, 1
  0085e	c6 44 24 20 01	 mov	 BYTE PTR [rsp+32], 1
  00863	66 41 b9 88 30	 mov	 r9w, 12424		; 00003088H
  00868	41 b0 60	 mov	 r8b, 96			; 00000060H
  0086b	66 ba 88 30	 mov	 dx, 12424		; 00003088H
  0086f	48 8b 4c 24 70	 mov	 rcx, QWORD PTR pLCSDev$[rsp]
  00874	48 8b 4c 01 10	 mov	 rcx, QWORD PTR [rcx+rax+16]
  00879	e8 00 00 00 00	 call	 SetSIDInfo

; 403  : //          SetCIWInfo( pLCSDev->pDEVBLK[LCS_WRITE_SUBCHANN], 0, 0, 0x72, 0x0080 );
; 404  : //          SetCIWInfo( pLCSDev->pDEVBLK[LCS_WRITE_SUBCHANN], 1, 1, 0x83, 0x0004 );
; 405  : //          SetCIWInfo( pLCSDev->pDEVBLK[LCS_WRITE_SUBCHANN], 2, 2, 0x82, 0x0040 );
; 406  : 
; 407  :             pLCSDev->pDEVBLK[LCS_WRITE_SUBCHANN]->ctctype  = CTC_LCS;

  0087e	b8 08 00 00 00	 mov	 eax, 8
  00883	48 6b c0 01	 imul	 rax, rax, 1
  00887	48 8b 4c 24 70	 mov	 rcx, QWORD PTR pLCSDev$[rsp]
  0088c	48 8b 44 01 10	 mov	 rax, QWORD PTR [rcx+rax+16]
  00891	c6 80 1c 07 00
	00 01		 mov	 BYTE PTR [rax+1820], 1

; 408  :             pLCSDev->pDEVBLK[LCS_WRITE_SUBCHANN]->ctcxmode = 1;

  00898	b8 08 00 00 00	 mov	 eax, 8
  0089d	48 6b c0 01	 imul	 rax, rax, 1
  008a1	48 8b 4c 24 70	 mov	 rcx, QWORD PTR pLCSDev$[rsp]
  008a6	48 8b 44 01 10	 mov	 rax, QWORD PTR [rcx+rax+16]
  008ab	8b 80 18 07 00
	00		 mov	 eax, DWORD PTR [rax+1816]
  008b1	83 c8 01	 or	 eax, 1
  008b4	b9 08 00 00 00	 mov	 ecx, 8
  008b9	48 6b c9 01	 imul	 rcx, rcx, 1
  008bd	48 8b 54 24 70	 mov	 rdx, QWORD PTR pLCSDev$[rsp]
  008c2	48 8b 4c 0a 10	 mov	 rcx, QWORD PTR [rdx+rcx+16]
  008c7	89 81 18 07 00
	00		 mov	 DWORD PTR [rcx+1816], eax

; 409  :             pLCSDev->pDEVBLK[LCS_WRITE_SUBCHANN]->dev_data = pLCSDev;

  008cd	b8 08 00 00 00	 mov	 eax, 8
  008d2	48 6b c0 01	 imul	 rax, rax, 1
  008d6	48 8b 4c 24 70	 mov	 rcx, QWORD PTR pLCSDev$[rsp]
  008db	48 8b 44 01 10	 mov	 rax, QWORD PTR [rcx+rax+16]
  008e0	48 8b 4c 24 70	 mov	 rcx, QWORD PTR pLCSDev$[rsp]
  008e5	48 89 88 08 06
	00 00		 mov	 QWORD PTR [rax+1544], rcx

; 410  : 
; 411  :             STRLCPY( pLCSDev->pDEVBLK[LCS_WRITE_SUBCHANN]->filename, pLCSBLK->pszTUNDevice );

  008ec	b8 08 00 00 00	 mov	 eax, 8
  008f1	48 6b c0 01	 imul	 rax, rax, 1
  008f5	48 8b 4c 24 70	 mov	 rcx, QWORD PTR pLCSDev$[rsp]
  008fa	48 8b 44 01 10	 mov	 rax, QWORD PTR [rcx+rax+16]
  008ff	48 05 a4 00 00
	00		 add	 rax, 164		; 000000a4H
  00905	41 b8 05 01 00
	00		 mov	 r8d, 261		; 00000105H
  0090b	48 8b 4c 24 78	 mov	 rcx, QWORD PTR pLCSBLK$[rsp]
  00910	48 8b 11	 mov	 rdx, QWORD PTR [rcx]
  00913	48 8b c8	 mov	 rcx, rax
  00916	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_strlcpy
$LN44@LCS_Init:

; 412  :         }
; 413  : 
; 414  :         // Initialize the buffer size. See the programming note re
; 415  :         // frame buffer size in ctcadpt.h, and note that the LCS_Startup
; 416  :         // command might reduce the value in pLCSDEV->iMaxFrameBufferSize.
; 417  :         // For SNA, the LCS_Startup command seems to be not used.
; 418  :         pLCSDev->iMaxFrameBufferSize = sizeof(pLCSDev->bFrameBuffer);

  0091c	b8 00 50 00 00	 mov	 eax, 20480		; 00005000H
  00921	48 8b 4c 24 70	 mov	 rcx, QWORD PTR pLCSDev$[rsp]
  00926	66 89 81 a4 00
	00 00		 mov	 WORD PTR [rcx+164], ax

; 419  : 
; 420  :         // Indicate that the DEVBLK(s) have been create sucessfully
; 421  :         pLCSDev->fDevCreated = 1;

  0092d	48 8b 44 24 70	 mov	 rax, QWORD PTR pLCSDev$[rsp]
  00932	8b 40 41	 mov	 eax, DWORD PTR [rax+65]
  00935	83 c8 01	 or	 eax, 1
  00938	48 8b 4c 24 70	 mov	 rcx, QWORD PTR pLCSDev$[rsp]
  0093d	89 41 41	 mov	 DWORD PTR [rcx+65], eax

; 422  : 
; 423  :         // Initialize locking and event mechanisms
; 424  :         initialize_lock( &pLCSDev->DevDataLock );

  00940	48 8b 44 24 70	 mov	 rax, QWORD PTR pLCSDev$[rsp]
  00945	48 05 9a 00 00
	00		 add	 rax, 154		; 0000009aH
  0094b	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG169568
  00952	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG169569
  00959	48 8b c8	 mov	 rcx, rax
  0095c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_initialize_lock

; 425  :         initialize_lock( &pLCSDev->DevEventLock );

  00962	48 8b 44 24 70	 mov	 rax, QWORD PTR pLCSDev$[rsp]
  00967	48 83 c0 31	 add	 rax, 49			; 00000031H
  0096b	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG169570
  00972	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG169571
  00979	48 8b c8	 mov	 rcx, rax
  0097c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_initialize_lock

; 426  :         initialize_condition( &pLCSDev->DevEvent );

  00982	48 8b 44 24 70	 mov	 rax, QWORD PTR pLCSDev$[rsp]
  00987	48 83 c0 39	 add	 rax, 57			; 00000039H
  0098b	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG169572
  00992	48 8b c8	 mov	 rcx, rax
  00995	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_initialize_condition

; 427  :         initialize_lock( &pLCSDev->LCSIBHChainLock );

  0099b	48 8b 44 24 70	 mov	 rax, QWORD PTR pLCSDev$[rsp]
  009a0	48 83 c0 6a	 add	 rax, 106		; 0000006aH
  009a4	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG169573
  009ab	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG169574
  009b2	48 8b c8	 mov	 rcx, rax
  009b5	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_initialize_lock

; 428  :         initialize_lock( &pLCSDev->LCSCONNChainLock );

  009bb	48 8b 44 24 70	 mov	 rax, QWORD PTR pLCSDev$[rsp]
  009c0	48 05 82 00 00
	00		 add	 rax, 130		; 00000082H
  009c6	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG169575
  009cd	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG169576
  009d4	48 8b c8	 mov	 rcx, rax
  009d7	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_initialize_lock

; 429  :         initialize_lock( &pLCSDev->InOutLock );

  009dd	48 8b 44 24 70	 mov	 rax, QWORD PTR pLCSDev$[rsp]
  009e2	48 05 92 00 00
	00		 add	 rax, 146		; 00000092H
  009e8	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG169577
  009ef	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG169578
  009f6	48 8b c8	 mov	 rcx, rax
  009f9	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_initialize_lock

; 430  : 
; 431  :         // Create the TAP interface (if not already created by a
; 432  :         // previous pass. More than one interface can exist on a port.
; 433  : 
; 434  :         pLCSPORT = &pLCSBLK->Port[ pLCSDev->bPort ];

  009ff	48 8b 44 24 70	 mov	 rax, QWORD PTR pLCSDev$[rsp]
  00a04	0f b6 40 23	 movzx	 eax, BYTE PTR [rax+35]
  00a08	48 69 c0 98 01
	00 00		 imul	 rax, rax, 408		; 00000198H
  00a0f	48 8b 4c 24 78	 mov	 rcx, QWORD PTR pLCSBLK$[rsp]
  00a14	48 8d 44 01 60	 lea	 rax, QWORD PTR [rcx+rax+96]
  00a19	48 89 84 24 80
	00 00 00	 mov	 QWORD PTR pLCSPORT$[rsp], rax

; 435  : 
; 436  :         if (!pLCSPORT->fPortCreated)

  00a21	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR pLCSPORT$[rsp]
  00a29	8b 80 34 01 00
	00		 mov	 eax, DWORD PTR [rax+308]
  00a2f	c1 e8 02	 shr	 eax, 2
  00a32	83 e0 01	 and	 eax, 1
  00a35	85 c0		 test	 eax, eax
  00a37	0f 85 a4 08 00
	00		 jne	 $LN46@LCS_Init

; 437  :         {
; 438  :             int  rc;
; 439  : 
; 440  :             rc = TUNTAP_CreateInterface( pLCSBLK->pszTUNDevice,

  00a3d	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR pLCSPORT$[rsp]
  00a45	48 05 48 01 00
	00		 add	 rax, 328		; 00000148H
  00a4b	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR pLCSPORT$[rsp]
  00a53	48 81 c1 38 01
	00 00		 add	 rcx, 312		; 00000138H
  00a5a	4c 8b c8	 mov	 r9, rax
  00a5d	4c 8b c1	 mov	 r8, rcx
  00a60	ba 02 10 00 00	 mov	 edx, 4098		; 00001002H
  00a65	48 8b 44 24 78	 mov	 rax, QWORD PTR pLCSBLK$[rsp]
  00a6a	48 8b 08	 mov	 rcx, QWORD PTR [rax]
  00a6d	e8 00 00 00 00	 call	 TUNTAP_CreateInterface
  00a72	89 84 24 90 00
	00 00		 mov	 DWORD PTR rc$1[rsp], eax

; 441  :                                          IFF_TAP | IFF_NO_PI,
; 442  :                                          &pLCSPORT->fd,
; 443  :                                          pLCSPORT->szNetIfName );
; 444  : 
; 445  :             if (rc < 0)

  00a79	83 bc 24 90 00
	00 00 00	 cmp	 DWORD PTR rc$1[rsp], 0
  00a81	0f 8d f1 00 00
	00		 jge	 $LN47@LCS_Init

; 446  :             {
; 447  :                 // "%1d:%04X %s: error in function %s: %s"
; 448  :                 WRMSG( HHC00900, "E", SSID_TO_LCSS( pLCSDev->pDEVBLK[LCS_READ_SUBCHANN]->ssid),

  00a87	8b 8c 24 90 00
	00 00		 mov	 ecx, DWORD PTR rc$1[rsp]
  00a8e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_strerror
  00a94	48 89 84 24 d8
	00 00 00	 mov	 QWORD PTR tv447[rsp], rax
  00a9c	b9 08 00 00 00	 mov	 ecx, 8
  00aa1	48 6b c9 00	 imul	 rcx, rcx, 0
  00aa5	48 8b 54 24 70	 mov	 rdx, QWORD PTR pLCSDev$[rsp]
  00aaa	48 8b 4c 0a 10	 mov	 rcx, QWORD PTR [rdx+rcx+16]
  00aaf	48 89 8c 24 e0
	00 00 00	 mov	 QWORD PTR tv881[rsp], rcx
  00ab7	ba 08 00 00 00	 mov	 edx, 8
  00abc	48 6b d2 00	 imul	 rdx, rdx, 0
  00ac0	48 8b 7c 24 70	 mov	 rdi, QWORD PTR pLCSDev$[rsp]
  00ac5	48 8b 54 17 10	 mov	 rdx, QWORD PTR [rdi+rdx+16]
  00aca	0f b7 52 48	 movzx	 edx, WORD PTR [rdx+72]
  00ace	89 94 24 bc 00
	00 00		 mov	 DWORD PTR tv492[rsp], edx
  00ad5	bf 08 00 00 00	 mov	 edi, 8
  00ada	48 6b ff 00	 imul	 rdi, rdi, 0
  00ade	4c 8b 44 24 70	 mov	 r8, QWORD PTR pLCSDev$[rsp]
  00ae3	49 8b 7c 38 10	 mov	 rdi, QWORD PTR [r8+rdi+16]
  00ae8	0f b7 7f 44	 movzx	 edi, WORD PTR [rdi+68]
  00aec	d1 ff		 sar	 edi, 1
  00aee	b9 01 00 00 00	 mov	 ecx, 1
  00af3	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  00af9	48 8b 8c 24 d8
	00 00 00	 mov	 rcx, QWORD PTR tv447[rsp]
  00b01	48 89 4c 24 58	 mov	 QWORD PTR [rsp+88], rcx
  00b06	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169581
  00b0d	48 89 4c 24 50	 mov	 QWORD PTR [rsp+80], rcx
  00b12	48 8b 8c 24 e0
	00 00 00	 mov	 rcx, QWORD PTR tv881[rsp]
  00b1a	48 8b 49 50	 mov	 rcx, QWORD PTR [rcx+80]
  00b1e	48 89 4c 24 48	 mov	 QWORD PTR [rsp+72], rcx
  00b23	8b 8c 24 bc 00
	00 00		 mov	 ecx, DWORD PTR tv492[rsp]
  00b2a	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  00b2e	89 7c 24 38	 mov	 DWORD PTR [rsp+56], edi
  00b32	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169582
  00b39	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  00b3e	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169583
  00b45	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00b4a	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00b4f	41 b9 03 00 00
	00		 mov	 r9d, 3
  00b55	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG169584
  00b5c	ba c2 01 00 00	 mov	 edx, 450		; 000001c2H
  00b61	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169585
  00b68	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 449  :                     pLCSDev->pDEVBLK[LCS_READ_SUBCHANN]->devnum, pLCSDev->pDEVBLK[LCS_READ_SUBCHANN]->typname,
; 450  :                     "TUNTAP_CreateInterface", strerror( rc ));
; 451  :                 return -1;

  00b6e	b8 ff ff ff ff	 mov	 eax, -1
  00b73	e9 74 09 00 00	 jmp	 $LN1@LCS_Init
$LN47@LCS_Init:

; 452  :             }
; 453  : 
; 454  :             // "%1d:%04X %s: interface %s, type %s opened"
; 455  :             WRMSG( HHC00901, "I", SSID_TO_LCSS( pLCSDev->pDEVBLK[LCS_READ_SUBCHANN]->ssid ),

  00b78	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR pLCSPORT$[rsp]
  00b80	48 05 48 01 00
	00		 add	 rax, 328		; 00000148H
  00b86	48 89 84 24 e8
	00 00 00	 mov	 QWORD PTR tv511[rsp], rax
  00b8e	b9 08 00 00 00	 mov	 ecx, 8
  00b93	48 6b c9 00	 imul	 rcx, rcx, 0
  00b97	48 8b 54 24 70	 mov	 rdx, QWORD PTR pLCSDev$[rsp]
  00b9c	48 8b 4c 0a 10	 mov	 rcx, QWORD PTR [rdx+rcx+16]
  00ba1	48 89 8c 24 f0
	00 00 00	 mov	 QWORD PTR tv878[rsp], rcx
  00ba9	ba 08 00 00 00	 mov	 edx, 8
  00bae	48 6b d2 00	 imul	 rdx, rdx, 0
  00bb2	48 8b 7c 24 70	 mov	 rdi, QWORD PTR pLCSDev$[rsp]
  00bb7	48 8b 54 17 10	 mov	 rdx, QWORD PTR [rdi+rdx+16]
  00bbc	0f b7 52 48	 movzx	 edx, WORD PTR [rdx+72]
  00bc0	89 94 24 c0 00
	00 00		 mov	 DWORD PTR tv522[rsp], edx
  00bc7	bf 08 00 00 00	 mov	 edi, 8
  00bcc	48 6b ff 00	 imul	 rdi, rdi, 0
  00bd0	4c 8b 44 24 70	 mov	 r8, QWORD PTR pLCSDev$[rsp]
  00bd5	49 8b 7c 38 10	 mov	 rdi, QWORD PTR [r8+rdi+16]
  00bda	0f b7 7f 44	 movzx	 edi, WORD PTR [rdi+68]
  00bde	d1 ff		 sar	 edi, 1
  00be0	b9 01 00 00 00	 mov	 ecx, 1
  00be5	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  00beb	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169586
  00bf2	48 89 4c 24 58	 mov	 QWORD PTR [rsp+88], rcx
  00bf7	48 8b 8c 24 e8
	00 00 00	 mov	 rcx, QWORD PTR tv511[rsp]
  00bff	48 89 4c 24 50	 mov	 QWORD PTR [rsp+80], rcx
  00c04	48 8b 8c 24 f0
	00 00 00	 mov	 rcx, QWORD PTR tv878[rsp]
  00c0c	48 8b 49 50	 mov	 rcx, QWORD PTR [rcx+80]
  00c10	48 89 4c 24 48	 mov	 QWORD PTR [rsp+72], rcx
  00c15	8b 8c 24 c0 00
	00 00		 mov	 ecx, DWORD PTR tv522[rsp]
  00c1c	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  00c20	89 7c 24 38	 mov	 DWORD PTR [rsp+56], edi
  00c24	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169587
  00c2b	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  00c30	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169588
  00c37	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00c3c	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00c41	41 b9 03 00 00
	00		 mov	 r9d, 3
  00c47	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG169589
  00c4e	ba ca 01 00 00	 mov	 edx, 458		; 000001caH
  00c53	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169590
  00c5a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 456  :                                   pLCSDev->pDEVBLK[LCS_READ_SUBCHANN]->devnum,
; 457  :                                   pLCSDev->pDEVBLK[LCS_READ_SUBCHANN]->typname,
; 458  :                                   pLCSPORT->szNetIfName, "TAP");
; 459  : 
; 460  :             //
; 461  :             if (!pLCSPORT->fPreconfigured)

  00c60	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR pLCSPORT$[rsp]
  00c68	8b 80 34 01 00
	00		 mov	 eax, DWORD PTR [rax+308]
  00c6e	c1 e8 06	 shr	 eax, 6
  00c71	83 e0 01	 and	 eax, 1
  00c74	85 c0		 test	 eax, eax
  00c76	0f 85 b8 01 00
	00		 jne	 $LN48@LCS_Init

; 462  :             {
; 463  : #ifdef OPTION_TUNTAP_SETMACADDR
; 464  :                 if (pLCSPORT->fLocalMAC)

  00c7c	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR pLCSPORT$[rsp]
  00c84	8b 80 34 01 00
	00		 mov	 eax, DWORD PTR [rax+308]
  00c8a	d1 e8		 shr	 eax, 1
  00c8c	83 e0 01	 and	 eax, 1
  00c8f	85 c0		 test	 eax, eax
  00c91	0f 84 8f 00 00
	00		 je	 $LN49@LCS_Init
$LN10@LCS_Init:

; 465  :                 {
; 466  :                     VERIFY( TUNTAP_SetMACAddr( pLCSPORT->szNetIfName,

  00c97	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR pLCSPORT$[rsp]
  00c9f	48 05 58 01 00
	00		 add	 rax, 344		; 00000158H
  00ca5	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR pLCSPORT$[rsp]
  00cad	48 81 c1 48 01
	00 00		 add	 rcx, 328		; 00000148H
  00cb4	48 8b d0	 mov	 rdx, rax
  00cb7	e8 00 00 00 00	 call	 TUNTAP_SetMACAddr
  00cbc	85 c0		 test	 eax, eax
  00cbe	74 5c		 je	 SHORT $LN50@LCS_Init
$LN13@LCS_Init:
  00cc0	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG169594
  00cc7	41 b8 d3 01 00
	00		 mov	 r8d, 467		; 000001d3H
  00ccd	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG169595
  00cd4	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169596
  00cdb	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_logmsg
  00ce1	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_IsDebuggerPresent
  00ce7	85 c0		 test	 eax, eax
  00ce9	74 20		 je	 SHORT $LN51@LCS_Init
  00ceb	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG169598
  00cf2	41 b8 d3 01 00
	00		 mov	 r8d, 467		; 000001d3H
  00cf8	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG169599
  00cff	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169600
  00d06	e8 00 00 00 00	 call	 DebuggerTrace
$LN51@LCS_Init:
  00d0b	33 c0		 xor	 eax, eax
  00d0d	85 c0		 test	 eax, eax
  00d0f	75 af		 jne	 SHORT $LN13@LCS_Init
  00d11	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_IsDebuggerPresent
  00d17	85 c0		 test	 eax, eax
  00d19	74 01		 je	 SHORT $LN52@LCS_Init
  00d1b	cc		 int	 3
$LN52@LCS_Init:
$LN50@LCS_Init:
  00d1c	33 c0		 xor	 eax, eax
  00d1e	85 c0		 test	 eax, eax
  00d20	0f 85 71 ff ff
	ff		 jne	 $LN10@LCS_Init
$LN49@LCS_Init:
$LN16@LCS_Init:

; 467  :                                                pLCSPORT->szMACAddress ) == 0 );
; 468  :                 }
; 469  : #endif // OPTION_TUNTAP_SETMACADDR
; 470  :                 VERIFY( TUNTAP_SetMTU( pLCSPORT->szNetIfName, "1500" ) == 0 );

  00d26	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR pLCSPORT$[rsp]
  00d2e	48 05 48 01 00
	00		 add	 rax, 328		; 00000148H
  00d34	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG169603
  00d3b	48 8b c8	 mov	 rcx, rax
  00d3e	e8 00 00 00 00	 call	 TUNTAP_SetMTU
  00d43	85 c0		 test	 eax, eax
  00d45	74 5c		 je	 SHORT $LN53@LCS_Init
$LN19@LCS_Init:
  00d47	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG169604
  00d4e	41 b8 d6 01 00
	00		 mov	 r8d, 470		; 000001d6H
  00d54	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG169605
  00d5b	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169606
  00d62	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_logmsg
  00d68	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_IsDebuggerPresent
  00d6e	85 c0		 test	 eax, eax
  00d70	74 20		 je	 SHORT $LN54@LCS_Init
  00d72	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG169608
  00d79	41 b8 d6 01 00
	00		 mov	 r8d, 470		; 000001d6H
  00d7f	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG169609
  00d86	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169610
  00d8d	e8 00 00 00 00	 call	 DebuggerTrace
$LN54@LCS_Init:
  00d92	33 c0		 xor	 eax, eax
  00d94	85 c0		 test	 eax, eax
  00d96	75 af		 jne	 SHORT $LN19@LCS_Init
  00d98	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_IsDebuggerPresent
  00d9e	85 c0		 test	 eax, eax
  00da0	74 01		 je	 SHORT $LN55@LCS_Init
  00da2	cc		 int	 3
$LN55@LCS_Init:
$LN53@LCS_Init:
  00da3	33 c0		 xor	 eax, eax
  00da5	85 c0		 test	 eax, eax
  00da7	0f 85 79 ff ff
	ff		 jne	 $LN16@LCS_Init
$LN22@LCS_Init:

; 471  :                 VERIFY( TUNTAP_SetIPAddr( pLCSPORT->szNetIfName, "0.0.0.0" ) == 0 );

  00dad	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR pLCSPORT$[rsp]
  00db5	48 05 48 01 00
	00		 add	 rax, 328		; 00000148H
  00dbb	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG169613
  00dc2	48 8b c8	 mov	 rcx, rax
  00dc5	e8 00 00 00 00	 call	 TUNTAP_SetIPAddr
  00dca	85 c0		 test	 eax, eax
  00dcc	74 5c		 je	 SHORT $LN56@LCS_Init
$LN25@LCS_Init:
  00dce	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG169614
  00dd5	41 b8 d7 01 00
	00		 mov	 r8d, 471		; 000001d7H
  00ddb	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG169615
  00de2	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169616
  00de9	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_logmsg
  00def	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_IsDebuggerPresent
  00df5	85 c0		 test	 eax, eax
  00df7	74 20		 je	 SHORT $LN57@LCS_Init
  00df9	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG169618
  00e00	41 b8 d7 01 00
	00		 mov	 r8d, 471		; 000001d7H
  00e06	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG169619
  00e0d	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169620
  00e14	e8 00 00 00 00	 call	 DebuggerTrace
$LN57@LCS_Init:
  00e19	33 c0		 xor	 eax, eax
  00e1b	85 c0		 test	 eax, eax
  00e1d	75 af		 jne	 SHORT $LN25@LCS_Init
  00e1f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_IsDebuggerPresent
  00e25	85 c0		 test	 eax, eax
  00e27	74 01		 je	 SHORT $LN58@LCS_Init
  00e29	cc		 int	 3
$LN58@LCS_Init:
$LN56@LCS_Init:
  00e2a	33 c0		 xor	 eax, eax
  00e2c	85 c0		 test	 eax, eax
  00e2e	0f 85 79 ff ff
	ff		 jne	 $LN22@LCS_Init
$LN48@LCS_Init:

; 472  :             }
; 473  : 
; 474  : #if defined(OPTION_W32_CTCI)
; 475  : 
; 476  :             // Set the specified driver/dll i/o buffer sizes..
; 477  :             {
; 478  :                 struct tt32ctl tt32ctl;
; 479  : 
; 480  :                 memset( &tt32ctl, 0, sizeof( tt32ctl ));

  00e34	48 8d 84 24 38
	01 00 00	 lea	 rax, QWORD PTR tt32ctl$2[rsp]
  00e3c	48 8b f8	 mov	 rdi, rax
  00e3f	33 c0		 xor	 eax, eax
  00e41	b9 14 00 00 00	 mov	 ecx, 20
  00e46	f3 aa		 rep stosb

; 481  :                 STRLCPY( tt32ctl.tt32ctl_name, pLCSPORT->szNetIfName );

  00e48	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR pLCSPORT$[rsp]
  00e50	48 05 48 01 00
	00		 add	 rax, 328		; 00000148H
  00e56	41 b8 10 00 00
	00		 mov	 r8d, 16
  00e5c	48 8b d0	 mov	 rdx, rax
  00e5f	48 8d 8c 24 38
	01 00 00	 lea	 rcx, QWORD PTR tt32ctl$2[rsp]
  00e67	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_strlcpy

; 482  : 
; 483  :                 tt32ctl.tt32ctl_devbuffsize = pLCSBLK->iKernBuff;

  00e6d	48 8b 44 24 78	 mov	 rax, QWORD PTR pLCSBLK$[rsp]
  00e72	8b 40 20	 mov	 eax, DWORD PTR [rax+32]
  00e75	89 84 24 48 01
	00 00		 mov	 DWORD PTR tt32ctl$2[rsp+16], eax

; 484  : 
; 485  :                 if (TUNTAP_IOCtl( pLCSPORT->fd, TT32SDEVBUFF, (char*) &tt32ctl ) != 0)

  00e7c	4c 8d 84 24 38
	01 00 00	 lea	 r8, QWORD PTR tt32ctl$2[rsp]
  00e84	ba dc 54 04 80	 mov	 edx, -2147199780	; ffffffff800454dcH
  00e89	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR pLCSPORT$[rsp]
  00e91	8b 88 38 01 00
	00		 mov	 ecx, DWORD PTR [rax+312]
  00e97	e8 00 00 00 00	 call	 tt32_ioctl
  00e9c	85 c0		 test	 eax, eax
  00e9e	0f 84 10 01 00
	00		 je	 $LN59@LCS_Init

; 486  :                 {
; 487  :                     // "%1d:%04X %s: ioctl %s failed for device %s: %s"
; 488  :                     WRMSG( HHC00902, "W", SSID_TO_LCSS( pLCSDev->pDEVBLK[LCS_READ_SUBCHANN]->ssid ),

  00ea4	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno
  00eaa	8b 08		 mov	 ecx, DWORD PTR [rax]
  00eac	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_strerror
  00eb2	48 89 84 24 f8
	00 00 00	 mov	 QWORD PTR tv621[rsp], rax
  00eba	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR pLCSPORT$[rsp]
  00ec2	48 81 c1 48 01
	00 00		 add	 rcx, 328		; 00000148H
  00ec9	48 89 8c 24 00
	01 00 00	 mov	 QWORD PTR tv625[rsp], rcx
  00ed1	ba 08 00 00 00	 mov	 edx, 8
  00ed6	48 6b d2 00	 imul	 rdx, rdx, 0
  00eda	48 8b 7c 24 70	 mov	 rdi, QWORD PTR pLCSDev$[rsp]
  00edf	48 8b 54 17 10	 mov	 rdx, QWORD PTR [rdi+rdx+16]
  00ee4	48 89 94 24 08
	01 00 00	 mov	 QWORD PTR tv875[rsp], rdx
  00eec	bf 08 00 00 00	 mov	 edi, 8
  00ef1	48 6b ff 00	 imul	 rdi, rdi, 0
  00ef5	4c 8b 44 24 70	 mov	 r8, QWORD PTR pLCSDev$[rsp]
  00efa	49 8b 7c 38 10	 mov	 rdi, QWORD PTR [r8+rdi+16]
  00eff	0f b7 7f 48	 movzx	 edi, WORD PTR [rdi+72]
  00f03	41 b8 08 00 00
	00		 mov	 r8d, 8
  00f09	4d 6b c0 00	 imul	 r8, r8, 0
  00f0d	4c 8b 4c 24 70	 mov	 r9, QWORD PTR pLCSDev$[rsp]
  00f12	4f 8b 44 01 10	 mov	 r8, QWORD PTR [r9+r8+16]
  00f17	45 0f b7 40 44	 movzx	 r8d, WORD PTR [r8+68]
  00f1c	41 d1 f8	 sar	 r8d, 1
  00f1f	44 89 84 24 c4
	00 00 00	 mov	 DWORD PTR tv676[rsp], r8d
  00f27	b9 01 00 00 00	 mov	 ecx, 1
  00f2c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  00f32	48 8b 8c 24 f8
	00 00 00	 mov	 rcx, QWORD PTR tv621[rsp]
  00f3a	48 89 4c 24 60	 mov	 QWORD PTR [rsp+96], rcx
  00f3f	48 8b 8c 24 00
	01 00 00	 mov	 rcx, QWORD PTR tv625[rsp]
  00f47	48 89 4c 24 58	 mov	 QWORD PTR [rsp+88], rcx
  00f4c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169623
  00f53	48 89 4c 24 50	 mov	 QWORD PTR [rsp+80], rcx
  00f58	48 8b 8c 24 08
	01 00 00	 mov	 rcx, QWORD PTR tv875[rsp]
  00f60	48 8b 49 50	 mov	 rcx, QWORD PTR [rcx+80]
  00f64	48 89 4c 24 48	 mov	 QWORD PTR [rsp+72], rcx
  00f69	89 7c 24 40	 mov	 DWORD PTR [rsp+64], edi
  00f6d	8b 8c 24 c4 00
	00 00		 mov	 ecx, DWORD PTR tv676[rsp]
  00f74	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  00f78	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169624
  00f7f	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  00f84	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169625
  00f8b	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00f90	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00f95	41 b9 03 00 00
	00		 mov	 r9d, 3
  00f9b	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG169626
  00fa2	ba eb 01 00 00	 mov	 edx, 491		; 000001ebH
  00fa7	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169627
  00fae	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg
$LN59@LCS_Init:

; 489  :                           pLCSDev->pDEVBLK[LCS_READ_SUBCHANN]->devnum,
; 490  :                           pLCSDev->pDEVBLK[LCS_READ_SUBCHANN]->typname,
; 491  :                           "TT32SDEVBUFF", pLCSPORT->szNetIfName, strerror( errno ));
; 492  :                 }
; 493  : 
; 494  :                 tt32ctl.tt32ctl_iobuffsize = pLCSBLK->iIOBuff;

  00fb4	48 8b 44 24 78	 mov	 rax, QWORD PTR pLCSBLK$[rsp]
  00fb9	8b 40 24	 mov	 eax, DWORD PTR [rax+36]
  00fbc	89 84 24 48 01
	00 00		 mov	 DWORD PTR tt32ctl$2[rsp+16], eax

; 495  : 
; 496  :                 if (TUNTAP_IOCtl( pLCSPORT->fd, TT32SIOBUFF, (char*) &tt32ctl ) != 0)

  00fc3	4c 8d 84 24 38
	01 00 00	 lea	 r8, QWORD PTR tt32ctl$2[rsp]
  00fcb	ba dd 54 04 80	 mov	 edx, -2147199779	; ffffffff800454ddH
  00fd0	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR pLCSPORT$[rsp]
  00fd8	8b 88 38 01 00
	00		 mov	 ecx, DWORD PTR [rax+312]
  00fde	e8 00 00 00 00	 call	 tt32_ioctl
  00fe3	85 c0		 test	 eax, eax
  00fe5	0f 84 10 01 00
	00		 je	 $LN60@LCS_Init

; 497  :                 {
; 498  :                     // "%1d:%04X %s: ioctl %s failed for device %s: %s"
; 499  :                     WRMSG( HHC00902, "W", SSID_TO_LCSS( pLCSDev->pDEVBLK[LCS_READ_SUBCHANN]->ssid ),

  00feb	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno
  00ff1	8b 08		 mov	 ecx, DWORD PTR [rax]
  00ff3	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_strerror
  00ff9	48 89 84 24 10
	01 00 00	 mov	 QWORD PTR tv694[rsp], rax
  01001	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR pLCSPORT$[rsp]
  01009	48 81 c1 48 01
	00 00		 add	 rcx, 328		; 00000148H
  01010	48 89 8c 24 18
	01 00 00	 mov	 QWORD PTR tv698[rsp], rcx
  01018	ba 08 00 00 00	 mov	 edx, 8
  0101d	48 6b d2 00	 imul	 rdx, rdx, 0
  01021	48 8b 7c 24 70	 mov	 rdi, QWORD PTR pLCSDev$[rsp]
  01026	48 8b 54 17 10	 mov	 rdx, QWORD PTR [rdi+rdx+16]
  0102b	48 89 94 24 20
	01 00 00	 mov	 QWORD PTR tv872[rsp], rdx
  01033	bf 08 00 00 00	 mov	 edi, 8
  01038	48 6b ff 00	 imul	 rdi, rdi, 0
  0103c	4c 8b 44 24 70	 mov	 r8, QWORD PTR pLCSDev$[rsp]
  01041	49 8b 7c 38 10	 mov	 rdi, QWORD PTR [r8+rdi+16]
  01046	0f b7 7f 48	 movzx	 edi, WORD PTR [rdi+72]
  0104a	41 b8 08 00 00
	00		 mov	 r8d, 8
  01050	4d 6b c0 00	 imul	 r8, r8, 0
  01054	4c 8b 4c 24 70	 mov	 r9, QWORD PTR pLCSDev$[rsp]
  01059	4f 8b 44 01 10	 mov	 r8, QWORD PTR [r9+r8+16]
  0105e	45 0f b7 40 44	 movzx	 r8d, WORD PTR [r8+68]
  01063	41 d1 f8	 sar	 r8d, 1
  01066	44 89 84 24 c8
	00 00 00	 mov	 DWORD PTR tv717[rsp], r8d
  0106e	b9 01 00 00 00	 mov	 ecx, 1
  01073	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  01079	48 8b 8c 24 10
	01 00 00	 mov	 rcx, QWORD PTR tv694[rsp]
  01081	48 89 4c 24 60	 mov	 QWORD PTR [rsp+96], rcx
  01086	48 8b 8c 24 18
	01 00 00	 mov	 rcx, QWORD PTR tv698[rsp]
  0108e	48 89 4c 24 58	 mov	 QWORD PTR [rsp+88], rcx
  01093	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169629
  0109a	48 89 4c 24 50	 mov	 QWORD PTR [rsp+80], rcx
  0109f	48 8b 8c 24 20
	01 00 00	 mov	 rcx, QWORD PTR tv872[rsp]
  010a7	48 8b 49 50	 mov	 rcx, QWORD PTR [rcx+80]
  010ab	48 89 4c 24 48	 mov	 QWORD PTR [rsp+72], rcx
  010b0	89 7c 24 40	 mov	 DWORD PTR [rsp+64], edi
  010b4	8b 8c 24 c8 00
	00 00		 mov	 ecx, DWORD PTR tv717[rsp]
  010bb	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  010bf	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169630
  010c6	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  010cb	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169631
  010d2	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  010d7	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  010dc	41 b9 03 00 00
	00		 mov	 r9d, 3
  010e2	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG169632
  010e9	ba f6 01 00 00	 mov	 edx, 502		; 000001f6H
  010ee	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169633
  010f5	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg
$LN60@LCS_Init:

; 500  :                           pLCSDev->pDEVBLK[LCS_READ_SUBCHANN]->devnum,
; 501  :                           pLCSDev->pDEVBLK[LCS_READ_SUBCHANN]->typname,
; 502  :                           "TT32SIOBUFF", pLCSPORT->szNetIfName, strerror( errno ) );
; 503  :                 }
; 504  :             }
; 505  : #endif
; 506  : 
; 507  :             // Get and display the tap interface MAC address.
; 508  :             GetIfMACAddress( pLCSPORT );

  010fb	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR pLCSPORT$[rsp]
  01103	e8 00 00 00 00	 call	 GetIfMACAddress

; 509  : 
; 510  :             // Indicate that the port is used.
; 511  :             pLCSPORT->fUsed        = 1;

  01108	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR pLCSPORT$[rsp]
  01110	8b 80 34 01 00
	00		 mov	 eax, DWORD PTR [rax+308]
  01116	83 c8 01	 or	 eax, 1
  01119	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR pLCSPORT$[rsp]
  01121	89 81 34 01 00
	00		 mov	 DWORD PTR [rcx+308], eax

; 512  :             pLCSPORT->fPortCreated = 1;

  01127	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR pLCSPORT$[rsp]
  0112f	8b 80 34 01 00
	00		 mov	 eax, DWORD PTR [rax+308]
  01135	83 c8 04	 or	 eax, 4
  01138	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR pLCSPORT$[rsp]
  01140	89 81 34 01 00
	00		 mov	 DWORD PTR [rcx+308], eax

; 513  : 
; 514  :             // Set assist flags
; 515  :             LCS_Assist( pLCSPORT );

  01146	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR pLCSPORT$[rsp]
  0114e	e8 00 00 00 00	 call	 LCS_Assist

; 516  : 
; 517  :             // Now create the port thread to read packets from tuntap
; 518  :             // The thread name uses the read device address of the first device pair.
; 519  :             MSGBUF( thread_name, "%s %4.4X Port %d Thread",

  01153	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR pLCSPORT$[rsp]
  0115b	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  0115e	48 8b 4c 24 78	 mov	 rcx, QWORD PTR pLCSBLK$[rsp]
  01163	48 8b 49 58	 mov	 rcx, QWORD PTR [rcx+88]
  01167	ba 08 00 00 00	 mov	 edx, 8
  0116c	48 6b d2 00	 imul	 rdx, rdx, 0
  01170	48 8b 4c 11 10	 mov	 rcx, QWORD PTR [rcx+rdx+16]
  01175	0f b7 49 48	 movzx	 ecx, WORD PTR [rcx+72]
  01179	48 8b 54 24 78	 mov	 rdx, QWORD PTR pLCSBLK$[rsp]
  0117e	48 8b 52 58	 mov	 rdx, QWORD PTR [rdx+88]
  01182	bf 08 00 00 00	 mov	 edi, 8
  01187	48 6b ff 00	 imul	 rdi, rdi, 0
  0118b	48 8b 54 3a 10	 mov	 rdx, QWORD PTR [rdx+rdi+16]
  01190	89 44 24 28	 mov	 DWORD PTR [rsp+40], eax
  01194	89 4c 24 20	 mov	 DWORD PTR [rsp+32], ecx
  01198	4c 8b 4a 50	 mov	 r9, QWORD PTR [rdx+80]
  0119c	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG169634
  011a3	ba 20 00 00 00	 mov	 edx, 32			; 00000020H
  011a8	48 8d 8c 24 50
	01 00 00	 lea	 rcx, QWORD PTR thread_name$[rsp]
  011b0	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_snprintf

; 520  :                                  pLCSBLK->pDevices->pDEVBLK[LCS_READ_SUBCHANN]->typname,
; 521  :                                  pLCSBLK->pDevices->pDEVBLK[LCS_READ_SUBCHANN]->devnum,
; 522  :                                  pLCSPORT->bPort);
; 523  :             rc = create_thread( &pLCSPORT->tid, JOINABLE,

  011b6	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  011bd	48 05 98 10 00
	00		 add	 rax, 4248		; 00001098H
  011c3	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR pLCSPORT$[rsp]
  011cb	48 81 c1 3c 01
	00 00		 add	 rcx, 316		; 0000013cH
  011d2	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG169635
  011d9	48 89 54 24 28	 mov	 QWORD PTR [rsp+40], rdx
  011de	48 8d 94 24 50
	01 00 00	 lea	 rdx, QWORD PTR thread_name$[rsp]
  011e6	48 89 54 24 20	 mov	 QWORD PTR [rsp+32], rdx
  011eb	4c 8b 8c 24 80
	00 00 00	 mov	 r9, QWORD PTR pLCSPORT$[rsp]
  011f3	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:LCS_PortThread
  011fa	48 8b d0	 mov	 rdx, rax
  011fd	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_create_thread
  01203	89 84 24 90 00
	00 00		 mov	 DWORD PTR rc$1[rsp], eax

; 524  :                                 LCS_PortThread, pLCSPORT, thread_name );
; 525  :             if (rc)

  0120a	83 bc 24 90 00
	00 00 00	 cmp	 DWORD PTR rc$1[rsp], 0
  01212	74 69		 je	 SHORT $LN61@LCS_Init

; 526  :             {
; 527  :                 // "Error in function create_thread(): %s"
; 528  :                 WRMSG( HHC00102, "E", strerror( rc ));

  01214	8b 8c 24 90 00
	00 00		 mov	 ecx, DWORD PTR rc$1[rsp]
  0121b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_strerror
  01221	48 89 84 24 28
	01 00 00	 mov	 QWORD PTR tv765[rsp], rax
  01229	b9 01 00 00 00	 mov	 ecx, 1
  0122e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  01234	48 8b 8c 24 28
	01 00 00	 mov	 rcx, QWORD PTR tv765[rsp]
  0123c	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  01241	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169637
  01248	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  0124d	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169638
  01254	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  01259	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  0125e	41 b9 03 00 00
	00		 mov	 r9d, 3
  01264	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG169639
  0126b	ba 10 02 00 00	 mov	 edx, 528		; 00000210H
  01270	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169640
  01277	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg
$LN61@LCS_Init:

; 529  :             }
; 530  : 
; 531  :             // Identify thread ID with devices on which they're active
; 532  :             pLCSDev->pDEVBLK[LCS_READ_SUBCHANN]->tid = pLCSPORT->tid;

  0127d	b8 08 00 00 00	 mov	 eax, 8
  01282	48 6b c0 00	 imul	 rax, rax, 0
  01286	48 8b 4c 24 70	 mov	 rcx, QWORD PTR pLCSDev$[rsp]
  0128b	48 8b 44 01 10	 mov	 rax, QWORD PTR [rcx+rax+16]
  01290	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR pLCSPORT$[rsp]
  01298	8b 89 3c 01 00
	00		 mov	 ecx, DWORD PTR [rcx+316]
  0129e	89 88 14 02 00
	00		 mov	 DWORD PTR [rax+532], ecx

; 533  :             if (pLCSDev->pDEVBLK[LCS_WRITE_SUBCHANN])

  012a4	b8 08 00 00 00	 mov	 eax, 8
  012a9	48 6b c0 01	 imul	 rax, rax, 1
  012ad	48 8b 4c 24 70	 mov	 rcx, QWORD PTR pLCSDev$[rsp]
  012b2	48 83 7c 01 10
	00		 cmp	 QWORD PTR [rcx+rax+16], 0
  012b8	74 27		 je	 SHORT $LN62@LCS_Init

; 534  :                 pLCSDev->pDEVBLK[LCS_WRITE_SUBCHANN]->tid = pLCSPORT->tid;

  012ba	b8 08 00 00 00	 mov	 eax, 8
  012bf	48 6b c0 01	 imul	 rax, rax, 1
  012c3	48 8b 4c 24 70	 mov	 rcx, QWORD PTR pLCSDev$[rsp]
  012c8	48 8b 44 01 10	 mov	 rax, QWORD PTR [rcx+rax+16]
  012cd	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR pLCSPORT$[rsp]
  012d5	8b 89 3c 01 00
	00		 mov	 ecx, DWORD PTR [rcx+316]
  012db	89 88 14 02 00
	00		 mov	 DWORD PTR [rax+532], ecx
$LN62@LCS_Init:
$LN46@LCS_Init:

; 535  :         }
; 536  : 
; 537  :         // Add these devices to the ports device list.
; 538  :         pLCSPORT->icDevices++;

  012e1	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR pLCSPORT$[rsp]
  012e9	8b 80 44 01 00
	00		 mov	 eax, DWORD PTR [rax+324]
  012ef	ff c0		 inc	 eax
  012f1	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR pLCSPORT$[rsp]
  012f9	89 81 44 01 00
	00		 mov	 DWORD PTR [rcx+324], eax

; 539  :         pLCSDev->pDEVBLK[LCS_READ_SUBCHANN]->fd = pLCSPORT->fd;

  012ff	b8 08 00 00 00	 mov	 eax, 8
  01304	48 6b c0 00	 imul	 rax, rax, 0
  01308	48 8b 4c 24 70	 mov	 rcx, QWORD PTR pLCSDev$[rsp]
  0130d	48 8b 44 01 10	 mov	 rax, QWORD PTR [rcx+rax+16]
  01312	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR pLCSPORT$[rsp]
  0131a	8b 89 38 01 00
	00		 mov	 ecx, DWORD PTR [rcx+312]
  01320	89 88 ac 01 00
	00		 mov	 DWORD PTR [rax+428], ecx

; 540  : 
; 541  :         if (pLCSDev->pDEVBLK[LCS_WRITE_SUBCHANN])

  01326	b8 08 00 00 00	 mov	 eax, 8
  0132b	48 6b c0 01	 imul	 rax, rax, 1
  0132f	48 8b 4c 24 70	 mov	 rcx, QWORD PTR pLCSDev$[rsp]
  01334	48 83 7c 01 10
	00		 cmp	 QWORD PTR [rcx+rax+16], 0
  0133a	74 27		 je	 SHORT $LN63@LCS_Init

; 542  :             pLCSDev->pDEVBLK[LCS_WRITE_SUBCHANN]->fd = pLCSPORT->fd;

  0133c	b8 08 00 00 00	 mov	 eax, 8
  01341	48 6b c0 01	 imul	 rax, rax, 1
  01345	48 8b 4c 24 70	 mov	 rcx, QWORD PTR pLCSDev$[rsp]
  0134a	48 8b 44 01 10	 mov	 rax, QWORD PTR [rcx+rax+16]
  0134f	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR pLCSPORT$[rsp]
  01357	8b 89 38 01 00
	00		 mov	 ecx, DWORD PTR [rcx+312]
  0135d	89 88 ac 01 00
	00		 mov	 DWORD PTR [rax+428], ecx
$LN63@LCS_Init:

; 543  : 
; 544  :     }   // End of  for (pLCSDev = pLCSBLK->pDevices; pLCSDev; pLCSDev = pLCSDev->pNext)

  01363	e9 ba f1 ff ff	 jmp	 $LN5@LCS_Init
$LN6@LCS_Init:

; 545  : 
; 546  : 
; 547  :     // If this LCS has one or more SNA devices we need an attention required thread to present Attention interrupts to the guest.
; 548  :     for (pLCSDev = pLCSBLK->pDevices; pLCSDev; pLCSDev = pLCSDev->pNext)

  01368	48 8b 44 24 78	 mov	 rax, QWORD PTR pLCSBLK$[rsp]
  0136d	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  01371	48 89 44 24 70	 mov	 QWORD PTR pLCSDev$[rsp], rax
  01376	eb 0d		 jmp	 SHORT $LN28@LCS_Init
$LN26@LCS_Init:
  01378	48 8b 44 24 70	 mov	 rax, QWORD PTR pLCSDev$[rsp]
  0137d	48 8b 00	 mov	 rax, QWORD PTR [rax]
  01380	48 89 44 24 70	 mov	 QWORD PTR pLCSDev$[rsp], rax
$LN28@LCS_Init:
  01385	48 83 7c 24 70
	00		 cmp	 QWORD PTR pLCSDev$[rsp], 0
  0138b	0f 84 59 01 00
	00		 je	 $LN27@LCS_Init

; 549  :     {
; 550  :         if (pLCSDev->bMode == LCSDEV_MODE_SNA)

  01391	48 8b 44 24 70	 mov	 rax, QWORD PTR pLCSDev$[rsp]
  01396	0f b6 40 22	 movzx	 eax, BYTE PTR [rax+34]
  0139a	83 f8 02	 cmp	 eax, 2
  0139d	0f 85 42 01 00
	00		 jne	 $LN64@LCS_Init

; 551  :         {
; 552  :             // Now create the attention required thread to present Attention interrupts to the guest(s).
; 553  :             // The thread name uses the read device address of the first device pair.
; 554  :             MSGBUF( thread_name, "%s %4.4X AttnThread",

  013a3	48 8b 44 24 78	 mov	 rax, QWORD PTR pLCSBLK$[rsp]
  013a8	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  013ac	b9 08 00 00 00	 mov	 ecx, 8
  013b1	48 6b c9 00	 imul	 rcx, rcx, 0
  013b5	48 8b 44 08 10	 mov	 rax, QWORD PTR [rax+rcx+16]
  013ba	0f b7 40 48	 movzx	 eax, WORD PTR [rax+72]
  013be	48 8b 4c 24 78	 mov	 rcx, QWORD PTR pLCSBLK$[rsp]
  013c3	48 8b 49 58	 mov	 rcx, QWORD PTR [rcx+88]
  013c7	ba 08 00 00 00	 mov	 edx, 8
  013cc	48 6b d2 00	 imul	 rdx, rdx, 0
  013d0	48 8b 4c 11 10	 mov	 rcx, QWORD PTR [rcx+rdx+16]
  013d5	89 44 24 20	 mov	 DWORD PTR [rsp+32], eax
  013d9	4c 8b 49 50	 mov	 r9, QWORD PTR [rcx+80]
  013dd	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG169644
  013e4	ba 20 00 00 00	 mov	 edx, 32			; 00000020H
  013e9	48 8d 8c 24 50
	01 00 00	 lea	 rcx, QWORD PTR thread_name$[rsp]
  013f1	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_snprintf

; 555  :                                  pLCSBLK->pDevices->pDEVBLK[LCS_READ_SUBCHANN]->typname,
; 556  :                                  pLCSBLK->pDevices->pDEVBLK[LCS_READ_SUBCHANN]->devnum);
; 557  :             rc = create_thread( &pLCSBLK->AttnTid, JOINABLE,

  013f7	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  013fe	48 05 98 10 00
	00		 add	 rax, 4248		; 00001098H
  01404	48 8b 4c 24 78	 mov	 rcx, QWORD PTR pLCSBLK$[rsp]
  01409	48 83 c1 50	 add	 rcx, 80			; 00000050H
  0140d	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG169645
  01414	48 89 54 24 28	 mov	 QWORD PTR [rsp+40], rdx
  01419	48 8d 94 24 50
	01 00 00	 lea	 rdx, QWORD PTR thread_name$[rsp]
  01421	48 89 54 24 20	 mov	 QWORD PTR [rsp+32], rdx
  01426	4c 8b 4c 24 78	 mov	 r9, QWORD PTR pLCSBLK$[rsp]
  0142b	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:LCS_AttnThread
  01432	48 8b d0	 mov	 rdx, rax
  01435	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_create_thread
  0143b	89 84 24 94 00
	00 00		 mov	 DWORD PTR rc$[rsp], eax

; 558  :                                 LCS_AttnThread, pLCSBLK, thread_name );
; 559  :             if (rc)

  01442	83 bc 24 94 00
	00 00 00	 cmp	 DWORD PTR rc$[rsp], 0
  0144a	74 69		 je	 SHORT $LN65@LCS_Init

; 560  :             {
; 561  :                 // "Error in function create_thread(): %s"
; 562  :                 WRMSG( HHC00102, "E", strerror( rc ));

  0144c	8b 8c 24 94 00
	00 00		 mov	 ecx, DWORD PTR rc$[rsp]
  01453	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_strerror
  01459	48 89 84 24 30
	01 00 00	 mov	 QWORD PTR tv841[rsp], rax
  01461	b9 01 00 00 00	 mov	 ecx, 1
  01466	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  0146c	48 8b 8c 24 30
	01 00 00	 mov	 rcx, QWORD PTR tv841[rsp]
  01474	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  01479	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169647
  01480	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  01485	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169648
  0148c	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  01491	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  01496	41 b9 03 00 00
	00		 mov	 r9d, 3
  0149c	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG169649
  014a3	ba 32 02 00 00	 mov	 edx, 562		; 00000232H
  014a8	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169650
  014af	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg
$LN65@LCS_Init:

; 563  :             }
; 564  : 
; 565  :             // Initialize locking for the SNA token, if necessary.
; 566  :             if (!TokenLockInitialized)

  014b5	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR TokenLockInitialized, 0
  014bc	75 25		 jne	 SHORT $LN66@LCS_Init

; 567  :             {
; 568  :                 TokenLockInitialized = TRUE;

  014be	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR TokenLockInitialized, 1

; 569  :                 initialize_lock( &TokenLock );

  014c8	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG169652
  014cf	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG169653
  014d6	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:TokenLock
  014dd	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_initialize_lock
$LN66@LCS_Init:

; 570  :             }
; 571  : 
; 572  :             break;

  014e3	eb 05		 jmp	 SHORT $LN27@LCS_Init
$LN64@LCS_Init:

; 573  :         }
; 574  :     }   // End of  for (pLCSDev = pLCSBLK->pDevices; pLCSDev; pLCSDev = pLCSDev->pNext)

  014e5	e9 8e fe ff ff	 jmp	 $LN26@LCS_Init
$LN27@LCS_Init:

; 575  : 
; 576  :     return 0;

  014ea	33 c0		 xor	 eax, eax
$LN1@LCS_Init:

; 577  : }

  014ec	48 8b 8c 24 98
	01 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  014f4	48 33 cc	 xor	 rcx, rsp
  014f7	e8 00 00 00 00	 call	 __security_check_cookie
  014fc	48 81 c4 a0 01
	00 00		 add	 rsp, 416		; 000001a0H
  01503	5f		 pop	 rdi
  01504	c3		 ret	 0
LCS_Init ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\machdep.h
;	COMDAT fetch_f3_noswap
_TEXT	SEGMENT
value$ = 0
ptr$ = 48
fetch_f3_noswap PROC					; COMDAT

; 780  :     inline U32 fetch_f3_noswap(const void *ptr) {

$LN3:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	56		 push	 rsi
  00006	57		 push	 rdi
  00007	48 83 ec 18	 sub	 rsp, 24

; 781  :       U32 value;
; 782  :       memcpy(((BYTE *)&value), (BYTE *)ptr, 3);

  0000b	48 8d 04 24	 lea	 rax, QWORD PTR value$[rsp]
  0000f	48 8b f8	 mov	 rdi, rax
  00012	48 8b 74 24 30	 mov	 rsi, QWORD PTR ptr$[rsp]
  00017	b9 03 00 00 00	 mov	 ecx, 3
  0001c	f3 a4		 rep movsb

; 783  :       value <<= 8;

  0001e	8b 04 24	 mov	 eax, DWORD PTR value$[rsp]
  00021	c1 e0 08	 shl	 eax, 8
  00024	89 04 24	 mov	 DWORD PTR value$[rsp], eax

; 784  :       return value;

  00027	8b 04 24	 mov	 eax, DWORD PTR value$[rsp]

; 785  :     }

  0002a	48 83 c4 18	 add	 rsp, 24
  0002e	5f		 pop	 rdi
  0002f	5e		 pop	 rsi
  00030	c3		 ret	 0
fetch_f3_noswap ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\machdep.h
;	COMDAT store_fw_noswap
_TEXT	SEGMENT
ptr$ = 8
value$ = 16
store_fw_noswap PROC					; COMDAT

; 764  :     inline void store_fw_noswap(void *ptr, U32 value) {

  00000	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00004	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx

; 765  :       memcpy((BYTE *)ptr, (BYTE *)&value, 4);

  00009	48 8b 44 24 08	 mov	 rax, QWORD PTR ptr$[rsp]
  0000e	8b 4c 24 10	 mov	 ecx, DWORD PTR value$[rsp]
  00012	89 08		 mov	 DWORD PTR [rax], ecx

; 766  :     }

  00014	c3		 ret	 0
store_fw_noswap ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\machdep.h
;	COMDAT store_hw_noswap
_TEXT	SEGMENT
ptr$ = 8
value$ = 16
store_hw_noswap PROC					; COMDAT

; 730  :     inline void store_hw_noswap(void *ptr, U16 value) {

  00000	66 89 54 24 10	 mov	 WORD PTR [rsp+16], dx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx

; 731  :       memcpy((BYTE *)ptr, (BYTE *)&value, 2);

  0000a	48 8b 44 24 08	 mov	 rax, QWORD PTR ptr$[rsp]
  0000f	0f b7 4c 24 10	 movzx	 ecx, WORD PTR value$[rsp]
  00014	66 89 08	 mov	 WORD PTR [rax], cx

; 732  :     }

  00017	c3		 ret	 0
store_hw_noswap ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\machdep.h
;	COMDAT fetch_hw_noswap
_TEXT	SEGMENT
value$ = 0
ptr$ = 32
fetch_hw_noswap PROC					; COMDAT

; 712  :     inline U16 fetch_hw_noswap(const void *ptr) {

$LN3:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 18	 sub	 rsp, 24

; 713  :       U16 value;
; 714  :       memcpy(&value, (BYTE *)ptr, 2);

  00009	48 8b 44 24 20	 mov	 rax, QWORD PTR ptr$[rsp]
  0000e	0f b7 00	 movzx	 eax, WORD PTR [rax]
  00011	66 89 04 24	 mov	 WORD PTR value$[rsp], ax

; 715  :       return value;

  00015	0f b7 04 24	 movzx	 eax, WORD PTR value$[rsp]

; 716  :     }

  00019	48 83 c4 18	 add	 rsp, 24
  0001d	c3		 ret	 0
fetch_hw_noswap ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\dbgtrace.h
_TEXT	SEGMENT
buffsize$ = 48
rc$ = 52
chunksize$ = 56
buffer$ = 64
args$ = 72
fmt$ = 96
DebuggerTrace PROC

; 94   :   static inline void DebuggerTrace(char* fmt, ...) {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000f	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00014	48 83 ec 58	 sub	 rsp, 88			; 00000058H

; 95   :       const int chunksize = 512;

  00018	c7 44 24 38 00
	02 00 00	 mov	 DWORD PTR chunksize$[rsp], 512 ; 00000200H

; 96   :       int buffsize = 0;

  00020	c7 44 24 30 00
	00 00 00	 mov	 DWORD PTR buffsize$[rsp], 0

; 97   :       char* buffer = NULL;

  00028	48 c7 44 24 40
	00 00 00 00	 mov	 QWORD PTR buffer$[rsp], 0

; 98   :       int rc = -1;

  00031	c7 44 24 34 ff
	ff ff ff	 mov	 DWORD PTR rc$[rsp], -1

; 99   :       va_list args;
; 100  :       va_start( args, fmt );

  00039	48 8d 44 24 68	 lea	 rax, QWORD PTR fmt$[rsp+8]
  0003e	48 89 44 24 48	 mov	 QWORD PTR args$[rsp], rax
$LN9@DebuggerTr:
$LN4@DebuggerTr:

; 101  :       do {
; 102  :           if (buffer) free( buffer );

  00043	48 83 7c 24 40
	00		 cmp	 QWORD PTR buffer$[rsp], 0
  00049	74 0b		 je	 SHORT $LN5@DebuggerTr
  0004b	48 8b 4c 24 40	 mov	 rcx, QWORD PTR buffer$[rsp]
  00050	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free
$LN5@DebuggerTr:

; 103  :           buffsize += chunksize;

  00056	8b 44 24 38	 mov	 eax, DWORD PTR chunksize$[rsp]
  0005a	8b 4c 24 30	 mov	 ecx, DWORD PTR buffsize$[rsp]
  0005e	03 c8		 add	 ecx, eax
  00060	8b c1		 mov	 eax, ecx
  00062	89 44 24 30	 mov	 DWORD PTR buffsize$[rsp], eax

; 104  :           buffer = malloc( buffsize + 1 );

  00066	8b 44 24 30	 mov	 eax, DWORD PTR buffsize$[rsp]
  0006a	ff c0		 inc	 eax
  0006c	48 98		 cdqe
  0006e	48 8b c8	 mov	 rcx, rax
  00071	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_malloc
  00077	48 89 44 24 40	 mov	 QWORD PTR buffer$[rsp], rax

; 105  :           if (!buffer) BREAK_INTO_DEBUGGER();

  0007c	48 83 7c 24 40
	00		 cmp	 QWORD PTR buffer$[rsp], 0
  00082	75 01		 jne	 SHORT $LN6@DebuggerTr
  00084	cc		 int	 3
$LN6@DebuggerTr:

; 106  :           rc = _vsnprintf_s( buffer, buffsize+1, buffsize, fmt, args);

  00085	48 63 44 24 30	 movsxd	 rax, DWORD PTR buffsize$[rsp]
  0008a	8b 4c 24 30	 mov	 ecx, DWORD PTR buffsize$[rsp]
  0008e	ff c1		 inc	 ecx
  00090	48 63 c9	 movsxd	 rcx, ecx
  00093	48 8b 54 24 48	 mov	 rdx, QWORD PTR args$[rsp]
  00098	48 89 54 24 20	 mov	 QWORD PTR [rsp+32], rdx
  0009d	4c 8b 4c 24 60	 mov	 r9, QWORD PTR fmt$[rsp]
  000a2	4c 8b c0	 mov	 r8, rax
  000a5	48 8b d1	 mov	 rdx, rcx
  000a8	48 8b 4c 24 40	 mov	 rcx, QWORD PTR buffer$[rsp]
  000ad	e8 00 00 00 00	 call	 _vsnprintf_s
  000b2	89 44 24 34	 mov	 DWORD PTR rc$[rsp], eax

; 107  :       } while (rc < 0 || rc >= buffsize);

  000b6	83 7c 24 34 00	 cmp	 DWORD PTR rc$[rsp], 0
  000bb	7c 86		 jl	 SHORT $LN4@DebuggerTr
  000bd	8b 44 24 30	 mov	 eax, DWORD PTR buffsize$[rsp]
  000c1	39 44 24 34	 cmp	 DWORD PTR rc$[rsp], eax
  000c5	0f 8d 78 ff ff
	ff		 jge	 $LN9@DebuggerTr

; 108  :       OutputDebugStringA( buffer ); /* send to debugger pane */

  000cb	48 8b 4c 24 40	 mov	 rcx, QWORD PTR buffer$[rsp]
  000d0	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_OutputDebugStringA

; 109  :       if (buffer) free( buffer );

  000d6	48 83 7c 24 40
	00		 cmp	 QWORD PTR buffer$[rsp], 0
  000dc	74 0b		 je	 SHORT $LN7@DebuggerTr
  000de	48 8b 4c 24 40	 mov	 rcx, QWORD PTR buffer$[rsp]
  000e3	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free
$LN7@DebuggerTr:

; 110  :       va_end( args );

  000e9	48 c7 44 24 48
	00 00 00 00	 mov	 QWORD PTR args$[rsp], 0

; 111  :   }

  000f2	48 83 c4 58	 add	 rsp, 88			; 00000058H
  000f6	c3		 ret	 0
DebuggerTrace ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files (x86)\Windows Kits\10\include\10.0.22000.0\ucrt\time.h
_TEXT	SEGMENT
_Time$ = 48
time	PROC

; 521  :         {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 522  :             return _time64(_Time);

  00009	48 8b 4c 24 30	 mov	 rcx, QWORD PTR _Time$[rsp]
  0000e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__time64

; 523  :         }

  00014	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00018	c3		 ret	 0
time	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files (x86)\Windows Kits\10\include\10.0.22000.0\ucrt\stdio.h
;	COMDAT sscanf
_TEXT	SEGMENT
_Result$ = 32
_ArgList$ = 40
_Buffer$ = 64
_Format$ = 72
sscanf	PROC						; COMDAT

; 2247 :     {

$LN3:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000f	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00014	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 2248 :         int _Result;
; 2249 :         va_list _ArgList;
; 2250 :         __crt_va_start(_ArgList, _Format);

  00018	48 8d 44 24 50	 lea	 rax, QWORD PTR _Format$[rsp+8]
  0001d	48 89 44 24 28	 mov	 QWORD PTR _ArgList$[rsp], rax

; 2251 :         _Result = _vsscanf_l(_Buffer, _Format, NULL, _ArgList);

  00022	4c 8b 4c 24 28	 mov	 r9, QWORD PTR _ArgList$[rsp]
  00027	45 33 c0	 xor	 r8d, r8d
  0002a	48 8b 54 24 48	 mov	 rdx, QWORD PTR _Format$[rsp]
  0002f	48 8b 4c 24 40	 mov	 rcx, QWORD PTR _Buffer$[rsp]
  00034	e8 00 00 00 00	 call	 _vsscanf_l
  00039	89 44 24 20	 mov	 DWORD PTR _Result$[rsp], eax

; 2252 :         __crt_va_end(_ArgList);

  0003d	48 c7 44 24 28
	00 00 00 00	 mov	 QWORD PTR _ArgList$[rsp], 0

; 2253 :         return _Result;

  00046	8b 44 24 20	 mov	 eax, DWORD PTR _Result$[rsp]

; 2254 :     }

  0004a	48 83 c4 38	 add	 rsp, 56			; 00000038H
  0004e	c3		 ret	 0
sscanf	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files (x86)\Windows Kits\10\include\10.0.22000.0\ucrt\stdio.h
;	COMDAT _vsscanf_l
_TEXT	SEGMENT
_Buffer$ = 64
_Format$ = 72
_Locale$ = 80
_ArgList$ = 88
_vsscanf_l PROC						; COMDAT

; 2152 :     {

$LN3:
  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 2153 :         return __stdio_common_vsscanf(

  00018	e8 00 00 00 00	 call	 __local_stdio_scanf_options
  0001d	48 8b 4c 24 58	 mov	 rcx, QWORD PTR _ArgList$[rsp]
  00022	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00027	48 8b 4c 24 50	 mov	 rcx, QWORD PTR _Locale$[rsp]
  0002c	48 89 4c 24 20	 mov	 QWORD PTR [rsp+32], rcx
  00031	4c 8b 4c 24 48	 mov	 r9, QWORD PTR _Format$[rsp]
  00036	49 c7 c0 ff ff
	ff ff		 mov	 r8, -1
  0003d	48 8b 54 24 40	 mov	 rdx, QWORD PTR _Buffer$[rsp]
  00042	48 8b 08	 mov	 rcx, QWORD PTR [rax]
  00045	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___stdio_common_vsscanf

; 2154 :             _CRT_INTERNAL_LOCAL_SCANF_OPTIONS,
; 2155 :             _Buffer, (size_t)-1, _Format, _Locale, _ArgList);
; 2156 :     }

  0004b	48 83 c4 38	 add	 rsp, 56			; 00000038H
  0004f	c3		 ret	 0
_vsscanf_l ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files (x86)\Windows Kits\10\include\10.0.22000.0\ucrt\stdio.h
;	COMDAT _vsnprintf_s
_TEXT	SEGMENT
_Buffer$ = 64
_BufferCount$ = 72
_MaxCount$ = 80
_Format$ = 88
_ArgList$ = 96
_vsnprintf_s PROC					; COMDAT

; 1598 :     {

$LN3:
  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 1599 :         return _vsnprintf_s_l(_Buffer, _BufferCount, _MaxCount, _Format, NULL, _ArgList);

  00018	48 8b 44 24 60	 mov	 rax, QWORD PTR _ArgList$[rsp]
  0001d	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  00022	48 c7 44 24 20
	00 00 00 00	 mov	 QWORD PTR [rsp+32], 0
  0002b	4c 8b 4c 24 58	 mov	 r9, QWORD PTR _Format$[rsp]
  00030	4c 8b 44 24 50	 mov	 r8, QWORD PTR _MaxCount$[rsp]
  00035	48 8b 54 24 48	 mov	 rdx, QWORD PTR _BufferCount$[rsp]
  0003a	48 8b 4c 24 40	 mov	 rcx, QWORD PTR _Buffer$[rsp]
  0003f	e8 00 00 00 00	 call	 _vsnprintf_s_l

; 1600 :     }

  00044	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00048	c3		 ret	 0
_vsnprintf_s ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files (x86)\Windows Kits\10\include\10.0.22000.0\ucrt\stdio.h
;	COMDAT _vsnprintf_s_l
_TEXT	SEGMENT
_Result$ = 64
tv74 = 68
_Buffer$ = 96
_BufferCount$ = 104
_MaxCount$ = 112
_Format$ = 120
_Locale$ = 128
_ArgList$ = 136
_vsnprintf_s_l PROC					; COMDAT

; 1577 :     {

$LN5:
  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	48 83 ec 58	 sub	 rsp, 88			; 00000058H

; 1578 :         int const _Result = __stdio_common_vsnprintf_s(

  00018	e8 00 00 00 00	 call	 __local_stdio_printf_options
  0001d	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR _ArgList$[rsp]
  00025	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  0002a	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR _Locale$[rsp]
  00032	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00037	48 8b 4c 24 78	 mov	 rcx, QWORD PTR _Format$[rsp]
  0003c	48 89 4c 24 20	 mov	 QWORD PTR [rsp+32], rcx
  00041	4c 8b 4c 24 70	 mov	 r9, QWORD PTR _MaxCount$[rsp]
  00046	4c 8b 44 24 68	 mov	 r8, QWORD PTR _BufferCount$[rsp]
  0004b	48 8b 54 24 60	 mov	 rdx, QWORD PTR _Buffer$[rsp]
  00050	48 8b 08	 mov	 rcx, QWORD PTR [rax]
  00053	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___stdio_common_vsnprintf_s
  00059	89 44 24 40	 mov	 DWORD PTR _Result$[rsp], eax

; 1579 :             _CRT_INTERNAL_LOCAL_PRINTF_OPTIONS,
; 1580 :             _Buffer, _BufferCount, _MaxCount, _Format, _Locale, _ArgList);
; 1581 : 
; 1582 :         return _Result < 0 ? -1 : _Result;

  0005d	83 7c 24 40 00	 cmp	 DWORD PTR _Result$[rsp], 0
  00062	7d 0a		 jge	 SHORT $LN3@vsnprintf_
  00064	c7 44 24 44 ff
	ff ff ff	 mov	 DWORD PTR tv74[rsp], -1
  0006c	eb 08		 jmp	 SHORT $LN4@vsnprintf_
$LN3@vsnprintf_:
  0006e	8b 44 24 40	 mov	 eax, DWORD PTR _Result$[rsp]
  00072	89 44 24 44	 mov	 DWORD PTR tv74[rsp], eax
$LN4@vsnprintf_:
  00076	8b 44 24 44	 mov	 eax, DWORD PTR tv74[rsp]

; 1583 :     }

  0007a	48 83 c4 58	 add	 rsp, 88			; 00000058H
  0007e	c3		 ret	 0
_vsnprintf_s_l ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files (x86)\Windows Kits\10\include\10.0.22000.0\ucrt\corecrt_stdio_config.h
;	COMDAT __local_stdio_scanf_options
_TEXT	SEGMENT
__local_stdio_scanf_options PROC			; COMDAT

; 101  :         static unsigned __int64 _OptionsStorage;
; 102  :         return &_OptionsStorage;

  00000	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:?_OptionsStorage@?1??__local_stdio_scanf_options@@9@9 ; `__local_stdio_scanf_options'::`2'::_OptionsStorage

; 103  :     }

  00007	c3		 ret	 0
__local_stdio_scanf_options ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files (x86)\Windows Kits\10\include\10.0.22000.0\ucrt\corecrt_stdio_config.h
;	COMDAT __local_stdio_printf_options
_TEXT	SEGMENT
__local_stdio_printf_options PROC			; COMDAT

; 91   :         static unsigned __int64 _OptionsStorage;
; 92   :         return &_OptionsStorage;

  00000	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:?_OptionsStorage@?1??__local_stdio_printf_options@@9@9 ; `__local_stdio_printf_options'::`2'::_OptionsStorage

; 93   :     }

  00007	c3		 ret	 0
__local_stdio_printf_options ENDP
_TEXT	ENDS
END
