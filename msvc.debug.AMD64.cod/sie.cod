; Listing generated by Microsoft (R) Optimizing Compiler Version 19.34.31937.0 

include listing.inc

INCLUDELIB MSVCRTD
INCLUDELIB OLDNAMES

CONST	SEGMENT
CKD_ENDTRK DB	0ffH
	DB	0ffH
	DB	0ffH
	DB	0ffH
	DB	0ffH
	DB	0ffH
	DB	0ffH
	DB	0ffH
CONST	ENDS
PUBLIC	cmpxchg4_x86
PUBLIC	cmpxchg1_x86
PUBLIC	fetch_hw_noswap
PUBLIC	store_hw_noswap
PUBLIC	fetch_fw_noswap
PUBLIC	store_fw_noswap
PUBLIC	fetch_dw_noswap
PUBLIC	store_dw_noswap
PUBLIC	_get_storekey_ptr
PUBLIC	_get_storekey1_ptr
PUBLIC	_get_storekey2_ptr
PUBLIC	s370__or_storage_key
PUBLIC	s370_or_4K_storage_key
PUBLIC	s370_maddr_l
PUBLIC	s370_instfetch
PUBLIC	s370_LockUnlockSCALock
PUBLIC	s370_LockUnlockRCPLock
PUBLIC	s370_LockUnlockSKALock
PUBLIC	s370_LockUnlockKeyLock
PUBLIC	s370_GetPGSTEFromPTE
PUBLIC	s370_GetPGSTE
PUBLIC	s370_GetOldRCP
PUBLIC	s370_GetPGSTE_and_RCPTE
PUBLIC	s390_sie_exit
PUBLIC	s390_diagnose_002
PUBLIC	s390_start_interpretive_execution
PUBLIC	s390_test_pending_zone_interrupt
PUBLIC	s390_store_zone_parameter
PUBLIC	s390_set_zone_parameter
PUBLIC	s390__or_storage_key
PUBLIC	s390_get_ptr_to_4K_storekey
PUBLIC	s390_or_4K_storage_key
PUBLIC	s390_get_ptr_to_storekey
PUBLIC	s390_maddr_l
PUBLIC	s390_vstorec
PUBLIC	s390_vfetchc
PUBLIC	s390_instfetch
PUBLIC	s390_LockUnlockSCALock
PUBLIC	s390_LockUnlockRCPLock
PUBLIC	s390_LockUnlockSKALock
PUBLIC	s390_LockUnlockKeyLock
PUBLIC	s390_GetPGSTEFromPTE
PUBLIC	s390_GetPGSTE
PUBLIC	s390_GetOldRCP
PUBLIC	s390_GetPGSTE_and_RCPTE
PUBLIC	z900_sie_exit
PUBLIC	z900_diagnose_002
PUBLIC	z900_store_hypervisor_information
PUBLIC	z900_start_interpretive_execution
PUBLIC	z900_test_pending_zone_interrupt
PUBLIC	z900_store_zone_parameter
PUBLIC	z900_set_zone_parameter
PUBLIC	z900_extract_and_set_storage_attributes
PUBLIC	z900__or_storage_key
PUBLIC	z900_get_ptr_to_4K_storekey
PUBLIC	z900_or_4K_storage_key
PUBLIC	z900_get_ptr_to_storekey
PUBLIC	z900_is_per3_event_suppressed
PUBLIC	z900_per3_zero
PUBLIC	z900_per3_zero_xcheck
PUBLIC	z900_maddr_l
PUBLIC	z900_vstorec
PUBLIC	z900_vfetchc
PUBLIC	z900_instfetch
PUBLIC	z900_LockUnlockSCALock
PUBLIC	z900_LockUnlockRCPLock
PUBLIC	z900_LockUnlockSKALock
PUBLIC	z900_LockUnlockKeyLock
PUBLIC	z900_GetPGSTEFromPTE
PUBLIC	z900_GetPGSTE
PUBLIC	z900_GetOldRCP
PUBLIC	z900_GetPGSTE_and_RCPTE
PUBLIC	??_C@_0CM@GFKCBHDD@C?3?2papa?2MyGit?2hyperion?9zvector?2@ ; `string'
PUBLIC	??_C@_0CM@NOJKKEDI@C?3?2papa?2MyGit?2hyperion?9zvector?2@ ; `string'
EXTRN	__imp__errno:PROC
EXTRN	__imp__aligned_malloc:PROC
EXTRN	_byteswap_ushort:PROC
EXTRN	_byteswap_ulong:PROC
EXTRN	_byteswap_uint64:PROC
EXTRN	longjmp:PROC
EXTRN	__imp___acrt_iob_func:PROC
EXTRN	__imp_hthread_obtain_lock:PROC
EXTRN	__imp_hthread_release_lock:PROC
EXTRN	__imp_hthread_signal_condition:PROC
EXTRN	__imp_hthread_wait_condition:PROC
EXTRN	__imp_hthread_timed_wait_condition:PROC
EXTRN	__imp_ptt_pthread_trace:PROC
EXTRN	__imp_ptyp2short:PROC
EXTRN	__imp_w32_strerror:PROC
EXTRN	__imp_clock_gettime:PROC
EXTRN	s370_store_int_timer:PROC
EXTRN	get_cpu_timer:PROC
EXTRN	set_cpu_timer:PROC
EXTRN	set_int_timer:PROC
EXTRN	s370_store_psw:PROC
EXTRN	s370_load_psw:PROC
EXTRN	s370_process_trace:PROC
EXTRN	s390_load_psw:PROC
EXTRN	s390_store_psw:PROC
EXTRN	s390_process_trace:PROC
EXTRN	z900_load_psw:PROC
EXTRN	z900_store_psw:PROC
EXTRN	z900_process_trace:PROC
EXTRN	cpu_init:PROC
EXTRN	s370_perform_io_interrupt:PROC
EXTRN	do_automatic_tracing:PROC
EXTRN	s370_perform_external_interrupt:PROC
EXTRN	find_device_by_subchan:PROC
EXTRN	txf_maddr_l:PROC
EXTRN	z900_abort_transaction:PROC
EXTRN	alloc_txfmap:PROC
EXTRN	s390_invalidate_guest_aia:PROC
EXTRN	z900_invalidate_guest_aia:PROC
EXTRN	s390_set_guest_ic_mask:PROC
EXTRN	z900_set_guest_ic_mask:PROC
EXTRN	s390_set_guest_aea_mode:PROC
EXTRN	z900_set_guest_aea_mode:PROC
EXTRN	s390_set_guest_aea_common:PROC
EXTRN	z900_set_guest_aea_common:PROC
EXTRN	s370_purge_tlb:PROC
EXTRN	s390_purge_tlb:PROC
EXTRN	z900_purge_tlb:PROC
EXTRN	s390_purge_alb:PROC
EXTRN	z900_purge_alb:PROC
EXTRN	apply_host_prefixing:PROC
EXTRN	s370_program_interrupt:PROC
EXTRN	s390_program_interrupt:PROC
EXTRN	z900_program_interrupt:PROC
EXTRN	__imp_fwritemsg:PROC
EXTRN	s370_logical_to_main_l:PROC
EXTRN	s390_logical_to_main_l:PROC
EXTRN	z900_logical_to_main_l:PROC
EXTRN	s370_invalidate_tlb:PROC
EXTRN	s390_translate_addr:PROC
EXTRN	z900_translate_addr:PROC
EXTRN	s390_present_zone_io_interrupt:PROC
EXTRN	s390_perform_io_interrupt:PROC
EXTRN	s390_perform_external_interrupt:PROC
EXTRN	s390_invalidate_tlb:PROC
EXTRN	z900_present_zone_io_interrupt:PROC
EXTRN	z900_perform_io_interrupt:PROC
EXTRN	z900_perform_external_interrupt:PROC
EXTRN	z900_invalidate_tlb:PROC
EXTRN	__GSHandlerCheck:PROC
EXTRN	__security_check_cookie:PROC
EXTRN	_setjmp:PROC
EXTRN	memcmp:PROC
EXTRN	__imp_pttclass:QWORD
EXTRN	tod_value:BYTE
EXTRN	__imp_sysblk:BYTE
EXTRN	__ImageBase:BYTE
EXTRN	__security_cookie:QWORD
pdata	SEGMENT
$pdata$calloc_aligned DD imagerel calloc_aligned
	DD	imagerel calloc_aligned+81
	DD	imagerel $unwind$calloc_aligned
$pdata$host_tod DD imagerel host_tod
	DD	imagerel host_tod+169
	DD	imagerel $unwind$host_tod
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$cmpxchg4_x86 DD imagerel $LN5
	DD	imagerel $LN5+102
	DD	imagerel $unwind$cmpxchg4_x86
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$cmpxchg1_x86 DD imagerel $LN3
	DD	imagerel $LN3+300
	DD	imagerel $unwind$cmpxchg1_x86
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$fetch_hw_noswap DD imagerel $LN3
	DD	imagerel $LN3+30
	DD	imagerel $unwind$fetch_hw_noswap
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$fetch_fw_noswap DD imagerel $LN3
	DD	imagerel $LN3+27
	DD	imagerel $unwind$fetch_fw_noswap
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$fetch_dw_noswap DD imagerel $LN3
	DD	imagerel $LN3+30
	DD	imagerel $unwind$fetch_dw_noswap
pdata	ENDS
pdata	SEGMENT
$pdata$Interrupt_Lock_Obtained DD imagerel Interrupt_Lock_Obtained
	DD	imagerel Interrupt_Lock_Obtained+269
	DD	imagerel $unwind$Interrupt_Lock_Obtained
$pdata$Obtain_Interrupt_Lock DD imagerel Obtain_Interrupt_Lock
	DD	imagerel Obtain_Interrupt_Lock+88
	DD	imagerel $unwind$Obtain_Interrupt_Lock
$pdata$Release_Interrupt_Lock DD imagerel Release_Interrupt_Lock
	DD	imagerel Release_Interrupt_Lock+71
	DD	imagerel $unwind$Release_Interrupt_Lock
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$_get_storekey_ptr DD imagerel $LN5
	DD	imagerel $LN5+104
	DD	imagerel $unwind$_get_storekey_ptr
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$s370__or_storage_key DD imagerel $LN8
	DD	imagerel $LN8+170
	DD	imagerel $unwind$s370__or_storage_key
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$s370_or_4K_storage_key DD imagerel $LN3
	DD	imagerel $LN3+42
	DD	imagerel $unwind$s370_or_4K_storage_key
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$s370_maddr_l DD imagerel $LN14
	DD	imagerel $LN14+474
	DD	imagerel $unwind$s370_maddr_l
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$s370_instfetch DD imagerel $LN68
	DD	imagerel $LN68+1960
	DD	imagerel $unwind$s370_instfetch
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$s370_LockUnlockSCALock DD imagerel $LN13
	DD	imagerel $LN13+267
	DD	imagerel $unwind$s370_LockUnlockSCALock
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$s370_LockUnlockRCPLock DD imagerel $LN8
	DD	imagerel $LN8+161
	DD	imagerel $unwind$s370_LockUnlockRCPLock
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$s370_LockUnlockSKALock DD imagerel $LN8
	DD	imagerel $LN8+217
	DD	imagerel $unwind$s370_LockUnlockSKALock
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$s370_LockUnlockKeyLock DD imagerel $LN5
	DD	imagerel $LN5+75
	DD	imagerel $unwind$s370_LockUnlockKeyLock
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$s370_GetPGSTEFromPTE DD imagerel $LN5
	DD	imagerel $LN5+108
	DD	imagerel $unwind$s370_GetPGSTEFromPTE
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$s370_GetPGSTE DD imagerel $LN8
	DD	imagerel $LN8+186
	DD	imagerel $unwind$s370_GetPGSTE
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$s370_GetOldRCP DD imagerel $LN3
	DD	imagerel $LN3+145
	DD	imagerel $unwind$s370_GetOldRCP
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$s370_GetPGSTE_and_RCPTE DD imagerel $LN7
	DD	imagerel $LN7+187
	DD	imagerel $unwind$s370_GetPGSTE_and_RCPTE
pdata	ENDS
pdata	SEGMENT
$pdata$s370_run_sie DD imagerel s370_run_sie
	DD	imagerel s370_run_sie+5949
	DD	imagerel $unwind$s370_run_sie
$pdata$s390_run_sie DD imagerel s390_run_sie
	DD	imagerel s390_run_sie+6002
	DD	imagerel $unwind$s390_run_sie
$pdata$z900_run_sie DD imagerel z900_run_sie
	DD	imagerel z900_run_sie+10071
	DD	imagerel $unwind$z900_run_sie
$pdata$s390_sie_exit DD imagerel $LN179
	DD	imagerel $LN179+6464
	DD	imagerel $unwind$s390_sie_exit
$pdata$s390_diagnose_002 DD imagerel $LN18
	DD	imagerel $LN18+703
	DD	imagerel $unwind$s390_diagnose_002
$pdata$s390_start_interpretive_execution DD imagerel $LN180
	DD	imagerel $LN180+10116
	DD	imagerel $unwind$s390_start_interpretive_execution
$pdata$s390_test_pending_zone_interrupt DD imagerel $LN30
	DD	imagerel $LN30+1042
	DD	imagerel $unwind$s390_test_pending_zone_interrupt
$pdata$s390_store_zone_parameter DD imagerel $LN23
	DD	imagerel $LN23+967
	DD	imagerel $unwind$s390_store_zone_parameter
$pdata$s390_set_zone_parameter DD imagerel $LN24
	DD	imagerel $LN24+1038
	DD	imagerel $unwind$s390_set_zone_parameter
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$s390__or_storage_key DD imagerel $LN8
	DD	imagerel $LN8+159
	DD	imagerel $unwind$s390__or_storage_key
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$s390_get_ptr_to_4K_storekey DD imagerel $LN3
	DD	imagerel $LN3+26
	DD	imagerel $unwind$s390_get_ptr_to_4K_storekey
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$s390_or_4K_storage_key DD imagerel $LN3
	DD	imagerel $LN3+42
	DD	imagerel $unwind$s390_or_4K_storage_key
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$s390_get_ptr_to_storekey DD imagerel $LN3
	DD	imagerel $LN3+24
	DD	imagerel $unwind$s390_get_ptr_to_storekey
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$s390_maddr_l DD imagerel $LN14
	DD	imagerel $LN14+474
	DD	imagerel $unwind$s390_maddr_l
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$s390_vstorec DD imagerel $LN9
	DD	imagerel $LN9+498
	DD	imagerel $unwind$s390_vstorec
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$s390_vfetchc DD imagerel $LN9
	DD	imagerel $LN9+432
	DD	imagerel $unwind$s390_vfetchc
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$s390_instfetch DD imagerel $LN76
	DD	imagerel $LN76+2248
	DD	imagerel $unwind$s390_instfetch
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$s390_LockUnlockSCALock DD imagerel $LN13
	DD	imagerel $LN13+267
	DD	imagerel $unwind$s390_LockUnlockSCALock
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$s390_LockUnlockRCPLock DD imagerel $LN8
	DD	imagerel $LN8+161
	DD	imagerel $unwind$s390_LockUnlockRCPLock
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$s390_LockUnlockSKALock DD imagerel $LN8
	DD	imagerel $LN8+217
	DD	imagerel $unwind$s390_LockUnlockSKALock
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$s390_LockUnlockKeyLock DD imagerel $LN5
	DD	imagerel $LN5+75
	DD	imagerel $unwind$s390_LockUnlockKeyLock
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$s390_GetPGSTEFromPTE DD imagerel $LN5
	DD	imagerel $LN5+108
	DD	imagerel $unwind$s390_GetPGSTEFromPTE
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$s390_GetPGSTE DD imagerel $LN10
	DD	imagerel $LN10+265
	DD	imagerel $unwind$s390_GetPGSTE
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$s390_GetOldRCP DD imagerel $LN5
	DD	imagerel $LN5+219
	DD	imagerel $unwind$s390_GetOldRCP
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$s390_GetPGSTE_and_RCPTE DD imagerel $LN12
	DD	imagerel $LN12+283
	DD	imagerel $unwind$s390_GetPGSTE_and_RCPTE
pdata	ENDS
pdata	SEGMENT
$pdata$z900_sie_exit DD imagerel $LN228
	DD	imagerel $LN228+8672
	DD	imagerel $unwind$z900_sie_exit
$pdata$z900_diagnose_002 DD imagerel $LN18
	DD	imagerel $LN18+703
	DD	imagerel $unwind$z900_diagnose_002
$pdata$z900_store_hypervisor_information DD imagerel $LN11
	DD	imagerel $LN11+178
	DD	imagerel $unwind$z900_store_hypervisor_information
$pdata$z900_start_interpretive_execution DD imagerel $LN171
	DD	imagerel $LN171+10102
	DD	imagerel $unwind$z900_start_interpretive_execution
$pdata$z900_test_pending_zone_interrupt DD imagerel $LN34
	DD	imagerel $LN34+1135
	DD	imagerel $unwind$z900_test_pending_zone_interrupt
$pdata$z900_store_zone_parameter DD imagerel $LN27
	DD	imagerel $LN27+1068
	DD	imagerel $unwind$z900_store_zone_parameter
$pdata$z900_set_zone_parameter DD imagerel $LN30
	DD	imagerel $LN30+1252
	DD	imagerel $unwind$z900_set_zone_parameter
$pdata$z900_extract_and_set_storage_attributes DD imagerel $LN11
	DD	imagerel $LN11+191
	DD	imagerel $unwind$z900_extract_and_set_storage_attributes
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$z900__or_storage_key DD imagerel $LN8
	DD	imagerel $LN8+159
	DD	imagerel $unwind$z900__or_storage_key
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$z900_get_ptr_to_4K_storekey DD imagerel $LN3
	DD	imagerel $LN3+26
	DD	imagerel $unwind$z900_get_ptr_to_4K_storekey
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$z900_or_4K_storage_key DD imagerel $LN3
	DD	imagerel $LN3+42
	DD	imagerel $unwind$z900_or_4K_storage_key
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$z900_get_ptr_to_storekey DD imagerel $LN3
	DD	imagerel $LN3+24
	DD	imagerel $unwind$z900_get_ptr_to_storekey
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$z900_per3_zero DD imagerel $LN12
	DD	imagerel $LN12+215
	DD	imagerel $unwind$z900_per3_zero
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$z900_per3_zero_xcheck DD imagerel $LN6
	DD	imagerel $LN6+108
	DD	imagerel $unwind$z900_per3_zero_xcheck
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$z900_maddr_l DD imagerel $LN18
	DD	imagerel $LN18+657
	DD	imagerel $unwind$z900_maddr_l
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$z900_vstorec DD imagerel $LN9
	DD	imagerel $LN9+511
	DD	imagerel $unwind$z900_vstorec
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$z900_vfetchc DD imagerel $LN9
	DD	imagerel $LN9+445
	DD	imagerel $unwind$z900_vfetchc
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$z900_instfetch DD imagerel $LN96
	DD	imagerel $LN96+2956
	DD	imagerel $unwind$z900_instfetch
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$z900_LockUnlockSCALock DD imagerel $LN13
	DD	imagerel $LN13+267
	DD	imagerel $unwind$z900_LockUnlockSCALock
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$z900_LockUnlockRCPLock DD imagerel $LN8
	DD	imagerel $LN8+161
	DD	imagerel $unwind$z900_LockUnlockRCPLock
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$z900_LockUnlockSKALock DD imagerel $LN8
	DD	imagerel $LN8+217
	DD	imagerel $unwind$z900_LockUnlockSKALock
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$z900_LockUnlockKeyLock DD imagerel $LN5
	DD	imagerel $LN5+75
	DD	imagerel $unwind$z900_LockUnlockKeyLock
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$z900_GetPGSTEFromPTE DD imagerel $LN5
	DD	imagerel $LN5+108
	DD	imagerel $unwind$z900_GetPGSTEFromPTE
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$z900_GetPGSTE DD imagerel $LN8
	DD	imagerel $LN8+187
	DD	imagerel $unwind$z900_GetPGSTE
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$z900_GetOldRCP DD imagerel $LN3
	DD	imagerel $LN3+146
	DD	imagerel $unwind$z900_GetOldRCP
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$z900_GetPGSTE_and_RCPTE DD imagerel $LN7
	DD	imagerel $LN7+187
	DD	imagerel $unwind$z900_GetPGSTE_and_RCPTE
pdata	ENDS
;	COMDAT ??_C@_0CM@NOJKKEDI@C?3?2papa?2MyGit?2hyperion?9zvector?2@
_DATA	SEGMENT
??_C@_0CM@NOJKKEDI@C?3?2papa?2MyGit?2hyperion?9zvector?2@ DB 'C:\papa\MyG'
	DB	'it\hyperion-zvector\vstore.h:943', 00H	; `string'
_DATA	ENDS
;	COMDAT ??_C@_0CM@GFKCBHDD@C?3?2papa?2MyGit?2hyperion?9zvector?2@
_DATA	SEGMENT
??_C@_0CM@GFKCBHDD@C?3?2papa?2MyGit?2hyperion?9zvector?2@ DB 'C:\papa\MyG'
	DB	'it\hyperion-zvector\vstore.h:863', 00H	; `string'
_DATA	ENDS
_DATA	SEGMENT
run_sie	DQ	FLAT:s370_run_sie
	DQ	FLAT:s390_run_sie
	DQ	FLAT:z900_run_sie
$SG169958 DB	'sie.c:999', 00H
	ORG $+6
$SG169959 DB	'run_sie h,g,a', 00H
	ORG $+2
$SG169961 DB	'sie.c:1021', 00H
	ORG $+1
$SG170001 DB	'W', 00H
	ORG $+2
$SG169962 DB	'run_sie setjmp', 00H
	ORG $+1
$SG169966 DB	'sie.c:1028', 00H
	ORG $+1
$SG180558 DB	'SIE', 00H
$SG169967 DB	'run_sie run...', 00H
	ORG $+1
$SG169973 DB	'sie.c:1063', 00H
	ORG $+1
$SG180574 DB	'E', 00H
	ORG $+2
$SG169980 DB	'sie.c:1111', 00H
	ORG $+1
$SG180944 DB	'W', 00H
	ORG $+2
$SG169985 DB	'sie.c:1123', 00H
	ORG $+1
$SG181349 DB	'SZP', 00H
$SG169994 DB	'sie.c:1145', 00H
	ORG $+1
$SG194857 DB	'SIE', 00H
$SG169995 DB	'sie.c:1148', 00H
	ORG $+1
$SG194873 DB	'E', 00H
	ORG $+2
$SG169996 DB	'sie.c:1157', 00H
	ORG $+1
$SG195312 DB	'W', 00H
	ORG $+2
$SG169997 DB	'sie.c:1163', 00H
	ORG $+5
$SG170003 DB	's370_run_sie', 00H
	ORG $+3
$SG170004 DB	'sie.c', 00H
	ORG $+2
$SG170002 DB	'HHC00835%s Processor %s%02X: aie invalidated; instructio'
	DB	'n being refetched', 0aH, 00H
	ORG $+1
$SG195321 DB	'W', 00H
	ORG $+2
$SG170013 DB	'sie.c:1343', 00H
	ORG $+1
$SG195331 DB	'W', 00H
	ORG $+2
$SG170014 DB	'run_sie !run', 00H
	ORG $+3
$SG170028 DB	'sie.c:1363', 00H
	ORG $+1
$SG195339 DB	0b2H, 0f8H, 00H
	ORG $+1
$SG170029 DB	'run_sie !run', 00H
	ORG $+3
$SG170031 DB	'sie.c:1368', 00H
	ORG $+1
$SG195349 DB	0b2H, 0f8H, 00H
	ORG $+1
$SG170032 DB	'run_sie ret', 00H
$SG195359 DB	0b2H, 0f8H, 00H
	ORG $+1
$SG180557 DB	'C:\papa\MyGit\hyperion-zvector\sie.c:351', 00H
	ORG $+3
$SG181302 DB	'*STZP', 00H
	ORG $+2
$SG195735 DB	'D', 00H
	ORG $+2
$SG180563 DB	'C:\papa\MyGit\hyperion-zvector\sie.c:395', 00H
	ORG $+3
$SG181411 DB	'*TPZI', 00H
	ORG $+2
$SG195745 DB	'D', 00H
	ORG $+2
$SG180564 DB	'SIE h,g,a', 00H
	ORG $+2
$SG195889 DB	'SZP', 00H
$SG180566 DB	'C:\papa\MyGit\hyperion-zvector\sie.c:398', 00H
	ORG $+3
$SG195837 DB	'*STZP', 00H
	ORG $+6
$SG180567 DB	'C:\papa\MyGit\hyperion-zvector\sie.c:402', 00H
	ORG $+7
$SG180570 DB	'C:\papa\MyGit\hyperion-zvector\sie.c:408', 00H
	ORG $+7
$SG180571 DB	'SIE calloc g', 00H
	ORG $+3
$SG180573 DB	'calloc()', 00H
	ORG $+7
$SG180575 DB	'HHC00813%s Processor %s%02X: error in function %s: %s', 0aH
	DB	00H
	ORG $+1
$SG180576 DB	's390_start_interpretive_execution', 00H
	ORG $+6
$SG180577 DB	'C:\papa\MyGit\hyperion-zvector\sie.c', 00H
	ORG $+3
$SG180601 DB	'C:\papa\MyGit\hyperion-zvector\sie.c:799', 00H
	ORG $+7
$SG180602 DB	'SIE a=1', 00H
$SG180603 DB	'C:\papa\MyGit\hyperion-zvector\sie.c:800', 00H
	ORG $+7
$SG180604 DB	'C:\papa\MyGit\hyperion-zvector\sie.c:804', 00H
	ORG $+7
$SG180609 DB	'C:\papa\MyGit\hyperion-zvector\sie.c:826', 00H
	ORG $+7
$SG180610 DB	'SIE a=0', 00H
$SG180611 DB	'C:\papa\MyGit\hyperion-zvector\sie.c:827', 00H
	ORG $+7
$SG180612 DB	'C:\papa\MyGit\hyperion-zvector\sie.c:831', 00H
	ORG $+7
$SG180616 DB	'C:\papa\MyGit\hyperion-zvector\sie.c:843', 00H
	ORG $+7
$SG180617 DB	'SIE a=0', 00H
$SG180618 DB	'C:\papa\MyGit\hyperion-zvector\sie.c:844', 00H
	ORG $+7
$SG180619 DB	'C:\papa\MyGit\hyperion-zvector\sie.c:848', 00H
	ORG $+7
$SG180620 DB	'C:\papa\MyGit\hyperion-zvector\sie.c:854', 00H
	ORG $+7
$SG180634 DB	'C:\papa\MyGit\hyperion-zvector\sie.c:907', 00H
	ORG $+7
$SG180637 DB	'C:\papa\MyGit\hyperion-zvector\sie.c:912', 00H
	ORG $+7
$SG180638 DB	'*SIE > pgmint', 00H
	ORG $+2
$SG180640 DB	'C:\papa\MyGit\hyperion-zvector\sie.c:917', 00H
	ORG $+7
$SG180641 DB	'SIE > run_sie', 00H
	ORG $+2
$SG180643 DB	'C:\papa\MyGit\hyperion-zvector\sie.c:919', 00H
	ORG $+7
$SG180644 DB	'SIE < run_sie', 00H
	ORG $+2
$SG180646 DB	'C:\papa\MyGit\hyperion-zvector\sie.c:924', 00H
	ORG $+7
$SG180647 DB	'SIE > sie_exit', 00H
	ORG $+1
$SG180649 DB	'C:\papa\MyGit\hyperion-zvector\sie.c:926', 00H
	ORG $+7
$SG180650 DB	'SIE < sie_exit', 00H
	ORG $+1
$SG180652 DB	'C:\papa\MyGit\hyperion-zvector\sie.c:933', 00H
	ORG $+7
$SG180653 DB	'SIE progjmp', 00H
	ORG $+4
$SG180896 DB	'C:\papa\MyGit\hyperion-zvector\sie.c:999', 00H
	ORG $+7
$SG180897 DB	'run_sie h,g,a', 00H
	ORG $+2
$SG180899 DB	'C:\papa\MyGit\hyperion-zvector\sie.c:1021', 00H
	ORG $+6
$SG180900 DB	'run_sie setjmp', 00H
	ORG $+1
$SG180904 DB	'C:\papa\MyGit\hyperion-zvector\sie.c:1028', 00H
	ORG $+6
$SG180905 DB	'run_sie run...', 00H
	ORG $+1
$SG180911 DB	'C:\papa\MyGit\hyperion-zvector\sie.c:1063', 00H
	ORG $+6
$SG180918 DB	'C:\papa\MyGit\hyperion-zvector\sie.c:1111', 00H
	ORG $+6
$SG180923 DB	'C:\papa\MyGit\hyperion-zvector\sie.c:1123', 00H
	ORG $+6
$SG180937 DB	'C:\papa\MyGit\hyperion-zvector\sie.c:1145', 00H
	ORG $+6
$SG180938 DB	'C:\papa\MyGit\hyperion-zvector\sie.c:1148', 00H
	ORG $+6
$SG180939 DB	'C:\papa\MyGit\hyperion-zvector\sie.c:1157', 00H
	ORG $+6
$SG180940 DB	'C:\papa\MyGit\hyperion-zvector\sie.c:1163', 00H
	ORG $+6
$SG180946 DB	's390_run_sie', 00H
	ORG $+3
$SG180947 DB	'C:\papa\MyGit\hyperion-zvector\sie.c', 00H
	ORG $+3
$SG180945 DB	'HHC00835%s Processor %s%02X: aie invalidated; instructio'
	DB	'n being refetched', 0aH, 00H
	ORG $+5
$SG180956 DB	'C:\papa\MyGit\hyperion-zvector\sie.c:1343', 00H
	ORG $+6
$SG180957 DB	'run_sie !run', 00H
	ORG $+3
$SG180971 DB	'C:\papa\MyGit\hyperion-zvector\sie.c:1363', 00H
	ORG $+6
$SG180972 DB	'run_sie !run', 00H
	ORG $+3
$SG180974 DB	'C:\papa\MyGit\hyperion-zvector\sie.c:1368', 00H
	ORG $+6
$SG180975 DB	'run_sie ret', 00H
	ORG $+4
$SG181181 DB	'C:\papa\MyGit\hyperion-zvector\sie.c:1406', 00H
	ORG $+6
$SG181182 DB	'sie_xit i,h,g', 00H
	ORG $+2
$SG181191 DB	'C:\papa\MyGit\hyperion-zvector\sie.c:1458', 00H
	ORG $+6
$SG181192 DB	'sie_xit inst', 00H
	ORG $+3
$SG181194 DB	'C:\papa\MyGit\hyperion-zvector\sie.c:1474', 00H
	ORG $+6
$SG181196 DB	'C:\papa\MyGit\hyperion-zvector\sie.c:1477', 00H
	ORG $+6
$SG181197 DB	'sie_xit a=0', 00H
	ORG $+4
$SG181198 DB	'C:\papa\MyGit\hyperion-zvector\sie.c:1479', 00H
	ORG $+6
$SG181220 DB	'C:\papa\MyGit\hyperion-zvector\sie.c:1516', 00H
	ORG $+6
$SG181221 DB	'sie_xit STA_c', 00H
	ORG $+2
$SG181253 DB	'C:\papa\MyGit\hyperion-zvector\sie.c:1754', 00H
	ORG $+6
$SG181254 DB	'sie_xit ret', 00H
	ORG $+4
$SG181296 DB	'C:\papa\MyGit\hyperion-zvector\sie.c:1780', 00H
	ORG $+2
$SG181297 DB	'STZP', 00H
	ORG $+7
$SG181301 DB	'C:\papa\MyGit\hyperion-zvector\sie.c:1788', 00H
	ORG $+6
$SG181348 DB	'C:\papa\MyGit\hyperion-zvector\sie.c:1825', 00H
	ORG $+6
$SG181354 DB	'C:\papa\MyGit\hyperion-zvector\sie.c:1833', 00H
	ORG $+2
$SG181355 DB	'*SZP', 00H
	ORG $+7
$SG181405 DB	'C:\papa\MyGit\hyperion-zvector\sie.c:1884', 00H
	ORG $+2
$SG181406 DB	'TPZI', 00H
	ORG $+7
$SG181410 DB	'C:\papa\MyGit\hyperion-zvector\sie.c:1896', 00H
	ORG $+6
$SG181414 DB	'C:\papa\MyGit\hyperion-zvector\sie.c:1904', 00H
	ORG $+6
$SG181417 DB	'C:\papa\MyGit\hyperion-zvector\sie.c:1918', 00H
	ORG $+6
$SG181418 DB	'C:\papa\MyGit\hyperion-zvector\sie.c:1927', 00H
	ORG $+6
$SG181443 DB	'C:\papa\MyGit\hyperion-zvector\sie.c:1957', 00H
	ORG $+6
$SG181444 DB	'*DIAG002', 00H
	ORG $+7
$SG181445 DB	'C:\papa\MyGit\hyperion-zvector\sie.c:1963', 00H
	ORG $+6
$SG181449 DB	'C:\papa\MyGit\hyperion-zvector\sie.c:1988', 00H
	ORG $+6
$SG194852 DB	'C:\papa\MyGit\hyperion-zvector\sie.c:346', 00H
	ORG $+7
$SG194856 DB	'C:\papa\MyGit\hyperion-zvector\sie.c:351', 00H
	ORG $+7
$SG194862 DB	'C:\papa\MyGit\hyperion-zvector\sie.c:395', 00H
	ORG $+7
$SG194863 DB	'SIE h,g,a', 00H
	ORG $+6
$SG194865 DB	'C:\papa\MyGit\hyperion-zvector\sie.c:398', 00H
	ORG $+7
$SG194866 DB	'C:\papa\MyGit\hyperion-zvector\sie.c:402', 00H
	ORG $+7
$SG194869 DB	'C:\papa\MyGit\hyperion-zvector\sie.c:408', 00H
	ORG $+7
$SG194870 DB	'SIE calloc g', 00H
	ORG $+3
$SG194872 DB	'calloc()', 00H
	ORG $+7
$SG194874 DB	'HHC00813%s Processor %s%02X: error in function %s: %s', 0aH
	DB	00H
	ORG $+1
$SG194875 DB	'z900_start_interpretive_execution', 00H
	ORG $+6
$SG194876 DB	'C:\papa\MyGit\hyperion-zvector\sie.c', 00H
	ORG $+3
$SG194903 DB	'C:\papa\MyGit\hyperion-zvector\sie.c:799', 00H
	ORG $+7
$SG194904 DB	'SIE a=1', 00H
$SG194905 DB	'C:\papa\MyGit\hyperion-zvector\sie.c:800', 00H
	ORG $+7
$SG194906 DB	'C:\papa\MyGit\hyperion-zvector\sie.c:804', 00H
	ORG $+7
$SG194911 DB	'C:\papa\MyGit\hyperion-zvector\sie.c:826', 00H
	ORG $+7
$SG194912 DB	'SIE a=0', 00H
$SG194913 DB	'C:\papa\MyGit\hyperion-zvector\sie.c:827', 00H
	ORG $+7
$SG194914 DB	'C:\papa\MyGit\hyperion-zvector\sie.c:831', 00H
	ORG $+7
$SG194918 DB	'C:\papa\MyGit\hyperion-zvector\sie.c:843', 00H
	ORG $+7
$SG194919 DB	'SIE a=0', 00H
$SG194920 DB	'C:\papa\MyGit\hyperion-zvector\sie.c:844', 00H
	ORG $+7
$SG194921 DB	'C:\papa\MyGit\hyperion-zvector\sie.c:848', 00H
	ORG $+7
$SG194922 DB	'C:\papa\MyGit\hyperion-zvector\sie.c:854', 00H
	ORG $+7
$SG194929 DB	'C:\papa\MyGit\hyperion-zvector\sie.c:907', 00H
	ORG $+7
$SG194932 DB	'C:\papa\MyGit\hyperion-zvector\sie.c:912', 00H
	ORG $+7
$SG194933 DB	'*SIE > pgmint', 00H
	ORG $+2
$SG194935 DB	'C:\papa\MyGit\hyperion-zvector\sie.c:917', 00H
	ORG $+7
$SG194936 DB	'SIE > run_sie', 00H
	ORG $+2
$SG194938 DB	'C:\papa\MyGit\hyperion-zvector\sie.c:919', 00H
	ORG $+7
$SG194939 DB	'SIE < run_sie', 00H
	ORG $+2
$SG194941 DB	'C:\papa\MyGit\hyperion-zvector\sie.c:924', 00H
	ORG $+7
$SG194942 DB	'SIE > sie_exit', 00H
	ORG $+1
$SG194944 DB	'C:\papa\MyGit\hyperion-zvector\sie.c:926', 00H
	ORG $+7
$SG194945 DB	'SIE < sie_exit', 00H
	ORG $+1
$SG194947 DB	'C:\papa\MyGit\hyperion-zvector\sie.c:933', 00H
	ORG $+7
$SG194948 DB	'SIE progjmp', 00H
	ORG $+4
$SG195261 DB	'C:\papa\MyGit\hyperion-zvector\sie.c:999', 00H
	ORG $+7
$SG195262 DB	'run_sie h,g,a', 00H
	ORG $+2
$SG195264 DB	'C:\papa\MyGit\hyperion-zvector\sie.c:1021', 00H
	ORG $+6
$SG195265 DB	'run_sie setjmp', 00H
	ORG $+1
$SG195269 DB	'C:\papa\MyGit\hyperion-zvector\sie.c:1028', 00H
	ORG $+6
$SG195270 DB	'run_sie run...', 00H
	ORG $+1
$SG195277 DB	'C:\papa\MyGit\hyperion-zvector\sie.c:1063', 00H
	ORG $+6
$SG195285 DB	'C:\papa\MyGit\hyperion-zvector\sie.c:1111', 00H
	ORG $+6
$SG195290 DB	'C:\papa\MyGit\hyperion-zvector\sie.c:1123', 00H
	ORG $+6
$SG195304 DB	'C:\papa\MyGit\hyperion-zvector\sie.c:1145', 00H
	ORG $+6
$SG195305 DB	'C:\papa\MyGit\hyperion-zvector\sie.c:1148', 00H
	ORG $+6
$SG195306 DB	'C:\papa\MyGit\hyperion-zvector\sie.c:1157', 00H
	ORG $+6
$SG195307 DB	'C:\papa\MyGit\hyperion-zvector\sie.c:1163', 00H
	ORG $+6
$SG195314 DB	'z900_run_sie', 00H
	ORG $+3
$SG195315 DB	'C:\papa\MyGit\hyperion-zvector\sie.c', 00H
	ORG $+3
$SG195313 DB	'HHC00835%s Processor %s%02X: aie invalidated; instructio'
	DB	'n being refetched', 0aH, 00H
	ORG $+5
$SG195322 DB	'HHC00835%s Processor %s%02X: aie invalidated; instructio'
	DB	'n being refetched', 0aH, 00H
	ORG $+5
$SG195323 DB	'z900_run_sie', 00H
	ORG $+3
$SG195324 DB	'C:\papa\MyGit\hyperion-zvector\sie.c', 00H
	ORG $+3
$SG195334 DB	'C:\papa\MyGit\hyperion-zvector\sie.c', 00H
	ORG $+3
$SG195332 DB	'HHC00835%s Processor %s%02X: aie invalidated; instructio'
	DB	'n being refetched', 0aH, 00H
	ORG $+5
$SG195333 DB	'z900_run_sie', 00H
	ORG $+3
$SG195337 DB	'C:\papa\MyGit\hyperion-zvector\sie.c:1268', 00H
	ORG $+6
$SG195340 DB	'C:\papa\MyGit\hyperion-zvector\sie.c:1268', 00H
	ORG $+6
$SG195342 DB	'C:\papa\MyGit\hyperion-zvector\sie.c:1268', 00H
	ORG $+6
$SG195347 DB	'C:\papa\MyGit\hyperion-zvector\sie.c:1278', 00H
	ORG $+6
$SG195350 DB	'C:\papa\MyGit\hyperion-zvector\sie.c:1278', 00H
	ORG $+6
$SG195352 DB	'C:\papa\MyGit\hyperion-zvector\sie.c:1278', 00H
	ORG $+6
$SG195357 DB	'C:\papa\MyGit\hyperion-zvector\sie.c:1283', 00H
	ORG $+6
$SG195360 DB	'C:\papa\MyGit\hyperion-zvector\sie.c:1283', 00H
	ORG $+6
$SG195362 DB	'C:\papa\MyGit\hyperion-zvector\sie.c:1283', 00H
	ORG $+6
$SG195370 DB	'C:\papa\MyGit\hyperion-zvector\sie.c:1343', 00H
	ORG $+6
$SG195371 DB	'run_sie !run', 00H
	ORG $+3
$SG195385 DB	'C:\papa\MyGit\hyperion-zvector\sie.c:1363', 00H
	ORG $+6
$SG195386 DB	'run_sie !run', 00H
	ORG $+3
$SG195388 DB	'C:\papa\MyGit\hyperion-zvector\sie.c:1368', 00H
	ORG $+6
$SG195389 DB	'run_sie ret', 00H
	ORG $+4
$SG195668 DB	'C:\papa\MyGit\hyperion-zvector\sie.c:1406', 00H
	ORG $+6
$SG195669 DB	'sie_xit i,h,g', 00H
	ORG $+2
$SG195679 DB	'C:\papa\MyGit\hyperion-zvector\sie.c:1458', 00H
	ORG $+6
$SG195680 DB	'sie_xit inst', 00H
	ORG $+3
$SG195682 DB	'C:\papa\MyGit\hyperion-zvector\sie.c:1474', 00H
	ORG $+6
$SG195684 DB	'C:\papa\MyGit\hyperion-zvector\sie.c:1477', 00H
	ORG $+6
$SG195685 DB	'sie_xit a=0', 00H
	ORG $+4
$SG195686 DB	'C:\papa\MyGit\hyperion-zvector\sie.c:1479', 00H
	ORG $+6
$SG195708 DB	'C:\papa\MyGit\hyperion-zvector\sie.c:1516', 00H
	ORG $+6
$SG195709 DB	'sie_xit STA_c', 00H
	ORG $+2
$SG195712 DB	'C:\papa\MyGit\hyperion-zvector\sie.c:1530', 00H
	ORG $+6
$SG195713 DB	'TXF itdb', 00H
	ORG $+7
$SG195714 DB	'C:\papa\MyGit\hyperion-zvector\sie.c:1532', 00H
	ORG $+6
$SG195715 DB	'C:\papa\MyGit\hyperion-zvector\sie.c:1537', 00H
	ORG $+6
$SG195717 DB	'C:\papa\MyGit\hyperion-zvector\sie.c:1539', 00H
	ORG $+6
$SG195718 DB	'TXF tnd,con', 00H
	ORG $+4
$SG195722 DB	'C:\papa\MyGit\hyperion-zvector\sie.c:1549', 00H
	ORG $+6
$SG195723 DB	'TXF abrt', 00H
	ORG $+7
$SG195724 DB	'C:\papa\MyGit\hyperion-zvector\sie.c:1552', 00H
	ORG $+6
$SG195727 DB	'C:\papa\MyGit\hyperion-zvector\sie.c:1557', 00H
	ORG $+6
$SG195728 DB	'TXF upgm', 00H
	ORG $+7
$SG195732 DB	'C:\papa\MyGit\hyperion-zvector\sie.c:1564', 00H
	ORG $+6
$SG195733 DB	'TXF itdb <=', 00H
	ORG $+4
$SG195736 DB	'HHC17714%s TXF: %s%02X: SIE: Populating Interception TDB'
	DB	' at 0x%16.16llx', 0aH, 00H
	ORG $+7
$SG195737 DB	'z900_sie_exit', 00H
	ORG $+2
$SG195738 DB	'C:\papa\MyGit\hyperion-zvector\sie.c', 00H
	ORG $+3
$SG195742 DB	'C:\papa\MyGit\hyperion-zvector\sie.c:1584', 00H
	ORG $+6
$SG195743 DB	'*TXF !itdba', 00H
$SG195832 DB	'STZP', 00H
	ORG $+7
$SG195746 DB	'HHC17716%s TXF: %s%02X: SIE: Interception TDB address no'
	DB	't provided!', 0aH, 00H
	ORG $+3
$SG195747 DB	'z900_sie_exit', 00H
	ORG $+2
$SG195748 DB	'C:\papa\MyGit\hyperion-zvector\sie.c', 00H
	ORG $+3
$SG195751 DB	'C:\papa\MyGit\hyperion-zvector\sie.c:1594', 00H
	ORG $+6
$SG195752 DB	'*TXF itdba<=0', 00H
	ORG $+2
$SG195783 DB	'C:\papa\MyGit\hyperion-zvector\sie.c:1754', 00H
	ORG $+6
$SG195784 DB	'sie_xit ret', 00H
	ORG $+4
$SG195827 DB	'C:\papa\MyGit\hyperion-zvector\sie.c:1775', 00H
	ORG $+6
$SG195831 DB	'C:\papa\MyGit\hyperion-zvector\sie.c:1780', 00H
	ORG $+6
$SG195836 DB	'C:\papa\MyGit\hyperion-zvector\sie.c:1788', 00H
	ORG $+6
$SG195884 DB	'C:\papa\MyGit\hyperion-zvector\sie.c:1820', 00H
	ORG $+6
$SG195888 DB	'C:\papa\MyGit\hyperion-zvector\sie.c:1825', 00H
	ORG $+6
$SG195894 DB	'C:\papa\MyGit\hyperion-zvector\sie.c:1833', 00H
	ORG $+2
$SG195895 DB	'*SZP', 00H
	ORG $+7
$SG195948 DB	'C:\papa\MyGit\hyperion-zvector\sie.c:1879', 00H
	ORG $+6
$SG195952 DB	'C:\papa\MyGit\hyperion-zvector\sie.c:1884', 00H
	ORG $+2
$SG195953 DB	'TPZI', 00H
	ORG $+7
$SG195957 DB	'C:\papa\MyGit\hyperion-zvector\sie.c:1896', 00H
	ORG $+2
$SG195958 DB	'*TPZI', 00H
	ORG $+6
$SG195961 DB	'C:\papa\MyGit\hyperion-zvector\sie.c:1904', 00H
	ORG $+6
$SG195964 DB	'C:\papa\MyGit\hyperion-zvector\sie.c:1918', 00H
	ORG $+6
$SG195965 DB	'C:\papa\MyGit\hyperion-zvector\sie.c:1927', 00H
	ORG $+6
$SG195990 DB	'C:\papa\MyGit\hyperion-zvector\sie.c:1957', 00H
	ORG $+6
$SG195991 DB	'*DIAG002', 00H
	ORG $+7
$SG195992 DB	'C:\papa\MyGit\hyperion-zvector\sie.c:1963', 00H
	ORG $+6
$SG195996 DB	'C:\papa\MyGit\hyperion-zvector\sie.c:1988', 00H
_DATA	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$z900_GetPGSTE_and_RCPTE DD 011801H
	DD	04218H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$z900_GetOldRCP DD 010e01H
	DD	0820eH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$z900_GetPGSTE DD 010e01H
	DD	0620eH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$z900_GetPGSTEFromPTE DD 010e01H
	DD	0420eH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$z900_LockUnlockKeyLock DD 011801H
	DD	04218H
xdata	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DB	0a5H
voltbl	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$z900_LockUnlockSKALock DD 010d01H
	DD	0620dH
xdata	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DB	071H
voltbl	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$z900_LockUnlockRCPLock DD 011301H
	DD	06213H
xdata	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DB	0dcH
voltbl	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$z900_LockUnlockSCALock DD 011201H
	DD	08212H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$z900_instfetch DD 021001H
	DD	0170110H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$z900_vfetchc DD 031901H
	DD	07015a219H
	DD	06014H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$z900_vstorec DD 031901H
	DD	07015c219H
	DD	06014H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$z900_maddr_l DD 011801H
	DD	0a218H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$z900_per3_zero_xcheck DD 010d01H
	DD	0620dH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$z900_per3_zero DD 010901H
	DD	06209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$z900_get_ptr_to_storekey DD 010901H
	DD	04209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$z900_or_4K_storage_key DD 010d01H
	DD	0420dH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$z900_get_ptr_to_4K_storekey DD 010901H
	DD	04209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$z900__or_storage_key DD 011201H
	DD	08212H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$s390_GetPGSTE_and_RCPTE DD 011801H
	DD	04218H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$s390_GetOldRCP DD 010e01H
	DD	0820eH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$s390_GetPGSTE DD 010e01H
	DD	0820eH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$s390_GetPGSTEFromPTE DD 010e01H
	DD	0420eH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$s390_LockUnlockKeyLock DD 011801H
	DD	04218H
xdata	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DB	0a5H
voltbl	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$s390_LockUnlockSKALock DD 010d01H
	DD	0620dH
xdata	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DB	071H
voltbl	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$s390_LockUnlockRCPLock DD 011301H
	DD	06213H
xdata	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DB	0dcH
voltbl	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$s390_LockUnlockSCALock DD 011201H
	DD	08212H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$s390_instfetch DD 021001H
	DD	0150110H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$s390_vfetchc DD 031901H
	DD	07015a219H
	DD	06014H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$s390_vstorec DD 031901H
	DD	07015c219H
	DD	06014H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$s390_maddr_l DD 011701H
	DD	0a217H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$s390_get_ptr_to_storekey DD 010901H
	DD	04209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$s390_or_4K_storage_key DD 010d01H
	DD	0420dH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$s390_get_ptr_to_4K_storekey DD 010901H
	DD	04209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$s390__or_storage_key DD 011201H
	DD	08212H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$s370_GetPGSTE_and_RCPTE DD 011801H
	DD	04218H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$s370_GetOldRCP DD 010e01H
	DD	0820eH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$s370_GetPGSTE DD 010e01H
	DD	0620eH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$s370_GetPGSTEFromPTE DD 010e01H
	DD	0420eH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$s370_LockUnlockKeyLock DD 011801H
	DD	04218H
xdata	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DB	0a5H
voltbl	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$s370_LockUnlockSKALock DD 010d01H
	DD	0620dH
xdata	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DB	071H
voltbl	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$s370_LockUnlockRCPLock DD 011301H
	DD	06213H
xdata	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DB	0dcH
voltbl	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$s370_LockUnlockSCALock DD 011201H
	DD	08212H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$s370_instfetch DD 021001H
	DD	0130110H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$s370_maddr_l DD 011701H
	DD	0a217H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$s370_or_4K_storage_key DD 010d01H
	DD	0420dH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$s370__or_storage_key DD 011201H
	DD	08212H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$_get_storekey_ptr DD 010d01H
	DD	0220dH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$fetch_dw_noswap DD 010901H
	DD	02209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$fetch_fw_noswap DD 010901H
	DD	02209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$fetch_hw_noswap DD 010901H
	DD	02209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$cmpxchg1_x86 DD 011201H
	DD	0c212H
xdata	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DB	035H
voltbl	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$cmpxchg4_x86 DD 011201H
	DD	02212H
xdata	ENDS
voltbl	SEGMENT
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:atomic_update64
	DD	014H
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:z900_set_zone_parameter
	DD	01bH
	DD	04ccH
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:z900_store_zone_parameter
	DD	01bH
	DD	0417H
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:z900_test_pending_zone_interrupt
	DD	01bH
	DD	045aH
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:s390_set_zone_parameter
	DD	01bH
	DD	03f6H
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:s390_store_zone_parameter
	DD	01bH
	DD	03b2H
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:s390_test_pending_zone_interrupt
	DD	01bH
	DD	03fdH
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:z900_run_sie
	DD	016H
	DD	0273fH
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:s390_run_sie
	DD	016H
	DD	0175aH
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:s370_run_sie
	DD	016H
	DD	01725H
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:host_tod
	DD	0eH
	DD	097H
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:z900_start_interpretive_execution
	DD	013H
	DD	01e70H
	DD	01e74H
	DD	025e3H
	DD	025fcH
	DD	02653H
	DD	02695H
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:s390_start_interpretive_execution
	DD	013H
	DD	01c56H
	DD	01c5aH
	DD	025f1H
	DD	0260aH
	DD	02661H
	DD	026a3H
voltbl	ENDS
xdata	SEGMENT
$unwind$calloc_aligned DD 020f01H
	DD	0700b520fH
$unwind$host_tod DD 011319H
	DD	0a204H
	DD	imagerel __GSHandlerCheck
	DD	040H
$unwind$Interrupt_Lock_Obtained DD 010e01H
	DD	0420eH
$unwind$Obtain_Interrupt_Lock DD 010e01H
	DD	0420eH
$unwind$Release_Interrupt_Lock DD 010e01H
	DD	0420eH
$unwind$s370_run_sie DD 021e19H
	DD	01f010cH
	DD	imagerel __GSHandlerCheck
	DD	0e0H
$unwind$s390_run_sie DD 021e19H
	DD	01b010cH
	DD	imagerel __GSHandlerCheck
	DD	0c8H
$unwind$z900_run_sie DD 021e19H
	DD	023010cH
	DD	imagerel __GSHandlerCheck
	DD	0108H
$unwind$s390_sie_exit DD 041201H
	DD	01d0112H
	DD	0600a700bH
$unwind$s390_diagnose_002 DD 011201H
	DD	0c212H
$unwind$s390_start_interpretive_execution DD 041301H
	DD	0230113H
	DD	0600b700cH
$unwind$s390_test_pending_zone_interrupt DD 022019H
	DD	0110111H
	DD	imagerel __GSHandlerCheck
	DD	070H
$unwind$s390_store_zone_parameter DD 022019H
	DD	0110111H
	DD	imagerel __GSHandlerCheck
	DD	078H
$unwind$s390_set_zone_parameter DD 022319H
	DD	0150111H
	DD	imagerel __GSHandlerCheck
	DD	098H
$unwind$z900_sie_exit DD 041201H
	DD	0270112H
	DD	0600a700bH
$unwind$z900_diagnose_002 DD 011201H
	DD	0c212H
$unwind$z900_store_hypervisor_information DD 010e01H
	DD	0620eH
$unwind$z900_start_interpretive_execution DD 041301H
	DD	0230113H
	DD	0600b700cH
$unwind$z900_test_pending_zone_interrupt DD 022019H
	DD	0110111H
	DD	imagerel __GSHandlerCheck
	DD	070H
$unwind$z900_store_zone_parameter DD 022019H
	DD	0110111H
	DD	imagerel __GSHandlerCheck
	DD	078H
$unwind$z900_set_zone_parameter DD 022319H
	DD	0150111H
	DD	imagerel __GSHandlerCheck
	DD	098H
$unwind$z900_extract_and_set_storage_attributes DD 010e01H
	DD	0620eH
xdata	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\sie.h
;	COMDAT z900_GetPGSTE_and_RCPTE
_TEXT	SEGMENT
regs$ = 48
gabspage$ = 56
ppPGSTE$ = 64
ppRCPTE$ = 72
z900_GetPGSTE_and_RCPTE PROC				; COMDAT

; 516  : {

$LN7:
  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 517  : #if defined( _FEATURE_STORAGE_KEY_ASSIST )
; 518  :     if (0
; 519  :         || SIE_STATE_BIT_ON( regs, RCPO0, SKA )
; 520  : #if defined( _FEATURE_ZSIE )
; 521  :         // SKA is always active for z/VM
; 522  :         || ARCH_900_IDX == HOSTREGS->arch_mode

  00018	33 c0		 xor	 eax, eax
  0001a	85 c0		 test	 eax, eax
  0001c	75 49		 jne	 SHORT $LN4@z900_GetPG
  0001e	48 8b 44 24 30	 mov	 rax, QWORD PTR regs$[rsp]
  00023	8b 80 c8 08 00
	00		 mov	 eax, DWORD PTR [rax+2248]
  00029	d1 e8		 shr	 eax, 1
  0002b	83 e0 01	 and	 eax, 1
  0002e	85 c0		 test	 eax, eax
  00030	74 23		 je	 SHORT $LN5@z900_GetPG
  00032	48 8b 44 24 30	 mov	 rax, QWORD PTR regs$[rsp]
  00037	48 8b 80 88 08
	00 00		 mov	 rax, QWORD PTR [rax+2184]
  0003e	b9 01 00 00 00	 mov	 ecx, 1
  00043	48 6b c9 00	 imul	 rcx, rcx, 0
  00047	0f b6 44 08 60	 movzx	 eax, BYTE PTR [rax+rcx+96]
  0004c	25 80 00 00 00	 and	 eax, 128		; 00000080H
  00051	85 c0		 test	 eax, eax
  00053	75 12		 jne	 SHORT $LN4@z900_GetPG
$LN5@z900_GetPG:
  00055	48 8b 44 24 30	 mov	 rax, QWORD PTR regs$[rsp]
  0005a	48 8b 80 68 08
	00 00		 mov	 rax, QWORD PTR [rax+2152]
  00061	83 78 64 02	 cmp	 DWORD PTR [rax+100], 2
  00065	75 2c		 jne	 SHORT $LN2@z900_GetPG
$LN4@z900_GetPG:

; 523  : #endif
; 524  :     )
; 525  :     {
; 526  :         /* SKA: Get pointer to both PGSTE and RCPTE */
; 527  :         *ppPGSTE = ARCH_DEP( GetPGSTE )( regs, gabspage );

  00067	48 8b 54 24 38	 mov	 rdx, QWORD PTR gabspage$[rsp]
  0006c	48 8b 4c 24 30	 mov	 rcx, QWORD PTR regs$[rsp]
  00071	e8 00 00 00 00	 call	 z900_GetPGSTE
  00076	48 8b 4c 24 40	 mov	 rcx, QWORD PTR ppPGSTE$[rsp]
  0007b	48 89 01	 mov	 QWORD PTR [rcx], rax

; 528  :         *ppRCPTE = &(*ppPGSTE)->pgsrcp;

  0007e	48 8b 44 24 40	 mov	 rax, QWORD PTR ppPGSTE$[rsp]
  00083	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00086	48 ff c0	 inc	 rax
  00089	48 8b 4c 24 48	 mov	 rcx, QWORD PTR ppRCPTE$[rsp]
  0008e	48 89 01	 mov	 QWORD PTR [rcx], rax

; 529  :     }

  00091	eb 23		 jmp	 SHORT $LN3@z900_GetPG
$LN2@z900_GetPG:

; 530  :     else // (NOT SKA...)
; 531  : #endif /* defined( _FEATURE_STORAGE_KEY_ASSIST ) */
; 532  :     {
; 533  : #if defined( FEATURE_MULTIPLE_CONTROLLED_DATA_SPACE )
; 534  :         if (SIE_STATE_BIT_ON( regs, MX, XC ))
; 535  :             SIE_INTERCEPT( regs );
; 536  : #endif
; 537  :         /* Get just the pointer to the old RCP table byte */
; 538  :         *ppPGSTE = NULL;

  00093	48 8b 44 24 40	 mov	 rax, QWORD PTR ppPGSTE$[rsp]
  00098	48 c7 00 00 00
	00 00		 mov	 QWORD PTR [rax], 0

; 539  :         *ppRCPTE = ARCH_DEP( GetOldRCP )( regs, gabspage );

  0009f	48 8b 54 24 38	 mov	 rdx, QWORD PTR gabspage$[rsp]
  000a4	48 8b 4c 24 30	 mov	 rcx, QWORD PTR regs$[rsp]
  000a9	e8 00 00 00 00	 call	 z900_GetOldRCP
  000ae	48 8b 4c 24 48	 mov	 rcx, QWORD PTR ppRCPTE$[rsp]
  000b3	48 89 01	 mov	 QWORD PTR [rcx], rax
$LN3@z900_GetPG:

; 540  :     }
; 541  : }

  000b6	48 83 c4 28	 add	 rsp, 40			; 00000028H
  000ba	c3		 ret	 0
z900_GetPGSTE_and_RCPTE ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\sie.h
;	COMDAT z900_GetOldRCP
_TEXT	SEGMENT
rcpa$ = 48
regs$ = 80
gabspage$ = 88
z900_GetOldRCP PROC					; COMDAT

; 497  : {

$LN3:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 498  :     /* Obtain address of the RCP area from the state desc */
; 499  :     RADR rcpa = regs->sie_rcpo;

  0000e	48 8b 44 24 50	 mov	 rax, QWORD PTR regs$[rsp]
  00013	48 8b 80 b0 08
	00 00		 mov	 rax, QWORD PTR [rax+2224]
  0001a	48 89 44 24 30	 mov	 QWORD PTR rcpa$[rsp], rax

; 500  : 
; 501  :     /* Use page index as byte offset into RCP table */
; 502  :     rcpa += (gabspage >> STORKEY_KEY_4K_SHIFTAMT);

  0001f	48 8b 44 24 58	 mov	 rax, QWORD PTR gabspage$[rsp]
  00024	48 c1 e8 0c	 shr	 rax, 12
  00028	48 8b 4c 24 30	 mov	 rcx, QWORD PTR rcpa$[rsp]
  0002d	48 03 c8	 add	 rcx, rax
  00030	48 8b c1	 mov	 rax, rcx
  00033	48 89 44 24 30	 mov	 QWORD PTR rcpa$[rsp], rax

; 503  : 
; 504  :     /* Translate host primary address to host absolute */
; 505  :     rcpa = SIE_LOGICAL_TO_ABS( rcpa, USE_PRIMARY_SPACE,

  00038	48 c7 44 24 28
	01 00 00 00	 mov	 QWORD PTR [rsp+40], 1
  00041	c6 44 24 20 00	 mov	 BYTE PTR [rsp+32], 0
  00046	45 33 c9	 xor	 r9d, r9d
  00049	48 8b 44 24 50	 mov	 rax, QWORD PTR regs$[rsp]
  0004e	4c 8b 80 68 08
	00 00		 mov	 r8, QWORD PTR [rax+2152]
  00055	ba fd ff ff ff	 mov	 edx, -3
  0005a	48 8b 4c 24 30	 mov	 rcx, QWORD PTR rcpa$[rsp]
  0005f	e8 00 00 00 00	 call	 z900_logical_to_main_l
  00064	48 8b 44 24 50	 mov	 rax, QWORD PTR regs$[rsp]
  00069	48 8b 80 68 08
	00 00		 mov	 rax, QWORD PTR [rax+2152]
  00070	48 8b 80 08 08
	00 00		 mov	 rax, QWORD PTR [rax+2056]
  00077	48 89 44 24 30	 mov	 QWORD PTR rcpa$[rsp], rax

; 506  :                                HOSTREGS, ACCTYPE_SIE, 0 );
; 507  : 
; 508  :     /* Return mainstor address of RCP table byte */
; 509  :     return (RCPTE*)(&regs->mainstor[ rcpa ]);

  0007c	48 8b 44 24 50	 mov	 rax, QWORD PTR regs$[rsp]
  00081	48 8b 80 48 08
	00 00		 mov	 rax, QWORD PTR [rax+2120]
  00088	48 03 44 24 30	 add	 rax, QWORD PTR rcpa$[rsp]

; 510  : }

  0008d	48 83 c4 48	 add	 rsp, 72			; 00000048H
  00091	c3		 ret	 0
z900_GetOldRCP ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\sie.h
;	COMDAT z900_GetPGSTE
_TEXT	SEGMENT
pte$ = 32
pgste$ = 40
regs$ = 64
gabspage$ = 72
z900_GetPGSTE PROC					; COMDAT

; 475  : {

$LN8:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 476  :     PGSTE*  pgste;
; 477  :     U64     pte;
; 478  : 
; 479  :     // Guest absolute to host PTE addr
; 480  :     if (SIE_TRANSLATE_ADDR( regs->sie_mso + gabspage,

  0000e	48 8b 44 24 40	 mov	 rax, QWORD PTR regs$[rsp]
  00013	48 8b 80 98 08
	00 00		 mov	 rax, QWORD PTR [rax+2200]
  0001a	48 03 44 24 48	 add	 rax, QWORD PTR gabspage$[rsp]
  0001f	41 b9 00 03 00
	00		 mov	 r9d, 768		; 00000300H
  00025	48 8b 4c 24 40	 mov	 rcx, QWORD PTR regs$[rsp]
  0002a	4c 8b 81 68 08
	00 00		 mov	 r8, QWORD PTR [rcx+2152]
  00031	ba fd ff ff ff	 mov	 edx, -3
  00036	48 8b c8	 mov	 rcx, rax
  00039	e8 00 00 00 00	 call	 z900_translate_addr
  0003e	85 c0		 test	 eax, eax
  00040	74 32		 je	 SHORT $LN5@z900_GetPG
$LN4@z900_GetPG:

; 481  :                             USE_PRIMARY_SPACE,
; 482  :                             HOSTREGS, ACCTYPE_PTE ))
; 483  :         SIE_INTERCEPT( regs );

  00042	48 8b 44 24 40	 mov	 rax, QWORD PTR regs$[rsp]
  00047	8b 80 c8 08 00
	00		 mov	 eax, DWORD PTR [rax+2248]
  0004d	d1 e8		 shr	 eax, 1
  0004f	83 e0 01	 and	 eax, 1
  00052	85 c0		 test	 eax, eax
  00054	74 18		 je	 SHORT $LN6@z900_GetPG
  00056	48 8b 44 24 40	 mov	 rax, QWORD PTR regs$[rsp]
  0005b	48 05 80 09 00
	00		 add	 rax, 2432		; 00000980H
  00061	ba fc ff ff ff	 mov	 edx, -4
  00066	48 8b c8	 mov	 rcx, rax
  00069	e8 00 00 00 00	 call	 longjmp
$LN6@z900_GetPG:
  0006e	33 c0		 xor	 eax, eax
  00070	85 c0		 test	 eax, eax
  00072	75 ce		 jne	 SHORT $LN4@z900_GetPG
$LN5@z900_GetPG:

; 484  : 
; 485  :     // Convert host real address to host absolute address
; 486  :     pte = apply_host_prefixing( HOSTREGS, HOSTREGS->dat.raddr );

  00074	48 8b 44 24 40	 mov	 rax, QWORD PTR regs$[rsp]
  00079	48 8b 80 68 08
	00 00		 mov	 rax, QWORD PTR [rax+2152]
  00080	48 8b 90 00 08
	00 00		 mov	 rdx, QWORD PTR [rax+2048]
  00087	48 8b 44 24 40	 mov	 rax, QWORD PTR regs$[rsp]
  0008c	48 8b 88 68 08
	00 00		 mov	 rcx, QWORD PTR [rax+2152]
  00093	e8 00 00 00 00	 call	 apply_host_prefixing
  00098	48 89 44 24 20	 mov	 QWORD PTR pte$[rsp], rax

; 487  : 
; 488  :     // Convert host abs PTE to PGSTE
; 489  :     pgste = ARCH_DEP( GetPGSTEFromPTE )( regs, pte );

  0009d	48 8b 54 24 20	 mov	 rdx, QWORD PTR pte$[rsp]
  000a2	48 8b 4c 24 40	 mov	 rcx, QWORD PTR regs$[rsp]
  000a7	e8 00 00 00 00	 call	 z900_GetPGSTEFromPTE
  000ac	48 89 44 24 28	 mov	 QWORD PTR pgste$[rsp], rax

; 490  :     return pgste;

  000b1	48 8b 44 24 28	 mov	 rax, QWORD PTR pgste$[rsp]
$LN7@z900_GetPG:

; 491  : }

  000b6	48 83 c4 38	 add	 rsp, 56			; 00000038H
  000ba	c3		 ret	 0
z900_GetPGSTE ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\sie.h
;	COMDAT z900_GetPGSTEFromPTE
_TEXT	SEGMENT
tv67 = 0
pte_offset_to_pgste$ = 8
pgste$ = 16
regs$ = 48
pte$ = 56
z900_GetPGSTEFromPTE PROC				; COMDAT

; 456  : {

$LN5:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 457  :     PGSTE*  pgste;
; 458  :     size_t  pte_offset_to_pgste;
; 459  : 
; 460  :     // Calculate offset to PGSTE (depends if host is z/VM or VM/ESA)
; 461  :     pte_offset_to_pgste = (ARCH_900_IDX == HOSTREGS->arch_mode)

  0000e	48 8b 44 24 30	 mov	 rax, QWORD PTR regs$[rsp]
  00013	48 8b 80 68 08
	00 00		 mov	 rax, QWORD PTR [rax+2152]
  0001a	83 78 64 02	 cmp	 DWORD PTR [rax+100], 2
  0001e	75 0a		 jne	 SHORT $LN3@z900_GetPG
  00020	48 c7 04 24 00
	08 00 00	 mov	 QWORD PTR tv67[rsp], 2048 ; 00000800H
  00028	eb 08		 jmp	 SHORT $LN4@z900_GetPG
$LN3@z900_GetPG:
  0002a	48 c7 04 24 00
	04 00 00	 mov	 QWORD PTR tv67[rsp], 1024 ; 00000400H
$LN4@z900_GetPG:
  00032	48 8b 04 24	 mov	 rax, QWORD PTR tv67[rsp]
  00036	48 89 44 24 08	 mov	 QWORD PTR pte_offset_to_pgste$[rsp], rax

; 462  :         ? offsetof( PGMBK64, pgmpgstb )   // (z/Arch z/VM)
; 463  :         : offsetof( PGMBK,   pgmpgstb );  // (S/390 VM/ESA)
; 464  : 
; 465  :     // Return mainstor address of PGSTE
; 466  :     pgste = (PGSTE*)&regs->mainstor[ pte + pte_offset_to_pgste ];

  0003b	48 8b 44 24 08	 mov	 rax, QWORD PTR pte_offset_to_pgste$[rsp]
  00040	48 8b 4c 24 38	 mov	 rcx, QWORD PTR pte$[rsp]
  00045	48 03 c8	 add	 rcx, rax
  00048	48 8b c1	 mov	 rax, rcx
  0004b	48 8b 4c 24 30	 mov	 rcx, QWORD PTR regs$[rsp]
  00050	48 8b 89 48 08
	00 00		 mov	 rcx, QWORD PTR [rcx+2120]
  00057	48 03 c8	 add	 rcx, rax
  0005a	48 8b c1	 mov	 rax, rcx
  0005d	48 89 44 24 10	 mov	 QWORD PTR pgste$[rsp], rax

; 467  : 
; 468  :     return pgste;

  00062	48 8b 44 24 10	 mov	 rax, QWORD PTR pgste$[rsp]

; 469  : }

  00067	48 83 c4 28	 add	 rsp, 40			; 00000028H
  0006b	c3		 ret	 0
z900_GetPGSTEFromPTE ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\sie.h
;	COMDAT z900_LockUnlockKeyLock
_TEXT	SEGMENT
regs$ = 48
pgste$ = 56
rcpte$ = 64
lock$ = 72
z900_LockUnlockKeyLock PROC				; COMDAT

; 437  : {

$LN5:
  00000	44 88 4c 24 20	 mov	 BYTE PTR [rsp+32], r9b
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 438  : #if defined( OPTION_USE_SKAIP_AS_LOCK )
; 439  :     if (pgste)

  00018	48 83 7c 24 38
	00		 cmp	 QWORD PTR pgste$[rsp], 0
  0001e	74 11		 je	 SHORT $LN2@z900_LockU

; 440  :         ARCH_DEP( LockUnlockSKALock )( regs, lock );

  00020	0f b6 54 24 48	 movzx	 edx, BYTE PTR lock$[rsp]
  00025	48 8b 4c 24 30	 mov	 rcx, QWORD PTR regs$[rsp]
  0002a	e8 00 00 00 00	 call	 z900_LockUnlockSKALock
  0002f	eb 15		 jmp	 SHORT $LN3@z900_LockU
$LN2@z900_LockU:

; 441  :     else
; 442  : #endif
; 443  :         ARCH_DEP( LockUnlockRCPLock )( regs, rcpte, lock );

  00031	44 0f b6 44 24
	48		 movzx	 r8d, BYTE PTR lock$[rsp]
  00037	48 8b 54 24 40	 mov	 rdx, QWORD PTR rcpte$[rsp]
  0003c	48 8b 4c 24 30	 mov	 rcx, QWORD PTR regs$[rsp]
  00041	e8 00 00 00 00	 call	 z900_LockUnlockRCPLock
$LN3@z900_LockU:

; 444  : }

  00046	48 83 c4 28	 add	 rsp, 40			; 00000028H
  0004a	c3		 ret	 0
z900_LockUnlockKeyLock ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\sie.h
;	COMDAT z900_LockUnlockSKALock
_TEXT	SEGMENT
old$1 = 32
new$ = 33
abspage$2 = 40
regs$ = 64
lock$ = 72
z900_LockUnlockSKALock PROC				; COMDAT

; 366  : {

$LN8:
  00000	88 54 24 10	 mov	 BYTE PTR [rsp+16], dl
  00004	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00009	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 367  :     BYTE new;
; 368  : 
; 369  :     if (lock)

  0000d	0f b6 44 24 48	 movzx	 eax, BYTE PTR lock$[rsp]
  00012	85 c0		 test	 eax, eax
  00014	74 6b		 je	 SHORT $LN5@z900_LockU

; 370  :     {
; 371  :         BYTE old = regs->siebk->SIE_RCPO0;

  00016	48 8b 44 24 40	 mov	 rax, QWORD PTR regs$[rsp]
  0001b	48 8b 80 88 08
	00 00		 mov	 rax, QWORD PTR [rax+2184]
  00022	b9 01 00 00 00	 mov	 ecx, 1
  00027	48 6b c9 00	 imul	 rcx, rcx, 0
  0002b	0f b6 44 08 60	 movzx	 eax, BYTE PTR [rax+rcx+96]
  00030	88 44 24 20	 mov	 BYTE PTR old$1[rsp], al
$LN4@z900_LockU:

; 372  : 
; 373  :         // MAINLOCK may be required if cmpxchg assists unavailable
; 374  :         OBTAIN_MAINLOCK( regs );
; 375  :         {
; 376  :             // Keep looping until we eventually obtain it...
; 377  :             do
; 378  :             {
; 379  :                 old &= ~SIE_RCPO0_SKAIP;        // Want bit to be initially off

  00034	0f b6 44 24 20	 movzx	 eax, BYTE PTR old$1[rsp]
  00039	83 e0 bf	 and	 eax, -65		; ffffffffffffffbfH
  0003c	88 44 24 20	 mov	 BYTE PTR old$1[rsp], al

; 380  :                 new = (old | SIE_RCPO0_SKAIP);  // And *WE* want to turn it on!

  00040	0f b6 44 24 20	 movzx	 eax, BYTE PTR old$1[rsp]
  00045	83 c8 40	 or	 eax, 64			; 00000040H
  00048	88 44 24 21	 mov	 BYTE PTR new$[rsp], al

; 381  :             }
; 382  :             while (cmpxchg1( &old, new, &regs->siebk->SIE_RCPO0 ) != 0);

  0004c	48 8b 44 24 40	 mov	 rax, QWORD PTR regs$[rsp]
  00051	48 8b 80 88 08
	00 00		 mov	 rax, QWORD PTR [rax+2184]
  00058	b9 01 00 00 00	 mov	 ecx, 1
  0005d	48 6b c9 00	 imul	 rcx, rcx, 0
  00061	48 8d 44 08 60	 lea	 rax, QWORD PTR [rax+rcx+96]
  00066	4c 8b c0	 mov	 r8, rax
  00069	0f b6 54 24 21	 movzx	 edx, BYTE PTR new$[rsp]
  0006e	48 8d 4c 24 20	 lea	 rcx, QWORD PTR old$1[rsp]
  00073	e8 00 00 00 00	 call	 cmpxchg1_x86
  00078	0f b6 c0	 movzx	 eax, al
  0007b	85 c0		 test	 eax, eax
  0007d	75 b5		 jne	 SHORT $LN4@z900_LockU

; 383  :         }
; 384  :         RELEASE_MAINLOCK( regs );
; 385  :     }

  0007f	eb 27		 jmp	 SHORT $LN6@z900_LockU
$LN5@z900_LockU:

; 386  :     else // (unlock)
; 387  :     {
; 388  :         // Atomically 'and' the lock bit off
; 389  :         new = ~SIE_RCPO0_SKAIP;

  00081	c6 44 24 21 bf	 mov	 BYTE PTR new$[rsp], 191	; 000000bfH

; 390  :         (void) H_ATOMIC_OP( &regs->siebk->SIE_RCPO0, new, and, And, & );

  00086	48 8b 44 24 40	 mov	 rax, QWORD PTR regs$[rsp]
  0008b	48 8b 80 88 08
	00 00		 mov	 rax, QWORD PTR [rax+2184]
  00092	b9 01 00 00 00	 mov	 ecx, 1
  00097	48 6b c9 00	 imul	 rcx, rcx, 0
  0009b	48 8d 44 08 60	 lea	 rax, QWORD PTR [rax+rcx+96]
  000a0	0f b6 4c 24 21	 movzx	 ecx, BYTE PTR new$[rsp]
  000a5	f0 20 08	 lock and BYTE PTR [rax], cl
$LN6@z900_LockU:

; 391  :     }
; 392  : 
; 393  :     // Set Reference and Change bit for the byte we just modified
; 394  :     {
; 395  :         U64 abspage = (U64) (((BYTE*)regs->siebk) - regs->mainstor);

  000a8	48 8b 44 24 40	 mov	 rax, QWORD PTR regs$[rsp]
  000ad	48 8b 4c 24 40	 mov	 rcx, QWORD PTR regs$[rsp]
  000b2	48 8b 89 48 08
	00 00		 mov	 rcx, QWORD PTR [rcx+2120]
  000b9	48 8b 80 88 08
	00 00		 mov	 rax, QWORD PTR [rax+2184]
  000c0	48 2b c1	 sub	 rax, rcx
  000c3	48 89 44 24 28	 mov	 QWORD PTR abspage$2[rsp], rax

; 396  :         ARCH_DEP( or_4K_storage_key )( abspage, (STORKEY_REF | STORKEY_CHANGE) );

  000c8	b2 06		 mov	 dl, 6
  000ca	48 8b 4c 24 28	 mov	 rcx, QWORD PTR abspage$2[rsp]
  000cf	e8 00 00 00 00	 call	 z900_or_4K_storage_key

; 397  :     }
; 398  : }

  000d4	48 83 c4 38	 add	 rsp, 56			; 00000038H
  000d8	c3		 ret	 0
z900_LockUnlockSKALock ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\sie.h
;	COMDAT z900_LockUnlockRCPLock
_TEXT	SEGMENT
old$1 = 32
new$ = 33
abspage$2 = 40
regs$ = 64
rcpte$ = 72
lock$ = 80
z900_LockUnlockRCPLock PROC				; COMDAT

; 316  : {

$LN8:
  00000	44 88 44 24 18	 mov	 BYTE PTR [rsp+24], r8b
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 317  :     BYTE new;
; 318  : 
; 319  :     if (lock)

  00013	0f b6 44 24 50	 movzx	 eax, BYTE PTR lock$[rsp]
  00018	85 c0		 test	 eax, eax
  0001a	74 46		 je	 SHORT $LN5@z900_LockU

; 320  :     {
; 321  :         BYTE old = rcpte->rcpbyte;

  0001c	48 8b 44 24 48	 mov	 rax, QWORD PTR rcpte$[rsp]
  00021	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  00024	88 44 24 20	 mov	 BYTE PTR old$1[rsp], al
$LN4@z900_LockU:

; 322  : 
; 323  :         // MAINLOCK may be required if cmpxchg assists unavailable
; 324  :         OBTAIN_MAINLOCK( regs );
; 325  :         {
; 326  :             // Keep looping until we eventually obtain it...
; 327  :             do
; 328  :             {
; 329  :                 old &= ~RCPLOCK;        // Want bit to be initially off

  00028	0f b6 44 24 20	 movzx	 eax, BYTE PTR old$1[rsp]
  0002d	0f ba f0 07	 btr	 eax, 7
  00031	88 44 24 20	 mov	 BYTE PTR old$1[rsp], al

; 330  :                 new = (old | RCPLOCK);  // And *WE* want to turn it on!

  00035	0f b6 44 24 20	 movzx	 eax, BYTE PTR old$1[rsp]
  0003a	0f ba e8 07	 bts	 eax, 7
  0003e	88 44 24 21	 mov	 BYTE PTR new$[rsp], al

; 331  :             }
; 332  :             while (cmpxchg1( &old, new, &rcpte->rcpbyte ) != 0);

  00042	48 8b 44 24 48	 mov	 rax, QWORD PTR rcpte$[rsp]
  00047	4c 8b c0	 mov	 r8, rax
  0004a	0f b6 54 24 21	 movzx	 edx, BYTE PTR new$[rsp]
  0004f	48 8d 4c 24 20	 lea	 rcx, QWORD PTR old$1[rsp]
  00054	e8 00 00 00 00	 call	 cmpxchg1_x86
  00059	0f b6 c0	 movzx	 eax, al
  0005c	85 c0		 test	 eax, eax
  0005e	75 c8		 jne	 SHORT $LN4@z900_LockU

; 333  :         }
; 334  :         RELEASE_MAINLOCK( regs );
; 335  :     }

  00060	eb 12		 jmp	 SHORT $LN6@z900_LockU
$LN5@z900_LockU:

; 336  :     else // (unlock)
; 337  :     {
; 338  :         // Atomically 'and' the lock bit off
; 339  :         new = (BYTE)(~RCPLOCK);

  00062	c6 44 24 21 7f	 mov	 BYTE PTR new$[rsp], 127	; 0000007fH

; 340  :         (void) H_ATOMIC_OP( &rcpte->rcpbyte, new, and, And, & );

  00067	48 8b 44 24 48	 mov	 rax, QWORD PTR rcpte$[rsp]
  0006c	0f b6 4c 24 21	 movzx	 ecx, BYTE PTR new$[rsp]
  00071	f0 20 08	 lock and BYTE PTR [rax], cl
$LN6@z900_LockU:

; 341  :     }
; 342  : 
; 343  :     // Set Reference and Change bit for the byte we just modified
; 344  :     {
; 345  :         U64 abspage = (U64) (((BYTE*)rcpte) - regs->mainstor);

  00074	48 8b 44 24 40	 mov	 rax, QWORD PTR regs$[rsp]
  00079	48 8b 80 48 08
	00 00		 mov	 rax, QWORD PTR [rax+2120]
  00080	48 8b 4c 24 48	 mov	 rcx, QWORD PTR rcpte$[rsp]
  00085	48 2b c8	 sub	 rcx, rax
  00088	48 8b c1	 mov	 rax, rcx
  0008b	48 89 44 24 28	 mov	 QWORD PTR abspage$2[rsp], rax

; 346  :         ARCH_DEP( or_4K_storage_key )( abspage, (STORKEY_REF | STORKEY_CHANGE) );

  00090	b2 06		 mov	 dl, 6
  00092	48 8b 4c 24 28	 mov	 rcx, QWORD PTR abspage$2[rsp]
  00097	e8 00 00 00 00	 call	 z900_or_4K_storage_key

; 347  :     }
; 348  : }

  0009c	48 83 c4 38	 add	 rsp, 56			; 00000038H
  000a0	c3		 ret	 0
z900_LockUnlockRCPLock ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\sie.h
;	COMDAT z900_LockUnlockSCALock
_TEXT	SEGMENT
old$1 = 32
new$ = 33
obtained$ = 34
tv84 = 36
tv86 = 40
scabk$ = 48
abspage$2 = 56
regs$ = 80
lock$ = 88
trylock$ = 96
z900_LockUnlockSCALock PROC				; COMDAT

; 255  : {

$LN13:
  00000	44 88 44 24 18	 mov	 BYTE PTR [rsp+24], r8b
  00005	88 54 24 10	 mov	 BYTE PTR [rsp+16], dl
  00009	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000e	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 256  :     BYTE new;
; 257  :     bool obtained = false;

  00012	c6 44 24 22 00	 mov	 BYTE PTR obtained$[rsp], 0

; 258  :     SCABK* scabk = (SCABK*) &regs->mainstor[ regs->sie_scao ];

  00017	48 8b 44 24 50	 mov	 rax, QWORD PTR regs$[rsp]
  0001c	48 8b 80 48 08
	00 00		 mov	 rax, QWORD PTR [rax+2120]
  00023	48 8b 4c 24 50	 mov	 rcx, QWORD PTR regs$[rsp]
  00028	48 03 81 b8 08
	00 00		 add	 rax, QWORD PTR [rcx+2232]
  0002f	48 89 44 24 30	 mov	 QWORD PTR scabk$[rsp], rax

; 259  : 
; 260  :     if (lock)

  00034	0f b6 44 24 58	 movzx	 eax, BYTE PTR lock$[rsp]
  00039	85 c0		 test	 eax, eax
  0003b	0f 84 8c 00 00
	00		 je	 $LN5@z900_LockU

; 261  :     {
; 262  :         BYTE old = scabk->scaiplk0;

  00041	48 8b 44 24 30	 mov	 rax, QWORD PTR scabk$[rsp]
  00046	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  00049	88 44 24 20	 mov	 BYTE PTR old$1[rsp], al
$LN4@z900_LockU:

; 263  : 
; 264  :         // MAINLOCK may be required if cmpxchg assists unavailable
; 265  :         OBTAIN_MAINLOCK( regs );
; 266  :         {
; 267  :             // If not TRY call, keep looping until we obtain it.
; 268  :             // Otherwise TRY just once, and return success or not.
; 269  :             do
; 270  :             {
; 271  :                 old &= ~SCAIPLKH;       // Want bit to be initially off

  0004d	0f b6 44 24 20	 movzx	 eax, BYTE PTR old$1[rsp]
  00052	0f ba f0 07	 btr	 eax, 7
  00056	88 44 24 20	 mov	 BYTE PTR old$1[rsp], al

; 272  :                 new = (old | SCAIPLKH); // And *WE* want to turn it on!

  0005a	0f b6 44 24 20	 movzx	 eax, BYTE PTR old$1[rsp]
  0005f	0f ba e8 07	 bts	 eax, 7
  00063	88 44 24 21	 mov	 BYTE PTR new$[rsp], al

; 273  :             }
; 274  :             while (!(obtained = (0 == cmpxchg1( &old, new, &scabk->scaiplk0 ))) && !trylock);

  00067	48 8b 44 24 30	 mov	 rax, QWORD PTR scabk$[rsp]
  0006c	4c 8b c0	 mov	 r8, rax
  0006f	0f b6 54 24 21	 movzx	 edx, BYTE PTR new$[rsp]
  00074	48 8d 4c 24 20	 lea	 rcx, QWORD PTR old$1[rsp]
  00079	e8 00 00 00 00	 call	 cmpxchg1_x86
  0007e	0f b6 c0	 movzx	 eax, al
  00081	85 c0		 test	 eax, eax
  00083	75 0a		 jne	 SHORT $LN9@z900_LockU
  00085	c7 44 24 24 01
	00 00 00	 mov	 DWORD PTR tv84[rsp], 1
  0008d	eb 08		 jmp	 SHORT $LN10@z900_LockU
$LN9@z900_LockU:
  0008f	c7 44 24 24 00
	00 00 00	 mov	 DWORD PTR tv84[rsp], 0
$LN10@z900_LockU:
  00097	83 7c 24 24 00	 cmp	 DWORD PTR tv84[rsp], 0
  0009c	75 0a		 jne	 SHORT $LN11@z900_LockU
  0009e	c7 44 24 28 00
	00 00 00	 mov	 DWORD PTR tv86[rsp], 0
  000a6	eb 08		 jmp	 SHORT $LN12@z900_LockU
$LN11@z900_LockU:
  000a8	c7 44 24 28 01
	00 00 00	 mov	 DWORD PTR tv86[rsp], 1
$LN12@z900_LockU:
  000b0	0f b6 44 24 28	 movzx	 eax, BYTE PTR tv86[rsp]
  000b5	88 44 24 22	 mov	 BYTE PTR obtained$[rsp], al
  000b9	0f b6 44 24 22	 movzx	 eax, BYTE PTR obtained$[rsp]
  000be	85 c0		 test	 eax, eax
  000c0	75 09		 jne	 SHORT $LN7@z900_LockU
  000c2	0f b6 44 24 60	 movzx	 eax, BYTE PTR trylock$[rsp]
  000c7	85 c0		 test	 eax, eax
  000c9	74 82		 je	 SHORT $LN4@z900_LockU
$LN7@z900_LockU:

; 275  :         }
; 276  :         RELEASE_MAINLOCK( regs );
; 277  :     }

  000cb	eb 12		 jmp	 SHORT $LN6@z900_LockU
$LN5@z900_LockU:

; 278  :     else // (unlock)
; 279  :     {
; 280  :         // Atomically 'and' the lock bit off
; 281  :         new = (BYTE)(~SCAIPLKH);

  000cd	c6 44 24 21 7f	 mov	 BYTE PTR new$[rsp], 127	; 0000007fH

; 282  :         (void) H_ATOMIC_OP( &scabk->scaiplk0, new, and, And, & );

  000d2	48 8b 44 24 30	 mov	 rax, QWORD PTR scabk$[rsp]
  000d7	0f b6 4c 24 21	 movzx	 ecx, BYTE PTR new$[rsp]
  000dc	f0 20 08	 lock and BYTE PTR [rax], cl
$LN6@z900_LockU:

; 283  :     }
; 284  : 
; 285  :     // Set Reference and Change bit for the byte we just modified
; 286  :     {
; 287  :         U64 abspage = (U64) (&scabk->scaiplk0 - regs->mainstor);

  000df	48 8b 44 24 30	 mov	 rax, QWORD PTR scabk$[rsp]
  000e4	48 8b 4c 24 50	 mov	 rcx, QWORD PTR regs$[rsp]
  000e9	48 2b 81 48 08
	00 00		 sub	 rax, QWORD PTR [rcx+2120]
  000f0	48 89 44 24 38	 mov	 QWORD PTR abspage$2[rsp], rax

; 288  :         ARCH_DEP( or_4K_storage_key )( abspage, (STORKEY_REF | STORKEY_CHANGE) );

  000f5	b2 06		 mov	 dl, 6
  000f7	48 8b 4c 24 38	 mov	 rcx, QWORD PTR abspage$2[rsp]
  000fc	e8 00 00 00 00	 call	 z900_or_4K_storage_key

; 289  :     }
; 290  : 
; 291  :     return obtained;

  00101	0f b6 44 24 22	 movzx	 eax, BYTE PTR obtained$[rsp]

; 292  : }

  00106	48 83 c4 48	 add	 rsp, 72			; 00000048H
  0010a	c3		 ret	 0
z900_LockUnlockSCALock ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\vstore.h
;	COMDAT z900_instfetch
_TEXT	SEGMENT
addr$ = 48
pagesz$ = 56
ip$ = 64
offset$ = 72
len$ = 76
tv128 = 80
tv130 = 84
tv137 = 88
tv156 = 92
tv172 = 96
tv174 = 100
tv180 = 104
tv187 = 108
tv204 = 112
tv239 = 116
tv238 = 120
tv240 = 124
tv256 = 128
tv350 = 132
tv351 = 136
dest$ = 144
tv75 = 152
tv77 = 160
tv357 = 168
regs$ = 192
exec$ = 200
z900_instfetch PROC					; COMDAT

; 777  : {

$LN96:
  00000	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00004	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00009	48 81 ec b8 00
	00 00		 sub	 rsp, 184		; 000000b8H

; 778  : VADR    addr;                           /* Instruction address       */
; 779  : BYTE*   ip;                             /* Instruction pointer       */
; 780  : BYTE*   dest;                           /* Fetched Instruction       */
; 781  : int     pagesz;                         /* Effective page size       */
; 782  : int     offset;                         /* Address offset into page  */
; 783  : int     len;                            /* Length for page crossing  */
; 784  : 
; 785  :     addr = exec ? regs->ET : VALID_AIE( regs ) ?

  00010	83 bc 24 c8 00
	00 00 00	 cmp	 DWORD PTR exec$[rsp], 0
  00018	74 1c		 je	 SHORT $LN52@z900_instf
  0001a	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00022	48 8b 80 20 07
	00 00		 mov	 rax, QWORD PTR [rax+1824]
  00029	48 89 84 24 a0
	00 00 00	 mov	 QWORD PTR tv77[rsp], rax
  00031	e9 85 00 00 00	 jmp	 $LN53@z900_instf
$LN52@z900_instf:
  00036	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0003e	48 83 b8 08 02
	00 00 00	 cmp	 QWORD PTR [rax+520], 0
  00046	74 4c		 je	 SHORT $LN50@z900_instf
  00048	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00050	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00058	48 8b 89 00 02
	00 00		 mov	 rcx, QWORD PTR [rcx+512]
  0005f	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  00063	48 2b c1	 sub	 rax, rcx
  00066	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0006e	48 8b 89 10 02
	00 00		 mov	 rcx, QWORD PTR [rcx+528]
  00075	48 03 c8	 add	 rcx, rax
  00078	48 8b c1	 mov	 rax, rcx
  0007b	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00083	48 23 81 90 00
	00 00		 and	 rax, QWORD PTR [rcx+144]
  0008a	48 89 84 24 98
	00 00 00	 mov	 QWORD PTR tv75[rsp], rax
  00092	eb 17		 jmp	 SHORT $LN51@z900_instf
$LN50@z900_instf:
  00094	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0009c	48 8b 80 88 00
	00 00		 mov	 rax, QWORD PTR [rax+136]
  000a3	48 89 84 24 98
	00 00 00	 mov	 QWORD PTR tv75[rsp], rax
$LN51@z900_instf:
  000ab	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR tv75[rsp]
  000b3	48 89 84 24 a0
	00 00 00	 mov	 QWORD PTR tv77[rsp], rax
$LN53@z900_instf:
  000bb	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR tv77[rsp]
  000c3	48 89 44 24 30	 mov	 QWORD PTR addr$[rsp], rax

; 786  :         PSW_IA_FROM_IP( regs, 0 ) : regs->psw.IA;
; 787  : 
; 788  :     /* Ensure PSW IA matches the instruction we're fetching */
; 789  :     if (!exec)

  000c8	83 bc 24 c8 00
	00 00 00	 cmp	 DWORD PTR exec$[rsp], 0
  000d0	75 69		 jne	 SHORT $LN23@z900_instf
$LN4@z900_instf:

; 790  :         MAYBE_SET_PSW_IA_FROM_IP( regs );

  000d2	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  000da	48 83 b8 08 02
	00 00 00	 cmp	 QWORD PTR [rax+520], 0
  000e2	74 51		 je	 SHORT $LN24@z900_instf
  000e4	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  000ec	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  000f4	48 8b 89 00 02
	00 00		 mov	 rcx, QWORD PTR [rcx+512]
  000fb	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  000ff	48 2b c1	 sub	 rax, rcx
  00102	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0010a	48 8b 89 10 02
	00 00		 mov	 rcx, QWORD PTR [rcx+528]
  00111	48 03 c8	 add	 rcx, rax
  00114	48 8b c1	 mov	 rax, rcx
  00117	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0011f	48 23 81 90 00
	00 00		 and	 rax, QWORD PTR [rcx+144]
  00126	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0012e	48 89 81 88 00
	00 00		 mov	 QWORD PTR [rcx+136], rax
$LN24@z900_instf:
  00135	33 c0		 xor	 eax, eax
  00137	85 c0		 test	 eax, eax
  00139	75 97		 jne	 SHORT $LN4@z900_instf
$LN23@z900_instf:

; 791  : 
; 792  :     offset = (int)(addr & PAGEFRAME_BYTEMASK);

  0013b	48 8b 44 24 30	 mov	 rax, QWORD PTR addr$[rsp]
  00140	48 25 ff 0f 00
	00		 and	 rax, 4095		; 00000fffH
  00146	89 44 24 48	 mov	 DWORD PTR offset$[rsp], eax

; 793  : 
; 794  :     pagesz = unlikely( addr < 0x800 ) ? 0x800 : PAGEFRAME_PAGESIZE;

  0014a	48 81 7c 24 30
	00 08 00 00	 cmp	 QWORD PTR addr$[rsp], 2048 ; 00000800H
  00153	73 0a		 jae	 SHORT $LN56@z900_instf
  00155	c7 44 24 50 01
	00 00 00	 mov	 DWORD PTR tv128[rsp], 1
  0015d	eb 08		 jmp	 SHORT $LN57@z900_instf
$LN56@z900_instf:
  0015f	c7 44 24 50 00
	00 00 00	 mov	 DWORD PTR tv128[rsp], 0
$LN57@z900_instf:
  00167	83 7c 24 50 00	 cmp	 DWORD PTR tv128[rsp], 0
  0016c	74 0a		 je	 SHORT $LN58@z900_instf
  0016e	c7 44 24 54 00
	08 00 00	 mov	 DWORD PTR tv130[rsp], 2048 ; 00000800H
  00176	eb 08		 jmp	 SHORT $LN59@z900_instf
$LN58@z900_instf:
  00178	c7 44 24 54 00
	10 00 00	 mov	 DWORD PTR tv130[rsp], 4096 ; 00001000H
$LN59@z900_instf:
  00180	8b 44 24 54	 mov	 eax, DWORD PTR tv130[rsp]
  00184	89 44 24 38	 mov	 DWORD PTR pagesz$[rsp], eax

; 795  : 
; 796  :     /* Program check if instruction address is odd */
; 797  :     if (unlikely( offset & 0x01 ))

  00188	8b 44 24 48	 mov	 eax, DWORD PTR offset$[rsp]
  0018c	83 e0 01	 and	 eax, 1
  0018f	85 c0		 test	 eax, eax
  00191	74 0a		 je	 SHORT $LN62@z900_instf
  00193	c7 44 24 58 01
	00 00 00	 mov	 DWORD PTR tv137[rsp], 1
  0019b	eb 08		 jmp	 SHORT $LN63@z900_instf
$LN62@z900_instf:
  0019d	c7 44 24 58 00
	00 00 00	 mov	 DWORD PTR tv137[rsp], 0
$LN63@z900_instf:
  001a5	83 7c 24 58 00	 cmp	 DWORD PTR tv137[rsp], 0
  001aa	74 44		 je	 SHORT $LN25@z900_instf

; 798  :     {
; 799  :         if (!exec)

  001ac	83 bc 24 c8 00
	00 00 00	 cmp	 DWORD PTR exec$[rsp], 0
  001b4	75 1f		 jne	 SHORT $LN26@z900_instf

; 800  :             regs->instinvalid = 1;

  001b6	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  001be	8b 80 28 07 00
	00		 mov	 eax, DWORD PTR [rax+1832]
  001c4	83 c8 08	 or	 eax, 8
  001c7	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  001cf	89 81 28 07 00
	00		 mov	 DWORD PTR [rcx+1832], eax
$LN26@z900_instf:

; 801  : 
; 802  :         regs->program_interrupt( regs, PGM_SPECIFICATION_EXCEPTION );

  001d5	ba 06 00 00 00	 mov	 edx, 6
  001da	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  001e2	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  001ea	ff 90 20 0d 00
	00		 call	 QWORD PTR [rax+3360]
$LN25@z900_instf:

; 803  :     }
; 804  : 
; 805  : #if defined( FEATURE_PER )
; 806  : 
; 807  :     /* Save the address used to fetch the instruction */
; 808  :     if (EN_IC_PER( regs ))

  001f0	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  001f8	8b 80 28 07 00
	00		 mov	 eax, DWORD PTR [rax+1832]
  001fe	c1 e8 02	 shr	 eax, 2
  00201	83 e0 01	 and	 eax, 1
  00204	85 c0		 test	 eax, eax
  00206	74 0a		 je	 SHORT $LN66@z900_instf
  00208	c7 44 24 5c 01
	00 00 00	 mov	 DWORD PTR tv156[rsp], 1
  00210	eb 08		 jmp	 SHORT $LN67@z900_instf
$LN66@z900_instf:
  00212	c7 44 24 5c 00
	00 00 00	 mov	 DWORD PTR tv156[rsp], 0
$LN67@z900_instf:
  0021a	83 7c 24 5c 00	 cmp	 DWORD PTR tv156[rsp], 0
  0021f	0f 84 16 05 00
	00		 je	 $LN27@z900_instf

; 809  :     {
; 810  : #if defined( FEATURE_PER2 )
; 811  :         regs->perc = 0x40    /* ATMID-validity */

  00225	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0022d	0f b6 40 78	 movzx	 eax, BYTE PTR [rax+120]
  00231	83 e0 04	 and	 eax, 4
  00234	85 c0		 test	 eax, eax
  00236	74 0a		 je	 SHORT $LN68@z900_instf
  00238	c7 44 24 60 01
	00 00 00	 mov	 DWORD PTR tv172[rsp], 1
  00240	eb 08		 jmp	 SHORT $LN69@z900_instf
$LN68@z900_instf:
  00242	c7 44 24 60 00
	00 00 00	 mov	 DWORD PTR tv172[rsp], 0
$LN69@z900_instf:
  0024a	83 7c 24 60 00	 cmp	 DWORD PTR tv172[rsp], 0
  0024f	74 0a		 je	 SHORT $LN70@z900_instf
  00251	c7 44 24 64 10
	00 00 00	 mov	 DWORD PTR tv174[rsp], 16
  00259	eb 08		 jmp	 SHORT $LN71@z900_instf
$LN70@z900_instf:
  0025b	c7 44 24 64 00
	00 00 00	 mov	 DWORD PTR tv174[rsp], 0
$LN71@z900_instf:
  00263	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0026b	0f b6 40 7b	 movzx	 eax, BYTE PTR [rax+123]
  0026f	25 80 00 00 00	 and	 eax, 128		; 00000080H
  00274	85 c0		 test	 eax, eax
  00276	74 0a		 je	 SHORT $LN72@z900_instf
  00278	c7 44 24 68 01
	00 00 00	 mov	 DWORD PTR tv180[rsp], 1
  00280	eb 08		 jmp	 SHORT $LN73@z900_instf
$LN72@z900_instf:
  00282	c7 44 24 68 00
	00 00 00	 mov	 DWORD PTR tv180[rsp], 0
$LN73@z900_instf:
  0028a	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00292	0f b6 40 7b	 movzx	 eax, BYTE PTR [rax+123]
  00296	83 e0 40	 and	 eax, 64			; 00000040H
  00299	85 c0		 test	 eax, eax
  0029b	74 0a		 je	 SHORT $LN74@z900_instf
  0029d	c7 44 24 6c 01
	00 00 00	 mov	 DWORD PTR tv187[rsp], 1
  002a5	eb 08		 jmp	 SHORT $LN75@z900_instf
$LN74@z900_instf:
  002a7	c7 44 24 6c 00
	00 00 00	 mov	 DWORD PTR tv187[rsp], 0
$LN75@z900_instf:
  002af	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  002b7	8b 80 80 00 00
	00		 mov	 eax, DWORD PTR [rax+128]
  002bd	83 e0 01	 and	 eax, 1
  002c0	c1 e0 07	 shl	 eax, 7
  002c3	83 c8 40	 or	 eax, 64			; 00000040H
  002c6	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  002ce	8b 89 80 00 00
	00		 mov	 ecx, DWORD PTR [rcx+128]
  002d4	d1 e9		 shr	 ecx, 1
  002d6	83 e1 01	 and	 ecx, 1
  002d9	c1 e1 05	 shl	 ecx, 5
  002dc	0b c1		 or	 eax, ecx
  002de	0b 44 24 64	 or	 eax, DWORD PTR tv174[rsp]
  002e2	8b 4c 24 68	 mov	 ecx, DWORD PTR tv180[rsp]
  002e6	c1 e1 03	 shl	 ecx, 3
  002e9	0b c1		 or	 eax, ecx
  002eb	8b 4c 24 6c	 mov	 ecx, DWORD PTR tv187[rsp]
  002ef	c1 e1 02	 shl	 ecx, 2
  002f2	0b c1		 or	 eax, ecx
  002f4	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  002fc	66 89 81 d0 08
	00 00		 mov	 WORD PTR [rcx+2256], ax

; 812  :                    | (regs->psw.amode64        << 7 )
; 813  :                    | (regs->psw.amode          << 5 )
; 814  :                    | (!REAL_MODE( &regs->psw ) ? 0x10 : 0 )
; 815  :                    | (SPACE_BIT(  &regs->psw ) << 3 )
; 816  :                    | (AR_BIT   (  &regs->psw ) << 2 );
; 817  : #else
; 818  :         regs->perc = 0;
; 819  : #endif /* defined( FEATURE_PER2 ) */
; 820  : 
; 821  :         if (!exec)

  00303	83 bc 24 c8 00
	00 00 00	 cmp	 DWORD PTR exec$[rsp], 0
  0030b	75 14		 jne	 SHORT $LN28@z900_instf

; 822  :             regs->peradr = addr;

  0030d	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00315	48 8b 4c 24 30	 mov	 rcx, QWORD PTR addr$[rsp]
  0031a	48 89 88 d8 08
	00 00		 mov	 QWORD PTR [rax+2264], rcx
$LN28@z900_instf:

; 823  : 
; 824  :         /* Test for PER instruction-fetching event */
; 825  :         if (1
; 826  :             && EN_IC_PER_IF( regs )
; 827  :             && PER_RANGE_CHECK( addr, regs->CR(10), regs->CR(11) )

  00321	33 c0		 xor	 eax, eax
  00323	83 f8 01	 cmp	 eax, 1
  00326	0f 84 22 02 00
	00		 je	 $LN29@z900_instf
  0032c	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00334	8b 80 28 07 00
	00		 mov	 eax, DWORD PTR [rax+1832]
  0033a	c1 e8 02	 shr	 eax, 2
  0033d	83 e0 01	 and	 eax, 1
  00340	85 c0		 test	 eax, eax
  00342	74 0a		 je	 SHORT $LN78@z900_instf
  00344	c7 44 24 70 01
	00 00 00	 mov	 DWORD PTR tv204[rsp], 1
  0034c	eb 08		 jmp	 SHORT $LN79@z900_instf
$LN78@z900_instf:
  0034e	c7 44 24 70 00
	00 00 00	 mov	 DWORD PTR tv204[rsp], 0
$LN79@z900_instf:
  00356	83 7c 24 70 00	 cmp	 DWORD PTR tv204[rsp], 0
  0035b	0f 84 ed 01 00
	00		 je	 $LN29@z900_instf
  00361	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00369	8b 40 48	 mov	 eax, DWORD PTR [rax+72]
  0036c	25 00 00 40 00	 and	 eax, 4194304		; 00400000H
  00371	85 c0		 test	 eax, eax
  00373	0f 84 d5 01 00
	00		 je	 $LN29@z900_instf
  00379	b8 08 00 00 00	 mov	 eax, 8
  0037e	48 6b c0 0c	 imul	 rax, rax, 12
  00382	b9 08 00 00 00	 mov	 ecx, 8
  00387	48 6b c9 0b	 imul	 rcx, rcx, 11
  0038b	48 8b 94 24 c0
	00 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  00393	4c 8b 84 24 c0
	00 00 00	 mov	 r8, QWORD PTR regs$[rsp]
  0039b	49 8b 8c 08 00
	06 00 00	 mov	 rcx, QWORD PTR [r8+rcx+1536]
  003a3	48 39 8c 02 00
	06 00 00	 cmp	 QWORD PTR [rdx+rax+1536], rcx
  003ab	72 5c		 jb	 SHORT $LN84@z900_instf
  003ad	b8 08 00 00 00	 mov	 eax, 8
  003b2	48 6b c0 0b	 imul	 rax, rax, 11
  003b6	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  003be	48 8b 84 01 00
	06 00 00	 mov	 rax, QWORD PTR [rcx+rax+1536]
  003c6	48 39 44 24 30	 cmp	 QWORD PTR addr$[rsp], rax
  003cb	72 2a		 jb	 SHORT $LN80@z900_instf
  003cd	b8 08 00 00 00	 mov	 eax, 8
  003d2	48 6b c0 0c	 imul	 rax, rax, 12
  003d6	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  003de	48 8b 84 01 00
	06 00 00	 mov	 rax, QWORD PTR [rcx+rax+1536]
  003e6	48 39 44 24 30	 cmp	 QWORD PTR addr$[rsp], rax
  003eb	77 0a		 ja	 SHORT $LN80@z900_instf
  003ed	c7 44 24 74 01
	00 00 00	 mov	 DWORD PTR tv239[rsp], 1
  003f5	eb 08		 jmp	 SHORT $LN83@z900_instf
$LN80@z900_instf:
  003f7	c7 44 24 74 00
	00 00 00	 mov	 DWORD PTR tv239[rsp], 0
$LN83@z900_instf:
  003ff	8b 44 24 74	 mov	 eax, DWORD PTR tv239[rsp]
  00403	89 44 24 7c	 mov	 DWORD PTR tv240[rsp], eax
  00407	eb 5a		 jmp	 SHORT $LN85@z900_instf
$LN84@z900_instf:
  00409	b8 08 00 00 00	 mov	 eax, 8
  0040e	48 6b c0 0b	 imul	 rax, rax, 11
  00412	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0041a	48 8b 84 01 00
	06 00 00	 mov	 rax, QWORD PTR [rcx+rax+1536]
  00422	48 39 44 24 30	 cmp	 QWORD PTR addr$[rsp], rax
  00427	73 2a		 jae	 SHORT $LN81@z900_instf
  00429	b8 08 00 00 00	 mov	 eax, 8
  0042e	48 6b c0 0c	 imul	 rax, rax, 12
  00432	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0043a	48 8b 84 01 00
	06 00 00	 mov	 rax, QWORD PTR [rcx+rax+1536]
  00442	48 39 44 24 30	 cmp	 QWORD PTR addr$[rsp], rax
  00447	76 0a		 jbe	 SHORT $LN81@z900_instf
  00449	c7 44 24 78 00
	00 00 00	 mov	 DWORD PTR tv238[rsp], 0
  00451	eb 08		 jmp	 SHORT $LN82@z900_instf
$LN81@z900_instf:
  00453	c7 44 24 78 01
	00 00 00	 mov	 DWORD PTR tv238[rsp], 1
$LN82@z900_instf:
  0045b	8b 44 24 78	 mov	 eax, DWORD PTR tv238[rsp]
  0045f	89 44 24 7c	 mov	 DWORD PTR tv240[rsp], eax
$LN85@z900_instf:
  00463	83 7c 24 7c 00	 cmp	 DWORD PTR tv240[rsp], 0
  00468	0f 84 e0 00 00
	00		 je	 $LN29@z900_instf
$LN7@z900_instf:

; 828  :         )
; 829  :         {
; 830  :             ON_IC_PER_IF( regs );

  0046e	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00476	8b 40 4c	 mov	 eax, DWORD PTR [rax+76]
  00479	0f ba e8 16	 bts	 eax, 22
  0047d	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00485	89 41 4c	 mov	 DWORD PTR [rcx+76], eax
  00488	33 c0		 xor	 eax, eax
  0048a	85 c0		 test	 eax, eax
  0048c	75 e0		 jne	 SHORT $LN7@z900_instf

; 831  : 
; 832  : #if defined( FEATURE_PER3 )
; 833  :             /* If CR9_IFNUL (PER instruction-fetching nullification) is
; 834  :                set, take a program check immediately, without executing
; 835  :                the instruction or updating the PSW instruction address */
; 836  :             if (EN_IC_PER_IFNUL( regs ))

  0048e	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00496	8b 80 28 07 00
	00		 mov	 eax, DWORD PTR [rax+1832]
  0049c	c1 e8 02	 shr	 eax, 2
  0049f	83 e0 01	 and	 eax, 1
  004a2	85 c0		 test	 eax, eax
  004a4	74 0d		 je	 SHORT $LN88@z900_instf
  004a6	c7 84 24 80 00
	00 00 01 00 00
	00		 mov	 DWORD PTR tv256[rsp], 1
  004b1	eb 0b		 jmp	 SHORT $LN89@z900_instf
$LN88@z900_instf:
  004b3	c7 84 24 80 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv256[rsp], 0
$LN89@z900_instf:
  004be	83 bc 24 80 00
	00 00 00	 cmp	 DWORD PTR tv256[rsp], 0
  004c6	0f 84 82 00 00
	00		 je	 $LN30@z900_instf
  004cc	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  004d4	8b 40 48	 mov	 eax, DWORD PTR [rax+72]
  004d7	25 00 00 01 00	 and	 eax, 65536		; 00010000H
  004dc	85 c0		 test	 eax, eax
  004de	74 6e		 je	 SHORT $LN30@z900_instf
$LN10@z900_instf:

; 837  :             {
; 838  :                 ON_IC_PER_IFNUL( regs );

  004e0	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  004e8	8b 40 4c	 mov	 eax, DWORD PTR [rax+76]
  004eb	0f ba e8 10	 bts	 eax, 16
  004ef	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  004f7	89 41 4c	 mov	 DWORD PTR [rcx+76], eax
  004fa	33 c0		 xor	 eax, eax
  004fc	85 c0		 test	 eax, eax
  004fe	75 e0		 jne	 SHORT $LN10@z900_instf

; 839  :                 regs->psw.IA = addr;

  00500	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00508	48 8b 4c 24 30	 mov	 rcx, QWORD PTR addr$[rsp]
  0050d	48 89 88 88 00
	00 00		 mov	 QWORD PTR [rax+136], rcx

; 840  :                 regs->psw.zeroilc = 1;

  00514	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0051c	8b 80 80 00 00
	00		 mov	 eax, DWORD PTR [rax+128]
  00522	83 c8 04	 or	 eax, 4
  00525	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0052d	89 81 80 00 00
	00		 mov	 DWORD PTR [rcx+128], eax

; 841  :                 regs->program_interrupt( regs, PGM_PER_EVENT );

  00533	ba 80 00 00 00	 mov	 edx, 128		; 00000080H
  00538	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00540	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00548	ff 90 20 0d 00
	00		 call	 QWORD PTR [rax+3360]
$LN30@z900_instf:
$LN29@z900_instf:

; 842  :             }
; 843  : #endif /* defined( FEATURE_PER3 ) */
; 844  :         }
; 845  : 
; 846  :         /* Quick exit if AIA is still valid */
; 847  :         if (1
; 848  :             && !exec
; 849  :             && !regs->breakortrace
; 850  :             &&  VALID_AIE( regs )
; 851  :             &&  regs->ip < (regs->aip + pagesz - 5)

  0054e	33 c0		 xor	 eax, eax
  00550	83 f8 01	 cmp	 eax, 1
  00553	0f 84 e2 01 00
	00		 je	 $LN31@z900_instf
  00559	83 bc 24 c8 00
	00 00 00	 cmp	 DWORD PTR exec$[rsp], 0
  00561	0f 85 d4 01 00
	00		 jne	 $LN31@z900_instf
  00567	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0056f	8b 80 28 07 00
	00		 mov	 eax, DWORD PTR [rax+1832]
  00575	c1 e8 10	 shr	 eax, 16
  00578	83 e0 01	 and	 eax, 1
  0057b	85 c0		 test	 eax, eax
  0057d	0f 85 b8 01 00
	00		 jne	 $LN31@z900_instf
  00583	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0058b	48 83 b8 08 02
	00 00 00	 cmp	 QWORD PTR [rax+520], 0
  00593	0f 84 a2 01 00
	00		 je	 $LN31@z900_instf
  00599	48 63 44 24 38	 movsxd	 rax, DWORD PTR pagesz$[rsp]
  0059e	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  005a6	48 8b 89 00 02
	00 00		 mov	 rcx, QWORD PTR [rcx+512]
  005ad	48 8d 44 01 fb	 lea	 rax, QWORD PTR [rcx+rax-5]
  005b2	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  005ba	48 39 41 68	 cmp	 QWORD PTR [rcx+104], rax
  005be	0f 83 77 01 00
	00		 jae	 $LN31@z900_instf

; 852  :         )
; 853  :         {
; 854  : #if defined( FEATURE_073_TRANSACT_EXEC_FACILITY )
; 855  : 
; 856  :             /* Update CONSTRAINED trans instruction fetch constraint */
; 857  :             if (regs->txf_contran)

  005c4	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  005cc	0f b6 80 4c 0e
	00 00		 movzx	 eax, BYTE PTR [rax+3660]
  005d3	85 c0		 test	 eax, eax
  005d5	74 4d		 je	 SHORT $LN32@z900_instf

; 858  :             {
; 859  :                 if (regs->AIV == regs->txf_aie_aiv2)

  005d7	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  005df	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  005e7	48 8b 89 70 af
	00 00		 mov	 rcx, QWORD PTR [rcx+44912]
  005ee	48 39 88 10 02
	00 00		 cmp	 QWORD PTR [rax+528], rcx
  005f5	75 2d		 jne	 SHORT $LN33@z900_instf

; 860  :                     regs->txf_aie = regs->aip + regs->txf_aie_off2;

  005f7	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  005ff	48 63 80 78 af
	00 00		 movsxd	 rax, DWORD PTR [rax+44920]
  00606	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0060e	48 03 81 00 02
	00 00		 add	 rax, QWORD PTR [rcx+512]
  00615	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0061d	48 89 81 60 af
	00 00		 mov	 QWORD PTR [rcx+44896], rax
$LN33@z900_instf:
$LN32@z900_instf:
$LN13@z900_instf:

; 861  :             }
; 862  : 
; 863  :             TXF_INSTRADDR_CONSTRAINT( regs );

  00624	33 c0		 xor	 eax, eax
  00626	83 f8 01	 cmp	 eax, 1
  00629	74 6f		 je	 SHORT $LN34@z900_instf
  0062b	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00633	0f b6 80 4c 0e
	00 00		 movzx	 eax, BYTE PTR [rax+3660]
  0063a	85 c0		 test	 eax, eax
  0063c	74 5c		 je	 SHORT $LN34@z900_instf
  0063e	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00646	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0064e	48 8b 89 60 af
	00 00		 mov	 rcx, QWORD PTR [rcx+44896]
  00655	48 39 48 68	 cmp	 QWORD PTR [rax+104], rcx
  00659	72 3f		 jb	 SHORT $LN34@z900_instf
  0065b	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00663	8b 80 84 af 00
	00		 mov	 eax, DWORD PTR [rax+44932]
  00669	0f ba e8 1f	 bts	 eax, 31
  0066d	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00675	89 81 84 af 00
	00		 mov	 DWORD PTR [rcx+44932], eax
  0067b	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:??_C@_0CM@GFKCBHDD@C?3?2papa?2MyGit?2hyperion?9zvector?2@
  00682	41 b8 0b 00 00
	00		 mov	 r8d, 11
  00688	ba fe ff ff ff	 mov	 edx, -2
  0068d	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00695	e8 00 00 00 00	 call	 z900_abort_transaction
$LN34@z900_instf:
  0069a	33 c0		 xor	 eax, eax
  0069c	85 c0		 test	 eax, eax
  0069e	75 84		 jne	 SHORT $LN13@z900_instf

; 864  : 
; 865  : #endif /* defined( FEATURE_073_TRANSACT_EXEC_FACILITY ) */
; 866  : 
; 867  :             /* Save the address of the instruction ABOUT to be executed */
; 868  :             regs->periaddr = PSW_IA_FROM_IP( regs, 0 );

  006a0	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  006a8	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  006b0	48 8b 89 00 02
	00 00		 mov	 rcx, QWORD PTR [rcx+512]
  006b7	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  006bb	48 2b c1	 sub	 rax, rcx
  006be	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  006c6	48 8b 89 10 02
	00 00		 mov	 rcx, QWORD PTR [rcx+528]
  006cd	48 03 c8	 add	 rcx, rax
  006d0	48 8b c1	 mov	 rax, rcx
  006d3	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  006db	48 23 81 90 00
	00 00		 and	 rax, QWORD PTR [rcx+144]
  006e2	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  006ea	48 89 81 e8 08
	00 00		 mov	 QWORD PTR [rcx+2280], rax

; 869  : 
; 870  :             /* Suppress PER instruction fetch event if appropriate */
; 871  :             if (IS_PER_SUPRESS( regs, CR9_IF ))

  006f1	ba 00 00 00 40	 mov	 edx, 1073741824		; 40000000H
  006f6	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  006fe	e8 00 00 00 00	 call	 z900_is_per3_event_suppressed
  00703	0f b6 c0	 movzx	 eax, al
  00706	85 c0		 test	 eax, eax
  00708	74 20		 je	 SHORT $LN35@z900_instf
$LN16@z900_instf:

; 872  :                 OFF_IC_PER_IF( regs );

  0070a	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00712	8b 40 4c	 mov	 eax, DWORD PTR [rax+76]
  00715	0f ba f0 16	 btr	 eax, 22
  00719	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00721	89 41 4c	 mov	 DWORD PTR [rcx+76], eax
  00724	33 c0		 xor	 eax, eax
  00726	85 c0		 test	 eax, eax
  00728	75 e0		 jne	 SHORT $LN16@z900_instf
$LN35@z900_instf:

; 873  : 
; 874  :             /* Return to caller to execute this instruction */
; 875  :             return regs->ip;

  0072a	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00732	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  00736	e9 49 04 00 00	 jmp	 $LN1@z900_instf
$LN31@z900_instf:
$LN27@z900_instf:

; 876  :         }
; 877  :     }
; 878  : #endif /* defined( FEATURE_PER ) */
; 879  : 
; 880  :     /* Set instinvalid in case of addressing or translation exception */
; 881  :     if (!exec)

  0073b	83 bc 24 c8 00
	00 00 00	 cmp	 DWORD PTR exec$[rsp], 0
  00743	75 1f		 jne	 SHORT $LN36@z900_instf

; 882  :         regs->instinvalid = 1;

  00745	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0074d	8b 80 28 07 00
	00		 mov	 eax, DWORD PTR [rax+1832]
  00753	83 c8 08	 or	 eax, 8
  00756	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0075e	89 81 28 07 00
	00		 mov	 DWORD PTR [rcx+1832], eax
$LN36@z900_instf:

; 883  : 
; 884  :     /* Get instruction address */
; 885  :     ip = MADDRL( addr, 6, USE_INST_SPACE, regs, ACCTYPE_INSTFETCH, regs->psw.pkey );

  00764	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0076c	0f b6 40 79	 movzx	 eax, BYTE PTR [rax+121]
  00770	88 44 24 28	 mov	 BYTE PTR [rsp+40], al
  00774	c7 44 24 20 04
	00 00 00	 mov	 DWORD PTR [rsp+32], 4
  0077c	4c 8b 8c 24 c0
	00 00 00	 mov	 r9, QWORD PTR regs$[rsp]
  00784	41 b8 ff ff ff
	ff		 mov	 r8d, -1
  0078a	ba 06 00 00 00	 mov	 edx, 6
  0078f	48 8b 4c 24 30	 mov	 rcx, QWORD PTR addr$[rsp]
  00794	e8 00 00 00 00	 call	 z900_maddr_l
  00799	48 89 44 24 40	 mov	 QWORD PTR ip$[rsp], rax

; 886  : 
; 887  :     /* If boundary is crossed then copy instruction to destination */
; 888  :     if (offset + ILC( ip[0] ) > pagesz)

  0079e	b8 01 00 00 00	 mov	 eax, 1
  007a3	48 6b c0 00	 imul	 rax, rax, 0
  007a7	48 8b 4c 24 40	 mov	 rcx, QWORD PTR ip$[rsp]
  007ac	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  007b0	83 f8 40	 cmp	 eax, 64			; 00000040H
  007b3	7d 0d		 jge	 SHORT $LN92@z900_instf
  007b5	c7 84 24 88 00
	00 00 02 00 00
	00		 mov	 DWORD PTR tv351[rsp], 2
  007c0	eb 3f		 jmp	 SHORT $LN93@z900_instf
$LN92@z900_instf:
  007c2	b8 01 00 00 00	 mov	 eax, 1
  007c7	48 6b c0 00	 imul	 rax, rax, 0
  007cb	48 8b 4c 24 40	 mov	 rcx, QWORD PTR ip$[rsp]
  007d0	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  007d4	3d c0 00 00 00	 cmp	 eax, 192		; 000000c0H
  007d9	7d 0d		 jge	 SHORT $LN90@z900_instf
  007db	c7 84 24 84 00
	00 00 04 00 00
	00		 mov	 DWORD PTR tv350[rsp], 4
  007e6	eb 0b		 jmp	 SHORT $LN91@z900_instf
$LN90@z900_instf:
  007e8	c7 84 24 84 00
	00 00 06 00 00
	00		 mov	 DWORD PTR tv350[rsp], 6
$LN91@z900_instf:
  007f3	8b 84 24 84 00
	00 00		 mov	 eax, DWORD PTR tv350[rsp]
  007fa	89 84 24 88 00
	00 00		 mov	 DWORD PTR tv351[rsp], eax
$LN93@z900_instf:
  00801	8b 84 24 88 00
	00 00		 mov	 eax, DWORD PTR tv351[rsp]
  00808	8b 4c 24 48	 mov	 ecx, DWORD PTR offset$[rsp]
  0080c	03 c8		 add	 ecx, eax
  0080e	8b c1		 mov	 eax, ecx
  00810	3b 44 24 38	 cmp	 eax, DWORD PTR pagesz$[rsp]
  00814	0f 8e 06 01 00
	00		 jle	 $LN37@z900_instf

; 889  :     {
; 890  :         /* Copy first part of instruction (note: dest is 8 bytes) */
; 891  :         dest = exec ? regs->exinst : regs->inst;

  0081a	83 bc 24 c8 00
	00 00 00	 cmp	 DWORD PTR exec$[rsp], 0
  00822	74 18		 je	 SHORT $LN94@z900_instf
  00824	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0082c	48 05 40 08 00
	00		 add	 rax, 2112		; 00000840H
  00832	48 89 84 24 a8
	00 00 00	 mov	 QWORD PTR tv357[rsp], rax
  0083a	eb 16		 jmp	 SHORT $LN95@z900_instf
$LN94@z900_instf:
  0083c	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00844	48 05 f1 08 00
	00		 add	 rax, 2289		; 000008f1H
  0084a	48 89 84 24 a8
	00 00 00	 mov	 QWORD PTR tv357[rsp], rax
$LN95@z900_instf:
  00852	48 8b 84 24 a8
	00 00 00	 mov	 rax, QWORD PTR tv357[rsp]
  0085a	48 89 84 24 90
	00 00 00	 mov	 QWORD PTR dest$[rsp], rax

; 892  :         memcpy( dest, ip, 4 );

  00862	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR dest$[rsp]
  0086a	48 8b 4c 24 40	 mov	 rcx, QWORD PTR ip$[rsp]
  0086f	8b 09		 mov	 ecx, DWORD PTR [rcx]
  00871	89 08		 mov	 DWORD PTR [rax], ecx

; 893  : 
; 894  :         /* Copy second part of instruction */
; 895  :         len = pagesz - offset;

  00873	8b 44 24 48	 mov	 eax, DWORD PTR offset$[rsp]
  00877	8b 4c 24 38	 mov	 ecx, DWORD PTR pagesz$[rsp]
  0087b	2b c8		 sub	 ecx, eax
  0087d	8b c1		 mov	 eax, ecx
  0087f	89 44 24 4c	 mov	 DWORD PTR len$[rsp], eax

; 896  :         addr = (addr + len) & ADDRESS_MAXWRAP( regs );

  00883	48 63 44 24 4c	 movsxd	 rax, DWORD PTR len$[rsp]
  00888	48 8b 4c 24 30	 mov	 rcx, QWORD PTR addr$[rsp]
  0088d	48 03 c8	 add	 rcx, rax
  00890	48 8b c1	 mov	 rax, rcx
  00893	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0089b	48 23 81 90 00
	00 00		 and	 rax, QWORD PTR [rcx+144]
  008a2	48 89 44 24 30	 mov	 QWORD PTR addr$[rsp], rax

; 897  :         ip = MADDR( addr, USE_INST_SPACE, regs, ACCTYPE_INSTFETCH, regs->psw.pkey );

  008a7	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  008af	0f b6 40 79	 movzx	 eax, BYTE PTR [rax+121]
  008b3	88 44 24 28	 mov	 BYTE PTR [rsp+40], al
  008b7	c7 44 24 20 04
	00 00 00	 mov	 DWORD PTR [rsp+32], 4
  008bf	4c 8b 8c 24 c0
	00 00 00	 mov	 r9, QWORD PTR regs$[rsp]
  008c7	41 b8 ff ff ff
	ff		 mov	 r8d, -1
  008cd	ba 01 00 00 00	 mov	 edx, 1
  008d2	48 8b 4c 24 30	 mov	 rcx, QWORD PTR addr$[rsp]
  008d7	e8 00 00 00 00	 call	 z900_maddr_l
  008dc	48 89 44 24 40	 mov	 QWORD PTR ip$[rsp], rax

; 898  :         if (!exec)

  008e1	83 bc 24 c8 00
	00 00 00	 cmp	 DWORD PTR exec$[rsp], 0
  008e9	75 1c		 jne	 SHORT $LN39@z900_instf

; 899  :             regs->ip = ip - len;

  008eb	48 63 44 24 4c	 movsxd	 rax, DWORD PTR len$[rsp]
  008f0	48 8b 4c 24 40	 mov	 rcx, QWORD PTR ip$[rsp]
  008f5	48 2b c8	 sub	 rcx, rax
  008f8	48 8b c1	 mov	 rax, rcx
  008fb	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00903	48 89 41 68	 mov	 QWORD PTR [rcx+104], rax
$LN39@z900_instf:

; 900  :         memcpy( dest + len, ip, 4 );

  00907	48 63 44 24 4c	 movsxd	 rax, DWORD PTR len$[rsp]
  0090c	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR dest$[rsp]
  00914	48 8b 54 24 40	 mov	 rdx, QWORD PTR ip$[rsp]
  00919	8b 12		 mov	 edx, DWORD PTR [rdx]
  0091b	89 14 01	 mov	 DWORD PTR [rcx+rax], edx

; 901  :     }

  0091e	eb 28		 jmp	 SHORT $LN38@z900_instf
$LN37@z900_instf:

; 902  :     else /* boundary NOT crossed */
; 903  :     {
; 904  :         dest = ip;

  00920	48 8b 44 24 40	 mov	 rax, QWORD PTR ip$[rsp]
  00925	48 89 84 24 90
	00 00 00	 mov	 QWORD PTR dest$[rsp], rax

; 905  : 
; 906  :         if (!exec)

  0092d	83 bc 24 c8 00
	00 00 00	 cmp	 DWORD PTR exec$[rsp], 0
  00935	75 11		 jne	 SHORT $LN40@z900_instf

; 907  :             regs->ip = ip;

  00937	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0093f	48 8b 4c 24 40	 mov	 rcx, QWORD PTR ip$[rsp]
  00944	48 89 48 68	 mov	 QWORD PTR [rax+104], rcx
$LN40@z900_instf:
$LN38@z900_instf:

; 908  :     }
; 909  : 
; 910  :     if (!exec)

  00948	83 bc 24 c8 00
	00 00 00	 cmp	 DWORD PTR exec$[rsp], 0
  00950	0f 85 c0 00 00
	00		 jne	 $LN41@z900_instf

; 911  :     {
; 912  :         /* Instr addr now known to be valid so reset instinvalid flag */
; 913  :         regs->instinvalid = 0;

  00956	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0095e	8b 80 28 07 00
	00		 mov	 eax, DWORD PTR [rax+1832]
  00964	83 e0 f7	 and	 eax, -9			; fffffff7H
  00967	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0096f	89 81 28 07 00
	00		 mov	 DWORD PTR [rcx+1832], eax

; 914  : 
; 915  :         /* Update the AIA values */
; 916  :         regs->AIV = addr & PAGEFRAME_PAGEMASK;

  00975	48 8b 44 24 30	 mov	 rax, QWORD PTR addr$[rsp]
  0097a	48 25 00 f0 ff
	ff		 and	 rax, -4096		; fffffffffffff000H
  00980	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00988	48 89 81 10 02
	00 00		 mov	 QWORD PTR [rcx+528], rax

; 917  :         regs->aip = (BYTE*)((uintptr_t)ip & ~PAGEFRAME_BYTEMASK);

  0098f	48 8b 44 24 40	 mov	 rax, QWORD PTR ip$[rsp]
  00994	48 25 00 f0 ff
	ff		 and	 rax, -4096		; fffffffffffff000H
  0099a	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  009a2	48 89 81 00 02
	00 00		 mov	 QWORD PTR [rcx+512], rax

; 918  : 
; 919  :         /* If tracing, stepping or PER is still active,
; 920  :            force another instfetch after this instruction.
; 921  :         */
; 922  :         if (regs->breakortrace || regs->permode)

  009a9	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  009b1	8b 80 28 07 00
	00		 mov	 eax, DWORD PTR [rax+1832]
  009b7	c1 e8 10	 shr	 eax, 16
  009ba	83 e0 01	 and	 eax, 1
  009bd	85 c0		 test	 eax, eax
  009bf	75 18		 jne	 SHORT $LN44@z900_instf
  009c1	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  009c9	8b 80 28 07 00
	00		 mov	 eax, DWORD PTR [rax+1832]
  009cf	c1 e8 02	 shr	 eax, 2
  009d2	83 e0 01	 and	 eax, 1
  009d5	85 c0		 test	 eax, eax
  009d7	74 15		 je	 SHORT $LN42@z900_instf
$LN44@z900_instf:

; 923  :         {
; 924  :             /* Force instfetch to be called again on next inst. */
; 925  :             regs->aie = PSEUDO_INVALID_AIE;

  009d9	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  009e1	48 c7 80 08 02
	00 00 01 00 00
	00		 mov	 QWORD PTR [rax+520], 1

; 926  :         }

  009ec	eb 28		 jmp	 SHORT $LN43@z900_instf
$LN42@z900_instf:

; 927  :         else /* (stepping/tracing/PER is NOT active) */
; 928  :         {
; 929  :             /* Call instfetch again ONLY when truly needed */
; 930  :             regs->aie = regs->aip + pagesz - 5;

  009ee	48 63 44 24 38	 movsxd	 rax, DWORD PTR pagesz$[rsp]
  009f3	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  009fb	48 8b 89 00 02
	00 00		 mov	 rcx, QWORD PTR [rcx+512]
  00a02	48 8d 44 01 fb	 lea	 rax, QWORD PTR [rcx+rax-5]
  00a07	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00a0f	48 89 81 08 02
	00 00		 mov	 QWORD PTR [rcx+520], rax
$LN43@z900_instf:
$LN41@z900_instf:

; 931  :         }
; 932  :     }
; 933  : 
; 934  : #if defined( FEATURE_073_TRANSACT_EXEC_FACILITY )
; 935  : 
; 936  :     /* Update CONSTRAINED trans instruction fetch constraint */
; 937  :     if (regs->txf_contran)

  00a16	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00a1e	0f b6 80 4c 0e
	00 00		 movzx	 eax, BYTE PTR [rax+3660]
  00a25	85 c0		 test	 eax, eax
  00a27	74 4d		 je	 SHORT $LN45@z900_instf

; 938  :     {
; 939  :         if (regs->AIV == regs->txf_aie_aiv2)

  00a29	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00a31	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00a39	48 8b 89 70 af
	00 00		 mov	 rcx, QWORD PTR [rcx+44912]
  00a40	48 39 88 10 02
	00 00		 cmp	 QWORD PTR [rax+528], rcx
  00a47	75 2d		 jne	 SHORT $LN46@z900_instf

; 940  :             regs->txf_aie = regs->aip + regs->txf_aie_off2;

  00a49	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00a51	48 63 80 78 af
	00 00		 movsxd	 rax, DWORD PTR [rax+44920]
  00a58	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00a60	48 03 81 00 02
	00 00		 add	 rax, QWORD PTR [rcx+512]
  00a67	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00a6f	48 89 81 60 af
	00 00		 mov	 QWORD PTR [rcx+44896], rax
$LN46@z900_instf:
$LN45@z900_instf:
$LN19@z900_instf:

; 941  :     }
; 942  : 
; 943  :     TXF_INSTRADDR_CONSTRAINT( regs );

  00a76	33 c0		 xor	 eax, eax
  00a78	83 f8 01	 cmp	 eax, 1
  00a7b	74 6f		 je	 SHORT $LN47@z900_instf
  00a7d	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00a85	0f b6 80 4c 0e
	00 00		 movzx	 eax, BYTE PTR [rax+3660]
  00a8c	85 c0		 test	 eax, eax
  00a8e	74 5c		 je	 SHORT $LN47@z900_instf
  00a90	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00a98	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00aa0	48 8b 89 60 af
	00 00		 mov	 rcx, QWORD PTR [rcx+44896]
  00aa7	48 39 48 68	 cmp	 QWORD PTR [rax+104], rcx
  00aab	72 3f		 jb	 SHORT $LN47@z900_instf
  00aad	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00ab5	8b 80 84 af 00
	00		 mov	 eax, DWORD PTR [rax+44932]
  00abb	0f ba e8 1f	 bts	 eax, 31
  00abf	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00ac7	89 81 84 af 00
	00		 mov	 DWORD PTR [rcx+44932], eax
  00acd	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:??_C@_0CM@NOJKKEDI@C?3?2papa?2MyGit?2hyperion?9zvector?2@
  00ad4	41 b8 0b 00 00
	00		 mov	 r8d, 11
  00ada	ba fe ff ff ff	 mov	 edx, -2
  00adf	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00ae7	e8 00 00 00 00	 call	 z900_abort_transaction
$LN47@z900_instf:
  00aec	33 c0		 xor	 eax, eax
  00aee	85 c0		 test	 eax, eax
  00af0	75 84		 jne	 SHORT $LN19@z900_instf

; 944  : 
; 945  : #endif /* defined( FEATURE_073_TRANSACT_EXEC_FACILITY ) */
; 946  : 
; 947  :     /* Save the address of the instruction ABOUT to be executed */
; 948  :     regs->periaddr = PSW_IA_FROM_IP( regs, 0 );

  00af2	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00afa	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00b02	48 8b 89 00 02
	00 00		 mov	 rcx, QWORD PTR [rcx+512]
  00b09	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  00b0d	48 2b c1	 sub	 rax, rcx
  00b10	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00b18	48 8b 89 10 02
	00 00		 mov	 rcx, QWORD PTR [rcx+528]
  00b1f	48 03 c8	 add	 rcx, rax
  00b22	48 8b c1	 mov	 rax, rcx
  00b25	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00b2d	48 23 81 90 00
	00 00		 and	 rax, QWORD PTR [rcx+144]
  00b34	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00b3c	48 89 81 e8 08
	00 00		 mov	 QWORD PTR [rcx+2280], rax

; 949  : 
; 950  :     /* Suppress PER instruction fetch event if appropriate */
; 951  :     if (IS_PER_SUPRESS( regs, CR9_IF ))

  00b43	ba 00 00 00 40	 mov	 edx, 1073741824		; 40000000H
  00b48	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00b50	e8 00 00 00 00	 call	 z900_is_per3_event_suppressed
  00b55	0f b6 c0	 movzx	 eax, al
  00b58	85 c0		 test	 eax, eax
  00b5a	74 20		 je	 SHORT $LN48@z900_instf
$LN22@z900_instf:

; 952  :         OFF_IC_PER_IF( regs );

  00b5c	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00b64	8b 40 4c	 mov	 eax, DWORD PTR [rax+76]
  00b67	0f ba f0 16	 btr	 eax, 22
  00b6b	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00b73	89 41 4c	 mov	 DWORD PTR [rcx+76], eax
  00b76	33 c0		 xor	 eax, eax
  00b78	85 c0		 test	 eax, eax
  00b7a	75 e0		 jne	 SHORT $LN22@z900_instf
$LN48@z900_instf:

; 953  : 
; 954  :     /* Return to caller to execute this instruction */
; 955  :     return dest;

  00b7c	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR dest$[rsp]
$LN1@z900_instf:

; 956  : 
; 957  : } /* end function ARCH_DEP( instfetch ) */

  00b84	48 81 c4 b8 00
	00 00		 add	 rsp, 184		; 000000b8H
  00b8b	c3		 ret	 0
z900_instfetch ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\vstore.h
;	COMDAT z900_vfetchc
_TEXT	SEGMENT
len2$ = 48
tv76 = 52
main1$ = 56
main2$ = 64
dest$ = 112
len$ = 120
addr$ = 128
arn$ = 136
regs$ = 144
z900_vfetchc PROC					; COMDAT

; 631  : {

$LN9:
  00000	44 89 4c 24 20	 mov	 DWORD PTR [rsp+32], r9d
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	88 54 24 10	 mov	 BYTE PTR [rsp+16], dl
  0000e	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00013	56		 push	 rsi
  00014	57		 push	 rdi
  00015	48 83 ec 58	 sub	 rsp, 88			; 00000058H

; 632  : BYTE   *main1, *main2;                  /* Main storage addresses    */
; 633  : int     len2;                           /* Length to copy on page    */
; 634  : 
; 635  :     if (NOCROSSPAGE( addr, len ))

  00019	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR addr$[rsp]
  00021	48 25 ff 0f 00
	00		 and	 rax, 4095		; 00000fffH
  00027	0f b6 4c 24 78	 movzx	 ecx, BYTE PTR len$[rsp]
  0002c	ba ff 0f 00 00	 mov	 edx, 4095		; 00000fffH
  00031	2b d1		 sub	 edx, ecx
  00033	8b ca		 mov	 ecx, edx
  00035	3b c1		 cmp	 eax, ecx
  00037	7f 0a		 jg	 SHORT $LN7@z900_vfetc
  00039	c7 44 24 34 01
	00 00 00	 mov	 DWORD PTR tv76[rsp], 1
  00041	eb 08		 jmp	 SHORT $LN8@z900_vfetc
$LN7@z900_vfetc:
  00043	c7 44 24 34 00
	00 00 00	 mov	 DWORD PTR tv76[rsp], 0
$LN8@z900_vfetc:
  0004b	83 7c 24 34 00	 cmp	 DWORD PTR tv76[rsp], 0
  00050	74 63		 je	 SHORT $LN2@z900_vfetc

; 636  :     {
; 637  :         ITIMER_SYNC( addr, len, regs );
; 638  :         main1 = MADDRL( addr, len + 1, arn, regs, ACCTYPE_READ, regs->psw.pkey );

  00052	0f b6 44 24 78	 movzx	 eax, BYTE PTR len$[rsp]
  00057	ff c0		 inc	 eax
  00059	48 98		 cdqe
  0005b	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00063	0f b6 49 79	 movzx	 ecx, BYTE PTR [rcx+121]
  00067	88 4c 24 28	 mov	 BYTE PTR [rsp+40], cl
  0006b	c7 44 24 20 04
	00 00 00	 mov	 DWORD PTR [rsp+32], 4
  00073	4c 8b 8c 24 90
	00 00 00	 mov	 r9, QWORD PTR regs$[rsp]
  0007b	44 8b 84 24 88
	00 00 00	 mov	 r8d, DWORD PTR arn$[rsp]
  00083	48 8b d0	 mov	 rdx, rax
  00086	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR addr$[rsp]
  0008e	e8 00 00 00 00	 call	 z900_maddr_l
  00093	48 89 44 24 38	 mov	 QWORD PTR main1$[rsp], rax

; 639  :         memcpy( dest, main1, len + 1 );

  00098	0f b6 44 24 78	 movzx	 eax, BYTE PTR len$[rsp]
  0009d	ff c0		 inc	 eax
  0009f	48 98		 cdqe
  000a1	48 8b 7c 24 70	 mov	 rdi, QWORD PTR dest$[rsp]
  000a6	48 8b 74 24 38	 mov	 rsi, QWORD PTR main1$[rsp]
  000ab	48 8b c8	 mov	 rcx, rax
  000ae	f3 a4		 rep movsb

; 640  :     }

  000b0	e9 01 01 00 00	 jmp	 $LN3@z900_vfetc
$LN2@z900_vfetc:

; 641  :     else
; 642  :     {
; 643  :         len2 = PAGEFRAME_PAGESIZE - (addr & PAGEFRAME_BYTEMASK);

  000b5	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR addr$[rsp]
  000bd	48 25 ff 0f 00
	00		 and	 rax, 4095		; 00000fffH
  000c3	b9 00 10 00 00	 mov	 ecx, 4096		; 00001000H
  000c8	48 2b c8	 sub	 rcx, rax
  000cb	48 8b c1	 mov	 rax, rcx
  000ce	89 44 24 30	 mov	 DWORD PTR len2$[rsp], eax

; 644  :         main1 = MADDRL( addr, len2, arn, regs, ACCTYPE_READ, regs->psw.pkey );

  000d2	48 63 44 24 30	 movsxd	 rax, DWORD PTR len2$[rsp]
  000d7	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  000df	0f b6 49 79	 movzx	 ecx, BYTE PTR [rcx+121]
  000e3	88 4c 24 28	 mov	 BYTE PTR [rsp+40], cl
  000e7	c7 44 24 20 04
	00 00 00	 mov	 DWORD PTR [rsp+32], 4
  000ef	4c 8b 8c 24 90
	00 00 00	 mov	 r9, QWORD PTR regs$[rsp]
  000f7	44 8b 84 24 88
	00 00 00	 mov	 r8d, DWORD PTR arn$[rsp]
  000ff	48 8b d0	 mov	 rdx, rax
  00102	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR addr$[rsp]
  0010a	e8 00 00 00 00	 call	 z900_maddr_l
  0010f	48 89 44 24 38	 mov	 QWORD PTR main1$[rsp], rax

; 645  :         main2 = MADDRL( (addr + len2) & ADDRESS_MAXWRAP( regs ), len + 1 - len2,

  00114	0f b6 44 24 78	 movzx	 eax, BYTE PTR len$[rsp]
  00119	ff c0		 inc	 eax
  0011b	2b 44 24 30	 sub	 eax, DWORD PTR len2$[rsp]
  0011f	48 98		 cdqe
  00121	48 63 4c 24 30	 movsxd	 rcx, DWORD PTR len2$[rsp]
  00126	48 8b 94 24 80
	00 00 00	 mov	 rdx, QWORD PTR addr$[rsp]
  0012e	48 03 d1	 add	 rdx, rcx
  00131	48 8b ca	 mov	 rcx, rdx
  00134	48 8b 94 24 90
	00 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  0013c	48 23 8a 90 00
	00 00		 and	 rcx, QWORD PTR [rdx+144]
  00143	48 8b 94 24 90
	00 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  0014b	0f b6 52 79	 movzx	 edx, BYTE PTR [rdx+121]
  0014f	88 54 24 28	 mov	 BYTE PTR [rsp+40], dl
  00153	c7 44 24 20 04
	00 00 00	 mov	 DWORD PTR [rsp+32], 4
  0015b	4c 8b 8c 24 90
	00 00 00	 mov	 r9, QWORD PTR regs$[rsp]
  00163	44 8b 84 24 88
	00 00 00	 mov	 r8d, DWORD PTR arn$[rsp]
  0016b	48 8b d0	 mov	 rdx, rax
  0016e	e8 00 00 00 00	 call	 z900_maddr_l
  00173	48 89 44 24 40	 mov	 QWORD PTR main2$[rsp], rax

; 646  :                         arn, regs, ACCTYPE_READ, regs->psw.pkey );
; 647  :         memcpy(        dest,        main1,           len2 );

  00178	48 63 44 24 30	 movsxd	 rax, DWORD PTR len2$[rsp]
  0017d	48 8b 7c 24 70	 mov	 rdi, QWORD PTR dest$[rsp]
  00182	48 8b 74 24 38	 mov	 rsi, QWORD PTR main1$[rsp]
  00187	48 8b c8	 mov	 rcx, rax
  0018a	f3 a4		 rep movsb

; 648  :         memcpy( (BYTE*)dest + len2, main2, len + 1 - len2 );

  0018c	0f b6 44 24 78	 movzx	 eax, BYTE PTR len$[rsp]
  00191	ff c0		 inc	 eax
  00193	2b 44 24 30	 sub	 eax, DWORD PTR len2$[rsp]
  00197	48 98		 cdqe
  00199	48 63 4c 24 30	 movsxd	 rcx, DWORD PTR len2$[rsp]
  0019e	48 8b 54 24 70	 mov	 rdx, QWORD PTR dest$[rsp]
  001a3	48 03 d1	 add	 rdx, rcx
  001a6	48 8b ca	 mov	 rcx, rdx
  001a9	48 8b f9	 mov	 rdi, rcx
  001ac	48 8b 74 24 40	 mov	 rsi, QWORD PTR main2$[rsp]
  001b1	48 8b c8	 mov	 rcx, rax
  001b4	f3 a4		 rep movsb
$LN3@z900_vfetc:

; 649  :     }
; 650  : }

  001b6	48 83 c4 58	 add	 rsp, 88			; 00000058H
  001ba	5f		 pop	 rdi
  001bb	5e		 pop	 rsi
  001bc	c3		 ret	 0
z900_vfetchc ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\vstore.h
;	COMDAT z900_vstorec
_TEXT	SEGMENT
len2$ = 48
tv76 = 52
sk$ = 56
tv83 = 64
main1$ = 72
main2$ = 80
src$ = 128
len$ = 136
addr$ = 144
arn$ = 152
regs$ = 160
z900_vstorec PROC					; COMDAT

; 489  : {

$LN9:
  00000	44 89 4c 24 20	 mov	 DWORD PTR [rsp+32], r9d
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	88 54 24 10	 mov	 BYTE PTR [rsp+16], dl
  0000e	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00013	56		 push	 rsi
  00014	57		 push	 rdi
  00015	48 83 ec 68	 sub	 rsp, 104		; 00000068H

; 490  : BYTE   *main1, *main2;                  /* Mainstor addresses        */
; 491  : BYTE   *sk;                             /* Storage key addresses     */
; 492  : int     len2;                           /* Length to end of page     */
; 493  : 
; 494  :     if (NOCROSSPAGE( addr,len ))

  00019	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR addr$[rsp]
  00021	48 25 ff 0f 00
	00		 and	 rax, 4095		; 00000fffH
  00027	0f b6 8c 24 88
	00 00 00	 movzx	 ecx, BYTE PTR len$[rsp]
  0002f	ba ff 0f 00 00	 mov	 edx, 4095		; 00000fffH
  00034	2b d1		 sub	 edx, ecx
  00036	8b ca		 mov	 ecx, edx
  00038	3b c1		 cmp	 eax, ecx
  0003a	7f 0a		 jg	 SHORT $LN7@z900_vstor
  0003c	c7 44 24 34 01
	00 00 00	 mov	 DWORD PTR tv76[rsp], 1
  00044	eb 08		 jmp	 SHORT $LN8@z900_vstor
$LN7@z900_vstor:
  00046	c7 44 24 34 00
	00 00 00	 mov	 DWORD PTR tv76[rsp], 0
$LN8@z900_vstor:
  0004e	83 7c 24 34 00	 cmp	 DWORD PTR tv76[rsp], 0
  00053	74 70		 je	 SHORT $LN2@z900_vstor

; 495  :     {
; 496  :         memcpy( MADDRL( addr, len+1, arn, regs, ACCTYPE_WRITE, regs->psw.pkey ),

  00055	0f b6 84 24 88
	00 00 00	 movzx	 eax, BYTE PTR len$[rsp]
  0005d	ff c0		 inc	 eax
  0005f	48 98		 cdqe
  00061	48 89 44 24 40	 mov	 QWORD PTR tv83[rsp], rax
  00066	0f b6 8c 24 88
	00 00 00	 movzx	 ecx, BYTE PTR len$[rsp]
  0006e	ff c1		 inc	 ecx
  00070	48 63 c9	 movsxd	 rcx, ecx
  00073	48 8b 94 24 a0
	00 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  0007b	0f b6 52 79	 movzx	 edx, BYTE PTR [rdx+121]
  0007f	88 54 24 28	 mov	 BYTE PTR [rsp+40], dl
  00083	c7 44 24 20 02
	00 00 00	 mov	 DWORD PTR [rsp+32], 2
  0008b	4c 8b 8c 24 a0
	00 00 00	 mov	 r9, QWORD PTR regs$[rsp]
  00093	44 8b 84 24 98
	00 00 00	 mov	 r8d, DWORD PTR arn$[rsp]
  0009b	48 8b d1	 mov	 rdx, rcx
  0009e	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR addr$[rsp]
  000a6	e8 00 00 00 00	 call	 z900_maddr_l
  000ab	48 8b f8	 mov	 rdi, rax
  000ae	48 8b b4 24 80
	00 00 00	 mov	 rsi, QWORD PTR src$[rsp]
  000b6	48 8b 44 24 40	 mov	 rax, QWORD PTR tv83[rsp]
  000bb	48 8b c8	 mov	 rcx, rax
  000be	f3 a4		 rep movsb

; 497  :                src, len + 1);
; 498  :         ITIMER_UPDATE( addr, len, regs );
; 499  :     }

  000c0	e9 33 01 00 00	 jmp	 $LN3@z900_vstor
$LN2@z900_vstor:

; 500  :     else
; 501  :     {
; 502  :         len2 = PAGEFRAME_PAGESIZE - (addr & PAGEFRAME_BYTEMASK);

  000c5	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR addr$[rsp]
  000cd	48 25 ff 0f 00
	00		 and	 rax, 4095		; 00000fffH
  000d3	b9 00 10 00 00	 mov	 ecx, 4096		; 00001000H
  000d8	48 2b c8	 sub	 rcx, rax
  000db	48 8b c1	 mov	 rax, rcx
  000de	89 44 24 30	 mov	 DWORD PTR len2$[rsp], eax

; 503  :         main1 = MADDRL( addr, len2, arn, regs, ACCTYPE_WRITE_SKP,

  000e2	48 63 44 24 30	 movsxd	 rax, DWORD PTR len2$[rsp]
  000e7	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  000ef	0f b6 49 79	 movzx	 ecx, BYTE PTR [rcx+121]
  000f3	88 4c 24 28	 mov	 BYTE PTR [rsp+40], cl
  000f7	c7 44 24 20 01
	00 00 00	 mov	 DWORD PTR [rsp+32], 1
  000ff	4c 8b 8c 24 a0
	00 00 00	 mov	 r9, QWORD PTR regs$[rsp]
  00107	44 8b 84 24 98
	00 00 00	 mov	 r8d, DWORD PTR arn$[rsp]
  0010f	48 8b d0	 mov	 rdx, rax
  00112	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR addr$[rsp]
  0011a	e8 00 00 00 00	 call	 z900_maddr_l
  0011f	48 89 44 24 48	 mov	 QWORD PTR main1$[rsp], rax

; 504  :                         regs->psw.pkey );
; 505  :         sk = regs->dat.storkey;

  00124	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0012c	48 8b 80 28 08
	00 00		 mov	 rax, QWORD PTR [rax+2088]
  00133	48 89 44 24 38	 mov	 QWORD PTR sk$[rsp], rax

; 506  :         main2 = MADDRL( (addr + len2) & ADDRESS_MAXWRAP( regs ),

  00138	0f b6 84 24 88
	00 00 00	 movzx	 eax, BYTE PTR len$[rsp]
  00140	ff c0		 inc	 eax
  00142	2b 44 24 30	 sub	 eax, DWORD PTR len2$[rsp]
  00146	48 98		 cdqe
  00148	48 63 4c 24 30	 movsxd	 rcx, DWORD PTR len2$[rsp]
  0014d	48 8b 94 24 90
	00 00 00	 mov	 rdx, QWORD PTR addr$[rsp]
  00155	48 03 d1	 add	 rdx, rcx
  00158	48 8b ca	 mov	 rcx, rdx
  0015b	48 8b 94 24 a0
	00 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  00163	48 23 8a 90 00
	00 00		 and	 rcx, QWORD PTR [rdx+144]
  0016a	48 8b 94 24 a0
	00 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  00172	0f b6 52 79	 movzx	 edx, BYTE PTR [rdx+121]
  00176	88 54 24 28	 mov	 BYTE PTR [rsp+40], dl
  0017a	c7 44 24 20 02
	00 00 00	 mov	 DWORD PTR [rsp+32], 2
  00182	4c 8b 8c 24 a0
	00 00 00	 mov	 r9, QWORD PTR regs$[rsp]
  0018a	44 8b 84 24 98
	00 00 00	 mov	 r8d, DWORD PTR arn$[rsp]
  00192	48 8b d0	 mov	 rdx, rax
  00195	e8 00 00 00 00	 call	 z900_maddr_l
  0019a	48 89 44 24 50	 mov	 QWORD PTR main2$[rsp], rax

; 507  :                         len+1-len2, arn,
; 508  :                         regs, ACCTYPE_WRITE, regs->psw.pkey );
; 509  :         *sk |= (STORKEY_REF | STORKEY_CHANGE);

  0019f	48 8b 44 24 38	 mov	 rax, QWORD PTR sk$[rsp]
  001a4	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  001a7	83 c8 06	 or	 eax, 6
  001aa	48 8b 4c 24 38	 mov	 rcx, QWORD PTR sk$[rsp]
  001af	88 01		 mov	 BYTE PTR [rcx], al

; 510  :         memcpy( main1, src, len2 );

  001b1	48 63 44 24 30	 movsxd	 rax, DWORD PTR len2$[rsp]
  001b6	48 8b 7c 24 48	 mov	 rdi, QWORD PTR main1$[rsp]
  001bb	48 8b b4 24 80
	00 00 00	 mov	 rsi, QWORD PTR src$[rsp]
  001c3	48 8b c8	 mov	 rcx, rax
  001c6	f3 a4		 rep movsb

; 511  :         memcpy( main2, (BYTE*)src + len2, len + 1 - len2 );

  001c8	0f b6 84 24 88
	00 00 00	 movzx	 eax, BYTE PTR len$[rsp]
  001d0	ff c0		 inc	 eax
  001d2	2b 44 24 30	 sub	 eax, DWORD PTR len2$[rsp]
  001d6	48 98		 cdqe
  001d8	48 63 4c 24 30	 movsxd	 rcx, DWORD PTR len2$[rsp]
  001dd	48 8b 94 24 80
	00 00 00	 mov	 rdx, QWORD PTR src$[rsp]
  001e5	48 03 d1	 add	 rdx, rcx
  001e8	48 8b ca	 mov	 rcx, rdx
  001eb	48 8b 7c 24 50	 mov	 rdi, QWORD PTR main2$[rsp]
  001f0	48 8b f1	 mov	 rsi, rcx
  001f3	48 8b c8	 mov	 rcx, rax
  001f6	f3 a4		 rep movsb
$LN3@z900_vstor:

; 512  :     }
; 513  : }

  001f8	48 83 c4 68	 add	 rsp, 104		; 00000068H
  001fc	5f		 pop	 rdi
  001fd	5e		 pop	 rsi
  001fe	c3		 ret	 0
z900_vstorec ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\dat.h
;	COMDAT z900_maddr_l
_TEXT	SEGMENT
tlbix$ = 48
aea_crn$ = 52
tv70 = 56
maddr$ = 64
addr$ = 96
len$ = 104
arn$ = 112
regs$ = 120
acctype$ = 128
akey$ = 136
z900_maddr_l PROC					; COMDAT

; 307  : {

$LN18:
  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	48 83 ec 58	 sub	 rsp, 88			; 00000058H

; 308  :     /* Note: ALL of the below conditions must be true for a TLB hit
; 309  :        to occur.  If ANY of them are false, then it's a TLB miss,
; 310  :        requiring us to then perform a full DAT address translation.
; 311  : 
; 312  :        Note too that on the grand scheme of things the order/sequence
; 313  :        of the below tests (if statements) is completely unimportant
; 314  :        since ALL conditions must be checked anyway in order for a hit
; 315  :        to occur, and it doesn't matter that a miss tests a few extra
; 316  :        conditions since it's going to do a full translation anyway!
; 317  :        (which is many, many instructions)
; 318  :     */
; 319  : 
; 320  :     int  aea_crn  = (arn >= USE_ARMODE) ? 0 : regs->AEA_AR( arn );

  00018	83 7c 24 70 10	 cmp	 DWORD PTR arn$[rsp], 16
  0001d	7c 0a		 jl	 SHORT $LN16@z900_maddr
  0001f	c7 44 24 38 00
	00 00 00	 mov	 DWORD PTR tv70[rsp], 0
  00027	eb 19		 jmp	 SHORT $LN17@z900_maddr
$LN16@z900_maddr:
  00029	8b 44 24 70	 mov	 eax, DWORD PTR arn$[rsp]
  0002d	83 c0 05	 add	 eax, 5
  00030	48 98		 cdqe
  00032	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  00037	8b 84 81 94 0c
	00 00		 mov	 eax, DWORD PTR [rcx+rax*4+3220]
  0003e	89 44 24 38	 mov	 DWORD PTR tv70[rsp], eax
$LN17@z900_maddr:
  00042	8b 44 24 38	 mov	 eax, DWORD PTR tv70[rsp]
  00046	89 44 24 34	 mov	 DWORD PTR aea_crn$[rsp], eax

; 321  :     U16  tlbix    = TLBIX( addr );

  0004a	48 8b 44 24 60	 mov	 rax, QWORD PTR addr$[rsp]
  0004f	48 c1 e8 0c	 shr	 rax, 12
  00053	48 25 ff 03 00
	00		 and	 rax, 1023		; 000003ffH
  00059	66 89 44 24 30	 mov	 WORD PTR tlbix$[rsp], ax

; 322  :     BYTE *maddr   = NULL;

  0005e	48 c7 44 24 40
	00 00 00 00	 mov	 QWORD PTR maddr$[rsp], 0

; 323  : 
; 324  :     /* Non-zero AEA Control Register number? */
; 325  :     if (aea_crn)

  00067	83 7c 24 34 00	 cmp	 DWORD PTR aea_crn$[rsp], 0
  0006c	0f 84 2d 01 00
	00		 je	 $LN2@z900_maddr

; 326  :     {
; 327  :         /* Same Addess Space Designator as before? */
; 328  :         /* Or if not, is address in a common segment? */
; 329  :         if (0
; 330  :             || (regs->CR( aea_crn ) == regs->tlb.TLB_ASD( tlbix ))
; 331  :             || (regs->AEA_COMMON( aea_crn ) & regs->tlb.common[ tlbix ])

  00072	33 c0		 xor	 eax, eax
  00074	85 c0		 test	 eax, eax
  00076	75 5a		 jne	 SHORT $LN4@z900_maddr
  00078	8b 44 24 34	 mov	 eax, DWORD PTR aea_crn$[rsp]
  0007c	ff c0		 inc	 eax
  0007e	48 98		 cdqe
  00080	0f b7 4c 24 30	 movzx	 ecx, WORD PTR tlbix$[rsp]
  00085	48 8b 54 24 78	 mov	 rdx, QWORD PTR regs$[rsp]
  0008a	4c 8b 44 24 78	 mov	 r8, QWORD PTR regs$[rsp]
  0008f	49 8b 8c c8 60
	b0 00 00	 mov	 rcx, QWORD PTR [r8+rcx*8+45152]
  00097	48 39 8c c2 00
	06 00 00	 cmp	 QWORD PTR [rdx+rax*8+1536], rcx
  0009f	74 31		 je	 SHORT $LN4@z900_maddr
  000a1	8b 44 24 34	 mov	 eax, DWORD PTR aea_crn$[rsp]
  000a5	ff c0		 inc	 eax
  000a7	48 98		 cdqe
  000a9	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  000ae	0f b6 84 01 e8
	0c 00 00	 movzx	 eax, BYTE PTR [rcx+rax+3304]
  000b6	0f b7 4c 24 30	 movzx	 ecx, WORD PTR tlbix$[rsp]
  000bb	48 8b 54 24 78	 mov	 rdx, QWORD PTR regs$[rsp]
  000c0	0f b6 8c 0a 60
	54 01 00	 movzx	 ecx, BYTE PTR [rdx+rcx+87136]
  000c8	23 c1		 and	 eax, ecx
  000ca	85 c0		 test	 eax, eax
  000cc	0f 84 cd 00 00
	00		 je	 $LN3@z900_maddr
$LN4@z900_maddr:

; 332  :         )
; 333  :         {
; 334  :             /* Storage Key zero? */
; 335  :             /* Or if not, same Storage Key as before? */
; 336  :             if (0
; 337  :                 || akey == 0
; 338  :                 || akey == regs->tlb.skey[ tlbix ]

  000d2	33 c0		 xor	 eax, eax
  000d4	85 c0		 test	 eax, eax
  000d6	75 2e		 jne	 SHORT $LN6@z900_maddr
  000d8	0f b6 84 24 88
	00 00 00	 movzx	 eax, BYTE PTR akey$[rsp]
  000e0	85 c0		 test	 eax, eax
  000e2	74 22		 je	 SHORT $LN6@z900_maddr
  000e4	0f b6 84 24 88
	00 00 00	 movzx	 eax, BYTE PTR akey$[rsp]
  000ec	0f b7 4c 24 30	 movzx	 ecx, WORD PTR tlbix$[rsp]
  000f1	48 8b 54 24 78	 mov	 rdx, QWORD PTR regs$[rsp]
  000f6	0f b6 8c 0a 60
	50 01 00	 movzx	 ecx, BYTE PTR [rdx+rcx+86112]
  000fe	3b c1		 cmp	 eax, ecx
  00100	0f 85 99 00 00
	00		 jne	 $LN5@z900_maddr
$LN6@z900_maddr:

; 339  :             )
; 340  :             {
; 341  :                 /* Does the page address match the one in the TLB? */
; 342  :                 /* (does a TLB entry exist for this page address?) */
; 343  :                 if (
; 344  :                     ((addr & TLBID_PAGEMASK) | regs->tlbID)
; 345  :                     ==

  00106	48 8b 44 24 60	 mov	 rax, QWORD PTR addr$[rsp]
  0010b	48 25 00 00 c0
	ff		 and	 rax, -4194304		; ffffffffffc00000H
  00111	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  00116	8b 89 58 b0 00
	00		 mov	 ecx, DWORD PTR [rcx+45144]
  0011c	48 0b c1	 or	 rax, rcx
  0011f	0f b7 4c 24 30	 movzx	 ecx, WORD PTR tlbix$[rsp]
  00124	48 8b 54 24 78	 mov	 rdx, QWORD PTR regs$[rsp]
  00129	48 3b 84 ca 60
	d0 00 00	 cmp	 rax, QWORD PTR [rdx+rcx*8+53344]
  00131	75 6c		 jne	 SHORT $LN7@z900_maddr

; 346  :                     regs->tlb.TLB_VADDR( tlbix )
; 347  :                 )
; 348  :                 {
; 349  :                     /* Is storage being accessed same way as before? */
; 350  :                     if (acctype & regs->tlb.acc[ tlbix ])

  00133	0f b7 44 24 30	 movzx	 eax, WORD PTR tlbix$[rsp]
  00138	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  0013d	0f b6 84 01 60
	5c 01 00	 movzx	 eax, BYTE PTR [rcx+rax+89184]
  00145	8b 8c 24 80 00
	00 00		 mov	 ecx, DWORD PTR acctype$[rsp]
  0014c	23 c8		 and	 ecx, eax
  0014e	8b c1		 mov	 eax, ecx
  00150	85 c0		 test	 eax, eax
  00152	74 4b		 je	 SHORT $LN8@z900_maddr

; 351  :                     {
; 352  :                         /*------------------------------------------*/
; 353  :                         /* TLB hit: use previously translated value */
; 354  :                         /*------------------------------------------*/
; 355  : 
; 356  :                         if (acctype & ACC_CHECK)

  00154	8b 84 24 80 00
	00 00		 mov	 eax, DWORD PTR acctype$[rsp]
  0015b	83 e0 01	 and	 eax, 1
  0015e	85 c0		 test	 eax, eax
  00160	74 1e		 je	 SHORT $LN9@z900_maddr

; 357  :                             regs->dat.storkey = regs->tlb.storkey[ tlbix ];

  00162	0f b7 44 24 30	 movzx	 eax, WORD PTR tlbix$[rsp]
  00167	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  0016c	48 8b 54 24 78	 mov	 rdx, QWORD PTR regs$[rsp]
  00171	48 8b 84 c2 60
	30 01 00	 mov	 rax, QWORD PTR [rdx+rax*8+77920]
  00179	48 89 81 28 08
	00 00		 mov	 QWORD PTR [rcx+2088], rax
$LN9@z900_maddr:

; 358  : 
; 359  :                         maddr = MAINADDR( regs->tlb.main[tlbix], addr );

  00180	0f b7 44 24 30	 movzx	 eax, WORD PTR tlbix$[rsp]
  00185	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  0018a	48 8b 54 24 60	 mov	 rdx, QWORD PTR addr$[rsp]
  0018f	48 8b 84 c1 60
	10 01 00	 mov	 rax, QWORD PTR [rcx+rax*8+69728]
  00197	48 33 c2	 xor	 rax, rdx
  0019a	48 89 44 24 40	 mov	 QWORD PTR maddr$[rsp], rax
$LN8@z900_maddr:
$LN7@z900_maddr:
$LN5@z900_maddr:
$LN3@z900_maddr:
$LN2@z900_maddr:

; 360  :                     }
; 361  :                 }
; 362  :             }
; 363  :         }
; 364  :     }
; 365  : 
; 366  :     /*---------------------------------------*/
; 367  :     /* TLB miss: do full address translation */
; 368  :     /*---------------------------------------*/
; 369  :     if (!maddr)

  0019f	48 83 7c 24 40
	00		 cmp	 QWORD PTR maddr$[rsp], 0
  001a5	75 36		 jne	 SHORT $LN10@z900_maddr

; 370  :         maddr = ARCH_DEP( logical_to_main_l )( addr, arn, regs, acctype, akey, len );

  001a7	48 8b 44 24 68	 mov	 rax, QWORD PTR len$[rsp]
  001ac	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  001b1	0f b6 84 24 88
	00 00 00	 movzx	 eax, BYTE PTR akey$[rsp]
  001b9	88 44 24 20	 mov	 BYTE PTR [rsp+32], al
  001bd	44 8b 8c 24 80
	00 00 00	 mov	 r9d, DWORD PTR acctype$[rsp]
  001c5	4c 8b 44 24 78	 mov	 r8, QWORD PTR regs$[rsp]
  001ca	8b 54 24 70	 mov	 edx, DWORD PTR arn$[rsp]
  001ce	48 8b 4c 24 60	 mov	 rcx, QWORD PTR addr$[rsp]
  001d3	e8 00 00 00 00	 call	 z900_logical_to_main_l
  001d8	48 89 44 24 40	 mov	 QWORD PTR maddr$[rsp], rax
$LN10@z900_maddr:

; 371  : 
; 372  : #if defined( FEATURE_073_TRANSACT_EXEC_FACILITY )
; 373  :     if (FACILITY_ENABLED( 073_TRANSACT_EXEC, regs ))

  001dd	b8 01 00 00 00	 mov	 eax, 1
  001e2	48 6b c0 09	 imul	 rax, rax, 9
  001e6	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  001eb	0f b6 84 01 28
	0d 00 00	 movzx	 eax, BYTE PTR [rcx+rax+3368]
  001f3	83 e0 40	 and	 eax, 64			; 00000040H
  001f6	85 c0		 test	 eax, eax
  001f8	0f 84 89 00 00
	00		 je	 $LN11@z900_maddr

; 374  :     {
; 375  :         /* SA22-7832-12 Principles of Operation, page 5-99:
; 376  : 
; 377  :              "Storage accesses for instruction and DAT- and ART-
; 378  :               table fetches follow the non-transactional rules."
; 379  :         */
; 380  :         if (0
; 381  :             || !regs
; 382  :             || !regs->txf_tnd
; 383  :             || arn == USE_INST_SPACE    /* Instruction fetching */
; 384  :             || arn == USE_REAL_ADDR     /* Address translation  */

  001fe	33 c0		 xor	 eax, eax
  00200	85 c0		 test	 eax, eax
  00202	75 26		 jne	 SHORT $LN13@z900_maddr
  00204	48 83 7c 24 78
	00		 cmp	 QWORD PTR regs$[rsp], 0
  0020a	74 1e		 je	 SHORT $LN13@z900_maddr
  0020c	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  00211	0f b6 80 58 0e
	00 00		 movzx	 eax, BYTE PTR [rax+3672]
  00218	85 c0		 test	 eax, eax
  0021a	74 0e		 je	 SHORT $LN13@z900_maddr
  0021c	83 7c 24 70 ff	 cmp	 DWORD PTR arn$[rsp], -1
  00221	74 07		 je	 SHORT $LN13@z900_maddr
  00223	83 7c 24 70 fe	 cmp	 DWORD PTR arn$[rsp], -2
  00228	75 07		 jne	 SHORT $LN12@z900_maddr
$LN13@z900_maddr:

; 385  :         )
; 386  :             return maddr;

  0022a	48 8b 44 24 40	 mov	 rax, QWORD PTR maddr$[rsp]
  0022f	eb 5b		 jmp	 SHORT $LN1@z900_maddr
$LN12@z900_maddr:

; 387  : 
; 388  :         /* Quick exit if NTSTG call */
; 389  :         if (regs->txf_NTSTG)

  00231	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  00236	0f b6 80 4b 0e
	00 00		 movzx	 eax, BYTE PTR [rax+3659]
  0023d	85 c0		 test	 eax, eax
  0023f	74 13		 je	 SHORT $LN14@z900_maddr

; 390  :         {
; 391  :             regs->txf_NTSTG = false;

  00241	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  00246	c6 80 4b 0e 00
	00 00		 mov	 BYTE PTR [rax+3659], 0

; 392  :             return maddr;

  0024d	48 8b 44 24 40	 mov	 rax, QWORD PTR maddr$[rsp]
  00252	eb 38		 jmp	 SHORT $LN1@z900_maddr
$LN14@z900_maddr:

; 393  :         }
; 394  : 
; 395  :         /* Translate to alternate TXF address */
; 396  :         maddr = TXF_MADDRL( addr, len, arn, regs, acctype, maddr );

  00254	48 8b 44 24 40	 mov	 rax, QWORD PTR maddr$[rsp]
  00259	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  0025e	8b 84 24 80 00
	00 00		 mov	 eax, DWORD PTR acctype$[rsp]
  00265	89 44 24 20	 mov	 DWORD PTR [rsp+32], eax
  00269	4c 8b 4c 24 78	 mov	 r9, QWORD PTR regs$[rsp]
  0026e	44 8b 44 24 70	 mov	 r8d, DWORD PTR arn$[rsp]
  00273	48 8b 54 24 68	 mov	 rdx, QWORD PTR len$[rsp]
  00278	48 8b 4c 24 60	 mov	 rcx, QWORD PTR addr$[rsp]
  0027d	e8 00 00 00 00	 call	 txf_maddr_l
  00282	48 89 44 24 40	 mov	 QWORD PTR maddr$[rsp], rax
$LN11@z900_maddr:

; 397  :     }
; 398  : #endif
; 399  : 
; 400  :     return maddr;

  00287	48 8b 44 24 40	 mov	 rax, QWORD PTR maddr$[rsp]
$LN1@z900_maddr:

; 401  : }

  0028c	48 83 c4 58	 add	 rsp, 88			; 00000058H
  00290	c3		 ret	 0
z900_maddr_l ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\inline.h
;	COMDAT z900_per3_zero_xcheck
_TEXT	SEGMENT
tv79 = 32
regs$ = 64
b1$ = 72
z900_per3_zero_xcheck PROC				; COMDAT

; 754  : {

$LN6:
  00000	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00004	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00009	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 755  : #if defined( FEATURE_PER_ZERO_ADDRESS_DETECTION_FACILITY )
; 756  :     if (b1 && GR_A( b1, regs ) == 0)

  0000d	83 7c 24 48 00	 cmp	 DWORD PTR b1$[rsp], 0
  00012	74 53		 je	 SHORT $LN2@z900_per3_
  00014	48 8b 44 24 40	 mov	 rax, QWORD PTR regs$[rsp]
  00019	8b 80 80 00 00
	00		 mov	 eax, DWORD PTR [rax+128]
  0001f	83 e0 01	 and	 eax, 1
  00022	85 c0		 test	 eax, eax
  00024	74 19		 je	 SHORT $LN4@z900_per3_
  00026	48 63 44 24 48	 movsxd	 rax, DWORD PTR b1$[rsp]
  0002b	48 8b 4c 24 40	 mov	 rcx, QWORD PTR regs$[rsp]
  00030	48 8b 84 c1 80
	02 00 00	 mov	 rax, QWORD PTR [rcx+rax*8+640]
  00038	48 89 44 24 20	 mov	 QWORD PTR tv79[rsp], rax
  0003d	eb 16		 jmp	 SHORT $LN5@z900_per3_
$LN4@z900_per3_:
  0003f	48 63 44 24 48	 movsxd	 rax, DWORD PTR b1$[rsp]
  00044	48 8b 4c 24 40	 mov	 rcx, QWORD PTR regs$[rsp]
  00049	8b 84 c1 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax*8+640]
  00050	48 89 44 24 20	 mov	 QWORD PTR tv79[rsp], rax
$LN5@z900_per3_:
  00055	48 83 7c 24 20
	00		 cmp	 QWORD PTR tv79[rsp], 0
  0005b	75 0a		 jne	 SHORT $LN2@z900_per3_

; 757  :         ARCH_DEP( per3_zero )( regs );

  0005d	48 8b 4c 24 40	 mov	 rcx, QWORD PTR regs$[rsp]
  00062	e8 00 00 00 00	 call	 z900_per3_zero
$LN2@z900_per3_:

; 758  : #else
; 759  :     UNREFERENCED( regs );
; 760  :     UNREFERENCED( b1 );
; 761  : #endif
; 762  : }

  00067	48 83 c4 38	 add	 rsp, 56			; 00000038H
  0006b	c3		 ret	 0
z900_per3_zero_xcheck ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\inline.h
;	COMDAT z900_per3_zero
_TEXT	SEGMENT
tv75 = 32
regs$ = 64
z900_per3_zero PROC					; COMDAT

; 602  : {

$LN12:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 603  : #if defined( FEATURE_PER_ZERO_ADDRESS_DETECTION_FACILITY )
; 604  :     if (1
; 605  :         && EN_IC_PER_ZEROADDR( regs )
; 606  :         && !IS_PER_SUPRESS( regs, CR9_ZEROADDR )

  00009	33 c0		 xor	 eax, eax
  0000b	83 f8 01	 cmp	 eax, 1
  0000e	0f 84 be 00 00
	00		 je	 $LN5@z900_per3_
  00014	48 8b 44 24 40	 mov	 rax, QWORD PTR regs$[rsp]
  00019	8b 80 28 07 00
	00		 mov	 eax, DWORD PTR [rax+1832]
  0001f	c1 e8 02	 shr	 eax, 2
  00022	83 e0 01	 and	 eax, 1
  00025	85 c0		 test	 eax, eax
  00027	74 0a		 je	 SHORT $LN10@z900_per3_
  00029	c7 44 24 20 01
	00 00 00	 mov	 DWORD PTR tv75[rsp], 1
  00031	eb 08		 jmp	 SHORT $LN11@z900_per3_
$LN10@z900_per3_:
  00033	c7 44 24 20 00
	00 00 00	 mov	 DWORD PTR tv75[rsp], 0
$LN11@z900_per3_:
  0003b	83 7c 24 20 00	 cmp	 DWORD PTR tv75[rsp], 0
  00040	0f 84 8c 00 00
	00		 je	 $LN5@z900_per3_
  00046	48 8b 44 24 40	 mov	 rax, QWORD PTR regs$[rsp]
  0004b	8b 40 48	 mov	 eax, DWORD PTR [rax+72]
  0004e	25 00 00 04 00	 and	 eax, 262144		; 00040000H
  00053	85 c0		 test	 eax, eax
  00055	74 7b		 je	 SHORT $LN5@z900_per3_
  00057	ba 00 00 00 04	 mov	 edx, 67108864		; 04000000H
  0005c	48 8b 4c 24 40	 mov	 rcx, QWORD PTR regs$[rsp]
  00061	e8 00 00 00 00	 call	 z900_is_per3_event_suppressed
  00066	0f b6 c0	 movzx	 eax, al
  00069	85 c0		 test	 eax, eax
  0006b	75 65		 jne	 SHORT $LN5@z900_per3_

; 607  :     )
; 608  :     {
; 609  :         regs->peradr = regs->periaddr;

  0006d	48 8b 44 24 40	 mov	 rax, QWORD PTR regs$[rsp]
  00072	48 8b 4c 24 40	 mov	 rcx, QWORD PTR regs$[rsp]
  00077	48 8b 89 e8 08
	00 00		 mov	 rcx, QWORD PTR [rcx+2280]
  0007e	48 89 88 d8 08
	00 00		 mov	 QWORD PTR [rax+2264], rcx
$LN4@z900_per3_:

; 610  :         ON_IC_PER_ZEROADDR( regs );

  00085	48 8b 44 24 40	 mov	 rax, QWORD PTR regs$[rsp]
  0008a	8b 40 4c	 mov	 eax, DWORD PTR [rax+76]
  0008d	0f ba e8 12	 bts	 eax, 18
  00091	48 8b 4c 24 40	 mov	 rcx, QWORD PTR regs$[rsp]
  00096	89 41 4c	 mov	 DWORD PTR [rcx+76], eax
  00099	33 c0		 xor	 eax, eax
  0009b	85 c0		 test	 eax, eax
  0009d	75 e6		 jne	 SHORT $LN4@z900_per3_

; 611  :         if (OPEN_IC_PER_ZEROADDR( regs ))

  0009f	48 8b 44 24 40	 mov	 rax, QWORD PTR regs$[rsp]
  000a4	48 8b 4c 24 40	 mov	 rcx, QWORD PTR regs$[rsp]
  000a9	8b 49 4c	 mov	 ecx, DWORD PTR [rcx+76]
  000ac	8b 40 48	 mov	 eax, DWORD PTR [rax+72]
  000af	23 c1		 and	 eax, ecx
  000b1	25 00 00 04 00	 and	 eax, 262144		; 00040000H
  000b6	85 c0		 test	 eax, eax
  000b8	74 18		 je	 SHORT $LN6@z900_per3_

; 612  :             RETURN_INTCHECK( regs );

  000ba	48 8b 44 24 40	 mov	 rax, QWORD PTR regs$[rsp]
  000bf	48 05 80 09 00
	00		 add	 rax, 2432		; 00000980H
  000c5	ba ff ff ff ff	 mov	 edx, -1
  000ca	48 8b c8	 mov	 rcx, rax
  000cd	e8 00 00 00 00	 call	 longjmp
$LN6@z900_per3_:
$LN5@z900_per3_:
$LN7@z900_per3_:

; 613  :     }
; 614  : #else
; 615  :     UNREFERENCED( regs );
; 616  : #endif
; 617  : }

  000d2	48 83 c4 38	 add	 rsp, 56			; 00000038H
  000d6	c3		 ret	 0
z900_per3_zero ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\inline.h
;	COMDAT z900_is_per3_event_suppressed
_TEXT	SEGMENT
regs$ = 8
cr9_per_event$ = 16
z900_is_per3_event_suppressed PROC			; COMDAT

; 566  : {

  00000	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00004	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx

; 567  : #if !defined( FEATURE_PER3 )
; 568  :     UNREFERENCED( regs );
; 569  :     UNREFERENCED( cr9_per_event );
; 570  : #else
; 571  :     /* DON'T suppress this event if Event Suppression isn't enabled */
; 572  :     if (!(regs->CR_L(9) & CR9_SUPPRESS))

  00009	b8 08 00 00 00	 mov	 eax, 8
  0000e	48 6b c0 0a	 imul	 rax, rax, 10
  00012	48 8b 4c 24 08	 mov	 rcx, QWORD PTR regs$[rsp]
  00017	8b 84 01 00 06
	00 00		 mov	 eax, DWORD PTR [rcx+rax+1536]
  0001e	25 00 00 40 00	 and	 eax, 4194304		; 00400000H
  00023	85 c0		 test	 eax, eax
  00025	75 04		 jne	 SHORT $LN2@z900_is_pe

; 573  :         return false;

  00027	32 c0		 xor	 al, al
  00029	eb 78		 jmp	 SHORT $LN1@z900_is_pe
$LN2@z900_is_pe:

; 574  : 
; 575  :     /* Is this PER event one that is ALLOWED to be suppressed? */
; 576  :     if (cr9_per_event & CR9_SUPPRESSABLE)

  0002b	8b 44 24 10	 mov	 eax, DWORD PTR cr9_per_event$[rsp]
  0002f	25 00 00 00 ed	 and	 eax, -318767104		; ed000000H
  00034	85 c0		 test	 eax, eax
  00036	74 69		 je	 SHORT $LN3@z900_is_pe

; 577  :     {
; 578  :         /* Is there an active transaction? */
; 579  :         if (regs->txf_tnd)

  00038	48 8b 44 24 08	 mov	 rax, QWORD PTR regs$[rsp]
  0003d	0f b6 80 58 0e
	00 00		 movzx	 eax, BYTE PTR [rax+3672]
  00044	85 c0		 test	 eax, eax
  00046	74 04		 je	 SHORT $LN4@z900_is_pe

; 580  :             return true;        /* Yes, then suppress it! */

  00048	b0 01		 mov	 al, 1
  0004a	eb 57		 jmp	 SHORT $LN1@z900_is_pe
$LN4@z900_is_pe:

; 581  : 
; 582  :         /* Suppress instruction-fetch events for TBEGIN/TBEGINC */
; 583  :         if (1
; 584  :             && cr9_per_event & CR9_IF
; 585  :             && *(regs->ip+0) == 0xE5
; 586  :             && (0

  0004c	33 c0		 xor	 eax, eax
  0004e	83 f8 01	 cmp	 eax, 1
  00051	74 4e		 je	 SHORT $LN5@z900_is_pe
  00053	8b 44 24 10	 mov	 eax, DWORD PTR cr9_per_event$[rsp]
  00057	25 00 00 00 40	 and	 eax, 1073741824		; 40000000H
  0005c	85 c0		 test	 eax, eax
  0005e	74 41		 je	 SHORT $LN5@z900_is_pe
  00060	48 8b 44 24 08	 mov	 rax, QWORD PTR regs$[rsp]
  00065	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  00069	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  0006c	3d e5 00 00 00	 cmp	 eax, 229		; 000000e5H
  00071	75 2e		 jne	 SHORT $LN5@z900_is_pe
  00073	33 c0		 xor	 eax, eax
  00075	85 c0		 test	 eax, eax
  00077	75 24		 jne	 SHORT $LN6@z900_is_pe
  00079	48 8b 44 24 08	 mov	 rax, QWORD PTR regs$[rsp]
  0007e	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  00082	0f b6 40 01	 movzx	 eax, BYTE PTR [rax+1]
  00086	83 f8 60	 cmp	 eax, 96			; 00000060H
  00089	74 12		 je	 SHORT $LN6@z900_is_pe
  0008b	48 8b 44 24 08	 mov	 rax, QWORD PTR regs$[rsp]
  00090	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  00094	0f b6 40 01	 movzx	 eax, BYTE PTR [rax+1]
  00098	83 f8 61	 cmp	 eax, 97			; 00000061H
  0009b	75 04		 jne	 SHORT $LN5@z900_is_pe
$LN6@z900_is_pe:

; 587  :                 || *(regs->ip+1) == 0x60
; 588  :                 || *(regs->ip+1) == 0x61
; 589  :                )
; 590  :         )
; 591  :             return true;        /* TBEGIN/TBEGINC: suppress it! */

  0009d	b0 01		 mov	 al, 1
  0009f	eb 02		 jmp	 SHORT $LN1@z900_is_pe
$LN5@z900_is_pe:
$LN3@z900_is_pe:

; 592  :     }
; 593  : #endif
; 594  :     /* Otherwise DON'T suppress this PER event */
; 595  :     return false;

  000a1	32 c0		 xor	 al, al
$LN1@z900_is_pe:

; 596  : }

  000a3	c3		 ret	 0
z900_is_per3_event_suppressed ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\skey.h
;	COMDAT z900_get_ptr_to_storekey
_TEXT	SEGMENT
abs$ = 48
z900_get_ptr_to_storekey PROC				; COMDAT

; 308  : {

$LN3:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 309  : #if defined( FEATURE_2K_STORAGE_KEYS )
; 310  :     return ARCH_DEP( get_ptr_to_2K_storekey )( abs );
; 311  : #else
; 312  :     return ARCH_DEP( get_ptr_to_4K_storekey )( abs );

  00009	48 8b 4c 24 30	 mov	 rcx, QWORD PTR abs$[rsp]
  0000e	e8 00 00 00 00	 call	 z900_get_ptr_to_4K_storekey

; 313  : #endif
; 314  : }

  00013	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00017	c3		 ret	 0
z900_get_ptr_to_storekey ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\skey.h
;	COMDAT z900_or_4K_storage_key
_TEXT	SEGMENT
abs$ = 48
bits$ = 56
z900_or_4K_storage_key PROC				; COMDAT

; 242  :   inline void  ARCH_DEP( or_4K_storage_key )      (              U64 abs, BYTE bits ) {        ARCH_DEP( _or_storage_key      )(      abs, bits & ~STORKEY_BADFRM, 4 ); }

$LN3:
  00000	88 54 24 10	 mov	 BYTE PTR [rsp+16], dl
  00004	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00009	48 83 ec 28	 sub	 rsp, 40			; 00000028H
  0000d	0f b6 44 24 38	 movzx	 eax, BYTE PTR bits$[rsp]
  00012	83 e0 fe	 and	 eax, -2
  00015	41 b0 04	 mov	 r8b, 4
  00018	0f b6 d0	 movzx	 edx, al
  0001b	48 8b 4c 24 30	 mov	 rcx, QWORD PTR abs$[rsp]
  00020	e8 00 00 00 00	 call	 z900__or_storage_key
  00025	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00029	c3		 ret	 0
z900_or_4K_storage_key ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\skey.h
;	COMDAT z900_get_ptr_to_4K_storekey
_TEXT	SEGMENT
abs$ = 48
z900_get_ptr_to_4K_storekey PROC			; COMDAT

; 238  :   inline BYTE* ARCH_DEP( get_ptr_to_4K_storekey ) (              U64 abs            ) { return           _get_storekey_ptr     (      abs, 4 );                         }

$LN3:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 28	 sub	 rsp, 40			; 00000028H
  00009	b2 04		 mov	 dl, 4
  0000b	48 8b 4c 24 30	 mov	 rcx, QWORD PTR abs$[rsp]
  00010	e8 00 00 00 00	 call	 _get_storekey_ptr
  00015	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00019	c3		 ret	 0
z900_get_ptr_to_4K_storekey ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\skey.h
;	COMDAT z900__or_storage_key
_TEXT	SEGMENT
skey1_ptr$1 = 32
skey2_ptr$2 = 40
skey_ptr$3 = 48
abs$ = 80
bits$ = 88
K$ = 96
z900__or_storage_key PROC				; COMDAT

; 189  : {

$LN8:
  00000	44 88 44 24 18	 mov	 BYTE PTR [rsp+24], r8b
  00005	88 54 24 10	 mov	 BYTE PTR [rsp+16], dl
  00009	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000e	48 83 ec 48	 sub	 rsp, 72			; 00000048H
$LN4@z900__or_s:

; 190  :     UNREFERENCED( K ); // (for FEATURE_4K_STORAGE_KEYS case)

  00012	33 c0		 xor	 eax, eax
  00014	85 c0		 test	 eax, eax
  00016	75 fa		 jne	 SHORT $LN4@z900__or_s

; 191  :     if (IS_DOUBLE_KEYED_4K_BYTE_BLOCK( K ))

  00018	33 c0		 xor	 eax, eax
  0001a	85 c0		 test	 eax, eax
  0001c	74 50		 je	 SHORT $LN5@z900__or_s

; 192  :     {
; 193  :         BYTE* skey1_ptr = _get_storekey1_ptr( abs );

  0001e	48 8b 4c 24 50	 mov	 rcx, QWORD PTR abs$[rsp]
  00023	e8 00 00 00 00	 call	 _get_storekey1_ptr
  00028	48 89 44 24 20	 mov	 QWORD PTR skey1_ptr$1[rsp], rax

; 194  :         BYTE* skey2_ptr = _get_storekey2_ptr( abs );

  0002d	48 8b 4c 24 50	 mov	 rcx, QWORD PTR abs$[rsp]
  00032	e8 00 00 00 00	 call	 _get_storekey2_ptr
  00037	48 89 44 24 28	 mov	 QWORD PTR skey2_ptr$2[rsp], rax

; 195  :         OR_SKEY( skey1_ptr, bits );

  0003c	0f b6 44 24 58	 movzx	 eax, BYTE PTR bits$[rsp]
  00041	48 8b 4c 24 20	 mov	 rcx, QWORD PTR skey1_ptr$1[rsp]
  00046	0f b6 09	 movzx	 ecx, BYTE PTR [rcx]
  00049	0b c8		 or	 ecx, eax
  0004b	8b c1		 mov	 eax, ecx
  0004d	48 8b 4c 24 20	 mov	 rcx, QWORD PTR skey1_ptr$1[rsp]
  00052	88 01		 mov	 BYTE PTR [rcx], al

; 196  :         OR_SKEY( skey2_ptr, bits );

  00054	0f b6 44 24 58	 movzx	 eax, BYTE PTR bits$[rsp]
  00059	48 8b 4c 24 28	 mov	 rcx, QWORD PTR skey2_ptr$2[rsp]
  0005e	0f b6 09	 movzx	 ecx, BYTE PTR [rcx]
  00061	0b c8		 or	 ecx, eax
  00063	8b c1		 mov	 eax, ecx
  00065	48 8b 4c 24 28	 mov	 rcx, QWORD PTR skey2_ptr$2[rsp]
  0006a	88 01		 mov	 BYTE PTR [rcx], al

; 197  :     }

  0006c	eb 2c		 jmp	 SHORT $LN6@z900__or_s
$LN5@z900__or_s:

; 198  :     else
; 199  :     {
; 200  :         BYTE* skey_ptr  = _get_storekey_ptr( abs, K );

  0006e	0f b6 54 24 60	 movzx	 edx, BYTE PTR K$[rsp]
  00073	48 8b 4c 24 50	 mov	 rcx, QWORD PTR abs$[rsp]
  00078	e8 00 00 00 00	 call	 _get_storekey_ptr
  0007d	48 89 44 24 30	 mov	 QWORD PTR skey_ptr$3[rsp], rax

; 201  :         OR_SKEY( skey_ptr, bits );

  00082	0f b6 44 24 58	 movzx	 eax, BYTE PTR bits$[rsp]
  00087	48 8b 4c 24 30	 mov	 rcx, QWORD PTR skey_ptr$3[rsp]
  0008c	0f b6 09	 movzx	 ecx, BYTE PTR [rcx]
  0008f	0b c8		 or	 ecx, eax
  00091	8b c1		 mov	 eax, ecx
  00093	48 8b 4c 24 30	 mov	 rcx, QWORD PTR skey_ptr$3[rsp]
  00098	88 01		 mov	 BYTE PTR [rcx], al
$LN6@z900__or_s:

; 202  :     }
; 203  : }

  0009a	48 83 c4 48	 add	 rsp, 72			; 00000048H
  0009e	c3		 ret	 0
z900__or_storage_key ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\sie.c
_TEXT	SEGMENT
temp$1 = 32
r2$ = 36
r1$ = 40
m3$ = 44
inst$ = 64
regs$ = 72
z900_extract_and_set_storage_attributes PROC

; 2032 : {

$LN11:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 2033 :     int r1, r2, m3;
; 2034 :     RRF_M( inst, regs, r1, r2, m3 );

  0000e	48 8b 4c 24 40	 mov	 rcx, QWORD PTR inst$[rsp]
  00013	e8 00 00 00 00	 call	 fetch_fw_noswap
  00018	8b c8		 mov	 ecx, eax
  0001a	e8 00 00 00 00	 call	 _byteswap_ulong
  0001f	89 44 24 20	 mov	 DWORD PTR temp$1[rsp], eax
  00023	8b 44 24 20	 mov	 eax, DWORD PTR temp$1[rsp]
  00027	83 e0 0f	 and	 eax, 15
  0002a	89 44 24 24	 mov	 DWORD PTR r2$[rsp], eax
  0002e	8b 44 24 20	 mov	 eax, DWORD PTR temp$1[rsp]
  00032	c1 e8 04	 shr	 eax, 4
  00035	83 e0 0f	 and	 eax, 15
  00038	89 44 24 28	 mov	 DWORD PTR r1$[rsp], eax
  0003c	8b 44 24 20	 mov	 eax, DWORD PTR temp$1[rsp]
  00040	c1 e8 0c	 shr	 eax, 12
  00043	83 e0 0f	 and	 eax, 15
  00046	89 44 24 2c	 mov	 DWORD PTR m3$[rsp], eax
$LN4@z900_extra:
  0004a	48 8b 44 24 48	 mov	 rax, QWORD PTR regs$[rsp]
  0004f	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  00053	48 83 c0 04	 add	 rax, 4
  00057	48 8b 4c 24 48	 mov	 rcx, QWORD PTR regs$[rsp]
  0005c	48 89 41 68	 mov	 QWORD PTR [rcx+104], rax
  00060	33 c0		 xor	 eax, eax
  00062	83 f8 04	 cmp	 eax, 4
  00065	74 0c		 je	 SHORT $LN8@z900_extra
  00067	48 8b 44 24 48	 mov	 rax, QWORD PTR regs$[rsp]
  0006c	c6 80 9a 00 00
	00 04		 mov	 BYTE PTR [rax+154], 4
$LN8@z900_extra:
  00073	33 c0		 xor	 eax, eax
  00075	85 c0		 test	 eax, eax
  00077	75 d1		 jne	 SHORT $LN4@z900_extra
$LN7@z900_extra:

; 2035 :     SIE_INTERCEPT( regs );

  00079	48 8b 44 24 48	 mov	 rax, QWORD PTR regs$[rsp]
  0007e	8b 80 c8 08 00
	00		 mov	 eax, DWORD PTR [rax+2248]
  00084	d1 e8		 shr	 eax, 1
  00086	83 e0 01	 and	 eax, 1
  00089	85 c0		 test	 eax, eax
  0008b	74 18		 je	 SHORT $LN9@z900_extra
  0008d	48 8b 44 24 48	 mov	 rax, QWORD PTR regs$[rsp]
  00092	48 05 80 09 00
	00		 add	 rax, 2432		; 00000980H
  00098	ba fc ff ff ff	 mov	 edx, -4
  0009d	48 8b c8	 mov	 rcx, rax
  000a0	e8 00 00 00 00	 call	 longjmp
$LN9@z900_extra:
  000a5	33 c0		 xor	 eax, eax
  000a7	85 c0		 test	 eax, eax
  000a9	75 ce		 jne	 SHORT $LN7@z900_extra

; 2036 :     ARCH_DEP( program_interrupt )( regs, PGM_OPERATION_EXCEPTION );

  000ab	ba 01 00 00 00	 mov	 edx, 1
  000b0	48 8b 4c 24 48	 mov	 rcx, QWORD PTR regs$[rsp]
  000b5	e8 00 00 00 00	 call	 z900_program_interrupt
$LN10@z900_extra:

; 2037 : }

  000ba	48 83 c4 38	 add	 rsp, 56			; 00000038H
  000be	c3		 ret	 0
z900_extract_and_set_storage_attributes ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\sie.c
_TEXT	SEGMENT
zone$ = 64
temp$1 = 68
b2$ = 72
effective_addr2$ = 80
mso$ = 88
msl$ = 96
eso$ = 104
esl$ = 112
zpb$ = 120
__$ArrayPad$ = 152
inst$ = 176
regs$ = 184
z900_set_zone_parameter PROC

; 1808 : {

$LN30:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 81 ec a8 00
	00 00		 sub	 rsp, 168		; 000000a8H
  00011	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00018	48 33 c4	 xor	 rax, rsp
  0001b	48 89 84 24 98
	00 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 1809 : int     b2;                             /* Values of R fields        */
; 1810 : RADR    effective_addr2;                /* address of state desc.    */
; 1811 : ZPB     zpb;                            /* Zone Parameter Block      */
; 1812 : int     zone;                           /* Zone number               */
; 1813 : RADR    mso,                            /* Main Storage Origin       */
; 1814 :         msl,                            /* Main Storage Length       */
; 1815 :         eso,                            /* Expanded Storage Origin   */
; 1816 :         esl;                            /* Expanded Storage Length   */
; 1817 : 
; 1818 :     S(inst, regs, b2, effective_addr2);

  00023	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR inst$[rsp]
  0002b	e8 00 00 00 00	 call	 fetch_fw_noswap
  00030	8b c8		 mov	 ecx, eax
  00032	e8 00 00 00 00	 call	 _byteswap_ulong
  00037	89 44 24 44	 mov	 DWORD PTR temp$1[rsp], eax
  0003b	8b 44 24 44	 mov	 eax, DWORD PTR temp$1[rsp]
  0003f	25 ff 0f 00 00	 and	 eax, 4095		; 00000fffH
  00044	8b c0		 mov	 eax, eax
  00046	48 89 44 24 50	 mov	 QWORD PTR effective_addr2$[rsp], rax
  0004b	8b 44 24 44	 mov	 eax, DWORD PTR temp$1[rsp]
  0004f	c1 e8 0c	 shr	 eax, 12
  00052	83 e0 0f	 and	 eax, 15
  00055	89 44 24 48	 mov	 DWORD PTR b2$[rsp], eax
  00059	83 7c 24 48 00	 cmp	 DWORD PTR b2$[rsp], 0
  0005e	74 44		 je	 SHORT $LN17@z900_set_z
  00060	48 63 44 24 48	 movsxd	 rax, DWORD PTR b2$[rsp]
  00065	48 8b 8c 24 b8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0006d	48 8b 84 c1 80
	02 00 00	 mov	 rax, QWORD PTR [rcx+rax*8+640]
  00075	48 8b 4c 24 50	 mov	 rcx, QWORD PTR effective_addr2$[rsp]
  0007a	48 03 c8	 add	 rcx, rax
  0007d	48 8b c1	 mov	 rax, rcx
  00080	48 89 44 24 50	 mov	 QWORD PTR effective_addr2$[rsp], rax
  00085	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0008d	48 8b 80 90 00
	00 00		 mov	 rax, QWORD PTR [rax+144]
  00094	48 8b 4c 24 50	 mov	 rcx, QWORD PTR effective_addr2$[rsp]
  00099	48 23 c8	 and	 rcx, rax
  0009c	48 8b c1	 mov	 rax, rcx
  0009f	48 89 44 24 50	 mov	 QWORD PTR effective_addr2$[rsp], rax
$LN17@z900_set_z:
$LN4@z900_set_z:
  000a4	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  000ac	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  000b0	48 83 c0 04	 add	 rax, 4
  000b4	48 8b 8c 24 b8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  000bc	48 89 41 68	 mov	 QWORD PTR [rcx+104], rax
  000c0	33 c0		 xor	 eax, eax
  000c2	83 f8 04	 cmp	 eax, 4
  000c5	74 0f		 je	 SHORT $LN18@z900_set_z
  000c7	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  000cf	c6 80 9a 00 00
	00 04		 mov	 BYTE PTR [rax+154], 4
$LN18@z900_set_z:
  000d6	33 c0		 xor	 eax, eax
  000d8	85 c0		 test	 eax, eax
  000da	75 c8		 jne	 SHORT $LN4@z900_set_z
$LN7@z900_set_z:

; 1819 : 
; 1820 :     TXF_INSTR_CHECK( regs );

  000dc	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  000e4	0f b6 80 58 0e
	00 00		 movzx	 eax, BYTE PTR [rax+3672]
  000eb	85 c0		 test	 eax, eax
  000ed	74 3f		 je	 SHORT $LN19@z900_set_z
  000ef	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  000f7	8b 80 84 af 00
	00		 mov	 eax, DWORD PTR [rax+44932]
  000fd	0f ba e8 0c	 bts	 eax, 12
  00101	48 8b 8c 24 b8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00109	89 81 84 af 00
	00		 mov	 DWORD PTR [rcx+44932], eax
  0010f	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG195884
  00116	41 b8 0b 00 00
	00		 mov	 r8d, 11
  0011c	ba 02 00 00 00	 mov	 edx, 2
  00121	48 8b 8c 24 b8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00129	e8 00 00 00 00	 call	 z900_abort_transaction
$LN19@z900_set_z:
  0012e	33 c0		 xor	 eax, eax
  00130	85 c0		 test	 eax, eax
  00132	75 a8		 jne	 SHORT $LN7@z900_set_z

; 1821 :     PRIV_CHECK(regs);

  00134	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0013c	0f b6 40 7a	 movzx	 eax, BYTE PTR [rax+122]
  00140	83 e0 01	 and	 eax, 1
  00143	85 c0		 test	 eax, eax
  00145	74 1b		 je	 SHORT $LN20@z900_set_z
  00147	ba 02 00 00 00	 mov	 edx, 2
  0014c	48 8b 8c 24 b8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00154	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0015c	ff 90 20 0d 00
	00		 call	 QWORD PTR [rax+3360]
$LN20@z900_set_z:
$LN10@z900_set_z:

; 1822 : 
; 1823 :     SIE_INTERCEPT(regs);

  00162	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0016a	8b 80 c8 08 00
	00		 mov	 eax, DWORD PTR [rax+2248]
  00170	d1 e8		 shr	 eax, 1
  00172	83 e0 01	 and	 eax, 1
  00175	85 c0		 test	 eax, eax
  00177	74 1b		 je	 SHORT $LN21@z900_set_z
  00179	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00181	48 05 80 09 00
	00		 add	 rax, 2432		; 00000980H
  00187	ba fc ff ff ff	 mov	 edx, -4
  0018c	48 8b c8	 mov	 rcx, rax
  0018f	e8 00 00 00 00	 call	 longjmp
$LN21@z900_set_z:
  00194	33 c0		 xor	 eax, eax
  00196	85 c0		 test	 eax, eax
  00198	75 c8		 jne	 SHORT $LN10@z900_set_z
$LN13@z900_set_z:

; 1824 : 
; 1825 :     PTT_IO("SZP", regs->GR_L(1), regs->GR_L(2),regs->psw.IA_L);

  0019a	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_pttclass
  001a1	48 8b 00	 mov	 rax, QWORD PTR [rax]
  001a4	48 25 00 02 00
	00		 and	 rax, 512		; 00000200H
  001aa	48 85 c0	 test	 rax, rax
  001ad	74 71		 je	 SHORT $LN22@z900_set_z
  001af	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  001b7	8b 80 88 00 00
	00		 mov	 eax, DWORD PTR [rax+136]
  001bd	b9 08 00 00 00	 mov	 ecx, 8
  001c2	48 6b c9 02	 imul	 rcx, rcx, 2
  001c6	48 8b 94 24 b8
	00 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  001ce	8b 8c 0a 80 02
	00 00		 mov	 ecx, DWORD PTR [rdx+rcx+640]
  001d5	ba 08 00 00 00	 mov	 edx, 8
  001da	48 6b d2 01	 imul	 rdx, rdx, 1
  001de	4c 8b 84 24 b8
	00 00 00	 mov	 r8, QWORD PTR regs$[rsp]
  001e6	41 8b 94 10 80
	02 00 00	 mov	 edx, DWORD PTR [r8+rdx+640]
  001ee	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR [rsp+48], 0
  001f7	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  001fc	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG195888
  00203	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00208	44 8b c9	 mov	 r9d, ecx
  0020b	44 8b c2	 mov	 r8d, edx
  0020e	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG195889
  00215	b9 00 02 00 00	 mov	 ecx, 512		; 00000200H
  0021a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ptt_pthread_trace
$LN22@z900_set_z:
  00220	33 c0		 xor	 eax, eax
  00222	85 c0		 test	 eax, eax
  00224	0f 85 70 ff ff
	ff		 jne	 $LN13@z900_set_z

; 1826 : 
; 1827 :     FW_CHECK(regs->GR(2), regs);

  0022a	b8 08 00 00 00	 mov	 eax, 8
  0022f	48 6b c0 02	 imul	 rax, rax, 2
  00233	48 8b 8c 24 b8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0023b	48 8b 84 01 80
	02 00 00	 mov	 rax, QWORD PTR [rcx+rax+640]
  00243	48 83 e0 03	 and	 rax, 3
  00247	48 85 c0	 test	 rax, rax
  0024a	74 1b		 je	 SHORT $LN23@z900_set_z
  0024c	ba 06 00 00 00	 mov	 edx, 6
  00251	48 8b 8c 24 b8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00259	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00261	ff 90 20 0d 00
	00		 call	 QWORD PTR [rax+3360]
$LN23@z900_set_z:

; 1828 : 
; 1829 :     zone = regs->GR_LHLCL(1);

  00267	b8 08 00 00 00	 mov	 eax, 8
  0026c	48 6b c0 01	 imul	 rax, rax, 1
  00270	48 8b 8c 24 b8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00278	0f b6 84 01 80
	02 00 00	 movzx	 eax, BYTE PTR [rcx+rax+640]
  00280	89 44 24 40	 mov	 DWORD PTR zone$[rsp], eax

; 1830 : 
; 1831 :     if(zone == 0 || zone >= FEATURE_SIE_MAXZONES)

  00284	83 7c 24 40 00	 cmp	 DWORD PTR zone$[rsp], 0
  00289	74 0b		 je	 SHORT $LN25@z900_set_z
  0028b	83 7c 24 40 08	 cmp	 DWORD PTR zone$[rsp], 8
  00290	0f 8c 9f 00 00
	00		 jl	 $LN24@z900_set_z
$LN25@z900_set_z:
$LN16@z900_set_z:

; 1832 :     {
; 1833 :         PTT_ERR("*SZP", regs->GR_L(1), regs->GR_L(2),regs->psw.IA_L);

  00296	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_pttclass
  0029d	48 8b 00	 mov	 rax, QWORD PTR [rax]
  002a0	48 83 e0 10	 and	 rax, 16
  002a4	48 85 c0	 test	 rax, rax
  002a7	74 71		 je	 SHORT $LN26@z900_set_z
  002a9	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  002b1	8b 80 88 00 00
	00		 mov	 eax, DWORD PTR [rax+136]
  002b7	b9 08 00 00 00	 mov	 ecx, 8
  002bc	48 6b c9 02	 imul	 rcx, rcx, 2
  002c0	48 8b 94 24 b8
	00 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  002c8	8b 8c 0a 80 02
	00 00		 mov	 ecx, DWORD PTR [rdx+rcx+640]
  002cf	ba 08 00 00 00	 mov	 edx, 8
  002d4	48 6b d2 01	 imul	 rdx, rdx, 1
  002d8	4c 8b 84 24 b8
	00 00 00	 mov	 r8, QWORD PTR regs$[rsp]
  002e0	41 8b 94 10 80
	02 00 00	 mov	 edx, DWORD PTR [r8+rdx+640]
  002e8	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR [rsp+48], 0
  002f1	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  002f6	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG195894
  002fd	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00302	44 8b c9	 mov	 r9d, ecx
  00305	44 8b c2	 mov	 r8d, edx
  00308	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG195895
  0030f	b9 10 00 00 00	 mov	 ecx, 16
  00314	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ptt_pthread_trace
$LN26@z900_set_z:
  0031a	33 c0		 xor	 eax, eax
  0031c	85 c0		 test	 eax, eax
  0031e	0f 85 72 ff ff
	ff		 jne	 $LN16@z900_set_z

; 1834 :         regs->psw.cc = 3;

  00324	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0032c	c6 40 7c 03	 mov	 BYTE PTR [rax+124], 3

; 1835 :         return;

  00330	e9 97 01 00 00	 jmp	 $LN1@z900_set_z
$LN24@z900_set_z:

; 1836 :     }
; 1837 : 
; 1838 :     ARCH_DEP(vfetchc(&zpb, sizeof(ZPB)-1,regs->GR(2), 2, regs));

  00335	b8 08 00 00 00	 mov	 eax, 8
  0033a	48 6b c0 02	 imul	 rax, rax, 2
  0033e	48 8b 8c 24 b8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00346	48 89 4c 24 20	 mov	 QWORD PTR [rsp+32], rcx
  0034b	41 b9 02 00 00
	00		 mov	 r9d, 2
  00351	48 8b 8c 24 b8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00359	4c 8b 84 01 80
	02 00 00	 mov	 r8, QWORD PTR [rcx+rax+640]
  00361	b2 1f		 mov	 dl, 31
  00363	48 8d 4c 24 78	 lea	 rcx, QWORD PTR zpb$[rsp]
  00368	e8 00 00 00 00	 call	 z900_vfetchc

; 1839 : 
; 1840 :     FETCH_W(mso,zpb.mso);

  0036d	48 8d 4c 24 78	 lea	 rcx, QWORD PTR zpb$[rsp]
  00372	e8 00 00 00 00	 call	 fetch_dw_noswap
  00377	48 8b c8	 mov	 rcx, rax
  0037a	e8 00 00 00 00	 call	 _byteswap_uint64
  0037f	48 89 44 24 58	 mov	 QWORD PTR mso$[rsp], rax

; 1841 :     FETCH_W(msl,zpb.msl);

  00384	48 8d 8c 24 80
	00 00 00	 lea	 rcx, QWORD PTR zpb$[rsp+8]
  0038c	e8 00 00 00 00	 call	 fetch_dw_noswap
  00391	48 8b c8	 mov	 rcx, rax
  00394	e8 00 00 00 00	 call	 _byteswap_uint64
  00399	48 89 44 24 60	 mov	 QWORD PTR msl$[rsp], rax

; 1842 :     FETCH_W(eso,zpb.eso);

  0039e	48 8d 8c 24 88
	00 00 00	 lea	 rcx, QWORD PTR zpb$[rsp+16]
  003a6	e8 00 00 00 00	 call	 fetch_dw_noswap
  003ab	48 8b c8	 mov	 rcx, rax
  003ae	e8 00 00 00 00	 call	 _byteswap_uint64
  003b3	48 89 44 24 68	 mov	 QWORD PTR eso$[rsp], rax

; 1843 :     FETCH_W(esl,zpb.esl);

  003b8	48 8d 8c 24 90
	00 00 00	 lea	 rcx, QWORD PTR zpb$[rsp+24]
  003c0	e8 00 00 00 00	 call	 fetch_dw_noswap
  003c5	48 8b c8	 mov	 rcx, rax
  003c8	e8 00 00 00 00	 call	 _byteswap_uint64
  003cd	48 89 44 24 70	 mov	 QWORD PTR esl$[rsp], rax

; 1844 : 
; 1845 : #if defined( FEATURE_001_ZARCH_INSTALLED_FACILITY )
; 1846 :     if(  (mso & ~ZPB2_MS_VALID)
; 1847 :       || (msl & ~ZPB2_MS_VALID)
; 1848 :       || (eso & ~ZPB2_ES_VALID)
; 1849 :       || (esl & ~ZPB2_ES_VALID) )

  003d2	48 b8 00 00 00
	00 00 f0 ff ff	 mov	 rax, -17592186044416	; fffff00000000000H
  003dc	48 8b 4c 24 58	 mov	 rcx, QWORD PTR mso$[rsp]
  003e1	48 23 c8	 and	 rcx, rax
  003e4	48 8b c1	 mov	 rax, rcx
  003e7	48 85 c0	 test	 rax, rax
  003ea	75 4e		 jne	 SHORT $LN28@z900_set_z
  003ec	48 b8 00 00 00
	00 00 f0 ff ff	 mov	 rax, -17592186044416	; fffff00000000000H
  003f6	48 8b 4c 24 60	 mov	 rcx, QWORD PTR msl$[rsp]
  003fb	48 23 c8	 and	 rcx, rax
  003fe	48 8b c1	 mov	 rax, rcx
  00401	48 85 c0	 test	 rax, rax
  00404	75 34		 jne	 SHORT $LN28@z900_set_z
  00406	48 b8 00 00 00
	00 00 00 00 ff	 mov	 rax, -72057594037927936	; ff00000000000000H
  00410	48 8b 4c 24 68	 mov	 rcx, QWORD PTR eso$[rsp]
  00415	48 23 c8	 and	 rcx, rax
  00418	48 8b c1	 mov	 rax, rcx
  0041b	48 85 c0	 test	 rax, rax
  0041e	75 1a		 jne	 SHORT $LN28@z900_set_z
  00420	48 b8 00 00 00
	00 00 00 00 ff	 mov	 rax, -72057594037927936	; ff00000000000000H
  0042a	48 8b 4c 24 70	 mov	 rcx, QWORD PTR esl$[rsp]
  0042f	48 23 c8	 and	 rcx, rax
  00432	48 8b c1	 mov	 rax, rcx
  00435	48 85 c0	 test	 rax, rax
  00438	74 12		 je	 SHORT $LN27@z900_set_z
$LN28@z900_set_z:

; 1850 :         ARCH_DEP(program_interrupt) (regs, PGM_OPERAND_EXCEPTION);

  0043a	ba 15 00 00 00	 mov	 edx, 21
  0043f	48 8b 8c 24 b8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00447	e8 00 00 00 00	 call	 z900_program_interrupt
$LN27@z900_set_z:

; 1851 : #endif
; 1852 : 
; 1853 :     sysblk.zpb[zone].mso = mso;

  0044c	48 63 44 24 40	 movsxd	 rax, DWORD PTR zone$[rsp]
  00451	48 6b c0 38	 imul	 rax, rax, 56		; 00000038H
  00455	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  0045c	48 8b 54 24 58	 mov	 rdx, QWORD PTR mso$[rsp]
  00461	48 89 94 01 a0
	0e 00 00	 mov	 QWORD PTR [rcx+rax+3744], rdx

; 1854 :     sysblk.zpb[zone].msl = msl;

  00469	48 63 44 24 40	 movsxd	 rax, DWORD PTR zone$[rsp]
  0046e	48 6b c0 38	 imul	 rax, rax, 56		; 00000038H
  00472	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  00479	48 8b 54 24 60	 mov	 rdx, QWORD PTR msl$[rsp]
  0047e	48 89 94 01 a8
	0e 00 00	 mov	 QWORD PTR [rcx+rax+3752], rdx

; 1855 :     sysblk.zpb[zone].eso = eso;

  00486	48 63 44 24 40	 movsxd	 rax, DWORD PTR zone$[rsp]
  0048b	48 6b c0 38	 imul	 rax, rax, 56		; 00000038H
  0048f	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  00496	48 8b 54 24 68	 mov	 rdx, QWORD PTR eso$[rsp]
  0049b	48 89 94 01 b0
	0e 00 00	 mov	 QWORD PTR [rcx+rax+3760], rdx

; 1856 :     sysblk.zpb[zone].esl = esl;

  004a3	48 63 44 24 40	 movsxd	 rax, DWORD PTR zone$[rsp]
  004a8	48 6b c0 38	 imul	 rax, rax, 56		; 00000038H
  004ac	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  004b3	48 8b 54 24 70	 mov	 rdx, QWORD PTR esl$[rsp]
  004b8	48 89 94 01 b8
	0e 00 00	 mov	 QWORD PTR [rcx+rax+3768], rdx

; 1857 : 
; 1858 :     regs->psw.cc = 0;

  004c0	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  004c8	c6 40 7c 00	 mov	 BYTE PTR [rax+124], 0
$LN1@z900_set_z:
$LN29@z900_set_z:

; 1859 : }

  004cc	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  004d4	48 33 cc	 xor	 rcx, rsp
  004d7	e8 00 00 00 00	 call	 __security_check_cookie
  004dc	48 81 c4 a8 00
	00 00		 add	 rsp, 168		; 000000a8H
  004e3	c3		 ret	 0
z900_set_zone_parameter ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\sie.c
_TEXT	SEGMENT
zone$ = 64
temp$1 = 68
b2$ = 72
effective_addr2$ = 80
zpb$ = 88
__$ArrayPad$ = 120
inst$ = 144
regs$ = 152
z900_store_zone_parameter PROC

; 1767 : {

$LN27:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 81 ec 88 00
	00 00		 sub	 rsp, 136		; 00000088H
  00011	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00018	48 33 c4	 xor	 rax, rsp
  0001b	48 89 44 24 78	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 1768 : int     b2;                             /* Values of R fields        */
; 1769 : RADR    effective_addr2;                /* address of state desc.    */
; 1770 : ZPB     zpb;                            /* Zone Parameter Block      */
; 1771 : int     zone;                           /* Zone number               */
; 1772 : 
; 1773 :     S(inst, regs, b2, effective_addr2);

  00020	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR inst$[rsp]
  00028	e8 00 00 00 00	 call	 fetch_fw_noswap
  0002d	8b c8		 mov	 ecx, eax
  0002f	e8 00 00 00 00	 call	 _byteswap_ulong
  00034	89 44 24 44	 mov	 DWORD PTR temp$1[rsp], eax
  00038	8b 44 24 44	 mov	 eax, DWORD PTR temp$1[rsp]
  0003c	25 ff 0f 00 00	 and	 eax, 4095		; 00000fffH
  00041	8b c0		 mov	 eax, eax
  00043	48 89 44 24 50	 mov	 QWORD PTR effective_addr2$[rsp], rax
  00048	8b 44 24 44	 mov	 eax, DWORD PTR temp$1[rsp]
  0004c	c1 e8 0c	 shr	 eax, 12
  0004f	83 e0 0f	 and	 eax, 15
  00052	89 44 24 48	 mov	 DWORD PTR b2$[rsp], eax
  00056	83 7c 24 48 00	 cmp	 DWORD PTR b2$[rsp], 0
  0005b	74 44		 je	 SHORT $LN17@z900_store
  0005d	48 63 44 24 48	 movsxd	 rax, DWORD PTR b2$[rsp]
  00062	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0006a	48 8b 84 c1 80
	02 00 00	 mov	 rax, QWORD PTR [rcx+rax*8+640]
  00072	48 8b 4c 24 50	 mov	 rcx, QWORD PTR effective_addr2$[rsp]
  00077	48 03 c8	 add	 rcx, rax
  0007a	48 8b c1	 mov	 rax, rcx
  0007d	48 89 44 24 50	 mov	 QWORD PTR effective_addr2$[rsp], rax
  00082	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0008a	48 8b 80 90 00
	00 00		 mov	 rax, QWORD PTR [rax+144]
  00091	48 8b 4c 24 50	 mov	 rcx, QWORD PTR effective_addr2$[rsp]
  00096	48 23 c8	 and	 rcx, rax
  00099	48 8b c1	 mov	 rax, rcx
  0009c	48 89 44 24 50	 mov	 QWORD PTR effective_addr2$[rsp], rax
$LN17@z900_store:
$LN4@z900_store:
  000a1	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  000a9	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  000ad	48 83 c0 04	 add	 rax, 4
  000b1	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  000b9	48 89 41 68	 mov	 QWORD PTR [rcx+104], rax
  000bd	33 c0		 xor	 eax, eax
  000bf	83 f8 04	 cmp	 eax, 4
  000c2	74 0f		 je	 SHORT $LN18@z900_store
  000c4	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  000cc	c6 80 9a 00 00
	00 04		 mov	 BYTE PTR [rax+154], 4
$LN18@z900_store:
  000d3	33 c0		 xor	 eax, eax
  000d5	85 c0		 test	 eax, eax
  000d7	75 c8		 jne	 SHORT $LN4@z900_store
$LN7@z900_store:

; 1774 : 
; 1775 :     TXF_INSTR_CHECK( regs );

  000d9	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  000e1	0f b6 80 58 0e
	00 00		 movzx	 eax, BYTE PTR [rax+3672]
  000e8	85 c0		 test	 eax, eax
  000ea	74 3f		 je	 SHORT $LN19@z900_store
  000ec	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  000f4	8b 80 84 af 00
	00		 mov	 eax, DWORD PTR [rax+44932]
  000fa	0f ba e8 0c	 bts	 eax, 12
  000fe	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00106	89 81 84 af 00
	00		 mov	 DWORD PTR [rcx+44932], eax
  0010c	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG195827
  00113	41 b8 0b 00 00
	00		 mov	 r8d, 11
  00119	ba 02 00 00 00	 mov	 edx, 2
  0011e	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00126	e8 00 00 00 00	 call	 z900_abort_transaction
$LN19@z900_store:
  0012b	33 c0		 xor	 eax, eax
  0012d	85 c0		 test	 eax, eax
  0012f	75 a8		 jne	 SHORT $LN7@z900_store

; 1776 :     PRIV_CHECK(regs);

  00131	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00139	0f b6 40 7a	 movzx	 eax, BYTE PTR [rax+122]
  0013d	83 e0 01	 and	 eax, 1
  00140	85 c0		 test	 eax, eax
  00142	74 1b		 je	 SHORT $LN20@z900_store
  00144	ba 02 00 00 00	 mov	 edx, 2
  00149	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00151	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00159	ff 90 20 0d 00
	00		 call	 QWORD PTR [rax+3360]
$LN20@z900_store:
$LN10@z900_store:

; 1777 : 
; 1778 :     SIE_INTERCEPT(regs);

  0015f	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00167	8b 80 c8 08 00
	00		 mov	 eax, DWORD PTR [rax+2248]
  0016d	d1 e8		 shr	 eax, 1
  0016f	83 e0 01	 and	 eax, 1
  00172	85 c0		 test	 eax, eax
  00174	74 1b		 je	 SHORT $LN21@z900_store
  00176	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0017e	48 05 80 09 00
	00		 add	 rax, 2432		; 00000980H
  00184	ba fc ff ff ff	 mov	 edx, -4
  00189	48 8b c8	 mov	 rcx, rax
  0018c	e8 00 00 00 00	 call	 longjmp
$LN21@z900_store:
  00191	33 c0		 xor	 eax, eax
  00193	85 c0		 test	 eax, eax
  00195	75 c8		 jne	 SHORT $LN10@z900_store
$LN13@z900_store:

; 1779 : 
; 1780 :     PTT_IO("STZP", regs->GR_L(1), regs->GR_L(2),regs->psw.IA_L);

  00197	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_pttclass
  0019e	48 8b 00	 mov	 rax, QWORD PTR [rax]
  001a1	48 25 00 02 00
	00		 and	 rax, 512		; 00000200H
  001a7	48 85 c0	 test	 rax, rax
  001aa	74 71		 je	 SHORT $LN22@z900_store
  001ac	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  001b4	8b 80 88 00 00
	00		 mov	 eax, DWORD PTR [rax+136]
  001ba	b9 08 00 00 00	 mov	 ecx, 8
  001bf	48 6b c9 02	 imul	 rcx, rcx, 2
  001c3	48 8b 94 24 98
	00 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  001cb	8b 8c 0a 80 02
	00 00		 mov	 ecx, DWORD PTR [rdx+rcx+640]
  001d2	ba 08 00 00 00	 mov	 edx, 8
  001d7	48 6b d2 01	 imul	 rdx, rdx, 1
  001db	4c 8b 84 24 98
	00 00 00	 mov	 r8, QWORD PTR regs$[rsp]
  001e3	41 8b 94 10 80
	02 00 00	 mov	 edx, DWORD PTR [r8+rdx+640]
  001eb	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR [rsp+48], 0
  001f4	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  001f9	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG195831
  00200	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00205	44 8b c9	 mov	 r9d, ecx
  00208	44 8b c2	 mov	 r8d, edx
  0020b	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG195832
  00212	b9 00 02 00 00	 mov	 ecx, 512		; 00000200H
  00217	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ptt_pthread_trace
$LN22@z900_store:
  0021d	33 c0		 xor	 eax, eax
  0021f	85 c0		 test	 eax, eax
  00221	0f 85 70 ff ff
	ff		 jne	 $LN13@z900_store

; 1781 : 
; 1782 :     FW_CHECK(regs->GR(2), regs);

  00227	b8 08 00 00 00	 mov	 eax, 8
  0022c	48 6b c0 02	 imul	 rax, rax, 2
  00230	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00238	48 8b 84 01 80
	02 00 00	 mov	 rax, QWORD PTR [rcx+rax+640]
  00240	48 83 e0 03	 and	 rax, 3
  00244	48 85 c0	 test	 rax, rax
  00247	74 1b		 je	 SHORT $LN23@z900_store
  00249	ba 06 00 00 00	 mov	 edx, 6
  0024e	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00256	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0025e	ff 90 20 0d 00
	00		 call	 QWORD PTR [rax+3360]
$LN23@z900_store:

; 1783 : 
; 1784 :     zone = regs->GR_LHLCL(1);

  00264	b8 08 00 00 00	 mov	 eax, 8
  00269	48 6b c0 01	 imul	 rax, rax, 1
  0026d	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00275	0f b6 84 01 80
	02 00 00	 movzx	 eax, BYTE PTR [rcx+rax+640]
  0027d	89 44 24 40	 mov	 DWORD PTR zone$[rsp], eax

; 1785 : 
; 1786 :     if(zone >= FEATURE_SIE_MAXZONES)

  00281	83 7c 24 40 08	 cmp	 DWORD PTR zone$[rsp], 8
  00286	0f 8c 9f 00 00
	00		 jl	 $LN24@z900_store
$LN16@z900_store:

; 1787 :     {
; 1788 :         PTT_ERR("*STZP", regs->GR_L(1), regs->GR_L(2),regs->psw.IA_L);

  0028c	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_pttclass
  00293	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00296	48 83 e0 10	 and	 rax, 16
  0029a	48 85 c0	 test	 rax, rax
  0029d	74 71		 je	 SHORT $LN25@z900_store
  0029f	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  002a7	8b 80 88 00 00
	00		 mov	 eax, DWORD PTR [rax+136]
  002ad	b9 08 00 00 00	 mov	 ecx, 8
  002b2	48 6b c9 02	 imul	 rcx, rcx, 2
  002b6	48 8b 94 24 98
	00 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  002be	8b 8c 0a 80 02
	00 00		 mov	 ecx, DWORD PTR [rdx+rcx+640]
  002c5	ba 08 00 00 00	 mov	 edx, 8
  002ca	48 6b d2 01	 imul	 rdx, rdx, 1
  002ce	4c 8b 84 24 98
	00 00 00	 mov	 r8, QWORD PTR regs$[rsp]
  002d6	41 8b 94 10 80
	02 00 00	 mov	 edx, DWORD PTR [r8+rdx+640]
  002de	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR [rsp+48], 0
  002e7	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  002ec	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG195836
  002f3	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  002f8	44 8b c9	 mov	 r9d, ecx
  002fb	44 8b c2	 mov	 r8d, edx
  002fe	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG195837
  00305	b9 10 00 00 00	 mov	 ecx, 16
  0030a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ptt_pthread_trace
$LN25@z900_store:
  00310	33 c0		 xor	 eax, eax
  00312	85 c0		 test	 eax, eax
  00314	0f 85 72 ff ff
	ff		 jne	 $LN16@z900_store

; 1789 :         regs->psw.cc = 3;

  0031a	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00322	c6 40 7c 03	 mov	 BYTE PTR [rax+124], 3

; 1790 :         return;

  00326	e9 ec 00 00 00	 jmp	 $LN1@z900_store
$LN24@z900_store:

; 1791 :     }
; 1792 : 
; 1793 :     STORE_W(zpb.mso,sysblk.zpb[zone].mso);

  0032b	48 63 44 24 40	 movsxd	 rax, DWORD PTR zone$[rsp]
  00330	48 6b c0 38	 imul	 rax, rax, 56		; 00000038H
  00334	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  0033b	48 8b 8c 01 a0
	0e 00 00	 mov	 rcx, QWORD PTR [rcx+rax+3744]
  00343	e8 00 00 00 00	 call	 _byteswap_uint64
  00348	48 8b d0	 mov	 rdx, rax
  0034b	48 8d 4c 24 58	 lea	 rcx, QWORD PTR zpb$[rsp]
  00350	e8 00 00 00 00	 call	 store_dw_noswap

; 1794 :     STORE_W(zpb.msl,sysblk.zpb[zone].msl);

  00355	48 63 44 24 40	 movsxd	 rax, DWORD PTR zone$[rsp]
  0035a	48 6b c0 38	 imul	 rax, rax, 56		; 00000038H
  0035e	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  00365	48 8b 8c 01 a8
	0e 00 00	 mov	 rcx, QWORD PTR [rcx+rax+3752]
  0036d	e8 00 00 00 00	 call	 _byteswap_uint64
  00372	48 8b d0	 mov	 rdx, rax
  00375	48 8d 4c 24 60	 lea	 rcx, QWORD PTR zpb$[rsp+8]
  0037a	e8 00 00 00 00	 call	 store_dw_noswap

; 1795 :     STORE_W(zpb.eso,sysblk.zpb[zone].eso);

  0037f	48 63 44 24 40	 movsxd	 rax, DWORD PTR zone$[rsp]
  00384	48 6b c0 38	 imul	 rax, rax, 56		; 00000038H
  00388	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  0038f	48 8b 8c 01 b0
	0e 00 00	 mov	 rcx, QWORD PTR [rcx+rax+3760]
  00397	e8 00 00 00 00	 call	 _byteswap_uint64
  0039c	48 8b d0	 mov	 rdx, rax
  0039f	48 8d 4c 24 68	 lea	 rcx, QWORD PTR zpb$[rsp+16]
  003a4	e8 00 00 00 00	 call	 store_dw_noswap

; 1796 :     STORE_W(zpb.esl,sysblk.zpb[zone].esl);

  003a9	48 63 44 24 40	 movsxd	 rax, DWORD PTR zone$[rsp]
  003ae	48 6b c0 38	 imul	 rax, rax, 56		; 00000038H
  003b2	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  003b9	48 8b 8c 01 b8
	0e 00 00	 mov	 rcx, QWORD PTR [rcx+rax+3768]
  003c1	e8 00 00 00 00	 call	 _byteswap_uint64
  003c6	48 8b d0	 mov	 rdx, rax
  003c9	48 8d 4c 24 70	 lea	 rcx, QWORD PTR zpb$[rsp+24]
  003ce	e8 00 00 00 00	 call	 store_dw_noswap

; 1797 : 
; 1798 :     ARCH_DEP(vstorec(&zpb, sizeof(ZPB)-1,regs->GR(2), 2, regs));

  003d3	b8 08 00 00 00	 mov	 eax, 8
  003d8	48 6b c0 02	 imul	 rax, rax, 2
  003dc	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  003e4	48 89 4c 24 20	 mov	 QWORD PTR [rsp+32], rcx
  003e9	41 b9 02 00 00
	00		 mov	 r9d, 2
  003ef	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  003f7	4c 8b 84 01 80
	02 00 00	 mov	 r8, QWORD PTR [rcx+rax+640]
  003ff	b2 1f		 mov	 dl, 31
  00401	48 8d 4c 24 58	 lea	 rcx, QWORD PTR zpb$[rsp]
  00406	e8 00 00 00 00	 call	 z900_vstorec

; 1799 : 
; 1800 :     regs->psw.cc = 0;

  0040b	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00413	c6 40 7c 00	 mov	 BYTE PTR [rax+124], 0
$LN1@z900_store:
$LN26@z900_store:

; 1801 : }

  00417	48 8b 4c 24 78	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  0041c	48 33 cc	 xor	 rcx, rsp
  0041f	e8 00 00 00 00	 call	 __security_check_cookie
  00424	48 81 c4 88 00
	00 00		 add	 rsp, 136		; 00000088H
  0042b	c3		 ret	 0
z900_store_zone_parameter ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\sie.c
_TEXT	SEGMENT
effective_addr2$ = 64
temp$1 = 72
b2$ = 76
zone$ = 80
ioid$ = 84
ioparm$ = 88
iointid$ = 92
tpziid$ = 96
__$ArrayPad$ = 112
inst$ = 144
regs$ = 152
z900_test_pending_zone_interrupt PROC

; 1868 : {

$LN34:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 81 ec 88 00
	00 00		 sub	 rsp, 136		; 00000088H
  00011	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00018	48 33 c4	 xor	 rax, rsp
  0001b	48 89 44 24 70	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 1869 : int     b2;                             /* Values of R fields        */
; 1870 : RADR    effective_addr2;                /* address of state desc.    */
; 1871 : U32     ioid;                           /* I/O interruption address  */
; 1872 : U32     ioparm;                         /* I/O interruption parameter*/
; 1873 : U32     iointid;                        /* I/O interruption ident    */
; 1874 : FWORD   tpziid[3];
; 1875 : int     zone;                           /* Zone number               */
; 1876 : 
; 1877 :     S(inst, regs, b2, effective_addr2);

  00020	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR inst$[rsp]
  00028	e8 00 00 00 00	 call	 fetch_fw_noswap
  0002d	8b c8		 mov	 ecx, eax
  0002f	e8 00 00 00 00	 call	 _byteswap_ulong
  00034	89 44 24 48	 mov	 DWORD PTR temp$1[rsp], eax
  00038	8b 44 24 48	 mov	 eax, DWORD PTR temp$1[rsp]
  0003c	25 ff 0f 00 00	 and	 eax, 4095		; 00000fffH
  00041	8b c0		 mov	 eax, eax
  00043	48 89 44 24 40	 mov	 QWORD PTR effective_addr2$[rsp], rax
  00048	8b 44 24 48	 mov	 eax, DWORD PTR temp$1[rsp]
  0004c	c1 e8 0c	 shr	 eax, 12
  0004f	83 e0 0f	 and	 eax, 15
  00052	89 44 24 4c	 mov	 DWORD PTR b2$[rsp], eax
  00056	83 7c 24 4c 00	 cmp	 DWORD PTR b2$[rsp], 0
  0005b	74 44		 je	 SHORT $LN20@z900_test_
  0005d	48 63 44 24 4c	 movsxd	 rax, DWORD PTR b2$[rsp]
  00062	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0006a	48 8b 84 c1 80
	02 00 00	 mov	 rax, QWORD PTR [rcx+rax*8+640]
  00072	48 8b 4c 24 40	 mov	 rcx, QWORD PTR effective_addr2$[rsp]
  00077	48 03 c8	 add	 rcx, rax
  0007a	48 8b c1	 mov	 rax, rcx
  0007d	48 89 44 24 40	 mov	 QWORD PTR effective_addr2$[rsp], rax
  00082	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0008a	48 8b 80 90 00
	00 00		 mov	 rax, QWORD PTR [rax+144]
  00091	48 8b 4c 24 40	 mov	 rcx, QWORD PTR effective_addr2$[rsp]
  00096	48 23 c8	 and	 rcx, rax
  00099	48 8b c1	 mov	 rax, rcx
  0009c	48 89 44 24 40	 mov	 QWORD PTR effective_addr2$[rsp], rax
$LN20@z900_test_:
$LN4@z900_test_:
  000a1	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  000a9	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  000ad	48 83 c0 04	 add	 rax, 4
  000b1	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  000b9	48 89 41 68	 mov	 QWORD PTR [rcx+104], rax
  000bd	33 c0		 xor	 eax, eax
  000bf	83 f8 04	 cmp	 eax, 4
  000c2	74 0f		 je	 SHORT $LN21@z900_test_
  000c4	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  000cc	c6 80 9a 00 00
	00 04		 mov	 BYTE PTR [rax+154], 4
$LN21@z900_test_:
  000d3	33 c0		 xor	 eax, eax
  000d5	85 c0		 test	 eax, eax
  000d7	75 c8		 jne	 SHORT $LN4@z900_test_
$LN7@z900_test_:

; 1878 : 
; 1879 :     TXF_INSTR_CHECK( regs );

  000d9	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  000e1	0f b6 80 58 0e
	00 00		 movzx	 eax, BYTE PTR [rax+3672]
  000e8	85 c0		 test	 eax, eax
  000ea	74 3f		 je	 SHORT $LN22@z900_test_
  000ec	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  000f4	8b 80 84 af 00
	00		 mov	 eax, DWORD PTR [rax+44932]
  000fa	0f ba e8 0c	 bts	 eax, 12
  000fe	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00106	89 81 84 af 00
	00		 mov	 DWORD PTR [rcx+44932], eax
  0010c	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG195948
  00113	41 b8 0b 00 00
	00		 mov	 r8d, 11
  00119	ba 02 00 00 00	 mov	 edx, 2
  0011e	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00126	e8 00 00 00 00	 call	 z900_abort_transaction
$LN22@z900_test_:
  0012b	33 c0		 xor	 eax, eax
  0012d	85 c0		 test	 eax, eax
  0012f	75 a8		 jne	 SHORT $LN7@z900_test_

; 1880 :     PRIV_CHECK(regs);

  00131	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00139	0f b6 40 7a	 movzx	 eax, BYTE PTR [rax+122]
  0013d	83 e0 01	 and	 eax, 1
  00140	85 c0		 test	 eax, eax
  00142	74 1b		 je	 SHORT $LN23@z900_test_
  00144	ba 02 00 00 00	 mov	 edx, 2
  00149	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00151	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00159	ff 90 20 0d 00
	00		 call	 QWORD PTR [rax+3360]
$LN23@z900_test_:
$LN10@z900_test_:

; 1881 : 
; 1882 :     SIE_INTERCEPT(regs);

  0015f	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00167	8b 80 c8 08 00
	00		 mov	 eax, DWORD PTR [rax+2248]
  0016d	d1 e8		 shr	 eax, 1
  0016f	83 e0 01	 and	 eax, 1
  00172	85 c0		 test	 eax, eax
  00174	74 1b		 je	 SHORT $LN24@z900_test_
  00176	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0017e	48 05 80 09 00
	00		 add	 rax, 2432		; 00000980H
  00184	ba fc ff ff ff	 mov	 edx, -4
  00189	48 8b c8	 mov	 rcx, rax
  0018c	e8 00 00 00 00	 call	 longjmp
$LN24@z900_test_:
  00191	33 c0		 xor	 eax, eax
  00193	85 c0		 test	 eax, eax
  00195	75 c8		 jne	 SHORT $LN10@z900_test_
$LN13@z900_test_:

; 1883 : 
; 1884 :     PTT_IO("TPZI", regs->GR_L(1),(U32)(effective_addr2 & 0xffffffff),regs->psw.IA_L);

  00197	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_pttclass
  0019e	48 8b 00	 mov	 rax, QWORD PTR [rax]
  001a1	48 25 00 02 00
	00		 and	 rax, 512		; 00000200H
  001a7	48 85 c0	 test	 rax, rax
  001aa	74 6b		 je	 SHORT $LN25@z900_test_
  001ac	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  001b4	8b 80 88 00 00
	00		 mov	 eax, DWORD PTR [rax+136]
  001ba	b9 ff ff ff ff	 mov	 ecx, -1			; ffffffffH
  001bf	48 8b 54 24 40	 mov	 rdx, QWORD PTR effective_addr2$[rsp]
  001c4	48 23 d1	 and	 rdx, rcx
  001c7	48 8b ca	 mov	 rcx, rdx
  001ca	8b c9		 mov	 ecx, ecx
  001cc	ba 08 00 00 00	 mov	 edx, 8
  001d1	48 6b d2 01	 imul	 rdx, rdx, 1
  001d5	4c 8b 84 24 98
	00 00 00	 mov	 r8, QWORD PTR regs$[rsp]
  001dd	41 8b 94 10 80
	02 00 00	 mov	 edx, DWORD PTR [r8+rdx+640]
  001e5	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR [rsp+48], 0
  001ee	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  001f3	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG195952
  001fa	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  001ff	44 8b c9	 mov	 r9d, ecx
  00202	44 8b c2	 mov	 r8d, edx
  00205	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG195953
  0020c	b9 00 02 00 00	 mov	 ecx, 512		; 00000200H
  00211	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ptt_pthread_trace
$LN25@z900_test_:
  00217	33 c0		 xor	 eax, eax
  00219	85 c0		 test	 eax, eax
  0021b	0f 85 76 ff ff
	ff		 jne	 $LN13@z900_test_

; 1885 : 
; 1886 :     FW_CHECK(regs->GR(2), regs);

  00221	b8 08 00 00 00	 mov	 eax, 8
  00226	48 6b c0 02	 imul	 rax, rax, 2
  0022a	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00232	48 8b 84 01 80
	02 00 00	 mov	 rax, QWORD PTR [rcx+rax+640]
  0023a	48 83 e0 03	 and	 rax, 3
  0023e	48 85 c0	 test	 rax, rax
  00241	74 1b		 je	 SHORT $LN26@z900_test_
  00243	ba 06 00 00 00	 mov	 edx, 6
  00248	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00250	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00258	ff 90 20 0d 00
	00		 call	 QWORD PTR [rax+3360]
$LN26@z900_test_:

; 1887 : 
; 1888 :     /* Perform serialization and checkpoint-synchronization */
; 1889 :     PERFORM_SERIALIZATION (regs);

  0025e	0f ae f0	 mfence
$LN16@z900_test_:

; 1890 :     PERFORM_CHKPT_SYNC (regs);

  00261	33 c0		 xor	 eax, eax
  00263	85 c0		 test	 eax, eax
  00265	75 fa		 jne	 SHORT $LN16@z900_test_

; 1891 : 
; 1892 :     zone = regs->GR_LHLCL(1);

  00267	b8 08 00 00 00	 mov	 eax, 8
  0026c	48 6b c0 01	 imul	 rax, rax, 1
  00270	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00278	0f b6 84 01 80
	02 00 00	 movzx	 eax, BYTE PTR [rcx+rax+640]
  00280	89 44 24 50	 mov	 DWORD PTR zone$[rsp], eax

; 1893 : 
; 1894 :     if(zone >= FEATURE_SIE_MAXZONES)

  00284	83 7c 24 50 08	 cmp	 DWORD PTR zone$[rsp], 8
  00289	0f 8c 99 00 00
	00		 jl	 $LN27@z900_test_
$LN19@z900_test_:

; 1895 :     {
; 1896 :         PTT_ERR("*TPZI", regs->GR_L(1),(U32)(effective_addr2 & 0xffffffff),regs->psw.IA_L);

  0028f	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_pttclass
  00296	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00299	48 83 e0 10	 and	 rax, 16
  0029d	48 85 c0	 test	 rax, rax
  002a0	74 6b		 je	 SHORT $LN28@z900_test_
  002a2	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  002aa	8b 80 88 00 00
	00		 mov	 eax, DWORD PTR [rax+136]
  002b0	b9 ff ff ff ff	 mov	 ecx, -1			; ffffffffH
  002b5	48 8b 54 24 40	 mov	 rdx, QWORD PTR effective_addr2$[rsp]
  002ba	48 23 d1	 and	 rdx, rcx
  002bd	48 8b ca	 mov	 rcx, rdx
  002c0	8b c9		 mov	 ecx, ecx
  002c2	ba 08 00 00 00	 mov	 edx, 8
  002c7	48 6b d2 01	 imul	 rdx, rdx, 1
  002cb	4c 8b 84 24 98
	00 00 00	 mov	 r8, QWORD PTR regs$[rsp]
  002d3	41 8b 94 10 80
	02 00 00	 mov	 edx, DWORD PTR [r8+rdx+640]
  002db	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR [rsp+48], 0
  002e4	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  002e9	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG195957
  002f0	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  002f5	44 8b c9	 mov	 r9d, ecx
  002f8	44 8b c2	 mov	 r8d, edx
  002fb	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG195958
  00302	b9 10 00 00 00	 mov	 ecx, 16
  00307	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ptt_pthread_trace
$LN28@z900_test_:
  0030d	33 c0		 xor	 eax, eax
  0030f	85 c0		 test	 eax, eax
  00311	0f 85 78 ff ff
	ff		 jne	 $LN19@z900_test_

; 1897 :         regs->psw.cc = 0;

  00317	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0031f	c6 40 7c 00	 mov	 BYTE PTR [rax+124], 0

; 1898 :         return;

  00323	e9 32 01 00 00	 jmp	 $LN1@z900_test_
$LN27@z900_test_:

; 1899 :     }
; 1900 : 
; 1901 :     if( IS_IC_IOPENDING )

  00328	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  0032f	8b 80 a0 12 00
	00		 mov	 eax, DWORD PTR [rax+4768]
  00335	25 00 00 00 40	 and	 eax, 1073741824		; 40000000H
  0033a	85 c0		 test	 eax, eax
  0033c	0f 84 0c 01 00
	00		 je	 $LN29@z900_test_

; 1902 :     {
; 1903 :         /* Obtain the interrupt lock */
; 1904 :         OBTAIN_INTLOCK(regs);

  00342	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG195961
  00349	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00351	e8 00 00 00 00	 call	 Obtain_Interrupt_Lock

; 1905 : 
; 1906 :         /* Test (but don't clear!) pending interrupt, and set condition code */
; 1907 :         if( ARCH_DEP(present_zone_io_interrupt) (&ioid, &ioparm,

  00356	44 0f b6 4c 24
	50		 movzx	 r9d, BYTE PTR zone$[rsp]
  0035c	4c 8d 44 24 5c	 lea	 r8, QWORD PTR iointid$[rsp]
  00361	48 8d 54 24 58	 lea	 rdx, QWORD PTR ioparm$[rsp]
  00366	48 8d 4c 24 54	 lea	 rcx, QWORD PTR ioid$[rsp]
  0036b	e8 00 00 00 00	 call	 z900_present_zone_io_interrupt
  00370	85 c0		 test	 eax, eax
  00372	0f 84 b4 00 00
	00		 je	 $LN31@z900_test_

; 1908 :                                                        &iointid, zone) )
; 1909 : 
; 1910 :         /* Store the SSID word and I/O parameter if an interrupt was pending */
; 1911 :         {
; 1912 :             /* Store interruption parms */
; 1913 :             STORE_FW(tpziid[0],ioid);

  00378	8b 4c 24 54	 mov	 ecx, DWORD PTR ioid$[rsp]
  0037c	e8 00 00 00 00	 call	 _byteswap_ulong
  00381	b9 04 00 00 00	 mov	 ecx, 4
  00386	48 6b c9 00	 imul	 rcx, rcx, 0
  0038a	48 8d 4c 0c 60	 lea	 rcx, QWORD PTR tpziid$[rsp+rcx]
  0038f	8b d0		 mov	 edx, eax
  00391	e8 00 00 00 00	 call	 store_fw_noswap

; 1914 :             STORE_FW(tpziid[1],ioparm);

  00396	8b 4c 24 58	 mov	 ecx, DWORD PTR ioparm$[rsp]
  0039a	e8 00 00 00 00	 call	 _byteswap_ulong
  0039f	b9 04 00 00 00	 mov	 ecx, 4
  003a4	48 6b c9 01	 imul	 rcx, rcx, 1
  003a8	48 8d 4c 0c 60	 lea	 rcx, QWORD PTR tpziid$[rsp+rcx]
  003ad	8b d0		 mov	 edx, eax
  003af	e8 00 00 00 00	 call	 store_fw_noswap

; 1915 :             STORE_FW(tpziid[2],iointid);

  003b4	8b 4c 24 5c	 mov	 ecx, DWORD PTR iointid$[rsp]
  003b8	e8 00 00 00 00	 call	 _byteswap_ulong
  003bd	b9 04 00 00 00	 mov	 ecx, 4
  003c2	48 6b c9 02	 imul	 rcx, rcx, 2
  003c6	48 8d 4c 0c 60	 lea	 rcx, QWORD PTR tpziid$[rsp+rcx]
  003cb	8b d0		 mov	 edx, eax
  003cd	e8 00 00 00 00	 call	 store_fw_noswap

; 1916 : 
; 1917 :             /* Release the interrupt lock */
; 1918 :             RELEASE_INTLOCK(regs);

  003d2	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG195964
  003d9	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  003e1	e8 00 00 00 00	 call	 Release_Interrupt_Lock

; 1919 : 
; 1920 :             ARCH_DEP(vstorec(&tpziid, sizeof(tpziid)-1,regs->GR(2), 2, regs));

  003e6	b8 08 00 00 00	 mov	 eax, 8
  003eb	48 6b c0 02	 imul	 rax, rax, 2
  003ef	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  003f7	48 89 4c 24 20	 mov	 QWORD PTR [rsp+32], rcx
  003fc	41 b9 02 00 00
	00		 mov	 r9d, 2
  00402	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0040a	4c 8b 84 01 80
	02 00 00	 mov	 r8, QWORD PTR [rcx+rax+640]
  00412	b2 0b		 mov	 dl, 11
  00414	48 8d 4c 24 60	 lea	 rcx, QWORD PTR tpziid$[rsp]
  00419	e8 00 00 00 00	 call	 z900_vstorec

; 1921 : 
; 1922 :             regs->psw.cc = 1;

  0041e	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00426	c6 40 7c 01	 mov	 BYTE PTR [rax+124], 1

; 1923 :         }

  0042a	eb 20		 jmp	 SHORT $LN32@z900_test_
$LN31@z900_test_:

; 1924 :         else
; 1925 :         {
; 1926 :             /* Release the interrupt lock */
; 1927 :             RELEASE_INTLOCK(regs);

  0042c	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG195965
  00433	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0043b	e8 00 00 00 00	 call	 Release_Interrupt_Lock

; 1928 :             regs->psw.cc = 0;

  00440	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00448	c6 40 7c 00	 mov	 BYTE PTR [rax+124], 0
$LN32@z900_test_:

; 1929 :         }
; 1930 : 
; 1931 :     }

  0044c	eb 0c		 jmp	 SHORT $LN30@z900_test_
$LN29@z900_test_:

; 1932 :     else
; 1933 :         regs->psw.cc = 0;

  0044e	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00456	c6 40 7c 00	 mov	 BYTE PTR [rax+124], 0
$LN30@z900_test_:
$LN1@z900_test_:
$LN33@z900_test_:

; 1934 : }

  0045a	48 8b 4c 24 70	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  0045f	48 33 cc	 xor	 rcx, rsp
  00462	e8 00 00 00 00	 call	 __security_check_cookie
  00467	48 81 c4 88 00
	00 00		 add	 rsp, 136		; 00000088H
  0046e	c3		 ret	 0
z900_test_pending_zone_interrupt ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\sie.c
_TEXT	SEGMENT
icode$ = 96
effective_addr2$ = 104
n$ = 112
fld$ = 116
lpsw_xcode$ = 120
same_cpu$ = 124
same_state$ = 125
lhcpu$ = 128
b2$ = 132
tv1056 = 136
mso$1 = 144
temp$2 = 152
tv302 = 156
tv1035 = 160
tv1037 = 164
tv1040 = 168
tv1042 = 172
msl$3 = 176
tv235 = 184
sie_scaoh$4 = 188
tv225 = 192
eso$5 = 200
esl$6 = 208
tv229 = 216
tv237 = 224
dreg$ = 232
sie_state$ = 240
p$7 = 248
tv1448 = 256
inst$ = 304
regs$ = 312
z900_start_interpretive_execution PROC

; 308  : {

$LN171:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	56		 push	 rsi
  0000b	57		 push	 rdi
  0000c	48 81 ec 18 01
	00 00		 sub	 rsp, 280		; 00000118H

; 309  : int     b2;                             /* Values of R fields        */
; 310  : RADR    effective_addr2;                /* address of state desc.    */
; 311  : int     n;                              /* Loop counter              */
; 312  : U16     lhcpu;                          /* Last Host CPU address     */
; 313  : U64     sie_state;                      /* Last SIE state            */
; 314  : int lpsw_xcode;                         /* xcode from load_psw       */
; 315  : volatile int icode = 0;                 /* interrupt code            */

  00013	c7 44 24 60 00
	00 00 00	 mov	 DWORD PTR icode$[rsp], 0

; 316  :                                         /* (why is this volatile?!)  */
; 317  : bool    same_cpu, same_state;           /* boolean helper flags      */
; 318  : U64     dreg;
; 319  : 
; 320  : #if defined( FEATURE_VIRTUAL_ARCHITECTURE_LEVEL )
; 321  : U32     fld;                            /* Facility List Designator  */
; 322  : #if !defined( OPTION_SIE2BK_FLD_COPY)
; 323  : int     i;                              /* (work)                    */
; 324  : #endif
; 325  : #endif
; 326  : 
; 327  :     //-----------------------------------------------------------
; 328  :     //             IMPORTANT SIE PROGRAMMING NOTE!
; 329  :     //-----------------------------------------------------------
; 330  :     // NOTE: Our execution architectural mode is that of the SIE
; 331  :     // HOST and our 'regs' variable is pointing the the HOST's
; 332  :     // registers. Since the GUEST could be running in a completely
; 333  :     // different architecture from the HOST, if you need to call
; 334  :     // a ARCH_DEP function for the GUEST (passing it GUESTREGS),
; 335  :     // you must TAKE SPECIAL CARE to ensure the correct version
; 336  :     // of that function is called! You cannot simply call the
; 337  :     // "ARCH_DEP" version of that function as they are for the
; 338  :     // architectue of the HOST, not the GUEST! (i.e. you cannot
; 339  :     // call a "z900_xxx" function expecting it to work correctly
; 340  :     // if the GUEST is supposed to call "s390_xxx" functions!)
; 341  :     //-----------------------------------------------------------
; 342  : 
; 343  :     S( inst, regs, b2, effective_addr2 );

  0001b	48 8b 8c 24 30
	01 00 00	 mov	 rcx, QWORD PTR inst$[rsp]
  00023	e8 00 00 00 00	 call	 fetch_fw_noswap
  00028	8b c8		 mov	 ecx, eax
  0002a	e8 00 00 00 00	 call	 _byteswap_ulong
  0002f	89 84 24 98 00
	00 00		 mov	 DWORD PTR temp$2[rsp], eax
  00036	8b 84 24 98 00
	00 00		 mov	 eax, DWORD PTR temp$2[rsp]
  0003d	25 ff 0f 00 00	 and	 eax, 4095		; 00000fffH
  00042	8b c0		 mov	 eax, eax
  00044	48 89 44 24 68	 mov	 QWORD PTR effective_addr2$[rsp], rax
  00049	8b 84 24 98 00
	00 00		 mov	 eax, DWORD PTR temp$2[rsp]
  00050	c1 e8 0c	 shr	 eax, 12
  00053	83 e0 0f	 and	 eax, 15
  00056	89 84 24 84 00
	00 00		 mov	 DWORD PTR b2$[rsp], eax
  0005d	83 bc 24 84 00
	00 00 00	 cmp	 DWORD PTR b2$[rsp], 0
  00065	74 47		 je	 SHORT $LN100@z900_start
  00067	48 63 84 24 84
	00 00 00	 movsxd	 rax, DWORD PTR b2$[rsp]
  0006f	48 8b 8c 24 38
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00077	48 8b 84 c1 80
	02 00 00	 mov	 rax, QWORD PTR [rcx+rax*8+640]
  0007f	48 8b 4c 24 68	 mov	 rcx, QWORD PTR effective_addr2$[rsp]
  00084	48 03 c8	 add	 rcx, rax
  00087	48 8b c1	 mov	 rax, rcx
  0008a	48 89 44 24 68	 mov	 QWORD PTR effective_addr2$[rsp], rax
  0008f	48 8b 84 24 38
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00097	48 8b 80 90 00
	00 00		 mov	 rax, QWORD PTR [rax+144]
  0009e	48 8b 4c 24 68	 mov	 rcx, QWORD PTR effective_addr2$[rsp]
  000a3	48 23 c8	 and	 rcx, rax
  000a6	48 8b c1	 mov	 rax, rcx
  000a9	48 89 44 24 68	 mov	 QWORD PTR effective_addr2$[rsp], rax
$LN100@z900_start:
$LN4@z900_start:
  000ae	48 8b 84 24 38
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  000b6	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  000ba	48 83 c0 04	 add	 rax, 4
  000be	48 8b 8c 24 38
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  000c6	48 89 41 68	 mov	 QWORD PTR [rcx+104], rax
  000ca	33 c0		 xor	 eax, eax
  000cc	83 f8 04	 cmp	 eax, 4
  000cf	74 0f		 je	 SHORT $LN101@z900_start
  000d1	48 8b 84 24 38
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  000d9	c6 80 9a 00 00
	00 04		 mov	 BYTE PTR [rax+154], 4
$LN101@z900_start:
  000e0	33 c0		 xor	 eax, eax
  000e2	85 c0		 test	 eax, eax
  000e4	75 c8		 jne	 SHORT $LN4@z900_start

; 344  :     PER_ZEROADDR_XCHECK( regs, b2 );

  000e6	8b 94 24 84 00
	00 00		 mov	 edx, DWORD PTR b2$[rsp]
  000ed	48 8b 8c 24 38
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  000f5	e8 00 00 00 00	 call	 z900_per3_zero_xcheck
$LN7@z900_start:

; 345  : 
; 346  :     TXF_INSTR_CHECK( regs );

  000fa	48 8b 84 24 38
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00102	0f b6 80 58 0e
	00 00		 movzx	 eax, BYTE PTR [rax+3672]
  00109	85 c0		 test	 eax, eax
  0010b	74 3f		 je	 SHORT $LN102@z900_start
  0010d	48 8b 84 24 38
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00115	8b 80 84 af 00
	00		 mov	 eax, DWORD PTR [rax+44932]
  0011b	0f ba e8 0c	 bts	 eax, 12
  0011f	48 8b 8c 24 38
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00127	89 81 84 af 00
	00		 mov	 DWORD PTR [rcx+44932], eax
  0012d	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG194852
  00134	41 b8 0b 00 00
	00		 mov	 r8d, 11
  0013a	ba 02 00 00 00	 mov	 edx, 2
  0013f	48 8b 8c 24 38
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00147	e8 00 00 00 00	 call	 z900_abort_transaction
$LN102@z900_start:
  0014c	33 c0		 xor	 eax, eax
  0014e	85 c0		 test	 eax, eax
  00150	75 a8		 jne	 SHORT $LN7@z900_start

; 347  :     PRIV_CHECK( regs );

  00152	48 8b 84 24 38
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0015a	0f b6 40 7a	 movzx	 eax, BYTE PTR [rax+122]
  0015e	83 e0 01	 and	 eax, 1
  00161	85 c0		 test	 eax, eax
  00163	74 1b		 je	 SHORT $LN103@z900_start
  00165	ba 02 00 00 00	 mov	 edx, 2
  0016a	48 8b 8c 24 38
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00172	48 8b 84 24 38
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0017a	ff 90 20 0d 00
	00		 call	 QWORD PTR [rax+3360]
$LN103@z900_start:
$LN10@z900_start:

; 348  : 
; 349  :     SIE_INTERCEPT( regs );

  00180	48 8b 84 24 38
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00188	8b 80 c8 08 00
	00		 mov	 eax, DWORD PTR [rax+2248]
  0018e	d1 e8		 shr	 eax, 1
  00190	83 e0 01	 and	 eax, 1
  00193	85 c0		 test	 eax, eax
  00195	74 1b		 je	 SHORT $LN104@z900_start
  00197	48 8b 84 24 38
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0019f	48 05 80 09 00
	00		 add	 rax, 2432		; 00000980H
  001a5	ba fc ff ff ff	 mov	 edx, -4
  001aa	48 8b c8	 mov	 rcx, rax
  001ad	e8 00 00 00 00	 call	 longjmp
$LN104@z900_start:
  001b2	33 c0		 xor	 eax, eax
  001b4	85 c0		 test	 eax, eax
  001b6	75 c8		 jne	 SHORT $LN10@z900_start
$LN13@z900_start:

; 350  : 
; 351  :     PTT_SIE( "SIE", regs->GR(14), regs->GR(15), effective_addr2);

  001b8	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_pttclass
  001bf	48 8b 00	 mov	 rax, QWORD PTR [rax]
  001c2	48 25 80 00 00
	00		 and	 rax, 128		; 00000080H
  001c8	48 85 c0	 test	 rax, rax
  001cb	74 63		 je	 SHORT $LN105@z900_start
  001cd	b8 08 00 00 00	 mov	 eax, 8
  001d2	48 6b c0 0f	 imul	 rax, rax, 15
  001d6	b9 08 00 00 00	 mov	 ecx, 8
  001db	48 6b c9 0e	 imul	 rcx, rcx, 14
  001df	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR [rsp+48], 0
  001e8	48 8b 54 24 68	 mov	 rdx, QWORD PTR effective_addr2$[rsp]
  001ed	48 89 54 24 28	 mov	 QWORD PTR [rsp+40], rdx
  001f2	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG194856
  001f9	48 89 54 24 20	 mov	 QWORD PTR [rsp+32], rdx
  001fe	48 8b 94 24 38
	01 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  00206	4c 8b 8c 02 80
	02 00 00	 mov	 r9, QWORD PTR [rdx+rax+640]
  0020e	48 8b 84 24 38
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00216	4c 8b 84 08 80
	02 00 00	 mov	 r8, QWORD PTR [rax+rcx+640]
  0021e	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG194857
  00225	b9 80 00 00 00	 mov	 ecx, 128		; 00000080H
  0022a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ptt_pthread_trace
$LN105@z900_start:
  00230	33 c0		 xor	 eax, eax
  00232	85 c0		 test	 eax, eax
  00234	75 82		 jne	 SHORT $LN13@z900_start

; 352  : 
; 353  :     SIE_PERFMON( SIE_PERF_ENTER );
; 354  : 
; 355  : #if !defined( FEATURE_001_ZARCH_INSTALLED_FACILITY ) && !defined( FEATURE_MULTIPLE_CONTROLLED_DATA_SPACE )
; 356  :     if (!regs->psw.amode || !PRIMARY_SPACE_MODE( &regs->psw ))
; 357  :         ARCH_DEP( program_interrupt )( regs, PGM_SPECIAL_OPERATION_EXCEPTION );
; 358  : #endif
; 359  : 
; 360  :     if (0
; 361  :         || (effective_addr2 & (sizeof(SIEBK)-1)) != 0
; 362  : 
; 363  : #if defined( FEATURE_001_ZARCH_INSTALLED_FACILITY )
; 364  : 
; 365  :         || (effective_addr2 & PREFIXING_900_MASK) == 0
; 366  :         || (effective_addr2 & PREFIXING_900_MASK) == regs->PX_900

  00236	33 c0		 xor	 eax, eax
  00238	85 c0		 test	 eax, eax
  0023a	75 39		 jne	 SHORT $LN107@z900_start
  0023c	48 8b 44 24 68	 mov	 rax, QWORD PTR effective_addr2$[rsp]
  00241	48 25 ff 01 00
	00		 and	 rax, 511		; 000001ffH
  00247	48 85 c0	 test	 rax, rax
  0024a	75 29		 jne	 SHORT $LN107@z900_start
  0024c	48 8b 44 24 68	 mov	 rax, QWORD PTR effective_addr2$[rsp]
  00251	48 25 00 e0 ff
	ff		 and	 rax, -8192		; ffffffffffffe000H
  00257	48 85 c0	 test	 rax, rax
  0025a	74 19		 je	 SHORT $LN107@z900_start
  0025c	48 8b 44 24 68	 mov	 rax, QWORD PTR effective_addr2$[rsp]
  00261	48 25 00 e0 ff
	ff		 and	 rax, -8192		; ffffffffffffe000H
  00267	48 8b 8c 24 38
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0026f	48 3b 41 70	 cmp	 rax, QWORD PTR [rcx+112]
  00273	75 12		 jne	 SHORT $LN106@z900_start
$LN107@z900_start:

; 367  : 
; 368  : #elif defined( FEATURE_S390_DAT )
; 369  :         || (effective_addr2 & PREFIXING_390_MASK) == 0
; 370  :         || (effective_addr2 & PREFIXING_390_MASK) == regs->PX_390
; 371  : #else
; 372  :         || (effective_addr2 & PREFIXING_370_MASK) == 0
; 373  :         || (effective_addr2 & PREFIXING_370_MASK) == regs->PX_370
; 374  : #endif
; 375  :     )
; 376  :         ARCH_DEP( program_interrupt )( regs, PGM_SPECIFICATION_EXCEPTION );

  00275	ba 06 00 00 00	 mov	 edx, 6
  0027a	48 8b 8c 24 38
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00282	e8 00 00 00 00	 call	 z900_program_interrupt
$LN106@z900_start:

; 377  : 
; 378  :     /* Perform serialization and checkpoint synchronization */
; 379  :     PERFORM_SERIALIZATION( regs );

  00287	0f ae f0	 mfence
$LN16@z900_start:

; 380  :     PERFORM_CHKPT_SYNC( regs );

  0028a	33 c0		 xor	 eax, eax
  0028c	85 c0		 test	 eax, eax
  0028e	75 fa		 jne	 SHORT $LN16@z900_start

; 381  : 
; 382  : #if defined( SIE_DEBUG )
; 383  :     LOGMSG( "SIE: state descriptor " F_RADR "\n", effective_addr2 );
; 384  :     ARCH_DEP( display_inst )( regs, regs->instinvalid ? NULL : regs->ip );
; 385  : #endif
; 386  : 
; 387  :     if (effective_addr2 > regs->mainlim - (sizeof( SIEBK ) - 1))

  00290	48 8b 84 24 38
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00298	48 8b 80 58 08
	00 00		 mov	 rax, QWORD PTR [rax+2136]
  0029f	48 2d ff 01 00
	00		 sub	 rax, 511		; 000001ffH
  002a5	48 39 44 24 68	 cmp	 QWORD PTR effective_addr2$[rsp], rax
  002aa	76 12		 jbe	 SHORT $LN108@z900_start

; 388  :         ARCH_DEP( program_interrupt )( regs, PGM_ADDRESSING_EXCEPTION );

  002ac	ba 05 00 00 00	 mov	 edx, 5
  002b1	48 8b 8c 24 38
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  002b9	e8 00 00 00 00	 call	 z900_program_interrupt
$LN108@z900_start:
$LN19@z900_start:

; 389  : 
; 390  :     /*
; 391  :      * As long as regs->sie_active is off, no serialization is
; 392  :      * required for GUESTREGS.  sie_active should always be off here.
; 393  :      * Any other thread looking at sie_active holds the intlock.
; 394  :      */
; 395  :     PTT_SIE( "SIE h,g,a", regs->host, regs->guest, regs->sie_active );

  002be	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_pttclass
  002c5	48 8b 00	 mov	 rax, QWORD PTR [rax]
  002c8	48 25 80 00 00
	00		 and	 rax, 128		; 00000080H
  002ce	48 85 c0	 test	 rax, rax
  002d1	74 71		 je	 SHORT $LN109@z900_start
  002d3	48 8b 84 24 38
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  002db	8b 80 c8 08 00
	00		 mov	 eax, DWORD PTR [rax+2248]
  002e1	83 e0 01	 and	 eax, 1
  002e4	8b c0		 mov	 eax, eax
  002e6	48 8b 8c 24 38
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  002ee	8b 89 28 07 00
	00		 mov	 ecx, DWORD PTR [rcx+1832]
  002f4	c1 e9 08	 shr	 ecx, 8
  002f7	83 e1 01	 and	 ecx, 1
  002fa	8b c9		 mov	 ecx, ecx
  002fc	48 8b 94 24 38
	01 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  00304	8b 92 28 07 00
	00		 mov	 edx, DWORD PTR [rdx+1832]
  0030a	c1 ea 07	 shr	 edx, 7
  0030d	83 e2 01	 and	 edx, 1
  00310	8b d2		 mov	 edx, edx
  00312	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR [rsp+48], 0
  0031b	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  00320	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG194862
  00327	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  0032c	44 8b c9	 mov	 r9d, ecx
  0032f	44 8b c2	 mov	 r8d, edx
  00332	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG194863
  00339	b9 80 00 00 00	 mov	 ecx, 128		; 00000080H
  0033e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ptt_pthread_trace
$LN109@z900_start:
  00344	33 c0		 xor	 eax, eax
  00346	85 c0		 test	 eax, eax
  00348	0f 85 70 ff ff
	ff		 jne	 $LN19@z900_start

; 396  :     if (regs->sie_active)

  0034e	48 8b 84 24 38
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00356	8b 80 c8 08 00
	00		 mov	 eax, DWORD PTR [rax+2248]
  0035c	83 e0 01	 and	 eax, 1
  0035f	85 c0		 test	 eax, eax
  00361	74 47		 je	 SHORT $LN110@z900_start

; 397  :     {
; 398  :         OBTAIN_INTLOCK( regs );

  00363	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG194865
  0036a	48 8b 8c 24 38
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00372	e8 00 00 00 00	 call	 Obtain_Interrupt_Lock

; 399  :         {
; 400  :             regs->sie_active = 0;

  00377	48 8b 84 24 38
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0037f	8b 80 c8 08 00
	00		 mov	 eax, DWORD PTR [rax+2248]
  00385	83 e0 fe	 and	 eax, -2			; fffffffeH
  00388	48 8b 8c 24 38
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00390	89 81 c8 08 00
	00		 mov	 DWORD PTR [rcx+2248], eax

; 401  :         }
; 402  :         RELEASE_INTLOCK( regs );

  00396	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG194866
  0039d	48 8b 8c 24 38
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  003a5	e8 00 00 00 00	 call	 Release_Interrupt_Lock
$LN110@z900_start:

; 403  :     }
; 404  : 
; 405  :     /* Initialize guestregs if first time */
; 406  :     if (!GUESTREGS)

  003aa	48 8b 84 24 38
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  003b2	48 83 b8 70 08
	00 00 00	 cmp	 QWORD PTR [rax+2160], 0
  003ba	0f 85 a5 01 00
	00		 jne	 $LN111@z900_start
$LN22@z900_start:

; 407  :     {
; 408  :         PTT_SIE( "SIE calloc g", 0, 0, 0 );

  003c0	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_pttclass
  003c7	48 8b 00	 mov	 rax, QWORD PTR [rax]
  003ca	48 25 80 00 00
	00		 and	 rax, 128		; 00000080H
  003d0	48 85 c0	 test	 rax, rax
  003d3	74 36		 je	 SHORT $LN112@z900_start
  003d5	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR [rsp+48], 0
  003de	48 c7 44 24 28
	00 00 00 00	 mov	 QWORD PTR [rsp+40], 0
  003e7	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG194869
  003ee	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  003f3	45 33 c9	 xor	 r9d, r9d
  003f6	45 33 c0	 xor	 r8d, r8d
  003f9	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG194870
  00400	b9 80 00 00 00	 mov	 ecx, 128		; 00000080H
  00405	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ptt_pthread_trace
$LN112@z900_start:
  0040b	33 c0		 xor	 eax, eax
  0040d	85 c0		 test	 eax, eax
  0040f	75 af		 jne	 SHORT $LN22@z900_start

; 409  :         if (!(GUESTREGS = calloc_aligned( sizeof( REGS ), 4096 )))

  00411	ba 00 10 00 00	 mov	 edx, 4096		; 00001000H
  00416	b9 80 60 01 00	 mov	 ecx, 90240		; 00016080H
  0041b	e8 00 00 00 00	 call	 calloc_aligned
  00420	48 89 84 24 c0
	00 00 00	 mov	 QWORD PTR tv225[rsp], rax
  00428	48 8b 84 24 38
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00430	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR tv225[rsp]
  00438	48 89 88 70 08
	00 00		 mov	 QWORD PTR [rax+2160], rcx
  0043f	48 83 bc 24 c0
	00 00 00 00	 cmp	 QWORD PTR tv225[rsp], 0
  00448	0f 85 d6 00 00
	00		 jne	 $LN113@z900_start

; 410  :         {
; 411  :             // "Processor %s%02X: error in function %s: %s"
; 412  :             WRMSG( HHC00813, "E", PTYPSTR( regs->cpuad ), regs->cpuad, "calloc()", strerror( errno ));

  0044e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno
  00454	8b 08		 mov	 ecx, DWORD PTR [rax]
  00456	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_strerror
  0045c	48 89 84 24 d8
	00 00 00	 mov	 QWORD PTR tv229[rsp], rax
  00464	48 8b 8c 24 38
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0046c	0f b7 89 3c 08
	00 00		 movzx	 ecx, WORD PTR [rcx+2108]
  00473	89 8c 24 b8 00
	00 00		 mov	 DWORD PTR tv235[rsp], ecx
  0047a	48 8b 94 24 38
	01 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  00482	0f b7 92 3c 08
	00 00		 movzx	 edx, WORD PTR [rdx+2108]
  00489	4c 8b 05 00 00
	00 00		 mov	 r8, QWORD PTR __imp_sysblk
  00490	41 0f b6 8c 10
	48 0b 00 00	 movzx	 ecx, BYTE PTR [r8+rdx+2888]
  00499	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ptyp2short
  0049f	48 89 84 24 e0
	00 00 00	 mov	 QWORD PTR tv237[rsp], rax
  004a7	b9 01 00 00 00	 mov	 ecx, 1
  004ac	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  004b2	48 8b 8c 24 d8
	00 00 00	 mov	 rcx, QWORD PTR tv229[rsp]
  004ba	48 89 4c 24 50	 mov	 QWORD PTR [rsp+80], rcx
  004bf	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG194872
  004c6	48 89 4c 24 48	 mov	 QWORD PTR [rsp+72], rcx
  004cb	8b 8c 24 b8 00
	00 00		 mov	 ecx, DWORD PTR tv235[rsp]
  004d2	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  004d6	48 8b 8c 24 e0
	00 00 00	 mov	 rcx, QWORD PTR tv237[rsp]
  004de	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  004e3	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG194873
  004ea	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  004ef	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG194874
  004f6	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  004fb	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00500	41 b9 03 00 00
	00		 mov	 r9d, 3
  00506	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG194875
  0050d	ba 9c 01 00 00	 mov	 edx, 412		; 0000019cH
  00512	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG194876
  00519	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 413  :             return;

  0051f	e9 48 22 00 00	 jmp	 $LN1@z900_start
$LN113@z900_start:

; 414  :         }
; 415  :         cpu_init( regs->cpuad, GUESTREGS, regs );

  00524	48 8b 84 24 38
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0052c	0f b7 80 3c 08
	00 00		 movzx	 eax, WORD PTR [rax+2108]
  00533	4c 8b 84 24 38
	01 00 00	 mov	 r8, QWORD PTR regs$[rsp]
  0053b	48 8b 8c 24 38
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00543	48 8b 91 70 08
	00 00		 mov	 rdx, QWORD PTR [rcx+2160]
  0054a	8b c8		 mov	 ecx, eax
  0054c	e8 00 00 00 00	 call	 cpu_init

; 416  :         TXF_ALLOCMAP( GUESTREGS );

  00551	48 8b 84 24 38
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00559	48 8b 88 70 08
	00 00		 mov	 rcx, QWORD PTR [rax+2160]
  00560	e8 00 00 00 00	 call	 alloc_txfmap
$LN111@z900_start:

; 417  :     }
; 418  : 
; 419  :     /* Direct pointer to state descriptor block */
; 420  :     GUESTREGS->siebk = (void*)(regs->mainstor + effective_addr2);

  00565	48 8b 84 24 38
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0056d	48 8b 80 48 08
	00 00		 mov	 rax, QWORD PTR [rax+2120]
  00574	48 03 44 24 68	 add	 rax, QWORD PTR effective_addr2$[rsp]
  00579	48 8b 8c 24 38
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00581	48 8b 89 70 08
	00 00		 mov	 rcx, QWORD PTR [rcx+2160]
  00588	48 89 81 88 08
	00 00		 mov	 QWORD PTR [rcx+2184], rax

; 421  : 
; 422  :     /* Set the guest's execution arch_mode and load its PSW */
; 423  : #if defined( FEATURE_001_ZARCH_INSTALLED_FACILITY )
; 424  :     if (STATEBK->mx & SIE_MX_ESAME)

  0058f	48 8b 84 24 38
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00597	48 8b 80 70 08
	00 00		 mov	 rax, QWORD PTR [rax+2160]
  0059e	48 8b 80 88 08
	00 00		 mov	 rax, QWORD PTR [rax+2184]
  005a5	0f b6 40 02	 movzx	 eax, BYTE PTR [rax+2]
  005a9	83 e0 08	 and	 eax, 8
  005ac	85 c0		 test	 eax, eax
  005ae	74 6c		 je	 SHORT $LN114@z900_start

; 425  :     {
; 426  :         GUESTREGS->arch_mode = ARCH_900_IDX;

  005b0	48 8b 84 24 38
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  005b8	48 8b 80 70 08
	00 00		 mov	 rax, QWORD PTR [rax+2160]
  005bf	c7 40 64 02 00
	00 00		 mov	 DWORD PTR [rax+100], 2

; 427  :         GUESTREGS->program_interrupt = &z900_program_interrupt;

  005c6	48 8b 84 24 38
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  005ce	48 8b 80 70 08
	00 00		 mov	 rax, QWORD PTR [rax+2160]
  005d5	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:z900_program_interrupt
  005dc	48 89 88 20 0d
	00 00		 mov	 QWORD PTR [rax+3360], rcx

; 428  :         lpsw_xcode = z900_load_psw( GUESTREGS, STATEBK->psw );

  005e3	48 8b 84 24 38
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  005eb	48 8b 80 70 08
	00 00		 mov	 rax, QWORD PTR [rax+2160]
  005f2	48 8b 80 88 08
	00 00		 mov	 rax, QWORD PTR [rax+2184]
  005f9	48 05 90 00 00
	00		 add	 rax, 144		; 00000090H
  005ff	48 8b d0	 mov	 rdx, rax
  00602	48 8b 84 24 38
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0060a	48 8b 88 70 08
	00 00		 mov	 rcx, QWORD PTR [rax+2160]
  00611	e8 00 00 00 00	 call	 z900_load_psw
  00616	89 44 24 78	 mov	 DWORD PTR lpsw_xcode$[rsp], eax

; 429  :     }

  0061a	eb 6a		 jmp	 SHORT $LN115@z900_start
$LN114@z900_start:

; 430  : #else /* !defined( FEATURE_001_ZARCH_INSTALLED_FACILITY ) */
; 431  :     if (STATEBK->m & SIE_M_370)
; 432  :     {
; 433  : #if defined(_370)
; 434  :         GUESTREGS->arch_mode = ARCH_370_IDX;
; 435  :         GUESTREGS->program_interrupt = &s370_program_interrupt;
; 436  :         lpsw_xcode = s370_load_psw(GUESTREGS, STATEBK->psw);
; 437  : #else
; 438  :         /* Validity intercept when 370 mode not installed */
; 439  :         SIE_SET_VI(SIE_VI_WHO_CPU, SIE_VI_WHEN_SIENT, SIE_VI_WHY_370NI, GUESTREGS);
; 440  :         STATEBK->c = SIE_C_VALIDITY;
; 441  :         return;
; 442  : #endif
; 443  :     }
; 444  : #endif /* !defined( FEATURE_001_ZARCH_INSTALLED_FACILITY ) */
; 445  :     else
; 446  : #if !defined( FEATURE_001_ZARCH_INSTALLED_FACILITY )
; 447  :     if (STATEBK->m & SIE_M_XA)
; 448  : #endif
; 449  :     {
; 450  :         GUESTREGS->arch_mode = ARCH_390_IDX;

  0061c	48 8b 84 24 38
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00624	48 8b 80 70 08
	00 00		 mov	 rax, QWORD PTR [rax+2160]
  0062b	c7 40 64 01 00
	00 00		 mov	 DWORD PTR [rax+100], 1

; 451  :         GUESTREGS->program_interrupt = &s390_program_interrupt;

  00632	48 8b 84 24 38
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0063a	48 8b 80 70 08
	00 00		 mov	 rax, QWORD PTR [rax+2160]
  00641	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:s390_program_interrupt
  00648	48 89 88 20 0d
	00 00		 mov	 QWORD PTR [rax+3360], rcx

; 452  :         lpsw_xcode = s390_load_psw(GUESTREGS, STATEBK->psw);

  0064f	48 8b 84 24 38
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00657	48 8b 80 70 08
	00 00		 mov	 rax, QWORD PTR [rax+2160]
  0065e	48 8b 80 88 08
	00 00		 mov	 rax, QWORD PTR [rax+2184]
  00665	48 05 90 00 00
	00		 add	 rax, 144		; 00000090H
  0066b	48 8b d0	 mov	 rdx, rax
  0066e	48 8b 84 24 38
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00676	48 8b 88 70 08
	00 00		 mov	 rcx, QWORD PTR [rax+2160]
  0067d	e8 00 00 00 00	 call	 s390_load_psw
  00682	89 44 24 78	 mov	 DWORD PTR lpsw_xcode$[rsp], eax
$LN115@z900_start:

; 453  :     }
; 454  : #if !defined( FEATURE_001_ZARCH_INSTALLED_FACILITY )
; 455  :     else
; 456  :     {
; 457  :         /* Validity intercept for invalid mode */
; 458  :         SIE_SET_VI( SIE_VI_WHO_CPU, SIE_VI_WHEN_SIENT, SIE_VI_WHY_MODE, GUESTREGS );
; 459  :         STATEBK->c = SIE_C_VALIDITY;
; 460  :         return;
; 461  :     }
; 462  : #endif
; 463  : 
; 464  :     /* Prefered guest indication */
; 465  :     GUESTREGS->sie_pref = (STATEBK->m & SIE_M_VR) ? 1 : 0;

  00686	48 8b 84 24 38
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0068e	48 8b 80 70 08
	00 00		 mov	 rax, QWORD PTR [rax+2160]
  00695	48 8b 80 88 08
	00 00		 mov	 rax, QWORD PTR [rax+2184]
  0069c	0f b6 40 03	 movzx	 eax, BYTE PTR [rax+3]
  006a0	83 e0 08	 and	 eax, 8
  006a3	85 c0		 test	 eax, eax
  006a5	74 0d		 je	 SHORT $LN161@z900_start
  006a7	c7 84 24 9c 00
	00 00 01 00 00
	00		 mov	 DWORD PTR tv302[rsp], 1
  006b2	eb 0b		 jmp	 SHORT $LN162@z900_start
$LN161@z900_start:
  006b4	c7 84 24 9c 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv302[rsp], 0
$LN162@z900_start:
  006bf	48 8b 84 24 38
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  006c7	48 8b 80 70 08
	00 00		 mov	 rax, QWORD PTR [rax+2160]
  006ce	8b 8c 24 9c 00
	00 00		 mov	 ecx, DWORD PTR tv302[rsp]
  006d5	83 e1 01	 and	 ecx, 1
  006d8	c1 e1 02	 shl	 ecx, 2
  006db	8b 80 c8 08 00
	00		 mov	 eax, DWORD PTR [rax+2248]
  006e1	83 e0 fb	 and	 eax, -5			; fffffffbH
  006e4	0b c1		 or	 eax, ecx
  006e6	48 8b 8c 24 38
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  006ee	48 8b 89 70 08
	00 00		 mov	 rcx, QWORD PTR [rcx+2160]
  006f5	89 81 c8 08 00
	00		 mov	 DWORD PTR [rcx+2248], eax

; 466  : 
; 467  :     /* Load prefix from state descriptor... (Using 'PX_L' is okay
; 468  :        since prefix is always a FWORD regardless of architecture) */
; 469  :     FETCH_FW( GUESTREGS->PX_L, STATEBK->prefix );

  006fb	48 8b 84 24 38
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00703	48 8b 80 70 08
	00 00		 mov	 rax, QWORD PTR [rax+2160]
  0070a	48 8b 80 88 08
	00 00		 mov	 rax, QWORD PTR [rax+2184]
  00711	48 83 c0 04	 add	 rax, 4
  00715	48 8b c8	 mov	 rcx, rax
  00718	e8 00 00 00 00	 call	 fetch_fw_noswap
  0071d	8b c8		 mov	 ecx, eax
  0071f	e8 00 00 00 00	 call	 _byteswap_ulong
  00724	48 8b 8c 24 38
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0072c	48 8b 89 70 08
	00 00		 mov	 rcx, QWORD PTR [rcx+2160]
  00733	89 41 70	 mov	 DWORD PTR [rcx+112], eax

; 470  : 
; 471  : #if defined( FEATURE_REGION_RELOCATE )
; 472  : 
; 473  :     if (STATEBK->mx & SIE_MX_RRF)

  00736	48 8b 84 24 38
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0073e	48 8b 80 70 08
	00 00		 mov	 rax, QWORD PTR [rax+2160]
  00745	48 8b 80 88 08
	00 00		 mov	 rax, QWORD PTR [rax+2184]
  0074c	0f b6 40 02	 movzx	 eax, BYTE PTR [rax+2]
  00750	25 80 00 00 00	 and	 eax, 128		; 00000080H
  00755	85 c0		 test	 eax, eax
  00757	0f 84 88 04 00
	00		 je	 $LN116@z900_start

; 474  :     {
; 475  :         RADR mso, msl, eso = 0, esl = 0;

  0075d	48 c7 84 24 c8
	00 00 00 00 00
	00 00		 mov	 QWORD PTR eso$5[rsp], 0
  00769	48 c7 84 24 d0
	00 00 00 00 00
	00 00		 mov	 QWORD PTR esl$6[rsp], 0

; 476  : 
; 477  :         if (STATEBK->zone >= FEATURE_SIE_MAXZONES)

  00775	48 8b 84 24 38
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0077d	48 8b 80 70 08
	00 00		 mov	 rax, QWORD PTR [rax+2160]
  00784	48 8b 80 88 08
	00 00		 mov	 rax, QWORD PTR [rax+2184]
  0078b	0f b6 40 74	 movzx	 eax, BYTE PTR [rax+116]
  0078f	83 f8 08	 cmp	 eax, 8
  00792	0f 8c c2 00 00
	00		 jl	 $LN118@z900_start
$LN25@z900_start:

; 478  :         {
; 479  :             /* Validity intercept for invalid zone */
; 480  :             SIE_SET_VI( SIE_VI_WHO_CPU, SIE_VI_WHEN_SIENT, SIE_VI_WHY_AZNNI, GUESTREGS );

  00798	48 8b 84 24 38
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  007a0	48 8b 80 70 08
	00 00		 mov	 rax, QWORD PTR [rax+2160]
  007a7	48 8b 80 88 08
	00 00		 mov	 rax, QWORD PTR [rax+2184]
  007ae	b9 01 00 00 00	 mov	 ecx, 1
  007b3	48 6b c9 00	 imul	 rcx, rcx, 0
  007b7	c6 44 08 56 01	 mov	 BYTE PTR [rax+rcx+86], 1
  007bc	48 8b 84 24 38
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  007c4	48 8b 80 70 08
	00 00		 mov	 rax, QWORD PTR [rax+2160]
  007cb	48 8b 80 88 08
	00 00		 mov	 rax, QWORD PTR [rax+2184]
  007d2	b9 01 00 00 00	 mov	 ecx, 1
  007d7	48 6b c9 01	 imul	 rcx, rcx, 1
  007db	c6 44 08 56 10	 mov	 BYTE PTR [rax+rcx+86], 16
  007e0	66 b9 05 10	 mov	 cx, 4101		; 00001005H
  007e4	e8 00 00 00 00	 call	 _byteswap_ushort
  007e9	48 8b 8c 24 38
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  007f1	48 8b 89 70 08
	00 00		 mov	 rcx, QWORD PTR [rcx+2160]
  007f8	48 8b 89 88 08
	00 00		 mov	 rcx, QWORD PTR [rcx+2184]
  007ff	48 83 c1 58	 add	 rcx, 88			; 00000058H
  00803	0f b7 d0	 movzx	 edx, ax
  00806	e8 00 00 00 00	 call	 store_hw_noswap
  0080b	48 8b 84 24 38
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00813	48 8b 80 70 08
	00 00		 mov	 rax, QWORD PTR [rax+2160]
  0081a	48 8b 80 88 08
	00 00		 mov	 rax, QWORD PTR [rax+2184]
  00821	48 83 c0 5a	 add	 rax, 90			; 0000005aH
  00825	48 8b f8	 mov	 rdi, rax
  00828	33 c0		 xor	 eax, eax
  0082a	b9 06 00 00 00	 mov	 ecx, 6
  0082f	f3 aa		 rep stosb
  00831	33 c0		 xor	 eax, eax
  00833	85 c0		 test	 eax, eax
  00835	0f 85 5d ff ff
	ff		 jne	 $LN25@z900_start

; 481  :             STATEBK->c = SIE_C_VALIDITY;

  0083b	48 8b 84 24 38
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00843	48 8b 80 70 08
	00 00		 mov	 rax, QWORD PTR [rax+2160]
  0084a	48 8b 80 88 08
	00 00		 mov	 rax, QWORD PTR [rax+2184]
  00851	c6 40 50 20	 mov	 BYTE PTR [rax+80], 32	; 00000020H

; 482  :             return;

  00855	e9 12 1f 00 00	 jmp	 $LN1@z900_start
$LN118@z900_start:

; 483  :         }
; 484  : 
; 485  :         mso = (sysblk.zpb[ STATEBK->zone ].mso & 0xFFFFF) << 20;

  0085a	48 8b 84 24 38
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00862	48 8b 80 70 08
	00 00		 mov	 rax, QWORD PTR [rax+2160]
  00869	48 8b 80 88 08
	00 00		 mov	 rax, QWORD PTR [rax+2184]
  00870	0f b6 40 74	 movzx	 eax, BYTE PTR [rax+116]
  00874	48 6b c0 38	 imul	 rax, rax, 56		; 00000038H
  00878	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  0087f	48 8b 84 01 a0
	0e 00 00	 mov	 rax, QWORD PTR [rcx+rax+3744]
  00887	48 25 ff ff 0f
	00		 and	 rax, 1048575		; 000fffffH
  0088d	48 c1 e0 14	 shl	 rax, 20
  00891	48 89 84 24 90
	00 00 00	 mov	 QWORD PTR mso$1[rsp], rax

; 486  :         msl = (sysblk.zpb[ STATEBK->zone ].msl & 0xFFFFF) << 20;

  00899	48 8b 84 24 38
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  008a1	48 8b 80 70 08
	00 00		 mov	 rax, QWORD PTR [rax+2160]
  008a8	48 8b 80 88 08
	00 00		 mov	 rax, QWORD PTR [rax+2184]
  008af	0f b6 40 74	 movzx	 eax, BYTE PTR [rax+116]
  008b3	48 6b c0 38	 imul	 rax, rax, 56		; 00000038H
  008b7	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  008be	48 8b 84 01 a8
	0e 00 00	 mov	 rax, QWORD PTR [rcx+rax+3752]
  008c6	48 25 ff ff 0f
	00		 and	 rax, 1048575		; 000fffffH
  008cc	48 c1 e0 14	 shl	 rax, 20
  008d0	48 89 84 24 b0
	00 00 00	 mov	 QWORD PTR msl$3[rsp], rax

; 487  :         eso = (sysblk.zpb[ STATEBK->zone ].eso & 0xFFFFF) << 20;

  008d8	48 8b 84 24 38
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  008e0	48 8b 80 70 08
	00 00		 mov	 rax, QWORD PTR [rax+2160]
  008e7	48 8b 80 88 08
	00 00		 mov	 rax, QWORD PTR [rax+2184]
  008ee	0f b6 40 74	 movzx	 eax, BYTE PTR [rax+116]
  008f2	48 6b c0 38	 imul	 rax, rax, 56		; 00000038H
  008f6	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  008fd	48 8b 84 01 b0
	0e 00 00	 mov	 rax, QWORD PTR [rcx+rax+3760]
  00905	48 25 ff ff 0f
	00		 and	 rax, 1048575		; 000fffffH
  0090b	48 c1 e0 14	 shl	 rax, 20
  0090f	48 89 84 24 c8
	00 00 00	 mov	 QWORD PTR eso$5[rsp], rax

; 488  :         esl = (sysblk.zpb[ STATEBK->zone ].esl & 0xFFFFF) << 20;

  00917	48 8b 84 24 38
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0091f	48 8b 80 70 08
	00 00		 mov	 rax, QWORD PTR [rax+2160]
  00926	48 8b 80 88 08
	00 00		 mov	 rax, QWORD PTR [rax+2184]
  0092d	0f b6 40 74	 movzx	 eax, BYTE PTR [rax+116]
  00931	48 6b c0 38	 imul	 rax, rax, 56		; 00000038H
  00935	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  0093c	48 8b 84 01 b8
	0e 00 00	 mov	 rax, QWORD PTR [rcx+rax+3768]
  00944	48 25 ff ff 0f
	00		 and	 rax, 1048575		; 000fffffH
  0094a	48 c1 e0 14	 shl	 rax, 20
  0094e	48 89 84 24 d0
	00 00 00	 mov	 QWORD PTR esl$6[rsp], rax

; 489  : 
; 490  :         if (mso > msl)

  00956	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR msl$3[rsp]
  0095e	48 39 84 24 90
	00 00 00	 cmp	 QWORD PTR mso$1[rsp], rax
  00966	0f 86 c2 00 00
	00		 jbe	 $LN119@z900_start
$LN28@z900_start:

; 491  :         {
; 492  :             /* Validity intercept for invalid zone */
; 493  :             SIE_SET_VI( SIE_VI_WHO_CPU, SIE_VI_WHEN_SIENT, SIE_VI_WHY_MSDEF, GUESTREGS );

  0096c	48 8b 84 24 38
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00974	48 8b 80 70 08
	00 00		 mov	 rax, QWORD PTR [rax+2160]
  0097b	48 8b 80 88 08
	00 00		 mov	 rax, QWORD PTR [rax+2184]
  00982	b9 01 00 00 00	 mov	 ecx, 1
  00987	48 6b c9 00	 imul	 rcx, rcx, 0
  0098b	c6 44 08 56 01	 mov	 BYTE PTR [rax+rcx+86], 1
  00990	48 8b 84 24 38
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00998	48 8b 80 70 08
	00 00		 mov	 rax, QWORD PTR [rax+2160]
  0099f	48 8b 80 88 08
	00 00		 mov	 rax, QWORD PTR [rax+2184]
  009a6	b9 01 00 00 00	 mov	 ecx, 1
  009ab	48 6b c9 01	 imul	 rcx, rcx, 1
  009af	c6 44 08 56 10	 mov	 BYTE PTR [rax+rcx+86], 16
  009b4	66 b9 41 00	 mov	 cx, 65			; 00000041H
  009b8	e8 00 00 00 00	 call	 _byteswap_ushort
  009bd	48 8b 8c 24 38
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  009c5	48 8b 89 70 08
	00 00		 mov	 rcx, QWORD PTR [rcx+2160]
  009cc	48 8b 89 88 08
	00 00		 mov	 rcx, QWORD PTR [rcx+2184]
  009d3	48 83 c1 58	 add	 rcx, 88			; 00000058H
  009d7	0f b7 d0	 movzx	 edx, ax
  009da	e8 00 00 00 00	 call	 store_hw_noswap
  009df	48 8b 84 24 38
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  009e7	48 8b 80 70 08
	00 00		 mov	 rax, QWORD PTR [rax+2160]
  009ee	48 8b 80 88 08
	00 00		 mov	 rax, QWORD PTR [rax+2184]
  009f5	48 83 c0 5a	 add	 rax, 90			; 0000005aH
  009f9	48 8b f8	 mov	 rdi, rax
  009fc	33 c0		 xor	 eax, eax
  009fe	b9 06 00 00 00	 mov	 ecx, 6
  00a03	f3 aa		 rep stosb
  00a05	33 c0		 xor	 eax, eax
  00a07	85 c0		 test	 eax, eax
  00a09	0f 85 5d ff ff
	ff		 jne	 $LN28@z900_start

; 494  :             STATEBK->c = SIE_C_VALIDITY;

  00a0f	48 8b 84 24 38
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00a17	48 8b 80 70 08
	00 00		 mov	 rax, QWORD PTR [rax+2160]
  00a1e	48 8b 80 88 08
	00 00		 mov	 rax, QWORD PTR [rax+2184]
  00a25	c6 40 50 20	 mov	 BYTE PTR [rax+80], 32	; 00000020H

; 495  :             return;

  00a29	e9 3e 1d 00 00	 jmp	 $LN1@z900_start
$LN119@z900_start:

; 496  :         }
; 497  : 
; 498  :         /* Ensure addressing exceptions on incorrect zone defs */
; 499  :         if (0
; 500  :             || mso > regs->mainlim
; 501  :             || msl > regs->mainlim

  00a2e	33 c0		 xor	 eax, eax
  00a30	85 c0		 test	 eax, eax
  00a32	75 32		 jne	 SHORT $LN121@z900_start
  00a34	48 8b 84 24 38
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00a3c	48 8b 80 58 08
	00 00		 mov	 rax, QWORD PTR [rax+2136]
  00a43	48 39 84 24 90
	00 00 00	 cmp	 QWORD PTR mso$1[rsp], rax
  00a4b	77 19		 ja	 SHORT $LN121@z900_start
  00a4d	48 8b 84 24 38
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00a55	48 8b 80 58 08
	00 00		 mov	 rax, QWORD PTR [rax+2136]
  00a5c	48 39 84 24 b0
	00 00 00	 cmp	 QWORD PTR msl$3[rsp], rax
  00a64	76 1c		 jbe	 SHORT $LN120@z900_start
$LN121@z900_start:

; 502  :         )
; 503  :             mso = msl = 0;

  00a66	48 c7 84 24 b0
	00 00 00 00 00
	00 00		 mov	 QWORD PTR msl$3[rsp], 0
  00a72	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR msl$3[rsp]
  00a7a	48 89 84 24 90
	00 00 00	 mov	 QWORD PTR mso$1[rsp], rax
$LN120@z900_start:

; 504  : 
; 505  : #if defined( SIE_DEBUG )
; 506  :         LOGMSG( "SIE: zone %d: mso=" F_RADR " msl=" F_RADR "\n", STATEBK->zone, mso, msl );
; 507  : #endif
; 508  : 
; 509  :         GUESTREGS->sie_pref  =  1;

  00a82	48 8b 84 24 38
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00a8a	48 8b 80 70 08
	00 00		 mov	 rax, QWORD PTR [rax+2160]
  00a91	8b 80 c8 08 00
	00		 mov	 eax, DWORD PTR [rax+2248]
  00a97	83 c8 04	 or	 eax, 4
  00a9a	48 8b 8c 24 38
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00aa2	48 8b 89 70 08
	00 00		 mov	 rcx, QWORD PTR [rcx+2160]
  00aa9	89 81 c8 08 00
	00		 mov	 DWORD PTR [rcx+2248], eax

; 510  :         GUESTREGS->sie_mso   =  0;

  00aaf	48 8b 84 24 38
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00ab7	48 8b 80 70 08
	00 00		 mov	 rax, QWORD PTR [rax+2160]
  00abe	48 c7 80 98 08
	00 00 00 00 00
	00		 mov	 QWORD PTR [rax+2200], 0

; 511  :         GUESTREGS->mainstor  =  &sysblk.mainstor[mso];

  00ac9	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00ad0	48 8b 80 98 00
	00 00		 mov	 rax, QWORD PTR [rax+152]
  00ad7	48 03 84 24 90
	00 00 00	 add	 rax, QWORD PTR mso$1[rsp]
  00adf	48 8b 8c 24 38
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00ae7	48 8b 89 70 08
	00 00		 mov	 rcx, QWORD PTR [rcx+2160]
  00aee	48 89 81 48 08
	00 00		 mov	 QWORD PTR [rcx+2120], rax

; 512  :         GUESTREGS->mainlim   =  msl - mso;

  00af5	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR mso$1[rsp]
  00afd	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR msl$3[rsp]
  00b05	48 2b c8	 sub	 rcx, rax
  00b08	48 8b c1	 mov	 rax, rcx
  00b0b	48 8b 8c 24 38
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00b13	48 8b 89 70 08
	00 00		 mov	 rcx, QWORD PTR [rcx+2160]
  00b1a	48 89 81 58 08
	00 00		 mov	 QWORD PTR [rcx+2136], rax

; 513  :         GUESTREGS->storkeys  =  ARCH_DEP( get_ptr_to_storekey )( mso );

  00b21	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR mso$1[rsp]
  00b29	e8 00 00 00 00	 call	 z900_get_ptr_to_storekey
  00b2e	48 8b 8c 24 38
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00b36	48 8b 89 70 08
	00 00		 mov	 rcx, QWORD PTR [rcx+2160]
  00b3d	48 89 81 50 08
	00 00		 mov	 QWORD PTR [rcx+2128], rax

; 514  :         GUESTREGS->sie_xso   =  eso;

  00b44	48 8b 84 24 38
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00b4c	48 8b 80 70 08
	00 00		 mov	 rax, QWORD PTR [rax+2160]
  00b53	48 8b 8c 24 c8
	00 00 00	 mov	 rcx, QWORD PTR eso$5[rsp]
  00b5b	48 89 88 a0 08
	00 00		 mov	 QWORD PTR [rax+2208], rcx

; 515  :         GUESTREGS->sie_xsl   =  esl;

  00b62	48 8b 84 24 38
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00b6a	48 8b 80 70 08
	00 00		 mov	 rax, QWORD PTR [rax+2160]
  00b71	48 8b 8c 24 d0
	00 00 00	 mov	 rcx, QWORD PTR esl$6[rsp]
  00b79	48 89 88 a8 08
	00 00		 mov	 QWORD PTR [rax+2216], rcx

; 516  :         GUESTREGS->sie_xso  *=  (XSTORE_INCREMENT_SIZE >> XSTORE_PAGESHIFT);

  00b80	48 8b 84 24 38
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00b88	48 8b 80 70 08
	00 00		 mov	 rax, QWORD PTR [rax+2160]
  00b8f	48 69 80 a0 08
	00 00 00 01 00
	00		 imul	 rax, QWORD PTR [rax+2208], 256 ; 00000100H
  00b9a	48 8b 8c 24 38
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00ba2	48 8b 89 70 08
	00 00		 mov	 rcx, QWORD PTR [rcx+2160]
  00ba9	48 89 81 a0 08
	00 00		 mov	 QWORD PTR [rcx+2208], rax

; 517  :         GUESTREGS->sie_xsl  *=  (XSTORE_INCREMENT_SIZE >> XSTORE_PAGESHIFT);

  00bb0	48 8b 84 24 38
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00bb8	48 8b 80 70 08
	00 00		 mov	 rax, QWORD PTR [rax+2160]
  00bbf	48 69 80 a8 08
	00 00 00 01 00
	00		 imul	 rax, QWORD PTR [rax+2216], 256 ; 00000100H
  00bca	48 8b 8c 24 38
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00bd2	48 8b 89 70 08
	00 00		 mov	 rcx, QWORD PTR [rcx+2160]
  00bd9	48 89 81 a8 08
	00 00		 mov	 QWORD PTR [rcx+2216], rax

; 518  :     }

  00be0	e9 db 04 00 00	 jmp	 $LN117@z900_start
$LN116@z900_start:

; 519  :     else
; 520  : #endif /* defined( FEATURE_REGION_RELOCATE ) */
; 521  :     {
; 522  :         GUESTREGS->mainstor = sysblk.mainstor;

  00be5	48 8b 84 24 38
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00bed	48 8b 80 70 08
	00 00		 mov	 rax, QWORD PTR [rax+2160]
  00bf4	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  00bfb	48 8b 89 98 00
	00 00		 mov	 rcx, QWORD PTR [rcx+152]
  00c02	48 89 88 48 08
	00 00		 mov	 QWORD PTR [rax+2120], rcx

; 523  :         GUESTREGS->storkeys = sysblk.storkeys;

  00c09	48 8b 84 24 38
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00c11	48 8b 80 70 08
	00 00		 mov	 rax, QWORD PTR [rax+2160]
  00c18	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  00c1f	48 8b 89 a0 00
	00 00		 mov	 rcx, QWORD PTR [rcx+160]
  00c26	48 89 88 50 08
	00 00		 mov	 QWORD PTR [rax+2128], rcx

; 524  : 
; 525  :         if (STATEBK->zone)

  00c2d	48 8b 84 24 38
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00c35	48 8b 80 70 08
	00 00		 mov	 rax, QWORD PTR [rax+2160]
  00c3c	48 8b 80 88 08
	00 00		 mov	 rax, QWORD PTR [rax+2184]
  00c43	0f b6 40 74	 movzx	 eax, BYTE PTR [rax+116]
  00c47	85 c0		 test	 eax, eax
  00c49	0f 84 c2 00 00
	00		 je	 $LN122@z900_start
$LN31@z900_start:

; 526  :         {
; 527  :             /* Validity intercept for invalid zone */
; 528  :             SIE_SET_VI( SIE_VI_WHO_CPU, SIE_VI_WHEN_SIENT, SIE_VI_WHY_AZNNZ, GUESTREGS );

  00c4f	48 8b 84 24 38
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00c57	48 8b 80 70 08
	00 00		 mov	 rax, QWORD PTR [rax+2160]
  00c5e	48 8b 80 88 08
	00 00		 mov	 rax, QWORD PTR [rax+2184]
  00c65	b9 01 00 00 00	 mov	 ecx, 1
  00c6a	48 6b c9 00	 imul	 rcx, rcx, 0
  00c6e	c6 44 08 56 01	 mov	 BYTE PTR [rax+rcx+86], 1
  00c73	48 8b 84 24 38
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00c7b	48 8b 80 70 08
	00 00		 mov	 rax, QWORD PTR [rax+2160]
  00c82	48 8b 80 88 08
	00 00		 mov	 rax, QWORD PTR [rax+2184]
  00c89	b9 01 00 00 00	 mov	 ecx, 1
  00c8e	48 6b c9 01	 imul	 rcx, rcx, 1
  00c92	c6 44 08 56 10	 mov	 BYTE PTR [rax+rcx+86], 16
  00c97	66 b9 06 10	 mov	 cx, 4102		; 00001006H
  00c9b	e8 00 00 00 00	 call	 _byteswap_ushort
  00ca0	48 8b 8c 24 38
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00ca8	48 8b 89 70 08
	00 00		 mov	 rcx, QWORD PTR [rcx+2160]
  00caf	48 8b 89 88 08
	00 00		 mov	 rcx, QWORD PTR [rcx+2184]
  00cb6	48 83 c1 58	 add	 rcx, 88			; 00000058H
  00cba	0f b7 d0	 movzx	 edx, ax
  00cbd	e8 00 00 00 00	 call	 store_hw_noswap
  00cc2	48 8b 84 24 38
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00cca	48 8b 80 70 08
	00 00		 mov	 rax, QWORD PTR [rax+2160]
  00cd1	48 8b 80 88 08
	00 00		 mov	 rax, QWORD PTR [rax+2184]
  00cd8	48 83 c0 5a	 add	 rax, 90			; 0000005aH
  00cdc	48 8b f8	 mov	 rdi, rax
  00cdf	33 c0		 xor	 eax, eax
  00ce1	b9 06 00 00 00	 mov	 ecx, 6
  00ce6	f3 aa		 rep stosb
  00ce8	33 c0		 xor	 eax, eax
  00cea	85 c0		 test	 eax, eax
  00cec	0f 85 5d ff ff
	ff		 jne	 $LN31@z900_start

; 529  :             STATEBK->c = SIE_C_VALIDITY;

  00cf2	48 8b 84 24 38
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00cfa	48 8b 80 70 08
	00 00		 mov	 rax, QWORD PTR [rax+2160]
  00d01	48 8b 80 88 08
	00 00		 mov	 rax, QWORD PTR [rax+2184]
  00d08	c6 40 50 20	 mov	 BYTE PTR [rax+80], 32	; 00000020H

; 530  :             return;

  00d0c	e9 5b 1a 00 00	 jmp	 $LN1@z900_start
$LN122@z900_start:

; 531  :         }
; 532  : 
; 533  : #if defined( FEATURE_001_ZARCH_INSTALLED_FACILITY )
; 534  : 
; 535  :         /* Load main storage origin */
; 536  :         FETCH_DW( GUESTREGS->sie_mso, STATEBK->mso );

  00d11	48 8b 84 24 38
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00d19	48 8b 80 70 08
	00 00		 mov	 rax, QWORD PTR [rax+2160]
  00d20	48 8b 80 88 08
	00 00		 mov	 rax, QWORD PTR [rax+2184]
  00d27	48 05 80 00 00
	00		 add	 rax, 128		; 00000080H
  00d2d	48 8b c8	 mov	 rcx, rax
  00d30	e8 00 00 00 00	 call	 fetch_dw_noswap
  00d35	48 8b c8	 mov	 rcx, rax
  00d38	e8 00 00 00 00	 call	 _byteswap_uint64
  00d3d	48 8b 8c 24 38
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00d45	48 8b 89 70 08
	00 00		 mov	 rcx, QWORD PTR [rcx+2160]
  00d4c	48 89 81 98 08
	00 00		 mov	 QWORD PTR [rcx+2200], rax

; 537  :         GUESTREGS->sie_mso &= SIE2_MS_MASK;

  00d53	48 8b 84 24 38
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00d5b	48 8b 80 70 08
	00 00		 mov	 rax, QWORD PTR [rax+2160]
  00d62	48 8b 80 98 08
	00 00		 mov	 rax, QWORD PTR [rax+2200]
  00d69	48 25 00 00 f0
	ff		 and	 rax, -1048576		; fffffffffff00000H
  00d6f	48 8b 8c 24 38
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00d77	48 8b 89 70 08
	00 00		 mov	 rcx, QWORD PTR [rcx+2160]
  00d7e	48 89 81 98 08
	00 00		 mov	 QWORD PTR [rcx+2200], rax

; 538  : 
; 539  :         /* Load main storage extent */
; 540  :         FETCH_DW( GUESTREGS->mainlim, STATEBK->mse );

  00d85	48 8b 84 24 38
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00d8d	48 8b 80 70 08
	00 00		 mov	 rax, QWORD PTR [rax+2160]
  00d94	48 8b 80 88 08
	00 00		 mov	 rax, QWORD PTR [rax+2184]
  00d9b	48 05 88 00 00
	00		 add	 rax, 136		; 00000088H
  00da1	48 8b c8	 mov	 rcx, rax
  00da4	e8 00 00 00 00	 call	 fetch_dw_noswap
  00da9	48 8b c8	 mov	 rcx, rax
  00dac	e8 00 00 00 00	 call	 _byteswap_uint64
  00db1	48 8b 8c 24 38
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00db9	48 8b 89 70 08
	00 00		 mov	 rcx, QWORD PTR [rcx+2160]
  00dc0	48 89 81 58 08
	00 00		 mov	 QWORD PTR [rcx+2136], rax

; 541  :         GUESTREGS->mainlim |= ~SIE2_MS_MASK;

  00dc7	48 8b 84 24 38
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00dcf	48 8b 80 70 08
	00 00		 mov	 rax, QWORD PTR [rax+2160]
  00dd6	48 8b 80 58 08
	00 00		 mov	 rax, QWORD PTR [rax+2136]
  00ddd	48 0d ff ff 0f
	00		 or	 rax, 1048575		; 000fffffH
  00de3	48 8b 8c 24 38
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00deb	48 8b 89 70 08
	00 00		 mov	 rcx, QWORD PTR [rcx+2160]
  00df2	48 89 81 58 08
	00 00		 mov	 QWORD PTR [rcx+2136], rax

; 542  : 
; 543  :         if (GUESTREGS->sie_mso > GUESTREGS->mainlim)

  00df9	48 8b 84 24 38
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00e01	48 8b 80 70 08
	00 00		 mov	 rax, QWORD PTR [rax+2160]
  00e08	48 8b 8c 24 38
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00e10	48 8b 89 70 08
	00 00		 mov	 rcx, QWORD PTR [rcx+2160]
  00e17	48 8b 89 58 08
	00 00		 mov	 rcx, QWORD PTR [rcx+2136]
  00e1e	48 39 88 98 08
	00 00		 cmp	 QWORD PTR [rax+2200], rcx
  00e25	0f 86 c2 00 00
	00		 jbe	 $LN123@z900_start
$LN34@z900_start:

; 544  :         {
; 545  :             SIE_SET_VI( SIE_VI_WHO_CPU, SIE_VI_WHEN_SIENT, SIE_VI_WHY_MSDEF, GUESTREGS );

  00e2b	48 8b 84 24 38
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00e33	48 8b 80 70 08
	00 00		 mov	 rax, QWORD PTR [rax+2160]
  00e3a	48 8b 80 88 08
	00 00		 mov	 rax, QWORD PTR [rax+2184]
  00e41	b9 01 00 00 00	 mov	 ecx, 1
  00e46	48 6b c9 00	 imul	 rcx, rcx, 0
  00e4a	c6 44 08 56 01	 mov	 BYTE PTR [rax+rcx+86], 1
  00e4f	48 8b 84 24 38
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00e57	48 8b 80 70 08
	00 00		 mov	 rax, QWORD PTR [rax+2160]
  00e5e	48 8b 80 88 08
	00 00		 mov	 rax, QWORD PTR [rax+2184]
  00e65	b9 01 00 00 00	 mov	 ecx, 1
  00e6a	48 6b c9 01	 imul	 rcx, rcx, 1
  00e6e	c6 44 08 56 10	 mov	 BYTE PTR [rax+rcx+86], 16
  00e73	66 b9 41 00	 mov	 cx, 65			; 00000041H
  00e77	e8 00 00 00 00	 call	 _byteswap_ushort
  00e7c	48 8b 8c 24 38
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00e84	48 8b 89 70 08
	00 00		 mov	 rcx, QWORD PTR [rcx+2160]
  00e8b	48 8b 89 88 08
	00 00		 mov	 rcx, QWORD PTR [rcx+2184]
  00e92	48 83 c1 58	 add	 rcx, 88			; 00000058H
  00e96	0f b7 d0	 movzx	 edx, ax
  00e99	e8 00 00 00 00	 call	 store_hw_noswap
  00e9e	48 8b 84 24 38
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00ea6	48 8b 80 70 08
	00 00		 mov	 rax, QWORD PTR [rax+2160]
  00ead	48 8b 80 88 08
	00 00		 mov	 rax, QWORD PTR [rax+2184]
  00eb4	48 83 c0 5a	 add	 rax, 90			; 0000005aH
  00eb8	48 8b f8	 mov	 rdi, rax
  00ebb	33 c0		 xor	 eax, eax
  00ebd	b9 06 00 00 00	 mov	 ecx, 6
  00ec2	f3 aa		 rep stosb
  00ec4	33 c0		 xor	 eax, eax
  00ec6	85 c0		 test	 eax, eax
  00ec8	0f 85 5d ff ff
	ff		 jne	 $LN34@z900_start

; 546  :             STATEBK->c = SIE_C_VALIDITY;

  00ece	48 8b 84 24 38
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00ed6	48 8b 80 70 08
	00 00		 mov	 rax, QWORD PTR [rax+2160]
  00edd	48 8b 80 88 08
	00 00		 mov	 rax, QWORD PTR [rax+2184]
  00ee4	c6 40 50 20	 mov	 BYTE PTR [rax+80], 32	; 00000020H

; 547  :             return;

  00ee8	e9 7f 18 00 00	 jmp	 $LN1@z900_start
$LN123@z900_start:

; 548  :         }
; 549  : 
; 550  :         /* Calculate main storage size */
; 551  :         GUESTREGS->mainlim -= GUESTREGS->sie_mso;

  00eed	48 8b 84 24 38
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00ef5	48 8b 80 70 08
	00 00		 mov	 rax, QWORD PTR [rax+2160]
  00efc	48 8b 8c 24 38
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00f04	48 8b 89 70 08
	00 00		 mov	 rcx, QWORD PTR [rcx+2160]
  00f0b	48 8b 89 98 08
	00 00		 mov	 rcx, QWORD PTR [rcx+2200]
  00f12	48 8b 80 58 08
	00 00		 mov	 rax, QWORD PTR [rax+2136]
  00f19	48 2b c1	 sub	 rax, rcx
  00f1c	48 8b 8c 24 38
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00f24	48 8b 89 70 08
	00 00		 mov	 rcx, QWORD PTR [rcx+2160]
  00f2b	48 89 81 58 08
	00 00		 mov	 QWORD PTR [rcx+2136], rax

; 552  : 
; 553  : #else /* !defined( FEATURE_001_ZARCH_INSTALLED_FACILITY ) */
; 554  : 
; 555  :         /* Load main storage origin */
; 556  :         FETCH_HW( GUESTREGS->sie_mso, STATEBK->mso );
; 557  :         GUESTREGS->sie_mso <<= 16;
; 558  : 
; 559  :         /* Load main storage extent */
; 560  :         FETCH_HW( GUESTREGS->mainlim, STATEBK->mse );
; 561  :         GUESTREGS->mainlim = ((GUESTREGS->mainlim + 1) << 16) - 1;
; 562  : 
; 563  : #endif /* defined( FEATURE_001_ZARCH_INSTALLED_FACILITY ) */
; 564  : 
; 565  :         /* Load expanded storage origin */
; 566  :         GUESTREGS->sie_xso = STATEBK->xso[0] << 16

  00f32	48 8b 84 24 38
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00f3a	48 8b 80 70 08
	00 00		 mov	 rax, QWORD PTR [rax+2160]
  00f41	48 8b 80 88 08
	00 00		 mov	 rax, QWORD PTR [rax+2184]
  00f48	b9 01 00 00 00	 mov	 ecx, 1
  00f4d	48 6b c9 00	 imul	 rcx, rcx, 0
  00f51	0f b6 84 08 ba
	00 00 00	 movzx	 eax, BYTE PTR [rax+rcx+186]
  00f59	c1 e0 10	 shl	 eax, 16
  00f5c	48 8b 8c 24 38
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00f64	48 8b 89 70 08
	00 00		 mov	 rcx, QWORD PTR [rcx+2160]
  00f6b	48 8b 89 88 08
	00 00		 mov	 rcx, QWORD PTR [rcx+2184]
  00f72	ba 01 00 00 00	 mov	 edx, 1
  00f77	48 6b d2 01	 imul	 rdx, rdx, 1
  00f7b	0f b6 8c 11 ba
	00 00 00	 movzx	 ecx, BYTE PTR [rcx+rdx+186]
  00f83	c1 e1 08	 shl	 ecx, 8
  00f86	0b c1		 or	 eax, ecx
  00f88	48 8b 8c 24 38
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00f90	48 8b 89 70 08
	00 00		 mov	 rcx, QWORD PTR [rcx+2160]
  00f97	48 8b 89 88 08
	00 00		 mov	 rcx, QWORD PTR [rcx+2184]
  00f9e	ba 01 00 00 00	 mov	 edx, 1
  00fa3	48 6b d2 02	 imul	 rdx, rdx, 2
  00fa7	0f b6 8c 11 ba
	00 00 00	 movzx	 ecx, BYTE PTR [rcx+rdx+186]
  00faf	0b c1		 or	 eax, ecx
  00fb1	48 8b 8c 24 38
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00fb9	48 8b 89 70 08
	00 00		 mov	 rcx, QWORD PTR [rcx+2160]
  00fc0	48 98		 cdqe
  00fc2	48 89 81 a0 08
	00 00		 mov	 QWORD PTR [rcx+2208], rax

; 567  :                            | STATEBK->xso[1] <<  8
; 568  :                            | STATEBK->xso[2];
; 569  :         GUESTREGS->sie_xso *= (XSTORE_INCREMENT_SIZE >> XSTORE_PAGESHIFT);

  00fc9	48 8b 84 24 38
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00fd1	48 8b 80 70 08
	00 00		 mov	 rax, QWORD PTR [rax+2160]
  00fd8	48 69 80 a0 08
	00 00 00 01 00
	00		 imul	 rax, QWORD PTR [rax+2208], 256 ; 00000100H
  00fe3	48 8b 8c 24 38
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00feb	48 8b 89 70 08
	00 00		 mov	 rcx, QWORD PTR [rcx+2160]
  00ff2	48 89 81 a0 08
	00 00		 mov	 QWORD PTR [rcx+2208], rax

; 570  : 
; 571  :         /* Load expanded storage limit */
; 572  :         GUESTREGS->sie_xsl = STATEBK->xsl[0] << 16

  00ff9	48 8b 84 24 38
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  01001	48 8b 80 70 08
	00 00		 mov	 rax, QWORD PTR [rax+2160]
  01008	48 8b 80 88 08
	00 00		 mov	 rax, QWORD PTR [rax+2184]
  0100f	b9 01 00 00 00	 mov	 ecx, 1
  01014	48 6b c9 00	 imul	 rcx, rcx, 0
  01018	0f b6 84 08 bd
	00 00 00	 movzx	 eax, BYTE PTR [rax+rcx+189]
  01020	c1 e0 10	 shl	 eax, 16
  01023	48 8b 8c 24 38
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0102b	48 8b 89 70 08
	00 00		 mov	 rcx, QWORD PTR [rcx+2160]
  01032	48 8b 89 88 08
	00 00		 mov	 rcx, QWORD PTR [rcx+2184]
  01039	ba 01 00 00 00	 mov	 edx, 1
  0103e	48 6b d2 01	 imul	 rdx, rdx, 1
  01042	0f b6 8c 11 bd
	00 00 00	 movzx	 ecx, BYTE PTR [rcx+rdx+189]
  0104a	c1 e1 08	 shl	 ecx, 8
  0104d	0b c1		 or	 eax, ecx
  0104f	48 8b 8c 24 38
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  01057	48 8b 89 70 08
	00 00		 mov	 rcx, QWORD PTR [rcx+2160]
  0105e	48 8b 89 88 08
	00 00		 mov	 rcx, QWORD PTR [rcx+2184]
  01065	ba 01 00 00 00	 mov	 edx, 1
  0106a	48 6b d2 02	 imul	 rdx, rdx, 2
  0106e	0f b6 8c 11 bd
	00 00 00	 movzx	 ecx, BYTE PTR [rcx+rdx+189]
  01076	0b c1		 or	 eax, ecx
  01078	48 8b 8c 24 38
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  01080	48 8b 89 70 08
	00 00		 mov	 rcx, QWORD PTR [rcx+2160]
  01087	48 98		 cdqe
  01089	48 89 81 a8 08
	00 00		 mov	 QWORD PTR [rcx+2216], rax

; 573  :                            | STATEBK->xsl[1] <<  8
; 574  :                            | STATEBK->xsl[2];
; 575  :         GUESTREGS->sie_xsl *= (XSTORE_INCREMENT_SIZE >> XSTORE_PAGESHIFT);

  01090	48 8b 84 24 38
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  01098	48 8b 80 70 08
	00 00		 mov	 rax, QWORD PTR [rax+2160]
  0109f	48 69 80 a8 08
	00 00 00 01 00
	00		 imul	 rax, QWORD PTR [rax+2216], 256 ; 00000100H
  010aa	48 8b 8c 24 38
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  010b2	48 8b 89 70 08
	00 00		 mov	 rcx, QWORD PTR [rcx+2160]
  010b9	48 89 81 a8 08
	00 00		 mov	 QWORD PTR [rcx+2216], rax
$LN117@z900_start:

; 576  :     }
; 577  : 
; 578  :     /* Validate Guest prefix */
; 579  :     if (GUESTREGS->PX > GUESTREGS->mainlim)

  010c0	48 8b 84 24 38
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  010c8	48 8b 80 70 08
	00 00		 mov	 rax, QWORD PTR [rax+2160]
  010cf	48 8b 8c 24 38
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  010d7	48 8b 89 70 08
	00 00		 mov	 rcx, QWORD PTR [rcx+2160]
  010de	48 8b 89 58 08
	00 00		 mov	 rcx, QWORD PTR [rcx+2136]
  010e5	48 39 48 70	 cmp	 QWORD PTR [rax+112], rcx
  010e9	0f 86 c2 00 00
	00		 jbe	 $LN124@z900_start
$LN37@z900_start:

; 580  :     {
; 581  :         SIE_SET_VI( SIE_VI_WHO_CPU, SIE_VI_WHEN_SIENT, SIE_VI_WHY_PFOUT, GUESTREGS );

  010ef	48 8b 84 24 38
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  010f7	48 8b 80 70 08
	00 00		 mov	 rax, QWORD PTR [rax+2160]
  010fe	48 8b 80 88 08
	00 00		 mov	 rax, QWORD PTR [rax+2184]
  01105	b9 01 00 00 00	 mov	 ecx, 1
  0110a	48 6b c9 00	 imul	 rcx, rcx, 0
  0110e	c6 44 08 56 01	 mov	 BYTE PTR [rax+rcx+86], 1
  01113	48 8b 84 24 38
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0111b	48 8b 80 70 08
	00 00		 mov	 rax, QWORD PTR [rax+2160]
  01122	48 8b 80 88 08
	00 00		 mov	 rax, QWORD PTR [rax+2184]
  01129	b9 01 00 00 00	 mov	 ecx, 1
  0112e	48 6b c9 01	 imul	 rcx, rcx, 1
  01132	c6 44 08 56 10	 mov	 BYTE PTR [rax+rcx+86], 16
  01137	66 b9 10 00	 mov	 cx, 16
  0113b	e8 00 00 00 00	 call	 _byteswap_ushort
  01140	48 8b 8c 24 38
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  01148	48 8b 89 70 08
	00 00		 mov	 rcx, QWORD PTR [rcx+2160]
  0114f	48 8b 89 88 08
	00 00		 mov	 rcx, QWORD PTR [rcx+2184]
  01156	48 83 c1 58	 add	 rcx, 88			; 00000058H
  0115a	0f b7 d0	 movzx	 edx, ax
  0115d	e8 00 00 00 00	 call	 store_hw_noswap
  01162	48 8b 84 24 38
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0116a	48 8b 80 70 08
	00 00		 mov	 rax, QWORD PTR [rax+2160]
  01171	48 8b 80 88 08
	00 00		 mov	 rax, QWORD PTR [rax+2184]
  01178	48 83 c0 5a	 add	 rax, 90			; 0000005aH
  0117c	48 8b f8	 mov	 rdi, rax
  0117f	33 c0		 xor	 eax, eax
  01181	b9 06 00 00 00	 mov	 ecx, 6
  01186	f3 aa		 rep stosb
  01188	33 c0		 xor	 eax, eax
  0118a	85 c0		 test	 eax, eax
  0118c	0f 85 5d ff ff
	ff		 jne	 $LN37@z900_start

; 582  :         STATEBK->c = SIE_C_VALIDITY;

  01192	48 8b 84 24 38
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0119a	48 8b 80 70 08
	00 00		 mov	 rax, QWORD PTR [rax+2160]
  011a1	48 8b 80 88 08
	00 00		 mov	 rax, QWORD PTR [rax+2184]
  011a8	c6 40 50 20	 mov	 BYTE PTR [rax+80], 32	; 00000020H

; 583  :         return;

  011ac	e9 bb 15 00 00	 jmp	 $LN1@z900_start
$LN124@z900_start:

; 584  :     }
; 585  : 
; 586  :     /* System Control Area Origin */
; 587  :     FETCH_FW( GUESTREGS->sie_scao, STATEBK->scao );

  011b1	48 8b 84 24 38
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  011b9	48 8b 80 70 08
	00 00		 mov	 rax, QWORD PTR [rax+2160]
  011c0	48 8b 80 88 08
	00 00		 mov	 rax, QWORD PTR [rax+2184]
  011c7	48 83 c0 64	 add	 rax, 100		; 00000064H
  011cb	48 8b c8	 mov	 rcx, rax
  011ce	e8 00 00 00 00	 call	 fetch_fw_noswap
  011d3	8b c8		 mov	 ecx, eax
  011d5	e8 00 00 00 00	 call	 _byteswap_ulong
  011da	48 8b 8c 24 38
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  011e2	48 8b 89 70 08
	00 00		 mov	 rcx, QWORD PTR [rcx+2160]
  011e9	8b c0		 mov	 eax, eax
  011eb	48 89 81 b8 08
	00 00		 mov	 QWORD PTR [rcx+2232], rax

; 588  :     GUESTREGS->sie_scao &= SIEISCAM;

  011f2	48 8b 84 24 38
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  011fa	48 8b 80 70 08
	00 00		 mov	 rax, QWORD PTR [rax+2160]
  01201	b9 f0 ff ff ff	 mov	 ecx, -16		; fffffff0H
  01206	48 8b 80 b8 08
	00 00		 mov	 rax, QWORD PTR [rax+2232]
  0120d	48 23 c1	 and	 rax, rcx
  01210	48 8b 8c 24 38
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  01218	48 8b 89 70 08
	00 00		 mov	 rcx, QWORD PTR [rcx+2160]
  0121f	48 89 81 b8 08
	00 00		 mov	 QWORD PTR [rcx+2232], rax

; 589  : 
; 590  : #if defined( FEATURE_001_ZARCH_INSTALLED_FACILITY )
; 591  :     {
; 592  :         /* For ESAME insert the high word of the address */
; 593  :         U32 sie_scaoh;
; 594  :         FETCH_FW( sie_scaoh, STATEBK->scaoh );

  01226	48 8b 84 24 38
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0122e	48 8b 80 70 08
	00 00		 mov	 rax, QWORD PTR [rax+2160]
  01235	48 8b 80 88 08
	00 00		 mov	 rax, QWORD PTR [rax+2184]
  0123c	48 83 c0 5c	 add	 rax, 92			; 0000005cH
  01240	48 8b c8	 mov	 rcx, rax
  01243	e8 00 00 00 00	 call	 fetch_fw_noswap
  01248	8b c8		 mov	 ecx, eax
  0124a	e8 00 00 00 00	 call	 _byteswap_ulong
  0124f	89 84 24 bc 00
	00 00		 mov	 DWORD PTR sie_scaoh$4[rsp], eax

; 595  :         GUESTREGS->sie_scao |= (RADR)sie_scaoh << 32;

  01256	48 8b 84 24 38
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0125e	48 8b 80 70 08
	00 00		 mov	 rax, QWORD PTR [rax+2160]
  01265	8b 8c 24 bc 00
	00 00		 mov	 ecx, DWORD PTR sie_scaoh$4[rsp]
  0126c	48 c1 e1 20	 shl	 rcx, 32			; 00000020H
  01270	48 8b 80 b8 08
	00 00		 mov	 rax, QWORD PTR [rax+2232]
  01277	48 0b c1	 or	 rax, rcx
  0127a	48 8b 8c 24 38
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  01282	48 8b 89 70 08
	00 00		 mov	 rcx, QWORD PTR [rcx+2160]
  01289	48 89 81 b8 08
	00 00		 mov	 QWORD PTR [rcx+2232], rax

; 596  :     }
; 597  : #endif
; 598  : 
; 599  :     if (GUESTREGS->sie_scao > regs->mainlim)

  01290	48 8b 84 24 38
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  01298	48 8b 80 70 08
	00 00		 mov	 rax, QWORD PTR [rax+2160]
  0129f	48 8b 8c 24 38
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  012a7	48 8b 89 58 08
	00 00		 mov	 rcx, QWORD PTR [rcx+2136]
  012ae	48 39 88 b8 08
	00 00		 cmp	 QWORD PTR [rax+2232], rcx
  012b5	0f 86 c2 00 00
	00		 jbe	 $LN125@z900_start
$LN40@z900_start:

; 600  :     {
; 601  :         SIE_SET_VI( SIE_VI_WHO_CPU, SIE_VI_WHEN_SIENT, SIE_VI_WHY_SCADR, GUESTREGS );

  012bb	48 8b 84 24 38
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  012c3	48 8b 80 70 08
	00 00		 mov	 rax, QWORD PTR [rax+2160]
  012ca	48 8b 80 88 08
	00 00		 mov	 rax, QWORD PTR [rax+2184]
  012d1	b9 01 00 00 00	 mov	 ecx, 1
  012d6	48 6b c9 00	 imul	 rcx, rcx, 0
  012da	c6 44 08 56 01	 mov	 BYTE PTR [rax+rcx+86], 1
  012df	48 8b 84 24 38
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  012e7	48 8b 80 70 08
	00 00		 mov	 rax, QWORD PTR [rax+2160]
  012ee	48 8b 80 88 08
	00 00		 mov	 rax, QWORD PTR [rax+2184]
  012f5	b9 01 00 00 00	 mov	 ecx, 1
  012fa	48 6b c9 01	 imul	 rcx, rcx, 1
  012fe	c6 44 08 56 10	 mov	 BYTE PTR [rax+rcx+86], 16
  01303	66 b9 34 00	 mov	 cx, 52			; 00000034H
  01307	e8 00 00 00 00	 call	 _byteswap_ushort
  0130c	48 8b 8c 24 38
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  01314	48 8b 89 70 08
	00 00		 mov	 rcx, QWORD PTR [rcx+2160]
  0131b	48 8b 89 88 08
	00 00		 mov	 rcx, QWORD PTR [rcx+2184]
  01322	48 83 c1 58	 add	 rcx, 88			; 00000058H
  01326	0f b7 d0	 movzx	 edx, ax
  01329	e8 00 00 00 00	 call	 store_hw_noswap
  0132e	48 8b 84 24 38
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  01336	48 8b 80 70 08
	00 00		 mov	 rax, QWORD PTR [rax+2160]
  0133d	48 8b 80 88 08
	00 00		 mov	 rax, QWORD PTR [rax+2184]
  01344	48 83 c0 5a	 add	 rax, 90			; 0000005aH
  01348	48 8b f8	 mov	 rdi, rax
  0134b	33 c0		 xor	 eax, eax
  0134d	b9 06 00 00 00	 mov	 ecx, 6
  01352	f3 aa		 rep stosb
  01354	33 c0		 xor	 eax, eax
  01356	85 c0		 test	 eax, eax
  01358	0f 85 5d ff ff
	ff		 jne	 $LN40@z900_start

; 602  :         STATEBK->c = SIE_C_VALIDITY;

  0135e	48 8b 84 24 38
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  01366	48 8b 80 70 08
	00 00		 mov	 rax, QWORD PTR [rax+2160]
  0136d	48 8b 80 88 08
	00 00		 mov	 rax, QWORD PTR [rax+2184]
  01374	c6 40 50 20	 mov	 BYTE PTR [rax+80], 32	; 00000020H

; 603  :         return;

  01378	e9 ef 13 00 00	 jmp	 $LN1@z900_start
$LN125@z900_start:

; 604  :     }
; 605  : 
; 606  :     /* Validate MSO */
; 607  :     if (GUESTREGS->sie_mso)

  0137d	48 8b 84 24 38
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  01385	48 8b 80 70 08
	00 00		 mov	 rax, QWORD PTR [rax+2160]
  0138c	48 83 b8 98 08
	00 00 00	 cmp	 QWORD PTR [rax+2200], 0
  01394	0f 84 cc 01 00
	00		 je	 $LN126@z900_start

; 608  :     {
; 609  :         /* Preferred guest must have zero MSO */
; 610  :         if (GUESTREGS->sie_pref)

  0139a	48 8b 84 24 38
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  013a2	48 8b 80 70 08
	00 00		 mov	 rax, QWORD PTR [rax+2160]
  013a9	8b 80 c8 08 00
	00		 mov	 eax, DWORD PTR [rax+2248]
  013af	c1 e8 02	 shr	 eax, 2
  013b2	83 e0 01	 and	 eax, 1
  013b5	85 c0		 test	 eax, eax
  013b7	0f 84 c2 00 00
	00		 je	 $LN127@z900_start
$LN43@z900_start:

; 611  :         {
; 612  :             SIE_SET_VI( SIE_VI_WHO_CPU, SIE_VI_WHEN_SIENT, SIE_VI_WHY_MSONZ, GUESTREGS );

  013bd	48 8b 84 24 38
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  013c5	48 8b 80 70 08
	00 00		 mov	 rax, QWORD PTR [rax+2160]
  013cc	48 8b 80 88 08
	00 00		 mov	 rax, QWORD PTR [rax+2184]
  013d3	b9 01 00 00 00	 mov	 ecx, 1
  013d8	48 6b c9 00	 imul	 rcx, rcx, 0
  013dc	c6 44 08 56 01	 mov	 BYTE PTR [rax+rcx+86], 1
  013e1	48 8b 84 24 38
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  013e9	48 8b 80 70 08
	00 00		 mov	 rax, QWORD PTR [rax+2160]
  013f0	48 8b 80 88 08
	00 00		 mov	 rax, QWORD PTR [rax+2184]
  013f7	b9 01 00 00 00	 mov	 ecx, 1
  013fc	48 6b c9 01	 imul	 rcx, rcx, 1
  01400	c6 44 08 56 10	 mov	 BYTE PTR [rax+rcx+86], 16
  01405	66 b9 51 00	 mov	 cx, 81			; 00000051H
  01409	e8 00 00 00 00	 call	 _byteswap_ushort
  0140e	48 8b 8c 24 38
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  01416	48 8b 89 70 08
	00 00		 mov	 rcx, QWORD PTR [rcx+2160]
  0141d	48 8b 89 88 08
	00 00		 mov	 rcx, QWORD PTR [rcx+2184]
  01424	48 83 c1 58	 add	 rcx, 88			; 00000058H
  01428	0f b7 d0	 movzx	 edx, ax
  0142b	e8 00 00 00 00	 call	 store_hw_noswap
  01430	48 8b 84 24 38
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  01438	48 8b 80 70 08
	00 00		 mov	 rax, QWORD PTR [rax+2160]
  0143f	48 8b 80 88 08
	00 00		 mov	 rax, QWORD PTR [rax+2184]
  01446	48 83 c0 5a	 add	 rax, 90			; 0000005aH
  0144a	48 8b f8	 mov	 rdi, rax
  0144d	33 c0		 xor	 eax, eax
  0144f	b9 06 00 00 00	 mov	 ecx, 6
  01454	f3 aa		 rep stosb
  01456	33 c0		 xor	 eax, eax
  01458	85 c0		 test	 eax, eax
  0145a	0f 85 5d ff ff
	ff		 jne	 $LN43@z900_start

; 613  :             STATEBK->c = SIE_C_VALIDITY;

  01460	48 8b 84 24 38
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  01468	48 8b 80 70 08
	00 00		 mov	 rax, QWORD PTR [rax+2160]
  0146f	48 8b 80 88 08
	00 00		 mov	 rax, QWORD PTR [rax+2184]
  01476	c6 40 50 20	 mov	 BYTE PTR [rax+80], 32	; 00000020H

; 614  :             return;

  0147a	e9 ed 12 00 00	 jmp	 $LN1@z900_start
$LN127@z900_start:

; 615  :         }
; 616  : 
; 617  :         /* MCDS guest must have zero MSO */
; 618  :         if (STATEBK->mx & SIE_MX_XC)

  0147f	48 8b 84 24 38
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  01487	48 8b 80 70 08
	00 00		 mov	 rax, QWORD PTR [rax+2160]
  0148e	48 8b 80 88 08
	00 00		 mov	 rax, QWORD PTR [rax+2184]
  01495	0f b6 40 02	 movzx	 eax, BYTE PTR [rax+2]
  01499	83 e0 01	 and	 eax, 1
  0149c	85 c0		 test	 eax, eax
  0149e	0f 84 c2 00 00
	00		 je	 $LN128@z900_start
$LN46@z900_start:

; 619  :         {
; 620  :             SIE_SET_VI( SIE_VI_WHO_CPU, SIE_VI_WHEN_SIENT, SIE_VI_WHY_MSODS, GUESTREGS );

  014a4	48 8b 84 24 38
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  014ac	48 8b 80 70 08
	00 00		 mov	 rax, QWORD PTR [rax+2160]
  014b3	48 8b 80 88 08
	00 00		 mov	 rax, QWORD PTR [rax+2184]
  014ba	b9 01 00 00 00	 mov	 ecx, 1
  014bf	48 6b c9 00	 imul	 rcx, rcx, 0
  014c3	c6 44 08 56 01	 mov	 BYTE PTR [rax+rcx+86], 1
  014c8	48 8b 84 24 38
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  014d0	48 8b 80 70 08
	00 00		 mov	 rax, QWORD PTR [rax+2160]
  014d7	48 8b 80 88 08
	00 00		 mov	 rax, QWORD PTR [rax+2184]
  014de	b9 01 00 00 00	 mov	 ecx, 1
  014e3	48 6b c9 01	 imul	 rcx, rcx, 1
  014e7	c6 44 08 56 10	 mov	 BYTE PTR [rax+rcx+86], 16
  014ec	66 b9 6a 00	 mov	 cx, 106			; 0000006aH
  014f0	e8 00 00 00 00	 call	 _byteswap_ushort
  014f5	48 8b 8c 24 38
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  014fd	48 8b 89 70 08
	00 00		 mov	 rcx, QWORD PTR [rcx+2160]
  01504	48 8b 89 88 08
	00 00		 mov	 rcx, QWORD PTR [rcx+2184]
  0150b	48 83 c1 58	 add	 rcx, 88			; 00000058H
  0150f	0f b7 d0	 movzx	 edx, ax
  01512	e8 00 00 00 00	 call	 store_hw_noswap
  01517	48 8b 84 24 38
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0151f	48 8b 80 70 08
	00 00		 mov	 rax, QWORD PTR [rax+2160]
  01526	48 8b 80 88 08
	00 00		 mov	 rax, QWORD PTR [rax+2184]
  0152d	48 83 c0 5a	 add	 rax, 90			; 0000005aH
  01531	48 8b f8	 mov	 rdi, rax
  01534	33 c0		 xor	 eax, eax
  01536	b9 06 00 00 00	 mov	 ecx, 6
  0153b	f3 aa		 rep stosb
  0153d	33 c0		 xor	 eax, eax
  0153f	85 c0		 test	 eax, eax
  01541	0f 85 5d ff ff
	ff		 jne	 $LN46@z900_start

; 621  :             STATEBK->c = SIE_C_VALIDITY;

  01547	48 8b 84 24 38
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0154f	48 8b 80 70 08
	00 00		 mov	 rax, QWORD PTR [rax+2160]
  01556	48 8b 80 88 08
	00 00		 mov	 rax, QWORD PTR [rax+2184]
  0155d	c6 40 50 20	 mov	 BYTE PTR [rax+80], 32	; 00000020H

; 622  :             return;

  01561	e9 06 12 00 00	 jmp	 $LN1@z900_start
$LN128@z900_start:
$LN126@z900_start:

; 623  :         }
; 624  :     }
; 625  : 
; 626  :     GUESTREGS->sie_fld = false;  // (default until we learn otherwise)

  01566	48 8b 84 24 38
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0156e	48 8b 80 70 08
	00 00		 mov	 rax, QWORD PTR [rax+2160]
  01575	c6 80 cc 08 00
	00 00		 mov	 BYTE PTR [rax+2252], 0

; 627  : 
; 628  : #if defined( FEATURE_VIRTUAL_ARCHITECTURE_LEVEL )
; 629  : 
; 630  :     /* Set Virtual Architecture Level (Facility List) */
; 631  :     /* SIE guest facilities by default start out same as host's */
; 632  :     memcpy( GUESTREGS->facility_list, HOSTREGS->facility_list, STFL_HERC_BY_SIZE );

  0157c	48 8b 84 24 38
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  01584	48 8b 80 68 08
	00 00		 mov	 rax, QWORD PTR [rax+2152]
  0158b	48 8b 8c 24 38
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  01593	48 8b 89 70 08
	00 00		 mov	 rcx, QWORD PTR [rcx+2160]
  0159a	48 8d b9 28 0d
	00 00		 lea	 rdi, QWORD PTR [rcx+3368]
  015a1	48 8d b0 28 0d
	00 00		 lea	 rsi, QWORD PTR [rax+3368]
  015a8	b9 23 00 00 00	 mov	 ecx, 35			; 00000023H
  015ad	f3 a4		 rep movsb

; 633  : 
; 634  :     /* Fetch address of optional SIE guest facility list designator */
; 635  :     FETCH_FW( fld, STATEBK->fld );

  015af	48 8b 84 24 38
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  015b7	48 8b 80 70 08
	00 00		 mov	 rax, QWORD PTR [rax+2160]
  015be	48 8b 80 88 08
	00 00		 mov	 rax, QWORD PTR [rax+2184]
  015c5	48 05 a0 01 00
	00		 add	 rax, 416		; 000001a0H
  015cb	48 8b c8	 mov	 rcx, rax
  015ce	e8 00 00 00 00	 call	 fetch_fw_noswap
  015d3	8b c8		 mov	 ecx, eax
  015d5	e8 00 00 00 00	 call	 _byteswap_ulong
  015da	89 44 24 74	 mov	 DWORD PTR fld$[rsp], eax

; 636  : 
; 637  :     if (0
; 638  :         || (U64)fld > regs->mainlim /* (beyond end of main storage?)  */
; 639  :         || (fld & ~0x7ffffff8)      /* (above 2GB or not DW aligned?) */

  015de	33 c0		 xor	 eax, eax
  015e0	85 c0		 test	 eax, eax
  015e2	75 22		 jne	 SHORT $LN130@z900_start
  015e4	8b 44 24 74	 mov	 eax, DWORD PTR fld$[rsp]
  015e8	48 8b 8c 24 38
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  015f0	48 3b 81 58 08
	00 00		 cmp	 rax, QWORD PTR [rcx+2136]
  015f7	77 0d		 ja	 SHORT $LN130@z900_start
  015f9	8b 44 24 74	 mov	 eax, DWORD PTR fld$[rsp]
  015fd	25 07 00 00 80	 and	 eax, -2147483641	; 80000007H
  01602	85 c0		 test	 eax, eax
  01604	74 1f		 je	 SHORT $LN129@z900_start
$LN130@z900_start:

; 640  :     )
; 641  :     {
; 642  :         /* ZZ: FIXME
; 643  :         SIE_SET_VI( SIE_VI_WHO_CPU, SIE_VI_WHEN_SIENT, SIE_VI_WHY_??ADR, GUESTREGS );
; 644  :         */
; 645  :         STATEBK->c = SIE_C_VALIDITY;

  01606	48 8b 84 24 38
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0160e	48 8b 80 70 08
	00 00		 mov	 rax, QWORD PTR [rax+2160]
  01615	48 8b 80 88 08
	00 00		 mov	 rax, QWORD PTR [rax+2184]
  0161c	c6 40 50 20	 mov	 BYTE PTR [rax+80], 32	; 00000020H

; 646  :         return;

  01620	e9 47 11 00 00	 jmp	 $LN1@z900_start
$LN129@z900_start:

; 647  :     }
; 648  : 
; 649  :     if (fld)

  01625	83 7c 24 74 00	 cmp	 DWORD PTR fld$[rsp], 0
  0162a	74 4a		 je	 SHORT $LN131@z900_start

; 650  :     {
; 651  :         GUESTREGS->sie_fld = true;

  0162c	48 8b 84 24 38
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  01634	48 8b 80 70 08
	00 00		 mov	 rax, QWORD PTR [rax+2160]
  0163b	c6 80 cc 08 00
	00 01		 mov	 BYTE PTR [rax+2252], 1

; 652  : 
; 653  : #if defined( OPTION_SIE2BK_FLD_COPY)
; 654  : 
; 655  :         /* If a facility list designator was provided
; 656  :            then it defines the SIE guest facility bits.
; 657  :         */
; 658  :         memcpy( GUESTREGS->facility_list, &regs->mainstor[ fld ], STFL_HERC_BY_SIZE );

  01642	8b 44 24 74	 mov	 eax, DWORD PTR fld$[rsp]
  01646	48 8b 8c 24 38
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0164e	48 8b 89 48 08
	00 00		 mov	 rcx, QWORD PTR [rcx+2120]
  01655	48 8b 94 24 38
	01 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  0165d	48 8b 92 70 08
	00 00		 mov	 rdx, QWORD PTR [rdx+2160]
  01664	48 8d ba 28 0d
	00 00		 lea	 rdi, QWORD PTR [rdx+3368]
  0166b	48 8d 34 01	 lea	 rsi, QWORD PTR [rcx+rax]
  0166f	b9 23 00 00 00	 mov	 ecx, 35			; 00000023H
  01674	f3 a4		 rep movsb
$LN131@z900_start:

; 659  : 
; 660  : #else /* !defined( OPTION_SIE2BK_FLD_COPY) */
; 661  : 
; 662  :         /* If a facility list designator was provided
; 663  :            then it's used as a mask to clear the SIE
; 664  :            guest facility bits which shouldn't be on.
; 665  :         */
; 666  :         for (i=0; i < (int) STFL_IBM_BY_SIZE; i++)
; 667  :             GUESTREGS->facility_list[i] &= regs->mainstor[ fld + i ];
; 668  : 
; 669  : #endif /* defined( OPTION_SIE2BK_FLD_COPY) */
; 670  :     }
; 671  : 
; 672  :     /* Prevent certain facility bits from being masked */
; 673  :     BIT_ARRAY_SET( GUESTREGS->facility_list, STFL_001_ZARCH_INSTALLED );

  01676	48 8b 84 24 38
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0167e	48 8b 80 70 08
	00 00		 mov	 rax, QWORD PTR [rax+2160]
  01685	b9 01 00 00 00	 mov	 ecx, 1
  0168a	48 6b c9 00	 imul	 rcx, rcx, 0
  0168e	0f b6 84 08 28
	0d 00 00	 movzx	 eax, BYTE PTR [rax+rcx+3368]
  01696	83 c8 40	 or	 eax, 64			; 00000040H
  01699	b9 01 00 00 00	 mov	 ecx, 1
  0169e	48 6b c9 00	 imul	 rcx, rcx, 0
  016a2	48 8b 94 24 38
	01 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  016aa	48 8b 92 70 08
	00 00		 mov	 rdx, QWORD PTR [rdx+2160]
  016b1	88 84 0a 28 0d
	00 00		 mov	 BYTE PTR [rdx+rcx+3368], al

; 674  : 
; 675  :     if (ARCH_900_IDX == GUESTREGS->arch_mode)

  016b8	48 8b 84 24 38
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  016c0	48 8b 80 70 08
	00 00		 mov	 rax, QWORD PTR [rax+2160]
  016c7	83 78 64 02	 cmp	 DWORD PTR [rax+100], 2
  016cb	75 44		 jne	 SHORT $LN132@z900_start

; 676  :         BIT_ARRAY_SET( GUESTREGS->facility_list, STFL_002_ZARCH_ACTIVE );

  016cd	48 8b 84 24 38
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  016d5	48 8b 80 70 08
	00 00		 mov	 rax, QWORD PTR [rax+2160]
  016dc	b9 01 00 00 00	 mov	 ecx, 1
  016e1	48 6b c9 00	 imul	 rcx, rcx, 0
  016e5	0f b6 84 08 28
	0d 00 00	 movzx	 eax, BYTE PTR [rax+rcx+3368]
  016ed	83 c8 20	 or	 eax, 32			; 00000020H
  016f0	b9 01 00 00 00	 mov	 ecx, 1
  016f5	48 6b c9 00	 imul	 rcx, rcx, 0
  016f9	48 8b 94 24 38
	01 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  01701	48 8b 92 70 08
	00 00		 mov	 rdx, QWORD PTR [rdx+2160]
  01708	88 84 0a 28 0d
	00 00		 mov	 BYTE PTR [rdx+rcx+3368], al
  0170f	eb 42		 jmp	 SHORT $LN133@z900_start
$LN132@z900_start:

; 677  :     else
; 678  :         BIT_ARRAY_CLR( GUESTREGS->facility_list, STFL_002_ZARCH_ACTIVE );

  01711	48 8b 84 24 38
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  01719	48 8b 80 70 08
	00 00		 mov	 rax, QWORD PTR [rax+2160]
  01720	b9 01 00 00 00	 mov	 ecx, 1
  01725	48 6b c9 00	 imul	 rcx, rcx, 0
  01729	0f b6 84 08 28
	0d 00 00	 movzx	 eax, BYTE PTR [rax+rcx+3368]
  01731	83 e0 df	 and	 eax, -33		; ffffffffffffffdfH
  01734	b9 01 00 00 00	 mov	 ecx, 1
  01739	48 6b c9 00	 imul	 rcx, rcx, 0
  0173d	48 8b 94 24 38
	01 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  01745	48 8b 92 70 08
	00 00		 mov	 rdx, QWORD PTR [rdx+2160]
  0174c	88 84 0a 28 0d
	00 00		 mov	 BYTE PTR [rdx+rcx+3368], al
$LN133@z900_start:

; 679  : 
; 680  : #endif /* defined( FEATURE_VIRTUAL_ARCHITECTURE_LEVEL ) */
; 681  : 
; 682  :    /* Reference and Change Preservation (RCP) Origin if high-order
; 683  :       0x80 bit is off. Otherwise (high-order 0x80 bit is on, which
; 684  :       it usually is for VM/ESA and z/VM), then the field ACTUALLY
; 685  :       contains various Execution Control flags such as Storage Key
; 686  :       Assist (SKA), etc.
; 687  :    */
; 688  :     FETCH_FW( GUESTREGS->sie_rcpo, STATEBK->rcpo );

  01753	48 8b 84 24 38
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0175b	48 8b 80 70 08
	00 00		 mov	 rax, QWORD PTR [rax+2160]
  01762	48 8b 80 88 08
	00 00		 mov	 rax, QWORD PTR [rax+2184]
  01769	48 83 c0 60	 add	 rax, 96			; 00000060H
  0176d	48 8b c8	 mov	 rcx, rax
  01770	e8 00 00 00 00	 call	 fetch_fw_noswap
  01775	8b c8		 mov	 ecx, eax
  01777	e8 00 00 00 00	 call	 _byteswap_ulong
  0177c	48 8b 8c 24 38
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  01784	48 8b 89 70 08
	00 00		 mov	 rcx, QWORD PTR [rcx+2160]
  0178b	8b c0		 mov	 eax, eax
  0178d	48 89 81 b0 08
	00 00		 mov	 QWORD PTR [rcx+2224], rax

; 689  : 
; 690  : #if !defined( FEATURE_001_ZARCH_INSTALLED_FACILITY )
; 691  : 
; 692  :     if (!GUESTREGS->sie_rcpo && !GUESTREGS->sie_pref)
; 693  :     {
; 694  :         SIE_SET_VI( SIE_VI_WHO_CPU, SIE_VI_WHEN_SIENT, SIE_VI_WHY_RCZER, GUESTREGS );
; 695  :         STATEBK->c = SIE_C_VALIDITY;
; 696  :         return;
; 697  :     }
; 698  : #endif
; 699  : 
; 700  :     /* Load the CPU timer */
; 701  :     FETCH_DW( dreg, STATEBK->cputimer );

  01794	48 8b 84 24 38
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0179c	48 8b 80 70 08
	00 00		 mov	 rax, QWORD PTR [rax+2160]
  017a3	48 8b 80 88 08
	00 00		 mov	 rax, QWORD PTR [rax+2184]
  017aa	48 83 c0 28	 add	 rax, 40			; 00000028H
  017ae	48 8b c8	 mov	 rcx, rax
  017b1	e8 00 00 00 00	 call	 fetch_dw_noswap
  017b6	48 8b c8	 mov	 rcx, rax
  017b9	e8 00 00 00 00	 call	 _byteswap_uint64
  017be	48 89 84 24 e8
	00 00 00	 mov	 QWORD PTR dreg$[rsp], rax

; 702  :     set_cpu_timer( GUESTREGS, dreg );

  017c6	48 8b 94 24 e8
	00 00 00	 mov	 rdx, QWORD PTR dreg$[rsp]
  017ce	48 8b 84 24 38
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  017d6	48 8b 88 70 08
	00 00		 mov	 rcx, QWORD PTR [rax+2160]
  017dd	e8 00 00 00 00	 call	 set_cpu_timer

; 703  : 
; 704  :     /* Load the TOD clock offset for this guest */
; 705  :     FETCH_DW( GUESTREGS->sie_epoch, STATEBK->epoch );

  017e2	48 8b 84 24 38
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  017ea	48 8b 80 70 08
	00 00		 mov	 rax, QWORD PTR [rax+2160]
  017f1	48 8b 80 88 08
	00 00		 mov	 rax, QWORD PTR [rax+2184]
  017f8	48 83 c0 38	 add	 rax, 56			; 00000038H
  017fc	48 8b c8	 mov	 rcx, rax
  017ff	e8 00 00 00 00	 call	 fetch_dw_noswap
  01804	48 8b c8	 mov	 rcx, rax
  01807	e8 00 00 00 00	 call	 _byteswap_uint64
  0180c	48 8b 8c 24 38
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  01814	48 8b 89 70 08
	00 00		 mov	 rcx, QWORD PTR [rcx+2160]
  0181b	48 89 81 c0 08
	00 00		 mov	 QWORD PTR [rcx+2240], rax

; 706  :     GUESTREGS->tod_epoch = regs->tod_epoch + TOD_high64_to_ETOD_high56( GUESTREGS->sie_epoch );

  01822	48 8b 84 24 38
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0182a	48 8b 80 70 08
	00 00		 mov	 rax, QWORD PTR [rax+2160]
  01831	48 8b 88 c0 08
	00 00		 mov	 rcx, QWORD PTR [rax+2240]
  01838	e8 00 00 00 00	 call	 TOD_high64_to_ETOD_high56
  0183d	48 8b 8c 24 38
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  01845	48 03 81 40 07
	00 00		 add	 rax, QWORD PTR [rcx+1856]
  0184c	48 8b 8c 24 38
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  01854	48 8b 89 70 08
	00 00		 mov	 rcx, QWORD PTR [rcx+2160]
  0185b	48 89 81 40 07
	00 00		 mov	 QWORD PTR [rcx+1856], rax

; 707  : 
; 708  :     /* Load the clock comparator */
; 709  :     FETCH_DW( GUESTREGS->clkc, STATEBK->clockcomp );

  01862	48 8b 84 24 38
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0186a	48 8b 80 70 08
	00 00		 mov	 rax, QWORD PTR [rax+2160]
  01871	48 8b 80 88 08
	00 00		 mov	 rax, QWORD PTR [rax+2184]
  01878	48 83 c0 30	 add	 rax, 48			; 00000030H
  0187c	48 8b c8	 mov	 rcx, rax
  0187f	e8 00 00 00 00	 call	 fetch_dw_noswap
  01884	48 8b c8	 mov	 rcx, rax
  01887	e8 00 00 00 00	 call	 _byteswap_uint64
  0188c	48 8b 8c 24 38
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  01894	48 8b 89 70 08
	00 00		 mov	 rcx, QWORD PTR [rcx+2160]
  0189b	48 89 81 48 07
	00 00		 mov	 QWORD PTR [rcx+1864], rax

; 710  :     GUESTREGS->clkc = TOD_high64_to_ETOD_high56( GUESTREGS->clkc );  /* Internal Hercules format */

  018a2	48 8b 84 24 38
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  018aa	48 8b 80 70 08
	00 00		 mov	 rax, QWORD PTR [rax+2160]
  018b1	48 8b 88 48 07
	00 00		 mov	 rcx, QWORD PTR [rax+1864]
  018b8	e8 00 00 00 00	 call	 TOD_high64_to_ETOD_high56
  018bd	48 8b 8c 24 38
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  018c5	48 8b 89 70 08
	00 00		 mov	 rcx, QWORD PTR [rcx+2160]
  018cc	48 89 81 48 07
	00 00		 mov	 QWORD PTR [rcx+1864], rax

; 711  : 
; 712  :     /* Load TOD Programmable Field */
; 713  :     FETCH_HW( GUESTREGS->todpr, STATEBK->todpf );

  018d3	48 8b 84 24 38
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  018db	48 8b 80 70 08
	00 00		 mov	 rax, QWORD PTR [rax+2160]
  018e2	48 8b 80 88 08
	00 00		 mov	 rax, QWORD PTR [rax+2184]
  018e9	48 83 c0 6e	 add	 rax, 110		; 0000006eH
  018ed	48 8b c8	 mov	 rcx, rax
  018f0	e8 00 00 00 00	 call	 fetch_hw_noswap
  018f5	0f b7 c8	 movzx	 ecx, ax
  018f8	e8 00 00 00 00	 call	 _byteswap_ushort
  018fd	48 8b 8c 24 38
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  01905	48 8b 89 70 08
	00 00		 mov	 rcx, QWORD PTR [rcx+2160]
  0190c	0f b7 c0	 movzx	 eax, ax
  0190f	89 81 58 07 00
	00		 mov	 DWORD PTR [rcx+1880], eax

; 714  : 
; 715  :     /* Load the guest registers */
; 716  :     memcpy( GUESTREGS->gr,  regs->gr,  14 * sizeof( regs->gr [0] ));

  01915	48 8b 84 24 38
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0191d	48 8b 80 70 08
	00 00		 mov	 rax, QWORD PTR [rax+2160]
  01924	48 8b 8c 24 38
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0192c	48 8d b8 80 02
	00 00		 lea	 rdi, QWORD PTR [rax+640]
  01933	48 8d b1 80 02
	00 00		 lea	 rsi, QWORD PTR [rcx+640]
  0193a	b9 70 00 00 00	 mov	 ecx, 112		; 00000070H
  0193f	f3 a4		 rep movsb

; 717  :     memcpy( GUESTREGS->ar,  regs->ar,  16 * sizeof( regs->ar [0] ));

  01941	48 8b 84 24 38
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  01949	48 8b 80 70 08
	00 00		 mov	 rax, QWORD PTR [rax+2160]
  01950	48 8b 8c 24 38
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  01958	48 8d b8 00 03
	00 00		 lea	 rdi, QWORD PTR [rax+768]
  0195f	48 8d b1 00 03
	00 00		 lea	 rsi, QWORD PTR [rcx+768]
  01966	b9 40 00 00 00	 mov	 ecx, 64			; 00000040H
  0196b	f3 a4		 rep movsb

; 718  :     memcpy( GUESTREGS->fpr, regs->fpr, 32 * sizeof( regs->fpr[0] ));

  0196d	48 8b 84 24 38
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  01975	48 8b 80 70 08
	00 00		 mov	 rax, QWORD PTR [rax+2160]
  0197c	48 8b 8c 24 38
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  01984	48 8d b8 40 03
	00 00		 lea	 rdi, QWORD PTR [rax+832]
  0198b	48 8d b1 40 03
	00 00		 lea	 rsi, QWORD PTR [rcx+832]
  01992	b9 80 00 00 00	 mov	 ecx, 128		; 00000080H
  01997	f3 a4		 rep movsb

; 719  : #if defined( FEATURE_BINARY_FLOATING_POINT )
; 720  :     GUESTREGS->fpc =  regs->fpc;

  01999	48 8b 84 24 38
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  019a1	48 8b 80 70 08
	00 00		 mov	 rax, QWORD PTR [rax+2160]
  019a8	48 8b 8c 24 38
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  019b0	8b 89 c0 03 00
	00		 mov	 ecx, DWORD PTR [rcx+960]
  019b6	89 88 c0 03 00
	00		 mov	 DWORD PTR [rax+960], ecx

; 721  : #endif
; 722  : 
; 723  :     /* Load GR14 and GR15 */
; 724  :     FETCH_W( GUESTREGS->GR(14), STATEBK->gr14 );

  019bc	48 8b 84 24 38
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  019c4	48 8b 80 70 08
	00 00		 mov	 rax, QWORD PTR [rax+2160]
  019cb	48 8b 80 88 08
	00 00		 mov	 rax, QWORD PTR [rax+2184]
  019d2	48 05 a0 00 00
	00		 add	 rax, 160		; 000000a0H
  019d8	48 8b c8	 mov	 rcx, rax
  019db	e8 00 00 00 00	 call	 fetch_dw_noswap
  019e0	48 8b c8	 mov	 rcx, rax
  019e3	e8 00 00 00 00	 call	 _byteswap_uint64
  019e8	48 8b 8c 24 38
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  019f0	48 8b 89 70 08
	00 00		 mov	 rcx, QWORD PTR [rcx+2160]
  019f7	ba 08 00 00 00	 mov	 edx, 8
  019fc	48 6b d2 0e	 imul	 rdx, rdx, 14
  01a00	48 89 84 11 80
	02 00 00	 mov	 QWORD PTR [rcx+rdx+640], rax

; 725  :     FETCH_W( GUESTREGS->GR(15), STATEBK->gr15 );

  01a08	48 8b 84 24 38
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  01a10	48 8b 80 70 08
	00 00		 mov	 rax, QWORD PTR [rax+2160]
  01a17	48 8b 80 88 08
	00 00		 mov	 rax, QWORD PTR [rax+2184]
  01a1e	48 05 a8 00 00
	00		 add	 rax, 168		; 000000a8H
  01a24	48 8b c8	 mov	 rcx, rax
  01a27	e8 00 00 00 00	 call	 fetch_dw_noswap
  01a2c	48 8b c8	 mov	 rcx, rax
  01a2f	e8 00 00 00 00	 call	 _byteswap_uint64
  01a34	48 8b 8c 24 38
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  01a3c	48 8b 89 70 08
	00 00		 mov	 rcx, QWORD PTR [rcx+2160]
  01a43	ba 08 00 00 00	 mov	 edx, 8
  01a48	48 6b d2 0f	 imul	 rdx, rdx, 15
  01a4c	48 89 84 11 80
	02 00 00	 mov	 QWORD PTR [rcx+rdx+640], rax

; 726  : 
; 727  :     /* Load control registers */
; 728  :     for (n=0; n < 16; n++)

  01a54	c7 44 24 70 00
	00 00 00	 mov	 DWORD PTR n$[rsp], 0
  01a5c	eb 0a		 jmp	 SHORT $LN49@z900_start
$LN47@z900_start:
  01a5e	8b 44 24 70	 mov	 eax, DWORD PTR n$[rsp]
  01a62	ff c0		 inc	 eax
  01a64	89 44 24 70	 mov	 DWORD PTR n$[rsp], eax
$LN49@z900_start:
  01a68	83 7c 24 70 10	 cmp	 DWORD PTR n$[rsp], 16
  01a6d	7d 55		 jge	 SHORT $LN48@z900_start

; 729  :         FETCH_W( GUESTREGS->CR( n ), STATEBK->cr[ n ]);

  01a6f	48 8b 84 24 38
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  01a77	48 8b 80 70 08
	00 00		 mov	 rax, QWORD PTR [rax+2160]
  01a7e	48 8b 80 88 08
	00 00		 mov	 rax, QWORD PTR [rax+2184]
  01a85	48 63 4c 24 70	 movsxd	 rcx, DWORD PTR n$[rsp]
  01a8a	48 8d 84 c8 00
	01 00 00	 lea	 rax, QWORD PTR [rax+rcx*8+256]
  01a92	48 8b c8	 mov	 rcx, rax
  01a95	e8 00 00 00 00	 call	 fetch_dw_noswap
  01a9a	48 8b c8	 mov	 rcx, rax
  01a9d	e8 00 00 00 00	 call	 _byteswap_uint64
  01aa2	48 8b 8c 24 38
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  01aaa	48 8b 89 70 08
	00 00		 mov	 rcx, QWORD PTR [rcx+2160]
  01ab1	8b 54 24 70	 mov	 edx, DWORD PTR n$[rsp]
  01ab5	ff c2		 inc	 edx
  01ab7	48 63 d2	 movsxd	 rdx, edx
  01aba	48 89 84 d1 00
	06 00 00	 mov	 QWORD PTR [rcx+rdx*8+1536], rax
  01ac2	eb 9a		 jmp	 SHORT $LN47@z900_start
$LN48@z900_start:

; 730  : 
; 731  :     /* Remember whether CPU or state is different from last time */
; 732  :     FETCH_HW( lhcpu, STATEBK->lhcpu );

  01ac4	48 8b 84 24 38
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  01acc	48 8b 80 70 08
	00 00		 mov	 rax, QWORD PTR [rax+2160]
  01ad3	48 8b 80 88 08
	00 00		 mov	 rax, QWORD PTR [rax+2184]
  01ada	48 83 c0 52	 add	 rax, 82			; 00000052H
  01ade	48 8b c8	 mov	 rcx, rax
  01ae1	e8 00 00 00 00	 call	 fetch_hw_noswap
  01ae6	0f b7 c8	 movzx	 ecx, ax
  01ae9	e8 00 00 00 00	 call	 _byteswap_ushort
  01aee	66 89 84 24 80
	00 00 00	 mov	 WORD PTR lhcpu$[rsp], ax

; 733  :     sie_state = SIE_STATE( GUESTREGS );

  01af6	48 8b 84 24 38
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  01afe	48 8b 80 70 08
	00 00		 mov	 rax, QWORD PTR [rax+2160]
  01b05	48 8b 80 80 08
	00 00		 mov	 rax, QWORD PTR [rax+2176]
  01b0c	48 89 84 24 f0
	00 00 00	 mov	 QWORD PTR sie_state$[rsp], rax

; 734  : 
; 735  :     same_cpu   = (regs->cpuad == lhcpu);

  01b14	48 8b 84 24 38
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  01b1c	0f b7 80 3c 08
	00 00		 movzx	 eax, WORD PTR [rax+2108]
  01b23	0f b7 8c 24 80
	00 00 00	 movzx	 ecx, WORD PTR lhcpu$[rsp]
  01b2b	3b c1		 cmp	 eax, ecx
  01b2d	75 0d		 jne	 SHORT $LN163@z900_start
  01b2f	c7 84 24 a0 00
	00 00 01 00 00
	00		 mov	 DWORD PTR tv1035[rsp], 1
  01b3a	eb 0b		 jmp	 SHORT $LN164@z900_start
$LN163@z900_start:
  01b3c	c7 84 24 a0 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv1035[rsp], 0
$LN164@z900_start:
  01b47	83 bc 24 a0 00
	00 00 00	 cmp	 DWORD PTR tv1035[rsp], 0
  01b4f	75 0d		 jne	 SHORT $LN165@z900_start
  01b51	c7 84 24 a4 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv1037[rsp], 0
  01b5c	eb 0b		 jmp	 SHORT $LN166@z900_start
$LN165@z900_start:
  01b5e	c7 84 24 a4 00
	00 00 01 00 00
	00		 mov	 DWORD PTR tv1037[rsp], 1
$LN166@z900_start:
  01b69	0f b6 84 24 a4
	00 00 00	 movzx	 eax, BYTE PTR tv1037[rsp]
  01b71	88 44 24 7c	 mov	 BYTE PTR same_cpu$[rsp], al

; 736  :     same_state = (effective_addr2 == sie_state);

  01b75	48 8b 84 24 f0
	00 00 00	 mov	 rax, QWORD PTR sie_state$[rsp]
  01b7d	48 39 44 24 68	 cmp	 QWORD PTR effective_addr2$[rsp], rax
  01b82	75 0d		 jne	 SHORT $LN167@z900_start
  01b84	c7 84 24 a8 00
	00 00 01 00 00
	00		 mov	 DWORD PTR tv1040[rsp], 1
  01b8f	eb 0b		 jmp	 SHORT $LN168@z900_start
$LN167@z900_start:
  01b91	c7 84 24 a8 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv1040[rsp], 0
$LN168@z900_start:
  01b9c	83 bc 24 a8 00
	00 00 00	 cmp	 DWORD PTR tv1040[rsp], 0
  01ba4	75 0d		 jne	 SHORT $LN169@z900_start
  01ba6	c7 84 24 ac 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv1042[rsp], 0
  01bb1	eb 0b		 jmp	 SHORT $LN170@z900_start
$LN169@z900_start:
  01bb3	c7 84 24 ac 00
	00 00 01 00 00
	00		 mov	 DWORD PTR tv1042[rsp], 1
$LN170@z900_start:
  01bbe	0f b6 84 24 ac
	00 00 00	 movzx	 eax, BYTE PTR tv1042[rsp]
  01bc6	88 44 24 7d	 mov	 BYTE PTR same_state$[rsp], al

; 737  : 
; 738  :     /* Regardless, set both of them to their proper current value */
; 739  :     SIE_STATE( GUESTREGS ) = effective_addr2;

  01bca	48 8b 84 24 38
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  01bd2	48 8b 80 70 08
	00 00		 mov	 rax, QWORD PTR [rax+2160]
  01bd9	48 8b 4c 24 68	 mov	 rcx, QWORD PTR effective_addr2$[rsp]
  01bde	48 89 88 80 08
	00 00		 mov	 QWORD PTR [rax+2176], rcx

; 740  :     STORE_HW( STATEBK->lhcpu, regs->cpuad );

  01be5	48 8b 84 24 38
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  01bed	0f b7 88 3c 08
	00 00		 movzx	 ecx, WORD PTR [rax+2108]
  01bf4	e8 00 00 00 00	 call	 _byteswap_ushort
  01bf9	48 8b 8c 24 38
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  01c01	48 8b 89 70 08
	00 00		 mov	 rcx, QWORD PTR [rcx+2160]
  01c08	48 8b 89 88 08
	00 00		 mov	 rcx, QWORD PTR [rcx+2184]
  01c0f	48 83 c1 52	 add	 rcx, 82			; 00000052H
  01c13	0f b7 d0	 movzx	 edx, ax
  01c16	e8 00 00 00 00	 call	 store_hw_noswap

; 741  : 
; 742  :     /*----------------------------------------*/
; 743  :     /* Maybe purge the guest's TLB/ALB or not */
; 744  :     /*----------------------------------------*/
; 745  : #if !defined( OPTION_SIE_PURGE_DAT_ALWAYS )
; 746  :     /*
; 747  :      *   If this is not the same last host cpu that dispatched
; 748  :      *   this state descriptor then clear the guest TLB entries.
; 749  :      */
; 750  :     if (!same_cpu || !same_state)
; 751  :     {
; 752  :         SIE_PERFMON( SIE_PERF_ENTER_F );
; 753  : 
; 754  :         /* Purge guest TLB entries */
; 755  : 
; 756  :         switch (GUESTREGS->arch_mode)
; 757  :         {
; 758  :         case ARCH_370_IDX: s370_purge_tlb( GUESTREGS );                              break;
; 759  :         case ARCH_390_IDX: s390_purge_tlb( GUESTREGS ); s390_purge_alb( GUESTREGS ); break;
; 760  :         case ARCH_900_IDX: z900_purge_tlb( GUESTREGS ); z900_purge_alb( GUESTREGS ); break;
; 761  :         default: CRASH();
; 762  :         }
; 763  :     }
; 764  : #else // defined( OPTION_SIE_PURGE_DAT_ALWAYS )
; 765  :     /*
; 766  :      *   ALWAYS purge guest TLB entries (Ivan 2016-07-30)
; 767  :      */
; 768  :     switch (GUESTREGS->arch_mode)

  01c1b	48 8b 84 24 38
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  01c23	48 8b 80 70 08
	00 00		 mov	 rax, QWORD PTR [rax+2160]
  01c2a	8b 40 64	 mov	 eax, DWORD PTR [rax+100]
  01c2d	89 84 24 88 00
	00 00		 mov	 DWORD PTR tv1056[rsp], eax
  01c34	83 bc 24 88 00
	00 00 00	 cmp	 DWORD PTR tv1056[rsp], 0
  01c3c	74 16		 je	 SHORT $LN134@z900_start
  01c3e	83 bc 24 88 00
	00 00 01	 cmp	 DWORD PTR tv1056[rsp], 1
  01c46	74 22		 je	 SHORT $LN135@z900_start
  01c48	83 bc 24 88 00
	00 00 02	 cmp	 DWORD PTR tv1056[rsp], 2
  01c50	74 42		 je	 SHORT $LN136@z900_start
  01c52	eb 6a		 jmp	 SHORT $LN137@z900_start
$LN134@z900_start:

; 769  :     {
; 770  :     case ARCH_370_IDX: s370_purge_tlb( GUESTREGS );                              break;

  01c54	48 8b 84 24 38
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  01c5c	48 8b 88 70 08
	00 00		 mov	 rcx, QWORD PTR [rax+2160]
  01c63	e8 00 00 00 00	 call	 s370_purge_tlb
  01c68	eb 71		 jmp	 SHORT $LN50@z900_start
$LN135@z900_start:

; 771  :     case ARCH_390_IDX: s390_purge_tlb( GUESTREGS ); s390_purge_alb( GUESTREGS ); break;

  01c6a	48 8b 84 24 38
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  01c72	48 8b 88 70 08
	00 00		 mov	 rcx, QWORD PTR [rax+2160]
  01c79	e8 00 00 00 00	 call	 s390_purge_tlb
  01c7e	48 8b 84 24 38
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  01c86	48 8b 88 70 08
	00 00		 mov	 rcx, QWORD PTR [rax+2160]
  01c8d	e8 00 00 00 00	 call	 s390_purge_alb
  01c92	eb 47		 jmp	 SHORT $LN50@z900_start
$LN136@z900_start:

; 772  :     case ARCH_900_IDX: z900_purge_tlb( GUESTREGS ); z900_purge_alb( GUESTREGS ); break;

  01c94	48 8b 84 24 38
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  01c9c	48 8b 88 70 08
	00 00		 mov	 rcx, QWORD PTR [rax+2160]
  01ca3	e8 00 00 00 00	 call	 z900_purge_tlb
  01ca8	48 8b 84 24 38
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  01cb0	48 8b 88 70 08
	00 00		 mov	 rcx, QWORD PTR [rax+2160]
  01cb7	e8 00 00 00 00	 call	 z900_purge_alb
  01cbc	eb 1d		 jmp	 SHORT $LN50@z900_start
$LN137@z900_start:
$LN54@z900_start:

; 773  :     default: CRASH();

  01cbe	48 c7 84 24 f8
	00 00 00 00 00
	00 00		 mov	 QWORD PTR p$7[rsp], 0
  01cca	48 8b 84 24 f8
	00 00 00	 mov	 rax, QWORD PTR p$7[rsp]
  01cd2	c6 00 00	 mov	 BYTE PTR [rax], 0
  01cd5	33 c0		 xor	 eax, eax
  01cd7	85 c0		 test	 eax, eax
  01cd9	75 e3		 jne	 SHORT $LN54@z900_start
$LN50@z900_start:

; 774  :     }
; 775  : #endif // defined( OPTION_SIE_PURGE_DAT_ALWAYS )
; 776  : 
; 777  :     /* Initialize interrupt mask and state */
; 778  :     ARCH_DEP( set_guest_ic_mask )( GUESTREGS );

  01cdb	48 8b 84 24 38
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  01ce3	48 8b 88 70 08
	00 00		 mov	 rcx, QWORD PTR [rax+2160]
  01cea	e8 00 00 00 00	 call	 z900_set_guest_ic_mask

; 779  :     SET_IC_INITIAL_STATE( GUESTREGS );

  01cef	48 8b 84 24 38
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  01cf7	48 8b 80 70 08
	00 00		 mov	 rax, QWORD PTR [rax+2160]
  01cfe	c7 40 48 01 00
	00 00		 mov	 DWORD PTR [rax+72], 1
$LN57@z900_start:

; 780  :     SET_IC_PER( GUESTREGS );

  01d05	48 8b 84 24 38
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  01d0d	48 8b 80 70 08
	00 00		 mov	 rax, QWORD PTR [rax+2160]
  01d14	8b 40 48	 mov	 eax, DWORD PTR [rax+72]
  01d17	25 ff ff 00 ff	 and	 eax, -16711681		; ff00ffffH
  01d1c	48 8b 8c 24 38
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  01d24	48 8b 89 70 08
	00 00		 mov	 rcx, QWORD PTR [rcx+2160]
  01d2b	89 41 48	 mov	 DWORD PTR [rcx+72], eax
  01d2e	48 8b 84 24 38
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  01d36	48 8b 80 70 08
	00 00		 mov	 rax, QWORD PTR [rax+2160]
  01d3d	48 8b 8c 24 38
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  01d45	48 8b 89 70 08
	00 00		 mov	 rcx, QWORD PTR [rcx+2160]
  01d4c	ba 08 00 00 00	 mov	 edx, 8
  01d51	48 6b d2 0a	 imul	 rdx, rdx, 10
  01d55	48 8b 8c 11 00
	06 00 00	 mov	 rcx, QWORD PTR [rcx+rdx+1536]
  01d5d	48 c1 e9 08	 shr	 rcx, 8
  01d61	48 81 e1 00 00
	ff 00		 and	 rcx, 16711680		; 00ff0000H
  01d68	8b 40 48	 mov	 eax, DWORD PTR [rax+72]
  01d6b	48 0b c1	 or	 rax, rcx
  01d6e	48 8b 8c 24 38
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  01d76	48 8b 89 70 08
	00 00		 mov	 rcx, QWORD PTR [rcx+2160]
  01d7d	89 41 48	 mov	 DWORD PTR [rcx+72], eax
  01d80	48 8b 84 24 38
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  01d88	48 8b 80 70 08
	00 00		 mov	 rax, QWORD PTR [rax+2160]
  01d8f	48 8b 8c 24 38
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  01d97	48 8b 89 70 08
	00 00		 mov	 rcx, QWORD PTR [rcx+2160]
  01d9e	8b 49 48	 mov	 ecx, DWORD PTR [rcx+72]
  01da1	81 c9 ff ff 00
	ff		 or	 ecx, -16711681		; ff00ffffH
  01da7	8b 40 4c	 mov	 eax, DWORD PTR [rax+76]
  01daa	23 c1		 and	 eax, ecx
  01dac	48 8b 8c 24 38
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  01db4	48 8b 89 70 08
	00 00		 mov	 rcx, QWORD PTR [rcx+2160]
  01dbb	89 41 4c	 mov	 DWORD PTR [rcx+76], eax
  01dbe	33 c0		 xor	 eax, eax
  01dc0	85 c0		 test	 eax, eax
  01dc2	0f 85 3d ff ff
	ff		 jne	 $LN57@z900_start

; 781  : 
; 782  :     /* Initialize accelerated address lookup values */
; 783  :     ARCH_DEP( set_guest_aea_mode   )( GUESTREGS );

  01dc8	48 8b 84 24 38
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  01dd0	48 8b 88 70 08
	00 00		 mov	 rcx, QWORD PTR [rax+2160]
  01dd7	e8 00 00 00 00	 call	 z900_set_guest_aea_mode

; 784  :     ARCH_DEP( set_guest_aea_common )( GUESTREGS );

  01ddc	48 8b 84 24 38
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  01de4	48 8b 88 70 08
	00 00		 mov	 rcx, QWORD PTR [rax+2160]
  01deb	e8 00 00 00 00	 call	 z900_set_guest_aea_common

; 785  :     ARCH_DEP( invalidate_guest_aia )( GUESTREGS );

  01df0	48 8b 84 24 38
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  01df8	48 8b 88 70 08
	00 00		 mov	 rcx, QWORD PTR [rax+2160]
  01dff	e8 00 00 00 00	 call	 z900_invalidate_guest_aia

; 786  : 
; 787  :     GUESTREGS->breakortrace = regs->breakortrace;

  01e04	48 8b 84 24 38
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  01e0c	8b 80 28 07 00
	00		 mov	 eax, DWORD PTR [rax+1832]
  01e12	c1 e8 10	 shr	 eax, 16
  01e15	83 e0 01	 and	 eax, 1
  01e18	48 8b 8c 24 38
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  01e20	48 8b 89 70 08
	00 00		 mov	 rcx, QWORD PTR [rcx+2160]
  01e27	83 e0 01	 and	 eax, 1
  01e2a	c1 e0 10	 shl	 eax, 16
  01e2d	8b 89 28 07 00
	00		 mov	 ecx, DWORD PTR [rcx+1832]
  01e33	0f ba f1 10	 btr	 ecx, 16
  01e37	0b c8		 or	 ecx, eax
  01e39	8b c1		 mov	 eax, ecx
  01e3b	48 8b 8c 24 38
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  01e43	48 8b 89 70 08
	00 00		 mov	 rcx, QWORD PTR [rcx+2160]
  01e4a	89 81 28 07 00
	00		 mov	 DWORD PTR [rcx+1832], eax

; 788  : 
; 789  :     /* Must do setjmp(progjmp) here since the 'translate_addr' further
; 790  :        below may result in longjmp(progjmp) for addressing exceptions.
; 791  :     */
; 792  :     if (!(icode = setjmp( GUESTREGS->progjmp )))

  01e50	48 8b 84 24 38
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  01e58	48 8b 80 70 08
	00 00		 mov	 rax, QWORD PTR [rax+2160]
  01e5f	48 05 80 09 00
	00		 add	 rax, 2432		; 00000980H
  01e65	48 8b c8	 mov	 rcx, rax
  01e68	48 8b d4	 mov	 rdx, rsp
  01e6b	e8 00 00 00 00	 call	 _setjmp
  01e70	89 44 24 60	 mov	 DWORD PTR icode$[rsp], eax
  01e74	8b 44 24 60	 mov	 eax, DWORD PTR icode$[rsp]
  01e78	85 c0		 test	 eax, eax
  01e7a	0f 85 be 07 00
	00		 jne	 $LN138@z900_start
$LN60@z900_start:

; 793  :     {
; 794  :         /*
; 795  :          * Set sie_active to 1. This means other threads
; 796  :          * may now access guestregs when holding intlock.
; 797  :          * This is the *ONLY* place sie_active is set to 1!
; 798  :          */
; 799  :         PTT_SIE( "SIE a=1", 0, 0, 0 );

  01e80	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_pttclass
  01e87	48 8b 00	 mov	 rax, QWORD PTR [rax]
  01e8a	48 25 80 00 00
	00		 and	 rax, 128		; 00000080H
  01e90	48 85 c0	 test	 rax, rax
  01e93	74 36		 je	 SHORT $LN139@z900_start
  01e95	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR [rsp+48], 0
  01e9e	48 c7 44 24 28
	00 00 00 00	 mov	 QWORD PTR [rsp+40], 0
  01ea7	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG194903
  01eae	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  01eb3	45 33 c9	 xor	 r9d, r9d
  01eb6	45 33 c0	 xor	 r8d, r8d
  01eb9	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG194904
  01ec0	b9 80 00 00 00	 mov	 ecx, 128		; 00000080H
  01ec5	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ptt_pthread_trace
$LN139@z900_start:
  01ecb	33 c0		 xor	 eax, eax
  01ecd	85 c0		 test	 eax, eax
  01ecf	75 af		 jne	 SHORT $LN60@z900_start

; 800  :         OBTAIN_INTLOCK( regs );

  01ed1	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG194905
  01ed8	48 8b 8c 24 38
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  01ee0	e8 00 00 00 00	 call	 Obtain_Interrupt_Lock

; 801  :         {
; 802  :             regs->sie_active = 1;

  01ee5	48 8b 84 24 38
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  01eed	8b 80 c8 08 00
	00		 mov	 eax, DWORD PTR [rax+2248]
  01ef3	83 c8 01	 or	 eax, 1
  01ef6	48 8b 8c 24 38
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  01efe	89 81 c8 08 00
	00		 mov	 DWORD PTR [rcx+2248], eax

; 803  :         }
; 804  :         RELEASE_INTLOCK( regs );

  01f04	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG194906
  01f0b	48 8b 8c 24 38
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  01f13	e8 00 00 00 00	 call	 Release_Interrupt_Lock

; 805  : 
; 806  :         /* Get PSA pointer and ensure PSA is paged in */
; 807  :         if (GUESTREGS->sie_pref)

  01f18	48 8b 84 24 38
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  01f20	48 8b 80 70 08
	00 00		 mov	 rax, QWORD PTR [rax+2160]
  01f27	8b 80 c8 08 00
	00		 mov	 eax, DWORD PTR [rax+2248]
  01f2d	c1 e8 02	 shr	 eax, 2
  01f30	83 e0 01	 and	 eax, 1
  01f33	85 c0		 test	 eax, eax
  01f35	74 6d		 je	 SHORT $LN140@z900_start

; 808  :         {
; 809  :             GUESTREGS->psa = (PSA_3XX*)(GUESTREGS->mainstor + GUESTREGS->PX);

  01f37	48 8b 84 24 38
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  01f3f	48 8b 80 70 08
	00 00		 mov	 rax, QWORD PTR [rax+2160]
  01f46	48 8b 8c 24 38
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  01f4e	48 8b 89 70 08
	00 00		 mov	 rcx, QWORD PTR [rcx+2160]
  01f55	48 8b 80 48 08
	00 00		 mov	 rax, QWORD PTR [rax+2120]
  01f5c	48 03 41 70	 add	 rax, QWORD PTR [rcx+112]
  01f60	48 8b 8c 24 38
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  01f68	48 8b 89 70 08
	00 00		 mov	 rcx, QWORD PTR [rcx+2160]
  01f6f	48 89 81 60 08
	00 00		 mov	 QWORD PTR [rcx+2144], rax

; 810  :             GUESTREGS->sie_px = GUESTREGS->PX;

  01f76	48 8b 84 24 38
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  01f7e	48 8b 80 70 08
	00 00		 mov	 rax, QWORD PTR [rax+2160]
  01f85	48 8b 8c 24 38
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  01f8d	48 8b 89 70 08
	00 00		 mov	 rcx, QWORD PTR [rcx+2160]
  01f94	48 8b 40 70	 mov	 rax, QWORD PTR [rax+112]
  01f98	48 89 81 90 08
	00 00		 mov	 QWORD PTR [rcx+2192], rax

; 811  :         }

  01f9f	e9 b3 03 00 00	 jmp	 $LN141@z900_start
$LN140@z900_start:

; 812  :         else
; 813  :         {
; 814  :             /* NOTE: longjmp(progjmp) for addressing exception is possible
; 815  :                here. Thus the need for doing setjmp(progjmp) further above.
; 816  :             */
; 817  :             /* Translate where this SIE guest's absolute storage begins
; 818  :                (which is a host virtual address) to a host real address.
; 819  :             */
; 820  :             if (ARCH_DEP( translate_addr )( GUESTREGS->sie_mso + GUESTREGS->PX,

  01fa4	48 8b 84 24 38
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  01fac	48 8b 80 70 08
	00 00		 mov	 rax, QWORD PTR [rax+2160]
  01fb3	48 8b 8c 24 38
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  01fbb	48 8b 89 70 08
	00 00		 mov	 rcx, QWORD PTR [rcx+2160]
  01fc2	48 8b 80 98 08
	00 00		 mov	 rax, QWORD PTR [rax+2200]
  01fc9	48 03 41 70	 add	 rax, QWORD PTR [rcx+112]
  01fcd	45 33 c9	 xor	 r9d, r9d
  01fd0	4c 8b 84 24 38
	01 00 00	 mov	 r8, QWORD PTR regs$[rsp]
  01fd8	ba fd ff ff ff	 mov	 edx, -3
  01fdd	48 8b c8	 mov	 rcx, rax
  01fe0	e8 00 00 00 00	 call	 z900_translate_addr
  01fe5	85 c0		 test	 eax, eax
  01fe7	0f 84 5a 01 00
	00		 je	 $LN142@z900_start
$LN63@z900_start:

; 821  :                                             USE_PRIMARY_SPACE, regs, ACCTYPE_SIE ))
; 822  :             {
; 823  :                 SIE_SET_VI( SIE_VI_WHO_CPU, SIE_VI_WHEN_SIENT, SIE_VI_WHY_PFACC, GUESTREGS );

  01fed	48 8b 84 24 38
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  01ff5	48 8b 80 70 08
	00 00		 mov	 rax, QWORD PTR [rax+2160]
  01ffc	48 8b 80 88 08
	00 00		 mov	 rax, QWORD PTR [rax+2184]
  02003	b9 01 00 00 00	 mov	 ecx, 1
  02008	48 6b c9 00	 imul	 rcx, rcx, 0
  0200c	c6 44 08 56 01	 mov	 BYTE PTR [rax+rcx+86], 1
  02011	48 8b 84 24 38
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  02019	48 8b 80 70 08
	00 00		 mov	 rax, QWORD PTR [rax+2160]
  02020	48 8b 80 88 08
	00 00		 mov	 rax, QWORD PTR [rax+2184]
  02027	b9 01 00 00 00	 mov	 ecx, 1
  0202c	48 6b c9 01	 imul	 rcx, rcx, 1
  02030	c6 44 08 56 10	 mov	 BYTE PTR [rax+rcx+86], 16
  02035	66 b9 37 00	 mov	 cx, 55			; 00000037H
  02039	e8 00 00 00 00	 call	 _byteswap_ushort
  0203e	48 8b 8c 24 38
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  02046	48 8b 89 70 08
	00 00		 mov	 rcx, QWORD PTR [rcx+2160]
  0204d	48 8b 89 88 08
	00 00		 mov	 rcx, QWORD PTR [rcx+2184]
  02054	48 83 c1 58	 add	 rcx, 88			; 00000058H
  02058	0f b7 d0	 movzx	 edx, ax
  0205b	e8 00 00 00 00	 call	 store_hw_noswap
  02060	48 8b 84 24 38
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  02068	48 8b 80 70 08
	00 00		 mov	 rax, QWORD PTR [rax+2160]
  0206f	48 8b 80 88 08
	00 00		 mov	 rax, QWORD PTR [rax+2184]
  02076	48 83 c0 5a	 add	 rax, 90			; 0000005aH
  0207a	48 8b f8	 mov	 rdi, rax
  0207d	33 c0		 xor	 eax, eax
  0207f	b9 06 00 00 00	 mov	 ecx, 6
  02084	f3 aa		 rep stosb
  02086	33 c0		 xor	 eax, eax
  02088	85 c0		 test	 eax, eax
  0208a	0f 85 5d ff ff
	ff		 jne	 $LN63@z900_start

; 824  :                 STATEBK->c = SIE_C_VALIDITY;

  02090	48 8b 84 24 38
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  02098	48 8b 80 70 08
	00 00		 mov	 rax, QWORD PTR [rax+2160]
  0209f	48 8b 80 88 08
	00 00		 mov	 rax, QWORD PTR [rax+2184]
  020a6	c6 40 50 20	 mov	 BYTE PTR [rax+80], 32	; 00000020H
$LN66@z900_start:

; 825  : 
; 826  :                 PTT_SIE( "SIE a=0", 0, 0, 0 );

  020aa	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_pttclass
  020b1	48 8b 00	 mov	 rax, QWORD PTR [rax]
  020b4	48 25 80 00 00
	00		 and	 rax, 128		; 00000080H
  020ba	48 85 c0	 test	 rax, rax
  020bd	74 36		 je	 SHORT $LN143@z900_start
  020bf	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR [rsp+48], 0
  020c8	48 c7 44 24 28
	00 00 00 00	 mov	 QWORD PTR [rsp+40], 0
  020d1	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG194911
  020d8	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  020dd	45 33 c9	 xor	 r9d, r9d
  020e0	45 33 c0	 xor	 r8d, r8d
  020e3	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG194912
  020ea	b9 80 00 00 00	 mov	 ecx, 128		; 00000080H
  020ef	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ptt_pthread_trace
$LN143@z900_start:
  020f5	33 c0		 xor	 eax, eax
  020f7	85 c0		 test	 eax, eax
  020f9	75 af		 jne	 SHORT $LN66@z900_start

; 827  :                 OBTAIN_INTLOCK( regs );

  020fb	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG194913
  02102	48 8b 8c 24 38
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0210a	e8 00 00 00 00	 call	 Obtain_Interrupt_Lock

; 828  :                 {
; 829  :                     regs->sie_active = 0;

  0210f	48 8b 84 24 38
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  02117	8b 80 c8 08 00
	00		 mov	 eax, DWORD PTR [rax+2248]
  0211d	83 e0 fe	 and	 eax, -2			; fffffffeH
  02120	48 8b 8c 24 38
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  02128	89 81 c8 08 00
	00		 mov	 DWORD PTR [rcx+2248], eax

; 830  :                 }
; 831  :                 RELEASE_INTLOCK( regs );

  0212e	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG194914
  02135	48 8b 8c 24 38
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0213d	e8 00 00 00 00	 call	 Release_Interrupt_Lock

; 832  :                 return;

  02142	e9 25 06 00 00	 jmp	 $LN1@z900_start
$LN142@z900_start:

; 833  :             }
; 834  : 
; 835  :             /* Convert host real address to host absolute address */
; 836  :             GUESTREGS->sie_px = apply_host_prefixing( regs, regs->dat.raddr );

  02147	48 8b 84 24 38
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0214f	48 8b 90 00 08
	00 00		 mov	 rdx, QWORD PTR [rax+2048]
  02156	48 8b 8c 24 38
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0215e	e8 00 00 00 00	 call	 apply_host_prefixing
  02163	48 8b 8c 24 38
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0216b	48 8b 89 70 08
	00 00		 mov	 rcx, QWORD PTR [rcx+2160]
  02172	48 89 81 90 08
	00 00		 mov	 QWORD PTR [rcx+2192], rax

; 837  : 
; 838  :             if (regs->dat.protect || GUESTREGS->sie_px > regs->mainlim)

  02179	48 8b 84 24 38
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  02181	8b 80 34 08 00
	00		 mov	 eax, DWORD PTR [rax+2100]
  02187	d1 e8		 shr	 eax, 1
  02189	83 e0 03	 and	 eax, 3
  0218c	85 c0		 test	 eax, eax
  0218e	75 2b		 jne	 SHORT $LN145@z900_start
  02190	48 8b 84 24 38
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  02198	48 8b 80 70 08
	00 00		 mov	 rax, QWORD PTR [rax+2160]
  0219f	48 8b 8c 24 38
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  021a7	48 8b 89 58 08
	00 00		 mov	 rcx, QWORD PTR [rcx+2136]
  021ae	48 39 88 90 08
	00 00		 cmp	 QWORD PTR [rax+2192], rcx
  021b5	0f 86 5a 01 00
	00		 jbe	 $LN144@z900_start
$LN145@z900_start:
$LN69@z900_start:

; 839  :             {
; 840  :                 SIE_SET_VI( SIE_VI_WHO_CPU, SIE_VI_WHEN_SIENT, SIE_VI_WHY_PFACC, GUESTREGS );

  021bb	48 8b 84 24 38
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  021c3	48 8b 80 70 08
	00 00		 mov	 rax, QWORD PTR [rax+2160]
  021ca	48 8b 80 88 08
	00 00		 mov	 rax, QWORD PTR [rax+2184]
  021d1	b9 01 00 00 00	 mov	 ecx, 1
  021d6	48 6b c9 00	 imul	 rcx, rcx, 0
  021da	c6 44 08 56 01	 mov	 BYTE PTR [rax+rcx+86], 1
  021df	48 8b 84 24 38
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  021e7	48 8b 80 70 08
	00 00		 mov	 rax, QWORD PTR [rax+2160]
  021ee	48 8b 80 88 08
	00 00		 mov	 rax, QWORD PTR [rax+2184]
  021f5	b9 01 00 00 00	 mov	 ecx, 1
  021fa	48 6b c9 01	 imul	 rcx, rcx, 1
  021fe	c6 44 08 56 10	 mov	 BYTE PTR [rax+rcx+86], 16
  02203	66 b9 37 00	 mov	 cx, 55			; 00000037H
  02207	e8 00 00 00 00	 call	 _byteswap_ushort
  0220c	48 8b 8c 24 38
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  02214	48 8b 89 70 08
	00 00		 mov	 rcx, QWORD PTR [rcx+2160]
  0221b	48 8b 89 88 08
	00 00		 mov	 rcx, QWORD PTR [rcx+2184]
  02222	48 83 c1 58	 add	 rcx, 88			; 00000058H
  02226	0f b7 d0	 movzx	 edx, ax
  02229	e8 00 00 00 00	 call	 store_hw_noswap
  0222e	48 8b 84 24 38
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  02236	48 8b 80 70 08
	00 00		 mov	 rax, QWORD PTR [rax+2160]
  0223d	48 8b 80 88 08
	00 00		 mov	 rax, QWORD PTR [rax+2184]
  02244	48 83 c0 5a	 add	 rax, 90			; 0000005aH
  02248	48 8b f8	 mov	 rdi, rax
  0224b	33 c0		 xor	 eax, eax
  0224d	b9 06 00 00 00	 mov	 ecx, 6
  02252	f3 aa		 rep stosb
  02254	33 c0		 xor	 eax, eax
  02256	85 c0		 test	 eax, eax
  02258	0f 85 5d ff ff
	ff		 jne	 $LN69@z900_start

; 841  :                 STATEBK->c = SIE_C_VALIDITY;

  0225e	48 8b 84 24 38
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  02266	48 8b 80 70 08
	00 00		 mov	 rax, QWORD PTR [rax+2160]
  0226d	48 8b 80 88 08
	00 00		 mov	 rax, QWORD PTR [rax+2184]
  02274	c6 40 50 20	 mov	 BYTE PTR [rax+80], 32	; 00000020H
$LN72@z900_start:

; 842  : 
; 843  :                 PTT_SIE( "SIE a=0", 0, 0, 0 );

  02278	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_pttclass
  0227f	48 8b 00	 mov	 rax, QWORD PTR [rax]
  02282	48 25 80 00 00
	00		 and	 rax, 128		; 00000080H
  02288	48 85 c0	 test	 rax, rax
  0228b	74 36		 je	 SHORT $LN146@z900_start
  0228d	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR [rsp+48], 0
  02296	48 c7 44 24 28
	00 00 00 00	 mov	 QWORD PTR [rsp+40], 0
  0229f	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG194918
  022a6	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  022ab	45 33 c9	 xor	 r9d, r9d
  022ae	45 33 c0	 xor	 r8d, r8d
  022b1	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG194919
  022b8	b9 80 00 00 00	 mov	 ecx, 128		; 00000080H
  022bd	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ptt_pthread_trace
$LN146@z900_start:
  022c3	33 c0		 xor	 eax, eax
  022c5	85 c0		 test	 eax, eax
  022c7	75 af		 jne	 SHORT $LN72@z900_start

; 844  :                 OBTAIN_INTLOCK( regs );

  022c9	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG194920
  022d0	48 8b 8c 24 38
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  022d8	e8 00 00 00 00	 call	 Obtain_Interrupt_Lock

; 845  :                 {
; 846  :                     regs->sie_active = 0;

  022dd	48 8b 84 24 38
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  022e5	8b 80 c8 08 00
	00		 mov	 eax, DWORD PTR [rax+2248]
  022eb	83 e0 fe	 and	 eax, -2			; fffffffeH
  022ee	48 8b 8c 24 38
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  022f6	89 81 c8 08 00
	00		 mov	 DWORD PTR [rcx+2248], eax

; 847  :                 }
; 848  :                 RELEASE_INTLOCK( regs );

  022fc	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG194921
  02303	48 8b 8c 24 38
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0230b	e8 00 00 00 00	 call	 Release_Interrupt_Lock

; 849  :                 return;

  02310	e9 57 04 00 00	 jmp	 $LN1@z900_start
$LN144@z900_start:

; 850  :             }
; 851  :             GUESTREGS->psa = (PSA_3XX*)(GUESTREGS->mainstor + GUESTREGS->sie_px);

  02315	48 8b 84 24 38
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0231d	48 8b 80 70 08
	00 00		 mov	 rax, QWORD PTR [rax+2160]
  02324	48 8b 8c 24 38
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0232c	48 8b 89 70 08
	00 00		 mov	 rcx, QWORD PTR [rcx+2160]
  02333	48 8b 80 48 08
	00 00		 mov	 rax, QWORD PTR [rax+2120]
  0233a	48 03 81 90 08
	00 00		 add	 rax, QWORD PTR [rcx+2192]
  02341	48 8b 8c 24 38
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  02349	48 8b 89 70 08
	00 00		 mov	 rcx, QWORD PTR [rcx+2160]
  02350	48 89 81 60 08
	00 00		 mov	 QWORD PTR [rcx+2144], rax
$LN141@z900_start:

; 852  :         }
; 853  : 
; 854  :         OBTAIN_INTLOCK( regs );

  02357	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG194922
  0235e	48 8b 8c 24 38
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  02366	e8 00 00 00 00	 call	 Obtain_Interrupt_Lock

; 855  :         {
; 856  :             /* Intialize guest timers... */
; 857  : 
; 858  :             /* CPU timer */
; 859  :             if (CPU_TIMER( GUESTREGS ) < 0)

  0236b	48 8b 84 24 38
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  02373	48 8b 88 70 08
	00 00		 mov	 rcx, QWORD PTR [rax+2160]
  0237a	e8 00 00 00 00	 call	 get_cpu_timer
  0237f	48 85 c0	 test	 rax, rax
  02382	7d 74		 jge	 SHORT $LN147@z900_start
$LN75@z900_start:

; 860  :                 ON_IC_PTIMER( GUESTREGS );

  02384	48 8b 84 24 38
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0238c	48 8b 80 70 08
	00 00		 mov	 rax, QWORD PTR [rax+2160]
  02393	8b 40 4c	 mov	 eax, DWORD PTR [rax+76]
  02396	25 00 04 00 00	 and	 eax, 1024		; 00000400H
  0239b	85 c0		 test	 eax, eax
  0239d	74 2b		 je	 SHORT $LN148@z900_start
  0239f	48 8b 84 24 38
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  023a7	48 8b 80 70 08
	00 00		 mov	 rax, QWORD PTR [rax+2160]
  023ae	8b 40 48	 mov	 eax, DWORD PTR [rax+72]
  023b1	0d 00 04 00 80	 or	 eax, -2147482624	; 80000400H
  023b6	48 8b 8c 24 38
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  023be	48 8b 89 70 08
	00 00		 mov	 rcx, QWORD PTR [rcx+2160]
  023c5	89 41 48	 mov	 DWORD PTR [rcx+72], eax
  023c8	eb 28		 jmp	 SHORT $LN149@z900_start
$LN148@z900_start:
  023ca	48 8b 84 24 38
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  023d2	48 8b 80 70 08
	00 00		 mov	 rax, QWORD PTR [rax+2160]
  023d9	8b 40 48	 mov	 eax, DWORD PTR [rax+72]
  023dc	0f ba e8 0a	 bts	 eax, 10
  023e0	48 8b 8c 24 38
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  023e8	48 8b 89 70 08
	00 00		 mov	 rcx, QWORD PTR [rcx+2160]
  023ef	89 41 48	 mov	 DWORD PTR [rcx+72], eax
$LN149@z900_start:
  023f2	33 c0		 xor	 eax, eax
  023f4	85 c0		 test	 eax, eax
  023f6	75 8c		 jne	 SHORT $LN75@z900_start
$LN147@z900_start:

; 861  : 
; 862  :             /* Clock comparator */
; 863  :             if (TOD_CLOCK( GUESTREGS ) > GUESTREGS->clkc)

  023f8	48 b8 ff ff ff
	ff ff ff ff 00	 mov	 rax, 72057594037927935	; 00ffffffffffffffH
  02402	48 8b 0d 08 00
	00 00		 mov	 rcx, QWORD PTR tod_value+8
  02409	48 23 c8	 and	 rcx, rax
  0240c	48 8b c1	 mov	 rax, rcx
  0240f	48 8b 8c 24 38
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  02417	48 8b 89 70 08
	00 00		 mov	 rcx, QWORD PTR [rcx+2160]
  0241e	48 03 81 40 07
	00 00		 add	 rax, QWORD PTR [rcx+1856]
  02425	48 8b 8c 24 38
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0242d	48 8b 89 70 08
	00 00		 mov	 rcx, QWORD PTR [rcx+2160]
  02434	48 3b 81 48 07
	00 00		 cmp	 rax, QWORD PTR [rcx+1864]
  0243b	76 74		 jbe	 SHORT $LN150@z900_start
$LN78@z900_start:

; 864  :                 ON_IC_CLKC( GUESTREGS );

  0243d	48 8b 84 24 38
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  02445	48 8b 80 70 08
	00 00		 mov	 rax, QWORD PTR [rax+2160]
  0244c	8b 40 4c	 mov	 eax, DWORD PTR [rax+76]
  0244f	25 00 08 00 00	 and	 eax, 2048		; 00000800H
  02454	85 c0		 test	 eax, eax
  02456	74 2b		 je	 SHORT $LN151@z900_start
  02458	48 8b 84 24 38
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  02460	48 8b 80 70 08
	00 00		 mov	 rax, QWORD PTR [rax+2160]
  02467	8b 40 48	 mov	 eax, DWORD PTR [rax+72]
  0246a	0d 00 08 00 80	 or	 eax, -2147481600	; 80000800H
  0246f	48 8b 8c 24 38
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  02477	48 8b 89 70 08
	00 00		 mov	 rcx, QWORD PTR [rcx+2160]
  0247e	89 41 48	 mov	 DWORD PTR [rcx+72], eax
  02481	eb 28		 jmp	 SHORT $LN152@z900_start
$LN151@z900_start:
  02483	48 8b 84 24 38
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0248b	48 8b 80 70 08
	00 00		 mov	 rax, QWORD PTR [rax+2160]
  02492	8b 40 48	 mov	 eax, DWORD PTR [rax+72]
  02495	0f ba e8 0b	 bts	 eax, 11
  02499	48 8b 8c 24 38
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  024a1	48 8b 89 70 08
	00 00		 mov	 rcx, QWORD PTR [rcx+2160]
  024a8	89 41 48	 mov	 DWORD PTR [rcx+72], eax
$LN152@z900_start:
  024ab	33 c0		 xor	 eax, eax
  024ad	85 c0		 test	 eax, eax
  024af	75 8c		 jne	 SHORT $LN78@z900_start
$LN150@z900_start:

; 865  : 
; 866  : #if !defined( FEATURE_001_ZARCH_INSTALLED_FACILITY )
; 867  : 
; 868  :             /* Interval timer if S/370 and timer is enabled */
; 869  :             if (1
; 870  :                 && (STATEBK->m & SIE_M_370)
; 871  :                 && !(STATEBK->m & SIE_M_ITMOF)
; 872  :             )
; 873  :             {
; 874  :                 S32 itimer, olditimer;
; 875  :                 U32 residue;
; 876  : 
; 877  :                 /* Set the interval timer pending according to
; 878  :                    the T bit in the state control
; 879  :                 */
; 880  :                 if (STATEBK->s & SIE_S_T)
; 881  :                     ON_IC_ITIMER( GUESTREGS );
; 882  : 
; 883  :                 /* Fetch the residue from the state descriptor */
; 884  :                 FETCH_FW( residue, STATEBK->residue );
; 885  : 
; 886  :                 /* Fetch the timer value from location 80 */
; 887  :                 FETCH_FW( olditimer, GUESTREGS->psa->inttimer );
; 888  : 
; 889  :                 /* Bit position 23 of the interval timer is decremented
; 890  :                    once for each multiple of 3,333 usecs containded in
; 891  :                    bit position 0-19 of the residue counter.
; 892  :                 */
; 893  :                 itimer = olditimer - ((residue / 3333) >> 4);
; 894  : 
; 895  :                 /* Store the timer back */
; 896  :                 STORE_FW( GUESTREGS->psa->inttimer, itimer );
; 897  : 
; 898  :                 /* Set interrupt flag and interval timer interrupt pending
; 899  :                    if the interval timer went from positive to negative
; 900  :                 */
; 901  :                 if (itimer < 0 && olditimer >= 0)
; 902  :                     ON_IC_ITIMER( GUESTREGS );
; 903  :             }
; 904  : #endif /* !defined( FEATURE_001_ZARCH_INSTALLED_FACILITY ) */
; 905  : 
; 906  :         }
; 907  :         RELEASE_INTLOCK( regs );

  024b1	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG194929
  024b8	48 8b 8c 24 38
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  024c0	e8 00 00 00 00	 call	 Release_Interrupt_Lock

; 908  : 
; 909  :         /* Early exceptions associated with the guest load_psw() */
; 910  :         if (lpsw_xcode)

  024c5	83 7c 24 78 00	 cmp	 DWORD PTR lpsw_xcode$[rsp], 0
  024ca	74 7e		 je	 SHORT $LN153@z900_start
$LN81@z900_start:

; 911  :         {
; 912  :             PTT_SIE( "*SIE > pgmint", lpsw_xcode, 0, 0 );

  024cc	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_pttclass
  024d3	48 8b 00	 mov	 rax, QWORD PTR [rax]
  024d6	48 25 80 00 00
	00		 and	 rax, 128		; 00000080H
  024dc	48 85 c0	 test	 rax, rax
  024df	74 3b		 je	 SHORT $LN154@z900_start
  024e1	48 63 44 24 78	 movsxd	 rax, DWORD PTR lpsw_xcode$[rsp]
  024e6	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR [rsp+48], 0
  024ef	48 c7 44 24 28
	00 00 00 00	 mov	 QWORD PTR [rsp+40], 0
  024f8	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG194932
  024ff	48 89 4c 24 20	 mov	 QWORD PTR [rsp+32], rcx
  02504	45 33 c9	 xor	 r9d, r9d
  02507	4c 8b c0	 mov	 r8, rax
  0250a	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG194933
  02511	b9 80 00 00 00	 mov	 ecx, 128		; 00000080H
  02516	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ptt_pthread_trace
$LN154@z900_start:
  0251c	33 c0		 xor	 eax, eax
  0251e	85 c0		 test	 eax, eax
  02520	75 aa		 jne	 SHORT $LN81@z900_start

; 913  :             GUESTREGS->program_interrupt( GUESTREGS, lpsw_xcode );

  02522	48 8b 84 24 38
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0252a	48 8b 80 70 08
	00 00		 mov	 rax, QWORD PTR [rax+2160]
  02531	8b 54 24 78	 mov	 edx, DWORD PTR lpsw_xcode$[rsp]
  02535	48 8b 8c 24 38
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0253d	48 8b 89 70 08
	00 00		 mov	 rcx, QWORD PTR [rcx+2160]
  02544	ff 90 20 0d 00
	00		 call	 QWORD PTR [rax+3360]
$LN153@z900_start:
$LN84@z900_start:

; 914  :         }
; 915  : 
; 916  :         /* Run SIE in guest's architecture mode */
; 917  :         PTT_SIE( "SIE > run_sie", GUESTREGS->arch_mode, 0, 0 );

  0254a	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_pttclass
  02551	48 8b 00	 mov	 rax, QWORD PTR [rax]
  02554	48 25 80 00 00
	00		 and	 rax, 128		; 00000080H
  0255a	48 85 c0	 test	 rax, rax
  0255d	74 49		 je	 SHORT $LN155@z900_start
  0255f	48 8b 84 24 38
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  02567	48 8b 80 70 08
	00 00		 mov	 rax, QWORD PTR [rax+2160]
  0256e	48 63 40 64	 movsxd	 rax, DWORD PTR [rax+100]
  02572	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR [rsp+48], 0
  0257b	48 c7 44 24 28
	00 00 00 00	 mov	 QWORD PTR [rsp+40], 0
  02584	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG194935
  0258b	48 89 4c 24 20	 mov	 QWORD PTR [rsp+32], rcx
  02590	45 33 c9	 xor	 r9d, r9d
  02593	4c 8b c0	 mov	 r8, rax
  02596	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG194936
  0259d	b9 80 00 00 00	 mov	 ecx, 128		; 00000080H
  025a2	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ptt_pthread_trace
$LN155@z900_start:
  025a8	33 c0		 xor	 eax, eax
  025aa	85 c0		 test	 eax, eax
  025ac	75 9c		 jne	 SHORT $LN84@z900_start

; 918  :         icode = run_sie[ GUESTREGS->arch_mode ]( regs );

  025ae	48 8b 84 24 38
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  025b6	48 8b 80 70 08
	00 00		 mov	 rax, QWORD PTR [rax+2160]
  025bd	48 63 40 64	 movsxd	 rax, DWORD PTR [rax+100]
  025c1	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:run_sie
  025c8	48 89 8c 24 00
	01 00 00	 mov	 QWORD PTR tv1448[rsp], rcx
  025d0	48 8b 8c 24 38
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  025d8	48 8b 94 24 00
	01 00 00	 mov	 rdx, QWORD PTR tv1448[rsp]
  025e0	ff 14 c2	 call	 QWORD PTR [rdx+rax*8]
  025e3	89 44 24 60	 mov	 DWORD PTR icode$[rsp], eax
$LN87@z900_start:

; 919  :         PTT_SIE( "SIE < run_sie", icode, 0, 0 );

  025e7	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_pttclass
  025ee	48 8b 00	 mov	 rax, QWORD PTR [rax]
  025f1	48 25 80 00 00
	00		 and	 rax, 128		; 00000080H
  025f7	48 85 c0	 test	 rax, rax
  025fa	74 3c		 je	 SHORT $LN156@z900_start
  025fc	8b 44 24 60	 mov	 eax, DWORD PTR icode$[rsp]
  02600	48 98		 cdqe
  02602	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR [rsp+48], 0
  0260b	48 c7 44 24 28
	00 00 00 00	 mov	 QWORD PTR [rsp+40], 0
  02614	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG194938
  0261b	48 89 4c 24 20	 mov	 QWORD PTR [rsp+32], rcx
  02620	45 33 c9	 xor	 r9d, r9d
  02623	4c 8b c0	 mov	 r8, rax
  02626	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG194939
  0262d	b9 80 00 00 00	 mov	 ecx, 128		; 00000080H
  02632	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ptt_pthread_trace
$LN156@z900_start:
  02638	33 c0		 xor	 eax, eax
  0263a	85 c0		 test	 eax, eax
  0263c	75 a9		 jne	 SHORT $LN87@z900_start
$LN138@z900_start:
$LN90@z900_start:

; 920  : 
; 921  :     } /* if (setjmp(GUESTREGS->progjmp)) */
; 922  : 
; 923  :     /* Exit from SIE mode */
; 924  :     PTT_SIE( "SIE > sie_exit", icode, 0, 0 );

  0263e	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_pttclass
  02645	48 8b 00	 mov	 rax, QWORD PTR [rax]
  02648	48 25 80 00 00
	00		 and	 rax, 128		; 00000080H
  0264e	48 85 c0	 test	 rax, rax
  02651	74 3c		 je	 SHORT $LN157@z900_start
  02653	8b 44 24 60	 mov	 eax, DWORD PTR icode$[rsp]
  02657	48 98		 cdqe
  02659	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR [rsp+48], 0
  02662	48 c7 44 24 28
	00 00 00 00	 mov	 QWORD PTR [rsp+40], 0
  0266b	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG194941
  02672	48 89 4c 24 20	 mov	 QWORD PTR [rsp+32], rcx
  02677	45 33 c9	 xor	 r9d, r9d
  0267a	4c 8b c0	 mov	 r8, rax
  0267d	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG194942
  02684	b9 80 00 00 00	 mov	 ecx, 128		; 00000080H
  02689	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ptt_pthread_trace
$LN157@z900_start:
  0268f	33 c0		 xor	 eax, eax
  02691	85 c0		 test	 eax, eax
  02693	75 a9		 jne	 SHORT $LN90@z900_start

; 925  :     ARCH_DEP( sie_exit )( regs, icode );

  02695	8b 54 24 60	 mov	 edx, DWORD PTR icode$[rsp]
  02699	48 8b 8c 24 38
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  026a1	e8 00 00 00 00	 call	 z900_sie_exit
$LN93@z900_start:

; 926  :     PTT_SIE( "SIE < sie_exit", 0, 0, 0 );

  026a6	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_pttclass
  026ad	48 8b 00	 mov	 rax, QWORD PTR [rax]
  026b0	48 25 80 00 00
	00		 and	 rax, 128		; 00000080H
  026b6	48 85 c0	 test	 rax, rax
  026b9	74 36		 je	 SHORT $LN158@z900_start
  026bb	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR [rsp+48], 0
  026c4	48 c7 44 24 28
	00 00 00 00	 mov	 QWORD PTR [rsp+40], 0
  026cd	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG194944
  026d4	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  026d9	45 33 c9	 xor	 r9d, r9d
  026dc	45 33 c0	 xor	 r8d, r8d
  026df	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG194945
  026e6	b9 80 00 00 00	 mov	 ecx, 128		; 00000080H
  026eb	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ptt_pthread_trace
$LN158@z900_start:
  026f1	33 c0		 xor	 eax, eax
  026f3	85 c0		 test	 eax, eax
  026f5	75 af		 jne	 SHORT $LN93@z900_start

; 927  : 
; 928  :     /* Perform serialization and checkpoint synchronization */
; 929  :     PERFORM_SERIALIZATION( regs );

  026f7	0f ae f0	 mfence
$LN96@z900_start:

; 930  :     PERFORM_CHKPT_SYNC( regs );

  026fa	33 c0		 xor	 eax, eax
  026fc	85 c0		 test	 eax, eax
  026fe	75 fa		 jne	 SHORT $LN96@z900_start
$LN99@z900_start:

; 931  : 
; 932  :     /* Return back to host instruction processing */
; 933  :     PTT_SIE( "SIE progjmp", 0, 0, 0 );

  02700	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_pttclass
  02707	48 8b 00	 mov	 rax, QWORD PTR [rax]
  0270a	48 25 80 00 00
	00		 and	 rax, 128		; 00000080H
  02710	48 85 c0	 test	 rax, rax
  02713	74 36		 je	 SHORT $LN159@z900_start
  02715	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR [rsp+48], 0
  0271e	48 c7 44 24 28
	00 00 00 00	 mov	 QWORD PTR [rsp+40], 0
  02727	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG194947
  0272e	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  02733	45 33 c9	 xor	 r9d, r9d
  02736	45 33 c0	 xor	 r8d, r8d
  02739	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG194948
  02740	b9 80 00 00 00	 mov	 ecx, 128		; 00000080H
  02745	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ptt_pthread_trace
$LN159@z900_start:
  0274b	33 c0		 xor	 eax, eax
  0274d	85 c0		 test	 eax, eax
  0274f	75 af		 jne	 SHORT $LN99@z900_start

; 934  :     longjmp( regs->progjmp, SIE_NO_INTERCEPT );

  02751	48 8b 84 24 38
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  02759	48 05 80 09 00
	00		 add	 rax, 2432		; 00000980H
  0275f	ba ff ff ff ff	 mov	 edx, -1
  02764	48 8b c8	 mov	 rcx, rax
  02767	e8 00 00 00 00	 call	 longjmp
$LN1@z900_start:
$LN160@z900_start:

; 935  : 
; 936  : } /* end of start_interpretive_execution instruction */

  0276c	48 81 c4 18 01
	00 00		 add	 rsp, 280		; 00000118H
  02773	5f		 pop	 rdi
  02774	5e		 pop	 rsi
  02775	c3		 ret	 0
z900_start_interpretive_execution ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\sie.c
_TEXT	SEGMENT
i$1 = 32
r2$ = 36
r1$ = 40
inst$ = 64
regs$ = 72
z900_store_hypervisor_information PROC

; 2008 : {

$LN11:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 2009 :     int r1, r2;
; 2010 :     RRE( inst, regs, r1, r2 );

  0000e	b8 01 00 00 00	 mov	 eax, 1
  00013	48 6b c0 03	 imul	 rax, rax, 3
  00017	48 8b 4c 24 40	 mov	 rcx, QWORD PTR inst$[rsp]
  0001c	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00020	89 44 24 20	 mov	 DWORD PTR i$1[rsp], eax
  00024	8b 44 24 20	 mov	 eax, DWORD PTR i$1[rsp]
  00028	83 e0 0f	 and	 eax, 15
  0002b	89 44 24 24	 mov	 DWORD PTR r2$[rsp], eax
  0002f	8b 44 24 20	 mov	 eax, DWORD PTR i$1[rsp]
  00033	c1 f8 04	 sar	 eax, 4
  00036	83 e0 0f	 and	 eax, 15
  00039	89 44 24 28	 mov	 DWORD PTR r1$[rsp], eax
$LN4@z900_store:
  0003d	48 8b 44 24 48	 mov	 rax, QWORD PTR regs$[rsp]
  00042	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  00046	48 83 c0 04	 add	 rax, 4
  0004a	48 8b 4c 24 48	 mov	 rcx, QWORD PTR regs$[rsp]
  0004f	48 89 41 68	 mov	 QWORD PTR [rcx+104], rax
  00053	33 c0		 xor	 eax, eax
  00055	83 f8 04	 cmp	 eax, 4
  00058	74 0c		 je	 SHORT $LN8@z900_store
  0005a	48 8b 44 24 48	 mov	 rax, QWORD PTR regs$[rsp]
  0005f	c6 80 9a 00 00
	00 04		 mov	 BYTE PTR [rax+154], 4
$LN8@z900_store:
  00066	33 c0		 xor	 eax, eax
  00068	85 c0		 test	 eax, eax
  0006a	75 d1		 jne	 SHORT $LN4@z900_store
$LN7@z900_store:

; 2011 :     SIE_INTERCEPT( regs );

  0006c	48 8b 44 24 48	 mov	 rax, QWORD PTR regs$[rsp]
  00071	8b 80 c8 08 00
	00		 mov	 eax, DWORD PTR [rax+2248]
  00077	d1 e8		 shr	 eax, 1
  00079	83 e0 01	 and	 eax, 1
  0007c	85 c0		 test	 eax, eax
  0007e	74 18		 je	 SHORT $LN9@z900_store
  00080	48 8b 44 24 48	 mov	 rax, QWORD PTR regs$[rsp]
  00085	48 05 80 09 00
	00		 add	 rax, 2432		; 00000980H
  0008b	ba fc ff ff ff	 mov	 edx, -4
  00090	48 8b c8	 mov	 rcx, rax
  00093	e8 00 00 00 00	 call	 longjmp
$LN9@z900_store:
  00098	33 c0		 xor	 eax, eax
  0009a	85 c0		 test	 eax, eax
  0009c	75 ce		 jne	 SHORT $LN7@z900_store

; 2012 :     ARCH_DEP( program_interrupt )( regs, PGM_OPERATION_EXCEPTION );

  0009e	ba 01 00 00 00	 mov	 edx, 1
  000a3	48 8b 4c 24 48	 mov	 rcx, QWORD PTR regs$[rsp]
  000a8	e8 00 00 00 00	 call	 z900_program_interrupt
$LN10@z900_store:

; 2013 : }

  000ad	48 83 c4 38	 add	 rsp, 56			; 00000038H
  000b1	c3		 ret	 0
z900_store_hypervisor_information ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\sie.c
_TEXT	SEGMENT
newgr1$ = 64
tv166 = 68
tv192 = 72
dev$ = 80
regs$ = 112
r1$ = 120
r3$ = 128
z900_diagnose_002 PROC

; 1941 : {

$LN18:
  00000	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  00005	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00009	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000e	48 83 ec 68	 sub	 rsp, 104		; 00000068H

; 1942 : DEVBLK *dev;
; 1943 : U32    newgr1;
; 1944 : 
; 1945 :     /* Program check if the ssid including lcss is invalid */
; 1946 :     SSID_CHECK(regs);

  00012	b8 08 00 00 00	 mov	 eax, 8
  00017	48 6b c0 01	 imul	 rax, rax, 1
  0001b	48 8b 4c 24 70	 mov	 rcx, QWORD PTR regs$[rsp]
  00020	0f b7 84 01 82
	02 00 00	 movzx	 eax, WORD PTR [rcx+rax+642]
  00028	83 e0 01	 and	 eax, 1
  0002b	85 c0		 test	 eax, eax
  0002d	74 1b		 je	 SHORT $LN6@z900_diagn
  0002f	b8 08 00 00 00	 mov	 eax, 8
  00034	48 6b c0 01	 imul	 rax, rax, 1
  00038	48 8b 4c 24 70	 mov	 rcx, QWORD PTR regs$[rsp]
  0003d	0f b7 84 01 82
	02 00 00	 movzx	 eax, WORD PTR [rcx+rax+642]
  00045	83 f8 03	 cmp	 eax, 3
  00048	7e 15		 jle	 SHORT $LN5@z900_diagn
$LN6@z900_diagn:
  0004a	ba 15 00 00 00	 mov	 edx, 21
  0004f	48 8b 4c 24 70	 mov	 rcx, QWORD PTR regs$[rsp]
  00054	48 8b 44 24 70	 mov	 rax, QWORD PTR regs$[rsp]
  00059	ff 90 20 0d 00
	00		 call	 QWORD PTR [rax+3360]
$LN5@z900_diagn:

; 1947 : 
; 1948 :     /* Locate the device block for this subchannel */
; 1949 :     dev = find_device_by_subchan (regs->GR_L(1));

  0005f	b8 08 00 00 00	 mov	 eax, 8
  00064	48 6b c0 01	 imul	 rax, rax, 1
  00068	48 8b 4c 24 70	 mov	 rcx, QWORD PTR regs$[rsp]
  0006d	8b 8c 01 80 02
	00 00		 mov	 ecx, DWORD PTR [rcx+rax+640]
  00074	e8 00 00 00 00	 call	 find_device_by_subchan
  00079	48 89 44 24 50	 mov	 QWORD PTR dev$[rsp], rax

; 1950 : 
; 1951 :     /* Condition code 3 if subchannel does not exist,
; 1952 :        is not valid, or is not enabled */
; 1953 :     if (dev == NULL
; 1954 :         || (dev->pmcw.flag5 & PMCW5_V) == 0
; 1955 :         || (dev->pmcw.flag5 & PMCW5_E) == 0)

  0007e	48 83 7c 24 50
	00		 cmp	 QWORD PTR dev$[rsp], 0
  00084	74 2c		 je	 SHORT $LN8@z900_diagn
  00086	48 8b 44 24 50	 mov	 rax, QWORD PTR dev$[rsp]
  0008b	0f b6 80 f1 02
	00 00		 movzx	 eax, BYTE PTR [rax+753]
  00092	83 e0 01	 and	 eax, 1
  00095	85 c0		 test	 eax, eax
  00097	74 19		 je	 SHORT $LN8@z900_diagn
  00099	48 8b 44 24 50	 mov	 rax, QWORD PTR dev$[rsp]
  0009e	0f b6 80 f1 02
	00 00		 movzx	 eax, BYTE PTR [rax+753]
  000a5	25 80 00 00 00	 and	 eax, 128		; 00000080H
  000aa	85 c0		 test	 eax, eax
  000ac	0f 85 98 00 00
	00		 jne	 $LN7@z900_diagn
$LN8@z900_diagn:
$LN4@z900_diagn:

; 1956 :     {
; 1957 :         PTT_ERR("*DIAG002", regs->GR_L(r1),regs->GR_L(r3),regs->GR_L(1));

  000b2	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_pttclass
  000b9	48 8b 00	 mov	 rax, QWORD PTR [rax]
  000bc	48 83 e0 10	 and	 rax, 16
  000c0	48 85 c0	 test	 rax, rax
  000c3	74 6d		 je	 SHORT $LN9@z900_diagn
  000c5	b8 08 00 00 00	 mov	 eax, 8
  000ca	48 6b c0 01	 imul	 rax, rax, 1
  000ce	48 8b 4c 24 70	 mov	 rcx, QWORD PTR regs$[rsp]
  000d3	8b 84 01 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax+640]
  000da	48 63 8c 24 80
	00 00 00	 movsxd	 rcx, DWORD PTR r3$[rsp]
  000e2	48 8b 54 24 70	 mov	 rdx, QWORD PTR regs$[rsp]
  000e7	8b 8c ca 80 02
	00 00		 mov	 ecx, DWORD PTR [rdx+rcx*8+640]
  000ee	48 63 54 24 78	 movsxd	 rdx, DWORD PTR r1$[rsp]
  000f3	4c 8b 44 24 70	 mov	 r8, QWORD PTR regs$[rsp]
  000f8	41 8b 94 d0 80
	02 00 00	 mov	 edx, DWORD PTR [r8+rdx*8+640]
  00100	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR [rsp+48], 0
  00109	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  0010e	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG195990
  00115	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  0011a	44 8b c9	 mov	 r9d, ecx
  0011d	44 8b c2	 mov	 r8d, edx
  00120	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG195991
  00127	b9 10 00 00 00	 mov	 ecx, 16
  0012c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ptt_pthread_trace
$LN9@z900_diagn:
  00132	33 c0		 xor	 eax, eax
  00134	85 c0		 test	 eax, eax
  00136	0f 85 76 ff ff
	ff		 jne	 $LN4@z900_diagn

; 1958 :         regs->psw.cc = 3;

  0013c	48 8b 44 24 70	 mov	 rax, QWORD PTR regs$[rsp]
  00141	c6 40 7c 03	 mov	 BYTE PTR [rax+124], 3

; 1959 :         return;

  00145	e9 70 01 00 00	 jmp	 $LN1@z900_diagn
$LN7@z900_diagn:

; 1960 :     }
; 1961 : 
; 1962 :     /* Obtain the device lock */
; 1963 :     obtain_lock (&dev->lock);

  0014a	48 8b 44 24 50	 mov	 rax, QWORD PTR dev$[rsp]
  0014f	48 83 c0 38	 add	 rax, 56			; 00000038H
  00153	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG195992
  0015a	48 8b c8	 mov	 rcx, rax
  0015d	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_obtain_lock

; 1964 : 
; 1965 :     /* Set newgr1 to the current value of pending and interlock control */
; 1966 :     newgr1 = ((dev->scsw.flag3 & SCSW3_SC_PEND)

  00163	48 8b 44 24 50	 mov	 rax, QWORD PTR dev$[rsp]
  00168	0f b6 80 0b 03
	00 00		 movzx	 eax, BYTE PTR [rax+779]
  0016f	83 e0 01	 and	 eax, 1
  00172	85 c0		 test	 eax, eax
  00174	75 1d		 jne	 SHORT $LN14@z900_diagn
  00176	48 8b 44 24 50	 mov	 rax, QWORD PTR dev$[rsp]
  0017b	0f b6 80 17 03
	00 00		 movzx	 eax, BYTE PTR [rax+791]
  00182	83 e0 01	 and	 eax, 1
  00185	85 c0		 test	 eax, eax
  00187	75 0a		 jne	 SHORT $LN14@z900_diagn
  00189	c7 44 24 44 00
	00 00 00	 mov	 DWORD PTR tv166[rsp], 0
  00191	eb 08		 jmp	 SHORT $LN15@z900_diagn
$LN14@z900_diagn:
  00193	c7 44 24 44 02
	00 00 00	 mov	 DWORD PTR tv166[rsp], 2
$LN15@z900_diagn:
  0019b	8b 44 24 44	 mov	 eax, DWORD PTR tv166[rsp]
  0019f	89 44 24 40	 mov	 DWORD PTR newgr1$[rsp], eax

; 1967 :               || (dev->pciscsw.flag3 & SCSW3_SC_PEND)) ? 0x02 : 0;
; 1968 :     if(dev->pmcw.flag27 & PMCW27_I)

  001a3	48 8b 44 24 50	 mov	 rax, QWORD PTR dev$[rsp]
  001a8	0f b6 80 07 03
	00 00		 movzx	 eax, BYTE PTR [rax+775]
  001af	25 80 00 00 00	 and	 eax, 128		; 00000080H
  001b4	85 c0		 test	 eax, eax
  001b6	74 0b		 je	 SHORT $LN10@z900_diagn

; 1969 :         newgr1 |= 0x01;

  001b8	8b 44 24 40	 mov	 eax, DWORD PTR newgr1$[rsp]
  001bc	83 c8 01	 or	 eax, 1
  001bf	89 44 24 40	 mov	 DWORD PTR newgr1$[rsp], eax
$LN10@z900_diagn:

; 1970 : 
; 1971 :     /* Do a compare-and-swap operation on the interrupt interlock
; 1972 :        control bit where both interlock and pending bits are
; 1973 :        compared, but only the interlock bit is swapped */
; 1974 :     if((regs->GR_L(r1) & 0x03) == newgr1)

  001c3	48 63 44 24 78	 movsxd	 rax, DWORD PTR r1$[rsp]
  001c8	48 8b 4c 24 70	 mov	 rcx, QWORD PTR regs$[rsp]
  001cd	8b 84 c1 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax*8+640]
  001d4	83 e0 03	 and	 eax, 3
  001d7	3b 44 24 40	 cmp	 eax, DWORD PTR newgr1$[rsp]
  001db	75 6e		 jne	 SHORT $LN11@z900_diagn

; 1975 :     {
; 1976 :         dev->pmcw.flag27 &= ~PMCW27_I;

  001dd	48 8b 44 24 50	 mov	 rax, QWORD PTR dev$[rsp]
  001e2	0f b6 80 07 03
	00 00		 movzx	 eax, BYTE PTR [rax+775]
  001e9	0f ba f0 07	 btr	 eax, 7
  001ed	48 8b 4c 24 50	 mov	 rcx, QWORD PTR dev$[rsp]
  001f2	88 81 07 03 00
	00		 mov	 BYTE PTR [rcx+775], al

; 1977 :         dev->pmcw.flag27 |= (regs->GR_L(r3) & 0x01) ? PMCW27_I : 0;

  001f8	48 63 84 24 80
	00 00 00	 movsxd	 rax, DWORD PTR r3$[rsp]
  00200	48 8b 4c 24 70	 mov	 rcx, QWORD PTR regs$[rsp]
  00205	8b 84 c1 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax*8+640]
  0020c	83 e0 01	 and	 eax, 1
  0020f	85 c0		 test	 eax, eax
  00211	74 0a		 je	 SHORT $LN16@z900_diagn
  00213	c7 44 24 48 80
	00 00 00	 mov	 DWORD PTR tv192[rsp], 128 ; 00000080H
  0021b	eb 08		 jmp	 SHORT $LN17@z900_diagn
$LN16@z900_diagn:
  0021d	c7 44 24 48 00
	00 00 00	 mov	 DWORD PTR tv192[rsp], 0
$LN17@z900_diagn:
  00225	48 8b 44 24 50	 mov	 rax, QWORD PTR dev$[rsp]
  0022a	0f b6 80 07 03
	00 00		 movzx	 eax, BYTE PTR [rax+775]
  00231	0b 44 24 48	 or	 eax, DWORD PTR tv192[rsp]
  00235	48 8b 4c 24 50	 mov	 rcx, QWORD PTR dev$[rsp]
  0023a	88 81 07 03 00
	00		 mov	 BYTE PTR [rcx+775], al

; 1978 :         regs->psw.cc = 0;

  00240	48 8b 44 24 70	 mov	 rax, QWORD PTR regs$[rsp]
  00245	c6 40 7c 00	 mov	 BYTE PTR [rax+124], 0

; 1979 :     }

  00249	eb 56		 jmp	 SHORT $LN12@z900_diagn
$LN11@z900_diagn:

; 1980 :     else
; 1981 :     {
; 1982 :         regs->GR_L(r1) &= ~0x03;

  0024b	48 63 44 24 78	 movsxd	 rax, DWORD PTR r1$[rsp]
  00250	48 8b 4c 24 70	 mov	 rcx, QWORD PTR regs$[rsp]
  00255	8b 84 c1 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax*8+640]
  0025c	83 e0 fc	 and	 eax, -4			; fffffffcH
  0025f	48 63 4c 24 78	 movsxd	 rcx, DWORD PTR r1$[rsp]
  00264	48 8b 54 24 70	 mov	 rdx, QWORD PTR regs$[rsp]
  00269	89 84 ca 80 02
	00 00		 mov	 DWORD PTR [rdx+rcx*8+640], eax

; 1983 :         regs->GR_L(r1) |= newgr1;

  00270	48 63 44 24 78	 movsxd	 rax, DWORD PTR r1$[rsp]
  00275	48 8b 4c 24 70	 mov	 rcx, QWORD PTR regs$[rsp]
  0027a	8b 54 24 40	 mov	 edx, DWORD PTR newgr1$[rsp]
  0027e	8b 84 c1 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax*8+640]
  00285	0b c2		 or	 eax, edx
  00287	48 63 4c 24 78	 movsxd	 rcx, DWORD PTR r1$[rsp]
  0028c	48 8b 54 24 70	 mov	 rdx, QWORD PTR regs$[rsp]
  00291	89 84 ca 80 02
	00 00		 mov	 DWORD PTR [rdx+rcx*8+640], eax

; 1984 :         regs->psw.cc = 1;

  00298	48 8b 44 24 70	 mov	 rax, QWORD PTR regs$[rsp]
  0029d	c6 40 7c 01	 mov	 BYTE PTR [rax+124], 1
$LN12@z900_diagn:

; 1985 :     }
; 1986 : 
; 1987 :     /* Release the device lock */
; 1988 :     release_lock (&dev->lock);

  002a1	48 8b 44 24 50	 mov	 rax, QWORD PTR dev$[rsp]
  002a6	48 83 c0 38	 add	 rax, 56			; 00000038H
  002aa	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG195996
  002b1	48 8b c8	 mov	 rcx, rax
  002b4	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_release_lock
$LN1@z900_diagn:

; 1989 : }

  002ba	48 83 c4 68	 add	 rsp, 104		; 00000068H
  002be	c3		 ret	 0
z900_diagnose_002 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\sie.c
_TEXT	SEGMENT
i$1 = 80
is_exrl$ = 84
txf_tnd$ = 85
txf_contran$ = 86
itdba$ = 88
oldmode$2 = 96
ip$3 = 104
n$ = 112
nt2$4 = 116
nt1$5 = 120
tv269 = 124
tv817 = 128
itdb$ = 136
tv189 = 144
tv190 = 148
tv209 = 152
tv210 = 156
tv268 = 160
tv286 = 164
tv293 = 168
tv300 = 172
tv302 = 176
tv791 = 180
tv811 = 184
tv796 = 188
tv927 = 192
tv1070 = 196
tv1078 = 200
tv1087 = 204
tv1089 = 208
tv1124 = 212
tv1126 = 216
tv1157 = 220
tv1158 = 224
ilc$6 = 228
tv143 = 232
tv1204 = 236
tv145 = 240
tv1203 = 244
tv169 = 248
tv510 = 252
tv561 = 256
inst_cr$7 = 260
tv398 = 264
psa$8 = 272
realregs$9 = 280
tv512 = 288
tv563 = 296
regs$ = 336
icode$ = 344
z900_sie_exit PROC

; 1382 : {

$LN228:
  00000	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00004	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00009	56		 push	 rsi
  0000a	57		 push	 rdi
  0000b	48 81 ec 38 01
	00 00		 sub	 rsp, 312		; 00000138H

; 1383 :     int n;
; 1384 : #if defined( FEATURE_073_TRANSACT_EXEC_FACILITY )
; 1385 :     U64  itdba = 0;

  00012	48 c7 44 24 58
	00 00 00 00	 mov	 QWORD PTR itdba$[rsp], 0

; 1386 :     TDB* itdb = NULL;

  0001b	48 c7 84 24 88
	00 00 00 00 00
	00 00		 mov	 QWORD PTR itdb$[rsp], 0

; 1387 :     bool txf_contran = false;

  00027	c6 44 24 56 00	 mov	 BYTE PTR txf_contran$[rsp], 0

; 1388 :     BYTE txf_tnd = 0;

  0002c	c6 44 24 55 00	 mov	 BYTE PTR txf_tnd$[rsp], 0

; 1389 : #endif
; 1390 :     bool is_exrl = false;

  00031	c6 44 24 54 00	 mov	 BYTE PTR is_exrl$[rsp], 0
$LN4@z900_sie_e:

; 1391 : 
; 1392 :     //-----------------------------------------------------------
; 1393 :     //              IMPORTANT SIE PROGRAMMING NOTE!
; 1394 :     //-----------------------------------------------------------
; 1395 :     // NOTE: Our execution architectural mode is that of the SIE
; 1396 :     // HOST, not the GUEST! If you need to call a function on
; 1397 :     // behalf of the GUEST (passing it 'GUESTREGS'), you must be
; 1398 :     // careful to ensure the correct version of that function is
; 1399 :     // called! You cannot simply call the "ARCH_DEP" version of
; 1400 :     // a function as they are for the architectue of the HOST,
; 1401 :     // not the GUEST! (e.g. you can't call a "z900_xxx" function
; 1402 :     // and expect it to work correctly if the GUEST is actually
; 1403 :     // supposed to be run in s390 mode!) YOU HAVE BEEN WARNED!
; 1404 :     //-----------------------------------------------------------
; 1405 : 
; 1406 :     PTT_SIE( "sie_xit i,h,g", icode, regs->host, regs->guest );

  00036	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_pttclass
  0003d	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00040	48 25 80 00 00
	00		 and	 rax, 128		; 00000080H
  00046	48 85 c0	 test	 rax, rax
  00049	74 66		 je	 SHORT $LN84@z900_sie_e
  0004b	48 8b 84 24 50
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00053	8b 80 28 07 00
	00		 mov	 eax, DWORD PTR [rax+1832]
  00059	c1 e8 08	 shr	 eax, 8
  0005c	83 e0 01	 and	 eax, 1
  0005f	8b c0		 mov	 eax, eax
  00061	48 8b 8c 24 50
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00069	8b 89 28 07 00
	00		 mov	 ecx, DWORD PTR [rcx+1832]
  0006f	c1 e9 07	 shr	 ecx, 7
  00072	83 e1 01	 and	 ecx, 1
  00075	8b c9		 mov	 ecx, ecx
  00077	48 63 94 24 58
	01 00 00	 movsxd	 rdx, DWORD PTR icode$[rsp]
  0007f	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR [rsp+48], 0
  00088	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  0008d	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG195668
  00094	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00099	44 8b c9	 mov	 r9d, ecx
  0009c	4c 8b c2	 mov	 r8, rdx
  0009f	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG195669
  000a6	b9 80 00 00 00	 mov	 ecx, 128		; 00000080H
  000ab	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ptt_pthread_trace
$LN84@z900_sie_e:
  000b1	33 c0		 xor	 eax, eax
  000b3	85 c0		 test	 eax, eax
  000b5	0f 85 7b ff ff
	ff		 jne	 $LN4@z900_sie_e

; 1407 : 
; 1408 :     /* PTT trace the SIE Exit... */
; 1409 :     if (pttclass & PTT_CL_SIE)

  000bb	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_pttclass
  000c2	48 8b 00	 mov	 rax, QWORD PTR [rax]
  000c5	48 25 80 00 00
	00		 and	 rax, 128		; 00000080H
  000cb	48 85 c0	 test	 rax, rax
  000ce	0f 84 a5 03 00
	00		 je	 $LN85@z900_sie_e

; 1410 :     {
; 1411 :         // (include some instruction information in the trace entry)
; 1412 : 
; 1413 :         U32    nt1  = 0;        // First 2 or 4 bytes of instruction.

  000d4	c7 44 24 78 00
	00 00 00	 mov	 DWORD PTR nt1$5[rsp], 0

; 1414 :                                 // If ilc > 4 then last 2 bytes are
; 1415 :                                 // in the first 2 bytes of nt2.
; 1416 : 
; 1417 :         U32    nt2  = 0;        // First 2 bytes are last 2 bytes of

  000dc	c7 44 24 74 00
	00 00 00	 mov	 DWORD PTR nt2$4[rsp], 0

; 1418 :                                 // instruction when ilc = 6. Else 0.
; 1419 :                                 // Last 2 bytes is opcode of the "EX"
; 1420 :                                 // or "EXRL" instruction if instruction
; 1421 :                                 // was being "executed". Else zeros.
; 1422 : 
; 1423 :         BYTE*  ip   = NULL;     // Work: points to the instruction or,

  000e4	48 c7 44 24 68
	00 00 00 00	 mov	 QWORD PTR ip$3[rsp], 0

; 1424 :                                 // if execute, the target instruction.
; 1425 : 
; 1426 :         if (!GUESTREGS->instinvalid)

  000ed	48 8b 84 24 50
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  000f5	48 8b 80 70 08
	00 00		 mov	 rax, QWORD PTR [rax+2160]
  000fc	8b 80 28 07 00
	00		 mov	 eax, DWORD PTR [rax+1832]
  00102	c1 e8 03	 shr	 eax, 3
  00105	83 e0 01	 and	 eax, 1
  00108	85 c0		 test	 eax, eax
  0010a	0f 85 0c 03 00
	00		 jne	 $LN86@z900_sie_e

; 1427 :         {
; 1428 : #if defined( FEATURE_035_EXECUTE_EXTN_FACILITY )
; 1429 :             if (FACILITY_ENABLED( 035_EXECUTE_EXTN, GUESTREGS ))

  00110	48 8b 84 24 50
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00118	48 8b 80 70 08
	00 00		 mov	 rax, QWORD PTR [rax+2160]
  0011f	b9 01 00 00 00	 mov	 ecx, 1
  00124	48 6b c9 04	 imul	 rcx, rcx, 4
  00128	0f b6 84 08 28
	0d 00 00	 movzx	 eax, BYTE PTR [rax+rcx+3368]
  00130	83 e0 10	 and	 eax, 16
  00133	85 c0		 test	 eax, eax
  00135	0f 84 9b 00 00
	00		 je	 $LN87@z900_sie_e

; 1430 :             {
; 1431 :                 /* EXRL = Execute Relative Long instruction? */
; 1432 :                 is_exrl =

  0013b	33 c0		 xor	 eax, eax
  0013d	83 f8 01	 cmp	 eax, 1
  00140	74 5b		 je	 SHORT $LN166@z900_sie_e
  00142	48 8b 84 24 50
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0014a	48 8b 80 70 08
	00 00		 mov	 rax, QWORD PTR [rax+2160]
  00151	b9 01 00 00 00	 mov	 ecx, 1
  00156	48 6b c9 00	 imul	 rcx, rcx, 0
  0015a	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  0015e	0f b6 04 08	 movzx	 eax, BYTE PTR [rax+rcx]
  00162	3d c6 00 00 00	 cmp	 eax, 198		; 000000c6H
  00167	75 34		 jne	 SHORT $LN166@z900_sie_e
  00169	48 8b 84 24 50
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00171	48 8b 80 70 08
	00 00		 mov	 rax, QWORD PTR [rax+2160]
  00178	b9 01 00 00 00	 mov	 ecx, 1
  0017d	48 6b c9 01	 imul	 rcx, rcx, 1
  00181	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  00185	0f b6 04 08	 movzx	 eax, BYTE PTR [rax+rcx]
  00189	83 e0 0f	 and	 eax, 15
  0018c	85 c0		 test	 eax, eax
  0018e	75 0d		 jne	 SHORT $LN166@z900_sie_e
  00190	c7 84 24 e8 00
	00 00 01 00 00
	00		 mov	 DWORD PTR tv143[rsp], 1
  0019b	eb 0b		 jmp	 SHORT $LN167@z900_sie_e
$LN166@z900_sie_e:
  0019d	c7 84 24 e8 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv143[rsp], 0
$LN167@z900_sie_e:
  001a8	83 bc 24 e8 00
	00 00 00	 cmp	 DWORD PTR tv143[rsp], 0
  001b0	75 0d		 jne	 SHORT $LN168@z900_sie_e
  001b2	c7 84 24 f0 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv145[rsp], 0
  001bd	eb 0b		 jmp	 SHORT $LN169@z900_sie_e
$LN168@z900_sie_e:
  001bf	c7 84 24 f0 00
	00 00 01 00 00
	00		 mov	 DWORD PTR tv145[rsp], 1
$LN169@z900_sie_e:
  001ca	0f b6 84 24 f0
	00 00 00	 movzx	 eax, BYTE PTR tv145[rsp]
  001d2	88 44 24 54	 mov	 BYTE PTR is_exrl$[rsp], al
$LN87@z900_sie_e:

; 1433 :                 (1
; 1434 :                     &&   GUESTREGS->ip[0] == 0xc6
; 1435 :                     && !(GUESTREGS->ip[1] &  0x0f)
; 1436 :                 );
; 1437 :             }
; 1438 : #endif
; 1439 :             /* EX or EXRL instruction? */
; 1440 :             if (GUESTREGS->ip[0] == 0x44 || is_exrl)

  001d6	48 8b 84 24 50
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  001de	48 8b 80 70 08
	00 00		 mov	 rax, QWORD PTR [rax+2160]
  001e5	b9 01 00 00 00	 mov	 ecx, 1
  001ea	48 6b c9 00	 imul	 rcx, rcx, 0
  001ee	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  001f2	0f b6 04 08	 movzx	 eax, BYTE PTR [rax+rcx]
  001f6	83 f8 44	 cmp	 eax, 68			; 00000044H
  001f9	74 0d		 je	 SHORT $LN90@z900_sie_e
  001fb	0f b6 44 24 54	 movzx	 eax, BYTE PTR is_exrl$[rsp]
  00200	85 c0		 test	 eax, eax
  00202	0f 84 85 00 00
	00		 je	 $LN88@z900_sie_e
$LN90@z900_sie_e:

; 1441 :             {
; 1442 :                 ip  =  GUESTREGS->exinst;

  00208	48 8b 84 24 50
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00210	48 8b 80 70 08
	00 00		 mov	 rax, QWORD PTR [rax+2160]
  00217	48 05 40 08 00
	00		 add	 rax, 2112		; 00000840H
  0021d	48 89 44 24 68	 mov	 QWORD PTR ip$3[rsp], rax

; 1443 :                 nt2 = (GUESTREGS->ip[0] == 0x44) ? 0x44

  00222	48 8b 84 24 50
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0022a	48 8b 80 70 08
	00 00		 mov	 rax, QWORD PTR [rax+2160]
  00231	b9 01 00 00 00	 mov	 ecx, 1
  00236	48 6b c9 00	 imul	 rcx, rcx, 0
  0023a	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  0023e	0f b6 04 08	 movzx	 eax, BYTE PTR [rax+rcx]
  00242	83 f8 44	 cmp	 eax, 68			; 00000044H
  00245	75 0d		 jne	 SHORT $LN170@z900_sie_e
  00247	c7 84 24 f8 00
	00 00 44 00 00
	00		 mov	 DWORD PTR tv169[rsp], 68 ; 00000044H
  00252	eb 2c		 jmp	 SHORT $LN171@z900_sie_e
$LN170@z900_sie_e:
  00254	48 8b 84 24 50
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0025c	48 8b 80 70 08
	00 00		 mov	 rax, QWORD PTR [rax+2160]
  00263	b9 01 00 00 00	 mov	 ecx, 1
  00268	48 6b c9 01	 imul	 rcx, rcx, 1
  0026c	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  00270	0f b6 04 08	 movzx	 eax, BYTE PTR [rax+rcx]
  00274	0d 00 c6 00 00	 or	 eax, 50688		; 0000c600H
  00279	89 84 24 f8 00
	00 00		 mov	 DWORD PTR tv169[rsp], eax
$LN171@z900_sie_e:
  00280	8b 84 24 f8 00
	00 00		 mov	 eax, DWORD PTR tv169[rsp]
  00287	89 44 24 74	 mov	 DWORD PTR nt2$4[rsp], eax

; 1444 :                     : ((0xc6 << 8) | GUESTREGS->ip[1]);
; 1445 :             }

  0028b	eb 18		 jmp	 SHORT $LN89@z900_sie_e
$LN88@z900_sie_e:

; 1446 :             else // not execute
; 1447 :             {
; 1448 :                 ip  =  GUESTREGS->ip;

  0028d	48 8b 84 24 50
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00295	48 8b 80 70 08
	00 00		 mov	 rax, QWORD PTR [rax+2160]
  0029c	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  002a0	48 89 44 24 68	 mov	 QWORD PTR ip$3[rsp], rax
$LN89@z900_sie_e:

; 1449 :             }
; 1450 : 
; 1451 :             nt1 = (ip[0] << 24)

  002a5	b8 01 00 00 00	 mov	 eax, 1
  002aa	48 6b c0 00	 imul	 rax, rax, 0
  002ae	48 8b 4c 24 68	 mov	 rcx, QWORD PTR ip$3[rsp]
  002b3	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  002b7	c1 e0 18	 shl	 eax, 24
  002ba	b9 01 00 00 00	 mov	 ecx, 1
  002bf	48 6b c9 01	 imul	 rcx, rcx, 1
  002c3	48 8b 54 24 68	 mov	 rdx, QWORD PTR ip$3[rsp]
  002c8	0f b6 0c 0a	 movzx	 ecx, BYTE PTR [rdx+rcx]
  002cc	c1 e1 10	 shl	 ecx, 16
  002cf	0b c1		 or	 eax, ecx
  002d1	89 44 24 78	 mov	 DWORD PTR nt1$5[rsp], eax

; 1452 :                 | (ip[1] << 16);
; 1453 : 
; 1454 :             if (ILC( ip[0]) > 2)  nt1  |=  ((ip[2] <<  8) | (ip[3] <<  0));

  002d5	b8 01 00 00 00	 mov	 eax, 1
  002da	48 6b c0 00	 imul	 rax, rax, 0
  002de	48 8b 4c 24 68	 mov	 rcx, QWORD PTR ip$3[rsp]
  002e3	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  002e7	83 f8 40	 cmp	 eax, 64			; 00000040H
  002ea	7d 0d		 jge	 SHORT $LN174@z900_sie_e
  002ec	c7 84 24 94 00
	00 00 02 00 00
	00		 mov	 DWORD PTR tv190[rsp], 2
  002f7	eb 3f		 jmp	 SHORT $LN175@z900_sie_e
$LN174@z900_sie_e:
  002f9	b8 01 00 00 00	 mov	 eax, 1
  002fe	48 6b c0 00	 imul	 rax, rax, 0
  00302	48 8b 4c 24 68	 mov	 rcx, QWORD PTR ip$3[rsp]
  00307	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  0030b	3d c0 00 00 00	 cmp	 eax, 192		; 000000c0H
  00310	7d 0d		 jge	 SHORT $LN172@z900_sie_e
  00312	c7 84 24 90 00
	00 00 04 00 00
	00		 mov	 DWORD PTR tv189[rsp], 4
  0031d	eb 0b		 jmp	 SHORT $LN173@z900_sie_e
$LN172@z900_sie_e:
  0031f	c7 84 24 90 00
	00 00 06 00 00
	00		 mov	 DWORD PTR tv189[rsp], 6
$LN173@z900_sie_e:
  0032a	8b 84 24 90 00
	00 00		 mov	 eax, DWORD PTR tv189[rsp]
  00331	89 84 24 94 00
	00 00		 mov	 DWORD PTR tv190[rsp], eax
$LN175@z900_sie_e:
  00338	83 bc 24 94 00
	00 00 02	 cmp	 DWORD PTR tv190[rsp], 2
  00340	7e 35		 jle	 SHORT $LN91@z900_sie_e
  00342	b8 01 00 00 00	 mov	 eax, 1
  00347	48 6b c0 02	 imul	 rax, rax, 2
  0034b	48 8b 4c 24 68	 mov	 rcx, QWORD PTR ip$3[rsp]
  00350	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00354	c1 e0 08	 shl	 eax, 8
  00357	b9 01 00 00 00	 mov	 ecx, 1
  0035c	48 6b c9 03	 imul	 rcx, rcx, 3
  00360	48 8b 54 24 68	 mov	 rdx, QWORD PTR ip$3[rsp]
  00365	0f b6 0c 0a	 movzx	 ecx, BYTE PTR [rdx+rcx]
  00369	0b c1		 or	 eax, ecx
  0036b	8b 4c 24 78	 mov	 ecx, DWORD PTR nt1$5[rsp]
  0036f	0b c8		 or	 ecx, eax
  00371	8b c1		 mov	 eax, ecx
  00373	89 44 24 78	 mov	 DWORD PTR nt1$5[rsp], eax
$LN91@z900_sie_e:

; 1455 :             if (ILC( ip[0]) > 4)  nt2  |=  ((ip[4] << 24) | (ip[5] << 16));

  00377	b8 01 00 00 00	 mov	 eax, 1
  0037c	48 6b c0 00	 imul	 rax, rax, 0
  00380	48 8b 4c 24 68	 mov	 rcx, QWORD PTR ip$3[rsp]
  00385	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00389	83 f8 40	 cmp	 eax, 64			; 00000040H
  0038c	7d 0d		 jge	 SHORT $LN178@z900_sie_e
  0038e	c7 84 24 9c 00
	00 00 02 00 00
	00		 mov	 DWORD PTR tv210[rsp], 2
  00399	eb 3f		 jmp	 SHORT $LN179@z900_sie_e
$LN178@z900_sie_e:
  0039b	b8 01 00 00 00	 mov	 eax, 1
  003a0	48 6b c0 00	 imul	 rax, rax, 0
  003a4	48 8b 4c 24 68	 mov	 rcx, QWORD PTR ip$3[rsp]
  003a9	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  003ad	3d c0 00 00 00	 cmp	 eax, 192		; 000000c0H
  003b2	7d 0d		 jge	 SHORT $LN176@z900_sie_e
  003b4	c7 84 24 98 00
	00 00 04 00 00
	00		 mov	 DWORD PTR tv209[rsp], 4
  003bf	eb 0b		 jmp	 SHORT $LN177@z900_sie_e
$LN176@z900_sie_e:
  003c1	c7 84 24 98 00
	00 00 06 00 00
	00		 mov	 DWORD PTR tv209[rsp], 6
$LN177@z900_sie_e:
  003cc	8b 84 24 98 00
	00 00		 mov	 eax, DWORD PTR tv209[rsp]
  003d3	89 84 24 9c 00
	00 00		 mov	 DWORD PTR tv210[rsp], eax
$LN179@z900_sie_e:
  003da	83 bc 24 9c 00
	00 00 04	 cmp	 DWORD PTR tv210[rsp], 4
  003e2	7e 38		 jle	 SHORT $LN92@z900_sie_e
  003e4	b8 01 00 00 00	 mov	 eax, 1
  003e9	48 6b c0 04	 imul	 rax, rax, 4
  003ed	48 8b 4c 24 68	 mov	 rcx, QWORD PTR ip$3[rsp]
  003f2	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  003f6	c1 e0 18	 shl	 eax, 24
  003f9	b9 01 00 00 00	 mov	 ecx, 1
  003fe	48 6b c9 05	 imul	 rcx, rcx, 5
  00402	48 8b 54 24 68	 mov	 rdx, QWORD PTR ip$3[rsp]
  00407	0f b6 0c 0a	 movzx	 ecx, BYTE PTR [rdx+rcx]
  0040b	c1 e1 10	 shl	 ecx, 16
  0040e	0b c1		 or	 eax, ecx
  00410	8b 4c 24 74	 mov	 ecx, DWORD PTR nt2$4[rsp]
  00414	0b c8		 or	 ecx, eax
  00416	8b c1		 mov	 eax, ecx
  00418	89 44 24 74	 mov	 DWORD PTR nt2$4[rsp], eax
$LN92@z900_sie_e:
$LN86@z900_sie_e:
$LN7@z900_sie_e:

; 1456 :         }
; 1457 : 
; 1458 :         PTT_SIE( "sie_xit inst", icode, nt1, nt2  );

  0041c	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_pttclass
  00423	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00426	48 25 80 00 00
	00		 and	 rax, 128		; 00000080H
  0042c	48 85 c0	 test	 rax, rax
  0042f	74 42		 je	 SHORT $LN93@z900_sie_e
  00431	8b 44 24 74	 mov	 eax, DWORD PTR nt2$4[rsp]
  00435	8b 4c 24 78	 mov	 ecx, DWORD PTR nt1$5[rsp]
  00439	48 63 94 24 58
	01 00 00	 movsxd	 rdx, DWORD PTR icode$[rsp]
  00441	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR [rsp+48], 0
  0044a	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  0044f	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG195679
  00456	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  0045b	44 8b c9	 mov	 r9d, ecx
  0045e	4c 8b c2	 mov	 r8, rdx
  00461	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG195680
  00468	b9 80 00 00 00	 mov	 ecx, 128		; 00000080H
  0046d	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ptt_pthread_trace
$LN93@z900_sie_e:
  00473	33 c0		 xor	 eax, eax
  00475	85 c0		 test	 eax, eax
  00477	75 a3		 jne	 SHORT $LN7@z900_sie_e
$LN85@z900_sie_e:

; 1459 : 
; 1460 :     } // end PTT trace of SIE exit
; 1461 : 
; 1462 : #if defined( SIE_DEBUG )
; 1463 :     LOGMSG( "SIE: interception code %d = %s\n", icode, sie_icode_2str( icode ));
; 1464 :     ARCH_DEP( display_guest_inst )( GUESTREGS, GUESTREGS->instinvalid ? NULL : GUESTREGS->ip );
; 1465 : #endif
; 1466 : 
; 1467 :     SIE_PERFMON( SIE_PERF_EXIT   );
; 1468 :     SIE_PERFMON( SIE_PERF_PGMINT );
; 1469 : 
; 1470 :     {
; 1471 :         /* Obtain INTLOCK (unless we already own it) */
; 1472 :         REGS* realregs = GUEST( sysblk.regs[ regs->cpuad ]);

  00479	48 8b 84 24 50
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00481	0f b7 80 3c 08
	00 00		 movzx	 eax, WORD PTR [rax+2108]
  00488	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  0048f	48 8b 84 c1 98
	0b 00 00	 mov	 rax, QWORD PTR [rcx+rax*8+2968]
  00497	48 8b 80 70 08
	00 00		 mov	 rax, QWORD PTR [rax+2160]
  0049e	48 89 84 24 18
	01 00 00	 mov	 QWORD PTR realregs$9[rsp], rax

; 1473 :         if (!IS_INTLOCK_HELD( realregs ))

  004a6	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  004ad	0f b7 80 62 10
	00 00		 movzx	 eax, WORD PTR [rax+4194]
  004b4	48 8b 8c 24 18
	01 00 00	 mov	 rcx, QWORD PTR realregs$9[rsp]
  004bc	0f b7 89 3c 08
	00 00		 movzx	 ecx, WORD PTR [rcx+2108]
  004c3	3b c1		 cmp	 eax, ecx
  004c5	74 14		 je	 SHORT $LN94@z900_sie_e

; 1474 :             OBTAIN_INTLOCK( regs );

  004c7	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG195682
  004ce	48 8b 8c 24 50
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  004d6	e8 00 00 00 00	 call	 Obtain_Interrupt_Lock
$LN94@z900_sie_e:
$LN10@z900_sie_e:

; 1475 : 
; 1476 :         /* Indicate we have left SIE mode */
; 1477 :         PTT_SIE( "sie_xit a=0", 0, 0, 0  );

  004db	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_pttclass
  004e2	48 8b 00	 mov	 rax, QWORD PTR [rax]
  004e5	48 25 80 00 00
	00		 and	 rax, 128		; 00000080H
  004eb	48 85 c0	 test	 rax, rax
  004ee	74 36		 je	 SHORT $LN95@z900_sie_e
  004f0	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR [rsp+48], 0
  004f9	48 c7 44 24 28
	00 00 00 00	 mov	 QWORD PTR [rsp+40], 0
  00502	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG195684
  00509	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  0050e	45 33 c9	 xor	 r9d, r9d
  00511	45 33 c0	 xor	 r8d, r8d
  00514	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG195685
  0051b	b9 80 00 00 00	 mov	 ecx, 128		; 00000080H
  00520	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ptt_pthread_trace
$LN95@z900_sie_e:
  00526	33 c0		 xor	 eax, eax
  00528	85 c0		 test	 eax, eax
  0052a	75 af		 jne	 SHORT $LN10@z900_sie_e

; 1478 :         regs->sie_active = 0;

  0052c	48 8b 84 24 50
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00534	8b 80 c8 08 00
	00		 mov	 eax, DWORD PTR [rax+2248]
  0053a	83 e0 fe	 and	 eax, -2			; fffffffeH
  0053d	48 8b 8c 24 50
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00545	89 81 c8 08 00
	00		 mov	 DWORD PTR [rcx+2248], eax

; 1479 :         RELEASE_INTLOCK( regs );

  0054b	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG195686
  00552	48 8b 8c 24 50
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0055a	e8 00 00 00 00	 call	 Release_Interrupt_Lock

; 1480 :     }
; 1481 : 
; 1482 :     /* Zeroize interception status */
; 1483 :     STATEBK->f = 0;

  0055f	48 8b 84 24 50
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00567	48 8b 80 70 08
	00 00		 mov	 rax, QWORD PTR [rax+2160]
  0056e	48 8b 80 88 08
	00 00		 mov	 rax, QWORD PTR [rax+2184]
  00575	c6 40 51 00	 mov	 BYTE PTR [rax+81], 0

; 1484 : 
; 1485 :     /* Set the interception code in the SIE block */
; 1486 :     switch (icode < 0 ? icode : icode & 0xFF)

  00579	83 bc 24 58 01
	00 00 00	 cmp	 DWORD PTR icode$[rsp], 0
  00581	7d 10		 jge	 SHORT $LN180@z900_sie_e
  00583	8b 84 24 58 01
	00 00		 mov	 eax, DWORD PTR icode$[rsp]
  0058a	89 84 24 a0 00
	00 00		 mov	 DWORD PTR tv268[rsp], eax
  00591	eb 13		 jmp	 SHORT $LN181@z900_sie_e
$LN180@z900_sie_e:
  00593	8b 84 24 58 01
	00 00		 mov	 eax, DWORD PTR icode$[rsp]
  0059a	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  0059f	89 84 24 a0 00
	00 00		 mov	 DWORD PTR tv268[rsp], eax
$LN181@z900_sie_e:
  005a6	8b 84 24 a0 00
	00 00		 mov	 eax, DWORD PTR tv268[rsp]
  005ad	89 44 24 7c	 mov	 DWORD PTR tv269[rsp], eax
  005b1	8b 44 24 7c	 mov	 eax, DWORD PTR tv269[rsp]
  005b5	83 c0 11	 add	 eax, 17
  005b8	89 44 24 7c	 mov	 DWORD PTR tv269[rsp], eax
  005bc	83 7c 24 7c 12	 cmp	 DWORD PTR tv269[rsp], 18
  005c1	0f 87 80 03 00
	00		 ja	 $LN115@z900_sie_e
  005c7	48 63 44 24 7c	 movsxd	 rax, DWORD PTR tv269[rsp]
  005cc	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__ImageBase
  005d3	8b 84 81 00 00
	00 00		 mov	 eax, DWORD PTR $LN227@z900_sie_e[rcx+rax*4]
  005da	48 03 c1	 add	 rax, rcx
  005dd	ff e0		 jmp	 rax
$LN96@z900_sie_e:
$LN15@z900_sie_e:

; 1487 :     {
; 1488 :        /* If host interrupt pending, then backup psw so that the SIE
; 1489 :           instruction gets re-executed again to re-enter SIE mode
; 1490 :           once the interrupt is processed by the host.
; 1491 :         */
; 1492 :         case SIE_HOST_INT_PEND:
; 1493 : 
; 1494 :             MAYBE_SET_PSW_IA_FROM_IP( regs );

  005df	48 8b 84 24 50
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  005e7	48 83 b8 08 02
	00 00 00	 cmp	 QWORD PTR [rax+520], 0
  005ef	74 51		 je	 SHORT $LN97@z900_sie_e
  005f1	48 8b 84 24 50
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  005f9	48 8b 8c 24 50
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00601	48 8b 89 00 02
	00 00		 mov	 rcx, QWORD PTR [rcx+512]
  00608	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  0060c	48 2b c1	 sub	 rax, rcx
  0060f	48 8b 8c 24 50
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00617	48 8b 89 10 02
	00 00		 mov	 rcx, QWORD PTR [rcx+528]
  0061e	48 03 c8	 add	 rcx, rax
  00621	48 8b c1	 mov	 rax, rcx
  00624	48 8b 8c 24 50
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0062c	48 23 81 90 00
	00 00		 and	 rax, QWORD PTR [rcx+144]
  00633	48 8b 8c 24 50
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0063b	48 89 81 88 00
	00 00		 mov	 QWORD PTR [rcx+136], rax
$LN97@z900_sie_e:
  00642	33 c0		 xor	 eax, eax
  00644	85 c0		 test	 eax, eax
  00646	75 97		 jne	 SHORT $LN15@z900_sie_e
$LN18@z900_sie_e:

; 1495 :             SET_PSW_IA_AND_MAYBE_IP( regs, regs->psw.IA - REAL_ILC( regs ));

  00648	48 8b 84 24 50
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00650	8b 80 28 07 00
	00		 mov	 eax, DWORD PTR [rax+1832]
  00656	83 e0 01	 and	 eax, 1
  00659	85 c0		 test	 eax, eax
  0065b	75 0d		 jne	 SHORT $LN182@z900_sie_e
  0065d	c7 84 24 a4 00
	00 00 01 00 00
	00		 mov	 DWORD PTR tv286[rsp], 1
  00668	eb 0b		 jmp	 SHORT $LN183@z900_sie_e
$LN182@z900_sie_e:
  0066a	c7 84 24 a4 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv286[rsp], 0
$LN183@z900_sie_e:
  00675	83 bc 24 a4 00
	00 00 00	 cmp	 DWORD PTR tv286[rsp], 0
  0067d	74 0d		 je	 SHORT $LN186@z900_sie_e
  0067f	c7 84 24 a8 00
	00 00 01 00 00
	00		 mov	 DWORD PTR tv293[rsp], 1
  0068a	eb 0b		 jmp	 SHORT $LN187@z900_sie_e
$LN186@z900_sie_e:
  0068c	c7 84 24 a8 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv293[rsp], 0
$LN187@z900_sie_e:
  00697	83 bc 24 a8 00
	00 00 00	 cmp	 DWORD PTR tv293[rsp], 0
  0069f	74 18		 je	 SHORT $LN190@z900_sie_e
  006a1	48 8b 84 24 50
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  006a9	0f b6 80 9a 00
	00 00		 movzx	 eax, BYTE PTR [rax+154]
  006b0	89 84 24 b0 00
	00 00		 mov	 DWORD PTR tv302[rsp], eax
  006b7	eb 3d		 jmp	 SHORT $LN191@z900_sie_e
$LN190@z900_sie_e:
  006b9	48 8b 84 24 50
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  006c1	8b 80 28 07 00
	00		 mov	 eax, DWORD PTR [rax+1832]
  006c7	d1 e8		 shr	 eax, 1
  006c9	83 e0 01	 and	 eax, 1
  006cc	85 c0		 test	 eax, eax
  006ce	74 0d		 je	 SHORT $LN188@z900_sie_e
  006d0	c7 84 24 ac 00
	00 00 06 00 00
	00		 mov	 DWORD PTR tv300[rsp], 6
  006db	eb 0b		 jmp	 SHORT $LN189@z900_sie_e
$LN188@z900_sie_e:
  006dd	c7 84 24 ac 00
	00 00 04 00 00
	00		 mov	 DWORD PTR tv300[rsp], 4
$LN189@z900_sie_e:
  006e8	8b 84 24 ac 00
	00 00		 mov	 eax, DWORD PTR tv300[rsp]
  006ef	89 84 24 b0 00
	00 00		 mov	 DWORD PTR tv302[rsp], eax
$LN191@z900_sie_e:
  006f6	48 63 84 24 b0
	00 00 00	 movsxd	 rax, DWORD PTR tv302[rsp]
  006fe	48 8b 8c 24 50
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00706	48 8b 89 88 00
	00 00		 mov	 rcx, QWORD PTR [rcx+136]
  0070d	48 2b c8	 sub	 rcx, rax
  00710	48 8b c1	 mov	 rax, rcx
  00713	48 8b 8c 24 50
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0071b	48 23 81 90 00
	00 00		 and	 rax, QWORD PTR [rcx+144]
  00722	48 8b 8c 24 50
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0072a	48 89 81 88 00
	00 00		 mov	 QWORD PTR [rcx+136], rax
  00731	48 8b 84 24 50
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00739	48 83 b8 08 02
	00 00 00	 cmp	 QWORD PTR [rax+520], 0
  00741	74 71		 je	 SHORT $LN98@z900_sie_e
  00743	48 8b 84 24 50
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0074b	48 8b 80 88 00
	00 00		 mov	 rax, QWORD PTR [rax+136]
  00752	48 25 01 f0 ff
	ff		 and	 rax, -4095		; fffffffffffff001H
  00758	48 8b 8c 24 50
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00760	48 39 81 10 02
	00 00		 cmp	 QWORD PTR [rcx+528], rax
  00767	75 38		 jne	 SHORT $LN99@z900_sie_e
  00769	48 8b 84 24 50
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00771	48 8b 80 88 00
	00 00		 mov	 rax, QWORD PTR [rax+136]
  00778	48 25 ff 0f 00
	00		 and	 rax, 4095		; 00000fffH
  0077e	48 8b 8c 24 50
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00786	48 8b 89 00 02
	00 00		 mov	 rcx, QWORD PTR [rcx+512]
  0078d	48 0b c8	 or	 rcx, rax
  00790	48 8b c1	 mov	 rax, rcx
  00793	48 8b 8c 24 50
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0079b	48 89 41 68	 mov	 QWORD PTR [rcx+104], rax
  0079f	eb 13		 jmp	 SHORT $LN100@z900_sie_e
$LN99@z900_sie_e:
  007a1	48 8b 84 24 50
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  007a9	48 c7 80 08 02
	00 00 00 00 00
	00		 mov	 QWORD PTR [rax+520], 0
$LN100@z900_sie_e:
$LN98@z900_sie_e:
  007b4	33 c0		 xor	 eax, eax
  007b6	85 c0		 test	 eax, eax
  007b8	0f 85 8a fe ff
	ff		 jne	 $LN18@z900_sie_e

; 1496 :             break;

  007be	e9 9e 01 00 00	 jmp	 $LN11@z900_sie_e
$LN101@z900_sie_e:

; 1497 : 
; 1498 :         case SIE_HOST_PGM_INT:         /* do nothing */             break;

  007c3	e9 99 01 00 00	 jmp	 $LN11@z900_sie_e
$LN102@z900_sie_e:

; 1499 :         case SIE_INTERCEPT_INST:       STATEBK->c = SIE_C_INST;     break;

  007c8	48 8b 84 24 50
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  007d0	48 8b 80 70 08
	00 00		 mov	 rax, QWORD PTR [rax+2160]
  007d7	48 8b 80 88 08
	00 00		 mov	 rax, QWORD PTR [rax+2184]
  007de	c6 40 50 04	 mov	 BYTE PTR [rax+80], 4
  007e2	e9 7a 01 00 00	 jmp	 $LN11@z900_sie_e
$LN103@z900_sie_e:

; 1500 :         case SIE_INTERCEPT_PER:        STATEBK->f |= SIE_F_IF;

  007e7	48 8b 84 24 50
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  007ef	48 8b 80 70 08
	00 00		 mov	 rax, QWORD PTR [rax+2160]
  007f6	48 8b 80 88 08
	00 00		 mov	 rax, QWORD PTR [rax+2184]
  007fd	0f b6 40 51	 movzx	 eax, BYTE PTR [rax+81]
  00801	83 c8 02	 or	 eax, 2
  00804	48 8b 8c 24 50
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0080c	48 8b 89 70 08
	00 00		 mov	 rcx, QWORD PTR [rcx+2160]
  00813	48 8b 89 88 08
	00 00		 mov	 rcx, QWORD PTR [rcx+2184]
  0081a	88 41 51	 mov	 BYTE PTR [rcx+81], al
$LN104@z900_sie_e:

; 1501 :                                        /* fall through */
; 1502 :         case SIE_INTERCEPT_INSTCOMP:   STATEBK->c = SIE_C_BOTH;     break;

  0081d	48 8b 84 24 50
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00825	48 8b 80 70 08
	00 00		 mov	 rax, QWORD PTR [rax+2160]
  0082c	48 8b 80 88 08
	00 00		 mov	 rax, QWORD PTR [rax+2184]
  00833	c6 40 50 0c	 mov	 BYTE PTR [rax+80], 12
  00837	e9 25 01 00 00	 jmp	 $LN11@z900_sie_e
$LN105@z900_sie_e:

; 1503 :         case SIE_INTERCEPT_WAIT:       STATEBK->c = SIE_C_WAIT;     break;

  0083c	48 8b 84 24 50
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00844	48 8b 80 70 08
	00 00		 mov	 rax, QWORD PTR [rax+2160]
  0084b	48 8b 80 88 08
	00 00		 mov	 rax, QWORD PTR [rax+2184]
  00852	c6 40 50 1c	 mov	 BYTE PTR [rax+80], 28
  00856	e9 06 01 00 00	 jmp	 $LN11@z900_sie_e
$LN106@z900_sie_e:

; 1504 :         case SIE_INTERCEPT_STOPREQ:    STATEBK->c = SIE_C_STOPREQ;  break;

  0085b	48 8b 84 24 50
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00863	48 8b 80 70 08
	00 00		 mov	 rax, QWORD PTR [rax+2160]
  0086a	48 8b 80 88 08
	00 00		 mov	 rax, QWORD PTR [rax+2184]
  00871	c6 40 50 28	 mov	 BYTE PTR [rax+80], 40	; 00000028H
  00875	e9 e7 00 00 00	 jmp	 $LN11@z900_sie_e
$LN107@z900_sie_e:

; 1505 :         case SIE_INTERCEPT_IOREQ:      STATEBK->c = SIE_C_IOREQ;    break;

  0087a	48 8b 84 24 50
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00882	48 8b 80 70 08
	00 00		 mov	 rax, QWORD PTR [rax+2160]
  00889	48 8b 80 88 08
	00 00		 mov	 rax, QWORD PTR [rax+2184]
  00890	c6 40 50 18	 mov	 BYTE PTR [rax+80], 24
  00894	e9 c8 00 00 00	 jmp	 $LN11@z900_sie_e
$LN108@z900_sie_e:

; 1506 :         case SIE_INTERCEPT_EXTREQ:     STATEBK->c = SIE_C_EXTREQ;   break;

  00899	48 8b 84 24 50
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  008a1	48 8b 80 70 08
	00 00		 mov	 rax, QWORD PTR [rax+2160]
  008a8	48 8b 80 88 08
	00 00		 mov	 rax, QWORD PTR [rax+2184]
  008af	c6 40 50 10	 mov	 BYTE PTR [rax+80], 16
  008b3	e9 a9 00 00 00	 jmp	 $LN11@z900_sie_e
$LN109@z900_sie_e:

; 1507 :         case SIE_INTERCEPT_EXT:        STATEBK->c = SIE_C_EXTINT;   break;

  008b8	48 8b 84 24 50
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  008c0	48 8b 80 70 08
	00 00		 mov	 rax, QWORD PTR [rax+2160]
  008c7	48 8b 80 88 08
	00 00		 mov	 rax, QWORD PTR [rax+2184]
  008ce	c6 40 50 14	 mov	 BYTE PTR [rax+80], 20
  008d2	e9 8a 00 00 00	 jmp	 $LN11@z900_sie_e
$LN110@z900_sie_e:

; 1508 :         case SIE_INTERCEPT_VALIDITY:   STATEBK->c = SIE_C_VALIDITY; break;

  008d7	48 8b 84 24 50
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  008df	48 8b 80 70 08
	00 00		 mov	 rax, QWORD PTR [rax+2160]
  008e6	48 8b 80 88 08
	00 00		 mov	 rax, QWORD PTR [rax+2184]
  008ed	c6 40 50 20	 mov	 BYTE PTR [rax+80], 32	; 00000020H
  008f1	eb 6e		 jmp	 SHORT $LN11@z900_sie_e
$LN111@z900_sie_e:
$LN112@z900_sie_e:

; 1509 :         case SIE_INTERCEPT_IOINT:      /* fall through */
; 1510 :         case SIE_INTERCEPT_IOINTP:     STATEBK->c = SIE_C_IOINT;    break;

  008f3	48 8b 84 24 50
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  008fb	48 8b 80 70 08
	00 00		 mov	 rax, QWORD PTR [rax+2160]
  00902	48 8b 80 88 08
	00 00		 mov	 rax, QWORD PTR [rax+2184]
  00909	c6 40 50 3c	 mov	 BYTE PTR [rax+80], 60	; 0000003cH
  0090d	eb 52		 jmp	 SHORT $LN11@z900_sie_e
$LN113@z900_sie_e:

; 1511 :         case SIE_INTERCEPT_IOINST:     STATEBK->c = SIE_C_IOINST;   break;

  0090f	48 8b 84 24 50
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00917	48 8b 80 70 08
	00 00		 mov	 rax, QWORD PTR [rax+2160]
  0091e	48 8b 80 88 08
	00 00		 mov	 rax, QWORD PTR [rax+2184]
  00925	c6 40 50 40	 mov	 BYTE PTR [rax+80], 64	; 00000040H
  00929	eb 36		 jmp	 SHORT $LN11@z900_sie_e
$LN114@z900_sie_e:

; 1512 :         case PGM_OPERATION_EXCEPTION:  STATEBK->c = SIE_C_OPEREXC;  break;

  0092b	48 8b 84 24 50
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00933	48 8b 80 70 08
	00 00		 mov	 rax, QWORD PTR [rax+2160]
  0093a	48 8b 80 88 08
	00 00		 mov	 rax, QWORD PTR [rax+2184]
  00941	c6 40 50 2c	 mov	 BYTE PTR [rax+80], 44	; 0000002cH
  00945	eb 1a		 jmp	 SHORT $LN11@z900_sie_e
$LN115@z900_sie_e:

; 1513 :         default:                       STATEBK->c = SIE_C_PGMINT;   break;

  00947	48 8b 84 24 50
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0094f	48 8b 80 70 08
	00 00		 mov	 rax, QWORD PTR [rax+2160]
  00956	48 8b 80 88 08
	00 00		 mov	 rax, QWORD PTR [rax+2184]
  0095d	c6 40 50 08	 mov	 BYTE PTR [rax+80], 8
$LN11@z900_sie_e:
$LN21@z900_sie_e:

; 1514 :     }
; 1515 : 
; 1516 :     PTT_SIE( "sie_xit STA_c", STATEBK->c, 0, 0  );

  00961	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_pttclass
  00968	48 8b 00	 mov	 rax, QWORD PTR [rax]
  0096b	48 25 80 00 00
	00		 and	 rax, 128		; 00000080H
  00971	48 85 c0	 test	 rax, rax
  00974	74 50		 je	 SHORT $LN116@z900_sie_e
  00976	48 8b 84 24 50
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0097e	48 8b 80 70 08
	00 00		 mov	 rax, QWORD PTR [rax+2160]
  00985	48 8b 80 88 08
	00 00		 mov	 rax, QWORD PTR [rax+2184]
  0098c	0f b6 40 50	 movzx	 eax, BYTE PTR [rax+80]
  00990	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR [rsp+48], 0
  00999	48 c7 44 24 28
	00 00 00 00	 mov	 QWORD PTR [rsp+40], 0
  009a2	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG195708
  009a9	48 89 4c 24 20	 mov	 QWORD PTR [rsp+32], rcx
  009ae	45 33 c9	 xor	 r9d, r9d
  009b1	44 8b c0	 mov	 r8d, eax
  009b4	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG195709
  009bb	b9 80 00 00 00	 mov	 ecx, 128		; 00000080H
  009c0	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ptt_pthread_trace
$LN116@z900_sie_e:
  009c6	33 c0		 xor	 eax, eax
  009c8	85 c0		 test	 eax, eax
  009ca	75 95		 jne	 SHORT $LN21@z900_sie_e

; 1517 : 
; 1518 : #if defined( FEATURE_073_TRANSACT_EXEC_FACILITY )
; 1519 : 
; 1520 :     /* US 8,880,959 B2, Greiner et al, 17.20:
; 1521 : 
; 1522 :        "Interception TDB: The 256-byte host real location
; 1523 :         specified by locations 488-495 (x'1E8') of the state
; 1524 :         description."
; 1525 :     */
; 1526 :     FETCH_DW( itdba, STATEBK->itdba );

  009cc	48 8b 84 24 50
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  009d4	48 8b 80 70 08
	00 00		 mov	 rax, QWORD PTR [rax+2160]
  009db	48 8b 80 88 08
	00 00		 mov	 rax, QWORD PTR [rax+2184]
  009e2	48 05 e8 01 00
	00		 add	 rax, 488		; 000001e8H
  009e8	48 8b c8	 mov	 rcx, rax
  009eb	e8 00 00 00 00	 call	 fetch_dw_noswap
  009f0	48 8b c8	 mov	 rcx, rax
  009f3	e8 00 00 00 00	 call	 _byteswap_uint64
  009f8	48 89 44 24 58	 mov	 QWORD PTR itdba$[rsp], rax

; 1527 :     if (itdba)

  009fd	48 83 7c 24 58
	00		 cmp	 QWORD PTR itdba$[rsp], 0
  00a03	74 72		 je	 SHORT $LN117@z900_sie_e

; 1528 :         itdba = APPLY_PREFIXING( itdba, HOSTREGS->PX );

  00a05	48 8b 44 24 58	 mov	 rax, QWORD PTR itdba$[rsp]
  00a0a	48 25 00 e0 ff
	ff		 and	 rax, -8192		; ffffffffffffe000H
  00a10	48 85 c0	 test	 rax, rax
  00a13	74 2f		 je	 SHORT $LN192@z900_sie_e
  00a15	48 8b 44 24 58	 mov	 rax, QWORD PTR itdba$[rsp]
  00a1a	48 25 00 e0 ff
	ff		 and	 rax, -8192		; ffffffffffffe000H
  00a20	48 8b 8c 24 50
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00a28	48 8b 89 68 08
	00 00		 mov	 rcx, QWORD PTR [rcx+2152]
  00a2f	48 3b 41 70	 cmp	 rax, QWORD PTR [rcx+112]
  00a33	74 0f		 je	 SHORT $LN192@z900_sie_e
  00a35	48 8b 44 24 58	 mov	 rax, QWORD PTR itdba$[rsp]
  00a3a	48 89 84 24 08
	01 00 00	 mov	 QWORD PTR tv398[rsp], rax
  00a42	eb 26		 jmp	 SHORT $LN193@z900_sie_e
$LN192@z900_sie_e:
  00a44	48 8b 84 24 50
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00a4c	48 8b 80 68 08
	00 00		 mov	 rax, QWORD PTR [rax+2152]
  00a53	48 8b 40 70	 mov	 rax, QWORD PTR [rax+112]
  00a57	48 8b 4c 24 58	 mov	 rcx, QWORD PTR itdba$[rsp]
  00a5c	48 33 c8	 xor	 rcx, rax
  00a5f	48 8b c1	 mov	 rax, rcx
  00a62	48 89 84 24 08
	01 00 00	 mov	 QWORD PTR tv398[rsp], rax
$LN193@z900_sie_e:
  00a6a	48 8b 84 24 08
	01 00 00	 mov	 rax, QWORD PTR tv398[rsp]
  00a72	48 89 44 24 58	 mov	 QWORD PTR itdba$[rsp], rax
$LN117@z900_sie_e:
$LN24@z900_sie_e:

; 1529 : 
; 1530 :     PTT_TXF( "TXF itdb", itdba, 0, 0 );

  00a77	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_pttclass
  00a7e	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00a81	48 25 00 04 00
	00		 and	 rax, 1024		; 00000400H
  00a87	48 85 c0	 test	 rax, rax
  00a8a	74 38		 je	 SHORT $LN118@z900_sie_e
  00a8c	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR [rsp+48], 0
  00a95	48 c7 44 24 28
	00 00 00 00	 mov	 QWORD PTR [rsp+40], 0
  00a9e	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG195712
  00aa5	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00aaa	45 33 c9	 xor	 r9d, r9d
  00aad	4c 8b 44 24 58	 mov	 r8, QWORD PTR itdba$[rsp]
  00ab2	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG195713
  00ab9	b9 00 04 00 00	 mov	 ecx, 1024		; 00000400H
  00abe	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ptt_pthread_trace
$LN118@z900_sie_e:
  00ac4	33 c0		 xor	 eax, eax
  00ac6	85 c0		 test	 eax, eax
  00ac8	75 ad		 jne	 SHORT $LN24@z900_sie_e

; 1531 : 
; 1532 :     OBTAIN_TXFLOCK( GUESTREGS );

  00aca	48 8b 84 24 50
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00ad2	48 8b 80 70 08
	00 00		 mov	 rax, QWORD PTR [rax+2160]
  00ad9	0f b7 80 3c 08
	00 00		 movzx	 eax, WORD PTR [rax+2108]
  00ae0	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  00ae7	48 8d 84 c1 48
	03 00 00	 lea	 rax, QWORD PTR [rcx+rax*8+840]
  00aef	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG195714
  00af6	48 8b c8	 mov	 rcx, rax
  00af9	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_obtain_lock

; 1533 :     {
; 1534 :         txf_tnd     = GUESTREGS->txf_tnd;

  00aff	48 8b 84 24 50
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00b07	48 8b 80 70 08
	00 00		 mov	 rax, QWORD PTR [rax+2160]
  00b0e	0f b6 80 58 0e
	00 00		 movzx	 eax, BYTE PTR [rax+3672]
  00b15	88 44 24 55	 mov	 BYTE PTR txf_tnd$[rsp], al

; 1535 :         txf_contran = GUESTREGS->txf_contran;

  00b19	48 8b 84 24 50
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00b21	48 8b 80 70 08
	00 00		 mov	 rax, QWORD PTR [rax+2160]
  00b28	0f b6 80 4c 0e
	00 00		 movzx	 eax, BYTE PTR [rax+3660]
  00b2f	88 44 24 56	 mov	 BYTE PTR txf_contran$[rsp], al

; 1536 :     }
; 1537 :     RELEASE_TXFLOCK( GUESTREGS );

  00b33	48 8b 84 24 50
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00b3b	48 8b 80 70 08
	00 00		 mov	 rax, QWORD PTR [rax+2160]
  00b42	0f b7 80 3c 08
	00 00		 movzx	 eax, WORD PTR [rax+2108]
  00b49	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  00b50	48 8d 84 c1 48
	03 00 00	 lea	 rax, QWORD PTR [rcx+rax*8+840]
  00b58	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG195715
  00b5f	48 8b c8	 mov	 rcx, rax
  00b62	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_release_lock
$LN27@z900_sie_e:

; 1538 : 
; 1539 :     PTT_TXF( "TXF tnd,con", txf_tnd, txf_contran, 0 );

  00b68	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_pttclass
  00b6f	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00b72	48 25 00 04 00
	00		 and	 rax, 1024		; 00000400H
  00b78	48 85 c0	 test	 rax, rax
  00b7b	74 40		 je	 SHORT $LN119@z900_sie_e
  00b7d	0f b6 44 24 56	 movzx	 eax, BYTE PTR txf_contran$[rsp]
  00b82	0f b6 4c 24 55	 movzx	 ecx, BYTE PTR txf_tnd$[rsp]
  00b87	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR [rsp+48], 0
  00b90	48 c7 44 24 28
	00 00 00 00	 mov	 QWORD PTR [rsp+40], 0
  00b99	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG195717
  00ba0	48 89 54 24 20	 mov	 QWORD PTR [rsp+32], rdx
  00ba5	44 8b c8	 mov	 r9d, eax
  00ba8	44 8b c1	 mov	 r8d, ecx
  00bab	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG195718
  00bb2	b9 00 04 00 00	 mov	 ecx, 1024		; 00000400H
  00bb7	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ptt_pthread_trace
$LN119@z900_sie_e:
  00bbd	33 c0		 xor	 eax, eax
  00bbf	85 c0		 test	 eax, eax
  00bc1	75 a5		 jne	 SHORT $LN27@z900_sie_e

; 1540 : 
; 1541 :     /* "A transaction may be aborted due to causes that
; 1542 :         are outside the scope of the immediate configuration
; 1543 :         in which it executes. For example, transient events
; 1544 :         recognized by a hypervisor (such as LPAR or z/VM)
; 1545 :         may cause a transaction to be aborted."
; 1546 :     */
; 1547 :     if (txf_tnd)

  00bc3	0f b6 44 24 55	 movzx	 eax, BYTE PTR txf_tnd$[rsp]
  00bc8	85 c0		 test	 eax, eax
  00bca	0f 84 c4 00 00
	00		 je	 $LN120@z900_sie_e
$LN30@z900_sie_e:

; 1548 :     {
; 1549 :         PTT_TXF( "TXF abrt", 0, 0, TAC_MISC );

  00bd0	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_pttclass
  00bd7	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00bda	48 25 00 04 00
	00		 and	 rax, 1024		; 00000400H
  00be0	48 85 c0	 test	 rax, rax
  00be3	74 36		 je	 SHORT $LN122@z900_sie_e
  00be5	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR [rsp+48], 0
  00bee	48 c7 44 24 28
	ff 00 00 00	 mov	 QWORD PTR [rsp+40], 255	; 000000ffH
  00bf7	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG195722
  00bfe	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00c03	45 33 c9	 xor	 r9d, r9d
  00c06	45 33 c0	 xor	 r8d, r8d
  00c09	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG195723
  00c10	b9 00 04 00 00	 mov	 ecx, 1024		; 00000400H
  00c15	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ptt_pthread_trace
$LN122@z900_sie_e:
  00c1b	33 c0		 xor	 eax, eax
  00c1d	85 c0		 test	 eax, eax
  00c1f	75 af		 jne	 SHORT $LN30@z900_sie_e

; 1550 : 
; 1551 :         GUESTREGS->txf_why |= TXF_WHY_SIE_EXIT;

  00c21	48 8b 84 24 50
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00c29	48 8b 80 70 08
	00 00		 mov	 rax, QWORD PTR [rax+2160]
  00c30	8b 80 84 af 00
	00		 mov	 eax, DWORD PTR [rax+44932]
  00c36	0f ba e8 1a	 bts	 eax, 26
  00c3a	48 8b 8c 24 50
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00c42	48 8b 89 70 08
	00 00		 mov	 rcx, QWORD PTR [rcx+2160]
  00c49	89 81 84 af 00
	00		 mov	 DWORD PTR [rcx+44932], eax

; 1552 :         ABORT_TRANS( GUESTREGS, ABORT_RETRY_RETURN, TAC_MISC );

  00c4f	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG195724
  00c56	41 b8 ff 00 00
	00		 mov	 r8d, 255		; 000000ffH
  00c5c	33 d2		 xor	 edx, edx
  00c5e	48 8b 84 24 50
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00c66	48 8b 88 70 08
	00 00		 mov	 rcx, QWORD PTR [rax+2160]
  00c6d	e8 00 00 00 00	 call	 z900_abort_transaction

; 1553 :         itdb = &GUESTREGS->txf_tdb;

  00c72	48 8b 84 24 50
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00c7a	48 8b 80 70 08
	00 00		 mov	 rax, QWORD PTR [rax+2160]
  00c81	48 05 4b 0d 00
	00		 add	 rax, 3403		; 00000d4bH
  00c87	48 89 84 24 88
	00 00 00	 mov	 QWORD PTR itdb$[rsp], rax

; 1554 :     }

  00c8f	e9 b8 00 00 00	 jmp	 $LN121@z900_sie_e
$LN120@z900_sie_e:

; 1555 :     else if (GUESTREGS->txf_UPGM_abort)

  00c94	48 8b 84 24 50
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00c9c	48 8b 80 70 08
	00 00		 mov	 rax, QWORD PTR [rax+2160]
  00ca3	0f b6 80 4d 0e
	00 00		 movzx	 eax, BYTE PTR [rax+3661]
  00caa	85 c0		 test	 eax, eax
  00cac	0f 84 9a 00 00
	00		 je	 $LN123@z900_sie_e
$LN33@z900_sie_e:

; 1556 :     {
; 1557 :         PTT_TXF( "TXF upgm", GUESTREGS->txf_UPGM_abort, GUESTREGS->txf_aborts, 0 );

  00cb2	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_pttclass
  00cb9	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00cbc	48 25 00 04 00
	00		 and	 rax, 1024		; 00000400H
  00cc2	48 85 c0	 test	 rax, rax
  00cc5	74 62		 je	 SHORT $LN124@z900_sie_e
  00cc7	48 8b 84 24 50
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00ccf	48 8b 80 70 08
	00 00		 mov	 rax, QWORD PTR [rax+2160]
  00cd6	48 63 80 50 0e
	00 00		 movsxd	 rax, DWORD PTR [rax+3664]
  00cdd	48 8b 8c 24 50
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00ce5	48 8b 89 70 08
	00 00		 mov	 rcx, QWORD PTR [rcx+2160]
  00cec	0f b6 89 4d 0e
	00 00		 movzx	 ecx, BYTE PTR [rcx+3661]
  00cf3	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR [rsp+48], 0
  00cfc	48 c7 44 24 28
	00 00 00 00	 mov	 QWORD PTR [rsp+40], 0
  00d05	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG195727
  00d0c	48 89 54 24 20	 mov	 QWORD PTR [rsp+32], rdx
  00d11	4c 8b c8	 mov	 r9, rax
  00d14	44 8b c1	 mov	 r8d, ecx
  00d17	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG195728
  00d1e	b9 00 04 00 00	 mov	 ecx, 1024		; 00000400H
  00d23	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ptt_pthread_trace
$LN124@z900_sie_e:
  00d29	33 c0		 xor	 eax, eax
  00d2b	85 c0		 test	 eax, eax
  00d2d	75 83		 jne	 SHORT $LN33@z900_sie_e

; 1558 :         itdb = &GUESTREGS->txf_tdb;

  00d2f	48 8b 84 24 50
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00d37	48 8b 80 70 08
	00 00		 mov	 rax, QWORD PTR [rax+2160]
  00d3e	48 05 4b 0d 00
	00		 add	 rax, 3403		; 00000d4bH
  00d44	48 89 84 24 88
	00 00 00	 mov	 QWORD PTR itdb$[rsp], rax
$LN123@z900_sie_e:
$LN121@z900_sie_e:

; 1559 :     }
; 1560 : 
; 1561 :     /* Check if we need to fill in an Interception TDB */
; 1562 :     if (STATEBK->c == SIE_C_PGMINT && itdba && itdb)

  00d4c	48 8b 84 24 50
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00d54	48 8b 80 70 08
	00 00		 mov	 rax, QWORD PTR [rax+2160]
  00d5b	48 8b 80 88 08
	00 00		 mov	 rax, QWORD PTR [rax+2184]
  00d62	0f b6 40 50	 movzx	 eax, BYTE PTR [rax+80]
  00d66	83 f8 08	 cmp	 eax, 8
  00d69	0f 85 7b 01 00
	00		 jne	 $LN125@z900_sie_e
  00d6f	48 83 7c 24 58
	00		 cmp	 QWORD PTR itdba$[rsp], 0
  00d75	0f 84 6f 01 00
	00		 je	 $LN125@z900_sie_e
  00d7b	48 83 bc 24 88
	00 00 00 00	 cmp	 QWORD PTR itdb$[rsp], 0
  00d84	0f 84 60 01 00
	00		 je	 $LN125@z900_sie_e
$LN36@z900_sie_e:

; 1563 :     {
; 1564 :         PTT_TXF( "TXF itdb <=", itdba, itdb, itdb->tdb_tac );

  00d8a	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_pttclass
  00d91	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00d94	48 25 00 04 00
	00		 and	 rax, 1024		; 00000400H
  00d9a	48 85 c0	 test	 rax, rax
  00d9d	74 45		 je	 SHORT $LN127@z900_sie_e
  00d9f	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR itdb$[rsp]
  00da7	48 83 c0 08	 add	 rax, 8
  00dab	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR [rsp+48], 0
  00db4	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  00db9	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG195732
  00dc0	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00dc5	4c 8b 8c 24 88
	00 00 00	 mov	 r9, QWORD PTR itdb$[rsp]
  00dcd	4c 8b 44 24 58	 mov	 r8, QWORD PTR itdba$[rsp]
  00dd2	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG195733
  00dd9	b9 00 04 00 00	 mov	 ecx, 1024		; 00000400H
  00dde	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ptt_pthread_trace
$LN127@z900_sie_e:
  00de4	33 c0		 xor	 eax, eax
  00de6	85 c0		 test	 eax, eax
  00de8	75 a0		 jne	 SHORT $LN36@z900_sie_e

; 1565 : 
; 1566 :         /* US 8,880,959 B2, Greiner et al, 17.20:
; 1567 : 
; 1568 :            "The interception TDB is stored when an aborted
; 1569 :             transaction results in a guest program interruption
; 1570 :             interception (i.e. interception code 8).  When a
; 1571 :             transaction is aborted due to other causes, the
; 1572 :             contents of the interception TDB are unpredictable."
; 1573 :         */
; 1574 :         if (TXF_TRACING())

  00dea	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00df1	83 b8 4c 05 00
	00 00		 cmp	 DWORD PTR [rax+1356], 0
  00df8	0f 84 b9 00 00
	00		 je	 $LN128@z900_sie_e

; 1575 :         {
; 1576 :             // "TXF: %s%02X: SIE: Populating Interception TDB at 0x%16.16"PRIx64
; 1577 :             WRMSG( HHC17714, "D", TXF_CPUAD( GUESTREGS ), itdba );

  00dfe	48 8b 84 24 50
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00e06	48 8b 80 70 08
	00 00		 mov	 rax, QWORD PTR [rax+2160]
  00e0d	0f b7 80 3c 08
	00 00		 movzx	 eax, WORD PTR [rax+2108]
  00e14	89 84 24 fc 00
	00 00		 mov	 DWORD PTR tv510[rsp], eax
  00e1b	48 8b 8c 24 50
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00e23	48 8b 89 70 08
	00 00		 mov	 rcx, QWORD PTR [rcx+2160]
  00e2a	0f b7 89 3c 08
	00 00		 movzx	 ecx, WORD PTR [rcx+2108]
  00e31	48 8b 15 00 00
	00 00		 mov	 rdx, QWORD PTR __imp_sysblk
  00e38	0f b6 8c 0a 48
	0b 00 00	 movzx	 ecx, BYTE PTR [rdx+rcx+2888]
  00e40	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ptyp2short
  00e46	48 89 84 24 20
	01 00 00	 mov	 QWORD PTR tv512[rsp], rax
  00e4e	b9 01 00 00 00	 mov	 ecx, 1
  00e53	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  00e59	48 8b 4c 24 58	 mov	 rcx, QWORD PTR itdba$[rsp]
  00e5e	48 89 4c 24 48	 mov	 QWORD PTR [rsp+72], rcx
  00e63	8b 8c 24 fc 00
	00 00		 mov	 ecx, DWORD PTR tv510[rsp]
  00e6a	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  00e6e	48 8b 8c 24 20
	01 00 00	 mov	 rcx, QWORD PTR tv512[rsp]
  00e76	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  00e7b	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG195735
  00e82	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  00e87	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG195736
  00e8e	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00e93	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00e98	41 b9 03 00 00
	00		 mov	 r9d, 3
  00e9e	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG195737
  00ea5	ba 29 06 00 00	 mov	 edx, 1577		; 00000629H
  00eaa	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG195738
  00eb1	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg
$LN128@z900_sie_e:

; 1578 :         }
; 1579 : 
; 1580 :         memcpy( HOSTREGS->mainstor + itdba, itdb, sizeof( TDB ));

  00eb7	48 8b 84 24 50
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00ebf	48 8b 80 68 08
	00 00		 mov	 rax, QWORD PTR [rax+2152]
  00ec6	48 8b 80 48 08
	00 00		 mov	 rax, QWORD PTR [rax+2120]
  00ecd	48 8b 4c 24 58	 mov	 rcx, QWORD PTR itdba$[rsp]
  00ed2	48 8d 3c 08	 lea	 rdi, QWORD PTR [rax+rcx]
  00ed6	48 8b b4 24 88
	00 00 00	 mov	 rsi, QWORD PTR itdb$[rsp]
  00ede	b9 00 01 00 00	 mov	 ecx, 256		; 00000100H
  00ee3	f3 a4		 rep movsb

; 1581 :     }

  00ee5	e9 ff 01 00 00	 jmp	 $LN126@z900_sie_e
$LN125@z900_sie_e:

; 1582 :     else if (STATEBK->c == SIE_C_PGMINT && itdb)

  00eea	48 8b 84 24 50
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00ef2	48 8b 80 70 08
	00 00		 mov	 rax, QWORD PTR [rax+2160]
  00ef9	48 8b 80 88 08
	00 00		 mov	 rax, QWORD PTR [rax+2184]
  00f00	0f b6 40 50	 movzx	 eax, BYTE PTR [rax+80]
  00f04	83 f8 08	 cmp	 eax, 8
  00f07	0f 85 37 01 00
	00		 jne	 $LN129@z900_sie_e
  00f0d	48 83 bc 24 88
	00 00 00 00	 cmp	 QWORD PTR itdb$[rsp], 0
  00f16	0f 84 28 01 00
	00		 je	 $LN129@z900_sie_e
$LN39@z900_sie_e:

; 1583 :     {
; 1584 :         PTT_TXF( "*TXF !itdba", itdba, itdb, itdb->tdb_tac );

  00f1c	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_pttclass
  00f23	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00f26	48 25 00 04 00
	00		 and	 rax, 1024		; 00000400H
  00f2c	48 85 c0	 test	 rax, rax
  00f2f	74 45		 je	 SHORT $LN131@z900_sie_e
  00f31	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR itdb$[rsp]
  00f39	48 83 c0 08	 add	 rax, 8
  00f3d	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR [rsp+48], 0
  00f46	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  00f4b	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG195742
  00f52	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00f57	4c 8b 8c 24 88
	00 00 00	 mov	 r9, QWORD PTR itdb$[rsp]
  00f5f	4c 8b 44 24 58	 mov	 r8, QWORD PTR itdba$[rsp]
  00f64	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG195743
  00f6b	b9 00 04 00 00	 mov	 ecx, 1024		; 00000400H
  00f70	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ptt_pthread_trace
$LN131@z900_sie_e:
  00f76	33 c0		 xor	 eax, eax
  00f78	85 c0		 test	 eax, eax
  00f7a	75 a0		 jne	 SHORT $LN39@z900_sie_e

; 1585 : 
; 1586 :         if (TXF_TRACING())

  00f7c	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00f83	83 b8 4c 05 00
	00 00		 cmp	 DWORD PTR [rax+1356], 0
  00f8a	0f 84 af 00 00
	00		 je	 $LN132@z900_sie_e

; 1587 :         {
; 1588 :             // "TXF: %s%02X: SIE: Interception TDB address not provided!"
; 1589 :             WRMSG( HHC17716, "D", TXF_CPUAD( GUESTREGS ));

  00f90	48 8b 84 24 50
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00f98	48 8b 80 70 08
	00 00		 mov	 rax, QWORD PTR [rax+2160]
  00f9f	0f b7 80 3c 08
	00 00		 movzx	 eax, WORD PTR [rax+2108]
  00fa6	89 84 24 00 01
	00 00		 mov	 DWORD PTR tv561[rsp], eax
  00fad	48 8b 8c 24 50
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00fb5	48 8b 89 70 08
	00 00		 mov	 rcx, QWORD PTR [rcx+2160]
  00fbc	0f b7 89 3c 08
	00 00		 movzx	 ecx, WORD PTR [rcx+2108]
  00fc3	48 8b 15 00 00
	00 00		 mov	 rdx, QWORD PTR __imp_sysblk
  00fca	0f b6 8c 0a 48
	0b 00 00	 movzx	 ecx, BYTE PTR [rdx+rcx+2888]
  00fd2	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ptyp2short
  00fd8	48 89 84 24 28
	01 00 00	 mov	 QWORD PTR tv563[rsp], rax
  00fe0	b9 01 00 00 00	 mov	 ecx, 1
  00fe5	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  00feb	8b 8c 24 00 01
	00 00		 mov	 ecx, DWORD PTR tv561[rsp]
  00ff2	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  00ff6	48 8b 8c 24 28
	01 00 00	 mov	 rcx, QWORD PTR tv563[rsp]
  00ffe	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  01003	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG195745
  0100a	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  0100f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG195746
  01016	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  0101b	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  01020	41 b9 03 00 00
	00		 mov	 r9d, 3
  01026	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG195747
  0102d	ba 35 06 00 00	 mov	 edx, 1589		; 00000635H
  01032	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG195748
  01039	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg
$LN132@z900_sie_e:

; 1590 :         }
; 1591 :     }

  0103f	e9 a5 00 00 00	 jmp	 $LN130@z900_sie_e
$LN129@z900_sie_e:

; 1592 :     else if (STATEBK->c != SIE_C_PGMINT && itdba)

  01044	48 8b 84 24 50
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0104c	48 8b 80 70 08
	00 00		 mov	 rax, QWORD PTR [rax+2160]
  01053	48 8b 80 88 08
	00 00		 mov	 rax, QWORD PTR [rax+2184]
  0105a	0f b6 40 50	 movzx	 eax, BYTE PTR [rax+80]
  0105e	83 f8 08	 cmp	 eax, 8
  01061	0f 84 82 00 00
	00		 je	 $LN133@z900_sie_e
  01067	48 83 7c 24 58
	00		 cmp	 QWORD PTR itdba$[rsp], 0
  0106d	74 7a		 je	 SHORT $LN133@z900_sie_e
$LN42@z900_sie_e:

; 1593 :     {
; 1594 :         PTT_TXF( "*TXF itdba<=0", itdba, 0, 0 );

  0106f	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_pttclass
  01076	48 8b 00	 mov	 rax, QWORD PTR [rax]
  01079	48 25 00 04 00
	00		 and	 rax, 1024		; 00000400H
  0107f	48 85 c0	 test	 rax, rax
  01082	74 38		 je	 SHORT $LN134@z900_sie_e
  01084	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR [rsp+48], 0
  0108d	48 c7 44 24 28
	00 00 00 00	 mov	 QWORD PTR [rsp+40], 0
  01096	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG195751
  0109d	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  010a2	45 33 c9	 xor	 r9d, r9d
  010a5	4c 8b 44 24 58	 mov	 r8, QWORD PTR itdba$[rsp]
  010aa	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG195752
  010b1	b9 00 04 00 00	 mov	 ecx, 1024		; 00000400H
  010b6	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ptt_pthread_trace
$LN134@z900_sie_e:
  010bc	33 c0		 xor	 eax, eax
  010be	85 c0		 test	 eax, eax
  010c0	75 ad		 jne	 SHORT $LN42@z900_sie_e

; 1595 : 
; 1596 :         /* The address of an Interception TDB was provided, but no
; 1597 :            transaction was aborted as a result of this intercepted
; 1598 :            program interrupt. For safety, return a "NULL" (empty)
; 1599 :            Interception TDB instead. (Sorry Dan! Could not locate
; 1600 :            Claudia Schiffers phone number!)
; 1601 :         */
; 1602 :         memset( HOSTREGS->mainstor + itdba, 0, sizeof( TDB ));

  010c2	48 8b 84 24 50
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  010ca	48 8b 80 68 08
	00 00		 mov	 rax, QWORD PTR [rax+2152]
  010d1	48 8b 80 48 08
	00 00		 mov	 rax, QWORD PTR [rax+2120]
  010d8	48 03 44 24 58	 add	 rax, QWORD PTR itdba$[rsp]
  010dd	48 8b f8	 mov	 rdi, rax
  010e0	33 c0		 xor	 eax, eax
  010e2	b9 00 01 00 00	 mov	 ecx, 256		; 00000100H
  010e7	f3 aa		 rep stosb
$LN133@z900_sie_e:
$LN130@z900_sie_e:
$LN126@z900_sie_e:

; 1603 :     }
; 1604 : 
; 1605 : #endif /* defined( FEATURE_073_TRANSACT_EXEC_FACILITY ) */
; 1606 : 
; 1607 :     /* Save CPU timer  */
; 1608 :     STORE_DW( STATEBK->cputimer, get_cpu_timer( GUESTREGS ));

  010e9	48 8b 84 24 50
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  010f1	48 8b 88 70 08
	00 00		 mov	 rcx, QWORD PTR [rax+2160]
  010f8	e8 00 00 00 00	 call	 get_cpu_timer
  010fd	48 8b c8	 mov	 rcx, rax
  01100	e8 00 00 00 00	 call	 _byteswap_uint64
  01105	48 8b 8c 24 50
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0110d	48 8b 89 70 08
	00 00		 mov	 rcx, QWORD PTR [rcx+2160]
  01114	48 8b 89 88 08
	00 00		 mov	 rcx, QWORD PTR [rcx+2184]
  0111b	48 83 c1 28	 add	 rcx, 40			; 00000028H
  0111f	48 8b d0	 mov	 rdx, rax
  01122	e8 00 00 00 00	 call	 store_dw_noswap

; 1609 : 
; 1610 :     /* Save clock comparator */
; 1611 :     STORE_DW( STATEBK->clockcomp, ETOD_high64_to_TOD_high56( GUESTREGS->clkc ));

  01127	48 8b 84 24 50
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0112f	48 8b 80 70 08
	00 00		 mov	 rax, QWORD PTR [rax+2160]
  01136	48 8b 88 48 07
	00 00		 mov	 rcx, QWORD PTR [rax+1864]
  0113d	e8 00 00 00 00	 call	 ETOD_high64_to_TOD_high56
  01142	48 8b c8	 mov	 rcx, rax
  01145	e8 00 00 00 00	 call	 _byteswap_uint64
  0114a	48 8b 8c 24 50
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  01152	48 8b 89 70 08
	00 00		 mov	 rcx, QWORD PTR [rcx+2160]
  01159	48 8b 89 88 08
	00 00		 mov	 rcx, QWORD PTR [rcx+2184]
  01160	48 83 c1 30	 add	 rcx, 48			; 00000030H
  01164	48 8b d0	 mov	 rdx, rax
  01167	e8 00 00 00 00	 call	 store_dw_noswap

; 1612 : 
; 1613 : #if defined( _FEATURE_INTERVAL_TIMER ) && !defined( FEATURE_001_ZARCH_INSTALLED_FACILITY )
; 1614 :     /* If this is a S/370 guest, and the interval timer is enabled
; 1615 :        then save the timer state control bit
; 1616 :     */
; 1617 :     if (1
; 1618 :         &&  (STATEBK->m & SIE_M_370)
; 1619 :         && !(STATEBK->m & SIE_M_ITMOF)
; 1620 :     )
; 1621 :     {
; 1622 :         /* Save the shadow interval timer */
; 1623 :         s370_store_int_timer( regs );
; 1624 : 
; 1625 :         if (IS_IC_ITIMER( GUESTREGS )) STATEBK->s |=  SIE_S_T;
; 1626 :         else                           STATEBK->s &= ~SIE_S_T;
; 1627 :     }
; 1628 : #endif /* defined( _FEATURE_INTERVAL_TIMER ) && !defined( FEATURE_001_ZARCH_INSTALLED_FACILITY ) */
; 1629 : 
; 1630 :     /* Save TOD Programmable Field */
; 1631 :     STORE_HW( STATEBK->todpf, GUESTREGS->todpr );

  0116c	48 8b 84 24 50
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  01174	48 8b 80 70 08
	00 00		 mov	 rax, QWORD PTR [rax+2160]
  0117b	0f b7 88 58 07
	00 00		 movzx	 ecx, WORD PTR [rax+1880]
  01182	e8 00 00 00 00	 call	 _byteswap_ushort
  01187	48 8b 8c 24 50
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0118f	48 8b 89 70 08
	00 00		 mov	 rcx, QWORD PTR [rcx+2160]
  01196	48 8b 89 88 08
	00 00		 mov	 rcx, QWORD PTR [rcx+2184]
  0119d	48 83 c1 6e	 add	 rcx, 110		; 0000006eH
  011a1	0f b7 d0	 movzx	 edx, ax
  011a4	e8 00 00 00 00	 call	 store_hw_noswap

; 1632 : 
; 1633 :     /* Save GR14 and GR15 */
; 1634 :     STORE_W( STATEBK->gr14, GUESTREGS->GR( 14 ));

  011a9	48 8b 84 24 50
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  011b1	48 8b 80 70 08
	00 00		 mov	 rax, QWORD PTR [rax+2160]
  011b8	b9 08 00 00 00	 mov	 ecx, 8
  011bd	48 6b c9 0e	 imul	 rcx, rcx, 14
  011c1	48 8b 8c 08 80
	02 00 00	 mov	 rcx, QWORD PTR [rax+rcx+640]
  011c9	e8 00 00 00 00	 call	 _byteswap_uint64
  011ce	48 8b 8c 24 50
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  011d6	48 8b 89 70 08
	00 00		 mov	 rcx, QWORD PTR [rcx+2160]
  011dd	48 8b 89 88 08
	00 00		 mov	 rcx, QWORD PTR [rcx+2184]
  011e4	48 81 c1 a0 00
	00 00		 add	 rcx, 160		; 000000a0H
  011eb	48 8b d0	 mov	 rdx, rax
  011ee	e8 00 00 00 00	 call	 store_dw_noswap

; 1635 :     STORE_W( STATEBK->gr15, GUESTREGS->GR( 15 ));

  011f3	48 8b 84 24 50
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  011fb	48 8b 80 70 08
	00 00		 mov	 rax, QWORD PTR [rax+2160]
  01202	b9 08 00 00 00	 mov	 ecx, 8
  01207	48 6b c9 0f	 imul	 rcx, rcx, 15
  0120b	48 8b 8c 08 80
	02 00 00	 mov	 rcx, QWORD PTR [rax+rcx+640]
  01213	e8 00 00 00 00	 call	 _byteswap_uint64
  01218	48 8b 8c 24 50
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  01220	48 8b 89 70 08
	00 00		 mov	 rcx, QWORD PTR [rcx+2160]
  01227	48 8b 89 88 08
	00 00		 mov	 rcx, QWORD PTR [rcx+2184]
  0122e	48 81 c1 a8 00
	00 00		 add	 rcx, 168		; 000000a8H
  01235	48 8b d0	 mov	 rdx, rax
  01238	e8 00 00 00 00	 call	 store_dw_noswap

; 1636 : 
; 1637 :     /* Store the PSW */
; 1638 :     if (GUESTREGS->arch_mode == ARCH_390_IDX)

  0123d	48 8b 84 24 50
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  01245	48 8b 80 70 08
	00 00		 mov	 rax, QWORD PTR [rax+2160]
  0124c	83 78 64 01	 cmp	 DWORD PTR [rax+100], 1
  01250	75 35		 jne	 SHORT $LN135@z900_sie_e

; 1639 :         s390_store_psw( GUESTREGS, STATEBK->psw );

  01252	48 8b 84 24 50
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0125a	48 8b 80 70 08
	00 00		 mov	 rax, QWORD PTR [rax+2160]
  01261	48 8b 80 88 08
	00 00		 mov	 rax, QWORD PTR [rax+2184]
  01268	48 05 90 00 00
	00		 add	 rax, 144		; 00000090H
  0126e	48 8b d0	 mov	 rdx, rax
  01271	48 8b 84 24 50
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  01279	48 8b 88 70 08
	00 00		 mov	 rcx, QWORD PTR [rax+2160]
  01280	e8 00 00 00 00	 call	 s390_store_psw
  01285	eb 33		 jmp	 SHORT $LN136@z900_sie_e
$LN135@z900_sie_e:

; 1640 : #if defined( _370 ) || defined( _900 )
; 1641 :     else
; 1642 : #endif
; 1643 : #if defined( FEATURE_001_ZARCH_INSTALLED_FACILITY )
; 1644 :         z900_store_psw( GUESTREGS, STATEBK->psw );

  01287	48 8b 84 24 50
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0128f	48 8b 80 70 08
	00 00		 mov	 rax, QWORD PTR [rax+2160]
  01296	48 8b 80 88 08
	00 00		 mov	 rax, QWORD PTR [rax+2184]
  0129d	48 05 90 00 00
	00		 add	 rax, 144		; 00000090H
  012a3	48 8b d0	 mov	 rdx, rax
  012a6	48 8b 84 24 50
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  012ae	48 8b 88 70 08
	00 00		 mov	 rcx, QWORD PTR [rax+2160]
  012b5	e8 00 00 00 00	 call	 z900_store_psw
$LN136@z900_sie_e:

; 1645 : #else
; 1646 : #if defined( _370 )
; 1647 :         s370_store_psw( GUESTREGS, STATEBK->psw );
; 1648 : #endif
; 1649 : #endif
; 1650 :     /* Save control registers */
; 1651 :     for (n=0; n < 16; n++)

  012ba	c7 44 24 70 00
	00 00 00	 mov	 DWORD PTR n$[rsp], 0
  012c2	eb 0a		 jmp	 SHORT $LN45@z900_sie_e
$LN43@z900_sie_e:
  012c4	8b 44 24 70	 mov	 eax, DWORD PTR n$[rsp]
  012c8	ff c0		 inc	 eax
  012ca	89 44 24 70	 mov	 DWORD PTR n$[rsp], eax
$LN45@z900_sie_e:
  012ce	83 7c 24 70 10	 cmp	 DWORD PTR n$[rsp], 16
  012d3	7d 52		 jge	 SHORT $LN44@z900_sie_e

; 1652 :         STORE_W( STATEBK->cr[ n ], GUESTREGS->CR( n ));

  012d5	48 8b 84 24 50
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  012dd	48 8b 80 70 08
	00 00		 mov	 rax, QWORD PTR [rax+2160]
  012e4	8b 4c 24 70	 mov	 ecx, DWORD PTR n$[rsp]
  012e8	ff c1		 inc	 ecx
  012ea	48 63 c9	 movsxd	 rcx, ecx
  012ed	48 8b 8c c8 00
	06 00 00	 mov	 rcx, QWORD PTR [rax+rcx*8+1536]
  012f5	e8 00 00 00 00	 call	 _byteswap_uint64
  012fa	48 8b 8c 24 50
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  01302	48 8b 89 70 08
	00 00		 mov	 rcx, QWORD PTR [rcx+2160]
  01309	48 8b 89 88 08
	00 00		 mov	 rcx, QWORD PTR [rcx+2184]
  01310	48 63 54 24 70	 movsxd	 rdx, DWORD PTR n$[rsp]
  01315	48 8d 8c d1 00
	01 00 00	 lea	 rcx, QWORD PTR [rcx+rdx*8+256]
  0131d	48 8b d0	 mov	 rdx, rax
  01320	e8 00 00 00 00	 call	 store_dw_noswap
  01325	eb 9d		 jmp	 SHORT $LN43@z900_sie_e
$LN44@z900_sie_e:

; 1653 : 
; 1654 :     /* Update the approprate host registers */
; 1655 :     memcpy( regs->gr,  GUESTREGS->gr,  14 * sizeof( regs->gr [0] ));

  01327	48 8b 84 24 50
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0132f	48 8b 80 70 08
	00 00		 mov	 rax, QWORD PTR [rax+2160]
  01336	48 8b 8c 24 50
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0133e	48 8d b9 80 02
	00 00		 lea	 rdi, QWORD PTR [rcx+640]
  01345	48 8d b0 80 02
	00 00		 lea	 rsi, QWORD PTR [rax+640]
  0134c	b9 70 00 00 00	 mov	 ecx, 112		; 00000070H
  01351	f3 a4		 rep movsb

; 1656 :     memcpy( regs->ar,  GUESTREGS->ar,  16 * sizeof( regs->ar [0] ));

  01353	48 8b 84 24 50
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0135b	48 8b 80 70 08
	00 00		 mov	 rax, QWORD PTR [rax+2160]
  01362	48 8b 8c 24 50
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0136a	48 8d b9 00 03
	00 00		 lea	 rdi, QWORD PTR [rcx+768]
  01371	48 8d b0 00 03
	00 00		 lea	 rsi, QWORD PTR [rax+768]
  01378	b9 40 00 00 00	 mov	 ecx, 64			; 00000040H
  0137d	f3 a4		 rep movsb

; 1657 :     memcpy( regs->fpr, GUESTREGS->fpr, 32 * sizeof( regs->fpr[0] ));

  0137f	48 8b 84 24 50
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  01387	48 8b 80 70 08
	00 00		 mov	 rax, QWORD PTR [rax+2160]
  0138e	48 8b 8c 24 50
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  01396	48 8d b9 40 03
	00 00		 lea	 rdi, QWORD PTR [rcx+832]
  0139d	48 8d b0 40 03
	00 00		 lea	 rsi, QWORD PTR [rax+832]
  013a4	b9 80 00 00 00	 mov	 ecx, 128		; 00000080H
  013a9	f3 a4		 rep movsb

; 1658 : #if defined( FEATURE_BINARY_FLOATING_POINT )
; 1659 :     regs->fpc = GUESTREGS->fpc;

  013ab	48 8b 84 24 50
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  013b3	48 8b 80 70 08
	00 00		 mov	 rax, QWORD PTR [rax+2160]
  013ba	48 8b 8c 24 50
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  013c2	8b 80 c0 03 00
	00		 mov	 eax, DWORD PTR [rax+960]
  013c8	89 81 c0 03 00
	00		 mov	 DWORD PTR [rcx+960], eax
$LN48@z900_sie_e:

; 1660 : #endif
; 1661 : 
; 1662 :     /* Invalidate instruction address accelerator */
; 1663 :     INVALIDATE_AIA(regs);

  013ce	48 8b 84 24 50
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  013d6	48 83 b8 08 02
	00 00 00	 cmp	 QWORD PTR [rax+520], 0
  013de	74 64		 je	 SHORT $LN137@z900_sie_e
  013e0	48 8b 84 24 50
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  013e8	48 8b 8c 24 50
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  013f0	48 8b 89 00 02
	00 00		 mov	 rcx, QWORD PTR [rcx+512]
  013f7	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  013fb	48 2b c1	 sub	 rax, rcx
  013fe	48 8b 8c 24 50
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  01406	48 8b 89 10 02
	00 00		 mov	 rcx, QWORD PTR [rcx+528]
  0140d	48 03 c8	 add	 rcx, rax
  01410	48 8b c1	 mov	 rax, rcx
  01413	48 8b 8c 24 50
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0141b	48 23 81 90 00
	00 00		 and	 rax, QWORD PTR [rcx+144]
  01422	48 8b 8c 24 50
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0142a	48 89 81 88 00
	00 00		 mov	 QWORD PTR [rcx+136], rax
  01431	48 8b 84 24 50
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  01439	48 c7 80 08 02
	00 00 00 00 00
	00		 mov	 QWORD PTR [rax+520], 0
$LN137@z900_sie_e:
  01444	33 c0		 xor	 eax, eax
  01446	85 c0		 test	 eax, eax
  01448	75 84		 jne	 SHORT $LN48@z900_sie_e
$LN51@z900_sie_e:

; 1664 :     SET_AEA_MODE( regs );

  0144a	b8 04 00 00 00	 mov	 eax, 4
  0144f	48 6b c0 04	 imul	 rax, rax, 4
  01453	48 8b 8c 24 50
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0145b	8b 84 01 94 0c
	00 00		 mov	 eax, DWORD PTR [rcx+rax+3220]
  01462	89 84 24 04 01
	00 00		 mov	 DWORD PTR inst_cr$7[rsp], eax
  01469	48 8b 84 24 50
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  01471	0f b6 80 90 0c
	00 00		 movzx	 eax, BYTE PTR [rax+3216]
  01478	88 44 24 60	 mov	 BYTE PTR oldmode$2[rsp], al
  0147c	48 8b 84 24 50
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  01484	0f b6 40 78	 movzx	 eax, BYTE PTR [rax+120]
  01488	83 e0 04	 and	 eax, 4
  0148b	85 c0		 test	 eax, eax
  0148d	75 6c		 jne	 SHORT $LN196@z900_sie_e
  0148f	48 8b 84 24 50
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  01497	8b 80 c8 08 00
	00		 mov	 eax, DWORD PTR [rax+2248]
  0149d	d1 e8		 shr	 eax, 1
  0149f	83 e0 01	 and	 eax, 1
  014a2	85 c0		 test	 eax, eax
  014a4	74 3a		 je	 SHORT $LN194@z900_sie_e
  014a6	48 8b 84 24 50
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  014ae	48 8b 80 88 08
	00 00		 mov	 rax, QWORD PTR [rax+2184]
  014b5	0f b6 40 02	 movzx	 eax, BYTE PTR [rax+2]
  014b9	83 e0 01	 and	 eax, 1
  014bc	85 c0		 test	 eax, eax
  014be	74 20		 je	 SHORT $LN194@z900_sie_e
  014c0	48 8b 84 24 50
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  014c8	0f b6 40 7b	 movzx	 eax, BYTE PTR [rax+123]
  014cc	83 e0 40	 and	 eax, 64			; 00000040H
  014cf	85 c0		 test	 eax, eax
  014d1	74 0d		 je	 SHORT $LN194@z900_sie_e
  014d3	c7 84 24 b4 00
	00 00 02 00 00
	00		 mov	 DWORD PTR tv791[rsp], 2
  014de	eb 0b		 jmp	 SHORT $LN195@z900_sie_e
$LN194@z900_sie_e:
  014e0	c7 84 24 b4 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv791[rsp], 0
$LN195@z900_sie_e:
  014eb	8b 84 24 b4 00
	00 00		 mov	 eax, DWORD PTR tv791[rsp]
  014f2	89 84 24 bc 00
	00 00		 mov	 DWORD PTR tv796[rsp], eax
  014f9	eb 18		 jmp	 SHORT $LN197@z900_sie_e
$LN196@z900_sie_e:
  014fb	48 8b 84 24 50
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  01503	0f b6 40 7b	 movzx	 eax, BYTE PTR [rax+123]
  01507	c1 f8 06	 sar	 eax, 6
  0150a	ff c0		 inc	 eax
  0150c	89 84 24 bc 00
	00 00		 mov	 DWORD PTR tv796[rsp], eax
$LN197@z900_sie_e:
  01513	33 c0		 xor	 eax, eax
  01515	85 c0		 test	 eax, eax
  01517	75 51		 jne	 SHORT $LN198@z900_sie_e
  01519	48 8b 84 24 50
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  01521	0f b6 40 78	 movzx	 eax, BYTE PTR [rax+120]
  01525	83 e0 40	 and	 eax, 64			; 00000040H
  01528	85 c0		 test	 eax, eax
  0152a	75 3e		 jne	 SHORT $LN198@z900_sie_e
  0152c	48 8b 84 24 50
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  01534	8b 80 c8 08 00
	00		 mov	 eax, DWORD PTR [rax+2248]
  0153a	d1 e8		 shr	 eax, 1
  0153c	83 e0 01	 and	 eax, 1
  0153f	85 c0		 test	 eax, eax
  01541	74 1a		 je	 SHORT $LN199@z900_sie_e
  01543	48 8b 84 24 50
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0154b	48 8b 80 88 08
	00 00		 mov	 rax, QWORD PTR [rax+2184]
  01552	0f b6 40 03	 movzx	 eax, BYTE PTR [rax+3]
  01556	83 e0 01	 and	 eax, 1
  01559	85 c0		 test	 eax, eax
  0155b	75 0d		 jne	 SHORT $LN198@z900_sie_e
$LN199@z900_sie_e:
  0155d	c7 84 24 b8 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv811[rsp], 0
  01568	eb 0b		 jmp	 SHORT $LN200@z900_sie_e
$LN198@z900_sie_e:
  0156a	c7 84 24 b8 00
	00 00 40 00 00
	00		 mov	 DWORD PTR tv811[rsp], 64 ; 00000040H
$LN200@z900_sie_e:
  01575	8b 84 24 b8 00
	00 00		 mov	 eax, DWORD PTR tv811[rsp]
  0157c	8b 8c 24 bc 00
	00 00		 mov	 ecx, DWORD PTR tv796[rsp]
  01583	0b c8		 or	 ecx, eax
  01585	8b c1		 mov	 eax, ecx
  01587	48 8b 8c 24 50
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0158f	88 81 90 0c 00
	00		 mov	 BYTE PTR [rcx+3216], al
  01595	48 8b 84 24 50
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0159d	0f b6 80 90 0c
	00 00		 movzx	 eax, BYTE PTR [rax+3216]
  015a4	83 e0 0f	 and	 eax, 15
  015a7	89 84 24 80 00
	00 00		 mov	 DWORD PTR tv817[rsp], eax
  015ae	83 bc 24 80 00
	00 00 01	 cmp	 DWORD PTR tv817[rsp], 1
  015b6	74 2b		 je	 SHORT $LN138@z900_sie_e
  015b8	83 bc 24 80 00
	00 00 02	 cmp	 DWORD PTR tv817[rsp], 2
  015c0	74 5f		 je	 SHORT $LN139@z900_sie_e
  015c2	83 bc 24 80 00
	00 00 03	 cmp	 DWORD PTR tv817[rsp], 3
  015ca	0f 84 14 01 00
	00		 je	 $LN143@z900_sie_e
  015d0	83 bc 24 80 00
	00 00 04	 cmp	 DWORD PTR tv817[rsp], 4
  015d8	0f 84 5d 01 00
	00		 je	 $LN144@z900_sie_e
  015de	e9 93 01 00 00	 jmp	 $LN145@z900_sie_e
$LN138@z900_sie_e:
  015e3	c7 44 24 50 ff
	ff ff ff	 mov	 DWORD PTR i$1[rsp], -1
  015eb	eb 0a		 jmp	 SHORT $LN56@z900_sie_e
$LN54@z900_sie_e:
  015ed	8b 44 24 50	 mov	 eax, DWORD PTR i$1[rsp]
  015f1	ff c0		 inc	 eax
  015f3	89 44 24 50	 mov	 DWORD PTR i$1[rsp], eax
$LN56@z900_sie_e:
  015f7	83 7c 24 50 10	 cmp	 DWORD PTR i$1[rsp], 16
  015fc	7d 1e		 jge	 SHORT $LN55@z900_sie_e
  015fe	8b 44 24 50	 mov	 eax, DWORD PTR i$1[rsp]
  01602	83 c0 05	 add	 eax, 5
  01605	48 98		 cdqe
  01607	48 8b 8c 24 50
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0160f	c7 84 81 94 0c
	00 00 01 00 00
	00		 mov	 DWORD PTR [rcx+rax*4+3220], 1
  0161a	eb d1		 jmp	 SHORT $LN54@z900_sie_e
$LN55@z900_sie_e:
  0161c	e9 8e 01 00 00	 jmp	 $LN52@z900_sie_e
$LN139@z900_sie_e:
  01621	c7 44 24 50 ff
	ff ff ff	 mov	 DWORD PTR i$1[rsp], -1
  01629	eb 0a		 jmp	 SHORT $LN59@z900_sie_e
$LN57@z900_sie_e:
  0162b	8b 44 24 50	 mov	 eax, DWORD PTR i$1[rsp]
  0162f	ff c0		 inc	 eax
  01631	89 44 24 50	 mov	 DWORD PTR i$1[rsp], eax
$LN59@z900_sie_e:
  01635	83 7c 24 50 10	 cmp	 DWORD PTR i$1[rsp], 16
  0163a	7d 1e		 jge	 SHORT $LN58@z900_sie_e
  0163c	8b 44 24 50	 mov	 eax, DWORD PTR i$1[rsp]
  01640	83 c0 05	 add	 eax, 5
  01643	48 98		 cdqe
  01645	48 8b 8c 24 50
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0164d	c7 84 81 94 0c
	00 00 01 00 00
	00		 mov	 DWORD PTR [rcx+rax*4+3220], 1
  01658	eb d1		 jmp	 SHORT $LN57@z900_sie_e
$LN58@z900_sie_e:
  0165a	c7 44 24 50 01
	00 00 00	 mov	 DWORD PTR i$1[rsp], 1
  01662	eb 0a		 jmp	 SHORT $LN62@z900_sie_e
$LN60@z900_sie_e:
  01664	8b 44 24 50	 mov	 eax, DWORD PTR i$1[rsp]
  01668	ff c0		 inc	 eax
  0166a	89 44 24 50	 mov	 DWORD PTR i$1[rsp], eax
$LN62@z900_sie_e:
  0166e	83 7c 24 50 10	 cmp	 DWORD PTR i$1[rsp], 16
  01673	7d 6a		 jge	 SHORT $LN61@z900_sie_e
  01675	48 63 44 24 50	 movsxd	 rax, DWORD PTR i$1[rsp]
  0167a	48 8b 8c 24 50
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  01682	83 bc 81 00 03
	00 00 01	 cmp	 DWORD PTR [rcx+rax*4+768], 1
  0168a	75 1e		 jne	 SHORT $LN140@z900_sie_e
  0168c	8b 44 24 50	 mov	 eax, DWORD PTR i$1[rsp]
  01690	83 c0 05	 add	 eax, 5
  01693	48 98		 cdqe
  01695	48 8b 8c 24 50
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0169d	c7 84 81 94 0c
	00 00 07 00 00
	00		 mov	 DWORD PTR [rcx+rax*4+3220], 7
  016a8	eb 33		 jmp	 SHORT $LN141@z900_sie_e
$LN140@z900_sie_e:
  016aa	48 63 44 24 50	 movsxd	 rax, DWORD PTR i$1[rsp]
  016af	48 8b 8c 24 50
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  016b7	83 bc 81 00 03
	00 00 00	 cmp	 DWORD PTR [rcx+rax*4+768], 0
  016bf	74 1c		 je	 SHORT $LN142@z900_sie_e
  016c1	8b 44 24 50	 mov	 eax, DWORD PTR i$1[rsp]
  016c5	83 c0 05	 add	 eax, 5
  016c8	48 98		 cdqe
  016ca	48 8b 8c 24 50
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  016d2	c7 84 81 94 0c
	00 00 00 00 00
	00		 mov	 DWORD PTR [rcx+rax*4+3220], 0
$LN142@z900_sie_e:
$LN141@z900_sie_e:
  016dd	eb 85		 jmp	 SHORT $LN60@z900_sie_e
$LN61@z900_sie_e:
  016df	e9 cb 00 00 00	 jmp	 $LN52@z900_sie_e
$LN143@z900_sie_e:
  016e4	b8 04 00 00 00	 mov	 eax, 4
  016e9	48 6b c0 04	 imul	 rax, rax, 4
  016ed	48 8b 8c 24 50
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  016f5	c7 84 01 94 0c
	00 00 01 00 00
	00		 mov	 DWORD PTR [rcx+rax+3220], 1
  01700	c7 44 24 50 00
	00 00 00	 mov	 DWORD PTR i$1[rsp], 0
  01708	eb 0a		 jmp	 SHORT $LN65@z900_sie_e
$LN63@z900_sie_e:
  0170a	8b 44 24 50	 mov	 eax, DWORD PTR i$1[rsp]
  0170e	ff c0		 inc	 eax
  01710	89 44 24 50	 mov	 DWORD PTR i$1[rsp], eax
$LN65@z900_sie_e:
  01714	83 7c 24 50 10	 cmp	 DWORD PTR i$1[rsp], 16
  01719	7d 1e		 jge	 SHORT $LN64@z900_sie_e
  0171b	8b 44 24 50	 mov	 eax, DWORD PTR i$1[rsp]
  0171f	83 c0 05	 add	 eax, 5
  01722	48 98		 cdqe
  01724	48 8b 8c 24 50
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0172c	c7 84 81 94 0c
	00 00 07 00 00
	00		 mov	 DWORD PTR [rcx+rax*4+3220], 7
  01737	eb d1		 jmp	 SHORT $LN63@z900_sie_e
$LN64@z900_sie_e:
  01739	eb 74		 jmp	 SHORT $LN52@z900_sie_e
$LN144@z900_sie_e:
  0173b	c7 44 24 50 ff
	ff ff ff	 mov	 DWORD PTR i$1[rsp], -1
  01743	eb 0a		 jmp	 SHORT $LN68@z900_sie_e
$LN66@z900_sie_e:
  01745	8b 44 24 50	 mov	 eax, DWORD PTR i$1[rsp]
  01749	ff c0		 inc	 eax
  0174b	89 44 24 50	 mov	 DWORD PTR i$1[rsp], eax
$LN68@z900_sie_e:
  0174f	83 7c 24 50 10	 cmp	 DWORD PTR i$1[rsp], 16
  01754	7d 1e		 jge	 SHORT $LN67@z900_sie_e
  01756	8b 44 24 50	 mov	 eax, DWORD PTR i$1[rsp]
  0175a	83 c0 05	 add	 eax, 5
  0175d	48 98		 cdqe
  0175f	48 8b 8c 24 50
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  01767	c7 84 81 94 0c
	00 00 0d 00 00
	00		 mov	 DWORD PTR [rcx+rax*4+3220], 13
  01772	eb d1		 jmp	 SHORT $LN66@z900_sie_e
$LN67@z900_sie_e:
  01774	eb 39		 jmp	 SHORT $LN52@z900_sie_e
$LN145@z900_sie_e:
  01776	c7 44 24 50 ff
	ff ff ff	 mov	 DWORD PTR i$1[rsp], -1
  0177e	eb 0a		 jmp	 SHORT $LN71@z900_sie_e
$LN69@z900_sie_e:
  01780	8b 44 24 50	 mov	 eax, DWORD PTR i$1[rsp]
  01784	ff c0		 inc	 eax
  01786	89 44 24 50	 mov	 DWORD PTR i$1[rsp], eax
$LN71@z900_sie_e:
  0178a	83 7c 24 50 10	 cmp	 DWORD PTR i$1[rsp], 16
  0178f	7d 1e		 jge	 SHORT $LN70@z900_sie_e
  01791	8b 44 24 50	 mov	 eax, DWORD PTR i$1[rsp]
  01795	83 c0 05	 add	 eax, 5
  01798	48 98		 cdqe
  0179a	48 8b 8c 24 50
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  017a2	c7 84 81 94 0c
	00 00 ff ff ff
	ff		 mov	 DWORD PTR [rcx+rax*4+3220], -1
  017ad	eb d1		 jmp	 SHORT $LN69@z900_sie_e
$LN70@z900_sie_e:
$LN52@z900_sie_e:
  017af	b8 04 00 00 00	 mov	 eax, 4
  017b4	48 6b c0 04	 imul	 rax, rax, 4
  017b8	48 8b 8c 24 50
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  017c0	8b 84 01 94 0c
	00 00		 mov	 eax, DWORD PTR [rcx+rax+3220]
  017c7	39 84 24 04 01
	00 00		 cmp	 DWORD PTR inst_cr$7[rsp], eax
  017ce	74 7c		 je	 SHORT $LN146@z900_sie_e
$LN74@z900_sie_e:
  017d0	48 8b 84 24 50
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  017d8	48 83 b8 08 02
	00 00 00	 cmp	 QWORD PTR [rax+520], 0
  017e0	74 64		 je	 SHORT $LN147@z900_sie_e
  017e2	48 8b 84 24 50
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  017ea	48 8b 8c 24 50
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  017f2	48 8b 89 00 02
	00 00		 mov	 rcx, QWORD PTR [rcx+512]
  017f9	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  017fd	48 2b c1	 sub	 rax, rcx
  01800	48 8b 8c 24 50
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  01808	48 8b 89 10 02
	00 00		 mov	 rcx, QWORD PTR [rcx+528]
  0180f	48 03 c8	 add	 rcx, rax
  01812	48 8b c1	 mov	 rax, rcx
  01815	48 8b 8c 24 50
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0181d	48 23 81 90 00
	00 00		 and	 rax, QWORD PTR [rcx+144]
  01824	48 8b 8c 24 50
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0182c	48 89 81 88 00
	00 00		 mov	 QWORD PTR [rcx+136], rax
  01833	48 8b 84 24 50
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0183b	48 c7 80 08 02
	00 00 00 00 00
	00		 mov	 QWORD PTR [rax+520], 0
$LN147@z900_sie_e:
  01846	33 c0		 xor	 eax, eax
  01848	85 c0		 test	 eax, eax
  0184a	75 84		 jne	 SHORT $LN74@z900_sie_e
$LN146@z900_sie_e:
  0184c	0f b6 44 24 60	 movzx	 eax, BYTE PTR oldmode$2[rsp]
  01851	83 e0 40	 and	 eax, 64			; 00000040H
  01854	85 c0		 test	 eax, eax
  01856	0f 85 f3 00 00
	00		 jne	 $LN148@z900_sie_e
  0185c	48 8b 84 24 50
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  01864	0f b6 80 90 0c
	00 00		 movzx	 eax, BYTE PTR [rax+3216]
  0186b	83 e0 40	 and	 eax, 64			; 00000040H
  0186e	85 c0		 test	 eax, eax
  01870	0f 84 d9 00 00
	00		 je	 $LN148@z900_sie_e
$LN77@z900_sie_e:
  01876	48 8b 84 24 50
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0187e	48 83 b8 08 02
	00 00 00	 cmp	 QWORD PTR [rax+520], 0
  01886	74 64		 je	 SHORT $LN149@z900_sie_e
  01888	48 8b 84 24 50
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  01890	48 8b 8c 24 50
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  01898	48 8b 89 00 02
	00 00		 mov	 rcx, QWORD PTR [rcx+512]
  0189f	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  018a3	48 2b c1	 sub	 rax, rcx
  018a6	48 8b 8c 24 50
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  018ae	48 8b 89 10 02
	00 00		 mov	 rcx, QWORD PTR [rcx+528]
  018b5	48 03 c8	 add	 rcx, rax
  018b8	48 8b c1	 mov	 rax, rcx
  018bb	48 8b 8c 24 50
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  018c3	48 23 81 90 00
	00 00		 and	 rax, QWORD PTR [rcx+144]
  018ca	48 8b 8c 24 50
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  018d2	48 89 81 88 00
	00 00		 mov	 QWORD PTR [rcx+136], rax
  018d9	48 8b 84 24 50
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  018e1	48 c7 80 08 02
	00 00 00 00 00
	00		 mov	 QWORD PTR [rax+520], 0
$LN149@z900_sie_e:
  018ec	33 c0		 xor	 eax, eax
  018ee	85 c0		 test	 eax, eax
  018f0	75 84		 jne	 SHORT $LN77@z900_sie_e
  018f2	48 8b 84 24 50
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  018fa	8b 80 28 07 00
	00		 mov	 eax, DWORD PTR [rax+1832]
  01900	c1 e8 02	 shr	 eax, 2
  01903	83 e0 01	 and	 eax, 1
  01906	85 c0		 test	 eax, eax
  01908	74 0d		 je	 SHORT $LN203@z900_sie_e
  0190a	c7 84 24 c0 00
	00 00 01 00 00
	00		 mov	 DWORD PTR tv927[rsp], 1
  01915	eb 0b		 jmp	 SHORT $LN204@z900_sie_e
$LN203@z900_sie_e:
  01917	c7 84 24 c0 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv927[rsp], 0
$LN204@z900_sie_e:
  01922	83 bc 24 c0 00
	00 00 00	 cmp	 DWORD PTR tv927[rsp], 0
  0192a	74 23		 je	 SHORT $LN150@z900_sie_e
  0192c	48 8b 84 24 50
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  01934	8b 40 48	 mov	 eax, DWORD PTR [rax+72]
  01937	25 00 00 20 00	 and	 eax, 2097152		; 00200000H
  0193c	85 c0		 test	 eax, eax
  0193e	74 0f		 je	 SHORT $LN150@z900_sie_e
  01940	b2 fc		 mov	 dl, 252			; 000000fcH
  01942	48 8b 8c 24 50
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0194a	e8 00 00 00 00	 call	 z900_invalidate_tlb
$LN150@z900_sie_e:
$LN148@z900_sie_e:
  0194f	33 c0		 xor	 eax, eax
  01951	85 c0		 test	 eax, eax
  01953	0f 85 f1 fa ff
	ff		 jne	 $LN51@z900_sie_e

; 1665 : 
; 1666 :     /* Zeroize the interruption parameters */
; 1667 :     memset( STATEBK->ipa, 0, 10 );

  01959	48 8b 84 24 50
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  01961	48 8b 80 70 08
	00 00		 mov	 rax, QWORD PTR [rax+2160]
  01968	48 8b 80 88 08
	00 00		 mov	 rax, QWORD PTR [rax+2184]
  0196f	48 83 c0 56	 add	 rax, 86			; 00000056H
  01973	48 8b f8	 mov	 rdi, rax
  01976	33 c0		 xor	 eax, eax
  01978	b9 0a 00 00 00	 mov	 ecx, 10
  0197d	f3 aa		 rep stosb

; 1668 : 
; 1669 :     /* If format-2 interception, we have more work to do */
; 1670 :     if (0
; 1671 :         || STATEBK->c == SIE_C_INST
; 1672 :         || STATEBK->c == SIE_C_BOTH
; 1673 :         || STATEBK->c == SIE_C_OPEREXC
; 1674 :         || STATEBK->c == SIE_C_IOINST

  0197f	33 c0		 xor	 eax, eax
  01981	85 c0		 test	 eax, eax
  01983	0f 85 80 00 00
	00		 jne	 $LN152@z900_sie_e
  01989	48 8b 84 24 50
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  01991	48 8b 80 70 08
	00 00		 mov	 rax, QWORD PTR [rax+2160]
  01998	48 8b 80 88 08
	00 00		 mov	 rax, QWORD PTR [rax+2184]
  0199f	0f b6 40 50	 movzx	 eax, BYTE PTR [rax+80]
  019a3	83 f8 04	 cmp	 eax, 4
  019a6	74 61		 je	 SHORT $LN152@z900_sie_e
  019a8	48 8b 84 24 50
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  019b0	48 8b 80 70 08
	00 00		 mov	 rax, QWORD PTR [rax+2160]
  019b7	48 8b 80 88 08
	00 00		 mov	 rax, QWORD PTR [rax+2184]
  019be	0f b6 40 50	 movzx	 eax, BYTE PTR [rax+80]
  019c2	83 f8 0c	 cmp	 eax, 12
  019c5	74 42		 je	 SHORT $LN152@z900_sie_e
  019c7	48 8b 84 24 50
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  019cf	48 8b 80 70 08
	00 00		 mov	 rax, QWORD PTR [rax+2160]
  019d6	48 8b 80 88 08
	00 00		 mov	 rax, QWORD PTR [rax+2184]
  019dd	0f b6 40 50	 movzx	 eax, BYTE PTR [rax+80]
  019e1	83 f8 2c	 cmp	 eax, 44			; 0000002cH
  019e4	74 23		 je	 SHORT $LN152@z900_sie_e
  019e6	48 8b 84 24 50
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  019ee	48 8b 80 70 08
	00 00		 mov	 rax, QWORD PTR [rax+2160]
  019f5	48 8b 80 88 08
	00 00		 mov	 rax, QWORD PTR [rax+2184]
  019fc	0f b6 40 50	 movzx	 eax, BYTE PTR [rax+80]
  01a00	83 f8 40	 cmp	 eax, 64			; 00000040H
  01a03	0f 85 2d 07 00
	00		 jne	 $LN151@z900_sie_e
$LN152@z900_sie_e:

; 1675 :     )
; 1676 :     {
; 1677 :         /* Indicate interception format 2 */
; 1678 :         STATEBK->f |= SIE_F_IN;

  01a09	48 8b 84 24 50
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  01a11	48 8b 80 70 08
	00 00		 mov	 rax, QWORD PTR [rax+2160]
  01a18	48 8b 80 88 08
	00 00		 mov	 rax, QWORD PTR [rax+2184]
  01a1f	0f b6 40 51	 movzx	 eax, BYTE PTR [rax+81]
  01a23	0f ba e8 07	 bts	 eax, 7
  01a27	48 8b 8c 24 50
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  01a2f	48 8b 89 70 08
	00 00		 mov	 rcx, QWORD PTR [rcx+2160]
  01a36	48 8b 89 88 08
	00 00		 mov	 rcx, QWORD PTR [rcx+2184]
  01a3d	88 41 51	 mov	 BYTE PTR [rcx+81], al

; 1679 : 
; 1680 : #if defined( _FEATURE_PER )
; 1681 :         /* Handle PER or concurrent PER event */
; 1682 :         if (1
; 1683 :             && OPEN_IC_PER( GUESTREGS )
; 1684 :             && ECMODE( &GUESTREGS->psw )
; 1685 :             && (GUESTREGS->psw.sysmask & PSW_PERMODE)

  01a40	33 c0		 xor	 eax, eax
  01a42	83 f8 01	 cmp	 eax, 1
  01a45	0f 84 f7 01 00
	00		 je	 $LN153@z900_sie_e
  01a4b	48 8b 84 24 50
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  01a53	48 8b 80 70 08
	00 00		 mov	 rax, QWORD PTR [rax+2160]
  01a5a	48 8b 8c 24 50
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  01a62	48 8b 89 70 08
	00 00		 mov	 rcx, QWORD PTR [rcx+2160]
  01a69	8b 49 4c	 mov	 ecx, DWORD PTR [rcx+76]
  01a6c	8b 40 48	 mov	 eax, DWORD PTR [rax+72]
  01a6f	23 c1		 and	 eax, ecx
  01a71	25 00 00 ff 00	 and	 eax, 16711680		; 00ff0000H
  01a76	85 c0		 test	 eax, eax
  01a78	0f 84 c4 01 00
	00		 je	 $LN153@z900_sie_e
  01a7e	48 8b 84 24 50
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  01a86	48 8b 80 70 08
	00 00		 mov	 rax, QWORD PTR [rax+2160]
  01a8d	0f b6 40 7a	 movzx	 eax, BYTE PTR [rax+122]
  01a91	83 e0 08	 and	 eax, 8
  01a94	85 c0		 test	 eax, eax
  01a96	0f 84 a6 01 00
	00		 je	 $LN153@z900_sie_e
  01a9c	48 8b 84 24 50
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  01aa4	48 8b 80 70 08
	00 00		 mov	 rax, QWORD PTR [rax+2160]
  01aab	0f b6 40 78	 movzx	 eax, BYTE PTR [rax+120]
  01aaf	83 e0 40	 and	 eax, 64			; 00000040H
  01ab2	85 c0		 test	 eax, eax
  01ab4	0f 84 88 01 00
	00		 je	 $LN153@z900_sie_e

; 1686 :         )
; 1687 :         {
; 1688 :             PSA* psa;
; 1689 : 
; 1690 : #if defined( _FEATURE_PER2 )
; 1691 : 
; 1692 :             GUESTREGS->perc |= OPEN_IC_PER( GUESTREGS ) >> ((32 - IC_CR9_SHIFT) - 16);

  01aba	48 8b 84 24 50
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  01ac2	48 8b 80 70 08
	00 00		 mov	 rax, QWORD PTR [rax+2160]
  01ac9	48 8b 8c 24 50
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  01ad1	48 8b 89 70 08
	00 00		 mov	 rcx, QWORD PTR [rcx+2160]
  01ad8	48 8b 94 24 50
	01 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  01ae0	48 8b 92 70 08
	00 00		 mov	 rdx, QWORD PTR [rdx+2160]
  01ae7	8b 52 4c	 mov	 edx, DWORD PTR [rdx+76]
  01aea	8b 49 48	 mov	 ecx, DWORD PTR [rcx+72]
  01aed	23 ca		 and	 ecx, edx
  01aef	81 e1 00 00 ff
	00		 and	 ecx, 16711680		; 00ff0000H
  01af5	c1 e9 08	 shr	 ecx, 8
  01af8	0f b7 80 d0 08
	00 00		 movzx	 eax, WORD PTR [rax+2256]
  01aff	0b c1		 or	 eax, ecx
  01b01	48 8b 8c 24 50
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  01b09	48 8b 89 70 08
	00 00		 mov	 rcx, QWORD PTR [rcx+2160]
  01b10	66 89 81 d0 08
	00 00		 mov	 WORD PTR [rcx+2256], ax

; 1693 : 
; 1694 :             /* Positions 14 and 15 contain zeros
; 1695 :                if a storage alteration event was NOT indicated
; 1696 :             */
; 1697 :             if (0
; 1698 :                 || !(OPEN_IC_PER_SA( GUESTREGS ))
; 1699 :                 ||  (OPEN_IC_PER_STURA( GUESTREGS ))

  01b17	33 c0		 xor	 eax, eax
  01b19	85 c0		 test	 eax, eax
  01b1b	75 5e		 jne	 SHORT $LN155@z900_sie_e
  01b1d	48 8b 84 24 50
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  01b25	48 8b 80 70 08
	00 00		 mov	 rax, QWORD PTR [rax+2160]
  01b2c	48 8b 8c 24 50
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  01b34	48 8b 89 70 08
	00 00		 mov	 rcx, QWORD PTR [rcx+2160]
  01b3b	8b 49 4c	 mov	 ecx, DWORD PTR [rcx+76]
  01b3e	8b 40 48	 mov	 eax, DWORD PTR [rax+72]
  01b41	23 c1		 and	 eax, ecx
  01b43	25 00 00 20 00	 and	 eax, 2097152		; 00200000H
  01b48	85 c0		 test	 eax, eax
  01b4a	74 2f		 je	 SHORT $LN155@z900_sie_e
  01b4c	48 8b 84 24 50
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  01b54	48 8b 80 70 08
	00 00		 mov	 rax, QWORD PTR [rax+2160]
  01b5b	48 8b 8c 24 50
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  01b63	48 8b 89 70 08
	00 00		 mov	 rcx, QWORD PTR [rcx+2160]
  01b6a	8b 49 4c	 mov	 ecx, DWORD PTR [rcx+76]
  01b6d	8b 40 48	 mov	 eax, DWORD PTR [rax+72]
  01b70	23 c1		 and	 eax, ecx
  01b72	25 00 00 08 00	 and	 eax, 524288		; 00080000H
  01b77	85 c0		 test	 eax, eax
  01b79	74 31		 je	 SHORT $LN154@z900_sie_e
$LN155@z900_sie_e:

; 1700 :             )
; 1701 :                 GUESTREGS->perc &= 0xFFFC;

  01b7b	48 8b 84 24 50
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  01b83	48 8b 80 70 08
	00 00		 mov	 rax, QWORD PTR [rax+2160]
  01b8a	0f b7 80 d0 08
	00 00		 movzx	 eax, WORD PTR [rax+2256]
  01b91	25 fc ff 00 00	 and	 eax, 65532		; 0000fffcH
  01b96	48 8b 8c 24 50
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  01b9e	48 8b 89 70 08
	00 00		 mov	 rcx, QWORD PTR [rcx+2160]
  01ba5	66 89 81 d0 08
	00 00		 mov	 WORD PTR [rcx+2256], ax
$LN154@z900_sie_e:

; 1702 : 
; 1703 : #endif /* defined( _FEATURE_PER2 ) */
; 1704 : 
; 1705 :             /* Point to PSA fields in state descriptor */
; 1706 :             psa = (void*)(regs->mainstor + SIE_STATE(GUESTREGS) + SIE_IP_PSA_OFFSET);

  01bac	48 8b 84 24 50
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  01bb4	48 8b 80 70 08
	00 00		 mov	 rax, QWORD PTR [rax+2160]
  01bbb	48 8b 8c 24 50
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  01bc3	48 8b 89 48 08
	00 00		 mov	 rcx, QWORD PTR [rcx+2120]
  01bca	48 8b 80 80 08
	00 00		 mov	 rax, QWORD PTR [rax+2176]
  01bd1	48 8d 44 01 40	 lea	 rax, QWORD PTR [rcx+rax+64]
  01bd6	48 89 84 24 10
	01 00 00	 mov	 QWORD PTR psa$8[rsp], rax

; 1707 :             STORE_HW( psa->perint, GUESTREGS->perc   );

  01bde	48 8b 84 24 50
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  01be6	48 8b 80 70 08
	00 00		 mov	 rax, QWORD PTR [rax+2160]
  01bed	0f b7 88 d0 08
	00 00		 movzx	 ecx, WORD PTR [rax+2256]
  01bf4	e8 00 00 00 00	 call	 _byteswap_ushort
  01bf9	48 8b 8c 24 10
	01 00 00	 mov	 rcx, QWORD PTR psa$8[rsp]
  01c01	48 81 c1 96 00
	00 00		 add	 rcx, 150		; 00000096H
  01c08	0f b7 d0	 movzx	 edx, ax
  01c0b	e8 00 00 00 00	 call	 store_hw_noswap

; 1708 :             STORE_W(  psa->peradr, GUESTREGS->peradr );

  01c10	48 8b 84 24 50
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  01c18	48 8b 80 70 08
	00 00		 mov	 rax, QWORD PTR [rax+2160]
  01c1f	48 8b 88 d8 08
	00 00		 mov	 rcx, QWORD PTR [rax+2264]
  01c26	e8 00 00 00 00	 call	 _byteswap_uint64
  01c2b	48 8b 8c 24 10
	01 00 00	 mov	 rcx, QWORD PTR psa$8[rsp]
  01c33	48 81 c1 98 00
	00 00		 add	 rcx, 152		; 00000098H
  01c3a	48 8b d0	 mov	 rdx, rax
  01c3d	e8 00 00 00 00	 call	 store_dw_noswap
$LN153@z900_sie_e:

; 1709 :         }
; 1710 : 
; 1711 :         if (IS_IC_PER_IF( GUESTREGS ))

  01c42	48 8b 84 24 50
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  01c4a	48 8b 80 70 08
	00 00		 mov	 rax, QWORD PTR [rax+2160]
  01c51	8b 40 4c	 mov	 eax, DWORD PTR [rax+76]
  01c54	25 00 00 40 00	 and	 eax, 4194304		; 00400000H
  01c59	85 c0		 test	 eax, eax
  01c5b	74 36		 je	 SHORT $LN156@z900_sie_e

; 1712 :             STATEBK->f |= SIE_F_IF;

  01c5d	48 8b 84 24 50
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  01c65	48 8b 80 70 08
	00 00		 mov	 rax, QWORD PTR [rax+2160]
  01c6c	48 8b 80 88 08
	00 00		 mov	 rax, QWORD PTR [rax+2184]
  01c73	0f b6 40 51	 movzx	 eax, BYTE PTR [rax+81]
  01c77	83 c8 02	 or	 eax, 2
  01c7a	48 8b 8c 24 50
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  01c82	48 8b 89 70 08
	00 00		 mov	 rcx, QWORD PTR [rcx+2160]
  01c89	48 8b 89 88 08
	00 00		 mov	 rcx, QWORD PTR [rcx+2184]
  01c90	88 41 51	 mov	 BYTE PTR [rcx+81], al
$LN156@z900_sie_e:
$LN80@z900_sie_e:

; 1713 : 
; 1714 :         /* Reset any pending PER indication */
; 1715 :         OFF_IC_PER( GUESTREGS );

  01c93	48 8b 84 24 50
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  01c9b	48 8b 80 70 08
	00 00		 mov	 rax, QWORD PTR [rax+2160]
  01ca2	8b 40 4c	 mov	 eax, DWORD PTR [rax+76]
  01ca5	25 ff ff 00 ff	 and	 eax, -16711681		; ff00ffffH
  01caa	48 8b 8c 24 50
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  01cb2	48 8b 89 70 08
	00 00		 mov	 rcx, QWORD PTR [rcx+2160]
  01cb9	89 41 4c	 mov	 DWORD PTR [rcx+76], eax
  01cbc	33 c0		 xor	 eax, eax
  01cbe	85 c0		 test	 eax, eax
  01cc0	75 d1		 jne	 SHORT $LN80@z900_sie_e

; 1716 : 
; 1717 : #endif /* defined( _FEATURE_PER ) */
; 1718 : 
; 1719 :         /* Backup to the previous instruction */
; 1720 :         GUESTREGS->ip -= REAL_ILC( GUESTREGS );

  01cc2	48 8b 84 24 50
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  01cca	48 8b 80 70 08
	00 00		 mov	 rax, QWORD PTR [rax+2160]
  01cd1	8b 80 28 07 00
	00		 mov	 eax, DWORD PTR [rax+1832]
  01cd7	83 e0 01	 and	 eax, 1
  01cda	85 c0		 test	 eax, eax
  01cdc	75 0d		 jne	 SHORT $LN205@z900_sie_e
  01cde	c7 84 24 c4 00
	00 00 01 00 00
	00		 mov	 DWORD PTR tv1070[rsp], 1
  01ce9	eb 0b		 jmp	 SHORT $LN206@z900_sie_e
$LN205@z900_sie_e:
  01ceb	c7 84 24 c4 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv1070[rsp], 0
$LN206@z900_sie_e:
  01cf6	83 bc 24 c4 00
	00 00 00	 cmp	 DWORD PTR tv1070[rsp], 0
  01cfe	74 0d		 je	 SHORT $LN209@z900_sie_e
  01d00	c7 84 24 c8 00
	00 00 01 00 00
	00		 mov	 DWORD PTR tv1078[rsp], 1
  01d0b	eb 0b		 jmp	 SHORT $LN210@z900_sie_e
$LN209@z900_sie_e:
  01d0d	c7 84 24 c8 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv1078[rsp], 0
$LN210@z900_sie_e:
  01d18	83 bc 24 c8 00
	00 00 00	 cmp	 DWORD PTR tv1078[rsp], 0
  01d20	74 1f		 je	 SHORT $LN213@z900_sie_e
  01d22	48 8b 84 24 50
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  01d2a	48 8b 80 70 08
	00 00		 mov	 rax, QWORD PTR [rax+2160]
  01d31	0f b6 80 9a 00
	00 00		 movzx	 eax, BYTE PTR [rax+154]
  01d38	89 84 24 d0 00
	00 00		 mov	 DWORD PTR tv1089[rsp], eax
  01d3f	eb 44		 jmp	 SHORT $LN214@z900_sie_e
$LN213@z900_sie_e:
  01d41	48 8b 84 24 50
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  01d49	48 8b 80 70 08
	00 00		 mov	 rax, QWORD PTR [rax+2160]
  01d50	8b 80 28 07 00
	00		 mov	 eax, DWORD PTR [rax+1832]
  01d56	d1 e8		 shr	 eax, 1
  01d58	83 e0 01	 and	 eax, 1
  01d5b	85 c0		 test	 eax, eax
  01d5d	74 0d		 je	 SHORT $LN211@z900_sie_e
  01d5f	c7 84 24 cc 00
	00 00 06 00 00
	00		 mov	 DWORD PTR tv1087[rsp], 6
  01d6a	eb 0b		 jmp	 SHORT $LN212@z900_sie_e
$LN211@z900_sie_e:
  01d6c	c7 84 24 cc 00
	00 00 04 00 00
	00		 mov	 DWORD PTR tv1087[rsp], 4
$LN212@z900_sie_e:
  01d77	8b 84 24 cc 00
	00 00		 mov	 eax, DWORD PTR tv1087[rsp]
  01d7e	89 84 24 d0 00
	00 00		 mov	 DWORD PTR tv1089[rsp], eax
$LN214@z900_sie_e:
  01d85	48 8b 84 24 50
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  01d8d	48 8b 80 70 08
	00 00		 mov	 rax, QWORD PTR [rax+2160]
  01d94	48 63 8c 24 d0
	00 00 00	 movsxd	 rcx, DWORD PTR tv1089[rsp]
  01d9c	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  01da0	48 2b c1	 sub	 rax, rcx
  01da3	48 8b 8c 24 50
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  01dab	48 8b 89 70 08
	00 00		 mov	 rcx, QWORD PTR [rcx+2160]
  01db2	48 89 41 68	 mov	 QWORD PTR [rcx+104], rax

; 1721 :         if (GUESTREGS->ip < GUESTREGS->aip)

  01db6	48 8b 84 24 50
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  01dbe	48 8b 80 70 08
	00 00		 mov	 rax, QWORD PTR [rax+2160]
  01dc5	48 8b 8c 24 50
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  01dcd	48 8b 89 70 08
	00 00		 mov	 rcx, QWORD PTR [rcx+2160]
  01dd4	48 8b 89 00 02
	00 00		 mov	 rcx, QWORD PTR [rcx+512]
  01ddb	48 39 48 68	 cmp	 QWORD PTR [rax+104], rcx
  01ddf	73 28		 jae	 SHORT $LN157@z900_sie_e

; 1722 :             GUESTREGS->ip = GUESTREGS->inst;

  01de1	48 8b 84 24 50
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  01de9	48 8b 80 70 08
	00 00		 mov	 rax, QWORD PTR [rax+2160]
  01df0	48 05 f1 08 00
	00		 add	 rax, 2289		; 000008f1H
  01df6	48 8b 8c 24 50
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  01dfe	48 8b 89 70 08
	00 00		 mov	 rcx, QWORD PTR [rcx+2160]
  01e05	48 89 41 68	 mov	 QWORD PTR [rcx+104], rax
$LN157@z900_sie_e:

; 1723 : 
; 1724 : #if defined( FEATURE_035_EXECUTE_EXTN_FACILITY )
; 1725 :         if (FACILITY_ENABLED( 035_EXECUTE_EXTN, GUESTREGS ))

  01e09	48 8b 84 24 50
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  01e11	48 8b 80 70 08
	00 00		 mov	 rax, QWORD PTR [rax+2160]
  01e18	b9 01 00 00 00	 mov	 ecx, 1
  01e1d	48 6b c9 04	 imul	 rcx, rcx, 4
  01e21	0f b6 84 08 28
	0d 00 00	 movzx	 eax, BYTE PTR [rax+rcx+3368]
  01e29	83 e0 10	 and	 eax, 16
  01e2c	85 c0		 test	 eax, eax
  01e2e	0f 84 9b 00 00
	00		 je	 $LN158@z900_sie_e

; 1726 :         {
; 1727 :             /* EXRL = Execute Relative Long instruction? */
; 1728 :             is_exrl =

  01e34	33 c0		 xor	 eax, eax
  01e36	83 f8 01	 cmp	 eax, 1
  01e39	74 5b		 je	 SHORT $LN215@z900_sie_e
  01e3b	48 8b 84 24 50
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  01e43	48 8b 80 70 08
	00 00		 mov	 rax, QWORD PTR [rax+2160]
  01e4a	b9 01 00 00 00	 mov	 ecx, 1
  01e4f	48 6b c9 00	 imul	 rcx, rcx, 0
  01e53	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  01e57	0f b6 04 08	 movzx	 eax, BYTE PTR [rax+rcx]
  01e5b	3d c6 00 00 00	 cmp	 eax, 198		; 000000c6H
  01e60	75 34		 jne	 SHORT $LN215@z900_sie_e
  01e62	48 8b 84 24 50
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  01e6a	48 8b 80 70 08
	00 00		 mov	 rax, QWORD PTR [rax+2160]
  01e71	b9 01 00 00 00	 mov	 ecx, 1
  01e76	48 6b c9 01	 imul	 rcx, rcx, 1
  01e7a	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  01e7e	0f b6 04 08	 movzx	 eax, BYTE PTR [rax+rcx]
  01e82	83 e0 0f	 and	 eax, 15
  01e85	85 c0		 test	 eax, eax
  01e87	75 0d		 jne	 SHORT $LN215@z900_sie_e
  01e89	c7 84 24 d4 00
	00 00 01 00 00
	00		 mov	 DWORD PTR tv1124[rsp], 1
  01e94	eb 0b		 jmp	 SHORT $LN216@z900_sie_e
$LN215@z900_sie_e:
  01e96	c7 84 24 d4 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv1124[rsp], 0
$LN216@z900_sie_e:
  01ea1	83 bc 24 d4 00
	00 00 00	 cmp	 DWORD PTR tv1124[rsp], 0
  01ea9	75 0d		 jne	 SHORT $LN217@z900_sie_e
  01eab	c7 84 24 d8 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv1126[rsp], 0
  01eb6	eb 0b		 jmp	 SHORT $LN218@z900_sie_e
$LN217@z900_sie_e:
  01eb8	c7 84 24 d8 00
	00 00 01 00 00
	00		 mov	 DWORD PTR tv1126[rsp], 1
$LN218@z900_sie_e:
  01ec3	0f b6 84 24 d8
	00 00 00	 movzx	 eax, BYTE PTR tv1126[rsp]
  01ecb	88 44 24 54	 mov	 BYTE PTR is_exrl$[rsp], al
$LN158@z900_sie_e:

; 1729 :             (1
; 1730 :                 &&   GUESTREGS->ip[0] == 0xc6
; 1731 :                 && !(GUESTREGS->ip[1] &  0x0f)
; 1732 :             );
; 1733 :         }
; 1734 : #endif
; 1735 :         /* Update interception parameters in the state descriptor */
; 1736 :         if (GUESTREGS->ip[0] == 0x44 || is_exrl)

  01ecf	48 8b 84 24 50
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  01ed7	48 8b 80 70 08
	00 00		 mov	 rax, QWORD PTR [rax+2160]
  01ede	b9 01 00 00 00	 mov	 ecx, 1
  01ee3	48 6b c9 00	 imul	 rcx, rcx, 0
  01ee7	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  01eeb	0f b6 04 08	 movzx	 eax, BYTE PTR [rax+rcx]
  01eef	83 f8 44	 cmp	 eax, 68			; 00000044H
  01ef2	74 0d		 je	 SHORT $LN161@z900_sie_e
  01ef4	0f b6 44 24 54	 movzx	 eax, BYTE PTR is_exrl$[rsp]
  01ef9	85 c0		 test	 eax, eax
  01efb	0f 84 56 01 00
	00		 je	 $LN159@z900_sie_e
$LN161@z900_sie_e:

; 1737 :         {
; 1738 :             int ilc;
; 1739 :             STATEBK->f |= SIE_F_EX;

  01f01	48 8b 84 24 50
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  01f09	48 8b 80 70 08
	00 00		 mov	 rax, QWORD PTR [rax+2160]
  01f10	48 8b 80 88 08
	00 00		 mov	 rax, QWORD PTR [rax+2184]
  01f17	0f b6 40 51	 movzx	 eax, BYTE PTR [rax+81]
  01f1b	83 c8 01	 or	 eax, 1
  01f1e	48 8b 8c 24 50
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  01f26	48 8b 89 70 08
	00 00		 mov	 rcx, QWORD PTR [rcx+2160]
  01f2d	48 8b 89 88 08
	00 00		 mov	 rcx, QWORD PTR [rcx+2184]
  01f34	88 41 51	 mov	 BYTE PTR [rcx+81], al

; 1740 :             ilc = ILC( GUESTREGS->exinst[0] );

  01f37	48 8b 84 24 50
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  01f3f	48 8b 80 70 08
	00 00		 mov	 rax, QWORD PTR [rax+2160]
  01f46	b9 01 00 00 00	 mov	 ecx, 1
  01f4b	48 6b c9 00	 imul	 rcx, rcx, 0
  01f4f	0f b6 84 08 40
	08 00 00	 movzx	 eax, BYTE PTR [rax+rcx+2112]
  01f57	83 f8 40	 cmp	 eax, 64			; 00000040H
  01f5a	7d 0d		 jge	 SHORT $LN221@z900_sie_e
  01f5c	c7 84 24 e0 00
	00 00 02 00 00
	00		 mov	 DWORD PTR tv1158[rsp], 2
  01f67	eb 4d		 jmp	 SHORT $LN222@z900_sie_e
$LN221@z900_sie_e:
  01f69	48 8b 84 24 50
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  01f71	48 8b 80 70 08
	00 00		 mov	 rax, QWORD PTR [rax+2160]
  01f78	b9 01 00 00 00	 mov	 ecx, 1
  01f7d	48 6b c9 00	 imul	 rcx, rcx, 0
  01f81	0f b6 84 08 40
	08 00 00	 movzx	 eax, BYTE PTR [rax+rcx+2112]
  01f89	3d c0 00 00 00	 cmp	 eax, 192		; 000000c0H
  01f8e	7d 0d		 jge	 SHORT $LN219@z900_sie_e
  01f90	c7 84 24 dc 00
	00 00 04 00 00
	00		 mov	 DWORD PTR tv1157[rsp], 4
  01f9b	eb 0b		 jmp	 SHORT $LN220@z900_sie_e
$LN219@z900_sie_e:
  01f9d	c7 84 24 dc 00
	00 00 06 00 00
	00		 mov	 DWORD PTR tv1157[rsp], 6
$LN220@z900_sie_e:
  01fa8	8b 84 24 dc 00
	00 00		 mov	 eax, DWORD PTR tv1157[rsp]
  01faf	89 84 24 e0 00
	00 00		 mov	 DWORD PTR tv1158[rsp], eax
$LN222@z900_sie_e:
  01fb6	8b 84 24 e0 00
	00 00		 mov	 eax, DWORD PTR tv1158[rsp]
  01fbd	89 84 24 e4 00
	00 00		 mov	 DWORD PTR ilc$6[rsp], eax

; 1741 : #if defined( FEATURE_035_EXECUTE_EXTN_FACILITY )
; 1742 :             if (is_exrl)

  01fc4	0f b6 44 24 54	 movzx	 eax, BYTE PTR is_exrl$[rsp]
  01fc9	85 c0		 test	 eax, eax
  01fcb	74 42		 je	 SHORT $LN162@z900_sie_e

; 1743 :                 STATEBK->f |= (ilc << 4) & SIE_F_EXL;

  01fcd	48 8b 84 24 50
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  01fd5	48 8b 80 70 08
	00 00		 mov	 rax, QWORD PTR [rax+2160]
  01fdc	48 8b 80 88 08
	00 00		 mov	 rax, QWORD PTR [rax+2184]
  01fe3	8b 8c 24 e4 00
	00 00		 mov	 ecx, DWORD PTR ilc$6[rsp]
  01fea	c1 e1 04	 shl	 ecx, 4
  01fed	83 e1 60	 and	 ecx, 96			; 00000060H
  01ff0	0f b6 40 51	 movzx	 eax, BYTE PTR [rax+81]
  01ff4	0b c1		 or	 eax, ecx
  01ff6	48 8b 8c 24 50
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  01ffe	48 8b 89 70 08
	00 00		 mov	 rcx, QWORD PTR [rcx+2160]
  02005	48 8b 89 88 08
	00 00		 mov	 rcx, QWORD PTR [rcx+2184]
  0200c	88 41 51	 mov	 BYTE PTR [rcx+81], al
$LN162@z900_sie_e:

; 1744 : #endif
; 1745 :             memcpy( STATEBK->ipa, GUESTREGS->exinst, ilc );

  0200f	48 63 84 24 e4
	00 00 00	 movsxd	 rax, DWORD PTR ilc$6[rsp]
  02017	48 8b 8c 24 50
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0201f	48 8b 89 70 08
	00 00		 mov	 rcx, QWORD PTR [rcx+2160]
  02026	48 81 c1 40 08
	00 00		 add	 rcx, 2112		; 00000840H
  0202d	48 8b 94 24 50
	01 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  02035	48 8b 92 70 08
	00 00		 mov	 rdx, QWORD PTR [rdx+2160]
  0203c	48 8b 92 88 08
	00 00		 mov	 rdx, QWORD PTR [rdx+2184]
  02043	48 83 c2 56	 add	 rdx, 86			; 00000056H
  02047	48 8b fa	 mov	 rdi, rdx
  0204a	48 8b f1	 mov	 rsi, rcx
  0204d	48 8b c8	 mov	 rcx, rax
  02050	f3 a4		 rep movsb

; 1746 :         }

  02052	e9 df 00 00 00	 jmp	 $LN160@z900_sie_e
$LN159@z900_sie_e:

; 1747 :         else
; 1748 :         {
; 1749 :             if (!GUESTREGS->instinvalid)

  02057	48 8b 84 24 50
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0205f	48 8b 80 70 08
	00 00		 mov	 rax, QWORD PTR [rax+2160]
  02066	8b 80 28 07 00
	00		 mov	 eax, DWORD PTR [rax+1832]
  0206c	c1 e8 03	 shr	 eax, 3
  0206f	83 e0 01	 and	 eax, 1
  02072	85 c0		 test	 eax, eax
  02074	0f 85 bc 00 00
	00		 jne	 $LN163@z900_sie_e

; 1750 :                 memcpy( STATEBK->ipa, GUESTREGS->ip, ILC( GUESTREGS->ip[0] ));

  0207a	48 8b 84 24 50
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  02082	48 8b 80 70 08
	00 00		 mov	 rax, QWORD PTR [rax+2160]
  02089	b9 01 00 00 00	 mov	 ecx, 1
  0208e	48 6b c9 00	 imul	 rcx, rcx, 0
  02092	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  02096	0f b6 04 08	 movzx	 eax, BYTE PTR [rax+rcx]
  0209a	83 f8 40	 cmp	 eax, 64			; 00000040H
  0209d	7d 0d		 jge	 SHORT $LN225@z900_sie_e
  0209f	c7 84 24 ec 00
	00 00 02 00 00
	00		 mov	 DWORD PTR tv1204[rsp], 2
  020aa	eb 4d		 jmp	 SHORT $LN226@z900_sie_e
$LN225@z900_sie_e:
  020ac	48 8b 84 24 50
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  020b4	48 8b 80 70 08
	00 00		 mov	 rax, QWORD PTR [rax+2160]
  020bb	b9 01 00 00 00	 mov	 ecx, 1
  020c0	48 6b c9 00	 imul	 rcx, rcx, 0
  020c4	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  020c8	0f b6 04 08	 movzx	 eax, BYTE PTR [rax+rcx]
  020cc	3d c0 00 00 00	 cmp	 eax, 192		; 000000c0H
  020d1	7d 0d		 jge	 SHORT $LN223@z900_sie_e
  020d3	c7 84 24 f4 00
	00 00 04 00 00
	00		 mov	 DWORD PTR tv1203[rsp], 4
  020de	eb 0b		 jmp	 SHORT $LN224@z900_sie_e
$LN223@z900_sie_e:
  020e0	c7 84 24 f4 00
	00 00 06 00 00
	00		 mov	 DWORD PTR tv1203[rsp], 6
$LN224@z900_sie_e:
  020eb	8b 84 24 f4 00
	00 00		 mov	 eax, DWORD PTR tv1203[rsp]
  020f2	89 84 24 ec 00
	00 00		 mov	 DWORD PTR tv1204[rsp], eax
$LN226@z900_sie_e:
  020f9	48 63 84 24 ec
	00 00 00	 movsxd	 rax, DWORD PTR tv1204[rsp]
  02101	48 8b 8c 24 50
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  02109	48 8b 89 70 08
	00 00		 mov	 rcx, QWORD PTR [rcx+2160]
  02110	48 8b 94 24 50
	01 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  02118	48 8b 92 70 08
	00 00		 mov	 rdx, QWORD PTR [rdx+2160]
  0211f	48 8b 92 88 08
	00 00		 mov	 rdx, QWORD PTR [rdx+2184]
  02126	48 83 c2 56	 add	 rdx, 86			; 00000056H
  0212a	48 8b fa	 mov	 rdi, rdx
  0212d	48 8b 71 68	 mov	 rsi, QWORD PTR [rcx+104]
  02131	48 8b c8	 mov	 rcx, rax
  02134	f3 a4		 rep movsb
$LN163@z900_sie_e:
$LN160@z900_sie_e:
$LN151@z900_sie_e:
$LN83@z900_sie_e:

; 1751 :         }
; 1752 :     }
; 1753 : 
; 1754 :     PTT_SIE( "sie_xit ret", 0, 0, 0  );

  02136	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_pttclass
  0213d	48 8b 00	 mov	 rax, QWORD PTR [rax]
  02140	48 25 80 00 00
	00		 and	 rax, 128		; 00000080H
  02146	48 85 c0	 test	 rax, rax
  02149	74 36		 je	 SHORT $LN164@z900_sie_e
  0214b	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR [rsp+48], 0
  02154	48 c7 44 24 28
	00 00 00 00	 mov	 QWORD PTR [rsp+40], 0
  0215d	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG195783
  02164	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  02169	45 33 c9	 xor	 r9d, r9d
  0216c	45 33 c0	 xor	 r8d, r8d
  0216f	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG195784
  02176	b9 80 00 00 00	 mov	 ecx, 128		; 00000080H
  0217b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ptt_pthread_trace
$LN164@z900_sie_e:
  02181	33 c0		 xor	 eax, eax
  02183	85 c0		 test	 eax, eax
  02185	75 af		 jne	 SHORT $LN83@z900_sie_e

; 1755 : 
; 1756 : } /* end function sie_exit */

  02187	48 81 c4 38 01
	00 00		 add	 rsp, 312		; 00000138H
  0218e	5f		 pop	 rdi
  0218f	5e		 pop	 rsi
  02190	c3		 ret	 0
  02191	0f 1f 00	 npad	 3
$LN227@z900_sie_e:
  02194	00 00 00 00	 DD	 $LN113@z900_sie_e
  02198	00 00 00 00	 DD	 $LN112@z900_sie_e
  0219c	00 00 00 00	 DD	 $LN111@z900_sie_e
  021a0	00 00 00 00	 DD	 $LN103@z900_sie_e
  021a4	00 00 00 00	 DD	 $LN110@z900_sie_e
  021a8	00 00 00 00	 DD	 $LN109@z900_sie_e
  021ac	00 00 00 00	 DD	 $LN115@z900_sie_e
  021b0	00 00 00 00	 DD	 $LN115@z900_sie_e
  021b4	00 00 00 00	 DD	 $LN106@z900_sie_e
  021b8	00 00 00 00	 DD	 $LN105@z900_sie_e
  021bc	00 00 00 00	 DD	 $LN107@z900_sie_e
  021c0	00 00 00 00	 DD	 $LN108@z900_sie_e
  021c4	00 00 00 00	 DD	 $LN104@z900_sie_e
  021c8	00 00 00 00	 DD	 $LN102@z900_sie_e
  021cc	00 00 00 00	 DD	 $LN101@z900_sie_e
  021d0	00 00 00 00	 DD	 $LN96@z900_sie_e
  021d4	00 00 00 00	 DD	 $LN115@z900_sie_e
  021d8	00 00 00 00	 DD	 $LN115@z900_sie_e
  021dc	00 00 00 00	 DD	 $LN114@z900_sie_e
z900_sie_exit ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\sie.h
;	COMDAT s390_GetPGSTE_and_RCPTE
_TEXT	SEGMENT
regs$ = 48
gabspage$ = 56
ppPGSTE$ = 64
ppRCPTE$ = 72
s390_GetPGSTE_and_RCPTE PROC				; COMDAT

; 516  : {

$LN12:
  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 517  : #if defined( _FEATURE_STORAGE_KEY_ASSIST )
; 518  :     if (0
; 519  :         || SIE_STATE_BIT_ON( regs, RCPO0, SKA )
; 520  : #if defined( _FEATURE_ZSIE )
; 521  :         // SKA is always active for z/VM
; 522  :         || ARCH_900_IDX == HOSTREGS->arch_mode

  00018	33 c0		 xor	 eax, eax
  0001a	85 c0		 test	 eax, eax
  0001c	75 49		 jne	 SHORT $LN7@s390_GetPG
  0001e	48 8b 44 24 30	 mov	 rax, QWORD PTR regs$[rsp]
  00023	8b 80 c8 08 00
	00		 mov	 eax, DWORD PTR [rax+2248]
  00029	d1 e8		 shr	 eax, 1
  0002b	83 e0 01	 and	 eax, 1
  0002e	85 c0		 test	 eax, eax
  00030	74 23		 je	 SHORT $LN8@s390_GetPG
  00032	48 8b 44 24 30	 mov	 rax, QWORD PTR regs$[rsp]
  00037	48 8b 80 88 08
	00 00		 mov	 rax, QWORD PTR [rax+2184]
  0003e	b9 01 00 00 00	 mov	 ecx, 1
  00043	48 6b c9 00	 imul	 rcx, rcx, 0
  00047	0f b6 44 08 60	 movzx	 eax, BYTE PTR [rax+rcx+96]
  0004c	25 80 00 00 00	 and	 eax, 128		; 00000080H
  00051	85 c0		 test	 eax, eax
  00053	75 12		 jne	 SHORT $LN7@s390_GetPG
$LN8@s390_GetPG:
  00055	48 8b 44 24 30	 mov	 rax, QWORD PTR regs$[rsp]
  0005a	48 8b 80 68 08
	00 00		 mov	 rax, QWORD PTR [rax+2152]
  00061	83 78 64 02	 cmp	 DWORD PTR [rax+100], 2
  00065	75 2f		 jne	 SHORT $LN5@s390_GetPG
$LN7@s390_GetPG:

; 523  : #endif
; 524  :     )
; 525  :     {
; 526  :         /* SKA: Get pointer to both PGSTE and RCPTE */
; 527  :         *ppPGSTE = ARCH_DEP( GetPGSTE )( regs, gabspage );

  00067	48 8b 54 24 38	 mov	 rdx, QWORD PTR gabspage$[rsp]
  0006c	48 8b 4c 24 30	 mov	 rcx, QWORD PTR regs$[rsp]
  00071	e8 00 00 00 00	 call	 s390_GetPGSTE
  00076	48 8b 4c 24 40	 mov	 rcx, QWORD PTR ppPGSTE$[rsp]
  0007b	48 89 01	 mov	 QWORD PTR [rcx], rax

; 528  :         *ppRCPTE = &(*ppPGSTE)->pgsrcp;

  0007e	48 8b 44 24 40	 mov	 rax, QWORD PTR ppPGSTE$[rsp]
  00083	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00086	48 ff c0	 inc	 rax
  00089	48 8b 4c 24 48	 mov	 rcx, QWORD PTR ppRCPTE$[rsp]
  0008e	48 89 01	 mov	 QWORD PTR [rcx], rax

; 529  :     }

  00091	e9 80 00 00 00	 jmp	 $LN6@s390_GetPG
$LN5@s390_GetPG:

; 530  :     else // (NOT SKA...)
; 531  : #endif /* defined( _FEATURE_STORAGE_KEY_ASSIST ) */
; 532  :     {
; 533  : #if defined( FEATURE_MULTIPLE_CONTROLLED_DATA_SPACE )
; 534  :         if (SIE_STATE_BIT_ON( regs, MX, XC ))

  00096	48 8b 44 24 30	 mov	 rax, QWORD PTR regs$[rsp]
  0009b	8b 80 c8 08 00
	00		 mov	 eax, DWORD PTR [rax+2248]
  000a1	d1 e8		 shr	 eax, 1
  000a3	83 e0 01	 and	 eax, 1
  000a6	85 c0		 test	 eax, eax
  000a8	74 49		 je	 SHORT $LN9@s390_GetPG
  000aa	48 8b 44 24 30	 mov	 rax, QWORD PTR regs$[rsp]
  000af	48 8b 80 88 08
	00 00		 mov	 rax, QWORD PTR [rax+2184]
  000b6	0f b6 40 02	 movzx	 eax, BYTE PTR [rax+2]
  000ba	83 e0 01	 and	 eax, 1
  000bd	85 c0		 test	 eax, eax
  000bf	74 32		 je	 SHORT $LN9@s390_GetPG
$LN4@s390_GetPG:

; 535  :             SIE_INTERCEPT( regs );

  000c1	48 8b 44 24 30	 mov	 rax, QWORD PTR regs$[rsp]
  000c6	8b 80 c8 08 00
	00		 mov	 eax, DWORD PTR [rax+2248]
  000cc	d1 e8		 shr	 eax, 1
  000ce	83 e0 01	 and	 eax, 1
  000d1	85 c0		 test	 eax, eax
  000d3	74 18		 je	 SHORT $LN10@s390_GetPG
  000d5	48 8b 44 24 30	 mov	 rax, QWORD PTR regs$[rsp]
  000da	48 05 80 09 00
	00		 add	 rax, 2432		; 00000980H
  000e0	ba fc ff ff ff	 mov	 edx, -4
  000e5	48 8b c8	 mov	 rcx, rax
  000e8	e8 00 00 00 00	 call	 longjmp
$LN10@s390_GetPG:
  000ed	33 c0		 xor	 eax, eax
  000ef	85 c0		 test	 eax, eax
  000f1	75 ce		 jne	 SHORT $LN4@s390_GetPG
$LN9@s390_GetPG:

; 536  : #endif
; 537  :         /* Get just the pointer to the old RCP table byte */
; 538  :         *ppPGSTE = NULL;

  000f3	48 8b 44 24 40	 mov	 rax, QWORD PTR ppPGSTE$[rsp]
  000f8	48 c7 00 00 00
	00 00		 mov	 QWORD PTR [rax], 0

; 539  :         *ppRCPTE = ARCH_DEP( GetOldRCP )( regs, gabspage );

  000ff	48 8b 54 24 38	 mov	 rdx, QWORD PTR gabspage$[rsp]
  00104	48 8b 4c 24 30	 mov	 rcx, QWORD PTR regs$[rsp]
  00109	e8 00 00 00 00	 call	 s390_GetOldRCP
  0010e	48 8b 4c 24 48	 mov	 rcx, QWORD PTR ppRCPTE$[rsp]
  00113	48 89 01	 mov	 QWORD PTR [rcx], rax
$LN6@s390_GetPG:
$LN11@s390_GetPG:

; 540  :     }
; 541  : }

  00116	48 83 c4 28	 add	 rsp, 40			; 00000028H
  0011a	c3		 ret	 0
s390_GetPGSTE_and_RCPTE ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\sie.h
;	COMDAT s390_GetOldRCP
_TEXT	SEGMENT
rcpa$ = 48
tv86 = 56
regs$ = 80
gabspage$ = 88
s390_GetOldRCP PROC					; COMDAT

; 497  : {

$LN5:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 498  :     /* Obtain address of the RCP area from the state desc */
; 499  :     RADR rcpa = regs->sie_rcpo;

  0000e	48 8b 44 24 50	 mov	 rax, QWORD PTR regs$[rsp]
  00013	48 8b 80 b0 08
	00 00		 mov	 rax, QWORD PTR [rax+2224]
  0001a	48 89 44 24 30	 mov	 QWORD PTR rcpa$[rsp], rax

; 500  : 
; 501  :     /* Use page index as byte offset into RCP table */
; 502  :     rcpa += (gabspage >> STORKEY_KEY_4K_SHIFTAMT);

  0001f	48 8b 44 24 58	 mov	 rax, QWORD PTR gabspage$[rsp]
  00024	48 c1 e8 0c	 shr	 rax, 12
  00028	48 8b 4c 24 30	 mov	 rcx, QWORD PTR rcpa$[rsp]
  0002d	48 03 c8	 add	 rcx, rax
  00030	48 8b c1	 mov	 rax, rcx
  00033	48 89 44 24 30	 mov	 QWORD PTR rcpa$[rsp], rax

; 503  : 
; 504  :     /* Translate host primary address to host absolute */
; 505  :     rcpa = SIE_LOGICAL_TO_ABS( rcpa, USE_PRIMARY_SPACE,

  00038	48 8b 44 24 50	 mov	 rax, QWORD PTR regs$[rsp]
  0003d	48 8b 80 68 08
	00 00		 mov	 rax, QWORD PTR [rax+2152]
  00044	83 78 64 01	 cmp	 DWORD PTR [rax+100], 1
  00048	75 32		 jne	 SHORT $LN3@s390_GetOl
  0004a	48 c7 44 24 28
	01 00 00 00	 mov	 QWORD PTR [rsp+40], 1
  00053	c6 44 24 20 00	 mov	 BYTE PTR [rsp+32], 0
  00058	45 33 c9	 xor	 r9d, r9d
  0005b	48 8b 44 24 50	 mov	 rax, QWORD PTR regs$[rsp]
  00060	4c 8b 80 68 08
	00 00		 mov	 r8, QWORD PTR [rax+2152]
  00067	ba fd ff ff ff	 mov	 edx, -3
  0006c	8b 4c 24 30	 mov	 ecx, DWORD PTR rcpa$[rsp]
  00070	e8 00 00 00 00	 call	 s390_logical_to_main_l
  00075	48 89 44 24 38	 mov	 QWORD PTR tv86[rsp], rax
  0007a	eb 31		 jmp	 SHORT $LN4@s390_GetOl
$LN3@s390_GetOl:
  0007c	48 c7 44 24 28
	01 00 00 00	 mov	 QWORD PTR [rsp+40], 1
  00085	c6 44 24 20 00	 mov	 BYTE PTR [rsp+32], 0
  0008a	45 33 c9	 xor	 r9d, r9d
  0008d	48 8b 44 24 50	 mov	 rax, QWORD PTR regs$[rsp]
  00092	4c 8b 80 68 08
	00 00		 mov	 r8, QWORD PTR [rax+2152]
  00099	ba fd ff ff ff	 mov	 edx, -3
  0009e	48 8b 4c 24 30	 mov	 rcx, QWORD PTR rcpa$[rsp]
  000a3	e8 00 00 00 00	 call	 z900_logical_to_main_l
  000a8	48 89 44 24 38	 mov	 QWORD PTR tv86[rsp], rax
$LN4@s390_GetOl:
  000ad	48 8b 44 24 50	 mov	 rax, QWORD PTR regs$[rsp]
  000b2	48 8b 80 68 08
	00 00		 mov	 rax, QWORD PTR [rax+2152]
  000b9	48 8b 80 08 08
	00 00		 mov	 rax, QWORD PTR [rax+2056]
  000c0	48 89 44 24 30	 mov	 QWORD PTR rcpa$[rsp], rax

; 506  :                                HOSTREGS, ACCTYPE_SIE, 0 );
; 507  : 
; 508  :     /* Return mainstor address of RCP table byte */
; 509  :     return (RCPTE*)(&regs->mainstor[ rcpa ]);

  000c5	48 8b 44 24 50	 mov	 rax, QWORD PTR regs$[rsp]
  000ca	48 8b 80 48 08
	00 00		 mov	 rax, QWORD PTR [rax+2120]
  000d1	48 03 44 24 30	 add	 rax, QWORD PTR rcpa$[rsp]

; 510  : }

  000d6	48 83 c4 48	 add	 rsp, 72			; 00000048H
  000da	c3		 ret	 0
s390_GetOldRCP ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\sie.h
;	COMDAT s390_GetPGSTE
_TEXT	SEGMENT
tv84 = 32
pte$ = 40
pgste$ = 48
regs$ = 80
gabspage$ = 88
s390_GetPGSTE PROC					; COMDAT

; 475  : {

$LN10:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 476  :     PGSTE*  pgste;
; 477  :     U64     pte;
; 478  : 
; 479  :     // Guest absolute to host PTE addr
; 480  :     if (SIE_TRANSLATE_ADDR( regs->sie_mso + gabspage,

  0000e	48 8b 44 24 50	 mov	 rax, QWORD PTR regs$[rsp]
  00013	48 8b 80 68 08
	00 00		 mov	 rax, QWORD PTR [rax+2152]
  0001a	83 78 64 01	 cmp	 DWORD PTR [rax+100], 1
  0001e	75 35		 jne	 SHORT $LN8@s390_GetPG
  00020	48 8b 44 24 50	 mov	 rax, QWORD PTR regs$[rsp]
  00025	48 8b 80 98 08
	00 00		 mov	 rax, QWORD PTR [rax+2200]
  0002c	48 03 44 24 58	 add	 rax, QWORD PTR gabspage$[rsp]
  00031	41 b9 00 03 00
	00		 mov	 r9d, 768		; 00000300H
  00037	48 8b 4c 24 50	 mov	 rcx, QWORD PTR regs$[rsp]
  0003c	4c 8b 81 68 08
	00 00		 mov	 r8, QWORD PTR [rcx+2152]
  00043	ba fd ff ff ff	 mov	 edx, -3
  00048	8b c8		 mov	 ecx, eax
  0004a	e8 00 00 00 00	 call	 s390_translate_addr
  0004f	89 44 24 20	 mov	 DWORD PTR tv84[rsp], eax
  00053	eb 34		 jmp	 SHORT $LN9@s390_GetPG
$LN8@s390_GetPG:
  00055	48 8b 44 24 50	 mov	 rax, QWORD PTR regs$[rsp]
  0005a	48 8b 80 98 08
	00 00		 mov	 rax, QWORD PTR [rax+2200]
  00061	48 03 44 24 58	 add	 rax, QWORD PTR gabspage$[rsp]
  00066	41 b9 00 03 00
	00		 mov	 r9d, 768		; 00000300H
  0006c	48 8b 4c 24 50	 mov	 rcx, QWORD PTR regs$[rsp]
  00071	4c 8b 81 68 08
	00 00		 mov	 r8, QWORD PTR [rcx+2152]
  00078	ba fd ff ff ff	 mov	 edx, -3
  0007d	48 8b c8	 mov	 rcx, rax
  00080	e8 00 00 00 00	 call	 z900_translate_addr
  00085	89 44 24 20	 mov	 DWORD PTR tv84[rsp], eax
$LN9@s390_GetPG:
  00089	83 7c 24 20 00	 cmp	 DWORD PTR tv84[rsp], 0
  0008e	74 32		 je	 SHORT $LN5@s390_GetPG
$LN4@s390_GetPG:

; 481  :                             USE_PRIMARY_SPACE,
; 482  :                             HOSTREGS, ACCTYPE_PTE ))
; 483  :         SIE_INTERCEPT( regs );

  00090	48 8b 44 24 50	 mov	 rax, QWORD PTR regs$[rsp]
  00095	8b 80 c8 08 00
	00		 mov	 eax, DWORD PTR [rax+2248]
  0009b	d1 e8		 shr	 eax, 1
  0009d	83 e0 01	 and	 eax, 1
  000a0	85 c0		 test	 eax, eax
  000a2	74 18		 je	 SHORT $LN6@s390_GetPG
  000a4	48 8b 44 24 50	 mov	 rax, QWORD PTR regs$[rsp]
  000a9	48 05 80 09 00
	00		 add	 rax, 2432		; 00000980H
  000af	ba fc ff ff ff	 mov	 edx, -4
  000b4	48 8b c8	 mov	 rcx, rax
  000b7	e8 00 00 00 00	 call	 longjmp
$LN6@s390_GetPG:
  000bc	33 c0		 xor	 eax, eax
  000be	85 c0		 test	 eax, eax
  000c0	75 ce		 jne	 SHORT $LN4@s390_GetPG
$LN5@s390_GetPG:

; 484  : 
; 485  :     // Convert host real address to host absolute address
; 486  :     pte = apply_host_prefixing( HOSTREGS, HOSTREGS->dat.raddr );

  000c2	48 8b 44 24 50	 mov	 rax, QWORD PTR regs$[rsp]
  000c7	48 8b 80 68 08
	00 00		 mov	 rax, QWORD PTR [rax+2152]
  000ce	48 8b 90 00 08
	00 00		 mov	 rdx, QWORD PTR [rax+2048]
  000d5	48 8b 44 24 50	 mov	 rax, QWORD PTR regs$[rsp]
  000da	48 8b 88 68 08
	00 00		 mov	 rcx, QWORD PTR [rax+2152]
  000e1	e8 00 00 00 00	 call	 apply_host_prefixing
  000e6	48 89 44 24 28	 mov	 QWORD PTR pte$[rsp], rax

; 487  : 
; 488  :     // Convert host abs PTE to PGSTE
; 489  :     pgste = ARCH_DEP( GetPGSTEFromPTE )( regs, pte );

  000eb	48 8b 54 24 28	 mov	 rdx, QWORD PTR pte$[rsp]
  000f0	48 8b 4c 24 50	 mov	 rcx, QWORD PTR regs$[rsp]
  000f5	e8 00 00 00 00	 call	 s390_GetPGSTEFromPTE
  000fa	48 89 44 24 30	 mov	 QWORD PTR pgste$[rsp], rax

; 490  :     return pgste;

  000ff	48 8b 44 24 30	 mov	 rax, QWORD PTR pgste$[rsp]
$LN7@s390_GetPG:

; 491  : }

  00104	48 83 c4 48	 add	 rsp, 72			; 00000048H
  00108	c3		 ret	 0
s390_GetPGSTE ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\sie.h
;	COMDAT s390_GetPGSTEFromPTE
_TEXT	SEGMENT
tv67 = 0
pte_offset_to_pgste$ = 8
pgste$ = 16
regs$ = 48
pte$ = 56
s390_GetPGSTEFromPTE PROC				; COMDAT

; 456  : {

$LN5:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 457  :     PGSTE*  pgste;
; 458  :     size_t  pte_offset_to_pgste;
; 459  : 
; 460  :     // Calculate offset to PGSTE (depends if host is z/VM or VM/ESA)
; 461  :     pte_offset_to_pgste = (ARCH_900_IDX == HOSTREGS->arch_mode)

  0000e	48 8b 44 24 30	 mov	 rax, QWORD PTR regs$[rsp]
  00013	48 8b 80 68 08
	00 00		 mov	 rax, QWORD PTR [rax+2152]
  0001a	83 78 64 02	 cmp	 DWORD PTR [rax+100], 2
  0001e	75 0a		 jne	 SHORT $LN3@s390_GetPG
  00020	48 c7 04 24 00
	08 00 00	 mov	 QWORD PTR tv67[rsp], 2048 ; 00000800H
  00028	eb 08		 jmp	 SHORT $LN4@s390_GetPG
$LN3@s390_GetPG:
  0002a	48 c7 04 24 00
	04 00 00	 mov	 QWORD PTR tv67[rsp], 1024 ; 00000400H
$LN4@s390_GetPG:
  00032	48 8b 04 24	 mov	 rax, QWORD PTR tv67[rsp]
  00036	48 89 44 24 08	 mov	 QWORD PTR pte_offset_to_pgste$[rsp], rax

; 462  :         ? offsetof( PGMBK64, pgmpgstb )   // (z/Arch z/VM)
; 463  :         : offsetof( PGMBK,   pgmpgstb );  // (S/390 VM/ESA)
; 464  : 
; 465  :     // Return mainstor address of PGSTE
; 466  :     pgste = (PGSTE*)&regs->mainstor[ pte + pte_offset_to_pgste ];

  0003b	48 8b 44 24 08	 mov	 rax, QWORD PTR pte_offset_to_pgste$[rsp]
  00040	48 8b 4c 24 38	 mov	 rcx, QWORD PTR pte$[rsp]
  00045	48 03 c8	 add	 rcx, rax
  00048	48 8b c1	 mov	 rax, rcx
  0004b	48 8b 4c 24 30	 mov	 rcx, QWORD PTR regs$[rsp]
  00050	48 8b 89 48 08
	00 00		 mov	 rcx, QWORD PTR [rcx+2120]
  00057	48 03 c8	 add	 rcx, rax
  0005a	48 8b c1	 mov	 rax, rcx
  0005d	48 89 44 24 10	 mov	 QWORD PTR pgste$[rsp], rax

; 467  : 
; 468  :     return pgste;

  00062	48 8b 44 24 10	 mov	 rax, QWORD PTR pgste$[rsp]

; 469  : }

  00067	48 83 c4 28	 add	 rsp, 40			; 00000028H
  0006b	c3		 ret	 0
s390_GetPGSTEFromPTE ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\sie.h
;	COMDAT s390_LockUnlockKeyLock
_TEXT	SEGMENT
regs$ = 48
pgste$ = 56
rcpte$ = 64
lock$ = 72
s390_LockUnlockKeyLock PROC				; COMDAT

; 437  : {

$LN5:
  00000	44 88 4c 24 20	 mov	 BYTE PTR [rsp+32], r9b
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 438  : #if defined( OPTION_USE_SKAIP_AS_LOCK )
; 439  :     if (pgste)

  00018	48 83 7c 24 38
	00		 cmp	 QWORD PTR pgste$[rsp], 0
  0001e	74 11		 je	 SHORT $LN2@s390_LockU

; 440  :         ARCH_DEP( LockUnlockSKALock )( regs, lock );

  00020	0f b6 54 24 48	 movzx	 edx, BYTE PTR lock$[rsp]
  00025	48 8b 4c 24 30	 mov	 rcx, QWORD PTR regs$[rsp]
  0002a	e8 00 00 00 00	 call	 s390_LockUnlockSKALock
  0002f	eb 15		 jmp	 SHORT $LN3@s390_LockU
$LN2@s390_LockU:

; 441  :     else
; 442  : #endif
; 443  :         ARCH_DEP( LockUnlockRCPLock )( regs, rcpte, lock );

  00031	44 0f b6 44 24
	48		 movzx	 r8d, BYTE PTR lock$[rsp]
  00037	48 8b 54 24 40	 mov	 rdx, QWORD PTR rcpte$[rsp]
  0003c	48 8b 4c 24 30	 mov	 rcx, QWORD PTR regs$[rsp]
  00041	e8 00 00 00 00	 call	 s390_LockUnlockRCPLock
$LN3@s390_LockU:

; 444  : }

  00046	48 83 c4 28	 add	 rsp, 40			; 00000028H
  0004a	c3		 ret	 0
s390_LockUnlockKeyLock ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\sie.h
;	COMDAT s390_LockUnlockSKALock
_TEXT	SEGMENT
old$1 = 32
new$ = 33
abspage$2 = 40
regs$ = 64
lock$ = 72
s390_LockUnlockSKALock PROC				; COMDAT

; 366  : {

$LN8:
  00000	88 54 24 10	 mov	 BYTE PTR [rsp+16], dl
  00004	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00009	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 367  :     BYTE new;
; 368  : 
; 369  :     if (lock)

  0000d	0f b6 44 24 48	 movzx	 eax, BYTE PTR lock$[rsp]
  00012	85 c0		 test	 eax, eax
  00014	74 6b		 je	 SHORT $LN5@s390_LockU

; 370  :     {
; 371  :         BYTE old = regs->siebk->SIE_RCPO0;

  00016	48 8b 44 24 40	 mov	 rax, QWORD PTR regs$[rsp]
  0001b	48 8b 80 88 08
	00 00		 mov	 rax, QWORD PTR [rax+2184]
  00022	b9 01 00 00 00	 mov	 ecx, 1
  00027	48 6b c9 00	 imul	 rcx, rcx, 0
  0002b	0f b6 44 08 60	 movzx	 eax, BYTE PTR [rax+rcx+96]
  00030	88 44 24 20	 mov	 BYTE PTR old$1[rsp], al
$LN4@s390_LockU:

; 372  : 
; 373  :         // MAINLOCK may be required if cmpxchg assists unavailable
; 374  :         OBTAIN_MAINLOCK( regs );
; 375  :         {
; 376  :             // Keep looping until we eventually obtain it...
; 377  :             do
; 378  :             {
; 379  :                 old &= ~SIE_RCPO0_SKAIP;        // Want bit to be initially off

  00034	0f b6 44 24 20	 movzx	 eax, BYTE PTR old$1[rsp]
  00039	83 e0 bf	 and	 eax, -65		; ffffffffffffffbfH
  0003c	88 44 24 20	 mov	 BYTE PTR old$1[rsp], al

; 380  :                 new = (old | SIE_RCPO0_SKAIP);  // And *WE* want to turn it on!

  00040	0f b6 44 24 20	 movzx	 eax, BYTE PTR old$1[rsp]
  00045	83 c8 40	 or	 eax, 64			; 00000040H
  00048	88 44 24 21	 mov	 BYTE PTR new$[rsp], al

; 381  :             }
; 382  :             while (cmpxchg1( &old, new, &regs->siebk->SIE_RCPO0 ) != 0);

  0004c	48 8b 44 24 40	 mov	 rax, QWORD PTR regs$[rsp]
  00051	48 8b 80 88 08
	00 00		 mov	 rax, QWORD PTR [rax+2184]
  00058	b9 01 00 00 00	 mov	 ecx, 1
  0005d	48 6b c9 00	 imul	 rcx, rcx, 0
  00061	48 8d 44 08 60	 lea	 rax, QWORD PTR [rax+rcx+96]
  00066	4c 8b c0	 mov	 r8, rax
  00069	0f b6 54 24 21	 movzx	 edx, BYTE PTR new$[rsp]
  0006e	48 8d 4c 24 20	 lea	 rcx, QWORD PTR old$1[rsp]
  00073	e8 00 00 00 00	 call	 cmpxchg1_x86
  00078	0f b6 c0	 movzx	 eax, al
  0007b	85 c0		 test	 eax, eax
  0007d	75 b5		 jne	 SHORT $LN4@s390_LockU

; 383  :         }
; 384  :         RELEASE_MAINLOCK( regs );
; 385  :     }

  0007f	eb 27		 jmp	 SHORT $LN6@s390_LockU
$LN5@s390_LockU:

; 386  :     else // (unlock)
; 387  :     {
; 388  :         // Atomically 'and' the lock bit off
; 389  :         new = ~SIE_RCPO0_SKAIP;

  00081	c6 44 24 21 bf	 mov	 BYTE PTR new$[rsp], 191	; 000000bfH

; 390  :         (void) H_ATOMIC_OP( &regs->siebk->SIE_RCPO0, new, and, And, & );

  00086	48 8b 44 24 40	 mov	 rax, QWORD PTR regs$[rsp]
  0008b	48 8b 80 88 08
	00 00		 mov	 rax, QWORD PTR [rax+2184]
  00092	b9 01 00 00 00	 mov	 ecx, 1
  00097	48 6b c9 00	 imul	 rcx, rcx, 0
  0009b	48 8d 44 08 60	 lea	 rax, QWORD PTR [rax+rcx+96]
  000a0	0f b6 4c 24 21	 movzx	 ecx, BYTE PTR new$[rsp]
  000a5	f0 20 08	 lock and BYTE PTR [rax], cl
$LN6@s390_LockU:

; 391  :     }
; 392  : 
; 393  :     // Set Reference and Change bit for the byte we just modified
; 394  :     {
; 395  :         U64 abspage = (U64) (((BYTE*)regs->siebk) - regs->mainstor);

  000a8	48 8b 44 24 40	 mov	 rax, QWORD PTR regs$[rsp]
  000ad	48 8b 4c 24 40	 mov	 rcx, QWORD PTR regs$[rsp]
  000b2	48 8b 89 48 08
	00 00		 mov	 rcx, QWORD PTR [rcx+2120]
  000b9	48 8b 80 88 08
	00 00		 mov	 rax, QWORD PTR [rax+2184]
  000c0	48 2b c1	 sub	 rax, rcx
  000c3	48 89 44 24 28	 mov	 QWORD PTR abspage$2[rsp], rax

; 396  :         ARCH_DEP( or_4K_storage_key )( abspage, (STORKEY_REF | STORKEY_CHANGE) );

  000c8	b2 06		 mov	 dl, 6
  000ca	48 8b 4c 24 28	 mov	 rcx, QWORD PTR abspage$2[rsp]
  000cf	e8 00 00 00 00	 call	 s390_or_4K_storage_key

; 397  :     }
; 398  : }

  000d4	48 83 c4 38	 add	 rsp, 56			; 00000038H
  000d8	c3		 ret	 0
s390_LockUnlockSKALock ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\sie.h
;	COMDAT s390_LockUnlockRCPLock
_TEXT	SEGMENT
old$1 = 32
new$ = 33
abspage$2 = 40
regs$ = 64
rcpte$ = 72
lock$ = 80
s390_LockUnlockRCPLock PROC				; COMDAT

; 316  : {

$LN8:
  00000	44 88 44 24 18	 mov	 BYTE PTR [rsp+24], r8b
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 317  :     BYTE new;
; 318  : 
; 319  :     if (lock)

  00013	0f b6 44 24 50	 movzx	 eax, BYTE PTR lock$[rsp]
  00018	85 c0		 test	 eax, eax
  0001a	74 46		 je	 SHORT $LN5@s390_LockU

; 320  :     {
; 321  :         BYTE old = rcpte->rcpbyte;

  0001c	48 8b 44 24 48	 mov	 rax, QWORD PTR rcpte$[rsp]
  00021	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  00024	88 44 24 20	 mov	 BYTE PTR old$1[rsp], al
$LN4@s390_LockU:

; 322  : 
; 323  :         // MAINLOCK may be required if cmpxchg assists unavailable
; 324  :         OBTAIN_MAINLOCK( regs );
; 325  :         {
; 326  :             // Keep looping until we eventually obtain it...
; 327  :             do
; 328  :             {
; 329  :                 old &= ~RCPLOCK;        // Want bit to be initially off

  00028	0f b6 44 24 20	 movzx	 eax, BYTE PTR old$1[rsp]
  0002d	0f ba f0 07	 btr	 eax, 7
  00031	88 44 24 20	 mov	 BYTE PTR old$1[rsp], al

; 330  :                 new = (old | RCPLOCK);  // And *WE* want to turn it on!

  00035	0f b6 44 24 20	 movzx	 eax, BYTE PTR old$1[rsp]
  0003a	0f ba e8 07	 bts	 eax, 7
  0003e	88 44 24 21	 mov	 BYTE PTR new$[rsp], al

; 331  :             }
; 332  :             while (cmpxchg1( &old, new, &rcpte->rcpbyte ) != 0);

  00042	48 8b 44 24 48	 mov	 rax, QWORD PTR rcpte$[rsp]
  00047	4c 8b c0	 mov	 r8, rax
  0004a	0f b6 54 24 21	 movzx	 edx, BYTE PTR new$[rsp]
  0004f	48 8d 4c 24 20	 lea	 rcx, QWORD PTR old$1[rsp]
  00054	e8 00 00 00 00	 call	 cmpxchg1_x86
  00059	0f b6 c0	 movzx	 eax, al
  0005c	85 c0		 test	 eax, eax
  0005e	75 c8		 jne	 SHORT $LN4@s390_LockU

; 333  :         }
; 334  :         RELEASE_MAINLOCK( regs );
; 335  :     }

  00060	eb 12		 jmp	 SHORT $LN6@s390_LockU
$LN5@s390_LockU:

; 336  :     else // (unlock)
; 337  :     {
; 338  :         // Atomically 'and' the lock bit off
; 339  :         new = (BYTE)(~RCPLOCK);

  00062	c6 44 24 21 7f	 mov	 BYTE PTR new$[rsp], 127	; 0000007fH

; 340  :         (void) H_ATOMIC_OP( &rcpte->rcpbyte, new, and, And, & );

  00067	48 8b 44 24 48	 mov	 rax, QWORD PTR rcpte$[rsp]
  0006c	0f b6 4c 24 21	 movzx	 ecx, BYTE PTR new$[rsp]
  00071	f0 20 08	 lock and BYTE PTR [rax], cl
$LN6@s390_LockU:

; 341  :     }
; 342  : 
; 343  :     // Set Reference and Change bit for the byte we just modified
; 344  :     {
; 345  :         U64 abspage = (U64) (((BYTE*)rcpte) - regs->mainstor);

  00074	48 8b 44 24 40	 mov	 rax, QWORD PTR regs$[rsp]
  00079	48 8b 80 48 08
	00 00		 mov	 rax, QWORD PTR [rax+2120]
  00080	48 8b 4c 24 48	 mov	 rcx, QWORD PTR rcpte$[rsp]
  00085	48 2b c8	 sub	 rcx, rax
  00088	48 8b c1	 mov	 rax, rcx
  0008b	48 89 44 24 28	 mov	 QWORD PTR abspage$2[rsp], rax

; 346  :         ARCH_DEP( or_4K_storage_key )( abspage, (STORKEY_REF | STORKEY_CHANGE) );

  00090	b2 06		 mov	 dl, 6
  00092	48 8b 4c 24 28	 mov	 rcx, QWORD PTR abspage$2[rsp]
  00097	e8 00 00 00 00	 call	 s390_or_4K_storage_key

; 347  :     }
; 348  : }

  0009c	48 83 c4 38	 add	 rsp, 56			; 00000038H
  000a0	c3		 ret	 0
s390_LockUnlockRCPLock ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\sie.h
;	COMDAT s390_LockUnlockSCALock
_TEXT	SEGMENT
old$1 = 32
new$ = 33
obtained$ = 34
tv84 = 36
tv86 = 40
scabk$ = 48
abspage$2 = 56
regs$ = 80
lock$ = 88
trylock$ = 96
s390_LockUnlockSCALock PROC				; COMDAT

; 255  : {

$LN13:
  00000	44 88 44 24 18	 mov	 BYTE PTR [rsp+24], r8b
  00005	88 54 24 10	 mov	 BYTE PTR [rsp+16], dl
  00009	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000e	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 256  :     BYTE new;
; 257  :     bool obtained = false;

  00012	c6 44 24 22 00	 mov	 BYTE PTR obtained$[rsp], 0

; 258  :     SCABK* scabk = (SCABK*) &regs->mainstor[ regs->sie_scao ];

  00017	48 8b 44 24 50	 mov	 rax, QWORD PTR regs$[rsp]
  0001c	48 8b 80 48 08
	00 00		 mov	 rax, QWORD PTR [rax+2120]
  00023	48 8b 4c 24 50	 mov	 rcx, QWORD PTR regs$[rsp]
  00028	48 03 81 b8 08
	00 00		 add	 rax, QWORD PTR [rcx+2232]
  0002f	48 89 44 24 30	 mov	 QWORD PTR scabk$[rsp], rax

; 259  : 
; 260  :     if (lock)

  00034	0f b6 44 24 58	 movzx	 eax, BYTE PTR lock$[rsp]
  00039	85 c0		 test	 eax, eax
  0003b	0f 84 8c 00 00
	00		 je	 $LN5@s390_LockU

; 261  :     {
; 262  :         BYTE old = scabk->scaiplk0;

  00041	48 8b 44 24 30	 mov	 rax, QWORD PTR scabk$[rsp]
  00046	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  00049	88 44 24 20	 mov	 BYTE PTR old$1[rsp], al
$LN4@s390_LockU:

; 263  : 
; 264  :         // MAINLOCK may be required if cmpxchg assists unavailable
; 265  :         OBTAIN_MAINLOCK( regs );
; 266  :         {
; 267  :             // If not TRY call, keep looping until we obtain it.
; 268  :             // Otherwise TRY just once, and return success or not.
; 269  :             do
; 270  :             {
; 271  :                 old &= ~SCAIPLKH;       // Want bit to be initially off

  0004d	0f b6 44 24 20	 movzx	 eax, BYTE PTR old$1[rsp]
  00052	0f ba f0 07	 btr	 eax, 7
  00056	88 44 24 20	 mov	 BYTE PTR old$1[rsp], al

; 272  :                 new = (old | SCAIPLKH); // And *WE* want to turn it on!

  0005a	0f b6 44 24 20	 movzx	 eax, BYTE PTR old$1[rsp]
  0005f	0f ba e8 07	 bts	 eax, 7
  00063	88 44 24 21	 mov	 BYTE PTR new$[rsp], al

; 273  :             }
; 274  :             while (!(obtained = (0 == cmpxchg1( &old, new, &scabk->scaiplk0 ))) && !trylock);

  00067	48 8b 44 24 30	 mov	 rax, QWORD PTR scabk$[rsp]
  0006c	4c 8b c0	 mov	 r8, rax
  0006f	0f b6 54 24 21	 movzx	 edx, BYTE PTR new$[rsp]
  00074	48 8d 4c 24 20	 lea	 rcx, QWORD PTR old$1[rsp]
  00079	e8 00 00 00 00	 call	 cmpxchg1_x86
  0007e	0f b6 c0	 movzx	 eax, al
  00081	85 c0		 test	 eax, eax
  00083	75 0a		 jne	 SHORT $LN9@s390_LockU
  00085	c7 44 24 24 01
	00 00 00	 mov	 DWORD PTR tv84[rsp], 1
  0008d	eb 08		 jmp	 SHORT $LN10@s390_LockU
$LN9@s390_LockU:
  0008f	c7 44 24 24 00
	00 00 00	 mov	 DWORD PTR tv84[rsp], 0
$LN10@s390_LockU:
  00097	83 7c 24 24 00	 cmp	 DWORD PTR tv84[rsp], 0
  0009c	75 0a		 jne	 SHORT $LN11@s390_LockU
  0009e	c7 44 24 28 00
	00 00 00	 mov	 DWORD PTR tv86[rsp], 0
  000a6	eb 08		 jmp	 SHORT $LN12@s390_LockU
$LN11@s390_LockU:
  000a8	c7 44 24 28 01
	00 00 00	 mov	 DWORD PTR tv86[rsp], 1
$LN12@s390_LockU:
  000b0	0f b6 44 24 28	 movzx	 eax, BYTE PTR tv86[rsp]
  000b5	88 44 24 22	 mov	 BYTE PTR obtained$[rsp], al
  000b9	0f b6 44 24 22	 movzx	 eax, BYTE PTR obtained$[rsp]
  000be	85 c0		 test	 eax, eax
  000c0	75 09		 jne	 SHORT $LN7@s390_LockU
  000c2	0f b6 44 24 60	 movzx	 eax, BYTE PTR trylock$[rsp]
  000c7	85 c0		 test	 eax, eax
  000c9	74 82		 je	 SHORT $LN4@s390_LockU
$LN7@s390_LockU:

; 275  :         }
; 276  :         RELEASE_MAINLOCK( regs );
; 277  :     }

  000cb	eb 12		 jmp	 SHORT $LN6@s390_LockU
$LN5@s390_LockU:

; 278  :     else // (unlock)
; 279  :     {
; 280  :         // Atomically 'and' the lock bit off
; 281  :         new = (BYTE)(~SCAIPLKH);

  000cd	c6 44 24 21 7f	 mov	 BYTE PTR new$[rsp], 127	; 0000007fH

; 282  :         (void) H_ATOMIC_OP( &scabk->scaiplk0, new, and, And, & );

  000d2	48 8b 44 24 30	 mov	 rax, QWORD PTR scabk$[rsp]
  000d7	0f b6 4c 24 21	 movzx	 ecx, BYTE PTR new$[rsp]
  000dc	f0 20 08	 lock and BYTE PTR [rax], cl
$LN6@s390_LockU:

; 283  :     }
; 284  : 
; 285  :     // Set Reference and Change bit for the byte we just modified
; 286  :     {
; 287  :         U64 abspage = (U64) (&scabk->scaiplk0 - regs->mainstor);

  000df	48 8b 44 24 30	 mov	 rax, QWORD PTR scabk$[rsp]
  000e4	48 8b 4c 24 50	 mov	 rcx, QWORD PTR regs$[rsp]
  000e9	48 2b 81 48 08
	00 00		 sub	 rax, QWORD PTR [rcx+2120]
  000f0	48 89 44 24 38	 mov	 QWORD PTR abspage$2[rsp], rax

; 288  :         ARCH_DEP( or_4K_storage_key )( abspage, (STORKEY_REF | STORKEY_CHANGE) );

  000f5	b2 06		 mov	 dl, 6
  000f7	48 8b 4c 24 38	 mov	 rcx, QWORD PTR abspage$2[rsp]
  000fc	e8 00 00 00 00	 call	 s390_or_4K_storage_key

; 289  :     }
; 290  : 
; 291  :     return obtained;

  00101	0f b6 44 24 22	 movzx	 eax, BYTE PTR obtained$[rsp]

; 292  : }

  00106	48 83 c4 48	 add	 rsp, 72			; 00000048H
  0010a	c3		 ret	 0
s390_LockUnlockSCALock ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\vstore.h
;	COMDAT s390_instfetch
_TEXT	SEGMENT
addr$ = 48
pagesz$ = 52
ip$ = 56
offset$ = 64
len$ = 68
tv78 = 72
tv80 = 76
tv133 = 80
tv135 = 84
tv142 = 88
tv161 = 92
tv177 = 96
tv179 = 100
tv185 = 104
tv192 = 108
tv210 = 112
tv251 = 116
tv250 = 120
tv252 = 124
tv310 = 128
tv311 = 132
dest$ = 136
tv317 = 144
regs$ = 176
exec$ = 184
s390_instfetch PROC					; COMDAT

; 777  : {

$LN76:
  00000	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00004	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00009	48 81 ec a8 00
	00 00		 sub	 rsp, 168		; 000000a8H

; 778  : VADR    addr;                           /* Instruction address       */
; 779  : BYTE*   ip;                             /* Instruction pointer       */
; 780  : BYTE*   dest;                           /* Fetched Instruction       */
; 781  : int     pagesz;                         /* Effective page size       */
; 782  : int     offset;                         /* Address offset into page  */
; 783  : int     len;                            /* Length for page crossing  */
; 784  : 
; 785  :     addr = exec ? regs->ET : VALID_AIE( regs ) ?

  00010	83 bc 24 b8 00
	00 00 00	 cmp	 DWORD PTR exec$[rsp], 0
  00018	74 14		 je	 SHORT $LN36@s390_instf
  0001a	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00022	8b 80 20 07 00
	00		 mov	 eax, DWORD PTR [rax+1824]
  00028	89 44 24 4c	 mov	 DWORD PTR tv80[rsp], eax
  0002c	eb 72		 jmp	 SHORT $LN37@s390_instf
$LN36@s390_instf:
  0002e	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00036	48 83 b8 08 02
	00 00 00	 cmp	 QWORD PTR [rax+520], 0
  0003e	74 46		 je	 SHORT $LN34@s390_instf
  00040	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00048	8b 80 10 02 00
	00		 mov	 eax, DWORD PTR [rax+528]
  0004e	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00056	48 8b 94 24 b0
	00 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  0005e	48 8b 92 00 02
	00 00		 mov	 rdx, QWORD PTR [rdx+512]
  00065	48 8b 49 68	 mov	 rcx, QWORD PTR [rcx+104]
  00069	48 2b ca	 sub	 rcx, rdx
  0006c	48 03 c1	 add	 rax, rcx
  0006f	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00077	8b 89 90 00 00
	00		 mov	 ecx, DWORD PTR [rcx+144]
  0007d	48 23 c1	 and	 rax, rcx
  00080	89 44 24 48	 mov	 DWORD PTR tv78[rsp], eax
  00084	eb 12		 jmp	 SHORT $LN35@s390_instf
$LN34@s390_instf:
  00086	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0008e	8b 80 88 00 00
	00		 mov	 eax, DWORD PTR [rax+136]
  00094	89 44 24 48	 mov	 DWORD PTR tv78[rsp], eax
$LN35@s390_instf:
  00098	8b 44 24 48	 mov	 eax, DWORD PTR tv78[rsp]
  0009c	89 44 24 4c	 mov	 DWORD PTR tv80[rsp], eax
$LN37@s390_instf:
  000a0	8b 44 24 4c	 mov	 eax, DWORD PTR tv80[rsp]
  000a4	89 44 24 30	 mov	 DWORD PTR addr$[rsp], eax

; 786  :         PSW_IA_FROM_IP( regs, 0 ) : regs->psw.IA;
; 787  : 
; 788  :     /* Ensure PSW IA matches the instruction we're fetching */
; 789  :     if (!exec)

  000a8	83 bc 24 b8 00
	00 00 00	 cmp	 DWORD PTR exec$[rsp], 0
  000b0	75 66		 jne	 SHORT $LN14@s390_instf
$LN4@s390_instf:

; 790  :         MAYBE_SET_PSW_IA_FROM_IP( regs );

  000b2	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  000ba	48 83 b8 08 02
	00 00 00	 cmp	 QWORD PTR [rax+520], 0
  000c2	74 4e		 je	 SHORT $LN15@s390_instf
  000c4	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  000cc	8b 80 10 02 00
	00		 mov	 eax, DWORD PTR [rax+528]
  000d2	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  000da	48 8b 94 24 b0
	00 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  000e2	48 8b 92 00 02
	00 00		 mov	 rdx, QWORD PTR [rdx+512]
  000e9	48 8b 49 68	 mov	 rcx, QWORD PTR [rcx+104]
  000ed	48 2b ca	 sub	 rcx, rdx
  000f0	48 03 c1	 add	 rax, rcx
  000f3	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  000fb	8b 89 90 00 00
	00		 mov	 ecx, DWORD PTR [rcx+144]
  00101	48 23 c1	 and	 rax, rcx
  00104	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0010c	89 81 88 00 00
	00		 mov	 DWORD PTR [rcx+136], eax
$LN15@s390_instf:
  00112	33 c0		 xor	 eax, eax
  00114	85 c0		 test	 eax, eax
  00116	75 9a		 jne	 SHORT $LN4@s390_instf
$LN14@s390_instf:

; 791  : 
; 792  :     offset = (int)(addr & PAGEFRAME_BYTEMASK);

  00118	8b 44 24 30	 mov	 eax, DWORD PTR addr$[rsp]
  0011c	25 ff 0f 00 00	 and	 eax, 4095		; 00000fffH
  00121	89 44 24 40	 mov	 DWORD PTR offset$[rsp], eax

; 793  : 
; 794  :     pagesz = unlikely( addr < 0x800 ) ? 0x800 : PAGEFRAME_PAGESIZE;

  00125	81 7c 24 30 00
	08 00 00	 cmp	 DWORD PTR addr$[rsp], 2048 ; 00000800H
  0012d	73 0a		 jae	 SHORT $LN40@s390_instf
  0012f	c7 44 24 50 01
	00 00 00	 mov	 DWORD PTR tv133[rsp], 1
  00137	eb 08		 jmp	 SHORT $LN41@s390_instf
$LN40@s390_instf:
  00139	c7 44 24 50 00
	00 00 00	 mov	 DWORD PTR tv133[rsp], 0
$LN41@s390_instf:
  00141	83 7c 24 50 00	 cmp	 DWORD PTR tv133[rsp], 0
  00146	74 0a		 je	 SHORT $LN42@s390_instf
  00148	c7 44 24 54 00
	08 00 00	 mov	 DWORD PTR tv135[rsp], 2048 ; 00000800H
  00150	eb 08		 jmp	 SHORT $LN43@s390_instf
$LN42@s390_instf:
  00152	c7 44 24 54 00
	10 00 00	 mov	 DWORD PTR tv135[rsp], 4096 ; 00001000H
$LN43@s390_instf:
  0015a	8b 44 24 54	 mov	 eax, DWORD PTR tv135[rsp]
  0015e	89 44 24 34	 mov	 DWORD PTR pagesz$[rsp], eax

; 795  : 
; 796  :     /* Program check if instruction address is odd */
; 797  :     if (unlikely( offset & 0x01 ))

  00162	8b 44 24 40	 mov	 eax, DWORD PTR offset$[rsp]
  00166	83 e0 01	 and	 eax, 1
  00169	85 c0		 test	 eax, eax
  0016b	74 0a		 je	 SHORT $LN46@s390_instf
  0016d	c7 44 24 58 01
	00 00 00	 mov	 DWORD PTR tv142[rsp], 1
  00175	eb 08		 jmp	 SHORT $LN47@s390_instf
$LN46@s390_instf:
  00177	c7 44 24 58 00
	00 00 00	 mov	 DWORD PTR tv142[rsp], 0
$LN47@s390_instf:
  0017f	83 7c 24 58 00	 cmp	 DWORD PTR tv142[rsp], 0
  00184	74 44		 je	 SHORT $LN16@s390_instf

; 798  :     {
; 799  :         if (!exec)

  00186	83 bc 24 b8 00
	00 00 00	 cmp	 DWORD PTR exec$[rsp], 0
  0018e	75 1f		 jne	 SHORT $LN17@s390_instf

; 800  :             regs->instinvalid = 1;

  00190	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00198	8b 80 28 07 00
	00		 mov	 eax, DWORD PTR [rax+1832]
  0019e	83 c8 08	 or	 eax, 8
  001a1	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  001a9	89 81 28 07 00
	00		 mov	 DWORD PTR [rcx+1832], eax
$LN17@s390_instf:

; 801  : 
; 802  :         regs->program_interrupt( regs, PGM_SPECIFICATION_EXCEPTION );

  001af	ba 06 00 00 00	 mov	 edx, 6
  001b4	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  001bc	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  001c4	ff 90 20 0d 00
	00		 call	 QWORD PTR [rax+3360]
$LN16@s390_instf:

; 803  :     }
; 804  : 
; 805  : #if defined( FEATURE_PER )
; 806  : 
; 807  :     /* Save the address used to fetch the instruction */
; 808  :     if (EN_IC_PER( regs ))

  001ca	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  001d2	8b 80 28 07 00
	00		 mov	 eax, DWORD PTR [rax+1832]
  001d8	c1 e8 02	 shr	 eax, 2
  001db	83 e0 01	 and	 eax, 1
  001de	85 c0		 test	 eax, eax
  001e0	74 0a		 je	 SHORT $LN50@s390_instf
  001e2	c7 44 24 5c 01
	00 00 00	 mov	 DWORD PTR tv161[rsp], 1
  001ea	eb 08		 jmp	 SHORT $LN51@s390_instf
$LN50@s390_instf:
  001ec	c7 44 24 5c 00
	00 00 00	 mov	 DWORD PTR tv161[rsp], 0
$LN51@s390_instf:
  001f4	83 7c 24 5c 00	 cmp	 DWORD PTR tv161[rsp], 0
  001f9	0f 84 72 03 00
	00		 je	 $LN18@s390_instf

; 809  :     {
; 810  : #if defined( FEATURE_PER2 )
; 811  :         regs->perc = 0x40    /* ATMID-validity */

  001ff	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00207	0f b6 40 78	 movzx	 eax, BYTE PTR [rax+120]
  0020b	83 e0 04	 and	 eax, 4
  0020e	85 c0		 test	 eax, eax
  00210	74 0a		 je	 SHORT $LN52@s390_instf
  00212	c7 44 24 60 01
	00 00 00	 mov	 DWORD PTR tv177[rsp], 1
  0021a	eb 08		 jmp	 SHORT $LN53@s390_instf
$LN52@s390_instf:
  0021c	c7 44 24 60 00
	00 00 00	 mov	 DWORD PTR tv177[rsp], 0
$LN53@s390_instf:
  00224	83 7c 24 60 00	 cmp	 DWORD PTR tv177[rsp], 0
  00229	74 0a		 je	 SHORT $LN54@s390_instf
  0022b	c7 44 24 64 10
	00 00 00	 mov	 DWORD PTR tv179[rsp], 16
  00233	eb 08		 jmp	 SHORT $LN55@s390_instf
$LN54@s390_instf:
  00235	c7 44 24 64 00
	00 00 00	 mov	 DWORD PTR tv179[rsp], 0
$LN55@s390_instf:
  0023d	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00245	0f b6 40 7b	 movzx	 eax, BYTE PTR [rax+123]
  00249	25 80 00 00 00	 and	 eax, 128		; 00000080H
  0024e	85 c0		 test	 eax, eax
  00250	74 0a		 je	 SHORT $LN56@s390_instf
  00252	c7 44 24 68 01
	00 00 00	 mov	 DWORD PTR tv185[rsp], 1
  0025a	eb 08		 jmp	 SHORT $LN57@s390_instf
$LN56@s390_instf:
  0025c	c7 44 24 68 00
	00 00 00	 mov	 DWORD PTR tv185[rsp], 0
$LN57@s390_instf:
  00264	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0026c	0f b6 40 7b	 movzx	 eax, BYTE PTR [rax+123]
  00270	83 e0 40	 and	 eax, 64			; 00000040H
  00273	85 c0		 test	 eax, eax
  00275	74 0a		 je	 SHORT $LN58@s390_instf
  00277	c7 44 24 6c 01
	00 00 00	 mov	 DWORD PTR tv192[rsp], 1
  0027f	eb 08		 jmp	 SHORT $LN59@s390_instf
$LN58@s390_instf:
  00281	c7 44 24 6c 00
	00 00 00	 mov	 DWORD PTR tv192[rsp], 0
$LN59@s390_instf:
  00289	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00291	8b 80 80 00 00
	00		 mov	 eax, DWORD PTR [rax+128]
  00297	83 e0 01	 and	 eax, 1
  0029a	c1 e0 07	 shl	 eax, 7
  0029d	83 c8 40	 or	 eax, 64			; 00000040H
  002a0	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  002a8	8b 89 80 00 00
	00		 mov	 ecx, DWORD PTR [rcx+128]
  002ae	d1 e9		 shr	 ecx, 1
  002b0	83 e1 01	 and	 ecx, 1
  002b3	c1 e1 05	 shl	 ecx, 5
  002b6	0b c1		 or	 eax, ecx
  002b8	0b 44 24 64	 or	 eax, DWORD PTR tv179[rsp]
  002bc	8b 4c 24 68	 mov	 ecx, DWORD PTR tv185[rsp]
  002c0	c1 e1 03	 shl	 ecx, 3
  002c3	0b c1		 or	 eax, ecx
  002c5	8b 4c 24 6c	 mov	 ecx, DWORD PTR tv192[rsp]
  002c9	c1 e1 02	 shl	 ecx, 2
  002cc	0b c1		 or	 eax, ecx
  002ce	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  002d6	66 89 81 d0 08
	00 00		 mov	 WORD PTR [rcx+2256], ax

; 812  :                    | (regs->psw.amode64        << 7 )
; 813  :                    | (regs->psw.amode          << 5 )
; 814  :                    | (!REAL_MODE( &regs->psw ) ? 0x10 : 0 )
; 815  :                    | (SPACE_BIT(  &regs->psw ) << 3 )
; 816  :                    | (AR_BIT   (  &regs->psw ) << 2 );
; 817  : #else
; 818  :         regs->perc = 0;
; 819  : #endif /* defined( FEATURE_PER2 ) */
; 820  : 
; 821  :         if (!exec)

  002dd	83 bc 24 b8 00
	00 00 00	 cmp	 DWORD PTR exec$[rsp], 0
  002e5	75 13		 jne	 SHORT $LN19@s390_instf

; 822  :             regs->peradr = addr;

  002e7	8b 44 24 30	 mov	 eax, DWORD PTR addr$[rsp]
  002eb	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  002f3	48 89 81 d8 08
	00 00		 mov	 QWORD PTR [rcx+2264], rax
$LN19@s390_instf:

; 823  : 
; 824  :         /* Test for PER instruction-fetching event */
; 825  :         if (1
; 826  :             && EN_IC_PER_IF( regs )
; 827  :             && PER_RANGE_CHECK( addr, regs->CR(10), regs->CR(11) )

  002fa	33 c0		 xor	 eax, eax
  002fc	83 f8 01	 cmp	 eax, 1
  002ff	0f 84 6e 01 00
	00		 je	 $LN20@s390_instf
  00305	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0030d	8b 80 28 07 00
	00		 mov	 eax, DWORD PTR [rax+1832]
  00313	c1 e8 02	 shr	 eax, 2
  00316	83 e0 01	 and	 eax, 1
  00319	85 c0		 test	 eax, eax
  0031b	74 0a		 je	 SHORT $LN62@s390_instf
  0031d	c7 44 24 70 01
	00 00 00	 mov	 DWORD PTR tv210[rsp], 1
  00325	eb 08		 jmp	 SHORT $LN63@s390_instf
$LN62@s390_instf:
  00327	c7 44 24 70 00
	00 00 00	 mov	 DWORD PTR tv210[rsp], 0
$LN63@s390_instf:
  0032f	83 7c 24 70 00	 cmp	 DWORD PTR tv210[rsp], 0
  00334	0f 84 39 01 00
	00		 je	 $LN20@s390_instf
  0033a	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00342	8b 40 48	 mov	 eax, DWORD PTR [rax+72]
  00345	25 00 00 40 00	 and	 eax, 4194304		; 00400000H
  0034a	85 c0		 test	 eax, eax
  0034c	0f 84 21 01 00
	00		 je	 $LN20@s390_instf
  00352	b8 08 00 00 00	 mov	 eax, 8
  00357	48 6b c0 0c	 imul	 rax, rax, 12
  0035b	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00363	8b 84 01 00 06
	00 00		 mov	 eax, DWORD PTR [rcx+rax+1536]
  0036a	0f ba f0 1f	 btr	 eax, 31
  0036e	b9 08 00 00 00	 mov	 ecx, 8
  00373	48 6b c9 0b	 imul	 rcx, rcx, 11
  00377	48 8b 94 24 b0
	00 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  0037f	8b 8c 0a 00 06
	00 00		 mov	 ecx, DWORD PTR [rdx+rcx+1536]
  00386	0f ba f1 1f	 btr	 ecx, 31
  0038a	3b c1		 cmp	 eax, ecx
  0038c	72 60		 jb	 SHORT $LN68@s390_instf
  0038e	b8 08 00 00 00	 mov	 eax, 8
  00393	48 6b c0 0b	 imul	 rax, rax, 11
  00397	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0039f	8b 84 01 00 06
	00 00		 mov	 eax, DWORD PTR [rcx+rax+1536]
  003a6	0f ba f0 1f	 btr	 eax, 31
  003aa	39 44 24 30	 cmp	 DWORD PTR addr$[rsp], eax
  003ae	72 2c		 jb	 SHORT $LN64@s390_instf
  003b0	b8 08 00 00 00	 mov	 eax, 8
  003b5	48 6b c0 0c	 imul	 rax, rax, 12
  003b9	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  003c1	8b 84 01 00 06
	00 00		 mov	 eax, DWORD PTR [rcx+rax+1536]
  003c8	0f ba f0 1f	 btr	 eax, 31
  003cc	39 44 24 30	 cmp	 DWORD PTR addr$[rsp], eax
  003d0	77 0a		 ja	 SHORT $LN64@s390_instf
  003d2	c7 44 24 74 01
	00 00 00	 mov	 DWORD PTR tv251[rsp], 1
  003da	eb 08		 jmp	 SHORT $LN67@s390_instf
$LN64@s390_instf:
  003dc	c7 44 24 74 00
	00 00 00	 mov	 DWORD PTR tv251[rsp], 0
$LN67@s390_instf:
  003e4	8b 44 24 74	 mov	 eax, DWORD PTR tv251[rsp]
  003e8	89 44 24 7c	 mov	 DWORD PTR tv252[rsp], eax
  003ec	eb 5e		 jmp	 SHORT $LN69@s390_instf
$LN68@s390_instf:
  003ee	b8 08 00 00 00	 mov	 eax, 8
  003f3	48 6b c0 0b	 imul	 rax, rax, 11
  003f7	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  003ff	8b 84 01 00 06
	00 00		 mov	 eax, DWORD PTR [rcx+rax+1536]
  00406	0f ba f0 1f	 btr	 eax, 31
  0040a	39 44 24 30	 cmp	 DWORD PTR addr$[rsp], eax
  0040e	73 2c		 jae	 SHORT $LN65@s390_instf
  00410	b8 08 00 00 00	 mov	 eax, 8
  00415	48 6b c0 0c	 imul	 rax, rax, 12
  00419	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00421	8b 84 01 00 06
	00 00		 mov	 eax, DWORD PTR [rcx+rax+1536]
  00428	0f ba f0 1f	 btr	 eax, 31
  0042c	39 44 24 30	 cmp	 DWORD PTR addr$[rsp], eax
  00430	76 0a		 jbe	 SHORT $LN65@s390_instf
  00432	c7 44 24 78 00
	00 00 00	 mov	 DWORD PTR tv250[rsp], 0
  0043a	eb 08		 jmp	 SHORT $LN66@s390_instf
$LN65@s390_instf:
  0043c	c7 44 24 78 01
	00 00 00	 mov	 DWORD PTR tv250[rsp], 1
$LN66@s390_instf:
  00444	8b 44 24 78	 mov	 eax, DWORD PTR tv250[rsp]
  00448	89 44 24 7c	 mov	 DWORD PTR tv252[rsp], eax
$LN69@s390_instf:
  0044c	83 7c 24 7c 00	 cmp	 DWORD PTR tv252[rsp], 0
  00451	74 20		 je	 SHORT $LN20@s390_instf
$LN7@s390_instf:

; 828  :         )
; 829  :         {
; 830  :             ON_IC_PER_IF( regs );

  00453	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0045b	8b 40 4c	 mov	 eax, DWORD PTR [rax+76]
  0045e	0f ba e8 16	 bts	 eax, 22
  00462	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0046a	89 41 4c	 mov	 DWORD PTR [rcx+76], eax
  0046d	33 c0		 xor	 eax, eax
  0046f	85 c0		 test	 eax, eax
  00471	75 e0		 jne	 SHORT $LN7@s390_instf
$LN20@s390_instf:

; 831  : 
; 832  : #if defined( FEATURE_PER3 )
; 833  :             /* If CR9_IFNUL (PER instruction-fetching nullification) is
; 834  :                set, take a program check immediately, without executing
; 835  :                the instruction or updating the PSW instruction address */
; 836  :             if (EN_IC_PER_IFNUL( regs ))
; 837  :             {
; 838  :                 ON_IC_PER_IFNUL( regs );
; 839  :                 regs->psw.IA = addr;
; 840  :                 regs->psw.zeroilc = 1;
; 841  :                 regs->program_interrupt( regs, PGM_PER_EVENT );
; 842  :             }
; 843  : #endif /* defined( FEATURE_PER3 ) */
; 844  :         }
; 845  : 
; 846  :         /* Quick exit if AIA is still valid */
; 847  :         if (1
; 848  :             && !exec
; 849  :             && !regs->breakortrace
; 850  :             &&  VALID_AIE( regs )
; 851  :             &&  regs->ip < (regs->aip + pagesz - 5)

  00473	33 c0		 xor	 eax, eax
  00475	83 f8 01	 cmp	 eax, 1
  00478	0f 84 f3 00 00
	00		 je	 $LN21@s390_instf
  0047e	83 bc 24 b8 00
	00 00 00	 cmp	 DWORD PTR exec$[rsp], 0
  00486	0f 85 e5 00 00
	00		 jne	 $LN21@s390_instf
  0048c	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00494	8b 80 28 07 00
	00		 mov	 eax, DWORD PTR [rax+1832]
  0049a	c1 e8 10	 shr	 eax, 16
  0049d	83 e0 01	 and	 eax, 1
  004a0	85 c0		 test	 eax, eax
  004a2	0f 85 c9 00 00
	00		 jne	 $LN21@s390_instf
  004a8	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  004b0	48 83 b8 08 02
	00 00 00	 cmp	 QWORD PTR [rax+520], 0
  004b8	0f 84 b3 00 00
	00		 je	 $LN21@s390_instf
  004be	48 63 44 24 34	 movsxd	 rax, DWORD PTR pagesz$[rsp]
  004c3	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  004cb	48 8b 89 00 02
	00 00		 mov	 rcx, QWORD PTR [rcx+512]
  004d2	48 8d 44 01 fb	 lea	 rax, QWORD PTR [rcx+rax-5]
  004d7	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  004df	48 39 41 68	 cmp	 QWORD PTR [rcx+104], rax
  004e3	0f 83 88 00 00
	00		 jae	 $LN21@s390_instf

; 852  :         )
; 853  :         {
; 854  : #if defined( FEATURE_073_TRANSACT_EXEC_FACILITY )
; 855  : 
; 856  :             /* Update CONSTRAINED trans instruction fetch constraint */
; 857  :             if (regs->txf_contran)
; 858  :             {
; 859  :                 if (regs->AIV == regs->txf_aie_aiv2)
; 860  :                     regs->txf_aie = regs->aip + regs->txf_aie_off2;
; 861  :             }
; 862  : 
; 863  :             TXF_INSTRADDR_CONSTRAINT( regs );
; 864  : 
; 865  : #endif /* defined( FEATURE_073_TRANSACT_EXEC_FACILITY ) */
; 866  : 
; 867  :             /* Save the address of the instruction ABOUT to be executed */
; 868  :             regs->periaddr = PSW_IA_FROM_IP( regs, 0 );

  004e9	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  004f1	8b 80 10 02 00
	00		 mov	 eax, DWORD PTR [rax+528]
  004f7	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  004ff	48 8b 94 24 b0
	00 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  00507	48 8b 92 00 02
	00 00		 mov	 rdx, QWORD PTR [rdx+512]
  0050e	48 8b 49 68	 mov	 rcx, QWORD PTR [rcx+104]
  00512	48 2b ca	 sub	 rcx, rdx
  00515	48 03 c1	 add	 rax, rcx
  00518	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00520	8b 89 90 00 00
	00		 mov	 ecx, DWORD PTR [rcx+144]
  00526	48 23 c1	 and	 rax, rcx
  00529	8b c0		 mov	 eax, eax
  0052b	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00533	48 89 81 e8 08
	00 00		 mov	 QWORD PTR [rcx+2280], rax

; 869  : 
; 870  :             /* Suppress PER instruction fetch event if appropriate */
; 871  :             if (IS_PER_SUPRESS( regs, CR9_IF ))

  0053a	33 c0		 xor	 eax, eax
  0053c	85 c0		 test	 eax, eax
  0053e	74 20		 je	 SHORT $LN22@s390_instf
$LN10@s390_instf:

; 872  :                 OFF_IC_PER_IF( regs );

  00540	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00548	8b 40 4c	 mov	 eax, DWORD PTR [rax+76]
  0054b	0f ba f0 16	 btr	 eax, 22
  0054f	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00557	89 41 4c	 mov	 DWORD PTR [rcx+76], eax
  0055a	33 c0		 xor	 eax, eax
  0055c	85 c0		 test	 eax, eax
  0055e	75 e0		 jne	 SHORT $LN10@s390_instf
$LN22@s390_instf:

; 873  : 
; 874  :             /* Return to caller to execute this instruction */
; 875  :             return regs->ip;

  00560	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00568	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  0056c	e9 4f 03 00 00	 jmp	 $LN1@s390_instf
$LN21@s390_instf:
$LN18@s390_instf:

; 876  :         }
; 877  :     }
; 878  : #endif /* defined( FEATURE_PER ) */
; 879  : 
; 880  :     /* Set instinvalid in case of addressing or translation exception */
; 881  :     if (!exec)

  00571	83 bc 24 b8 00
	00 00 00	 cmp	 DWORD PTR exec$[rsp], 0
  00579	75 1f		 jne	 SHORT $LN23@s390_instf

; 882  :         regs->instinvalid = 1;

  0057b	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00583	8b 80 28 07 00
	00		 mov	 eax, DWORD PTR [rax+1832]
  00589	83 c8 08	 or	 eax, 8
  0058c	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00594	89 81 28 07 00
	00		 mov	 DWORD PTR [rcx+1832], eax
$LN23@s390_instf:

; 883  : 
; 884  :     /* Get instruction address */
; 885  :     ip = MADDRL( addr, 6, USE_INST_SPACE, regs, ACCTYPE_INSTFETCH, regs->psw.pkey );

  0059a	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  005a2	0f b6 40 79	 movzx	 eax, BYTE PTR [rax+121]
  005a6	88 44 24 28	 mov	 BYTE PTR [rsp+40], al
  005aa	c7 44 24 20 04
	00 00 00	 mov	 DWORD PTR [rsp+32], 4
  005b2	4c 8b 8c 24 b0
	00 00 00	 mov	 r9, QWORD PTR regs$[rsp]
  005ba	41 b8 ff ff ff
	ff		 mov	 r8d, -1
  005c0	ba 06 00 00 00	 mov	 edx, 6
  005c5	8b 4c 24 30	 mov	 ecx, DWORD PTR addr$[rsp]
  005c9	e8 00 00 00 00	 call	 s390_maddr_l
  005ce	48 89 44 24 38	 mov	 QWORD PTR ip$[rsp], rax

; 886  : 
; 887  :     /* If boundary is crossed then copy instruction to destination */
; 888  :     if (offset + ILC( ip[0] ) > pagesz)

  005d3	b8 01 00 00 00	 mov	 eax, 1
  005d8	48 6b c0 00	 imul	 rax, rax, 0
  005dc	48 8b 4c 24 38	 mov	 rcx, QWORD PTR ip$[rsp]
  005e1	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  005e5	83 f8 40	 cmp	 eax, 64			; 00000040H
  005e8	7d 0d		 jge	 SHORT $LN72@s390_instf
  005ea	c7 84 24 84 00
	00 00 02 00 00
	00		 mov	 DWORD PTR tv311[rsp], 2
  005f5	eb 3f		 jmp	 SHORT $LN73@s390_instf
$LN72@s390_instf:
  005f7	b8 01 00 00 00	 mov	 eax, 1
  005fc	48 6b c0 00	 imul	 rax, rax, 0
  00600	48 8b 4c 24 38	 mov	 rcx, QWORD PTR ip$[rsp]
  00605	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00609	3d c0 00 00 00	 cmp	 eax, 192		; 000000c0H
  0060e	7d 0d		 jge	 SHORT $LN70@s390_instf
  00610	c7 84 24 80 00
	00 00 04 00 00
	00		 mov	 DWORD PTR tv310[rsp], 4
  0061b	eb 0b		 jmp	 SHORT $LN71@s390_instf
$LN70@s390_instf:
  0061d	c7 84 24 80 00
	00 00 06 00 00
	00		 mov	 DWORD PTR tv310[rsp], 6
$LN71@s390_instf:
  00628	8b 84 24 80 00
	00 00		 mov	 eax, DWORD PTR tv310[rsp]
  0062f	89 84 24 84 00
	00 00		 mov	 DWORD PTR tv311[rsp], eax
$LN73@s390_instf:
  00636	8b 84 24 84 00
	00 00		 mov	 eax, DWORD PTR tv311[rsp]
  0063d	8b 4c 24 40	 mov	 ecx, DWORD PTR offset$[rsp]
  00641	03 c8		 add	 ecx, eax
  00643	8b c1		 mov	 eax, ecx
  00645	3b 44 24 34	 cmp	 eax, DWORD PTR pagesz$[rsp]
  00649	0f 8e ff 00 00
	00		 jle	 $LN24@s390_instf

; 889  :     {
; 890  :         /* Copy first part of instruction (note: dest is 8 bytes) */
; 891  :         dest = exec ? regs->exinst : regs->inst;

  0064f	83 bc 24 b8 00
	00 00 00	 cmp	 DWORD PTR exec$[rsp], 0
  00657	74 18		 je	 SHORT $LN74@s390_instf
  00659	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00661	48 05 40 08 00
	00		 add	 rax, 2112		; 00000840H
  00667	48 89 84 24 90
	00 00 00	 mov	 QWORD PTR tv317[rsp], rax
  0066f	eb 16		 jmp	 SHORT $LN75@s390_instf
$LN74@s390_instf:
  00671	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00679	48 05 f1 08 00
	00		 add	 rax, 2289		; 000008f1H
  0067f	48 89 84 24 90
	00 00 00	 mov	 QWORD PTR tv317[rsp], rax
$LN75@s390_instf:
  00687	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR tv317[rsp]
  0068f	48 89 84 24 88
	00 00 00	 mov	 QWORD PTR dest$[rsp], rax

; 892  :         memcpy( dest, ip, 4 );

  00697	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR dest$[rsp]
  0069f	48 8b 4c 24 38	 mov	 rcx, QWORD PTR ip$[rsp]
  006a4	8b 09		 mov	 ecx, DWORD PTR [rcx]
  006a6	89 08		 mov	 DWORD PTR [rax], ecx

; 893  : 
; 894  :         /* Copy second part of instruction */
; 895  :         len = pagesz - offset;

  006a8	8b 44 24 40	 mov	 eax, DWORD PTR offset$[rsp]
  006ac	8b 4c 24 34	 mov	 ecx, DWORD PTR pagesz$[rsp]
  006b0	2b c8		 sub	 ecx, eax
  006b2	8b c1		 mov	 eax, ecx
  006b4	89 44 24 44	 mov	 DWORD PTR len$[rsp], eax

; 896  :         addr = (addr + len) & ADDRESS_MAXWRAP( regs );

  006b8	8b 44 24 44	 mov	 eax, DWORD PTR len$[rsp]
  006bc	8b 4c 24 30	 mov	 ecx, DWORD PTR addr$[rsp]
  006c0	03 c8		 add	 ecx, eax
  006c2	8b c1		 mov	 eax, ecx
  006c4	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  006cc	23 81 90 00 00
	00		 and	 eax, DWORD PTR [rcx+144]
  006d2	89 44 24 30	 mov	 DWORD PTR addr$[rsp], eax

; 897  :         ip = MADDR( addr, USE_INST_SPACE, regs, ACCTYPE_INSTFETCH, regs->psw.pkey );

  006d6	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  006de	0f b6 40 79	 movzx	 eax, BYTE PTR [rax+121]
  006e2	88 44 24 28	 mov	 BYTE PTR [rsp+40], al
  006e6	c7 44 24 20 04
	00 00 00	 mov	 DWORD PTR [rsp+32], 4
  006ee	4c 8b 8c 24 b0
	00 00 00	 mov	 r9, QWORD PTR regs$[rsp]
  006f6	41 b8 ff ff ff
	ff		 mov	 r8d, -1
  006fc	ba 01 00 00 00	 mov	 edx, 1
  00701	8b 4c 24 30	 mov	 ecx, DWORD PTR addr$[rsp]
  00705	e8 00 00 00 00	 call	 s390_maddr_l
  0070a	48 89 44 24 38	 mov	 QWORD PTR ip$[rsp], rax

; 898  :         if (!exec)

  0070f	83 bc 24 b8 00
	00 00 00	 cmp	 DWORD PTR exec$[rsp], 0
  00717	75 1c		 jne	 SHORT $LN26@s390_instf

; 899  :             regs->ip = ip - len;

  00719	48 63 44 24 44	 movsxd	 rax, DWORD PTR len$[rsp]
  0071e	48 8b 4c 24 38	 mov	 rcx, QWORD PTR ip$[rsp]
  00723	48 2b c8	 sub	 rcx, rax
  00726	48 8b c1	 mov	 rax, rcx
  00729	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00731	48 89 41 68	 mov	 QWORD PTR [rcx+104], rax
$LN26@s390_instf:

; 900  :         memcpy( dest + len, ip, 4 );

  00735	48 63 44 24 44	 movsxd	 rax, DWORD PTR len$[rsp]
  0073a	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR dest$[rsp]
  00742	48 8b 54 24 38	 mov	 rdx, QWORD PTR ip$[rsp]
  00747	8b 12		 mov	 edx, DWORD PTR [rdx]
  00749	89 14 01	 mov	 DWORD PTR [rcx+rax], edx

; 901  :     }

  0074c	eb 28		 jmp	 SHORT $LN25@s390_instf
$LN24@s390_instf:

; 902  :     else /* boundary NOT crossed */
; 903  :     {
; 904  :         dest = ip;

  0074e	48 8b 44 24 38	 mov	 rax, QWORD PTR ip$[rsp]
  00753	48 89 84 24 88
	00 00 00	 mov	 QWORD PTR dest$[rsp], rax

; 905  : 
; 906  :         if (!exec)

  0075b	83 bc 24 b8 00
	00 00 00	 cmp	 DWORD PTR exec$[rsp], 0
  00763	75 11		 jne	 SHORT $LN27@s390_instf

; 907  :             regs->ip = ip;

  00765	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0076d	48 8b 4c 24 38	 mov	 rcx, QWORD PTR ip$[rsp]
  00772	48 89 48 68	 mov	 QWORD PTR [rax+104], rcx
$LN27@s390_instf:
$LN25@s390_instf:

; 908  :     }
; 909  : 
; 910  :     if (!exec)

  00776	83 bc 24 b8 00
	00 00 00	 cmp	 DWORD PTR exec$[rsp], 0
  0077e	0f 85 bd 00 00
	00		 jne	 $LN28@s390_instf

; 911  :     {
; 912  :         /* Instr addr now known to be valid so reset instinvalid flag */
; 913  :         regs->instinvalid = 0;

  00784	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0078c	8b 80 28 07 00
	00		 mov	 eax, DWORD PTR [rax+1832]
  00792	83 e0 f7	 and	 eax, -9			; fffffff7H
  00795	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0079d	89 81 28 07 00
	00		 mov	 DWORD PTR [rcx+1832], eax

; 914  : 
; 915  :         /* Update the AIA values */
; 916  :         regs->AIV = addr & PAGEFRAME_PAGEMASK;

  007a3	8b 44 24 30	 mov	 eax, DWORD PTR addr$[rsp]
  007a7	25 00 f0 ff 7f	 and	 eax, 2147479552		; 7ffff000H
  007ac	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  007b4	89 81 10 02 00
	00		 mov	 DWORD PTR [rcx+528], eax

; 917  :         regs->aip = (BYTE*)((uintptr_t)ip & ~PAGEFRAME_BYTEMASK);

  007ba	48 8b 44 24 38	 mov	 rax, QWORD PTR ip$[rsp]
  007bf	48 25 00 f0 ff
	ff		 and	 rax, -4096		; fffffffffffff000H
  007c5	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  007cd	48 89 81 00 02
	00 00		 mov	 QWORD PTR [rcx+512], rax

; 918  : 
; 919  :         /* If tracing, stepping or PER is still active,
; 920  :            force another instfetch after this instruction.
; 921  :         */
; 922  :         if (regs->breakortrace || regs->permode)

  007d4	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  007dc	8b 80 28 07 00
	00		 mov	 eax, DWORD PTR [rax+1832]
  007e2	c1 e8 10	 shr	 eax, 16
  007e5	83 e0 01	 and	 eax, 1
  007e8	85 c0		 test	 eax, eax
  007ea	75 18		 jne	 SHORT $LN31@s390_instf
  007ec	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  007f4	8b 80 28 07 00
	00		 mov	 eax, DWORD PTR [rax+1832]
  007fa	c1 e8 02	 shr	 eax, 2
  007fd	83 e0 01	 and	 eax, 1
  00800	85 c0		 test	 eax, eax
  00802	74 15		 je	 SHORT $LN29@s390_instf
$LN31@s390_instf:

; 923  :         {
; 924  :             /* Force instfetch to be called again on next inst. */
; 925  :             regs->aie = PSEUDO_INVALID_AIE;

  00804	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0080c	48 c7 80 08 02
	00 00 01 00 00
	00		 mov	 QWORD PTR [rax+520], 1

; 926  :         }

  00817	eb 28		 jmp	 SHORT $LN30@s390_instf
$LN29@s390_instf:

; 927  :         else /* (stepping/tracing/PER is NOT active) */
; 928  :         {
; 929  :             /* Call instfetch again ONLY when truly needed */
; 930  :             regs->aie = regs->aip + pagesz - 5;

  00819	48 63 44 24 34	 movsxd	 rax, DWORD PTR pagesz$[rsp]
  0081e	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00826	48 8b 89 00 02
	00 00		 mov	 rcx, QWORD PTR [rcx+512]
  0082d	48 8d 44 01 fb	 lea	 rax, QWORD PTR [rcx+rax-5]
  00832	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0083a	48 89 81 08 02
	00 00		 mov	 QWORD PTR [rcx+520], rax
$LN30@s390_instf:
$LN28@s390_instf:

; 931  :         }
; 932  :     }
; 933  : 
; 934  : #if defined( FEATURE_073_TRANSACT_EXEC_FACILITY )
; 935  : 
; 936  :     /* Update CONSTRAINED trans instruction fetch constraint */
; 937  :     if (regs->txf_contran)
; 938  :     {
; 939  :         if (regs->AIV == regs->txf_aie_aiv2)
; 940  :             regs->txf_aie = regs->aip + regs->txf_aie_off2;
; 941  :     }
; 942  : 
; 943  :     TXF_INSTRADDR_CONSTRAINT( regs );
; 944  : 
; 945  : #endif /* defined( FEATURE_073_TRANSACT_EXEC_FACILITY ) */
; 946  : 
; 947  :     /* Save the address of the instruction ABOUT to be executed */
; 948  :     regs->periaddr = PSW_IA_FROM_IP( regs, 0 );

  00841	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00849	8b 80 10 02 00
	00		 mov	 eax, DWORD PTR [rax+528]
  0084f	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00857	48 8b 94 24 b0
	00 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  0085f	48 8b 92 00 02
	00 00		 mov	 rdx, QWORD PTR [rdx+512]
  00866	48 8b 49 68	 mov	 rcx, QWORD PTR [rcx+104]
  0086a	48 2b ca	 sub	 rcx, rdx
  0086d	48 03 c1	 add	 rax, rcx
  00870	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00878	8b 89 90 00 00
	00		 mov	 ecx, DWORD PTR [rcx+144]
  0087e	48 23 c1	 and	 rax, rcx
  00881	8b c0		 mov	 eax, eax
  00883	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0088b	48 89 81 e8 08
	00 00		 mov	 QWORD PTR [rcx+2280], rax

; 949  : 
; 950  :     /* Suppress PER instruction fetch event if appropriate */
; 951  :     if (IS_PER_SUPRESS( regs, CR9_IF ))

  00892	33 c0		 xor	 eax, eax
  00894	85 c0		 test	 eax, eax
  00896	74 20		 je	 SHORT $LN32@s390_instf
$LN13@s390_instf:

; 952  :         OFF_IC_PER_IF( regs );

  00898	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  008a0	8b 40 4c	 mov	 eax, DWORD PTR [rax+76]
  008a3	0f ba f0 16	 btr	 eax, 22
  008a7	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  008af	89 41 4c	 mov	 DWORD PTR [rcx+76], eax
  008b2	33 c0		 xor	 eax, eax
  008b4	85 c0		 test	 eax, eax
  008b6	75 e0		 jne	 SHORT $LN13@s390_instf
$LN32@s390_instf:

; 953  : 
; 954  :     /* Return to caller to execute this instruction */
; 955  :     return dest;

  008b8	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR dest$[rsp]
$LN1@s390_instf:

; 956  : 
; 957  : } /* end function ARCH_DEP( instfetch ) */

  008c0	48 81 c4 a8 00
	00 00		 add	 rsp, 168		; 000000a8H
  008c7	c3		 ret	 0
s390_instfetch ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\vstore.h
;	COMDAT s390_vfetchc
_TEXT	SEGMENT
len2$ = 48
tv74 = 52
main1$ = 56
main2$ = 64
dest$ = 112
len$ = 120
addr$ = 128
arn$ = 136
regs$ = 144
s390_vfetchc PROC					; COMDAT

; 631  : {

$LN9:
  00000	44 89 4c 24 20	 mov	 DWORD PTR [rsp+32], r9d
  00005	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  0000a	88 54 24 10	 mov	 BYTE PTR [rsp+16], dl
  0000e	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00013	56		 push	 rsi
  00014	57		 push	 rdi
  00015	48 83 ec 58	 sub	 rsp, 88			; 00000058H

; 632  : BYTE   *main1, *main2;                  /* Main storage addresses    */
; 633  : int     len2;                           /* Length to copy on page    */
; 634  : 
; 635  :     if (NOCROSSPAGE( addr, len ))

  00019	8b 84 24 80 00
	00 00		 mov	 eax, DWORD PTR addr$[rsp]
  00020	25 ff 0f 00 00	 and	 eax, 4095		; 00000fffH
  00025	0f b6 4c 24 78	 movzx	 ecx, BYTE PTR len$[rsp]
  0002a	ba ff 0f 00 00	 mov	 edx, 4095		; 00000fffH
  0002f	2b d1		 sub	 edx, ecx
  00031	8b ca		 mov	 ecx, edx
  00033	3b c1		 cmp	 eax, ecx
  00035	7f 0a		 jg	 SHORT $LN7@s390_vfetc
  00037	c7 44 24 34 01
	00 00 00	 mov	 DWORD PTR tv74[rsp], 1
  0003f	eb 08		 jmp	 SHORT $LN8@s390_vfetc
$LN7@s390_vfetc:
  00041	c7 44 24 34 00
	00 00 00	 mov	 DWORD PTR tv74[rsp], 0
$LN8@s390_vfetc:
  00049	83 7c 24 34 00	 cmp	 DWORD PTR tv74[rsp], 0
  0004e	74 62		 je	 SHORT $LN2@s390_vfetc

; 636  :     {
; 637  :         ITIMER_SYNC( addr, len, regs );
; 638  :         main1 = MADDRL( addr, len + 1, arn, regs, ACCTYPE_READ, regs->psw.pkey );

  00050	0f b6 44 24 78	 movzx	 eax, BYTE PTR len$[rsp]
  00055	ff c0		 inc	 eax
  00057	48 98		 cdqe
  00059	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00061	0f b6 49 79	 movzx	 ecx, BYTE PTR [rcx+121]
  00065	88 4c 24 28	 mov	 BYTE PTR [rsp+40], cl
  00069	c7 44 24 20 04
	00 00 00	 mov	 DWORD PTR [rsp+32], 4
  00071	4c 8b 8c 24 90
	00 00 00	 mov	 r9, QWORD PTR regs$[rsp]
  00079	44 8b 84 24 88
	00 00 00	 mov	 r8d, DWORD PTR arn$[rsp]
  00081	48 8b d0	 mov	 rdx, rax
  00084	8b 8c 24 80 00
	00 00		 mov	 ecx, DWORD PTR addr$[rsp]
  0008b	e8 00 00 00 00	 call	 s390_maddr_l
  00090	48 89 44 24 38	 mov	 QWORD PTR main1$[rsp], rax

; 639  :         memcpy( dest, main1, len + 1 );

  00095	0f b6 44 24 78	 movzx	 eax, BYTE PTR len$[rsp]
  0009a	ff c0		 inc	 eax
  0009c	48 98		 cdqe
  0009e	48 8b 7c 24 70	 mov	 rdi, QWORD PTR dest$[rsp]
  000a3	48 8b 74 24 38	 mov	 rsi, QWORD PTR main1$[rsp]
  000a8	48 8b c8	 mov	 rcx, rax
  000ab	f3 a4		 rep movsb

; 640  :     }

  000ad	e9 f7 00 00 00	 jmp	 $LN3@s390_vfetc
$LN2@s390_vfetc:

; 641  :     else
; 642  :     {
; 643  :         len2 = PAGEFRAME_PAGESIZE - (addr & PAGEFRAME_BYTEMASK);

  000b2	8b 84 24 80 00
	00 00		 mov	 eax, DWORD PTR addr$[rsp]
  000b9	25 ff 0f 00 00	 and	 eax, 4095		; 00000fffH
  000be	b9 00 10 00 00	 mov	 ecx, 4096		; 00001000H
  000c3	2b c8		 sub	 ecx, eax
  000c5	8b c1		 mov	 eax, ecx
  000c7	89 44 24 30	 mov	 DWORD PTR len2$[rsp], eax

; 644  :         main1 = MADDRL( addr, len2, arn, regs, ACCTYPE_READ, regs->psw.pkey );

  000cb	48 63 44 24 30	 movsxd	 rax, DWORD PTR len2$[rsp]
  000d0	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  000d8	0f b6 49 79	 movzx	 ecx, BYTE PTR [rcx+121]
  000dc	88 4c 24 28	 mov	 BYTE PTR [rsp+40], cl
  000e0	c7 44 24 20 04
	00 00 00	 mov	 DWORD PTR [rsp+32], 4
  000e8	4c 8b 8c 24 90
	00 00 00	 mov	 r9, QWORD PTR regs$[rsp]
  000f0	44 8b 84 24 88
	00 00 00	 mov	 r8d, DWORD PTR arn$[rsp]
  000f8	48 8b d0	 mov	 rdx, rax
  000fb	8b 8c 24 80 00
	00 00		 mov	 ecx, DWORD PTR addr$[rsp]
  00102	e8 00 00 00 00	 call	 s390_maddr_l
  00107	48 89 44 24 38	 mov	 QWORD PTR main1$[rsp], rax

; 645  :         main2 = MADDRL( (addr + len2) & ADDRESS_MAXWRAP( regs ), len + 1 - len2,

  0010c	0f b6 44 24 78	 movzx	 eax, BYTE PTR len$[rsp]
  00111	ff c0		 inc	 eax
  00113	2b 44 24 30	 sub	 eax, DWORD PTR len2$[rsp]
  00117	48 98		 cdqe
  00119	8b 4c 24 30	 mov	 ecx, DWORD PTR len2$[rsp]
  0011d	8b 94 24 80 00
	00 00		 mov	 edx, DWORD PTR addr$[rsp]
  00124	03 d1		 add	 edx, ecx
  00126	8b ca		 mov	 ecx, edx
  00128	48 8b 94 24 90
	00 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  00130	23 8a 90 00 00
	00		 and	 ecx, DWORD PTR [rdx+144]
  00136	48 8b 94 24 90
	00 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  0013e	0f b6 52 79	 movzx	 edx, BYTE PTR [rdx+121]
  00142	88 54 24 28	 mov	 BYTE PTR [rsp+40], dl
  00146	c7 44 24 20 04
	00 00 00	 mov	 DWORD PTR [rsp+32], 4
  0014e	4c 8b 8c 24 90
	00 00 00	 mov	 r9, QWORD PTR regs$[rsp]
  00156	44 8b 84 24 88
	00 00 00	 mov	 r8d, DWORD PTR arn$[rsp]
  0015e	48 8b d0	 mov	 rdx, rax
  00161	e8 00 00 00 00	 call	 s390_maddr_l
  00166	48 89 44 24 40	 mov	 QWORD PTR main2$[rsp], rax

; 646  :                         arn, regs, ACCTYPE_READ, regs->psw.pkey );
; 647  :         memcpy(        dest,        main1,           len2 );

  0016b	48 63 44 24 30	 movsxd	 rax, DWORD PTR len2$[rsp]
  00170	48 8b 7c 24 70	 mov	 rdi, QWORD PTR dest$[rsp]
  00175	48 8b 74 24 38	 mov	 rsi, QWORD PTR main1$[rsp]
  0017a	48 8b c8	 mov	 rcx, rax
  0017d	f3 a4		 rep movsb

; 648  :         memcpy( (BYTE*)dest + len2, main2, len + 1 - len2 );

  0017f	0f b6 44 24 78	 movzx	 eax, BYTE PTR len$[rsp]
  00184	ff c0		 inc	 eax
  00186	2b 44 24 30	 sub	 eax, DWORD PTR len2$[rsp]
  0018a	48 98		 cdqe
  0018c	48 63 4c 24 30	 movsxd	 rcx, DWORD PTR len2$[rsp]
  00191	48 8b 54 24 70	 mov	 rdx, QWORD PTR dest$[rsp]
  00196	48 03 d1	 add	 rdx, rcx
  00199	48 8b ca	 mov	 rcx, rdx
  0019c	48 8b f9	 mov	 rdi, rcx
  0019f	48 8b 74 24 40	 mov	 rsi, QWORD PTR main2$[rsp]
  001a4	48 8b c8	 mov	 rcx, rax
  001a7	f3 a4		 rep movsb
$LN3@s390_vfetc:

; 649  :     }
; 650  : }

  001a9	48 83 c4 58	 add	 rsp, 88			; 00000058H
  001ad	5f		 pop	 rdi
  001ae	5e		 pop	 rsi
  001af	c3		 ret	 0
s390_vfetchc ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\vstore.h
;	COMDAT s390_vstorec
_TEXT	SEGMENT
len2$ = 48
tv74 = 52
sk$ = 56
tv81 = 64
main1$ = 72
main2$ = 80
src$ = 128
len$ = 136
addr$ = 144
arn$ = 152
regs$ = 160
s390_vstorec PROC					; COMDAT

; 489  : {

$LN9:
  00000	44 89 4c 24 20	 mov	 DWORD PTR [rsp+32], r9d
  00005	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  0000a	88 54 24 10	 mov	 BYTE PTR [rsp+16], dl
  0000e	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00013	56		 push	 rsi
  00014	57		 push	 rdi
  00015	48 83 ec 68	 sub	 rsp, 104		; 00000068H

; 490  : BYTE   *main1, *main2;                  /* Mainstor addresses        */
; 491  : BYTE   *sk;                             /* Storage key addresses     */
; 492  : int     len2;                           /* Length to end of page     */
; 493  : 
; 494  :     if (NOCROSSPAGE( addr,len ))

  00019	8b 84 24 90 00
	00 00		 mov	 eax, DWORD PTR addr$[rsp]
  00020	25 ff 0f 00 00	 and	 eax, 4095		; 00000fffH
  00025	0f b6 8c 24 88
	00 00 00	 movzx	 ecx, BYTE PTR len$[rsp]
  0002d	ba ff 0f 00 00	 mov	 edx, 4095		; 00000fffH
  00032	2b d1		 sub	 edx, ecx
  00034	8b ca		 mov	 ecx, edx
  00036	3b c1		 cmp	 eax, ecx
  00038	7f 0a		 jg	 SHORT $LN7@s390_vstor
  0003a	c7 44 24 34 01
	00 00 00	 mov	 DWORD PTR tv74[rsp], 1
  00042	eb 08		 jmp	 SHORT $LN8@s390_vstor
$LN7@s390_vstor:
  00044	c7 44 24 34 00
	00 00 00	 mov	 DWORD PTR tv74[rsp], 0
$LN8@s390_vstor:
  0004c	83 7c 24 34 00	 cmp	 DWORD PTR tv74[rsp], 0
  00051	74 6f		 je	 SHORT $LN2@s390_vstor

; 495  :     {
; 496  :         memcpy( MADDRL( addr, len+1, arn, regs, ACCTYPE_WRITE, regs->psw.pkey ),

  00053	0f b6 84 24 88
	00 00 00	 movzx	 eax, BYTE PTR len$[rsp]
  0005b	ff c0		 inc	 eax
  0005d	48 98		 cdqe
  0005f	48 89 44 24 40	 mov	 QWORD PTR tv81[rsp], rax
  00064	0f b6 8c 24 88
	00 00 00	 movzx	 ecx, BYTE PTR len$[rsp]
  0006c	ff c1		 inc	 ecx
  0006e	48 63 c9	 movsxd	 rcx, ecx
  00071	48 8b 94 24 a0
	00 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  00079	0f b6 52 79	 movzx	 edx, BYTE PTR [rdx+121]
  0007d	88 54 24 28	 mov	 BYTE PTR [rsp+40], dl
  00081	c7 44 24 20 02
	00 00 00	 mov	 DWORD PTR [rsp+32], 2
  00089	4c 8b 8c 24 a0
	00 00 00	 mov	 r9, QWORD PTR regs$[rsp]
  00091	44 8b 84 24 98
	00 00 00	 mov	 r8d, DWORD PTR arn$[rsp]
  00099	48 8b d1	 mov	 rdx, rcx
  0009c	8b 8c 24 90 00
	00 00		 mov	 ecx, DWORD PTR addr$[rsp]
  000a3	e8 00 00 00 00	 call	 s390_maddr_l
  000a8	48 8b f8	 mov	 rdi, rax
  000ab	48 8b b4 24 80
	00 00 00	 mov	 rsi, QWORD PTR src$[rsp]
  000b3	48 8b 44 24 40	 mov	 rax, QWORD PTR tv81[rsp]
  000b8	48 8b c8	 mov	 rcx, rax
  000bb	f3 a4		 rep movsb

; 497  :                src, len + 1);
; 498  :         ITIMER_UPDATE( addr, len, regs );
; 499  :     }

  000bd	e9 29 01 00 00	 jmp	 $LN3@s390_vstor
$LN2@s390_vstor:

; 500  :     else
; 501  :     {
; 502  :         len2 = PAGEFRAME_PAGESIZE - (addr & PAGEFRAME_BYTEMASK);

  000c2	8b 84 24 90 00
	00 00		 mov	 eax, DWORD PTR addr$[rsp]
  000c9	25 ff 0f 00 00	 and	 eax, 4095		; 00000fffH
  000ce	b9 00 10 00 00	 mov	 ecx, 4096		; 00001000H
  000d3	2b c8		 sub	 ecx, eax
  000d5	8b c1		 mov	 eax, ecx
  000d7	89 44 24 30	 mov	 DWORD PTR len2$[rsp], eax

; 503  :         main1 = MADDRL( addr, len2, arn, regs, ACCTYPE_WRITE_SKP,

  000db	48 63 44 24 30	 movsxd	 rax, DWORD PTR len2$[rsp]
  000e0	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  000e8	0f b6 49 79	 movzx	 ecx, BYTE PTR [rcx+121]
  000ec	88 4c 24 28	 mov	 BYTE PTR [rsp+40], cl
  000f0	c7 44 24 20 01
	00 00 00	 mov	 DWORD PTR [rsp+32], 1
  000f8	4c 8b 8c 24 a0
	00 00 00	 mov	 r9, QWORD PTR regs$[rsp]
  00100	44 8b 84 24 98
	00 00 00	 mov	 r8d, DWORD PTR arn$[rsp]
  00108	48 8b d0	 mov	 rdx, rax
  0010b	8b 8c 24 90 00
	00 00		 mov	 ecx, DWORD PTR addr$[rsp]
  00112	e8 00 00 00 00	 call	 s390_maddr_l
  00117	48 89 44 24 48	 mov	 QWORD PTR main1$[rsp], rax

; 504  :                         regs->psw.pkey );
; 505  :         sk = regs->dat.storkey;

  0011c	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00124	48 8b 80 28 08
	00 00		 mov	 rax, QWORD PTR [rax+2088]
  0012b	48 89 44 24 38	 mov	 QWORD PTR sk$[rsp], rax

; 506  :         main2 = MADDRL( (addr + len2) & ADDRESS_MAXWRAP( regs ),

  00130	0f b6 84 24 88
	00 00 00	 movzx	 eax, BYTE PTR len$[rsp]
  00138	ff c0		 inc	 eax
  0013a	2b 44 24 30	 sub	 eax, DWORD PTR len2$[rsp]
  0013e	48 98		 cdqe
  00140	8b 4c 24 30	 mov	 ecx, DWORD PTR len2$[rsp]
  00144	8b 94 24 90 00
	00 00		 mov	 edx, DWORD PTR addr$[rsp]
  0014b	03 d1		 add	 edx, ecx
  0014d	8b ca		 mov	 ecx, edx
  0014f	48 8b 94 24 a0
	00 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  00157	23 8a 90 00 00
	00		 and	 ecx, DWORD PTR [rdx+144]
  0015d	48 8b 94 24 a0
	00 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  00165	0f b6 52 79	 movzx	 edx, BYTE PTR [rdx+121]
  00169	88 54 24 28	 mov	 BYTE PTR [rsp+40], dl
  0016d	c7 44 24 20 02
	00 00 00	 mov	 DWORD PTR [rsp+32], 2
  00175	4c 8b 8c 24 a0
	00 00 00	 mov	 r9, QWORD PTR regs$[rsp]
  0017d	44 8b 84 24 98
	00 00 00	 mov	 r8d, DWORD PTR arn$[rsp]
  00185	48 8b d0	 mov	 rdx, rax
  00188	e8 00 00 00 00	 call	 s390_maddr_l
  0018d	48 89 44 24 50	 mov	 QWORD PTR main2$[rsp], rax

; 507  :                         len+1-len2, arn,
; 508  :                         regs, ACCTYPE_WRITE, regs->psw.pkey );
; 509  :         *sk |= (STORKEY_REF | STORKEY_CHANGE);

  00192	48 8b 44 24 38	 mov	 rax, QWORD PTR sk$[rsp]
  00197	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  0019a	83 c8 06	 or	 eax, 6
  0019d	48 8b 4c 24 38	 mov	 rcx, QWORD PTR sk$[rsp]
  001a2	88 01		 mov	 BYTE PTR [rcx], al

; 510  :         memcpy( main1, src, len2 );

  001a4	48 63 44 24 30	 movsxd	 rax, DWORD PTR len2$[rsp]
  001a9	48 8b 7c 24 48	 mov	 rdi, QWORD PTR main1$[rsp]
  001ae	48 8b b4 24 80
	00 00 00	 mov	 rsi, QWORD PTR src$[rsp]
  001b6	48 8b c8	 mov	 rcx, rax
  001b9	f3 a4		 rep movsb

; 511  :         memcpy( main2, (BYTE*)src + len2, len + 1 - len2 );

  001bb	0f b6 84 24 88
	00 00 00	 movzx	 eax, BYTE PTR len$[rsp]
  001c3	ff c0		 inc	 eax
  001c5	2b 44 24 30	 sub	 eax, DWORD PTR len2$[rsp]
  001c9	48 98		 cdqe
  001cb	48 63 4c 24 30	 movsxd	 rcx, DWORD PTR len2$[rsp]
  001d0	48 8b 94 24 80
	00 00 00	 mov	 rdx, QWORD PTR src$[rsp]
  001d8	48 03 d1	 add	 rdx, rcx
  001db	48 8b ca	 mov	 rcx, rdx
  001de	48 8b 7c 24 50	 mov	 rdi, QWORD PTR main2$[rsp]
  001e3	48 8b f1	 mov	 rsi, rcx
  001e6	48 8b c8	 mov	 rcx, rax
  001e9	f3 a4		 rep movsb
$LN3@s390_vstor:

; 512  :     }
; 513  : }

  001eb	48 83 c4 68	 add	 rsp, 104		; 00000068H
  001ef	5f		 pop	 rdi
  001f0	5e		 pop	 rsi
  001f1	c3		 ret	 0
s390_vstorec ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\dat.h
;	COMDAT s390_maddr_l
_TEXT	SEGMENT
tlbix$ = 48
aea_crn$ = 52
tv70 = 56
maddr$ = 64
addr$ = 96
len$ = 104
arn$ = 112
regs$ = 120
acctype$ = 128
akey$ = 136
s390_maddr_l PROC					; COMDAT

; 307  : {

$LN14:
  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	89 4c 24 08	 mov	 DWORD PTR [rsp+8], ecx
  00013	48 83 ec 58	 sub	 rsp, 88			; 00000058H

; 308  :     /* Note: ALL of the below conditions must be true for a TLB hit
; 309  :        to occur.  If ANY of them are false, then it's a TLB miss,
; 310  :        requiring us to then perform a full DAT address translation.
; 311  : 
; 312  :        Note too that on the grand scheme of things the order/sequence
; 313  :        of the below tests (if statements) is completely unimportant
; 314  :        since ALL conditions must be checked anyway in order for a hit
; 315  :        to occur, and it doesn't matter that a miss tests a few extra
; 316  :        conditions since it's going to do a full translation anyway!
; 317  :        (which is many, many instructions)
; 318  :     */
; 319  : 
; 320  :     int  aea_crn  = (arn >= USE_ARMODE) ? 0 : regs->AEA_AR( arn );

  00017	83 7c 24 70 10	 cmp	 DWORD PTR arn$[rsp], 16
  0001c	7c 0a		 jl	 SHORT $LN12@s390_maddr
  0001e	c7 44 24 38 00
	00 00 00	 mov	 DWORD PTR tv70[rsp], 0
  00026	eb 19		 jmp	 SHORT $LN13@s390_maddr
$LN12@s390_maddr:
  00028	8b 44 24 70	 mov	 eax, DWORD PTR arn$[rsp]
  0002c	83 c0 05	 add	 eax, 5
  0002f	48 98		 cdqe
  00031	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  00036	8b 84 81 94 0c
	00 00		 mov	 eax, DWORD PTR [rcx+rax*4+3220]
  0003d	89 44 24 38	 mov	 DWORD PTR tv70[rsp], eax
$LN13@s390_maddr:
  00041	8b 44 24 38	 mov	 eax, DWORD PTR tv70[rsp]
  00045	89 44 24 34	 mov	 DWORD PTR aea_crn$[rsp], eax

; 321  :     U16  tlbix    = TLBIX( addr );

  00049	8b 44 24 60	 mov	 eax, DWORD PTR addr$[rsp]
  0004d	c1 e8 0c	 shr	 eax, 12
  00050	25 ff 03 00 00	 and	 eax, 1023		; 000003ffH
  00055	66 89 44 24 30	 mov	 WORD PTR tlbix$[rsp], ax

; 322  :     BYTE *maddr   = NULL;

  0005a	48 c7 44 24 40
	00 00 00 00	 mov	 QWORD PTR maddr$[rsp], 0

; 323  : 
; 324  :     /* Non-zero AEA Control Register number? */
; 325  :     if (aea_crn)

  00063	83 7c 24 34 00	 cmp	 DWORD PTR aea_crn$[rsp], 0
  00068	0f 84 25 01 00
	00		 je	 $LN2@s390_maddr

; 326  :     {
; 327  :         /* Same Addess Space Designator as before? */
; 328  :         /* Or if not, is address in a common segment? */
; 329  :         if (0
; 330  :             || (regs->CR( aea_crn ) == regs->tlb.TLB_ASD( tlbix ))
; 331  :             || (regs->AEA_COMMON( aea_crn ) & regs->tlb.common[ tlbix ])

  0006e	33 c0		 xor	 eax, eax
  00070	85 c0		 test	 eax, eax
  00072	75 59		 jne	 SHORT $LN4@s390_maddr
  00074	8b 44 24 34	 mov	 eax, DWORD PTR aea_crn$[rsp]
  00078	ff c0		 inc	 eax
  0007a	48 98		 cdqe
  0007c	0f b7 4c 24 30	 movzx	 ecx, WORD PTR tlbix$[rsp]
  00081	48 8b 54 24 78	 mov	 rdx, QWORD PTR regs$[rsp]
  00086	4c 8b 44 24 78	 mov	 r8, QWORD PTR regs$[rsp]
  0008b	41 8b 8c c8 60
	b0 00 00	 mov	 ecx, DWORD PTR [r8+rcx*8+45152]
  00093	39 8c c2 00 06
	00 00		 cmp	 DWORD PTR [rdx+rax*8+1536], ecx
  0009a	74 31		 je	 SHORT $LN4@s390_maddr
  0009c	8b 44 24 34	 mov	 eax, DWORD PTR aea_crn$[rsp]
  000a0	ff c0		 inc	 eax
  000a2	48 98		 cdqe
  000a4	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  000a9	0f b6 84 01 e8
	0c 00 00	 movzx	 eax, BYTE PTR [rcx+rax+3304]
  000b1	0f b7 4c 24 30	 movzx	 ecx, WORD PTR tlbix$[rsp]
  000b6	48 8b 54 24 78	 mov	 rdx, QWORD PTR regs$[rsp]
  000bb	0f b6 8c 0a 60
	54 01 00	 movzx	 ecx, BYTE PTR [rdx+rcx+87136]
  000c3	23 c1		 and	 eax, ecx
  000c5	85 c0		 test	 eax, eax
  000c7	0f 84 c6 00 00
	00		 je	 $LN3@s390_maddr
$LN4@s390_maddr:

; 332  :         )
; 333  :         {
; 334  :             /* Storage Key zero? */
; 335  :             /* Or if not, same Storage Key as before? */
; 336  :             if (0
; 337  :                 || akey == 0
; 338  :                 || akey == regs->tlb.skey[ tlbix ]

  000cd	33 c0		 xor	 eax, eax
  000cf	85 c0		 test	 eax, eax
  000d1	75 2e		 jne	 SHORT $LN6@s390_maddr
  000d3	0f b6 84 24 88
	00 00 00	 movzx	 eax, BYTE PTR akey$[rsp]
  000db	85 c0		 test	 eax, eax
  000dd	74 22		 je	 SHORT $LN6@s390_maddr
  000df	0f b6 84 24 88
	00 00 00	 movzx	 eax, BYTE PTR akey$[rsp]
  000e7	0f b7 4c 24 30	 movzx	 ecx, WORD PTR tlbix$[rsp]
  000ec	48 8b 54 24 78	 mov	 rdx, QWORD PTR regs$[rsp]
  000f1	0f b6 8c 0a 60
	50 01 00	 movzx	 ecx, BYTE PTR [rdx+rcx+86112]
  000f9	3b c1		 cmp	 eax, ecx
  000fb	0f 85 92 00 00
	00		 jne	 $LN5@s390_maddr
$LN6@s390_maddr:

; 339  :             )
; 340  :             {
; 341  :                 /* Does the page address match the one in the TLB? */
; 342  :                 /* (does a TLB entry exist for this page address?) */
; 343  :                 if (
; 344  :                     ((addr & TLBID_PAGEMASK) | regs->tlbID)
; 345  :                     ==

  00101	8b 44 24 60	 mov	 eax, DWORD PTR addr$[rsp]
  00105	25 00 00 c0 7f	 and	 eax, 2143289344		; 7fc00000H
  0010a	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  0010f	0b 81 58 b0 00
	00		 or	 eax, DWORD PTR [rcx+45144]
  00115	0f b7 4c 24 30	 movzx	 ecx, WORD PTR tlbix$[rsp]
  0011a	48 8b 54 24 78	 mov	 rdx, QWORD PTR regs$[rsp]
  0011f	3b 84 ca 60 d0
	00 00		 cmp	 eax, DWORD PTR [rdx+rcx*8+53344]
  00126	75 6b		 jne	 SHORT $LN7@s390_maddr

; 346  :                     regs->tlb.TLB_VADDR( tlbix )
; 347  :                 )
; 348  :                 {
; 349  :                     /* Is storage being accessed same way as before? */
; 350  :                     if (acctype & regs->tlb.acc[ tlbix ])

  00128	0f b7 44 24 30	 movzx	 eax, WORD PTR tlbix$[rsp]
  0012d	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  00132	0f b6 84 01 60
	5c 01 00	 movzx	 eax, BYTE PTR [rcx+rax+89184]
  0013a	8b 8c 24 80 00
	00 00		 mov	 ecx, DWORD PTR acctype$[rsp]
  00141	23 c8		 and	 ecx, eax
  00143	8b c1		 mov	 eax, ecx
  00145	85 c0		 test	 eax, eax
  00147	74 4a		 je	 SHORT $LN8@s390_maddr

; 351  :                     {
; 352  :                         /*------------------------------------------*/
; 353  :                         /* TLB hit: use previously translated value */
; 354  :                         /*------------------------------------------*/
; 355  : 
; 356  :                         if (acctype & ACC_CHECK)

  00149	8b 84 24 80 00
	00 00		 mov	 eax, DWORD PTR acctype$[rsp]
  00150	83 e0 01	 and	 eax, 1
  00153	85 c0		 test	 eax, eax
  00155	74 1e		 je	 SHORT $LN9@s390_maddr

; 357  :                             regs->dat.storkey = regs->tlb.storkey[ tlbix ];

  00157	0f b7 44 24 30	 movzx	 eax, WORD PTR tlbix$[rsp]
  0015c	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  00161	48 8b 54 24 78	 mov	 rdx, QWORD PTR regs$[rsp]
  00166	48 8b 84 c2 60
	30 01 00	 mov	 rax, QWORD PTR [rdx+rax*8+77920]
  0016e	48 89 81 28 08
	00 00		 mov	 QWORD PTR [rcx+2088], rax
$LN9@s390_maddr:

; 358  : 
; 359  :                         maddr = MAINADDR( regs->tlb.main[tlbix], addr );

  00175	0f b7 44 24 30	 movzx	 eax, WORD PTR tlbix$[rsp]
  0017a	8b 4c 24 60	 mov	 ecx, DWORD PTR addr$[rsp]
  0017e	48 8b 54 24 78	 mov	 rdx, QWORD PTR regs$[rsp]
  00183	48 8b 84 c2 60
	10 01 00	 mov	 rax, QWORD PTR [rdx+rax*8+69728]
  0018b	48 33 c1	 xor	 rax, rcx
  0018e	48 89 44 24 40	 mov	 QWORD PTR maddr$[rsp], rax
$LN8@s390_maddr:
$LN7@s390_maddr:
$LN5@s390_maddr:
$LN3@s390_maddr:
$LN2@s390_maddr:

; 360  :                     }
; 361  :                 }
; 362  :             }
; 363  :         }
; 364  :     }
; 365  : 
; 366  :     /*---------------------------------------*/
; 367  :     /* TLB miss: do full address translation */
; 368  :     /*---------------------------------------*/
; 369  :     if (!maddr)

  00193	48 83 7c 24 40
	00		 cmp	 QWORD PTR maddr$[rsp], 0
  00199	75 35		 jne	 SHORT $LN10@s390_maddr

; 370  :         maddr = ARCH_DEP( logical_to_main_l )( addr, arn, regs, acctype, akey, len );

  0019b	48 8b 44 24 68	 mov	 rax, QWORD PTR len$[rsp]
  001a0	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  001a5	0f b6 84 24 88
	00 00 00	 movzx	 eax, BYTE PTR akey$[rsp]
  001ad	88 44 24 20	 mov	 BYTE PTR [rsp+32], al
  001b1	44 8b 8c 24 80
	00 00 00	 mov	 r9d, DWORD PTR acctype$[rsp]
  001b9	4c 8b 44 24 78	 mov	 r8, QWORD PTR regs$[rsp]
  001be	8b 54 24 70	 mov	 edx, DWORD PTR arn$[rsp]
  001c2	8b 4c 24 60	 mov	 ecx, DWORD PTR addr$[rsp]
  001c6	e8 00 00 00 00	 call	 s390_logical_to_main_l
  001cb	48 89 44 24 40	 mov	 QWORD PTR maddr$[rsp], rax
$LN10@s390_maddr:

; 371  : 
; 372  : #if defined( FEATURE_073_TRANSACT_EXEC_FACILITY )
; 373  :     if (FACILITY_ENABLED( 073_TRANSACT_EXEC, regs ))
; 374  :     {
; 375  :         /* SA22-7832-12 Principles of Operation, page 5-99:
; 376  : 
; 377  :              "Storage accesses for instruction and DAT- and ART-
; 378  :               table fetches follow the non-transactional rules."
; 379  :         */
; 380  :         if (0
; 381  :             || !regs
; 382  :             || !regs->txf_tnd
; 383  :             || arn == USE_INST_SPACE    /* Instruction fetching */
; 384  :             || arn == USE_REAL_ADDR     /* Address translation  */
; 385  :         )
; 386  :             return maddr;
; 387  : 
; 388  :         /* Quick exit if NTSTG call */
; 389  :         if (regs->txf_NTSTG)
; 390  :         {
; 391  :             regs->txf_NTSTG = false;
; 392  :             return maddr;
; 393  :         }
; 394  : 
; 395  :         /* Translate to alternate TXF address */
; 396  :         maddr = TXF_MADDRL( addr, len, arn, regs, acctype, maddr );
; 397  :     }
; 398  : #endif
; 399  : 
; 400  :     return maddr;

  001d0	48 8b 44 24 40	 mov	 rax, QWORD PTR maddr$[rsp]

; 401  : }

  001d5	48 83 c4 58	 add	 rsp, 88			; 00000058H
  001d9	c3		 ret	 0
s390_maddr_l ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\skey.h
;	COMDAT s390_get_ptr_to_storekey
_TEXT	SEGMENT
abs$ = 48
s390_get_ptr_to_storekey PROC				; COMDAT

; 308  : {

$LN3:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 309  : #if defined( FEATURE_2K_STORAGE_KEYS )
; 310  :     return ARCH_DEP( get_ptr_to_2K_storekey )( abs );
; 311  : #else
; 312  :     return ARCH_DEP( get_ptr_to_4K_storekey )( abs );

  00009	48 8b 4c 24 30	 mov	 rcx, QWORD PTR abs$[rsp]
  0000e	e8 00 00 00 00	 call	 s390_get_ptr_to_4K_storekey

; 313  : #endif
; 314  : }

  00013	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00017	c3		 ret	 0
s390_get_ptr_to_storekey ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\skey.h
;	COMDAT s390_or_4K_storage_key
_TEXT	SEGMENT
abs$ = 48
bits$ = 56
s390_or_4K_storage_key PROC				; COMDAT

; 242  :   inline void  ARCH_DEP( or_4K_storage_key )      (              U64 abs, BYTE bits ) {        ARCH_DEP( _or_storage_key      )(      abs, bits & ~STORKEY_BADFRM, 4 ); }

$LN3:
  00000	88 54 24 10	 mov	 BYTE PTR [rsp+16], dl
  00004	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00009	48 83 ec 28	 sub	 rsp, 40			; 00000028H
  0000d	0f b6 44 24 38	 movzx	 eax, BYTE PTR bits$[rsp]
  00012	83 e0 fe	 and	 eax, -2
  00015	41 b0 04	 mov	 r8b, 4
  00018	0f b6 d0	 movzx	 edx, al
  0001b	48 8b 4c 24 30	 mov	 rcx, QWORD PTR abs$[rsp]
  00020	e8 00 00 00 00	 call	 s390__or_storage_key
  00025	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00029	c3		 ret	 0
s390_or_4K_storage_key ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\skey.h
;	COMDAT s390_get_ptr_to_4K_storekey
_TEXT	SEGMENT
abs$ = 48
s390_get_ptr_to_4K_storekey PROC			; COMDAT

; 238  :   inline BYTE* ARCH_DEP( get_ptr_to_4K_storekey ) (              U64 abs            ) { return           _get_storekey_ptr     (      abs, 4 );                         }

$LN3:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 28	 sub	 rsp, 40			; 00000028H
  00009	b2 04		 mov	 dl, 4
  0000b	48 8b 4c 24 30	 mov	 rcx, QWORD PTR abs$[rsp]
  00010	e8 00 00 00 00	 call	 _get_storekey_ptr
  00015	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00019	c3		 ret	 0
s390_get_ptr_to_4K_storekey ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\skey.h
;	COMDAT s390__or_storage_key
_TEXT	SEGMENT
skey1_ptr$1 = 32
skey2_ptr$2 = 40
skey_ptr$3 = 48
abs$ = 80
bits$ = 88
K$ = 96
s390__or_storage_key PROC				; COMDAT

; 189  : {

$LN8:
  00000	44 88 44 24 18	 mov	 BYTE PTR [rsp+24], r8b
  00005	88 54 24 10	 mov	 BYTE PTR [rsp+16], dl
  00009	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000e	48 83 ec 48	 sub	 rsp, 72			; 00000048H
$LN4@s390__or_s:

; 190  :     UNREFERENCED( K ); // (for FEATURE_4K_STORAGE_KEYS case)

  00012	33 c0		 xor	 eax, eax
  00014	85 c0		 test	 eax, eax
  00016	75 fa		 jne	 SHORT $LN4@s390__or_s

; 191  :     if (IS_DOUBLE_KEYED_4K_BYTE_BLOCK( K ))

  00018	33 c0		 xor	 eax, eax
  0001a	85 c0		 test	 eax, eax
  0001c	74 50		 je	 SHORT $LN5@s390__or_s

; 192  :     {
; 193  :         BYTE* skey1_ptr = _get_storekey1_ptr( abs );

  0001e	48 8b 4c 24 50	 mov	 rcx, QWORD PTR abs$[rsp]
  00023	e8 00 00 00 00	 call	 _get_storekey1_ptr
  00028	48 89 44 24 20	 mov	 QWORD PTR skey1_ptr$1[rsp], rax

; 194  :         BYTE* skey2_ptr = _get_storekey2_ptr( abs );

  0002d	48 8b 4c 24 50	 mov	 rcx, QWORD PTR abs$[rsp]
  00032	e8 00 00 00 00	 call	 _get_storekey2_ptr
  00037	48 89 44 24 28	 mov	 QWORD PTR skey2_ptr$2[rsp], rax

; 195  :         OR_SKEY( skey1_ptr, bits );

  0003c	0f b6 44 24 58	 movzx	 eax, BYTE PTR bits$[rsp]
  00041	48 8b 4c 24 20	 mov	 rcx, QWORD PTR skey1_ptr$1[rsp]
  00046	0f b6 09	 movzx	 ecx, BYTE PTR [rcx]
  00049	0b c8		 or	 ecx, eax
  0004b	8b c1		 mov	 eax, ecx
  0004d	48 8b 4c 24 20	 mov	 rcx, QWORD PTR skey1_ptr$1[rsp]
  00052	88 01		 mov	 BYTE PTR [rcx], al

; 196  :         OR_SKEY( skey2_ptr, bits );

  00054	0f b6 44 24 58	 movzx	 eax, BYTE PTR bits$[rsp]
  00059	48 8b 4c 24 28	 mov	 rcx, QWORD PTR skey2_ptr$2[rsp]
  0005e	0f b6 09	 movzx	 ecx, BYTE PTR [rcx]
  00061	0b c8		 or	 ecx, eax
  00063	8b c1		 mov	 eax, ecx
  00065	48 8b 4c 24 28	 mov	 rcx, QWORD PTR skey2_ptr$2[rsp]
  0006a	88 01		 mov	 BYTE PTR [rcx], al

; 197  :     }

  0006c	eb 2c		 jmp	 SHORT $LN6@s390__or_s
$LN5@s390__or_s:

; 198  :     else
; 199  :     {
; 200  :         BYTE* skey_ptr  = _get_storekey_ptr( abs, K );

  0006e	0f b6 54 24 60	 movzx	 edx, BYTE PTR K$[rsp]
  00073	48 8b 4c 24 50	 mov	 rcx, QWORD PTR abs$[rsp]
  00078	e8 00 00 00 00	 call	 _get_storekey_ptr
  0007d	48 89 44 24 30	 mov	 QWORD PTR skey_ptr$3[rsp], rax

; 201  :         OR_SKEY( skey_ptr, bits );

  00082	0f b6 44 24 58	 movzx	 eax, BYTE PTR bits$[rsp]
  00087	48 8b 4c 24 30	 mov	 rcx, QWORD PTR skey_ptr$3[rsp]
  0008c	0f b6 09	 movzx	 ecx, BYTE PTR [rcx]
  0008f	0b c8		 or	 ecx, eax
  00091	8b c1		 mov	 eax, ecx
  00093	48 8b 4c 24 30	 mov	 rcx, QWORD PTR skey_ptr$3[rsp]
  00098	88 01		 mov	 BYTE PTR [rcx], al
$LN6@s390__or_s:

; 202  :     }
; 203  : }

  0009a	48 83 c4 48	 add	 rsp, 72			; 00000048H
  0009e	c3		 ret	 0
s390__or_storage_key ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\sie.c
_TEXT	SEGMENT
zone$ = 64
temp$1 = 68
b2$ = 72
effective_addr2$ = 80
mso$ = 88
msl$ = 96
eso$ = 104
esl$ = 112
zpb$ = 120
__$ArrayPad$ = 152
inst$ = 176
regs$ = 184
s390_set_zone_parameter PROC

; 1808 : {

$LN24:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 81 ec a8 00
	00 00		 sub	 rsp, 168		; 000000a8H
  00011	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00018	48 33 c4	 xor	 rax, rsp
  0001b	48 89 84 24 98
	00 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 1809 : int     b2;                             /* Values of R fields        */
; 1810 : RADR    effective_addr2;                /* address of state desc.    */
; 1811 : ZPB     zpb;                            /* Zone Parameter Block      */
; 1812 : int     zone;                           /* Zone number               */
; 1813 : RADR    mso,                            /* Main Storage Origin       */
; 1814 :         msl,                            /* Main Storage Length       */
; 1815 :         eso,                            /* Expanded Storage Origin   */
; 1816 :         esl;                            /* Expanded Storage Length   */
; 1817 : 
; 1818 :     S(inst, regs, b2, effective_addr2);

  00023	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR inst$[rsp]
  0002b	e8 00 00 00 00	 call	 fetch_fw_noswap
  00030	8b c8		 mov	 ecx, eax
  00032	e8 00 00 00 00	 call	 _byteswap_ulong
  00037	89 44 24 44	 mov	 DWORD PTR temp$1[rsp], eax
  0003b	8b 44 24 44	 mov	 eax, DWORD PTR temp$1[rsp]
  0003f	25 ff 0f 00 00	 and	 eax, 4095		; 00000fffH
  00044	8b c0		 mov	 eax, eax
  00046	48 89 44 24 50	 mov	 QWORD PTR effective_addr2$[rsp], rax
  0004b	8b 44 24 44	 mov	 eax, DWORD PTR temp$1[rsp]
  0004f	c1 e8 0c	 shr	 eax, 12
  00052	83 e0 0f	 and	 eax, 15
  00055	89 44 24 48	 mov	 DWORD PTR b2$[rsp], eax
  00059	83 7c 24 48 00	 cmp	 DWORD PTR b2$[rsp], 0
  0005e	74 42		 je	 SHORT $LN14@s390_set_z
  00060	48 63 44 24 48	 movsxd	 rax, DWORD PTR b2$[rsp]
  00065	48 8b 8c 24 b8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0006d	8b 84 c1 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax*8+640]
  00074	48 8b 4c 24 50	 mov	 rcx, QWORD PTR effective_addr2$[rsp]
  00079	48 03 c8	 add	 rcx, rax
  0007c	48 8b c1	 mov	 rax, rcx
  0007f	48 89 44 24 50	 mov	 QWORD PTR effective_addr2$[rsp], rax
  00084	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0008c	8b 80 90 00 00
	00		 mov	 eax, DWORD PTR [rax+144]
  00092	48 8b 4c 24 50	 mov	 rcx, QWORD PTR effective_addr2$[rsp]
  00097	48 23 c8	 and	 rcx, rax
  0009a	48 8b c1	 mov	 rax, rcx
  0009d	48 89 44 24 50	 mov	 QWORD PTR effective_addr2$[rsp], rax
$LN14@s390_set_z:
$LN4@s390_set_z:
  000a2	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  000aa	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  000ae	48 83 c0 04	 add	 rax, 4
  000b2	48 8b 8c 24 b8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  000ba	48 89 41 68	 mov	 QWORD PTR [rcx+104], rax
  000be	33 c0		 xor	 eax, eax
  000c0	83 f8 04	 cmp	 eax, 4
  000c3	74 0f		 je	 SHORT $LN15@s390_set_z
  000c5	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  000cd	c6 80 9a 00 00
	00 04		 mov	 BYTE PTR [rax+154], 4
$LN15@s390_set_z:
  000d4	33 c0		 xor	 eax, eax
  000d6	85 c0		 test	 eax, eax
  000d8	75 c8		 jne	 SHORT $LN4@s390_set_z

; 1819 : 
; 1820 :     TXF_INSTR_CHECK( regs );
; 1821 :     PRIV_CHECK(regs);

  000da	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  000e2	0f b6 40 7a	 movzx	 eax, BYTE PTR [rax+122]
  000e6	83 e0 01	 and	 eax, 1
  000e9	85 c0		 test	 eax, eax
  000eb	74 1b		 je	 SHORT $LN16@s390_set_z
  000ed	ba 02 00 00 00	 mov	 edx, 2
  000f2	48 8b 8c 24 b8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  000fa	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00102	ff 90 20 0d 00
	00		 call	 QWORD PTR [rax+3360]
$LN16@s390_set_z:
$LN7@s390_set_z:

; 1822 : 
; 1823 :     SIE_INTERCEPT(regs);

  00108	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00110	8b 80 c8 08 00
	00		 mov	 eax, DWORD PTR [rax+2248]
  00116	d1 e8		 shr	 eax, 1
  00118	83 e0 01	 and	 eax, 1
  0011b	85 c0		 test	 eax, eax
  0011d	74 1b		 je	 SHORT $LN17@s390_set_z
  0011f	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00127	48 05 80 09 00
	00		 add	 rax, 2432		; 00000980H
  0012d	ba fc ff ff ff	 mov	 edx, -4
  00132	48 8b c8	 mov	 rcx, rax
  00135	e8 00 00 00 00	 call	 longjmp
$LN17@s390_set_z:
  0013a	33 c0		 xor	 eax, eax
  0013c	85 c0		 test	 eax, eax
  0013e	75 c8		 jne	 SHORT $LN7@s390_set_z
$LN10@s390_set_z:

; 1824 : 
; 1825 :     PTT_IO("SZP", regs->GR_L(1), regs->GR_L(2),regs->psw.IA_L);

  00140	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_pttclass
  00147	48 8b 00	 mov	 rax, QWORD PTR [rax]
  0014a	48 25 00 02 00
	00		 and	 rax, 512		; 00000200H
  00150	48 85 c0	 test	 rax, rax
  00153	74 71		 je	 SHORT $LN18@s390_set_z
  00155	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0015d	8b 80 88 00 00
	00		 mov	 eax, DWORD PTR [rax+136]
  00163	b9 08 00 00 00	 mov	 ecx, 8
  00168	48 6b c9 02	 imul	 rcx, rcx, 2
  0016c	48 8b 94 24 b8
	00 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  00174	8b 8c 0a 80 02
	00 00		 mov	 ecx, DWORD PTR [rdx+rcx+640]
  0017b	ba 08 00 00 00	 mov	 edx, 8
  00180	48 6b d2 01	 imul	 rdx, rdx, 1
  00184	4c 8b 84 24 b8
	00 00 00	 mov	 r8, QWORD PTR regs$[rsp]
  0018c	41 8b 94 10 80
	02 00 00	 mov	 edx, DWORD PTR [r8+rdx+640]
  00194	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR [rsp+48], 0
  0019d	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  001a2	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG181348
  001a9	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  001ae	44 8b c9	 mov	 r9d, ecx
  001b1	44 8b c2	 mov	 r8d, edx
  001b4	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG181349
  001bb	b9 00 02 00 00	 mov	 ecx, 512		; 00000200H
  001c0	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ptt_pthread_trace
$LN18@s390_set_z:
  001c6	33 c0		 xor	 eax, eax
  001c8	85 c0		 test	 eax, eax
  001ca	0f 85 70 ff ff
	ff		 jne	 $LN10@s390_set_z

; 1826 : 
; 1827 :     FW_CHECK(regs->GR(2), regs);

  001d0	b8 08 00 00 00	 mov	 eax, 8
  001d5	48 6b c0 02	 imul	 rax, rax, 2
  001d9	48 8b 8c 24 b8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  001e1	8b 84 01 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax+640]
  001e8	83 e0 03	 and	 eax, 3
  001eb	85 c0		 test	 eax, eax
  001ed	74 1b		 je	 SHORT $LN19@s390_set_z
  001ef	ba 06 00 00 00	 mov	 edx, 6
  001f4	48 8b 8c 24 b8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  001fc	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00204	ff 90 20 0d 00
	00		 call	 QWORD PTR [rax+3360]
$LN19@s390_set_z:

; 1828 : 
; 1829 :     zone = regs->GR_LHLCL(1);

  0020a	b8 08 00 00 00	 mov	 eax, 8
  0020f	48 6b c0 01	 imul	 rax, rax, 1
  00213	48 8b 8c 24 b8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0021b	0f b6 84 01 80
	02 00 00	 movzx	 eax, BYTE PTR [rcx+rax+640]
  00223	89 44 24 40	 mov	 DWORD PTR zone$[rsp], eax

; 1830 : 
; 1831 :     if(zone == 0 || zone >= FEATURE_SIE_MAXZONES)

  00227	83 7c 24 40 00	 cmp	 DWORD PTR zone$[rsp], 0
  0022c	74 0b		 je	 SHORT $LN21@s390_set_z
  0022e	83 7c 24 40 08	 cmp	 DWORD PTR zone$[rsp], 8
  00233	0f 8c 9f 00 00
	00		 jl	 $LN20@s390_set_z
$LN21@s390_set_z:
$LN13@s390_set_z:

; 1832 :     {
; 1833 :         PTT_ERR("*SZP", regs->GR_L(1), regs->GR_L(2),regs->psw.IA_L);

  00239	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_pttclass
  00240	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00243	48 83 e0 10	 and	 rax, 16
  00247	48 85 c0	 test	 rax, rax
  0024a	74 71		 je	 SHORT $LN22@s390_set_z
  0024c	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00254	8b 80 88 00 00
	00		 mov	 eax, DWORD PTR [rax+136]
  0025a	b9 08 00 00 00	 mov	 ecx, 8
  0025f	48 6b c9 02	 imul	 rcx, rcx, 2
  00263	48 8b 94 24 b8
	00 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  0026b	8b 8c 0a 80 02
	00 00		 mov	 ecx, DWORD PTR [rdx+rcx+640]
  00272	ba 08 00 00 00	 mov	 edx, 8
  00277	48 6b d2 01	 imul	 rdx, rdx, 1
  0027b	4c 8b 84 24 b8
	00 00 00	 mov	 r8, QWORD PTR regs$[rsp]
  00283	41 8b 94 10 80
	02 00 00	 mov	 edx, DWORD PTR [r8+rdx+640]
  0028b	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR [rsp+48], 0
  00294	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  00299	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG181354
  002a0	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  002a5	44 8b c9	 mov	 r9d, ecx
  002a8	44 8b c2	 mov	 r8d, edx
  002ab	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG181355
  002b2	b9 10 00 00 00	 mov	 ecx, 16
  002b7	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ptt_pthread_trace
$LN22@s390_set_z:
  002bd	33 c0		 xor	 eax, eax
  002bf	85 c0		 test	 eax, eax
  002c1	0f 85 72 ff ff
	ff		 jne	 $LN13@s390_set_z

; 1834 :         regs->psw.cc = 3;

  002c7	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  002cf	c6 40 7c 03	 mov	 BYTE PTR [rax+124], 3

; 1835 :         return;

  002d3	e9 1e 01 00 00	 jmp	 $LN1@s390_set_z
$LN20@s390_set_z:

; 1836 :     }
; 1837 : 
; 1838 :     ARCH_DEP(vfetchc(&zpb, sizeof(ZPB)-1,regs->GR(2), 2, regs));

  002d8	b8 08 00 00 00	 mov	 eax, 8
  002dd	48 6b c0 02	 imul	 rax, rax, 2
  002e1	48 8b 8c 24 b8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  002e9	48 89 4c 24 20	 mov	 QWORD PTR [rsp+32], rcx
  002ee	41 b9 02 00 00
	00		 mov	 r9d, 2
  002f4	48 8b 8c 24 b8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  002fc	44 8b 84 01 80
	02 00 00	 mov	 r8d, DWORD PTR [rcx+rax+640]
  00304	b2 1f		 mov	 dl, 31
  00306	48 8d 4c 24 78	 lea	 rcx, QWORD PTR zpb$[rsp]
  0030b	e8 00 00 00 00	 call	 s390_vfetchc

; 1839 : 
; 1840 :     FETCH_W(mso,zpb.mso);

  00310	48 8d 4c 24 78	 lea	 rcx, QWORD PTR zpb$[rsp]
  00315	e8 00 00 00 00	 call	 fetch_fw_noswap
  0031a	8b c8		 mov	 ecx, eax
  0031c	e8 00 00 00 00	 call	 _byteswap_ulong
  00321	8b c0		 mov	 eax, eax
  00323	48 89 44 24 58	 mov	 QWORD PTR mso$[rsp], rax

; 1841 :     FETCH_W(msl,zpb.msl);

  00328	48 8d 4c 24 7c	 lea	 rcx, QWORD PTR zpb$[rsp+4]
  0032d	e8 00 00 00 00	 call	 fetch_fw_noswap
  00332	8b c8		 mov	 ecx, eax
  00334	e8 00 00 00 00	 call	 _byteswap_ulong
  00339	8b c0		 mov	 eax, eax
  0033b	48 89 44 24 60	 mov	 QWORD PTR msl$[rsp], rax

; 1842 :     FETCH_W(eso,zpb.eso);

  00340	48 8d 8c 24 80
	00 00 00	 lea	 rcx, QWORD PTR zpb$[rsp+8]
  00348	e8 00 00 00 00	 call	 fetch_fw_noswap
  0034d	8b c8		 mov	 ecx, eax
  0034f	e8 00 00 00 00	 call	 _byteswap_ulong
  00354	8b c0		 mov	 eax, eax
  00356	48 89 44 24 68	 mov	 QWORD PTR eso$[rsp], rax

; 1843 :     FETCH_W(esl,zpb.esl);

  0035b	48 8d 8c 24 84
	00 00 00	 lea	 rcx, QWORD PTR zpb$[rsp+12]
  00363	e8 00 00 00 00	 call	 fetch_fw_noswap
  00368	8b c8		 mov	 ecx, eax
  0036a	e8 00 00 00 00	 call	 _byteswap_ulong
  0036f	8b c0		 mov	 eax, eax
  00371	48 89 44 24 70	 mov	 QWORD PTR esl$[rsp], rax

; 1844 : 
; 1845 : #if defined( FEATURE_001_ZARCH_INSTALLED_FACILITY )
; 1846 :     if(  (mso & ~ZPB2_MS_VALID)
; 1847 :       || (msl & ~ZPB2_MS_VALID)
; 1848 :       || (eso & ~ZPB2_ES_VALID)
; 1849 :       || (esl & ~ZPB2_ES_VALID) )
; 1850 :         ARCH_DEP(program_interrupt) (regs, PGM_OPERAND_EXCEPTION);
; 1851 : #endif
; 1852 : 
; 1853 :     sysblk.zpb[zone].mso = mso;

  00376	48 63 44 24 40	 movsxd	 rax, DWORD PTR zone$[rsp]
  0037b	48 6b c0 38	 imul	 rax, rax, 56		; 00000038H
  0037f	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  00386	48 8b 54 24 58	 mov	 rdx, QWORD PTR mso$[rsp]
  0038b	48 89 94 01 a0
	0e 00 00	 mov	 QWORD PTR [rcx+rax+3744], rdx

; 1854 :     sysblk.zpb[zone].msl = msl;

  00393	48 63 44 24 40	 movsxd	 rax, DWORD PTR zone$[rsp]
  00398	48 6b c0 38	 imul	 rax, rax, 56		; 00000038H
  0039c	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  003a3	48 8b 54 24 60	 mov	 rdx, QWORD PTR msl$[rsp]
  003a8	48 89 94 01 a8
	0e 00 00	 mov	 QWORD PTR [rcx+rax+3752], rdx

; 1855 :     sysblk.zpb[zone].eso = eso;

  003b0	48 63 44 24 40	 movsxd	 rax, DWORD PTR zone$[rsp]
  003b5	48 6b c0 38	 imul	 rax, rax, 56		; 00000038H
  003b9	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  003c0	48 8b 54 24 68	 mov	 rdx, QWORD PTR eso$[rsp]
  003c5	48 89 94 01 b0
	0e 00 00	 mov	 QWORD PTR [rcx+rax+3760], rdx

; 1856 :     sysblk.zpb[zone].esl = esl;

  003cd	48 63 44 24 40	 movsxd	 rax, DWORD PTR zone$[rsp]
  003d2	48 6b c0 38	 imul	 rax, rax, 56		; 00000038H
  003d6	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  003dd	48 8b 54 24 70	 mov	 rdx, QWORD PTR esl$[rsp]
  003e2	48 89 94 01 b8
	0e 00 00	 mov	 QWORD PTR [rcx+rax+3768], rdx

; 1857 : 
; 1858 :     regs->psw.cc = 0;

  003ea	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  003f2	c6 40 7c 00	 mov	 BYTE PTR [rax+124], 0
$LN1@s390_set_z:
$LN23@s390_set_z:

; 1859 : }

  003f6	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  003fe	48 33 cc	 xor	 rcx, rsp
  00401	e8 00 00 00 00	 call	 __security_check_cookie
  00406	48 81 c4 a8 00
	00 00		 add	 rsp, 168		; 000000a8H
  0040d	c3		 ret	 0
s390_set_zone_parameter ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\sie.c
_TEXT	SEGMENT
zone$ = 64
temp$1 = 68
b2$ = 72
effective_addr2$ = 80
zpb$ = 88
__$ArrayPad$ = 120
inst$ = 144
regs$ = 152
s390_store_zone_parameter PROC

; 1767 : {

$LN23:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 81 ec 88 00
	00 00		 sub	 rsp, 136		; 00000088H
  00011	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00018	48 33 c4	 xor	 rax, rsp
  0001b	48 89 44 24 78	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 1768 : int     b2;                             /* Values of R fields        */
; 1769 : RADR    effective_addr2;                /* address of state desc.    */
; 1770 : ZPB     zpb;                            /* Zone Parameter Block      */
; 1771 : int     zone;                           /* Zone number               */
; 1772 : 
; 1773 :     S(inst, regs, b2, effective_addr2);

  00020	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR inst$[rsp]
  00028	e8 00 00 00 00	 call	 fetch_fw_noswap
  0002d	8b c8		 mov	 ecx, eax
  0002f	e8 00 00 00 00	 call	 _byteswap_ulong
  00034	89 44 24 44	 mov	 DWORD PTR temp$1[rsp], eax
  00038	8b 44 24 44	 mov	 eax, DWORD PTR temp$1[rsp]
  0003c	25 ff 0f 00 00	 and	 eax, 4095		; 00000fffH
  00041	8b c0		 mov	 eax, eax
  00043	48 89 44 24 50	 mov	 QWORD PTR effective_addr2$[rsp], rax
  00048	8b 44 24 44	 mov	 eax, DWORD PTR temp$1[rsp]
  0004c	c1 e8 0c	 shr	 eax, 12
  0004f	83 e0 0f	 and	 eax, 15
  00052	89 44 24 48	 mov	 DWORD PTR b2$[rsp], eax
  00056	83 7c 24 48 00	 cmp	 DWORD PTR b2$[rsp], 0
  0005b	74 42		 je	 SHORT $LN14@s390_store
  0005d	48 63 44 24 48	 movsxd	 rax, DWORD PTR b2$[rsp]
  00062	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0006a	8b 84 c1 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax*8+640]
  00071	48 8b 4c 24 50	 mov	 rcx, QWORD PTR effective_addr2$[rsp]
  00076	48 03 c8	 add	 rcx, rax
  00079	48 8b c1	 mov	 rax, rcx
  0007c	48 89 44 24 50	 mov	 QWORD PTR effective_addr2$[rsp], rax
  00081	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00089	8b 80 90 00 00
	00		 mov	 eax, DWORD PTR [rax+144]
  0008f	48 8b 4c 24 50	 mov	 rcx, QWORD PTR effective_addr2$[rsp]
  00094	48 23 c8	 and	 rcx, rax
  00097	48 8b c1	 mov	 rax, rcx
  0009a	48 89 44 24 50	 mov	 QWORD PTR effective_addr2$[rsp], rax
$LN14@s390_store:
$LN4@s390_store:
  0009f	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  000a7	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  000ab	48 83 c0 04	 add	 rax, 4
  000af	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  000b7	48 89 41 68	 mov	 QWORD PTR [rcx+104], rax
  000bb	33 c0		 xor	 eax, eax
  000bd	83 f8 04	 cmp	 eax, 4
  000c0	74 0f		 je	 SHORT $LN15@s390_store
  000c2	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  000ca	c6 80 9a 00 00
	00 04		 mov	 BYTE PTR [rax+154], 4
$LN15@s390_store:
  000d1	33 c0		 xor	 eax, eax
  000d3	85 c0		 test	 eax, eax
  000d5	75 c8		 jne	 SHORT $LN4@s390_store

; 1774 : 
; 1775 :     TXF_INSTR_CHECK( regs );
; 1776 :     PRIV_CHECK(regs);

  000d7	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  000df	0f b6 40 7a	 movzx	 eax, BYTE PTR [rax+122]
  000e3	83 e0 01	 and	 eax, 1
  000e6	85 c0		 test	 eax, eax
  000e8	74 1b		 je	 SHORT $LN16@s390_store
  000ea	ba 02 00 00 00	 mov	 edx, 2
  000ef	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  000f7	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  000ff	ff 90 20 0d 00
	00		 call	 QWORD PTR [rax+3360]
$LN16@s390_store:
$LN7@s390_store:

; 1777 : 
; 1778 :     SIE_INTERCEPT(regs);

  00105	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0010d	8b 80 c8 08 00
	00		 mov	 eax, DWORD PTR [rax+2248]
  00113	d1 e8		 shr	 eax, 1
  00115	83 e0 01	 and	 eax, 1
  00118	85 c0		 test	 eax, eax
  0011a	74 1b		 je	 SHORT $LN17@s390_store
  0011c	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00124	48 05 80 09 00
	00		 add	 rax, 2432		; 00000980H
  0012a	ba fc ff ff ff	 mov	 edx, -4
  0012f	48 8b c8	 mov	 rcx, rax
  00132	e8 00 00 00 00	 call	 longjmp
$LN17@s390_store:
  00137	33 c0		 xor	 eax, eax
  00139	85 c0		 test	 eax, eax
  0013b	75 c8		 jne	 SHORT $LN7@s390_store
$LN10@s390_store:

; 1779 : 
; 1780 :     PTT_IO("STZP", regs->GR_L(1), regs->GR_L(2),regs->psw.IA_L);

  0013d	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_pttclass
  00144	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00147	48 25 00 02 00
	00		 and	 rax, 512		; 00000200H
  0014d	48 85 c0	 test	 rax, rax
  00150	74 71		 je	 SHORT $LN18@s390_store
  00152	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0015a	8b 80 88 00 00
	00		 mov	 eax, DWORD PTR [rax+136]
  00160	b9 08 00 00 00	 mov	 ecx, 8
  00165	48 6b c9 02	 imul	 rcx, rcx, 2
  00169	48 8b 94 24 98
	00 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  00171	8b 8c 0a 80 02
	00 00		 mov	 ecx, DWORD PTR [rdx+rcx+640]
  00178	ba 08 00 00 00	 mov	 edx, 8
  0017d	48 6b d2 01	 imul	 rdx, rdx, 1
  00181	4c 8b 84 24 98
	00 00 00	 mov	 r8, QWORD PTR regs$[rsp]
  00189	41 8b 94 10 80
	02 00 00	 mov	 edx, DWORD PTR [r8+rdx+640]
  00191	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR [rsp+48], 0
  0019a	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  0019f	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG181296
  001a6	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  001ab	44 8b c9	 mov	 r9d, ecx
  001ae	44 8b c2	 mov	 r8d, edx
  001b1	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG181297
  001b8	b9 00 02 00 00	 mov	 ecx, 512		; 00000200H
  001bd	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ptt_pthread_trace
$LN18@s390_store:
  001c3	33 c0		 xor	 eax, eax
  001c5	85 c0		 test	 eax, eax
  001c7	0f 85 70 ff ff
	ff		 jne	 $LN10@s390_store

; 1781 : 
; 1782 :     FW_CHECK(regs->GR(2), regs);

  001cd	b8 08 00 00 00	 mov	 eax, 8
  001d2	48 6b c0 02	 imul	 rax, rax, 2
  001d6	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  001de	8b 84 01 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax+640]
  001e5	83 e0 03	 and	 eax, 3
  001e8	85 c0		 test	 eax, eax
  001ea	74 1b		 je	 SHORT $LN19@s390_store
  001ec	ba 06 00 00 00	 mov	 edx, 6
  001f1	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  001f9	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00201	ff 90 20 0d 00
	00		 call	 QWORD PTR [rax+3360]
$LN19@s390_store:

; 1783 : 
; 1784 :     zone = regs->GR_LHLCL(1);

  00207	b8 08 00 00 00	 mov	 eax, 8
  0020c	48 6b c0 01	 imul	 rax, rax, 1
  00210	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00218	0f b6 84 01 80
	02 00 00	 movzx	 eax, BYTE PTR [rcx+rax+640]
  00220	89 44 24 40	 mov	 DWORD PTR zone$[rsp], eax

; 1785 : 
; 1786 :     if(zone >= FEATURE_SIE_MAXZONES)

  00224	83 7c 24 40 08	 cmp	 DWORD PTR zone$[rsp], 8
  00229	0f 8c 9f 00 00
	00		 jl	 $LN20@s390_store
$LN13@s390_store:

; 1787 :     {
; 1788 :         PTT_ERR("*STZP", regs->GR_L(1), regs->GR_L(2),regs->psw.IA_L);

  0022f	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_pttclass
  00236	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00239	48 83 e0 10	 and	 rax, 16
  0023d	48 85 c0	 test	 rax, rax
  00240	74 71		 je	 SHORT $LN21@s390_store
  00242	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0024a	8b 80 88 00 00
	00		 mov	 eax, DWORD PTR [rax+136]
  00250	b9 08 00 00 00	 mov	 ecx, 8
  00255	48 6b c9 02	 imul	 rcx, rcx, 2
  00259	48 8b 94 24 98
	00 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  00261	8b 8c 0a 80 02
	00 00		 mov	 ecx, DWORD PTR [rdx+rcx+640]
  00268	ba 08 00 00 00	 mov	 edx, 8
  0026d	48 6b d2 01	 imul	 rdx, rdx, 1
  00271	4c 8b 84 24 98
	00 00 00	 mov	 r8, QWORD PTR regs$[rsp]
  00279	41 8b 94 10 80
	02 00 00	 mov	 edx, DWORD PTR [r8+rdx+640]
  00281	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR [rsp+48], 0
  0028a	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  0028f	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG181301
  00296	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  0029b	44 8b c9	 mov	 r9d, ecx
  0029e	44 8b c2	 mov	 r8d, edx
  002a1	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG181302
  002a8	b9 10 00 00 00	 mov	 ecx, 16
  002ad	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ptt_pthread_trace
$LN21@s390_store:
  002b3	33 c0		 xor	 eax, eax
  002b5	85 c0		 test	 eax, eax
  002b7	0f 85 72 ff ff
	ff		 jne	 $LN13@s390_store

; 1789 :         regs->psw.cc = 3;

  002bd	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  002c5	c6 40 7c 03	 mov	 BYTE PTR [rax+124], 3

; 1790 :         return;

  002c9	e9 e4 00 00 00	 jmp	 $LN1@s390_store
$LN20@s390_store:

; 1791 :     }
; 1792 : 
; 1793 :     STORE_W(zpb.mso,sysblk.zpb[zone].mso);

  002ce	48 63 44 24 40	 movsxd	 rax, DWORD PTR zone$[rsp]
  002d3	48 6b c0 38	 imul	 rax, rax, 56		; 00000038H
  002d7	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  002de	8b 8c 01 a0 0e
	00 00		 mov	 ecx, DWORD PTR [rcx+rax+3744]
  002e5	e8 00 00 00 00	 call	 _byteswap_ulong
  002ea	8b d0		 mov	 edx, eax
  002ec	48 8d 4c 24 58	 lea	 rcx, QWORD PTR zpb$[rsp]
  002f1	e8 00 00 00 00	 call	 store_fw_noswap

; 1794 :     STORE_W(zpb.msl,sysblk.zpb[zone].msl);

  002f6	48 63 44 24 40	 movsxd	 rax, DWORD PTR zone$[rsp]
  002fb	48 6b c0 38	 imul	 rax, rax, 56		; 00000038H
  002ff	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  00306	8b 8c 01 a8 0e
	00 00		 mov	 ecx, DWORD PTR [rcx+rax+3752]
  0030d	e8 00 00 00 00	 call	 _byteswap_ulong
  00312	8b d0		 mov	 edx, eax
  00314	48 8d 4c 24 5c	 lea	 rcx, QWORD PTR zpb$[rsp+4]
  00319	e8 00 00 00 00	 call	 store_fw_noswap

; 1795 :     STORE_W(zpb.eso,sysblk.zpb[zone].eso);

  0031e	48 63 44 24 40	 movsxd	 rax, DWORD PTR zone$[rsp]
  00323	48 6b c0 38	 imul	 rax, rax, 56		; 00000038H
  00327	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  0032e	8b 8c 01 b0 0e
	00 00		 mov	 ecx, DWORD PTR [rcx+rax+3760]
  00335	e8 00 00 00 00	 call	 _byteswap_ulong
  0033a	8b d0		 mov	 edx, eax
  0033c	48 8d 4c 24 60	 lea	 rcx, QWORD PTR zpb$[rsp+8]
  00341	e8 00 00 00 00	 call	 store_fw_noswap

; 1796 :     STORE_W(zpb.esl,sysblk.zpb[zone].esl);

  00346	48 63 44 24 40	 movsxd	 rax, DWORD PTR zone$[rsp]
  0034b	48 6b c0 38	 imul	 rax, rax, 56		; 00000038H
  0034f	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  00356	8b 8c 01 b8 0e
	00 00		 mov	 ecx, DWORD PTR [rcx+rax+3768]
  0035d	e8 00 00 00 00	 call	 _byteswap_ulong
  00362	8b d0		 mov	 edx, eax
  00364	48 8d 4c 24 64	 lea	 rcx, QWORD PTR zpb$[rsp+12]
  00369	e8 00 00 00 00	 call	 store_fw_noswap

; 1797 : 
; 1798 :     ARCH_DEP(vstorec(&zpb, sizeof(ZPB)-1,regs->GR(2), 2, regs));

  0036e	b8 08 00 00 00	 mov	 eax, 8
  00373	48 6b c0 02	 imul	 rax, rax, 2
  00377	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0037f	48 89 4c 24 20	 mov	 QWORD PTR [rsp+32], rcx
  00384	41 b9 02 00 00
	00		 mov	 r9d, 2
  0038a	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00392	44 8b 84 01 80
	02 00 00	 mov	 r8d, DWORD PTR [rcx+rax+640]
  0039a	b2 1f		 mov	 dl, 31
  0039c	48 8d 4c 24 58	 lea	 rcx, QWORD PTR zpb$[rsp]
  003a1	e8 00 00 00 00	 call	 s390_vstorec

; 1799 : 
; 1800 :     regs->psw.cc = 0;

  003a6	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  003ae	c6 40 7c 00	 mov	 BYTE PTR [rax+124], 0
$LN1@s390_store:
$LN22@s390_store:

; 1801 : }

  003b2	48 8b 4c 24 78	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  003b7	48 33 cc	 xor	 rcx, rsp
  003ba	e8 00 00 00 00	 call	 __security_check_cookie
  003bf	48 81 c4 88 00
	00 00		 add	 rsp, 136		; 00000088H
  003c6	c3		 ret	 0
s390_store_zone_parameter ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\sie.c
_TEXT	SEGMENT
effective_addr2$ = 64
temp$1 = 72
b2$ = 76
zone$ = 80
ioid$ = 84
ioparm$ = 88
iointid$ = 92
tpziid$ = 96
__$ArrayPad$ = 112
inst$ = 144
regs$ = 152
s390_test_pending_zone_interrupt PROC

; 1868 : {

$LN30:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 81 ec 88 00
	00 00		 sub	 rsp, 136		; 00000088H
  00011	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00018	48 33 c4	 xor	 rax, rsp
  0001b	48 89 44 24 70	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 1869 : int     b2;                             /* Values of R fields        */
; 1870 : RADR    effective_addr2;                /* address of state desc.    */
; 1871 : U32     ioid;                           /* I/O interruption address  */
; 1872 : U32     ioparm;                         /* I/O interruption parameter*/
; 1873 : U32     iointid;                        /* I/O interruption ident    */
; 1874 : FWORD   tpziid[3];
; 1875 : int     zone;                           /* Zone number               */
; 1876 : 
; 1877 :     S(inst, regs, b2, effective_addr2);

  00020	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR inst$[rsp]
  00028	e8 00 00 00 00	 call	 fetch_fw_noswap
  0002d	8b c8		 mov	 ecx, eax
  0002f	e8 00 00 00 00	 call	 _byteswap_ulong
  00034	89 44 24 48	 mov	 DWORD PTR temp$1[rsp], eax
  00038	8b 44 24 48	 mov	 eax, DWORD PTR temp$1[rsp]
  0003c	25 ff 0f 00 00	 and	 eax, 4095		; 00000fffH
  00041	8b c0		 mov	 eax, eax
  00043	48 89 44 24 40	 mov	 QWORD PTR effective_addr2$[rsp], rax
  00048	8b 44 24 48	 mov	 eax, DWORD PTR temp$1[rsp]
  0004c	c1 e8 0c	 shr	 eax, 12
  0004f	83 e0 0f	 and	 eax, 15
  00052	89 44 24 4c	 mov	 DWORD PTR b2$[rsp], eax
  00056	83 7c 24 4c 00	 cmp	 DWORD PTR b2$[rsp], 0
  0005b	74 42		 je	 SHORT $LN17@s390_test_
  0005d	48 63 44 24 4c	 movsxd	 rax, DWORD PTR b2$[rsp]
  00062	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0006a	8b 84 c1 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax*8+640]
  00071	48 8b 4c 24 40	 mov	 rcx, QWORD PTR effective_addr2$[rsp]
  00076	48 03 c8	 add	 rcx, rax
  00079	48 8b c1	 mov	 rax, rcx
  0007c	48 89 44 24 40	 mov	 QWORD PTR effective_addr2$[rsp], rax
  00081	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00089	8b 80 90 00 00
	00		 mov	 eax, DWORD PTR [rax+144]
  0008f	48 8b 4c 24 40	 mov	 rcx, QWORD PTR effective_addr2$[rsp]
  00094	48 23 c8	 and	 rcx, rax
  00097	48 8b c1	 mov	 rax, rcx
  0009a	48 89 44 24 40	 mov	 QWORD PTR effective_addr2$[rsp], rax
$LN17@s390_test_:
$LN4@s390_test_:
  0009f	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  000a7	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  000ab	48 83 c0 04	 add	 rax, 4
  000af	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  000b7	48 89 41 68	 mov	 QWORD PTR [rcx+104], rax
  000bb	33 c0		 xor	 eax, eax
  000bd	83 f8 04	 cmp	 eax, 4
  000c0	74 0f		 je	 SHORT $LN18@s390_test_
  000c2	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  000ca	c6 80 9a 00 00
	00 04		 mov	 BYTE PTR [rax+154], 4
$LN18@s390_test_:
  000d1	33 c0		 xor	 eax, eax
  000d3	85 c0		 test	 eax, eax
  000d5	75 c8		 jne	 SHORT $LN4@s390_test_

; 1878 : 
; 1879 :     TXF_INSTR_CHECK( regs );
; 1880 :     PRIV_CHECK(regs);

  000d7	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  000df	0f b6 40 7a	 movzx	 eax, BYTE PTR [rax+122]
  000e3	83 e0 01	 and	 eax, 1
  000e6	85 c0		 test	 eax, eax
  000e8	74 1b		 je	 SHORT $LN19@s390_test_
  000ea	ba 02 00 00 00	 mov	 edx, 2
  000ef	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  000f7	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  000ff	ff 90 20 0d 00
	00		 call	 QWORD PTR [rax+3360]
$LN19@s390_test_:
$LN7@s390_test_:

; 1881 : 
; 1882 :     SIE_INTERCEPT(regs);

  00105	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0010d	8b 80 c8 08 00
	00		 mov	 eax, DWORD PTR [rax+2248]
  00113	d1 e8		 shr	 eax, 1
  00115	83 e0 01	 and	 eax, 1
  00118	85 c0		 test	 eax, eax
  0011a	74 1b		 je	 SHORT $LN20@s390_test_
  0011c	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00124	48 05 80 09 00
	00		 add	 rax, 2432		; 00000980H
  0012a	ba fc ff ff ff	 mov	 edx, -4
  0012f	48 8b c8	 mov	 rcx, rax
  00132	e8 00 00 00 00	 call	 longjmp
$LN20@s390_test_:
  00137	33 c0		 xor	 eax, eax
  00139	85 c0		 test	 eax, eax
  0013b	75 c8		 jne	 SHORT $LN7@s390_test_
$LN10@s390_test_:

; 1883 : 
; 1884 :     PTT_IO("TPZI", regs->GR_L(1),(U32)(effective_addr2 & 0xffffffff),regs->psw.IA_L);

  0013d	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_pttclass
  00144	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00147	48 25 00 02 00
	00		 and	 rax, 512		; 00000200H
  0014d	48 85 c0	 test	 rax, rax
  00150	74 6b		 je	 SHORT $LN21@s390_test_
  00152	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0015a	8b 80 88 00 00
	00		 mov	 eax, DWORD PTR [rax+136]
  00160	b9 ff ff ff ff	 mov	 ecx, -1			; ffffffffH
  00165	48 8b 54 24 40	 mov	 rdx, QWORD PTR effective_addr2$[rsp]
  0016a	48 23 d1	 and	 rdx, rcx
  0016d	48 8b ca	 mov	 rcx, rdx
  00170	8b c9		 mov	 ecx, ecx
  00172	ba 08 00 00 00	 mov	 edx, 8
  00177	48 6b d2 01	 imul	 rdx, rdx, 1
  0017b	4c 8b 84 24 98
	00 00 00	 mov	 r8, QWORD PTR regs$[rsp]
  00183	41 8b 94 10 80
	02 00 00	 mov	 edx, DWORD PTR [r8+rdx+640]
  0018b	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR [rsp+48], 0
  00194	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  00199	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG181405
  001a0	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  001a5	44 8b c9	 mov	 r9d, ecx
  001a8	44 8b c2	 mov	 r8d, edx
  001ab	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG181406
  001b2	b9 00 02 00 00	 mov	 ecx, 512		; 00000200H
  001b7	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ptt_pthread_trace
$LN21@s390_test_:
  001bd	33 c0		 xor	 eax, eax
  001bf	85 c0		 test	 eax, eax
  001c1	0f 85 76 ff ff
	ff		 jne	 $LN10@s390_test_

; 1885 : 
; 1886 :     FW_CHECK(regs->GR(2), regs);

  001c7	b8 08 00 00 00	 mov	 eax, 8
  001cc	48 6b c0 02	 imul	 rax, rax, 2
  001d0	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  001d8	8b 84 01 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax+640]
  001df	83 e0 03	 and	 eax, 3
  001e2	85 c0		 test	 eax, eax
  001e4	74 1b		 je	 SHORT $LN22@s390_test_
  001e6	ba 06 00 00 00	 mov	 edx, 6
  001eb	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  001f3	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  001fb	ff 90 20 0d 00
	00		 call	 QWORD PTR [rax+3360]
$LN22@s390_test_:

; 1887 : 
; 1888 :     /* Perform serialization and checkpoint-synchronization */
; 1889 :     PERFORM_SERIALIZATION (regs);

  00201	0f ae f0	 mfence
$LN13@s390_test_:

; 1890 :     PERFORM_CHKPT_SYNC (regs);

  00204	33 c0		 xor	 eax, eax
  00206	85 c0		 test	 eax, eax
  00208	75 fa		 jne	 SHORT $LN13@s390_test_

; 1891 : 
; 1892 :     zone = regs->GR_LHLCL(1);

  0020a	b8 08 00 00 00	 mov	 eax, 8
  0020f	48 6b c0 01	 imul	 rax, rax, 1
  00213	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0021b	0f b6 84 01 80
	02 00 00	 movzx	 eax, BYTE PTR [rcx+rax+640]
  00223	89 44 24 50	 mov	 DWORD PTR zone$[rsp], eax

; 1893 : 
; 1894 :     if(zone >= FEATURE_SIE_MAXZONES)

  00227	83 7c 24 50 08	 cmp	 DWORD PTR zone$[rsp], 8
  0022c	0f 8c 99 00 00
	00		 jl	 $LN23@s390_test_
$LN16@s390_test_:

; 1895 :     {
; 1896 :         PTT_ERR("*TPZI", regs->GR_L(1),(U32)(effective_addr2 & 0xffffffff),regs->psw.IA_L);

  00232	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_pttclass
  00239	48 8b 00	 mov	 rax, QWORD PTR [rax]
  0023c	48 83 e0 10	 and	 rax, 16
  00240	48 85 c0	 test	 rax, rax
  00243	74 6b		 je	 SHORT $LN24@s390_test_
  00245	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0024d	8b 80 88 00 00
	00		 mov	 eax, DWORD PTR [rax+136]
  00253	b9 ff ff ff ff	 mov	 ecx, -1			; ffffffffH
  00258	48 8b 54 24 40	 mov	 rdx, QWORD PTR effective_addr2$[rsp]
  0025d	48 23 d1	 and	 rdx, rcx
  00260	48 8b ca	 mov	 rcx, rdx
  00263	8b c9		 mov	 ecx, ecx
  00265	ba 08 00 00 00	 mov	 edx, 8
  0026a	48 6b d2 01	 imul	 rdx, rdx, 1
  0026e	4c 8b 84 24 98
	00 00 00	 mov	 r8, QWORD PTR regs$[rsp]
  00276	41 8b 94 10 80
	02 00 00	 mov	 edx, DWORD PTR [r8+rdx+640]
  0027e	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR [rsp+48], 0
  00287	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  0028c	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG181410
  00293	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00298	44 8b c9	 mov	 r9d, ecx
  0029b	44 8b c2	 mov	 r8d, edx
  0029e	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG181411
  002a5	b9 10 00 00 00	 mov	 ecx, 16
  002aa	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ptt_pthread_trace
$LN24@s390_test_:
  002b0	33 c0		 xor	 eax, eax
  002b2	85 c0		 test	 eax, eax
  002b4	0f 85 78 ff ff
	ff		 jne	 $LN16@s390_test_

; 1897 :         regs->psw.cc = 0;

  002ba	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  002c2	c6 40 7c 00	 mov	 BYTE PTR [rax+124], 0

; 1898 :         return;

  002c6	e9 32 01 00 00	 jmp	 $LN1@s390_test_
$LN23@s390_test_:

; 1899 :     }
; 1900 : 
; 1901 :     if( IS_IC_IOPENDING )

  002cb	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  002d2	8b 80 a0 12 00
	00		 mov	 eax, DWORD PTR [rax+4768]
  002d8	25 00 00 00 40	 and	 eax, 1073741824		; 40000000H
  002dd	85 c0		 test	 eax, eax
  002df	0f 84 0c 01 00
	00		 je	 $LN25@s390_test_

; 1902 :     {
; 1903 :         /* Obtain the interrupt lock */
; 1904 :         OBTAIN_INTLOCK(regs);

  002e5	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG181414
  002ec	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  002f4	e8 00 00 00 00	 call	 Obtain_Interrupt_Lock

; 1905 : 
; 1906 :         /* Test (but don't clear!) pending interrupt, and set condition code */
; 1907 :         if( ARCH_DEP(present_zone_io_interrupt) (&ioid, &ioparm,

  002f9	44 0f b6 4c 24
	50		 movzx	 r9d, BYTE PTR zone$[rsp]
  002ff	4c 8d 44 24 5c	 lea	 r8, QWORD PTR iointid$[rsp]
  00304	48 8d 54 24 58	 lea	 rdx, QWORD PTR ioparm$[rsp]
  00309	48 8d 4c 24 54	 lea	 rcx, QWORD PTR ioid$[rsp]
  0030e	e8 00 00 00 00	 call	 s390_present_zone_io_interrupt
  00313	85 c0		 test	 eax, eax
  00315	0f 84 b4 00 00
	00		 je	 $LN27@s390_test_

; 1908 :                                                        &iointid, zone) )
; 1909 : 
; 1910 :         /* Store the SSID word and I/O parameter if an interrupt was pending */
; 1911 :         {
; 1912 :             /* Store interruption parms */
; 1913 :             STORE_FW(tpziid[0],ioid);

  0031b	8b 4c 24 54	 mov	 ecx, DWORD PTR ioid$[rsp]
  0031f	e8 00 00 00 00	 call	 _byteswap_ulong
  00324	b9 04 00 00 00	 mov	 ecx, 4
  00329	48 6b c9 00	 imul	 rcx, rcx, 0
  0032d	48 8d 4c 0c 60	 lea	 rcx, QWORD PTR tpziid$[rsp+rcx]
  00332	8b d0		 mov	 edx, eax
  00334	e8 00 00 00 00	 call	 store_fw_noswap

; 1914 :             STORE_FW(tpziid[1],ioparm);

  00339	8b 4c 24 58	 mov	 ecx, DWORD PTR ioparm$[rsp]
  0033d	e8 00 00 00 00	 call	 _byteswap_ulong
  00342	b9 04 00 00 00	 mov	 ecx, 4
  00347	48 6b c9 01	 imul	 rcx, rcx, 1
  0034b	48 8d 4c 0c 60	 lea	 rcx, QWORD PTR tpziid$[rsp+rcx]
  00350	8b d0		 mov	 edx, eax
  00352	e8 00 00 00 00	 call	 store_fw_noswap

; 1915 :             STORE_FW(tpziid[2],iointid);

  00357	8b 4c 24 5c	 mov	 ecx, DWORD PTR iointid$[rsp]
  0035b	e8 00 00 00 00	 call	 _byteswap_ulong
  00360	b9 04 00 00 00	 mov	 ecx, 4
  00365	48 6b c9 02	 imul	 rcx, rcx, 2
  00369	48 8d 4c 0c 60	 lea	 rcx, QWORD PTR tpziid$[rsp+rcx]
  0036e	8b d0		 mov	 edx, eax
  00370	e8 00 00 00 00	 call	 store_fw_noswap

; 1916 : 
; 1917 :             /* Release the interrupt lock */
; 1918 :             RELEASE_INTLOCK(regs);

  00375	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG181417
  0037c	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00384	e8 00 00 00 00	 call	 Release_Interrupt_Lock

; 1919 : 
; 1920 :             ARCH_DEP(vstorec(&tpziid, sizeof(tpziid)-1,regs->GR(2), 2, regs));

  00389	b8 08 00 00 00	 mov	 eax, 8
  0038e	48 6b c0 02	 imul	 rax, rax, 2
  00392	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0039a	48 89 4c 24 20	 mov	 QWORD PTR [rsp+32], rcx
  0039f	41 b9 02 00 00
	00		 mov	 r9d, 2
  003a5	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  003ad	44 8b 84 01 80
	02 00 00	 mov	 r8d, DWORD PTR [rcx+rax+640]
  003b5	b2 0b		 mov	 dl, 11
  003b7	48 8d 4c 24 60	 lea	 rcx, QWORD PTR tpziid$[rsp]
  003bc	e8 00 00 00 00	 call	 s390_vstorec

; 1921 : 
; 1922 :             regs->psw.cc = 1;

  003c1	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  003c9	c6 40 7c 01	 mov	 BYTE PTR [rax+124], 1

; 1923 :         }

  003cd	eb 20		 jmp	 SHORT $LN28@s390_test_
$LN27@s390_test_:

; 1924 :         else
; 1925 :         {
; 1926 :             /* Release the interrupt lock */
; 1927 :             RELEASE_INTLOCK(regs);

  003cf	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG181418
  003d6	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  003de	e8 00 00 00 00	 call	 Release_Interrupt_Lock

; 1928 :             regs->psw.cc = 0;

  003e3	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  003eb	c6 40 7c 00	 mov	 BYTE PTR [rax+124], 0
$LN28@s390_test_:

; 1929 :         }
; 1930 : 
; 1931 :     }

  003ef	eb 0c		 jmp	 SHORT $LN26@s390_test_
$LN25@s390_test_:

; 1932 :     else
; 1933 :         regs->psw.cc = 0;

  003f1	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  003f9	c6 40 7c 00	 mov	 BYTE PTR [rax+124], 0
$LN26@s390_test_:
$LN1@s390_test_:
$LN29@s390_test_:

; 1934 : }

  003fd	48 8b 4c 24 70	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  00402	48 33 cc	 xor	 rcx, rsp
  00405	e8 00 00 00 00	 call	 __security_check_cookie
  0040a	48 81 c4 88 00
	00 00		 add	 rsp, 136		; 00000088H
  00411	c3		 ret	 0
s390_test_pending_zone_interrupt ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\sie.c
_TEXT	SEGMENT
icode$ = 96
effective_addr2$ = 104
n$ = 112
lpsw_xcode$ = 116
same_cpu$ = 120
same_state$ = 121
lhcpu$ = 124
tv989 = 128
mso$1 = 136
temp$2 = 144
b2$ = 148
tv327 = 152
tv968 = 156
tv970 = 160
tv973 = 164
tv975 = 168
itimer$3 = 172
olditimer$4 = 176
msl$5 = 184
tv227 = 192
residue$6 = 196
tv217 = 200
eso$7 = 208
esl$8 = 216
tv221 = 224
tv229 = 232
dreg$ = 240
sie_state$ = 248
p$9 = 256
tv1458 = 264
inst$ = 304
regs$ = 312
s390_start_interpretive_execution PROC

; 308  : {

$LN180:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	56		 push	 rsi
  0000b	57		 push	 rdi
  0000c	48 81 ec 18 01
	00 00		 sub	 rsp, 280		; 00000118H

; 309  : int     b2;                             /* Values of R fields        */
; 310  : RADR    effective_addr2;                /* address of state desc.    */
; 311  : int     n;                              /* Loop counter              */
; 312  : U16     lhcpu;                          /* Last Host CPU address     */
; 313  : U64     sie_state;                      /* Last SIE state            */
; 314  : int lpsw_xcode;                         /* xcode from load_psw       */
; 315  : volatile int icode = 0;                 /* interrupt code            */

  00013	c7 44 24 60 00
	00 00 00	 mov	 DWORD PTR icode$[rsp], 0

; 316  :                                         /* (why is this volatile?!)  */
; 317  : bool    same_cpu, same_state;           /* boolean helper flags      */
; 318  : U64     dreg;
; 319  : 
; 320  : #if defined( FEATURE_VIRTUAL_ARCHITECTURE_LEVEL )
; 321  : U32     fld;                            /* Facility List Designator  */
; 322  : #if !defined( OPTION_SIE2BK_FLD_COPY)
; 323  : int     i;                              /* (work)                    */
; 324  : #endif
; 325  : #endif
; 326  : 
; 327  :     //-----------------------------------------------------------
; 328  :     //             IMPORTANT SIE PROGRAMMING NOTE!
; 329  :     //-----------------------------------------------------------
; 330  :     // NOTE: Our execution architectural mode is that of the SIE
; 331  :     // HOST and our 'regs' variable is pointing the the HOST's
; 332  :     // registers. Since the GUEST could be running in a completely
; 333  :     // different architecture from the HOST, if you need to call
; 334  :     // a ARCH_DEP function for the GUEST (passing it GUESTREGS),
; 335  :     // you must TAKE SPECIAL CARE to ensure the correct version
; 336  :     // of that function is called! You cannot simply call the
; 337  :     // "ARCH_DEP" version of that function as they are for the
; 338  :     // architectue of the HOST, not the GUEST! (i.e. you cannot
; 339  :     // call a "z900_xxx" function expecting it to work correctly
; 340  :     // if the GUEST is supposed to call "s390_xxx" functions!)
; 341  :     //-----------------------------------------------------------
; 342  : 
; 343  :     S( inst, regs, b2, effective_addr2 );

  0001b	48 8b 8c 24 30
	01 00 00	 mov	 rcx, QWORD PTR inst$[rsp]
  00023	e8 00 00 00 00	 call	 fetch_fw_noswap
  00028	8b c8		 mov	 ecx, eax
  0002a	e8 00 00 00 00	 call	 _byteswap_ulong
  0002f	89 84 24 90 00
	00 00		 mov	 DWORD PTR temp$2[rsp], eax
  00036	8b 84 24 90 00
	00 00		 mov	 eax, DWORD PTR temp$2[rsp]
  0003d	25 ff 0f 00 00	 and	 eax, 4095		; 00000fffH
  00042	8b c0		 mov	 eax, eax
  00044	48 89 44 24 68	 mov	 QWORD PTR effective_addr2$[rsp], rax
  00049	8b 84 24 90 00
	00 00		 mov	 eax, DWORD PTR temp$2[rsp]
  00050	c1 e8 0c	 shr	 eax, 12
  00053	83 e0 0f	 and	 eax, 15
  00056	89 84 24 94 00
	00 00		 mov	 DWORD PTR b2$[rsp], eax
  0005d	83 bc 24 94 00
	00 00 00	 cmp	 DWORD PTR b2$[rsp], 0
  00065	74 45		 je	 SHORT $LN106@s390_start
  00067	48 63 84 24 94
	00 00 00	 movsxd	 rax, DWORD PTR b2$[rsp]
  0006f	48 8b 8c 24 38
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00077	8b 84 c1 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax*8+640]
  0007e	48 8b 4c 24 68	 mov	 rcx, QWORD PTR effective_addr2$[rsp]
  00083	48 03 c8	 add	 rcx, rax
  00086	48 8b c1	 mov	 rax, rcx
  00089	48 89 44 24 68	 mov	 QWORD PTR effective_addr2$[rsp], rax
  0008e	48 8b 84 24 38
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00096	8b 80 90 00 00
	00		 mov	 eax, DWORD PTR [rax+144]
  0009c	48 8b 4c 24 68	 mov	 rcx, QWORD PTR effective_addr2$[rsp]
  000a1	48 23 c8	 and	 rcx, rax
  000a4	48 8b c1	 mov	 rax, rcx
  000a7	48 89 44 24 68	 mov	 QWORD PTR effective_addr2$[rsp], rax
$LN106@s390_start:
$LN4@s390_start:
  000ac	48 8b 84 24 38
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  000b4	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  000b8	48 83 c0 04	 add	 rax, 4
  000bc	48 8b 8c 24 38
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  000c4	48 89 41 68	 mov	 QWORD PTR [rcx+104], rax
  000c8	33 c0		 xor	 eax, eax
  000ca	83 f8 04	 cmp	 eax, 4
  000cd	74 0f		 je	 SHORT $LN107@s390_start
  000cf	48 8b 84 24 38
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  000d7	c6 80 9a 00 00
	00 04		 mov	 BYTE PTR [rax+154], 4
$LN107@s390_start:
  000de	33 c0		 xor	 eax, eax
  000e0	85 c0		 test	 eax, eax
  000e2	75 c8		 jne	 SHORT $LN4@s390_start

; 344  :     PER_ZEROADDR_XCHECK( regs, b2 );
; 345  : 
; 346  :     TXF_INSTR_CHECK( regs );
; 347  :     PRIV_CHECK( regs );

  000e4	48 8b 84 24 38
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  000ec	0f b6 40 7a	 movzx	 eax, BYTE PTR [rax+122]
  000f0	83 e0 01	 and	 eax, 1
  000f3	85 c0		 test	 eax, eax
  000f5	74 1b		 je	 SHORT $LN108@s390_start
  000f7	ba 02 00 00 00	 mov	 edx, 2
  000fc	48 8b 8c 24 38
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00104	48 8b 84 24 38
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0010c	ff 90 20 0d 00
	00		 call	 QWORD PTR [rax+3360]
$LN108@s390_start:
$LN7@s390_start:

; 348  : 
; 349  :     SIE_INTERCEPT( regs );

  00112	48 8b 84 24 38
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0011a	8b 80 c8 08 00
	00		 mov	 eax, DWORD PTR [rax+2248]
  00120	d1 e8		 shr	 eax, 1
  00122	83 e0 01	 and	 eax, 1
  00125	85 c0		 test	 eax, eax
  00127	74 1b		 je	 SHORT $LN109@s390_start
  00129	48 8b 84 24 38
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00131	48 05 80 09 00
	00		 add	 rax, 2432		; 00000980H
  00137	ba fc ff ff ff	 mov	 edx, -4
  0013c	48 8b c8	 mov	 rcx, rax
  0013f	e8 00 00 00 00	 call	 longjmp
$LN109@s390_start:
  00144	33 c0		 xor	 eax, eax
  00146	85 c0		 test	 eax, eax
  00148	75 c8		 jne	 SHORT $LN7@s390_start
$LN10@s390_start:

; 350  : 
; 351  :     PTT_SIE( "SIE", regs->GR(14), regs->GR(15), effective_addr2);

  0014a	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_pttclass
  00151	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00154	48 25 80 00 00
	00		 and	 rax, 128		; 00000080H
  0015a	48 85 c0	 test	 rax, rax
  0015d	74 67		 je	 SHORT $LN110@s390_start
  0015f	b8 08 00 00 00	 mov	 eax, 8
  00164	48 6b c0 0f	 imul	 rax, rax, 15
  00168	48 8b 8c 24 38
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00170	8b 84 01 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax+640]
  00177	b9 08 00 00 00	 mov	 ecx, 8
  0017c	48 6b c9 0e	 imul	 rcx, rcx, 14
  00180	48 8b 94 24 38
	01 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  00188	8b 8c 0a 80 02
	00 00		 mov	 ecx, DWORD PTR [rdx+rcx+640]
  0018f	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR [rsp+48], 0
  00198	48 8b 54 24 68	 mov	 rdx, QWORD PTR effective_addr2$[rsp]
  0019d	48 89 54 24 28	 mov	 QWORD PTR [rsp+40], rdx
  001a2	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG180557
  001a9	48 89 54 24 20	 mov	 QWORD PTR [rsp+32], rdx
  001ae	44 8b c8	 mov	 r9d, eax
  001b1	44 8b c1	 mov	 r8d, ecx
  001b4	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG180558
  001bb	b9 80 00 00 00	 mov	 ecx, 128		; 00000080H
  001c0	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ptt_pthread_trace
$LN110@s390_start:
  001c6	33 c0		 xor	 eax, eax
  001c8	85 c0		 test	 eax, eax
  001ca	0f 85 7a ff ff
	ff		 jne	 $LN10@s390_start

; 352  : 
; 353  :     SIE_PERFMON( SIE_PERF_ENTER );
; 354  : 
; 355  : #if !defined( FEATURE_001_ZARCH_INSTALLED_FACILITY ) && !defined( FEATURE_MULTIPLE_CONTROLLED_DATA_SPACE )
; 356  :     if (!regs->psw.amode || !PRIMARY_SPACE_MODE( &regs->psw ))
; 357  :         ARCH_DEP( program_interrupt )( regs, PGM_SPECIAL_OPERATION_EXCEPTION );
; 358  : #endif
; 359  : 
; 360  :     if (0
; 361  :         || (effective_addr2 & (sizeof(SIEBK)-1)) != 0
; 362  : 
; 363  : #if defined( FEATURE_001_ZARCH_INSTALLED_FACILITY )
; 364  : 
; 365  :         || (effective_addr2 & PREFIXING_900_MASK) == 0
; 366  :         || (effective_addr2 & PREFIXING_900_MASK) == regs->PX_900
; 367  : 
; 368  : #elif defined( FEATURE_S390_DAT )
; 369  :         || (effective_addr2 & PREFIXING_390_MASK) == 0
; 370  :         || (effective_addr2 & PREFIXING_390_MASK) == regs->PX_390

  001d0	33 c0		 xor	 eax, eax
  001d2	85 c0		 test	 eax, eax
  001d4	75 3b		 jne	 SHORT $LN112@s390_start
  001d6	48 8b 44 24 68	 mov	 rax, QWORD PTR effective_addr2$[rsp]
  001db	48 25 ff 00 00
	00		 and	 rax, 255		; 000000ffH
  001e1	48 85 c0	 test	 rax, rax
  001e4	75 2b		 jne	 SHORT $LN112@s390_start
  001e6	48 8b 44 24 68	 mov	 rax, QWORD PTR effective_addr2$[rsp]
  001eb	48 25 00 f0 ff
	ff		 and	 rax, -4096		; fffffffffffff000H
  001f1	48 85 c0	 test	 rax, rax
  001f4	74 1b		 je	 SHORT $LN112@s390_start
  001f6	48 8b 44 24 68	 mov	 rax, QWORD PTR effective_addr2$[rsp]
  001fb	48 25 00 f0 ff
	ff		 and	 rax, -4096		; fffffffffffff000H
  00201	48 8b 8c 24 38
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00209	8b 49 70	 mov	 ecx, DWORD PTR [rcx+112]
  0020c	48 3b c1	 cmp	 rax, rcx
  0020f	75 12		 jne	 SHORT $LN111@s390_start
$LN112@s390_start:

; 371  : #else
; 372  :         || (effective_addr2 & PREFIXING_370_MASK) == 0
; 373  :         || (effective_addr2 & PREFIXING_370_MASK) == regs->PX_370
; 374  : #endif
; 375  :     )
; 376  :         ARCH_DEP( program_interrupt )( regs, PGM_SPECIFICATION_EXCEPTION );

  00211	ba 06 00 00 00	 mov	 edx, 6
  00216	48 8b 8c 24 38
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0021e	e8 00 00 00 00	 call	 s390_program_interrupt
$LN111@s390_start:

; 377  : 
; 378  :     /* Perform serialization and checkpoint synchronization */
; 379  :     PERFORM_SERIALIZATION( regs );

  00223	0f ae f0	 mfence
$LN13@s390_start:

; 380  :     PERFORM_CHKPT_SYNC( regs );

  00226	33 c0		 xor	 eax, eax
  00228	85 c0		 test	 eax, eax
  0022a	75 fa		 jne	 SHORT $LN13@s390_start

; 381  : 
; 382  : #if defined( SIE_DEBUG )
; 383  :     LOGMSG( "SIE: state descriptor " F_RADR "\n", effective_addr2 );
; 384  :     ARCH_DEP( display_inst )( regs, regs->instinvalid ? NULL : regs->ip );
; 385  : #endif
; 386  : 
; 387  :     if (effective_addr2 > regs->mainlim - (sizeof( SIEBK ) - 1))

  0022c	48 8b 84 24 38
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00234	48 8b 80 58 08
	00 00		 mov	 rax, QWORD PTR [rax+2136]
  0023b	48 2d ff 00 00
	00		 sub	 rax, 255		; 000000ffH
  00241	48 39 44 24 68	 cmp	 QWORD PTR effective_addr2$[rsp], rax
  00246	76 12		 jbe	 SHORT $LN113@s390_start

; 388  :         ARCH_DEP( program_interrupt )( regs, PGM_ADDRESSING_EXCEPTION );

  00248	ba 05 00 00 00	 mov	 edx, 5
  0024d	48 8b 8c 24 38
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00255	e8 00 00 00 00	 call	 s390_program_interrupt
$LN113@s390_start:
$LN16@s390_start:

; 389  : 
; 390  :     /*
; 391  :      * As long as regs->sie_active is off, no serialization is
; 392  :      * required for GUESTREGS.  sie_active should always be off here.
; 393  :      * Any other thread looking at sie_active holds the intlock.
; 394  :      */
; 395  :     PTT_SIE( "SIE h,g,a", regs->host, regs->guest, regs->sie_active );

  0025a	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_pttclass
  00261	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00264	48 25 80 00 00
	00		 and	 rax, 128		; 00000080H
  0026a	48 85 c0	 test	 rax, rax
  0026d	74 71		 je	 SHORT $LN114@s390_start
  0026f	48 8b 84 24 38
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00277	8b 80 c8 08 00
	00		 mov	 eax, DWORD PTR [rax+2248]
  0027d	83 e0 01	 and	 eax, 1
  00280	8b c0		 mov	 eax, eax
  00282	48 8b 8c 24 38
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0028a	8b 89 28 07 00
	00		 mov	 ecx, DWORD PTR [rcx+1832]
  00290	c1 e9 08	 shr	 ecx, 8
  00293	83 e1 01	 and	 ecx, 1
  00296	8b c9		 mov	 ecx, ecx
  00298	48 8b 94 24 38
	01 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  002a0	8b 92 28 07 00
	00		 mov	 edx, DWORD PTR [rdx+1832]
  002a6	c1 ea 07	 shr	 edx, 7
  002a9	83 e2 01	 and	 edx, 1
  002ac	8b d2		 mov	 edx, edx
  002ae	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR [rsp+48], 0
  002b7	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  002bc	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG180563
  002c3	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  002c8	44 8b c9	 mov	 r9d, ecx
  002cb	44 8b c2	 mov	 r8d, edx
  002ce	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG180564
  002d5	b9 80 00 00 00	 mov	 ecx, 128		; 00000080H
  002da	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ptt_pthread_trace
$LN114@s390_start:
  002e0	33 c0		 xor	 eax, eax
  002e2	85 c0		 test	 eax, eax
  002e4	0f 85 70 ff ff
	ff		 jne	 $LN16@s390_start

; 396  :     if (regs->sie_active)

  002ea	48 8b 84 24 38
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  002f2	8b 80 c8 08 00
	00		 mov	 eax, DWORD PTR [rax+2248]
  002f8	83 e0 01	 and	 eax, 1
  002fb	85 c0		 test	 eax, eax
  002fd	74 47		 je	 SHORT $LN115@s390_start

; 397  :     {
; 398  :         OBTAIN_INTLOCK( regs );

  002ff	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG180566
  00306	48 8b 8c 24 38
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0030e	e8 00 00 00 00	 call	 Obtain_Interrupt_Lock

; 399  :         {
; 400  :             regs->sie_active = 0;

  00313	48 8b 84 24 38
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0031b	8b 80 c8 08 00
	00		 mov	 eax, DWORD PTR [rax+2248]
  00321	83 e0 fe	 and	 eax, -2			; fffffffeH
  00324	48 8b 8c 24 38
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0032c	89 81 c8 08 00
	00		 mov	 DWORD PTR [rcx+2248], eax

; 401  :         }
; 402  :         RELEASE_INTLOCK( regs );

  00332	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG180567
  00339	48 8b 8c 24 38
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00341	e8 00 00 00 00	 call	 Release_Interrupt_Lock
$LN115@s390_start:

; 403  :     }
; 404  : 
; 405  :     /* Initialize guestregs if first time */
; 406  :     if (!GUESTREGS)

  00346	48 8b 84 24 38
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0034e	48 83 b8 70 08
	00 00 00	 cmp	 QWORD PTR [rax+2160], 0
  00356	0f 85 91 01 00
	00		 jne	 $LN116@s390_start
$LN19@s390_start:

; 407  :     {
; 408  :         PTT_SIE( "SIE calloc g", 0, 0, 0 );

  0035c	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_pttclass
  00363	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00366	48 25 80 00 00
	00		 and	 rax, 128		; 00000080H
  0036c	48 85 c0	 test	 rax, rax
  0036f	74 36		 je	 SHORT $LN117@s390_start
  00371	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR [rsp+48], 0
  0037a	48 c7 44 24 28
	00 00 00 00	 mov	 QWORD PTR [rsp+40], 0
  00383	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG180570
  0038a	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  0038f	45 33 c9	 xor	 r9d, r9d
  00392	45 33 c0	 xor	 r8d, r8d
  00395	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG180571
  0039c	b9 80 00 00 00	 mov	 ecx, 128		; 00000080H
  003a1	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ptt_pthread_trace
$LN117@s390_start:
  003a7	33 c0		 xor	 eax, eax
  003a9	85 c0		 test	 eax, eax
  003ab	75 af		 jne	 SHORT $LN19@s390_start

; 409  :         if (!(GUESTREGS = calloc_aligned( sizeof( REGS ), 4096 )))

  003ad	ba 00 10 00 00	 mov	 edx, 4096		; 00001000H
  003b2	b9 80 60 01 00	 mov	 ecx, 90240		; 00016080H
  003b7	e8 00 00 00 00	 call	 calloc_aligned
  003bc	48 89 84 24 c8
	00 00 00	 mov	 QWORD PTR tv217[rsp], rax
  003c4	48 8b 84 24 38
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  003cc	48 8b 8c 24 c8
	00 00 00	 mov	 rcx, QWORD PTR tv217[rsp]
  003d4	48 89 88 70 08
	00 00		 mov	 QWORD PTR [rax+2160], rcx
  003db	48 83 bc 24 c8
	00 00 00 00	 cmp	 QWORD PTR tv217[rsp], 0
  003e4	0f 85 d6 00 00
	00		 jne	 $LN118@s390_start

; 410  :         {
; 411  :             // "Processor %s%02X: error in function %s: %s"
; 412  :             WRMSG( HHC00813, "E", PTYPSTR( regs->cpuad ), regs->cpuad, "calloc()", strerror( errno ));

  003ea	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno
  003f0	8b 08		 mov	 ecx, DWORD PTR [rax]
  003f2	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_strerror
  003f8	48 89 84 24 e0
	00 00 00	 mov	 QWORD PTR tv221[rsp], rax
  00400	48 8b 8c 24 38
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00408	0f b7 89 3c 08
	00 00		 movzx	 ecx, WORD PTR [rcx+2108]
  0040f	89 8c 24 c0 00
	00 00		 mov	 DWORD PTR tv227[rsp], ecx
  00416	48 8b 94 24 38
	01 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  0041e	0f b7 92 3c 08
	00 00		 movzx	 edx, WORD PTR [rdx+2108]
  00425	4c 8b 05 00 00
	00 00		 mov	 r8, QWORD PTR __imp_sysblk
  0042c	41 0f b6 8c 10
	48 0b 00 00	 movzx	 ecx, BYTE PTR [r8+rdx+2888]
  00435	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ptyp2short
  0043b	48 89 84 24 e8
	00 00 00	 mov	 QWORD PTR tv229[rsp], rax
  00443	b9 01 00 00 00	 mov	 ecx, 1
  00448	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  0044e	48 8b 8c 24 e0
	00 00 00	 mov	 rcx, QWORD PTR tv221[rsp]
  00456	48 89 4c 24 50	 mov	 QWORD PTR [rsp+80], rcx
  0045b	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG180573
  00462	48 89 4c 24 48	 mov	 QWORD PTR [rsp+72], rcx
  00467	8b 8c 24 c0 00
	00 00		 mov	 ecx, DWORD PTR tv227[rsp]
  0046e	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  00472	48 8b 8c 24 e8
	00 00 00	 mov	 rcx, QWORD PTR tv229[rsp]
  0047a	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  0047f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG180574
  00486	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  0048b	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG180575
  00492	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00497	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  0049c	41 b9 03 00 00
	00		 mov	 r9d, 3
  004a2	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG180576
  004a9	ba 9c 01 00 00	 mov	 edx, 412		; 0000019cH
  004ae	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG180577
  004b5	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 413  :             return;

  004bb	e9 ba 22 00 00	 jmp	 $LN1@s390_start
$LN118@s390_start:

; 414  :         }
; 415  :         cpu_init( regs->cpuad, GUESTREGS, regs );

  004c0	48 8b 84 24 38
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  004c8	0f b7 80 3c 08
	00 00		 movzx	 eax, WORD PTR [rax+2108]
  004cf	4c 8b 84 24 38
	01 00 00	 mov	 r8, QWORD PTR regs$[rsp]
  004d7	48 8b 8c 24 38
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  004df	48 8b 91 70 08
	00 00		 mov	 rdx, QWORD PTR [rcx+2160]
  004e6	8b c8		 mov	 ecx, eax
  004e8	e8 00 00 00 00	 call	 cpu_init
$LN116@s390_start:

; 416  :         TXF_ALLOCMAP( GUESTREGS );
; 417  :     }
; 418  : 
; 419  :     /* Direct pointer to state descriptor block */
; 420  :     GUESTREGS->siebk = (void*)(regs->mainstor + effective_addr2);

  004ed	48 8b 84 24 38
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  004f5	48 8b 80 48 08
	00 00		 mov	 rax, QWORD PTR [rax+2120]
  004fc	48 03 44 24 68	 add	 rax, QWORD PTR effective_addr2$[rsp]
  00501	48 8b 8c 24 38
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00509	48 8b 89 70 08
	00 00		 mov	 rcx, QWORD PTR [rcx+2160]
  00510	48 89 81 88 08
	00 00		 mov	 QWORD PTR [rcx+2184], rax

; 421  : 
; 422  :     /* Set the guest's execution arch_mode and load its PSW */
; 423  : #if defined( FEATURE_001_ZARCH_INSTALLED_FACILITY )
; 424  :     if (STATEBK->mx & SIE_MX_ESAME)
; 425  :     {
; 426  :         GUESTREGS->arch_mode = ARCH_900_IDX;
; 427  :         GUESTREGS->program_interrupt = &z900_program_interrupt;
; 428  :         lpsw_xcode = z900_load_psw( GUESTREGS, STATEBK->psw );
; 429  :     }
; 430  : #else /* !defined( FEATURE_001_ZARCH_INSTALLED_FACILITY ) */
; 431  :     if (STATEBK->m & SIE_M_370)

  00517	48 8b 84 24 38
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0051f	48 8b 80 70 08
	00 00		 mov	 rax, QWORD PTR [rax+2160]
  00526	48 8b 80 88 08
	00 00		 mov	 rax, QWORD PTR [rax+2184]
  0052d	0f b6 40 03	 movzx	 eax, BYTE PTR [rax+3]
  00531	83 e0 10	 and	 eax, 16
  00534	85 c0		 test	 eax, eax
  00536	74 6d		 je	 SHORT $LN119@s390_start

; 432  :     {
; 433  : #if defined(_370)
; 434  :         GUESTREGS->arch_mode = ARCH_370_IDX;

  00538	48 8b 84 24 38
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00540	48 8b 80 70 08
	00 00		 mov	 rax, QWORD PTR [rax+2160]
  00547	c7 40 64 00 00
	00 00		 mov	 DWORD PTR [rax+100], 0

; 435  :         GUESTREGS->program_interrupt = &s370_program_interrupt;

  0054e	48 8b 84 24 38
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00556	48 8b 80 70 08
	00 00		 mov	 rax, QWORD PTR [rax+2160]
  0055d	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:s370_program_interrupt
  00564	48 89 88 20 0d
	00 00		 mov	 QWORD PTR [rax+3360], rcx

; 436  :         lpsw_xcode = s370_load_psw(GUESTREGS, STATEBK->psw);

  0056b	48 8b 84 24 38
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00573	48 8b 80 70 08
	00 00		 mov	 rax, QWORD PTR [rax+2160]
  0057a	48 8b 80 88 08
	00 00		 mov	 rax, QWORD PTR [rax+2184]
  00581	48 83 c0 18	 add	 rax, 24
  00585	48 8b d0	 mov	 rdx, rax
  00588	48 8b 84 24 38
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00590	48 8b 88 70 08
	00 00		 mov	 rcx, QWORD PTR [rax+2160]
  00597	e8 00 00 00 00	 call	 s370_load_psw
  0059c	89 44 24 74	 mov	 DWORD PTR lpsw_xcode$[rsp], eax

; 437  : #else
; 438  :         /* Validity intercept when 370 mode not installed */
; 439  :         SIE_SET_VI(SIE_VI_WHO_CPU, SIE_VI_WHEN_SIENT, SIE_VI_WHY_370NI, GUESTREGS);
; 440  :         STATEBK->c = SIE_C_VALIDITY;
; 441  :         return;
; 442  : #endif
; 443  :     }

  005a0	e9 50 01 00 00	 jmp	 $LN120@s390_start
$LN119@s390_start:

; 444  : #endif /* !defined( FEATURE_001_ZARCH_INSTALLED_FACILITY ) */
; 445  :     else
; 446  : #if !defined( FEATURE_001_ZARCH_INSTALLED_FACILITY )
; 447  :     if (STATEBK->m & SIE_M_XA)

  005a5	48 8b 84 24 38
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  005ad	48 8b 80 70 08
	00 00		 mov	 rax, QWORD PTR [rax+2160]
  005b4	48 8b 80 88 08
	00 00		 mov	 rax, QWORD PTR [rax+2184]
  005bb	0f b6 40 03	 movzx	 eax, BYTE PTR [rax+3]
  005bf	83 e0 20	 and	 eax, 32			; 00000020H
  005c2	85 c0		 test	 eax, eax
  005c4	74 6d		 je	 SHORT $LN121@s390_start

; 448  : #endif
; 449  :     {
; 450  :         GUESTREGS->arch_mode = ARCH_390_IDX;

  005c6	48 8b 84 24 38
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  005ce	48 8b 80 70 08
	00 00		 mov	 rax, QWORD PTR [rax+2160]
  005d5	c7 40 64 01 00
	00 00		 mov	 DWORD PTR [rax+100], 1

; 451  :         GUESTREGS->program_interrupt = &s390_program_interrupt;

  005dc	48 8b 84 24 38
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  005e4	48 8b 80 70 08
	00 00		 mov	 rax, QWORD PTR [rax+2160]
  005eb	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:s390_program_interrupt
  005f2	48 89 88 20 0d
	00 00		 mov	 QWORD PTR [rax+3360], rcx

; 452  :         lpsw_xcode = s390_load_psw(GUESTREGS, STATEBK->psw);

  005f9	48 8b 84 24 38
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00601	48 8b 80 70 08
	00 00		 mov	 rax, QWORD PTR [rax+2160]
  00608	48 8b 80 88 08
	00 00		 mov	 rax, QWORD PTR [rax+2184]
  0060f	48 83 c0 18	 add	 rax, 24
  00613	48 8b d0	 mov	 rdx, rax
  00616	48 8b 84 24 38
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0061e	48 8b 88 70 08
	00 00		 mov	 rcx, QWORD PTR [rax+2160]
  00625	e8 00 00 00 00	 call	 s390_load_psw
  0062a	89 44 24 74	 mov	 DWORD PTR lpsw_xcode$[rsp], eax

; 453  :     }

  0062e	e9 c2 00 00 00	 jmp	 $LN122@s390_start
$LN121@s390_start:
$LN22@s390_start:

; 454  : #if !defined( FEATURE_001_ZARCH_INSTALLED_FACILITY )
; 455  :     else
; 456  :     {
; 457  :         /* Validity intercept for invalid mode */
; 458  :         SIE_SET_VI( SIE_VI_WHO_CPU, SIE_VI_WHEN_SIENT, SIE_VI_WHY_MODE, GUESTREGS );

  00633	48 8b 84 24 38
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0063b	48 8b 80 70 08
	00 00		 mov	 rax, QWORD PTR [rax+2160]
  00642	48 8b 80 88 08
	00 00		 mov	 rax, QWORD PTR [rax+2184]
  00649	b9 01 00 00 00	 mov	 ecx, 1
  0064e	48 6b c9 00	 imul	 rcx, rcx, 0
  00652	c6 44 08 56 01	 mov	 BYTE PTR [rax+rcx+86], 1
  00657	48 8b 84 24 38
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0065f	48 8b 80 70 08
	00 00		 mov	 rax, QWORD PTR [rax+2160]
  00666	48 8b 80 88 08
	00 00		 mov	 rax, QWORD PTR [rax+2184]
  0066d	b9 01 00 00 00	 mov	 ecx, 1
  00672	48 6b c9 01	 imul	 rcx, rcx, 1
  00676	c6 44 08 56 10	 mov	 BYTE PTR [rax+rcx+86], 16
  0067b	66 b9 01 00	 mov	 cx, 1
  0067f	e8 00 00 00 00	 call	 _byteswap_ushort
  00684	48 8b 8c 24 38
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0068c	48 8b 89 70 08
	00 00		 mov	 rcx, QWORD PTR [rcx+2160]
  00693	48 8b 89 88 08
	00 00		 mov	 rcx, QWORD PTR [rcx+2184]
  0069a	48 83 c1 58	 add	 rcx, 88			; 00000058H
  0069e	0f b7 d0	 movzx	 edx, ax
  006a1	e8 00 00 00 00	 call	 store_hw_noswap
  006a6	48 8b 84 24 38
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  006ae	48 8b 80 70 08
	00 00		 mov	 rax, QWORD PTR [rax+2160]
  006b5	48 8b 80 88 08
	00 00		 mov	 rax, QWORD PTR [rax+2184]
  006bc	48 83 c0 5a	 add	 rax, 90			; 0000005aH
  006c0	48 8b f8	 mov	 rdi, rax
  006c3	33 c0		 xor	 eax, eax
  006c5	b9 06 00 00 00	 mov	 ecx, 6
  006ca	f3 aa		 rep stosb
  006cc	33 c0		 xor	 eax, eax
  006ce	85 c0		 test	 eax, eax
  006d0	0f 85 5d ff ff
	ff		 jne	 $LN22@s390_start

; 459  :         STATEBK->c = SIE_C_VALIDITY;

  006d6	48 8b 84 24 38
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  006de	48 8b 80 70 08
	00 00		 mov	 rax, QWORD PTR [rax+2160]
  006e5	48 8b 80 88 08
	00 00		 mov	 rax, QWORD PTR [rax+2184]
  006ec	c6 40 50 20	 mov	 BYTE PTR [rax+80], 32	; 00000020H

; 460  :         return;

  006f0	e9 85 20 00 00	 jmp	 $LN1@s390_start
$LN122@s390_start:
$LN120@s390_start:

; 461  :     }
; 462  : #endif
; 463  : 
; 464  :     /* Prefered guest indication */
; 465  :     GUESTREGS->sie_pref = (STATEBK->m & SIE_M_VR) ? 1 : 0;

  006f5	48 8b 84 24 38
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  006fd	48 8b 80 70 08
	00 00		 mov	 rax, QWORD PTR [rax+2160]
  00704	48 8b 80 88 08
	00 00		 mov	 rax, QWORD PTR [rax+2184]
  0070b	0f b6 40 03	 movzx	 eax, BYTE PTR [rax+3]
  0070f	83 e0 08	 and	 eax, 8
  00712	85 c0		 test	 eax, eax
  00714	74 0d		 je	 SHORT $LN170@s390_start
  00716	c7 84 24 98 00
	00 00 01 00 00
	00		 mov	 DWORD PTR tv327[rsp], 1
  00721	eb 0b		 jmp	 SHORT $LN171@s390_start
$LN170@s390_start:
  00723	c7 84 24 98 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv327[rsp], 0
$LN171@s390_start:
  0072e	48 8b 84 24 38
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00736	48 8b 80 70 08
	00 00		 mov	 rax, QWORD PTR [rax+2160]
  0073d	8b 8c 24 98 00
	00 00		 mov	 ecx, DWORD PTR tv327[rsp]
  00744	83 e1 01	 and	 ecx, 1
  00747	c1 e1 02	 shl	 ecx, 2
  0074a	8b 80 c8 08 00
	00		 mov	 eax, DWORD PTR [rax+2248]
  00750	83 e0 fb	 and	 eax, -5			; fffffffbH
  00753	0b c1		 or	 eax, ecx
  00755	48 8b 8c 24 38
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0075d	48 8b 89 70 08
	00 00		 mov	 rcx, QWORD PTR [rcx+2160]
  00764	89 81 c8 08 00
	00		 mov	 DWORD PTR [rcx+2248], eax

; 466  : 
; 467  :     /* Load prefix from state descriptor... (Using 'PX_L' is okay
; 468  :        since prefix is always a FWORD regardless of architecture) */
; 469  :     FETCH_FW( GUESTREGS->PX_L, STATEBK->prefix );

  0076a	48 8b 84 24 38
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00772	48 8b 80 70 08
	00 00		 mov	 rax, QWORD PTR [rax+2160]
  00779	48 8b 80 88 08
	00 00		 mov	 rax, QWORD PTR [rax+2184]
  00780	48 83 c0 04	 add	 rax, 4
  00784	48 8b c8	 mov	 rcx, rax
  00787	e8 00 00 00 00	 call	 fetch_fw_noswap
  0078c	8b c8		 mov	 ecx, eax
  0078e	e8 00 00 00 00	 call	 _byteswap_ulong
  00793	48 8b 8c 24 38
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0079b	48 8b 89 70 08
	00 00		 mov	 rcx, QWORD PTR [rcx+2160]
  007a2	89 41 70	 mov	 DWORD PTR [rcx+112], eax

; 470  : 
; 471  : #if defined( FEATURE_REGION_RELOCATE )
; 472  : 
; 473  :     if (STATEBK->mx & SIE_MX_RRF)

  007a5	48 8b 84 24 38
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  007ad	48 8b 80 70 08
	00 00		 mov	 rax, QWORD PTR [rax+2160]
  007b4	48 8b 80 88 08
	00 00		 mov	 rax, QWORD PTR [rax+2184]
  007bb	0f b6 40 02	 movzx	 eax, BYTE PTR [rax+2]
  007bf	25 80 00 00 00	 and	 eax, 128		; 00000080H
  007c4	85 c0		 test	 eax, eax
  007c6	0f 84 88 04 00
	00		 je	 $LN123@s390_start

; 474  :     {
; 475  :         RADR mso, msl, eso = 0, esl = 0;

  007cc	48 c7 84 24 d0
	00 00 00 00 00
	00 00		 mov	 QWORD PTR eso$7[rsp], 0
  007d8	48 c7 84 24 d8
	00 00 00 00 00
	00 00		 mov	 QWORD PTR esl$8[rsp], 0

; 476  : 
; 477  :         if (STATEBK->zone >= FEATURE_SIE_MAXZONES)

  007e4	48 8b 84 24 38
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  007ec	48 8b 80 70 08
	00 00		 mov	 rax, QWORD PTR [rax+2160]
  007f3	48 8b 80 88 08
	00 00		 mov	 rax, QWORD PTR [rax+2184]
  007fa	0f b6 40 74	 movzx	 eax, BYTE PTR [rax+116]
  007fe	83 f8 08	 cmp	 eax, 8
  00801	0f 8c c2 00 00
	00		 jl	 $LN125@s390_start
$LN25@s390_start:

; 478  :         {
; 479  :             /* Validity intercept for invalid zone */
; 480  :             SIE_SET_VI( SIE_VI_WHO_CPU, SIE_VI_WHEN_SIENT, SIE_VI_WHY_AZNNI, GUESTREGS );

  00807	48 8b 84 24 38
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0080f	48 8b 80 70 08
	00 00		 mov	 rax, QWORD PTR [rax+2160]
  00816	48 8b 80 88 08
	00 00		 mov	 rax, QWORD PTR [rax+2184]
  0081d	b9 01 00 00 00	 mov	 ecx, 1
  00822	48 6b c9 00	 imul	 rcx, rcx, 0
  00826	c6 44 08 56 01	 mov	 BYTE PTR [rax+rcx+86], 1
  0082b	48 8b 84 24 38
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00833	48 8b 80 70 08
	00 00		 mov	 rax, QWORD PTR [rax+2160]
  0083a	48 8b 80 88 08
	00 00		 mov	 rax, QWORD PTR [rax+2184]
  00841	b9 01 00 00 00	 mov	 ecx, 1
  00846	48 6b c9 01	 imul	 rcx, rcx, 1
  0084a	c6 44 08 56 10	 mov	 BYTE PTR [rax+rcx+86], 16
  0084f	66 b9 05 10	 mov	 cx, 4101		; 00001005H
  00853	e8 00 00 00 00	 call	 _byteswap_ushort
  00858	48 8b 8c 24 38
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00860	48 8b 89 70 08
	00 00		 mov	 rcx, QWORD PTR [rcx+2160]
  00867	48 8b 89 88 08
	00 00		 mov	 rcx, QWORD PTR [rcx+2184]
  0086e	48 83 c1 58	 add	 rcx, 88			; 00000058H
  00872	0f b7 d0	 movzx	 edx, ax
  00875	e8 00 00 00 00	 call	 store_hw_noswap
  0087a	48 8b 84 24 38
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00882	48 8b 80 70 08
	00 00		 mov	 rax, QWORD PTR [rax+2160]
  00889	48 8b 80 88 08
	00 00		 mov	 rax, QWORD PTR [rax+2184]
  00890	48 83 c0 5a	 add	 rax, 90			; 0000005aH
  00894	48 8b f8	 mov	 rdi, rax
  00897	33 c0		 xor	 eax, eax
  00899	b9 06 00 00 00	 mov	 ecx, 6
  0089e	f3 aa		 rep stosb
  008a0	33 c0		 xor	 eax, eax
  008a2	85 c0		 test	 eax, eax
  008a4	0f 85 5d ff ff
	ff		 jne	 $LN25@s390_start

; 481  :             STATEBK->c = SIE_C_VALIDITY;

  008aa	48 8b 84 24 38
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  008b2	48 8b 80 70 08
	00 00		 mov	 rax, QWORD PTR [rax+2160]
  008b9	48 8b 80 88 08
	00 00		 mov	 rax, QWORD PTR [rax+2184]
  008c0	c6 40 50 20	 mov	 BYTE PTR [rax+80], 32	; 00000020H

; 482  :             return;

  008c4	e9 b1 1e 00 00	 jmp	 $LN1@s390_start
$LN125@s390_start:

; 483  :         }
; 484  : 
; 485  :         mso = (sysblk.zpb[ STATEBK->zone ].mso & 0xFFFFF) << 20;

  008c9	48 8b 84 24 38
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  008d1	48 8b 80 70 08
	00 00		 mov	 rax, QWORD PTR [rax+2160]
  008d8	48 8b 80 88 08
	00 00		 mov	 rax, QWORD PTR [rax+2184]
  008df	0f b6 40 74	 movzx	 eax, BYTE PTR [rax+116]
  008e3	48 6b c0 38	 imul	 rax, rax, 56		; 00000038H
  008e7	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  008ee	48 8b 84 01 a0
	0e 00 00	 mov	 rax, QWORD PTR [rcx+rax+3744]
  008f6	48 25 ff ff 0f
	00		 and	 rax, 1048575		; 000fffffH
  008fc	48 c1 e0 14	 shl	 rax, 20
  00900	48 89 84 24 88
	00 00 00	 mov	 QWORD PTR mso$1[rsp], rax

; 486  :         msl = (sysblk.zpb[ STATEBK->zone ].msl & 0xFFFFF) << 20;

  00908	48 8b 84 24 38
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00910	48 8b 80 70 08
	00 00		 mov	 rax, QWORD PTR [rax+2160]
  00917	48 8b 80 88 08
	00 00		 mov	 rax, QWORD PTR [rax+2184]
  0091e	0f b6 40 74	 movzx	 eax, BYTE PTR [rax+116]
  00922	48 6b c0 38	 imul	 rax, rax, 56		; 00000038H
  00926	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  0092d	48 8b 84 01 a8
	0e 00 00	 mov	 rax, QWORD PTR [rcx+rax+3752]
  00935	48 25 ff ff 0f
	00		 and	 rax, 1048575		; 000fffffH
  0093b	48 c1 e0 14	 shl	 rax, 20
  0093f	48 89 84 24 b8
	00 00 00	 mov	 QWORD PTR msl$5[rsp], rax

; 487  :         eso = (sysblk.zpb[ STATEBK->zone ].eso & 0xFFFFF) << 20;

  00947	48 8b 84 24 38
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0094f	48 8b 80 70 08
	00 00		 mov	 rax, QWORD PTR [rax+2160]
  00956	48 8b 80 88 08
	00 00		 mov	 rax, QWORD PTR [rax+2184]
  0095d	0f b6 40 74	 movzx	 eax, BYTE PTR [rax+116]
  00961	48 6b c0 38	 imul	 rax, rax, 56		; 00000038H
  00965	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  0096c	48 8b 84 01 b0
	0e 00 00	 mov	 rax, QWORD PTR [rcx+rax+3760]
  00974	48 25 ff ff 0f
	00		 and	 rax, 1048575		; 000fffffH
  0097a	48 c1 e0 14	 shl	 rax, 20
  0097e	48 89 84 24 d0
	00 00 00	 mov	 QWORD PTR eso$7[rsp], rax

; 488  :         esl = (sysblk.zpb[ STATEBK->zone ].esl & 0xFFFFF) << 20;

  00986	48 8b 84 24 38
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0098e	48 8b 80 70 08
	00 00		 mov	 rax, QWORD PTR [rax+2160]
  00995	48 8b 80 88 08
	00 00		 mov	 rax, QWORD PTR [rax+2184]
  0099c	0f b6 40 74	 movzx	 eax, BYTE PTR [rax+116]
  009a0	48 6b c0 38	 imul	 rax, rax, 56		; 00000038H
  009a4	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  009ab	48 8b 84 01 b8
	0e 00 00	 mov	 rax, QWORD PTR [rcx+rax+3768]
  009b3	48 25 ff ff 0f
	00		 and	 rax, 1048575		; 000fffffH
  009b9	48 c1 e0 14	 shl	 rax, 20
  009bd	48 89 84 24 d8
	00 00 00	 mov	 QWORD PTR esl$8[rsp], rax

; 489  : 
; 490  :         if (mso > msl)

  009c5	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR msl$5[rsp]
  009cd	48 39 84 24 88
	00 00 00	 cmp	 QWORD PTR mso$1[rsp], rax
  009d5	0f 86 c2 00 00
	00		 jbe	 $LN126@s390_start
$LN28@s390_start:

; 491  :         {
; 492  :             /* Validity intercept for invalid zone */
; 493  :             SIE_SET_VI( SIE_VI_WHO_CPU, SIE_VI_WHEN_SIENT, SIE_VI_WHY_MSDEF, GUESTREGS );

  009db	48 8b 84 24 38
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  009e3	48 8b 80 70 08
	00 00		 mov	 rax, QWORD PTR [rax+2160]
  009ea	48 8b 80 88 08
	00 00		 mov	 rax, QWORD PTR [rax+2184]
  009f1	b9 01 00 00 00	 mov	 ecx, 1
  009f6	48 6b c9 00	 imul	 rcx, rcx, 0
  009fa	c6 44 08 56 01	 mov	 BYTE PTR [rax+rcx+86], 1
  009ff	48 8b 84 24 38
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00a07	48 8b 80 70 08
	00 00		 mov	 rax, QWORD PTR [rax+2160]
  00a0e	48 8b 80 88 08
	00 00		 mov	 rax, QWORD PTR [rax+2184]
  00a15	b9 01 00 00 00	 mov	 ecx, 1
  00a1a	48 6b c9 01	 imul	 rcx, rcx, 1
  00a1e	c6 44 08 56 10	 mov	 BYTE PTR [rax+rcx+86], 16
  00a23	66 b9 41 00	 mov	 cx, 65			; 00000041H
  00a27	e8 00 00 00 00	 call	 _byteswap_ushort
  00a2c	48 8b 8c 24 38
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00a34	48 8b 89 70 08
	00 00		 mov	 rcx, QWORD PTR [rcx+2160]
  00a3b	48 8b 89 88 08
	00 00		 mov	 rcx, QWORD PTR [rcx+2184]
  00a42	48 83 c1 58	 add	 rcx, 88			; 00000058H
  00a46	0f b7 d0	 movzx	 edx, ax
  00a49	e8 00 00 00 00	 call	 store_hw_noswap
  00a4e	48 8b 84 24 38
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00a56	48 8b 80 70 08
	00 00		 mov	 rax, QWORD PTR [rax+2160]
  00a5d	48 8b 80 88 08
	00 00		 mov	 rax, QWORD PTR [rax+2184]
  00a64	48 83 c0 5a	 add	 rax, 90			; 0000005aH
  00a68	48 8b f8	 mov	 rdi, rax
  00a6b	33 c0		 xor	 eax, eax
  00a6d	b9 06 00 00 00	 mov	 ecx, 6
  00a72	f3 aa		 rep stosb
  00a74	33 c0		 xor	 eax, eax
  00a76	85 c0		 test	 eax, eax
  00a78	0f 85 5d ff ff
	ff		 jne	 $LN28@s390_start

; 494  :             STATEBK->c = SIE_C_VALIDITY;

  00a7e	48 8b 84 24 38
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00a86	48 8b 80 70 08
	00 00		 mov	 rax, QWORD PTR [rax+2160]
  00a8d	48 8b 80 88 08
	00 00		 mov	 rax, QWORD PTR [rax+2184]
  00a94	c6 40 50 20	 mov	 BYTE PTR [rax+80], 32	; 00000020H

; 495  :             return;

  00a98	e9 dd 1c 00 00	 jmp	 $LN1@s390_start
$LN126@s390_start:

; 496  :         }
; 497  : 
; 498  :         /* Ensure addressing exceptions on incorrect zone defs */
; 499  :         if (0
; 500  :             || mso > regs->mainlim
; 501  :             || msl > regs->mainlim

  00a9d	33 c0		 xor	 eax, eax
  00a9f	85 c0		 test	 eax, eax
  00aa1	75 32		 jne	 SHORT $LN128@s390_start
  00aa3	48 8b 84 24 38
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00aab	48 8b 80 58 08
	00 00		 mov	 rax, QWORD PTR [rax+2136]
  00ab2	48 39 84 24 88
	00 00 00	 cmp	 QWORD PTR mso$1[rsp], rax
  00aba	77 19		 ja	 SHORT $LN128@s390_start
  00abc	48 8b 84 24 38
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00ac4	48 8b 80 58 08
	00 00		 mov	 rax, QWORD PTR [rax+2136]
  00acb	48 39 84 24 b8
	00 00 00	 cmp	 QWORD PTR msl$5[rsp], rax
  00ad3	76 1c		 jbe	 SHORT $LN127@s390_start
$LN128@s390_start:

; 502  :         )
; 503  :             mso = msl = 0;

  00ad5	48 c7 84 24 b8
	00 00 00 00 00
	00 00		 mov	 QWORD PTR msl$5[rsp], 0
  00ae1	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR msl$5[rsp]
  00ae9	48 89 84 24 88
	00 00 00	 mov	 QWORD PTR mso$1[rsp], rax
$LN127@s390_start:

; 504  : 
; 505  : #if defined( SIE_DEBUG )
; 506  :         LOGMSG( "SIE: zone %d: mso=" F_RADR " msl=" F_RADR "\n", STATEBK->zone, mso, msl );
; 507  : #endif
; 508  : 
; 509  :         GUESTREGS->sie_pref  =  1;

  00af1	48 8b 84 24 38
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00af9	48 8b 80 70 08
	00 00		 mov	 rax, QWORD PTR [rax+2160]
  00b00	8b 80 c8 08 00
	00		 mov	 eax, DWORD PTR [rax+2248]
  00b06	83 c8 04	 or	 eax, 4
  00b09	48 8b 8c 24 38
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00b11	48 8b 89 70 08
	00 00		 mov	 rcx, QWORD PTR [rcx+2160]
  00b18	89 81 c8 08 00
	00		 mov	 DWORD PTR [rcx+2248], eax

; 510  :         GUESTREGS->sie_mso   =  0;

  00b1e	48 8b 84 24 38
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00b26	48 8b 80 70 08
	00 00		 mov	 rax, QWORD PTR [rax+2160]
  00b2d	48 c7 80 98 08
	00 00 00 00 00
	00		 mov	 QWORD PTR [rax+2200], 0

; 511  :         GUESTREGS->mainstor  =  &sysblk.mainstor[mso];

  00b38	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00b3f	48 8b 80 98 00
	00 00		 mov	 rax, QWORD PTR [rax+152]
  00b46	48 03 84 24 88
	00 00 00	 add	 rax, QWORD PTR mso$1[rsp]
  00b4e	48 8b 8c 24 38
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00b56	48 8b 89 70 08
	00 00		 mov	 rcx, QWORD PTR [rcx+2160]
  00b5d	48 89 81 48 08
	00 00		 mov	 QWORD PTR [rcx+2120], rax

; 512  :         GUESTREGS->mainlim   =  msl - mso;

  00b64	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR mso$1[rsp]
  00b6c	48 8b 8c 24 b8
	00 00 00	 mov	 rcx, QWORD PTR msl$5[rsp]
  00b74	48 2b c8	 sub	 rcx, rax
  00b77	48 8b c1	 mov	 rax, rcx
  00b7a	48 8b 8c 24 38
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00b82	48 8b 89 70 08
	00 00		 mov	 rcx, QWORD PTR [rcx+2160]
  00b89	48 89 81 58 08
	00 00		 mov	 QWORD PTR [rcx+2136], rax

; 513  :         GUESTREGS->storkeys  =  ARCH_DEP( get_ptr_to_storekey )( mso );

  00b90	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR mso$1[rsp]
  00b98	e8 00 00 00 00	 call	 s390_get_ptr_to_storekey
  00b9d	48 8b 8c 24 38
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00ba5	48 8b 89 70 08
	00 00		 mov	 rcx, QWORD PTR [rcx+2160]
  00bac	48 89 81 50 08
	00 00		 mov	 QWORD PTR [rcx+2128], rax

; 514  :         GUESTREGS->sie_xso   =  eso;

  00bb3	48 8b 84 24 38
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00bbb	48 8b 80 70 08
	00 00		 mov	 rax, QWORD PTR [rax+2160]
  00bc2	48 8b 8c 24 d0
	00 00 00	 mov	 rcx, QWORD PTR eso$7[rsp]
  00bca	48 89 88 a0 08
	00 00		 mov	 QWORD PTR [rax+2208], rcx

; 515  :         GUESTREGS->sie_xsl   =  esl;

  00bd1	48 8b 84 24 38
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00bd9	48 8b 80 70 08
	00 00		 mov	 rax, QWORD PTR [rax+2160]
  00be0	48 8b 8c 24 d8
	00 00 00	 mov	 rcx, QWORD PTR esl$8[rsp]
  00be8	48 89 88 a8 08
	00 00		 mov	 QWORD PTR [rax+2216], rcx

; 516  :         GUESTREGS->sie_xso  *=  (XSTORE_INCREMENT_SIZE >> XSTORE_PAGESHIFT);

  00bef	48 8b 84 24 38
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00bf7	48 8b 80 70 08
	00 00		 mov	 rax, QWORD PTR [rax+2160]
  00bfe	48 69 80 a0 08
	00 00 00 01 00
	00		 imul	 rax, QWORD PTR [rax+2208], 256 ; 00000100H
  00c09	48 8b 8c 24 38
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00c11	48 8b 89 70 08
	00 00		 mov	 rcx, QWORD PTR [rcx+2160]
  00c18	48 89 81 a0 08
	00 00		 mov	 QWORD PTR [rcx+2208], rax

; 517  :         GUESTREGS->sie_xsl  *=  (XSTORE_INCREMENT_SIZE >> XSTORE_PAGESHIFT);

  00c1f	48 8b 84 24 38
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00c27	48 8b 80 70 08
	00 00		 mov	 rax, QWORD PTR [rax+2160]
  00c2e	48 69 80 a8 08
	00 00 00 01 00
	00		 imul	 rax, QWORD PTR [rax+2216], 256 ; 00000100H
  00c39	48 8b 8c 24 38
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00c41	48 8b 89 70 08
	00 00		 mov	 rcx, QWORD PTR [rcx+2160]
  00c48	48 89 81 a8 08
	00 00		 mov	 QWORD PTR [rcx+2216], rax

; 518  :     }

  00c4f	e9 a6 03 00 00	 jmp	 $LN124@s390_start
$LN123@s390_start:

; 519  :     else
; 520  : #endif /* defined( FEATURE_REGION_RELOCATE ) */
; 521  :     {
; 522  :         GUESTREGS->mainstor = sysblk.mainstor;

  00c54	48 8b 84 24 38
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00c5c	48 8b 80 70 08
	00 00		 mov	 rax, QWORD PTR [rax+2160]
  00c63	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  00c6a	48 8b 89 98 00
	00 00		 mov	 rcx, QWORD PTR [rcx+152]
  00c71	48 89 88 48 08
	00 00		 mov	 QWORD PTR [rax+2120], rcx

; 523  :         GUESTREGS->storkeys = sysblk.storkeys;

  00c78	48 8b 84 24 38
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00c80	48 8b 80 70 08
	00 00		 mov	 rax, QWORD PTR [rax+2160]
  00c87	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  00c8e	48 8b 89 a0 00
	00 00		 mov	 rcx, QWORD PTR [rcx+160]
  00c95	48 89 88 50 08
	00 00		 mov	 QWORD PTR [rax+2128], rcx

; 524  : 
; 525  :         if (STATEBK->zone)

  00c9c	48 8b 84 24 38
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00ca4	48 8b 80 70 08
	00 00		 mov	 rax, QWORD PTR [rax+2160]
  00cab	48 8b 80 88 08
	00 00		 mov	 rax, QWORD PTR [rax+2184]
  00cb2	0f b6 40 74	 movzx	 eax, BYTE PTR [rax+116]
  00cb6	85 c0		 test	 eax, eax
  00cb8	0f 84 c2 00 00
	00		 je	 $LN129@s390_start
$LN31@s390_start:

; 526  :         {
; 527  :             /* Validity intercept for invalid zone */
; 528  :             SIE_SET_VI( SIE_VI_WHO_CPU, SIE_VI_WHEN_SIENT, SIE_VI_WHY_AZNNZ, GUESTREGS );

  00cbe	48 8b 84 24 38
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00cc6	48 8b 80 70 08
	00 00		 mov	 rax, QWORD PTR [rax+2160]
  00ccd	48 8b 80 88 08
	00 00		 mov	 rax, QWORD PTR [rax+2184]
  00cd4	b9 01 00 00 00	 mov	 ecx, 1
  00cd9	48 6b c9 00	 imul	 rcx, rcx, 0
  00cdd	c6 44 08 56 01	 mov	 BYTE PTR [rax+rcx+86], 1
  00ce2	48 8b 84 24 38
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00cea	48 8b 80 70 08
	00 00		 mov	 rax, QWORD PTR [rax+2160]
  00cf1	48 8b 80 88 08
	00 00		 mov	 rax, QWORD PTR [rax+2184]
  00cf8	b9 01 00 00 00	 mov	 ecx, 1
  00cfd	48 6b c9 01	 imul	 rcx, rcx, 1
  00d01	c6 44 08 56 10	 mov	 BYTE PTR [rax+rcx+86], 16
  00d06	66 b9 06 10	 mov	 cx, 4102		; 00001006H
  00d0a	e8 00 00 00 00	 call	 _byteswap_ushort
  00d0f	48 8b 8c 24 38
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00d17	48 8b 89 70 08
	00 00		 mov	 rcx, QWORD PTR [rcx+2160]
  00d1e	48 8b 89 88 08
	00 00		 mov	 rcx, QWORD PTR [rcx+2184]
  00d25	48 83 c1 58	 add	 rcx, 88			; 00000058H
  00d29	0f b7 d0	 movzx	 edx, ax
  00d2c	e8 00 00 00 00	 call	 store_hw_noswap
  00d31	48 8b 84 24 38
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00d39	48 8b 80 70 08
	00 00		 mov	 rax, QWORD PTR [rax+2160]
  00d40	48 8b 80 88 08
	00 00		 mov	 rax, QWORD PTR [rax+2184]
  00d47	48 83 c0 5a	 add	 rax, 90			; 0000005aH
  00d4b	48 8b f8	 mov	 rdi, rax
  00d4e	33 c0		 xor	 eax, eax
  00d50	b9 06 00 00 00	 mov	 ecx, 6
  00d55	f3 aa		 rep stosb
  00d57	33 c0		 xor	 eax, eax
  00d59	85 c0		 test	 eax, eax
  00d5b	0f 85 5d ff ff
	ff		 jne	 $LN31@s390_start

; 529  :             STATEBK->c = SIE_C_VALIDITY;

  00d61	48 8b 84 24 38
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00d69	48 8b 80 70 08
	00 00		 mov	 rax, QWORD PTR [rax+2160]
  00d70	48 8b 80 88 08
	00 00		 mov	 rax, QWORD PTR [rax+2184]
  00d77	c6 40 50 20	 mov	 BYTE PTR [rax+80], 32	; 00000020H

; 530  :             return;

  00d7b	e9 fa 19 00 00	 jmp	 $LN1@s390_start
$LN129@s390_start:

; 531  :         }
; 532  : 
; 533  : #if defined( FEATURE_001_ZARCH_INSTALLED_FACILITY )
; 534  : 
; 535  :         /* Load main storage origin */
; 536  :         FETCH_DW( GUESTREGS->sie_mso, STATEBK->mso );
; 537  :         GUESTREGS->sie_mso &= SIE2_MS_MASK;
; 538  : 
; 539  :         /* Load main storage extent */
; 540  :         FETCH_DW( GUESTREGS->mainlim, STATEBK->mse );
; 541  :         GUESTREGS->mainlim |= ~SIE2_MS_MASK;
; 542  : 
; 543  :         if (GUESTREGS->sie_mso > GUESTREGS->mainlim)
; 544  :         {
; 545  :             SIE_SET_VI( SIE_VI_WHO_CPU, SIE_VI_WHEN_SIENT, SIE_VI_WHY_MSDEF, GUESTREGS );
; 546  :             STATEBK->c = SIE_C_VALIDITY;
; 547  :             return;
; 548  :         }
; 549  : 
; 550  :         /* Calculate main storage size */
; 551  :         GUESTREGS->mainlim -= GUESTREGS->sie_mso;
; 552  : 
; 553  : #else /* !defined( FEATURE_001_ZARCH_INSTALLED_FACILITY ) */
; 554  : 
; 555  :         /* Load main storage origin */
; 556  :         FETCH_HW( GUESTREGS->sie_mso, STATEBK->mso );

  00d80	48 8b 84 24 38
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00d88	48 8b 80 70 08
	00 00		 mov	 rax, QWORD PTR [rax+2160]
  00d8f	48 8b 80 88 08
	00 00		 mov	 rax, QWORD PTR [rax+2184]
  00d96	48 83 c0 08	 add	 rax, 8
  00d9a	48 8b c8	 mov	 rcx, rax
  00d9d	e8 00 00 00 00	 call	 fetch_hw_noswap
  00da2	0f b7 c8	 movzx	 ecx, ax
  00da5	e8 00 00 00 00	 call	 _byteswap_ushort
  00daa	48 8b 8c 24 38
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00db2	48 8b 89 70 08
	00 00		 mov	 rcx, QWORD PTR [rcx+2160]
  00db9	0f b7 c0	 movzx	 eax, ax
  00dbc	48 89 81 98 08
	00 00		 mov	 QWORD PTR [rcx+2200], rax

; 557  :         GUESTREGS->sie_mso <<= 16;

  00dc3	48 8b 84 24 38
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00dcb	48 8b 80 70 08
	00 00		 mov	 rax, QWORD PTR [rax+2160]
  00dd2	48 8b 80 98 08
	00 00		 mov	 rax, QWORD PTR [rax+2200]
  00dd9	48 c1 e0 10	 shl	 rax, 16
  00ddd	48 8b 8c 24 38
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00de5	48 8b 89 70 08
	00 00		 mov	 rcx, QWORD PTR [rcx+2160]
  00dec	48 89 81 98 08
	00 00		 mov	 QWORD PTR [rcx+2200], rax

; 558  : 
; 559  :         /* Load main storage extent */
; 560  :         FETCH_HW( GUESTREGS->mainlim, STATEBK->mse );

  00df3	48 8b 84 24 38
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00dfb	48 8b 80 70 08
	00 00		 mov	 rax, QWORD PTR [rax+2160]
  00e02	48 8b 80 88 08
	00 00		 mov	 rax, QWORD PTR [rax+2184]
  00e09	48 83 c0 0a	 add	 rax, 10
  00e0d	48 8b c8	 mov	 rcx, rax
  00e10	e8 00 00 00 00	 call	 fetch_hw_noswap
  00e15	0f b7 c8	 movzx	 ecx, ax
  00e18	e8 00 00 00 00	 call	 _byteswap_ushort
  00e1d	48 8b 8c 24 38
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00e25	48 8b 89 70 08
	00 00		 mov	 rcx, QWORD PTR [rcx+2160]
  00e2c	0f b7 c0	 movzx	 eax, ax
  00e2f	48 89 81 58 08
	00 00		 mov	 QWORD PTR [rcx+2136], rax

; 561  :         GUESTREGS->mainlim = ((GUESTREGS->mainlim + 1) << 16) - 1;

  00e36	48 8b 84 24 38
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00e3e	48 8b 80 70 08
	00 00		 mov	 rax, QWORD PTR [rax+2160]
  00e45	48 8b 80 58 08
	00 00		 mov	 rax, QWORD PTR [rax+2136]
  00e4c	48 ff c0	 inc	 rax
  00e4f	48 c1 e0 10	 shl	 rax, 16
  00e53	48 ff c8	 dec	 rax
  00e56	48 8b 8c 24 38
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00e5e	48 8b 89 70 08
	00 00		 mov	 rcx, QWORD PTR [rcx+2160]
  00e65	48 89 81 58 08
	00 00		 mov	 QWORD PTR [rcx+2136], rax

; 562  : 
; 563  : #endif /* defined( FEATURE_001_ZARCH_INSTALLED_FACILITY ) */
; 564  : 
; 565  :         /* Load expanded storage origin */
; 566  :         GUESTREGS->sie_xso = STATEBK->xso[0] << 16

  00e6c	48 8b 84 24 38
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00e74	48 8b 80 70 08
	00 00		 mov	 rax, QWORD PTR [rax+2160]
  00e7b	48 8b 80 88 08
	00 00		 mov	 rax, QWORD PTR [rax+2184]
  00e82	b9 01 00 00 00	 mov	 ecx, 1
  00e87	48 6b c9 00	 imul	 rcx, rcx, 0
  00e8b	0f b6 84 08 e2
	00 00 00	 movzx	 eax, BYTE PTR [rax+rcx+226]
  00e93	c1 e0 10	 shl	 eax, 16
  00e96	48 8b 8c 24 38
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00e9e	48 8b 89 70 08
	00 00		 mov	 rcx, QWORD PTR [rcx+2160]
  00ea5	48 8b 89 88 08
	00 00		 mov	 rcx, QWORD PTR [rcx+2184]
  00eac	ba 01 00 00 00	 mov	 edx, 1
  00eb1	48 6b d2 01	 imul	 rdx, rdx, 1
  00eb5	0f b6 8c 11 e2
	00 00 00	 movzx	 ecx, BYTE PTR [rcx+rdx+226]
  00ebd	c1 e1 08	 shl	 ecx, 8
  00ec0	0b c1		 or	 eax, ecx
  00ec2	48 8b 8c 24 38
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00eca	48 8b 89 70 08
	00 00		 mov	 rcx, QWORD PTR [rcx+2160]
  00ed1	48 8b 89 88 08
	00 00		 mov	 rcx, QWORD PTR [rcx+2184]
  00ed8	ba 01 00 00 00	 mov	 edx, 1
  00edd	48 6b d2 02	 imul	 rdx, rdx, 2
  00ee1	0f b6 8c 11 e2
	00 00 00	 movzx	 ecx, BYTE PTR [rcx+rdx+226]
  00ee9	0b c1		 or	 eax, ecx
  00eeb	48 8b 8c 24 38
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00ef3	48 8b 89 70 08
	00 00		 mov	 rcx, QWORD PTR [rcx+2160]
  00efa	48 98		 cdqe
  00efc	48 89 81 a0 08
	00 00		 mov	 QWORD PTR [rcx+2208], rax

; 567  :                            | STATEBK->xso[1] <<  8
; 568  :                            | STATEBK->xso[2];
; 569  :         GUESTREGS->sie_xso *= (XSTORE_INCREMENT_SIZE >> XSTORE_PAGESHIFT);

  00f03	48 8b 84 24 38
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00f0b	48 8b 80 70 08
	00 00		 mov	 rax, QWORD PTR [rax+2160]
  00f12	48 69 80 a0 08
	00 00 00 01 00
	00		 imul	 rax, QWORD PTR [rax+2208], 256 ; 00000100H
  00f1d	48 8b 8c 24 38
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00f25	48 8b 89 70 08
	00 00		 mov	 rcx, QWORD PTR [rcx+2160]
  00f2c	48 89 81 a0 08
	00 00		 mov	 QWORD PTR [rcx+2208], rax

; 570  : 
; 571  :         /* Load expanded storage limit */
; 572  :         GUESTREGS->sie_xsl = STATEBK->xsl[0] << 16

  00f33	48 8b 84 24 38
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00f3b	48 8b 80 70 08
	00 00		 mov	 rax, QWORD PTR [rax+2160]
  00f42	48 8b 80 88 08
	00 00		 mov	 rax, QWORD PTR [rax+2184]
  00f49	b9 01 00 00 00	 mov	 ecx, 1
  00f4e	48 6b c9 00	 imul	 rcx, rcx, 0
  00f52	0f b6 84 08 e5
	00 00 00	 movzx	 eax, BYTE PTR [rax+rcx+229]
  00f5a	c1 e0 10	 shl	 eax, 16
  00f5d	48 8b 8c 24 38
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00f65	48 8b 89 70 08
	00 00		 mov	 rcx, QWORD PTR [rcx+2160]
  00f6c	48 8b 89 88 08
	00 00		 mov	 rcx, QWORD PTR [rcx+2184]
  00f73	ba 01 00 00 00	 mov	 edx, 1
  00f78	48 6b d2 01	 imul	 rdx, rdx, 1
  00f7c	0f b6 8c 11 e5
	00 00 00	 movzx	 ecx, BYTE PTR [rcx+rdx+229]
  00f84	c1 e1 08	 shl	 ecx, 8
  00f87	0b c1		 or	 eax, ecx
  00f89	48 8b 8c 24 38
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00f91	48 8b 89 70 08
	00 00		 mov	 rcx, QWORD PTR [rcx+2160]
  00f98	48 8b 89 88 08
	00 00		 mov	 rcx, QWORD PTR [rcx+2184]
  00f9f	ba 01 00 00 00	 mov	 edx, 1
  00fa4	48 6b d2 02	 imul	 rdx, rdx, 2
  00fa8	0f b6 8c 11 e5
	00 00 00	 movzx	 ecx, BYTE PTR [rcx+rdx+229]
  00fb0	0b c1		 or	 eax, ecx
  00fb2	48 8b 8c 24 38
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00fba	48 8b 89 70 08
	00 00		 mov	 rcx, QWORD PTR [rcx+2160]
  00fc1	48 98		 cdqe
  00fc3	48 89 81 a8 08
	00 00		 mov	 QWORD PTR [rcx+2216], rax

; 573  :                            | STATEBK->xsl[1] <<  8
; 574  :                            | STATEBK->xsl[2];
; 575  :         GUESTREGS->sie_xsl *= (XSTORE_INCREMENT_SIZE >> XSTORE_PAGESHIFT);

  00fca	48 8b 84 24 38
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00fd2	48 8b 80 70 08
	00 00		 mov	 rax, QWORD PTR [rax+2160]
  00fd9	48 69 80 a8 08
	00 00 00 01 00
	00		 imul	 rax, QWORD PTR [rax+2216], 256 ; 00000100H
  00fe4	48 8b 8c 24 38
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00fec	48 8b 89 70 08
	00 00		 mov	 rcx, QWORD PTR [rcx+2160]
  00ff3	48 89 81 a8 08
	00 00		 mov	 QWORD PTR [rcx+2216], rax
$LN124@s390_start:

; 576  :     }
; 577  : 
; 578  :     /* Validate Guest prefix */
; 579  :     if (GUESTREGS->PX > GUESTREGS->mainlim)

  00ffa	48 8b 84 24 38
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  01002	48 8b 80 70 08
	00 00		 mov	 rax, QWORD PTR [rax+2160]
  01009	8b 40 70	 mov	 eax, DWORD PTR [rax+112]
  0100c	48 8b 8c 24 38
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  01014	48 8b 89 70 08
	00 00		 mov	 rcx, QWORD PTR [rcx+2160]
  0101b	48 3b 81 58 08
	00 00		 cmp	 rax, QWORD PTR [rcx+2136]
  01022	0f 86 c2 00 00
	00		 jbe	 $LN130@s390_start
$LN34@s390_start:

; 580  :     {
; 581  :         SIE_SET_VI( SIE_VI_WHO_CPU, SIE_VI_WHEN_SIENT, SIE_VI_WHY_PFOUT, GUESTREGS );

  01028	48 8b 84 24 38
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  01030	48 8b 80 70 08
	00 00		 mov	 rax, QWORD PTR [rax+2160]
  01037	48 8b 80 88 08
	00 00		 mov	 rax, QWORD PTR [rax+2184]
  0103e	b9 01 00 00 00	 mov	 ecx, 1
  01043	48 6b c9 00	 imul	 rcx, rcx, 0
  01047	c6 44 08 56 01	 mov	 BYTE PTR [rax+rcx+86], 1
  0104c	48 8b 84 24 38
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  01054	48 8b 80 70 08
	00 00		 mov	 rax, QWORD PTR [rax+2160]
  0105b	48 8b 80 88 08
	00 00		 mov	 rax, QWORD PTR [rax+2184]
  01062	b9 01 00 00 00	 mov	 ecx, 1
  01067	48 6b c9 01	 imul	 rcx, rcx, 1
  0106b	c6 44 08 56 10	 mov	 BYTE PTR [rax+rcx+86], 16
  01070	66 b9 10 00	 mov	 cx, 16
  01074	e8 00 00 00 00	 call	 _byteswap_ushort
  01079	48 8b 8c 24 38
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  01081	48 8b 89 70 08
	00 00		 mov	 rcx, QWORD PTR [rcx+2160]
  01088	48 8b 89 88 08
	00 00		 mov	 rcx, QWORD PTR [rcx+2184]
  0108f	48 83 c1 58	 add	 rcx, 88			; 00000058H
  01093	0f b7 d0	 movzx	 edx, ax
  01096	e8 00 00 00 00	 call	 store_hw_noswap
  0109b	48 8b 84 24 38
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  010a3	48 8b 80 70 08
	00 00		 mov	 rax, QWORD PTR [rax+2160]
  010aa	48 8b 80 88 08
	00 00		 mov	 rax, QWORD PTR [rax+2184]
  010b1	48 83 c0 5a	 add	 rax, 90			; 0000005aH
  010b5	48 8b f8	 mov	 rdi, rax
  010b8	33 c0		 xor	 eax, eax
  010ba	b9 06 00 00 00	 mov	 ecx, 6
  010bf	f3 aa		 rep stosb
  010c1	33 c0		 xor	 eax, eax
  010c3	85 c0		 test	 eax, eax
  010c5	0f 85 5d ff ff
	ff		 jne	 $LN34@s390_start

; 582  :         STATEBK->c = SIE_C_VALIDITY;

  010cb	48 8b 84 24 38
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  010d3	48 8b 80 70 08
	00 00		 mov	 rax, QWORD PTR [rax+2160]
  010da	48 8b 80 88 08
	00 00		 mov	 rax, QWORD PTR [rax+2184]
  010e1	c6 40 50 20	 mov	 BYTE PTR [rax+80], 32	; 00000020H

; 583  :         return;

  010e5	e9 90 16 00 00	 jmp	 $LN1@s390_start
$LN130@s390_start:

; 584  :     }
; 585  : 
; 586  :     /* System Control Area Origin */
; 587  :     FETCH_FW( GUESTREGS->sie_scao, STATEBK->scao );

  010ea	48 8b 84 24 38
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  010f2	48 8b 80 70 08
	00 00		 mov	 rax, QWORD PTR [rax+2160]
  010f9	48 8b 80 88 08
	00 00		 mov	 rax, QWORD PTR [rax+2184]
  01100	48 83 c0 64	 add	 rax, 100		; 00000064H
  01104	48 8b c8	 mov	 rcx, rax
  01107	e8 00 00 00 00	 call	 fetch_fw_noswap
  0110c	8b c8		 mov	 ecx, eax
  0110e	e8 00 00 00 00	 call	 _byteswap_ulong
  01113	48 8b 8c 24 38
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0111b	48 8b 89 70 08
	00 00		 mov	 rcx, QWORD PTR [rcx+2160]
  01122	8b c0		 mov	 eax, eax
  01124	48 89 81 b8 08
	00 00		 mov	 QWORD PTR [rcx+2232], rax

; 588  :     GUESTREGS->sie_scao &= SIEISCAM;

  0112b	48 8b 84 24 38
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  01133	48 8b 80 70 08
	00 00		 mov	 rax, QWORD PTR [rax+2160]
  0113a	b9 f0 ff ff ff	 mov	 ecx, -16		; fffffff0H
  0113f	48 8b 80 b8 08
	00 00		 mov	 rax, QWORD PTR [rax+2232]
  01146	48 23 c1	 and	 rax, rcx
  01149	48 8b 8c 24 38
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  01151	48 8b 89 70 08
	00 00		 mov	 rcx, QWORD PTR [rcx+2160]
  01158	48 89 81 b8 08
	00 00		 mov	 QWORD PTR [rcx+2232], rax

; 589  : 
; 590  : #if defined( FEATURE_001_ZARCH_INSTALLED_FACILITY )
; 591  :     {
; 592  :         /* For ESAME insert the high word of the address */
; 593  :         U32 sie_scaoh;
; 594  :         FETCH_FW( sie_scaoh, STATEBK->scaoh );
; 595  :         GUESTREGS->sie_scao |= (RADR)sie_scaoh << 32;
; 596  :     }
; 597  : #endif
; 598  : 
; 599  :     if (GUESTREGS->sie_scao > regs->mainlim)

  0115f	48 8b 84 24 38
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  01167	48 8b 80 70 08
	00 00		 mov	 rax, QWORD PTR [rax+2160]
  0116e	48 8b 8c 24 38
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  01176	48 8b 89 58 08
	00 00		 mov	 rcx, QWORD PTR [rcx+2136]
  0117d	48 39 88 b8 08
	00 00		 cmp	 QWORD PTR [rax+2232], rcx
  01184	0f 86 c2 00 00
	00		 jbe	 $LN131@s390_start
$LN37@s390_start:

; 600  :     {
; 601  :         SIE_SET_VI( SIE_VI_WHO_CPU, SIE_VI_WHEN_SIENT, SIE_VI_WHY_SCADR, GUESTREGS );

  0118a	48 8b 84 24 38
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  01192	48 8b 80 70 08
	00 00		 mov	 rax, QWORD PTR [rax+2160]
  01199	48 8b 80 88 08
	00 00		 mov	 rax, QWORD PTR [rax+2184]
  011a0	b9 01 00 00 00	 mov	 ecx, 1
  011a5	48 6b c9 00	 imul	 rcx, rcx, 0
  011a9	c6 44 08 56 01	 mov	 BYTE PTR [rax+rcx+86], 1
  011ae	48 8b 84 24 38
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  011b6	48 8b 80 70 08
	00 00		 mov	 rax, QWORD PTR [rax+2160]
  011bd	48 8b 80 88 08
	00 00		 mov	 rax, QWORD PTR [rax+2184]
  011c4	b9 01 00 00 00	 mov	 ecx, 1
  011c9	48 6b c9 01	 imul	 rcx, rcx, 1
  011cd	c6 44 08 56 10	 mov	 BYTE PTR [rax+rcx+86], 16
  011d2	66 b9 34 00	 mov	 cx, 52			; 00000034H
  011d6	e8 00 00 00 00	 call	 _byteswap_ushort
  011db	48 8b 8c 24 38
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  011e3	48 8b 89 70 08
	00 00		 mov	 rcx, QWORD PTR [rcx+2160]
  011ea	48 8b 89 88 08
	00 00		 mov	 rcx, QWORD PTR [rcx+2184]
  011f1	48 83 c1 58	 add	 rcx, 88			; 00000058H
  011f5	0f b7 d0	 movzx	 edx, ax
  011f8	e8 00 00 00 00	 call	 store_hw_noswap
  011fd	48 8b 84 24 38
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  01205	48 8b 80 70 08
	00 00		 mov	 rax, QWORD PTR [rax+2160]
  0120c	48 8b 80 88 08
	00 00		 mov	 rax, QWORD PTR [rax+2184]
  01213	48 83 c0 5a	 add	 rax, 90			; 0000005aH
  01217	48 8b f8	 mov	 rdi, rax
  0121a	33 c0		 xor	 eax, eax
  0121c	b9 06 00 00 00	 mov	 ecx, 6
  01221	f3 aa		 rep stosb
  01223	33 c0		 xor	 eax, eax
  01225	85 c0		 test	 eax, eax
  01227	0f 85 5d ff ff
	ff		 jne	 $LN37@s390_start

; 602  :         STATEBK->c = SIE_C_VALIDITY;

  0122d	48 8b 84 24 38
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  01235	48 8b 80 70 08
	00 00		 mov	 rax, QWORD PTR [rax+2160]
  0123c	48 8b 80 88 08
	00 00		 mov	 rax, QWORD PTR [rax+2184]
  01243	c6 40 50 20	 mov	 BYTE PTR [rax+80], 32	; 00000020H

; 603  :         return;

  01247	e9 2e 15 00 00	 jmp	 $LN1@s390_start
$LN131@s390_start:

; 604  :     }
; 605  : 
; 606  :     /* Validate MSO */
; 607  :     if (GUESTREGS->sie_mso)

  0124c	48 8b 84 24 38
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  01254	48 8b 80 70 08
	00 00		 mov	 rax, QWORD PTR [rax+2160]
  0125b	48 83 b8 98 08
	00 00 00	 cmp	 QWORD PTR [rax+2200], 0
  01263	0f 84 cc 01 00
	00		 je	 $LN132@s390_start

; 608  :     {
; 609  :         /* Preferred guest must have zero MSO */
; 610  :         if (GUESTREGS->sie_pref)

  01269	48 8b 84 24 38
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  01271	48 8b 80 70 08
	00 00		 mov	 rax, QWORD PTR [rax+2160]
  01278	8b 80 c8 08 00
	00		 mov	 eax, DWORD PTR [rax+2248]
  0127e	c1 e8 02	 shr	 eax, 2
  01281	83 e0 01	 and	 eax, 1
  01284	85 c0		 test	 eax, eax
  01286	0f 84 c2 00 00
	00		 je	 $LN133@s390_start
$LN40@s390_start:

; 611  :         {
; 612  :             SIE_SET_VI( SIE_VI_WHO_CPU, SIE_VI_WHEN_SIENT, SIE_VI_WHY_MSONZ, GUESTREGS );

  0128c	48 8b 84 24 38
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  01294	48 8b 80 70 08
	00 00		 mov	 rax, QWORD PTR [rax+2160]
  0129b	48 8b 80 88 08
	00 00		 mov	 rax, QWORD PTR [rax+2184]
  012a2	b9 01 00 00 00	 mov	 ecx, 1
  012a7	48 6b c9 00	 imul	 rcx, rcx, 0
  012ab	c6 44 08 56 01	 mov	 BYTE PTR [rax+rcx+86], 1
  012b0	48 8b 84 24 38
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  012b8	48 8b 80 70 08
	00 00		 mov	 rax, QWORD PTR [rax+2160]
  012bf	48 8b 80 88 08
	00 00		 mov	 rax, QWORD PTR [rax+2184]
  012c6	b9 01 00 00 00	 mov	 ecx, 1
  012cb	48 6b c9 01	 imul	 rcx, rcx, 1
  012cf	c6 44 08 56 10	 mov	 BYTE PTR [rax+rcx+86], 16
  012d4	66 b9 51 00	 mov	 cx, 81			; 00000051H
  012d8	e8 00 00 00 00	 call	 _byteswap_ushort
  012dd	48 8b 8c 24 38
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  012e5	48 8b 89 70 08
	00 00		 mov	 rcx, QWORD PTR [rcx+2160]
  012ec	48 8b 89 88 08
	00 00		 mov	 rcx, QWORD PTR [rcx+2184]
  012f3	48 83 c1 58	 add	 rcx, 88			; 00000058H
  012f7	0f b7 d0	 movzx	 edx, ax
  012fa	e8 00 00 00 00	 call	 store_hw_noswap
  012ff	48 8b 84 24 38
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  01307	48 8b 80 70 08
	00 00		 mov	 rax, QWORD PTR [rax+2160]
  0130e	48 8b 80 88 08
	00 00		 mov	 rax, QWORD PTR [rax+2184]
  01315	48 83 c0 5a	 add	 rax, 90			; 0000005aH
  01319	48 8b f8	 mov	 rdi, rax
  0131c	33 c0		 xor	 eax, eax
  0131e	b9 06 00 00 00	 mov	 ecx, 6
  01323	f3 aa		 rep stosb
  01325	33 c0		 xor	 eax, eax
  01327	85 c0		 test	 eax, eax
  01329	0f 85 5d ff ff
	ff		 jne	 $LN40@s390_start

; 613  :             STATEBK->c = SIE_C_VALIDITY;

  0132f	48 8b 84 24 38
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  01337	48 8b 80 70 08
	00 00		 mov	 rax, QWORD PTR [rax+2160]
  0133e	48 8b 80 88 08
	00 00		 mov	 rax, QWORD PTR [rax+2184]
  01345	c6 40 50 20	 mov	 BYTE PTR [rax+80], 32	; 00000020H

; 614  :             return;

  01349	e9 2c 14 00 00	 jmp	 $LN1@s390_start
$LN133@s390_start:

; 615  :         }
; 616  : 
; 617  :         /* MCDS guest must have zero MSO */
; 618  :         if (STATEBK->mx & SIE_MX_XC)

  0134e	48 8b 84 24 38
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  01356	48 8b 80 70 08
	00 00		 mov	 rax, QWORD PTR [rax+2160]
  0135d	48 8b 80 88 08
	00 00		 mov	 rax, QWORD PTR [rax+2184]
  01364	0f b6 40 02	 movzx	 eax, BYTE PTR [rax+2]
  01368	83 e0 01	 and	 eax, 1
  0136b	85 c0		 test	 eax, eax
  0136d	0f 84 c2 00 00
	00		 je	 $LN134@s390_start
$LN43@s390_start:

; 619  :         {
; 620  :             SIE_SET_VI( SIE_VI_WHO_CPU, SIE_VI_WHEN_SIENT, SIE_VI_WHY_MSODS, GUESTREGS );

  01373	48 8b 84 24 38
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0137b	48 8b 80 70 08
	00 00		 mov	 rax, QWORD PTR [rax+2160]
  01382	48 8b 80 88 08
	00 00		 mov	 rax, QWORD PTR [rax+2184]
  01389	b9 01 00 00 00	 mov	 ecx, 1
  0138e	48 6b c9 00	 imul	 rcx, rcx, 0
  01392	c6 44 08 56 01	 mov	 BYTE PTR [rax+rcx+86], 1
  01397	48 8b 84 24 38
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0139f	48 8b 80 70 08
	00 00		 mov	 rax, QWORD PTR [rax+2160]
  013a6	48 8b 80 88 08
	00 00		 mov	 rax, QWORD PTR [rax+2184]
  013ad	b9 01 00 00 00	 mov	 ecx, 1
  013b2	48 6b c9 01	 imul	 rcx, rcx, 1
  013b6	c6 44 08 56 10	 mov	 BYTE PTR [rax+rcx+86], 16
  013bb	66 b9 6a 00	 mov	 cx, 106			; 0000006aH
  013bf	e8 00 00 00 00	 call	 _byteswap_ushort
  013c4	48 8b 8c 24 38
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  013cc	48 8b 89 70 08
	00 00		 mov	 rcx, QWORD PTR [rcx+2160]
  013d3	48 8b 89 88 08
	00 00		 mov	 rcx, QWORD PTR [rcx+2184]
  013da	48 83 c1 58	 add	 rcx, 88			; 00000058H
  013de	0f b7 d0	 movzx	 edx, ax
  013e1	e8 00 00 00 00	 call	 store_hw_noswap
  013e6	48 8b 84 24 38
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  013ee	48 8b 80 70 08
	00 00		 mov	 rax, QWORD PTR [rax+2160]
  013f5	48 8b 80 88 08
	00 00		 mov	 rax, QWORD PTR [rax+2184]
  013fc	48 83 c0 5a	 add	 rax, 90			; 0000005aH
  01400	48 8b f8	 mov	 rdi, rax
  01403	33 c0		 xor	 eax, eax
  01405	b9 06 00 00 00	 mov	 ecx, 6
  0140a	f3 aa		 rep stosb
  0140c	33 c0		 xor	 eax, eax
  0140e	85 c0		 test	 eax, eax
  01410	0f 85 5d ff ff
	ff		 jne	 $LN43@s390_start

; 621  :             STATEBK->c = SIE_C_VALIDITY;

  01416	48 8b 84 24 38
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0141e	48 8b 80 70 08
	00 00		 mov	 rax, QWORD PTR [rax+2160]
  01425	48 8b 80 88 08
	00 00		 mov	 rax, QWORD PTR [rax+2184]
  0142c	c6 40 50 20	 mov	 BYTE PTR [rax+80], 32	; 00000020H

; 622  :             return;

  01430	e9 45 13 00 00	 jmp	 $LN1@s390_start
$LN134@s390_start:
$LN132@s390_start:

; 623  :         }
; 624  :     }
; 625  : 
; 626  :     GUESTREGS->sie_fld = false;  // (default until we learn otherwise)

  01435	48 8b 84 24 38
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0143d	48 8b 80 70 08
	00 00		 mov	 rax, QWORD PTR [rax+2160]
  01444	c6 80 cc 08 00
	00 00		 mov	 BYTE PTR [rax+2252], 0

; 627  : 
; 628  : #if defined( FEATURE_VIRTUAL_ARCHITECTURE_LEVEL )
; 629  : 
; 630  :     /* Set Virtual Architecture Level (Facility List) */
; 631  :     /* SIE guest facilities by default start out same as host's */
; 632  :     memcpy( GUESTREGS->facility_list, HOSTREGS->facility_list, STFL_HERC_BY_SIZE );
; 633  : 
; 634  :     /* Fetch address of optional SIE guest facility list designator */
; 635  :     FETCH_FW( fld, STATEBK->fld );
; 636  : 
; 637  :     if (0
; 638  :         || (U64)fld > regs->mainlim /* (beyond end of main storage?)  */
; 639  :         || (fld & ~0x7ffffff8)      /* (above 2GB or not DW aligned?) */
; 640  :     )
; 641  :     {
; 642  :         /* ZZ: FIXME
; 643  :         SIE_SET_VI( SIE_VI_WHO_CPU, SIE_VI_WHEN_SIENT, SIE_VI_WHY_??ADR, GUESTREGS );
; 644  :         */
; 645  :         STATEBK->c = SIE_C_VALIDITY;
; 646  :         return;
; 647  :     }
; 648  : 
; 649  :     if (fld)
; 650  :     {
; 651  :         GUESTREGS->sie_fld = true;
; 652  : 
; 653  : #if defined( OPTION_SIE2BK_FLD_COPY)
; 654  : 
; 655  :         /* If a facility list designator was provided
; 656  :            then it defines the SIE guest facility bits.
; 657  :         */
; 658  :         memcpy( GUESTREGS->facility_list, &regs->mainstor[ fld ], STFL_HERC_BY_SIZE );
; 659  : 
; 660  : #else /* !defined( OPTION_SIE2BK_FLD_COPY) */
; 661  : 
; 662  :         /* If a facility list designator was provided
; 663  :            then it's used as a mask to clear the SIE
; 664  :            guest facility bits which shouldn't be on.
; 665  :         */
; 666  :         for (i=0; i < (int) STFL_IBM_BY_SIZE; i++)
; 667  :             GUESTREGS->facility_list[i] &= regs->mainstor[ fld + i ];
; 668  : 
; 669  : #endif /* defined( OPTION_SIE2BK_FLD_COPY) */
; 670  :     }
; 671  : 
; 672  :     /* Prevent certain facility bits from being masked */
; 673  :     BIT_ARRAY_SET( GUESTREGS->facility_list, STFL_001_ZARCH_INSTALLED );
; 674  : 
; 675  :     if (ARCH_900_IDX == GUESTREGS->arch_mode)
; 676  :         BIT_ARRAY_SET( GUESTREGS->facility_list, STFL_002_ZARCH_ACTIVE );
; 677  :     else
; 678  :         BIT_ARRAY_CLR( GUESTREGS->facility_list, STFL_002_ZARCH_ACTIVE );
; 679  : 
; 680  : #endif /* defined( FEATURE_VIRTUAL_ARCHITECTURE_LEVEL ) */
; 681  : 
; 682  :    /* Reference and Change Preservation (RCP) Origin if high-order
; 683  :       0x80 bit is off. Otherwise (high-order 0x80 bit is on, which
; 684  :       it usually is for VM/ESA and z/VM), then the field ACTUALLY
; 685  :       contains various Execution Control flags such as Storage Key
; 686  :       Assist (SKA), etc.
; 687  :    */
; 688  :     FETCH_FW( GUESTREGS->sie_rcpo, STATEBK->rcpo );

  0144b	48 8b 84 24 38
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  01453	48 8b 80 70 08
	00 00		 mov	 rax, QWORD PTR [rax+2160]
  0145a	48 8b 80 88 08
	00 00		 mov	 rax, QWORD PTR [rax+2184]
  01461	48 83 c0 60	 add	 rax, 96			; 00000060H
  01465	48 8b c8	 mov	 rcx, rax
  01468	e8 00 00 00 00	 call	 fetch_fw_noswap
  0146d	8b c8		 mov	 ecx, eax
  0146f	e8 00 00 00 00	 call	 _byteswap_ulong
  01474	48 8b 8c 24 38
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0147c	48 8b 89 70 08
	00 00		 mov	 rcx, QWORD PTR [rcx+2160]
  01483	8b c0		 mov	 eax, eax
  01485	48 89 81 b0 08
	00 00		 mov	 QWORD PTR [rcx+2224], rax

; 689  : 
; 690  : #if !defined( FEATURE_001_ZARCH_INSTALLED_FACILITY )
; 691  : 
; 692  :     if (!GUESTREGS->sie_rcpo && !GUESTREGS->sie_pref)

  0148c	48 8b 84 24 38
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  01494	48 8b 80 70 08
	00 00		 mov	 rax, QWORD PTR [rax+2160]
  0149b	48 83 b8 b0 08
	00 00 00	 cmp	 QWORD PTR [rax+2224], 0
  014a3	0f 85 e5 00 00
	00		 jne	 $LN135@s390_start
  014a9	48 8b 84 24 38
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  014b1	48 8b 80 70 08
	00 00		 mov	 rax, QWORD PTR [rax+2160]
  014b8	8b 80 c8 08 00
	00		 mov	 eax, DWORD PTR [rax+2248]
  014be	c1 e8 02	 shr	 eax, 2
  014c1	83 e0 01	 and	 eax, 1
  014c4	85 c0		 test	 eax, eax
  014c6	0f 85 c2 00 00
	00		 jne	 $LN135@s390_start
$LN46@s390_start:

; 693  :     {
; 694  :         SIE_SET_VI( SIE_VI_WHO_CPU, SIE_VI_WHEN_SIENT, SIE_VI_WHY_RCZER, GUESTREGS );

  014cc	48 8b 84 24 38
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  014d4	48 8b 80 70 08
	00 00		 mov	 rax, QWORD PTR [rax+2160]
  014db	48 8b 80 88 08
	00 00		 mov	 rax, QWORD PTR [rax+2184]
  014e2	b9 01 00 00 00	 mov	 ecx, 1
  014e7	48 6b c9 00	 imul	 rcx, rcx, 0
  014eb	c6 44 08 56 01	 mov	 BYTE PTR [rax+rcx+86], 1
  014f0	48 8b 84 24 38
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  014f8	48 8b 80 70 08
	00 00		 mov	 rax, QWORD PTR [rax+2160]
  014ff	48 8b 80 88 08
	00 00		 mov	 rax, QWORD PTR [rax+2184]
  01506	b9 01 00 00 00	 mov	 ecx, 1
  0150b	48 6b c9 01	 imul	 rcx, rcx, 1
  0150f	c6 44 08 56 10	 mov	 BYTE PTR [rax+rcx+86], 16
  01514	66 b9 67 00	 mov	 cx, 103			; 00000067H
  01518	e8 00 00 00 00	 call	 _byteswap_ushort
  0151d	48 8b 8c 24 38
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  01525	48 8b 89 70 08
	00 00		 mov	 rcx, QWORD PTR [rcx+2160]
  0152c	48 8b 89 88 08
	00 00		 mov	 rcx, QWORD PTR [rcx+2184]
  01533	48 83 c1 58	 add	 rcx, 88			; 00000058H
  01537	0f b7 d0	 movzx	 edx, ax
  0153a	e8 00 00 00 00	 call	 store_hw_noswap
  0153f	48 8b 84 24 38
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  01547	48 8b 80 70 08
	00 00		 mov	 rax, QWORD PTR [rax+2160]
  0154e	48 8b 80 88 08
	00 00		 mov	 rax, QWORD PTR [rax+2184]
  01555	48 83 c0 5a	 add	 rax, 90			; 0000005aH
  01559	48 8b f8	 mov	 rdi, rax
  0155c	33 c0		 xor	 eax, eax
  0155e	b9 06 00 00 00	 mov	 ecx, 6
  01563	f3 aa		 rep stosb
  01565	33 c0		 xor	 eax, eax
  01567	85 c0		 test	 eax, eax
  01569	0f 85 5d ff ff
	ff		 jne	 $LN46@s390_start

; 695  :         STATEBK->c = SIE_C_VALIDITY;

  0156f	48 8b 84 24 38
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  01577	48 8b 80 70 08
	00 00		 mov	 rax, QWORD PTR [rax+2160]
  0157e	48 8b 80 88 08
	00 00		 mov	 rax, QWORD PTR [rax+2184]
  01585	c6 40 50 20	 mov	 BYTE PTR [rax+80], 32	; 00000020H

; 696  :         return;

  01589	e9 ec 11 00 00	 jmp	 $LN1@s390_start
$LN135@s390_start:

; 697  :     }
; 698  : #endif
; 699  : 
; 700  :     /* Load the CPU timer */
; 701  :     FETCH_DW( dreg, STATEBK->cputimer );

  0158e	48 8b 84 24 38
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  01596	48 8b 80 70 08
	00 00		 mov	 rax, QWORD PTR [rax+2160]
  0159d	48 8b 80 88 08
	00 00		 mov	 rax, QWORD PTR [rax+2184]
  015a4	48 83 c0 28	 add	 rax, 40			; 00000028H
  015a8	48 8b c8	 mov	 rcx, rax
  015ab	e8 00 00 00 00	 call	 fetch_dw_noswap
  015b0	48 8b c8	 mov	 rcx, rax
  015b3	e8 00 00 00 00	 call	 _byteswap_uint64
  015b8	48 89 84 24 f0
	00 00 00	 mov	 QWORD PTR dreg$[rsp], rax

; 702  :     set_cpu_timer( GUESTREGS, dreg );

  015c0	48 8b 94 24 f0
	00 00 00	 mov	 rdx, QWORD PTR dreg$[rsp]
  015c8	48 8b 84 24 38
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  015d0	48 8b 88 70 08
	00 00		 mov	 rcx, QWORD PTR [rax+2160]
  015d7	e8 00 00 00 00	 call	 set_cpu_timer

; 703  : 
; 704  :     /* Load the TOD clock offset for this guest */
; 705  :     FETCH_DW( GUESTREGS->sie_epoch, STATEBK->epoch );

  015dc	48 8b 84 24 38
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  015e4	48 8b 80 70 08
	00 00		 mov	 rax, QWORD PTR [rax+2160]
  015eb	48 8b 80 88 08
	00 00		 mov	 rax, QWORD PTR [rax+2184]
  015f2	48 83 c0 38	 add	 rax, 56			; 00000038H
  015f6	48 8b c8	 mov	 rcx, rax
  015f9	e8 00 00 00 00	 call	 fetch_dw_noswap
  015fe	48 8b c8	 mov	 rcx, rax
  01601	e8 00 00 00 00	 call	 _byteswap_uint64
  01606	48 8b 8c 24 38
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0160e	48 8b 89 70 08
	00 00		 mov	 rcx, QWORD PTR [rcx+2160]
  01615	48 89 81 c0 08
	00 00		 mov	 QWORD PTR [rcx+2240], rax

; 706  :     GUESTREGS->tod_epoch = regs->tod_epoch + TOD_high64_to_ETOD_high56( GUESTREGS->sie_epoch );

  0161c	48 8b 84 24 38
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  01624	48 8b 80 70 08
	00 00		 mov	 rax, QWORD PTR [rax+2160]
  0162b	48 8b 88 c0 08
	00 00		 mov	 rcx, QWORD PTR [rax+2240]
  01632	e8 00 00 00 00	 call	 TOD_high64_to_ETOD_high56
  01637	48 8b 8c 24 38
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0163f	48 03 81 40 07
	00 00		 add	 rax, QWORD PTR [rcx+1856]
  01646	48 8b 8c 24 38
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0164e	48 8b 89 70 08
	00 00		 mov	 rcx, QWORD PTR [rcx+2160]
  01655	48 89 81 40 07
	00 00		 mov	 QWORD PTR [rcx+1856], rax

; 707  : 
; 708  :     /* Load the clock comparator */
; 709  :     FETCH_DW( GUESTREGS->clkc, STATEBK->clockcomp );

  0165c	48 8b 84 24 38
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  01664	48 8b 80 70 08
	00 00		 mov	 rax, QWORD PTR [rax+2160]
  0166b	48 8b 80 88 08
	00 00		 mov	 rax, QWORD PTR [rax+2184]
  01672	48 83 c0 30	 add	 rax, 48			; 00000030H
  01676	48 8b c8	 mov	 rcx, rax
  01679	e8 00 00 00 00	 call	 fetch_dw_noswap
  0167e	48 8b c8	 mov	 rcx, rax
  01681	e8 00 00 00 00	 call	 _byteswap_uint64
  01686	48 8b 8c 24 38
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0168e	48 8b 89 70 08
	00 00		 mov	 rcx, QWORD PTR [rcx+2160]
  01695	48 89 81 48 07
	00 00		 mov	 QWORD PTR [rcx+1864], rax

; 710  :     GUESTREGS->clkc = TOD_high64_to_ETOD_high56( GUESTREGS->clkc );  /* Internal Hercules format */

  0169c	48 8b 84 24 38
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  016a4	48 8b 80 70 08
	00 00		 mov	 rax, QWORD PTR [rax+2160]
  016ab	48 8b 88 48 07
	00 00		 mov	 rcx, QWORD PTR [rax+1864]
  016b2	e8 00 00 00 00	 call	 TOD_high64_to_ETOD_high56
  016b7	48 8b 8c 24 38
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  016bf	48 8b 89 70 08
	00 00		 mov	 rcx, QWORD PTR [rcx+2160]
  016c6	48 89 81 48 07
	00 00		 mov	 QWORD PTR [rcx+1864], rax

; 711  : 
; 712  :     /* Load TOD Programmable Field */
; 713  :     FETCH_HW( GUESTREGS->todpr, STATEBK->todpf );

  016cd	48 8b 84 24 38
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  016d5	48 8b 80 70 08
	00 00		 mov	 rax, QWORD PTR [rax+2160]
  016dc	48 8b 80 88 08
	00 00		 mov	 rax, QWORD PTR [rax+2184]
  016e3	48 83 c0 54	 add	 rax, 84			; 00000054H
  016e7	48 8b c8	 mov	 rcx, rax
  016ea	e8 00 00 00 00	 call	 fetch_hw_noswap
  016ef	0f b7 c8	 movzx	 ecx, ax
  016f2	e8 00 00 00 00	 call	 _byteswap_ushort
  016f7	48 8b 8c 24 38
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  016ff	48 8b 89 70 08
	00 00		 mov	 rcx, QWORD PTR [rcx+2160]
  01706	0f b7 c0	 movzx	 eax, ax
  01709	89 81 58 07 00
	00		 mov	 DWORD PTR [rcx+1880], eax

; 714  : 
; 715  :     /* Load the guest registers */
; 716  :     memcpy( GUESTREGS->gr,  regs->gr,  14 * sizeof( regs->gr [0] ));

  0170f	48 8b 84 24 38
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  01717	48 8b 80 70 08
	00 00		 mov	 rax, QWORD PTR [rax+2160]
  0171e	48 8b 8c 24 38
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  01726	48 8d b8 80 02
	00 00		 lea	 rdi, QWORD PTR [rax+640]
  0172d	48 8d b1 80 02
	00 00		 lea	 rsi, QWORD PTR [rcx+640]
  01734	b9 70 00 00 00	 mov	 ecx, 112		; 00000070H
  01739	f3 a4		 rep movsb

; 717  :     memcpy( GUESTREGS->ar,  regs->ar,  16 * sizeof( regs->ar [0] ));

  0173b	48 8b 84 24 38
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  01743	48 8b 80 70 08
	00 00		 mov	 rax, QWORD PTR [rax+2160]
  0174a	48 8b 8c 24 38
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  01752	48 8d b8 00 03
	00 00		 lea	 rdi, QWORD PTR [rax+768]
  01759	48 8d b1 00 03
	00 00		 lea	 rsi, QWORD PTR [rcx+768]
  01760	b9 40 00 00 00	 mov	 ecx, 64			; 00000040H
  01765	f3 a4		 rep movsb

; 718  :     memcpy( GUESTREGS->fpr, regs->fpr, 32 * sizeof( regs->fpr[0] ));

  01767	48 8b 84 24 38
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0176f	48 8b 80 70 08
	00 00		 mov	 rax, QWORD PTR [rax+2160]
  01776	48 8b 8c 24 38
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0177e	48 8d b8 40 03
	00 00		 lea	 rdi, QWORD PTR [rax+832]
  01785	48 8d b1 40 03
	00 00		 lea	 rsi, QWORD PTR [rcx+832]
  0178c	b9 80 00 00 00	 mov	 ecx, 128		; 00000080H
  01791	f3 a4		 rep movsb

; 719  : #if defined( FEATURE_BINARY_FLOATING_POINT )
; 720  :     GUESTREGS->fpc =  regs->fpc;

  01793	48 8b 84 24 38
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0179b	48 8b 80 70 08
	00 00		 mov	 rax, QWORD PTR [rax+2160]
  017a2	48 8b 8c 24 38
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  017aa	8b 89 c0 03 00
	00		 mov	 ecx, DWORD PTR [rcx+960]
  017b0	89 88 c0 03 00
	00		 mov	 DWORD PTR [rax+960], ecx

; 721  : #endif
; 722  : 
; 723  :     /* Load GR14 and GR15 */
; 724  :     FETCH_W( GUESTREGS->GR(14), STATEBK->gr14 );

  017b6	48 8b 84 24 38
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  017be	48 8b 80 70 08
	00 00		 mov	 rax, QWORD PTR [rax+2160]
  017c5	48 8b 80 88 08
	00 00		 mov	 rax, QWORD PTR [rax+2184]
  017cc	48 83 c0 10	 add	 rax, 16
  017d0	48 8b c8	 mov	 rcx, rax
  017d3	e8 00 00 00 00	 call	 fetch_fw_noswap
  017d8	8b c8		 mov	 ecx, eax
  017da	e8 00 00 00 00	 call	 _byteswap_ulong
  017df	48 8b 8c 24 38
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  017e7	48 8b 89 70 08
	00 00		 mov	 rcx, QWORD PTR [rcx+2160]
  017ee	ba 08 00 00 00	 mov	 edx, 8
  017f3	48 6b d2 0e	 imul	 rdx, rdx, 14
  017f7	89 84 11 80 02
	00 00		 mov	 DWORD PTR [rcx+rdx+640], eax

; 725  :     FETCH_W( GUESTREGS->GR(15), STATEBK->gr15 );

  017fe	48 8b 84 24 38
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  01806	48 8b 80 70 08
	00 00		 mov	 rax, QWORD PTR [rax+2160]
  0180d	48 8b 80 88 08
	00 00		 mov	 rax, QWORD PTR [rax+2184]
  01814	48 83 c0 14	 add	 rax, 20
  01818	48 8b c8	 mov	 rcx, rax
  0181b	e8 00 00 00 00	 call	 fetch_fw_noswap
  01820	8b c8		 mov	 ecx, eax
  01822	e8 00 00 00 00	 call	 _byteswap_ulong
  01827	48 8b 8c 24 38
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0182f	48 8b 89 70 08
	00 00		 mov	 rcx, QWORD PTR [rcx+2160]
  01836	ba 08 00 00 00	 mov	 edx, 8
  0183b	48 6b d2 0f	 imul	 rdx, rdx, 15
  0183f	89 84 11 80 02
	00 00		 mov	 DWORD PTR [rcx+rdx+640], eax

; 726  : 
; 727  :     /* Load control registers */
; 728  :     for (n=0; n < 16; n++)

  01846	c7 44 24 70 00
	00 00 00	 mov	 DWORD PTR n$[rsp], 0
  0184e	eb 0a		 jmp	 SHORT $LN49@s390_start
$LN47@s390_start:
  01850	8b 44 24 70	 mov	 eax, DWORD PTR n$[rsp]
  01854	ff c0		 inc	 eax
  01856	89 44 24 70	 mov	 DWORD PTR n$[rsp], eax
$LN49@s390_start:
  0185a	83 7c 24 70 10	 cmp	 DWORD PTR n$[rsp], 16
  0185f	7d 53		 jge	 SHORT $LN48@s390_start

; 729  :         FETCH_W( GUESTREGS->CR( n ), STATEBK->cr[ n ]);

  01861	48 8b 84 24 38
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  01869	48 8b 80 70 08
	00 00		 mov	 rax, QWORD PTR [rax+2160]
  01870	48 8b 80 88 08
	00 00		 mov	 rax, QWORD PTR [rax+2184]
  01877	48 63 4c 24 70	 movsxd	 rcx, DWORD PTR n$[rsp]
  0187c	48 8d 84 88 80
	00 00 00	 lea	 rax, QWORD PTR [rax+rcx*4+128]
  01884	48 8b c8	 mov	 rcx, rax
  01887	e8 00 00 00 00	 call	 fetch_fw_noswap
  0188c	8b c8		 mov	 ecx, eax
  0188e	e8 00 00 00 00	 call	 _byteswap_ulong
  01893	48 8b 8c 24 38
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0189b	48 8b 89 70 08
	00 00		 mov	 rcx, QWORD PTR [rcx+2160]
  018a2	8b 54 24 70	 mov	 edx, DWORD PTR n$[rsp]
  018a6	ff c2		 inc	 edx
  018a8	48 63 d2	 movsxd	 rdx, edx
  018ab	89 84 d1 00 06
	00 00		 mov	 DWORD PTR [rcx+rdx*8+1536], eax
  018b2	eb 9c		 jmp	 SHORT $LN47@s390_start
$LN48@s390_start:

; 730  : 
; 731  :     /* Remember whether CPU or state is different from last time */
; 732  :     FETCH_HW( lhcpu, STATEBK->lhcpu );

  018b4	48 8b 84 24 38
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  018bc	48 8b 80 70 08
	00 00		 mov	 rax, QWORD PTR [rax+2160]
  018c3	48 8b 80 88 08
	00 00		 mov	 rax, QWORD PTR [rax+2184]
  018ca	48 83 c0 52	 add	 rax, 82			; 00000052H
  018ce	48 8b c8	 mov	 rcx, rax
  018d1	e8 00 00 00 00	 call	 fetch_hw_noswap
  018d6	0f b7 c8	 movzx	 ecx, ax
  018d9	e8 00 00 00 00	 call	 _byteswap_ushort
  018de	66 89 44 24 7c	 mov	 WORD PTR lhcpu$[rsp], ax

; 733  :     sie_state = SIE_STATE( GUESTREGS );

  018e3	48 8b 84 24 38
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  018eb	48 8b 80 70 08
	00 00		 mov	 rax, QWORD PTR [rax+2160]
  018f2	48 8b 80 80 08
	00 00		 mov	 rax, QWORD PTR [rax+2176]
  018f9	48 89 84 24 f8
	00 00 00	 mov	 QWORD PTR sie_state$[rsp], rax

; 734  : 
; 735  :     same_cpu   = (regs->cpuad == lhcpu);

  01901	48 8b 84 24 38
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  01909	0f b7 80 3c 08
	00 00		 movzx	 eax, WORD PTR [rax+2108]
  01910	0f b7 4c 24 7c	 movzx	 ecx, WORD PTR lhcpu$[rsp]
  01915	3b c1		 cmp	 eax, ecx
  01917	75 0d		 jne	 SHORT $LN172@s390_start
  01919	c7 84 24 9c 00
	00 00 01 00 00
	00		 mov	 DWORD PTR tv968[rsp], 1
  01924	eb 0b		 jmp	 SHORT $LN173@s390_start
$LN172@s390_start:
  01926	c7 84 24 9c 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv968[rsp], 0
$LN173@s390_start:
  01931	83 bc 24 9c 00
	00 00 00	 cmp	 DWORD PTR tv968[rsp], 0
  01939	75 0d		 jne	 SHORT $LN174@s390_start
  0193b	c7 84 24 a0 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv970[rsp], 0
  01946	eb 0b		 jmp	 SHORT $LN175@s390_start
$LN174@s390_start:
  01948	c7 84 24 a0 00
	00 00 01 00 00
	00		 mov	 DWORD PTR tv970[rsp], 1
$LN175@s390_start:
  01953	0f b6 84 24 a0
	00 00 00	 movzx	 eax, BYTE PTR tv970[rsp]
  0195b	88 44 24 78	 mov	 BYTE PTR same_cpu$[rsp], al

; 736  :     same_state = (effective_addr2 == sie_state);

  0195f	48 8b 84 24 f8
	00 00 00	 mov	 rax, QWORD PTR sie_state$[rsp]
  01967	48 39 44 24 68	 cmp	 QWORD PTR effective_addr2$[rsp], rax
  0196c	75 0d		 jne	 SHORT $LN176@s390_start
  0196e	c7 84 24 a4 00
	00 00 01 00 00
	00		 mov	 DWORD PTR tv973[rsp], 1
  01979	eb 0b		 jmp	 SHORT $LN177@s390_start
$LN176@s390_start:
  0197b	c7 84 24 a4 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv973[rsp], 0
$LN177@s390_start:
  01986	83 bc 24 a4 00
	00 00 00	 cmp	 DWORD PTR tv973[rsp], 0
  0198e	75 0d		 jne	 SHORT $LN178@s390_start
  01990	c7 84 24 a8 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv975[rsp], 0
  0199b	eb 0b		 jmp	 SHORT $LN179@s390_start
$LN178@s390_start:
  0199d	c7 84 24 a8 00
	00 00 01 00 00
	00		 mov	 DWORD PTR tv975[rsp], 1
$LN179@s390_start:
  019a8	0f b6 84 24 a8
	00 00 00	 movzx	 eax, BYTE PTR tv975[rsp]
  019b0	88 44 24 79	 mov	 BYTE PTR same_state$[rsp], al

; 737  : 
; 738  :     /* Regardless, set both of them to their proper current value */
; 739  :     SIE_STATE( GUESTREGS ) = effective_addr2;

  019b4	48 8b 84 24 38
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  019bc	48 8b 80 70 08
	00 00		 mov	 rax, QWORD PTR [rax+2160]
  019c3	48 8b 4c 24 68	 mov	 rcx, QWORD PTR effective_addr2$[rsp]
  019c8	48 89 88 80 08
	00 00		 mov	 QWORD PTR [rax+2176], rcx

; 740  :     STORE_HW( STATEBK->lhcpu, regs->cpuad );

  019cf	48 8b 84 24 38
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  019d7	0f b7 88 3c 08
	00 00		 movzx	 ecx, WORD PTR [rax+2108]
  019de	e8 00 00 00 00	 call	 _byteswap_ushort
  019e3	48 8b 8c 24 38
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  019eb	48 8b 89 70 08
	00 00		 mov	 rcx, QWORD PTR [rcx+2160]
  019f2	48 8b 89 88 08
	00 00		 mov	 rcx, QWORD PTR [rcx+2184]
  019f9	48 83 c1 52	 add	 rcx, 82			; 00000052H
  019fd	0f b7 d0	 movzx	 edx, ax
  01a00	e8 00 00 00 00	 call	 store_hw_noswap

; 741  : 
; 742  :     /*----------------------------------------*/
; 743  :     /* Maybe purge the guest's TLB/ALB or not */
; 744  :     /*----------------------------------------*/
; 745  : #if !defined( OPTION_SIE_PURGE_DAT_ALWAYS )
; 746  :     /*
; 747  :      *   If this is not the same last host cpu that dispatched
; 748  :      *   this state descriptor then clear the guest TLB entries.
; 749  :      */
; 750  :     if (!same_cpu || !same_state)
; 751  :     {
; 752  :         SIE_PERFMON( SIE_PERF_ENTER_F );
; 753  : 
; 754  :         /* Purge guest TLB entries */
; 755  : 
; 756  :         switch (GUESTREGS->arch_mode)
; 757  :         {
; 758  :         case ARCH_370_IDX: s370_purge_tlb( GUESTREGS );                              break;
; 759  :         case ARCH_390_IDX: s390_purge_tlb( GUESTREGS ); s390_purge_alb( GUESTREGS ); break;
; 760  :         case ARCH_900_IDX: z900_purge_tlb( GUESTREGS ); z900_purge_alb( GUESTREGS ); break;
; 761  :         default: CRASH();
; 762  :         }
; 763  :     }
; 764  : #else // defined( OPTION_SIE_PURGE_DAT_ALWAYS )
; 765  :     /*
; 766  :      *   ALWAYS purge guest TLB entries (Ivan 2016-07-30)
; 767  :      */
; 768  :     switch (GUESTREGS->arch_mode)

  01a05	48 8b 84 24 38
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  01a0d	48 8b 80 70 08
	00 00		 mov	 rax, QWORD PTR [rax+2160]
  01a14	8b 40 64	 mov	 eax, DWORD PTR [rax+100]
  01a17	89 84 24 80 00
	00 00		 mov	 DWORD PTR tv989[rsp], eax
  01a1e	83 bc 24 80 00
	00 00 00	 cmp	 DWORD PTR tv989[rsp], 0
  01a26	74 16		 je	 SHORT $LN136@s390_start
  01a28	83 bc 24 80 00
	00 00 01	 cmp	 DWORD PTR tv989[rsp], 1
  01a30	74 22		 je	 SHORT $LN137@s390_start
  01a32	83 bc 24 80 00
	00 00 02	 cmp	 DWORD PTR tv989[rsp], 2
  01a3a	74 42		 je	 SHORT $LN138@s390_start
  01a3c	eb 6a		 jmp	 SHORT $LN139@s390_start
$LN136@s390_start:

; 769  :     {
; 770  :     case ARCH_370_IDX: s370_purge_tlb( GUESTREGS );                              break;

  01a3e	48 8b 84 24 38
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  01a46	48 8b 88 70 08
	00 00		 mov	 rcx, QWORD PTR [rax+2160]
  01a4d	e8 00 00 00 00	 call	 s370_purge_tlb
  01a52	eb 71		 jmp	 SHORT $LN50@s390_start
$LN137@s390_start:

; 771  :     case ARCH_390_IDX: s390_purge_tlb( GUESTREGS ); s390_purge_alb( GUESTREGS ); break;

  01a54	48 8b 84 24 38
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  01a5c	48 8b 88 70 08
	00 00		 mov	 rcx, QWORD PTR [rax+2160]
  01a63	e8 00 00 00 00	 call	 s390_purge_tlb
  01a68	48 8b 84 24 38
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  01a70	48 8b 88 70 08
	00 00		 mov	 rcx, QWORD PTR [rax+2160]
  01a77	e8 00 00 00 00	 call	 s390_purge_alb
  01a7c	eb 47		 jmp	 SHORT $LN50@s390_start
$LN138@s390_start:

; 772  :     case ARCH_900_IDX: z900_purge_tlb( GUESTREGS ); z900_purge_alb( GUESTREGS ); break;

  01a7e	48 8b 84 24 38
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  01a86	48 8b 88 70 08
	00 00		 mov	 rcx, QWORD PTR [rax+2160]
  01a8d	e8 00 00 00 00	 call	 z900_purge_tlb
  01a92	48 8b 84 24 38
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  01a9a	48 8b 88 70 08
	00 00		 mov	 rcx, QWORD PTR [rax+2160]
  01aa1	e8 00 00 00 00	 call	 z900_purge_alb
  01aa6	eb 1d		 jmp	 SHORT $LN50@s390_start
$LN139@s390_start:
$LN54@s390_start:

; 773  :     default: CRASH();

  01aa8	48 c7 84 24 00
	01 00 00 00 00
	00 00		 mov	 QWORD PTR p$9[rsp], 0
  01ab4	48 8b 84 24 00
	01 00 00	 mov	 rax, QWORD PTR p$9[rsp]
  01abc	c6 00 00	 mov	 BYTE PTR [rax], 0
  01abf	33 c0		 xor	 eax, eax
  01ac1	85 c0		 test	 eax, eax
  01ac3	75 e3		 jne	 SHORT $LN54@s390_start
$LN50@s390_start:

; 774  :     }
; 775  : #endif // defined( OPTION_SIE_PURGE_DAT_ALWAYS )
; 776  : 
; 777  :     /* Initialize interrupt mask and state */
; 778  :     ARCH_DEP( set_guest_ic_mask )( GUESTREGS );

  01ac5	48 8b 84 24 38
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  01acd	48 8b 88 70 08
	00 00		 mov	 rcx, QWORD PTR [rax+2160]
  01ad4	e8 00 00 00 00	 call	 s390_set_guest_ic_mask

; 779  :     SET_IC_INITIAL_STATE( GUESTREGS );

  01ad9	48 8b 84 24 38
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  01ae1	48 8b 80 70 08
	00 00		 mov	 rax, QWORD PTR [rax+2160]
  01ae8	c7 40 48 01 00
	00 00		 mov	 DWORD PTR [rax+72], 1
$LN57@s390_start:

; 780  :     SET_IC_PER( GUESTREGS );

  01aef	48 8b 84 24 38
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  01af7	48 8b 80 70 08
	00 00		 mov	 rax, QWORD PTR [rax+2160]
  01afe	8b 40 48	 mov	 eax, DWORD PTR [rax+72]
  01b01	25 ff ff 00 ff	 and	 eax, -16711681		; ff00ffffH
  01b06	48 8b 8c 24 38
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  01b0e	48 8b 89 70 08
	00 00		 mov	 rcx, QWORD PTR [rcx+2160]
  01b15	89 41 48	 mov	 DWORD PTR [rcx+72], eax
  01b18	48 8b 84 24 38
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  01b20	48 8b 80 70 08
	00 00		 mov	 rax, QWORD PTR [rax+2160]
  01b27	48 8b 8c 24 38
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  01b2f	48 8b 89 70 08
	00 00		 mov	 rcx, QWORD PTR [rcx+2160]
  01b36	ba 08 00 00 00	 mov	 edx, 8
  01b3b	48 6b d2 0a	 imul	 rdx, rdx, 10
  01b3f	8b 8c 11 00 06
	00 00		 mov	 ecx, DWORD PTR [rcx+rdx+1536]
  01b46	c1 e9 08	 shr	 ecx, 8
  01b49	81 e1 00 00 ff
	00		 and	 ecx, 16711680		; 00ff0000H
  01b4f	8b 40 48	 mov	 eax, DWORD PTR [rax+72]
  01b52	0b c1		 or	 eax, ecx
  01b54	48 8b 8c 24 38
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  01b5c	48 8b 89 70 08
	00 00		 mov	 rcx, QWORD PTR [rcx+2160]
  01b63	89 41 48	 mov	 DWORD PTR [rcx+72], eax
  01b66	48 8b 84 24 38
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  01b6e	48 8b 80 70 08
	00 00		 mov	 rax, QWORD PTR [rax+2160]
  01b75	48 8b 8c 24 38
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  01b7d	48 8b 89 70 08
	00 00		 mov	 rcx, QWORD PTR [rcx+2160]
  01b84	8b 49 48	 mov	 ecx, DWORD PTR [rcx+72]
  01b87	81 c9 ff ff 00
	ff		 or	 ecx, -16711681		; ff00ffffH
  01b8d	8b 40 4c	 mov	 eax, DWORD PTR [rax+76]
  01b90	23 c1		 and	 eax, ecx
  01b92	48 8b 8c 24 38
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  01b9a	48 8b 89 70 08
	00 00		 mov	 rcx, QWORD PTR [rcx+2160]
  01ba1	89 41 4c	 mov	 DWORD PTR [rcx+76], eax
  01ba4	33 c0		 xor	 eax, eax
  01ba6	85 c0		 test	 eax, eax
  01ba8	0f 85 41 ff ff
	ff		 jne	 $LN57@s390_start

; 781  : 
; 782  :     /* Initialize accelerated address lookup values */
; 783  :     ARCH_DEP( set_guest_aea_mode   )( GUESTREGS );

  01bae	48 8b 84 24 38
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  01bb6	48 8b 88 70 08
	00 00		 mov	 rcx, QWORD PTR [rax+2160]
  01bbd	e8 00 00 00 00	 call	 s390_set_guest_aea_mode

; 784  :     ARCH_DEP( set_guest_aea_common )( GUESTREGS );

  01bc2	48 8b 84 24 38
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  01bca	48 8b 88 70 08
	00 00		 mov	 rcx, QWORD PTR [rax+2160]
  01bd1	e8 00 00 00 00	 call	 s390_set_guest_aea_common

; 785  :     ARCH_DEP( invalidate_guest_aia )( GUESTREGS );

  01bd6	48 8b 84 24 38
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  01bde	48 8b 88 70 08
	00 00		 mov	 rcx, QWORD PTR [rax+2160]
  01be5	e8 00 00 00 00	 call	 s390_invalidate_guest_aia

; 786  : 
; 787  :     GUESTREGS->breakortrace = regs->breakortrace;

  01bea	48 8b 84 24 38
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  01bf2	8b 80 28 07 00
	00		 mov	 eax, DWORD PTR [rax+1832]
  01bf8	c1 e8 10	 shr	 eax, 16
  01bfb	83 e0 01	 and	 eax, 1
  01bfe	48 8b 8c 24 38
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  01c06	48 8b 89 70 08
	00 00		 mov	 rcx, QWORD PTR [rcx+2160]
  01c0d	83 e0 01	 and	 eax, 1
  01c10	c1 e0 10	 shl	 eax, 16
  01c13	8b 89 28 07 00
	00		 mov	 ecx, DWORD PTR [rcx+1832]
  01c19	0f ba f1 10	 btr	 ecx, 16
  01c1d	0b c8		 or	 ecx, eax
  01c1f	8b c1		 mov	 eax, ecx
  01c21	48 8b 8c 24 38
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  01c29	48 8b 89 70 08
	00 00		 mov	 rcx, QWORD PTR [rcx+2160]
  01c30	89 81 28 07 00
	00		 mov	 DWORD PTR [rcx+1832], eax

; 788  : 
; 789  :     /* Must do setjmp(progjmp) here since the 'translate_addr' further
; 790  :        below may result in longjmp(progjmp) for addressing exceptions.
; 791  :     */
; 792  :     if (!(icode = setjmp( GUESTREGS->progjmp )))

  01c36	48 8b 84 24 38
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  01c3e	48 8b 80 70 08
	00 00		 mov	 rax, QWORD PTR [rax+2160]
  01c45	48 05 80 09 00
	00		 add	 rax, 2432		; 00000980H
  01c4b	48 8b c8	 mov	 rcx, rax
  01c4e	48 8b d4	 mov	 rdx, rsp
  01c51	e8 00 00 00 00	 call	 _setjmp
  01c56	89 44 24 60	 mov	 DWORD PTR icode$[rsp], eax
  01c5a	8b 44 24 60	 mov	 eax, DWORD PTR icode$[rsp]
  01c5e	85 c0		 test	 eax, eax
  01c60	0f 85 e6 09 00
	00		 jne	 $LN140@s390_start
$LN60@s390_start:

; 793  :     {
; 794  :         /*
; 795  :          * Set sie_active to 1. This means other threads
; 796  :          * may now access guestregs when holding intlock.
; 797  :          * This is the *ONLY* place sie_active is set to 1!
; 798  :          */
; 799  :         PTT_SIE( "SIE a=1", 0, 0, 0 );

  01c66	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_pttclass
  01c6d	48 8b 00	 mov	 rax, QWORD PTR [rax]
  01c70	48 25 80 00 00
	00		 and	 rax, 128		; 00000080H
  01c76	48 85 c0	 test	 rax, rax
  01c79	74 36		 je	 SHORT $LN141@s390_start
  01c7b	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR [rsp+48], 0
  01c84	48 c7 44 24 28
	00 00 00 00	 mov	 QWORD PTR [rsp+40], 0
  01c8d	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG180601
  01c94	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  01c99	45 33 c9	 xor	 r9d, r9d
  01c9c	45 33 c0	 xor	 r8d, r8d
  01c9f	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG180602
  01ca6	b9 80 00 00 00	 mov	 ecx, 128		; 00000080H
  01cab	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ptt_pthread_trace
$LN141@s390_start:
  01cb1	33 c0		 xor	 eax, eax
  01cb3	85 c0		 test	 eax, eax
  01cb5	75 af		 jne	 SHORT $LN60@s390_start

; 800  :         OBTAIN_INTLOCK( regs );

  01cb7	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG180603
  01cbe	48 8b 8c 24 38
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  01cc6	e8 00 00 00 00	 call	 Obtain_Interrupt_Lock

; 801  :         {
; 802  :             regs->sie_active = 1;

  01ccb	48 8b 84 24 38
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  01cd3	8b 80 c8 08 00
	00		 mov	 eax, DWORD PTR [rax+2248]
  01cd9	83 c8 01	 or	 eax, 1
  01cdc	48 8b 8c 24 38
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  01ce4	89 81 c8 08 00
	00		 mov	 DWORD PTR [rcx+2248], eax

; 803  :         }
; 804  :         RELEASE_INTLOCK( regs );

  01cea	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG180604
  01cf1	48 8b 8c 24 38
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  01cf9	e8 00 00 00 00	 call	 Release_Interrupt_Lock

; 805  : 
; 806  :         /* Get PSA pointer and ensure PSA is paged in */
; 807  :         if (GUESTREGS->sie_pref)

  01cfe	48 8b 84 24 38
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  01d06	48 8b 80 70 08
	00 00		 mov	 rax, QWORD PTR [rax+2160]
  01d0d	8b 80 c8 08 00
	00		 mov	 eax, DWORD PTR [rax+2248]
  01d13	c1 e8 02	 shr	 eax, 2
  01d16	83 e0 01	 and	 eax, 1
  01d19	85 c0		 test	 eax, eax
  01d1b	74 6e		 je	 SHORT $LN142@s390_start

; 808  :         {
; 809  :             GUESTREGS->psa = (PSA_3XX*)(GUESTREGS->mainstor + GUESTREGS->PX);

  01d1d	48 8b 84 24 38
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  01d25	48 8b 80 70 08
	00 00		 mov	 rax, QWORD PTR [rax+2160]
  01d2c	48 8b 8c 24 38
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  01d34	48 8b 89 70 08
	00 00		 mov	 rcx, QWORD PTR [rcx+2160]
  01d3b	8b 49 70	 mov	 ecx, DWORD PTR [rcx+112]
  01d3e	48 03 88 48 08
	00 00		 add	 rcx, QWORD PTR [rax+2120]
  01d45	48 8b c1	 mov	 rax, rcx
  01d48	48 8b 8c 24 38
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  01d50	48 8b 89 70 08
	00 00		 mov	 rcx, QWORD PTR [rcx+2160]
  01d57	48 89 81 60 08
	00 00		 mov	 QWORD PTR [rcx+2144], rax

; 810  :             GUESTREGS->sie_px = GUESTREGS->PX;

  01d5e	48 8b 84 24 38
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  01d66	48 8b 80 70 08
	00 00		 mov	 rax, QWORD PTR [rax+2160]
  01d6d	48 8b 8c 24 38
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  01d75	48 8b 89 70 08
	00 00		 mov	 rcx, QWORD PTR [rcx+2160]
  01d7c	8b 40 70	 mov	 eax, DWORD PTR [rax+112]
  01d7f	48 89 81 90 08
	00 00		 mov	 QWORD PTR [rcx+2192], rax

; 811  :         }

  01d86	e9 b4 03 00 00	 jmp	 $LN143@s390_start
$LN142@s390_start:

; 812  :         else
; 813  :         {
; 814  :             /* NOTE: longjmp(progjmp) for addressing exception is possible
; 815  :                here. Thus the need for doing setjmp(progjmp) further above.
; 816  :             */
; 817  :             /* Translate where this SIE guest's absolute storage begins
; 818  :                (which is a host virtual address) to a host real address.
; 819  :             */
; 820  :             if (ARCH_DEP( translate_addr )( GUESTREGS->sie_mso + GUESTREGS->PX,

  01d8b	48 8b 84 24 38
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  01d93	48 8b 80 70 08
	00 00		 mov	 rax, QWORD PTR [rax+2160]
  01d9a	48 8b 8c 24 38
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  01da2	48 8b 89 70 08
	00 00		 mov	 rcx, QWORD PTR [rcx+2160]
  01da9	8b 49 70	 mov	 ecx, DWORD PTR [rcx+112]
  01dac	48 03 88 98 08
	00 00		 add	 rcx, QWORD PTR [rax+2200]
  01db3	48 8b c1	 mov	 rax, rcx
  01db6	45 33 c9	 xor	 r9d, r9d
  01db9	4c 8b 84 24 38
	01 00 00	 mov	 r8, QWORD PTR regs$[rsp]
  01dc1	ba fd ff ff ff	 mov	 edx, -3
  01dc6	8b c8		 mov	 ecx, eax
  01dc8	e8 00 00 00 00	 call	 s390_translate_addr
  01dcd	85 c0		 test	 eax, eax
  01dcf	0f 84 5a 01 00
	00		 je	 $LN144@s390_start
$LN63@s390_start:

; 821  :                                             USE_PRIMARY_SPACE, regs, ACCTYPE_SIE ))
; 822  :             {
; 823  :                 SIE_SET_VI( SIE_VI_WHO_CPU, SIE_VI_WHEN_SIENT, SIE_VI_WHY_PFACC, GUESTREGS );

  01dd5	48 8b 84 24 38
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  01ddd	48 8b 80 70 08
	00 00		 mov	 rax, QWORD PTR [rax+2160]
  01de4	48 8b 80 88 08
	00 00		 mov	 rax, QWORD PTR [rax+2184]
  01deb	b9 01 00 00 00	 mov	 ecx, 1
  01df0	48 6b c9 00	 imul	 rcx, rcx, 0
  01df4	c6 44 08 56 01	 mov	 BYTE PTR [rax+rcx+86], 1
  01df9	48 8b 84 24 38
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  01e01	48 8b 80 70 08
	00 00		 mov	 rax, QWORD PTR [rax+2160]
  01e08	48 8b 80 88 08
	00 00		 mov	 rax, QWORD PTR [rax+2184]
  01e0f	b9 01 00 00 00	 mov	 ecx, 1
  01e14	48 6b c9 01	 imul	 rcx, rcx, 1
  01e18	c6 44 08 56 10	 mov	 BYTE PTR [rax+rcx+86], 16
  01e1d	66 b9 37 00	 mov	 cx, 55			; 00000037H
  01e21	e8 00 00 00 00	 call	 _byteswap_ushort
  01e26	48 8b 8c 24 38
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  01e2e	48 8b 89 70 08
	00 00		 mov	 rcx, QWORD PTR [rcx+2160]
  01e35	48 8b 89 88 08
	00 00		 mov	 rcx, QWORD PTR [rcx+2184]
  01e3c	48 83 c1 58	 add	 rcx, 88			; 00000058H
  01e40	0f b7 d0	 movzx	 edx, ax
  01e43	e8 00 00 00 00	 call	 store_hw_noswap
  01e48	48 8b 84 24 38
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  01e50	48 8b 80 70 08
	00 00		 mov	 rax, QWORD PTR [rax+2160]
  01e57	48 8b 80 88 08
	00 00		 mov	 rax, QWORD PTR [rax+2184]
  01e5e	48 83 c0 5a	 add	 rax, 90			; 0000005aH
  01e62	48 8b f8	 mov	 rdi, rax
  01e65	33 c0		 xor	 eax, eax
  01e67	b9 06 00 00 00	 mov	 ecx, 6
  01e6c	f3 aa		 rep stosb
  01e6e	33 c0		 xor	 eax, eax
  01e70	85 c0		 test	 eax, eax
  01e72	0f 85 5d ff ff
	ff		 jne	 $LN63@s390_start

; 824  :                 STATEBK->c = SIE_C_VALIDITY;

  01e78	48 8b 84 24 38
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  01e80	48 8b 80 70 08
	00 00		 mov	 rax, QWORD PTR [rax+2160]
  01e87	48 8b 80 88 08
	00 00		 mov	 rax, QWORD PTR [rax+2184]
  01e8e	c6 40 50 20	 mov	 BYTE PTR [rax+80], 32	; 00000020H
$LN66@s390_start:

; 825  : 
; 826  :                 PTT_SIE( "SIE a=0", 0, 0, 0 );

  01e92	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_pttclass
  01e99	48 8b 00	 mov	 rax, QWORD PTR [rax]
  01e9c	48 25 80 00 00
	00		 and	 rax, 128		; 00000080H
  01ea2	48 85 c0	 test	 rax, rax
  01ea5	74 36		 je	 SHORT $LN145@s390_start
  01ea7	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR [rsp+48], 0
  01eb0	48 c7 44 24 28
	00 00 00 00	 mov	 QWORD PTR [rsp+40], 0
  01eb9	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG180609
  01ec0	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  01ec5	45 33 c9	 xor	 r9d, r9d
  01ec8	45 33 c0	 xor	 r8d, r8d
  01ecb	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG180610
  01ed2	b9 80 00 00 00	 mov	 ecx, 128		; 00000080H
  01ed7	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ptt_pthread_trace
$LN145@s390_start:
  01edd	33 c0		 xor	 eax, eax
  01edf	85 c0		 test	 eax, eax
  01ee1	75 af		 jne	 SHORT $LN66@s390_start

; 827  :                 OBTAIN_INTLOCK( regs );

  01ee3	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG180611
  01eea	48 8b 8c 24 38
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  01ef2	e8 00 00 00 00	 call	 Obtain_Interrupt_Lock

; 828  :                 {
; 829  :                     regs->sie_active = 0;

  01ef7	48 8b 84 24 38
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  01eff	8b 80 c8 08 00
	00		 mov	 eax, DWORD PTR [rax+2248]
  01f05	83 e0 fe	 and	 eax, -2			; fffffffeH
  01f08	48 8b 8c 24 38
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  01f10	89 81 c8 08 00
	00		 mov	 DWORD PTR [rcx+2248], eax

; 830  :                 }
; 831  :                 RELEASE_INTLOCK( regs );

  01f16	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG180612
  01f1d	48 8b 8c 24 38
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  01f25	e8 00 00 00 00	 call	 Release_Interrupt_Lock

; 832  :                 return;

  01f2a	e9 4b 08 00 00	 jmp	 $LN1@s390_start
$LN144@s390_start:

; 833  :             }
; 834  : 
; 835  :             /* Convert host real address to host absolute address */
; 836  :             GUESTREGS->sie_px = apply_host_prefixing( regs, regs->dat.raddr );

  01f2f	48 8b 84 24 38
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  01f37	48 8b 90 00 08
	00 00		 mov	 rdx, QWORD PTR [rax+2048]
  01f3e	48 8b 8c 24 38
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  01f46	e8 00 00 00 00	 call	 apply_host_prefixing
  01f4b	48 8b 8c 24 38
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  01f53	48 8b 89 70 08
	00 00		 mov	 rcx, QWORD PTR [rcx+2160]
  01f5a	48 89 81 90 08
	00 00		 mov	 QWORD PTR [rcx+2192], rax

; 837  : 
; 838  :             if (regs->dat.protect || GUESTREGS->sie_px > regs->mainlim)

  01f61	48 8b 84 24 38
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  01f69	8b 80 34 08 00
	00		 mov	 eax, DWORD PTR [rax+2100]
  01f6f	d1 e8		 shr	 eax, 1
  01f71	83 e0 03	 and	 eax, 3
  01f74	85 c0		 test	 eax, eax
  01f76	75 2b		 jne	 SHORT $LN147@s390_start
  01f78	48 8b 84 24 38
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  01f80	48 8b 80 70 08
	00 00		 mov	 rax, QWORD PTR [rax+2160]
  01f87	48 8b 8c 24 38
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  01f8f	48 8b 89 58 08
	00 00		 mov	 rcx, QWORD PTR [rcx+2136]
  01f96	48 39 88 90 08
	00 00		 cmp	 QWORD PTR [rax+2192], rcx
  01f9d	0f 86 5a 01 00
	00		 jbe	 $LN146@s390_start
$LN147@s390_start:
$LN69@s390_start:

; 839  :             {
; 840  :                 SIE_SET_VI( SIE_VI_WHO_CPU, SIE_VI_WHEN_SIENT, SIE_VI_WHY_PFACC, GUESTREGS );

  01fa3	48 8b 84 24 38
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  01fab	48 8b 80 70 08
	00 00		 mov	 rax, QWORD PTR [rax+2160]
  01fb2	48 8b 80 88 08
	00 00		 mov	 rax, QWORD PTR [rax+2184]
  01fb9	b9 01 00 00 00	 mov	 ecx, 1
  01fbe	48 6b c9 00	 imul	 rcx, rcx, 0
  01fc2	c6 44 08 56 01	 mov	 BYTE PTR [rax+rcx+86], 1
  01fc7	48 8b 84 24 38
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  01fcf	48 8b 80 70 08
	00 00		 mov	 rax, QWORD PTR [rax+2160]
  01fd6	48 8b 80 88 08
	00 00		 mov	 rax, QWORD PTR [rax+2184]
  01fdd	b9 01 00 00 00	 mov	 ecx, 1
  01fe2	48 6b c9 01	 imul	 rcx, rcx, 1
  01fe6	c6 44 08 56 10	 mov	 BYTE PTR [rax+rcx+86], 16
  01feb	66 b9 37 00	 mov	 cx, 55			; 00000037H
  01fef	e8 00 00 00 00	 call	 _byteswap_ushort
  01ff4	48 8b 8c 24 38
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  01ffc	48 8b 89 70 08
	00 00		 mov	 rcx, QWORD PTR [rcx+2160]
  02003	48 8b 89 88 08
	00 00		 mov	 rcx, QWORD PTR [rcx+2184]
  0200a	48 83 c1 58	 add	 rcx, 88			; 00000058H
  0200e	0f b7 d0	 movzx	 edx, ax
  02011	e8 00 00 00 00	 call	 store_hw_noswap
  02016	48 8b 84 24 38
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0201e	48 8b 80 70 08
	00 00		 mov	 rax, QWORD PTR [rax+2160]
  02025	48 8b 80 88 08
	00 00		 mov	 rax, QWORD PTR [rax+2184]
  0202c	48 83 c0 5a	 add	 rax, 90			; 0000005aH
  02030	48 8b f8	 mov	 rdi, rax
  02033	33 c0		 xor	 eax, eax
  02035	b9 06 00 00 00	 mov	 ecx, 6
  0203a	f3 aa		 rep stosb
  0203c	33 c0		 xor	 eax, eax
  0203e	85 c0		 test	 eax, eax
  02040	0f 85 5d ff ff
	ff		 jne	 $LN69@s390_start

; 841  :                 STATEBK->c = SIE_C_VALIDITY;

  02046	48 8b 84 24 38
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0204e	48 8b 80 70 08
	00 00		 mov	 rax, QWORD PTR [rax+2160]
  02055	48 8b 80 88 08
	00 00		 mov	 rax, QWORD PTR [rax+2184]
  0205c	c6 40 50 20	 mov	 BYTE PTR [rax+80], 32	; 00000020H
$LN72@s390_start:

; 842  : 
; 843  :                 PTT_SIE( "SIE a=0", 0, 0, 0 );

  02060	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_pttclass
  02067	48 8b 00	 mov	 rax, QWORD PTR [rax]
  0206a	48 25 80 00 00
	00		 and	 rax, 128		; 00000080H
  02070	48 85 c0	 test	 rax, rax
  02073	74 36		 je	 SHORT $LN148@s390_start
  02075	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR [rsp+48], 0
  0207e	48 c7 44 24 28
	00 00 00 00	 mov	 QWORD PTR [rsp+40], 0
  02087	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG180616
  0208e	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  02093	45 33 c9	 xor	 r9d, r9d
  02096	45 33 c0	 xor	 r8d, r8d
  02099	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG180617
  020a0	b9 80 00 00 00	 mov	 ecx, 128		; 00000080H
  020a5	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ptt_pthread_trace
$LN148@s390_start:
  020ab	33 c0		 xor	 eax, eax
  020ad	85 c0		 test	 eax, eax
  020af	75 af		 jne	 SHORT $LN72@s390_start

; 844  :                 OBTAIN_INTLOCK( regs );

  020b1	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG180618
  020b8	48 8b 8c 24 38
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  020c0	e8 00 00 00 00	 call	 Obtain_Interrupt_Lock

; 845  :                 {
; 846  :                     regs->sie_active = 0;

  020c5	48 8b 84 24 38
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  020cd	8b 80 c8 08 00
	00		 mov	 eax, DWORD PTR [rax+2248]
  020d3	83 e0 fe	 and	 eax, -2			; fffffffeH
  020d6	48 8b 8c 24 38
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  020de	89 81 c8 08 00
	00		 mov	 DWORD PTR [rcx+2248], eax

; 847  :                 }
; 848  :                 RELEASE_INTLOCK( regs );

  020e4	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG180619
  020eb	48 8b 8c 24 38
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  020f3	e8 00 00 00 00	 call	 Release_Interrupt_Lock

; 849  :                 return;

  020f8	e9 7d 06 00 00	 jmp	 $LN1@s390_start
$LN146@s390_start:

; 850  :             }
; 851  :             GUESTREGS->psa = (PSA_3XX*)(GUESTREGS->mainstor + GUESTREGS->sie_px);

  020fd	48 8b 84 24 38
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  02105	48 8b 80 70 08
	00 00		 mov	 rax, QWORD PTR [rax+2160]
  0210c	48 8b 8c 24 38
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  02114	48 8b 89 70 08
	00 00		 mov	 rcx, QWORD PTR [rcx+2160]
  0211b	48 8b 80 48 08
	00 00		 mov	 rax, QWORD PTR [rax+2120]
  02122	48 03 81 90 08
	00 00		 add	 rax, QWORD PTR [rcx+2192]
  02129	48 8b 8c 24 38
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  02131	48 8b 89 70 08
	00 00		 mov	 rcx, QWORD PTR [rcx+2160]
  02138	48 89 81 60 08
	00 00		 mov	 QWORD PTR [rcx+2144], rax
$LN143@s390_start:

; 852  :         }
; 853  : 
; 854  :         OBTAIN_INTLOCK( regs );

  0213f	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG180620
  02146	48 8b 8c 24 38
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0214e	e8 00 00 00 00	 call	 Obtain_Interrupt_Lock

; 855  :         {
; 856  :             /* Intialize guest timers... */
; 857  : 
; 858  :             /* CPU timer */
; 859  :             if (CPU_TIMER( GUESTREGS ) < 0)

  02153	48 8b 84 24 38
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0215b	48 8b 88 70 08
	00 00		 mov	 rcx, QWORD PTR [rax+2160]
  02162	e8 00 00 00 00	 call	 get_cpu_timer
  02167	48 85 c0	 test	 rax, rax
  0216a	7d 74		 jge	 SHORT $LN149@s390_start
$LN75@s390_start:

; 860  :                 ON_IC_PTIMER( GUESTREGS );

  0216c	48 8b 84 24 38
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  02174	48 8b 80 70 08
	00 00		 mov	 rax, QWORD PTR [rax+2160]
  0217b	8b 40 4c	 mov	 eax, DWORD PTR [rax+76]
  0217e	25 00 04 00 00	 and	 eax, 1024		; 00000400H
  02183	85 c0		 test	 eax, eax
  02185	74 2b		 je	 SHORT $LN150@s390_start
  02187	48 8b 84 24 38
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0218f	48 8b 80 70 08
	00 00		 mov	 rax, QWORD PTR [rax+2160]
  02196	8b 40 48	 mov	 eax, DWORD PTR [rax+72]
  02199	0d 00 04 00 80	 or	 eax, -2147482624	; 80000400H
  0219e	48 8b 8c 24 38
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  021a6	48 8b 89 70 08
	00 00		 mov	 rcx, QWORD PTR [rcx+2160]
  021ad	89 41 48	 mov	 DWORD PTR [rcx+72], eax
  021b0	eb 28		 jmp	 SHORT $LN151@s390_start
$LN150@s390_start:
  021b2	48 8b 84 24 38
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  021ba	48 8b 80 70 08
	00 00		 mov	 rax, QWORD PTR [rax+2160]
  021c1	8b 40 48	 mov	 eax, DWORD PTR [rax+72]
  021c4	0f ba e8 0a	 bts	 eax, 10
  021c8	48 8b 8c 24 38
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  021d0	48 8b 89 70 08
	00 00		 mov	 rcx, QWORD PTR [rcx+2160]
  021d7	89 41 48	 mov	 DWORD PTR [rcx+72], eax
$LN151@s390_start:
  021da	33 c0		 xor	 eax, eax
  021dc	85 c0		 test	 eax, eax
  021de	75 8c		 jne	 SHORT $LN75@s390_start
$LN149@s390_start:

; 861  : 
; 862  :             /* Clock comparator */
; 863  :             if (TOD_CLOCK( GUESTREGS ) > GUESTREGS->clkc)

  021e0	48 b8 ff ff ff
	ff ff ff ff 00	 mov	 rax, 72057594037927935	; 00ffffffffffffffH
  021ea	48 8b 0d 08 00
	00 00		 mov	 rcx, QWORD PTR tod_value+8
  021f1	48 23 c8	 and	 rcx, rax
  021f4	48 8b c1	 mov	 rax, rcx
  021f7	48 8b 8c 24 38
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  021ff	48 8b 89 70 08
	00 00		 mov	 rcx, QWORD PTR [rcx+2160]
  02206	48 03 81 40 07
	00 00		 add	 rax, QWORD PTR [rcx+1856]
  0220d	48 8b 8c 24 38
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  02215	48 8b 89 70 08
	00 00		 mov	 rcx, QWORD PTR [rcx+2160]
  0221c	48 3b 81 48 07
	00 00		 cmp	 rax, QWORD PTR [rcx+1864]
  02223	76 74		 jbe	 SHORT $LN152@s390_start
$LN78@s390_start:

; 864  :                 ON_IC_CLKC( GUESTREGS );

  02225	48 8b 84 24 38
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0222d	48 8b 80 70 08
	00 00		 mov	 rax, QWORD PTR [rax+2160]
  02234	8b 40 4c	 mov	 eax, DWORD PTR [rax+76]
  02237	25 00 08 00 00	 and	 eax, 2048		; 00000800H
  0223c	85 c0		 test	 eax, eax
  0223e	74 2b		 je	 SHORT $LN153@s390_start
  02240	48 8b 84 24 38
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  02248	48 8b 80 70 08
	00 00		 mov	 rax, QWORD PTR [rax+2160]
  0224f	8b 40 48	 mov	 eax, DWORD PTR [rax+72]
  02252	0d 00 08 00 80	 or	 eax, -2147481600	; 80000800H
  02257	48 8b 8c 24 38
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0225f	48 8b 89 70 08
	00 00		 mov	 rcx, QWORD PTR [rcx+2160]
  02266	89 41 48	 mov	 DWORD PTR [rcx+72], eax
  02269	eb 28		 jmp	 SHORT $LN154@s390_start
$LN153@s390_start:
  0226b	48 8b 84 24 38
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  02273	48 8b 80 70 08
	00 00		 mov	 rax, QWORD PTR [rax+2160]
  0227a	8b 40 48	 mov	 eax, DWORD PTR [rax+72]
  0227d	0f ba e8 0b	 bts	 eax, 11
  02281	48 8b 8c 24 38
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  02289	48 8b 89 70 08
	00 00		 mov	 rcx, QWORD PTR [rcx+2160]
  02290	89 41 48	 mov	 DWORD PTR [rcx+72], eax
$LN154@s390_start:
  02293	33 c0		 xor	 eax, eax
  02295	85 c0		 test	 eax, eax
  02297	75 8c		 jne	 SHORT $LN78@s390_start
$LN152@s390_start:

; 865  : 
; 866  : #if !defined( FEATURE_001_ZARCH_INSTALLED_FACILITY )
; 867  : 
; 868  :             /* Interval timer if S/370 and timer is enabled */
; 869  :             if (1
; 870  :                 && (STATEBK->m & SIE_M_370)
; 871  :                 && !(STATEBK->m & SIE_M_ITMOF)

  02299	33 c0		 xor	 eax, eax
  0229b	83 f8 01	 cmp	 eax, 1
  0229e	0f 84 1b 02 00
	00		 je	 $LN155@s390_start
  022a4	48 8b 84 24 38
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  022ac	48 8b 80 70 08
	00 00		 mov	 rax, QWORD PTR [rax+2160]
  022b3	48 8b 80 88 08
	00 00		 mov	 rax, QWORD PTR [rax+2184]
  022ba	0f b6 40 03	 movzx	 eax, BYTE PTR [rax+3]
  022be	83 e0 10	 and	 eax, 16
  022c1	85 c0		 test	 eax, eax
  022c3	0f 84 f6 01 00
	00		 je	 $LN155@s390_start
  022c9	48 8b 84 24 38
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  022d1	48 8b 80 70 08
	00 00		 mov	 rax, QWORD PTR [rax+2160]
  022d8	48 8b 80 88 08
	00 00		 mov	 rax, QWORD PTR [rax+2184]
  022df	0f b6 40 03	 movzx	 eax, BYTE PTR [rax+3]
  022e3	83 e0 04	 and	 eax, 4
  022e6	85 c0		 test	 eax, eax
  022e8	0f 85 d1 01 00
	00		 jne	 $LN155@s390_start

; 872  :             )
; 873  :             {
; 874  :                 S32 itimer, olditimer;
; 875  :                 U32 residue;
; 876  : 
; 877  :                 /* Set the interval timer pending according to
; 878  :                    the T bit in the state control
; 879  :                 */
; 880  :                 if (STATEBK->s & SIE_S_T)

  022ee	48 8b 84 24 38
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  022f6	48 8b 80 70 08
	00 00		 mov	 rax, QWORD PTR [rax+2160]
  022fd	48 8b 80 88 08
	00 00		 mov	 rax, QWORD PTR [rax+2184]
  02304	0f b6 40 01	 movzx	 eax, BYTE PTR [rax+1]
  02308	25 80 00 00 00	 and	 eax, 128		; 00000080H
  0230d	85 c0		 test	 eax, eax
  0230f	74 74		 je	 SHORT $LN156@s390_start
$LN81@s390_start:

; 881  :                     ON_IC_ITIMER( GUESTREGS );

  02311	48 8b 84 24 38
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  02319	48 8b 80 70 08
	00 00		 mov	 rax, QWORD PTR [rax+2160]
  02320	8b 40 4c	 mov	 eax, DWORD PTR [rax+76]
  02323	25 80 00 00 00	 and	 eax, 128		; 00000080H
  02328	85 c0		 test	 eax, eax
  0232a	74 2b		 je	 SHORT $LN157@s390_start
  0232c	48 8b 84 24 38
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  02334	48 8b 80 70 08
	00 00		 mov	 rax, QWORD PTR [rax+2160]
  0233b	8b 40 48	 mov	 eax, DWORD PTR [rax+72]
  0233e	0d 80 00 00 80	 or	 eax, -2147483520	; 80000080H
  02343	48 8b 8c 24 38
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0234b	48 8b 89 70 08
	00 00		 mov	 rcx, QWORD PTR [rcx+2160]
  02352	89 41 48	 mov	 DWORD PTR [rcx+72], eax
  02355	eb 28		 jmp	 SHORT $LN158@s390_start
$LN157@s390_start:
  02357	48 8b 84 24 38
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0235f	48 8b 80 70 08
	00 00		 mov	 rax, QWORD PTR [rax+2160]
  02366	8b 40 48	 mov	 eax, DWORD PTR [rax+72]
  02369	0f ba e8 07	 bts	 eax, 7
  0236d	48 8b 8c 24 38
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  02375	48 8b 89 70 08
	00 00		 mov	 rcx, QWORD PTR [rcx+2160]
  0237c	89 41 48	 mov	 DWORD PTR [rcx+72], eax
$LN158@s390_start:
  0237f	33 c0		 xor	 eax, eax
  02381	85 c0		 test	 eax, eax
  02383	75 8c		 jne	 SHORT $LN81@s390_start
$LN156@s390_start:

; 882  : 
; 883  :                 /* Fetch the residue from the state descriptor */
; 884  :                 FETCH_FW( residue, STATEBK->residue );

  02385	48 8b 84 24 38
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0238d	48 8b 80 70 08
	00 00		 mov	 rax, QWORD PTR [rax+2160]
  02394	48 8b 80 88 08
	00 00		 mov	 rax, QWORD PTR [rax+2184]
  0239b	48 83 c0 24	 add	 rax, 36			; 00000024H
  0239f	48 8b c8	 mov	 rcx, rax
  023a2	e8 00 00 00 00	 call	 fetch_fw_noswap
  023a7	8b c8		 mov	 ecx, eax
  023a9	e8 00 00 00 00	 call	 _byteswap_ulong
  023ae	89 84 24 c4 00
	00 00		 mov	 DWORD PTR residue$6[rsp], eax

; 885  : 
; 886  :                 /* Fetch the timer value from location 80 */
; 887  :                 FETCH_FW( olditimer, GUESTREGS->psa->inttimer );

  023b5	48 8b 84 24 38
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  023bd	48 8b 80 70 08
	00 00		 mov	 rax, QWORD PTR [rax+2160]
  023c4	48 8b 80 60 08
	00 00		 mov	 rax, QWORD PTR [rax+2144]
  023cb	48 83 c0 50	 add	 rax, 80			; 00000050H
  023cf	48 8b c8	 mov	 rcx, rax
  023d2	e8 00 00 00 00	 call	 fetch_fw_noswap
  023d7	8b c8		 mov	 ecx, eax
  023d9	e8 00 00 00 00	 call	 _byteswap_ulong
  023de	89 84 24 b0 00
	00 00		 mov	 DWORD PTR olditimer$4[rsp], eax

; 888  : 
; 889  :                 /* Bit position 23 of the interval timer is decremented
; 890  :                    once for each multiple of 3,333 usecs containded in
; 891  :                    bit position 0-19 of the residue counter.
; 892  :                 */
; 893  :                 itimer = olditimer - ((residue / 3333) >> 4);

  023e5	33 d2		 xor	 edx, edx
  023e7	8b 84 24 c4 00
	00 00		 mov	 eax, DWORD PTR residue$6[rsp]
  023ee	b9 05 0d 00 00	 mov	 ecx, 3333		; 00000d05H
  023f3	f7 f1		 div	 ecx
  023f5	c1 e8 04	 shr	 eax, 4
  023f8	8b 8c 24 b0 00
	00 00		 mov	 ecx, DWORD PTR olditimer$4[rsp]
  023ff	2b c8		 sub	 ecx, eax
  02401	8b c1		 mov	 eax, ecx
  02403	89 84 24 ac 00
	00 00		 mov	 DWORD PTR itimer$3[rsp], eax

; 894  : 
; 895  :                 /* Store the timer back */
; 896  :                 STORE_FW( GUESTREGS->psa->inttimer, itimer );

  0240a	8b 8c 24 ac 00
	00 00		 mov	 ecx, DWORD PTR itimer$3[rsp]
  02411	e8 00 00 00 00	 call	 _byteswap_ulong
  02416	48 8b 8c 24 38
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0241e	48 8b 89 70 08
	00 00		 mov	 rcx, QWORD PTR [rcx+2160]
  02425	48 8b 89 60 08
	00 00		 mov	 rcx, QWORD PTR [rcx+2144]
  0242c	48 83 c1 50	 add	 rcx, 80			; 00000050H
  02430	8b d0		 mov	 edx, eax
  02432	e8 00 00 00 00	 call	 store_fw_noswap

; 897  : 
; 898  :                 /* Set interrupt flag and interval timer interrupt pending
; 899  :                    if the interval timer went from positive to negative
; 900  :                 */
; 901  :                 if (itimer < 0 && olditimer >= 0)

  02437	83 bc 24 ac 00
	00 00 00	 cmp	 DWORD PTR itimer$3[rsp], 0
  0243f	7d 7e		 jge	 SHORT $LN159@s390_start
  02441	83 bc 24 b0 00
	00 00 00	 cmp	 DWORD PTR olditimer$4[rsp], 0
  02449	7c 74		 jl	 SHORT $LN159@s390_start
$LN84@s390_start:

; 902  :                     ON_IC_ITIMER( GUESTREGS );

  0244b	48 8b 84 24 38
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  02453	48 8b 80 70 08
	00 00		 mov	 rax, QWORD PTR [rax+2160]
  0245a	8b 40 4c	 mov	 eax, DWORD PTR [rax+76]
  0245d	25 80 00 00 00	 and	 eax, 128		; 00000080H
  02462	85 c0		 test	 eax, eax
  02464	74 2b		 je	 SHORT $LN160@s390_start
  02466	48 8b 84 24 38
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0246e	48 8b 80 70 08
	00 00		 mov	 rax, QWORD PTR [rax+2160]
  02475	8b 40 48	 mov	 eax, DWORD PTR [rax+72]
  02478	0d 80 00 00 80	 or	 eax, -2147483520	; 80000080H
  0247d	48 8b 8c 24 38
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  02485	48 8b 89 70 08
	00 00		 mov	 rcx, QWORD PTR [rcx+2160]
  0248c	89 41 48	 mov	 DWORD PTR [rcx+72], eax
  0248f	eb 28		 jmp	 SHORT $LN161@s390_start
$LN160@s390_start:
  02491	48 8b 84 24 38
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  02499	48 8b 80 70 08
	00 00		 mov	 rax, QWORD PTR [rax+2160]
  024a0	8b 40 48	 mov	 eax, DWORD PTR [rax+72]
  024a3	0f ba e8 07	 bts	 eax, 7
  024a7	48 8b 8c 24 38
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  024af	48 8b 89 70 08
	00 00		 mov	 rcx, QWORD PTR [rcx+2160]
  024b6	89 41 48	 mov	 DWORD PTR [rcx+72], eax
$LN161@s390_start:
  024b9	33 c0		 xor	 eax, eax
  024bb	85 c0		 test	 eax, eax
  024bd	75 8c		 jne	 SHORT $LN84@s390_start
$LN159@s390_start:
$LN155@s390_start:

; 903  :             }
; 904  : #endif /* !defined( FEATURE_001_ZARCH_INSTALLED_FACILITY ) */
; 905  : 
; 906  :         }
; 907  :         RELEASE_INTLOCK( regs );

  024bf	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG180634
  024c6	48 8b 8c 24 38
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  024ce	e8 00 00 00 00	 call	 Release_Interrupt_Lock

; 908  : 
; 909  :         /* Early exceptions associated with the guest load_psw() */
; 910  :         if (lpsw_xcode)

  024d3	83 7c 24 74 00	 cmp	 DWORD PTR lpsw_xcode$[rsp], 0
  024d8	74 7e		 je	 SHORT $LN162@s390_start
$LN87@s390_start:

; 911  :         {
; 912  :             PTT_SIE( "*SIE > pgmint", lpsw_xcode, 0, 0 );

  024da	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_pttclass
  024e1	48 8b 00	 mov	 rax, QWORD PTR [rax]
  024e4	48 25 80 00 00
	00		 and	 rax, 128		; 00000080H
  024ea	48 85 c0	 test	 rax, rax
  024ed	74 3b		 je	 SHORT $LN163@s390_start
  024ef	48 63 44 24 74	 movsxd	 rax, DWORD PTR lpsw_xcode$[rsp]
  024f4	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR [rsp+48], 0
  024fd	48 c7 44 24 28
	00 00 00 00	 mov	 QWORD PTR [rsp+40], 0
  02506	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG180637
  0250d	48 89 4c 24 20	 mov	 QWORD PTR [rsp+32], rcx
  02512	45 33 c9	 xor	 r9d, r9d
  02515	4c 8b c0	 mov	 r8, rax
  02518	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG180638
  0251f	b9 80 00 00 00	 mov	 ecx, 128		; 00000080H
  02524	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ptt_pthread_trace
$LN163@s390_start:
  0252a	33 c0		 xor	 eax, eax
  0252c	85 c0		 test	 eax, eax
  0252e	75 aa		 jne	 SHORT $LN87@s390_start

; 913  :             GUESTREGS->program_interrupt( GUESTREGS, lpsw_xcode );

  02530	48 8b 84 24 38
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  02538	48 8b 80 70 08
	00 00		 mov	 rax, QWORD PTR [rax+2160]
  0253f	8b 54 24 74	 mov	 edx, DWORD PTR lpsw_xcode$[rsp]
  02543	48 8b 8c 24 38
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0254b	48 8b 89 70 08
	00 00		 mov	 rcx, QWORD PTR [rcx+2160]
  02552	ff 90 20 0d 00
	00		 call	 QWORD PTR [rax+3360]
$LN162@s390_start:
$LN90@s390_start:

; 914  :         }
; 915  : 
; 916  :         /* Run SIE in guest's architecture mode */
; 917  :         PTT_SIE( "SIE > run_sie", GUESTREGS->arch_mode, 0, 0 );

  02558	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_pttclass
  0255f	48 8b 00	 mov	 rax, QWORD PTR [rax]
  02562	48 25 80 00 00
	00		 and	 rax, 128		; 00000080H
  02568	48 85 c0	 test	 rax, rax
  0256b	74 49		 je	 SHORT $LN164@s390_start
  0256d	48 8b 84 24 38
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  02575	48 8b 80 70 08
	00 00		 mov	 rax, QWORD PTR [rax+2160]
  0257c	48 63 40 64	 movsxd	 rax, DWORD PTR [rax+100]
  02580	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR [rsp+48], 0
  02589	48 c7 44 24 28
	00 00 00 00	 mov	 QWORD PTR [rsp+40], 0
  02592	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG180640
  02599	48 89 4c 24 20	 mov	 QWORD PTR [rsp+32], rcx
  0259e	45 33 c9	 xor	 r9d, r9d
  025a1	4c 8b c0	 mov	 r8, rax
  025a4	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG180641
  025ab	b9 80 00 00 00	 mov	 ecx, 128		; 00000080H
  025b0	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ptt_pthread_trace
$LN164@s390_start:
  025b6	33 c0		 xor	 eax, eax
  025b8	85 c0		 test	 eax, eax
  025ba	75 9c		 jne	 SHORT $LN90@s390_start

; 918  :         icode = run_sie[ GUESTREGS->arch_mode ]( regs );

  025bc	48 8b 84 24 38
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  025c4	48 8b 80 70 08
	00 00		 mov	 rax, QWORD PTR [rax+2160]
  025cb	48 63 40 64	 movsxd	 rax, DWORD PTR [rax+100]
  025cf	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:run_sie
  025d6	48 89 8c 24 08
	01 00 00	 mov	 QWORD PTR tv1458[rsp], rcx
  025de	48 8b 8c 24 38
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  025e6	48 8b 94 24 08
	01 00 00	 mov	 rdx, QWORD PTR tv1458[rsp]
  025ee	ff 14 c2	 call	 QWORD PTR [rdx+rax*8]
  025f1	89 44 24 60	 mov	 DWORD PTR icode$[rsp], eax
$LN93@s390_start:

; 919  :         PTT_SIE( "SIE < run_sie", icode, 0, 0 );

  025f5	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_pttclass
  025fc	48 8b 00	 mov	 rax, QWORD PTR [rax]
  025ff	48 25 80 00 00
	00		 and	 rax, 128		; 00000080H
  02605	48 85 c0	 test	 rax, rax
  02608	74 3c		 je	 SHORT $LN165@s390_start
  0260a	8b 44 24 60	 mov	 eax, DWORD PTR icode$[rsp]
  0260e	48 98		 cdqe
  02610	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR [rsp+48], 0
  02619	48 c7 44 24 28
	00 00 00 00	 mov	 QWORD PTR [rsp+40], 0
  02622	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG180643
  02629	48 89 4c 24 20	 mov	 QWORD PTR [rsp+32], rcx
  0262e	45 33 c9	 xor	 r9d, r9d
  02631	4c 8b c0	 mov	 r8, rax
  02634	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG180644
  0263b	b9 80 00 00 00	 mov	 ecx, 128		; 00000080H
  02640	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ptt_pthread_trace
$LN165@s390_start:
  02646	33 c0		 xor	 eax, eax
  02648	85 c0		 test	 eax, eax
  0264a	75 a9		 jne	 SHORT $LN93@s390_start
$LN140@s390_start:
$LN96@s390_start:

; 920  : 
; 921  :     } /* if (setjmp(GUESTREGS->progjmp)) */
; 922  : 
; 923  :     /* Exit from SIE mode */
; 924  :     PTT_SIE( "SIE > sie_exit", icode, 0, 0 );

  0264c	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_pttclass
  02653	48 8b 00	 mov	 rax, QWORD PTR [rax]
  02656	48 25 80 00 00
	00		 and	 rax, 128		; 00000080H
  0265c	48 85 c0	 test	 rax, rax
  0265f	74 3c		 je	 SHORT $LN166@s390_start
  02661	8b 44 24 60	 mov	 eax, DWORD PTR icode$[rsp]
  02665	48 98		 cdqe
  02667	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR [rsp+48], 0
  02670	48 c7 44 24 28
	00 00 00 00	 mov	 QWORD PTR [rsp+40], 0
  02679	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG180646
  02680	48 89 4c 24 20	 mov	 QWORD PTR [rsp+32], rcx
  02685	45 33 c9	 xor	 r9d, r9d
  02688	4c 8b c0	 mov	 r8, rax
  0268b	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG180647
  02692	b9 80 00 00 00	 mov	 ecx, 128		; 00000080H
  02697	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ptt_pthread_trace
$LN166@s390_start:
  0269d	33 c0		 xor	 eax, eax
  0269f	85 c0		 test	 eax, eax
  026a1	75 a9		 jne	 SHORT $LN96@s390_start

; 925  :     ARCH_DEP( sie_exit )( regs, icode );

  026a3	8b 54 24 60	 mov	 edx, DWORD PTR icode$[rsp]
  026a7	48 8b 8c 24 38
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  026af	e8 00 00 00 00	 call	 s390_sie_exit
$LN99@s390_start:

; 926  :     PTT_SIE( "SIE < sie_exit", 0, 0, 0 );

  026b4	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_pttclass
  026bb	48 8b 00	 mov	 rax, QWORD PTR [rax]
  026be	48 25 80 00 00
	00		 and	 rax, 128		; 00000080H
  026c4	48 85 c0	 test	 rax, rax
  026c7	74 36		 je	 SHORT $LN167@s390_start
  026c9	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR [rsp+48], 0
  026d2	48 c7 44 24 28
	00 00 00 00	 mov	 QWORD PTR [rsp+40], 0
  026db	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG180649
  026e2	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  026e7	45 33 c9	 xor	 r9d, r9d
  026ea	45 33 c0	 xor	 r8d, r8d
  026ed	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG180650
  026f4	b9 80 00 00 00	 mov	 ecx, 128		; 00000080H
  026f9	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ptt_pthread_trace
$LN167@s390_start:
  026ff	33 c0		 xor	 eax, eax
  02701	85 c0		 test	 eax, eax
  02703	75 af		 jne	 SHORT $LN99@s390_start

; 927  : 
; 928  :     /* Perform serialization and checkpoint synchronization */
; 929  :     PERFORM_SERIALIZATION( regs );

  02705	0f ae f0	 mfence
$LN102@s390_start:

; 930  :     PERFORM_CHKPT_SYNC( regs );

  02708	33 c0		 xor	 eax, eax
  0270a	85 c0		 test	 eax, eax
  0270c	75 fa		 jne	 SHORT $LN102@s390_start
$LN105@s390_start:

; 931  : 
; 932  :     /* Return back to host instruction processing */
; 933  :     PTT_SIE( "SIE progjmp", 0, 0, 0 );

  0270e	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_pttclass
  02715	48 8b 00	 mov	 rax, QWORD PTR [rax]
  02718	48 25 80 00 00
	00		 and	 rax, 128		; 00000080H
  0271e	48 85 c0	 test	 rax, rax
  02721	74 36		 je	 SHORT $LN168@s390_start
  02723	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR [rsp+48], 0
  0272c	48 c7 44 24 28
	00 00 00 00	 mov	 QWORD PTR [rsp+40], 0
  02735	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG180652
  0273c	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  02741	45 33 c9	 xor	 r9d, r9d
  02744	45 33 c0	 xor	 r8d, r8d
  02747	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG180653
  0274e	b9 80 00 00 00	 mov	 ecx, 128		; 00000080H
  02753	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ptt_pthread_trace
$LN168@s390_start:
  02759	33 c0		 xor	 eax, eax
  0275b	85 c0		 test	 eax, eax
  0275d	75 af		 jne	 SHORT $LN105@s390_start

; 934  :     longjmp( regs->progjmp, SIE_NO_INTERCEPT );

  0275f	48 8b 84 24 38
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  02767	48 05 80 09 00
	00		 add	 rax, 2432		; 00000980H
  0276d	ba ff ff ff ff	 mov	 edx, -1
  02772	48 8b c8	 mov	 rcx, rax
  02775	e8 00 00 00 00	 call	 longjmp
$LN1@s390_start:
$LN169@s390_start:

; 935  : 
; 936  : } /* end of start_interpretive_execution instruction */

  0277a	48 81 c4 18 01
	00 00		 add	 rsp, 280		; 00000118H
  02781	5f		 pop	 rdi
  02782	5e		 pop	 rsi
  02783	c3		 ret	 0
s390_start_interpretive_execution ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\sie.c
_TEXT	SEGMENT
newgr1$ = 64
tv166 = 68
tv192 = 72
dev$ = 80
regs$ = 112
r1$ = 120
r3$ = 128
s390_diagnose_002 PROC

; 1941 : {

$LN18:
  00000	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  00005	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00009	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000e	48 83 ec 68	 sub	 rsp, 104		; 00000068H

; 1942 : DEVBLK *dev;
; 1943 : U32    newgr1;
; 1944 : 
; 1945 :     /* Program check if the ssid including lcss is invalid */
; 1946 :     SSID_CHECK(regs);

  00012	b8 08 00 00 00	 mov	 eax, 8
  00017	48 6b c0 01	 imul	 rax, rax, 1
  0001b	48 8b 4c 24 70	 mov	 rcx, QWORD PTR regs$[rsp]
  00020	0f b7 84 01 82
	02 00 00	 movzx	 eax, WORD PTR [rcx+rax+642]
  00028	83 e0 01	 and	 eax, 1
  0002b	85 c0		 test	 eax, eax
  0002d	74 1b		 je	 SHORT $LN6@s390_diagn
  0002f	b8 08 00 00 00	 mov	 eax, 8
  00034	48 6b c0 01	 imul	 rax, rax, 1
  00038	48 8b 4c 24 70	 mov	 rcx, QWORD PTR regs$[rsp]
  0003d	0f b7 84 01 82
	02 00 00	 movzx	 eax, WORD PTR [rcx+rax+642]
  00045	83 f8 03	 cmp	 eax, 3
  00048	7e 15		 jle	 SHORT $LN5@s390_diagn
$LN6@s390_diagn:
  0004a	ba 15 00 00 00	 mov	 edx, 21
  0004f	48 8b 4c 24 70	 mov	 rcx, QWORD PTR regs$[rsp]
  00054	48 8b 44 24 70	 mov	 rax, QWORD PTR regs$[rsp]
  00059	ff 90 20 0d 00
	00		 call	 QWORD PTR [rax+3360]
$LN5@s390_diagn:

; 1947 : 
; 1948 :     /* Locate the device block for this subchannel */
; 1949 :     dev = find_device_by_subchan (regs->GR_L(1));

  0005f	b8 08 00 00 00	 mov	 eax, 8
  00064	48 6b c0 01	 imul	 rax, rax, 1
  00068	48 8b 4c 24 70	 mov	 rcx, QWORD PTR regs$[rsp]
  0006d	8b 8c 01 80 02
	00 00		 mov	 ecx, DWORD PTR [rcx+rax+640]
  00074	e8 00 00 00 00	 call	 find_device_by_subchan
  00079	48 89 44 24 50	 mov	 QWORD PTR dev$[rsp], rax

; 1950 : 
; 1951 :     /* Condition code 3 if subchannel does not exist,
; 1952 :        is not valid, or is not enabled */
; 1953 :     if (dev == NULL
; 1954 :         || (dev->pmcw.flag5 & PMCW5_V) == 0
; 1955 :         || (dev->pmcw.flag5 & PMCW5_E) == 0)

  0007e	48 83 7c 24 50
	00		 cmp	 QWORD PTR dev$[rsp], 0
  00084	74 2c		 je	 SHORT $LN8@s390_diagn
  00086	48 8b 44 24 50	 mov	 rax, QWORD PTR dev$[rsp]
  0008b	0f b6 80 f1 02
	00 00		 movzx	 eax, BYTE PTR [rax+753]
  00092	83 e0 01	 and	 eax, 1
  00095	85 c0		 test	 eax, eax
  00097	74 19		 je	 SHORT $LN8@s390_diagn
  00099	48 8b 44 24 50	 mov	 rax, QWORD PTR dev$[rsp]
  0009e	0f b6 80 f1 02
	00 00		 movzx	 eax, BYTE PTR [rax+753]
  000a5	25 80 00 00 00	 and	 eax, 128		; 00000080H
  000aa	85 c0		 test	 eax, eax
  000ac	0f 85 98 00 00
	00		 jne	 $LN7@s390_diagn
$LN8@s390_diagn:
$LN4@s390_diagn:

; 1956 :     {
; 1957 :         PTT_ERR("*DIAG002", regs->GR_L(r1),regs->GR_L(r3),regs->GR_L(1));

  000b2	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_pttclass
  000b9	48 8b 00	 mov	 rax, QWORD PTR [rax]
  000bc	48 83 e0 10	 and	 rax, 16
  000c0	48 85 c0	 test	 rax, rax
  000c3	74 6d		 je	 SHORT $LN9@s390_diagn
  000c5	b8 08 00 00 00	 mov	 eax, 8
  000ca	48 6b c0 01	 imul	 rax, rax, 1
  000ce	48 8b 4c 24 70	 mov	 rcx, QWORD PTR regs$[rsp]
  000d3	8b 84 01 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax+640]
  000da	48 63 8c 24 80
	00 00 00	 movsxd	 rcx, DWORD PTR r3$[rsp]
  000e2	48 8b 54 24 70	 mov	 rdx, QWORD PTR regs$[rsp]
  000e7	8b 8c ca 80 02
	00 00		 mov	 ecx, DWORD PTR [rdx+rcx*8+640]
  000ee	48 63 54 24 78	 movsxd	 rdx, DWORD PTR r1$[rsp]
  000f3	4c 8b 44 24 70	 mov	 r8, QWORD PTR regs$[rsp]
  000f8	41 8b 94 d0 80
	02 00 00	 mov	 edx, DWORD PTR [r8+rdx*8+640]
  00100	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR [rsp+48], 0
  00109	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  0010e	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG181443
  00115	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  0011a	44 8b c9	 mov	 r9d, ecx
  0011d	44 8b c2	 mov	 r8d, edx
  00120	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG181444
  00127	b9 10 00 00 00	 mov	 ecx, 16
  0012c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ptt_pthread_trace
$LN9@s390_diagn:
  00132	33 c0		 xor	 eax, eax
  00134	85 c0		 test	 eax, eax
  00136	0f 85 76 ff ff
	ff		 jne	 $LN4@s390_diagn

; 1958 :         regs->psw.cc = 3;

  0013c	48 8b 44 24 70	 mov	 rax, QWORD PTR regs$[rsp]
  00141	c6 40 7c 03	 mov	 BYTE PTR [rax+124], 3

; 1959 :         return;

  00145	e9 70 01 00 00	 jmp	 $LN1@s390_diagn
$LN7@s390_diagn:

; 1960 :     }
; 1961 : 
; 1962 :     /* Obtain the device lock */
; 1963 :     obtain_lock (&dev->lock);

  0014a	48 8b 44 24 50	 mov	 rax, QWORD PTR dev$[rsp]
  0014f	48 83 c0 38	 add	 rax, 56			; 00000038H
  00153	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG181445
  0015a	48 8b c8	 mov	 rcx, rax
  0015d	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_obtain_lock

; 1964 : 
; 1965 :     /* Set newgr1 to the current value of pending and interlock control */
; 1966 :     newgr1 = ((dev->scsw.flag3 & SCSW3_SC_PEND)

  00163	48 8b 44 24 50	 mov	 rax, QWORD PTR dev$[rsp]
  00168	0f b6 80 0b 03
	00 00		 movzx	 eax, BYTE PTR [rax+779]
  0016f	83 e0 01	 and	 eax, 1
  00172	85 c0		 test	 eax, eax
  00174	75 1d		 jne	 SHORT $LN14@s390_diagn
  00176	48 8b 44 24 50	 mov	 rax, QWORD PTR dev$[rsp]
  0017b	0f b6 80 17 03
	00 00		 movzx	 eax, BYTE PTR [rax+791]
  00182	83 e0 01	 and	 eax, 1
  00185	85 c0		 test	 eax, eax
  00187	75 0a		 jne	 SHORT $LN14@s390_diagn
  00189	c7 44 24 44 00
	00 00 00	 mov	 DWORD PTR tv166[rsp], 0
  00191	eb 08		 jmp	 SHORT $LN15@s390_diagn
$LN14@s390_diagn:
  00193	c7 44 24 44 02
	00 00 00	 mov	 DWORD PTR tv166[rsp], 2
$LN15@s390_diagn:
  0019b	8b 44 24 44	 mov	 eax, DWORD PTR tv166[rsp]
  0019f	89 44 24 40	 mov	 DWORD PTR newgr1$[rsp], eax

; 1967 :               || (dev->pciscsw.flag3 & SCSW3_SC_PEND)) ? 0x02 : 0;
; 1968 :     if(dev->pmcw.flag27 & PMCW27_I)

  001a3	48 8b 44 24 50	 mov	 rax, QWORD PTR dev$[rsp]
  001a8	0f b6 80 07 03
	00 00		 movzx	 eax, BYTE PTR [rax+775]
  001af	25 80 00 00 00	 and	 eax, 128		; 00000080H
  001b4	85 c0		 test	 eax, eax
  001b6	74 0b		 je	 SHORT $LN10@s390_diagn

; 1969 :         newgr1 |= 0x01;

  001b8	8b 44 24 40	 mov	 eax, DWORD PTR newgr1$[rsp]
  001bc	83 c8 01	 or	 eax, 1
  001bf	89 44 24 40	 mov	 DWORD PTR newgr1$[rsp], eax
$LN10@s390_diagn:

; 1970 : 
; 1971 :     /* Do a compare-and-swap operation on the interrupt interlock
; 1972 :        control bit where both interlock and pending bits are
; 1973 :        compared, but only the interlock bit is swapped */
; 1974 :     if((regs->GR_L(r1) & 0x03) == newgr1)

  001c3	48 63 44 24 78	 movsxd	 rax, DWORD PTR r1$[rsp]
  001c8	48 8b 4c 24 70	 mov	 rcx, QWORD PTR regs$[rsp]
  001cd	8b 84 c1 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax*8+640]
  001d4	83 e0 03	 and	 eax, 3
  001d7	3b 44 24 40	 cmp	 eax, DWORD PTR newgr1$[rsp]
  001db	75 6e		 jne	 SHORT $LN11@s390_diagn

; 1975 :     {
; 1976 :         dev->pmcw.flag27 &= ~PMCW27_I;

  001dd	48 8b 44 24 50	 mov	 rax, QWORD PTR dev$[rsp]
  001e2	0f b6 80 07 03
	00 00		 movzx	 eax, BYTE PTR [rax+775]
  001e9	0f ba f0 07	 btr	 eax, 7
  001ed	48 8b 4c 24 50	 mov	 rcx, QWORD PTR dev$[rsp]
  001f2	88 81 07 03 00
	00		 mov	 BYTE PTR [rcx+775], al

; 1977 :         dev->pmcw.flag27 |= (regs->GR_L(r3) & 0x01) ? PMCW27_I : 0;

  001f8	48 63 84 24 80
	00 00 00	 movsxd	 rax, DWORD PTR r3$[rsp]
  00200	48 8b 4c 24 70	 mov	 rcx, QWORD PTR regs$[rsp]
  00205	8b 84 c1 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax*8+640]
  0020c	83 e0 01	 and	 eax, 1
  0020f	85 c0		 test	 eax, eax
  00211	74 0a		 je	 SHORT $LN16@s390_diagn
  00213	c7 44 24 48 80
	00 00 00	 mov	 DWORD PTR tv192[rsp], 128 ; 00000080H
  0021b	eb 08		 jmp	 SHORT $LN17@s390_diagn
$LN16@s390_diagn:
  0021d	c7 44 24 48 00
	00 00 00	 mov	 DWORD PTR tv192[rsp], 0
$LN17@s390_diagn:
  00225	48 8b 44 24 50	 mov	 rax, QWORD PTR dev$[rsp]
  0022a	0f b6 80 07 03
	00 00		 movzx	 eax, BYTE PTR [rax+775]
  00231	0b 44 24 48	 or	 eax, DWORD PTR tv192[rsp]
  00235	48 8b 4c 24 50	 mov	 rcx, QWORD PTR dev$[rsp]
  0023a	88 81 07 03 00
	00		 mov	 BYTE PTR [rcx+775], al

; 1978 :         regs->psw.cc = 0;

  00240	48 8b 44 24 70	 mov	 rax, QWORD PTR regs$[rsp]
  00245	c6 40 7c 00	 mov	 BYTE PTR [rax+124], 0

; 1979 :     }

  00249	eb 56		 jmp	 SHORT $LN12@s390_diagn
$LN11@s390_diagn:

; 1980 :     else
; 1981 :     {
; 1982 :         regs->GR_L(r1) &= ~0x03;

  0024b	48 63 44 24 78	 movsxd	 rax, DWORD PTR r1$[rsp]
  00250	48 8b 4c 24 70	 mov	 rcx, QWORD PTR regs$[rsp]
  00255	8b 84 c1 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax*8+640]
  0025c	83 e0 fc	 and	 eax, -4			; fffffffcH
  0025f	48 63 4c 24 78	 movsxd	 rcx, DWORD PTR r1$[rsp]
  00264	48 8b 54 24 70	 mov	 rdx, QWORD PTR regs$[rsp]
  00269	89 84 ca 80 02
	00 00		 mov	 DWORD PTR [rdx+rcx*8+640], eax

; 1983 :         regs->GR_L(r1) |= newgr1;

  00270	48 63 44 24 78	 movsxd	 rax, DWORD PTR r1$[rsp]
  00275	48 8b 4c 24 70	 mov	 rcx, QWORD PTR regs$[rsp]
  0027a	8b 54 24 40	 mov	 edx, DWORD PTR newgr1$[rsp]
  0027e	8b 84 c1 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax*8+640]
  00285	0b c2		 or	 eax, edx
  00287	48 63 4c 24 78	 movsxd	 rcx, DWORD PTR r1$[rsp]
  0028c	48 8b 54 24 70	 mov	 rdx, QWORD PTR regs$[rsp]
  00291	89 84 ca 80 02
	00 00		 mov	 DWORD PTR [rdx+rcx*8+640], eax

; 1984 :         regs->psw.cc = 1;

  00298	48 8b 44 24 70	 mov	 rax, QWORD PTR regs$[rsp]
  0029d	c6 40 7c 01	 mov	 BYTE PTR [rax+124], 1
$LN12@s390_diagn:

; 1985 :     }
; 1986 : 
; 1987 :     /* Release the device lock */
; 1988 :     release_lock (&dev->lock);

  002a1	48 8b 44 24 50	 mov	 rax, QWORD PTR dev$[rsp]
  002a6	48 83 c0 38	 add	 rax, 56			; 00000038H
  002aa	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG181449
  002b1	48 8b c8	 mov	 rcx, rax
  002b4	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_release_lock
$LN1@s390_diagn:

; 1989 : }

  002ba	48 83 c4 68	 add	 rsp, 104		; 00000068H
  002be	c3		 ret	 0
s390_diagnose_002 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\sie.c
_TEXT	SEGMENT
i$1 = 64
is_exrl$ = 68
oldmode$2 = 69
ip$3 = 72
n$ = 80
nt2$4 = 84
nt1$5 = 88
tv244 = 92
tv579 = 96
tv164 = 100
tv165 = 104
tv184 = 108
tv185 = 112
tv243 = 116
tv264 = 120
tv271 = 124
tv278 = 128
tv280 = 132
tv553 = 136
tv573 = 140
tv558 = 144
tv695 = 148
tv838 = 152
tv846 = 156
tv855 = 160
tv857 = 164
tv900 = 168
tv901 = 172
tv933 = 176
tv934 = 180
tv144 = 184
ilc$6 = 188
inst_cr$7 = 192
psa$8 = 200
realregs$9 = 208
regs$ = 256
icode$ = 264
s390_sie_exit PROC

; 1382 : {

$LN179:
  00000	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00004	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00009	56		 push	 rsi
  0000a	57		 push	 rdi
  0000b	48 81 ec e8 00
	00 00		 sub	 rsp, 232		; 000000e8H

; 1383 :     int n;
; 1384 : #if defined( FEATURE_073_TRANSACT_EXEC_FACILITY )
; 1385 :     U64  itdba = 0;
; 1386 :     TDB* itdb = NULL;
; 1387 :     bool txf_contran = false;
; 1388 :     BYTE txf_tnd = 0;
; 1389 : #endif
; 1390 :     bool is_exrl = false;

  00012	c6 44 24 44 00	 mov	 BYTE PTR is_exrl$[rsp], 0
$LN4@s390_sie_e:

; 1391 : 
; 1392 :     //-----------------------------------------------------------
; 1393 :     //              IMPORTANT SIE PROGRAMMING NOTE!
; 1394 :     //-----------------------------------------------------------
; 1395 :     // NOTE: Our execution architectural mode is that of the SIE
; 1396 :     // HOST, not the GUEST! If you need to call a function on
; 1397 :     // behalf of the GUEST (passing it 'GUESTREGS'), you must be
; 1398 :     // careful to ensure the correct version of that function is
; 1399 :     // called! You cannot simply call the "ARCH_DEP" version of
; 1400 :     // a function as they are for the architectue of the HOST,
; 1401 :     // not the GUEST! (e.g. you can't call a "z900_xxx" function
; 1402 :     // and expect it to work correctly if the GUEST is actually
; 1403 :     // supposed to be run in s390 mode!) YOU HAVE BEEN WARNED!
; 1404 :     //-----------------------------------------------------------
; 1405 : 
; 1406 :     PTT_SIE( "sie_xit i,h,g", icode, regs->host, regs->guest );

  00017	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_pttclass
  0001e	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00021	48 25 80 00 00
	00		 and	 rax, 128		; 00000080H
  00027	48 85 c0	 test	 rax, rax
  0002a	74 66		 je	 SHORT $LN63@s390_sie_e
  0002c	48 8b 84 24 00
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00034	8b 80 28 07 00
	00		 mov	 eax, DWORD PTR [rax+1832]
  0003a	c1 e8 08	 shr	 eax, 8
  0003d	83 e0 01	 and	 eax, 1
  00040	8b c0		 mov	 eax, eax
  00042	48 8b 8c 24 00
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0004a	8b 89 28 07 00
	00		 mov	 ecx, DWORD PTR [rcx+1832]
  00050	c1 e9 07	 shr	 ecx, 7
  00053	83 e1 01	 and	 ecx, 1
  00056	8b c9		 mov	 ecx, ecx
  00058	48 63 94 24 08
	01 00 00	 movsxd	 rdx, DWORD PTR icode$[rsp]
  00060	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR [rsp+48], 0
  00069	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  0006e	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG181181
  00075	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  0007a	44 8b c9	 mov	 r9d, ecx
  0007d	4c 8b c2	 mov	 r8, rdx
  00080	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG181182
  00087	b9 80 00 00 00	 mov	 ecx, 128		; 00000080H
  0008c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ptt_pthread_trace
$LN63@s390_sie_e:
  00092	33 c0		 xor	 eax, eax
  00094	85 c0		 test	 eax, eax
  00096	0f 85 7b ff ff
	ff		 jne	 $LN4@s390_sie_e

; 1407 : 
; 1408 :     /* PTT trace the SIE Exit... */
; 1409 :     if (pttclass & PTT_CL_SIE)

  0009c	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_pttclass
  000a3	48 8b 00	 mov	 rax, QWORD PTR [rax]
  000a6	48 25 80 00 00
	00		 and	 rax, 128		; 00000080H
  000ac	48 85 c0	 test	 rax, rax
  000af	0f 84 bb 02 00
	00		 je	 $LN64@s390_sie_e

; 1410 :     {
; 1411 :         // (include some instruction information in the trace entry)
; 1412 : 
; 1413 :         U32    nt1  = 0;        // First 2 or 4 bytes of instruction.

  000b5	c7 44 24 58 00
	00 00 00	 mov	 DWORD PTR nt1$5[rsp], 0

; 1414 :                                 // If ilc > 4 then last 2 bytes are
; 1415 :                                 // in the first 2 bytes of nt2.
; 1416 : 
; 1417 :         U32    nt2  = 0;        // First 2 bytes are last 2 bytes of

  000bd	c7 44 24 54 00
	00 00 00	 mov	 DWORD PTR nt2$4[rsp], 0

; 1418 :                                 // instruction when ilc = 6. Else 0.
; 1419 :                                 // Last 2 bytes is opcode of the "EX"
; 1420 :                                 // or "EXRL" instruction if instruction
; 1421 :                                 // was being "executed". Else zeros.
; 1422 : 
; 1423 :         BYTE*  ip   = NULL;     // Work: points to the instruction or,

  000c5	48 c7 44 24 48
	00 00 00 00	 mov	 QWORD PTR ip$3[rsp], 0

; 1424 :                                 // if execute, the target instruction.
; 1425 : 
; 1426 :         if (!GUESTREGS->instinvalid)

  000ce	48 8b 84 24 00
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  000d6	48 8b 80 70 08
	00 00		 mov	 rax, QWORD PTR [rax+2160]
  000dd	8b 80 28 07 00
	00		 mov	 eax, DWORD PTR [rax+1832]
  000e3	c1 e8 03	 shr	 eax, 3
  000e6	83 e0 01	 and	 eax, 1
  000e9	85 c0		 test	 eax, eax
  000eb	0f 85 22 02 00
	00		 jne	 $LN65@s390_sie_e

; 1427 :         {
; 1428 : #if defined( FEATURE_035_EXECUTE_EXTN_FACILITY )
; 1429 :             if (FACILITY_ENABLED( 035_EXECUTE_EXTN, GUESTREGS ))
; 1430 :             {
; 1431 :                 /* EXRL = Execute Relative Long instruction? */
; 1432 :                 is_exrl =
; 1433 :                 (1
; 1434 :                     &&   GUESTREGS->ip[0] == 0xc6
; 1435 :                     && !(GUESTREGS->ip[1] &  0x0f)
; 1436 :                 );
; 1437 :             }
; 1438 : #endif
; 1439 :             /* EX or EXRL instruction? */
; 1440 :             if (GUESTREGS->ip[0] == 0x44 || is_exrl)

  000f1	48 8b 84 24 00
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  000f9	48 8b 80 70 08
	00 00		 mov	 rax, QWORD PTR [rax+2160]
  00100	b9 01 00 00 00	 mov	 ecx, 1
  00105	48 6b c9 00	 imul	 rcx, rcx, 0
  00109	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  0010d	0f b6 04 08	 movzx	 eax, BYTE PTR [rax+rcx]
  00111	83 f8 44	 cmp	 eax, 68			; 00000044H
  00114	74 0d		 je	 SHORT $LN68@s390_sie_e
  00116	0f b6 44 24 44	 movzx	 eax, BYTE PTR is_exrl$[rsp]
  0011b	85 c0		 test	 eax, eax
  0011d	0f 84 85 00 00
	00		 je	 $LN66@s390_sie_e
$LN68@s390_sie_e:

; 1441 :             {
; 1442 :                 ip  =  GUESTREGS->exinst;

  00123	48 8b 84 24 00
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0012b	48 8b 80 70 08
	00 00		 mov	 rax, QWORD PTR [rax+2160]
  00132	48 05 40 08 00
	00		 add	 rax, 2112		; 00000840H
  00138	48 89 44 24 48	 mov	 QWORD PTR ip$3[rsp], rax

; 1443 :                 nt2 = (GUESTREGS->ip[0] == 0x44) ? 0x44

  0013d	48 8b 84 24 00
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00145	48 8b 80 70 08
	00 00		 mov	 rax, QWORD PTR [rax+2160]
  0014c	b9 01 00 00 00	 mov	 ecx, 1
  00151	48 6b c9 00	 imul	 rcx, rcx, 0
  00155	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  00159	0f b6 04 08	 movzx	 eax, BYTE PTR [rax+rcx]
  0015d	83 f8 44	 cmp	 eax, 68			; 00000044H
  00160	75 0d		 jne	 SHORT $LN127@s390_sie_e
  00162	c7 84 24 b8 00
	00 00 44 00 00
	00		 mov	 DWORD PTR tv144[rsp], 68 ; 00000044H
  0016d	eb 2c		 jmp	 SHORT $LN128@s390_sie_e
$LN127@s390_sie_e:
  0016f	48 8b 84 24 00
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00177	48 8b 80 70 08
	00 00		 mov	 rax, QWORD PTR [rax+2160]
  0017e	b9 01 00 00 00	 mov	 ecx, 1
  00183	48 6b c9 01	 imul	 rcx, rcx, 1
  00187	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  0018b	0f b6 04 08	 movzx	 eax, BYTE PTR [rax+rcx]
  0018f	0d 00 c6 00 00	 or	 eax, 50688		; 0000c600H
  00194	89 84 24 b8 00
	00 00		 mov	 DWORD PTR tv144[rsp], eax
$LN128@s390_sie_e:
  0019b	8b 84 24 b8 00
	00 00		 mov	 eax, DWORD PTR tv144[rsp]
  001a2	89 44 24 54	 mov	 DWORD PTR nt2$4[rsp], eax

; 1444 :                     : ((0xc6 << 8) | GUESTREGS->ip[1]);
; 1445 :             }

  001a6	eb 18		 jmp	 SHORT $LN67@s390_sie_e
$LN66@s390_sie_e:

; 1446 :             else // not execute
; 1447 :             {
; 1448 :                 ip  =  GUESTREGS->ip;

  001a8	48 8b 84 24 00
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  001b0	48 8b 80 70 08
	00 00		 mov	 rax, QWORD PTR [rax+2160]
  001b7	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  001bb	48 89 44 24 48	 mov	 QWORD PTR ip$3[rsp], rax
$LN67@s390_sie_e:

; 1449 :             }
; 1450 : 
; 1451 :             nt1 = (ip[0] << 24)

  001c0	b8 01 00 00 00	 mov	 eax, 1
  001c5	48 6b c0 00	 imul	 rax, rax, 0
  001c9	48 8b 4c 24 48	 mov	 rcx, QWORD PTR ip$3[rsp]
  001ce	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  001d2	c1 e0 18	 shl	 eax, 24
  001d5	b9 01 00 00 00	 mov	 ecx, 1
  001da	48 6b c9 01	 imul	 rcx, rcx, 1
  001de	48 8b 54 24 48	 mov	 rdx, QWORD PTR ip$3[rsp]
  001e3	0f b6 0c 0a	 movzx	 ecx, BYTE PTR [rdx+rcx]
  001e7	c1 e1 10	 shl	 ecx, 16
  001ea	0b c1		 or	 eax, ecx
  001ec	89 44 24 58	 mov	 DWORD PTR nt1$5[rsp], eax

; 1452 :                 | (ip[1] << 16);
; 1453 : 
; 1454 :             if (ILC( ip[0]) > 2)  nt1  |=  ((ip[2] <<  8) | (ip[3] <<  0));

  001f0	b8 01 00 00 00	 mov	 eax, 1
  001f5	48 6b c0 00	 imul	 rax, rax, 0
  001f9	48 8b 4c 24 48	 mov	 rcx, QWORD PTR ip$3[rsp]
  001fe	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00202	83 f8 40	 cmp	 eax, 64			; 00000040H
  00205	7d 0a		 jge	 SHORT $LN131@s390_sie_e
  00207	c7 44 24 68 02
	00 00 00	 mov	 DWORD PTR tv165[rsp], 2
  0020f	eb 33		 jmp	 SHORT $LN132@s390_sie_e
$LN131@s390_sie_e:
  00211	b8 01 00 00 00	 mov	 eax, 1
  00216	48 6b c0 00	 imul	 rax, rax, 0
  0021a	48 8b 4c 24 48	 mov	 rcx, QWORD PTR ip$3[rsp]
  0021f	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00223	3d c0 00 00 00	 cmp	 eax, 192		; 000000c0H
  00228	7d 0a		 jge	 SHORT $LN129@s390_sie_e
  0022a	c7 44 24 64 04
	00 00 00	 mov	 DWORD PTR tv164[rsp], 4
  00232	eb 08		 jmp	 SHORT $LN130@s390_sie_e
$LN129@s390_sie_e:
  00234	c7 44 24 64 06
	00 00 00	 mov	 DWORD PTR tv164[rsp], 6
$LN130@s390_sie_e:
  0023c	8b 44 24 64	 mov	 eax, DWORD PTR tv164[rsp]
  00240	89 44 24 68	 mov	 DWORD PTR tv165[rsp], eax
$LN132@s390_sie_e:
  00244	83 7c 24 68 02	 cmp	 DWORD PTR tv165[rsp], 2
  00249	7e 35		 jle	 SHORT $LN69@s390_sie_e
  0024b	b8 01 00 00 00	 mov	 eax, 1
  00250	48 6b c0 02	 imul	 rax, rax, 2
  00254	48 8b 4c 24 48	 mov	 rcx, QWORD PTR ip$3[rsp]
  00259	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  0025d	c1 e0 08	 shl	 eax, 8
  00260	b9 01 00 00 00	 mov	 ecx, 1
  00265	48 6b c9 03	 imul	 rcx, rcx, 3
  00269	48 8b 54 24 48	 mov	 rdx, QWORD PTR ip$3[rsp]
  0026e	0f b6 0c 0a	 movzx	 ecx, BYTE PTR [rdx+rcx]
  00272	0b c1		 or	 eax, ecx
  00274	8b 4c 24 58	 mov	 ecx, DWORD PTR nt1$5[rsp]
  00278	0b c8		 or	 ecx, eax
  0027a	8b c1		 mov	 eax, ecx
  0027c	89 44 24 58	 mov	 DWORD PTR nt1$5[rsp], eax
$LN69@s390_sie_e:

; 1455 :             if (ILC( ip[0]) > 4)  nt2  |=  ((ip[4] << 24) | (ip[5] << 16));

  00280	b8 01 00 00 00	 mov	 eax, 1
  00285	48 6b c0 00	 imul	 rax, rax, 0
  00289	48 8b 4c 24 48	 mov	 rcx, QWORD PTR ip$3[rsp]
  0028e	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00292	83 f8 40	 cmp	 eax, 64			; 00000040H
  00295	7d 0a		 jge	 SHORT $LN135@s390_sie_e
  00297	c7 44 24 70 02
	00 00 00	 mov	 DWORD PTR tv185[rsp], 2
  0029f	eb 33		 jmp	 SHORT $LN136@s390_sie_e
$LN135@s390_sie_e:
  002a1	b8 01 00 00 00	 mov	 eax, 1
  002a6	48 6b c0 00	 imul	 rax, rax, 0
  002aa	48 8b 4c 24 48	 mov	 rcx, QWORD PTR ip$3[rsp]
  002af	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  002b3	3d c0 00 00 00	 cmp	 eax, 192		; 000000c0H
  002b8	7d 0a		 jge	 SHORT $LN133@s390_sie_e
  002ba	c7 44 24 6c 04
	00 00 00	 mov	 DWORD PTR tv184[rsp], 4
  002c2	eb 08		 jmp	 SHORT $LN134@s390_sie_e
$LN133@s390_sie_e:
  002c4	c7 44 24 6c 06
	00 00 00	 mov	 DWORD PTR tv184[rsp], 6
$LN134@s390_sie_e:
  002cc	8b 44 24 6c	 mov	 eax, DWORD PTR tv184[rsp]
  002d0	89 44 24 70	 mov	 DWORD PTR tv185[rsp], eax
$LN136@s390_sie_e:
  002d4	83 7c 24 70 04	 cmp	 DWORD PTR tv185[rsp], 4
  002d9	7e 38		 jle	 SHORT $LN70@s390_sie_e
  002db	b8 01 00 00 00	 mov	 eax, 1
  002e0	48 6b c0 04	 imul	 rax, rax, 4
  002e4	48 8b 4c 24 48	 mov	 rcx, QWORD PTR ip$3[rsp]
  002e9	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  002ed	c1 e0 18	 shl	 eax, 24
  002f0	b9 01 00 00 00	 mov	 ecx, 1
  002f5	48 6b c9 05	 imul	 rcx, rcx, 5
  002f9	48 8b 54 24 48	 mov	 rdx, QWORD PTR ip$3[rsp]
  002fe	0f b6 0c 0a	 movzx	 ecx, BYTE PTR [rdx+rcx]
  00302	c1 e1 10	 shl	 ecx, 16
  00305	0b c1		 or	 eax, ecx
  00307	8b 4c 24 54	 mov	 ecx, DWORD PTR nt2$4[rsp]
  0030b	0b c8		 or	 ecx, eax
  0030d	8b c1		 mov	 eax, ecx
  0030f	89 44 24 54	 mov	 DWORD PTR nt2$4[rsp], eax
$LN70@s390_sie_e:
$LN65@s390_sie_e:
$LN7@s390_sie_e:

; 1456 :         }
; 1457 : 
; 1458 :         PTT_SIE( "sie_xit inst", icode, nt1, nt2  );

  00313	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_pttclass
  0031a	48 8b 00	 mov	 rax, QWORD PTR [rax]
  0031d	48 25 80 00 00
	00		 and	 rax, 128		; 00000080H
  00323	48 85 c0	 test	 rax, rax
  00326	74 42		 je	 SHORT $LN71@s390_sie_e
  00328	8b 44 24 54	 mov	 eax, DWORD PTR nt2$4[rsp]
  0032c	8b 4c 24 58	 mov	 ecx, DWORD PTR nt1$5[rsp]
  00330	48 63 94 24 08
	01 00 00	 movsxd	 rdx, DWORD PTR icode$[rsp]
  00338	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR [rsp+48], 0
  00341	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  00346	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG181191
  0034d	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00352	44 8b c9	 mov	 r9d, ecx
  00355	4c 8b c2	 mov	 r8, rdx
  00358	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG181192
  0035f	b9 80 00 00 00	 mov	 ecx, 128		; 00000080H
  00364	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ptt_pthread_trace
$LN71@s390_sie_e:
  0036a	33 c0		 xor	 eax, eax
  0036c	85 c0		 test	 eax, eax
  0036e	75 a3		 jne	 SHORT $LN7@s390_sie_e
$LN64@s390_sie_e:

; 1459 : 
; 1460 :     } // end PTT trace of SIE exit
; 1461 : 
; 1462 : #if defined( SIE_DEBUG )
; 1463 :     LOGMSG( "SIE: interception code %d = %s\n", icode, sie_icode_2str( icode ));
; 1464 :     ARCH_DEP( display_guest_inst )( GUESTREGS, GUESTREGS->instinvalid ? NULL : GUESTREGS->ip );
; 1465 : #endif
; 1466 : 
; 1467 :     SIE_PERFMON( SIE_PERF_EXIT   );
; 1468 :     SIE_PERFMON( SIE_PERF_PGMINT );
; 1469 : 
; 1470 :     {
; 1471 :         /* Obtain INTLOCK (unless we already own it) */
; 1472 :         REGS* realregs = GUEST( sysblk.regs[ regs->cpuad ]);

  00370	48 8b 84 24 00
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00378	0f b7 80 3c 08
	00 00		 movzx	 eax, WORD PTR [rax+2108]
  0037f	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  00386	48 8b 84 c1 98
	0b 00 00	 mov	 rax, QWORD PTR [rcx+rax*8+2968]
  0038e	48 8b 80 70 08
	00 00		 mov	 rax, QWORD PTR [rax+2160]
  00395	48 89 84 24 d0
	00 00 00	 mov	 QWORD PTR realregs$9[rsp], rax

; 1473 :         if (!IS_INTLOCK_HELD( realregs ))

  0039d	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  003a4	0f b7 80 62 10
	00 00		 movzx	 eax, WORD PTR [rax+4194]
  003ab	48 8b 8c 24 d0
	00 00 00	 mov	 rcx, QWORD PTR realregs$9[rsp]
  003b3	0f b7 89 3c 08
	00 00		 movzx	 ecx, WORD PTR [rcx+2108]
  003ba	3b c1		 cmp	 eax, ecx
  003bc	74 14		 je	 SHORT $LN72@s390_sie_e

; 1474 :             OBTAIN_INTLOCK( regs );

  003be	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG181194
  003c5	48 8b 8c 24 00
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  003cd	e8 00 00 00 00	 call	 Obtain_Interrupt_Lock
$LN72@s390_sie_e:
$LN10@s390_sie_e:

; 1475 : 
; 1476 :         /* Indicate we have left SIE mode */
; 1477 :         PTT_SIE( "sie_xit a=0", 0, 0, 0  );

  003d2	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_pttclass
  003d9	48 8b 00	 mov	 rax, QWORD PTR [rax]
  003dc	48 25 80 00 00
	00		 and	 rax, 128		; 00000080H
  003e2	48 85 c0	 test	 rax, rax
  003e5	74 36		 je	 SHORT $LN73@s390_sie_e
  003e7	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR [rsp+48], 0
  003f0	48 c7 44 24 28
	00 00 00 00	 mov	 QWORD PTR [rsp+40], 0
  003f9	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG181196
  00400	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00405	45 33 c9	 xor	 r9d, r9d
  00408	45 33 c0	 xor	 r8d, r8d
  0040b	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG181197
  00412	b9 80 00 00 00	 mov	 ecx, 128		; 00000080H
  00417	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ptt_pthread_trace
$LN73@s390_sie_e:
  0041d	33 c0		 xor	 eax, eax
  0041f	85 c0		 test	 eax, eax
  00421	75 af		 jne	 SHORT $LN10@s390_sie_e

; 1478 :         regs->sie_active = 0;

  00423	48 8b 84 24 00
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0042b	8b 80 c8 08 00
	00		 mov	 eax, DWORD PTR [rax+2248]
  00431	83 e0 fe	 and	 eax, -2			; fffffffeH
  00434	48 8b 8c 24 00
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0043c	89 81 c8 08 00
	00		 mov	 DWORD PTR [rcx+2248], eax

; 1479 :         RELEASE_INTLOCK( regs );

  00442	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG181198
  00449	48 8b 8c 24 00
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00451	e8 00 00 00 00	 call	 Release_Interrupt_Lock

; 1480 :     }
; 1481 : 
; 1482 :     /* Zeroize interception status */
; 1483 :     STATEBK->f = 0;

  00456	48 8b 84 24 00
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0045e	48 8b 80 70 08
	00 00		 mov	 rax, QWORD PTR [rax+2160]
  00465	48 8b 80 88 08
	00 00		 mov	 rax, QWORD PTR [rax+2184]
  0046c	c6 40 51 00	 mov	 BYTE PTR [rax+81], 0

; 1484 : 
; 1485 :     /* Set the interception code in the SIE block */
; 1486 :     switch (icode < 0 ? icode : icode & 0xFF)

  00470	83 bc 24 08 01
	00 00 00	 cmp	 DWORD PTR icode$[rsp], 0
  00478	7d 0d		 jge	 SHORT $LN137@s390_sie_e
  0047a	8b 84 24 08 01
	00 00		 mov	 eax, DWORD PTR icode$[rsp]
  00481	89 44 24 74	 mov	 DWORD PTR tv243[rsp], eax
  00485	eb 10		 jmp	 SHORT $LN138@s390_sie_e
$LN137@s390_sie_e:
  00487	8b 84 24 08 01
	00 00		 mov	 eax, DWORD PTR icode$[rsp]
  0048e	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  00493	89 44 24 74	 mov	 DWORD PTR tv243[rsp], eax
$LN138@s390_sie_e:
  00497	8b 44 24 74	 mov	 eax, DWORD PTR tv243[rsp]
  0049b	89 44 24 5c	 mov	 DWORD PTR tv244[rsp], eax
  0049f	8b 44 24 5c	 mov	 eax, DWORD PTR tv244[rsp]
  004a3	83 c0 11	 add	 eax, 17
  004a6	89 44 24 5c	 mov	 DWORD PTR tv244[rsp], eax
  004aa	83 7c 24 5c 12	 cmp	 DWORD PTR tv244[rsp], 18
  004af	0f 87 60 03 00
	00		 ja	 $LN93@s390_sie_e
  004b5	48 63 44 24 5c	 movsxd	 rax, DWORD PTR tv244[rsp]
  004ba	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__ImageBase
  004c1	8b 84 81 00 00
	00 00		 mov	 eax, DWORD PTR $LN178@s390_sie_e[rcx+rax*4]
  004c8	48 03 c1	 add	 rax, rcx
  004cb	ff e0		 jmp	 rax
$LN74@s390_sie_e:
$LN15@s390_sie_e:

; 1487 :     {
; 1488 :        /* If host interrupt pending, then backup psw so that the SIE
; 1489 :           instruction gets re-executed again to re-enter SIE mode
; 1490 :           once the interrupt is processed by the host.
; 1491 :         */
; 1492 :         case SIE_HOST_INT_PEND:
; 1493 : 
; 1494 :             MAYBE_SET_PSW_IA_FROM_IP( regs );

  004cd	48 8b 84 24 00
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  004d5	48 83 b8 08 02
	00 00 00	 cmp	 QWORD PTR [rax+520], 0
  004dd	74 4e		 je	 SHORT $LN75@s390_sie_e
  004df	48 8b 84 24 00
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  004e7	8b 80 10 02 00
	00		 mov	 eax, DWORD PTR [rax+528]
  004ed	48 8b 8c 24 00
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  004f5	48 8b 94 24 00
	01 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  004fd	48 8b 92 00 02
	00 00		 mov	 rdx, QWORD PTR [rdx+512]
  00504	48 8b 49 68	 mov	 rcx, QWORD PTR [rcx+104]
  00508	48 2b ca	 sub	 rcx, rdx
  0050b	48 03 c1	 add	 rax, rcx
  0050e	48 8b 8c 24 00
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00516	8b 89 90 00 00
	00		 mov	 ecx, DWORD PTR [rcx+144]
  0051c	48 23 c1	 and	 rax, rcx
  0051f	48 8b 8c 24 00
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00527	89 81 88 00 00
	00		 mov	 DWORD PTR [rcx+136], eax
$LN75@s390_sie_e:
  0052d	33 c0		 xor	 eax, eax
  0052f	85 c0		 test	 eax, eax
  00531	75 9a		 jne	 SHORT $LN15@s390_sie_e
$LN18@s390_sie_e:

; 1495 :             SET_PSW_IA_AND_MAYBE_IP( regs, regs->psw.IA - REAL_ILC( regs ));

  00533	48 8b 84 24 00
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0053b	8b 80 28 07 00
	00		 mov	 eax, DWORD PTR [rax+1832]
  00541	83 e0 01	 and	 eax, 1
  00544	85 c0		 test	 eax, eax
  00546	75 0a		 jne	 SHORT $LN139@s390_sie_e
  00548	c7 44 24 78 01
	00 00 00	 mov	 DWORD PTR tv264[rsp], 1
  00550	eb 08		 jmp	 SHORT $LN140@s390_sie_e
$LN139@s390_sie_e:
  00552	c7 44 24 78 00
	00 00 00	 mov	 DWORD PTR tv264[rsp], 0
$LN140@s390_sie_e:
  0055a	83 7c 24 78 00	 cmp	 DWORD PTR tv264[rsp], 0
  0055f	74 0a		 je	 SHORT $LN143@s390_sie_e
  00561	c7 44 24 7c 01
	00 00 00	 mov	 DWORD PTR tv271[rsp], 1
  00569	eb 08		 jmp	 SHORT $LN144@s390_sie_e
$LN143@s390_sie_e:
  0056b	c7 44 24 7c 00
	00 00 00	 mov	 DWORD PTR tv271[rsp], 0
$LN144@s390_sie_e:
  00573	83 7c 24 7c 00	 cmp	 DWORD PTR tv271[rsp], 0
  00578	74 18		 je	 SHORT $LN147@s390_sie_e
  0057a	48 8b 84 24 00
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00582	0f b6 80 9a 00
	00 00		 movzx	 eax, BYTE PTR [rax+154]
  00589	89 84 24 84 00
	00 00		 mov	 DWORD PTR tv280[rsp], eax
  00590	eb 3d		 jmp	 SHORT $LN148@s390_sie_e
$LN147@s390_sie_e:
  00592	48 8b 84 24 00
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0059a	8b 80 28 07 00
	00		 mov	 eax, DWORD PTR [rax+1832]
  005a0	d1 e8		 shr	 eax, 1
  005a2	83 e0 01	 and	 eax, 1
  005a5	85 c0		 test	 eax, eax
  005a7	74 0d		 je	 SHORT $LN145@s390_sie_e
  005a9	c7 84 24 80 00
	00 00 06 00 00
	00		 mov	 DWORD PTR tv278[rsp], 6
  005b4	eb 0b		 jmp	 SHORT $LN146@s390_sie_e
$LN145@s390_sie_e:
  005b6	c7 84 24 80 00
	00 00 04 00 00
	00		 mov	 DWORD PTR tv278[rsp], 4
$LN146@s390_sie_e:
  005c1	8b 84 24 80 00
	00 00		 mov	 eax, DWORD PTR tv278[rsp]
  005c8	89 84 24 84 00
	00 00		 mov	 DWORD PTR tv280[rsp], eax
$LN148@s390_sie_e:
  005cf	48 8b 84 24 00
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  005d7	8b 8c 24 84 00
	00 00		 mov	 ecx, DWORD PTR tv280[rsp]
  005de	8b 80 88 00 00
	00		 mov	 eax, DWORD PTR [rax+136]
  005e4	2b c1		 sub	 eax, ecx
  005e6	48 8b 8c 24 00
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  005ee	23 81 90 00 00
	00		 and	 eax, DWORD PTR [rcx+144]
  005f4	48 8b 8c 24 00
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  005fc	89 81 88 00 00
	00		 mov	 DWORD PTR [rcx+136], eax
  00602	48 8b 84 24 00
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0060a	48 83 b8 08 02
	00 00 00	 cmp	 QWORD PTR [rax+520], 0
  00612	74 6e		 je	 SHORT $LN76@s390_sie_e
  00614	48 8b 84 24 00
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0061c	8b 80 88 00 00
	00		 mov	 eax, DWORD PTR [rax+136]
  00622	25 01 f0 ff 7f	 and	 eax, 2147479553		; 7ffff001H
  00627	48 8b 8c 24 00
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0062f	39 81 10 02 00
	00		 cmp	 DWORD PTR [rcx+528], eax
  00635	75 38		 jne	 SHORT $LN77@s390_sie_e
  00637	48 8b 84 24 00
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0063f	8b 80 88 00 00
	00		 mov	 eax, DWORD PTR [rax+136]
  00645	25 ff 0f 00 00	 and	 eax, 4095		; 00000fffH
  0064a	8b c0		 mov	 eax, eax
  0064c	48 8b 8c 24 00
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00654	48 8b 89 00 02
	00 00		 mov	 rcx, QWORD PTR [rcx+512]
  0065b	48 0b c8	 or	 rcx, rax
  0065e	48 8b c1	 mov	 rax, rcx
  00661	48 8b 8c 24 00
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00669	48 89 41 68	 mov	 QWORD PTR [rcx+104], rax
  0066d	eb 13		 jmp	 SHORT $LN78@s390_sie_e
$LN77@s390_sie_e:
  0066f	48 8b 84 24 00
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00677	48 c7 80 08 02
	00 00 00 00 00
	00		 mov	 QWORD PTR [rax+520], 0
$LN78@s390_sie_e:
$LN76@s390_sie_e:
  00682	33 c0		 xor	 eax, eax
  00684	85 c0		 test	 eax, eax
  00686	0f 85 a7 fe ff
	ff		 jne	 $LN18@s390_sie_e

; 1496 :             break;

  0068c	e9 9e 01 00 00	 jmp	 $LN11@s390_sie_e
$LN79@s390_sie_e:

; 1497 : 
; 1498 :         case SIE_HOST_PGM_INT:         /* do nothing */             break;

  00691	e9 99 01 00 00	 jmp	 $LN11@s390_sie_e
$LN80@s390_sie_e:

; 1499 :         case SIE_INTERCEPT_INST:       STATEBK->c = SIE_C_INST;     break;

  00696	48 8b 84 24 00
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0069e	48 8b 80 70 08
	00 00		 mov	 rax, QWORD PTR [rax+2160]
  006a5	48 8b 80 88 08
	00 00		 mov	 rax, QWORD PTR [rax+2184]
  006ac	c6 40 50 04	 mov	 BYTE PTR [rax+80], 4
  006b0	e9 7a 01 00 00	 jmp	 $LN11@s390_sie_e
$LN81@s390_sie_e:

; 1500 :         case SIE_INTERCEPT_PER:        STATEBK->f |= SIE_F_IF;

  006b5	48 8b 84 24 00
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  006bd	48 8b 80 70 08
	00 00		 mov	 rax, QWORD PTR [rax+2160]
  006c4	48 8b 80 88 08
	00 00		 mov	 rax, QWORD PTR [rax+2184]
  006cb	0f b6 40 51	 movzx	 eax, BYTE PTR [rax+81]
  006cf	83 c8 02	 or	 eax, 2
  006d2	48 8b 8c 24 00
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  006da	48 8b 89 70 08
	00 00		 mov	 rcx, QWORD PTR [rcx+2160]
  006e1	48 8b 89 88 08
	00 00		 mov	 rcx, QWORD PTR [rcx+2184]
  006e8	88 41 51	 mov	 BYTE PTR [rcx+81], al
$LN82@s390_sie_e:

; 1501 :                                        /* fall through */
; 1502 :         case SIE_INTERCEPT_INSTCOMP:   STATEBK->c = SIE_C_BOTH;     break;

  006eb	48 8b 84 24 00
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  006f3	48 8b 80 70 08
	00 00		 mov	 rax, QWORD PTR [rax+2160]
  006fa	48 8b 80 88 08
	00 00		 mov	 rax, QWORD PTR [rax+2184]
  00701	c6 40 50 0c	 mov	 BYTE PTR [rax+80], 12
  00705	e9 25 01 00 00	 jmp	 $LN11@s390_sie_e
$LN83@s390_sie_e:

; 1503 :         case SIE_INTERCEPT_WAIT:       STATEBK->c = SIE_C_WAIT;     break;

  0070a	48 8b 84 24 00
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00712	48 8b 80 70 08
	00 00		 mov	 rax, QWORD PTR [rax+2160]
  00719	48 8b 80 88 08
	00 00		 mov	 rax, QWORD PTR [rax+2184]
  00720	c6 40 50 1c	 mov	 BYTE PTR [rax+80], 28
  00724	e9 06 01 00 00	 jmp	 $LN11@s390_sie_e
$LN84@s390_sie_e:

; 1504 :         case SIE_INTERCEPT_STOPREQ:    STATEBK->c = SIE_C_STOPREQ;  break;

  00729	48 8b 84 24 00
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00731	48 8b 80 70 08
	00 00		 mov	 rax, QWORD PTR [rax+2160]
  00738	48 8b 80 88 08
	00 00		 mov	 rax, QWORD PTR [rax+2184]
  0073f	c6 40 50 28	 mov	 BYTE PTR [rax+80], 40	; 00000028H
  00743	e9 e7 00 00 00	 jmp	 $LN11@s390_sie_e
$LN85@s390_sie_e:

; 1505 :         case SIE_INTERCEPT_IOREQ:      STATEBK->c = SIE_C_IOREQ;    break;

  00748	48 8b 84 24 00
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00750	48 8b 80 70 08
	00 00		 mov	 rax, QWORD PTR [rax+2160]
  00757	48 8b 80 88 08
	00 00		 mov	 rax, QWORD PTR [rax+2184]
  0075e	c6 40 50 18	 mov	 BYTE PTR [rax+80], 24
  00762	e9 c8 00 00 00	 jmp	 $LN11@s390_sie_e
$LN86@s390_sie_e:

; 1506 :         case SIE_INTERCEPT_EXTREQ:     STATEBK->c = SIE_C_EXTREQ;   break;

  00767	48 8b 84 24 00
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0076f	48 8b 80 70 08
	00 00		 mov	 rax, QWORD PTR [rax+2160]
  00776	48 8b 80 88 08
	00 00		 mov	 rax, QWORD PTR [rax+2184]
  0077d	c6 40 50 10	 mov	 BYTE PTR [rax+80], 16
  00781	e9 a9 00 00 00	 jmp	 $LN11@s390_sie_e
$LN87@s390_sie_e:

; 1507 :         case SIE_INTERCEPT_EXT:        STATEBK->c = SIE_C_EXTINT;   break;

  00786	48 8b 84 24 00
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0078e	48 8b 80 70 08
	00 00		 mov	 rax, QWORD PTR [rax+2160]
  00795	48 8b 80 88 08
	00 00		 mov	 rax, QWORD PTR [rax+2184]
  0079c	c6 40 50 14	 mov	 BYTE PTR [rax+80], 20
  007a0	e9 8a 00 00 00	 jmp	 $LN11@s390_sie_e
$LN88@s390_sie_e:

; 1508 :         case SIE_INTERCEPT_VALIDITY:   STATEBK->c = SIE_C_VALIDITY; break;

  007a5	48 8b 84 24 00
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  007ad	48 8b 80 70 08
	00 00		 mov	 rax, QWORD PTR [rax+2160]
  007b4	48 8b 80 88 08
	00 00		 mov	 rax, QWORD PTR [rax+2184]
  007bb	c6 40 50 20	 mov	 BYTE PTR [rax+80], 32	; 00000020H
  007bf	eb 6e		 jmp	 SHORT $LN11@s390_sie_e
$LN89@s390_sie_e:
$LN90@s390_sie_e:

; 1509 :         case SIE_INTERCEPT_IOINT:      /* fall through */
; 1510 :         case SIE_INTERCEPT_IOINTP:     STATEBK->c = SIE_C_IOINT;    break;

  007c1	48 8b 84 24 00
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  007c9	48 8b 80 70 08
	00 00		 mov	 rax, QWORD PTR [rax+2160]
  007d0	48 8b 80 88 08
	00 00		 mov	 rax, QWORD PTR [rax+2184]
  007d7	c6 40 50 3c	 mov	 BYTE PTR [rax+80], 60	; 0000003cH
  007db	eb 52		 jmp	 SHORT $LN11@s390_sie_e
$LN91@s390_sie_e:

; 1511 :         case SIE_INTERCEPT_IOINST:     STATEBK->c = SIE_C_IOINST;   break;

  007dd	48 8b 84 24 00
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  007e5	48 8b 80 70 08
	00 00		 mov	 rax, QWORD PTR [rax+2160]
  007ec	48 8b 80 88 08
	00 00		 mov	 rax, QWORD PTR [rax+2184]
  007f3	c6 40 50 40	 mov	 BYTE PTR [rax+80], 64	; 00000040H
  007f7	eb 36		 jmp	 SHORT $LN11@s390_sie_e
$LN92@s390_sie_e:

; 1512 :         case PGM_OPERATION_EXCEPTION:  STATEBK->c = SIE_C_OPEREXC;  break;

  007f9	48 8b 84 24 00
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00801	48 8b 80 70 08
	00 00		 mov	 rax, QWORD PTR [rax+2160]
  00808	48 8b 80 88 08
	00 00		 mov	 rax, QWORD PTR [rax+2184]
  0080f	c6 40 50 2c	 mov	 BYTE PTR [rax+80], 44	; 0000002cH
  00813	eb 1a		 jmp	 SHORT $LN11@s390_sie_e
$LN93@s390_sie_e:

; 1513 :         default:                       STATEBK->c = SIE_C_PGMINT;   break;

  00815	48 8b 84 24 00
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0081d	48 8b 80 70 08
	00 00		 mov	 rax, QWORD PTR [rax+2160]
  00824	48 8b 80 88 08
	00 00		 mov	 rax, QWORD PTR [rax+2184]
  0082b	c6 40 50 08	 mov	 BYTE PTR [rax+80], 8
$LN11@s390_sie_e:
$LN21@s390_sie_e:

; 1514 :     }
; 1515 : 
; 1516 :     PTT_SIE( "sie_xit STA_c", STATEBK->c, 0, 0  );

  0082f	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_pttclass
  00836	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00839	48 25 80 00 00
	00		 and	 rax, 128		; 00000080H
  0083f	48 85 c0	 test	 rax, rax
  00842	74 50		 je	 SHORT $LN94@s390_sie_e
  00844	48 8b 84 24 00
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0084c	48 8b 80 70 08
	00 00		 mov	 rax, QWORD PTR [rax+2160]
  00853	48 8b 80 88 08
	00 00		 mov	 rax, QWORD PTR [rax+2184]
  0085a	0f b6 40 50	 movzx	 eax, BYTE PTR [rax+80]
  0085e	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR [rsp+48], 0
  00867	48 c7 44 24 28
	00 00 00 00	 mov	 QWORD PTR [rsp+40], 0
  00870	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG181220
  00877	48 89 4c 24 20	 mov	 QWORD PTR [rsp+32], rcx
  0087c	45 33 c9	 xor	 r9d, r9d
  0087f	44 8b c0	 mov	 r8d, eax
  00882	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG181221
  00889	b9 80 00 00 00	 mov	 ecx, 128		; 00000080H
  0088e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ptt_pthread_trace
$LN94@s390_sie_e:
  00894	33 c0		 xor	 eax, eax
  00896	85 c0		 test	 eax, eax
  00898	75 95		 jne	 SHORT $LN21@s390_sie_e

; 1517 : 
; 1518 : #if defined( FEATURE_073_TRANSACT_EXEC_FACILITY )
; 1519 : 
; 1520 :     /* US 8,880,959 B2, Greiner et al, 17.20:
; 1521 : 
; 1522 :        "Interception TDB: The 256-byte host real location
; 1523 :         specified by locations 488-495 (x'1E8') of the state
; 1524 :         description."
; 1525 :     */
; 1526 :     FETCH_DW( itdba, STATEBK->itdba );
; 1527 :     if (itdba)
; 1528 :         itdba = APPLY_PREFIXING( itdba, HOSTREGS->PX );
; 1529 : 
; 1530 :     PTT_TXF( "TXF itdb", itdba, 0, 0 );
; 1531 : 
; 1532 :     OBTAIN_TXFLOCK( GUESTREGS );
; 1533 :     {
; 1534 :         txf_tnd     = GUESTREGS->txf_tnd;
; 1535 :         txf_contran = GUESTREGS->txf_contran;
; 1536 :     }
; 1537 :     RELEASE_TXFLOCK( GUESTREGS );
; 1538 : 
; 1539 :     PTT_TXF( "TXF tnd,con", txf_tnd, txf_contran, 0 );
; 1540 : 
; 1541 :     /* "A transaction may be aborted due to causes that
; 1542 :         are outside the scope of the immediate configuration
; 1543 :         in which it executes. For example, transient events
; 1544 :         recognized by a hypervisor (such as LPAR or z/VM)
; 1545 :         may cause a transaction to be aborted."
; 1546 :     */
; 1547 :     if (txf_tnd)
; 1548 :     {
; 1549 :         PTT_TXF( "TXF abrt", 0, 0, TAC_MISC );
; 1550 : 
; 1551 :         GUESTREGS->txf_why |= TXF_WHY_SIE_EXIT;
; 1552 :         ABORT_TRANS( GUESTREGS, ABORT_RETRY_RETURN, TAC_MISC );
; 1553 :         itdb = &GUESTREGS->txf_tdb;
; 1554 :     }
; 1555 :     else if (GUESTREGS->txf_UPGM_abort)
; 1556 :     {
; 1557 :         PTT_TXF( "TXF upgm", GUESTREGS->txf_UPGM_abort, GUESTREGS->txf_aborts, 0 );
; 1558 :         itdb = &GUESTREGS->txf_tdb;
; 1559 :     }
; 1560 : 
; 1561 :     /* Check if we need to fill in an Interception TDB */
; 1562 :     if (STATEBK->c == SIE_C_PGMINT && itdba && itdb)
; 1563 :     {
; 1564 :         PTT_TXF( "TXF itdb <=", itdba, itdb, itdb->tdb_tac );
; 1565 : 
; 1566 :         /* US 8,880,959 B2, Greiner et al, 17.20:
; 1567 : 
; 1568 :            "The interception TDB is stored when an aborted
; 1569 :             transaction results in a guest program interruption
; 1570 :             interception (i.e. interception code 8).  When a
; 1571 :             transaction is aborted due to other causes, the
; 1572 :             contents of the interception TDB are unpredictable."
; 1573 :         */
; 1574 :         if (TXF_TRACING())
; 1575 :         {
; 1576 :             // "TXF: %s%02X: SIE: Populating Interception TDB at 0x%16.16"PRIx64
; 1577 :             WRMSG( HHC17714, "D", TXF_CPUAD( GUESTREGS ), itdba );
; 1578 :         }
; 1579 : 
; 1580 :         memcpy( HOSTREGS->mainstor + itdba, itdb, sizeof( TDB ));
; 1581 :     }
; 1582 :     else if (STATEBK->c == SIE_C_PGMINT && itdb)
; 1583 :     {
; 1584 :         PTT_TXF( "*TXF !itdba", itdba, itdb, itdb->tdb_tac );
; 1585 : 
; 1586 :         if (TXF_TRACING())
; 1587 :         {
; 1588 :             // "TXF: %s%02X: SIE: Interception TDB address not provided!"
; 1589 :             WRMSG( HHC17716, "D", TXF_CPUAD( GUESTREGS ));
; 1590 :         }
; 1591 :     }
; 1592 :     else if (STATEBK->c != SIE_C_PGMINT && itdba)
; 1593 :     {
; 1594 :         PTT_TXF( "*TXF itdba<=0", itdba, 0, 0 );
; 1595 : 
; 1596 :         /* The address of an Interception TDB was provided, but no
; 1597 :            transaction was aborted as a result of this intercepted
; 1598 :            program interrupt. For safety, return a "NULL" (empty)
; 1599 :            Interception TDB instead. (Sorry Dan! Could not locate
; 1600 :            Claudia Schiffers phone number!)
; 1601 :         */
; 1602 :         memset( HOSTREGS->mainstor + itdba, 0, sizeof( TDB ));
; 1603 :     }
; 1604 : 
; 1605 : #endif /* defined( FEATURE_073_TRANSACT_EXEC_FACILITY ) */
; 1606 : 
; 1607 :     /* Save CPU timer  */
; 1608 :     STORE_DW( STATEBK->cputimer, get_cpu_timer( GUESTREGS ));

  0089a	48 8b 84 24 00
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  008a2	48 8b 88 70 08
	00 00		 mov	 rcx, QWORD PTR [rax+2160]
  008a9	e8 00 00 00 00	 call	 get_cpu_timer
  008ae	48 8b c8	 mov	 rcx, rax
  008b1	e8 00 00 00 00	 call	 _byteswap_uint64
  008b6	48 8b 8c 24 00
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  008be	48 8b 89 70 08
	00 00		 mov	 rcx, QWORD PTR [rcx+2160]
  008c5	48 8b 89 88 08
	00 00		 mov	 rcx, QWORD PTR [rcx+2184]
  008cc	48 83 c1 28	 add	 rcx, 40			; 00000028H
  008d0	48 8b d0	 mov	 rdx, rax
  008d3	e8 00 00 00 00	 call	 store_dw_noswap

; 1609 : 
; 1610 :     /* Save clock comparator */
; 1611 :     STORE_DW( STATEBK->clockcomp, ETOD_high64_to_TOD_high56( GUESTREGS->clkc ));

  008d8	48 8b 84 24 00
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  008e0	48 8b 80 70 08
	00 00		 mov	 rax, QWORD PTR [rax+2160]
  008e7	48 8b 88 48 07
	00 00		 mov	 rcx, QWORD PTR [rax+1864]
  008ee	e8 00 00 00 00	 call	 ETOD_high64_to_TOD_high56
  008f3	48 8b c8	 mov	 rcx, rax
  008f6	e8 00 00 00 00	 call	 _byteswap_uint64
  008fb	48 8b 8c 24 00
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00903	48 8b 89 70 08
	00 00		 mov	 rcx, QWORD PTR [rcx+2160]
  0090a	48 8b 89 88 08
	00 00		 mov	 rcx, QWORD PTR [rcx+2184]
  00911	48 83 c1 30	 add	 rcx, 48			; 00000030H
  00915	48 8b d0	 mov	 rdx, rax
  00918	e8 00 00 00 00	 call	 store_dw_noswap

; 1612 : 
; 1613 : #if defined( _FEATURE_INTERVAL_TIMER ) && !defined( FEATURE_001_ZARCH_INSTALLED_FACILITY )
; 1614 :     /* If this is a S/370 guest, and the interval timer is enabled
; 1615 :        then save the timer state control bit
; 1616 :     */
; 1617 :     if (1
; 1618 :         &&  (STATEBK->m & SIE_M_370)
; 1619 :         && !(STATEBK->m & SIE_M_ITMOF)

  0091d	33 c0		 xor	 eax, eax
  0091f	83 f8 01	 cmp	 eax, 1
  00922	0f 84 e2 00 00
	00		 je	 $LN95@s390_sie_e
  00928	48 8b 84 24 00
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00930	48 8b 80 70 08
	00 00		 mov	 rax, QWORD PTR [rax+2160]
  00937	48 8b 80 88 08
	00 00		 mov	 rax, QWORD PTR [rax+2184]
  0093e	0f b6 40 03	 movzx	 eax, BYTE PTR [rax+3]
  00942	83 e0 10	 and	 eax, 16
  00945	85 c0		 test	 eax, eax
  00947	0f 84 bd 00 00
	00		 je	 $LN95@s390_sie_e
  0094d	48 8b 84 24 00
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00955	48 8b 80 70 08
	00 00		 mov	 rax, QWORD PTR [rax+2160]
  0095c	48 8b 80 88 08
	00 00		 mov	 rax, QWORD PTR [rax+2184]
  00963	0f b6 40 03	 movzx	 eax, BYTE PTR [rax+3]
  00967	83 e0 04	 and	 eax, 4
  0096a	85 c0		 test	 eax, eax
  0096c	0f 85 98 00 00
	00		 jne	 $LN95@s390_sie_e

; 1620 :     )
; 1621 :     {
; 1622 :         /* Save the shadow interval timer */
; 1623 :         s370_store_int_timer( regs );

  00972	48 8b 8c 24 00
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0097a	e8 00 00 00 00	 call	 s370_store_int_timer

; 1624 : 
; 1625 :         if (IS_IC_ITIMER( GUESTREGS )) STATEBK->s |=  SIE_S_T;

  0097f	48 8b 84 24 00
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00987	48 8b 80 70 08
	00 00		 mov	 rax, QWORD PTR [rax+2160]
  0098e	8b 40 48	 mov	 eax, DWORD PTR [rax+72]
  00991	25 80 00 00 00	 and	 eax, 128		; 00000080H
  00996	85 c0		 test	 eax, eax
  00998	74 39		 je	 SHORT $LN96@s390_sie_e
  0099a	48 8b 84 24 00
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  009a2	48 8b 80 70 08
	00 00		 mov	 rax, QWORD PTR [rax+2160]
  009a9	48 8b 80 88 08
	00 00		 mov	 rax, QWORD PTR [rax+2184]
  009b0	0f b6 40 01	 movzx	 eax, BYTE PTR [rax+1]
  009b4	0f ba e8 07	 bts	 eax, 7
  009b8	48 8b 8c 24 00
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  009c0	48 8b 89 70 08
	00 00		 mov	 rcx, QWORD PTR [rcx+2160]
  009c7	48 8b 89 88 08
	00 00		 mov	 rcx, QWORD PTR [rcx+2184]
  009ce	88 41 01	 mov	 BYTE PTR [rcx+1], al
  009d1	eb 37		 jmp	 SHORT $LN97@s390_sie_e
$LN96@s390_sie_e:

; 1626 :         else                           STATEBK->s &= ~SIE_S_T;

  009d3	48 8b 84 24 00
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  009db	48 8b 80 70 08
	00 00		 mov	 rax, QWORD PTR [rax+2160]
  009e2	48 8b 80 88 08
	00 00		 mov	 rax, QWORD PTR [rax+2184]
  009e9	0f b6 40 01	 movzx	 eax, BYTE PTR [rax+1]
  009ed	0f ba f0 07	 btr	 eax, 7
  009f1	48 8b 8c 24 00
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  009f9	48 8b 89 70 08
	00 00		 mov	 rcx, QWORD PTR [rcx+2160]
  00a00	48 8b 89 88 08
	00 00		 mov	 rcx, QWORD PTR [rcx+2184]
  00a07	88 41 01	 mov	 BYTE PTR [rcx+1], al
$LN97@s390_sie_e:
$LN95@s390_sie_e:

; 1627 :     }
; 1628 : #endif /* defined( _FEATURE_INTERVAL_TIMER ) && !defined( FEATURE_001_ZARCH_INSTALLED_FACILITY ) */
; 1629 : 
; 1630 :     /* Save TOD Programmable Field */
; 1631 :     STORE_HW( STATEBK->todpf, GUESTREGS->todpr );

  00a0a	48 8b 84 24 00
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00a12	48 8b 80 70 08
	00 00		 mov	 rax, QWORD PTR [rax+2160]
  00a19	0f b7 88 58 07
	00 00		 movzx	 ecx, WORD PTR [rax+1880]
  00a20	e8 00 00 00 00	 call	 _byteswap_ushort
  00a25	48 8b 8c 24 00
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00a2d	48 8b 89 70 08
	00 00		 mov	 rcx, QWORD PTR [rcx+2160]
  00a34	48 8b 89 88 08
	00 00		 mov	 rcx, QWORD PTR [rcx+2184]
  00a3b	48 83 c1 54	 add	 rcx, 84			; 00000054H
  00a3f	0f b7 d0	 movzx	 edx, ax
  00a42	e8 00 00 00 00	 call	 store_hw_noswap

; 1632 : 
; 1633 :     /* Save GR14 and GR15 */
; 1634 :     STORE_W( STATEBK->gr14, GUESTREGS->GR( 14 ));

  00a47	48 8b 84 24 00
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00a4f	48 8b 80 70 08
	00 00		 mov	 rax, QWORD PTR [rax+2160]
  00a56	b9 08 00 00 00	 mov	 ecx, 8
  00a5b	48 6b c9 0e	 imul	 rcx, rcx, 14
  00a5f	8b 8c 08 80 02
	00 00		 mov	 ecx, DWORD PTR [rax+rcx+640]
  00a66	e8 00 00 00 00	 call	 _byteswap_ulong
  00a6b	48 8b 8c 24 00
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00a73	48 8b 89 70 08
	00 00		 mov	 rcx, QWORD PTR [rcx+2160]
  00a7a	48 8b 89 88 08
	00 00		 mov	 rcx, QWORD PTR [rcx+2184]
  00a81	48 83 c1 10	 add	 rcx, 16
  00a85	8b d0		 mov	 edx, eax
  00a87	e8 00 00 00 00	 call	 store_fw_noswap

; 1635 :     STORE_W( STATEBK->gr15, GUESTREGS->GR( 15 ));

  00a8c	48 8b 84 24 00
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00a94	48 8b 80 70 08
	00 00		 mov	 rax, QWORD PTR [rax+2160]
  00a9b	b9 08 00 00 00	 mov	 ecx, 8
  00aa0	48 6b c9 0f	 imul	 rcx, rcx, 15
  00aa4	8b 8c 08 80 02
	00 00		 mov	 ecx, DWORD PTR [rax+rcx+640]
  00aab	e8 00 00 00 00	 call	 _byteswap_ulong
  00ab0	48 8b 8c 24 00
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00ab8	48 8b 89 70 08
	00 00		 mov	 rcx, QWORD PTR [rcx+2160]
  00abf	48 8b 89 88 08
	00 00		 mov	 rcx, QWORD PTR [rcx+2184]
  00ac6	48 83 c1 14	 add	 rcx, 20
  00aca	8b d0		 mov	 edx, eax
  00acc	e8 00 00 00 00	 call	 store_fw_noswap

; 1636 : 
; 1637 :     /* Store the PSW */
; 1638 :     if (GUESTREGS->arch_mode == ARCH_390_IDX)

  00ad1	48 8b 84 24 00
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00ad9	48 8b 80 70 08
	00 00		 mov	 rax, QWORD PTR [rax+2160]
  00ae0	83 78 64 01	 cmp	 DWORD PTR [rax+100], 1
  00ae4	75 33		 jne	 SHORT $LN98@s390_sie_e

; 1639 :         s390_store_psw( GUESTREGS, STATEBK->psw );

  00ae6	48 8b 84 24 00
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00aee	48 8b 80 70 08
	00 00		 mov	 rax, QWORD PTR [rax+2160]
  00af5	48 8b 80 88 08
	00 00		 mov	 rax, QWORD PTR [rax+2184]
  00afc	48 83 c0 18	 add	 rax, 24
  00b00	48 8b d0	 mov	 rdx, rax
  00b03	48 8b 84 24 00
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00b0b	48 8b 88 70 08
	00 00		 mov	 rcx, QWORD PTR [rax+2160]
  00b12	e8 00 00 00 00	 call	 s390_store_psw
  00b17	eb 31		 jmp	 SHORT $LN99@s390_sie_e
$LN98@s390_sie_e:

; 1640 : #if defined( _370 ) || defined( _900 )
; 1641 :     else
; 1642 : #endif
; 1643 : #if defined( FEATURE_001_ZARCH_INSTALLED_FACILITY )
; 1644 :         z900_store_psw( GUESTREGS, STATEBK->psw );
; 1645 : #else
; 1646 : #if defined( _370 )
; 1647 :         s370_store_psw( GUESTREGS, STATEBK->psw );

  00b19	48 8b 84 24 00
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00b21	48 8b 80 70 08
	00 00		 mov	 rax, QWORD PTR [rax+2160]
  00b28	48 8b 80 88 08
	00 00		 mov	 rax, QWORD PTR [rax+2184]
  00b2f	48 83 c0 18	 add	 rax, 24
  00b33	48 8b d0	 mov	 rdx, rax
  00b36	48 8b 84 24 00
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00b3e	48 8b 88 70 08
	00 00		 mov	 rcx, QWORD PTR [rax+2160]
  00b45	e8 00 00 00 00	 call	 s370_store_psw
$LN99@s390_sie_e:

; 1648 : #endif
; 1649 : #endif
; 1650 :     /* Save control registers */
; 1651 :     for (n=0; n < 16; n++)

  00b4a	c7 44 24 50 00
	00 00 00	 mov	 DWORD PTR n$[rsp], 0
  00b52	eb 0a		 jmp	 SHORT $LN24@s390_sie_e
$LN22@s390_sie_e:
  00b54	8b 44 24 50	 mov	 eax, DWORD PTR n$[rsp]
  00b58	ff c0		 inc	 eax
  00b5a	89 44 24 50	 mov	 DWORD PTR n$[rsp], eax
$LN24@s390_sie_e:
  00b5e	83 7c 24 50 10	 cmp	 DWORD PTR n$[rsp], 16
  00b63	7d 50		 jge	 SHORT $LN23@s390_sie_e

; 1652 :         STORE_W( STATEBK->cr[ n ], GUESTREGS->CR( n ));

  00b65	48 8b 84 24 00
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00b6d	48 8b 80 70 08
	00 00		 mov	 rax, QWORD PTR [rax+2160]
  00b74	8b 4c 24 50	 mov	 ecx, DWORD PTR n$[rsp]
  00b78	ff c1		 inc	 ecx
  00b7a	48 63 c9	 movsxd	 rcx, ecx
  00b7d	8b 8c c8 00 06
	00 00		 mov	 ecx, DWORD PTR [rax+rcx*8+1536]
  00b84	e8 00 00 00 00	 call	 _byteswap_ulong
  00b89	48 8b 8c 24 00
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00b91	48 8b 89 70 08
	00 00		 mov	 rcx, QWORD PTR [rcx+2160]
  00b98	48 8b 89 88 08
	00 00		 mov	 rcx, QWORD PTR [rcx+2184]
  00b9f	48 63 54 24 50	 movsxd	 rdx, DWORD PTR n$[rsp]
  00ba4	48 8d 8c 91 80
	00 00 00	 lea	 rcx, QWORD PTR [rcx+rdx*4+128]
  00bac	8b d0		 mov	 edx, eax
  00bae	e8 00 00 00 00	 call	 store_fw_noswap
  00bb3	eb 9f		 jmp	 SHORT $LN22@s390_sie_e
$LN23@s390_sie_e:

; 1653 : 
; 1654 :     /* Update the approprate host registers */
; 1655 :     memcpy( regs->gr,  GUESTREGS->gr,  14 * sizeof( regs->gr [0] ));

  00bb5	48 8b 84 24 00
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00bbd	48 8b 80 70 08
	00 00		 mov	 rax, QWORD PTR [rax+2160]
  00bc4	48 8b 8c 24 00
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00bcc	48 8d b9 80 02
	00 00		 lea	 rdi, QWORD PTR [rcx+640]
  00bd3	48 8d b0 80 02
	00 00		 lea	 rsi, QWORD PTR [rax+640]
  00bda	b9 70 00 00 00	 mov	 ecx, 112		; 00000070H
  00bdf	f3 a4		 rep movsb

; 1656 :     memcpy( regs->ar,  GUESTREGS->ar,  16 * sizeof( regs->ar [0] ));

  00be1	48 8b 84 24 00
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00be9	48 8b 80 70 08
	00 00		 mov	 rax, QWORD PTR [rax+2160]
  00bf0	48 8b 8c 24 00
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00bf8	48 8d b9 00 03
	00 00		 lea	 rdi, QWORD PTR [rcx+768]
  00bff	48 8d b0 00 03
	00 00		 lea	 rsi, QWORD PTR [rax+768]
  00c06	b9 40 00 00 00	 mov	 ecx, 64			; 00000040H
  00c0b	f3 a4		 rep movsb

; 1657 :     memcpy( regs->fpr, GUESTREGS->fpr, 32 * sizeof( regs->fpr[0] ));

  00c0d	48 8b 84 24 00
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00c15	48 8b 80 70 08
	00 00		 mov	 rax, QWORD PTR [rax+2160]
  00c1c	48 8b 8c 24 00
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00c24	48 8d b9 40 03
	00 00		 lea	 rdi, QWORD PTR [rcx+832]
  00c2b	48 8d b0 40 03
	00 00		 lea	 rsi, QWORD PTR [rax+832]
  00c32	b9 80 00 00 00	 mov	 ecx, 128		; 00000080H
  00c37	f3 a4		 rep movsb

; 1658 : #if defined( FEATURE_BINARY_FLOATING_POINT )
; 1659 :     regs->fpc = GUESTREGS->fpc;

  00c39	48 8b 84 24 00
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00c41	48 8b 80 70 08
	00 00		 mov	 rax, QWORD PTR [rax+2160]
  00c48	48 8b 8c 24 00
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00c50	8b 80 c0 03 00
	00		 mov	 eax, DWORD PTR [rax+960]
  00c56	89 81 c0 03 00
	00		 mov	 DWORD PTR [rcx+960], eax
$LN27@s390_sie_e:

; 1660 : #endif
; 1661 : 
; 1662 :     /* Invalidate instruction address accelerator */
; 1663 :     INVALIDATE_AIA(regs);

  00c5c	48 8b 84 24 00
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00c64	48 83 b8 08 02
	00 00 00	 cmp	 QWORD PTR [rax+520], 0
  00c6c	74 61		 je	 SHORT $LN100@s390_sie_e
  00c6e	48 8b 84 24 00
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00c76	8b 80 10 02 00
	00		 mov	 eax, DWORD PTR [rax+528]
  00c7c	48 8b 8c 24 00
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00c84	48 8b 94 24 00
	01 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  00c8c	48 8b 92 00 02
	00 00		 mov	 rdx, QWORD PTR [rdx+512]
  00c93	48 8b 49 68	 mov	 rcx, QWORD PTR [rcx+104]
  00c97	48 2b ca	 sub	 rcx, rdx
  00c9a	48 03 c1	 add	 rax, rcx
  00c9d	48 8b 8c 24 00
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00ca5	8b 89 90 00 00
	00		 mov	 ecx, DWORD PTR [rcx+144]
  00cab	48 23 c1	 and	 rax, rcx
  00cae	48 8b 8c 24 00
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00cb6	89 81 88 00 00
	00		 mov	 DWORD PTR [rcx+136], eax
  00cbc	48 8b 84 24 00
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00cc4	48 c7 80 08 02
	00 00 00 00 00
	00		 mov	 QWORD PTR [rax+520], 0
$LN100@s390_sie_e:
  00ccf	33 c0		 xor	 eax, eax
  00cd1	85 c0		 test	 eax, eax
  00cd3	75 87		 jne	 SHORT $LN27@s390_sie_e
$LN30@s390_sie_e:

; 1664 :     SET_AEA_MODE( regs );

  00cd5	b8 04 00 00 00	 mov	 eax, 4
  00cda	48 6b c0 04	 imul	 rax, rax, 4
  00cde	48 8b 8c 24 00
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00ce6	8b 84 01 94 0c
	00 00		 mov	 eax, DWORD PTR [rcx+rax+3220]
  00ced	89 84 24 c0 00
	00 00		 mov	 DWORD PTR inst_cr$7[rsp], eax
  00cf4	48 8b 84 24 00
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00cfc	0f b6 80 90 0c
	00 00		 movzx	 eax, BYTE PTR [rax+3216]
  00d03	88 44 24 45	 mov	 BYTE PTR oldmode$2[rsp], al
  00d07	48 8b 84 24 00
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00d0f	0f b6 40 78	 movzx	 eax, BYTE PTR [rax+120]
  00d13	83 e0 04	 and	 eax, 4
  00d16	85 c0		 test	 eax, eax
  00d18	75 6c		 jne	 SHORT $LN151@s390_sie_e
  00d1a	48 8b 84 24 00
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00d22	8b 80 c8 08 00
	00		 mov	 eax, DWORD PTR [rax+2248]
  00d28	d1 e8		 shr	 eax, 1
  00d2a	83 e0 01	 and	 eax, 1
  00d2d	85 c0		 test	 eax, eax
  00d2f	74 3a		 je	 SHORT $LN149@s390_sie_e
  00d31	48 8b 84 24 00
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00d39	48 8b 80 88 08
	00 00		 mov	 rax, QWORD PTR [rax+2184]
  00d40	0f b6 40 02	 movzx	 eax, BYTE PTR [rax+2]
  00d44	83 e0 01	 and	 eax, 1
  00d47	85 c0		 test	 eax, eax
  00d49	74 20		 je	 SHORT $LN149@s390_sie_e
  00d4b	48 8b 84 24 00
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00d53	0f b6 40 7b	 movzx	 eax, BYTE PTR [rax+123]
  00d57	83 e0 40	 and	 eax, 64			; 00000040H
  00d5a	85 c0		 test	 eax, eax
  00d5c	74 0d		 je	 SHORT $LN149@s390_sie_e
  00d5e	c7 84 24 88 00
	00 00 02 00 00
	00		 mov	 DWORD PTR tv553[rsp], 2
  00d69	eb 0b		 jmp	 SHORT $LN150@s390_sie_e
$LN149@s390_sie_e:
  00d6b	c7 84 24 88 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv553[rsp], 0
$LN150@s390_sie_e:
  00d76	8b 84 24 88 00
	00 00		 mov	 eax, DWORD PTR tv553[rsp]
  00d7d	89 84 24 90 00
	00 00		 mov	 DWORD PTR tv558[rsp], eax
  00d84	eb 18		 jmp	 SHORT $LN152@s390_sie_e
$LN151@s390_sie_e:
  00d86	48 8b 84 24 00
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00d8e	0f b6 40 7b	 movzx	 eax, BYTE PTR [rax+123]
  00d92	c1 f8 06	 sar	 eax, 6
  00d95	ff c0		 inc	 eax
  00d97	89 84 24 90 00
	00 00		 mov	 DWORD PTR tv558[rsp], eax
$LN152@s390_sie_e:
  00d9e	33 c0		 xor	 eax, eax
  00da0	85 c0		 test	 eax, eax
  00da2	75 51		 jne	 SHORT $LN153@s390_sie_e
  00da4	48 8b 84 24 00
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00dac	0f b6 40 78	 movzx	 eax, BYTE PTR [rax+120]
  00db0	83 e0 40	 and	 eax, 64			; 00000040H
  00db3	85 c0		 test	 eax, eax
  00db5	75 3e		 jne	 SHORT $LN153@s390_sie_e
  00db7	48 8b 84 24 00
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00dbf	8b 80 c8 08 00
	00		 mov	 eax, DWORD PTR [rax+2248]
  00dc5	d1 e8		 shr	 eax, 1
  00dc7	83 e0 01	 and	 eax, 1
  00dca	85 c0		 test	 eax, eax
  00dcc	74 1a		 je	 SHORT $LN154@s390_sie_e
  00dce	48 8b 84 24 00
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00dd6	48 8b 80 88 08
	00 00		 mov	 rax, QWORD PTR [rax+2184]
  00ddd	0f b6 40 03	 movzx	 eax, BYTE PTR [rax+3]
  00de1	83 e0 01	 and	 eax, 1
  00de4	85 c0		 test	 eax, eax
  00de6	75 0d		 jne	 SHORT $LN153@s390_sie_e
$LN154@s390_sie_e:
  00de8	c7 84 24 8c 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv573[rsp], 0
  00df3	eb 0b		 jmp	 SHORT $LN155@s390_sie_e
$LN153@s390_sie_e:
  00df5	c7 84 24 8c 00
	00 00 40 00 00
	00		 mov	 DWORD PTR tv573[rsp], 64 ; 00000040H
$LN155@s390_sie_e:
  00e00	8b 84 24 8c 00
	00 00		 mov	 eax, DWORD PTR tv573[rsp]
  00e07	8b 8c 24 90 00
	00 00		 mov	 ecx, DWORD PTR tv558[rsp]
  00e0e	0b c8		 or	 ecx, eax
  00e10	8b c1		 mov	 eax, ecx
  00e12	48 8b 8c 24 00
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00e1a	88 81 90 0c 00
	00		 mov	 BYTE PTR [rcx+3216], al
  00e20	48 8b 84 24 00
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00e28	0f b6 80 90 0c
	00 00		 movzx	 eax, BYTE PTR [rax+3216]
  00e2f	83 e0 0f	 and	 eax, 15
  00e32	89 44 24 60	 mov	 DWORD PTR tv579[rsp], eax
  00e36	83 7c 24 60 01	 cmp	 DWORD PTR tv579[rsp], 1
  00e3b	74 22		 je	 SHORT $LN101@s390_sie_e
  00e3d	83 7c 24 60 02	 cmp	 DWORD PTR tv579[rsp], 2
  00e42	74 59		 je	 SHORT $LN102@s390_sie_e
  00e44	83 7c 24 60 03	 cmp	 DWORD PTR tv579[rsp], 3
  00e49	0f 84 11 01 00
	00		 je	 $LN106@s390_sie_e
  00e4f	83 7c 24 60 04	 cmp	 DWORD PTR tv579[rsp], 4
  00e54	0f 84 5d 01 00
	00		 je	 $LN107@s390_sie_e
  00e5a	e9 93 01 00 00	 jmp	 $LN108@s390_sie_e
$LN101@s390_sie_e:
  00e5f	c7 44 24 40 ff
	ff ff ff	 mov	 DWORD PTR i$1[rsp], -1
  00e67	eb 0a		 jmp	 SHORT $LN35@s390_sie_e
$LN33@s390_sie_e:
  00e69	8b 44 24 40	 mov	 eax, DWORD PTR i$1[rsp]
  00e6d	ff c0		 inc	 eax
  00e6f	89 44 24 40	 mov	 DWORD PTR i$1[rsp], eax
$LN35@s390_sie_e:
  00e73	83 7c 24 40 10	 cmp	 DWORD PTR i$1[rsp], 16
  00e78	7d 1e		 jge	 SHORT $LN34@s390_sie_e
  00e7a	8b 44 24 40	 mov	 eax, DWORD PTR i$1[rsp]
  00e7e	83 c0 05	 add	 eax, 5
  00e81	48 98		 cdqe
  00e83	48 8b 8c 24 00
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00e8b	c7 84 81 94 0c
	00 00 01 00 00
	00		 mov	 DWORD PTR [rcx+rax*4+3220], 1
  00e96	eb d1		 jmp	 SHORT $LN33@s390_sie_e
$LN34@s390_sie_e:
  00e98	e9 8e 01 00 00	 jmp	 $LN31@s390_sie_e
$LN102@s390_sie_e:
  00e9d	c7 44 24 40 ff
	ff ff ff	 mov	 DWORD PTR i$1[rsp], -1
  00ea5	eb 0a		 jmp	 SHORT $LN38@s390_sie_e
$LN36@s390_sie_e:
  00ea7	8b 44 24 40	 mov	 eax, DWORD PTR i$1[rsp]
  00eab	ff c0		 inc	 eax
  00ead	89 44 24 40	 mov	 DWORD PTR i$1[rsp], eax
$LN38@s390_sie_e:
  00eb1	83 7c 24 40 10	 cmp	 DWORD PTR i$1[rsp], 16
  00eb6	7d 1e		 jge	 SHORT $LN37@s390_sie_e
  00eb8	8b 44 24 40	 mov	 eax, DWORD PTR i$1[rsp]
  00ebc	83 c0 05	 add	 eax, 5
  00ebf	48 98		 cdqe
  00ec1	48 8b 8c 24 00
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00ec9	c7 84 81 94 0c
	00 00 01 00 00
	00		 mov	 DWORD PTR [rcx+rax*4+3220], 1
  00ed4	eb d1		 jmp	 SHORT $LN36@s390_sie_e
$LN37@s390_sie_e:
  00ed6	c7 44 24 40 01
	00 00 00	 mov	 DWORD PTR i$1[rsp], 1
  00ede	eb 0a		 jmp	 SHORT $LN41@s390_sie_e
$LN39@s390_sie_e:
  00ee0	8b 44 24 40	 mov	 eax, DWORD PTR i$1[rsp]
  00ee4	ff c0		 inc	 eax
  00ee6	89 44 24 40	 mov	 DWORD PTR i$1[rsp], eax
$LN41@s390_sie_e:
  00eea	83 7c 24 40 10	 cmp	 DWORD PTR i$1[rsp], 16
  00eef	7d 6a		 jge	 SHORT $LN40@s390_sie_e
  00ef1	48 63 44 24 40	 movsxd	 rax, DWORD PTR i$1[rsp]
  00ef6	48 8b 8c 24 00
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00efe	83 bc 81 00 03
	00 00 01	 cmp	 DWORD PTR [rcx+rax*4+768], 1
  00f06	75 1e		 jne	 SHORT $LN103@s390_sie_e
  00f08	8b 44 24 40	 mov	 eax, DWORD PTR i$1[rsp]
  00f0c	83 c0 05	 add	 eax, 5
  00f0f	48 98		 cdqe
  00f11	48 8b 8c 24 00
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00f19	c7 84 81 94 0c
	00 00 07 00 00
	00		 mov	 DWORD PTR [rcx+rax*4+3220], 7
  00f24	eb 33		 jmp	 SHORT $LN104@s390_sie_e
$LN103@s390_sie_e:
  00f26	48 63 44 24 40	 movsxd	 rax, DWORD PTR i$1[rsp]
  00f2b	48 8b 8c 24 00
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00f33	83 bc 81 00 03
	00 00 00	 cmp	 DWORD PTR [rcx+rax*4+768], 0
  00f3b	74 1c		 je	 SHORT $LN105@s390_sie_e
  00f3d	8b 44 24 40	 mov	 eax, DWORD PTR i$1[rsp]
  00f41	83 c0 05	 add	 eax, 5
  00f44	48 98		 cdqe
  00f46	48 8b 8c 24 00
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00f4e	c7 84 81 94 0c
	00 00 00 00 00
	00		 mov	 DWORD PTR [rcx+rax*4+3220], 0
$LN105@s390_sie_e:
$LN104@s390_sie_e:
  00f59	eb 85		 jmp	 SHORT $LN39@s390_sie_e
$LN40@s390_sie_e:
  00f5b	e9 cb 00 00 00	 jmp	 $LN31@s390_sie_e
$LN106@s390_sie_e:
  00f60	b8 04 00 00 00	 mov	 eax, 4
  00f65	48 6b c0 04	 imul	 rax, rax, 4
  00f69	48 8b 8c 24 00
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00f71	c7 84 01 94 0c
	00 00 01 00 00
	00		 mov	 DWORD PTR [rcx+rax+3220], 1
  00f7c	c7 44 24 40 00
	00 00 00	 mov	 DWORD PTR i$1[rsp], 0
  00f84	eb 0a		 jmp	 SHORT $LN44@s390_sie_e
$LN42@s390_sie_e:
  00f86	8b 44 24 40	 mov	 eax, DWORD PTR i$1[rsp]
  00f8a	ff c0		 inc	 eax
  00f8c	89 44 24 40	 mov	 DWORD PTR i$1[rsp], eax
$LN44@s390_sie_e:
  00f90	83 7c 24 40 10	 cmp	 DWORD PTR i$1[rsp], 16
  00f95	7d 1e		 jge	 SHORT $LN43@s390_sie_e
  00f97	8b 44 24 40	 mov	 eax, DWORD PTR i$1[rsp]
  00f9b	83 c0 05	 add	 eax, 5
  00f9e	48 98		 cdqe
  00fa0	48 8b 8c 24 00
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00fa8	c7 84 81 94 0c
	00 00 07 00 00
	00		 mov	 DWORD PTR [rcx+rax*4+3220], 7
  00fb3	eb d1		 jmp	 SHORT $LN42@s390_sie_e
$LN43@s390_sie_e:
  00fb5	eb 74		 jmp	 SHORT $LN31@s390_sie_e
$LN107@s390_sie_e:
  00fb7	c7 44 24 40 ff
	ff ff ff	 mov	 DWORD PTR i$1[rsp], -1
  00fbf	eb 0a		 jmp	 SHORT $LN47@s390_sie_e
$LN45@s390_sie_e:
  00fc1	8b 44 24 40	 mov	 eax, DWORD PTR i$1[rsp]
  00fc5	ff c0		 inc	 eax
  00fc7	89 44 24 40	 mov	 DWORD PTR i$1[rsp], eax
$LN47@s390_sie_e:
  00fcb	83 7c 24 40 10	 cmp	 DWORD PTR i$1[rsp], 16
  00fd0	7d 1e		 jge	 SHORT $LN46@s390_sie_e
  00fd2	8b 44 24 40	 mov	 eax, DWORD PTR i$1[rsp]
  00fd6	83 c0 05	 add	 eax, 5
  00fd9	48 98		 cdqe
  00fdb	48 8b 8c 24 00
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00fe3	c7 84 81 94 0c
	00 00 0d 00 00
	00		 mov	 DWORD PTR [rcx+rax*4+3220], 13
  00fee	eb d1		 jmp	 SHORT $LN45@s390_sie_e
$LN46@s390_sie_e:
  00ff0	eb 39		 jmp	 SHORT $LN31@s390_sie_e
$LN108@s390_sie_e:
  00ff2	c7 44 24 40 ff
	ff ff ff	 mov	 DWORD PTR i$1[rsp], -1
  00ffa	eb 0a		 jmp	 SHORT $LN50@s390_sie_e
$LN48@s390_sie_e:
  00ffc	8b 44 24 40	 mov	 eax, DWORD PTR i$1[rsp]
  01000	ff c0		 inc	 eax
  01002	89 44 24 40	 mov	 DWORD PTR i$1[rsp], eax
$LN50@s390_sie_e:
  01006	83 7c 24 40 10	 cmp	 DWORD PTR i$1[rsp], 16
  0100b	7d 1e		 jge	 SHORT $LN49@s390_sie_e
  0100d	8b 44 24 40	 mov	 eax, DWORD PTR i$1[rsp]
  01011	83 c0 05	 add	 eax, 5
  01014	48 98		 cdqe
  01016	48 8b 8c 24 00
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0101e	c7 84 81 94 0c
	00 00 ff ff ff
	ff		 mov	 DWORD PTR [rcx+rax*4+3220], -1
  01029	eb d1		 jmp	 SHORT $LN48@s390_sie_e
$LN49@s390_sie_e:
$LN31@s390_sie_e:
  0102b	b8 04 00 00 00	 mov	 eax, 4
  01030	48 6b c0 04	 imul	 rax, rax, 4
  01034	48 8b 8c 24 00
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0103c	8b 84 01 94 0c
	00 00		 mov	 eax, DWORD PTR [rcx+rax+3220]
  01043	39 84 24 c0 00
	00 00		 cmp	 DWORD PTR inst_cr$7[rsp], eax
  0104a	74 79		 je	 SHORT $LN109@s390_sie_e
$LN53@s390_sie_e:
  0104c	48 8b 84 24 00
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  01054	48 83 b8 08 02
	00 00 00	 cmp	 QWORD PTR [rax+520], 0
  0105c	74 61		 je	 SHORT $LN110@s390_sie_e
  0105e	48 8b 84 24 00
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  01066	8b 80 10 02 00
	00		 mov	 eax, DWORD PTR [rax+528]
  0106c	48 8b 8c 24 00
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  01074	48 8b 94 24 00
	01 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  0107c	48 8b 92 00 02
	00 00		 mov	 rdx, QWORD PTR [rdx+512]
  01083	48 8b 49 68	 mov	 rcx, QWORD PTR [rcx+104]
  01087	48 2b ca	 sub	 rcx, rdx
  0108a	48 03 c1	 add	 rax, rcx
  0108d	48 8b 8c 24 00
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  01095	8b 89 90 00 00
	00		 mov	 ecx, DWORD PTR [rcx+144]
  0109b	48 23 c1	 and	 rax, rcx
  0109e	48 8b 8c 24 00
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  010a6	89 81 88 00 00
	00		 mov	 DWORD PTR [rcx+136], eax
  010ac	48 8b 84 24 00
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  010b4	48 c7 80 08 02
	00 00 00 00 00
	00		 mov	 QWORD PTR [rax+520], 0
$LN110@s390_sie_e:
  010bf	33 c0		 xor	 eax, eax
  010c1	85 c0		 test	 eax, eax
  010c3	75 87		 jne	 SHORT $LN53@s390_sie_e
$LN109@s390_sie_e:
  010c5	0f b6 44 24 45	 movzx	 eax, BYTE PTR oldmode$2[rsp]
  010ca	83 e0 40	 and	 eax, 64			; 00000040H
  010cd	85 c0		 test	 eax, eax
  010cf	0f 85 f0 00 00
	00		 jne	 $LN111@s390_sie_e
  010d5	48 8b 84 24 00
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  010dd	0f b6 80 90 0c
	00 00		 movzx	 eax, BYTE PTR [rax+3216]
  010e4	83 e0 40	 and	 eax, 64			; 00000040H
  010e7	85 c0		 test	 eax, eax
  010e9	0f 84 d6 00 00
	00		 je	 $LN111@s390_sie_e
$LN56@s390_sie_e:
  010ef	48 8b 84 24 00
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  010f7	48 83 b8 08 02
	00 00 00	 cmp	 QWORD PTR [rax+520], 0
  010ff	74 61		 je	 SHORT $LN112@s390_sie_e
  01101	48 8b 84 24 00
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  01109	8b 80 10 02 00
	00		 mov	 eax, DWORD PTR [rax+528]
  0110f	48 8b 8c 24 00
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  01117	48 8b 94 24 00
	01 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  0111f	48 8b 92 00 02
	00 00		 mov	 rdx, QWORD PTR [rdx+512]
  01126	48 8b 49 68	 mov	 rcx, QWORD PTR [rcx+104]
  0112a	48 2b ca	 sub	 rcx, rdx
  0112d	48 03 c1	 add	 rax, rcx
  01130	48 8b 8c 24 00
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  01138	8b 89 90 00 00
	00		 mov	 ecx, DWORD PTR [rcx+144]
  0113e	48 23 c1	 and	 rax, rcx
  01141	48 8b 8c 24 00
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  01149	89 81 88 00 00
	00		 mov	 DWORD PTR [rcx+136], eax
  0114f	48 8b 84 24 00
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  01157	48 c7 80 08 02
	00 00 00 00 00
	00		 mov	 QWORD PTR [rax+520], 0
$LN112@s390_sie_e:
  01162	33 c0		 xor	 eax, eax
  01164	85 c0		 test	 eax, eax
  01166	75 87		 jne	 SHORT $LN56@s390_sie_e
  01168	48 8b 84 24 00
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  01170	8b 80 28 07 00
	00		 mov	 eax, DWORD PTR [rax+1832]
  01176	c1 e8 02	 shr	 eax, 2
  01179	83 e0 01	 and	 eax, 1
  0117c	85 c0		 test	 eax, eax
  0117e	74 0d		 je	 SHORT $LN158@s390_sie_e
  01180	c7 84 24 94 00
	00 00 01 00 00
	00		 mov	 DWORD PTR tv695[rsp], 1
  0118b	eb 0b		 jmp	 SHORT $LN159@s390_sie_e
$LN158@s390_sie_e:
  0118d	c7 84 24 94 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv695[rsp], 0
$LN159@s390_sie_e:
  01198	83 bc 24 94 00
	00 00 00	 cmp	 DWORD PTR tv695[rsp], 0
  011a0	74 23		 je	 SHORT $LN113@s390_sie_e
  011a2	48 8b 84 24 00
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  011aa	8b 40 48	 mov	 eax, DWORD PTR [rax+72]
  011ad	25 00 00 20 00	 and	 eax, 2097152		; 00200000H
  011b2	85 c0		 test	 eax, eax
  011b4	74 0f		 je	 SHORT $LN113@s390_sie_e
  011b6	b2 fc		 mov	 dl, 252			; 000000fcH
  011b8	48 8b 8c 24 00
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  011c0	e8 00 00 00 00	 call	 s390_invalidate_tlb
$LN113@s390_sie_e:
$LN111@s390_sie_e:
  011c5	33 c0		 xor	 eax, eax
  011c7	85 c0		 test	 eax, eax
  011c9	0f 85 06 fb ff
	ff		 jne	 $LN30@s390_sie_e

; 1665 : 
; 1666 :     /* Zeroize the interruption parameters */
; 1667 :     memset( STATEBK->ipa, 0, 10 );

  011cf	48 8b 84 24 00
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  011d7	48 8b 80 70 08
	00 00		 mov	 rax, QWORD PTR [rax+2160]
  011de	48 8b 80 88 08
	00 00		 mov	 rax, QWORD PTR [rax+2184]
  011e5	48 83 c0 56	 add	 rax, 86			; 00000056H
  011e9	48 8b f8	 mov	 rdi, rax
  011ec	33 c0		 xor	 eax, eax
  011ee	b9 0a 00 00 00	 mov	 ecx, 10
  011f3	f3 aa		 rep stosb

; 1668 : 
; 1669 :     /* If format-2 interception, we have more work to do */
; 1670 :     if (0
; 1671 :         || STATEBK->c == SIE_C_INST
; 1672 :         || STATEBK->c == SIE_C_BOTH
; 1673 :         || STATEBK->c == SIE_C_OPEREXC
; 1674 :         || STATEBK->c == SIE_C_IOINST

  011f5	33 c0		 xor	 eax, eax
  011f7	85 c0		 test	 eax, eax
  011f9	0f 85 80 00 00
	00		 jne	 $LN115@s390_sie_e
  011ff	48 8b 84 24 00
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  01207	48 8b 80 70 08
	00 00		 mov	 rax, QWORD PTR [rax+2160]
  0120e	48 8b 80 88 08
	00 00		 mov	 rax, QWORD PTR [rax+2184]
  01215	0f b6 40 50	 movzx	 eax, BYTE PTR [rax+80]
  01219	83 f8 04	 cmp	 eax, 4
  0121c	74 61		 je	 SHORT $LN115@s390_sie_e
  0121e	48 8b 84 24 00
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  01226	48 8b 80 70 08
	00 00		 mov	 rax, QWORD PTR [rax+2160]
  0122d	48 8b 80 88 08
	00 00		 mov	 rax, QWORD PTR [rax+2184]
  01234	0f b6 40 50	 movzx	 eax, BYTE PTR [rax+80]
  01238	83 f8 0c	 cmp	 eax, 12
  0123b	74 42		 je	 SHORT $LN115@s390_sie_e
  0123d	48 8b 84 24 00
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  01245	48 8b 80 70 08
	00 00		 mov	 rax, QWORD PTR [rax+2160]
  0124c	48 8b 80 88 08
	00 00		 mov	 rax, QWORD PTR [rax+2184]
  01253	0f b6 40 50	 movzx	 eax, BYTE PTR [rax+80]
  01257	83 f8 2c	 cmp	 eax, 44			; 0000002cH
  0125a	74 23		 je	 SHORT $LN115@s390_sie_e
  0125c	48 8b 84 24 00
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  01264	48 8b 80 70 08
	00 00		 mov	 rax, QWORD PTR [rax+2160]
  0126b	48 8b 80 88 08
	00 00		 mov	 rax, QWORD PTR [rax+2184]
  01272	0f b6 40 50	 movzx	 eax, BYTE PTR [rax+80]
  01276	83 f8 40	 cmp	 eax, 64			; 00000040H
  01279	0f 85 1a 06 00
	00		 jne	 $LN114@s390_sie_e
$LN115@s390_sie_e:

; 1675 :     )
; 1676 :     {
; 1677 :         /* Indicate interception format 2 */
; 1678 :         STATEBK->f |= SIE_F_IN;

  0127f	48 8b 84 24 00
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  01287	48 8b 80 70 08
	00 00		 mov	 rax, QWORD PTR [rax+2160]
  0128e	48 8b 80 88 08
	00 00		 mov	 rax, QWORD PTR [rax+2184]
  01295	0f b6 40 51	 movzx	 eax, BYTE PTR [rax+81]
  01299	0f ba e8 07	 bts	 eax, 7
  0129d	48 8b 8c 24 00
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  012a5	48 8b 89 70 08
	00 00		 mov	 rcx, QWORD PTR [rcx+2160]
  012ac	48 8b 89 88 08
	00 00		 mov	 rcx, QWORD PTR [rcx+2184]
  012b3	88 41 51	 mov	 BYTE PTR [rcx+81], al

; 1679 : 
; 1680 : #if defined( _FEATURE_PER )
; 1681 :         /* Handle PER or concurrent PER event */
; 1682 :         if (1
; 1683 :             && OPEN_IC_PER( GUESTREGS )
; 1684 :             && ECMODE( &GUESTREGS->psw )
; 1685 :             && (GUESTREGS->psw.sysmask & PSW_PERMODE)

  012b6	33 c0		 xor	 eax, eax
  012b8	83 f8 01	 cmp	 eax, 1
  012bb	0f 84 f5 01 00
	00		 je	 $LN116@s390_sie_e
  012c1	48 8b 84 24 00
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  012c9	48 8b 80 70 08
	00 00		 mov	 rax, QWORD PTR [rax+2160]
  012d0	48 8b 8c 24 00
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  012d8	48 8b 89 70 08
	00 00		 mov	 rcx, QWORD PTR [rcx+2160]
  012df	8b 49 4c	 mov	 ecx, DWORD PTR [rcx+76]
  012e2	8b 40 48	 mov	 eax, DWORD PTR [rax+72]
  012e5	23 c1		 and	 eax, ecx
  012e7	25 00 00 ff 00	 and	 eax, 16711680		; 00ff0000H
  012ec	85 c0		 test	 eax, eax
  012ee	0f 84 c2 01 00
	00		 je	 $LN116@s390_sie_e
  012f4	48 8b 84 24 00
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  012fc	48 8b 80 70 08
	00 00		 mov	 rax, QWORD PTR [rax+2160]
  01303	0f b6 40 7a	 movzx	 eax, BYTE PTR [rax+122]
  01307	83 e0 08	 and	 eax, 8
  0130a	85 c0		 test	 eax, eax
  0130c	0f 84 a4 01 00
	00		 je	 $LN116@s390_sie_e
  01312	48 8b 84 24 00
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0131a	48 8b 80 70 08
	00 00		 mov	 rax, QWORD PTR [rax+2160]
  01321	0f b6 40 78	 movzx	 eax, BYTE PTR [rax+120]
  01325	83 e0 40	 and	 eax, 64			; 00000040H
  01328	85 c0		 test	 eax, eax
  0132a	0f 84 86 01 00
	00		 je	 $LN116@s390_sie_e

; 1686 :         )
; 1687 :         {
; 1688 :             PSA* psa;
; 1689 : 
; 1690 : #if defined( _FEATURE_PER2 )
; 1691 : 
; 1692 :             GUESTREGS->perc |= OPEN_IC_PER( GUESTREGS ) >> ((32 - IC_CR9_SHIFT) - 16);

  01330	48 8b 84 24 00
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  01338	48 8b 80 70 08
	00 00		 mov	 rax, QWORD PTR [rax+2160]
  0133f	48 8b 8c 24 00
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  01347	48 8b 89 70 08
	00 00		 mov	 rcx, QWORD PTR [rcx+2160]
  0134e	48 8b 94 24 00
	01 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  01356	48 8b 92 70 08
	00 00		 mov	 rdx, QWORD PTR [rdx+2160]
  0135d	8b 52 4c	 mov	 edx, DWORD PTR [rdx+76]
  01360	8b 49 48	 mov	 ecx, DWORD PTR [rcx+72]
  01363	23 ca		 and	 ecx, edx
  01365	81 e1 00 00 ff
	00		 and	 ecx, 16711680		; 00ff0000H
  0136b	c1 e9 08	 shr	 ecx, 8
  0136e	0f b7 80 d0 08
	00 00		 movzx	 eax, WORD PTR [rax+2256]
  01375	0b c1		 or	 eax, ecx
  01377	48 8b 8c 24 00
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0137f	48 8b 89 70 08
	00 00		 mov	 rcx, QWORD PTR [rcx+2160]
  01386	66 89 81 d0 08
	00 00		 mov	 WORD PTR [rcx+2256], ax

; 1693 : 
; 1694 :             /* Positions 14 and 15 contain zeros
; 1695 :                if a storage alteration event was NOT indicated
; 1696 :             */
; 1697 :             if (0
; 1698 :                 || !(OPEN_IC_PER_SA( GUESTREGS ))
; 1699 :                 ||  (OPEN_IC_PER_STURA( GUESTREGS ))

  0138d	33 c0		 xor	 eax, eax
  0138f	85 c0		 test	 eax, eax
  01391	75 5e		 jne	 SHORT $LN118@s390_sie_e
  01393	48 8b 84 24 00
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0139b	48 8b 80 70 08
	00 00		 mov	 rax, QWORD PTR [rax+2160]
  013a2	48 8b 8c 24 00
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  013aa	48 8b 89 70 08
	00 00		 mov	 rcx, QWORD PTR [rcx+2160]
  013b1	8b 49 4c	 mov	 ecx, DWORD PTR [rcx+76]
  013b4	8b 40 48	 mov	 eax, DWORD PTR [rax+72]
  013b7	23 c1		 and	 eax, ecx
  013b9	25 00 00 20 00	 and	 eax, 2097152		; 00200000H
  013be	85 c0		 test	 eax, eax
  013c0	74 2f		 je	 SHORT $LN118@s390_sie_e
  013c2	48 8b 84 24 00
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  013ca	48 8b 80 70 08
	00 00		 mov	 rax, QWORD PTR [rax+2160]
  013d1	48 8b 8c 24 00
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  013d9	48 8b 89 70 08
	00 00		 mov	 rcx, QWORD PTR [rcx+2160]
  013e0	8b 49 4c	 mov	 ecx, DWORD PTR [rcx+76]
  013e3	8b 40 48	 mov	 eax, DWORD PTR [rax+72]
  013e6	23 c1		 and	 eax, ecx
  013e8	25 00 00 08 00	 and	 eax, 524288		; 00080000H
  013ed	85 c0		 test	 eax, eax
  013ef	74 31		 je	 SHORT $LN117@s390_sie_e
$LN118@s390_sie_e:

; 1700 :             )
; 1701 :                 GUESTREGS->perc &= 0xFFFC;

  013f1	48 8b 84 24 00
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  013f9	48 8b 80 70 08
	00 00		 mov	 rax, QWORD PTR [rax+2160]
  01400	0f b7 80 d0 08
	00 00		 movzx	 eax, WORD PTR [rax+2256]
  01407	25 fc ff 00 00	 and	 eax, 65532		; 0000fffcH
  0140c	48 8b 8c 24 00
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  01414	48 8b 89 70 08
	00 00		 mov	 rcx, QWORD PTR [rcx+2160]
  0141b	66 89 81 d0 08
	00 00		 mov	 WORD PTR [rcx+2256], ax
$LN117@s390_sie_e:

; 1702 : 
; 1703 : #endif /* defined( _FEATURE_PER2 ) */
; 1704 : 
; 1705 :             /* Point to PSA fields in state descriptor */
; 1706 :             psa = (void*)(regs->mainstor + SIE_STATE(GUESTREGS) + SIE_IP_PSA_OFFSET);

  01422	48 8b 84 24 00
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0142a	48 8b 80 70 08
	00 00		 mov	 rax, QWORD PTR [rax+2160]
  01431	48 8b 8c 24 00
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  01439	48 8b 89 48 08
	00 00		 mov	 rcx, QWORD PTR [rcx+2120]
  01440	48 8b 80 80 08
	00 00		 mov	 rax, QWORD PTR [rax+2176]
  01447	48 8d 44 01 40	 lea	 rax, QWORD PTR [rcx+rax+64]
  0144c	48 89 84 24 c8
	00 00 00	 mov	 QWORD PTR psa$8[rsp], rax

; 1707 :             STORE_HW( psa->perint, GUESTREGS->perc   );

  01454	48 8b 84 24 00
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0145c	48 8b 80 70 08
	00 00		 mov	 rax, QWORD PTR [rax+2160]
  01463	0f b7 88 d0 08
	00 00		 movzx	 ecx, WORD PTR [rax+2256]
  0146a	e8 00 00 00 00	 call	 _byteswap_ushort
  0146f	48 8b 8c 24 c8
	00 00 00	 mov	 rcx, QWORD PTR psa$8[rsp]
  01477	48 81 c1 96 00
	00 00		 add	 rcx, 150		; 00000096H
  0147e	0f b7 d0	 movzx	 edx, ax
  01481	e8 00 00 00 00	 call	 store_hw_noswap

; 1708 :             STORE_W(  psa->peradr, GUESTREGS->peradr );

  01486	48 8b 84 24 00
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0148e	48 8b 80 70 08
	00 00		 mov	 rax, QWORD PTR [rax+2160]
  01495	8b 88 d8 08 00
	00		 mov	 ecx, DWORD PTR [rax+2264]
  0149b	e8 00 00 00 00	 call	 _byteswap_ulong
  014a0	48 8b 8c 24 c8
	00 00 00	 mov	 rcx, QWORD PTR psa$8[rsp]
  014a8	48 81 c1 98 00
	00 00		 add	 rcx, 152		; 00000098H
  014af	8b d0		 mov	 edx, eax
  014b1	e8 00 00 00 00	 call	 store_fw_noswap
$LN116@s390_sie_e:

; 1709 :         }
; 1710 : 
; 1711 :         if (IS_IC_PER_IF( GUESTREGS ))

  014b6	48 8b 84 24 00
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  014be	48 8b 80 70 08
	00 00		 mov	 rax, QWORD PTR [rax+2160]
  014c5	8b 40 4c	 mov	 eax, DWORD PTR [rax+76]
  014c8	25 00 00 40 00	 and	 eax, 4194304		; 00400000H
  014cd	85 c0		 test	 eax, eax
  014cf	74 36		 je	 SHORT $LN119@s390_sie_e

; 1712 :             STATEBK->f |= SIE_F_IF;

  014d1	48 8b 84 24 00
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  014d9	48 8b 80 70 08
	00 00		 mov	 rax, QWORD PTR [rax+2160]
  014e0	48 8b 80 88 08
	00 00		 mov	 rax, QWORD PTR [rax+2184]
  014e7	0f b6 40 51	 movzx	 eax, BYTE PTR [rax+81]
  014eb	83 c8 02	 or	 eax, 2
  014ee	48 8b 8c 24 00
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  014f6	48 8b 89 70 08
	00 00		 mov	 rcx, QWORD PTR [rcx+2160]
  014fd	48 8b 89 88 08
	00 00		 mov	 rcx, QWORD PTR [rcx+2184]
  01504	88 41 51	 mov	 BYTE PTR [rcx+81], al
$LN119@s390_sie_e:
$LN59@s390_sie_e:

; 1713 : 
; 1714 :         /* Reset any pending PER indication */
; 1715 :         OFF_IC_PER( GUESTREGS );

  01507	48 8b 84 24 00
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0150f	48 8b 80 70 08
	00 00		 mov	 rax, QWORD PTR [rax+2160]
  01516	8b 40 4c	 mov	 eax, DWORD PTR [rax+76]
  01519	25 ff ff 00 ff	 and	 eax, -16711681		; ff00ffffH
  0151e	48 8b 8c 24 00
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  01526	48 8b 89 70 08
	00 00		 mov	 rcx, QWORD PTR [rcx+2160]
  0152d	89 41 4c	 mov	 DWORD PTR [rcx+76], eax
  01530	33 c0		 xor	 eax, eax
  01532	85 c0		 test	 eax, eax
  01534	75 d1		 jne	 SHORT $LN59@s390_sie_e

; 1716 : 
; 1717 : #endif /* defined( _FEATURE_PER ) */
; 1718 : 
; 1719 :         /* Backup to the previous instruction */
; 1720 :         GUESTREGS->ip -= REAL_ILC( GUESTREGS );

  01536	48 8b 84 24 00
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0153e	48 8b 80 70 08
	00 00		 mov	 rax, QWORD PTR [rax+2160]
  01545	8b 80 28 07 00
	00		 mov	 eax, DWORD PTR [rax+1832]
  0154b	83 e0 01	 and	 eax, 1
  0154e	85 c0		 test	 eax, eax
  01550	75 0d		 jne	 SHORT $LN160@s390_sie_e
  01552	c7 84 24 98 00
	00 00 01 00 00
	00		 mov	 DWORD PTR tv838[rsp], 1
  0155d	eb 0b		 jmp	 SHORT $LN161@s390_sie_e
$LN160@s390_sie_e:
  0155f	c7 84 24 98 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv838[rsp], 0
$LN161@s390_sie_e:
  0156a	83 bc 24 98 00
	00 00 00	 cmp	 DWORD PTR tv838[rsp], 0
  01572	74 0d		 je	 SHORT $LN164@s390_sie_e
  01574	c7 84 24 9c 00
	00 00 01 00 00
	00		 mov	 DWORD PTR tv846[rsp], 1
  0157f	eb 0b		 jmp	 SHORT $LN165@s390_sie_e
$LN164@s390_sie_e:
  01581	c7 84 24 9c 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv846[rsp], 0
$LN165@s390_sie_e:
  0158c	83 bc 24 9c 00
	00 00 00	 cmp	 DWORD PTR tv846[rsp], 0
  01594	74 1f		 je	 SHORT $LN168@s390_sie_e
  01596	48 8b 84 24 00
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0159e	48 8b 80 70 08
	00 00		 mov	 rax, QWORD PTR [rax+2160]
  015a5	0f b6 80 9a 00
	00 00		 movzx	 eax, BYTE PTR [rax+154]
  015ac	89 84 24 a4 00
	00 00		 mov	 DWORD PTR tv857[rsp], eax
  015b3	eb 44		 jmp	 SHORT $LN169@s390_sie_e
$LN168@s390_sie_e:
  015b5	48 8b 84 24 00
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  015bd	48 8b 80 70 08
	00 00		 mov	 rax, QWORD PTR [rax+2160]
  015c4	8b 80 28 07 00
	00		 mov	 eax, DWORD PTR [rax+1832]
  015ca	d1 e8		 shr	 eax, 1
  015cc	83 e0 01	 and	 eax, 1
  015cf	85 c0		 test	 eax, eax
  015d1	74 0d		 je	 SHORT $LN166@s390_sie_e
  015d3	c7 84 24 a0 00
	00 00 06 00 00
	00		 mov	 DWORD PTR tv855[rsp], 6
  015de	eb 0b		 jmp	 SHORT $LN167@s390_sie_e
$LN166@s390_sie_e:
  015e0	c7 84 24 a0 00
	00 00 04 00 00
	00		 mov	 DWORD PTR tv855[rsp], 4
$LN167@s390_sie_e:
  015eb	8b 84 24 a0 00
	00 00		 mov	 eax, DWORD PTR tv855[rsp]
  015f2	89 84 24 a4 00
	00 00		 mov	 DWORD PTR tv857[rsp], eax
$LN169@s390_sie_e:
  015f9	48 8b 84 24 00
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  01601	48 8b 80 70 08
	00 00		 mov	 rax, QWORD PTR [rax+2160]
  01608	48 63 8c 24 a4
	00 00 00	 movsxd	 rcx, DWORD PTR tv857[rsp]
  01610	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  01614	48 2b c1	 sub	 rax, rcx
  01617	48 8b 8c 24 00
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0161f	48 8b 89 70 08
	00 00		 mov	 rcx, QWORD PTR [rcx+2160]
  01626	48 89 41 68	 mov	 QWORD PTR [rcx+104], rax

; 1721 :         if (GUESTREGS->ip < GUESTREGS->aip)

  0162a	48 8b 84 24 00
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  01632	48 8b 80 70 08
	00 00		 mov	 rax, QWORD PTR [rax+2160]
  01639	48 8b 8c 24 00
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  01641	48 8b 89 70 08
	00 00		 mov	 rcx, QWORD PTR [rcx+2160]
  01648	48 8b 89 00 02
	00 00		 mov	 rcx, QWORD PTR [rcx+512]
  0164f	48 39 48 68	 cmp	 QWORD PTR [rax+104], rcx
  01653	73 28		 jae	 SHORT $LN120@s390_sie_e

; 1722 :             GUESTREGS->ip = GUESTREGS->inst;

  01655	48 8b 84 24 00
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0165d	48 8b 80 70 08
	00 00		 mov	 rax, QWORD PTR [rax+2160]
  01664	48 05 f1 08 00
	00		 add	 rax, 2289		; 000008f1H
  0166a	48 8b 8c 24 00
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  01672	48 8b 89 70 08
	00 00		 mov	 rcx, QWORD PTR [rcx+2160]
  01679	48 89 41 68	 mov	 QWORD PTR [rcx+104], rax
$LN120@s390_sie_e:

; 1723 : 
; 1724 : #if defined( FEATURE_035_EXECUTE_EXTN_FACILITY )
; 1725 :         if (FACILITY_ENABLED( 035_EXECUTE_EXTN, GUESTREGS ))
; 1726 :         {
; 1727 :             /* EXRL = Execute Relative Long instruction? */
; 1728 :             is_exrl =
; 1729 :             (1
; 1730 :                 &&   GUESTREGS->ip[0] == 0xc6
; 1731 :                 && !(GUESTREGS->ip[1] &  0x0f)
; 1732 :             );
; 1733 :         }
; 1734 : #endif
; 1735 :         /* Update interception parameters in the state descriptor */
; 1736 :         if (GUESTREGS->ip[0] == 0x44 || is_exrl)

  0167d	48 8b 84 24 00
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  01685	48 8b 80 70 08
	00 00		 mov	 rax, QWORD PTR [rax+2160]
  0168c	b9 01 00 00 00	 mov	 ecx, 1
  01691	48 6b c9 00	 imul	 rcx, rcx, 0
  01695	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  01699	0f b6 04 08	 movzx	 eax, BYTE PTR [rax+rcx]
  0169d	83 f8 44	 cmp	 eax, 68			; 00000044H
  016a0	74 0d		 je	 SHORT $LN123@s390_sie_e
  016a2	0f b6 44 24 44	 movzx	 eax, BYTE PTR is_exrl$[rsp]
  016a7	85 c0		 test	 eax, eax
  016a9	0f 84 0b 01 00
	00		 je	 $LN121@s390_sie_e
$LN123@s390_sie_e:

; 1737 :         {
; 1738 :             int ilc;
; 1739 :             STATEBK->f |= SIE_F_EX;

  016af	48 8b 84 24 00
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  016b7	48 8b 80 70 08
	00 00		 mov	 rax, QWORD PTR [rax+2160]
  016be	48 8b 80 88 08
	00 00		 mov	 rax, QWORD PTR [rax+2184]
  016c5	0f b6 40 51	 movzx	 eax, BYTE PTR [rax+81]
  016c9	83 c8 01	 or	 eax, 1
  016cc	48 8b 8c 24 00
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  016d4	48 8b 89 70 08
	00 00		 mov	 rcx, QWORD PTR [rcx+2160]
  016db	48 8b 89 88 08
	00 00		 mov	 rcx, QWORD PTR [rcx+2184]
  016e2	88 41 51	 mov	 BYTE PTR [rcx+81], al

; 1740 :             ilc = ILC( GUESTREGS->exinst[0] );

  016e5	48 8b 84 24 00
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  016ed	48 8b 80 70 08
	00 00		 mov	 rax, QWORD PTR [rax+2160]
  016f4	b9 01 00 00 00	 mov	 ecx, 1
  016f9	48 6b c9 00	 imul	 rcx, rcx, 0
  016fd	0f b6 84 08 40
	08 00 00	 movzx	 eax, BYTE PTR [rax+rcx+2112]
  01705	83 f8 40	 cmp	 eax, 64			; 00000040H
  01708	7d 0d		 jge	 SHORT $LN172@s390_sie_e
  0170a	c7 84 24 ac 00
	00 00 02 00 00
	00		 mov	 DWORD PTR tv901[rsp], 2
  01715	eb 4d		 jmp	 SHORT $LN173@s390_sie_e
$LN172@s390_sie_e:
  01717	48 8b 84 24 00
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0171f	48 8b 80 70 08
	00 00		 mov	 rax, QWORD PTR [rax+2160]
  01726	b9 01 00 00 00	 mov	 ecx, 1
  0172b	48 6b c9 00	 imul	 rcx, rcx, 0
  0172f	0f b6 84 08 40
	08 00 00	 movzx	 eax, BYTE PTR [rax+rcx+2112]
  01737	3d c0 00 00 00	 cmp	 eax, 192		; 000000c0H
  0173c	7d 0d		 jge	 SHORT $LN170@s390_sie_e
  0173e	c7 84 24 a8 00
	00 00 04 00 00
	00		 mov	 DWORD PTR tv900[rsp], 4
  01749	eb 0b		 jmp	 SHORT $LN171@s390_sie_e
$LN170@s390_sie_e:
  0174b	c7 84 24 a8 00
	00 00 06 00 00
	00		 mov	 DWORD PTR tv900[rsp], 6
$LN171@s390_sie_e:
  01756	8b 84 24 a8 00
	00 00		 mov	 eax, DWORD PTR tv900[rsp]
  0175d	89 84 24 ac 00
	00 00		 mov	 DWORD PTR tv901[rsp], eax
$LN173@s390_sie_e:
  01764	8b 84 24 ac 00
	00 00		 mov	 eax, DWORD PTR tv901[rsp]
  0176b	89 84 24 bc 00
	00 00		 mov	 DWORD PTR ilc$6[rsp], eax

; 1741 : #if defined( FEATURE_035_EXECUTE_EXTN_FACILITY )
; 1742 :             if (is_exrl)
; 1743 :                 STATEBK->f |= (ilc << 4) & SIE_F_EXL;
; 1744 : #endif
; 1745 :             memcpy( STATEBK->ipa, GUESTREGS->exinst, ilc );

  01772	48 63 84 24 bc
	00 00 00	 movsxd	 rax, DWORD PTR ilc$6[rsp]
  0177a	48 8b 8c 24 00
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  01782	48 8b 89 70 08
	00 00		 mov	 rcx, QWORD PTR [rcx+2160]
  01789	48 81 c1 40 08
	00 00		 add	 rcx, 2112		; 00000840H
  01790	48 8b 94 24 00
	01 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  01798	48 8b 92 70 08
	00 00		 mov	 rdx, QWORD PTR [rdx+2160]
  0179f	48 8b 92 88 08
	00 00		 mov	 rdx, QWORD PTR [rdx+2184]
  017a6	48 83 c2 56	 add	 rdx, 86			; 00000056H
  017aa	48 8b fa	 mov	 rdi, rdx
  017ad	48 8b f1	 mov	 rsi, rcx
  017b0	48 8b c8	 mov	 rcx, rax
  017b3	f3 a4		 rep movsb

; 1746 :         }

  017b5	e9 df 00 00 00	 jmp	 $LN122@s390_sie_e
$LN121@s390_sie_e:

; 1747 :         else
; 1748 :         {
; 1749 :             if (!GUESTREGS->instinvalid)

  017ba	48 8b 84 24 00
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  017c2	48 8b 80 70 08
	00 00		 mov	 rax, QWORD PTR [rax+2160]
  017c9	8b 80 28 07 00
	00		 mov	 eax, DWORD PTR [rax+1832]
  017cf	c1 e8 03	 shr	 eax, 3
  017d2	83 e0 01	 and	 eax, 1
  017d5	85 c0		 test	 eax, eax
  017d7	0f 85 bc 00 00
	00		 jne	 $LN124@s390_sie_e

; 1750 :                 memcpy( STATEBK->ipa, GUESTREGS->ip, ILC( GUESTREGS->ip[0] ));

  017dd	48 8b 84 24 00
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  017e5	48 8b 80 70 08
	00 00		 mov	 rax, QWORD PTR [rax+2160]
  017ec	b9 01 00 00 00	 mov	 ecx, 1
  017f1	48 6b c9 00	 imul	 rcx, rcx, 0
  017f5	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  017f9	0f b6 04 08	 movzx	 eax, BYTE PTR [rax+rcx]
  017fd	83 f8 40	 cmp	 eax, 64			; 00000040H
  01800	7d 0d		 jge	 SHORT $LN176@s390_sie_e
  01802	c7 84 24 b4 00
	00 00 02 00 00
	00		 mov	 DWORD PTR tv934[rsp], 2
  0180d	eb 4d		 jmp	 SHORT $LN177@s390_sie_e
$LN176@s390_sie_e:
  0180f	48 8b 84 24 00
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  01817	48 8b 80 70 08
	00 00		 mov	 rax, QWORD PTR [rax+2160]
  0181e	b9 01 00 00 00	 mov	 ecx, 1
  01823	48 6b c9 00	 imul	 rcx, rcx, 0
  01827	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  0182b	0f b6 04 08	 movzx	 eax, BYTE PTR [rax+rcx]
  0182f	3d c0 00 00 00	 cmp	 eax, 192		; 000000c0H
  01834	7d 0d		 jge	 SHORT $LN174@s390_sie_e
  01836	c7 84 24 b0 00
	00 00 04 00 00
	00		 mov	 DWORD PTR tv933[rsp], 4
  01841	eb 0b		 jmp	 SHORT $LN175@s390_sie_e
$LN174@s390_sie_e:
  01843	c7 84 24 b0 00
	00 00 06 00 00
	00		 mov	 DWORD PTR tv933[rsp], 6
$LN175@s390_sie_e:
  0184e	8b 84 24 b0 00
	00 00		 mov	 eax, DWORD PTR tv933[rsp]
  01855	89 84 24 b4 00
	00 00		 mov	 DWORD PTR tv934[rsp], eax
$LN177@s390_sie_e:
  0185c	48 63 84 24 b4
	00 00 00	 movsxd	 rax, DWORD PTR tv934[rsp]
  01864	48 8b 8c 24 00
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0186c	48 8b 89 70 08
	00 00		 mov	 rcx, QWORD PTR [rcx+2160]
  01873	48 8b 94 24 00
	01 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  0187b	48 8b 92 70 08
	00 00		 mov	 rdx, QWORD PTR [rdx+2160]
  01882	48 8b 92 88 08
	00 00		 mov	 rdx, QWORD PTR [rdx+2184]
  01889	48 83 c2 56	 add	 rdx, 86			; 00000056H
  0188d	48 8b fa	 mov	 rdi, rdx
  01890	48 8b 71 68	 mov	 rsi, QWORD PTR [rcx+104]
  01894	48 8b c8	 mov	 rcx, rax
  01897	f3 a4		 rep movsb
$LN124@s390_sie_e:
$LN122@s390_sie_e:
$LN114@s390_sie_e:
$LN62@s390_sie_e:

; 1751 :         }
; 1752 :     }
; 1753 : 
; 1754 :     PTT_SIE( "sie_xit ret", 0, 0, 0  );

  01899	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_pttclass
  018a0	48 8b 00	 mov	 rax, QWORD PTR [rax]
  018a3	48 25 80 00 00
	00		 and	 rax, 128		; 00000080H
  018a9	48 85 c0	 test	 rax, rax
  018ac	74 36		 je	 SHORT $LN125@s390_sie_e
  018ae	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR [rsp+48], 0
  018b7	48 c7 44 24 28
	00 00 00 00	 mov	 QWORD PTR [rsp+40], 0
  018c0	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG181253
  018c7	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  018cc	45 33 c9	 xor	 r9d, r9d
  018cf	45 33 c0	 xor	 r8d, r8d
  018d2	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG181254
  018d9	b9 80 00 00 00	 mov	 ecx, 128		; 00000080H
  018de	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ptt_pthread_trace
$LN125@s390_sie_e:
  018e4	33 c0		 xor	 eax, eax
  018e6	85 c0		 test	 eax, eax
  018e8	75 af		 jne	 SHORT $LN62@s390_sie_e

; 1755 : 
; 1756 : } /* end function sie_exit */

  018ea	48 81 c4 e8 00
	00 00		 add	 rsp, 232		; 000000e8H
  018f1	5f		 pop	 rdi
  018f2	5e		 pop	 rsi
  018f3	c3		 ret	 0
$LN178@s390_sie_e:
  018f4	00 00 00 00	 DD	 $LN91@s390_sie_e
  018f8	00 00 00 00	 DD	 $LN90@s390_sie_e
  018fc	00 00 00 00	 DD	 $LN89@s390_sie_e
  01900	00 00 00 00	 DD	 $LN81@s390_sie_e
  01904	00 00 00 00	 DD	 $LN88@s390_sie_e
  01908	00 00 00 00	 DD	 $LN87@s390_sie_e
  0190c	00 00 00 00	 DD	 $LN93@s390_sie_e
  01910	00 00 00 00	 DD	 $LN93@s390_sie_e
  01914	00 00 00 00	 DD	 $LN84@s390_sie_e
  01918	00 00 00 00	 DD	 $LN83@s390_sie_e
  0191c	00 00 00 00	 DD	 $LN85@s390_sie_e
  01920	00 00 00 00	 DD	 $LN86@s390_sie_e
  01924	00 00 00 00	 DD	 $LN82@s390_sie_e
  01928	00 00 00 00	 DD	 $LN80@s390_sie_e
  0192c	00 00 00 00	 DD	 $LN79@s390_sie_e
  01930	00 00 00 00	 DD	 $LN74@s390_sie_e
  01934	00 00 00 00	 DD	 $LN93@s390_sie_e
  01938	00 00 00 00	 DD	 $LN93@s390_sie_e
  0193c	00 00 00 00	 DD	 $LN92@s390_sie_e
s390_sie_exit ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\sie.c
_TEXT	SEGMENT
i$1 = 80
i$ = 84
icode$ = 88
oldmode$2 = 92
ip$ = 96
tv404 = 104
current_opcode_table$ = 112
tv373 = 120
tv397 = 124
tv379 = 128
tv542 = 132
tv632 = 136
inst_cr$3 = 140
tv669 = 144
tv782 = 148
tv899 = 152
now$4 = 160
tv640 = 168
tv671 = 176
tv1576 = 184
tv1572 = 192
tv784 = 200
tv1559 = 208
tv1554 = 216
tv901 = 224
tv1505 = 232
tv1481 = 240
waittime$5 = 248
__$ArrayPad$ = 264
regs$ = 288
z900_run_sie PROC

; 947  : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 81 ec 18 01
	00 00		 sub	 rsp, 280		; 00000118H
  0000c	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00013	48 33 c4	 xor	 rax, rsp
  00016	48 89 84 24 08
	01 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax
$LN4@z900_run_s:

; 948  :     BYTE*  ip;      /* instruction pointer        */
; 949  :     int    icode;   /* SIE longjmp intercept code */
; 950  :     int    i;
; 951  :     const INSTR_FUNC*  current_opcode_table;
; 952  : 
; 953  :     //---------------------------------------------------------
; 954  :     //              CRITICAL SIE PROGRAMMING NOTE!
; 955  :     //---------------------------------------------------------
; 956  :     //
; 957  :     //  Our 'regs' variable always points the HOST's regs (i.e.
; 958  :     //  regs == HOSTREGS && regs->host is always true), even though
; 959  :     //  we are actually RUNNING (executing) in GUEST architecture
; 960  :     //  mode!!
; 961  :     //
; 962  :     //  That is to say, if the host is, for example, z900 (z/VM)
; 963  :     //  but the guest it wants to execute is a 390 guest, the above
; 964  :     //  "start_interpretive_execution" instruction function calls
; 965  :     //  the "s390_run_sie" function (because it wants to execute
; 966  :     //  the guest in 390 mode), but it passed its own HOST regs to
; 967  :     //  this function!
; 968  :     //
; 969  :     //  So even though our function's build architecture is 390
; 970  :     //  (i.e. even though our function's build architecture is that
; 971  :     //  of the GUEST's), our 'regs' pointer is nevertheless still
; 972  :     //  pointing to the z/VM HOST's registers!! GUESTREGS must be
; 973  :     //  used to access the GUEST's register context!!
; 974  :     //
; 975  :     //  What this means is that SPECIAL CARE must be taken when
; 976  :     //  invoking macros or calling functions on behalf of the HOST
; 977  :     //  (i.e. when using 'regs' or HOSTREGS instead of GUESTREGS)
; 978  :     //  since many of our macros and functions are architecture
; 979  :     //  dependent, relying on the regs they were called with to
; 980  :     //  always match that of the current build architecture, which,
; 981  :     //  as explained, is NOT necessarily always true in our case!!
; 982  :     //
; 983  :     //---------------------------------------------------------
; 984  : 
; 985  :     //-----------------------------------------------------------
; 986  :     //               IMPORTANT SIE PROGRAMMING NOTE!
; 987  :     //-----------------------------------------------------------
; 988  :     // NOTE: Our execution architectural mode is that of the SIE
; 989  :     // GUEST, not the HOST! If you need to call a function on
; 990  :     // behalf of the HOST (passing it 'regs'), you must be careful
; 991  :     // to ensure the correct version of that function is called!
; 992  :     // You cannot simply call the "ARCH_DEP" version of a function
; 993  :     // as they are for the architectue of the GUEST, not the HOST!
; 994  :     // (e.g. you cannot call a "s390_xxxx" function expecting it
; 995  :     // to work correctly if the HOST function that SHOULD have been
; 996  :     // called should have been "z900_xxxx"!) YOU HAVE BEEN WARNED!
; 997  :     //-----------------------------------------------------------
; 998  : 
; 999  :     PTT_SIE( "run_sie h,g,a", regs->host, regs->guest, regs->sie_active );

  0001e	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_pttclass
  00025	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00028	48 25 80 00 00
	00		 and	 rax, 128		; 00000080H
  0002e	48 85 c0	 test	 rax, rax
  00031	74 71		 je	 SHORT $LN150@z900_run_s
  00033	48 8b 84 24 20
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0003b	8b 80 c8 08 00
	00		 mov	 eax, DWORD PTR [rax+2248]
  00041	83 e0 01	 and	 eax, 1
  00044	8b c0		 mov	 eax, eax
  00046	48 8b 8c 24 20
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0004e	8b 89 28 07 00
	00		 mov	 ecx, DWORD PTR [rcx+1832]
  00054	c1 e9 08	 shr	 ecx, 8
  00057	83 e1 01	 and	 ecx, 1
  0005a	8b c9		 mov	 ecx, ecx
  0005c	48 8b 94 24 20
	01 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  00064	8b 92 28 07 00
	00		 mov	 edx, DWORD PTR [rdx+1832]
  0006a	c1 ea 07	 shr	 edx, 7
  0006d	83 e2 01	 and	 edx, 1
  00070	8b d2		 mov	 edx, edx
  00072	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR [rsp+48], 0
  0007b	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  00080	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG195261
  00087	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  0008c	44 8b c9	 mov	 r9d, ecx
  0008f	44 8b c2	 mov	 r8d, edx
  00092	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG195262
  00099	b9 80 00 00 00	 mov	 ecx, 128		; 00000080H
  0009e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ptt_pthread_trace
$LN150@z900_run_s:
  000a4	33 c0		 xor	 eax, eax
  000a6	85 c0		 test	 eax, eax
  000a8	0f 85 70 ff ff
	ff		 jne	 $LN4@z900_run_s
$LN7@z900_run_s:

; 1000 : 
; 1001 :     SIE_PERFMON( SIE_PERF_RUNSIE );
; 1002 : 
; 1003 : #if defined( _FEATURE_PER )
; 1004 :     /* Reset any PER pending indication */
; 1005 :     OFF_IC_PER( GUESTREGS );

  000ae	48 8b 84 24 20
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  000b6	48 8b 80 70 08
	00 00		 mov	 rax, QWORD PTR [rax+2160]
  000bd	8b 40 4c	 mov	 eax, DWORD PTR [rax+76]
  000c0	25 ff ff 00 ff	 and	 eax, -16711681		; ff00ffffH
  000c5	48 8b 8c 24 20
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  000cd	48 8b 89 70 08
	00 00		 mov	 rcx, QWORD PTR [rcx+2160]
  000d4	89 41 4c	 mov	 DWORD PTR [rcx+76], eax
  000d7	33 c0		 xor	 eax, eax
  000d9	85 c0		 test	 eax, eax
  000db	75 d1		 jne	 SHORT $LN7@z900_run_s
$LN257@z900_run_s:
$LN10@z900_run_s:
$LN13@z900_run_s:

; 1006 : #endif
; 1007 : 
; 1008 : #ifdef FEATURE_INTERVAL_TIMER
; 1009 :     /* Load the shadow interval timer */
; 1010 :     {
; 1011 :         S32 itimer;
; 1012 :         FETCH_FW( itimer, GUESTREGS->psa->inttimer );
; 1013 :         set_int_timer( GUESTREGS, itimer );
; 1014 :     }
; 1015 : #endif
; 1016 : 
; 1017 :     do
; 1018 :     {
; 1019 :         SIE_PERFMON( SIE_PERF_RUNLOOP_1 );
; 1020 : 
; 1021 :         PTT_SIE( "run_sie setjmp", 0, 0, 0 );

  000dd	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_pttclass
  000e4	48 8b 00	 mov	 rax, QWORD PTR [rax]
  000e7	48 25 80 00 00
	00		 and	 rax, 128		; 00000080H
  000ed	48 85 c0	 test	 rax, rax
  000f0	74 36		 je	 SHORT $LN151@z900_run_s
  000f2	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR [rsp+48], 0
  000fb	48 c7 44 24 28
	00 00 00 00	 mov	 QWORD PTR [rsp+40], 0
  00104	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG195264
  0010b	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00110	45 33 c9	 xor	 r9d, r9d
  00113	45 33 c0	 xor	 r8d, r8d
  00116	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG195265
  0011d	b9 80 00 00 00	 mov	 ecx, 128		; 00000080H
  00122	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ptt_pthread_trace
$LN151@z900_run_s:
  00128	33 c0		 xor	 eax, eax
  0012a	85 c0		 test	 eax, eax
  0012c	75 af		 jne	 SHORT $LN13@z900_run_s

; 1022 : 
; 1023 :         /* Establish longjmp destination for program check or
; 1024 :            RETURN_INTCHECK, or SIE_INTERCEPT, or longjmp, etc.
; 1025 :         */
; 1026 :         if (!(icode = setjmp( GUESTREGS->progjmp )))

  0012e	48 8b 84 24 20
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00136	48 8b 80 70 08
	00 00		 mov	 rax, QWORD PTR [rax+2160]
  0013d	48 05 80 09 00
	00		 add	 rax, 2432		; 00000980H
  00143	48 8b c8	 mov	 rcx, rax
  00146	48 8b d4	 mov	 rdx, rsp
  00149	e8 00 00 00 00	 call	 _setjmp
  0014e	89 44 24 58	 mov	 DWORD PTR icode$[rsp], eax
  00152	83 7c 24 58 00	 cmp	 DWORD PTR icode$[rsp], 0
  00157	0f 85 eb 22 00
	00		 jne	 $LN152@z900_run_s
$LN16@z900_run_s:

; 1027 :         {
; 1028 :             PTT_SIE( "run_sie run...", 0, 0, 0 );

  0015d	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_pttclass
  00164	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00167	48 25 80 00 00
	00		 and	 rax, 128		; 00000080H
  0016d	48 85 c0	 test	 rax, rax
  00170	74 36		 je	 SHORT $LN154@z900_run_s
  00172	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR [rsp+48], 0
  0017b	48 c7 44 24 28
	00 00 00 00	 mov	 QWORD PTR [rsp+40], 0
  00184	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG195269
  0018b	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00190	45 33 c9	 xor	 r9d, r9d
  00193	45 33 c0	 xor	 r8d, r8d
  00196	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG195270
  0019d	b9 80 00 00 00	 mov	 ecx, 128		; 00000080H
  001a2	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ptt_pthread_trace
$LN154@z900_run_s:
  001a8	33 c0		 xor	 eax, eax
  001aa	85 c0		 test	 eax, eax
  001ac	75 af		 jne	 SHORT $LN16@z900_run_s
$LN259@z900_run_s:
$LN258@z900_run_s:
$LN19@z900_run_s:

; 1029 :             do
; 1030 :             {
; 1031 :                 SIE_PERFMON( SIE_PERF_RUNLOOP_2 );
; 1032 : 
; 1033 :                 /* Set `execflag' to 0 in case EXecuted instruction did progjmp */
; 1034 :                 GUESTREGS->execflag = 0;

  001ae	48 8b 84 24 20
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  001b6	48 8b 80 70 08
	00 00		 mov	 rax, QWORD PTR [rax+2160]
  001bd	8b 80 28 07 00
	00		 mov	 eax, DWORD PTR [rax+1832]
  001c3	83 e0 fe	 and	 eax, -2			; fffffffeH
  001c6	48 8b 8c 24 20
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  001ce	48 8b 89 70 08
	00 00		 mov	 rcx, QWORD PTR [rcx+2160]
  001d5	89 81 28 07 00
	00		 mov	 DWORD PTR [rcx+1832], eax

; 1035 : 
; 1036 :                 /* Exit from SIE mode when either asked or
; 1037 :                    if External or I/O Interrupt is pending
; 1038 :                 */
; 1039 :                 if (1
; 1040 : #if defined( FEATURE_073_TRANSACT_EXEC_FACILITY )
; 1041 :                     /* Don't interrupt active transaction */
; 1042 :                     && (0
; 1043 :                         || GUESTREGS->txf_tnd == 0
; 1044 :                         || GUESTREGS->txf_PPA < PPA_MUCH_HELP_THRESHOLD
; 1045 :                        )
; 1046 : #endif
; 1047 :                     && (0

  001db	33 c0		 xor	 eax, eax
  001dd	83 f8 01	 cmp	 eax, 1
  001e0	0f 84 df 00 00
	00		 je	 $LN155@z900_run_s
  001e6	33 c0		 xor	 eax, eax
  001e8	85 c0		 test	 eax, eax
  001ea	75 36		 jne	 SHORT $LN156@z900_run_s
  001ec	48 8b 84 24 20
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  001f4	48 8b 80 70 08
	00 00		 mov	 rax, QWORD PTR [rax+2160]
  001fb	0f b6 80 58 0e
	00 00		 movzx	 eax, BYTE PTR [rax+3672]
  00202	85 c0		 test	 eax, eax
  00204	74 1c		 je	 SHORT $LN156@z900_run_s
  00206	48 8b 84 24 20
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0020e	48 8b 80 70 08
	00 00		 mov	 rax, QWORD PTR [rax+2160]
  00215	83 b8 54 0e 00
	00 02		 cmp	 DWORD PTR [rax+3668], 2
  0021c	0f 8d a3 00 00
	00		 jge	 $LN155@z900_run_s
$LN156@z900_run_s:
  00222	33 c0		 xor	 eax, eax
  00224	85 c0		 test	 eax, eax
  00226	0f 85 94 00 00
	00		 jne	 $LN157@z900_run_s
  0022c	48 8b 84 24 20
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00234	48 8b 80 70 08
	00 00		 mov	 rax, QWORD PTR [rax+2160]
  0023b	48 8b 80 88 08
	00 00		 mov	 rax, QWORD PTR [rax+2184]
  00242	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  00245	83 e0 04	 and	 eax, 4
  00248	85 c0		 test	 eax, eax
  0024a	75 74		 jne	 SHORT $LN157@z900_run_s
  0024c	48 8b 84 24 20
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00254	48 8b 80 70 08
	00 00		 mov	 rax, QWORD PTR [rax+2160]
  0025b	48 8b 80 88 08
	00 00		 mov	 rax, QWORD PTR [rax+2184]
  00262	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  00265	83 e0 01	 and	 eax, 1
  00268	85 c0		 test	 eax, eax
  0026a	74 1a		 je	 SHORT $LN158@z900_run_s
  0026c	48 8b 84 24 20
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00274	48 8b 80 70 08
	00 00		 mov	 rax, QWORD PTR [rax+2160]
  0027b	0f b6 40 78	 movzx	 eax, BYTE PTR [rax+120]
  0027f	83 e0 01	 and	 eax, 1
  00282	85 c0		 test	 eax, eax
  00284	75 3a		 jne	 SHORT $LN157@z900_run_s
$LN158@z900_run_s:
  00286	48 8b 84 24 20
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0028e	48 8b 80 70 08
	00 00		 mov	 rax, QWORD PTR [rax+2160]
  00295	48 8b 80 88 08
	00 00		 mov	 rax, QWORD PTR [rax+2184]
  0029c	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  0029f	83 e0 02	 and	 eax, 2
  002a2	85 c0		 test	 eax, eax
  002a4	74 1f		 je	 SHORT $LN155@z900_run_s
  002a6	48 8b 84 24 20
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  002ae	48 8b 80 70 08
	00 00		 mov	 rax, QWORD PTR [rax+2160]
  002b5	0f b6 40 78	 movzx	 eax, BYTE PTR [rax+120]
  002b9	83 e0 02	 and	 eax, 2
  002bc	85 c0		 test	 eax, eax
  002be	74 05		 je	 SHORT $LN155@z900_run_s
$LN157@z900_run_s:

; 1048 :                         || SIE_I_STOP ( GUESTREGS )
; 1049 :                         || SIE_I_EXT  ( GUESTREGS )
; 1050 :                         || SIE_I_IO   ( GUESTREGS )
; 1051 :                        )
; 1052 :                 )
; 1053 :                     break;

  002c0	e9 81 21 00 00	 jmp	 $LN18@z900_run_s
$LN155@z900_run_s:

; 1054 : 
; 1055 :                 if (SIE_IC_INTERRUPT_CPU( GUESTREGS ))

  002c5	48 8b 84 24 20
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  002cd	48 8b 80 70 08
	00 00		 mov	 rax, QWORD PTR [rax+2160]
  002d4	48 8b 8c 24 20
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  002dc	48 8b 89 70 08
	00 00		 mov	 rcx, QWORD PTR [rcx+2160]
  002e3	48 8b 89 68 08
	00 00		 mov	 rcx, QWORD PTR [rcx+2152]
  002ea	8b 49 48	 mov	 ecx, DWORD PTR [rcx+72]
  002ed	81 e1 80 0c 00
	40		 and	 ecx, 1073745024		; 40000c80H
  002f3	8b 40 48	 mov	 eax, DWORD PTR [rax+72]
  002f6	0b c1		 or	 eax, ecx
  002f8	48 8b 8c 24 20
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00300	48 8b 89 70 08
	00 00		 mov	 rcx, QWORD PTR [rcx+2160]
  00307	23 41 4c	 and	 eax, DWORD PTR [rcx+76]
  0030a	85 c0		 test	 eax, eax
  0030c	0f 84 41 0c 00
	00		 je	 $LN159@z900_run_s

; 1056 :                 {
; 1057 :                     SIE_PERFMON( SIE_PERF_INTCHECK );
; 1058 : 
; 1059 :                     /* Process PER program interrupts */
; 1060 :                     if (OPEN_IC_PER( GUESTREGS ))

  00312	48 8b 84 24 20
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0031a	48 8b 80 70 08
	00 00		 mov	 rax, QWORD PTR [rax+2160]
  00321	48 8b 8c 24 20
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00329	48 8b 89 70 08
	00 00		 mov	 rcx, QWORD PTR [rcx+2160]
  00330	8b 49 4c	 mov	 ecx, DWORD PTR [rcx+76]
  00333	8b 40 48	 mov	 eax, DWORD PTR [rax+72]
  00336	23 c1		 and	 eax, ecx
  00338	25 00 00 ff 00	 and	 eax, 16711680		; 00ff0000H
  0033d	85 c0		 test	 eax, eax
  0033f	74 19		 je	 SHORT $LN160@z900_run_s

; 1061 :                         ARCH_DEP( program_interrupt )( GUESTREGS, PGM_PER_EVENT );

  00341	ba 80 00 00 00	 mov	 edx, 128		; 00000080H
  00346	48 8b 84 24 20
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0034e	48 8b 88 70 08
	00 00		 mov	 rcx, QWORD PTR [rax+2160]
  00355	e8 00 00 00 00	 call	 z900_program_interrupt
$LN160@z900_run_s:

; 1062 : 
; 1063 :                     OBTAIN_INTLOCK( regs );

  0035a	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG195277
  00361	48 8b 8c 24 20
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00369	e8 00 00 00 00	 call	 Obtain_Interrupt_Lock
$LN22@z900_run_s:

; 1064 :                     OFF_IC_INTERRUPT( GUESTREGS );

  0036e	48 8b 84 24 20
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00376	48 8b 80 70 08
	00 00		 mov	 rax, QWORD PTR [rax+2160]
  0037d	8b 40 48	 mov	 eax, DWORD PTR [rax+72]
  00380	0f ba f0 1f	 btr	 eax, 31
  00384	48 8b 8c 24 20
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0038c	48 8b 89 70 08
	00 00		 mov	 rcx, QWORD PTR [rcx+2160]
  00393	89 41 48	 mov	 DWORD PTR [rcx+72], eax
  00396	33 c0		 xor	 eax, eax
  00398	85 c0		 test	 eax, eax
  0039a	75 d2		 jne	 SHORT $LN22@z900_run_s
$LN25@z900_run_s:

; 1065 : 
; 1066 :                     /* Set psw.IA and invalidate the aia */
; 1067 :                     INVALIDATE_AIA( GUESTREGS );

  0039c	48 8b 84 24 20
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  003a4	48 8b 80 70 08
	00 00		 mov	 rax, QWORD PTR [rax+2160]
  003ab	48 83 b8 08 02
	00 00 00	 cmp	 QWORD PTR [rax+520], 0
  003b3	0f 84 8b 00 00
	00		 je	 $LN161@z900_run_s
  003b9	48 8b 84 24 20
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  003c1	48 8b 80 70 08
	00 00		 mov	 rax, QWORD PTR [rax+2160]
  003c8	48 8b 8c 24 20
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  003d0	48 8b 89 70 08
	00 00		 mov	 rcx, QWORD PTR [rcx+2160]
  003d7	48 8b 94 24 20
	01 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  003df	48 8b 92 70 08
	00 00		 mov	 rdx, QWORD PTR [rdx+2160]
  003e6	48 8b 92 00 02
	00 00		 mov	 rdx, QWORD PTR [rdx+512]
  003ed	48 8b 49 68	 mov	 rcx, QWORD PTR [rcx+104]
  003f1	48 2b ca	 sub	 rcx, rdx
  003f4	48 8b 80 10 02
	00 00		 mov	 rax, QWORD PTR [rax+528]
  003fb	48 03 c1	 add	 rax, rcx
  003fe	48 8b 8c 24 20
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00406	48 8b 89 70 08
	00 00		 mov	 rcx, QWORD PTR [rcx+2160]
  0040d	48 23 81 90 00
	00 00		 and	 rax, QWORD PTR [rcx+144]
  00414	48 8b 8c 24 20
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0041c	48 8b 89 70 08
	00 00		 mov	 rcx, QWORD PTR [rcx+2160]
  00423	48 89 81 88 00
	00 00		 mov	 QWORD PTR [rcx+136], rax
  0042a	48 8b 84 24 20
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00432	48 8b 80 70 08
	00 00		 mov	 rax, QWORD PTR [rax+2160]
  00439	48 c7 80 08 02
	00 00 00 00 00
	00		 mov	 QWORD PTR [rax+520], 0
$LN161@z900_run_s:
  00444	33 c0		 xor	 eax, eax
  00446	85 c0		 test	 eax, eax
  00448	0f 85 4e ff ff
	ff		 jne	 $LN25@z900_run_s

; 1068 : 
; 1069 :                     /* Process External Interrupt if one is pending */
; 1070 :                     if (1
; 1071 :                         && OPEN_IC_EXTPENDING( GUESTREGS )
; 1072 : #if defined( FEATURE_073_TRANSACT_EXEC_FACILITY )
; 1073 :                         /* Don't interrupt active transaction */
; 1074 :                         && (0

  0044e	33 c0		 xor	 eax, eax
  00450	83 f8 01	 cmp	 eax, 1
  00453	74 7b		 je	 SHORT $LN162@z900_run_s
  00455	48 8b 84 24 20
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0045d	48 8b 80 70 08
	00 00		 mov	 rax, QWORD PTR [rax+2160]
  00464	48 8b 8c 24 20
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0046c	48 8b 89 70 08
	00 00		 mov	 rcx, QWORD PTR [rcx+2160]
  00473	8b 49 4c	 mov	 ecx, DWORD PTR [rcx+76]
  00476	8b 40 48	 mov	 eax, DWORD PTR [rax+72]
  00479	23 c1		 and	 eax, ecx
  0047b	25 f0 ff 00 00	 and	 eax, 65520		; 0000fff0H
  00480	85 c0		 test	 eax, eax
  00482	74 4c		 je	 SHORT $LN162@z900_run_s
  00484	33 c0		 xor	 eax, eax
  00486	85 c0		 test	 eax, eax
  00488	75 32		 jne	 SHORT $LN163@z900_run_s
  0048a	48 8b 84 24 20
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00492	48 8b 80 70 08
	00 00		 mov	 rax, QWORD PTR [rax+2160]
  00499	0f b6 80 58 0e
	00 00		 movzx	 eax, BYTE PTR [rax+3672]
  004a0	85 c0		 test	 eax, eax
  004a2	74 18		 je	 SHORT $LN163@z900_run_s
  004a4	48 8b 84 24 20
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  004ac	48 8b 80 70 08
	00 00		 mov	 rax, QWORD PTR [rax+2160]
  004b3	83 b8 54 0e 00
	00 02		 cmp	 DWORD PTR [rax+3668], 2
  004ba	7d 14		 jge	 SHORT $LN162@z900_run_s
$LN163@z900_run_s:

; 1075 :                             || GUESTREGS->txf_tnd == 0
; 1076 :                             || GUESTREGS->txf_PPA < PPA_MUCH_HELP_THRESHOLD
; 1077 :                            )
; 1078 : #endif
; 1079 :                     )
; 1080 :                         ARCH_DEP( perform_external_interrupt )( GUESTREGS );

  004bc	48 8b 84 24 20
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  004c4	48 8b 88 70 08
	00 00		 mov	 rcx, QWORD PTR [rax+2160]
  004cb	e8 00 00 00 00	 call	 z900_perform_external_interrupt
$LN162@z900_run_s:

; 1081 : 
; 1082 :                     /* Process I/O Interrupt if either I/O or SIGA Assist is enabled
; 1083 :                        and an I/O Interrupt is pending.
; 1084 :                     */
; 1085 :                     if (1
; 1086 :                         && (0
; 1087 :                             || (STATEBK->ec[0] & SIE_EC0_IOA)
; 1088 :                             || (STATEBK->ec[3] & SIE_EC3_SIGA)
; 1089 :                            )
; 1090 :                         && OPEN_IC_IOPENDING( GUESTREGS )

  004d0	33 c0		 xor	 eax, eax
  004d2	83 f8 01	 cmp	 eax, 1
  004d5	0f 84 a8 00 00
	00		 je	 $LN164@z900_run_s
  004db	33 c0		 xor	 eax, eax
  004dd	85 c0		 test	 eax, eax
  004df	75 56		 jne	 SHORT $LN165@z900_run_s
  004e1	48 8b 84 24 20
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  004e9	48 8b 80 70 08
	00 00		 mov	 rax, QWORD PTR [rax+2160]
  004f0	48 8b 80 88 08
	00 00		 mov	 rax, QWORD PTR [rax+2184]
  004f7	b9 01 00 00 00	 mov	 ecx, 1
  004fc	48 6b c9 00	 imul	 rcx, rcx, 0
  00500	0f b6 44 08 4c	 movzx	 eax, BYTE PTR [rax+rcx+76]
  00505	83 e0 04	 and	 eax, 4
  00508	85 c0		 test	 eax, eax
  0050a	75 2b		 jne	 SHORT $LN165@z900_run_s
  0050c	48 8b 84 24 20
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00514	48 8b 80 70 08
	00 00		 mov	 rax, QWORD PTR [rax+2160]
  0051b	48 8b 80 88 08
	00 00		 mov	 rax, QWORD PTR [rax+2184]
  00522	b9 01 00 00 00	 mov	 ecx, 1
  00527	48 6b c9 03	 imul	 rcx, rcx, 3
  0052b	0f b6 44 08 4c	 movzx	 eax, BYTE PTR [rax+rcx+76]
  00530	83 e0 04	 and	 eax, 4
  00533	85 c0		 test	 eax, eax
  00535	74 4c		 je	 SHORT $LN164@z900_run_s
$LN165@z900_run_s:
  00537	48 8b 84 24 20
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0053f	48 8b 80 70 08
	00 00		 mov	 rax, QWORD PTR [rax+2160]
  00546	48 8b 8c 24 20
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0054e	48 8b 89 70 08
	00 00		 mov	 rcx, QWORD PTR [rcx+2160]
  00555	8b 49 4c	 mov	 ecx, DWORD PTR [rcx+76]
  00558	8b 40 48	 mov	 eax, DWORD PTR [rax+72]
  0055b	23 c1		 and	 eax, ecx
  0055d	25 00 00 00 40	 and	 eax, 1073741824		; 40000000H
  00562	85 c0		 test	 eax, eax
  00564	74 1d		 je	 SHORT $LN164@z900_run_s

; 1091 :                     )
; 1092 :                     {
; 1093 :                         PERFORM_SERIALIZATION ( GUESTREGS );

  00566	0f ae f0	 mfence
$LN28@z900_run_s:

; 1094 :                         PERFORM_CHKPT_SYNC    ( GUESTREGS );

  00569	33 c0		 xor	 eax, eax
  0056b	85 c0		 test	 eax, eax
  0056d	75 fa		 jne	 SHORT $LN28@z900_run_s

; 1095 :                         ARCH_DEP( perform_io_interrupt )( GUESTREGS );

  0056f	48 8b 84 24 20
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00577	48 8b 88 70 08
	00 00		 mov	 rcx, QWORD PTR [rax+2160]
  0057e	e8 00 00 00 00	 call	 z900_perform_io_interrupt
$LN164@z900_run_s:

; 1096 :                     }
; 1097 : 
; 1098 : #if defined( _FEATURE_WAITSTATE_ASSIST )
; 1099 : 
; 1100 :                     /*  Is SIE guest in a wait state
; 1101 :                         AND Wait State Assist enabled?
; 1102 :                     */
; 1103 :                     if (1
; 1104 :                         && WAITSTATE( &GUESTREGS->psw )
; 1105 :                         && (STATEBK->ec[0] & SIE_EC0_WAIA)

  00583	33 c0		 xor	 eax, eax
  00585	83 f8 01	 cmp	 eax, 1
  00588	0f 84 b1 09 00
	00		 je	 $LN166@z900_run_s
  0058e	48 8b 84 24 20
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00596	48 8b 80 70 08
	00 00		 mov	 rax, QWORD PTR [rax+2160]
  0059d	0f b6 40 7a	 movzx	 eax, BYTE PTR [rax+122]
  005a1	83 e0 02	 and	 eax, 2
  005a4	85 c0		 test	 eax, eax
  005a6	0f 84 93 09 00
	00		 je	 $LN166@z900_run_s
  005ac	48 8b 84 24 20
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  005b4	48 8b 80 70 08
	00 00		 mov	 rax, QWORD PTR [rax+2160]
  005bb	48 8b 80 88 08
	00 00		 mov	 rax, QWORD PTR [rax+2184]
  005c2	b9 01 00 00 00	 mov	 ecx, 1
  005c7	48 6b c9 00	 imul	 rcx, rcx, 0
  005cb	0f b6 44 08 4c	 movzx	 eax, BYTE PTR [rax+rcx+76]
  005d0	83 e0 20	 and	 eax, 32			; 00000020H
  005d3	85 c0		 test	 eax, eax
  005d5	0f 84 64 09 00
	00		 je	 $LN166@z900_run_s

; 1106 :                     )
; 1107 :                     {
; 1108 :                         /* Test for disabled wait PSW and issue message */
; 1109 :                         if (IS_IC_DISABLED_WAIT_PSW( GUESTREGS ))

  005db	48 8b 84 24 20
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  005e3	48 8b 80 70 08
	00 00		 mov	 rax, QWORD PTR [rax+2160]
  005ea	8b 40 4c	 mov	 eax, DWORD PTR [rax+76]
  005ed	25 f0 ff 00 5f	 and	 eax, 1593901040		; 5f00fff0H
  005f2	85 c0		 test	 eax, eax
  005f4	75 36		 jne	 SHORT $LN167@z900_run_s

; 1110 :                         {
; 1111 :                             RELEASE_INTLOCK( regs );

  005f6	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG195285
  005fd	48 8b 8c 24 20
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00605	e8 00 00 00 00	 call	 Release_Interrupt_Lock

; 1112 :                             longjmp( GUESTREGS->progjmp, SIE_INTERCEPT_WAIT );

  0060a	48 8b 84 24 20
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00612	48 8b 80 70 08
	00 00		 mov	 rax, QWORD PTR [rax+2160]
  00619	48 05 80 09 00
	00		 add	 rax, 2432		; 00000980H
  0061f	ba f8 ff ff ff	 mov	 edx, -8
  00624	48 8b c8	 mov	 rcx, rax
  00627	e8 00 00 00 00	 call	 longjmp
$LN167@z900_run_s:

; 1113 :                         }
; 1114 : 
; 1115 :                         /* Skip conditions we cannot assist with */
; 1116 :                         if (0
; 1117 :                             || SIE_I_STOP ( GUESTREGS )
; 1118 :                             || SIE_I_EXT  ( GUESTREGS )
; 1119 :                             || SIE_I_IO   ( GUESTREGS )
; 1120 :                             || SIE_I_HOST (    regs   )

  0062c	33 c0		 xor	 eax, eax
  0062e	85 c0		 test	 eax, eax
  00630	0f 85 b4 00 00
	00		 jne	 $LN169@z900_run_s
  00636	48 8b 84 24 20
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0063e	48 8b 80 70 08
	00 00		 mov	 rax, QWORD PTR [rax+2160]
  00645	48 8b 80 88 08
	00 00		 mov	 rax, QWORD PTR [rax+2184]
  0064c	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  0064f	83 e0 04	 and	 eax, 4
  00652	85 c0		 test	 eax, eax
  00654	0f 85 90 00 00
	00		 jne	 $LN169@z900_run_s
  0065a	48 8b 84 24 20
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00662	48 8b 80 70 08
	00 00		 mov	 rax, QWORD PTR [rax+2160]
  00669	48 8b 80 88 08
	00 00		 mov	 rax, QWORD PTR [rax+2184]
  00670	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  00673	83 e0 01	 and	 eax, 1
  00676	85 c0		 test	 eax, eax
  00678	74 1a		 je	 SHORT $LN170@z900_run_s
  0067a	48 8b 84 24 20
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00682	48 8b 80 70 08
	00 00		 mov	 rax, QWORD PTR [rax+2160]
  00689	0f b6 40 78	 movzx	 eax, BYTE PTR [rax+120]
  0068d	83 e0 01	 and	 eax, 1
  00690	85 c0		 test	 eax, eax
  00692	75 56		 jne	 SHORT $LN169@z900_run_s
$LN170@z900_run_s:
  00694	48 8b 84 24 20
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0069c	48 8b 80 70 08
	00 00		 mov	 rax, QWORD PTR [rax+2160]
  006a3	48 8b 80 88 08
	00 00		 mov	 rax, QWORD PTR [rax+2184]
  006aa	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  006ad	83 e0 02	 and	 eax, 2
  006b0	85 c0		 test	 eax, eax
  006b2	74 1a		 je	 SHORT $LN171@z900_run_s
  006b4	48 8b 84 24 20
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  006bc	48 8b 80 70 08
	00 00		 mov	 rax, QWORD PTR [rax+2160]
  006c3	0f b6 40 78	 movzx	 eax, BYTE PTR [rax+120]
  006c7	83 e0 02	 and	 eax, 2
  006ca	85 c0		 test	 eax, eax
  006cc	75 1c		 jne	 SHORT $LN169@z900_run_s
$LN171@z900_run_s:
  006ce	48 8b 84 24 20
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  006d6	48 8b 8c 24 20
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  006de	8b 49 4c	 mov	 ecx, DWORD PTR [rcx+76]
  006e1	8b 40 48	 mov	 eax, DWORD PTR [rax+72]
  006e4	23 c1		 and	 eax, ecx
  006e6	85 c0		 test	 eax, eax
  006e8	74 19		 je	 SHORT $LN168@z900_run_s
$LN169@z900_run_s:

; 1121 :                         )
; 1122 :                         {
; 1123 :                             RELEASE_INTLOCK( regs );

  006ea	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG195290
  006f1	48 8b 8c 24 20
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  006f9	e8 00 00 00 00	 call	 Release_Interrupt_Lock

; 1124 :                             break;

  006fe	e9 43 1d 00 00	 jmp	 $LN18@z900_run_s
$LN168@z900_run_s:
$LN31@z900_run_s:

; 1125 :                         }
; 1126 : 
; 1127 :                         SET_AEA_MODE( GUESTREGS );

  00703	48 8b 84 24 20
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0070b	48 8b 80 70 08
	00 00		 mov	 rax, QWORD PTR [rax+2160]
  00712	b9 04 00 00 00	 mov	 ecx, 4
  00717	48 6b c9 04	 imul	 rcx, rcx, 4
  0071b	8b 84 08 94 0c
	00 00		 mov	 eax, DWORD PTR [rax+rcx+3220]
  00722	89 84 24 8c 00
	00 00		 mov	 DWORD PTR inst_cr$3[rsp], eax
  00729	48 8b 84 24 20
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00731	48 8b 80 70 08
	00 00		 mov	 rax, QWORD PTR [rax+2160]
  00738	0f b6 80 90 0c
	00 00		 movzx	 eax, BYTE PTR [rax+3216]
  0073f	88 44 24 5c	 mov	 BYTE PTR oldmode$2[rsp], al
  00743	48 8b 84 24 20
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0074b	48 8b 80 70 08
	00 00		 mov	 rax, QWORD PTR [rax+2160]
  00752	0f b6 40 78	 movzx	 eax, BYTE PTR [rax+120]
  00756	83 e0 04	 and	 eax, 4
  00759	85 c0		 test	 eax, eax
  0075b	75 78		 jne	 SHORT $LN240@z900_run_s
  0075d	48 8b 84 24 20
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00765	48 8b 80 70 08
	00 00		 mov	 rax, QWORD PTR [rax+2160]
  0076c	8b 80 c8 08 00
	00		 mov	 eax, DWORD PTR [rax+2248]
  00772	d1 e8		 shr	 eax, 1
  00774	83 e0 01	 and	 eax, 1
  00777	85 c0		 test	 eax, eax
  00779	74 45		 je	 SHORT $LN238@z900_run_s
  0077b	48 8b 84 24 20
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00783	48 8b 80 70 08
	00 00		 mov	 rax, QWORD PTR [rax+2160]
  0078a	48 8b 80 88 08
	00 00		 mov	 rax, QWORD PTR [rax+2184]
  00791	0f b6 40 02	 movzx	 eax, BYTE PTR [rax+2]
  00795	83 e0 01	 and	 eax, 1
  00798	85 c0		 test	 eax, eax
  0079a	74 24		 je	 SHORT $LN238@z900_run_s
  0079c	48 8b 84 24 20
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  007a4	48 8b 80 70 08
	00 00		 mov	 rax, QWORD PTR [rax+2160]
  007ab	0f b6 40 7b	 movzx	 eax, BYTE PTR [rax+123]
  007af	83 e0 40	 and	 eax, 64			; 00000040H
  007b2	85 c0		 test	 eax, eax
  007b4	74 0a		 je	 SHORT $LN238@z900_run_s
  007b6	c7 44 24 78 02
	00 00 00	 mov	 DWORD PTR tv373[rsp], 2
  007be	eb 08		 jmp	 SHORT $LN239@z900_run_s
$LN238@z900_run_s:
  007c0	c7 44 24 78 00
	00 00 00	 mov	 DWORD PTR tv373[rsp], 0
$LN239@z900_run_s:
  007c8	8b 44 24 78	 mov	 eax, DWORD PTR tv373[rsp]
  007cc	89 84 24 80 00
	00 00		 mov	 DWORD PTR tv379[rsp], eax
  007d3	eb 1f		 jmp	 SHORT $LN241@z900_run_s
$LN240@z900_run_s:
  007d5	48 8b 84 24 20
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  007dd	48 8b 80 70 08
	00 00		 mov	 rax, QWORD PTR [rax+2160]
  007e4	0f b6 40 7b	 movzx	 eax, BYTE PTR [rax+123]
  007e8	c1 f8 06	 sar	 eax, 6
  007eb	ff c0		 inc	 eax
  007ed	89 84 24 80 00
	00 00		 mov	 DWORD PTR tv379[rsp], eax
$LN241@z900_run_s:
  007f4	33 c0		 xor	 eax, eax
  007f6	85 c0		 test	 eax, eax
  007f8	75 63		 jne	 SHORT $LN242@z900_run_s
  007fa	48 8b 84 24 20
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00802	48 8b 80 70 08
	00 00		 mov	 rax, QWORD PTR [rax+2160]
  00809	0f b6 40 78	 movzx	 eax, BYTE PTR [rax+120]
  0080d	83 e0 40	 and	 eax, 64			; 00000040H
  00810	85 c0		 test	 eax, eax
  00812	75 49		 jne	 SHORT $LN242@z900_run_s
  00814	48 8b 84 24 20
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0081c	48 8b 80 70 08
	00 00		 mov	 rax, QWORD PTR [rax+2160]
  00823	8b 80 c8 08 00
	00		 mov	 eax, DWORD PTR [rax+2248]
  00829	d1 e8		 shr	 eax, 1
  0082b	83 e0 01	 and	 eax, 1
  0082e	85 c0		 test	 eax, eax
  00830	74 21		 je	 SHORT $LN243@z900_run_s
  00832	48 8b 84 24 20
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0083a	48 8b 80 70 08
	00 00		 mov	 rax, QWORD PTR [rax+2160]
  00841	48 8b 80 88 08
	00 00		 mov	 rax, QWORD PTR [rax+2184]
  00848	0f b6 40 03	 movzx	 eax, BYTE PTR [rax+3]
  0084c	83 e0 01	 and	 eax, 1
  0084f	85 c0		 test	 eax, eax
  00851	75 0a		 jne	 SHORT $LN242@z900_run_s
$LN243@z900_run_s:
  00853	c7 44 24 7c 00
	00 00 00	 mov	 DWORD PTR tv397[rsp], 0
  0085b	eb 08		 jmp	 SHORT $LN244@z900_run_s
$LN242@z900_run_s:
  0085d	c7 44 24 7c 40
	00 00 00	 mov	 DWORD PTR tv397[rsp], 64 ; 00000040H
$LN244@z900_run_s:
  00865	8b 44 24 7c	 mov	 eax, DWORD PTR tv397[rsp]
  00869	8b 8c 24 80 00
	00 00		 mov	 ecx, DWORD PTR tv379[rsp]
  00870	0b c8		 or	 ecx, eax
  00872	8b c1		 mov	 eax, ecx
  00874	48 8b 8c 24 20
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0087c	48 8b 89 70 08
	00 00		 mov	 rcx, QWORD PTR [rcx+2160]
  00883	88 81 90 0c 00
	00		 mov	 BYTE PTR [rcx+3216], al
  00889	48 8b 84 24 20
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00891	48 8b 80 70 08
	00 00		 mov	 rax, QWORD PTR [rax+2160]
  00898	0f b6 80 90 0c
	00 00		 movzx	 eax, BYTE PTR [rax+3216]
  0089f	83 e0 0f	 and	 eax, 15
  008a2	89 44 24 68	 mov	 DWORD PTR tv404[rsp], eax
  008a6	83 7c 24 68 01	 cmp	 DWORD PTR tv404[rsp], 1
  008ab	74 22		 je	 SHORT $LN172@z900_run_s
  008ad	83 7c 24 68 02	 cmp	 DWORD PTR tv404[rsp], 2
  008b2	74 61		 je	 SHORT $LN173@z900_run_s
  008b4	83 7c 24 68 03	 cmp	 DWORD PTR tv404[rsp], 3
  008b9	0f 84 46 01 00
	00		 je	 $LN177@z900_run_s
  008bf	83 7c 24 68 04	 cmp	 DWORD PTR tv404[rsp], 4
  008c4	0f 84 a4 01 00
	00		 je	 $LN178@z900_run_s
  008ca	e9 e2 01 00 00	 jmp	 $LN179@z900_run_s
$LN172@z900_run_s:
  008cf	c7 44 24 50 ff
	ff ff ff	 mov	 DWORD PTR i$1[rsp], -1
  008d7	eb 0a		 jmp	 SHORT $LN36@z900_run_s
$LN34@z900_run_s:
  008d9	8b 44 24 50	 mov	 eax, DWORD PTR i$1[rsp]
  008dd	ff c0		 inc	 eax
  008df	89 44 24 50	 mov	 DWORD PTR i$1[rsp], eax
$LN36@z900_run_s:
  008e3	83 7c 24 50 10	 cmp	 DWORD PTR i$1[rsp], 16
  008e8	7d 26		 jge	 SHORT $LN35@z900_run_s
  008ea	48 8b 84 24 20
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  008f2	48 8b 80 70 08
	00 00		 mov	 rax, QWORD PTR [rax+2160]
  008f9	8b 4c 24 50	 mov	 ecx, DWORD PTR i$1[rsp]
  008fd	83 c1 05	 add	 ecx, 5
  00900	48 63 c9	 movsxd	 rcx, ecx
  00903	c7 84 88 94 0c
	00 00 01 00 00
	00		 mov	 DWORD PTR [rax+rcx*4+3220], 1
  0090e	eb c9		 jmp	 SHORT $LN34@z900_run_s
$LN35@z900_run_s:
  00910	e9 dd 01 00 00	 jmp	 $LN32@z900_run_s
$LN173@z900_run_s:
  00915	c7 44 24 50 ff
	ff ff ff	 mov	 DWORD PTR i$1[rsp], -1
  0091d	eb 0a		 jmp	 SHORT $LN39@z900_run_s
$LN37@z900_run_s:
  0091f	8b 44 24 50	 mov	 eax, DWORD PTR i$1[rsp]
  00923	ff c0		 inc	 eax
  00925	89 44 24 50	 mov	 DWORD PTR i$1[rsp], eax
$LN39@z900_run_s:
  00929	83 7c 24 50 10	 cmp	 DWORD PTR i$1[rsp], 16
  0092e	7d 26		 jge	 SHORT $LN38@z900_run_s
  00930	48 8b 84 24 20
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00938	48 8b 80 70 08
	00 00		 mov	 rax, QWORD PTR [rax+2160]
  0093f	8b 4c 24 50	 mov	 ecx, DWORD PTR i$1[rsp]
  00943	83 c1 05	 add	 ecx, 5
  00946	48 63 c9	 movsxd	 rcx, ecx
  00949	c7 84 88 94 0c
	00 00 01 00 00
	00		 mov	 DWORD PTR [rax+rcx*4+3220], 1
  00954	eb c9		 jmp	 SHORT $LN37@z900_run_s
$LN38@z900_run_s:
  00956	c7 44 24 50 01
	00 00 00	 mov	 DWORD PTR i$1[rsp], 1
  0095e	eb 0a		 jmp	 SHORT $LN42@z900_run_s
$LN40@z900_run_s:
  00960	8b 44 24 50	 mov	 eax, DWORD PTR i$1[rsp]
  00964	ff c0		 inc	 eax
  00966	89 44 24 50	 mov	 DWORD PTR i$1[rsp], eax
$LN42@z900_run_s:
  0096a	83 7c 24 50 10	 cmp	 DWORD PTR i$1[rsp], 16
  0096f	0f 8d 8b 00 00
	00		 jge	 $LN41@z900_run_s
  00975	48 8b 84 24 20
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0097d	48 8b 80 70 08
	00 00		 mov	 rax, QWORD PTR [rax+2160]
  00984	48 63 4c 24 50	 movsxd	 rcx, DWORD PTR i$1[rsp]
  00989	83 bc 88 00 03
	00 00 01	 cmp	 DWORD PTR [rax+rcx*4+768], 1
  00991	75 26		 jne	 SHORT $LN174@z900_run_s
  00993	48 8b 84 24 20
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0099b	48 8b 80 70 08
	00 00		 mov	 rax, QWORD PTR [rax+2160]
  009a2	8b 4c 24 50	 mov	 ecx, DWORD PTR i$1[rsp]
  009a6	83 c1 05	 add	 ecx, 5
  009a9	48 63 c9	 movsxd	 rcx, ecx
  009ac	c7 84 88 94 0c
	00 00 07 00 00
	00		 mov	 DWORD PTR [rax+rcx*4+3220], 7
  009b7	eb 42		 jmp	 SHORT $LN175@z900_run_s
$LN174@z900_run_s:
  009b9	48 8b 84 24 20
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  009c1	48 8b 80 70 08
	00 00		 mov	 rax, QWORD PTR [rax+2160]
  009c8	48 63 4c 24 50	 movsxd	 rcx, DWORD PTR i$1[rsp]
  009cd	83 bc 88 00 03
	00 00 00	 cmp	 DWORD PTR [rax+rcx*4+768], 0
  009d5	74 24		 je	 SHORT $LN176@z900_run_s
  009d7	48 8b 84 24 20
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  009df	48 8b 80 70 08
	00 00		 mov	 rax, QWORD PTR [rax+2160]
  009e6	8b 4c 24 50	 mov	 ecx, DWORD PTR i$1[rsp]
  009ea	83 c1 05	 add	 ecx, 5
  009ed	48 63 c9	 movsxd	 rcx, ecx
  009f0	c7 84 88 94 0c
	00 00 00 00 00
	00		 mov	 DWORD PTR [rax+rcx*4+3220], 0
$LN176@z900_run_s:
$LN175@z900_run_s:
  009fb	e9 60 ff ff ff	 jmp	 $LN40@z900_run_s
$LN41@z900_run_s:
  00a00	e9 ed 00 00 00	 jmp	 $LN32@z900_run_s
$LN177@z900_run_s:
  00a05	48 8b 84 24 20
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00a0d	48 8b 80 70 08
	00 00		 mov	 rax, QWORD PTR [rax+2160]
  00a14	b9 04 00 00 00	 mov	 ecx, 4
  00a19	48 6b c9 04	 imul	 rcx, rcx, 4
  00a1d	c7 84 08 94 0c
	00 00 01 00 00
	00		 mov	 DWORD PTR [rax+rcx+3220], 1
  00a28	c7 44 24 50 00
	00 00 00	 mov	 DWORD PTR i$1[rsp], 0
  00a30	eb 0a		 jmp	 SHORT $LN45@z900_run_s
$LN43@z900_run_s:
  00a32	8b 44 24 50	 mov	 eax, DWORD PTR i$1[rsp]
  00a36	ff c0		 inc	 eax
  00a38	89 44 24 50	 mov	 DWORD PTR i$1[rsp], eax
$LN45@z900_run_s:
  00a3c	83 7c 24 50 10	 cmp	 DWORD PTR i$1[rsp], 16
  00a41	7d 26		 jge	 SHORT $LN44@z900_run_s
  00a43	48 8b 84 24 20
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00a4b	48 8b 80 70 08
	00 00		 mov	 rax, QWORD PTR [rax+2160]
  00a52	8b 4c 24 50	 mov	 ecx, DWORD PTR i$1[rsp]
  00a56	83 c1 05	 add	 ecx, 5
  00a59	48 63 c9	 movsxd	 rcx, ecx
  00a5c	c7 84 88 94 0c
	00 00 07 00 00
	00		 mov	 DWORD PTR [rax+rcx*4+3220], 7
  00a67	eb c9		 jmp	 SHORT $LN43@z900_run_s
$LN44@z900_run_s:
  00a69	e9 84 00 00 00	 jmp	 $LN32@z900_run_s
$LN178@z900_run_s:
  00a6e	c7 44 24 50 ff
	ff ff ff	 mov	 DWORD PTR i$1[rsp], -1
  00a76	eb 0a		 jmp	 SHORT $LN48@z900_run_s
$LN46@z900_run_s:
  00a78	8b 44 24 50	 mov	 eax, DWORD PTR i$1[rsp]
  00a7c	ff c0		 inc	 eax
  00a7e	89 44 24 50	 mov	 DWORD PTR i$1[rsp], eax
$LN48@z900_run_s:
  00a82	83 7c 24 50 10	 cmp	 DWORD PTR i$1[rsp], 16
  00a87	7d 26		 jge	 SHORT $LN47@z900_run_s
  00a89	48 8b 84 24 20
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00a91	48 8b 80 70 08
	00 00		 mov	 rax, QWORD PTR [rax+2160]
  00a98	8b 4c 24 50	 mov	 ecx, DWORD PTR i$1[rsp]
  00a9c	83 c1 05	 add	 ecx, 5
  00a9f	48 63 c9	 movsxd	 rcx, ecx
  00aa2	c7 84 88 94 0c
	00 00 0d 00 00
	00		 mov	 DWORD PTR [rax+rcx*4+3220], 13
  00aad	eb c9		 jmp	 SHORT $LN46@z900_run_s
$LN47@z900_run_s:
  00aaf	eb 41		 jmp	 SHORT $LN32@z900_run_s
$LN179@z900_run_s:
  00ab1	c7 44 24 50 ff
	ff ff ff	 mov	 DWORD PTR i$1[rsp], -1
  00ab9	eb 0a		 jmp	 SHORT $LN51@z900_run_s
$LN49@z900_run_s:
  00abb	8b 44 24 50	 mov	 eax, DWORD PTR i$1[rsp]
  00abf	ff c0		 inc	 eax
  00ac1	89 44 24 50	 mov	 DWORD PTR i$1[rsp], eax
$LN51@z900_run_s:
  00ac5	83 7c 24 50 10	 cmp	 DWORD PTR i$1[rsp], 16
  00aca	7d 26		 jge	 SHORT $LN50@z900_run_s
  00acc	48 8b 84 24 20
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00ad4	48 8b 80 70 08
	00 00		 mov	 rax, QWORD PTR [rax+2160]
  00adb	8b 4c 24 50	 mov	 ecx, DWORD PTR i$1[rsp]
  00adf	83 c1 05	 add	 ecx, 5
  00ae2	48 63 c9	 movsxd	 rcx, ecx
  00ae5	c7 84 88 94 0c
	00 00 ff ff ff
	ff		 mov	 DWORD PTR [rax+rcx*4+3220], -1
  00af0	eb c9		 jmp	 SHORT $LN49@z900_run_s
$LN50@z900_run_s:
$LN32@z900_run_s:
  00af2	48 8b 84 24 20
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00afa	48 8b 80 70 08
	00 00		 mov	 rax, QWORD PTR [rax+2160]
  00b01	b9 04 00 00 00	 mov	 ecx, 4
  00b06	48 6b c9 04	 imul	 rcx, rcx, 4
  00b0a	8b 84 08 94 0c
	00 00		 mov	 eax, DWORD PTR [rax+rcx+3220]
  00b11	39 84 24 8c 00
	00 00		 cmp	 DWORD PTR inst_cr$3[rsp], eax
  00b18	0f 84 b2 00 00
	00		 je	 $LN180@z900_run_s
$LN54@z900_run_s:
  00b1e	48 8b 84 24 20
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00b26	48 8b 80 70 08
	00 00		 mov	 rax, QWORD PTR [rax+2160]
  00b2d	48 83 b8 08 02
	00 00 00	 cmp	 QWORD PTR [rax+520], 0
  00b35	0f 84 8b 00 00
	00		 je	 $LN181@z900_run_s
  00b3b	48 8b 84 24 20
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00b43	48 8b 80 70 08
	00 00		 mov	 rax, QWORD PTR [rax+2160]
  00b4a	48 8b 8c 24 20
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00b52	48 8b 89 70 08
	00 00		 mov	 rcx, QWORD PTR [rcx+2160]
  00b59	48 8b 94 24 20
	01 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  00b61	48 8b 92 70 08
	00 00		 mov	 rdx, QWORD PTR [rdx+2160]
  00b68	48 8b 92 00 02
	00 00		 mov	 rdx, QWORD PTR [rdx+512]
  00b6f	48 8b 49 68	 mov	 rcx, QWORD PTR [rcx+104]
  00b73	48 2b ca	 sub	 rcx, rdx
  00b76	48 8b 80 10 02
	00 00		 mov	 rax, QWORD PTR [rax+528]
  00b7d	48 03 c1	 add	 rax, rcx
  00b80	48 8b 8c 24 20
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00b88	48 8b 89 70 08
	00 00		 mov	 rcx, QWORD PTR [rcx+2160]
  00b8f	48 23 81 90 00
	00 00		 and	 rax, QWORD PTR [rcx+144]
  00b96	48 8b 8c 24 20
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00b9e	48 8b 89 70 08
	00 00		 mov	 rcx, QWORD PTR [rcx+2160]
  00ba5	48 89 81 88 00
	00 00		 mov	 QWORD PTR [rcx+136], rax
  00bac	48 8b 84 24 20
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00bb4	48 8b 80 70 08
	00 00		 mov	 rax, QWORD PTR [rax+2160]
  00bbb	48 c7 80 08 02
	00 00 00 00 00
	00		 mov	 QWORD PTR [rax+520], 0
$LN181@z900_run_s:
  00bc6	33 c0		 xor	 eax, eax
  00bc8	85 c0		 test	 eax, eax
  00bca	0f 85 4e ff ff
	ff		 jne	 $LN54@z900_run_s
$LN180@z900_run_s:
  00bd0	0f b6 44 24 5c	 movzx	 eax, BYTE PTR oldmode$2[rsp]
  00bd5	83 e0 40	 and	 eax, 64			; 00000040H
  00bd8	85 c0		 test	 eax, eax
  00bda	0f 85 45 01 00
	00		 jne	 $LN182@z900_run_s
  00be0	48 8b 84 24 20
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00be8	48 8b 80 70 08
	00 00		 mov	 rax, QWORD PTR [rax+2160]
  00bef	0f b6 80 90 0c
	00 00		 movzx	 eax, BYTE PTR [rax+3216]
  00bf6	83 e0 40	 and	 eax, 64			; 00000040H
  00bf9	85 c0		 test	 eax, eax
  00bfb	0f 84 24 01 00
	00		 je	 $LN182@z900_run_s
$LN57@z900_run_s:
  00c01	48 8b 84 24 20
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00c09	48 8b 80 70 08
	00 00		 mov	 rax, QWORD PTR [rax+2160]
  00c10	48 83 b8 08 02
	00 00 00	 cmp	 QWORD PTR [rax+520], 0
  00c18	0f 84 8b 00 00
	00		 je	 $LN183@z900_run_s
  00c1e	48 8b 84 24 20
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00c26	48 8b 80 70 08
	00 00		 mov	 rax, QWORD PTR [rax+2160]
  00c2d	48 8b 8c 24 20
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00c35	48 8b 89 70 08
	00 00		 mov	 rcx, QWORD PTR [rcx+2160]
  00c3c	48 8b 94 24 20
	01 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  00c44	48 8b 92 70 08
	00 00		 mov	 rdx, QWORD PTR [rdx+2160]
  00c4b	48 8b 92 00 02
	00 00		 mov	 rdx, QWORD PTR [rdx+512]
  00c52	48 8b 49 68	 mov	 rcx, QWORD PTR [rcx+104]
  00c56	48 2b ca	 sub	 rcx, rdx
  00c59	48 8b 80 10 02
	00 00		 mov	 rax, QWORD PTR [rax+528]
  00c60	48 03 c1	 add	 rax, rcx
  00c63	48 8b 8c 24 20
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00c6b	48 8b 89 70 08
	00 00		 mov	 rcx, QWORD PTR [rcx+2160]
  00c72	48 23 81 90 00
	00 00		 and	 rax, QWORD PTR [rcx+144]
  00c79	48 8b 8c 24 20
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00c81	48 8b 89 70 08
	00 00		 mov	 rcx, QWORD PTR [rcx+2160]
  00c88	48 89 81 88 00
	00 00		 mov	 QWORD PTR [rcx+136], rax
  00c8f	48 8b 84 24 20
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00c97	48 8b 80 70 08
	00 00		 mov	 rax, QWORD PTR [rax+2160]
  00c9e	48 c7 80 08 02
	00 00 00 00 00
	00		 mov	 QWORD PTR [rax+520], 0
$LN183@z900_run_s:
  00ca9	33 c0		 xor	 eax, eax
  00cab	85 c0		 test	 eax, eax
  00cad	0f 85 4e ff ff
	ff		 jne	 $LN57@z900_run_s
  00cb3	48 8b 84 24 20
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00cbb	48 8b 80 70 08
	00 00		 mov	 rax, QWORD PTR [rax+2160]
  00cc2	8b 80 28 07 00
	00		 mov	 eax, DWORD PTR [rax+1832]
  00cc8	c1 e8 02	 shr	 eax, 2
  00ccb	83 e0 01	 and	 eax, 1
  00cce	85 c0		 test	 eax, eax
  00cd0	74 0d		 je	 SHORT $LN247@z900_run_s
  00cd2	c7 84 24 84 00
	00 00 01 00 00
	00		 mov	 DWORD PTR tv542[rsp], 1
  00cdd	eb 0b		 jmp	 SHORT $LN248@z900_run_s
$LN247@z900_run_s:
  00cdf	c7 84 24 84 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv542[rsp], 0
$LN248@z900_run_s:
  00cea	83 bc 24 84 00
	00 00 00	 cmp	 DWORD PTR tv542[rsp], 0
  00cf2	74 31		 je	 SHORT $LN184@z900_run_s
  00cf4	48 8b 84 24 20
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00cfc	48 8b 80 70 08
	00 00		 mov	 rax, QWORD PTR [rax+2160]
  00d03	8b 40 48	 mov	 eax, DWORD PTR [rax+72]
  00d06	25 00 00 20 00	 and	 eax, 2097152		; 00200000H
  00d0b	85 c0		 test	 eax, eax
  00d0d	74 16		 je	 SHORT $LN184@z900_run_s
  00d0f	b2 fc		 mov	 dl, 252			; 000000fcH
  00d11	48 8b 84 24 20
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00d19	48 8b 88 70 08
	00 00		 mov	 rcx, QWORD PTR [rax+2160]
  00d20	e8 00 00 00 00	 call	 z900_invalidate_tlb
$LN184@z900_run_s:
$LN182@z900_run_s:
  00d25	33 c0		 xor	 eax, eax
  00d27	85 c0		 test	 eax, eax
  00d29	0f 85 d4 f9 ff
	ff		 jne	 $LN31@z900_run_s

; 1128 : 
; 1129 :                         /* Assist with the wait... but only briefly */
; 1130 :                         {
; 1131 :                             struct timespec waittime;
; 1132 : 
; 1133 :                             U64 now = host_tod();

  00d2f	e8 00 00 00 00	 call	 host_tod
  00d34	48 89 84 24 a0
	00 00 00	 mov	 QWORD PTR now$4[rsp], rax

; 1134 : 
; 1135 :                             waittime.tv_sec  =   (now >> (64-51)) / ONE_MILLION;

  00d3c	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR now$4[rsp]
  00d44	48 c1 e8 0d	 shr	 rax, 13
  00d48	33 d2		 xor	 edx, edx
  00d4a	b9 40 42 0f 00	 mov	 ecx, 1000000		; 000f4240H
  00d4f	48 f7 f1	 div	 rcx
  00d52	48 89 84 24 f8
	00 00 00	 mov	 QWORD PTR waittime$5[rsp], rax

; 1136 :                             waittime.tv_nsec = (((now >> (64-51)) % ONE_MILLION) + 3333) * 1000;

  00d5a	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR now$4[rsp]
  00d62	48 c1 e8 0d	 shr	 rax, 13
  00d66	33 d2		 xor	 edx, edx
  00d68	b9 40 42 0f 00	 mov	 ecx, 1000000		; 000f4240H
  00d6d	48 f7 f1	 div	 rcx
  00d70	48 8b c2	 mov	 rax, rdx
  00d73	48 05 05 0d 00
	00		 add	 rax, 3333		; 00000d05H
  00d79	48 69 c0 e8 03
	00 00		 imul	 rax, rax, 1000		; 000003e8H
  00d80	89 84 24 00 01
	00 00		 mov	 DWORD PTR waittime$5[rsp+8], eax

; 1137 :                             waittime.tv_sec  += waittime.tv_nsec /  ONE_BILLION;

  00d87	48 63 84 24 00
	01 00 00	 movsxd	 rax, DWORD PTR waittime$5[rsp+8]
  00d8f	33 d2		 xor	 edx, edx
  00d91	b9 00 ca 9a 3b	 mov	 ecx, 1000000000		; 3b9aca00H
  00d96	48 f7 f1	 div	 rcx
  00d99	48 8b 8c 24 f8
	00 00 00	 mov	 rcx, QWORD PTR waittime$5[rsp]
  00da1	48 03 c8	 add	 rcx, rax
  00da4	48 8b c1	 mov	 rax, rcx
  00da7	48 89 84 24 f8
	00 00 00	 mov	 QWORD PTR waittime$5[rsp], rax

; 1138 :                             waittime.tv_nsec %=                     ONE_BILLION;

  00daf	48 63 84 24 00
	01 00 00	 movsxd	 rax, DWORD PTR waittime$5[rsp+8]
  00db7	33 d2		 xor	 edx, edx
  00db9	b9 00 ca 9a 3b	 mov	 ecx, 1000000000		; 3b9aca00H
  00dbe	48 f7 f1	 div	 rcx
  00dc1	48 8b c2	 mov	 rax, rdx
  00dc4	89 84 24 00 01
	00 00		 mov	 DWORD PTR waittime$5[rsp+8], eax

; 1139 : 
; 1140 :                             regs->waittod = now;

  00dcb	48 8b 84 24 20
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00dd3	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR now$4[rsp]
  00ddb	48 89 88 b8 07
	00 00		 mov	 QWORD PTR [rax+1976], rcx

; 1141 : 
; 1142 :                             sysblk.waiting_mask  |=  regs->cpubit;

  00de2	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00de9	48 8b 8c 24 20
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00df1	48 8b 49 50	 mov	 rcx, QWORD PTR [rcx+80]
  00df5	48 8b 80 b8 12
	00 00		 mov	 rax, QWORD PTR [rax+4792]
  00dfc	48 0b c1	 or	 rax, rcx
  00dff	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  00e06	48 89 81 b8 12
	00 00		 mov	 QWORD PTR [rcx+4792], rax

; 1143 :                             sysblk.intowner       =  LOCK_OWNER_NONE;

  00e0d	b8 ff ff 00 00	 mov	 eax, 65535		; 0000ffffH
  00e12	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  00e19	66 89 81 62 10
	00 00		 mov	 WORD PTR [rcx+4194], ax

; 1144 :                             {
; 1145 :                                 timed_wait_condition( &regs->intcond, &sysblk.intlock, &waittime );

  00e20	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00e27	48 05 70 10 00
	00		 add	 rax, 4208		; 00001070H
  00e2d	48 8b 8c 24 20
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00e35	48 81 c1 80 0c
	00 00		 add	 rcx, 3200		; 00000c80H
  00e3c	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG195304
  00e43	4c 8d 84 24 f8
	00 00 00	 lea	 r8, QWORD PTR waittime$5[rsp]
  00e4b	48 8b d0	 mov	 rdx, rax
  00e4e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_timed_wait_condition
$LN58@z900_run_s:

; 1146 : 
; 1147 :                                 while (sysblk.syncing)

  00e54	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00e5b	0f b6 80 7c 13
	00 00		 movzx	 eax, BYTE PTR [rax+4988]
  00e62	85 c0		 test	 eax, eax
  00e64	74 2d		 je	 SHORT $LN59@z900_run_s

; 1148 :                                      wait_condition( &sysblk.sync_done_cond, &sysblk.intlock );

  00e66	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00e6d	48 05 70 10 00
	00		 add	 rax, 4208		; 00001070H
  00e73	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  00e7a	48 81 c1 90 13
	00 00		 add	 rcx, 5008		; 00001390H
  00e81	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG195305
  00e88	48 8b d0	 mov	 rdx, rax
  00e8b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_wait_condition
  00e91	eb c1		 jmp	 SHORT $LN58@z900_run_s
$LN59@z900_run_s:

; 1149 :                             }
; 1150 :                             sysblk.intowner       =   regs->cpuad;

  00e93	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00e9a	48 8b 8c 24 20
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00ea2	0f b7 89 3c 08
	00 00		 movzx	 ecx, WORD PTR [rcx+2108]
  00ea9	66 89 88 62 10
	00 00		 mov	 WORD PTR [rax+4194], cx

; 1151 :                             sysblk.waiting_mask  &=  ~regs->cpubit;

  00eb0	48 8b 84 24 20
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00eb8	48 8b 40 50	 mov	 rax, QWORD PTR [rax+80]
  00ebc	48 f7 d0	 not	 rax
  00ebf	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  00ec6	48 8b 89 b8 12
	00 00		 mov	 rcx, QWORD PTR [rcx+4792]
  00ecd	48 23 c8	 and	 rcx, rax
  00ed0	48 8b c1	 mov	 rax, rcx
  00ed3	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  00eda	48 89 81 b8 12
	00 00		 mov	 QWORD PTR [rcx+4792], rax

; 1152 : 
; 1153 :                             regs->waittime += host_tod() - regs->waittod;

  00ee1	e8 00 00 00 00	 call	 host_tod
  00ee6	48 8b 8c 24 20
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00eee	48 2b 81 b8 07
	00 00		 sub	 rax, QWORD PTR [rcx+1976]
  00ef5	48 8b 8c 24 20
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00efd	48 03 81 c0 07
	00 00		 add	 rax, QWORD PTR [rcx+1984]
  00f04	48 8b 8c 24 20
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00f0c	48 89 81 c0 07
	00 00		 mov	 QWORD PTR [rcx+1984], rax

; 1154 :                             regs->waittod = 0;

  00f13	48 8b 84 24 20
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00f1b	48 c7 80 b8 07
	00 00 00 00 00
	00		 mov	 QWORD PTR [rax+1976], 0

; 1155 :                         }
; 1156 : 
; 1157 :                         RELEASE_INTLOCK( regs );

  00f26	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG195306
  00f2d	48 8b 8c 24 20
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00f35	e8 00 00 00 00	 call	 Release_Interrupt_Lock

; 1158 :                         break;

  00f3a	e9 07 15 00 00	 jmp	 $LN18@z900_run_s
$LN166@z900_run_s:

; 1159 : 
; 1160 :                     }
; 1161 : #endif /* defined( _FEATURE_WAITSTATE_ASSIST ) */
; 1162 : 
; 1163 :                     RELEASE_INTLOCK( regs );

  00f3f	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG195307
  00f46	48 8b 8c 24 20
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00f4e	e8 00 00 00 00	 call	 Release_Interrupt_Lock
$LN159@z900_run_s:

; 1164 :                 }
; 1165 : 
; 1166 :                 /* Break out of loop if SIE guest is waiting */
; 1167 :                 if (SIE_I_WAIT( GUESTREGS ))

  00f53	48 8b 84 24 20
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00f5b	48 8b 80 70 08
	00 00		 mov	 rax, QWORD PTR [rax+2160]
  00f62	0f b6 40 7a	 movzx	 eax, BYTE PTR [rax+122]
  00f66	83 e0 02	 and	 eax, 2
  00f69	85 c0		 test	 eax, eax
  00f6b	74 30		 je	 SHORT $LN185@z900_run_s
  00f6d	48 8b 84 24 20
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00f75	48 8b 80 70 08
	00 00		 mov	 rax, QWORD PTR [rax+2160]
  00f7c	48 8b 80 88 08
	00 00		 mov	 rax, QWORD PTR [rax+2184]
  00f83	b9 01 00 00 00	 mov	 ecx, 1
  00f88	48 6b c9 00	 imul	 rcx, rcx, 0
  00f8c	0f b6 44 08 4c	 movzx	 eax, BYTE PTR [rax+rcx+76]
  00f91	83 e0 20	 and	 eax, 32			; 00000020H
  00f94	85 c0		 test	 eax, eax
  00f96	75 05		 jne	 SHORT $LN185@z900_run_s

; 1168 :                     break;

  00f98	e9 a9 14 00 00	 jmp	 $LN18@z900_run_s
$LN185@z900_run_s:
$LN261@z900_run_s:
$LN260@z900_run_s:
$sie_fetch_instruction$262:

; 1169 : 
; 1170 : sie_fetch_instruction:
; 1171 : 
; 1172 :                 ip = INSTRUCTION_FETCH( GUESTREGS, 0 );

  00f9d	33 c0		 xor	 eax, eax
  00f9f	83 f8 01	 cmp	 eax, 1
  00fa2	74 2b		 je	 SHORT $LN249@z900_run_s
  00fa4	48 8b 84 24 20
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00fac	48 8b 80 70 08
	00 00		 mov	 rax, QWORD PTR [rax+2160]
  00fb3	48 8b 8c 24 20
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00fbb	48 8b 89 70 08
	00 00		 mov	 rcx, QWORD PTR [rcx+2160]
  00fc2	48 8b 89 08 02
	00 00		 mov	 rcx, QWORD PTR [rcx+520]
  00fc9	48 39 48 68	 cmp	 QWORD PTR [rax+104], rcx
  00fcd	72 13		 jb	 SHORT $LN250@z900_run_s
$LN249@z900_run_s:
  00fcf	33 c0		 xor	 eax, eax
  00fd1	85 c0		 test	 eax, eax
  00fd3	75 0d		 jne	 SHORT $LN250@z900_run_s
  00fd5	c7 84 24 88 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv632[rsp], 0
  00fe0	eb 0b		 jmp	 SHORT $LN254@z900_run_s
$LN250@z900_run_s:
  00fe2	c7 84 24 88 00
	00 00 01 00 00
	00		 mov	 DWORD PTR tv632[rsp], 1
$LN254@z900_run_s:
  00fed	83 bc 24 88 00
	00 00 00	 cmp	 DWORD PTR tv632[rsp], 0
  00ff5	74 1d		 je	 SHORT $LN255@z900_run_s
  00ff7	48 8b 84 24 20
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00fff	48 8b 80 70 08
	00 00		 mov	 rax, QWORD PTR [rax+2160]
  01006	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  0100a	48 89 84 24 a8
	00 00 00	 mov	 QWORD PTR tv640[rsp], rax
  01012	eb 1e		 jmp	 SHORT $LN256@z900_run_s
$LN255@z900_run_s:
  01014	33 d2		 xor	 edx, edx
  01016	48 8b 84 24 20
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0101e	48 8b 88 70 08
	00 00		 mov	 rcx, QWORD PTR [rax+2160]
  01025	e8 00 00 00 00	 call	 z900_instfetch
  0102a	48 89 84 24 a8
	00 00 00	 mov	 QWORD PTR tv640[rsp], rax
$LN256@z900_run_s:
  01032	48 8b 84 24 a8
	00 00 00	 mov	 rax, QWORD PTR tv640[rsp]
  0103a	48 89 44 24 60	 mov	 QWORD PTR ip$[rsp], rax

; 1173 :                 current_opcode_table = GUESTREGS->ARCH_DEP( runtime_opcode_xxxx );

  0103f	48 8b 84 24 20
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  01047	48 8b 80 70 08
	00 00		 mov	 rax, QWORD PTR [rax+2160]
  0104e	48 8b 80 28 b0
	00 00		 mov	 rax, QWORD PTR [rax+45096]
  01055	48 89 44 24 70	 mov	 QWORD PTR current_opcode_table$[rsp], rax

; 1174 : 
; 1175 : #if defined( SIE_DEBUG )
; 1176 :                 ARCH_DEP( display_inst )( GUESTREGS, GUESTREGS->instinvalid ? NULL : ip );
; 1177 : #endif
; 1178 :                 //--------------------------------------------------------------
; 1179 :                 //                    PROGRAMMING NOTE
; 1180 :                 //--------------------------------------------------------------
; 1181 :                 // The first 'fastest_no_txf_loop' loop below is used when the
; 1182 :                 // TXF facility is not enabled, and since facilities cannot be
; 1183 :                 // enabled or disabled once the guest system has been IPLed and
; 1184 :                 // started, it utilizes our original instruction execution loop
; 1185 :                 // which uses the 'EXECUTE_INSTRUCTION' and 'UNROLLED_EXECUTE'
; 1186 :                 // macros which do not have any TXF related code in them.
; 1187 :                 //
; 1188 :                 // The second and third loops below (the 'txf_facility_loop' and
; 1189 :                 // 'txf_slower_loop') are used when the TXF facility is enabled,
; 1190 :                 // requiring us to check whether or not a transaction is active
; 1191 :                 // or not after each instruction is executed.
; 1192 :                 //
; 1193 :                 // If no transaction is active, the normal 'EXECUTE_INSTRUCTION'
; 1194 :                 // and 'UNROLLED_EXECUTE' macros can be used, but a check for an
; 1195 :                 // active transaction still needs to be performed after each and
; 1196 :                 // every instruction (so we can know which loop we need to use).
; 1197 :                 //
; 1198 :                 // When a transaction is active, we use the third (slowest) loop
; 1199 :                 // called 'txf_slower_loop', using the 'TXF_EXECUTE_INSTRUCTION'
; 1200 :                 // and 'TXF_UNROLLED_EXECUTE' macros, which contain code that
; 1201 :                 // enforces certain Transaction-Exceution Facility constraints.
; 1202 :                 //--------------------------------------------------------------
; 1203 : 
; 1204 : #if defined( FEATURE_073_TRANSACT_EXEC_FACILITY )
; 1205 :                 if (FACILITY_ENABLED( 073_TRANSACT_EXEC, GUESTREGS ))

  0105a	48 8b 84 24 20
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  01062	48 8b 80 70 08
	00 00		 mov	 rax, QWORD PTR [rax+2160]
  01069	b9 01 00 00 00	 mov	 ecx, 1
  0106e	48 6b c9 09	 imul	 rcx, rcx, 9
  01072	0f b6 84 08 28
	0d 00 00	 movzx	 eax, BYTE PTR [rax+rcx+3368]
  0107a	83 e0 40	 and	 eax, 64			; 00000040H
  0107d	85 c0		 test	 eax, eax
  0107f	74 05		 je	 SHORT $LN186@z900_run_s

; 1206 :                     goto txf_facility_loop;

  01081	e9 4c 03 00 00	 jmp	 $txf_facility_loop$263
$LN186@z900_run_s:
$LN62@z900_run_s:

; 1207 : #endif
; 1208 : 
; 1209 : //fastest_no_txf_loop:
; 1210 : 
; 1211 :                 SIE_PERFMON( SIE_PERF_EXEC );
; 1212 : 
; 1213 :                 PROCESS_TRACE( GUESTREGS, ip, sie_fetch_instruction );

  01086	48 8b 84 24 20
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0108e	48 8b 80 70 08
	00 00		 mov	 rax, QWORD PTR [rax+2160]
  01095	8b 80 28 07 00
	00		 mov	 eax, DWORD PTR [rax+1832]
  0109b	c1 e8 10	 shr	 eax, 16
  0109e	83 e0 01	 and	 eax, 1
  010a1	85 c0		 test	 eax, eax
  010a3	0f 84 18 01 00
	00		 je	 $LN187@z900_run_s
  010a9	48 8b 54 24 60	 mov	 rdx, QWORD PTR ip$[rsp]
  010ae	48 8b 84 24 20
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  010b6	48 8b 88 70 08
	00 00		 mov	 rcx, QWORD PTR [rax+2160]
  010bd	e8 00 00 00 00	 call	 z900_process_trace
  010c2	33 c0		 xor	 eax, eax
  010c4	83 f8 01	 cmp	 eax, 1
  010c7	0f 84 f4 00 00
	00		 je	 $LN188@z900_run_s
  010cd	48 8b 84 24 20
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  010d5	48 8b 80 70 08
	00 00		 mov	 rax, QWORD PTR [rax+2160]
  010dc	8b 80 28 07 00
	00		 mov	 eax, DWORD PTR [rax+1832]
  010e2	c1 e8 11	 shr	 eax, 17
  010e5	83 e0 01	 and	 eax, 1
  010e8	85 c0		 test	 eax, eax
  010ea	0f 84 d1 00 00
	00		 je	 $LN188@z900_run_s
  010f0	48 8b 84 24 20
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  010f8	48 8b 80 70 08
	00 00		 mov	 rax, QWORD PTR [rax+2160]
  010ff	48 83 b8 08 02
	00 00 00	 cmp	 QWORD PTR [rax+520], 0
  01107	0f 85 b4 00 00
	00		 jne	 $LN188@z900_run_s
  0110d	48 8b 84 24 20
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  01115	48 8b 80 70 08
	00 00		 mov	 rax, QWORD PTR [rax+2160]
  0111c	0f b7 80 3c 08
	00 00		 movzx	 eax, WORD PTR [rax+2108]
  01123	89 84 24 90 00
	00 00		 mov	 DWORD PTR tv669[rsp], eax
  0112a	48 8b 8c 24 20
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  01132	48 8b 89 70 08
	00 00		 mov	 rcx, QWORD PTR [rcx+2160]
  01139	0f b7 89 3c 08
	00 00		 movzx	 ecx, WORD PTR [rcx+2108]
  01140	48 8b 15 00 00
	00 00		 mov	 rdx, QWORD PTR __imp_sysblk
  01147	0f b6 8c 0a 48
	0b 00 00	 movzx	 ecx, BYTE PTR [rdx+rcx+2888]
  0114f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ptyp2short
  01155	48 89 84 24 b0
	00 00 00	 mov	 QWORD PTR tv671[rsp], rax
  0115d	b9 01 00 00 00	 mov	 ecx, 1
  01162	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  01168	8b 8c 24 90 00
	00 00		 mov	 ecx, DWORD PTR tv669[rsp]
  0116f	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  01173	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR tv671[rsp]
  0117b	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  01180	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG195312
  01187	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  0118c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG195313
  01193	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  01198	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  0119d	41 b9 03 00 00
	00		 mov	 r9d, 3
  011a3	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG195314
  011aa	ba bd 04 00 00	 mov	 edx, 1213		; 000004bdH
  011af	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG195315
  011b6	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg
  011bc	e9 dc fd ff ff	 jmp	 $sie_fetch_instruction$262
$LN188@z900_run_s:
$LN187@z900_run_s:
  011c1	33 c0		 xor	 eax, eax
  011c3	85 c0		 test	 eax, eax
  011c5	0f 85 bb fe ff
	ff		 jne	 $LN62@z900_run_s
$LN65@z900_run_s:

; 1214 :                 EXECUTE_INSTRUCTION( current_opcode_table, ip, GUESTREGS );

  011cb	48 8b 4c 24 60	 mov	 rcx, QWORD PTR ip$[rsp]
  011d0	e8 00 00 00 00	 call	 fetch_hw_noswap
  011d5	0f b7 c8	 movzx	 ecx, ax
  011d8	e8 00 00 00 00	 call	 _byteswap_ushort
  011dd	0f b7 c0	 movzx	 eax, ax
  011e0	48 8b 8c 24 20
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  011e8	48 8b 91 70 08
	00 00		 mov	 rdx, QWORD PTR [rcx+2160]
  011ef	48 8b 4c 24 60	 mov	 rcx, QWORD PTR ip$[rsp]
  011f4	4c 8b 44 24 70	 mov	 r8, QWORD PTR current_opcode_table$[rsp]
  011f9	41 ff 14 c0	 call	 QWORD PTR [r8+rax*8]
  011fd	33 c0		 xor	 eax, eax
  011ff	85 c0		 test	 eax, eax
  01201	75 c8		 jne	 SHORT $LN65@z900_run_s

; 1215 :                 regs->instcount++;

  01203	48 8b 84 24 20
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0120b	8b 80 98 07 00
	00		 mov	 eax, DWORD PTR [rax+1944]
  01211	ff c0		 inc	 eax
  01213	48 8b 8c 24 20
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0121b	89 81 98 07 00
	00		 mov	 DWORD PTR [rcx+1944], eax

; 1216 :                 UPDATE_SYSBLK_INSTCOUNT( 1 );

  01221	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  01228	48 05 80 14 00
	00		 add	 rax, 5248		; 00001480H
  0122e	ba 01 00 00 00	 mov	 edx, 1
  01233	48 8b c8	 mov	 rcx, rax
  01236	e8 00 00 00 00	 call	 atomic_update64

; 1217 :                 SIE_PERFMON( SIE_PERF_EXEC_U );
; 1218 : 
; 1219 :                 for (i=0; i < MAX_CPU_LOOPS/2; i++)

  0123b	c7 44 24 54 00
	00 00 00	 mov	 DWORD PTR i$[rsp], 0
  01243	eb 0a		 jmp	 SHORT $LN68@z900_run_s
$LN66@z900_run_s:
  01245	8b 44 24 54	 mov	 eax, DWORD PTR i$[rsp]
  01249	ff c0		 inc	 eax
  0124b	89 44 24 54	 mov	 DWORD PTR i$[rsp], eax
$LN68@z900_run_s:
  0124f	81 7c 24 54 80
	00 00 00	 cmp	 DWORD PTR i$[rsp], 128	; 00000080H
  01257	0f 8d 2a 01 00
	00		 jge	 $LN67@z900_run_s

; 1220 :                 {
; 1221 :                     UNROLLED_EXECUTE( current_opcode_table, GUESTREGS );

  0125d	48 8b 84 24 20
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  01265	48 8b 80 70 08
	00 00		 mov	 rax, QWORD PTR [rax+2160]
  0126c	48 8b 8c 24 20
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  01274	48 8b 89 70 08
	00 00		 mov	 rcx, QWORD PTR [rcx+2160]
  0127b	48 8b 89 08 02
	00 00		 mov	 rcx, QWORD PTR [rcx+520]
  01282	48 39 48 68	 cmp	 QWORD PTR [rax+104], rcx
  01286	72 05		 jb	 SHORT $LN189@z900_run_s
  01288	e9 fa 00 00 00	 jmp	 $LN67@z900_run_s
$LN189@z900_run_s:
$LN71@z900_run_s:
  0128d	48 8b 84 24 20
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  01295	48 8b 80 70 08
	00 00		 mov	 rax, QWORD PTR [rax+2160]
  0129c	48 89 84 24 b8
	00 00 00	 mov	 QWORD PTR tv1576[rsp], rax
  012a4	48 8b 8c 24 20
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  012ac	48 8b 89 70 08
	00 00		 mov	 rcx, QWORD PTR [rcx+2160]
  012b3	48 8b 49 68	 mov	 rcx, QWORD PTR [rcx+104]
  012b7	e8 00 00 00 00	 call	 fetch_hw_noswap
  012bc	0f b7 c8	 movzx	 ecx, ax
  012bf	e8 00 00 00 00	 call	 _byteswap_ushort
  012c4	0f b7 c0	 movzx	 eax, ax
  012c7	48 8b 8c 24 20
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  012cf	48 8b 91 70 08
	00 00		 mov	 rdx, QWORD PTR [rcx+2160]
  012d6	48 8b 8c 24 b8
	00 00 00	 mov	 rcx, QWORD PTR tv1576[rsp]
  012de	48 8b 49 68	 mov	 rcx, QWORD PTR [rcx+104]
  012e2	4c 8b 44 24 70	 mov	 r8, QWORD PTR current_opcode_table$[rsp]
  012e7	41 ff 14 c0	 call	 QWORD PTR [r8+rax*8]
  012eb	33 c0		 xor	 eax, eax
  012ed	85 c0		 test	 eax, eax
  012ef	75 9c		 jne	 SHORT $LN71@z900_run_s

; 1222 :                     UNROLLED_EXECUTE( current_opcode_table, GUESTREGS );

  012f1	48 8b 84 24 20
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  012f9	48 8b 80 70 08
	00 00		 mov	 rax, QWORD PTR [rax+2160]
  01300	48 8b 8c 24 20
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  01308	48 8b 89 70 08
	00 00		 mov	 rcx, QWORD PTR [rcx+2160]
  0130f	48 8b 89 08 02
	00 00		 mov	 rcx, QWORD PTR [rcx+520]
  01316	48 39 48 68	 cmp	 QWORD PTR [rax+104], rcx
  0131a	72 02		 jb	 SHORT $LN190@z900_run_s
  0131c	eb 69		 jmp	 SHORT $LN67@z900_run_s
$LN190@z900_run_s:
$LN74@z900_run_s:
  0131e	48 8b 84 24 20
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  01326	48 8b 80 70 08
	00 00		 mov	 rax, QWORD PTR [rax+2160]
  0132d	48 89 84 24 c0
	00 00 00	 mov	 QWORD PTR tv1572[rsp], rax
  01335	48 8b 8c 24 20
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0133d	48 8b 89 70 08
	00 00		 mov	 rcx, QWORD PTR [rcx+2160]
  01344	48 8b 49 68	 mov	 rcx, QWORD PTR [rcx+104]
  01348	e8 00 00 00 00	 call	 fetch_hw_noswap
  0134d	0f b7 c8	 movzx	 ecx, ax
  01350	e8 00 00 00 00	 call	 _byteswap_ushort
  01355	0f b7 c0	 movzx	 eax, ax
  01358	48 8b 8c 24 20
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  01360	48 8b 91 70 08
	00 00		 mov	 rdx, QWORD PTR [rcx+2160]
  01367	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR tv1572[rsp]
  0136f	48 8b 49 68	 mov	 rcx, QWORD PTR [rcx+104]
  01373	4c 8b 44 24 70	 mov	 r8, QWORD PTR current_opcode_table$[rsp]
  01378	41 ff 14 c0	 call	 QWORD PTR [r8+rax*8]
  0137c	33 c0		 xor	 eax, eax
  0137e	85 c0		 test	 eax, eax
  01380	75 9c		 jne	 SHORT $LN74@z900_run_s

; 1223 :                 }

  01382	e9 be fe ff ff	 jmp	 $LN66@z900_run_s
$LN67@z900_run_s:

; 1224 :                 regs->instcount +=  (i * 2);

  01387	48 8b 84 24 20
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0138f	8b 80 98 07 00
	00		 mov	 eax, DWORD PTR [rax+1944]
  01395	8b 4c 24 54	 mov	 ecx, DWORD PTR i$[rsp]
  01399	8d 04 48	 lea	 eax, DWORD PTR [rax+rcx*2]
  0139c	48 8b 8c 24 20
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  013a4	89 81 98 07 00
	00		 mov	 DWORD PTR [rcx+1944], eax

; 1225 :                 UPDATE_SYSBLK_INSTCOUNT( (i * 2) );

  013aa	8b 44 24 54	 mov	 eax, DWORD PTR i$[rsp]
  013ae	03 c0		 add	 eax, eax
  013b0	48 98		 cdqe
  013b2	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  013b9	48 81 c1 80 14
	00 00		 add	 rcx, 5248		; 00001480H
  013c0	48 8b d0	 mov	 rdx, rax
  013c3	e8 00 00 00 00	 call	 atomic_update64

; 1226 : 
; 1227 :                 /* Perform automatic instruction tracing if it's enabled */
; 1228 :                 do_automatic_tracing();

  013c8	e8 00 00 00 00	 call	 do_automatic_tracing

; 1229 :                 goto endloop;

  013cd	e9 f4 0e 00 00	 jmp	 $endloop$264
$txf_facility_loop$263:

; 1230 : 
; 1231 : #if defined( FEATURE_073_TRANSACT_EXEC_FACILITY )
; 1232 : 
; 1233 : txf_facility_loop:
; 1234 : 
; 1235 :                 SIE_PERFMON( SIE_PERF_EXEC );
; 1236 : 
; 1237 :                 if (GUESTREGS->txf_tnd)

  013d2	48 8b 84 24 20
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  013da	48 8b 80 70 08
	00 00		 mov	 rax, QWORD PTR [rax+2160]
  013e1	0f b6 80 58 0e
	00 00		 movzx	 eax, BYTE PTR [rax+3672]
  013e8	85 c0		 test	 eax, eax
  013ea	74 05		 je	 SHORT $LN191@z900_run_s

; 1238 :                     goto txf_slower_loop;

  013ec	e9 8a 03 00 00	 jmp	 $txf_slower_loop$265
$LN191@z900_run_s:
$LN77@z900_run_s:

; 1239 : 
; 1240 :                 PROCESS_TRACE( GUESTREGS, ip, sie_fetch_instruction );

  013f1	48 8b 84 24 20
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  013f9	48 8b 80 70 08
	00 00		 mov	 rax, QWORD PTR [rax+2160]
  01400	8b 80 28 07 00
	00		 mov	 eax, DWORD PTR [rax+1832]
  01406	c1 e8 10	 shr	 eax, 16
  01409	83 e0 01	 and	 eax, 1
  0140c	85 c0		 test	 eax, eax
  0140e	0f 84 18 01 00
	00		 je	 $LN192@z900_run_s
  01414	48 8b 54 24 60	 mov	 rdx, QWORD PTR ip$[rsp]
  01419	48 8b 84 24 20
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  01421	48 8b 88 70 08
	00 00		 mov	 rcx, QWORD PTR [rax+2160]
  01428	e8 00 00 00 00	 call	 z900_process_trace
  0142d	33 c0		 xor	 eax, eax
  0142f	83 f8 01	 cmp	 eax, 1
  01432	0f 84 f4 00 00
	00		 je	 $LN193@z900_run_s
  01438	48 8b 84 24 20
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  01440	48 8b 80 70 08
	00 00		 mov	 rax, QWORD PTR [rax+2160]
  01447	8b 80 28 07 00
	00		 mov	 eax, DWORD PTR [rax+1832]
  0144d	c1 e8 11	 shr	 eax, 17
  01450	83 e0 01	 and	 eax, 1
  01453	85 c0		 test	 eax, eax
  01455	0f 84 d1 00 00
	00		 je	 $LN193@z900_run_s
  0145b	48 8b 84 24 20
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  01463	48 8b 80 70 08
	00 00		 mov	 rax, QWORD PTR [rax+2160]
  0146a	48 83 b8 08 02
	00 00 00	 cmp	 QWORD PTR [rax+520], 0
  01472	0f 85 b4 00 00
	00		 jne	 $LN193@z900_run_s
  01478	48 8b 84 24 20
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  01480	48 8b 80 70 08
	00 00		 mov	 rax, QWORD PTR [rax+2160]
  01487	0f b7 80 3c 08
	00 00		 movzx	 eax, WORD PTR [rax+2108]
  0148e	89 84 24 94 00
	00 00		 mov	 DWORD PTR tv782[rsp], eax
  01495	48 8b 8c 24 20
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0149d	48 8b 89 70 08
	00 00		 mov	 rcx, QWORD PTR [rcx+2160]
  014a4	0f b7 89 3c 08
	00 00		 movzx	 ecx, WORD PTR [rcx+2108]
  014ab	48 8b 15 00 00
	00 00		 mov	 rdx, QWORD PTR __imp_sysblk
  014b2	0f b6 8c 0a 48
	0b 00 00	 movzx	 ecx, BYTE PTR [rdx+rcx+2888]
  014ba	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ptyp2short
  014c0	48 89 84 24 c8
	00 00 00	 mov	 QWORD PTR tv784[rsp], rax
  014c8	b9 01 00 00 00	 mov	 ecx, 1
  014cd	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  014d3	8b 8c 24 94 00
	00 00		 mov	 ecx, DWORD PTR tv782[rsp]
  014da	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  014de	48 8b 8c 24 c8
	00 00 00	 mov	 rcx, QWORD PTR tv784[rsp]
  014e6	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  014eb	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG195321
  014f2	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  014f7	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG195322
  014fe	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  01503	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  01508	41 b9 03 00 00
	00		 mov	 r9d, 3
  0150e	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG195323
  01515	ba d8 04 00 00	 mov	 edx, 1240		; 000004d8H
  0151a	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG195324
  01521	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg
  01527	e9 71 fa ff ff	 jmp	 $LN260@z900_run_s
$LN193@z900_run_s:
$LN192@z900_run_s:
  0152c	33 c0		 xor	 eax, eax
  0152e	85 c0		 test	 eax, eax
  01530	0f 85 bb fe ff
	ff		 jne	 $LN77@z900_run_s
$LN80@z900_run_s:

; 1241 :                 EXECUTE_INSTRUCTION( current_opcode_table, ip, GUESTREGS );

  01536	48 8b 4c 24 60	 mov	 rcx, QWORD PTR ip$[rsp]
  0153b	e8 00 00 00 00	 call	 fetch_hw_noswap
  01540	0f b7 c8	 movzx	 ecx, ax
  01543	e8 00 00 00 00	 call	 _byteswap_ushort
  01548	0f b7 c0	 movzx	 eax, ax
  0154b	48 8b 8c 24 20
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  01553	48 8b 91 70 08
	00 00		 mov	 rdx, QWORD PTR [rcx+2160]
  0155a	48 8b 4c 24 60	 mov	 rcx, QWORD PTR ip$[rsp]
  0155f	4c 8b 44 24 70	 mov	 r8, QWORD PTR current_opcode_table$[rsp]
  01564	41 ff 14 c0	 call	 QWORD PTR [r8+rax*8]
  01568	33 c0		 xor	 eax, eax
  0156a	85 c0		 test	 eax, eax
  0156c	75 c8		 jne	 SHORT $LN80@z900_run_s

; 1242 :                 regs->instcount++;

  0156e	48 8b 84 24 20
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  01576	8b 80 98 07 00
	00		 mov	 eax, DWORD PTR [rax+1944]
  0157c	ff c0		 inc	 eax
  0157e	48 8b 8c 24 20
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  01586	89 81 98 07 00
	00		 mov	 DWORD PTR [rcx+1944], eax

; 1243 :                 UPDATE_SYSBLK_INSTCOUNT( 1 );

  0158c	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  01593	48 05 80 14 00
	00		 add	 rax, 5248		; 00001480H
  01599	ba 01 00 00 00	 mov	 edx, 1
  0159e	48 8b c8	 mov	 rcx, rax
  015a1	e8 00 00 00 00	 call	 atomic_update64

; 1244 :                 SIE_PERFMON( SIE_PERF_EXEC_U );
; 1245 : 
; 1246 :                 for (i=0; i < MAX_CPU_LOOPS/2; i++)

  015a6	c7 44 24 54 00
	00 00 00	 mov	 DWORD PTR i$[rsp], 0
  015ae	eb 0a		 jmp	 SHORT $LN83@z900_run_s
$LN81@z900_run_s:
  015b0	8b 44 24 54	 mov	 eax, DWORD PTR i$[rsp]
  015b4	ff c0		 inc	 eax
  015b6	89 44 24 54	 mov	 DWORD PTR i$[rsp], eax
$LN83@z900_run_s:
  015ba	81 7c 24 54 80
	00 00 00	 cmp	 DWORD PTR i$[rsp], 128	; 00000080H
  015c2	0f 8d 68 01 00
	00		 jge	 $LN82@z900_run_s

; 1247 :                 {
; 1248 :                     if (GUESTREGS->txf_tnd)

  015c8	48 8b 84 24 20
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  015d0	48 8b 80 70 08
	00 00		 mov	 rax, QWORD PTR [rax+2160]
  015d7	0f b6 80 58 0e
	00 00		 movzx	 eax, BYTE PTR [rax+3672]
  015de	85 c0		 test	 eax, eax
  015e0	74 05		 je	 SHORT $LN194@z900_run_s

; 1249 :                         break;

  015e2	e9 49 01 00 00	 jmp	 $LN82@z900_run_s
$LN194@z900_run_s:

; 1250 : 
; 1251 :                     UNROLLED_EXECUTE( current_opcode_table, GUESTREGS );

  015e7	48 8b 84 24 20
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  015ef	48 8b 80 70 08
	00 00		 mov	 rax, QWORD PTR [rax+2160]
  015f6	48 8b 8c 24 20
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  015fe	48 8b 89 70 08
	00 00		 mov	 rcx, QWORD PTR [rcx+2160]
  01605	48 8b 89 08 02
	00 00		 mov	 rcx, QWORD PTR [rcx+520]
  0160c	48 39 48 68	 cmp	 QWORD PTR [rax+104], rcx
  01610	72 05		 jb	 SHORT $LN195@z900_run_s
  01612	e9 19 01 00 00	 jmp	 $LN82@z900_run_s
$LN195@z900_run_s:
$LN86@z900_run_s:
  01617	48 8b 84 24 20
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0161f	48 8b 80 70 08
	00 00		 mov	 rax, QWORD PTR [rax+2160]
  01626	48 89 84 24 d0
	00 00 00	 mov	 QWORD PTR tv1559[rsp], rax
  0162e	48 8b 8c 24 20
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  01636	48 8b 89 70 08
	00 00		 mov	 rcx, QWORD PTR [rcx+2160]
  0163d	48 8b 49 68	 mov	 rcx, QWORD PTR [rcx+104]
  01641	e8 00 00 00 00	 call	 fetch_hw_noswap
  01646	0f b7 c8	 movzx	 ecx, ax
  01649	e8 00 00 00 00	 call	 _byteswap_ushort
  0164e	0f b7 c0	 movzx	 eax, ax
  01651	48 8b 8c 24 20
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  01659	48 8b 91 70 08
	00 00		 mov	 rdx, QWORD PTR [rcx+2160]
  01660	48 8b 8c 24 d0
	00 00 00	 mov	 rcx, QWORD PTR tv1559[rsp]
  01668	48 8b 49 68	 mov	 rcx, QWORD PTR [rcx+104]
  0166c	4c 8b 44 24 70	 mov	 r8, QWORD PTR current_opcode_table$[rsp]
  01671	41 ff 14 c0	 call	 QWORD PTR [r8+rax*8]
  01675	33 c0		 xor	 eax, eax
  01677	85 c0		 test	 eax, eax
  01679	75 9c		 jne	 SHORT $LN86@z900_run_s

; 1252 : 
; 1253 :                     if (GUESTREGS->txf_tnd)

  0167b	48 8b 84 24 20
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  01683	48 8b 80 70 08
	00 00		 mov	 rax, QWORD PTR [rax+2160]
  0168a	0f b6 80 58 0e
	00 00		 movzx	 eax, BYTE PTR [rax+3672]
  01691	85 c0		 test	 eax, eax
  01693	74 05		 je	 SHORT $LN196@z900_run_s

; 1254 :                         break;

  01695	e9 96 00 00 00	 jmp	 $LN82@z900_run_s
$LN196@z900_run_s:

; 1255 : 
; 1256 :                     UNROLLED_EXECUTE( current_opcode_table, GUESTREGS );

  0169a	48 8b 84 24 20
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  016a2	48 8b 80 70 08
	00 00		 mov	 rax, QWORD PTR [rax+2160]
  016a9	48 8b 8c 24 20
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  016b1	48 8b 89 70 08
	00 00		 mov	 rcx, QWORD PTR [rcx+2160]
  016b8	48 8b 89 08 02
	00 00		 mov	 rcx, QWORD PTR [rcx+520]
  016bf	48 39 48 68	 cmp	 QWORD PTR [rax+104], rcx
  016c3	72 02		 jb	 SHORT $LN197@z900_run_s
  016c5	eb 69		 jmp	 SHORT $LN82@z900_run_s
$LN197@z900_run_s:
$LN89@z900_run_s:
  016c7	48 8b 84 24 20
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  016cf	48 8b 80 70 08
	00 00		 mov	 rax, QWORD PTR [rax+2160]
  016d6	48 89 84 24 d8
	00 00 00	 mov	 QWORD PTR tv1554[rsp], rax
  016de	48 8b 8c 24 20
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  016e6	48 8b 89 70 08
	00 00		 mov	 rcx, QWORD PTR [rcx+2160]
  016ed	48 8b 49 68	 mov	 rcx, QWORD PTR [rcx+104]
  016f1	e8 00 00 00 00	 call	 fetch_hw_noswap
  016f6	0f b7 c8	 movzx	 ecx, ax
  016f9	e8 00 00 00 00	 call	 _byteswap_ushort
  016fe	0f b7 c0	 movzx	 eax, ax
  01701	48 8b 8c 24 20
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  01709	48 8b 91 70 08
	00 00		 mov	 rdx, QWORD PTR [rcx+2160]
  01710	48 8b 8c 24 d8
	00 00 00	 mov	 rcx, QWORD PTR tv1554[rsp]
  01718	48 8b 49 68	 mov	 rcx, QWORD PTR [rcx+104]
  0171c	4c 8b 44 24 70	 mov	 r8, QWORD PTR current_opcode_table$[rsp]
  01721	41 ff 14 c0	 call	 QWORD PTR [r8+rax*8]
  01725	33 c0		 xor	 eax, eax
  01727	85 c0		 test	 eax, eax
  01729	75 9c		 jne	 SHORT $LN89@z900_run_s

; 1257 :                 }

  0172b	e9 80 fe ff ff	 jmp	 $LN81@z900_run_s
$LN82@z900_run_s:

; 1258 :                 regs->instcount +=  (i * 2);

  01730	48 8b 84 24 20
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  01738	8b 80 98 07 00
	00		 mov	 eax, DWORD PTR [rax+1944]
  0173e	8b 4c 24 54	 mov	 ecx, DWORD PTR i$[rsp]
  01742	8d 04 48	 lea	 eax, DWORD PTR [rax+rcx*2]
  01745	48 8b 8c 24 20
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0174d	89 81 98 07 00
	00		 mov	 DWORD PTR [rcx+1944], eax

; 1259 :                 UPDATE_SYSBLK_INSTCOUNT( (i * 2) );

  01753	8b 44 24 54	 mov	 eax, DWORD PTR i$[rsp]
  01757	03 c0		 add	 eax, eax
  01759	48 98		 cdqe
  0175b	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  01762	48 81 c1 80 14
	00 00		 add	 rcx, 5248		; 00001480H
  01769	48 8b d0	 mov	 rdx, rax
  0176c	e8 00 00 00 00	 call	 atomic_update64

; 1260 : 
; 1261 :                 /* Perform automatic instruction tracing if it's enabled */
; 1262 :                 do_automatic_tracing();

  01771	e8 00 00 00 00	 call	 do_automatic_tracing

; 1263 :                 goto endloop;

  01776	e9 4b 0b 00 00	 jmp	 $endloop$264
$txf_slower_loop$265:
$LN92@z900_run_s:

; 1264 : 
; 1265 : txf_slower_loop:
; 1266 : 
; 1267 :                 PROCESS_TRACE( GUESTREGS, ip, sie_fetch_instruction );

  0177b	48 8b 84 24 20
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  01783	48 8b 80 70 08
	00 00		 mov	 rax, QWORD PTR [rax+2160]
  0178a	8b 80 28 07 00
	00		 mov	 eax, DWORD PTR [rax+1832]
  01790	c1 e8 10	 shr	 eax, 16
  01793	83 e0 01	 and	 eax, 1
  01796	85 c0		 test	 eax, eax
  01798	0f 84 18 01 00
	00		 je	 $LN198@z900_run_s
  0179e	48 8b 54 24 60	 mov	 rdx, QWORD PTR ip$[rsp]
  017a3	48 8b 84 24 20
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  017ab	48 8b 88 70 08
	00 00		 mov	 rcx, QWORD PTR [rax+2160]
  017b2	e8 00 00 00 00	 call	 z900_process_trace
  017b7	33 c0		 xor	 eax, eax
  017b9	83 f8 01	 cmp	 eax, 1
  017bc	0f 84 f4 00 00
	00		 je	 $LN199@z900_run_s
  017c2	48 8b 84 24 20
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  017ca	48 8b 80 70 08
	00 00		 mov	 rax, QWORD PTR [rax+2160]
  017d1	8b 80 28 07 00
	00		 mov	 eax, DWORD PTR [rax+1832]
  017d7	c1 e8 11	 shr	 eax, 17
  017da	83 e0 01	 and	 eax, 1
  017dd	85 c0		 test	 eax, eax
  017df	0f 84 d1 00 00
	00		 je	 $LN199@z900_run_s
  017e5	48 8b 84 24 20
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  017ed	48 8b 80 70 08
	00 00		 mov	 rax, QWORD PTR [rax+2160]
  017f4	48 83 b8 08 02
	00 00 00	 cmp	 QWORD PTR [rax+520], 0
  017fc	0f 85 b4 00 00
	00		 jne	 $LN199@z900_run_s
  01802	48 8b 84 24 20
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0180a	48 8b 80 70 08
	00 00		 mov	 rax, QWORD PTR [rax+2160]
  01811	0f b7 80 3c 08
	00 00		 movzx	 eax, WORD PTR [rax+2108]
  01818	89 84 24 98 00
	00 00		 mov	 DWORD PTR tv899[rsp], eax
  0181f	48 8b 8c 24 20
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  01827	48 8b 89 70 08
	00 00		 mov	 rcx, QWORD PTR [rcx+2160]
  0182e	0f b7 89 3c 08
	00 00		 movzx	 ecx, WORD PTR [rcx+2108]
  01835	48 8b 15 00 00
	00 00		 mov	 rdx, QWORD PTR __imp_sysblk
  0183c	0f b6 8c 0a 48
	0b 00 00	 movzx	 ecx, BYTE PTR [rdx+rcx+2888]
  01844	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ptyp2short
  0184a	48 89 84 24 e0
	00 00 00	 mov	 QWORD PTR tv901[rsp], rax
  01852	b9 01 00 00 00	 mov	 ecx, 1
  01857	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  0185d	8b 8c 24 98 00
	00 00		 mov	 ecx, DWORD PTR tv899[rsp]
  01864	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  01868	48 8b 8c 24 e0
	00 00 00	 mov	 rcx, QWORD PTR tv901[rsp]
  01870	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  01875	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG195331
  0187c	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  01881	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG195332
  01888	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  0188d	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  01892	41 b9 03 00 00
	00		 mov	 r9d, 3
  01898	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG195333
  0189f	ba f3 04 00 00	 mov	 edx, 1267		; 000004f3H
  018a4	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG195334
  018ab	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg
  018b1	e9 e7 f6 ff ff	 jmp	 $LN261@z900_run_s
$LN199@z900_run_s:
$LN198@z900_run_s:
  018b6	33 c0		 xor	 eax, eax
  018b8	85 c0		 test	 eax, eax
  018ba	0f 85 bb fe ff
	ff		 jne	 $LN92@z900_run_s
$LN95@z900_run_s:
$LN98@z900_run_s:

; 1268 :                 TXF_EXECUTE_INSTRUCTION( current_opcode_table, ip, GUESTREGS );

  018c0	48 8b 84 24 20
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  018c8	48 8b 80 70 08
	00 00		 mov	 rax, QWORD PTR [rax+2160]
  018cf	0f b6 80 58 0e
	00 00		 movzx	 eax, BYTE PTR [rax+3672]
  018d6	85 c0		 test	 eax, eax
  018d8	0f 84 61 02 00
	00		 je	 $LN200@z900_run_s
$LN101@z900_run_s:
  018de	33 c0		 xor	 eax, eax
  018e0	83 f8 01	 cmp	 eax, 1
  018e3	0f 84 99 00 00
	00		 je	 $LN201@z900_run_s
  018e9	48 8b 84 24 20
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  018f1	48 8b 80 70 08
	00 00		 mov	 rax, QWORD PTR [rax+2160]
  018f8	0f b6 80 4c 0e
	00 00		 movzx	 eax, BYTE PTR [rax+3660]
  018ff	85 c0		 test	 eax, eax
  01901	74 7f		 je	 SHORT $LN201@z900_run_s
  01903	48 8b 84 24 20
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0190b	48 8b 80 70 08
	00 00		 mov	 rax, QWORD PTR [rax+2160]
  01912	48 8b 8c 24 20
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0191a	48 8b 89 70 08
	00 00		 mov	 rcx, QWORD PTR [rcx+2160]
  01921	48 8b 89 60 af
	00 00		 mov	 rcx, QWORD PTR [rcx+44896]
  01928	48 39 48 68	 cmp	 QWORD PTR [rax+104], rcx
  0192c	72 54		 jb	 SHORT $LN201@z900_run_s
  0192e	48 8b 84 24 20
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  01936	48 8b 80 70 08
	00 00		 mov	 rax, QWORD PTR [rax+2160]
  0193d	8b 80 84 af 00
	00		 mov	 eax, DWORD PTR [rax+44932]
  01943	0f ba e8 1f	 bts	 eax, 31
  01947	48 8b 8c 24 20
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0194f	48 8b 89 70 08
	00 00		 mov	 rcx, QWORD PTR [rcx+2160]
  01956	89 81 84 af 00
	00		 mov	 DWORD PTR [rcx+44932], eax
  0195c	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG195337
  01963	41 b8 0b 00 00
	00		 mov	 r8d, 11
  01969	ba fe ff ff ff	 mov	 edx, -2
  0196e	48 8b 84 24 20
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  01976	48 8b 88 70 08
	00 00		 mov	 rcx, QWORD PTR [rax+2160]
  0197d	e8 00 00 00 00	 call	 z900_abort_transaction
$LN201@z900_run_s:
  01982	33 c0		 xor	 eax, eax
  01984	85 c0		 test	 eax, eax
  01986	0f 85 52 ff ff
	ff		 jne	 $LN101@z900_run_s
  0198c	48 8b 84 24 20
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  01994	48 8b 80 70 08
	00 00		 mov	 rax, QWORD PTR [rax+2160]
  0199b	0f b7 80 5e 0e
	00 00		 movzx	 eax, WORD PTR [rax+3678]
  019a2	66 ff c0	 inc	 ax
  019a5	48 8b 8c 24 20
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  019ad	48 8b 89 70 08
	00 00		 mov	 rcx, QWORD PTR [rcx+2160]
  019b4	66 89 81 5e 0e
	00 00		 mov	 WORD PTR [rcx+3678], ax
$LN104@z900_run_s:
  019bb	33 c0		 xor	 eax, eax
  019bd	83 f8 01	 cmp	 eax, 1
  019c0	0f 84 a8 00 00
	00		 je	 $LN202@z900_run_s
  019c6	48 8b 84 24 20
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  019ce	48 8b 80 70 08
	00 00		 mov	 rax, QWORD PTR [rax+2160]
  019d5	0f b6 80 4c 0e
	00 00		 movzx	 eax, BYTE PTR [rax+3660]
  019dc	85 c0		 test	 eax, eax
  019de	0f 84 8a 00 00
	00		 je	 $LN202@z900_run_s
  019e4	48 8b 84 24 20
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  019ec	48 8b 80 70 08
	00 00		 mov	 rax, QWORD PTR [rax+2160]
  019f3	0f b7 80 5e 0e
	00 00		 movzx	 eax, WORD PTR [rax+3678]
  019fa	83 f8 20	 cmp	 eax, 32			; 00000020H
  019fd	7e 6f		 jle	 SHORT $LN202@z900_run_s
  019ff	41 b8 02 00 00
	00		 mov	 r8d, 2
  01a05	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG195339
  01a0c	48 8b 4c 24 60	 mov	 rcx, QWORD PTR ip$[rsp]
  01a11	e8 00 00 00 00	 call	 memcmp
  01a16	85 c0		 test	 eax, eax
  01a18	74 54		 je	 SHORT $LN202@z900_run_s
  01a1a	48 8b 84 24 20
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  01a22	48 8b 80 70 08
	00 00		 mov	 rax, QWORD PTR [rax+2160]
  01a29	8b 80 84 af 00
	00		 mov	 eax, DWORD PTR [rax+44932]
  01a2f	0f ba e8 1e	 bts	 eax, 30
  01a33	48 8b 8c 24 20
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  01a3b	48 8b 89 70 08
	00 00		 mov	 rcx, QWORD PTR [rcx+2160]
  01a42	89 81 84 af 00
	00		 mov	 DWORD PTR [rcx+44932], eax
  01a48	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG195340
  01a4f	41 b8 0b 00 00
	00		 mov	 r8d, 11
  01a55	ba fe ff ff ff	 mov	 edx, -2
  01a5a	48 8b 84 24 20
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  01a62	48 8b 88 70 08
	00 00		 mov	 rcx, QWORD PTR [rax+2160]
  01a69	e8 00 00 00 00	 call	 z900_abort_transaction
$LN202@z900_run_s:
  01a6e	33 c0		 xor	 eax, eax
  01a70	85 c0		 test	 eax, eax
  01a72	0f 85 43 ff ff
	ff		 jne	 $LN104@z900_run_s
$LN107@z900_run_s:
  01a78	33 c0		 xor	 eax, eax
  01a7a	83 f8 01	 cmp	 eax, 1
  01a7d	0f 84 b2 00 00
	00		 je	 $LN203@z900_run_s
  01a83	48 8b 84 24 20
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  01a8b	48 8b 80 70 08
	00 00		 mov	 rax, QWORD PTR [rax+2160]
  01a92	0f b7 80 60 0e
	00 00		 movzx	 eax, WORD PTR [rax+3680]
  01a99	85 c0		 test	 eax, eax
  01a9b	0f 84 94 00 00
	00		 je	 $LN203@z900_run_s
  01aa1	48 8b 84 24 20
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  01aa9	48 8b 80 70 08
	00 00		 mov	 rax, QWORD PTR [rax+2160]
  01ab0	0f b7 80 5e 0e
	00 00		 movzx	 eax, WORD PTR [rax+3678]
  01ab7	48 8b 8c 24 20
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  01abf	48 8b 89 70 08
	00 00		 mov	 rcx, QWORD PTR [rcx+2160]
  01ac6	0f b7 89 60 0e
	00 00		 movzx	 ecx, WORD PTR [rcx+3680]
  01acd	3b c1		 cmp	 eax, ecx
  01acf	7c 64		 jl	 SHORT $LN203@z900_run_s
  01ad1	48 8b 84 24 20
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  01ad9	48 8b 80 70 08
	00 00		 mov	 rax, QWORD PTR [rax+2160]
  01ae0	8b 80 84 af 00
	00		 mov	 eax, DWORD PTR [rax+44932]
  01ae6	0f ba e8 1d	 bts	 eax, 29
  01aea	48 8b 8c 24 20
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  01af2	48 8b 89 70 08
	00 00		 mov	 rcx, QWORD PTR [rcx+2160]
  01af9	89 81 84 af 00
	00		 mov	 DWORD PTR [rcx+44932], eax
  01aff	48 8b 84 24 20
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  01b07	48 8b 80 70 08
	00 00		 mov	 rax, QWORD PTR [rax+2160]
  01b0e	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG195342
  01b15	44 8b 80 0c af
	00 00		 mov	 r8d, DWORD PTR [rax+44812]
  01b1c	ba fe ff ff ff	 mov	 edx, -2
  01b21	48 8b 84 24 20
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  01b29	48 8b 88 70 08
	00 00		 mov	 rcx, QWORD PTR [rax+2160]
  01b30	e8 00 00 00 00	 call	 z900_abort_transaction
$LN203@z900_run_s:
  01b35	33 c0		 xor	 eax, eax
  01b37	85 c0		 test	 eax, eax
  01b39	0f 85 39 ff ff
	ff		 jne	 $LN107@z900_run_s
$LN200@z900_run_s:
  01b3f	33 c0		 xor	 eax, eax
  01b41	85 c0		 test	 eax, eax
  01b43	0f 85 77 fd ff
	ff		 jne	 $LN98@z900_run_s
  01b49	48 8b 4c 24 60	 mov	 rcx, QWORD PTR ip$[rsp]
  01b4e	e8 00 00 00 00	 call	 fetch_hw_noswap
  01b53	0f b7 c8	 movzx	 ecx, ax
  01b56	e8 00 00 00 00	 call	 _byteswap_ushort
  01b5b	0f b7 c0	 movzx	 eax, ax
  01b5e	48 8b 8c 24 20
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  01b66	48 8b 91 70 08
	00 00		 mov	 rdx, QWORD PTR [rcx+2160]
  01b6d	48 8b 4c 24 60	 mov	 rcx, QWORD PTR ip$[rsp]
  01b72	4c 8b 44 24 70	 mov	 r8, QWORD PTR current_opcode_table$[rsp]
  01b77	41 ff 14 c0	 call	 QWORD PTR [r8+rax*8]
  01b7b	33 c0		 xor	 eax, eax
  01b7d	85 c0		 test	 eax, eax
  01b7f	0f 85 3b fd ff
	ff		 jne	 $LN95@z900_run_s

; 1269 :                 regs->instcount++;

  01b85	48 8b 84 24 20
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  01b8d	8b 80 98 07 00
	00		 mov	 eax, DWORD PTR [rax+1944]
  01b93	ff c0		 inc	 eax
  01b95	48 8b 8c 24 20
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  01b9d	89 81 98 07 00
	00		 mov	 DWORD PTR [rcx+1944], eax

; 1270 :                 UPDATE_SYSBLK_INSTCOUNT( 1 );

  01ba3	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  01baa	48 05 80 14 00
	00		 add	 rax, 5248		; 00001480H
  01bb0	ba 01 00 00 00	 mov	 edx, 1
  01bb5	48 8b c8	 mov	 rcx, rax
  01bb8	e8 00 00 00 00	 call	 atomic_update64

; 1271 :                 SIE_PERFMON( SIE_PERF_EXEC_U );
; 1272 : 
; 1273 :                 for (i=0; i < MAX_CPU_LOOPS/2; i++)

  01bbd	c7 44 24 54 00
	00 00 00	 mov	 DWORD PTR i$[rsp], 0
  01bc5	eb 0a		 jmp	 SHORT $LN110@z900_run_s
$LN108@z900_run_s:
  01bc7	8b 44 24 54	 mov	 eax, DWORD PTR i$[rsp]
  01bcb	ff c0		 inc	 eax
  01bcd	89 44 24 54	 mov	 DWORD PTR i$[rsp], eax
$LN110@z900_run_s:
  01bd1	81 7c 24 54 80
	00 00 00	 cmp	 DWORD PTR i$[rsp], 128	; 00000080H
  01bd9	0f 8d a1 06 00
	00		 jge	 $LN109@z900_run_s

; 1274 :                 {
; 1275 :                     if (!GUESTREGS->txf_tnd)

  01bdf	48 8b 84 24 20
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  01be7	48 8b 80 70 08
	00 00		 mov	 rax, QWORD PTR [rax+2160]
  01bee	0f b6 80 58 0e
	00 00		 movzx	 eax, BYTE PTR [rax+3672]
  01bf5	85 c0		 test	 eax, eax
  01bf7	75 05		 jne	 SHORT $LN204@z900_run_s

; 1276 :                         break;

  01bf9	e9 82 06 00 00	 jmp	 $LN109@z900_run_s
$LN204@z900_run_s:

; 1277 : 
; 1278 :                     TXF_UNROLLED_EXECUTE( current_opcode_table, GUESTREGS );

  01bfe	48 8b 84 24 20
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  01c06	48 8b 80 70 08
	00 00		 mov	 rax, QWORD PTR [rax+2160]
  01c0d	48 8b 8c 24 20
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  01c15	48 8b 89 70 08
	00 00		 mov	 rcx, QWORD PTR [rcx+2160]
  01c1c	48 8b 89 08 02
	00 00		 mov	 rcx, QWORD PTR [rcx+520]
  01c23	48 39 48 68	 cmp	 QWORD PTR [rax+104], rcx
  01c27	72 05		 jb	 SHORT $LN205@z900_run_s
  01c29	e9 52 06 00 00	 jmp	 $LN109@z900_run_s
$LN205@z900_run_s:
$LN113@z900_run_s:
$LN116@z900_run_s:
  01c2e	48 8b 84 24 20
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  01c36	48 8b 80 70 08
	00 00		 mov	 rax, QWORD PTR [rax+2160]
  01c3d	0f b6 80 58 0e
	00 00		 movzx	 eax, BYTE PTR [rax+3672]
  01c44	85 c0		 test	 eax, eax
  01c46	0f 84 6f 02 00
	00		 je	 $LN206@z900_run_s
$LN119@z900_run_s:
  01c4c	33 c0		 xor	 eax, eax
  01c4e	83 f8 01	 cmp	 eax, 1
  01c51	0f 84 99 00 00
	00		 je	 $LN207@z900_run_s
  01c57	48 8b 84 24 20
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  01c5f	48 8b 80 70 08
	00 00		 mov	 rax, QWORD PTR [rax+2160]
  01c66	0f b6 80 4c 0e
	00 00		 movzx	 eax, BYTE PTR [rax+3660]
  01c6d	85 c0		 test	 eax, eax
  01c6f	74 7f		 je	 SHORT $LN207@z900_run_s
  01c71	48 8b 84 24 20
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  01c79	48 8b 80 70 08
	00 00		 mov	 rax, QWORD PTR [rax+2160]
  01c80	48 8b 8c 24 20
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  01c88	48 8b 89 70 08
	00 00		 mov	 rcx, QWORD PTR [rcx+2160]
  01c8f	48 8b 89 60 af
	00 00		 mov	 rcx, QWORD PTR [rcx+44896]
  01c96	48 39 48 68	 cmp	 QWORD PTR [rax+104], rcx
  01c9a	72 54		 jb	 SHORT $LN207@z900_run_s
  01c9c	48 8b 84 24 20
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  01ca4	48 8b 80 70 08
	00 00		 mov	 rax, QWORD PTR [rax+2160]
  01cab	8b 80 84 af 00
	00		 mov	 eax, DWORD PTR [rax+44932]
  01cb1	0f ba e8 1f	 bts	 eax, 31
  01cb5	48 8b 8c 24 20
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  01cbd	48 8b 89 70 08
	00 00		 mov	 rcx, QWORD PTR [rcx+2160]
  01cc4	89 81 84 af 00
	00		 mov	 DWORD PTR [rcx+44932], eax
  01cca	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG195347
  01cd1	41 b8 0b 00 00
	00		 mov	 r8d, 11
  01cd7	ba fe ff ff ff	 mov	 edx, -2
  01cdc	48 8b 84 24 20
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  01ce4	48 8b 88 70 08
	00 00		 mov	 rcx, QWORD PTR [rax+2160]
  01ceb	e8 00 00 00 00	 call	 z900_abort_transaction
$LN207@z900_run_s:
  01cf0	33 c0		 xor	 eax, eax
  01cf2	85 c0		 test	 eax, eax
  01cf4	0f 85 52 ff ff
	ff		 jne	 $LN119@z900_run_s
  01cfa	48 8b 84 24 20
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  01d02	48 8b 80 70 08
	00 00		 mov	 rax, QWORD PTR [rax+2160]
  01d09	0f b7 80 5e 0e
	00 00		 movzx	 eax, WORD PTR [rax+3678]
  01d10	66 ff c0	 inc	 ax
  01d13	48 8b 8c 24 20
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  01d1b	48 8b 89 70 08
	00 00		 mov	 rcx, QWORD PTR [rcx+2160]
  01d22	66 89 81 5e 0e
	00 00		 mov	 WORD PTR [rcx+3678], ax
$LN122@z900_run_s:
  01d29	33 c0		 xor	 eax, eax
  01d2b	83 f8 01	 cmp	 eax, 1
  01d2e	0f 84 b6 00 00
	00		 je	 $LN208@z900_run_s
  01d34	48 8b 84 24 20
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  01d3c	48 8b 80 70 08
	00 00		 mov	 rax, QWORD PTR [rax+2160]
  01d43	0f b6 80 4c 0e
	00 00		 movzx	 eax, BYTE PTR [rax+3660]
  01d4a	85 c0		 test	 eax, eax
  01d4c	0f 84 98 00 00
	00		 je	 $LN208@z900_run_s
  01d52	48 8b 84 24 20
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  01d5a	48 8b 80 70 08
	00 00		 mov	 rax, QWORD PTR [rax+2160]
  01d61	0f b7 80 5e 0e
	00 00		 movzx	 eax, WORD PTR [rax+3678]
  01d68	83 f8 20	 cmp	 eax, 32			; 00000020H
  01d6b	7e 7d		 jle	 SHORT $LN208@z900_run_s
  01d6d	48 8b 84 24 20
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  01d75	48 8b 80 70 08
	00 00		 mov	 rax, QWORD PTR [rax+2160]
  01d7c	41 b8 02 00 00
	00		 mov	 r8d, 2
  01d82	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG195349
  01d89	48 8b 48 68	 mov	 rcx, QWORD PTR [rax+104]
  01d8d	e8 00 00 00 00	 call	 memcmp
  01d92	85 c0		 test	 eax, eax
  01d94	74 54		 je	 SHORT $LN208@z900_run_s
  01d96	48 8b 84 24 20
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  01d9e	48 8b 80 70 08
	00 00		 mov	 rax, QWORD PTR [rax+2160]
  01da5	8b 80 84 af 00
	00		 mov	 eax, DWORD PTR [rax+44932]
  01dab	0f ba e8 1e	 bts	 eax, 30
  01daf	48 8b 8c 24 20
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  01db7	48 8b 89 70 08
	00 00		 mov	 rcx, QWORD PTR [rcx+2160]
  01dbe	89 81 84 af 00
	00		 mov	 DWORD PTR [rcx+44932], eax
  01dc4	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG195350
  01dcb	41 b8 0b 00 00
	00		 mov	 r8d, 11
  01dd1	ba fe ff ff ff	 mov	 edx, -2
  01dd6	48 8b 84 24 20
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  01dde	48 8b 88 70 08
	00 00		 mov	 rcx, QWORD PTR [rax+2160]
  01de5	e8 00 00 00 00	 call	 z900_abort_transaction
$LN208@z900_run_s:
  01dea	33 c0		 xor	 eax, eax
  01dec	85 c0		 test	 eax, eax
  01dee	0f 85 35 ff ff
	ff		 jne	 $LN122@z900_run_s
$LN125@z900_run_s:
  01df4	33 c0		 xor	 eax, eax
  01df6	83 f8 01	 cmp	 eax, 1
  01df9	0f 84 b2 00 00
	00		 je	 $LN209@z900_run_s
  01dff	48 8b 84 24 20
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  01e07	48 8b 80 70 08
	00 00		 mov	 rax, QWORD PTR [rax+2160]
  01e0e	0f b7 80 60 0e
	00 00		 movzx	 eax, WORD PTR [rax+3680]
  01e15	85 c0		 test	 eax, eax
  01e17	0f 84 94 00 00
	00		 je	 $LN209@z900_run_s
  01e1d	48 8b 84 24 20
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  01e25	48 8b 80 70 08
	00 00		 mov	 rax, QWORD PTR [rax+2160]
  01e2c	0f b7 80 5e 0e
	00 00		 movzx	 eax, WORD PTR [rax+3678]
  01e33	48 8b 8c 24 20
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  01e3b	48 8b 89 70 08
	00 00		 mov	 rcx, QWORD PTR [rcx+2160]
  01e42	0f b7 89 60 0e
	00 00		 movzx	 ecx, WORD PTR [rcx+3680]
  01e49	3b c1		 cmp	 eax, ecx
  01e4b	7c 64		 jl	 SHORT $LN209@z900_run_s
  01e4d	48 8b 84 24 20
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  01e55	48 8b 80 70 08
	00 00		 mov	 rax, QWORD PTR [rax+2160]
  01e5c	8b 80 84 af 00
	00		 mov	 eax, DWORD PTR [rax+44932]
  01e62	0f ba e8 1d	 bts	 eax, 29
  01e66	48 8b 8c 24 20
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  01e6e	48 8b 89 70 08
	00 00		 mov	 rcx, QWORD PTR [rcx+2160]
  01e75	89 81 84 af 00
	00		 mov	 DWORD PTR [rcx+44932], eax
  01e7b	48 8b 84 24 20
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  01e83	48 8b 80 70 08
	00 00		 mov	 rax, QWORD PTR [rax+2160]
  01e8a	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG195352
  01e91	44 8b 80 0c af
	00 00		 mov	 r8d, DWORD PTR [rax+44812]
  01e98	ba fe ff ff ff	 mov	 edx, -2
  01e9d	48 8b 84 24 20
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  01ea5	48 8b 88 70 08
	00 00		 mov	 rcx, QWORD PTR [rax+2160]
  01eac	e8 00 00 00 00	 call	 z900_abort_transaction
$LN209@z900_run_s:
  01eb1	33 c0		 xor	 eax, eax
  01eb3	85 c0		 test	 eax, eax
  01eb5	0f 85 39 ff ff
	ff		 jne	 $LN125@z900_run_s
$LN206@z900_run_s:
  01ebb	33 c0		 xor	 eax, eax
  01ebd	85 c0		 test	 eax, eax
  01ebf	0f 85 69 fd ff
	ff		 jne	 $LN116@z900_run_s
  01ec5	48 8b 84 24 20
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  01ecd	48 8b 80 70 08
	00 00		 mov	 rax, QWORD PTR [rax+2160]
  01ed4	48 89 84 24 e8
	00 00 00	 mov	 QWORD PTR tv1505[rsp], rax
  01edc	48 8b 8c 24 20
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  01ee4	48 8b 89 70 08
	00 00		 mov	 rcx, QWORD PTR [rcx+2160]
  01eeb	48 8b 49 68	 mov	 rcx, QWORD PTR [rcx+104]
  01eef	e8 00 00 00 00	 call	 fetch_hw_noswap
  01ef4	0f b7 c8	 movzx	 ecx, ax
  01ef7	e8 00 00 00 00	 call	 _byteswap_ushort
  01efc	0f b7 c0	 movzx	 eax, ax
  01eff	48 8b 8c 24 20
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  01f07	48 8b 91 70 08
	00 00		 mov	 rdx, QWORD PTR [rcx+2160]
  01f0e	48 8b 8c 24 e8
	00 00 00	 mov	 rcx, QWORD PTR tv1505[rsp]
  01f16	48 8b 49 68	 mov	 rcx, QWORD PTR [rcx+104]
  01f1a	4c 8b 44 24 70	 mov	 r8, QWORD PTR current_opcode_table$[rsp]
  01f1f	41 ff 14 c0	 call	 QWORD PTR [r8+rax*8]
  01f23	33 c0		 xor	 eax, eax
  01f25	85 c0		 test	 eax, eax
  01f27	0f 85 01 fd ff
	ff		 jne	 $LN113@z900_run_s

; 1279 : 
; 1280 :                     if (!GUESTREGS->txf_tnd)

  01f2d	48 8b 84 24 20
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  01f35	48 8b 80 70 08
	00 00		 mov	 rax, QWORD PTR [rax+2160]
  01f3c	0f b6 80 58 0e
	00 00		 movzx	 eax, BYTE PTR [rax+3672]
  01f43	85 c0		 test	 eax, eax
  01f45	75 05		 jne	 SHORT $LN210@z900_run_s

; 1281 :                         break;

  01f47	e9 34 03 00 00	 jmp	 $LN109@z900_run_s
$LN210@z900_run_s:

; 1282 : 
; 1283 :                     TXF_UNROLLED_EXECUTE( current_opcode_table, GUESTREGS );

  01f4c	48 8b 84 24 20
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  01f54	48 8b 80 70 08
	00 00		 mov	 rax, QWORD PTR [rax+2160]
  01f5b	48 8b 8c 24 20
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  01f63	48 8b 89 70 08
	00 00		 mov	 rcx, QWORD PTR [rcx+2160]
  01f6a	48 8b 89 08 02
	00 00		 mov	 rcx, QWORD PTR [rcx+520]
  01f71	48 39 48 68	 cmp	 QWORD PTR [rax+104], rcx
  01f75	72 05		 jb	 SHORT $LN211@z900_run_s
  01f77	e9 04 03 00 00	 jmp	 $LN109@z900_run_s
$LN211@z900_run_s:
$LN128@z900_run_s:
$LN131@z900_run_s:
  01f7c	48 8b 84 24 20
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  01f84	48 8b 80 70 08
	00 00		 mov	 rax, QWORD PTR [rax+2160]
  01f8b	0f b6 80 58 0e
	00 00		 movzx	 eax, BYTE PTR [rax+3672]
  01f92	85 c0		 test	 eax, eax
  01f94	0f 84 6f 02 00
	00		 je	 $LN212@z900_run_s
$LN134@z900_run_s:
  01f9a	33 c0		 xor	 eax, eax
  01f9c	83 f8 01	 cmp	 eax, 1
  01f9f	0f 84 99 00 00
	00		 je	 $LN213@z900_run_s
  01fa5	48 8b 84 24 20
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  01fad	48 8b 80 70 08
	00 00		 mov	 rax, QWORD PTR [rax+2160]
  01fb4	0f b6 80 4c 0e
	00 00		 movzx	 eax, BYTE PTR [rax+3660]
  01fbb	85 c0		 test	 eax, eax
  01fbd	74 7f		 je	 SHORT $LN213@z900_run_s
  01fbf	48 8b 84 24 20
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  01fc7	48 8b 80 70 08
	00 00		 mov	 rax, QWORD PTR [rax+2160]
  01fce	48 8b 8c 24 20
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  01fd6	48 8b 89 70 08
	00 00		 mov	 rcx, QWORD PTR [rcx+2160]
  01fdd	48 8b 89 60 af
	00 00		 mov	 rcx, QWORD PTR [rcx+44896]
  01fe4	48 39 48 68	 cmp	 QWORD PTR [rax+104], rcx
  01fe8	72 54		 jb	 SHORT $LN213@z900_run_s
  01fea	48 8b 84 24 20
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  01ff2	48 8b 80 70 08
	00 00		 mov	 rax, QWORD PTR [rax+2160]
  01ff9	8b 80 84 af 00
	00		 mov	 eax, DWORD PTR [rax+44932]
  01fff	0f ba e8 1f	 bts	 eax, 31
  02003	48 8b 8c 24 20
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0200b	48 8b 89 70 08
	00 00		 mov	 rcx, QWORD PTR [rcx+2160]
  02012	89 81 84 af 00
	00		 mov	 DWORD PTR [rcx+44932], eax
  02018	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG195357
  0201f	41 b8 0b 00 00
	00		 mov	 r8d, 11
  02025	ba fe ff ff ff	 mov	 edx, -2
  0202a	48 8b 84 24 20
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  02032	48 8b 88 70 08
	00 00		 mov	 rcx, QWORD PTR [rax+2160]
  02039	e8 00 00 00 00	 call	 z900_abort_transaction
$LN213@z900_run_s:
  0203e	33 c0		 xor	 eax, eax
  02040	85 c0		 test	 eax, eax
  02042	0f 85 52 ff ff
	ff		 jne	 $LN134@z900_run_s
  02048	48 8b 84 24 20
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  02050	48 8b 80 70 08
	00 00		 mov	 rax, QWORD PTR [rax+2160]
  02057	0f b7 80 5e 0e
	00 00		 movzx	 eax, WORD PTR [rax+3678]
  0205e	66 ff c0	 inc	 ax
  02061	48 8b 8c 24 20
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  02069	48 8b 89 70 08
	00 00		 mov	 rcx, QWORD PTR [rcx+2160]
  02070	66 89 81 5e 0e
	00 00		 mov	 WORD PTR [rcx+3678], ax
$LN137@z900_run_s:
  02077	33 c0		 xor	 eax, eax
  02079	83 f8 01	 cmp	 eax, 1
  0207c	0f 84 b6 00 00
	00		 je	 $LN214@z900_run_s
  02082	48 8b 84 24 20
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0208a	48 8b 80 70 08
	00 00		 mov	 rax, QWORD PTR [rax+2160]
  02091	0f b6 80 4c 0e
	00 00		 movzx	 eax, BYTE PTR [rax+3660]
  02098	85 c0		 test	 eax, eax
  0209a	0f 84 98 00 00
	00		 je	 $LN214@z900_run_s
  020a0	48 8b 84 24 20
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  020a8	48 8b 80 70 08
	00 00		 mov	 rax, QWORD PTR [rax+2160]
  020af	0f b7 80 5e 0e
	00 00		 movzx	 eax, WORD PTR [rax+3678]
  020b6	83 f8 20	 cmp	 eax, 32			; 00000020H
  020b9	7e 7d		 jle	 SHORT $LN214@z900_run_s
  020bb	48 8b 84 24 20
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  020c3	48 8b 80 70 08
	00 00		 mov	 rax, QWORD PTR [rax+2160]
  020ca	41 b8 02 00 00
	00		 mov	 r8d, 2
  020d0	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG195359
  020d7	48 8b 48 68	 mov	 rcx, QWORD PTR [rax+104]
  020db	e8 00 00 00 00	 call	 memcmp
  020e0	85 c0		 test	 eax, eax
  020e2	74 54		 je	 SHORT $LN214@z900_run_s
  020e4	48 8b 84 24 20
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  020ec	48 8b 80 70 08
	00 00		 mov	 rax, QWORD PTR [rax+2160]
  020f3	8b 80 84 af 00
	00		 mov	 eax, DWORD PTR [rax+44932]
  020f9	0f ba e8 1e	 bts	 eax, 30
  020fd	48 8b 8c 24 20
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  02105	48 8b 89 70 08
	00 00		 mov	 rcx, QWORD PTR [rcx+2160]
  0210c	89 81 84 af 00
	00		 mov	 DWORD PTR [rcx+44932], eax
  02112	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG195360
  02119	41 b8 0b 00 00
	00		 mov	 r8d, 11
  0211f	ba fe ff ff ff	 mov	 edx, -2
  02124	48 8b 84 24 20
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0212c	48 8b 88 70 08
	00 00		 mov	 rcx, QWORD PTR [rax+2160]
  02133	e8 00 00 00 00	 call	 z900_abort_transaction
$LN214@z900_run_s:
  02138	33 c0		 xor	 eax, eax
  0213a	85 c0		 test	 eax, eax
  0213c	0f 85 35 ff ff
	ff		 jne	 $LN137@z900_run_s
$LN140@z900_run_s:
  02142	33 c0		 xor	 eax, eax
  02144	83 f8 01	 cmp	 eax, 1
  02147	0f 84 b2 00 00
	00		 je	 $LN215@z900_run_s
  0214d	48 8b 84 24 20
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  02155	48 8b 80 70 08
	00 00		 mov	 rax, QWORD PTR [rax+2160]
  0215c	0f b7 80 60 0e
	00 00		 movzx	 eax, WORD PTR [rax+3680]
  02163	85 c0		 test	 eax, eax
  02165	0f 84 94 00 00
	00		 je	 $LN215@z900_run_s
  0216b	48 8b 84 24 20
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  02173	48 8b 80 70 08
	00 00		 mov	 rax, QWORD PTR [rax+2160]
  0217a	0f b7 80 5e 0e
	00 00		 movzx	 eax, WORD PTR [rax+3678]
  02181	48 8b 8c 24 20
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  02189	48 8b 89 70 08
	00 00		 mov	 rcx, QWORD PTR [rcx+2160]
  02190	0f b7 89 60 0e
	00 00		 movzx	 ecx, WORD PTR [rcx+3680]
  02197	3b c1		 cmp	 eax, ecx
  02199	7c 64		 jl	 SHORT $LN215@z900_run_s
  0219b	48 8b 84 24 20
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  021a3	48 8b 80 70 08
	00 00		 mov	 rax, QWORD PTR [rax+2160]
  021aa	8b 80 84 af 00
	00		 mov	 eax, DWORD PTR [rax+44932]
  021b0	0f ba e8 1d	 bts	 eax, 29
  021b4	48 8b 8c 24 20
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  021bc	48 8b 89 70 08
	00 00		 mov	 rcx, QWORD PTR [rcx+2160]
  021c3	89 81 84 af 00
	00		 mov	 DWORD PTR [rcx+44932], eax
  021c9	48 8b 84 24 20
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  021d1	48 8b 80 70 08
	00 00		 mov	 rax, QWORD PTR [rax+2160]
  021d8	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG195362
  021df	44 8b 80 0c af
	00 00		 mov	 r8d, DWORD PTR [rax+44812]
  021e6	ba fe ff ff ff	 mov	 edx, -2
  021eb	48 8b 84 24 20
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  021f3	48 8b 88 70 08
	00 00		 mov	 rcx, QWORD PTR [rax+2160]
  021fa	e8 00 00 00 00	 call	 z900_abort_transaction
$LN215@z900_run_s:
  021ff	33 c0		 xor	 eax, eax
  02201	85 c0		 test	 eax, eax
  02203	0f 85 39 ff ff
	ff		 jne	 $LN140@z900_run_s
$LN212@z900_run_s:
  02209	33 c0		 xor	 eax, eax
  0220b	85 c0		 test	 eax, eax
  0220d	0f 85 69 fd ff
	ff		 jne	 $LN131@z900_run_s
  02213	48 8b 84 24 20
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0221b	48 8b 80 70 08
	00 00		 mov	 rax, QWORD PTR [rax+2160]
  02222	48 89 84 24 f0
	00 00 00	 mov	 QWORD PTR tv1481[rsp], rax
  0222a	48 8b 8c 24 20
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  02232	48 8b 89 70 08
	00 00		 mov	 rcx, QWORD PTR [rcx+2160]
  02239	48 8b 49 68	 mov	 rcx, QWORD PTR [rcx+104]
  0223d	e8 00 00 00 00	 call	 fetch_hw_noswap
  02242	0f b7 c8	 movzx	 ecx, ax
  02245	e8 00 00 00 00	 call	 _byteswap_ushort
  0224a	0f b7 c0	 movzx	 eax, ax
  0224d	48 8b 8c 24 20
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  02255	48 8b 91 70 08
	00 00		 mov	 rdx, QWORD PTR [rcx+2160]
  0225c	48 8b 8c 24 f0
	00 00 00	 mov	 rcx, QWORD PTR tv1481[rsp]
  02264	48 8b 49 68	 mov	 rcx, QWORD PTR [rcx+104]
  02268	4c 8b 44 24 70	 mov	 r8, QWORD PTR current_opcode_table$[rsp]
  0226d	41 ff 14 c0	 call	 QWORD PTR [r8+rax*8]
  02271	33 c0		 xor	 eax, eax
  02273	85 c0		 test	 eax, eax
  02275	0f 85 01 fd ff
	ff		 jne	 $LN128@z900_run_s

; 1284 :                 }

  0227b	e9 47 f9 ff ff	 jmp	 $LN108@z900_run_s
$LN109@z900_run_s:

; 1285 :                 regs->instcount +=  (i * 2);

  02280	48 8b 84 24 20
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  02288	8b 80 98 07 00
	00		 mov	 eax, DWORD PTR [rax+1944]
  0228e	8b 4c 24 54	 mov	 ecx, DWORD PTR i$[rsp]
  02292	8d 04 48	 lea	 eax, DWORD PTR [rax+rcx*2]
  02295	48 8b 8c 24 20
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0229d	89 81 98 07 00
	00		 mov	 DWORD PTR [rcx+1944], eax

; 1286 :                 UPDATE_SYSBLK_INSTCOUNT( (i * 2) );

  022a3	8b 44 24 54	 mov	 eax, DWORD PTR i$[rsp]
  022a7	d1 e0		 shl	 eax, 1
  022a9	48 98		 cdqe
  022ab	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  022b2	48 81 c1 80 14
	00 00		 add	 rcx, 5248		; 00001480H
  022b9	48 8b d0	 mov	 rdx, rax
  022bc	e8 00 00 00 00	 call	 atomic_update64

; 1287 : 
; 1288 :                 /* Perform automatic instruction tracing if it's enabled */
; 1289 :                 do_automatic_tracing();

  022c1	e8 00 00 00 00	 call	 do_automatic_tracing
$endloop$264:

; 1290 :                 goto endloop;
; 1291 : 
; 1292 : #endif /* defined( FEATURE_073_TRANSACT_EXEC_FACILITY ) */
; 1293 : 
; 1294 : endloop:        ; // (nop to make compiler happy)
; 1295 :             }
; 1296 :             /******************************************/
; 1297 :             /* Remain in SIE (above loop) as long as: */
; 1298 :             /*  - No Host Interrupt is pending        */
; 1299 :             /*  - No SIE defined Interrupt is pending */
; 1300 :             /*    (Wait, External or I/O)             */
; 1301 :             /*  - No guest interrupt is pending       */
; 1302 :             /******************************************/
; 1303 :             while
; 1304 :             (0
; 1305 : #if defined( FEATURE_073_TRANSACT_EXEC_FACILITY )
; 1306 :              /* Don't interrupt active transaction */
; 1307 :              || (1
; 1308 :                  && GUESTREGS->txf_tnd > 0
; 1309 :                  && GUESTREGS->txf_PPA >= PPA_MUCH_HELP_THRESHOLD
; 1310 :                 )
; 1311 : #endif
; 1312 :              || (1

  022c6	33 c0		 xor	 eax, eax
  022c8	85 c0		 test	 eax, eax
  022ca	0f 85 de de ff
	ff		 jne	 $LN19@z900_run_s
  022d0	33 c0		 xor	 eax, eax
  022d2	83 f8 01	 cmp	 eax, 1
  022d5	74 36		 je	 SHORT $LN216@z900_run_s
  022d7	48 8b 84 24 20
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  022df	48 8b 80 70 08
	00 00		 mov	 rax, QWORD PTR [rax+2160]
  022e6	0f b6 80 58 0e
	00 00		 movzx	 eax, BYTE PTR [rax+3672]
  022ed	85 c0		 test	 eax, eax
  022ef	7e 1c		 jle	 SHORT $LN216@z900_run_s
  022f1	48 8b 84 24 20
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  022f9	48 8b 80 70 08
	00 00		 mov	 rax, QWORD PTR [rax+2160]
  02300	83 b8 54 0e 00
	00 02		 cmp	 DWORD PTR [rax+3668], 2
  02307	0f 8d a1 de ff
	ff		 jge	 $LN258@z900_run_s
$LN216@z900_run_s:
  0230d	33 c0		 xor	 eax, eax
  0230f	83 f8 01	 cmp	 eax, 1
  02312	0f 84 2e 01 00
	00		 je	 $LN217@z900_run_s
  02318	48 8b 84 24 20
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  02320	48 8b 8c 24 20
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  02328	8b 49 4c	 mov	 ecx, DWORD PTR [rcx+76]
  0232b	8b 40 48	 mov	 eax, DWORD PTR [rax+72]
  0232e	23 c1		 and	 eax, ecx
  02330	85 c0		 test	 eax, eax
  02332	0f 85 0e 01 00
	00		 jne	 $LN217@z900_run_s
  02338	48 8b 84 24 20
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  02340	48 8b 80 70 08
	00 00		 mov	 rax, QWORD PTR [rax+2160]
  02347	0f b6 40 7a	 movzx	 eax, BYTE PTR [rax+122]
  0234b	83 e0 02	 and	 eax, 2
  0234e	85 c0		 test	 eax, eax
  02350	74 2f		 je	 SHORT $LN218@z900_run_s
  02352	48 8b 84 24 20
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0235a	48 8b 80 70 08
	00 00		 mov	 rax, QWORD PTR [rax+2160]
  02361	48 8b 80 88 08
	00 00		 mov	 rax, QWORD PTR [rax+2184]
  02368	b9 01 00 00 00	 mov	 ecx, 1
  0236d	48 6b c9 00	 imul	 rcx, rcx, 0
  02371	0f b6 44 08 4c	 movzx	 eax, BYTE PTR [rax+rcx+76]
  02376	83 e0 20	 and	 eax, 32			; 00000020H
  02379	85 c0		 test	 eax, eax
  0237b	0f 84 c5 00 00
	00		 je	 $LN217@z900_run_s
$LN218@z900_run_s:
  02381	48 8b 84 24 20
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  02389	48 8b 80 70 08
	00 00		 mov	 rax, QWORD PTR [rax+2160]
  02390	48 8b 80 88 08
	00 00		 mov	 rax, QWORD PTR [rax+2184]
  02397	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  0239a	83 e0 01	 and	 eax, 1
  0239d	85 c0		 test	 eax, eax
  0239f	74 1e		 je	 SHORT $LN219@z900_run_s
  023a1	48 8b 84 24 20
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  023a9	48 8b 80 70 08
	00 00		 mov	 rax, QWORD PTR [rax+2160]
  023b0	0f b6 40 78	 movzx	 eax, BYTE PTR [rax+120]
  023b4	83 e0 01	 and	 eax, 1
  023b7	85 c0		 test	 eax, eax
  023b9	0f 85 87 00 00
	00		 jne	 $LN217@z900_run_s
$LN219@z900_run_s:
  023bf	48 8b 84 24 20
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  023c7	48 8b 80 70 08
	00 00		 mov	 rax, QWORD PTR [rax+2160]
  023ce	48 8b 80 88 08
	00 00		 mov	 rax, QWORD PTR [rax+2184]
  023d5	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  023d8	83 e0 02	 and	 eax, 2
  023db	85 c0		 test	 eax, eax
  023dd	74 1a		 je	 SHORT $LN220@z900_run_s
  023df	48 8b 84 24 20
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  023e7	48 8b 80 70 08
	00 00		 mov	 rax, QWORD PTR [rax+2160]
  023ee	0f b6 40 78	 movzx	 eax, BYTE PTR [rax+120]
  023f2	83 e0 02	 and	 eax, 2
  023f5	85 c0		 test	 eax, eax
  023f7	75 4d		 jne	 SHORT $LN217@z900_run_s
$LN220@z900_run_s:
  023f9	48 8b 84 24 20
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  02401	48 8b 80 70 08
	00 00		 mov	 rax, QWORD PTR [rax+2160]
  02408	48 8b 8c 24 20
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  02410	48 8b 89 70 08
	00 00		 mov	 rcx, QWORD PTR [rcx+2160]
  02417	48 8b 89 68 08
	00 00		 mov	 rcx, QWORD PTR [rcx+2152]
  0241e	8b 49 48	 mov	 ecx, DWORD PTR [rcx+72]
  02421	81 e1 80 0c 00
	40		 and	 ecx, 1073745024		; 40000c80H
  02427	8b 40 48	 mov	 eax, DWORD PTR [rax+72]
  0242a	0b c1		 or	 eax, ecx
  0242c	48 8b 8c 24 20
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  02434	48 8b 89 70 08
	00 00		 mov	 rcx, QWORD PTR [rcx+2160]
  0243b	23 41 4c	 and	 eax, DWORD PTR [rcx+76]
  0243e	85 c0		 test	 eax, eax
  02440	0f 84 68 dd ff
	ff		 je	 $LN259@z900_run_s
$LN217@z900_run_s:
$LN18@z900_run_s:

; 1313 :                  && !SIE_I_HOST            (    regs   )
; 1314 :                  && !SIE_I_WAIT            ( GUESTREGS )
; 1315 :                  && !SIE_I_EXT             ( GUESTREGS )
; 1316 :                  && !SIE_I_IO              ( GUESTREGS )
; 1317 :                  && !SIE_INTERRUPT_PENDING ( GUESTREGS )
; 1318 :                 )
; 1319 :             );
; 1320 : 
; 1321 :             /* Otherwise break out of the above loop
; 1322 :                and check if we should exit from SIE
; 1323 :                (check is done slightly further below)
; 1324 :             */
; 1325 :         }

  02446	eb 56		 jmp	 SHORT $LN153@z900_run_s
$LN152@z900_run_s:

; 1326 :         else
; 1327 :         {
; 1328 :             /* Our above instruction execution loop didn't finish due
; 1329 :                to a longjmp(progjmp) having been done, bringing us to
; 1330 :                here, thereby causing the instruction counter to not be
; 1331 :                properly updated. Thus, we must update it here instead.
; 1332 :            */
; 1333 :             if (sysblk.ipled)

  02448	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  0244f	8b 80 94 12 00
	00		 mov	 eax, DWORD PTR [rax+4756]
  02455	d1 e8		 shr	 eax, 1
  02457	83 e0 01	 and	 eax, 1
  0245a	85 c0		 test	 eax, eax
  0245c	74 40		 je	 SHORT $LN221@z900_run_s

; 1334 :             {
; 1335 :                 regs->instcount += MAX_CPU_LOOPS/2;

  0245e	48 8b 84 24 20
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  02466	8b 80 98 07 00
	00		 mov	 eax, DWORD PTR [rax+1944]
  0246c	05 80 00 00 00	 add	 eax, 128		; 00000080H
  02471	48 8b 8c 24 20
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  02479	89 81 98 07 00
	00		 mov	 DWORD PTR [rcx+1944], eax

; 1336 :                 UPDATE_SYSBLK_INSTCOUNT( MAX_CPU_LOOPS/2 );

  0247f	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  02486	48 05 80 14 00
	00		 add	 rax, 5248		; 00001480H
  0248c	ba 80 00 00 00	 mov	 edx, 128		; 00000080H
  02491	48 8b c8	 mov	 rcx, rax
  02494	e8 00 00 00 00	 call	 atomic_update64

; 1337 : 
; 1338 :                 /* Perform automatic instruction tracing if it's enabled */
; 1339 :                 do_automatic_tracing();

  02499	e8 00 00 00 00	 call	 do_automatic_tracing
$LN221@z900_run_s:
$LN153@z900_run_s:
$LN143@z900_run_s:

; 1340 :             }
; 1341 :         }
; 1342 : 
; 1343 :         PTT_SIE( "run_sie !run", icode, 0, 0 );

  0249e	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_pttclass
  024a5	48 8b 00	 mov	 rax, QWORD PTR [rax]
  024a8	48 25 80 00 00
	00		 and	 rax, 128		; 00000080H
  024ae	48 85 c0	 test	 rax, rax
  024b1	74 3b		 je	 SHORT $LN222@z900_run_s
  024b3	48 63 44 24 58	 movsxd	 rax, DWORD PTR icode$[rsp]
  024b8	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR [rsp+48], 0
  024c1	48 c7 44 24 28
	00 00 00 00	 mov	 QWORD PTR [rsp+40], 0
  024ca	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG195370
  024d1	48 89 4c 24 20	 mov	 QWORD PTR [rsp+32], rcx
  024d6	45 33 c9	 xor	 r9d, r9d
  024d9	4c 8b c0	 mov	 r8, rax
  024dc	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG195371
  024e3	b9 80 00 00 00	 mov	 ecx, 128		; 00000080H
  024e8	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ptt_pthread_trace
$LN222@z900_run_s:
  024ee	33 c0		 xor	 eax, eax
  024f0	85 c0		 test	 eax, eax
  024f2	75 aa		 jne	 SHORT $LN143@z900_run_s

; 1344 : 
; 1345 :         /* Check if we should remain in, or exit from, SIE mode */
; 1346 :         if (!icode || SIE_NO_INTERCEPT == icode)

  024f4	83 7c 24 58 00	 cmp	 DWORD PTR icode$[rsp], 0
  024f9	74 0b		 je	 SHORT $LN224@z900_run_s
  024fb	83 7c 24 58 ff	 cmp	 DWORD PTR icode$[rsp], -1
  02500	0f 85 73 01 00
	00		 jne	 $LN223@z900_run_s
$LN224@z900_run_s:

; 1347 :         {
; 1348 :             /* Check PER first, higher priority */
; 1349 :             if (OPEN_IC_PER( GUESTREGS ))

  02506	48 8b 84 24 20
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0250e	48 8b 80 70 08
	00 00		 mov	 rax, QWORD PTR [rax+2160]
  02515	48 8b 8c 24 20
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0251d	48 8b 89 70 08
	00 00		 mov	 rcx, QWORD PTR [rcx+2160]
  02524	8b 49 4c	 mov	 ecx, DWORD PTR [rcx+76]
  02527	8b 40 48	 mov	 eax, DWORD PTR [rax+72]
  0252a	23 c1		 and	 eax, ecx
  0252c	25 00 00 ff 00	 and	 eax, 16711680		; 00ff0000H
  02531	85 c0		 test	 eax, eax
  02533	74 19		 je	 SHORT $LN225@z900_run_s

; 1350 :                 ARCH_DEP( program_interrupt )( GUESTREGS, PGM_PER_EVENT );

  02535	ba 80 00 00 00	 mov	 edx, 128		; 00000080H
  0253a	48 8b 84 24 20
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  02542	48 8b 88 70 08
	00 00		 mov	 rcx, QWORD PTR [rax+2160]
  02549	e8 00 00 00 00	 call	 z900_program_interrupt
$LN225@z900_run_s:

; 1351 : 
; 1352 :             /* Check for SIE exit conditions... */
; 1353 : 
; 1354 :                  if (SIE_I_EXT  ( GUESTREGS )) icode = SIE_INTERCEPT_EXTREQ;

  0254e	48 8b 84 24 20
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  02556	48 8b 80 70 08
	00 00		 mov	 rax, QWORD PTR [rax+2160]
  0255d	48 8b 80 88 08
	00 00		 mov	 rax, QWORD PTR [rax+2184]
  02564	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  02567	83 e0 01	 and	 eax, 1
  0256a	85 c0		 test	 eax, eax
  0256c	74 27		 je	 SHORT $LN226@z900_run_s
  0256e	48 8b 84 24 20
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  02576	48 8b 80 70 08
	00 00		 mov	 rax, QWORD PTR [rax+2160]
  0257d	0f b6 40 78	 movzx	 eax, BYTE PTR [rax+120]
  02581	83 e0 01	 and	 eax, 1
  02584	85 c0		 test	 eax, eax
  02586	74 0d		 je	 SHORT $LN226@z900_run_s
  02588	c7 44 24 58 fa
	ff ff ff	 mov	 DWORD PTR icode$[rsp], -6
  02590	e9 e4 00 00 00	 jmp	 $LN227@z900_run_s
$LN226@z900_run_s:

; 1355 :             else if (SIE_I_IO   ( GUESTREGS )) icode = SIE_INTERCEPT_IOREQ;

  02595	48 8b 84 24 20
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0259d	48 8b 80 70 08
	00 00		 mov	 rax, QWORD PTR [rax+2160]
  025a4	48 8b 80 88 08
	00 00		 mov	 rax, QWORD PTR [rax+2184]
  025ab	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  025ae	83 e0 02	 and	 eax, 2
  025b1	85 c0		 test	 eax, eax
  025b3	74 27		 je	 SHORT $LN228@z900_run_s
  025b5	48 8b 84 24 20
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  025bd	48 8b 80 70 08
	00 00		 mov	 rax, QWORD PTR [rax+2160]
  025c4	0f b6 40 78	 movzx	 eax, BYTE PTR [rax+120]
  025c8	83 e0 02	 and	 eax, 2
  025cb	85 c0		 test	 eax, eax
  025cd	74 0d		 je	 SHORT $LN228@z900_run_s
  025cf	c7 44 24 58 f9
	ff ff ff	 mov	 DWORD PTR icode$[rsp], -7
  025d7	e9 9d 00 00 00	 jmp	 $LN229@z900_run_s
$LN228@z900_run_s:

; 1356 :             else if (SIE_I_STOP ( GUESTREGS )) icode = SIE_INTERCEPT_STOPREQ;

  025dc	48 8b 84 24 20
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  025e4	48 8b 80 70 08
	00 00		 mov	 rax, QWORD PTR [rax+2160]
  025eb	48 8b 80 88 08
	00 00		 mov	 rax, QWORD PTR [rax+2184]
  025f2	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  025f5	83 e0 04	 and	 eax, 4
  025f8	85 c0		 test	 eax, eax
  025fa	74 0a		 je	 SHORT $LN230@z900_run_s
  025fc	c7 44 24 58 f7
	ff ff ff	 mov	 DWORD PTR icode$[rsp], -9
  02604	eb 73		 jmp	 SHORT $LN231@z900_run_s
$LN230@z900_run_s:

; 1357 :             else if (SIE_I_WAIT ( GUESTREGS )) icode = SIE_INTERCEPT_WAIT;

  02606	48 8b 84 24 20
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0260e	48 8b 80 70 08
	00 00		 mov	 rax, QWORD PTR [rax+2160]
  02615	0f b6 40 7a	 movzx	 eax, BYTE PTR [rax+122]
  02619	83 e0 02	 and	 eax, 2
  0261c	85 c0		 test	 eax, eax
  0261e	74 35		 je	 SHORT $LN232@z900_run_s
  02620	48 8b 84 24 20
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  02628	48 8b 80 70 08
	00 00		 mov	 rax, QWORD PTR [rax+2160]
  0262f	48 8b 80 88 08
	00 00		 mov	 rax, QWORD PTR [rax+2184]
  02636	b9 01 00 00 00	 mov	 ecx, 1
  0263b	48 6b c9 00	 imul	 rcx, rcx, 0
  0263f	0f b6 44 08 4c	 movzx	 eax, BYTE PTR [rax+rcx+76]
  02644	83 e0 20	 and	 eax, 32			; 00000020H
  02647	85 c0		 test	 eax, eax
  02649	75 0a		 jne	 SHORT $LN232@z900_run_s
  0264b	c7 44 24 58 f8
	ff ff ff	 mov	 DWORD PTR icode$[rsp], -8
  02653	eb 24		 jmp	 SHORT $LN233@z900_run_s
$LN232@z900_run_s:

; 1358 :             else if (SIE_I_HOST (   regs    )) icode = SIE_HOST_INT_PEND;

  02655	48 8b 84 24 20
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0265d	48 8b 8c 24 20
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  02665	8b 49 4c	 mov	 ecx, DWORD PTR [rcx+76]
  02668	8b 40 48	 mov	 eax, DWORD PTR [rax+72]
  0266b	23 c1		 and	 eax, ecx
  0266d	85 c0		 test	 eax, eax
  0266f	74 08		 je	 SHORT $LN234@z900_run_s
  02671	c7 44 24 58 fe
	ff ff ff	 mov	 DWORD PTR icode$[rsp], -2
$LN234@z900_run_s:
$LN233@z900_run_s:
$LN231@z900_run_s:
$LN229@z900_run_s:
$LN227@z900_run_s:
$LN223@z900_run_s:
$LN146@z900_run_s:

; 1359 : 
; 1360 :             /* Otherwise we should remain in SIE mode */
; 1361 :         }
; 1362 : 
; 1363 :         PTT_SIE( "run_sie !run", icode, 0, 0 );

  02679	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_pttclass
  02680	48 8b 00	 mov	 rax, QWORD PTR [rax]
  02683	48 25 80 00 00
	00		 and	 rax, 128		; 00000080H
  02689	48 85 c0	 test	 rax, rax
  0268c	74 3b		 je	 SHORT $LN235@z900_run_s
  0268e	48 63 44 24 58	 movsxd	 rax, DWORD PTR icode$[rsp]
  02693	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR [rsp+48], 0
  0269c	48 c7 44 24 28
	00 00 00 00	 mov	 QWORD PTR [rsp+40], 0
  026a5	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG195385
  026ac	48 89 4c 24 20	 mov	 QWORD PTR [rsp+32], rcx
  026b1	45 33 c9	 xor	 r9d, r9d
  026b4	4c 8b c0	 mov	 r8, rax
  026b7	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG195386
  026be	b9 80 00 00 00	 mov	 ecx, 128		; 00000080H
  026c3	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ptt_pthread_trace
$LN235@z900_run_s:
  026c9	33 c0		 xor	 eax, eax
  026cb	85 c0		 test	 eax, eax
  026cd	75 aa		 jne	 SHORT $LN146@z900_run_s

; 1364 :     }
; 1365 :     /* Try to remain in SIE mode if possible */
; 1366 :     while (!icode || icode == SIE_NO_INTERCEPT);

  026cf	83 7c 24 58 00	 cmp	 DWORD PTR icode$[rsp], 0
  026d4	0f 84 03 da ff
	ff		 je	 $LN10@z900_run_s
  026da	83 7c 24 58 ff	 cmp	 DWORD PTR icode$[rsp], -1
  026df	0f 84 f8 d9 ff
	ff		 je	 $LN257@z900_run_s
$LN149@z900_run_s:

; 1367 : 
; 1368 :     PTT_SIE( "run_sie ret", icode, 0, 0 );

  026e5	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_pttclass
  026ec	48 8b 00	 mov	 rax, QWORD PTR [rax]
  026ef	48 25 80 00 00
	00		 and	 rax, 128		; 00000080H
  026f5	48 85 c0	 test	 rax, rax
  026f8	74 3b		 je	 SHORT $LN236@z900_run_s
  026fa	48 63 44 24 58	 movsxd	 rax, DWORD PTR icode$[rsp]
  026ff	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR [rsp+48], 0
  02708	48 c7 44 24 28
	00 00 00 00	 mov	 QWORD PTR [rsp+40], 0
  02711	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG195388
  02718	48 89 4c 24 20	 mov	 QWORD PTR [rsp+32], rcx
  0271d	45 33 c9	 xor	 r9d, r9d
  02720	4c 8b c0	 mov	 r8, rax
  02723	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG195389
  0272a	b9 80 00 00 00	 mov	 ecx, 128		; 00000080H
  0272f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ptt_pthread_trace
$LN236@z900_run_s:
  02735	33 c0		 xor	 eax, eax
  02737	85 c0		 test	 eax, eax
  02739	75 aa		 jne	 SHORT $LN149@z900_run_s

; 1369 : 
; 1370 :     return icode;

  0273b	8b 44 24 58	 mov	 eax, DWORD PTR icode$[rsp]
$LN237@z900_run_s:

; 1371 : } /* end function run_sie */

  0273f	48 8b 8c 24 08
	01 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  02747	48 33 cc	 xor	 rcx, rsp
  0274a	e8 00 00 00 00	 call	 __security_check_cookie
  0274f	48 81 c4 18 01
	00 00		 add	 rsp, 280		; 00000118H
  02756	c3		 ret	 0
z900_run_sie ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\sie.c
_TEXT	SEGMENT
i$1 = 80
icode$ = 84
oldmode$2 = 88
i$ = 92
tv391 = 96
tv360 = 100
tv384 = 104
tv366 = 108
tv535 = 112
tv625 = 116
inst_cr$3 = 120
tv655 = 124
now$4 = 128
ip$ = 136
current_opcode_table$ = 144
tv633 = 152
tv657 = 160
tv932 = 168
tv928 = 176
waittime$5 = 184
__$ArrayPad$ = 200
regs$ = 224
s390_run_sie PROC

; 947  : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 81 ec d8 00
	00 00		 sub	 rsp, 216		; 000000d8H
  0000c	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00013	48 33 c4	 xor	 rax, rsp
  00016	48 89 84 24 c8
	00 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax
$LN4@s390_run_s:

; 948  :     BYTE*  ip;      /* instruction pointer        */
; 949  :     int    icode;   /* SIE longjmp intercept code */
; 950  :     int    i;
; 951  :     const INSTR_FUNC*  current_opcode_table;
; 952  : 
; 953  :     //---------------------------------------------------------
; 954  :     //              CRITICAL SIE PROGRAMMING NOTE!
; 955  :     //---------------------------------------------------------
; 956  :     //
; 957  :     //  Our 'regs' variable always points the HOST's regs (i.e.
; 958  :     //  regs == HOSTREGS && regs->host is always true), even though
; 959  :     //  we are actually RUNNING (executing) in GUEST architecture
; 960  :     //  mode!!
; 961  :     //
; 962  :     //  That is to say, if the host is, for example, z900 (z/VM)
; 963  :     //  but the guest it wants to execute is a 390 guest, the above
; 964  :     //  "start_interpretive_execution" instruction function calls
; 965  :     //  the "s390_run_sie" function (because it wants to execute
; 966  :     //  the guest in 390 mode), but it passed its own HOST regs to
; 967  :     //  this function!
; 968  :     //
; 969  :     //  So even though our function's build architecture is 390
; 970  :     //  (i.e. even though our function's build architecture is that
; 971  :     //  of the GUEST's), our 'regs' pointer is nevertheless still
; 972  :     //  pointing to the z/VM HOST's registers!! GUESTREGS must be
; 973  :     //  used to access the GUEST's register context!!
; 974  :     //
; 975  :     //  What this means is that SPECIAL CARE must be taken when
; 976  :     //  invoking macros or calling functions on behalf of the HOST
; 977  :     //  (i.e. when using 'regs' or HOSTREGS instead of GUESTREGS)
; 978  :     //  since many of our macros and functions are architecture
; 979  :     //  dependent, relying on the regs they were called with to
; 980  :     //  always match that of the current build architecture, which,
; 981  :     //  as explained, is NOT necessarily always true in our case!!
; 982  :     //
; 983  :     //---------------------------------------------------------
; 984  : 
; 985  :     //-----------------------------------------------------------
; 986  :     //               IMPORTANT SIE PROGRAMMING NOTE!
; 987  :     //-----------------------------------------------------------
; 988  :     // NOTE: Our execution architectural mode is that of the SIE
; 989  :     // GUEST, not the HOST! If you need to call a function on
; 990  :     // behalf of the HOST (passing it 'regs'), you must be careful
; 991  :     // to ensure the correct version of that function is called!
; 992  :     // You cannot simply call the "ARCH_DEP" version of a function
; 993  :     // as they are for the architectue of the GUEST, not the HOST!
; 994  :     // (e.g. you cannot call a "s390_xxxx" function expecting it
; 995  :     // to work correctly if the HOST function that SHOULD have been
; 996  :     // called should have been "z900_xxxx"!) YOU HAVE BEEN WARNED!
; 997  :     //-----------------------------------------------------------
; 998  : 
; 999  :     PTT_SIE( "run_sie h,g,a", regs->host, regs->guest, regs->sie_active );

  0001e	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_pttclass
  00025	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00028	48 25 80 00 00
	00		 and	 rax, 128		; 00000080H
  0002e	48 85 c0	 test	 rax, rax
  00031	74 71		 je	 SHORT $LN84@s390_run_s
  00033	48 8b 84 24 e0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0003b	8b 80 c8 08 00
	00		 mov	 eax, DWORD PTR [rax+2248]
  00041	83 e0 01	 and	 eax, 1
  00044	8b c0		 mov	 eax, eax
  00046	48 8b 8c 24 e0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0004e	8b 89 28 07 00
	00		 mov	 ecx, DWORD PTR [rcx+1832]
  00054	c1 e9 08	 shr	 ecx, 8
  00057	83 e1 01	 and	 ecx, 1
  0005a	8b c9		 mov	 ecx, ecx
  0005c	48 8b 94 24 e0
	00 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  00064	8b 92 28 07 00
	00		 mov	 edx, DWORD PTR [rdx+1832]
  0006a	c1 ea 07	 shr	 edx, 7
  0006d	83 e2 01	 and	 edx, 1
  00070	8b d2		 mov	 edx, edx
  00072	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR [rsp+48], 0
  0007b	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  00080	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG180896
  00087	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  0008c	44 8b c9	 mov	 r9d, ecx
  0008f	44 8b c2	 mov	 r8d, edx
  00092	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG180897
  00099	b9 80 00 00 00	 mov	 ecx, 128		; 00000080H
  0009e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ptt_pthread_trace
$LN84@s390_run_s:
  000a4	33 c0		 xor	 eax, eax
  000a6	85 c0		 test	 eax, eax
  000a8	0f 85 70 ff ff
	ff		 jne	 $LN4@s390_run_s
$LN7@s390_run_s:

; 1000 : 
; 1001 :     SIE_PERFMON( SIE_PERF_RUNSIE );
; 1002 : 
; 1003 : #if defined( _FEATURE_PER )
; 1004 :     /* Reset any PER pending indication */
; 1005 :     OFF_IC_PER( GUESTREGS );

  000ae	48 8b 84 24 e0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  000b6	48 8b 80 70 08
	00 00		 mov	 rax, QWORD PTR [rax+2160]
  000bd	8b 40 4c	 mov	 eax, DWORD PTR [rax+76]
  000c0	25 ff ff 00 ff	 and	 eax, -16711681		; ff00ffffH
  000c5	48 8b 8c 24 e0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  000cd	48 8b 89 70 08
	00 00		 mov	 rcx, QWORD PTR [rcx+2160]
  000d4	89 41 4c	 mov	 DWORD PTR [rcx+76], eax
  000d7	33 c0		 xor	 eax, eax
  000d9	85 c0		 test	 eax, eax
  000db	75 d1		 jne	 SHORT $LN7@s390_run_s
$LN162@s390_run_s:
$LN10@s390_run_s:
$LN13@s390_run_s:

; 1006 : #endif
; 1007 : 
; 1008 : #ifdef FEATURE_INTERVAL_TIMER
; 1009 :     /* Load the shadow interval timer */
; 1010 :     {
; 1011 :         S32 itimer;
; 1012 :         FETCH_FW( itimer, GUESTREGS->psa->inttimer );
; 1013 :         set_int_timer( GUESTREGS, itimer );
; 1014 :     }
; 1015 : #endif
; 1016 : 
; 1017 :     do
; 1018 :     {
; 1019 :         SIE_PERFMON( SIE_PERF_RUNLOOP_1 );
; 1020 : 
; 1021 :         PTT_SIE( "run_sie setjmp", 0, 0, 0 );

  000dd	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_pttclass
  000e4	48 8b 00	 mov	 rax, QWORD PTR [rax]
  000e7	48 25 80 00 00
	00		 and	 rax, 128		; 00000080H
  000ed	48 85 c0	 test	 rax, rax
  000f0	74 36		 je	 SHORT $LN85@s390_run_s
  000f2	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR [rsp+48], 0
  000fb	48 c7 44 24 28
	00 00 00 00	 mov	 QWORD PTR [rsp+40], 0
  00104	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG180899
  0010b	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00110	45 33 c9	 xor	 r9d, r9d
  00113	45 33 c0	 xor	 r8d, r8d
  00116	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG180900
  0011d	b9 80 00 00 00	 mov	 ecx, 128		; 00000080H
  00122	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ptt_pthread_trace
$LN85@s390_run_s:
  00128	33 c0		 xor	 eax, eax
  0012a	85 c0		 test	 eax, eax
  0012c	75 af		 jne	 SHORT $LN13@s390_run_s

; 1022 : 
; 1023 :         /* Establish longjmp destination for program check or
; 1024 :            RETURN_INTCHECK, or SIE_INTERCEPT, or longjmp, etc.
; 1025 :         */
; 1026 :         if (!(icode = setjmp( GUESTREGS->progjmp )))

  0012e	48 8b 84 24 e0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00136	48 8b 80 70 08
	00 00		 mov	 rax, QWORD PTR [rax+2160]
  0013d	48 05 80 09 00
	00		 add	 rax, 2432		; 00000980H
  00143	48 8b c8	 mov	 rcx, rax
  00146	48 8b d4	 mov	 rdx, rsp
  00149	e8 00 00 00 00	 call	 _setjmp
  0014e	89 44 24 54	 mov	 DWORD PTR icode$[rsp], eax
  00152	83 7c 24 54 00	 cmp	 DWORD PTR icode$[rsp], 0
  00157	0f 85 06 13 00
	00		 jne	 $LN86@s390_run_s
$LN16@s390_run_s:

; 1027 :         {
; 1028 :             PTT_SIE( "run_sie run...", 0, 0, 0 );

  0015d	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_pttclass
  00164	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00167	48 25 80 00 00
	00		 and	 rax, 128		; 00000080H
  0016d	48 85 c0	 test	 rax, rax
  00170	74 36		 je	 SHORT $LN88@s390_run_s
  00172	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR [rsp+48], 0
  0017b	48 c7 44 24 28
	00 00 00 00	 mov	 QWORD PTR [rsp+40], 0
  00184	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG180904
  0018b	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00190	45 33 c9	 xor	 r9d, r9d
  00193	45 33 c0	 xor	 r8d, r8d
  00196	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG180905
  0019d	b9 80 00 00 00	 mov	 ecx, 128		; 00000080H
  001a2	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ptt_pthread_trace
$LN88@s390_run_s:
  001a8	33 c0		 xor	 eax, eax
  001aa	85 c0		 test	 eax, eax
  001ac	75 af		 jne	 SHORT $LN16@s390_run_s
$LN163@s390_run_s:
$LN19@s390_run_s:

; 1029 :             do
; 1030 :             {
; 1031 :                 SIE_PERFMON( SIE_PERF_RUNLOOP_2 );
; 1032 : 
; 1033 :                 /* Set `execflag' to 0 in case EXecuted instruction did progjmp */
; 1034 :                 GUESTREGS->execflag = 0;

  001ae	48 8b 84 24 e0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  001b6	48 8b 80 70 08
	00 00		 mov	 rax, QWORD PTR [rax+2160]
  001bd	8b 80 28 07 00
	00		 mov	 eax, DWORD PTR [rax+1832]
  001c3	83 e0 fe	 and	 eax, -2			; fffffffeH
  001c6	48 8b 8c 24 e0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  001ce	48 8b 89 70 08
	00 00		 mov	 rcx, QWORD PTR [rcx+2160]
  001d5	89 81 28 07 00
	00		 mov	 DWORD PTR [rcx+1832], eax

; 1035 : 
; 1036 :                 /* Exit from SIE mode when either asked or
; 1037 :                    if External or I/O Interrupt is pending
; 1038 :                 */
; 1039 :                 if (1
; 1040 : #if defined( FEATURE_073_TRANSACT_EXEC_FACILITY )
; 1041 :                     /* Don't interrupt active transaction */
; 1042 :                     && (0
; 1043 :                         || GUESTREGS->txf_tnd == 0
; 1044 :                         || GUESTREGS->txf_PPA < PPA_MUCH_HELP_THRESHOLD
; 1045 :                        )
; 1046 : #endif
; 1047 :                     && (0

  001db	33 c0		 xor	 eax, eax
  001dd	83 f8 01	 cmp	 eax, 1
  001e0	0f 84 a3 00 00
	00		 je	 $LN89@s390_run_s
  001e6	33 c0		 xor	 eax, eax
  001e8	85 c0		 test	 eax, eax
  001ea	0f 85 94 00 00
	00		 jne	 $LN90@s390_run_s
  001f0	48 8b 84 24 e0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  001f8	48 8b 80 70 08
	00 00		 mov	 rax, QWORD PTR [rax+2160]
  001ff	48 8b 80 88 08
	00 00		 mov	 rax, QWORD PTR [rax+2184]
  00206	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  00209	83 e0 04	 and	 eax, 4
  0020c	85 c0		 test	 eax, eax
  0020e	75 74		 jne	 SHORT $LN90@s390_run_s
  00210	48 8b 84 24 e0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00218	48 8b 80 70 08
	00 00		 mov	 rax, QWORD PTR [rax+2160]
  0021f	48 8b 80 88 08
	00 00		 mov	 rax, QWORD PTR [rax+2184]
  00226	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  00229	83 e0 01	 and	 eax, 1
  0022c	85 c0		 test	 eax, eax
  0022e	74 1a		 je	 SHORT $LN91@s390_run_s
  00230	48 8b 84 24 e0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00238	48 8b 80 70 08
	00 00		 mov	 rax, QWORD PTR [rax+2160]
  0023f	0f b6 40 78	 movzx	 eax, BYTE PTR [rax+120]
  00243	83 e0 01	 and	 eax, 1
  00246	85 c0		 test	 eax, eax
  00248	75 3a		 jne	 SHORT $LN90@s390_run_s
$LN91@s390_run_s:
  0024a	48 8b 84 24 e0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00252	48 8b 80 70 08
	00 00		 mov	 rax, QWORD PTR [rax+2160]
  00259	48 8b 80 88 08
	00 00		 mov	 rax, QWORD PTR [rax+2184]
  00260	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  00263	83 e0 02	 and	 eax, 2
  00266	85 c0		 test	 eax, eax
  00268	74 1f		 je	 SHORT $LN89@s390_run_s
  0026a	48 8b 84 24 e0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00272	48 8b 80 70 08
	00 00		 mov	 rax, QWORD PTR [rax+2160]
  00279	0f b6 40 78	 movzx	 eax, BYTE PTR [rax+120]
  0027d	83 e0 02	 and	 eax, 2
  00280	85 c0		 test	 eax, eax
  00282	74 05		 je	 SHORT $LN89@s390_run_s
$LN90@s390_run_s:

; 1048 :                         || SIE_I_STOP ( GUESTREGS )
; 1049 :                         || SIE_I_EXT  ( GUESTREGS )
; 1050 :                         || SIE_I_IO   ( GUESTREGS )
; 1051 :                        )
; 1052 :                 )
; 1053 :                     break;

  00284	e9 d8 11 00 00	 jmp	 $LN18@s390_run_s
$LN89@s390_run_s:

; 1054 : 
; 1055 :                 if (SIE_IC_INTERRUPT_CPU( GUESTREGS ))

  00289	48 8b 84 24 e0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00291	48 8b 80 70 08
	00 00		 mov	 rax, QWORD PTR [rax+2160]
  00298	48 8b 8c 24 e0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  002a0	48 8b 89 70 08
	00 00		 mov	 rcx, QWORD PTR [rcx+2160]
  002a7	48 8b 89 68 08
	00 00		 mov	 rcx, QWORD PTR [rcx+2152]
  002ae	8b 49 48	 mov	 ecx, DWORD PTR [rcx+72]
  002b1	81 e1 80 0c 00
	40		 and	 ecx, 1073745024		; 40000c80H
  002b7	8b 40 48	 mov	 eax, DWORD PTR [rax+72]
  002ba	0b c1		 or	 eax, ecx
  002bc	48 8b 8c 24 e0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  002c4	48 8b 89 70 08
	00 00		 mov	 rcx, QWORD PTR [rcx+2160]
  002cb	23 41 4c	 and	 eax, DWORD PTR [rcx+76]
  002ce	85 c0		 test	 eax, eax
  002d0	0f 84 f1 0b 00
	00		 je	 $LN92@s390_run_s

; 1056 :                 {
; 1057 :                     SIE_PERFMON( SIE_PERF_INTCHECK );
; 1058 : 
; 1059 :                     /* Process PER program interrupts */
; 1060 :                     if (OPEN_IC_PER( GUESTREGS ))

  002d6	48 8b 84 24 e0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  002de	48 8b 80 70 08
	00 00		 mov	 rax, QWORD PTR [rax+2160]
  002e5	48 8b 8c 24 e0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  002ed	48 8b 89 70 08
	00 00		 mov	 rcx, QWORD PTR [rcx+2160]
  002f4	8b 49 4c	 mov	 ecx, DWORD PTR [rcx+76]
  002f7	8b 40 48	 mov	 eax, DWORD PTR [rax+72]
  002fa	23 c1		 and	 eax, ecx
  002fc	25 00 00 ff 00	 and	 eax, 16711680		; 00ff0000H
  00301	85 c0		 test	 eax, eax
  00303	74 19		 je	 SHORT $LN93@s390_run_s

; 1061 :                         ARCH_DEP( program_interrupt )( GUESTREGS, PGM_PER_EVENT );

  00305	ba 80 00 00 00	 mov	 edx, 128		; 00000080H
  0030a	48 8b 84 24 e0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00312	48 8b 88 70 08
	00 00		 mov	 rcx, QWORD PTR [rax+2160]
  00319	e8 00 00 00 00	 call	 s390_program_interrupt
$LN93@s390_run_s:

; 1062 : 
; 1063 :                     OBTAIN_INTLOCK( regs );

  0031e	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG180911
  00325	48 8b 8c 24 e0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0032d	e8 00 00 00 00	 call	 Obtain_Interrupt_Lock
$LN22@s390_run_s:

; 1064 :                     OFF_IC_INTERRUPT( GUESTREGS );

  00332	48 8b 84 24 e0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0033a	48 8b 80 70 08
	00 00		 mov	 rax, QWORD PTR [rax+2160]
  00341	8b 40 48	 mov	 eax, DWORD PTR [rax+72]
  00344	0f ba f0 1f	 btr	 eax, 31
  00348	48 8b 8c 24 e0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00350	48 8b 89 70 08
	00 00		 mov	 rcx, QWORD PTR [rcx+2160]
  00357	89 41 48	 mov	 DWORD PTR [rcx+72], eax
  0035a	33 c0		 xor	 eax, eax
  0035c	85 c0		 test	 eax, eax
  0035e	75 d2		 jne	 SHORT $LN22@s390_run_s
$LN25@s390_run_s:

; 1065 : 
; 1066 :                     /* Set psw.IA and invalidate the aia */
; 1067 :                     INVALIDATE_AIA( GUESTREGS );

  00360	48 8b 84 24 e0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00368	48 8b 80 70 08
	00 00		 mov	 rax, QWORD PTR [rax+2160]
  0036f	48 83 b8 08 02
	00 00 00	 cmp	 QWORD PTR [rax+520], 0
  00377	0f 84 8b 00 00
	00		 je	 $LN94@s390_run_s
  0037d	48 8b 84 24 e0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00385	48 8b 80 70 08
	00 00		 mov	 rax, QWORD PTR [rax+2160]
  0038c	8b 80 10 02 00
	00		 mov	 eax, DWORD PTR [rax+528]
  00392	48 8b 8c 24 e0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0039a	48 8b 89 70 08
	00 00		 mov	 rcx, QWORD PTR [rcx+2160]
  003a1	48 8b 94 24 e0
	00 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  003a9	48 8b 92 70 08
	00 00		 mov	 rdx, QWORD PTR [rdx+2160]
  003b0	48 8b 92 00 02
	00 00		 mov	 rdx, QWORD PTR [rdx+512]
  003b7	48 8b 49 68	 mov	 rcx, QWORD PTR [rcx+104]
  003bb	48 2b ca	 sub	 rcx, rdx
  003be	48 03 c1	 add	 rax, rcx
  003c1	48 8b 8c 24 e0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  003c9	48 8b 89 70 08
	00 00		 mov	 rcx, QWORD PTR [rcx+2160]
  003d0	8b 89 90 00 00
	00		 mov	 ecx, DWORD PTR [rcx+144]
  003d6	48 23 c1	 and	 rax, rcx
  003d9	48 8b 8c 24 e0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  003e1	48 8b 89 70 08
	00 00		 mov	 rcx, QWORD PTR [rcx+2160]
  003e8	89 81 88 00 00
	00		 mov	 DWORD PTR [rcx+136], eax
  003ee	48 8b 84 24 e0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  003f6	48 8b 80 70 08
	00 00		 mov	 rax, QWORD PTR [rax+2160]
  003fd	48 c7 80 08 02
	00 00 00 00 00
	00		 mov	 QWORD PTR [rax+520], 0
$LN94@s390_run_s:
  00408	33 c0		 xor	 eax, eax
  0040a	85 c0		 test	 eax, eax
  0040c	0f 85 4e ff ff
	ff		 jne	 $LN25@s390_run_s

; 1068 : 
; 1069 :                     /* Process External Interrupt if one is pending */
; 1070 :                     if (1
; 1071 :                         && OPEN_IC_EXTPENDING( GUESTREGS )

  00412	33 c0		 xor	 eax, eax
  00414	83 f8 01	 cmp	 eax, 1
  00417	74 43		 je	 SHORT $LN95@s390_run_s
  00419	48 8b 84 24 e0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00421	48 8b 80 70 08
	00 00		 mov	 rax, QWORD PTR [rax+2160]
  00428	48 8b 8c 24 e0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00430	48 8b 89 70 08
	00 00		 mov	 rcx, QWORD PTR [rcx+2160]
  00437	8b 49 4c	 mov	 ecx, DWORD PTR [rcx+76]
  0043a	8b 40 48	 mov	 eax, DWORD PTR [rax+72]
  0043d	23 c1		 and	 eax, ecx
  0043f	25 f0 ff 00 00	 and	 eax, 65520		; 0000fff0H
  00444	85 c0		 test	 eax, eax
  00446	74 14		 je	 SHORT $LN95@s390_run_s

; 1072 : #if defined( FEATURE_073_TRANSACT_EXEC_FACILITY )
; 1073 :                         /* Don't interrupt active transaction */
; 1074 :                         && (0
; 1075 :                             || GUESTREGS->txf_tnd == 0
; 1076 :                             || GUESTREGS->txf_PPA < PPA_MUCH_HELP_THRESHOLD
; 1077 :                            )
; 1078 : #endif
; 1079 :                     )
; 1080 :                         ARCH_DEP( perform_external_interrupt )( GUESTREGS );

  00448	48 8b 84 24 e0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00450	48 8b 88 70 08
	00 00		 mov	 rcx, QWORD PTR [rax+2160]
  00457	e8 00 00 00 00	 call	 s390_perform_external_interrupt
$LN95@s390_run_s:

; 1081 : 
; 1082 :                     /* Process I/O Interrupt if either I/O or SIGA Assist is enabled
; 1083 :                        and an I/O Interrupt is pending.
; 1084 :                     */
; 1085 :                     if (1
; 1086 :                         && (0
; 1087 :                             || (STATEBK->ec[0] & SIE_EC0_IOA)
; 1088 :                             || (STATEBK->ec[3] & SIE_EC3_SIGA)
; 1089 :                            )
; 1090 :                         && OPEN_IC_IOPENDING( GUESTREGS )

  0045c	33 c0		 xor	 eax, eax
  0045e	83 f8 01	 cmp	 eax, 1
  00461	0f 84 a8 00 00
	00		 je	 $LN96@s390_run_s
  00467	33 c0		 xor	 eax, eax
  00469	85 c0		 test	 eax, eax
  0046b	75 56		 jne	 SHORT $LN97@s390_run_s
  0046d	48 8b 84 24 e0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00475	48 8b 80 70 08
	00 00		 mov	 rax, QWORD PTR [rax+2160]
  0047c	48 8b 80 88 08
	00 00		 mov	 rax, QWORD PTR [rax+2184]
  00483	b9 01 00 00 00	 mov	 ecx, 1
  00488	48 6b c9 00	 imul	 rcx, rcx, 0
  0048c	0f b6 44 08 4c	 movzx	 eax, BYTE PTR [rax+rcx+76]
  00491	83 e0 04	 and	 eax, 4
  00494	85 c0		 test	 eax, eax
  00496	75 2b		 jne	 SHORT $LN97@s390_run_s
  00498	48 8b 84 24 e0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  004a0	48 8b 80 70 08
	00 00		 mov	 rax, QWORD PTR [rax+2160]
  004a7	48 8b 80 88 08
	00 00		 mov	 rax, QWORD PTR [rax+2184]
  004ae	b9 01 00 00 00	 mov	 ecx, 1
  004b3	48 6b c9 03	 imul	 rcx, rcx, 3
  004b7	0f b6 44 08 4c	 movzx	 eax, BYTE PTR [rax+rcx+76]
  004bc	83 e0 04	 and	 eax, 4
  004bf	85 c0		 test	 eax, eax
  004c1	74 4c		 je	 SHORT $LN96@s390_run_s
$LN97@s390_run_s:
  004c3	48 8b 84 24 e0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  004cb	48 8b 80 70 08
	00 00		 mov	 rax, QWORD PTR [rax+2160]
  004d2	48 8b 8c 24 e0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  004da	48 8b 89 70 08
	00 00		 mov	 rcx, QWORD PTR [rcx+2160]
  004e1	8b 49 4c	 mov	 ecx, DWORD PTR [rcx+76]
  004e4	8b 40 48	 mov	 eax, DWORD PTR [rax+72]
  004e7	23 c1		 and	 eax, ecx
  004e9	25 00 00 00 40	 and	 eax, 1073741824		; 40000000H
  004ee	85 c0		 test	 eax, eax
  004f0	74 1d		 je	 SHORT $LN96@s390_run_s

; 1091 :                     )
; 1092 :                     {
; 1093 :                         PERFORM_SERIALIZATION ( GUESTREGS );

  004f2	0f ae f0	 mfence
$LN28@s390_run_s:

; 1094 :                         PERFORM_CHKPT_SYNC    ( GUESTREGS );

  004f5	33 c0		 xor	 eax, eax
  004f7	85 c0		 test	 eax, eax
  004f9	75 fa		 jne	 SHORT $LN28@s390_run_s

; 1095 :                         ARCH_DEP( perform_io_interrupt )( GUESTREGS );

  004fb	48 8b 84 24 e0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00503	48 8b 88 70 08
	00 00		 mov	 rcx, QWORD PTR [rax+2160]
  0050a	e8 00 00 00 00	 call	 s390_perform_io_interrupt
$LN96@s390_run_s:

; 1096 :                     }
; 1097 : 
; 1098 : #if defined( _FEATURE_WAITSTATE_ASSIST )
; 1099 : 
; 1100 :                     /*  Is SIE guest in a wait state
; 1101 :                         AND Wait State Assist enabled?
; 1102 :                     */
; 1103 :                     if (1
; 1104 :                         && WAITSTATE( &GUESTREGS->psw )
; 1105 :                         && (STATEBK->ec[0] & SIE_EC0_WAIA)

  0050f	33 c0		 xor	 eax, eax
  00511	83 f8 01	 cmp	 eax, 1
  00514	0f 84 99 09 00
	00		 je	 $LN98@s390_run_s
  0051a	48 8b 84 24 e0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00522	48 8b 80 70 08
	00 00		 mov	 rax, QWORD PTR [rax+2160]
  00529	0f b6 40 7a	 movzx	 eax, BYTE PTR [rax+122]
  0052d	83 e0 02	 and	 eax, 2
  00530	85 c0		 test	 eax, eax
  00532	0f 84 7b 09 00
	00		 je	 $LN98@s390_run_s
  00538	48 8b 84 24 e0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00540	48 8b 80 70 08
	00 00		 mov	 rax, QWORD PTR [rax+2160]
  00547	48 8b 80 88 08
	00 00		 mov	 rax, QWORD PTR [rax+2184]
  0054e	b9 01 00 00 00	 mov	 ecx, 1
  00553	48 6b c9 00	 imul	 rcx, rcx, 0
  00557	0f b6 44 08 4c	 movzx	 eax, BYTE PTR [rax+rcx+76]
  0055c	83 e0 20	 and	 eax, 32			; 00000020H
  0055f	85 c0		 test	 eax, eax
  00561	0f 84 4c 09 00
	00		 je	 $LN98@s390_run_s

; 1106 :                     )
; 1107 :                     {
; 1108 :                         /* Test for disabled wait PSW and issue message */
; 1109 :                         if (IS_IC_DISABLED_WAIT_PSW( GUESTREGS ))

  00567	48 8b 84 24 e0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0056f	48 8b 80 70 08
	00 00		 mov	 rax, QWORD PTR [rax+2160]
  00576	8b 40 4c	 mov	 eax, DWORD PTR [rax+76]
  00579	25 f0 ff 00 5f	 and	 eax, 1593901040		; 5f00fff0H
  0057e	85 c0		 test	 eax, eax
  00580	75 36		 jne	 SHORT $LN99@s390_run_s

; 1110 :                         {
; 1111 :                             RELEASE_INTLOCK( regs );

  00582	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG180918
  00589	48 8b 8c 24 e0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00591	e8 00 00 00 00	 call	 Release_Interrupt_Lock

; 1112 :                             longjmp( GUESTREGS->progjmp, SIE_INTERCEPT_WAIT );

  00596	48 8b 84 24 e0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0059e	48 8b 80 70 08
	00 00		 mov	 rax, QWORD PTR [rax+2160]
  005a5	48 05 80 09 00
	00		 add	 rax, 2432		; 00000980H
  005ab	ba f8 ff ff ff	 mov	 edx, -8
  005b0	48 8b c8	 mov	 rcx, rax
  005b3	e8 00 00 00 00	 call	 longjmp
$LN99@s390_run_s:

; 1113 :                         }
; 1114 : 
; 1115 :                         /* Skip conditions we cannot assist with */
; 1116 :                         if (0
; 1117 :                             || SIE_I_STOP ( GUESTREGS )
; 1118 :                             || SIE_I_EXT  ( GUESTREGS )
; 1119 :                             || SIE_I_IO   ( GUESTREGS )
; 1120 :                             || SIE_I_HOST (    regs   )

  005b8	33 c0		 xor	 eax, eax
  005ba	85 c0		 test	 eax, eax
  005bc	0f 85 b4 00 00
	00		 jne	 $LN101@s390_run_s
  005c2	48 8b 84 24 e0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  005ca	48 8b 80 70 08
	00 00		 mov	 rax, QWORD PTR [rax+2160]
  005d1	48 8b 80 88 08
	00 00		 mov	 rax, QWORD PTR [rax+2184]
  005d8	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  005db	83 e0 04	 and	 eax, 4
  005de	85 c0		 test	 eax, eax
  005e0	0f 85 90 00 00
	00		 jne	 $LN101@s390_run_s
  005e6	48 8b 84 24 e0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  005ee	48 8b 80 70 08
	00 00		 mov	 rax, QWORD PTR [rax+2160]
  005f5	48 8b 80 88 08
	00 00		 mov	 rax, QWORD PTR [rax+2184]
  005fc	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  005ff	83 e0 01	 and	 eax, 1
  00602	85 c0		 test	 eax, eax
  00604	74 1a		 je	 SHORT $LN102@s390_run_s
  00606	48 8b 84 24 e0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0060e	48 8b 80 70 08
	00 00		 mov	 rax, QWORD PTR [rax+2160]
  00615	0f b6 40 78	 movzx	 eax, BYTE PTR [rax+120]
  00619	83 e0 01	 and	 eax, 1
  0061c	85 c0		 test	 eax, eax
  0061e	75 56		 jne	 SHORT $LN101@s390_run_s
$LN102@s390_run_s:
  00620	48 8b 84 24 e0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00628	48 8b 80 70 08
	00 00		 mov	 rax, QWORD PTR [rax+2160]
  0062f	48 8b 80 88 08
	00 00		 mov	 rax, QWORD PTR [rax+2184]
  00636	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  00639	83 e0 02	 and	 eax, 2
  0063c	85 c0		 test	 eax, eax
  0063e	74 1a		 je	 SHORT $LN103@s390_run_s
  00640	48 8b 84 24 e0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00648	48 8b 80 70 08
	00 00		 mov	 rax, QWORD PTR [rax+2160]
  0064f	0f b6 40 78	 movzx	 eax, BYTE PTR [rax+120]
  00653	83 e0 02	 and	 eax, 2
  00656	85 c0		 test	 eax, eax
  00658	75 1c		 jne	 SHORT $LN101@s390_run_s
$LN103@s390_run_s:
  0065a	48 8b 84 24 e0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00662	48 8b 8c 24 e0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0066a	8b 49 4c	 mov	 ecx, DWORD PTR [rcx+76]
  0066d	8b 40 48	 mov	 eax, DWORD PTR [rax+72]
  00670	23 c1		 and	 eax, ecx
  00672	85 c0		 test	 eax, eax
  00674	74 19		 je	 SHORT $LN100@s390_run_s
$LN101@s390_run_s:

; 1121 :                         )
; 1122 :                         {
; 1123 :                             RELEASE_INTLOCK( regs );

  00676	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG180923
  0067d	48 8b 8c 24 e0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00685	e8 00 00 00 00	 call	 Release_Interrupt_Lock

; 1124 :                             break;

  0068a	e9 d2 0d 00 00	 jmp	 $LN18@s390_run_s
$LN100@s390_run_s:
$LN31@s390_run_s:

; 1125 :                         }
; 1126 : 
; 1127 :                         SET_AEA_MODE( GUESTREGS );

  0068f	48 8b 84 24 e0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00697	48 8b 80 70 08
	00 00		 mov	 rax, QWORD PTR [rax+2160]
  0069e	b9 04 00 00 00	 mov	 ecx, 4
  006a3	48 6b c9 04	 imul	 rcx, rcx, 4
  006a7	8b 84 08 94 0c
	00 00		 mov	 eax, DWORD PTR [rax+rcx+3220]
  006ae	89 44 24 78	 mov	 DWORD PTR inst_cr$3[rsp], eax
  006b2	48 8b 84 24 e0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  006ba	48 8b 80 70 08
	00 00		 mov	 rax, QWORD PTR [rax+2160]
  006c1	0f b6 80 90 0c
	00 00		 movzx	 eax, BYTE PTR [rax+3216]
  006c8	88 44 24 58	 mov	 BYTE PTR oldmode$2[rsp], al
  006cc	48 8b 84 24 e0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  006d4	48 8b 80 70 08
	00 00		 mov	 rax, QWORD PTR [rax+2160]
  006db	0f b6 40 78	 movzx	 eax, BYTE PTR [rax+120]
  006df	83 e0 04	 and	 eax, 4
  006e2	85 c0		 test	 eax, eax
  006e4	75 75		 jne	 SHORT $LN145@s390_run_s
  006e6	48 8b 84 24 e0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  006ee	48 8b 80 70 08
	00 00		 mov	 rax, QWORD PTR [rax+2160]
  006f5	8b 80 c8 08 00
	00		 mov	 eax, DWORD PTR [rax+2248]
  006fb	d1 e8		 shr	 eax, 1
  006fd	83 e0 01	 and	 eax, 1
  00700	85 c0		 test	 eax, eax
  00702	74 45		 je	 SHORT $LN143@s390_run_s
  00704	48 8b 84 24 e0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0070c	48 8b 80 70 08
	00 00		 mov	 rax, QWORD PTR [rax+2160]
  00713	48 8b 80 88 08
	00 00		 mov	 rax, QWORD PTR [rax+2184]
  0071a	0f b6 40 02	 movzx	 eax, BYTE PTR [rax+2]
  0071e	83 e0 01	 and	 eax, 1
  00721	85 c0		 test	 eax, eax
  00723	74 24		 je	 SHORT $LN143@s390_run_s
  00725	48 8b 84 24 e0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0072d	48 8b 80 70 08
	00 00		 mov	 rax, QWORD PTR [rax+2160]
  00734	0f b6 40 7b	 movzx	 eax, BYTE PTR [rax+123]
  00738	83 e0 40	 and	 eax, 64			; 00000040H
  0073b	85 c0		 test	 eax, eax
  0073d	74 0a		 je	 SHORT $LN143@s390_run_s
  0073f	c7 44 24 64 02
	00 00 00	 mov	 DWORD PTR tv360[rsp], 2
  00747	eb 08		 jmp	 SHORT $LN144@s390_run_s
$LN143@s390_run_s:
  00749	c7 44 24 64 00
	00 00 00	 mov	 DWORD PTR tv360[rsp], 0
$LN144@s390_run_s:
  00751	8b 44 24 64	 mov	 eax, DWORD PTR tv360[rsp]
  00755	89 44 24 6c	 mov	 DWORD PTR tv366[rsp], eax
  00759	eb 1c		 jmp	 SHORT $LN146@s390_run_s
$LN145@s390_run_s:
  0075b	48 8b 84 24 e0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00763	48 8b 80 70 08
	00 00		 mov	 rax, QWORD PTR [rax+2160]
  0076a	0f b6 40 7b	 movzx	 eax, BYTE PTR [rax+123]
  0076e	c1 f8 06	 sar	 eax, 6
  00771	ff c0		 inc	 eax
  00773	89 44 24 6c	 mov	 DWORD PTR tv366[rsp], eax
$LN146@s390_run_s:
  00777	33 c0		 xor	 eax, eax
  00779	85 c0		 test	 eax, eax
  0077b	75 63		 jne	 SHORT $LN147@s390_run_s
  0077d	48 8b 84 24 e0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00785	48 8b 80 70 08
	00 00		 mov	 rax, QWORD PTR [rax+2160]
  0078c	0f b6 40 78	 movzx	 eax, BYTE PTR [rax+120]
  00790	83 e0 40	 and	 eax, 64			; 00000040H
  00793	85 c0		 test	 eax, eax
  00795	75 49		 jne	 SHORT $LN147@s390_run_s
  00797	48 8b 84 24 e0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0079f	48 8b 80 70 08
	00 00		 mov	 rax, QWORD PTR [rax+2160]
  007a6	8b 80 c8 08 00
	00		 mov	 eax, DWORD PTR [rax+2248]
  007ac	d1 e8		 shr	 eax, 1
  007ae	83 e0 01	 and	 eax, 1
  007b1	85 c0		 test	 eax, eax
  007b3	74 21		 je	 SHORT $LN148@s390_run_s
  007b5	48 8b 84 24 e0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  007bd	48 8b 80 70 08
	00 00		 mov	 rax, QWORD PTR [rax+2160]
  007c4	48 8b 80 88 08
	00 00		 mov	 rax, QWORD PTR [rax+2184]
  007cb	0f b6 40 03	 movzx	 eax, BYTE PTR [rax+3]
  007cf	83 e0 01	 and	 eax, 1
  007d2	85 c0		 test	 eax, eax
  007d4	75 0a		 jne	 SHORT $LN147@s390_run_s
$LN148@s390_run_s:
  007d6	c7 44 24 68 00
	00 00 00	 mov	 DWORD PTR tv384[rsp], 0
  007de	eb 08		 jmp	 SHORT $LN149@s390_run_s
$LN147@s390_run_s:
  007e0	c7 44 24 68 40
	00 00 00	 mov	 DWORD PTR tv384[rsp], 64 ; 00000040H
$LN149@s390_run_s:
  007e8	8b 44 24 68	 mov	 eax, DWORD PTR tv384[rsp]
  007ec	8b 4c 24 6c	 mov	 ecx, DWORD PTR tv366[rsp]
  007f0	0b c8		 or	 ecx, eax
  007f2	8b c1		 mov	 eax, ecx
  007f4	48 8b 8c 24 e0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  007fc	48 8b 89 70 08
	00 00		 mov	 rcx, QWORD PTR [rcx+2160]
  00803	88 81 90 0c 00
	00		 mov	 BYTE PTR [rcx+3216], al
  00809	48 8b 84 24 e0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00811	48 8b 80 70 08
	00 00		 mov	 rax, QWORD PTR [rax+2160]
  00818	0f b6 80 90 0c
	00 00		 movzx	 eax, BYTE PTR [rax+3216]
  0081f	83 e0 0f	 and	 eax, 15
  00822	89 44 24 60	 mov	 DWORD PTR tv391[rsp], eax
  00826	83 7c 24 60 01	 cmp	 DWORD PTR tv391[rsp], 1
  0082b	74 22		 je	 SHORT $LN104@s390_run_s
  0082d	83 7c 24 60 02	 cmp	 DWORD PTR tv391[rsp], 2
  00832	74 61		 je	 SHORT $LN105@s390_run_s
  00834	83 7c 24 60 03	 cmp	 DWORD PTR tv391[rsp], 3
  00839	0f 84 46 01 00
	00		 je	 $LN109@s390_run_s
  0083f	83 7c 24 60 04	 cmp	 DWORD PTR tv391[rsp], 4
  00844	0f 84 a4 01 00
	00		 je	 $LN110@s390_run_s
  0084a	e9 e2 01 00 00	 jmp	 $LN111@s390_run_s
$LN104@s390_run_s:
  0084f	c7 44 24 50 ff
	ff ff ff	 mov	 DWORD PTR i$1[rsp], -1
  00857	eb 0a		 jmp	 SHORT $LN36@s390_run_s
$LN34@s390_run_s:
  00859	8b 44 24 50	 mov	 eax, DWORD PTR i$1[rsp]
  0085d	ff c0		 inc	 eax
  0085f	89 44 24 50	 mov	 DWORD PTR i$1[rsp], eax
$LN36@s390_run_s:
  00863	83 7c 24 50 10	 cmp	 DWORD PTR i$1[rsp], 16
  00868	7d 26		 jge	 SHORT $LN35@s390_run_s
  0086a	48 8b 84 24 e0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00872	48 8b 80 70 08
	00 00		 mov	 rax, QWORD PTR [rax+2160]
  00879	8b 4c 24 50	 mov	 ecx, DWORD PTR i$1[rsp]
  0087d	83 c1 05	 add	 ecx, 5
  00880	48 63 c9	 movsxd	 rcx, ecx
  00883	c7 84 88 94 0c
	00 00 01 00 00
	00		 mov	 DWORD PTR [rax+rcx*4+3220], 1
  0088e	eb c9		 jmp	 SHORT $LN34@s390_run_s
$LN35@s390_run_s:
  00890	e9 dd 01 00 00	 jmp	 $LN32@s390_run_s
$LN105@s390_run_s:
  00895	c7 44 24 50 ff
	ff ff ff	 mov	 DWORD PTR i$1[rsp], -1
  0089d	eb 0a		 jmp	 SHORT $LN39@s390_run_s
$LN37@s390_run_s:
  0089f	8b 44 24 50	 mov	 eax, DWORD PTR i$1[rsp]
  008a3	ff c0		 inc	 eax
  008a5	89 44 24 50	 mov	 DWORD PTR i$1[rsp], eax
$LN39@s390_run_s:
  008a9	83 7c 24 50 10	 cmp	 DWORD PTR i$1[rsp], 16
  008ae	7d 26		 jge	 SHORT $LN38@s390_run_s
  008b0	48 8b 84 24 e0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  008b8	48 8b 80 70 08
	00 00		 mov	 rax, QWORD PTR [rax+2160]
  008bf	8b 4c 24 50	 mov	 ecx, DWORD PTR i$1[rsp]
  008c3	83 c1 05	 add	 ecx, 5
  008c6	48 63 c9	 movsxd	 rcx, ecx
  008c9	c7 84 88 94 0c
	00 00 01 00 00
	00		 mov	 DWORD PTR [rax+rcx*4+3220], 1
  008d4	eb c9		 jmp	 SHORT $LN37@s390_run_s
$LN38@s390_run_s:
  008d6	c7 44 24 50 01
	00 00 00	 mov	 DWORD PTR i$1[rsp], 1
  008de	eb 0a		 jmp	 SHORT $LN42@s390_run_s
$LN40@s390_run_s:
  008e0	8b 44 24 50	 mov	 eax, DWORD PTR i$1[rsp]
  008e4	ff c0		 inc	 eax
  008e6	89 44 24 50	 mov	 DWORD PTR i$1[rsp], eax
$LN42@s390_run_s:
  008ea	83 7c 24 50 10	 cmp	 DWORD PTR i$1[rsp], 16
  008ef	0f 8d 8b 00 00
	00		 jge	 $LN41@s390_run_s
  008f5	48 8b 84 24 e0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  008fd	48 8b 80 70 08
	00 00		 mov	 rax, QWORD PTR [rax+2160]
  00904	48 63 4c 24 50	 movsxd	 rcx, DWORD PTR i$1[rsp]
  00909	83 bc 88 00 03
	00 00 01	 cmp	 DWORD PTR [rax+rcx*4+768], 1
  00911	75 26		 jne	 SHORT $LN106@s390_run_s
  00913	48 8b 84 24 e0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0091b	48 8b 80 70 08
	00 00		 mov	 rax, QWORD PTR [rax+2160]
  00922	8b 4c 24 50	 mov	 ecx, DWORD PTR i$1[rsp]
  00926	83 c1 05	 add	 ecx, 5
  00929	48 63 c9	 movsxd	 rcx, ecx
  0092c	c7 84 88 94 0c
	00 00 07 00 00
	00		 mov	 DWORD PTR [rax+rcx*4+3220], 7
  00937	eb 42		 jmp	 SHORT $LN107@s390_run_s
$LN106@s390_run_s:
  00939	48 8b 84 24 e0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00941	48 8b 80 70 08
	00 00		 mov	 rax, QWORD PTR [rax+2160]
  00948	48 63 4c 24 50	 movsxd	 rcx, DWORD PTR i$1[rsp]
  0094d	83 bc 88 00 03
	00 00 00	 cmp	 DWORD PTR [rax+rcx*4+768], 0
  00955	74 24		 je	 SHORT $LN108@s390_run_s
  00957	48 8b 84 24 e0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0095f	48 8b 80 70 08
	00 00		 mov	 rax, QWORD PTR [rax+2160]
  00966	8b 4c 24 50	 mov	 ecx, DWORD PTR i$1[rsp]
  0096a	83 c1 05	 add	 ecx, 5
  0096d	48 63 c9	 movsxd	 rcx, ecx
  00970	c7 84 88 94 0c
	00 00 00 00 00
	00		 mov	 DWORD PTR [rax+rcx*4+3220], 0
$LN108@s390_run_s:
$LN107@s390_run_s:
  0097b	e9 60 ff ff ff	 jmp	 $LN40@s390_run_s
$LN41@s390_run_s:
  00980	e9 ed 00 00 00	 jmp	 $LN32@s390_run_s
$LN109@s390_run_s:
  00985	48 8b 84 24 e0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0098d	48 8b 80 70 08
	00 00		 mov	 rax, QWORD PTR [rax+2160]
  00994	b9 04 00 00 00	 mov	 ecx, 4
  00999	48 6b c9 04	 imul	 rcx, rcx, 4
  0099d	c7 84 08 94 0c
	00 00 01 00 00
	00		 mov	 DWORD PTR [rax+rcx+3220], 1
  009a8	c7 44 24 50 00
	00 00 00	 mov	 DWORD PTR i$1[rsp], 0
  009b0	eb 0a		 jmp	 SHORT $LN45@s390_run_s
$LN43@s390_run_s:
  009b2	8b 44 24 50	 mov	 eax, DWORD PTR i$1[rsp]
  009b6	ff c0		 inc	 eax
  009b8	89 44 24 50	 mov	 DWORD PTR i$1[rsp], eax
$LN45@s390_run_s:
  009bc	83 7c 24 50 10	 cmp	 DWORD PTR i$1[rsp], 16
  009c1	7d 26		 jge	 SHORT $LN44@s390_run_s
  009c3	48 8b 84 24 e0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  009cb	48 8b 80 70 08
	00 00		 mov	 rax, QWORD PTR [rax+2160]
  009d2	8b 4c 24 50	 mov	 ecx, DWORD PTR i$1[rsp]
  009d6	83 c1 05	 add	 ecx, 5
  009d9	48 63 c9	 movsxd	 rcx, ecx
  009dc	c7 84 88 94 0c
	00 00 07 00 00
	00		 mov	 DWORD PTR [rax+rcx*4+3220], 7
  009e7	eb c9		 jmp	 SHORT $LN43@s390_run_s
$LN44@s390_run_s:
  009e9	e9 84 00 00 00	 jmp	 $LN32@s390_run_s
$LN110@s390_run_s:
  009ee	c7 44 24 50 ff
	ff ff ff	 mov	 DWORD PTR i$1[rsp], -1
  009f6	eb 0a		 jmp	 SHORT $LN48@s390_run_s
$LN46@s390_run_s:
  009f8	8b 44 24 50	 mov	 eax, DWORD PTR i$1[rsp]
  009fc	ff c0		 inc	 eax
  009fe	89 44 24 50	 mov	 DWORD PTR i$1[rsp], eax
$LN48@s390_run_s:
  00a02	83 7c 24 50 10	 cmp	 DWORD PTR i$1[rsp], 16
  00a07	7d 26		 jge	 SHORT $LN47@s390_run_s
  00a09	48 8b 84 24 e0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00a11	48 8b 80 70 08
	00 00		 mov	 rax, QWORD PTR [rax+2160]
  00a18	8b 4c 24 50	 mov	 ecx, DWORD PTR i$1[rsp]
  00a1c	83 c1 05	 add	 ecx, 5
  00a1f	48 63 c9	 movsxd	 rcx, ecx
  00a22	c7 84 88 94 0c
	00 00 0d 00 00
	00		 mov	 DWORD PTR [rax+rcx*4+3220], 13
  00a2d	eb c9		 jmp	 SHORT $LN46@s390_run_s
$LN47@s390_run_s:
  00a2f	eb 41		 jmp	 SHORT $LN32@s390_run_s
$LN111@s390_run_s:
  00a31	c7 44 24 50 ff
	ff ff ff	 mov	 DWORD PTR i$1[rsp], -1
  00a39	eb 0a		 jmp	 SHORT $LN51@s390_run_s
$LN49@s390_run_s:
  00a3b	8b 44 24 50	 mov	 eax, DWORD PTR i$1[rsp]
  00a3f	ff c0		 inc	 eax
  00a41	89 44 24 50	 mov	 DWORD PTR i$1[rsp], eax
$LN51@s390_run_s:
  00a45	83 7c 24 50 10	 cmp	 DWORD PTR i$1[rsp], 16
  00a4a	7d 26		 jge	 SHORT $LN50@s390_run_s
  00a4c	48 8b 84 24 e0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00a54	48 8b 80 70 08
	00 00		 mov	 rax, QWORD PTR [rax+2160]
  00a5b	8b 4c 24 50	 mov	 ecx, DWORD PTR i$1[rsp]
  00a5f	83 c1 05	 add	 ecx, 5
  00a62	48 63 c9	 movsxd	 rcx, ecx
  00a65	c7 84 88 94 0c
	00 00 ff ff ff
	ff		 mov	 DWORD PTR [rax+rcx*4+3220], -1
  00a70	eb c9		 jmp	 SHORT $LN49@s390_run_s
$LN50@s390_run_s:
$LN32@s390_run_s:
  00a72	48 8b 84 24 e0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00a7a	48 8b 80 70 08
	00 00		 mov	 rax, QWORD PTR [rax+2160]
  00a81	b9 04 00 00 00	 mov	 ecx, 4
  00a86	48 6b c9 04	 imul	 rcx, rcx, 4
  00a8a	8b 84 08 94 0c
	00 00		 mov	 eax, DWORD PTR [rax+rcx+3220]
  00a91	39 44 24 78	 cmp	 DWORD PTR inst_cr$3[rsp], eax
  00a95	0f 84 b2 00 00
	00		 je	 $LN112@s390_run_s
$LN54@s390_run_s:
  00a9b	48 8b 84 24 e0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00aa3	48 8b 80 70 08
	00 00		 mov	 rax, QWORD PTR [rax+2160]
  00aaa	48 83 b8 08 02
	00 00 00	 cmp	 QWORD PTR [rax+520], 0
  00ab2	0f 84 8b 00 00
	00		 je	 $LN113@s390_run_s
  00ab8	48 8b 84 24 e0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00ac0	48 8b 80 70 08
	00 00		 mov	 rax, QWORD PTR [rax+2160]
  00ac7	8b 80 10 02 00
	00		 mov	 eax, DWORD PTR [rax+528]
  00acd	48 8b 8c 24 e0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00ad5	48 8b 89 70 08
	00 00		 mov	 rcx, QWORD PTR [rcx+2160]
  00adc	48 8b 94 24 e0
	00 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  00ae4	48 8b 92 70 08
	00 00		 mov	 rdx, QWORD PTR [rdx+2160]
  00aeb	48 8b 92 00 02
	00 00		 mov	 rdx, QWORD PTR [rdx+512]
  00af2	48 8b 49 68	 mov	 rcx, QWORD PTR [rcx+104]
  00af6	48 2b ca	 sub	 rcx, rdx
  00af9	48 03 c1	 add	 rax, rcx
  00afc	48 8b 8c 24 e0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00b04	48 8b 89 70 08
	00 00		 mov	 rcx, QWORD PTR [rcx+2160]
  00b0b	8b 89 90 00 00
	00		 mov	 ecx, DWORD PTR [rcx+144]
  00b11	48 23 c1	 and	 rax, rcx
  00b14	48 8b 8c 24 e0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00b1c	48 8b 89 70 08
	00 00		 mov	 rcx, QWORD PTR [rcx+2160]
  00b23	89 81 88 00 00
	00		 mov	 DWORD PTR [rcx+136], eax
  00b29	48 8b 84 24 e0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00b31	48 8b 80 70 08
	00 00		 mov	 rax, QWORD PTR [rax+2160]
  00b38	48 c7 80 08 02
	00 00 00 00 00
	00		 mov	 QWORD PTR [rax+520], 0
$LN113@s390_run_s:
  00b43	33 c0		 xor	 eax, eax
  00b45	85 c0		 test	 eax, eax
  00b47	0f 85 4e ff ff
	ff		 jne	 $LN54@s390_run_s
$LN112@s390_run_s:
  00b4d	0f b6 44 24 58	 movzx	 eax, BYTE PTR oldmode$2[rsp]
  00b52	83 e0 40	 and	 eax, 64			; 00000040H
  00b55	85 c0		 test	 eax, eax
  00b57	0f 85 3c 01 00
	00		 jne	 $LN114@s390_run_s
  00b5d	48 8b 84 24 e0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00b65	48 8b 80 70 08
	00 00		 mov	 rax, QWORD PTR [rax+2160]
  00b6c	0f b6 80 90 0c
	00 00		 movzx	 eax, BYTE PTR [rax+3216]
  00b73	83 e0 40	 and	 eax, 64			; 00000040H
  00b76	85 c0		 test	 eax, eax
  00b78	0f 84 1b 01 00
	00		 je	 $LN114@s390_run_s
$LN57@s390_run_s:
  00b7e	48 8b 84 24 e0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00b86	48 8b 80 70 08
	00 00		 mov	 rax, QWORD PTR [rax+2160]
  00b8d	48 83 b8 08 02
	00 00 00	 cmp	 QWORD PTR [rax+520], 0
  00b95	0f 84 8b 00 00
	00		 je	 $LN115@s390_run_s
  00b9b	48 8b 84 24 e0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00ba3	48 8b 80 70 08
	00 00		 mov	 rax, QWORD PTR [rax+2160]
  00baa	8b 80 10 02 00
	00		 mov	 eax, DWORD PTR [rax+528]
  00bb0	48 8b 8c 24 e0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00bb8	48 8b 89 70 08
	00 00		 mov	 rcx, QWORD PTR [rcx+2160]
  00bbf	48 8b 94 24 e0
	00 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  00bc7	48 8b 92 70 08
	00 00		 mov	 rdx, QWORD PTR [rdx+2160]
  00bce	48 8b 92 00 02
	00 00		 mov	 rdx, QWORD PTR [rdx+512]
  00bd5	48 8b 49 68	 mov	 rcx, QWORD PTR [rcx+104]
  00bd9	48 2b ca	 sub	 rcx, rdx
  00bdc	48 03 c1	 add	 rax, rcx
  00bdf	48 8b 8c 24 e0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00be7	48 8b 89 70 08
	00 00		 mov	 rcx, QWORD PTR [rcx+2160]
  00bee	8b 89 90 00 00
	00		 mov	 ecx, DWORD PTR [rcx+144]
  00bf4	48 23 c1	 and	 rax, rcx
  00bf7	48 8b 8c 24 e0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00bff	48 8b 89 70 08
	00 00		 mov	 rcx, QWORD PTR [rcx+2160]
  00c06	89 81 88 00 00
	00		 mov	 DWORD PTR [rcx+136], eax
  00c0c	48 8b 84 24 e0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00c14	48 8b 80 70 08
	00 00		 mov	 rax, QWORD PTR [rax+2160]
  00c1b	48 c7 80 08 02
	00 00 00 00 00
	00		 mov	 QWORD PTR [rax+520], 0
$LN115@s390_run_s:
  00c26	33 c0		 xor	 eax, eax
  00c28	85 c0		 test	 eax, eax
  00c2a	0f 85 4e ff ff
	ff		 jne	 $LN57@s390_run_s
  00c30	48 8b 84 24 e0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00c38	48 8b 80 70 08
	00 00		 mov	 rax, QWORD PTR [rax+2160]
  00c3f	8b 80 28 07 00
	00		 mov	 eax, DWORD PTR [rax+1832]
  00c45	c1 e8 02	 shr	 eax, 2
  00c48	83 e0 01	 and	 eax, 1
  00c4b	85 c0		 test	 eax, eax
  00c4d	74 0a		 je	 SHORT $LN152@s390_run_s
  00c4f	c7 44 24 70 01
	00 00 00	 mov	 DWORD PTR tv535[rsp], 1
  00c57	eb 08		 jmp	 SHORT $LN153@s390_run_s
$LN152@s390_run_s:
  00c59	c7 44 24 70 00
	00 00 00	 mov	 DWORD PTR tv535[rsp], 0
$LN153@s390_run_s:
  00c61	83 7c 24 70 00	 cmp	 DWORD PTR tv535[rsp], 0
  00c66	74 31		 je	 SHORT $LN116@s390_run_s
  00c68	48 8b 84 24 e0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00c70	48 8b 80 70 08
	00 00		 mov	 rax, QWORD PTR [rax+2160]
  00c77	8b 40 48	 mov	 eax, DWORD PTR [rax+72]
  00c7a	25 00 00 20 00	 and	 eax, 2097152		; 00200000H
  00c7f	85 c0		 test	 eax, eax
  00c81	74 16		 je	 SHORT $LN116@s390_run_s
  00c83	b2 fc		 mov	 dl, 252			; 000000fcH
  00c85	48 8b 84 24 e0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00c8d	48 8b 88 70 08
	00 00		 mov	 rcx, QWORD PTR [rax+2160]
  00c94	e8 00 00 00 00	 call	 s390_invalidate_tlb
$LN116@s390_run_s:
$LN114@s390_run_s:
  00c99	33 c0		 xor	 eax, eax
  00c9b	85 c0		 test	 eax, eax
  00c9d	0f 85 ec f9 ff
	ff		 jne	 $LN31@s390_run_s

; 1128 : 
; 1129 :                         /* Assist with the wait... but only briefly */
; 1130 :                         {
; 1131 :                             struct timespec waittime;
; 1132 : 
; 1133 :                             U64 now = host_tod();

  00ca3	e8 00 00 00 00	 call	 host_tod
  00ca8	48 89 84 24 80
	00 00 00	 mov	 QWORD PTR now$4[rsp], rax

; 1134 : 
; 1135 :                             waittime.tv_sec  =   (now >> (64-51)) / ONE_MILLION;

  00cb0	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR now$4[rsp]
  00cb8	48 c1 e8 0d	 shr	 rax, 13
  00cbc	33 d2		 xor	 edx, edx
  00cbe	b9 40 42 0f 00	 mov	 ecx, 1000000		; 000f4240H
  00cc3	48 f7 f1	 div	 rcx
  00cc6	48 89 84 24 b8
	00 00 00	 mov	 QWORD PTR waittime$5[rsp], rax

; 1136 :                             waittime.tv_nsec = (((now >> (64-51)) % ONE_MILLION) + 3333) * 1000;

  00cce	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR now$4[rsp]
  00cd6	48 c1 e8 0d	 shr	 rax, 13
  00cda	33 d2		 xor	 edx, edx
  00cdc	b9 40 42 0f 00	 mov	 ecx, 1000000		; 000f4240H
  00ce1	48 f7 f1	 div	 rcx
  00ce4	48 8b c2	 mov	 rax, rdx
  00ce7	48 05 05 0d 00
	00		 add	 rax, 3333		; 00000d05H
  00ced	48 69 c0 e8 03
	00 00		 imul	 rax, rax, 1000		; 000003e8H
  00cf4	89 84 24 c0 00
	00 00		 mov	 DWORD PTR waittime$5[rsp+8], eax

; 1137 :                             waittime.tv_sec  += waittime.tv_nsec /  ONE_BILLION;

  00cfb	48 63 84 24 c0
	00 00 00	 movsxd	 rax, DWORD PTR waittime$5[rsp+8]
  00d03	33 d2		 xor	 edx, edx
  00d05	b9 00 ca 9a 3b	 mov	 ecx, 1000000000		; 3b9aca00H
  00d0a	48 f7 f1	 div	 rcx
  00d0d	48 8b 8c 24 b8
	00 00 00	 mov	 rcx, QWORD PTR waittime$5[rsp]
  00d15	48 03 c8	 add	 rcx, rax
  00d18	48 8b c1	 mov	 rax, rcx
  00d1b	48 89 84 24 b8
	00 00 00	 mov	 QWORD PTR waittime$5[rsp], rax

; 1138 :                             waittime.tv_nsec %=                     ONE_BILLION;

  00d23	48 63 84 24 c0
	00 00 00	 movsxd	 rax, DWORD PTR waittime$5[rsp+8]
  00d2b	33 d2		 xor	 edx, edx
  00d2d	b9 00 ca 9a 3b	 mov	 ecx, 1000000000		; 3b9aca00H
  00d32	48 f7 f1	 div	 rcx
  00d35	48 8b c2	 mov	 rax, rdx
  00d38	89 84 24 c0 00
	00 00		 mov	 DWORD PTR waittime$5[rsp+8], eax

; 1139 : 
; 1140 :                             regs->waittod = now;

  00d3f	48 8b 84 24 e0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00d47	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR now$4[rsp]
  00d4f	48 89 88 b8 07
	00 00		 mov	 QWORD PTR [rax+1976], rcx

; 1141 : 
; 1142 :                             sysblk.waiting_mask  |=  regs->cpubit;

  00d56	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00d5d	48 8b 8c 24 e0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00d65	48 8b 49 50	 mov	 rcx, QWORD PTR [rcx+80]
  00d69	48 8b 80 b8 12
	00 00		 mov	 rax, QWORD PTR [rax+4792]
  00d70	48 0b c1	 or	 rax, rcx
  00d73	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  00d7a	48 89 81 b8 12
	00 00		 mov	 QWORD PTR [rcx+4792], rax

; 1143 :                             sysblk.intowner       =  LOCK_OWNER_NONE;

  00d81	b8 ff ff 00 00	 mov	 eax, 65535		; 0000ffffH
  00d86	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  00d8d	66 89 81 62 10
	00 00		 mov	 WORD PTR [rcx+4194], ax

; 1144 :                             {
; 1145 :                                 timed_wait_condition( &regs->intcond, &sysblk.intlock, &waittime );

  00d94	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00d9b	48 05 70 10 00
	00		 add	 rax, 4208		; 00001070H
  00da1	48 8b 8c 24 e0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00da9	48 81 c1 80 0c
	00 00		 add	 rcx, 3200		; 00000c80H
  00db0	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG180937
  00db7	4c 8d 84 24 b8
	00 00 00	 lea	 r8, QWORD PTR waittime$5[rsp]
  00dbf	48 8b d0	 mov	 rdx, rax
  00dc2	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_timed_wait_condition
$LN58@s390_run_s:

; 1146 : 
; 1147 :                                 while (sysblk.syncing)

  00dc8	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00dcf	0f b6 80 7c 13
	00 00		 movzx	 eax, BYTE PTR [rax+4988]
  00dd6	85 c0		 test	 eax, eax
  00dd8	74 2d		 je	 SHORT $LN59@s390_run_s

; 1148 :                                      wait_condition( &sysblk.sync_done_cond, &sysblk.intlock );

  00dda	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00de1	48 05 70 10 00
	00		 add	 rax, 4208		; 00001070H
  00de7	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  00dee	48 81 c1 90 13
	00 00		 add	 rcx, 5008		; 00001390H
  00df5	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG180938
  00dfc	48 8b d0	 mov	 rdx, rax
  00dff	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_wait_condition
  00e05	eb c1		 jmp	 SHORT $LN58@s390_run_s
$LN59@s390_run_s:

; 1149 :                             }
; 1150 :                             sysblk.intowner       =   regs->cpuad;

  00e07	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00e0e	48 8b 8c 24 e0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00e16	0f b7 89 3c 08
	00 00		 movzx	 ecx, WORD PTR [rcx+2108]
  00e1d	66 89 88 62 10
	00 00		 mov	 WORD PTR [rax+4194], cx

; 1151 :                             sysblk.waiting_mask  &=  ~regs->cpubit;

  00e24	48 8b 84 24 e0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00e2c	48 8b 40 50	 mov	 rax, QWORD PTR [rax+80]
  00e30	48 f7 d0	 not	 rax
  00e33	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  00e3a	48 8b 89 b8 12
	00 00		 mov	 rcx, QWORD PTR [rcx+4792]
  00e41	48 23 c8	 and	 rcx, rax
  00e44	48 8b c1	 mov	 rax, rcx
  00e47	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  00e4e	48 89 81 b8 12
	00 00		 mov	 QWORD PTR [rcx+4792], rax

; 1152 : 
; 1153 :                             regs->waittime += host_tod() - regs->waittod;

  00e55	e8 00 00 00 00	 call	 host_tod
  00e5a	48 8b 8c 24 e0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00e62	48 2b 81 b8 07
	00 00		 sub	 rax, QWORD PTR [rcx+1976]
  00e69	48 8b 8c 24 e0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00e71	48 03 81 c0 07
	00 00		 add	 rax, QWORD PTR [rcx+1984]
  00e78	48 8b 8c 24 e0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00e80	48 89 81 c0 07
	00 00		 mov	 QWORD PTR [rcx+1984], rax

; 1154 :                             regs->waittod = 0;

  00e87	48 8b 84 24 e0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00e8f	48 c7 80 b8 07
	00 00 00 00 00
	00		 mov	 QWORD PTR [rax+1976], 0

; 1155 :                         }
; 1156 : 
; 1157 :                         RELEASE_INTLOCK( regs );

  00e9a	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG180939
  00ea1	48 8b 8c 24 e0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00ea9	e8 00 00 00 00	 call	 Release_Interrupt_Lock

; 1158 :                         break;

  00eae	e9 ae 05 00 00	 jmp	 $LN18@s390_run_s
$LN98@s390_run_s:

; 1159 : 
; 1160 :                     }
; 1161 : #endif /* defined( _FEATURE_WAITSTATE_ASSIST ) */
; 1162 : 
; 1163 :                     RELEASE_INTLOCK( regs );

  00eb3	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG180940
  00eba	48 8b 8c 24 e0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00ec2	e8 00 00 00 00	 call	 Release_Interrupt_Lock
$LN92@s390_run_s:

; 1164 :                 }
; 1165 : 
; 1166 :                 /* Break out of loop if SIE guest is waiting */
; 1167 :                 if (SIE_I_WAIT( GUESTREGS ))

  00ec7	48 8b 84 24 e0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00ecf	48 8b 80 70 08
	00 00		 mov	 rax, QWORD PTR [rax+2160]
  00ed6	0f b6 40 7a	 movzx	 eax, BYTE PTR [rax+122]
  00eda	83 e0 02	 and	 eax, 2
  00edd	85 c0		 test	 eax, eax
  00edf	74 30		 je	 SHORT $LN117@s390_run_s
  00ee1	48 8b 84 24 e0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00ee9	48 8b 80 70 08
	00 00		 mov	 rax, QWORD PTR [rax+2160]
  00ef0	48 8b 80 88 08
	00 00		 mov	 rax, QWORD PTR [rax+2184]
  00ef7	b9 01 00 00 00	 mov	 ecx, 1
  00efc	48 6b c9 00	 imul	 rcx, rcx, 0
  00f00	0f b6 44 08 4c	 movzx	 eax, BYTE PTR [rax+rcx+76]
  00f05	83 e0 20	 and	 eax, 32			; 00000020H
  00f08	85 c0		 test	 eax, eax
  00f0a	75 05		 jne	 SHORT $LN117@s390_run_s

; 1168 :                     break;

  00f0c	e9 50 05 00 00	 jmp	 $LN18@s390_run_s
$LN117@s390_run_s:
$sie_fetch_instruction$164:

; 1169 : 
; 1170 : sie_fetch_instruction:
; 1171 : 
; 1172 :                 ip = INSTRUCTION_FETCH( GUESTREGS, 0 );

  00f11	33 c0		 xor	 eax, eax
  00f13	83 f8 01	 cmp	 eax, 1
  00f16	74 2b		 je	 SHORT $LN154@s390_run_s
  00f18	48 8b 84 24 e0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00f20	48 8b 80 70 08
	00 00		 mov	 rax, QWORD PTR [rax+2160]
  00f27	48 8b 8c 24 e0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00f2f	48 8b 89 70 08
	00 00		 mov	 rcx, QWORD PTR [rcx+2160]
  00f36	48 8b 89 08 02
	00 00		 mov	 rcx, QWORD PTR [rcx+520]
  00f3d	48 39 48 68	 cmp	 QWORD PTR [rax+104], rcx
  00f41	72 10		 jb	 SHORT $LN155@s390_run_s
$LN154@s390_run_s:
  00f43	33 c0		 xor	 eax, eax
  00f45	85 c0		 test	 eax, eax
  00f47	75 0a		 jne	 SHORT $LN155@s390_run_s
  00f49	c7 44 24 74 00
	00 00 00	 mov	 DWORD PTR tv625[rsp], 0
  00f51	eb 08		 jmp	 SHORT $LN159@s390_run_s
$LN155@s390_run_s:
  00f53	c7 44 24 74 01
	00 00 00	 mov	 DWORD PTR tv625[rsp], 1
$LN159@s390_run_s:
  00f5b	83 7c 24 74 00	 cmp	 DWORD PTR tv625[rsp], 0
  00f60	74 1d		 je	 SHORT $LN160@s390_run_s
  00f62	48 8b 84 24 e0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00f6a	48 8b 80 70 08
	00 00		 mov	 rax, QWORD PTR [rax+2160]
  00f71	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  00f75	48 89 84 24 98
	00 00 00	 mov	 QWORD PTR tv633[rsp], rax
  00f7d	eb 1e		 jmp	 SHORT $LN161@s390_run_s
$LN160@s390_run_s:
  00f7f	33 d2		 xor	 edx, edx
  00f81	48 8b 84 24 e0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00f89	48 8b 88 70 08
	00 00		 mov	 rcx, QWORD PTR [rax+2160]
  00f90	e8 00 00 00 00	 call	 s390_instfetch
  00f95	48 89 84 24 98
	00 00 00	 mov	 QWORD PTR tv633[rsp], rax
$LN161@s390_run_s:
  00f9d	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR tv633[rsp]
  00fa5	48 89 84 24 88
	00 00 00	 mov	 QWORD PTR ip$[rsp], rax

; 1173 :                 current_opcode_table = GUESTREGS->ARCH_DEP( runtime_opcode_xxxx );

  00fad	48 8b 84 24 e0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00fb5	48 8b 80 70 08
	00 00		 mov	 rax, QWORD PTR [rax+2160]
  00fbc	48 8b 80 f8 af
	00 00		 mov	 rax, QWORD PTR [rax+45048]
  00fc3	48 89 84 24 90
	00 00 00	 mov	 QWORD PTR current_opcode_table$[rsp], rax
$LN62@s390_run_s:

; 1174 : 
; 1175 : #if defined( SIE_DEBUG )
; 1176 :                 ARCH_DEP( display_inst )( GUESTREGS, GUESTREGS->instinvalid ? NULL : ip );
; 1177 : #endif
; 1178 :                 //--------------------------------------------------------------
; 1179 :                 //                    PROGRAMMING NOTE
; 1180 :                 //--------------------------------------------------------------
; 1181 :                 // The first 'fastest_no_txf_loop' loop below is used when the
; 1182 :                 // TXF facility is not enabled, and since facilities cannot be
; 1183 :                 // enabled or disabled once the guest system has been IPLed and
; 1184 :                 // started, it utilizes our original instruction execution loop
; 1185 :                 // which uses the 'EXECUTE_INSTRUCTION' and 'UNROLLED_EXECUTE'
; 1186 :                 // macros which do not have any TXF related code in them.
; 1187 :                 //
; 1188 :                 // The second and third loops below (the 'txf_facility_loop' and
; 1189 :                 // 'txf_slower_loop') are used when the TXF facility is enabled,
; 1190 :                 // requiring us to check whether or not a transaction is active
; 1191 :                 // or not after each instruction is executed.
; 1192 :                 //
; 1193 :                 // If no transaction is active, the normal 'EXECUTE_INSTRUCTION'
; 1194 :                 // and 'UNROLLED_EXECUTE' macros can be used, but a check for an
; 1195 :                 // active transaction still needs to be performed after each and
; 1196 :                 // every instruction (so we can know which loop we need to use).
; 1197 :                 //
; 1198 :                 // When a transaction is active, we use the third (slowest) loop
; 1199 :                 // called 'txf_slower_loop', using the 'TXF_EXECUTE_INSTRUCTION'
; 1200 :                 // and 'TXF_UNROLLED_EXECUTE' macros, which contain code that
; 1201 :                 // enforces certain Transaction-Exceution Facility constraints.
; 1202 :                 //--------------------------------------------------------------
; 1203 : 
; 1204 : #if defined( FEATURE_073_TRANSACT_EXEC_FACILITY )
; 1205 :                 if (FACILITY_ENABLED( 073_TRANSACT_EXEC, GUESTREGS ))
; 1206 :                     goto txf_facility_loop;
; 1207 : #endif
; 1208 : 
; 1209 : //fastest_no_txf_loop:
; 1210 : 
; 1211 :                 SIE_PERFMON( SIE_PERF_EXEC );
; 1212 : 
; 1213 :                 PROCESS_TRACE( GUESTREGS, ip, sie_fetch_instruction );

  00fcb	48 8b 84 24 e0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00fd3	48 8b 80 70 08
	00 00		 mov	 rax, QWORD PTR [rax+2160]
  00fda	8b 80 28 07 00
	00		 mov	 eax, DWORD PTR [rax+1832]
  00fe0	c1 e8 10	 shr	 eax, 16
  00fe3	83 e0 01	 and	 eax, 1
  00fe6	85 c0		 test	 eax, eax
  00fe8	0f 84 15 01 00
	00		 je	 $LN118@s390_run_s
  00fee	48 8b 94 24 88
	00 00 00	 mov	 rdx, QWORD PTR ip$[rsp]
  00ff6	48 8b 84 24 e0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00ffe	48 8b 88 70 08
	00 00		 mov	 rcx, QWORD PTR [rax+2160]
  01005	e8 00 00 00 00	 call	 s390_process_trace
  0100a	33 c0		 xor	 eax, eax
  0100c	83 f8 01	 cmp	 eax, 1
  0100f	0f 84 ee 00 00
	00		 je	 $LN119@s390_run_s
  01015	48 8b 84 24 e0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0101d	48 8b 80 70 08
	00 00		 mov	 rax, QWORD PTR [rax+2160]
  01024	8b 80 28 07 00
	00		 mov	 eax, DWORD PTR [rax+1832]
  0102a	c1 e8 11	 shr	 eax, 17
  0102d	83 e0 01	 and	 eax, 1
  01030	85 c0		 test	 eax, eax
  01032	0f 84 cb 00 00
	00		 je	 $LN119@s390_run_s
  01038	48 8b 84 24 e0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  01040	48 8b 80 70 08
	00 00		 mov	 rax, QWORD PTR [rax+2160]
  01047	48 83 b8 08 02
	00 00 00	 cmp	 QWORD PTR [rax+520], 0
  0104f	0f 85 ae 00 00
	00		 jne	 $LN119@s390_run_s
  01055	48 8b 84 24 e0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0105d	48 8b 80 70 08
	00 00		 mov	 rax, QWORD PTR [rax+2160]
  01064	0f b7 80 3c 08
	00 00		 movzx	 eax, WORD PTR [rax+2108]
  0106b	89 44 24 7c	 mov	 DWORD PTR tv655[rsp], eax
  0106f	48 8b 8c 24 e0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  01077	48 8b 89 70 08
	00 00		 mov	 rcx, QWORD PTR [rcx+2160]
  0107e	0f b7 89 3c 08
	00 00		 movzx	 ecx, WORD PTR [rcx+2108]
  01085	48 8b 15 00 00
	00 00		 mov	 rdx, QWORD PTR __imp_sysblk
  0108c	0f b6 8c 0a 48
	0b 00 00	 movzx	 ecx, BYTE PTR [rdx+rcx+2888]
  01094	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ptyp2short
  0109a	48 89 84 24 a0
	00 00 00	 mov	 QWORD PTR tv657[rsp], rax
  010a2	b9 01 00 00 00	 mov	 ecx, 1
  010a7	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  010ad	8b 4c 24 7c	 mov	 ecx, DWORD PTR tv655[rsp]
  010b1	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  010b5	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR tv657[rsp]
  010bd	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  010c2	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG180944
  010c9	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  010ce	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG180945
  010d5	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  010da	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  010df	41 b9 03 00 00
	00		 mov	 r9d, 3
  010e5	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG180946
  010ec	ba bd 04 00 00	 mov	 edx, 1213		; 000004bdH
  010f1	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG180947
  010f8	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg
  010fe	e9 0e fe ff ff	 jmp	 $sie_fetch_instruction$164
$LN119@s390_run_s:
$LN118@s390_run_s:
  01103	33 c0		 xor	 eax, eax
  01105	85 c0		 test	 eax, eax
  01107	0f 85 be fe ff
	ff		 jne	 $LN62@s390_run_s
$LN65@s390_run_s:

; 1214 :                 EXECUTE_INSTRUCTION( current_opcode_table, ip, GUESTREGS );

  0110d	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR ip$[rsp]
  01115	e8 00 00 00 00	 call	 fetch_hw_noswap
  0111a	0f b7 c8	 movzx	 ecx, ax
  0111d	e8 00 00 00 00	 call	 _byteswap_ushort
  01122	0f b7 c0	 movzx	 eax, ax
  01125	48 8b 8c 24 e0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0112d	48 8b 91 70 08
	00 00		 mov	 rdx, QWORD PTR [rcx+2160]
  01134	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR ip$[rsp]
  0113c	4c 8b 84 24 90
	00 00 00	 mov	 r8, QWORD PTR current_opcode_table$[rsp]
  01144	41 ff 14 c0	 call	 QWORD PTR [r8+rax*8]
  01148	33 c0		 xor	 eax, eax
  0114a	85 c0		 test	 eax, eax
  0114c	75 bf		 jne	 SHORT $LN65@s390_run_s

; 1215 :                 regs->instcount++;

  0114e	48 8b 84 24 e0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  01156	8b 80 98 07 00
	00		 mov	 eax, DWORD PTR [rax+1944]
  0115c	ff c0		 inc	 eax
  0115e	48 8b 8c 24 e0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  01166	89 81 98 07 00
	00		 mov	 DWORD PTR [rcx+1944], eax

; 1216 :                 UPDATE_SYSBLK_INSTCOUNT( 1 );

  0116c	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  01173	48 05 80 14 00
	00		 add	 rax, 5248		; 00001480H
  01179	ba 01 00 00 00	 mov	 edx, 1
  0117e	48 8b c8	 mov	 rcx, rax
  01181	e8 00 00 00 00	 call	 atomic_update64

; 1217 :                 SIE_PERFMON( SIE_PERF_EXEC_U );
; 1218 : 
; 1219 :                 for (i=0; i < MAX_CPU_LOOPS/2; i++)

  01186	c7 44 24 5c 00
	00 00 00	 mov	 DWORD PTR i$[rsp], 0
  0118e	eb 0a		 jmp	 SHORT $LN68@s390_run_s
$LN66@s390_run_s:
  01190	8b 44 24 5c	 mov	 eax, DWORD PTR i$[rsp]
  01194	ff c0		 inc	 eax
  01196	89 44 24 5c	 mov	 DWORD PTR i$[rsp], eax
$LN68@s390_run_s:
  0119a	81 7c 24 5c 80
	00 00 00	 cmp	 DWORD PTR i$[rsp], 128	; 00000080H
  011a2	0f 8d 30 01 00
	00		 jge	 $LN67@s390_run_s

; 1220 :                 {
; 1221 :                     UNROLLED_EXECUTE( current_opcode_table, GUESTREGS );

  011a8	48 8b 84 24 e0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  011b0	48 8b 80 70 08
	00 00		 mov	 rax, QWORD PTR [rax+2160]
  011b7	48 8b 8c 24 e0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  011bf	48 8b 89 70 08
	00 00		 mov	 rcx, QWORD PTR [rcx+2160]
  011c6	48 8b 89 08 02
	00 00		 mov	 rcx, QWORD PTR [rcx+520]
  011cd	48 39 48 68	 cmp	 QWORD PTR [rax+104], rcx
  011d1	72 05		 jb	 SHORT $LN120@s390_run_s
  011d3	e9 00 01 00 00	 jmp	 $LN67@s390_run_s
$LN120@s390_run_s:
$LN71@s390_run_s:
  011d8	48 8b 84 24 e0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  011e0	48 8b 80 70 08
	00 00		 mov	 rax, QWORD PTR [rax+2160]
  011e7	48 89 84 24 a8
	00 00 00	 mov	 QWORD PTR tv932[rsp], rax
  011ef	48 8b 8c 24 e0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  011f7	48 8b 89 70 08
	00 00		 mov	 rcx, QWORD PTR [rcx+2160]
  011fe	48 8b 49 68	 mov	 rcx, QWORD PTR [rcx+104]
  01202	e8 00 00 00 00	 call	 fetch_hw_noswap
  01207	0f b7 c8	 movzx	 ecx, ax
  0120a	e8 00 00 00 00	 call	 _byteswap_ushort
  0120f	0f b7 c0	 movzx	 eax, ax
  01212	48 8b 8c 24 e0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0121a	48 8b 91 70 08
	00 00		 mov	 rdx, QWORD PTR [rcx+2160]
  01221	48 8b 8c 24 a8
	00 00 00	 mov	 rcx, QWORD PTR tv932[rsp]
  01229	48 8b 49 68	 mov	 rcx, QWORD PTR [rcx+104]
  0122d	4c 8b 84 24 90
	00 00 00	 mov	 r8, QWORD PTR current_opcode_table$[rsp]
  01235	41 ff 14 c0	 call	 QWORD PTR [r8+rax*8]
  01239	33 c0		 xor	 eax, eax
  0123b	85 c0		 test	 eax, eax
  0123d	75 99		 jne	 SHORT $LN71@s390_run_s

; 1222 :                     UNROLLED_EXECUTE( current_opcode_table, GUESTREGS );

  0123f	48 8b 84 24 e0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  01247	48 8b 80 70 08
	00 00		 mov	 rax, QWORD PTR [rax+2160]
  0124e	48 8b 8c 24 e0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  01256	48 8b 89 70 08
	00 00		 mov	 rcx, QWORD PTR [rcx+2160]
  0125d	48 8b 89 08 02
	00 00		 mov	 rcx, QWORD PTR [rcx+520]
  01264	48 39 48 68	 cmp	 QWORD PTR [rax+104], rcx
  01268	72 02		 jb	 SHORT $LN121@s390_run_s
  0126a	eb 6c		 jmp	 SHORT $LN67@s390_run_s
$LN121@s390_run_s:
$LN74@s390_run_s:
  0126c	48 8b 84 24 e0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  01274	48 8b 80 70 08
	00 00		 mov	 rax, QWORD PTR [rax+2160]
  0127b	48 89 84 24 b0
	00 00 00	 mov	 QWORD PTR tv928[rsp], rax
  01283	48 8b 8c 24 e0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0128b	48 8b 89 70 08
	00 00		 mov	 rcx, QWORD PTR [rcx+2160]
  01292	48 8b 49 68	 mov	 rcx, QWORD PTR [rcx+104]
  01296	e8 00 00 00 00	 call	 fetch_hw_noswap
  0129b	0f b7 c8	 movzx	 ecx, ax
  0129e	e8 00 00 00 00	 call	 _byteswap_ushort
  012a3	0f b7 c0	 movzx	 eax, ax
  012a6	48 8b 8c 24 e0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  012ae	48 8b 91 70 08
	00 00		 mov	 rdx, QWORD PTR [rcx+2160]
  012b5	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR tv928[rsp]
  012bd	48 8b 49 68	 mov	 rcx, QWORD PTR [rcx+104]
  012c1	4c 8b 84 24 90
	00 00 00	 mov	 r8, QWORD PTR current_opcode_table$[rsp]
  012c9	41 ff 14 c0	 call	 QWORD PTR [r8+rax*8]
  012cd	33 c0		 xor	 eax, eax
  012cf	85 c0		 test	 eax, eax
  012d1	75 99		 jne	 SHORT $LN74@s390_run_s

; 1223 :                 }

  012d3	e9 b8 fe ff ff	 jmp	 $LN66@s390_run_s
$LN67@s390_run_s:

; 1224 :                 regs->instcount +=  (i * 2);

  012d8	48 8b 84 24 e0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  012e0	8b 80 98 07 00
	00		 mov	 eax, DWORD PTR [rax+1944]
  012e6	8b 4c 24 5c	 mov	 ecx, DWORD PTR i$[rsp]
  012ea	8d 04 48	 lea	 eax, DWORD PTR [rax+rcx*2]
  012ed	48 8b 8c 24 e0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  012f5	89 81 98 07 00
	00		 mov	 DWORD PTR [rcx+1944], eax

; 1225 :                 UPDATE_SYSBLK_INSTCOUNT( (i * 2) );

  012fb	8b 44 24 5c	 mov	 eax, DWORD PTR i$[rsp]
  012ff	d1 e0		 shl	 eax, 1
  01301	48 98		 cdqe
  01303	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  0130a	48 81 c1 80 14
	00 00		 add	 rcx, 5248		; 00001480H
  01311	48 8b d0	 mov	 rdx, rax
  01314	e8 00 00 00 00	 call	 atomic_update64

; 1226 : 
; 1227 :                 /* Perform automatic instruction tracing if it's enabled */
; 1228 :                 do_automatic_tracing();

  01319	e8 00 00 00 00	 call	 do_automatic_tracing
$endloop$165:

; 1229 :                 goto endloop;
; 1230 : 
; 1231 : #if defined( FEATURE_073_TRANSACT_EXEC_FACILITY )
; 1232 : 
; 1233 : txf_facility_loop:
; 1234 : 
; 1235 :                 SIE_PERFMON( SIE_PERF_EXEC );
; 1236 : 
; 1237 :                 if (GUESTREGS->txf_tnd)
; 1238 :                     goto txf_slower_loop;
; 1239 : 
; 1240 :                 PROCESS_TRACE( GUESTREGS, ip, sie_fetch_instruction );
; 1241 :                 EXECUTE_INSTRUCTION( current_opcode_table, ip, GUESTREGS );
; 1242 :                 regs->instcount++;
; 1243 :                 UPDATE_SYSBLK_INSTCOUNT( 1 );
; 1244 :                 SIE_PERFMON( SIE_PERF_EXEC_U );
; 1245 : 
; 1246 :                 for (i=0; i < MAX_CPU_LOOPS/2; i++)
; 1247 :                 {
; 1248 :                     if (GUESTREGS->txf_tnd)
; 1249 :                         break;
; 1250 : 
; 1251 :                     UNROLLED_EXECUTE( current_opcode_table, GUESTREGS );
; 1252 : 
; 1253 :                     if (GUESTREGS->txf_tnd)
; 1254 :                         break;
; 1255 : 
; 1256 :                     UNROLLED_EXECUTE( current_opcode_table, GUESTREGS );
; 1257 :                 }
; 1258 :                 regs->instcount +=  (i * 2);
; 1259 :                 UPDATE_SYSBLK_INSTCOUNT( (i * 2) );
; 1260 : 
; 1261 :                 /* Perform automatic instruction tracing if it's enabled */
; 1262 :                 do_automatic_tracing();
; 1263 :                 goto endloop;
; 1264 : 
; 1265 : txf_slower_loop:
; 1266 : 
; 1267 :                 PROCESS_TRACE( GUESTREGS, ip, sie_fetch_instruction );
; 1268 :                 TXF_EXECUTE_INSTRUCTION( current_opcode_table, ip, GUESTREGS );
; 1269 :                 regs->instcount++;
; 1270 :                 UPDATE_SYSBLK_INSTCOUNT( 1 );
; 1271 :                 SIE_PERFMON( SIE_PERF_EXEC_U );
; 1272 : 
; 1273 :                 for (i=0; i < MAX_CPU_LOOPS/2; i++)
; 1274 :                 {
; 1275 :                     if (!GUESTREGS->txf_tnd)
; 1276 :                         break;
; 1277 : 
; 1278 :                     TXF_UNROLLED_EXECUTE( current_opcode_table, GUESTREGS );
; 1279 : 
; 1280 :                     if (!GUESTREGS->txf_tnd)
; 1281 :                         break;
; 1282 : 
; 1283 :                     TXF_UNROLLED_EXECUTE( current_opcode_table, GUESTREGS );
; 1284 :                 }
; 1285 :                 regs->instcount +=  (i * 2);
; 1286 :                 UPDATE_SYSBLK_INSTCOUNT( (i * 2) );
; 1287 : 
; 1288 :                 /* Perform automatic instruction tracing if it's enabled */
; 1289 :                 do_automatic_tracing();
; 1290 :                 goto endloop;
; 1291 : 
; 1292 : #endif /* defined( FEATURE_073_TRANSACT_EXEC_FACILITY ) */
; 1293 : 
; 1294 : endloop:        ; // (nop to make compiler happy)
; 1295 :             }
; 1296 :             /******************************************/
; 1297 :             /* Remain in SIE (above loop) as long as: */
; 1298 :             /*  - No Host Interrupt is pending        */
; 1299 :             /*  - No SIE defined Interrupt is pending */
; 1300 :             /*    (Wait, External or I/O)             */
; 1301 :             /*  - No guest interrupt is pending       */
; 1302 :             /******************************************/
; 1303 :             while
; 1304 :             (0
; 1305 : #if defined( FEATURE_073_TRANSACT_EXEC_FACILITY )
; 1306 :              /* Don't interrupt active transaction */
; 1307 :              || (1
; 1308 :                  && GUESTREGS->txf_tnd > 0
; 1309 :                  && GUESTREGS->txf_PPA >= PPA_MUCH_HELP_THRESHOLD
; 1310 :                 )
; 1311 : #endif
; 1312 :              || (1

  0131e	33 c0		 xor	 eax, eax
  01320	85 c0		 test	 eax, eax
  01322	0f 85 86 ee ff
	ff		 jne	 $LN19@s390_run_s
  01328	33 c0		 xor	 eax, eax
  0132a	83 f8 01	 cmp	 eax, 1
  0132d	0f 84 2e 01 00
	00		 je	 $LN122@s390_run_s
  01333	48 8b 84 24 e0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0133b	48 8b 8c 24 e0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  01343	8b 49 4c	 mov	 ecx, DWORD PTR [rcx+76]
  01346	8b 40 48	 mov	 eax, DWORD PTR [rax+72]
  01349	23 c1		 and	 eax, ecx
  0134b	85 c0		 test	 eax, eax
  0134d	0f 85 0e 01 00
	00		 jne	 $LN122@s390_run_s
  01353	48 8b 84 24 e0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0135b	48 8b 80 70 08
	00 00		 mov	 rax, QWORD PTR [rax+2160]
  01362	0f b6 40 7a	 movzx	 eax, BYTE PTR [rax+122]
  01366	83 e0 02	 and	 eax, 2
  01369	85 c0		 test	 eax, eax
  0136b	74 2f		 je	 SHORT $LN123@s390_run_s
  0136d	48 8b 84 24 e0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  01375	48 8b 80 70 08
	00 00		 mov	 rax, QWORD PTR [rax+2160]
  0137c	48 8b 80 88 08
	00 00		 mov	 rax, QWORD PTR [rax+2184]
  01383	b9 01 00 00 00	 mov	 ecx, 1
  01388	48 6b c9 00	 imul	 rcx, rcx, 0
  0138c	0f b6 44 08 4c	 movzx	 eax, BYTE PTR [rax+rcx+76]
  01391	83 e0 20	 and	 eax, 32			; 00000020H
  01394	85 c0		 test	 eax, eax
  01396	0f 84 c5 00 00
	00		 je	 $LN122@s390_run_s
$LN123@s390_run_s:
  0139c	48 8b 84 24 e0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  013a4	48 8b 80 70 08
	00 00		 mov	 rax, QWORD PTR [rax+2160]
  013ab	48 8b 80 88 08
	00 00		 mov	 rax, QWORD PTR [rax+2184]
  013b2	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  013b5	83 e0 01	 and	 eax, 1
  013b8	85 c0		 test	 eax, eax
  013ba	74 1e		 je	 SHORT $LN124@s390_run_s
  013bc	48 8b 84 24 e0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  013c4	48 8b 80 70 08
	00 00		 mov	 rax, QWORD PTR [rax+2160]
  013cb	0f b6 40 78	 movzx	 eax, BYTE PTR [rax+120]
  013cf	83 e0 01	 and	 eax, 1
  013d2	85 c0		 test	 eax, eax
  013d4	0f 85 87 00 00
	00		 jne	 $LN122@s390_run_s
$LN124@s390_run_s:
  013da	48 8b 84 24 e0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  013e2	48 8b 80 70 08
	00 00		 mov	 rax, QWORD PTR [rax+2160]
  013e9	48 8b 80 88 08
	00 00		 mov	 rax, QWORD PTR [rax+2184]
  013f0	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  013f3	83 e0 02	 and	 eax, 2
  013f6	85 c0		 test	 eax, eax
  013f8	74 1a		 je	 SHORT $LN125@s390_run_s
  013fa	48 8b 84 24 e0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  01402	48 8b 80 70 08
	00 00		 mov	 rax, QWORD PTR [rax+2160]
  01409	0f b6 40 78	 movzx	 eax, BYTE PTR [rax+120]
  0140d	83 e0 02	 and	 eax, 2
  01410	85 c0		 test	 eax, eax
  01412	75 4d		 jne	 SHORT $LN122@s390_run_s
$LN125@s390_run_s:
  01414	48 8b 84 24 e0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0141c	48 8b 80 70 08
	00 00		 mov	 rax, QWORD PTR [rax+2160]
  01423	48 8b 8c 24 e0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0142b	48 8b 89 70 08
	00 00		 mov	 rcx, QWORD PTR [rcx+2160]
  01432	48 8b 89 68 08
	00 00		 mov	 rcx, QWORD PTR [rcx+2152]
  01439	8b 49 48	 mov	 ecx, DWORD PTR [rcx+72]
  0143c	81 e1 80 0c 00
	40		 and	 ecx, 1073745024		; 40000c80H
  01442	8b 40 48	 mov	 eax, DWORD PTR [rax+72]
  01445	0b c1		 or	 eax, ecx
  01447	48 8b 8c 24 e0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0144f	48 8b 89 70 08
	00 00		 mov	 rcx, QWORD PTR [rcx+2160]
  01456	23 41 4c	 and	 eax, DWORD PTR [rcx+76]
  01459	85 c0		 test	 eax, eax
  0145b	0f 84 4d ed ff
	ff		 je	 $LN163@s390_run_s
$LN122@s390_run_s:
$LN18@s390_run_s:

; 1313 :                  && !SIE_I_HOST            (    regs   )
; 1314 :                  && !SIE_I_WAIT            ( GUESTREGS )
; 1315 :                  && !SIE_I_EXT             ( GUESTREGS )
; 1316 :                  && !SIE_I_IO              ( GUESTREGS )
; 1317 :                  && !SIE_INTERRUPT_PENDING ( GUESTREGS )
; 1318 :                 )
; 1319 :             );
; 1320 : 
; 1321 :             /* Otherwise break out of the above loop
; 1322 :                and check if we should exit from SIE
; 1323 :                (check is done slightly further below)
; 1324 :             */
; 1325 :         }

  01461	eb 56		 jmp	 SHORT $LN87@s390_run_s
$LN86@s390_run_s:

; 1326 :         else
; 1327 :         {
; 1328 :             /* Our above instruction execution loop didn't finish due
; 1329 :                to a longjmp(progjmp) having been done, bringing us to
; 1330 :                here, thereby causing the instruction counter to not be
; 1331 :                properly updated. Thus, we must update it here instead.
; 1332 :            */
; 1333 :             if (sysblk.ipled)

  01463	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  0146a	8b 80 94 12 00
	00		 mov	 eax, DWORD PTR [rax+4756]
  01470	d1 e8		 shr	 eax, 1
  01472	83 e0 01	 and	 eax, 1
  01475	85 c0		 test	 eax, eax
  01477	74 40		 je	 SHORT $LN126@s390_run_s

; 1334 :             {
; 1335 :                 regs->instcount += MAX_CPU_LOOPS/2;

  01479	48 8b 84 24 e0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  01481	8b 80 98 07 00
	00		 mov	 eax, DWORD PTR [rax+1944]
  01487	05 80 00 00 00	 add	 eax, 128		; 00000080H
  0148c	48 8b 8c 24 e0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  01494	89 81 98 07 00
	00		 mov	 DWORD PTR [rcx+1944], eax

; 1336 :                 UPDATE_SYSBLK_INSTCOUNT( MAX_CPU_LOOPS/2 );

  0149a	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  014a1	48 05 80 14 00
	00		 add	 rax, 5248		; 00001480H
  014a7	ba 80 00 00 00	 mov	 edx, 128		; 00000080H
  014ac	48 8b c8	 mov	 rcx, rax
  014af	e8 00 00 00 00	 call	 atomic_update64

; 1337 : 
; 1338 :                 /* Perform automatic instruction tracing if it's enabled */
; 1339 :                 do_automatic_tracing();

  014b4	e8 00 00 00 00	 call	 do_automatic_tracing
$LN126@s390_run_s:
$LN87@s390_run_s:
$LN77@s390_run_s:

; 1340 :             }
; 1341 :         }
; 1342 : 
; 1343 :         PTT_SIE( "run_sie !run", icode, 0, 0 );

  014b9	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_pttclass
  014c0	48 8b 00	 mov	 rax, QWORD PTR [rax]
  014c3	48 25 80 00 00
	00		 and	 rax, 128		; 00000080H
  014c9	48 85 c0	 test	 rax, rax
  014cc	74 3b		 je	 SHORT $LN127@s390_run_s
  014ce	48 63 44 24 54	 movsxd	 rax, DWORD PTR icode$[rsp]
  014d3	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR [rsp+48], 0
  014dc	48 c7 44 24 28
	00 00 00 00	 mov	 QWORD PTR [rsp+40], 0
  014e5	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG180956
  014ec	48 89 4c 24 20	 mov	 QWORD PTR [rsp+32], rcx
  014f1	45 33 c9	 xor	 r9d, r9d
  014f4	4c 8b c0	 mov	 r8, rax
  014f7	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG180957
  014fe	b9 80 00 00 00	 mov	 ecx, 128		; 00000080H
  01503	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ptt_pthread_trace
$LN127@s390_run_s:
  01509	33 c0		 xor	 eax, eax
  0150b	85 c0		 test	 eax, eax
  0150d	75 aa		 jne	 SHORT $LN77@s390_run_s

; 1344 : 
; 1345 :         /* Check if we should remain in, or exit from, SIE mode */
; 1346 :         if (!icode || SIE_NO_INTERCEPT == icode)

  0150f	83 7c 24 54 00	 cmp	 DWORD PTR icode$[rsp], 0
  01514	74 0b		 je	 SHORT $LN129@s390_run_s
  01516	83 7c 24 54 ff	 cmp	 DWORD PTR icode$[rsp], -1
  0151b	0f 85 73 01 00
	00		 jne	 $LN128@s390_run_s
$LN129@s390_run_s:

; 1347 :         {
; 1348 :             /* Check PER first, higher priority */
; 1349 :             if (OPEN_IC_PER( GUESTREGS ))

  01521	48 8b 84 24 e0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  01529	48 8b 80 70 08
	00 00		 mov	 rax, QWORD PTR [rax+2160]
  01530	48 8b 8c 24 e0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  01538	48 8b 89 70 08
	00 00		 mov	 rcx, QWORD PTR [rcx+2160]
  0153f	8b 49 4c	 mov	 ecx, DWORD PTR [rcx+76]
  01542	8b 40 48	 mov	 eax, DWORD PTR [rax+72]
  01545	23 c1		 and	 eax, ecx
  01547	25 00 00 ff 00	 and	 eax, 16711680		; 00ff0000H
  0154c	85 c0		 test	 eax, eax
  0154e	74 19		 je	 SHORT $LN130@s390_run_s

; 1350 :                 ARCH_DEP( program_interrupt )( GUESTREGS, PGM_PER_EVENT );

  01550	ba 80 00 00 00	 mov	 edx, 128		; 00000080H
  01555	48 8b 84 24 e0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0155d	48 8b 88 70 08
	00 00		 mov	 rcx, QWORD PTR [rax+2160]
  01564	e8 00 00 00 00	 call	 s390_program_interrupt
$LN130@s390_run_s:

; 1351 : 
; 1352 :             /* Check for SIE exit conditions... */
; 1353 : 
; 1354 :                  if (SIE_I_EXT  ( GUESTREGS )) icode = SIE_INTERCEPT_EXTREQ;

  01569	48 8b 84 24 e0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  01571	48 8b 80 70 08
	00 00		 mov	 rax, QWORD PTR [rax+2160]
  01578	48 8b 80 88 08
	00 00		 mov	 rax, QWORD PTR [rax+2184]
  0157f	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  01582	83 e0 01	 and	 eax, 1
  01585	85 c0		 test	 eax, eax
  01587	74 27		 je	 SHORT $LN131@s390_run_s
  01589	48 8b 84 24 e0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  01591	48 8b 80 70 08
	00 00		 mov	 rax, QWORD PTR [rax+2160]
  01598	0f b6 40 78	 movzx	 eax, BYTE PTR [rax+120]
  0159c	83 e0 01	 and	 eax, 1
  0159f	85 c0		 test	 eax, eax
  015a1	74 0d		 je	 SHORT $LN131@s390_run_s
  015a3	c7 44 24 54 fa
	ff ff ff	 mov	 DWORD PTR icode$[rsp], -6
  015ab	e9 e4 00 00 00	 jmp	 $LN132@s390_run_s
$LN131@s390_run_s:

; 1355 :             else if (SIE_I_IO   ( GUESTREGS )) icode = SIE_INTERCEPT_IOREQ;

  015b0	48 8b 84 24 e0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  015b8	48 8b 80 70 08
	00 00		 mov	 rax, QWORD PTR [rax+2160]
  015bf	48 8b 80 88 08
	00 00		 mov	 rax, QWORD PTR [rax+2184]
  015c6	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  015c9	83 e0 02	 and	 eax, 2
  015cc	85 c0		 test	 eax, eax
  015ce	74 27		 je	 SHORT $LN133@s390_run_s
  015d0	48 8b 84 24 e0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  015d8	48 8b 80 70 08
	00 00		 mov	 rax, QWORD PTR [rax+2160]
  015df	0f b6 40 78	 movzx	 eax, BYTE PTR [rax+120]
  015e3	83 e0 02	 and	 eax, 2
  015e6	85 c0		 test	 eax, eax
  015e8	74 0d		 je	 SHORT $LN133@s390_run_s
  015ea	c7 44 24 54 f9
	ff ff ff	 mov	 DWORD PTR icode$[rsp], -7
  015f2	e9 9d 00 00 00	 jmp	 $LN134@s390_run_s
$LN133@s390_run_s:

; 1356 :             else if (SIE_I_STOP ( GUESTREGS )) icode = SIE_INTERCEPT_STOPREQ;

  015f7	48 8b 84 24 e0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  015ff	48 8b 80 70 08
	00 00		 mov	 rax, QWORD PTR [rax+2160]
  01606	48 8b 80 88 08
	00 00		 mov	 rax, QWORD PTR [rax+2184]
  0160d	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  01610	83 e0 04	 and	 eax, 4
  01613	85 c0		 test	 eax, eax
  01615	74 0a		 je	 SHORT $LN135@s390_run_s
  01617	c7 44 24 54 f7
	ff ff ff	 mov	 DWORD PTR icode$[rsp], -9
  0161f	eb 73		 jmp	 SHORT $LN136@s390_run_s
$LN135@s390_run_s:

; 1357 :             else if (SIE_I_WAIT ( GUESTREGS )) icode = SIE_INTERCEPT_WAIT;

  01621	48 8b 84 24 e0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  01629	48 8b 80 70 08
	00 00		 mov	 rax, QWORD PTR [rax+2160]
  01630	0f b6 40 7a	 movzx	 eax, BYTE PTR [rax+122]
  01634	83 e0 02	 and	 eax, 2
  01637	85 c0		 test	 eax, eax
  01639	74 35		 je	 SHORT $LN137@s390_run_s
  0163b	48 8b 84 24 e0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  01643	48 8b 80 70 08
	00 00		 mov	 rax, QWORD PTR [rax+2160]
  0164a	48 8b 80 88 08
	00 00		 mov	 rax, QWORD PTR [rax+2184]
  01651	b9 01 00 00 00	 mov	 ecx, 1
  01656	48 6b c9 00	 imul	 rcx, rcx, 0
  0165a	0f b6 44 08 4c	 movzx	 eax, BYTE PTR [rax+rcx+76]
  0165f	83 e0 20	 and	 eax, 32			; 00000020H
  01662	85 c0		 test	 eax, eax
  01664	75 0a		 jne	 SHORT $LN137@s390_run_s
  01666	c7 44 24 54 f8
	ff ff ff	 mov	 DWORD PTR icode$[rsp], -8
  0166e	eb 24		 jmp	 SHORT $LN138@s390_run_s
$LN137@s390_run_s:

; 1358 :             else if (SIE_I_HOST (   regs    )) icode = SIE_HOST_INT_PEND;

  01670	48 8b 84 24 e0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  01678	48 8b 8c 24 e0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  01680	8b 49 4c	 mov	 ecx, DWORD PTR [rcx+76]
  01683	8b 40 48	 mov	 eax, DWORD PTR [rax+72]
  01686	23 c1		 and	 eax, ecx
  01688	85 c0		 test	 eax, eax
  0168a	74 08		 je	 SHORT $LN139@s390_run_s
  0168c	c7 44 24 54 fe
	ff ff ff	 mov	 DWORD PTR icode$[rsp], -2
$LN139@s390_run_s:
$LN138@s390_run_s:
$LN136@s390_run_s:
$LN134@s390_run_s:
$LN132@s390_run_s:
$LN128@s390_run_s:
$LN80@s390_run_s:

; 1359 : 
; 1360 :             /* Otherwise we should remain in SIE mode */
; 1361 :         }
; 1362 : 
; 1363 :         PTT_SIE( "run_sie !run", icode, 0, 0 );

  01694	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_pttclass
  0169b	48 8b 00	 mov	 rax, QWORD PTR [rax]
  0169e	48 25 80 00 00
	00		 and	 rax, 128		; 00000080H
  016a4	48 85 c0	 test	 rax, rax
  016a7	74 3b		 je	 SHORT $LN140@s390_run_s
  016a9	48 63 44 24 54	 movsxd	 rax, DWORD PTR icode$[rsp]
  016ae	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR [rsp+48], 0
  016b7	48 c7 44 24 28
	00 00 00 00	 mov	 QWORD PTR [rsp+40], 0
  016c0	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG180971
  016c7	48 89 4c 24 20	 mov	 QWORD PTR [rsp+32], rcx
  016cc	45 33 c9	 xor	 r9d, r9d
  016cf	4c 8b c0	 mov	 r8, rax
  016d2	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG180972
  016d9	b9 80 00 00 00	 mov	 ecx, 128		; 00000080H
  016de	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ptt_pthread_trace
$LN140@s390_run_s:
  016e4	33 c0		 xor	 eax, eax
  016e6	85 c0		 test	 eax, eax
  016e8	75 aa		 jne	 SHORT $LN80@s390_run_s

; 1364 :     }
; 1365 :     /* Try to remain in SIE mode if possible */
; 1366 :     while (!icode || icode == SIE_NO_INTERCEPT);

  016ea	83 7c 24 54 00	 cmp	 DWORD PTR icode$[rsp], 0
  016ef	0f 84 e8 e9 ff
	ff		 je	 $LN10@s390_run_s
  016f5	83 7c 24 54 ff	 cmp	 DWORD PTR icode$[rsp], -1
  016fa	0f 84 dd e9 ff
	ff		 je	 $LN162@s390_run_s
$LN83@s390_run_s:

; 1367 : 
; 1368 :     PTT_SIE( "run_sie ret", icode, 0, 0 );

  01700	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_pttclass
  01707	48 8b 00	 mov	 rax, QWORD PTR [rax]
  0170a	48 25 80 00 00
	00		 and	 rax, 128		; 00000080H
  01710	48 85 c0	 test	 rax, rax
  01713	74 3b		 je	 SHORT $LN141@s390_run_s
  01715	48 63 44 24 54	 movsxd	 rax, DWORD PTR icode$[rsp]
  0171a	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR [rsp+48], 0
  01723	48 c7 44 24 28
	00 00 00 00	 mov	 QWORD PTR [rsp+40], 0
  0172c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG180974
  01733	48 89 4c 24 20	 mov	 QWORD PTR [rsp+32], rcx
  01738	45 33 c9	 xor	 r9d, r9d
  0173b	4c 8b c0	 mov	 r8, rax
  0173e	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG180975
  01745	b9 80 00 00 00	 mov	 ecx, 128		; 00000080H
  0174a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ptt_pthread_trace
$LN141@s390_run_s:
  01750	33 c0		 xor	 eax, eax
  01752	85 c0		 test	 eax, eax
  01754	75 aa		 jne	 SHORT $LN83@s390_run_s

; 1369 : 
; 1370 :     return icode;

  01756	8b 44 24 54	 mov	 eax, DWORD PTR icode$[rsp]
$LN142@s390_run_s:

; 1371 : } /* end function run_sie */

  0175a	48 8b 8c 24 c8
	00 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  01762	48 33 cc	 xor	 rcx, rsp
  01765	e8 00 00 00 00	 call	 __security_check_cookie
  0176a	48 81 c4 d8 00
	00 00		 add	 rsp, 216		; 000000d8H
  01771	c3		 ret	 0
s390_run_sie ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\sie.c
_TEXT	SEGMENT
i$1 = 80
icode$ = 84
oldmode$2 = 88
i$ = 92
tv196 = 96
tv341 = 100
tv384 = 104
tv413 = 108
tv390 = 112
tv420 = 116
tv514 = 120
tv604 = 124
tv768 = 128
tv840 = 132
itimer$3 = 136
inst_cr$4 = 140
tv634 = 144
now$5 = 152
ip$ = 160
current_opcode_table$ = 168
tv612 = 176
tv636 = 184
tv925 = 192
tv921 = 200
waittime$6 = 208
__$ArrayPad$ = 224
regs$ = 256
s370_run_sie PROC

; 947  : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 81 ec f8 00
	00 00		 sub	 rsp, 248		; 000000f8H
  0000c	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00013	48 33 c4	 xor	 rax, rsp
  00016	48 89 84 24 e0
	00 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax
$LN4@s370_run_s:

; 948  :     BYTE*  ip;      /* instruction pointer        */
; 949  :     int    icode;   /* SIE longjmp intercept code */
; 950  :     int    i;
; 951  :     const INSTR_FUNC*  current_opcode_table;
; 952  : 
; 953  :     //---------------------------------------------------------
; 954  :     //              CRITICAL SIE PROGRAMMING NOTE!
; 955  :     //---------------------------------------------------------
; 956  :     //
; 957  :     //  Our 'regs' variable always points the HOST's regs (i.e.
; 958  :     //  regs == HOSTREGS && regs->host is always true), even though
; 959  :     //  we are actually RUNNING (executing) in GUEST architecture
; 960  :     //  mode!!
; 961  :     //
; 962  :     //  That is to say, if the host is, for example, z900 (z/VM)
; 963  :     //  but the guest it wants to execute is a 390 guest, the above
; 964  :     //  "start_interpretive_execution" instruction function calls
; 965  :     //  the "s390_run_sie" function (because it wants to execute
; 966  :     //  the guest in 390 mode), but it passed its own HOST regs to
; 967  :     //  this function!
; 968  :     //
; 969  :     //  So even though our function's build architecture is 390
; 970  :     //  (i.e. even though our function's build architecture is that
; 971  :     //  of the GUEST's), our 'regs' pointer is nevertheless still
; 972  :     //  pointing to the z/VM HOST's registers!! GUESTREGS must be
; 973  :     //  used to access the GUEST's register context!!
; 974  :     //
; 975  :     //  What this means is that SPECIAL CARE must be taken when
; 976  :     //  invoking macros or calling functions on behalf of the HOST
; 977  :     //  (i.e. when using 'regs' or HOSTREGS instead of GUESTREGS)
; 978  :     //  since many of our macros and functions are architecture
; 979  :     //  dependent, relying on the regs they were called with to
; 980  :     //  always match that of the current build architecture, which,
; 981  :     //  as explained, is NOT necessarily always true in our case!!
; 982  :     //
; 983  :     //---------------------------------------------------------
; 984  : 
; 985  :     //-----------------------------------------------------------
; 986  :     //               IMPORTANT SIE PROGRAMMING NOTE!
; 987  :     //-----------------------------------------------------------
; 988  :     // NOTE: Our execution architectural mode is that of the SIE
; 989  :     // GUEST, not the HOST! If you need to call a function on
; 990  :     // behalf of the HOST (passing it 'regs'), you must be careful
; 991  :     // to ensure the correct version of that function is called!
; 992  :     // You cannot simply call the "ARCH_DEP" version of a function
; 993  :     // as they are for the architectue of the GUEST, not the HOST!
; 994  :     // (e.g. you cannot call a "s390_xxxx" function expecting it
; 995  :     // to work correctly if the HOST function that SHOULD have been
; 996  :     // called should have been "z900_xxxx"!) YOU HAVE BEEN WARNED!
; 997  :     //-----------------------------------------------------------
; 998  : 
; 999  :     PTT_SIE( "run_sie h,g,a", regs->host, regs->guest, regs->sie_active );

  0001e	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_pttclass
  00025	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00028	48 25 80 00 00
	00		 and	 rax, 128		; 00000080H
  0002e	48 85 c0	 test	 rax, rax
  00031	74 71		 je	 SHORT $LN75@s370_run_s
  00033	48 8b 84 24 00
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0003b	8b 80 c8 08 00
	00		 mov	 eax, DWORD PTR [rax+2248]
  00041	83 e0 01	 and	 eax, 1
  00044	8b c0		 mov	 eax, eax
  00046	48 8b 8c 24 00
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0004e	8b 89 28 07 00
	00		 mov	 ecx, DWORD PTR [rcx+1832]
  00054	c1 e9 08	 shr	 ecx, 8
  00057	83 e1 01	 and	 ecx, 1
  0005a	8b c9		 mov	 ecx, ecx
  0005c	48 8b 94 24 00
	01 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  00064	8b 92 28 07 00
	00		 mov	 edx, DWORD PTR [rdx+1832]
  0006a	c1 ea 07	 shr	 edx, 7
  0006d	83 e2 01	 and	 edx, 1
  00070	8b d2		 mov	 edx, edx
  00072	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR [rsp+48], 0
  0007b	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  00080	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG169958
  00087	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  0008c	44 8b c9	 mov	 r9d, ecx
  0008f	44 8b c2	 mov	 r8d, edx
  00092	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG169959
  00099	b9 80 00 00 00	 mov	 ecx, 128		; 00000080H
  0009e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ptt_pthread_trace
$LN75@s370_run_s:
  000a4	33 c0		 xor	 eax, eax
  000a6	85 c0		 test	 eax, eax
  000a8	0f 85 70 ff ff
	ff		 jne	 $LN4@s370_run_s
$LN7@s370_run_s:

; 1000 : 
; 1001 :     SIE_PERFMON( SIE_PERF_RUNSIE );
; 1002 : 
; 1003 : #if defined( _FEATURE_PER )
; 1004 :     /* Reset any PER pending indication */
; 1005 :     OFF_IC_PER( GUESTREGS );

  000ae	48 8b 84 24 00
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  000b6	48 8b 80 70 08
	00 00		 mov	 rax, QWORD PTR [rax+2160]
  000bd	8b 40 4c	 mov	 eax, DWORD PTR [rax+76]
  000c0	25 ff ff 00 ff	 and	 eax, -16711681		; ff00ffffH
  000c5	48 8b 8c 24 00
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  000cd	48 8b 89 70 08
	00 00		 mov	 rcx, QWORD PTR [rcx+2160]
  000d4	89 41 4c	 mov	 DWORD PTR [rcx+76], eax
  000d7	33 c0		 xor	 eax, eax
  000d9	85 c0		 test	 eax, eax
  000db	75 d1		 jne	 SHORT $LN7@s370_run_s

; 1006 : #endif
; 1007 : 
; 1008 : #ifdef FEATURE_INTERVAL_TIMER
; 1009 :     /* Load the shadow interval timer */
; 1010 :     {
; 1011 :         S32 itimer;
; 1012 :         FETCH_FW( itimer, GUESTREGS->psa->inttimer );

  000dd	48 8b 84 24 00
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  000e5	48 8b 80 70 08
	00 00		 mov	 rax, QWORD PTR [rax+2160]
  000ec	48 8b 80 60 08
	00 00		 mov	 rax, QWORD PTR [rax+2144]
  000f3	48 83 c0 50	 add	 rax, 80			; 00000050H
  000f7	48 8b c8	 mov	 rcx, rax
  000fa	e8 00 00 00 00	 call	 fetch_fw_noswap
  000ff	8b c8		 mov	 ecx, eax
  00101	e8 00 00 00 00	 call	 _byteswap_ulong
  00106	89 84 24 88 00
	00 00		 mov	 DWORD PTR itimer$3[rsp], eax

; 1013 :         set_int_timer( GUESTREGS, itimer );

  0010d	8b 94 24 88 00
	00 00		 mov	 edx, DWORD PTR itimer$3[rsp]
  00114	48 8b 84 24 00
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0011c	48 8b 88 70 08
	00 00		 mov	 rcx, QWORD PTR [rax+2160]
  00123	e8 00 00 00 00	 call	 set_int_timer
$LN157@s370_run_s:
$LN10@s370_run_s:
$LN13@s370_run_s:

; 1014 :     }
; 1015 : #endif
; 1016 : 
; 1017 :     do
; 1018 :     {
; 1019 :         SIE_PERFMON( SIE_PERF_RUNLOOP_1 );
; 1020 : 
; 1021 :         PTT_SIE( "run_sie setjmp", 0, 0, 0 );

  00128	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_pttclass
  0012f	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00132	48 25 80 00 00
	00		 and	 rax, 128		; 00000080H
  00138	48 85 c0	 test	 rax, rax
  0013b	74 36		 je	 SHORT $LN76@s370_run_s
  0013d	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR [rsp+48], 0
  00146	48 c7 44 24 28
	00 00 00 00	 mov	 QWORD PTR [rsp+40], 0
  0014f	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG169961
  00156	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  0015b	45 33 c9	 xor	 r9d, r9d
  0015e	45 33 c0	 xor	 r8d, r8d
  00161	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG169962
  00168	b9 80 00 00 00	 mov	 ecx, 128		; 00000080H
  0016d	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ptt_pthread_trace
$LN76@s370_run_s:
  00173	33 c0		 xor	 eax, eax
  00175	85 c0		 test	 eax, eax
  00177	75 af		 jne	 SHORT $LN13@s370_run_s

; 1022 : 
; 1023 :         /* Establish longjmp destination for program check or
; 1024 :            RETURN_INTCHECK, or SIE_INTERCEPT, or longjmp, etc.
; 1025 :         */
; 1026 :         if (!(icode = setjmp( GUESTREGS->progjmp )))

  00179	48 8b 84 24 00
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00181	48 8b 80 70 08
	00 00		 mov	 rax, QWORD PTR [rax+2160]
  00188	48 05 80 09 00
	00		 add	 rax, 2432		; 00000980H
  0018e	48 8b c8	 mov	 rcx, rax
  00191	48 8b d4	 mov	 rdx, rsp
  00194	e8 00 00 00 00	 call	 _setjmp
  00199	89 44 24 54	 mov	 DWORD PTR icode$[rsp], eax
  0019d	83 7c 24 54 00	 cmp	 DWORD PTR icode$[rsp], 0
  001a2	0f 85 50 12 00
	00		 jne	 $LN77@s370_run_s
$LN16@s370_run_s:

; 1027 :         {
; 1028 :             PTT_SIE( "run_sie run...", 0, 0, 0 );

  001a8	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_pttclass
  001af	48 8b 00	 mov	 rax, QWORD PTR [rax]
  001b2	48 25 80 00 00
	00		 and	 rax, 128		; 00000080H
  001b8	48 85 c0	 test	 rax, rax
  001bb	74 36		 je	 SHORT $LN79@s370_run_s
  001bd	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR [rsp+48], 0
  001c6	48 c7 44 24 28
	00 00 00 00	 mov	 QWORD PTR [rsp+40], 0
  001cf	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG169966
  001d6	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  001db	45 33 c9	 xor	 r9d, r9d
  001de	45 33 c0	 xor	 r8d, r8d
  001e1	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG169967
  001e8	b9 80 00 00 00	 mov	 ecx, 128		; 00000080H
  001ed	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ptt_pthread_trace
$LN79@s370_run_s:
  001f3	33 c0		 xor	 eax, eax
  001f5	85 c0		 test	 eax, eax
  001f7	75 af		 jne	 SHORT $LN16@s370_run_s
$LN158@s370_run_s:
$LN19@s370_run_s:

; 1029 :             do
; 1030 :             {
; 1031 :                 SIE_PERFMON( SIE_PERF_RUNLOOP_2 );
; 1032 : 
; 1033 :                 /* Set `execflag' to 0 in case EXecuted instruction did progjmp */
; 1034 :                 GUESTREGS->execflag = 0;

  001f9	48 8b 84 24 00
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00201	48 8b 80 70 08
	00 00		 mov	 rax, QWORD PTR [rax+2160]
  00208	8b 80 28 07 00
	00		 mov	 eax, DWORD PTR [rax+1832]
  0020e	83 e0 fe	 and	 eax, -2			; fffffffeH
  00211	48 8b 8c 24 00
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00219	48 8b 89 70 08
	00 00		 mov	 rcx, QWORD PTR [rcx+2160]
  00220	89 81 28 07 00
	00		 mov	 DWORD PTR [rcx+1832], eax

; 1035 : 
; 1036 :                 /* Exit from SIE mode when either asked or
; 1037 :                    if External or I/O Interrupt is pending
; 1038 :                 */
; 1039 :                 if (1
; 1040 : #if defined( FEATURE_073_TRANSACT_EXEC_FACILITY )
; 1041 :                     /* Don't interrupt active transaction */
; 1042 :                     && (0
; 1043 :                         || GUESTREGS->txf_tnd == 0
; 1044 :                         || GUESTREGS->txf_PPA < PPA_MUCH_HELP_THRESHOLD
; 1045 :                        )
; 1046 : #endif
; 1047 :                     && (0

  00226	33 c0		 xor	 eax, eax
  00228	83 f8 01	 cmp	 eax, 1
  0022b	0f 84 d4 00 00
	00		 je	 $LN80@s370_run_s
  00231	33 c0		 xor	 eax, eax
  00233	85 c0		 test	 eax, eax
  00235	0f 85 c5 00 00
	00		 jne	 $LN81@s370_run_s
  0023b	48 8b 84 24 00
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00243	48 8b 80 70 08
	00 00		 mov	 rax, QWORD PTR [rax+2160]
  0024a	48 8b 80 88 08
	00 00		 mov	 rax, QWORD PTR [rax+2184]
  00251	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  00254	83 e0 04	 and	 eax, 4
  00257	85 c0		 test	 eax, eax
  00259	0f 85 a1 00 00
	00		 jne	 $LN81@s370_run_s
  0025f	48 8b 84 24 00
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00267	48 8b 80 70 08
	00 00		 mov	 rax, QWORD PTR [rax+2160]
  0026e	48 8b 80 88 08
	00 00		 mov	 rax, QWORD PTR [rax+2184]
  00275	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  00278	83 e0 01	 and	 eax, 1
  0027b	85 c0		 test	 eax, eax
  0027d	74 1a		 je	 SHORT $LN82@s370_run_s
  0027f	48 8b 84 24 00
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00287	48 8b 80 70 08
	00 00		 mov	 rax, QWORD PTR [rax+2160]
  0028e	0f b6 40 78	 movzx	 eax, BYTE PTR [rax+120]
  00292	83 e0 01	 and	 eax, 1
  00295	85 c0		 test	 eax, eax
  00297	75 67		 jne	 SHORT $LN81@s370_run_s
$LN82@s370_run_s:
  00299	48 8b 84 24 00
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  002a1	48 8b 80 70 08
	00 00		 mov	 rax, QWORD PTR [rax+2160]
  002a8	48 8b 80 88 08
	00 00		 mov	 rax, QWORD PTR [rax+2184]
  002af	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  002b2	83 e0 02	 and	 eax, 2
  002b5	85 c0		 test	 eax, eax
  002b7	74 4c		 je	 SHORT $LN80@s370_run_s
  002b9	48 8b 84 24 00
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  002c1	48 8b 80 70 08
	00 00		 mov	 rax, QWORD PTR [rax+2160]
  002c8	0f b6 40 7a	 movzx	 eax, BYTE PTR [rax+122]
  002cc	83 e0 08	 and	 eax, 8
  002cf	85 c0		 test	 eax, eax
  002d1	74 0a		 je	 SHORT $LN129@s370_run_s
  002d3	c7 44 24 60 02
	00 00 00	 mov	 DWORD PTR tv196[rsp], 2
  002db	eb 08		 jmp	 SHORT $LN130@s370_run_s
$LN129@s370_run_s:
  002dd	c7 44 24 60 fe
	00 00 00	 mov	 DWORD PTR tv196[rsp], 254 ; 000000feH
$LN130@s370_run_s:
  002e5	48 8b 84 24 00
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  002ed	48 8b 80 70 08
	00 00		 mov	 rax, QWORD PTR [rax+2160]
  002f4	0f b6 40 78	 movzx	 eax, BYTE PTR [rax+120]
  002f8	23 44 24 60	 and	 eax, DWORD PTR tv196[rsp]
  002fc	85 c0		 test	 eax, eax
  002fe	74 05		 je	 SHORT $LN80@s370_run_s
$LN81@s370_run_s:

; 1048 :                         || SIE_I_STOP ( GUESTREGS )
; 1049 :                         || SIE_I_EXT  ( GUESTREGS )
; 1050 :                         || SIE_I_IO   ( GUESTREGS )
; 1051 :                        )
; 1052 :                 )
; 1053 :                     break;

  00300	e9 f1 10 00 00	 jmp	 $LN18@s370_run_s
$LN80@s370_run_s:

; 1054 : 
; 1055 :                 if (SIE_IC_INTERRUPT_CPU( GUESTREGS ))

  00305	48 8b 84 24 00
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0030d	48 8b 80 70 08
	00 00		 mov	 rax, QWORD PTR [rax+2160]
  00314	48 8b 8c 24 00
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0031c	48 8b 89 70 08
	00 00		 mov	 rcx, QWORD PTR [rcx+2160]
  00323	48 8b 89 68 08
	00 00		 mov	 rcx, QWORD PTR [rcx+2152]
  0032a	8b 49 48	 mov	 ecx, DWORD PTR [rcx+72]
  0032d	81 e1 80 0c 00
	40		 and	 ecx, 1073745024		; 40000c80H
  00333	8b 40 48	 mov	 eax, DWORD PTR [rax+72]
  00336	0b c1		 or	 eax, ecx
  00338	48 8b 8c 24 00
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00340	48 8b 89 70 08
	00 00		 mov	 rcx, QWORD PTR [rcx+2160]
  00347	23 41 4c	 and	 eax, DWORD PTR [rcx+76]
  0034a	85 c0		 test	 eax, eax
  0034c	0f 84 ce 0a 00
	00		 je	 $LN83@s370_run_s

; 1056 :                 {
; 1057 :                     SIE_PERFMON( SIE_PERF_INTCHECK );
; 1058 : 
; 1059 :                     /* Process PER program interrupts */
; 1060 :                     if (OPEN_IC_PER( GUESTREGS ))

  00352	48 8b 84 24 00
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0035a	48 8b 80 70 08
	00 00		 mov	 rax, QWORD PTR [rax+2160]
  00361	48 8b 8c 24 00
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00369	48 8b 89 70 08
	00 00		 mov	 rcx, QWORD PTR [rcx+2160]
  00370	8b 49 4c	 mov	 ecx, DWORD PTR [rcx+76]
  00373	8b 40 48	 mov	 eax, DWORD PTR [rax+72]
  00376	23 c1		 and	 eax, ecx
  00378	25 00 00 ff 00	 and	 eax, 16711680		; 00ff0000H
  0037d	85 c0		 test	 eax, eax
  0037f	74 19		 je	 SHORT $LN84@s370_run_s

; 1061 :                         ARCH_DEP( program_interrupt )( GUESTREGS, PGM_PER_EVENT );

  00381	ba 80 00 00 00	 mov	 edx, 128		; 00000080H
  00386	48 8b 84 24 00
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0038e	48 8b 88 70 08
	00 00		 mov	 rcx, QWORD PTR [rax+2160]
  00395	e8 00 00 00 00	 call	 s370_program_interrupt
$LN84@s370_run_s:

; 1062 : 
; 1063 :                     OBTAIN_INTLOCK( regs );

  0039a	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG169973
  003a1	48 8b 8c 24 00
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  003a9	e8 00 00 00 00	 call	 Obtain_Interrupt_Lock
$LN22@s370_run_s:

; 1064 :                     OFF_IC_INTERRUPT( GUESTREGS );

  003ae	48 8b 84 24 00
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  003b6	48 8b 80 70 08
	00 00		 mov	 rax, QWORD PTR [rax+2160]
  003bd	8b 40 48	 mov	 eax, DWORD PTR [rax+72]
  003c0	0f ba f0 1f	 btr	 eax, 31
  003c4	48 8b 8c 24 00
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  003cc	48 8b 89 70 08
	00 00		 mov	 rcx, QWORD PTR [rcx+2160]
  003d3	89 41 48	 mov	 DWORD PTR [rcx+72], eax
  003d6	33 c0		 xor	 eax, eax
  003d8	85 c0		 test	 eax, eax
  003da	75 d2		 jne	 SHORT $LN22@s370_run_s
$LN25@s370_run_s:

; 1065 : 
; 1066 :                     /* Set psw.IA and invalidate the aia */
; 1067 :                     INVALIDATE_AIA( GUESTREGS );

  003dc	48 8b 84 24 00
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  003e4	48 8b 80 70 08
	00 00		 mov	 rax, QWORD PTR [rax+2160]
  003eb	48 83 b8 08 02
	00 00 00	 cmp	 QWORD PTR [rax+520], 0
  003f3	74 79		 je	 SHORT $LN85@s370_run_s
  003f5	48 8b 84 24 00
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  003fd	48 8b 80 70 08
	00 00		 mov	 rax, QWORD PTR [rax+2160]
  00404	8b 80 10 02 00
	00		 mov	 eax, DWORD PTR [rax+528]
  0040a	48 8b 8c 24 00
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00412	48 8b 89 70 08
	00 00		 mov	 rcx, QWORD PTR [rcx+2160]
  00419	48 8b 94 24 00
	01 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  00421	48 8b 92 70 08
	00 00		 mov	 rdx, QWORD PTR [rdx+2160]
  00428	48 8b 92 00 02
	00 00		 mov	 rdx, QWORD PTR [rdx+512]
  0042f	48 8b 49 68	 mov	 rcx, QWORD PTR [rcx+104]
  00433	48 2b ca	 sub	 rcx, rdx
  00436	48 03 c1	 add	 rax, rcx
  00439	48 25 ff ff ff
	00		 and	 rax, 16777215		; 00ffffffH
  0043f	48 8b 8c 24 00
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00447	48 8b 89 70 08
	00 00		 mov	 rcx, QWORD PTR [rcx+2160]
  0044e	89 81 88 00 00
	00		 mov	 DWORD PTR [rcx+136], eax
  00454	48 8b 84 24 00
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0045c	48 8b 80 70 08
	00 00		 mov	 rax, QWORD PTR [rax+2160]
  00463	48 c7 80 08 02
	00 00 00 00 00
	00		 mov	 QWORD PTR [rax+520], 0
$LN85@s370_run_s:
  0046e	33 c0		 xor	 eax, eax
  00470	85 c0		 test	 eax, eax
  00472	0f 85 64 ff ff
	ff		 jne	 $LN25@s370_run_s

; 1068 : 
; 1069 :                     /* Process External Interrupt if one is pending */
; 1070 :                     if (1
; 1071 :                         && OPEN_IC_EXTPENDING( GUESTREGS )

  00478	33 c0		 xor	 eax, eax
  0047a	83 f8 01	 cmp	 eax, 1
  0047d	74 43		 je	 SHORT $LN86@s370_run_s
  0047f	48 8b 84 24 00
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00487	48 8b 80 70 08
	00 00		 mov	 rax, QWORD PTR [rax+2160]
  0048e	48 8b 8c 24 00
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00496	48 8b 89 70 08
	00 00		 mov	 rcx, QWORD PTR [rcx+2160]
  0049d	8b 49 4c	 mov	 ecx, DWORD PTR [rcx+76]
  004a0	8b 40 48	 mov	 eax, DWORD PTR [rax+72]
  004a3	23 c1		 and	 eax, ecx
  004a5	25 f0 ff 00 00	 and	 eax, 65520		; 0000fff0H
  004aa	85 c0		 test	 eax, eax
  004ac	74 14		 je	 SHORT $LN86@s370_run_s

; 1072 : #if defined( FEATURE_073_TRANSACT_EXEC_FACILITY )
; 1073 :                         /* Don't interrupt active transaction */
; 1074 :                         && (0
; 1075 :                             || GUESTREGS->txf_tnd == 0
; 1076 :                             || GUESTREGS->txf_PPA < PPA_MUCH_HELP_THRESHOLD
; 1077 :                            )
; 1078 : #endif
; 1079 :                     )
; 1080 :                         ARCH_DEP( perform_external_interrupt )( GUESTREGS );

  004ae	48 8b 84 24 00
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  004b6	48 8b 88 70 08
	00 00		 mov	 rcx, QWORD PTR [rax+2160]
  004bd	e8 00 00 00 00	 call	 s370_perform_external_interrupt
$LN86@s370_run_s:

; 1081 : 
; 1082 :                     /* Process I/O Interrupt if either I/O or SIGA Assist is enabled
; 1083 :                        and an I/O Interrupt is pending.
; 1084 :                     */
; 1085 :                     if (1
; 1086 :                         && (0
; 1087 :                             || (STATEBK->ec[0] & SIE_EC0_IOA)
; 1088 :                             || (STATEBK->ec[3] & SIE_EC3_SIGA)
; 1089 :                            )
; 1090 :                         && OPEN_IC_IOPENDING( GUESTREGS )

  004c2	33 c0		 xor	 eax, eax
  004c4	83 f8 01	 cmp	 eax, 1
  004c7	0f 84 a8 00 00
	00		 je	 $LN87@s370_run_s
  004cd	33 c0		 xor	 eax, eax
  004cf	85 c0		 test	 eax, eax
  004d1	75 56		 jne	 SHORT $LN88@s370_run_s
  004d3	48 8b 84 24 00
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  004db	48 8b 80 70 08
	00 00		 mov	 rax, QWORD PTR [rax+2160]
  004e2	48 8b 80 88 08
	00 00		 mov	 rax, QWORD PTR [rax+2184]
  004e9	b9 01 00 00 00	 mov	 ecx, 1
  004ee	48 6b c9 00	 imul	 rcx, rcx, 0
  004f2	0f b6 44 08 4c	 movzx	 eax, BYTE PTR [rax+rcx+76]
  004f7	83 e0 04	 and	 eax, 4
  004fa	85 c0		 test	 eax, eax
  004fc	75 2b		 jne	 SHORT $LN88@s370_run_s
  004fe	48 8b 84 24 00
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00506	48 8b 80 70 08
	00 00		 mov	 rax, QWORD PTR [rax+2160]
  0050d	48 8b 80 88 08
	00 00		 mov	 rax, QWORD PTR [rax+2184]
  00514	b9 01 00 00 00	 mov	 ecx, 1
  00519	48 6b c9 03	 imul	 rcx, rcx, 3
  0051d	0f b6 44 08 4c	 movzx	 eax, BYTE PTR [rax+rcx+76]
  00522	83 e0 04	 and	 eax, 4
  00525	85 c0		 test	 eax, eax
  00527	74 4c		 je	 SHORT $LN87@s370_run_s
$LN88@s370_run_s:
  00529	48 8b 84 24 00
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00531	48 8b 80 70 08
	00 00		 mov	 rax, QWORD PTR [rax+2160]
  00538	48 8b 8c 24 00
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00540	48 8b 89 70 08
	00 00		 mov	 rcx, QWORD PTR [rcx+2160]
  00547	8b 49 4c	 mov	 ecx, DWORD PTR [rcx+76]
  0054a	8b 40 48	 mov	 eax, DWORD PTR [rax+72]
  0054d	23 c1		 and	 eax, ecx
  0054f	25 00 00 00 40	 and	 eax, 1073741824		; 40000000H
  00554	85 c0		 test	 eax, eax
  00556	74 1d		 je	 SHORT $LN87@s370_run_s

; 1091 :                     )
; 1092 :                     {
; 1093 :                         PERFORM_SERIALIZATION ( GUESTREGS );

  00558	0f ae f0	 mfence
$LN28@s370_run_s:

; 1094 :                         PERFORM_CHKPT_SYNC    ( GUESTREGS );

  0055b	33 c0		 xor	 eax, eax
  0055d	85 c0		 test	 eax, eax
  0055f	75 fa		 jne	 SHORT $LN28@s370_run_s

; 1095 :                         ARCH_DEP( perform_io_interrupt )( GUESTREGS );

  00561	48 8b 84 24 00
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00569	48 8b 88 70 08
	00 00		 mov	 rcx, QWORD PTR [rax+2160]
  00570	e8 00 00 00 00	 call	 s370_perform_io_interrupt
$LN87@s370_run_s:

; 1096 :                     }
; 1097 : 
; 1098 : #if defined( _FEATURE_WAITSTATE_ASSIST )
; 1099 : 
; 1100 :                     /*  Is SIE guest in a wait state
; 1101 :                         AND Wait State Assist enabled?
; 1102 :                     */
; 1103 :                     if (1
; 1104 :                         && WAITSTATE( &GUESTREGS->psw )
; 1105 :                         && (STATEBK->ec[0] & SIE_EC0_WAIA)

  00575	33 c0		 xor	 eax, eax
  00577	83 f8 01	 cmp	 eax, 1
  0057a	0f 84 8c 08 00
	00		 je	 $LN89@s370_run_s
  00580	48 8b 84 24 00
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00588	48 8b 80 70 08
	00 00		 mov	 rax, QWORD PTR [rax+2160]
  0058f	0f b6 40 7a	 movzx	 eax, BYTE PTR [rax+122]
  00593	83 e0 02	 and	 eax, 2
  00596	85 c0		 test	 eax, eax
  00598	0f 84 6e 08 00
	00		 je	 $LN89@s370_run_s
  0059e	48 8b 84 24 00
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  005a6	48 8b 80 70 08
	00 00		 mov	 rax, QWORD PTR [rax+2160]
  005ad	48 8b 80 88 08
	00 00		 mov	 rax, QWORD PTR [rax+2184]
  005b4	b9 01 00 00 00	 mov	 ecx, 1
  005b9	48 6b c9 00	 imul	 rcx, rcx, 0
  005bd	0f b6 44 08 4c	 movzx	 eax, BYTE PTR [rax+rcx+76]
  005c2	83 e0 20	 and	 eax, 32			; 00000020H
  005c5	85 c0		 test	 eax, eax
  005c7	0f 84 3f 08 00
	00		 je	 $LN89@s370_run_s

; 1106 :                     )
; 1107 :                     {
; 1108 :                         /* Test for disabled wait PSW and issue message */
; 1109 :                         if (IS_IC_DISABLED_WAIT_PSW( GUESTREGS ))

  005cd	48 8b 84 24 00
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  005d5	48 8b 80 70 08
	00 00		 mov	 rax, QWORD PTR [rax+2160]
  005dc	8b 40 4c	 mov	 eax, DWORD PTR [rax+76]
  005df	25 f0 ff 00 5f	 and	 eax, 1593901040		; 5f00fff0H
  005e4	85 c0		 test	 eax, eax
  005e6	75 36		 jne	 SHORT $LN90@s370_run_s

; 1110 :                         {
; 1111 :                             RELEASE_INTLOCK( regs );

  005e8	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG169980
  005ef	48 8b 8c 24 00
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  005f7	e8 00 00 00 00	 call	 Release_Interrupt_Lock

; 1112 :                             longjmp( GUESTREGS->progjmp, SIE_INTERCEPT_WAIT );

  005fc	48 8b 84 24 00
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00604	48 8b 80 70 08
	00 00		 mov	 rax, QWORD PTR [rax+2160]
  0060b	48 05 80 09 00
	00		 add	 rax, 2432		; 00000980H
  00611	ba f8 ff ff ff	 mov	 edx, -8
  00616	48 8b c8	 mov	 rcx, rax
  00619	e8 00 00 00 00	 call	 longjmp
$LN90@s370_run_s:

; 1113 :                         }
; 1114 : 
; 1115 :                         /* Skip conditions we cannot assist with */
; 1116 :                         if (0
; 1117 :                             || SIE_I_STOP ( GUESTREGS )
; 1118 :                             || SIE_I_EXT  ( GUESTREGS )
; 1119 :                             || SIE_I_IO   ( GUESTREGS )
; 1120 :                             || SIE_I_HOST (    regs   )

  0061e	33 c0		 xor	 eax, eax
  00620	85 c0		 test	 eax, eax
  00622	0f 85 e5 00 00
	00		 jne	 $LN92@s370_run_s
  00628	48 8b 84 24 00
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00630	48 8b 80 70 08
	00 00		 mov	 rax, QWORD PTR [rax+2160]
  00637	48 8b 80 88 08
	00 00		 mov	 rax, QWORD PTR [rax+2184]
  0063e	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  00641	83 e0 04	 and	 eax, 4
  00644	85 c0		 test	 eax, eax
  00646	0f 85 c1 00 00
	00		 jne	 $LN92@s370_run_s
  0064c	48 8b 84 24 00
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00654	48 8b 80 70 08
	00 00		 mov	 rax, QWORD PTR [rax+2160]
  0065b	48 8b 80 88 08
	00 00		 mov	 rax, QWORD PTR [rax+2184]
  00662	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  00665	83 e0 01	 and	 eax, 1
  00668	85 c0		 test	 eax, eax
  0066a	74 1e		 je	 SHORT $LN93@s370_run_s
  0066c	48 8b 84 24 00
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00674	48 8b 80 70 08
	00 00		 mov	 rax, QWORD PTR [rax+2160]
  0067b	0f b6 40 78	 movzx	 eax, BYTE PTR [rax+120]
  0067f	83 e0 01	 and	 eax, 1
  00682	85 c0		 test	 eax, eax
  00684	0f 85 83 00 00
	00		 jne	 $LN92@s370_run_s
$LN93@s370_run_s:
  0068a	48 8b 84 24 00
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00692	48 8b 80 70 08
	00 00		 mov	 rax, QWORD PTR [rax+2160]
  00699	48 8b 80 88 08
	00 00		 mov	 rax, QWORD PTR [rax+2184]
  006a0	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  006a3	83 e0 02	 and	 eax, 2
  006a6	85 c0		 test	 eax, eax
  006a8	74 47		 je	 SHORT $LN94@s370_run_s
  006aa	48 8b 84 24 00
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  006b2	48 8b 80 70 08
	00 00		 mov	 rax, QWORD PTR [rax+2160]
  006b9	0f b6 40 7a	 movzx	 eax, BYTE PTR [rax+122]
  006bd	83 e0 08	 and	 eax, 8
  006c0	85 c0		 test	 eax, eax
  006c2	74 0a		 je	 SHORT $LN131@s370_run_s
  006c4	c7 44 24 64 02
	00 00 00	 mov	 DWORD PTR tv341[rsp], 2
  006cc	eb 08		 jmp	 SHORT $LN132@s370_run_s
$LN131@s370_run_s:
  006ce	c7 44 24 64 fe
	00 00 00	 mov	 DWORD PTR tv341[rsp], 254 ; 000000feH
$LN132@s370_run_s:
  006d6	48 8b 84 24 00
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  006de	48 8b 80 70 08
	00 00		 mov	 rax, QWORD PTR [rax+2160]
  006e5	0f b6 40 78	 movzx	 eax, BYTE PTR [rax+120]
  006e9	23 44 24 64	 and	 eax, DWORD PTR tv341[rsp]
  006ed	85 c0		 test	 eax, eax
  006ef	75 1c		 jne	 SHORT $LN92@s370_run_s
$LN94@s370_run_s:
  006f1	48 8b 84 24 00
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  006f9	48 8b 8c 24 00
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00701	8b 49 4c	 mov	 ecx, DWORD PTR [rcx+76]
  00704	8b 40 48	 mov	 eax, DWORD PTR [rax+72]
  00707	23 c1		 and	 eax, ecx
  00709	85 c0		 test	 eax, eax
  0070b	74 19		 je	 SHORT $LN91@s370_run_s
$LN92@s370_run_s:

; 1121 :                         )
; 1122 :                         {
; 1123 :                             RELEASE_INTLOCK( regs );

  0070d	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG169985
  00714	48 8b 8c 24 00
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0071c	e8 00 00 00 00	 call	 Release_Interrupt_Lock

; 1124 :                             break;

  00721	e9 d0 0c 00 00	 jmp	 $LN18@s370_run_s
$LN91@s370_run_s:
$LN31@s370_run_s:

; 1125 :                         }
; 1126 : 
; 1127 :                         SET_AEA_MODE( GUESTREGS );

  00726	48 8b 84 24 00
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0072e	48 8b 80 70 08
	00 00		 mov	 rax, QWORD PTR [rax+2160]
  00735	b9 04 00 00 00	 mov	 ecx, 4
  0073a	48 6b c9 04	 imul	 rcx, rcx, 4
  0073e	8b 84 08 94 0c
	00 00		 mov	 eax, DWORD PTR [rax+rcx+3220]
  00745	89 84 24 8c 00
	00 00		 mov	 DWORD PTR inst_cr$4[rsp], eax
  0074c	48 8b 84 24 00
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00754	48 8b 80 70 08
	00 00		 mov	 rax, QWORD PTR [rax+2160]
  0075b	0f b6 80 90 0c
	00 00		 movzx	 eax, BYTE PTR [rax+3216]
  00762	88 44 24 58	 mov	 BYTE PTR oldmode$2[rsp], al
  00766	48 8b 84 24 00
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0076e	48 8b 80 70 08
	00 00		 mov	 rax, QWORD PTR [rax+2160]
  00775	0f b6 40 7a	 movzx	 eax, BYTE PTR [rax+122]
  00779	83 e0 08	 and	 eax, 8
  0077c	85 c0		 test	 eax, eax
  0077e	74 38		 je	 SHORT $LN133@s370_run_s
  00780	48 8b 84 24 00
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00788	48 8b 80 70 08
	00 00		 mov	 rax, QWORD PTR [rax+2160]
  0078f	0f b6 40 78	 movzx	 eax, BYTE PTR [rax+120]
  00793	83 e0 04	 and	 eax, 4
  00796	85 c0		 test	 eax, eax
  00798	74 1e		 je	 SHORT $LN133@s370_run_s
  0079a	48 8b 84 24 00
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  007a2	48 8b 80 70 08
	00 00		 mov	 rax, QWORD PTR [rax+2160]
  007a9	0f b6 40 7b	 movzx	 eax, BYTE PTR [rax+123]
  007ad	c1 f8 06	 sar	 eax, 6
  007b0	ff c0		 inc	 eax
  007b2	89 44 24 70	 mov	 DWORD PTR tv390[rsp], eax
  007b6	eb 73		 jmp	 SHORT $LN136@s370_run_s
$LN133@s370_run_s:
  007b8	48 8b 84 24 00
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  007c0	48 8b 80 70 08
	00 00		 mov	 rax, QWORD PTR [rax+2160]
  007c7	8b 80 c8 08 00
	00		 mov	 eax, DWORD PTR [rax+2248]
  007cd	d1 e8		 shr	 eax, 1
  007cf	83 e0 01	 and	 eax, 1
  007d2	85 c0		 test	 eax, eax
  007d4	74 45		 je	 SHORT $LN134@s370_run_s
  007d6	48 8b 84 24 00
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  007de	48 8b 80 70 08
	00 00		 mov	 rax, QWORD PTR [rax+2160]
  007e5	48 8b 80 88 08
	00 00		 mov	 rax, QWORD PTR [rax+2184]
  007ec	0f b6 40 02	 movzx	 eax, BYTE PTR [rax+2]
  007f0	83 e0 01	 and	 eax, 1
  007f3	85 c0		 test	 eax, eax
  007f5	74 24		 je	 SHORT $LN134@s370_run_s
  007f7	48 8b 84 24 00
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  007ff	48 8b 80 70 08
	00 00		 mov	 rax, QWORD PTR [rax+2160]
  00806	0f b6 40 7b	 movzx	 eax, BYTE PTR [rax+123]
  0080a	83 e0 40	 and	 eax, 64			; 00000040H
  0080d	85 c0		 test	 eax, eax
  0080f	74 0a		 je	 SHORT $LN134@s370_run_s
  00811	c7 44 24 68 02
	00 00 00	 mov	 DWORD PTR tv384[rsp], 2
  00819	eb 08		 jmp	 SHORT $LN135@s370_run_s
$LN134@s370_run_s:
  0081b	c7 44 24 68 00
	00 00 00	 mov	 DWORD PTR tv384[rsp], 0
$LN135@s370_run_s:
  00823	8b 44 24 68	 mov	 eax, DWORD PTR tv384[rsp]
  00827	89 44 24 70	 mov	 DWORD PTR tv390[rsp], eax
$LN136@s370_run_s:
  0082b	33 c0		 xor	 eax, eax
  0082d	85 c0		 test	 eax, eax
  0082f	75 7d		 jne	 SHORT $LN138@s370_run_s
  00831	48 8b 84 24 00
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00839	48 8b 80 70 08
	00 00		 mov	 rax, QWORD PTR [rax+2160]
  00840	0f b6 40 7a	 movzx	 eax, BYTE PTR [rax+122]
  00844	83 e0 08	 and	 eax, 8
  00847	85 c0		 test	 eax, eax
  00849	74 1a		 je	 SHORT $LN137@s370_run_s
  0084b	48 8b 84 24 00
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00853	48 8b 80 70 08
	00 00		 mov	 rax, QWORD PTR [rax+2160]
  0085a	0f b6 40 78	 movzx	 eax, BYTE PTR [rax+120]
  0085e	83 e0 40	 and	 eax, 64			; 00000040H
  00861	85 c0		 test	 eax, eax
  00863	75 49		 jne	 SHORT $LN138@s370_run_s
$LN137@s370_run_s:
  00865	48 8b 84 24 00
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0086d	48 8b 80 70 08
	00 00		 mov	 rax, QWORD PTR [rax+2160]
  00874	8b 80 c8 08 00
	00		 mov	 eax, DWORD PTR [rax+2248]
  0087a	d1 e8		 shr	 eax, 1
  0087c	83 e0 01	 and	 eax, 1
  0087f	85 c0		 test	 eax, eax
  00881	74 21		 je	 SHORT $LN139@s370_run_s
  00883	48 8b 84 24 00
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0088b	48 8b 80 70 08
	00 00		 mov	 rax, QWORD PTR [rax+2160]
  00892	48 8b 80 88 08
	00 00		 mov	 rax, QWORD PTR [rax+2184]
  00899	0f b6 40 03	 movzx	 eax, BYTE PTR [rax+3]
  0089d	83 e0 01	 and	 eax, 1
  008a0	85 c0		 test	 eax, eax
  008a2	75 0a		 jne	 SHORT $LN138@s370_run_s
$LN139@s370_run_s:
  008a4	c7 44 24 6c 00
	00 00 00	 mov	 DWORD PTR tv413[rsp], 0
  008ac	eb 08		 jmp	 SHORT $LN140@s370_run_s
$LN138@s370_run_s:
  008ae	c7 44 24 6c 40
	00 00 00	 mov	 DWORD PTR tv413[rsp], 64 ; 00000040H
$LN140@s370_run_s:
  008b6	8b 44 24 6c	 mov	 eax, DWORD PTR tv413[rsp]
  008ba	8b 4c 24 70	 mov	 ecx, DWORD PTR tv390[rsp]
  008be	0b c8		 or	 ecx, eax
  008c0	8b c1		 mov	 eax, ecx
  008c2	48 8b 8c 24 00
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  008ca	48 8b 89 70 08
	00 00		 mov	 rcx, QWORD PTR [rcx+2160]
  008d1	88 81 90 0c 00
	00		 mov	 BYTE PTR [rcx+3216], al
  008d7	48 8b 84 24 00
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  008df	48 8b 80 70 08
	00 00		 mov	 rax, QWORD PTR [rax+2160]
  008e6	0f b6 80 90 0c
	00 00		 movzx	 eax, BYTE PTR [rax+3216]
  008ed	83 e0 0f	 and	 eax, 15
  008f0	89 44 24 74	 mov	 DWORD PTR tv420[rsp], eax
  008f4	83 7c 24 74 01	 cmp	 DWORD PTR tv420[rsp], 1
  008f9	74 0c		 je	 SHORT $LN95@s370_run_s
  008fb	83 7c 24 74 03	 cmp	 DWORD PTR tv420[rsp], 3
  00900	74 4b		 je	 SHORT $LN96@s370_run_s
  00902	e9 ac 00 00 00	 jmp	 $LN97@s370_run_s
$LN95@s370_run_s:
  00907	c7 44 24 50 ff
	ff ff ff	 mov	 DWORD PTR i$1[rsp], -1
  0090f	eb 0a		 jmp	 SHORT $LN36@s370_run_s
$LN34@s370_run_s:
  00911	8b 44 24 50	 mov	 eax, DWORD PTR i$1[rsp]
  00915	ff c0		 inc	 eax
  00917	89 44 24 50	 mov	 DWORD PTR i$1[rsp], eax
$LN36@s370_run_s:
  0091b	83 7c 24 50 10	 cmp	 DWORD PTR i$1[rsp], 16
  00920	7d 26		 jge	 SHORT $LN35@s370_run_s
  00922	48 8b 84 24 00
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0092a	48 8b 80 70 08
	00 00		 mov	 rax, QWORD PTR [rax+2160]
  00931	8b 4c 24 50	 mov	 ecx, DWORD PTR i$1[rsp]
  00935	83 c1 05	 add	 ecx, 5
  00938	48 63 c9	 movsxd	 rcx, ecx
  0093b	c7 84 88 94 0c
	00 00 01 00 00
	00		 mov	 DWORD PTR [rax+rcx*4+3220], 1
  00946	eb c9		 jmp	 SHORT $LN34@s370_run_s
$LN35@s370_run_s:
  00948	e9 a7 00 00 00	 jmp	 $LN32@s370_run_s
$LN96@s370_run_s:
  0094d	48 8b 84 24 00
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00955	48 8b 80 70 08
	00 00		 mov	 rax, QWORD PTR [rax+2160]
  0095c	b9 04 00 00 00	 mov	 ecx, 4
  00961	48 6b c9 04	 imul	 rcx, rcx, 4
  00965	c7 84 08 94 0c
	00 00 01 00 00
	00		 mov	 DWORD PTR [rax+rcx+3220], 1
  00970	c7 44 24 50 00
	00 00 00	 mov	 DWORD PTR i$1[rsp], 0
  00978	eb 0a		 jmp	 SHORT $LN39@s370_run_s
$LN37@s370_run_s:
  0097a	8b 44 24 50	 mov	 eax, DWORD PTR i$1[rsp]
  0097e	ff c0		 inc	 eax
  00980	89 44 24 50	 mov	 DWORD PTR i$1[rsp], eax
$LN39@s370_run_s:
  00984	83 7c 24 50 10	 cmp	 DWORD PTR i$1[rsp], 16
  00989	7d 26		 jge	 SHORT $LN38@s370_run_s
  0098b	48 8b 84 24 00
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00993	48 8b 80 70 08
	00 00		 mov	 rax, QWORD PTR [rax+2160]
  0099a	8b 4c 24 50	 mov	 ecx, DWORD PTR i$1[rsp]
  0099e	83 c1 05	 add	 ecx, 5
  009a1	48 63 c9	 movsxd	 rcx, ecx
  009a4	c7 84 88 94 0c
	00 00 07 00 00
	00		 mov	 DWORD PTR [rax+rcx*4+3220], 7
  009af	eb c9		 jmp	 SHORT $LN37@s370_run_s
$LN38@s370_run_s:
  009b1	eb 41		 jmp	 SHORT $LN32@s370_run_s
$LN97@s370_run_s:
  009b3	c7 44 24 50 ff
	ff ff ff	 mov	 DWORD PTR i$1[rsp], -1
  009bb	eb 0a		 jmp	 SHORT $LN42@s370_run_s
$LN40@s370_run_s:
  009bd	8b 44 24 50	 mov	 eax, DWORD PTR i$1[rsp]
  009c1	ff c0		 inc	 eax
  009c3	89 44 24 50	 mov	 DWORD PTR i$1[rsp], eax
$LN42@s370_run_s:
  009c7	83 7c 24 50 10	 cmp	 DWORD PTR i$1[rsp], 16
  009cc	7d 26		 jge	 SHORT $LN41@s370_run_s
  009ce	48 8b 84 24 00
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  009d6	48 8b 80 70 08
	00 00		 mov	 rax, QWORD PTR [rax+2160]
  009dd	8b 4c 24 50	 mov	 ecx, DWORD PTR i$1[rsp]
  009e1	83 c1 05	 add	 ecx, 5
  009e4	48 63 c9	 movsxd	 rcx, ecx
  009e7	c7 84 88 94 0c
	00 00 ff ff ff
	ff		 mov	 DWORD PTR [rax+rcx*4+3220], -1
  009f2	eb c9		 jmp	 SHORT $LN40@s370_run_s
$LN41@s370_run_s:
$LN32@s370_run_s:
  009f4	48 8b 84 24 00
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  009fc	48 8b 80 70 08
	00 00		 mov	 rax, QWORD PTR [rax+2160]
  00a03	b9 04 00 00 00	 mov	 ecx, 4
  00a08	48 6b c9 04	 imul	 rcx, rcx, 4
  00a0c	8b 84 08 94 0c
	00 00		 mov	 eax, DWORD PTR [rax+rcx+3220]
  00a13	39 84 24 8c 00
	00 00		 cmp	 DWORD PTR inst_cr$4[rsp], eax
  00a1a	0f 84 9c 00 00
	00		 je	 $LN98@s370_run_s
$LN45@s370_run_s:
  00a20	48 8b 84 24 00
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00a28	48 8b 80 70 08
	00 00		 mov	 rax, QWORD PTR [rax+2160]
  00a2f	48 83 b8 08 02
	00 00 00	 cmp	 QWORD PTR [rax+520], 0
  00a37	74 79		 je	 SHORT $LN99@s370_run_s
  00a39	48 8b 84 24 00
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00a41	48 8b 80 70 08
	00 00		 mov	 rax, QWORD PTR [rax+2160]
  00a48	8b 80 10 02 00
	00		 mov	 eax, DWORD PTR [rax+528]
  00a4e	48 8b 8c 24 00
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00a56	48 8b 89 70 08
	00 00		 mov	 rcx, QWORD PTR [rcx+2160]
  00a5d	48 8b 94 24 00
	01 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  00a65	48 8b 92 70 08
	00 00		 mov	 rdx, QWORD PTR [rdx+2160]
  00a6c	48 8b 92 00 02
	00 00		 mov	 rdx, QWORD PTR [rdx+512]
  00a73	48 8b 49 68	 mov	 rcx, QWORD PTR [rcx+104]
  00a77	48 2b ca	 sub	 rcx, rdx
  00a7a	48 03 c1	 add	 rax, rcx
  00a7d	48 25 ff ff ff
	00		 and	 rax, 16777215		; 00ffffffH
  00a83	48 8b 8c 24 00
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00a8b	48 8b 89 70 08
	00 00		 mov	 rcx, QWORD PTR [rcx+2160]
  00a92	89 81 88 00 00
	00		 mov	 DWORD PTR [rcx+136], eax
  00a98	48 8b 84 24 00
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00aa0	48 8b 80 70 08
	00 00		 mov	 rax, QWORD PTR [rax+2160]
  00aa7	48 c7 80 08 02
	00 00 00 00 00
	00		 mov	 QWORD PTR [rax+520], 0
$LN99@s370_run_s:
  00ab2	33 c0		 xor	 eax, eax
  00ab4	85 c0		 test	 eax, eax
  00ab6	0f 85 64 ff ff
	ff		 jne	 $LN45@s370_run_s
$LN98@s370_run_s:
  00abc	0f b6 44 24 58	 movzx	 eax, BYTE PTR oldmode$2[rsp]
  00ac1	83 e0 40	 and	 eax, 64			; 00000040H
  00ac4	85 c0		 test	 eax, eax
  00ac6	0f 85 26 01 00
	00		 jne	 $LN100@s370_run_s
  00acc	48 8b 84 24 00
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00ad4	48 8b 80 70 08
	00 00		 mov	 rax, QWORD PTR [rax+2160]
  00adb	0f b6 80 90 0c
	00 00		 movzx	 eax, BYTE PTR [rax+3216]
  00ae2	83 e0 40	 and	 eax, 64			; 00000040H
  00ae5	85 c0		 test	 eax, eax
  00ae7	0f 84 05 01 00
	00		 je	 $LN100@s370_run_s
$LN48@s370_run_s:
  00aed	48 8b 84 24 00
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00af5	48 8b 80 70 08
	00 00		 mov	 rax, QWORD PTR [rax+2160]
  00afc	48 83 b8 08 02
	00 00 00	 cmp	 QWORD PTR [rax+520], 0
  00b04	74 79		 je	 SHORT $LN101@s370_run_s
  00b06	48 8b 84 24 00
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00b0e	48 8b 80 70 08
	00 00		 mov	 rax, QWORD PTR [rax+2160]
  00b15	8b 80 10 02 00
	00		 mov	 eax, DWORD PTR [rax+528]
  00b1b	48 8b 8c 24 00
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00b23	48 8b 89 70 08
	00 00		 mov	 rcx, QWORD PTR [rcx+2160]
  00b2a	48 8b 94 24 00
	01 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  00b32	48 8b 92 70 08
	00 00		 mov	 rdx, QWORD PTR [rdx+2160]
  00b39	48 8b 92 00 02
	00 00		 mov	 rdx, QWORD PTR [rdx+512]
  00b40	48 8b 49 68	 mov	 rcx, QWORD PTR [rcx+104]
  00b44	48 2b ca	 sub	 rcx, rdx
  00b47	48 03 c1	 add	 rax, rcx
  00b4a	48 25 ff ff ff
	00		 and	 rax, 16777215		; 00ffffffH
  00b50	48 8b 8c 24 00
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00b58	48 8b 89 70 08
	00 00		 mov	 rcx, QWORD PTR [rcx+2160]
  00b5f	89 81 88 00 00
	00		 mov	 DWORD PTR [rcx+136], eax
  00b65	48 8b 84 24 00
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00b6d	48 8b 80 70 08
	00 00		 mov	 rax, QWORD PTR [rax+2160]
  00b74	48 c7 80 08 02
	00 00 00 00 00
	00		 mov	 QWORD PTR [rax+520], 0
$LN101@s370_run_s:
  00b7f	33 c0		 xor	 eax, eax
  00b81	85 c0		 test	 eax, eax
  00b83	0f 85 64 ff ff
	ff		 jne	 $LN48@s370_run_s
  00b89	48 8b 84 24 00
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00b91	48 8b 80 70 08
	00 00		 mov	 rax, QWORD PTR [rax+2160]
  00b98	8b 80 28 07 00
	00		 mov	 eax, DWORD PTR [rax+1832]
  00b9e	c1 e8 02	 shr	 eax, 2
  00ba1	83 e0 01	 and	 eax, 1
  00ba4	85 c0		 test	 eax, eax
  00ba6	74 0a		 je	 SHORT $LN143@s370_run_s
  00ba8	c7 44 24 78 01
	00 00 00	 mov	 DWORD PTR tv514[rsp], 1
  00bb0	eb 08		 jmp	 SHORT $LN144@s370_run_s
$LN143@s370_run_s:
  00bb2	c7 44 24 78 00
	00 00 00	 mov	 DWORD PTR tv514[rsp], 0
$LN144@s370_run_s:
  00bba	83 7c 24 78 00	 cmp	 DWORD PTR tv514[rsp], 0
  00bbf	74 31		 je	 SHORT $LN102@s370_run_s
  00bc1	48 8b 84 24 00
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00bc9	48 8b 80 70 08
	00 00		 mov	 rax, QWORD PTR [rax+2160]
  00bd0	8b 40 48	 mov	 eax, DWORD PTR [rax+72]
  00bd3	25 00 00 20 00	 and	 eax, 2097152		; 00200000H
  00bd8	85 c0		 test	 eax, eax
  00bda	74 16		 je	 SHORT $LN102@s370_run_s
  00bdc	b2 fc		 mov	 dl, 252			; 000000fcH
  00bde	48 8b 84 24 00
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00be6	48 8b 88 70 08
	00 00		 mov	 rcx, QWORD PTR [rax+2160]
  00bed	e8 00 00 00 00	 call	 s370_invalidate_tlb
$LN102@s370_run_s:
$LN100@s370_run_s:
  00bf2	33 c0		 xor	 eax, eax
  00bf4	85 c0		 test	 eax, eax
  00bf6	0f 85 2a fb ff
	ff		 jne	 $LN31@s370_run_s

; 1128 : 
; 1129 :                         /* Assist with the wait... but only briefly */
; 1130 :                         {
; 1131 :                             struct timespec waittime;
; 1132 : 
; 1133 :                             U64 now = host_tod();

  00bfc	e8 00 00 00 00	 call	 host_tod
  00c01	48 89 84 24 98
	00 00 00	 mov	 QWORD PTR now$5[rsp], rax

; 1134 : 
; 1135 :                             waittime.tv_sec  =   (now >> (64-51)) / ONE_MILLION;

  00c09	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR now$5[rsp]
  00c11	48 c1 e8 0d	 shr	 rax, 13
  00c15	33 d2		 xor	 edx, edx
  00c17	b9 40 42 0f 00	 mov	 ecx, 1000000		; 000f4240H
  00c1c	48 f7 f1	 div	 rcx
  00c1f	48 89 84 24 d0
	00 00 00	 mov	 QWORD PTR waittime$6[rsp], rax

; 1136 :                             waittime.tv_nsec = (((now >> (64-51)) % ONE_MILLION) + 3333) * 1000;

  00c27	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR now$5[rsp]
  00c2f	48 c1 e8 0d	 shr	 rax, 13
  00c33	33 d2		 xor	 edx, edx
  00c35	b9 40 42 0f 00	 mov	 ecx, 1000000		; 000f4240H
  00c3a	48 f7 f1	 div	 rcx
  00c3d	48 8b c2	 mov	 rax, rdx
  00c40	48 05 05 0d 00
	00		 add	 rax, 3333		; 00000d05H
  00c46	48 69 c0 e8 03
	00 00		 imul	 rax, rax, 1000		; 000003e8H
  00c4d	89 84 24 d8 00
	00 00		 mov	 DWORD PTR waittime$6[rsp+8], eax

; 1137 :                             waittime.tv_sec  += waittime.tv_nsec /  ONE_BILLION;

  00c54	48 63 84 24 d8
	00 00 00	 movsxd	 rax, DWORD PTR waittime$6[rsp+8]
  00c5c	33 d2		 xor	 edx, edx
  00c5e	b9 00 ca 9a 3b	 mov	 ecx, 1000000000		; 3b9aca00H
  00c63	48 f7 f1	 div	 rcx
  00c66	48 8b 8c 24 d0
	00 00 00	 mov	 rcx, QWORD PTR waittime$6[rsp]
  00c6e	48 03 c8	 add	 rcx, rax
  00c71	48 8b c1	 mov	 rax, rcx
  00c74	48 89 84 24 d0
	00 00 00	 mov	 QWORD PTR waittime$6[rsp], rax

; 1138 :                             waittime.tv_nsec %=                     ONE_BILLION;

  00c7c	48 63 84 24 d8
	00 00 00	 movsxd	 rax, DWORD PTR waittime$6[rsp+8]
  00c84	33 d2		 xor	 edx, edx
  00c86	b9 00 ca 9a 3b	 mov	 ecx, 1000000000		; 3b9aca00H
  00c8b	48 f7 f1	 div	 rcx
  00c8e	48 8b c2	 mov	 rax, rdx
  00c91	89 84 24 d8 00
	00 00		 mov	 DWORD PTR waittime$6[rsp+8], eax

; 1139 : 
; 1140 :                             regs->waittod = now;

  00c98	48 8b 84 24 00
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00ca0	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR now$5[rsp]
  00ca8	48 89 88 b8 07
	00 00		 mov	 QWORD PTR [rax+1976], rcx

; 1141 : 
; 1142 :                             sysblk.waiting_mask  |=  regs->cpubit;

  00caf	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00cb6	48 8b 8c 24 00
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00cbe	48 8b 49 50	 mov	 rcx, QWORD PTR [rcx+80]
  00cc2	48 8b 80 b8 12
	00 00		 mov	 rax, QWORD PTR [rax+4792]
  00cc9	48 0b c1	 or	 rax, rcx
  00ccc	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  00cd3	48 89 81 b8 12
	00 00		 mov	 QWORD PTR [rcx+4792], rax

; 1143 :                             sysblk.intowner       =  LOCK_OWNER_NONE;

  00cda	b8 ff ff 00 00	 mov	 eax, 65535		; 0000ffffH
  00cdf	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  00ce6	66 89 81 62 10
	00 00		 mov	 WORD PTR [rcx+4194], ax

; 1144 :                             {
; 1145 :                                 timed_wait_condition( &regs->intcond, &sysblk.intlock, &waittime );

  00ced	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00cf4	48 05 70 10 00
	00		 add	 rax, 4208		; 00001070H
  00cfa	48 8b 8c 24 00
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00d02	48 81 c1 80 0c
	00 00		 add	 rcx, 3200		; 00000c80H
  00d09	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG169994
  00d10	4c 8d 84 24 d0
	00 00 00	 lea	 r8, QWORD PTR waittime$6[rsp]
  00d18	48 8b d0	 mov	 rdx, rax
  00d1b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_timed_wait_condition
$LN49@s370_run_s:

; 1146 : 
; 1147 :                                 while (sysblk.syncing)

  00d21	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00d28	0f b6 80 7c 13
	00 00		 movzx	 eax, BYTE PTR [rax+4988]
  00d2f	85 c0		 test	 eax, eax
  00d31	74 2d		 je	 SHORT $LN50@s370_run_s

; 1148 :                                      wait_condition( &sysblk.sync_done_cond, &sysblk.intlock );

  00d33	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00d3a	48 05 70 10 00
	00		 add	 rax, 4208		; 00001070H
  00d40	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  00d47	48 81 c1 90 13
	00 00		 add	 rcx, 5008		; 00001390H
  00d4e	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG169995
  00d55	48 8b d0	 mov	 rdx, rax
  00d58	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_wait_condition
  00d5e	eb c1		 jmp	 SHORT $LN49@s370_run_s
$LN50@s370_run_s:

; 1149 :                             }
; 1150 :                             sysblk.intowner       =   regs->cpuad;

  00d60	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00d67	48 8b 8c 24 00
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00d6f	0f b7 89 3c 08
	00 00		 movzx	 ecx, WORD PTR [rcx+2108]
  00d76	66 89 88 62 10
	00 00		 mov	 WORD PTR [rax+4194], cx

; 1151 :                             sysblk.waiting_mask  &=  ~regs->cpubit;

  00d7d	48 8b 84 24 00
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00d85	48 8b 40 50	 mov	 rax, QWORD PTR [rax+80]
  00d89	48 f7 d0	 not	 rax
  00d8c	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  00d93	48 8b 89 b8 12
	00 00		 mov	 rcx, QWORD PTR [rcx+4792]
  00d9a	48 23 c8	 and	 rcx, rax
  00d9d	48 8b c1	 mov	 rax, rcx
  00da0	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  00da7	48 89 81 b8 12
	00 00		 mov	 QWORD PTR [rcx+4792], rax

; 1152 : 
; 1153 :                             regs->waittime += host_tod() - regs->waittod;

  00dae	e8 00 00 00 00	 call	 host_tod
  00db3	48 8b 8c 24 00
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00dbb	48 2b 81 b8 07
	00 00		 sub	 rax, QWORD PTR [rcx+1976]
  00dc2	48 8b 8c 24 00
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00dca	48 03 81 c0 07
	00 00		 add	 rax, QWORD PTR [rcx+1984]
  00dd1	48 8b 8c 24 00
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00dd9	48 89 81 c0 07
	00 00		 mov	 QWORD PTR [rcx+1984], rax

; 1154 :                             regs->waittod = 0;

  00de0	48 8b 84 24 00
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00de8	48 c7 80 b8 07
	00 00 00 00 00
	00		 mov	 QWORD PTR [rax+1976], 0

; 1155 :                         }
; 1156 : 
; 1157 :                         RELEASE_INTLOCK( regs );

  00df3	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG169996
  00dfa	48 8b 8c 24 00
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00e02	e8 00 00 00 00	 call	 Release_Interrupt_Lock

; 1158 :                         break;

  00e07	e9 ea 05 00 00	 jmp	 $LN18@s370_run_s
$LN89@s370_run_s:

; 1159 : 
; 1160 :                     }
; 1161 : #endif /* defined( _FEATURE_WAITSTATE_ASSIST ) */
; 1162 : 
; 1163 :                     RELEASE_INTLOCK( regs );

  00e0c	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG169997
  00e13	48 8b 8c 24 00
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00e1b	e8 00 00 00 00	 call	 Release_Interrupt_Lock
$LN83@s370_run_s:

; 1164 :                 }
; 1165 : 
; 1166 :                 /* Break out of loop if SIE guest is waiting */
; 1167 :                 if (SIE_I_WAIT( GUESTREGS ))

  00e20	48 8b 84 24 00
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00e28	48 8b 80 70 08
	00 00		 mov	 rax, QWORD PTR [rax+2160]
  00e2f	0f b6 40 7a	 movzx	 eax, BYTE PTR [rax+122]
  00e33	83 e0 02	 and	 eax, 2
  00e36	85 c0		 test	 eax, eax
  00e38	74 30		 je	 SHORT $LN103@s370_run_s
  00e3a	48 8b 84 24 00
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00e42	48 8b 80 70 08
	00 00		 mov	 rax, QWORD PTR [rax+2160]
  00e49	48 8b 80 88 08
	00 00		 mov	 rax, QWORD PTR [rax+2184]
  00e50	b9 01 00 00 00	 mov	 ecx, 1
  00e55	48 6b c9 00	 imul	 rcx, rcx, 0
  00e59	0f b6 44 08 4c	 movzx	 eax, BYTE PTR [rax+rcx+76]
  00e5e	83 e0 20	 and	 eax, 32			; 00000020H
  00e61	85 c0		 test	 eax, eax
  00e63	75 05		 jne	 SHORT $LN103@s370_run_s

; 1168 :                     break;

  00e65	e9 8c 05 00 00	 jmp	 $LN18@s370_run_s
$LN103@s370_run_s:
$sie_fetch_instruction$159:

; 1169 : 
; 1170 : sie_fetch_instruction:
; 1171 : 
; 1172 :                 ip = INSTRUCTION_FETCH( GUESTREGS, 0 );

  00e6a	33 c0		 xor	 eax, eax
  00e6c	83 f8 01	 cmp	 eax, 1
  00e6f	74 2b		 je	 SHORT $LN145@s370_run_s
  00e71	48 8b 84 24 00
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00e79	48 8b 80 70 08
	00 00		 mov	 rax, QWORD PTR [rax+2160]
  00e80	48 8b 8c 24 00
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00e88	48 8b 89 70 08
	00 00		 mov	 rcx, QWORD PTR [rcx+2160]
  00e8f	48 8b 89 08 02
	00 00		 mov	 rcx, QWORD PTR [rcx+520]
  00e96	48 39 48 68	 cmp	 QWORD PTR [rax+104], rcx
  00e9a	72 10		 jb	 SHORT $LN146@s370_run_s
$LN145@s370_run_s:
  00e9c	33 c0		 xor	 eax, eax
  00e9e	85 c0		 test	 eax, eax
  00ea0	75 0a		 jne	 SHORT $LN146@s370_run_s
  00ea2	c7 44 24 7c 00
	00 00 00	 mov	 DWORD PTR tv604[rsp], 0
  00eaa	eb 08		 jmp	 SHORT $LN150@s370_run_s
$LN146@s370_run_s:
  00eac	c7 44 24 7c 01
	00 00 00	 mov	 DWORD PTR tv604[rsp], 1
$LN150@s370_run_s:
  00eb4	83 7c 24 7c 00	 cmp	 DWORD PTR tv604[rsp], 0
  00eb9	74 1d		 je	 SHORT $LN151@s370_run_s
  00ebb	48 8b 84 24 00
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00ec3	48 8b 80 70 08
	00 00		 mov	 rax, QWORD PTR [rax+2160]
  00eca	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  00ece	48 89 84 24 b0
	00 00 00	 mov	 QWORD PTR tv612[rsp], rax
  00ed6	eb 1e		 jmp	 SHORT $LN152@s370_run_s
$LN151@s370_run_s:
  00ed8	33 d2		 xor	 edx, edx
  00eda	48 8b 84 24 00
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00ee2	48 8b 88 70 08
	00 00		 mov	 rcx, QWORD PTR [rax+2160]
  00ee9	e8 00 00 00 00	 call	 s370_instfetch
  00eee	48 89 84 24 b0
	00 00 00	 mov	 QWORD PTR tv612[rsp], rax
$LN152@s370_run_s:
  00ef6	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR tv612[rsp]
  00efe	48 89 84 24 a0
	00 00 00	 mov	 QWORD PTR ip$[rsp], rax

; 1173 :                 current_opcode_table = GUESTREGS->ARCH_DEP( runtime_opcode_xxxx );

  00f06	48 8b 84 24 00
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00f0e	48 8b 80 70 08
	00 00		 mov	 rax, QWORD PTR [rax+2160]
  00f15	48 8b 80 c8 af
	00 00		 mov	 rax, QWORD PTR [rax+45000]
  00f1c	48 89 84 24 a8
	00 00 00	 mov	 QWORD PTR current_opcode_table$[rsp], rax
$LN53@s370_run_s:

; 1174 : 
; 1175 : #if defined( SIE_DEBUG )
; 1176 :                 ARCH_DEP( display_inst )( GUESTREGS, GUESTREGS->instinvalid ? NULL : ip );
; 1177 : #endif
; 1178 :                 //--------------------------------------------------------------
; 1179 :                 //                    PROGRAMMING NOTE
; 1180 :                 //--------------------------------------------------------------
; 1181 :                 // The first 'fastest_no_txf_loop' loop below is used when the
; 1182 :                 // TXF facility is not enabled, and since facilities cannot be
; 1183 :                 // enabled or disabled once the guest system has been IPLed and
; 1184 :                 // started, it utilizes our original instruction execution loop
; 1185 :                 // which uses the 'EXECUTE_INSTRUCTION' and 'UNROLLED_EXECUTE'
; 1186 :                 // macros which do not have any TXF related code in them.
; 1187 :                 //
; 1188 :                 // The second and third loops below (the 'txf_facility_loop' and
; 1189 :                 // 'txf_slower_loop') are used when the TXF facility is enabled,
; 1190 :                 // requiring us to check whether or not a transaction is active
; 1191 :                 // or not after each instruction is executed.
; 1192 :                 //
; 1193 :                 // If no transaction is active, the normal 'EXECUTE_INSTRUCTION'
; 1194 :                 // and 'UNROLLED_EXECUTE' macros can be used, but a check for an
; 1195 :                 // active transaction still needs to be performed after each and
; 1196 :                 // every instruction (so we can know which loop we need to use).
; 1197 :                 //
; 1198 :                 // When a transaction is active, we use the third (slowest) loop
; 1199 :                 // called 'txf_slower_loop', using the 'TXF_EXECUTE_INSTRUCTION'
; 1200 :                 // and 'TXF_UNROLLED_EXECUTE' macros, which contain code that
; 1201 :                 // enforces certain Transaction-Exceution Facility constraints.
; 1202 :                 //--------------------------------------------------------------
; 1203 : 
; 1204 : #if defined( FEATURE_073_TRANSACT_EXEC_FACILITY )
; 1205 :                 if (FACILITY_ENABLED( 073_TRANSACT_EXEC, GUESTREGS ))
; 1206 :                     goto txf_facility_loop;
; 1207 : #endif
; 1208 : 
; 1209 : //fastest_no_txf_loop:
; 1210 : 
; 1211 :                 SIE_PERFMON( SIE_PERF_EXEC );
; 1212 : 
; 1213 :                 PROCESS_TRACE( GUESTREGS, ip, sie_fetch_instruction );

  00f24	48 8b 84 24 00
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00f2c	48 8b 80 70 08
	00 00		 mov	 rax, QWORD PTR [rax+2160]
  00f33	8b 80 28 07 00
	00		 mov	 eax, DWORD PTR [rax+1832]
  00f39	c1 e8 10	 shr	 eax, 16
  00f3c	83 e0 01	 and	 eax, 1
  00f3f	85 c0		 test	 eax, eax
  00f41	0f 84 1b 01 00
	00		 je	 $LN104@s370_run_s
  00f47	48 8b 94 24 a0
	00 00 00	 mov	 rdx, QWORD PTR ip$[rsp]
  00f4f	48 8b 84 24 00
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00f57	48 8b 88 70 08
	00 00		 mov	 rcx, QWORD PTR [rax+2160]
  00f5e	e8 00 00 00 00	 call	 s370_process_trace
  00f63	33 c0		 xor	 eax, eax
  00f65	83 f8 01	 cmp	 eax, 1
  00f68	0f 84 f4 00 00
	00		 je	 $LN105@s370_run_s
  00f6e	48 8b 84 24 00
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00f76	48 8b 80 70 08
	00 00		 mov	 rax, QWORD PTR [rax+2160]
  00f7d	8b 80 28 07 00
	00		 mov	 eax, DWORD PTR [rax+1832]
  00f83	c1 e8 11	 shr	 eax, 17
  00f86	83 e0 01	 and	 eax, 1
  00f89	85 c0		 test	 eax, eax
  00f8b	0f 84 d1 00 00
	00		 je	 $LN105@s370_run_s
  00f91	48 8b 84 24 00
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00f99	48 8b 80 70 08
	00 00		 mov	 rax, QWORD PTR [rax+2160]
  00fa0	48 83 b8 08 02
	00 00 00	 cmp	 QWORD PTR [rax+520], 0
  00fa8	0f 85 b4 00 00
	00		 jne	 $LN105@s370_run_s
  00fae	48 8b 84 24 00
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00fb6	48 8b 80 70 08
	00 00		 mov	 rax, QWORD PTR [rax+2160]
  00fbd	0f b7 80 3c 08
	00 00		 movzx	 eax, WORD PTR [rax+2108]
  00fc4	89 84 24 90 00
	00 00		 mov	 DWORD PTR tv634[rsp], eax
  00fcb	48 8b 8c 24 00
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00fd3	48 8b 89 70 08
	00 00		 mov	 rcx, QWORD PTR [rcx+2160]
  00fda	0f b7 89 3c 08
	00 00		 movzx	 ecx, WORD PTR [rcx+2108]
  00fe1	48 8b 15 00 00
	00 00		 mov	 rdx, QWORD PTR __imp_sysblk
  00fe8	0f b6 8c 0a 48
	0b 00 00	 movzx	 ecx, BYTE PTR [rdx+rcx+2888]
  00ff0	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ptyp2short
  00ff6	48 89 84 24 b8
	00 00 00	 mov	 QWORD PTR tv636[rsp], rax
  00ffe	b9 01 00 00 00	 mov	 ecx, 1
  01003	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  01009	8b 8c 24 90 00
	00 00		 mov	 ecx, DWORD PTR tv634[rsp]
  01010	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  01014	48 8b 8c 24 b8
	00 00 00	 mov	 rcx, QWORD PTR tv636[rsp]
  0101c	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  01021	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170001
  01028	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  0102d	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170002
  01034	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  01039	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  0103e	41 b9 03 00 00
	00		 mov	 r9d, 3
  01044	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG170003
  0104b	ba bd 04 00 00	 mov	 edx, 1213		; 000004bdH
  01050	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170004
  01057	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg
  0105d	e9 08 fe ff ff	 jmp	 $sie_fetch_instruction$159
$LN105@s370_run_s:
$LN104@s370_run_s:
  01062	33 c0		 xor	 eax, eax
  01064	85 c0		 test	 eax, eax
  01066	0f 85 b8 fe ff
	ff		 jne	 $LN53@s370_run_s
$LN56@s370_run_s:

; 1214 :                 EXECUTE_INSTRUCTION( current_opcode_table, ip, GUESTREGS );

  0106c	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR ip$[rsp]
  01074	e8 00 00 00 00	 call	 fetch_hw_noswap
  01079	0f b7 c8	 movzx	 ecx, ax
  0107c	e8 00 00 00 00	 call	 _byteswap_ushort
  01081	0f b7 c0	 movzx	 eax, ax
  01084	48 8b 8c 24 00
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0108c	48 8b 91 70 08
	00 00		 mov	 rdx, QWORD PTR [rcx+2160]
  01093	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR ip$[rsp]
  0109b	4c 8b 84 24 a8
	00 00 00	 mov	 r8, QWORD PTR current_opcode_table$[rsp]
  010a3	41 ff 14 c0	 call	 QWORD PTR [r8+rax*8]
  010a7	33 c0		 xor	 eax, eax
  010a9	85 c0		 test	 eax, eax
  010ab	75 bf		 jne	 SHORT $LN56@s370_run_s

; 1215 :                 regs->instcount++;

  010ad	48 8b 84 24 00
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  010b5	8b 80 98 07 00
	00		 mov	 eax, DWORD PTR [rax+1944]
  010bb	ff c0		 inc	 eax
  010bd	48 8b 8c 24 00
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  010c5	89 81 98 07 00
	00		 mov	 DWORD PTR [rcx+1944], eax

; 1216 :                 UPDATE_SYSBLK_INSTCOUNT( 1 );

  010cb	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  010d2	48 05 80 14 00
	00		 add	 rax, 5248		; 00001480H
  010d8	ba 01 00 00 00	 mov	 edx, 1
  010dd	48 8b c8	 mov	 rcx, rax
  010e0	e8 00 00 00 00	 call	 atomic_update64

; 1217 :                 SIE_PERFMON( SIE_PERF_EXEC_U );
; 1218 : 
; 1219 :                 for (i=0; i < MAX_CPU_LOOPS/2; i++)

  010e5	c7 44 24 5c 00
	00 00 00	 mov	 DWORD PTR i$[rsp], 0
  010ed	eb 0a		 jmp	 SHORT $LN59@s370_run_s
$LN57@s370_run_s:
  010ef	8b 44 24 5c	 mov	 eax, DWORD PTR i$[rsp]
  010f3	ff c0		 inc	 eax
  010f5	89 44 24 5c	 mov	 DWORD PTR i$[rsp], eax
$LN59@s370_run_s:
  010f9	81 7c 24 5c 80
	00 00 00	 cmp	 DWORD PTR i$[rsp], 128	; 00000080H
  01101	0f 8d 30 01 00
	00		 jge	 $LN58@s370_run_s

; 1220 :                 {
; 1221 :                     UNROLLED_EXECUTE( current_opcode_table, GUESTREGS );

  01107	48 8b 84 24 00
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0110f	48 8b 80 70 08
	00 00		 mov	 rax, QWORD PTR [rax+2160]
  01116	48 8b 8c 24 00
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0111e	48 8b 89 70 08
	00 00		 mov	 rcx, QWORD PTR [rcx+2160]
  01125	48 8b 89 08 02
	00 00		 mov	 rcx, QWORD PTR [rcx+520]
  0112c	48 39 48 68	 cmp	 QWORD PTR [rax+104], rcx
  01130	72 05		 jb	 SHORT $LN106@s370_run_s
  01132	e9 00 01 00 00	 jmp	 $LN58@s370_run_s
$LN106@s370_run_s:
$LN62@s370_run_s:
  01137	48 8b 84 24 00
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0113f	48 8b 80 70 08
	00 00		 mov	 rax, QWORD PTR [rax+2160]
  01146	48 89 84 24 c0
	00 00 00	 mov	 QWORD PTR tv925[rsp], rax
  0114e	48 8b 8c 24 00
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  01156	48 8b 89 70 08
	00 00		 mov	 rcx, QWORD PTR [rcx+2160]
  0115d	48 8b 49 68	 mov	 rcx, QWORD PTR [rcx+104]
  01161	e8 00 00 00 00	 call	 fetch_hw_noswap
  01166	0f b7 c8	 movzx	 ecx, ax
  01169	e8 00 00 00 00	 call	 _byteswap_ushort
  0116e	0f b7 c0	 movzx	 eax, ax
  01171	48 8b 8c 24 00
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  01179	48 8b 91 70 08
	00 00		 mov	 rdx, QWORD PTR [rcx+2160]
  01180	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR tv925[rsp]
  01188	48 8b 49 68	 mov	 rcx, QWORD PTR [rcx+104]
  0118c	4c 8b 84 24 a8
	00 00 00	 mov	 r8, QWORD PTR current_opcode_table$[rsp]
  01194	41 ff 14 c0	 call	 QWORD PTR [r8+rax*8]
  01198	33 c0		 xor	 eax, eax
  0119a	85 c0		 test	 eax, eax
  0119c	75 99		 jne	 SHORT $LN62@s370_run_s

; 1222 :                     UNROLLED_EXECUTE( current_opcode_table, GUESTREGS );

  0119e	48 8b 84 24 00
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  011a6	48 8b 80 70 08
	00 00		 mov	 rax, QWORD PTR [rax+2160]
  011ad	48 8b 8c 24 00
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  011b5	48 8b 89 70 08
	00 00		 mov	 rcx, QWORD PTR [rcx+2160]
  011bc	48 8b 89 08 02
	00 00		 mov	 rcx, QWORD PTR [rcx+520]
  011c3	48 39 48 68	 cmp	 QWORD PTR [rax+104], rcx
  011c7	72 02		 jb	 SHORT $LN107@s370_run_s
  011c9	eb 6c		 jmp	 SHORT $LN58@s370_run_s
$LN107@s370_run_s:
$LN65@s370_run_s:
  011cb	48 8b 84 24 00
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  011d3	48 8b 80 70 08
	00 00		 mov	 rax, QWORD PTR [rax+2160]
  011da	48 89 84 24 c8
	00 00 00	 mov	 QWORD PTR tv921[rsp], rax
  011e2	48 8b 8c 24 00
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  011ea	48 8b 89 70 08
	00 00		 mov	 rcx, QWORD PTR [rcx+2160]
  011f1	48 8b 49 68	 mov	 rcx, QWORD PTR [rcx+104]
  011f5	e8 00 00 00 00	 call	 fetch_hw_noswap
  011fa	0f b7 c8	 movzx	 ecx, ax
  011fd	e8 00 00 00 00	 call	 _byteswap_ushort
  01202	0f b7 c0	 movzx	 eax, ax
  01205	48 8b 8c 24 00
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0120d	48 8b 91 70 08
	00 00		 mov	 rdx, QWORD PTR [rcx+2160]
  01214	48 8b 8c 24 c8
	00 00 00	 mov	 rcx, QWORD PTR tv921[rsp]
  0121c	48 8b 49 68	 mov	 rcx, QWORD PTR [rcx+104]
  01220	4c 8b 84 24 a8
	00 00 00	 mov	 r8, QWORD PTR current_opcode_table$[rsp]
  01228	41 ff 14 c0	 call	 QWORD PTR [r8+rax*8]
  0122c	33 c0		 xor	 eax, eax
  0122e	85 c0		 test	 eax, eax
  01230	75 99		 jne	 SHORT $LN65@s370_run_s

; 1223 :                 }

  01232	e9 b8 fe ff ff	 jmp	 $LN57@s370_run_s
$LN58@s370_run_s:

; 1224 :                 regs->instcount +=  (i * 2);

  01237	48 8b 84 24 00
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0123f	8b 80 98 07 00
	00		 mov	 eax, DWORD PTR [rax+1944]
  01245	8b 4c 24 5c	 mov	 ecx, DWORD PTR i$[rsp]
  01249	8d 04 48	 lea	 eax, DWORD PTR [rax+rcx*2]
  0124c	48 8b 8c 24 00
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  01254	89 81 98 07 00
	00		 mov	 DWORD PTR [rcx+1944], eax

; 1225 :                 UPDATE_SYSBLK_INSTCOUNT( (i * 2) );

  0125a	8b 44 24 5c	 mov	 eax, DWORD PTR i$[rsp]
  0125e	d1 e0		 shl	 eax, 1
  01260	48 98		 cdqe
  01262	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  01269	48 81 c1 80 14
	00 00		 add	 rcx, 5248		; 00001480H
  01270	48 8b d0	 mov	 rdx, rax
  01273	e8 00 00 00 00	 call	 atomic_update64

; 1226 : 
; 1227 :                 /* Perform automatic instruction tracing if it's enabled */
; 1228 :                 do_automatic_tracing();

  01278	e8 00 00 00 00	 call	 do_automatic_tracing
$endloop$160:

; 1229 :                 goto endloop;
; 1230 : 
; 1231 : #if defined( FEATURE_073_TRANSACT_EXEC_FACILITY )
; 1232 : 
; 1233 : txf_facility_loop:
; 1234 : 
; 1235 :                 SIE_PERFMON( SIE_PERF_EXEC );
; 1236 : 
; 1237 :                 if (GUESTREGS->txf_tnd)
; 1238 :                     goto txf_slower_loop;
; 1239 : 
; 1240 :                 PROCESS_TRACE( GUESTREGS, ip, sie_fetch_instruction );
; 1241 :                 EXECUTE_INSTRUCTION( current_opcode_table, ip, GUESTREGS );
; 1242 :                 regs->instcount++;
; 1243 :                 UPDATE_SYSBLK_INSTCOUNT( 1 );
; 1244 :                 SIE_PERFMON( SIE_PERF_EXEC_U );
; 1245 : 
; 1246 :                 for (i=0; i < MAX_CPU_LOOPS/2; i++)
; 1247 :                 {
; 1248 :                     if (GUESTREGS->txf_tnd)
; 1249 :                         break;
; 1250 : 
; 1251 :                     UNROLLED_EXECUTE( current_opcode_table, GUESTREGS );
; 1252 : 
; 1253 :                     if (GUESTREGS->txf_tnd)
; 1254 :                         break;
; 1255 : 
; 1256 :                     UNROLLED_EXECUTE( current_opcode_table, GUESTREGS );
; 1257 :                 }
; 1258 :                 regs->instcount +=  (i * 2);
; 1259 :                 UPDATE_SYSBLK_INSTCOUNT( (i * 2) );
; 1260 : 
; 1261 :                 /* Perform automatic instruction tracing if it's enabled */
; 1262 :                 do_automatic_tracing();
; 1263 :                 goto endloop;
; 1264 : 
; 1265 : txf_slower_loop:
; 1266 : 
; 1267 :                 PROCESS_TRACE( GUESTREGS, ip, sie_fetch_instruction );
; 1268 :                 TXF_EXECUTE_INSTRUCTION( current_opcode_table, ip, GUESTREGS );
; 1269 :                 regs->instcount++;
; 1270 :                 UPDATE_SYSBLK_INSTCOUNT( 1 );
; 1271 :                 SIE_PERFMON( SIE_PERF_EXEC_U );
; 1272 : 
; 1273 :                 for (i=0; i < MAX_CPU_LOOPS/2; i++)
; 1274 :                 {
; 1275 :                     if (!GUESTREGS->txf_tnd)
; 1276 :                         break;
; 1277 : 
; 1278 :                     TXF_UNROLLED_EXECUTE( current_opcode_table, GUESTREGS );
; 1279 : 
; 1280 :                     if (!GUESTREGS->txf_tnd)
; 1281 :                         break;
; 1282 : 
; 1283 :                     TXF_UNROLLED_EXECUTE( current_opcode_table, GUESTREGS );
; 1284 :                 }
; 1285 :                 regs->instcount +=  (i * 2);
; 1286 :                 UPDATE_SYSBLK_INSTCOUNT( (i * 2) );
; 1287 : 
; 1288 :                 /* Perform automatic instruction tracing if it's enabled */
; 1289 :                 do_automatic_tracing();
; 1290 :                 goto endloop;
; 1291 : 
; 1292 : #endif /* defined( FEATURE_073_TRANSACT_EXEC_FACILITY ) */
; 1293 : 
; 1294 : endloop:        ; // (nop to make compiler happy)
; 1295 :             }
; 1296 :             /******************************************/
; 1297 :             /* Remain in SIE (above loop) as long as: */
; 1298 :             /*  - No Host Interrupt is pending        */
; 1299 :             /*  - No SIE defined Interrupt is pending */
; 1300 :             /*    (Wait, External or I/O)             */
; 1301 :             /*  - No guest interrupt is pending       */
; 1302 :             /******************************************/
; 1303 :             while
; 1304 :             (0
; 1305 : #if defined( FEATURE_073_TRANSACT_EXEC_FACILITY )
; 1306 :              /* Don't interrupt active transaction */
; 1307 :              || (1
; 1308 :                  && GUESTREGS->txf_tnd > 0
; 1309 :                  && GUESTREGS->txf_PPA >= PPA_MUCH_HELP_THRESHOLD
; 1310 :                 )
; 1311 : #endif
; 1312 :              || (1

  0127d	33 c0		 xor	 eax, eax
  0127f	85 c0		 test	 eax, eax
  01281	0f 85 72 ef ff
	ff		 jne	 $LN19@s370_run_s
  01287	33 c0		 xor	 eax, eax
  01289	83 f8 01	 cmp	 eax, 1
  0128c	0f 84 64 01 00
	00		 je	 $LN108@s370_run_s
  01292	48 8b 84 24 00
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0129a	48 8b 8c 24 00
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  012a2	8b 49 4c	 mov	 ecx, DWORD PTR [rcx+76]
  012a5	8b 40 48	 mov	 eax, DWORD PTR [rax+72]
  012a8	23 c1		 and	 eax, ecx
  012aa	85 c0		 test	 eax, eax
  012ac	0f 85 44 01 00
	00		 jne	 $LN108@s370_run_s
  012b2	48 8b 84 24 00
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  012ba	48 8b 80 70 08
	00 00		 mov	 rax, QWORD PTR [rax+2160]
  012c1	0f b6 40 7a	 movzx	 eax, BYTE PTR [rax+122]
  012c5	83 e0 02	 and	 eax, 2
  012c8	85 c0		 test	 eax, eax
  012ca	74 2f		 je	 SHORT $LN109@s370_run_s
  012cc	48 8b 84 24 00
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  012d4	48 8b 80 70 08
	00 00		 mov	 rax, QWORD PTR [rax+2160]
  012db	48 8b 80 88 08
	00 00		 mov	 rax, QWORD PTR [rax+2184]
  012e2	b9 01 00 00 00	 mov	 ecx, 1
  012e7	48 6b c9 00	 imul	 rcx, rcx, 0
  012eb	0f b6 44 08 4c	 movzx	 eax, BYTE PTR [rax+rcx+76]
  012f0	83 e0 20	 and	 eax, 32			; 00000020H
  012f3	85 c0		 test	 eax, eax
  012f5	0f 84 fb 00 00
	00		 je	 $LN108@s370_run_s
$LN109@s370_run_s:
  012fb	48 8b 84 24 00
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  01303	48 8b 80 70 08
	00 00		 mov	 rax, QWORD PTR [rax+2160]
  0130a	48 8b 80 88 08
	00 00		 mov	 rax, QWORD PTR [rax+2184]
  01311	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  01314	83 e0 01	 and	 eax, 1
  01317	85 c0		 test	 eax, eax
  01319	74 1e		 je	 SHORT $LN110@s370_run_s
  0131b	48 8b 84 24 00
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  01323	48 8b 80 70 08
	00 00		 mov	 rax, QWORD PTR [rax+2160]
  0132a	0f b6 40 78	 movzx	 eax, BYTE PTR [rax+120]
  0132e	83 e0 01	 and	 eax, 1
  01331	85 c0		 test	 eax, eax
  01333	0f 85 bd 00 00
	00		 jne	 $LN108@s370_run_s
$LN110@s370_run_s:
  01339	48 8b 84 24 00
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  01341	48 8b 80 70 08
	00 00		 mov	 rax, QWORD PTR [rax+2160]
  01348	48 8b 80 88 08
	00 00		 mov	 rax, QWORD PTR [rax+2184]
  0134f	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  01352	83 e0 02	 and	 eax, 2
  01355	85 c0		 test	 eax, eax
  01357	74 50		 je	 SHORT $LN111@s370_run_s
  01359	48 8b 84 24 00
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  01361	48 8b 80 70 08
	00 00		 mov	 rax, QWORD PTR [rax+2160]
  01368	0f b6 40 7a	 movzx	 eax, BYTE PTR [rax+122]
  0136c	83 e0 08	 and	 eax, 8
  0136f	85 c0		 test	 eax, eax
  01371	74 0d		 je	 SHORT $LN153@s370_run_s
  01373	c7 84 24 80 00
	00 00 02 00 00
	00		 mov	 DWORD PTR tv768[rsp], 2
  0137e	eb 0b		 jmp	 SHORT $LN154@s370_run_s
$LN153@s370_run_s:
  01380	c7 84 24 80 00
	00 00 fe 00 00
	00		 mov	 DWORD PTR tv768[rsp], 254 ; 000000feH
$LN154@s370_run_s:
  0138b	48 8b 84 24 00
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  01393	48 8b 80 70 08
	00 00		 mov	 rax, QWORD PTR [rax+2160]
  0139a	0f b6 40 78	 movzx	 eax, BYTE PTR [rax+120]
  0139e	23 84 24 80 00
	00 00		 and	 eax, DWORD PTR tv768[rsp]
  013a5	85 c0		 test	 eax, eax
  013a7	75 4d		 jne	 SHORT $LN108@s370_run_s
$LN111@s370_run_s:
  013a9	48 8b 84 24 00
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  013b1	48 8b 80 70 08
	00 00		 mov	 rax, QWORD PTR [rax+2160]
  013b8	48 8b 8c 24 00
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  013c0	48 8b 89 70 08
	00 00		 mov	 rcx, QWORD PTR [rcx+2160]
  013c7	48 8b 89 68 08
	00 00		 mov	 rcx, QWORD PTR [rcx+2152]
  013ce	8b 49 48	 mov	 ecx, DWORD PTR [rcx+72]
  013d1	81 e1 80 0c 00
	40		 and	 ecx, 1073745024		; 40000c80H
  013d7	8b 40 48	 mov	 eax, DWORD PTR [rax+72]
  013da	0b c1		 or	 eax, ecx
  013dc	48 8b 8c 24 00
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  013e4	48 8b 89 70 08
	00 00		 mov	 rcx, QWORD PTR [rcx+2160]
  013eb	23 41 4c	 and	 eax, DWORD PTR [rcx+76]
  013ee	85 c0		 test	 eax, eax
  013f0	0f 84 03 ee ff
	ff		 je	 $LN158@s370_run_s
$LN108@s370_run_s:
$LN18@s370_run_s:

; 1313 :                  && !SIE_I_HOST            (    regs   )
; 1314 :                  && !SIE_I_WAIT            ( GUESTREGS )
; 1315 :                  && !SIE_I_EXT             ( GUESTREGS )
; 1316 :                  && !SIE_I_IO              ( GUESTREGS )
; 1317 :                  && !SIE_INTERRUPT_PENDING ( GUESTREGS )
; 1318 :                 )
; 1319 :             );
; 1320 : 
; 1321 :             /* Otherwise break out of the above loop
; 1322 :                and check if we should exit from SIE
; 1323 :                (check is done slightly further below)
; 1324 :             */
; 1325 :         }

  013f6	eb 56		 jmp	 SHORT $LN78@s370_run_s
$LN77@s370_run_s:

; 1326 :         else
; 1327 :         {
; 1328 :             /* Our above instruction execution loop didn't finish due
; 1329 :                to a longjmp(progjmp) having been done, bringing us to
; 1330 :                here, thereby causing the instruction counter to not be
; 1331 :                properly updated. Thus, we must update it here instead.
; 1332 :            */
; 1333 :             if (sysblk.ipled)

  013f8	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  013ff	8b 80 94 12 00
	00		 mov	 eax, DWORD PTR [rax+4756]
  01405	d1 e8		 shr	 eax, 1
  01407	83 e0 01	 and	 eax, 1
  0140a	85 c0		 test	 eax, eax
  0140c	74 40		 je	 SHORT $LN112@s370_run_s

; 1334 :             {
; 1335 :                 regs->instcount += MAX_CPU_LOOPS/2;

  0140e	48 8b 84 24 00
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  01416	8b 80 98 07 00
	00		 mov	 eax, DWORD PTR [rax+1944]
  0141c	05 80 00 00 00	 add	 eax, 128		; 00000080H
  01421	48 8b 8c 24 00
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  01429	89 81 98 07 00
	00		 mov	 DWORD PTR [rcx+1944], eax

; 1336 :                 UPDATE_SYSBLK_INSTCOUNT( MAX_CPU_LOOPS/2 );

  0142f	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  01436	48 05 80 14 00
	00		 add	 rax, 5248		; 00001480H
  0143c	ba 80 00 00 00	 mov	 edx, 128		; 00000080H
  01441	48 8b c8	 mov	 rcx, rax
  01444	e8 00 00 00 00	 call	 atomic_update64

; 1337 : 
; 1338 :                 /* Perform automatic instruction tracing if it's enabled */
; 1339 :                 do_automatic_tracing();

  01449	e8 00 00 00 00	 call	 do_automatic_tracing
$LN112@s370_run_s:
$LN78@s370_run_s:
$LN68@s370_run_s:

; 1340 :             }
; 1341 :         }
; 1342 : 
; 1343 :         PTT_SIE( "run_sie !run", icode, 0, 0 );

  0144e	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_pttclass
  01455	48 8b 00	 mov	 rax, QWORD PTR [rax]
  01458	48 25 80 00 00
	00		 and	 rax, 128		; 00000080H
  0145e	48 85 c0	 test	 rax, rax
  01461	74 3b		 je	 SHORT $LN113@s370_run_s
  01463	48 63 44 24 54	 movsxd	 rax, DWORD PTR icode$[rsp]
  01468	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR [rsp+48], 0
  01471	48 c7 44 24 28
	00 00 00 00	 mov	 QWORD PTR [rsp+40], 0
  0147a	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170013
  01481	48 89 4c 24 20	 mov	 QWORD PTR [rsp+32], rcx
  01486	45 33 c9	 xor	 r9d, r9d
  01489	4c 8b c0	 mov	 r8, rax
  0148c	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG170014
  01493	b9 80 00 00 00	 mov	 ecx, 128		; 00000080H
  01498	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ptt_pthread_trace
$LN113@s370_run_s:
  0149e	33 c0		 xor	 eax, eax
  014a0	85 c0		 test	 eax, eax
  014a2	75 aa		 jne	 SHORT $LN68@s370_run_s

; 1344 : 
; 1345 :         /* Check if we should remain in, or exit from, SIE mode */
; 1346 :         if (!icode || SIE_NO_INTERCEPT == icode)

  014a4	83 7c 24 54 00	 cmp	 DWORD PTR icode$[rsp], 0
  014a9	74 0b		 je	 SHORT $LN115@s370_run_s
  014ab	83 7c 24 54 ff	 cmp	 DWORD PTR icode$[rsp], -1
  014b0	0f 85 a9 01 00
	00		 jne	 $LN114@s370_run_s
$LN115@s370_run_s:

; 1347 :         {
; 1348 :             /* Check PER first, higher priority */
; 1349 :             if (OPEN_IC_PER( GUESTREGS ))

  014b6	48 8b 84 24 00
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  014be	48 8b 80 70 08
	00 00		 mov	 rax, QWORD PTR [rax+2160]
  014c5	48 8b 8c 24 00
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  014cd	48 8b 89 70 08
	00 00		 mov	 rcx, QWORD PTR [rcx+2160]
  014d4	8b 49 4c	 mov	 ecx, DWORD PTR [rcx+76]
  014d7	8b 40 48	 mov	 eax, DWORD PTR [rax+72]
  014da	23 c1		 and	 eax, ecx
  014dc	25 00 00 ff 00	 and	 eax, 16711680		; 00ff0000H
  014e1	85 c0		 test	 eax, eax
  014e3	74 19		 je	 SHORT $LN116@s370_run_s

; 1350 :                 ARCH_DEP( program_interrupt )( GUESTREGS, PGM_PER_EVENT );

  014e5	ba 80 00 00 00	 mov	 edx, 128		; 00000080H
  014ea	48 8b 84 24 00
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  014f2	48 8b 88 70 08
	00 00		 mov	 rcx, QWORD PTR [rax+2160]
  014f9	e8 00 00 00 00	 call	 s370_program_interrupt
$LN116@s370_run_s:

; 1351 : 
; 1352 :             /* Check for SIE exit conditions... */
; 1353 : 
; 1354 :                  if (SIE_I_EXT  ( GUESTREGS )) icode = SIE_INTERCEPT_EXTREQ;

  014fe	48 8b 84 24 00
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  01506	48 8b 80 70 08
	00 00		 mov	 rax, QWORD PTR [rax+2160]
  0150d	48 8b 80 88 08
	00 00		 mov	 rax, QWORD PTR [rax+2184]
  01514	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  01517	83 e0 01	 and	 eax, 1
  0151a	85 c0		 test	 eax, eax
  0151c	74 27		 je	 SHORT $LN117@s370_run_s
  0151e	48 8b 84 24 00
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  01526	48 8b 80 70 08
	00 00		 mov	 rax, QWORD PTR [rax+2160]
  0152d	0f b6 40 78	 movzx	 eax, BYTE PTR [rax+120]
  01531	83 e0 01	 and	 eax, 1
  01534	85 c0		 test	 eax, eax
  01536	74 0d		 je	 SHORT $LN117@s370_run_s
  01538	c7 44 24 54 fa
	ff ff ff	 mov	 DWORD PTR icode$[rsp], -6
  01540	e9 1a 01 00 00	 jmp	 $LN118@s370_run_s
$LN117@s370_run_s:

; 1355 :             else if (SIE_I_IO   ( GUESTREGS )) icode = SIE_INTERCEPT_IOREQ;

  01545	48 8b 84 24 00
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0154d	48 8b 80 70 08
	00 00		 mov	 rax, QWORD PTR [rax+2160]
  01554	48 8b 80 88 08
	00 00		 mov	 rax, QWORD PTR [rax+2184]
  0155b	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  0155e	83 e0 02	 and	 eax, 2
  01561	85 c0		 test	 eax, eax
  01563	74 5d		 je	 SHORT $LN119@s370_run_s
  01565	48 8b 84 24 00
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0156d	48 8b 80 70 08
	00 00		 mov	 rax, QWORD PTR [rax+2160]
  01574	0f b6 40 7a	 movzx	 eax, BYTE PTR [rax+122]
  01578	83 e0 08	 and	 eax, 8
  0157b	85 c0		 test	 eax, eax
  0157d	74 0d		 je	 SHORT $LN155@s370_run_s
  0157f	c7 84 24 84 00
	00 00 02 00 00
	00		 mov	 DWORD PTR tv840[rsp], 2
  0158a	eb 0b		 jmp	 SHORT $LN156@s370_run_s
$LN155@s370_run_s:
  0158c	c7 84 24 84 00
	00 00 fe 00 00
	00		 mov	 DWORD PTR tv840[rsp], 254 ; 000000feH
$LN156@s370_run_s:
  01597	48 8b 84 24 00
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0159f	48 8b 80 70 08
	00 00		 mov	 rax, QWORD PTR [rax+2160]
  015a6	0f b6 40 78	 movzx	 eax, BYTE PTR [rax+120]
  015aa	23 84 24 84 00
	00 00		 and	 eax, DWORD PTR tv840[rsp]
  015b1	85 c0		 test	 eax, eax
  015b3	74 0d		 je	 SHORT $LN119@s370_run_s
  015b5	c7 44 24 54 f9
	ff ff ff	 mov	 DWORD PTR icode$[rsp], -7
  015bd	e9 9d 00 00 00	 jmp	 $LN120@s370_run_s
$LN119@s370_run_s:

; 1356 :             else if (SIE_I_STOP ( GUESTREGS )) icode = SIE_INTERCEPT_STOPREQ;

  015c2	48 8b 84 24 00
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  015ca	48 8b 80 70 08
	00 00		 mov	 rax, QWORD PTR [rax+2160]
  015d1	48 8b 80 88 08
	00 00		 mov	 rax, QWORD PTR [rax+2184]
  015d8	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  015db	83 e0 04	 and	 eax, 4
  015de	85 c0		 test	 eax, eax
  015e0	74 0a		 je	 SHORT $LN121@s370_run_s
  015e2	c7 44 24 54 f7
	ff ff ff	 mov	 DWORD PTR icode$[rsp], -9
  015ea	eb 73		 jmp	 SHORT $LN122@s370_run_s
$LN121@s370_run_s:

; 1357 :             else if (SIE_I_WAIT ( GUESTREGS )) icode = SIE_INTERCEPT_WAIT;

  015ec	48 8b 84 24 00
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  015f4	48 8b 80 70 08
	00 00		 mov	 rax, QWORD PTR [rax+2160]
  015fb	0f b6 40 7a	 movzx	 eax, BYTE PTR [rax+122]
  015ff	83 e0 02	 and	 eax, 2
  01602	85 c0		 test	 eax, eax
  01604	74 35		 je	 SHORT $LN123@s370_run_s
  01606	48 8b 84 24 00
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0160e	48 8b 80 70 08
	00 00		 mov	 rax, QWORD PTR [rax+2160]
  01615	48 8b 80 88 08
	00 00		 mov	 rax, QWORD PTR [rax+2184]
  0161c	b9 01 00 00 00	 mov	 ecx, 1
  01621	48 6b c9 00	 imul	 rcx, rcx, 0
  01625	0f b6 44 08 4c	 movzx	 eax, BYTE PTR [rax+rcx+76]
  0162a	83 e0 20	 and	 eax, 32			; 00000020H
  0162d	85 c0		 test	 eax, eax
  0162f	75 0a		 jne	 SHORT $LN123@s370_run_s
  01631	c7 44 24 54 f8
	ff ff ff	 mov	 DWORD PTR icode$[rsp], -8
  01639	eb 24		 jmp	 SHORT $LN124@s370_run_s
$LN123@s370_run_s:

; 1358 :             else if (SIE_I_HOST (   regs    )) icode = SIE_HOST_INT_PEND;

  0163b	48 8b 84 24 00
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  01643	48 8b 8c 24 00
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0164b	8b 49 4c	 mov	 ecx, DWORD PTR [rcx+76]
  0164e	8b 40 48	 mov	 eax, DWORD PTR [rax+72]
  01651	23 c1		 and	 eax, ecx
  01653	85 c0		 test	 eax, eax
  01655	74 08		 je	 SHORT $LN125@s370_run_s
  01657	c7 44 24 54 fe
	ff ff ff	 mov	 DWORD PTR icode$[rsp], -2
$LN125@s370_run_s:
$LN124@s370_run_s:
$LN122@s370_run_s:
$LN120@s370_run_s:
$LN118@s370_run_s:
$LN114@s370_run_s:
$LN71@s370_run_s:

; 1359 : 
; 1360 :             /* Otherwise we should remain in SIE mode */
; 1361 :         }
; 1362 : 
; 1363 :         PTT_SIE( "run_sie !run", icode, 0, 0 );

  0165f	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_pttclass
  01666	48 8b 00	 mov	 rax, QWORD PTR [rax]
  01669	48 25 80 00 00
	00		 and	 rax, 128		; 00000080H
  0166f	48 85 c0	 test	 rax, rax
  01672	74 3b		 je	 SHORT $LN126@s370_run_s
  01674	48 63 44 24 54	 movsxd	 rax, DWORD PTR icode$[rsp]
  01679	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR [rsp+48], 0
  01682	48 c7 44 24 28
	00 00 00 00	 mov	 QWORD PTR [rsp+40], 0
  0168b	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170028
  01692	48 89 4c 24 20	 mov	 QWORD PTR [rsp+32], rcx
  01697	45 33 c9	 xor	 r9d, r9d
  0169a	4c 8b c0	 mov	 r8, rax
  0169d	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG170029
  016a4	b9 80 00 00 00	 mov	 ecx, 128		; 00000080H
  016a9	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ptt_pthread_trace
$LN126@s370_run_s:
  016af	33 c0		 xor	 eax, eax
  016b1	85 c0		 test	 eax, eax
  016b3	75 aa		 jne	 SHORT $LN71@s370_run_s

; 1364 :     }
; 1365 :     /* Try to remain in SIE mode if possible */
; 1366 :     while (!icode || icode == SIE_NO_INTERCEPT);

  016b5	83 7c 24 54 00	 cmp	 DWORD PTR icode$[rsp], 0
  016ba	0f 84 68 ea ff
	ff		 je	 $LN10@s370_run_s
  016c0	83 7c 24 54 ff	 cmp	 DWORD PTR icode$[rsp], -1
  016c5	0f 84 5d ea ff
	ff		 je	 $LN157@s370_run_s
$LN74@s370_run_s:

; 1367 : 
; 1368 :     PTT_SIE( "run_sie ret", icode, 0, 0 );

  016cb	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_pttclass
  016d2	48 8b 00	 mov	 rax, QWORD PTR [rax]
  016d5	48 25 80 00 00
	00		 and	 rax, 128		; 00000080H
  016db	48 85 c0	 test	 rax, rax
  016de	74 3b		 je	 SHORT $LN127@s370_run_s
  016e0	48 63 44 24 54	 movsxd	 rax, DWORD PTR icode$[rsp]
  016e5	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR [rsp+48], 0
  016ee	48 c7 44 24 28
	00 00 00 00	 mov	 QWORD PTR [rsp+40], 0
  016f7	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170031
  016fe	48 89 4c 24 20	 mov	 QWORD PTR [rsp+32], rcx
  01703	45 33 c9	 xor	 r9d, r9d
  01706	4c 8b c0	 mov	 r8, rax
  01709	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG170032
  01710	b9 80 00 00 00	 mov	 ecx, 128		; 00000080H
  01715	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ptt_pthread_trace
$LN127@s370_run_s:
  0171b	33 c0		 xor	 eax, eax
  0171d	85 c0		 test	 eax, eax
  0171f	75 aa		 jne	 SHORT $LN74@s370_run_s

; 1369 : 
; 1370 :     return icode;

  01721	8b 44 24 54	 mov	 eax, DWORD PTR icode$[rsp]
$LN128@s370_run_s:

; 1371 : } /* end function run_sie */

  01725	48 8b 8c 24 e0
	00 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  0172d	48 33 cc	 xor	 rcx, rsp
  01730	e8 00 00 00 00	 call	 __security_check_cookie
  01735	48 81 c4 f8 00
	00 00		 add	 rsp, 248		; 000000f8H
  0173c	c3		 ret	 0
s370_run_sie ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\sie.h
;	COMDAT s370_GetPGSTE_and_RCPTE
_TEXT	SEGMENT
regs$ = 48
gabspage$ = 56
ppPGSTE$ = 64
ppRCPTE$ = 72
s370_GetPGSTE_and_RCPTE PROC				; COMDAT

; 516  : {

$LN7:
  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 517  : #if defined( _FEATURE_STORAGE_KEY_ASSIST )
; 518  :     if (0
; 519  :         || SIE_STATE_BIT_ON( regs, RCPO0, SKA )
; 520  : #if defined( _FEATURE_ZSIE )
; 521  :         // SKA is always active for z/VM
; 522  :         || ARCH_900_IDX == HOSTREGS->arch_mode

  00018	33 c0		 xor	 eax, eax
  0001a	85 c0		 test	 eax, eax
  0001c	75 49		 jne	 SHORT $LN4@s370_GetPG
  0001e	48 8b 44 24 30	 mov	 rax, QWORD PTR regs$[rsp]
  00023	8b 80 c8 08 00
	00		 mov	 eax, DWORD PTR [rax+2248]
  00029	d1 e8		 shr	 eax, 1
  0002b	83 e0 01	 and	 eax, 1
  0002e	85 c0		 test	 eax, eax
  00030	74 23		 je	 SHORT $LN5@s370_GetPG
  00032	48 8b 44 24 30	 mov	 rax, QWORD PTR regs$[rsp]
  00037	48 8b 80 88 08
	00 00		 mov	 rax, QWORD PTR [rax+2184]
  0003e	b9 01 00 00 00	 mov	 ecx, 1
  00043	48 6b c9 00	 imul	 rcx, rcx, 0
  00047	0f b6 44 08 60	 movzx	 eax, BYTE PTR [rax+rcx+96]
  0004c	25 80 00 00 00	 and	 eax, 128		; 00000080H
  00051	85 c0		 test	 eax, eax
  00053	75 12		 jne	 SHORT $LN4@s370_GetPG
$LN5@s370_GetPG:
  00055	48 8b 44 24 30	 mov	 rax, QWORD PTR regs$[rsp]
  0005a	48 8b 80 68 08
	00 00		 mov	 rax, QWORD PTR [rax+2152]
  00061	83 78 64 02	 cmp	 DWORD PTR [rax+100], 2
  00065	75 2c		 jne	 SHORT $LN2@s370_GetPG
$LN4@s370_GetPG:

; 523  : #endif
; 524  :     )
; 525  :     {
; 526  :         /* SKA: Get pointer to both PGSTE and RCPTE */
; 527  :         *ppPGSTE = ARCH_DEP( GetPGSTE )( regs, gabspage );

  00067	48 8b 54 24 38	 mov	 rdx, QWORD PTR gabspage$[rsp]
  0006c	48 8b 4c 24 30	 mov	 rcx, QWORD PTR regs$[rsp]
  00071	e8 00 00 00 00	 call	 s370_GetPGSTE
  00076	48 8b 4c 24 40	 mov	 rcx, QWORD PTR ppPGSTE$[rsp]
  0007b	48 89 01	 mov	 QWORD PTR [rcx], rax

; 528  :         *ppRCPTE = &(*ppPGSTE)->pgsrcp;

  0007e	48 8b 44 24 40	 mov	 rax, QWORD PTR ppPGSTE$[rsp]
  00083	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00086	48 ff c0	 inc	 rax
  00089	48 8b 4c 24 48	 mov	 rcx, QWORD PTR ppRCPTE$[rsp]
  0008e	48 89 01	 mov	 QWORD PTR [rcx], rax

; 529  :     }

  00091	eb 23		 jmp	 SHORT $LN3@s370_GetPG
$LN2@s370_GetPG:

; 530  :     else // (NOT SKA...)
; 531  : #endif /* defined( _FEATURE_STORAGE_KEY_ASSIST ) */
; 532  :     {
; 533  : #if defined( FEATURE_MULTIPLE_CONTROLLED_DATA_SPACE )
; 534  :         if (SIE_STATE_BIT_ON( regs, MX, XC ))
; 535  :             SIE_INTERCEPT( regs );
; 536  : #endif
; 537  :         /* Get just the pointer to the old RCP table byte */
; 538  :         *ppPGSTE = NULL;

  00093	48 8b 44 24 40	 mov	 rax, QWORD PTR ppPGSTE$[rsp]
  00098	48 c7 00 00 00
	00 00		 mov	 QWORD PTR [rax], 0

; 539  :         *ppRCPTE = ARCH_DEP( GetOldRCP )( regs, gabspage );

  0009f	48 8b 54 24 38	 mov	 rdx, QWORD PTR gabspage$[rsp]
  000a4	48 8b 4c 24 30	 mov	 rcx, QWORD PTR regs$[rsp]
  000a9	e8 00 00 00 00	 call	 s370_GetOldRCP
  000ae	48 8b 4c 24 48	 mov	 rcx, QWORD PTR ppRCPTE$[rsp]
  000b3	48 89 01	 mov	 QWORD PTR [rcx], rax
$LN3@s370_GetPG:

; 540  :     }
; 541  : }

  000b6	48 83 c4 28	 add	 rsp, 40			; 00000028H
  000ba	c3		 ret	 0
s370_GetPGSTE_and_RCPTE ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\sie.h
;	COMDAT s370_GetOldRCP
_TEXT	SEGMENT
rcpa$ = 48
regs$ = 80
gabspage$ = 88
s370_GetOldRCP PROC					; COMDAT

; 497  : {

$LN3:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 498  :     /* Obtain address of the RCP area from the state desc */
; 499  :     RADR rcpa = regs->sie_rcpo;

  0000e	48 8b 44 24 50	 mov	 rax, QWORD PTR regs$[rsp]
  00013	48 8b 80 b0 08
	00 00		 mov	 rax, QWORD PTR [rax+2224]
  0001a	48 89 44 24 30	 mov	 QWORD PTR rcpa$[rsp], rax

; 500  : 
; 501  :     /* Use page index as byte offset into RCP table */
; 502  :     rcpa += (gabspage >> STORKEY_KEY_4K_SHIFTAMT);

  0001f	48 8b 44 24 58	 mov	 rax, QWORD PTR gabspage$[rsp]
  00024	48 c1 e8 0c	 shr	 rax, 12
  00028	48 8b 4c 24 30	 mov	 rcx, QWORD PTR rcpa$[rsp]
  0002d	48 03 c8	 add	 rcx, rax
  00030	48 8b c1	 mov	 rax, rcx
  00033	48 89 44 24 30	 mov	 QWORD PTR rcpa$[rsp], rax

; 503  : 
; 504  :     /* Translate host primary address to host absolute */
; 505  :     rcpa = SIE_LOGICAL_TO_ABS( rcpa, USE_PRIMARY_SPACE,

  00038	48 c7 44 24 28
	01 00 00 00	 mov	 QWORD PTR [rsp+40], 1
  00041	c6 44 24 20 00	 mov	 BYTE PTR [rsp+32], 0
  00046	45 33 c9	 xor	 r9d, r9d
  00049	48 8b 44 24 50	 mov	 rax, QWORD PTR regs$[rsp]
  0004e	4c 8b 80 68 08
	00 00		 mov	 r8, QWORD PTR [rax+2152]
  00055	ba fd ff ff ff	 mov	 edx, -3
  0005a	8b 4c 24 30	 mov	 ecx, DWORD PTR rcpa$[rsp]
  0005e	e8 00 00 00 00	 call	 s390_logical_to_main_l
  00063	48 8b 44 24 50	 mov	 rax, QWORD PTR regs$[rsp]
  00068	48 8b 80 68 08
	00 00		 mov	 rax, QWORD PTR [rax+2152]
  0006f	48 8b 80 08 08
	00 00		 mov	 rax, QWORD PTR [rax+2056]
  00076	48 89 44 24 30	 mov	 QWORD PTR rcpa$[rsp], rax

; 506  :                                HOSTREGS, ACCTYPE_SIE, 0 );
; 507  : 
; 508  :     /* Return mainstor address of RCP table byte */
; 509  :     return (RCPTE*)(&regs->mainstor[ rcpa ]);

  0007b	48 8b 44 24 50	 mov	 rax, QWORD PTR regs$[rsp]
  00080	48 8b 80 48 08
	00 00		 mov	 rax, QWORD PTR [rax+2120]
  00087	48 03 44 24 30	 add	 rax, QWORD PTR rcpa$[rsp]

; 510  : }

  0008c	48 83 c4 48	 add	 rsp, 72			; 00000048H
  00090	c3		 ret	 0
s370_GetOldRCP ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\sie.h
;	COMDAT s370_GetPGSTE
_TEXT	SEGMENT
pte$ = 32
pgste$ = 40
regs$ = 64
gabspage$ = 72
s370_GetPGSTE PROC					; COMDAT

; 475  : {

$LN8:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 476  :     PGSTE*  pgste;
; 477  :     U64     pte;
; 478  : 
; 479  :     // Guest absolute to host PTE addr
; 480  :     if (SIE_TRANSLATE_ADDR( regs->sie_mso + gabspage,

  0000e	48 8b 44 24 40	 mov	 rax, QWORD PTR regs$[rsp]
  00013	48 8b 80 98 08
	00 00		 mov	 rax, QWORD PTR [rax+2200]
  0001a	48 03 44 24 48	 add	 rax, QWORD PTR gabspage$[rsp]
  0001f	41 b9 00 03 00
	00		 mov	 r9d, 768		; 00000300H
  00025	48 8b 4c 24 40	 mov	 rcx, QWORD PTR regs$[rsp]
  0002a	4c 8b 81 68 08
	00 00		 mov	 r8, QWORD PTR [rcx+2152]
  00031	ba fd ff ff ff	 mov	 edx, -3
  00036	8b c8		 mov	 ecx, eax
  00038	e8 00 00 00 00	 call	 s390_translate_addr
  0003d	85 c0		 test	 eax, eax
  0003f	74 32		 je	 SHORT $LN5@s370_GetPG
$LN4@s370_GetPG:

; 481  :                             USE_PRIMARY_SPACE,
; 482  :                             HOSTREGS, ACCTYPE_PTE ))
; 483  :         SIE_INTERCEPT( regs );

  00041	48 8b 44 24 40	 mov	 rax, QWORD PTR regs$[rsp]
  00046	8b 80 c8 08 00
	00		 mov	 eax, DWORD PTR [rax+2248]
  0004c	d1 e8		 shr	 eax, 1
  0004e	83 e0 01	 and	 eax, 1
  00051	85 c0		 test	 eax, eax
  00053	74 18		 je	 SHORT $LN6@s370_GetPG
  00055	48 8b 44 24 40	 mov	 rax, QWORD PTR regs$[rsp]
  0005a	48 05 80 09 00
	00		 add	 rax, 2432		; 00000980H
  00060	ba fc ff ff ff	 mov	 edx, -4
  00065	48 8b c8	 mov	 rcx, rax
  00068	e8 00 00 00 00	 call	 longjmp
$LN6@s370_GetPG:
  0006d	33 c0		 xor	 eax, eax
  0006f	85 c0		 test	 eax, eax
  00071	75 ce		 jne	 SHORT $LN4@s370_GetPG
$LN5@s370_GetPG:

; 484  : 
; 485  :     // Convert host real address to host absolute address
; 486  :     pte = apply_host_prefixing( HOSTREGS, HOSTREGS->dat.raddr );

  00073	48 8b 44 24 40	 mov	 rax, QWORD PTR regs$[rsp]
  00078	48 8b 80 68 08
	00 00		 mov	 rax, QWORD PTR [rax+2152]
  0007f	48 8b 90 00 08
	00 00		 mov	 rdx, QWORD PTR [rax+2048]
  00086	48 8b 44 24 40	 mov	 rax, QWORD PTR regs$[rsp]
  0008b	48 8b 88 68 08
	00 00		 mov	 rcx, QWORD PTR [rax+2152]
  00092	e8 00 00 00 00	 call	 apply_host_prefixing
  00097	48 89 44 24 20	 mov	 QWORD PTR pte$[rsp], rax

; 487  : 
; 488  :     // Convert host abs PTE to PGSTE
; 489  :     pgste = ARCH_DEP( GetPGSTEFromPTE )( regs, pte );

  0009c	48 8b 54 24 20	 mov	 rdx, QWORD PTR pte$[rsp]
  000a1	48 8b 4c 24 40	 mov	 rcx, QWORD PTR regs$[rsp]
  000a6	e8 00 00 00 00	 call	 s370_GetPGSTEFromPTE
  000ab	48 89 44 24 28	 mov	 QWORD PTR pgste$[rsp], rax

; 490  :     return pgste;

  000b0	48 8b 44 24 28	 mov	 rax, QWORD PTR pgste$[rsp]
$LN7@s370_GetPG:

; 491  : }

  000b5	48 83 c4 38	 add	 rsp, 56			; 00000038H
  000b9	c3		 ret	 0
s370_GetPGSTE ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\sie.h
;	COMDAT s370_GetPGSTEFromPTE
_TEXT	SEGMENT
tv67 = 0
pte_offset_to_pgste$ = 8
pgste$ = 16
regs$ = 48
pte$ = 56
s370_GetPGSTEFromPTE PROC				; COMDAT

; 456  : {

$LN5:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 457  :     PGSTE*  pgste;
; 458  :     size_t  pte_offset_to_pgste;
; 459  : 
; 460  :     // Calculate offset to PGSTE (depends if host is z/VM or VM/ESA)
; 461  :     pte_offset_to_pgste = (ARCH_900_IDX == HOSTREGS->arch_mode)

  0000e	48 8b 44 24 30	 mov	 rax, QWORD PTR regs$[rsp]
  00013	48 8b 80 68 08
	00 00		 mov	 rax, QWORD PTR [rax+2152]
  0001a	83 78 64 02	 cmp	 DWORD PTR [rax+100], 2
  0001e	75 0a		 jne	 SHORT $LN3@s370_GetPG
  00020	48 c7 04 24 00
	08 00 00	 mov	 QWORD PTR tv67[rsp], 2048 ; 00000800H
  00028	eb 08		 jmp	 SHORT $LN4@s370_GetPG
$LN3@s370_GetPG:
  0002a	48 c7 04 24 00
	04 00 00	 mov	 QWORD PTR tv67[rsp], 1024 ; 00000400H
$LN4@s370_GetPG:
  00032	48 8b 04 24	 mov	 rax, QWORD PTR tv67[rsp]
  00036	48 89 44 24 08	 mov	 QWORD PTR pte_offset_to_pgste$[rsp], rax

; 462  :         ? offsetof( PGMBK64, pgmpgstb )   // (z/Arch z/VM)
; 463  :         : offsetof( PGMBK,   pgmpgstb );  // (S/390 VM/ESA)
; 464  : 
; 465  :     // Return mainstor address of PGSTE
; 466  :     pgste = (PGSTE*)&regs->mainstor[ pte + pte_offset_to_pgste ];

  0003b	48 8b 44 24 08	 mov	 rax, QWORD PTR pte_offset_to_pgste$[rsp]
  00040	48 8b 4c 24 38	 mov	 rcx, QWORD PTR pte$[rsp]
  00045	48 03 c8	 add	 rcx, rax
  00048	48 8b c1	 mov	 rax, rcx
  0004b	48 8b 4c 24 30	 mov	 rcx, QWORD PTR regs$[rsp]
  00050	48 8b 89 48 08
	00 00		 mov	 rcx, QWORD PTR [rcx+2120]
  00057	48 03 c8	 add	 rcx, rax
  0005a	48 8b c1	 mov	 rax, rcx
  0005d	48 89 44 24 10	 mov	 QWORD PTR pgste$[rsp], rax

; 467  : 
; 468  :     return pgste;

  00062	48 8b 44 24 10	 mov	 rax, QWORD PTR pgste$[rsp]

; 469  : }

  00067	48 83 c4 28	 add	 rsp, 40			; 00000028H
  0006b	c3		 ret	 0
s370_GetPGSTEFromPTE ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\sie.h
;	COMDAT s370_LockUnlockKeyLock
_TEXT	SEGMENT
regs$ = 48
pgste$ = 56
rcpte$ = 64
lock$ = 72
s370_LockUnlockKeyLock PROC				; COMDAT

; 437  : {

$LN5:
  00000	44 88 4c 24 20	 mov	 BYTE PTR [rsp+32], r9b
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 438  : #if defined( OPTION_USE_SKAIP_AS_LOCK )
; 439  :     if (pgste)

  00018	48 83 7c 24 38
	00		 cmp	 QWORD PTR pgste$[rsp], 0
  0001e	74 11		 je	 SHORT $LN2@s370_LockU

; 440  :         ARCH_DEP( LockUnlockSKALock )( regs, lock );

  00020	0f b6 54 24 48	 movzx	 edx, BYTE PTR lock$[rsp]
  00025	48 8b 4c 24 30	 mov	 rcx, QWORD PTR regs$[rsp]
  0002a	e8 00 00 00 00	 call	 s370_LockUnlockSKALock
  0002f	eb 15		 jmp	 SHORT $LN3@s370_LockU
$LN2@s370_LockU:

; 441  :     else
; 442  : #endif
; 443  :         ARCH_DEP( LockUnlockRCPLock )( regs, rcpte, lock );

  00031	44 0f b6 44 24
	48		 movzx	 r8d, BYTE PTR lock$[rsp]
  00037	48 8b 54 24 40	 mov	 rdx, QWORD PTR rcpte$[rsp]
  0003c	48 8b 4c 24 30	 mov	 rcx, QWORD PTR regs$[rsp]
  00041	e8 00 00 00 00	 call	 s370_LockUnlockRCPLock
$LN3@s370_LockU:

; 444  : }

  00046	48 83 c4 28	 add	 rsp, 40			; 00000028H
  0004a	c3		 ret	 0
s370_LockUnlockKeyLock ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\sie.h
;	COMDAT s370_LockUnlockSKALock
_TEXT	SEGMENT
old$1 = 32
new$ = 33
abspage$2 = 40
regs$ = 64
lock$ = 72
s370_LockUnlockSKALock PROC				; COMDAT

; 366  : {

$LN8:
  00000	88 54 24 10	 mov	 BYTE PTR [rsp+16], dl
  00004	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00009	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 367  :     BYTE new;
; 368  : 
; 369  :     if (lock)

  0000d	0f b6 44 24 48	 movzx	 eax, BYTE PTR lock$[rsp]
  00012	85 c0		 test	 eax, eax
  00014	74 6b		 je	 SHORT $LN5@s370_LockU

; 370  :     {
; 371  :         BYTE old = regs->siebk->SIE_RCPO0;

  00016	48 8b 44 24 40	 mov	 rax, QWORD PTR regs$[rsp]
  0001b	48 8b 80 88 08
	00 00		 mov	 rax, QWORD PTR [rax+2184]
  00022	b9 01 00 00 00	 mov	 ecx, 1
  00027	48 6b c9 00	 imul	 rcx, rcx, 0
  0002b	0f b6 44 08 60	 movzx	 eax, BYTE PTR [rax+rcx+96]
  00030	88 44 24 20	 mov	 BYTE PTR old$1[rsp], al
$LN4@s370_LockU:

; 372  : 
; 373  :         // MAINLOCK may be required if cmpxchg assists unavailable
; 374  :         OBTAIN_MAINLOCK( regs );
; 375  :         {
; 376  :             // Keep looping until we eventually obtain it...
; 377  :             do
; 378  :             {
; 379  :                 old &= ~SIE_RCPO0_SKAIP;        // Want bit to be initially off

  00034	0f b6 44 24 20	 movzx	 eax, BYTE PTR old$1[rsp]
  00039	83 e0 bf	 and	 eax, -65		; ffffffffffffffbfH
  0003c	88 44 24 20	 mov	 BYTE PTR old$1[rsp], al

; 380  :                 new = (old | SIE_RCPO0_SKAIP);  // And *WE* want to turn it on!

  00040	0f b6 44 24 20	 movzx	 eax, BYTE PTR old$1[rsp]
  00045	83 c8 40	 or	 eax, 64			; 00000040H
  00048	88 44 24 21	 mov	 BYTE PTR new$[rsp], al

; 381  :             }
; 382  :             while (cmpxchg1( &old, new, &regs->siebk->SIE_RCPO0 ) != 0);

  0004c	48 8b 44 24 40	 mov	 rax, QWORD PTR regs$[rsp]
  00051	48 8b 80 88 08
	00 00		 mov	 rax, QWORD PTR [rax+2184]
  00058	b9 01 00 00 00	 mov	 ecx, 1
  0005d	48 6b c9 00	 imul	 rcx, rcx, 0
  00061	48 8d 44 08 60	 lea	 rax, QWORD PTR [rax+rcx+96]
  00066	4c 8b c0	 mov	 r8, rax
  00069	0f b6 54 24 21	 movzx	 edx, BYTE PTR new$[rsp]
  0006e	48 8d 4c 24 20	 lea	 rcx, QWORD PTR old$1[rsp]
  00073	e8 00 00 00 00	 call	 cmpxchg1_x86
  00078	0f b6 c0	 movzx	 eax, al
  0007b	85 c0		 test	 eax, eax
  0007d	75 b5		 jne	 SHORT $LN4@s370_LockU

; 383  :         }
; 384  :         RELEASE_MAINLOCK( regs );
; 385  :     }

  0007f	eb 27		 jmp	 SHORT $LN6@s370_LockU
$LN5@s370_LockU:

; 386  :     else // (unlock)
; 387  :     {
; 388  :         // Atomically 'and' the lock bit off
; 389  :         new = ~SIE_RCPO0_SKAIP;

  00081	c6 44 24 21 bf	 mov	 BYTE PTR new$[rsp], 191	; 000000bfH

; 390  :         (void) H_ATOMIC_OP( &regs->siebk->SIE_RCPO0, new, and, And, & );

  00086	48 8b 44 24 40	 mov	 rax, QWORD PTR regs$[rsp]
  0008b	48 8b 80 88 08
	00 00		 mov	 rax, QWORD PTR [rax+2184]
  00092	b9 01 00 00 00	 mov	 ecx, 1
  00097	48 6b c9 00	 imul	 rcx, rcx, 0
  0009b	48 8d 44 08 60	 lea	 rax, QWORD PTR [rax+rcx+96]
  000a0	0f b6 4c 24 21	 movzx	 ecx, BYTE PTR new$[rsp]
  000a5	f0 20 08	 lock and BYTE PTR [rax], cl
$LN6@s370_LockU:

; 391  :     }
; 392  : 
; 393  :     // Set Reference and Change bit for the byte we just modified
; 394  :     {
; 395  :         U64 abspage = (U64) (((BYTE*)regs->siebk) - regs->mainstor);

  000a8	48 8b 44 24 40	 mov	 rax, QWORD PTR regs$[rsp]
  000ad	48 8b 4c 24 40	 mov	 rcx, QWORD PTR regs$[rsp]
  000b2	48 8b 89 48 08
	00 00		 mov	 rcx, QWORD PTR [rcx+2120]
  000b9	48 8b 80 88 08
	00 00		 mov	 rax, QWORD PTR [rax+2184]
  000c0	48 2b c1	 sub	 rax, rcx
  000c3	48 89 44 24 28	 mov	 QWORD PTR abspage$2[rsp], rax

; 396  :         ARCH_DEP( or_4K_storage_key )( abspage, (STORKEY_REF | STORKEY_CHANGE) );

  000c8	b2 06		 mov	 dl, 6
  000ca	48 8b 4c 24 28	 mov	 rcx, QWORD PTR abspage$2[rsp]
  000cf	e8 00 00 00 00	 call	 s370_or_4K_storage_key

; 397  :     }
; 398  : }

  000d4	48 83 c4 38	 add	 rsp, 56			; 00000038H
  000d8	c3		 ret	 0
s370_LockUnlockSKALock ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\sie.h
;	COMDAT s370_LockUnlockRCPLock
_TEXT	SEGMENT
old$1 = 32
new$ = 33
abspage$2 = 40
regs$ = 64
rcpte$ = 72
lock$ = 80
s370_LockUnlockRCPLock PROC				; COMDAT

; 316  : {

$LN8:
  00000	44 88 44 24 18	 mov	 BYTE PTR [rsp+24], r8b
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 317  :     BYTE new;
; 318  : 
; 319  :     if (lock)

  00013	0f b6 44 24 50	 movzx	 eax, BYTE PTR lock$[rsp]
  00018	85 c0		 test	 eax, eax
  0001a	74 46		 je	 SHORT $LN5@s370_LockU

; 320  :     {
; 321  :         BYTE old = rcpte->rcpbyte;

  0001c	48 8b 44 24 48	 mov	 rax, QWORD PTR rcpte$[rsp]
  00021	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  00024	88 44 24 20	 mov	 BYTE PTR old$1[rsp], al
$LN4@s370_LockU:

; 322  : 
; 323  :         // MAINLOCK may be required if cmpxchg assists unavailable
; 324  :         OBTAIN_MAINLOCK( regs );
; 325  :         {
; 326  :             // Keep looping until we eventually obtain it...
; 327  :             do
; 328  :             {
; 329  :                 old &= ~RCPLOCK;        // Want bit to be initially off

  00028	0f b6 44 24 20	 movzx	 eax, BYTE PTR old$1[rsp]
  0002d	0f ba f0 07	 btr	 eax, 7
  00031	88 44 24 20	 mov	 BYTE PTR old$1[rsp], al

; 330  :                 new = (old | RCPLOCK);  // And *WE* want to turn it on!

  00035	0f b6 44 24 20	 movzx	 eax, BYTE PTR old$1[rsp]
  0003a	0f ba e8 07	 bts	 eax, 7
  0003e	88 44 24 21	 mov	 BYTE PTR new$[rsp], al

; 331  :             }
; 332  :             while (cmpxchg1( &old, new, &rcpte->rcpbyte ) != 0);

  00042	48 8b 44 24 48	 mov	 rax, QWORD PTR rcpte$[rsp]
  00047	4c 8b c0	 mov	 r8, rax
  0004a	0f b6 54 24 21	 movzx	 edx, BYTE PTR new$[rsp]
  0004f	48 8d 4c 24 20	 lea	 rcx, QWORD PTR old$1[rsp]
  00054	e8 00 00 00 00	 call	 cmpxchg1_x86
  00059	0f b6 c0	 movzx	 eax, al
  0005c	85 c0		 test	 eax, eax
  0005e	75 c8		 jne	 SHORT $LN4@s370_LockU

; 333  :         }
; 334  :         RELEASE_MAINLOCK( regs );
; 335  :     }

  00060	eb 12		 jmp	 SHORT $LN6@s370_LockU
$LN5@s370_LockU:

; 336  :     else // (unlock)
; 337  :     {
; 338  :         // Atomically 'and' the lock bit off
; 339  :         new = (BYTE)(~RCPLOCK);

  00062	c6 44 24 21 7f	 mov	 BYTE PTR new$[rsp], 127	; 0000007fH

; 340  :         (void) H_ATOMIC_OP( &rcpte->rcpbyte, new, and, And, & );

  00067	48 8b 44 24 48	 mov	 rax, QWORD PTR rcpte$[rsp]
  0006c	0f b6 4c 24 21	 movzx	 ecx, BYTE PTR new$[rsp]
  00071	f0 20 08	 lock and BYTE PTR [rax], cl
$LN6@s370_LockU:

; 341  :     }
; 342  : 
; 343  :     // Set Reference and Change bit for the byte we just modified
; 344  :     {
; 345  :         U64 abspage = (U64) (((BYTE*)rcpte) - regs->mainstor);

  00074	48 8b 44 24 40	 mov	 rax, QWORD PTR regs$[rsp]
  00079	48 8b 80 48 08
	00 00		 mov	 rax, QWORD PTR [rax+2120]
  00080	48 8b 4c 24 48	 mov	 rcx, QWORD PTR rcpte$[rsp]
  00085	48 2b c8	 sub	 rcx, rax
  00088	48 8b c1	 mov	 rax, rcx
  0008b	48 89 44 24 28	 mov	 QWORD PTR abspage$2[rsp], rax

; 346  :         ARCH_DEP( or_4K_storage_key )( abspage, (STORKEY_REF | STORKEY_CHANGE) );

  00090	b2 06		 mov	 dl, 6
  00092	48 8b 4c 24 28	 mov	 rcx, QWORD PTR abspage$2[rsp]
  00097	e8 00 00 00 00	 call	 s370_or_4K_storage_key

; 347  :     }
; 348  : }

  0009c	48 83 c4 38	 add	 rsp, 56			; 00000038H
  000a0	c3		 ret	 0
s370_LockUnlockRCPLock ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\sie.h
;	COMDAT s370_LockUnlockSCALock
_TEXT	SEGMENT
old$1 = 32
new$ = 33
obtained$ = 34
tv84 = 36
tv86 = 40
scabk$ = 48
abspage$2 = 56
regs$ = 80
lock$ = 88
trylock$ = 96
s370_LockUnlockSCALock PROC				; COMDAT

; 255  : {

$LN13:
  00000	44 88 44 24 18	 mov	 BYTE PTR [rsp+24], r8b
  00005	88 54 24 10	 mov	 BYTE PTR [rsp+16], dl
  00009	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000e	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 256  :     BYTE new;
; 257  :     bool obtained = false;

  00012	c6 44 24 22 00	 mov	 BYTE PTR obtained$[rsp], 0

; 258  :     SCABK* scabk = (SCABK*) &regs->mainstor[ regs->sie_scao ];

  00017	48 8b 44 24 50	 mov	 rax, QWORD PTR regs$[rsp]
  0001c	48 8b 80 48 08
	00 00		 mov	 rax, QWORD PTR [rax+2120]
  00023	48 8b 4c 24 50	 mov	 rcx, QWORD PTR regs$[rsp]
  00028	48 03 81 b8 08
	00 00		 add	 rax, QWORD PTR [rcx+2232]
  0002f	48 89 44 24 30	 mov	 QWORD PTR scabk$[rsp], rax

; 259  : 
; 260  :     if (lock)

  00034	0f b6 44 24 58	 movzx	 eax, BYTE PTR lock$[rsp]
  00039	85 c0		 test	 eax, eax
  0003b	0f 84 8c 00 00
	00		 je	 $LN5@s370_LockU

; 261  :     {
; 262  :         BYTE old = scabk->scaiplk0;

  00041	48 8b 44 24 30	 mov	 rax, QWORD PTR scabk$[rsp]
  00046	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  00049	88 44 24 20	 mov	 BYTE PTR old$1[rsp], al
$LN4@s370_LockU:

; 263  : 
; 264  :         // MAINLOCK may be required if cmpxchg assists unavailable
; 265  :         OBTAIN_MAINLOCK( regs );
; 266  :         {
; 267  :             // If not TRY call, keep looping until we obtain it.
; 268  :             // Otherwise TRY just once, and return success or not.
; 269  :             do
; 270  :             {
; 271  :                 old &= ~SCAIPLKH;       // Want bit to be initially off

  0004d	0f b6 44 24 20	 movzx	 eax, BYTE PTR old$1[rsp]
  00052	0f ba f0 07	 btr	 eax, 7
  00056	88 44 24 20	 mov	 BYTE PTR old$1[rsp], al

; 272  :                 new = (old | SCAIPLKH); // And *WE* want to turn it on!

  0005a	0f b6 44 24 20	 movzx	 eax, BYTE PTR old$1[rsp]
  0005f	0f ba e8 07	 bts	 eax, 7
  00063	88 44 24 21	 mov	 BYTE PTR new$[rsp], al

; 273  :             }
; 274  :             while (!(obtained = (0 == cmpxchg1( &old, new, &scabk->scaiplk0 ))) && !trylock);

  00067	48 8b 44 24 30	 mov	 rax, QWORD PTR scabk$[rsp]
  0006c	4c 8b c0	 mov	 r8, rax
  0006f	0f b6 54 24 21	 movzx	 edx, BYTE PTR new$[rsp]
  00074	48 8d 4c 24 20	 lea	 rcx, QWORD PTR old$1[rsp]
  00079	e8 00 00 00 00	 call	 cmpxchg1_x86
  0007e	0f b6 c0	 movzx	 eax, al
  00081	85 c0		 test	 eax, eax
  00083	75 0a		 jne	 SHORT $LN9@s370_LockU
  00085	c7 44 24 24 01
	00 00 00	 mov	 DWORD PTR tv84[rsp], 1
  0008d	eb 08		 jmp	 SHORT $LN10@s370_LockU
$LN9@s370_LockU:
  0008f	c7 44 24 24 00
	00 00 00	 mov	 DWORD PTR tv84[rsp], 0
$LN10@s370_LockU:
  00097	83 7c 24 24 00	 cmp	 DWORD PTR tv84[rsp], 0
  0009c	75 0a		 jne	 SHORT $LN11@s370_LockU
  0009e	c7 44 24 28 00
	00 00 00	 mov	 DWORD PTR tv86[rsp], 0
  000a6	eb 08		 jmp	 SHORT $LN12@s370_LockU
$LN11@s370_LockU:
  000a8	c7 44 24 28 01
	00 00 00	 mov	 DWORD PTR tv86[rsp], 1
$LN12@s370_LockU:
  000b0	0f b6 44 24 28	 movzx	 eax, BYTE PTR tv86[rsp]
  000b5	88 44 24 22	 mov	 BYTE PTR obtained$[rsp], al
  000b9	0f b6 44 24 22	 movzx	 eax, BYTE PTR obtained$[rsp]
  000be	85 c0		 test	 eax, eax
  000c0	75 09		 jne	 SHORT $LN7@s370_LockU
  000c2	0f b6 44 24 60	 movzx	 eax, BYTE PTR trylock$[rsp]
  000c7	85 c0		 test	 eax, eax
  000c9	74 82		 je	 SHORT $LN4@s370_LockU
$LN7@s370_LockU:

; 275  :         }
; 276  :         RELEASE_MAINLOCK( regs );
; 277  :     }

  000cb	eb 12		 jmp	 SHORT $LN6@s370_LockU
$LN5@s370_LockU:

; 278  :     else // (unlock)
; 279  :     {
; 280  :         // Atomically 'and' the lock bit off
; 281  :         new = (BYTE)(~SCAIPLKH);

  000cd	c6 44 24 21 7f	 mov	 BYTE PTR new$[rsp], 127	; 0000007fH

; 282  :         (void) H_ATOMIC_OP( &scabk->scaiplk0, new, and, And, & );

  000d2	48 8b 44 24 30	 mov	 rax, QWORD PTR scabk$[rsp]
  000d7	0f b6 4c 24 21	 movzx	 ecx, BYTE PTR new$[rsp]
  000dc	f0 20 08	 lock and BYTE PTR [rax], cl
$LN6@s370_LockU:

; 283  :     }
; 284  : 
; 285  :     // Set Reference and Change bit for the byte we just modified
; 286  :     {
; 287  :         U64 abspage = (U64) (&scabk->scaiplk0 - regs->mainstor);

  000df	48 8b 44 24 30	 mov	 rax, QWORD PTR scabk$[rsp]
  000e4	48 8b 4c 24 50	 mov	 rcx, QWORD PTR regs$[rsp]
  000e9	48 2b 81 48 08
	00 00		 sub	 rax, QWORD PTR [rcx+2120]
  000f0	48 89 44 24 38	 mov	 QWORD PTR abspage$2[rsp], rax

; 288  :         ARCH_DEP( or_4K_storage_key )( abspage, (STORKEY_REF | STORKEY_CHANGE) );

  000f5	b2 06		 mov	 dl, 6
  000f7	48 8b 4c 24 38	 mov	 rcx, QWORD PTR abspage$2[rsp]
  000fc	e8 00 00 00 00	 call	 s370_or_4K_storage_key

; 289  :     }
; 290  : 
; 291  :     return obtained;

  00101	0f b6 44 24 22	 movzx	 eax, BYTE PTR obtained$[rsp]

; 292  : }

  00106	48 83 c4 48	 add	 rsp, 72			; 00000048H
  0010a	c3		 ret	 0
s370_LockUnlockSCALock ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\vstore.h
;	COMDAT s370_instfetch
_TEXT	SEGMENT
addr$ = 48
pagesz$ = 52
ip$ = 56
offset$ = 64
len$ = 68
tv76 = 72
tv78 = 76
tv129 = 80
tv131 = 84
tv138 = 88
tv157 = 92
tv174 = 96
tv215 = 100
tv214 = 104
tv216 = 108
tv272 = 112
tv273 = 116
dest$ = 120
tv279 = 128
regs$ = 160
exec$ = 168
s370_instfetch PROC					; COMDAT

; 777  : {

$LN68:
  00000	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00004	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00009	48 81 ec 98 00
	00 00		 sub	 rsp, 152		; 00000098H

; 778  : VADR    addr;                           /* Instruction address       */
; 779  : BYTE*   ip;                             /* Instruction pointer       */
; 780  : BYTE*   dest;                           /* Fetched Instruction       */
; 781  : int     pagesz;                         /* Effective page size       */
; 782  : int     offset;                         /* Address offset into page  */
; 783  : int     len;                            /* Length for page crossing  */
; 784  : 
; 785  :     addr = exec ? regs->ET : VALID_AIE( regs ) ?

  00010	83 bc 24 a8 00
	00 00 00	 cmp	 DWORD PTR exec$[rsp], 0
  00018	74 14		 je	 SHORT $LN36@s370_instf
  0001a	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00022	8b 80 20 07 00
	00		 mov	 eax, DWORD PTR [rax+1824]
  00028	89 44 24 4c	 mov	 DWORD PTR tv78[rsp], eax
  0002c	eb 67		 jmp	 SHORT $LN37@s370_instf
$LN36@s370_instf:
  0002e	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00036	48 83 b8 08 02
	00 00 00	 cmp	 QWORD PTR [rax+520], 0
  0003e	74 3b		 je	 SHORT $LN34@s370_instf
  00040	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00048	8b 80 10 02 00
	00		 mov	 eax, DWORD PTR [rax+528]
  0004e	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00056	48 8b 94 24 a0
	00 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  0005e	48 8b 92 00 02
	00 00		 mov	 rdx, QWORD PTR [rdx+512]
  00065	48 8b 49 68	 mov	 rcx, QWORD PTR [rcx+104]
  00069	48 2b ca	 sub	 rcx, rdx
  0006c	48 03 c1	 add	 rax, rcx
  0006f	48 25 ff ff ff
	00		 and	 rax, 16777215		; 00ffffffH
  00075	89 44 24 48	 mov	 DWORD PTR tv76[rsp], eax
  00079	eb 12		 jmp	 SHORT $LN35@s370_instf
$LN34@s370_instf:
  0007b	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00083	8b 80 88 00 00
	00		 mov	 eax, DWORD PTR [rax+136]
  00089	89 44 24 48	 mov	 DWORD PTR tv76[rsp], eax
$LN35@s370_instf:
  0008d	8b 44 24 48	 mov	 eax, DWORD PTR tv76[rsp]
  00091	89 44 24 4c	 mov	 DWORD PTR tv78[rsp], eax
$LN37@s370_instf:
  00095	8b 44 24 4c	 mov	 eax, DWORD PTR tv78[rsp]
  00099	89 44 24 30	 mov	 DWORD PTR addr$[rsp], eax

; 786  :         PSW_IA_FROM_IP( regs, 0 ) : regs->psw.IA;
; 787  : 
; 788  :     /* Ensure PSW IA matches the instruction we're fetching */
; 789  :     if (!exec)

  0009d	83 bc 24 a8 00
	00 00 00	 cmp	 DWORD PTR exec$[rsp], 0
  000a5	75 5b		 jne	 SHORT $LN14@s370_instf
$LN4@s370_instf:

; 790  :         MAYBE_SET_PSW_IA_FROM_IP( regs );

  000a7	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  000af	48 83 b8 08 02
	00 00 00	 cmp	 QWORD PTR [rax+520], 0
  000b7	74 43		 je	 SHORT $LN15@s370_instf
  000b9	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  000c1	8b 80 10 02 00
	00		 mov	 eax, DWORD PTR [rax+528]
  000c7	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  000cf	48 8b 94 24 a0
	00 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  000d7	48 8b 92 00 02
	00 00		 mov	 rdx, QWORD PTR [rdx+512]
  000de	48 8b 49 68	 mov	 rcx, QWORD PTR [rcx+104]
  000e2	48 2b ca	 sub	 rcx, rdx
  000e5	48 03 c1	 add	 rax, rcx
  000e8	48 25 ff ff ff
	00		 and	 rax, 16777215		; 00ffffffH
  000ee	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  000f6	89 81 88 00 00
	00		 mov	 DWORD PTR [rcx+136], eax
$LN15@s370_instf:
  000fc	33 c0		 xor	 eax, eax
  000fe	85 c0		 test	 eax, eax
  00100	75 a5		 jne	 SHORT $LN4@s370_instf
$LN14@s370_instf:

; 791  : 
; 792  :     offset = (int)(addr & PAGEFRAME_BYTEMASK);

  00102	8b 44 24 30	 mov	 eax, DWORD PTR addr$[rsp]
  00106	25 ff 07 00 00	 and	 eax, 2047		; 000007ffH
  0010b	89 44 24 40	 mov	 DWORD PTR offset$[rsp], eax

; 793  : 
; 794  :     pagesz = unlikely( addr < 0x800 ) ? 0x800 : PAGEFRAME_PAGESIZE;

  0010f	81 7c 24 30 00
	08 00 00	 cmp	 DWORD PTR addr$[rsp], 2048 ; 00000800H
  00117	73 0a		 jae	 SHORT $LN40@s370_instf
  00119	c7 44 24 50 01
	00 00 00	 mov	 DWORD PTR tv129[rsp], 1
  00121	eb 08		 jmp	 SHORT $LN41@s370_instf
$LN40@s370_instf:
  00123	c7 44 24 50 00
	00 00 00	 mov	 DWORD PTR tv129[rsp], 0
$LN41@s370_instf:
  0012b	83 7c 24 50 00	 cmp	 DWORD PTR tv129[rsp], 0
  00130	74 0a		 je	 SHORT $LN42@s370_instf
  00132	c7 44 24 54 00
	08 00 00	 mov	 DWORD PTR tv131[rsp], 2048 ; 00000800H
  0013a	eb 08		 jmp	 SHORT $LN43@s370_instf
$LN42@s370_instf:
  0013c	c7 44 24 54 00
	08 00 00	 mov	 DWORD PTR tv131[rsp], 2048 ; 00000800H
$LN43@s370_instf:
  00144	8b 44 24 54	 mov	 eax, DWORD PTR tv131[rsp]
  00148	89 44 24 34	 mov	 DWORD PTR pagesz$[rsp], eax

; 795  : 
; 796  :     /* Program check if instruction address is odd */
; 797  :     if (unlikely( offset & 0x01 ))

  0014c	8b 44 24 40	 mov	 eax, DWORD PTR offset$[rsp]
  00150	83 e0 01	 and	 eax, 1
  00153	85 c0		 test	 eax, eax
  00155	74 0a		 je	 SHORT $LN46@s370_instf
  00157	c7 44 24 58 01
	00 00 00	 mov	 DWORD PTR tv138[rsp], 1
  0015f	eb 08		 jmp	 SHORT $LN47@s370_instf
$LN46@s370_instf:
  00161	c7 44 24 58 00
	00 00 00	 mov	 DWORD PTR tv138[rsp], 0
$LN47@s370_instf:
  00169	83 7c 24 58 00	 cmp	 DWORD PTR tv138[rsp], 0
  0016e	74 44		 je	 SHORT $LN16@s370_instf

; 798  :     {
; 799  :         if (!exec)

  00170	83 bc 24 a8 00
	00 00 00	 cmp	 DWORD PTR exec$[rsp], 0
  00178	75 1f		 jne	 SHORT $LN17@s370_instf

; 800  :             regs->instinvalid = 1;

  0017a	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00182	8b 80 28 07 00
	00		 mov	 eax, DWORD PTR [rax+1832]
  00188	83 c8 08	 or	 eax, 8
  0018b	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00193	89 81 28 07 00
	00		 mov	 DWORD PTR [rcx+1832], eax
$LN17@s370_instf:

; 801  : 
; 802  :         regs->program_interrupt( regs, PGM_SPECIFICATION_EXCEPTION );

  00199	ba 06 00 00 00	 mov	 edx, 6
  0019e	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  001a6	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  001ae	ff 90 20 0d 00
	00		 call	 QWORD PTR [rax+3360]
$LN16@s370_instf:

; 803  :     }
; 804  : 
; 805  : #if defined( FEATURE_PER )
; 806  : 
; 807  :     /* Save the address used to fetch the instruction */
; 808  :     if (EN_IC_PER( regs ))

  001b4	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  001bc	8b 80 28 07 00
	00		 mov	 eax, DWORD PTR [rax+1832]
  001c2	c1 e8 02	 shr	 eax, 2
  001c5	83 e0 01	 and	 eax, 1
  001c8	85 c0		 test	 eax, eax
  001ca	74 0a		 je	 SHORT $LN50@s370_instf
  001cc	c7 44 24 5c 01
	00 00 00	 mov	 DWORD PTR tv157[rsp], 1
  001d4	eb 08		 jmp	 SHORT $LN51@s370_instf
$LN50@s370_instf:
  001d6	c7 44 24 5c 00
	00 00 00	 mov	 DWORD PTR tv157[rsp], 0
$LN51@s370_instf:
  001de	83 7c 24 5c 00	 cmp	 DWORD PTR tv157[rsp], 0
  001e3	0f 84 9d 02 00
	00		 je	 $LN18@s370_instf

; 809  :     {
; 810  : #if defined( FEATURE_PER2 )
; 811  :         regs->perc = 0x40    /* ATMID-validity */
; 812  :                    | (regs->psw.amode64        << 7 )
; 813  :                    | (regs->psw.amode          << 5 )
; 814  :                    | (!REAL_MODE( &regs->psw ) ? 0x10 : 0 )
; 815  :                    | (SPACE_BIT(  &regs->psw ) << 3 )
; 816  :                    | (AR_BIT   (  &regs->psw ) << 2 );
; 817  : #else
; 818  :         regs->perc = 0;

  001e9	33 c0		 xor	 eax, eax
  001eb	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  001f3	66 89 81 d0 08
	00 00		 mov	 WORD PTR [rcx+2256], ax

; 819  : #endif /* defined( FEATURE_PER2 ) */
; 820  : 
; 821  :         if (!exec)

  001fa	83 bc 24 a8 00
	00 00 00	 cmp	 DWORD PTR exec$[rsp], 0
  00202	75 13		 jne	 SHORT $LN19@s370_instf

; 822  :             regs->peradr = addr;

  00204	8b 44 24 30	 mov	 eax, DWORD PTR addr$[rsp]
  00208	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00210	48 89 81 d8 08
	00 00		 mov	 QWORD PTR [rcx+2264], rax
$LN19@s370_instf:

; 823  : 
; 824  :         /* Test for PER instruction-fetching event */
; 825  :         if (1
; 826  :             && EN_IC_PER_IF( regs )
; 827  :             && PER_RANGE_CHECK( addr, regs->CR(10), regs->CR(11) )

  00217	33 c0		 xor	 eax, eax
  00219	83 f8 01	 cmp	 eax, 1
  0021c	0f 84 75 01 00
	00		 je	 $LN20@s370_instf
  00222	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0022a	8b 80 28 07 00
	00		 mov	 eax, DWORD PTR [rax+1832]
  00230	c1 e8 02	 shr	 eax, 2
  00233	83 e0 01	 and	 eax, 1
  00236	85 c0		 test	 eax, eax
  00238	74 0a		 je	 SHORT $LN54@s370_instf
  0023a	c7 44 24 60 01
	00 00 00	 mov	 DWORD PTR tv174[rsp], 1
  00242	eb 08		 jmp	 SHORT $LN55@s370_instf
$LN54@s370_instf:
  00244	c7 44 24 60 00
	00 00 00	 mov	 DWORD PTR tv174[rsp], 0
$LN55@s370_instf:
  0024c	83 7c 24 60 00	 cmp	 DWORD PTR tv174[rsp], 0
  00251	0f 84 40 01 00
	00		 je	 $LN20@s370_instf
  00257	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0025f	8b 40 48	 mov	 eax, DWORD PTR [rax+72]
  00262	25 00 00 40 00	 and	 eax, 4194304		; 00400000H
  00267	85 c0		 test	 eax, eax
  00269	0f 84 28 01 00
	00		 je	 $LN20@s370_instf
  0026f	b8 08 00 00 00	 mov	 eax, 8
  00274	48 6b c0 0c	 imul	 rax, rax, 12
  00278	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00280	8b 84 01 00 06
	00 00		 mov	 eax, DWORD PTR [rcx+rax+1536]
  00287	25 ff ff ff 00	 and	 eax, 16777215		; 00ffffffH
  0028c	b9 08 00 00 00	 mov	 ecx, 8
  00291	48 6b c9 0b	 imul	 rcx, rcx, 11
  00295	48 8b 94 24 a0
	00 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  0029d	8b 8c 0a 00 06
	00 00		 mov	 ecx, DWORD PTR [rdx+rcx+1536]
  002a4	81 e1 ff ff ff
	00		 and	 ecx, 16777215		; 00ffffffH
  002aa	3b c1		 cmp	 eax, ecx
  002ac	72 62		 jb	 SHORT $LN60@s370_instf
  002ae	b8 08 00 00 00	 mov	 eax, 8
  002b3	48 6b c0 0b	 imul	 rax, rax, 11
  002b7	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  002bf	8b 84 01 00 06
	00 00		 mov	 eax, DWORD PTR [rcx+rax+1536]
  002c6	25 ff ff ff 00	 and	 eax, 16777215		; 00ffffffH
  002cb	39 44 24 30	 cmp	 DWORD PTR addr$[rsp], eax
  002cf	72 2d		 jb	 SHORT $LN56@s370_instf
  002d1	b8 08 00 00 00	 mov	 eax, 8
  002d6	48 6b c0 0c	 imul	 rax, rax, 12
  002da	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  002e2	8b 84 01 00 06
	00 00		 mov	 eax, DWORD PTR [rcx+rax+1536]
  002e9	25 ff ff ff 00	 and	 eax, 16777215		; 00ffffffH
  002ee	39 44 24 30	 cmp	 DWORD PTR addr$[rsp], eax
  002f2	77 0a		 ja	 SHORT $LN56@s370_instf
  002f4	c7 44 24 64 01
	00 00 00	 mov	 DWORD PTR tv215[rsp], 1
  002fc	eb 08		 jmp	 SHORT $LN59@s370_instf
$LN56@s370_instf:
  002fe	c7 44 24 64 00
	00 00 00	 mov	 DWORD PTR tv215[rsp], 0
$LN59@s370_instf:
  00306	8b 44 24 64	 mov	 eax, DWORD PTR tv215[rsp]
  0030a	89 44 24 6c	 mov	 DWORD PTR tv216[rsp], eax
  0030e	eb 60		 jmp	 SHORT $LN61@s370_instf
$LN60@s370_instf:
  00310	b8 08 00 00 00	 mov	 eax, 8
  00315	48 6b c0 0b	 imul	 rax, rax, 11
  00319	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00321	8b 84 01 00 06
	00 00		 mov	 eax, DWORD PTR [rcx+rax+1536]
  00328	25 ff ff ff 00	 and	 eax, 16777215		; 00ffffffH
  0032d	39 44 24 30	 cmp	 DWORD PTR addr$[rsp], eax
  00331	73 2d		 jae	 SHORT $LN57@s370_instf
  00333	b8 08 00 00 00	 mov	 eax, 8
  00338	48 6b c0 0c	 imul	 rax, rax, 12
  0033c	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00344	8b 84 01 00 06
	00 00		 mov	 eax, DWORD PTR [rcx+rax+1536]
  0034b	25 ff ff ff 00	 and	 eax, 16777215		; 00ffffffH
  00350	39 44 24 30	 cmp	 DWORD PTR addr$[rsp], eax
  00354	76 0a		 jbe	 SHORT $LN57@s370_instf
  00356	c7 44 24 68 00
	00 00 00	 mov	 DWORD PTR tv214[rsp], 0
  0035e	eb 08		 jmp	 SHORT $LN58@s370_instf
$LN57@s370_instf:
  00360	c7 44 24 68 01
	00 00 00	 mov	 DWORD PTR tv214[rsp], 1
$LN58@s370_instf:
  00368	8b 44 24 68	 mov	 eax, DWORD PTR tv214[rsp]
  0036c	89 44 24 6c	 mov	 DWORD PTR tv216[rsp], eax
$LN61@s370_instf:
  00370	83 7c 24 6c 00	 cmp	 DWORD PTR tv216[rsp], 0
  00375	74 20		 je	 SHORT $LN20@s370_instf
$LN7@s370_instf:

; 828  :         )
; 829  :         {
; 830  :             ON_IC_PER_IF( regs );

  00377	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0037f	8b 40 4c	 mov	 eax, DWORD PTR [rax+76]
  00382	0f ba e8 16	 bts	 eax, 22
  00386	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0038e	89 41 4c	 mov	 DWORD PTR [rcx+76], eax
  00391	33 c0		 xor	 eax, eax
  00393	85 c0		 test	 eax, eax
  00395	75 e0		 jne	 SHORT $LN7@s370_instf
$LN20@s370_instf:

; 831  : 
; 832  : #if defined( FEATURE_PER3 )
; 833  :             /* If CR9_IFNUL (PER instruction-fetching nullification) is
; 834  :                set, take a program check immediately, without executing
; 835  :                the instruction or updating the PSW instruction address */
; 836  :             if (EN_IC_PER_IFNUL( regs ))
; 837  :             {
; 838  :                 ON_IC_PER_IFNUL( regs );
; 839  :                 regs->psw.IA = addr;
; 840  :                 regs->psw.zeroilc = 1;
; 841  :                 regs->program_interrupt( regs, PGM_PER_EVENT );
; 842  :             }
; 843  : #endif /* defined( FEATURE_PER3 ) */
; 844  :         }
; 845  : 
; 846  :         /* Quick exit if AIA is still valid */
; 847  :         if (1
; 848  :             && !exec
; 849  :             && !regs->breakortrace
; 850  :             &&  VALID_AIE( regs )
; 851  :             &&  regs->ip < (regs->aip + pagesz - 5)

  00397	33 c0		 xor	 eax, eax
  00399	83 f8 01	 cmp	 eax, 1
  0039c	0f 84 e4 00 00
	00		 je	 $LN21@s370_instf
  003a2	83 bc 24 a8 00
	00 00 00	 cmp	 DWORD PTR exec$[rsp], 0
  003aa	0f 85 d6 00 00
	00		 jne	 $LN21@s370_instf
  003b0	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  003b8	8b 80 28 07 00
	00		 mov	 eax, DWORD PTR [rax+1832]
  003be	c1 e8 10	 shr	 eax, 16
  003c1	83 e0 01	 and	 eax, 1
  003c4	85 c0		 test	 eax, eax
  003c6	0f 85 ba 00 00
	00		 jne	 $LN21@s370_instf
  003cc	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  003d4	48 83 b8 08 02
	00 00 00	 cmp	 QWORD PTR [rax+520], 0
  003dc	0f 84 a4 00 00
	00		 je	 $LN21@s370_instf
  003e2	48 63 44 24 34	 movsxd	 rax, DWORD PTR pagesz$[rsp]
  003e7	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  003ef	48 8b 89 00 02
	00 00		 mov	 rcx, QWORD PTR [rcx+512]
  003f6	48 8d 44 01 fb	 lea	 rax, QWORD PTR [rcx+rax-5]
  003fb	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00403	48 39 41 68	 cmp	 QWORD PTR [rcx+104], rax
  00407	73 7d		 jae	 SHORT $LN21@s370_instf

; 852  :         )
; 853  :         {
; 854  : #if defined( FEATURE_073_TRANSACT_EXEC_FACILITY )
; 855  : 
; 856  :             /* Update CONSTRAINED trans instruction fetch constraint */
; 857  :             if (regs->txf_contran)
; 858  :             {
; 859  :                 if (regs->AIV == regs->txf_aie_aiv2)
; 860  :                     regs->txf_aie = regs->aip + regs->txf_aie_off2;
; 861  :             }
; 862  : 
; 863  :             TXF_INSTRADDR_CONSTRAINT( regs );
; 864  : 
; 865  : #endif /* defined( FEATURE_073_TRANSACT_EXEC_FACILITY ) */
; 866  : 
; 867  :             /* Save the address of the instruction ABOUT to be executed */
; 868  :             regs->periaddr = PSW_IA_FROM_IP( regs, 0 );

  00409	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00411	8b 80 10 02 00
	00		 mov	 eax, DWORD PTR [rax+528]
  00417	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0041f	48 8b 94 24 a0
	00 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  00427	48 8b 92 00 02
	00 00		 mov	 rdx, QWORD PTR [rdx+512]
  0042e	48 8b 49 68	 mov	 rcx, QWORD PTR [rcx+104]
  00432	48 2b ca	 sub	 rcx, rdx
  00435	48 03 c1	 add	 rax, rcx
  00438	48 25 ff ff ff
	00		 and	 rax, 16777215		; 00ffffffH
  0043e	8b c0		 mov	 eax, eax
  00440	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00448	48 89 81 e8 08
	00 00		 mov	 QWORD PTR [rcx+2280], rax

; 869  : 
; 870  :             /* Suppress PER instruction fetch event if appropriate */
; 871  :             if (IS_PER_SUPRESS( regs, CR9_IF ))

  0044f	33 c0		 xor	 eax, eax
  00451	85 c0		 test	 eax, eax
  00453	74 20		 je	 SHORT $LN22@s370_instf
$LN10@s370_instf:

; 872  :                 OFF_IC_PER_IF( regs );

  00455	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0045d	8b 40 4c	 mov	 eax, DWORD PTR [rax+76]
  00460	0f ba f0 16	 btr	 eax, 22
  00464	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0046c	89 41 4c	 mov	 DWORD PTR [rcx+76], eax
  0046f	33 c0		 xor	 eax, eax
  00471	85 c0		 test	 eax, eax
  00473	75 e0		 jne	 SHORT $LN10@s370_instf
$LN22@s370_instf:

; 873  : 
; 874  :             /* Return to caller to execute this instruction */
; 875  :             return regs->ip;

  00475	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0047d	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  00481	e9 1a 03 00 00	 jmp	 $LN1@s370_instf
$LN21@s370_instf:
$LN18@s370_instf:

; 876  :         }
; 877  :     }
; 878  : #endif /* defined( FEATURE_PER ) */
; 879  : 
; 880  :     /* Set instinvalid in case of addressing or translation exception */
; 881  :     if (!exec)

  00486	83 bc 24 a8 00
	00 00 00	 cmp	 DWORD PTR exec$[rsp], 0
  0048e	75 1f		 jne	 SHORT $LN23@s370_instf

; 882  :         regs->instinvalid = 1;

  00490	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00498	8b 80 28 07 00
	00		 mov	 eax, DWORD PTR [rax+1832]
  0049e	83 c8 08	 or	 eax, 8
  004a1	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  004a9	89 81 28 07 00
	00		 mov	 DWORD PTR [rcx+1832], eax
$LN23@s370_instf:

; 883  : 
; 884  :     /* Get instruction address */
; 885  :     ip = MADDRL( addr, 6, USE_INST_SPACE, regs, ACCTYPE_INSTFETCH, regs->psw.pkey );

  004af	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  004b7	0f b6 40 79	 movzx	 eax, BYTE PTR [rax+121]
  004bb	88 44 24 28	 mov	 BYTE PTR [rsp+40], al
  004bf	c7 44 24 20 04
	00 00 00	 mov	 DWORD PTR [rsp+32], 4
  004c7	4c 8b 8c 24 a0
	00 00 00	 mov	 r9, QWORD PTR regs$[rsp]
  004cf	41 b8 ff ff ff
	ff		 mov	 r8d, -1
  004d5	ba 06 00 00 00	 mov	 edx, 6
  004da	8b 4c 24 30	 mov	 ecx, DWORD PTR addr$[rsp]
  004de	e8 00 00 00 00	 call	 s370_maddr_l
  004e3	48 89 44 24 38	 mov	 QWORD PTR ip$[rsp], rax

; 886  : 
; 887  :     /* If boundary is crossed then copy instruction to destination */
; 888  :     if (offset + ILC( ip[0] ) > pagesz)

  004e8	b8 01 00 00 00	 mov	 eax, 1
  004ed	48 6b c0 00	 imul	 rax, rax, 0
  004f1	48 8b 4c 24 38	 mov	 rcx, QWORD PTR ip$[rsp]
  004f6	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  004fa	83 f8 40	 cmp	 eax, 64			; 00000040H
  004fd	7d 0a		 jge	 SHORT $LN64@s370_instf
  004ff	c7 44 24 74 02
	00 00 00	 mov	 DWORD PTR tv273[rsp], 2
  00507	eb 33		 jmp	 SHORT $LN65@s370_instf
$LN64@s370_instf:
  00509	b8 01 00 00 00	 mov	 eax, 1
  0050e	48 6b c0 00	 imul	 rax, rax, 0
  00512	48 8b 4c 24 38	 mov	 rcx, QWORD PTR ip$[rsp]
  00517	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  0051b	3d c0 00 00 00	 cmp	 eax, 192		; 000000c0H
  00520	7d 0a		 jge	 SHORT $LN62@s370_instf
  00522	c7 44 24 70 04
	00 00 00	 mov	 DWORD PTR tv272[rsp], 4
  0052a	eb 08		 jmp	 SHORT $LN63@s370_instf
$LN62@s370_instf:
  0052c	c7 44 24 70 06
	00 00 00	 mov	 DWORD PTR tv272[rsp], 6
$LN63@s370_instf:
  00534	8b 44 24 70	 mov	 eax, DWORD PTR tv272[rsp]
  00538	89 44 24 74	 mov	 DWORD PTR tv273[rsp], eax
$LN65@s370_instf:
  0053c	8b 44 24 74	 mov	 eax, DWORD PTR tv273[rsp]
  00540	8b 4c 24 40	 mov	 ecx, DWORD PTR offset$[rsp]
  00544	03 c8		 add	 ecx, eax
  00546	8b c1		 mov	 eax, ecx
  00548	3b 44 24 34	 cmp	 eax, DWORD PTR pagesz$[rsp]
  0054c	0f 8e ed 00 00
	00		 jle	 $LN24@s370_instf

; 889  :     {
; 890  :         /* Copy first part of instruction (note: dest is 8 bytes) */
; 891  :         dest = exec ? regs->exinst : regs->inst;

  00552	83 bc 24 a8 00
	00 00 00	 cmp	 DWORD PTR exec$[rsp], 0
  0055a	74 18		 je	 SHORT $LN66@s370_instf
  0055c	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00564	48 05 40 08 00
	00		 add	 rax, 2112		; 00000840H
  0056a	48 89 84 24 80
	00 00 00	 mov	 QWORD PTR tv279[rsp], rax
  00572	eb 16		 jmp	 SHORT $LN67@s370_instf
$LN66@s370_instf:
  00574	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0057c	48 05 f1 08 00
	00		 add	 rax, 2289		; 000008f1H
  00582	48 89 84 24 80
	00 00 00	 mov	 QWORD PTR tv279[rsp], rax
$LN67@s370_instf:
  0058a	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR tv279[rsp]
  00592	48 89 44 24 78	 mov	 QWORD PTR dest$[rsp], rax

; 892  :         memcpy( dest, ip, 4 );

  00597	48 8b 44 24 78	 mov	 rax, QWORD PTR dest$[rsp]
  0059c	48 8b 4c 24 38	 mov	 rcx, QWORD PTR ip$[rsp]
  005a1	8b 09		 mov	 ecx, DWORD PTR [rcx]
  005a3	89 08		 mov	 DWORD PTR [rax], ecx

; 893  : 
; 894  :         /* Copy second part of instruction */
; 895  :         len = pagesz - offset;

  005a5	8b 44 24 40	 mov	 eax, DWORD PTR offset$[rsp]
  005a9	8b 4c 24 34	 mov	 ecx, DWORD PTR pagesz$[rsp]
  005ad	2b c8		 sub	 ecx, eax
  005af	8b c1		 mov	 eax, ecx
  005b1	89 44 24 44	 mov	 DWORD PTR len$[rsp], eax

; 896  :         addr = (addr + len) & ADDRESS_MAXWRAP( regs );

  005b5	8b 44 24 44	 mov	 eax, DWORD PTR len$[rsp]
  005b9	8b 4c 24 30	 mov	 ecx, DWORD PTR addr$[rsp]
  005bd	03 c8		 add	 ecx, eax
  005bf	8b c1		 mov	 eax, ecx
  005c1	25 ff ff ff 00	 and	 eax, 16777215		; 00ffffffH
  005c6	89 44 24 30	 mov	 DWORD PTR addr$[rsp], eax

; 897  :         ip = MADDR( addr, USE_INST_SPACE, regs, ACCTYPE_INSTFETCH, regs->psw.pkey );

  005ca	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  005d2	0f b6 40 79	 movzx	 eax, BYTE PTR [rax+121]
  005d6	88 44 24 28	 mov	 BYTE PTR [rsp+40], al
  005da	c7 44 24 20 04
	00 00 00	 mov	 DWORD PTR [rsp+32], 4
  005e2	4c 8b 8c 24 a0
	00 00 00	 mov	 r9, QWORD PTR regs$[rsp]
  005ea	41 b8 ff ff ff
	ff		 mov	 r8d, -1
  005f0	ba 01 00 00 00	 mov	 edx, 1
  005f5	8b 4c 24 30	 mov	 ecx, DWORD PTR addr$[rsp]
  005f9	e8 00 00 00 00	 call	 s370_maddr_l
  005fe	48 89 44 24 38	 mov	 QWORD PTR ip$[rsp], rax

; 898  :         if (!exec)

  00603	83 bc 24 a8 00
	00 00 00	 cmp	 DWORD PTR exec$[rsp], 0
  0060b	75 1c		 jne	 SHORT $LN26@s370_instf

; 899  :             regs->ip = ip - len;

  0060d	48 63 44 24 44	 movsxd	 rax, DWORD PTR len$[rsp]
  00612	48 8b 4c 24 38	 mov	 rcx, QWORD PTR ip$[rsp]
  00617	48 2b c8	 sub	 rcx, rax
  0061a	48 8b c1	 mov	 rax, rcx
  0061d	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00625	48 89 41 68	 mov	 QWORD PTR [rcx+104], rax
$LN26@s370_instf:

; 900  :         memcpy( dest + len, ip, 4 );

  00629	48 63 44 24 44	 movsxd	 rax, DWORD PTR len$[rsp]
  0062e	48 8b 4c 24 78	 mov	 rcx, QWORD PTR dest$[rsp]
  00633	48 8b 54 24 38	 mov	 rdx, QWORD PTR ip$[rsp]
  00638	8b 12		 mov	 edx, DWORD PTR [rdx]
  0063a	89 14 01	 mov	 DWORD PTR [rcx+rax], edx

; 901  :     }

  0063d	eb 25		 jmp	 SHORT $LN25@s370_instf
$LN24@s370_instf:

; 902  :     else /* boundary NOT crossed */
; 903  :     {
; 904  :         dest = ip;

  0063f	48 8b 44 24 38	 mov	 rax, QWORD PTR ip$[rsp]
  00644	48 89 44 24 78	 mov	 QWORD PTR dest$[rsp], rax

; 905  : 
; 906  :         if (!exec)

  00649	83 bc 24 a8 00
	00 00 00	 cmp	 DWORD PTR exec$[rsp], 0
  00651	75 11		 jne	 SHORT $LN27@s370_instf

; 907  :             regs->ip = ip;

  00653	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0065b	48 8b 4c 24 38	 mov	 rcx, QWORD PTR ip$[rsp]
  00660	48 89 48 68	 mov	 QWORD PTR [rax+104], rcx
$LN27@s370_instf:
$LN25@s370_instf:

; 908  :     }
; 909  : 
; 910  :     if (!exec)

  00664	83 bc 24 a8 00
	00 00 00	 cmp	 DWORD PTR exec$[rsp], 0
  0066c	0f 85 bd 00 00
	00		 jne	 $LN28@s370_instf

; 911  :     {
; 912  :         /* Instr addr now known to be valid so reset instinvalid flag */
; 913  :         regs->instinvalid = 0;

  00672	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0067a	8b 80 28 07 00
	00		 mov	 eax, DWORD PTR [rax+1832]
  00680	83 e0 f7	 and	 eax, -9			; fffffff7H
  00683	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0068b	89 81 28 07 00
	00		 mov	 DWORD PTR [rcx+1832], eax

; 914  : 
; 915  :         /* Update the AIA values */
; 916  :         regs->AIV = addr & PAGEFRAME_PAGEMASK;

  00691	8b 44 24 30	 mov	 eax, DWORD PTR addr$[rsp]
  00695	25 00 f8 ff 7f	 and	 eax, 2147481600		; 7ffff800H
  0069a	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  006a2	89 81 10 02 00
	00		 mov	 DWORD PTR [rcx+528], eax

; 917  :         regs->aip = (BYTE*)((uintptr_t)ip & ~PAGEFRAME_BYTEMASK);

  006a8	48 8b 44 24 38	 mov	 rax, QWORD PTR ip$[rsp]
  006ad	48 25 00 f8 ff
	ff		 and	 rax, -2048		; fffffffffffff800H
  006b3	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  006bb	48 89 81 00 02
	00 00		 mov	 QWORD PTR [rcx+512], rax

; 918  : 
; 919  :         /* If tracing, stepping or PER is still active,
; 920  :            force another instfetch after this instruction.
; 921  :         */
; 922  :         if (regs->breakortrace || regs->permode)

  006c2	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  006ca	8b 80 28 07 00
	00		 mov	 eax, DWORD PTR [rax+1832]
  006d0	c1 e8 10	 shr	 eax, 16
  006d3	83 e0 01	 and	 eax, 1
  006d6	85 c0		 test	 eax, eax
  006d8	75 18		 jne	 SHORT $LN31@s370_instf
  006da	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  006e2	8b 80 28 07 00
	00		 mov	 eax, DWORD PTR [rax+1832]
  006e8	c1 e8 02	 shr	 eax, 2
  006eb	83 e0 01	 and	 eax, 1
  006ee	85 c0		 test	 eax, eax
  006f0	74 15		 je	 SHORT $LN29@s370_instf
$LN31@s370_instf:

; 923  :         {
; 924  :             /* Force instfetch to be called again on next inst. */
; 925  :             regs->aie = PSEUDO_INVALID_AIE;

  006f2	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  006fa	48 c7 80 08 02
	00 00 01 00 00
	00		 mov	 QWORD PTR [rax+520], 1

; 926  :         }

  00705	eb 28		 jmp	 SHORT $LN30@s370_instf
$LN29@s370_instf:

; 927  :         else /* (stepping/tracing/PER is NOT active) */
; 928  :         {
; 929  :             /* Call instfetch again ONLY when truly needed */
; 930  :             regs->aie = regs->aip + pagesz - 5;

  00707	48 63 44 24 34	 movsxd	 rax, DWORD PTR pagesz$[rsp]
  0070c	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00714	48 8b 89 00 02
	00 00		 mov	 rcx, QWORD PTR [rcx+512]
  0071b	48 8d 44 01 fb	 lea	 rax, QWORD PTR [rcx+rax-5]
  00720	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00728	48 89 81 08 02
	00 00		 mov	 QWORD PTR [rcx+520], rax
$LN30@s370_instf:
$LN28@s370_instf:

; 931  :         }
; 932  :     }
; 933  : 
; 934  : #if defined( FEATURE_073_TRANSACT_EXEC_FACILITY )
; 935  : 
; 936  :     /* Update CONSTRAINED trans instruction fetch constraint */
; 937  :     if (regs->txf_contran)
; 938  :     {
; 939  :         if (regs->AIV == regs->txf_aie_aiv2)
; 940  :             regs->txf_aie = regs->aip + regs->txf_aie_off2;
; 941  :     }
; 942  : 
; 943  :     TXF_INSTRADDR_CONSTRAINT( regs );
; 944  : 
; 945  : #endif /* defined( FEATURE_073_TRANSACT_EXEC_FACILITY ) */
; 946  : 
; 947  :     /* Save the address of the instruction ABOUT to be executed */
; 948  :     regs->periaddr = PSW_IA_FROM_IP( regs, 0 );

  0072f	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00737	8b 80 10 02 00
	00		 mov	 eax, DWORD PTR [rax+528]
  0073d	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00745	48 8b 94 24 a0
	00 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  0074d	48 8b 92 00 02
	00 00		 mov	 rdx, QWORD PTR [rdx+512]
  00754	48 8b 49 68	 mov	 rcx, QWORD PTR [rcx+104]
  00758	48 2b ca	 sub	 rcx, rdx
  0075b	48 03 c1	 add	 rax, rcx
  0075e	48 25 ff ff ff
	00		 and	 rax, 16777215		; 00ffffffH
  00764	8b c0		 mov	 eax, eax
  00766	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0076e	48 89 81 e8 08
	00 00		 mov	 QWORD PTR [rcx+2280], rax

; 949  : 
; 950  :     /* Suppress PER instruction fetch event if appropriate */
; 951  :     if (IS_PER_SUPRESS( regs, CR9_IF ))

  00775	33 c0		 xor	 eax, eax
  00777	85 c0		 test	 eax, eax
  00779	74 20		 je	 SHORT $LN32@s370_instf
$LN13@s370_instf:

; 952  :         OFF_IC_PER_IF( regs );

  0077b	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00783	8b 40 4c	 mov	 eax, DWORD PTR [rax+76]
  00786	0f ba f0 16	 btr	 eax, 22
  0078a	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00792	89 41 4c	 mov	 DWORD PTR [rcx+76], eax
  00795	33 c0		 xor	 eax, eax
  00797	85 c0		 test	 eax, eax
  00799	75 e0		 jne	 SHORT $LN13@s370_instf
$LN32@s370_instf:

; 953  : 
; 954  :     /* Return to caller to execute this instruction */
; 955  :     return dest;

  0079b	48 8b 44 24 78	 mov	 rax, QWORD PTR dest$[rsp]
$LN1@s370_instf:

; 956  : 
; 957  : } /* end function ARCH_DEP( instfetch ) */

  007a0	48 81 c4 98 00
	00 00		 add	 rsp, 152		; 00000098H
  007a7	c3		 ret	 0
s370_instfetch ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\dat.h
;	COMDAT s370_maddr_l
_TEXT	SEGMENT
tlbix$ = 48
aea_crn$ = 52
tv70 = 56
maddr$ = 64
addr$ = 96
len$ = 104
arn$ = 112
regs$ = 120
acctype$ = 128
akey$ = 136
s370_maddr_l PROC					; COMDAT

; 307  : {

$LN14:
  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	89 4c 24 08	 mov	 DWORD PTR [rsp+8], ecx
  00013	48 83 ec 58	 sub	 rsp, 88			; 00000058H

; 308  :     /* Note: ALL of the below conditions must be true for a TLB hit
; 309  :        to occur.  If ANY of them are false, then it's a TLB miss,
; 310  :        requiring us to then perform a full DAT address translation.
; 311  : 
; 312  :        Note too that on the grand scheme of things the order/sequence
; 313  :        of the below tests (if statements) is completely unimportant
; 314  :        since ALL conditions must be checked anyway in order for a hit
; 315  :        to occur, and it doesn't matter that a miss tests a few extra
; 316  :        conditions since it's going to do a full translation anyway!
; 317  :        (which is many, many instructions)
; 318  :     */
; 319  : 
; 320  :     int  aea_crn  = (arn >= USE_ARMODE) ? 0 : regs->AEA_AR( arn );

  00017	83 7c 24 70 10	 cmp	 DWORD PTR arn$[rsp], 16
  0001c	7c 0a		 jl	 SHORT $LN12@s370_maddr
  0001e	c7 44 24 38 00
	00 00 00	 mov	 DWORD PTR tv70[rsp], 0
  00026	eb 19		 jmp	 SHORT $LN13@s370_maddr
$LN12@s370_maddr:
  00028	8b 44 24 70	 mov	 eax, DWORD PTR arn$[rsp]
  0002c	83 c0 05	 add	 eax, 5
  0002f	48 98		 cdqe
  00031	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  00036	8b 84 81 94 0c
	00 00		 mov	 eax, DWORD PTR [rcx+rax*4+3220]
  0003d	89 44 24 38	 mov	 DWORD PTR tv70[rsp], eax
$LN13@s370_maddr:
  00041	8b 44 24 38	 mov	 eax, DWORD PTR tv70[rsp]
  00045	89 44 24 34	 mov	 DWORD PTR aea_crn$[rsp], eax

; 321  :     U16  tlbix    = TLBIX( addr );

  00049	8b 44 24 60	 mov	 eax, DWORD PTR addr$[rsp]
  0004d	c1 e8 0b	 shr	 eax, 11
  00050	25 ff 03 00 00	 and	 eax, 1023		; 000003ffH
  00055	66 89 44 24 30	 mov	 WORD PTR tlbix$[rsp], ax

; 322  :     BYTE *maddr   = NULL;

  0005a	48 c7 44 24 40
	00 00 00 00	 mov	 QWORD PTR maddr$[rsp], 0

; 323  : 
; 324  :     /* Non-zero AEA Control Register number? */
; 325  :     if (aea_crn)

  00063	83 7c 24 34 00	 cmp	 DWORD PTR aea_crn$[rsp], 0
  00068	0f 84 25 01 00
	00		 je	 $LN2@s370_maddr

; 326  :     {
; 327  :         /* Same Addess Space Designator as before? */
; 328  :         /* Or if not, is address in a common segment? */
; 329  :         if (0
; 330  :             || (regs->CR( aea_crn ) == regs->tlb.TLB_ASD( tlbix ))
; 331  :             || (regs->AEA_COMMON( aea_crn ) & regs->tlb.common[ tlbix ])

  0006e	33 c0		 xor	 eax, eax
  00070	85 c0		 test	 eax, eax
  00072	75 59		 jne	 SHORT $LN4@s370_maddr
  00074	8b 44 24 34	 mov	 eax, DWORD PTR aea_crn$[rsp]
  00078	ff c0		 inc	 eax
  0007a	48 98		 cdqe
  0007c	0f b7 4c 24 30	 movzx	 ecx, WORD PTR tlbix$[rsp]
  00081	48 8b 54 24 78	 mov	 rdx, QWORD PTR regs$[rsp]
  00086	4c 8b 44 24 78	 mov	 r8, QWORD PTR regs$[rsp]
  0008b	41 8b 8c c8 60
	b0 00 00	 mov	 ecx, DWORD PTR [r8+rcx*8+45152]
  00093	39 8c c2 00 06
	00 00		 cmp	 DWORD PTR [rdx+rax*8+1536], ecx
  0009a	74 31		 je	 SHORT $LN4@s370_maddr
  0009c	8b 44 24 34	 mov	 eax, DWORD PTR aea_crn$[rsp]
  000a0	ff c0		 inc	 eax
  000a2	48 98		 cdqe
  000a4	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  000a9	0f b6 84 01 e8
	0c 00 00	 movzx	 eax, BYTE PTR [rcx+rax+3304]
  000b1	0f b7 4c 24 30	 movzx	 ecx, WORD PTR tlbix$[rsp]
  000b6	48 8b 54 24 78	 mov	 rdx, QWORD PTR regs$[rsp]
  000bb	0f b6 8c 0a 60
	54 01 00	 movzx	 ecx, BYTE PTR [rdx+rcx+87136]
  000c3	23 c1		 and	 eax, ecx
  000c5	85 c0		 test	 eax, eax
  000c7	0f 84 c6 00 00
	00		 je	 $LN3@s370_maddr
$LN4@s370_maddr:

; 332  :         )
; 333  :         {
; 334  :             /* Storage Key zero? */
; 335  :             /* Or if not, same Storage Key as before? */
; 336  :             if (0
; 337  :                 || akey == 0
; 338  :                 || akey == regs->tlb.skey[ tlbix ]

  000cd	33 c0		 xor	 eax, eax
  000cf	85 c0		 test	 eax, eax
  000d1	75 2e		 jne	 SHORT $LN6@s370_maddr
  000d3	0f b6 84 24 88
	00 00 00	 movzx	 eax, BYTE PTR akey$[rsp]
  000db	85 c0		 test	 eax, eax
  000dd	74 22		 je	 SHORT $LN6@s370_maddr
  000df	0f b6 84 24 88
	00 00 00	 movzx	 eax, BYTE PTR akey$[rsp]
  000e7	0f b7 4c 24 30	 movzx	 ecx, WORD PTR tlbix$[rsp]
  000ec	48 8b 54 24 78	 mov	 rdx, QWORD PTR regs$[rsp]
  000f1	0f b6 8c 0a 60
	50 01 00	 movzx	 ecx, BYTE PTR [rdx+rcx+86112]
  000f9	3b c1		 cmp	 eax, ecx
  000fb	0f 85 92 00 00
	00		 jne	 $LN5@s370_maddr
$LN6@s370_maddr:

; 339  :             )
; 340  :             {
; 341  :                 /* Does the page address match the one in the TLB? */
; 342  :                 /* (does a TLB entry exist for this page address?) */
; 343  :                 if (
; 344  :                     ((addr & TLBID_PAGEMASK) | regs->tlbID)
; 345  :                     ==

  00101	8b 44 24 60	 mov	 eax, DWORD PTR addr$[rsp]
  00105	25 00 00 e0 00	 and	 eax, 14680064		; 00e00000H
  0010a	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  0010f	0b 81 58 b0 00
	00		 or	 eax, DWORD PTR [rcx+45144]
  00115	0f b7 4c 24 30	 movzx	 ecx, WORD PTR tlbix$[rsp]
  0011a	48 8b 54 24 78	 mov	 rdx, QWORD PTR regs$[rsp]
  0011f	3b 84 ca 60 d0
	00 00		 cmp	 eax, DWORD PTR [rdx+rcx*8+53344]
  00126	75 6b		 jne	 SHORT $LN7@s370_maddr

; 346  :                     regs->tlb.TLB_VADDR( tlbix )
; 347  :                 )
; 348  :                 {
; 349  :                     /* Is storage being accessed same way as before? */
; 350  :                     if (acctype & regs->tlb.acc[ tlbix ])

  00128	0f b7 44 24 30	 movzx	 eax, WORD PTR tlbix$[rsp]
  0012d	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  00132	0f b6 84 01 60
	5c 01 00	 movzx	 eax, BYTE PTR [rcx+rax+89184]
  0013a	8b 8c 24 80 00
	00 00		 mov	 ecx, DWORD PTR acctype$[rsp]
  00141	23 c8		 and	 ecx, eax
  00143	8b c1		 mov	 eax, ecx
  00145	85 c0		 test	 eax, eax
  00147	74 4a		 je	 SHORT $LN8@s370_maddr

; 351  :                     {
; 352  :                         /*------------------------------------------*/
; 353  :                         /* TLB hit: use previously translated value */
; 354  :                         /*------------------------------------------*/
; 355  : 
; 356  :                         if (acctype & ACC_CHECK)

  00149	8b 84 24 80 00
	00 00		 mov	 eax, DWORD PTR acctype$[rsp]
  00150	83 e0 01	 and	 eax, 1
  00153	85 c0		 test	 eax, eax
  00155	74 1e		 je	 SHORT $LN9@s370_maddr

; 357  :                             regs->dat.storkey = regs->tlb.storkey[ tlbix ];

  00157	0f b7 44 24 30	 movzx	 eax, WORD PTR tlbix$[rsp]
  0015c	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  00161	48 8b 54 24 78	 mov	 rdx, QWORD PTR regs$[rsp]
  00166	48 8b 84 c2 60
	30 01 00	 mov	 rax, QWORD PTR [rdx+rax*8+77920]
  0016e	48 89 81 28 08
	00 00		 mov	 QWORD PTR [rcx+2088], rax
$LN9@s370_maddr:

; 358  : 
; 359  :                         maddr = MAINADDR( regs->tlb.main[tlbix], addr );

  00175	0f b7 44 24 30	 movzx	 eax, WORD PTR tlbix$[rsp]
  0017a	8b 4c 24 60	 mov	 ecx, DWORD PTR addr$[rsp]
  0017e	48 8b 54 24 78	 mov	 rdx, QWORD PTR regs$[rsp]
  00183	48 8b 84 c2 60
	10 01 00	 mov	 rax, QWORD PTR [rdx+rax*8+69728]
  0018b	48 33 c1	 xor	 rax, rcx
  0018e	48 89 44 24 40	 mov	 QWORD PTR maddr$[rsp], rax
$LN8@s370_maddr:
$LN7@s370_maddr:
$LN5@s370_maddr:
$LN3@s370_maddr:
$LN2@s370_maddr:

; 360  :                     }
; 361  :                 }
; 362  :             }
; 363  :         }
; 364  :     }
; 365  : 
; 366  :     /*---------------------------------------*/
; 367  :     /* TLB miss: do full address translation */
; 368  :     /*---------------------------------------*/
; 369  :     if (!maddr)

  00193	48 83 7c 24 40
	00		 cmp	 QWORD PTR maddr$[rsp], 0
  00199	75 35		 jne	 SHORT $LN10@s370_maddr

; 370  :         maddr = ARCH_DEP( logical_to_main_l )( addr, arn, regs, acctype, akey, len );

  0019b	48 8b 44 24 68	 mov	 rax, QWORD PTR len$[rsp]
  001a0	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  001a5	0f b6 84 24 88
	00 00 00	 movzx	 eax, BYTE PTR akey$[rsp]
  001ad	88 44 24 20	 mov	 BYTE PTR [rsp+32], al
  001b1	44 8b 8c 24 80
	00 00 00	 mov	 r9d, DWORD PTR acctype$[rsp]
  001b9	4c 8b 44 24 78	 mov	 r8, QWORD PTR regs$[rsp]
  001be	8b 54 24 70	 mov	 edx, DWORD PTR arn$[rsp]
  001c2	8b 4c 24 60	 mov	 ecx, DWORD PTR addr$[rsp]
  001c6	e8 00 00 00 00	 call	 s370_logical_to_main_l
  001cb	48 89 44 24 40	 mov	 QWORD PTR maddr$[rsp], rax
$LN10@s370_maddr:

; 371  : 
; 372  : #if defined( FEATURE_073_TRANSACT_EXEC_FACILITY )
; 373  :     if (FACILITY_ENABLED( 073_TRANSACT_EXEC, regs ))
; 374  :     {
; 375  :         /* SA22-7832-12 Principles of Operation, page 5-99:
; 376  : 
; 377  :              "Storage accesses for instruction and DAT- and ART-
; 378  :               table fetches follow the non-transactional rules."
; 379  :         */
; 380  :         if (0
; 381  :             || !regs
; 382  :             || !regs->txf_tnd
; 383  :             || arn == USE_INST_SPACE    /* Instruction fetching */
; 384  :             || arn == USE_REAL_ADDR     /* Address translation  */
; 385  :         )
; 386  :             return maddr;
; 387  : 
; 388  :         /* Quick exit if NTSTG call */
; 389  :         if (regs->txf_NTSTG)
; 390  :         {
; 391  :             regs->txf_NTSTG = false;
; 392  :             return maddr;
; 393  :         }
; 394  : 
; 395  :         /* Translate to alternate TXF address */
; 396  :         maddr = TXF_MADDRL( addr, len, arn, regs, acctype, maddr );
; 397  :     }
; 398  : #endif
; 399  : 
; 400  :     return maddr;

  001d0	48 8b 44 24 40	 mov	 rax, QWORD PTR maddr$[rsp]

; 401  : }

  001d5	48 83 c4 58	 add	 rsp, 88			; 00000058H
  001d9	c3		 ret	 0
s370_maddr_l ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\skey.h
;	COMDAT s370_or_4K_storage_key
_TEXT	SEGMENT
abs$ = 48
bits$ = 56
s370_or_4K_storage_key PROC				; COMDAT

; 242  :   inline void  ARCH_DEP( or_4K_storage_key )      (              U64 abs, BYTE bits ) {        ARCH_DEP( _or_storage_key      )(      abs, bits & ~STORKEY_BADFRM, 4 ); }

$LN3:
  00000	88 54 24 10	 mov	 BYTE PTR [rsp+16], dl
  00004	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00009	48 83 ec 28	 sub	 rsp, 40			; 00000028H
  0000d	0f b6 44 24 38	 movzx	 eax, BYTE PTR bits$[rsp]
  00012	83 e0 fe	 and	 eax, -2
  00015	41 b0 04	 mov	 r8b, 4
  00018	0f b6 d0	 movzx	 edx, al
  0001b	48 8b 4c 24 30	 mov	 rcx, QWORD PTR abs$[rsp]
  00020	e8 00 00 00 00	 call	 s370__or_storage_key
  00025	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00029	c3		 ret	 0
s370_or_4K_storage_key ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\skey.h
;	COMDAT s370__or_storage_key
_TEXT	SEGMENT
skey1_ptr$1 = 32
skey2_ptr$2 = 40
skey_ptr$3 = 48
abs$ = 80
bits$ = 88
K$ = 96
s370__or_storage_key PROC				; COMDAT

; 189  : {

$LN8:
  00000	44 88 44 24 18	 mov	 BYTE PTR [rsp+24], r8b
  00005	88 54 24 10	 mov	 BYTE PTR [rsp+16], dl
  00009	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000e	48 83 ec 48	 sub	 rsp, 72			; 00000048H
$LN4@s370__or_s:

; 190  :     UNREFERENCED( K ); // (for FEATURE_4K_STORAGE_KEYS case)

  00012	33 c0		 xor	 eax, eax
  00014	85 c0		 test	 eax, eax
  00016	75 fa		 jne	 SHORT $LN4@s370__or_s

; 191  :     if (IS_DOUBLE_KEYED_4K_BYTE_BLOCK( K ))

  00018	0f b6 44 24 60	 movzx	 eax, BYTE PTR K$[rsp]
  0001d	83 f8 04	 cmp	 eax, 4
  00020	75 57		 jne	 SHORT $LN5@s370__or_s
  00022	33 c0		 xor	 eax, eax
  00024	83 f8 01	 cmp	 eax, 1
  00027	74 50		 je	 SHORT $LN5@s370__or_s

; 192  :     {
; 193  :         BYTE* skey1_ptr = _get_storekey1_ptr( abs );

  00029	48 8b 4c 24 50	 mov	 rcx, QWORD PTR abs$[rsp]
  0002e	e8 00 00 00 00	 call	 _get_storekey1_ptr
  00033	48 89 44 24 20	 mov	 QWORD PTR skey1_ptr$1[rsp], rax

; 194  :         BYTE* skey2_ptr = _get_storekey2_ptr( abs );

  00038	48 8b 4c 24 50	 mov	 rcx, QWORD PTR abs$[rsp]
  0003d	e8 00 00 00 00	 call	 _get_storekey2_ptr
  00042	48 89 44 24 28	 mov	 QWORD PTR skey2_ptr$2[rsp], rax

; 195  :         OR_SKEY( skey1_ptr, bits );

  00047	0f b6 44 24 58	 movzx	 eax, BYTE PTR bits$[rsp]
  0004c	48 8b 4c 24 20	 mov	 rcx, QWORD PTR skey1_ptr$1[rsp]
  00051	0f b6 09	 movzx	 ecx, BYTE PTR [rcx]
  00054	0b c8		 or	 ecx, eax
  00056	8b c1		 mov	 eax, ecx
  00058	48 8b 4c 24 20	 mov	 rcx, QWORD PTR skey1_ptr$1[rsp]
  0005d	88 01		 mov	 BYTE PTR [rcx], al

; 196  :         OR_SKEY( skey2_ptr, bits );

  0005f	0f b6 44 24 58	 movzx	 eax, BYTE PTR bits$[rsp]
  00064	48 8b 4c 24 28	 mov	 rcx, QWORD PTR skey2_ptr$2[rsp]
  00069	0f b6 09	 movzx	 ecx, BYTE PTR [rcx]
  0006c	0b c8		 or	 ecx, eax
  0006e	8b c1		 mov	 eax, ecx
  00070	48 8b 4c 24 28	 mov	 rcx, QWORD PTR skey2_ptr$2[rsp]
  00075	88 01		 mov	 BYTE PTR [rcx], al

; 197  :     }

  00077	eb 2c		 jmp	 SHORT $LN6@s370__or_s
$LN5@s370__or_s:

; 198  :     else
; 199  :     {
; 200  :         BYTE* skey_ptr  = _get_storekey_ptr( abs, K );

  00079	0f b6 54 24 60	 movzx	 edx, BYTE PTR K$[rsp]
  0007e	48 8b 4c 24 50	 mov	 rcx, QWORD PTR abs$[rsp]
  00083	e8 00 00 00 00	 call	 _get_storekey_ptr
  00088	48 89 44 24 30	 mov	 QWORD PTR skey_ptr$3[rsp], rax

; 201  :         OR_SKEY( skey_ptr, bits );

  0008d	0f b6 44 24 58	 movzx	 eax, BYTE PTR bits$[rsp]
  00092	48 8b 4c 24 30	 mov	 rcx, QWORD PTR skey_ptr$3[rsp]
  00097	0f b6 09	 movzx	 ecx, BYTE PTR [rcx]
  0009a	0b c8		 or	 ecx, eax
  0009c	8b c1		 mov	 eax, ecx
  0009e	48 8b 4c 24 30	 mov	 rcx, QWORD PTR skey_ptr$3[rsp]
  000a3	88 01		 mov	 BYTE PTR [rcx], al
$LN6@s370__or_s:

; 202  :     }
; 203  : }

  000a5	48 83 c4 48	 add	 rsp, 72			; 00000048H
  000a9	c3		 ret	 0
s370__or_storage_key ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\skey.h
;	COMDAT _get_storekey2_ptr
_TEXT	SEGMENT
abs$ = 8
_get_storekey2_ptr PROC					; COMDAT

; 60   : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx

; 61   :     ABS_CHECK( abs );
; 62   :     return &STOREKEY2( abs, &sysblk );

  00005	48 8b 44 24 08	 mov	 rax, QWORD PTR abs$[rsp]
  0000a	48 c1 e8 0b	 shr	 rax, 11
  0000e	48 83 c8 01	 or	 rax, 1
  00012	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  00019	48 8b 89 a0 00
	00 00		 mov	 rcx, QWORD PTR [rcx+160]
  00020	48 03 c8	 add	 rcx, rax
  00023	48 8b c1	 mov	 rax, rcx

; 63   : }

  00026	c3		 ret	 0
_get_storekey2_ptr ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\skey.h
;	COMDAT _get_storekey1_ptr
_TEXT	SEGMENT
abs$ = 8
_get_storekey1_ptr PROC					; COMDAT

; 54   : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx

; 55   :     ABS_CHECK( abs );
; 56   :     return &STOREKEY1( abs, &sysblk );

  00005	48 8b 44 24 08	 mov	 rax, QWORD PTR abs$[rsp]
  0000a	48 c1 e8 0b	 shr	 rax, 11
  0000e	48 83 e0 fe	 and	 rax, -2
  00012	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  00019	48 8b 89 a0 00
	00 00		 mov	 rcx, QWORD PTR [rcx+160]
  00020	48 03 c8	 add	 rcx, rax
  00023	48 8b c1	 mov	 rax, rcx

; 57   : }

  00026	c3		 ret	 0
_get_storekey1_ptr ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\skey.h
;	COMDAT _get_storekey_ptr
_TEXT	SEGMENT
tv75 = 0
abs$ = 32
K$ = 40
_get_storekey_ptr PROC					; COMDAT

; 40   : {

$LN5:
  00000	88 54 24 10	 mov	 BYTE PTR [rsp+16], dl
  00004	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00009	48 83 ec 18	 sub	 rsp, 24

; 41   :     ABS_CHECK( abs );
; 42   :     return (4 == K) ? &STOREKEY1( abs, &sysblk ) // (see feature.h PROGRAMMING NOTE)

  0000d	0f b6 44 24 28	 movzx	 eax, BYTE PTR K$[rsp]
  00012	83 f8 04	 cmp	 eax, 4
  00015	75 27		 jne	 SHORT $LN3@get_storek
  00017	48 8b 44 24 20	 mov	 rax, QWORD PTR abs$[rsp]
  0001c	48 c1 e8 0b	 shr	 rax, 11
  00020	48 83 e0 fe	 and	 rax, -2
  00024	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  0002b	48 8b 89 a0 00
	00 00		 mov	 rcx, QWORD PTR [rcx+160]
  00032	48 03 c8	 add	 rcx, rax
  00035	48 8b c1	 mov	 rax, rcx
  00038	48 89 04 24	 mov	 QWORD PTR tv75[rsp], rax
  0003c	eb 21		 jmp	 SHORT $LN4@get_storek
$LN3@get_storek:
  0003e	48 8b 44 24 20	 mov	 rax, QWORD PTR abs$[rsp]
  00043	48 c1 e8 0b	 shr	 rax, 11
  00047	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  0004e	48 8b 89 a0 00
	00 00		 mov	 rcx, QWORD PTR [rcx+160]
  00055	48 03 c8	 add	 rcx, rax
  00058	48 8b c1	 mov	 rax, rcx
  0005b	48 89 04 24	 mov	 QWORD PTR tv75[rsp], rax
$LN4@get_storek:
  0005f	48 8b 04 24	 mov	 rax, QWORD PTR tv75[rsp]

; 43   :                     : &STOREKEY(  abs, &sysblk );
; 44   : }

  00063	48 83 c4 18	 add	 rsp, 24
  00067	c3		 ret	 0
_get_storekey_ptr ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\hinlines.h
_TEXT	SEGMENT
p$ = 8
count$ = 16
atomic_update64 PROC

; 425  : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx

; 426  : #if defined( _MSVC_ )
; 427  :     InterlockedExchangeAdd64( p, count );

  0000a	48 8b 44 24 08	 mov	 rax, QWORD PTR p$[rsp]
  0000f	48 8b 4c 24 10	 mov	 rcx, QWORD PTR count$[rsp]
  00014	f0 48 01 08	 lock add QWORD PTR [rax], rcx

; 428  : #else // GCC (and CLANG?)
; 429  :   #if defined( HAVE_SYNC_BUILTINS )
; 430  :     __sync_fetch_and_add( p, count );
; 431  :   #else
; 432  :     *p += count;  /* (N.B. non-atomic!) */
; 433  :   #endif
; 434  : #endif
; 435  : }

  00018	c3		 ret	 0
atomic_update64 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\hinlines.h
_TEXT	SEGMENT
regs$ = 48
location$ = 56
Release_Interrupt_Lock PROC

; 403  : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 28	 sub	 rsp, 40			; 00000028H
$LN4@Release_In:

; 404  :     UNREFERENCED( regs );

  0000e	33 c0		 xor	 eax, eax
  00010	85 c0		 test	 eax, eax
  00012	75 fa		 jne	 SHORT $LN4@Release_In

; 405  :     sysblk.intowner = LOCK_OWNER_NONE;

  00014	b8 ff ff 00 00	 mov	 eax, 65535		; 0000ffffH
  00019	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  00020	66 89 81 62 10
	00 00		 mov	 WORD PTR [rcx+4194], ax

; 406  :     hthread_release_lock( &sysblk.intlock, location );

  00027	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  0002e	48 05 70 10 00
	00		 add	 rax, 4208		; 00001070H
  00034	48 8b 54 24 38	 mov	 rdx, QWORD PTR location$[rsp]
  00039	48 8b c8	 mov	 rcx, rax
  0003c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_release_lock

; 407  : }

  00042	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00046	c3		 ret	 0
Release_Interrupt_Lock ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\hinlines.h
_TEXT	SEGMENT
regs$ = 48
location$ = 56
Obtain_Interrupt_Lock PROC

; 379  : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 380  :     if (regs)

  0000e	48 83 7c 24 30
	00		 cmp	 QWORD PTR regs$[rsp], 0
  00014	74 13		 je	 SHORT $LN2@Obtain_Int

; 381  :         HOSTREGS->intwait = true;

  00016	48 8b 44 24 30	 mov	 rax, QWORD PTR regs$[rsp]
  0001b	48 8b 80 68 08
	00 00		 mov	 rax, QWORD PTR [rax+2152]
  00022	c6 80 f0 08 00
	00 01		 mov	 BYTE PTR [rax+2288], 1
$LN2@Obtain_Int:

; 382  :     hthread_obtain_lock( &sysblk.intlock, location );

  00029	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00030	48 05 70 10 00
	00		 add	 rax, 4208		; 00001070H
  00036	48 8b 54 24 38	 mov	 rdx, QWORD PTR location$[rsp]
  0003b	48 8b c8	 mov	 rcx, rax
  0003e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_obtain_lock

; 383  :     Interrupt_Lock_Obtained( regs, location );

  00044	48 8b 54 24 38	 mov	 rdx, QWORD PTR location$[rsp]
  00049	48 8b 4c 24 30	 mov	 rcx, QWORD PTR regs$[rsp]
  0004e	e8 00 00 00 00	 call	 Interrupt_Lock_Obtained

; 384  : }

  00053	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00057	c3		 ret	 0
Obtain_Interrupt_Lock ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\hinlines.h
_TEXT	SEGMENT
regs$ = 48
location$ = 56
Interrupt_Lock_Obtained PROC

; 347  : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 348  :     if (regs)

  0000e	48 83 7c 24 30
	00		 cmp	 QWORD PTR regs$[rsp], 0
  00014	0f 84 db 00 00
	00		 je	 $LN4@Interrupt_
$LN2@Interrupt_:

; 349  :     {
; 350  :         /* Wait for any SYNCHRONIZE_CPUS to finish before proceeding */
; 351  :         while (sysblk.syncing)

  0001a	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00021	0f b6 80 7c 13
	00 00		 movzx	 eax, BYTE PTR [rax+4988]
  00028	85 c0		 test	 eax, eax
  0002a	0f 84 8f 00 00
	00		 je	 $LN3@Interrupt_

; 352  :         {
; 353  :             /* Indicate we have reached the sync point */
; 354  :             sysblk.sync_mask &= ~HOSTREGS->cpubit;

  00030	48 8b 44 24 30	 mov	 rax, QWORD PTR regs$[rsp]
  00035	48 8b 80 68 08
	00 00		 mov	 rax, QWORD PTR [rax+2152]
  0003c	48 8b 40 50	 mov	 rax, QWORD PTR [rax+80]
  00040	48 f7 d0	 not	 rax
  00043	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  0004a	48 8b 89 80 13
	00 00		 mov	 rcx, QWORD PTR [rcx+4992]
  00051	48 23 c8	 and	 rcx, rax
  00054	48 8b c1	 mov	 rax, rcx
  00057	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  0005e	48 89 81 80 13
	00 00		 mov	 QWORD PTR [rcx+4992], rax

; 355  : 
; 356  :             /* If we're the last CPU to reach this sync point,
; 357  :                signal the CPU that requested the sync that it
; 358  :                may now safely proceed with its exclusive logic.
; 359  :             */
; 360  :             if (!sysblk.sync_mask)

  00065	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  0006c	48 83 b8 80 13
	00 00 00	 cmp	 QWORD PTR [rax+4992], 0
  00074	75 1b		 jne	 SHORT $LN6@Interrupt_

; 361  :                 hthread_signal_condition( &sysblk.all_synced_cond, location );

  00076	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  0007d	48 05 88 13 00
	00		 add	 rax, 5000		; 00001388H
  00083	48 8b 54 24 38	 mov	 rdx, QWORD PTR location$[rsp]
  00088	48 8b c8	 mov	 rcx, rax
  0008b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_signal_condition
$LN6@Interrupt_:

; 362  : 
; 363  :             /* Wait for CPU that requested the sync to indicate
; 364  :                it's done and thus is now safe for us to proceed.
; 365  :             */
; 366  :             hthread_wait_condition( &sysblk.sync_done_cond, &sysblk.intlock, location );

  00091	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00098	48 05 70 10 00
	00		 add	 rax, 4208		; 00001070H
  0009e	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  000a5	48 81 c1 90 13
	00 00		 add	 rcx, 5008		; 00001390H
  000ac	4c 8b 44 24 38	 mov	 r8, QWORD PTR location$[rsp]
  000b1	48 8b d0	 mov	 rdx, rax
  000b4	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_wait_condition

; 367  :         }

  000ba	e9 5b ff ff ff	 jmp	 $LN2@Interrupt_
$LN3@Interrupt_:

; 368  : 
; 369  :         HOSTREGS->intwait = false;

  000bf	48 8b 44 24 30	 mov	 rax, QWORD PTR regs$[rsp]
  000c4	48 8b 80 68 08
	00 00		 mov	 rax, QWORD PTR [rax+2152]
  000cb	c6 80 f0 08 00
	00 00		 mov	 BYTE PTR [rax+2288], 0

; 370  :         sysblk.intowner = HOSTREGS->cpuad;

  000d2	48 8b 44 24 30	 mov	 rax, QWORD PTR regs$[rsp]
  000d7	48 8b 80 68 08
	00 00		 mov	 rax, QWORD PTR [rax+2152]
  000de	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  000e5	0f b7 80 3c 08
	00 00		 movzx	 eax, WORD PTR [rax+2108]
  000ec	66 89 81 62 10
	00 00		 mov	 WORD PTR [rcx+4194], ax

; 371  :     }

  000f3	eb 13		 jmp	 SHORT $LN5@Interrupt_
$LN4@Interrupt_:

; 372  :     else
; 373  :         sysblk.intowner = LOCK_OWNER_OTHER;

  000f5	b8 fe ff 00 00	 mov	 eax, 65534		; 0000fffeH
  000fa	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  00101	66 89 81 62 10
	00 00		 mov	 WORD PTR [rcx+4194], ax
$LN5@Interrupt_:

; 374  : }

  00108	48 83 c4 28	 add	 rsp, 40			; 00000028H
  0010c	c3		 ret	 0
Interrupt_Lock_Obtained ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\machdep.h
;	COMDAT store_dw_noswap
_TEXT	SEGMENT
ptr$ = 8
value$ = 16
store_dw_noswap PROC					; COMDAT

; 834  :     inline void store_dw_noswap(void *ptr, U64 value) {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx

; 835  :       memcpy((BYTE *)ptr, (BYTE *)&value, 8);

  0000a	48 8b 44 24 08	 mov	 rax, QWORD PTR ptr$[rsp]
  0000f	48 8b 4c 24 10	 mov	 rcx, QWORD PTR value$[rsp]
  00014	48 89 08	 mov	 QWORD PTR [rax], rcx

; 836  :     }

  00017	c3		 ret	 0
store_dw_noswap ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\machdep.h
;	COMDAT fetch_dw_noswap
_TEXT	SEGMENT
value$ = 0
ptr$ = 32
fetch_dw_noswap PROC					; COMDAT

; 816  :     inline U64 fetch_dw_noswap(const void *ptr) {

$LN3:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 18	 sub	 rsp, 24

; 817  :       U64 value;
; 818  :       memcpy(&value, (BYTE *)ptr, 8);

  00009	48 8b 44 24 20	 mov	 rax, QWORD PTR ptr$[rsp]
  0000e	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00011	48 89 04 24	 mov	 QWORD PTR value$[rsp], rax

; 819  :       return value;

  00015	48 8b 04 24	 mov	 rax, QWORD PTR value$[rsp]

; 820  :     }

  00019	48 83 c4 18	 add	 rsp, 24
  0001d	c3		 ret	 0
fetch_dw_noswap ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\machdep.h
;	COMDAT store_fw_noswap
_TEXT	SEGMENT
ptr$ = 8
value$ = 16
store_fw_noswap PROC					; COMDAT

; 764  :     inline void store_fw_noswap(void *ptr, U32 value) {

  00000	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00004	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx

; 765  :       memcpy((BYTE *)ptr, (BYTE *)&value, 4);

  00009	48 8b 44 24 08	 mov	 rax, QWORD PTR ptr$[rsp]
  0000e	8b 4c 24 10	 mov	 ecx, DWORD PTR value$[rsp]
  00012	89 08		 mov	 DWORD PTR [rax], ecx

; 766  :     }

  00014	c3		 ret	 0
store_fw_noswap ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\machdep.h
;	COMDAT fetch_fw_noswap
_TEXT	SEGMENT
value$ = 0
ptr$ = 32
fetch_fw_noswap PROC					; COMDAT

; 746  :     inline U32 fetch_fw_noswap(const void *ptr) {

$LN3:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 18	 sub	 rsp, 24

; 747  :       U32 value;
; 748  :       memcpy(&value, (BYTE *)ptr, 4);

  00009	48 8b 44 24 20	 mov	 rax, QWORD PTR ptr$[rsp]
  0000e	8b 00		 mov	 eax, DWORD PTR [rax]
  00010	89 04 24	 mov	 DWORD PTR value$[rsp], eax

; 749  :       return value;

  00013	8b 04 24	 mov	 eax, DWORD PTR value$[rsp]

; 750  :     }

  00016	48 83 c4 18	 add	 rsp, 24
  0001a	c3		 ret	 0
fetch_fw_noswap ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\machdep.h
;	COMDAT store_hw_noswap
_TEXT	SEGMENT
ptr$ = 8
value$ = 16
store_hw_noswap PROC					; COMDAT

; 730  :     inline void store_hw_noswap(void *ptr, U16 value) {

  00000	66 89 54 24 10	 mov	 WORD PTR [rsp+16], dx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx

; 731  :       memcpy((BYTE *)ptr, (BYTE *)&value, 2);

  0000a	48 8b 44 24 08	 mov	 rax, QWORD PTR ptr$[rsp]
  0000f	0f b7 4c 24 10	 movzx	 ecx, WORD PTR value$[rsp]
  00014	66 89 08	 mov	 WORD PTR [rax], cx

; 732  :     }

  00017	c3		 ret	 0
store_hw_noswap ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\machdep.h
;	COMDAT fetch_hw_noswap
_TEXT	SEGMENT
value$ = 0
ptr$ = 32
fetch_hw_noswap PROC					; COMDAT

; 712  :     inline U16 fetch_hw_noswap(const void *ptr) {

$LN3:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 18	 sub	 rsp, 24

; 713  :       U16 value;
; 714  :       memcpy(&value, (BYTE *)ptr, 2);

  00009	48 8b 44 24 20	 mov	 rax, QWORD PTR ptr$[rsp]
  0000e	0f b7 00	 movzx	 eax, WORD PTR [rax]
  00011	66 89 04 24	 mov	 WORD PTR value$[rsp], ax

; 715  :       return value;

  00015	0f b7 04 24	 movzx	 eax, WORD PTR value$[rsp]

; 716  :     }

  00019	48 83 c4 18	 add	 rsp, 24
  0001d	c3		 ret	 0
fetch_hw_noswap ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\machdep.h
;	COMDAT cmpxchg1_x86
_TEXT	SEGMENT
cc$ = 32
val4$ = 36
old4$ = 40
shift$ = 48
tv154 = 56
tv74 = 60
tv163 = 64
tv82 = 68
new4$ = 72
off$ = 80
ptr4$ = 88
old$ = 112
unew$ = 120
ptr$ = 128
cmpxchg1_x86 PROC					; COMDAT

; 113  :     {

$LN3:
  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	88 54 24 10	 mov	 BYTE PTR [rsp+16], dl
  00009	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000e	48 83 ec 68	 sub	 rsp, 104		; 00000068H

; 114  :         // returns 0 == success, 1 otherwise
; 115  : 
; 116  :         LONG_PTR  off, shift;
; 117  :         BYTE  cc;
; 118  :         U32  *ptr4, val4, old4, new4;
; 119  : 
; 120  :         off   = (LONG_PTR)ptr & 3;

  00012	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR ptr$[rsp]
  0001a	48 83 e0 03	 and	 rax, 3
  0001e	48 89 44 24 50	 mov	 QWORD PTR off$[rsp], rax

; 121  :         shift = (3 - off) * 8;

  00023	b8 03 00 00 00	 mov	 eax, 3
  00028	48 2b 44 24 50	 sub	 rax, QWORD PTR off$[rsp]
  0002d	48 c1 e0 03	 shl	 rax, 3
  00031	48 89 44 24 30	 mov	 QWORD PTR shift$[rsp], rax

; 122  :         ptr4  = (U32*)(((BYTE*)ptr) - off);

  00036	48 8b 44 24 50	 mov	 rax, QWORD PTR off$[rsp]
  0003b	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR ptr$[rsp]
  00043	48 2b c8	 sub	 rcx, rax
  00046	48 8b c1	 mov	 rax, rcx
  00049	48 89 44 24 58	 mov	 QWORD PTR ptr4$[rsp], rax

; 123  :         val4  = CSWAP32(*ptr4);

  0004e	48 8b 44 24 58	 mov	 rax, QWORD PTR ptr4$[rsp]
  00053	8b 08		 mov	 ecx, DWORD PTR [rax]
  00055	e8 00 00 00 00	 call	 _byteswap_ulong
  0005a	89 44 24 24	 mov	 DWORD PTR val4$[rsp], eax

; 124  : 
; 125  :         old4  = CSWAP32((val4 & ~(0xff << shift)) | (*old << shift));

  0005e	48 8b 44 24 30	 mov	 rax, QWORD PTR shift$[rsp]
  00063	b9 ff 00 00 00	 mov	 ecx, 255		; 000000ffH
  00068	89 4c 24 38	 mov	 DWORD PTR tv154[rsp], ecx
  0006c	0f b6 c8	 movzx	 ecx, al
  0006f	8b 44 24 38	 mov	 eax, DWORD PTR tv154[rsp]
  00073	d3 e0		 shl	 eax, cl
  00075	f7 d0		 not	 eax
  00077	8b 4c 24 24	 mov	 ecx, DWORD PTR val4$[rsp]
  0007b	23 c8		 and	 ecx, eax
  0007d	8b c1		 mov	 eax, ecx
  0007f	48 8b 4c 24 70	 mov	 rcx, QWORD PTR old$[rsp]
  00084	0f b6 09	 movzx	 ecx, BYTE PTR [rcx]
  00087	89 4c 24 3c	 mov	 DWORD PTR tv74[rsp], ecx
  0008b	48 8b 54 24 30	 mov	 rdx, QWORD PTR shift$[rsp]
  00090	0f b6 ca	 movzx	 ecx, dl
  00093	8b 54 24 3c	 mov	 edx, DWORD PTR tv74[rsp]
  00097	d3 e2		 shl	 edx, cl
  00099	8b ca		 mov	 ecx, edx
  0009b	0b c1		 or	 eax, ecx
  0009d	8b c8		 mov	 ecx, eax
  0009f	e8 00 00 00 00	 call	 _byteswap_ulong
  000a4	89 44 24 28	 mov	 DWORD PTR old4$[rsp], eax

; 126  :         new4  = CSWAP32((val4 & ~(0xff << shift)) | ( unew << shift));

  000a8	48 8b 44 24 30	 mov	 rax, QWORD PTR shift$[rsp]
  000ad	b9 ff 00 00 00	 mov	 ecx, 255		; 000000ffH
  000b2	89 4c 24 40	 mov	 DWORD PTR tv163[rsp], ecx
  000b6	0f b6 c8	 movzx	 ecx, al
  000b9	8b 44 24 40	 mov	 eax, DWORD PTR tv163[rsp]
  000bd	d3 e0		 shl	 eax, cl
  000bf	f7 d0		 not	 eax
  000c1	8b 4c 24 24	 mov	 ecx, DWORD PTR val4$[rsp]
  000c5	23 c8		 and	 ecx, eax
  000c7	8b c1		 mov	 eax, ecx
  000c9	0f b6 4c 24 78	 movzx	 ecx, BYTE PTR unew$[rsp]
  000ce	89 4c 24 44	 mov	 DWORD PTR tv82[rsp], ecx
  000d2	48 8b 54 24 30	 mov	 rdx, QWORD PTR shift$[rsp]
  000d7	0f b6 ca	 movzx	 ecx, dl
  000da	8b 54 24 44	 mov	 edx, DWORD PTR tv82[rsp]
  000de	d3 e2		 shl	 edx, cl
  000e0	8b ca		 mov	 ecx, edx
  000e2	0b c1		 or	 eax, ecx
  000e4	8b c8		 mov	 ecx, eax
  000e6	e8 00 00 00 00	 call	 _byteswap_ulong
  000eb	89 44 24 48	 mov	 DWORD PTR new4$[rsp], eax

; 127  : 
; 128  :         cc    = cmpxchg4( &old4, new4, ptr4 );

  000ef	4c 8b 44 24 58	 mov	 r8, QWORD PTR ptr4$[rsp]
  000f4	8b 54 24 48	 mov	 edx, DWORD PTR new4$[rsp]
  000f8	48 8d 4c 24 28	 lea	 rcx, QWORD PTR old4$[rsp]
  000fd	e8 00 00 00 00	 call	 cmpxchg4_x86
  00102	88 44 24 20	 mov	 BYTE PTR cc$[rsp], al

; 129  : 
; 130  :         *old  = (CSWAP32(old4) >> shift) & 0xff;

  00106	8b 4c 24 28	 mov	 ecx, DWORD PTR old4$[rsp]
  0010a	e8 00 00 00 00	 call	 _byteswap_ulong
  0010f	48 8b 4c 24 30	 mov	 rcx, QWORD PTR shift$[rsp]
  00114	d3 e8		 shr	 eax, cl
  00116	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  0011b	48 8b 4c 24 70	 mov	 rcx, QWORD PTR old$[rsp]
  00120	88 01		 mov	 BYTE PTR [rcx], al

; 131  : 
; 132  :         return cc;

  00122	0f b6 44 24 20	 movzx	 eax, BYTE PTR cc$[rsp]

; 133  :     }

  00127	48 83 c4 68	 add	 rsp, 104		; 00000068H
  0012b	c3		 ret	 0
cmpxchg1_x86 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\machdep.h
;	COMDAT cmpxchg4_x86
_TEXT	SEGMENT
tv69 = 0
tv71 = 4
tmp$ = 8
old$ = 32
unew$ = 40
ptr$ = 48
cmpxchg4_x86 PROC					; COMDAT

; 104  :     {

$LN5:
  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00009	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000e	48 83 ec 18	 sub	 rsp, 24

; 105  :         // returns 0 == success, 1 otherwise
; 106  :         U32 tmp = *old;

  00012	48 8b 44 24 20	 mov	 rax, QWORD PTR old$[rsp]
  00017	8b 00		 mov	 eax, DWORD PTR [rax]
  00019	89 44 24 08	 mov	 DWORD PTR tmp$[rsp], eax

; 107  :         *old = _InterlockedCompareExchange( ptr, unew, *old );

  0001d	8b 44 24 28	 mov	 eax, DWORD PTR unew$[rsp]
  00021	89 44 24 04	 mov	 DWORD PTR tv71[rsp], eax
  00025	48 8b 4c 24 30	 mov	 rcx, QWORD PTR ptr$[rsp]
  0002a	48 8b 54 24 20	 mov	 rdx, QWORD PTR old$[rsp]
  0002f	8b 02		 mov	 eax, DWORD PTR [rdx]
  00031	8b 54 24 04	 mov	 edx, DWORD PTR tv71[rsp]
  00035	f0 0f b1 11	 lock cmpxchg DWORD PTR [rcx], edx
  00039	48 8b 4c 24 20	 mov	 rcx, QWORD PTR old$[rsp]
  0003e	89 01		 mov	 DWORD PTR [rcx], eax

; 108  :         return ((tmp == *old) ? 0 : 1);

  00040	48 8b 44 24 20	 mov	 rax, QWORD PTR old$[rsp]
  00045	8b 00		 mov	 eax, DWORD PTR [rax]
  00047	39 44 24 08	 cmp	 DWORD PTR tmp$[rsp], eax
  0004b	75 09		 jne	 SHORT $LN3@cmpxchg4_x
  0004d	c7 04 24 00 00
	00 00		 mov	 DWORD PTR tv69[rsp], 0
  00054	eb 07		 jmp	 SHORT $LN4@cmpxchg4_x
$LN3@cmpxchg4_x:
  00056	c7 04 24 01 00
	00 00		 mov	 DWORD PTR tv69[rsp], 1
$LN4@cmpxchg4_x:
  0005d	0f b6 04 24	 movzx	 eax, BYTE PTR tv69[rsp]

; 109  :     }

  00061	48 83 c4 18	 add	 rsp, 24
  00065	c3		 ret	 0
cmpxchg4_x86 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\clock.h
_TEXT	SEGMENT
tod$ = 8
TOD_high64_to_ETOD_high56 PROC

; 221  : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx

; 222  :     return (tod >> 8);                  /* Adjust bit 51 to bit 59   */

  00005	48 8b 44 24 08	 mov	 rax, QWORD PTR tod$[rsp]
  0000a	48 c1 e8 08	 shr	 rax, 8

; 223  : }

  0000e	c3		 ret	 0
TOD_high64_to_ETOD_high56 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\clock.h
_TEXT	SEGMENT
etod$ = 8
ETOD_high64_to_TOD_high56 PROC

; 213  : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx

; 214  :     return (etod << 8);                 /* Adjust bit 59 to bit 51   */

  00005	48 8b 44 24 08	 mov	 rax, QWORD PTR etod$[rsp]
  0000a	48 c1 e0 08	 shl	 rax, 8

; 215  : }

  0000e	c3		 ret	 0
ETOD_high64_to_TOD_high56 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\clock.h
_TEXT	SEGMENT
result$ = 32
temp$ = 40
time$1 = 48
__$ArrayPad$ = 64
host_tod PROC

; 565  : {

  00000	48 83 ec 58	 sub	 rsp, 88			; 00000058H
  00004	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  0000b	48 33 c4	 xor	 rax, rsp
  0000e	48 89 44 24 40	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 566  :   register TOD  result;
; 567  :   register U64  temp;
; 568  : 
; 569  :   /* Use the same clock source as host_ETOD().
; 570  :      Refer to host_ETOD() in clock.c for additional comments.
; 571  :    */
; 572  : 
; 573  : #if !defined( _MSVC_ ) && !defined( CLOCK_REALTIME )
; 574  :   {
; 575  :     struct timeval time;
; 576  :     gettimeofday( &time, NULL );    /* Get current host time         */
; 577  :     result = time.tv_usec << 4;     /* Adjust microseconds to bit-59 */
; 578  :     temp   = time.tv_sec;           /* Load seconds                  */
; 579  :   }
; 580  : #else
; 581  :   {
; 582  :     struct timespec time;
; 583  :     clock_gettime( CLOCK_REALTIME, &time );

  00013	48 8d 54 24 30	 lea	 rdx, QWORD PTR time$1[rsp]
  00018	33 c9		 xor	 ecx, ecx
  0001a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_clock_gettime

; 584  :     result  = time.tv_nsec;         /* Adjust nanoseconds to bit-59  */

  00020	48 63 44 24 38	 movsxd	 rax, DWORD PTR time$1[rsp+8]
  00025	48 89 44 24 20	 mov	 QWORD PTR result$[rsp], rax

; 585  :     result <<= 1;                   /* and divide by 1000

  0002a	48 8b 44 24 20	 mov	 rax, QWORD PTR result$[rsp]
  0002f	48 d1 e0	 shl	 rax, 1
  00032	48 89 44 24 20	 mov	 QWORD PTR result$[rsp], rax

; 586  :                                        (bit-shift compressed)        */
; 587  :     result  /= 125;                 /* ...                           */

  00037	33 d2		 xor	 edx, edx
  00039	48 8b 44 24 20	 mov	 rax, QWORD PTR result$[rsp]
  0003e	b9 7d 00 00 00	 mov	 ecx, 125		; 0000007dH
  00043	48 f7 f1	 div	 rcx
  00046	48 89 44 24 20	 mov	 QWORD PTR result$[rsp], rax

; 588  :     temp     = time.tv_sec;         /* Load seconds                  */

  0004b	48 8b 44 24 30	 mov	 rax, QWORD PTR time$1[rsp]
  00050	48 89 44 24 28	 mov	 QWORD PTR temp$[rsp], rax

; 589  :    }
; 590  : #endif /* !defined( _MSVC_ ) && !defined( CLOCK_REALTIME ) */
; 591  : 
; 592  :   temp   *= ETOD_SEC;               /* Convert seconds to ETOD fmt   */

  00055	48 69 44 24 28
	00 24 f4 00	 imul	 rax, QWORD PTR temp$[rsp], 16000000 ; 00f42400H
  0005e	48 89 44 24 28	 mov	 QWORD PTR temp$[rsp], rax

; 593  :   result += temp;                   /* Add seconds                   */

  00063	48 8b 44 24 28	 mov	 rax, QWORD PTR temp$[rsp]
  00068	48 8b 4c 24 20	 mov	 rcx, QWORD PTR result$[rsp]
  0006d	48 03 c8	 add	 rcx, rax
  00070	48 8b c1	 mov	 rax, rcx
  00073	48 89 44 24 20	 mov	 QWORD PTR result$[rsp], rax

; 594  :   result += ETOD_1970;              /* Adjust to epoch 1970          */

  00078	48 b8 00 00 ca
	8b 04 91 7d 00	 mov	 rax, 35343820800000000	; 007d91048bca0000H
  00082	48 8b 4c 24 20	 mov	 rcx, QWORD PTR result$[rsp]
  00087	48 03 c8	 add	 rcx, rax
  0008a	48 8b c1	 mov	 rax, rcx
  0008d	48 89 44 24 20	 mov	 QWORD PTR result$[rsp], rax

; 595  :   return ( result );

  00092	48 8b 44 24 20	 mov	 rax, QWORD PTR result$[rsp]

; 596  : }

  00097	48 8b 4c 24 40	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  0009c	48 33 cc	 xor	 rcx, rsp
  0009f	e8 00 00 00 00	 call	 __security_check_cookie
  000a4	48 83 c4 58	 add	 rsp, 88			; 00000058H
  000a8	c3		 ret	 0
host_tod ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\hmalloc.h
_TEXT	SEGMENT
result$ = 32
size$ = 64
alignment$ = 72
calloc_aligned PROC

; 151  :     {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	57		 push	 rdi
  0000b	48 83 ec 30	 sub	 rsp, 48			; 00000030H

; 152  :         void* result;
; 153  : 
; 154  :         if (!size)

  0000f	48 83 7c 24 40
	00		 cmp	 QWORD PTR size$[rsp], 0
  00015	75 04		 jne	 SHORT $LN2@calloc_ali

; 155  :         {
; 156  :             return (NULL);

  00017	33 c0		 xor	 eax, eax
  00019	eb 30		 jmp	 SHORT $LN1@calloc_ali
$LN2@calloc_ali:

; 157  :         }
; 158  : 
; 159  :         result = _aligned_malloc(size, alignment);

  0001b	48 8b 54 24 48	 mov	 rdx, QWORD PTR alignment$[rsp]
  00020	48 8b 4c 24 40	 mov	 rcx, QWORD PTR size$[rsp]
  00025	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__aligned_malloc
  0002b	48 89 44 24 20	 mov	 QWORD PTR result$[rsp], rax

; 160  : 
; 161  :         if (result != NULL)

  00030	48 83 7c 24 20
	00		 cmp	 QWORD PTR result$[rsp], 0
  00036	74 0e		 je	 SHORT $LN3@calloc_ali

; 162  :         {
; 163  :             memset(result, 0, size);

  00038	48 8b 7c 24 20	 mov	 rdi, QWORD PTR result$[rsp]
  0003d	33 c0		 xor	 eax, eax
  0003f	48 8b 4c 24 40	 mov	 rcx, QWORD PTR size$[rsp]
  00044	f3 aa		 rep stosb
$LN3@calloc_ali:

; 164  :         }
; 165  : 
; 166  :         return (result);

  00046	48 8b 44 24 20	 mov	 rax, QWORD PTR result$[rsp]
$LN1@calloc_ali:

; 167  :     }

  0004b	48 83 c4 30	 add	 rsp, 48			; 00000030H
  0004f	5f		 pop	 rdi
  00050	c3		 ret	 0
calloc_aligned ENDP
_TEXT	ENDS
END
