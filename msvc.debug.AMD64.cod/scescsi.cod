; Listing generated by Microsoft (R) Optimizing Compiler Version 19.34.31937.0 

include listing.inc

INCLUDELIB MSVCRTD
INCLUDELIB OLDNAMES

PUBLIC	n2flist
_DATA	SEGMENT
n2flist	DQ	FLAT:$SG169590
	DD	03H
	ORG $+4
	DQ	FLAT:$SG169591
	DD	02H
	ORG $+4
	DQ	FLAT:$SG169592
	DD	01H
	ORG $+4
	DQ	0000000000000000H
	DD	00H
	ORG $+4
$SG169590 DB	'config', 00H
	ORG $+1
$SG169591 DB	'scsiboot', 00H
	ORG $+3
$SG169592 DB	'type_1', 00H
_DATA	ENDS
CONST	SEGMENT
CKD_ENDTRK DB	0ffH
	DB	0ffH
	DB	0ffH
	DB	0ffH
	DB	0ffH
	DB	0ffH
	DB	0ffH
	DB	0ffH
CONST	ENDS
PUBLIC	__local_stdio_printf_options
PUBLIC	__local_stdio_scanf_options
PUBLIC	_vsnprintf_l
PUBLIC	_vsprintf_l
PUBLIC	sprintf
PUBLIC	_vsscanf_l
PUBLIC	sscanf
PUBLIC	s370_sdias_store_status_clear
PUBLIC	s370_sdias_store_status
PUBLIC	support_boot
PUBLIC	load_boot
PUBLIC	hwldr_cmd
PUBLIC	lddev_cmd
PUBLIC	fetch_hw_noswap
PUBLIC	store_hw_noswap
PUBLIC	fetch_fw_noswap
PUBLIC	store_fw_noswap
PUBLIC	fetch_dw_noswap
PUBLIC	store_dw_noswap
PUBLIC	_get_storekey_ptr
PUBLIC	_get_storekey1_ptr
PUBLIC	_get_storekey2_ptr
PUBLIC	s370_store_boot_parms
PUBLIC	s370_load_boot
PUBLIC	s390_sclp_hwl_request
PUBLIC	s390_sclp_hwl_event
PUBLIC	s390_sclp_sdias_request
PUBLIC	s390_sclp_sdias_event
PUBLIC	s390_sdias_store_status_clear
PUBLIC	s390_sdias_store_status
PUBLIC	s390__or_storage_key
PUBLIC	s390_or_4K_storage_key
PUBLIC	s390_or_storage_key
PUBLIC	s390_store_boot_parms
PUBLIC	s390_load_boot
PUBLIC	z900_sclp_hwl_request
PUBLIC	z900_sclp_hwl_event
PUBLIC	z900_sclp_sdias_request
PUBLIC	z900_sclp_sdias_event
PUBLIC	z900_sdias_store_status_clear
PUBLIC	z900_sdias_store_status
PUBLIC	z900__or_storage_key
PUBLIC	z900_or_4K_storage_key
PUBLIC	z900_or_storage_key
PUBLIC	z900_store_boot_parms
PUBLIC	z900_load_boot
EXTRN	__imp_islower:PROC
EXTRN	__imp_isdigit:PROC
EXTRN	__imp_toupper:PROC
EXTRN	__imp__errno:PROC
EXTRN	__imp__stricmp:PROC
EXTRN	strlen:PROC
EXTRN	__imp__strnicmp:PROC
EXTRN	__imp_strdup:PROC
EXTRN	__imp_free:PROC
EXTRN	__imp_malloc:PROC
EXTRN	_byteswap_ushort:PROC
EXTRN	_byteswap_ulong:PROC
EXTRN	_byteswap_uint64:PROC
EXTRN	__imp_close:PROC
EXTRN	__imp_open:PROC
EXTRN	__imp_read:PROC
EXTRN	__imp___acrt_iob_func:PROC
EXTRN	__imp___stdio_common_vsprintf:PROC
EXTRN	__imp___stdio_common_vsscanf:PROC
EXTRN	__imp__stat64:PROC
EXTRN	__imp_hthread_obtain_lock:PROC
EXTRN	__imp_hthread_release_lock:PROC
EXTRN	__imp_hthread_signal_condition:PROC
EXTRN	__imp_hthread_wait_condition:PROC
EXTRN	__imp_hthread_create_thread:PROC
EXTRN	__imp_w32_strerror:PROC
EXTRN	__imp_w32_snprintf:PROC
EXTRN	s370_common_load_begin:PROC
EXTRN	s370_common_load_finish:PROC
EXTRN	s370_load_main:PROC
EXTRN	sclp_attention:PROC
EXTRN	__imp_fwritemsg:PROC
EXTRN	s390_common_load_begin:PROC
EXTRN	s390_common_load_finish:PROC
EXTRN	s390_load_main:PROC
EXTRN	z900_common_load_begin:PROC
EXTRN	z900_common_load_finish:PROC
EXTRN	z900_load_main:PROC
EXTRN	__GSHandlerCheck:PROC
EXTRN	__security_check_cookie:PROC
EXTRN	__imp_sysblk:BYTE
EXTRN	__security_cookie:QWORD
_DATA	SEGMENT
COMM	?_OptionsStorage@?1??__local_stdio_printf_options@@9@9:QWORD							; `__local_stdio_printf_options'::`2'::_OptionsStorage
COMM	?_OptionsStorage@?1??__local_stdio_scanf_options@@9@9:QWORD							; `__local_stdio_scanf_options'::`2'::_OptionsStorage
_DATA	ENDS
_BSS	SEGMENT
scsi_lddev_wwpn DQ 02H DUP (?)
scsi_lddev_lun DQ 02H DUP (?)
scsi_lddev_prog DD 02H DUP (?)
scsi_lddev_brlba DQ 02H DUP (?)
scsi_lddev_scpdata DQ 02H DUP (?)
hwl_tid	DD	01H DUP (?)
	ALIGN	8

hwl_fn	DQ	08H DUP (?)
sdias_hsa DQ	01H DUP (?)
sdias_size DD	01H DUP (?)
?static_hwl_bk@?1??s390_hwl_request@@9@9 DB 02aH DUP (?) ; `s390_hwl_request'::`2'::static_hwl_bk
	ALIGN	4

?hwl_pending@?1??s390_hwl_request@@9@9 DD 01H DUP (?)	; `s390_hwl_request'::`2'::hwl_pending
?static_hwl_bk@?1??z900_hwl_request@@9@9 DB 02aH DUP (?) ; `z900_hwl_request'::`2'::static_hwl_bk
	ALIGN	4

?hwl_pending@?1??z900_hwl_request@@9@9 DD 01H DUP (?)	; `z900_hwl_request'::`2'::hwl_pending
?name@?1??file2name@@9@9 DB 08H DUP (?)			; `file2name'::`2'::name
_BSS	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$_vsnprintf_l DD imagerel $LN5
	DD	imagerel $LN5+118
	DD	imagerel $unwind$_vsnprintf_l
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$_vsprintf_l DD imagerel $LN3
	DD	imagerel $LN3+66
	DD	imagerel $unwind$_vsprintf_l
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$sprintf DD imagerel $LN3
	DD	imagerel $LN3+79
	DD	imagerel $unwind$sprintf
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$_vsscanf_l DD imagerel $LN3
	DD	imagerel $LN3+80
	DD	imagerel $unwind$_vsscanf_l
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$sscanf DD imagerel $LN3
	DD	imagerel $LN3+79
	DD	imagerel $unwind$sscanf
pdata	ENDS
pdata	SEGMENT
$pdata$s370_sdias_store_status_clear DD imagerel $LN7
	DD	imagerel $LN7+64
	DD	imagerel $unwind$s370_sdias_store_status_clear
$pdata$s370_sdias_store_status DD imagerel $LN11
	DD	imagerel $LN11+226
	DD	imagerel $unwind$s370_sdias_store_status
$pdata$support_boot DD imagerel $LN9
	DD	imagerel $LN9+231
	DD	imagerel $unwind$support_boot
$pdata$load_boot DD imagerel $LN12
	DD	imagerel $LN12+174
	DD	imagerel $unwind$load_boot
$pdata$hwldr_cmd DD imagerel $LN26
	DD	imagerel $LN26+1038
	DD	imagerel $unwind$hwldr_cmd
$pdata$lddev_cmd DD imagerel $LN37
	DD	imagerel $LN37+2112
	DD	imagerel $unwind$lddev_cmd
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$fetch_hw_noswap DD imagerel $LN3
	DD	imagerel $LN3+30
	DD	imagerel $unwind$fetch_hw_noswap
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$fetch_fw_noswap DD imagerel $LN3
	DD	imagerel $LN3+27
	DD	imagerel $unwind$fetch_fw_noswap
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$fetch_dw_noswap DD imagerel $LN3
	DD	imagerel $LN3+30
	DD	imagerel $unwind$fetch_dw_noswap
pdata	ENDS
pdata	SEGMENT
$pdata$Interrupt_Lock_Obtained DD imagerel Interrupt_Lock_Obtained
	DD	imagerel Interrupt_Lock_Obtained+269
	DD	imagerel $unwind$Interrupt_Lock_Obtained
$pdata$Obtain_Interrupt_Lock DD imagerel Obtain_Interrupt_Lock
	DD	imagerel Obtain_Interrupt_Lock+88
	DD	imagerel $unwind$Obtain_Interrupt_Lock
$pdata$Release_Interrupt_Lock DD imagerel Release_Interrupt_Lock
	DD	imagerel Release_Interrupt_Lock+71
	DD	imagerel $unwind$Release_Interrupt_Lock
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$_get_storekey_ptr DD imagerel $LN5
	DD	imagerel $LN5+104
	DD	imagerel $unwind$_get_storekey_ptr
pdata	ENDS
pdata	SEGMENT
$pdata$s370_store_boot_parms DD imagerel $LN12
	DD	imagerel $LN12+1390
	DD	imagerel $unwind$s370_store_boot_parms
$pdata$s370_load_boot DD imagerel $LN8
	DD	imagerel $LN8+431
	DD	imagerel $unwind$s370_load_boot
$pdata$s390_sclp_hwl_request DD imagerel $LN9
	DD	imagerel $LN9+340
	DD	imagerel $unwind$s390_sclp_hwl_request
$pdata$s390_sclp_hwl_event DD imagerel $LN5
	DD	imagerel $LN5+229
	DD	imagerel $unwind$s390_sclp_hwl_event
$pdata$s390_sclp_sdias_request DD imagerel $LN3
	DD	imagerel $LN3+64
	DD	imagerel $unwind$s390_sclp_sdias_request
$pdata$s390_sdias_store_status_clear DD imagerel $LN7
	DD	imagerel $LN7+64
	DD	imagerel $unwind$s390_sdias_store_status_clear
$pdata$s390_sdias_store_status DD imagerel $LN11
	DD	imagerel $LN11+226
	DD	imagerel $unwind$s390_sdias_store_status
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$s390__or_storage_key DD imagerel $LN8
	DD	imagerel $LN8+159
	DD	imagerel $unwind$s390__or_storage_key
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$s390_or_4K_storage_key DD imagerel $LN3
	DD	imagerel $LN3+42
	DD	imagerel $unwind$s390_or_4K_storage_key
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$s390_or_storage_key DD imagerel $LN3
	DD	imagerel $LN3+33
	DD	imagerel $unwind$s390_or_storage_key
pdata	ENDS
pdata	SEGMENT
$pdata$s390_load_pages DD imagerel s390_load_pages
	DD	imagerel s390_load_pages+687
	DD	imagerel $unwind$s390_load_pages
$pdata$s390_walk_table DD imagerel s390_walk_table
	DD	imagerel s390_walk_table+260
	DD	imagerel $unwind$s390_walk_table
$pdata$s390_hwl_loadfile DD imagerel s390_hwl_loadfile
	DD	imagerel s390_hwl_loadfile+578
	DD	imagerel $unwind$s390_hwl_loadfile
$pdata$s390_hwl_thread DD imagerel s390_hwl_thread
	DD	imagerel s390_hwl_thread+563
	DD	imagerel $unwind$s390_hwl_thread
$pdata$s390_hwl_request DD imagerel s390_hwl_request
	DD	imagerel s390_hwl_request+398
	DD	imagerel $unwind$s390_hwl_request
$pdata$s390_store_boot_parms DD imagerel $LN12
	DD	imagerel $LN12+1390
	DD	imagerel $unwind$s390_store_boot_parms
$pdata$s390_load_boot DD imagerel $LN8
	DD	imagerel $LN8+431
	DD	imagerel $unwind$s390_load_boot
$pdata$z900_sclp_hwl_request DD imagerel $LN9
	DD	imagerel $LN9+340
	DD	imagerel $unwind$z900_sclp_hwl_request
$pdata$z900_sclp_hwl_event DD imagerel $LN5
	DD	imagerel $LN5+229
	DD	imagerel $unwind$z900_sclp_hwl_event
$pdata$z900_sclp_sdias_request DD imagerel $LN3
	DD	imagerel $LN3+64
	DD	imagerel $unwind$z900_sclp_sdias_request
$pdata$z900_sdias_store_status_clear DD imagerel $LN7
	DD	imagerel $LN7+64
	DD	imagerel $unwind$z900_sdias_store_status_clear
$pdata$z900_sdias_store_status DD imagerel $LN11
	DD	imagerel $LN11+226
	DD	imagerel $unwind$z900_sdias_store_status
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$z900__or_storage_key DD imagerel $LN8
	DD	imagerel $LN8+159
	DD	imagerel $unwind$z900__or_storage_key
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$z900_or_4K_storage_key DD imagerel $LN3
	DD	imagerel $LN3+42
	DD	imagerel $unwind$z900_or_4K_storage_key
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$z900_or_storage_key DD imagerel $LN3
	DD	imagerel $LN3+33
	DD	imagerel $unwind$z900_or_storage_key
pdata	ENDS
pdata	SEGMENT
$pdata$z900_load_pages DD imagerel z900_load_pages
	DD	imagerel z900_load_pages+704
	DD	imagerel $unwind$z900_load_pages
$pdata$z900_walk_table DD imagerel z900_walk_table
	DD	imagerel z900_walk_table+281
	DD	imagerel $unwind$z900_walk_table
$pdata$z900_hwl_loadfile DD imagerel z900_hwl_loadfile
	DD	imagerel z900_hwl_loadfile+702
	DD	imagerel $unwind$z900_hwl_loadfile
$pdata$z900_hwl_thread DD imagerel z900_hwl_thread
	DD	imagerel z900_hwl_thread+588
	DD	imagerel $unwind$z900_hwl_thread
$pdata$z900_hwl_request DD imagerel z900_hwl_request
	DD	imagerel z900_hwl_request+398
	DD	imagerel $unwind$z900_hwl_request
$pdata$z900_store_boot_parms DD imagerel $LN12
	DD	imagerel $LN12+1390
	DD	imagerel $unwind$z900_store_boot_parms
$pdata$z900_load_boot DD imagerel $LN8
	DD	imagerel $LN8+431
	DD	imagerel $unwind$z900_load_boot
$pdata$file2name DD imagerel file2name
	DD	imagerel file2name+126
	DD	imagerel $unwind$file2name
$pdata$validate_boot DD imagerel validate_boot
	DD	imagerel validate_boot+57
	DD	imagerel $unwind$validate_boot
pdata	ENDS
_DATA	SEGMENT
	ORG $+1
$SG169677 DB	'E', 00H
	ORG $+2
$SG169678 DB	'HHC00655%s Store Status save to HSA failed', 0aH, 00H
$SG169723 DB	'ipl', 00H
$SG169679 DB	's370_sdias_store_status', 00H
$SG169680 DB	'scescsi.c', 00H
	ORG $+2
$SG169757 DB	'E', 00H
	ORG $+2
$SG169720 DB	'<?xml version="1.0" encoding ="UTF-8"?>', 0aH, 00H
	ORG $+3
$SG179799 DB	'table', 00H
	ORG $+2
$SG179800 DB	'E', 00H
	ORG $+2
$SG169721 DB	'<eServer_ipl_script version="1.0">', 0aH, 00H
$SG169722 DB	'dump', 00H
	ORG $+3
$SG179807 DB	'E', 00H
	ORG $+2
$SG169724 DB	'<type>%s</type>', 0aH, 00H
	ORG $+3
$SG179812 DB	'E', 00H
	ORG $+2
$SG169725 DB	'<ipl_control_section id="herculesipl-1">', 0aH, 00H
	ORG $+2
$SG179851 DB	'E', 00H
	ORG $+2
$SG169726 DB	'<ipl_platform_loader>', 0aH, 00H
	ORG $+1
$SG169727 DB	'<fcp_ipl>', 0aH, 00H
	ORG $+1
$SG179855 DB	'I', 00H
	ORG $+2
$SG169728 DB	'<devno>0x%4.4X</devno>', 0aH, 00H
$SG169729 DB	'<wwpn>0x%16.16llX</wwpn>', 0aH, 00H
	ORG $+2
$SG179861 DB	'E', 00H
	ORG $+2
$SG169730 DB	'<lun>0x%16.16llX</lun>', 0aH, 00H
$SG169731 DB	'<boot_program_selector>0x%8.8X</boot_program_selector>', 0aH
	DB	00H
$SG169732 DB	'<br_lba>0x%16.16llX</br_lba>', 0aH, 00H
	ORG $+2
$SG169733 DB	'</fcp_ipl>', 0aH, 00H
$SG179884 DB	'E', 00H
	ORG $+2
$SG169734 DB	'</ipl_platform_loader>', 0aH, 00H
$SG169736 DB	'<system_control_program>', 0aH, 00H
	ORG $+2
$SG179889 DB	'E', 00H
	ORG $+2
$SG169737 DB	'<parameter_string>%s</parameter_string>', 0aH, 00H
	ORG $+3
$SG179920 DB	'E', 00H
	ORG $+2
$SG169738 DB	'</system_control_program>', 0aH, 00H
	ORG $+1
$SG179936 DB	'I', 00H
	ORG $+2
$SG169739 DB	'</ipl_control_section>', 0aH, 00H
$SG169740 DB	'</eServer_ipl_script>', 0aH, 00H
	ORG $+1
$SG169758 DB	'HHC00656%s Cannot load bootstrap loader %s: %s', 0aH, 00H
$SG169759 DB	's370_load_boot', 00H
	ORG $+1
$SG169760 DB	'scescsi.c', 00H
	ORG $+2
$SG179981 DB	'E', 00H
	ORG $+2
$SG179801 DB	'HHC00659%s %s is outside of main storage', 0aH, 00H
	ORG $+2
$SG180027 DB	'ipl', 00H
$SG179802 DB	's390_load_pages', 00H
$SG179803 DB	'C:\papa\MyGit\hyperion-zvector\scescsi.c', 00H
	ORG $+3
$SG179806 DB	'page', 00H
	ORG $+3
$SG180061 DB	'E', 00H
	ORG $+2
$SG179808 DB	'HHC00659%s %s is outside of main storage', 0aH, 00H
	ORG $+2
$SG192982 DB	'E', 00H
	ORG $+2
$SG179809 DB	's390_load_pages', 00H
$SG179810 DB	'C:\papa\MyGit\hyperion-zvector\scescsi.c', 00H
	ORG $+3
$SG192981 DB	'table', 00H
	ORG $+2
$SG192989 DB	'E', 00H
	ORG $+2
$SG179813 DB	'HHC00658%s I/O error on read(): rc=%d: "%s"', 0aH, 00H
	ORG $+3
$SG179814 DB	's390_load_pages', 00H
$SG179815 DB	'C:\papa\MyGit\hyperion-zvector\scescsi.c', 00H
	ORG $+3
$SG192994 DB	'E', 00H
	ORG $+2
$SG179852 DB	'HHC00650%s %s open error: %s', 0aH, 00H
	ORG $+2
$SG179853 DB	's390_hwl_loadfile', 00H
	ORG $+2
$SG193033 DB	'E', 00H
	ORG $+2
$SG179854 DB	'C:\papa\MyGit\hyperion-zvector\scescsi.c', 00H
	ORG $+3
$SG193037 DB	'I', 00H
	ORG $+2
$SG179856 DB	'HHC00651%s Loading %s', 0aH, 00H
	ORG $+1
$SG179857 DB	's390_hwl_loadfile', 00H
	ORG $+2
$SG193043 DB	'E', 00H
	ORG $+2
$SG179858 DB	'C:\papa\MyGit\hyperion-zvector\scescsi.c', 00H
	ORG $+3
$SG179860 DB	'asce', 00H
	ORG $+3
$SG193069 DB	'E', 00H
	ORG $+2
$SG179862 DB	'HHC00659%s %s is outside of main storage', 0aH, 00H
	ORG $+2
$SG193076 DB	'E', 00H
	ORG $+2
$SG179863 DB	's390_hwl_loadfile', 00H
	ORG $+2
$SG193107 DB	'E', 00H
	ORG $+2
$SG179864 DB	'C:\papa\MyGit\hyperion-zvector\scescsi.c', 00H
	ORG $+3
$SG193123 DB	'I', 00H
	ORG $+2
$SG179885 DB	'HHC00652%s Hardware loader %s: %s', 0aH, 00H
	ORG $+1
$SG193168 DB	'E', 00H
	ORG $+2
$SG179886 DB	's390_hwl_thread', 00H
$SG179887 DB	'C:\papa\MyGit\hyperion-zvector\scescsi.c', 00H
	ORG $+3
$SG193214 DB	'ipl', 00H
$SG179890 DB	'HHC00653%s Hardware loader file type %d not supported', 0aH
	DB	00H
	ORG $+1
$SG179891 DB	's390_hwl_thread', 00H
$SG179892 DB	'C:\papa\MyGit\hyperion-zvector\scescsi.c', 00H
	ORG $+3
$SG193248 DB	'E', 00H
	ORG $+2
$SG179893 DB	'C:\papa\MyGit\hyperion-zvector\scescsi.c:428', 00H
	ORG $+3
$SG179894 DB	'C:\papa\MyGit\hyperion-zvector\scescsi.c:430', 00H
	ORG $+3
$SG179917 DB	'C:\papa\MyGit\hyperion-zvector\scescsi.c:481', 00H
	ORG $+3
$SG179918 DB	'hwl_thread', 00H
	ORG $+1
$SG193297 DB	'E', 00H
	ORG $+2
$SG179921 DB	'HHC00654%s Unknown hardware loader request type %2.2X', 0aH
	DB	00H
	ORG $+1
$SG179922 DB	's390_hwl_request', 00H
	ORG $+3
$SG193264 DB	'type%u', 00H
	ORG $+1
$SG193307 DB	'I', 00H
	ORG $+2
$SG179923 DB	'C:\papa\MyGit\hyperion-zvector\scescsi.c', 00H
	ORG $+3
$SG179933 DB	'INFO', 00H
	ORG $+3
$SG179934 DB	'LOAD', 00H
	ORG $+3
$SG193312 DB	'I', 00H
	ORG $+2
$SG179935 DB	'unknown', 00H
$SG179937 DB	'HHC00661%s Hardware loader: %s request: SCCB = 0x%llX', 0aH
	DB	00H
	ORG $+1
$SG179938 DB	's390_sclp_hwl_request', 00H
	ORG $+2
$SG179939 DB	'C:\papa\MyGit\hyperion-zvector\scescsi.c', 00H
	ORG $+3
$SG193341 DB	'%llx%c', 00H
	ORG $+1
$SG193343 DB	'E', 00H
	ORG $+2
$SG179982 DB	'HHC00655%s Store Status save to HSA failed', 0aH, 00H
$SG193349 DB	'lun', 00H
$SG179983 DB	's390_sdias_store_status', 00H
$SG179984 DB	'C:\papa\MyGit\hyperion-zvector\scescsi.c', 00H
	ORG $+3
$SG193351 DB	'%llx%c', 00H
	ORG $+1
$SG193352 DB	'LUN', 00H
$SG180024 DB	'<?xml version="1.0" encoding ="UTF-8"?>', 0aH, 00H
	ORG $+3
$SG193353 DB	'E', 00H
	ORG $+2
$SG180025 DB	'<eServer_ipl_script version="1.0">', 0aH, 00H
$SG180026 DB	'dump', 00H
	ORG $+3
$SG193363 DB	'E', 00H
	ORG $+2
$SG180028 DB	'<type>%s</type>', 0aH, 00H
	ORG $+3
$SG193369 DB	'br_lba', 00H
	ORG $+1
$SG193373 DB	'E', 00H
	ORG $+2
$SG180029 DB	'<ipl_control_section id="herculesipl-1">', 0aH, 00H
	ORG $+2
$SG193371 DB	'%llx%c', 00H
	ORG $+1
$SG193383 DB	'E', 00H
	ORG $+2
$SG180030 DB	'<ipl_platform_loader>', 0aH, 00H
	ORG $+1
$SG180031 DB	'<fcp_ipl>', 0aH, 00H
	ORG $+1
$SG193388 DB	'I', 00H
	ORG $+2
$SG180032 DB	'<devno>0x%4.4X</devno>', 0aH, 00H
$SG180033 DB	'<wwpn>0x%16.16llX</wwpn>', 0aH, 00H
	ORG $+2
$SG193372 DB	'BR_LBA', 00H
	ORG $+1
$SG193393 DB	'I', 00H
	ORG $+2
$SG180034 DB	'<lun>0x%16.16llX</lun>', 0aH, 00H
$SG180035 DB	'<boot_program_selector>0x%8.8X</boot_program_selector>', 0aH
	DB	00H
$SG180036 DB	'<br_lba>0x%16.16llX</br_lba>', 0aH, 00H
	ORG $+2
$SG180037 DB	'</fcp_ipl>', 0aH, 00H
$SG193398 DB	'I', 00H
	ORG $+2
$SG180038 DB	'</ipl_platform_loader>', 0aH, 00H
$SG180040 DB	'<system_control_program>', 0aH, 00H
	ORG $+2
$SG193403 DB	'I', 00H
	ORG $+2
$SG180041 DB	'<parameter_string>%s</parameter_string>', 0aH, 00H
	ORG $+3
$SG193408 DB	'I', 00H
	ORG $+2
$SG180042 DB	'</system_control_program>', 0aH, 00H
	ORG $+5
$SG180043 DB	'</ipl_control_section>', 0aH, 00H
$SG180044 DB	'</eServer_ipl_script>', 0aH, 00H
	ORG $+1
$SG180062 DB	'HHC00656%s Cannot load bootstrap loader %s: %s', 0aH, 00H
$SG180063 DB	's390_load_boot', 00H
	ORG $+1
$SG180064 DB	'C:\papa\MyGit\hyperion-zvector\scescsi.c', 00H
	ORG $+7
$SG192983 DB	'HHC00659%s %s is outside of main storage', 0aH, 00H
	ORG $+6
$SG192984 DB	'z900_load_pages', 00H
$SG192985 DB	'C:\papa\MyGit\hyperion-zvector\scescsi.c', 00H
	ORG $+3
$SG192988 DB	'page', 00H
	ORG $+7
$SG192990 DB	'HHC00659%s %s is outside of main storage', 0aH, 00H
	ORG $+6
$SG192991 DB	'z900_load_pages', 00H
$SG192992 DB	'C:\papa\MyGit\hyperion-zvector\scescsi.c', 00H
	ORG $+7
$SG192995 DB	'HHC00658%s I/O error on read(): rc=%d: "%s"', 0aH, 00H
	ORG $+3
$SG192996 DB	'z900_load_pages', 00H
$SG192997 DB	'C:\papa\MyGit\hyperion-zvector\scescsi.c', 00H
	ORG $+7
$SG193034 DB	'HHC00650%s %s open error: %s', 0aH, 00H
	ORG $+2
$SG193035 DB	'z900_hwl_loadfile', 00H
	ORG $+6
$SG193036 DB	'C:\papa\MyGit\hyperion-zvector\scescsi.c', 00H
	ORG $+7
$SG193038 DB	'HHC00651%s Loading %s', 0aH, 00H
	ORG $+1
$SG193039 DB	'z900_hwl_loadfile', 00H
	ORG $+6
$SG193040 DB	'C:\papa\MyGit\hyperion-zvector\scescsi.c', 00H
	ORG $+3
$SG193042 DB	'asce', 00H
	ORG $+7
$SG193044 DB	'HHC00659%s %s is outside of main storage', 0aH, 00H
	ORG $+6
$SG193045 DB	'z900_hwl_loadfile', 00H
	ORG $+6
$SG193046 DB	'C:\papa\MyGit\hyperion-zvector\scescsi.c', 00H
	ORG $+7
$SG193070 DB	'HHC00652%s Hardware loader %s: %s', 0aH, 00H
	ORG $+5
$SG193071 DB	'z900_hwl_thread', 00H
$SG193072 DB	'C:\papa\MyGit\hyperion-zvector\scescsi.c', 00H
	ORG $+7
$SG193077 DB	'HHC00653%s Hardware loader file type %d not supported', 0aH
	DB	00H
	ORG $+1
$SG193078 DB	'z900_hwl_thread', 00H
$SG193079 DB	'C:\papa\MyGit\hyperion-zvector\scescsi.c', 00H
	ORG $+7
$SG193080 DB	'C:\papa\MyGit\hyperion-zvector\scescsi.c:428', 00H
	ORG $+3
$SG193081 DB	'C:\papa\MyGit\hyperion-zvector\scescsi.c:430', 00H
	ORG $+3
$SG193104 DB	'C:\papa\MyGit\hyperion-zvector\scescsi.c:481', 00H
	ORG $+3
$SG193105 DB	'hwl_thread', 00H
	ORG $+5
$SG193108 DB	'HHC00654%s Unknown hardware loader request type %2.2X', 0aH
	DB	00H
	ORG $+1
$SG193109 DB	'z900_hwl_request', 00H
	ORG $+7
$SG193110 DB	'C:\papa\MyGit\hyperion-zvector\scescsi.c', 00H
	ORG $+3
$SG193120 DB	'INFO', 00H
	ORG $+3
$SG193121 DB	'LOAD', 00H
	ORG $+7
$SG193122 DB	'unknown', 00H
$SG193124 DB	'HHC00661%s Hardware loader: %s request: SCCB = 0x%llX', 0aH
	DB	00H
	ORG $+1
$SG193125 DB	'z900_sclp_hwl_request', 00H
	ORG $+2
$SG193126 DB	'C:\papa\MyGit\hyperion-zvector\scescsi.c', 00H
	ORG $+7
$SG193169 DB	'HHC00655%s Store Status save to HSA failed', 0aH, 00H
	ORG $+4
$SG193170 DB	'z900_sdias_store_status', 00H
$SG193171 DB	'C:\papa\MyGit\hyperion-zvector\scescsi.c', 00H
	ORG $+7
$SG193211 DB	'<?xml version="1.0" encoding ="UTF-8"?>', 0aH, 00H
	ORG $+7
$SG193212 DB	'<eServer_ipl_script version="1.0">', 0aH, 00H
$SG193213 DB	'dump', 00H
	ORG $+7
$SG193215 DB	'<type>%s</type>', 0aH, 00H
	ORG $+7
$SG193216 DB	'<ipl_control_section id="herculesipl-1">', 0aH, 00H
	ORG $+6
$SG193217 DB	'<ipl_platform_loader>', 0aH, 00H
	ORG $+1
$SG193218 DB	'<fcp_ipl>', 0aH, 00H
	ORG $+5
$SG193219 DB	'<devno>0x%4.4X</devno>', 0aH, 00H
$SG193220 DB	'<wwpn>0x%16.16llX</wwpn>', 0aH, 00H
	ORG $+6
$SG193221 DB	'<lun>0x%16.16llX</lun>', 0aH, 00H
$SG193222 DB	'<boot_program_selector>0x%8.8X</boot_program_selector>', 0aH
	DB	00H
$SG193223 DB	'<br_lba>0x%16.16llX</br_lba>', 0aH, 00H
	ORG $+2
$SG193224 DB	'</fcp_ipl>', 0aH, 00H
	ORG $+4
$SG193225 DB	'</ipl_platform_loader>', 0aH, 00H
$SG193227 DB	'<system_control_program>', 0aH, 00H
	ORG $+6
$SG193228 DB	'<parameter_string>%s</parameter_string>', 0aH, 00H
	ORG $+7
$SG193229 DB	'</system_control_program>', 0aH, 00H
	ORG $+5
$SG193230 DB	'</ipl_control_section>', 0aH, 00H
$SG193231 DB	'</eServer_ipl_script>', 0aH, 00H
	ORG $+1
$SG193249 DB	'HHC00656%s Cannot load bootstrap loader %s: %s', 0aH, 00H
$SG193250 DB	'z900_load_boot', 00H
	ORG $+1
$SG193251 DB	'C:\papa\MyGit\hyperion-zvector\scescsi.c', 00H
	ORG $+3
$SG193294 DB	'type', 00H
	ORG $+3
$SG193295 DB	'%u%c', 00H
	ORG $+7
$SG193298 DB	'HHC00657%s Invalid file %s', 0aH, 00H
	ORG $+4
$SG193299 DB	'hwldr_cmd', 00H
	ORG $+6
$SG193300 DB	'C:\papa\MyGit\hyperion-zvector\scescsi.c', 00H
	ORG $+3
$SG193306 DB	'none', 00H
	ORG $+7
$SG193308 DB	'HHC00660%s %-8s %s', 0aH, 00H
	ORG $+4
$SG193309 DB	'hwldr_cmd', 00H
	ORG $+6
$SG193310 DB	'C:\papa\MyGit\hyperion-zvector\scescsi.c', 00H
	ORG $+7
$SG193313 DB	'HHC00660%s %-8s %s', 0aH, 00H
	ORG $+4
$SG193314 DB	'hwldr_cmd', 00H
	ORG $+6
$SG193315 DB	'C:\papa\MyGit\hyperion-zvector\scescsi.c', 00H
	ORG $+7
$SG193339 DB	'portname', 00H
	ORG $+7
$SG193342 DB	'PORTNAME', 00H
	ORG $+7
$SG193344 DB	'HHC00670%s Invalid %s', 0aH, 00H
	ORG $+1
$SG193345 DB	'lddev_cmd', 00H
	ORG $+6
$SG193346 DB	'C:\papa\MyGit\hyperion-zvector\scescsi.c', 00H
	ORG $+7
$SG193354 DB	'HHC00670%s Invalid %s', 0aH, 00H
	ORG $+1
$SG193355 DB	'lddev_cmd', 00H
	ORG $+6
$SG193356 DB	'C:\papa\MyGit\hyperion-zvector\scescsi.c', 00H
	ORG $+7
$SG193359 DB	'bootprog', 00H
	ORG $+3
$SG193361 DB	'%x%c', 00H
	ORG $+7
$SG193362 DB	'BOOTPROG', 00H
	ORG $+7
$SG193364 DB	'HHC00670%s Invalid %s', 0aH, 00H
	ORG $+1
$SG193365 DB	'lddev_cmd', 00H
	ORG $+6
$SG193366 DB	'C:\papa\MyGit\hyperion-zvector\scescsi.c', 00H
	ORG $+7
$SG193374 DB	'HHC00670%s Invalid %s', 0aH, 00H
	ORG $+1
$SG193375 DB	'lddev_cmd', 00H
	ORG $+6
$SG193376 DB	'C:\papa\MyGit\hyperion-zvector\scescsi.c', 00H
	ORG $+7
$SG193379 DB	'scpdata', 00H
$SG193384 DB	'HHC00671%s Invalid option %s', 0aH, 00H
	ORG $+2
$SG193385 DB	'lddev_cmd', 00H
	ORG $+6
$SG193386 DB	'C:\papa\MyGit\hyperion-zvector\scescsi.c', 00H
	ORG $+7
$SG193389 DB	'HHC00680%s portname %16.16llx', 0aH, 00H
	ORG $+1
$SG193390 DB	'lddev_cmd', 00H
	ORG $+6
$SG193391 DB	'C:\papa\MyGit\hyperion-zvector\scescsi.c', 00H
	ORG $+7
$SG193394 DB	'HHC00681%s lun      %16.16llx', 0aH, 00H
	ORG $+1
$SG193395 DB	'lddev_cmd', 00H
	ORG $+6
$SG193396 DB	'C:\papa\MyGit\hyperion-zvector\scescsi.c', 00H
	ORG $+7
$SG193399 DB	'HHC00682%s bootprog %8.8x', 0aH, 00H
	ORG $+5
$SG193400 DB	'lddev_cmd', 00H
	ORG $+6
$SG193401 DB	'C:\papa\MyGit\hyperion-zvector\scescsi.c', 00H
	ORG $+7
$SG193404 DB	'HHC00683%s br_lba   %16.16llx', 0aH, 00H
	ORG $+1
$SG193405 DB	'lddev_cmd', 00H
	ORG $+6
$SG193406 DB	'C:\papa\MyGit\hyperion-zvector\scescsi.c', 00H
	ORG $+7
$SG193409 DB	'HHC00684%s scpdata  %s', 0aH, 00H
$SG193410 DB	'lddev_cmd', 00H
	ORG $+6
$SG193411 DB	'C:\papa\MyGit\hyperion-zvector\scescsi.c', 00H
_DATA	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$z900_or_storage_key DD 010d01H
	DD	0420dH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$z900_or_4K_storage_key DD 010d01H
	DD	0420dH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$z900__or_storage_key DD 011201H
	DD	08212H
xdata	ENDS
voltbl	SEGMENT
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:z900_hwl_thread
	DD	016H
	DD	0234H
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:s390_hwl_thread
	DD	016H
	DD	021bH
voltbl	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$s390_or_storage_key DD 010d01H
	DD	0420dH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$s390_or_4K_storage_key DD 010d01H
	DD	0420dH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$s390__or_storage_key DD 011201H
	DD	08212H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$_get_storekey_ptr DD 010d01H
	DD	0220dH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$fetch_dw_noswap DD 010901H
	DD	02209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$fetch_fw_noswap DD 010901H
	DD	02209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$fetch_hw_noswap DD 010901H
	DD	02209H
xdata	ENDS
xdata	SEGMENT
$unwind$s370_sdias_store_status_clear DD 010901H
	DD	04209H
$unwind$s370_sdias_store_status DD 030b01H
	DD	07007a20bH
	DD	06006H
$unwind$support_boot DD 010901H
	DD	06209H
$unwind$load_boot DD 011701H
	DD	06217H
$unwind$hwldr_cmd DD 021501H
	DD	0150115H
$unwind$lddev_cmd DD 021501H
	DD	0170115H
$unwind$Interrupt_Lock_Obtained DD 010e01H
	DD	0420eH
$unwind$Obtain_Interrupt_Lock DD 010e01H
	DD	0420eH
$unwind$Release_Interrupt_Lock DD 010e01H
	DD	0420eH
$unwind$s370_store_boot_parms DD 030f01H
	DD	0700ba20fH
	DD	0600aH
$unwind$s370_load_boot DD 021a01H
	DD	011011aH
$unwind$s390_sclp_hwl_request DD 020c01H
	DD	011010cH
$unwind$s390_sclp_hwl_event DD 020a01H
	DD	07006520aH
$unwind$s390_sclp_sdias_request DD 010901H
	DD	02209H
$unwind$s390_sdias_store_status_clear DD 010901H
	DD	04209H
$unwind$s390_sdias_store_status DD 030b01H
	DD	07007a20bH
	DD	06006H
$unwind$s390_load_pages DD 021401H
	DD	0110114H
$unwind$s390_walk_table DD 011601H
	DD	08216H
$unwind$s390_hwl_loadfile DD 020c01H
	DD	013010cH
$unwind$s390_hwl_thread DD 021e19H
	DD	019010cH
	DD	imagerel __GSHandlerCheck
	DD	0b8H
$unwind$s390_hwl_request DD 030f01H
	DD	0700bc20fH
	DD	0600aH
$unwind$s390_store_boot_parms DD 030f01H
	DD	0700ba20fH
	DD	0600aH
$unwind$s390_load_boot DD 021a01H
	DD	011011aH
$unwind$z900_sclp_hwl_request DD 020c01H
	DD	011010cH
$unwind$z900_sclp_hwl_event DD 020a01H
	DD	07006520aH
$unwind$z900_sclp_sdias_request DD 010901H
	DD	02209H
$unwind$z900_sdias_store_status_clear DD 010901H
	DD	04209H
$unwind$z900_sdias_store_status DD 030b01H
	DD	07007a20bH
	DD	06006H
$unwind$z900_load_pages DD 021501H
	DD	0110115H
$unwind$z900_walk_table DD 011701H
	DD	08217H
$unwind$z900_hwl_loadfile DD 020c01H
	DD	013010cH
$unwind$z900_hwl_thread DD 021e19H
	DD	019010cH
	DD	imagerel __GSHandlerCheck
	DD	0b8H
$unwind$z900_hwl_request DD 030f01H
	DD	0700bc20fH
	DD	0600aH
$unwind$z900_store_boot_parms DD 030f01H
	DD	0700ba20fH
	DD	0600aH
$unwind$z900_load_boot DD 021a01H
	DD	011011aH
$unwind$file2name DD 010801H
	DD	06208H
$unwind$validate_boot DD 010801H
	DD	02208H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$sscanf DD 011801H
	DD	06218H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$_vsscanf_l DD 011801H
	DD	06218H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$sprintf DD 011801H
	DD	06218H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$_vsprintf_l DD 011801H
	DD	06218H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$_vsnprintf_l DD 011801H
	DD	08218H
xdata	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\scescsi.c
_TEXT	SEGMENT
tv69 = 0
file$ = 32
validate_boot PROC

; 990  : {

  00000	89 4c 24 08	 mov	 DWORD PTR [rsp+8], ecx
  00004	48 83 ec 18	 sub	 rsp, 24

; 991  :     return ((file < HWL_MAXFILETYPE && hwl_fn[file]) ? (int) file : -1);

  00008	83 7c 24 20 08	 cmp	 DWORD PTR file$[rsp], 8
  0000d	73 1b		 jae	 SHORT $LN3@validate_b
  0000f	8b 44 24 20	 mov	 eax, DWORD PTR file$[rsp]
  00013	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:hwl_fn
  0001a	48 83 3c c1 00	 cmp	 QWORD PTR [rcx+rax*8], 0
  0001f	74 09		 je	 SHORT $LN3@validate_b
  00021	8b 44 24 20	 mov	 eax, DWORD PTR file$[rsp]
  00025	89 04 24	 mov	 DWORD PTR tv69[rsp], eax
  00028	eb 07		 jmp	 SHORT $LN4@validate_b
$LN3@validate_b:
  0002a	c7 04 24 ff ff
	ff ff		 mov	 DWORD PTR tv69[rsp], -1
$LN4@validate_b:
  00031	8b 04 24	 mov	 eax, DWORD PTR tv69[rsp]

; 992  : }

  00034	48 83 c4 18	 add	 rsp, 24
  00038	c3		 ret	 0
validate_boot ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\scescsi.c
_TEXT	SEGMENT
ntf$ = 32
file$ = 64
file2name PROC

; 825  : {

  00000	89 4c 24 08	 mov	 DWORD PTR [rsp+8], ecx
  00004	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 826  : struct name2file *ntf;
; 827  : static char name[8];
; 828  : 
; 829  :     for(ntf = n2flist; ntf->name && ntf->file != file; ntf++);

  00008	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:n2flist
  0000f	48 89 44 24 20	 mov	 QWORD PTR ntf$[rsp], rax
  00014	eb 0e		 jmp	 SHORT $LN4@file2name
$LN2@file2name:
  00016	48 8b 44 24 20	 mov	 rax, QWORD PTR ntf$[rsp]
  0001b	48 83 c0 10	 add	 rax, 16
  0001f	48 89 44 24 20	 mov	 QWORD PTR ntf$[rsp], rax
$LN4@file2name:
  00024	48 8b 44 24 20	 mov	 rax, QWORD PTR ntf$[rsp]
  00029	48 83 38 00	 cmp	 QWORD PTR [rax], 0
  0002d	74 10		 je	 SHORT $LN3@file2name
  0002f	48 8b 44 24 20	 mov	 rax, QWORD PTR ntf$[rsp]
  00034	8b 4c 24 40	 mov	 ecx, DWORD PTR file$[rsp]
  00038	39 48 08	 cmp	 DWORD PTR [rax+8], ecx
  0003b	74 02		 je	 SHORT $LN3@file2name
  0003d	eb d7		 jmp	 SHORT $LN2@file2name
$LN3@file2name:

; 830  : 
; 831  :     if(ntf->name)

  0003f	48 8b 44 24 20	 mov	 rax, QWORD PTR ntf$[rsp]
  00044	48 83 38 00	 cmp	 QWORD PTR [rax], 0
  00048	74 0a		 je	 SHORT $LN5@file2name

; 832  :         return ntf->name;

  0004a	48 8b 44 24 20	 mov	 rax, QWORD PTR ntf$[rsp]
  0004f	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00052	eb 25		 jmp	 SHORT $LN1@file2name
$LN5@file2name:

; 833  : 
; 834  :     MSGBUF(name,"type%u",file);

  00054	44 8b 4c 24 40	 mov	 r9d, DWORD PTR file$[rsp]
  00059	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG193264
  00060	ba 08 00 00 00	 mov	 edx, 8
  00065	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:?name@?1??file2name@@9@9
  0006c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_snprintf

; 835  : 
; 836  :     return name;

  00072	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:?name@?1??file2name@@9@9
$LN1@file2name:

; 837  : }

  00079	48 83 c4 38	 add	 rsp, 56			; 00000038H
  0007d	c3		 ret	 0
file2name ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\scescsi.c
_TEXT	SEGMENT
bootfile$ = 80
tv87 = 88
tv150 = 96
tv91 = 104
regs$ = 112
dev$ = 144
cpu$ = 152
clear$ = 160
ldind$ = 168
z900_load_boot PROC

; 759  : {

$LN8:
  00000	44 89 4c 24 20	 mov	 DWORD PTR [rsp+32], r9d
  00005	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  0000a	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  0000e	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00013	48 81 ec 88 00
	00 00		 sub	 rsp, 136		; 00000088H

; 760  : REGS *regs = sysblk.regs[cpu];

  0001a	48 63 84 24 98
	00 00 00	 movsxd	 rax, DWORD PTR cpu$[rsp]
  00022	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  00029	48 8b 84 c1 98
	0b 00 00	 mov	 rax, QWORD PTR [rcx+rax*8+2968]
  00031	48 89 44 24 70	 mov	 QWORD PTR regs$[rsp], rax

; 761  : int bootfile;
; 762  : 
; 763  :     bootfile = support_boot(dev);

  00036	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  0003e	e8 00 00 00 00	 call	 support_boot
  00043	89 44 24 50	 mov	 DWORD PTR bootfile$[rsp], eax

; 764  : 
; 765  :     if(bootfile < 0 || !hwl_fn[bootfile])

  00047	83 7c 24 50 00	 cmp	 DWORD PTR bootfile$[rsp], 0
  0004c	7c 13		 jl	 SHORT $LN3@z900_load_
  0004e	48 63 44 24 50	 movsxd	 rax, DWORD PTR bootfile$[rsp]
  00053	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:hwl_fn
  0005a	48 83 3c c1 00	 cmp	 QWORD PTR [rcx+rax*8], 0
  0005f	75 0a		 jne	 SHORT $LN2@z900_load_
$LN3@z900_load_:

; 766  :         return -1; // Should not occur, has been validated.

  00061	b8 ff ff ff ff	 mov	 eax, -1
  00066	e9 3c 01 00 00	 jmp	 $LN1@z900_load_
$LN2@z900_load_:

; 767  : 
; 768  :     if (ARCH_DEP(common_load_begin) (cpu, clear) != 0)

  0006b	8b 94 24 a0 00
	00 00		 mov	 edx, DWORD PTR clear$[rsp]
  00072	8b 8c 24 98 00
	00 00		 mov	 ecx, DWORD PTR cpu$[rsp]
  00079	e8 00 00 00 00	 call	 z900_common_load_begin
  0007e	85 c0		 test	 eax, eax
  00080	74 0a		 je	 SHORT $LN4@z900_load_

; 769  :         return -1;

  00082	b8 ff ff ff ff	 mov	 eax, -1
  00087	e9 1b 01 00 00	 jmp	 $LN1@z900_load_
$LN4@z900_load_:

; 770  : 
; 771  :     if( ARCH_DEP(load_main) (hwl_fn[bootfile], 0, 0) < 0)

  0008c	48 63 44 24 50	 movsxd	 rax, DWORD PTR bootfile$[rsp]
  00091	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:hwl_fn
  00098	45 33 c0	 xor	 r8d, r8d
  0009b	33 d2		 xor	 edx, edx
  0009d	48 8b 0c c1	 mov	 rcx, QWORD PTR [rcx+rax*8]
  000a1	e8 00 00 00 00	 call	 z900_load_main
  000a6	85 c0		 test	 eax, eax
  000a8	0f 8d 94 00 00
	00		 jge	 $LN5@z900_load_

; 772  :     {
; 773  :         // "Cannot load bootstrap loader %s: %s"
; 774  :         WRMSG( HHC00656, "E", hwl_fn[ bootfile ], strerror( errno ));

  000ae	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno
  000b4	8b 08		 mov	 ecx, DWORD PTR [rax]
  000b6	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_strerror
  000bc	48 89 44 24 58	 mov	 QWORD PTR tv87[rsp], rax
  000c1	48 63 4c 24 50	 movsxd	 rcx, DWORD PTR bootfile$[rsp]
  000c6	48 89 4c 24 68	 mov	 QWORD PTR tv91[rsp], rcx
  000cb	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:hwl_fn
  000d2	48 89 54 24 60	 mov	 QWORD PTR tv150[rsp], rdx
  000d7	b9 01 00 00 00	 mov	 ecx, 1
  000dc	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  000e2	48 8b 4c 24 58	 mov	 rcx, QWORD PTR tv87[rsp]
  000e7	48 89 4c 24 40	 mov	 QWORD PTR [rsp+64], rcx
  000ec	48 8b 4c 24 60	 mov	 rcx, QWORD PTR tv150[rsp]
  000f1	48 8b 54 24 68	 mov	 rdx, QWORD PTR tv91[rsp]
  000f6	48 8b 0c d1	 mov	 rcx, QWORD PTR [rcx+rdx*8]
  000fa	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  000ff	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG193248
  00106	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  0010b	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG193249
  00112	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00117	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  0011c	41 b9 03 00 00
	00		 mov	 r9d, 3
  00122	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG193250
  00129	ba 06 03 00 00	 mov	 edx, 774		; 00000306H
  0012e	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG193251
  00135	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 775  :         return -1;

  0013b	b8 ff ff ff ff	 mov	 eax, -1
  00140	eb 65		 jmp	 SHORT $LN1@z900_load_
$LN5@z900_load_:

; 776  :     }
; 777  :     sysblk.main_clear = sysblk.xpnd_clear = 0;

  00142	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00149	8b 80 94 12 00
	00		 mov	 eax, DWORD PTR [rax+4756]
  0014f	0f ba f0 0f	 btr	 eax, 15
  00153	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  0015a	89 81 94 12 00
	00		 mov	 DWORD PTR [rcx+4756], eax
  00160	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00167	8b 80 94 12 00
	00		 mov	 eax, DWORD PTR [rax+4756]
  0016d	0f ba f0 0e	 btr	 eax, 14
  00171	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  00178	89 81 94 12 00
	00		 mov	 DWORD PTR [rcx+4756], eax

; 778  : 
; 779  :     if( ARCH_DEP(store_boot_parms)(dev, ldind) )

  0017e	8b 94 24 a8 00
	00 00		 mov	 edx, DWORD PTR ldind$[rsp]
  00185	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  0018d	e8 00 00 00 00	 call	 z900_store_boot_parms
  00192	85 c0		 test	 eax, eax
  00194	74 07		 je	 SHORT $LN6@z900_load_

; 780  :         return -1;

  00196	b8 ff ff ff ff	 mov	 eax, -1
  0019b	eb 0a		 jmp	 SHORT $LN1@z900_load_
$LN6@z900_load_:

; 781  : 
; 782  :     return ARCH_DEP(common_load_finish)(regs);

  0019d	48 8b 4c 24 70	 mov	 rcx, QWORD PTR regs$[rsp]
  001a2	e8 00 00 00 00	 call	 z900_common_load_finish
$LN1@z900_load_:

; 783  : }

  001a7	48 81 c4 88 00
	00 00		 add	 rsp, 136		; 00000088H
  001ae	c3		 ret	 0
z900_load_boot ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\scescsi.c
_TEXT	SEGMENT
scp_len$ = 32
tv80 = 36
xml$ = 40
sb_bk$ = 48
tv212 = 56
psa$ = 64
dev$ = 112
ldind$ = 120
z900_store_boot_parms PROC

; 685  : {

$LN12:
  00000	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00004	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00009	56		 push	 rsi
  0000a	57		 push	 rdi
  0000b	48 83 ec 58	 sub	 rsp, 88			; 00000058H

; 686  : PSA *psa;
; 687  : SCSI_BOOT_BK *sb_bk;
; 688  : BYTE *xml;
; 689  : int scp_len;
; 690  : 
; 691  :     if(sysblk.mainsize < (BOOT_PARM_ADDR + 0x1000))

  0000f	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00016	48 81 b8 90 00
	00 00 00 e0 ff
	01		 cmp	 QWORD PTR [rax+144], 33546240 ; 01ffe000H
  00021	73 0a		 jae	 SHORT $LN2@z900_store

; 692  :         return -1;

  00023	b8 ff ff ff ff	 mov	 eax, -1
  00028	e9 3a 05 00 00	 jmp	 $LN1@z900_store
$LN2@z900_store:

; 693  : 
; 694  :     psa = (PSA*)sysblk.mainstor;

  0002d	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00034	48 8b 80 98 00
	00 00		 mov	 rax, QWORD PTR [rax+152]
  0003b	48 89 44 24 40	 mov	 QWORD PTR psa$[rsp], rax

; 695  : 
; 696  :     STORE_DW(psa->iplccw2,BOOT_PARM_ADDR);

  00040	b9 00 d0 ff 01	 mov	 ecx, 33542144		; 01ffd000H
  00045	e8 00 00 00 00	 call	 _byteswap_uint64
  0004a	48 8b 4c 24 40	 mov	 rcx, QWORD PTR psa$[rsp]
  0004f	48 83 c1 10	 add	 rcx, 16
  00053	48 8b d0	 mov	 rdx, rax
  00056	e8 00 00 00 00	 call	 store_dw_noswap

; 697  : 
; 698  :     sb_bk = (SCSI_BOOT_BK*)(sysblk.mainstor + BOOT_PARM_ADDR);

  0005b	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00062	48 8b 80 98 00
	00 00		 mov	 rax, QWORD PTR [rax+152]
  00069	48 05 00 d0 ff
	01		 add	 rax, 33542144		; 01ffd000H
  0006f	48 89 44 24 30	 mov	 QWORD PTR sb_bk$[rsp], rax

; 699  :     memset(sb_bk,0x00,0x1000);

  00074	48 8b 7c 24 30	 mov	 rdi, QWORD PTR sb_bk$[rsp]
  00079	33 c0		 xor	 eax, eax
  0007b	b9 00 10 00 00	 mov	 ecx, 4096		; 00001000H
  00080	f3 aa		 rep stosb

; 700  : 
; 701  :     sb_bk->ldind = ldind ? SCSI_BOOT_LDIND_DUMP : SCSI_BOOT_LDIND_LOAD;

  00082	83 7c 24 78 00	 cmp	 DWORD PTR ldind$[rsp], 0
  00087	74 0a		 je	 SHORT $LN8@z900_store
  00089	c7 44 24 24 20
	00 00 00	 mov	 DWORD PTR tv80[rsp], 32	; 00000020H
  00091	eb 08		 jmp	 SHORT $LN9@z900_store
$LN8@z900_store:
  00093	c7 44 24 24 10
	00 00 00	 mov	 DWORD PTR tv80[rsp], 16
$LN9@z900_store:
  0009b	48 8b 44 24 30	 mov	 rax, QWORD PTR sb_bk$[rsp]
  000a0	0f b6 4c 24 24	 movzx	 ecx, BYTE PTR tv80[rsp]
  000a5	88 88 48 01 00
	00		 mov	 BYTE PTR [rax+328], cl

; 702  : 
; 703  :     STORE_HW(sb_bk->devno,dev->devnum);

  000ab	48 8b 44 24 70	 mov	 rax, QWORD PTR dev$[rsp]
  000b0	0f b7 48 48	 movzx	 ecx, WORD PTR [rax+72]
  000b4	e8 00 00 00 00	 call	 _byteswap_ushort
  000b9	48 8b 4c 24 30	 mov	 rcx, QWORD PTR sb_bk$[rsp]
  000be	48 81 c1 4e 01
	00 00		 add	 rcx, 334		; 0000014eH
  000c5	0f b7 d0	 movzx	 edx, ax
  000c8	e8 00 00 00 00	 call	 store_hw_noswap

; 704  :     STORE_DW(sb_bk->wwpn,scsi_lddev_wwpn[ldind]);

  000cd	48 63 44 24 78	 movsxd	 rax, DWORD PTR ldind$[rsp]
  000d2	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:scsi_lddev_wwpn
  000d9	48 8b 0c c1	 mov	 rcx, QWORD PTR [rcx+rax*8]
  000dd	e8 00 00 00 00	 call	 _byteswap_uint64
  000e2	48 8b 4c 24 30	 mov	 rcx, QWORD PTR sb_bk$[rsp]
  000e7	48 81 c1 54 01
	00 00		 add	 rcx, 340		; 00000154H
  000ee	48 8b d0	 mov	 rdx, rax
  000f1	e8 00 00 00 00	 call	 store_dw_noswap

; 705  :     STORE_DW(sb_bk->lun,scsi_lddev_lun[ldind]);

  000f6	48 63 44 24 78	 movsxd	 rax, DWORD PTR ldind$[rsp]
  000fb	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:scsi_lddev_lun
  00102	48 8b 0c c1	 mov	 rcx, QWORD PTR [rcx+rax*8]
  00106	e8 00 00 00 00	 call	 _byteswap_uint64
  0010b	48 8b 4c 24 30	 mov	 rcx, QWORD PTR sb_bk$[rsp]
  00110	48 81 c1 5c 01
	00 00		 add	 rcx, 348		; 0000015cH
  00117	48 8b d0	 mov	 rdx, rax
  0011a	e8 00 00 00 00	 call	 store_dw_noswap

; 706  :     STORE_FW(sb_bk->prog,scsi_lddev_prog[ldind]);

  0011f	48 63 44 24 78	 movsxd	 rax, DWORD PTR ldind$[rsp]
  00124	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:scsi_lddev_prog
  0012b	8b 0c 81	 mov	 ecx, DWORD PTR [rcx+rax*4]
  0012e	e8 00 00 00 00	 call	 _byteswap_ulong
  00133	48 8b 4c 24 30	 mov	 rcx, QWORD PTR sb_bk$[rsp]
  00138	48 81 c1 64 01
	00 00		 add	 rcx, 356		; 00000164H
  0013f	8b d0		 mov	 edx, eax
  00141	e8 00 00 00 00	 call	 store_fw_noswap

; 707  :     STORE_DW(sb_bk->brlba,scsi_lddev_brlba[ldind]);

  00146	48 63 44 24 78	 movsxd	 rax, DWORD PTR ldind$[rsp]
  0014b	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:scsi_lddev_brlba
  00152	48 8b 0c c1	 mov	 rcx, QWORD PTR [rcx+rax*8]
  00156	e8 00 00 00 00	 call	 _byteswap_uint64
  0015b	48 8b 4c 24 30	 mov	 rcx, QWORD PTR sb_bk$[rsp]
  00160	48 81 c1 74 01
	00 00		 add	 rcx, 372		; 00000174H
  00167	48 8b d0	 mov	 rdx, rax
  0016a	e8 00 00 00 00	 call	 store_dw_noswap

; 708  : 
; 709  :     if(scsi_lddev_scpdata[ldind])

  0016f	48 63 44 24 78	 movsxd	 rax, DWORD PTR ldind$[rsp]
  00174	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:scsi_lddev_scpdata
  0017b	48 83 3c c1 00	 cmp	 QWORD PTR [rcx+rax*8], 0
  00180	74 6f		 je	 SHORT $LN3@z900_store

; 710  :     {
; 711  :         scp_len = strlen((char*)scsi_lddev_scpdata[ldind]);

  00182	48 63 44 24 78	 movsxd	 rax, DWORD PTR ldind$[rsp]
  00187	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:scsi_lddev_scpdata
  0018e	48 8b 0c c1	 mov	 rcx, QWORD PTR [rcx+rax*8]
  00192	e8 00 00 00 00	 call	 strlen
  00197	89 44 24 20	 mov	 DWORD PTR scp_len$[rsp], eax

; 712  :         if(scp_len > 256)

  0019b	81 7c 24 20 00
	01 00 00	 cmp	 DWORD PTR scp_len$[rsp], 256 ; 00000100H
  001a3	7e 08		 jle	 SHORT $LN5@z900_store

; 713  :             scp_len = 256; // Sanity check

  001a5	c7 44 24 20 00
	01 00 00	 mov	 DWORD PTR scp_len$[rsp], 256 ; 00000100H
$LN5@z900_store:

; 714  :         STORE_FW(sb_bk->scp_len,scp_len);

  001ad	8b 4c 24 20	 mov	 ecx, DWORD PTR scp_len$[rsp]
  001b1	e8 00 00 00 00	 call	 _byteswap_ulong
  001b6	48 8b 4c 24 30	 mov	 rcx, QWORD PTR sb_bk$[rsp]
  001bb	48 81 c1 7c 01
	00 00		 add	 rcx, 380		; 0000017cH
  001c2	8b d0		 mov	 edx, eax
  001c4	e8 00 00 00 00	 call	 store_fw_noswap

; 715  :         memcpy((BYTE*)(sb_bk+1), scsi_lddev_scpdata[ldind], scp_len);

  001c9	48 63 44 24 20	 movsxd	 rax, DWORD PTR scp_len$[rsp]
  001ce	48 63 4c 24 78	 movsxd	 rcx, DWORD PTR ldind$[rsp]
  001d3	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:scsi_lddev_scpdata
  001da	48 8b 7c 24 30	 mov	 rdi, QWORD PTR sb_bk$[rsp]
  001df	48 81 c7 84 02
	00 00		 add	 rdi, 644		; 00000284H
  001e6	48 8b 34 ca	 mov	 rsi, QWORD PTR [rdx+rcx*8]
  001ea	48 8b c8	 mov	 rcx, rax
  001ed	f3 a4		 rep movsb

; 716  :     }

  001ef	eb 08		 jmp	 SHORT $LN4@z900_store
$LN3@z900_store:

; 717  :     else
; 718  :         scp_len = 0;

  001f1	c7 44 24 20 00
	00 00 00	 mov	 DWORD PTR scp_len$[rsp], 0
$LN4@z900_store:

; 719  : 
; 720  :     scp_len += 7;

  001f9	8b 44 24 20	 mov	 eax, DWORD PTR scp_len$[rsp]
  001fd	83 c0 07	 add	 eax, 7
  00200	89 44 24 20	 mov	 DWORD PTR scp_len$[rsp], eax

; 721  :     scp_len &= ~7;

  00204	8b 44 24 20	 mov	 eax, DWORD PTR scp_len$[rsp]
  00208	83 e0 f8	 and	 eax, -8
  0020b	89 44 24 20	 mov	 DWORD PTR scp_len$[rsp], eax

; 722  : 
; 723  :     STORE_FW(sb_bk->xml_off,sizeof(SCSI_BOOT_BK) + scp_len);

  0020f	48 63 44 24 20	 movsxd	 rax, DWORD PTR scp_len$[rsp]
  00214	48 05 84 02 00
	00		 add	 rax, 644		; 00000284H
  0021a	8b c8		 mov	 ecx, eax
  0021c	e8 00 00 00 00	 call	 _byteswap_ulong
  00221	48 8b 4c 24 30	 mov	 rcx, QWORD PTR sb_bk$[rsp]
  00226	8b d0		 mov	 edx, eax
  00228	e8 00 00 00 00	 call	 store_fw_noswap

; 724  : 
; 725  :     STORE_FW(sb_bk->scp_off,sizeof(SCSI_BOOT_BK) + scp_len - 8); // ZZ:???

  0022d	48 63 44 24 20	 movsxd	 rax, DWORD PTR scp_len$[rsp]
  00232	48 05 7c 02 00
	00		 add	 rax, 636		; 0000027cH
  00238	8b c8		 mov	 ecx, eax
  0023a	e8 00 00 00 00	 call	 _byteswap_ulong
  0023f	48 8b 4c 24 30	 mov	 rcx, QWORD PTR sb_bk$[rsp]
  00244	48 83 c1 08	 add	 rcx, 8
  00248	8b d0		 mov	 edx, eax
  0024a	e8 00 00 00 00	 call	 store_fw_noswap

; 726  : 
; 727  :     xml = (BYTE*)(sb_bk+1) + scp_len;

  0024f	48 63 44 24 20	 movsxd	 rax, DWORD PTR scp_len$[rsp]
  00254	48 8b 4c 24 30	 mov	 rcx, QWORD PTR sb_bk$[rsp]
  00259	48 8d 84 01 84
	02 00 00	 lea	 rax, QWORD PTR [rcx+rax+644]
  00261	48 89 44 24 28	 mov	 QWORD PTR xml$[rsp], rax

; 728  : 
; 729  :     xml += sprintf((char*)xml, "<?xml version=\"1.0\" encoding =\"UTF-8\"?>\n" );

  00266	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG193211
  0026d	48 8b 4c 24 28	 mov	 rcx, QWORD PTR xml$[rsp]
  00272	e8 00 00 00 00	 call	 sprintf
  00277	48 98		 cdqe
  00279	48 8b 4c 24 28	 mov	 rcx, QWORD PTR xml$[rsp]
  0027e	48 03 c8	 add	 rcx, rax
  00281	48 8b c1	 mov	 rax, rcx
  00284	48 89 44 24 28	 mov	 QWORD PTR xml$[rsp], rax

; 730  :     xml += sprintf((char*)xml, "<eServer_ipl_script version=\"1.0\">\n" );

  00289	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG193212
  00290	48 8b 4c 24 28	 mov	 rcx, QWORD PTR xml$[rsp]
  00295	e8 00 00 00 00	 call	 sprintf
  0029a	48 98		 cdqe
  0029c	48 8b 4c 24 28	 mov	 rcx, QWORD PTR xml$[rsp]
  002a1	48 03 c8	 add	 rcx, rax
  002a4	48 8b c1	 mov	 rax, rcx
  002a7	48 89 44 24 28	 mov	 QWORD PTR xml$[rsp], rax

; 731  :     xml += sprintf((char*)xml,  "<type>%s</type>\n", ldind ? "dump" : "ipl" );

  002ac	83 7c 24 78 00	 cmp	 DWORD PTR ldind$[rsp], 0
  002b1	74 0e		 je	 SHORT $LN10@z900_store
  002b3	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG193213
  002ba	48 89 44 24 38	 mov	 QWORD PTR tv212[rsp], rax
  002bf	eb 0c		 jmp	 SHORT $LN11@z900_store
$LN10@z900_store:
  002c1	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG193214
  002c8	48 89 44 24 38	 mov	 QWORD PTR tv212[rsp], rax
$LN11@z900_store:
  002cd	4c 8b 44 24 38	 mov	 r8, QWORD PTR tv212[rsp]
  002d2	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG193215
  002d9	48 8b 4c 24 28	 mov	 rcx, QWORD PTR xml$[rsp]
  002de	e8 00 00 00 00	 call	 sprintf
  002e3	48 98		 cdqe
  002e5	48 8b 4c 24 28	 mov	 rcx, QWORD PTR xml$[rsp]
  002ea	48 03 c8	 add	 rcx, rax
  002ed	48 8b c1	 mov	 rax, rcx
  002f0	48 89 44 24 28	 mov	 QWORD PTR xml$[rsp], rax

; 732  :     xml += sprintf((char*)xml,  "<ipl_control_section id=\"herculesipl-1\">\n" );

  002f5	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG193216
  002fc	48 8b 4c 24 28	 mov	 rcx, QWORD PTR xml$[rsp]
  00301	e8 00 00 00 00	 call	 sprintf
  00306	48 98		 cdqe
  00308	48 8b 4c 24 28	 mov	 rcx, QWORD PTR xml$[rsp]
  0030d	48 03 c8	 add	 rcx, rax
  00310	48 8b c1	 mov	 rax, rcx
  00313	48 89 44 24 28	 mov	 QWORD PTR xml$[rsp], rax

; 733  :     xml += sprintf((char*)xml,   "<ipl_platform_loader>\n" );

  00318	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG193217
  0031f	48 8b 4c 24 28	 mov	 rcx, QWORD PTR xml$[rsp]
  00324	e8 00 00 00 00	 call	 sprintf
  00329	48 98		 cdqe
  0032b	48 8b 4c 24 28	 mov	 rcx, QWORD PTR xml$[rsp]
  00330	48 03 c8	 add	 rcx, rax
  00333	48 8b c1	 mov	 rax, rcx
  00336	48 89 44 24 28	 mov	 QWORD PTR xml$[rsp], rax

; 734  :     xml += sprintf((char*)xml,    "<fcp_ipl>\n" );

  0033b	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG193218
  00342	48 8b 4c 24 28	 mov	 rcx, QWORD PTR xml$[rsp]
  00347	e8 00 00 00 00	 call	 sprintf
  0034c	48 98		 cdqe
  0034e	48 8b 4c 24 28	 mov	 rcx, QWORD PTR xml$[rsp]
  00353	48 03 c8	 add	 rcx, rax
  00356	48 8b c1	 mov	 rax, rcx
  00359	48 89 44 24 28	 mov	 QWORD PTR xml$[rsp], rax

; 735  :     xml += sprintf((char*)xml,     "<devno>0x%4.4X</devno>\n", dev->devnum);

  0035e	48 8b 44 24 70	 mov	 rax, QWORD PTR dev$[rsp]
  00363	0f b7 40 48	 movzx	 eax, WORD PTR [rax+72]
  00367	44 8b c0	 mov	 r8d, eax
  0036a	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG193219
  00371	48 8b 4c 24 28	 mov	 rcx, QWORD PTR xml$[rsp]
  00376	e8 00 00 00 00	 call	 sprintf
  0037b	48 98		 cdqe
  0037d	48 8b 4c 24 28	 mov	 rcx, QWORD PTR xml$[rsp]
  00382	48 03 c8	 add	 rcx, rax
  00385	48 8b c1	 mov	 rax, rcx
  00388	48 89 44 24 28	 mov	 QWORD PTR xml$[rsp], rax

; 736  :     xml += sprintf((char*)xml,     "<wwpn>0x%16.16"PRIX64"</wwpn>\n", scsi_lddev_wwpn[ldind]);

  0038d	48 63 44 24 78	 movsxd	 rax, DWORD PTR ldind$[rsp]
  00392	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:scsi_lddev_wwpn
  00399	4c 8b 04 c1	 mov	 r8, QWORD PTR [rcx+rax*8]
  0039d	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG193220
  003a4	48 8b 4c 24 28	 mov	 rcx, QWORD PTR xml$[rsp]
  003a9	e8 00 00 00 00	 call	 sprintf
  003ae	48 98		 cdqe
  003b0	48 8b 4c 24 28	 mov	 rcx, QWORD PTR xml$[rsp]
  003b5	48 03 c8	 add	 rcx, rax
  003b8	48 8b c1	 mov	 rax, rcx
  003bb	48 89 44 24 28	 mov	 QWORD PTR xml$[rsp], rax

; 737  :     xml += sprintf((char*)xml,     "<lun>0x%16.16"PRIX64"</lun>\n", scsi_lddev_lun[ldind]);

  003c0	48 63 44 24 78	 movsxd	 rax, DWORD PTR ldind$[rsp]
  003c5	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:scsi_lddev_lun
  003cc	4c 8b 04 c1	 mov	 r8, QWORD PTR [rcx+rax*8]
  003d0	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG193221
  003d7	48 8b 4c 24 28	 mov	 rcx, QWORD PTR xml$[rsp]
  003dc	e8 00 00 00 00	 call	 sprintf
  003e1	48 98		 cdqe
  003e3	48 8b 4c 24 28	 mov	 rcx, QWORD PTR xml$[rsp]
  003e8	48 03 c8	 add	 rcx, rax
  003eb	48 8b c1	 mov	 rax, rcx
  003ee	48 89 44 24 28	 mov	 QWORD PTR xml$[rsp], rax

; 738  :     xml += sprintf((char*)xml,     "<boot_program_selector>0x%8.8X</boot_program_selector>\n", scsi_lddev_prog[ldind]);

  003f3	48 63 44 24 78	 movsxd	 rax, DWORD PTR ldind$[rsp]
  003f8	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:scsi_lddev_prog
  003ff	44 8b 04 81	 mov	 r8d, DWORD PTR [rcx+rax*4]
  00403	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG193222
  0040a	48 8b 4c 24 28	 mov	 rcx, QWORD PTR xml$[rsp]
  0040f	e8 00 00 00 00	 call	 sprintf
  00414	48 98		 cdqe
  00416	48 8b 4c 24 28	 mov	 rcx, QWORD PTR xml$[rsp]
  0041b	48 03 c8	 add	 rcx, rax
  0041e	48 8b c1	 mov	 rax, rcx
  00421	48 89 44 24 28	 mov	 QWORD PTR xml$[rsp], rax

; 739  :     xml += sprintf((char*)xml,     "<br_lba>0x%16.16"PRIX64"</br_lba>\n", scsi_lddev_brlba[ldind]);

  00426	48 63 44 24 78	 movsxd	 rax, DWORD PTR ldind$[rsp]
  0042b	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:scsi_lddev_brlba
  00432	4c 8b 04 c1	 mov	 r8, QWORD PTR [rcx+rax*8]
  00436	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG193223
  0043d	48 8b 4c 24 28	 mov	 rcx, QWORD PTR xml$[rsp]
  00442	e8 00 00 00 00	 call	 sprintf
  00447	48 98		 cdqe
  00449	48 8b 4c 24 28	 mov	 rcx, QWORD PTR xml$[rsp]
  0044e	48 03 c8	 add	 rcx, rax
  00451	48 8b c1	 mov	 rax, rcx
  00454	48 89 44 24 28	 mov	 QWORD PTR xml$[rsp], rax

; 740  :     xml += sprintf((char*)xml,    "</fcp_ipl>\n" );

  00459	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG193224
  00460	48 8b 4c 24 28	 mov	 rcx, QWORD PTR xml$[rsp]
  00465	e8 00 00 00 00	 call	 sprintf
  0046a	48 98		 cdqe
  0046c	48 8b 4c 24 28	 mov	 rcx, QWORD PTR xml$[rsp]
  00471	48 03 c8	 add	 rcx, rax
  00474	48 8b c1	 mov	 rax, rcx
  00477	48 89 44 24 28	 mov	 QWORD PTR xml$[rsp], rax

; 741  :     xml += sprintf((char*)xml,   "</ipl_platform_loader>\n" );

  0047c	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG193225
  00483	48 8b 4c 24 28	 mov	 rcx, QWORD PTR xml$[rsp]
  00488	e8 00 00 00 00	 call	 sprintf
  0048d	48 98		 cdqe
  0048f	48 8b 4c 24 28	 mov	 rcx, QWORD PTR xml$[rsp]
  00494	48 03 c8	 add	 rcx, rax
  00497	48 8b c1	 mov	 rax, rcx
  0049a	48 89 44 24 28	 mov	 QWORD PTR xml$[rsp], rax

; 742  :     if(scp_len)

  0049f	83 7c 24 20 00	 cmp	 DWORD PTR scp_len$[rsp], 0
  004a4	74 79		 je	 SHORT $LN6@z900_store

; 743  :     {
; 744  :       xml += sprintf((char*)xml, "<system_control_program>\n" );

  004a6	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG193227
  004ad	48 8b 4c 24 28	 mov	 rcx, QWORD PTR xml$[rsp]
  004b2	e8 00 00 00 00	 call	 sprintf
  004b7	48 98		 cdqe
  004b9	48 8b 4c 24 28	 mov	 rcx, QWORD PTR xml$[rsp]
  004be	48 03 c8	 add	 rcx, rax
  004c1	48 8b c1	 mov	 rax, rcx
  004c4	48 89 44 24 28	 mov	 QWORD PTR xml$[rsp], rax

; 745  :       xml += sprintf((char*)xml,  "<parameter_string>%s</parameter_string>\n", scsi_lddev_scpdata[ldind]);

  004c9	48 63 44 24 78	 movsxd	 rax, DWORD PTR ldind$[rsp]
  004ce	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:scsi_lddev_scpdata
  004d5	4c 8b 04 c1	 mov	 r8, QWORD PTR [rcx+rax*8]
  004d9	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG193228
  004e0	48 8b 4c 24 28	 mov	 rcx, QWORD PTR xml$[rsp]
  004e5	e8 00 00 00 00	 call	 sprintf
  004ea	48 98		 cdqe
  004ec	48 8b 4c 24 28	 mov	 rcx, QWORD PTR xml$[rsp]
  004f1	48 03 c8	 add	 rcx, rax
  004f4	48 8b c1	 mov	 rax, rcx
  004f7	48 89 44 24 28	 mov	 QWORD PTR xml$[rsp], rax

; 746  :       xml += sprintf((char*)xml, "</system_control_program>\n" );

  004fc	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG193229
  00503	48 8b 4c 24 28	 mov	 rcx, QWORD PTR xml$[rsp]
  00508	e8 00 00 00 00	 call	 sprintf
  0050d	48 98		 cdqe
  0050f	48 8b 4c 24 28	 mov	 rcx, QWORD PTR xml$[rsp]
  00514	48 03 c8	 add	 rcx, rax
  00517	48 8b c1	 mov	 rax, rcx
  0051a	48 89 44 24 28	 mov	 QWORD PTR xml$[rsp], rax
$LN6@z900_store:

; 747  :     }
; 748  :     xml += sprintf((char*)xml,  "</ipl_control_section>\n" );

  0051f	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG193230
  00526	48 8b 4c 24 28	 mov	 rcx, QWORD PTR xml$[rsp]
  0052b	e8 00 00 00 00	 call	 sprintf
  00530	48 98		 cdqe
  00532	48 8b 4c 24 28	 mov	 rcx, QWORD PTR xml$[rsp]
  00537	48 03 c8	 add	 rcx, rax
  0053a	48 8b c1	 mov	 rax, rcx
  0053d	48 89 44 24 28	 mov	 QWORD PTR xml$[rsp], rax

; 749  :     xml += sprintf((char*)xml, "</eServer_ipl_script>\n" );

  00542	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG193231
  00549	48 8b 4c 24 28	 mov	 rcx, QWORD PTR xml$[rsp]
  0054e	e8 00 00 00 00	 call	 sprintf
  00553	48 98		 cdqe
  00555	48 8b 4c 24 28	 mov	 rcx, QWORD PTR xml$[rsp]
  0055a	48 03 c8	 add	 rcx, rax
  0055d	48 8b c1	 mov	 rax, rcx
  00560	48 89 44 24 28	 mov	 QWORD PTR xml$[rsp], rax

; 750  : 
; 751  :     return 0;

  00565	33 c0		 xor	 eax, eax
$LN1@z900_store:

; 752  : }

  00567	48 83 c4 58	 add	 rsp, 88			; 00000058H
  0056b	5f		 pop	 rdi
  0056c	5e		 pop	 rsi
  0056d	c3		 ret	 0
z900_store_boot_parms ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\scescsi.c
_TEXT	SEGMENT
tv70 = 64
pending_req$1 = 68
tv83 = 72
hwl_bk$ = 80
sclp_command$ = 128
evd_hdr$ = 136
z900_hwl_request PROC

; 439  : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	89 4c 24 08	 mov	 DWORD PTR [rsp+8], ecx
  00009	56		 push	 rsi
  0000a	57		 push	 rdi
  0000b	48 83 ec 68	 sub	 rsp, 104		; 00000068H

; 440  : SCCB_HWL_BK *hwl_bk = (SCCB_HWL_BK*)(evd_hdr + 1);

  0000f	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR evd_hdr$[rsp]
  00017	48 83 c0 06	 add	 rax, 6
  0001b	48 89 44 24 50	 mov	 QWORD PTR hwl_bk$[rsp], rax

; 441  : 
; 442  : static SCCB_HWL_BK static_hwl_bk;
; 443  : static int hwl_pending;
; 444  : 
; 445  :     if(sclp_command == SCLP_READ_EVENT_DATA)

  00020	81 bc 24 80 00
	00 00 05 00 77
	00		 cmp	 DWORD PTR sclp_command$[rsp], 7798789 ; 00770005H
  0002b	75 4c		 jne	 SHORT $LN4@z900_hwl_r

; 446  :     {
; 447  :     int pending_req = hwl_pending;

  0002d	8b 05 00 00 00
	00		 mov	 eax, DWORD PTR ?hwl_pending@?1??z900_hwl_request@@9@9
  00033	89 44 24 44	 mov	 DWORD PTR pending_req$1[rsp], eax

; 448  : 
; 449  :         /* Return no data if the hardware loader thread is still active */
; 450  :         if(hwl_tid)

  00037	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR hwl_tid, 0
  0003e	74 07		 je	 SHORT $LN5@z900_hwl_r

; 451  :             return 0;

  00040	33 c0		 xor	 eax, eax
  00042	e9 40 01 00 00	 jmp	 $LN1@z900_hwl_r
$LN5@z900_hwl_r:

; 452  : 
; 453  :         /* Update the hwl_bk copy in the SCCB */
; 454  :         if(hwl_pending)

  00047	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?hwl_pending@?1??z900_hwl_request@@9@9, 0
  0004e	74 16		 je	 SHORT $LN6@z900_hwl_r

; 455  :             *hwl_bk = static_hwl_bk;

  00050	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:?static_hwl_bk@?1??z900_hwl_request@@9@9
  00057	48 8b 7c 24 50	 mov	 rdi, QWORD PTR hwl_bk$[rsp]
  0005c	48 8b f0	 mov	 rsi, rax
  0005f	b9 2a 00 00 00	 mov	 ecx, 42			; 0000002aH
  00064	f3 a4		 rep movsb
$LN6@z900_hwl_r:

; 456  : 
; 457  :         /* Reset the pending flag */
; 458  :         hwl_pending = 0;

  00066	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?hwl_pending@?1??z900_hwl_request@@9@9, 0

; 459  : 
; 460  :         /* Return true if a request was pending */
; 461  :         return pending_req;

  00070	8b 44 24 44	 mov	 eax, DWORD PTR pending_req$1[rsp]
  00074	e9 0e 01 00 00	 jmp	 $LN1@z900_hwl_r
$LN4@z900_hwl_r:

; 462  :     }
; 463  : 
; 464  :     switch(hwl_bk->type) {

  00079	48 8b 44 24 50	 mov	 rax, QWORD PTR hwl_bk$[rsp]
  0007e	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  00081	88 44 24 40	 mov	 BYTE PTR tv70[rsp], al
  00085	80 7c 24 40 00	 cmp	 BYTE PTR tv70[rsp], 0
  0008a	74 0c		 je	 SHORT $LN8@z900_hwl_r
  0008c	80 7c 24 40 02	 cmp	 BYTE PTR tv70[rsp], 2
  00091	74 05		 je	 SHORT $LN7@z900_hwl_r
  00093	e9 8f 00 00 00	 jmp	 $LN11@z900_hwl_r
$LN7@z900_hwl_r:
$LN8@z900_hwl_r:

; 465  : 
; 466  :     case SCCB_HWL_TYPE_INFO:
; 467  :     case SCCB_HWL_TYPE_LOAD:
; 468  : 
; 469  :         /* Return error if the hwl thread is already active */
; 470  :         if( hwl_tid )

  00098	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR hwl_tid, 0
  0009f	74 0a		 je	 SHORT $LN9@z900_hwl_r

; 471  :             return -1;

  000a1	b8 ff ff ff ff	 mov	 eax, -1
  000a6	e9 dc 00 00 00	 jmp	 $LN1@z900_hwl_r
$LN9@z900_hwl_r:

; 472  : 
; 473  :         /* Take a copy of the hwl_bk in the SCCB */
; 474  :         static_hwl_bk = *hwl_bk;

  000ab	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:?static_hwl_bk@?1??z900_hwl_request@@9@9
  000b2	48 8b f8	 mov	 rdi, rax
  000b5	48 8b 74 24 50	 mov	 rsi, QWORD PTR hwl_bk$[rsp]
  000ba	b9 2a 00 00 00	 mov	 ecx, 42			; 0000002aH
  000bf	f3 a4		 rep movsb

; 475  : 
; 476  :         /* Reset pending flag */
; 477  :         hwl_pending = 0;

  000c1	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?hwl_pending@?1??z900_hwl_request@@9@9, 0

; 478  : 
; 479  :         /* Create the hwl thread */
; 480  :         if( create_thread(&hwl_tid, &sysblk.detattr,

  000cb	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  000d2	48 05 88 10 00
	00		 add	 rax, 4232		; 00001088H
  000d8	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG193104
  000df	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  000e4	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG193105
  000eb	48 89 4c 24 20	 mov	 QWORD PTR [rsp+32], rcx
  000f0	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:?static_hwl_bk@?1??z900_hwl_request@@9@9
  000f7	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:z900_hwl_thread
  000fe	48 8b d0	 mov	 rdx, rax
  00101	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:hwl_tid
  00108	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_create_thread
  0010e	85 c0		 test	 eax, eax
  00110	74 07		 je	 SHORT $LN10@z900_hwl_r

; 481  :           ARCH_DEP(hwl_thread), &static_hwl_bk, "hwl_thread") )
; 482  :             return -1;

  00112	b8 ff ff ff ff	 mov	 eax, -1
  00117	eb 6e		 jmp	 SHORT $LN1@z900_hwl_r
$LN10@z900_hwl_r:

; 483  : 
; 484  :         /* Set pending flag */
; 485  :         hwl_pending = 1;

  00119	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR ?hwl_pending@?1??z900_hwl_request@@9@9, 1

; 486  : 
; 487  :         return 0;

  00123	33 c0		 xor	 eax, eax
  00125	eb 60		 jmp	 SHORT $LN1@z900_hwl_r
$LN11@z900_hwl_r:

; 488  : 
; 489  :     default:
; 490  :         // "Unknown hardware loader request type %2.2X"
; 491  :         WRMSG( HHC00654, "E", hwl_bk->type );

  00127	48 8b 44 24 50	 mov	 rax, QWORD PTR hwl_bk$[rsp]
  0012c	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  0012f	89 44 24 48	 mov	 DWORD PTR tv83[rsp], eax
  00133	b9 01 00 00 00	 mov	 ecx, 1
  00138	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  0013e	8b 4c 24 48	 mov	 ecx, DWORD PTR tv83[rsp]
  00142	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  00146	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG193107
  0014d	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  00152	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG193108
  00159	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  0015e	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00163	41 b9 03 00 00
	00		 mov	 r9d, 3
  00169	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG193109
  00170	ba eb 01 00 00	 mov	 edx, 491		; 000001ebH
  00175	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG193110
  0017c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 492  :         return -1;

  00182	b8 ff ff ff ff	 mov	 eax, -1
$LN1@z900_hwl_r:

; 493  :     }
; 494  : }

  00187	48 83 c4 68	 add	 rsp, 104		; 00000068H
  0018b	5f		 pop	 rdi
  0018c	5e		 pop	 rsi
  0018d	c3		 ret	 0
z900_hwl_request ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\scescsi.c
_TEXT	SEGMENT
size$1 = 80
hwl_bk$ = 88
tv74 = 96
tv151 = 100
tv91 = 104
tv169 = 112
tv128 = 120
st$2 = 128
__$ArrayPad$ = 184
arg$ = 208
z900_hwl_thread PROC

; 381  : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 81 ec c8 00
	00 00		 sub	 rsp, 200		; 000000c8H
  0000c	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00013	48 33 c4	 xor	 rax, rsp
  00016	48 89 84 24 b8
	00 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 382  : SCCB_HWL_BK *hwl_bk = (SCCB_HWL_BK*) arg;

  0001e	48 8b 84 24 d0
	00 00 00	 mov	 rax, QWORD PTR arg$[rsp]
  00026	48 89 44 24 58	 mov	 QWORD PTR hwl_bk$[rsp], rax

; 383  : 
; 384  :     if(hwl_bk->file < HWL_MAXFILETYPE && hwl_fn[hwl_bk->file])

  0002b	48 8b 44 24 58	 mov	 rax, QWORD PTR hwl_bk$[rsp]
  00030	0f b6 40 01	 movzx	 eax, BYTE PTR [rax+1]
  00034	83 f8 08	 cmp	 eax, 8
  00037	0f 8d 6a 01 00
	00		 jge	 $LN4@z900_hwl_t
  0003d	48 8b 44 24 58	 mov	 rax, QWORD PTR hwl_bk$[rsp]
  00042	0f b6 40 01	 movzx	 eax, BYTE PTR [rax+1]
  00046	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:hwl_fn
  0004d	48 83 3c c1 00	 cmp	 QWORD PTR [rcx+rax*8], 0
  00052	0f 84 4f 01 00
	00		 je	 $LN4@z900_hwl_t

; 385  :     {
; 386  :         switch(hwl_bk->type) {

  00058	48 8b 44 24 58	 mov	 rax, QWORD PTR hwl_bk$[rsp]
  0005d	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  00060	88 44 24 60	 mov	 BYTE PTR tv74[rsp], al
  00064	80 7c 24 60 00	 cmp	 BYTE PTR tv74[rsp], 0
  00069	0f 84 13 01 00
	00		 je	 $LN9@z900_hwl_t
  0006f	80 7c 24 60 02	 cmp	 BYTE PTR tv74[rsp], 2
  00074	74 05		 je	 SHORT $LN6@z900_hwl_t
  00076	e9 2a 01 00 00	 jmp	 $LN2@z900_hwl_t
$LN6@z900_hwl_t:

; 387  : 
; 388  :         /* INFO request returns the required region size in 4K pages */
; 389  :         case SCCB_HWL_TYPE_INFO:
; 390  :             {
; 391  :             struct stat st;
; 392  : 
; 393  :                 if(!stat(hwl_fn[hwl_bk->file], &st) )

  0007b	48 8b 44 24 58	 mov	 rax, QWORD PTR hwl_bk$[rsp]
  00080	0f b6 40 01	 movzx	 eax, BYTE PTR [rax+1]
  00084	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:hwl_fn
  0008b	48 8d 94 24 80
	00 00 00	 lea	 rdx, QWORD PTR st$2[rsp]
  00093	48 8b 0c c1	 mov	 rcx, QWORD PTR [rcx+rax*8]
  00097	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__stat64
  0009d	85 c0		 test	 eax, eax
  0009f	75 4e		 jne	 SHORT $LN7@z900_hwl_t

; 394  :                 {
; 395  :                 U32     size;
; 396  : 
; 397  :                     size = st.st_size;

  000a1	8b 84 24 98 00
	00 00		 mov	 eax, DWORD PTR st$2[rsp+24]
  000a8	89 44 24 50	 mov	 DWORD PTR size$1[rsp], eax

; 398  :                     size += 0x00000FFF;

  000ac	8b 44 24 50	 mov	 eax, DWORD PTR size$1[rsp]
  000b0	05 ff 0f 00 00	 add	 eax, 4095		; 00000fffH
  000b5	89 44 24 50	 mov	 DWORD PTR size$1[rsp], eax

; 399  :                     size &= 0xFFFFF000;

  000b9	8b 44 24 50	 mov	 eax, DWORD PTR size$1[rsp]
  000bd	25 00 f0 ff ff	 and	 eax, -4096		; fffff000H
  000c2	89 44 24 50	 mov	 DWORD PTR size$1[rsp], eax

; 400  :                     size >>= 12;

  000c6	8b 44 24 50	 mov	 eax, DWORD PTR size$1[rsp]
  000ca	c1 e8 0c	 shr	 eax, 12
  000cd	89 44 24 50	 mov	 DWORD PTR size$1[rsp], eax

; 401  : 
; 402  :                     STORE_FW(hwl_bk->size,size);

  000d1	8b 4c 24 50	 mov	 ecx, DWORD PTR size$1[rsp]
  000d5	e8 00 00 00 00	 call	 _byteswap_ulong
  000da	48 8b 4c 24 58	 mov	 rcx, QWORD PTR hwl_bk$[rsp]
  000df	48 83 c1 26	 add	 rcx, 38			; 00000026H
  000e3	8b d0		 mov	 edx, eax
  000e5	e8 00 00 00 00	 call	 store_fw_noswap

; 403  :                 }

  000ea	e9 91 00 00 00	 jmp	 $LN8@z900_hwl_t
$LN7@z900_hwl_t:

; 404  :                 else
; 405  :                     // "Hardware loader %s: %s"
; 406  :                     WRMSG( HHC00652, "E", hwl_fn[ hwl_bk->file ], strerror( errno ));

  000ef	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno
  000f5	8b 08		 mov	 ecx, DWORD PTR [rax]
  000f7	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_strerror
  000fd	48 89 44 24 68	 mov	 QWORD PTR tv91[rsp], rax
  00102	48 8b 4c 24 58	 mov	 rcx, QWORD PTR hwl_bk$[rsp]
  00107	0f b6 49 01	 movzx	 ecx, BYTE PTR [rcx+1]
  0010b	48 89 4c 24 78	 mov	 QWORD PTR tv128[rsp], rcx
  00110	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:hwl_fn
  00117	48 89 54 24 70	 mov	 QWORD PTR tv169[rsp], rdx
  0011c	b9 01 00 00 00	 mov	 ecx, 1
  00121	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  00127	48 8b 4c 24 68	 mov	 rcx, QWORD PTR tv91[rsp]
  0012c	48 89 4c 24 40	 mov	 QWORD PTR [rsp+64], rcx
  00131	48 8b 4c 24 70	 mov	 rcx, QWORD PTR tv169[rsp]
  00136	48 8b 54 24 78	 mov	 rdx, QWORD PTR tv128[rsp]
  0013b	48 8b 0c d1	 mov	 rcx, QWORD PTR [rcx+rdx*8]
  0013f	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  00144	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG193069
  0014b	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  00150	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG193070
  00157	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  0015c	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00161	41 b9 03 00 00
	00		 mov	 r9d, 3
  00167	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG193071
  0016e	ba 96 01 00 00	 mov	 edx, 406		; 00000196H
  00173	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG193072
  0017a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg
$LN8@z900_hwl_t:

; 407  :             }
; 408  :             break;

  00180	eb 23		 jmp	 SHORT $LN2@z900_hwl_t
$LN9@z900_hwl_t:

; 409  : 
; 410  :         /* Load request will load the image into fixed virtual storage
; 411  :            the Segment Table Origin is listed in the hwl_bk */
; 412  :         case SCCB_HWL_TYPE_LOAD:
; 413  : #if defined( FEATURE_001_ZARCH_INSTALLED_FACILITY )
; 414  :             if(!hwl_bk->asa)

  00182	48 8b 44 24 58	 mov	 rax, QWORD PTR hwl_bk$[rsp]
  00187	0f b6 40 10	 movzx	 eax, BYTE PTR [rax+16]
  0018b	85 c0		 test	 eax, eax
  0018d	75 0c		 jne	 SHORT $LN10@z900_hwl_t

; 415  :                 s390_hwl_loadfile(hwl_bk);

  0018f	48 8b 4c 24 58	 mov	 rcx, QWORD PTR hwl_bk$[rsp]
  00194	e8 00 00 00 00	 call	 s390_hwl_loadfile
  00199	eb 0a		 jmp	 SHORT $LN11@z900_hwl_t
$LN10@z900_hwl_t:

; 416  :             else
; 417  : #endif
; 418  :                 ARCH_DEP(hwl_loadfile)(hwl_bk);

  0019b	48 8b 4c 24 58	 mov	 rcx, QWORD PTR hwl_bk$[rsp]
  001a0	e8 00 00 00 00	 call	 z900_hwl_loadfile
$LN11@z900_hwl_t:
$LN2@z900_hwl_t:

; 419  :             break;
; 420  :         }
; 421  :     }

  001a5	eb 5c		 jmp	 SHORT $LN5@z900_hwl_t
$LN4@z900_hwl_t:

; 422  :     else
; 423  :         // "Hardware loader file type %d not not supported"
; 424  :         WRMSG( HHC00653, "E", hwl_bk->file );

  001a7	48 8b 44 24 58	 mov	 rax, QWORD PTR hwl_bk$[rsp]
  001ac	0f b6 40 01	 movzx	 eax, BYTE PTR [rax+1]
  001b0	89 44 24 64	 mov	 DWORD PTR tv151[rsp], eax
  001b4	b9 01 00 00 00	 mov	 ecx, 1
  001b9	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  001bf	8b 4c 24 64	 mov	 ecx, DWORD PTR tv151[rsp]
  001c3	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  001c7	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG193076
  001ce	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  001d3	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG193077
  001da	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  001df	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  001e4	41 b9 03 00 00
	00		 mov	 r9d, 3
  001ea	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG193078
  001f1	ba a8 01 00 00	 mov	 edx, 424		; 000001a8H
  001f6	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG193079
  001fd	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg
$LN5@z900_hwl_t:

; 425  : 
; 426  :     hwl_tid = 0;

  00203	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR hwl_tid, 0

; 427  : 
; 428  :     OBTAIN_INTLOCK(NULL);

  0020d	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG193080
  00214	33 c9		 xor	 ecx, ecx
  00216	e8 00 00 00 00	 call	 Obtain_Interrupt_Lock

; 429  :     sclp_attention(SCCB_EVD_TYPE_HWL);

  0021b	66 b9 0c 00	 mov	 cx, 12
  0021f	e8 00 00 00 00	 call	 sclp_attention

; 430  :     RELEASE_INTLOCK(NULL);

  00224	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG193081
  0022b	33 c9		 xor	 ecx, ecx
  0022d	e8 00 00 00 00	 call	 Release_Interrupt_Lock

; 431  :     return NULL;

  00232	33 c0		 xor	 eax, eax

; 432  : }

  00234	48 8b 8c 24 b8
	00 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  0023c	48 33 cc	 xor	 rcx, rsp
  0023f	e8 00 00 00 00	 call	 __security_check_cookie
  00244	48 81 c4 c8 00
	00 00		 add	 rsp, 200		; 000000c8H
  0024b	c3		 ret	 0
z900_hwl_thread ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\scescsi.c
_TEXT	SEGMENT
fd$ = 80
pages$ = 84
asce$ = 88
tv160 = 96
tv72 = 104
tv183 = 112
tv77 = 120
tv184 = 128
tv91 = 136
hwl_bk$ = 160
z900_hwl_loadfile PROC

; 329  : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 81 ec 98 00
	00 00		 sub	 rsp, 152		; 00000098H

; 330  :     U32   pages;                        /* Num pages to be loaded    */
; 331  :     CREG  asce;                         /* DAT Addr Space Ctl Elem   */
; 332  :     int   fd;                           /* fd of file to be loaded   */
; 333  : 
; 334  :     /* Open the file to be loaded */
; 335  :     if ((fd = open( hwl_fn[ hwl_bk->file ], O_RDONLY | O_BINARY )) < 0)

  0000c	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR hwl_bk$[rsp]
  00014	0f b6 40 01	 movzx	 eax, BYTE PTR [rax+1]
  00018	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:hwl_fn
  0001f	ba 00 80 00 00	 mov	 edx, 32768		; 00008000H
  00024	48 8b 0c c1	 mov	 rcx, QWORD PTR [rcx+rax*8]
  00028	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_open
  0002e	89 44 24 50	 mov	 DWORD PTR fd$[rsp], eax
  00032	83 7c 24 50 00	 cmp	 DWORD PTR fd$[rsp], 0
  00037	0f 8d 9e 00 00
	00		 jge	 $LN4@z900_hwl_l

; 336  :     {
; 337  :         // "%s open error: %s"
; 338  :         WRMSG( HHC00650, "E", hwl_fn[ hwl_bk->file ], strerror( errno ));

  0003d	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno
  00043	8b 08		 mov	 ecx, DWORD PTR [rax]
  00045	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_strerror
  0004b	48 89 44 24 68	 mov	 QWORD PTR tv72[rsp], rax
  00050	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR hwl_bk$[rsp]
  00058	0f b6 49 01	 movzx	 ecx, BYTE PTR [rcx+1]
  0005c	48 89 4c 24 78	 mov	 QWORD PTR tv77[rsp], rcx
  00061	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:hwl_fn
  00068	48 89 54 24 70	 mov	 QWORD PTR tv183[rsp], rdx
  0006d	b9 01 00 00 00	 mov	 ecx, 1
  00072	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  00078	48 8b 4c 24 68	 mov	 rcx, QWORD PTR tv72[rsp]
  0007d	48 89 4c 24 40	 mov	 QWORD PTR [rsp+64], rcx
  00082	48 8b 4c 24 70	 mov	 rcx, QWORD PTR tv183[rsp]
  00087	48 8b 54 24 78	 mov	 rdx, QWORD PTR tv77[rsp]
  0008c	48 8b 0c d1	 mov	 rcx, QWORD PTR [rcx+rdx*8]
  00090	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  00095	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG193033
  0009c	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  000a1	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG193034
  000a8	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  000ad	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  000b2	41 b9 03 00 00
	00		 mov	 r9d, 3
  000b8	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG193035
  000bf	ba 52 01 00 00	 mov	 edx, 338		; 00000152H
  000c4	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG193036
  000cb	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 339  :         return;

  000d1	e9 e0 01 00 00	 jmp	 $LN1@z900_hwl_l

; 340  :     }

  000d6	e9 83 00 00 00	 jmp	 $LN5@z900_hwl_l
$LN4@z900_hwl_l:

; 341  :     else
; 342  :         // "Loading %s"
; 343  :         WRMSG( HHC00651, "I", hwl_fn[ hwl_bk->file ]);

  000db	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR hwl_bk$[rsp]
  000e3	0f b6 40 01	 movzx	 eax, BYTE PTR [rax+1]
  000e7	48 89 84 24 88
	00 00 00	 mov	 QWORD PTR tv91[rsp], rax
  000ef	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:hwl_fn
  000f6	48 89 8c 24 80
	00 00 00	 mov	 QWORD PTR tv184[rsp], rcx
  000fe	b9 01 00 00 00	 mov	 ecx, 1
  00103	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  00109	48 8b 94 24 80
	00 00 00	 mov	 rdx, QWORD PTR tv184[rsp]
  00111	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR tv91[rsp]
  00119	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  0011d	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  00122	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG193037
  00129	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  0012e	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG193038
  00135	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  0013a	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  0013f	41 b9 03 00 00
	00		 mov	 r9d, 3
  00145	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG193039
  0014c	ba 57 01 00 00	 mov	 edx, 343		; 00000157H
  00151	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG193040
  00158	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg
$LN5@z900_hwl_l:

; 344  : 
; 345  :     /* Retrieve number of pages to be loaded */
; 346  :     FETCH_FW( pages, hwl_bk->size );

  0015e	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR hwl_bk$[rsp]
  00166	48 83 c0 26	 add	 rax, 38			; 00000026H
  0016a	48 8b c8	 mov	 rcx, rax
  0016d	e8 00 00 00 00	 call	 fetch_fw_noswap
  00172	8b c8		 mov	 ecx, eax
  00174	e8 00 00 00 00	 call	 _byteswap_ulong
  00179	89 44 24 54	 mov	 DWORD PTR pages$[rsp], eax

; 347  : 
; 348  :     /* Retrieve the ASCE to determine where in guest
; 349  :        storage that the file should be loaded into. */
; 350  :     FETCH_DW( asce, hwl_bk->asce );

  0017d	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR hwl_bk$[rsp]
  00185	48 83 c0 12	 add	 rax, 18
  00189	48 8b c8	 mov	 rcx, rax
  0018c	e8 00 00 00 00	 call	 fetch_dw_noswap
  00191	48 8b c8	 mov	 rcx, rax
  00194	e8 00 00 00 00	 call	 _byteswap_uint64
  00199	48 89 44 24 58	 mov	 QWORD PTR asce$[rsp], rax

; 351  : 
; 352  :     /* Abort if ASCE points outside of main storage */
; 353  :     if (asce >= sysblk.mainsize)

  0019e	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  001a5	48 8b 80 90 00
	00 00		 mov	 rax, QWORD PTR [rax+144]
  001ac	48 39 44 24 58	 cmp	 QWORD PTR asce$[rsp], rax
  001b1	72 62		 jb	 SHORT $LN6@z900_hwl_l

; 354  :     {
; 355  :         // "%s is outside of main storage"
; 356  :         WRMSG( HHC00659, "E", "asce" );

  001b3	b9 01 00 00 00	 mov	 ecx, 1
  001b8	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  001be	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG193042
  001c5	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  001ca	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG193043
  001d1	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  001d6	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG193044
  001dd	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  001e2	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  001e7	41 b9 03 00 00
	00		 mov	 r9d, 3
  001ed	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG193045
  001f4	ba 64 01 00 00	 mov	 edx, 356		; 00000164H
  001f9	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG193046
  00200	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 357  :         close( fd );

  00206	8b 4c 24 50	 mov	 ecx, DWORD PTR fd$[rsp]
  0020a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_close

; 358  :         return;

  00210	e9 a1 00 00 00	 jmp	 $LN1@z900_hwl_l
$LN6@z900_hwl_l:

; 359  :     }
; 360  : 
; 361  :     /* Load the file into guest storage */
; 362  :     switch (asce & ASCE_DT)

  00215	48 8b 44 24 58	 mov	 rax, QWORD PTR asce$[rsp]
  0021a	48 83 e0 0c	 and	 rax, 12
  0021e	48 89 44 24 60	 mov	 QWORD PTR tv160[rsp], rax
  00223	48 83 7c 24 60
	00		 cmp	 QWORD PTR tv160[rsp], 0
  00229	74 6b		 je	 SHORT $LN10@z900_hwl_l
  0022b	48 83 7c 24 60
	04		 cmp	 QWORD PTR tv160[rsp], 4
  00231	74 48		 je	 SHORT $LN9@z900_hwl_l
  00233	48 83 7c 24 60
	08		 cmp	 QWORD PTR tv160[rsp], 8
  00239	74 25		 je	 SHORT $LN8@z900_hwl_l
  0023b	48 83 7c 24 60
	0c		 cmp	 QWORD PTR tv160[rsp], 12
  00241	74 02		 je	 SHORT $LN7@z900_hwl_l
  00243	eb 67		 jmp	 SHORT $LN2@z900_hwl_l
$LN7@z900_hwl_l:

; 363  :     {
; 364  : #if defined( FEATURE_001_ZARCH_INSTALLED_FACILITY )
; 365  :     case TT_R1TABL: ARCH_DEP( walk_table )( asce, fd, &pages, 3 ); break;

  00245	41 b9 03 00 00
	00		 mov	 r9d, 3
  0024b	4c 8d 44 24 54	 lea	 r8, QWORD PTR pages$[rsp]
  00250	8b 54 24 50	 mov	 edx, DWORD PTR fd$[rsp]
  00254	48 8b 4c 24 58	 mov	 rcx, QWORD PTR asce$[rsp]
  00259	e8 00 00 00 00	 call	 z900_walk_table
  0025e	eb 4c		 jmp	 SHORT $LN2@z900_hwl_l
$LN8@z900_hwl_l:

; 366  :     case TT_R2TABL: ARCH_DEP( walk_table )( asce, fd, &pages, 2 ); break;

  00260	41 b9 02 00 00
	00		 mov	 r9d, 2
  00266	4c 8d 44 24 54	 lea	 r8, QWORD PTR pages$[rsp]
  0026b	8b 54 24 50	 mov	 edx, DWORD PTR fd$[rsp]
  0026f	48 8b 4c 24 58	 mov	 rcx, QWORD PTR asce$[rsp]
  00274	e8 00 00 00 00	 call	 z900_walk_table
  00279	eb 31		 jmp	 SHORT $LN2@z900_hwl_l
$LN9@z900_hwl_l:

; 367  :     case TT_R3TABL: ARCH_DEP( walk_table )( asce, fd, &pages, 1 ); break;

  0027b	41 b9 01 00 00
	00		 mov	 r9d, 1
  00281	4c 8d 44 24 54	 lea	 r8, QWORD PTR pages$[rsp]
  00286	8b 54 24 50	 mov	 edx, DWORD PTR fd$[rsp]
  0028a	48 8b 4c 24 58	 mov	 rcx, QWORD PTR asce$[rsp]
  0028f	e8 00 00 00 00	 call	 z900_walk_table
  00294	eb 16		 jmp	 SHORT $LN2@z900_hwl_l
$LN10@z900_hwl_l:

; 368  : #endif
; 369  :     case TT_SEGTAB: ARCH_DEP( walk_table )( asce, fd, &pages, 0 ); break;

  00296	45 33 c9	 xor	 r9d, r9d
  00299	4c 8d 44 24 54	 lea	 r8, QWORD PTR pages$[rsp]
  0029e	8b 54 24 50	 mov	 edx, DWORD PTR fd$[rsp]
  002a2	48 8b 4c 24 58	 mov	 rcx, QWORD PTR asce$[rsp]
  002a7	e8 00 00 00 00	 call	 z900_walk_table
$LN2@z900_hwl_l:

; 370  :     }
; 371  : 
; 372  :     /* We're done. Close input file and return */
; 373  :     close( fd );

  002ac	8b 4c 24 50	 mov	 ecx, DWORD PTR fd$[rsp]
  002b0	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_close
$LN1@z900_hwl_l:

; 374  : }

  002b6	48 81 c4 98 00
	00 00		 add	 rsp, 152		; 00000098H
  002bd	c3		 ret	 0
z900_hwl_loadfile ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\scescsi.c
_TEXT	SEGMENT
keep_walking$ = 32
i$ = 36
entries$ = 40
to$ = 48
te$ = 56
rto$ = 80
fd$ = 88
pages$ = 96
tables$ = 104
z900_walk_table PROC

; 284  : {

  00000	44 89 4c 24 20	 mov	 DWORD PTR [rsp+32], r9d
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  0000e	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00013	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 285  :     TBLTYP*  te;                        /* Pointer to Table Entry    */
; 286  :     CREG     to;                        /* Next Table's Origin       */
; 287  :     U32      entries;                   /* Number of Table Entries   */
; 288  :     U32      i;                         /* Table Entry Iterator      */
; 289  :     bool     keep_walking = true;

  00017	c6 44 24 20 01	 mov	 BYTE PTR keep_walking$[rsp], 1

; 290  : 
; 291  :     /* Tables have 2048 entries max. A table length
; 292  :        of 0 means 512 entries, 1 means 1024, etc. */
; 293  :     entries = ((rto & REGTAB_TL) + 1) * 512;

  0001c	48 8b 44 24 50	 mov	 rax, QWORD PTR rto$[rsp]
  00021	48 83 e0 03	 and	 rax, 3
  00025	48 ff c0	 inc	 rax
  00028	48 69 c0 00 02
	00 00		 imul	 rax, rax, 512		; 00000200H
  0002f	89 44 24 28	 mov	 DWORD PTR entries$[rsp], eax

; 294  : 
; 295  :     /* Remove bit definitions to form table origin */
; 296  :     rto &= TBLTO_MASK;

  00033	48 8b 44 24 50	 mov	 rax, QWORD PTR rto$[rsp]
  00038	48 25 00 f0 ff
	ff		 and	 rax, -4096		; fffffffffffff000H
  0003e	48 89 44 24 50	 mov	 QWORD PTR rto$[rsp], rax

; 297  : 
; 298  :     /* Walk trough all table entries to find valid entries */
; 299  :     for (i=0; keep_walking && i < entries; i++, rto += sizeof( rto ))

  00043	c7 44 24 24 00
	00 00 00	 mov	 DWORD PTR i$[rsp], 0
  0004b	eb 18		 jmp	 SHORT $LN4@z900_walk_
$LN2@z900_walk_:
  0004d	8b 44 24 24	 mov	 eax, DWORD PTR i$[rsp]
  00051	ff c0		 inc	 eax
  00053	89 44 24 24	 mov	 DWORD PTR i$[rsp], eax
  00057	48 8b 44 24 50	 mov	 rax, QWORD PTR rto$[rsp]
  0005c	48 83 c0 08	 add	 rax, 8
  00060	48 89 44 24 50	 mov	 QWORD PTR rto$[rsp], rax
$LN4@z900_walk_:
  00065	0f b6 44 24 20	 movzx	 eax, BYTE PTR keep_walking$[rsp]
  0006a	85 c0		 test	 eax, eax
  0006c	0f 84 9d 00 00
	00		 je	 $LN3@z900_walk_
  00072	8b 44 24 28	 mov	 eax, DWORD PTR entries$[rsp]
  00076	39 44 24 24	 cmp	 DWORD PTR i$[rsp], eax
  0007a	0f 83 8f 00 00
	00		 jae	 $LN3@z900_walk_

; 300  :     {
; 301  :         /* Point to table entry in main storage */
; 302  :         te = (TBLTYP*)(sysblk.mainstor + rto);

  00080	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00087	48 8b 80 98 00
	00 00		 mov	 rax, QWORD PTR [rax+152]
  0008e	48 03 44 24 50	 add	 rax, QWORD PTR rto$[rsp]
  00093	48 89 44 24 38	 mov	 QWORD PTR te$[rsp], rax

; 303  : 
; 304  :         /* Fetch this Table Entry */
; 305  :         FETCH_W( to, te );

  00098	48 8b 4c 24 38	 mov	 rcx, QWORD PTR te$[rsp]
  0009d	e8 00 00 00 00	 call	 fetch_dw_noswap
  000a2	48 8b c8	 mov	 rcx, rax
  000a5	e8 00 00 00 00	 call	 _byteswap_uint64
  000aa	48 89 44 24 30	 mov	 QWORD PTR to$[rsp], rax

; 306  : 
; 307  :         /* Process this entry if it's not invalid */
; 308  :         if (!(to & REGSEG_INV))

  000af	48 8b 44 24 30	 mov	 rax, QWORD PTR to$[rsp]
  000b4	48 83 e0 20	 and	 rax, 32			; 00000020H
  000b8	48 85 c0	 test	 rax, rax
  000bb	75 4d		 jne	 SHORT $LN5@z900_walk_

; 309  :         {
; 310  :             /* Walk the next level table if there's one to be walked.
; 311  :                Otherwise load next part of file into this table's pages.
; 312  :             */
; 313  :             if ( ( to & REGTAB_TT ) != TT_SEGTAB )

  000bd	48 8b 44 24 30	 mov	 rax, QWORD PTR to$[rsp]
  000c2	48 83 e0 0c	 and	 rax, 12
  000c6	48 85 c0	 test	 rax, rax
  000c9	74 28		 je	 SHORT $LN6@z900_walk_

; 314  :                 keep_walking = ARCH_DEP( walk_table )( to, fd, pages, --tables );

  000cb	8b 44 24 68	 mov	 eax, DWORD PTR tables$[rsp]
  000cf	ff c8		 dec	 eax
  000d1	89 44 24 68	 mov	 DWORD PTR tables$[rsp], eax
  000d5	44 8b 4c 24 68	 mov	 r9d, DWORD PTR tables$[rsp]
  000da	4c 8b 44 24 60	 mov	 r8, QWORD PTR pages$[rsp]
  000df	8b 54 24 58	 mov	 edx, DWORD PTR fd$[rsp]
  000e3	48 8b 4c 24 30	 mov	 rcx, QWORD PTR to$[rsp]
  000e8	e8 00 00 00 00	 call	 z900_walk_table
  000ed	88 44 24 20	 mov	 BYTE PTR keep_walking$[rsp], al
  000f1	eb 17		 jmp	 SHORT $LN7@z900_walk_
$LN6@z900_walk_:

; 315  :             else
; 316  :                 keep_walking = ARCH_DEP( load_pages )( to, fd, pages );

  000f3	4c 8b 44 24 60	 mov	 r8, QWORD PTR pages$[rsp]
  000f8	8b 54 24 58	 mov	 edx, DWORD PTR fd$[rsp]
  000fc	48 8b 4c 24 30	 mov	 rcx, QWORD PTR to$[rsp]
  00101	e8 00 00 00 00	 call	 z900_load_pages
  00106	88 44 24 20	 mov	 BYTE PTR keep_walking$[rsp], al
$LN7@z900_walk_:
$LN5@z900_walk_:

; 317  :         }
; 318  :     }

  0010a	e9 3e ff ff ff	 jmp	 $LN2@z900_walk_
$LN3@z900_walk_:

; 319  : 
; 320  :     return keep_walking;

  0010f	0f b6 44 24 20	 movzx	 eax, BYTE PTR keep_walking$[rsp]

; 321  : }

  00114	48 83 c4 48	 add	 rsp, 72			; 00000048H
  00118	c3		 ret	 0
z900_walk_table ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\scescsi.c
_TEXT	SEGMENT
pti$ = 80
rc$ = 84
tv159 = 88
tv161 = 92
pgo$ = 96
pte$ = 104
page$ = 112
tv141 = 120
pto$ = 144
fd$ = 152
pages$ = 160
z900_load_pages PROC

; 216  : {

  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00009	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000e	48 81 ec 88 00
	00 00		 sub	 rsp, 136		; 00000088H

; 217  :     TBLTYP*  pte;                   /* Page Table Entry              */
; 218  :     int      pti;                   /* Page Table Entry iterator     */
; 219  :     CREG     pgo;                   /* Page Origin (i.e. PFRA)       */
; 220  :     BYTE*    page;                  /* Pointer to page in mainstor   */
; 221  :     int      rc;                    /* Return code from read()       */
; 222  : 
; 223  :     /* Remove bit definitions to form table origin */
; 224  :     pto &= PTO_MASK;

  00015	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR pto$[rsp]
  0001d	48 25 00 f8 ff
	ff		 and	 rax, -2048		; fffffffffffff800H
  00023	48 89 84 24 90
	00 00 00	 mov	 QWORD PTR pto$[rsp], rax

; 225  : 
; 226  :     /* Keep loading file data into this page table's valid pages
; 227  :        until either the entire file has been loaded, or we run out
; 228  :        of page table entries or an abortive condition is detected.
; 229  :     */
; 230  :     for (pti=0; *pages && pti < 256; pti++, pto += sizeof( pto ))

  0002b	c7 44 24 50 00
	00 00 00	 mov	 DWORD PTR pti$[rsp], 0
  00033	eb 1e		 jmp	 SHORT $LN4@z900_load_
$LN2@z900_load_:
  00035	8b 44 24 50	 mov	 eax, DWORD PTR pti$[rsp]
  00039	ff c0		 inc	 eax
  0003b	89 44 24 50	 mov	 DWORD PTR pti$[rsp], eax
  0003f	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR pto$[rsp]
  00047	48 83 c0 08	 add	 rax, 8
  0004b	48 89 84 24 90
	00 00 00	 mov	 QWORD PTR pto$[rsp], rax
$LN4@z900_load_:
  00053	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR pages$[rsp]
  0005b	83 38 00	 cmp	 DWORD PTR [rax], 0
  0005e	0f 84 17 02 00
	00		 je	 $LN3@z900_load_
  00064	81 7c 24 50 00
	01 00 00	 cmp	 DWORD PTR pti$[rsp], 256 ; 00000100H
  0006c	0f 8d 09 02 00
	00		 jge	 $LN3@z900_load_

; 231  :     {
; 232  :         /* Abort if table entry is outside of main storage */
; 233  :         if (pto >= sysblk.mainsize)

  00072	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00079	48 8b 80 90 00
	00 00		 mov	 rax, QWORD PTR [rax+144]
  00080	48 39 84 24 90
	00 00 00	 cmp	 QWORD PTR pto$[rsp], rax
  00088	72 5a		 jb	 SHORT $LN5@z900_load_

; 234  :         {
; 235  :             // "%s is outside of main storage"
; 236  :             WRMSG( HHC00659, "E", "table" );

  0008a	b9 01 00 00 00	 mov	 ecx, 1
  0008f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  00095	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG192981
  0009c	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  000a1	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG192982
  000a8	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  000ad	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG192983
  000b4	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  000b9	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  000be	41 b9 03 00 00
	00		 mov	 r9d, 3
  000c4	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG192984
  000cb	ba ec 00 00 00	 mov	 edx, 236		; 000000ecH
  000d0	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG192985
  000d7	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 237  :             return false; // abort!

  000dd	32 c0		 xor	 al, al
  000df	e9 d4 01 00 00	 jmp	 $LN1@z900_load_
$LN5@z900_load_:

; 238  :         }
; 239  : 
; 240  :         /* Point to table entry in main storage */
; 241  :         pte = (TBLTYP*)(sysblk.mainstor + pto);

  000e4	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  000eb	48 8b 80 98 00
	00 00		 mov	 rax, QWORD PTR [rax+152]
  000f2	48 03 84 24 90
	00 00 00	 add	 rax, QWORD PTR pto$[rsp]
  000fa	48 89 44 24 68	 mov	 QWORD PTR pte$[rsp], rax

; 242  : 
; 243  :         /* Fetch this Page Table Entry */
; 244  :         FETCH_W( pgo, pte );

  000ff	48 8b 4c 24 68	 mov	 rcx, QWORD PTR pte$[rsp]
  00104	e8 00 00 00 00	 call	 fetch_dw_noswap
  00109	48 8b c8	 mov	 rcx, rax
  0010c	e8 00 00 00 00	 call	 _byteswap_uint64
  00111	48 89 44 24 60	 mov	 QWORD PTR pgo$[rsp], rax

; 245  : 
; 246  :         /* Process this entry if it's not invalid */
; 247  :         if (!(pgo & PAGETAB_INVALID))

  00116	48 8b 44 24 60	 mov	 rax, QWORD PTR pgo$[rsp]
  0011b	48 25 00 04 00
	00		 and	 rax, 1024		; 00000400H
  00121	48 85 c0	 test	 rax, rax
  00124	0f 85 4c 01 00
	00		 jne	 $LN6@z900_load_

; 248  :         {
; 249  :             /* Get Page Frame Real Address */
; 250  :             pgo &= PFRA_MASK;

  0012a	48 8b 44 24 60	 mov	 rax, QWORD PTR pgo$[rsp]
  0012f	48 25 00 f0 ff
	ff		 and	 rax, -4096		; fffffffffffff000H
  00135	48 89 44 24 60	 mov	 QWORD PTR pgo$[rsp], rax

; 251  : 
; 252  :             /* Abort if page is outside of main storage */
; 253  :             if (pgo >= sysblk.mainsize)

  0013a	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00141	48 8b 80 90 00
	00 00		 mov	 rax, QWORD PTR [rax+144]
  00148	48 39 44 24 60	 cmp	 QWORD PTR pgo$[rsp], rax
  0014d	72 5a		 jb	 SHORT $LN7@z900_load_

; 254  :             {
; 255  :                 // "%s is outside of main storage"
; 256  :                 WRMSG( HHC00659, "E", "page" );

  0014f	b9 01 00 00 00	 mov	 ecx, 1
  00154	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  0015a	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG192988
  00161	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  00166	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG192989
  0016d	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  00172	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG192990
  00179	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  0017e	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00183	41 b9 03 00 00
	00		 mov	 r9d, 3
  00189	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG192991
  00190	ba 00 01 00 00	 mov	 edx, 256		; 00000100H
  00195	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG192992
  0019c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 257  :                 return false; // abort!

  001a2	32 c0		 xor	 al, al
  001a4	e9 0f 01 00 00	 jmp	 $LN1@z900_load_
$LN7@z900_load_:

; 258  :             }
; 259  : 
; 260  :             /* Get mainstor address of this page */
; 261  :             page = sysblk.mainstor + pgo;

  001a9	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  001b0	48 8b 80 98 00
	00 00		 mov	 rax, QWORD PTR [rax+152]
  001b7	48 03 44 24 60	 add	 rax, QWORD PTR pgo$[rsp]
  001bc	48 89 44 24 70	 mov	 QWORD PTR page$[rsp], rax

; 262  : 
; 263  :             /* Load one page's worth of file data into this page */
; 264  :             if ((rc = read( fd, page, STORAGE_KEY_PAGESIZE )) < 0)

  001c1	41 b8 00 10 00
	00		 mov	 r8d, 4096		; 00001000H
  001c7	48 8b 54 24 70	 mov	 rdx, QWORD PTR page$[rsp]
  001cc	8b 8c 24 98 00
	00 00		 mov	 ecx, DWORD PTR fd$[rsp]
  001d3	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_read
  001d9	89 44 24 54	 mov	 DWORD PTR rc$[rsp], eax
  001dd	83 7c 24 54 00	 cmp	 DWORD PTR rc$[rsp], 0
  001e2	7d 70		 jge	 SHORT $LN8@z900_load_

; 265  :             {
; 266  :                 // "I/O error on read(): rc=%d: \"%s\""
; 267  :                 WRMSG( HHC00658, "E", rc, strerror( errno ));

  001e4	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno
  001ea	8b 08		 mov	 ecx, DWORD PTR [rax]
  001ec	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_strerror
  001f2	48 89 44 24 78	 mov	 QWORD PTR tv141[rsp], rax
  001f7	b9 01 00 00 00	 mov	 ecx, 1
  001fc	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  00202	48 8b 4c 24 78	 mov	 rcx, QWORD PTR tv141[rsp]
  00207	48 89 4c 24 40	 mov	 QWORD PTR [rsp+64], rcx
  0020c	8b 4c 24 54	 mov	 ecx, DWORD PTR rc$[rsp]
  00210	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  00214	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG192994
  0021b	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  00220	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG192995
  00227	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  0022c	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00231	41 b9 03 00 00
	00		 mov	 r9d, 3
  00237	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG192996
  0023e	ba 0b 01 00 00	 mov	 edx, 267		; 0000010bH
  00243	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG192997
  0024a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 268  :                 return false; // abort!

  00250	32 c0		 xor	 al, al
  00252	eb 64		 jmp	 SHORT $LN1@z900_load_
$LN8@z900_load_:

; 269  :             }
; 270  : 
; 271  :             /* Page successfully loaded; Decrement pages remaining */
; 272  :             (*pages)--;

  00254	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR pages$[rsp]
  0025c	8b 00		 mov	 eax, DWORD PTR [rax]
  0025e	ff c8		 dec	 eax
  00260	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR pages$[rsp]
  00268	89 01		 mov	 DWORD PTR [rcx], eax

; 273  : 
; 274  :             /* Update page's referenced and changed Storage Key bits */
; 275  :             ARCH_DEP( or_storage_key )( pgo, (STORKEY_REF | STORKEY_CHANGE) );

  0026a	b2 06		 mov	 dl, 6
  0026c	48 8b 4c 24 60	 mov	 rcx, QWORD PTR pgo$[rsp]
  00271	e8 00 00 00 00	 call	 z900_or_storage_key
$LN6@z900_load_:

; 276  :         }
; 277  :     }

  00276	e9 ba fd ff ff	 jmp	 $LN2@z900_load_
$LN3@z900_load_:

; 278  : 
; 279  :     /* Keep going if there are still pages remaining to be loaded */
; 280  :     return (*pages > 0) ? true : false;

  0027b	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR pages$[rsp]
  00283	83 38 00	 cmp	 DWORD PTR [rax], 0
  00286	76 0a		 jbe	 SHORT $LN10@z900_load_
  00288	c7 44 24 58 01
	00 00 00	 mov	 DWORD PTR tv159[rsp], 1
  00290	eb 08		 jmp	 SHORT $LN11@z900_load_
$LN10@z900_load_:
  00292	c7 44 24 58 00
	00 00 00	 mov	 DWORD PTR tv159[rsp], 0
$LN11@z900_load_:
  0029a	83 7c 24 58 00	 cmp	 DWORD PTR tv159[rsp], 0
  0029f	75 0a		 jne	 SHORT $LN12@z900_load_
  002a1	c7 44 24 5c 00
	00 00 00	 mov	 DWORD PTR tv161[rsp], 0
  002a9	eb 08		 jmp	 SHORT $LN13@z900_load_
$LN12@z900_load_:
  002ab	c7 44 24 5c 01
	00 00 00	 mov	 DWORD PTR tv161[rsp], 1
$LN13@z900_load_:
  002b3	0f b6 44 24 5c	 movzx	 eax, BYTE PTR tv161[rsp]
$LN1@z900_load_:

; 281  : }

  002b8	48 81 c4 88 00
	00 00		 add	 rsp, 136		; 00000088H
  002bf	c3		 ret	 0
z900_load_pages ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\skey.h
;	COMDAT z900_or_storage_key
_TEXT	SEGMENT
abs$ = 48
bits$ = 56
z900_or_storage_key PROC				; COMDAT

; 290  : {

$LN3:
  00000	88 54 24 10	 mov	 BYTE PTR [rsp+16], dl
  00004	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00009	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 291  : #if defined( FEATURE_2K_STORAGE_KEYS )
; 292  :     ARCH_DEP( or_2K_storage_key )( abs, bits );
; 293  : #else
; 294  :     ARCH_DEP( or_4K_storage_key )( abs, bits );

  0000d	0f b6 54 24 38	 movzx	 edx, BYTE PTR bits$[rsp]
  00012	48 8b 4c 24 30	 mov	 rcx, QWORD PTR abs$[rsp]
  00017	e8 00 00 00 00	 call	 z900_or_4K_storage_key

; 295  : #endif
; 296  : }

  0001c	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00020	c3		 ret	 0
z900_or_storage_key ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\skey.h
;	COMDAT z900_or_4K_storage_key
_TEXT	SEGMENT
abs$ = 48
bits$ = 56
z900_or_4K_storage_key PROC				; COMDAT

; 242  :   inline void  ARCH_DEP( or_4K_storage_key )      (              U64 abs, BYTE bits ) {        ARCH_DEP( _or_storage_key      )(      abs, bits & ~STORKEY_BADFRM, 4 ); }

$LN3:
  00000	88 54 24 10	 mov	 BYTE PTR [rsp+16], dl
  00004	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00009	48 83 ec 28	 sub	 rsp, 40			; 00000028H
  0000d	0f b6 44 24 38	 movzx	 eax, BYTE PTR bits$[rsp]
  00012	83 e0 fe	 and	 eax, -2
  00015	41 b0 04	 mov	 r8b, 4
  00018	0f b6 d0	 movzx	 edx, al
  0001b	48 8b 4c 24 30	 mov	 rcx, QWORD PTR abs$[rsp]
  00020	e8 00 00 00 00	 call	 z900__or_storage_key
  00025	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00029	c3		 ret	 0
z900_or_4K_storage_key ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\skey.h
;	COMDAT z900__or_storage_key
_TEXT	SEGMENT
skey1_ptr$1 = 32
skey2_ptr$2 = 40
skey_ptr$3 = 48
abs$ = 80
bits$ = 88
K$ = 96
z900__or_storage_key PROC				; COMDAT

; 189  : {

$LN8:
  00000	44 88 44 24 18	 mov	 BYTE PTR [rsp+24], r8b
  00005	88 54 24 10	 mov	 BYTE PTR [rsp+16], dl
  00009	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000e	48 83 ec 48	 sub	 rsp, 72			; 00000048H
$LN4@z900__or_s:

; 190  :     UNREFERENCED( K ); // (for FEATURE_4K_STORAGE_KEYS case)

  00012	33 c0		 xor	 eax, eax
  00014	85 c0		 test	 eax, eax
  00016	75 fa		 jne	 SHORT $LN4@z900__or_s

; 191  :     if (IS_DOUBLE_KEYED_4K_BYTE_BLOCK( K ))

  00018	33 c0		 xor	 eax, eax
  0001a	85 c0		 test	 eax, eax
  0001c	74 50		 je	 SHORT $LN5@z900__or_s

; 192  :     {
; 193  :         BYTE* skey1_ptr = _get_storekey1_ptr( abs );

  0001e	48 8b 4c 24 50	 mov	 rcx, QWORD PTR abs$[rsp]
  00023	e8 00 00 00 00	 call	 _get_storekey1_ptr
  00028	48 89 44 24 20	 mov	 QWORD PTR skey1_ptr$1[rsp], rax

; 194  :         BYTE* skey2_ptr = _get_storekey2_ptr( abs );

  0002d	48 8b 4c 24 50	 mov	 rcx, QWORD PTR abs$[rsp]
  00032	e8 00 00 00 00	 call	 _get_storekey2_ptr
  00037	48 89 44 24 28	 mov	 QWORD PTR skey2_ptr$2[rsp], rax

; 195  :         OR_SKEY( skey1_ptr, bits );

  0003c	0f b6 44 24 58	 movzx	 eax, BYTE PTR bits$[rsp]
  00041	48 8b 4c 24 20	 mov	 rcx, QWORD PTR skey1_ptr$1[rsp]
  00046	0f b6 09	 movzx	 ecx, BYTE PTR [rcx]
  00049	0b c8		 or	 ecx, eax
  0004b	8b c1		 mov	 eax, ecx
  0004d	48 8b 4c 24 20	 mov	 rcx, QWORD PTR skey1_ptr$1[rsp]
  00052	88 01		 mov	 BYTE PTR [rcx], al

; 196  :         OR_SKEY( skey2_ptr, bits );

  00054	0f b6 44 24 58	 movzx	 eax, BYTE PTR bits$[rsp]
  00059	48 8b 4c 24 28	 mov	 rcx, QWORD PTR skey2_ptr$2[rsp]
  0005e	0f b6 09	 movzx	 ecx, BYTE PTR [rcx]
  00061	0b c8		 or	 ecx, eax
  00063	8b c1		 mov	 eax, ecx
  00065	48 8b 4c 24 28	 mov	 rcx, QWORD PTR skey2_ptr$2[rsp]
  0006a	88 01		 mov	 BYTE PTR [rcx], al

; 197  :     }

  0006c	eb 2c		 jmp	 SHORT $LN6@z900__or_s
$LN5@z900__or_s:

; 198  :     else
; 199  :     {
; 200  :         BYTE* skey_ptr  = _get_storekey_ptr( abs, K );

  0006e	0f b6 54 24 60	 movzx	 edx, BYTE PTR K$[rsp]
  00073	48 8b 4c 24 50	 mov	 rcx, QWORD PTR abs$[rsp]
  00078	e8 00 00 00 00	 call	 _get_storekey_ptr
  0007d	48 89 44 24 30	 mov	 QWORD PTR skey_ptr$3[rsp], rax

; 201  :         OR_SKEY( skey_ptr, bits );

  00082	0f b6 44 24 58	 movzx	 eax, BYTE PTR bits$[rsp]
  00087	48 8b 4c 24 30	 mov	 rcx, QWORD PTR skey_ptr$3[rsp]
  0008c	0f b6 09	 movzx	 ecx, BYTE PTR [rcx]
  0008f	0b c8		 or	 ecx, eax
  00091	8b c1		 mov	 eax, ecx
  00093	48 8b 4c 24 30	 mov	 rcx, QWORD PTR skey_ptr$3[rsp]
  00098	88 01		 mov	 BYTE PTR [rcx], al
$LN6@z900__or_s:

; 202  :     }
; 203  : }

  0009a	48 83 c4 48	 add	 rsp, 72			; 00000048H
  0009e	c3		 ret	 0
z900__or_storage_key ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\scescsi.c
_TEXT	SEGMENT
tv68 = 64
regs$ = 112
z900_sdias_store_status PROC

; 662  : {

$LN11:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	56		 push	 rsi
  00006	57		 push	 rdi
  00007	48 83 ec 58	 sub	 rsp, 88			; 00000058H
$LN4@z900_sdias:

; 663  :     UNREFERENCED(regs);

  0000b	33 c0		 xor	 eax, eax
  0000d	85 c0		 test	 eax, eax
  0000f	75 fa		 jne	 SHORT $LN4@z900_sdias

; 664  : 
; 665  :     sdias_size = sysblk.mainsize < SDIAS_STORE_STATUS_MAXSIZE

  00011	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00018	48 81 b8 90 00
	00 00 00 00 00
	02		 cmp	 QWORD PTR [rax+144], 33554432 ; 02000000H
  00023	73 15		 jae	 SHORT $LN9@z900_sdias
  00025	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  0002c	48 8b 80 90 00
	00 00		 mov	 rax, QWORD PTR [rax+144]
  00033	48 89 44 24 40	 mov	 QWORD PTR tv68[rsp], rax
  00038	eb 09		 jmp	 SHORT $LN10@z900_sdias
$LN9@z900_sdias:
  0003a	48 c7 44 24 40
	00 00 00 02	 mov	 QWORD PTR tv68[rsp], 33554432 ; 02000000H
$LN10@z900_sdias:
  00043	8b 44 24 40	 mov	 eax, DWORD PTR tv68[rsp]
  00047	89 05 00 00 00
	00		 mov	 DWORD PTR sdias_size, eax

; 666  :                ? sysblk.mainsize : SDIAS_STORE_STATUS_MAXSIZE;
; 667  : 
; 668  :     if(!sdias_hsa)

  0004d	48 83 3d 00 00
	00 00 00	 cmp	 QWORD PTR sdias_hsa, 0
  00055	75 12		 jne	 SHORT $LN5@z900_sdias

; 669  :         sdias_hsa = malloc(SDIAS_STORE_STATUS_MAXSIZE);

  00057	b9 00 00 00 02	 mov	 ecx, 33554432		; 02000000H
  0005c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_malloc
  00062	48 89 05 00 00
	00 00		 mov	 QWORD PTR sdias_hsa, rax
$LN5@z900_sdias:

; 670  : 
; 671  :     if(sdias_hsa)

  00069	48 83 3d 00 00
	00 00 00	 cmp	 QWORD PTR sdias_hsa, 0
  00071	74 21		 je	 SHORT $LN6@z900_sdias

; 672  :         memcpy(sdias_hsa,sysblk.mainstor,sdias_size);

  00073	8b 05 00 00 00
	00		 mov	 eax, DWORD PTR sdias_size
  00079	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  00080	48 8b 3d 00 00
	00 00		 mov	 rdi, QWORD PTR sdias_hsa
  00087	48 8b b1 98 00
	00 00		 mov	 rsi, QWORD PTR [rcx+152]
  0008e	8b c8		 mov	 ecx, eax
  00090	f3 a4		 rep movsb
  00092	eb 47		 jmp	 SHORT $LN7@z900_sdias
$LN6@z900_sdias:

; 673  :     else
; 674  :         // "Store Status save to HSA failed"
; 675  :         WRMSG( HHC00655, "E" );

  00094	b9 01 00 00 00	 mov	 ecx, 1
  00099	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  0009f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG193168
  000a6	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  000ab	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG193169
  000b2	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  000b7	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  000bc	41 b9 03 00 00
	00		 mov	 r9d, 3
  000c2	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG193170
  000c9	ba a3 02 00 00	 mov	 edx, 675		; 000002a3H
  000ce	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG193171
  000d5	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg
$LN7@z900_sdias:

; 676  : }

  000db	48 83 c4 58	 add	 rsp, 88			; 00000058H
  000df	5f		 pop	 rdi
  000e0	5e		 pop	 rsi
  000e1	c3		 ret	 0
z900_sdias_store_status ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\scescsi.c
_TEXT	SEGMENT
regs$ = 48
z900_sdias_store_status_clear PROC

; 648  : {

$LN7:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 28	 sub	 rsp, 40			; 00000028H
$LN4@z900_sdias:

; 649  :     UNREFERENCED(regs);

  00009	33 c0		 xor	 eax, eax
  0000b	85 c0		 test	 eax, eax
  0000d	75 fa		 jne	 SHORT $LN4@z900_sdias

; 650  : 
; 651  :     sdias_size = 0;

  0000f	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR sdias_size, 0

; 652  :     if(sdias_hsa)

  00019	48 83 3d 00 00
	00 00 00	 cmp	 QWORD PTR sdias_hsa, 0
  00021	74 0d		 je	 SHORT $LN5@z900_sdias

; 653  :         free(sdias_hsa);

  00023	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR sdias_hsa
  0002a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free
$LN5@z900_sdias:

; 654  :     sdias_hsa = NULL;

  00030	48 c7 05 00 00
	00 00 00 00 00
	00		 mov	 QWORD PTR sdias_hsa, 0

; 655  : }

  0003b	48 83 c4 28	 add	 rsp, 40			; 00000028H
  0003f	c3		 ret	 0
z900_sdias_store_status_clear ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\scescsi.c
_TEXT	SEGMENT
sccb$ = 8
z900_sclp_sdias_event PROC

; 599  : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx

; 600  : #if 0
; 601  : SCCB_EVD_HDR *evd_hdr = (SCCB_EVD_HDR*)(sccb + 1);
; 602  : U16 sccb_len;
; 603  : U16 evd_len;
; 604  : 
; 605  :     if( ARCH_DEP(sdias_request)(SCLP_READ_EVENT_DATA, evd_hdr) )
; 606  :     {
; 607  :        /* Zero all fields */
; 608  :         memset (evd_hdr, 0, sizeof(SCCB_EVD_HDR));
; 609  : 
; 610  :         /* Set length in event header */
; 611  :         evd_len = sizeof(SCCB_EVD_HDR) + sizeof(SCCB_HWL_BK);
; 612  :         STORE_HW(evd_hdr->totlen, evd_len);
; 613  : 
; 614  :         /* Set type in event header */
; 615  :         evd_hdr->type = SCCB_EVD_TYPE_HWL;
; 616  : 
; 617  :         /* Update SCCB length field if variable request */
; 618  :         if (sccb->type & SCCB_TYPE_VARIABLE)
; 619  :         {
; 620  :             FETCH_HW(evd_len, evd_hdr->totlen);
; 621  :             sccb_len = evd_len + sizeof(SCCB_HEADER);
; 622  :             STORE_HW(sccb->length, sccb_len);
; 623  :             sccb->type &= ~SCCB_TYPE_VARIABLE;
; 624  :         }
; 625  : 
; 626  :         /* Set response code X'0020' in SCCB header */
; 627  :         sccb->reas = SCCB_REAS_NONE;
; 628  :         sccb->resp = SCCB_RESP_COMPLETE;
; 629  :     }
; 630  : #else
; 631  :     sccb->reas = SCCB_REAS_NONE;

  00005	48 8b 44 24 08	 mov	 rax, QWORD PTR sccb$[rsp]
  0000a	c6 40 06 00	 mov	 BYTE PTR [rax+6], 0

; 632  :     sccb->resp = SCCB_RESP_BACKOUT;

  0000e	48 8b 44 24 08	 mov	 rax, QWORD PTR sccb$[rsp]
  00013	c6 40 07 40	 mov	 BYTE PTR [rax+7], 64	; 00000040H

; 633  : #endif
; 634  : }

  00017	c3		 ret	 0
z900_sclp_sdias_event ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\scescsi.c
_TEXT	SEGMENT
evd_hdr$ = 0
sccb$ = 32
z900_sclp_sdias_request PROC

; 570  : {

$LN3:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 18	 sub	 rsp, 24

; 571  : SCCB_EVD_HDR    *evd_hdr = (SCCB_EVD_HDR*)(sccb + 1);

  00009	48 8b 44 24 20	 mov	 rax, QWORD PTR sccb$[rsp]
  0000e	48 83 c0 08	 add	 rax, 8
  00012	48 89 04 24	 mov	 QWORD PTR evd_hdr$[rsp], rax

; 572  : 
; 573  : #if 0
; 574  :     if( ARCH_DEP(sdias_request)(SCLP_WRITE_EVENT_DATA, evd_hdr) )
; 575  :     {
; 576  :         /* Set response code X'0040' in SCCB header */
; 577  :         sccb->reas = SCCB_REAS_NONE;
; 578  :         sccb->resp = SCCB_RESP_BACKOUT;
; 579  :     }
; 580  :     else
; 581  :     {
; 582  :         /* Set response code X'0020' in SCCB header */
; 583  :         sccb->reas = SCCB_REAS_NONE;
; 584  :         sccb->resp = SCCB_RESP_COMPLETE;
; 585  :     }
; 586  : #else
; 587  :     sccb->reas = SCCB_REAS_NONE;

  00016	48 8b 44 24 20	 mov	 rax, QWORD PTR sccb$[rsp]
  0001b	c6 40 06 00	 mov	 BYTE PTR [rax+6], 0

; 588  :     sccb->resp = SCCB_RESP_BACKOUT;

  0001f	48 8b 44 24 20	 mov	 rax, QWORD PTR sccb$[rsp]
  00024	c6 40 07 40	 mov	 BYTE PTR [rax+7], 64	; 00000040H

; 589  : #endif
; 590  :     /* Indicate Event Processed */
; 591  :     evd_hdr->flag |= SCCB_EVD_FLAG_PROC;

  00028	48 8b 04 24	 mov	 rax, QWORD PTR evd_hdr$[rsp]
  0002c	0f b6 40 03	 movzx	 eax, BYTE PTR [rax+3]
  00030	0f ba e8 07	 bts	 eax, 7
  00034	48 8b 0c 24	 mov	 rcx, QWORD PTR evd_hdr$[rsp]
  00038	88 41 03	 mov	 BYTE PTR [rcx+3], al

; 592  : }

  0003b	48 83 c4 18	 add	 rsp, 24
  0003f	c3		 ret	 0
z900_sclp_sdias_request ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\scescsi.c
_TEXT	SEGMENT
evd_len$ = 32
sccb_len$ = 36
evd_hdr$ = 40
sccb$ = 64
z900_sclp_hwl_event PROC

; 533  : {

$LN5:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	57		 push	 rdi
  00006	48 83 ec 30	 sub	 rsp, 48			; 00000030H

; 534  : SCCB_EVD_HDR *evd_hdr = (SCCB_EVD_HDR*)(sccb + 1);

  0000a	48 8b 44 24 40	 mov	 rax, QWORD PTR sccb$[rsp]
  0000f	48 83 c0 08	 add	 rax, 8
  00013	48 89 44 24 28	 mov	 QWORD PTR evd_hdr$[rsp], rax

; 535  : U16 sccb_len;
; 536  : U16 evd_len;
; 537  : 
; 538  :     if( ARCH_DEP(hwl_request)(SCLP_READ_EVENT_DATA, evd_hdr) )

  00018	48 8b 54 24 28	 mov	 rdx, QWORD PTR evd_hdr$[rsp]
  0001d	b9 05 00 77 00	 mov	 ecx, 7798789		; 00770005H
  00022	e8 00 00 00 00	 call	 z900_hwl_request
  00027	85 c0		 test	 eax, eax
  00029	0f 84 b0 00 00
	00		 je	 $LN2@z900_sclp_

; 539  :     {
; 540  :        /* Zero all fields */
; 541  :         memset (evd_hdr, 0, sizeof(SCCB_EVD_HDR));

  0002f	48 8b 7c 24 28	 mov	 rdi, QWORD PTR evd_hdr$[rsp]
  00034	33 c0		 xor	 eax, eax
  00036	b9 06 00 00 00	 mov	 ecx, 6
  0003b	f3 aa		 rep stosb

; 542  : 
; 543  :         /* Set length in event header */
; 544  :         evd_len = sizeof(SCCB_EVD_HDR) + sizeof(SCCB_HWL_BK);

  0003d	b8 30 00 00 00	 mov	 eax, 48			; 00000030H
  00042	66 89 44 24 20	 mov	 WORD PTR evd_len$[rsp], ax

; 545  :         STORE_HW(evd_hdr->totlen, evd_len);

  00047	0f b7 4c 24 20	 movzx	 ecx, WORD PTR evd_len$[rsp]
  0004c	e8 00 00 00 00	 call	 _byteswap_ushort
  00051	48 8b 4c 24 28	 mov	 rcx, QWORD PTR evd_hdr$[rsp]
  00056	0f b7 d0	 movzx	 edx, ax
  00059	e8 00 00 00 00	 call	 store_hw_noswap

; 546  : 
; 547  :         /* Set type in event header */
; 548  :         evd_hdr->type = SCCB_EVD_TYPE_HWL;

  0005e	48 8b 44 24 28	 mov	 rax, QWORD PTR evd_hdr$[rsp]
  00063	c6 40 02 0c	 mov	 BYTE PTR [rax+2], 12

; 549  : 
; 550  :         /* Update SCCB length field if variable request */
; 551  :         if (sccb->type & SCCB_TYPE_VARIABLE)

  00067	48 8b 44 24 40	 mov	 rax, QWORD PTR sccb$[rsp]
  0006c	0f b6 40 05	 movzx	 eax, BYTE PTR [rax+5]
  00070	25 80 00 00 00	 and	 eax, 128		; 00000080H
  00075	85 c0		 test	 eax, eax
  00077	74 54		 je	 SHORT $LN3@z900_sclp_

; 552  :         {
; 553  :             FETCH_HW(evd_len, evd_hdr->totlen);

  00079	48 8b 44 24 28	 mov	 rax, QWORD PTR evd_hdr$[rsp]
  0007e	48 8b c8	 mov	 rcx, rax
  00081	e8 00 00 00 00	 call	 fetch_hw_noswap
  00086	0f b7 c8	 movzx	 ecx, ax
  00089	e8 00 00 00 00	 call	 _byteswap_ushort
  0008e	66 89 44 24 20	 mov	 WORD PTR evd_len$[rsp], ax

; 554  :             sccb_len = evd_len + sizeof(SCCB_HEADER);

  00093	0f b7 44 24 20	 movzx	 eax, WORD PTR evd_len$[rsp]
  00098	48 83 c0 08	 add	 rax, 8
  0009c	66 89 44 24 24	 mov	 WORD PTR sccb_len$[rsp], ax

; 555  :             STORE_HW(sccb->length, sccb_len);

  000a1	0f b7 4c 24 24	 movzx	 ecx, WORD PTR sccb_len$[rsp]
  000a6	e8 00 00 00 00	 call	 _byteswap_ushort
  000ab	48 8b 4c 24 40	 mov	 rcx, QWORD PTR sccb$[rsp]
  000b0	0f b7 d0	 movzx	 edx, ax
  000b3	e8 00 00 00 00	 call	 store_hw_noswap

; 556  :             sccb->type &= ~SCCB_TYPE_VARIABLE;

  000b8	48 8b 44 24 40	 mov	 rax, QWORD PTR sccb$[rsp]
  000bd	0f b6 40 05	 movzx	 eax, BYTE PTR [rax+5]
  000c1	0f ba f0 07	 btr	 eax, 7
  000c5	48 8b 4c 24 40	 mov	 rcx, QWORD PTR sccb$[rsp]
  000ca	88 41 05	 mov	 BYTE PTR [rcx+5], al
$LN3@z900_sclp_:

; 557  :         }
; 558  : 
; 559  :         /* Set response code X'0020' in SCCB header */
; 560  :         sccb->reas = SCCB_REAS_NONE;

  000cd	48 8b 44 24 40	 mov	 rax, QWORD PTR sccb$[rsp]
  000d2	c6 40 06 00	 mov	 BYTE PTR [rax+6], 0

; 561  :         sccb->resp = SCCB_RESP_COMPLETE;

  000d6	48 8b 44 24 40	 mov	 rax, QWORD PTR sccb$[rsp]
  000db	c6 40 07 20	 mov	 BYTE PTR [rax+7], 32	; 00000020H
$LN2@z900_sclp_:

; 562  :     }
; 563  : }

  000df	48 83 c4 30	 add	 rsp, 48			; 00000030H
  000e3	5f		 pop	 rdi
  000e4	c3		 ret	 0
z900_sclp_hwl_event ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\scescsi.c
_TEXT	SEGMENT
evd_hdr$ = 80
hwl_bk$ = 88
tv75 = 96
tv76 = 104
tv67 = 112
sccb$ = 144
z900_sclp_hwl_request PROC

; 501  : {

$LN9:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 81 ec 88 00
	00 00		 sub	 rsp, 136		; 00000088H

; 502  : SCCB_EVD_HDR    *evd_hdr = (SCCB_EVD_HDR*)(sccb + 1);

  0000c	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR sccb$[rsp]
  00014	48 83 c0 08	 add	 rax, 8
  00018	48 89 44 24 50	 mov	 QWORD PTR evd_hdr$[rsp], rax

; 503  : SCCB_HWL_BK     *hwl_bk  = (SCCB_HWL_BK*)(evd_hdr + 1);

  0001d	48 8b 44 24 50	 mov	 rax, QWORD PTR evd_hdr$[rsp]
  00022	48 83 c0 06	 add	 rax, 6
  00026	48 89 44 24 58	 mov	 QWORD PTR hwl_bk$[rsp], rax

; 504  : 
; 505  :     // "Hardware loader: %s request: SCCB = 0x%"PRIX64
; 506  :     WRMSG( HHC00661, "I",

  0002b	48 8b 44 24 58	 mov	 rax, QWORD PTR hwl_bk$[rsp]
  00030	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  00033	83 f8 02	 cmp	 eax, 2
  00036	75 0e		 jne	 SHORT $LN7@z900_sclp_
  00038	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG193120
  0003f	48 89 44 24 68	 mov	 QWORD PTR tv76[rsp], rax
  00044	eb 30		 jmp	 SHORT $LN8@z900_sclp_
$LN7@z900_sclp_:
  00046	48 8b 44 24 58	 mov	 rax, QWORD PTR hwl_bk$[rsp]
  0004b	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  0004e	85 c0		 test	 eax, eax
  00050	75 0e		 jne	 SHORT $LN5@z900_sclp_
  00052	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG193121
  00059	48 89 44 24 60	 mov	 QWORD PTR tv75[rsp], rax
  0005e	eb 0c		 jmp	 SHORT $LN6@z900_sclp_
$LN5@z900_sclp_:
  00060	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG193122
  00067	48 89 44 24 60	 mov	 QWORD PTR tv75[rsp], rax
$LN6@z900_sclp_:
  0006c	48 8b 44 24 60	 mov	 rax, QWORD PTR tv75[rsp]
  00071	48 89 44 24 68	 mov	 QWORD PTR tv76[rsp], rax
$LN8@z900_sclp_:
  00076	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  0007d	48 8b 80 98 00
	00 00		 mov	 rax, QWORD PTR [rax+152]
  00084	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR sccb$[rsp]
  0008c	48 2b c8	 sub	 rcx, rax
  0008f	48 8b c1	 mov	 rax, rcx
  00092	48 89 44 24 70	 mov	 QWORD PTR tv67[rsp], rax
  00097	b9 01 00 00 00	 mov	 ecx, 1
  0009c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  000a2	48 8b 4c 24 70	 mov	 rcx, QWORD PTR tv67[rsp]
  000a7	48 89 4c 24 40	 mov	 QWORD PTR [rsp+64], rcx
  000ac	48 8b 4c 24 68	 mov	 rcx, QWORD PTR tv76[rsp]
  000b1	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  000b6	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG193123
  000bd	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  000c2	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG193124
  000c9	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  000ce	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  000d3	41 b9 03 00 00
	00		 mov	 r9d, 3
  000d9	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG193125
  000e0	ba fd 01 00 00	 mov	 edx, 509		; 000001fdH
  000e5	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG193126
  000ec	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 507  :         SCCB_HWL_TYPE_INFO == hwl_bk->type ? "INFO" :
; 508  :         SCCB_HWL_TYPE_LOAD == hwl_bk->type ? "LOAD" : "unknown",
; 509  :         (BYTE*)sccb - (BYTE*)sysblk.mainstor );
; 510  : 
; 511  :     if( ARCH_DEP(hwl_request)(SCLP_WRITE_EVENT_DATA, evd_hdr) )

  000f2	48 8b 54 24 50	 mov	 rdx, QWORD PTR evd_hdr$[rsp]
  000f7	b9 05 00 76 00	 mov	 ecx, 7733253		; 00760005H
  000fc	e8 00 00 00 00	 call	 z900_hwl_request
  00101	85 c0		 test	 eax, eax
  00103	74 1a		 je	 SHORT $LN2@z900_sclp_

; 512  :     {
; 513  :         /* Set response code X'0040' in SCCB header */
; 514  :         sccb->reas = SCCB_REAS_NONE;

  00105	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR sccb$[rsp]
  0010d	c6 40 06 00	 mov	 BYTE PTR [rax+6], 0

; 515  :         sccb->resp = SCCB_RESP_BACKOUT;

  00111	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR sccb$[rsp]
  00119	c6 40 07 40	 mov	 BYTE PTR [rax+7], 64	; 00000040H

; 516  :     }

  0011d	eb 18		 jmp	 SHORT $LN3@z900_sclp_
$LN2@z900_sclp_:

; 517  :     else
; 518  :     {
; 519  :         /* Set response code X'0020' in SCCB header */
; 520  :         sccb->reas = SCCB_REAS_NONE;

  0011f	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR sccb$[rsp]
  00127	c6 40 06 00	 mov	 BYTE PTR [rax+6], 0

; 521  :         sccb->resp = SCCB_RESP_COMPLETE;

  0012b	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR sccb$[rsp]
  00133	c6 40 07 20	 mov	 BYTE PTR [rax+7], 32	; 00000020H
$LN3@z900_sclp_:

; 522  :     }
; 523  : 
; 524  :     /* Indicate Event Processed */
; 525  :     evd_hdr->flag |= SCCB_EVD_FLAG_PROC;

  00137	48 8b 44 24 50	 mov	 rax, QWORD PTR evd_hdr$[rsp]
  0013c	0f b6 40 03	 movzx	 eax, BYTE PTR [rax+3]
  00140	0f ba e8 07	 bts	 eax, 7
  00144	48 8b 4c 24 50	 mov	 rcx, QWORD PTR evd_hdr$[rsp]
  00149	88 41 03	 mov	 BYTE PTR [rcx+3], al

; 526  : }

  0014c	48 81 c4 88 00
	00 00		 add	 rsp, 136		; 00000088H
  00153	c3		 ret	 0
z900_sclp_hwl_request ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\scescsi.c
_TEXT	SEGMENT
bootfile$ = 80
tv87 = 88
tv150 = 96
tv91 = 104
regs$ = 112
dev$ = 144
cpu$ = 152
clear$ = 160
ldind$ = 168
s390_load_boot PROC

; 759  : {

$LN8:
  00000	44 89 4c 24 20	 mov	 DWORD PTR [rsp+32], r9d
  00005	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  0000a	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  0000e	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00013	48 81 ec 88 00
	00 00		 sub	 rsp, 136		; 00000088H

; 760  : REGS *regs = sysblk.regs[cpu];

  0001a	48 63 84 24 98
	00 00 00	 movsxd	 rax, DWORD PTR cpu$[rsp]
  00022	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  00029	48 8b 84 c1 98
	0b 00 00	 mov	 rax, QWORD PTR [rcx+rax*8+2968]
  00031	48 89 44 24 70	 mov	 QWORD PTR regs$[rsp], rax

; 761  : int bootfile;
; 762  : 
; 763  :     bootfile = support_boot(dev);

  00036	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  0003e	e8 00 00 00 00	 call	 support_boot
  00043	89 44 24 50	 mov	 DWORD PTR bootfile$[rsp], eax

; 764  : 
; 765  :     if(bootfile < 0 || !hwl_fn[bootfile])

  00047	83 7c 24 50 00	 cmp	 DWORD PTR bootfile$[rsp], 0
  0004c	7c 13		 jl	 SHORT $LN3@s390_load_
  0004e	48 63 44 24 50	 movsxd	 rax, DWORD PTR bootfile$[rsp]
  00053	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:hwl_fn
  0005a	48 83 3c c1 00	 cmp	 QWORD PTR [rcx+rax*8], 0
  0005f	75 0a		 jne	 SHORT $LN2@s390_load_
$LN3@s390_load_:

; 766  :         return -1; // Should not occur, has been validated.

  00061	b8 ff ff ff ff	 mov	 eax, -1
  00066	e9 3c 01 00 00	 jmp	 $LN1@s390_load_
$LN2@s390_load_:

; 767  : 
; 768  :     if (ARCH_DEP(common_load_begin) (cpu, clear) != 0)

  0006b	8b 94 24 a0 00
	00 00		 mov	 edx, DWORD PTR clear$[rsp]
  00072	8b 8c 24 98 00
	00 00		 mov	 ecx, DWORD PTR cpu$[rsp]
  00079	e8 00 00 00 00	 call	 s390_common_load_begin
  0007e	85 c0		 test	 eax, eax
  00080	74 0a		 je	 SHORT $LN4@s390_load_

; 769  :         return -1;

  00082	b8 ff ff ff ff	 mov	 eax, -1
  00087	e9 1b 01 00 00	 jmp	 $LN1@s390_load_
$LN4@s390_load_:

; 770  : 
; 771  :     if( ARCH_DEP(load_main) (hwl_fn[bootfile], 0, 0) < 0)

  0008c	48 63 44 24 50	 movsxd	 rax, DWORD PTR bootfile$[rsp]
  00091	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:hwl_fn
  00098	45 33 c0	 xor	 r8d, r8d
  0009b	33 d2		 xor	 edx, edx
  0009d	48 8b 0c c1	 mov	 rcx, QWORD PTR [rcx+rax*8]
  000a1	e8 00 00 00 00	 call	 s390_load_main
  000a6	85 c0		 test	 eax, eax
  000a8	0f 8d 94 00 00
	00		 jge	 $LN5@s390_load_

; 772  :     {
; 773  :         // "Cannot load bootstrap loader %s: %s"
; 774  :         WRMSG( HHC00656, "E", hwl_fn[ bootfile ], strerror( errno ));

  000ae	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno
  000b4	8b 08		 mov	 ecx, DWORD PTR [rax]
  000b6	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_strerror
  000bc	48 89 44 24 58	 mov	 QWORD PTR tv87[rsp], rax
  000c1	48 63 4c 24 50	 movsxd	 rcx, DWORD PTR bootfile$[rsp]
  000c6	48 89 4c 24 68	 mov	 QWORD PTR tv91[rsp], rcx
  000cb	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:hwl_fn
  000d2	48 89 54 24 60	 mov	 QWORD PTR tv150[rsp], rdx
  000d7	b9 01 00 00 00	 mov	 ecx, 1
  000dc	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  000e2	48 8b 4c 24 58	 mov	 rcx, QWORD PTR tv87[rsp]
  000e7	48 89 4c 24 40	 mov	 QWORD PTR [rsp+64], rcx
  000ec	48 8b 4c 24 60	 mov	 rcx, QWORD PTR tv150[rsp]
  000f1	48 8b 54 24 68	 mov	 rdx, QWORD PTR tv91[rsp]
  000f6	48 8b 0c d1	 mov	 rcx, QWORD PTR [rcx+rdx*8]
  000fa	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  000ff	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG180061
  00106	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  0010b	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG180062
  00112	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00117	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  0011c	41 b9 03 00 00
	00		 mov	 r9d, 3
  00122	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG180063
  00129	ba 06 03 00 00	 mov	 edx, 774		; 00000306H
  0012e	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG180064
  00135	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 775  :         return -1;

  0013b	b8 ff ff ff ff	 mov	 eax, -1
  00140	eb 65		 jmp	 SHORT $LN1@s390_load_
$LN5@s390_load_:

; 776  :     }
; 777  :     sysblk.main_clear = sysblk.xpnd_clear = 0;

  00142	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00149	8b 80 94 12 00
	00		 mov	 eax, DWORD PTR [rax+4756]
  0014f	0f ba f0 0f	 btr	 eax, 15
  00153	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  0015a	89 81 94 12 00
	00		 mov	 DWORD PTR [rcx+4756], eax
  00160	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00167	8b 80 94 12 00
	00		 mov	 eax, DWORD PTR [rax+4756]
  0016d	0f ba f0 0e	 btr	 eax, 14
  00171	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  00178	89 81 94 12 00
	00		 mov	 DWORD PTR [rcx+4756], eax

; 778  : 
; 779  :     if( ARCH_DEP(store_boot_parms)(dev, ldind) )

  0017e	8b 94 24 a8 00
	00 00		 mov	 edx, DWORD PTR ldind$[rsp]
  00185	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  0018d	e8 00 00 00 00	 call	 s390_store_boot_parms
  00192	85 c0		 test	 eax, eax
  00194	74 07		 je	 SHORT $LN6@s390_load_

; 780  :         return -1;

  00196	b8 ff ff ff ff	 mov	 eax, -1
  0019b	eb 0a		 jmp	 SHORT $LN1@s390_load_
$LN6@s390_load_:

; 781  : 
; 782  :     return ARCH_DEP(common_load_finish)(regs);

  0019d	48 8b 4c 24 70	 mov	 rcx, QWORD PTR regs$[rsp]
  001a2	e8 00 00 00 00	 call	 s390_common_load_finish
$LN1@s390_load_:

; 783  : }

  001a7	48 81 c4 88 00
	00 00		 add	 rsp, 136		; 00000088H
  001ae	c3		 ret	 0
s390_load_boot ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\scescsi.c
_TEXT	SEGMENT
scp_len$ = 32
tv80 = 36
xml$ = 40
sb_bk$ = 48
tv212 = 56
psa$ = 64
dev$ = 112
ldind$ = 120
s390_store_boot_parms PROC

; 685  : {

$LN12:
  00000	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00004	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00009	56		 push	 rsi
  0000a	57		 push	 rdi
  0000b	48 83 ec 58	 sub	 rsp, 88			; 00000058H

; 686  : PSA *psa;
; 687  : SCSI_BOOT_BK *sb_bk;
; 688  : BYTE *xml;
; 689  : int scp_len;
; 690  : 
; 691  :     if(sysblk.mainsize < (BOOT_PARM_ADDR + 0x1000))

  0000f	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00016	48 81 b8 90 00
	00 00 00 e0 ff
	01		 cmp	 QWORD PTR [rax+144], 33546240 ; 01ffe000H
  00021	73 0a		 jae	 SHORT $LN2@s390_store

; 692  :         return -1;

  00023	b8 ff ff ff ff	 mov	 eax, -1
  00028	e9 3a 05 00 00	 jmp	 $LN1@s390_store
$LN2@s390_store:

; 693  : 
; 694  :     psa = (PSA*)sysblk.mainstor;

  0002d	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00034	48 8b 80 98 00
	00 00		 mov	 rax, QWORD PTR [rax+152]
  0003b	48 89 44 24 40	 mov	 QWORD PTR psa$[rsp], rax

; 695  : 
; 696  :     STORE_DW(psa->iplccw2,BOOT_PARM_ADDR);

  00040	b9 00 d0 ff 01	 mov	 ecx, 33542144		; 01ffd000H
  00045	e8 00 00 00 00	 call	 _byteswap_uint64
  0004a	48 8b 4c 24 40	 mov	 rcx, QWORD PTR psa$[rsp]
  0004f	48 83 c1 10	 add	 rcx, 16
  00053	48 8b d0	 mov	 rdx, rax
  00056	e8 00 00 00 00	 call	 store_dw_noswap

; 697  : 
; 698  :     sb_bk = (SCSI_BOOT_BK*)(sysblk.mainstor + BOOT_PARM_ADDR);

  0005b	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00062	48 8b 80 98 00
	00 00		 mov	 rax, QWORD PTR [rax+152]
  00069	48 05 00 d0 ff
	01		 add	 rax, 33542144		; 01ffd000H
  0006f	48 89 44 24 30	 mov	 QWORD PTR sb_bk$[rsp], rax

; 699  :     memset(sb_bk,0x00,0x1000);

  00074	48 8b 7c 24 30	 mov	 rdi, QWORD PTR sb_bk$[rsp]
  00079	33 c0		 xor	 eax, eax
  0007b	b9 00 10 00 00	 mov	 ecx, 4096		; 00001000H
  00080	f3 aa		 rep stosb

; 700  : 
; 701  :     sb_bk->ldind = ldind ? SCSI_BOOT_LDIND_DUMP : SCSI_BOOT_LDIND_LOAD;

  00082	83 7c 24 78 00	 cmp	 DWORD PTR ldind$[rsp], 0
  00087	74 0a		 je	 SHORT $LN8@s390_store
  00089	c7 44 24 24 20
	00 00 00	 mov	 DWORD PTR tv80[rsp], 32	; 00000020H
  00091	eb 08		 jmp	 SHORT $LN9@s390_store
$LN8@s390_store:
  00093	c7 44 24 24 10
	00 00 00	 mov	 DWORD PTR tv80[rsp], 16
$LN9@s390_store:
  0009b	48 8b 44 24 30	 mov	 rax, QWORD PTR sb_bk$[rsp]
  000a0	0f b6 4c 24 24	 movzx	 ecx, BYTE PTR tv80[rsp]
  000a5	88 88 48 01 00
	00		 mov	 BYTE PTR [rax+328], cl

; 702  : 
; 703  :     STORE_HW(sb_bk->devno,dev->devnum);

  000ab	48 8b 44 24 70	 mov	 rax, QWORD PTR dev$[rsp]
  000b0	0f b7 48 48	 movzx	 ecx, WORD PTR [rax+72]
  000b4	e8 00 00 00 00	 call	 _byteswap_ushort
  000b9	48 8b 4c 24 30	 mov	 rcx, QWORD PTR sb_bk$[rsp]
  000be	48 81 c1 4e 01
	00 00		 add	 rcx, 334		; 0000014eH
  000c5	0f b7 d0	 movzx	 edx, ax
  000c8	e8 00 00 00 00	 call	 store_hw_noswap

; 704  :     STORE_DW(sb_bk->wwpn,scsi_lddev_wwpn[ldind]);

  000cd	48 63 44 24 78	 movsxd	 rax, DWORD PTR ldind$[rsp]
  000d2	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:scsi_lddev_wwpn
  000d9	48 8b 0c c1	 mov	 rcx, QWORD PTR [rcx+rax*8]
  000dd	e8 00 00 00 00	 call	 _byteswap_uint64
  000e2	48 8b 4c 24 30	 mov	 rcx, QWORD PTR sb_bk$[rsp]
  000e7	48 81 c1 54 01
	00 00		 add	 rcx, 340		; 00000154H
  000ee	48 8b d0	 mov	 rdx, rax
  000f1	e8 00 00 00 00	 call	 store_dw_noswap

; 705  :     STORE_DW(sb_bk->lun,scsi_lddev_lun[ldind]);

  000f6	48 63 44 24 78	 movsxd	 rax, DWORD PTR ldind$[rsp]
  000fb	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:scsi_lddev_lun
  00102	48 8b 0c c1	 mov	 rcx, QWORD PTR [rcx+rax*8]
  00106	e8 00 00 00 00	 call	 _byteswap_uint64
  0010b	48 8b 4c 24 30	 mov	 rcx, QWORD PTR sb_bk$[rsp]
  00110	48 81 c1 5c 01
	00 00		 add	 rcx, 348		; 0000015cH
  00117	48 8b d0	 mov	 rdx, rax
  0011a	e8 00 00 00 00	 call	 store_dw_noswap

; 706  :     STORE_FW(sb_bk->prog,scsi_lddev_prog[ldind]);

  0011f	48 63 44 24 78	 movsxd	 rax, DWORD PTR ldind$[rsp]
  00124	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:scsi_lddev_prog
  0012b	8b 0c 81	 mov	 ecx, DWORD PTR [rcx+rax*4]
  0012e	e8 00 00 00 00	 call	 _byteswap_ulong
  00133	48 8b 4c 24 30	 mov	 rcx, QWORD PTR sb_bk$[rsp]
  00138	48 81 c1 64 01
	00 00		 add	 rcx, 356		; 00000164H
  0013f	8b d0		 mov	 edx, eax
  00141	e8 00 00 00 00	 call	 store_fw_noswap

; 707  :     STORE_DW(sb_bk->brlba,scsi_lddev_brlba[ldind]);

  00146	48 63 44 24 78	 movsxd	 rax, DWORD PTR ldind$[rsp]
  0014b	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:scsi_lddev_brlba
  00152	48 8b 0c c1	 mov	 rcx, QWORD PTR [rcx+rax*8]
  00156	e8 00 00 00 00	 call	 _byteswap_uint64
  0015b	48 8b 4c 24 30	 mov	 rcx, QWORD PTR sb_bk$[rsp]
  00160	48 81 c1 74 01
	00 00		 add	 rcx, 372		; 00000174H
  00167	48 8b d0	 mov	 rdx, rax
  0016a	e8 00 00 00 00	 call	 store_dw_noswap

; 708  : 
; 709  :     if(scsi_lddev_scpdata[ldind])

  0016f	48 63 44 24 78	 movsxd	 rax, DWORD PTR ldind$[rsp]
  00174	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:scsi_lddev_scpdata
  0017b	48 83 3c c1 00	 cmp	 QWORD PTR [rcx+rax*8], 0
  00180	74 6f		 je	 SHORT $LN3@s390_store

; 710  :     {
; 711  :         scp_len = strlen((char*)scsi_lddev_scpdata[ldind]);

  00182	48 63 44 24 78	 movsxd	 rax, DWORD PTR ldind$[rsp]
  00187	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:scsi_lddev_scpdata
  0018e	48 8b 0c c1	 mov	 rcx, QWORD PTR [rcx+rax*8]
  00192	e8 00 00 00 00	 call	 strlen
  00197	89 44 24 20	 mov	 DWORD PTR scp_len$[rsp], eax

; 712  :         if(scp_len > 256)

  0019b	81 7c 24 20 00
	01 00 00	 cmp	 DWORD PTR scp_len$[rsp], 256 ; 00000100H
  001a3	7e 08		 jle	 SHORT $LN5@s390_store

; 713  :             scp_len = 256; // Sanity check

  001a5	c7 44 24 20 00
	01 00 00	 mov	 DWORD PTR scp_len$[rsp], 256 ; 00000100H
$LN5@s390_store:

; 714  :         STORE_FW(sb_bk->scp_len,scp_len);

  001ad	8b 4c 24 20	 mov	 ecx, DWORD PTR scp_len$[rsp]
  001b1	e8 00 00 00 00	 call	 _byteswap_ulong
  001b6	48 8b 4c 24 30	 mov	 rcx, QWORD PTR sb_bk$[rsp]
  001bb	48 81 c1 7c 01
	00 00		 add	 rcx, 380		; 0000017cH
  001c2	8b d0		 mov	 edx, eax
  001c4	e8 00 00 00 00	 call	 store_fw_noswap

; 715  :         memcpy((BYTE*)(sb_bk+1), scsi_lddev_scpdata[ldind], scp_len);

  001c9	48 63 44 24 20	 movsxd	 rax, DWORD PTR scp_len$[rsp]
  001ce	48 63 4c 24 78	 movsxd	 rcx, DWORD PTR ldind$[rsp]
  001d3	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:scsi_lddev_scpdata
  001da	48 8b 7c 24 30	 mov	 rdi, QWORD PTR sb_bk$[rsp]
  001df	48 81 c7 84 02
	00 00		 add	 rdi, 644		; 00000284H
  001e6	48 8b 34 ca	 mov	 rsi, QWORD PTR [rdx+rcx*8]
  001ea	48 8b c8	 mov	 rcx, rax
  001ed	f3 a4		 rep movsb

; 716  :     }

  001ef	eb 08		 jmp	 SHORT $LN4@s390_store
$LN3@s390_store:

; 717  :     else
; 718  :         scp_len = 0;

  001f1	c7 44 24 20 00
	00 00 00	 mov	 DWORD PTR scp_len$[rsp], 0
$LN4@s390_store:

; 719  : 
; 720  :     scp_len += 7;

  001f9	8b 44 24 20	 mov	 eax, DWORD PTR scp_len$[rsp]
  001fd	83 c0 07	 add	 eax, 7
  00200	89 44 24 20	 mov	 DWORD PTR scp_len$[rsp], eax

; 721  :     scp_len &= ~7;

  00204	8b 44 24 20	 mov	 eax, DWORD PTR scp_len$[rsp]
  00208	83 e0 f8	 and	 eax, -8
  0020b	89 44 24 20	 mov	 DWORD PTR scp_len$[rsp], eax

; 722  : 
; 723  :     STORE_FW(sb_bk->xml_off,sizeof(SCSI_BOOT_BK) + scp_len);

  0020f	48 63 44 24 20	 movsxd	 rax, DWORD PTR scp_len$[rsp]
  00214	48 05 84 02 00
	00		 add	 rax, 644		; 00000284H
  0021a	8b c8		 mov	 ecx, eax
  0021c	e8 00 00 00 00	 call	 _byteswap_ulong
  00221	48 8b 4c 24 30	 mov	 rcx, QWORD PTR sb_bk$[rsp]
  00226	8b d0		 mov	 edx, eax
  00228	e8 00 00 00 00	 call	 store_fw_noswap

; 724  : 
; 725  :     STORE_FW(sb_bk->scp_off,sizeof(SCSI_BOOT_BK) + scp_len - 8); // ZZ:???

  0022d	48 63 44 24 20	 movsxd	 rax, DWORD PTR scp_len$[rsp]
  00232	48 05 7c 02 00
	00		 add	 rax, 636		; 0000027cH
  00238	8b c8		 mov	 ecx, eax
  0023a	e8 00 00 00 00	 call	 _byteswap_ulong
  0023f	48 8b 4c 24 30	 mov	 rcx, QWORD PTR sb_bk$[rsp]
  00244	48 83 c1 08	 add	 rcx, 8
  00248	8b d0		 mov	 edx, eax
  0024a	e8 00 00 00 00	 call	 store_fw_noswap

; 726  : 
; 727  :     xml = (BYTE*)(sb_bk+1) + scp_len;

  0024f	48 63 44 24 20	 movsxd	 rax, DWORD PTR scp_len$[rsp]
  00254	48 8b 4c 24 30	 mov	 rcx, QWORD PTR sb_bk$[rsp]
  00259	48 8d 84 01 84
	02 00 00	 lea	 rax, QWORD PTR [rcx+rax+644]
  00261	48 89 44 24 28	 mov	 QWORD PTR xml$[rsp], rax

; 728  : 
; 729  :     xml += sprintf((char*)xml, "<?xml version=\"1.0\" encoding =\"UTF-8\"?>\n" );

  00266	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG180024
  0026d	48 8b 4c 24 28	 mov	 rcx, QWORD PTR xml$[rsp]
  00272	e8 00 00 00 00	 call	 sprintf
  00277	48 98		 cdqe
  00279	48 8b 4c 24 28	 mov	 rcx, QWORD PTR xml$[rsp]
  0027e	48 03 c8	 add	 rcx, rax
  00281	48 8b c1	 mov	 rax, rcx
  00284	48 89 44 24 28	 mov	 QWORD PTR xml$[rsp], rax

; 730  :     xml += sprintf((char*)xml, "<eServer_ipl_script version=\"1.0\">\n" );

  00289	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG180025
  00290	48 8b 4c 24 28	 mov	 rcx, QWORD PTR xml$[rsp]
  00295	e8 00 00 00 00	 call	 sprintf
  0029a	48 98		 cdqe
  0029c	48 8b 4c 24 28	 mov	 rcx, QWORD PTR xml$[rsp]
  002a1	48 03 c8	 add	 rcx, rax
  002a4	48 8b c1	 mov	 rax, rcx
  002a7	48 89 44 24 28	 mov	 QWORD PTR xml$[rsp], rax

; 731  :     xml += sprintf((char*)xml,  "<type>%s</type>\n", ldind ? "dump" : "ipl" );

  002ac	83 7c 24 78 00	 cmp	 DWORD PTR ldind$[rsp], 0
  002b1	74 0e		 je	 SHORT $LN10@s390_store
  002b3	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG180026
  002ba	48 89 44 24 38	 mov	 QWORD PTR tv212[rsp], rax
  002bf	eb 0c		 jmp	 SHORT $LN11@s390_store
$LN10@s390_store:
  002c1	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG180027
  002c8	48 89 44 24 38	 mov	 QWORD PTR tv212[rsp], rax
$LN11@s390_store:
  002cd	4c 8b 44 24 38	 mov	 r8, QWORD PTR tv212[rsp]
  002d2	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG180028
  002d9	48 8b 4c 24 28	 mov	 rcx, QWORD PTR xml$[rsp]
  002de	e8 00 00 00 00	 call	 sprintf
  002e3	48 98		 cdqe
  002e5	48 8b 4c 24 28	 mov	 rcx, QWORD PTR xml$[rsp]
  002ea	48 03 c8	 add	 rcx, rax
  002ed	48 8b c1	 mov	 rax, rcx
  002f0	48 89 44 24 28	 mov	 QWORD PTR xml$[rsp], rax

; 732  :     xml += sprintf((char*)xml,  "<ipl_control_section id=\"herculesipl-1\">\n" );

  002f5	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG180029
  002fc	48 8b 4c 24 28	 mov	 rcx, QWORD PTR xml$[rsp]
  00301	e8 00 00 00 00	 call	 sprintf
  00306	48 98		 cdqe
  00308	48 8b 4c 24 28	 mov	 rcx, QWORD PTR xml$[rsp]
  0030d	48 03 c8	 add	 rcx, rax
  00310	48 8b c1	 mov	 rax, rcx
  00313	48 89 44 24 28	 mov	 QWORD PTR xml$[rsp], rax

; 733  :     xml += sprintf((char*)xml,   "<ipl_platform_loader>\n" );

  00318	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG180030
  0031f	48 8b 4c 24 28	 mov	 rcx, QWORD PTR xml$[rsp]
  00324	e8 00 00 00 00	 call	 sprintf
  00329	48 98		 cdqe
  0032b	48 8b 4c 24 28	 mov	 rcx, QWORD PTR xml$[rsp]
  00330	48 03 c8	 add	 rcx, rax
  00333	48 8b c1	 mov	 rax, rcx
  00336	48 89 44 24 28	 mov	 QWORD PTR xml$[rsp], rax

; 734  :     xml += sprintf((char*)xml,    "<fcp_ipl>\n" );

  0033b	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG180031
  00342	48 8b 4c 24 28	 mov	 rcx, QWORD PTR xml$[rsp]
  00347	e8 00 00 00 00	 call	 sprintf
  0034c	48 98		 cdqe
  0034e	48 8b 4c 24 28	 mov	 rcx, QWORD PTR xml$[rsp]
  00353	48 03 c8	 add	 rcx, rax
  00356	48 8b c1	 mov	 rax, rcx
  00359	48 89 44 24 28	 mov	 QWORD PTR xml$[rsp], rax

; 735  :     xml += sprintf((char*)xml,     "<devno>0x%4.4X</devno>\n", dev->devnum);

  0035e	48 8b 44 24 70	 mov	 rax, QWORD PTR dev$[rsp]
  00363	0f b7 40 48	 movzx	 eax, WORD PTR [rax+72]
  00367	44 8b c0	 mov	 r8d, eax
  0036a	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG180032
  00371	48 8b 4c 24 28	 mov	 rcx, QWORD PTR xml$[rsp]
  00376	e8 00 00 00 00	 call	 sprintf
  0037b	48 98		 cdqe
  0037d	48 8b 4c 24 28	 mov	 rcx, QWORD PTR xml$[rsp]
  00382	48 03 c8	 add	 rcx, rax
  00385	48 8b c1	 mov	 rax, rcx
  00388	48 89 44 24 28	 mov	 QWORD PTR xml$[rsp], rax

; 736  :     xml += sprintf((char*)xml,     "<wwpn>0x%16.16"PRIX64"</wwpn>\n", scsi_lddev_wwpn[ldind]);

  0038d	48 63 44 24 78	 movsxd	 rax, DWORD PTR ldind$[rsp]
  00392	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:scsi_lddev_wwpn
  00399	4c 8b 04 c1	 mov	 r8, QWORD PTR [rcx+rax*8]
  0039d	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG180033
  003a4	48 8b 4c 24 28	 mov	 rcx, QWORD PTR xml$[rsp]
  003a9	e8 00 00 00 00	 call	 sprintf
  003ae	48 98		 cdqe
  003b0	48 8b 4c 24 28	 mov	 rcx, QWORD PTR xml$[rsp]
  003b5	48 03 c8	 add	 rcx, rax
  003b8	48 8b c1	 mov	 rax, rcx
  003bb	48 89 44 24 28	 mov	 QWORD PTR xml$[rsp], rax

; 737  :     xml += sprintf((char*)xml,     "<lun>0x%16.16"PRIX64"</lun>\n", scsi_lddev_lun[ldind]);

  003c0	48 63 44 24 78	 movsxd	 rax, DWORD PTR ldind$[rsp]
  003c5	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:scsi_lddev_lun
  003cc	4c 8b 04 c1	 mov	 r8, QWORD PTR [rcx+rax*8]
  003d0	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG180034
  003d7	48 8b 4c 24 28	 mov	 rcx, QWORD PTR xml$[rsp]
  003dc	e8 00 00 00 00	 call	 sprintf
  003e1	48 98		 cdqe
  003e3	48 8b 4c 24 28	 mov	 rcx, QWORD PTR xml$[rsp]
  003e8	48 03 c8	 add	 rcx, rax
  003eb	48 8b c1	 mov	 rax, rcx
  003ee	48 89 44 24 28	 mov	 QWORD PTR xml$[rsp], rax

; 738  :     xml += sprintf((char*)xml,     "<boot_program_selector>0x%8.8X</boot_program_selector>\n", scsi_lddev_prog[ldind]);

  003f3	48 63 44 24 78	 movsxd	 rax, DWORD PTR ldind$[rsp]
  003f8	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:scsi_lddev_prog
  003ff	44 8b 04 81	 mov	 r8d, DWORD PTR [rcx+rax*4]
  00403	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG180035
  0040a	48 8b 4c 24 28	 mov	 rcx, QWORD PTR xml$[rsp]
  0040f	e8 00 00 00 00	 call	 sprintf
  00414	48 98		 cdqe
  00416	48 8b 4c 24 28	 mov	 rcx, QWORD PTR xml$[rsp]
  0041b	48 03 c8	 add	 rcx, rax
  0041e	48 8b c1	 mov	 rax, rcx
  00421	48 89 44 24 28	 mov	 QWORD PTR xml$[rsp], rax

; 739  :     xml += sprintf((char*)xml,     "<br_lba>0x%16.16"PRIX64"</br_lba>\n", scsi_lddev_brlba[ldind]);

  00426	48 63 44 24 78	 movsxd	 rax, DWORD PTR ldind$[rsp]
  0042b	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:scsi_lddev_brlba
  00432	4c 8b 04 c1	 mov	 r8, QWORD PTR [rcx+rax*8]
  00436	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG180036
  0043d	48 8b 4c 24 28	 mov	 rcx, QWORD PTR xml$[rsp]
  00442	e8 00 00 00 00	 call	 sprintf
  00447	48 98		 cdqe
  00449	48 8b 4c 24 28	 mov	 rcx, QWORD PTR xml$[rsp]
  0044e	48 03 c8	 add	 rcx, rax
  00451	48 8b c1	 mov	 rax, rcx
  00454	48 89 44 24 28	 mov	 QWORD PTR xml$[rsp], rax

; 740  :     xml += sprintf((char*)xml,    "</fcp_ipl>\n" );

  00459	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG180037
  00460	48 8b 4c 24 28	 mov	 rcx, QWORD PTR xml$[rsp]
  00465	e8 00 00 00 00	 call	 sprintf
  0046a	48 98		 cdqe
  0046c	48 8b 4c 24 28	 mov	 rcx, QWORD PTR xml$[rsp]
  00471	48 03 c8	 add	 rcx, rax
  00474	48 8b c1	 mov	 rax, rcx
  00477	48 89 44 24 28	 mov	 QWORD PTR xml$[rsp], rax

; 741  :     xml += sprintf((char*)xml,   "</ipl_platform_loader>\n" );

  0047c	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG180038
  00483	48 8b 4c 24 28	 mov	 rcx, QWORD PTR xml$[rsp]
  00488	e8 00 00 00 00	 call	 sprintf
  0048d	48 98		 cdqe
  0048f	48 8b 4c 24 28	 mov	 rcx, QWORD PTR xml$[rsp]
  00494	48 03 c8	 add	 rcx, rax
  00497	48 8b c1	 mov	 rax, rcx
  0049a	48 89 44 24 28	 mov	 QWORD PTR xml$[rsp], rax

; 742  :     if(scp_len)

  0049f	83 7c 24 20 00	 cmp	 DWORD PTR scp_len$[rsp], 0
  004a4	74 79		 je	 SHORT $LN6@s390_store

; 743  :     {
; 744  :       xml += sprintf((char*)xml, "<system_control_program>\n" );

  004a6	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG180040
  004ad	48 8b 4c 24 28	 mov	 rcx, QWORD PTR xml$[rsp]
  004b2	e8 00 00 00 00	 call	 sprintf
  004b7	48 98		 cdqe
  004b9	48 8b 4c 24 28	 mov	 rcx, QWORD PTR xml$[rsp]
  004be	48 03 c8	 add	 rcx, rax
  004c1	48 8b c1	 mov	 rax, rcx
  004c4	48 89 44 24 28	 mov	 QWORD PTR xml$[rsp], rax

; 745  :       xml += sprintf((char*)xml,  "<parameter_string>%s</parameter_string>\n", scsi_lddev_scpdata[ldind]);

  004c9	48 63 44 24 78	 movsxd	 rax, DWORD PTR ldind$[rsp]
  004ce	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:scsi_lddev_scpdata
  004d5	4c 8b 04 c1	 mov	 r8, QWORD PTR [rcx+rax*8]
  004d9	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG180041
  004e0	48 8b 4c 24 28	 mov	 rcx, QWORD PTR xml$[rsp]
  004e5	e8 00 00 00 00	 call	 sprintf
  004ea	48 98		 cdqe
  004ec	48 8b 4c 24 28	 mov	 rcx, QWORD PTR xml$[rsp]
  004f1	48 03 c8	 add	 rcx, rax
  004f4	48 8b c1	 mov	 rax, rcx
  004f7	48 89 44 24 28	 mov	 QWORD PTR xml$[rsp], rax

; 746  :       xml += sprintf((char*)xml, "</system_control_program>\n" );

  004fc	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG180042
  00503	48 8b 4c 24 28	 mov	 rcx, QWORD PTR xml$[rsp]
  00508	e8 00 00 00 00	 call	 sprintf
  0050d	48 98		 cdqe
  0050f	48 8b 4c 24 28	 mov	 rcx, QWORD PTR xml$[rsp]
  00514	48 03 c8	 add	 rcx, rax
  00517	48 8b c1	 mov	 rax, rcx
  0051a	48 89 44 24 28	 mov	 QWORD PTR xml$[rsp], rax
$LN6@s390_store:

; 747  :     }
; 748  :     xml += sprintf((char*)xml,  "</ipl_control_section>\n" );

  0051f	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG180043
  00526	48 8b 4c 24 28	 mov	 rcx, QWORD PTR xml$[rsp]
  0052b	e8 00 00 00 00	 call	 sprintf
  00530	48 98		 cdqe
  00532	48 8b 4c 24 28	 mov	 rcx, QWORD PTR xml$[rsp]
  00537	48 03 c8	 add	 rcx, rax
  0053a	48 8b c1	 mov	 rax, rcx
  0053d	48 89 44 24 28	 mov	 QWORD PTR xml$[rsp], rax

; 749  :     xml += sprintf((char*)xml, "</eServer_ipl_script>\n" );

  00542	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG180044
  00549	48 8b 4c 24 28	 mov	 rcx, QWORD PTR xml$[rsp]
  0054e	e8 00 00 00 00	 call	 sprintf
  00553	48 98		 cdqe
  00555	48 8b 4c 24 28	 mov	 rcx, QWORD PTR xml$[rsp]
  0055a	48 03 c8	 add	 rcx, rax
  0055d	48 8b c1	 mov	 rax, rcx
  00560	48 89 44 24 28	 mov	 QWORD PTR xml$[rsp], rax

; 750  : 
; 751  :     return 0;

  00565	33 c0		 xor	 eax, eax
$LN1@s390_store:

; 752  : }

  00567	48 83 c4 58	 add	 rsp, 88			; 00000058H
  0056b	5f		 pop	 rdi
  0056c	5e		 pop	 rsi
  0056d	c3		 ret	 0
s390_store_boot_parms ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\scescsi.c
_TEXT	SEGMENT
tv70 = 64
pending_req$1 = 68
tv83 = 72
hwl_bk$ = 80
sclp_command$ = 128
evd_hdr$ = 136
s390_hwl_request PROC

; 439  : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	89 4c 24 08	 mov	 DWORD PTR [rsp+8], ecx
  00009	56		 push	 rsi
  0000a	57		 push	 rdi
  0000b	48 83 ec 68	 sub	 rsp, 104		; 00000068H

; 440  : SCCB_HWL_BK *hwl_bk = (SCCB_HWL_BK*)(evd_hdr + 1);

  0000f	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR evd_hdr$[rsp]
  00017	48 83 c0 06	 add	 rax, 6
  0001b	48 89 44 24 50	 mov	 QWORD PTR hwl_bk$[rsp], rax

; 441  : 
; 442  : static SCCB_HWL_BK static_hwl_bk;
; 443  : static int hwl_pending;
; 444  : 
; 445  :     if(sclp_command == SCLP_READ_EVENT_DATA)

  00020	81 bc 24 80 00
	00 00 05 00 77
	00		 cmp	 DWORD PTR sclp_command$[rsp], 7798789 ; 00770005H
  0002b	75 4c		 jne	 SHORT $LN4@s390_hwl_r

; 446  :     {
; 447  :     int pending_req = hwl_pending;

  0002d	8b 05 00 00 00
	00		 mov	 eax, DWORD PTR ?hwl_pending@?1??s390_hwl_request@@9@9
  00033	89 44 24 44	 mov	 DWORD PTR pending_req$1[rsp], eax

; 448  : 
; 449  :         /* Return no data if the hardware loader thread is still active */
; 450  :         if(hwl_tid)

  00037	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR hwl_tid, 0
  0003e	74 07		 je	 SHORT $LN5@s390_hwl_r

; 451  :             return 0;

  00040	33 c0		 xor	 eax, eax
  00042	e9 40 01 00 00	 jmp	 $LN1@s390_hwl_r
$LN5@s390_hwl_r:

; 452  : 
; 453  :         /* Update the hwl_bk copy in the SCCB */
; 454  :         if(hwl_pending)

  00047	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?hwl_pending@?1??s390_hwl_request@@9@9, 0
  0004e	74 16		 je	 SHORT $LN6@s390_hwl_r

; 455  :             *hwl_bk = static_hwl_bk;

  00050	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:?static_hwl_bk@?1??s390_hwl_request@@9@9
  00057	48 8b 7c 24 50	 mov	 rdi, QWORD PTR hwl_bk$[rsp]
  0005c	48 8b f0	 mov	 rsi, rax
  0005f	b9 2a 00 00 00	 mov	 ecx, 42			; 0000002aH
  00064	f3 a4		 rep movsb
$LN6@s390_hwl_r:

; 456  : 
; 457  :         /* Reset the pending flag */
; 458  :         hwl_pending = 0;

  00066	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?hwl_pending@?1??s390_hwl_request@@9@9, 0

; 459  : 
; 460  :         /* Return true if a request was pending */
; 461  :         return pending_req;

  00070	8b 44 24 44	 mov	 eax, DWORD PTR pending_req$1[rsp]
  00074	e9 0e 01 00 00	 jmp	 $LN1@s390_hwl_r
$LN4@s390_hwl_r:

; 462  :     }
; 463  : 
; 464  :     switch(hwl_bk->type) {

  00079	48 8b 44 24 50	 mov	 rax, QWORD PTR hwl_bk$[rsp]
  0007e	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  00081	88 44 24 40	 mov	 BYTE PTR tv70[rsp], al
  00085	80 7c 24 40 00	 cmp	 BYTE PTR tv70[rsp], 0
  0008a	74 0c		 je	 SHORT $LN8@s390_hwl_r
  0008c	80 7c 24 40 02	 cmp	 BYTE PTR tv70[rsp], 2
  00091	74 05		 je	 SHORT $LN7@s390_hwl_r
  00093	e9 8f 00 00 00	 jmp	 $LN11@s390_hwl_r
$LN7@s390_hwl_r:
$LN8@s390_hwl_r:

; 465  : 
; 466  :     case SCCB_HWL_TYPE_INFO:
; 467  :     case SCCB_HWL_TYPE_LOAD:
; 468  : 
; 469  :         /* Return error if the hwl thread is already active */
; 470  :         if( hwl_tid )

  00098	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR hwl_tid, 0
  0009f	74 0a		 je	 SHORT $LN9@s390_hwl_r

; 471  :             return -1;

  000a1	b8 ff ff ff ff	 mov	 eax, -1
  000a6	e9 dc 00 00 00	 jmp	 $LN1@s390_hwl_r
$LN9@s390_hwl_r:

; 472  : 
; 473  :         /* Take a copy of the hwl_bk in the SCCB */
; 474  :         static_hwl_bk = *hwl_bk;

  000ab	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:?static_hwl_bk@?1??s390_hwl_request@@9@9
  000b2	48 8b f8	 mov	 rdi, rax
  000b5	48 8b 74 24 50	 mov	 rsi, QWORD PTR hwl_bk$[rsp]
  000ba	b9 2a 00 00 00	 mov	 ecx, 42			; 0000002aH
  000bf	f3 a4		 rep movsb

; 475  : 
; 476  :         /* Reset pending flag */
; 477  :         hwl_pending = 0;

  000c1	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?hwl_pending@?1??s390_hwl_request@@9@9, 0

; 478  : 
; 479  :         /* Create the hwl thread */
; 480  :         if( create_thread(&hwl_tid, &sysblk.detattr,

  000cb	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  000d2	48 05 88 10 00
	00		 add	 rax, 4232		; 00001088H
  000d8	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG179917
  000df	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  000e4	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG179918
  000eb	48 89 4c 24 20	 mov	 QWORD PTR [rsp+32], rcx
  000f0	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:?static_hwl_bk@?1??s390_hwl_request@@9@9
  000f7	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:s390_hwl_thread
  000fe	48 8b d0	 mov	 rdx, rax
  00101	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:hwl_tid
  00108	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_create_thread
  0010e	85 c0		 test	 eax, eax
  00110	74 07		 je	 SHORT $LN10@s390_hwl_r

; 481  :           ARCH_DEP(hwl_thread), &static_hwl_bk, "hwl_thread") )
; 482  :             return -1;

  00112	b8 ff ff ff ff	 mov	 eax, -1
  00117	eb 6e		 jmp	 SHORT $LN1@s390_hwl_r
$LN10@s390_hwl_r:

; 483  : 
; 484  :         /* Set pending flag */
; 485  :         hwl_pending = 1;

  00119	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR ?hwl_pending@?1??s390_hwl_request@@9@9, 1

; 486  : 
; 487  :         return 0;

  00123	33 c0		 xor	 eax, eax
  00125	eb 60		 jmp	 SHORT $LN1@s390_hwl_r
$LN11@s390_hwl_r:

; 488  : 
; 489  :     default:
; 490  :         // "Unknown hardware loader request type %2.2X"
; 491  :         WRMSG( HHC00654, "E", hwl_bk->type );

  00127	48 8b 44 24 50	 mov	 rax, QWORD PTR hwl_bk$[rsp]
  0012c	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  0012f	89 44 24 48	 mov	 DWORD PTR tv83[rsp], eax
  00133	b9 01 00 00 00	 mov	 ecx, 1
  00138	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  0013e	8b 4c 24 48	 mov	 ecx, DWORD PTR tv83[rsp]
  00142	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  00146	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG179920
  0014d	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  00152	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG179921
  00159	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  0015e	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00163	41 b9 03 00 00
	00		 mov	 r9d, 3
  00169	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG179922
  00170	ba eb 01 00 00	 mov	 edx, 491		; 000001ebH
  00175	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG179923
  0017c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 492  :         return -1;

  00182	b8 ff ff ff ff	 mov	 eax, -1
$LN1@s390_hwl_r:

; 493  :     }
; 494  : }

  00187	48 83 c4 68	 add	 rsp, 104		; 00000068H
  0018b	5f		 pop	 rdi
  0018c	5e		 pop	 rsi
  0018d	c3		 ret	 0
s390_hwl_request ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\scescsi.c
_TEXT	SEGMENT
size$1 = 80
hwl_bk$ = 88
tv74 = 96
tv147 = 100
tv91 = 104
tv165 = 112
tv128 = 120
st$2 = 128
__$ArrayPad$ = 184
arg$ = 208
s390_hwl_thread PROC

; 381  : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 81 ec c8 00
	00 00		 sub	 rsp, 200		; 000000c8H
  0000c	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00013	48 33 c4	 xor	 rax, rsp
  00016	48 89 84 24 b8
	00 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 382  : SCCB_HWL_BK *hwl_bk = (SCCB_HWL_BK*) arg;

  0001e	48 8b 84 24 d0
	00 00 00	 mov	 rax, QWORD PTR arg$[rsp]
  00026	48 89 44 24 58	 mov	 QWORD PTR hwl_bk$[rsp], rax

; 383  : 
; 384  :     if(hwl_bk->file < HWL_MAXFILETYPE && hwl_fn[hwl_bk->file])

  0002b	48 8b 44 24 58	 mov	 rax, QWORD PTR hwl_bk$[rsp]
  00030	0f b6 40 01	 movzx	 eax, BYTE PTR [rax+1]
  00034	83 f8 08	 cmp	 eax, 8
  00037	0f 8d 51 01 00
	00		 jge	 $LN4@s390_hwl_t
  0003d	48 8b 44 24 58	 mov	 rax, QWORD PTR hwl_bk$[rsp]
  00042	0f b6 40 01	 movzx	 eax, BYTE PTR [rax+1]
  00046	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:hwl_fn
  0004d	48 83 3c c1 00	 cmp	 QWORD PTR [rcx+rax*8], 0
  00052	0f 84 36 01 00
	00		 je	 $LN4@s390_hwl_t

; 385  :     {
; 386  :         switch(hwl_bk->type) {

  00058	48 8b 44 24 58	 mov	 rax, QWORD PTR hwl_bk$[rsp]
  0005d	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  00060	88 44 24 60	 mov	 BYTE PTR tv74[rsp], al
  00064	80 7c 24 60 00	 cmp	 BYTE PTR tv74[rsp], 0
  00069	0f 84 13 01 00
	00		 je	 $LN9@s390_hwl_t
  0006f	80 7c 24 60 02	 cmp	 BYTE PTR tv74[rsp], 2
  00074	74 05		 je	 SHORT $LN6@s390_hwl_t
  00076	e9 11 01 00 00	 jmp	 $LN2@s390_hwl_t
$LN6@s390_hwl_t:

; 387  : 
; 388  :         /* INFO request returns the required region size in 4K pages */
; 389  :         case SCCB_HWL_TYPE_INFO:
; 390  :             {
; 391  :             struct stat st;
; 392  : 
; 393  :                 if(!stat(hwl_fn[hwl_bk->file], &st) )

  0007b	48 8b 44 24 58	 mov	 rax, QWORD PTR hwl_bk$[rsp]
  00080	0f b6 40 01	 movzx	 eax, BYTE PTR [rax+1]
  00084	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:hwl_fn
  0008b	48 8d 94 24 80
	00 00 00	 lea	 rdx, QWORD PTR st$2[rsp]
  00093	48 8b 0c c1	 mov	 rcx, QWORD PTR [rcx+rax*8]
  00097	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__stat64
  0009d	85 c0		 test	 eax, eax
  0009f	75 4e		 jne	 SHORT $LN7@s390_hwl_t

; 394  :                 {
; 395  :                 U32     size;
; 396  : 
; 397  :                     size = st.st_size;

  000a1	8b 84 24 98 00
	00 00		 mov	 eax, DWORD PTR st$2[rsp+24]
  000a8	89 44 24 50	 mov	 DWORD PTR size$1[rsp], eax

; 398  :                     size += 0x00000FFF;

  000ac	8b 44 24 50	 mov	 eax, DWORD PTR size$1[rsp]
  000b0	05 ff 0f 00 00	 add	 eax, 4095		; 00000fffH
  000b5	89 44 24 50	 mov	 DWORD PTR size$1[rsp], eax

; 399  :                     size &= 0xFFFFF000;

  000b9	8b 44 24 50	 mov	 eax, DWORD PTR size$1[rsp]
  000bd	25 00 f0 ff ff	 and	 eax, -4096		; fffff000H
  000c2	89 44 24 50	 mov	 DWORD PTR size$1[rsp], eax

; 400  :                     size >>= 12;

  000c6	8b 44 24 50	 mov	 eax, DWORD PTR size$1[rsp]
  000ca	c1 e8 0c	 shr	 eax, 12
  000cd	89 44 24 50	 mov	 DWORD PTR size$1[rsp], eax

; 401  : 
; 402  :                     STORE_FW(hwl_bk->size,size);

  000d1	8b 4c 24 50	 mov	 ecx, DWORD PTR size$1[rsp]
  000d5	e8 00 00 00 00	 call	 _byteswap_ulong
  000da	48 8b 4c 24 58	 mov	 rcx, QWORD PTR hwl_bk$[rsp]
  000df	48 83 c1 26	 add	 rcx, 38			; 00000026H
  000e3	8b d0		 mov	 edx, eax
  000e5	e8 00 00 00 00	 call	 store_fw_noswap

; 403  :                 }

  000ea	e9 91 00 00 00	 jmp	 $LN8@s390_hwl_t
$LN7@s390_hwl_t:

; 404  :                 else
; 405  :                     // "Hardware loader %s: %s"
; 406  :                     WRMSG( HHC00652, "E", hwl_fn[ hwl_bk->file ], strerror( errno ));

  000ef	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno
  000f5	8b 08		 mov	 ecx, DWORD PTR [rax]
  000f7	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_strerror
  000fd	48 89 44 24 68	 mov	 QWORD PTR tv91[rsp], rax
  00102	48 8b 4c 24 58	 mov	 rcx, QWORD PTR hwl_bk$[rsp]
  00107	0f b6 49 01	 movzx	 ecx, BYTE PTR [rcx+1]
  0010b	48 89 4c 24 78	 mov	 QWORD PTR tv128[rsp], rcx
  00110	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:hwl_fn
  00117	48 89 54 24 70	 mov	 QWORD PTR tv165[rsp], rdx
  0011c	b9 01 00 00 00	 mov	 ecx, 1
  00121	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  00127	48 8b 4c 24 68	 mov	 rcx, QWORD PTR tv91[rsp]
  0012c	48 89 4c 24 40	 mov	 QWORD PTR [rsp+64], rcx
  00131	48 8b 4c 24 70	 mov	 rcx, QWORD PTR tv165[rsp]
  00136	48 8b 54 24 78	 mov	 rdx, QWORD PTR tv128[rsp]
  0013b	48 8b 0c d1	 mov	 rcx, QWORD PTR [rcx+rdx*8]
  0013f	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  00144	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG179884
  0014b	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  00150	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG179885
  00157	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  0015c	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00161	41 b9 03 00 00
	00		 mov	 r9d, 3
  00167	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG179886
  0016e	ba 96 01 00 00	 mov	 edx, 406		; 00000196H
  00173	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG179887
  0017a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg
$LN8@s390_hwl_t:

; 407  :             }
; 408  :             break;

  00180	eb 0a		 jmp	 SHORT $LN2@s390_hwl_t
$LN9@s390_hwl_t:

; 409  : 
; 410  :         /* Load request will load the image into fixed virtual storage
; 411  :            the Segment Table Origin is listed in the hwl_bk */
; 412  :         case SCCB_HWL_TYPE_LOAD:
; 413  : #if defined( FEATURE_001_ZARCH_INSTALLED_FACILITY )
; 414  :             if(!hwl_bk->asa)
; 415  :                 s390_hwl_loadfile(hwl_bk);
; 416  :             else
; 417  : #endif
; 418  :                 ARCH_DEP(hwl_loadfile)(hwl_bk);

  00182	48 8b 4c 24 58	 mov	 rcx, QWORD PTR hwl_bk$[rsp]
  00187	e8 00 00 00 00	 call	 s390_hwl_loadfile
$LN2@s390_hwl_t:

; 419  :             break;
; 420  :         }
; 421  :     }

  0018c	eb 5c		 jmp	 SHORT $LN5@s390_hwl_t
$LN4@s390_hwl_t:

; 422  :     else
; 423  :         // "Hardware loader file type %d not not supported"
; 424  :         WRMSG( HHC00653, "E", hwl_bk->file );

  0018e	48 8b 44 24 58	 mov	 rax, QWORD PTR hwl_bk$[rsp]
  00193	0f b6 40 01	 movzx	 eax, BYTE PTR [rax+1]
  00197	89 44 24 64	 mov	 DWORD PTR tv147[rsp], eax
  0019b	b9 01 00 00 00	 mov	 ecx, 1
  001a0	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  001a6	8b 4c 24 64	 mov	 ecx, DWORD PTR tv147[rsp]
  001aa	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  001ae	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG179889
  001b5	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  001ba	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG179890
  001c1	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  001c6	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  001cb	41 b9 03 00 00
	00		 mov	 r9d, 3
  001d1	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG179891
  001d8	ba a8 01 00 00	 mov	 edx, 424		; 000001a8H
  001dd	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG179892
  001e4	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg
$LN5@s390_hwl_t:

; 425  : 
; 426  :     hwl_tid = 0;

  001ea	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR hwl_tid, 0

; 427  : 
; 428  :     OBTAIN_INTLOCK(NULL);

  001f4	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG179893
  001fb	33 c9		 xor	 ecx, ecx
  001fd	e8 00 00 00 00	 call	 Obtain_Interrupt_Lock

; 429  :     sclp_attention(SCCB_EVD_TYPE_HWL);

  00202	66 b9 0c 00	 mov	 cx, 12
  00206	e8 00 00 00 00	 call	 sclp_attention

; 430  :     RELEASE_INTLOCK(NULL);

  0020b	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG179894
  00212	33 c9		 xor	 ecx, ecx
  00214	e8 00 00 00 00	 call	 Release_Interrupt_Lock

; 431  :     return NULL;

  00219	33 c0		 xor	 eax, eax

; 432  : }

  0021b	48 8b 8c 24 b8
	00 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  00223	48 33 cc	 xor	 rcx, rsp
  00226	e8 00 00 00 00	 call	 __security_check_cookie
  0022b	48 81 c4 c8 00
	00 00		 add	 rsp, 200		; 000000c8H
  00232	c3		 ret	 0
s390_hwl_thread ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\scescsi.c
_TEXT	SEGMENT
fd$ = 80
asce$ = 84
tv162 = 88
pages$ = 92
tv72 = 96
tv170 = 104
tv77 = 112
tv171 = 120
tv91 = 128
hwl_bk$ = 160
s390_hwl_loadfile PROC

; 329  : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 81 ec 98 00
	00 00		 sub	 rsp, 152		; 00000098H

; 330  :     U32   pages;                        /* Num pages to be loaded    */
; 331  :     CREG  asce;                         /* DAT Addr Space Ctl Elem   */
; 332  :     int   fd;                           /* fd of file to be loaded   */
; 333  : 
; 334  :     /* Open the file to be loaded */
; 335  :     if ((fd = open( hwl_fn[ hwl_bk->file ], O_RDONLY | O_BINARY )) < 0)

  0000c	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR hwl_bk$[rsp]
  00014	0f b6 40 01	 movzx	 eax, BYTE PTR [rax+1]
  00018	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:hwl_fn
  0001f	ba 00 80 00 00	 mov	 edx, 32768		; 00008000H
  00024	48 8b 0c c1	 mov	 rcx, QWORD PTR [rcx+rax*8]
  00028	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_open
  0002e	89 44 24 50	 mov	 DWORD PTR fd$[rsp], eax
  00032	83 7c 24 50 00	 cmp	 DWORD PTR fd$[rsp], 0
  00037	0f 8d 9b 00 00
	00		 jge	 $LN4@s390_hwl_l

; 336  :     {
; 337  :         // "%s open error: %s"
; 338  :         WRMSG( HHC00650, "E", hwl_fn[ hwl_bk->file ], strerror( errno ));

  0003d	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno
  00043	8b 08		 mov	 ecx, DWORD PTR [rax]
  00045	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_strerror
  0004b	48 89 44 24 60	 mov	 QWORD PTR tv72[rsp], rax
  00050	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR hwl_bk$[rsp]
  00058	0f b6 49 01	 movzx	 ecx, BYTE PTR [rcx+1]
  0005c	48 89 4c 24 70	 mov	 QWORD PTR tv77[rsp], rcx
  00061	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:hwl_fn
  00068	48 89 54 24 68	 mov	 QWORD PTR tv170[rsp], rdx
  0006d	b9 01 00 00 00	 mov	 ecx, 1
  00072	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  00078	48 8b 4c 24 60	 mov	 rcx, QWORD PTR tv72[rsp]
  0007d	48 89 4c 24 40	 mov	 QWORD PTR [rsp+64], rcx
  00082	48 8b 4c 24 68	 mov	 rcx, QWORD PTR tv170[rsp]
  00087	48 8b 54 24 70	 mov	 rdx, QWORD PTR tv77[rsp]
  0008c	48 8b 0c d1	 mov	 rcx, QWORD PTR [rcx+rdx*8]
  00090	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  00095	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG179851
  0009c	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  000a1	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG179852
  000a8	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  000ad	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  000b2	41 b9 03 00 00
	00		 mov	 r9d, 3
  000b8	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG179853
  000bf	ba 52 01 00 00	 mov	 edx, 338		; 00000152H
  000c4	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG179854
  000cb	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 339  :         return;

  000d1	e9 64 01 00 00	 jmp	 $LN1@s390_hwl_l

; 340  :     }

  000d6	eb 7d		 jmp	 SHORT $LN5@s390_hwl_l
$LN4@s390_hwl_l:

; 341  :     else
; 342  :         // "Loading %s"
; 343  :         WRMSG( HHC00651, "I", hwl_fn[ hwl_bk->file ]);

  000d8	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR hwl_bk$[rsp]
  000e0	0f b6 40 01	 movzx	 eax, BYTE PTR [rax+1]
  000e4	48 89 84 24 80
	00 00 00	 mov	 QWORD PTR tv91[rsp], rax
  000ec	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:hwl_fn
  000f3	48 89 4c 24 78	 mov	 QWORD PTR tv171[rsp], rcx
  000f8	b9 01 00 00 00	 mov	 ecx, 1
  000fd	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  00103	48 8b 54 24 78	 mov	 rdx, QWORD PTR tv171[rsp]
  00108	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR tv91[rsp]
  00110	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  00114	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  00119	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG179855
  00120	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  00125	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG179856
  0012c	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00131	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00136	41 b9 03 00 00
	00		 mov	 r9d, 3
  0013c	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG179857
  00143	ba 57 01 00 00	 mov	 edx, 343		; 00000157H
  00148	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG179858
  0014f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg
$LN5@s390_hwl_l:

; 344  : 
; 345  :     /* Retrieve number of pages to be loaded */
; 346  :     FETCH_FW( pages, hwl_bk->size );

  00155	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR hwl_bk$[rsp]
  0015d	48 83 c0 26	 add	 rax, 38			; 00000026H
  00161	48 8b c8	 mov	 rcx, rax
  00164	e8 00 00 00 00	 call	 fetch_fw_noswap
  00169	8b c8		 mov	 ecx, eax
  0016b	e8 00 00 00 00	 call	 _byteswap_ulong
  00170	89 44 24 5c	 mov	 DWORD PTR pages$[rsp], eax

; 347  : 
; 348  :     /* Retrieve the ASCE to determine where in guest
; 349  :        storage that the file should be loaded into. */
; 350  :     FETCH_DW( asce, hwl_bk->asce );

  00174	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR hwl_bk$[rsp]
  0017c	48 83 c0 12	 add	 rax, 18
  00180	48 8b c8	 mov	 rcx, rax
  00183	e8 00 00 00 00	 call	 fetch_dw_noswap
  00188	48 8b c8	 mov	 rcx, rax
  0018b	e8 00 00 00 00	 call	 _byteswap_uint64
  00190	89 44 24 54	 mov	 DWORD PTR asce$[rsp], eax

; 351  : 
; 352  :     /* Abort if ASCE points outside of main storage */
; 353  :     if (asce >= sysblk.mainsize)

  00194	8b 44 24 54	 mov	 eax, DWORD PTR asce$[rsp]
  00198	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  0019f	48 3b 81 90 00
	00 00		 cmp	 rax, QWORD PTR [rcx+144]
  001a6	72 5f		 jb	 SHORT $LN6@s390_hwl_l

; 354  :     {
; 355  :         // "%s is outside of main storage"
; 356  :         WRMSG( HHC00659, "E", "asce" );

  001a8	b9 01 00 00 00	 mov	 ecx, 1
  001ad	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  001b3	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG179860
  001ba	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  001bf	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG179861
  001c6	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  001cb	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG179862
  001d2	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  001d7	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  001dc	41 b9 03 00 00
	00		 mov	 r9d, 3
  001e2	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG179863
  001e9	ba 64 01 00 00	 mov	 edx, 356		; 00000164H
  001ee	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG179864
  001f5	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 357  :         close( fd );

  001fb	8b 4c 24 50	 mov	 ecx, DWORD PTR fd$[rsp]
  001ff	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_close

; 358  :         return;

  00205	eb 33		 jmp	 SHORT $LN1@s390_hwl_l
$LN6@s390_hwl_l:

; 359  :     }
; 360  : 
; 361  :     /* Load the file into guest storage */
; 362  :     switch (asce & ASCE_DT)

  00207	8b 44 24 54	 mov	 eax, DWORD PTR asce$[rsp]
  0020b	83 e0 0c	 and	 eax, 12
  0020e	89 44 24 58	 mov	 DWORD PTR tv162[rsp], eax
  00212	83 7c 24 58 00	 cmp	 DWORD PTR tv162[rsp], 0
  00217	74 02		 je	 SHORT $LN7@s390_hwl_l
  00219	eb 15		 jmp	 SHORT $LN2@s390_hwl_l
$LN7@s390_hwl_l:

; 363  :     {
; 364  : #if defined( FEATURE_001_ZARCH_INSTALLED_FACILITY )
; 365  :     case TT_R1TABL: ARCH_DEP( walk_table )( asce, fd, &pages, 3 ); break;
; 366  :     case TT_R2TABL: ARCH_DEP( walk_table )( asce, fd, &pages, 2 ); break;
; 367  :     case TT_R3TABL: ARCH_DEP( walk_table )( asce, fd, &pages, 1 ); break;
; 368  : #endif
; 369  :     case TT_SEGTAB: ARCH_DEP( walk_table )( asce, fd, &pages, 0 ); break;

  0021b	45 33 c9	 xor	 r9d, r9d
  0021e	4c 8d 44 24 5c	 lea	 r8, QWORD PTR pages$[rsp]
  00223	8b 54 24 50	 mov	 edx, DWORD PTR fd$[rsp]
  00227	8b 4c 24 54	 mov	 ecx, DWORD PTR asce$[rsp]
  0022b	e8 00 00 00 00	 call	 s390_walk_table
$LN2@s390_hwl_l:

; 370  :     }
; 371  : 
; 372  :     /* We're done. Close input file and return */
; 373  :     close( fd );

  00230	8b 4c 24 50	 mov	 ecx, DWORD PTR fd$[rsp]
  00234	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_close
$LN1@s390_hwl_l:

; 374  : }

  0023a	48 81 c4 98 00
	00 00		 add	 rsp, 152		; 00000098H
  00241	c3		 ret	 0
s390_hwl_loadfile ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\scescsi.c
_TEXT	SEGMENT
keep_walking$ = 32
to$ = 36
i$ = 40
entries$ = 44
te$ = 48
rto$ = 80
fd$ = 88
pages$ = 96
tables$ = 104
s390_walk_table PROC

; 284  : {

  00000	44 89 4c 24 20	 mov	 DWORD PTR [rsp+32], r9d
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  0000e	89 4c 24 08	 mov	 DWORD PTR [rsp+8], ecx
  00012	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 285  :     TBLTYP*  te;                        /* Pointer to Table Entry    */
; 286  :     CREG     to;                        /* Next Table's Origin       */
; 287  :     U32      entries;                   /* Number of Table Entries   */
; 288  :     U32      i;                         /* Table Entry Iterator      */
; 289  :     bool     keep_walking = true;

  00016	c6 44 24 20 01	 mov	 BYTE PTR keep_walking$[rsp], 1

; 290  : 
; 291  :     /* Tables have 2048 entries max. A table length
; 292  :        of 0 means 512 entries, 1 means 1024, etc. */
; 293  :     entries = ((rto & REGTAB_TL) + 1) * 512;

  0001b	8b 44 24 50	 mov	 eax, DWORD PTR rto$[rsp]
  0001f	83 e0 03	 and	 eax, 3
  00022	ff c0		 inc	 eax
  00024	69 c0 00 02 00
	00		 imul	 eax, eax, 512		; 00000200H
  0002a	89 44 24 2c	 mov	 DWORD PTR entries$[rsp], eax

; 294  : 
; 295  :     /* Remove bit definitions to form table origin */
; 296  :     rto &= TBLTO_MASK;

  0002e	8b 44 24 50	 mov	 eax, DWORD PTR rto$[rsp]
  00032	25 00 f0 ff 7f	 and	 eax, 2147479552		; 7ffff000H
  00037	89 44 24 50	 mov	 DWORD PTR rto$[rsp], eax

; 297  : 
; 298  :     /* Walk trough all table entries to find valid entries */
; 299  :     for (i=0; keep_walking && i < entries; i++, rto += sizeof( rto ))

  0003b	c7 44 24 28 00
	00 00 00	 mov	 DWORD PTR i$[rsp], 0
  00043	eb 16		 jmp	 SHORT $LN4@s390_walk_
$LN2@s390_walk_:
  00045	8b 44 24 28	 mov	 eax, DWORD PTR i$[rsp]
  00049	ff c0		 inc	 eax
  0004b	89 44 24 28	 mov	 DWORD PTR i$[rsp], eax
  0004f	8b 44 24 50	 mov	 eax, DWORD PTR rto$[rsp]
  00053	48 83 c0 04	 add	 rax, 4
  00057	89 44 24 50	 mov	 DWORD PTR rto$[rsp], eax
$LN4@s390_walk_:
  0005b	0f b6 44 24 20	 movzx	 eax, BYTE PTR keep_walking$[rsp]
  00060	85 c0		 test	 eax, eax
  00062	0f 84 92 00 00
	00		 je	 $LN3@s390_walk_
  00068	8b 44 24 2c	 mov	 eax, DWORD PTR entries$[rsp]
  0006c	39 44 24 28	 cmp	 DWORD PTR i$[rsp], eax
  00070	0f 83 84 00 00
	00		 jae	 $LN3@s390_walk_

; 300  :     {
; 301  :         /* Point to table entry in main storage */
; 302  :         te = (TBLTYP*)(sysblk.mainstor + rto);

  00076	8b 44 24 50	 mov	 eax, DWORD PTR rto$[rsp]
  0007a	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  00081	48 03 81 98 00
	00 00		 add	 rax, QWORD PTR [rcx+152]
  00088	48 89 44 24 30	 mov	 QWORD PTR te$[rsp], rax

; 303  : 
; 304  :         /* Fetch this Table Entry */
; 305  :         FETCH_W( to, te );

  0008d	48 8b 4c 24 30	 mov	 rcx, QWORD PTR te$[rsp]
  00092	e8 00 00 00 00	 call	 fetch_fw_noswap
  00097	8b c8		 mov	 ecx, eax
  00099	e8 00 00 00 00	 call	 _byteswap_ulong
  0009e	89 44 24 24	 mov	 DWORD PTR to$[rsp], eax

; 306  : 
; 307  :         /* Process this entry if it's not invalid */
; 308  :         if (!(to & REGSEG_INV))

  000a2	8b 44 24 24	 mov	 eax, DWORD PTR to$[rsp]
  000a6	83 e0 20	 and	 eax, 32			; 00000020H
  000a9	85 c0		 test	 eax, eax
  000ab	75 48		 jne	 SHORT $LN5@s390_walk_

; 309  :         {
; 310  :             /* Walk the next level table if there's one to be walked.
; 311  :                Otherwise load next part of file into this table's pages.
; 312  :             */
; 313  :             if ( ( to & REGTAB_TT ) != TT_SEGTAB )

  000ad	8b 44 24 24	 mov	 eax, DWORD PTR to$[rsp]
  000b1	83 e0 0c	 and	 eax, 12
  000b4	85 c0		 test	 eax, eax
  000b6	74 27		 je	 SHORT $LN6@s390_walk_

; 314  :                 keep_walking = ARCH_DEP( walk_table )( to, fd, pages, --tables );

  000b8	8b 44 24 68	 mov	 eax, DWORD PTR tables$[rsp]
  000bc	ff c8		 dec	 eax
  000be	89 44 24 68	 mov	 DWORD PTR tables$[rsp], eax
  000c2	44 8b 4c 24 68	 mov	 r9d, DWORD PTR tables$[rsp]
  000c7	4c 8b 44 24 60	 mov	 r8, QWORD PTR pages$[rsp]
  000cc	8b 54 24 58	 mov	 edx, DWORD PTR fd$[rsp]
  000d0	8b 4c 24 24	 mov	 ecx, DWORD PTR to$[rsp]
  000d4	e8 00 00 00 00	 call	 s390_walk_table
  000d9	88 44 24 20	 mov	 BYTE PTR keep_walking$[rsp], al
  000dd	eb 16		 jmp	 SHORT $LN7@s390_walk_
$LN6@s390_walk_:

; 315  :             else
; 316  :                 keep_walking = ARCH_DEP( load_pages )( to, fd, pages );

  000df	4c 8b 44 24 60	 mov	 r8, QWORD PTR pages$[rsp]
  000e4	8b 54 24 58	 mov	 edx, DWORD PTR fd$[rsp]
  000e8	8b 4c 24 24	 mov	 ecx, DWORD PTR to$[rsp]
  000ec	e8 00 00 00 00	 call	 s390_load_pages
  000f1	88 44 24 20	 mov	 BYTE PTR keep_walking$[rsp], al
$LN7@s390_walk_:
$LN5@s390_walk_:

; 317  :         }
; 318  :     }

  000f5	e9 4b ff ff ff	 jmp	 $LN2@s390_walk_
$LN3@s390_walk_:

; 319  : 
; 320  :     return keep_walking;

  000fa	0f b6 44 24 20	 movzx	 eax, BYTE PTR keep_walking$[rsp]

; 321  : }

  000ff	48 83 c4 48	 add	 rsp, 72			; 00000048H
  00103	c3		 ret	 0
s390_walk_table ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\scescsi.c
_TEXT	SEGMENT
pgo$ = 80
pti$ = 84
rc$ = 88
tv166 = 92
tv168 = 96
pte$ = 104
page$ = 112
tv147 = 120
pto$ = 144
fd$ = 152
pages$ = 160
s390_load_pages PROC

; 216  : {

  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00009	89 4c 24 08	 mov	 DWORD PTR [rsp+8], ecx
  0000d	48 81 ec 88 00
	00 00		 sub	 rsp, 136		; 00000088H

; 217  :     TBLTYP*  pte;                   /* Page Table Entry              */
; 218  :     int      pti;                   /* Page Table Entry iterator     */
; 219  :     CREG     pgo;                   /* Page Origin (i.e. PFRA)       */
; 220  :     BYTE*    page;                  /* Pointer to page in mainstor   */
; 221  :     int      rc;                    /* Return code from read()       */
; 222  : 
; 223  :     /* Remove bit definitions to form table origin */
; 224  :     pto &= PTO_MASK;

  00014	8b 84 24 90 00
	00 00		 mov	 eax, DWORD PTR pto$[rsp]
  0001b	25 c0 ff ff 7f	 and	 eax, 2147483584		; 7fffffc0H
  00020	89 84 24 90 00
	00 00		 mov	 DWORD PTR pto$[rsp], eax

; 225  : 
; 226  :     /* Keep loading file data into this page table's valid pages
; 227  :        until either the entire file has been loaded, or we run out
; 228  :        of page table entries or an abortive condition is detected.
; 229  :     */
; 230  :     for (pti=0; *pages && pti < 256; pti++, pto += sizeof( pto ))

  00027	c7 44 24 54 00
	00 00 00	 mov	 DWORD PTR pti$[rsp], 0
  0002f	eb 1c		 jmp	 SHORT $LN4@s390_load_
$LN2@s390_load_:
  00031	8b 44 24 54	 mov	 eax, DWORD PTR pti$[rsp]
  00035	ff c0		 inc	 eax
  00037	89 44 24 54	 mov	 DWORD PTR pti$[rsp], eax
  0003b	8b 84 24 90 00
	00 00		 mov	 eax, DWORD PTR pto$[rsp]
  00042	48 83 c0 04	 add	 rax, 4
  00046	89 84 24 90 00
	00 00		 mov	 DWORD PTR pto$[rsp], eax
$LN4@s390_load_:
  0004d	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR pages$[rsp]
  00055	83 38 00	 cmp	 DWORD PTR [rax], 0
  00058	0f 84 0c 02 00
	00		 je	 $LN3@s390_load_
  0005e	81 7c 24 54 00
	01 00 00	 cmp	 DWORD PTR pti$[rsp], 256 ; 00000100H
  00066	0f 8d fe 01 00
	00		 jge	 $LN3@s390_load_

; 231  :     {
; 232  :         /* Abort if table entry is outside of main storage */
; 233  :         if (pto >= sysblk.mainsize)

  0006c	8b 84 24 90 00
	00 00		 mov	 eax, DWORD PTR pto$[rsp]
  00073	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  0007a	48 3b 81 90 00
	00 00		 cmp	 rax, QWORD PTR [rcx+144]
  00081	72 5a		 jb	 SHORT $LN5@s390_load_

; 234  :         {
; 235  :             // "%s is outside of main storage"
; 236  :             WRMSG( HHC00659, "E", "table" );

  00083	b9 01 00 00 00	 mov	 ecx, 1
  00088	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  0008e	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG179799
  00095	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  0009a	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG179800
  000a1	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  000a6	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG179801
  000ad	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  000b2	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  000b7	41 b9 03 00 00
	00		 mov	 r9d, 3
  000bd	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG179802
  000c4	ba ec 00 00 00	 mov	 edx, 236		; 000000ecH
  000c9	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG179803
  000d0	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 237  :             return false; // abort!

  000d6	32 c0		 xor	 al, al
  000d8	e9 ca 01 00 00	 jmp	 $LN1@s390_load_
$LN5@s390_load_:

; 238  :         }
; 239  : 
; 240  :         /* Point to table entry in main storage */
; 241  :         pte = (TBLTYP*)(sysblk.mainstor + pto);

  000dd	8b 84 24 90 00
	00 00		 mov	 eax, DWORD PTR pto$[rsp]
  000e4	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  000eb	48 03 81 98 00
	00 00		 add	 rax, QWORD PTR [rcx+152]
  000f2	48 89 44 24 68	 mov	 QWORD PTR pte$[rsp], rax

; 242  : 
; 243  :         /* Fetch this Page Table Entry */
; 244  :         FETCH_W( pgo, pte );

  000f7	48 8b 4c 24 68	 mov	 rcx, QWORD PTR pte$[rsp]
  000fc	e8 00 00 00 00	 call	 fetch_fw_noswap
  00101	8b c8		 mov	 ecx, eax
  00103	e8 00 00 00 00	 call	 _byteswap_ulong
  00108	89 44 24 50	 mov	 DWORD PTR pgo$[rsp], eax

; 245  : 
; 246  :         /* Process this entry if it's not invalid */
; 247  :         if (!(pgo & PAGETAB_INVALID))

  0010c	8b 44 24 50	 mov	 eax, DWORD PTR pgo$[rsp]
  00110	25 00 04 00 00	 and	 eax, 1024		; 00000400H
  00115	85 c0		 test	 eax, eax
  00117	0f 85 48 01 00
	00		 jne	 $LN6@s390_load_

; 248  :         {
; 249  :             /* Get Page Frame Real Address */
; 250  :             pgo &= PFRA_MASK;

  0011d	8b 44 24 50	 mov	 eax, DWORD PTR pgo$[rsp]
  00121	25 00 f0 ff 7f	 and	 eax, 2147479552		; 7ffff000H
  00126	89 44 24 50	 mov	 DWORD PTR pgo$[rsp], eax

; 251  : 
; 252  :             /* Abort if page is outside of main storage */
; 253  :             if (pgo >= sysblk.mainsize)

  0012a	8b 44 24 50	 mov	 eax, DWORD PTR pgo$[rsp]
  0012e	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  00135	48 3b 81 90 00
	00 00		 cmp	 rax, QWORD PTR [rcx+144]
  0013c	72 5a		 jb	 SHORT $LN7@s390_load_

; 254  :             {
; 255  :                 // "%s is outside of main storage"
; 256  :                 WRMSG( HHC00659, "E", "page" );

  0013e	b9 01 00 00 00	 mov	 ecx, 1
  00143	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  00149	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG179806
  00150	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  00155	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG179807
  0015c	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  00161	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG179808
  00168	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  0016d	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00172	41 b9 03 00 00
	00		 mov	 r9d, 3
  00178	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG179809
  0017f	ba 00 01 00 00	 mov	 edx, 256		; 00000100H
  00184	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG179810
  0018b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 257  :                 return false; // abort!

  00191	32 c0		 xor	 al, al
  00193	e9 0f 01 00 00	 jmp	 $LN1@s390_load_
$LN7@s390_load_:

; 258  :             }
; 259  : 
; 260  :             /* Get mainstor address of this page */
; 261  :             page = sysblk.mainstor + pgo;

  00198	8b 44 24 50	 mov	 eax, DWORD PTR pgo$[rsp]
  0019c	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  001a3	48 03 81 98 00
	00 00		 add	 rax, QWORD PTR [rcx+152]
  001aa	48 89 44 24 70	 mov	 QWORD PTR page$[rsp], rax

; 262  : 
; 263  :             /* Load one page's worth of file data into this page */
; 264  :             if ((rc = read( fd, page, STORAGE_KEY_PAGESIZE )) < 0)

  001af	41 b8 00 10 00
	00		 mov	 r8d, 4096		; 00001000H
  001b5	48 8b 54 24 70	 mov	 rdx, QWORD PTR page$[rsp]
  001ba	8b 8c 24 98 00
	00 00		 mov	 ecx, DWORD PTR fd$[rsp]
  001c1	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_read
  001c7	89 44 24 58	 mov	 DWORD PTR rc$[rsp], eax
  001cb	83 7c 24 58 00	 cmp	 DWORD PTR rc$[rsp], 0
  001d0	7d 70		 jge	 SHORT $LN8@s390_load_

; 265  :             {
; 266  :                 // "I/O error on read(): rc=%d: \"%s\""
; 267  :                 WRMSG( HHC00658, "E", rc, strerror( errno ));

  001d2	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno
  001d8	8b 08		 mov	 ecx, DWORD PTR [rax]
  001da	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_strerror
  001e0	48 89 44 24 78	 mov	 QWORD PTR tv147[rsp], rax
  001e5	b9 01 00 00 00	 mov	 ecx, 1
  001ea	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  001f0	48 8b 4c 24 78	 mov	 rcx, QWORD PTR tv147[rsp]
  001f5	48 89 4c 24 40	 mov	 QWORD PTR [rsp+64], rcx
  001fa	8b 4c 24 58	 mov	 ecx, DWORD PTR rc$[rsp]
  001fe	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  00202	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG179812
  00209	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  0020e	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG179813
  00215	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  0021a	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  0021f	41 b9 03 00 00
	00		 mov	 r9d, 3
  00225	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG179814
  0022c	ba 0b 01 00 00	 mov	 edx, 267		; 0000010bH
  00231	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG179815
  00238	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 268  :                 return false; // abort!

  0023e	32 c0		 xor	 al, al
  00240	eb 65		 jmp	 SHORT $LN1@s390_load_
$LN8@s390_load_:

; 269  :             }
; 270  : 
; 271  :             /* Page successfully loaded; Decrement pages remaining */
; 272  :             (*pages)--;

  00242	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR pages$[rsp]
  0024a	8b 00		 mov	 eax, DWORD PTR [rax]
  0024c	ff c8		 dec	 eax
  0024e	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR pages$[rsp]
  00256	89 01		 mov	 DWORD PTR [rcx], eax

; 273  : 
; 274  :             /* Update page's referenced and changed Storage Key bits */
; 275  :             ARCH_DEP( or_storage_key )( pgo, (STORKEY_REF | STORKEY_CHANGE) );

  00258	8b 44 24 50	 mov	 eax, DWORD PTR pgo$[rsp]
  0025c	b2 06		 mov	 dl, 6
  0025e	8b c8		 mov	 ecx, eax
  00260	e8 00 00 00 00	 call	 s390_or_storage_key
$LN6@s390_load_:

; 276  :         }
; 277  :     }

  00265	e9 c7 fd ff ff	 jmp	 $LN2@s390_load_
$LN3@s390_load_:

; 278  : 
; 279  :     /* Keep going if there are still pages remaining to be loaded */
; 280  :     return (*pages > 0) ? true : false;

  0026a	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR pages$[rsp]
  00272	83 38 00	 cmp	 DWORD PTR [rax], 0
  00275	76 0a		 jbe	 SHORT $LN10@s390_load_
  00277	c7 44 24 5c 01
	00 00 00	 mov	 DWORD PTR tv166[rsp], 1
  0027f	eb 08		 jmp	 SHORT $LN11@s390_load_
$LN10@s390_load_:
  00281	c7 44 24 5c 00
	00 00 00	 mov	 DWORD PTR tv166[rsp], 0
$LN11@s390_load_:
  00289	83 7c 24 5c 00	 cmp	 DWORD PTR tv166[rsp], 0
  0028e	75 0a		 jne	 SHORT $LN12@s390_load_
  00290	c7 44 24 60 00
	00 00 00	 mov	 DWORD PTR tv168[rsp], 0
  00298	eb 08		 jmp	 SHORT $LN13@s390_load_
$LN12@s390_load_:
  0029a	c7 44 24 60 01
	00 00 00	 mov	 DWORD PTR tv168[rsp], 1
$LN13@s390_load_:
  002a2	0f b6 44 24 60	 movzx	 eax, BYTE PTR tv168[rsp]
$LN1@s390_load_:

; 281  : }

  002a7	48 81 c4 88 00
	00 00		 add	 rsp, 136		; 00000088H
  002ae	c3		 ret	 0
s390_load_pages ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\skey.h
;	COMDAT s390_or_storage_key
_TEXT	SEGMENT
abs$ = 48
bits$ = 56
s390_or_storage_key PROC				; COMDAT

; 290  : {

$LN3:
  00000	88 54 24 10	 mov	 BYTE PTR [rsp+16], dl
  00004	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00009	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 291  : #if defined( FEATURE_2K_STORAGE_KEYS )
; 292  :     ARCH_DEP( or_2K_storage_key )( abs, bits );
; 293  : #else
; 294  :     ARCH_DEP( or_4K_storage_key )( abs, bits );

  0000d	0f b6 54 24 38	 movzx	 edx, BYTE PTR bits$[rsp]
  00012	48 8b 4c 24 30	 mov	 rcx, QWORD PTR abs$[rsp]
  00017	e8 00 00 00 00	 call	 s390_or_4K_storage_key

; 295  : #endif
; 296  : }

  0001c	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00020	c3		 ret	 0
s390_or_storage_key ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\skey.h
;	COMDAT s390_or_4K_storage_key
_TEXT	SEGMENT
abs$ = 48
bits$ = 56
s390_or_4K_storage_key PROC				; COMDAT

; 242  :   inline void  ARCH_DEP( or_4K_storage_key )      (              U64 abs, BYTE bits ) {        ARCH_DEP( _or_storage_key      )(      abs, bits & ~STORKEY_BADFRM, 4 ); }

$LN3:
  00000	88 54 24 10	 mov	 BYTE PTR [rsp+16], dl
  00004	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00009	48 83 ec 28	 sub	 rsp, 40			; 00000028H
  0000d	0f b6 44 24 38	 movzx	 eax, BYTE PTR bits$[rsp]
  00012	83 e0 fe	 and	 eax, -2
  00015	41 b0 04	 mov	 r8b, 4
  00018	0f b6 d0	 movzx	 edx, al
  0001b	48 8b 4c 24 30	 mov	 rcx, QWORD PTR abs$[rsp]
  00020	e8 00 00 00 00	 call	 s390__or_storage_key
  00025	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00029	c3		 ret	 0
s390_or_4K_storage_key ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\skey.h
;	COMDAT s390__or_storage_key
_TEXT	SEGMENT
skey1_ptr$1 = 32
skey2_ptr$2 = 40
skey_ptr$3 = 48
abs$ = 80
bits$ = 88
K$ = 96
s390__or_storage_key PROC				; COMDAT

; 189  : {

$LN8:
  00000	44 88 44 24 18	 mov	 BYTE PTR [rsp+24], r8b
  00005	88 54 24 10	 mov	 BYTE PTR [rsp+16], dl
  00009	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000e	48 83 ec 48	 sub	 rsp, 72			; 00000048H
$LN4@s390__or_s:

; 190  :     UNREFERENCED( K ); // (for FEATURE_4K_STORAGE_KEYS case)

  00012	33 c0		 xor	 eax, eax
  00014	85 c0		 test	 eax, eax
  00016	75 fa		 jne	 SHORT $LN4@s390__or_s

; 191  :     if (IS_DOUBLE_KEYED_4K_BYTE_BLOCK( K ))

  00018	33 c0		 xor	 eax, eax
  0001a	85 c0		 test	 eax, eax
  0001c	74 50		 je	 SHORT $LN5@s390__or_s

; 192  :     {
; 193  :         BYTE* skey1_ptr = _get_storekey1_ptr( abs );

  0001e	48 8b 4c 24 50	 mov	 rcx, QWORD PTR abs$[rsp]
  00023	e8 00 00 00 00	 call	 _get_storekey1_ptr
  00028	48 89 44 24 20	 mov	 QWORD PTR skey1_ptr$1[rsp], rax

; 194  :         BYTE* skey2_ptr = _get_storekey2_ptr( abs );

  0002d	48 8b 4c 24 50	 mov	 rcx, QWORD PTR abs$[rsp]
  00032	e8 00 00 00 00	 call	 _get_storekey2_ptr
  00037	48 89 44 24 28	 mov	 QWORD PTR skey2_ptr$2[rsp], rax

; 195  :         OR_SKEY( skey1_ptr, bits );

  0003c	0f b6 44 24 58	 movzx	 eax, BYTE PTR bits$[rsp]
  00041	48 8b 4c 24 20	 mov	 rcx, QWORD PTR skey1_ptr$1[rsp]
  00046	0f b6 09	 movzx	 ecx, BYTE PTR [rcx]
  00049	0b c8		 or	 ecx, eax
  0004b	8b c1		 mov	 eax, ecx
  0004d	48 8b 4c 24 20	 mov	 rcx, QWORD PTR skey1_ptr$1[rsp]
  00052	88 01		 mov	 BYTE PTR [rcx], al

; 196  :         OR_SKEY( skey2_ptr, bits );

  00054	0f b6 44 24 58	 movzx	 eax, BYTE PTR bits$[rsp]
  00059	48 8b 4c 24 28	 mov	 rcx, QWORD PTR skey2_ptr$2[rsp]
  0005e	0f b6 09	 movzx	 ecx, BYTE PTR [rcx]
  00061	0b c8		 or	 ecx, eax
  00063	8b c1		 mov	 eax, ecx
  00065	48 8b 4c 24 28	 mov	 rcx, QWORD PTR skey2_ptr$2[rsp]
  0006a	88 01		 mov	 BYTE PTR [rcx], al

; 197  :     }

  0006c	eb 2c		 jmp	 SHORT $LN6@s390__or_s
$LN5@s390__or_s:

; 198  :     else
; 199  :     {
; 200  :         BYTE* skey_ptr  = _get_storekey_ptr( abs, K );

  0006e	0f b6 54 24 60	 movzx	 edx, BYTE PTR K$[rsp]
  00073	48 8b 4c 24 50	 mov	 rcx, QWORD PTR abs$[rsp]
  00078	e8 00 00 00 00	 call	 _get_storekey_ptr
  0007d	48 89 44 24 30	 mov	 QWORD PTR skey_ptr$3[rsp], rax

; 201  :         OR_SKEY( skey_ptr, bits );

  00082	0f b6 44 24 58	 movzx	 eax, BYTE PTR bits$[rsp]
  00087	48 8b 4c 24 30	 mov	 rcx, QWORD PTR skey_ptr$3[rsp]
  0008c	0f b6 09	 movzx	 ecx, BYTE PTR [rcx]
  0008f	0b c8		 or	 ecx, eax
  00091	8b c1		 mov	 eax, ecx
  00093	48 8b 4c 24 30	 mov	 rcx, QWORD PTR skey_ptr$3[rsp]
  00098	88 01		 mov	 BYTE PTR [rcx], al
$LN6@s390__or_s:

; 202  :     }
; 203  : }

  0009a	48 83 c4 48	 add	 rsp, 72			; 00000048H
  0009e	c3		 ret	 0
s390__or_storage_key ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\scescsi.c
_TEXT	SEGMENT
tv68 = 64
regs$ = 112
s390_sdias_store_status PROC

; 662  : {

$LN11:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	56		 push	 rsi
  00006	57		 push	 rdi
  00007	48 83 ec 58	 sub	 rsp, 88			; 00000058H
$LN4@s390_sdias:

; 663  :     UNREFERENCED(regs);

  0000b	33 c0		 xor	 eax, eax
  0000d	85 c0		 test	 eax, eax
  0000f	75 fa		 jne	 SHORT $LN4@s390_sdias

; 664  : 
; 665  :     sdias_size = sysblk.mainsize < SDIAS_STORE_STATUS_MAXSIZE

  00011	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00018	48 81 b8 90 00
	00 00 00 00 00
	02		 cmp	 QWORD PTR [rax+144], 33554432 ; 02000000H
  00023	73 15		 jae	 SHORT $LN9@s390_sdias
  00025	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  0002c	48 8b 80 90 00
	00 00		 mov	 rax, QWORD PTR [rax+144]
  00033	48 89 44 24 40	 mov	 QWORD PTR tv68[rsp], rax
  00038	eb 09		 jmp	 SHORT $LN10@s390_sdias
$LN9@s390_sdias:
  0003a	48 c7 44 24 40
	00 00 00 02	 mov	 QWORD PTR tv68[rsp], 33554432 ; 02000000H
$LN10@s390_sdias:
  00043	8b 44 24 40	 mov	 eax, DWORD PTR tv68[rsp]
  00047	89 05 00 00 00
	00		 mov	 DWORD PTR sdias_size, eax

; 666  :                ? sysblk.mainsize : SDIAS_STORE_STATUS_MAXSIZE;
; 667  : 
; 668  :     if(!sdias_hsa)

  0004d	48 83 3d 00 00
	00 00 00	 cmp	 QWORD PTR sdias_hsa, 0
  00055	75 12		 jne	 SHORT $LN5@s390_sdias

; 669  :         sdias_hsa = malloc(SDIAS_STORE_STATUS_MAXSIZE);

  00057	b9 00 00 00 02	 mov	 ecx, 33554432		; 02000000H
  0005c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_malloc
  00062	48 89 05 00 00
	00 00		 mov	 QWORD PTR sdias_hsa, rax
$LN5@s390_sdias:

; 670  : 
; 671  :     if(sdias_hsa)

  00069	48 83 3d 00 00
	00 00 00	 cmp	 QWORD PTR sdias_hsa, 0
  00071	74 21		 je	 SHORT $LN6@s390_sdias

; 672  :         memcpy(sdias_hsa,sysblk.mainstor,sdias_size);

  00073	8b 05 00 00 00
	00		 mov	 eax, DWORD PTR sdias_size
  00079	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  00080	48 8b 3d 00 00
	00 00		 mov	 rdi, QWORD PTR sdias_hsa
  00087	48 8b b1 98 00
	00 00		 mov	 rsi, QWORD PTR [rcx+152]
  0008e	8b c8		 mov	 ecx, eax
  00090	f3 a4		 rep movsb
  00092	eb 47		 jmp	 SHORT $LN7@s390_sdias
$LN6@s390_sdias:

; 673  :     else
; 674  :         // "Store Status save to HSA failed"
; 675  :         WRMSG( HHC00655, "E" );

  00094	b9 01 00 00 00	 mov	 ecx, 1
  00099	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  0009f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG179981
  000a6	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  000ab	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG179982
  000b2	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  000b7	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  000bc	41 b9 03 00 00
	00		 mov	 r9d, 3
  000c2	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG179983
  000c9	ba a3 02 00 00	 mov	 edx, 675		; 000002a3H
  000ce	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG179984
  000d5	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg
$LN7@s390_sdias:

; 676  : }

  000db	48 83 c4 58	 add	 rsp, 88			; 00000058H
  000df	5f		 pop	 rdi
  000e0	5e		 pop	 rsi
  000e1	c3		 ret	 0
s390_sdias_store_status ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\scescsi.c
_TEXT	SEGMENT
regs$ = 48
s390_sdias_store_status_clear PROC

; 648  : {

$LN7:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 28	 sub	 rsp, 40			; 00000028H
$LN4@s390_sdias:

; 649  :     UNREFERENCED(regs);

  00009	33 c0		 xor	 eax, eax
  0000b	85 c0		 test	 eax, eax
  0000d	75 fa		 jne	 SHORT $LN4@s390_sdias

; 650  : 
; 651  :     sdias_size = 0;

  0000f	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR sdias_size, 0

; 652  :     if(sdias_hsa)

  00019	48 83 3d 00 00
	00 00 00	 cmp	 QWORD PTR sdias_hsa, 0
  00021	74 0d		 je	 SHORT $LN5@s390_sdias

; 653  :         free(sdias_hsa);

  00023	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR sdias_hsa
  0002a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free
$LN5@s390_sdias:

; 654  :     sdias_hsa = NULL;

  00030	48 c7 05 00 00
	00 00 00 00 00
	00		 mov	 QWORD PTR sdias_hsa, 0

; 655  : }

  0003b	48 83 c4 28	 add	 rsp, 40			; 00000028H
  0003f	c3		 ret	 0
s390_sdias_store_status_clear ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\scescsi.c
_TEXT	SEGMENT
sccb$ = 8
s390_sclp_sdias_event PROC

; 599  : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx

; 600  : #if 0
; 601  : SCCB_EVD_HDR *evd_hdr = (SCCB_EVD_HDR*)(sccb + 1);
; 602  : U16 sccb_len;
; 603  : U16 evd_len;
; 604  : 
; 605  :     if( ARCH_DEP(sdias_request)(SCLP_READ_EVENT_DATA, evd_hdr) )
; 606  :     {
; 607  :        /* Zero all fields */
; 608  :         memset (evd_hdr, 0, sizeof(SCCB_EVD_HDR));
; 609  : 
; 610  :         /* Set length in event header */
; 611  :         evd_len = sizeof(SCCB_EVD_HDR) + sizeof(SCCB_HWL_BK);
; 612  :         STORE_HW(evd_hdr->totlen, evd_len);
; 613  : 
; 614  :         /* Set type in event header */
; 615  :         evd_hdr->type = SCCB_EVD_TYPE_HWL;
; 616  : 
; 617  :         /* Update SCCB length field if variable request */
; 618  :         if (sccb->type & SCCB_TYPE_VARIABLE)
; 619  :         {
; 620  :             FETCH_HW(evd_len, evd_hdr->totlen);
; 621  :             sccb_len = evd_len + sizeof(SCCB_HEADER);
; 622  :             STORE_HW(sccb->length, sccb_len);
; 623  :             sccb->type &= ~SCCB_TYPE_VARIABLE;
; 624  :         }
; 625  : 
; 626  :         /* Set response code X'0020' in SCCB header */
; 627  :         sccb->reas = SCCB_REAS_NONE;
; 628  :         sccb->resp = SCCB_RESP_COMPLETE;
; 629  :     }
; 630  : #else
; 631  :     sccb->reas = SCCB_REAS_NONE;

  00005	48 8b 44 24 08	 mov	 rax, QWORD PTR sccb$[rsp]
  0000a	c6 40 06 00	 mov	 BYTE PTR [rax+6], 0

; 632  :     sccb->resp = SCCB_RESP_BACKOUT;

  0000e	48 8b 44 24 08	 mov	 rax, QWORD PTR sccb$[rsp]
  00013	c6 40 07 40	 mov	 BYTE PTR [rax+7], 64	; 00000040H

; 633  : #endif
; 634  : }

  00017	c3		 ret	 0
s390_sclp_sdias_event ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\scescsi.c
_TEXT	SEGMENT
evd_hdr$ = 0
sccb$ = 32
s390_sclp_sdias_request PROC

; 570  : {

$LN3:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 18	 sub	 rsp, 24

; 571  : SCCB_EVD_HDR    *evd_hdr = (SCCB_EVD_HDR*)(sccb + 1);

  00009	48 8b 44 24 20	 mov	 rax, QWORD PTR sccb$[rsp]
  0000e	48 83 c0 08	 add	 rax, 8
  00012	48 89 04 24	 mov	 QWORD PTR evd_hdr$[rsp], rax

; 572  : 
; 573  : #if 0
; 574  :     if( ARCH_DEP(sdias_request)(SCLP_WRITE_EVENT_DATA, evd_hdr) )
; 575  :     {
; 576  :         /* Set response code X'0040' in SCCB header */
; 577  :         sccb->reas = SCCB_REAS_NONE;
; 578  :         sccb->resp = SCCB_RESP_BACKOUT;
; 579  :     }
; 580  :     else
; 581  :     {
; 582  :         /* Set response code X'0020' in SCCB header */
; 583  :         sccb->reas = SCCB_REAS_NONE;
; 584  :         sccb->resp = SCCB_RESP_COMPLETE;
; 585  :     }
; 586  : #else
; 587  :     sccb->reas = SCCB_REAS_NONE;

  00016	48 8b 44 24 20	 mov	 rax, QWORD PTR sccb$[rsp]
  0001b	c6 40 06 00	 mov	 BYTE PTR [rax+6], 0

; 588  :     sccb->resp = SCCB_RESP_BACKOUT;

  0001f	48 8b 44 24 20	 mov	 rax, QWORD PTR sccb$[rsp]
  00024	c6 40 07 40	 mov	 BYTE PTR [rax+7], 64	; 00000040H

; 589  : #endif
; 590  :     /* Indicate Event Processed */
; 591  :     evd_hdr->flag |= SCCB_EVD_FLAG_PROC;

  00028	48 8b 04 24	 mov	 rax, QWORD PTR evd_hdr$[rsp]
  0002c	0f b6 40 03	 movzx	 eax, BYTE PTR [rax+3]
  00030	0f ba e8 07	 bts	 eax, 7
  00034	48 8b 0c 24	 mov	 rcx, QWORD PTR evd_hdr$[rsp]
  00038	88 41 03	 mov	 BYTE PTR [rcx+3], al

; 592  : }

  0003b	48 83 c4 18	 add	 rsp, 24
  0003f	c3		 ret	 0
s390_sclp_sdias_request ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\scescsi.c
_TEXT	SEGMENT
evd_len$ = 32
sccb_len$ = 36
evd_hdr$ = 40
sccb$ = 64
s390_sclp_hwl_event PROC

; 533  : {

$LN5:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	57		 push	 rdi
  00006	48 83 ec 30	 sub	 rsp, 48			; 00000030H

; 534  : SCCB_EVD_HDR *evd_hdr = (SCCB_EVD_HDR*)(sccb + 1);

  0000a	48 8b 44 24 40	 mov	 rax, QWORD PTR sccb$[rsp]
  0000f	48 83 c0 08	 add	 rax, 8
  00013	48 89 44 24 28	 mov	 QWORD PTR evd_hdr$[rsp], rax

; 535  : U16 sccb_len;
; 536  : U16 evd_len;
; 537  : 
; 538  :     if( ARCH_DEP(hwl_request)(SCLP_READ_EVENT_DATA, evd_hdr) )

  00018	48 8b 54 24 28	 mov	 rdx, QWORD PTR evd_hdr$[rsp]
  0001d	b9 05 00 77 00	 mov	 ecx, 7798789		; 00770005H
  00022	e8 00 00 00 00	 call	 s390_hwl_request
  00027	85 c0		 test	 eax, eax
  00029	0f 84 b0 00 00
	00		 je	 $LN2@s390_sclp_

; 539  :     {
; 540  :        /* Zero all fields */
; 541  :         memset (evd_hdr, 0, sizeof(SCCB_EVD_HDR));

  0002f	48 8b 7c 24 28	 mov	 rdi, QWORD PTR evd_hdr$[rsp]
  00034	33 c0		 xor	 eax, eax
  00036	b9 06 00 00 00	 mov	 ecx, 6
  0003b	f3 aa		 rep stosb

; 542  : 
; 543  :         /* Set length in event header */
; 544  :         evd_len = sizeof(SCCB_EVD_HDR) + sizeof(SCCB_HWL_BK);

  0003d	b8 30 00 00 00	 mov	 eax, 48			; 00000030H
  00042	66 89 44 24 20	 mov	 WORD PTR evd_len$[rsp], ax

; 545  :         STORE_HW(evd_hdr->totlen, evd_len);

  00047	0f b7 4c 24 20	 movzx	 ecx, WORD PTR evd_len$[rsp]
  0004c	e8 00 00 00 00	 call	 _byteswap_ushort
  00051	48 8b 4c 24 28	 mov	 rcx, QWORD PTR evd_hdr$[rsp]
  00056	0f b7 d0	 movzx	 edx, ax
  00059	e8 00 00 00 00	 call	 store_hw_noswap

; 546  : 
; 547  :         /* Set type in event header */
; 548  :         evd_hdr->type = SCCB_EVD_TYPE_HWL;

  0005e	48 8b 44 24 28	 mov	 rax, QWORD PTR evd_hdr$[rsp]
  00063	c6 40 02 0c	 mov	 BYTE PTR [rax+2], 12

; 549  : 
; 550  :         /* Update SCCB length field if variable request */
; 551  :         if (sccb->type & SCCB_TYPE_VARIABLE)

  00067	48 8b 44 24 40	 mov	 rax, QWORD PTR sccb$[rsp]
  0006c	0f b6 40 05	 movzx	 eax, BYTE PTR [rax+5]
  00070	25 80 00 00 00	 and	 eax, 128		; 00000080H
  00075	85 c0		 test	 eax, eax
  00077	74 54		 je	 SHORT $LN3@s390_sclp_

; 552  :         {
; 553  :             FETCH_HW(evd_len, evd_hdr->totlen);

  00079	48 8b 44 24 28	 mov	 rax, QWORD PTR evd_hdr$[rsp]
  0007e	48 8b c8	 mov	 rcx, rax
  00081	e8 00 00 00 00	 call	 fetch_hw_noswap
  00086	0f b7 c8	 movzx	 ecx, ax
  00089	e8 00 00 00 00	 call	 _byteswap_ushort
  0008e	66 89 44 24 20	 mov	 WORD PTR evd_len$[rsp], ax

; 554  :             sccb_len = evd_len + sizeof(SCCB_HEADER);

  00093	0f b7 44 24 20	 movzx	 eax, WORD PTR evd_len$[rsp]
  00098	48 83 c0 08	 add	 rax, 8
  0009c	66 89 44 24 24	 mov	 WORD PTR sccb_len$[rsp], ax

; 555  :             STORE_HW(sccb->length, sccb_len);

  000a1	0f b7 4c 24 24	 movzx	 ecx, WORD PTR sccb_len$[rsp]
  000a6	e8 00 00 00 00	 call	 _byteswap_ushort
  000ab	48 8b 4c 24 40	 mov	 rcx, QWORD PTR sccb$[rsp]
  000b0	0f b7 d0	 movzx	 edx, ax
  000b3	e8 00 00 00 00	 call	 store_hw_noswap

; 556  :             sccb->type &= ~SCCB_TYPE_VARIABLE;

  000b8	48 8b 44 24 40	 mov	 rax, QWORD PTR sccb$[rsp]
  000bd	0f b6 40 05	 movzx	 eax, BYTE PTR [rax+5]
  000c1	0f ba f0 07	 btr	 eax, 7
  000c5	48 8b 4c 24 40	 mov	 rcx, QWORD PTR sccb$[rsp]
  000ca	88 41 05	 mov	 BYTE PTR [rcx+5], al
$LN3@s390_sclp_:

; 557  :         }
; 558  : 
; 559  :         /* Set response code X'0020' in SCCB header */
; 560  :         sccb->reas = SCCB_REAS_NONE;

  000cd	48 8b 44 24 40	 mov	 rax, QWORD PTR sccb$[rsp]
  000d2	c6 40 06 00	 mov	 BYTE PTR [rax+6], 0

; 561  :         sccb->resp = SCCB_RESP_COMPLETE;

  000d6	48 8b 44 24 40	 mov	 rax, QWORD PTR sccb$[rsp]
  000db	c6 40 07 20	 mov	 BYTE PTR [rax+7], 32	; 00000020H
$LN2@s390_sclp_:

; 562  :     }
; 563  : }

  000df	48 83 c4 30	 add	 rsp, 48			; 00000030H
  000e3	5f		 pop	 rdi
  000e4	c3		 ret	 0
s390_sclp_hwl_event ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\scescsi.c
_TEXT	SEGMENT
evd_hdr$ = 80
hwl_bk$ = 88
tv75 = 96
tv76 = 104
tv67 = 112
sccb$ = 144
s390_sclp_hwl_request PROC

; 501  : {

$LN9:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 81 ec 88 00
	00 00		 sub	 rsp, 136		; 00000088H

; 502  : SCCB_EVD_HDR    *evd_hdr = (SCCB_EVD_HDR*)(sccb + 1);

  0000c	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR sccb$[rsp]
  00014	48 83 c0 08	 add	 rax, 8
  00018	48 89 44 24 50	 mov	 QWORD PTR evd_hdr$[rsp], rax

; 503  : SCCB_HWL_BK     *hwl_bk  = (SCCB_HWL_BK*)(evd_hdr + 1);

  0001d	48 8b 44 24 50	 mov	 rax, QWORD PTR evd_hdr$[rsp]
  00022	48 83 c0 06	 add	 rax, 6
  00026	48 89 44 24 58	 mov	 QWORD PTR hwl_bk$[rsp], rax

; 504  : 
; 505  :     // "Hardware loader: %s request: SCCB = 0x%"PRIX64
; 506  :     WRMSG( HHC00661, "I",

  0002b	48 8b 44 24 58	 mov	 rax, QWORD PTR hwl_bk$[rsp]
  00030	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  00033	83 f8 02	 cmp	 eax, 2
  00036	75 0e		 jne	 SHORT $LN7@s390_sclp_
  00038	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG179933
  0003f	48 89 44 24 68	 mov	 QWORD PTR tv76[rsp], rax
  00044	eb 30		 jmp	 SHORT $LN8@s390_sclp_
$LN7@s390_sclp_:
  00046	48 8b 44 24 58	 mov	 rax, QWORD PTR hwl_bk$[rsp]
  0004b	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  0004e	85 c0		 test	 eax, eax
  00050	75 0e		 jne	 SHORT $LN5@s390_sclp_
  00052	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG179934
  00059	48 89 44 24 60	 mov	 QWORD PTR tv75[rsp], rax
  0005e	eb 0c		 jmp	 SHORT $LN6@s390_sclp_
$LN5@s390_sclp_:
  00060	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG179935
  00067	48 89 44 24 60	 mov	 QWORD PTR tv75[rsp], rax
$LN6@s390_sclp_:
  0006c	48 8b 44 24 60	 mov	 rax, QWORD PTR tv75[rsp]
  00071	48 89 44 24 68	 mov	 QWORD PTR tv76[rsp], rax
$LN8@s390_sclp_:
  00076	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  0007d	48 8b 80 98 00
	00 00		 mov	 rax, QWORD PTR [rax+152]
  00084	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR sccb$[rsp]
  0008c	48 2b c8	 sub	 rcx, rax
  0008f	48 8b c1	 mov	 rax, rcx
  00092	48 89 44 24 70	 mov	 QWORD PTR tv67[rsp], rax
  00097	b9 01 00 00 00	 mov	 ecx, 1
  0009c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  000a2	48 8b 4c 24 70	 mov	 rcx, QWORD PTR tv67[rsp]
  000a7	48 89 4c 24 40	 mov	 QWORD PTR [rsp+64], rcx
  000ac	48 8b 4c 24 68	 mov	 rcx, QWORD PTR tv76[rsp]
  000b1	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  000b6	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG179936
  000bd	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  000c2	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG179937
  000c9	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  000ce	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  000d3	41 b9 03 00 00
	00		 mov	 r9d, 3
  000d9	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG179938
  000e0	ba fd 01 00 00	 mov	 edx, 509		; 000001fdH
  000e5	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG179939
  000ec	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 507  :         SCCB_HWL_TYPE_INFO == hwl_bk->type ? "INFO" :
; 508  :         SCCB_HWL_TYPE_LOAD == hwl_bk->type ? "LOAD" : "unknown",
; 509  :         (BYTE*)sccb - (BYTE*)sysblk.mainstor );
; 510  : 
; 511  :     if( ARCH_DEP(hwl_request)(SCLP_WRITE_EVENT_DATA, evd_hdr) )

  000f2	48 8b 54 24 50	 mov	 rdx, QWORD PTR evd_hdr$[rsp]
  000f7	b9 05 00 76 00	 mov	 ecx, 7733253		; 00760005H
  000fc	e8 00 00 00 00	 call	 s390_hwl_request
  00101	85 c0		 test	 eax, eax
  00103	74 1a		 je	 SHORT $LN2@s390_sclp_

; 512  :     {
; 513  :         /* Set response code X'0040' in SCCB header */
; 514  :         sccb->reas = SCCB_REAS_NONE;

  00105	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR sccb$[rsp]
  0010d	c6 40 06 00	 mov	 BYTE PTR [rax+6], 0

; 515  :         sccb->resp = SCCB_RESP_BACKOUT;

  00111	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR sccb$[rsp]
  00119	c6 40 07 40	 mov	 BYTE PTR [rax+7], 64	; 00000040H

; 516  :     }

  0011d	eb 18		 jmp	 SHORT $LN3@s390_sclp_
$LN2@s390_sclp_:

; 517  :     else
; 518  :     {
; 519  :         /* Set response code X'0020' in SCCB header */
; 520  :         sccb->reas = SCCB_REAS_NONE;

  0011f	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR sccb$[rsp]
  00127	c6 40 06 00	 mov	 BYTE PTR [rax+6], 0

; 521  :         sccb->resp = SCCB_RESP_COMPLETE;

  0012b	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR sccb$[rsp]
  00133	c6 40 07 20	 mov	 BYTE PTR [rax+7], 32	; 00000020H
$LN3@s390_sclp_:

; 522  :     }
; 523  : 
; 524  :     /* Indicate Event Processed */
; 525  :     evd_hdr->flag |= SCCB_EVD_FLAG_PROC;

  00137	48 8b 44 24 50	 mov	 rax, QWORD PTR evd_hdr$[rsp]
  0013c	0f b6 40 03	 movzx	 eax, BYTE PTR [rax+3]
  00140	0f ba e8 07	 bts	 eax, 7
  00144	48 8b 4c 24 50	 mov	 rcx, QWORD PTR evd_hdr$[rsp]
  00149	88 41 03	 mov	 BYTE PTR [rcx+3], al

; 526  : }

  0014c	48 81 c4 88 00
	00 00		 add	 rsp, 136		; 00000088H
  00153	c3		 ret	 0
s390_sclp_hwl_request ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\scescsi.c
_TEXT	SEGMENT
bootfile$ = 80
tv87 = 88
tv150 = 96
tv91 = 104
regs$ = 112
dev$ = 144
cpu$ = 152
clear$ = 160
ldind$ = 168
s370_load_boot PROC

; 759  : {

$LN8:
  00000	44 89 4c 24 20	 mov	 DWORD PTR [rsp+32], r9d
  00005	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  0000a	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  0000e	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00013	48 81 ec 88 00
	00 00		 sub	 rsp, 136		; 00000088H

; 760  : REGS *regs = sysblk.regs[cpu];

  0001a	48 63 84 24 98
	00 00 00	 movsxd	 rax, DWORD PTR cpu$[rsp]
  00022	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  00029	48 8b 84 c1 98
	0b 00 00	 mov	 rax, QWORD PTR [rcx+rax*8+2968]
  00031	48 89 44 24 70	 mov	 QWORD PTR regs$[rsp], rax

; 761  : int bootfile;
; 762  : 
; 763  :     bootfile = support_boot(dev);

  00036	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  0003e	e8 00 00 00 00	 call	 support_boot
  00043	89 44 24 50	 mov	 DWORD PTR bootfile$[rsp], eax

; 764  : 
; 765  :     if(bootfile < 0 || !hwl_fn[bootfile])

  00047	83 7c 24 50 00	 cmp	 DWORD PTR bootfile$[rsp], 0
  0004c	7c 13		 jl	 SHORT $LN3@s370_load_
  0004e	48 63 44 24 50	 movsxd	 rax, DWORD PTR bootfile$[rsp]
  00053	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:hwl_fn
  0005a	48 83 3c c1 00	 cmp	 QWORD PTR [rcx+rax*8], 0
  0005f	75 0a		 jne	 SHORT $LN2@s370_load_
$LN3@s370_load_:

; 766  :         return -1; // Should not occur, has been validated.

  00061	b8 ff ff ff ff	 mov	 eax, -1
  00066	e9 3c 01 00 00	 jmp	 $LN1@s370_load_
$LN2@s370_load_:

; 767  : 
; 768  :     if (ARCH_DEP(common_load_begin) (cpu, clear) != 0)

  0006b	8b 94 24 a0 00
	00 00		 mov	 edx, DWORD PTR clear$[rsp]
  00072	8b 8c 24 98 00
	00 00		 mov	 ecx, DWORD PTR cpu$[rsp]
  00079	e8 00 00 00 00	 call	 s370_common_load_begin
  0007e	85 c0		 test	 eax, eax
  00080	74 0a		 je	 SHORT $LN4@s370_load_

; 769  :         return -1;

  00082	b8 ff ff ff ff	 mov	 eax, -1
  00087	e9 1b 01 00 00	 jmp	 $LN1@s370_load_
$LN4@s370_load_:

; 770  : 
; 771  :     if( ARCH_DEP(load_main) (hwl_fn[bootfile], 0, 0) < 0)

  0008c	48 63 44 24 50	 movsxd	 rax, DWORD PTR bootfile$[rsp]
  00091	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:hwl_fn
  00098	45 33 c0	 xor	 r8d, r8d
  0009b	33 d2		 xor	 edx, edx
  0009d	48 8b 0c c1	 mov	 rcx, QWORD PTR [rcx+rax*8]
  000a1	e8 00 00 00 00	 call	 s370_load_main
  000a6	85 c0		 test	 eax, eax
  000a8	0f 8d 94 00 00
	00		 jge	 $LN5@s370_load_

; 772  :     {
; 773  :         // "Cannot load bootstrap loader %s: %s"
; 774  :         WRMSG( HHC00656, "E", hwl_fn[ bootfile ], strerror( errno ));

  000ae	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno
  000b4	8b 08		 mov	 ecx, DWORD PTR [rax]
  000b6	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_strerror
  000bc	48 89 44 24 58	 mov	 QWORD PTR tv87[rsp], rax
  000c1	48 63 4c 24 50	 movsxd	 rcx, DWORD PTR bootfile$[rsp]
  000c6	48 89 4c 24 68	 mov	 QWORD PTR tv91[rsp], rcx
  000cb	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:hwl_fn
  000d2	48 89 54 24 60	 mov	 QWORD PTR tv150[rsp], rdx
  000d7	b9 01 00 00 00	 mov	 ecx, 1
  000dc	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  000e2	48 8b 4c 24 58	 mov	 rcx, QWORD PTR tv87[rsp]
  000e7	48 89 4c 24 40	 mov	 QWORD PTR [rsp+64], rcx
  000ec	48 8b 4c 24 60	 mov	 rcx, QWORD PTR tv150[rsp]
  000f1	48 8b 54 24 68	 mov	 rdx, QWORD PTR tv91[rsp]
  000f6	48 8b 0c d1	 mov	 rcx, QWORD PTR [rcx+rdx*8]
  000fa	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  000ff	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169757
  00106	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  0010b	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169758
  00112	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00117	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  0011c	41 b9 03 00 00
	00		 mov	 r9d, 3
  00122	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG169759
  00129	ba 06 03 00 00	 mov	 edx, 774		; 00000306H
  0012e	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169760
  00135	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 775  :         return -1;

  0013b	b8 ff ff ff ff	 mov	 eax, -1
  00140	eb 65		 jmp	 SHORT $LN1@s370_load_
$LN5@s370_load_:

; 776  :     }
; 777  :     sysblk.main_clear = sysblk.xpnd_clear = 0;

  00142	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00149	8b 80 94 12 00
	00		 mov	 eax, DWORD PTR [rax+4756]
  0014f	0f ba f0 0f	 btr	 eax, 15
  00153	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  0015a	89 81 94 12 00
	00		 mov	 DWORD PTR [rcx+4756], eax
  00160	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00167	8b 80 94 12 00
	00		 mov	 eax, DWORD PTR [rax+4756]
  0016d	0f ba f0 0e	 btr	 eax, 14
  00171	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  00178	89 81 94 12 00
	00		 mov	 DWORD PTR [rcx+4756], eax

; 778  : 
; 779  :     if( ARCH_DEP(store_boot_parms)(dev, ldind) )

  0017e	8b 94 24 a8 00
	00 00		 mov	 edx, DWORD PTR ldind$[rsp]
  00185	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  0018d	e8 00 00 00 00	 call	 s370_store_boot_parms
  00192	85 c0		 test	 eax, eax
  00194	74 07		 je	 SHORT $LN6@s370_load_

; 780  :         return -1;

  00196	b8 ff ff ff ff	 mov	 eax, -1
  0019b	eb 0a		 jmp	 SHORT $LN1@s370_load_
$LN6@s370_load_:

; 781  : 
; 782  :     return ARCH_DEP(common_load_finish)(regs);

  0019d	48 8b 4c 24 70	 mov	 rcx, QWORD PTR regs$[rsp]
  001a2	e8 00 00 00 00	 call	 s370_common_load_finish
$LN1@s370_load_:

; 783  : }

  001a7	48 81 c4 88 00
	00 00		 add	 rsp, 136		; 00000088H
  001ae	c3		 ret	 0
s370_load_boot ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\scescsi.c
_TEXT	SEGMENT
scp_len$ = 32
tv80 = 36
xml$ = 40
sb_bk$ = 48
tv212 = 56
psa$ = 64
dev$ = 112
ldind$ = 120
s370_store_boot_parms PROC

; 685  : {

$LN12:
  00000	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00004	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00009	56		 push	 rsi
  0000a	57		 push	 rdi
  0000b	48 83 ec 58	 sub	 rsp, 88			; 00000058H

; 686  : PSA *psa;
; 687  : SCSI_BOOT_BK *sb_bk;
; 688  : BYTE *xml;
; 689  : int scp_len;
; 690  : 
; 691  :     if(sysblk.mainsize < (BOOT_PARM_ADDR + 0x1000))

  0000f	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00016	48 81 b8 90 00
	00 00 00 e0 ff
	01		 cmp	 QWORD PTR [rax+144], 33546240 ; 01ffe000H
  00021	73 0a		 jae	 SHORT $LN2@s370_store

; 692  :         return -1;

  00023	b8 ff ff ff ff	 mov	 eax, -1
  00028	e9 3a 05 00 00	 jmp	 $LN1@s370_store
$LN2@s370_store:

; 693  : 
; 694  :     psa = (PSA*)sysblk.mainstor;

  0002d	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00034	48 8b 80 98 00
	00 00		 mov	 rax, QWORD PTR [rax+152]
  0003b	48 89 44 24 40	 mov	 QWORD PTR psa$[rsp], rax

; 695  : 
; 696  :     STORE_DW(psa->iplccw2,BOOT_PARM_ADDR);

  00040	b9 00 d0 ff 01	 mov	 ecx, 33542144		; 01ffd000H
  00045	e8 00 00 00 00	 call	 _byteswap_uint64
  0004a	48 8b 4c 24 40	 mov	 rcx, QWORD PTR psa$[rsp]
  0004f	48 83 c1 10	 add	 rcx, 16
  00053	48 8b d0	 mov	 rdx, rax
  00056	e8 00 00 00 00	 call	 store_dw_noswap

; 697  : 
; 698  :     sb_bk = (SCSI_BOOT_BK*)(sysblk.mainstor + BOOT_PARM_ADDR);

  0005b	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00062	48 8b 80 98 00
	00 00		 mov	 rax, QWORD PTR [rax+152]
  00069	48 05 00 d0 ff
	01		 add	 rax, 33542144		; 01ffd000H
  0006f	48 89 44 24 30	 mov	 QWORD PTR sb_bk$[rsp], rax

; 699  :     memset(sb_bk,0x00,0x1000);

  00074	48 8b 7c 24 30	 mov	 rdi, QWORD PTR sb_bk$[rsp]
  00079	33 c0		 xor	 eax, eax
  0007b	b9 00 10 00 00	 mov	 ecx, 4096		; 00001000H
  00080	f3 aa		 rep stosb

; 700  : 
; 701  :     sb_bk->ldind = ldind ? SCSI_BOOT_LDIND_DUMP : SCSI_BOOT_LDIND_LOAD;

  00082	83 7c 24 78 00	 cmp	 DWORD PTR ldind$[rsp], 0
  00087	74 0a		 je	 SHORT $LN8@s370_store
  00089	c7 44 24 24 20
	00 00 00	 mov	 DWORD PTR tv80[rsp], 32	; 00000020H
  00091	eb 08		 jmp	 SHORT $LN9@s370_store
$LN8@s370_store:
  00093	c7 44 24 24 10
	00 00 00	 mov	 DWORD PTR tv80[rsp], 16
$LN9@s370_store:
  0009b	48 8b 44 24 30	 mov	 rax, QWORD PTR sb_bk$[rsp]
  000a0	0f b6 4c 24 24	 movzx	 ecx, BYTE PTR tv80[rsp]
  000a5	88 88 48 01 00
	00		 mov	 BYTE PTR [rax+328], cl

; 702  : 
; 703  :     STORE_HW(sb_bk->devno,dev->devnum);

  000ab	48 8b 44 24 70	 mov	 rax, QWORD PTR dev$[rsp]
  000b0	0f b7 48 48	 movzx	 ecx, WORD PTR [rax+72]
  000b4	e8 00 00 00 00	 call	 _byteswap_ushort
  000b9	48 8b 4c 24 30	 mov	 rcx, QWORD PTR sb_bk$[rsp]
  000be	48 81 c1 4e 01
	00 00		 add	 rcx, 334		; 0000014eH
  000c5	0f b7 d0	 movzx	 edx, ax
  000c8	e8 00 00 00 00	 call	 store_hw_noswap

; 704  :     STORE_DW(sb_bk->wwpn,scsi_lddev_wwpn[ldind]);

  000cd	48 63 44 24 78	 movsxd	 rax, DWORD PTR ldind$[rsp]
  000d2	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:scsi_lddev_wwpn
  000d9	48 8b 0c c1	 mov	 rcx, QWORD PTR [rcx+rax*8]
  000dd	e8 00 00 00 00	 call	 _byteswap_uint64
  000e2	48 8b 4c 24 30	 mov	 rcx, QWORD PTR sb_bk$[rsp]
  000e7	48 81 c1 54 01
	00 00		 add	 rcx, 340		; 00000154H
  000ee	48 8b d0	 mov	 rdx, rax
  000f1	e8 00 00 00 00	 call	 store_dw_noswap

; 705  :     STORE_DW(sb_bk->lun,scsi_lddev_lun[ldind]);

  000f6	48 63 44 24 78	 movsxd	 rax, DWORD PTR ldind$[rsp]
  000fb	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:scsi_lddev_lun
  00102	48 8b 0c c1	 mov	 rcx, QWORD PTR [rcx+rax*8]
  00106	e8 00 00 00 00	 call	 _byteswap_uint64
  0010b	48 8b 4c 24 30	 mov	 rcx, QWORD PTR sb_bk$[rsp]
  00110	48 81 c1 5c 01
	00 00		 add	 rcx, 348		; 0000015cH
  00117	48 8b d0	 mov	 rdx, rax
  0011a	e8 00 00 00 00	 call	 store_dw_noswap

; 706  :     STORE_FW(sb_bk->prog,scsi_lddev_prog[ldind]);

  0011f	48 63 44 24 78	 movsxd	 rax, DWORD PTR ldind$[rsp]
  00124	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:scsi_lddev_prog
  0012b	8b 0c 81	 mov	 ecx, DWORD PTR [rcx+rax*4]
  0012e	e8 00 00 00 00	 call	 _byteswap_ulong
  00133	48 8b 4c 24 30	 mov	 rcx, QWORD PTR sb_bk$[rsp]
  00138	48 81 c1 64 01
	00 00		 add	 rcx, 356		; 00000164H
  0013f	8b d0		 mov	 edx, eax
  00141	e8 00 00 00 00	 call	 store_fw_noswap

; 707  :     STORE_DW(sb_bk->brlba,scsi_lddev_brlba[ldind]);

  00146	48 63 44 24 78	 movsxd	 rax, DWORD PTR ldind$[rsp]
  0014b	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:scsi_lddev_brlba
  00152	48 8b 0c c1	 mov	 rcx, QWORD PTR [rcx+rax*8]
  00156	e8 00 00 00 00	 call	 _byteswap_uint64
  0015b	48 8b 4c 24 30	 mov	 rcx, QWORD PTR sb_bk$[rsp]
  00160	48 81 c1 74 01
	00 00		 add	 rcx, 372		; 00000174H
  00167	48 8b d0	 mov	 rdx, rax
  0016a	e8 00 00 00 00	 call	 store_dw_noswap

; 708  : 
; 709  :     if(scsi_lddev_scpdata[ldind])

  0016f	48 63 44 24 78	 movsxd	 rax, DWORD PTR ldind$[rsp]
  00174	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:scsi_lddev_scpdata
  0017b	48 83 3c c1 00	 cmp	 QWORD PTR [rcx+rax*8], 0
  00180	74 6f		 je	 SHORT $LN3@s370_store

; 710  :     {
; 711  :         scp_len = strlen((char*)scsi_lddev_scpdata[ldind]);

  00182	48 63 44 24 78	 movsxd	 rax, DWORD PTR ldind$[rsp]
  00187	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:scsi_lddev_scpdata
  0018e	48 8b 0c c1	 mov	 rcx, QWORD PTR [rcx+rax*8]
  00192	e8 00 00 00 00	 call	 strlen
  00197	89 44 24 20	 mov	 DWORD PTR scp_len$[rsp], eax

; 712  :         if(scp_len > 256)

  0019b	81 7c 24 20 00
	01 00 00	 cmp	 DWORD PTR scp_len$[rsp], 256 ; 00000100H
  001a3	7e 08		 jle	 SHORT $LN5@s370_store

; 713  :             scp_len = 256; // Sanity check

  001a5	c7 44 24 20 00
	01 00 00	 mov	 DWORD PTR scp_len$[rsp], 256 ; 00000100H
$LN5@s370_store:

; 714  :         STORE_FW(sb_bk->scp_len,scp_len);

  001ad	8b 4c 24 20	 mov	 ecx, DWORD PTR scp_len$[rsp]
  001b1	e8 00 00 00 00	 call	 _byteswap_ulong
  001b6	48 8b 4c 24 30	 mov	 rcx, QWORD PTR sb_bk$[rsp]
  001bb	48 81 c1 7c 01
	00 00		 add	 rcx, 380		; 0000017cH
  001c2	8b d0		 mov	 edx, eax
  001c4	e8 00 00 00 00	 call	 store_fw_noswap

; 715  :         memcpy((BYTE*)(sb_bk+1), scsi_lddev_scpdata[ldind], scp_len);

  001c9	48 63 44 24 20	 movsxd	 rax, DWORD PTR scp_len$[rsp]
  001ce	48 63 4c 24 78	 movsxd	 rcx, DWORD PTR ldind$[rsp]
  001d3	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:scsi_lddev_scpdata
  001da	48 8b 7c 24 30	 mov	 rdi, QWORD PTR sb_bk$[rsp]
  001df	48 81 c7 84 02
	00 00		 add	 rdi, 644		; 00000284H
  001e6	48 8b 34 ca	 mov	 rsi, QWORD PTR [rdx+rcx*8]
  001ea	48 8b c8	 mov	 rcx, rax
  001ed	f3 a4		 rep movsb

; 716  :     }

  001ef	eb 08		 jmp	 SHORT $LN4@s370_store
$LN3@s370_store:

; 717  :     else
; 718  :         scp_len = 0;

  001f1	c7 44 24 20 00
	00 00 00	 mov	 DWORD PTR scp_len$[rsp], 0
$LN4@s370_store:

; 719  : 
; 720  :     scp_len += 7;

  001f9	8b 44 24 20	 mov	 eax, DWORD PTR scp_len$[rsp]
  001fd	83 c0 07	 add	 eax, 7
  00200	89 44 24 20	 mov	 DWORD PTR scp_len$[rsp], eax

; 721  :     scp_len &= ~7;

  00204	8b 44 24 20	 mov	 eax, DWORD PTR scp_len$[rsp]
  00208	83 e0 f8	 and	 eax, -8
  0020b	89 44 24 20	 mov	 DWORD PTR scp_len$[rsp], eax

; 722  : 
; 723  :     STORE_FW(sb_bk->xml_off,sizeof(SCSI_BOOT_BK) + scp_len);

  0020f	48 63 44 24 20	 movsxd	 rax, DWORD PTR scp_len$[rsp]
  00214	48 05 84 02 00
	00		 add	 rax, 644		; 00000284H
  0021a	8b c8		 mov	 ecx, eax
  0021c	e8 00 00 00 00	 call	 _byteswap_ulong
  00221	48 8b 4c 24 30	 mov	 rcx, QWORD PTR sb_bk$[rsp]
  00226	8b d0		 mov	 edx, eax
  00228	e8 00 00 00 00	 call	 store_fw_noswap

; 724  : 
; 725  :     STORE_FW(sb_bk->scp_off,sizeof(SCSI_BOOT_BK) + scp_len - 8); // ZZ:???

  0022d	48 63 44 24 20	 movsxd	 rax, DWORD PTR scp_len$[rsp]
  00232	48 05 7c 02 00
	00		 add	 rax, 636		; 0000027cH
  00238	8b c8		 mov	 ecx, eax
  0023a	e8 00 00 00 00	 call	 _byteswap_ulong
  0023f	48 8b 4c 24 30	 mov	 rcx, QWORD PTR sb_bk$[rsp]
  00244	48 83 c1 08	 add	 rcx, 8
  00248	8b d0		 mov	 edx, eax
  0024a	e8 00 00 00 00	 call	 store_fw_noswap

; 726  : 
; 727  :     xml = (BYTE*)(sb_bk+1) + scp_len;

  0024f	48 63 44 24 20	 movsxd	 rax, DWORD PTR scp_len$[rsp]
  00254	48 8b 4c 24 30	 mov	 rcx, QWORD PTR sb_bk$[rsp]
  00259	48 8d 84 01 84
	02 00 00	 lea	 rax, QWORD PTR [rcx+rax+644]
  00261	48 89 44 24 28	 mov	 QWORD PTR xml$[rsp], rax

; 728  : 
; 729  :     xml += sprintf((char*)xml, "<?xml version=\"1.0\" encoding =\"UTF-8\"?>\n" );

  00266	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG169720
  0026d	48 8b 4c 24 28	 mov	 rcx, QWORD PTR xml$[rsp]
  00272	e8 00 00 00 00	 call	 sprintf
  00277	48 98		 cdqe
  00279	48 8b 4c 24 28	 mov	 rcx, QWORD PTR xml$[rsp]
  0027e	48 03 c8	 add	 rcx, rax
  00281	48 8b c1	 mov	 rax, rcx
  00284	48 89 44 24 28	 mov	 QWORD PTR xml$[rsp], rax

; 730  :     xml += sprintf((char*)xml, "<eServer_ipl_script version=\"1.0\">\n" );

  00289	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG169721
  00290	48 8b 4c 24 28	 mov	 rcx, QWORD PTR xml$[rsp]
  00295	e8 00 00 00 00	 call	 sprintf
  0029a	48 98		 cdqe
  0029c	48 8b 4c 24 28	 mov	 rcx, QWORD PTR xml$[rsp]
  002a1	48 03 c8	 add	 rcx, rax
  002a4	48 8b c1	 mov	 rax, rcx
  002a7	48 89 44 24 28	 mov	 QWORD PTR xml$[rsp], rax

; 731  :     xml += sprintf((char*)xml,  "<type>%s</type>\n", ldind ? "dump" : "ipl" );

  002ac	83 7c 24 78 00	 cmp	 DWORD PTR ldind$[rsp], 0
  002b1	74 0e		 je	 SHORT $LN10@s370_store
  002b3	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG169722
  002ba	48 89 44 24 38	 mov	 QWORD PTR tv212[rsp], rax
  002bf	eb 0c		 jmp	 SHORT $LN11@s370_store
$LN10@s370_store:
  002c1	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG169723
  002c8	48 89 44 24 38	 mov	 QWORD PTR tv212[rsp], rax
$LN11@s370_store:
  002cd	4c 8b 44 24 38	 mov	 r8, QWORD PTR tv212[rsp]
  002d2	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG169724
  002d9	48 8b 4c 24 28	 mov	 rcx, QWORD PTR xml$[rsp]
  002de	e8 00 00 00 00	 call	 sprintf
  002e3	48 98		 cdqe
  002e5	48 8b 4c 24 28	 mov	 rcx, QWORD PTR xml$[rsp]
  002ea	48 03 c8	 add	 rcx, rax
  002ed	48 8b c1	 mov	 rax, rcx
  002f0	48 89 44 24 28	 mov	 QWORD PTR xml$[rsp], rax

; 732  :     xml += sprintf((char*)xml,  "<ipl_control_section id=\"herculesipl-1\">\n" );

  002f5	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG169725
  002fc	48 8b 4c 24 28	 mov	 rcx, QWORD PTR xml$[rsp]
  00301	e8 00 00 00 00	 call	 sprintf
  00306	48 98		 cdqe
  00308	48 8b 4c 24 28	 mov	 rcx, QWORD PTR xml$[rsp]
  0030d	48 03 c8	 add	 rcx, rax
  00310	48 8b c1	 mov	 rax, rcx
  00313	48 89 44 24 28	 mov	 QWORD PTR xml$[rsp], rax

; 733  :     xml += sprintf((char*)xml,   "<ipl_platform_loader>\n" );

  00318	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG169726
  0031f	48 8b 4c 24 28	 mov	 rcx, QWORD PTR xml$[rsp]
  00324	e8 00 00 00 00	 call	 sprintf
  00329	48 98		 cdqe
  0032b	48 8b 4c 24 28	 mov	 rcx, QWORD PTR xml$[rsp]
  00330	48 03 c8	 add	 rcx, rax
  00333	48 8b c1	 mov	 rax, rcx
  00336	48 89 44 24 28	 mov	 QWORD PTR xml$[rsp], rax

; 734  :     xml += sprintf((char*)xml,    "<fcp_ipl>\n" );

  0033b	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG169727
  00342	48 8b 4c 24 28	 mov	 rcx, QWORD PTR xml$[rsp]
  00347	e8 00 00 00 00	 call	 sprintf
  0034c	48 98		 cdqe
  0034e	48 8b 4c 24 28	 mov	 rcx, QWORD PTR xml$[rsp]
  00353	48 03 c8	 add	 rcx, rax
  00356	48 8b c1	 mov	 rax, rcx
  00359	48 89 44 24 28	 mov	 QWORD PTR xml$[rsp], rax

; 735  :     xml += sprintf((char*)xml,     "<devno>0x%4.4X</devno>\n", dev->devnum);

  0035e	48 8b 44 24 70	 mov	 rax, QWORD PTR dev$[rsp]
  00363	0f b7 40 48	 movzx	 eax, WORD PTR [rax+72]
  00367	44 8b c0	 mov	 r8d, eax
  0036a	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG169728
  00371	48 8b 4c 24 28	 mov	 rcx, QWORD PTR xml$[rsp]
  00376	e8 00 00 00 00	 call	 sprintf
  0037b	48 98		 cdqe
  0037d	48 8b 4c 24 28	 mov	 rcx, QWORD PTR xml$[rsp]
  00382	48 03 c8	 add	 rcx, rax
  00385	48 8b c1	 mov	 rax, rcx
  00388	48 89 44 24 28	 mov	 QWORD PTR xml$[rsp], rax

; 736  :     xml += sprintf((char*)xml,     "<wwpn>0x%16.16"PRIX64"</wwpn>\n", scsi_lddev_wwpn[ldind]);

  0038d	48 63 44 24 78	 movsxd	 rax, DWORD PTR ldind$[rsp]
  00392	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:scsi_lddev_wwpn
  00399	4c 8b 04 c1	 mov	 r8, QWORD PTR [rcx+rax*8]
  0039d	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG169729
  003a4	48 8b 4c 24 28	 mov	 rcx, QWORD PTR xml$[rsp]
  003a9	e8 00 00 00 00	 call	 sprintf
  003ae	48 98		 cdqe
  003b0	48 8b 4c 24 28	 mov	 rcx, QWORD PTR xml$[rsp]
  003b5	48 03 c8	 add	 rcx, rax
  003b8	48 8b c1	 mov	 rax, rcx
  003bb	48 89 44 24 28	 mov	 QWORD PTR xml$[rsp], rax

; 737  :     xml += sprintf((char*)xml,     "<lun>0x%16.16"PRIX64"</lun>\n", scsi_lddev_lun[ldind]);

  003c0	48 63 44 24 78	 movsxd	 rax, DWORD PTR ldind$[rsp]
  003c5	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:scsi_lddev_lun
  003cc	4c 8b 04 c1	 mov	 r8, QWORD PTR [rcx+rax*8]
  003d0	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG169730
  003d7	48 8b 4c 24 28	 mov	 rcx, QWORD PTR xml$[rsp]
  003dc	e8 00 00 00 00	 call	 sprintf
  003e1	48 98		 cdqe
  003e3	48 8b 4c 24 28	 mov	 rcx, QWORD PTR xml$[rsp]
  003e8	48 03 c8	 add	 rcx, rax
  003eb	48 8b c1	 mov	 rax, rcx
  003ee	48 89 44 24 28	 mov	 QWORD PTR xml$[rsp], rax

; 738  :     xml += sprintf((char*)xml,     "<boot_program_selector>0x%8.8X</boot_program_selector>\n", scsi_lddev_prog[ldind]);

  003f3	48 63 44 24 78	 movsxd	 rax, DWORD PTR ldind$[rsp]
  003f8	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:scsi_lddev_prog
  003ff	44 8b 04 81	 mov	 r8d, DWORD PTR [rcx+rax*4]
  00403	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG169731
  0040a	48 8b 4c 24 28	 mov	 rcx, QWORD PTR xml$[rsp]
  0040f	e8 00 00 00 00	 call	 sprintf
  00414	48 98		 cdqe
  00416	48 8b 4c 24 28	 mov	 rcx, QWORD PTR xml$[rsp]
  0041b	48 03 c8	 add	 rcx, rax
  0041e	48 8b c1	 mov	 rax, rcx
  00421	48 89 44 24 28	 mov	 QWORD PTR xml$[rsp], rax

; 739  :     xml += sprintf((char*)xml,     "<br_lba>0x%16.16"PRIX64"</br_lba>\n", scsi_lddev_brlba[ldind]);

  00426	48 63 44 24 78	 movsxd	 rax, DWORD PTR ldind$[rsp]
  0042b	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:scsi_lddev_brlba
  00432	4c 8b 04 c1	 mov	 r8, QWORD PTR [rcx+rax*8]
  00436	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG169732
  0043d	48 8b 4c 24 28	 mov	 rcx, QWORD PTR xml$[rsp]
  00442	e8 00 00 00 00	 call	 sprintf
  00447	48 98		 cdqe
  00449	48 8b 4c 24 28	 mov	 rcx, QWORD PTR xml$[rsp]
  0044e	48 03 c8	 add	 rcx, rax
  00451	48 8b c1	 mov	 rax, rcx
  00454	48 89 44 24 28	 mov	 QWORD PTR xml$[rsp], rax

; 740  :     xml += sprintf((char*)xml,    "</fcp_ipl>\n" );

  00459	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG169733
  00460	48 8b 4c 24 28	 mov	 rcx, QWORD PTR xml$[rsp]
  00465	e8 00 00 00 00	 call	 sprintf
  0046a	48 98		 cdqe
  0046c	48 8b 4c 24 28	 mov	 rcx, QWORD PTR xml$[rsp]
  00471	48 03 c8	 add	 rcx, rax
  00474	48 8b c1	 mov	 rax, rcx
  00477	48 89 44 24 28	 mov	 QWORD PTR xml$[rsp], rax

; 741  :     xml += sprintf((char*)xml,   "</ipl_platform_loader>\n" );

  0047c	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG169734
  00483	48 8b 4c 24 28	 mov	 rcx, QWORD PTR xml$[rsp]
  00488	e8 00 00 00 00	 call	 sprintf
  0048d	48 98		 cdqe
  0048f	48 8b 4c 24 28	 mov	 rcx, QWORD PTR xml$[rsp]
  00494	48 03 c8	 add	 rcx, rax
  00497	48 8b c1	 mov	 rax, rcx
  0049a	48 89 44 24 28	 mov	 QWORD PTR xml$[rsp], rax

; 742  :     if(scp_len)

  0049f	83 7c 24 20 00	 cmp	 DWORD PTR scp_len$[rsp], 0
  004a4	74 79		 je	 SHORT $LN6@s370_store

; 743  :     {
; 744  :       xml += sprintf((char*)xml, "<system_control_program>\n" );

  004a6	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG169736
  004ad	48 8b 4c 24 28	 mov	 rcx, QWORD PTR xml$[rsp]
  004b2	e8 00 00 00 00	 call	 sprintf
  004b7	48 98		 cdqe
  004b9	48 8b 4c 24 28	 mov	 rcx, QWORD PTR xml$[rsp]
  004be	48 03 c8	 add	 rcx, rax
  004c1	48 8b c1	 mov	 rax, rcx
  004c4	48 89 44 24 28	 mov	 QWORD PTR xml$[rsp], rax

; 745  :       xml += sprintf((char*)xml,  "<parameter_string>%s</parameter_string>\n", scsi_lddev_scpdata[ldind]);

  004c9	48 63 44 24 78	 movsxd	 rax, DWORD PTR ldind$[rsp]
  004ce	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:scsi_lddev_scpdata
  004d5	4c 8b 04 c1	 mov	 r8, QWORD PTR [rcx+rax*8]
  004d9	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG169737
  004e0	48 8b 4c 24 28	 mov	 rcx, QWORD PTR xml$[rsp]
  004e5	e8 00 00 00 00	 call	 sprintf
  004ea	48 98		 cdqe
  004ec	48 8b 4c 24 28	 mov	 rcx, QWORD PTR xml$[rsp]
  004f1	48 03 c8	 add	 rcx, rax
  004f4	48 8b c1	 mov	 rax, rcx
  004f7	48 89 44 24 28	 mov	 QWORD PTR xml$[rsp], rax

; 746  :       xml += sprintf((char*)xml, "</system_control_program>\n" );

  004fc	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG169738
  00503	48 8b 4c 24 28	 mov	 rcx, QWORD PTR xml$[rsp]
  00508	e8 00 00 00 00	 call	 sprintf
  0050d	48 98		 cdqe
  0050f	48 8b 4c 24 28	 mov	 rcx, QWORD PTR xml$[rsp]
  00514	48 03 c8	 add	 rcx, rax
  00517	48 8b c1	 mov	 rax, rcx
  0051a	48 89 44 24 28	 mov	 QWORD PTR xml$[rsp], rax
$LN6@s370_store:

; 747  :     }
; 748  :     xml += sprintf((char*)xml,  "</ipl_control_section>\n" );

  0051f	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG169739
  00526	48 8b 4c 24 28	 mov	 rcx, QWORD PTR xml$[rsp]
  0052b	e8 00 00 00 00	 call	 sprintf
  00530	48 98		 cdqe
  00532	48 8b 4c 24 28	 mov	 rcx, QWORD PTR xml$[rsp]
  00537	48 03 c8	 add	 rcx, rax
  0053a	48 8b c1	 mov	 rax, rcx
  0053d	48 89 44 24 28	 mov	 QWORD PTR xml$[rsp], rax

; 749  :     xml += sprintf((char*)xml, "</eServer_ipl_script>\n" );

  00542	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG169740
  00549	48 8b 4c 24 28	 mov	 rcx, QWORD PTR xml$[rsp]
  0054e	e8 00 00 00 00	 call	 sprintf
  00553	48 98		 cdqe
  00555	48 8b 4c 24 28	 mov	 rcx, QWORD PTR xml$[rsp]
  0055a	48 03 c8	 add	 rcx, rax
  0055d	48 8b c1	 mov	 rax, rcx
  00560	48 89 44 24 28	 mov	 QWORD PTR xml$[rsp], rax

; 750  : 
; 751  :     return 0;

  00565	33 c0		 xor	 eax, eax
$LN1@s370_store:

; 752  : }

  00567	48 83 c4 58	 add	 rsp, 88			; 00000058H
  0056b	5f		 pop	 rdi
  0056c	5e		 pop	 rsi
  0056d	c3		 ret	 0
s370_store_boot_parms ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\skey.h
;	COMDAT _get_storekey2_ptr
_TEXT	SEGMENT
abs$ = 8
_get_storekey2_ptr PROC					; COMDAT

; 60   : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx

; 61   :     ABS_CHECK( abs );
; 62   :     return &STOREKEY2( abs, &sysblk );

  00005	48 8b 44 24 08	 mov	 rax, QWORD PTR abs$[rsp]
  0000a	48 c1 e8 0b	 shr	 rax, 11
  0000e	48 83 c8 01	 or	 rax, 1
  00012	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  00019	48 8b 89 a0 00
	00 00		 mov	 rcx, QWORD PTR [rcx+160]
  00020	48 03 c8	 add	 rcx, rax
  00023	48 8b c1	 mov	 rax, rcx

; 63   : }

  00026	c3		 ret	 0
_get_storekey2_ptr ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\skey.h
;	COMDAT _get_storekey1_ptr
_TEXT	SEGMENT
abs$ = 8
_get_storekey1_ptr PROC					; COMDAT

; 54   : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx

; 55   :     ABS_CHECK( abs );
; 56   :     return &STOREKEY1( abs, &sysblk );

  00005	48 8b 44 24 08	 mov	 rax, QWORD PTR abs$[rsp]
  0000a	48 c1 e8 0b	 shr	 rax, 11
  0000e	48 83 e0 fe	 and	 rax, -2
  00012	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  00019	48 8b 89 a0 00
	00 00		 mov	 rcx, QWORD PTR [rcx+160]
  00020	48 03 c8	 add	 rcx, rax
  00023	48 8b c1	 mov	 rax, rcx

; 57   : }

  00026	c3		 ret	 0
_get_storekey1_ptr ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\skey.h
;	COMDAT _get_storekey_ptr
_TEXT	SEGMENT
tv75 = 0
abs$ = 32
K$ = 40
_get_storekey_ptr PROC					; COMDAT

; 40   : {

$LN5:
  00000	88 54 24 10	 mov	 BYTE PTR [rsp+16], dl
  00004	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00009	48 83 ec 18	 sub	 rsp, 24

; 41   :     ABS_CHECK( abs );
; 42   :     return (4 == K) ? &STOREKEY1( abs, &sysblk ) // (see feature.h PROGRAMMING NOTE)

  0000d	0f b6 44 24 28	 movzx	 eax, BYTE PTR K$[rsp]
  00012	83 f8 04	 cmp	 eax, 4
  00015	75 27		 jne	 SHORT $LN3@get_storek
  00017	48 8b 44 24 20	 mov	 rax, QWORD PTR abs$[rsp]
  0001c	48 c1 e8 0b	 shr	 rax, 11
  00020	48 83 e0 fe	 and	 rax, -2
  00024	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  0002b	48 8b 89 a0 00
	00 00		 mov	 rcx, QWORD PTR [rcx+160]
  00032	48 03 c8	 add	 rcx, rax
  00035	48 8b c1	 mov	 rax, rcx
  00038	48 89 04 24	 mov	 QWORD PTR tv75[rsp], rax
  0003c	eb 21		 jmp	 SHORT $LN4@get_storek
$LN3@get_storek:
  0003e	48 8b 44 24 20	 mov	 rax, QWORD PTR abs$[rsp]
  00043	48 c1 e8 0b	 shr	 rax, 11
  00047	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  0004e	48 8b 89 a0 00
	00 00		 mov	 rcx, QWORD PTR [rcx+160]
  00055	48 03 c8	 add	 rcx, rax
  00058	48 8b c1	 mov	 rax, rcx
  0005b	48 89 04 24	 mov	 QWORD PTR tv75[rsp], rax
$LN4@get_storek:
  0005f	48 8b 04 24	 mov	 rax, QWORD PTR tv75[rsp]

; 43   :                     : &STOREKEY(  abs, &sysblk );
; 44   : }

  00063	48 83 c4 18	 add	 rsp, 24
  00067	c3		 ret	 0
_get_storekey_ptr ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\hinlines.h
_TEXT	SEGMENT
regs$ = 48
location$ = 56
Release_Interrupt_Lock PROC

; 403  : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 28	 sub	 rsp, 40			; 00000028H
$LN4@Release_In:

; 404  :     UNREFERENCED( regs );

  0000e	33 c0		 xor	 eax, eax
  00010	85 c0		 test	 eax, eax
  00012	75 fa		 jne	 SHORT $LN4@Release_In

; 405  :     sysblk.intowner = LOCK_OWNER_NONE;

  00014	b8 ff ff 00 00	 mov	 eax, 65535		; 0000ffffH
  00019	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  00020	66 89 81 62 10
	00 00		 mov	 WORD PTR [rcx+4194], ax

; 406  :     hthread_release_lock( &sysblk.intlock, location );

  00027	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  0002e	48 05 70 10 00
	00		 add	 rax, 4208		; 00001070H
  00034	48 8b 54 24 38	 mov	 rdx, QWORD PTR location$[rsp]
  00039	48 8b c8	 mov	 rcx, rax
  0003c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_release_lock

; 407  : }

  00042	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00046	c3		 ret	 0
Release_Interrupt_Lock ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\hinlines.h
_TEXT	SEGMENT
regs$ = 48
location$ = 56
Obtain_Interrupt_Lock PROC

; 379  : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 380  :     if (regs)

  0000e	48 83 7c 24 30
	00		 cmp	 QWORD PTR regs$[rsp], 0
  00014	74 13		 je	 SHORT $LN2@Obtain_Int

; 381  :         HOSTREGS->intwait = true;

  00016	48 8b 44 24 30	 mov	 rax, QWORD PTR regs$[rsp]
  0001b	48 8b 80 68 08
	00 00		 mov	 rax, QWORD PTR [rax+2152]
  00022	c6 80 f0 08 00
	00 01		 mov	 BYTE PTR [rax+2288], 1
$LN2@Obtain_Int:

; 382  :     hthread_obtain_lock( &sysblk.intlock, location );

  00029	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00030	48 05 70 10 00
	00		 add	 rax, 4208		; 00001070H
  00036	48 8b 54 24 38	 mov	 rdx, QWORD PTR location$[rsp]
  0003b	48 8b c8	 mov	 rcx, rax
  0003e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_obtain_lock

; 383  :     Interrupt_Lock_Obtained( regs, location );

  00044	48 8b 54 24 38	 mov	 rdx, QWORD PTR location$[rsp]
  00049	48 8b 4c 24 30	 mov	 rcx, QWORD PTR regs$[rsp]
  0004e	e8 00 00 00 00	 call	 Interrupt_Lock_Obtained

; 384  : }

  00053	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00057	c3		 ret	 0
Obtain_Interrupt_Lock ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\hinlines.h
_TEXT	SEGMENT
regs$ = 48
location$ = 56
Interrupt_Lock_Obtained PROC

; 347  : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 348  :     if (regs)

  0000e	48 83 7c 24 30
	00		 cmp	 QWORD PTR regs$[rsp], 0
  00014	0f 84 db 00 00
	00		 je	 $LN4@Interrupt_
$LN2@Interrupt_:

; 349  :     {
; 350  :         /* Wait for any SYNCHRONIZE_CPUS to finish before proceeding */
; 351  :         while (sysblk.syncing)

  0001a	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00021	0f b6 80 7c 13
	00 00		 movzx	 eax, BYTE PTR [rax+4988]
  00028	85 c0		 test	 eax, eax
  0002a	0f 84 8f 00 00
	00		 je	 $LN3@Interrupt_

; 352  :         {
; 353  :             /* Indicate we have reached the sync point */
; 354  :             sysblk.sync_mask &= ~HOSTREGS->cpubit;

  00030	48 8b 44 24 30	 mov	 rax, QWORD PTR regs$[rsp]
  00035	48 8b 80 68 08
	00 00		 mov	 rax, QWORD PTR [rax+2152]
  0003c	48 8b 40 50	 mov	 rax, QWORD PTR [rax+80]
  00040	48 f7 d0	 not	 rax
  00043	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  0004a	48 8b 89 80 13
	00 00		 mov	 rcx, QWORD PTR [rcx+4992]
  00051	48 23 c8	 and	 rcx, rax
  00054	48 8b c1	 mov	 rax, rcx
  00057	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  0005e	48 89 81 80 13
	00 00		 mov	 QWORD PTR [rcx+4992], rax

; 355  : 
; 356  :             /* If we're the last CPU to reach this sync point,
; 357  :                signal the CPU that requested the sync that it
; 358  :                may now safely proceed with its exclusive logic.
; 359  :             */
; 360  :             if (!sysblk.sync_mask)

  00065	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  0006c	48 83 b8 80 13
	00 00 00	 cmp	 QWORD PTR [rax+4992], 0
  00074	75 1b		 jne	 SHORT $LN6@Interrupt_

; 361  :                 hthread_signal_condition( &sysblk.all_synced_cond, location );

  00076	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  0007d	48 05 88 13 00
	00		 add	 rax, 5000		; 00001388H
  00083	48 8b 54 24 38	 mov	 rdx, QWORD PTR location$[rsp]
  00088	48 8b c8	 mov	 rcx, rax
  0008b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_signal_condition
$LN6@Interrupt_:

; 362  : 
; 363  :             /* Wait for CPU that requested the sync to indicate
; 364  :                it's done and thus is now safe for us to proceed.
; 365  :             */
; 366  :             hthread_wait_condition( &sysblk.sync_done_cond, &sysblk.intlock, location );

  00091	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00098	48 05 70 10 00
	00		 add	 rax, 4208		; 00001070H
  0009e	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  000a5	48 81 c1 90 13
	00 00		 add	 rcx, 5008		; 00001390H
  000ac	4c 8b 44 24 38	 mov	 r8, QWORD PTR location$[rsp]
  000b1	48 8b d0	 mov	 rdx, rax
  000b4	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_wait_condition

; 367  :         }

  000ba	e9 5b ff ff ff	 jmp	 $LN2@Interrupt_
$LN3@Interrupt_:

; 368  : 
; 369  :         HOSTREGS->intwait = false;

  000bf	48 8b 44 24 30	 mov	 rax, QWORD PTR regs$[rsp]
  000c4	48 8b 80 68 08
	00 00		 mov	 rax, QWORD PTR [rax+2152]
  000cb	c6 80 f0 08 00
	00 00		 mov	 BYTE PTR [rax+2288], 0

; 370  :         sysblk.intowner = HOSTREGS->cpuad;

  000d2	48 8b 44 24 30	 mov	 rax, QWORD PTR regs$[rsp]
  000d7	48 8b 80 68 08
	00 00		 mov	 rax, QWORD PTR [rax+2152]
  000de	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  000e5	0f b7 80 3c 08
	00 00		 movzx	 eax, WORD PTR [rax+2108]
  000ec	66 89 81 62 10
	00 00		 mov	 WORD PTR [rcx+4194], ax

; 371  :     }

  000f3	eb 13		 jmp	 SHORT $LN5@Interrupt_
$LN4@Interrupt_:

; 372  :     else
; 373  :         sysblk.intowner = LOCK_OWNER_OTHER;

  000f5	b8 fe ff 00 00	 mov	 eax, 65534		; 0000fffeH
  000fa	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  00101	66 89 81 62 10
	00 00		 mov	 WORD PTR [rcx+4194], ax
$LN5@Interrupt_:

; 374  : }

  00108	48 83 c4 28	 add	 rsp, 40			; 00000028H
  0010c	c3		 ret	 0
Interrupt_Lock_Obtained ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\machdep.h
;	COMDAT store_dw_noswap
_TEXT	SEGMENT
ptr$ = 8
value$ = 16
store_dw_noswap PROC					; COMDAT

; 834  :     inline void store_dw_noswap(void *ptr, U64 value) {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx

; 835  :       memcpy((BYTE *)ptr, (BYTE *)&value, 8);

  0000a	48 8b 44 24 08	 mov	 rax, QWORD PTR ptr$[rsp]
  0000f	48 8b 4c 24 10	 mov	 rcx, QWORD PTR value$[rsp]
  00014	48 89 08	 mov	 QWORD PTR [rax], rcx

; 836  :     }

  00017	c3		 ret	 0
store_dw_noswap ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\machdep.h
;	COMDAT fetch_dw_noswap
_TEXT	SEGMENT
value$ = 0
ptr$ = 32
fetch_dw_noswap PROC					; COMDAT

; 816  :     inline U64 fetch_dw_noswap(const void *ptr) {

$LN3:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 18	 sub	 rsp, 24

; 817  :       U64 value;
; 818  :       memcpy(&value, (BYTE *)ptr, 8);

  00009	48 8b 44 24 20	 mov	 rax, QWORD PTR ptr$[rsp]
  0000e	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00011	48 89 04 24	 mov	 QWORD PTR value$[rsp], rax

; 819  :       return value;

  00015	48 8b 04 24	 mov	 rax, QWORD PTR value$[rsp]

; 820  :     }

  00019	48 83 c4 18	 add	 rsp, 24
  0001d	c3		 ret	 0
fetch_dw_noswap ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\machdep.h
;	COMDAT store_fw_noswap
_TEXT	SEGMENT
ptr$ = 8
value$ = 16
store_fw_noswap PROC					; COMDAT

; 764  :     inline void store_fw_noswap(void *ptr, U32 value) {

  00000	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00004	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx

; 765  :       memcpy((BYTE *)ptr, (BYTE *)&value, 4);

  00009	48 8b 44 24 08	 mov	 rax, QWORD PTR ptr$[rsp]
  0000e	8b 4c 24 10	 mov	 ecx, DWORD PTR value$[rsp]
  00012	89 08		 mov	 DWORD PTR [rax], ecx

; 766  :     }

  00014	c3		 ret	 0
store_fw_noswap ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\machdep.h
;	COMDAT fetch_fw_noswap
_TEXT	SEGMENT
value$ = 0
ptr$ = 32
fetch_fw_noswap PROC					; COMDAT

; 746  :     inline U32 fetch_fw_noswap(const void *ptr) {

$LN3:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 18	 sub	 rsp, 24

; 747  :       U32 value;
; 748  :       memcpy(&value, (BYTE *)ptr, 4);

  00009	48 8b 44 24 20	 mov	 rax, QWORD PTR ptr$[rsp]
  0000e	8b 00		 mov	 eax, DWORD PTR [rax]
  00010	89 04 24	 mov	 DWORD PTR value$[rsp], eax

; 749  :       return value;

  00013	8b 04 24	 mov	 eax, DWORD PTR value$[rsp]

; 750  :     }

  00016	48 83 c4 18	 add	 rsp, 24
  0001a	c3		 ret	 0
fetch_fw_noswap ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\machdep.h
;	COMDAT store_hw_noswap
_TEXT	SEGMENT
ptr$ = 8
value$ = 16
store_hw_noswap PROC					; COMDAT

; 730  :     inline void store_hw_noswap(void *ptr, U16 value) {

  00000	66 89 54 24 10	 mov	 WORD PTR [rsp+16], dx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx

; 731  :       memcpy((BYTE *)ptr, (BYTE *)&value, 2);

  0000a	48 8b 44 24 08	 mov	 rax, QWORD PTR ptr$[rsp]
  0000f	0f b7 4c 24 10	 movzx	 ecx, WORD PTR value$[rsp]
  00014	66 89 08	 mov	 WORD PTR [rax], cx

; 732  :     }

  00017	c3		 ret	 0
store_hw_noswap ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\machdep.h
;	COMDAT fetch_hw_noswap
_TEXT	SEGMENT
value$ = 0
ptr$ = 32
fetch_hw_noswap PROC					; COMDAT

; 712  :     inline U16 fetch_hw_noswap(const void *ptr) {

$LN3:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 18	 sub	 rsp, 24

; 713  :       U16 value;
; 714  :       memcpy(&value, (BYTE *)ptr, 2);

  00009	48 8b 44 24 20	 mov	 rax, QWORD PTR ptr$[rsp]
  0000e	0f b7 00	 movzx	 eax, WORD PTR [rax]
  00011	66 89 04 24	 mov	 WORD PTR value$[rsp], ax

; 715  :       return value;

  00015	0f b7 04 24	 movzx	 eax, WORD PTR value$[rsp]

; 716  :     }

  00019	48 83 c4 18	 add	 rsp, 24
  0001d	c3		 ret	 0
fetch_hw_noswap ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\scescsi.c
_TEXT	SEGMENT
i$ = 64
ldind$ = 68
c$ = 72
tv82 = 76
tv84 = 80
tv316 = 88
tv423 = 96
tv333 = 104
tv425 = 112
tv350 = 120
tv427 = 128
tv367 = 136
tv429 = 144
tv384 = 152
tv431 = 160
tv401 = 168
argc$ = 192
argv$ = 200
cmdline$ = 208
lddev_cmd PROC

; 907  : {

$LN37:
  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	89 4c 24 08	 mov	 DWORD PTR [rsp+8], ecx
  0000e	48 81 ec b8 00
	00 00		 sub	 rsp, 184		; 000000b8H
$LN4@lddev_cmd:

; 908  :     int  i;
; 909  :     char c;
; 910  :     int  ldind;     /* LOAD/DUMP indicator: [0] = LOAD, [1] = DUMP */
; 911  : 
; 912  :     UNREFERENCED(cmdline);

  00015	33 c0		 xor	 eax, eax
  00017	85 c0		 test	 eax, eax
  00019	75 fa		 jne	 SHORT $LN4@lddev_cmd

; 913  : 
; 914  :     // [0] = LOAD, [1] = DUMP
; 915  :     ldind = ((islower(*argv[0]) ? toupper(*argv[0]) : *argv[0] ) == 'L')

  0001b	b8 08 00 00 00	 mov	 eax, 8
  00020	48 6b c0 00	 imul	 rax, rax, 0
  00024	48 8b 8c 24 c8
	00 00 00	 mov	 rcx, QWORD PTR argv$[rsp]
  0002c	48 8b 04 01	 mov	 rax, QWORD PTR [rcx+rax]
  00030	0f be 00	 movsx	 eax, BYTE PTR [rax]
  00033	8b c8		 mov	 ecx, eax
  00035	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_islower
  0003b	85 c0		 test	 eax, eax
  0003d	74 26		 je	 SHORT $LN33@lddev_cmd
  0003f	b8 08 00 00 00	 mov	 eax, 8
  00044	48 6b c0 00	 imul	 rax, rax, 0
  00048	48 8b 8c 24 c8
	00 00 00	 mov	 rcx, QWORD PTR argv$[rsp]
  00050	48 8b 04 01	 mov	 rax, QWORD PTR [rcx+rax]
  00054	0f be 00	 movsx	 eax, BYTE PTR [rax]
  00057	8b c8		 mov	 ecx, eax
  00059	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_toupper
  0005f	89 44 24 4c	 mov	 DWORD PTR tv82[rsp], eax
  00063	eb 1c		 jmp	 SHORT $LN34@lddev_cmd
$LN33@lddev_cmd:
  00065	b8 08 00 00 00	 mov	 eax, 8
  0006a	48 6b c0 00	 imul	 rax, rax, 0
  0006e	48 8b 8c 24 c8
	00 00 00	 mov	 rcx, QWORD PTR argv$[rsp]
  00076	48 8b 04 01	 mov	 rax, QWORD PTR [rcx+rax]
  0007a	0f be 00	 movsx	 eax, BYTE PTR [rax]
  0007d	89 44 24 4c	 mov	 DWORD PTR tv82[rsp], eax
$LN34@lddev_cmd:
  00081	83 7c 24 4c 4c	 cmp	 DWORD PTR tv82[rsp], 76	; 0000004cH
  00086	75 0a		 jne	 SHORT $LN35@lddev_cmd
  00088	c7 44 24 50 00
	00 00 00	 mov	 DWORD PTR tv84[rsp], 0
  00090	eb 08		 jmp	 SHORT $LN36@lddev_cmd
$LN35@lddev_cmd:
  00092	c7 44 24 50 01
	00 00 00	 mov	 DWORD PTR tv84[rsp], 1
$LN36@lddev_cmd:
  0009a	8b 44 24 50	 mov	 eax, DWORD PTR tv84[rsp]
  0009e	89 44 24 44	 mov	 DWORD PTR ldind$[rsp], eax

; 916  :           ? 0 : 1;
; 917  : 
; 918  :     if(argc > 1)

  000a2	83 bc 24 c0 00
	00 00 01	 cmp	 DWORD PTR argc$[rsp], 1
  000aa	0f 8e d6 04 00
	00		 jle	 $LN8@lddev_cmd

; 919  :     {
; 920  :         // process all command line options here
; 921  :         for(i = 1; i < argc; i++)

  000b0	c7 44 24 40 01
	00 00 00	 mov	 DWORD PTR i$[rsp], 1
  000b8	eb 0a		 jmp	 SHORT $LN7@lddev_cmd
$LN5@lddev_cmd:
  000ba	8b 44 24 40	 mov	 eax, DWORD PTR i$[rsp]
  000be	ff c0		 inc	 eax
  000c0	89 44 24 40	 mov	 DWORD PTR i$[rsp], eax
$LN7@lddev_cmd:
  000c4	8b 84 24 c0 00
	00 00		 mov	 eax, DWORD PTR argc$[rsp]
  000cb	39 44 24 40	 cmp	 DWORD PTR i$[rsp], eax
  000cf	0f 8d ac 04 00
	00		 jge	 $LN6@lddev_cmd

; 922  :         {
; 923  :             if(!strcasecmp("portname",argv[i]) && (i+1) < argc)

  000d5	48 63 44 24 40	 movsxd	 rax, DWORD PTR i$[rsp]
  000da	48 8b 8c 24 c8
	00 00 00	 mov	 rcx, QWORD PTR argv$[rsp]
  000e2	48 8b 14 c1	 mov	 rdx, QWORD PTR [rcx+rax*8]
  000e6	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG193339
  000ed	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__stricmp
  000f3	85 c0		 test	 eax, eax
  000f5	0f 85 b4 00 00
	00		 jne	 $LN10@lddev_cmd
  000fb	8b 44 24 40	 mov	 eax, DWORD PTR i$[rsp]
  000ff	ff c0		 inc	 eax
  00101	3b 84 24 c0 00
	00 00		 cmp	 eax, DWORD PTR argc$[rsp]
  00108	0f 8d a1 00 00
	00		 jge	 $LN10@lddev_cmd

; 924  :             {
; 925  :                 if(sscanf(argv[++i], "%"SCNx64"%c", &scsi_lddev_wwpn[ldind], &c) != 1)

  0010e	8b 44 24 40	 mov	 eax, DWORD PTR i$[rsp]
  00112	ff c0		 inc	 eax
  00114	89 44 24 40	 mov	 DWORD PTR i$[rsp], eax
  00118	48 63 44 24 44	 movsxd	 rax, DWORD PTR ldind$[rsp]
  0011d	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:scsi_lddev_wwpn
  00124	48 8d 04 c1	 lea	 rax, QWORD PTR [rcx+rax*8]
  00128	48 63 4c 24 40	 movsxd	 rcx, DWORD PTR i$[rsp]
  0012d	4c 8d 4c 24 48	 lea	 r9, QWORD PTR c$[rsp]
  00132	4c 8b c0	 mov	 r8, rax
  00135	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG193341
  0013c	48 8b 84 24 c8
	00 00 00	 mov	 rax, QWORD PTR argv$[rsp]
  00144	48 8b 0c c8	 mov	 rcx, QWORD PTR [rax+rcx*8]
  00148	e8 00 00 00 00	 call	 sscanf
  0014d	83 f8 01	 cmp	 eax, 1
  00150	74 53		 je	 SHORT $LN12@lddev_cmd

; 926  :                     // "Invalid %s"
; 927  :                     WRMSG( HHC00670, "E", "PORTNAME" );

  00152	b9 01 00 00 00	 mov	 ecx, 1
  00157	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  0015d	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG193342
  00164	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  00169	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG193343
  00170	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  00175	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG193344
  0017c	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00181	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00186	41 b9 03 00 00
	00		 mov	 r9d, 3
  0018c	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG193345
  00193	ba 9f 03 00 00	 mov	 edx, 927		; 0000039fH
  00198	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG193346
  0019f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg
$LN12@lddev_cmd:

; 928  :                 continue;

  001a5	e9 10 ff ff ff	 jmp	 $LN5@lddev_cmd

; 929  :             }

  001aa	e9 cd 03 00 00	 jmp	 $LN11@lddev_cmd
$LN10@lddev_cmd:

; 930  :             else if(!strcasecmp("lun",argv[i]) && (i+1) < argc)

  001af	48 63 44 24 40	 movsxd	 rax, DWORD PTR i$[rsp]
  001b4	48 8b 8c 24 c8
	00 00 00	 mov	 rcx, QWORD PTR argv$[rsp]
  001bc	48 8b 14 c1	 mov	 rdx, QWORD PTR [rcx+rax*8]
  001c0	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG193349
  001c7	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__stricmp
  001cd	85 c0		 test	 eax, eax
  001cf	0f 85 b4 00 00
	00		 jne	 $LN13@lddev_cmd
  001d5	8b 44 24 40	 mov	 eax, DWORD PTR i$[rsp]
  001d9	ff c0		 inc	 eax
  001db	3b 84 24 c0 00
	00 00		 cmp	 eax, DWORD PTR argc$[rsp]
  001e2	0f 8d a1 00 00
	00		 jge	 $LN13@lddev_cmd

; 931  :             {
; 932  :                 if(sscanf(argv[++i], "%"SCNx64"%c", &scsi_lddev_lun[ldind], &c) != 1)

  001e8	8b 44 24 40	 mov	 eax, DWORD PTR i$[rsp]
  001ec	ff c0		 inc	 eax
  001ee	89 44 24 40	 mov	 DWORD PTR i$[rsp], eax
  001f2	48 63 44 24 44	 movsxd	 rax, DWORD PTR ldind$[rsp]
  001f7	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:scsi_lddev_lun
  001fe	48 8d 04 c1	 lea	 rax, QWORD PTR [rcx+rax*8]
  00202	48 63 4c 24 40	 movsxd	 rcx, DWORD PTR i$[rsp]
  00207	4c 8d 4c 24 48	 lea	 r9, QWORD PTR c$[rsp]
  0020c	4c 8b c0	 mov	 r8, rax
  0020f	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG193351
  00216	48 8b 84 24 c8
	00 00 00	 mov	 rax, QWORD PTR argv$[rsp]
  0021e	48 8b 0c c8	 mov	 rcx, QWORD PTR [rax+rcx*8]
  00222	e8 00 00 00 00	 call	 sscanf
  00227	83 f8 01	 cmp	 eax, 1
  0022a	74 53		 je	 SHORT $LN15@lddev_cmd

; 933  :                     // "Invalid %s"
; 934  :                     WRMSG( HHC00670, "E", "LUN" );

  0022c	b9 01 00 00 00	 mov	 ecx, 1
  00231	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  00237	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG193352
  0023e	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  00243	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG193353
  0024a	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  0024f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG193354
  00256	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  0025b	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00260	41 b9 03 00 00
	00		 mov	 r9d, 3
  00266	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG193355
  0026d	ba a6 03 00 00	 mov	 edx, 934		; 000003a6H
  00272	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG193356
  00279	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg
$LN15@lddev_cmd:

; 935  :                 continue;

  0027f	e9 36 fe ff ff	 jmp	 $LN5@lddev_cmd

; 936  :             }

  00284	e9 f3 02 00 00	 jmp	 $LN14@lddev_cmd
$LN13@lddev_cmd:

; 937  :             else if(!strcasecmp("bootprog",argv[i]) && (i+1) < argc)

  00289	48 63 44 24 40	 movsxd	 rax, DWORD PTR i$[rsp]
  0028e	48 8b 8c 24 c8
	00 00 00	 mov	 rcx, QWORD PTR argv$[rsp]
  00296	48 8b 14 c1	 mov	 rdx, QWORD PTR [rcx+rax*8]
  0029a	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG193359
  002a1	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__stricmp
  002a7	85 c0		 test	 eax, eax
  002a9	0f 85 b4 00 00
	00		 jne	 $LN16@lddev_cmd
  002af	8b 44 24 40	 mov	 eax, DWORD PTR i$[rsp]
  002b3	ff c0		 inc	 eax
  002b5	3b 84 24 c0 00
	00 00		 cmp	 eax, DWORD PTR argc$[rsp]
  002bc	0f 8d a1 00 00
	00		 jge	 $LN16@lddev_cmd

; 938  :             {
; 939  :                 if(sscanf(argv[++i], "%"SCNx32"%c", &scsi_lddev_prog[ldind], &c) != 1)

  002c2	8b 44 24 40	 mov	 eax, DWORD PTR i$[rsp]
  002c6	ff c0		 inc	 eax
  002c8	89 44 24 40	 mov	 DWORD PTR i$[rsp], eax
  002cc	48 63 44 24 44	 movsxd	 rax, DWORD PTR ldind$[rsp]
  002d1	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:scsi_lddev_prog
  002d8	48 8d 04 81	 lea	 rax, QWORD PTR [rcx+rax*4]
  002dc	48 63 4c 24 40	 movsxd	 rcx, DWORD PTR i$[rsp]
  002e1	4c 8d 4c 24 48	 lea	 r9, QWORD PTR c$[rsp]
  002e6	4c 8b c0	 mov	 r8, rax
  002e9	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG193361
  002f0	48 8b 84 24 c8
	00 00 00	 mov	 rax, QWORD PTR argv$[rsp]
  002f8	48 8b 0c c8	 mov	 rcx, QWORD PTR [rax+rcx*8]
  002fc	e8 00 00 00 00	 call	 sscanf
  00301	83 f8 01	 cmp	 eax, 1
  00304	74 53		 je	 SHORT $LN18@lddev_cmd

; 940  :                     // "Invalid %s"
; 941  :                     WRMSG( HHC00670, "E", "BOOTPROG" );

  00306	b9 01 00 00 00	 mov	 ecx, 1
  0030b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  00311	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG193362
  00318	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  0031d	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG193363
  00324	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  00329	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG193364
  00330	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00335	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  0033a	41 b9 03 00 00
	00		 mov	 r9d, 3
  00340	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG193365
  00347	ba ad 03 00 00	 mov	 edx, 941		; 000003adH
  0034c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG193366
  00353	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg
$LN18@lddev_cmd:

; 942  :                 continue;

  00359	e9 5c fd ff ff	 jmp	 $LN5@lddev_cmd

; 943  :             }

  0035e	e9 19 02 00 00	 jmp	 $LN17@lddev_cmd
$LN16@lddev_cmd:

; 944  :             else if(!strcasecmp("br_lba",argv[i]) && (i+1) < argc)

  00363	48 63 44 24 40	 movsxd	 rax, DWORD PTR i$[rsp]
  00368	48 8b 8c 24 c8
	00 00 00	 mov	 rcx, QWORD PTR argv$[rsp]
  00370	48 8b 14 c1	 mov	 rdx, QWORD PTR [rcx+rax*8]
  00374	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG193369
  0037b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__stricmp
  00381	85 c0		 test	 eax, eax
  00383	0f 85 b4 00 00
	00		 jne	 $LN19@lddev_cmd
  00389	8b 44 24 40	 mov	 eax, DWORD PTR i$[rsp]
  0038d	ff c0		 inc	 eax
  0038f	3b 84 24 c0 00
	00 00		 cmp	 eax, DWORD PTR argc$[rsp]
  00396	0f 8d a1 00 00
	00		 jge	 $LN19@lddev_cmd

; 945  :             {
; 946  :                 if(sscanf(argv[++i], "%"SCNx64"%c", &scsi_lddev_brlba[ldind], &c) != 1)

  0039c	8b 44 24 40	 mov	 eax, DWORD PTR i$[rsp]
  003a0	ff c0		 inc	 eax
  003a2	89 44 24 40	 mov	 DWORD PTR i$[rsp], eax
  003a6	48 63 44 24 44	 movsxd	 rax, DWORD PTR ldind$[rsp]
  003ab	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:scsi_lddev_brlba
  003b2	48 8d 04 c1	 lea	 rax, QWORD PTR [rcx+rax*8]
  003b6	48 63 4c 24 40	 movsxd	 rcx, DWORD PTR i$[rsp]
  003bb	4c 8d 4c 24 48	 lea	 r9, QWORD PTR c$[rsp]
  003c0	4c 8b c0	 mov	 r8, rax
  003c3	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG193371
  003ca	48 8b 84 24 c8
	00 00 00	 mov	 rax, QWORD PTR argv$[rsp]
  003d2	48 8b 0c c8	 mov	 rcx, QWORD PTR [rax+rcx*8]
  003d6	e8 00 00 00 00	 call	 sscanf
  003db	83 f8 01	 cmp	 eax, 1
  003de	74 53		 je	 SHORT $LN21@lddev_cmd

; 947  :                     // "Invalid %s"
; 948  :                     WRMSG( HHC00670, "E", "BR_LBA" );

  003e0	b9 01 00 00 00	 mov	 ecx, 1
  003e5	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  003eb	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG193372
  003f2	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  003f7	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG193373
  003fe	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  00403	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG193374
  0040a	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  0040f	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00414	41 b9 03 00 00
	00		 mov	 r9d, 3
  0041a	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG193375
  00421	ba b4 03 00 00	 mov	 edx, 948		; 000003b4H
  00426	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG193376
  0042d	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg
$LN21@lddev_cmd:

; 949  :                 continue;

  00433	e9 82 fc ff ff	 jmp	 $LN5@lddev_cmd

; 950  :             }

  00438	e9 3f 01 00 00	 jmp	 $LN20@lddev_cmd
$LN19@lddev_cmd:

; 951  :             else if(!strcasecmp("scpdata",argv[i]) && (i+1) < argc)

  0043d	48 63 44 24 40	 movsxd	 rax, DWORD PTR i$[rsp]
  00442	48 8b 8c 24 c8
	00 00 00	 mov	 rcx, QWORD PTR argv$[rsp]
  0044a	48 8b 14 c1	 mov	 rdx, QWORD PTR [rcx+rax*8]
  0044e	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG193379
  00455	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__stricmp
  0045b	85 c0		 test	 eax, eax
  0045d	0f 85 a8 00 00
	00		 jne	 $LN22@lddev_cmd
  00463	8b 44 24 40	 mov	 eax, DWORD PTR i$[rsp]
  00467	ff c0		 inc	 eax
  00469	3b 84 24 c0 00
	00 00		 cmp	 eax, DWORD PTR argc$[rsp]
  00470	0f 8d 95 00 00
	00		 jge	 $LN22@lddev_cmd

; 952  :             {
; 953  :                 if(scsi_lddev_scpdata[ldind])

  00476	48 63 44 24 44	 movsxd	 rax, DWORD PTR ldind$[rsp]
  0047b	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:scsi_lddev_scpdata
  00482	48 83 3c c1 00	 cmp	 QWORD PTR [rcx+rax*8], 0
  00487	74 16		 je	 SHORT $LN24@lddev_cmd

; 954  :                     free(scsi_lddev_scpdata[ldind]);

  00489	48 63 44 24 44	 movsxd	 rax, DWORD PTR ldind$[rsp]
  0048e	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:scsi_lddev_scpdata
  00495	48 8b 0c c1	 mov	 rcx, QWORD PTR [rcx+rax*8]
  00499	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free
$LN24@lddev_cmd:

; 955  :                 if(strlen(argv[i+1]))

  0049f	8b 44 24 40	 mov	 eax, DWORD PTR i$[rsp]
  004a3	ff c0		 inc	 eax
  004a5	48 98		 cdqe
  004a7	48 8b 8c 24 c8
	00 00 00	 mov	 rcx, QWORD PTR argv$[rsp]
  004af	48 8b 0c c1	 mov	 rcx, QWORD PTR [rcx+rax*8]
  004b3	e8 00 00 00 00	 call	 strlen
  004b8	48 85 c0	 test	 rax, rax
  004bb	74 33		 je	 SHORT $LN25@lddev_cmd

; 956  :                     scsi_lddev_scpdata[ldind] = (BYTE*)strdup(argv[++i]);

  004bd	8b 44 24 40	 mov	 eax, DWORD PTR i$[rsp]
  004c1	ff c0		 inc	 eax
  004c3	89 44 24 40	 mov	 DWORD PTR i$[rsp], eax
  004c7	48 63 44 24 40	 movsxd	 rax, DWORD PTR i$[rsp]
  004cc	48 8b 8c 24 c8
	00 00 00	 mov	 rcx, QWORD PTR argv$[rsp]
  004d4	48 8b 0c c1	 mov	 rcx, QWORD PTR [rcx+rax*8]
  004d8	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_strdup
  004de	48 63 4c 24 44	 movsxd	 rcx, DWORD PTR ldind$[rsp]
  004e3	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:scsi_lddev_scpdata
  004ea	48 89 04 ca	 mov	 QWORD PTR [rdx+rcx*8], rax
  004ee	eb 14		 jmp	 SHORT $LN26@lddev_cmd
$LN25@lddev_cmd:

; 957  :                 else
; 958  :                     scsi_lddev_scpdata[ldind] = NULL;

  004f0	48 63 44 24 44	 movsxd	 rax, DWORD PTR ldind$[rsp]
  004f5	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:scsi_lddev_scpdata
  004fc	48 c7 04 c1 00
	00 00 00	 mov	 QWORD PTR [rcx+rax*8], 0
$LN26@lddev_cmd:

; 959  :                 continue;

  00504	e9 b1 fb ff ff	 jmp	 $LN5@lddev_cmd

; 960  :             }

  00509	eb 71		 jmp	 SHORT $LN23@lddev_cmd
$LN22@lddev_cmd:

; 961  :             else
; 962  :             {
; 963  :                 // "Invalid option %s"
; 964  :                 WRMSG( HHC00671, "E", argv[i] );

  0050b	48 63 44 24 40	 movsxd	 rax, DWORD PTR i$[rsp]
  00510	48 89 44 24 58	 mov	 QWORD PTR tv316[rsp], rax
  00515	b9 01 00 00 00	 mov	 ecx, 1
  0051a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  00520	48 8b 8c 24 c8
	00 00 00	 mov	 rcx, QWORD PTR argv$[rsp]
  00528	48 8b 54 24 58	 mov	 rdx, QWORD PTR tv316[rsp]
  0052d	48 8b 0c d1	 mov	 rcx, QWORD PTR [rcx+rdx*8]
  00531	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  00536	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG193383
  0053d	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  00542	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG193384
  00549	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  0054e	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00553	41 b9 03 00 00
	00		 mov	 r9d, 3
  00559	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG193385
  00560	ba c4 03 00 00	 mov	 edx, 964		; 000003c4H
  00565	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG193386
  0056c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 965  :                 return -1;

  00572	b8 ff ff ff ff	 mov	 eax, -1
  00577	e9 bc 02 00 00	 jmp	 $LN1@lddev_cmd
$LN23@lddev_cmd:
$LN20@lddev_cmd:
$LN17@lddev_cmd:
$LN14@lddev_cmd:
$LN11@lddev_cmd:

; 966  :             }
; 967  :         }

  0057c	e9 39 fb ff ff	 jmp	 $LN5@lddev_cmd
$LN6@lddev_cmd:

; 968  :     }

  00581	e9 b0 02 00 00	 jmp	 $LN9@lddev_cmd
$LN8@lddev_cmd:

; 969  :     else
; 970  :     {
; 971  :         // "portname %16.16"PRIx64
; 972  :         // "lun      %16.16"PRIx64
; 973  :         // "bootprog %8.8x"
; 974  :         // "br_lba   %16.16"PRIx64
; 975  :         // "scpdata  %s"
; 976  :         if (scsi_lddev_wwpn   [ ldind ]) WRMSG( HHC00680, "I", scsi_lddev_wwpn   [ ldind ] );

  00586	48 63 44 24 44	 movsxd	 rax, DWORD PTR ldind$[rsp]
  0058b	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:scsi_lddev_wwpn
  00592	48 83 3c c1 00	 cmp	 QWORD PTR [rcx+rax*8], 0
  00597	74 70		 je	 SHORT $LN27@lddev_cmd
  00599	48 63 44 24 44	 movsxd	 rax, DWORD PTR ldind$[rsp]
  0059e	48 89 44 24 68	 mov	 QWORD PTR tv333[rsp], rax
  005a3	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:scsi_lddev_wwpn
  005aa	48 89 4c 24 60	 mov	 QWORD PTR tv423[rsp], rcx
  005af	b9 01 00 00 00	 mov	 ecx, 1
  005b4	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  005ba	48 8b 54 24 60	 mov	 rdx, QWORD PTR tv423[rsp]
  005bf	48 8b 4c 24 68	 mov	 rcx, QWORD PTR tv333[rsp]
  005c4	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  005c8	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  005cd	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG193388
  005d4	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  005d9	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG193389
  005e0	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  005e5	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  005ea	41 b9 03 00 00
	00		 mov	 r9d, 3
  005f0	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG193390
  005f7	ba d0 03 00 00	 mov	 edx, 976		; 000003d0H
  005fc	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG193391
  00603	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg
$LN27@lddev_cmd:

; 977  :         if (scsi_lddev_lun    [ ldind ]) WRMSG( HHC00681, "I", scsi_lddev_lun    [ ldind ] );

  00609	48 63 44 24 44	 movsxd	 rax, DWORD PTR ldind$[rsp]
  0060e	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:scsi_lddev_lun
  00615	48 83 3c c1 00	 cmp	 QWORD PTR [rcx+rax*8], 0
  0061a	74 70		 je	 SHORT $LN28@lddev_cmd
  0061c	48 63 44 24 44	 movsxd	 rax, DWORD PTR ldind$[rsp]
  00621	48 89 44 24 78	 mov	 QWORD PTR tv350[rsp], rax
  00626	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:scsi_lddev_lun
  0062d	48 89 4c 24 70	 mov	 QWORD PTR tv425[rsp], rcx
  00632	b9 01 00 00 00	 mov	 ecx, 1
  00637	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  0063d	48 8b 54 24 70	 mov	 rdx, QWORD PTR tv425[rsp]
  00642	48 8b 4c 24 78	 mov	 rcx, QWORD PTR tv350[rsp]
  00647	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  0064b	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  00650	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG193393
  00657	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  0065c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG193394
  00663	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00668	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  0066d	41 b9 03 00 00
	00		 mov	 r9d, 3
  00673	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG193395
  0067a	ba d1 03 00 00	 mov	 edx, 977		; 000003d1H
  0067f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG193396
  00686	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg
$LN28@lddev_cmd:

; 978  :         if (scsi_lddev_prog   [ ldind ]) WRMSG( HHC00682, "I", scsi_lddev_prog   [ ldind ] );

  0068c	48 63 44 24 44	 movsxd	 rax, DWORD PTR ldind$[rsp]
  00691	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:scsi_lddev_prog
  00698	83 3c 81 00	 cmp	 DWORD PTR [rcx+rax*4], 0
  0069c	74 7a		 je	 SHORT $LN29@lddev_cmd
  0069e	48 63 44 24 44	 movsxd	 rax, DWORD PTR ldind$[rsp]
  006a3	48 89 84 24 88
	00 00 00	 mov	 QWORD PTR tv367[rsp], rax
  006ab	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:scsi_lddev_prog
  006b2	48 89 8c 24 80
	00 00 00	 mov	 QWORD PTR tv427[rsp], rcx
  006ba	b9 01 00 00 00	 mov	 ecx, 1
  006bf	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  006c5	48 8b 94 24 80
	00 00 00	 mov	 rdx, QWORD PTR tv427[rsp]
  006cd	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR tv367[rsp]
  006d5	8b 0c 8a	 mov	 ecx, DWORD PTR [rdx+rcx*4]
  006d8	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  006dc	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG193398
  006e3	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  006e8	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG193399
  006ef	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  006f4	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  006f9	41 b9 03 00 00
	00		 mov	 r9d, 3
  006ff	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG193400
  00706	ba d2 03 00 00	 mov	 edx, 978		; 000003d2H
  0070b	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG193401
  00712	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg
$LN29@lddev_cmd:

; 979  :         if (scsi_lddev_brlba  [ ldind ]) WRMSG( HHC00683, "I", scsi_lddev_brlba  [ ldind ] );

  00718	48 63 44 24 44	 movsxd	 rax, DWORD PTR ldind$[rsp]
  0071d	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:scsi_lddev_brlba
  00724	48 83 3c c1 00	 cmp	 QWORD PTR [rcx+rax*8], 0
  00729	74 7c		 je	 SHORT $LN30@lddev_cmd
  0072b	48 63 44 24 44	 movsxd	 rax, DWORD PTR ldind$[rsp]
  00730	48 89 84 24 98
	00 00 00	 mov	 QWORD PTR tv384[rsp], rax
  00738	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:scsi_lddev_brlba
  0073f	48 89 8c 24 90
	00 00 00	 mov	 QWORD PTR tv429[rsp], rcx
  00747	b9 01 00 00 00	 mov	 ecx, 1
  0074c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  00752	48 8b 94 24 90
	00 00 00	 mov	 rdx, QWORD PTR tv429[rsp]
  0075a	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR tv384[rsp]
  00762	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  00766	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  0076b	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG193403
  00772	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  00777	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG193404
  0077e	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00783	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00788	41 b9 03 00 00
	00		 mov	 r9d, 3
  0078e	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG193405
  00795	ba d3 03 00 00	 mov	 edx, 979		; 000003d3H
  0079a	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG193406
  007a1	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg
$LN30@lddev_cmd:

; 980  :         if (scsi_lddev_scpdata[ ldind ]) WRMSG( HHC00684, "I", scsi_lddev_scpdata[ ldind ] );

  007a7	48 63 44 24 44	 movsxd	 rax, DWORD PTR ldind$[rsp]
  007ac	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:scsi_lddev_scpdata
  007b3	48 83 3c c1 00	 cmp	 QWORD PTR [rcx+rax*8], 0
  007b8	74 7c		 je	 SHORT $LN31@lddev_cmd
  007ba	48 63 44 24 44	 movsxd	 rax, DWORD PTR ldind$[rsp]
  007bf	48 89 84 24 a8
	00 00 00	 mov	 QWORD PTR tv401[rsp], rax
  007c7	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:scsi_lddev_scpdata
  007ce	48 89 8c 24 a0
	00 00 00	 mov	 QWORD PTR tv431[rsp], rcx
  007d6	b9 01 00 00 00	 mov	 ecx, 1
  007db	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  007e1	48 8b 94 24 a0
	00 00 00	 mov	 rdx, QWORD PTR tv431[rsp]
  007e9	48 8b 8c 24 a8
	00 00 00	 mov	 rcx, QWORD PTR tv401[rsp]
  007f1	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  007f5	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  007fa	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG193408
  00801	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  00806	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG193409
  0080d	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00812	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00817	41 b9 03 00 00
	00		 mov	 r9d, 3
  0081d	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG193410
  00824	ba d4 03 00 00	 mov	 edx, 980		; 000003d4H
  00829	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG193411
  00830	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg
$LN31@lddev_cmd:
$LN9@lddev_cmd:

; 981  :     }
; 982  :     return 0;

  00836	33 c0		 xor	 eax, eax
$LN1@lddev_cmd:

; 983  : }

  00838	48 81 c4 b8 00
	00 00		 add	 rsp, 184		; 000000b8H
  0083f	c3		 ret	 0
lddev_cmd ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\scescsi.c
_TEXT	SEGMENT
file$ = 80
n$ = 84
c$ = 88
ntf$ = 96
tv137 = 104
tv228 = 112
tv186 = 120
tv190 = 128
tv230 = 136
tv208 = 144
tv212 = 152
argc$ = 176
argv$ = 184
cmdline$ = 192
hwldr_cmd PROC

; 844  : {

$LN26:
  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	89 4c 24 08	 mov	 DWORD PTR [rsp+8], ecx
  0000e	48 81 ec a8 00
	00 00		 sub	 rsp, 168		; 000000a8H
$LN4@hwldr_cmd:

; 845  : struct name2file *ntf;
; 846  : unsigned int file;
; 847  : char c;
; 848  : int n;
; 849  : 
; 850  :     UNREFERENCED(cmdline);

  00015	33 c0		 xor	 eax, eax
  00017	85 c0		 test	 eax, eax
  00019	75 fa		 jne	 SHORT $LN4@hwldr_cmd

; 851  : 
; 852  :     if(argc > 1)

  0001b	83 bc 24 b0 00
	00 00 01	 cmp	 DWORD PTR argc$[rsp], 1
  00023	0f 8e 08 03 00
	00		 jle	 $LN14@hwldr_cmd

; 853  :     {
; 854  :         for(ntf = n2flist; ntf->name && strcasecmp(ntf->name,argv[1]); ntf++);

  00029	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:n2flist
  00030	48 89 44 24 60	 mov	 QWORD PTR ntf$[rsp], rax
  00035	eb 0e		 jmp	 SHORT $LN7@hwldr_cmd
$LN5@hwldr_cmd:
  00037	48 8b 44 24 60	 mov	 rax, QWORD PTR ntf$[rsp]
  0003c	48 83 c0 10	 add	 rax, 16
  00040	48 89 44 24 60	 mov	 QWORD PTR ntf$[rsp], rax
$LN7@hwldr_cmd:
  00045	48 8b 44 24 60	 mov	 rax, QWORD PTR ntf$[rsp]
  0004a	48 83 38 00	 cmp	 QWORD PTR [rax], 0
  0004e	74 29		 je	 SHORT $LN6@hwldr_cmd
  00050	b8 08 00 00 00	 mov	 eax, 8
  00055	48 6b c0 01	 imul	 rax, rax, 1
  00059	48 8b 8c 24 b8
	00 00 00	 mov	 rcx, QWORD PTR argv$[rsp]
  00061	48 8b 14 01	 mov	 rdx, QWORD PTR [rcx+rax]
  00065	48 8b 44 24 60	 mov	 rax, QWORD PTR ntf$[rsp]
  0006a	48 8b 08	 mov	 rcx, QWORD PTR [rax]
  0006d	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__stricmp
  00073	85 c0		 test	 eax, eax
  00075	74 02		 je	 SHORT $LN6@hwldr_cmd
  00077	eb be		 jmp	 SHORT $LN5@hwldr_cmd
$LN6@hwldr_cmd:

; 855  :         file = ntf->file;

  00079	48 8b 44 24 60	 mov	 rax, QWORD PTR ntf$[rsp]
  0007e	8b 40 08	 mov	 eax, DWORD PTR [rax+8]
  00081	89 44 24 50	 mov	 DWORD PTR file$[rsp], eax

; 856  : 
; 857  :         if(!(!ntf->name

  00085	48 8b 44 24 60	 mov	 rax, QWORD PTR ntf$[rsp]
  0008a	48 83 38 00	 cmp	 QWORD PTR [rax], 0
  0008e	0f 85 93 00 00
	00		 jne	 $LN17@hwldr_cmd
  00094	b8 08 00 00 00	 mov	 eax, 8
  00099	48 6b c0 01	 imul	 rax, rax, 1
  0009d	41 b8 04 00 00
	00		 mov	 r8d, 4
  000a3	48 8b 8c 24 b8
	00 00 00	 mov	 rcx, QWORD PTR argv$[rsp]
  000ab	48 8b 14 01	 mov	 rdx, QWORD PTR [rcx+rax]
  000af	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG193294
  000b6	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__strnicmp
  000bc	85 c0		 test	 eax, eax
  000be	75 67		 jne	 SHORT $LN17@hwldr_cmd
  000c0	b8 08 00 00 00	 mov	 eax, 8
  000c5	48 6b c0 01	 imul	 rax, rax, 1
  000c9	48 8b 8c 24 b8
	00 00 00	 mov	 rcx, QWORD PTR argv$[rsp]
  000d1	48 8b 04 01	 mov	 rax, QWORD PTR [rcx+rax]
  000d5	0f be 40 04	 movsx	 eax, BYTE PTR [rax+4]
  000d9	8b c8		 mov	 ecx, eax
  000db	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_isdigit
  000e1	85 c0		 test	 eax, eax
  000e3	74 42		 je	 SHORT $LN17@hwldr_cmd
  000e5	b8 08 00 00 00	 mov	 eax, 8
  000ea	48 6b c0 01	 imul	 rax, rax, 1
  000ee	48 8b 8c 24 b8
	00 00 00	 mov	 rcx, QWORD PTR argv$[rsp]
  000f6	48 8b 04 01	 mov	 rax, QWORD PTR [rcx+rax]
  000fa	48 83 c0 04	 add	 rax, 4
  000fe	4c 8d 4c 24 58	 lea	 r9, QWORD PTR c$[rsp]
  00103	4c 8d 44 24 50	 lea	 r8, QWORD PTR file$[rsp]
  00108	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG193295
  0010f	48 8b c8	 mov	 rcx, rax
  00112	e8 00 00 00 00	 call	 sscanf
  00117	83 f8 01	 cmp	 eax, 1
  0011a	75 0b		 jne	 SHORT $LN17@hwldr_cmd
  0011c	83 7c 24 50 08	 cmp	 DWORD PTR file$[rsp], 8
  00121	0f 82 80 00 00
	00		 jb	 $LN16@hwldr_cmd
$LN17@hwldr_cmd:

; 858  :           && !strncasecmp("type",argv[1],4)
; 859  :           && isdigit(*(argv[1]+4))
; 860  :           && sscanf(argv[1]+4, "%u%c", &file, &c) == 1
; 861  :           && file < HWL_MAXFILETYPE))
; 862  :         {
; 863  :             if(!ntf->name)

  00127	48 8b 44 24 60	 mov	 rax, QWORD PTR ntf$[rsp]
  0012c	48 83 38 00	 cmp	 QWORD PTR [rax], 0
  00130	75 75		 jne	 SHORT $LN18@hwldr_cmd

; 864  :             {
; 865  :                 // "Invalid file %s"
; 866  :                 WRMSG( HHC00657, "E", argv[1] );

  00132	b8 08 00 00 00	 mov	 eax, 8
  00137	48 6b c0 01	 imul	 rax, rax, 1
  0013b	48 89 44 24 68	 mov	 QWORD PTR tv137[rsp], rax
  00140	b9 01 00 00 00	 mov	 ecx, 1
  00145	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  0014b	48 8b 8c 24 b8
	00 00 00	 mov	 rcx, QWORD PTR argv$[rsp]
  00153	48 8b 54 24 68	 mov	 rdx, QWORD PTR tv137[rsp]
  00158	48 8b 0c 11	 mov	 rcx, QWORD PTR [rcx+rdx]
  0015c	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  00161	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG193297
  00168	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  0016d	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG193298
  00174	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00179	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  0017e	41 b9 03 00 00
	00		 mov	 r9d, 3
  00184	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG193299
  0018b	ba 62 03 00 00	 mov	 edx, 866		; 00000362H
  00190	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG193300
  00197	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 867  :                 return -1;

  0019d	b8 ff ff ff ff	 mov	 eax, -1
  001a2	e9 5f 02 00 00	 jmp	 $LN1@hwldr_cmd
$LN18@hwldr_cmd:
$LN16@hwldr_cmd:

; 868  :             }
; 869  :         }
; 870  : 
; 871  :         if(argc > 2)

  001a7	83 bc 24 b0 00
	00 00 02	 cmp	 DWORD PTR argc$[rsp], 2
  001af	0f 8e e3 00 00
	00		 jle	 $LN19@hwldr_cmd

; 872  :         {
; 873  :             for(n = 2; n < argc && file < HWL_MAXFILETYPE; n++, file++)

  001b5	c7 44 24 54 02
	00 00 00	 mov	 DWORD PTR n$[rsp], 2
  001bd	eb 14		 jmp	 SHORT $LN10@hwldr_cmd
$LN8@hwldr_cmd:
  001bf	8b 44 24 54	 mov	 eax, DWORD PTR n$[rsp]
  001c3	ff c0		 inc	 eax
  001c5	89 44 24 54	 mov	 DWORD PTR n$[rsp], eax
  001c9	8b 44 24 50	 mov	 eax, DWORD PTR file$[rsp]
  001cd	ff c0		 inc	 eax
  001cf	89 44 24 50	 mov	 DWORD PTR file$[rsp], eax
$LN10@hwldr_cmd:
  001d3	8b 84 24 b0 00
	00 00		 mov	 eax, DWORD PTR argc$[rsp]
  001da	39 44 24 54	 cmp	 DWORD PTR n$[rsp], eax
  001de	0f 8d af 00 00
	00		 jge	 $LN9@hwldr_cmd
  001e4	83 7c 24 50 08	 cmp	 DWORD PTR file$[rsp], 8
  001e9	0f 83 a4 00 00
	00		 jae	 $LN9@hwldr_cmd

; 874  :             {
; 875  :                 if(hwl_fn[file])

  001ef	8b 44 24 50	 mov	 eax, DWORD PTR file$[rsp]
  001f3	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:hwl_fn
  001fa	48 83 3c c1 00	 cmp	 QWORD PTR [rcx+rax*8], 0
  001ff	74 15		 je	 SHORT $LN21@hwldr_cmd

; 876  :                     free(hwl_fn[file]);

  00201	8b 44 24 50	 mov	 eax, DWORD PTR file$[rsp]
  00205	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:hwl_fn
  0020c	48 8b 0c c1	 mov	 rcx, QWORD PTR [rcx+rax*8]
  00210	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free
$LN21@hwldr_cmd:

; 877  : 
; 878  :                 if(strcasecmp(argv[n],"none") && strlen(argv[n]))

  00216	48 63 44 24 54	 movsxd	 rax, DWORD PTR n$[rsp]
  0021b	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG193306
  00222	48 8b 8c 24 b8
	00 00 00	 mov	 rcx, QWORD PTR argv$[rsp]
  0022a	48 8b 0c c1	 mov	 rcx, QWORD PTR [rcx+rax*8]
  0022e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__stricmp
  00234	85 c0		 test	 eax, eax
  00236	74 43		 je	 SHORT $LN22@hwldr_cmd
  00238	48 63 44 24 54	 movsxd	 rax, DWORD PTR n$[rsp]
  0023d	48 8b 8c 24 b8
	00 00 00	 mov	 rcx, QWORD PTR argv$[rsp]
  00245	48 8b 0c c1	 mov	 rcx, QWORD PTR [rcx+rax*8]
  00249	e8 00 00 00 00	 call	 strlen
  0024e	48 85 c0	 test	 rax, rax
  00251	74 28		 je	 SHORT $LN22@hwldr_cmd

; 879  :                     hwl_fn[file] = strdup(argv[n]);

  00253	48 63 44 24 54	 movsxd	 rax, DWORD PTR n$[rsp]
  00258	48 8b 8c 24 b8
	00 00 00	 mov	 rcx, QWORD PTR argv$[rsp]
  00260	48 8b 0c c1	 mov	 rcx, QWORD PTR [rcx+rax*8]
  00264	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_strdup
  0026a	8b 4c 24 50	 mov	 ecx, DWORD PTR file$[rsp]
  0026e	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:hwl_fn
  00275	48 89 04 ca	 mov	 QWORD PTR [rdx+rcx*8], rax
  00279	eb 13		 jmp	 SHORT $LN23@hwldr_cmd
$LN22@hwldr_cmd:

; 880  :                 else
; 881  :                     hwl_fn[file] = NULL;

  0027b	8b 44 24 50	 mov	 eax, DWORD PTR file$[rsp]
  0027f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:hwl_fn
  00286	48 c7 04 c1 00
	00 00 00	 mov	 QWORD PTR [rcx+rax*8], 0
$LN23@hwldr_cmd:

; 882  :             }

  0028e	e9 2c ff ff ff	 jmp	 $LN8@hwldr_cmd
$LN9@hwldr_cmd:

; 883  :         }

  00293	e9 94 00 00 00	 jmp	 $LN20@hwldr_cmd
$LN19@hwldr_cmd:

; 884  :         else
; 885  :         {
; 886  :             // "%-8s %s"
; 887  :             WRMSG( HHC00660, "I", file2name( file ), hwl_fn[ file ]);

  00298	8b 44 24 50	 mov	 eax, DWORD PTR file$[rsp]
  0029c	48 89 44 24 78	 mov	 QWORD PTR tv186[rsp], rax
  002a1	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:hwl_fn
  002a8	48 89 4c 24 70	 mov	 QWORD PTR tv228[rsp], rcx
  002ad	8b 4c 24 50	 mov	 ecx, DWORD PTR file$[rsp]
  002b1	e8 00 00 00 00	 call	 file2name
  002b6	48 89 84 24 80
	00 00 00	 mov	 QWORD PTR tv190[rsp], rax
  002be	b9 01 00 00 00	 mov	 ecx, 1
  002c3	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  002c9	48 8b 54 24 70	 mov	 rdx, QWORD PTR tv228[rsp]
  002ce	48 8b 4c 24 78	 mov	 rcx, QWORD PTR tv186[rsp]
  002d3	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  002d7	48 89 4c 24 40	 mov	 QWORD PTR [rsp+64], rcx
  002dc	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR tv190[rsp]
  002e4	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  002e9	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG193307
  002f0	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  002f5	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG193308
  002fc	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00301	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00306	41 b9 03 00 00
	00		 mov	 r9d, 3
  0030c	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG193309
  00313	ba 77 03 00 00	 mov	 edx, 887		; 00000377H
  00318	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG193310
  0031f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 888  :             return 0;

  00325	33 c0		 xor	 eax, eax
  00327	e9 da 00 00 00	 jmp	 $LN1@hwldr_cmd
$LN20@hwldr_cmd:

; 889  :         }
; 890  :     }

  0032c	e9 d3 00 00 00	 jmp	 $LN15@hwldr_cmd
$LN14@hwldr_cmd:

; 891  :     else
; 892  :         for(file = 0; file < HWL_MAXFILETYPE; file++)

  00331	c7 44 24 50 00
	00 00 00	 mov	 DWORD PTR file$[rsp], 0
  00339	eb 0a		 jmp	 SHORT $LN13@hwldr_cmd
$LN11@hwldr_cmd:
  0033b	8b 44 24 50	 mov	 eax, DWORD PTR file$[rsp]
  0033f	ff c0		 inc	 eax
  00341	89 44 24 50	 mov	 DWORD PTR file$[rsp], eax
$LN13@hwldr_cmd:
  00345	83 7c 24 50 08	 cmp	 DWORD PTR file$[rsp], 8
  0034a	0f 83 b4 00 00
	00		 jae	 $LN12@hwldr_cmd

; 893  :             if(hwl_fn[file])

  00350	8b 44 24 50	 mov	 eax, DWORD PTR file$[rsp]
  00354	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:hwl_fn
  0035b	48 83 3c c1 00	 cmp	 QWORD PTR [rcx+rax*8], 0
  00360	0f 84 99 00 00
	00		 je	 $LN24@hwldr_cmd

; 894  :                 // "%-8s %s"
; 895  :                 WRMSG( HHC00660, "I", file2name( file ), hwl_fn[ file ]);

  00366	8b 44 24 50	 mov	 eax, DWORD PTR file$[rsp]
  0036a	48 89 84 24 90
	00 00 00	 mov	 QWORD PTR tv208[rsp], rax
  00372	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:hwl_fn
  00379	48 89 8c 24 88
	00 00 00	 mov	 QWORD PTR tv230[rsp], rcx
  00381	8b 4c 24 50	 mov	 ecx, DWORD PTR file$[rsp]
  00385	e8 00 00 00 00	 call	 file2name
  0038a	48 89 84 24 98
	00 00 00	 mov	 QWORD PTR tv212[rsp], rax
  00392	b9 01 00 00 00	 mov	 ecx, 1
  00397	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  0039d	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR tv230[rsp]
  003a5	48 8b 94 24 90
	00 00 00	 mov	 rdx, QWORD PTR tv208[rsp]
  003ad	48 8b 0c d1	 mov	 rcx, QWORD PTR [rcx+rdx*8]
  003b1	48 89 4c 24 40	 mov	 QWORD PTR [rsp+64], rcx
  003b6	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR tv212[rsp]
  003be	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  003c3	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG193312
  003ca	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  003cf	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG193313
  003d6	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  003db	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  003e0	41 b9 03 00 00
	00		 mov	 r9d, 3
  003e6	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG193314
  003ed	ba 7f 03 00 00	 mov	 edx, 895		; 0000037fH
  003f2	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG193315
  003f9	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg
$LN24@hwldr_cmd:
  003ff	e9 37 ff ff ff	 jmp	 $LN11@hwldr_cmd
$LN12@hwldr_cmd:
$LN15@hwldr_cmd:

; 896  : 
; 897  :     return 0;

  00404	33 c0		 xor	 eax, eax
$LN1@hwldr_cmd:

; 898  : }

  00406	48 81 c4 a8 00
	00 00		 add	 rsp, 168		; 000000a8H
  0040d	c3		 ret	 0
hwldr_cmd ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\scescsi.c
_TEXT	SEGMENT
tv65 = 32
p$1 = 40
dev$ = 64
cpu$ = 72
clear$ = 80
ldind$ = 88
load_boot PROC

; 1030 : {

$LN12:
  00000	44 89 4c 24 20	 mov	 DWORD PTR [rsp+32], r9d
  00005	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  0000a	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  0000e	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00013	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 1031 :     switch(sysblk.arch_mode) {

  00017	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  0001e	8b 80 88 00 00
	00		 mov	 eax, DWORD PTR [rax+136]
  00024	89 44 24 20	 mov	 DWORD PTR tv65[rsp], eax
  00028	83 7c 24 20 00	 cmp	 DWORD PTR tv65[rsp], 0
  0002d	74 10		 je	 SHORT $LN7@load_boot
  0002f	83 7c 24 20 01	 cmp	 DWORD PTR tv65[rsp], 1
  00034	74 23		 je	 SHORT $LN8@load_boot
  00036	83 7c 24 20 02	 cmp	 DWORD PTR tv65[rsp], 2
  0003b	74 36		 je	 SHORT $LN9@load_boot
  0003d	eb 4e		 jmp	 SHORT $LN10@load_boot
$LN7@load_boot:

; 1032 : #if defined( _370 )
; 1033 :         case ARCH_370_IDX:
; 1034 :             return s370_load_boot (dev, cpu, clear, ldind);

  0003f	44 8b 4c 24 58	 mov	 r9d, DWORD PTR ldind$[rsp]
  00044	44 8b 44 24 50	 mov	 r8d, DWORD PTR clear$[rsp]
  00049	8b 54 24 48	 mov	 edx, DWORD PTR cpu$[rsp]
  0004d	48 8b 4c 24 40	 mov	 rcx, QWORD PTR dev$[rsp]
  00052	e8 00 00 00 00	 call	 s370_load_boot
  00057	eb 50		 jmp	 SHORT $LN1@load_boot
$LN8@load_boot:

; 1035 : #endif
; 1036 : #if defined( _390 )
; 1037 :         case ARCH_390_IDX:
; 1038 :             return s390_load_boot (dev, cpu, clear, ldind);

  00059	44 8b 4c 24 58	 mov	 r9d, DWORD PTR ldind$[rsp]
  0005e	44 8b 44 24 50	 mov	 r8d, DWORD PTR clear$[rsp]
  00063	8b 54 24 48	 mov	 edx, DWORD PTR cpu$[rsp]
  00067	48 8b 4c 24 40	 mov	 rcx, QWORD PTR dev$[rsp]
  0006c	e8 00 00 00 00	 call	 s390_load_boot
  00071	eb 36		 jmp	 SHORT $LN1@load_boot
$LN9@load_boot:

; 1039 : #endif
; 1040 : #if defined( _900 )
; 1041 :         case ARCH_900_IDX:
; 1042 :             /* z/Arch always starts out in ESA390 mode */
; 1043 :             return s390_load_boot (dev, cpu, clear, ldind);

  00073	44 8b 4c 24 58	 mov	 r9d, DWORD PTR ldind$[rsp]
  00078	44 8b 44 24 50	 mov	 r8d, DWORD PTR clear$[rsp]
  0007d	8b 54 24 48	 mov	 edx, DWORD PTR cpu$[rsp]
  00081	48 8b 4c 24 40	 mov	 rcx, QWORD PTR dev$[rsp]
  00086	e8 00 00 00 00	 call	 s390_load_boot
  0008b	eb 1c		 jmp	 SHORT $LN1@load_boot
$LN10@load_boot:
$LN6@load_boot:

; 1044 : #endif
; 1045 :         default: CRASH();

  0008d	48 c7 44 24 28
	00 00 00 00	 mov	 QWORD PTR p$1[rsp], 0
  00096	48 8b 44 24 28	 mov	 rax, QWORD PTR p$1[rsp]
  0009b	c6 00 00	 mov	 BYTE PTR [rax], 0
  0009e	33 c0		 xor	 eax, eax
  000a0	85 c0		 test	 eax, eax
  000a2	75 e9		 jne	 SHORT $LN6@load_boot

; 1046 :     }
; 1047 :     return -1;

  000a4	b8 ff ff ff ff	 mov	 eax, -1
$LN1@load_boot:

; 1048 : }

  000a9	48 83 c4 38	 add	 rsp, 56			; 00000038H
  000ad	c3		 ret	 0
load_boot ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\scescsi.c
_TEXT	SEGMENT
ct$ = 32
tv128 = 36
dt$ = 40
tv129 = 44
dev$ = 64
support_boot PROC

; 999  : {

$LN9:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 1000 : U32 dt, ct;
; 1001 : 
; 1002 :     ct = dev->devid[1] << 16 | dev->devid[2] << 8 | dev->devid[3];

  00009	b8 01 00 00 00	 mov	 eax, 1
  0000e	48 6b c0 01	 imul	 rax, rax, 1
  00012	48 8b 4c 24 40	 mov	 rcx, QWORD PTR dev$[rsp]
  00017	0f b6 84 01 68
	04 00 00	 movzx	 eax, BYTE PTR [rcx+rax+1128]
  0001f	c1 e0 10	 shl	 eax, 16
  00022	b9 01 00 00 00	 mov	 ecx, 1
  00027	48 6b c9 02	 imul	 rcx, rcx, 2
  0002b	48 8b 54 24 40	 mov	 rdx, QWORD PTR dev$[rsp]
  00030	0f b6 8c 0a 68
	04 00 00	 movzx	 ecx, BYTE PTR [rdx+rcx+1128]
  00038	c1 e1 08	 shl	 ecx, 8
  0003b	0b c1		 or	 eax, ecx
  0003d	b9 01 00 00 00	 mov	 ecx, 1
  00042	48 6b c9 03	 imul	 rcx, rcx, 3
  00046	48 8b 54 24 40	 mov	 rdx, QWORD PTR dev$[rsp]
  0004b	0f b6 8c 0a 68
	04 00 00	 movzx	 ecx, BYTE PTR [rdx+rcx+1128]
  00053	0b c1		 or	 eax, ecx
  00055	89 44 24 20	 mov	 DWORD PTR ct$[rsp], eax

; 1003 :     dt = dev->devid[4] << 16 | dev->devid[5] << 8 | dev->devid[6];

  00059	b8 01 00 00 00	 mov	 eax, 1
  0005e	48 6b c0 04	 imul	 rax, rax, 4
  00062	48 8b 4c 24 40	 mov	 rcx, QWORD PTR dev$[rsp]
  00067	0f b6 84 01 68
	04 00 00	 movzx	 eax, BYTE PTR [rcx+rax+1128]
  0006f	c1 e0 10	 shl	 eax, 16
  00072	b9 01 00 00 00	 mov	 ecx, 1
  00077	48 6b c9 05	 imul	 rcx, rcx, 5
  0007b	48 8b 54 24 40	 mov	 rdx, QWORD PTR dev$[rsp]
  00080	0f b6 8c 0a 68
	04 00 00	 movzx	 ecx, BYTE PTR [rdx+rcx+1128]
  00088	c1 e1 08	 shl	 ecx, 8
  0008b	0b c1		 or	 eax, ecx
  0008d	b9 01 00 00 00	 mov	 ecx, 1
  00092	48 6b c9 06	 imul	 rcx, rcx, 6
  00096	48 8b 54 24 40	 mov	 rdx, QWORD PTR dev$[rsp]
  0009b	0f b6 8c 0a 68
	04 00 00	 movzx	 ecx, BYTE PTR [rdx+rcx+1128]
  000a3	0b c1		 or	 eax, ecx
  000a5	89 44 24 28	 mov	 DWORD PTR dt$[rsp], eax

; 1004 : 
; 1005 :     switch(ct) {

  000a9	8b 44 24 20	 mov	 eax, DWORD PTR ct$[rsp]
  000ad	89 44 24 24	 mov	 DWORD PTR tv128[rsp], eax
  000b1	81 7c 24 24 03
	31 17 00	 cmp	 DWORD PTR tv128[rsp], 1519875 ; 00173103H
  000b9	74 02		 je	 SHORT $LN6@support_bo
  000bb	eb 20		 jmp	 SHORT $LN2@support_bo
$LN6@support_bo:

; 1006 : #if 0
; 1007 :         case 0x173101:
; 1008 :             switch(dt) {
; 1009 :                 case 0x173201: // OSA
; 1010 :                     return validate_boot(7);
; 1011 :             }
; 1012 :             break;
; 1013 : #endif
; 1014 :         case 0x173103:
; 1015 :             switch(dt) {

  000bd	8b 44 24 28	 mov	 eax, DWORD PTR dt$[rsp]
  000c1	89 44 24 2c	 mov	 DWORD PTR tv129[rsp], eax
  000c5	81 7c 24 2c 03
	32 17 00	 cmp	 DWORD PTR tv129[rsp], 1520131 ; 00173203H
  000cd	74 02		 je	 SHORT $LN7@support_bo
  000cf	eb 0c		 jmp	 SHORT $LN4@support_bo
$LN7@support_bo:

; 1016 :                 case 0x173203: // FCP
; 1017 :                     return validate_boot(SCCB_HWL_FILE_SCSIBOOT);

  000d1	b9 02 00 00 00	 mov	 ecx, 2
  000d6	e8 00 00 00 00	 call	 validate_boot
  000db	eb 05		 jmp	 SHORT $LN1@support_bo
$LN4@support_bo:
$LN2@support_bo:

; 1018 :             }
; 1019 :             break;
; 1020 :     }
; 1021 : 
; 1022 :     return -1;

  000dd	b8 ff ff ff ff	 mov	 eax, -1
$LN1@support_bo:

; 1023 : }

  000e2	48 83 c4 38	 add	 rsp, 56			; 00000038H
  000e6	c3		 ret	 0
support_boot ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\scescsi.c
_TEXT	SEGMENT
tv68 = 64
regs$ = 112
s370_sdias_store_status PROC

; 662  : {

$LN11:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	56		 push	 rsi
  00006	57		 push	 rdi
  00007	48 83 ec 58	 sub	 rsp, 88			; 00000058H
$LN4@s370_sdias:

; 663  :     UNREFERENCED(regs);

  0000b	33 c0		 xor	 eax, eax
  0000d	85 c0		 test	 eax, eax
  0000f	75 fa		 jne	 SHORT $LN4@s370_sdias

; 664  : 
; 665  :     sdias_size = sysblk.mainsize < SDIAS_STORE_STATUS_MAXSIZE

  00011	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00018	48 81 b8 90 00
	00 00 00 00 00
	02		 cmp	 QWORD PTR [rax+144], 33554432 ; 02000000H
  00023	73 15		 jae	 SHORT $LN9@s370_sdias
  00025	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  0002c	48 8b 80 90 00
	00 00		 mov	 rax, QWORD PTR [rax+144]
  00033	48 89 44 24 40	 mov	 QWORD PTR tv68[rsp], rax
  00038	eb 09		 jmp	 SHORT $LN10@s370_sdias
$LN9@s370_sdias:
  0003a	48 c7 44 24 40
	00 00 00 02	 mov	 QWORD PTR tv68[rsp], 33554432 ; 02000000H
$LN10@s370_sdias:
  00043	8b 44 24 40	 mov	 eax, DWORD PTR tv68[rsp]
  00047	89 05 00 00 00
	00		 mov	 DWORD PTR sdias_size, eax

; 666  :                ? sysblk.mainsize : SDIAS_STORE_STATUS_MAXSIZE;
; 667  : 
; 668  :     if(!sdias_hsa)

  0004d	48 83 3d 00 00
	00 00 00	 cmp	 QWORD PTR sdias_hsa, 0
  00055	75 12		 jne	 SHORT $LN5@s370_sdias

; 669  :         sdias_hsa = malloc(SDIAS_STORE_STATUS_MAXSIZE);

  00057	b9 00 00 00 02	 mov	 ecx, 33554432		; 02000000H
  0005c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_malloc
  00062	48 89 05 00 00
	00 00		 mov	 QWORD PTR sdias_hsa, rax
$LN5@s370_sdias:

; 670  : 
; 671  :     if(sdias_hsa)

  00069	48 83 3d 00 00
	00 00 00	 cmp	 QWORD PTR sdias_hsa, 0
  00071	74 21		 je	 SHORT $LN6@s370_sdias

; 672  :         memcpy(sdias_hsa,sysblk.mainstor,sdias_size);

  00073	8b 05 00 00 00
	00		 mov	 eax, DWORD PTR sdias_size
  00079	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  00080	48 8b 3d 00 00
	00 00		 mov	 rdi, QWORD PTR sdias_hsa
  00087	48 8b b1 98 00
	00 00		 mov	 rsi, QWORD PTR [rcx+152]
  0008e	8b c8		 mov	 ecx, eax
  00090	f3 a4		 rep movsb
  00092	eb 47		 jmp	 SHORT $LN7@s370_sdias
$LN6@s370_sdias:

; 673  :     else
; 674  :         // "Store Status save to HSA failed"
; 675  :         WRMSG( HHC00655, "E" );

  00094	b9 01 00 00 00	 mov	 ecx, 1
  00099	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  0009f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169677
  000a6	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  000ab	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169678
  000b2	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  000b7	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  000bc	41 b9 03 00 00
	00		 mov	 r9d, 3
  000c2	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG169679
  000c9	ba a3 02 00 00	 mov	 edx, 675		; 000002a3H
  000ce	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169680
  000d5	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg
$LN7@s370_sdias:

; 676  : }

  000db	48 83 c4 58	 add	 rsp, 88			; 00000058H
  000df	5f		 pop	 rdi
  000e0	5e		 pop	 rsi
  000e1	c3		 ret	 0
s370_sdias_store_status ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\scescsi.c
_TEXT	SEGMENT
regs$ = 48
s370_sdias_store_status_clear PROC

; 648  : {

$LN7:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 28	 sub	 rsp, 40			; 00000028H
$LN4@s370_sdias:

; 649  :     UNREFERENCED(regs);

  00009	33 c0		 xor	 eax, eax
  0000b	85 c0		 test	 eax, eax
  0000d	75 fa		 jne	 SHORT $LN4@s370_sdias

; 650  : 
; 651  :     sdias_size = 0;

  0000f	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR sdias_size, 0

; 652  :     if(sdias_hsa)

  00019	48 83 3d 00 00
	00 00 00	 cmp	 QWORD PTR sdias_hsa, 0
  00021	74 0d		 je	 SHORT $LN5@s370_sdias

; 653  :         free(sdias_hsa);

  00023	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR sdias_hsa
  0002a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free
$LN5@s370_sdias:

; 654  :     sdias_hsa = NULL;

  00030	48 c7 05 00 00
	00 00 00 00 00
	00		 mov	 QWORD PTR sdias_hsa, 0

; 655  : }

  0003b	48 83 c4 28	 add	 rsp, 40			; 00000028H
  0003f	c3		 ret	 0
s370_sdias_store_status_clear ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files (x86)\Windows Kits\10\include\10.0.22000.0\ucrt\stdio.h
;	COMDAT sscanf
_TEXT	SEGMENT
_Result$ = 32
_ArgList$ = 40
_Buffer$ = 64
_Format$ = 72
sscanf	PROC						; COMDAT

; 2247 :     {

$LN3:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000f	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00014	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 2248 :         int _Result;
; 2249 :         va_list _ArgList;
; 2250 :         __crt_va_start(_ArgList, _Format);

  00018	48 8d 44 24 50	 lea	 rax, QWORD PTR _Format$[rsp+8]
  0001d	48 89 44 24 28	 mov	 QWORD PTR _ArgList$[rsp], rax

; 2251 :         _Result = _vsscanf_l(_Buffer, _Format, NULL, _ArgList);

  00022	4c 8b 4c 24 28	 mov	 r9, QWORD PTR _ArgList$[rsp]
  00027	45 33 c0	 xor	 r8d, r8d
  0002a	48 8b 54 24 48	 mov	 rdx, QWORD PTR _Format$[rsp]
  0002f	48 8b 4c 24 40	 mov	 rcx, QWORD PTR _Buffer$[rsp]
  00034	e8 00 00 00 00	 call	 _vsscanf_l
  00039	89 44 24 20	 mov	 DWORD PTR _Result$[rsp], eax

; 2252 :         __crt_va_end(_ArgList);

  0003d	48 c7 44 24 28
	00 00 00 00	 mov	 QWORD PTR _ArgList$[rsp], 0

; 2253 :         return _Result;

  00046	8b 44 24 20	 mov	 eax, DWORD PTR _Result$[rsp]

; 2254 :     }

  0004a	48 83 c4 38	 add	 rsp, 56			; 00000038H
  0004e	c3		 ret	 0
sscanf	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files (x86)\Windows Kits\10\include\10.0.22000.0\ucrt\stdio.h
;	COMDAT _vsscanf_l
_TEXT	SEGMENT
_Buffer$ = 64
_Format$ = 72
_Locale$ = 80
_ArgList$ = 88
_vsscanf_l PROC						; COMDAT

; 2152 :     {

$LN3:
  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 2153 :         return __stdio_common_vsscanf(

  00018	e8 00 00 00 00	 call	 __local_stdio_scanf_options
  0001d	48 8b 4c 24 58	 mov	 rcx, QWORD PTR _ArgList$[rsp]
  00022	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00027	48 8b 4c 24 50	 mov	 rcx, QWORD PTR _Locale$[rsp]
  0002c	48 89 4c 24 20	 mov	 QWORD PTR [rsp+32], rcx
  00031	4c 8b 4c 24 48	 mov	 r9, QWORD PTR _Format$[rsp]
  00036	49 c7 c0 ff ff
	ff ff		 mov	 r8, -1
  0003d	48 8b 54 24 40	 mov	 rdx, QWORD PTR _Buffer$[rsp]
  00042	48 8b 08	 mov	 rcx, QWORD PTR [rax]
  00045	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___stdio_common_vsscanf

; 2154 :             _CRT_INTERNAL_LOCAL_SCANF_OPTIONS,
; 2155 :             _Buffer, (size_t)-1, _Format, _Locale, _ArgList);
; 2156 :     }

  0004b	48 83 c4 38	 add	 rsp, 56			; 00000038H
  0004f	c3		 ret	 0
_vsscanf_l ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files (x86)\Windows Kits\10\include\10.0.22000.0\ucrt\stdio.h
;	COMDAT sprintf
_TEXT	SEGMENT
_Result$ = 32
_ArgList$ = 40
_Buffer$ = 64
_Format$ = 72
sprintf	PROC						; COMDAT

; 1771 :     {

$LN3:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000f	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00014	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 1772 :         int _Result;
; 1773 :         va_list _ArgList;
; 1774 :         __crt_va_start(_ArgList, _Format);

  00018	48 8d 44 24 50	 lea	 rax, QWORD PTR _Format$[rsp+8]
  0001d	48 89 44 24 28	 mov	 QWORD PTR _ArgList$[rsp], rax

; 1775 : 
; 1776 :         _Result = _vsprintf_l(_Buffer, _Format, NULL, _ArgList);

  00022	4c 8b 4c 24 28	 mov	 r9, QWORD PTR _ArgList$[rsp]
  00027	45 33 c0	 xor	 r8d, r8d
  0002a	48 8b 54 24 48	 mov	 rdx, QWORD PTR _Format$[rsp]
  0002f	48 8b 4c 24 40	 mov	 rcx, QWORD PTR _Buffer$[rsp]
  00034	e8 00 00 00 00	 call	 _vsprintf_l
  00039	89 44 24 20	 mov	 DWORD PTR _Result$[rsp], eax

; 1777 : 
; 1778 :         __crt_va_end(_ArgList);

  0003d	48 c7 44 24 28
	00 00 00 00	 mov	 QWORD PTR _ArgList$[rsp], 0

; 1779 :         return _Result;

  00046	8b 44 24 20	 mov	 eax, DWORD PTR _Result$[rsp]

; 1780 :     }

  0004a	48 83 c4 38	 add	 rsp, 56			; 00000038H
  0004e	c3		 ret	 0
sprintf	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files (x86)\Windows Kits\10\include\10.0.22000.0\ucrt\stdio.h
;	COMDAT _vsprintf_l
_TEXT	SEGMENT
_Buffer$ = 64
_Format$ = 72
_Locale$ = 80
_ArgList$ = 88
_vsprintf_l PROC					; COMDAT

; 1458 :     {

$LN3:
  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 1459 :         return _vsnprintf_l(_Buffer, (size_t)-1, _Format, _Locale, _ArgList);

  00018	48 8b 44 24 58	 mov	 rax, QWORD PTR _ArgList$[rsp]
  0001d	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00022	4c 8b 4c 24 50	 mov	 r9, QWORD PTR _Locale$[rsp]
  00027	4c 8b 44 24 48	 mov	 r8, QWORD PTR _Format$[rsp]
  0002c	48 c7 c2 ff ff
	ff ff		 mov	 rdx, -1
  00033	48 8b 4c 24 40	 mov	 rcx, QWORD PTR _Buffer$[rsp]
  00038	e8 00 00 00 00	 call	 _vsnprintf_l

; 1460 :     }

  0003d	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00041	c3		 ret	 0
_vsprintf_l ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files (x86)\Windows Kits\10\include\10.0.22000.0\ucrt\stdio.h
;	COMDAT _vsnprintf_l
_TEXT	SEGMENT
_Result$ = 48
tv74 = 52
_Buffer$ = 80
_BufferCount$ = 88
_Format$ = 96
_Locale$ = 104
_ArgList$ = 112
_vsnprintf_l PROC					; COMDAT

; 1391 :     {

$LN5:
  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 1392 :         int const _Result = __stdio_common_vsprintf(

  00018	e8 00 00 00 00	 call	 __local_stdio_printf_options
  0001d	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00020	48 83 c8 01	 or	 rax, 1
  00024	48 8b 4c 24 70	 mov	 rcx, QWORD PTR _ArgList$[rsp]
  00029	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  0002e	48 8b 4c 24 68	 mov	 rcx, QWORD PTR _Locale$[rsp]
  00033	48 89 4c 24 20	 mov	 QWORD PTR [rsp+32], rcx
  00038	4c 8b 4c 24 60	 mov	 r9, QWORD PTR _Format$[rsp]
  0003d	4c 8b 44 24 58	 mov	 r8, QWORD PTR _BufferCount$[rsp]
  00042	48 8b 54 24 50	 mov	 rdx, QWORD PTR _Buffer$[rsp]
  00047	48 8b c8	 mov	 rcx, rax
  0004a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___stdio_common_vsprintf
  00050	89 44 24 30	 mov	 DWORD PTR _Result$[rsp], eax

; 1393 :             _CRT_INTERNAL_LOCAL_PRINTF_OPTIONS | _CRT_INTERNAL_PRINTF_LEGACY_VSPRINTF_NULL_TERMINATION,
; 1394 :             _Buffer, _BufferCount, _Format, _Locale, _ArgList);
; 1395 : 
; 1396 :         return _Result < 0 ? -1 : _Result;

  00054	83 7c 24 30 00	 cmp	 DWORD PTR _Result$[rsp], 0
  00059	7d 0a		 jge	 SHORT $LN3@vsnprintf_
  0005b	c7 44 24 34 ff
	ff ff ff	 mov	 DWORD PTR tv74[rsp], -1
  00063	eb 08		 jmp	 SHORT $LN4@vsnprintf_
$LN3@vsnprintf_:
  00065	8b 44 24 30	 mov	 eax, DWORD PTR _Result$[rsp]
  00069	89 44 24 34	 mov	 DWORD PTR tv74[rsp], eax
$LN4@vsnprintf_:
  0006d	8b 44 24 34	 mov	 eax, DWORD PTR tv74[rsp]

; 1397 :     }

  00071	48 83 c4 48	 add	 rsp, 72			; 00000048H
  00075	c3		 ret	 0
_vsnprintf_l ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files (x86)\Windows Kits\10\include\10.0.22000.0\ucrt\corecrt_stdio_config.h
;	COMDAT __local_stdio_scanf_options
_TEXT	SEGMENT
__local_stdio_scanf_options PROC			; COMDAT

; 101  :         static unsigned __int64 _OptionsStorage;
; 102  :         return &_OptionsStorage;

  00000	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:?_OptionsStorage@?1??__local_stdio_scanf_options@@9@9 ; `__local_stdio_scanf_options'::`2'::_OptionsStorage

; 103  :     }

  00007	c3		 ret	 0
__local_stdio_scanf_options ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files (x86)\Windows Kits\10\include\10.0.22000.0\ucrt\corecrt_stdio_config.h
;	COMDAT __local_stdio_printf_options
_TEXT	SEGMENT
__local_stdio_printf_options PROC			; COMDAT

; 91   :         static unsigned __int64 _OptionsStorage;
; 92   :         return &_OptionsStorage;

  00000	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:?_OptionsStorage@?1??__local_stdio_printf_options@@9@9 ; `__local_stdio_printf_options'::`2'::_OptionsStorage

; 93   :     }

  00007	c3		 ret	 0
__local_stdio_printf_options ENDP
_TEXT	ENDS
END
