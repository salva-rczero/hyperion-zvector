; Listing generated by Microsoft (R) Optimizing Compiler Version 19.34.31937.0 

include listing.inc

INCLUDELIB MSVCRTD
INCLUDELIB OLDNAMES

CONST	SEGMENT
?zeros@?1??s390_add_frr@@9@9	ORG $+256			; `s390_add_frr'::`2'::zeros
CKD_ENDTRK DB	0ffH
	DB	0ffH
	DB	0ffH
	DB	0ffH
	DB	0ffH
	DB	0ffH
	DB	0ffH
	DB	0ffH
	ORG $+8
?zeros@?1??z900_add_frr@@9@9	ORG $+256			; `z900_add_frr'::`2'::zeros
?zeros@?1??s370_add_frr@@9@9	ORG $+256			; `s370_add_frr'::`2'::zeros
CONST	ENDS
PUBLIC	s370_add_frr
PUBLIC	s370_fix_page
PUBLIC	s370_obtain_cms_lock
PUBLIC	s370_obtain_local_lock
PUBLIC	s370_release_cms_lock
PUBLIC	s370_release_local_lock
PUBLIC	s370_svc_assist
PUBLIC	s370_trace_initial_srb_dispatch
PUBLIC	s370_trace_io_interruption
PUBLIC	s370_trace_program_interruption
PUBLIC	s370_trace_svc_interruption
PUBLIC	s370_trace_svc_return
PUBLIC	s370_trace_task_dispatch
PUBLIC	cmpxchg4_x86
PUBLIC	fetch_fw_noswap
PUBLIC	store_fw_noswap
PUBLIC	s370_maddr_l
PUBLIC	s370_vstore4_full
PUBLIC	s370_vfetch4_full
PUBLIC	s370_vstorec
PUBLIC	s370_vstoreb
PUBLIC	s370_vstore4
PUBLIC	s370_vfetchc
PUBLIC	s370_vfetchb
PUBLIC	s370_vfetch4
PUBLIC	s390_add_frr
PUBLIC	s390_obtain_cms_lock
PUBLIC	s390_obtain_local_lock
PUBLIC	s390_release_cms_lock
PUBLIC	s390_release_local_lock
PUBLIC	s390_svc_assist
PUBLIC	s390_maddr_l
PUBLIC	s390_vstore4_full
PUBLIC	s390_vfetch4_full
PUBLIC	s390_vstorec
PUBLIC	s390_vstoreb
PUBLIC	s390_vstore4
PUBLIC	s390_vfetchc
PUBLIC	s390_vfetchb
PUBLIC	s390_vfetch4
PUBLIC	z900_add_frr
PUBLIC	z900_obtain_cms_lock
PUBLIC	z900_obtain_local_lock
PUBLIC	z900_release_cms_lock
PUBLIC	z900_release_local_lock
PUBLIC	z900_svc_assist
PUBLIC	z900_is_per3_event_suppressed
PUBLIC	z900_per3_zero
PUBLIC	z900_per3_zero_xcheck2
PUBLIC	z900_maddr_l
PUBLIC	z900_vstore4_full
PUBLIC	z900_vfetch4_full
PUBLIC	z900_vstorec
PUBLIC	z900_vstoreb
PUBLIC	z900_vstore4
PUBLIC	z900_vfetchc
PUBLIC	z900_vfetchb
PUBLIC	z900_vfetch4
EXTRN	_byteswap_ulong:PROC
EXTRN	longjmp:PROC
EXTRN	__imp_hthread_obtain_lock:PROC
EXTRN	__imp_hthread_release_lock:PROC
EXTRN	__imp_ptt_pthread_trace:PROC
EXTRN	s370_fetch_int_timer:PROC
EXTRN	s370_store_int_timer:PROC
EXTRN	txf_maddr_l:PROC
EXTRN	s370_program_interrupt:PROC
EXTRN	s390_program_interrupt:PROC
EXTRN	z900_program_interrupt:PROC
EXTRN	s370_logical_to_main_l:PROC
EXTRN	s390_logical_to_main_l:PROC
EXTRN	z900_logical_to_main_l:PROC
EXTRN	__GSHandlerCheck:PROC
EXTRN	__security_check_cookie:PROC
EXTRN	__imp_pttclass:QWORD
EXTRN	__security_cookie:QWORD
pdata	SEGMENT
$pdata$s370_add_frr DD imagerel $LN23
	DD	imagerel $LN23+1282
	DD	imagerel $unwind$s370_add_frr
$pdata$s370_fix_page DD imagerel $LN18
	DD	imagerel $LN18+638
	DD	imagerel $unwind$s370_fix_page
$pdata$s370_obtain_cms_lock DD imagerel $LN26
	DD	imagerel $LN26+1171
	DD	imagerel $unwind$s370_obtain_cms_lock
$pdata$s370_obtain_local_lock DD imagerel $LN23
	DD	imagerel $LN23+1068
	DD	imagerel $unwind$s370_obtain_local_lock
$pdata$s370_release_cms_lock DD imagerel $LN31
	DD	imagerel $LN31+1162
	DD	imagerel $unwind$s370_release_cms_lock
$pdata$s370_release_local_lock DD imagerel $LN31
	DD	imagerel $LN31+1183
	DD	imagerel $unwind$s370_release_local_lock
$pdata$s370_svc_assist DD imagerel $LN16
	DD	imagerel $LN16+427
	DD	imagerel $unwind$s370_svc_assist
$pdata$s370_trace_initial_srb_dispatch DD imagerel $LN18
	DD	imagerel $LN18+464
	DD	imagerel $unwind$s370_trace_initial_srb_dispatch
$pdata$s370_trace_io_interruption DD imagerel $LN18
	DD	imagerel $LN18+464
	DD	imagerel $unwind$s370_trace_io_interruption
$pdata$s370_trace_program_interruption DD imagerel $LN18
	DD	imagerel $LN18+464
	DD	imagerel $unwind$s370_trace_program_interruption
$pdata$s370_trace_svc_interruption DD imagerel $LN18
	DD	imagerel $LN18+464
	DD	imagerel $unwind$s370_trace_svc_interruption
$pdata$s370_trace_svc_return DD imagerel $LN18
	DD	imagerel $LN18+464
	DD	imagerel $unwind$s370_trace_svc_return
$pdata$s370_trace_task_dispatch DD imagerel $LN18
	DD	imagerel $LN18+464
	DD	imagerel $unwind$s370_trace_task_dispatch
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$cmpxchg4_x86 DD imagerel $LN5
	DD	imagerel $LN5+102
	DD	imagerel $unwind$cmpxchg4_x86
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$fetch_fw_noswap DD imagerel $LN3
	DD	imagerel $LN3+27
	DD	imagerel $unwind$fetch_fw_noswap
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$s370_maddr_l DD imagerel $LN14
	DD	imagerel $LN14+474
	DD	imagerel $unwind$s370_maddr_l
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$s370_vstore4_full DD imagerel $LN3
	DD	imagerel $LN3+313
	DD	imagerel $unwind$s370_vstore4_full
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$s370_vfetch4_full DD imagerel $LN3
	DD	imagerel $LN3+288
	DD	imagerel $unwind$s370_vfetch4_full
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$s370_vstorec DD imagerel $LN24
	DD	imagerel $LN24+597
	DD	imagerel $unwind$s370_vstorec
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$s370_vstoreb DD imagerel $LN18
	DD	imagerel $LN18+169
	DD	imagerel $unwind$s370_vstoreb
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$s370_vstore4 DD imagerel $LN27
	DD	imagerel $LN27+289
	DD	imagerel $unwind$s370_vstore4
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$s370_vfetchc DD imagerel $LN24
	DD	imagerel $LN24+528
	DD	imagerel $unwind$s370_vfetchc
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$s370_vfetchb DD imagerel $LN18
	DD	imagerel $LN18+160
	DD	imagerel $unwind$s370_vfetchb
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$s370_vfetch4 DD imagerel $LN26
	DD	imagerel $LN26+275
	DD	imagerel $unwind$s370_vfetch4
pdata	ENDS
pdata	SEGMENT
$pdata$s390_add_frr DD imagerel $LN23
	DD	imagerel $LN23+1459
	DD	imagerel $unwind$s390_add_frr
$pdata$s390_obtain_cms_lock DD imagerel $LN26
	DD	imagerel $LN26+1245
	DD	imagerel $unwind$s390_obtain_cms_lock
$pdata$s390_obtain_local_lock DD imagerel $LN23
	DD	imagerel $LN23+1131
	DD	imagerel $unwind$s390_obtain_local_lock
$pdata$s390_release_cms_lock DD imagerel $LN31
	DD	imagerel $LN31+1218
	DD	imagerel $unwind$s390_release_cms_lock
$pdata$s390_release_local_lock DD imagerel $LN31
	DD	imagerel $LN31+1243
	DD	imagerel $unwind$s390_release_local_lock
$pdata$s390_svc_assist DD imagerel $LN16
	DD	imagerel $LN16+447
	DD	imagerel $unwind$s390_svc_assist
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$s390_maddr_l DD imagerel $LN14
	DD	imagerel $LN14+474
	DD	imagerel $unwind$s390_maddr_l
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$s390_vstore4_full DD imagerel $LN3
	DD	imagerel $LN3+321
	DD	imagerel $unwind$s390_vstore4_full
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$s390_vfetch4_full DD imagerel $LN3
	DD	imagerel $LN3+296
	DD	imagerel $unwind$s390_vfetch4_full
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$s390_vstorec DD imagerel $LN9
	DD	imagerel $LN9+498
	DD	imagerel $unwind$s390_vstorec
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$s390_vstoreb DD imagerel $LN3
	DD	imagerel $LN3+89
	DD	imagerel $unwind$s390_vstoreb
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$s390_vstore4 DD imagerel $LN12
	DD	imagerel $LN12+200
	DD	imagerel $unwind$s390_vstore4
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$s390_vfetchc DD imagerel $LN9
	DD	imagerel $LN9+432
	DD	imagerel $unwind$s390_vfetchc
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$s390_vfetchb DD imagerel $LN3
	DD	imagerel $LN3+80
	DD	imagerel $unwind$s390_vfetchb
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$s390_vfetch4 DD imagerel $LN11
	DD	imagerel $LN11+186
	DD	imagerel $unwind$s390_vfetch4
pdata	ENDS
pdata	SEGMENT
$pdata$z900_add_frr DD imagerel $LN23
	DD	imagerel $LN23+1591
	DD	imagerel $unwind$z900_add_frr
$pdata$z900_obtain_cms_lock DD imagerel $LN26
	DD	imagerel $LN26+1357
	DD	imagerel $unwind$z900_obtain_cms_lock
$pdata$z900_obtain_local_lock DD imagerel $LN23
	DD	imagerel $LN23+1235
	DD	imagerel $unwind$z900_obtain_local_lock
$pdata$z900_release_cms_lock DD imagerel $LN31
	DD	imagerel $LN31+1480
	DD	imagerel $unwind$z900_release_cms_lock
$pdata$z900_release_local_lock DD imagerel $LN31
	DD	imagerel $LN31+1516
	DD	imagerel $unwind$z900_release_local_lock
$pdata$z900_svc_assist DD imagerel $LN16
	DD	imagerel $LN16+488
	DD	imagerel $unwind$z900_svc_assist
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$z900_per3_zero DD imagerel $LN12
	DD	imagerel $LN12+215
	DD	imagerel $unwind$z900_per3_zero
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$z900_per3_zero_xcheck2 DD imagerel $LN18
	DD	imagerel $LN18+485
	DD	imagerel $unwind$z900_per3_zero_xcheck2
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$z900_maddr_l DD imagerel $LN18
	DD	imagerel $LN18+657
	DD	imagerel $unwind$z900_maddr_l
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$z900_vstore4_full DD imagerel $LN3
	DD	imagerel $LN3+332
	DD	imagerel $unwind$z900_vstore4_full
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$z900_vfetch4_full DD imagerel $LN3
	DD	imagerel $LN3+307
	DD	imagerel $unwind$z900_vfetch4_full
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$z900_vstorec DD imagerel $LN9
	DD	imagerel $LN9+511
	DD	imagerel $unwind$z900_vstorec
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$z900_vstoreb DD imagerel $LN3
	DD	imagerel $LN3+91
	DD	imagerel $unwind$z900_vstoreb
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$z900_vstore4 DD imagerel $LN12
	DD	imagerel $LN12+209
	DD	imagerel $unwind$z900_vstore4
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$z900_vfetchc DD imagerel $LN9
	DD	imagerel $LN9+445
	DD	imagerel $unwind$z900_vfetchc
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$z900_vfetchb DD imagerel $LN3
	DD	imagerel $LN3+82
	DD	imagerel $unwind$z900_vfetchb
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$z900_vfetch4 DD imagerel $LN11
	DD	imagerel $LN11+195
	DD	imagerel $unwind$z900_vfetch4
pdata	ENDS
_DATA	SEGMENT
$SG169636 DB	'assist.c:139', 00H
	ORG $+3
$SG169637 DB	'*E503 SVCA', 00H
	ORG $+5
$SG169738 DB	'assist.c:268', 00H
	ORG $+3
$SG169746 DB	'assist.c:328', 00H
	ORG $+3
$SG169850 DB	'assist.c:476', 00H
	ORG $+3
$SG169858 DB	'assist.c:531', 00H
	ORG $+3
$SG169892 DB	'assist.c:555', 00H
	ORG $+3
$SG169893 DB	'*E508 TRSVC', 00H
	ORG $+4
$SG169927 DB	'assist.c:578', 00H
	ORG $+3
$SG169928 DB	'*E509 TRPGM', 00H
	ORG $+4
$SG169962 DB	'assist.c:601', 00H
	ORG $+3
$SG169963 DB	'*E50A TRSRB', 00H
	ORG $+4
$SG169997 DB	'assist.c:624', 00H
	ORG $+3
$SG169998 DB	'*E50B TRIO', 00H
	ORG $+5
$SG170032 DB	'assist.c:647', 00H
	ORG $+3
$SG170033 DB	'*E50C TRTSK', 00H
	ORG $+4
$SG170067 DB	'assist.c:670', 00H
	ORG $+3
$SG170068 DB	'*E50D TRRTN', 00H
	ORG $+4
$SG180168 DB	'C:\papa\MyGit\hyperion-zvector\assist.c:139', 00H
	ORG $+4
$SG180169 DB	'*E503 SVCA', 00H
	ORG $+5
$SG180270 DB	'C:\papa\MyGit\hyperion-zvector\assist.c:268', 00H
	ORG $+4
$SG180278 DB	'C:\papa\MyGit\hyperion-zvector\assist.c:328', 00H
	ORG $+4
$SG180382 DB	'C:\papa\MyGit\hyperion-zvector\assist.c:476', 00H
	ORG $+4
$SG180390 DB	'C:\papa\MyGit\hyperion-zvector\assist.c:531', 00H
	ORG $+4
$SG193367 DB	'C:\papa\MyGit\hyperion-zvector\assist.c:139', 00H
	ORG $+4
$SG193368 DB	'*E503 SVCA', 00H
	ORG $+5
$SG193469 DB	'C:\papa\MyGit\hyperion-zvector\assist.c:268', 00H
	ORG $+4
$SG193477 DB	'C:\papa\MyGit\hyperion-zvector\assist.c:328', 00H
	ORG $+4
$SG193581 DB	'C:\papa\MyGit\hyperion-zvector\assist.c:476', 00H
	ORG $+4
$SG193589 DB	'C:\papa\MyGit\hyperion-zvector\assist.c:531', 00H
_DATA	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$z900_vfetch4 DD 011201H
	DD	08212H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$z900_vfetchb DD 011201H
	DD	08212H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$z900_vfetchc DD 031901H
	DD	07015a219H
	DD	06014H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$z900_vstore4 DD 011701H
	DD	08217H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$z900_vstoreb DD 011701H
	DD	08217H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$z900_vstorec DD 031901H
	DD	07015c219H
	DD	06014H
xdata	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DW	01eH
	DW	011fH
voltbl	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$z900_vfetch4_full DD 032319H
	DD	07010a214H
	DD	0600fH
	DD	imagerel __GSHandlerCheck
	DD	048H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$z900_vstore4_full DD 031901H
	DD	07015a219H
	DD	06014H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$z900_maddr_l DD 011801H
	DD	0a218H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$z900_per3_zero_xcheck2 DD 011201H
	DD	0a212H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$z900_per3_zero DD 010901H
	DD	06209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$s390_vfetch4 DD 011101H
	DD	08211H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$s390_vfetchb DD 011101H
	DD	08211H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$s390_vfetchc DD 031901H
	DD	07015a219H
	DD	06014H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$s390_vstore4 DD 011601H
	DD	08216H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$s390_vstoreb DD 011601H
	DD	08216H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$s390_vstorec DD 031901H
	DD	07015c219H
	DD	06014H
xdata	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DW	01dH
	DW	0114H
voltbl	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$s390_vfetch4_full DD 032219H
	DD	0700fa213H
	DD	0600eH
	DD	imagerel __GSHandlerCheck
	DD	048H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$s390_vstore4_full DD 031801H
	DD	07014a218H
	DD	06013H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$s390_maddr_l DD 011701H
	DD	0a217H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$s370_vfetch4 DD 011101H
	DD	0a211H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$s370_vfetchb DD 011101H
	DD	08211H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$s370_vfetchc DD 031901H
	DD	07015a219H
	DD	06014H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$s370_vstore4 DD 011601H
	DD	0a216H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$s370_vstoreb DD 011601H
	DD	08216H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$s370_vstorec DD 031901H
	DD	07015c219H
	DD	06014H
xdata	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DW	01dH
	DW	010cH
voltbl	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$s370_vfetch4_full DD 032219H
	DD	0700fa213H
	DD	0600eH
	DD	imagerel __GSHandlerCheck
	DD	048H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$s370_vstore4_full DD 031801H
	DD	07014a218H
	DD	06013H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$s370_maddr_l DD 011701H
	DD	0a217H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$fetch_fw_noswap DD 010901H
	DD	02209H
xdata	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DB	035H
voltbl	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$cmpxchg4_x86 DD 011201H
	DD	02212H
xdata	ENDS
voltbl	SEGMENT
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:z900_add_frr
	DD	01bH
	DD	061fH
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:s390_add_frr
	DD	01bH
	DD	059eH
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:s370_add_frr
	DD	01bH
	DD	04edH
voltbl	ENDS
xdata	SEGMENT
$unwind$s370_add_frr DD 022019H
	DD	0110111H
	DD	imagerel __GSHandlerCheck
	DD	078H
$unwind$s370_fix_page DD 010e01H
	DD	0820eH
$unwind$s370_obtain_cms_lock DD 021101H
	DD	0110111H
$unwind$s370_obtain_local_lock DD 010e01H
	DD	0e20eH
$unwind$s370_release_cms_lock DD 010e01H
	DD	0c20eH
$unwind$s370_release_local_lock DD 010e01H
	DD	0c20eH
$unwind$s370_svc_assist DD 010e01H
	DD	0c20eH
$unwind$s370_trace_initial_srb_dispatch DD 010e01H
	DD	0c20eH
$unwind$s370_trace_io_interruption DD 010e01H
	DD	0c20eH
$unwind$s370_trace_program_interruption DD 010e01H
	DD	0c20eH
$unwind$s370_trace_svc_interruption DD 010e01H
	DD	0c20eH
$unwind$s370_trace_svc_return DD 010e01H
	DD	0c20eH
$unwind$s370_trace_task_dispatch DD 010e01H
	DD	0c20eH
$unwind$s390_add_frr DD 022019H
	DD	0110111H
	DD	imagerel __GSHandlerCheck
	DD	078H
$unwind$s390_obtain_cms_lock DD 021101H
	DD	0110111H
$unwind$s390_obtain_local_lock DD 010e01H
	DD	0e20eH
$unwind$s390_release_cms_lock DD 010e01H
	DD	0c20eH
$unwind$s390_release_local_lock DD 010e01H
	DD	0c20eH
$unwind$s390_svc_assist DD 010e01H
	DD	0c20eH
$unwind$z900_add_frr DD 022319H
	DD	0170111H
	DD	imagerel __GSHandlerCheck
	DD	0a0H
$unwind$z900_obtain_cms_lock DD 021101H
	DD	0150111H
$unwind$z900_obtain_local_lock DD 021101H
	DD	0130111H
$unwind$z900_release_cms_lock DD 021101H
	DD	0110111H
$unwind$z900_release_local_lock DD 021101H
	DD	0110111H
$unwind$z900_svc_assist DD 010e01H
	DD	0c20eH
xdata	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\vstore.h
;	COMDAT z900_vfetch4
_TEXT	SEGMENT
tv66 = 48
tv72 = 52
mn$1 = 56
addr$ = 80
arn$ = 88
regs$ = 96
z900_vfetch4 PROC					; COMDAT

; 695  : {

$LN11:
  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00009	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000e	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 696  :     if ((likely(!((VADR_L)addr & 0x03))
; 697  :         || (((VADR_L)addr & PAGEFRAME_BYTEMASK) <= (PAGEFRAME_BYTEMASK-3) )))

  00012	48 8b 44 24 50	 mov	 rax, QWORD PTR addr$[rsp]
  00017	48 83 e0 03	 and	 rax, 3
  0001b	48 85 c0	 test	 rax, rax
  0001e	75 0a		 jne	 SHORT $LN5@z900_vfetc
  00020	c7 44 24 30 01
	00 00 00	 mov	 DWORD PTR tv66[rsp], 1
  00028	eb 08		 jmp	 SHORT $LN6@z900_vfetc
$LN5@z900_vfetc:
  0002a	c7 44 24 30 00
	00 00 00	 mov	 DWORD PTR tv66[rsp], 0
$LN6@z900_vfetc:
  00032	83 7c 24 30 00	 cmp	 DWORD PTR tv66[rsp], 0
  00037	74 0a		 je	 SHORT $LN9@z900_vfetc
  00039	c7 44 24 34 01
	00 00 00	 mov	 DWORD PTR tv72[rsp], 1
  00041	eb 08		 jmp	 SHORT $LN10@z900_vfetc
$LN9@z900_vfetc:
  00043	c7 44 24 34 00
	00 00 00	 mov	 DWORD PTR tv72[rsp], 0
$LN10@z900_vfetc:
  0004b	83 7c 24 34 00	 cmp	 DWORD PTR tv72[rsp], 0
  00050	75 13		 jne	 SHORT $LN3@z900_vfetc
  00052	48 8b 44 24 50	 mov	 rax, QWORD PTR addr$[rsp]
  00057	48 25 ff 0f 00
	00		 and	 rax, 4095		; 00000fffH
  0005d	48 3d fc 0f 00
	00		 cmp	 rax, 4092		; 00000ffcH
  00063	77 46		 ja	 SHORT $LN2@z900_vfetc
$LN3@z900_vfetc:

; 698  :     {
; 699  :         BYTE *mn;
; 700  :         ITIMER_SYNC( addr, 4-1, regs );
; 701  :         mn = MADDRL( addr, 4,arn, regs, ACCTYPE_READ, regs->psw.pkey );

  00065	48 8b 44 24 60	 mov	 rax, QWORD PTR regs$[rsp]
  0006a	0f b6 40 79	 movzx	 eax, BYTE PTR [rax+121]
  0006e	88 44 24 28	 mov	 BYTE PTR [rsp+40], al
  00072	c7 44 24 20 04
	00 00 00	 mov	 DWORD PTR [rsp+32], 4
  0007a	4c 8b 4c 24 60	 mov	 r9, QWORD PTR regs$[rsp]
  0007f	44 8b 44 24 58	 mov	 r8d, DWORD PTR arn$[rsp]
  00084	ba 04 00 00 00	 mov	 edx, 4
  00089	48 8b 4c 24 50	 mov	 rcx, QWORD PTR addr$[rsp]
  0008e	e8 00 00 00 00	 call	 z900_maddr_l
  00093	48 89 44 24 38	 mov	 QWORD PTR mn$1[rsp], rax

; 702  :         return fetch_fw( mn );

  00098	48 8b 4c 24 38	 mov	 rcx, QWORD PTR mn$1[rsp]
  0009d	e8 00 00 00 00	 call	 fetch_fw_noswap
  000a2	8b c8		 mov	 ecx, eax
  000a4	e8 00 00 00 00	 call	 _byteswap_ulong
  000a9	eb 13		 jmp	 SHORT $LN1@z900_vfetc
$LN2@z900_vfetc:

; 703  :     }
; 704  :     return ARCH_DEP( vfetch4_full )( addr, arn, regs );

  000ab	4c 8b 44 24 60	 mov	 r8, QWORD PTR regs$[rsp]
  000b0	8b 54 24 58	 mov	 edx, DWORD PTR arn$[rsp]
  000b4	48 8b 4c 24 50	 mov	 rcx, QWORD PTR addr$[rsp]
  000b9	e8 00 00 00 00	 call	 z900_vfetch4_full
$LN1@z900_vfetc:

; 705  : }

  000be	48 83 c4 48	 add	 rsp, 72			; 00000048H
  000c2	c3		 ret	 0
z900_vfetch4 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\vstore.h
;	COMDAT z900_vfetchb
_TEXT	SEGMENT
mn$ = 48
addr$ = 80
arn$ = 88
regs$ = 96
z900_vfetchb PROC					; COMDAT

; 667  : {

$LN3:
  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00009	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000e	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 668  : BYTE   *mn;                             /* Main storage address      */
; 669  : 
; 670  :     ITIMER_SYNC( addr, 1-1, regs );
; 671  :     mn = MADDR( addr, arn, regs, ACCTYPE_READ, regs->psw.pkey );

  00012	48 8b 44 24 60	 mov	 rax, QWORD PTR regs$[rsp]
  00017	0f b6 40 79	 movzx	 eax, BYTE PTR [rax+121]
  0001b	88 44 24 28	 mov	 BYTE PTR [rsp+40], al
  0001f	c7 44 24 20 04
	00 00 00	 mov	 DWORD PTR [rsp+32], 4
  00027	4c 8b 4c 24 60	 mov	 r9, QWORD PTR regs$[rsp]
  0002c	44 8b 44 24 58	 mov	 r8d, DWORD PTR arn$[rsp]
  00031	ba 01 00 00 00	 mov	 edx, 1
  00036	48 8b 4c 24 50	 mov	 rcx, QWORD PTR addr$[rsp]
  0003b	e8 00 00 00 00	 call	 z900_maddr_l
  00040	48 89 44 24 30	 mov	 QWORD PTR mn$[rsp], rax

; 672  :     return *mn;

  00045	48 8b 44 24 30	 mov	 rax, QWORD PTR mn$[rsp]
  0004a	0f b6 00	 movzx	 eax, BYTE PTR [rax]

; 673  : }

  0004d	48 83 c4 48	 add	 rsp, 72			; 00000048H
  00051	c3		 ret	 0
z900_vfetchb ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\vstore.h
;	COMDAT z900_vfetchc
_TEXT	SEGMENT
len2$ = 48
tv76 = 52
main1$ = 56
main2$ = 64
dest$ = 112
len$ = 120
addr$ = 128
arn$ = 136
regs$ = 144
z900_vfetchc PROC					; COMDAT

; 631  : {

$LN9:
  00000	44 89 4c 24 20	 mov	 DWORD PTR [rsp+32], r9d
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	88 54 24 10	 mov	 BYTE PTR [rsp+16], dl
  0000e	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00013	56		 push	 rsi
  00014	57		 push	 rdi
  00015	48 83 ec 58	 sub	 rsp, 88			; 00000058H

; 632  : BYTE   *main1, *main2;                  /* Main storage addresses    */
; 633  : int     len2;                           /* Length to copy on page    */
; 634  : 
; 635  :     if (NOCROSSPAGE( addr, len ))

  00019	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR addr$[rsp]
  00021	48 25 ff 0f 00
	00		 and	 rax, 4095		; 00000fffH
  00027	0f b6 4c 24 78	 movzx	 ecx, BYTE PTR len$[rsp]
  0002c	ba ff 0f 00 00	 mov	 edx, 4095		; 00000fffH
  00031	2b d1		 sub	 edx, ecx
  00033	8b ca		 mov	 ecx, edx
  00035	3b c1		 cmp	 eax, ecx
  00037	7f 0a		 jg	 SHORT $LN7@z900_vfetc
  00039	c7 44 24 34 01
	00 00 00	 mov	 DWORD PTR tv76[rsp], 1
  00041	eb 08		 jmp	 SHORT $LN8@z900_vfetc
$LN7@z900_vfetc:
  00043	c7 44 24 34 00
	00 00 00	 mov	 DWORD PTR tv76[rsp], 0
$LN8@z900_vfetc:
  0004b	83 7c 24 34 00	 cmp	 DWORD PTR tv76[rsp], 0
  00050	74 63		 je	 SHORT $LN2@z900_vfetc

; 636  :     {
; 637  :         ITIMER_SYNC( addr, len, regs );
; 638  :         main1 = MADDRL( addr, len + 1, arn, regs, ACCTYPE_READ, regs->psw.pkey );

  00052	0f b6 44 24 78	 movzx	 eax, BYTE PTR len$[rsp]
  00057	ff c0		 inc	 eax
  00059	48 98		 cdqe
  0005b	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00063	0f b6 49 79	 movzx	 ecx, BYTE PTR [rcx+121]
  00067	88 4c 24 28	 mov	 BYTE PTR [rsp+40], cl
  0006b	c7 44 24 20 04
	00 00 00	 mov	 DWORD PTR [rsp+32], 4
  00073	4c 8b 8c 24 90
	00 00 00	 mov	 r9, QWORD PTR regs$[rsp]
  0007b	44 8b 84 24 88
	00 00 00	 mov	 r8d, DWORD PTR arn$[rsp]
  00083	48 8b d0	 mov	 rdx, rax
  00086	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR addr$[rsp]
  0008e	e8 00 00 00 00	 call	 z900_maddr_l
  00093	48 89 44 24 38	 mov	 QWORD PTR main1$[rsp], rax

; 639  :         memcpy( dest, main1, len + 1 );

  00098	0f b6 44 24 78	 movzx	 eax, BYTE PTR len$[rsp]
  0009d	ff c0		 inc	 eax
  0009f	48 98		 cdqe
  000a1	48 8b 7c 24 70	 mov	 rdi, QWORD PTR dest$[rsp]
  000a6	48 8b 74 24 38	 mov	 rsi, QWORD PTR main1$[rsp]
  000ab	48 8b c8	 mov	 rcx, rax
  000ae	f3 a4		 rep movsb

; 640  :     }

  000b0	e9 01 01 00 00	 jmp	 $LN3@z900_vfetc
$LN2@z900_vfetc:

; 641  :     else
; 642  :     {
; 643  :         len2 = PAGEFRAME_PAGESIZE - (addr & PAGEFRAME_BYTEMASK);

  000b5	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR addr$[rsp]
  000bd	48 25 ff 0f 00
	00		 and	 rax, 4095		; 00000fffH
  000c3	b9 00 10 00 00	 mov	 ecx, 4096		; 00001000H
  000c8	48 2b c8	 sub	 rcx, rax
  000cb	48 8b c1	 mov	 rax, rcx
  000ce	89 44 24 30	 mov	 DWORD PTR len2$[rsp], eax

; 644  :         main1 = MADDRL( addr, len2, arn, regs, ACCTYPE_READ, regs->psw.pkey );

  000d2	48 63 44 24 30	 movsxd	 rax, DWORD PTR len2$[rsp]
  000d7	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  000df	0f b6 49 79	 movzx	 ecx, BYTE PTR [rcx+121]
  000e3	88 4c 24 28	 mov	 BYTE PTR [rsp+40], cl
  000e7	c7 44 24 20 04
	00 00 00	 mov	 DWORD PTR [rsp+32], 4
  000ef	4c 8b 8c 24 90
	00 00 00	 mov	 r9, QWORD PTR regs$[rsp]
  000f7	44 8b 84 24 88
	00 00 00	 mov	 r8d, DWORD PTR arn$[rsp]
  000ff	48 8b d0	 mov	 rdx, rax
  00102	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR addr$[rsp]
  0010a	e8 00 00 00 00	 call	 z900_maddr_l
  0010f	48 89 44 24 38	 mov	 QWORD PTR main1$[rsp], rax

; 645  :         main2 = MADDRL( (addr + len2) & ADDRESS_MAXWRAP( regs ), len + 1 - len2,

  00114	0f b6 44 24 78	 movzx	 eax, BYTE PTR len$[rsp]
  00119	ff c0		 inc	 eax
  0011b	2b 44 24 30	 sub	 eax, DWORD PTR len2$[rsp]
  0011f	48 98		 cdqe
  00121	48 63 4c 24 30	 movsxd	 rcx, DWORD PTR len2$[rsp]
  00126	48 8b 94 24 80
	00 00 00	 mov	 rdx, QWORD PTR addr$[rsp]
  0012e	48 03 d1	 add	 rdx, rcx
  00131	48 8b ca	 mov	 rcx, rdx
  00134	48 8b 94 24 90
	00 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  0013c	48 23 8a 90 00
	00 00		 and	 rcx, QWORD PTR [rdx+144]
  00143	48 8b 94 24 90
	00 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  0014b	0f b6 52 79	 movzx	 edx, BYTE PTR [rdx+121]
  0014f	88 54 24 28	 mov	 BYTE PTR [rsp+40], dl
  00153	c7 44 24 20 04
	00 00 00	 mov	 DWORD PTR [rsp+32], 4
  0015b	4c 8b 8c 24 90
	00 00 00	 mov	 r9, QWORD PTR regs$[rsp]
  00163	44 8b 84 24 88
	00 00 00	 mov	 r8d, DWORD PTR arn$[rsp]
  0016b	48 8b d0	 mov	 rdx, rax
  0016e	e8 00 00 00 00	 call	 z900_maddr_l
  00173	48 89 44 24 40	 mov	 QWORD PTR main2$[rsp], rax

; 646  :                         arn, regs, ACCTYPE_READ, regs->psw.pkey );
; 647  :         memcpy(        dest,        main1,           len2 );

  00178	48 63 44 24 30	 movsxd	 rax, DWORD PTR len2$[rsp]
  0017d	48 8b 7c 24 70	 mov	 rdi, QWORD PTR dest$[rsp]
  00182	48 8b 74 24 38	 mov	 rsi, QWORD PTR main1$[rsp]
  00187	48 8b c8	 mov	 rcx, rax
  0018a	f3 a4		 rep movsb

; 648  :         memcpy( (BYTE*)dest + len2, main2, len + 1 - len2 );

  0018c	0f b6 44 24 78	 movzx	 eax, BYTE PTR len$[rsp]
  00191	ff c0		 inc	 eax
  00193	2b 44 24 30	 sub	 eax, DWORD PTR len2$[rsp]
  00197	48 98		 cdqe
  00199	48 63 4c 24 30	 movsxd	 rcx, DWORD PTR len2$[rsp]
  0019e	48 8b 54 24 70	 mov	 rdx, QWORD PTR dest$[rsp]
  001a3	48 03 d1	 add	 rdx, rcx
  001a6	48 8b ca	 mov	 rcx, rdx
  001a9	48 8b f9	 mov	 rdi, rcx
  001ac	48 8b 74 24 40	 mov	 rsi, QWORD PTR main2$[rsp]
  001b1	48 8b c8	 mov	 rcx, rax
  001b4	f3 a4		 rep movsb
$LN3@z900_vfetc:

; 649  :     }
; 650  : }

  001b6	48 83 c4 58	 add	 rsp, 88			; 00000058H
  001ba	5f		 pop	 rdi
  001bb	5e		 pop	 rsi
  001bc	c3		 ret	 0
z900_vfetchc ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\vstore.h
;	COMDAT z900_vstore4
_TEXT	SEGMENT
tv66 = 48
tv72 = 52
mn$1 = 56
value$ = 80
addr$ = 88
arn$ = 96
regs$ = 104
z900_vstore4 PROC					; COMDAT

; 559  : {

$LN12:
  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	89 4c 24 08	 mov	 DWORD PTR [rsp+8], ecx
  00013	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 560  :     /* Most common case : Aligned & not crossing page boundary */
; 561  :     if (likely(!((VADR_L)addr & 0x03))
; 562  :         || (((VADR_L)addr & PAGEFRAME_BYTEMASK) <= (PAGEFRAME_BYTEMASK-3)))

  00017	48 8b 44 24 58	 mov	 rax, QWORD PTR addr$[rsp]
  0001c	48 83 e0 03	 and	 rax, 3
  00020	48 85 c0	 test	 rax, rax
  00023	75 0a		 jne	 SHORT $LN6@z900_vstor
  00025	c7 44 24 30 01
	00 00 00	 mov	 DWORD PTR tv66[rsp], 1
  0002d	eb 08		 jmp	 SHORT $LN7@z900_vstor
$LN6@z900_vstor:
  0002f	c7 44 24 30 00
	00 00 00	 mov	 DWORD PTR tv66[rsp], 0
$LN7@z900_vstor:
  00037	83 7c 24 30 00	 cmp	 DWORD PTR tv66[rsp], 0
  0003c	74 0a		 je	 SHORT $LN10@z900_vstor
  0003e	c7 44 24 34 01
	00 00 00	 mov	 DWORD PTR tv72[rsp], 1
  00046	eb 08		 jmp	 SHORT $LN11@z900_vstor
$LN10@z900_vstor:
  00048	c7 44 24 34 00
	00 00 00	 mov	 DWORD PTR tv72[rsp], 0
$LN11@z900_vstor:
  00050	83 7c 24 34 00	 cmp	 DWORD PTR tv72[rsp], 0
  00055	75 13		 jne	 SHORT $LN4@z900_vstor
  00057	48 8b 44 24 58	 mov	 rax, QWORD PTR addr$[rsp]
  0005c	48 25 ff 0f 00
	00		 and	 rax, 4095		; 00000fffH
  00062	48 3d fc 0f 00
	00		 cmp	 rax, 4092		; 00000ffcH
  00068	77 4a		 ja	 SHORT $LN2@z900_vstor
$LN4@z900_vstor:

; 563  :     {
; 564  :         BYTE *mn;
; 565  :         mn = MADDRL( addr, 4, arn, regs, ACCTYPE_WRITE, regs->psw.pkey );

  0006a	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  0006f	0f b6 40 79	 movzx	 eax, BYTE PTR [rax+121]
  00073	88 44 24 28	 mov	 BYTE PTR [rsp+40], al
  00077	c7 44 24 20 02
	00 00 00	 mov	 DWORD PTR [rsp+32], 2
  0007f	4c 8b 4c 24 68	 mov	 r9, QWORD PTR regs$[rsp]
  00084	44 8b 44 24 60	 mov	 r8d, DWORD PTR arn$[rsp]
  00089	ba 04 00 00 00	 mov	 edx, 4
  0008e	48 8b 4c 24 58	 mov	 rcx, QWORD PTR addr$[rsp]
  00093	e8 00 00 00 00	 call	 z900_maddr_l
  00098	48 89 44 24 38	 mov	 QWORD PTR mn$1[rsp], rax

; 566  :         STORE_FW( mn, value );

  0009d	8b 4c 24 50	 mov	 ecx, DWORD PTR value$[rsp]
  000a1	e8 00 00 00 00	 call	 _byteswap_ulong
  000a6	8b d0		 mov	 edx, eax
  000a8	48 8b 4c 24 38	 mov	 rcx, QWORD PTR mn$1[rsp]
  000ad	e8 00 00 00 00	 call	 store_fw_noswap

; 567  :         ITIMER_UPDATE( addr, 4-1, regs );
; 568  :     }

  000b2	eb 18		 jmp	 SHORT $LN3@z900_vstor
$LN2@z900_vstor:

; 569  :     else
; 570  :         ARCH_DEP( vstore4_full )( value, addr, arn, regs );

  000b4	4c 8b 4c 24 68	 mov	 r9, QWORD PTR regs$[rsp]
  000b9	44 8b 44 24 60	 mov	 r8d, DWORD PTR arn$[rsp]
  000be	48 8b 54 24 58	 mov	 rdx, QWORD PTR addr$[rsp]
  000c3	8b 4c 24 50	 mov	 ecx, DWORD PTR value$[rsp]
  000c7	e8 00 00 00 00	 call	 z900_vstore4_full
$LN3@z900_vstor:

; 571  : }

  000cc	48 83 c4 48	 add	 rsp, 72			; 00000048H
  000d0	c3		 ret	 0
z900_vstore4 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\vstore.h
;	COMDAT z900_vstoreb
_TEXT	SEGMENT
main1$ = 48
value$ = 80
addr$ = 88
arn$ = 96
regs$ = 104
z900_vstoreb PROC					; COMDAT

; 529  : {

$LN3:
  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	88 4c 24 08	 mov	 BYTE PTR [rsp+8], cl
  00013	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 530  : BYTE   *main1;                          /* Mainstor address          */
; 531  : 
; 532  :     main1 = MADDR( addr, arn, regs, ACCTYPE_WRITE, regs->psw.pkey );

  00017	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  0001c	0f b6 40 79	 movzx	 eax, BYTE PTR [rax+121]
  00020	88 44 24 28	 mov	 BYTE PTR [rsp+40], al
  00024	c7 44 24 20 02
	00 00 00	 mov	 DWORD PTR [rsp+32], 2
  0002c	4c 8b 4c 24 68	 mov	 r9, QWORD PTR regs$[rsp]
  00031	44 8b 44 24 60	 mov	 r8d, DWORD PTR arn$[rsp]
  00036	ba 01 00 00 00	 mov	 edx, 1
  0003b	48 8b 4c 24 58	 mov	 rcx, QWORD PTR addr$[rsp]
  00040	e8 00 00 00 00	 call	 z900_maddr_l
  00045	48 89 44 24 30	 mov	 QWORD PTR main1$[rsp], rax

; 533  :     *main1 = value;

  0004a	48 8b 44 24 30	 mov	 rax, QWORD PTR main1$[rsp]
  0004f	0f b6 4c 24 50	 movzx	 ecx, BYTE PTR value$[rsp]
  00054	88 08		 mov	 BYTE PTR [rax], cl

; 534  :     ITIMER_UPDATE( addr, 1-1, regs );
; 535  : }

  00056	48 83 c4 48	 add	 rsp, 72			; 00000048H
  0005a	c3		 ret	 0
z900_vstoreb ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\vstore.h
;	COMDAT z900_vstorec
_TEXT	SEGMENT
len2$ = 48
tv76 = 52
sk$ = 56
tv83 = 64
main1$ = 72
main2$ = 80
src$ = 128
len$ = 136
addr$ = 144
arn$ = 152
regs$ = 160
z900_vstorec PROC					; COMDAT

; 489  : {

$LN9:
  00000	44 89 4c 24 20	 mov	 DWORD PTR [rsp+32], r9d
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	88 54 24 10	 mov	 BYTE PTR [rsp+16], dl
  0000e	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00013	56		 push	 rsi
  00014	57		 push	 rdi
  00015	48 83 ec 68	 sub	 rsp, 104		; 00000068H

; 490  : BYTE   *main1, *main2;                  /* Mainstor addresses        */
; 491  : BYTE   *sk;                             /* Storage key addresses     */
; 492  : int     len2;                           /* Length to end of page     */
; 493  : 
; 494  :     if (NOCROSSPAGE( addr,len ))

  00019	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR addr$[rsp]
  00021	48 25 ff 0f 00
	00		 and	 rax, 4095		; 00000fffH
  00027	0f b6 8c 24 88
	00 00 00	 movzx	 ecx, BYTE PTR len$[rsp]
  0002f	ba ff 0f 00 00	 mov	 edx, 4095		; 00000fffH
  00034	2b d1		 sub	 edx, ecx
  00036	8b ca		 mov	 ecx, edx
  00038	3b c1		 cmp	 eax, ecx
  0003a	7f 0a		 jg	 SHORT $LN7@z900_vstor
  0003c	c7 44 24 34 01
	00 00 00	 mov	 DWORD PTR tv76[rsp], 1
  00044	eb 08		 jmp	 SHORT $LN8@z900_vstor
$LN7@z900_vstor:
  00046	c7 44 24 34 00
	00 00 00	 mov	 DWORD PTR tv76[rsp], 0
$LN8@z900_vstor:
  0004e	83 7c 24 34 00	 cmp	 DWORD PTR tv76[rsp], 0
  00053	74 70		 je	 SHORT $LN2@z900_vstor

; 495  :     {
; 496  :         memcpy( MADDRL( addr, len+1, arn, regs, ACCTYPE_WRITE, regs->psw.pkey ),

  00055	0f b6 84 24 88
	00 00 00	 movzx	 eax, BYTE PTR len$[rsp]
  0005d	ff c0		 inc	 eax
  0005f	48 98		 cdqe
  00061	48 89 44 24 40	 mov	 QWORD PTR tv83[rsp], rax
  00066	0f b6 8c 24 88
	00 00 00	 movzx	 ecx, BYTE PTR len$[rsp]
  0006e	ff c1		 inc	 ecx
  00070	48 63 c9	 movsxd	 rcx, ecx
  00073	48 8b 94 24 a0
	00 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  0007b	0f b6 52 79	 movzx	 edx, BYTE PTR [rdx+121]
  0007f	88 54 24 28	 mov	 BYTE PTR [rsp+40], dl
  00083	c7 44 24 20 02
	00 00 00	 mov	 DWORD PTR [rsp+32], 2
  0008b	4c 8b 8c 24 a0
	00 00 00	 mov	 r9, QWORD PTR regs$[rsp]
  00093	44 8b 84 24 98
	00 00 00	 mov	 r8d, DWORD PTR arn$[rsp]
  0009b	48 8b d1	 mov	 rdx, rcx
  0009e	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR addr$[rsp]
  000a6	e8 00 00 00 00	 call	 z900_maddr_l
  000ab	48 8b f8	 mov	 rdi, rax
  000ae	48 8b b4 24 80
	00 00 00	 mov	 rsi, QWORD PTR src$[rsp]
  000b6	48 8b 44 24 40	 mov	 rax, QWORD PTR tv83[rsp]
  000bb	48 8b c8	 mov	 rcx, rax
  000be	f3 a4		 rep movsb

; 497  :                src, len + 1);
; 498  :         ITIMER_UPDATE( addr, len, regs );
; 499  :     }

  000c0	e9 33 01 00 00	 jmp	 $LN3@z900_vstor
$LN2@z900_vstor:

; 500  :     else
; 501  :     {
; 502  :         len2 = PAGEFRAME_PAGESIZE - (addr & PAGEFRAME_BYTEMASK);

  000c5	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR addr$[rsp]
  000cd	48 25 ff 0f 00
	00		 and	 rax, 4095		; 00000fffH
  000d3	b9 00 10 00 00	 mov	 ecx, 4096		; 00001000H
  000d8	48 2b c8	 sub	 rcx, rax
  000db	48 8b c1	 mov	 rax, rcx
  000de	89 44 24 30	 mov	 DWORD PTR len2$[rsp], eax

; 503  :         main1 = MADDRL( addr, len2, arn, regs, ACCTYPE_WRITE_SKP,

  000e2	48 63 44 24 30	 movsxd	 rax, DWORD PTR len2$[rsp]
  000e7	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  000ef	0f b6 49 79	 movzx	 ecx, BYTE PTR [rcx+121]
  000f3	88 4c 24 28	 mov	 BYTE PTR [rsp+40], cl
  000f7	c7 44 24 20 01
	00 00 00	 mov	 DWORD PTR [rsp+32], 1
  000ff	4c 8b 8c 24 a0
	00 00 00	 mov	 r9, QWORD PTR regs$[rsp]
  00107	44 8b 84 24 98
	00 00 00	 mov	 r8d, DWORD PTR arn$[rsp]
  0010f	48 8b d0	 mov	 rdx, rax
  00112	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR addr$[rsp]
  0011a	e8 00 00 00 00	 call	 z900_maddr_l
  0011f	48 89 44 24 48	 mov	 QWORD PTR main1$[rsp], rax

; 504  :                         regs->psw.pkey );
; 505  :         sk = regs->dat.storkey;

  00124	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0012c	48 8b 80 28 08
	00 00		 mov	 rax, QWORD PTR [rax+2088]
  00133	48 89 44 24 38	 mov	 QWORD PTR sk$[rsp], rax

; 506  :         main2 = MADDRL( (addr + len2) & ADDRESS_MAXWRAP( regs ),

  00138	0f b6 84 24 88
	00 00 00	 movzx	 eax, BYTE PTR len$[rsp]
  00140	ff c0		 inc	 eax
  00142	2b 44 24 30	 sub	 eax, DWORD PTR len2$[rsp]
  00146	48 98		 cdqe
  00148	48 63 4c 24 30	 movsxd	 rcx, DWORD PTR len2$[rsp]
  0014d	48 8b 94 24 90
	00 00 00	 mov	 rdx, QWORD PTR addr$[rsp]
  00155	48 03 d1	 add	 rdx, rcx
  00158	48 8b ca	 mov	 rcx, rdx
  0015b	48 8b 94 24 a0
	00 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  00163	48 23 8a 90 00
	00 00		 and	 rcx, QWORD PTR [rdx+144]
  0016a	48 8b 94 24 a0
	00 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  00172	0f b6 52 79	 movzx	 edx, BYTE PTR [rdx+121]
  00176	88 54 24 28	 mov	 BYTE PTR [rsp+40], dl
  0017a	c7 44 24 20 02
	00 00 00	 mov	 DWORD PTR [rsp+32], 2
  00182	4c 8b 8c 24 a0
	00 00 00	 mov	 r9, QWORD PTR regs$[rsp]
  0018a	44 8b 84 24 98
	00 00 00	 mov	 r8d, DWORD PTR arn$[rsp]
  00192	48 8b d0	 mov	 rdx, rax
  00195	e8 00 00 00 00	 call	 z900_maddr_l
  0019a	48 89 44 24 50	 mov	 QWORD PTR main2$[rsp], rax

; 507  :                         len+1-len2, arn,
; 508  :                         regs, ACCTYPE_WRITE, regs->psw.pkey );
; 509  :         *sk |= (STORKEY_REF | STORKEY_CHANGE);

  0019f	48 8b 44 24 38	 mov	 rax, QWORD PTR sk$[rsp]
  001a4	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  001a7	83 c8 06	 or	 eax, 6
  001aa	48 8b 4c 24 38	 mov	 rcx, QWORD PTR sk$[rsp]
  001af	88 01		 mov	 BYTE PTR [rcx], al

; 510  :         memcpy( main1, src, len2 );

  001b1	48 63 44 24 30	 movsxd	 rax, DWORD PTR len2$[rsp]
  001b6	48 8b 7c 24 48	 mov	 rdi, QWORD PTR main1$[rsp]
  001bb	48 8b b4 24 80
	00 00 00	 mov	 rsi, QWORD PTR src$[rsp]
  001c3	48 8b c8	 mov	 rcx, rax
  001c6	f3 a4		 rep movsb

; 511  :         memcpy( main2, (BYTE*)src + len2, len + 1 - len2 );

  001c8	0f b6 84 24 88
	00 00 00	 movzx	 eax, BYTE PTR len$[rsp]
  001d0	ff c0		 inc	 eax
  001d2	2b 44 24 30	 sub	 eax, DWORD PTR len2$[rsp]
  001d6	48 98		 cdqe
  001d8	48 63 4c 24 30	 movsxd	 rcx, DWORD PTR len2$[rsp]
  001dd	48 8b 94 24 80
	00 00 00	 mov	 rdx, QWORD PTR src$[rsp]
  001e5	48 03 d1	 add	 rdx, rcx
  001e8	48 8b ca	 mov	 rcx, rdx
  001eb	48 8b 7c 24 50	 mov	 rdi, QWORD PTR main2$[rsp]
  001f0	48 8b f1	 mov	 rsi, rcx
  001f3	48 8b c8	 mov	 rcx, rax
  001f6	f3 a4		 rep movsb
$LN3@z900_vstor:

; 512  :     }
; 513  : }

  001f8	48 83 c4 68	 add	 rsp, 104		; 00000068H
  001fc	5f		 pop	 rdi
  001fd	5e		 pop	 rsi
  001fe	c3		 ret	 0
z900_vstorec ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\vstore.h
;	COMDAT z900_vfetch4_full
_TEXT	SEGMENT
len$ = 48
mn$ = 56
temp$ = 64
__$ArrayPad$ = 72
addr$ = 112
arn$ = 120
regs$ = 128
z900_vfetch4_full PROC					; COMDAT

; 428  : {

$LN3:
  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00009	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000e	56		 push	 rsi
  0000f	57		 push	 rdi
  00010	48 83 ec 58	 sub	 rsp, 88			; 00000058H
  00014	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  0001b	48 33 c4	 xor	 rax, rsp
  0001e	48 89 44 24 48	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 429  : BYTE   *mn;                             /* Main storage addresses    */
; 430  : int     len;                            /* Length to end of page     */
; 431  : BYTE    temp[8];                        /* Copy destination          */
; 432  : 
; 433  :     len = PAGEFRAME_PAGESIZE - (addr & PAGEFRAME_BYTEMASK);

  00023	48 8b 44 24 70	 mov	 rax, QWORD PTR addr$[rsp]
  00028	48 25 ff 0f 00
	00		 and	 rax, 4095		; 00000fffH
  0002e	b9 00 10 00 00	 mov	 ecx, 4096		; 00001000H
  00033	48 2b c8	 sub	 rcx, rax
  00036	48 8b c1	 mov	 rax, rcx
  00039	89 44 24 30	 mov	 DWORD PTR len$[rsp], eax

; 434  :     mn = MADDRL( addr, len, arn, regs, ACCTYPE_READ, regs->psw.pkey );

  0003d	48 63 44 24 30	 movsxd	 rax, DWORD PTR len$[rsp]
  00042	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0004a	0f b6 49 79	 movzx	 ecx, BYTE PTR [rcx+121]
  0004e	88 4c 24 28	 mov	 BYTE PTR [rsp+40], cl
  00052	c7 44 24 20 04
	00 00 00	 mov	 DWORD PTR [rsp+32], 4
  0005a	4c 8b 8c 24 80
	00 00 00	 mov	 r9, QWORD PTR regs$[rsp]
  00062	44 8b 44 24 78	 mov	 r8d, DWORD PTR arn$[rsp]
  00067	48 8b d0	 mov	 rdx, rax
  0006a	48 8b 4c 24 70	 mov	 rcx, QWORD PTR addr$[rsp]
  0006f	e8 00 00 00 00	 call	 z900_maddr_l
  00074	48 89 44 24 38	 mov	 QWORD PTR mn$[rsp], rax

; 435  :     memcpy( temp, mn, len);

  00079	48 63 44 24 30	 movsxd	 rax, DWORD PTR len$[rsp]
  0007e	48 8d 4c 24 40	 lea	 rcx, QWORD PTR temp$[rsp]
  00083	48 8b f9	 mov	 rdi, rcx
  00086	48 8b 74 24 38	 mov	 rsi, QWORD PTR mn$[rsp]
  0008b	48 8b c8	 mov	 rcx, rax
  0008e	f3 a4		 rep movsb

; 436  :     mn = MADDRL( (addr + len) & ADDRESS_MAXWRAP( regs ), 4 - len, arn, regs,

  00090	b8 04 00 00 00	 mov	 eax, 4
  00095	2b 44 24 30	 sub	 eax, DWORD PTR len$[rsp]
  00099	48 98		 cdqe
  0009b	48 63 4c 24 30	 movsxd	 rcx, DWORD PTR len$[rsp]
  000a0	48 8b 54 24 70	 mov	 rdx, QWORD PTR addr$[rsp]
  000a5	48 03 d1	 add	 rdx, rcx
  000a8	48 8b ca	 mov	 rcx, rdx
  000ab	48 8b 94 24 80
	00 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  000b3	48 23 8a 90 00
	00 00		 and	 rcx, QWORD PTR [rdx+144]
  000ba	48 8b 94 24 80
	00 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  000c2	0f b6 52 79	 movzx	 edx, BYTE PTR [rdx+121]
  000c6	88 54 24 28	 mov	 BYTE PTR [rsp+40], dl
  000ca	c7 44 24 20 04
	00 00 00	 mov	 DWORD PTR [rsp+32], 4
  000d2	4c 8b 8c 24 80
	00 00 00	 mov	 r9, QWORD PTR regs$[rsp]
  000da	44 8b 44 24 78	 mov	 r8d, DWORD PTR arn$[rsp]
  000df	48 8b d0	 mov	 rdx, rax
  000e2	e8 00 00 00 00	 call	 z900_maddr_l
  000e7	48 89 44 24 38	 mov	 QWORD PTR mn$[rsp], rax

; 437  :                   ACCTYPE_READ, regs->psw.pkey );
; 438  :     memcpy( temp+len, mn, 4 - len);

  000ec	b8 04 00 00 00	 mov	 eax, 4
  000f1	2b 44 24 30	 sub	 eax, DWORD PTR len$[rsp]
  000f5	48 98		 cdqe
  000f7	48 63 4c 24 30	 movsxd	 rcx, DWORD PTR len$[rsp]
  000fc	48 8d 4c 0c 40	 lea	 rcx, QWORD PTR temp$[rsp+rcx]
  00101	48 8b f9	 mov	 rdi, rcx
  00104	48 8b 74 24 38	 mov	 rsi, QWORD PTR mn$[rsp]
  00109	48 8b c8	 mov	 rcx, rax
  0010c	f3 a4		 rep movsb

; 439  :     return fetch_fw( temp );

  0010e	48 8d 4c 24 40	 lea	 rcx, QWORD PTR temp$[rsp]
  00113	e8 00 00 00 00	 call	 fetch_fw_noswap
  00118	8b c8		 mov	 ecx, eax
  0011a	e8 00 00 00 00	 call	 _byteswap_ulong

; 440  : }

  0011f	48 8b 4c 24 48	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  00124	48 33 cc	 xor	 rcx, rsp
  00127	e8 00 00 00 00	 call	 __security_check_cookie
  0012c	48 83 c4 58	 add	 rsp, 88			; 00000058H
  00130	5f		 pop	 rdi
  00131	5e		 pop	 rsi
  00132	c3		 ret	 0
z900_vfetch4_full ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\vstore.h
;	COMDAT z900_vstore4_full
_TEXT	SEGMENT
len$ = 48
temp$ = 52
sk$ = 56
main1$ = 64
main2$ = 72
value$ = 112
addr$ = 120
arn$ = 128
regs$ = 136
z900_vstore4_full PROC					; COMDAT

; 335  : {

$LN3:
  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	89 4c 24 08	 mov	 DWORD PTR [rsp+8], ecx
  00013	56		 push	 rsi
  00014	57		 push	 rdi
  00015	48 83 ec 58	 sub	 rsp, 88			; 00000058H

; 336  : BYTE   *main1, *main2;                  /* Mainstor addresses        */
; 337  : BYTE   *sk;                             /* Storage key addresses     */
; 338  : int     len;                            /* Length to end of page     */
; 339  : BYTE    temp[4];                        /* Copied value              */
; 340  : 
; 341  :     len = PAGEFRAME_PAGESIZE - (addr & PAGEFRAME_BYTEMASK);

  00019	48 8b 44 24 78	 mov	 rax, QWORD PTR addr$[rsp]
  0001e	48 25 ff 0f 00
	00		 and	 rax, 4095		; 00000fffH
  00024	b9 00 10 00 00	 mov	 ecx, 4096		; 00001000H
  00029	48 2b c8	 sub	 rcx, rax
  0002c	48 8b c1	 mov	 rax, rcx
  0002f	89 44 24 30	 mov	 DWORD PTR len$[rsp], eax

; 342  :     main1 = MADDRL( addr, len, arn, regs, ACCTYPE_WRITE_SKP, regs->psw.pkey );

  00033	48 63 44 24 30	 movsxd	 rax, DWORD PTR len$[rsp]
  00038	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00040	0f b6 49 79	 movzx	 ecx, BYTE PTR [rcx+121]
  00044	88 4c 24 28	 mov	 BYTE PTR [rsp+40], cl
  00048	c7 44 24 20 01
	00 00 00	 mov	 DWORD PTR [rsp+32], 1
  00050	4c 8b 8c 24 88
	00 00 00	 mov	 r9, QWORD PTR regs$[rsp]
  00058	44 8b 84 24 80
	00 00 00	 mov	 r8d, DWORD PTR arn$[rsp]
  00060	48 8b d0	 mov	 rdx, rax
  00063	48 8b 4c 24 78	 mov	 rcx, QWORD PTR addr$[rsp]
  00068	e8 00 00 00 00	 call	 z900_maddr_l
  0006d	48 89 44 24 40	 mov	 QWORD PTR main1$[rsp], rax

; 343  :     sk = regs->dat.storkey;

  00072	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0007a	48 8b 80 28 08
	00 00		 mov	 rax, QWORD PTR [rax+2088]
  00081	48 89 44 24 38	 mov	 QWORD PTR sk$[rsp], rax

; 344  :     main2 = MADDRL( (addr + len) & ADDRESS_MAXWRAP( regs ), 4-len, arn, regs,

  00086	b8 04 00 00 00	 mov	 eax, 4
  0008b	2b 44 24 30	 sub	 eax, DWORD PTR len$[rsp]
  0008f	48 98		 cdqe
  00091	48 63 4c 24 30	 movsxd	 rcx, DWORD PTR len$[rsp]
  00096	48 8b 54 24 78	 mov	 rdx, QWORD PTR addr$[rsp]
  0009b	48 03 d1	 add	 rdx, rcx
  0009e	48 8b ca	 mov	 rcx, rdx
  000a1	48 8b 94 24 88
	00 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  000a9	48 23 8a 90 00
	00 00		 and	 rcx, QWORD PTR [rdx+144]
  000b0	48 8b 94 24 88
	00 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  000b8	0f b6 52 79	 movzx	 edx, BYTE PTR [rdx+121]
  000bc	88 54 24 28	 mov	 BYTE PTR [rsp+40], dl
  000c0	c7 44 24 20 02
	00 00 00	 mov	 DWORD PTR [rsp+32], 2
  000c8	4c 8b 8c 24 88
	00 00 00	 mov	 r9, QWORD PTR regs$[rsp]
  000d0	44 8b 84 24 80
	00 00 00	 mov	 r8d, DWORD PTR arn$[rsp]
  000d8	48 8b d0	 mov	 rdx, rax
  000db	e8 00 00 00 00	 call	 z900_maddr_l
  000e0	48 89 44 24 48	 mov	 QWORD PTR main2$[rsp], rax

; 345  :                     ACCTYPE_WRITE, regs->psw.pkey );
; 346  :     *sk |= (STORKEY_REF | STORKEY_CHANGE);

  000e5	48 8b 44 24 38	 mov	 rax, QWORD PTR sk$[rsp]
  000ea	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  000ed	83 c8 06	 or	 eax, 6
  000f0	48 8b 4c 24 38	 mov	 rcx, QWORD PTR sk$[rsp]
  000f5	88 01		 mov	 BYTE PTR [rcx], al

; 347  :     STORE_FW( temp, value );

  000f7	8b 4c 24 70	 mov	 ecx, DWORD PTR value$[rsp]
  000fb	e8 00 00 00 00	 call	 _byteswap_ulong
  00100	8b d0		 mov	 edx, eax
  00102	48 8d 4c 24 34	 lea	 rcx, QWORD PTR temp$[rsp]
  00107	e8 00 00 00 00	 call	 store_fw_noswap

; 348  :     memcpy( main1, temp,       len );

  0010c	48 63 44 24 30	 movsxd	 rax, DWORD PTR len$[rsp]
  00111	48 8d 4c 24 34	 lea	 rcx, QWORD PTR temp$[rsp]
  00116	48 8b 7c 24 40	 mov	 rdi, QWORD PTR main1$[rsp]
  0011b	48 8b f1	 mov	 rsi, rcx
  0011e	48 8b c8	 mov	 rcx, rax
  00121	f3 a4		 rep movsb

; 349  :     memcpy( main2, temp+len, 4-len );

  00123	b8 04 00 00 00	 mov	 eax, 4
  00128	2b 44 24 30	 sub	 eax, DWORD PTR len$[rsp]
  0012c	48 98		 cdqe
  0012e	48 63 4c 24 30	 movsxd	 rcx, DWORD PTR len$[rsp]
  00133	48 8d 4c 0c 34	 lea	 rcx, QWORD PTR temp$[rsp+rcx]
  00138	48 8b 7c 24 48	 mov	 rdi, QWORD PTR main2$[rsp]
  0013d	48 8b f1	 mov	 rsi, rcx
  00140	48 8b c8	 mov	 rcx, rax
  00143	f3 a4		 rep movsb

; 350  : }

  00145	48 83 c4 58	 add	 rsp, 88			; 00000058H
  00149	5f		 pop	 rdi
  0014a	5e		 pop	 rsi
  0014b	c3		 ret	 0
z900_vstore4_full ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\dat.h
;	COMDAT z900_maddr_l
_TEXT	SEGMENT
tlbix$ = 48
aea_crn$ = 52
tv70 = 56
maddr$ = 64
addr$ = 96
len$ = 104
arn$ = 112
regs$ = 120
acctype$ = 128
akey$ = 136
z900_maddr_l PROC					; COMDAT

; 307  : {

$LN18:
  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	48 83 ec 58	 sub	 rsp, 88			; 00000058H

; 308  :     /* Note: ALL of the below conditions must be true for a TLB hit
; 309  :        to occur.  If ANY of them are false, then it's a TLB miss,
; 310  :        requiring us to then perform a full DAT address translation.
; 311  : 
; 312  :        Note too that on the grand scheme of things the order/sequence
; 313  :        of the below tests (if statements) is completely unimportant
; 314  :        since ALL conditions must be checked anyway in order for a hit
; 315  :        to occur, and it doesn't matter that a miss tests a few extra
; 316  :        conditions since it's going to do a full translation anyway!
; 317  :        (which is many, many instructions)
; 318  :     */
; 319  : 
; 320  :     int  aea_crn  = (arn >= USE_ARMODE) ? 0 : regs->AEA_AR( arn );

  00018	83 7c 24 70 10	 cmp	 DWORD PTR arn$[rsp], 16
  0001d	7c 0a		 jl	 SHORT $LN16@z900_maddr
  0001f	c7 44 24 38 00
	00 00 00	 mov	 DWORD PTR tv70[rsp], 0
  00027	eb 19		 jmp	 SHORT $LN17@z900_maddr
$LN16@z900_maddr:
  00029	8b 44 24 70	 mov	 eax, DWORD PTR arn$[rsp]
  0002d	83 c0 05	 add	 eax, 5
  00030	48 98		 cdqe
  00032	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  00037	8b 84 81 94 0c
	00 00		 mov	 eax, DWORD PTR [rcx+rax*4+3220]
  0003e	89 44 24 38	 mov	 DWORD PTR tv70[rsp], eax
$LN17@z900_maddr:
  00042	8b 44 24 38	 mov	 eax, DWORD PTR tv70[rsp]
  00046	89 44 24 34	 mov	 DWORD PTR aea_crn$[rsp], eax

; 321  :     U16  tlbix    = TLBIX( addr );

  0004a	48 8b 44 24 60	 mov	 rax, QWORD PTR addr$[rsp]
  0004f	48 c1 e8 0c	 shr	 rax, 12
  00053	48 25 ff 03 00
	00		 and	 rax, 1023		; 000003ffH
  00059	66 89 44 24 30	 mov	 WORD PTR tlbix$[rsp], ax

; 322  :     BYTE *maddr   = NULL;

  0005e	48 c7 44 24 40
	00 00 00 00	 mov	 QWORD PTR maddr$[rsp], 0

; 323  : 
; 324  :     /* Non-zero AEA Control Register number? */
; 325  :     if (aea_crn)

  00067	83 7c 24 34 00	 cmp	 DWORD PTR aea_crn$[rsp], 0
  0006c	0f 84 2d 01 00
	00		 je	 $LN2@z900_maddr

; 326  :     {
; 327  :         /* Same Addess Space Designator as before? */
; 328  :         /* Or if not, is address in a common segment? */
; 329  :         if (0
; 330  :             || (regs->CR( aea_crn ) == regs->tlb.TLB_ASD( tlbix ))
; 331  :             || (regs->AEA_COMMON( aea_crn ) & regs->tlb.common[ tlbix ])

  00072	33 c0		 xor	 eax, eax
  00074	85 c0		 test	 eax, eax
  00076	75 5a		 jne	 SHORT $LN4@z900_maddr
  00078	8b 44 24 34	 mov	 eax, DWORD PTR aea_crn$[rsp]
  0007c	ff c0		 inc	 eax
  0007e	48 98		 cdqe
  00080	0f b7 4c 24 30	 movzx	 ecx, WORD PTR tlbix$[rsp]
  00085	48 8b 54 24 78	 mov	 rdx, QWORD PTR regs$[rsp]
  0008a	4c 8b 44 24 78	 mov	 r8, QWORD PTR regs$[rsp]
  0008f	49 8b 8c c8 60
	b0 00 00	 mov	 rcx, QWORD PTR [r8+rcx*8+45152]
  00097	48 39 8c c2 00
	06 00 00	 cmp	 QWORD PTR [rdx+rax*8+1536], rcx
  0009f	74 31		 je	 SHORT $LN4@z900_maddr
  000a1	8b 44 24 34	 mov	 eax, DWORD PTR aea_crn$[rsp]
  000a5	ff c0		 inc	 eax
  000a7	48 98		 cdqe
  000a9	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  000ae	0f b6 84 01 e8
	0c 00 00	 movzx	 eax, BYTE PTR [rcx+rax+3304]
  000b6	0f b7 4c 24 30	 movzx	 ecx, WORD PTR tlbix$[rsp]
  000bb	48 8b 54 24 78	 mov	 rdx, QWORD PTR regs$[rsp]
  000c0	0f b6 8c 0a 60
	54 01 00	 movzx	 ecx, BYTE PTR [rdx+rcx+87136]
  000c8	23 c1		 and	 eax, ecx
  000ca	85 c0		 test	 eax, eax
  000cc	0f 84 cd 00 00
	00		 je	 $LN3@z900_maddr
$LN4@z900_maddr:

; 332  :         )
; 333  :         {
; 334  :             /* Storage Key zero? */
; 335  :             /* Or if not, same Storage Key as before? */
; 336  :             if (0
; 337  :                 || akey == 0
; 338  :                 || akey == regs->tlb.skey[ tlbix ]

  000d2	33 c0		 xor	 eax, eax
  000d4	85 c0		 test	 eax, eax
  000d6	75 2e		 jne	 SHORT $LN6@z900_maddr
  000d8	0f b6 84 24 88
	00 00 00	 movzx	 eax, BYTE PTR akey$[rsp]
  000e0	85 c0		 test	 eax, eax
  000e2	74 22		 je	 SHORT $LN6@z900_maddr
  000e4	0f b6 84 24 88
	00 00 00	 movzx	 eax, BYTE PTR akey$[rsp]
  000ec	0f b7 4c 24 30	 movzx	 ecx, WORD PTR tlbix$[rsp]
  000f1	48 8b 54 24 78	 mov	 rdx, QWORD PTR regs$[rsp]
  000f6	0f b6 8c 0a 60
	50 01 00	 movzx	 ecx, BYTE PTR [rdx+rcx+86112]
  000fe	3b c1		 cmp	 eax, ecx
  00100	0f 85 99 00 00
	00		 jne	 $LN5@z900_maddr
$LN6@z900_maddr:

; 339  :             )
; 340  :             {
; 341  :                 /* Does the page address match the one in the TLB? */
; 342  :                 /* (does a TLB entry exist for this page address?) */
; 343  :                 if (
; 344  :                     ((addr & TLBID_PAGEMASK) | regs->tlbID)
; 345  :                     ==

  00106	48 8b 44 24 60	 mov	 rax, QWORD PTR addr$[rsp]
  0010b	48 25 00 00 c0
	ff		 and	 rax, -4194304		; ffffffffffc00000H
  00111	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  00116	8b 89 58 b0 00
	00		 mov	 ecx, DWORD PTR [rcx+45144]
  0011c	48 0b c1	 or	 rax, rcx
  0011f	0f b7 4c 24 30	 movzx	 ecx, WORD PTR tlbix$[rsp]
  00124	48 8b 54 24 78	 mov	 rdx, QWORD PTR regs$[rsp]
  00129	48 3b 84 ca 60
	d0 00 00	 cmp	 rax, QWORD PTR [rdx+rcx*8+53344]
  00131	75 6c		 jne	 SHORT $LN7@z900_maddr

; 346  :                     regs->tlb.TLB_VADDR( tlbix )
; 347  :                 )
; 348  :                 {
; 349  :                     /* Is storage being accessed same way as before? */
; 350  :                     if (acctype & regs->tlb.acc[ tlbix ])

  00133	0f b7 44 24 30	 movzx	 eax, WORD PTR tlbix$[rsp]
  00138	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  0013d	0f b6 84 01 60
	5c 01 00	 movzx	 eax, BYTE PTR [rcx+rax+89184]
  00145	8b 8c 24 80 00
	00 00		 mov	 ecx, DWORD PTR acctype$[rsp]
  0014c	23 c8		 and	 ecx, eax
  0014e	8b c1		 mov	 eax, ecx
  00150	85 c0		 test	 eax, eax
  00152	74 4b		 je	 SHORT $LN8@z900_maddr

; 351  :                     {
; 352  :                         /*------------------------------------------*/
; 353  :                         /* TLB hit: use previously translated value */
; 354  :                         /*------------------------------------------*/
; 355  : 
; 356  :                         if (acctype & ACC_CHECK)

  00154	8b 84 24 80 00
	00 00		 mov	 eax, DWORD PTR acctype$[rsp]
  0015b	83 e0 01	 and	 eax, 1
  0015e	85 c0		 test	 eax, eax
  00160	74 1e		 je	 SHORT $LN9@z900_maddr

; 357  :                             regs->dat.storkey = regs->tlb.storkey[ tlbix ];

  00162	0f b7 44 24 30	 movzx	 eax, WORD PTR tlbix$[rsp]
  00167	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  0016c	48 8b 54 24 78	 mov	 rdx, QWORD PTR regs$[rsp]
  00171	48 8b 84 c2 60
	30 01 00	 mov	 rax, QWORD PTR [rdx+rax*8+77920]
  00179	48 89 81 28 08
	00 00		 mov	 QWORD PTR [rcx+2088], rax
$LN9@z900_maddr:

; 358  : 
; 359  :                         maddr = MAINADDR( regs->tlb.main[tlbix], addr );

  00180	0f b7 44 24 30	 movzx	 eax, WORD PTR tlbix$[rsp]
  00185	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  0018a	48 8b 54 24 60	 mov	 rdx, QWORD PTR addr$[rsp]
  0018f	48 8b 84 c1 60
	10 01 00	 mov	 rax, QWORD PTR [rcx+rax*8+69728]
  00197	48 33 c2	 xor	 rax, rdx
  0019a	48 89 44 24 40	 mov	 QWORD PTR maddr$[rsp], rax
$LN8@z900_maddr:
$LN7@z900_maddr:
$LN5@z900_maddr:
$LN3@z900_maddr:
$LN2@z900_maddr:

; 360  :                     }
; 361  :                 }
; 362  :             }
; 363  :         }
; 364  :     }
; 365  : 
; 366  :     /*---------------------------------------*/
; 367  :     /* TLB miss: do full address translation */
; 368  :     /*---------------------------------------*/
; 369  :     if (!maddr)

  0019f	48 83 7c 24 40
	00		 cmp	 QWORD PTR maddr$[rsp], 0
  001a5	75 36		 jne	 SHORT $LN10@z900_maddr

; 370  :         maddr = ARCH_DEP( logical_to_main_l )( addr, arn, regs, acctype, akey, len );

  001a7	48 8b 44 24 68	 mov	 rax, QWORD PTR len$[rsp]
  001ac	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  001b1	0f b6 84 24 88
	00 00 00	 movzx	 eax, BYTE PTR akey$[rsp]
  001b9	88 44 24 20	 mov	 BYTE PTR [rsp+32], al
  001bd	44 8b 8c 24 80
	00 00 00	 mov	 r9d, DWORD PTR acctype$[rsp]
  001c5	4c 8b 44 24 78	 mov	 r8, QWORD PTR regs$[rsp]
  001ca	8b 54 24 70	 mov	 edx, DWORD PTR arn$[rsp]
  001ce	48 8b 4c 24 60	 mov	 rcx, QWORD PTR addr$[rsp]
  001d3	e8 00 00 00 00	 call	 z900_logical_to_main_l
  001d8	48 89 44 24 40	 mov	 QWORD PTR maddr$[rsp], rax
$LN10@z900_maddr:

; 371  : 
; 372  : #if defined( FEATURE_073_TRANSACT_EXEC_FACILITY )
; 373  :     if (FACILITY_ENABLED( 073_TRANSACT_EXEC, regs ))

  001dd	b8 01 00 00 00	 mov	 eax, 1
  001e2	48 6b c0 09	 imul	 rax, rax, 9
  001e6	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  001eb	0f b6 84 01 28
	0d 00 00	 movzx	 eax, BYTE PTR [rcx+rax+3368]
  001f3	83 e0 40	 and	 eax, 64			; 00000040H
  001f6	85 c0		 test	 eax, eax
  001f8	0f 84 89 00 00
	00		 je	 $LN11@z900_maddr

; 374  :     {
; 375  :         /* SA22-7832-12 Principles of Operation, page 5-99:
; 376  : 
; 377  :              "Storage accesses for instruction and DAT- and ART-
; 378  :               table fetches follow the non-transactional rules."
; 379  :         */
; 380  :         if (0
; 381  :             || !regs
; 382  :             || !regs->txf_tnd
; 383  :             || arn == USE_INST_SPACE    /* Instruction fetching */
; 384  :             || arn == USE_REAL_ADDR     /* Address translation  */

  001fe	33 c0		 xor	 eax, eax
  00200	85 c0		 test	 eax, eax
  00202	75 26		 jne	 SHORT $LN13@z900_maddr
  00204	48 83 7c 24 78
	00		 cmp	 QWORD PTR regs$[rsp], 0
  0020a	74 1e		 je	 SHORT $LN13@z900_maddr
  0020c	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  00211	0f b6 80 58 0e
	00 00		 movzx	 eax, BYTE PTR [rax+3672]
  00218	85 c0		 test	 eax, eax
  0021a	74 0e		 je	 SHORT $LN13@z900_maddr
  0021c	83 7c 24 70 ff	 cmp	 DWORD PTR arn$[rsp], -1
  00221	74 07		 je	 SHORT $LN13@z900_maddr
  00223	83 7c 24 70 fe	 cmp	 DWORD PTR arn$[rsp], -2
  00228	75 07		 jne	 SHORT $LN12@z900_maddr
$LN13@z900_maddr:

; 385  :         )
; 386  :             return maddr;

  0022a	48 8b 44 24 40	 mov	 rax, QWORD PTR maddr$[rsp]
  0022f	eb 5b		 jmp	 SHORT $LN1@z900_maddr
$LN12@z900_maddr:

; 387  : 
; 388  :         /* Quick exit if NTSTG call */
; 389  :         if (regs->txf_NTSTG)

  00231	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  00236	0f b6 80 4b 0e
	00 00		 movzx	 eax, BYTE PTR [rax+3659]
  0023d	85 c0		 test	 eax, eax
  0023f	74 13		 je	 SHORT $LN14@z900_maddr

; 390  :         {
; 391  :             regs->txf_NTSTG = false;

  00241	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  00246	c6 80 4b 0e 00
	00 00		 mov	 BYTE PTR [rax+3659], 0

; 392  :             return maddr;

  0024d	48 8b 44 24 40	 mov	 rax, QWORD PTR maddr$[rsp]
  00252	eb 38		 jmp	 SHORT $LN1@z900_maddr
$LN14@z900_maddr:

; 393  :         }
; 394  : 
; 395  :         /* Translate to alternate TXF address */
; 396  :         maddr = TXF_MADDRL( addr, len, arn, regs, acctype, maddr );

  00254	48 8b 44 24 40	 mov	 rax, QWORD PTR maddr$[rsp]
  00259	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  0025e	8b 84 24 80 00
	00 00		 mov	 eax, DWORD PTR acctype$[rsp]
  00265	89 44 24 20	 mov	 DWORD PTR [rsp+32], eax
  00269	4c 8b 4c 24 78	 mov	 r9, QWORD PTR regs$[rsp]
  0026e	44 8b 44 24 70	 mov	 r8d, DWORD PTR arn$[rsp]
  00273	48 8b 54 24 68	 mov	 rdx, QWORD PTR len$[rsp]
  00278	48 8b 4c 24 60	 mov	 rcx, QWORD PTR addr$[rsp]
  0027d	e8 00 00 00 00	 call	 txf_maddr_l
  00282	48 89 44 24 40	 mov	 QWORD PTR maddr$[rsp], rax
$LN11@z900_maddr:

; 397  :     }
; 398  : #endif
; 399  : 
; 400  :     return maddr;

  00287	48 8b 44 24 40	 mov	 rax, QWORD PTR maddr$[rsp]
$LN1@z900_maddr:

; 401  : }

  0028c	48 83 c4 58	 add	 rsp, 88			; 00000058H
  00290	c3		 ret	 0
z900_maddr_l ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\inline.h
;	COMDAT z900_per3_zero_xcheck2
_TEXT	SEGMENT
tv81 = 32
tv131 = 40
tv150 = 48
tv181 = 56
tv166 = 64
regs$ = 96
x2$ = 104
b2$ = 112
z900_per3_zero_xcheck2 PROC				; COMDAT

; 765  : {

$LN18:
  00000	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  00005	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00009	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000e	48 83 ec 58	 sub	 rsp, 88			; 00000058H

; 766  : #if defined( FEATURE_PER_ZERO_ADDRESS_DETECTION_FACILITY )
; 767  :     if (0
; 768  :         || (!b2 && x2 && GR_A( x2, regs ) == 0)
; 769  :         || (!x2 && b2 && GR_A( b2, regs ) == 0)
; 770  :         || ( b2 && x2 && (0

  00012	33 c0		 xor	 eax, eax
  00014	85 c0		 test	 eax, eax
  00016	0f 85 ba 01 00
	00		 jne	 $LN3@z900_per3_
  0001c	83 7c 24 70 00	 cmp	 DWORD PTR b2$[rsp], 0
  00021	75 54		 jne	 SHORT $LN4@z900_per3_
  00023	83 7c 24 68 00	 cmp	 DWORD PTR x2$[rsp], 0
  00028	74 4d		 je	 SHORT $LN4@z900_per3_
  0002a	48 8b 44 24 60	 mov	 rax, QWORD PTR regs$[rsp]
  0002f	8b 80 80 00 00
	00		 mov	 eax, DWORD PTR [rax+128]
  00035	83 e0 01	 and	 eax, 1
  00038	85 c0		 test	 eax, eax
  0003a	74 19		 je	 SHORT $LN8@z900_per3_
  0003c	48 63 44 24 68	 movsxd	 rax, DWORD PTR x2$[rsp]
  00041	48 8b 4c 24 60	 mov	 rcx, QWORD PTR regs$[rsp]
  00046	48 8b 84 c1 80
	02 00 00	 mov	 rax, QWORD PTR [rcx+rax*8+640]
  0004e	48 89 44 24 20	 mov	 QWORD PTR tv81[rsp], rax
  00053	eb 16		 jmp	 SHORT $LN9@z900_per3_
$LN8@z900_per3_:
  00055	48 63 44 24 68	 movsxd	 rax, DWORD PTR x2$[rsp]
  0005a	48 8b 4c 24 60	 mov	 rcx, QWORD PTR regs$[rsp]
  0005f	8b 84 c1 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax*8+640]
  00066	48 89 44 24 20	 mov	 QWORD PTR tv81[rsp], rax
$LN9@z900_per3_:
  0006b	48 83 7c 24 20
	00		 cmp	 QWORD PTR tv81[rsp], 0
  00071	0f 84 5f 01 00
	00		 je	 $LN3@z900_per3_
$LN4@z900_per3_:
  00077	83 7c 24 68 00	 cmp	 DWORD PTR x2$[rsp], 0
  0007c	75 54		 jne	 SHORT $LN5@z900_per3_
  0007e	83 7c 24 70 00	 cmp	 DWORD PTR b2$[rsp], 0
  00083	74 4d		 je	 SHORT $LN5@z900_per3_
  00085	48 8b 44 24 60	 mov	 rax, QWORD PTR regs$[rsp]
  0008a	8b 80 80 00 00
	00		 mov	 eax, DWORD PTR [rax+128]
  00090	83 e0 01	 and	 eax, 1
  00093	85 c0		 test	 eax, eax
  00095	74 19		 je	 SHORT $LN10@z900_per3_
  00097	48 63 44 24 70	 movsxd	 rax, DWORD PTR b2$[rsp]
  0009c	48 8b 4c 24 60	 mov	 rcx, QWORD PTR regs$[rsp]
  000a1	48 8b 84 c1 80
	02 00 00	 mov	 rax, QWORD PTR [rcx+rax*8+640]
  000a9	48 89 44 24 28	 mov	 QWORD PTR tv131[rsp], rax
  000ae	eb 16		 jmp	 SHORT $LN11@z900_per3_
$LN10@z900_per3_:
  000b0	48 63 44 24 70	 movsxd	 rax, DWORD PTR b2$[rsp]
  000b5	48 8b 4c 24 60	 mov	 rcx, QWORD PTR regs$[rsp]
  000ba	8b 84 c1 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax*8+640]
  000c1	48 89 44 24 28	 mov	 QWORD PTR tv131[rsp], rax
$LN11@z900_per3_:
  000c6	48 83 7c 24 28
	00		 cmp	 QWORD PTR tv131[rsp], 0
  000cc	0f 84 04 01 00
	00		 je	 $LN3@z900_per3_
$LN5@z900_per3_:
  000d2	83 7c 24 70 00	 cmp	 DWORD PTR b2$[rsp], 0
  000d7	0f 84 03 01 00
	00		 je	 $LN2@z900_per3_
  000dd	83 7c 24 68 00	 cmp	 DWORD PTR x2$[rsp], 0
  000e2	0f 84 f8 00 00
	00		 je	 $LN2@z900_per3_
  000e8	33 c0		 xor	 eax, eax
  000ea	85 c0		 test	 eax, eax
  000ec	0f 85 e4 00 00
	00		 jne	 $LN6@z900_per3_
  000f2	48 8b 44 24 60	 mov	 rax, QWORD PTR regs$[rsp]
  000f7	8b 80 80 00 00
	00		 mov	 eax, DWORD PTR [rax+128]
  000fd	83 e0 01	 and	 eax, 1
  00100	85 c0		 test	 eax, eax
  00102	74 19		 je	 SHORT $LN12@z900_per3_
  00104	48 63 44 24 70	 movsxd	 rax, DWORD PTR b2$[rsp]
  00109	48 8b 4c 24 60	 mov	 rcx, QWORD PTR regs$[rsp]
  0010e	48 8b 84 c1 80
	02 00 00	 mov	 rax, QWORD PTR [rcx+rax*8+640]
  00116	48 89 44 24 30	 mov	 QWORD PTR tv150[rsp], rax
  0011b	eb 16		 jmp	 SHORT $LN13@z900_per3_
$LN12@z900_per3_:
  0011d	48 63 44 24 70	 movsxd	 rax, DWORD PTR b2$[rsp]
  00122	48 8b 4c 24 60	 mov	 rcx, QWORD PTR regs$[rsp]
  00127	8b 84 c1 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax*8+640]
  0012e	48 89 44 24 30	 mov	 QWORD PTR tv150[rsp], rax
$LN13@z900_per3_:
  00133	48 83 7c 24 30
	00		 cmp	 QWORD PTR tv150[rsp], 0
  00139	0f 84 97 00 00
	00		 je	 $LN6@z900_per3_
  0013f	48 8b 44 24 60	 mov	 rax, QWORD PTR regs$[rsp]
  00144	8b 80 80 00 00
	00		 mov	 eax, DWORD PTR [rax+128]
  0014a	83 e0 01	 and	 eax, 1
  0014d	85 c0		 test	 eax, eax
  0014f	74 19		 je	 SHORT $LN14@z900_per3_
  00151	48 63 44 24 70	 movsxd	 rax, DWORD PTR b2$[rsp]
  00156	48 8b 4c 24 60	 mov	 rcx, QWORD PTR regs$[rsp]
  0015b	48 8b 84 c1 80
	02 00 00	 mov	 rax, QWORD PTR [rcx+rax*8+640]
  00163	48 89 44 24 40	 mov	 QWORD PTR tv166[rsp], rax
  00168	eb 16		 jmp	 SHORT $LN15@z900_per3_
$LN14@z900_per3_:
  0016a	48 63 44 24 70	 movsxd	 rax, DWORD PTR b2$[rsp]
  0016f	48 8b 4c 24 60	 mov	 rcx, QWORD PTR regs$[rsp]
  00174	8b 84 c1 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax*8+640]
  0017b	48 89 44 24 40	 mov	 QWORD PTR tv166[rsp], rax
$LN15@z900_per3_:
  00180	48 8b 44 24 60	 mov	 rax, QWORD PTR regs$[rsp]
  00185	8b 80 80 00 00
	00		 mov	 eax, DWORD PTR [rax+128]
  0018b	83 e0 01	 and	 eax, 1
  0018e	85 c0		 test	 eax, eax
  00190	74 19		 je	 SHORT $LN16@z900_per3_
  00192	48 63 44 24 68	 movsxd	 rax, DWORD PTR x2$[rsp]
  00197	48 8b 4c 24 60	 mov	 rcx, QWORD PTR regs$[rsp]
  0019c	48 8b 84 c1 80
	02 00 00	 mov	 rax, QWORD PTR [rcx+rax*8+640]
  001a4	48 89 44 24 38	 mov	 QWORD PTR tv181[rsp], rax
  001a9	eb 16		 jmp	 SHORT $LN17@z900_per3_
$LN16@z900_per3_:
  001ab	48 63 44 24 68	 movsxd	 rax, DWORD PTR x2$[rsp]
  001b0	48 8b 4c 24 60	 mov	 rcx, QWORD PTR regs$[rsp]
  001b5	8b 84 c1 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax*8+640]
  001bc	48 89 44 24 38	 mov	 QWORD PTR tv181[rsp], rax
$LN17@z900_per3_:
  001c1	48 8b 44 24 38	 mov	 rax, QWORD PTR tv181[rsp]
  001c6	48 8b 4c 24 40	 mov	 rcx, QWORD PTR tv166[rsp]
  001cb	48 03 c8	 add	 rcx, rax
  001ce	48 8b c1	 mov	 rax, rcx
  001d1	48 85 c0	 test	 rax, rax
  001d4	75 0a		 jne	 SHORT $LN2@z900_per3_
$LN6@z900_per3_:
$LN3@z900_per3_:

; 771  :                           || GR_A( b2, regs ) == 0
; 772  :                           || GR_A( b2, regs ) + GR_A( x2, regs ) == 0
; 773  :                          )
; 774  :            )
; 775  :     )
; 776  :         ARCH_DEP( per3_zero )( regs );

  001d6	48 8b 4c 24 60	 mov	 rcx, QWORD PTR regs$[rsp]
  001db	e8 00 00 00 00	 call	 z900_per3_zero
$LN2@z900_per3_:

; 777  : #else
; 778  :     UNREFERENCED( regs );
; 779  :     UNREFERENCED( x2 );
; 780  :     UNREFERENCED( b2 );
; 781  : #endif
; 782  : }

  001e0	48 83 c4 58	 add	 rsp, 88			; 00000058H
  001e4	c3		 ret	 0
z900_per3_zero_xcheck2 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\inline.h
;	COMDAT z900_per3_zero
_TEXT	SEGMENT
tv75 = 32
regs$ = 64
z900_per3_zero PROC					; COMDAT

; 602  : {

$LN12:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 603  : #if defined( FEATURE_PER_ZERO_ADDRESS_DETECTION_FACILITY )
; 604  :     if (1
; 605  :         && EN_IC_PER_ZEROADDR( regs )
; 606  :         && !IS_PER_SUPRESS( regs, CR9_ZEROADDR )

  00009	33 c0		 xor	 eax, eax
  0000b	83 f8 01	 cmp	 eax, 1
  0000e	0f 84 be 00 00
	00		 je	 $LN5@z900_per3_
  00014	48 8b 44 24 40	 mov	 rax, QWORD PTR regs$[rsp]
  00019	8b 80 28 07 00
	00		 mov	 eax, DWORD PTR [rax+1832]
  0001f	c1 e8 02	 shr	 eax, 2
  00022	83 e0 01	 and	 eax, 1
  00025	85 c0		 test	 eax, eax
  00027	74 0a		 je	 SHORT $LN10@z900_per3_
  00029	c7 44 24 20 01
	00 00 00	 mov	 DWORD PTR tv75[rsp], 1
  00031	eb 08		 jmp	 SHORT $LN11@z900_per3_
$LN10@z900_per3_:
  00033	c7 44 24 20 00
	00 00 00	 mov	 DWORD PTR tv75[rsp], 0
$LN11@z900_per3_:
  0003b	83 7c 24 20 00	 cmp	 DWORD PTR tv75[rsp], 0
  00040	0f 84 8c 00 00
	00		 je	 $LN5@z900_per3_
  00046	48 8b 44 24 40	 mov	 rax, QWORD PTR regs$[rsp]
  0004b	8b 40 48	 mov	 eax, DWORD PTR [rax+72]
  0004e	25 00 00 04 00	 and	 eax, 262144		; 00040000H
  00053	85 c0		 test	 eax, eax
  00055	74 7b		 je	 SHORT $LN5@z900_per3_
  00057	ba 00 00 00 04	 mov	 edx, 67108864		; 04000000H
  0005c	48 8b 4c 24 40	 mov	 rcx, QWORD PTR regs$[rsp]
  00061	e8 00 00 00 00	 call	 z900_is_per3_event_suppressed
  00066	0f b6 c0	 movzx	 eax, al
  00069	85 c0		 test	 eax, eax
  0006b	75 65		 jne	 SHORT $LN5@z900_per3_

; 607  :     )
; 608  :     {
; 609  :         regs->peradr = regs->periaddr;

  0006d	48 8b 44 24 40	 mov	 rax, QWORD PTR regs$[rsp]
  00072	48 8b 4c 24 40	 mov	 rcx, QWORD PTR regs$[rsp]
  00077	48 8b 89 e8 08
	00 00		 mov	 rcx, QWORD PTR [rcx+2280]
  0007e	48 89 88 d8 08
	00 00		 mov	 QWORD PTR [rax+2264], rcx
$LN4@z900_per3_:

; 610  :         ON_IC_PER_ZEROADDR( regs );

  00085	48 8b 44 24 40	 mov	 rax, QWORD PTR regs$[rsp]
  0008a	8b 40 4c	 mov	 eax, DWORD PTR [rax+76]
  0008d	0f ba e8 12	 bts	 eax, 18
  00091	48 8b 4c 24 40	 mov	 rcx, QWORD PTR regs$[rsp]
  00096	89 41 4c	 mov	 DWORD PTR [rcx+76], eax
  00099	33 c0		 xor	 eax, eax
  0009b	85 c0		 test	 eax, eax
  0009d	75 e6		 jne	 SHORT $LN4@z900_per3_

; 611  :         if (OPEN_IC_PER_ZEROADDR( regs ))

  0009f	48 8b 44 24 40	 mov	 rax, QWORD PTR regs$[rsp]
  000a4	48 8b 4c 24 40	 mov	 rcx, QWORD PTR regs$[rsp]
  000a9	8b 49 4c	 mov	 ecx, DWORD PTR [rcx+76]
  000ac	8b 40 48	 mov	 eax, DWORD PTR [rax+72]
  000af	23 c1		 and	 eax, ecx
  000b1	25 00 00 04 00	 and	 eax, 262144		; 00040000H
  000b6	85 c0		 test	 eax, eax
  000b8	74 18		 je	 SHORT $LN6@z900_per3_

; 612  :             RETURN_INTCHECK( regs );

  000ba	48 8b 44 24 40	 mov	 rax, QWORD PTR regs$[rsp]
  000bf	48 05 80 09 00
	00		 add	 rax, 2432		; 00000980H
  000c5	ba ff ff ff ff	 mov	 edx, -1
  000ca	48 8b c8	 mov	 rcx, rax
  000cd	e8 00 00 00 00	 call	 longjmp
$LN6@z900_per3_:
$LN5@z900_per3_:
$LN7@z900_per3_:

; 613  :     }
; 614  : #else
; 615  :     UNREFERENCED( regs );
; 616  : #endif
; 617  : }

  000d2	48 83 c4 38	 add	 rsp, 56			; 00000038H
  000d6	c3		 ret	 0
z900_per3_zero ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\inline.h
;	COMDAT z900_is_per3_event_suppressed
_TEXT	SEGMENT
regs$ = 8
cr9_per_event$ = 16
z900_is_per3_event_suppressed PROC			; COMDAT

; 566  : {

  00000	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00004	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx

; 567  : #if !defined( FEATURE_PER3 )
; 568  :     UNREFERENCED( regs );
; 569  :     UNREFERENCED( cr9_per_event );
; 570  : #else
; 571  :     /* DON'T suppress this event if Event Suppression isn't enabled */
; 572  :     if (!(regs->CR_L(9) & CR9_SUPPRESS))

  00009	b8 08 00 00 00	 mov	 eax, 8
  0000e	48 6b c0 0a	 imul	 rax, rax, 10
  00012	48 8b 4c 24 08	 mov	 rcx, QWORD PTR regs$[rsp]
  00017	8b 84 01 00 06
	00 00		 mov	 eax, DWORD PTR [rcx+rax+1536]
  0001e	25 00 00 40 00	 and	 eax, 4194304		; 00400000H
  00023	85 c0		 test	 eax, eax
  00025	75 04		 jne	 SHORT $LN2@z900_is_pe

; 573  :         return false;

  00027	32 c0		 xor	 al, al
  00029	eb 78		 jmp	 SHORT $LN1@z900_is_pe
$LN2@z900_is_pe:

; 574  : 
; 575  :     /* Is this PER event one that is ALLOWED to be suppressed? */
; 576  :     if (cr9_per_event & CR9_SUPPRESSABLE)

  0002b	8b 44 24 10	 mov	 eax, DWORD PTR cr9_per_event$[rsp]
  0002f	25 00 00 00 ed	 and	 eax, -318767104		; ed000000H
  00034	85 c0		 test	 eax, eax
  00036	74 69		 je	 SHORT $LN3@z900_is_pe

; 577  :     {
; 578  :         /* Is there an active transaction? */
; 579  :         if (regs->txf_tnd)

  00038	48 8b 44 24 08	 mov	 rax, QWORD PTR regs$[rsp]
  0003d	0f b6 80 58 0e
	00 00		 movzx	 eax, BYTE PTR [rax+3672]
  00044	85 c0		 test	 eax, eax
  00046	74 04		 je	 SHORT $LN4@z900_is_pe

; 580  :             return true;        /* Yes, then suppress it! */

  00048	b0 01		 mov	 al, 1
  0004a	eb 57		 jmp	 SHORT $LN1@z900_is_pe
$LN4@z900_is_pe:

; 581  : 
; 582  :         /* Suppress instruction-fetch events for TBEGIN/TBEGINC */
; 583  :         if (1
; 584  :             && cr9_per_event & CR9_IF
; 585  :             && *(regs->ip+0) == 0xE5
; 586  :             && (0

  0004c	33 c0		 xor	 eax, eax
  0004e	83 f8 01	 cmp	 eax, 1
  00051	74 4e		 je	 SHORT $LN5@z900_is_pe
  00053	8b 44 24 10	 mov	 eax, DWORD PTR cr9_per_event$[rsp]
  00057	25 00 00 00 40	 and	 eax, 1073741824		; 40000000H
  0005c	85 c0		 test	 eax, eax
  0005e	74 41		 je	 SHORT $LN5@z900_is_pe
  00060	48 8b 44 24 08	 mov	 rax, QWORD PTR regs$[rsp]
  00065	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  00069	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  0006c	3d e5 00 00 00	 cmp	 eax, 229		; 000000e5H
  00071	75 2e		 jne	 SHORT $LN5@z900_is_pe
  00073	33 c0		 xor	 eax, eax
  00075	85 c0		 test	 eax, eax
  00077	75 24		 jne	 SHORT $LN6@z900_is_pe
  00079	48 8b 44 24 08	 mov	 rax, QWORD PTR regs$[rsp]
  0007e	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  00082	0f b6 40 01	 movzx	 eax, BYTE PTR [rax+1]
  00086	83 f8 60	 cmp	 eax, 96			; 00000060H
  00089	74 12		 je	 SHORT $LN6@z900_is_pe
  0008b	48 8b 44 24 08	 mov	 rax, QWORD PTR regs$[rsp]
  00090	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  00094	0f b6 40 01	 movzx	 eax, BYTE PTR [rax+1]
  00098	83 f8 61	 cmp	 eax, 97			; 00000061H
  0009b	75 04		 jne	 SHORT $LN5@z900_is_pe
$LN6@z900_is_pe:

; 587  :                 || *(regs->ip+1) == 0x60
; 588  :                 || *(regs->ip+1) == 0x61
; 589  :                )
; 590  :         )
; 591  :             return true;        /* TBEGIN/TBEGINC: suppress it! */

  0009d	b0 01		 mov	 al, 1
  0009f	eb 02		 jmp	 SHORT $LN1@z900_is_pe
$LN5@z900_is_pe:
$LN3@z900_is_pe:

; 592  :     }
; 593  : #endif
; 594  :     /* Otherwise DON'T suppress this PER event */
; 595  :     return false;

  000a1	32 c0		 xor	 al, al
$LN1@z900_is_pe:

; 596  : }

  000a3	c3		 ret	 0
z900_is_per3_event_suppressed ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\assist.c
_TEXT	SEGMENT
temp$1 = 64
b2$ = 68
b1$ = 72
effective_addr2$ = 80
effective_addr1$ = 88
inst$ = 112
regs$ = 120
z900_svc_assist PROC

; 129  : {

$LN16:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 68	 sub	 rsp, 104		; 00000068H

; 130  : int     b1, b2;                         /* Values of base field      */
; 131  : VADR    effective_addr1,
; 132  :         effective_addr2;                /* Effective addresses       */
; 133  : 
; 134  :     SSE(inst, regs, b1, effective_addr1, b2, effective_addr2);

  0000e	48 8b 44 24 70	 mov	 rax, QWORD PTR inst$[rsp]
  00013	48 83 c0 02	 add	 rax, 2
  00017	48 8b c8	 mov	 rcx, rax
  0001a	e8 00 00 00 00	 call	 fetch_fw_noswap
  0001f	8b c8		 mov	 ecx, eax
  00021	e8 00 00 00 00	 call	 _byteswap_ulong
  00026	89 44 24 40	 mov	 DWORD PTR temp$1[rsp], eax
  0002a	8b 44 24 40	 mov	 eax, DWORD PTR temp$1[rsp]
  0002e	25 ff 0f 00 00	 and	 eax, 4095		; 00000fffH
  00033	8b c0		 mov	 eax, eax
  00035	48 89 44 24 50	 mov	 QWORD PTR effective_addr2$[rsp], rax
  0003a	8b 44 24 40	 mov	 eax, DWORD PTR temp$1[rsp]
  0003e	c1 e8 0c	 shr	 eax, 12
  00041	83 e0 0f	 and	 eax, 15
  00044	89 44 24 44	 mov	 DWORD PTR b2$[rsp], eax
  00048	8b 44 24 40	 mov	 eax, DWORD PTR temp$1[rsp]
  0004c	c1 e8 10	 shr	 eax, 16
  0004f	25 ff 0f 00 00	 and	 eax, 4095		; 00000fffH
  00054	8b c0		 mov	 eax, eax
  00056	48 89 44 24 58	 mov	 QWORD PTR effective_addr1$[rsp], rax
  0005b	8b 44 24 40	 mov	 eax, DWORD PTR temp$1[rsp]
  0005f	c1 e8 1c	 shr	 eax, 28
  00062	83 e0 0f	 and	 eax, 15
  00065	89 44 24 48	 mov	 DWORD PTR b1$[rsp], eax
  00069	83 7c 24 48 00	 cmp	 DWORD PTR b1$[rsp], 0
  0006e	74 3e		 je	 SHORT $LN8@z900_svc_a
  00070	48 63 44 24 48	 movsxd	 rax, DWORD PTR b1$[rsp]
  00075	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  0007a	48 8b 84 c1 80
	02 00 00	 mov	 rax, QWORD PTR [rcx+rax*8+640]
  00082	48 8b 4c 24 58	 mov	 rcx, QWORD PTR effective_addr1$[rsp]
  00087	48 03 c8	 add	 rcx, rax
  0008a	48 8b c1	 mov	 rax, rcx
  0008d	48 89 44 24 58	 mov	 QWORD PTR effective_addr1$[rsp], rax
  00092	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  00097	48 8b 80 90 00
	00 00		 mov	 rax, QWORD PTR [rax+144]
  0009e	48 8b 4c 24 58	 mov	 rcx, QWORD PTR effective_addr1$[rsp]
  000a3	48 23 c8	 and	 rcx, rax
  000a6	48 8b c1	 mov	 rax, rcx
  000a9	48 89 44 24 58	 mov	 QWORD PTR effective_addr1$[rsp], rax
$LN8@z900_svc_a:
  000ae	83 7c 24 44 00	 cmp	 DWORD PTR b2$[rsp], 0
  000b3	74 3e		 je	 SHORT $LN9@z900_svc_a
  000b5	48 63 44 24 44	 movsxd	 rax, DWORD PTR b2$[rsp]
  000ba	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  000bf	48 8b 84 c1 80
	02 00 00	 mov	 rax, QWORD PTR [rcx+rax*8+640]
  000c7	48 8b 4c 24 50	 mov	 rcx, QWORD PTR effective_addr2$[rsp]
  000cc	48 03 c8	 add	 rcx, rax
  000cf	48 8b c1	 mov	 rax, rcx
  000d2	48 89 44 24 50	 mov	 QWORD PTR effective_addr2$[rsp], rax
  000d7	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  000dc	48 8b 80 90 00
	00 00		 mov	 rax, QWORD PTR [rax+144]
  000e3	48 8b 4c 24 50	 mov	 rcx, QWORD PTR effective_addr2$[rsp]
  000e8	48 23 c8	 and	 rcx, rax
  000eb	48 8b c1	 mov	 rax, rcx
  000ee	48 89 44 24 50	 mov	 QWORD PTR effective_addr2$[rsp], rax
$LN9@z900_svc_a:
$LN4@z900_svc_a:
  000f3	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  000f8	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  000fc	48 83 c0 06	 add	 rax, 6
  00100	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  00105	48 89 41 68	 mov	 QWORD PTR [rcx+104], rax
  00109	33 c0		 xor	 eax, eax
  0010b	83 f8 06	 cmp	 eax, 6
  0010e	74 0c		 je	 SHORT $LN10@z900_svc_a
  00110	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  00115	c6 80 9a 00 00
	00 06		 mov	 BYTE PTR [rax+154], 6
$LN10@z900_svc_a:
  0011c	33 c0		 xor	 eax, eax
  0011e	85 c0		 test	 eax, eax
  00120	75 d1		 jne	 SHORT $LN4@z900_svc_a

; 135  :     PER_ZEROADDR_XCHECK2( regs, b1, b2 );

  00122	44 8b 44 24 44	 mov	 r8d, DWORD PTR b2$[rsp]
  00127	8b 54 24 48	 mov	 edx, DWORD PTR b1$[rsp]
  0012b	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  00130	e8 00 00 00 00	 call	 z900_per3_zero_xcheck2

; 136  : 
; 137  :     GUEST_CHECK( );

  00135	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  0013a	0f b6 40 7a	 movzx	 eax, BYTE PTR [rax+122]
  0013e	83 e0 01	 and	 eax, 1
  00141	85 c0		 test	 eax, eax
  00143	74 44		 je	 SHORT $LN11@z900_svc_a
  00145	b8 08 00 00 00	 mov	 eax, 8
  0014a	48 6b c0 07	 imul	 rax, rax, 7
  0014e	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  00153	8b 84 01 00 06
	00 00		 mov	 eax, DWORD PTR [rcx+rax+1536]
  0015a	25 04 00 00 40	 and	 eax, 1073741828		; 40000004H
  0015f	83 f8 04	 cmp	 eax, 4
  00162	74 25		 je	 SHORT $LN12@z900_svc_a
  00164	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  00169	0f b6 40 7a	 movzx	 eax, BYTE PTR [rax+122]
  0016d	83 e0 01	 and	 eax, 1
  00170	85 c0		 test	 eax, eax
  00172	74 15		 je	 SHORT $LN13@z900_svc_a
  00174	ba 02 00 00 00	 mov	 edx, 2
  00179	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  0017e	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  00183	ff 90 20 0d 00
	00		 call	 QWORD PTR [rax+3360]
$LN13@z900_svc_a:
$LN12@z900_svc_a:
$LN11@z900_svc_a:
$LN7@z900_svc_a:

; 138  : 
; 139  :     PTT_ERR( "*E503 SVCA", effective_addr1, effective_addr2, regs->psw.IA_L );

  00189	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_pttclass
  00190	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00193	48 83 e0 10	 and	 rax, 16
  00197	48 85 c0	 test	 rax, rax
  0019a	74 41		 je	 SHORT $LN14@z900_svc_a
  0019c	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  001a1	8b 80 88 00 00
	00		 mov	 eax, DWORD PTR [rax+136]
  001a7	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR [rsp+48], 0
  001b0	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  001b5	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG193367
  001bc	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  001c1	4c 8b 4c 24 50	 mov	 r9, QWORD PTR effective_addr2$[rsp]
  001c6	4c 8b 44 24 58	 mov	 r8, QWORD PTR effective_addr1$[rsp]
  001cb	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG193368
  001d2	b9 10 00 00 00	 mov	 ecx, 16
  001d7	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ptt_pthread_trace
$LN14@z900_svc_a:
  001dd	33 c0		 xor	 eax, eax
  001df	85 c0		 test	 eax, eax
  001e1	75 a6		 jne	 SHORT $LN7@z900_svc_a

; 140  :     /*INCOMPLETE: NO ACTION IS TAKEN, THE SVC IS UNASSISTED
; 141  :                   AND MVS WILL HAVE TO HANDLE THE SITUATION*/
; 142  : }

  001e3	48 83 c4 68	 add	 rsp, 104		; 00000068H
  001e7	c3		 ret	 0
z900_svc_assist ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\assist.c
_TEXT	SEGMENT
acc_mode$ = 32
hlhi_word$ = 36
effective_addr2$ = 40
temp$1 = 48
b2$ = 52
b1$ = 56
effective_addr1$ = 64
lcpa$ = 72
lock$ = 76
susp$ = 80
lit_addr$ = 88
ascb_addr$ = 96
lock_addr$ = 104
newia$ = 112
susp_addr$ = 120
inst$ = 144
regs$ = 152
z900_release_local_lock PROC

; 242  : {

$LN31:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 81 ec 88 00
	00 00		 sub	 rsp, 136		; 00000088H

; 243  : int     b1, b2;                         /* Values of base field      */
; 244  : VADR    effective_addr1,
; 245  :         effective_addr2;                /* Effective addresses       */
; 246  : VADR    ascb_addr;                      /* Virtual address of ASCB   */
; 247  : VADR    lock_addr;                      /* Virtual addr of ASCBLOCK  */
; 248  : VADR    susp_addr;                      /* Virtual addr of ASCBLSWQ  */
; 249  : U32     hlhi_word;                      /* Highest lock held word    */
; 250  : VADR    lit_addr;                       /* Virtual address of lock
; 251  :                                            interface table           */
; 252  : U32     lock;                           /* Lock value                */
; 253  : U32     susp;                           /* Lock suspend queue        */
; 254  : U32     lcpa;                           /* Logical CPU address       */
; 255  : VADR    newia;                          /* Unsuccessful branch addr  */
; 256  : int     acc_mode = 0;                   /* access mode to use        */

  00011	c7 44 24 20 00
	00 00 00	 mov	 DWORD PTR acc_mode$[rsp], 0

; 257  : 
; 258  :     SSE(inst, regs, b1, effective_addr1, b2, effective_addr2);

  00019	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR inst$[rsp]
  00021	48 83 c0 02	 add	 rax, 2
  00025	48 8b c8	 mov	 rcx, rax
  00028	e8 00 00 00 00	 call	 fetch_fw_noswap
  0002d	8b c8		 mov	 ecx, eax
  0002f	e8 00 00 00 00	 call	 _byteswap_ulong
  00034	89 44 24 30	 mov	 DWORD PTR temp$1[rsp], eax
  00038	8b 44 24 30	 mov	 eax, DWORD PTR temp$1[rsp]
  0003c	25 ff 0f 00 00	 and	 eax, 4095		; 00000fffH
  00041	8b c0		 mov	 eax, eax
  00043	48 89 44 24 28	 mov	 QWORD PTR effective_addr2$[rsp], rax
  00048	8b 44 24 30	 mov	 eax, DWORD PTR temp$1[rsp]
  0004c	c1 e8 0c	 shr	 eax, 12
  0004f	83 e0 0f	 and	 eax, 15
  00052	89 44 24 34	 mov	 DWORD PTR b2$[rsp], eax
  00056	8b 44 24 30	 mov	 eax, DWORD PTR temp$1[rsp]
  0005a	c1 e8 10	 shr	 eax, 16
  0005d	25 ff 0f 00 00	 and	 eax, 4095		; 00000fffH
  00062	8b c0		 mov	 eax, eax
  00064	48 89 44 24 40	 mov	 QWORD PTR effective_addr1$[rsp], rax
  00069	8b 44 24 30	 mov	 eax, DWORD PTR temp$1[rsp]
  0006d	c1 e8 1c	 shr	 eax, 28
  00070	83 e0 0f	 and	 eax, 15
  00073	89 44 24 38	 mov	 DWORD PTR b1$[rsp], eax
  00077	83 7c 24 38 00	 cmp	 DWORD PTR b1$[rsp], 0
  0007c	74 44		 je	 SHORT $LN14@z900_relea
  0007e	48 63 44 24 38	 movsxd	 rax, DWORD PTR b1$[rsp]
  00083	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0008b	48 8b 84 c1 80
	02 00 00	 mov	 rax, QWORD PTR [rcx+rax*8+640]
  00093	48 8b 4c 24 40	 mov	 rcx, QWORD PTR effective_addr1$[rsp]
  00098	48 03 c8	 add	 rcx, rax
  0009b	48 8b c1	 mov	 rax, rcx
  0009e	48 89 44 24 40	 mov	 QWORD PTR effective_addr1$[rsp], rax
  000a3	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  000ab	48 8b 80 90 00
	00 00		 mov	 rax, QWORD PTR [rax+144]
  000b2	48 8b 4c 24 40	 mov	 rcx, QWORD PTR effective_addr1$[rsp]
  000b7	48 23 c8	 and	 rcx, rax
  000ba	48 8b c1	 mov	 rax, rcx
  000bd	48 89 44 24 40	 mov	 QWORD PTR effective_addr1$[rsp], rax
$LN14@z900_relea:
  000c2	83 7c 24 34 00	 cmp	 DWORD PTR b2$[rsp], 0
  000c7	74 44		 je	 SHORT $LN15@z900_relea
  000c9	48 63 44 24 34	 movsxd	 rax, DWORD PTR b2$[rsp]
  000ce	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  000d6	48 8b 84 c1 80
	02 00 00	 mov	 rax, QWORD PTR [rcx+rax*8+640]
  000de	48 8b 4c 24 28	 mov	 rcx, QWORD PTR effective_addr2$[rsp]
  000e3	48 03 c8	 add	 rcx, rax
  000e6	48 8b c1	 mov	 rax, rcx
  000e9	48 89 44 24 28	 mov	 QWORD PTR effective_addr2$[rsp], rax
  000ee	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  000f6	48 8b 80 90 00
	00 00		 mov	 rax, QWORD PTR [rax+144]
  000fd	48 8b 4c 24 28	 mov	 rcx, QWORD PTR effective_addr2$[rsp]
  00102	48 23 c8	 and	 rcx, rax
  00105	48 8b c1	 mov	 rax, rcx
  00108	48 89 44 24 28	 mov	 QWORD PTR effective_addr2$[rsp], rax
$LN15@z900_relea:
$LN4@z900_relea:
  0010d	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00115	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  00119	48 83 c0 06	 add	 rax, 6
  0011d	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00125	48 89 41 68	 mov	 QWORD PTR [rcx+104], rax
  00129	33 c0		 xor	 eax, eax
  0012b	83 f8 06	 cmp	 eax, 6
  0012e	74 0f		 je	 SHORT $LN16@z900_relea
  00130	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00138	c6 80 9a 00 00
	00 06		 mov	 BYTE PTR [rax+154], 6
$LN16@z900_relea:
  0013f	33 c0		 xor	 eax, eax
  00141	85 c0		 test	 eax, eax
  00143	75 c8		 jne	 SHORT $LN4@z900_relea

; 259  :     PER_ZEROADDR_XCHECK2( regs, b1, b2 );

  00145	44 8b 44 24 34	 mov	 r8d, DWORD PTR b2$[rsp]
  0014a	8b 54 24 38	 mov	 edx, DWORD PTR b1$[rsp]
  0014e	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00156	e8 00 00 00 00	 call	 z900_per3_zero_xcheck2

; 260  : 
; 261  :     GUEST_CHECK( );

  0015b	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00163	0f b6 40 7a	 movzx	 eax, BYTE PTR [rax+122]
  00167	83 e0 01	 and	 eax, 1
  0016a	85 c0		 test	 eax, eax
  0016c	74 50		 je	 SHORT $LN17@z900_relea
  0016e	b8 08 00 00 00	 mov	 eax, 8
  00173	48 6b c0 07	 imul	 rax, rax, 7
  00177	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0017f	8b 84 01 00 06
	00 00		 mov	 eax, DWORD PTR [rcx+rax+1536]
  00186	25 04 00 00 40	 and	 eax, 1073741828		; 40000004H
  0018b	83 f8 04	 cmp	 eax, 4
  0018e	74 2e		 je	 SHORT $LN18@z900_relea
  00190	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00198	0f b6 40 7a	 movzx	 eax, BYTE PTR [rax+122]
  0019c	83 e0 01	 and	 eax, 1
  0019f	85 c0		 test	 eax, eax
  001a1	74 1b		 je	 SHORT $LN19@z900_relea
  001a3	ba 02 00 00 00	 mov	 edx, 2
  001a8	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  001b0	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  001b8	ff 90 20 0d 00
	00		 call	 QWORD PTR [rax+3360]
$LN19@z900_relea:
$LN18@z900_relea:
$LN17@z900_relea:

; 262  : 
; 263  :     /* Specification exception if operands are not on word boundary */
; 264  :     if ((effective_addr1 & 0x00000003) || (effective_addr2 & 0x00000003))

  001be	48 8b 44 24 40	 mov	 rax, QWORD PTR effective_addr1$[rsp]
  001c3	48 83 e0 03	 and	 rax, 3
  001c7	48 85 c0	 test	 rax, rax
  001ca	75 0e		 jne	 SHORT $LN21@z900_relea
  001cc	48 8b 44 24 28	 mov	 rax, QWORD PTR effective_addr2$[rsp]
  001d1	48 83 e0 03	 and	 rax, 3
  001d5	48 85 c0	 test	 rax, rax
  001d8	74 12		 je	 SHORT $LN20@z900_relea
$LN21@z900_relea:

; 265  :         ARCH_DEP(program_interrupt) (regs, PGM_SPECIFICATION_EXCEPTION);

  001da	ba 06 00 00 00	 mov	 edx, 6
  001df	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  001e7	e8 00 00 00 00	 call	 z900_program_interrupt
$LN20@z900_relea:
$LN7@z900_relea:

; 266  : 
; 267  :     /* Obtain main-storage access lock */
; 268  :     OBTAIN_MAINLOCK_UNCONDITIONAL(regs);

  001ec	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  001f4	48 8b 80 68 08
	00 00		 mov	 rax, QWORD PTR [rax+2152]
  001fb	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00203	48 8b 49 40	 mov	 rcx, QWORD PTR [rcx+64]
  00207	48 8b 89 b0 12
	00 00		 mov	 rcx, QWORD PTR [rcx+4784]
  0020e	48 39 48 50	 cmp	 QWORD PTR [rax+80], rcx
  00212	74 4b		 je	 SHORT $LN22@z900_relea
  00214	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0021c	48 8b 40 40	 mov	 rax, QWORD PTR [rax+64]
  00220	48 05 68 10 00
	00		 add	 rax, 4200		; 00001068H
  00226	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG193469
  0022d	48 8b c8	 mov	 rcx, rax
  00230	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_obtain_lock
  00236	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0023e	48 8b 80 68 08
	00 00		 mov	 rax, QWORD PTR [rax+2152]
  00245	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0024d	48 8b 49 40	 mov	 rcx, QWORD PTR [rcx+64]
  00251	0f b7 80 3c 08
	00 00		 movzx	 eax, WORD PTR [rax+2108]
  00258	66 89 81 60 10
	00 00		 mov	 WORD PTR [rcx+4192], ax
$LN22@z900_relea:
  0025f	33 c0		 xor	 eax, eax
  00261	85 c0		 test	 eax, eax
  00263	75 87		 jne	 SHORT $LN7@z900_relea

; 269  : 
; 270  :     if (ACCESS_REGISTER_MODE(&regs->psw))

  00265	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0026d	0f b6 40 7b	 movzx	 eax, BYTE PTR [rax+123]
  00271	83 f8 40	 cmp	 eax, 64			; 00000040H
  00274	75 08		 jne	 SHORT $LN23@z900_relea

; 271  :         acc_mode = USE_PRIMARY_SPACE;

  00276	c7 44 24 20 fd
	ff ff ff	 mov	 DWORD PTR acc_mode$[rsp], -3
$LN23@z900_relea:

; 272  : 
; 273  :     /* Load ASCB address from first operand location */
; 274  :     ascb_addr = ARCH_DEP(vfetch4) ( effective_addr1, acc_mode, regs );

  0027e	4c 8b 84 24 98
	00 00 00	 mov	 r8, QWORD PTR regs$[rsp]
  00286	8b 54 24 20	 mov	 edx, DWORD PTR acc_mode$[rsp]
  0028a	48 8b 4c 24 40	 mov	 rcx, QWORD PTR effective_addr1$[rsp]
  0028f	e8 00 00 00 00	 call	 z900_vfetch4
  00294	8b c0		 mov	 eax, eax
  00296	48 89 44 24 60	 mov	 QWORD PTR ascb_addr$[rsp], rax

; 275  : 
; 276  :     /* Load locks held bits from second operand location */
; 277  :     hlhi_word = ARCH_DEP(vfetch4) ( effective_addr2, acc_mode, regs );

  0029b	4c 8b 84 24 98
	00 00 00	 mov	 r8, QWORD PTR regs$[rsp]
  002a3	8b 54 24 20	 mov	 edx, DWORD PTR acc_mode$[rsp]
  002a7	48 8b 4c 24 28	 mov	 rcx, QWORD PTR effective_addr2$[rsp]
  002ac	e8 00 00 00 00	 call	 z900_vfetch4
  002b1	89 44 24 24	 mov	 DWORD PTR hlhi_word$[rsp], eax

; 278  : 
; 279  :     /* Fetch our logical CPU address from PSALCPUA */
; 280  :     lcpa = ARCH_DEP(vfetch4) ( effective_addr2 - 4, acc_mode, regs );

  002b5	48 8b 44 24 28	 mov	 rax, QWORD PTR effective_addr2$[rsp]
  002ba	48 83 e8 04	 sub	 rax, 4
  002be	4c 8b 84 24 98
	00 00 00	 mov	 r8, QWORD PTR regs$[rsp]
  002c6	8b 54 24 20	 mov	 edx, DWORD PTR acc_mode$[rsp]
  002ca	48 8b c8	 mov	 rcx, rax
  002cd	e8 00 00 00 00	 call	 z900_vfetch4
  002d2	89 44 24 48	 mov	 DWORD PTR lcpa$[rsp], eax

; 281  : 
; 282  :     /* Fetch the local lock and the suspend queue from the ASCB */
; 283  :     lock_addr = (ascb_addr + ASCBLOCK) & ADDRESS_MAXWRAP(regs);

  002d6	48 8b 44 24 60	 mov	 rax, QWORD PTR ascb_addr$[rsp]
  002db	48 05 80 00 00
	00		 add	 rax, 128		; 00000080H
  002e1	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  002e9	48 23 81 90 00
	00 00		 and	 rax, QWORD PTR [rcx+144]
  002f0	48 89 44 24 68	 mov	 QWORD PTR lock_addr$[rsp], rax

; 284  :     susp_addr = (ascb_addr + ASCBLSWQ) & ADDRESS_MAXWRAP(regs);

  002f5	48 8b 44 24 60	 mov	 rax, QWORD PTR ascb_addr$[rsp]
  002fa	48 05 84 00 00
	00		 add	 rax, 132		; 00000084H
  00300	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00308	48 23 81 90 00
	00 00		 and	 rax, QWORD PTR [rcx+144]
  0030f	48 89 44 24 78	 mov	 QWORD PTR susp_addr$[rsp], rax

; 285  :     lock = ARCH_DEP(vfetch4) ( lock_addr, acc_mode, regs );

  00314	4c 8b 84 24 98
	00 00 00	 mov	 r8, QWORD PTR regs$[rsp]
  0031c	8b 54 24 20	 mov	 edx, DWORD PTR acc_mode$[rsp]
  00320	48 8b 4c 24 68	 mov	 rcx, QWORD PTR lock_addr$[rsp]
  00325	e8 00 00 00 00	 call	 z900_vfetch4
  0032a	89 44 24 4c	 mov	 DWORD PTR lock$[rsp], eax

; 286  :     susp = ARCH_DEP(vfetch4) ( susp_addr, acc_mode, regs );

  0032e	4c 8b 84 24 98
	00 00 00	 mov	 r8, QWORD PTR regs$[rsp]
  00336	8b 54 24 20	 mov	 edx, DWORD PTR acc_mode$[rsp]
  0033a	48 8b 4c 24 78	 mov	 rcx, QWORD PTR susp_addr$[rsp]
  0033f	e8 00 00 00 00	 call	 z900_vfetch4
  00344	89 44 24 50	 mov	 DWORD PTR susp$[rsp], eax

; 287  : 
; 288  :     /* Test if this CPU holds the local lock, and does not hold
; 289  :        any CMS lock, and the local lock suspend queue is empty */
; 290  :     if (lock == lcpa
; 291  :         && (hlhi_word & (PSALCLLI | PSACMSLI)) == PSALCLLI
; 292  :         && susp == 0)

  00348	8b 44 24 48	 mov	 eax, DWORD PTR lcpa$[rsp]
  0034c	39 44 24 4c	 cmp	 DWORD PTR lock$[rsp], eax
  00350	0f 85 92 00 00
	00		 jne	 $LN24@z900_relea
  00356	8b 44 24 24	 mov	 eax, DWORD PTR hlhi_word$[rsp]
  0035a	83 e0 03	 and	 eax, 3
  0035d	83 f8 01	 cmp	 eax, 1
  00360	0f 85 82 00 00
	00		 jne	 $LN24@z900_relea
  00366	83 7c 24 50 00	 cmp	 DWORD PTR susp$[rsp], 0
  0036b	75 7b		 jne	 SHORT $LN24@z900_relea

; 293  :     {
; 294  :         /* Store the unchanged value into the second operand to
; 295  :            ensure suppression in the event of an access exception */
; 296  :         ARCH_DEP(vstore4) ( hlhi_word, effective_addr2, acc_mode, regs );

  0036d	4c 8b 8c 24 98
	00 00 00	 mov	 r9, QWORD PTR regs$[rsp]
  00375	44 8b 44 24 20	 mov	 r8d, DWORD PTR acc_mode$[rsp]
  0037a	48 8b 54 24 28	 mov	 rdx, QWORD PTR effective_addr2$[rsp]
  0037f	8b 4c 24 24	 mov	 ecx, DWORD PTR hlhi_word$[rsp]
  00383	e8 00 00 00 00	 call	 z900_vstore4

; 297  : 
; 298  :         /* Clear the local lock held bit in the second operand */
; 299  :         hlhi_word &= ~PSALCLLI;

  00388	8b 44 24 24	 mov	 eax, DWORD PTR hlhi_word$[rsp]
  0038c	83 e0 fe	 and	 eax, -2			; fffffffeH
  0038f	89 44 24 24	 mov	 DWORD PTR hlhi_word$[rsp], eax

; 300  :         ARCH_DEP(vstore4) ( hlhi_word, effective_addr2, acc_mode, regs );

  00393	4c 8b 8c 24 98
	00 00 00	 mov	 r9, QWORD PTR regs$[rsp]
  0039b	44 8b 44 24 20	 mov	 r8d, DWORD PTR acc_mode$[rsp]
  003a0	48 8b 54 24 28	 mov	 rdx, QWORD PTR effective_addr2$[rsp]
  003a5	8b 4c 24 24	 mov	 ecx, DWORD PTR hlhi_word$[rsp]
  003a9	e8 00 00 00 00	 call	 z900_vstore4

; 301  : 
; 302  :         /* Set the local lock to zero */
; 303  :         ARCH_DEP(vstore4) ( 0, lock_addr, acc_mode, regs );

  003ae	4c 8b 8c 24 98
	00 00 00	 mov	 r9, QWORD PTR regs$[rsp]
  003b6	44 8b 44 24 20	 mov	 r8d, DWORD PTR acc_mode$[rsp]
  003bb	48 8b 54 24 68	 mov	 rdx, QWORD PTR lock_addr$[rsp]
  003c0	33 c9		 xor	 ecx, ecx
  003c2	e8 00 00 00 00	 call	 z900_vstore4

; 304  : 
; 305  :         /* Set register 13 to zero to indicate lock released */
; 306  :         regs->GR_L(13) = 0;

  003c7	b8 08 00 00 00	 mov	 eax, 8
  003cc	48 6b c0 0d	 imul	 rax, rax, 13
  003d0	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  003d8	c7 84 01 80 02
	00 00 00 00 00
	00		 mov	 DWORD PTR [rcx+rax+640], 0

; 307  :     }

  003e3	e9 8f 01 00 00	 jmp	 $LN25@z900_relea
$LN24@z900_relea:

; 308  :     else
; 309  :     {
; 310  :         /* Fetch the lock interface table address from the
; 311  :            second word of the second operand, and load the
; 312  :            new instruction address and amode from LITRLOC */
; 313  :         lit_addr = ARCH_DEP(vfetch4) ( effective_addr2 + 4, acc_mode, regs ) + LITRLOC;

  003e8	48 8b 44 24 28	 mov	 rax, QWORD PTR effective_addr2$[rsp]
  003ed	48 83 c0 04	 add	 rax, 4
  003f1	4c 8b 84 24 98
	00 00 00	 mov	 r8, QWORD PTR regs$[rsp]
  003f9	8b 54 24 20	 mov	 edx, DWORD PTR acc_mode$[rsp]
  003fd	48 8b c8	 mov	 rcx, rax
  00400	e8 00 00 00 00	 call	 z900_vfetch4
  00405	83 c0 f4	 add	 eax, -12		; fffffff4H
  00408	8b c0		 mov	 eax, eax
  0040a	48 89 44 24 58	 mov	 QWORD PTR lit_addr$[rsp], rax

; 314  :         lit_addr &= ADDRESS_MAXWRAP(regs);

  0040f	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00417	48 8b 80 90 00
	00 00		 mov	 rax, QWORD PTR [rax+144]
  0041e	48 8b 4c 24 58	 mov	 rcx, QWORD PTR lit_addr$[rsp]
  00423	48 23 c8	 and	 rcx, rax
  00426	48 8b c1	 mov	 rax, rcx
  00429	48 89 44 24 58	 mov	 QWORD PTR lit_addr$[rsp], rax

; 315  :         newia = ARCH_DEP(vfetch4) ( lit_addr, acc_mode, regs );

  0042e	4c 8b 84 24 98
	00 00 00	 mov	 r8, QWORD PTR regs$[rsp]
  00436	8b 54 24 20	 mov	 edx, DWORD PTR acc_mode$[rsp]
  0043a	48 8b 4c 24 58	 mov	 rcx, QWORD PTR lit_addr$[rsp]
  0043f	e8 00 00 00 00	 call	 z900_vfetch4
  00444	8b c0		 mov	 eax, eax
  00446	48 89 44 24 70	 mov	 QWORD PTR newia$[rsp], rax

; 316  : 
; 317  :         /* Save the link information in register 12 */
; 318  :         regs->GR_L(12) = PSW_IA_FROM_IP(regs, 0);

  0044b	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00453	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0045b	48 8b 89 00 02
	00 00		 mov	 rcx, QWORD PTR [rcx+512]
  00462	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  00466	48 2b c1	 sub	 rax, rcx
  00469	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00471	48 8b 89 10 02
	00 00		 mov	 rcx, QWORD PTR [rcx+528]
  00478	48 03 c8	 add	 rcx, rax
  0047b	48 8b c1	 mov	 rax, rcx
  0047e	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00486	48 23 81 90 00
	00 00		 and	 rax, QWORD PTR [rcx+144]
  0048d	b9 08 00 00 00	 mov	 ecx, 8
  00492	48 6b c9 0c	 imul	 rcx, rcx, 12
  00496	48 8b 94 24 98
	00 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  0049e	89 84 0a 80 02
	00 00		 mov	 DWORD PTR [rdx+rcx+640], eax

; 319  : 
; 320  :         /* Copy LITRLOC into register 13 to signify release failure */
; 321  :         regs->GR_L(13) = newia;

  004a5	b8 08 00 00 00	 mov	 eax, 8
  004aa	48 6b c0 0d	 imul	 rax, rax, 13
  004ae	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  004b6	8b 54 24 70	 mov	 edx, DWORD PTR newia$[rsp]
  004ba	89 94 01 80 02
	00 00		 mov	 DWORD PTR [rcx+rax+640], edx
$LN10@z900_relea:

; 322  : 
; 323  :         /* Update the PSW instruction address */
; 324  :         SET_PSW_IA_AND_MAYBE_IP(regs, newia);

  004c1	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  004c9	48 8b 80 90 00
	00 00		 mov	 rax, QWORD PTR [rax+144]
  004d0	48 8b 4c 24 70	 mov	 rcx, QWORD PTR newia$[rsp]
  004d5	48 23 c8	 and	 rcx, rax
  004d8	48 8b c1	 mov	 rax, rcx
  004db	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  004e3	48 89 81 88 00
	00 00		 mov	 QWORD PTR [rcx+136], rax
  004ea	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  004f2	48 83 b8 08 02
	00 00 00	 cmp	 QWORD PTR [rax+520], 0
  004fa	74 71		 je	 SHORT $LN26@z900_relea
  004fc	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00504	48 8b 80 88 00
	00 00		 mov	 rax, QWORD PTR [rax+136]
  0050b	48 25 01 f0 ff
	ff		 and	 rax, -4095		; fffffffffffff001H
  00511	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00519	48 39 81 10 02
	00 00		 cmp	 QWORD PTR [rcx+528], rax
  00520	75 38		 jne	 SHORT $LN27@z900_relea
  00522	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0052a	48 8b 80 88 00
	00 00		 mov	 rax, QWORD PTR [rax+136]
  00531	48 25 ff 0f 00
	00		 and	 rax, 4095		; 00000fffH
  00537	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0053f	48 8b 89 00 02
	00 00		 mov	 rcx, QWORD PTR [rcx+512]
  00546	48 0b c8	 or	 rcx, rax
  00549	48 8b c1	 mov	 rax, rcx
  0054c	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00554	48 89 41 68	 mov	 QWORD PTR [rcx+104], rax
  00558	eb 13		 jmp	 SHORT $LN28@z900_relea
$LN27@z900_relea:
  0055a	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00562	48 c7 80 08 02
	00 00 00 00 00
	00		 mov	 QWORD PTR [rax+520], 0
$LN28@z900_relea:
$LN26@z900_relea:
  0056d	33 c0		 xor	 eax, eax
  0056f	85 c0		 test	 eax, eax
  00571	0f 85 4a ff ff
	ff		 jne	 $LN10@z900_relea
$LN25@z900_relea:
$LN13@z900_relea:

; 325  :     }
; 326  : 
; 327  :     /* Release main-storage access lock */
; 328  :     RELEASE_MAINLOCK_UNCONDITIONAL(regs);

  00577	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0057f	48 8b 40 40	 mov	 rax, QWORD PTR [rax+64]
  00583	0f b7 80 60 10
	00 00		 movzx	 eax, WORD PTR [rax+4192]
  0058a	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00592	48 8b 89 68 08
	00 00		 mov	 rcx, QWORD PTR [rcx+2152]
  00599	0f b7 89 3c 08
	00 00		 movzx	 ecx, WORD PTR [rcx+2108]
  005a0	3b c1		 cmp	 eax, ecx
  005a2	75 3a		 jne	 SHORT $LN29@z900_relea
  005a4	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  005ac	48 8b 40 40	 mov	 rax, QWORD PTR [rax+64]
  005b0	b9 ff ff 00 00	 mov	 ecx, 65535		; 0000ffffH
  005b5	66 89 88 60 10
	00 00		 mov	 WORD PTR [rax+4192], cx
  005bc	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  005c4	48 8b 40 40	 mov	 rax, QWORD PTR [rax+64]
  005c8	48 05 68 10 00
	00		 add	 rax, 4200		; 00001068H
  005ce	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG193477
  005d5	48 8b c8	 mov	 rcx, rax
  005d8	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_release_lock
$LN29@z900_relea:
  005de	33 c0		 xor	 eax, eax
  005e0	85 c0		 test	 eax, eax
  005e2	75 93		 jne	 SHORT $LN13@z900_relea

; 329  : 
; 330  : } /* end function release_local_lock */

  005e4	48 81 c4 88 00
	00 00		 add	 rsp, 136		; 00000088H
  005eb	c3		 ret	 0
z900_release_local_lock ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\assist.c
_TEXT	SEGMENT
acc_mode$ = 32
hlhi_word$ = 36
temp$1 = 40
effective_addr2$ = 48
b2$ = 56
b1$ = 60
effective_addr1$ = 64
lock$ = 72
susp$ = 76
lock_addr$ = 80
lit_addr$ = 88
newia$ = 96
lock_arn$ = 104
ascb_addr$ = 112
inst$ = 144
regs$ = 152
z900_release_cms_lock PROC

; 447  : {

$LN31:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 81 ec 88 00
	00 00		 sub	 rsp, 136		; 00000088H

; 448  : int     b1, b2;                         /* Values of base field      */
; 449  : VADR    effective_addr1,
; 450  :         effective_addr2;                /* Effective addresses       */
; 451  : VADR    ascb_addr;                      /* Virtual address of ASCB   */
; 452  : U32     hlhi_word;                      /* Highest lock held word    */
; 453  : VADR    lit_addr;                       /* Virtual address of lock
; 454  :                                            interface table           */
; 455  : VADR    lock_addr;                      /* Lock address              */
; 456  : int     lock_arn;                       /* Lock access register      */
; 457  : U32     lock;                           /* Lock value                */
; 458  : U32     susp;                           /* Lock suspend queue        */
; 459  : VADR    newia;                          /* Unsuccessful branch addr  */
; 460  : int     acc_mode = 0;                   /* access mode to use        */

  00011	c7 44 24 20 00
	00 00 00	 mov	 DWORD PTR acc_mode$[rsp], 0

; 461  : 
; 462  :     SSE(inst, regs, b1, effective_addr1, b2, effective_addr2);

  00019	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR inst$[rsp]
  00021	48 83 c0 02	 add	 rax, 2
  00025	48 8b c8	 mov	 rcx, rax
  00028	e8 00 00 00 00	 call	 fetch_fw_noswap
  0002d	8b c8		 mov	 ecx, eax
  0002f	e8 00 00 00 00	 call	 _byteswap_ulong
  00034	89 44 24 28	 mov	 DWORD PTR temp$1[rsp], eax
  00038	8b 44 24 28	 mov	 eax, DWORD PTR temp$1[rsp]
  0003c	25 ff 0f 00 00	 and	 eax, 4095		; 00000fffH
  00041	8b c0		 mov	 eax, eax
  00043	48 89 44 24 30	 mov	 QWORD PTR effective_addr2$[rsp], rax
  00048	8b 44 24 28	 mov	 eax, DWORD PTR temp$1[rsp]
  0004c	c1 e8 0c	 shr	 eax, 12
  0004f	83 e0 0f	 and	 eax, 15
  00052	89 44 24 38	 mov	 DWORD PTR b2$[rsp], eax
  00056	8b 44 24 28	 mov	 eax, DWORD PTR temp$1[rsp]
  0005a	c1 e8 10	 shr	 eax, 16
  0005d	25 ff 0f 00 00	 and	 eax, 4095		; 00000fffH
  00062	8b c0		 mov	 eax, eax
  00064	48 89 44 24 40	 mov	 QWORD PTR effective_addr1$[rsp], rax
  00069	8b 44 24 28	 mov	 eax, DWORD PTR temp$1[rsp]
  0006d	c1 e8 1c	 shr	 eax, 28
  00070	83 e0 0f	 and	 eax, 15
  00073	89 44 24 3c	 mov	 DWORD PTR b1$[rsp], eax
  00077	83 7c 24 3c 00	 cmp	 DWORD PTR b1$[rsp], 0
  0007c	74 44		 je	 SHORT $LN14@z900_relea
  0007e	48 63 44 24 3c	 movsxd	 rax, DWORD PTR b1$[rsp]
  00083	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0008b	48 8b 84 c1 80
	02 00 00	 mov	 rax, QWORD PTR [rcx+rax*8+640]
  00093	48 8b 4c 24 40	 mov	 rcx, QWORD PTR effective_addr1$[rsp]
  00098	48 03 c8	 add	 rcx, rax
  0009b	48 8b c1	 mov	 rax, rcx
  0009e	48 89 44 24 40	 mov	 QWORD PTR effective_addr1$[rsp], rax
  000a3	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  000ab	48 8b 80 90 00
	00 00		 mov	 rax, QWORD PTR [rax+144]
  000b2	48 8b 4c 24 40	 mov	 rcx, QWORD PTR effective_addr1$[rsp]
  000b7	48 23 c8	 and	 rcx, rax
  000ba	48 8b c1	 mov	 rax, rcx
  000bd	48 89 44 24 40	 mov	 QWORD PTR effective_addr1$[rsp], rax
$LN14@z900_relea:
  000c2	83 7c 24 38 00	 cmp	 DWORD PTR b2$[rsp], 0
  000c7	74 44		 je	 SHORT $LN15@z900_relea
  000c9	48 63 44 24 38	 movsxd	 rax, DWORD PTR b2$[rsp]
  000ce	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  000d6	48 8b 84 c1 80
	02 00 00	 mov	 rax, QWORD PTR [rcx+rax*8+640]
  000de	48 8b 4c 24 30	 mov	 rcx, QWORD PTR effective_addr2$[rsp]
  000e3	48 03 c8	 add	 rcx, rax
  000e6	48 8b c1	 mov	 rax, rcx
  000e9	48 89 44 24 30	 mov	 QWORD PTR effective_addr2$[rsp], rax
  000ee	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  000f6	48 8b 80 90 00
	00 00		 mov	 rax, QWORD PTR [rax+144]
  000fd	48 8b 4c 24 30	 mov	 rcx, QWORD PTR effective_addr2$[rsp]
  00102	48 23 c8	 and	 rcx, rax
  00105	48 8b c1	 mov	 rax, rcx
  00108	48 89 44 24 30	 mov	 QWORD PTR effective_addr2$[rsp], rax
$LN15@z900_relea:
$LN4@z900_relea:
  0010d	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00115	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  00119	48 83 c0 06	 add	 rax, 6
  0011d	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00125	48 89 41 68	 mov	 QWORD PTR [rcx+104], rax
  00129	33 c0		 xor	 eax, eax
  0012b	83 f8 06	 cmp	 eax, 6
  0012e	74 0f		 je	 SHORT $LN16@z900_relea
  00130	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00138	c6 80 9a 00 00
	00 06		 mov	 BYTE PTR [rax+154], 6
$LN16@z900_relea:
  0013f	33 c0		 xor	 eax, eax
  00141	85 c0		 test	 eax, eax
  00143	75 c8		 jne	 SHORT $LN4@z900_relea

; 463  :     PER_ZEROADDR_XCHECK2( regs, b1, b2 );

  00145	44 8b 44 24 38	 mov	 r8d, DWORD PTR b2$[rsp]
  0014a	8b 54 24 3c	 mov	 edx, DWORD PTR b1$[rsp]
  0014e	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00156	e8 00 00 00 00	 call	 z900_per3_zero_xcheck2

; 464  : 
; 465  :     GUEST_CHECK( );

  0015b	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00163	0f b6 40 7a	 movzx	 eax, BYTE PTR [rax+122]
  00167	83 e0 01	 and	 eax, 1
  0016a	85 c0		 test	 eax, eax
  0016c	74 50		 je	 SHORT $LN17@z900_relea
  0016e	b8 08 00 00 00	 mov	 eax, 8
  00173	48 6b c0 07	 imul	 rax, rax, 7
  00177	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0017f	8b 84 01 00 06
	00 00		 mov	 eax, DWORD PTR [rcx+rax+1536]
  00186	25 04 00 00 40	 and	 eax, 1073741828		; 40000004H
  0018b	83 f8 04	 cmp	 eax, 4
  0018e	74 2e		 je	 SHORT $LN18@z900_relea
  00190	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00198	0f b6 40 7a	 movzx	 eax, BYTE PTR [rax+122]
  0019c	83 e0 01	 and	 eax, 1
  0019f	85 c0		 test	 eax, eax
  001a1	74 1b		 je	 SHORT $LN19@z900_relea
  001a3	ba 02 00 00 00	 mov	 edx, 2
  001a8	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  001b0	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  001b8	ff 90 20 0d 00
	00		 call	 QWORD PTR [rax+3360]
$LN19@z900_relea:
$LN18@z900_relea:
$LN17@z900_relea:

; 466  : 
; 467  :     /* Specification exception if operands are not on word boundary */
; 468  :     if ((effective_addr1 & 0x00000003) || (effective_addr2 & 0x00000003))

  001be	48 8b 44 24 40	 mov	 rax, QWORD PTR effective_addr1$[rsp]
  001c3	48 83 e0 03	 and	 rax, 3
  001c7	48 85 c0	 test	 rax, rax
  001ca	75 0e		 jne	 SHORT $LN21@z900_relea
  001cc	48 8b 44 24 30	 mov	 rax, QWORD PTR effective_addr2$[rsp]
  001d1	48 83 e0 03	 and	 rax, 3
  001d5	48 85 c0	 test	 rax, rax
  001d8	74 12		 je	 SHORT $LN20@z900_relea
$LN21@z900_relea:

; 469  :         ARCH_DEP(program_interrupt) (regs, PGM_SPECIFICATION_EXCEPTION);

  001da	ba 06 00 00 00	 mov	 edx, 6
  001df	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  001e7	e8 00 00 00 00	 call	 z900_program_interrupt
$LN20@z900_relea:

; 470  : 
; 471  :     /* General register 11 contains the lock address */
; 472  :     lock_addr = regs->GR_L(11) & ADDRESS_MAXWRAP(regs);

  001ec	b8 08 00 00 00	 mov	 eax, 8
  001f1	48 6b c0 0b	 imul	 rax, rax, 11
  001f5	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  001fd	8b 84 01 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax+640]
  00204	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0020c	48 23 81 90 00
	00 00		 and	 rax, QWORD PTR [rcx+144]
  00213	48 89 44 24 50	 mov	 QWORD PTR lock_addr$[rsp], rax

; 473  :     lock_arn = 11;

  00218	c7 44 24 68 0b
	00 00 00	 mov	 DWORD PTR lock_arn$[rsp], 11
$LN7@z900_relea:

; 474  : 
; 475  :     /* Obtain main-storage access lock */
; 476  :     OBTAIN_MAINLOCK_UNCONDITIONAL(regs);

  00220	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00228	48 8b 80 68 08
	00 00		 mov	 rax, QWORD PTR [rax+2152]
  0022f	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00237	48 8b 49 40	 mov	 rcx, QWORD PTR [rcx+64]
  0023b	48 8b 89 b0 12
	00 00		 mov	 rcx, QWORD PTR [rcx+4784]
  00242	48 39 48 50	 cmp	 QWORD PTR [rax+80], rcx
  00246	74 4b		 je	 SHORT $LN22@z900_relea
  00248	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00250	48 8b 40 40	 mov	 rax, QWORD PTR [rax+64]
  00254	48 05 68 10 00
	00		 add	 rax, 4200		; 00001068H
  0025a	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG193581
  00261	48 8b c8	 mov	 rcx, rax
  00264	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_obtain_lock
  0026a	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00272	48 8b 80 68 08
	00 00		 mov	 rax, QWORD PTR [rax+2152]
  00279	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00281	48 8b 49 40	 mov	 rcx, QWORD PTR [rcx+64]
  00285	0f b7 80 3c 08
	00 00		 movzx	 eax, WORD PTR [rax+2108]
  0028c	66 89 81 60 10
	00 00		 mov	 WORD PTR [rcx+4192], ax
$LN22@z900_relea:
  00293	33 c0		 xor	 eax, eax
  00295	85 c0		 test	 eax, eax
  00297	75 87		 jne	 SHORT $LN7@z900_relea

; 477  : 
; 478  :     if (ACCESS_REGISTER_MODE(&regs->psw))

  00299	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  002a1	0f b6 40 7b	 movzx	 eax, BYTE PTR [rax+123]
  002a5	83 f8 40	 cmp	 eax, 64			; 00000040H
  002a8	75 08		 jne	 SHORT $LN23@z900_relea

; 479  :         acc_mode = USE_PRIMARY_SPACE;

  002aa	c7 44 24 20 fd
	ff ff ff	 mov	 DWORD PTR acc_mode$[rsp], -3
$LN23@z900_relea:

; 480  : 
; 481  :     /* Load ASCB address from first operand location */
; 482  :     ascb_addr = ARCH_DEP(vfetch4) ( effective_addr1, acc_mode, regs );

  002b2	4c 8b 84 24 98
	00 00 00	 mov	 r8, QWORD PTR regs$[rsp]
  002ba	8b 54 24 20	 mov	 edx, DWORD PTR acc_mode$[rsp]
  002be	48 8b 4c 24 40	 mov	 rcx, QWORD PTR effective_addr1$[rsp]
  002c3	e8 00 00 00 00	 call	 z900_vfetch4
  002c8	8b c0		 mov	 eax, eax
  002ca	48 89 44 24 70	 mov	 QWORD PTR ascb_addr$[rsp], rax

; 483  : 
; 484  :     /* Load locks held bits from second operand location */
; 485  :     hlhi_word = ARCH_DEP(vfetch4) ( effective_addr2, acc_mode, regs );

  002cf	4c 8b 84 24 98
	00 00 00	 mov	 r8, QWORD PTR regs$[rsp]
  002d7	8b 54 24 20	 mov	 edx, DWORD PTR acc_mode$[rsp]
  002db	48 8b 4c 24 30	 mov	 rcx, QWORD PTR effective_addr2$[rsp]
  002e0	e8 00 00 00 00	 call	 z900_vfetch4
  002e5	89 44 24 24	 mov	 DWORD PTR hlhi_word$[rsp], eax

; 486  : 
; 487  :     /* Fetch the CMS lock and the suspend queue word */
; 488  :     lock = ARCH_DEP(vfetch4) ( lock_addr, acc_mode, regs );

  002e9	4c 8b 84 24 98
	00 00 00	 mov	 r8, QWORD PTR regs$[rsp]
  002f1	8b 54 24 20	 mov	 edx, DWORD PTR acc_mode$[rsp]
  002f5	48 8b 4c 24 50	 mov	 rcx, QWORD PTR lock_addr$[rsp]
  002fa	e8 00 00 00 00	 call	 z900_vfetch4
  002ff	89 44 24 48	 mov	 DWORD PTR lock$[rsp], eax

; 489  :     susp = ARCH_DEP(vfetch4) ( lock_addr + 4, acc_mode, regs );

  00303	48 8b 44 24 50	 mov	 rax, QWORD PTR lock_addr$[rsp]
  00308	48 83 c0 04	 add	 rax, 4
  0030c	4c 8b 84 24 98
	00 00 00	 mov	 r8, QWORD PTR regs$[rsp]
  00314	8b 54 24 20	 mov	 edx, DWORD PTR acc_mode$[rsp]
  00318	48 8b c8	 mov	 rcx, rax
  0031b	e8 00 00 00 00	 call	 z900_vfetch4
  00320	89 44 24 4c	 mov	 DWORD PTR susp$[rsp], eax

; 490  : 
; 491  :     /* Test if current ASCB holds this lock, the locks held indicators
; 492  :        show a CMS lock is held, and the lock suspend queue is empty */
; 493  :     if (lock == ascb_addr
; 494  :         && (hlhi_word & PSACMSLI)
; 495  :         && susp == 0)

  00324	8b 44 24 48	 mov	 eax, DWORD PTR lock$[rsp]
  00328	48 3b 44 24 70	 cmp	 rax, QWORD PTR ascb_addr$[rsp]
  0032d	0f 85 91 00 00
	00		 jne	 $LN24@z900_relea
  00333	8b 44 24 24	 mov	 eax, DWORD PTR hlhi_word$[rsp]
  00337	83 e0 02	 and	 eax, 2
  0033a	85 c0		 test	 eax, eax
  0033c	0f 84 82 00 00
	00		 je	 $LN24@z900_relea
  00342	83 7c 24 4c 00	 cmp	 DWORD PTR susp$[rsp], 0
  00347	75 7b		 jne	 SHORT $LN24@z900_relea

; 496  :     {
; 497  :         /* Store the unchanged value into the second operand to
; 498  :            ensure suppression in the event of an access exception */
; 499  :         ARCH_DEP(vstore4) ( hlhi_word, effective_addr2, acc_mode, regs );

  00349	4c 8b 8c 24 98
	00 00 00	 mov	 r9, QWORD PTR regs$[rsp]
  00351	44 8b 44 24 20	 mov	 r8d, DWORD PTR acc_mode$[rsp]
  00356	48 8b 54 24 30	 mov	 rdx, QWORD PTR effective_addr2$[rsp]
  0035b	8b 4c 24 24	 mov	 ecx, DWORD PTR hlhi_word$[rsp]
  0035f	e8 00 00 00 00	 call	 z900_vstore4

; 500  : 
; 501  :         /* Clear the CMS lock held bit in the second operand */
; 502  :         hlhi_word &= ~PSACMSLI;

  00364	8b 44 24 24	 mov	 eax, DWORD PTR hlhi_word$[rsp]
  00368	83 e0 fd	 and	 eax, -3			; fffffffdH
  0036b	89 44 24 24	 mov	 DWORD PTR hlhi_word$[rsp], eax

; 503  :         ARCH_DEP(vstore4) ( hlhi_word, effective_addr2, acc_mode, regs );

  0036f	4c 8b 8c 24 98
	00 00 00	 mov	 r9, QWORD PTR regs$[rsp]
  00377	44 8b 44 24 20	 mov	 r8d, DWORD PTR acc_mode$[rsp]
  0037c	48 8b 54 24 30	 mov	 rdx, QWORD PTR effective_addr2$[rsp]
  00381	8b 4c 24 24	 mov	 ecx, DWORD PTR hlhi_word$[rsp]
  00385	e8 00 00 00 00	 call	 z900_vstore4

; 504  : 
; 505  :         /* Set the CMS lock to zero */
; 506  :         ARCH_DEP(vstore4) ( 0, lock_addr, acc_mode, regs );

  0038a	4c 8b 8c 24 98
	00 00 00	 mov	 r9, QWORD PTR regs$[rsp]
  00392	44 8b 44 24 20	 mov	 r8d, DWORD PTR acc_mode$[rsp]
  00397	48 8b 54 24 50	 mov	 rdx, QWORD PTR lock_addr$[rsp]
  0039c	33 c9		 xor	 ecx, ecx
  0039e	e8 00 00 00 00	 call	 z900_vstore4

; 507  : 
; 508  :         /* Set register 13 to zero to indicate lock released */
; 509  :         regs->GR_L(13) = 0;

  003a3	b8 08 00 00 00	 mov	 eax, 8
  003a8	48 6b c0 0d	 imul	 rax, rax, 13
  003ac	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  003b4	c7 84 01 80 02
	00 00 00 00 00
	00		 mov	 DWORD PTR [rcx+rax+640], 0

; 510  :     }

  003bf	e9 8f 01 00 00	 jmp	 $LN25@z900_relea
$LN24@z900_relea:

; 511  :     else
; 512  :     {
; 513  :         /* Fetch the lock interface table address from the
; 514  :            second word of the second operand, and load the
; 515  :            new instruction address and amode from LITRCMS */
; 516  :         lit_addr = ARCH_DEP(vfetch4) ( effective_addr2 + 4, acc_mode, regs ) + LITRCMS;

  003c4	48 8b 44 24 30	 mov	 rax, QWORD PTR effective_addr2$[rsp]
  003c9	48 83 c0 04	 add	 rax, 4
  003cd	4c 8b 84 24 98
	00 00 00	 mov	 r8, QWORD PTR regs$[rsp]
  003d5	8b 54 24 20	 mov	 edx, DWORD PTR acc_mode$[rsp]
  003d9	48 8b c8	 mov	 rcx, rax
  003dc	e8 00 00 00 00	 call	 z900_vfetch4
  003e1	83 c0 fc	 add	 eax, -4			; fffffffcH
  003e4	8b c0		 mov	 eax, eax
  003e6	48 89 44 24 58	 mov	 QWORD PTR lit_addr$[rsp], rax

; 517  :         lit_addr &= ADDRESS_MAXWRAP(regs);

  003eb	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  003f3	48 8b 80 90 00
	00 00		 mov	 rax, QWORD PTR [rax+144]
  003fa	48 8b 4c 24 58	 mov	 rcx, QWORD PTR lit_addr$[rsp]
  003ff	48 23 c8	 and	 rcx, rax
  00402	48 8b c1	 mov	 rax, rcx
  00405	48 89 44 24 58	 mov	 QWORD PTR lit_addr$[rsp], rax

; 518  :         newia = ARCH_DEP(vfetch4) ( lit_addr, acc_mode, regs );

  0040a	4c 8b 84 24 98
	00 00 00	 mov	 r8, QWORD PTR regs$[rsp]
  00412	8b 54 24 20	 mov	 edx, DWORD PTR acc_mode$[rsp]
  00416	48 8b 4c 24 58	 mov	 rcx, QWORD PTR lit_addr$[rsp]
  0041b	e8 00 00 00 00	 call	 z900_vfetch4
  00420	8b c0		 mov	 eax, eax
  00422	48 89 44 24 60	 mov	 QWORD PTR newia$[rsp], rax

; 519  : 
; 520  :         /* Save the link information in register 12 */
; 521  :         regs->GR_L(12) = PSW_IA_FROM_IP(regs, 0);

  00427	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0042f	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00437	48 8b 89 00 02
	00 00		 mov	 rcx, QWORD PTR [rcx+512]
  0043e	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  00442	48 2b c1	 sub	 rax, rcx
  00445	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0044d	48 8b 89 10 02
	00 00		 mov	 rcx, QWORD PTR [rcx+528]
  00454	48 03 c8	 add	 rcx, rax
  00457	48 8b c1	 mov	 rax, rcx
  0045a	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00462	48 23 81 90 00
	00 00		 and	 rax, QWORD PTR [rcx+144]
  00469	b9 08 00 00 00	 mov	 ecx, 8
  0046e	48 6b c9 0c	 imul	 rcx, rcx, 12
  00472	48 8b 94 24 98
	00 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  0047a	89 84 0a 80 02
	00 00		 mov	 DWORD PTR [rdx+rcx+640], eax

; 522  : 
; 523  :         /* Copy LITRCMS into register 13 to signify release failure */
; 524  :         regs->GR_L(13) = newia;

  00481	b8 08 00 00 00	 mov	 eax, 8
  00486	48 6b c0 0d	 imul	 rax, rax, 13
  0048a	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00492	8b 54 24 60	 mov	 edx, DWORD PTR newia$[rsp]
  00496	89 94 01 80 02
	00 00		 mov	 DWORD PTR [rcx+rax+640], edx
$LN10@z900_relea:

; 525  : 
; 526  :         /* Update the PSW instruction address */
; 527  :         SET_PSW_IA_AND_MAYBE_IP(regs, newia);

  0049d	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  004a5	48 8b 80 90 00
	00 00		 mov	 rax, QWORD PTR [rax+144]
  004ac	48 8b 4c 24 60	 mov	 rcx, QWORD PTR newia$[rsp]
  004b1	48 23 c8	 and	 rcx, rax
  004b4	48 8b c1	 mov	 rax, rcx
  004b7	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  004bf	48 89 81 88 00
	00 00		 mov	 QWORD PTR [rcx+136], rax
  004c6	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  004ce	48 83 b8 08 02
	00 00 00	 cmp	 QWORD PTR [rax+520], 0
  004d6	74 71		 je	 SHORT $LN26@z900_relea
  004d8	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  004e0	48 8b 80 88 00
	00 00		 mov	 rax, QWORD PTR [rax+136]
  004e7	48 25 01 f0 ff
	ff		 and	 rax, -4095		; fffffffffffff001H
  004ed	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  004f5	48 39 81 10 02
	00 00		 cmp	 QWORD PTR [rcx+528], rax
  004fc	75 38		 jne	 SHORT $LN27@z900_relea
  004fe	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00506	48 8b 80 88 00
	00 00		 mov	 rax, QWORD PTR [rax+136]
  0050d	48 25 ff 0f 00
	00		 and	 rax, 4095		; 00000fffH
  00513	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0051b	48 8b 89 00 02
	00 00		 mov	 rcx, QWORD PTR [rcx+512]
  00522	48 0b c8	 or	 rcx, rax
  00525	48 8b c1	 mov	 rax, rcx
  00528	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00530	48 89 41 68	 mov	 QWORD PTR [rcx+104], rax
  00534	eb 13		 jmp	 SHORT $LN28@z900_relea
$LN27@z900_relea:
  00536	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0053e	48 c7 80 08 02
	00 00 00 00 00
	00		 mov	 QWORD PTR [rax+520], 0
$LN28@z900_relea:
$LN26@z900_relea:
  00549	33 c0		 xor	 eax, eax
  0054b	85 c0		 test	 eax, eax
  0054d	0f 85 4a ff ff
	ff		 jne	 $LN10@z900_relea
$LN25@z900_relea:
$LN13@z900_relea:

; 528  :     }
; 529  : 
; 530  :     /* Release main-storage access lock */
; 531  :     RELEASE_MAINLOCK_UNCONDITIONAL(regs);

  00553	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0055b	48 8b 40 40	 mov	 rax, QWORD PTR [rax+64]
  0055f	0f b7 80 60 10
	00 00		 movzx	 eax, WORD PTR [rax+4192]
  00566	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0056e	48 8b 89 68 08
	00 00		 mov	 rcx, QWORD PTR [rcx+2152]
  00575	0f b7 89 3c 08
	00 00		 movzx	 ecx, WORD PTR [rcx+2108]
  0057c	3b c1		 cmp	 eax, ecx
  0057e	75 3a		 jne	 SHORT $LN29@z900_relea
  00580	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00588	48 8b 40 40	 mov	 rax, QWORD PTR [rax+64]
  0058c	b9 ff ff 00 00	 mov	 ecx, 65535		; 0000ffffH
  00591	66 89 88 60 10
	00 00		 mov	 WORD PTR [rax+4192], cx
  00598	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  005a0	48 8b 40 40	 mov	 rax, QWORD PTR [rax+64]
  005a4	48 05 68 10 00
	00		 add	 rax, 4200		; 00001068H
  005aa	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG193589
  005b1	48 8b c8	 mov	 rcx, rax
  005b4	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_release_lock
$LN29@z900_relea:
  005ba	33 c0		 xor	 eax, eax
  005bc	85 c0		 test	 eax, eax
  005be	75 93		 jne	 SHORT $LN13@z900_relea

; 532  : 
; 533  : } /* end function release_cms_lock */

  005c0	48 81 c4 88 00
	00 00		 add	 rsp, 136		; 00000088H
  005c7	c3		 ret	 0
z900_release_cms_lock ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\assist.c
_TEXT	SEGMENT
acc_mode$ = 48
effective_addr2$ = 56
temp$1 = 64
b2$ = 68
hlhi_word$ = 72
b1$ = 76
effective_addr1$ = 80
lcpa$ = 88
new$ = 92
old$ = 96
lit_addr$ = 104
newia$ = 112
ascb_addr$ = 120
mainstor$ = 128
inst$ = 160
regs$ = 168
z900_obtain_local_lock PROC

; 149  : {

$LN23:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 81 ec 98 00
	00 00		 sub	 rsp, 152		; 00000098H

; 150  :     int     b1, b2;                     /* Values of base field      */
; 151  :     VADR    effective_addr1,
; 152  :             effective_addr2;            /* Effective addresses       */
; 153  :     VADR    ascb_addr;                  /* Virtual address of ASCB   */
; 154  :     U32     hlhi_word;                  /* Highest lock held word    */
; 155  :     VADR    lit_addr;                   /* Virtual address of lock
; 156  :                                            interface table           */
; 157  :     U32     lcpa;                       /* Logical CPU address       */
; 158  :     VADR    newia;                      /* Unsuccessful branch addr  */
; 159  :     BYTE   *mainstor;                   /* mainstor address          */
; 160  :     U32     old;                        /* old value                 */
; 161  :     U32     new;                        /* new value                 */
; 162  :     int     acc_mode = 0;               /* access mode to use        */

  00011	c7 44 24 30 00
	00 00 00	 mov	 DWORD PTR acc_mode$[rsp], 0

; 163  : 
; 164  :     SSE(inst, regs, b1, effective_addr1, b2, effective_addr2);

  00019	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR inst$[rsp]
  00021	48 83 c0 02	 add	 rax, 2
  00025	48 8b c8	 mov	 rcx, rax
  00028	e8 00 00 00 00	 call	 fetch_fw_noswap
  0002d	8b c8		 mov	 ecx, eax
  0002f	e8 00 00 00 00	 call	 _byteswap_ulong
  00034	89 44 24 40	 mov	 DWORD PTR temp$1[rsp], eax
  00038	8b 44 24 40	 mov	 eax, DWORD PTR temp$1[rsp]
  0003c	25 ff 0f 00 00	 and	 eax, 4095		; 00000fffH
  00041	8b c0		 mov	 eax, eax
  00043	48 89 44 24 38	 mov	 QWORD PTR effective_addr2$[rsp], rax
  00048	8b 44 24 40	 mov	 eax, DWORD PTR temp$1[rsp]
  0004c	c1 e8 0c	 shr	 eax, 12
  0004f	83 e0 0f	 and	 eax, 15
  00052	89 44 24 44	 mov	 DWORD PTR b2$[rsp], eax
  00056	8b 44 24 40	 mov	 eax, DWORD PTR temp$1[rsp]
  0005a	c1 e8 10	 shr	 eax, 16
  0005d	25 ff 0f 00 00	 and	 eax, 4095		; 00000fffH
  00062	8b c0		 mov	 eax, eax
  00064	48 89 44 24 50	 mov	 QWORD PTR effective_addr1$[rsp], rax
  00069	8b 44 24 40	 mov	 eax, DWORD PTR temp$1[rsp]
  0006d	c1 e8 1c	 shr	 eax, 28
  00070	83 e0 0f	 and	 eax, 15
  00073	89 44 24 4c	 mov	 DWORD PTR b1$[rsp], eax
  00077	83 7c 24 4c 00	 cmp	 DWORD PTR b1$[rsp], 0
  0007c	74 44		 je	 SHORT $LN8@z900_obtai
  0007e	48 63 44 24 4c	 movsxd	 rax, DWORD PTR b1$[rsp]
  00083	48 8b 8c 24 a8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0008b	48 8b 84 c1 80
	02 00 00	 mov	 rax, QWORD PTR [rcx+rax*8+640]
  00093	48 8b 4c 24 50	 mov	 rcx, QWORD PTR effective_addr1$[rsp]
  00098	48 03 c8	 add	 rcx, rax
  0009b	48 8b c1	 mov	 rax, rcx
  0009e	48 89 44 24 50	 mov	 QWORD PTR effective_addr1$[rsp], rax
  000a3	48 8b 84 24 a8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  000ab	48 8b 80 90 00
	00 00		 mov	 rax, QWORD PTR [rax+144]
  000b2	48 8b 4c 24 50	 mov	 rcx, QWORD PTR effective_addr1$[rsp]
  000b7	48 23 c8	 and	 rcx, rax
  000ba	48 8b c1	 mov	 rax, rcx
  000bd	48 89 44 24 50	 mov	 QWORD PTR effective_addr1$[rsp], rax
$LN8@z900_obtai:
  000c2	83 7c 24 44 00	 cmp	 DWORD PTR b2$[rsp], 0
  000c7	74 44		 je	 SHORT $LN9@z900_obtai
  000c9	48 63 44 24 44	 movsxd	 rax, DWORD PTR b2$[rsp]
  000ce	48 8b 8c 24 a8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  000d6	48 8b 84 c1 80
	02 00 00	 mov	 rax, QWORD PTR [rcx+rax*8+640]
  000de	48 8b 4c 24 38	 mov	 rcx, QWORD PTR effective_addr2$[rsp]
  000e3	48 03 c8	 add	 rcx, rax
  000e6	48 8b c1	 mov	 rax, rcx
  000e9	48 89 44 24 38	 mov	 QWORD PTR effective_addr2$[rsp], rax
  000ee	48 8b 84 24 a8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  000f6	48 8b 80 90 00
	00 00		 mov	 rax, QWORD PTR [rax+144]
  000fd	48 8b 4c 24 38	 mov	 rcx, QWORD PTR effective_addr2$[rsp]
  00102	48 23 c8	 and	 rcx, rax
  00105	48 8b c1	 mov	 rax, rcx
  00108	48 89 44 24 38	 mov	 QWORD PTR effective_addr2$[rsp], rax
$LN9@z900_obtai:
$LN4@z900_obtai:
  0010d	48 8b 84 24 a8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00115	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  00119	48 83 c0 06	 add	 rax, 6
  0011d	48 8b 8c 24 a8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00125	48 89 41 68	 mov	 QWORD PTR [rcx+104], rax
  00129	33 c0		 xor	 eax, eax
  0012b	83 f8 06	 cmp	 eax, 6
  0012e	74 0f		 je	 SHORT $LN10@z900_obtai
  00130	48 8b 84 24 a8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00138	c6 80 9a 00 00
	00 06		 mov	 BYTE PTR [rax+154], 6
$LN10@z900_obtai:
  0013f	33 c0		 xor	 eax, eax
  00141	85 c0		 test	 eax, eax
  00143	75 c8		 jne	 SHORT $LN4@z900_obtai

; 165  :     PER_ZEROADDR_XCHECK2( regs, b1, b2 );

  00145	44 8b 44 24 44	 mov	 r8d, DWORD PTR b2$[rsp]
  0014a	8b 54 24 4c	 mov	 edx, DWORD PTR b1$[rsp]
  0014e	48 8b 8c 24 a8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00156	e8 00 00 00 00	 call	 z900_per3_zero_xcheck2

; 166  : 
; 167  :     GUEST_CHECK( );

  0015b	48 8b 84 24 a8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00163	0f b6 40 7a	 movzx	 eax, BYTE PTR [rax+122]
  00167	83 e0 01	 and	 eax, 1
  0016a	85 c0		 test	 eax, eax
  0016c	74 50		 je	 SHORT $LN11@z900_obtai
  0016e	b8 08 00 00 00	 mov	 eax, 8
  00173	48 6b c0 07	 imul	 rax, rax, 7
  00177	48 8b 8c 24 a8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0017f	8b 84 01 00 06
	00 00		 mov	 eax, DWORD PTR [rcx+rax+1536]
  00186	25 04 00 00 40	 and	 eax, 1073741828		; 40000004H
  0018b	83 f8 04	 cmp	 eax, 4
  0018e	74 2e		 je	 SHORT $LN12@z900_obtai
  00190	48 8b 84 24 a8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00198	0f b6 40 7a	 movzx	 eax, BYTE PTR [rax+122]
  0019c	83 e0 01	 and	 eax, 1
  0019f	85 c0		 test	 eax, eax
  001a1	74 1b		 je	 SHORT $LN13@z900_obtai
  001a3	ba 02 00 00 00	 mov	 edx, 2
  001a8	48 8b 8c 24 a8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  001b0	48 8b 84 24 a8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  001b8	ff 90 20 0d 00
	00		 call	 QWORD PTR [rax+3360]
$LN13@z900_obtai:
$LN12@z900_obtai:
$LN11@z900_obtai:

; 168  : 
; 169  :     /* Specification exception if operands are not on word boundary */
; 170  :     if ((effective_addr1 & 0x00000003) || (effective_addr2 & 0x00000003))

  001be	48 8b 44 24 50	 mov	 rax, QWORD PTR effective_addr1$[rsp]
  001c3	48 83 e0 03	 and	 rax, 3
  001c7	48 85 c0	 test	 rax, rax
  001ca	75 0e		 jne	 SHORT $LN15@z900_obtai
  001cc	48 8b 44 24 38	 mov	 rax, QWORD PTR effective_addr2$[rsp]
  001d1	48 83 e0 03	 and	 rax, 3
  001d5	48 85 c0	 test	 rax, rax
  001d8	74 12		 je	 SHORT $LN14@z900_obtai
$LN15@z900_obtai:

; 171  :         ARCH_DEP(program_interrupt) (regs, PGM_SPECIFICATION_EXCEPTION);

  001da	ba 06 00 00 00	 mov	 edx, 6
  001df	48 8b 8c 24 a8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  001e7	e8 00 00 00 00	 call	 z900_program_interrupt
$LN14@z900_obtai:

; 172  : 
; 173  :     PERFORM_SERIALIZATION(regs);

  001ec	0f ae f0	 mfence

; 174  : 
; 175  :     /* MAINLOCK may be required if cmpxchg assists unavailable */
; 176  :     OBTAIN_MAINLOCK(regs);
; 177  :     {
; 178  :         if (ACCESS_REGISTER_MODE(&regs->psw))

  001ef	48 8b 84 24 a8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  001f7	0f b6 40 7b	 movzx	 eax, BYTE PTR [rax+123]
  001fb	83 f8 40	 cmp	 eax, 64			; 00000040H
  001fe	75 08		 jne	 SHORT $LN16@z900_obtai

; 179  :             acc_mode = USE_PRIMARY_SPACE;

  00200	c7 44 24 30 fd
	ff ff ff	 mov	 DWORD PTR acc_mode$[rsp], -3
$LN16@z900_obtai:

; 180  : 
; 181  :         /* Load ASCB address from first operand location */
; 182  :         ascb_addr = ARCH_DEP(vfetch4) ( effective_addr1, acc_mode, regs );

  00208	4c 8b 84 24 a8
	00 00 00	 mov	 r8, QWORD PTR regs$[rsp]
  00210	8b 54 24 30	 mov	 edx, DWORD PTR acc_mode$[rsp]
  00214	48 8b 4c 24 50	 mov	 rcx, QWORD PTR effective_addr1$[rsp]
  00219	e8 00 00 00 00	 call	 z900_vfetch4
  0021e	8b c0		 mov	 eax, eax
  00220	48 89 44 24 78	 mov	 QWORD PTR ascb_addr$[rsp], rax

; 183  : 
; 184  :         /* Load locks held bits from second operand location */
; 185  :         hlhi_word = ARCH_DEP(vfetch4) ( effective_addr2, acc_mode, regs );

  00225	4c 8b 84 24 a8
	00 00 00	 mov	 r8, QWORD PTR regs$[rsp]
  0022d	8b 54 24 30	 mov	 edx, DWORD PTR acc_mode$[rsp]
  00231	48 8b 4c 24 38	 mov	 rcx, QWORD PTR effective_addr2$[rsp]
  00236	e8 00 00 00 00	 call	 z900_vfetch4
  0023b	89 44 24 48	 mov	 DWORD PTR hlhi_word$[rsp], eax

; 186  : 
; 187  :         /* Fetch our logical CPU address from PSALCPUA */
; 188  :         lcpa = ARCH_DEP(vfetch4) ( effective_addr2 - 4, acc_mode, regs );

  0023f	48 8b 44 24 38	 mov	 rax, QWORD PTR effective_addr2$[rsp]
  00244	48 83 e8 04	 sub	 rax, 4
  00248	4c 8b 84 24 a8
	00 00 00	 mov	 r8, QWORD PTR regs$[rsp]
  00250	8b 54 24 30	 mov	 edx, DWORD PTR acc_mode$[rsp]
  00254	48 8b c8	 mov	 rcx, rax
  00257	e8 00 00 00 00	 call	 z900_vfetch4
  0025c	89 44 24 58	 mov	 DWORD PTR lcpa$[rsp], eax

; 189  : 
; 190  :         /* Get mainstor address of ASCBLOCK word */
; 191  :         mainstor = MADDRL (ascb_addr + ASCBLOCK, 4, b2, regs, ACCTYPE_WRITE, regs->psw.pkey);

  00260	48 8b 44 24 78	 mov	 rax, QWORD PTR ascb_addr$[rsp]
  00265	48 05 80 00 00
	00		 add	 rax, 128		; 00000080H
  0026b	48 8b 8c 24 a8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00273	0f b6 49 79	 movzx	 ecx, BYTE PTR [rcx+121]
  00277	88 4c 24 28	 mov	 BYTE PTR [rsp+40], cl
  0027b	c7 44 24 20 02
	00 00 00	 mov	 DWORD PTR [rsp+32], 2
  00283	4c 8b 8c 24 a8
	00 00 00	 mov	 r9, QWORD PTR regs$[rsp]
  0028b	44 8b 44 24 44	 mov	 r8d, DWORD PTR b2$[rsp]
  00290	ba 04 00 00 00	 mov	 edx, 4
  00295	48 8b c8	 mov	 rcx, rax
  00298	e8 00 00 00 00	 call	 z900_maddr_l
  0029d	48 89 84 24 80
	00 00 00	 mov	 QWORD PTR mainstor$[rsp], rax

; 192  : 
; 193  :         /* The lock word should contain 0; use this as our compare value.
; 194  :            Swap in the CPU address in lpca */
; 195  :         old = 0;

  002a5	c7 44 24 60 00
	00 00 00	 mov	 DWORD PTR old$[rsp], 0

; 196  :         new = CSWAP32(lcpa);

  002ad	8b 4c 24 58	 mov	 ecx, DWORD PTR lcpa$[rsp]
  002b1	e8 00 00 00 00	 call	 _byteswap_ulong
  002b6	89 44 24 5c	 mov	 DWORD PTR new$[rsp], eax

; 197  : 
; 198  :         /* Try exchanging values; cmpxchg4 returns 0=success, !0=failure */
; 199  :         if (!cmpxchg4( &old, new, mainstor ))

  002ba	4c 8b 84 24 80
	00 00 00	 mov	 r8, QWORD PTR mainstor$[rsp]
  002c2	8b 54 24 5c	 mov	 edx, DWORD PTR new$[rsp]
  002c6	48 8d 4c 24 60	 lea	 rcx, QWORD PTR old$[rsp]
  002cb	e8 00 00 00 00	 call	 cmpxchg4_x86
  002d0	0f b6 c0	 movzx	 eax, al
  002d3	85 c0		 test	 eax, eax
  002d5	75 62		 jne	 SHORT $LN17@z900_obtai

; 200  :         {
; 201  :             /* Store the unchanged value into the second operand to
; 202  :             ensure suppression in the event of an access exception */
; 203  :             ARCH_DEP(vstore4) ( hlhi_word, effective_addr2, acc_mode, regs );

  002d7	4c 8b 8c 24 a8
	00 00 00	 mov	 r9, QWORD PTR regs$[rsp]
  002df	44 8b 44 24 30	 mov	 r8d, DWORD PTR acc_mode$[rsp]
  002e4	48 8b 54 24 38	 mov	 rdx, QWORD PTR effective_addr2$[rsp]
  002e9	8b 4c 24 48	 mov	 ecx, DWORD PTR hlhi_word$[rsp]
  002ed	e8 00 00 00 00	 call	 z900_vstore4

; 204  : 
; 205  :             /* Set the local lock held bit in the second operand */
; 206  :             hlhi_word |= PSALCLLI;

  002f2	8b 44 24 48	 mov	 eax, DWORD PTR hlhi_word$[rsp]
  002f6	83 c8 01	 or	 eax, 1
  002f9	89 44 24 48	 mov	 DWORD PTR hlhi_word$[rsp], eax

; 207  :             ARCH_DEP(vstore4) ( hlhi_word, effective_addr2, acc_mode, regs );

  002fd	4c 8b 8c 24 a8
	00 00 00	 mov	 r9, QWORD PTR regs$[rsp]
  00305	44 8b 44 24 30	 mov	 r8d, DWORD PTR acc_mode$[rsp]
  0030a	48 8b 54 24 38	 mov	 rdx, QWORD PTR effective_addr2$[rsp]
  0030f	8b 4c 24 48	 mov	 ecx, DWORD PTR hlhi_word$[rsp]
  00313	e8 00 00 00 00	 call	 z900_vstore4

; 208  : 
; 209  :             /* Set register 13 to zero to indicate lock obtained */
; 210  :             regs->GR_L(13) = 0;

  00318	b8 08 00 00 00	 mov	 eax, 8
  0031d	48 6b c0 0d	 imul	 rax, rax, 13
  00321	48 8b 8c 24 a8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00329	c7 84 01 80 02
	00 00 00 00 00
	00		 mov	 DWORD PTR [rcx+rax+640], 0

; 211  :         }

  00334	e9 8f 01 00 00	 jmp	 $LN18@z900_obtai
$LN17@z900_obtai:

; 212  :         else
; 213  :         {
; 214  :             /* Fetch the lock interface table address from the
; 215  :             second word of the second operand, and load the
; 216  :             new instruction address and amode from LITOLOC */
; 217  :             lit_addr = ARCH_DEP(vfetch4) ( effective_addr2 + 4, acc_mode, regs ) + LITOLOC;

  00339	48 8b 44 24 38	 mov	 rax, QWORD PTR effective_addr2$[rsp]
  0033e	48 83 c0 04	 add	 rax, 4
  00342	4c 8b 84 24 a8
	00 00 00	 mov	 r8, QWORD PTR regs$[rsp]
  0034a	8b 54 24 30	 mov	 edx, DWORD PTR acc_mode$[rsp]
  0034e	48 8b c8	 mov	 rcx, rax
  00351	e8 00 00 00 00	 call	 z900_vfetch4
  00356	83 c0 f0	 add	 eax, -16		; fffffff0H
  00359	8b c0		 mov	 eax, eax
  0035b	48 89 44 24 68	 mov	 QWORD PTR lit_addr$[rsp], rax

; 218  :             lit_addr &= ADDRESS_MAXWRAP(regs);

  00360	48 8b 84 24 a8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00368	48 8b 80 90 00
	00 00		 mov	 rax, QWORD PTR [rax+144]
  0036f	48 8b 4c 24 68	 mov	 rcx, QWORD PTR lit_addr$[rsp]
  00374	48 23 c8	 and	 rcx, rax
  00377	48 8b c1	 mov	 rax, rcx
  0037a	48 89 44 24 68	 mov	 QWORD PTR lit_addr$[rsp], rax

; 219  :             newia = ARCH_DEP(vfetch4) ( lit_addr, acc_mode, regs );

  0037f	4c 8b 84 24 a8
	00 00 00	 mov	 r8, QWORD PTR regs$[rsp]
  00387	8b 54 24 30	 mov	 edx, DWORD PTR acc_mode$[rsp]
  0038b	48 8b 4c 24 68	 mov	 rcx, QWORD PTR lit_addr$[rsp]
  00390	e8 00 00 00 00	 call	 z900_vfetch4
  00395	8b c0		 mov	 eax, eax
  00397	48 89 44 24 70	 mov	 QWORD PTR newia$[rsp], rax

; 220  : 
; 221  :             /* Save the link information in register 12 */
; 222  :             regs->GR_L(12) = PSW_IA_FROM_IP(regs, 0);

  0039c	48 8b 84 24 a8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  003a4	48 8b 8c 24 a8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  003ac	48 8b 89 00 02
	00 00		 mov	 rcx, QWORD PTR [rcx+512]
  003b3	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  003b7	48 2b c1	 sub	 rax, rcx
  003ba	48 8b 8c 24 a8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  003c2	48 8b 89 10 02
	00 00		 mov	 rcx, QWORD PTR [rcx+528]
  003c9	48 03 c8	 add	 rcx, rax
  003cc	48 8b c1	 mov	 rax, rcx
  003cf	48 8b 8c 24 a8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  003d7	48 23 81 90 00
	00 00		 and	 rax, QWORD PTR [rcx+144]
  003de	b9 08 00 00 00	 mov	 ecx, 8
  003e3	48 6b c9 0c	 imul	 rcx, rcx, 12
  003e7	48 8b 94 24 a8
	00 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  003ef	89 84 0a 80 02
	00 00		 mov	 DWORD PTR [rdx+rcx+640], eax

; 223  : 
; 224  :             /* Copy LITOLOC into register 13 to signify obtain failure */
; 225  :             regs->GR_L(13) = newia;

  003f6	b8 08 00 00 00	 mov	 eax, 8
  003fb	48 6b c0 0d	 imul	 rax, rax, 13
  003ff	48 8b 8c 24 a8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00407	8b 54 24 70	 mov	 edx, DWORD PTR newia$[rsp]
  0040b	89 94 01 80 02
	00 00		 mov	 DWORD PTR [rcx+rax+640], edx
$LN7@z900_obtai:

; 226  : 
; 227  :             /* Update the PSW instruction address */
; 228  :             SET_PSW_IA_AND_MAYBE_IP(regs, newia);

  00412	48 8b 84 24 a8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0041a	48 8b 80 90 00
	00 00		 mov	 rax, QWORD PTR [rax+144]
  00421	48 8b 4c 24 70	 mov	 rcx, QWORD PTR newia$[rsp]
  00426	48 23 c8	 and	 rcx, rax
  00429	48 8b c1	 mov	 rax, rcx
  0042c	48 8b 8c 24 a8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00434	48 89 81 88 00
	00 00		 mov	 QWORD PTR [rcx+136], rax
  0043b	48 8b 84 24 a8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00443	48 83 b8 08 02
	00 00 00	 cmp	 QWORD PTR [rax+520], 0
  0044b	74 71		 je	 SHORT $LN19@z900_obtai
  0044d	48 8b 84 24 a8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00455	48 8b 80 88 00
	00 00		 mov	 rax, QWORD PTR [rax+136]
  0045c	48 25 01 f0 ff
	ff		 and	 rax, -4095		; fffffffffffff001H
  00462	48 8b 8c 24 a8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0046a	48 39 81 10 02
	00 00		 cmp	 QWORD PTR [rcx+528], rax
  00471	75 38		 jne	 SHORT $LN20@z900_obtai
  00473	48 8b 84 24 a8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0047b	48 8b 80 88 00
	00 00		 mov	 rax, QWORD PTR [rax+136]
  00482	48 25 ff 0f 00
	00		 and	 rax, 4095		; 00000fffH
  00488	48 8b 8c 24 a8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00490	48 8b 89 00 02
	00 00		 mov	 rcx, QWORD PTR [rcx+512]
  00497	48 0b c8	 or	 rcx, rax
  0049a	48 8b c1	 mov	 rax, rcx
  0049d	48 8b 8c 24 a8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  004a5	48 89 41 68	 mov	 QWORD PTR [rcx+104], rax
  004a9	eb 13		 jmp	 SHORT $LN21@z900_obtai
$LN20@z900_obtai:
  004ab	48 8b 84 24 a8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  004b3	48 c7 80 08 02
	00 00 00 00 00
	00		 mov	 QWORD PTR [rax+520], 0
$LN21@z900_obtai:
$LN19@z900_obtai:
  004be	33 c0		 xor	 eax, eax
  004c0	85 c0		 test	 eax, eax
  004c2	0f 85 4a ff ff
	ff		 jne	 $LN7@z900_obtai
$LN18@z900_obtai:

; 229  :         }
; 230  :     }
; 231  :     RELEASE_MAINLOCK(regs);
; 232  : 
; 233  :     PERFORM_SERIALIZATION(regs);

  004c8	0f ae f0	 mfence

; 234  : 
; 235  : } /* end function obtain_local_lock */

  004cb	48 81 c4 98 00
	00 00		 add	 rsp, 152		; 00000098H
  004d2	c3		 ret	 0
z900_obtain_local_lock ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\assist.c
_TEXT	SEGMENT
acc_mode$ = 48
hlhi_word$ = 52
temp$1 = 56
b2$ = 60
effective_addr2$ = 64
b1$ = 72
effective_addr1$ = 80
tv202 = 88
locked$ = 92
lock$ = 96
new$ = 100
old$ = 104
lit_addr$ = 112
lock_addr$ = 120
newia$ = 128
lock_arn$ = 136
ascb_addr$ = 144
mainstor$ = 152
inst$ = 176
regs$ = 184
z900_obtain_cms_lock PROC

; 337  : {

$LN26:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 81 ec a8 00
	00 00		 sub	 rsp, 168		; 000000a8H

; 338  :     int     b1, b2;                     /* Values of base field      */
; 339  :     VADR    effective_addr1,
; 340  :             effective_addr2;            /* Effective addresses       */
; 341  :     VADR    ascb_addr;                  /* Virtual address of ASCB   */
; 342  :     U32     hlhi_word;                  /* Highest lock held word    */
; 343  :     VADR    lit_addr;                   /* Virtual address of lock
; 344  :                                            interface table           */
; 345  :     VADR    lock_addr;                  /* Lock address              */
; 346  :     int     lock_arn;                   /* Lock access register      */
; 347  :     U32     lock;                       /* Lock value                */
; 348  :     VADR    newia;                      /* Unsuccessful branch addr  */
; 349  :     BYTE   *mainstor;                   /* mainstor address          */
; 350  :     U32     old;                        /* old value                 */
; 351  :     U32     new;                        /* new value                 */
; 352  :     U32     locked = 0;                 /* status of cmpxchg4 result */

  00011	c7 44 24 5c 00
	00 00 00	 mov	 DWORD PTR locked$[rsp], 0

; 353  :     int     acc_mode = 0;               /* access mode to use        */

  00019	c7 44 24 30 00
	00 00 00	 mov	 DWORD PTR acc_mode$[rsp], 0

; 354  : 
; 355  :     SSE(inst, regs, b1, effective_addr1, b2, effective_addr2);

  00021	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR inst$[rsp]
  00029	48 83 c0 02	 add	 rax, 2
  0002d	48 8b c8	 mov	 rcx, rax
  00030	e8 00 00 00 00	 call	 fetch_fw_noswap
  00035	8b c8		 mov	 ecx, eax
  00037	e8 00 00 00 00	 call	 _byteswap_ulong
  0003c	89 44 24 38	 mov	 DWORD PTR temp$1[rsp], eax
  00040	8b 44 24 38	 mov	 eax, DWORD PTR temp$1[rsp]
  00044	25 ff 0f 00 00	 and	 eax, 4095		; 00000fffH
  00049	8b c0		 mov	 eax, eax
  0004b	48 89 44 24 40	 mov	 QWORD PTR effective_addr2$[rsp], rax
  00050	8b 44 24 38	 mov	 eax, DWORD PTR temp$1[rsp]
  00054	c1 e8 0c	 shr	 eax, 12
  00057	83 e0 0f	 and	 eax, 15
  0005a	89 44 24 3c	 mov	 DWORD PTR b2$[rsp], eax
  0005e	8b 44 24 38	 mov	 eax, DWORD PTR temp$1[rsp]
  00062	c1 e8 10	 shr	 eax, 16
  00065	25 ff 0f 00 00	 and	 eax, 4095		; 00000fffH
  0006a	8b c0		 mov	 eax, eax
  0006c	48 89 44 24 50	 mov	 QWORD PTR effective_addr1$[rsp], rax
  00071	8b 44 24 38	 mov	 eax, DWORD PTR temp$1[rsp]
  00075	c1 e8 1c	 shr	 eax, 28
  00078	83 e0 0f	 and	 eax, 15
  0007b	89 44 24 48	 mov	 DWORD PTR b1$[rsp], eax
  0007f	83 7c 24 48 00	 cmp	 DWORD PTR b1$[rsp], 0
  00084	74 44		 je	 SHORT $LN8@z900_obtai
  00086	48 63 44 24 48	 movsxd	 rax, DWORD PTR b1$[rsp]
  0008b	48 8b 8c 24 b8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00093	48 8b 84 c1 80
	02 00 00	 mov	 rax, QWORD PTR [rcx+rax*8+640]
  0009b	48 8b 4c 24 50	 mov	 rcx, QWORD PTR effective_addr1$[rsp]
  000a0	48 03 c8	 add	 rcx, rax
  000a3	48 8b c1	 mov	 rax, rcx
  000a6	48 89 44 24 50	 mov	 QWORD PTR effective_addr1$[rsp], rax
  000ab	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  000b3	48 8b 80 90 00
	00 00		 mov	 rax, QWORD PTR [rax+144]
  000ba	48 8b 4c 24 50	 mov	 rcx, QWORD PTR effective_addr1$[rsp]
  000bf	48 23 c8	 and	 rcx, rax
  000c2	48 8b c1	 mov	 rax, rcx
  000c5	48 89 44 24 50	 mov	 QWORD PTR effective_addr1$[rsp], rax
$LN8@z900_obtai:
  000ca	83 7c 24 3c 00	 cmp	 DWORD PTR b2$[rsp], 0
  000cf	74 44		 je	 SHORT $LN9@z900_obtai
  000d1	48 63 44 24 3c	 movsxd	 rax, DWORD PTR b2$[rsp]
  000d6	48 8b 8c 24 b8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  000de	48 8b 84 c1 80
	02 00 00	 mov	 rax, QWORD PTR [rcx+rax*8+640]
  000e6	48 8b 4c 24 40	 mov	 rcx, QWORD PTR effective_addr2$[rsp]
  000eb	48 03 c8	 add	 rcx, rax
  000ee	48 8b c1	 mov	 rax, rcx
  000f1	48 89 44 24 40	 mov	 QWORD PTR effective_addr2$[rsp], rax
  000f6	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  000fe	48 8b 80 90 00
	00 00		 mov	 rax, QWORD PTR [rax+144]
  00105	48 8b 4c 24 40	 mov	 rcx, QWORD PTR effective_addr2$[rsp]
  0010a	48 23 c8	 and	 rcx, rax
  0010d	48 8b c1	 mov	 rax, rcx
  00110	48 89 44 24 40	 mov	 QWORD PTR effective_addr2$[rsp], rax
$LN9@z900_obtai:
$LN4@z900_obtai:
  00115	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0011d	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  00121	48 83 c0 06	 add	 rax, 6
  00125	48 8b 8c 24 b8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0012d	48 89 41 68	 mov	 QWORD PTR [rcx+104], rax
  00131	33 c0		 xor	 eax, eax
  00133	83 f8 06	 cmp	 eax, 6
  00136	74 0f		 je	 SHORT $LN10@z900_obtai
  00138	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00140	c6 80 9a 00 00
	00 06		 mov	 BYTE PTR [rax+154], 6
$LN10@z900_obtai:
  00147	33 c0		 xor	 eax, eax
  00149	85 c0		 test	 eax, eax
  0014b	75 c8		 jne	 SHORT $LN4@z900_obtai

; 356  :     PER_ZEROADDR_XCHECK2( regs, b1, b2 );

  0014d	44 8b 44 24 3c	 mov	 r8d, DWORD PTR b2$[rsp]
  00152	8b 54 24 48	 mov	 edx, DWORD PTR b1$[rsp]
  00156	48 8b 8c 24 b8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0015e	e8 00 00 00 00	 call	 z900_per3_zero_xcheck2

; 357  : 
; 358  :     GUEST_CHECK( );

  00163	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0016b	0f b6 40 7a	 movzx	 eax, BYTE PTR [rax+122]
  0016f	83 e0 01	 and	 eax, 1
  00172	85 c0		 test	 eax, eax
  00174	74 50		 je	 SHORT $LN11@z900_obtai
  00176	b8 08 00 00 00	 mov	 eax, 8
  0017b	48 6b c0 07	 imul	 rax, rax, 7
  0017f	48 8b 8c 24 b8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00187	8b 84 01 00 06
	00 00		 mov	 eax, DWORD PTR [rcx+rax+1536]
  0018e	25 04 00 00 40	 and	 eax, 1073741828		; 40000004H
  00193	83 f8 04	 cmp	 eax, 4
  00196	74 2e		 je	 SHORT $LN12@z900_obtai
  00198	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  001a0	0f b6 40 7a	 movzx	 eax, BYTE PTR [rax+122]
  001a4	83 e0 01	 and	 eax, 1
  001a7	85 c0		 test	 eax, eax
  001a9	74 1b		 je	 SHORT $LN13@z900_obtai
  001ab	ba 02 00 00 00	 mov	 edx, 2
  001b0	48 8b 8c 24 b8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  001b8	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  001c0	ff 90 20 0d 00
	00		 call	 QWORD PTR [rax+3360]
$LN13@z900_obtai:
$LN12@z900_obtai:
$LN11@z900_obtai:

; 359  : 
; 360  :     /* Specification exception if operands are not on word boundary */
; 361  :     if ((effective_addr1 & 0x00000003) || (effective_addr2 & 0x00000003))

  001c6	48 8b 44 24 50	 mov	 rax, QWORD PTR effective_addr1$[rsp]
  001cb	48 83 e0 03	 and	 rax, 3
  001cf	48 85 c0	 test	 rax, rax
  001d2	75 0e		 jne	 SHORT $LN15@z900_obtai
  001d4	48 8b 44 24 40	 mov	 rax, QWORD PTR effective_addr2$[rsp]
  001d9	48 83 e0 03	 and	 rax, 3
  001dd	48 85 c0	 test	 rax, rax
  001e0	74 12		 je	 SHORT $LN14@z900_obtai
$LN15@z900_obtai:

; 362  :         ARCH_DEP(program_interrupt) (regs, PGM_SPECIFICATION_EXCEPTION);

  001e2	ba 06 00 00 00	 mov	 edx, 6
  001e7	48 8b 8c 24 b8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  001ef	e8 00 00 00 00	 call	 z900_program_interrupt
$LN14@z900_obtai:

; 363  : 
; 364  :     PERFORM_SERIALIZATION(regs);

  001f4	0f ae f0	 mfence

; 365  : 
; 366  :     /* General register 11 contains the lock address */
; 367  :     lock_addr = regs->GR_L(11) & ADDRESS_MAXWRAP(regs);

  001f7	b8 08 00 00 00	 mov	 eax, 8
  001fc	48 6b c0 0b	 imul	 rax, rax, 11
  00200	48 8b 8c 24 b8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00208	8b 84 01 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax+640]
  0020f	48 8b 8c 24 b8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00217	48 23 81 90 00
	00 00		 and	 rax, QWORD PTR [rcx+144]
  0021e	48 89 44 24 78	 mov	 QWORD PTR lock_addr$[rsp], rax

; 368  :     lock_arn = 11;

  00223	c7 84 24 88 00
	00 00 0b 00 00
	00		 mov	 DWORD PTR lock_arn$[rsp], 11

; 369  : 
; 370  :     /* MAINLOCK may be required if cmpxchg assists unavailable */
; 371  :     OBTAIN_MAINLOCK(regs);
; 372  :     {
; 373  :         if (ACCESS_REGISTER_MODE(&regs->psw))

  0022e	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00236	0f b6 40 7b	 movzx	 eax, BYTE PTR [rax+123]
  0023a	83 f8 40	 cmp	 eax, 64			; 00000040H
  0023d	75 08		 jne	 SHORT $LN16@z900_obtai

; 374  :             acc_mode = USE_PRIMARY_SPACE;

  0023f	c7 44 24 30 fd
	ff ff ff	 mov	 DWORD PTR acc_mode$[rsp], -3
$LN16@z900_obtai:

; 375  : 
; 376  :         /* Load ASCB address from first operand location */
; 377  :         ascb_addr = ARCH_DEP(vfetch4) ( effective_addr1, acc_mode, regs );

  00247	4c 8b 84 24 b8
	00 00 00	 mov	 r8, QWORD PTR regs$[rsp]
  0024f	8b 54 24 30	 mov	 edx, DWORD PTR acc_mode$[rsp]
  00253	48 8b 4c 24 50	 mov	 rcx, QWORD PTR effective_addr1$[rsp]
  00258	e8 00 00 00 00	 call	 z900_vfetch4
  0025d	8b c0		 mov	 eax, eax
  0025f	48 89 84 24 90
	00 00 00	 mov	 QWORD PTR ascb_addr$[rsp], rax

; 378  : 
; 379  :         /* Load locks held bits from second operand location */
; 380  :         hlhi_word = ARCH_DEP(vfetch4) ( effective_addr2, acc_mode, regs );

  00267	4c 8b 84 24 b8
	00 00 00	 mov	 r8, QWORD PTR regs$[rsp]
  0026f	8b 54 24 30	 mov	 edx, DWORD PTR acc_mode$[rsp]
  00273	48 8b 4c 24 40	 mov	 rcx, QWORD PTR effective_addr2$[rsp]
  00278	e8 00 00 00 00	 call	 z900_vfetch4
  0027d	89 44 24 34	 mov	 DWORD PTR hlhi_word$[rsp], eax

; 381  : 
; 382  :         /* Fetch the lock addressed by general register 11 */
; 383  :         lock = ARCH_DEP(vfetch4) ( lock_addr, acc_mode, regs );

  00281	4c 8b 84 24 b8
	00 00 00	 mov	 r8, QWORD PTR regs$[rsp]
  00289	8b 54 24 30	 mov	 edx, DWORD PTR acc_mode$[rsp]
  0028d	48 8b 4c 24 78	 mov	 rcx, QWORD PTR lock_addr$[rsp]
  00292	e8 00 00 00 00	 call	 z900_vfetch4
  00297	89 44 24 60	 mov	 DWORD PTR lock$[rsp], eax

; 384  : 
; 385  :         /* Validate that the address space meets criteria to obtain the CMS lock:
; 386  :              the target lock word pointed to by GR11 must be 0,
; 387  :              the LOCAL lock *must* be held on this CPU,
; 388  :              and the CMS lock must *not* be held on this CPU.  */
; 389  :         if (lock == 0
; 390  :             && (hlhi_word & (PSALCLLI | PSACMSLI)) == PSALCLLI)

  0029b	83 7c 24 60 00	 cmp	 DWORD PTR lock$[rsp], 0
  002a0	0f 85 9b 00 00
	00		 jne	 $LN17@z900_obtai
  002a6	8b 44 24 34	 mov	 eax, DWORD PTR hlhi_word$[rsp]
  002aa	83 e0 03	 and	 eax, 3
  002ad	83 f8 01	 cmp	 eax, 1
  002b0	0f 85 8b 00 00
	00		 jne	 $LN17@z900_obtai

; 391  :         {
; 392  :             /* Get mainstor address of lock word */
; 393  :             mainstor = MADDRL (lock_addr, 4, b2, regs, ACCTYPE_WRITE, regs->psw.pkey);

  002b6	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  002be	0f b6 40 79	 movzx	 eax, BYTE PTR [rax+121]
  002c2	88 44 24 28	 mov	 BYTE PTR [rsp+40], al
  002c6	c7 44 24 20 02
	00 00 00	 mov	 DWORD PTR [rsp+32], 2
  002ce	4c 8b 8c 24 b8
	00 00 00	 mov	 r9, QWORD PTR regs$[rsp]
  002d6	44 8b 44 24 3c	 mov	 r8d, DWORD PTR b2$[rsp]
  002db	ba 04 00 00 00	 mov	 edx, 4
  002e0	48 8b 4c 24 78	 mov	 rcx, QWORD PTR lock_addr$[rsp]
  002e5	e8 00 00 00 00	 call	 z900_maddr_l
  002ea	48 89 84 24 98
	00 00 00	 mov	 QWORD PTR mainstor$[rsp], rax

; 394  : 
; 395  :             /* The lock word should contain 0; use this as our compare value.
; 396  :             Swap in the ASCB address from instruction operand 1            */
; 397  :             old = 0;

  002f2	c7 44 24 68 00
	00 00 00	 mov	 DWORD PTR old$[rsp], 0

; 398  :             new = CSWAP32(ascb_addr);

  002fa	8b 8c 24 90 00
	00 00		 mov	 ecx, DWORD PTR ascb_addr$[rsp]
  00301	e8 00 00 00 00	 call	 _byteswap_ulong
  00306	89 44 24 64	 mov	 DWORD PTR new$[rsp], eax

; 399  : 
; 400  :             /* Try exchanging values; cmpxchg4 returns 0=success, !0=failure */
; 401  :             locked = !cmpxchg4( &old, new, mainstor );

  0030a	4c 8b 84 24 98
	00 00 00	 mov	 r8, QWORD PTR mainstor$[rsp]
  00312	8b 54 24 64	 mov	 edx, DWORD PTR new$[rsp]
  00316	48 8d 4c 24 68	 lea	 rcx, QWORD PTR old$[rsp]
  0031b	e8 00 00 00 00	 call	 cmpxchg4_x86
  00320	0f b6 c0	 movzx	 eax, al
  00323	85 c0		 test	 eax, eax
  00325	75 0a		 jne	 SHORT $LN24@z900_obtai
  00327	c7 44 24 58 01
	00 00 00	 mov	 DWORD PTR tv202[rsp], 1
  0032f	eb 08		 jmp	 SHORT $LN25@z900_obtai
$LN24@z900_obtai:
  00331	c7 44 24 58 00
	00 00 00	 mov	 DWORD PTR tv202[rsp], 0
$LN25@z900_obtai:
  00339	8b 44 24 58	 mov	 eax, DWORD PTR tv202[rsp]
  0033d	89 44 24 5c	 mov	 DWORD PTR locked$[rsp], eax
$LN17@z900_obtai:

; 402  :         }
; 403  : 
; 404  :         if (locked)

  00341	83 7c 24 5c 00	 cmp	 DWORD PTR locked$[rsp], 0
  00346	74 62		 je	 SHORT $LN18@z900_obtai

; 405  :         {
; 406  :             /* Store the unchanged value into the second operand to
; 407  :             ensure suppression in the event of an access exception */
; 408  :             ARCH_DEP(vstore4) ( hlhi_word, effective_addr2, acc_mode, regs );

  00348	4c 8b 8c 24 b8
	00 00 00	 mov	 r9, QWORD PTR regs$[rsp]
  00350	44 8b 44 24 30	 mov	 r8d, DWORD PTR acc_mode$[rsp]
  00355	48 8b 54 24 40	 mov	 rdx, QWORD PTR effective_addr2$[rsp]
  0035a	8b 4c 24 34	 mov	 ecx, DWORD PTR hlhi_word$[rsp]
  0035e	e8 00 00 00 00	 call	 z900_vstore4

; 409  : 
; 410  :             /* Set the CMS lock held bit in the second operand */
; 411  :             hlhi_word |= PSACMSLI;

  00363	8b 44 24 34	 mov	 eax, DWORD PTR hlhi_word$[rsp]
  00367	83 c8 02	 or	 eax, 2
  0036a	89 44 24 34	 mov	 DWORD PTR hlhi_word$[rsp], eax

; 412  :             ARCH_DEP(vstore4) ( hlhi_word, effective_addr2, acc_mode, regs );

  0036e	4c 8b 8c 24 b8
	00 00 00	 mov	 r9, QWORD PTR regs$[rsp]
  00376	44 8b 44 24 30	 mov	 r8d, DWORD PTR acc_mode$[rsp]
  0037b	48 8b 54 24 40	 mov	 rdx, QWORD PTR effective_addr2$[rsp]
  00380	8b 4c 24 34	 mov	 ecx, DWORD PTR hlhi_word$[rsp]
  00384	e8 00 00 00 00	 call	 z900_vstore4

; 413  : 
; 414  :             /* Set register 13 to zero to indicate lock obtained */
; 415  :             regs->GR_L(13) = 0;

  00389	b8 08 00 00 00	 mov	 eax, 8
  0038e	48 6b c0 0d	 imul	 rax, rax, 13
  00392	48 8b 8c 24 b8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0039a	c7 84 01 80 02
	00 00 00 00 00
	00		 mov	 DWORD PTR [rcx+rax+640], 0

; 416  :         }

  003a5	e9 98 01 00 00	 jmp	 $LN19@z900_obtai
$LN18@z900_obtai:

; 417  :         else
; 418  :         {
; 419  :             /* Fetch the lock interface table address from the
; 420  :             second word of the second operand, and load the
; 421  :             new instruction address and amode from LITOCMS */
; 422  :             lit_addr = ARCH_DEP(vfetch4) ( effective_addr2 + 4, acc_mode, regs ) + LITOCMS;

  003aa	48 8b 44 24 40	 mov	 rax, QWORD PTR effective_addr2$[rsp]
  003af	48 83 c0 04	 add	 rax, 4
  003b3	4c 8b 84 24 b8
	00 00 00	 mov	 r8, QWORD PTR regs$[rsp]
  003bb	8b 54 24 30	 mov	 edx, DWORD PTR acc_mode$[rsp]
  003bf	48 8b c8	 mov	 rcx, rax
  003c2	e8 00 00 00 00	 call	 z900_vfetch4
  003c7	83 c0 f8	 add	 eax, -8			; fffffff8H
  003ca	8b c0		 mov	 eax, eax
  003cc	48 89 44 24 70	 mov	 QWORD PTR lit_addr$[rsp], rax

; 423  :             lit_addr &= ADDRESS_MAXWRAP(regs);

  003d1	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  003d9	48 8b 80 90 00
	00 00		 mov	 rax, QWORD PTR [rax+144]
  003e0	48 8b 4c 24 70	 mov	 rcx, QWORD PTR lit_addr$[rsp]
  003e5	48 23 c8	 and	 rcx, rax
  003e8	48 8b c1	 mov	 rax, rcx
  003eb	48 89 44 24 70	 mov	 QWORD PTR lit_addr$[rsp], rax

; 424  :             newia = ARCH_DEP(vfetch4) ( lit_addr, acc_mode, regs );

  003f0	4c 8b 84 24 b8
	00 00 00	 mov	 r8, QWORD PTR regs$[rsp]
  003f8	8b 54 24 30	 mov	 edx, DWORD PTR acc_mode$[rsp]
  003fc	48 8b 4c 24 70	 mov	 rcx, QWORD PTR lit_addr$[rsp]
  00401	e8 00 00 00 00	 call	 z900_vfetch4
  00406	8b c0		 mov	 eax, eax
  00408	48 89 84 24 80
	00 00 00	 mov	 QWORD PTR newia$[rsp], rax

; 425  : 
; 426  :             /* Save the link information in register 12 */
; 427  :             regs->GR_L(12) = PSW_IA_FROM_IP(regs, 0);

  00410	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00418	48 8b 8c 24 b8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00420	48 8b 89 00 02
	00 00		 mov	 rcx, QWORD PTR [rcx+512]
  00427	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  0042b	48 2b c1	 sub	 rax, rcx
  0042e	48 8b 8c 24 b8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00436	48 8b 89 10 02
	00 00		 mov	 rcx, QWORD PTR [rcx+528]
  0043d	48 03 c8	 add	 rcx, rax
  00440	48 8b c1	 mov	 rax, rcx
  00443	48 8b 8c 24 b8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0044b	48 23 81 90 00
	00 00		 and	 rax, QWORD PTR [rcx+144]
  00452	b9 08 00 00 00	 mov	 ecx, 8
  00457	48 6b c9 0c	 imul	 rcx, rcx, 12
  0045b	48 8b 94 24 b8
	00 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  00463	89 84 0a 80 02
	00 00		 mov	 DWORD PTR [rdx+rcx+640], eax

; 428  : 
; 429  :             /* Copy LITOCMS into register 13 to signify obtain failure */
; 430  :             regs->GR_L(13) = newia;

  0046a	b8 08 00 00 00	 mov	 eax, 8
  0046f	48 6b c0 0d	 imul	 rax, rax, 13
  00473	48 8b 8c 24 b8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0047b	8b 94 24 80 00
	00 00		 mov	 edx, DWORD PTR newia$[rsp]
  00482	89 94 01 80 02
	00 00		 mov	 DWORD PTR [rcx+rax+640], edx
$LN7@z900_obtai:

; 431  : 
; 432  :             /* Update the PSW instruction address */
; 433  :             SET_PSW_IA_AND_MAYBE_IP(regs, newia);

  00489	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00491	48 8b 80 90 00
	00 00		 mov	 rax, QWORD PTR [rax+144]
  00498	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR newia$[rsp]
  004a0	48 23 c8	 and	 rcx, rax
  004a3	48 8b c1	 mov	 rax, rcx
  004a6	48 8b 8c 24 b8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  004ae	48 89 81 88 00
	00 00		 mov	 QWORD PTR [rcx+136], rax
  004b5	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  004bd	48 83 b8 08 02
	00 00 00	 cmp	 QWORD PTR [rax+520], 0
  004c5	74 71		 je	 SHORT $LN20@z900_obtai
  004c7	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  004cf	48 8b 80 88 00
	00 00		 mov	 rax, QWORD PTR [rax+136]
  004d6	48 25 01 f0 ff
	ff		 and	 rax, -4095		; fffffffffffff001H
  004dc	48 8b 8c 24 b8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  004e4	48 39 81 10 02
	00 00		 cmp	 QWORD PTR [rcx+528], rax
  004eb	75 38		 jne	 SHORT $LN21@z900_obtai
  004ed	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  004f5	48 8b 80 88 00
	00 00		 mov	 rax, QWORD PTR [rax+136]
  004fc	48 25 ff 0f 00
	00		 and	 rax, 4095		; 00000fffH
  00502	48 8b 8c 24 b8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0050a	48 8b 89 00 02
	00 00		 mov	 rcx, QWORD PTR [rcx+512]
  00511	48 0b c8	 or	 rcx, rax
  00514	48 8b c1	 mov	 rax, rcx
  00517	48 8b 8c 24 b8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0051f	48 89 41 68	 mov	 QWORD PTR [rcx+104], rax
  00523	eb 13		 jmp	 SHORT $LN22@z900_obtai
$LN21@z900_obtai:
  00525	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0052d	48 c7 80 08 02
	00 00 00 00 00
	00		 mov	 QWORD PTR [rax+520], 0
$LN22@z900_obtai:
$LN20@z900_obtai:
  00538	33 c0		 xor	 eax, eax
  0053a	85 c0		 test	 eax, eax
  0053c	0f 85 47 ff ff
	ff		 jne	 $LN7@z900_obtai
$LN19@z900_obtai:

; 434  :         }
; 435  :     }
; 436  :     RELEASE_MAINLOCK(regs);
; 437  : 
; 438  :     PERFORM_SERIALIZATION(regs);

  00542	0f ae f0	 mfence

; 439  : 
; 440  : } /* end function obtain_cms_lock */

  00545	48 81 c4 a8 00
	00 00		 add	 rsp, 168		; 000000a8H
  0054c	c3		 ret	 0
z900_obtain_cms_lock ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\assist.c
_TEXT	SEGMENT
entrycode$ = 48
size$ = 52
len$ = 56
frrnext$ = 64
r2$ = 72
frrstak$ = 80
i$1 = 88
r1$ = 92
frrsize$ = 96
cr_ptr$ = 104
clear_vaddr$ = 112
frrcurr$ = 120
frrlast$ = 128
newia$ = 136
frrparm$ = 144
cr34$2 = 152
__$ArrayPad$ = 160
inst$ = 192
regs$ = 200
z900_add_frr PROC

; 680  : {

$LN23:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 81 ec b8 00
	00 00		 sub	 rsp, 184		; 000000b8H
  00011	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00018	48 33 c4	 xor	 rax, rsp
  0001b	48 89 84 24 a0
	00 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 681  : /*                          ADDFRR
; 682  : 
; 683  :         Add new Functional-Recovery-Routine Stack entry
; 684  : 
; 685  :    What little documentation that exists for this feature can be found
; 686  :    on page 9 of IBM System/370 Assists for MVS, GA22-7079-1 (the text
; 687  :    of which is copied verbatim further below), which can be found on
; 688  :    Bitsavers at:
; 689  : 
; 690  :       * https://bitsavers.org/pdf/ibm/370/MVS/GA22-7079-1_IBM_System_370_Assists_for_MVS_2nd_ed_198110.pdf
; 691  : 
; 692  :    The rest of the documentation regarding how it works is found in the
; 693  :    way MVS itself manages the FRR stack. The assist feature is part of
; 694  :    the 3033 Extensions.
; 695  : 
; 696  :    r1 contains an entry value designating the type of FRR and action to
; 697  :    take by this assist. r2 contains the address of the FRR to be added.
; 698  : */
; 699  : /*                          ADDFRR
; 700  : 
; 701  :     "A new entry is added to the top of the current functional-
; 702  :      recovery-routine (FRR) stack. The entry is initialized with
; 703  :      values provided in general registers and with the PSW S bit
; 704  :      (bit 16)."
; 705  : 
; 706  :     "Optionally, the contents of control registers 3 and 4 are
; 707  :      saved in an entry in a separate table."
; 708  : 
; 709  :     "The general register designated by the r2 field provides the
; 710  :      logical address of the FRR entry point."
; 711  : 
; 712  :     "Before instruction execution, the general register designated
; 713  :      by the r1 field provides three bytes that are stored in the
; 714  :      FRR entry and whose value determines if control registers 3
; 715  :      and 4 are to be stored as well. When instruction execution is
; 716  :      completed, the register designated by r1 contains the logical
; 717  :      address of the six-word work area within the new, current
; 718  :      FRR-stack entry."
; 719  : 
; 720  :     "Logical location 380 hex contains the logical address of the
; 721  :      stack-table header. The stack-table header contains (1) a logical
; 722  :      address which is 32 less than the address of the first dynamic
; 723  :      entry in the stack table, (2) the logical address of the last
; 724  :      entry in the stack table, and (3) the logical address of the
; 725  :      current stack-table entry."
; 726  : 
; 727  :     "At an offset from the beginning of the stack-table header is
; 728  :      found a table of stack-entry-extension entries. Optionally,
; 729  :      the contents of control registers 3 and 4 are saved in an
; 730  :      extension entry. One extension entry corresponds to each entry
; 731  :      in the stack table. The offset to the table of extension entries,
; 732  :      and the encoded length of an extension entry, are found in the
; 733  :      word at logical location BA8 hex."
; 734  : 
; 735  :     Condition Code: The code remains unchanged.
; 736  : 
; 737  :     Program Exceptions:
; 738  :     Access (storage operands)
; 739  :     Operation (when the instruction is not installed)
; 740  :     Privileged operation
; 741  :     Specification
; 742  : */
; 743  : 
; 744  : int     r1, r2;
; 745  : VADR    frrstak;
; 746  : VADR    frrparm;
; 747  : VADR    frrlast;
; 748  : U32     frrsize;
; 749  : VADR    frrcurr;
; 750  : VADR    frrnext;
; 751  : VADR    newia;
; 752  : VADR    cr_ptr;
; 753  : BYTE    entrycode;
; 754  : U32     size, len;
; 755  : VADR    clear_vaddr;
; 756  : static const BYTE zeros[256] = {0};
; 757  : 
; 758  : #define FRRSPARM    0x08
; 759  : 
; 760  : /* Entry code bits in r1 */
; 761  : #define EUT         0x80
; 762  : #define FULLXM      0x08
; 763  : #define PRIMARY     0x04
; 764  : #define LOCAL       0x02
; 765  : #define GLOBAL      0x01
; 766  : #define HOME        0x00
; 767  : 
; 768  :     RRE( inst, regs, r1, r2 );

  00023	b8 01 00 00 00	 mov	 eax, 1
  00028	48 6b c0 03	 imul	 rax, rax, 3
  0002c	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR inst$[rsp]
  00034	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00038	89 44 24 58	 mov	 DWORD PTR i$1[rsp], eax
  0003c	8b 44 24 58	 mov	 eax, DWORD PTR i$1[rsp]
  00040	83 e0 0f	 and	 eax, 15
  00043	89 44 24 48	 mov	 DWORD PTR r2$[rsp], eax
  00047	8b 44 24 58	 mov	 eax, DWORD PTR i$1[rsp]
  0004b	c1 f8 04	 sar	 eax, 4
  0004e	83 e0 0f	 and	 eax, 15
  00051	89 44 24 5c	 mov	 DWORD PTR r1$[rsp], eax
$LN4@z900_add_f:
  00055	48 8b 84 24 c8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0005d	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  00061	48 83 c0 04	 add	 rax, 4
  00065	48 8b 8c 24 c8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0006d	48 89 41 68	 mov	 QWORD PTR [rcx+104], rax
  00071	33 c0		 xor	 eax, eax
  00073	83 f8 04	 cmp	 eax, 4
  00076	74 0f		 je	 SHORT $LN10@z900_add_f
  00078	48 8b 84 24 c8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00080	c6 80 9a 00 00
	00 04		 mov	 BYTE PTR [rax+154], 4
$LN10@z900_add_f:
  00087	33 c0		 xor	 eax, eax
  00089	85 c0		 test	 eax, eax
  0008b	75 c8		 jne	 SHORT $LN4@z900_add_f

; 769  : 
; 770  :     PRIV_CHECK( regs );

  0008d	48 8b 84 24 c8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00095	0f b6 40 7a	 movzx	 eax, BYTE PTR [rax+122]
  00099	83 e0 01	 and	 eax, 1
  0009c	85 c0		 test	 eax, eax
  0009e	74 1b		 je	 SHORT $LN11@z900_add_f
  000a0	ba 02 00 00 00	 mov	 edx, 2
  000a5	48 8b 8c 24 c8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  000ad	48 8b 84 24 c8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  000b5	ff 90 20 0d 00
	00		 call	 QWORD PTR [rax+3360]
$LN11@z900_add_f:

; 771  : 
; 772  :     /* Obtain needed values from the FRR stack pointers */
; 773  :     frrstak = ARCH_DEP( vfetch4 )( PSACSTK,                                  USE_PRIMARY_SPACE, regs ) & ADDRESS_MAXWRAP( regs );

  000bb	4c 8b 84 24 c8
	00 00 00	 mov	 r8, QWORD PTR regs$[rsp]
  000c3	ba fd ff ff ff	 mov	 edx, -3
  000c8	b9 80 03 00 00	 mov	 ecx, 896		; 00000380H
  000cd	e8 00 00 00 00	 call	 z900_vfetch4
  000d2	8b c0		 mov	 eax, eax
  000d4	48 8b 8c 24 c8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  000dc	48 23 81 90 00
	00 00		 and	 rax, QWORD PTR [rcx+144]
  000e3	48 89 44 24 50	 mov	 QWORD PTR frrstak$[rsp], rax

; 774  :     frrparm = ARCH_DEP( vfetch4 )( (frrstak +  0),                           USE_PRIMARY_SPACE, regs ) & ADDRESS_MAXWRAP( regs );

  000e8	4c 8b 84 24 c8
	00 00 00	 mov	 r8, QWORD PTR regs$[rsp]
  000f0	ba fd ff ff ff	 mov	 edx, -3
  000f5	48 8b 4c 24 50	 mov	 rcx, QWORD PTR frrstak$[rsp]
  000fa	e8 00 00 00 00	 call	 z900_vfetch4
  000ff	8b c0		 mov	 eax, eax
  00101	48 8b 8c 24 c8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00109	48 23 81 90 00
	00 00		 and	 rax, QWORD PTR [rcx+144]
  00110	48 89 84 24 90
	00 00 00	 mov	 QWORD PTR frrparm$[rsp], rax

; 775  :     frrlast = ARCH_DEP( vfetch4 )( (frrstak +  4) & ADDRESS_MAXWRAP( regs ), USE_PRIMARY_SPACE, regs ) & ADDRESS_MAXWRAP( regs );

  00118	48 8b 44 24 50	 mov	 rax, QWORD PTR frrstak$[rsp]
  0011d	48 83 c0 04	 add	 rax, 4
  00121	48 8b 8c 24 c8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00129	48 23 81 90 00
	00 00		 and	 rax, QWORD PTR [rcx+144]
  00130	4c 8b 84 24 c8
	00 00 00	 mov	 r8, QWORD PTR regs$[rsp]
  00138	ba fd ff ff ff	 mov	 edx, -3
  0013d	48 8b c8	 mov	 rcx, rax
  00140	e8 00 00 00 00	 call	 z900_vfetch4
  00145	8b c0		 mov	 eax, eax
  00147	48 8b 8c 24 c8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0014f	48 23 81 90 00
	00 00		 and	 rax, QWORD PTR [rcx+144]
  00156	48 89 84 24 80
	00 00 00	 mov	 QWORD PTR frrlast$[rsp], rax

; 776  :     frrsize = ARCH_DEP( vfetch4 )( (frrstak +  8) & ADDRESS_MAXWRAP( regs ), USE_PRIMARY_SPACE, regs );

  0015e	48 8b 44 24 50	 mov	 rax, QWORD PTR frrstak$[rsp]
  00163	48 83 c0 08	 add	 rax, 8
  00167	48 8b 8c 24 c8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0016f	48 23 81 90 00
	00 00		 and	 rax, QWORD PTR [rcx+144]
  00176	4c 8b 84 24 c8
	00 00 00	 mov	 r8, QWORD PTR regs$[rsp]
  0017e	ba fd ff ff ff	 mov	 edx, -3
  00183	48 8b c8	 mov	 rcx, rax
  00186	e8 00 00 00 00	 call	 z900_vfetch4
  0018b	89 44 24 60	 mov	 DWORD PTR frrsize$[rsp], eax

; 777  :     frrcurr = ARCH_DEP( vfetch4 )( (frrstak + 12) & ADDRESS_MAXWRAP( regs ), USE_PRIMARY_SPACE, regs ) & ADDRESS_MAXWRAP( regs );

  0018f	48 8b 44 24 50	 mov	 rax, QWORD PTR frrstak$[rsp]
  00194	48 83 c0 0c	 add	 rax, 12
  00198	48 8b 8c 24 c8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  001a0	48 23 81 90 00
	00 00		 and	 rax, QWORD PTR [rcx+144]
  001a7	4c 8b 84 24 c8
	00 00 00	 mov	 r8, QWORD PTR regs$[rsp]
  001af	ba fd ff ff ff	 mov	 edx, -3
  001b4	48 8b c8	 mov	 rcx, rax
  001b7	e8 00 00 00 00	 call	 z900_vfetch4
  001bc	8b c0		 mov	 eax, eax
  001be	48 8b 8c 24 c8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  001c6	48 23 81 90 00
	00 00		 and	 rax, QWORD PTR [rcx+144]
  001cd	48 89 44 24 78	 mov	 QWORD PTR frrcurr$[rsp], rax

; 778  :     frrnext = (frrcurr + frrsize) & ADDRESS_MAXWRAP( regs );

  001d2	8b 44 24 60	 mov	 eax, DWORD PTR frrsize$[rsp]
  001d6	48 8b 4c 24 78	 mov	 rcx, QWORD PTR frrcurr$[rsp]
  001db	48 03 c8	 add	 rcx, rax
  001de	48 8b c1	 mov	 rax, rcx
  001e1	48 8b 8c 24 c8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  001e9	48 23 81 90 00
	00 00		 and	 rax, QWORD PTR [rcx+144]
  001f0	48 89 44 24 40	 mov	 QWORD PTR frrnext$[rsp], rax

; 779  : 
; 780  :     /* Determine if FRR stack is full. If yes, then
; 781  :        branch to the system supplied code at PSALFSCC
; 782  :     */
; 783  :     if (frrnext > frrlast)

  001f5	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR frrlast$[rsp]
  001fd	48 39 44 24 40	 cmp	 QWORD PTR frrnext$[rsp], rax
  00202	0f 86 ee 00 00
	00		 jbe	 $LN12@z900_add_f

; 784  :     {
; 785  :         newia = ARCH_DEP( vfetch4 )( PSALSFCC, USE_PRIMARY_SPACE, regs ) & ADDRESS_MAXWRAP( regs );

  00208	4c 8b 84 24 c8
	00 00 00	 mov	 r8, QWORD PTR regs$[rsp]
  00210	ba fd ff ff ff	 mov	 edx, -3
  00215	b9 f4 03 00 00	 mov	 ecx, 1012		; 000003f4H
  0021a	e8 00 00 00 00	 call	 z900_vfetch4
  0021f	8b c0		 mov	 eax, eax
  00221	48 8b 8c 24 c8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00229	48 23 81 90 00
	00 00		 and	 rax, QWORD PTR [rcx+144]
  00230	48 89 84 24 88
	00 00 00	 mov	 QWORD PTR newia$[rsp], rax
$LN7@z900_add_f:

; 786  :         SET_PSW_IA_AND_MAYBE_IP( regs, newia );

  00238	48 8b 84 24 c8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00240	48 8b 80 90 00
	00 00		 mov	 rax, QWORD PTR [rax+144]
  00247	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR newia$[rsp]
  0024f	48 23 c8	 and	 rcx, rax
  00252	48 8b c1	 mov	 rax, rcx
  00255	48 8b 8c 24 c8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0025d	48 89 81 88 00
	00 00		 mov	 QWORD PTR [rcx+136], rax
  00264	48 8b 84 24 c8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0026c	48 83 b8 08 02
	00 00 00	 cmp	 QWORD PTR [rax+520], 0
  00274	74 71		 je	 SHORT $LN13@z900_add_f
  00276	48 8b 84 24 c8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0027e	48 8b 80 88 00
	00 00		 mov	 rax, QWORD PTR [rax+136]
  00285	48 25 01 f0 ff
	ff		 and	 rax, -4095		; fffffffffffff001H
  0028b	48 8b 8c 24 c8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00293	48 39 81 10 02
	00 00		 cmp	 QWORD PTR [rcx+528], rax
  0029a	75 38		 jne	 SHORT $LN14@z900_add_f
  0029c	48 8b 84 24 c8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  002a4	48 8b 80 88 00
	00 00		 mov	 rax, QWORD PTR [rax+136]
  002ab	48 25 ff 0f 00
	00		 and	 rax, 4095		; 00000fffH
  002b1	48 8b 8c 24 c8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  002b9	48 8b 89 00 02
	00 00		 mov	 rcx, QWORD PTR [rcx+512]
  002c0	48 0b c8	 or	 rcx, rax
  002c3	48 8b c1	 mov	 rax, rcx
  002c6	48 8b 8c 24 c8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  002ce	48 89 41 68	 mov	 QWORD PTR [rcx+104], rax
  002d2	eb 13		 jmp	 SHORT $LN15@z900_add_f
$LN14@z900_add_f:
  002d4	48 8b 84 24 c8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  002dc	48 c7 80 08 02
	00 00 00 00 00
	00		 mov	 QWORD PTR [rax+520], 0
$LN15@z900_add_f:
$LN13@z900_add_f:
  002e7	33 c0		 xor	 eax, eax
  002e9	85 c0		 test	 eax, eax
  002eb	0f 85 47 ff ff
	ff		 jne	 $LN7@z900_add_f

; 787  :         return;

  002f1	e9 29 03 00 00	 jmp	 $LN1@z900_add_f
$LN12@z900_add_f:

; 788  :     }
; 789  : 
; 790  :     /* Perform exactly one of the following three functions based on the entry code from r1 */
; 791  :     entrycode = regs->GR_LHLCL( r1 );

  002f6	48 63 44 24 5c	 movsxd	 rax, DWORD PTR r1$[rsp]
  002fb	48 8b 8c 24 c8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00303	0f b6 84 c1 80
	02 00 00	 movzx	 eax, BYTE PTR [rcx+rax*8+640]
  0030b	88 44 24 30	 mov	 BYTE PTR entrycode$[rsp], al

; 792  : 
; 793  :     /*  1. SETFRR  A,MODE=HOME (no LOCAL/GLOBAL or EUT specification) */
; 794  : 
; 795  :     if (entrycode == HOME)

  0030f	0f b6 44 24 30	 movzx	 eax, BYTE PTR entrycode$[rsp]
  00314	85 c0		 test	 eax, eax
  00316	75 31		 jne	 SHORT $LN16@z900_add_f

; 796  :     {
; 797  :         /* Set the FRR entry point from r2 in the stack */
; 798  :         ARCH_DEP( vstore4 )( regs->GR_L(r2), frrnext, USE_PRIMARY_SPACE, regs );

  00318	48 63 44 24 48	 movsxd	 rax, DWORD PTR r2$[rsp]
  0031d	4c 8b 8c 24 c8
	00 00 00	 mov	 r9, QWORD PTR regs$[rsp]
  00325	41 b8 fd ff ff
	ff		 mov	 r8d, -3
  0032b	48 8b 54 24 40	 mov	 rdx, QWORD PTR frrnext$[rsp]
  00330	48 8b 8c 24 c8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00338	8b 8c c1 80 02
	00 00		 mov	 ecx, DWORD PTR [rcx+rax*8+640]
  0033f	e8 00 00 00 00	 call	 z900_vstore4

; 799  :     }

  00344	e9 bc 01 00 00	 jmp	 $LN17@z900_add_f
$LN16@z900_add_f:

; 800  : 
; 801  :     /*  2. SETFRR A,MODE=(HOME, with any combination of LOCAL or GLOBAL or EUT=YES.  */
; 802  : 
; 803  :     else if ((!(entrycode & (FULLXM + PRIMARY))) && (entrycode & (EUT + GLOBAL + LOCAL)))

  00349	0f b6 44 24 30	 movzx	 eax, BYTE PTR entrycode$[rsp]
  0034e	83 e0 0c	 and	 eax, 12
  00351	85 c0		 test	 eax, eax
  00353	75 77		 jne	 SHORT $LN18@z900_add_f
  00355	0f b6 44 24 30	 movzx	 eax, BYTE PTR entrycode$[rsp]
  0035a	25 83 00 00 00	 and	 eax, 131		; 00000083H
  0035f	85 c0		 test	 eax, eax
  00361	74 69		 je	 SHORT $LN18@z900_add_f

; 804  :     {
; 805  :         /* Set the FRR entry point from r2 in the stack */
; 806  :         ARCH_DEP( vstore4 )( regs->GR_L(r2) | 0x00000001, frrnext, USE_PRIMARY_SPACE, regs );

  00363	48 63 44 24 48	 movsxd	 rax, DWORD PTR r2$[rsp]
  00368	48 8b 8c 24 c8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00370	8b 84 c1 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax*8+640]
  00377	83 c8 01	 or	 eax, 1
  0037a	4c 8b 8c 24 c8
	00 00 00	 mov	 r9, QWORD PTR regs$[rsp]
  00382	41 b8 fd ff ff
	ff		 mov	 r8d, -3
  00388	48 8b 54 24 40	 mov	 rdx, QWORD PTR frrnext$[rsp]
  0038d	8b c8		 mov	 ecx, eax
  0038f	e8 00 00 00 00	 call	 z900_vstore4

; 807  : 
; 808  :         /* The entry code is stored in the FRR stack */
; 809  :         ARCH_DEP( vstoreb )( entrycode, (frrnext + 7) & ADDRESS_MAXWRAP( regs ), USE_PRIMARY_SPACE, regs );

  00394	48 8b 44 24 40	 mov	 rax, QWORD PTR frrnext$[rsp]
  00399	48 83 c0 07	 add	 rax, 7
  0039d	48 8b 8c 24 c8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  003a5	48 23 81 90 00
	00 00		 and	 rax, QWORD PTR [rcx+144]
  003ac	4c 8b 8c 24 c8
	00 00 00	 mov	 r9, QWORD PTR regs$[rsp]
  003b4	41 b8 fd ff ff
	ff		 mov	 r8d, -3
  003ba	48 8b d0	 mov	 rdx, rax
  003bd	0f b6 4c 24 30	 movzx	 ecx, BYTE PTR entrycode$[rsp]
  003c2	e8 00 00 00 00	 call	 z900_vstoreb

; 810  :     }

  003c7	e9 39 01 00 00	 jmp	 $LN19@z900_add_f
$LN18@z900_add_f:

; 811  : 
; 812  :     /*  3. SETFRR A,MODE=(FULLXM | PRIMARY, with any or no combination of LOCAL or GLOBAL or EUT=YES.  */
; 813  : 
; 814  :     else
; 815  :     {
; 816  :         BYTE cr34[8];  // CR3 and CR4
; 817  : 
; 818  :         /* Set the FRR entry point from r2 in the stack */
; 819  :         ARCH_DEP( vstore4 )( regs->GR_L(r2) | 0x00000001, frrnext, USE_PRIMARY_SPACE, regs );

  003cc	48 63 44 24 48	 movsxd	 rax, DWORD PTR r2$[rsp]
  003d1	48 8b 8c 24 c8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  003d9	8b 84 c1 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax*8+640]
  003e0	83 c8 01	 or	 eax, 1
  003e3	4c 8b 8c 24 c8
	00 00 00	 mov	 r9, QWORD PTR regs$[rsp]
  003eb	41 b8 fd ff ff
	ff		 mov	 r8d, -3
  003f1	48 8b 54 24 40	 mov	 rdx, QWORD PTR frrnext$[rsp]
  003f6	8b c8		 mov	 ecx, eax
  003f8	e8 00 00 00 00	 call	 z900_vstore4

; 820  : 
; 821  :         /* Check if in secondary access mode; if yes turn on secondary bit in the entry code */
; 822  :         if (ARCH_DEP( vfetchb )( (PSAXMFLG & ADDRESS_MAXWRAP( regs )), USE_PRIMARY_SPACE, regs ) & PSAXMODE)

  003fd	48 8b 84 24 c8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00405	48 8b 80 90 00
	00 00		 mov	 rax, QWORD PTR [rax+144]
  0040c	48 25 9c 04 00
	00		 and	 rax, 1180		; 0000049cH
  00412	4c 8b 84 24 c8
	00 00 00	 mov	 r8, QWORD PTR regs$[rsp]
  0041a	ba fd ff ff ff	 mov	 edx, -3
  0041f	48 8b c8	 mov	 rcx, rax
  00422	e8 00 00 00 00	 call	 z900_vfetchb
  00427	0f b6 c0	 movzx	 eax, al
  0042a	83 e0 40	 and	 eax, 64			; 00000040H
  0042d	85 c0		 test	 eax, eax
  0042f	74 0c		 je	 SHORT $LN20@z900_add_f

; 823  :             entrycode |= PSAXMODE;  // indicate to FRR in secondary mode

  00431	0f b6 44 24 30	 movzx	 eax, BYTE PTR entrycode$[rsp]
  00436	83 c8 40	 or	 eax, 64			; 00000040H
  00439	88 44 24 30	 mov	 BYTE PTR entrycode$[rsp], al
$LN20@z900_add_f:

; 824  : 
; 825  :         /* The entry code is stored in the FRR stack */
; 826  :         ARCH_DEP( vstoreb )( entrycode, ((frrnext + 7) & ADDRESS_MAXWRAP( regs )), USE_PRIMARY_SPACE, regs );

  0043d	48 8b 44 24 40	 mov	 rax, QWORD PTR frrnext$[rsp]
  00442	48 83 c0 07	 add	 rax, 7
  00446	48 8b 8c 24 c8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0044e	48 23 81 90 00
	00 00		 and	 rax, QWORD PTR [rcx+144]
  00455	4c 8b 8c 24 c8
	00 00 00	 mov	 r9, QWORD PTR regs$[rsp]
  0045d	41 b8 fd ff ff
	ff		 mov	 r8d, -3
  00463	48 8b d0	 mov	 rdx, rax
  00466	0f b6 4c 24 30	 movzx	 ecx, BYTE PTR entrycode$[rsp]
  0046b	e8 00 00 00 00	 call	 z900_vstoreb

; 827  : 
; 828  :         /* Compute the address of the FRR area where CR3 and CR4 are copied from the PSA */
; 829  :         cr_ptr = frrnext - frrparm;

  00470	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR frrparm$[rsp]
  00478	48 8b 4c 24 40	 mov	 rcx, QWORD PTR frrnext$[rsp]
  0047d	48 2b c8	 sub	 rcx, rax
  00480	48 8b c1	 mov	 rax, rcx
  00483	48 89 44 24 68	 mov	 QWORD PTR cr_ptr$[rsp], rax

; 830  :         cr_ptr = cr_ptr >> 2;

  00488	48 8b 44 24 68	 mov	 rax, QWORD PTR cr_ptr$[rsp]
  0048d	48 c1 e8 02	 shr	 rax, 2
  00491	48 89 44 24 68	 mov	 QWORD PTR cr_ptr$[rsp], rax

; 831  :         cr_ptr = (frrstak + cr_ptr + 120) & ADDRESS_MAXWRAP( regs );

  00496	48 8b 44 24 50	 mov	 rax, QWORD PTR frrstak$[rsp]
  0049b	48 8b 4c 24 68	 mov	 rcx, QWORD PTR cr_ptr$[rsp]
  004a0	48 8d 44 08 78	 lea	 rax, QWORD PTR [rax+rcx+120]
  004a5	48 8b 8c 24 c8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  004ad	48 23 81 90 00
	00 00		 and	 rax, QWORD PTR [rcx+144]
  004b4	48 89 44 24 68	 mov	 QWORD PTR cr_ptr$[rsp], rax

; 832  : 
; 833  :         /* Copy CR3 and CR4 values from PSA to computed FRR area */
; 834  :         ARCH_DEP( vfetchc )( cr34, 8-1, PSAXMCR3, USE_PRIMARY_SPACE, regs );

  004b9	48 8b 84 24 c8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  004c1	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  004c6	41 b9 fd ff ff
	ff		 mov	 r9d, -3
  004cc	41 b8 c4 05 00
	00		 mov	 r8d, 1476		; 000005c4H
  004d2	b2 07		 mov	 dl, 7
  004d4	48 8d 8c 24 98
	00 00 00	 lea	 rcx, QWORD PTR cr34$2[rsp]
  004dc	e8 00 00 00 00	 call	 z900_vfetchc

; 835  :         ARCH_DEP( vstorec )( cr34, 8-1, cr_ptr, 0, regs );

  004e1	48 8b 84 24 c8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  004e9	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  004ee	45 33 c9	 xor	 r9d, r9d
  004f1	4c 8b 44 24 68	 mov	 r8, QWORD PTR cr_ptr$[rsp]
  004f6	b2 07		 mov	 dl, 7
  004f8	48 8d 8c 24 98
	00 00 00	 lea	 rcx, QWORD PTR cr34$2[rsp]
  00500	e8 00 00 00 00	 call	 z900_vstorec
$LN19@z900_add_f:
$LN17@z900_add_f:

; 836  :     }
; 837  : 
; 838  :     /* Update the FRR stack pointers to point to the newly added FRR */
; 839  :     ARCH_DEP( vstore4 )( frrnext, (frrstak + 12) & ADDRESS_MAXWRAP( regs ), USE_PRIMARY_SPACE, regs );

  00505	48 8b 44 24 50	 mov	 rax, QWORD PTR frrstak$[rsp]
  0050a	48 83 c0 0c	 add	 rax, 12
  0050e	48 8b 8c 24 c8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00516	48 23 81 90 00
	00 00		 and	 rax, QWORD PTR [rcx+144]
  0051d	4c 8b 8c 24 c8
	00 00 00	 mov	 r9, QWORD PTR regs$[rsp]
  00525	41 b8 fd ff ff
	ff		 mov	 r8d, -3
  0052b	48 8b d0	 mov	 rdx, rax
  0052e	8b 4c 24 40	 mov	 ecx, DWORD PTR frrnext$[rsp]
  00532	e8 00 00 00 00	 call	 z900_vstore4

; 840  : 
; 841  :     /* Return with the FRRSPARM area address in r1 per the assist documentation  */
; 842  :     regs->GR_L(r1) = (frrnext + FRRSPARM) & ADDRESS_MAXWRAP( regs );

  00537	48 8b 44 24 40	 mov	 rax, QWORD PTR frrnext$[rsp]
  0053c	48 83 c0 08	 add	 rax, 8
  00540	48 8b 8c 24 c8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00548	48 23 81 90 00
	00 00		 and	 rax, QWORD PTR [rcx+144]
  0054f	48 63 4c 24 5c	 movsxd	 rcx, DWORD PTR r1$[rsp]
  00554	48 8b 94 24 c8
	00 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  0055c	89 84 ca 80 02
	00 00		 mov	 DWORD PTR [rdx+rcx*8+640], eax

; 843  : 
; 844  :     /* Initialize (clear) the rest of the FRR stack */
; 845  :     clear_vaddr = (frrnext + 8) & ADDRESS_MAXWRAP( regs );

  00563	48 8b 44 24 40	 mov	 rax, QWORD PTR frrnext$[rsp]
  00568	48 83 c0 08	 add	 rax, 8
  0056c	48 8b 8c 24 c8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00574	48 23 81 90 00
	00 00		 and	 rax, QWORD PTR [rcx+144]
  0057b	48 89 44 24 70	 mov	 QWORD PTR clear_vaddr$[rsp], rax

; 846  :     len = 256;

  00580	c7 44 24 38 00
	01 00 00	 mov	 DWORD PTR len$[rsp], 256 ; 00000100H

; 847  :     size = frrsize;

  00588	8b 44 24 60	 mov	 eax, DWORD PTR frrsize$[rsp]
  0058c	89 44 24 34	 mov	 DWORD PTR size$[rsp], eax
$LN8@z900_add_f:

; 848  :     while (size)

  00590	83 7c 24 34 00	 cmp	 DWORD PTR size$[rsp], 0
  00595	0f 84 84 00 00
	00		 je	 $LN9@z900_add_f

; 849  :     {
; 850  :         if (len > size) len = size;

  0059b	8b 44 24 34	 mov	 eax, DWORD PTR size$[rsp]
  0059f	39 44 24 38	 cmp	 DWORD PTR len$[rsp], eax
  005a3	76 08		 jbe	 SHORT $LN21@z900_add_f
  005a5	8b 44 24 34	 mov	 eax, DWORD PTR size$[rsp]
  005a9	89 44 24 38	 mov	 DWORD PTR len$[rsp], eax
$LN21@z900_add_f:

; 851  :         ARCH_DEP( vstorec )( zeros, len-1, clear_vaddr, 0, regs );

  005ad	8b 44 24 38	 mov	 eax, DWORD PTR len$[rsp]
  005b1	ff c8		 dec	 eax
  005b3	48 8b 8c 24 c8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  005bb	48 89 4c 24 20	 mov	 QWORD PTR [rsp+32], rcx
  005c0	45 33 c9	 xor	 r9d, r9d
  005c3	4c 8b 44 24 70	 mov	 r8, QWORD PTR clear_vaddr$[rsp]
  005c8	0f b6 d0	 movzx	 edx, al
  005cb	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:?zeros@?1??z900_add_frr@@9@9
  005d2	e8 00 00 00 00	 call	 z900_vstorec

; 852  :         size        -= len;

  005d7	8b 44 24 38	 mov	 eax, DWORD PTR len$[rsp]
  005db	8b 4c 24 34	 mov	 ecx, DWORD PTR size$[rsp]
  005df	2b c8		 sub	 ecx, eax
  005e1	8b c1		 mov	 eax, ecx
  005e3	89 44 24 34	 mov	 DWORD PTR size$[rsp], eax

; 853  :         clear_vaddr += len;

  005e7	8b 44 24 38	 mov	 eax, DWORD PTR len$[rsp]
  005eb	48 8b 4c 24 70	 mov	 rcx, QWORD PTR clear_vaddr$[rsp]
  005f0	48 03 c8	 add	 rcx, rax
  005f3	48 8b c1	 mov	 rax, rcx
  005f6	48 89 44 24 70	 mov	 QWORD PTR clear_vaddr$[rsp], rax

; 854  :         clear_vaddr &= ADDRESS_MAXWRAP( regs );

  005fb	48 8b 84 24 c8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00603	48 8b 80 90 00
	00 00		 mov	 rax, QWORD PTR [rax+144]
  0060a	48 8b 4c 24 70	 mov	 rcx, QWORD PTR clear_vaddr$[rsp]
  0060f	48 23 c8	 and	 rcx, rax
  00612	48 8b c1	 mov	 rax, rcx
  00615	48 89 44 24 70	 mov	 QWORD PTR clear_vaddr$[rsp], rax

; 855  :     }

  0061a	e9 71 ff ff ff	 jmp	 $LN8@z900_add_f
$LN9@z900_add_f:
$LN1@z900_add_f:

; 856  : }

  0061f	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  00627	48 33 cc	 xor	 rcx, rsp
  0062a	e8 00 00 00 00	 call	 __security_check_cookie
  0062f	48 81 c4 b8 00
	00 00		 add	 rsp, 184		; 000000b8H
  00636	c3		 ret	 0
z900_add_frr ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\vstore.h
;	COMDAT s390_vfetch4
_TEXT	SEGMENT
tv66 = 48
tv72 = 52
mn$1 = 56
addr$ = 80
arn$ = 88
regs$ = 96
s390_vfetch4 PROC					; COMDAT

; 695  : {

$LN11:
  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00009	89 4c 24 08	 mov	 DWORD PTR [rsp+8], ecx
  0000d	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 696  :     if ((likely(!((VADR_L)addr & 0x03))
; 697  :         || (((VADR_L)addr & PAGEFRAME_BYTEMASK) <= (PAGEFRAME_BYTEMASK-3) )))

  00011	8b 44 24 50	 mov	 eax, DWORD PTR addr$[rsp]
  00015	83 e0 03	 and	 eax, 3
  00018	85 c0		 test	 eax, eax
  0001a	75 0a		 jne	 SHORT $LN5@s390_vfetc
  0001c	c7 44 24 30 01
	00 00 00	 mov	 DWORD PTR tv66[rsp], 1
  00024	eb 08		 jmp	 SHORT $LN6@s390_vfetc
$LN5@s390_vfetc:
  00026	c7 44 24 30 00
	00 00 00	 mov	 DWORD PTR tv66[rsp], 0
$LN6@s390_vfetc:
  0002e	83 7c 24 30 00	 cmp	 DWORD PTR tv66[rsp], 0
  00033	74 0a		 je	 SHORT $LN9@s390_vfetc
  00035	c7 44 24 34 01
	00 00 00	 mov	 DWORD PTR tv72[rsp], 1
  0003d	eb 08		 jmp	 SHORT $LN10@s390_vfetc
$LN9@s390_vfetc:
  0003f	c7 44 24 34 00
	00 00 00	 mov	 DWORD PTR tv72[rsp], 0
$LN10@s390_vfetc:
  00047	83 7c 24 34 00	 cmp	 DWORD PTR tv72[rsp], 0
  0004c	75 10		 jne	 SHORT $LN3@s390_vfetc
  0004e	8b 44 24 50	 mov	 eax, DWORD PTR addr$[rsp]
  00052	25 ff 0f 00 00	 and	 eax, 4095		; 00000fffH
  00057	3d fc 0f 00 00	 cmp	 eax, 4092		; 00000ffcH
  0005c	77 45		 ja	 SHORT $LN2@s390_vfetc
$LN3@s390_vfetc:

; 698  :     {
; 699  :         BYTE *mn;
; 700  :         ITIMER_SYNC( addr, 4-1, regs );
; 701  :         mn = MADDRL( addr, 4,arn, regs, ACCTYPE_READ, regs->psw.pkey );

  0005e	48 8b 44 24 60	 mov	 rax, QWORD PTR regs$[rsp]
  00063	0f b6 40 79	 movzx	 eax, BYTE PTR [rax+121]
  00067	88 44 24 28	 mov	 BYTE PTR [rsp+40], al
  0006b	c7 44 24 20 04
	00 00 00	 mov	 DWORD PTR [rsp+32], 4
  00073	4c 8b 4c 24 60	 mov	 r9, QWORD PTR regs$[rsp]
  00078	44 8b 44 24 58	 mov	 r8d, DWORD PTR arn$[rsp]
  0007d	ba 04 00 00 00	 mov	 edx, 4
  00082	8b 4c 24 50	 mov	 ecx, DWORD PTR addr$[rsp]
  00086	e8 00 00 00 00	 call	 s390_maddr_l
  0008b	48 89 44 24 38	 mov	 QWORD PTR mn$1[rsp], rax

; 702  :         return fetch_fw( mn );

  00090	48 8b 4c 24 38	 mov	 rcx, QWORD PTR mn$1[rsp]
  00095	e8 00 00 00 00	 call	 fetch_fw_noswap
  0009a	8b c8		 mov	 ecx, eax
  0009c	e8 00 00 00 00	 call	 _byteswap_ulong
  000a1	eb 12		 jmp	 SHORT $LN1@s390_vfetc
$LN2@s390_vfetc:

; 703  :     }
; 704  :     return ARCH_DEP( vfetch4_full )( addr, arn, regs );

  000a3	4c 8b 44 24 60	 mov	 r8, QWORD PTR regs$[rsp]
  000a8	8b 54 24 58	 mov	 edx, DWORD PTR arn$[rsp]
  000ac	8b 4c 24 50	 mov	 ecx, DWORD PTR addr$[rsp]
  000b0	e8 00 00 00 00	 call	 s390_vfetch4_full
$LN1@s390_vfetc:

; 705  : }

  000b5	48 83 c4 48	 add	 rsp, 72			; 00000048H
  000b9	c3		 ret	 0
s390_vfetch4 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\vstore.h
;	COMDAT s390_vfetchb
_TEXT	SEGMENT
mn$ = 48
addr$ = 80
arn$ = 88
regs$ = 96
s390_vfetchb PROC					; COMDAT

; 667  : {

$LN3:
  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00009	89 4c 24 08	 mov	 DWORD PTR [rsp+8], ecx
  0000d	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 668  : BYTE   *mn;                             /* Main storage address      */
; 669  : 
; 670  :     ITIMER_SYNC( addr, 1-1, regs );
; 671  :     mn = MADDR( addr, arn, regs, ACCTYPE_READ, regs->psw.pkey );

  00011	48 8b 44 24 60	 mov	 rax, QWORD PTR regs$[rsp]
  00016	0f b6 40 79	 movzx	 eax, BYTE PTR [rax+121]
  0001a	88 44 24 28	 mov	 BYTE PTR [rsp+40], al
  0001e	c7 44 24 20 04
	00 00 00	 mov	 DWORD PTR [rsp+32], 4
  00026	4c 8b 4c 24 60	 mov	 r9, QWORD PTR regs$[rsp]
  0002b	44 8b 44 24 58	 mov	 r8d, DWORD PTR arn$[rsp]
  00030	ba 01 00 00 00	 mov	 edx, 1
  00035	8b 4c 24 50	 mov	 ecx, DWORD PTR addr$[rsp]
  00039	e8 00 00 00 00	 call	 s390_maddr_l
  0003e	48 89 44 24 30	 mov	 QWORD PTR mn$[rsp], rax

; 672  :     return *mn;

  00043	48 8b 44 24 30	 mov	 rax, QWORD PTR mn$[rsp]
  00048	0f b6 00	 movzx	 eax, BYTE PTR [rax]

; 673  : }

  0004b	48 83 c4 48	 add	 rsp, 72			; 00000048H
  0004f	c3		 ret	 0
s390_vfetchb ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\vstore.h
;	COMDAT s390_vfetchc
_TEXT	SEGMENT
len2$ = 48
tv74 = 52
main1$ = 56
main2$ = 64
dest$ = 112
len$ = 120
addr$ = 128
arn$ = 136
regs$ = 144
s390_vfetchc PROC					; COMDAT

; 631  : {

$LN9:
  00000	44 89 4c 24 20	 mov	 DWORD PTR [rsp+32], r9d
  00005	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  0000a	88 54 24 10	 mov	 BYTE PTR [rsp+16], dl
  0000e	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00013	56		 push	 rsi
  00014	57		 push	 rdi
  00015	48 83 ec 58	 sub	 rsp, 88			; 00000058H

; 632  : BYTE   *main1, *main2;                  /* Main storage addresses    */
; 633  : int     len2;                           /* Length to copy on page    */
; 634  : 
; 635  :     if (NOCROSSPAGE( addr, len ))

  00019	8b 84 24 80 00
	00 00		 mov	 eax, DWORD PTR addr$[rsp]
  00020	25 ff 0f 00 00	 and	 eax, 4095		; 00000fffH
  00025	0f b6 4c 24 78	 movzx	 ecx, BYTE PTR len$[rsp]
  0002a	ba ff 0f 00 00	 mov	 edx, 4095		; 00000fffH
  0002f	2b d1		 sub	 edx, ecx
  00031	8b ca		 mov	 ecx, edx
  00033	3b c1		 cmp	 eax, ecx
  00035	7f 0a		 jg	 SHORT $LN7@s390_vfetc
  00037	c7 44 24 34 01
	00 00 00	 mov	 DWORD PTR tv74[rsp], 1
  0003f	eb 08		 jmp	 SHORT $LN8@s390_vfetc
$LN7@s390_vfetc:
  00041	c7 44 24 34 00
	00 00 00	 mov	 DWORD PTR tv74[rsp], 0
$LN8@s390_vfetc:
  00049	83 7c 24 34 00	 cmp	 DWORD PTR tv74[rsp], 0
  0004e	74 62		 je	 SHORT $LN2@s390_vfetc

; 636  :     {
; 637  :         ITIMER_SYNC( addr, len, regs );
; 638  :         main1 = MADDRL( addr, len + 1, arn, regs, ACCTYPE_READ, regs->psw.pkey );

  00050	0f b6 44 24 78	 movzx	 eax, BYTE PTR len$[rsp]
  00055	ff c0		 inc	 eax
  00057	48 98		 cdqe
  00059	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00061	0f b6 49 79	 movzx	 ecx, BYTE PTR [rcx+121]
  00065	88 4c 24 28	 mov	 BYTE PTR [rsp+40], cl
  00069	c7 44 24 20 04
	00 00 00	 mov	 DWORD PTR [rsp+32], 4
  00071	4c 8b 8c 24 90
	00 00 00	 mov	 r9, QWORD PTR regs$[rsp]
  00079	44 8b 84 24 88
	00 00 00	 mov	 r8d, DWORD PTR arn$[rsp]
  00081	48 8b d0	 mov	 rdx, rax
  00084	8b 8c 24 80 00
	00 00		 mov	 ecx, DWORD PTR addr$[rsp]
  0008b	e8 00 00 00 00	 call	 s390_maddr_l
  00090	48 89 44 24 38	 mov	 QWORD PTR main1$[rsp], rax

; 639  :         memcpy( dest, main1, len + 1 );

  00095	0f b6 44 24 78	 movzx	 eax, BYTE PTR len$[rsp]
  0009a	ff c0		 inc	 eax
  0009c	48 98		 cdqe
  0009e	48 8b 7c 24 70	 mov	 rdi, QWORD PTR dest$[rsp]
  000a3	48 8b 74 24 38	 mov	 rsi, QWORD PTR main1$[rsp]
  000a8	48 8b c8	 mov	 rcx, rax
  000ab	f3 a4		 rep movsb

; 640  :     }

  000ad	e9 f7 00 00 00	 jmp	 $LN3@s390_vfetc
$LN2@s390_vfetc:

; 641  :     else
; 642  :     {
; 643  :         len2 = PAGEFRAME_PAGESIZE - (addr & PAGEFRAME_BYTEMASK);

  000b2	8b 84 24 80 00
	00 00		 mov	 eax, DWORD PTR addr$[rsp]
  000b9	25 ff 0f 00 00	 and	 eax, 4095		; 00000fffH
  000be	b9 00 10 00 00	 mov	 ecx, 4096		; 00001000H
  000c3	2b c8		 sub	 ecx, eax
  000c5	8b c1		 mov	 eax, ecx
  000c7	89 44 24 30	 mov	 DWORD PTR len2$[rsp], eax

; 644  :         main1 = MADDRL( addr, len2, arn, regs, ACCTYPE_READ, regs->psw.pkey );

  000cb	48 63 44 24 30	 movsxd	 rax, DWORD PTR len2$[rsp]
  000d0	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  000d8	0f b6 49 79	 movzx	 ecx, BYTE PTR [rcx+121]
  000dc	88 4c 24 28	 mov	 BYTE PTR [rsp+40], cl
  000e0	c7 44 24 20 04
	00 00 00	 mov	 DWORD PTR [rsp+32], 4
  000e8	4c 8b 8c 24 90
	00 00 00	 mov	 r9, QWORD PTR regs$[rsp]
  000f0	44 8b 84 24 88
	00 00 00	 mov	 r8d, DWORD PTR arn$[rsp]
  000f8	48 8b d0	 mov	 rdx, rax
  000fb	8b 8c 24 80 00
	00 00		 mov	 ecx, DWORD PTR addr$[rsp]
  00102	e8 00 00 00 00	 call	 s390_maddr_l
  00107	48 89 44 24 38	 mov	 QWORD PTR main1$[rsp], rax

; 645  :         main2 = MADDRL( (addr + len2) & ADDRESS_MAXWRAP( regs ), len + 1 - len2,

  0010c	0f b6 44 24 78	 movzx	 eax, BYTE PTR len$[rsp]
  00111	ff c0		 inc	 eax
  00113	2b 44 24 30	 sub	 eax, DWORD PTR len2$[rsp]
  00117	48 98		 cdqe
  00119	8b 4c 24 30	 mov	 ecx, DWORD PTR len2$[rsp]
  0011d	8b 94 24 80 00
	00 00		 mov	 edx, DWORD PTR addr$[rsp]
  00124	03 d1		 add	 edx, ecx
  00126	8b ca		 mov	 ecx, edx
  00128	48 8b 94 24 90
	00 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  00130	23 8a 90 00 00
	00		 and	 ecx, DWORD PTR [rdx+144]
  00136	48 8b 94 24 90
	00 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  0013e	0f b6 52 79	 movzx	 edx, BYTE PTR [rdx+121]
  00142	88 54 24 28	 mov	 BYTE PTR [rsp+40], dl
  00146	c7 44 24 20 04
	00 00 00	 mov	 DWORD PTR [rsp+32], 4
  0014e	4c 8b 8c 24 90
	00 00 00	 mov	 r9, QWORD PTR regs$[rsp]
  00156	44 8b 84 24 88
	00 00 00	 mov	 r8d, DWORD PTR arn$[rsp]
  0015e	48 8b d0	 mov	 rdx, rax
  00161	e8 00 00 00 00	 call	 s390_maddr_l
  00166	48 89 44 24 40	 mov	 QWORD PTR main2$[rsp], rax

; 646  :                         arn, regs, ACCTYPE_READ, regs->psw.pkey );
; 647  :         memcpy(        dest,        main1,           len2 );

  0016b	48 63 44 24 30	 movsxd	 rax, DWORD PTR len2$[rsp]
  00170	48 8b 7c 24 70	 mov	 rdi, QWORD PTR dest$[rsp]
  00175	48 8b 74 24 38	 mov	 rsi, QWORD PTR main1$[rsp]
  0017a	48 8b c8	 mov	 rcx, rax
  0017d	f3 a4		 rep movsb

; 648  :         memcpy( (BYTE*)dest + len2, main2, len + 1 - len2 );

  0017f	0f b6 44 24 78	 movzx	 eax, BYTE PTR len$[rsp]
  00184	ff c0		 inc	 eax
  00186	2b 44 24 30	 sub	 eax, DWORD PTR len2$[rsp]
  0018a	48 98		 cdqe
  0018c	48 63 4c 24 30	 movsxd	 rcx, DWORD PTR len2$[rsp]
  00191	48 8b 54 24 70	 mov	 rdx, QWORD PTR dest$[rsp]
  00196	48 03 d1	 add	 rdx, rcx
  00199	48 8b ca	 mov	 rcx, rdx
  0019c	48 8b f9	 mov	 rdi, rcx
  0019f	48 8b 74 24 40	 mov	 rsi, QWORD PTR main2$[rsp]
  001a4	48 8b c8	 mov	 rcx, rax
  001a7	f3 a4		 rep movsb
$LN3@s390_vfetc:

; 649  :     }
; 650  : }

  001a9	48 83 c4 58	 add	 rsp, 88			; 00000058H
  001ad	5f		 pop	 rdi
  001ae	5e		 pop	 rsi
  001af	c3		 ret	 0
s390_vfetchc ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\vstore.h
;	COMDAT s390_vstore4
_TEXT	SEGMENT
tv66 = 48
tv72 = 52
mn$1 = 56
value$ = 80
addr$ = 88
arn$ = 96
regs$ = 104
s390_vstore4 PROC					; COMDAT

; 559  : {

$LN12:
  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  0000a	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  0000e	89 4c 24 08	 mov	 DWORD PTR [rsp+8], ecx
  00012	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 560  :     /* Most common case : Aligned & not crossing page boundary */
; 561  :     if (likely(!((VADR_L)addr & 0x03))
; 562  :         || (((VADR_L)addr & PAGEFRAME_BYTEMASK) <= (PAGEFRAME_BYTEMASK-3)))

  00016	8b 44 24 58	 mov	 eax, DWORD PTR addr$[rsp]
  0001a	83 e0 03	 and	 eax, 3
  0001d	85 c0		 test	 eax, eax
  0001f	75 0a		 jne	 SHORT $LN6@s390_vstor
  00021	c7 44 24 30 01
	00 00 00	 mov	 DWORD PTR tv66[rsp], 1
  00029	eb 08		 jmp	 SHORT $LN7@s390_vstor
$LN6@s390_vstor:
  0002b	c7 44 24 30 00
	00 00 00	 mov	 DWORD PTR tv66[rsp], 0
$LN7@s390_vstor:
  00033	83 7c 24 30 00	 cmp	 DWORD PTR tv66[rsp], 0
  00038	74 0a		 je	 SHORT $LN10@s390_vstor
  0003a	c7 44 24 34 01
	00 00 00	 mov	 DWORD PTR tv72[rsp], 1
  00042	eb 08		 jmp	 SHORT $LN11@s390_vstor
$LN10@s390_vstor:
  00044	c7 44 24 34 00
	00 00 00	 mov	 DWORD PTR tv72[rsp], 0
$LN11@s390_vstor:
  0004c	83 7c 24 34 00	 cmp	 DWORD PTR tv72[rsp], 0
  00051	75 10		 jne	 SHORT $LN4@s390_vstor
  00053	8b 44 24 58	 mov	 eax, DWORD PTR addr$[rsp]
  00057	25 ff 0f 00 00	 and	 eax, 4095		; 00000fffH
  0005c	3d fc 0f 00 00	 cmp	 eax, 4092		; 00000ffcH
  00061	77 49		 ja	 SHORT $LN2@s390_vstor
$LN4@s390_vstor:

; 563  :     {
; 564  :         BYTE *mn;
; 565  :         mn = MADDRL( addr, 4, arn, regs, ACCTYPE_WRITE, regs->psw.pkey );

  00063	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  00068	0f b6 40 79	 movzx	 eax, BYTE PTR [rax+121]
  0006c	88 44 24 28	 mov	 BYTE PTR [rsp+40], al
  00070	c7 44 24 20 02
	00 00 00	 mov	 DWORD PTR [rsp+32], 2
  00078	4c 8b 4c 24 68	 mov	 r9, QWORD PTR regs$[rsp]
  0007d	44 8b 44 24 60	 mov	 r8d, DWORD PTR arn$[rsp]
  00082	ba 04 00 00 00	 mov	 edx, 4
  00087	8b 4c 24 58	 mov	 ecx, DWORD PTR addr$[rsp]
  0008b	e8 00 00 00 00	 call	 s390_maddr_l
  00090	48 89 44 24 38	 mov	 QWORD PTR mn$1[rsp], rax

; 566  :         STORE_FW( mn, value );

  00095	8b 4c 24 50	 mov	 ecx, DWORD PTR value$[rsp]
  00099	e8 00 00 00 00	 call	 _byteswap_ulong
  0009e	8b d0		 mov	 edx, eax
  000a0	48 8b 4c 24 38	 mov	 rcx, QWORD PTR mn$1[rsp]
  000a5	e8 00 00 00 00	 call	 store_fw_noswap

; 567  :         ITIMER_UPDATE( addr, 4-1, regs );
; 568  :     }

  000aa	eb 17		 jmp	 SHORT $LN3@s390_vstor
$LN2@s390_vstor:

; 569  :     else
; 570  :         ARCH_DEP( vstore4_full )( value, addr, arn, regs );

  000ac	4c 8b 4c 24 68	 mov	 r9, QWORD PTR regs$[rsp]
  000b1	44 8b 44 24 60	 mov	 r8d, DWORD PTR arn$[rsp]
  000b6	8b 54 24 58	 mov	 edx, DWORD PTR addr$[rsp]
  000ba	8b 4c 24 50	 mov	 ecx, DWORD PTR value$[rsp]
  000be	e8 00 00 00 00	 call	 s390_vstore4_full
$LN3@s390_vstor:

; 571  : }

  000c3	48 83 c4 48	 add	 rsp, 72			; 00000048H
  000c7	c3		 ret	 0
s390_vstore4 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\vstore.h
;	COMDAT s390_vstoreb
_TEXT	SEGMENT
main1$ = 48
value$ = 80
addr$ = 88
arn$ = 96
regs$ = 104
s390_vstoreb PROC					; COMDAT

; 529  : {

$LN3:
  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  0000a	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  0000e	88 4c 24 08	 mov	 BYTE PTR [rsp+8], cl
  00012	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 530  : BYTE   *main1;                          /* Mainstor address          */
; 531  : 
; 532  :     main1 = MADDR( addr, arn, regs, ACCTYPE_WRITE, regs->psw.pkey );

  00016	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  0001b	0f b6 40 79	 movzx	 eax, BYTE PTR [rax+121]
  0001f	88 44 24 28	 mov	 BYTE PTR [rsp+40], al
  00023	c7 44 24 20 02
	00 00 00	 mov	 DWORD PTR [rsp+32], 2
  0002b	4c 8b 4c 24 68	 mov	 r9, QWORD PTR regs$[rsp]
  00030	44 8b 44 24 60	 mov	 r8d, DWORD PTR arn$[rsp]
  00035	ba 01 00 00 00	 mov	 edx, 1
  0003a	8b 4c 24 58	 mov	 ecx, DWORD PTR addr$[rsp]
  0003e	e8 00 00 00 00	 call	 s390_maddr_l
  00043	48 89 44 24 30	 mov	 QWORD PTR main1$[rsp], rax

; 533  :     *main1 = value;

  00048	48 8b 44 24 30	 mov	 rax, QWORD PTR main1$[rsp]
  0004d	0f b6 4c 24 50	 movzx	 ecx, BYTE PTR value$[rsp]
  00052	88 08		 mov	 BYTE PTR [rax], cl

; 534  :     ITIMER_UPDATE( addr, 1-1, regs );
; 535  : }

  00054	48 83 c4 48	 add	 rsp, 72			; 00000048H
  00058	c3		 ret	 0
s390_vstoreb ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\vstore.h
;	COMDAT s390_vstorec
_TEXT	SEGMENT
len2$ = 48
tv74 = 52
sk$ = 56
tv81 = 64
main1$ = 72
main2$ = 80
src$ = 128
len$ = 136
addr$ = 144
arn$ = 152
regs$ = 160
s390_vstorec PROC					; COMDAT

; 489  : {

$LN9:
  00000	44 89 4c 24 20	 mov	 DWORD PTR [rsp+32], r9d
  00005	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  0000a	88 54 24 10	 mov	 BYTE PTR [rsp+16], dl
  0000e	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00013	56		 push	 rsi
  00014	57		 push	 rdi
  00015	48 83 ec 68	 sub	 rsp, 104		; 00000068H

; 490  : BYTE   *main1, *main2;                  /* Mainstor addresses        */
; 491  : BYTE   *sk;                             /* Storage key addresses     */
; 492  : int     len2;                           /* Length to end of page     */
; 493  : 
; 494  :     if (NOCROSSPAGE( addr,len ))

  00019	8b 84 24 90 00
	00 00		 mov	 eax, DWORD PTR addr$[rsp]
  00020	25 ff 0f 00 00	 and	 eax, 4095		; 00000fffH
  00025	0f b6 8c 24 88
	00 00 00	 movzx	 ecx, BYTE PTR len$[rsp]
  0002d	ba ff 0f 00 00	 mov	 edx, 4095		; 00000fffH
  00032	2b d1		 sub	 edx, ecx
  00034	8b ca		 mov	 ecx, edx
  00036	3b c1		 cmp	 eax, ecx
  00038	7f 0a		 jg	 SHORT $LN7@s390_vstor
  0003a	c7 44 24 34 01
	00 00 00	 mov	 DWORD PTR tv74[rsp], 1
  00042	eb 08		 jmp	 SHORT $LN8@s390_vstor
$LN7@s390_vstor:
  00044	c7 44 24 34 00
	00 00 00	 mov	 DWORD PTR tv74[rsp], 0
$LN8@s390_vstor:
  0004c	83 7c 24 34 00	 cmp	 DWORD PTR tv74[rsp], 0
  00051	74 6f		 je	 SHORT $LN2@s390_vstor

; 495  :     {
; 496  :         memcpy( MADDRL( addr, len+1, arn, regs, ACCTYPE_WRITE, regs->psw.pkey ),

  00053	0f b6 84 24 88
	00 00 00	 movzx	 eax, BYTE PTR len$[rsp]
  0005b	ff c0		 inc	 eax
  0005d	48 98		 cdqe
  0005f	48 89 44 24 40	 mov	 QWORD PTR tv81[rsp], rax
  00064	0f b6 8c 24 88
	00 00 00	 movzx	 ecx, BYTE PTR len$[rsp]
  0006c	ff c1		 inc	 ecx
  0006e	48 63 c9	 movsxd	 rcx, ecx
  00071	48 8b 94 24 a0
	00 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  00079	0f b6 52 79	 movzx	 edx, BYTE PTR [rdx+121]
  0007d	88 54 24 28	 mov	 BYTE PTR [rsp+40], dl
  00081	c7 44 24 20 02
	00 00 00	 mov	 DWORD PTR [rsp+32], 2
  00089	4c 8b 8c 24 a0
	00 00 00	 mov	 r9, QWORD PTR regs$[rsp]
  00091	44 8b 84 24 98
	00 00 00	 mov	 r8d, DWORD PTR arn$[rsp]
  00099	48 8b d1	 mov	 rdx, rcx
  0009c	8b 8c 24 90 00
	00 00		 mov	 ecx, DWORD PTR addr$[rsp]
  000a3	e8 00 00 00 00	 call	 s390_maddr_l
  000a8	48 8b f8	 mov	 rdi, rax
  000ab	48 8b b4 24 80
	00 00 00	 mov	 rsi, QWORD PTR src$[rsp]
  000b3	48 8b 44 24 40	 mov	 rax, QWORD PTR tv81[rsp]
  000b8	48 8b c8	 mov	 rcx, rax
  000bb	f3 a4		 rep movsb

; 497  :                src, len + 1);
; 498  :         ITIMER_UPDATE( addr, len, regs );
; 499  :     }

  000bd	e9 29 01 00 00	 jmp	 $LN3@s390_vstor
$LN2@s390_vstor:

; 500  :     else
; 501  :     {
; 502  :         len2 = PAGEFRAME_PAGESIZE - (addr & PAGEFRAME_BYTEMASK);

  000c2	8b 84 24 90 00
	00 00		 mov	 eax, DWORD PTR addr$[rsp]
  000c9	25 ff 0f 00 00	 and	 eax, 4095		; 00000fffH
  000ce	b9 00 10 00 00	 mov	 ecx, 4096		; 00001000H
  000d3	2b c8		 sub	 ecx, eax
  000d5	8b c1		 mov	 eax, ecx
  000d7	89 44 24 30	 mov	 DWORD PTR len2$[rsp], eax

; 503  :         main1 = MADDRL( addr, len2, arn, regs, ACCTYPE_WRITE_SKP,

  000db	48 63 44 24 30	 movsxd	 rax, DWORD PTR len2$[rsp]
  000e0	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  000e8	0f b6 49 79	 movzx	 ecx, BYTE PTR [rcx+121]
  000ec	88 4c 24 28	 mov	 BYTE PTR [rsp+40], cl
  000f0	c7 44 24 20 01
	00 00 00	 mov	 DWORD PTR [rsp+32], 1
  000f8	4c 8b 8c 24 a0
	00 00 00	 mov	 r9, QWORD PTR regs$[rsp]
  00100	44 8b 84 24 98
	00 00 00	 mov	 r8d, DWORD PTR arn$[rsp]
  00108	48 8b d0	 mov	 rdx, rax
  0010b	8b 8c 24 90 00
	00 00		 mov	 ecx, DWORD PTR addr$[rsp]
  00112	e8 00 00 00 00	 call	 s390_maddr_l
  00117	48 89 44 24 48	 mov	 QWORD PTR main1$[rsp], rax

; 504  :                         regs->psw.pkey );
; 505  :         sk = regs->dat.storkey;

  0011c	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00124	48 8b 80 28 08
	00 00		 mov	 rax, QWORD PTR [rax+2088]
  0012b	48 89 44 24 38	 mov	 QWORD PTR sk$[rsp], rax

; 506  :         main2 = MADDRL( (addr + len2) & ADDRESS_MAXWRAP( regs ),

  00130	0f b6 84 24 88
	00 00 00	 movzx	 eax, BYTE PTR len$[rsp]
  00138	ff c0		 inc	 eax
  0013a	2b 44 24 30	 sub	 eax, DWORD PTR len2$[rsp]
  0013e	48 98		 cdqe
  00140	8b 4c 24 30	 mov	 ecx, DWORD PTR len2$[rsp]
  00144	8b 94 24 90 00
	00 00		 mov	 edx, DWORD PTR addr$[rsp]
  0014b	03 d1		 add	 edx, ecx
  0014d	8b ca		 mov	 ecx, edx
  0014f	48 8b 94 24 a0
	00 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  00157	23 8a 90 00 00
	00		 and	 ecx, DWORD PTR [rdx+144]
  0015d	48 8b 94 24 a0
	00 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  00165	0f b6 52 79	 movzx	 edx, BYTE PTR [rdx+121]
  00169	88 54 24 28	 mov	 BYTE PTR [rsp+40], dl
  0016d	c7 44 24 20 02
	00 00 00	 mov	 DWORD PTR [rsp+32], 2
  00175	4c 8b 8c 24 a0
	00 00 00	 mov	 r9, QWORD PTR regs$[rsp]
  0017d	44 8b 84 24 98
	00 00 00	 mov	 r8d, DWORD PTR arn$[rsp]
  00185	48 8b d0	 mov	 rdx, rax
  00188	e8 00 00 00 00	 call	 s390_maddr_l
  0018d	48 89 44 24 50	 mov	 QWORD PTR main2$[rsp], rax

; 507  :                         len+1-len2, arn,
; 508  :                         regs, ACCTYPE_WRITE, regs->psw.pkey );
; 509  :         *sk |= (STORKEY_REF | STORKEY_CHANGE);

  00192	48 8b 44 24 38	 mov	 rax, QWORD PTR sk$[rsp]
  00197	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  0019a	83 c8 06	 or	 eax, 6
  0019d	48 8b 4c 24 38	 mov	 rcx, QWORD PTR sk$[rsp]
  001a2	88 01		 mov	 BYTE PTR [rcx], al

; 510  :         memcpy( main1, src, len2 );

  001a4	48 63 44 24 30	 movsxd	 rax, DWORD PTR len2$[rsp]
  001a9	48 8b 7c 24 48	 mov	 rdi, QWORD PTR main1$[rsp]
  001ae	48 8b b4 24 80
	00 00 00	 mov	 rsi, QWORD PTR src$[rsp]
  001b6	48 8b c8	 mov	 rcx, rax
  001b9	f3 a4		 rep movsb

; 511  :         memcpy( main2, (BYTE*)src + len2, len + 1 - len2 );

  001bb	0f b6 84 24 88
	00 00 00	 movzx	 eax, BYTE PTR len$[rsp]
  001c3	ff c0		 inc	 eax
  001c5	2b 44 24 30	 sub	 eax, DWORD PTR len2$[rsp]
  001c9	48 98		 cdqe
  001cb	48 63 4c 24 30	 movsxd	 rcx, DWORD PTR len2$[rsp]
  001d0	48 8b 94 24 80
	00 00 00	 mov	 rdx, QWORD PTR src$[rsp]
  001d8	48 03 d1	 add	 rdx, rcx
  001db	48 8b ca	 mov	 rcx, rdx
  001de	48 8b 7c 24 50	 mov	 rdi, QWORD PTR main2$[rsp]
  001e3	48 8b f1	 mov	 rsi, rcx
  001e6	48 8b c8	 mov	 rcx, rax
  001e9	f3 a4		 rep movsb
$LN3@s390_vstor:

; 512  :     }
; 513  : }

  001eb	48 83 c4 68	 add	 rsp, 104		; 00000068H
  001ef	5f		 pop	 rdi
  001f0	5e		 pop	 rsi
  001f1	c3		 ret	 0
s390_vstorec ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\vstore.h
;	COMDAT s390_vfetch4_full
_TEXT	SEGMENT
len$ = 48
mn$ = 56
temp$ = 64
__$ArrayPad$ = 72
addr$ = 112
arn$ = 120
regs$ = 128
s390_vfetch4_full PROC					; COMDAT

; 428  : {

$LN3:
  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00009	89 4c 24 08	 mov	 DWORD PTR [rsp+8], ecx
  0000d	56		 push	 rsi
  0000e	57		 push	 rdi
  0000f	48 83 ec 58	 sub	 rsp, 88			; 00000058H
  00013	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  0001a	48 33 c4	 xor	 rax, rsp
  0001d	48 89 44 24 48	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 429  : BYTE   *mn;                             /* Main storage addresses    */
; 430  : int     len;                            /* Length to end of page     */
; 431  : BYTE    temp[8];                        /* Copy destination          */
; 432  : 
; 433  :     len = PAGEFRAME_PAGESIZE - (addr & PAGEFRAME_BYTEMASK);

  00022	8b 44 24 70	 mov	 eax, DWORD PTR addr$[rsp]
  00026	25 ff 0f 00 00	 and	 eax, 4095		; 00000fffH
  0002b	b9 00 10 00 00	 mov	 ecx, 4096		; 00001000H
  00030	2b c8		 sub	 ecx, eax
  00032	8b c1		 mov	 eax, ecx
  00034	89 44 24 30	 mov	 DWORD PTR len$[rsp], eax

; 434  :     mn = MADDRL( addr, len, arn, regs, ACCTYPE_READ, regs->psw.pkey );

  00038	48 63 44 24 30	 movsxd	 rax, DWORD PTR len$[rsp]
  0003d	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00045	0f b6 49 79	 movzx	 ecx, BYTE PTR [rcx+121]
  00049	88 4c 24 28	 mov	 BYTE PTR [rsp+40], cl
  0004d	c7 44 24 20 04
	00 00 00	 mov	 DWORD PTR [rsp+32], 4
  00055	4c 8b 8c 24 80
	00 00 00	 mov	 r9, QWORD PTR regs$[rsp]
  0005d	44 8b 44 24 78	 mov	 r8d, DWORD PTR arn$[rsp]
  00062	48 8b d0	 mov	 rdx, rax
  00065	8b 4c 24 70	 mov	 ecx, DWORD PTR addr$[rsp]
  00069	e8 00 00 00 00	 call	 s390_maddr_l
  0006e	48 89 44 24 38	 mov	 QWORD PTR mn$[rsp], rax

; 435  :     memcpy( temp, mn, len);

  00073	48 63 44 24 30	 movsxd	 rax, DWORD PTR len$[rsp]
  00078	48 8d 4c 24 40	 lea	 rcx, QWORD PTR temp$[rsp]
  0007d	48 8b f9	 mov	 rdi, rcx
  00080	48 8b 74 24 38	 mov	 rsi, QWORD PTR mn$[rsp]
  00085	48 8b c8	 mov	 rcx, rax
  00088	f3 a4		 rep movsb

; 436  :     mn = MADDRL( (addr + len) & ADDRESS_MAXWRAP( regs ), 4 - len, arn, regs,

  0008a	b8 04 00 00 00	 mov	 eax, 4
  0008f	2b 44 24 30	 sub	 eax, DWORD PTR len$[rsp]
  00093	48 98		 cdqe
  00095	8b 4c 24 30	 mov	 ecx, DWORD PTR len$[rsp]
  00099	8b 54 24 70	 mov	 edx, DWORD PTR addr$[rsp]
  0009d	03 d1		 add	 edx, ecx
  0009f	8b ca		 mov	 ecx, edx
  000a1	48 8b 94 24 80
	00 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  000a9	23 8a 90 00 00
	00		 and	 ecx, DWORD PTR [rdx+144]
  000af	48 8b 94 24 80
	00 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  000b7	0f b6 52 79	 movzx	 edx, BYTE PTR [rdx+121]
  000bb	88 54 24 28	 mov	 BYTE PTR [rsp+40], dl
  000bf	c7 44 24 20 04
	00 00 00	 mov	 DWORD PTR [rsp+32], 4
  000c7	4c 8b 8c 24 80
	00 00 00	 mov	 r9, QWORD PTR regs$[rsp]
  000cf	44 8b 44 24 78	 mov	 r8d, DWORD PTR arn$[rsp]
  000d4	48 8b d0	 mov	 rdx, rax
  000d7	e8 00 00 00 00	 call	 s390_maddr_l
  000dc	48 89 44 24 38	 mov	 QWORD PTR mn$[rsp], rax

; 437  :                   ACCTYPE_READ, regs->psw.pkey );
; 438  :     memcpy( temp+len, mn, 4 - len);

  000e1	b8 04 00 00 00	 mov	 eax, 4
  000e6	2b 44 24 30	 sub	 eax, DWORD PTR len$[rsp]
  000ea	48 98		 cdqe
  000ec	48 63 4c 24 30	 movsxd	 rcx, DWORD PTR len$[rsp]
  000f1	48 8d 4c 0c 40	 lea	 rcx, QWORD PTR temp$[rsp+rcx]
  000f6	48 8b f9	 mov	 rdi, rcx
  000f9	48 8b 74 24 38	 mov	 rsi, QWORD PTR mn$[rsp]
  000fe	48 8b c8	 mov	 rcx, rax
  00101	f3 a4		 rep movsb

; 439  :     return fetch_fw( temp );

  00103	48 8d 4c 24 40	 lea	 rcx, QWORD PTR temp$[rsp]
  00108	e8 00 00 00 00	 call	 fetch_fw_noswap
  0010d	8b c8		 mov	 ecx, eax
  0010f	e8 00 00 00 00	 call	 _byteswap_ulong

; 440  : }

  00114	48 8b 4c 24 48	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  00119	48 33 cc	 xor	 rcx, rsp
  0011c	e8 00 00 00 00	 call	 __security_check_cookie
  00121	48 83 c4 58	 add	 rsp, 88			; 00000058H
  00125	5f		 pop	 rdi
  00126	5e		 pop	 rsi
  00127	c3		 ret	 0
s390_vfetch4_full ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\vstore.h
;	COMDAT s390_vstore4_full
_TEXT	SEGMENT
len$ = 48
temp$ = 52
sk$ = 56
main1$ = 64
main2$ = 72
value$ = 112
addr$ = 120
arn$ = 128
regs$ = 136
s390_vstore4_full PROC					; COMDAT

; 335  : {

$LN3:
  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  0000a	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  0000e	89 4c 24 08	 mov	 DWORD PTR [rsp+8], ecx
  00012	56		 push	 rsi
  00013	57		 push	 rdi
  00014	48 83 ec 58	 sub	 rsp, 88			; 00000058H

; 336  : BYTE   *main1, *main2;                  /* Mainstor addresses        */
; 337  : BYTE   *sk;                             /* Storage key addresses     */
; 338  : int     len;                            /* Length to end of page     */
; 339  : BYTE    temp[4];                        /* Copied value              */
; 340  : 
; 341  :     len = PAGEFRAME_PAGESIZE - (addr & PAGEFRAME_BYTEMASK);

  00018	8b 44 24 78	 mov	 eax, DWORD PTR addr$[rsp]
  0001c	25 ff 0f 00 00	 and	 eax, 4095		; 00000fffH
  00021	b9 00 10 00 00	 mov	 ecx, 4096		; 00001000H
  00026	2b c8		 sub	 ecx, eax
  00028	8b c1		 mov	 eax, ecx
  0002a	89 44 24 30	 mov	 DWORD PTR len$[rsp], eax

; 342  :     main1 = MADDRL( addr, len, arn, regs, ACCTYPE_WRITE_SKP, regs->psw.pkey );

  0002e	48 63 44 24 30	 movsxd	 rax, DWORD PTR len$[rsp]
  00033	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0003b	0f b6 49 79	 movzx	 ecx, BYTE PTR [rcx+121]
  0003f	88 4c 24 28	 mov	 BYTE PTR [rsp+40], cl
  00043	c7 44 24 20 01
	00 00 00	 mov	 DWORD PTR [rsp+32], 1
  0004b	4c 8b 8c 24 88
	00 00 00	 mov	 r9, QWORD PTR regs$[rsp]
  00053	44 8b 84 24 80
	00 00 00	 mov	 r8d, DWORD PTR arn$[rsp]
  0005b	48 8b d0	 mov	 rdx, rax
  0005e	8b 4c 24 78	 mov	 ecx, DWORD PTR addr$[rsp]
  00062	e8 00 00 00 00	 call	 s390_maddr_l
  00067	48 89 44 24 40	 mov	 QWORD PTR main1$[rsp], rax

; 343  :     sk = regs->dat.storkey;

  0006c	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00074	48 8b 80 28 08
	00 00		 mov	 rax, QWORD PTR [rax+2088]
  0007b	48 89 44 24 38	 mov	 QWORD PTR sk$[rsp], rax

; 344  :     main2 = MADDRL( (addr + len) & ADDRESS_MAXWRAP( regs ), 4-len, arn, regs,

  00080	b8 04 00 00 00	 mov	 eax, 4
  00085	2b 44 24 30	 sub	 eax, DWORD PTR len$[rsp]
  00089	48 98		 cdqe
  0008b	8b 4c 24 30	 mov	 ecx, DWORD PTR len$[rsp]
  0008f	8b 54 24 78	 mov	 edx, DWORD PTR addr$[rsp]
  00093	03 d1		 add	 edx, ecx
  00095	8b ca		 mov	 ecx, edx
  00097	48 8b 94 24 88
	00 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  0009f	23 8a 90 00 00
	00		 and	 ecx, DWORD PTR [rdx+144]
  000a5	48 8b 94 24 88
	00 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  000ad	0f b6 52 79	 movzx	 edx, BYTE PTR [rdx+121]
  000b1	88 54 24 28	 mov	 BYTE PTR [rsp+40], dl
  000b5	c7 44 24 20 02
	00 00 00	 mov	 DWORD PTR [rsp+32], 2
  000bd	4c 8b 8c 24 88
	00 00 00	 mov	 r9, QWORD PTR regs$[rsp]
  000c5	44 8b 84 24 80
	00 00 00	 mov	 r8d, DWORD PTR arn$[rsp]
  000cd	48 8b d0	 mov	 rdx, rax
  000d0	e8 00 00 00 00	 call	 s390_maddr_l
  000d5	48 89 44 24 48	 mov	 QWORD PTR main2$[rsp], rax

; 345  :                     ACCTYPE_WRITE, regs->psw.pkey );
; 346  :     *sk |= (STORKEY_REF | STORKEY_CHANGE);

  000da	48 8b 44 24 38	 mov	 rax, QWORD PTR sk$[rsp]
  000df	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  000e2	83 c8 06	 or	 eax, 6
  000e5	48 8b 4c 24 38	 mov	 rcx, QWORD PTR sk$[rsp]
  000ea	88 01		 mov	 BYTE PTR [rcx], al

; 347  :     STORE_FW( temp, value );

  000ec	8b 4c 24 70	 mov	 ecx, DWORD PTR value$[rsp]
  000f0	e8 00 00 00 00	 call	 _byteswap_ulong
  000f5	8b d0		 mov	 edx, eax
  000f7	48 8d 4c 24 34	 lea	 rcx, QWORD PTR temp$[rsp]
  000fc	e8 00 00 00 00	 call	 store_fw_noswap

; 348  :     memcpy( main1, temp,       len );

  00101	48 63 44 24 30	 movsxd	 rax, DWORD PTR len$[rsp]
  00106	48 8d 4c 24 34	 lea	 rcx, QWORD PTR temp$[rsp]
  0010b	48 8b 7c 24 40	 mov	 rdi, QWORD PTR main1$[rsp]
  00110	48 8b f1	 mov	 rsi, rcx
  00113	48 8b c8	 mov	 rcx, rax
  00116	f3 a4		 rep movsb

; 349  :     memcpy( main2, temp+len, 4-len );

  00118	b8 04 00 00 00	 mov	 eax, 4
  0011d	2b 44 24 30	 sub	 eax, DWORD PTR len$[rsp]
  00121	48 98		 cdqe
  00123	48 63 4c 24 30	 movsxd	 rcx, DWORD PTR len$[rsp]
  00128	48 8d 4c 0c 34	 lea	 rcx, QWORD PTR temp$[rsp+rcx]
  0012d	48 8b 7c 24 48	 mov	 rdi, QWORD PTR main2$[rsp]
  00132	48 8b f1	 mov	 rsi, rcx
  00135	48 8b c8	 mov	 rcx, rax
  00138	f3 a4		 rep movsb

; 350  : }

  0013a	48 83 c4 58	 add	 rsp, 88			; 00000058H
  0013e	5f		 pop	 rdi
  0013f	5e		 pop	 rsi
  00140	c3		 ret	 0
s390_vstore4_full ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\dat.h
;	COMDAT s390_maddr_l
_TEXT	SEGMENT
tlbix$ = 48
aea_crn$ = 52
tv70 = 56
maddr$ = 64
addr$ = 96
len$ = 104
arn$ = 112
regs$ = 120
acctype$ = 128
akey$ = 136
s390_maddr_l PROC					; COMDAT

; 307  : {

$LN14:
  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	89 4c 24 08	 mov	 DWORD PTR [rsp+8], ecx
  00013	48 83 ec 58	 sub	 rsp, 88			; 00000058H

; 308  :     /* Note: ALL of the below conditions must be true for a TLB hit
; 309  :        to occur.  If ANY of them are false, then it's a TLB miss,
; 310  :        requiring us to then perform a full DAT address translation.
; 311  : 
; 312  :        Note too that on the grand scheme of things the order/sequence
; 313  :        of the below tests (if statements) is completely unimportant
; 314  :        since ALL conditions must be checked anyway in order for a hit
; 315  :        to occur, and it doesn't matter that a miss tests a few extra
; 316  :        conditions since it's going to do a full translation anyway!
; 317  :        (which is many, many instructions)
; 318  :     */
; 319  : 
; 320  :     int  aea_crn  = (arn >= USE_ARMODE) ? 0 : regs->AEA_AR( arn );

  00017	83 7c 24 70 10	 cmp	 DWORD PTR arn$[rsp], 16
  0001c	7c 0a		 jl	 SHORT $LN12@s390_maddr
  0001e	c7 44 24 38 00
	00 00 00	 mov	 DWORD PTR tv70[rsp], 0
  00026	eb 19		 jmp	 SHORT $LN13@s390_maddr
$LN12@s390_maddr:
  00028	8b 44 24 70	 mov	 eax, DWORD PTR arn$[rsp]
  0002c	83 c0 05	 add	 eax, 5
  0002f	48 98		 cdqe
  00031	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  00036	8b 84 81 94 0c
	00 00		 mov	 eax, DWORD PTR [rcx+rax*4+3220]
  0003d	89 44 24 38	 mov	 DWORD PTR tv70[rsp], eax
$LN13@s390_maddr:
  00041	8b 44 24 38	 mov	 eax, DWORD PTR tv70[rsp]
  00045	89 44 24 34	 mov	 DWORD PTR aea_crn$[rsp], eax

; 321  :     U16  tlbix    = TLBIX( addr );

  00049	8b 44 24 60	 mov	 eax, DWORD PTR addr$[rsp]
  0004d	c1 e8 0c	 shr	 eax, 12
  00050	25 ff 03 00 00	 and	 eax, 1023		; 000003ffH
  00055	66 89 44 24 30	 mov	 WORD PTR tlbix$[rsp], ax

; 322  :     BYTE *maddr   = NULL;

  0005a	48 c7 44 24 40
	00 00 00 00	 mov	 QWORD PTR maddr$[rsp], 0

; 323  : 
; 324  :     /* Non-zero AEA Control Register number? */
; 325  :     if (aea_crn)

  00063	83 7c 24 34 00	 cmp	 DWORD PTR aea_crn$[rsp], 0
  00068	0f 84 25 01 00
	00		 je	 $LN2@s390_maddr

; 326  :     {
; 327  :         /* Same Addess Space Designator as before? */
; 328  :         /* Or if not, is address in a common segment? */
; 329  :         if (0
; 330  :             || (regs->CR( aea_crn ) == regs->tlb.TLB_ASD( tlbix ))
; 331  :             || (regs->AEA_COMMON( aea_crn ) & regs->tlb.common[ tlbix ])

  0006e	33 c0		 xor	 eax, eax
  00070	85 c0		 test	 eax, eax
  00072	75 59		 jne	 SHORT $LN4@s390_maddr
  00074	8b 44 24 34	 mov	 eax, DWORD PTR aea_crn$[rsp]
  00078	ff c0		 inc	 eax
  0007a	48 98		 cdqe
  0007c	0f b7 4c 24 30	 movzx	 ecx, WORD PTR tlbix$[rsp]
  00081	48 8b 54 24 78	 mov	 rdx, QWORD PTR regs$[rsp]
  00086	4c 8b 44 24 78	 mov	 r8, QWORD PTR regs$[rsp]
  0008b	41 8b 8c c8 60
	b0 00 00	 mov	 ecx, DWORD PTR [r8+rcx*8+45152]
  00093	39 8c c2 00 06
	00 00		 cmp	 DWORD PTR [rdx+rax*8+1536], ecx
  0009a	74 31		 je	 SHORT $LN4@s390_maddr
  0009c	8b 44 24 34	 mov	 eax, DWORD PTR aea_crn$[rsp]
  000a0	ff c0		 inc	 eax
  000a2	48 98		 cdqe
  000a4	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  000a9	0f b6 84 01 e8
	0c 00 00	 movzx	 eax, BYTE PTR [rcx+rax+3304]
  000b1	0f b7 4c 24 30	 movzx	 ecx, WORD PTR tlbix$[rsp]
  000b6	48 8b 54 24 78	 mov	 rdx, QWORD PTR regs$[rsp]
  000bb	0f b6 8c 0a 60
	54 01 00	 movzx	 ecx, BYTE PTR [rdx+rcx+87136]
  000c3	23 c1		 and	 eax, ecx
  000c5	85 c0		 test	 eax, eax
  000c7	0f 84 c6 00 00
	00		 je	 $LN3@s390_maddr
$LN4@s390_maddr:

; 332  :         )
; 333  :         {
; 334  :             /* Storage Key zero? */
; 335  :             /* Or if not, same Storage Key as before? */
; 336  :             if (0
; 337  :                 || akey == 0
; 338  :                 || akey == regs->tlb.skey[ tlbix ]

  000cd	33 c0		 xor	 eax, eax
  000cf	85 c0		 test	 eax, eax
  000d1	75 2e		 jne	 SHORT $LN6@s390_maddr
  000d3	0f b6 84 24 88
	00 00 00	 movzx	 eax, BYTE PTR akey$[rsp]
  000db	85 c0		 test	 eax, eax
  000dd	74 22		 je	 SHORT $LN6@s390_maddr
  000df	0f b6 84 24 88
	00 00 00	 movzx	 eax, BYTE PTR akey$[rsp]
  000e7	0f b7 4c 24 30	 movzx	 ecx, WORD PTR tlbix$[rsp]
  000ec	48 8b 54 24 78	 mov	 rdx, QWORD PTR regs$[rsp]
  000f1	0f b6 8c 0a 60
	50 01 00	 movzx	 ecx, BYTE PTR [rdx+rcx+86112]
  000f9	3b c1		 cmp	 eax, ecx
  000fb	0f 85 92 00 00
	00		 jne	 $LN5@s390_maddr
$LN6@s390_maddr:

; 339  :             )
; 340  :             {
; 341  :                 /* Does the page address match the one in the TLB? */
; 342  :                 /* (does a TLB entry exist for this page address?) */
; 343  :                 if (
; 344  :                     ((addr & TLBID_PAGEMASK) | regs->tlbID)
; 345  :                     ==

  00101	8b 44 24 60	 mov	 eax, DWORD PTR addr$[rsp]
  00105	25 00 00 c0 7f	 and	 eax, 2143289344		; 7fc00000H
  0010a	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  0010f	0b 81 58 b0 00
	00		 or	 eax, DWORD PTR [rcx+45144]
  00115	0f b7 4c 24 30	 movzx	 ecx, WORD PTR tlbix$[rsp]
  0011a	48 8b 54 24 78	 mov	 rdx, QWORD PTR regs$[rsp]
  0011f	3b 84 ca 60 d0
	00 00		 cmp	 eax, DWORD PTR [rdx+rcx*8+53344]
  00126	75 6b		 jne	 SHORT $LN7@s390_maddr

; 346  :                     regs->tlb.TLB_VADDR( tlbix )
; 347  :                 )
; 348  :                 {
; 349  :                     /* Is storage being accessed same way as before? */
; 350  :                     if (acctype & regs->tlb.acc[ tlbix ])

  00128	0f b7 44 24 30	 movzx	 eax, WORD PTR tlbix$[rsp]
  0012d	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  00132	0f b6 84 01 60
	5c 01 00	 movzx	 eax, BYTE PTR [rcx+rax+89184]
  0013a	8b 8c 24 80 00
	00 00		 mov	 ecx, DWORD PTR acctype$[rsp]
  00141	23 c8		 and	 ecx, eax
  00143	8b c1		 mov	 eax, ecx
  00145	85 c0		 test	 eax, eax
  00147	74 4a		 je	 SHORT $LN8@s390_maddr

; 351  :                     {
; 352  :                         /*------------------------------------------*/
; 353  :                         /* TLB hit: use previously translated value */
; 354  :                         /*------------------------------------------*/
; 355  : 
; 356  :                         if (acctype & ACC_CHECK)

  00149	8b 84 24 80 00
	00 00		 mov	 eax, DWORD PTR acctype$[rsp]
  00150	83 e0 01	 and	 eax, 1
  00153	85 c0		 test	 eax, eax
  00155	74 1e		 je	 SHORT $LN9@s390_maddr

; 357  :                             regs->dat.storkey = regs->tlb.storkey[ tlbix ];

  00157	0f b7 44 24 30	 movzx	 eax, WORD PTR tlbix$[rsp]
  0015c	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  00161	48 8b 54 24 78	 mov	 rdx, QWORD PTR regs$[rsp]
  00166	48 8b 84 c2 60
	30 01 00	 mov	 rax, QWORD PTR [rdx+rax*8+77920]
  0016e	48 89 81 28 08
	00 00		 mov	 QWORD PTR [rcx+2088], rax
$LN9@s390_maddr:

; 358  : 
; 359  :                         maddr = MAINADDR( regs->tlb.main[tlbix], addr );

  00175	0f b7 44 24 30	 movzx	 eax, WORD PTR tlbix$[rsp]
  0017a	8b 4c 24 60	 mov	 ecx, DWORD PTR addr$[rsp]
  0017e	48 8b 54 24 78	 mov	 rdx, QWORD PTR regs$[rsp]
  00183	48 8b 84 c2 60
	10 01 00	 mov	 rax, QWORD PTR [rdx+rax*8+69728]
  0018b	48 33 c1	 xor	 rax, rcx
  0018e	48 89 44 24 40	 mov	 QWORD PTR maddr$[rsp], rax
$LN8@s390_maddr:
$LN7@s390_maddr:
$LN5@s390_maddr:
$LN3@s390_maddr:
$LN2@s390_maddr:

; 360  :                     }
; 361  :                 }
; 362  :             }
; 363  :         }
; 364  :     }
; 365  : 
; 366  :     /*---------------------------------------*/
; 367  :     /* TLB miss: do full address translation */
; 368  :     /*---------------------------------------*/
; 369  :     if (!maddr)

  00193	48 83 7c 24 40
	00		 cmp	 QWORD PTR maddr$[rsp], 0
  00199	75 35		 jne	 SHORT $LN10@s390_maddr

; 370  :         maddr = ARCH_DEP( logical_to_main_l )( addr, arn, regs, acctype, akey, len );

  0019b	48 8b 44 24 68	 mov	 rax, QWORD PTR len$[rsp]
  001a0	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  001a5	0f b6 84 24 88
	00 00 00	 movzx	 eax, BYTE PTR akey$[rsp]
  001ad	88 44 24 20	 mov	 BYTE PTR [rsp+32], al
  001b1	44 8b 8c 24 80
	00 00 00	 mov	 r9d, DWORD PTR acctype$[rsp]
  001b9	4c 8b 44 24 78	 mov	 r8, QWORD PTR regs$[rsp]
  001be	8b 54 24 70	 mov	 edx, DWORD PTR arn$[rsp]
  001c2	8b 4c 24 60	 mov	 ecx, DWORD PTR addr$[rsp]
  001c6	e8 00 00 00 00	 call	 s390_logical_to_main_l
  001cb	48 89 44 24 40	 mov	 QWORD PTR maddr$[rsp], rax
$LN10@s390_maddr:

; 371  : 
; 372  : #if defined( FEATURE_073_TRANSACT_EXEC_FACILITY )
; 373  :     if (FACILITY_ENABLED( 073_TRANSACT_EXEC, regs ))
; 374  :     {
; 375  :         /* SA22-7832-12 Principles of Operation, page 5-99:
; 376  : 
; 377  :              "Storage accesses for instruction and DAT- and ART-
; 378  :               table fetches follow the non-transactional rules."
; 379  :         */
; 380  :         if (0
; 381  :             || !regs
; 382  :             || !regs->txf_tnd
; 383  :             || arn == USE_INST_SPACE    /* Instruction fetching */
; 384  :             || arn == USE_REAL_ADDR     /* Address translation  */
; 385  :         )
; 386  :             return maddr;
; 387  : 
; 388  :         /* Quick exit if NTSTG call */
; 389  :         if (regs->txf_NTSTG)
; 390  :         {
; 391  :             regs->txf_NTSTG = false;
; 392  :             return maddr;
; 393  :         }
; 394  : 
; 395  :         /* Translate to alternate TXF address */
; 396  :         maddr = TXF_MADDRL( addr, len, arn, regs, acctype, maddr );
; 397  :     }
; 398  : #endif
; 399  : 
; 400  :     return maddr;

  001d0	48 8b 44 24 40	 mov	 rax, QWORD PTR maddr$[rsp]

; 401  : }

  001d5	48 83 c4 58	 add	 rsp, 88			; 00000058H
  001d9	c3		 ret	 0
s390_maddr_l ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\assist.c
_TEXT	SEGMENT
effective_addr2$ = 64
effective_addr1$ = 68
temp$1 = 72
b1$ = 76
b2$ = 80
inst$ = 112
regs$ = 120
s390_svc_assist PROC

; 129  : {

$LN16:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 68	 sub	 rsp, 104		; 00000068H

; 130  : int     b1, b2;                         /* Values of base field      */
; 131  : VADR    effective_addr1,
; 132  :         effective_addr2;                /* Effective addresses       */
; 133  : 
; 134  :     SSE(inst, regs, b1, effective_addr1, b2, effective_addr2);

  0000e	48 8b 44 24 70	 mov	 rax, QWORD PTR inst$[rsp]
  00013	48 83 c0 02	 add	 rax, 2
  00017	48 8b c8	 mov	 rcx, rax
  0001a	e8 00 00 00 00	 call	 fetch_fw_noswap
  0001f	8b c8		 mov	 ecx, eax
  00021	e8 00 00 00 00	 call	 _byteswap_ulong
  00026	89 44 24 48	 mov	 DWORD PTR temp$1[rsp], eax
  0002a	8b 44 24 48	 mov	 eax, DWORD PTR temp$1[rsp]
  0002e	25 ff 0f 00 00	 and	 eax, 4095		; 00000fffH
  00033	89 44 24 40	 mov	 DWORD PTR effective_addr2$[rsp], eax
  00037	8b 44 24 48	 mov	 eax, DWORD PTR temp$1[rsp]
  0003b	c1 e8 0c	 shr	 eax, 12
  0003e	83 e0 0f	 and	 eax, 15
  00041	89 44 24 50	 mov	 DWORD PTR b2$[rsp], eax
  00045	8b 44 24 48	 mov	 eax, DWORD PTR temp$1[rsp]
  00049	c1 e8 10	 shr	 eax, 16
  0004c	25 ff 0f 00 00	 and	 eax, 4095		; 00000fffH
  00051	89 44 24 44	 mov	 DWORD PTR effective_addr1$[rsp], eax
  00055	8b 44 24 48	 mov	 eax, DWORD PTR temp$1[rsp]
  00059	c1 e8 1c	 shr	 eax, 28
  0005c	83 e0 0f	 and	 eax, 15
  0005f	89 44 24 4c	 mov	 DWORD PTR b1$[rsp], eax
  00063	83 7c 24 4c 00	 cmp	 DWORD PTR b1$[rsp], 0
  00068	74 34		 je	 SHORT $LN8@s390_svc_a
  0006a	48 63 44 24 4c	 movsxd	 rax, DWORD PTR b1$[rsp]
  0006f	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  00074	8b 84 c1 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax*8+640]
  0007b	8b 4c 24 44	 mov	 ecx, DWORD PTR effective_addr1$[rsp]
  0007f	03 c8		 add	 ecx, eax
  00081	8b c1		 mov	 eax, ecx
  00083	89 44 24 44	 mov	 DWORD PTR effective_addr1$[rsp], eax
  00087	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  0008c	8b 80 90 00 00
	00		 mov	 eax, DWORD PTR [rax+144]
  00092	8b 4c 24 44	 mov	 ecx, DWORD PTR effective_addr1$[rsp]
  00096	23 c8		 and	 ecx, eax
  00098	8b c1		 mov	 eax, ecx
  0009a	89 44 24 44	 mov	 DWORD PTR effective_addr1$[rsp], eax
$LN8@s390_svc_a:
  0009e	83 7c 24 50 00	 cmp	 DWORD PTR b2$[rsp], 0
  000a3	74 34		 je	 SHORT $LN9@s390_svc_a
  000a5	48 63 44 24 50	 movsxd	 rax, DWORD PTR b2$[rsp]
  000aa	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  000af	8b 84 c1 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax*8+640]
  000b6	8b 4c 24 40	 mov	 ecx, DWORD PTR effective_addr2$[rsp]
  000ba	03 c8		 add	 ecx, eax
  000bc	8b c1		 mov	 eax, ecx
  000be	89 44 24 40	 mov	 DWORD PTR effective_addr2$[rsp], eax
  000c2	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  000c7	8b 80 90 00 00
	00		 mov	 eax, DWORD PTR [rax+144]
  000cd	8b 4c 24 40	 mov	 ecx, DWORD PTR effective_addr2$[rsp]
  000d1	23 c8		 and	 ecx, eax
  000d3	8b c1		 mov	 eax, ecx
  000d5	89 44 24 40	 mov	 DWORD PTR effective_addr2$[rsp], eax
$LN9@s390_svc_a:
$LN4@s390_svc_a:
  000d9	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  000de	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  000e2	48 83 c0 06	 add	 rax, 6
  000e6	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  000eb	48 89 41 68	 mov	 QWORD PTR [rcx+104], rax
  000ef	33 c0		 xor	 eax, eax
  000f1	83 f8 06	 cmp	 eax, 6
  000f4	74 0c		 je	 SHORT $LN10@s390_svc_a
  000f6	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  000fb	c6 80 9a 00 00
	00 06		 mov	 BYTE PTR [rax+154], 6
$LN10@s390_svc_a:
  00102	33 c0		 xor	 eax, eax
  00104	85 c0		 test	 eax, eax
  00106	75 d1		 jne	 SHORT $LN4@s390_svc_a

; 135  :     PER_ZEROADDR_XCHECK2( regs, b1, b2 );
; 136  : 
; 137  :     GUEST_CHECK( );

  00108	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  0010d	0f b6 40 7a	 movzx	 eax, BYTE PTR [rax+122]
  00111	83 e0 01	 and	 eax, 1
  00114	85 c0		 test	 eax, eax
  00116	74 44		 je	 SHORT $LN11@s390_svc_a
  00118	b8 08 00 00 00	 mov	 eax, 8
  0011d	48 6b c0 07	 imul	 rax, rax, 7
  00121	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  00126	8b 84 01 00 06
	00 00		 mov	 eax, DWORD PTR [rcx+rax+1536]
  0012d	25 04 00 00 40	 and	 eax, 1073741828		; 40000004H
  00132	83 f8 04	 cmp	 eax, 4
  00135	74 25		 je	 SHORT $LN12@s390_svc_a
  00137	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  0013c	0f b6 40 7a	 movzx	 eax, BYTE PTR [rax+122]
  00140	83 e0 01	 and	 eax, 1
  00143	85 c0		 test	 eax, eax
  00145	74 15		 je	 SHORT $LN13@s390_svc_a
  00147	ba 02 00 00 00	 mov	 edx, 2
  0014c	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  00151	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  00156	ff 90 20 0d 00
	00		 call	 QWORD PTR [rax+3360]
$LN13@s390_svc_a:
$LN12@s390_svc_a:
$LN11@s390_svc_a:
$LN7@s390_svc_a:

; 138  : 
; 139  :     PTT_ERR( "*E503 SVCA", effective_addr1, effective_addr2, regs->psw.IA_L );

  0015c	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_pttclass
  00163	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00166	48 83 e0 10	 and	 rax, 16
  0016a	48 85 c0	 test	 rax, rax
  0016d	74 45		 je	 SHORT $LN14@s390_svc_a
  0016f	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  00174	8b 80 88 00 00
	00		 mov	 eax, DWORD PTR [rax+136]
  0017a	8b 4c 24 40	 mov	 ecx, DWORD PTR effective_addr2$[rsp]
  0017e	8b 54 24 44	 mov	 edx, DWORD PTR effective_addr1$[rsp]
  00182	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR [rsp+48], 0
  0018b	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  00190	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG180168
  00197	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  0019c	44 8b c9	 mov	 r9d, ecx
  0019f	44 8b c2	 mov	 r8d, edx
  001a2	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG180169
  001a9	b9 10 00 00 00	 mov	 ecx, 16
  001ae	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ptt_pthread_trace
$LN14@s390_svc_a:
  001b4	33 c0		 xor	 eax, eax
  001b6	85 c0		 test	 eax, eax
  001b8	75 a2		 jne	 SHORT $LN7@s390_svc_a

; 140  :     /*INCOMPLETE: NO ACTION IS TAKEN, THE SVC IS UNASSISTED
; 141  :                   AND MVS WILL HAVE TO HANDLE THE SITUATION*/
; 142  : }

  001ba	48 83 c4 68	 add	 rsp, 104		; 00000068H
  001be	c3		 ret	 0
s390_svc_assist ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\assist.c
_TEXT	SEGMENT
acc_mode$ = 32
effective_addr2$ = 36
effective_addr1$ = 40
hlhi_word$ = 44
temp$1 = 48
lit_addr$ = 52
b1$ = 56
b2$ = 60
ascb_addr$ = 64
lock_addr$ = 68
newia$ = 72
susp_addr$ = 76
lcpa$ = 80
lock$ = 84
susp$ = 88
inst$ = 112
regs$ = 120
s390_release_local_lock PROC

; 242  : {

$LN31:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 68	 sub	 rsp, 104		; 00000068H

; 243  : int     b1, b2;                         /* Values of base field      */
; 244  : VADR    effective_addr1,
; 245  :         effective_addr2;                /* Effective addresses       */
; 246  : VADR    ascb_addr;                      /* Virtual address of ASCB   */
; 247  : VADR    lock_addr;                      /* Virtual addr of ASCBLOCK  */
; 248  : VADR    susp_addr;                      /* Virtual addr of ASCBLSWQ  */
; 249  : U32     hlhi_word;                      /* Highest lock held word    */
; 250  : VADR    lit_addr;                       /* Virtual address of lock
; 251  :                                            interface table           */
; 252  : U32     lock;                           /* Lock value                */
; 253  : U32     susp;                           /* Lock suspend queue        */
; 254  : U32     lcpa;                           /* Logical CPU address       */
; 255  : VADR    newia;                          /* Unsuccessful branch addr  */
; 256  : int     acc_mode = 0;                   /* access mode to use        */

  0000e	c7 44 24 20 00
	00 00 00	 mov	 DWORD PTR acc_mode$[rsp], 0

; 257  : 
; 258  :     SSE(inst, regs, b1, effective_addr1, b2, effective_addr2);

  00016	48 8b 44 24 70	 mov	 rax, QWORD PTR inst$[rsp]
  0001b	48 83 c0 02	 add	 rax, 2
  0001f	48 8b c8	 mov	 rcx, rax
  00022	e8 00 00 00 00	 call	 fetch_fw_noswap
  00027	8b c8		 mov	 ecx, eax
  00029	e8 00 00 00 00	 call	 _byteswap_ulong
  0002e	89 44 24 30	 mov	 DWORD PTR temp$1[rsp], eax
  00032	8b 44 24 30	 mov	 eax, DWORD PTR temp$1[rsp]
  00036	25 ff 0f 00 00	 and	 eax, 4095		; 00000fffH
  0003b	89 44 24 24	 mov	 DWORD PTR effective_addr2$[rsp], eax
  0003f	8b 44 24 30	 mov	 eax, DWORD PTR temp$1[rsp]
  00043	c1 e8 0c	 shr	 eax, 12
  00046	83 e0 0f	 and	 eax, 15
  00049	89 44 24 3c	 mov	 DWORD PTR b2$[rsp], eax
  0004d	8b 44 24 30	 mov	 eax, DWORD PTR temp$1[rsp]
  00051	c1 e8 10	 shr	 eax, 16
  00054	25 ff 0f 00 00	 and	 eax, 4095		; 00000fffH
  00059	89 44 24 28	 mov	 DWORD PTR effective_addr1$[rsp], eax
  0005d	8b 44 24 30	 mov	 eax, DWORD PTR temp$1[rsp]
  00061	c1 e8 1c	 shr	 eax, 28
  00064	83 e0 0f	 and	 eax, 15
  00067	89 44 24 38	 mov	 DWORD PTR b1$[rsp], eax
  0006b	83 7c 24 38 00	 cmp	 DWORD PTR b1$[rsp], 0
  00070	74 34		 je	 SHORT $LN14@s390_relea
  00072	48 63 44 24 38	 movsxd	 rax, DWORD PTR b1$[rsp]
  00077	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  0007c	8b 84 c1 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax*8+640]
  00083	8b 4c 24 28	 mov	 ecx, DWORD PTR effective_addr1$[rsp]
  00087	03 c8		 add	 ecx, eax
  00089	8b c1		 mov	 eax, ecx
  0008b	89 44 24 28	 mov	 DWORD PTR effective_addr1$[rsp], eax
  0008f	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  00094	8b 80 90 00 00
	00		 mov	 eax, DWORD PTR [rax+144]
  0009a	8b 4c 24 28	 mov	 ecx, DWORD PTR effective_addr1$[rsp]
  0009e	23 c8		 and	 ecx, eax
  000a0	8b c1		 mov	 eax, ecx
  000a2	89 44 24 28	 mov	 DWORD PTR effective_addr1$[rsp], eax
$LN14@s390_relea:
  000a6	83 7c 24 3c 00	 cmp	 DWORD PTR b2$[rsp], 0
  000ab	74 34		 je	 SHORT $LN15@s390_relea
  000ad	48 63 44 24 3c	 movsxd	 rax, DWORD PTR b2$[rsp]
  000b2	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  000b7	8b 84 c1 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax*8+640]
  000be	8b 4c 24 24	 mov	 ecx, DWORD PTR effective_addr2$[rsp]
  000c2	03 c8		 add	 ecx, eax
  000c4	8b c1		 mov	 eax, ecx
  000c6	89 44 24 24	 mov	 DWORD PTR effective_addr2$[rsp], eax
  000ca	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  000cf	8b 80 90 00 00
	00		 mov	 eax, DWORD PTR [rax+144]
  000d5	8b 4c 24 24	 mov	 ecx, DWORD PTR effective_addr2$[rsp]
  000d9	23 c8		 and	 ecx, eax
  000db	8b c1		 mov	 eax, ecx
  000dd	89 44 24 24	 mov	 DWORD PTR effective_addr2$[rsp], eax
$LN15@s390_relea:
$LN4@s390_relea:
  000e1	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  000e6	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  000ea	48 83 c0 06	 add	 rax, 6
  000ee	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  000f3	48 89 41 68	 mov	 QWORD PTR [rcx+104], rax
  000f7	33 c0		 xor	 eax, eax
  000f9	83 f8 06	 cmp	 eax, 6
  000fc	74 0c		 je	 SHORT $LN16@s390_relea
  000fe	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  00103	c6 80 9a 00 00
	00 06		 mov	 BYTE PTR [rax+154], 6
$LN16@s390_relea:
  0010a	33 c0		 xor	 eax, eax
  0010c	85 c0		 test	 eax, eax
  0010e	75 d1		 jne	 SHORT $LN4@s390_relea

; 259  :     PER_ZEROADDR_XCHECK2( regs, b1, b2 );
; 260  : 
; 261  :     GUEST_CHECK( );

  00110	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  00115	0f b6 40 7a	 movzx	 eax, BYTE PTR [rax+122]
  00119	83 e0 01	 and	 eax, 1
  0011c	85 c0		 test	 eax, eax
  0011e	74 44		 je	 SHORT $LN17@s390_relea
  00120	b8 08 00 00 00	 mov	 eax, 8
  00125	48 6b c0 07	 imul	 rax, rax, 7
  00129	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  0012e	8b 84 01 00 06
	00 00		 mov	 eax, DWORD PTR [rcx+rax+1536]
  00135	25 04 00 00 40	 and	 eax, 1073741828		; 40000004H
  0013a	83 f8 04	 cmp	 eax, 4
  0013d	74 25		 je	 SHORT $LN18@s390_relea
  0013f	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  00144	0f b6 40 7a	 movzx	 eax, BYTE PTR [rax+122]
  00148	83 e0 01	 and	 eax, 1
  0014b	85 c0		 test	 eax, eax
  0014d	74 15		 je	 SHORT $LN19@s390_relea
  0014f	ba 02 00 00 00	 mov	 edx, 2
  00154	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  00159	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  0015e	ff 90 20 0d 00
	00		 call	 QWORD PTR [rax+3360]
$LN19@s390_relea:
$LN18@s390_relea:
$LN17@s390_relea:

; 262  : 
; 263  :     /* Specification exception if operands are not on word boundary */
; 264  :     if ((effective_addr1 & 0x00000003) || (effective_addr2 & 0x00000003))

  00164	8b 44 24 28	 mov	 eax, DWORD PTR effective_addr1$[rsp]
  00168	83 e0 03	 and	 eax, 3
  0016b	85 c0		 test	 eax, eax
  0016d	75 0b		 jne	 SHORT $LN21@s390_relea
  0016f	8b 44 24 24	 mov	 eax, DWORD PTR effective_addr2$[rsp]
  00173	83 e0 03	 and	 eax, 3
  00176	85 c0		 test	 eax, eax
  00178	74 0f		 je	 SHORT $LN20@s390_relea
$LN21@s390_relea:

; 265  :         ARCH_DEP(program_interrupt) (regs, PGM_SPECIFICATION_EXCEPTION);

  0017a	ba 06 00 00 00	 mov	 edx, 6
  0017f	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  00184	e8 00 00 00 00	 call	 s390_program_interrupt
$LN20@s390_relea:
$LN7@s390_relea:

; 266  : 
; 267  :     /* Obtain main-storage access lock */
; 268  :     OBTAIN_MAINLOCK_UNCONDITIONAL(regs);

  00189	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  0018e	48 8b 80 68 08
	00 00		 mov	 rax, QWORD PTR [rax+2152]
  00195	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  0019a	48 8b 49 40	 mov	 rcx, QWORD PTR [rcx+64]
  0019e	48 8b 89 b0 12
	00 00		 mov	 rcx, QWORD PTR [rcx+4784]
  001a5	48 39 48 50	 cmp	 QWORD PTR [rax+80], rcx
  001a9	74 42		 je	 SHORT $LN22@s390_relea
  001ab	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  001b0	48 8b 40 40	 mov	 rax, QWORD PTR [rax+64]
  001b4	48 05 68 10 00
	00		 add	 rax, 4200		; 00001068H
  001ba	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG180270
  001c1	48 8b c8	 mov	 rcx, rax
  001c4	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_obtain_lock
  001ca	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  001cf	48 8b 80 68 08
	00 00		 mov	 rax, QWORD PTR [rax+2152]
  001d6	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  001db	48 8b 49 40	 mov	 rcx, QWORD PTR [rcx+64]
  001df	0f b7 80 3c 08
	00 00		 movzx	 eax, WORD PTR [rax+2108]
  001e6	66 89 81 60 10
	00 00		 mov	 WORD PTR [rcx+4192], ax
$LN22@s390_relea:
  001ed	33 c0		 xor	 eax, eax
  001ef	85 c0		 test	 eax, eax
  001f1	75 96		 jne	 SHORT $LN7@s390_relea

; 269  : 
; 270  :     if (ACCESS_REGISTER_MODE(&regs->psw))

  001f3	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  001f8	0f b6 40 7b	 movzx	 eax, BYTE PTR [rax+123]
  001fc	83 f8 40	 cmp	 eax, 64			; 00000040H
  001ff	75 08		 jne	 SHORT $LN23@s390_relea

; 271  :         acc_mode = USE_PRIMARY_SPACE;

  00201	c7 44 24 20 fd
	ff ff ff	 mov	 DWORD PTR acc_mode$[rsp], -3
$LN23@s390_relea:

; 272  : 
; 273  :     /* Load ASCB address from first operand location */
; 274  :     ascb_addr = ARCH_DEP(vfetch4) ( effective_addr1, acc_mode, regs );

  00209	4c 8b 44 24 78	 mov	 r8, QWORD PTR regs$[rsp]
  0020e	8b 54 24 20	 mov	 edx, DWORD PTR acc_mode$[rsp]
  00212	8b 4c 24 28	 mov	 ecx, DWORD PTR effective_addr1$[rsp]
  00216	e8 00 00 00 00	 call	 s390_vfetch4
  0021b	89 44 24 40	 mov	 DWORD PTR ascb_addr$[rsp], eax

; 275  : 
; 276  :     /* Load locks held bits from second operand location */
; 277  :     hlhi_word = ARCH_DEP(vfetch4) ( effective_addr2, acc_mode, regs );

  0021f	4c 8b 44 24 78	 mov	 r8, QWORD PTR regs$[rsp]
  00224	8b 54 24 20	 mov	 edx, DWORD PTR acc_mode$[rsp]
  00228	8b 4c 24 24	 mov	 ecx, DWORD PTR effective_addr2$[rsp]
  0022c	e8 00 00 00 00	 call	 s390_vfetch4
  00231	89 44 24 2c	 mov	 DWORD PTR hlhi_word$[rsp], eax

; 278  : 
; 279  :     /* Fetch our logical CPU address from PSALCPUA */
; 280  :     lcpa = ARCH_DEP(vfetch4) ( effective_addr2 - 4, acc_mode, regs );

  00235	8b 44 24 24	 mov	 eax, DWORD PTR effective_addr2$[rsp]
  00239	83 e8 04	 sub	 eax, 4
  0023c	4c 8b 44 24 78	 mov	 r8, QWORD PTR regs$[rsp]
  00241	8b 54 24 20	 mov	 edx, DWORD PTR acc_mode$[rsp]
  00245	8b c8		 mov	 ecx, eax
  00247	e8 00 00 00 00	 call	 s390_vfetch4
  0024c	89 44 24 50	 mov	 DWORD PTR lcpa$[rsp], eax

; 281  : 
; 282  :     /* Fetch the local lock and the suspend queue from the ASCB */
; 283  :     lock_addr = (ascb_addr + ASCBLOCK) & ADDRESS_MAXWRAP(regs);

  00250	8b 44 24 40	 mov	 eax, DWORD PTR ascb_addr$[rsp]
  00254	05 80 00 00 00	 add	 eax, 128		; 00000080H
  00259	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  0025e	23 81 90 00 00
	00		 and	 eax, DWORD PTR [rcx+144]
  00264	89 44 24 44	 mov	 DWORD PTR lock_addr$[rsp], eax

; 284  :     susp_addr = (ascb_addr + ASCBLSWQ) & ADDRESS_MAXWRAP(regs);

  00268	8b 44 24 40	 mov	 eax, DWORD PTR ascb_addr$[rsp]
  0026c	05 84 00 00 00	 add	 eax, 132		; 00000084H
  00271	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  00276	23 81 90 00 00
	00		 and	 eax, DWORD PTR [rcx+144]
  0027c	89 44 24 4c	 mov	 DWORD PTR susp_addr$[rsp], eax

; 285  :     lock = ARCH_DEP(vfetch4) ( lock_addr, acc_mode, regs );

  00280	4c 8b 44 24 78	 mov	 r8, QWORD PTR regs$[rsp]
  00285	8b 54 24 20	 mov	 edx, DWORD PTR acc_mode$[rsp]
  00289	8b 4c 24 44	 mov	 ecx, DWORD PTR lock_addr$[rsp]
  0028d	e8 00 00 00 00	 call	 s390_vfetch4
  00292	89 44 24 54	 mov	 DWORD PTR lock$[rsp], eax

; 286  :     susp = ARCH_DEP(vfetch4) ( susp_addr, acc_mode, regs );

  00296	4c 8b 44 24 78	 mov	 r8, QWORD PTR regs$[rsp]
  0029b	8b 54 24 20	 mov	 edx, DWORD PTR acc_mode$[rsp]
  0029f	8b 4c 24 4c	 mov	 ecx, DWORD PTR susp_addr$[rsp]
  002a3	e8 00 00 00 00	 call	 s390_vfetch4
  002a8	89 44 24 58	 mov	 DWORD PTR susp$[rsp], eax

; 287  : 
; 288  :     /* Test if this CPU holds the local lock, and does not hold
; 289  :        any CMS lock, and the local lock suspend queue is empty */
; 290  :     if (lock == lcpa
; 291  :         && (hlhi_word & (PSALCLLI | PSACMSLI)) == PSALCLLI
; 292  :         && susp == 0)

  002ac	8b 44 24 50	 mov	 eax, DWORD PTR lcpa$[rsp]
  002b0	39 44 24 54	 cmp	 DWORD PTR lock$[rsp], eax
  002b4	75 7f		 jne	 SHORT $LN24@s390_relea
  002b6	8b 44 24 2c	 mov	 eax, DWORD PTR hlhi_word$[rsp]
  002ba	83 e0 03	 and	 eax, 3
  002bd	83 f8 01	 cmp	 eax, 1
  002c0	75 73		 jne	 SHORT $LN24@s390_relea
  002c2	83 7c 24 58 00	 cmp	 DWORD PTR susp$[rsp], 0
  002c7	75 6c		 jne	 SHORT $LN24@s390_relea

; 293  :     {
; 294  :         /* Store the unchanged value into the second operand to
; 295  :            ensure suppression in the event of an access exception */
; 296  :         ARCH_DEP(vstore4) ( hlhi_word, effective_addr2, acc_mode, regs );

  002c9	4c 8b 4c 24 78	 mov	 r9, QWORD PTR regs$[rsp]
  002ce	44 8b 44 24 20	 mov	 r8d, DWORD PTR acc_mode$[rsp]
  002d3	8b 54 24 24	 mov	 edx, DWORD PTR effective_addr2$[rsp]
  002d7	8b 4c 24 2c	 mov	 ecx, DWORD PTR hlhi_word$[rsp]
  002db	e8 00 00 00 00	 call	 s390_vstore4

; 297  : 
; 298  :         /* Clear the local lock held bit in the second operand */
; 299  :         hlhi_word &= ~PSALCLLI;

  002e0	8b 44 24 2c	 mov	 eax, DWORD PTR hlhi_word$[rsp]
  002e4	83 e0 fe	 and	 eax, -2			; fffffffeH
  002e7	89 44 24 2c	 mov	 DWORD PTR hlhi_word$[rsp], eax

; 300  :         ARCH_DEP(vstore4) ( hlhi_word, effective_addr2, acc_mode, regs );

  002eb	4c 8b 4c 24 78	 mov	 r9, QWORD PTR regs$[rsp]
  002f0	44 8b 44 24 20	 mov	 r8d, DWORD PTR acc_mode$[rsp]
  002f5	8b 54 24 24	 mov	 edx, DWORD PTR effective_addr2$[rsp]
  002f9	8b 4c 24 2c	 mov	 ecx, DWORD PTR hlhi_word$[rsp]
  002fd	e8 00 00 00 00	 call	 s390_vstore4

; 301  : 
; 302  :         /* Set the local lock to zero */
; 303  :         ARCH_DEP(vstore4) ( 0, lock_addr, acc_mode, regs );

  00302	4c 8b 4c 24 78	 mov	 r9, QWORD PTR regs$[rsp]
  00307	44 8b 44 24 20	 mov	 r8d, DWORD PTR acc_mode$[rsp]
  0030c	8b 54 24 44	 mov	 edx, DWORD PTR lock_addr$[rsp]
  00310	33 c9		 xor	 ecx, ecx
  00312	e8 00 00 00 00	 call	 s390_vstore4

; 304  : 
; 305  :         /* Set register 13 to zero to indicate lock released */
; 306  :         regs->GR_L(13) = 0;

  00317	b8 08 00 00 00	 mov	 eax, 8
  0031c	48 6b c0 0d	 imul	 rax, rax, 13
  00320	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  00325	c7 84 01 80 02
	00 00 00 00 00
	00		 mov	 DWORD PTR [rcx+rax+640], 0

; 307  :     }

  00330	e9 40 01 00 00	 jmp	 $LN25@s390_relea
$LN24@s390_relea:

; 308  :     else
; 309  :     {
; 310  :         /* Fetch the lock interface table address from the
; 311  :            second word of the second operand, and load the
; 312  :            new instruction address and amode from LITRLOC */
; 313  :         lit_addr = ARCH_DEP(vfetch4) ( effective_addr2 + 4, acc_mode, regs ) + LITRLOC;

  00335	8b 44 24 24	 mov	 eax, DWORD PTR effective_addr2$[rsp]
  00339	83 c0 04	 add	 eax, 4
  0033c	4c 8b 44 24 78	 mov	 r8, QWORD PTR regs$[rsp]
  00341	8b 54 24 20	 mov	 edx, DWORD PTR acc_mode$[rsp]
  00345	8b c8		 mov	 ecx, eax
  00347	e8 00 00 00 00	 call	 s390_vfetch4
  0034c	83 c0 f4	 add	 eax, -12		; fffffff4H
  0034f	89 44 24 34	 mov	 DWORD PTR lit_addr$[rsp], eax

; 314  :         lit_addr &= ADDRESS_MAXWRAP(regs);

  00353	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  00358	8b 80 90 00 00
	00		 mov	 eax, DWORD PTR [rax+144]
  0035e	8b 4c 24 34	 mov	 ecx, DWORD PTR lit_addr$[rsp]
  00362	23 c8		 and	 ecx, eax
  00364	8b c1		 mov	 eax, ecx
  00366	89 44 24 34	 mov	 DWORD PTR lit_addr$[rsp], eax

; 315  :         newia = ARCH_DEP(vfetch4) ( lit_addr, acc_mode, regs );

  0036a	4c 8b 44 24 78	 mov	 r8, QWORD PTR regs$[rsp]
  0036f	8b 54 24 20	 mov	 edx, DWORD PTR acc_mode$[rsp]
  00373	8b 4c 24 34	 mov	 ecx, DWORD PTR lit_addr$[rsp]
  00377	e8 00 00 00 00	 call	 s390_vfetch4
  0037c	89 44 24 48	 mov	 DWORD PTR newia$[rsp], eax

; 316  : 
; 317  :         /* Save the link information in register 12 */
; 318  :         regs->GR_L(12) = PSW_IA_FROM_IP(regs, 0);

  00380	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  00385	8b 80 10 02 00
	00		 mov	 eax, DWORD PTR [rax+528]
  0038b	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  00390	48 8b 54 24 78	 mov	 rdx, QWORD PTR regs$[rsp]
  00395	48 8b 92 00 02
	00 00		 mov	 rdx, QWORD PTR [rdx+512]
  0039c	48 8b 49 68	 mov	 rcx, QWORD PTR [rcx+104]
  003a0	48 2b ca	 sub	 rcx, rdx
  003a3	48 03 c1	 add	 rax, rcx
  003a6	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  003ab	8b 89 90 00 00
	00		 mov	 ecx, DWORD PTR [rcx+144]
  003b1	48 23 c1	 and	 rax, rcx
  003b4	b9 08 00 00 00	 mov	 ecx, 8
  003b9	48 6b c9 0c	 imul	 rcx, rcx, 12
  003bd	48 8b 54 24 78	 mov	 rdx, QWORD PTR regs$[rsp]
  003c2	89 84 0a 80 02
	00 00		 mov	 DWORD PTR [rdx+rcx+640], eax

; 319  : 
; 320  :         /* Copy LITRLOC into register 13 to signify release failure */
; 321  :         regs->GR_L(13) = newia;

  003c9	b8 08 00 00 00	 mov	 eax, 8
  003ce	48 6b c0 0d	 imul	 rax, rax, 13
  003d2	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  003d7	8b 54 24 48	 mov	 edx, DWORD PTR newia$[rsp]
  003db	89 94 01 80 02
	00 00		 mov	 DWORD PTR [rcx+rax+640], edx
$LN10@s390_relea:

; 322  : 
; 323  :         /* Update the PSW instruction address */
; 324  :         SET_PSW_IA_AND_MAYBE_IP(regs, newia);

  003e2	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  003e7	8b 80 90 00 00
	00		 mov	 eax, DWORD PTR [rax+144]
  003ed	8b 4c 24 48	 mov	 ecx, DWORD PTR newia$[rsp]
  003f1	23 c8		 and	 ecx, eax
  003f3	8b c1		 mov	 eax, ecx
  003f5	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  003fa	89 81 88 00 00
	00		 mov	 DWORD PTR [rcx+136], eax
  00400	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  00405	48 83 b8 08 02
	00 00 00	 cmp	 QWORD PTR [rax+520], 0
  0040d	74 5c		 je	 SHORT $LN26@s390_relea
  0040f	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  00414	8b 80 88 00 00
	00		 mov	 eax, DWORD PTR [rax+136]
  0041a	25 01 f0 ff 7f	 and	 eax, 2147479553		; 7ffff001H
  0041f	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  00424	39 81 10 02 00
	00		 cmp	 DWORD PTR [rcx+528], eax
  0042a	75 2f		 jne	 SHORT $LN27@s390_relea
  0042c	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  00431	8b 80 88 00 00
	00		 mov	 eax, DWORD PTR [rax+136]
  00437	25 ff 0f 00 00	 and	 eax, 4095		; 00000fffH
  0043c	8b c0		 mov	 eax, eax
  0043e	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  00443	48 8b 89 00 02
	00 00		 mov	 rcx, QWORD PTR [rcx+512]
  0044a	48 0b c8	 or	 rcx, rax
  0044d	48 8b c1	 mov	 rax, rcx
  00450	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  00455	48 89 41 68	 mov	 QWORD PTR [rcx+104], rax
  00459	eb 10		 jmp	 SHORT $LN28@s390_relea
$LN27@s390_relea:
  0045b	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  00460	48 c7 80 08 02
	00 00 00 00 00
	00		 mov	 QWORD PTR [rax+520], 0
$LN28@s390_relea:
$LN26@s390_relea:
  0046b	33 c0		 xor	 eax, eax
  0046d	85 c0		 test	 eax, eax
  0046f	0f 85 6d ff ff
	ff		 jne	 $LN10@s390_relea
$LN25@s390_relea:
$LN13@s390_relea:

; 325  :     }
; 326  : 
; 327  :     /* Release main-storage access lock */
; 328  :     RELEASE_MAINLOCK_UNCONDITIONAL(regs);

  00475	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  0047a	48 8b 40 40	 mov	 rax, QWORD PTR [rax+64]
  0047e	0f b7 80 60 10
	00 00		 movzx	 eax, WORD PTR [rax+4192]
  00485	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  0048a	48 8b 89 68 08
	00 00		 mov	 rcx, QWORD PTR [rcx+2152]
  00491	0f b7 89 3c 08
	00 00		 movzx	 ecx, WORD PTR [rcx+2108]
  00498	3b c1		 cmp	 eax, ecx
  0049a	75 34		 jne	 SHORT $LN29@s390_relea
  0049c	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  004a1	48 8b 40 40	 mov	 rax, QWORD PTR [rax+64]
  004a5	b9 ff ff 00 00	 mov	 ecx, 65535		; 0000ffffH
  004aa	66 89 88 60 10
	00 00		 mov	 WORD PTR [rax+4192], cx
  004b1	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  004b6	48 8b 40 40	 mov	 rax, QWORD PTR [rax+64]
  004ba	48 05 68 10 00
	00		 add	 rax, 4200		; 00001068H
  004c0	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG180278
  004c7	48 8b c8	 mov	 rcx, rax
  004ca	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_release_lock
$LN29@s390_relea:
  004d0	33 c0		 xor	 eax, eax
  004d2	85 c0		 test	 eax, eax
  004d4	75 9f		 jne	 SHORT $LN13@s390_relea

; 329  : 
; 330  : } /* end function release_local_lock */

  004d6	48 83 c4 68	 add	 rsp, 104		; 00000068H
  004da	c3		 ret	 0
s390_release_local_lock ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\assist.c
_TEXT	SEGMENT
acc_mode$ = 32
effective_addr2$ = 36
effective_addr1$ = 40
hlhi_word$ = 44
temp$1 = 48
lock_addr$ = 52
lit_addr$ = 56
b1$ = 60
b2$ = 64
newia$ = 68
ascb_addr$ = 72
lock$ = 76
susp$ = 80
lock_arn$ = 84
inst$ = 112
regs$ = 120
s390_release_cms_lock PROC

; 447  : {

$LN31:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 68	 sub	 rsp, 104		; 00000068H

; 448  : int     b1, b2;                         /* Values of base field      */
; 449  : VADR    effective_addr1,
; 450  :         effective_addr2;                /* Effective addresses       */
; 451  : VADR    ascb_addr;                      /* Virtual address of ASCB   */
; 452  : U32     hlhi_word;                      /* Highest lock held word    */
; 453  : VADR    lit_addr;                       /* Virtual address of lock
; 454  :                                            interface table           */
; 455  : VADR    lock_addr;                      /* Lock address              */
; 456  : int     lock_arn;                       /* Lock access register      */
; 457  : U32     lock;                           /* Lock value                */
; 458  : U32     susp;                           /* Lock suspend queue        */
; 459  : VADR    newia;                          /* Unsuccessful branch addr  */
; 460  : int     acc_mode = 0;                   /* access mode to use        */

  0000e	c7 44 24 20 00
	00 00 00	 mov	 DWORD PTR acc_mode$[rsp], 0

; 461  : 
; 462  :     SSE(inst, regs, b1, effective_addr1, b2, effective_addr2);

  00016	48 8b 44 24 70	 mov	 rax, QWORD PTR inst$[rsp]
  0001b	48 83 c0 02	 add	 rax, 2
  0001f	48 8b c8	 mov	 rcx, rax
  00022	e8 00 00 00 00	 call	 fetch_fw_noswap
  00027	8b c8		 mov	 ecx, eax
  00029	e8 00 00 00 00	 call	 _byteswap_ulong
  0002e	89 44 24 30	 mov	 DWORD PTR temp$1[rsp], eax
  00032	8b 44 24 30	 mov	 eax, DWORD PTR temp$1[rsp]
  00036	25 ff 0f 00 00	 and	 eax, 4095		; 00000fffH
  0003b	89 44 24 24	 mov	 DWORD PTR effective_addr2$[rsp], eax
  0003f	8b 44 24 30	 mov	 eax, DWORD PTR temp$1[rsp]
  00043	c1 e8 0c	 shr	 eax, 12
  00046	83 e0 0f	 and	 eax, 15
  00049	89 44 24 40	 mov	 DWORD PTR b2$[rsp], eax
  0004d	8b 44 24 30	 mov	 eax, DWORD PTR temp$1[rsp]
  00051	c1 e8 10	 shr	 eax, 16
  00054	25 ff 0f 00 00	 and	 eax, 4095		; 00000fffH
  00059	89 44 24 28	 mov	 DWORD PTR effective_addr1$[rsp], eax
  0005d	8b 44 24 30	 mov	 eax, DWORD PTR temp$1[rsp]
  00061	c1 e8 1c	 shr	 eax, 28
  00064	83 e0 0f	 and	 eax, 15
  00067	89 44 24 3c	 mov	 DWORD PTR b1$[rsp], eax
  0006b	83 7c 24 3c 00	 cmp	 DWORD PTR b1$[rsp], 0
  00070	74 34		 je	 SHORT $LN14@s390_relea
  00072	48 63 44 24 3c	 movsxd	 rax, DWORD PTR b1$[rsp]
  00077	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  0007c	8b 84 c1 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax*8+640]
  00083	8b 4c 24 28	 mov	 ecx, DWORD PTR effective_addr1$[rsp]
  00087	03 c8		 add	 ecx, eax
  00089	8b c1		 mov	 eax, ecx
  0008b	89 44 24 28	 mov	 DWORD PTR effective_addr1$[rsp], eax
  0008f	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  00094	8b 80 90 00 00
	00		 mov	 eax, DWORD PTR [rax+144]
  0009a	8b 4c 24 28	 mov	 ecx, DWORD PTR effective_addr1$[rsp]
  0009e	23 c8		 and	 ecx, eax
  000a0	8b c1		 mov	 eax, ecx
  000a2	89 44 24 28	 mov	 DWORD PTR effective_addr1$[rsp], eax
$LN14@s390_relea:
  000a6	83 7c 24 40 00	 cmp	 DWORD PTR b2$[rsp], 0
  000ab	74 34		 je	 SHORT $LN15@s390_relea
  000ad	48 63 44 24 40	 movsxd	 rax, DWORD PTR b2$[rsp]
  000b2	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  000b7	8b 84 c1 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax*8+640]
  000be	8b 4c 24 24	 mov	 ecx, DWORD PTR effective_addr2$[rsp]
  000c2	03 c8		 add	 ecx, eax
  000c4	8b c1		 mov	 eax, ecx
  000c6	89 44 24 24	 mov	 DWORD PTR effective_addr2$[rsp], eax
  000ca	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  000cf	8b 80 90 00 00
	00		 mov	 eax, DWORD PTR [rax+144]
  000d5	8b 4c 24 24	 mov	 ecx, DWORD PTR effective_addr2$[rsp]
  000d9	23 c8		 and	 ecx, eax
  000db	8b c1		 mov	 eax, ecx
  000dd	89 44 24 24	 mov	 DWORD PTR effective_addr2$[rsp], eax
$LN15@s390_relea:
$LN4@s390_relea:
  000e1	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  000e6	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  000ea	48 83 c0 06	 add	 rax, 6
  000ee	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  000f3	48 89 41 68	 mov	 QWORD PTR [rcx+104], rax
  000f7	33 c0		 xor	 eax, eax
  000f9	83 f8 06	 cmp	 eax, 6
  000fc	74 0c		 je	 SHORT $LN16@s390_relea
  000fe	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  00103	c6 80 9a 00 00
	00 06		 mov	 BYTE PTR [rax+154], 6
$LN16@s390_relea:
  0010a	33 c0		 xor	 eax, eax
  0010c	85 c0		 test	 eax, eax
  0010e	75 d1		 jne	 SHORT $LN4@s390_relea

; 463  :     PER_ZEROADDR_XCHECK2( regs, b1, b2 );
; 464  : 
; 465  :     GUEST_CHECK( );

  00110	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  00115	0f b6 40 7a	 movzx	 eax, BYTE PTR [rax+122]
  00119	83 e0 01	 and	 eax, 1
  0011c	85 c0		 test	 eax, eax
  0011e	74 44		 je	 SHORT $LN17@s390_relea
  00120	b8 08 00 00 00	 mov	 eax, 8
  00125	48 6b c0 07	 imul	 rax, rax, 7
  00129	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  0012e	8b 84 01 00 06
	00 00		 mov	 eax, DWORD PTR [rcx+rax+1536]
  00135	25 04 00 00 40	 and	 eax, 1073741828		; 40000004H
  0013a	83 f8 04	 cmp	 eax, 4
  0013d	74 25		 je	 SHORT $LN18@s390_relea
  0013f	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  00144	0f b6 40 7a	 movzx	 eax, BYTE PTR [rax+122]
  00148	83 e0 01	 and	 eax, 1
  0014b	85 c0		 test	 eax, eax
  0014d	74 15		 je	 SHORT $LN19@s390_relea
  0014f	ba 02 00 00 00	 mov	 edx, 2
  00154	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  00159	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  0015e	ff 90 20 0d 00
	00		 call	 QWORD PTR [rax+3360]
$LN19@s390_relea:
$LN18@s390_relea:
$LN17@s390_relea:

; 466  : 
; 467  :     /* Specification exception if operands are not on word boundary */
; 468  :     if ((effective_addr1 & 0x00000003) || (effective_addr2 & 0x00000003))

  00164	8b 44 24 28	 mov	 eax, DWORD PTR effective_addr1$[rsp]
  00168	83 e0 03	 and	 eax, 3
  0016b	85 c0		 test	 eax, eax
  0016d	75 0b		 jne	 SHORT $LN21@s390_relea
  0016f	8b 44 24 24	 mov	 eax, DWORD PTR effective_addr2$[rsp]
  00173	83 e0 03	 and	 eax, 3
  00176	85 c0		 test	 eax, eax
  00178	74 0f		 je	 SHORT $LN20@s390_relea
$LN21@s390_relea:

; 469  :         ARCH_DEP(program_interrupt) (regs, PGM_SPECIFICATION_EXCEPTION);

  0017a	ba 06 00 00 00	 mov	 edx, 6
  0017f	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  00184	e8 00 00 00 00	 call	 s390_program_interrupt
$LN20@s390_relea:

; 470  : 
; 471  :     /* General register 11 contains the lock address */
; 472  :     lock_addr = regs->GR_L(11) & ADDRESS_MAXWRAP(regs);

  00189	b8 08 00 00 00	 mov	 eax, 8
  0018e	48 6b c0 0b	 imul	 rax, rax, 11
  00192	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  00197	48 8b 54 24 78	 mov	 rdx, QWORD PTR regs$[rsp]
  0019c	8b 92 90 00 00
	00		 mov	 edx, DWORD PTR [rdx+144]
  001a2	8b 84 01 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax+640]
  001a9	23 c2		 and	 eax, edx
  001ab	89 44 24 34	 mov	 DWORD PTR lock_addr$[rsp], eax

; 473  :     lock_arn = 11;

  001af	c7 44 24 54 0b
	00 00 00	 mov	 DWORD PTR lock_arn$[rsp], 11
$LN7@s390_relea:

; 474  : 
; 475  :     /* Obtain main-storage access lock */
; 476  :     OBTAIN_MAINLOCK_UNCONDITIONAL(regs);

  001b7	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  001bc	48 8b 80 68 08
	00 00		 mov	 rax, QWORD PTR [rax+2152]
  001c3	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  001c8	48 8b 49 40	 mov	 rcx, QWORD PTR [rcx+64]
  001cc	48 8b 89 b0 12
	00 00		 mov	 rcx, QWORD PTR [rcx+4784]
  001d3	48 39 48 50	 cmp	 QWORD PTR [rax+80], rcx
  001d7	74 42		 je	 SHORT $LN22@s390_relea
  001d9	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  001de	48 8b 40 40	 mov	 rax, QWORD PTR [rax+64]
  001e2	48 05 68 10 00
	00		 add	 rax, 4200		; 00001068H
  001e8	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG180382
  001ef	48 8b c8	 mov	 rcx, rax
  001f2	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_obtain_lock
  001f8	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  001fd	48 8b 80 68 08
	00 00		 mov	 rax, QWORD PTR [rax+2152]
  00204	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  00209	48 8b 49 40	 mov	 rcx, QWORD PTR [rcx+64]
  0020d	0f b7 80 3c 08
	00 00		 movzx	 eax, WORD PTR [rax+2108]
  00214	66 89 81 60 10
	00 00		 mov	 WORD PTR [rcx+4192], ax
$LN22@s390_relea:
  0021b	33 c0		 xor	 eax, eax
  0021d	85 c0		 test	 eax, eax
  0021f	75 96		 jne	 SHORT $LN7@s390_relea

; 477  : 
; 478  :     if (ACCESS_REGISTER_MODE(&regs->psw))

  00221	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  00226	0f b6 40 7b	 movzx	 eax, BYTE PTR [rax+123]
  0022a	83 f8 40	 cmp	 eax, 64			; 00000040H
  0022d	75 08		 jne	 SHORT $LN23@s390_relea

; 479  :         acc_mode = USE_PRIMARY_SPACE;

  0022f	c7 44 24 20 fd
	ff ff ff	 mov	 DWORD PTR acc_mode$[rsp], -3
$LN23@s390_relea:

; 480  : 
; 481  :     /* Load ASCB address from first operand location */
; 482  :     ascb_addr = ARCH_DEP(vfetch4) ( effective_addr1, acc_mode, regs );

  00237	4c 8b 44 24 78	 mov	 r8, QWORD PTR regs$[rsp]
  0023c	8b 54 24 20	 mov	 edx, DWORD PTR acc_mode$[rsp]
  00240	8b 4c 24 28	 mov	 ecx, DWORD PTR effective_addr1$[rsp]
  00244	e8 00 00 00 00	 call	 s390_vfetch4
  00249	89 44 24 48	 mov	 DWORD PTR ascb_addr$[rsp], eax

; 483  : 
; 484  :     /* Load locks held bits from second operand location */
; 485  :     hlhi_word = ARCH_DEP(vfetch4) ( effective_addr2, acc_mode, regs );

  0024d	4c 8b 44 24 78	 mov	 r8, QWORD PTR regs$[rsp]
  00252	8b 54 24 20	 mov	 edx, DWORD PTR acc_mode$[rsp]
  00256	8b 4c 24 24	 mov	 ecx, DWORD PTR effective_addr2$[rsp]
  0025a	e8 00 00 00 00	 call	 s390_vfetch4
  0025f	89 44 24 2c	 mov	 DWORD PTR hlhi_word$[rsp], eax

; 486  : 
; 487  :     /* Fetch the CMS lock and the suspend queue word */
; 488  :     lock = ARCH_DEP(vfetch4) ( lock_addr, acc_mode, regs );

  00263	4c 8b 44 24 78	 mov	 r8, QWORD PTR regs$[rsp]
  00268	8b 54 24 20	 mov	 edx, DWORD PTR acc_mode$[rsp]
  0026c	8b 4c 24 34	 mov	 ecx, DWORD PTR lock_addr$[rsp]
  00270	e8 00 00 00 00	 call	 s390_vfetch4
  00275	89 44 24 4c	 mov	 DWORD PTR lock$[rsp], eax

; 489  :     susp = ARCH_DEP(vfetch4) ( lock_addr + 4, acc_mode, regs );

  00279	8b 44 24 34	 mov	 eax, DWORD PTR lock_addr$[rsp]
  0027d	83 c0 04	 add	 eax, 4
  00280	4c 8b 44 24 78	 mov	 r8, QWORD PTR regs$[rsp]
  00285	8b 54 24 20	 mov	 edx, DWORD PTR acc_mode$[rsp]
  00289	8b c8		 mov	 ecx, eax
  0028b	e8 00 00 00 00	 call	 s390_vfetch4
  00290	89 44 24 50	 mov	 DWORD PTR susp$[rsp], eax

; 490  : 
; 491  :     /* Test if current ASCB holds this lock, the locks held indicators
; 492  :        show a CMS lock is held, and the lock suspend queue is empty */
; 493  :     if (lock == ascb_addr
; 494  :         && (hlhi_word & PSACMSLI)
; 495  :         && susp == 0)

  00294	8b 44 24 48	 mov	 eax, DWORD PTR ascb_addr$[rsp]
  00298	39 44 24 4c	 cmp	 DWORD PTR lock$[rsp], eax
  0029c	75 7e		 jne	 SHORT $LN24@s390_relea
  0029e	8b 44 24 2c	 mov	 eax, DWORD PTR hlhi_word$[rsp]
  002a2	83 e0 02	 and	 eax, 2
  002a5	85 c0		 test	 eax, eax
  002a7	74 73		 je	 SHORT $LN24@s390_relea
  002a9	83 7c 24 50 00	 cmp	 DWORD PTR susp$[rsp], 0
  002ae	75 6c		 jne	 SHORT $LN24@s390_relea

; 496  :     {
; 497  :         /* Store the unchanged value into the second operand to
; 498  :            ensure suppression in the event of an access exception */
; 499  :         ARCH_DEP(vstore4) ( hlhi_word, effective_addr2, acc_mode, regs );

  002b0	4c 8b 4c 24 78	 mov	 r9, QWORD PTR regs$[rsp]
  002b5	44 8b 44 24 20	 mov	 r8d, DWORD PTR acc_mode$[rsp]
  002ba	8b 54 24 24	 mov	 edx, DWORD PTR effective_addr2$[rsp]
  002be	8b 4c 24 2c	 mov	 ecx, DWORD PTR hlhi_word$[rsp]
  002c2	e8 00 00 00 00	 call	 s390_vstore4

; 500  : 
; 501  :         /* Clear the CMS lock held bit in the second operand */
; 502  :         hlhi_word &= ~PSACMSLI;

  002c7	8b 44 24 2c	 mov	 eax, DWORD PTR hlhi_word$[rsp]
  002cb	83 e0 fd	 and	 eax, -3			; fffffffdH
  002ce	89 44 24 2c	 mov	 DWORD PTR hlhi_word$[rsp], eax

; 503  :         ARCH_DEP(vstore4) ( hlhi_word, effective_addr2, acc_mode, regs );

  002d2	4c 8b 4c 24 78	 mov	 r9, QWORD PTR regs$[rsp]
  002d7	44 8b 44 24 20	 mov	 r8d, DWORD PTR acc_mode$[rsp]
  002dc	8b 54 24 24	 mov	 edx, DWORD PTR effective_addr2$[rsp]
  002e0	8b 4c 24 2c	 mov	 ecx, DWORD PTR hlhi_word$[rsp]
  002e4	e8 00 00 00 00	 call	 s390_vstore4

; 504  : 
; 505  :         /* Set the CMS lock to zero */
; 506  :         ARCH_DEP(vstore4) ( 0, lock_addr, acc_mode, regs );

  002e9	4c 8b 4c 24 78	 mov	 r9, QWORD PTR regs$[rsp]
  002ee	44 8b 44 24 20	 mov	 r8d, DWORD PTR acc_mode$[rsp]
  002f3	8b 54 24 34	 mov	 edx, DWORD PTR lock_addr$[rsp]
  002f7	33 c9		 xor	 ecx, ecx
  002f9	e8 00 00 00 00	 call	 s390_vstore4

; 507  : 
; 508  :         /* Set register 13 to zero to indicate lock released */
; 509  :         regs->GR_L(13) = 0;

  002fe	b8 08 00 00 00	 mov	 eax, 8
  00303	48 6b c0 0d	 imul	 rax, rax, 13
  00307	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  0030c	c7 84 01 80 02
	00 00 00 00 00
	00		 mov	 DWORD PTR [rcx+rax+640], 0

; 510  :     }

  00317	e9 40 01 00 00	 jmp	 $LN25@s390_relea
$LN24@s390_relea:

; 511  :     else
; 512  :     {
; 513  :         /* Fetch the lock interface table address from the
; 514  :            second word of the second operand, and load the
; 515  :            new instruction address and amode from LITRCMS */
; 516  :         lit_addr = ARCH_DEP(vfetch4) ( effective_addr2 + 4, acc_mode, regs ) + LITRCMS;

  0031c	8b 44 24 24	 mov	 eax, DWORD PTR effective_addr2$[rsp]
  00320	83 c0 04	 add	 eax, 4
  00323	4c 8b 44 24 78	 mov	 r8, QWORD PTR regs$[rsp]
  00328	8b 54 24 20	 mov	 edx, DWORD PTR acc_mode$[rsp]
  0032c	8b c8		 mov	 ecx, eax
  0032e	e8 00 00 00 00	 call	 s390_vfetch4
  00333	83 c0 fc	 add	 eax, -4			; fffffffcH
  00336	89 44 24 38	 mov	 DWORD PTR lit_addr$[rsp], eax

; 517  :         lit_addr &= ADDRESS_MAXWRAP(regs);

  0033a	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  0033f	8b 80 90 00 00
	00		 mov	 eax, DWORD PTR [rax+144]
  00345	8b 4c 24 38	 mov	 ecx, DWORD PTR lit_addr$[rsp]
  00349	23 c8		 and	 ecx, eax
  0034b	8b c1		 mov	 eax, ecx
  0034d	89 44 24 38	 mov	 DWORD PTR lit_addr$[rsp], eax

; 518  :         newia = ARCH_DEP(vfetch4) ( lit_addr, acc_mode, regs );

  00351	4c 8b 44 24 78	 mov	 r8, QWORD PTR regs$[rsp]
  00356	8b 54 24 20	 mov	 edx, DWORD PTR acc_mode$[rsp]
  0035a	8b 4c 24 38	 mov	 ecx, DWORD PTR lit_addr$[rsp]
  0035e	e8 00 00 00 00	 call	 s390_vfetch4
  00363	89 44 24 44	 mov	 DWORD PTR newia$[rsp], eax

; 519  : 
; 520  :         /* Save the link information in register 12 */
; 521  :         regs->GR_L(12) = PSW_IA_FROM_IP(regs, 0);

  00367	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  0036c	8b 80 10 02 00
	00		 mov	 eax, DWORD PTR [rax+528]
  00372	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  00377	48 8b 54 24 78	 mov	 rdx, QWORD PTR regs$[rsp]
  0037c	48 8b 92 00 02
	00 00		 mov	 rdx, QWORD PTR [rdx+512]
  00383	48 8b 49 68	 mov	 rcx, QWORD PTR [rcx+104]
  00387	48 2b ca	 sub	 rcx, rdx
  0038a	48 03 c1	 add	 rax, rcx
  0038d	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  00392	8b 89 90 00 00
	00		 mov	 ecx, DWORD PTR [rcx+144]
  00398	48 23 c1	 and	 rax, rcx
  0039b	b9 08 00 00 00	 mov	 ecx, 8
  003a0	48 6b c9 0c	 imul	 rcx, rcx, 12
  003a4	48 8b 54 24 78	 mov	 rdx, QWORD PTR regs$[rsp]
  003a9	89 84 0a 80 02
	00 00		 mov	 DWORD PTR [rdx+rcx+640], eax

; 522  : 
; 523  :         /* Copy LITRCMS into register 13 to signify release failure */
; 524  :         regs->GR_L(13) = newia;

  003b0	b8 08 00 00 00	 mov	 eax, 8
  003b5	48 6b c0 0d	 imul	 rax, rax, 13
  003b9	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  003be	8b 54 24 44	 mov	 edx, DWORD PTR newia$[rsp]
  003c2	89 94 01 80 02
	00 00		 mov	 DWORD PTR [rcx+rax+640], edx
$LN10@s390_relea:

; 525  : 
; 526  :         /* Update the PSW instruction address */
; 527  :         SET_PSW_IA_AND_MAYBE_IP(regs, newia);

  003c9	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  003ce	8b 80 90 00 00
	00		 mov	 eax, DWORD PTR [rax+144]
  003d4	8b 4c 24 44	 mov	 ecx, DWORD PTR newia$[rsp]
  003d8	23 c8		 and	 ecx, eax
  003da	8b c1		 mov	 eax, ecx
  003dc	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  003e1	89 81 88 00 00
	00		 mov	 DWORD PTR [rcx+136], eax
  003e7	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  003ec	48 83 b8 08 02
	00 00 00	 cmp	 QWORD PTR [rax+520], 0
  003f4	74 5c		 je	 SHORT $LN26@s390_relea
  003f6	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  003fb	8b 80 88 00 00
	00		 mov	 eax, DWORD PTR [rax+136]
  00401	25 01 f0 ff 7f	 and	 eax, 2147479553		; 7ffff001H
  00406	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  0040b	39 81 10 02 00
	00		 cmp	 DWORD PTR [rcx+528], eax
  00411	75 2f		 jne	 SHORT $LN27@s390_relea
  00413	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  00418	8b 80 88 00 00
	00		 mov	 eax, DWORD PTR [rax+136]
  0041e	25 ff 0f 00 00	 and	 eax, 4095		; 00000fffH
  00423	8b c0		 mov	 eax, eax
  00425	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  0042a	48 8b 89 00 02
	00 00		 mov	 rcx, QWORD PTR [rcx+512]
  00431	48 0b c8	 or	 rcx, rax
  00434	48 8b c1	 mov	 rax, rcx
  00437	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  0043c	48 89 41 68	 mov	 QWORD PTR [rcx+104], rax
  00440	eb 10		 jmp	 SHORT $LN28@s390_relea
$LN27@s390_relea:
  00442	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  00447	48 c7 80 08 02
	00 00 00 00 00
	00		 mov	 QWORD PTR [rax+520], 0
$LN28@s390_relea:
$LN26@s390_relea:
  00452	33 c0		 xor	 eax, eax
  00454	85 c0		 test	 eax, eax
  00456	0f 85 6d ff ff
	ff		 jne	 $LN10@s390_relea
$LN25@s390_relea:
$LN13@s390_relea:

; 528  :     }
; 529  : 
; 530  :     /* Release main-storage access lock */
; 531  :     RELEASE_MAINLOCK_UNCONDITIONAL(regs);

  0045c	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  00461	48 8b 40 40	 mov	 rax, QWORD PTR [rax+64]
  00465	0f b7 80 60 10
	00 00		 movzx	 eax, WORD PTR [rax+4192]
  0046c	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  00471	48 8b 89 68 08
	00 00		 mov	 rcx, QWORD PTR [rcx+2152]
  00478	0f b7 89 3c 08
	00 00		 movzx	 ecx, WORD PTR [rcx+2108]
  0047f	3b c1		 cmp	 eax, ecx
  00481	75 34		 jne	 SHORT $LN29@s390_relea
  00483	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  00488	48 8b 40 40	 mov	 rax, QWORD PTR [rax+64]
  0048c	b9 ff ff 00 00	 mov	 ecx, 65535		; 0000ffffH
  00491	66 89 88 60 10
	00 00		 mov	 WORD PTR [rax+4192], cx
  00498	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  0049d	48 8b 40 40	 mov	 rax, QWORD PTR [rax+64]
  004a1	48 05 68 10 00
	00		 add	 rax, 4200		; 00001068H
  004a7	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG180390
  004ae	48 8b c8	 mov	 rcx, rax
  004b1	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_release_lock
$LN29@s390_relea:
  004b7	33 c0		 xor	 eax, eax
  004b9	85 c0		 test	 eax, eax
  004bb	75 9f		 jne	 SHORT $LN13@s390_relea

; 532  : 
; 533  : } /* end function release_cms_lock */

  004bd	48 83 c4 68	 add	 rsp, 104		; 00000068H
  004c1	c3		 ret	 0
s390_release_cms_lock ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\assist.c
_TEXT	SEGMENT
effective_addr2$ = 48
acc_mode$ = 52
effective_addr1$ = 56
temp$1 = 60
hlhi_word$ = 64
b2$ = 68
lit_addr$ = 72
b1$ = 76
newia$ = 80
ascb_addr$ = 84
lcpa$ = 88
new$ = 92
old$ = 96
mainstor$ = 104
inst$ = 128
regs$ = 136
s390_obtain_local_lock PROC

; 149  : {

$LN23:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 78	 sub	 rsp, 120		; 00000078H

; 150  :     int     b1, b2;                     /* Values of base field      */
; 151  :     VADR    effective_addr1,
; 152  :             effective_addr2;            /* Effective addresses       */
; 153  :     VADR    ascb_addr;                  /* Virtual address of ASCB   */
; 154  :     U32     hlhi_word;                  /* Highest lock held word    */
; 155  :     VADR    lit_addr;                   /* Virtual address of lock
; 156  :                                            interface table           */
; 157  :     U32     lcpa;                       /* Logical CPU address       */
; 158  :     VADR    newia;                      /* Unsuccessful branch addr  */
; 159  :     BYTE   *mainstor;                   /* mainstor address          */
; 160  :     U32     old;                        /* old value                 */
; 161  :     U32     new;                        /* new value                 */
; 162  :     int     acc_mode = 0;               /* access mode to use        */

  0000e	c7 44 24 34 00
	00 00 00	 mov	 DWORD PTR acc_mode$[rsp], 0

; 163  : 
; 164  :     SSE(inst, regs, b1, effective_addr1, b2, effective_addr2);

  00016	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR inst$[rsp]
  0001e	48 83 c0 02	 add	 rax, 2
  00022	48 8b c8	 mov	 rcx, rax
  00025	e8 00 00 00 00	 call	 fetch_fw_noswap
  0002a	8b c8		 mov	 ecx, eax
  0002c	e8 00 00 00 00	 call	 _byteswap_ulong
  00031	89 44 24 3c	 mov	 DWORD PTR temp$1[rsp], eax
  00035	8b 44 24 3c	 mov	 eax, DWORD PTR temp$1[rsp]
  00039	25 ff 0f 00 00	 and	 eax, 4095		; 00000fffH
  0003e	89 44 24 30	 mov	 DWORD PTR effective_addr2$[rsp], eax
  00042	8b 44 24 3c	 mov	 eax, DWORD PTR temp$1[rsp]
  00046	c1 e8 0c	 shr	 eax, 12
  00049	83 e0 0f	 and	 eax, 15
  0004c	89 44 24 44	 mov	 DWORD PTR b2$[rsp], eax
  00050	8b 44 24 3c	 mov	 eax, DWORD PTR temp$1[rsp]
  00054	c1 e8 10	 shr	 eax, 16
  00057	25 ff 0f 00 00	 and	 eax, 4095		; 00000fffH
  0005c	89 44 24 38	 mov	 DWORD PTR effective_addr1$[rsp], eax
  00060	8b 44 24 3c	 mov	 eax, DWORD PTR temp$1[rsp]
  00064	c1 e8 1c	 shr	 eax, 28
  00067	83 e0 0f	 and	 eax, 15
  0006a	89 44 24 4c	 mov	 DWORD PTR b1$[rsp], eax
  0006e	83 7c 24 4c 00	 cmp	 DWORD PTR b1$[rsp], 0
  00073	74 3a		 je	 SHORT $LN8@s390_obtai
  00075	48 63 44 24 4c	 movsxd	 rax, DWORD PTR b1$[rsp]
  0007a	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00082	8b 84 c1 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax*8+640]
  00089	8b 4c 24 38	 mov	 ecx, DWORD PTR effective_addr1$[rsp]
  0008d	03 c8		 add	 ecx, eax
  0008f	8b c1		 mov	 eax, ecx
  00091	89 44 24 38	 mov	 DWORD PTR effective_addr1$[rsp], eax
  00095	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0009d	8b 80 90 00 00
	00		 mov	 eax, DWORD PTR [rax+144]
  000a3	8b 4c 24 38	 mov	 ecx, DWORD PTR effective_addr1$[rsp]
  000a7	23 c8		 and	 ecx, eax
  000a9	8b c1		 mov	 eax, ecx
  000ab	89 44 24 38	 mov	 DWORD PTR effective_addr1$[rsp], eax
$LN8@s390_obtai:
  000af	83 7c 24 44 00	 cmp	 DWORD PTR b2$[rsp], 0
  000b4	74 3a		 je	 SHORT $LN9@s390_obtai
  000b6	48 63 44 24 44	 movsxd	 rax, DWORD PTR b2$[rsp]
  000bb	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  000c3	8b 84 c1 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax*8+640]
  000ca	8b 4c 24 30	 mov	 ecx, DWORD PTR effective_addr2$[rsp]
  000ce	03 c8		 add	 ecx, eax
  000d0	8b c1		 mov	 eax, ecx
  000d2	89 44 24 30	 mov	 DWORD PTR effective_addr2$[rsp], eax
  000d6	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  000de	8b 80 90 00 00
	00		 mov	 eax, DWORD PTR [rax+144]
  000e4	8b 4c 24 30	 mov	 ecx, DWORD PTR effective_addr2$[rsp]
  000e8	23 c8		 and	 ecx, eax
  000ea	8b c1		 mov	 eax, ecx
  000ec	89 44 24 30	 mov	 DWORD PTR effective_addr2$[rsp], eax
$LN9@s390_obtai:
$LN4@s390_obtai:
  000f0	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  000f8	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  000fc	48 83 c0 06	 add	 rax, 6
  00100	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00108	48 89 41 68	 mov	 QWORD PTR [rcx+104], rax
  0010c	33 c0		 xor	 eax, eax
  0010e	83 f8 06	 cmp	 eax, 6
  00111	74 0f		 je	 SHORT $LN10@s390_obtai
  00113	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0011b	c6 80 9a 00 00
	00 06		 mov	 BYTE PTR [rax+154], 6
$LN10@s390_obtai:
  00122	33 c0		 xor	 eax, eax
  00124	85 c0		 test	 eax, eax
  00126	75 c8		 jne	 SHORT $LN4@s390_obtai

; 165  :     PER_ZEROADDR_XCHECK2( regs, b1, b2 );
; 166  : 
; 167  :     GUEST_CHECK( );

  00128	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00130	0f b6 40 7a	 movzx	 eax, BYTE PTR [rax+122]
  00134	83 e0 01	 and	 eax, 1
  00137	85 c0		 test	 eax, eax
  00139	74 50		 je	 SHORT $LN11@s390_obtai
  0013b	b8 08 00 00 00	 mov	 eax, 8
  00140	48 6b c0 07	 imul	 rax, rax, 7
  00144	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0014c	8b 84 01 00 06
	00 00		 mov	 eax, DWORD PTR [rcx+rax+1536]
  00153	25 04 00 00 40	 and	 eax, 1073741828		; 40000004H
  00158	83 f8 04	 cmp	 eax, 4
  0015b	74 2e		 je	 SHORT $LN12@s390_obtai
  0015d	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00165	0f b6 40 7a	 movzx	 eax, BYTE PTR [rax+122]
  00169	83 e0 01	 and	 eax, 1
  0016c	85 c0		 test	 eax, eax
  0016e	74 1b		 je	 SHORT $LN13@s390_obtai
  00170	ba 02 00 00 00	 mov	 edx, 2
  00175	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0017d	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00185	ff 90 20 0d 00
	00		 call	 QWORD PTR [rax+3360]
$LN13@s390_obtai:
$LN12@s390_obtai:
$LN11@s390_obtai:

; 168  : 
; 169  :     /* Specification exception if operands are not on word boundary */
; 170  :     if ((effective_addr1 & 0x00000003) || (effective_addr2 & 0x00000003))

  0018b	8b 44 24 38	 mov	 eax, DWORD PTR effective_addr1$[rsp]
  0018f	83 e0 03	 and	 eax, 3
  00192	85 c0		 test	 eax, eax
  00194	75 0b		 jne	 SHORT $LN15@s390_obtai
  00196	8b 44 24 30	 mov	 eax, DWORD PTR effective_addr2$[rsp]
  0019a	83 e0 03	 and	 eax, 3
  0019d	85 c0		 test	 eax, eax
  0019f	74 12		 je	 SHORT $LN14@s390_obtai
$LN15@s390_obtai:

; 171  :         ARCH_DEP(program_interrupt) (regs, PGM_SPECIFICATION_EXCEPTION);

  001a1	ba 06 00 00 00	 mov	 edx, 6
  001a6	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  001ae	e8 00 00 00 00	 call	 s390_program_interrupt
$LN14@s390_obtai:

; 172  : 
; 173  :     PERFORM_SERIALIZATION(regs);

  001b3	0f ae f0	 mfence

; 174  : 
; 175  :     /* MAINLOCK may be required if cmpxchg assists unavailable */
; 176  :     OBTAIN_MAINLOCK(regs);
; 177  :     {
; 178  :         if (ACCESS_REGISTER_MODE(&regs->psw))

  001b6	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  001be	0f b6 40 7b	 movzx	 eax, BYTE PTR [rax+123]
  001c2	83 f8 40	 cmp	 eax, 64			; 00000040H
  001c5	75 08		 jne	 SHORT $LN16@s390_obtai

; 179  :             acc_mode = USE_PRIMARY_SPACE;

  001c7	c7 44 24 34 fd
	ff ff ff	 mov	 DWORD PTR acc_mode$[rsp], -3
$LN16@s390_obtai:

; 180  : 
; 181  :         /* Load ASCB address from first operand location */
; 182  :         ascb_addr = ARCH_DEP(vfetch4) ( effective_addr1, acc_mode, regs );

  001cf	4c 8b 84 24 88
	00 00 00	 mov	 r8, QWORD PTR regs$[rsp]
  001d7	8b 54 24 34	 mov	 edx, DWORD PTR acc_mode$[rsp]
  001db	8b 4c 24 38	 mov	 ecx, DWORD PTR effective_addr1$[rsp]
  001df	e8 00 00 00 00	 call	 s390_vfetch4
  001e4	89 44 24 54	 mov	 DWORD PTR ascb_addr$[rsp], eax

; 183  : 
; 184  :         /* Load locks held bits from second operand location */
; 185  :         hlhi_word = ARCH_DEP(vfetch4) ( effective_addr2, acc_mode, regs );

  001e8	4c 8b 84 24 88
	00 00 00	 mov	 r8, QWORD PTR regs$[rsp]
  001f0	8b 54 24 34	 mov	 edx, DWORD PTR acc_mode$[rsp]
  001f4	8b 4c 24 30	 mov	 ecx, DWORD PTR effective_addr2$[rsp]
  001f8	e8 00 00 00 00	 call	 s390_vfetch4
  001fd	89 44 24 40	 mov	 DWORD PTR hlhi_word$[rsp], eax

; 186  : 
; 187  :         /* Fetch our logical CPU address from PSALCPUA */
; 188  :         lcpa = ARCH_DEP(vfetch4) ( effective_addr2 - 4, acc_mode, regs );

  00201	8b 44 24 30	 mov	 eax, DWORD PTR effective_addr2$[rsp]
  00205	83 e8 04	 sub	 eax, 4
  00208	4c 8b 84 24 88
	00 00 00	 mov	 r8, QWORD PTR regs$[rsp]
  00210	8b 54 24 34	 mov	 edx, DWORD PTR acc_mode$[rsp]
  00214	8b c8		 mov	 ecx, eax
  00216	e8 00 00 00 00	 call	 s390_vfetch4
  0021b	89 44 24 58	 mov	 DWORD PTR lcpa$[rsp], eax

; 189  : 
; 190  :         /* Get mainstor address of ASCBLOCK word */
; 191  :         mainstor = MADDRL (ascb_addr + ASCBLOCK, 4, b2, regs, ACCTYPE_WRITE, regs->psw.pkey);

  0021f	8b 44 24 54	 mov	 eax, DWORD PTR ascb_addr$[rsp]
  00223	05 80 00 00 00	 add	 eax, 128		; 00000080H
  00228	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00230	0f b6 49 79	 movzx	 ecx, BYTE PTR [rcx+121]
  00234	88 4c 24 28	 mov	 BYTE PTR [rsp+40], cl
  00238	c7 44 24 20 02
	00 00 00	 mov	 DWORD PTR [rsp+32], 2
  00240	4c 8b 8c 24 88
	00 00 00	 mov	 r9, QWORD PTR regs$[rsp]
  00248	44 8b 44 24 44	 mov	 r8d, DWORD PTR b2$[rsp]
  0024d	ba 04 00 00 00	 mov	 edx, 4
  00252	8b c8		 mov	 ecx, eax
  00254	e8 00 00 00 00	 call	 s390_maddr_l
  00259	48 89 44 24 68	 mov	 QWORD PTR mainstor$[rsp], rax

; 192  : 
; 193  :         /* The lock word should contain 0; use this as our compare value.
; 194  :            Swap in the CPU address in lpca */
; 195  :         old = 0;

  0025e	c7 44 24 60 00
	00 00 00	 mov	 DWORD PTR old$[rsp], 0

; 196  :         new = CSWAP32(lcpa);

  00266	8b 4c 24 58	 mov	 ecx, DWORD PTR lcpa$[rsp]
  0026a	e8 00 00 00 00	 call	 _byteswap_ulong
  0026f	89 44 24 5c	 mov	 DWORD PTR new$[rsp], eax

; 197  : 
; 198  :         /* Try exchanging values; cmpxchg4 returns 0=success, !0=failure */
; 199  :         if (!cmpxchg4( &old, new, mainstor ))

  00273	4c 8b 44 24 68	 mov	 r8, QWORD PTR mainstor$[rsp]
  00278	8b 54 24 5c	 mov	 edx, DWORD PTR new$[rsp]
  0027c	48 8d 4c 24 60	 lea	 rcx, QWORD PTR old$[rsp]
  00281	e8 00 00 00 00	 call	 cmpxchg4_x86
  00286	0f b6 c0	 movzx	 eax, al
  00289	85 c0		 test	 eax, eax
  0028b	75 60		 jne	 SHORT $LN17@s390_obtai

; 200  :         {
; 201  :             /* Store the unchanged value into the second operand to
; 202  :             ensure suppression in the event of an access exception */
; 203  :             ARCH_DEP(vstore4) ( hlhi_word, effective_addr2, acc_mode, regs );

  0028d	4c 8b 8c 24 88
	00 00 00	 mov	 r9, QWORD PTR regs$[rsp]
  00295	44 8b 44 24 34	 mov	 r8d, DWORD PTR acc_mode$[rsp]
  0029a	8b 54 24 30	 mov	 edx, DWORD PTR effective_addr2$[rsp]
  0029e	8b 4c 24 40	 mov	 ecx, DWORD PTR hlhi_word$[rsp]
  002a2	e8 00 00 00 00	 call	 s390_vstore4

; 204  : 
; 205  :             /* Set the local lock held bit in the second operand */
; 206  :             hlhi_word |= PSALCLLI;

  002a7	8b 44 24 40	 mov	 eax, DWORD PTR hlhi_word$[rsp]
  002ab	83 c8 01	 or	 eax, 1
  002ae	89 44 24 40	 mov	 DWORD PTR hlhi_word$[rsp], eax

; 207  :             ARCH_DEP(vstore4) ( hlhi_word, effective_addr2, acc_mode, regs );

  002b2	4c 8b 8c 24 88
	00 00 00	 mov	 r9, QWORD PTR regs$[rsp]
  002ba	44 8b 44 24 34	 mov	 r8d, DWORD PTR acc_mode$[rsp]
  002bf	8b 54 24 30	 mov	 edx, DWORD PTR effective_addr2$[rsp]
  002c3	8b 4c 24 40	 mov	 ecx, DWORD PTR hlhi_word$[rsp]
  002c7	e8 00 00 00 00	 call	 s390_vstore4

; 208  : 
; 209  :             /* Set register 13 to zero to indicate lock obtained */
; 210  :             regs->GR_L(13) = 0;

  002cc	b8 08 00 00 00	 mov	 eax, 8
  002d1	48 6b c0 0d	 imul	 rax, rax, 13
  002d5	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  002dd	c7 84 01 80 02
	00 00 00 00 00
	00		 mov	 DWORD PTR [rcx+rax+640], 0

; 211  :         }

  002e8	e9 76 01 00 00	 jmp	 $LN18@s390_obtai
$LN17@s390_obtai:

; 212  :         else
; 213  :         {
; 214  :             /* Fetch the lock interface table address from the
; 215  :             second word of the second operand, and load the
; 216  :             new instruction address and amode from LITOLOC */
; 217  :             lit_addr = ARCH_DEP(vfetch4) ( effective_addr2 + 4, acc_mode, regs ) + LITOLOC;

  002ed	8b 44 24 30	 mov	 eax, DWORD PTR effective_addr2$[rsp]
  002f1	83 c0 04	 add	 eax, 4
  002f4	4c 8b 84 24 88
	00 00 00	 mov	 r8, QWORD PTR regs$[rsp]
  002fc	8b 54 24 34	 mov	 edx, DWORD PTR acc_mode$[rsp]
  00300	8b c8		 mov	 ecx, eax
  00302	e8 00 00 00 00	 call	 s390_vfetch4
  00307	83 c0 f0	 add	 eax, -16		; fffffff0H
  0030a	89 44 24 48	 mov	 DWORD PTR lit_addr$[rsp], eax

; 218  :             lit_addr &= ADDRESS_MAXWRAP(regs);

  0030e	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00316	8b 80 90 00 00
	00		 mov	 eax, DWORD PTR [rax+144]
  0031c	8b 4c 24 48	 mov	 ecx, DWORD PTR lit_addr$[rsp]
  00320	23 c8		 and	 ecx, eax
  00322	8b c1		 mov	 eax, ecx
  00324	89 44 24 48	 mov	 DWORD PTR lit_addr$[rsp], eax

; 219  :             newia = ARCH_DEP(vfetch4) ( lit_addr, acc_mode, regs );

  00328	4c 8b 84 24 88
	00 00 00	 mov	 r8, QWORD PTR regs$[rsp]
  00330	8b 54 24 34	 mov	 edx, DWORD PTR acc_mode$[rsp]
  00334	8b 4c 24 48	 mov	 ecx, DWORD PTR lit_addr$[rsp]
  00338	e8 00 00 00 00	 call	 s390_vfetch4
  0033d	89 44 24 50	 mov	 DWORD PTR newia$[rsp], eax

; 220  : 
; 221  :             /* Save the link information in register 12 */
; 222  :             regs->GR_L(12) = PSW_IA_FROM_IP(regs, 0);

  00341	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00349	8b 80 10 02 00
	00		 mov	 eax, DWORD PTR [rax+528]
  0034f	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00357	48 8b 94 24 88
	00 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  0035f	48 8b 92 00 02
	00 00		 mov	 rdx, QWORD PTR [rdx+512]
  00366	48 8b 49 68	 mov	 rcx, QWORD PTR [rcx+104]
  0036a	48 2b ca	 sub	 rcx, rdx
  0036d	48 03 c1	 add	 rax, rcx
  00370	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00378	8b 89 90 00 00
	00		 mov	 ecx, DWORD PTR [rcx+144]
  0037e	48 23 c1	 and	 rax, rcx
  00381	b9 08 00 00 00	 mov	 ecx, 8
  00386	48 6b c9 0c	 imul	 rcx, rcx, 12
  0038a	48 8b 94 24 88
	00 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  00392	89 84 0a 80 02
	00 00		 mov	 DWORD PTR [rdx+rcx+640], eax

; 223  : 
; 224  :             /* Copy LITOLOC into register 13 to signify obtain failure */
; 225  :             regs->GR_L(13) = newia;

  00399	b8 08 00 00 00	 mov	 eax, 8
  0039e	48 6b c0 0d	 imul	 rax, rax, 13
  003a2	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  003aa	8b 54 24 50	 mov	 edx, DWORD PTR newia$[rsp]
  003ae	89 94 01 80 02
	00 00		 mov	 DWORD PTR [rcx+rax+640], edx
$LN7@s390_obtai:

; 226  : 
; 227  :             /* Update the PSW instruction address */
; 228  :             SET_PSW_IA_AND_MAYBE_IP(regs, newia);

  003b5	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  003bd	8b 80 90 00 00
	00		 mov	 eax, DWORD PTR [rax+144]
  003c3	8b 4c 24 50	 mov	 ecx, DWORD PTR newia$[rsp]
  003c7	23 c8		 and	 ecx, eax
  003c9	8b c1		 mov	 eax, ecx
  003cb	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  003d3	89 81 88 00 00
	00		 mov	 DWORD PTR [rcx+136], eax
  003d9	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  003e1	48 83 b8 08 02
	00 00 00	 cmp	 QWORD PTR [rax+520], 0
  003e9	74 6e		 je	 SHORT $LN19@s390_obtai
  003eb	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  003f3	8b 80 88 00 00
	00		 mov	 eax, DWORD PTR [rax+136]
  003f9	25 01 f0 ff 7f	 and	 eax, 2147479553		; 7ffff001H
  003fe	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00406	39 81 10 02 00
	00		 cmp	 DWORD PTR [rcx+528], eax
  0040c	75 38		 jne	 SHORT $LN20@s390_obtai
  0040e	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00416	8b 80 88 00 00
	00		 mov	 eax, DWORD PTR [rax+136]
  0041c	25 ff 0f 00 00	 and	 eax, 4095		; 00000fffH
  00421	8b c0		 mov	 eax, eax
  00423	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0042b	48 8b 89 00 02
	00 00		 mov	 rcx, QWORD PTR [rcx+512]
  00432	48 0b c8	 or	 rcx, rax
  00435	48 8b c1	 mov	 rax, rcx
  00438	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00440	48 89 41 68	 mov	 QWORD PTR [rcx+104], rax
  00444	eb 13		 jmp	 SHORT $LN21@s390_obtai
$LN20@s390_obtai:
  00446	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0044e	48 c7 80 08 02
	00 00 00 00 00
	00		 mov	 QWORD PTR [rax+520], 0
$LN21@s390_obtai:
$LN19@s390_obtai:
  00459	33 c0		 xor	 eax, eax
  0045b	85 c0		 test	 eax, eax
  0045d	0f 85 52 ff ff
	ff		 jne	 $LN7@s390_obtai
$LN18@s390_obtai:

; 229  :         }
; 230  :     }
; 231  :     RELEASE_MAINLOCK(regs);
; 232  : 
; 233  :     PERFORM_SERIALIZATION(regs);

  00463	0f ae f0	 mfence

; 234  : 
; 235  : } /* end function obtain_local_lock */

  00466	48 83 c4 78	 add	 rsp, 120		; 00000078H
  0046a	c3		 ret	 0
s390_obtain_local_lock ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\assist.c
_TEXT	SEGMENT
effective_addr2$ = 48
acc_mode$ = 52
effective_addr1$ = 56
hlhi_word$ = 60
temp$1 = 64
b2$ = 68
lit_addr$ = 72
b1$ = 76
lock_addr$ = 80
tv195 = 84
locked$ = 88
newia$ = 92
lock$ = 96
ascb_addr$ = 100
new$ = 104
old$ = 108
lock_arn$ = 112
mainstor$ = 120
inst$ = 144
regs$ = 152
s390_obtain_cms_lock PROC

; 337  : {

$LN26:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 81 ec 88 00
	00 00		 sub	 rsp, 136		; 00000088H

; 338  :     int     b1, b2;                     /* Values of base field      */
; 339  :     VADR    effective_addr1,
; 340  :             effective_addr2;            /* Effective addresses       */
; 341  :     VADR    ascb_addr;                  /* Virtual address of ASCB   */
; 342  :     U32     hlhi_word;                  /* Highest lock held word    */
; 343  :     VADR    lit_addr;                   /* Virtual address of lock
; 344  :                                            interface table           */
; 345  :     VADR    lock_addr;                  /* Lock address              */
; 346  :     int     lock_arn;                   /* Lock access register      */
; 347  :     U32     lock;                       /* Lock value                */
; 348  :     VADR    newia;                      /* Unsuccessful branch addr  */
; 349  :     BYTE   *mainstor;                   /* mainstor address          */
; 350  :     U32     old;                        /* old value                 */
; 351  :     U32     new;                        /* new value                 */
; 352  :     U32     locked = 0;                 /* status of cmpxchg4 result */

  00011	c7 44 24 58 00
	00 00 00	 mov	 DWORD PTR locked$[rsp], 0

; 353  :     int     acc_mode = 0;               /* access mode to use        */

  00019	c7 44 24 34 00
	00 00 00	 mov	 DWORD PTR acc_mode$[rsp], 0

; 354  : 
; 355  :     SSE(inst, regs, b1, effective_addr1, b2, effective_addr2);

  00021	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR inst$[rsp]
  00029	48 83 c0 02	 add	 rax, 2
  0002d	48 8b c8	 mov	 rcx, rax
  00030	e8 00 00 00 00	 call	 fetch_fw_noswap
  00035	8b c8		 mov	 ecx, eax
  00037	e8 00 00 00 00	 call	 _byteswap_ulong
  0003c	89 44 24 40	 mov	 DWORD PTR temp$1[rsp], eax
  00040	8b 44 24 40	 mov	 eax, DWORD PTR temp$1[rsp]
  00044	25 ff 0f 00 00	 and	 eax, 4095		; 00000fffH
  00049	89 44 24 30	 mov	 DWORD PTR effective_addr2$[rsp], eax
  0004d	8b 44 24 40	 mov	 eax, DWORD PTR temp$1[rsp]
  00051	c1 e8 0c	 shr	 eax, 12
  00054	83 e0 0f	 and	 eax, 15
  00057	89 44 24 44	 mov	 DWORD PTR b2$[rsp], eax
  0005b	8b 44 24 40	 mov	 eax, DWORD PTR temp$1[rsp]
  0005f	c1 e8 10	 shr	 eax, 16
  00062	25 ff 0f 00 00	 and	 eax, 4095		; 00000fffH
  00067	89 44 24 38	 mov	 DWORD PTR effective_addr1$[rsp], eax
  0006b	8b 44 24 40	 mov	 eax, DWORD PTR temp$1[rsp]
  0006f	c1 e8 1c	 shr	 eax, 28
  00072	83 e0 0f	 and	 eax, 15
  00075	89 44 24 4c	 mov	 DWORD PTR b1$[rsp], eax
  00079	83 7c 24 4c 00	 cmp	 DWORD PTR b1$[rsp], 0
  0007e	74 3a		 je	 SHORT $LN8@s390_obtai
  00080	48 63 44 24 4c	 movsxd	 rax, DWORD PTR b1$[rsp]
  00085	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0008d	8b 84 c1 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax*8+640]
  00094	8b 4c 24 38	 mov	 ecx, DWORD PTR effective_addr1$[rsp]
  00098	03 c8		 add	 ecx, eax
  0009a	8b c1		 mov	 eax, ecx
  0009c	89 44 24 38	 mov	 DWORD PTR effective_addr1$[rsp], eax
  000a0	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  000a8	8b 80 90 00 00
	00		 mov	 eax, DWORD PTR [rax+144]
  000ae	8b 4c 24 38	 mov	 ecx, DWORD PTR effective_addr1$[rsp]
  000b2	23 c8		 and	 ecx, eax
  000b4	8b c1		 mov	 eax, ecx
  000b6	89 44 24 38	 mov	 DWORD PTR effective_addr1$[rsp], eax
$LN8@s390_obtai:
  000ba	83 7c 24 44 00	 cmp	 DWORD PTR b2$[rsp], 0
  000bf	74 3a		 je	 SHORT $LN9@s390_obtai
  000c1	48 63 44 24 44	 movsxd	 rax, DWORD PTR b2$[rsp]
  000c6	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  000ce	8b 84 c1 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax*8+640]
  000d5	8b 4c 24 30	 mov	 ecx, DWORD PTR effective_addr2$[rsp]
  000d9	03 c8		 add	 ecx, eax
  000db	8b c1		 mov	 eax, ecx
  000dd	89 44 24 30	 mov	 DWORD PTR effective_addr2$[rsp], eax
  000e1	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  000e9	8b 80 90 00 00
	00		 mov	 eax, DWORD PTR [rax+144]
  000ef	8b 4c 24 30	 mov	 ecx, DWORD PTR effective_addr2$[rsp]
  000f3	23 c8		 and	 ecx, eax
  000f5	8b c1		 mov	 eax, ecx
  000f7	89 44 24 30	 mov	 DWORD PTR effective_addr2$[rsp], eax
$LN9@s390_obtai:
$LN4@s390_obtai:
  000fb	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00103	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  00107	48 83 c0 06	 add	 rax, 6
  0010b	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00113	48 89 41 68	 mov	 QWORD PTR [rcx+104], rax
  00117	33 c0		 xor	 eax, eax
  00119	83 f8 06	 cmp	 eax, 6
  0011c	74 0f		 je	 SHORT $LN10@s390_obtai
  0011e	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00126	c6 80 9a 00 00
	00 06		 mov	 BYTE PTR [rax+154], 6
$LN10@s390_obtai:
  0012d	33 c0		 xor	 eax, eax
  0012f	85 c0		 test	 eax, eax
  00131	75 c8		 jne	 SHORT $LN4@s390_obtai

; 356  :     PER_ZEROADDR_XCHECK2( regs, b1, b2 );
; 357  : 
; 358  :     GUEST_CHECK( );

  00133	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0013b	0f b6 40 7a	 movzx	 eax, BYTE PTR [rax+122]
  0013f	83 e0 01	 and	 eax, 1
  00142	85 c0		 test	 eax, eax
  00144	74 50		 je	 SHORT $LN11@s390_obtai
  00146	b8 08 00 00 00	 mov	 eax, 8
  0014b	48 6b c0 07	 imul	 rax, rax, 7
  0014f	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00157	8b 84 01 00 06
	00 00		 mov	 eax, DWORD PTR [rcx+rax+1536]
  0015e	25 04 00 00 40	 and	 eax, 1073741828		; 40000004H
  00163	83 f8 04	 cmp	 eax, 4
  00166	74 2e		 je	 SHORT $LN12@s390_obtai
  00168	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00170	0f b6 40 7a	 movzx	 eax, BYTE PTR [rax+122]
  00174	83 e0 01	 and	 eax, 1
  00177	85 c0		 test	 eax, eax
  00179	74 1b		 je	 SHORT $LN13@s390_obtai
  0017b	ba 02 00 00 00	 mov	 edx, 2
  00180	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00188	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00190	ff 90 20 0d 00
	00		 call	 QWORD PTR [rax+3360]
$LN13@s390_obtai:
$LN12@s390_obtai:
$LN11@s390_obtai:

; 359  : 
; 360  :     /* Specification exception if operands are not on word boundary */
; 361  :     if ((effective_addr1 & 0x00000003) || (effective_addr2 & 0x00000003))

  00196	8b 44 24 38	 mov	 eax, DWORD PTR effective_addr1$[rsp]
  0019a	83 e0 03	 and	 eax, 3
  0019d	85 c0		 test	 eax, eax
  0019f	75 0b		 jne	 SHORT $LN15@s390_obtai
  001a1	8b 44 24 30	 mov	 eax, DWORD PTR effective_addr2$[rsp]
  001a5	83 e0 03	 and	 eax, 3
  001a8	85 c0		 test	 eax, eax
  001aa	74 12		 je	 SHORT $LN14@s390_obtai
$LN15@s390_obtai:

; 362  :         ARCH_DEP(program_interrupt) (regs, PGM_SPECIFICATION_EXCEPTION);

  001ac	ba 06 00 00 00	 mov	 edx, 6
  001b1	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  001b9	e8 00 00 00 00	 call	 s390_program_interrupt
$LN14@s390_obtai:

; 363  : 
; 364  :     PERFORM_SERIALIZATION(regs);

  001be	0f ae f0	 mfence

; 365  : 
; 366  :     /* General register 11 contains the lock address */
; 367  :     lock_addr = regs->GR_L(11) & ADDRESS_MAXWRAP(regs);

  001c1	b8 08 00 00 00	 mov	 eax, 8
  001c6	48 6b c0 0b	 imul	 rax, rax, 11
  001ca	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  001d2	48 8b 94 24 98
	00 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  001da	8b 92 90 00 00
	00		 mov	 edx, DWORD PTR [rdx+144]
  001e0	8b 84 01 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax+640]
  001e7	23 c2		 and	 eax, edx
  001e9	89 44 24 50	 mov	 DWORD PTR lock_addr$[rsp], eax

; 368  :     lock_arn = 11;

  001ed	c7 44 24 70 0b
	00 00 00	 mov	 DWORD PTR lock_arn$[rsp], 11

; 369  : 
; 370  :     /* MAINLOCK may be required if cmpxchg assists unavailable */
; 371  :     OBTAIN_MAINLOCK(regs);
; 372  :     {
; 373  :         if (ACCESS_REGISTER_MODE(&regs->psw))

  001f5	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  001fd	0f b6 40 7b	 movzx	 eax, BYTE PTR [rax+123]
  00201	83 f8 40	 cmp	 eax, 64			; 00000040H
  00204	75 08		 jne	 SHORT $LN16@s390_obtai

; 374  :             acc_mode = USE_PRIMARY_SPACE;

  00206	c7 44 24 34 fd
	ff ff ff	 mov	 DWORD PTR acc_mode$[rsp], -3
$LN16@s390_obtai:

; 375  : 
; 376  :         /* Load ASCB address from first operand location */
; 377  :         ascb_addr = ARCH_DEP(vfetch4) ( effective_addr1, acc_mode, regs );

  0020e	4c 8b 84 24 98
	00 00 00	 mov	 r8, QWORD PTR regs$[rsp]
  00216	8b 54 24 34	 mov	 edx, DWORD PTR acc_mode$[rsp]
  0021a	8b 4c 24 38	 mov	 ecx, DWORD PTR effective_addr1$[rsp]
  0021e	e8 00 00 00 00	 call	 s390_vfetch4
  00223	89 44 24 64	 mov	 DWORD PTR ascb_addr$[rsp], eax

; 378  : 
; 379  :         /* Load locks held bits from second operand location */
; 380  :         hlhi_word = ARCH_DEP(vfetch4) ( effective_addr2, acc_mode, regs );

  00227	4c 8b 84 24 98
	00 00 00	 mov	 r8, QWORD PTR regs$[rsp]
  0022f	8b 54 24 34	 mov	 edx, DWORD PTR acc_mode$[rsp]
  00233	8b 4c 24 30	 mov	 ecx, DWORD PTR effective_addr2$[rsp]
  00237	e8 00 00 00 00	 call	 s390_vfetch4
  0023c	89 44 24 3c	 mov	 DWORD PTR hlhi_word$[rsp], eax

; 381  : 
; 382  :         /* Fetch the lock addressed by general register 11 */
; 383  :         lock = ARCH_DEP(vfetch4) ( lock_addr, acc_mode, regs );

  00240	4c 8b 84 24 98
	00 00 00	 mov	 r8, QWORD PTR regs$[rsp]
  00248	8b 54 24 34	 mov	 edx, DWORD PTR acc_mode$[rsp]
  0024c	8b 4c 24 50	 mov	 ecx, DWORD PTR lock_addr$[rsp]
  00250	e8 00 00 00 00	 call	 s390_vfetch4
  00255	89 44 24 60	 mov	 DWORD PTR lock$[rsp], eax

; 384  : 
; 385  :         /* Validate that the address space meets criteria to obtain the CMS lock:
; 386  :              the target lock word pointed to by GR11 must be 0,
; 387  :              the LOCAL lock *must* be held on this CPU,
; 388  :              and the CMS lock must *not* be held on this CPU.  */
; 389  :         if (lock == 0
; 390  :             && (hlhi_word & (PSALCLLI | PSACMSLI)) == PSALCLLI)

  00259	83 7c 24 60 00	 cmp	 DWORD PTR lock$[rsp], 0
  0025e	0f 85 91 00 00
	00		 jne	 $LN17@s390_obtai
  00264	8b 44 24 3c	 mov	 eax, DWORD PTR hlhi_word$[rsp]
  00268	83 e0 03	 and	 eax, 3
  0026b	83 f8 01	 cmp	 eax, 1
  0026e	0f 85 81 00 00
	00		 jne	 $LN17@s390_obtai

; 391  :         {
; 392  :             /* Get mainstor address of lock word */
; 393  :             mainstor = MADDRL (lock_addr, 4, b2, regs, ACCTYPE_WRITE, regs->psw.pkey);

  00274	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0027c	0f b6 40 79	 movzx	 eax, BYTE PTR [rax+121]
  00280	88 44 24 28	 mov	 BYTE PTR [rsp+40], al
  00284	c7 44 24 20 02
	00 00 00	 mov	 DWORD PTR [rsp+32], 2
  0028c	4c 8b 8c 24 98
	00 00 00	 mov	 r9, QWORD PTR regs$[rsp]
  00294	44 8b 44 24 44	 mov	 r8d, DWORD PTR b2$[rsp]
  00299	ba 04 00 00 00	 mov	 edx, 4
  0029e	8b 4c 24 50	 mov	 ecx, DWORD PTR lock_addr$[rsp]
  002a2	e8 00 00 00 00	 call	 s390_maddr_l
  002a7	48 89 44 24 78	 mov	 QWORD PTR mainstor$[rsp], rax

; 394  : 
; 395  :             /* The lock word should contain 0; use this as our compare value.
; 396  :             Swap in the ASCB address from instruction operand 1            */
; 397  :             old = 0;

  002ac	c7 44 24 6c 00
	00 00 00	 mov	 DWORD PTR old$[rsp], 0

; 398  :             new = CSWAP32(ascb_addr);

  002b4	8b 4c 24 64	 mov	 ecx, DWORD PTR ascb_addr$[rsp]
  002b8	e8 00 00 00 00	 call	 _byteswap_ulong
  002bd	89 44 24 68	 mov	 DWORD PTR new$[rsp], eax

; 399  : 
; 400  :             /* Try exchanging values; cmpxchg4 returns 0=success, !0=failure */
; 401  :             locked = !cmpxchg4( &old, new, mainstor );

  002c1	4c 8b 44 24 78	 mov	 r8, QWORD PTR mainstor$[rsp]
  002c6	8b 54 24 68	 mov	 edx, DWORD PTR new$[rsp]
  002ca	48 8d 4c 24 6c	 lea	 rcx, QWORD PTR old$[rsp]
  002cf	e8 00 00 00 00	 call	 cmpxchg4_x86
  002d4	0f b6 c0	 movzx	 eax, al
  002d7	85 c0		 test	 eax, eax
  002d9	75 0a		 jne	 SHORT $LN24@s390_obtai
  002db	c7 44 24 54 01
	00 00 00	 mov	 DWORD PTR tv195[rsp], 1
  002e3	eb 08		 jmp	 SHORT $LN25@s390_obtai
$LN24@s390_obtai:
  002e5	c7 44 24 54 00
	00 00 00	 mov	 DWORD PTR tv195[rsp], 0
$LN25@s390_obtai:
  002ed	8b 44 24 54	 mov	 eax, DWORD PTR tv195[rsp]
  002f1	89 44 24 58	 mov	 DWORD PTR locked$[rsp], eax
$LN17@s390_obtai:

; 402  :         }
; 403  : 
; 404  :         if (locked)

  002f5	83 7c 24 58 00	 cmp	 DWORD PTR locked$[rsp], 0
  002fa	74 60		 je	 SHORT $LN18@s390_obtai

; 405  :         {
; 406  :             /* Store the unchanged value into the second operand to
; 407  :             ensure suppression in the event of an access exception */
; 408  :             ARCH_DEP(vstore4) ( hlhi_word, effective_addr2, acc_mode, regs );

  002fc	4c 8b 8c 24 98
	00 00 00	 mov	 r9, QWORD PTR regs$[rsp]
  00304	44 8b 44 24 34	 mov	 r8d, DWORD PTR acc_mode$[rsp]
  00309	8b 54 24 30	 mov	 edx, DWORD PTR effective_addr2$[rsp]
  0030d	8b 4c 24 3c	 mov	 ecx, DWORD PTR hlhi_word$[rsp]
  00311	e8 00 00 00 00	 call	 s390_vstore4

; 409  : 
; 410  :             /* Set the CMS lock held bit in the second operand */
; 411  :             hlhi_word |= PSACMSLI;

  00316	8b 44 24 3c	 mov	 eax, DWORD PTR hlhi_word$[rsp]
  0031a	83 c8 02	 or	 eax, 2
  0031d	89 44 24 3c	 mov	 DWORD PTR hlhi_word$[rsp], eax

; 412  :             ARCH_DEP(vstore4) ( hlhi_word, effective_addr2, acc_mode, regs );

  00321	4c 8b 8c 24 98
	00 00 00	 mov	 r9, QWORD PTR regs$[rsp]
  00329	44 8b 44 24 34	 mov	 r8d, DWORD PTR acc_mode$[rsp]
  0032e	8b 54 24 30	 mov	 edx, DWORD PTR effective_addr2$[rsp]
  00332	8b 4c 24 3c	 mov	 ecx, DWORD PTR hlhi_word$[rsp]
  00336	e8 00 00 00 00	 call	 s390_vstore4

; 413  : 
; 414  :             /* Set register 13 to zero to indicate lock obtained */
; 415  :             regs->GR_L(13) = 0;

  0033b	b8 08 00 00 00	 mov	 eax, 8
  00340	48 6b c0 0d	 imul	 rax, rax, 13
  00344	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0034c	c7 84 01 80 02
	00 00 00 00 00
	00		 mov	 DWORD PTR [rcx+rax+640], 0

; 416  :         }

  00357	e9 76 01 00 00	 jmp	 $LN19@s390_obtai
$LN18@s390_obtai:

; 417  :         else
; 418  :         {
; 419  :             /* Fetch the lock interface table address from the
; 420  :             second word of the second operand, and load the
; 421  :             new instruction address and amode from LITOCMS */
; 422  :             lit_addr = ARCH_DEP(vfetch4) ( effective_addr2 + 4, acc_mode, regs ) + LITOCMS;

  0035c	8b 44 24 30	 mov	 eax, DWORD PTR effective_addr2$[rsp]
  00360	83 c0 04	 add	 eax, 4
  00363	4c 8b 84 24 98
	00 00 00	 mov	 r8, QWORD PTR regs$[rsp]
  0036b	8b 54 24 34	 mov	 edx, DWORD PTR acc_mode$[rsp]
  0036f	8b c8		 mov	 ecx, eax
  00371	e8 00 00 00 00	 call	 s390_vfetch4
  00376	83 c0 f8	 add	 eax, -8			; fffffff8H
  00379	89 44 24 48	 mov	 DWORD PTR lit_addr$[rsp], eax

; 423  :             lit_addr &= ADDRESS_MAXWRAP(regs);

  0037d	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00385	8b 80 90 00 00
	00		 mov	 eax, DWORD PTR [rax+144]
  0038b	8b 4c 24 48	 mov	 ecx, DWORD PTR lit_addr$[rsp]
  0038f	23 c8		 and	 ecx, eax
  00391	8b c1		 mov	 eax, ecx
  00393	89 44 24 48	 mov	 DWORD PTR lit_addr$[rsp], eax

; 424  :             newia = ARCH_DEP(vfetch4) ( lit_addr, acc_mode, regs );

  00397	4c 8b 84 24 98
	00 00 00	 mov	 r8, QWORD PTR regs$[rsp]
  0039f	8b 54 24 34	 mov	 edx, DWORD PTR acc_mode$[rsp]
  003a3	8b 4c 24 48	 mov	 ecx, DWORD PTR lit_addr$[rsp]
  003a7	e8 00 00 00 00	 call	 s390_vfetch4
  003ac	89 44 24 5c	 mov	 DWORD PTR newia$[rsp], eax

; 425  : 
; 426  :             /* Save the link information in register 12 */
; 427  :             regs->GR_L(12) = PSW_IA_FROM_IP(regs, 0);

  003b0	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  003b8	8b 80 10 02 00
	00		 mov	 eax, DWORD PTR [rax+528]
  003be	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  003c6	48 8b 94 24 98
	00 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  003ce	48 8b 92 00 02
	00 00		 mov	 rdx, QWORD PTR [rdx+512]
  003d5	48 8b 49 68	 mov	 rcx, QWORD PTR [rcx+104]
  003d9	48 2b ca	 sub	 rcx, rdx
  003dc	48 03 c1	 add	 rax, rcx
  003df	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  003e7	8b 89 90 00 00
	00		 mov	 ecx, DWORD PTR [rcx+144]
  003ed	48 23 c1	 and	 rax, rcx
  003f0	b9 08 00 00 00	 mov	 ecx, 8
  003f5	48 6b c9 0c	 imul	 rcx, rcx, 12
  003f9	48 8b 94 24 98
	00 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  00401	89 84 0a 80 02
	00 00		 mov	 DWORD PTR [rdx+rcx+640], eax

; 428  : 
; 429  :             /* Copy LITOCMS into register 13 to signify obtain failure */
; 430  :             regs->GR_L(13) = newia;

  00408	b8 08 00 00 00	 mov	 eax, 8
  0040d	48 6b c0 0d	 imul	 rax, rax, 13
  00411	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00419	8b 54 24 5c	 mov	 edx, DWORD PTR newia$[rsp]
  0041d	89 94 01 80 02
	00 00		 mov	 DWORD PTR [rcx+rax+640], edx
$LN7@s390_obtai:

; 431  : 
; 432  :             /* Update the PSW instruction address */
; 433  :             SET_PSW_IA_AND_MAYBE_IP(regs, newia);

  00424	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0042c	8b 80 90 00 00
	00		 mov	 eax, DWORD PTR [rax+144]
  00432	8b 4c 24 5c	 mov	 ecx, DWORD PTR newia$[rsp]
  00436	23 c8		 and	 ecx, eax
  00438	8b c1		 mov	 eax, ecx
  0043a	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00442	89 81 88 00 00
	00		 mov	 DWORD PTR [rcx+136], eax
  00448	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00450	48 83 b8 08 02
	00 00 00	 cmp	 QWORD PTR [rax+520], 0
  00458	74 6e		 je	 SHORT $LN20@s390_obtai
  0045a	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00462	8b 80 88 00 00
	00		 mov	 eax, DWORD PTR [rax+136]
  00468	25 01 f0 ff 7f	 and	 eax, 2147479553		; 7ffff001H
  0046d	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00475	39 81 10 02 00
	00		 cmp	 DWORD PTR [rcx+528], eax
  0047b	75 38		 jne	 SHORT $LN21@s390_obtai
  0047d	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00485	8b 80 88 00 00
	00		 mov	 eax, DWORD PTR [rax+136]
  0048b	25 ff 0f 00 00	 and	 eax, 4095		; 00000fffH
  00490	8b c0		 mov	 eax, eax
  00492	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0049a	48 8b 89 00 02
	00 00		 mov	 rcx, QWORD PTR [rcx+512]
  004a1	48 0b c8	 or	 rcx, rax
  004a4	48 8b c1	 mov	 rax, rcx
  004a7	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  004af	48 89 41 68	 mov	 QWORD PTR [rcx+104], rax
  004b3	eb 13		 jmp	 SHORT $LN22@s390_obtai
$LN21@s390_obtai:
  004b5	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  004bd	48 c7 80 08 02
	00 00 00 00 00
	00		 mov	 QWORD PTR [rax+520], 0
$LN22@s390_obtai:
$LN20@s390_obtai:
  004c8	33 c0		 xor	 eax, eax
  004ca	85 c0		 test	 eax, eax
  004cc	0f 85 52 ff ff
	ff		 jne	 $LN7@s390_obtai
$LN19@s390_obtai:

; 434  :         }
; 435  :     }
; 436  :     RELEASE_MAINLOCK(regs);
; 437  : 
; 438  :     PERFORM_SERIALIZATION(regs);

  004d2	0f ae f0	 mfence

; 439  : 
; 440  : } /* end function obtain_cms_lock */

  004d5	48 81 c4 88 00
	00 00		 add	 rsp, 136		; 00000088H
  004dc	c3		 ret	 0
s390_obtain_cms_lock ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\assist.c
_TEXT	SEGMENT
entrycode$ = 48
frrnext$ = 52
frrstak$ = 56
cr_ptr$ = 60
size$ = 64
len$ = 68
clear_vaddr$ = 72
r2$ = 76
i$1 = 80
r1$ = 84
frrsize$ = 88
frrcurr$ = 92
frrlast$ = 96
newia$ = 100
frrparm$ = 104
cr34$2 = 112
__$ArrayPad$ = 120
inst$ = 144
regs$ = 152
s390_add_frr PROC

; 680  : {

$LN23:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 81 ec 88 00
	00 00		 sub	 rsp, 136		; 00000088H
  00011	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00018	48 33 c4	 xor	 rax, rsp
  0001b	48 89 44 24 78	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 681  : /*                          ADDFRR
; 682  : 
; 683  :         Add new Functional-Recovery-Routine Stack entry
; 684  : 
; 685  :    What little documentation that exists for this feature can be found
; 686  :    on page 9 of IBM System/370 Assists for MVS, GA22-7079-1 (the text
; 687  :    of which is copied verbatim further below), which can be found on
; 688  :    Bitsavers at:
; 689  : 
; 690  :       * https://bitsavers.org/pdf/ibm/370/MVS/GA22-7079-1_IBM_System_370_Assists_for_MVS_2nd_ed_198110.pdf
; 691  : 
; 692  :    The rest of the documentation regarding how it works is found in the
; 693  :    way MVS itself manages the FRR stack. The assist feature is part of
; 694  :    the 3033 Extensions.
; 695  : 
; 696  :    r1 contains an entry value designating the type of FRR and action to
; 697  :    take by this assist. r2 contains the address of the FRR to be added.
; 698  : */
; 699  : /*                          ADDFRR
; 700  : 
; 701  :     "A new entry is added to the top of the current functional-
; 702  :      recovery-routine (FRR) stack. The entry is initialized with
; 703  :      values provided in general registers and with the PSW S bit
; 704  :      (bit 16)."
; 705  : 
; 706  :     "Optionally, the contents of control registers 3 and 4 are
; 707  :      saved in an entry in a separate table."
; 708  : 
; 709  :     "The general register designated by the r2 field provides the
; 710  :      logical address of the FRR entry point."
; 711  : 
; 712  :     "Before instruction execution, the general register designated
; 713  :      by the r1 field provides three bytes that are stored in the
; 714  :      FRR entry and whose value determines if control registers 3
; 715  :      and 4 are to be stored as well. When instruction execution is
; 716  :      completed, the register designated by r1 contains the logical
; 717  :      address of the six-word work area within the new, current
; 718  :      FRR-stack entry."
; 719  : 
; 720  :     "Logical location 380 hex contains the logical address of the
; 721  :      stack-table header. The stack-table header contains (1) a logical
; 722  :      address which is 32 less than the address of the first dynamic
; 723  :      entry in the stack table, (2) the logical address of the last
; 724  :      entry in the stack table, and (3) the logical address of the
; 725  :      current stack-table entry."
; 726  : 
; 727  :     "At an offset from the beginning of the stack-table header is
; 728  :      found a table of stack-entry-extension entries. Optionally,
; 729  :      the contents of control registers 3 and 4 are saved in an
; 730  :      extension entry. One extension entry corresponds to each entry
; 731  :      in the stack table. The offset to the table of extension entries,
; 732  :      and the encoded length of an extension entry, are found in the
; 733  :      word at logical location BA8 hex."
; 734  : 
; 735  :     Condition Code: The code remains unchanged.
; 736  : 
; 737  :     Program Exceptions:
; 738  :     Access (storage operands)
; 739  :     Operation (when the instruction is not installed)
; 740  :     Privileged operation
; 741  :     Specification
; 742  : */
; 743  : 
; 744  : int     r1, r2;
; 745  : VADR    frrstak;
; 746  : VADR    frrparm;
; 747  : VADR    frrlast;
; 748  : U32     frrsize;
; 749  : VADR    frrcurr;
; 750  : VADR    frrnext;
; 751  : VADR    newia;
; 752  : VADR    cr_ptr;
; 753  : BYTE    entrycode;
; 754  : U32     size, len;
; 755  : VADR    clear_vaddr;
; 756  : static const BYTE zeros[256] = {0};
; 757  : 
; 758  : #define FRRSPARM    0x08
; 759  : 
; 760  : /* Entry code bits in r1 */
; 761  : #define EUT         0x80
; 762  : #define FULLXM      0x08
; 763  : #define PRIMARY     0x04
; 764  : #define LOCAL       0x02
; 765  : #define GLOBAL      0x01
; 766  : #define HOME        0x00
; 767  : 
; 768  :     RRE( inst, regs, r1, r2 );

  00020	b8 01 00 00 00	 mov	 eax, 1
  00025	48 6b c0 03	 imul	 rax, rax, 3
  00029	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR inst$[rsp]
  00031	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00035	89 44 24 50	 mov	 DWORD PTR i$1[rsp], eax
  00039	8b 44 24 50	 mov	 eax, DWORD PTR i$1[rsp]
  0003d	83 e0 0f	 and	 eax, 15
  00040	89 44 24 4c	 mov	 DWORD PTR r2$[rsp], eax
  00044	8b 44 24 50	 mov	 eax, DWORD PTR i$1[rsp]
  00048	c1 f8 04	 sar	 eax, 4
  0004b	83 e0 0f	 and	 eax, 15
  0004e	89 44 24 54	 mov	 DWORD PTR r1$[rsp], eax
$LN4@s390_add_f:
  00052	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0005a	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  0005e	48 83 c0 04	 add	 rax, 4
  00062	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0006a	48 89 41 68	 mov	 QWORD PTR [rcx+104], rax
  0006e	33 c0		 xor	 eax, eax
  00070	83 f8 04	 cmp	 eax, 4
  00073	74 0f		 je	 SHORT $LN10@s390_add_f
  00075	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0007d	c6 80 9a 00 00
	00 04		 mov	 BYTE PTR [rax+154], 4
$LN10@s390_add_f:
  00084	33 c0		 xor	 eax, eax
  00086	85 c0		 test	 eax, eax
  00088	75 c8		 jne	 SHORT $LN4@s390_add_f

; 769  : 
; 770  :     PRIV_CHECK( regs );

  0008a	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00092	0f b6 40 7a	 movzx	 eax, BYTE PTR [rax+122]
  00096	83 e0 01	 and	 eax, 1
  00099	85 c0		 test	 eax, eax
  0009b	74 1b		 je	 SHORT $LN11@s390_add_f
  0009d	ba 02 00 00 00	 mov	 edx, 2
  000a2	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  000aa	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  000b2	ff 90 20 0d 00
	00		 call	 QWORD PTR [rax+3360]
$LN11@s390_add_f:

; 771  : 
; 772  :     /* Obtain needed values from the FRR stack pointers */
; 773  :     frrstak = ARCH_DEP( vfetch4 )( PSACSTK,                                  USE_PRIMARY_SPACE, regs ) & ADDRESS_MAXWRAP( regs );

  000b8	4c 8b 84 24 98
	00 00 00	 mov	 r8, QWORD PTR regs$[rsp]
  000c0	ba fd ff ff ff	 mov	 edx, -3
  000c5	b9 80 03 00 00	 mov	 ecx, 896		; 00000380H
  000ca	e8 00 00 00 00	 call	 s390_vfetch4
  000cf	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  000d7	23 81 90 00 00
	00		 and	 eax, DWORD PTR [rcx+144]
  000dd	89 44 24 38	 mov	 DWORD PTR frrstak$[rsp], eax

; 774  :     frrparm = ARCH_DEP( vfetch4 )( (frrstak +  0),                           USE_PRIMARY_SPACE, regs ) & ADDRESS_MAXWRAP( regs );

  000e1	4c 8b 84 24 98
	00 00 00	 mov	 r8, QWORD PTR regs$[rsp]
  000e9	ba fd ff ff ff	 mov	 edx, -3
  000ee	8b 4c 24 38	 mov	 ecx, DWORD PTR frrstak$[rsp]
  000f2	e8 00 00 00 00	 call	 s390_vfetch4
  000f7	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  000ff	23 81 90 00 00
	00		 and	 eax, DWORD PTR [rcx+144]
  00105	89 44 24 68	 mov	 DWORD PTR frrparm$[rsp], eax

; 775  :     frrlast = ARCH_DEP( vfetch4 )( (frrstak +  4) & ADDRESS_MAXWRAP( regs ), USE_PRIMARY_SPACE, regs ) & ADDRESS_MAXWRAP( regs );

  00109	8b 44 24 38	 mov	 eax, DWORD PTR frrstak$[rsp]
  0010d	83 c0 04	 add	 eax, 4
  00110	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00118	23 81 90 00 00
	00		 and	 eax, DWORD PTR [rcx+144]
  0011e	4c 8b 84 24 98
	00 00 00	 mov	 r8, QWORD PTR regs$[rsp]
  00126	ba fd ff ff ff	 mov	 edx, -3
  0012b	8b c8		 mov	 ecx, eax
  0012d	e8 00 00 00 00	 call	 s390_vfetch4
  00132	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0013a	23 81 90 00 00
	00		 and	 eax, DWORD PTR [rcx+144]
  00140	89 44 24 60	 mov	 DWORD PTR frrlast$[rsp], eax

; 776  :     frrsize = ARCH_DEP( vfetch4 )( (frrstak +  8) & ADDRESS_MAXWRAP( regs ), USE_PRIMARY_SPACE, regs );

  00144	8b 44 24 38	 mov	 eax, DWORD PTR frrstak$[rsp]
  00148	83 c0 08	 add	 eax, 8
  0014b	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00153	23 81 90 00 00
	00		 and	 eax, DWORD PTR [rcx+144]
  00159	4c 8b 84 24 98
	00 00 00	 mov	 r8, QWORD PTR regs$[rsp]
  00161	ba fd ff ff ff	 mov	 edx, -3
  00166	8b c8		 mov	 ecx, eax
  00168	e8 00 00 00 00	 call	 s390_vfetch4
  0016d	89 44 24 58	 mov	 DWORD PTR frrsize$[rsp], eax

; 777  :     frrcurr = ARCH_DEP( vfetch4 )( (frrstak + 12) & ADDRESS_MAXWRAP( regs ), USE_PRIMARY_SPACE, regs ) & ADDRESS_MAXWRAP( regs );

  00171	8b 44 24 38	 mov	 eax, DWORD PTR frrstak$[rsp]
  00175	83 c0 0c	 add	 eax, 12
  00178	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00180	23 81 90 00 00
	00		 and	 eax, DWORD PTR [rcx+144]
  00186	4c 8b 84 24 98
	00 00 00	 mov	 r8, QWORD PTR regs$[rsp]
  0018e	ba fd ff ff ff	 mov	 edx, -3
  00193	8b c8		 mov	 ecx, eax
  00195	e8 00 00 00 00	 call	 s390_vfetch4
  0019a	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  001a2	23 81 90 00 00
	00		 and	 eax, DWORD PTR [rcx+144]
  001a8	89 44 24 5c	 mov	 DWORD PTR frrcurr$[rsp], eax

; 778  :     frrnext = (frrcurr + frrsize) & ADDRESS_MAXWRAP( regs );

  001ac	8b 44 24 58	 mov	 eax, DWORD PTR frrsize$[rsp]
  001b0	8b 4c 24 5c	 mov	 ecx, DWORD PTR frrcurr$[rsp]
  001b4	03 c8		 add	 ecx, eax
  001b6	8b c1		 mov	 eax, ecx
  001b8	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  001c0	23 81 90 00 00
	00		 and	 eax, DWORD PTR [rcx+144]
  001c6	89 44 24 34	 mov	 DWORD PTR frrnext$[rsp], eax

; 779  : 
; 780  :     /* Determine if FRR stack is full. If yes, then
; 781  :        branch to the system supplied code at PSALFSCC
; 782  :     */
; 783  :     if (frrnext > frrlast)

  001ca	8b 44 24 60	 mov	 eax, DWORD PTR frrlast$[rsp]
  001ce	39 44 24 34	 cmp	 DWORD PTR frrnext$[rsp], eax
  001d2	0f 86 dc 00 00
	00		 jbe	 $LN12@s390_add_f

; 784  :     {
; 785  :         newia = ARCH_DEP( vfetch4 )( PSALSFCC, USE_PRIMARY_SPACE, regs ) & ADDRESS_MAXWRAP( regs );

  001d8	4c 8b 84 24 98
	00 00 00	 mov	 r8, QWORD PTR regs$[rsp]
  001e0	ba fd ff ff ff	 mov	 edx, -3
  001e5	b9 f4 03 00 00	 mov	 ecx, 1012		; 000003f4H
  001ea	e8 00 00 00 00	 call	 s390_vfetch4
  001ef	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  001f7	23 81 90 00 00
	00		 and	 eax, DWORD PTR [rcx+144]
  001fd	89 44 24 64	 mov	 DWORD PTR newia$[rsp], eax
$LN7@s390_add_f:

; 786  :         SET_PSW_IA_AND_MAYBE_IP( regs, newia );

  00201	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00209	8b 80 90 00 00
	00		 mov	 eax, DWORD PTR [rax+144]
  0020f	8b 4c 24 64	 mov	 ecx, DWORD PTR newia$[rsp]
  00213	23 c8		 and	 ecx, eax
  00215	8b c1		 mov	 eax, ecx
  00217	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0021f	89 81 88 00 00
	00		 mov	 DWORD PTR [rcx+136], eax
  00225	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0022d	48 83 b8 08 02
	00 00 00	 cmp	 QWORD PTR [rax+520], 0
  00235	74 6e		 je	 SHORT $LN13@s390_add_f
  00237	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0023f	8b 80 88 00 00
	00		 mov	 eax, DWORD PTR [rax+136]
  00245	25 01 f0 ff 7f	 and	 eax, 2147479553		; 7ffff001H
  0024a	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00252	39 81 10 02 00
	00		 cmp	 DWORD PTR [rcx+528], eax
  00258	75 38		 jne	 SHORT $LN14@s390_add_f
  0025a	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00262	8b 80 88 00 00
	00		 mov	 eax, DWORD PTR [rax+136]
  00268	25 ff 0f 00 00	 and	 eax, 4095		; 00000fffH
  0026d	8b c0		 mov	 eax, eax
  0026f	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00277	48 8b 89 00 02
	00 00		 mov	 rcx, QWORD PTR [rcx+512]
  0027e	48 0b c8	 or	 rcx, rax
  00281	48 8b c1	 mov	 rax, rcx
  00284	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0028c	48 89 41 68	 mov	 QWORD PTR [rcx+104], rax
  00290	eb 13		 jmp	 SHORT $LN15@s390_add_f
$LN14@s390_add_f:
  00292	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0029a	48 c7 80 08 02
	00 00 00 00 00
	00		 mov	 QWORD PTR [rax+520], 0
$LN15@s390_add_f:
$LN13@s390_add_f:
  002a5	33 c0		 xor	 eax, eax
  002a7	85 c0		 test	 eax, eax
  002a9	0f 85 52 ff ff
	ff		 jne	 $LN7@s390_add_f

; 787  :         return;

  002af	e9 ea 02 00 00	 jmp	 $LN1@s390_add_f
$LN12@s390_add_f:

; 788  :     }
; 789  : 
; 790  :     /* Perform exactly one of the following three functions based on the entry code from r1 */
; 791  :     entrycode = regs->GR_LHLCL( r1 );

  002b4	48 63 44 24 54	 movsxd	 rax, DWORD PTR r1$[rsp]
  002b9	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  002c1	0f b6 84 c1 80
	02 00 00	 movzx	 eax, BYTE PTR [rcx+rax*8+640]
  002c9	88 44 24 30	 mov	 BYTE PTR entrycode$[rsp], al

; 792  : 
; 793  :     /*  1. SETFRR  A,MODE=HOME (no LOCAL/GLOBAL or EUT specification) */
; 794  : 
; 795  :     if (entrycode == HOME)

  002cd	0f b6 44 24 30	 movzx	 eax, BYTE PTR entrycode$[rsp]
  002d2	85 c0		 test	 eax, eax
  002d4	75 30		 jne	 SHORT $LN16@s390_add_f

; 796  :     {
; 797  :         /* Set the FRR entry point from r2 in the stack */
; 798  :         ARCH_DEP( vstore4 )( regs->GR_L(r2), frrnext, USE_PRIMARY_SPACE, regs );

  002d6	48 63 44 24 4c	 movsxd	 rax, DWORD PTR r2$[rsp]
  002db	4c 8b 8c 24 98
	00 00 00	 mov	 r9, QWORD PTR regs$[rsp]
  002e3	41 b8 fd ff ff
	ff		 mov	 r8d, -3
  002e9	8b 54 24 34	 mov	 edx, DWORD PTR frrnext$[rsp]
  002ed	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  002f5	8b 8c c1 80 02
	00 00		 mov	 ecx, DWORD PTR [rcx+rax*8+640]
  002fc	e8 00 00 00 00	 call	 s390_vstore4

; 799  :     }

  00301	e9 99 01 00 00	 jmp	 $LN17@s390_add_f
$LN16@s390_add_f:

; 800  : 
; 801  :     /*  2. SETFRR A,MODE=(HOME, with any combination of LOCAL or GLOBAL or EUT=YES.  */
; 802  : 
; 803  :     else if ((!(entrycode & (FULLXM + PRIMARY))) && (entrycode & (EUT + GLOBAL + LOCAL)))

  00306	0f b6 44 24 30	 movzx	 eax, BYTE PTR entrycode$[rsp]
  0030b	83 e0 0c	 and	 eax, 12
  0030e	85 c0		 test	 eax, eax
  00310	75 72		 jne	 SHORT $LN18@s390_add_f
  00312	0f b6 44 24 30	 movzx	 eax, BYTE PTR entrycode$[rsp]
  00317	25 83 00 00 00	 and	 eax, 131		; 00000083H
  0031c	85 c0		 test	 eax, eax
  0031e	74 64		 je	 SHORT $LN18@s390_add_f

; 804  :     {
; 805  :         /* Set the FRR entry point from r2 in the stack */
; 806  :         ARCH_DEP( vstore4 )( regs->GR_L(r2) | 0x00000001, frrnext, USE_PRIMARY_SPACE, regs );

  00320	48 63 44 24 4c	 movsxd	 rax, DWORD PTR r2$[rsp]
  00325	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0032d	8b 84 c1 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax*8+640]
  00334	83 c8 01	 or	 eax, 1
  00337	4c 8b 8c 24 98
	00 00 00	 mov	 r9, QWORD PTR regs$[rsp]
  0033f	41 b8 fd ff ff
	ff		 mov	 r8d, -3
  00345	8b 54 24 34	 mov	 edx, DWORD PTR frrnext$[rsp]
  00349	8b c8		 mov	 ecx, eax
  0034b	e8 00 00 00 00	 call	 s390_vstore4

; 807  : 
; 808  :         /* The entry code is stored in the FRR stack */
; 809  :         ARCH_DEP( vstoreb )( entrycode, (frrnext + 7) & ADDRESS_MAXWRAP( regs ), USE_PRIMARY_SPACE, regs );

  00350	8b 44 24 34	 mov	 eax, DWORD PTR frrnext$[rsp]
  00354	83 c0 07	 add	 eax, 7
  00357	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0035f	23 81 90 00 00
	00		 and	 eax, DWORD PTR [rcx+144]
  00365	4c 8b 8c 24 98
	00 00 00	 mov	 r9, QWORD PTR regs$[rsp]
  0036d	41 b8 fd ff ff
	ff		 mov	 r8d, -3
  00373	8b d0		 mov	 edx, eax
  00375	0f b6 4c 24 30	 movzx	 ecx, BYTE PTR entrycode$[rsp]
  0037a	e8 00 00 00 00	 call	 s390_vstoreb

; 810  :     }

  0037f	e9 1b 01 00 00	 jmp	 $LN19@s390_add_f
$LN18@s390_add_f:

; 811  : 
; 812  :     /*  3. SETFRR A,MODE=(FULLXM | PRIMARY, with any or no combination of LOCAL or GLOBAL or EUT=YES.  */
; 813  : 
; 814  :     else
; 815  :     {
; 816  :         BYTE cr34[8];  // CR3 and CR4
; 817  : 
; 818  :         /* Set the FRR entry point from r2 in the stack */
; 819  :         ARCH_DEP( vstore4 )( regs->GR_L(r2) | 0x00000001, frrnext, USE_PRIMARY_SPACE, regs );

  00384	48 63 44 24 4c	 movsxd	 rax, DWORD PTR r2$[rsp]
  00389	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00391	8b 84 c1 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax*8+640]
  00398	83 c8 01	 or	 eax, 1
  0039b	4c 8b 8c 24 98
	00 00 00	 mov	 r9, QWORD PTR regs$[rsp]
  003a3	41 b8 fd ff ff
	ff		 mov	 r8d, -3
  003a9	8b 54 24 34	 mov	 edx, DWORD PTR frrnext$[rsp]
  003ad	8b c8		 mov	 ecx, eax
  003af	e8 00 00 00 00	 call	 s390_vstore4

; 820  : 
; 821  :         /* Check if in secondary access mode; if yes turn on secondary bit in the entry code */
; 822  :         if (ARCH_DEP( vfetchb )( (PSAXMFLG & ADDRESS_MAXWRAP( regs )), USE_PRIMARY_SPACE, regs ) & PSAXMODE)

  003b4	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  003bc	8b 80 90 00 00
	00		 mov	 eax, DWORD PTR [rax+144]
  003c2	25 9c 04 00 00	 and	 eax, 1180		; 0000049cH
  003c7	4c 8b 84 24 98
	00 00 00	 mov	 r8, QWORD PTR regs$[rsp]
  003cf	ba fd ff ff ff	 mov	 edx, -3
  003d4	8b c8		 mov	 ecx, eax
  003d6	e8 00 00 00 00	 call	 s390_vfetchb
  003db	0f b6 c0	 movzx	 eax, al
  003de	83 e0 40	 and	 eax, 64			; 00000040H
  003e1	85 c0		 test	 eax, eax
  003e3	74 0c		 je	 SHORT $LN20@s390_add_f

; 823  :             entrycode |= PSAXMODE;  // indicate to FRR in secondary mode

  003e5	0f b6 44 24 30	 movzx	 eax, BYTE PTR entrycode$[rsp]
  003ea	83 c8 40	 or	 eax, 64			; 00000040H
  003ed	88 44 24 30	 mov	 BYTE PTR entrycode$[rsp], al
$LN20@s390_add_f:

; 824  : 
; 825  :         /* The entry code is stored in the FRR stack */
; 826  :         ARCH_DEP( vstoreb )( entrycode, ((frrnext + 7) & ADDRESS_MAXWRAP( regs )), USE_PRIMARY_SPACE, regs );

  003f1	8b 44 24 34	 mov	 eax, DWORD PTR frrnext$[rsp]
  003f5	83 c0 07	 add	 eax, 7
  003f8	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00400	23 81 90 00 00
	00		 and	 eax, DWORD PTR [rcx+144]
  00406	4c 8b 8c 24 98
	00 00 00	 mov	 r9, QWORD PTR regs$[rsp]
  0040e	41 b8 fd ff ff
	ff		 mov	 r8d, -3
  00414	8b d0		 mov	 edx, eax
  00416	0f b6 4c 24 30	 movzx	 ecx, BYTE PTR entrycode$[rsp]
  0041b	e8 00 00 00 00	 call	 s390_vstoreb

; 827  : 
; 828  :         /* Compute the address of the FRR area where CR3 and CR4 are copied from the PSA */
; 829  :         cr_ptr = frrnext - frrparm;

  00420	8b 44 24 68	 mov	 eax, DWORD PTR frrparm$[rsp]
  00424	8b 4c 24 34	 mov	 ecx, DWORD PTR frrnext$[rsp]
  00428	2b c8		 sub	 ecx, eax
  0042a	8b c1		 mov	 eax, ecx
  0042c	89 44 24 3c	 mov	 DWORD PTR cr_ptr$[rsp], eax

; 830  :         cr_ptr = cr_ptr >> 2;

  00430	8b 44 24 3c	 mov	 eax, DWORD PTR cr_ptr$[rsp]
  00434	c1 e8 02	 shr	 eax, 2
  00437	89 44 24 3c	 mov	 DWORD PTR cr_ptr$[rsp], eax

; 831  :         cr_ptr = (frrstak + cr_ptr + 120) & ADDRESS_MAXWRAP( regs );

  0043b	8b 44 24 38	 mov	 eax, DWORD PTR frrstak$[rsp]
  0043f	8b 4c 24 3c	 mov	 ecx, DWORD PTR cr_ptr$[rsp]
  00443	8d 44 08 78	 lea	 eax, DWORD PTR [rax+rcx+120]
  00447	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0044f	23 81 90 00 00
	00		 and	 eax, DWORD PTR [rcx+144]
  00455	89 44 24 3c	 mov	 DWORD PTR cr_ptr$[rsp], eax

; 832  : 
; 833  :         /* Copy CR3 and CR4 values from PSA to computed FRR area */
; 834  :         ARCH_DEP( vfetchc )( cr34, 8-1, PSAXMCR3, USE_PRIMARY_SPACE, regs );

  00459	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00461	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00466	41 b9 fd ff ff
	ff		 mov	 r9d, -3
  0046c	41 b8 c4 05 00
	00		 mov	 r8d, 1476		; 000005c4H
  00472	b2 07		 mov	 dl, 7
  00474	48 8d 4c 24 70	 lea	 rcx, QWORD PTR cr34$2[rsp]
  00479	e8 00 00 00 00	 call	 s390_vfetchc

; 835  :         ARCH_DEP( vstorec )( cr34, 8-1, cr_ptr, 0, regs );

  0047e	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00486	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  0048b	45 33 c9	 xor	 r9d, r9d
  0048e	44 8b 44 24 3c	 mov	 r8d, DWORD PTR cr_ptr$[rsp]
  00493	b2 07		 mov	 dl, 7
  00495	48 8d 4c 24 70	 lea	 rcx, QWORD PTR cr34$2[rsp]
  0049a	e8 00 00 00 00	 call	 s390_vstorec
$LN19@s390_add_f:
$LN17@s390_add_f:

; 836  :     }
; 837  : 
; 838  :     /* Update the FRR stack pointers to point to the newly added FRR */
; 839  :     ARCH_DEP( vstore4 )( frrnext, (frrstak + 12) & ADDRESS_MAXWRAP( regs ), USE_PRIMARY_SPACE, regs );

  0049f	8b 44 24 38	 mov	 eax, DWORD PTR frrstak$[rsp]
  004a3	83 c0 0c	 add	 eax, 12
  004a6	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  004ae	23 81 90 00 00
	00		 and	 eax, DWORD PTR [rcx+144]
  004b4	4c 8b 8c 24 98
	00 00 00	 mov	 r9, QWORD PTR regs$[rsp]
  004bc	41 b8 fd ff ff
	ff		 mov	 r8d, -3
  004c2	8b d0		 mov	 edx, eax
  004c4	8b 4c 24 34	 mov	 ecx, DWORD PTR frrnext$[rsp]
  004c8	e8 00 00 00 00	 call	 s390_vstore4

; 840  : 
; 841  :     /* Return with the FRRSPARM area address in r1 per the assist documentation  */
; 842  :     regs->GR_L(r1) = (frrnext + FRRSPARM) & ADDRESS_MAXWRAP( regs );

  004cd	8b 44 24 34	 mov	 eax, DWORD PTR frrnext$[rsp]
  004d1	83 c0 08	 add	 eax, 8
  004d4	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  004dc	23 81 90 00 00
	00		 and	 eax, DWORD PTR [rcx+144]
  004e2	48 63 4c 24 54	 movsxd	 rcx, DWORD PTR r1$[rsp]
  004e7	48 8b 94 24 98
	00 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  004ef	89 84 ca 80 02
	00 00		 mov	 DWORD PTR [rdx+rcx*8+640], eax

; 843  : 
; 844  :     /* Initialize (clear) the rest of the FRR stack */
; 845  :     clear_vaddr = (frrnext + 8) & ADDRESS_MAXWRAP( regs );

  004f6	8b 44 24 34	 mov	 eax, DWORD PTR frrnext$[rsp]
  004fa	83 c0 08	 add	 eax, 8
  004fd	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00505	23 81 90 00 00
	00		 and	 eax, DWORD PTR [rcx+144]
  0050b	89 44 24 48	 mov	 DWORD PTR clear_vaddr$[rsp], eax

; 846  :     len = 256;

  0050f	c7 44 24 44 00
	01 00 00	 mov	 DWORD PTR len$[rsp], 256 ; 00000100H

; 847  :     size = frrsize;

  00517	8b 44 24 58	 mov	 eax, DWORD PTR frrsize$[rsp]
  0051b	89 44 24 40	 mov	 DWORD PTR size$[rsp], eax
$LN8@s390_add_f:

; 848  :     while (size)

  0051f	83 7c 24 40 00	 cmp	 DWORD PTR size$[rsp], 0
  00524	74 78		 je	 SHORT $LN9@s390_add_f

; 849  :     {
; 850  :         if (len > size) len = size;

  00526	8b 44 24 40	 mov	 eax, DWORD PTR size$[rsp]
  0052a	39 44 24 44	 cmp	 DWORD PTR len$[rsp], eax
  0052e	76 08		 jbe	 SHORT $LN21@s390_add_f
  00530	8b 44 24 40	 mov	 eax, DWORD PTR size$[rsp]
  00534	89 44 24 44	 mov	 DWORD PTR len$[rsp], eax
$LN21@s390_add_f:

; 851  :         ARCH_DEP( vstorec )( zeros, len-1, clear_vaddr, 0, regs );

  00538	8b 44 24 44	 mov	 eax, DWORD PTR len$[rsp]
  0053c	ff c8		 dec	 eax
  0053e	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00546	48 89 4c 24 20	 mov	 QWORD PTR [rsp+32], rcx
  0054b	45 33 c9	 xor	 r9d, r9d
  0054e	44 8b 44 24 48	 mov	 r8d, DWORD PTR clear_vaddr$[rsp]
  00553	0f b6 d0	 movzx	 edx, al
  00556	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:?zeros@?1??s390_add_frr@@9@9
  0055d	e8 00 00 00 00	 call	 s390_vstorec

; 852  :         size        -= len;

  00562	8b 44 24 44	 mov	 eax, DWORD PTR len$[rsp]
  00566	8b 4c 24 40	 mov	 ecx, DWORD PTR size$[rsp]
  0056a	2b c8		 sub	 ecx, eax
  0056c	8b c1		 mov	 eax, ecx
  0056e	89 44 24 40	 mov	 DWORD PTR size$[rsp], eax

; 853  :         clear_vaddr += len;

  00572	8b 44 24 44	 mov	 eax, DWORD PTR len$[rsp]
  00576	8b 4c 24 48	 mov	 ecx, DWORD PTR clear_vaddr$[rsp]
  0057a	03 c8		 add	 ecx, eax
  0057c	8b c1		 mov	 eax, ecx
  0057e	89 44 24 48	 mov	 DWORD PTR clear_vaddr$[rsp], eax

; 854  :         clear_vaddr &= ADDRESS_MAXWRAP( regs );

  00582	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0058a	8b 80 90 00 00
	00		 mov	 eax, DWORD PTR [rax+144]
  00590	8b 4c 24 48	 mov	 ecx, DWORD PTR clear_vaddr$[rsp]
  00594	23 c8		 and	 ecx, eax
  00596	8b c1		 mov	 eax, ecx
  00598	89 44 24 48	 mov	 DWORD PTR clear_vaddr$[rsp], eax

; 855  :     }

  0059c	eb 81		 jmp	 SHORT $LN8@s390_add_f
$LN9@s390_add_f:
$LN1@s390_add_f:

; 856  : }

  0059e	48 8b 4c 24 78	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  005a3	48 33 cc	 xor	 rcx, rsp
  005a6	e8 00 00 00 00	 call	 __security_check_cookie
  005ab	48 81 c4 88 00
	00 00		 add	 rsp, 136		; 00000088H
  005b2	c3		 ret	 0
s390_add_frr ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\vstore.h
;	COMDAT s370_vfetch4
_TEXT	SEGMENT
tv66 = 48
tv72 = 52
tv80 = 56
tv92 = 60
mn$1 = 64
addr$ = 96
arn$ = 104
regs$ = 112
s370_vfetch4 PROC					; COMDAT

; 695  : {

$LN26:
  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00009	89 4c 24 08	 mov	 DWORD PTR [rsp+8], ecx
  0000d	48 83 ec 58	 sub	 rsp, 88			; 00000058H

; 696  :     if ((likely(!((VADR_L)addr & 0x03))
; 697  :         || (((VADR_L)addr & PAGEFRAME_BYTEMASK) <= (PAGEFRAME_BYTEMASK-3) )))

  00011	8b 44 24 60	 mov	 eax, DWORD PTR addr$[rsp]
  00015	83 e0 03	 and	 eax, 3
  00018	85 c0		 test	 eax, eax
  0001a	75 0a		 jne	 SHORT $LN9@s370_vfetc
  0001c	c7 44 24 30 01
	00 00 00	 mov	 DWORD PTR tv66[rsp], 1
  00024	eb 08		 jmp	 SHORT $LN10@s370_vfetc
$LN9@s370_vfetc:
  00026	c7 44 24 30 00
	00 00 00	 mov	 DWORD PTR tv66[rsp], 0
$LN10@s370_vfetc:
  0002e	83 7c 24 30 00	 cmp	 DWORD PTR tv66[rsp], 0
  00033	74 0a		 je	 SHORT $LN13@s370_vfetc
  00035	c7 44 24 34 01
	00 00 00	 mov	 DWORD PTR tv72[rsp], 1
  0003d	eb 08		 jmp	 SHORT $LN14@s370_vfetc
$LN13@s370_vfetc:
  0003f	c7 44 24 34 00
	00 00 00	 mov	 DWORD PTR tv72[rsp], 0
$LN14@s370_vfetc:
  00047	83 7c 24 34 00	 cmp	 DWORD PTR tv72[rsp], 0
  0004c	75 14		 jne	 SHORT $LN6@s370_vfetc
  0004e	8b 44 24 60	 mov	 eax, DWORD PTR addr$[rsp]
  00052	25 ff 07 00 00	 and	 eax, 2047		; 000007ffH
  00057	3d fc 07 00 00	 cmp	 eax, 2044		; 000007fcH
  0005c	0f 87 9a 00 00
	00		 ja	 $LN5@s370_vfetc
$LN6@s370_vfetc:
$LN4@s370_vfetc:

; 698  :     {
; 699  :         BYTE *mn;
; 700  :         ITIMER_SYNC( addr, 4-1, regs );

  00062	83 7c 24 60 54	 cmp	 DWORD PTR addr$[rsp], 84 ; 00000054H
  00067	73 0a		 jae	 SHORT $LN17@s370_vfetc
  00069	c7 44 24 38 01
	00 00 00	 mov	 DWORD PTR tv80[rsp], 1
  00071	eb 08		 jmp	 SHORT $LN18@s370_vfetc
$LN17@s370_vfetc:
  00073	c7 44 24 38 00
	00 00 00	 mov	 DWORD PTR tv80[rsp], 0
$LN18@s370_vfetc:
  0007b	83 7c 24 38 00	 cmp	 DWORD PTR tv80[rsp], 0
  00080	74 16		 je	 SHORT $LN19@s370_vfetc
  00082	8b 44 24 60	 mov	 eax, DWORD PTR addr$[rsp]
  00086	83 c0 03	 add	 eax, 3
  00089	83 f8 50	 cmp	 eax, 80			; 00000050H
  0008c	72 0a		 jb	 SHORT $LN19@s370_vfetc
  0008e	c7 44 24 3c 01
	00 00 00	 mov	 DWORD PTR tv92[rsp], 1
  00096	eb 08		 jmp	 SHORT $LN25@s370_vfetc
$LN19@s370_vfetc:
  00098	c7 44 24 3c 00
	00 00 00	 mov	 DWORD PTR tv92[rsp], 0
$LN25@s370_vfetc:
  000a0	83 7c 24 3c 00	 cmp	 DWORD PTR tv92[rsp], 0
  000a5	74 0a		 je	 SHORT $LN7@s370_vfetc
  000a7	48 8b 4c 24 70	 mov	 rcx, QWORD PTR regs$[rsp]
  000ac	e8 00 00 00 00	 call	 s370_store_int_timer
$LN7@s370_vfetc:
  000b1	33 c0		 xor	 eax, eax
  000b3	85 c0		 test	 eax, eax
  000b5	75 ab		 jne	 SHORT $LN4@s370_vfetc

; 701  :         mn = MADDRL( addr, 4,arn, regs, ACCTYPE_READ, regs->psw.pkey );

  000b7	48 8b 44 24 70	 mov	 rax, QWORD PTR regs$[rsp]
  000bc	0f b6 40 79	 movzx	 eax, BYTE PTR [rax+121]
  000c0	88 44 24 28	 mov	 BYTE PTR [rsp+40], al
  000c4	c7 44 24 20 04
	00 00 00	 mov	 DWORD PTR [rsp+32], 4
  000cc	4c 8b 4c 24 70	 mov	 r9, QWORD PTR regs$[rsp]
  000d1	44 8b 44 24 68	 mov	 r8d, DWORD PTR arn$[rsp]
  000d6	ba 04 00 00 00	 mov	 edx, 4
  000db	8b 4c 24 60	 mov	 ecx, DWORD PTR addr$[rsp]
  000df	e8 00 00 00 00	 call	 s370_maddr_l
  000e4	48 89 44 24 40	 mov	 QWORD PTR mn$1[rsp], rax

; 702  :         return fetch_fw( mn );

  000e9	48 8b 4c 24 40	 mov	 rcx, QWORD PTR mn$1[rsp]
  000ee	e8 00 00 00 00	 call	 fetch_fw_noswap
  000f3	8b c8		 mov	 ecx, eax
  000f5	e8 00 00 00 00	 call	 _byteswap_ulong
  000fa	eb 12		 jmp	 SHORT $LN1@s370_vfetc
$LN5@s370_vfetc:

; 703  :     }
; 704  :     return ARCH_DEP( vfetch4_full )( addr, arn, regs );

  000fc	4c 8b 44 24 70	 mov	 r8, QWORD PTR regs$[rsp]
  00101	8b 54 24 68	 mov	 edx, DWORD PTR arn$[rsp]
  00105	8b 4c 24 60	 mov	 ecx, DWORD PTR addr$[rsp]
  00109	e8 00 00 00 00	 call	 s370_vfetch4_full
$LN1@s370_vfetc:

; 705  : }

  0010e	48 83 c4 58	 add	 rsp, 88			; 00000058H
  00112	c3		 ret	 0
s370_vfetch4 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\vstore.h
;	COMDAT s370_vfetchb
_TEXT	SEGMENT
tv68 = 48
tv78 = 52
mn$ = 56
addr$ = 80
arn$ = 88
regs$ = 96
s370_vfetchb PROC					; COMDAT

; 667  : {

$LN18:
  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00009	89 4c 24 08	 mov	 DWORD PTR [rsp+8], ecx
  0000d	48 83 ec 48	 sub	 rsp, 72			; 00000048H
$LN4@s370_vfetc:

; 668  : BYTE   *mn;                             /* Main storage address      */
; 669  : 
; 670  :     ITIMER_SYNC( addr, 1-1, regs );

  00011	83 7c 24 50 54	 cmp	 DWORD PTR addr$[rsp], 84 ; 00000054H
  00016	73 0a		 jae	 SHORT $LN9@s370_vfetc
  00018	c7 44 24 30 01
	00 00 00	 mov	 DWORD PTR tv68[rsp], 1
  00020	eb 08		 jmp	 SHORT $LN10@s370_vfetc
$LN9@s370_vfetc:
  00022	c7 44 24 30 00
	00 00 00	 mov	 DWORD PTR tv68[rsp], 0
$LN10@s370_vfetc:
  0002a	83 7c 24 30 00	 cmp	 DWORD PTR tv68[rsp], 0
  0002f	74 11		 je	 SHORT $LN11@s370_vfetc
  00031	83 7c 24 50 50	 cmp	 DWORD PTR addr$[rsp], 80 ; 00000050H
  00036	72 0a		 jb	 SHORT $LN11@s370_vfetc
  00038	c7 44 24 34 01
	00 00 00	 mov	 DWORD PTR tv78[rsp], 1
  00040	eb 08		 jmp	 SHORT $LN17@s370_vfetc
$LN11@s370_vfetc:
  00042	c7 44 24 34 00
	00 00 00	 mov	 DWORD PTR tv78[rsp], 0
$LN17@s370_vfetc:
  0004a	83 7c 24 34 00	 cmp	 DWORD PTR tv78[rsp], 0
  0004f	74 0a		 je	 SHORT $LN5@s370_vfetc
  00051	48 8b 4c 24 60	 mov	 rcx, QWORD PTR regs$[rsp]
  00056	e8 00 00 00 00	 call	 s370_store_int_timer
$LN5@s370_vfetc:
  0005b	33 c0		 xor	 eax, eax
  0005d	85 c0		 test	 eax, eax
  0005f	75 b0		 jne	 SHORT $LN4@s370_vfetc

; 671  :     mn = MADDR( addr, arn, regs, ACCTYPE_READ, regs->psw.pkey );

  00061	48 8b 44 24 60	 mov	 rax, QWORD PTR regs$[rsp]
  00066	0f b6 40 79	 movzx	 eax, BYTE PTR [rax+121]
  0006a	88 44 24 28	 mov	 BYTE PTR [rsp+40], al
  0006e	c7 44 24 20 04
	00 00 00	 mov	 DWORD PTR [rsp+32], 4
  00076	4c 8b 4c 24 60	 mov	 r9, QWORD PTR regs$[rsp]
  0007b	44 8b 44 24 58	 mov	 r8d, DWORD PTR arn$[rsp]
  00080	ba 01 00 00 00	 mov	 edx, 1
  00085	8b 4c 24 50	 mov	 ecx, DWORD PTR addr$[rsp]
  00089	e8 00 00 00 00	 call	 s370_maddr_l
  0008e	48 89 44 24 38	 mov	 QWORD PTR mn$[rsp], rax

; 672  :     return *mn;

  00093	48 8b 44 24 38	 mov	 rax, QWORD PTR mn$[rsp]
  00098	0f b6 00	 movzx	 eax, BYTE PTR [rax]

; 673  : }

  0009b	48 83 c4 48	 add	 rsp, 72			; 00000048H
  0009f	c3		 ret	 0
s370_vfetchb ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\vstore.h
;	COMDAT s370_vfetchc
_TEXT	SEGMENT
len2$ = 48
tv74 = 52
tv80 = 56
tv94 = 60
main1$ = 64
main2$ = 72
dest$ = 112
len$ = 120
addr$ = 128
arn$ = 136
regs$ = 144
s370_vfetchc PROC					; COMDAT

; 631  : {

$LN24:
  00000	44 89 4c 24 20	 mov	 DWORD PTR [rsp+32], r9d
  00005	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  0000a	88 54 24 10	 mov	 BYTE PTR [rsp+16], dl
  0000e	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00013	56		 push	 rsi
  00014	57		 push	 rdi
  00015	48 83 ec 58	 sub	 rsp, 88			; 00000058H

; 632  : BYTE   *main1, *main2;                  /* Main storage addresses    */
; 633  : int     len2;                           /* Length to copy on page    */
; 634  : 
; 635  :     if (NOCROSSPAGE( addr, len ))

  00019	8b 84 24 80 00
	00 00		 mov	 eax, DWORD PTR addr$[rsp]
  00020	25 ff 07 00 00	 and	 eax, 2047		; 000007ffH
  00025	0f b6 4c 24 78	 movzx	 ecx, BYTE PTR len$[rsp]
  0002a	ba ff 07 00 00	 mov	 edx, 2047		; 000007ffH
  0002f	2b d1		 sub	 edx, ecx
  00031	8b ca		 mov	 ecx, edx
  00033	3b c1		 cmp	 eax, ecx
  00035	7f 0a		 jg	 SHORT $LN11@s370_vfetc
  00037	c7 44 24 34 01
	00 00 00	 mov	 DWORD PTR tv74[rsp], 1
  0003f	eb 08		 jmp	 SHORT $LN12@s370_vfetc
$LN11@s370_vfetc:
  00041	c7 44 24 34 00
	00 00 00	 mov	 DWORD PTR tv74[rsp], 0
$LN12@s370_vfetc:
  00049	83 7c 24 34 00	 cmp	 DWORD PTR tv74[rsp], 0
  0004e	0f 84 c6 00 00
	00		 je	 $LN5@s370_vfetc
$LN4@s370_vfetc:

; 636  :     {
; 637  :         ITIMER_SYNC( addr, len, regs );

  00054	83 bc 24 80 00
	00 00 54	 cmp	 DWORD PTR addr$[rsp], 84 ; 00000054H
  0005c	73 0a		 jae	 SHORT $LN15@s370_vfetc
  0005e	c7 44 24 38 01
	00 00 00	 mov	 DWORD PTR tv80[rsp], 1
  00066	eb 08		 jmp	 SHORT $LN16@s370_vfetc
$LN15@s370_vfetc:
  00068	c7 44 24 38 00
	00 00 00	 mov	 DWORD PTR tv80[rsp], 0
$LN16@s370_vfetc:
  00070	83 7c 24 38 00	 cmp	 DWORD PTR tv80[rsp], 0
  00075	74 1f		 je	 SHORT $LN17@s370_vfetc
  00077	0f b6 44 24 78	 movzx	 eax, BYTE PTR len$[rsp]
  0007c	8b 8c 24 80 00
	00 00		 mov	 ecx, DWORD PTR addr$[rsp]
  00083	03 c8		 add	 ecx, eax
  00085	8b c1		 mov	 eax, ecx
  00087	83 f8 50	 cmp	 eax, 80			; 00000050H
  0008a	72 0a		 jb	 SHORT $LN17@s370_vfetc
  0008c	c7 44 24 3c 01
	00 00 00	 mov	 DWORD PTR tv94[rsp], 1
  00094	eb 08		 jmp	 SHORT $LN23@s370_vfetc
$LN17@s370_vfetc:
  00096	c7 44 24 3c 00
	00 00 00	 mov	 DWORD PTR tv94[rsp], 0
$LN23@s370_vfetc:
  0009e	83 7c 24 3c 00	 cmp	 DWORD PTR tv94[rsp], 0
  000a3	74 0d		 je	 SHORT $LN7@s370_vfetc
  000a5	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  000ad	e8 00 00 00 00	 call	 s370_store_int_timer
$LN7@s370_vfetc:
  000b2	33 c0		 xor	 eax, eax
  000b4	85 c0		 test	 eax, eax
  000b6	75 9c		 jne	 SHORT $LN4@s370_vfetc

; 638  :         main1 = MADDRL( addr, len + 1, arn, regs, ACCTYPE_READ, regs->psw.pkey );

  000b8	0f b6 44 24 78	 movzx	 eax, BYTE PTR len$[rsp]
  000bd	ff c0		 inc	 eax
  000bf	48 98		 cdqe
  000c1	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  000c9	0f b6 49 79	 movzx	 ecx, BYTE PTR [rcx+121]
  000cd	88 4c 24 28	 mov	 BYTE PTR [rsp+40], cl
  000d1	c7 44 24 20 04
	00 00 00	 mov	 DWORD PTR [rsp+32], 4
  000d9	4c 8b 8c 24 90
	00 00 00	 mov	 r9, QWORD PTR regs$[rsp]
  000e1	44 8b 84 24 88
	00 00 00	 mov	 r8d, DWORD PTR arn$[rsp]
  000e9	48 8b d0	 mov	 rdx, rax
  000ec	8b 8c 24 80 00
	00 00		 mov	 ecx, DWORD PTR addr$[rsp]
  000f3	e8 00 00 00 00	 call	 s370_maddr_l
  000f8	48 89 44 24 40	 mov	 QWORD PTR main1$[rsp], rax

; 639  :         memcpy( dest, main1, len + 1 );

  000fd	0f b6 44 24 78	 movzx	 eax, BYTE PTR len$[rsp]
  00102	ff c0		 inc	 eax
  00104	48 98		 cdqe
  00106	48 8b 7c 24 70	 mov	 rdi, QWORD PTR dest$[rsp]
  0010b	48 8b 74 24 40	 mov	 rsi, QWORD PTR main1$[rsp]
  00110	48 8b c8	 mov	 rcx, rax
  00113	f3 a4		 rep movsb

; 640  :     }

  00115	e9 ef 00 00 00	 jmp	 $LN6@s370_vfetc
$LN5@s370_vfetc:

; 641  :     else
; 642  :     {
; 643  :         len2 = PAGEFRAME_PAGESIZE - (addr & PAGEFRAME_BYTEMASK);

  0011a	8b 84 24 80 00
	00 00		 mov	 eax, DWORD PTR addr$[rsp]
  00121	25 ff 07 00 00	 and	 eax, 2047		; 000007ffH
  00126	b9 00 08 00 00	 mov	 ecx, 2048		; 00000800H
  0012b	2b c8		 sub	 ecx, eax
  0012d	8b c1		 mov	 eax, ecx
  0012f	89 44 24 30	 mov	 DWORD PTR len2$[rsp], eax

; 644  :         main1 = MADDRL( addr, len2, arn, regs, ACCTYPE_READ, regs->psw.pkey );

  00133	48 63 44 24 30	 movsxd	 rax, DWORD PTR len2$[rsp]
  00138	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00140	0f b6 49 79	 movzx	 ecx, BYTE PTR [rcx+121]
  00144	88 4c 24 28	 mov	 BYTE PTR [rsp+40], cl
  00148	c7 44 24 20 04
	00 00 00	 mov	 DWORD PTR [rsp+32], 4
  00150	4c 8b 8c 24 90
	00 00 00	 mov	 r9, QWORD PTR regs$[rsp]
  00158	44 8b 84 24 88
	00 00 00	 mov	 r8d, DWORD PTR arn$[rsp]
  00160	48 8b d0	 mov	 rdx, rax
  00163	8b 8c 24 80 00
	00 00		 mov	 ecx, DWORD PTR addr$[rsp]
  0016a	e8 00 00 00 00	 call	 s370_maddr_l
  0016f	48 89 44 24 40	 mov	 QWORD PTR main1$[rsp], rax

; 645  :         main2 = MADDRL( (addr + len2) & ADDRESS_MAXWRAP( regs ), len + 1 - len2,

  00174	0f b6 44 24 78	 movzx	 eax, BYTE PTR len$[rsp]
  00179	ff c0		 inc	 eax
  0017b	2b 44 24 30	 sub	 eax, DWORD PTR len2$[rsp]
  0017f	48 98		 cdqe
  00181	8b 4c 24 30	 mov	 ecx, DWORD PTR len2$[rsp]
  00185	8b 94 24 80 00
	00 00		 mov	 edx, DWORD PTR addr$[rsp]
  0018c	03 d1		 add	 edx, ecx
  0018e	8b ca		 mov	 ecx, edx
  00190	81 e1 ff ff ff
	00		 and	 ecx, 16777215		; 00ffffffH
  00196	48 8b 94 24 90
	00 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  0019e	0f b6 52 79	 movzx	 edx, BYTE PTR [rdx+121]
  001a2	88 54 24 28	 mov	 BYTE PTR [rsp+40], dl
  001a6	c7 44 24 20 04
	00 00 00	 mov	 DWORD PTR [rsp+32], 4
  001ae	4c 8b 8c 24 90
	00 00 00	 mov	 r9, QWORD PTR regs$[rsp]
  001b6	44 8b 84 24 88
	00 00 00	 mov	 r8d, DWORD PTR arn$[rsp]
  001be	48 8b d0	 mov	 rdx, rax
  001c1	e8 00 00 00 00	 call	 s370_maddr_l
  001c6	48 89 44 24 48	 mov	 QWORD PTR main2$[rsp], rax

; 646  :                         arn, regs, ACCTYPE_READ, regs->psw.pkey );
; 647  :         memcpy(        dest,        main1,           len2 );

  001cb	48 63 44 24 30	 movsxd	 rax, DWORD PTR len2$[rsp]
  001d0	48 8b 7c 24 70	 mov	 rdi, QWORD PTR dest$[rsp]
  001d5	48 8b 74 24 40	 mov	 rsi, QWORD PTR main1$[rsp]
  001da	48 8b c8	 mov	 rcx, rax
  001dd	f3 a4		 rep movsb

; 648  :         memcpy( (BYTE*)dest + len2, main2, len + 1 - len2 );

  001df	0f b6 44 24 78	 movzx	 eax, BYTE PTR len$[rsp]
  001e4	ff c0		 inc	 eax
  001e6	2b 44 24 30	 sub	 eax, DWORD PTR len2$[rsp]
  001ea	48 98		 cdqe
  001ec	48 63 4c 24 30	 movsxd	 rcx, DWORD PTR len2$[rsp]
  001f1	48 8b 54 24 70	 mov	 rdx, QWORD PTR dest$[rsp]
  001f6	48 03 d1	 add	 rdx, rcx
  001f9	48 8b ca	 mov	 rcx, rdx
  001fc	48 8b f9	 mov	 rdi, rcx
  001ff	48 8b 74 24 48	 mov	 rsi, QWORD PTR main2$[rsp]
  00204	48 8b c8	 mov	 rcx, rax
  00207	f3 a4		 rep movsb
$LN6@s370_vfetc:

; 649  :     }
; 650  : }

  00209	48 83 c4 58	 add	 rsp, 88			; 00000058H
  0020d	5f		 pop	 rdi
  0020e	5e		 pop	 rsi
  0020f	c3		 ret	 0
s370_vfetchc ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\vstore.h
;	COMDAT s370_vstore4
_TEXT	SEGMENT
tv66 = 48
tv72 = 52
tv92 = 56
tv136 = 60
mn$1 = 64
value$ = 96
addr$ = 104
arn$ = 112
regs$ = 120
s370_vstore4 PROC					; COMDAT

; 559  : {

$LN27:
  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  0000a	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  0000e	89 4c 24 08	 mov	 DWORD PTR [rsp+8], ecx
  00012	48 83 ec 58	 sub	 rsp, 88			; 00000058H

; 560  :     /* Most common case : Aligned & not crossing page boundary */
; 561  :     if (likely(!((VADR_L)addr & 0x03))
; 562  :         || (((VADR_L)addr & PAGEFRAME_BYTEMASK) <= (PAGEFRAME_BYTEMASK-3)))

  00016	8b 44 24 68	 mov	 eax, DWORD PTR addr$[rsp]
  0001a	83 e0 03	 and	 eax, 3
  0001d	85 c0		 test	 eax, eax
  0001f	75 0a		 jne	 SHORT $LN10@s370_vstor
  00021	c7 44 24 30 01
	00 00 00	 mov	 DWORD PTR tv66[rsp], 1
  00029	eb 08		 jmp	 SHORT $LN11@s370_vstor
$LN10@s370_vstor:
  0002b	c7 44 24 30 00
	00 00 00	 mov	 DWORD PTR tv66[rsp], 0
$LN11@s370_vstor:
  00033	83 7c 24 30 00	 cmp	 DWORD PTR tv66[rsp], 0
  00038	74 0a		 je	 SHORT $LN14@s370_vstor
  0003a	c7 44 24 34 01
	00 00 00	 mov	 DWORD PTR tv72[rsp], 1
  00042	eb 08		 jmp	 SHORT $LN15@s370_vstor
$LN14@s370_vstor:
  00044	c7 44 24 34 00
	00 00 00	 mov	 DWORD PTR tv72[rsp], 0
$LN15@s370_vstor:
  0004c	83 7c 24 34 00	 cmp	 DWORD PTR tv72[rsp], 0
  00051	75 14		 jne	 SHORT $LN7@s370_vstor
  00053	8b 44 24 68	 mov	 eax, DWORD PTR addr$[rsp]
  00057	25 ff 07 00 00	 and	 eax, 2047		; 000007ffH
  0005c	3d fc 07 00 00	 cmp	 eax, 2044		; 000007fcH
  00061	0f 87 9e 00 00
	00		 ja	 $LN5@s370_vstor
$LN7@s370_vstor:

; 563  :     {
; 564  :         BYTE *mn;
; 565  :         mn = MADDRL( addr, 4, arn, regs, ACCTYPE_WRITE, regs->psw.pkey );

  00067	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  0006c	0f b6 40 79	 movzx	 eax, BYTE PTR [rax+121]
  00070	88 44 24 28	 mov	 BYTE PTR [rsp+40], al
  00074	c7 44 24 20 02
	00 00 00	 mov	 DWORD PTR [rsp+32], 2
  0007c	4c 8b 4c 24 78	 mov	 r9, QWORD PTR regs$[rsp]
  00081	44 8b 44 24 70	 mov	 r8d, DWORD PTR arn$[rsp]
  00086	ba 04 00 00 00	 mov	 edx, 4
  0008b	8b 4c 24 68	 mov	 ecx, DWORD PTR addr$[rsp]
  0008f	e8 00 00 00 00	 call	 s370_maddr_l
  00094	48 89 44 24 40	 mov	 QWORD PTR mn$1[rsp], rax

; 566  :         STORE_FW( mn, value );

  00099	8b 4c 24 60	 mov	 ecx, DWORD PTR value$[rsp]
  0009d	e8 00 00 00 00	 call	 _byteswap_ulong
  000a2	8b d0		 mov	 edx, eax
  000a4	48 8b 4c 24 40	 mov	 rcx, QWORD PTR mn$1[rsp]
  000a9	e8 00 00 00 00	 call	 store_fw_noswap
$LN4@s370_vstor:

; 567  :         ITIMER_UPDATE( addr, 4-1, regs );

  000ae	83 7c 24 68 54	 cmp	 DWORD PTR addr$[rsp], 84 ; 00000054H
  000b3	73 0a		 jae	 SHORT $LN18@s370_vstor
  000b5	c7 44 24 38 01
	00 00 00	 mov	 DWORD PTR tv92[rsp], 1
  000bd	eb 08		 jmp	 SHORT $LN19@s370_vstor
$LN18@s370_vstor:
  000bf	c7 44 24 38 00
	00 00 00	 mov	 DWORD PTR tv92[rsp], 0
$LN19@s370_vstor:
  000c7	83 7c 24 38 00	 cmp	 DWORD PTR tv92[rsp], 0
  000cc	74 16		 je	 SHORT $LN20@s370_vstor
  000ce	8b 44 24 68	 mov	 eax, DWORD PTR addr$[rsp]
  000d2	83 c0 03	 add	 eax, 3
  000d5	83 f8 50	 cmp	 eax, 80			; 00000050H
  000d8	72 0a		 jb	 SHORT $LN20@s370_vstor
  000da	c7 44 24 3c 01
	00 00 00	 mov	 DWORD PTR tv136[rsp], 1
  000e2	eb 08		 jmp	 SHORT $LN26@s370_vstor
$LN20@s370_vstor:
  000e4	c7 44 24 3c 00
	00 00 00	 mov	 DWORD PTR tv136[rsp], 0
$LN26@s370_vstor:
  000ec	83 7c 24 3c 00	 cmp	 DWORD PTR tv136[rsp], 0
  000f1	74 0a		 je	 SHORT $LN8@s370_vstor
  000f3	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  000f8	e8 00 00 00 00	 call	 s370_fetch_int_timer
$LN8@s370_vstor:
  000fd	33 c0		 xor	 eax, eax
  000ff	85 c0		 test	 eax, eax
  00101	75 ab		 jne	 SHORT $LN4@s370_vstor

; 568  :     }

  00103	eb 17		 jmp	 SHORT $LN6@s370_vstor
$LN5@s370_vstor:

; 569  :     else
; 570  :         ARCH_DEP( vstore4_full )( value, addr, arn, regs );

  00105	4c 8b 4c 24 78	 mov	 r9, QWORD PTR regs$[rsp]
  0010a	44 8b 44 24 70	 mov	 r8d, DWORD PTR arn$[rsp]
  0010f	8b 54 24 68	 mov	 edx, DWORD PTR addr$[rsp]
  00113	8b 4c 24 60	 mov	 ecx, DWORD PTR value$[rsp]
  00117	e8 00 00 00 00	 call	 s370_vstore4_full
$LN6@s370_vstor:

; 571  : }

  0011c	48 83 c4 58	 add	 rsp, 88			; 00000058H
  00120	c3		 ret	 0
s370_vstore4 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\vstore.h
;	COMDAT s370_vstoreb
_TEXT	SEGMENT
tv76 = 48
tv86 = 52
main1$ = 56
value$ = 80
addr$ = 88
arn$ = 96
regs$ = 104
s370_vstoreb PROC					; COMDAT

; 529  : {

$LN18:
  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  0000a	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  0000e	88 4c 24 08	 mov	 BYTE PTR [rsp+8], cl
  00012	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 530  : BYTE   *main1;                          /* Mainstor address          */
; 531  : 
; 532  :     main1 = MADDR( addr, arn, regs, ACCTYPE_WRITE, regs->psw.pkey );

  00016	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  0001b	0f b6 40 79	 movzx	 eax, BYTE PTR [rax+121]
  0001f	88 44 24 28	 mov	 BYTE PTR [rsp+40], al
  00023	c7 44 24 20 02
	00 00 00	 mov	 DWORD PTR [rsp+32], 2
  0002b	4c 8b 4c 24 68	 mov	 r9, QWORD PTR regs$[rsp]
  00030	44 8b 44 24 60	 mov	 r8d, DWORD PTR arn$[rsp]
  00035	ba 01 00 00 00	 mov	 edx, 1
  0003a	8b 4c 24 58	 mov	 ecx, DWORD PTR addr$[rsp]
  0003e	e8 00 00 00 00	 call	 s370_maddr_l
  00043	48 89 44 24 38	 mov	 QWORD PTR main1$[rsp], rax

; 533  :     *main1 = value;

  00048	48 8b 44 24 38	 mov	 rax, QWORD PTR main1$[rsp]
  0004d	0f b6 4c 24 50	 movzx	 ecx, BYTE PTR value$[rsp]
  00052	88 08		 mov	 BYTE PTR [rax], cl
$LN4@s370_vstor:

; 534  :     ITIMER_UPDATE( addr, 1-1, regs );

  00054	83 7c 24 58 54	 cmp	 DWORD PTR addr$[rsp], 84 ; 00000054H
  00059	73 0a		 jae	 SHORT $LN9@s370_vstor
  0005b	c7 44 24 30 01
	00 00 00	 mov	 DWORD PTR tv76[rsp], 1
  00063	eb 08		 jmp	 SHORT $LN10@s370_vstor
$LN9@s370_vstor:
  00065	c7 44 24 30 00
	00 00 00	 mov	 DWORD PTR tv76[rsp], 0
$LN10@s370_vstor:
  0006d	83 7c 24 30 00	 cmp	 DWORD PTR tv76[rsp], 0
  00072	74 11		 je	 SHORT $LN11@s370_vstor
  00074	83 7c 24 58 50	 cmp	 DWORD PTR addr$[rsp], 80 ; 00000050H
  00079	72 0a		 jb	 SHORT $LN11@s370_vstor
  0007b	c7 44 24 34 01
	00 00 00	 mov	 DWORD PTR tv86[rsp], 1
  00083	eb 08		 jmp	 SHORT $LN17@s370_vstor
$LN11@s370_vstor:
  00085	c7 44 24 34 00
	00 00 00	 mov	 DWORD PTR tv86[rsp], 0
$LN17@s370_vstor:
  0008d	83 7c 24 34 00	 cmp	 DWORD PTR tv86[rsp], 0
  00092	74 0a		 je	 SHORT $LN5@s370_vstor
  00094	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  00099	e8 00 00 00 00	 call	 s370_fetch_int_timer
$LN5@s370_vstor:
  0009e	33 c0		 xor	 eax, eax
  000a0	85 c0		 test	 eax, eax
  000a2	75 b0		 jne	 SHORT $LN4@s370_vstor

; 535  : }

  000a4	48 83 c4 48	 add	 rsp, 72			; 00000048H
  000a8	c3		 ret	 0
s370_vstoreb ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\vstore.h
;	COMDAT s370_vstorec
_TEXT	SEGMENT
len2$ = 48
tv74 = 52
tv131 = 56
tv145 = 60
sk$ = 64
tv81 = 72
main1$ = 80
main2$ = 88
src$ = 128
len$ = 136
addr$ = 144
arn$ = 152
regs$ = 160
s370_vstorec PROC					; COMDAT

; 489  : {

$LN24:
  00000	44 89 4c 24 20	 mov	 DWORD PTR [rsp+32], r9d
  00005	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  0000a	88 54 24 10	 mov	 BYTE PTR [rsp+16], dl
  0000e	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00013	56		 push	 rsi
  00014	57		 push	 rdi
  00015	48 83 ec 68	 sub	 rsp, 104		; 00000068H

; 490  : BYTE   *main1, *main2;                  /* Mainstor addresses        */
; 491  : BYTE   *sk;                             /* Storage key addresses     */
; 492  : int     len2;                           /* Length to end of page     */
; 493  : 
; 494  :     if (NOCROSSPAGE( addr,len ))

  00019	8b 84 24 90 00
	00 00		 mov	 eax, DWORD PTR addr$[rsp]
  00020	25 ff 07 00 00	 and	 eax, 2047		; 000007ffH
  00025	0f b6 8c 24 88
	00 00 00	 movzx	 ecx, BYTE PTR len$[rsp]
  0002d	ba ff 07 00 00	 mov	 edx, 2047		; 000007ffH
  00032	2b d1		 sub	 edx, ecx
  00034	8b ca		 mov	 ecx, edx
  00036	3b c1		 cmp	 eax, ecx
  00038	7f 0a		 jg	 SHORT $LN11@s370_vstor
  0003a	c7 44 24 34 01
	00 00 00	 mov	 DWORD PTR tv74[rsp], 1
  00042	eb 08		 jmp	 SHORT $LN12@s370_vstor
$LN11@s370_vstor:
  00044	c7 44 24 34 00
	00 00 00	 mov	 DWORD PTR tv74[rsp], 0
$LN12@s370_vstor:
  0004c	83 7c 24 34 00	 cmp	 DWORD PTR tv74[rsp], 0
  00051	0f 84 d6 00 00
	00		 je	 $LN5@s370_vstor

; 495  :     {
; 496  :         memcpy( MADDRL( addr, len+1, arn, regs, ACCTYPE_WRITE, regs->psw.pkey ),

  00057	0f b6 84 24 88
	00 00 00	 movzx	 eax, BYTE PTR len$[rsp]
  0005f	ff c0		 inc	 eax
  00061	48 98		 cdqe
  00063	48 89 44 24 48	 mov	 QWORD PTR tv81[rsp], rax
  00068	0f b6 8c 24 88
	00 00 00	 movzx	 ecx, BYTE PTR len$[rsp]
  00070	ff c1		 inc	 ecx
  00072	48 63 c9	 movsxd	 rcx, ecx
  00075	48 8b 94 24 a0
	00 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  0007d	0f b6 52 79	 movzx	 edx, BYTE PTR [rdx+121]
  00081	88 54 24 28	 mov	 BYTE PTR [rsp+40], dl
  00085	c7 44 24 20 02
	00 00 00	 mov	 DWORD PTR [rsp+32], 2
  0008d	4c 8b 8c 24 a0
	00 00 00	 mov	 r9, QWORD PTR regs$[rsp]
  00095	44 8b 84 24 98
	00 00 00	 mov	 r8d, DWORD PTR arn$[rsp]
  0009d	48 8b d1	 mov	 rdx, rcx
  000a0	8b 8c 24 90 00
	00 00		 mov	 ecx, DWORD PTR addr$[rsp]
  000a7	e8 00 00 00 00	 call	 s370_maddr_l
  000ac	48 8b f8	 mov	 rdi, rax
  000af	48 8b b4 24 80
	00 00 00	 mov	 rsi, QWORD PTR src$[rsp]
  000b7	48 8b 44 24 48	 mov	 rax, QWORD PTR tv81[rsp]
  000bc	48 8b c8	 mov	 rcx, rax
  000bf	f3 a4		 rep movsb
$LN4@s370_vstor:

; 497  :                src, len + 1);
; 498  :         ITIMER_UPDATE( addr, len, regs );

  000c1	83 bc 24 90 00
	00 00 54	 cmp	 DWORD PTR addr$[rsp], 84 ; 00000054H
  000c9	73 0a		 jae	 SHORT $LN15@s370_vstor
  000cb	c7 44 24 38 01
	00 00 00	 mov	 DWORD PTR tv131[rsp], 1
  000d3	eb 08		 jmp	 SHORT $LN16@s370_vstor
$LN15@s370_vstor:
  000d5	c7 44 24 38 00
	00 00 00	 mov	 DWORD PTR tv131[rsp], 0
$LN16@s370_vstor:
  000dd	83 7c 24 38 00	 cmp	 DWORD PTR tv131[rsp], 0
  000e2	74 22		 je	 SHORT $LN17@s370_vstor
  000e4	0f b6 84 24 88
	00 00 00	 movzx	 eax, BYTE PTR len$[rsp]
  000ec	8b 8c 24 90 00
	00 00		 mov	 ecx, DWORD PTR addr$[rsp]
  000f3	03 c8		 add	 ecx, eax
  000f5	8b c1		 mov	 eax, ecx
  000f7	83 f8 50	 cmp	 eax, 80			; 00000050H
  000fa	72 0a		 jb	 SHORT $LN17@s370_vstor
  000fc	c7 44 24 3c 01
	00 00 00	 mov	 DWORD PTR tv145[rsp], 1
  00104	eb 08		 jmp	 SHORT $LN23@s370_vstor
$LN17@s370_vstor:
  00106	c7 44 24 3c 00
	00 00 00	 mov	 DWORD PTR tv145[rsp], 0
$LN23@s370_vstor:
  0010e	83 7c 24 3c 00	 cmp	 DWORD PTR tv145[rsp], 0
  00113	74 0d		 je	 SHORT $LN7@s370_vstor
  00115	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0011d	e8 00 00 00 00	 call	 s370_fetch_int_timer
$LN7@s370_vstor:
  00122	33 c0		 xor	 eax, eax
  00124	85 c0		 test	 eax, eax
  00126	75 99		 jne	 SHORT $LN4@s370_vstor

; 499  :     }

  00128	e9 21 01 00 00	 jmp	 $LN6@s370_vstor
$LN5@s370_vstor:

; 500  :     else
; 501  :     {
; 502  :         len2 = PAGEFRAME_PAGESIZE - (addr & PAGEFRAME_BYTEMASK);

  0012d	8b 84 24 90 00
	00 00		 mov	 eax, DWORD PTR addr$[rsp]
  00134	25 ff 07 00 00	 and	 eax, 2047		; 000007ffH
  00139	b9 00 08 00 00	 mov	 ecx, 2048		; 00000800H
  0013e	2b c8		 sub	 ecx, eax
  00140	8b c1		 mov	 eax, ecx
  00142	89 44 24 30	 mov	 DWORD PTR len2$[rsp], eax

; 503  :         main1 = MADDRL( addr, len2, arn, regs, ACCTYPE_WRITE_SKP,

  00146	48 63 44 24 30	 movsxd	 rax, DWORD PTR len2$[rsp]
  0014b	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00153	0f b6 49 79	 movzx	 ecx, BYTE PTR [rcx+121]
  00157	88 4c 24 28	 mov	 BYTE PTR [rsp+40], cl
  0015b	c7 44 24 20 01
	00 00 00	 mov	 DWORD PTR [rsp+32], 1
  00163	4c 8b 8c 24 a0
	00 00 00	 mov	 r9, QWORD PTR regs$[rsp]
  0016b	44 8b 84 24 98
	00 00 00	 mov	 r8d, DWORD PTR arn$[rsp]
  00173	48 8b d0	 mov	 rdx, rax
  00176	8b 8c 24 90 00
	00 00		 mov	 ecx, DWORD PTR addr$[rsp]
  0017d	e8 00 00 00 00	 call	 s370_maddr_l
  00182	48 89 44 24 50	 mov	 QWORD PTR main1$[rsp], rax

; 504  :                         regs->psw.pkey );
; 505  :         sk = regs->dat.storkey;

  00187	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0018f	48 8b 80 28 08
	00 00		 mov	 rax, QWORD PTR [rax+2088]
  00196	48 89 44 24 40	 mov	 QWORD PTR sk$[rsp], rax

; 506  :         main2 = MADDRL( (addr + len2) & ADDRESS_MAXWRAP( regs ),

  0019b	0f b6 84 24 88
	00 00 00	 movzx	 eax, BYTE PTR len$[rsp]
  001a3	ff c0		 inc	 eax
  001a5	2b 44 24 30	 sub	 eax, DWORD PTR len2$[rsp]
  001a9	48 98		 cdqe
  001ab	8b 4c 24 30	 mov	 ecx, DWORD PTR len2$[rsp]
  001af	8b 94 24 90 00
	00 00		 mov	 edx, DWORD PTR addr$[rsp]
  001b6	03 d1		 add	 edx, ecx
  001b8	8b ca		 mov	 ecx, edx
  001ba	81 e1 ff ff ff
	00		 and	 ecx, 16777215		; 00ffffffH
  001c0	48 8b 94 24 a0
	00 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  001c8	0f b6 52 79	 movzx	 edx, BYTE PTR [rdx+121]
  001cc	88 54 24 28	 mov	 BYTE PTR [rsp+40], dl
  001d0	c7 44 24 20 02
	00 00 00	 mov	 DWORD PTR [rsp+32], 2
  001d8	4c 8b 8c 24 a0
	00 00 00	 mov	 r9, QWORD PTR regs$[rsp]
  001e0	44 8b 84 24 98
	00 00 00	 mov	 r8d, DWORD PTR arn$[rsp]
  001e8	48 8b d0	 mov	 rdx, rax
  001eb	e8 00 00 00 00	 call	 s370_maddr_l
  001f0	48 89 44 24 58	 mov	 QWORD PTR main2$[rsp], rax

; 507  :                         len+1-len2, arn,
; 508  :                         regs, ACCTYPE_WRITE, regs->psw.pkey );
; 509  :         *sk |= (STORKEY_REF | STORKEY_CHANGE);

  001f5	48 8b 44 24 40	 mov	 rax, QWORD PTR sk$[rsp]
  001fa	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  001fd	83 c8 06	 or	 eax, 6
  00200	48 8b 4c 24 40	 mov	 rcx, QWORD PTR sk$[rsp]
  00205	88 01		 mov	 BYTE PTR [rcx], al

; 510  :         memcpy( main1, src, len2 );

  00207	48 63 44 24 30	 movsxd	 rax, DWORD PTR len2$[rsp]
  0020c	48 8b 7c 24 50	 mov	 rdi, QWORD PTR main1$[rsp]
  00211	48 8b b4 24 80
	00 00 00	 mov	 rsi, QWORD PTR src$[rsp]
  00219	48 8b c8	 mov	 rcx, rax
  0021c	f3 a4		 rep movsb

; 511  :         memcpy( main2, (BYTE*)src + len2, len + 1 - len2 );

  0021e	0f b6 84 24 88
	00 00 00	 movzx	 eax, BYTE PTR len$[rsp]
  00226	ff c0		 inc	 eax
  00228	2b 44 24 30	 sub	 eax, DWORD PTR len2$[rsp]
  0022c	48 98		 cdqe
  0022e	48 63 4c 24 30	 movsxd	 rcx, DWORD PTR len2$[rsp]
  00233	48 8b 94 24 80
	00 00 00	 mov	 rdx, QWORD PTR src$[rsp]
  0023b	48 03 d1	 add	 rdx, rcx
  0023e	48 8b ca	 mov	 rcx, rdx
  00241	48 8b 7c 24 58	 mov	 rdi, QWORD PTR main2$[rsp]
  00246	48 8b f1	 mov	 rsi, rcx
  00249	48 8b c8	 mov	 rcx, rax
  0024c	f3 a4		 rep movsb
$LN6@s370_vstor:

; 512  :     }
; 513  : }

  0024e	48 83 c4 68	 add	 rsp, 104		; 00000068H
  00252	5f		 pop	 rdi
  00253	5e		 pop	 rsi
  00254	c3		 ret	 0
s370_vstorec ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\vstore.h
;	COMDAT s370_vfetch4_full
_TEXT	SEGMENT
len$ = 48
mn$ = 56
temp$ = 64
__$ArrayPad$ = 72
addr$ = 112
arn$ = 120
regs$ = 128
s370_vfetch4_full PROC					; COMDAT

; 428  : {

$LN3:
  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00009	89 4c 24 08	 mov	 DWORD PTR [rsp+8], ecx
  0000d	56		 push	 rsi
  0000e	57		 push	 rdi
  0000f	48 83 ec 58	 sub	 rsp, 88			; 00000058H
  00013	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  0001a	48 33 c4	 xor	 rax, rsp
  0001d	48 89 44 24 48	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 429  : BYTE   *mn;                             /* Main storage addresses    */
; 430  : int     len;                            /* Length to end of page     */
; 431  : BYTE    temp[8];                        /* Copy destination          */
; 432  : 
; 433  :     len = PAGEFRAME_PAGESIZE - (addr & PAGEFRAME_BYTEMASK);

  00022	8b 44 24 70	 mov	 eax, DWORD PTR addr$[rsp]
  00026	25 ff 07 00 00	 and	 eax, 2047		; 000007ffH
  0002b	b9 00 08 00 00	 mov	 ecx, 2048		; 00000800H
  00030	2b c8		 sub	 ecx, eax
  00032	8b c1		 mov	 eax, ecx
  00034	89 44 24 30	 mov	 DWORD PTR len$[rsp], eax

; 434  :     mn = MADDRL( addr, len, arn, regs, ACCTYPE_READ, regs->psw.pkey );

  00038	48 63 44 24 30	 movsxd	 rax, DWORD PTR len$[rsp]
  0003d	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00045	0f b6 49 79	 movzx	 ecx, BYTE PTR [rcx+121]
  00049	88 4c 24 28	 mov	 BYTE PTR [rsp+40], cl
  0004d	c7 44 24 20 04
	00 00 00	 mov	 DWORD PTR [rsp+32], 4
  00055	4c 8b 8c 24 80
	00 00 00	 mov	 r9, QWORD PTR regs$[rsp]
  0005d	44 8b 44 24 78	 mov	 r8d, DWORD PTR arn$[rsp]
  00062	48 8b d0	 mov	 rdx, rax
  00065	8b 4c 24 70	 mov	 ecx, DWORD PTR addr$[rsp]
  00069	e8 00 00 00 00	 call	 s370_maddr_l
  0006e	48 89 44 24 38	 mov	 QWORD PTR mn$[rsp], rax

; 435  :     memcpy( temp, mn, len);

  00073	48 63 44 24 30	 movsxd	 rax, DWORD PTR len$[rsp]
  00078	48 8d 4c 24 40	 lea	 rcx, QWORD PTR temp$[rsp]
  0007d	48 8b f9	 mov	 rdi, rcx
  00080	48 8b 74 24 38	 mov	 rsi, QWORD PTR mn$[rsp]
  00085	48 8b c8	 mov	 rcx, rax
  00088	f3 a4		 rep movsb

; 436  :     mn = MADDRL( (addr + len) & ADDRESS_MAXWRAP( regs ), 4 - len, arn, regs,

  0008a	b8 04 00 00 00	 mov	 eax, 4
  0008f	2b 44 24 30	 sub	 eax, DWORD PTR len$[rsp]
  00093	48 98		 cdqe
  00095	8b 4c 24 30	 mov	 ecx, DWORD PTR len$[rsp]
  00099	8b 54 24 70	 mov	 edx, DWORD PTR addr$[rsp]
  0009d	03 d1		 add	 edx, ecx
  0009f	8b ca		 mov	 ecx, edx
  000a1	81 e1 ff ff ff
	00		 and	 ecx, 16777215		; 00ffffffH
  000a7	48 8b 94 24 80
	00 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  000af	0f b6 52 79	 movzx	 edx, BYTE PTR [rdx+121]
  000b3	88 54 24 28	 mov	 BYTE PTR [rsp+40], dl
  000b7	c7 44 24 20 04
	00 00 00	 mov	 DWORD PTR [rsp+32], 4
  000bf	4c 8b 8c 24 80
	00 00 00	 mov	 r9, QWORD PTR regs$[rsp]
  000c7	44 8b 44 24 78	 mov	 r8d, DWORD PTR arn$[rsp]
  000cc	48 8b d0	 mov	 rdx, rax
  000cf	e8 00 00 00 00	 call	 s370_maddr_l
  000d4	48 89 44 24 38	 mov	 QWORD PTR mn$[rsp], rax

; 437  :                   ACCTYPE_READ, regs->psw.pkey );
; 438  :     memcpy( temp+len, mn, 4 - len);

  000d9	b8 04 00 00 00	 mov	 eax, 4
  000de	2b 44 24 30	 sub	 eax, DWORD PTR len$[rsp]
  000e2	48 98		 cdqe
  000e4	48 63 4c 24 30	 movsxd	 rcx, DWORD PTR len$[rsp]
  000e9	48 8d 4c 0c 40	 lea	 rcx, QWORD PTR temp$[rsp+rcx]
  000ee	48 8b f9	 mov	 rdi, rcx
  000f1	48 8b 74 24 38	 mov	 rsi, QWORD PTR mn$[rsp]
  000f6	48 8b c8	 mov	 rcx, rax
  000f9	f3 a4		 rep movsb

; 439  :     return fetch_fw( temp );

  000fb	48 8d 4c 24 40	 lea	 rcx, QWORD PTR temp$[rsp]
  00100	e8 00 00 00 00	 call	 fetch_fw_noswap
  00105	8b c8		 mov	 ecx, eax
  00107	e8 00 00 00 00	 call	 _byteswap_ulong

; 440  : }

  0010c	48 8b 4c 24 48	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  00111	48 33 cc	 xor	 rcx, rsp
  00114	e8 00 00 00 00	 call	 __security_check_cookie
  00119	48 83 c4 58	 add	 rsp, 88			; 00000058H
  0011d	5f		 pop	 rdi
  0011e	5e		 pop	 rsi
  0011f	c3		 ret	 0
s370_vfetch4_full ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\vstore.h
;	COMDAT s370_vstore4_full
_TEXT	SEGMENT
len$ = 48
temp$ = 52
sk$ = 56
main1$ = 64
main2$ = 72
value$ = 112
addr$ = 120
arn$ = 128
regs$ = 136
s370_vstore4_full PROC					; COMDAT

; 335  : {

$LN3:
  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  0000a	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  0000e	89 4c 24 08	 mov	 DWORD PTR [rsp+8], ecx
  00012	56		 push	 rsi
  00013	57		 push	 rdi
  00014	48 83 ec 58	 sub	 rsp, 88			; 00000058H

; 336  : BYTE   *main1, *main2;                  /* Mainstor addresses        */
; 337  : BYTE   *sk;                             /* Storage key addresses     */
; 338  : int     len;                            /* Length to end of page     */
; 339  : BYTE    temp[4];                        /* Copied value              */
; 340  : 
; 341  :     len = PAGEFRAME_PAGESIZE - (addr & PAGEFRAME_BYTEMASK);

  00018	8b 44 24 78	 mov	 eax, DWORD PTR addr$[rsp]
  0001c	25 ff 07 00 00	 and	 eax, 2047		; 000007ffH
  00021	b9 00 08 00 00	 mov	 ecx, 2048		; 00000800H
  00026	2b c8		 sub	 ecx, eax
  00028	8b c1		 mov	 eax, ecx
  0002a	89 44 24 30	 mov	 DWORD PTR len$[rsp], eax

; 342  :     main1 = MADDRL( addr, len, arn, regs, ACCTYPE_WRITE_SKP, regs->psw.pkey );

  0002e	48 63 44 24 30	 movsxd	 rax, DWORD PTR len$[rsp]
  00033	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0003b	0f b6 49 79	 movzx	 ecx, BYTE PTR [rcx+121]
  0003f	88 4c 24 28	 mov	 BYTE PTR [rsp+40], cl
  00043	c7 44 24 20 01
	00 00 00	 mov	 DWORD PTR [rsp+32], 1
  0004b	4c 8b 8c 24 88
	00 00 00	 mov	 r9, QWORD PTR regs$[rsp]
  00053	44 8b 84 24 80
	00 00 00	 mov	 r8d, DWORD PTR arn$[rsp]
  0005b	48 8b d0	 mov	 rdx, rax
  0005e	8b 4c 24 78	 mov	 ecx, DWORD PTR addr$[rsp]
  00062	e8 00 00 00 00	 call	 s370_maddr_l
  00067	48 89 44 24 40	 mov	 QWORD PTR main1$[rsp], rax

; 343  :     sk = regs->dat.storkey;

  0006c	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00074	48 8b 80 28 08
	00 00		 mov	 rax, QWORD PTR [rax+2088]
  0007b	48 89 44 24 38	 mov	 QWORD PTR sk$[rsp], rax

; 344  :     main2 = MADDRL( (addr + len) & ADDRESS_MAXWRAP( regs ), 4-len, arn, regs,

  00080	b8 04 00 00 00	 mov	 eax, 4
  00085	2b 44 24 30	 sub	 eax, DWORD PTR len$[rsp]
  00089	48 98		 cdqe
  0008b	8b 4c 24 30	 mov	 ecx, DWORD PTR len$[rsp]
  0008f	8b 54 24 78	 mov	 edx, DWORD PTR addr$[rsp]
  00093	03 d1		 add	 edx, ecx
  00095	8b ca		 mov	 ecx, edx
  00097	81 e1 ff ff ff
	00		 and	 ecx, 16777215		; 00ffffffH
  0009d	48 8b 94 24 88
	00 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  000a5	0f b6 52 79	 movzx	 edx, BYTE PTR [rdx+121]
  000a9	88 54 24 28	 mov	 BYTE PTR [rsp+40], dl
  000ad	c7 44 24 20 02
	00 00 00	 mov	 DWORD PTR [rsp+32], 2
  000b5	4c 8b 8c 24 88
	00 00 00	 mov	 r9, QWORD PTR regs$[rsp]
  000bd	44 8b 84 24 80
	00 00 00	 mov	 r8d, DWORD PTR arn$[rsp]
  000c5	48 8b d0	 mov	 rdx, rax
  000c8	e8 00 00 00 00	 call	 s370_maddr_l
  000cd	48 89 44 24 48	 mov	 QWORD PTR main2$[rsp], rax

; 345  :                     ACCTYPE_WRITE, regs->psw.pkey );
; 346  :     *sk |= (STORKEY_REF | STORKEY_CHANGE);

  000d2	48 8b 44 24 38	 mov	 rax, QWORD PTR sk$[rsp]
  000d7	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  000da	83 c8 06	 or	 eax, 6
  000dd	48 8b 4c 24 38	 mov	 rcx, QWORD PTR sk$[rsp]
  000e2	88 01		 mov	 BYTE PTR [rcx], al

; 347  :     STORE_FW( temp, value );

  000e4	8b 4c 24 70	 mov	 ecx, DWORD PTR value$[rsp]
  000e8	e8 00 00 00 00	 call	 _byteswap_ulong
  000ed	8b d0		 mov	 edx, eax
  000ef	48 8d 4c 24 34	 lea	 rcx, QWORD PTR temp$[rsp]
  000f4	e8 00 00 00 00	 call	 store_fw_noswap

; 348  :     memcpy( main1, temp,       len );

  000f9	48 63 44 24 30	 movsxd	 rax, DWORD PTR len$[rsp]
  000fe	48 8d 4c 24 34	 lea	 rcx, QWORD PTR temp$[rsp]
  00103	48 8b 7c 24 40	 mov	 rdi, QWORD PTR main1$[rsp]
  00108	48 8b f1	 mov	 rsi, rcx
  0010b	48 8b c8	 mov	 rcx, rax
  0010e	f3 a4		 rep movsb

; 349  :     memcpy( main2, temp+len, 4-len );

  00110	b8 04 00 00 00	 mov	 eax, 4
  00115	2b 44 24 30	 sub	 eax, DWORD PTR len$[rsp]
  00119	48 98		 cdqe
  0011b	48 63 4c 24 30	 movsxd	 rcx, DWORD PTR len$[rsp]
  00120	48 8d 4c 0c 34	 lea	 rcx, QWORD PTR temp$[rsp+rcx]
  00125	48 8b 7c 24 48	 mov	 rdi, QWORD PTR main2$[rsp]
  0012a	48 8b f1	 mov	 rsi, rcx
  0012d	48 8b c8	 mov	 rcx, rax
  00130	f3 a4		 rep movsb

; 350  : }

  00132	48 83 c4 58	 add	 rsp, 88			; 00000058H
  00136	5f		 pop	 rdi
  00137	5e		 pop	 rsi
  00138	c3		 ret	 0
s370_vstore4_full ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\dat.h
;	COMDAT s370_maddr_l
_TEXT	SEGMENT
tlbix$ = 48
aea_crn$ = 52
tv70 = 56
maddr$ = 64
addr$ = 96
len$ = 104
arn$ = 112
regs$ = 120
acctype$ = 128
akey$ = 136
s370_maddr_l PROC					; COMDAT

; 307  : {

$LN14:
  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	89 4c 24 08	 mov	 DWORD PTR [rsp+8], ecx
  00013	48 83 ec 58	 sub	 rsp, 88			; 00000058H

; 308  :     /* Note: ALL of the below conditions must be true for a TLB hit
; 309  :        to occur.  If ANY of them are false, then it's a TLB miss,
; 310  :        requiring us to then perform a full DAT address translation.
; 311  : 
; 312  :        Note too that on the grand scheme of things the order/sequence
; 313  :        of the below tests (if statements) is completely unimportant
; 314  :        since ALL conditions must be checked anyway in order for a hit
; 315  :        to occur, and it doesn't matter that a miss tests a few extra
; 316  :        conditions since it's going to do a full translation anyway!
; 317  :        (which is many, many instructions)
; 318  :     */
; 319  : 
; 320  :     int  aea_crn  = (arn >= USE_ARMODE) ? 0 : regs->AEA_AR( arn );

  00017	83 7c 24 70 10	 cmp	 DWORD PTR arn$[rsp], 16
  0001c	7c 0a		 jl	 SHORT $LN12@s370_maddr
  0001e	c7 44 24 38 00
	00 00 00	 mov	 DWORD PTR tv70[rsp], 0
  00026	eb 19		 jmp	 SHORT $LN13@s370_maddr
$LN12@s370_maddr:
  00028	8b 44 24 70	 mov	 eax, DWORD PTR arn$[rsp]
  0002c	83 c0 05	 add	 eax, 5
  0002f	48 98		 cdqe
  00031	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  00036	8b 84 81 94 0c
	00 00		 mov	 eax, DWORD PTR [rcx+rax*4+3220]
  0003d	89 44 24 38	 mov	 DWORD PTR tv70[rsp], eax
$LN13@s370_maddr:
  00041	8b 44 24 38	 mov	 eax, DWORD PTR tv70[rsp]
  00045	89 44 24 34	 mov	 DWORD PTR aea_crn$[rsp], eax

; 321  :     U16  tlbix    = TLBIX( addr );

  00049	8b 44 24 60	 mov	 eax, DWORD PTR addr$[rsp]
  0004d	c1 e8 0b	 shr	 eax, 11
  00050	25 ff 03 00 00	 and	 eax, 1023		; 000003ffH
  00055	66 89 44 24 30	 mov	 WORD PTR tlbix$[rsp], ax

; 322  :     BYTE *maddr   = NULL;

  0005a	48 c7 44 24 40
	00 00 00 00	 mov	 QWORD PTR maddr$[rsp], 0

; 323  : 
; 324  :     /* Non-zero AEA Control Register number? */
; 325  :     if (aea_crn)

  00063	83 7c 24 34 00	 cmp	 DWORD PTR aea_crn$[rsp], 0
  00068	0f 84 25 01 00
	00		 je	 $LN2@s370_maddr

; 326  :     {
; 327  :         /* Same Addess Space Designator as before? */
; 328  :         /* Or if not, is address in a common segment? */
; 329  :         if (0
; 330  :             || (regs->CR( aea_crn ) == regs->tlb.TLB_ASD( tlbix ))
; 331  :             || (regs->AEA_COMMON( aea_crn ) & regs->tlb.common[ tlbix ])

  0006e	33 c0		 xor	 eax, eax
  00070	85 c0		 test	 eax, eax
  00072	75 59		 jne	 SHORT $LN4@s370_maddr
  00074	8b 44 24 34	 mov	 eax, DWORD PTR aea_crn$[rsp]
  00078	ff c0		 inc	 eax
  0007a	48 98		 cdqe
  0007c	0f b7 4c 24 30	 movzx	 ecx, WORD PTR tlbix$[rsp]
  00081	48 8b 54 24 78	 mov	 rdx, QWORD PTR regs$[rsp]
  00086	4c 8b 44 24 78	 mov	 r8, QWORD PTR regs$[rsp]
  0008b	41 8b 8c c8 60
	b0 00 00	 mov	 ecx, DWORD PTR [r8+rcx*8+45152]
  00093	39 8c c2 00 06
	00 00		 cmp	 DWORD PTR [rdx+rax*8+1536], ecx
  0009a	74 31		 je	 SHORT $LN4@s370_maddr
  0009c	8b 44 24 34	 mov	 eax, DWORD PTR aea_crn$[rsp]
  000a0	ff c0		 inc	 eax
  000a2	48 98		 cdqe
  000a4	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  000a9	0f b6 84 01 e8
	0c 00 00	 movzx	 eax, BYTE PTR [rcx+rax+3304]
  000b1	0f b7 4c 24 30	 movzx	 ecx, WORD PTR tlbix$[rsp]
  000b6	48 8b 54 24 78	 mov	 rdx, QWORD PTR regs$[rsp]
  000bb	0f b6 8c 0a 60
	54 01 00	 movzx	 ecx, BYTE PTR [rdx+rcx+87136]
  000c3	23 c1		 and	 eax, ecx
  000c5	85 c0		 test	 eax, eax
  000c7	0f 84 c6 00 00
	00		 je	 $LN3@s370_maddr
$LN4@s370_maddr:

; 332  :         )
; 333  :         {
; 334  :             /* Storage Key zero? */
; 335  :             /* Or if not, same Storage Key as before? */
; 336  :             if (0
; 337  :                 || akey == 0
; 338  :                 || akey == regs->tlb.skey[ tlbix ]

  000cd	33 c0		 xor	 eax, eax
  000cf	85 c0		 test	 eax, eax
  000d1	75 2e		 jne	 SHORT $LN6@s370_maddr
  000d3	0f b6 84 24 88
	00 00 00	 movzx	 eax, BYTE PTR akey$[rsp]
  000db	85 c0		 test	 eax, eax
  000dd	74 22		 je	 SHORT $LN6@s370_maddr
  000df	0f b6 84 24 88
	00 00 00	 movzx	 eax, BYTE PTR akey$[rsp]
  000e7	0f b7 4c 24 30	 movzx	 ecx, WORD PTR tlbix$[rsp]
  000ec	48 8b 54 24 78	 mov	 rdx, QWORD PTR regs$[rsp]
  000f1	0f b6 8c 0a 60
	50 01 00	 movzx	 ecx, BYTE PTR [rdx+rcx+86112]
  000f9	3b c1		 cmp	 eax, ecx
  000fb	0f 85 92 00 00
	00		 jne	 $LN5@s370_maddr
$LN6@s370_maddr:

; 339  :             )
; 340  :             {
; 341  :                 /* Does the page address match the one in the TLB? */
; 342  :                 /* (does a TLB entry exist for this page address?) */
; 343  :                 if (
; 344  :                     ((addr & TLBID_PAGEMASK) | regs->tlbID)
; 345  :                     ==

  00101	8b 44 24 60	 mov	 eax, DWORD PTR addr$[rsp]
  00105	25 00 00 e0 00	 and	 eax, 14680064		; 00e00000H
  0010a	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  0010f	0b 81 58 b0 00
	00		 or	 eax, DWORD PTR [rcx+45144]
  00115	0f b7 4c 24 30	 movzx	 ecx, WORD PTR tlbix$[rsp]
  0011a	48 8b 54 24 78	 mov	 rdx, QWORD PTR regs$[rsp]
  0011f	3b 84 ca 60 d0
	00 00		 cmp	 eax, DWORD PTR [rdx+rcx*8+53344]
  00126	75 6b		 jne	 SHORT $LN7@s370_maddr

; 346  :                     regs->tlb.TLB_VADDR( tlbix )
; 347  :                 )
; 348  :                 {
; 349  :                     /* Is storage being accessed same way as before? */
; 350  :                     if (acctype & regs->tlb.acc[ tlbix ])

  00128	0f b7 44 24 30	 movzx	 eax, WORD PTR tlbix$[rsp]
  0012d	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  00132	0f b6 84 01 60
	5c 01 00	 movzx	 eax, BYTE PTR [rcx+rax+89184]
  0013a	8b 8c 24 80 00
	00 00		 mov	 ecx, DWORD PTR acctype$[rsp]
  00141	23 c8		 and	 ecx, eax
  00143	8b c1		 mov	 eax, ecx
  00145	85 c0		 test	 eax, eax
  00147	74 4a		 je	 SHORT $LN8@s370_maddr

; 351  :                     {
; 352  :                         /*------------------------------------------*/
; 353  :                         /* TLB hit: use previously translated value */
; 354  :                         /*------------------------------------------*/
; 355  : 
; 356  :                         if (acctype & ACC_CHECK)

  00149	8b 84 24 80 00
	00 00		 mov	 eax, DWORD PTR acctype$[rsp]
  00150	83 e0 01	 and	 eax, 1
  00153	85 c0		 test	 eax, eax
  00155	74 1e		 je	 SHORT $LN9@s370_maddr

; 357  :                             regs->dat.storkey = regs->tlb.storkey[ tlbix ];

  00157	0f b7 44 24 30	 movzx	 eax, WORD PTR tlbix$[rsp]
  0015c	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  00161	48 8b 54 24 78	 mov	 rdx, QWORD PTR regs$[rsp]
  00166	48 8b 84 c2 60
	30 01 00	 mov	 rax, QWORD PTR [rdx+rax*8+77920]
  0016e	48 89 81 28 08
	00 00		 mov	 QWORD PTR [rcx+2088], rax
$LN9@s370_maddr:

; 358  : 
; 359  :                         maddr = MAINADDR( regs->tlb.main[tlbix], addr );

  00175	0f b7 44 24 30	 movzx	 eax, WORD PTR tlbix$[rsp]
  0017a	8b 4c 24 60	 mov	 ecx, DWORD PTR addr$[rsp]
  0017e	48 8b 54 24 78	 mov	 rdx, QWORD PTR regs$[rsp]
  00183	48 8b 84 c2 60
	10 01 00	 mov	 rax, QWORD PTR [rdx+rax*8+69728]
  0018b	48 33 c1	 xor	 rax, rcx
  0018e	48 89 44 24 40	 mov	 QWORD PTR maddr$[rsp], rax
$LN8@s370_maddr:
$LN7@s370_maddr:
$LN5@s370_maddr:
$LN3@s370_maddr:
$LN2@s370_maddr:

; 360  :                     }
; 361  :                 }
; 362  :             }
; 363  :         }
; 364  :     }
; 365  : 
; 366  :     /*---------------------------------------*/
; 367  :     /* TLB miss: do full address translation */
; 368  :     /*---------------------------------------*/
; 369  :     if (!maddr)

  00193	48 83 7c 24 40
	00		 cmp	 QWORD PTR maddr$[rsp], 0
  00199	75 35		 jne	 SHORT $LN10@s370_maddr

; 370  :         maddr = ARCH_DEP( logical_to_main_l )( addr, arn, regs, acctype, akey, len );

  0019b	48 8b 44 24 68	 mov	 rax, QWORD PTR len$[rsp]
  001a0	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  001a5	0f b6 84 24 88
	00 00 00	 movzx	 eax, BYTE PTR akey$[rsp]
  001ad	88 44 24 20	 mov	 BYTE PTR [rsp+32], al
  001b1	44 8b 8c 24 80
	00 00 00	 mov	 r9d, DWORD PTR acctype$[rsp]
  001b9	4c 8b 44 24 78	 mov	 r8, QWORD PTR regs$[rsp]
  001be	8b 54 24 70	 mov	 edx, DWORD PTR arn$[rsp]
  001c2	8b 4c 24 60	 mov	 ecx, DWORD PTR addr$[rsp]
  001c6	e8 00 00 00 00	 call	 s370_logical_to_main_l
  001cb	48 89 44 24 40	 mov	 QWORD PTR maddr$[rsp], rax
$LN10@s370_maddr:

; 371  : 
; 372  : #if defined( FEATURE_073_TRANSACT_EXEC_FACILITY )
; 373  :     if (FACILITY_ENABLED( 073_TRANSACT_EXEC, regs ))
; 374  :     {
; 375  :         /* SA22-7832-12 Principles of Operation, page 5-99:
; 376  : 
; 377  :              "Storage accesses for instruction and DAT- and ART-
; 378  :               table fetches follow the non-transactional rules."
; 379  :         */
; 380  :         if (0
; 381  :             || !regs
; 382  :             || !regs->txf_tnd
; 383  :             || arn == USE_INST_SPACE    /* Instruction fetching */
; 384  :             || arn == USE_REAL_ADDR     /* Address translation  */
; 385  :         )
; 386  :             return maddr;
; 387  : 
; 388  :         /* Quick exit if NTSTG call */
; 389  :         if (regs->txf_NTSTG)
; 390  :         {
; 391  :             regs->txf_NTSTG = false;
; 392  :             return maddr;
; 393  :         }
; 394  : 
; 395  :         /* Translate to alternate TXF address */
; 396  :         maddr = TXF_MADDRL( addr, len, arn, regs, acctype, maddr );
; 397  :     }
; 398  : #endif
; 399  : 
; 400  :     return maddr;

  001d0	48 8b 44 24 40	 mov	 rax, QWORD PTR maddr$[rsp]

; 401  : }

  001d5	48 83 c4 58	 add	 rsp, 88			; 00000058H
  001d9	c3		 ret	 0
s370_maddr_l ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\machdep.h
;	COMDAT store_fw_noswap
_TEXT	SEGMENT
ptr$ = 8
value$ = 16
store_fw_noswap PROC					; COMDAT

; 764  :     inline void store_fw_noswap(void *ptr, U32 value) {

  00000	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00004	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx

; 765  :       memcpy((BYTE *)ptr, (BYTE *)&value, 4);

  00009	48 8b 44 24 08	 mov	 rax, QWORD PTR ptr$[rsp]
  0000e	8b 4c 24 10	 mov	 ecx, DWORD PTR value$[rsp]
  00012	89 08		 mov	 DWORD PTR [rax], ecx

; 766  :     }

  00014	c3		 ret	 0
store_fw_noswap ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\machdep.h
;	COMDAT fetch_fw_noswap
_TEXT	SEGMENT
value$ = 0
ptr$ = 32
fetch_fw_noswap PROC					; COMDAT

; 746  :     inline U32 fetch_fw_noswap(const void *ptr) {

$LN3:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 18	 sub	 rsp, 24

; 747  :       U32 value;
; 748  :       memcpy(&value, (BYTE *)ptr, 4);

  00009	48 8b 44 24 20	 mov	 rax, QWORD PTR ptr$[rsp]
  0000e	8b 00		 mov	 eax, DWORD PTR [rax]
  00010	89 04 24	 mov	 DWORD PTR value$[rsp], eax

; 749  :       return value;

  00013	8b 04 24	 mov	 eax, DWORD PTR value$[rsp]

; 750  :     }

  00016	48 83 c4 18	 add	 rsp, 24
  0001a	c3		 ret	 0
fetch_fw_noswap ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\machdep.h
;	COMDAT cmpxchg4_x86
_TEXT	SEGMENT
tv69 = 0
tv71 = 4
tmp$ = 8
old$ = 32
unew$ = 40
ptr$ = 48
cmpxchg4_x86 PROC					; COMDAT

; 104  :     {

$LN5:
  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00009	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000e	48 83 ec 18	 sub	 rsp, 24

; 105  :         // returns 0 == success, 1 otherwise
; 106  :         U32 tmp = *old;

  00012	48 8b 44 24 20	 mov	 rax, QWORD PTR old$[rsp]
  00017	8b 00		 mov	 eax, DWORD PTR [rax]
  00019	89 44 24 08	 mov	 DWORD PTR tmp$[rsp], eax

; 107  :         *old = _InterlockedCompareExchange( ptr, unew, *old );

  0001d	8b 44 24 28	 mov	 eax, DWORD PTR unew$[rsp]
  00021	89 44 24 04	 mov	 DWORD PTR tv71[rsp], eax
  00025	48 8b 4c 24 30	 mov	 rcx, QWORD PTR ptr$[rsp]
  0002a	48 8b 54 24 20	 mov	 rdx, QWORD PTR old$[rsp]
  0002f	8b 02		 mov	 eax, DWORD PTR [rdx]
  00031	8b 54 24 04	 mov	 edx, DWORD PTR tv71[rsp]
  00035	f0 0f b1 11	 lock cmpxchg DWORD PTR [rcx], edx
  00039	48 8b 4c 24 20	 mov	 rcx, QWORD PTR old$[rsp]
  0003e	89 01		 mov	 DWORD PTR [rcx], eax

; 108  :         return ((tmp == *old) ? 0 : 1);

  00040	48 8b 44 24 20	 mov	 rax, QWORD PTR old$[rsp]
  00045	8b 00		 mov	 eax, DWORD PTR [rax]
  00047	39 44 24 08	 cmp	 DWORD PTR tmp$[rsp], eax
  0004b	75 09		 jne	 SHORT $LN3@cmpxchg4_x
  0004d	c7 04 24 00 00
	00 00		 mov	 DWORD PTR tv69[rsp], 0
  00054	eb 07		 jmp	 SHORT $LN4@cmpxchg4_x
$LN3@cmpxchg4_x:
  00056	c7 04 24 01 00
	00 00		 mov	 DWORD PTR tv69[rsp], 1
$LN4@cmpxchg4_x:
  0005d	0f b6 04 24	 movzx	 eax, BYTE PTR tv69[rsp]

; 109  :     }

  00061	48 83 c4 18	 add	 rsp, 24
  00065	c3		 ret	 0
cmpxchg4_x86 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\assist.c
_TEXT	SEGMENT
effective_addr2$ = 64
effective_addr1$ = 68
temp$1 = 72
b1$ = 76
b2$ = 80
inst$ = 112
regs$ = 120
s370_trace_task_dispatch PROC

; 633  : {

$LN18:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 68	 sub	 rsp, 104		; 00000068H

; 634  : int     b1, b2;                         /* Values of base field      */
; 635  : VADR    effective_addr1,
; 636  :         effective_addr2;                /* Effective addresses       */
; 637  : 
; 638  :     SSE(inst, regs, b1, effective_addr1, b2, effective_addr2);

  0000e	48 8b 44 24 70	 mov	 rax, QWORD PTR inst$[rsp]
  00013	48 83 c0 02	 add	 rax, 2
  00017	48 8b c8	 mov	 rcx, rax
  0001a	e8 00 00 00 00	 call	 fetch_fw_noswap
  0001f	8b c8		 mov	 ecx, eax
  00021	e8 00 00 00 00	 call	 _byteswap_ulong
  00026	89 44 24 48	 mov	 DWORD PTR temp$1[rsp], eax
  0002a	8b 44 24 48	 mov	 eax, DWORD PTR temp$1[rsp]
  0002e	25 ff 0f 00 00	 and	 eax, 4095		; 00000fffH
  00033	89 44 24 40	 mov	 DWORD PTR effective_addr2$[rsp], eax
  00037	8b 44 24 48	 mov	 eax, DWORD PTR temp$1[rsp]
  0003b	c1 e8 0c	 shr	 eax, 12
  0003e	83 e0 0f	 and	 eax, 15
  00041	89 44 24 50	 mov	 DWORD PTR b2$[rsp], eax
  00045	8b 44 24 48	 mov	 eax, DWORD PTR temp$1[rsp]
  00049	c1 e8 10	 shr	 eax, 16
  0004c	25 ff 0f 00 00	 and	 eax, 4095		; 00000fffH
  00051	89 44 24 44	 mov	 DWORD PTR effective_addr1$[rsp], eax
  00055	8b 44 24 48	 mov	 eax, DWORD PTR temp$1[rsp]
  00059	c1 e8 1c	 shr	 eax, 28
  0005c	83 e0 0f	 and	 eax, 15
  0005f	89 44 24 4c	 mov	 DWORD PTR b1$[rsp], eax
  00063	83 7c 24 4c 00	 cmp	 DWORD PTR b1$[rsp], 0
  00068	74 2a		 je	 SHORT $LN8@s370_trace
  0006a	48 63 44 24 4c	 movsxd	 rax, DWORD PTR b1$[rsp]
  0006f	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  00074	8b 84 c1 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax*8+640]
  0007b	8b 4c 24 44	 mov	 ecx, DWORD PTR effective_addr1$[rsp]
  0007f	03 c8		 add	 ecx, eax
  00081	8b c1		 mov	 eax, ecx
  00083	89 44 24 44	 mov	 DWORD PTR effective_addr1$[rsp], eax
  00087	8b 44 24 44	 mov	 eax, DWORD PTR effective_addr1$[rsp]
  0008b	25 ff ff ff 00	 and	 eax, 16777215		; 00ffffffH
  00090	89 44 24 44	 mov	 DWORD PTR effective_addr1$[rsp], eax
$LN8@s370_trace:
  00094	83 7c 24 50 00	 cmp	 DWORD PTR b2$[rsp], 0
  00099	74 2a		 je	 SHORT $LN9@s370_trace
  0009b	48 63 44 24 50	 movsxd	 rax, DWORD PTR b2$[rsp]
  000a0	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  000a5	8b 84 c1 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax*8+640]
  000ac	8b 4c 24 40	 mov	 ecx, DWORD PTR effective_addr2$[rsp]
  000b0	03 c8		 add	 ecx, eax
  000b2	8b c1		 mov	 eax, ecx
  000b4	89 44 24 40	 mov	 DWORD PTR effective_addr2$[rsp], eax
  000b8	8b 44 24 40	 mov	 eax, DWORD PTR effective_addr2$[rsp]
  000bc	25 ff ff ff 00	 and	 eax, 16777215		; 00ffffffH
  000c1	89 44 24 40	 mov	 DWORD PTR effective_addr2$[rsp], eax
$LN9@s370_trace:
$LN4@s370_trace:
  000c5	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  000ca	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  000ce	48 83 c0 06	 add	 rax, 6
  000d2	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  000d7	48 89 41 68	 mov	 QWORD PTR [rcx+104], rax
  000db	33 c0		 xor	 eax, eax
  000dd	83 f8 06	 cmp	 eax, 6
  000e0	74 0c		 je	 SHORT $LN10@s370_trace
  000e2	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  000e7	c6 80 9a 00 00
	00 06		 mov	 BYTE PTR [rax+154], 6
$LN10@s370_trace:
  000ee	33 c0		 xor	 eax, eax
  000f0	85 c0		 test	 eax, eax
  000f2	75 d1		 jne	 SHORT $LN4@s370_trace

; 639  :     PER_ZEROADDR_XCHECK2( regs, b1, b2 );
; 640  : 
; 641  :     GUEST_CHECK( );

  000f4	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  000f9	0f b6 40 7a	 movzx	 eax, BYTE PTR [rax+122]
  000fd	83 e0 01	 and	 eax, 1
  00100	85 c0		 test	 eax, eax
  00102	74 44		 je	 SHORT $LN11@s370_trace
  00104	b8 08 00 00 00	 mov	 eax, 8
  00109	48 6b c0 07	 imul	 rax, rax, 7
  0010d	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  00112	8b 84 01 00 06
	00 00		 mov	 eax, DWORD PTR [rcx+rax+1536]
  00119	25 04 00 00 40	 and	 eax, 1073741828		; 40000004H
  0011e	83 f8 04	 cmp	 eax, 4
  00121	74 25		 je	 SHORT $LN12@s370_trace
  00123	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  00128	0f b6 40 7a	 movzx	 eax, BYTE PTR [rax+122]
  0012c	83 e0 01	 and	 eax, 1
  0012f	85 c0		 test	 eax, eax
  00131	74 15		 je	 SHORT $LN13@s370_trace
  00133	ba 02 00 00 00	 mov	 edx, 2
  00138	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  0013d	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  00142	ff 90 20 0d 00
	00		 call	 QWORD PTR [rax+3360]
$LN13@s370_trace:
$LN12@s370_trace:
$LN11@s370_trace:

; 642  : 
; 643  :     /* Specification exception if operands are not on word boundary */
; 644  :     if ((effective_addr1 & 0x00000003) || (effective_addr2 & 0x00000003))

  00148	8b 44 24 44	 mov	 eax, DWORD PTR effective_addr1$[rsp]
  0014c	83 e0 03	 and	 eax, 3
  0014f	85 c0		 test	 eax, eax
  00151	75 0b		 jne	 SHORT $LN15@s370_trace
  00153	8b 44 24 40	 mov	 eax, DWORD PTR effective_addr2$[rsp]
  00157	83 e0 03	 and	 eax, 3
  0015a	85 c0		 test	 eax, eax
  0015c	74 0f		 je	 SHORT $LN14@s370_trace
$LN15@s370_trace:

; 645  :         ARCH_DEP(program_interrupt) (regs, PGM_SPECIFICATION_EXCEPTION);

  0015e	ba 06 00 00 00	 mov	 edx, 6
  00163	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  00168	e8 00 00 00 00	 call	 s370_program_interrupt
$LN14@s370_trace:
$LN7@s370_trace:

; 646  : 
; 647  :     PTT_ERR("*E50C TRTSK",effective_addr1,effective_addr2,regs->psw.IA_L);

  0016d	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_pttclass
  00174	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00177	48 83 e0 10	 and	 rax, 16
  0017b	48 85 c0	 test	 rax, rax
  0017e	74 45		 je	 SHORT $LN16@s370_trace
  00180	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  00185	8b 80 88 00 00
	00		 mov	 eax, DWORD PTR [rax+136]
  0018b	8b 4c 24 40	 mov	 ecx, DWORD PTR effective_addr2$[rsp]
  0018f	8b 54 24 44	 mov	 edx, DWORD PTR effective_addr1$[rsp]
  00193	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR [rsp+48], 0
  0019c	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  001a1	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG170032
  001a8	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  001ad	44 8b c9	 mov	 r9d, ecx
  001b0	44 8b c2	 mov	 r8d, edx
  001b3	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG170033
  001ba	b9 10 00 00 00	 mov	 ecx, 16
  001bf	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ptt_pthread_trace
$LN16@s370_trace:
  001c5	33 c0		 xor	 eax, eax
  001c7	85 c0		 test	 eax, eax
  001c9	75 a2		 jne	 SHORT $LN7@s370_trace

; 648  :     /*INCOMPLETE: NO TRACE ENTRY IS GENERATED*/
; 649  : }

  001cb	48 83 c4 68	 add	 rsp, 104		; 00000068H
  001cf	c3		 ret	 0
s370_trace_task_dispatch ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\assist.c
_TEXT	SEGMENT
effective_addr2$ = 64
effective_addr1$ = 68
temp$1 = 72
b1$ = 76
b2$ = 80
inst$ = 112
regs$ = 120
s370_trace_svc_return PROC

; 656  : {

$LN18:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 68	 sub	 rsp, 104		; 00000068H

; 657  : int     b1, b2;                         /* Values of base field      */
; 658  : VADR    effective_addr1,
; 659  :         effective_addr2;                /* Effective addresses       */
; 660  : 
; 661  :     SSE(inst, regs, b1, effective_addr1, b2, effective_addr2);

  0000e	48 8b 44 24 70	 mov	 rax, QWORD PTR inst$[rsp]
  00013	48 83 c0 02	 add	 rax, 2
  00017	48 8b c8	 mov	 rcx, rax
  0001a	e8 00 00 00 00	 call	 fetch_fw_noswap
  0001f	8b c8		 mov	 ecx, eax
  00021	e8 00 00 00 00	 call	 _byteswap_ulong
  00026	89 44 24 48	 mov	 DWORD PTR temp$1[rsp], eax
  0002a	8b 44 24 48	 mov	 eax, DWORD PTR temp$1[rsp]
  0002e	25 ff 0f 00 00	 and	 eax, 4095		; 00000fffH
  00033	89 44 24 40	 mov	 DWORD PTR effective_addr2$[rsp], eax
  00037	8b 44 24 48	 mov	 eax, DWORD PTR temp$1[rsp]
  0003b	c1 e8 0c	 shr	 eax, 12
  0003e	83 e0 0f	 and	 eax, 15
  00041	89 44 24 50	 mov	 DWORD PTR b2$[rsp], eax
  00045	8b 44 24 48	 mov	 eax, DWORD PTR temp$1[rsp]
  00049	c1 e8 10	 shr	 eax, 16
  0004c	25 ff 0f 00 00	 and	 eax, 4095		; 00000fffH
  00051	89 44 24 44	 mov	 DWORD PTR effective_addr1$[rsp], eax
  00055	8b 44 24 48	 mov	 eax, DWORD PTR temp$1[rsp]
  00059	c1 e8 1c	 shr	 eax, 28
  0005c	83 e0 0f	 and	 eax, 15
  0005f	89 44 24 4c	 mov	 DWORD PTR b1$[rsp], eax
  00063	83 7c 24 4c 00	 cmp	 DWORD PTR b1$[rsp], 0
  00068	74 2a		 je	 SHORT $LN8@s370_trace
  0006a	48 63 44 24 4c	 movsxd	 rax, DWORD PTR b1$[rsp]
  0006f	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  00074	8b 84 c1 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax*8+640]
  0007b	8b 4c 24 44	 mov	 ecx, DWORD PTR effective_addr1$[rsp]
  0007f	03 c8		 add	 ecx, eax
  00081	8b c1		 mov	 eax, ecx
  00083	89 44 24 44	 mov	 DWORD PTR effective_addr1$[rsp], eax
  00087	8b 44 24 44	 mov	 eax, DWORD PTR effective_addr1$[rsp]
  0008b	25 ff ff ff 00	 and	 eax, 16777215		; 00ffffffH
  00090	89 44 24 44	 mov	 DWORD PTR effective_addr1$[rsp], eax
$LN8@s370_trace:
  00094	83 7c 24 50 00	 cmp	 DWORD PTR b2$[rsp], 0
  00099	74 2a		 je	 SHORT $LN9@s370_trace
  0009b	48 63 44 24 50	 movsxd	 rax, DWORD PTR b2$[rsp]
  000a0	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  000a5	8b 84 c1 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax*8+640]
  000ac	8b 4c 24 40	 mov	 ecx, DWORD PTR effective_addr2$[rsp]
  000b0	03 c8		 add	 ecx, eax
  000b2	8b c1		 mov	 eax, ecx
  000b4	89 44 24 40	 mov	 DWORD PTR effective_addr2$[rsp], eax
  000b8	8b 44 24 40	 mov	 eax, DWORD PTR effective_addr2$[rsp]
  000bc	25 ff ff ff 00	 and	 eax, 16777215		; 00ffffffH
  000c1	89 44 24 40	 mov	 DWORD PTR effective_addr2$[rsp], eax
$LN9@s370_trace:
$LN4@s370_trace:
  000c5	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  000ca	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  000ce	48 83 c0 06	 add	 rax, 6
  000d2	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  000d7	48 89 41 68	 mov	 QWORD PTR [rcx+104], rax
  000db	33 c0		 xor	 eax, eax
  000dd	83 f8 06	 cmp	 eax, 6
  000e0	74 0c		 je	 SHORT $LN10@s370_trace
  000e2	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  000e7	c6 80 9a 00 00
	00 06		 mov	 BYTE PTR [rax+154], 6
$LN10@s370_trace:
  000ee	33 c0		 xor	 eax, eax
  000f0	85 c0		 test	 eax, eax
  000f2	75 d1		 jne	 SHORT $LN4@s370_trace

; 662  :     PER_ZEROADDR_XCHECK2( regs, b1, b2 );
; 663  : 
; 664  :     GUEST_CHECK( );

  000f4	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  000f9	0f b6 40 7a	 movzx	 eax, BYTE PTR [rax+122]
  000fd	83 e0 01	 and	 eax, 1
  00100	85 c0		 test	 eax, eax
  00102	74 44		 je	 SHORT $LN11@s370_trace
  00104	b8 08 00 00 00	 mov	 eax, 8
  00109	48 6b c0 07	 imul	 rax, rax, 7
  0010d	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  00112	8b 84 01 00 06
	00 00		 mov	 eax, DWORD PTR [rcx+rax+1536]
  00119	25 04 00 00 40	 and	 eax, 1073741828		; 40000004H
  0011e	83 f8 04	 cmp	 eax, 4
  00121	74 25		 je	 SHORT $LN12@s370_trace
  00123	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  00128	0f b6 40 7a	 movzx	 eax, BYTE PTR [rax+122]
  0012c	83 e0 01	 and	 eax, 1
  0012f	85 c0		 test	 eax, eax
  00131	74 15		 je	 SHORT $LN13@s370_trace
  00133	ba 02 00 00 00	 mov	 edx, 2
  00138	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  0013d	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  00142	ff 90 20 0d 00
	00		 call	 QWORD PTR [rax+3360]
$LN13@s370_trace:
$LN12@s370_trace:
$LN11@s370_trace:

; 665  : 
; 666  :     /* Specification exception if operands are not on word boundary */
; 667  :     if ((effective_addr1 & 0x00000003) || (effective_addr2 & 0x00000003))

  00148	8b 44 24 44	 mov	 eax, DWORD PTR effective_addr1$[rsp]
  0014c	83 e0 03	 and	 eax, 3
  0014f	85 c0		 test	 eax, eax
  00151	75 0b		 jne	 SHORT $LN15@s370_trace
  00153	8b 44 24 40	 mov	 eax, DWORD PTR effective_addr2$[rsp]
  00157	83 e0 03	 and	 eax, 3
  0015a	85 c0		 test	 eax, eax
  0015c	74 0f		 je	 SHORT $LN14@s370_trace
$LN15@s370_trace:

; 668  :         ARCH_DEP(program_interrupt) (regs, PGM_SPECIFICATION_EXCEPTION);

  0015e	ba 06 00 00 00	 mov	 edx, 6
  00163	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  00168	e8 00 00 00 00	 call	 s370_program_interrupt
$LN14@s370_trace:
$LN7@s370_trace:

; 669  : 
; 670  :     PTT_ERR("*E50D TRRTN",effective_addr1,effective_addr2,regs->psw.IA_L);

  0016d	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_pttclass
  00174	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00177	48 83 e0 10	 and	 rax, 16
  0017b	48 85 c0	 test	 rax, rax
  0017e	74 45		 je	 SHORT $LN16@s370_trace
  00180	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  00185	8b 80 88 00 00
	00		 mov	 eax, DWORD PTR [rax+136]
  0018b	8b 4c 24 40	 mov	 ecx, DWORD PTR effective_addr2$[rsp]
  0018f	8b 54 24 44	 mov	 edx, DWORD PTR effective_addr1$[rsp]
  00193	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR [rsp+48], 0
  0019c	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  001a1	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG170067
  001a8	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  001ad	44 8b c9	 mov	 r9d, ecx
  001b0	44 8b c2	 mov	 r8d, edx
  001b3	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG170068
  001ba	b9 10 00 00 00	 mov	 ecx, 16
  001bf	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ptt_pthread_trace
$LN16@s370_trace:
  001c5	33 c0		 xor	 eax, eax
  001c7	85 c0		 test	 eax, eax
  001c9	75 a2		 jne	 SHORT $LN7@s370_trace

; 671  :     /*INCOMPLETE: NO TRACE ENTRY IS GENERATED*/
; 672  : }

  001cb	48 83 c4 68	 add	 rsp, 104		; 00000068H
  001cf	c3		 ret	 0
s370_trace_svc_return ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\assist.c
_TEXT	SEGMENT
effective_addr2$ = 64
effective_addr1$ = 68
temp$1 = 72
b1$ = 76
b2$ = 80
inst$ = 112
regs$ = 120
s370_trace_svc_interruption PROC

; 541  : {

$LN18:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 68	 sub	 rsp, 104		; 00000068H

; 542  : int     b1, b2;                         /* Values of base field      */
; 543  : VADR    effective_addr1,
; 544  :         effective_addr2;                /* Effective addresses       */
; 545  : 
; 546  :     SSE(inst, regs, b1, effective_addr1, b2, effective_addr2);

  0000e	48 8b 44 24 70	 mov	 rax, QWORD PTR inst$[rsp]
  00013	48 83 c0 02	 add	 rax, 2
  00017	48 8b c8	 mov	 rcx, rax
  0001a	e8 00 00 00 00	 call	 fetch_fw_noswap
  0001f	8b c8		 mov	 ecx, eax
  00021	e8 00 00 00 00	 call	 _byteswap_ulong
  00026	89 44 24 48	 mov	 DWORD PTR temp$1[rsp], eax
  0002a	8b 44 24 48	 mov	 eax, DWORD PTR temp$1[rsp]
  0002e	25 ff 0f 00 00	 and	 eax, 4095		; 00000fffH
  00033	89 44 24 40	 mov	 DWORD PTR effective_addr2$[rsp], eax
  00037	8b 44 24 48	 mov	 eax, DWORD PTR temp$1[rsp]
  0003b	c1 e8 0c	 shr	 eax, 12
  0003e	83 e0 0f	 and	 eax, 15
  00041	89 44 24 50	 mov	 DWORD PTR b2$[rsp], eax
  00045	8b 44 24 48	 mov	 eax, DWORD PTR temp$1[rsp]
  00049	c1 e8 10	 shr	 eax, 16
  0004c	25 ff 0f 00 00	 and	 eax, 4095		; 00000fffH
  00051	89 44 24 44	 mov	 DWORD PTR effective_addr1$[rsp], eax
  00055	8b 44 24 48	 mov	 eax, DWORD PTR temp$1[rsp]
  00059	c1 e8 1c	 shr	 eax, 28
  0005c	83 e0 0f	 and	 eax, 15
  0005f	89 44 24 4c	 mov	 DWORD PTR b1$[rsp], eax
  00063	83 7c 24 4c 00	 cmp	 DWORD PTR b1$[rsp], 0
  00068	74 2a		 je	 SHORT $LN8@s370_trace
  0006a	48 63 44 24 4c	 movsxd	 rax, DWORD PTR b1$[rsp]
  0006f	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  00074	8b 84 c1 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax*8+640]
  0007b	8b 4c 24 44	 mov	 ecx, DWORD PTR effective_addr1$[rsp]
  0007f	03 c8		 add	 ecx, eax
  00081	8b c1		 mov	 eax, ecx
  00083	89 44 24 44	 mov	 DWORD PTR effective_addr1$[rsp], eax
  00087	8b 44 24 44	 mov	 eax, DWORD PTR effective_addr1$[rsp]
  0008b	25 ff ff ff 00	 and	 eax, 16777215		; 00ffffffH
  00090	89 44 24 44	 mov	 DWORD PTR effective_addr1$[rsp], eax
$LN8@s370_trace:
  00094	83 7c 24 50 00	 cmp	 DWORD PTR b2$[rsp], 0
  00099	74 2a		 je	 SHORT $LN9@s370_trace
  0009b	48 63 44 24 50	 movsxd	 rax, DWORD PTR b2$[rsp]
  000a0	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  000a5	8b 84 c1 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax*8+640]
  000ac	8b 4c 24 40	 mov	 ecx, DWORD PTR effective_addr2$[rsp]
  000b0	03 c8		 add	 ecx, eax
  000b2	8b c1		 mov	 eax, ecx
  000b4	89 44 24 40	 mov	 DWORD PTR effective_addr2$[rsp], eax
  000b8	8b 44 24 40	 mov	 eax, DWORD PTR effective_addr2$[rsp]
  000bc	25 ff ff ff 00	 and	 eax, 16777215		; 00ffffffH
  000c1	89 44 24 40	 mov	 DWORD PTR effective_addr2$[rsp], eax
$LN9@s370_trace:
$LN4@s370_trace:
  000c5	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  000ca	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  000ce	48 83 c0 06	 add	 rax, 6
  000d2	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  000d7	48 89 41 68	 mov	 QWORD PTR [rcx+104], rax
  000db	33 c0		 xor	 eax, eax
  000dd	83 f8 06	 cmp	 eax, 6
  000e0	74 0c		 je	 SHORT $LN10@s370_trace
  000e2	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  000e7	c6 80 9a 00 00
	00 06		 mov	 BYTE PTR [rax+154], 6
$LN10@s370_trace:
  000ee	33 c0		 xor	 eax, eax
  000f0	85 c0		 test	 eax, eax
  000f2	75 d1		 jne	 SHORT $LN4@s370_trace

; 547  :     PER_ZEROADDR_XCHECK2( regs, b1, b2 );
; 548  : 
; 549  :     GUEST_CHECK( );

  000f4	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  000f9	0f b6 40 7a	 movzx	 eax, BYTE PTR [rax+122]
  000fd	83 e0 01	 and	 eax, 1
  00100	85 c0		 test	 eax, eax
  00102	74 44		 je	 SHORT $LN11@s370_trace
  00104	b8 08 00 00 00	 mov	 eax, 8
  00109	48 6b c0 07	 imul	 rax, rax, 7
  0010d	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  00112	8b 84 01 00 06
	00 00		 mov	 eax, DWORD PTR [rcx+rax+1536]
  00119	25 04 00 00 40	 and	 eax, 1073741828		; 40000004H
  0011e	83 f8 04	 cmp	 eax, 4
  00121	74 25		 je	 SHORT $LN12@s370_trace
  00123	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  00128	0f b6 40 7a	 movzx	 eax, BYTE PTR [rax+122]
  0012c	83 e0 01	 and	 eax, 1
  0012f	85 c0		 test	 eax, eax
  00131	74 15		 je	 SHORT $LN13@s370_trace
  00133	ba 02 00 00 00	 mov	 edx, 2
  00138	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  0013d	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  00142	ff 90 20 0d 00
	00		 call	 QWORD PTR [rax+3360]
$LN13@s370_trace:
$LN12@s370_trace:
$LN11@s370_trace:

; 550  : 
; 551  :     /* Specification exception if operands are not on word boundary */
; 552  :     if ((effective_addr1 & 0x00000003) || (effective_addr2 & 0x00000003))

  00148	8b 44 24 44	 mov	 eax, DWORD PTR effective_addr1$[rsp]
  0014c	83 e0 03	 and	 eax, 3
  0014f	85 c0		 test	 eax, eax
  00151	75 0b		 jne	 SHORT $LN15@s370_trace
  00153	8b 44 24 40	 mov	 eax, DWORD PTR effective_addr2$[rsp]
  00157	83 e0 03	 and	 eax, 3
  0015a	85 c0		 test	 eax, eax
  0015c	74 0f		 je	 SHORT $LN14@s370_trace
$LN15@s370_trace:

; 553  :         ARCH_DEP(program_interrupt) (regs, PGM_SPECIFICATION_EXCEPTION);

  0015e	ba 06 00 00 00	 mov	 edx, 6
  00163	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  00168	e8 00 00 00 00	 call	 s370_program_interrupt
$LN14@s370_trace:
$LN7@s370_trace:

; 554  : 
; 555  :     PTT_ERR("*E508 TRSVC",effective_addr1,effective_addr2,regs->psw.IA_L);

  0016d	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_pttclass
  00174	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00177	48 83 e0 10	 and	 rax, 16
  0017b	48 85 c0	 test	 rax, rax
  0017e	74 45		 je	 SHORT $LN16@s370_trace
  00180	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  00185	8b 80 88 00 00
	00		 mov	 eax, DWORD PTR [rax+136]
  0018b	8b 4c 24 40	 mov	 ecx, DWORD PTR effective_addr2$[rsp]
  0018f	8b 54 24 44	 mov	 edx, DWORD PTR effective_addr1$[rsp]
  00193	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR [rsp+48], 0
  0019c	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  001a1	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG169892
  001a8	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  001ad	44 8b c9	 mov	 r9d, ecx
  001b0	44 8b c2	 mov	 r8d, edx
  001b3	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG169893
  001ba	b9 10 00 00 00	 mov	 ecx, 16
  001bf	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ptt_pthread_trace
$LN16@s370_trace:
  001c5	33 c0		 xor	 eax, eax
  001c7	85 c0		 test	 eax, eax
  001c9	75 a2		 jne	 SHORT $LN7@s370_trace

; 556  :     /*INCOMPLETE: NO TRACE ENTRY IS GENERATED*/
; 557  : }

  001cb	48 83 c4 68	 add	 rsp, 104		; 00000068H
  001cf	c3		 ret	 0
s370_trace_svc_interruption ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\assist.c
_TEXT	SEGMENT
effective_addr2$ = 64
effective_addr1$ = 68
temp$1 = 72
b1$ = 76
b2$ = 80
inst$ = 112
regs$ = 120
s370_trace_program_interruption PROC

; 564  : {

$LN18:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 68	 sub	 rsp, 104		; 00000068H

; 565  : int     b1, b2;                         /* Values of base field      */
; 566  : VADR    effective_addr1,
; 567  :         effective_addr2;                /* Effective addresses       */
; 568  : 
; 569  :     SSE(inst, regs, b1, effective_addr1, b2, effective_addr2);

  0000e	48 8b 44 24 70	 mov	 rax, QWORD PTR inst$[rsp]
  00013	48 83 c0 02	 add	 rax, 2
  00017	48 8b c8	 mov	 rcx, rax
  0001a	e8 00 00 00 00	 call	 fetch_fw_noswap
  0001f	8b c8		 mov	 ecx, eax
  00021	e8 00 00 00 00	 call	 _byteswap_ulong
  00026	89 44 24 48	 mov	 DWORD PTR temp$1[rsp], eax
  0002a	8b 44 24 48	 mov	 eax, DWORD PTR temp$1[rsp]
  0002e	25 ff 0f 00 00	 and	 eax, 4095		; 00000fffH
  00033	89 44 24 40	 mov	 DWORD PTR effective_addr2$[rsp], eax
  00037	8b 44 24 48	 mov	 eax, DWORD PTR temp$1[rsp]
  0003b	c1 e8 0c	 shr	 eax, 12
  0003e	83 e0 0f	 and	 eax, 15
  00041	89 44 24 50	 mov	 DWORD PTR b2$[rsp], eax
  00045	8b 44 24 48	 mov	 eax, DWORD PTR temp$1[rsp]
  00049	c1 e8 10	 shr	 eax, 16
  0004c	25 ff 0f 00 00	 and	 eax, 4095		; 00000fffH
  00051	89 44 24 44	 mov	 DWORD PTR effective_addr1$[rsp], eax
  00055	8b 44 24 48	 mov	 eax, DWORD PTR temp$1[rsp]
  00059	c1 e8 1c	 shr	 eax, 28
  0005c	83 e0 0f	 and	 eax, 15
  0005f	89 44 24 4c	 mov	 DWORD PTR b1$[rsp], eax
  00063	83 7c 24 4c 00	 cmp	 DWORD PTR b1$[rsp], 0
  00068	74 2a		 je	 SHORT $LN8@s370_trace
  0006a	48 63 44 24 4c	 movsxd	 rax, DWORD PTR b1$[rsp]
  0006f	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  00074	8b 84 c1 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax*8+640]
  0007b	8b 4c 24 44	 mov	 ecx, DWORD PTR effective_addr1$[rsp]
  0007f	03 c8		 add	 ecx, eax
  00081	8b c1		 mov	 eax, ecx
  00083	89 44 24 44	 mov	 DWORD PTR effective_addr1$[rsp], eax
  00087	8b 44 24 44	 mov	 eax, DWORD PTR effective_addr1$[rsp]
  0008b	25 ff ff ff 00	 and	 eax, 16777215		; 00ffffffH
  00090	89 44 24 44	 mov	 DWORD PTR effective_addr1$[rsp], eax
$LN8@s370_trace:
  00094	83 7c 24 50 00	 cmp	 DWORD PTR b2$[rsp], 0
  00099	74 2a		 je	 SHORT $LN9@s370_trace
  0009b	48 63 44 24 50	 movsxd	 rax, DWORD PTR b2$[rsp]
  000a0	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  000a5	8b 84 c1 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax*8+640]
  000ac	8b 4c 24 40	 mov	 ecx, DWORD PTR effective_addr2$[rsp]
  000b0	03 c8		 add	 ecx, eax
  000b2	8b c1		 mov	 eax, ecx
  000b4	89 44 24 40	 mov	 DWORD PTR effective_addr2$[rsp], eax
  000b8	8b 44 24 40	 mov	 eax, DWORD PTR effective_addr2$[rsp]
  000bc	25 ff ff ff 00	 and	 eax, 16777215		; 00ffffffH
  000c1	89 44 24 40	 mov	 DWORD PTR effective_addr2$[rsp], eax
$LN9@s370_trace:
$LN4@s370_trace:
  000c5	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  000ca	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  000ce	48 83 c0 06	 add	 rax, 6
  000d2	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  000d7	48 89 41 68	 mov	 QWORD PTR [rcx+104], rax
  000db	33 c0		 xor	 eax, eax
  000dd	83 f8 06	 cmp	 eax, 6
  000e0	74 0c		 je	 SHORT $LN10@s370_trace
  000e2	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  000e7	c6 80 9a 00 00
	00 06		 mov	 BYTE PTR [rax+154], 6
$LN10@s370_trace:
  000ee	33 c0		 xor	 eax, eax
  000f0	85 c0		 test	 eax, eax
  000f2	75 d1		 jne	 SHORT $LN4@s370_trace

; 570  :     PER_ZEROADDR_XCHECK2( regs, b1, b2 );
; 571  : 
; 572  :     GUEST_CHECK( );

  000f4	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  000f9	0f b6 40 7a	 movzx	 eax, BYTE PTR [rax+122]
  000fd	83 e0 01	 and	 eax, 1
  00100	85 c0		 test	 eax, eax
  00102	74 44		 je	 SHORT $LN11@s370_trace
  00104	b8 08 00 00 00	 mov	 eax, 8
  00109	48 6b c0 07	 imul	 rax, rax, 7
  0010d	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  00112	8b 84 01 00 06
	00 00		 mov	 eax, DWORD PTR [rcx+rax+1536]
  00119	25 04 00 00 40	 and	 eax, 1073741828		; 40000004H
  0011e	83 f8 04	 cmp	 eax, 4
  00121	74 25		 je	 SHORT $LN12@s370_trace
  00123	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  00128	0f b6 40 7a	 movzx	 eax, BYTE PTR [rax+122]
  0012c	83 e0 01	 and	 eax, 1
  0012f	85 c0		 test	 eax, eax
  00131	74 15		 je	 SHORT $LN13@s370_trace
  00133	ba 02 00 00 00	 mov	 edx, 2
  00138	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  0013d	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  00142	ff 90 20 0d 00
	00		 call	 QWORD PTR [rax+3360]
$LN13@s370_trace:
$LN12@s370_trace:
$LN11@s370_trace:

; 573  : 
; 574  :     /* Specification exception if operands are not on word boundary */
; 575  :     if ((effective_addr1 & 0x00000003) || (effective_addr2 & 0x00000003))

  00148	8b 44 24 44	 mov	 eax, DWORD PTR effective_addr1$[rsp]
  0014c	83 e0 03	 and	 eax, 3
  0014f	85 c0		 test	 eax, eax
  00151	75 0b		 jne	 SHORT $LN15@s370_trace
  00153	8b 44 24 40	 mov	 eax, DWORD PTR effective_addr2$[rsp]
  00157	83 e0 03	 and	 eax, 3
  0015a	85 c0		 test	 eax, eax
  0015c	74 0f		 je	 SHORT $LN14@s370_trace
$LN15@s370_trace:

; 576  :         ARCH_DEP(program_interrupt) (regs, PGM_SPECIFICATION_EXCEPTION);

  0015e	ba 06 00 00 00	 mov	 edx, 6
  00163	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  00168	e8 00 00 00 00	 call	 s370_program_interrupt
$LN14@s370_trace:
$LN7@s370_trace:

; 577  : 
; 578  :     PTT_ERR("*E509 TRPGM",effective_addr1,effective_addr2,regs->psw.IA_L);

  0016d	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_pttclass
  00174	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00177	48 83 e0 10	 and	 rax, 16
  0017b	48 85 c0	 test	 rax, rax
  0017e	74 45		 je	 SHORT $LN16@s370_trace
  00180	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  00185	8b 80 88 00 00
	00		 mov	 eax, DWORD PTR [rax+136]
  0018b	8b 4c 24 40	 mov	 ecx, DWORD PTR effective_addr2$[rsp]
  0018f	8b 54 24 44	 mov	 edx, DWORD PTR effective_addr1$[rsp]
  00193	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR [rsp+48], 0
  0019c	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  001a1	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG169927
  001a8	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  001ad	44 8b c9	 mov	 r9d, ecx
  001b0	44 8b c2	 mov	 r8d, edx
  001b3	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG169928
  001ba	b9 10 00 00 00	 mov	 ecx, 16
  001bf	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ptt_pthread_trace
$LN16@s370_trace:
  001c5	33 c0		 xor	 eax, eax
  001c7	85 c0		 test	 eax, eax
  001c9	75 a2		 jne	 SHORT $LN7@s370_trace

; 579  :     /*INCOMPLETE: NO TRACE ENTRY IS GENERATED*/
; 580  : }

  001cb	48 83 c4 68	 add	 rsp, 104		; 00000068H
  001cf	c3		 ret	 0
s370_trace_program_interruption ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\assist.c
_TEXT	SEGMENT
effective_addr2$ = 64
effective_addr1$ = 68
temp$1 = 72
b1$ = 76
b2$ = 80
inst$ = 112
regs$ = 120
s370_trace_io_interruption PROC

; 610  : {

$LN18:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 68	 sub	 rsp, 104		; 00000068H

; 611  : int     b1, b2;                         /* Values of base field      */
; 612  : VADR    effective_addr1,
; 613  :         effective_addr2;                /* Effective addresses       */
; 614  : 
; 615  :     SSE(inst, regs, b1, effective_addr1, b2, effective_addr2);

  0000e	48 8b 44 24 70	 mov	 rax, QWORD PTR inst$[rsp]
  00013	48 83 c0 02	 add	 rax, 2
  00017	48 8b c8	 mov	 rcx, rax
  0001a	e8 00 00 00 00	 call	 fetch_fw_noswap
  0001f	8b c8		 mov	 ecx, eax
  00021	e8 00 00 00 00	 call	 _byteswap_ulong
  00026	89 44 24 48	 mov	 DWORD PTR temp$1[rsp], eax
  0002a	8b 44 24 48	 mov	 eax, DWORD PTR temp$1[rsp]
  0002e	25 ff 0f 00 00	 and	 eax, 4095		; 00000fffH
  00033	89 44 24 40	 mov	 DWORD PTR effective_addr2$[rsp], eax
  00037	8b 44 24 48	 mov	 eax, DWORD PTR temp$1[rsp]
  0003b	c1 e8 0c	 shr	 eax, 12
  0003e	83 e0 0f	 and	 eax, 15
  00041	89 44 24 50	 mov	 DWORD PTR b2$[rsp], eax
  00045	8b 44 24 48	 mov	 eax, DWORD PTR temp$1[rsp]
  00049	c1 e8 10	 shr	 eax, 16
  0004c	25 ff 0f 00 00	 and	 eax, 4095		; 00000fffH
  00051	89 44 24 44	 mov	 DWORD PTR effective_addr1$[rsp], eax
  00055	8b 44 24 48	 mov	 eax, DWORD PTR temp$1[rsp]
  00059	c1 e8 1c	 shr	 eax, 28
  0005c	83 e0 0f	 and	 eax, 15
  0005f	89 44 24 4c	 mov	 DWORD PTR b1$[rsp], eax
  00063	83 7c 24 4c 00	 cmp	 DWORD PTR b1$[rsp], 0
  00068	74 2a		 je	 SHORT $LN8@s370_trace
  0006a	48 63 44 24 4c	 movsxd	 rax, DWORD PTR b1$[rsp]
  0006f	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  00074	8b 84 c1 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax*8+640]
  0007b	8b 4c 24 44	 mov	 ecx, DWORD PTR effective_addr1$[rsp]
  0007f	03 c8		 add	 ecx, eax
  00081	8b c1		 mov	 eax, ecx
  00083	89 44 24 44	 mov	 DWORD PTR effective_addr1$[rsp], eax
  00087	8b 44 24 44	 mov	 eax, DWORD PTR effective_addr1$[rsp]
  0008b	25 ff ff ff 00	 and	 eax, 16777215		; 00ffffffH
  00090	89 44 24 44	 mov	 DWORD PTR effective_addr1$[rsp], eax
$LN8@s370_trace:
  00094	83 7c 24 50 00	 cmp	 DWORD PTR b2$[rsp], 0
  00099	74 2a		 je	 SHORT $LN9@s370_trace
  0009b	48 63 44 24 50	 movsxd	 rax, DWORD PTR b2$[rsp]
  000a0	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  000a5	8b 84 c1 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax*8+640]
  000ac	8b 4c 24 40	 mov	 ecx, DWORD PTR effective_addr2$[rsp]
  000b0	03 c8		 add	 ecx, eax
  000b2	8b c1		 mov	 eax, ecx
  000b4	89 44 24 40	 mov	 DWORD PTR effective_addr2$[rsp], eax
  000b8	8b 44 24 40	 mov	 eax, DWORD PTR effective_addr2$[rsp]
  000bc	25 ff ff ff 00	 and	 eax, 16777215		; 00ffffffH
  000c1	89 44 24 40	 mov	 DWORD PTR effective_addr2$[rsp], eax
$LN9@s370_trace:
$LN4@s370_trace:
  000c5	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  000ca	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  000ce	48 83 c0 06	 add	 rax, 6
  000d2	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  000d7	48 89 41 68	 mov	 QWORD PTR [rcx+104], rax
  000db	33 c0		 xor	 eax, eax
  000dd	83 f8 06	 cmp	 eax, 6
  000e0	74 0c		 je	 SHORT $LN10@s370_trace
  000e2	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  000e7	c6 80 9a 00 00
	00 06		 mov	 BYTE PTR [rax+154], 6
$LN10@s370_trace:
  000ee	33 c0		 xor	 eax, eax
  000f0	85 c0		 test	 eax, eax
  000f2	75 d1		 jne	 SHORT $LN4@s370_trace

; 616  :     PER_ZEROADDR_XCHECK2( regs, b1, b2 );
; 617  : 
; 618  :     GUEST_CHECK( );

  000f4	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  000f9	0f b6 40 7a	 movzx	 eax, BYTE PTR [rax+122]
  000fd	83 e0 01	 and	 eax, 1
  00100	85 c0		 test	 eax, eax
  00102	74 44		 je	 SHORT $LN11@s370_trace
  00104	b8 08 00 00 00	 mov	 eax, 8
  00109	48 6b c0 07	 imul	 rax, rax, 7
  0010d	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  00112	8b 84 01 00 06
	00 00		 mov	 eax, DWORD PTR [rcx+rax+1536]
  00119	25 04 00 00 40	 and	 eax, 1073741828		; 40000004H
  0011e	83 f8 04	 cmp	 eax, 4
  00121	74 25		 je	 SHORT $LN12@s370_trace
  00123	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  00128	0f b6 40 7a	 movzx	 eax, BYTE PTR [rax+122]
  0012c	83 e0 01	 and	 eax, 1
  0012f	85 c0		 test	 eax, eax
  00131	74 15		 je	 SHORT $LN13@s370_trace
  00133	ba 02 00 00 00	 mov	 edx, 2
  00138	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  0013d	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  00142	ff 90 20 0d 00
	00		 call	 QWORD PTR [rax+3360]
$LN13@s370_trace:
$LN12@s370_trace:
$LN11@s370_trace:

; 619  : 
; 620  :     /* Specification exception if operands are not on word boundary */
; 621  :     if ((effective_addr1 & 0x00000003) || (effective_addr2 & 0x00000003))

  00148	8b 44 24 44	 mov	 eax, DWORD PTR effective_addr1$[rsp]
  0014c	83 e0 03	 and	 eax, 3
  0014f	85 c0		 test	 eax, eax
  00151	75 0b		 jne	 SHORT $LN15@s370_trace
  00153	8b 44 24 40	 mov	 eax, DWORD PTR effective_addr2$[rsp]
  00157	83 e0 03	 and	 eax, 3
  0015a	85 c0		 test	 eax, eax
  0015c	74 0f		 je	 SHORT $LN14@s370_trace
$LN15@s370_trace:

; 622  :         ARCH_DEP(program_interrupt) (regs, PGM_SPECIFICATION_EXCEPTION);

  0015e	ba 06 00 00 00	 mov	 edx, 6
  00163	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  00168	e8 00 00 00 00	 call	 s370_program_interrupt
$LN14@s370_trace:
$LN7@s370_trace:

; 623  : 
; 624  :     PTT_ERR("*E50B TRIO",effective_addr1,effective_addr2,regs->psw.IA_L);

  0016d	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_pttclass
  00174	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00177	48 83 e0 10	 and	 rax, 16
  0017b	48 85 c0	 test	 rax, rax
  0017e	74 45		 je	 SHORT $LN16@s370_trace
  00180	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  00185	8b 80 88 00 00
	00		 mov	 eax, DWORD PTR [rax+136]
  0018b	8b 4c 24 40	 mov	 ecx, DWORD PTR effective_addr2$[rsp]
  0018f	8b 54 24 44	 mov	 edx, DWORD PTR effective_addr1$[rsp]
  00193	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR [rsp+48], 0
  0019c	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  001a1	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG169997
  001a8	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  001ad	44 8b c9	 mov	 r9d, ecx
  001b0	44 8b c2	 mov	 r8d, edx
  001b3	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG169998
  001ba	b9 10 00 00 00	 mov	 ecx, 16
  001bf	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ptt_pthread_trace
$LN16@s370_trace:
  001c5	33 c0		 xor	 eax, eax
  001c7	85 c0		 test	 eax, eax
  001c9	75 a2		 jne	 SHORT $LN7@s370_trace

; 625  :     /*INCOMPLETE: NO TRACE ENTRY IS GENERATED*/
; 626  : }

  001cb	48 83 c4 68	 add	 rsp, 104		; 00000068H
  001cf	c3		 ret	 0
s370_trace_io_interruption ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\assist.c
_TEXT	SEGMENT
effective_addr2$ = 64
effective_addr1$ = 68
temp$1 = 72
b1$ = 76
b2$ = 80
inst$ = 112
regs$ = 120
s370_trace_initial_srb_dispatch PROC

; 587  : {

$LN18:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 68	 sub	 rsp, 104		; 00000068H

; 588  : int     b1, b2;                         /* Values of base field      */
; 589  : VADR    effective_addr1,
; 590  :         effective_addr2;                /* Effective addresses       */
; 591  : 
; 592  :     SSE(inst, regs, b1, effective_addr1, b2, effective_addr2);

  0000e	48 8b 44 24 70	 mov	 rax, QWORD PTR inst$[rsp]
  00013	48 83 c0 02	 add	 rax, 2
  00017	48 8b c8	 mov	 rcx, rax
  0001a	e8 00 00 00 00	 call	 fetch_fw_noswap
  0001f	8b c8		 mov	 ecx, eax
  00021	e8 00 00 00 00	 call	 _byteswap_ulong
  00026	89 44 24 48	 mov	 DWORD PTR temp$1[rsp], eax
  0002a	8b 44 24 48	 mov	 eax, DWORD PTR temp$1[rsp]
  0002e	25 ff 0f 00 00	 and	 eax, 4095		; 00000fffH
  00033	89 44 24 40	 mov	 DWORD PTR effective_addr2$[rsp], eax
  00037	8b 44 24 48	 mov	 eax, DWORD PTR temp$1[rsp]
  0003b	c1 e8 0c	 shr	 eax, 12
  0003e	83 e0 0f	 and	 eax, 15
  00041	89 44 24 50	 mov	 DWORD PTR b2$[rsp], eax
  00045	8b 44 24 48	 mov	 eax, DWORD PTR temp$1[rsp]
  00049	c1 e8 10	 shr	 eax, 16
  0004c	25 ff 0f 00 00	 and	 eax, 4095		; 00000fffH
  00051	89 44 24 44	 mov	 DWORD PTR effective_addr1$[rsp], eax
  00055	8b 44 24 48	 mov	 eax, DWORD PTR temp$1[rsp]
  00059	c1 e8 1c	 shr	 eax, 28
  0005c	83 e0 0f	 and	 eax, 15
  0005f	89 44 24 4c	 mov	 DWORD PTR b1$[rsp], eax
  00063	83 7c 24 4c 00	 cmp	 DWORD PTR b1$[rsp], 0
  00068	74 2a		 je	 SHORT $LN8@s370_trace
  0006a	48 63 44 24 4c	 movsxd	 rax, DWORD PTR b1$[rsp]
  0006f	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  00074	8b 84 c1 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax*8+640]
  0007b	8b 4c 24 44	 mov	 ecx, DWORD PTR effective_addr1$[rsp]
  0007f	03 c8		 add	 ecx, eax
  00081	8b c1		 mov	 eax, ecx
  00083	89 44 24 44	 mov	 DWORD PTR effective_addr1$[rsp], eax
  00087	8b 44 24 44	 mov	 eax, DWORD PTR effective_addr1$[rsp]
  0008b	25 ff ff ff 00	 and	 eax, 16777215		; 00ffffffH
  00090	89 44 24 44	 mov	 DWORD PTR effective_addr1$[rsp], eax
$LN8@s370_trace:
  00094	83 7c 24 50 00	 cmp	 DWORD PTR b2$[rsp], 0
  00099	74 2a		 je	 SHORT $LN9@s370_trace
  0009b	48 63 44 24 50	 movsxd	 rax, DWORD PTR b2$[rsp]
  000a0	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  000a5	8b 84 c1 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax*8+640]
  000ac	8b 4c 24 40	 mov	 ecx, DWORD PTR effective_addr2$[rsp]
  000b0	03 c8		 add	 ecx, eax
  000b2	8b c1		 mov	 eax, ecx
  000b4	89 44 24 40	 mov	 DWORD PTR effective_addr2$[rsp], eax
  000b8	8b 44 24 40	 mov	 eax, DWORD PTR effective_addr2$[rsp]
  000bc	25 ff ff ff 00	 and	 eax, 16777215		; 00ffffffH
  000c1	89 44 24 40	 mov	 DWORD PTR effective_addr2$[rsp], eax
$LN9@s370_trace:
$LN4@s370_trace:
  000c5	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  000ca	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  000ce	48 83 c0 06	 add	 rax, 6
  000d2	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  000d7	48 89 41 68	 mov	 QWORD PTR [rcx+104], rax
  000db	33 c0		 xor	 eax, eax
  000dd	83 f8 06	 cmp	 eax, 6
  000e0	74 0c		 je	 SHORT $LN10@s370_trace
  000e2	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  000e7	c6 80 9a 00 00
	00 06		 mov	 BYTE PTR [rax+154], 6
$LN10@s370_trace:
  000ee	33 c0		 xor	 eax, eax
  000f0	85 c0		 test	 eax, eax
  000f2	75 d1		 jne	 SHORT $LN4@s370_trace

; 593  :     PER_ZEROADDR_XCHECK2( regs, b1, b2 );
; 594  : 
; 595  :     GUEST_CHECK( );

  000f4	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  000f9	0f b6 40 7a	 movzx	 eax, BYTE PTR [rax+122]
  000fd	83 e0 01	 and	 eax, 1
  00100	85 c0		 test	 eax, eax
  00102	74 44		 je	 SHORT $LN11@s370_trace
  00104	b8 08 00 00 00	 mov	 eax, 8
  00109	48 6b c0 07	 imul	 rax, rax, 7
  0010d	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  00112	8b 84 01 00 06
	00 00		 mov	 eax, DWORD PTR [rcx+rax+1536]
  00119	25 04 00 00 40	 and	 eax, 1073741828		; 40000004H
  0011e	83 f8 04	 cmp	 eax, 4
  00121	74 25		 je	 SHORT $LN12@s370_trace
  00123	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  00128	0f b6 40 7a	 movzx	 eax, BYTE PTR [rax+122]
  0012c	83 e0 01	 and	 eax, 1
  0012f	85 c0		 test	 eax, eax
  00131	74 15		 je	 SHORT $LN13@s370_trace
  00133	ba 02 00 00 00	 mov	 edx, 2
  00138	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  0013d	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  00142	ff 90 20 0d 00
	00		 call	 QWORD PTR [rax+3360]
$LN13@s370_trace:
$LN12@s370_trace:
$LN11@s370_trace:

; 596  : 
; 597  :     /* Specification exception if operands are not on word boundary */
; 598  :     if ((effective_addr1 & 0x00000003) || (effective_addr2 & 0x00000003))

  00148	8b 44 24 44	 mov	 eax, DWORD PTR effective_addr1$[rsp]
  0014c	83 e0 03	 and	 eax, 3
  0014f	85 c0		 test	 eax, eax
  00151	75 0b		 jne	 SHORT $LN15@s370_trace
  00153	8b 44 24 40	 mov	 eax, DWORD PTR effective_addr2$[rsp]
  00157	83 e0 03	 and	 eax, 3
  0015a	85 c0		 test	 eax, eax
  0015c	74 0f		 je	 SHORT $LN14@s370_trace
$LN15@s370_trace:

; 599  :         ARCH_DEP(program_interrupt) (regs, PGM_SPECIFICATION_EXCEPTION);

  0015e	ba 06 00 00 00	 mov	 edx, 6
  00163	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  00168	e8 00 00 00 00	 call	 s370_program_interrupt
$LN14@s370_trace:
$LN7@s370_trace:

; 600  : 
; 601  :     PTT_ERR("*E50A TRSRB",effective_addr1,effective_addr2,regs->psw.IA_L);

  0016d	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_pttclass
  00174	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00177	48 83 e0 10	 and	 rax, 16
  0017b	48 85 c0	 test	 rax, rax
  0017e	74 45		 je	 SHORT $LN16@s370_trace
  00180	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  00185	8b 80 88 00 00
	00		 mov	 eax, DWORD PTR [rax+136]
  0018b	8b 4c 24 40	 mov	 ecx, DWORD PTR effective_addr2$[rsp]
  0018f	8b 54 24 44	 mov	 edx, DWORD PTR effective_addr1$[rsp]
  00193	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR [rsp+48], 0
  0019c	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  001a1	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG169962
  001a8	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  001ad	44 8b c9	 mov	 r9d, ecx
  001b0	44 8b c2	 mov	 r8d, edx
  001b3	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG169963
  001ba	b9 10 00 00 00	 mov	 ecx, 16
  001bf	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ptt_pthread_trace
$LN16@s370_trace:
  001c5	33 c0		 xor	 eax, eax
  001c7	85 c0		 test	 eax, eax
  001c9	75 a2		 jne	 SHORT $LN7@s370_trace

; 602  :     /*INCOMPLETE: NO TRACE ENTRY IS GENERATED*/
; 603  : }

  001cb	48 83 c4 68	 add	 rsp, 104		; 00000068H
  001cf	c3		 ret	 0
s370_trace_initial_srb_dispatch ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\assist.c
_TEXT	SEGMENT
effective_addr2$ = 64
effective_addr1$ = 68
temp$1 = 72
b1$ = 76
b2$ = 80
inst$ = 112
regs$ = 120
s370_svc_assist PROC

; 129  : {

$LN16:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 68	 sub	 rsp, 104		; 00000068H

; 130  : int     b1, b2;                         /* Values of base field      */
; 131  : VADR    effective_addr1,
; 132  :         effective_addr2;                /* Effective addresses       */
; 133  : 
; 134  :     SSE(inst, regs, b1, effective_addr1, b2, effective_addr2);

  0000e	48 8b 44 24 70	 mov	 rax, QWORD PTR inst$[rsp]
  00013	48 83 c0 02	 add	 rax, 2
  00017	48 8b c8	 mov	 rcx, rax
  0001a	e8 00 00 00 00	 call	 fetch_fw_noswap
  0001f	8b c8		 mov	 ecx, eax
  00021	e8 00 00 00 00	 call	 _byteswap_ulong
  00026	89 44 24 48	 mov	 DWORD PTR temp$1[rsp], eax
  0002a	8b 44 24 48	 mov	 eax, DWORD PTR temp$1[rsp]
  0002e	25 ff 0f 00 00	 and	 eax, 4095		; 00000fffH
  00033	89 44 24 40	 mov	 DWORD PTR effective_addr2$[rsp], eax
  00037	8b 44 24 48	 mov	 eax, DWORD PTR temp$1[rsp]
  0003b	c1 e8 0c	 shr	 eax, 12
  0003e	83 e0 0f	 and	 eax, 15
  00041	89 44 24 50	 mov	 DWORD PTR b2$[rsp], eax
  00045	8b 44 24 48	 mov	 eax, DWORD PTR temp$1[rsp]
  00049	c1 e8 10	 shr	 eax, 16
  0004c	25 ff 0f 00 00	 and	 eax, 4095		; 00000fffH
  00051	89 44 24 44	 mov	 DWORD PTR effective_addr1$[rsp], eax
  00055	8b 44 24 48	 mov	 eax, DWORD PTR temp$1[rsp]
  00059	c1 e8 1c	 shr	 eax, 28
  0005c	83 e0 0f	 and	 eax, 15
  0005f	89 44 24 4c	 mov	 DWORD PTR b1$[rsp], eax
  00063	83 7c 24 4c 00	 cmp	 DWORD PTR b1$[rsp], 0
  00068	74 2a		 je	 SHORT $LN8@s370_svc_a
  0006a	48 63 44 24 4c	 movsxd	 rax, DWORD PTR b1$[rsp]
  0006f	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  00074	8b 84 c1 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax*8+640]
  0007b	8b 4c 24 44	 mov	 ecx, DWORD PTR effective_addr1$[rsp]
  0007f	03 c8		 add	 ecx, eax
  00081	8b c1		 mov	 eax, ecx
  00083	89 44 24 44	 mov	 DWORD PTR effective_addr1$[rsp], eax
  00087	8b 44 24 44	 mov	 eax, DWORD PTR effective_addr1$[rsp]
  0008b	25 ff ff ff 00	 and	 eax, 16777215		; 00ffffffH
  00090	89 44 24 44	 mov	 DWORD PTR effective_addr1$[rsp], eax
$LN8@s370_svc_a:
  00094	83 7c 24 50 00	 cmp	 DWORD PTR b2$[rsp], 0
  00099	74 2a		 je	 SHORT $LN9@s370_svc_a
  0009b	48 63 44 24 50	 movsxd	 rax, DWORD PTR b2$[rsp]
  000a0	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  000a5	8b 84 c1 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax*8+640]
  000ac	8b 4c 24 40	 mov	 ecx, DWORD PTR effective_addr2$[rsp]
  000b0	03 c8		 add	 ecx, eax
  000b2	8b c1		 mov	 eax, ecx
  000b4	89 44 24 40	 mov	 DWORD PTR effective_addr2$[rsp], eax
  000b8	8b 44 24 40	 mov	 eax, DWORD PTR effective_addr2$[rsp]
  000bc	25 ff ff ff 00	 and	 eax, 16777215		; 00ffffffH
  000c1	89 44 24 40	 mov	 DWORD PTR effective_addr2$[rsp], eax
$LN9@s370_svc_a:
$LN4@s370_svc_a:
  000c5	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  000ca	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  000ce	48 83 c0 06	 add	 rax, 6
  000d2	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  000d7	48 89 41 68	 mov	 QWORD PTR [rcx+104], rax
  000db	33 c0		 xor	 eax, eax
  000dd	83 f8 06	 cmp	 eax, 6
  000e0	74 0c		 je	 SHORT $LN10@s370_svc_a
  000e2	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  000e7	c6 80 9a 00 00
	00 06		 mov	 BYTE PTR [rax+154], 6
$LN10@s370_svc_a:
  000ee	33 c0		 xor	 eax, eax
  000f0	85 c0		 test	 eax, eax
  000f2	75 d1		 jne	 SHORT $LN4@s370_svc_a

; 135  :     PER_ZEROADDR_XCHECK2( regs, b1, b2 );
; 136  : 
; 137  :     GUEST_CHECK( );

  000f4	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  000f9	0f b6 40 7a	 movzx	 eax, BYTE PTR [rax+122]
  000fd	83 e0 01	 and	 eax, 1
  00100	85 c0		 test	 eax, eax
  00102	74 44		 je	 SHORT $LN11@s370_svc_a
  00104	b8 08 00 00 00	 mov	 eax, 8
  00109	48 6b c0 07	 imul	 rax, rax, 7
  0010d	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  00112	8b 84 01 00 06
	00 00		 mov	 eax, DWORD PTR [rcx+rax+1536]
  00119	25 04 00 00 40	 and	 eax, 1073741828		; 40000004H
  0011e	83 f8 04	 cmp	 eax, 4
  00121	74 25		 je	 SHORT $LN12@s370_svc_a
  00123	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  00128	0f b6 40 7a	 movzx	 eax, BYTE PTR [rax+122]
  0012c	83 e0 01	 and	 eax, 1
  0012f	85 c0		 test	 eax, eax
  00131	74 15		 je	 SHORT $LN13@s370_svc_a
  00133	ba 02 00 00 00	 mov	 edx, 2
  00138	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  0013d	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  00142	ff 90 20 0d 00
	00		 call	 QWORD PTR [rax+3360]
$LN13@s370_svc_a:
$LN12@s370_svc_a:
$LN11@s370_svc_a:
$LN7@s370_svc_a:

; 138  : 
; 139  :     PTT_ERR( "*E503 SVCA", effective_addr1, effective_addr2, regs->psw.IA_L );

  00148	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_pttclass
  0014f	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00152	48 83 e0 10	 and	 rax, 16
  00156	48 85 c0	 test	 rax, rax
  00159	74 45		 je	 SHORT $LN14@s370_svc_a
  0015b	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  00160	8b 80 88 00 00
	00		 mov	 eax, DWORD PTR [rax+136]
  00166	8b 4c 24 40	 mov	 ecx, DWORD PTR effective_addr2$[rsp]
  0016a	8b 54 24 44	 mov	 edx, DWORD PTR effective_addr1$[rsp]
  0016e	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR [rsp+48], 0
  00177	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  0017c	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG169636
  00183	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00188	44 8b c9	 mov	 r9d, ecx
  0018b	44 8b c2	 mov	 r8d, edx
  0018e	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG169637
  00195	b9 10 00 00 00	 mov	 ecx, 16
  0019a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ptt_pthread_trace
$LN14@s370_svc_a:
  001a0	33 c0		 xor	 eax, eax
  001a2	85 c0		 test	 eax, eax
  001a4	75 a2		 jne	 SHORT $LN7@s370_svc_a

; 140  :     /*INCOMPLETE: NO ACTION IS TAKEN, THE SVC IS UNASSISTED
; 141  :                   AND MVS WILL HAVE TO HANDLE THE SITUATION*/
; 142  : }

  001a6	48 83 c4 68	 add	 rsp, 104		; 00000068H
  001aa	c3		 ret	 0
s370_svc_assist ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\assist.c
_TEXT	SEGMENT
acc_mode$ = 32
effective_addr2$ = 36
effective_addr1$ = 40
hlhi_word$ = 44
temp$1 = 48
lit_addr$ = 52
b1$ = 56
b2$ = 60
ascb_addr$ = 64
lock_addr$ = 68
newia$ = 72
susp_addr$ = 76
lcpa$ = 80
lock$ = 84
susp$ = 88
inst$ = 112
regs$ = 120
s370_release_local_lock PROC

; 242  : {

$LN31:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 68	 sub	 rsp, 104		; 00000068H

; 243  : int     b1, b2;                         /* Values of base field      */
; 244  : VADR    effective_addr1,
; 245  :         effective_addr2;                /* Effective addresses       */
; 246  : VADR    ascb_addr;                      /* Virtual address of ASCB   */
; 247  : VADR    lock_addr;                      /* Virtual addr of ASCBLOCK  */
; 248  : VADR    susp_addr;                      /* Virtual addr of ASCBLSWQ  */
; 249  : U32     hlhi_word;                      /* Highest lock held word    */
; 250  : VADR    lit_addr;                       /* Virtual address of lock
; 251  :                                            interface table           */
; 252  : U32     lock;                           /* Lock value                */
; 253  : U32     susp;                           /* Lock suspend queue        */
; 254  : U32     lcpa;                           /* Logical CPU address       */
; 255  : VADR    newia;                          /* Unsuccessful branch addr  */
; 256  : int     acc_mode = 0;                   /* access mode to use        */

  0000e	c7 44 24 20 00
	00 00 00	 mov	 DWORD PTR acc_mode$[rsp], 0

; 257  : 
; 258  :     SSE(inst, regs, b1, effective_addr1, b2, effective_addr2);

  00016	48 8b 44 24 70	 mov	 rax, QWORD PTR inst$[rsp]
  0001b	48 83 c0 02	 add	 rax, 2
  0001f	48 8b c8	 mov	 rcx, rax
  00022	e8 00 00 00 00	 call	 fetch_fw_noswap
  00027	8b c8		 mov	 ecx, eax
  00029	e8 00 00 00 00	 call	 _byteswap_ulong
  0002e	89 44 24 30	 mov	 DWORD PTR temp$1[rsp], eax
  00032	8b 44 24 30	 mov	 eax, DWORD PTR temp$1[rsp]
  00036	25 ff 0f 00 00	 and	 eax, 4095		; 00000fffH
  0003b	89 44 24 24	 mov	 DWORD PTR effective_addr2$[rsp], eax
  0003f	8b 44 24 30	 mov	 eax, DWORD PTR temp$1[rsp]
  00043	c1 e8 0c	 shr	 eax, 12
  00046	83 e0 0f	 and	 eax, 15
  00049	89 44 24 3c	 mov	 DWORD PTR b2$[rsp], eax
  0004d	8b 44 24 30	 mov	 eax, DWORD PTR temp$1[rsp]
  00051	c1 e8 10	 shr	 eax, 16
  00054	25 ff 0f 00 00	 and	 eax, 4095		; 00000fffH
  00059	89 44 24 28	 mov	 DWORD PTR effective_addr1$[rsp], eax
  0005d	8b 44 24 30	 mov	 eax, DWORD PTR temp$1[rsp]
  00061	c1 e8 1c	 shr	 eax, 28
  00064	83 e0 0f	 and	 eax, 15
  00067	89 44 24 38	 mov	 DWORD PTR b1$[rsp], eax
  0006b	83 7c 24 38 00	 cmp	 DWORD PTR b1$[rsp], 0
  00070	74 2a		 je	 SHORT $LN14@s370_relea
  00072	48 63 44 24 38	 movsxd	 rax, DWORD PTR b1$[rsp]
  00077	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  0007c	8b 84 c1 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax*8+640]
  00083	8b 4c 24 28	 mov	 ecx, DWORD PTR effective_addr1$[rsp]
  00087	03 c8		 add	 ecx, eax
  00089	8b c1		 mov	 eax, ecx
  0008b	89 44 24 28	 mov	 DWORD PTR effective_addr1$[rsp], eax
  0008f	8b 44 24 28	 mov	 eax, DWORD PTR effective_addr1$[rsp]
  00093	25 ff ff ff 00	 and	 eax, 16777215		; 00ffffffH
  00098	89 44 24 28	 mov	 DWORD PTR effective_addr1$[rsp], eax
$LN14@s370_relea:
  0009c	83 7c 24 3c 00	 cmp	 DWORD PTR b2$[rsp], 0
  000a1	74 2a		 je	 SHORT $LN15@s370_relea
  000a3	48 63 44 24 3c	 movsxd	 rax, DWORD PTR b2$[rsp]
  000a8	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  000ad	8b 84 c1 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax*8+640]
  000b4	8b 4c 24 24	 mov	 ecx, DWORD PTR effective_addr2$[rsp]
  000b8	03 c8		 add	 ecx, eax
  000ba	8b c1		 mov	 eax, ecx
  000bc	89 44 24 24	 mov	 DWORD PTR effective_addr2$[rsp], eax
  000c0	8b 44 24 24	 mov	 eax, DWORD PTR effective_addr2$[rsp]
  000c4	25 ff ff ff 00	 and	 eax, 16777215		; 00ffffffH
  000c9	89 44 24 24	 mov	 DWORD PTR effective_addr2$[rsp], eax
$LN15@s370_relea:
$LN4@s370_relea:
  000cd	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  000d2	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  000d6	48 83 c0 06	 add	 rax, 6
  000da	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  000df	48 89 41 68	 mov	 QWORD PTR [rcx+104], rax
  000e3	33 c0		 xor	 eax, eax
  000e5	83 f8 06	 cmp	 eax, 6
  000e8	74 0c		 je	 SHORT $LN16@s370_relea
  000ea	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  000ef	c6 80 9a 00 00
	00 06		 mov	 BYTE PTR [rax+154], 6
$LN16@s370_relea:
  000f6	33 c0		 xor	 eax, eax
  000f8	85 c0		 test	 eax, eax
  000fa	75 d1		 jne	 SHORT $LN4@s370_relea

; 259  :     PER_ZEROADDR_XCHECK2( regs, b1, b2 );
; 260  : 
; 261  :     GUEST_CHECK( );

  000fc	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  00101	0f b6 40 7a	 movzx	 eax, BYTE PTR [rax+122]
  00105	83 e0 01	 and	 eax, 1
  00108	85 c0		 test	 eax, eax
  0010a	74 44		 je	 SHORT $LN17@s370_relea
  0010c	b8 08 00 00 00	 mov	 eax, 8
  00111	48 6b c0 07	 imul	 rax, rax, 7
  00115	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  0011a	8b 84 01 00 06
	00 00		 mov	 eax, DWORD PTR [rcx+rax+1536]
  00121	25 04 00 00 40	 and	 eax, 1073741828		; 40000004H
  00126	83 f8 04	 cmp	 eax, 4
  00129	74 25		 je	 SHORT $LN18@s370_relea
  0012b	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  00130	0f b6 40 7a	 movzx	 eax, BYTE PTR [rax+122]
  00134	83 e0 01	 and	 eax, 1
  00137	85 c0		 test	 eax, eax
  00139	74 15		 je	 SHORT $LN19@s370_relea
  0013b	ba 02 00 00 00	 mov	 edx, 2
  00140	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  00145	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  0014a	ff 90 20 0d 00
	00		 call	 QWORD PTR [rax+3360]
$LN19@s370_relea:
$LN18@s370_relea:
$LN17@s370_relea:

; 262  : 
; 263  :     /* Specification exception if operands are not on word boundary */
; 264  :     if ((effective_addr1 & 0x00000003) || (effective_addr2 & 0x00000003))

  00150	8b 44 24 28	 mov	 eax, DWORD PTR effective_addr1$[rsp]
  00154	83 e0 03	 and	 eax, 3
  00157	85 c0		 test	 eax, eax
  00159	75 0b		 jne	 SHORT $LN21@s370_relea
  0015b	8b 44 24 24	 mov	 eax, DWORD PTR effective_addr2$[rsp]
  0015f	83 e0 03	 and	 eax, 3
  00162	85 c0		 test	 eax, eax
  00164	74 0f		 je	 SHORT $LN20@s370_relea
$LN21@s370_relea:

; 265  :         ARCH_DEP(program_interrupt) (regs, PGM_SPECIFICATION_EXCEPTION);

  00166	ba 06 00 00 00	 mov	 edx, 6
  0016b	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  00170	e8 00 00 00 00	 call	 s370_program_interrupt
$LN20@s370_relea:
$LN7@s370_relea:

; 266  : 
; 267  :     /* Obtain main-storage access lock */
; 268  :     OBTAIN_MAINLOCK_UNCONDITIONAL(regs);

  00175	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  0017a	48 8b 80 68 08
	00 00		 mov	 rax, QWORD PTR [rax+2152]
  00181	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  00186	48 8b 49 40	 mov	 rcx, QWORD PTR [rcx+64]
  0018a	48 8b 89 b0 12
	00 00		 mov	 rcx, QWORD PTR [rcx+4784]
  00191	48 39 48 50	 cmp	 QWORD PTR [rax+80], rcx
  00195	74 42		 je	 SHORT $LN22@s370_relea
  00197	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  0019c	48 8b 40 40	 mov	 rax, QWORD PTR [rax+64]
  001a0	48 05 68 10 00
	00		 add	 rax, 4200		; 00001068H
  001a6	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG169738
  001ad	48 8b c8	 mov	 rcx, rax
  001b0	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_obtain_lock
  001b6	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  001bb	48 8b 80 68 08
	00 00		 mov	 rax, QWORD PTR [rax+2152]
  001c2	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  001c7	48 8b 49 40	 mov	 rcx, QWORD PTR [rcx+64]
  001cb	0f b7 80 3c 08
	00 00		 movzx	 eax, WORD PTR [rax+2108]
  001d2	66 89 81 60 10
	00 00		 mov	 WORD PTR [rcx+4192], ax
$LN22@s370_relea:
  001d9	33 c0		 xor	 eax, eax
  001db	85 c0		 test	 eax, eax
  001dd	75 96		 jne	 SHORT $LN7@s370_relea

; 269  : 
; 270  :     if (ACCESS_REGISTER_MODE(&regs->psw))

  001df	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  001e4	0f b6 40 7b	 movzx	 eax, BYTE PTR [rax+123]
  001e8	83 f8 40	 cmp	 eax, 64			; 00000040H
  001eb	75 08		 jne	 SHORT $LN23@s370_relea

; 271  :         acc_mode = USE_PRIMARY_SPACE;

  001ed	c7 44 24 20 fd
	ff ff ff	 mov	 DWORD PTR acc_mode$[rsp], -3
$LN23@s370_relea:

; 272  : 
; 273  :     /* Load ASCB address from first operand location */
; 274  :     ascb_addr = ARCH_DEP(vfetch4) ( effective_addr1, acc_mode, regs );

  001f5	4c 8b 44 24 78	 mov	 r8, QWORD PTR regs$[rsp]
  001fa	8b 54 24 20	 mov	 edx, DWORD PTR acc_mode$[rsp]
  001fe	8b 4c 24 28	 mov	 ecx, DWORD PTR effective_addr1$[rsp]
  00202	e8 00 00 00 00	 call	 s370_vfetch4
  00207	89 44 24 40	 mov	 DWORD PTR ascb_addr$[rsp], eax

; 275  : 
; 276  :     /* Load locks held bits from second operand location */
; 277  :     hlhi_word = ARCH_DEP(vfetch4) ( effective_addr2, acc_mode, regs );

  0020b	4c 8b 44 24 78	 mov	 r8, QWORD PTR regs$[rsp]
  00210	8b 54 24 20	 mov	 edx, DWORD PTR acc_mode$[rsp]
  00214	8b 4c 24 24	 mov	 ecx, DWORD PTR effective_addr2$[rsp]
  00218	e8 00 00 00 00	 call	 s370_vfetch4
  0021d	89 44 24 2c	 mov	 DWORD PTR hlhi_word$[rsp], eax

; 278  : 
; 279  :     /* Fetch our logical CPU address from PSALCPUA */
; 280  :     lcpa = ARCH_DEP(vfetch4) ( effective_addr2 - 4, acc_mode, regs );

  00221	8b 44 24 24	 mov	 eax, DWORD PTR effective_addr2$[rsp]
  00225	83 e8 04	 sub	 eax, 4
  00228	4c 8b 44 24 78	 mov	 r8, QWORD PTR regs$[rsp]
  0022d	8b 54 24 20	 mov	 edx, DWORD PTR acc_mode$[rsp]
  00231	8b c8		 mov	 ecx, eax
  00233	e8 00 00 00 00	 call	 s370_vfetch4
  00238	89 44 24 50	 mov	 DWORD PTR lcpa$[rsp], eax

; 281  : 
; 282  :     /* Fetch the local lock and the suspend queue from the ASCB */
; 283  :     lock_addr = (ascb_addr + ASCBLOCK) & ADDRESS_MAXWRAP(regs);

  0023c	8b 44 24 40	 mov	 eax, DWORD PTR ascb_addr$[rsp]
  00240	05 80 00 00 00	 add	 eax, 128		; 00000080H
  00245	25 ff ff ff 00	 and	 eax, 16777215		; 00ffffffH
  0024a	89 44 24 44	 mov	 DWORD PTR lock_addr$[rsp], eax

; 284  :     susp_addr = (ascb_addr + ASCBLSWQ) & ADDRESS_MAXWRAP(regs);

  0024e	8b 44 24 40	 mov	 eax, DWORD PTR ascb_addr$[rsp]
  00252	05 84 00 00 00	 add	 eax, 132		; 00000084H
  00257	25 ff ff ff 00	 and	 eax, 16777215		; 00ffffffH
  0025c	89 44 24 4c	 mov	 DWORD PTR susp_addr$[rsp], eax

; 285  :     lock = ARCH_DEP(vfetch4) ( lock_addr, acc_mode, regs );

  00260	4c 8b 44 24 78	 mov	 r8, QWORD PTR regs$[rsp]
  00265	8b 54 24 20	 mov	 edx, DWORD PTR acc_mode$[rsp]
  00269	8b 4c 24 44	 mov	 ecx, DWORD PTR lock_addr$[rsp]
  0026d	e8 00 00 00 00	 call	 s370_vfetch4
  00272	89 44 24 54	 mov	 DWORD PTR lock$[rsp], eax

; 286  :     susp = ARCH_DEP(vfetch4) ( susp_addr, acc_mode, regs );

  00276	4c 8b 44 24 78	 mov	 r8, QWORD PTR regs$[rsp]
  0027b	8b 54 24 20	 mov	 edx, DWORD PTR acc_mode$[rsp]
  0027f	8b 4c 24 4c	 mov	 ecx, DWORD PTR susp_addr$[rsp]
  00283	e8 00 00 00 00	 call	 s370_vfetch4
  00288	89 44 24 58	 mov	 DWORD PTR susp$[rsp], eax

; 287  : 
; 288  :     /* Test if this CPU holds the local lock, and does not hold
; 289  :        any CMS lock, and the local lock suspend queue is empty */
; 290  :     if (lock == lcpa
; 291  :         && (hlhi_word & (PSALCLLI | PSACMSLI)) == PSALCLLI
; 292  :         && susp == 0)

  0028c	8b 44 24 50	 mov	 eax, DWORD PTR lcpa$[rsp]
  00290	39 44 24 54	 cmp	 DWORD PTR lock$[rsp], eax
  00294	75 7f		 jne	 SHORT $LN24@s370_relea
  00296	8b 44 24 2c	 mov	 eax, DWORD PTR hlhi_word$[rsp]
  0029a	83 e0 03	 and	 eax, 3
  0029d	83 f8 01	 cmp	 eax, 1
  002a0	75 73		 jne	 SHORT $LN24@s370_relea
  002a2	83 7c 24 58 00	 cmp	 DWORD PTR susp$[rsp], 0
  002a7	75 6c		 jne	 SHORT $LN24@s370_relea

; 293  :     {
; 294  :         /* Store the unchanged value into the second operand to
; 295  :            ensure suppression in the event of an access exception */
; 296  :         ARCH_DEP(vstore4) ( hlhi_word, effective_addr2, acc_mode, regs );

  002a9	4c 8b 4c 24 78	 mov	 r9, QWORD PTR regs$[rsp]
  002ae	44 8b 44 24 20	 mov	 r8d, DWORD PTR acc_mode$[rsp]
  002b3	8b 54 24 24	 mov	 edx, DWORD PTR effective_addr2$[rsp]
  002b7	8b 4c 24 2c	 mov	 ecx, DWORD PTR hlhi_word$[rsp]
  002bb	e8 00 00 00 00	 call	 s370_vstore4

; 297  : 
; 298  :         /* Clear the local lock held bit in the second operand */
; 299  :         hlhi_word &= ~PSALCLLI;

  002c0	8b 44 24 2c	 mov	 eax, DWORD PTR hlhi_word$[rsp]
  002c4	83 e0 fe	 and	 eax, -2			; fffffffeH
  002c7	89 44 24 2c	 mov	 DWORD PTR hlhi_word$[rsp], eax

; 300  :         ARCH_DEP(vstore4) ( hlhi_word, effective_addr2, acc_mode, regs );

  002cb	4c 8b 4c 24 78	 mov	 r9, QWORD PTR regs$[rsp]
  002d0	44 8b 44 24 20	 mov	 r8d, DWORD PTR acc_mode$[rsp]
  002d5	8b 54 24 24	 mov	 edx, DWORD PTR effective_addr2$[rsp]
  002d9	8b 4c 24 2c	 mov	 ecx, DWORD PTR hlhi_word$[rsp]
  002dd	e8 00 00 00 00	 call	 s370_vstore4

; 301  : 
; 302  :         /* Set the local lock to zero */
; 303  :         ARCH_DEP(vstore4) ( 0, lock_addr, acc_mode, regs );

  002e2	4c 8b 4c 24 78	 mov	 r9, QWORD PTR regs$[rsp]
  002e7	44 8b 44 24 20	 mov	 r8d, DWORD PTR acc_mode$[rsp]
  002ec	8b 54 24 44	 mov	 edx, DWORD PTR lock_addr$[rsp]
  002f0	33 c9		 xor	 ecx, ecx
  002f2	e8 00 00 00 00	 call	 s370_vstore4

; 304  : 
; 305  :         /* Set register 13 to zero to indicate lock released */
; 306  :         regs->GR_L(13) = 0;

  002f7	b8 08 00 00 00	 mov	 eax, 8
  002fc	48 6b c0 0d	 imul	 rax, rax, 13
  00300	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  00305	c7 84 01 80 02
	00 00 00 00 00
	00		 mov	 DWORD PTR [rcx+rax+640], 0

; 307  :     }

  00310	e9 24 01 00 00	 jmp	 $LN25@s370_relea
$LN24@s370_relea:

; 308  :     else
; 309  :     {
; 310  :         /* Fetch the lock interface table address from the
; 311  :            second word of the second operand, and load the
; 312  :            new instruction address and amode from LITRLOC */
; 313  :         lit_addr = ARCH_DEP(vfetch4) ( effective_addr2 + 4, acc_mode, regs ) + LITRLOC;

  00315	8b 44 24 24	 mov	 eax, DWORD PTR effective_addr2$[rsp]
  00319	83 c0 04	 add	 eax, 4
  0031c	4c 8b 44 24 78	 mov	 r8, QWORD PTR regs$[rsp]
  00321	8b 54 24 20	 mov	 edx, DWORD PTR acc_mode$[rsp]
  00325	8b c8		 mov	 ecx, eax
  00327	e8 00 00 00 00	 call	 s370_vfetch4
  0032c	83 c0 f4	 add	 eax, -12		; fffffff4H
  0032f	89 44 24 34	 mov	 DWORD PTR lit_addr$[rsp], eax

; 314  :         lit_addr &= ADDRESS_MAXWRAP(regs);

  00333	8b 44 24 34	 mov	 eax, DWORD PTR lit_addr$[rsp]
  00337	25 ff ff ff 00	 and	 eax, 16777215		; 00ffffffH
  0033c	89 44 24 34	 mov	 DWORD PTR lit_addr$[rsp], eax

; 315  :         newia = ARCH_DEP(vfetch4) ( lit_addr, acc_mode, regs );

  00340	4c 8b 44 24 78	 mov	 r8, QWORD PTR regs$[rsp]
  00345	8b 54 24 20	 mov	 edx, DWORD PTR acc_mode$[rsp]
  00349	8b 4c 24 34	 mov	 ecx, DWORD PTR lit_addr$[rsp]
  0034d	e8 00 00 00 00	 call	 s370_vfetch4
  00352	89 44 24 48	 mov	 DWORD PTR newia$[rsp], eax

; 316  : 
; 317  :         /* Save the link information in register 12 */
; 318  :         regs->GR_L(12) = PSW_IA_FROM_IP(regs, 0);

  00356	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  0035b	8b 80 10 02 00
	00		 mov	 eax, DWORD PTR [rax+528]
  00361	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  00366	48 8b 54 24 78	 mov	 rdx, QWORD PTR regs$[rsp]
  0036b	48 8b 92 00 02
	00 00		 mov	 rdx, QWORD PTR [rdx+512]
  00372	48 8b 49 68	 mov	 rcx, QWORD PTR [rcx+104]
  00376	48 2b ca	 sub	 rcx, rdx
  00379	48 03 c1	 add	 rax, rcx
  0037c	48 25 ff ff ff
	00		 and	 rax, 16777215		; 00ffffffH
  00382	b9 08 00 00 00	 mov	 ecx, 8
  00387	48 6b c9 0c	 imul	 rcx, rcx, 12
  0038b	48 8b 54 24 78	 mov	 rdx, QWORD PTR regs$[rsp]
  00390	89 84 0a 80 02
	00 00		 mov	 DWORD PTR [rdx+rcx+640], eax

; 319  : 
; 320  :         /* Copy LITRLOC into register 13 to signify release failure */
; 321  :         regs->GR_L(13) = newia;

  00397	b8 08 00 00 00	 mov	 eax, 8
  0039c	48 6b c0 0d	 imul	 rax, rax, 13
  003a0	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  003a5	8b 54 24 48	 mov	 edx, DWORD PTR newia$[rsp]
  003a9	89 94 01 80 02
	00 00		 mov	 DWORD PTR [rcx+rax+640], edx
$LN10@s370_relea:

; 322  : 
; 323  :         /* Update the PSW instruction address */
; 324  :         SET_PSW_IA_AND_MAYBE_IP(regs, newia);

  003b0	8b 44 24 48	 mov	 eax, DWORD PTR newia$[rsp]
  003b4	25 ff ff ff 00	 and	 eax, 16777215		; 00ffffffH
  003b9	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  003be	89 81 88 00 00
	00		 mov	 DWORD PTR [rcx+136], eax
  003c4	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  003c9	48 83 b8 08 02
	00 00 00	 cmp	 QWORD PTR [rax+520], 0
  003d1	74 5c		 je	 SHORT $LN26@s370_relea
  003d3	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  003d8	8b 80 88 00 00
	00		 mov	 eax, DWORD PTR [rax+136]
  003de	25 01 f8 ff 7f	 and	 eax, 2147481601		; 7ffff801H
  003e3	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  003e8	39 81 10 02 00
	00		 cmp	 DWORD PTR [rcx+528], eax
  003ee	75 2f		 jne	 SHORT $LN27@s370_relea
  003f0	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  003f5	8b 80 88 00 00
	00		 mov	 eax, DWORD PTR [rax+136]
  003fb	25 ff 07 00 00	 and	 eax, 2047		; 000007ffH
  00400	8b c0		 mov	 eax, eax
  00402	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  00407	48 8b 89 00 02
	00 00		 mov	 rcx, QWORD PTR [rcx+512]
  0040e	48 0b c8	 or	 rcx, rax
  00411	48 8b c1	 mov	 rax, rcx
  00414	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  00419	48 89 41 68	 mov	 QWORD PTR [rcx+104], rax
  0041d	eb 10		 jmp	 SHORT $LN28@s370_relea
$LN27@s370_relea:
  0041f	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  00424	48 c7 80 08 02
	00 00 00 00 00
	00		 mov	 QWORD PTR [rax+520], 0
$LN28@s370_relea:
$LN26@s370_relea:
  0042f	33 c0		 xor	 eax, eax
  00431	85 c0		 test	 eax, eax
  00433	0f 85 77 ff ff
	ff		 jne	 $LN10@s370_relea
$LN25@s370_relea:
$LN13@s370_relea:

; 325  :     }
; 326  : 
; 327  :     /* Release main-storage access lock */
; 328  :     RELEASE_MAINLOCK_UNCONDITIONAL(regs);

  00439	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  0043e	48 8b 40 40	 mov	 rax, QWORD PTR [rax+64]
  00442	0f b7 80 60 10
	00 00		 movzx	 eax, WORD PTR [rax+4192]
  00449	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  0044e	48 8b 89 68 08
	00 00		 mov	 rcx, QWORD PTR [rcx+2152]
  00455	0f b7 89 3c 08
	00 00		 movzx	 ecx, WORD PTR [rcx+2108]
  0045c	3b c1		 cmp	 eax, ecx
  0045e	75 34		 jne	 SHORT $LN29@s370_relea
  00460	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  00465	48 8b 40 40	 mov	 rax, QWORD PTR [rax+64]
  00469	b9 ff ff 00 00	 mov	 ecx, 65535		; 0000ffffH
  0046e	66 89 88 60 10
	00 00		 mov	 WORD PTR [rax+4192], cx
  00475	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  0047a	48 8b 40 40	 mov	 rax, QWORD PTR [rax+64]
  0047e	48 05 68 10 00
	00		 add	 rax, 4200		; 00001068H
  00484	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG169746
  0048b	48 8b c8	 mov	 rcx, rax
  0048e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_release_lock
$LN29@s370_relea:
  00494	33 c0		 xor	 eax, eax
  00496	85 c0		 test	 eax, eax
  00498	75 9f		 jne	 SHORT $LN13@s370_relea

; 329  : 
; 330  : } /* end function release_local_lock */

  0049a	48 83 c4 68	 add	 rsp, 104		; 00000068H
  0049e	c3		 ret	 0
s370_release_local_lock ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\assist.c
_TEXT	SEGMENT
acc_mode$ = 32
effective_addr2$ = 36
effective_addr1$ = 40
hlhi_word$ = 44
temp$1 = 48
lock_addr$ = 52
lit_addr$ = 56
b1$ = 60
b2$ = 64
newia$ = 68
ascb_addr$ = 72
lock$ = 76
susp$ = 80
lock_arn$ = 84
inst$ = 112
regs$ = 120
s370_release_cms_lock PROC

; 447  : {

$LN31:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 68	 sub	 rsp, 104		; 00000068H

; 448  : int     b1, b2;                         /* Values of base field      */
; 449  : VADR    effective_addr1,
; 450  :         effective_addr2;                /* Effective addresses       */
; 451  : VADR    ascb_addr;                      /* Virtual address of ASCB   */
; 452  : U32     hlhi_word;                      /* Highest lock held word    */
; 453  : VADR    lit_addr;                       /* Virtual address of lock
; 454  :                                            interface table           */
; 455  : VADR    lock_addr;                      /* Lock address              */
; 456  : int     lock_arn;                       /* Lock access register      */
; 457  : U32     lock;                           /* Lock value                */
; 458  : U32     susp;                           /* Lock suspend queue        */
; 459  : VADR    newia;                          /* Unsuccessful branch addr  */
; 460  : int     acc_mode = 0;                   /* access mode to use        */

  0000e	c7 44 24 20 00
	00 00 00	 mov	 DWORD PTR acc_mode$[rsp], 0

; 461  : 
; 462  :     SSE(inst, regs, b1, effective_addr1, b2, effective_addr2);

  00016	48 8b 44 24 70	 mov	 rax, QWORD PTR inst$[rsp]
  0001b	48 83 c0 02	 add	 rax, 2
  0001f	48 8b c8	 mov	 rcx, rax
  00022	e8 00 00 00 00	 call	 fetch_fw_noswap
  00027	8b c8		 mov	 ecx, eax
  00029	e8 00 00 00 00	 call	 _byteswap_ulong
  0002e	89 44 24 30	 mov	 DWORD PTR temp$1[rsp], eax
  00032	8b 44 24 30	 mov	 eax, DWORD PTR temp$1[rsp]
  00036	25 ff 0f 00 00	 and	 eax, 4095		; 00000fffH
  0003b	89 44 24 24	 mov	 DWORD PTR effective_addr2$[rsp], eax
  0003f	8b 44 24 30	 mov	 eax, DWORD PTR temp$1[rsp]
  00043	c1 e8 0c	 shr	 eax, 12
  00046	83 e0 0f	 and	 eax, 15
  00049	89 44 24 40	 mov	 DWORD PTR b2$[rsp], eax
  0004d	8b 44 24 30	 mov	 eax, DWORD PTR temp$1[rsp]
  00051	c1 e8 10	 shr	 eax, 16
  00054	25 ff 0f 00 00	 and	 eax, 4095		; 00000fffH
  00059	89 44 24 28	 mov	 DWORD PTR effective_addr1$[rsp], eax
  0005d	8b 44 24 30	 mov	 eax, DWORD PTR temp$1[rsp]
  00061	c1 e8 1c	 shr	 eax, 28
  00064	83 e0 0f	 and	 eax, 15
  00067	89 44 24 3c	 mov	 DWORD PTR b1$[rsp], eax
  0006b	83 7c 24 3c 00	 cmp	 DWORD PTR b1$[rsp], 0
  00070	74 2a		 je	 SHORT $LN14@s370_relea
  00072	48 63 44 24 3c	 movsxd	 rax, DWORD PTR b1$[rsp]
  00077	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  0007c	8b 84 c1 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax*8+640]
  00083	8b 4c 24 28	 mov	 ecx, DWORD PTR effective_addr1$[rsp]
  00087	03 c8		 add	 ecx, eax
  00089	8b c1		 mov	 eax, ecx
  0008b	89 44 24 28	 mov	 DWORD PTR effective_addr1$[rsp], eax
  0008f	8b 44 24 28	 mov	 eax, DWORD PTR effective_addr1$[rsp]
  00093	25 ff ff ff 00	 and	 eax, 16777215		; 00ffffffH
  00098	89 44 24 28	 mov	 DWORD PTR effective_addr1$[rsp], eax
$LN14@s370_relea:
  0009c	83 7c 24 40 00	 cmp	 DWORD PTR b2$[rsp], 0
  000a1	74 2a		 je	 SHORT $LN15@s370_relea
  000a3	48 63 44 24 40	 movsxd	 rax, DWORD PTR b2$[rsp]
  000a8	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  000ad	8b 84 c1 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax*8+640]
  000b4	8b 4c 24 24	 mov	 ecx, DWORD PTR effective_addr2$[rsp]
  000b8	03 c8		 add	 ecx, eax
  000ba	8b c1		 mov	 eax, ecx
  000bc	89 44 24 24	 mov	 DWORD PTR effective_addr2$[rsp], eax
  000c0	8b 44 24 24	 mov	 eax, DWORD PTR effective_addr2$[rsp]
  000c4	25 ff ff ff 00	 and	 eax, 16777215		; 00ffffffH
  000c9	89 44 24 24	 mov	 DWORD PTR effective_addr2$[rsp], eax
$LN15@s370_relea:
$LN4@s370_relea:
  000cd	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  000d2	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  000d6	48 83 c0 06	 add	 rax, 6
  000da	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  000df	48 89 41 68	 mov	 QWORD PTR [rcx+104], rax
  000e3	33 c0		 xor	 eax, eax
  000e5	83 f8 06	 cmp	 eax, 6
  000e8	74 0c		 je	 SHORT $LN16@s370_relea
  000ea	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  000ef	c6 80 9a 00 00
	00 06		 mov	 BYTE PTR [rax+154], 6
$LN16@s370_relea:
  000f6	33 c0		 xor	 eax, eax
  000f8	85 c0		 test	 eax, eax
  000fa	75 d1		 jne	 SHORT $LN4@s370_relea

; 463  :     PER_ZEROADDR_XCHECK2( regs, b1, b2 );
; 464  : 
; 465  :     GUEST_CHECK( );

  000fc	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  00101	0f b6 40 7a	 movzx	 eax, BYTE PTR [rax+122]
  00105	83 e0 01	 and	 eax, 1
  00108	85 c0		 test	 eax, eax
  0010a	74 44		 je	 SHORT $LN17@s370_relea
  0010c	b8 08 00 00 00	 mov	 eax, 8
  00111	48 6b c0 07	 imul	 rax, rax, 7
  00115	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  0011a	8b 84 01 00 06
	00 00		 mov	 eax, DWORD PTR [rcx+rax+1536]
  00121	25 04 00 00 40	 and	 eax, 1073741828		; 40000004H
  00126	83 f8 04	 cmp	 eax, 4
  00129	74 25		 je	 SHORT $LN18@s370_relea
  0012b	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  00130	0f b6 40 7a	 movzx	 eax, BYTE PTR [rax+122]
  00134	83 e0 01	 and	 eax, 1
  00137	85 c0		 test	 eax, eax
  00139	74 15		 je	 SHORT $LN19@s370_relea
  0013b	ba 02 00 00 00	 mov	 edx, 2
  00140	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  00145	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  0014a	ff 90 20 0d 00
	00		 call	 QWORD PTR [rax+3360]
$LN19@s370_relea:
$LN18@s370_relea:
$LN17@s370_relea:

; 466  : 
; 467  :     /* Specification exception if operands are not on word boundary */
; 468  :     if ((effective_addr1 & 0x00000003) || (effective_addr2 & 0x00000003))

  00150	8b 44 24 28	 mov	 eax, DWORD PTR effective_addr1$[rsp]
  00154	83 e0 03	 and	 eax, 3
  00157	85 c0		 test	 eax, eax
  00159	75 0b		 jne	 SHORT $LN21@s370_relea
  0015b	8b 44 24 24	 mov	 eax, DWORD PTR effective_addr2$[rsp]
  0015f	83 e0 03	 and	 eax, 3
  00162	85 c0		 test	 eax, eax
  00164	74 0f		 je	 SHORT $LN20@s370_relea
$LN21@s370_relea:

; 469  :         ARCH_DEP(program_interrupt) (regs, PGM_SPECIFICATION_EXCEPTION);

  00166	ba 06 00 00 00	 mov	 edx, 6
  0016b	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  00170	e8 00 00 00 00	 call	 s370_program_interrupt
$LN20@s370_relea:

; 470  : 
; 471  :     /* General register 11 contains the lock address */
; 472  :     lock_addr = regs->GR_L(11) & ADDRESS_MAXWRAP(regs);

  00175	b8 08 00 00 00	 mov	 eax, 8
  0017a	48 6b c0 0b	 imul	 rax, rax, 11
  0017e	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  00183	8b 84 01 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax+640]
  0018a	25 ff ff ff 00	 and	 eax, 16777215		; 00ffffffH
  0018f	89 44 24 34	 mov	 DWORD PTR lock_addr$[rsp], eax

; 473  :     lock_arn = 11;

  00193	c7 44 24 54 0b
	00 00 00	 mov	 DWORD PTR lock_arn$[rsp], 11
$LN7@s370_relea:

; 474  : 
; 475  :     /* Obtain main-storage access lock */
; 476  :     OBTAIN_MAINLOCK_UNCONDITIONAL(regs);

  0019b	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  001a0	48 8b 80 68 08
	00 00		 mov	 rax, QWORD PTR [rax+2152]
  001a7	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  001ac	48 8b 49 40	 mov	 rcx, QWORD PTR [rcx+64]
  001b0	48 8b 89 b0 12
	00 00		 mov	 rcx, QWORD PTR [rcx+4784]
  001b7	48 39 48 50	 cmp	 QWORD PTR [rax+80], rcx
  001bb	74 42		 je	 SHORT $LN22@s370_relea
  001bd	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  001c2	48 8b 40 40	 mov	 rax, QWORD PTR [rax+64]
  001c6	48 05 68 10 00
	00		 add	 rax, 4200		; 00001068H
  001cc	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG169850
  001d3	48 8b c8	 mov	 rcx, rax
  001d6	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_obtain_lock
  001dc	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  001e1	48 8b 80 68 08
	00 00		 mov	 rax, QWORD PTR [rax+2152]
  001e8	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  001ed	48 8b 49 40	 mov	 rcx, QWORD PTR [rcx+64]
  001f1	0f b7 80 3c 08
	00 00		 movzx	 eax, WORD PTR [rax+2108]
  001f8	66 89 81 60 10
	00 00		 mov	 WORD PTR [rcx+4192], ax
$LN22@s370_relea:
  001ff	33 c0		 xor	 eax, eax
  00201	85 c0		 test	 eax, eax
  00203	75 96		 jne	 SHORT $LN7@s370_relea

; 477  : 
; 478  :     if (ACCESS_REGISTER_MODE(&regs->psw))

  00205	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  0020a	0f b6 40 7b	 movzx	 eax, BYTE PTR [rax+123]
  0020e	83 f8 40	 cmp	 eax, 64			; 00000040H
  00211	75 08		 jne	 SHORT $LN23@s370_relea

; 479  :         acc_mode = USE_PRIMARY_SPACE;

  00213	c7 44 24 20 fd
	ff ff ff	 mov	 DWORD PTR acc_mode$[rsp], -3
$LN23@s370_relea:

; 480  : 
; 481  :     /* Load ASCB address from first operand location */
; 482  :     ascb_addr = ARCH_DEP(vfetch4) ( effective_addr1, acc_mode, regs );

  0021b	4c 8b 44 24 78	 mov	 r8, QWORD PTR regs$[rsp]
  00220	8b 54 24 20	 mov	 edx, DWORD PTR acc_mode$[rsp]
  00224	8b 4c 24 28	 mov	 ecx, DWORD PTR effective_addr1$[rsp]
  00228	e8 00 00 00 00	 call	 s370_vfetch4
  0022d	89 44 24 48	 mov	 DWORD PTR ascb_addr$[rsp], eax

; 483  : 
; 484  :     /* Load locks held bits from second operand location */
; 485  :     hlhi_word = ARCH_DEP(vfetch4) ( effective_addr2, acc_mode, regs );

  00231	4c 8b 44 24 78	 mov	 r8, QWORD PTR regs$[rsp]
  00236	8b 54 24 20	 mov	 edx, DWORD PTR acc_mode$[rsp]
  0023a	8b 4c 24 24	 mov	 ecx, DWORD PTR effective_addr2$[rsp]
  0023e	e8 00 00 00 00	 call	 s370_vfetch4
  00243	89 44 24 2c	 mov	 DWORD PTR hlhi_word$[rsp], eax

; 486  : 
; 487  :     /* Fetch the CMS lock and the suspend queue word */
; 488  :     lock = ARCH_DEP(vfetch4) ( lock_addr, acc_mode, regs );

  00247	4c 8b 44 24 78	 mov	 r8, QWORD PTR regs$[rsp]
  0024c	8b 54 24 20	 mov	 edx, DWORD PTR acc_mode$[rsp]
  00250	8b 4c 24 34	 mov	 ecx, DWORD PTR lock_addr$[rsp]
  00254	e8 00 00 00 00	 call	 s370_vfetch4
  00259	89 44 24 4c	 mov	 DWORD PTR lock$[rsp], eax

; 489  :     susp = ARCH_DEP(vfetch4) ( lock_addr + 4, acc_mode, regs );

  0025d	8b 44 24 34	 mov	 eax, DWORD PTR lock_addr$[rsp]
  00261	83 c0 04	 add	 eax, 4
  00264	4c 8b 44 24 78	 mov	 r8, QWORD PTR regs$[rsp]
  00269	8b 54 24 20	 mov	 edx, DWORD PTR acc_mode$[rsp]
  0026d	8b c8		 mov	 ecx, eax
  0026f	e8 00 00 00 00	 call	 s370_vfetch4
  00274	89 44 24 50	 mov	 DWORD PTR susp$[rsp], eax

; 490  : 
; 491  :     /* Test if current ASCB holds this lock, the locks held indicators
; 492  :        show a CMS lock is held, and the lock suspend queue is empty */
; 493  :     if (lock == ascb_addr
; 494  :         && (hlhi_word & PSACMSLI)
; 495  :         && susp == 0)

  00278	8b 44 24 48	 mov	 eax, DWORD PTR ascb_addr$[rsp]
  0027c	39 44 24 4c	 cmp	 DWORD PTR lock$[rsp], eax
  00280	75 7e		 jne	 SHORT $LN24@s370_relea
  00282	8b 44 24 2c	 mov	 eax, DWORD PTR hlhi_word$[rsp]
  00286	83 e0 02	 and	 eax, 2
  00289	85 c0		 test	 eax, eax
  0028b	74 73		 je	 SHORT $LN24@s370_relea
  0028d	83 7c 24 50 00	 cmp	 DWORD PTR susp$[rsp], 0
  00292	75 6c		 jne	 SHORT $LN24@s370_relea

; 496  :     {
; 497  :         /* Store the unchanged value into the second operand to
; 498  :            ensure suppression in the event of an access exception */
; 499  :         ARCH_DEP(vstore4) ( hlhi_word, effective_addr2, acc_mode, regs );

  00294	4c 8b 4c 24 78	 mov	 r9, QWORD PTR regs$[rsp]
  00299	44 8b 44 24 20	 mov	 r8d, DWORD PTR acc_mode$[rsp]
  0029e	8b 54 24 24	 mov	 edx, DWORD PTR effective_addr2$[rsp]
  002a2	8b 4c 24 2c	 mov	 ecx, DWORD PTR hlhi_word$[rsp]
  002a6	e8 00 00 00 00	 call	 s370_vstore4

; 500  : 
; 501  :         /* Clear the CMS lock held bit in the second operand */
; 502  :         hlhi_word &= ~PSACMSLI;

  002ab	8b 44 24 2c	 mov	 eax, DWORD PTR hlhi_word$[rsp]
  002af	83 e0 fd	 and	 eax, -3			; fffffffdH
  002b2	89 44 24 2c	 mov	 DWORD PTR hlhi_word$[rsp], eax

; 503  :         ARCH_DEP(vstore4) ( hlhi_word, effective_addr2, acc_mode, regs );

  002b6	4c 8b 4c 24 78	 mov	 r9, QWORD PTR regs$[rsp]
  002bb	44 8b 44 24 20	 mov	 r8d, DWORD PTR acc_mode$[rsp]
  002c0	8b 54 24 24	 mov	 edx, DWORD PTR effective_addr2$[rsp]
  002c4	8b 4c 24 2c	 mov	 ecx, DWORD PTR hlhi_word$[rsp]
  002c8	e8 00 00 00 00	 call	 s370_vstore4

; 504  : 
; 505  :         /* Set the CMS lock to zero */
; 506  :         ARCH_DEP(vstore4) ( 0, lock_addr, acc_mode, regs );

  002cd	4c 8b 4c 24 78	 mov	 r9, QWORD PTR regs$[rsp]
  002d2	44 8b 44 24 20	 mov	 r8d, DWORD PTR acc_mode$[rsp]
  002d7	8b 54 24 34	 mov	 edx, DWORD PTR lock_addr$[rsp]
  002db	33 c9		 xor	 ecx, ecx
  002dd	e8 00 00 00 00	 call	 s370_vstore4

; 507  : 
; 508  :         /* Set register 13 to zero to indicate lock released */
; 509  :         regs->GR_L(13) = 0;

  002e2	b8 08 00 00 00	 mov	 eax, 8
  002e7	48 6b c0 0d	 imul	 rax, rax, 13
  002eb	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  002f0	c7 84 01 80 02
	00 00 00 00 00
	00		 mov	 DWORD PTR [rcx+rax+640], 0

; 510  :     }

  002fb	e9 24 01 00 00	 jmp	 $LN25@s370_relea
$LN24@s370_relea:

; 511  :     else
; 512  :     {
; 513  :         /* Fetch the lock interface table address from the
; 514  :            second word of the second operand, and load the
; 515  :            new instruction address and amode from LITRCMS */
; 516  :         lit_addr = ARCH_DEP(vfetch4) ( effective_addr2 + 4, acc_mode, regs ) + LITRCMS;

  00300	8b 44 24 24	 mov	 eax, DWORD PTR effective_addr2$[rsp]
  00304	83 c0 04	 add	 eax, 4
  00307	4c 8b 44 24 78	 mov	 r8, QWORD PTR regs$[rsp]
  0030c	8b 54 24 20	 mov	 edx, DWORD PTR acc_mode$[rsp]
  00310	8b c8		 mov	 ecx, eax
  00312	e8 00 00 00 00	 call	 s370_vfetch4
  00317	83 c0 fc	 add	 eax, -4			; fffffffcH
  0031a	89 44 24 38	 mov	 DWORD PTR lit_addr$[rsp], eax

; 517  :         lit_addr &= ADDRESS_MAXWRAP(regs);

  0031e	8b 44 24 38	 mov	 eax, DWORD PTR lit_addr$[rsp]
  00322	25 ff ff ff 00	 and	 eax, 16777215		; 00ffffffH
  00327	89 44 24 38	 mov	 DWORD PTR lit_addr$[rsp], eax

; 518  :         newia = ARCH_DEP(vfetch4) ( lit_addr, acc_mode, regs );

  0032b	4c 8b 44 24 78	 mov	 r8, QWORD PTR regs$[rsp]
  00330	8b 54 24 20	 mov	 edx, DWORD PTR acc_mode$[rsp]
  00334	8b 4c 24 38	 mov	 ecx, DWORD PTR lit_addr$[rsp]
  00338	e8 00 00 00 00	 call	 s370_vfetch4
  0033d	89 44 24 44	 mov	 DWORD PTR newia$[rsp], eax

; 519  : 
; 520  :         /* Save the link information in register 12 */
; 521  :         regs->GR_L(12) = PSW_IA_FROM_IP(regs, 0);

  00341	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  00346	8b 80 10 02 00
	00		 mov	 eax, DWORD PTR [rax+528]
  0034c	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  00351	48 8b 54 24 78	 mov	 rdx, QWORD PTR regs$[rsp]
  00356	48 8b 92 00 02
	00 00		 mov	 rdx, QWORD PTR [rdx+512]
  0035d	48 8b 49 68	 mov	 rcx, QWORD PTR [rcx+104]
  00361	48 2b ca	 sub	 rcx, rdx
  00364	48 03 c1	 add	 rax, rcx
  00367	48 25 ff ff ff
	00		 and	 rax, 16777215		; 00ffffffH
  0036d	b9 08 00 00 00	 mov	 ecx, 8
  00372	48 6b c9 0c	 imul	 rcx, rcx, 12
  00376	48 8b 54 24 78	 mov	 rdx, QWORD PTR regs$[rsp]
  0037b	89 84 0a 80 02
	00 00		 mov	 DWORD PTR [rdx+rcx+640], eax

; 522  : 
; 523  :         /* Copy LITRCMS into register 13 to signify release failure */
; 524  :         regs->GR_L(13) = newia;

  00382	b8 08 00 00 00	 mov	 eax, 8
  00387	48 6b c0 0d	 imul	 rax, rax, 13
  0038b	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  00390	8b 54 24 44	 mov	 edx, DWORD PTR newia$[rsp]
  00394	89 94 01 80 02
	00 00		 mov	 DWORD PTR [rcx+rax+640], edx
$LN10@s370_relea:

; 525  : 
; 526  :         /* Update the PSW instruction address */
; 527  :         SET_PSW_IA_AND_MAYBE_IP(regs, newia);

  0039b	8b 44 24 44	 mov	 eax, DWORD PTR newia$[rsp]
  0039f	25 ff ff ff 00	 and	 eax, 16777215		; 00ffffffH
  003a4	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  003a9	89 81 88 00 00
	00		 mov	 DWORD PTR [rcx+136], eax
  003af	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  003b4	48 83 b8 08 02
	00 00 00	 cmp	 QWORD PTR [rax+520], 0
  003bc	74 5c		 je	 SHORT $LN26@s370_relea
  003be	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  003c3	8b 80 88 00 00
	00		 mov	 eax, DWORD PTR [rax+136]
  003c9	25 01 f8 ff 7f	 and	 eax, 2147481601		; 7ffff801H
  003ce	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  003d3	39 81 10 02 00
	00		 cmp	 DWORD PTR [rcx+528], eax
  003d9	75 2f		 jne	 SHORT $LN27@s370_relea
  003db	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  003e0	8b 80 88 00 00
	00		 mov	 eax, DWORD PTR [rax+136]
  003e6	25 ff 07 00 00	 and	 eax, 2047		; 000007ffH
  003eb	8b c0		 mov	 eax, eax
  003ed	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  003f2	48 8b 89 00 02
	00 00		 mov	 rcx, QWORD PTR [rcx+512]
  003f9	48 0b c8	 or	 rcx, rax
  003fc	48 8b c1	 mov	 rax, rcx
  003ff	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  00404	48 89 41 68	 mov	 QWORD PTR [rcx+104], rax
  00408	eb 10		 jmp	 SHORT $LN28@s370_relea
$LN27@s370_relea:
  0040a	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  0040f	48 c7 80 08 02
	00 00 00 00 00
	00		 mov	 QWORD PTR [rax+520], 0
$LN28@s370_relea:
$LN26@s370_relea:
  0041a	33 c0		 xor	 eax, eax
  0041c	85 c0		 test	 eax, eax
  0041e	0f 85 77 ff ff
	ff		 jne	 $LN10@s370_relea
$LN25@s370_relea:
$LN13@s370_relea:

; 528  :     }
; 529  : 
; 530  :     /* Release main-storage access lock */
; 531  :     RELEASE_MAINLOCK_UNCONDITIONAL(regs);

  00424	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  00429	48 8b 40 40	 mov	 rax, QWORD PTR [rax+64]
  0042d	0f b7 80 60 10
	00 00		 movzx	 eax, WORD PTR [rax+4192]
  00434	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  00439	48 8b 89 68 08
	00 00		 mov	 rcx, QWORD PTR [rcx+2152]
  00440	0f b7 89 3c 08
	00 00		 movzx	 ecx, WORD PTR [rcx+2108]
  00447	3b c1		 cmp	 eax, ecx
  00449	75 34		 jne	 SHORT $LN29@s370_relea
  0044b	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  00450	48 8b 40 40	 mov	 rax, QWORD PTR [rax+64]
  00454	b9 ff ff 00 00	 mov	 ecx, 65535		; 0000ffffH
  00459	66 89 88 60 10
	00 00		 mov	 WORD PTR [rax+4192], cx
  00460	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  00465	48 8b 40 40	 mov	 rax, QWORD PTR [rax+64]
  00469	48 05 68 10 00
	00		 add	 rax, 4200		; 00001068H
  0046f	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG169858
  00476	48 8b c8	 mov	 rcx, rax
  00479	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_release_lock
$LN29@s370_relea:
  0047f	33 c0		 xor	 eax, eax
  00481	85 c0		 test	 eax, eax
  00483	75 9f		 jne	 SHORT $LN13@s370_relea

; 532  : 
; 533  : } /* end function release_cms_lock */

  00485	48 83 c4 68	 add	 rsp, 104		; 00000068H
  00489	c3		 ret	 0
s370_release_cms_lock ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\assist.c
_TEXT	SEGMENT
effective_addr2$ = 48
acc_mode$ = 52
effective_addr1$ = 56
temp$1 = 60
hlhi_word$ = 64
b2$ = 68
lit_addr$ = 72
b1$ = 76
newia$ = 80
ascb_addr$ = 84
lcpa$ = 88
new$ = 92
old$ = 96
mainstor$ = 104
inst$ = 128
regs$ = 136
s370_obtain_local_lock PROC

; 149  : {

$LN23:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 78	 sub	 rsp, 120		; 00000078H

; 150  :     int     b1, b2;                     /* Values of base field      */
; 151  :     VADR    effective_addr1,
; 152  :             effective_addr2;            /* Effective addresses       */
; 153  :     VADR    ascb_addr;                  /* Virtual address of ASCB   */
; 154  :     U32     hlhi_word;                  /* Highest lock held word    */
; 155  :     VADR    lit_addr;                   /* Virtual address of lock
; 156  :                                            interface table           */
; 157  :     U32     lcpa;                       /* Logical CPU address       */
; 158  :     VADR    newia;                      /* Unsuccessful branch addr  */
; 159  :     BYTE   *mainstor;                   /* mainstor address          */
; 160  :     U32     old;                        /* old value                 */
; 161  :     U32     new;                        /* new value                 */
; 162  :     int     acc_mode = 0;               /* access mode to use        */

  0000e	c7 44 24 34 00
	00 00 00	 mov	 DWORD PTR acc_mode$[rsp], 0

; 163  : 
; 164  :     SSE(inst, regs, b1, effective_addr1, b2, effective_addr2);

  00016	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR inst$[rsp]
  0001e	48 83 c0 02	 add	 rax, 2
  00022	48 8b c8	 mov	 rcx, rax
  00025	e8 00 00 00 00	 call	 fetch_fw_noswap
  0002a	8b c8		 mov	 ecx, eax
  0002c	e8 00 00 00 00	 call	 _byteswap_ulong
  00031	89 44 24 3c	 mov	 DWORD PTR temp$1[rsp], eax
  00035	8b 44 24 3c	 mov	 eax, DWORD PTR temp$1[rsp]
  00039	25 ff 0f 00 00	 and	 eax, 4095		; 00000fffH
  0003e	89 44 24 30	 mov	 DWORD PTR effective_addr2$[rsp], eax
  00042	8b 44 24 3c	 mov	 eax, DWORD PTR temp$1[rsp]
  00046	c1 e8 0c	 shr	 eax, 12
  00049	83 e0 0f	 and	 eax, 15
  0004c	89 44 24 44	 mov	 DWORD PTR b2$[rsp], eax
  00050	8b 44 24 3c	 mov	 eax, DWORD PTR temp$1[rsp]
  00054	c1 e8 10	 shr	 eax, 16
  00057	25 ff 0f 00 00	 and	 eax, 4095		; 00000fffH
  0005c	89 44 24 38	 mov	 DWORD PTR effective_addr1$[rsp], eax
  00060	8b 44 24 3c	 mov	 eax, DWORD PTR temp$1[rsp]
  00064	c1 e8 1c	 shr	 eax, 28
  00067	83 e0 0f	 and	 eax, 15
  0006a	89 44 24 4c	 mov	 DWORD PTR b1$[rsp], eax
  0006e	83 7c 24 4c 00	 cmp	 DWORD PTR b1$[rsp], 0
  00073	74 2d		 je	 SHORT $LN8@s370_obtai
  00075	48 63 44 24 4c	 movsxd	 rax, DWORD PTR b1$[rsp]
  0007a	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00082	8b 84 c1 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax*8+640]
  00089	8b 4c 24 38	 mov	 ecx, DWORD PTR effective_addr1$[rsp]
  0008d	03 c8		 add	 ecx, eax
  0008f	8b c1		 mov	 eax, ecx
  00091	89 44 24 38	 mov	 DWORD PTR effective_addr1$[rsp], eax
  00095	8b 44 24 38	 mov	 eax, DWORD PTR effective_addr1$[rsp]
  00099	25 ff ff ff 00	 and	 eax, 16777215		; 00ffffffH
  0009e	89 44 24 38	 mov	 DWORD PTR effective_addr1$[rsp], eax
$LN8@s370_obtai:
  000a2	83 7c 24 44 00	 cmp	 DWORD PTR b2$[rsp], 0
  000a7	74 2d		 je	 SHORT $LN9@s370_obtai
  000a9	48 63 44 24 44	 movsxd	 rax, DWORD PTR b2$[rsp]
  000ae	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  000b6	8b 84 c1 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax*8+640]
  000bd	8b 4c 24 30	 mov	 ecx, DWORD PTR effective_addr2$[rsp]
  000c1	03 c8		 add	 ecx, eax
  000c3	8b c1		 mov	 eax, ecx
  000c5	89 44 24 30	 mov	 DWORD PTR effective_addr2$[rsp], eax
  000c9	8b 44 24 30	 mov	 eax, DWORD PTR effective_addr2$[rsp]
  000cd	25 ff ff ff 00	 and	 eax, 16777215		; 00ffffffH
  000d2	89 44 24 30	 mov	 DWORD PTR effective_addr2$[rsp], eax
$LN9@s370_obtai:
$LN4@s370_obtai:
  000d6	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  000de	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  000e2	48 83 c0 06	 add	 rax, 6
  000e6	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  000ee	48 89 41 68	 mov	 QWORD PTR [rcx+104], rax
  000f2	33 c0		 xor	 eax, eax
  000f4	83 f8 06	 cmp	 eax, 6
  000f7	74 0f		 je	 SHORT $LN10@s370_obtai
  000f9	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00101	c6 80 9a 00 00
	00 06		 mov	 BYTE PTR [rax+154], 6
$LN10@s370_obtai:
  00108	33 c0		 xor	 eax, eax
  0010a	85 c0		 test	 eax, eax
  0010c	75 c8		 jne	 SHORT $LN4@s370_obtai

; 165  :     PER_ZEROADDR_XCHECK2( regs, b1, b2 );
; 166  : 
; 167  :     GUEST_CHECK( );

  0010e	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00116	0f b6 40 7a	 movzx	 eax, BYTE PTR [rax+122]
  0011a	83 e0 01	 and	 eax, 1
  0011d	85 c0		 test	 eax, eax
  0011f	74 50		 je	 SHORT $LN11@s370_obtai
  00121	b8 08 00 00 00	 mov	 eax, 8
  00126	48 6b c0 07	 imul	 rax, rax, 7
  0012a	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00132	8b 84 01 00 06
	00 00		 mov	 eax, DWORD PTR [rcx+rax+1536]
  00139	25 04 00 00 40	 and	 eax, 1073741828		; 40000004H
  0013e	83 f8 04	 cmp	 eax, 4
  00141	74 2e		 je	 SHORT $LN12@s370_obtai
  00143	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0014b	0f b6 40 7a	 movzx	 eax, BYTE PTR [rax+122]
  0014f	83 e0 01	 and	 eax, 1
  00152	85 c0		 test	 eax, eax
  00154	74 1b		 je	 SHORT $LN13@s370_obtai
  00156	ba 02 00 00 00	 mov	 edx, 2
  0015b	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00163	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0016b	ff 90 20 0d 00
	00		 call	 QWORD PTR [rax+3360]
$LN13@s370_obtai:
$LN12@s370_obtai:
$LN11@s370_obtai:

; 168  : 
; 169  :     /* Specification exception if operands are not on word boundary */
; 170  :     if ((effective_addr1 & 0x00000003) || (effective_addr2 & 0x00000003))

  00171	8b 44 24 38	 mov	 eax, DWORD PTR effective_addr1$[rsp]
  00175	83 e0 03	 and	 eax, 3
  00178	85 c0		 test	 eax, eax
  0017a	75 0b		 jne	 SHORT $LN15@s370_obtai
  0017c	8b 44 24 30	 mov	 eax, DWORD PTR effective_addr2$[rsp]
  00180	83 e0 03	 and	 eax, 3
  00183	85 c0		 test	 eax, eax
  00185	74 12		 je	 SHORT $LN14@s370_obtai
$LN15@s370_obtai:

; 171  :         ARCH_DEP(program_interrupt) (regs, PGM_SPECIFICATION_EXCEPTION);

  00187	ba 06 00 00 00	 mov	 edx, 6
  0018c	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00194	e8 00 00 00 00	 call	 s370_program_interrupt
$LN14@s370_obtai:

; 172  : 
; 173  :     PERFORM_SERIALIZATION(regs);

  00199	0f ae f0	 mfence

; 174  : 
; 175  :     /* MAINLOCK may be required if cmpxchg assists unavailable */
; 176  :     OBTAIN_MAINLOCK(regs);
; 177  :     {
; 178  :         if (ACCESS_REGISTER_MODE(&regs->psw))

  0019c	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  001a4	0f b6 40 7b	 movzx	 eax, BYTE PTR [rax+123]
  001a8	83 f8 40	 cmp	 eax, 64			; 00000040H
  001ab	75 08		 jne	 SHORT $LN16@s370_obtai

; 179  :             acc_mode = USE_PRIMARY_SPACE;

  001ad	c7 44 24 34 fd
	ff ff ff	 mov	 DWORD PTR acc_mode$[rsp], -3
$LN16@s370_obtai:

; 180  : 
; 181  :         /* Load ASCB address from first operand location */
; 182  :         ascb_addr = ARCH_DEP(vfetch4) ( effective_addr1, acc_mode, regs );

  001b5	4c 8b 84 24 88
	00 00 00	 mov	 r8, QWORD PTR regs$[rsp]
  001bd	8b 54 24 34	 mov	 edx, DWORD PTR acc_mode$[rsp]
  001c1	8b 4c 24 38	 mov	 ecx, DWORD PTR effective_addr1$[rsp]
  001c5	e8 00 00 00 00	 call	 s370_vfetch4
  001ca	89 44 24 54	 mov	 DWORD PTR ascb_addr$[rsp], eax

; 183  : 
; 184  :         /* Load locks held bits from second operand location */
; 185  :         hlhi_word = ARCH_DEP(vfetch4) ( effective_addr2, acc_mode, regs );

  001ce	4c 8b 84 24 88
	00 00 00	 mov	 r8, QWORD PTR regs$[rsp]
  001d6	8b 54 24 34	 mov	 edx, DWORD PTR acc_mode$[rsp]
  001da	8b 4c 24 30	 mov	 ecx, DWORD PTR effective_addr2$[rsp]
  001de	e8 00 00 00 00	 call	 s370_vfetch4
  001e3	89 44 24 40	 mov	 DWORD PTR hlhi_word$[rsp], eax

; 186  : 
; 187  :         /* Fetch our logical CPU address from PSALCPUA */
; 188  :         lcpa = ARCH_DEP(vfetch4) ( effective_addr2 - 4, acc_mode, regs );

  001e7	8b 44 24 30	 mov	 eax, DWORD PTR effective_addr2$[rsp]
  001eb	83 e8 04	 sub	 eax, 4
  001ee	4c 8b 84 24 88
	00 00 00	 mov	 r8, QWORD PTR regs$[rsp]
  001f6	8b 54 24 34	 mov	 edx, DWORD PTR acc_mode$[rsp]
  001fa	8b c8		 mov	 ecx, eax
  001fc	e8 00 00 00 00	 call	 s370_vfetch4
  00201	89 44 24 58	 mov	 DWORD PTR lcpa$[rsp], eax

; 189  : 
; 190  :         /* Get mainstor address of ASCBLOCK word */
; 191  :         mainstor = MADDRL (ascb_addr + ASCBLOCK, 4, b2, regs, ACCTYPE_WRITE, regs->psw.pkey);

  00205	8b 44 24 54	 mov	 eax, DWORD PTR ascb_addr$[rsp]
  00209	05 80 00 00 00	 add	 eax, 128		; 00000080H
  0020e	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00216	0f b6 49 79	 movzx	 ecx, BYTE PTR [rcx+121]
  0021a	88 4c 24 28	 mov	 BYTE PTR [rsp+40], cl
  0021e	c7 44 24 20 02
	00 00 00	 mov	 DWORD PTR [rsp+32], 2
  00226	4c 8b 8c 24 88
	00 00 00	 mov	 r9, QWORD PTR regs$[rsp]
  0022e	44 8b 44 24 44	 mov	 r8d, DWORD PTR b2$[rsp]
  00233	ba 04 00 00 00	 mov	 edx, 4
  00238	8b c8		 mov	 ecx, eax
  0023a	e8 00 00 00 00	 call	 s370_maddr_l
  0023f	48 89 44 24 68	 mov	 QWORD PTR mainstor$[rsp], rax

; 192  : 
; 193  :         /* The lock word should contain 0; use this as our compare value.
; 194  :            Swap in the CPU address in lpca */
; 195  :         old = 0;

  00244	c7 44 24 60 00
	00 00 00	 mov	 DWORD PTR old$[rsp], 0

; 196  :         new = CSWAP32(lcpa);

  0024c	8b 4c 24 58	 mov	 ecx, DWORD PTR lcpa$[rsp]
  00250	e8 00 00 00 00	 call	 _byteswap_ulong
  00255	89 44 24 5c	 mov	 DWORD PTR new$[rsp], eax

; 197  : 
; 198  :         /* Try exchanging values; cmpxchg4 returns 0=success, !0=failure */
; 199  :         if (!cmpxchg4( &old, new, mainstor ))

  00259	4c 8b 44 24 68	 mov	 r8, QWORD PTR mainstor$[rsp]
  0025e	8b 54 24 5c	 mov	 edx, DWORD PTR new$[rsp]
  00262	48 8d 4c 24 60	 lea	 rcx, QWORD PTR old$[rsp]
  00267	e8 00 00 00 00	 call	 cmpxchg4_x86
  0026c	0f b6 c0	 movzx	 eax, al
  0026f	85 c0		 test	 eax, eax
  00271	75 60		 jne	 SHORT $LN17@s370_obtai

; 200  :         {
; 201  :             /* Store the unchanged value into the second operand to
; 202  :             ensure suppression in the event of an access exception */
; 203  :             ARCH_DEP(vstore4) ( hlhi_word, effective_addr2, acc_mode, regs );

  00273	4c 8b 8c 24 88
	00 00 00	 mov	 r9, QWORD PTR regs$[rsp]
  0027b	44 8b 44 24 34	 mov	 r8d, DWORD PTR acc_mode$[rsp]
  00280	8b 54 24 30	 mov	 edx, DWORD PTR effective_addr2$[rsp]
  00284	8b 4c 24 40	 mov	 ecx, DWORD PTR hlhi_word$[rsp]
  00288	e8 00 00 00 00	 call	 s370_vstore4

; 204  : 
; 205  :             /* Set the local lock held bit in the second operand */
; 206  :             hlhi_word |= PSALCLLI;

  0028d	8b 44 24 40	 mov	 eax, DWORD PTR hlhi_word$[rsp]
  00291	83 c8 01	 or	 eax, 1
  00294	89 44 24 40	 mov	 DWORD PTR hlhi_word$[rsp], eax

; 207  :             ARCH_DEP(vstore4) ( hlhi_word, effective_addr2, acc_mode, regs );

  00298	4c 8b 8c 24 88
	00 00 00	 mov	 r9, QWORD PTR regs$[rsp]
  002a0	44 8b 44 24 34	 mov	 r8d, DWORD PTR acc_mode$[rsp]
  002a5	8b 54 24 30	 mov	 edx, DWORD PTR effective_addr2$[rsp]
  002a9	8b 4c 24 40	 mov	 ecx, DWORD PTR hlhi_word$[rsp]
  002ad	e8 00 00 00 00	 call	 s370_vstore4

; 208  : 
; 209  :             /* Set register 13 to zero to indicate lock obtained */
; 210  :             regs->GR_L(13) = 0;

  002b2	b8 08 00 00 00	 mov	 eax, 8
  002b7	48 6b c0 0d	 imul	 rax, rax, 13
  002bb	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  002c3	c7 84 01 80 02
	00 00 00 00 00
	00		 mov	 DWORD PTR [rcx+rax+640], 0

; 211  :         }

  002ce	e9 51 01 00 00	 jmp	 $LN18@s370_obtai
$LN17@s370_obtai:

; 212  :         else
; 213  :         {
; 214  :             /* Fetch the lock interface table address from the
; 215  :             second word of the second operand, and load the
; 216  :             new instruction address and amode from LITOLOC */
; 217  :             lit_addr = ARCH_DEP(vfetch4) ( effective_addr2 + 4, acc_mode, regs ) + LITOLOC;

  002d3	8b 44 24 30	 mov	 eax, DWORD PTR effective_addr2$[rsp]
  002d7	83 c0 04	 add	 eax, 4
  002da	4c 8b 84 24 88
	00 00 00	 mov	 r8, QWORD PTR regs$[rsp]
  002e2	8b 54 24 34	 mov	 edx, DWORD PTR acc_mode$[rsp]
  002e6	8b c8		 mov	 ecx, eax
  002e8	e8 00 00 00 00	 call	 s370_vfetch4
  002ed	83 c0 f0	 add	 eax, -16		; fffffff0H
  002f0	89 44 24 48	 mov	 DWORD PTR lit_addr$[rsp], eax

; 218  :             lit_addr &= ADDRESS_MAXWRAP(regs);

  002f4	8b 44 24 48	 mov	 eax, DWORD PTR lit_addr$[rsp]
  002f8	25 ff ff ff 00	 and	 eax, 16777215		; 00ffffffH
  002fd	89 44 24 48	 mov	 DWORD PTR lit_addr$[rsp], eax

; 219  :             newia = ARCH_DEP(vfetch4) ( lit_addr, acc_mode, regs );

  00301	4c 8b 84 24 88
	00 00 00	 mov	 r8, QWORD PTR regs$[rsp]
  00309	8b 54 24 34	 mov	 edx, DWORD PTR acc_mode$[rsp]
  0030d	8b 4c 24 48	 mov	 ecx, DWORD PTR lit_addr$[rsp]
  00311	e8 00 00 00 00	 call	 s370_vfetch4
  00316	89 44 24 50	 mov	 DWORD PTR newia$[rsp], eax

; 220  : 
; 221  :             /* Save the link information in register 12 */
; 222  :             regs->GR_L(12) = PSW_IA_FROM_IP(regs, 0);

  0031a	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00322	8b 80 10 02 00
	00		 mov	 eax, DWORD PTR [rax+528]
  00328	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00330	48 8b 94 24 88
	00 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  00338	48 8b 92 00 02
	00 00		 mov	 rdx, QWORD PTR [rdx+512]
  0033f	48 8b 49 68	 mov	 rcx, QWORD PTR [rcx+104]
  00343	48 2b ca	 sub	 rcx, rdx
  00346	48 03 c1	 add	 rax, rcx
  00349	48 25 ff ff ff
	00		 and	 rax, 16777215		; 00ffffffH
  0034f	b9 08 00 00 00	 mov	 ecx, 8
  00354	48 6b c9 0c	 imul	 rcx, rcx, 12
  00358	48 8b 94 24 88
	00 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  00360	89 84 0a 80 02
	00 00		 mov	 DWORD PTR [rdx+rcx+640], eax

; 223  : 
; 224  :             /* Copy LITOLOC into register 13 to signify obtain failure */
; 225  :             regs->GR_L(13) = newia;

  00367	b8 08 00 00 00	 mov	 eax, 8
  0036c	48 6b c0 0d	 imul	 rax, rax, 13
  00370	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00378	8b 54 24 50	 mov	 edx, DWORD PTR newia$[rsp]
  0037c	89 94 01 80 02
	00 00		 mov	 DWORD PTR [rcx+rax+640], edx
$LN7@s370_obtai:

; 226  : 
; 227  :             /* Update the PSW instruction address */
; 228  :             SET_PSW_IA_AND_MAYBE_IP(regs, newia);

  00383	8b 44 24 50	 mov	 eax, DWORD PTR newia$[rsp]
  00387	25 ff ff ff 00	 and	 eax, 16777215		; 00ffffffH
  0038c	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00394	89 81 88 00 00
	00		 mov	 DWORD PTR [rcx+136], eax
  0039a	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  003a2	48 83 b8 08 02
	00 00 00	 cmp	 QWORD PTR [rax+520], 0
  003aa	74 6e		 je	 SHORT $LN19@s370_obtai
  003ac	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  003b4	8b 80 88 00 00
	00		 mov	 eax, DWORD PTR [rax+136]
  003ba	25 01 f8 ff 7f	 and	 eax, 2147481601		; 7ffff801H
  003bf	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  003c7	39 81 10 02 00
	00		 cmp	 DWORD PTR [rcx+528], eax
  003cd	75 38		 jne	 SHORT $LN20@s370_obtai
  003cf	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  003d7	8b 80 88 00 00
	00		 mov	 eax, DWORD PTR [rax+136]
  003dd	25 ff 07 00 00	 and	 eax, 2047		; 000007ffH
  003e2	8b c0		 mov	 eax, eax
  003e4	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  003ec	48 8b 89 00 02
	00 00		 mov	 rcx, QWORD PTR [rcx+512]
  003f3	48 0b c8	 or	 rcx, rax
  003f6	48 8b c1	 mov	 rax, rcx
  003f9	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00401	48 89 41 68	 mov	 QWORD PTR [rcx+104], rax
  00405	eb 13		 jmp	 SHORT $LN21@s370_obtai
$LN20@s370_obtai:
  00407	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0040f	48 c7 80 08 02
	00 00 00 00 00
	00		 mov	 QWORD PTR [rax+520], 0
$LN21@s370_obtai:
$LN19@s370_obtai:
  0041a	33 c0		 xor	 eax, eax
  0041c	85 c0		 test	 eax, eax
  0041e	0f 85 5f ff ff
	ff		 jne	 $LN7@s370_obtai
$LN18@s370_obtai:

; 229  :         }
; 230  :     }
; 231  :     RELEASE_MAINLOCK(regs);
; 232  : 
; 233  :     PERFORM_SERIALIZATION(regs);

  00424	0f ae f0	 mfence

; 234  : 
; 235  : } /* end function obtain_local_lock */

  00427	48 83 c4 78	 add	 rsp, 120		; 00000078H
  0042b	c3		 ret	 0
s370_obtain_local_lock ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\assist.c
_TEXT	SEGMENT
effective_addr2$ = 48
acc_mode$ = 52
effective_addr1$ = 56
hlhi_word$ = 60
temp$1 = 64
b2$ = 68
lit_addr$ = 72
b1$ = 76
lock_addr$ = 80
tv192 = 84
locked$ = 88
newia$ = 92
lock$ = 96
ascb_addr$ = 100
new$ = 104
old$ = 108
lock_arn$ = 112
mainstor$ = 120
inst$ = 144
regs$ = 152
s370_obtain_cms_lock PROC

; 337  : {

$LN26:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 81 ec 88 00
	00 00		 sub	 rsp, 136		; 00000088H

; 338  :     int     b1, b2;                     /* Values of base field      */
; 339  :     VADR    effective_addr1,
; 340  :             effective_addr2;            /* Effective addresses       */
; 341  :     VADR    ascb_addr;                  /* Virtual address of ASCB   */
; 342  :     U32     hlhi_word;                  /* Highest lock held word    */
; 343  :     VADR    lit_addr;                   /* Virtual address of lock
; 344  :                                            interface table           */
; 345  :     VADR    lock_addr;                  /* Lock address              */
; 346  :     int     lock_arn;                   /* Lock access register      */
; 347  :     U32     lock;                       /* Lock value                */
; 348  :     VADR    newia;                      /* Unsuccessful branch addr  */
; 349  :     BYTE   *mainstor;                   /* mainstor address          */
; 350  :     U32     old;                        /* old value                 */
; 351  :     U32     new;                        /* new value                 */
; 352  :     U32     locked = 0;                 /* status of cmpxchg4 result */

  00011	c7 44 24 58 00
	00 00 00	 mov	 DWORD PTR locked$[rsp], 0

; 353  :     int     acc_mode = 0;               /* access mode to use        */

  00019	c7 44 24 34 00
	00 00 00	 mov	 DWORD PTR acc_mode$[rsp], 0

; 354  : 
; 355  :     SSE(inst, regs, b1, effective_addr1, b2, effective_addr2);

  00021	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR inst$[rsp]
  00029	48 83 c0 02	 add	 rax, 2
  0002d	48 8b c8	 mov	 rcx, rax
  00030	e8 00 00 00 00	 call	 fetch_fw_noswap
  00035	8b c8		 mov	 ecx, eax
  00037	e8 00 00 00 00	 call	 _byteswap_ulong
  0003c	89 44 24 40	 mov	 DWORD PTR temp$1[rsp], eax
  00040	8b 44 24 40	 mov	 eax, DWORD PTR temp$1[rsp]
  00044	25 ff 0f 00 00	 and	 eax, 4095		; 00000fffH
  00049	89 44 24 30	 mov	 DWORD PTR effective_addr2$[rsp], eax
  0004d	8b 44 24 40	 mov	 eax, DWORD PTR temp$1[rsp]
  00051	c1 e8 0c	 shr	 eax, 12
  00054	83 e0 0f	 and	 eax, 15
  00057	89 44 24 44	 mov	 DWORD PTR b2$[rsp], eax
  0005b	8b 44 24 40	 mov	 eax, DWORD PTR temp$1[rsp]
  0005f	c1 e8 10	 shr	 eax, 16
  00062	25 ff 0f 00 00	 and	 eax, 4095		; 00000fffH
  00067	89 44 24 38	 mov	 DWORD PTR effective_addr1$[rsp], eax
  0006b	8b 44 24 40	 mov	 eax, DWORD PTR temp$1[rsp]
  0006f	c1 e8 1c	 shr	 eax, 28
  00072	83 e0 0f	 and	 eax, 15
  00075	89 44 24 4c	 mov	 DWORD PTR b1$[rsp], eax
  00079	83 7c 24 4c 00	 cmp	 DWORD PTR b1$[rsp], 0
  0007e	74 2d		 je	 SHORT $LN8@s370_obtai
  00080	48 63 44 24 4c	 movsxd	 rax, DWORD PTR b1$[rsp]
  00085	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0008d	8b 84 c1 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax*8+640]
  00094	8b 4c 24 38	 mov	 ecx, DWORD PTR effective_addr1$[rsp]
  00098	03 c8		 add	 ecx, eax
  0009a	8b c1		 mov	 eax, ecx
  0009c	89 44 24 38	 mov	 DWORD PTR effective_addr1$[rsp], eax
  000a0	8b 44 24 38	 mov	 eax, DWORD PTR effective_addr1$[rsp]
  000a4	25 ff ff ff 00	 and	 eax, 16777215		; 00ffffffH
  000a9	89 44 24 38	 mov	 DWORD PTR effective_addr1$[rsp], eax
$LN8@s370_obtai:
  000ad	83 7c 24 44 00	 cmp	 DWORD PTR b2$[rsp], 0
  000b2	74 2d		 je	 SHORT $LN9@s370_obtai
  000b4	48 63 44 24 44	 movsxd	 rax, DWORD PTR b2$[rsp]
  000b9	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  000c1	8b 84 c1 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax*8+640]
  000c8	8b 4c 24 30	 mov	 ecx, DWORD PTR effective_addr2$[rsp]
  000cc	03 c8		 add	 ecx, eax
  000ce	8b c1		 mov	 eax, ecx
  000d0	89 44 24 30	 mov	 DWORD PTR effective_addr2$[rsp], eax
  000d4	8b 44 24 30	 mov	 eax, DWORD PTR effective_addr2$[rsp]
  000d8	25 ff ff ff 00	 and	 eax, 16777215		; 00ffffffH
  000dd	89 44 24 30	 mov	 DWORD PTR effective_addr2$[rsp], eax
$LN9@s370_obtai:
$LN4@s370_obtai:
  000e1	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  000e9	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  000ed	48 83 c0 06	 add	 rax, 6
  000f1	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  000f9	48 89 41 68	 mov	 QWORD PTR [rcx+104], rax
  000fd	33 c0		 xor	 eax, eax
  000ff	83 f8 06	 cmp	 eax, 6
  00102	74 0f		 je	 SHORT $LN10@s370_obtai
  00104	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0010c	c6 80 9a 00 00
	00 06		 mov	 BYTE PTR [rax+154], 6
$LN10@s370_obtai:
  00113	33 c0		 xor	 eax, eax
  00115	85 c0		 test	 eax, eax
  00117	75 c8		 jne	 SHORT $LN4@s370_obtai

; 356  :     PER_ZEROADDR_XCHECK2( regs, b1, b2 );
; 357  : 
; 358  :     GUEST_CHECK( );

  00119	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00121	0f b6 40 7a	 movzx	 eax, BYTE PTR [rax+122]
  00125	83 e0 01	 and	 eax, 1
  00128	85 c0		 test	 eax, eax
  0012a	74 50		 je	 SHORT $LN11@s370_obtai
  0012c	b8 08 00 00 00	 mov	 eax, 8
  00131	48 6b c0 07	 imul	 rax, rax, 7
  00135	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0013d	8b 84 01 00 06
	00 00		 mov	 eax, DWORD PTR [rcx+rax+1536]
  00144	25 04 00 00 40	 and	 eax, 1073741828		; 40000004H
  00149	83 f8 04	 cmp	 eax, 4
  0014c	74 2e		 je	 SHORT $LN12@s370_obtai
  0014e	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00156	0f b6 40 7a	 movzx	 eax, BYTE PTR [rax+122]
  0015a	83 e0 01	 and	 eax, 1
  0015d	85 c0		 test	 eax, eax
  0015f	74 1b		 je	 SHORT $LN13@s370_obtai
  00161	ba 02 00 00 00	 mov	 edx, 2
  00166	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0016e	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00176	ff 90 20 0d 00
	00		 call	 QWORD PTR [rax+3360]
$LN13@s370_obtai:
$LN12@s370_obtai:
$LN11@s370_obtai:

; 359  : 
; 360  :     /* Specification exception if operands are not on word boundary */
; 361  :     if ((effective_addr1 & 0x00000003) || (effective_addr2 & 0x00000003))

  0017c	8b 44 24 38	 mov	 eax, DWORD PTR effective_addr1$[rsp]
  00180	83 e0 03	 and	 eax, 3
  00183	85 c0		 test	 eax, eax
  00185	75 0b		 jne	 SHORT $LN15@s370_obtai
  00187	8b 44 24 30	 mov	 eax, DWORD PTR effective_addr2$[rsp]
  0018b	83 e0 03	 and	 eax, 3
  0018e	85 c0		 test	 eax, eax
  00190	74 12		 je	 SHORT $LN14@s370_obtai
$LN15@s370_obtai:

; 362  :         ARCH_DEP(program_interrupt) (regs, PGM_SPECIFICATION_EXCEPTION);

  00192	ba 06 00 00 00	 mov	 edx, 6
  00197	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0019f	e8 00 00 00 00	 call	 s370_program_interrupt
$LN14@s370_obtai:

; 363  : 
; 364  :     PERFORM_SERIALIZATION(regs);

  001a4	0f ae f0	 mfence

; 365  : 
; 366  :     /* General register 11 contains the lock address */
; 367  :     lock_addr = regs->GR_L(11) & ADDRESS_MAXWRAP(regs);

  001a7	b8 08 00 00 00	 mov	 eax, 8
  001ac	48 6b c0 0b	 imul	 rax, rax, 11
  001b0	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  001b8	8b 84 01 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax+640]
  001bf	25 ff ff ff 00	 and	 eax, 16777215		; 00ffffffH
  001c4	89 44 24 50	 mov	 DWORD PTR lock_addr$[rsp], eax

; 368  :     lock_arn = 11;

  001c8	c7 44 24 70 0b
	00 00 00	 mov	 DWORD PTR lock_arn$[rsp], 11

; 369  : 
; 370  :     /* MAINLOCK may be required if cmpxchg assists unavailable */
; 371  :     OBTAIN_MAINLOCK(regs);
; 372  :     {
; 373  :         if (ACCESS_REGISTER_MODE(&regs->psw))

  001d0	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  001d8	0f b6 40 7b	 movzx	 eax, BYTE PTR [rax+123]
  001dc	83 f8 40	 cmp	 eax, 64			; 00000040H
  001df	75 08		 jne	 SHORT $LN16@s370_obtai

; 374  :             acc_mode = USE_PRIMARY_SPACE;

  001e1	c7 44 24 34 fd
	ff ff ff	 mov	 DWORD PTR acc_mode$[rsp], -3
$LN16@s370_obtai:

; 375  : 
; 376  :         /* Load ASCB address from first operand location */
; 377  :         ascb_addr = ARCH_DEP(vfetch4) ( effective_addr1, acc_mode, regs );

  001e9	4c 8b 84 24 98
	00 00 00	 mov	 r8, QWORD PTR regs$[rsp]
  001f1	8b 54 24 34	 mov	 edx, DWORD PTR acc_mode$[rsp]
  001f5	8b 4c 24 38	 mov	 ecx, DWORD PTR effective_addr1$[rsp]
  001f9	e8 00 00 00 00	 call	 s370_vfetch4
  001fe	89 44 24 64	 mov	 DWORD PTR ascb_addr$[rsp], eax

; 378  : 
; 379  :         /* Load locks held bits from second operand location */
; 380  :         hlhi_word = ARCH_DEP(vfetch4) ( effective_addr2, acc_mode, regs );

  00202	4c 8b 84 24 98
	00 00 00	 mov	 r8, QWORD PTR regs$[rsp]
  0020a	8b 54 24 34	 mov	 edx, DWORD PTR acc_mode$[rsp]
  0020e	8b 4c 24 30	 mov	 ecx, DWORD PTR effective_addr2$[rsp]
  00212	e8 00 00 00 00	 call	 s370_vfetch4
  00217	89 44 24 3c	 mov	 DWORD PTR hlhi_word$[rsp], eax

; 381  : 
; 382  :         /* Fetch the lock addressed by general register 11 */
; 383  :         lock = ARCH_DEP(vfetch4) ( lock_addr, acc_mode, regs );

  0021b	4c 8b 84 24 98
	00 00 00	 mov	 r8, QWORD PTR regs$[rsp]
  00223	8b 54 24 34	 mov	 edx, DWORD PTR acc_mode$[rsp]
  00227	8b 4c 24 50	 mov	 ecx, DWORD PTR lock_addr$[rsp]
  0022b	e8 00 00 00 00	 call	 s370_vfetch4
  00230	89 44 24 60	 mov	 DWORD PTR lock$[rsp], eax

; 384  : 
; 385  :         /* Validate that the address space meets criteria to obtain the CMS lock:
; 386  :              the target lock word pointed to by GR11 must be 0,
; 387  :              the LOCAL lock *must* be held on this CPU,
; 388  :              and the CMS lock must *not* be held on this CPU.  */
; 389  :         if (lock == 0
; 390  :             && (hlhi_word & (PSALCLLI | PSACMSLI)) == PSALCLLI)

  00234	83 7c 24 60 00	 cmp	 DWORD PTR lock$[rsp], 0
  00239	0f 85 91 00 00
	00		 jne	 $LN17@s370_obtai
  0023f	8b 44 24 3c	 mov	 eax, DWORD PTR hlhi_word$[rsp]
  00243	83 e0 03	 and	 eax, 3
  00246	83 f8 01	 cmp	 eax, 1
  00249	0f 85 81 00 00
	00		 jne	 $LN17@s370_obtai

; 391  :         {
; 392  :             /* Get mainstor address of lock word */
; 393  :             mainstor = MADDRL (lock_addr, 4, b2, regs, ACCTYPE_WRITE, regs->psw.pkey);

  0024f	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00257	0f b6 40 79	 movzx	 eax, BYTE PTR [rax+121]
  0025b	88 44 24 28	 mov	 BYTE PTR [rsp+40], al
  0025f	c7 44 24 20 02
	00 00 00	 mov	 DWORD PTR [rsp+32], 2
  00267	4c 8b 8c 24 98
	00 00 00	 mov	 r9, QWORD PTR regs$[rsp]
  0026f	44 8b 44 24 44	 mov	 r8d, DWORD PTR b2$[rsp]
  00274	ba 04 00 00 00	 mov	 edx, 4
  00279	8b 4c 24 50	 mov	 ecx, DWORD PTR lock_addr$[rsp]
  0027d	e8 00 00 00 00	 call	 s370_maddr_l
  00282	48 89 44 24 78	 mov	 QWORD PTR mainstor$[rsp], rax

; 394  : 
; 395  :             /* The lock word should contain 0; use this as our compare value.
; 396  :             Swap in the ASCB address from instruction operand 1            */
; 397  :             old = 0;

  00287	c7 44 24 6c 00
	00 00 00	 mov	 DWORD PTR old$[rsp], 0

; 398  :             new = CSWAP32(ascb_addr);

  0028f	8b 4c 24 64	 mov	 ecx, DWORD PTR ascb_addr$[rsp]
  00293	e8 00 00 00 00	 call	 _byteswap_ulong
  00298	89 44 24 68	 mov	 DWORD PTR new$[rsp], eax

; 399  : 
; 400  :             /* Try exchanging values; cmpxchg4 returns 0=success, !0=failure */
; 401  :             locked = !cmpxchg4( &old, new, mainstor );

  0029c	4c 8b 44 24 78	 mov	 r8, QWORD PTR mainstor$[rsp]
  002a1	8b 54 24 68	 mov	 edx, DWORD PTR new$[rsp]
  002a5	48 8d 4c 24 6c	 lea	 rcx, QWORD PTR old$[rsp]
  002aa	e8 00 00 00 00	 call	 cmpxchg4_x86
  002af	0f b6 c0	 movzx	 eax, al
  002b2	85 c0		 test	 eax, eax
  002b4	75 0a		 jne	 SHORT $LN24@s370_obtai
  002b6	c7 44 24 54 01
	00 00 00	 mov	 DWORD PTR tv192[rsp], 1
  002be	eb 08		 jmp	 SHORT $LN25@s370_obtai
$LN24@s370_obtai:
  002c0	c7 44 24 54 00
	00 00 00	 mov	 DWORD PTR tv192[rsp], 0
$LN25@s370_obtai:
  002c8	8b 44 24 54	 mov	 eax, DWORD PTR tv192[rsp]
  002cc	89 44 24 58	 mov	 DWORD PTR locked$[rsp], eax
$LN17@s370_obtai:

; 402  :         }
; 403  : 
; 404  :         if (locked)

  002d0	83 7c 24 58 00	 cmp	 DWORD PTR locked$[rsp], 0
  002d5	74 60		 je	 SHORT $LN18@s370_obtai

; 405  :         {
; 406  :             /* Store the unchanged value into the second operand to
; 407  :             ensure suppression in the event of an access exception */
; 408  :             ARCH_DEP(vstore4) ( hlhi_word, effective_addr2, acc_mode, regs );

  002d7	4c 8b 8c 24 98
	00 00 00	 mov	 r9, QWORD PTR regs$[rsp]
  002df	44 8b 44 24 34	 mov	 r8d, DWORD PTR acc_mode$[rsp]
  002e4	8b 54 24 30	 mov	 edx, DWORD PTR effective_addr2$[rsp]
  002e8	8b 4c 24 3c	 mov	 ecx, DWORD PTR hlhi_word$[rsp]
  002ec	e8 00 00 00 00	 call	 s370_vstore4

; 409  : 
; 410  :             /* Set the CMS lock held bit in the second operand */
; 411  :             hlhi_word |= PSACMSLI;

  002f1	8b 44 24 3c	 mov	 eax, DWORD PTR hlhi_word$[rsp]
  002f5	83 c8 02	 or	 eax, 2
  002f8	89 44 24 3c	 mov	 DWORD PTR hlhi_word$[rsp], eax

; 412  :             ARCH_DEP(vstore4) ( hlhi_word, effective_addr2, acc_mode, regs );

  002fc	4c 8b 8c 24 98
	00 00 00	 mov	 r9, QWORD PTR regs$[rsp]
  00304	44 8b 44 24 34	 mov	 r8d, DWORD PTR acc_mode$[rsp]
  00309	8b 54 24 30	 mov	 edx, DWORD PTR effective_addr2$[rsp]
  0030d	8b 4c 24 3c	 mov	 ecx, DWORD PTR hlhi_word$[rsp]
  00311	e8 00 00 00 00	 call	 s370_vstore4

; 413  : 
; 414  :             /* Set register 13 to zero to indicate lock obtained */
; 415  :             regs->GR_L(13) = 0;

  00316	b8 08 00 00 00	 mov	 eax, 8
  0031b	48 6b c0 0d	 imul	 rax, rax, 13
  0031f	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00327	c7 84 01 80 02
	00 00 00 00 00
	00		 mov	 DWORD PTR [rcx+rax+640], 0

; 416  :         }

  00332	e9 51 01 00 00	 jmp	 $LN19@s370_obtai
$LN18@s370_obtai:

; 417  :         else
; 418  :         {
; 419  :             /* Fetch the lock interface table address from the
; 420  :             second word of the second operand, and load the
; 421  :             new instruction address and amode from LITOCMS */
; 422  :             lit_addr = ARCH_DEP(vfetch4) ( effective_addr2 + 4, acc_mode, regs ) + LITOCMS;

  00337	8b 44 24 30	 mov	 eax, DWORD PTR effective_addr2$[rsp]
  0033b	83 c0 04	 add	 eax, 4
  0033e	4c 8b 84 24 98
	00 00 00	 mov	 r8, QWORD PTR regs$[rsp]
  00346	8b 54 24 34	 mov	 edx, DWORD PTR acc_mode$[rsp]
  0034a	8b c8		 mov	 ecx, eax
  0034c	e8 00 00 00 00	 call	 s370_vfetch4
  00351	83 c0 f8	 add	 eax, -8			; fffffff8H
  00354	89 44 24 48	 mov	 DWORD PTR lit_addr$[rsp], eax

; 423  :             lit_addr &= ADDRESS_MAXWRAP(regs);

  00358	8b 44 24 48	 mov	 eax, DWORD PTR lit_addr$[rsp]
  0035c	25 ff ff ff 00	 and	 eax, 16777215		; 00ffffffH
  00361	89 44 24 48	 mov	 DWORD PTR lit_addr$[rsp], eax

; 424  :             newia = ARCH_DEP(vfetch4) ( lit_addr, acc_mode, regs );

  00365	4c 8b 84 24 98
	00 00 00	 mov	 r8, QWORD PTR regs$[rsp]
  0036d	8b 54 24 34	 mov	 edx, DWORD PTR acc_mode$[rsp]
  00371	8b 4c 24 48	 mov	 ecx, DWORD PTR lit_addr$[rsp]
  00375	e8 00 00 00 00	 call	 s370_vfetch4
  0037a	89 44 24 5c	 mov	 DWORD PTR newia$[rsp], eax

; 425  : 
; 426  :             /* Save the link information in register 12 */
; 427  :             regs->GR_L(12) = PSW_IA_FROM_IP(regs, 0);

  0037e	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00386	8b 80 10 02 00
	00		 mov	 eax, DWORD PTR [rax+528]
  0038c	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00394	48 8b 94 24 98
	00 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  0039c	48 8b 92 00 02
	00 00		 mov	 rdx, QWORD PTR [rdx+512]
  003a3	48 8b 49 68	 mov	 rcx, QWORD PTR [rcx+104]
  003a7	48 2b ca	 sub	 rcx, rdx
  003aa	48 03 c1	 add	 rax, rcx
  003ad	48 25 ff ff ff
	00		 and	 rax, 16777215		; 00ffffffH
  003b3	b9 08 00 00 00	 mov	 ecx, 8
  003b8	48 6b c9 0c	 imul	 rcx, rcx, 12
  003bc	48 8b 94 24 98
	00 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  003c4	89 84 0a 80 02
	00 00		 mov	 DWORD PTR [rdx+rcx+640], eax

; 428  : 
; 429  :             /* Copy LITOCMS into register 13 to signify obtain failure */
; 430  :             regs->GR_L(13) = newia;

  003cb	b8 08 00 00 00	 mov	 eax, 8
  003d0	48 6b c0 0d	 imul	 rax, rax, 13
  003d4	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  003dc	8b 54 24 5c	 mov	 edx, DWORD PTR newia$[rsp]
  003e0	89 94 01 80 02
	00 00		 mov	 DWORD PTR [rcx+rax+640], edx
$LN7@s370_obtai:

; 431  : 
; 432  :             /* Update the PSW instruction address */
; 433  :             SET_PSW_IA_AND_MAYBE_IP(regs, newia);

  003e7	8b 44 24 5c	 mov	 eax, DWORD PTR newia$[rsp]
  003eb	25 ff ff ff 00	 and	 eax, 16777215		; 00ffffffH
  003f0	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  003f8	89 81 88 00 00
	00		 mov	 DWORD PTR [rcx+136], eax
  003fe	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00406	48 83 b8 08 02
	00 00 00	 cmp	 QWORD PTR [rax+520], 0
  0040e	74 6e		 je	 SHORT $LN20@s370_obtai
  00410	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00418	8b 80 88 00 00
	00		 mov	 eax, DWORD PTR [rax+136]
  0041e	25 01 f8 ff 7f	 and	 eax, 2147481601		; 7ffff801H
  00423	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0042b	39 81 10 02 00
	00		 cmp	 DWORD PTR [rcx+528], eax
  00431	75 38		 jne	 SHORT $LN21@s370_obtai
  00433	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0043b	8b 80 88 00 00
	00		 mov	 eax, DWORD PTR [rax+136]
  00441	25 ff 07 00 00	 and	 eax, 2047		; 000007ffH
  00446	8b c0		 mov	 eax, eax
  00448	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00450	48 8b 89 00 02
	00 00		 mov	 rcx, QWORD PTR [rcx+512]
  00457	48 0b c8	 or	 rcx, rax
  0045a	48 8b c1	 mov	 rax, rcx
  0045d	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00465	48 89 41 68	 mov	 QWORD PTR [rcx+104], rax
  00469	eb 13		 jmp	 SHORT $LN22@s370_obtai
$LN21@s370_obtai:
  0046b	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00473	48 c7 80 08 02
	00 00 00 00 00
	00		 mov	 QWORD PTR [rax+520], 0
$LN22@s370_obtai:
$LN20@s370_obtai:
  0047e	33 c0		 xor	 eax, eax
  00480	85 c0		 test	 eax, eax
  00482	0f 85 5f ff ff
	ff		 jne	 $LN7@s370_obtai
$LN19@s370_obtai:

; 434  :         }
; 435  :     }
; 436  :     RELEASE_MAINLOCK(regs);
; 437  : 
; 438  :     PERFORM_SERIALIZATION(regs);

  00488	0f ae f0	 mfence

; 439  : 
; 440  : } /* end function obtain_cms_lock */

  0048b	48 81 c4 88 00
	00 00		 add	 rsp, 136		; 00000088H
  00492	c3		 ret	 0
s370_obtain_cms_lock ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\assist.c
_TEXT	SEGMENT
effective_addr2$ = 32
temp$1 = 36
effective_addr1$ = 40
b1$ = 44
b2$ = 48
mplp$ = 56
inst$ = 80
regs$ = 88
s370_fix_page PROC

; 93   : {

$LN18:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 94   : int     b1, b2;                         /* Values of base field      */
; 95   : VADR    effective_addr1,
; 96   :         effective_addr2;                /* Effective addresses       */
; 97   : RADR    mplp;
; 98   : 
; 99   : #define MPLPFAL  0x34
; 100  : 
; 101  :     SSE( inst, regs, b1, effective_addr1, b2, effective_addr2 );

  0000e	48 8b 44 24 50	 mov	 rax, QWORD PTR inst$[rsp]
  00013	48 83 c0 02	 add	 rax, 2
  00017	48 8b c8	 mov	 rcx, rax
  0001a	e8 00 00 00 00	 call	 fetch_fw_noswap
  0001f	8b c8		 mov	 ecx, eax
  00021	e8 00 00 00 00	 call	 _byteswap_ulong
  00026	89 44 24 24	 mov	 DWORD PTR temp$1[rsp], eax
  0002a	8b 44 24 24	 mov	 eax, DWORD PTR temp$1[rsp]
  0002e	25 ff 0f 00 00	 and	 eax, 4095		; 00000fffH
  00033	89 44 24 20	 mov	 DWORD PTR effective_addr2$[rsp], eax
  00037	8b 44 24 24	 mov	 eax, DWORD PTR temp$1[rsp]
  0003b	c1 e8 0c	 shr	 eax, 12
  0003e	83 e0 0f	 and	 eax, 15
  00041	89 44 24 30	 mov	 DWORD PTR b2$[rsp], eax
  00045	8b 44 24 24	 mov	 eax, DWORD PTR temp$1[rsp]
  00049	c1 e8 10	 shr	 eax, 16
  0004c	25 ff 0f 00 00	 and	 eax, 4095		; 00000fffH
  00051	89 44 24 28	 mov	 DWORD PTR effective_addr1$[rsp], eax
  00055	8b 44 24 24	 mov	 eax, DWORD PTR temp$1[rsp]
  00059	c1 e8 1c	 shr	 eax, 28
  0005c	83 e0 0f	 and	 eax, 15
  0005f	89 44 24 2c	 mov	 DWORD PTR b1$[rsp], eax
  00063	83 7c 24 2c 00	 cmp	 DWORD PTR b1$[rsp], 0
  00068	74 2a		 je	 SHORT $LN8@s370_fix_p
  0006a	48 63 44 24 2c	 movsxd	 rax, DWORD PTR b1$[rsp]
  0006f	48 8b 4c 24 58	 mov	 rcx, QWORD PTR regs$[rsp]
  00074	8b 84 c1 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax*8+640]
  0007b	8b 4c 24 28	 mov	 ecx, DWORD PTR effective_addr1$[rsp]
  0007f	03 c8		 add	 ecx, eax
  00081	8b c1		 mov	 eax, ecx
  00083	89 44 24 28	 mov	 DWORD PTR effective_addr1$[rsp], eax
  00087	8b 44 24 28	 mov	 eax, DWORD PTR effective_addr1$[rsp]
  0008b	25 ff ff ff 00	 and	 eax, 16777215		; 00ffffffH
  00090	89 44 24 28	 mov	 DWORD PTR effective_addr1$[rsp], eax
$LN8@s370_fix_p:
  00094	83 7c 24 30 00	 cmp	 DWORD PTR b2$[rsp], 0
  00099	74 2a		 je	 SHORT $LN9@s370_fix_p
  0009b	48 63 44 24 30	 movsxd	 rax, DWORD PTR b2$[rsp]
  000a0	48 8b 4c 24 58	 mov	 rcx, QWORD PTR regs$[rsp]
  000a5	8b 84 c1 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax*8+640]
  000ac	8b 4c 24 20	 mov	 ecx, DWORD PTR effective_addr2$[rsp]
  000b0	03 c8		 add	 ecx, eax
  000b2	8b c1		 mov	 eax, ecx
  000b4	89 44 24 20	 mov	 DWORD PTR effective_addr2$[rsp], eax
  000b8	8b 44 24 20	 mov	 eax, DWORD PTR effective_addr2$[rsp]
  000bc	25 ff ff ff 00	 and	 eax, 16777215		; 00ffffffH
  000c1	89 44 24 20	 mov	 DWORD PTR effective_addr2$[rsp], eax
$LN9@s370_fix_p:
$LN4@s370_fix_p:
  000c5	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  000ca	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  000ce	48 83 c0 06	 add	 rax, 6
  000d2	48 8b 4c 24 58	 mov	 rcx, QWORD PTR regs$[rsp]
  000d7	48 89 41 68	 mov	 QWORD PTR [rcx+104], rax
  000db	33 c0		 xor	 eax, eax
  000dd	83 f8 06	 cmp	 eax, 6
  000e0	74 0c		 je	 SHORT $LN10@s370_fix_p
  000e2	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  000e7	c6 80 9a 00 00
	00 06		 mov	 BYTE PTR [rax+154], 6
$LN10@s370_fix_p:
  000ee	33 c0		 xor	 eax, eax
  000f0	85 c0		 test	 eax, eax
  000f2	75 d1		 jne	 SHORT $LN4@s370_fix_p

; 102  :     PER_ZEROADDR_XCHECK2( regs, b1, b2 );
; 103  : 
; 104  :     GUEST_CHECK();

  000f4	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  000f9	0f b6 40 7a	 movzx	 eax, BYTE PTR [rax+122]
  000fd	83 e0 01	 and	 eax, 1
  00100	85 c0		 test	 eax, eax
  00102	74 44		 je	 SHORT $LN11@s370_fix_p
  00104	b8 08 00 00 00	 mov	 eax, 8
  00109	48 6b c0 07	 imul	 rax, rax, 7
  0010d	48 8b 4c 24 58	 mov	 rcx, QWORD PTR regs$[rsp]
  00112	8b 84 01 00 06
	00 00		 mov	 eax, DWORD PTR [rcx+rax+1536]
  00119	25 04 00 00 40	 and	 eax, 1073741828		; 40000004H
  0011e	83 f8 04	 cmp	 eax, 4
  00121	74 25		 je	 SHORT $LN12@s370_fix_p
  00123	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  00128	0f b6 40 7a	 movzx	 eax, BYTE PTR [rax+122]
  0012c	83 e0 01	 and	 eax, 1
  0012f	85 c0		 test	 eax, eax
  00131	74 15		 je	 SHORT $LN13@s370_fix_p
  00133	ba 02 00 00 00	 mov	 edx, 2
  00138	48 8b 4c 24 58	 mov	 rcx, QWORD PTR regs$[rsp]
  0013d	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  00142	ff 90 20 0d 00
	00		 call	 QWORD PTR [rax+3360]
$LN13@s370_fix_p:
$LN12@s370_fix_p:
$LN11@s370_fix_p:

; 105  : 
; 106  :     /* The Page Fix assist cannot return via the PTT_ERR( ) method as used
; 107  :        in most of the other assists here.  Per GA22-7079-1 "IBM System/370
; 108  :        Assists for MVS", this assist must NOT exit to the next sequential
; 109  :        instruction.  Instead, we follow the "simplified execution path"
; 110  :        described on page 3 of that documentation for Fix Page.
; 111  :     */
; 112  :     regs->GR_L(14) = PSW_IA_FROM_IP(regs, 0);

  00148	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  0014d	8b 80 10 02 00
	00		 mov	 eax, DWORD PTR [rax+528]
  00153	48 8b 4c 24 58	 mov	 rcx, QWORD PTR regs$[rsp]
  00158	48 8b 54 24 58	 mov	 rdx, QWORD PTR regs$[rsp]
  0015d	48 8b 92 00 02
	00 00		 mov	 rdx, QWORD PTR [rdx+512]
  00164	48 8b 49 68	 mov	 rcx, QWORD PTR [rcx+104]
  00168	48 2b ca	 sub	 rcx, rdx
  0016b	48 03 c1	 add	 rax, rcx
  0016e	48 25 ff ff ff
	00		 and	 rax, 16777215		; 00ffffffH
  00174	b9 08 00 00 00	 mov	 ecx, 8
  00179	48 6b c9 0e	 imul	 rcx, rcx, 14
  0017d	48 8b 54 24 58	 mov	 rdx, QWORD PTR regs$[rsp]
  00182	89 84 0a 80 02
	00 00		 mov	 DWORD PTR [rdx+rcx+640], eax

; 113  : 
; 114  :     mplp = ARCH_DEP( vfetch4 )( (effective_addr2 & ADDRESS_MAXWRAP( regs )),

  00189	8b 44 24 20	 mov	 eax, DWORD PTR effective_addr2$[rsp]
  0018d	25 ff ff ff 00	 and	 eax, 16777215		; 00ffffffH
  00192	4c 8b 44 24 58	 mov	 r8, QWORD PTR regs$[rsp]
  00197	ba ff ff ff ff	 mov	 edx, -1
  0019c	8b c8		 mov	 ecx, eax
  0019e	e8 00 00 00 00	 call	 s370_vfetch4
  001a3	8b c0		 mov	 eax, eax
  001a5	48 89 44 24 38	 mov	 QWORD PTR mplp$[rsp], rax

; 115  :         USE_INST_SPACE, regs );
; 116  : 
; 117  :     regs->GR_L(15) = ARCH_DEP( vfetch4 )( (( mplp+MPLPFAL ) & ADDRESS_MAXWRAP( regs )),

  001aa	48 8b 44 24 38	 mov	 rax, QWORD PTR mplp$[rsp]
  001af	48 83 c0 34	 add	 rax, 52			; 00000034H
  001b3	48 25 ff ff ff
	00		 and	 rax, 16777215		; 00ffffffH
  001b9	4c 8b 44 24 58	 mov	 r8, QWORD PTR regs$[rsp]
  001be	ba ff ff ff ff	 mov	 edx, -1
  001c3	8b c8		 mov	 ecx, eax
  001c5	e8 00 00 00 00	 call	 s370_vfetch4
  001ca	b9 08 00 00 00	 mov	 ecx, 8
  001cf	48 6b c9 0f	 imul	 rcx, rcx, 15
  001d3	48 8b 54 24 58	 mov	 rdx, QWORD PTR regs$[rsp]
  001d8	89 84 0a 80 02
	00 00		 mov	 DWORD PTR [rdx+rcx+640], eax
$LN7@s370_fix_p:

; 118  :         USE_INST_SPACE, regs );
; 119  : 
; 120  :     SET_PSW_IA_AND_MAYBE_IP( regs, regs->GR_L(15) );

  001df	b8 08 00 00 00	 mov	 eax, 8
  001e4	48 6b c0 0f	 imul	 rax, rax, 15
  001e8	48 8b 4c 24 58	 mov	 rcx, QWORD PTR regs$[rsp]
  001ed	8b 84 01 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax+640]
  001f4	25 ff ff ff 00	 and	 eax, 16777215		; 00ffffffH
  001f9	48 8b 4c 24 58	 mov	 rcx, QWORD PTR regs$[rsp]
  001fe	89 81 88 00 00
	00		 mov	 DWORD PTR [rcx+136], eax
  00204	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  00209	48 83 b8 08 02
	00 00 00	 cmp	 QWORD PTR [rax+520], 0
  00211	74 5c		 je	 SHORT $LN14@s370_fix_p
  00213	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  00218	8b 80 88 00 00
	00		 mov	 eax, DWORD PTR [rax+136]
  0021e	25 01 f8 ff 7f	 and	 eax, 2147481601		; 7ffff801H
  00223	48 8b 4c 24 58	 mov	 rcx, QWORD PTR regs$[rsp]
  00228	39 81 10 02 00
	00		 cmp	 DWORD PTR [rcx+528], eax
  0022e	75 2f		 jne	 SHORT $LN15@s370_fix_p
  00230	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  00235	8b 80 88 00 00
	00		 mov	 eax, DWORD PTR [rax+136]
  0023b	25 ff 07 00 00	 and	 eax, 2047		; 000007ffH
  00240	8b c0		 mov	 eax, eax
  00242	48 8b 4c 24 58	 mov	 rcx, QWORD PTR regs$[rsp]
  00247	48 8b 89 00 02
	00 00		 mov	 rcx, QWORD PTR [rcx+512]
  0024e	48 0b c8	 or	 rcx, rax
  00251	48 8b c1	 mov	 rax, rcx
  00254	48 8b 4c 24 58	 mov	 rcx, QWORD PTR regs$[rsp]
  00259	48 89 41 68	 mov	 QWORD PTR [rcx+104], rax
  0025d	eb 10		 jmp	 SHORT $LN16@s370_fix_p
$LN15@s370_fix_p:
  0025f	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  00264	48 c7 80 08 02
	00 00 00 00 00
	00		 mov	 QWORD PTR [rax+520], 0
$LN16@s370_fix_p:
$LN14@s370_fix_p:
  0026f	33 c0		 xor	 eax, eax
  00271	85 c0		 test	 eax, eax
  00273	0f 85 66 ff ff
	ff		 jne	 $LN7@s370_fix_p

; 121  : }

  00279	48 83 c4 48	 add	 rsp, 72			; 00000048H
  0027d	c3		 ret	 0
s370_fix_page ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\assist.c
_TEXT	SEGMENT
entrycode$ = 48
frrnext$ = 52
frrstak$ = 56
cr_ptr$ = 60
size$ = 64
len$ = 68
clear_vaddr$ = 72
r2$ = 76
i$1 = 80
r1$ = 84
frrsize$ = 88
frrcurr$ = 92
frrlast$ = 96
newia$ = 100
frrparm$ = 104
cr34$2 = 112
__$ArrayPad$ = 120
inst$ = 144
regs$ = 152
s370_add_frr PROC

; 680  : {

$LN23:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 81 ec 88 00
	00 00		 sub	 rsp, 136		; 00000088H
  00011	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00018	48 33 c4	 xor	 rax, rsp
  0001b	48 89 44 24 78	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 681  : /*                          ADDFRR
; 682  : 
; 683  :         Add new Functional-Recovery-Routine Stack entry
; 684  : 
; 685  :    What little documentation that exists for this feature can be found
; 686  :    on page 9 of IBM System/370 Assists for MVS, GA22-7079-1 (the text
; 687  :    of which is copied verbatim further below), which can be found on
; 688  :    Bitsavers at:
; 689  : 
; 690  :       * https://bitsavers.org/pdf/ibm/370/MVS/GA22-7079-1_IBM_System_370_Assists_for_MVS_2nd_ed_198110.pdf
; 691  : 
; 692  :    The rest of the documentation regarding how it works is found in the
; 693  :    way MVS itself manages the FRR stack. The assist feature is part of
; 694  :    the 3033 Extensions.
; 695  : 
; 696  :    r1 contains an entry value designating the type of FRR and action to
; 697  :    take by this assist. r2 contains the address of the FRR to be added.
; 698  : */
; 699  : /*                          ADDFRR
; 700  : 
; 701  :     "A new entry is added to the top of the current functional-
; 702  :      recovery-routine (FRR) stack. The entry is initialized with
; 703  :      values provided in general registers and with the PSW S bit
; 704  :      (bit 16)."
; 705  : 
; 706  :     "Optionally, the contents of control registers 3 and 4 are
; 707  :      saved in an entry in a separate table."
; 708  : 
; 709  :     "The general register designated by the r2 field provides the
; 710  :      logical address of the FRR entry point."
; 711  : 
; 712  :     "Before instruction execution, the general register designated
; 713  :      by the r1 field provides three bytes that are stored in the
; 714  :      FRR entry and whose value determines if control registers 3
; 715  :      and 4 are to be stored as well. When instruction execution is
; 716  :      completed, the register designated by r1 contains the logical
; 717  :      address of the six-word work area within the new, current
; 718  :      FRR-stack entry."
; 719  : 
; 720  :     "Logical location 380 hex contains the logical address of the
; 721  :      stack-table header. The stack-table header contains (1) a logical
; 722  :      address which is 32 less than the address of the first dynamic
; 723  :      entry in the stack table, (2) the logical address of the last
; 724  :      entry in the stack table, and (3) the logical address of the
; 725  :      current stack-table entry."
; 726  : 
; 727  :     "At an offset from the beginning of the stack-table header is
; 728  :      found a table of stack-entry-extension entries. Optionally,
; 729  :      the contents of control registers 3 and 4 are saved in an
; 730  :      extension entry. One extension entry corresponds to each entry
; 731  :      in the stack table. The offset to the table of extension entries,
; 732  :      and the encoded length of an extension entry, are found in the
; 733  :      word at logical location BA8 hex."
; 734  : 
; 735  :     Condition Code: The code remains unchanged.
; 736  : 
; 737  :     Program Exceptions:
; 738  :     Access (storage operands)
; 739  :     Operation (when the instruction is not installed)
; 740  :     Privileged operation
; 741  :     Specification
; 742  : */
; 743  : 
; 744  : int     r1, r2;
; 745  : VADR    frrstak;
; 746  : VADR    frrparm;
; 747  : VADR    frrlast;
; 748  : U32     frrsize;
; 749  : VADR    frrcurr;
; 750  : VADR    frrnext;
; 751  : VADR    newia;
; 752  : VADR    cr_ptr;
; 753  : BYTE    entrycode;
; 754  : U32     size, len;
; 755  : VADR    clear_vaddr;
; 756  : static const BYTE zeros[256] = {0};
; 757  : 
; 758  : #define FRRSPARM    0x08
; 759  : 
; 760  : /* Entry code bits in r1 */
; 761  : #define EUT         0x80
; 762  : #define FULLXM      0x08
; 763  : #define PRIMARY     0x04
; 764  : #define LOCAL       0x02
; 765  : #define GLOBAL      0x01
; 766  : #define HOME        0x00
; 767  : 
; 768  :     RRE( inst, regs, r1, r2 );

  00020	b8 01 00 00 00	 mov	 eax, 1
  00025	48 6b c0 03	 imul	 rax, rax, 3
  00029	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR inst$[rsp]
  00031	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00035	89 44 24 50	 mov	 DWORD PTR i$1[rsp], eax
  00039	8b 44 24 50	 mov	 eax, DWORD PTR i$1[rsp]
  0003d	83 e0 0f	 and	 eax, 15
  00040	89 44 24 4c	 mov	 DWORD PTR r2$[rsp], eax
  00044	8b 44 24 50	 mov	 eax, DWORD PTR i$1[rsp]
  00048	c1 f8 04	 sar	 eax, 4
  0004b	83 e0 0f	 and	 eax, 15
  0004e	89 44 24 54	 mov	 DWORD PTR r1$[rsp], eax
$LN4@s370_add_f:
  00052	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0005a	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  0005e	48 83 c0 04	 add	 rax, 4
  00062	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0006a	48 89 41 68	 mov	 QWORD PTR [rcx+104], rax
  0006e	33 c0		 xor	 eax, eax
  00070	83 f8 04	 cmp	 eax, 4
  00073	74 0f		 je	 SHORT $LN10@s370_add_f
  00075	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0007d	c6 80 9a 00 00
	00 04		 mov	 BYTE PTR [rax+154], 4
$LN10@s370_add_f:
  00084	33 c0		 xor	 eax, eax
  00086	85 c0		 test	 eax, eax
  00088	75 c8		 jne	 SHORT $LN4@s370_add_f

; 769  : 
; 770  :     PRIV_CHECK( regs );

  0008a	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00092	0f b6 40 7a	 movzx	 eax, BYTE PTR [rax+122]
  00096	83 e0 01	 and	 eax, 1
  00099	85 c0		 test	 eax, eax
  0009b	74 1b		 je	 SHORT $LN11@s370_add_f
  0009d	ba 02 00 00 00	 mov	 edx, 2
  000a2	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  000aa	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  000b2	ff 90 20 0d 00
	00		 call	 QWORD PTR [rax+3360]
$LN11@s370_add_f:

; 771  : 
; 772  :     /* Obtain needed values from the FRR stack pointers */
; 773  :     frrstak = ARCH_DEP( vfetch4 )( PSACSTK,                                  USE_PRIMARY_SPACE, regs ) & ADDRESS_MAXWRAP( regs );

  000b8	4c 8b 84 24 98
	00 00 00	 mov	 r8, QWORD PTR regs$[rsp]
  000c0	ba fd ff ff ff	 mov	 edx, -3
  000c5	b9 80 03 00 00	 mov	 ecx, 896		; 00000380H
  000ca	e8 00 00 00 00	 call	 s370_vfetch4
  000cf	25 ff ff ff 00	 and	 eax, 16777215		; 00ffffffH
  000d4	89 44 24 38	 mov	 DWORD PTR frrstak$[rsp], eax

; 774  :     frrparm = ARCH_DEP( vfetch4 )( (frrstak +  0),                           USE_PRIMARY_SPACE, regs ) & ADDRESS_MAXWRAP( regs );

  000d8	4c 8b 84 24 98
	00 00 00	 mov	 r8, QWORD PTR regs$[rsp]
  000e0	ba fd ff ff ff	 mov	 edx, -3
  000e5	8b 4c 24 38	 mov	 ecx, DWORD PTR frrstak$[rsp]
  000e9	e8 00 00 00 00	 call	 s370_vfetch4
  000ee	25 ff ff ff 00	 and	 eax, 16777215		; 00ffffffH
  000f3	89 44 24 68	 mov	 DWORD PTR frrparm$[rsp], eax

; 775  :     frrlast = ARCH_DEP( vfetch4 )( (frrstak +  4) & ADDRESS_MAXWRAP( regs ), USE_PRIMARY_SPACE, regs ) & ADDRESS_MAXWRAP( regs );

  000f7	8b 44 24 38	 mov	 eax, DWORD PTR frrstak$[rsp]
  000fb	83 c0 04	 add	 eax, 4
  000fe	25 ff ff ff 00	 and	 eax, 16777215		; 00ffffffH
  00103	4c 8b 84 24 98
	00 00 00	 mov	 r8, QWORD PTR regs$[rsp]
  0010b	ba fd ff ff ff	 mov	 edx, -3
  00110	8b c8		 mov	 ecx, eax
  00112	e8 00 00 00 00	 call	 s370_vfetch4
  00117	25 ff ff ff 00	 and	 eax, 16777215		; 00ffffffH
  0011c	89 44 24 60	 mov	 DWORD PTR frrlast$[rsp], eax

; 776  :     frrsize = ARCH_DEP( vfetch4 )( (frrstak +  8) & ADDRESS_MAXWRAP( regs ), USE_PRIMARY_SPACE, regs );

  00120	8b 44 24 38	 mov	 eax, DWORD PTR frrstak$[rsp]
  00124	83 c0 08	 add	 eax, 8
  00127	25 ff ff ff 00	 and	 eax, 16777215		; 00ffffffH
  0012c	4c 8b 84 24 98
	00 00 00	 mov	 r8, QWORD PTR regs$[rsp]
  00134	ba fd ff ff ff	 mov	 edx, -3
  00139	8b c8		 mov	 ecx, eax
  0013b	e8 00 00 00 00	 call	 s370_vfetch4
  00140	89 44 24 58	 mov	 DWORD PTR frrsize$[rsp], eax

; 777  :     frrcurr = ARCH_DEP( vfetch4 )( (frrstak + 12) & ADDRESS_MAXWRAP( regs ), USE_PRIMARY_SPACE, regs ) & ADDRESS_MAXWRAP( regs );

  00144	8b 44 24 38	 mov	 eax, DWORD PTR frrstak$[rsp]
  00148	83 c0 0c	 add	 eax, 12
  0014b	25 ff ff ff 00	 and	 eax, 16777215		; 00ffffffH
  00150	4c 8b 84 24 98
	00 00 00	 mov	 r8, QWORD PTR regs$[rsp]
  00158	ba fd ff ff ff	 mov	 edx, -3
  0015d	8b c8		 mov	 ecx, eax
  0015f	e8 00 00 00 00	 call	 s370_vfetch4
  00164	25 ff ff ff 00	 and	 eax, 16777215		; 00ffffffH
  00169	89 44 24 5c	 mov	 DWORD PTR frrcurr$[rsp], eax

; 778  :     frrnext = (frrcurr + frrsize) & ADDRESS_MAXWRAP( regs );

  0016d	8b 44 24 58	 mov	 eax, DWORD PTR frrsize$[rsp]
  00171	8b 4c 24 5c	 mov	 ecx, DWORD PTR frrcurr$[rsp]
  00175	03 c8		 add	 ecx, eax
  00177	8b c1		 mov	 eax, ecx
  00179	25 ff ff ff 00	 and	 eax, 16777215		; 00ffffffH
  0017e	89 44 24 34	 mov	 DWORD PTR frrnext$[rsp], eax

; 779  : 
; 780  :     /* Determine if FRR stack is full. If yes, then
; 781  :        branch to the system supplied code at PSALFSCC
; 782  :     */
; 783  :     if (frrnext > frrlast)

  00182	8b 44 24 60	 mov	 eax, DWORD PTR frrlast$[rsp]
  00186	39 44 24 34	 cmp	 DWORD PTR frrnext$[rsp], eax
  0018a	0f 86 c6 00 00
	00		 jbe	 $LN12@s370_add_f

; 784  :     {
; 785  :         newia = ARCH_DEP( vfetch4 )( PSALSFCC, USE_PRIMARY_SPACE, regs ) & ADDRESS_MAXWRAP( regs );

  00190	4c 8b 84 24 98
	00 00 00	 mov	 r8, QWORD PTR regs$[rsp]
  00198	ba fd ff ff ff	 mov	 edx, -3
  0019d	b9 f4 03 00 00	 mov	 ecx, 1012		; 000003f4H
  001a2	e8 00 00 00 00	 call	 s370_vfetch4
  001a7	25 ff ff ff 00	 and	 eax, 16777215		; 00ffffffH
  001ac	89 44 24 64	 mov	 DWORD PTR newia$[rsp], eax
$LN7@s370_add_f:

; 786  :         SET_PSW_IA_AND_MAYBE_IP( regs, newia );

  001b0	8b 44 24 64	 mov	 eax, DWORD PTR newia$[rsp]
  001b4	25 ff ff ff 00	 and	 eax, 16777215		; 00ffffffH
  001b9	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  001c1	89 81 88 00 00
	00		 mov	 DWORD PTR [rcx+136], eax
  001c7	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  001cf	48 83 b8 08 02
	00 00 00	 cmp	 QWORD PTR [rax+520], 0
  001d7	74 6e		 je	 SHORT $LN13@s370_add_f
  001d9	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  001e1	8b 80 88 00 00
	00		 mov	 eax, DWORD PTR [rax+136]
  001e7	25 01 f8 ff 7f	 and	 eax, 2147481601		; 7ffff801H
  001ec	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  001f4	39 81 10 02 00
	00		 cmp	 DWORD PTR [rcx+528], eax
  001fa	75 38		 jne	 SHORT $LN14@s370_add_f
  001fc	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00204	8b 80 88 00 00
	00		 mov	 eax, DWORD PTR [rax+136]
  0020a	25 ff 07 00 00	 and	 eax, 2047		; 000007ffH
  0020f	8b c0		 mov	 eax, eax
  00211	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00219	48 8b 89 00 02
	00 00		 mov	 rcx, QWORD PTR [rcx+512]
  00220	48 0b c8	 or	 rcx, rax
  00223	48 8b c1	 mov	 rax, rcx
  00226	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0022e	48 89 41 68	 mov	 QWORD PTR [rcx+104], rax
  00232	eb 13		 jmp	 SHORT $LN15@s370_add_f
$LN14@s370_add_f:
  00234	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0023c	48 c7 80 08 02
	00 00 00 00 00
	00		 mov	 QWORD PTR [rax+520], 0
$LN15@s370_add_f:
$LN13@s370_add_f:
  00247	33 c0		 xor	 eax, eax
  00249	85 c0		 test	 eax, eax
  0024b	0f 85 5f ff ff
	ff		 jne	 $LN7@s370_add_f

; 787  :         return;

  00251	e9 97 02 00 00	 jmp	 $LN1@s370_add_f
$LN12@s370_add_f:

; 788  :     }
; 789  : 
; 790  :     /* Perform exactly one of the following three functions based on the entry code from r1 */
; 791  :     entrycode = regs->GR_LHLCL( r1 );

  00256	48 63 44 24 54	 movsxd	 rax, DWORD PTR r1$[rsp]
  0025b	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00263	0f b6 84 c1 80
	02 00 00	 movzx	 eax, BYTE PTR [rcx+rax*8+640]
  0026b	88 44 24 30	 mov	 BYTE PTR entrycode$[rsp], al

; 792  : 
; 793  :     /*  1. SETFRR  A,MODE=HOME (no LOCAL/GLOBAL or EUT specification) */
; 794  : 
; 795  :     if (entrycode == HOME)

  0026f	0f b6 44 24 30	 movzx	 eax, BYTE PTR entrycode$[rsp]
  00274	85 c0		 test	 eax, eax
  00276	75 30		 jne	 SHORT $LN16@s370_add_f

; 796  :     {
; 797  :         /* Set the FRR entry point from r2 in the stack */
; 798  :         ARCH_DEP( vstore4 )( regs->GR_L(r2), frrnext, USE_PRIMARY_SPACE, regs );

  00278	48 63 44 24 4c	 movsxd	 rax, DWORD PTR r2$[rsp]
  0027d	4c 8b 8c 24 98
	00 00 00	 mov	 r9, QWORD PTR regs$[rsp]
  00285	41 b8 fd ff ff
	ff		 mov	 r8d, -3
  0028b	8b 54 24 34	 mov	 edx, DWORD PTR frrnext$[rsp]
  0028f	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00297	8b 8c c1 80 02
	00 00		 mov	 ecx, DWORD PTR [rcx+rax*8+640]
  0029e	e8 00 00 00 00	 call	 s370_vstore4

; 799  :     }

  002a3	e9 6e 01 00 00	 jmp	 $LN17@s370_add_f
$LN16@s370_add_f:

; 800  : 
; 801  :     /*  2. SETFRR A,MODE=(HOME, with any combination of LOCAL or GLOBAL or EUT=YES.  */
; 802  : 
; 803  :     else if ((!(entrycode & (FULLXM + PRIMARY))) && (entrycode & (EUT + GLOBAL + LOCAL)))

  002a8	0f b6 44 24 30	 movzx	 eax, BYTE PTR entrycode$[rsp]
  002ad	83 e0 0c	 and	 eax, 12
  002b0	85 c0		 test	 eax, eax
  002b2	75 69		 jne	 SHORT $LN18@s370_add_f
  002b4	0f b6 44 24 30	 movzx	 eax, BYTE PTR entrycode$[rsp]
  002b9	25 83 00 00 00	 and	 eax, 131		; 00000083H
  002be	85 c0		 test	 eax, eax
  002c0	74 5b		 je	 SHORT $LN18@s370_add_f

; 804  :     {
; 805  :         /* Set the FRR entry point from r2 in the stack */
; 806  :         ARCH_DEP( vstore4 )( regs->GR_L(r2) | 0x00000001, frrnext, USE_PRIMARY_SPACE, regs );

  002c2	48 63 44 24 4c	 movsxd	 rax, DWORD PTR r2$[rsp]
  002c7	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  002cf	8b 84 c1 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax*8+640]
  002d6	83 c8 01	 or	 eax, 1
  002d9	4c 8b 8c 24 98
	00 00 00	 mov	 r9, QWORD PTR regs$[rsp]
  002e1	41 b8 fd ff ff
	ff		 mov	 r8d, -3
  002e7	8b 54 24 34	 mov	 edx, DWORD PTR frrnext$[rsp]
  002eb	8b c8		 mov	 ecx, eax
  002ed	e8 00 00 00 00	 call	 s370_vstore4

; 807  : 
; 808  :         /* The entry code is stored in the FRR stack */
; 809  :         ARCH_DEP( vstoreb )( entrycode, (frrnext + 7) & ADDRESS_MAXWRAP( regs ), USE_PRIMARY_SPACE, regs );

  002f2	8b 44 24 34	 mov	 eax, DWORD PTR frrnext$[rsp]
  002f6	83 c0 07	 add	 eax, 7
  002f9	25 ff ff ff 00	 and	 eax, 16777215		; 00ffffffH
  002fe	4c 8b 8c 24 98
	00 00 00	 mov	 r9, QWORD PTR regs$[rsp]
  00306	41 b8 fd ff ff
	ff		 mov	 r8d, -3
  0030c	8b d0		 mov	 edx, eax
  0030e	0f b6 4c 24 30	 movzx	 ecx, BYTE PTR entrycode$[rsp]
  00313	e8 00 00 00 00	 call	 s370_vstoreb

; 810  :     }

  00318	e9 f9 00 00 00	 jmp	 $LN19@s370_add_f
$LN18@s370_add_f:

; 811  : 
; 812  :     /*  3. SETFRR A,MODE=(FULLXM | PRIMARY, with any or no combination of LOCAL or GLOBAL or EUT=YES.  */
; 813  : 
; 814  :     else
; 815  :     {
; 816  :         BYTE cr34[8];  // CR3 and CR4
; 817  : 
; 818  :         /* Set the FRR entry point from r2 in the stack */
; 819  :         ARCH_DEP( vstore4 )( regs->GR_L(r2) | 0x00000001, frrnext, USE_PRIMARY_SPACE, regs );

  0031d	48 63 44 24 4c	 movsxd	 rax, DWORD PTR r2$[rsp]
  00322	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0032a	8b 84 c1 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax*8+640]
  00331	83 c8 01	 or	 eax, 1
  00334	4c 8b 8c 24 98
	00 00 00	 mov	 r9, QWORD PTR regs$[rsp]
  0033c	41 b8 fd ff ff
	ff		 mov	 r8d, -3
  00342	8b 54 24 34	 mov	 edx, DWORD PTR frrnext$[rsp]
  00346	8b c8		 mov	 ecx, eax
  00348	e8 00 00 00 00	 call	 s370_vstore4

; 820  : 
; 821  :         /* Check if in secondary access mode; if yes turn on secondary bit in the entry code */
; 822  :         if (ARCH_DEP( vfetchb )( (PSAXMFLG & ADDRESS_MAXWRAP( regs )), USE_PRIMARY_SPACE, regs ) & PSAXMODE)

  0034d	4c 8b 84 24 98
	00 00 00	 mov	 r8, QWORD PTR regs$[rsp]
  00355	ba fd ff ff ff	 mov	 edx, -3
  0035a	b9 9c 04 00 00	 mov	 ecx, 1180		; 0000049cH
  0035f	e8 00 00 00 00	 call	 s370_vfetchb
  00364	0f b6 c0	 movzx	 eax, al
  00367	83 e0 40	 and	 eax, 64			; 00000040H
  0036a	85 c0		 test	 eax, eax
  0036c	74 0c		 je	 SHORT $LN20@s370_add_f

; 823  :             entrycode |= PSAXMODE;  // indicate to FRR in secondary mode

  0036e	0f b6 44 24 30	 movzx	 eax, BYTE PTR entrycode$[rsp]
  00373	83 c8 40	 or	 eax, 64			; 00000040H
  00376	88 44 24 30	 mov	 BYTE PTR entrycode$[rsp], al
$LN20@s370_add_f:

; 824  : 
; 825  :         /* The entry code is stored in the FRR stack */
; 826  :         ARCH_DEP( vstoreb )( entrycode, ((frrnext + 7) & ADDRESS_MAXWRAP( regs )), USE_PRIMARY_SPACE, regs );

  0037a	8b 44 24 34	 mov	 eax, DWORD PTR frrnext$[rsp]
  0037e	83 c0 07	 add	 eax, 7
  00381	25 ff ff ff 00	 and	 eax, 16777215		; 00ffffffH
  00386	4c 8b 8c 24 98
	00 00 00	 mov	 r9, QWORD PTR regs$[rsp]
  0038e	41 b8 fd ff ff
	ff		 mov	 r8d, -3
  00394	8b d0		 mov	 edx, eax
  00396	0f b6 4c 24 30	 movzx	 ecx, BYTE PTR entrycode$[rsp]
  0039b	e8 00 00 00 00	 call	 s370_vstoreb

; 827  : 
; 828  :         /* Compute the address of the FRR area where CR3 and CR4 are copied from the PSA */
; 829  :         cr_ptr = frrnext - frrparm;

  003a0	8b 44 24 68	 mov	 eax, DWORD PTR frrparm$[rsp]
  003a4	8b 4c 24 34	 mov	 ecx, DWORD PTR frrnext$[rsp]
  003a8	2b c8		 sub	 ecx, eax
  003aa	8b c1		 mov	 eax, ecx
  003ac	89 44 24 3c	 mov	 DWORD PTR cr_ptr$[rsp], eax

; 830  :         cr_ptr = cr_ptr >> 2;

  003b0	8b 44 24 3c	 mov	 eax, DWORD PTR cr_ptr$[rsp]
  003b4	c1 e8 02	 shr	 eax, 2
  003b7	89 44 24 3c	 mov	 DWORD PTR cr_ptr$[rsp], eax

; 831  :         cr_ptr = (frrstak + cr_ptr + 120) & ADDRESS_MAXWRAP( regs );

  003bb	8b 44 24 38	 mov	 eax, DWORD PTR frrstak$[rsp]
  003bf	8b 4c 24 3c	 mov	 ecx, DWORD PTR cr_ptr$[rsp]
  003c3	8d 44 08 78	 lea	 eax, DWORD PTR [rax+rcx+120]
  003c7	25 ff ff ff 00	 and	 eax, 16777215		; 00ffffffH
  003cc	89 44 24 3c	 mov	 DWORD PTR cr_ptr$[rsp], eax

; 832  : 
; 833  :         /* Copy CR3 and CR4 values from PSA to computed FRR area */
; 834  :         ARCH_DEP( vfetchc )( cr34, 8-1, PSAXMCR3, USE_PRIMARY_SPACE, regs );

  003d0	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  003d8	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  003dd	41 b9 fd ff ff
	ff		 mov	 r9d, -3
  003e3	41 b8 c4 05 00
	00		 mov	 r8d, 1476		; 000005c4H
  003e9	b2 07		 mov	 dl, 7
  003eb	48 8d 4c 24 70	 lea	 rcx, QWORD PTR cr34$2[rsp]
  003f0	e8 00 00 00 00	 call	 s370_vfetchc

; 835  :         ARCH_DEP( vstorec )( cr34, 8-1, cr_ptr, 0, regs );

  003f5	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  003fd	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00402	45 33 c9	 xor	 r9d, r9d
  00405	44 8b 44 24 3c	 mov	 r8d, DWORD PTR cr_ptr$[rsp]
  0040a	b2 07		 mov	 dl, 7
  0040c	48 8d 4c 24 70	 lea	 rcx, QWORD PTR cr34$2[rsp]
  00411	e8 00 00 00 00	 call	 s370_vstorec
$LN19@s370_add_f:
$LN17@s370_add_f:

; 836  :     }
; 837  : 
; 838  :     /* Update the FRR stack pointers to point to the newly added FRR */
; 839  :     ARCH_DEP( vstore4 )( frrnext, (frrstak + 12) & ADDRESS_MAXWRAP( regs ), USE_PRIMARY_SPACE, regs );

  00416	8b 44 24 38	 mov	 eax, DWORD PTR frrstak$[rsp]
  0041a	83 c0 0c	 add	 eax, 12
  0041d	25 ff ff ff 00	 and	 eax, 16777215		; 00ffffffH
  00422	4c 8b 8c 24 98
	00 00 00	 mov	 r9, QWORD PTR regs$[rsp]
  0042a	41 b8 fd ff ff
	ff		 mov	 r8d, -3
  00430	8b d0		 mov	 edx, eax
  00432	8b 4c 24 34	 mov	 ecx, DWORD PTR frrnext$[rsp]
  00436	e8 00 00 00 00	 call	 s370_vstore4

; 840  : 
; 841  :     /* Return with the FRRSPARM area address in r1 per the assist documentation  */
; 842  :     regs->GR_L(r1) = (frrnext + FRRSPARM) & ADDRESS_MAXWRAP( regs );

  0043b	8b 44 24 34	 mov	 eax, DWORD PTR frrnext$[rsp]
  0043f	83 c0 08	 add	 eax, 8
  00442	25 ff ff ff 00	 and	 eax, 16777215		; 00ffffffH
  00447	48 63 4c 24 54	 movsxd	 rcx, DWORD PTR r1$[rsp]
  0044c	48 8b 94 24 98
	00 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  00454	89 84 ca 80 02
	00 00		 mov	 DWORD PTR [rdx+rcx*8+640], eax

; 843  : 
; 844  :     /* Initialize (clear) the rest of the FRR stack */
; 845  :     clear_vaddr = (frrnext + 8) & ADDRESS_MAXWRAP( regs );

  0045b	8b 44 24 34	 mov	 eax, DWORD PTR frrnext$[rsp]
  0045f	83 c0 08	 add	 eax, 8
  00462	25 ff ff ff 00	 and	 eax, 16777215		; 00ffffffH
  00467	89 44 24 48	 mov	 DWORD PTR clear_vaddr$[rsp], eax

; 846  :     len = 256;

  0046b	c7 44 24 44 00
	01 00 00	 mov	 DWORD PTR len$[rsp], 256 ; 00000100H

; 847  :     size = frrsize;

  00473	8b 44 24 58	 mov	 eax, DWORD PTR frrsize$[rsp]
  00477	89 44 24 40	 mov	 DWORD PTR size$[rsp], eax
$LN8@s370_add_f:

; 848  :     while (size)

  0047b	83 7c 24 40 00	 cmp	 DWORD PTR size$[rsp], 0
  00480	74 6b		 je	 SHORT $LN9@s370_add_f

; 849  :     {
; 850  :         if (len > size) len = size;

  00482	8b 44 24 40	 mov	 eax, DWORD PTR size$[rsp]
  00486	39 44 24 44	 cmp	 DWORD PTR len$[rsp], eax
  0048a	76 08		 jbe	 SHORT $LN21@s370_add_f
  0048c	8b 44 24 40	 mov	 eax, DWORD PTR size$[rsp]
  00490	89 44 24 44	 mov	 DWORD PTR len$[rsp], eax
$LN21@s370_add_f:

; 851  :         ARCH_DEP( vstorec )( zeros, len-1, clear_vaddr, 0, regs );

  00494	8b 44 24 44	 mov	 eax, DWORD PTR len$[rsp]
  00498	ff c8		 dec	 eax
  0049a	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  004a2	48 89 4c 24 20	 mov	 QWORD PTR [rsp+32], rcx
  004a7	45 33 c9	 xor	 r9d, r9d
  004aa	44 8b 44 24 48	 mov	 r8d, DWORD PTR clear_vaddr$[rsp]
  004af	0f b6 d0	 movzx	 edx, al
  004b2	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:?zeros@?1??s370_add_frr@@9@9
  004b9	e8 00 00 00 00	 call	 s370_vstorec

; 852  :         size        -= len;

  004be	8b 44 24 44	 mov	 eax, DWORD PTR len$[rsp]
  004c2	8b 4c 24 40	 mov	 ecx, DWORD PTR size$[rsp]
  004c6	2b c8		 sub	 ecx, eax
  004c8	8b c1		 mov	 eax, ecx
  004ca	89 44 24 40	 mov	 DWORD PTR size$[rsp], eax

; 853  :         clear_vaddr += len;

  004ce	8b 44 24 44	 mov	 eax, DWORD PTR len$[rsp]
  004d2	8b 4c 24 48	 mov	 ecx, DWORD PTR clear_vaddr$[rsp]
  004d6	03 c8		 add	 ecx, eax
  004d8	8b c1		 mov	 eax, ecx
  004da	89 44 24 48	 mov	 DWORD PTR clear_vaddr$[rsp], eax

; 854  :         clear_vaddr &= ADDRESS_MAXWRAP( regs );

  004de	8b 44 24 48	 mov	 eax, DWORD PTR clear_vaddr$[rsp]
  004e2	25 ff ff ff 00	 and	 eax, 16777215		; 00ffffffH
  004e7	89 44 24 48	 mov	 DWORD PTR clear_vaddr$[rsp], eax

; 855  :     }

  004eb	eb 8e		 jmp	 SHORT $LN8@s370_add_f
$LN9@s370_add_f:
$LN1@s370_add_f:

; 856  : }

  004ed	48 8b 4c 24 78	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  004f2	48 33 cc	 xor	 rcx, rsp
  004f5	e8 00 00 00 00	 call	 __security_check_cookie
  004fa	48 81 c4 88 00
	00 00		 add	 rsp, 136		; 00000088H
  00501	c3		 ret	 0
s370_add_frr ENDP
_TEXT	ENDS
END
