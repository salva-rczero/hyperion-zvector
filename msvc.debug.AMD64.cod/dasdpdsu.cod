; Listing generated by Microsoft (R) Optimizing Compiler Version 19.34.31937.0 

include listing.inc

INCLUDELIB MSVCRTD
INCLUDELIB OLDNAMES

CONST	SEGMENT
CKD_ENDTRK DB	0ffH
	DB	0ffH
	DB	0ffH
	DB	0ffH
	DB	0ffH
	DB	0ffH
	DB	0ffH
	DB	0ffH
VOL1_KEYA DB	056H
	DB	04fH
	DB	04cH
	DB	031H
VOL1_KEY DB	0e5H
	DB	0d6H
	DB	0d3H
	DB	0f1H
IPL1_KEY DB	0c9H
	DB	0d7H
	DB	0d3H
	DB	0f1H
IPL2_KEY DB	0c9H
	DB	0d7H
	DB	0d3H
	DB	0f2H
iplpsw	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
iplccw1	DB	06H
	DB	00H
	DB	03aH
	DB	098H
	DB	060H
	DB	00H
	DB	00H
	DB	060H
iplccw2	DB	08H
	DB	00H
	DB	03aH
	DB	098H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
noiplpsw DB	00H
	DB	02H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	0fH
noiplccw1 DB	03H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	01H
noiplccw2 DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
ipl2data DB	07H
	DB	00H
	DB	03aH
	DB	0b8H
	DB	040H
	DB	00H
	DB	00H
	DB	06H
	DB	031H
	DB	00H
	DB	03aH
	DB	0beH
	DB	040H
	DB	00H
	DB	00H
	DB	05H
	DB	08H
	DB	00H
	DB	03aH
	DB	0a0H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	06H
	DB	00H
	DB	00H
	DB	00H
	DB	020H
	DB	00H
	DB	07fH
	DB	0ffH
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	04H
CONST	ENDS
PUBLIC	__local_stdio_printf_options
PUBLIC	_vsnprintf_s_l
PUBLIC	_vsnprintf_s
PUBLIC	fetch_hw_noswap
PUBLIC	main
EXTRN	__report_rangecheckfailure:PROC
EXTRN	__imp__errno:PROC
EXTRN	__imp__stricmp:PROC
EXTRN	strlen:PROC
EXTRN	__imp_strncpy:PROC
EXTRN	__imp_IsDebuggerPresent:PROC
EXTRN	__imp_OutputDebugStringA:PROC
EXTRN	__imp_free:PROC
EXTRN	__imp_malloc:PROC
EXTRN	_byteswap_ushort:PROC
EXTRN	__imp___acrt_iob_func:PROC
EXTRN	__imp_ferror:PROC
EXTRN	__imp_fopen:PROC
EXTRN	__imp___stdio_common_vsnprintf_s:PROC
EXTRN	__imp__stat64:PROC
EXTRN	__imp_strlcpy:PROC
EXTRN	__imp_strlcat:PROC
EXTRN	__imp_initialize_utility:PROC
EXTRN	__imp_string_to_upper:PROC
EXTRN	__imp_string_to_lower:PROC
EXTRN	__imp_make_asciiz:PROC
EXTRN	__imp_w32_strerror:PROC
EXTRN	__imp_hostpath:PROC
EXTRN	__imp_w32_fwrite:PROC
EXTRN	__imp_w32_fprintf:PROC
EXTRN	__imp_w32_fclose:PROC
EXTRN	__imp_fwritemsg:PROC
EXTRN	__imp_logmsg:PROC
EXTRN	__imp_read_block:PROC
EXTRN	__imp_convert_tt:PROC
EXTRN	__imp_open_ckd_image:PROC
EXTRN	__imp_close_ckd_image:PROC
EXTRN	__imp_build_extent_array:PROC
EXTRN	__GSHandlerCheck:PROC
EXTRN	__security_check_cookie:PROC
EXTRN	memcmp:PROC
EXTRN	__imp_extgui:DWORD
EXTRN	__security_cookie:QWORD
_DATA	SEGMENT
COMM	?_OptionsStorage@?1??__local_stdio_printf_options@@9@9:QWORD							; `__local_stdio_printf_options'::`2'::_OptionsStorage
_DATA	ENDS
_BSS	SEGMENT
asciiflag DB	01H DUP (?)
	ALIGN	4

odir	DB	0104H DUP (?)
_BSS	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$_vsnprintf_s_l DD imagerel $LN5
	DD	imagerel $LN5+127
	DD	imagerel $unwind$_vsnprintf_s_l
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$_vsnprintf_s DD imagerel $LN3
	DD	imagerel $LN3+73
	DD	imagerel $unwind$_vsnprintf_s
pdata	ENDS
pdata	SEGMENT
$pdata$DebuggerTrace DD imagerel DebuggerTrace
	DD	imagerel DebuggerTrace+247
	DD	imagerel $unwind$DebuggerTrace
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$fetch_hw_noswap DD imagerel $LN3
	DD	imagerel $LN3+30
	DD	imagerel $unwind$fetch_hw_noswap
pdata	ENDS
pdata	SEGMENT
$pdata$process_member DD imagerel process_member
	DD	imagerel process_member+1526
	DD	imagerel $unwind$process_member
$pdata$process_dirblk DD imagerel process_dirblk
	DD	imagerel process_dirblk+451
	DD	imagerel $unwind$process_dirblk
$pdata$syntax DD imagerel syntax
	DD	imagerel syntax+100
	DD	imagerel $unwind$syntax
$pdata$main DD	imagerel $LN42
	DD	imagerel $LN42+2322
	DD	imagerel $unwind$main
pdata	ENDS
_DATA	SEGMENT
$SG159590 DB	'I', 00H
	ORG $+14
$SG159591 DB	'HHC02975%s Usage: %s infile [sf=shadow-file] pdsname [AS'
	DB	'CII] [odir]', 0aH, 'HHC02975I   infile    input file', 0aH, 'H'
	DB	'HC02975I   pdsname   name of PDS to be unloaded', 0aH, 'HHC02'
	DB	'975I options:', 0aH, 'HHC02975I   ASCII     unload as variabl'
	DB	'e length ASCII text files', 0aH, 'HHC02975I             other'
	DB	'wise unloaded as fixed length EBCDIC', 0aH, 'HHC02975I   odir'
	DB	'      directory where files should be written to', 0aH, 'HHC0'
	DB	'2975I             otherwise output is to current directory', 0aH
	DB	0aH, 00H
$SG159592 DB	'syntax', 00H
	ORG $+1
$SG159647 DB	'sf=', 00H
$SG159593 DB	'dasdpdsu.c', 00H
	ORG $+1
$SG159650 DB	'E', 00H
	ORG $+2
$SG159642 DB	'PDS unload', 00H
	ORG $+1
$SG159658 DB	'E', 00H
	ORG $+2
$SG159643 DB	'dasdpdsu', 00H
	ORG $+3
$SG159657 DB	'ASCII', 00H
	ORG $+2
$SG159667 DB	'E', 00H
	ORG $+2
$SG159649 DB	'required ''pdsname'' argument', 00H
$SG159673 DB	'/', 00H
	ORG $+2
$SG159651 DB	'HHC02578%s %s missing', 0aH, 00H
	ORG $+1
$SG159652 DB	'main', 00H
	ORG $+3
$SG159653 DB	'dasdpdsu.c', 00H
	ORG $+1
$SG159682 DB	'I', 00H
	ORG $+2
$SG159659 DB	'HHC02465%s Invalid argument: %s', 0aH, 00H
	ORG $+3
$SG159660 DB	'main', 00H
	ORG $+3
$SG159691 DB	'I', 00H
	ORG $+2
$SG159661 DB	'dasdpdsu.c', 00H
	ORG $+1
$SG159732 DB	'w', 00H
	ORG $+2
$SG159668 DB	'HHC02465%s Invalid argument: %s', 0aH, 00H
	ORG $+3
$SG159669 DB	'main', 00H
	ORG $+3
$SG159733 DB	'wb', 00H
	ORG $+1
$SG159670 DB	'dasdpdsu.c', 00H
	ORG $+1
$SG159735 DB	'E', 00H
	ORG $+2
$SG159678 DB	'ETRK=%d', 0aH, 00H
	ORG $+3
$SG159734 DB	'fopen', 00H
	ORG $+2
$SG159739 DB	'I', 00H
	ORG $+2
$SG159680 DB	'CTRK=%d', 0aH, 00H
	ORG $+3
$SG159751 DB	'E', 00H
	ORG $+2
$SG159683 DB	'HHC02466%s Reading directory block at CCHHR %04X%04X%02X'
	DB	0aH, 00H
	ORG $+2
$SG159684 DB	'main', 00H
	ORG $+3
$SG159757 DB	'%s', 0aH, 00H
$SG159685 DB	'dasdpdsu.c', 00H
	ORG $+1
$SG159760 DB	'E', 00H
	ORG $+2
$SG159692 DB	'HHC02467%s End of directory', 0aH, 00H
	ORG $+3
$SG159693 DB	'main', 00H
	ORG $+3
$SG159694 DB	'dasdpdsu.c', 00H
	ORG $+1
$SG159730 DB	'.mac', 00H
	ORG $+3
$SG159759 DB	'fwrite', 00H
	ORG $+1
$SG159786 DB	'E', 00H
	ORG $+2
$SG159736 DB	'HHC02468%s File %s; %s error: %s', 0aH, 00H
	ORG $+6
$SG159737 DB	'process_member', 00H
	ORG $+1
$SG159738 DB	'dasdpdsu.c', 00H
	ORG $+5
$SG159740 DB	'HHC02469%s Member %s TTR %04X%02X', 0aH, 00H
	ORG $+5
$SG159741 DB	'process_member', 00H
	ORG $+1
$SG159742 DB	'dasdpdsu.c', 00H
	ORG $+5
$SG159744 DB	'CCHHR=%4.4X%4.4X%2.2X', 0aH, 00H
	ORG $+1
$SG159746 DB	'CCHHR=%4.4X%4.4X%2.2X', 0aH, 00H
	ORG $+1
$SG159752 DB	'HHC02470%s Invalid block length %d at CCHHR %04X%04X%02X'
	DB	0aH, 00H
	ORG $+6
$SG159753 DB	'process_member', 00H
	ORG $+1
$SG159754 DB	'dasdpdsu.c', 00H
	ORG $+5
$SG159761 DB	'HHC02468%s File %s; %s error: %s', 0aH, 00H
	ORG $+6
$SG159762 DB	'process_member', 00H
	ORG $+1
$SG159763 DB	'dasdpdsu.c', 00H
	ORG $+5
$SG159787 DB	'HHC02400%s Directory block byte count is invalid', 0aH, 00H
	ORG $+6
$SG159788 DB	'process_dirblk', 00H
	ORG $+1
$SG159789 DB	'dasdpdsu.c', 00H
_DATA	ENDS
voltbl	SEGMENT
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:main
	DD	01cH
	DD	08f8H
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:process_dirblk
	DD	024H
	DD	01aeH
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:process_member
	DD	025H
	DD	05ddH
voltbl	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$fetch_hw_noswap DD 010901H
	DD	02209H
xdata	ENDS
xdata	SEGMENT
$unwind$DebuggerTrace DD 011801H
	DD	0a218H
$unwind$process_member DD 032d19H
	DD	06c011bH
	DD	07014H
	DD	imagerel __GSHandlerCheck
	DD	0350H
$unwind$process_dirblk DD 022919H
	DD	011011aH
	DD	imagerel __GSHandlerCheck
	DD	078H
$unwind$syntax DD 010901H
	DD	08209H
$unwind$main DD	042419H
	DD	0810112H
	DD	0600a700bH
	DD	imagerel __GSHandlerCheck
	DD	03f0H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$_vsnprintf_s DD 011801H
	DD	06218H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$_vsnprintf_s_l DD 011801H
	DD	0a218H
xdata	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\dasdpdsu.c
_TEXT	SEGMENT
rec$ = 80
c$1 = 81
head$ = 82
rc$ = 84
i$ = 88
i$2 = 92
dirlen$3 = 96
trk$ = 100
cif$ = 104
len$ = 112
trks$4 = 116
noext$ = 120
cyl$ = 124
pgm$ = 128
ecyl$5 = 136
etrk$6 = 140
bcyl$7 = 144
btrk$8 = 148
tv317 = 152
tv340 = 156
tv342 = 160
$T9 = 168
sfname$ = 176
tv156 = 184
tv218 = 192
fname$ = 200
blkptr$ = 208
statbuf$10 = 216
extent$ = 272
dsnama$ = 432
dirblk$ = 480
pathname$11 = 736
__$ArrayPad$ = 1008
argc$ = 1056
argv$ = 1064
main	PROC

; 55   : {

$LN42:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	89 4c 24 08	 mov	 DWORD PTR [rsp+8], ecx
  00009	56		 push	 rsi
  0000a	57		 push	 rdi
  0000b	48 81 ec 08 04
	00 00		 sub	 rsp, 1032		; 00000408H
  00012	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00019	48 33 c4	 xor	 rax, rsp
  0001c	48 89 84 24 f0
	03 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 56   : char           *pgm;                    /* less any extension (.ext) */
; 57   : int             rc;                     /* Return code               */
; 58   : int             i=0;                    /* Arument index             */

  00024	c7 44 24 58 00
	00 00 00	 mov	 DWORD PTR i$[rsp], 0

; 59   : U16             len;                    /* Record length             */
; 60   : U32             cyl;                    /* Cylinder number           */
; 61   : U8              head;                   /* Head number               */
; 62   : U8              rec;                    /* Record number             */
; 63   : u_int           trk;                    /* Relative track number     */
; 64   : char           *fname;                  /* -> CKD image file name    */
; 65   : char           *sfname=NULL;            /* -> CKD shadow file name   */

  0002c	48 c7 84 24 b0
	00 00 00 00 00
	00 00		 mov	 QWORD PTR sfname$[rsp], 0

; 66   : char            dsnama[45];             /* Dataset name (ASCIIZ)     */
; 67   : int             noext;                  /* Number of extents         */
; 68   : DSXTENT         extent[16];             /* Extent descriptor array   */
; 69   : BYTE           *blkptr;                 /* -> PDS directory block    */
; 70   : BYTE            dirblk[256];            /* Copy of directory block   */
; 71   : CIFBLK         *cif;                    /* CKD image file descriptor */
; 72   : 
; 73   :     INITIALIZE_UTILITY( UTILITY_NAME, UTILITY_DESC, &pgm );

  00038	48 8d 84 24 80
	00 00 00	 lea	 rax, QWORD PTR pgm$[rsp]
  00040	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00045	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG159642
  0004c	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG159643
  00053	48 8b 94 24 28
	04 00 00	 mov	 rdx, QWORD PTR argv$[rsp]
  0005b	8b 8c 24 20 04
	00 00		 mov	 ecx, DWORD PTR argc$[rsp]
  00062	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_initialize_utility
  00068	89 84 24 20 04
	00 00		 mov	 DWORD PTR argc$[rsp], eax

; 74   : 
; 75   :     /* Check the number of arguments */
; 76   :     if (argc < 3 || argc > 6)

  0006f	83 bc 24 20 04
	00 00 03	 cmp	 DWORD PTR argc$[rsp], 3
  00077	7c 0a		 jl	 SHORT $LN14@main
  00079	83 bc 24 20 04
	00 00 06	 cmp	 DWORD PTR argc$[rsp], 6
  00081	7e 12		 jle	 SHORT $LN13@main
$LN14@main:

; 77   :         return syntax( pgm );

  00083	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR pgm$[rsp]
  0008b	e8 00 00 00 00	 call	 syntax
  00090	e9 63 08 00 00	 jmp	 $LN1@main
$LN13@main:

; 78   : 
; 79   :     /* The first argument is the name of the CKD image file */
; 80   :     fname = argv[1];

  00095	b8 08 00 00 00	 mov	 eax, 8
  0009a	48 6b c0 01	 imul	 rax, rax, 1
  0009e	48 8b 8c 24 28
	04 00 00	 mov	 rcx, QWORD PTR argv$[rsp]
  000a6	48 8b 04 01	 mov	 rax, QWORD PTR [rcx+rax]
  000aa	48 89 84 24 c8
	00 00 00	 mov	 QWORD PTR fname$[rsp], rax

; 81   : 
; 82   :     /* The next argument may be the shadow file name */
; 83   :     if (!memcmp (argv[2], "sf=", 3))

  000b2	b8 08 00 00 00	 mov	 eax, 8
  000b7	48 6b c0 02	 imul	 rax, rax, 2
  000bb	41 b8 03 00 00
	00		 mov	 r8d, 3
  000c1	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG159647
  000c8	48 8b 8c 24 28
	04 00 00	 mov	 rcx, QWORD PTR argv$[rsp]
  000d0	48 8b 0c 01	 mov	 rcx, QWORD PTR [rcx+rax]
  000d4	e8 00 00 00 00	 call	 memcmp
  000d9	85 c0		 test	 eax, eax
  000db	0f 85 94 00 00
	00		 jne	 $LN15@main

; 84   :     {
; 85   :         if (argc < 4)

  000e1	83 bc 24 20 04
	00 00 04	 cmp	 DWORD PTR argc$[rsp], 4
  000e9	7d 65		 jge	 SHORT $LN16@main

; 86   :         {
; 87   :             // "%s missing"
; 88   :             FWRMSG( stderr, HHC02578, "E", "required 'pdsname' argument" );

  000eb	b9 02 00 00 00	 mov	 ecx, 2
  000f0	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  000f6	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159649
  000fd	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  00102	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159650
  00109	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  0010e	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159651
  00115	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  0011a	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  0011f	41 b9 03 00 00
	00		 mov	 r9d, 3
  00125	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG159652
  0012c	ba 58 00 00 00	 mov	 edx, 88			; 00000058H
  00131	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159653
  00138	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 89   :             return syntax( pgm );

  0013e	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR pgm$[rsp]
  00146	e8 00 00 00 00	 call	 syntax
  0014b	e9 a8 07 00 00	 jmp	 $LN1@main
$LN16@main:

; 90   :         }
; 91   : 
; 92   :         sfname = argv[2];

  00150	b8 08 00 00 00	 mov	 eax, 8
  00155	48 6b c0 02	 imul	 rax, rax, 2
  00159	48 8b 8c 24 28
	04 00 00	 mov	 rcx, QWORD PTR argv$[rsp]
  00161	48 8b 04 01	 mov	 rax, QWORD PTR [rcx+rax]
  00165	48 89 84 24 b0
	00 00 00	 mov	 QWORD PTR sfname$[rsp], rax

; 93   :         i = 1;

  0016d	c7 44 24 58 01
	00 00 00	 mov	 DWORD PTR i$[rsp], 1
$LN15@main:

; 94   :     }
; 95   : 
; 96   :     /* The second argument is the dataset name */
; 97   :     STRLCPY( dsnama, argv[2+i] );

  00175	8b 44 24 58	 mov	 eax, DWORD PTR i$[rsp]
  00179	83 c0 02	 add	 eax, 2
  0017c	48 98		 cdqe
  0017e	41 b8 2d 00 00
	00		 mov	 r8d, 45			; 0000002dH
  00184	48 8b 8c 24 28
	04 00 00	 mov	 rcx, QWORD PTR argv$[rsp]
  0018c	48 8b 14 c1	 mov	 rdx, QWORD PTR [rcx+rax*8]
  00190	48 8d 8c 24 b0
	01 00 00	 lea	 rcx, QWORD PTR dsnama$[rsp]
  00198	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_strlcpy

; 98   :     string_to_upper( dsnama );

  0019e	48 8d 8c 24 b0
	01 00 00	 lea	 rcx, QWORD PTR dsnama$[rsp]
  001a6	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_string_to_upper

; 99   : 
; 100  :     /* The third argument is an optional keyword */
; 101  :     if (argc > (3+i) && argv[3+i])

  001ac	8b 44 24 58	 mov	 eax, DWORD PTR i$[rsp]
  001b0	83 c0 03	 add	 eax, 3
  001b3	39 84 24 20 04
	00 00		 cmp	 DWORD PTR argc$[rsp], eax
  001ba	0f 8e d1 00 00
	00		 jle	 $LN17@main
  001c0	8b 44 24 58	 mov	 eax, DWORD PTR i$[rsp]
  001c4	83 c0 03	 add	 eax, 3
  001c7	48 98		 cdqe
  001c9	48 8b 8c 24 28
	04 00 00	 mov	 rcx, QWORD PTR argv$[rsp]
  001d1	48 83 3c c1 00	 cmp	 QWORD PTR [rcx+rax*8], 0
  001d6	0f 84 b5 00 00
	00		 je	 $LN17@main

; 102  :     {
; 103  :         if (strcasecmp( argv[3+i], "ASCII" ) == 0)

  001dc	8b 44 24 58	 mov	 eax, DWORD PTR i$[rsp]
  001e0	83 c0 03	 add	 eax, 3
  001e3	48 98		 cdqe
  001e5	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG159657
  001ec	48 8b 8c 24 28
	04 00 00	 mov	 rcx, QWORD PTR argv$[rsp]
  001f4	48 8b 0c c1	 mov	 rcx, QWORD PTR [rcx+rax*8]
  001f8	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__stricmp
  001fe	85 c0		 test	 eax, eax
  00200	75 0c		 jne	 SHORT $LN18@main

; 104  :             asciiflag = 1;

  00202	c6 05 00 00 00
	00 01		 mov	 BYTE PTR asciiflag, 1
  00209	e9 83 00 00 00	 jmp	 $LN19@main
$LN18@main:

; 105  :         else
; 106  :         {
; 107  :             // "Invalid argument: %s"
; 108  :             FWRMSG( stderr, HHC02465, "E", argv[3+i] );

  0020e	8b 44 24 58	 mov	 eax, DWORD PTR i$[rsp]
  00212	83 c0 03	 add	 eax, 3
  00215	48 98		 cdqe
  00217	48 89 84 24 b8
	00 00 00	 mov	 QWORD PTR tv156[rsp], rax
  0021f	b9 02 00 00 00	 mov	 ecx, 2
  00224	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  0022a	48 8b 8c 24 28
	04 00 00	 mov	 rcx, QWORD PTR argv$[rsp]
  00232	48 8b 94 24 b8
	00 00 00	 mov	 rdx, QWORD PTR tv156[rsp]
  0023a	48 8b 0c d1	 mov	 rcx, QWORD PTR [rcx+rdx*8]
  0023e	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  00243	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159658
  0024a	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  0024f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159659
  00256	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  0025b	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00260	41 b9 03 00 00
	00		 mov	 r9d, 3
  00266	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG159660
  0026d	ba 6c 00 00 00	 mov	 edx, 108		; 0000006cH
  00272	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159661
  00279	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 109  :             return syntax( pgm );

  0027f	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR pgm$[rsp]
  00287	e8 00 00 00 00	 call	 syntax
  0028c	e9 67 06 00 00	 jmp	 $LN1@main
$LN19@main:
$LN17@main:

; 110  :         }
; 111  :     }
; 112  : 
; 113  :     /* The forth argument is an optional output directory */
; 114  :     if (argc > (4+i) && argv[4+i])

  00291	8b 44 24 58	 mov	 eax, DWORD PTR i$[rsp]
  00295	83 c0 04	 add	 eax, 4
  00298	39 84 24 20 04
	00 00		 cmp	 DWORD PTR argc$[rsp], eax
  0029f	0f 8e 2d 02 00
	00		 jle	 $LN20@main
  002a5	8b 44 24 58	 mov	 eax, DWORD PTR i$[rsp]
  002a9	83 c0 04	 add	 eax, 4
  002ac	48 98		 cdqe
  002ae	48 8b 8c 24 28
	04 00 00	 mov	 rcx, QWORD PTR argv$[rsp]
  002b6	48 83 3c c1 00	 cmp	 QWORD PTR [rcx+rax*8], 0
  002bb	0f 84 11 02 00
	00		 je	 $LN20@main

; 115  :     {
; 116  :         struct stat statbuf;
; 117  :         char pathname[MAX_PATH], c = 0;

  002c1	c6 44 24 51 00	 mov	 BYTE PTR c$1[rsp], 0

; 118  :         int dirlen = 0;

  002c6	c7 44 24 60 00
	00 00 00	 mov	 DWORD PTR dirlen$3[rsp], 0

; 119  : 
; 120  :         /* Copy argument to work */
; 121  :         STRLCPY( odir, argv[4+i] );

  002ce	8b 44 24 58	 mov	 eax, DWORD PTR i$[rsp]
  002d2	83 c0 04	 add	 eax, 4
  002d5	48 98		 cdqe
  002d7	41 b8 04 01 00
	00		 mov	 r8d, 260		; 00000104H
  002dd	48 8b 8c 24 28
	04 00 00	 mov	 rcx, QWORD PTR argv$[rsp]
  002e5	48 8b 14 c1	 mov	 rdx, QWORD PTR [rcx+rax*8]
  002e9	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:odir
  002f0	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_strlcpy

; 122  : 
; 123  : #if defined( _MSVC_ )
; 124  :         /* stat(): If path contains the location of a directory,
; 125  :            it cannot contain a trailing backslash.  If it does,
; 126  :            -1 will be returned and errno will be set to ENOENT. */
; 127  :         dirlen = (int) strlen( odir );

  002f6	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:odir
  002fd	e8 00 00 00 00	 call	 strlen
  00302	89 44 24 60	 mov	 DWORD PTR dirlen$3[rsp], eax

; 128  :         if (0
; 129  :             || odir[ dirlen - 1 ] == '/'
; 130  :             || odir[ dirlen - 1 ] == '\\'

  00306	33 c0		 xor	 eax, eax
  00308	85 c0		 test	 eax, eax
  0030a	75 30		 jne	 SHORT $LN22@main
  0030c	8b 44 24 60	 mov	 eax, DWORD PTR dirlen$3[rsp]
  00310	ff c8		 dec	 eax
  00312	48 98		 cdqe
  00314	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:odir
  0031b	0f be 04 01	 movsx	 eax, BYTE PTR [rcx+rax]
  0031f	83 f8 2f	 cmp	 eax, 47			; 0000002fH
  00322	74 18		 je	 SHORT $LN22@main
  00324	8b 44 24 60	 mov	 eax, DWORD PTR dirlen$3[rsp]
  00328	ff c8		 dec	 eax
  0032a	48 98		 cdqe
  0032c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:odir
  00333	0f be 04 01	 movsx	 eax, BYTE PTR [rcx+rax]
  00337	83 f8 5c	 cmp	 eax, 92			; 0000005cH
  0033a	75 4f		 jne	 SHORT $LN21@main
$LN22@main:

; 131  :         )
; 132  :         {
; 133  :             c = odir[ dirlen - 1 ];   // (remember)

  0033c	8b 44 24 60	 mov	 eax, DWORD PTR dirlen$3[rsp]
  00340	ff c8		 dec	 eax
  00342	48 98		 cdqe
  00344	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:odir
  0034b	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  0034f	88 44 24 51	 mov	 BYTE PTR c$1[rsp], al

; 134  :             odir[ dirlen - 1 ] = 0;   // (remove it)

  00353	8b 44 24 60	 mov	 eax, DWORD PTR dirlen$3[rsp]
  00357	ff c8		 dec	 eax
  00359	48 98		 cdqe
  0035b	48 89 84 24 a8
	00 00 00	 mov	 QWORD PTR $T9[rsp], rax
  00363	48 81 bc 24 a8
	00 00 00 04 01
	00 00		 cmp	 QWORD PTR $T9[rsp], 260	; 00000104H
  0036f	73 02		 jae	 SHORT $LN39@main
  00371	eb 05		 jmp	 SHORT $LN40@main
$LN39@main:
  00373	e8 00 00 00 00	 call	 __report_rangecheckfailure
$LN40@main:
  00378	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:odir
  0037f	48 8b 8c 24 a8
	00 00 00	 mov	 rcx, QWORD PTR $T9[rsp]
  00387	c6 04 08 00	 mov	 BYTE PTR [rax+rcx], 0
$LN21@main:

; 135  :         }
; 136  : #endif
; 137  :         /* Valid directory name specified? */
; 138  :         if (0
; 139  :             || stat( odir, &statbuf ) != 0
; 140  :             || !S_ISDIR( statbuf.st_mode )

  0038b	33 c0		 xor	 eax, eax
  0038d	85 c0		 test	 eax, eax
  0038f	75 31		 jne	 SHORT $LN24@main
  00391	48 8d 94 24 d8
	00 00 00	 lea	 rdx, QWORD PTR statbuf$10[rsp]
  00399	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:odir
  003a0	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__stat64
  003a6	85 c0		 test	 eax, eax
  003a8	75 18		 jne	 SHORT $LN24@main
  003aa	0f b7 84 24 de
	00 00 00	 movzx	 eax, WORD PTR statbuf$10[rsp+6]
  003b2	25 00 f0 00 00	 and	 eax, 61440		; 0000f000H
  003b7	3d 00 40 00 00	 cmp	 eax, 16384		; 00004000H
  003bc	0f 84 83 00 00
	00		 je	 $LN23@main
$LN24@main:

; 141  :         )
; 142  :         {
; 143  :             // "Invalid argument: %s"
; 144  :             FWRMSG( stderr, HHC02465, "E", argv[4+i] );

  003c2	8b 44 24 58	 mov	 eax, DWORD PTR i$[rsp]
  003c6	83 c0 04	 add	 eax, 4
  003c9	48 98		 cdqe
  003cb	48 89 84 24 c0
	00 00 00	 mov	 QWORD PTR tv218[rsp], rax
  003d3	b9 02 00 00 00	 mov	 ecx, 2
  003d8	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  003de	48 8b 8c 24 28
	04 00 00	 mov	 rcx, QWORD PTR argv$[rsp]
  003e6	48 8b 94 24 c0
	00 00 00	 mov	 rdx, QWORD PTR tv218[rsp]
  003ee	48 8b 0c d1	 mov	 rcx, QWORD PTR [rcx+rdx*8]
  003f2	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  003f7	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159667
  003fe	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  00403	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159668
  0040a	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  0040f	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00414	41 b9 03 00 00
	00		 mov	 r9d, 3
  0041a	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG159669
  00421	ba 90 00 00 00	 mov	 edx, 144		; 00000090H
  00426	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159670
  0042d	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 145  :             return syntax( pgm );

  00433	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR pgm$[rsp]
  0043b	e8 00 00 00 00	 call	 syntax
  00440	e9 b3 04 00 00	 jmp	 $LN1@main
$LN23@main:

; 146  :         }
; 147  : 
; 148  :         /* (restore trailing path separator if removed) */
; 149  :         if (c)

  00445	0f be 44 24 51	 movsx	 eax, BYTE PTR c$1[rsp]
  0044a	85 c0		 test	 eax, eax
  0044c	74 17		 je	 SHORT $LN25@main

; 150  :             odir[ dirlen - 1 ] = c;

  0044e	8b 44 24 60	 mov	 eax, DWORD PTR dirlen$3[rsp]
  00452	ff c8		 dec	 eax
  00454	48 98		 cdqe
  00456	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:odir
  0045d	0f b6 54 24 51	 movzx	 edx, BYTE PTR c$1[rsp]
  00462	88 14 01	 mov	 BYTE PTR [rcx+rax], dl
$LN25@main:

; 151  : 
; 152  :         /* Convert output directory to host format */
; 153  :         hostpath( pathname, odir, sizeof( pathname ));

  00465	41 b8 04 01 00
	00		 mov	 r8d, 260		; 00000104H
  0046b	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:odir
  00472	48 8d 8c 24 e0
	02 00 00	 lea	 rcx, QWORD PTR pathname$11[rsp]
  0047a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hostpath

; 154  :         STRLCPY( odir, pathname );

  00480	41 b8 04 01 00
	00		 mov	 r8d, 260		; 00000104H
  00486	48 8d 94 24 e0
	02 00 00	 lea	 rdx, QWORD PTR pathname$11[rsp]
  0048e	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:odir
  00495	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_strlcpy

; 155  : 
; 156  :         /* Append path separator if needed */
; 157  :         if (odir[ strlen( odir ) - 1 ] != PATHSEPC)

  0049b	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:odir
  004a2	e8 00 00 00 00	 call	 strlen
  004a7	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:odir
  004ae	0f be 44 01 ff	 movsx	 eax, BYTE PTR [rcx+rax-1]
  004b3	83 f8 2f	 cmp	 eax, 47			; 0000002fH
  004b6	74 1a		 je	 SHORT $LN26@main

; 158  :             STRLCAT( odir, PATHSEPS );

  004b8	41 b8 04 01 00
	00		 mov	 r8d, 260		; 00000104H
  004be	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG159673
  004c5	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:odir
  004cc	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_strlcat
$LN26@main:
$LN20@main:

; 159  :     }
; 160  : 
; 161  :     /* Open the CKD image file */
; 162  :     if (!(cif = open_ckd_image( fname, sfname, O_RDONLY | O_BINARY, IMAGE_OPEN_NORMAL )))

  004d2	45 33 c9	 xor	 r9d, r9d
  004d5	41 b8 00 80 00
	00		 mov	 r8d, 32768		; 00008000H
  004db	48 8b 94 24 b0
	00 00 00	 mov	 rdx, QWORD PTR sfname$[rsp]
  004e3	48 8b 8c 24 c8
	00 00 00	 mov	 rcx, QWORD PTR fname$[rsp]
  004eb	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_open_ckd_image
  004f1	48 89 44 24 68	 mov	 QWORD PTR cif$[rsp], rax
  004f6	48 83 7c 24 68
	00		 cmp	 QWORD PTR cif$[rsp], 0
  004fc	75 0a		 jne	 SHORT $LN27@main

; 163  :         return -1;

  004fe	b8 ff ff ff ff	 mov	 eax, -1
  00503	e9 f0 03 00 00	 jmp	 $LN1@main
$LN27@main:

; 164  : 
; 165  :     /* Build the extent array for the requested dataset */
; 166  :     if ((rc = build_extent_array( cif, dsnama, extent, &noext )) < 0)

  00508	4c 8d 4c 24 78	 lea	 r9, QWORD PTR noext$[rsp]
  0050d	4c 8d 84 24 10
	01 00 00	 lea	 r8, QWORD PTR extent$[rsp]
  00515	48 8d 94 24 b0
	01 00 00	 lea	 rdx, QWORD PTR dsnama$[rsp]
  0051d	48 8b 4c 24 68	 mov	 rcx, QWORD PTR cif$[rsp]
  00522	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_build_extent_array
  00528	89 44 24 54	 mov	 DWORD PTR rc$[rsp], eax
  0052c	83 7c 24 54 00	 cmp	 DWORD PTR rc$[rsp], 0
  00531	7d 0a		 jge	 SHORT $LN28@main

; 167  :         return -1;

  00533	b8 ff ff ff ff	 mov	 eax, -1
  00538	e9 bb 03 00 00	 jmp	 $LN1@main
$LN28@main:

; 168  : 
; 169  :     /* Calculate ending relative track */
; 170  :     if (extgui)

  0053d	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_extgui
  00544	83 38 00	 cmp	 DWORD PTR [rax], 0
  00547	0f 84 5f 01 00
	00		 je	 $LN29@main

; 171  :     {
; 172  :         int bcyl;  /* Extent begin cylinder     */
; 173  :         int btrk;  /* Extent begin head         */
; 174  :         int ecyl;  /* Extent end cylinder       */
; 175  :         int etrk;  /* Extent end head           */
; 176  :         int trks;  /* total tracks in dataset   */
; 177  :         int i;     /* loop control              */
; 178  : 
; 179  :         for (i=0, trks = 0; i < noext; i++)

  0054d	c7 44 24 5c 00
	00 00 00	 mov	 DWORD PTR i$2[rsp], 0
  00555	c7 44 24 74 00
	00 00 00	 mov	 DWORD PTR trks$4[rsp], 0
  0055d	eb 0a		 jmp	 SHORT $LN4@main
$LN2@main:
  0055f	8b 44 24 5c	 mov	 eax, DWORD PTR i$2[rsp]
  00563	ff c0		 inc	 eax
  00565	89 44 24 5c	 mov	 DWORD PTR i$2[rsp], eax
$LN4@main:
  00569	8b 44 24 78	 mov	 eax, DWORD PTR noext$[rsp]
  0056d	39 44 24 5c	 cmp	 DWORD PTR i$2[rsp], eax
  00571	0f 8d f1 00 00
	00		 jge	 $LN3@main

; 180  :         {
; 181  :             bcyl = fetch_hw( extent[i].xtbcyl );

  00577	48 63 44 24 5c	 movsxd	 rax, DWORD PTR i$2[rsp]
  0057c	48 6b c0 0a	 imul	 rax, rax, 10
  00580	48 8d 84 04 12
	01 00 00	 lea	 rax, QWORD PTR extent$[rsp+rax+2]
  00588	48 8b c8	 mov	 rcx, rax
  0058b	e8 00 00 00 00	 call	 fetch_hw_noswap
  00590	0f b7 c8	 movzx	 ecx, ax
  00593	e8 00 00 00 00	 call	 _byteswap_ushort
  00598	0f b7 c0	 movzx	 eax, ax
  0059b	89 84 24 90 00
	00 00		 mov	 DWORD PTR bcyl$7[rsp], eax

; 182  :             btrk = fetch_hw( extent[i].xtbtrk );

  005a2	48 63 44 24 5c	 movsxd	 rax, DWORD PTR i$2[rsp]
  005a7	48 6b c0 0a	 imul	 rax, rax, 10
  005ab	48 8d 84 04 14
	01 00 00	 lea	 rax, QWORD PTR extent$[rsp+rax+4]
  005b3	48 8b c8	 mov	 rcx, rax
  005b6	e8 00 00 00 00	 call	 fetch_hw_noswap
  005bb	0f b7 c8	 movzx	 ecx, ax
  005be	e8 00 00 00 00	 call	 _byteswap_ushort
  005c3	0f b7 c0	 movzx	 eax, ax
  005c6	89 84 24 94 00
	00 00		 mov	 DWORD PTR btrk$8[rsp], eax

; 183  :             ecyl = fetch_hw( extent[i].xtecyl );

  005cd	48 63 44 24 5c	 movsxd	 rax, DWORD PTR i$2[rsp]
  005d2	48 6b c0 0a	 imul	 rax, rax, 10
  005d6	48 8d 84 04 16
	01 00 00	 lea	 rax, QWORD PTR extent$[rsp+rax+6]
  005de	48 8b c8	 mov	 rcx, rax
  005e1	e8 00 00 00 00	 call	 fetch_hw_noswap
  005e6	0f b7 c8	 movzx	 ecx, ax
  005e9	e8 00 00 00 00	 call	 _byteswap_ushort
  005ee	0f b7 c0	 movzx	 eax, ax
  005f1	89 84 24 88 00
	00 00		 mov	 DWORD PTR ecyl$5[rsp], eax

; 184  :             etrk = fetch_hw( extent[i].xtetrk );

  005f8	48 63 44 24 5c	 movsxd	 rax, DWORD PTR i$2[rsp]
  005fd	48 6b c0 0a	 imul	 rax, rax, 10
  00601	48 8d 84 04 18
	01 00 00	 lea	 rax, QWORD PTR extent$[rsp+rax+8]
  00609	48 8b c8	 mov	 rcx, rax
  0060c	e8 00 00 00 00	 call	 fetch_hw_noswap
  00611	0f b7 c8	 movzx	 ecx, ax
  00614	e8 00 00 00 00	 call	 _byteswap_ushort
  00619	0f b7 c0	 movzx	 eax, ax
  0061c	89 84 24 8c 00
	00 00		 mov	 DWORD PTR etrk$6[rsp], eax

; 185  : 
; 186  :             trks += (((ecyl * cif->heads) + etrk) - ((bcyl * cif->heads) + btrk)) + 1;

  00623	48 8b 44 24 68	 mov	 rax, QWORD PTR cif$[rsp]
  00628	8b 8c 24 88 00
	00 00		 mov	 ecx, DWORD PTR ecyl$5[rsp]
  0062f	0f af 48 24	 imul	 ecx, DWORD PTR [rax+36]
  00633	8b c1		 mov	 eax, ecx
  00635	03 84 24 8c 00
	00 00		 add	 eax, DWORD PTR etrk$6[rsp]
  0063c	48 8b 4c 24 68	 mov	 rcx, QWORD PTR cif$[rsp]
  00641	8b 94 24 90 00
	00 00		 mov	 edx, DWORD PTR bcyl$7[rsp]
  00648	0f af 51 24	 imul	 edx, DWORD PTR [rcx+36]
  0064c	8b ca		 mov	 ecx, edx
  0064e	03 8c 24 94 00
	00 00		 add	 ecx, DWORD PTR btrk$8[rsp]
  00655	2b c1		 sub	 eax, ecx
  00657	8b 4c 24 74	 mov	 ecx, DWORD PTR trks$4[rsp]
  0065b	8d 44 01 01	 lea	 eax, DWORD PTR [rcx+rax+1]
  0065f	89 44 24 74	 mov	 DWORD PTR trks$4[rsp], eax

; 187  :         }

  00663	e9 f7 fe ff ff	 jmp	 $LN2@main
$LN3@main:
$LN7@main:

; 188  : 
; 189  :         EXTGUIMSG( "ETRK=%d\n", trks-1 );

  00668	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_extgui
  0066f	83 38 00	 cmp	 DWORD PTR [rax], 0
  00672	74 32		 je	 SHORT $LN30@main
  00674	8b 44 24 74	 mov	 eax, DWORD PTR trks$4[rsp]
  00678	ff c8		 dec	 eax
  0067a	89 84 24 98 00
	00 00		 mov	 DWORD PTR tv317[rsp], eax
  00681	b9 02 00 00 00	 mov	 ecx, 2
  00686	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  0068c	8b 8c 24 98 00
	00 00		 mov	 ecx, DWORD PTR tv317[rsp]
  00693	44 8b c1	 mov	 r8d, ecx
  00696	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG159678
  0069d	48 8b c8	 mov	 rcx, rax
  006a0	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_fprintf
$LN30@main:
  006a6	33 c0		 xor	 eax, eax
  006a8	85 c0		 test	 eax, eax
  006aa	75 bc		 jne	 SHORT $LN7@main
$LN29@main:

; 190  :     }
; 191  : 
; 192  :     /* Point to the start of the directory */
; 193  :     trk = 0;

  006ac	c7 44 24 64 00
	00 00 00	 mov	 DWORD PTR trk$[rsp], 0

; 194  :     rec = 1;

  006b4	c6 44 24 50 01	 mov	 BYTE PTR rec$[rsp], 1
$LN41@main:
$LN8@main:

; 195  : 
; 196  :     /* Read the directory */
; 197  :     while (1)

  006b9	33 c0		 xor	 eax, eax
  006bb	83 f8 01	 cmp	 eax, 1
  006be	0f 84 da 01 00
	00		 je	 $LN9@main
$LN12@main:

; 198  :     {
; 199  :         EXTGUIMSG( "CTRK=%d\n", trk );

  006c4	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_extgui
  006cb	83 38 00	 cmp	 DWORD PTR [rax], 0
  006ce	74 20		 je	 SHORT $LN31@main
  006d0	b9 02 00 00 00	 mov	 ecx, 2
  006d5	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  006db	44 8b 44 24 64	 mov	 r8d, DWORD PTR trk$[rsp]
  006e0	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG159680
  006e7	48 8b c8	 mov	 rcx, rax
  006ea	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_fprintf
$LN31@main:
  006f0	33 c0		 xor	 eax, eax
  006f2	85 c0		 test	 eax, eax
  006f4	75 ce		 jne	 SHORT $LN12@main

; 200  : 
; 201  :         /* Convert relative track to cylinder and head */
; 202  :         if ((rc = convert_tt( trk, noext, extent, cif->heads, &cyl, &head )) < 0)

  006f6	48 8d 44 24 52	 lea	 rax, QWORD PTR head$[rsp]
  006fb	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  00700	48 8d 44 24 7c	 lea	 rax, QWORD PTR cyl$[rsp]
  00705	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  0070a	48 8b 44 24 68	 mov	 rax, QWORD PTR cif$[rsp]
  0070f	44 0f b6 48 24	 movzx	 r9d, BYTE PTR [rax+36]
  00714	4c 8d 84 24 10
	01 00 00	 lea	 r8, QWORD PTR extent$[rsp]
  0071c	8b 54 24 78	 mov	 edx, DWORD PTR noext$[rsp]
  00720	8b 4c 24 64	 mov	 ecx, DWORD PTR trk$[rsp]
  00724	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_convert_tt
  0072a	89 44 24 54	 mov	 DWORD PTR rc$[rsp], eax
  0072e	83 7c 24 54 00	 cmp	 DWORD PTR rc$[rsp], 0
  00733	7d 0a		 jge	 SHORT $LN32@main

; 203  :             return -1;

  00735	b8 ff ff ff ff	 mov	 eax, -1
  0073a	e9 b9 01 00 00	 jmp	 $LN1@main
$LN32@main:

; 204  : 
; 205  :         /* Read a directory block */
; 206  :         WRMSG( HHC02466, "I", cyl, head, rec );

  0073f	0f b6 44 24 50	 movzx	 eax, BYTE PTR rec$[rsp]
  00744	89 84 24 9c 00
	00 00		 mov	 DWORD PTR tv340[rsp], eax
  0074b	0f b6 4c 24 52	 movzx	 ecx, BYTE PTR head$[rsp]
  00750	89 8c 24 a0 00
	00 00		 mov	 DWORD PTR tv342[rsp], ecx
  00757	b9 01 00 00 00	 mov	 ecx, 1
  0075c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  00762	8b 8c 24 9c 00
	00 00		 mov	 ecx, DWORD PTR tv340[rsp]
  00769	89 4c 24 48	 mov	 DWORD PTR [rsp+72], ecx
  0076d	8b 8c 24 a0 00
	00 00		 mov	 ecx, DWORD PTR tv342[rsp]
  00774	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  00778	8b 4c 24 7c	 mov	 ecx, DWORD PTR cyl$[rsp]
  0077c	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  00780	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159682
  00787	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  0078c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159683
  00793	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00798	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  0079d	41 b9 03 00 00
	00		 mov	 r9d, 3
  007a3	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG159684
  007aa	ba ce 00 00 00	 mov	 edx, 206		; 000000ceH
  007af	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159685
  007b6	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 207  : 
; 208  :         if ((rc = read_block( cif, cyl, head, rec, NULL, NULL, &blkptr, &len )) < 0)

  007bc	48 8d 44 24 70	 lea	 rax, QWORD PTR len$[rsp]
  007c1	48 89 44 24 38	 mov	 QWORD PTR [rsp+56], rax
  007c6	48 8d 84 24 d0
	00 00 00	 lea	 rax, QWORD PTR blkptr$[rsp]
  007ce	48 89 44 24 30	 mov	 QWORD PTR [rsp+48], rax
  007d3	48 c7 44 24 28
	00 00 00 00	 mov	 QWORD PTR [rsp+40], 0
  007dc	48 c7 44 24 20
	00 00 00 00	 mov	 QWORD PTR [rsp+32], 0
  007e5	44 0f b6 4c 24
	50		 movzx	 r9d, BYTE PTR rec$[rsp]
  007eb	44 0f b6 44 24
	52		 movzx	 r8d, BYTE PTR head$[rsp]
  007f1	8b 54 24 7c	 mov	 edx, DWORD PTR cyl$[rsp]
  007f5	48 8b 4c 24 68	 mov	 rcx, QWORD PTR cif$[rsp]
  007fa	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_read_block
  00800	89 44 24 54	 mov	 DWORD PTR rc$[rsp], eax
  00804	83 7c 24 54 00	 cmp	 DWORD PTR rc$[rsp], 0
  00809	7d 0a		 jge	 SHORT $LN33@main

; 209  :             return -1;

  0080b	b8 ff ff ff ff	 mov	 eax, -1
  00810	e9 e3 00 00 00	 jmp	 $LN1@main
$LN33@main:

; 210  : 
; 211  :         /* Move to next track if block not found */
; 212  :         if (rc > 0)

  00815	83 7c 24 54 00	 cmp	 DWORD PTR rc$[rsp], 0
  0081a	7e 14		 jle	 SHORT $LN34@main

; 213  :         {
; 214  :             trk++;

  0081c	8b 44 24 64	 mov	 eax, DWORD PTR trk$[rsp]
  00820	ff c0		 inc	 eax
  00822	89 44 24 64	 mov	 DWORD PTR trk$[rsp], eax

; 215  :             rec = 1;

  00826	c6 44 24 50 01	 mov	 BYTE PTR rec$[rsp], 1

; 216  :             continue;

  0082b	e9 89 fe ff ff	 jmp	 $LN8@main
$LN34@main:

; 217  :         }
; 218  : 
; 219  :         /* Exit at end of directory */
; 220  :         if (!len)

  00830	0f b7 44 24 70	 movzx	 eax, WORD PTR len$[rsp]
  00835	85 c0		 test	 eax, eax
  00837	75 02		 jne	 SHORT $LN35@main

; 221  :             break;

  00839	eb 63		 jmp	 SHORT $LN9@main
$LN35@main:

; 222  : 
; 223  :         /* Copy the directory block */
; 224  :         memcpy( dirblk, blkptr, sizeof( dirblk ));

  0083b	48 8d 84 24 e0
	01 00 00	 lea	 rax, QWORD PTR dirblk$[rsp]
  00843	48 8b f8	 mov	 rdi, rax
  00846	48 8b b4 24 d0
	00 00 00	 mov	 rsi, QWORD PTR blkptr$[rsp]
  0084e	b9 00 01 00 00	 mov	 ecx, 256		; 00000100H
  00853	f3 a4		 rep movsb

; 225  : 
; 226  :         /* Process each member in the directory block */
; 227  :         if ((rc = process_dirblk( cif, noext, extent, dirblk )) < 0)

  00855	4c 8d 8c 24 e0
	01 00 00	 lea	 r9, QWORD PTR dirblk$[rsp]
  0085d	4c 8d 84 24 10
	01 00 00	 lea	 r8, QWORD PTR extent$[rsp]
  00865	8b 54 24 78	 mov	 edx, DWORD PTR noext$[rsp]
  00869	48 8b 4c 24 68	 mov	 rcx, QWORD PTR cif$[rsp]
  0086e	e8 00 00 00 00	 call	 process_dirblk
  00873	89 44 24 54	 mov	 DWORD PTR rc$[rsp], eax
  00877	83 7c 24 54 00	 cmp	 DWORD PTR rc$[rsp], 0
  0087c	7d 07		 jge	 SHORT $LN36@main

; 228  :             return -1;

  0087e	b8 ff ff ff ff	 mov	 eax, -1
  00883	eb 73		 jmp	 SHORT $LN1@main
$LN36@main:

; 229  : 
; 230  :         /* Exit at end of directory */
; 231  :         if (rc > 0)

  00885	83 7c 24 54 00	 cmp	 DWORD PTR rc$[rsp], 0
  0088a	7e 02		 jle	 SHORT $LN37@main

; 232  :             break;

  0088c	eb 10		 jmp	 SHORT $LN9@main
$LN37@main:

; 233  : 
; 234  :         /* Point to the next directory block */
; 235  :         rec++;

  0088e	0f b6 44 24 50	 movzx	 eax, BYTE PTR rec$[rsp]
  00893	fe c0		 inc	 al
  00895	88 44 24 50	 mov	 BYTE PTR rec$[rsp], al

; 236  : 
; 237  :     } /* end while */

  00899	e9 1b fe ff ff	 jmp	 $LN41@main
$LN9@main:

; 238  : 
; 239  :     WRMSG( HHC02467, "I" );

  0089e	b9 01 00 00 00	 mov	 ecx, 1
  008a3	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  008a9	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159691
  008b0	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  008b5	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159692
  008bc	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  008c1	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  008c6	41 b9 03 00 00
	00		 mov	 r9d, 3
  008cc	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG159693
  008d3	ba ef 00 00 00	 mov	 edx, 239		; 000000efH
  008d8	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159694
  008df	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 240  : 
; 241  :     /* Close the CKD image file and exit */
; 242  :     rc = close_ckd_image( cif );

  008e5	48 8b 4c 24 68	 mov	 rcx, QWORD PTR cif$[rsp]
  008ea	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_close_ckd_image
  008f0	89 44 24 54	 mov	 DWORD PTR rc$[rsp], eax

; 243  :     return rc;

  008f4	8b 44 24 54	 mov	 eax, DWORD PTR rc$[rsp]
$LN1@main:
$LN38@main:

; 244  : 
; 245  : } /* end function main */

  008f8	48 8b 8c 24 f0
	03 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  00900	48 33 cc	 xor	 rcx, rsp
  00903	e8 00 00 00 00	 call	 __security_check_cookie
  00908	48 81 c4 08 04
	00 00		 add	 rsp, 1032		; 00000408H
  0090f	5f		 pop	 rdi
  00910	5e		 pop	 rsi
  00911	c3		 ret	 0
main	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\dasdpdsu.c
_TEXT	SEGMENT
pgm$ = 80
syntax	PROC

; 45   : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 46   :     // "Usage: %s ckdfile [sf=shadow-file-name] pdsname [ASCII] [odir]"
; 47   :     FWRMSG( stderr, HHC02975, "I", pgm );

  00009	b9 02 00 00 00	 mov	 ecx, 2
  0000e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  00014	48 8b 4c 24 50	 mov	 rcx, QWORD PTR pgm$[rsp]
  00019	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  0001e	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159590
  00025	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  0002a	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159591
  00031	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00036	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  0003b	41 b9 03 00 00
	00		 mov	 r9d, 3
  00041	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG159592
  00048	ba 2f 00 00 00	 mov	 edx, 47			; 0000002fH
  0004d	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159593
  00054	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 48   :     return -1;

  0005a	b8 ff ff ff ff	 mov	 eax, -1

; 49   : }

  0005f	48 83 c4 48	 add	 rsp, 72			; 00000048H
  00063	c3		 ret	 0
syntax	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\dasdpdsu.c
_TEXT	SEGMENT
dirrem$ = 64
dirptr$ = 72
size$ = 80
dirent$ = 88
rc$ = 96
k$ = 100
memname$ = 104
__$ArrayPad$ = 120
cif$ = 144
noext$ = 152
extent$ = 160
dirblk$ = 168
process_dirblk PROC

; 380  : {

  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  0000e	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00013	48 81 ec 88 00
	00 00		 sub	 rsp, 136		; 00000088H
  0001a	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00021	48 33 c4	 xor	 rax, rsp
  00024	48 89 44 24 78	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 381  : int             rc;                     /* Return code               */
; 382  : int             size;                   /* Size of directory entry   */
; 383  : int             k;                      /* Userdata halfword count   */
; 384  : BYTE           *dirptr;                 /* -> Next byte within block */
; 385  : int             dirrem;                 /* Number of bytes remaining */
; 386  : PDSDIR         *dirent;                 /* -> Directory entry        */
; 387  : char            memname[9];             /* Member name (ASCIIZ)      */
; 388  : 
; 389  :     /* Load number of bytes in directory block */
; 390  :     dirptr = dirblk;

  00029	48 8b 84 24 a8
	00 00 00	 mov	 rax, QWORD PTR dirblk$[rsp]
  00031	48 89 44 24 48	 mov	 QWORD PTR dirptr$[rsp], rax

; 391  :     dirrem = fetch_hw( dirptr );

  00036	48 8b 4c 24 48	 mov	 rcx, QWORD PTR dirptr$[rsp]
  0003b	e8 00 00 00 00	 call	 fetch_hw_noswap
  00040	0f b7 c8	 movzx	 ecx, ax
  00043	e8 00 00 00 00	 call	 _byteswap_ushort
  00048	0f b7 c0	 movzx	 eax, ax
  0004b	89 44 24 40	 mov	 DWORD PTR dirrem$[rsp], eax

; 392  :     if (dirrem < 2 || dirrem > 256)

  0004f	83 7c 24 40 02	 cmp	 DWORD PTR dirrem$[rsp], 2
  00054	7c 0a		 jl	 SHORT $LN5@process_di
  00056	81 7c 24 40 00
	01 00 00	 cmp	 DWORD PTR dirrem$[rsp], 256 ; 00000100H
  0005e	7e 51		 jle	 SHORT $LN4@process_di
$LN5@process_di:

; 393  :     {
; 394  :         // "Directory block byte count is invalid"
; 395  :         FWRMSG( stderr, HHC02400, "E" );

  00060	b9 02 00 00 00	 mov	 ecx, 2
  00065	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  0006b	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159786
  00072	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  00077	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159787
  0007e	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00083	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00088	41 b9 03 00 00
	00		 mov	 r9d, 3
  0008e	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG159788
  00095	ba 8b 01 00 00	 mov	 edx, 395		; 0000018bH
  0009a	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159789
  000a1	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 396  :         return -1;

  000a7	b8 ff ff ff ff	 mov	 eax, -1
  000ac	e9 fd 00 00 00	 jmp	 $LN1@process_di
$LN4@process_di:

; 397  :     }
; 398  : 
; 399  :     /* Point to first directory entry */
; 400  :     dirptr += 2;

  000b1	48 8b 44 24 48	 mov	 rax, QWORD PTR dirptr$[rsp]
  000b6	48 83 c0 02	 add	 rax, 2
  000ba	48 89 44 24 48	 mov	 QWORD PTR dirptr$[rsp], rax

; 401  :     dirrem -= 2;

  000bf	8b 44 24 40	 mov	 eax, DWORD PTR dirrem$[rsp]
  000c3	83 e8 02	 sub	 eax, 2
  000c6	89 44 24 40	 mov	 DWORD PTR dirrem$[rsp], eax
$LN2@process_di:

; 402  : 
; 403  :     /* Process each directory entry */
; 404  :     while (dirrem > 0)

  000ca	83 7c 24 40 00	 cmp	 DWORD PTR dirrem$[rsp], 0
  000cf	0f 8e d7 00 00
	00		 jle	 $LN3@process_di

; 405  :     {
; 406  :         /* Point to next directory entry */
; 407  :         dirent = (PDSDIR*)dirptr;

  000d5	48 8b 44 24 48	 mov	 rax, QWORD PTR dirptr$[rsp]
  000da	48 89 44 24 58	 mov	 QWORD PTR dirent$[rsp], rax

; 408  : 
; 409  :         /* Test for end of directory */
; 410  :         if (memcmp( dirent->pds2name, &CKD_ENDTRK, CKD_ENDTRK_SIZE ) == 0)

  000df	48 8b 44 24 58	 mov	 rax, QWORD PTR dirent$[rsp]
  000e4	41 b8 08 00 00
	00		 mov	 r8d, 8
  000ea	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:CKD_ENDTRK
  000f1	48 8b c8	 mov	 rcx, rax
  000f4	e8 00 00 00 00	 call	 memcmp
  000f9	85 c0		 test	 eax, eax
  000fb	75 0a		 jne	 SHORT $LN6@process_di

; 411  :             return +1;

  000fd	b8 01 00 00 00	 mov	 eax, 1
  00102	e9 a7 00 00 00	 jmp	 $LN1@process_di
$LN6@process_di:

; 412  : 
; 413  :         /* Extract the member name */
; 414  :         make_asciiz( memname, sizeof( memname ), dirent->pds2name, 8 );

  00107	48 8b 44 24 58	 mov	 rax, QWORD PTR dirent$[rsp]
  0010c	41 b9 08 00 00
	00		 mov	 r9d, 8
  00112	4c 8b c0	 mov	 r8, rax
  00115	ba 09 00 00 00	 mov	 edx, 9
  0011a	48 8d 4c 24 68	 lea	 rcx, QWORD PTR memname$[rsp]
  0011f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_make_asciiz

; 415  : 
; 416  :         /* Process the member */
; 417  :         if ((rc = process_member( cif, noext, extent, memname, dirent->pds2ttrp )) < 0)

  00125	48 8b 44 24 58	 mov	 rax, QWORD PTR dirent$[rsp]
  0012a	48 83 c0 08	 add	 rax, 8
  0012e	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00133	4c 8d 4c 24 68	 lea	 r9, QWORD PTR memname$[rsp]
  00138	4c 8b 84 24 a0
	00 00 00	 mov	 r8, QWORD PTR extent$[rsp]
  00140	8b 94 24 98 00
	00 00		 mov	 edx, DWORD PTR noext$[rsp]
  00147	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR cif$[rsp]
  0014f	e8 00 00 00 00	 call	 process_member
  00154	89 44 24 60	 mov	 DWORD PTR rc$[rsp], eax
  00158	83 7c 24 60 00	 cmp	 DWORD PTR rc$[rsp], 0
  0015d	7d 07		 jge	 SHORT $LN7@process_di

; 418  :             return -1;

  0015f	b8 ff ff ff ff	 mov	 eax, -1
  00164	eb 48		 jmp	 SHORT $LN1@process_di
$LN7@process_di:

; 419  : 
; 420  :         /* Load the user data halfword count */
; 421  :         k = dirent->pds2indc & PDS2INDC_LUSR;

  00166	48 8b 44 24 58	 mov	 rax, QWORD PTR dirent$[rsp]
  0016b	0f b6 40 0b	 movzx	 eax, BYTE PTR [rax+11]
  0016f	83 e0 1f	 and	 eax, 31
  00172	89 44 24 64	 mov	 DWORD PTR k$[rsp], eax

; 422  : 
; 423  :         /* Point to next directory entry */
; 424  :         size = 12 + (k * 2);

  00176	8b 44 24 64	 mov	 eax, DWORD PTR k$[rsp]
  0017a	8d 44 00 0c	 lea	 eax, DWORD PTR [rax+rax+12]
  0017e	89 44 24 50	 mov	 DWORD PTR size$[rsp], eax

; 425  : 
; 426  :         dirptr += size;

  00182	48 63 44 24 50	 movsxd	 rax, DWORD PTR size$[rsp]
  00187	48 8b 4c 24 48	 mov	 rcx, QWORD PTR dirptr$[rsp]
  0018c	48 03 c8	 add	 rcx, rax
  0018f	48 8b c1	 mov	 rax, rcx
  00192	48 89 44 24 48	 mov	 QWORD PTR dirptr$[rsp], rax

; 427  :         dirrem -= size;

  00197	8b 44 24 50	 mov	 eax, DWORD PTR size$[rsp]
  0019b	8b 4c 24 40	 mov	 ecx, DWORD PTR dirrem$[rsp]
  0019f	2b c8		 sub	 ecx, eax
  001a1	8b c1		 mov	 eax, ecx
  001a3	89 44 24 40	 mov	 DWORD PTR dirrem$[rsp], eax

; 428  :     }

  001a7	e9 1e ff ff ff	 jmp	 $LN2@process_di
$LN3@process_di:

; 429  : 
; 430  :     return 0;

  001ac	33 c0		 xor	 eax, eax
$LN1@process_di:

; 431  : } /* end function process_dirblk */

  001ae	48 8b 4c 24 78	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  001b3	48 33 cc	 xor	 rcx, rsp
  001b6	e8 00 00 00 00	 call	 __security_check_cookie
  001bb	48 81 c4 88 00
	00 00		 add	 rsp, 136		; 00000088H
  001c2	c3		 ret	 0
process_dirblk ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\dasdpdsu.c
_TEXT	SEGMENT
rec$ = 96
head$ = 97
len$ = 100
offset$ = 104
rc$ = 108
trk$ = 112
cyl$ = 116
ofp$ = 120
tv148 = 128
tv203 = 132
tv205 = 136
tv208 = 140
$T1 = 144
tv90 = 152
buf$ = 160
tv94 = 168
tv242 = 176
ofname$ = 184
card$ = 208
workpath$ = 304
pathname$ = 576
__$ArrayPad$ = 848
cif$ = 880
noext$ = 888
extent$ = 896
memname$ = 904
ttr$ = 912
process_member PROC

; 261  : {

  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  0000e	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00013	57		 push	 rdi
  00014	48 81 ec 60 03
	00 00		 sub	 rsp, 864		; 00000360H
  0001b	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00022	48 33 c4	 xor	 rax, rsp
  00025	48 89 84 24 50
	03 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 262  : int             rc;                     /* Return code               */
; 263  : U16             len;                    /* Record length             */
; 264  : u_int           trk;                    /* Relative track number     */
; 265  : U32             cyl;                    /* Cylinder number           */
; 266  : U8              head;                   /* Head number               */
; 267  : U8              rec;                    /* Record number             */
; 268  : BYTE           *buf;                    /* -> Data block             */
; 269  : FILE           *ofp;                    /* Output file pointer       */
; 270  : char            ofname[13] = {0};       /* Output file name          */

  0002d	48 8d 84 24 b8
	00 00 00	 lea	 rax, QWORD PTR ofname$[rsp]
  00035	48 8b f8	 mov	 rdi, rax
  00038	33 c0		 xor	 eax, eax
  0003a	b9 0d 00 00 00	 mov	 ecx, 13
  0003f	f3 aa		 rep stosb

; 271  : int             offset;                 /* Offset of record in buffer*/
; 272  : char            card[81];               /* Logical record (ASCIIZ)   */
; 273  : char            workpath[MAX_PATH];     /* full path of ofname       */
; 274  : char            pathname[MAX_PATH];     /* ofname in host format     */
; 275  : 
; 276  :     /* Build the output file name */
; 277  :     strncpy( ofname, memname, sizeof(ofname) );

  00041	41 b8 0d 00 00
	00		 mov	 r8d, 13
  00047	48 8b 94 24 88
	03 00 00	 mov	 rdx, QWORD PTR memname$[rsp]
  0004f	48 8d 8c 24 b8
	00 00 00	 lea	 rcx, QWORD PTR ofname$[rsp]
  00057	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_strncpy

; 278  :     ofname[8]=0; /* force string termination */

  0005d	b8 01 00 00 00	 mov	 eax, 1
  00062	48 6b c0 08	 imul	 rax, rax, 8
  00066	48 89 84 24 90
	00 00 00	 mov	 QWORD PTR $T1[rsp], rax
  0006e	48 83 bc 24 90
	00 00 00 0d	 cmp	 QWORD PTR $T1[rsp], 13
  00077	73 02		 jae	 SHORT $LN21@process_me
  00079	eb 05		 jmp	 SHORT $LN22@process_me
$LN21@process_me:
  0007b	e8 00 00 00 00	 call	 __report_rangecheckfailure
$LN22@process_me:
  00080	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR $T1[rsp]
  00088	c6 84 04 b8 00
	00 00 00	 mov	 BYTE PTR ofname$[rsp+rax], 0

; 279  :     string_to_lower( ofname );

  00090	48 8d 8c 24 b8
	00 00 00	 lea	 rcx, QWORD PTR ofname$[rsp]
  00098	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_string_to_lower

; 280  :     STRLCAT( ofname, ".mac" );

  0009e	41 b8 0d 00 00
	00		 mov	 r8d, 13
  000a4	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG159730
  000ab	48 8d 8c 24 b8
	00 00 00	 lea	 rcx, QWORD PTR ofname$[rsp]
  000b3	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_strlcat

; 281  : 
; 282  :     /* Build the full path of the output filename */
; 283  :     STRLCPY( workpath, odir );

  000b9	41 b8 04 01 00
	00		 mov	 r8d, 260		; 00000104H
  000bf	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:odir
  000c6	48 8d 8c 24 30
	01 00 00	 lea	 rcx, QWORD PTR workpath$[rsp]
  000ce	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_strlcpy

; 284  :     STRLCAT( workpath, ofname );

  000d4	41 b8 04 01 00
	00		 mov	 r8d, 260		; 00000104H
  000da	48 8d 94 24 b8
	00 00 00	 lea	 rdx, QWORD PTR ofname$[rsp]
  000e2	48 8d 8c 24 30
	01 00 00	 lea	 rcx, QWORD PTR workpath$[rsp]
  000ea	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_strlcat

; 285  : 
; 286  :     /* Convert output path to host format */
; 287  :     hostpath( pathname, workpath, sizeof( pathname ));

  000f0	41 b8 04 01 00
	00		 mov	 r8d, 260		; 00000104H
  000f6	48 8d 94 24 30
	01 00 00	 lea	 rdx, QWORD PTR workpath$[rsp]
  000fe	48 8d 8c 24 40
	02 00 00	 lea	 rcx, QWORD PTR pathname$[rsp]
  00106	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hostpath

; 288  : 
; 289  :     /* Open the output file */
; 290  :     if (!(ofp = fopen( pathname, (asciiflag? "w" : "wb"))))

  0010c	0f b6 05 00 00
	00 00		 movzx	 eax, BYTE PTR asciiflag
  00113	85 c0		 test	 eax, eax
  00115	74 11		 je	 SHORT $LN23@process_me
  00117	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG159732
  0011e	48 89 84 24 98
	00 00 00	 mov	 QWORD PTR tv90[rsp], rax
  00126	eb 0f		 jmp	 SHORT $LN24@process_me
$LN23@process_me:
  00128	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG159733
  0012f	48 89 84 24 98
	00 00 00	 mov	 QWORD PTR tv90[rsp], rax
$LN24@process_me:
  00137	48 8b 94 24 98
	00 00 00	 mov	 rdx, QWORD PTR tv90[rsp]
  0013f	48 8d 8c 24 40
	02 00 00	 lea	 rcx, QWORD PTR pathname$[rsp]
  00147	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fopen
  0014d	48 89 44 24 78	 mov	 QWORD PTR ofp$[rsp], rax
  00152	48 83 7c 24 78
	00		 cmp	 QWORD PTR ofp$[rsp], 0
  00158	0f 85 8d 00 00
	00		 jne	 $LN10@process_me

; 291  :     {
; 292  :         // "File %s; %s error: %s"
; 293  :         FWRMSG( stderr, HHC02468, "E", ofname, "fopen", strerror( errno ));

  0015e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno
  00164	8b 08		 mov	 ecx, DWORD PTR [rax]
  00166	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_strerror
  0016c	48 89 84 24 a8
	00 00 00	 mov	 QWORD PTR tv94[rsp], rax
  00174	b9 02 00 00 00	 mov	 ecx, 2
  00179	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  0017f	48 8b 8c 24 a8
	00 00 00	 mov	 rcx, QWORD PTR tv94[rsp]
  00187	48 89 4c 24 48	 mov	 QWORD PTR [rsp+72], rcx
  0018c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159734
  00193	48 89 4c 24 40	 mov	 QWORD PTR [rsp+64], rcx
  00198	48 8d 8c 24 b8
	00 00 00	 lea	 rcx, QWORD PTR ofname$[rsp]
  001a0	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  001a5	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159735
  001ac	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  001b1	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159736
  001b8	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  001bd	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  001c2	41 b9 03 00 00
	00		 mov	 r9d, 3
  001c8	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG159737
  001cf	ba 25 01 00 00	 mov	 edx, 293		; 00000125H
  001d4	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159738
  001db	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 294  :         return -1;

  001e1	b8 ff ff ff ff	 mov	 eax, -1
  001e6	e9 f2 03 00 00	 jmp	 $LN1@process_me
$LN10@process_me:

; 295  :     }
; 296  : 
; 297  :     /* Point to the start of the member */
; 298  :     trk = fetch_hw( ttr );

  001eb	48 8b 8c 24 90
	03 00 00	 mov	 rcx, QWORD PTR ttr$[rsp]
  001f3	e8 00 00 00 00	 call	 fetch_hw_noswap
  001f8	0f b7 c8	 movzx	 ecx, ax
  001fb	e8 00 00 00 00	 call	 _byteswap_ushort
  00200	0f b7 c0	 movzx	 eax, ax
  00203	89 44 24 70	 mov	 DWORD PTR trk$[rsp], eax

; 299  :     rec = ttr[2];

  00207	b8 01 00 00 00	 mov	 eax, 1
  0020c	48 6b c0 02	 imul	 rax, rax, 2
  00210	48 8b 8c 24 90
	03 00 00	 mov	 rcx, QWORD PTR ttr$[rsp]
  00218	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  0021c	88 44 24 60	 mov	 BYTE PTR rec$[rsp], al

; 300  : 
; 301  :     // "Member %s TTR %04X%02X"
; 302  :     WRMSG( HHC02469, "I", memname, trk, rec );

  00220	0f b6 44 24 60	 movzx	 eax, BYTE PTR rec$[rsp]
  00225	89 84 24 80 00
	00 00		 mov	 DWORD PTR tv148[rsp], eax
  0022c	b9 01 00 00 00	 mov	 ecx, 1
  00231	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  00237	8b 8c 24 80 00
	00 00		 mov	 ecx, DWORD PTR tv148[rsp]
  0023e	89 4c 24 48	 mov	 DWORD PTR [rsp+72], ecx
  00242	8b 4c 24 70	 mov	 ecx, DWORD PTR trk$[rsp]
  00246	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  0024a	48 8b 8c 24 88
	03 00 00	 mov	 rcx, QWORD PTR memname$[rsp]
  00252	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  00257	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159739
  0025e	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  00263	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159740
  0026a	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  0026f	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00274	41 b9 03 00 00
	00		 mov	 r9d, 3
  0027a	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG159741
  00281	ba 2e 01 00 00	 mov	 edx, 302		; 0000012eH
  00286	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159742
  0028d	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg
$LN25@process_me:
$LN2@process_me:

; 303  : 
; 304  :     /* Read the member */
; 305  :     while (1)

  00293	33 c0		 xor	 eax, eax
  00295	83 f8 01	 cmp	 eax, 1
  00298	0f 84 32 03 00
	00		 je	 $LN3@process_me

; 306  :     {
; 307  :         /* Convert relative track to cylinder and head */
; 308  :         if ((rc = convert_tt( trk, noext, extent, cif->heads, &cyl, &head )) < 0)

  0029e	48 8d 44 24 61	 lea	 rax, QWORD PTR head$[rsp]
  002a3	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  002a8	48 8d 44 24 74	 lea	 rax, QWORD PTR cyl$[rsp]
  002ad	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  002b2	48 8b 84 24 70
	03 00 00	 mov	 rax, QWORD PTR cif$[rsp]
  002ba	44 0f b6 48 24	 movzx	 r9d, BYTE PTR [rax+36]
  002bf	4c 8b 84 24 80
	03 00 00	 mov	 r8, QWORD PTR extent$[rsp]
  002c7	8b 94 24 78 03
	00 00		 mov	 edx, DWORD PTR noext$[rsp]
  002ce	8b 4c 24 70	 mov	 ecx, DWORD PTR trk$[rsp]
  002d2	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_convert_tt
  002d8	89 44 24 6c	 mov	 DWORD PTR rc$[rsp], eax
  002dc	83 7c 24 6c 00	 cmp	 DWORD PTR rc$[rsp], 0
  002e1	7d 0a		 jge	 SHORT $LN11@process_me

; 309  :             return -1;

  002e3	b8 ff ff ff ff	 mov	 eax, -1
  002e8	e9 f0 02 00 00	 jmp	 $LN1@process_me
$LN11@process_me:
$LN6@process_me:

; 310  : 
; 311  :         TRACE( "CCHHR=%4.4X%4.4X%2.2X\n", cyl, head, rec );

  002ed	0f b6 44 24 60	 movzx	 eax, BYTE PTR rec$[rsp]
  002f2	0f b6 4c 24 61	 movzx	 ecx, BYTE PTR head$[rsp]
  002f7	44 8b c8	 mov	 r9d, eax
  002fa	44 8b c1	 mov	 r8d, ecx
  002fd	8b 54 24 74	 mov	 edx, DWORD PTR cyl$[rsp]
  00301	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159744
  00308	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_logmsg
  0030e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_IsDebuggerPresent
  00314	85 c0		 test	 eax, eax
  00316	74 20		 je	 SHORT $LN12@process_me
  00318	0f b6 44 24 60	 movzx	 eax, BYTE PTR rec$[rsp]
  0031d	0f b6 4c 24 61	 movzx	 ecx, BYTE PTR head$[rsp]
  00322	44 8b c8	 mov	 r9d, eax
  00325	44 8b c1	 mov	 r8d, ecx
  00328	8b 54 24 74	 mov	 edx, DWORD PTR cyl$[rsp]
  0032c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159746
  00333	e8 00 00 00 00	 call	 DebuggerTrace
$LN12@process_me:
  00338	33 c0		 xor	 eax, eax
  0033a	85 c0		 test	 eax, eax
  0033c	75 af		 jne	 SHORT $LN6@process_me

; 312  : 
; 313  :         /* Read a data block */
; 314  :         if ((rc = read_block( cif, cyl, head, rec, NULL, NULL, &buf, &len )) < 0)

  0033e	48 8d 44 24 64	 lea	 rax, QWORD PTR len$[rsp]
  00343	48 89 44 24 38	 mov	 QWORD PTR [rsp+56], rax
  00348	48 8d 84 24 a0
	00 00 00	 lea	 rax, QWORD PTR buf$[rsp]
  00350	48 89 44 24 30	 mov	 QWORD PTR [rsp+48], rax
  00355	48 c7 44 24 28
	00 00 00 00	 mov	 QWORD PTR [rsp+40], 0
  0035e	48 c7 44 24 20
	00 00 00 00	 mov	 QWORD PTR [rsp+32], 0
  00367	44 0f b6 4c 24
	60		 movzx	 r9d, BYTE PTR rec$[rsp]
  0036d	44 0f b6 44 24
	61		 movzx	 r8d, BYTE PTR head$[rsp]
  00373	8b 54 24 74	 mov	 edx, DWORD PTR cyl$[rsp]
  00377	48 8b 8c 24 70
	03 00 00	 mov	 rcx, QWORD PTR cif$[rsp]
  0037f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_read_block
  00385	89 44 24 6c	 mov	 DWORD PTR rc$[rsp], eax
  00389	83 7c 24 6c 00	 cmp	 DWORD PTR rc$[rsp], 0
  0038e	7d 0a		 jge	 SHORT $LN13@process_me

; 315  :             return -1;

  00390	b8 ff ff ff ff	 mov	 eax, -1
  00395	e9 43 02 00 00	 jmp	 $LN1@process_me
$LN13@process_me:

; 316  : 
; 317  :         /* Move to next track if record not found */
; 318  :         if (rc > 0)

  0039a	83 7c 24 6c 00	 cmp	 DWORD PTR rc$[rsp], 0
  0039f	7e 14		 jle	 SHORT $LN14@process_me

; 319  :         {
; 320  :             trk++;

  003a1	8b 44 24 70	 mov	 eax, DWORD PTR trk$[rsp]
  003a5	ff c0		 inc	 eax
  003a7	89 44 24 70	 mov	 DWORD PTR trk$[rsp], eax

; 321  :             rec = 1;

  003ab	c6 44 24 60 01	 mov	 BYTE PTR rec$[rsp], 1

; 322  :             continue;

  003b0	e9 de fe ff ff	 jmp	 $LN2@process_me
$LN14@process_me:

; 323  :         }
; 324  : 
; 325  :         /* Exit at end of member */
; 326  :         if (!len)

  003b5	0f b7 44 24 64	 movzx	 eax, WORD PTR len$[rsp]
  003ba	85 c0		 test	 eax, eax
  003bc	75 05		 jne	 SHORT $LN15@process_me

; 327  :             break;

  003be	e9 0d 02 00 00	 jmp	 $LN3@process_me
$LN15@process_me:

; 328  : 
; 329  :         /* Check length of data block */
; 330  :         if (len % 80 != 0)

  003c3	0f b7 44 24 64	 movzx	 eax, WORD PTR len$[rsp]
  003c8	99		 cdq
  003c9	b9 50 00 00 00	 mov	 ecx, 80			; 00000050H
  003ce	f7 f9		 idiv	 ecx
  003d0	8b c2		 mov	 eax, edx
  003d2	85 c0		 test	 eax, eax
  003d4	0f 84 9e 00 00
	00		 je	 $LN16@process_me

; 331  :         {
; 332  :             // "Invalid block length %d at CCHHR %04X%04X%02X"
; 333  :             FWRMSG( stderr, HHC02470, "E", len, cyl, head, rec );

  003da	0f b6 44 24 60	 movzx	 eax, BYTE PTR rec$[rsp]
  003df	89 84 24 84 00
	00 00		 mov	 DWORD PTR tv203[rsp], eax
  003e6	0f b6 4c 24 61	 movzx	 ecx, BYTE PTR head$[rsp]
  003eb	89 8c 24 88 00
	00 00		 mov	 DWORD PTR tv205[rsp], ecx
  003f2	0f b7 54 24 64	 movzx	 edx, WORD PTR len$[rsp]
  003f7	89 94 24 8c 00
	00 00		 mov	 DWORD PTR tv208[rsp], edx
  003fe	b9 02 00 00 00	 mov	 ecx, 2
  00403	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  00409	8b 8c 24 84 00
	00 00		 mov	 ecx, DWORD PTR tv203[rsp]
  00410	89 4c 24 50	 mov	 DWORD PTR [rsp+80], ecx
  00414	8b 8c 24 88 00
	00 00		 mov	 ecx, DWORD PTR tv205[rsp]
  0041b	89 4c 24 48	 mov	 DWORD PTR [rsp+72], ecx
  0041f	8b 4c 24 74	 mov	 ecx, DWORD PTR cyl$[rsp]
  00423	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  00427	8b 8c 24 8c 00
	00 00		 mov	 ecx, DWORD PTR tv208[rsp]
  0042e	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  00432	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159751
  00439	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  0043e	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159752
  00445	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  0044a	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  0044f	41 b9 03 00 00
	00		 mov	 r9d, 3
  00455	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG159753
  0045c	ba 4d 01 00 00	 mov	 edx, 333		; 0000014dH
  00461	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159754
  00468	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 334  :             return -1;

  0046e	b8 ff ff ff ff	 mov	 eax, -1
  00473	e9 65 01 00 00	 jmp	 $LN1@process_me
$LN16@process_me:

; 335  :         }
; 336  : 
; 337  :         /* Process each record in the data block */
; 338  :         for (offset = 0; offset < len; offset += 80)

  00478	c7 44 24 68 00
	00 00 00	 mov	 DWORD PTR offset$[rsp], 0
  00480	eb 0b		 jmp	 SHORT $LN9@process_me
$LN7@process_me:
  00482	8b 44 24 68	 mov	 eax, DWORD PTR offset$[rsp]
  00486	83 c0 50	 add	 eax, 80			; 00000050H
  00489	89 44 24 68	 mov	 DWORD PTR offset$[rsp], eax
$LN9@process_me:
  0048d	0f b7 44 24 64	 movzx	 eax, WORD PTR len$[rsp]
  00492	39 44 24 68	 cmp	 DWORD PTR offset$[rsp], eax
  00496	0f 8d 24 01 00
	00		 jge	 $LN8@process_me

; 339  :         {
; 340  :             if (asciiflag)

  0049c	0f b6 05 00 00
	00 00		 movzx	 eax, BYTE PTR asciiflag
  004a3	85 c0		 test	 eax, eax
  004a5	74 4b		 je	 SHORT $LN17@process_me

; 341  :             {
; 342  :                 make_asciiz( card, sizeof( card ), buf + offset, 72 );

  004a7	48 63 44 24 68	 movsxd	 rax, DWORD PTR offset$[rsp]
  004ac	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR buf$[rsp]
  004b4	48 03 c8	 add	 rcx, rax
  004b7	48 8b c1	 mov	 rax, rcx
  004ba	41 b9 48 00 00
	00		 mov	 r9d, 72			; 00000048H
  004c0	4c 8b c0	 mov	 r8, rax
  004c3	ba 51 00 00 00	 mov	 edx, 81			; 00000051H
  004c8	48 8d 8c 24 d0
	00 00 00	 lea	 rcx, QWORD PTR card$[rsp]
  004d0	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_make_asciiz

; 343  :                 fprintf( ofp, "%s\n", card );

  004d6	4c 8d 84 24 d0
	00 00 00	 lea	 r8, QWORD PTR card$[rsp]
  004de	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG159757
  004e5	48 8b 4c 24 78	 mov	 rcx, QWORD PTR ofp$[rsp]
  004ea	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_fprintf

; 344  :             }

  004f0	eb 2c		 jmp	 SHORT $LN18@process_me
$LN17@process_me:

; 345  :             else
; 346  :                 fwrite( buf+offset, 80, 1, ofp );

  004f2	48 63 44 24 68	 movsxd	 rax, DWORD PTR offset$[rsp]
  004f7	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR buf$[rsp]
  004ff	48 03 c8	 add	 rcx, rax
  00502	48 8b c1	 mov	 rax, rcx
  00505	4c 8b 4c 24 78	 mov	 r9, QWORD PTR ofp$[rsp]
  0050a	41 b8 01 00 00
	00		 mov	 r8d, 1
  00510	ba 50 00 00 00	 mov	 edx, 80			; 00000050H
  00515	48 8b c8	 mov	 rcx, rax
  00518	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_fwrite
$LN18@process_me:

; 347  : 
; 348  :             if (ferror( ofp ))

  0051e	48 8b 4c 24 78	 mov	 rcx, QWORD PTR ofp$[rsp]
  00523	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ferror
  00529	85 c0		 test	 eax, eax
  0052b	0f 84 8a 00 00
	00		 je	 $LN19@process_me

; 349  :             {
; 350  :                 // "File %s; %s error: %s"
; 351  :                 FWRMSG( stderr, HHC02468, "E",

  00531	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno
  00537	8b 08		 mov	 ecx, DWORD PTR [rax]
  00539	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_strerror
  0053f	48 89 84 24 b0
	00 00 00	 mov	 QWORD PTR tv242[rsp], rax
  00547	b9 02 00 00 00	 mov	 ecx, 2
  0054c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  00552	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR tv242[rsp]
  0055a	48 89 4c 24 48	 mov	 QWORD PTR [rsp+72], rcx
  0055f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159759
  00566	48 89 4c 24 40	 mov	 QWORD PTR [rsp+64], rcx
  0056b	48 8d 8c 24 b8
	00 00 00	 lea	 rcx, QWORD PTR ofname$[rsp]
  00573	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  00578	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159760
  0057f	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  00584	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159761
  0058b	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00590	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00595	41 b9 03 00 00
	00		 mov	 r9d, 3
  0059b	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG159762
  005a2	ba 60 01 00 00	 mov	 edx, 352		; 00000160H
  005a7	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159763
  005ae	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 352  :                     ofname, "fwrite", strerror( errno ));
; 353  :                 return -1;

  005b4	b8 ff ff ff ff	 mov	 eax, -1
  005b9	eb 22		 jmp	 SHORT $LN1@process_me
$LN19@process_me:

; 354  :             }
; 355  :         } /* end for(offset) */

  005bb	e9 c2 fe ff ff	 jmp	 $LN7@process_me
$LN8@process_me:

; 356  : 
; 357  :         /* Point to the next data block */
; 358  :         rec++;

  005c0	0f b6 44 24 60	 movzx	 eax, BYTE PTR rec$[rsp]
  005c5	fe c0		 inc	 al
  005c7	88 44 24 60	 mov	 BYTE PTR rec$[rsp], al

; 359  : 
; 360  :     } /* end while */

  005cb	e9 c3 fc ff ff	 jmp	 $LN25@process_me
$LN3@process_me:

; 361  : 
; 362  :     /* Close the output file and exit */
; 363  :     fclose( ofp );

  005d0	48 8b 4c 24 78	 mov	 rcx, QWORD PTR ofp$[rsp]
  005d5	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_fclose

; 364  :     return 0;

  005db	33 c0		 xor	 eax, eax
$LN1@process_me:
$LN20@process_me:

; 365  : 
; 366  : } /* end function process_member */

  005dd	48 8b 8c 24 50
	03 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  005e5	48 33 cc	 xor	 rcx, rsp
  005e8	e8 00 00 00 00	 call	 __security_check_cookie
  005ed	48 81 c4 60 03
	00 00		 add	 rsp, 864		; 00000360H
  005f4	5f		 pop	 rdi
  005f5	c3		 ret	 0
process_member ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\machdep.h
;	COMDAT fetch_hw_noswap
_TEXT	SEGMENT
value$ = 0
ptr$ = 32
fetch_hw_noswap PROC					; COMDAT

; 712  :     inline U16 fetch_hw_noswap(const void *ptr) {

$LN3:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 18	 sub	 rsp, 24

; 713  :       U16 value;
; 714  :       memcpy(&value, (BYTE *)ptr, 2);

  00009	48 8b 44 24 20	 mov	 rax, QWORD PTR ptr$[rsp]
  0000e	0f b7 00	 movzx	 eax, WORD PTR [rax]
  00011	66 89 04 24	 mov	 WORD PTR value$[rsp], ax

; 715  :       return value;

  00015	0f b7 04 24	 movzx	 eax, WORD PTR value$[rsp]

; 716  :     }

  00019	48 83 c4 18	 add	 rsp, 24
  0001d	c3		 ret	 0
fetch_hw_noswap ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\dbgtrace.h
_TEXT	SEGMENT
buffsize$ = 48
rc$ = 52
chunksize$ = 56
buffer$ = 64
args$ = 72
fmt$ = 96
DebuggerTrace PROC

; 94   :   static inline void DebuggerTrace(char* fmt, ...) {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000f	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00014	48 83 ec 58	 sub	 rsp, 88			; 00000058H

; 95   :       const int chunksize = 512;

  00018	c7 44 24 38 00
	02 00 00	 mov	 DWORD PTR chunksize$[rsp], 512 ; 00000200H

; 96   :       int buffsize = 0;

  00020	c7 44 24 30 00
	00 00 00	 mov	 DWORD PTR buffsize$[rsp], 0

; 97   :       char* buffer = NULL;

  00028	48 c7 44 24 40
	00 00 00 00	 mov	 QWORD PTR buffer$[rsp], 0

; 98   :       int rc = -1;

  00031	c7 44 24 34 ff
	ff ff ff	 mov	 DWORD PTR rc$[rsp], -1

; 99   :       va_list args;
; 100  :       va_start( args, fmt );

  00039	48 8d 44 24 68	 lea	 rax, QWORD PTR fmt$[rsp+8]
  0003e	48 89 44 24 48	 mov	 QWORD PTR args$[rsp], rax
$LN9@DebuggerTr:
$LN4@DebuggerTr:

; 101  :       do {
; 102  :           if (buffer) free( buffer );

  00043	48 83 7c 24 40
	00		 cmp	 QWORD PTR buffer$[rsp], 0
  00049	74 0b		 je	 SHORT $LN5@DebuggerTr
  0004b	48 8b 4c 24 40	 mov	 rcx, QWORD PTR buffer$[rsp]
  00050	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free
$LN5@DebuggerTr:

; 103  :           buffsize += chunksize;

  00056	8b 44 24 38	 mov	 eax, DWORD PTR chunksize$[rsp]
  0005a	8b 4c 24 30	 mov	 ecx, DWORD PTR buffsize$[rsp]
  0005e	03 c8		 add	 ecx, eax
  00060	8b c1		 mov	 eax, ecx
  00062	89 44 24 30	 mov	 DWORD PTR buffsize$[rsp], eax

; 104  :           buffer = malloc( buffsize + 1 );

  00066	8b 44 24 30	 mov	 eax, DWORD PTR buffsize$[rsp]
  0006a	ff c0		 inc	 eax
  0006c	48 98		 cdqe
  0006e	48 8b c8	 mov	 rcx, rax
  00071	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_malloc
  00077	48 89 44 24 40	 mov	 QWORD PTR buffer$[rsp], rax

; 105  :           if (!buffer) BREAK_INTO_DEBUGGER();

  0007c	48 83 7c 24 40
	00		 cmp	 QWORD PTR buffer$[rsp], 0
  00082	75 01		 jne	 SHORT $LN6@DebuggerTr
  00084	cc		 int	 3
$LN6@DebuggerTr:

; 106  :           rc = _vsnprintf_s( buffer, buffsize+1, buffsize, fmt, args);

  00085	48 63 44 24 30	 movsxd	 rax, DWORD PTR buffsize$[rsp]
  0008a	8b 4c 24 30	 mov	 ecx, DWORD PTR buffsize$[rsp]
  0008e	ff c1		 inc	 ecx
  00090	48 63 c9	 movsxd	 rcx, ecx
  00093	48 8b 54 24 48	 mov	 rdx, QWORD PTR args$[rsp]
  00098	48 89 54 24 20	 mov	 QWORD PTR [rsp+32], rdx
  0009d	4c 8b 4c 24 60	 mov	 r9, QWORD PTR fmt$[rsp]
  000a2	4c 8b c0	 mov	 r8, rax
  000a5	48 8b d1	 mov	 rdx, rcx
  000a8	48 8b 4c 24 40	 mov	 rcx, QWORD PTR buffer$[rsp]
  000ad	e8 00 00 00 00	 call	 _vsnprintf_s
  000b2	89 44 24 34	 mov	 DWORD PTR rc$[rsp], eax

; 107  :       } while (rc < 0 || rc >= buffsize);

  000b6	83 7c 24 34 00	 cmp	 DWORD PTR rc$[rsp], 0
  000bb	7c 86		 jl	 SHORT $LN4@DebuggerTr
  000bd	8b 44 24 30	 mov	 eax, DWORD PTR buffsize$[rsp]
  000c1	39 44 24 34	 cmp	 DWORD PTR rc$[rsp], eax
  000c5	0f 8d 78 ff ff
	ff		 jge	 $LN9@DebuggerTr

; 108  :       OutputDebugStringA( buffer ); /* send to debugger pane */

  000cb	48 8b 4c 24 40	 mov	 rcx, QWORD PTR buffer$[rsp]
  000d0	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_OutputDebugStringA

; 109  :       if (buffer) free( buffer );

  000d6	48 83 7c 24 40
	00		 cmp	 QWORD PTR buffer$[rsp], 0
  000dc	74 0b		 je	 SHORT $LN7@DebuggerTr
  000de	48 8b 4c 24 40	 mov	 rcx, QWORD PTR buffer$[rsp]
  000e3	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free
$LN7@DebuggerTr:

; 110  :       va_end( args );

  000e9	48 c7 44 24 48
	00 00 00 00	 mov	 QWORD PTR args$[rsp], 0

; 111  :   }

  000f2	48 83 c4 58	 add	 rsp, 88			; 00000058H
  000f6	c3		 ret	 0
DebuggerTrace ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files (x86)\Windows Kits\10\include\10.0.22000.0\ucrt\stdio.h
;	COMDAT _vsnprintf_s
_TEXT	SEGMENT
_Buffer$ = 64
_BufferCount$ = 72
_MaxCount$ = 80
_Format$ = 88
_ArgList$ = 96
_vsnprintf_s PROC					; COMDAT

; 1598 :     {

$LN3:
  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 1599 :         return _vsnprintf_s_l(_Buffer, _BufferCount, _MaxCount, _Format, NULL, _ArgList);

  00018	48 8b 44 24 60	 mov	 rax, QWORD PTR _ArgList$[rsp]
  0001d	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  00022	48 c7 44 24 20
	00 00 00 00	 mov	 QWORD PTR [rsp+32], 0
  0002b	4c 8b 4c 24 58	 mov	 r9, QWORD PTR _Format$[rsp]
  00030	4c 8b 44 24 50	 mov	 r8, QWORD PTR _MaxCount$[rsp]
  00035	48 8b 54 24 48	 mov	 rdx, QWORD PTR _BufferCount$[rsp]
  0003a	48 8b 4c 24 40	 mov	 rcx, QWORD PTR _Buffer$[rsp]
  0003f	e8 00 00 00 00	 call	 _vsnprintf_s_l

; 1600 :     }

  00044	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00048	c3		 ret	 0
_vsnprintf_s ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files (x86)\Windows Kits\10\include\10.0.22000.0\ucrt\stdio.h
;	COMDAT _vsnprintf_s_l
_TEXT	SEGMENT
_Result$ = 64
tv74 = 68
_Buffer$ = 96
_BufferCount$ = 104
_MaxCount$ = 112
_Format$ = 120
_Locale$ = 128
_ArgList$ = 136
_vsnprintf_s_l PROC					; COMDAT

; 1577 :     {

$LN5:
  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	48 83 ec 58	 sub	 rsp, 88			; 00000058H

; 1578 :         int const _Result = __stdio_common_vsnprintf_s(

  00018	e8 00 00 00 00	 call	 __local_stdio_printf_options
  0001d	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR _ArgList$[rsp]
  00025	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  0002a	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR _Locale$[rsp]
  00032	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00037	48 8b 4c 24 78	 mov	 rcx, QWORD PTR _Format$[rsp]
  0003c	48 89 4c 24 20	 mov	 QWORD PTR [rsp+32], rcx
  00041	4c 8b 4c 24 70	 mov	 r9, QWORD PTR _MaxCount$[rsp]
  00046	4c 8b 44 24 68	 mov	 r8, QWORD PTR _BufferCount$[rsp]
  0004b	48 8b 54 24 60	 mov	 rdx, QWORD PTR _Buffer$[rsp]
  00050	48 8b 08	 mov	 rcx, QWORD PTR [rax]
  00053	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___stdio_common_vsnprintf_s
  00059	89 44 24 40	 mov	 DWORD PTR _Result$[rsp], eax

; 1579 :             _CRT_INTERNAL_LOCAL_PRINTF_OPTIONS,
; 1580 :             _Buffer, _BufferCount, _MaxCount, _Format, _Locale, _ArgList);
; 1581 : 
; 1582 :         return _Result < 0 ? -1 : _Result;

  0005d	83 7c 24 40 00	 cmp	 DWORD PTR _Result$[rsp], 0
  00062	7d 0a		 jge	 SHORT $LN3@vsnprintf_
  00064	c7 44 24 44 ff
	ff ff ff	 mov	 DWORD PTR tv74[rsp], -1
  0006c	eb 08		 jmp	 SHORT $LN4@vsnprintf_
$LN3@vsnprintf_:
  0006e	8b 44 24 40	 mov	 eax, DWORD PTR _Result$[rsp]
  00072	89 44 24 44	 mov	 DWORD PTR tv74[rsp], eax
$LN4@vsnprintf_:
  00076	8b 44 24 44	 mov	 eax, DWORD PTR tv74[rsp]

; 1583 :     }

  0007a	48 83 c4 58	 add	 rsp, 88			; 00000058H
  0007e	c3		 ret	 0
_vsnprintf_s_l ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files (x86)\Windows Kits\10\include\10.0.22000.0\ucrt\corecrt_stdio_config.h
;	COMDAT __local_stdio_printf_options
_TEXT	SEGMENT
__local_stdio_printf_options PROC			; COMDAT

; 91   :         static unsigned __int64 _OptionsStorage;
; 92   :         return &_OptionsStorage;

  00000	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:?_OptionsStorage@?1??__local_stdio_printf_options@@9@9 ; `__local_stdio_printf_options'::`2'::_OptionsStorage

; 93   :     }

  00007	c3		 ret	 0
__local_stdio_printf_options ENDP
_TEXT	ENDS
END
