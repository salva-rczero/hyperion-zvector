; Listing generated by Microsoft (R) Optimizing Compiler Version 19.34.31937.0 

include listing.inc

INCLUDELIB MSVCRTD
INCLUDELIB OLDNAMES

PUBLIC	slowpoll
PUBLIC	fastpoll
PUBLIC	timeout
PUBLIC	previo
_BSS	SEGMENT
$SG177530 DB	01H DUP (?)
	ALIGN	4

$SG177531 DB	01H DUP (?)
	ALIGN	4

$SG177542 DB	01H DUP (?)
	ALIGN	4

$SG177544 DB	01H DUP (?)
	ALIGN	4

$SG177780 DB	01H DUP (?)
	ALIGN	8

previo	DQ	01H DUP (?)
_BSS	ENDS
_DATA	SEGMENT
COMM	currio:QWORD
COMM	diffio:QWORD
_DATA	ENDS
_DATA	SEGMENT
$SG177487 DB	'@ALIGN NONE', 00H
$SG177493 DB	'@NL', 00H
$SG177488 DB	'@SBA 0,0', 00H
	ORG $+3
$SG177489 DB	'@SF P', 00H
	ORG $+2
$SG177491 DB	'@SF HP', 00H
	ORG $+1
$SG177498 DB	'@NL', 00H
$SG177490 DB	'Hercules Version  :', 00H
$SG177503 DB	'@NL', 00H
$SG177492 DB	'$(VERSION)', 00H
	ORG $+1
$SG177494 DB	'@SF P', 00H
	ORG $+2
$SG177496 DB	'@SF HP', 00H
	ORG $+1
$SG177508 DB	'@NL', 00H
$SG177495 DB	'Host name         :', 00H
$SG177513 DB	'@NL', 00H
$SG177497 DB	'$(HOSTNAME)', 00H
$SG177499 DB	'@SF P', 00H
	ORG $+2
$SG177501 DB	'@SF HP', 00H
	ORG $+1
$SG177518 DB	'@NL', 00H
$SG177500 DB	'Host OS           :', 00H
$SG177523 DB	'@NL', 00H
$SG177502 DB	'$(HOSTOS)-$(HOSTOSREL)', 00H
	ORG $+1
$SG177504 DB	'@SF P', 00H
	ORG $+2
$SG177505 DB	'Host Architecture :', 00H
$SG177506 DB	'@SF HP', 00H
	ORG $+5
$SG177507 DB	'$(HOSTARCH)', 00H
$SG177509 DB	'@SF P', 00H
	ORG $+6
$SG177510 DB	'Processors        :', 00H
$SG177511 DB	'@SF HP', 00H
	ORG $+5
$SG177512 DB	'$(HOSTNUMCPUS)', 00H
	ORG $+1
$SG177514 DB	'@SF P', 00H
	ORG $+2
$SG177515 DB	'LPAR Name         :', 00H
$SG177516 DB	'@SF HP', 00H
	ORG $+5
$SG177517 DB	'$(LPARNAME)', 00H
$SG177519 DB	'@SF P', 00H
	ORG $+6
$SG177520 DB	'Device number     :', 00H
$SG177521 DB	'@SF HP', 00H
	ORG $+5
$SG177522 DB	'$(CSS):$(CCUU)', 00H
	ORG $+1
$SG177524 DB	'@SF P', 00H
	ORG $+2
$SG177525 DB	'Subchannel        :', 00H
$SG177526 DB	'@SF HP', 00H
	ORG $+5
$SG177527 DB	'$(SUBCHAN)', 00H
	ORG $+1
$SG177528 DB	'@SF P', 00H
	ORG $+6
$SG177529 DB	'@ALIGN LEFT', 00H
	ORG $+4
$SG177532 DB	'         The Hercules S/370, ESA/390 and z/Architecture '
	DB	'Emulator', 00H
	ORG $+7
$SG177533 DB	'                 Software Development Laboratories', 00H
	ORG $+5
$SG177534 DB	'           _    _                            _', 00H
	ORG $+1
$SG177535 DB	'          | |  | |                          (_)', 00H
$SG177536 DB	'          | |__| | _   _  _ __    ___  _ __  _   ___   _'
	DB	' __', 00H
	ORG $+4
$SG177537 DB	'          |  __  || | | || ''_ \  / _ \| ''__|| | / _ \ '
	DB	'| ''_ \', 00H
	ORG $+3
$SG177538 DB	'          | |  | || |_| || |_) ||  __/| |   | || (_) || '
	DB	'| | |', 00H
	ORG $+2
$SG177539 DB	'          |_|  |_| \__, || .__/  \___||_|   |_| \___/ |_'
	DB	'| |_|', 00H
	ORG $+2
$SG177540 DB	'                    __/ || |', 00H
	ORG $+3
$SG177541 DB	'                   |___/ |_|', 00H
	ORG $+3
$SG177543 DB	'                   My PC thinks it''s a MAINFRAME!', 00H
	ORG $+6
$SG178000 DB	'0.0.0.0', 00H
$SG177545 DB	'       Copyright (C) 1999-2023 Roger Bowler, Jan Jaeger,'
	DB	' and others', 00H
	ORG $+4
$SG178049 DB	'0.0.0.0', 00H
constty_immed DB 00H
	DB	00H
	DB	00H
	DB	01H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	01H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
loc3270_immed DB 00H
	DB	00H
	DB	00H
	DB	01H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	01H
	DB	00H
	DB	00H
	DB	00H
	DB	01H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	01H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	01H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	01H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	01H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
$SG178716 DB	'IBM-DYNAMIC', 00H
	ORG $+4
$SG178717 DB	'IBM-3179-2', 00H
	ORG $+5
$SG178718 DB	'IBM-3180-2', 00H
	ORG $+5
$SG178719 DB	'IBM-3277-2', 00H
	ORG $+5
$SG178720 DB	'IBM-3278-2', 00H
	ORG $+5
$SG178721 DB	'IBM-3278-3', 00H
	ORG $+5
$SG178722 DB	'IBM-3278-4', 00H
	ORG $+5
$SG178723 DB	'IBM-3278-5', 00H
	ORG $+5
$SG178724 DB	'IBM-3278-2-E', 00H
	ORG $+3
$SG178725 DB	'IBM-3278-3-E', 00H
	ORG $+3
$SG178726 DB	'IBM-3278-4-E', 00H
	ORG $+3
$SG178727 DB	'IBM-3278-5-E', 00H
	ORG $+3
$SG178728 DB	'IBM-3279-2', 00H
	ORG $+5
$SG178729 DB	'IBM-3279-3', 00H
	ORG $+5
$SG178730 DB	'IBM-3279-4', 00H
	ORG $+5
$SG178731 DB	'IBM-3279-5', 00H
	ORG $+5
$SG178732 DB	'IBM-3279-2-E', 00H
	ORG $+3
$SG178733 DB	'IBM-3279-3-E', 00H
	ORG $+3
$SG178734 DB	'IBM-3279-4-E', 00H
	ORG $+3
$SG178735 DB	'IBM-3279-5-E', 00H
	ORG $+3
slowpoll DQ	0000000000000000H
	DD	05f5e100H
	ORG $+4
fastpoll DQ	0000000000000000H
	DD	0f4240H
	ORG $+4
timeout	DQ	FLAT:slowpoll
_DATA	ENDS
CONST	SEGMENT
CKD_ENDTRK DB	0ffH
	DB	0ffH
	DB	0ffH
	DB	0ffH
	DB	0ffH
	DB	0ffH
	DB	0ffH
	DB	0ffH
telnet_opts DB	018H
	DB	0fcH
	DB	0fdH
	DB	0ffH
	DB	00H
	DB	00H
CONST	ENDS
PUBLIC	__local_stdio_printf_options
PUBLIC	__local_stdio_scanf_options
PUBLIC	_vsnprintf_s_l
PUBLIC	_vsnprintf_s
PUBLIC	_vsscanf_l
PUBLIC	sscanf
PUBLIC	fetch_hw_noswap
PUBLIC	store_hw_noswap
PUBLIC	fetch_fw_noswap
PUBLIC	store_fw_noswap
PUBLIC	fetch_dw_noswap
PUBLIC	store_dw_noswap
PUBLIC	hdl_check_depends_ep
PUBLIC	hdl_define_devtypes_ep
EXTRN	__report_rangecheckfailure:PROC
EXTRN	__imp_isalpha:PROC
EXTRN	__imp_isdigit:PROC
EXTRN	__imp_isalnum:PROC
EXTRN	__imp__errno:PROC
EXTRN	memmove:PROC
EXTRN	strchr:PROC
EXTRN	strcmp:PROC
EXTRN	__imp__stricmp:PROC
EXTRN	strlen:PROC
EXTRN	__imp__strnicmp:PROC
EXTRN	__imp_strdup:PROC
EXTRN	__imp_IsDebuggerPresent:PROC
EXTRN	__imp_OutputDebugStringA:PROC
EXTRN	__imp_calloc:PROC
EXTRN	__imp_free:PROC
EXTRN	__imp_malloc:PROC
EXTRN	__imp_realloc:PROC
EXTRN	_byteswap_ushort:PROC
EXTRN	_byteswap_ulong:PROC
EXTRN	_byteswap_uint64:PROC
EXTRN	__imp_atoi:PROC
EXTRN	__imp_bind:PROC
EXTRN	__imp_getpeername:PROC
EXTRN	__imp_htons:PROC
EXTRN	__imp_inet_addr:PROC
EXTRN	__imp_inet_ntoa:PROC
EXTRN	__imp_listen:PROC
EXTRN	__imp_ntohs:PROC
EXTRN	__imp_recv:PROC
EXTRN	__imp_send:PROC
EXTRN	__imp_setsockopt:PROC
EXTRN	__imp_gethostbyname:PROC
EXTRN	__imp_getservbyname:PROC
EXTRN	__imp_WSASetLastError:PROC
EXTRN	__imp_WSAGetLastError:PROC
EXTRN	__imp_inet_pton:PROC
EXTRN	inet_ntop:PROC
EXTRN	__imp___acrt_iob_func:PROC
EXTRN	__imp_fread:PROC
EXTRN	__imp___stdio_common_vsnprintf_s:PROC
EXTRN	__imp___stdio_common_vsscanf:PROC
EXTRN	__imp_fthread_self:PROC
EXTRN	__imp_hthread_obtain_lock:PROC
EXTRN	__imp_hthread_try_obtain_lock:PROC
EXTRN	__imp_hthread_release_lock:PROC
EXTRN	__imp_hthread_create_thread:PROC
EXTRN	__imp_hthread_join_thread:PROC
EXTRN	__imp_hthread_set_thread_prio:PROC
EXTRN	__imp_hthread_get_thread_prio:PROC
EXTRN	__imp_init_hostinfo:PROC
EXTRN	__imp_get_symbol:PROC
EXTRN	__imp_resolve_symbol_string:PROC
EXTRN	__imp_set_symbol:PROC
EXTRN	__imp_strlcpy:PROC
EXTRN	__imp_timeval_subtract:PROC
EXTRN	__imp_w32_strerror:PROC
EXTRN	__imp_strtok_r:PROC
EXTRN	__imp_gettimeofday:PROC
EXTRN	__imp_usleep:PROC
EXTRN	__imp_sleep:PROC
EXTRN	__imp_sched_yield:PROC
EXTRN	__imp_hostpath:PROC
EXTRN	__imp_socket_set_blocking_mode:PROC
EXTRN	__imp_set_socket_keepalive:PROC
EXTRN	__imp_w32_socket:PROC
EXTRN	__imp_w32_accept:PROC
EXTRN	__imp_w32_close_socket:PROC
EXTRN	__imp_w32_FD_SET:PROC
EXTRN	__imp_w32_FD_ISSET:PROC
EXTRN	__imp_w32_pselect:PROC
EXTRN	__imp_w32_fwrite:PROC
EXTRN	__imp_w32_snprintf:PROC
EXTRN	__imp_w32_basename:PROC
EXTRN	__imp_guest_to_host:PROC
EXTRN	__imp_prt_host_to_guest:PROC
EXTRN	__imp_write_socket:PROC
EXTRN	__imp_disable_nagle:PROC
EXTRN	telnet_init:PROC
EXTRN	telnet_free:PROC
EXTRN	telnet_recv:PROC
EXTRN	telnet_3270_cmd:PROC
EXTRN	telnet_negotiate:PROC
EXTRN	telnet_send_one_shot:PROC
EXTRN	telnet_printf:PROC
EXTRN	telnet_ttype_send:PROC
EXTRN	telnet_ttype_is:PROC
EXTRN	telnet_opt_name:PROC
EXTRN	telnet_evt_name:PROC
EXTRN	telnet_err_name:PROC
EXTRN	telnet_closesocket:PROC
EXTRN	__imp_readlogo:PROC
EXTRN	__imp_sclp_sysg_attention:PROC
EXTRN	__imp_device_attention:PROC
EXTRN	__imp_Dequeue_IO_Interrupt:PROC
EXTRN	__imp_fwritemsg:PROC
EXTRN	__imp_logmsg:PROC
EXTRN	__GSHandlerCheck:PROC
EXTRN	__chkstk:PROC
EXTRN	__security_check_cookie:PROC
EXTRN	__imp_hostinfo:BYTE
EXTRN	__imp_sysblk:BYTE
EXTRN	__ImageBase:BYTE
EXTRN	__security_cookie:QWORD
_DATA	SEGMENT
COMM	?_OptionsStorage@?1??__local_stdio_printf_options@@9@9:QWORD							; `__local_stdio_printf_options'::`2'::_OptionsStorage
COMM	?_OptionsStorage@?1??__local_stdio_scanf_options@@9@9:QWORD							; `__local_stdio_scanf_options'::`2'::_OptionsStorage
_DATA	ENDS
_BSS	SEGMENT
console_cnslcnt DD 01H DUP (?)
$SG178641 DB	01H DUP (?)
	ALIGN	4

$SG178653 DB	01H DUP (?)
	ALIGN	4

$SG178655 DB	01H DUP (?)
	ALIGN	4

$SG178704 DB	01H DUP (?)
	ALIGN	4

$SG179003 DB	01H DUP (?)
	ALIGN	8

?prev@?BN@??console_connection_handler@@9@9 DQ 01H DUP (?) ; `console_connection_handler'::`29'::prev
?prev@?CE@??console_connection_handler@@9@9 DQ 01H DUP (?) ; `console_connection_handler'::`36'::prev
?clid@?CI@??console_connection_handler@@9@9 DD 01H DUP (?) ; `console_connection_handler'::`40'::clid
$SG179337 DB	01H DUP (?)
	ALIGN	4

$SG179343 DB	01H DUP (?)
_BSS	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$_vsnprintf_s_l DD imagerel $LN5
	DD	imagerel $LN5+127
	DD	imagerel $unwind$_vsnprintf_s_l
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$_vsnprintf_s DD imagerel $LN3
	DD	imagerel $LN3+73
	DD	imagerel $unwind$_vsnprintf_s
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$_vsscanf_l DD imagerel $LN3
	DD	imagerel $LN3+80
	DD	imagerel $unwind$_vsscanf_l
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$sscanf DD imagerel $LN3
	DD	imagerel $LN3+79
	DD	imagerel $unwind$sscanf
pdata	ENDS
pdata	SEGMENT
$pdata$DebuggerTrace DD imagerel DebuggerTrace
	DD	imagerel DebuggerTrace+247
	DD	imagerel $unwind$DebuggerTrace
$pdata$strupper DD imagerel strupper
	DD	imagerel strupper+114
	DD	imagerel $unwind$strupper
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$fetch_hw_noswap DD imagerel $LN3
	DD	imagerel $LN3+30
	DD	imagerel $unwind$fetch_hw_noswap
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$fetch_fw_noswap DD imagerel $LN3
	DD	imagerel $LN3+27
	DD	imagerel $unwind$fetch_fw_noswap
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$fetch_dw_noswap DD imagerel $LN3
	DD	imagerel $LN3+30
	DD	imagerel $unwind$fetch_dw_noswap
pdata	ENDS
pdata	SEGMENT
$pdata$sr_write_hdr DD imagerel sr_write_hdr
	DD	imagerel sr_write_hdr+199
	DD	imagerel $unwind$sr_write_hdr
$pdata$sr_write_value DD imagerel sr_write_value
	DD	imagerel sr_write_value+378
	DD	imagerel $unwind$sr_write_value
$pdata$sr_write_buf DD imagerel sr_write_buf
	DD	imagerel sr_write_buf+285
	DD	imagerel $unwind$sr_write_buf
$pdata$sr_read_hdr DD imagerel sr_read_hdr
	DD	imagerel sr_read_hdr+221
	DD	imagerel $unwind$sr_read_hdr
$pdata$sr_read_value DD imagerel sr_read_value
	DD	imagerel sr_read_value+588
	DD	imagerel $unwind$sr_read_value
$pdata$sr_read_buf DD imagerel sr_read_buf
	DD	imagerel sr_read_buf+240
	DD	imagerel $unwind$sr_read_buf
$pdata$sr_read_skip DD imagerel sr_read_skip
	DD	imagerel sr_read_skip+248
	DD	imagerel $unwind$sr_read_skip
$pdata$sr_write_error_ DD imagerel sr_write_error_
	DD	imagerel sr_write_error_+121
	DD	imagerel $unwind$sr_write_error_
$pdata$sr_read_error_ DD imagerel sr_read_error_
	DD	imagerel sr_read_error_+121
	DD	imagerel $unwind$sr_read_error_
$pdata$sr_value_error_ DD imagerel sr_value_error_
	DD	imagerel sr_value_error_+80
	DD	imagerel $unwind$sr_value_error_
$pdata$console_connection_handler DD imagerel console_connection_handler
	DD	imagerel console_connection_handler+4778
	DD	imagerel $unwind$console_connection_handler
$pdata$solicit_3270_data DD imagerel solicit_3270_data
	DD	imagerel solicit_3270_data+255
	DD	imagerel $unwind$solicit_3270_data
$pdata$loc3270_input DD imagerel loc3270_input
	DD	imagerel loc3270_input+588
	DD	imagerel $unwind$loc3270_input
$pdata$constty_input DD imagerel constty_input
	DD	imagerel constty_input+1082
	DD	imagerel $unwind$constty_input
$pdata$negotiate_ttype DD imagerel negotiate_ttype
	DD	imagerel negotiate_ttype+1045
	DD	imagerel $unwind$negotiate_ttype
$pdata$telnet_ev_handler DD imagerel telnet_ev_handler
	DD	imagerel telnet_ev_handler+3776
	DD	imagerel $unwind$telnet_ev_handler
$pdata$sendto_client DD imagerel sendto_client
	DD	imagerel sendto_client+297
	DD	imagerel $unwind$sendto_client
$pdata$raise_device_attention DD imagerel raise_device_attention
	DD	imagerel raise_device_attention+129
	DD	imagerel $unwind$raise_device_attention
$pdata$finish_console_init DD imagerel finish_console_init
	DD	imagerel finish_console_init+269
	DD	imagerel $unwind$finish_console_init
$pdata$disconnect_telnet_client DD imagerel disconnect_telnet_client
	DD	imagerel disconnect_telnet_client+113
	DD	imagerel $unwind$disconnect_telnet_client
$pdata$disconnect_console_device DD imagerel disconnect_console_device
	DD	imagerel disconnect_console_device+87
	DD	imagerel $unwind$disconnect_console_device
$pdata$finish_console_close DD imagerel finish_console_close
	DD	imagerel finish_console_close+431
	DD	imagerel $unwind$finish_console_close
$pdata$loc3270_close_device DD imagerel loc3270_close_device
	DD	imagerel loc3270_close_device+65
	DD	imagerel $unwind$loc3270_close_device
$pdata$constty_close_device DD imagerel constty_close_device
	DD	imagerel constty_close_device+26
	DD	imagerel $unwind$constty_close_device
$pdata$loc3270_init_handler DD imagerel loc3270_init_handler
	DD	imagerel loc3270_init_handler+2808
	DD	imagerel $unwind$loc3270_init_handler
$pdata$constty_init_handler DD imagerel constty_init_handler
	DD	imagerel constty_init_handler+1861
	DD	imagerel $unwind$constty_init_handler
$pdata$parse_sockspec DD imagerel parse_sockspec
	DD	imagerel parse_sockspec+716
	DD	imagerel $unwind$parse_sockspec
$pdata$next_3270_pos DD imagerel next_3270_pos
	DD	imagerel next_3270_pos+680
	DD	imagerel $unwind$next_3270_pos
$pdata$end_of_buf_pos DD imagerel end_of_buf_pos
	DD	imagerel end_of_buf_pos+75
	DD	imagerel $unwind$end_of_buf_pos
$pdata$pos_to_buff_offset DD imagerel pos_to_buff_offset
	DD	imagerel pos_to_buff_offset+89
	DD	imagerel $unwind$pos_to_buff_offset
$pdata$buffer_addchar DD imagerel buffer_addchar
	DD	imagerel buffer_addchar+230
	DD	imagerel $unwind$buffer_addchar
$pdata$buffer_addstring DD imagerel buffer_addstring
	DD	imagerel buffer_addstring+140
	DD	imagerel $unwind$buffer_addstring
$pdata$buffer_addsba DD imagerel buffer_addsba
	DD	imagerel buffer_addsba+209
	DD	imagerel $unwind$buffer_addsba
$pdata$buffer_addsf DD imagerel buffer_addsf
	DD	imagerel buffer_addsf+133
	DD	imagerel $unwind$buffer_addsf
$pdata$build_logo DD imagerel build_logo
	DD	imagerel build_logo+2045
	DD	imagerel $unwind$build_logo
$pdata$init_logo DD imagerel init_logo
	DD	imagerel init_logo+388
	DD	imagerel $unwind$init_logo
$pdata$constty_redrive_pselect DD imagerel constty_redrive_pselect
	DD	imagerel constty_redrive_pselect+309
	DD	imagerel $unwind$constty_redrive_pselect
$pdata$loc3270_redrive_pselect DD imagerel loc3270_redrive_pselect
	DD	imagerel loc3270_redrive_pselect+345
	DD	imagerel $unwind$loc3270_redrive_pselect
$pdata$constty_halt_or_clear DD imagerel constty_halt_or_clear
	DD	imagerel constty_halt_or_clear+24
	DD	imagerel $unwind$constty_halt_or_clear
$pdata$loc3270_halt_or_clear DD imagerel loc3270_halt_or_clear
	DD	imagerel loc3270_halt_or_clear+24
	DD	imagerel $unwind$loc3270_halt_or_clear
$pdata$loc3270_hsuspend DD imagerel loc3270_hsuspend
	DD	imagerel loc3270_hsuspend+481
	DD	imagerel $unwind$loc3270_hsuspend
$pdata$loc3270_hresume DD imagerel loc3270_hresume
	DD	imagerel loc3270_hresume+1425
	DD	imagerel $unwind$loc3270_hresume
$pdata$constty_query_device DD imagerel constty_query_device
	DD	imagerel constty_query_device+1227
	DD	imagerel $unwind$constty_query_device
$pdata$loc3270_query_device DD imagerel loc3270_query_device
	DD	imagerel loc3270_query_device+935
	DD	imagerel $unwind$loc3270_query_device
$pdata$lookup_ttype DD imagerel lookup_ttype
	DD	imagerel lookup_ttype+146
	DD	imagerel $unwind$lookup_ttype
$pdata$recv_3270_data DD imagerel recv_3270_data
	DD	imagerel recv_3270_data+1221
	DD	imagerel $unwind$recv_3270_data
$pdata$recv_1052_data DD imagerel recv_1052_data
	DD	imagerel recv_1052_data+1135
	DD	imagerel $unwind$recv_1052_data
$pdata$connect_client DD imagerel connect_client
	DD	imagerel connect_client+5068
	DD	imagerel $unwind$connect_client
$pdata$calcto DD imagerel calcto
	DD	imagerel calcto+283
	DD	imagerel $unwind$calcto
$pdata$consio DD imagerel consio
	DD	imagerel consio+28
	DD	imagerel $unwind$consio
$pdata$consto DD imagerel consto
	DD	imagerel consto+14
	DD	imagerel $unwind$consto
$pdata$get_listening_socket DD imagerel get_listening_socket
	DD	imagerel get_listening_socket+1294
	DD	imagerel $unwind$get_listening_socket
$pdata$loc3270_execute_ccw DD imagerel loc3270_execute_ccw
	DD	imagerel loc3270_execute_ccw+5156
	DD	imagerel $unwind$loc3270_execute_ccw
$pdata$constty_execute_ccw DD imagerel constty_execute_ccw
	DD	imagerel constty_execute_ccw+2088
	DD	imagerel $unwind$constty_execute_ccw
$pdata$hdl_check_depends_ep DD imagerel $LN15
	DD	imagerel $LN15+152
	DD	imagerel $unwind$hdl_check_depends_ep
$pdata$hdl_define_devtypes_ep DD imagerel $LN3
	DD	imagerel $LN3+104
	DD	imagerel $unwind$hdl_define_devtypes_ep
pdata	ENDS
_DATA	SEGMENT
$SG177265 DB	'SR: sr_write_hdr:    key=0x%8.8x, len=0x%8.8x', 0aH, 00H
	ORG $+1
$SG177267 DB	'SR: sr_write_hdr:    key=0x%8.8x, len=0x%8.8x', 0aH, 00H
	ORG $+1
$SG177307 DB	'SR: sr_write_buf:    key=0x%8.8x, len=0x%16.16llx', 0aH, 00H
	ORG $+1
$SG177459 DB	'E', 00H
	ORG $+2
$SG177309 DB	'SR: sr_write_buf:    key=0x%8.8x, len=0x%16.16llx', 0aH, 00H
	ORG $+5
$SG177353 DB	'SR: sr_read_hdr:   key=0x%8.8x, len=0x%8.8x', 0aH, 00H
	ORG $+3
$SG177370 DB	'SR: sr_read_skip:                  len=0x%8.8x', 0aH, 00H
$SG177406 DB	'SR: sr_read_buf:                   len=0x%16.16llx', 0aH
	DB	00H
	ORG $+4
$SG177331 DB	'SR: sr_write_value:  key=0x%8.8x, len=0x%8.8x, val=0x%16'
	DB	'.16llx', 0aH, 00H
$SG177333 DB	'SR: sr_write_value:  key=0x%8.8x, len=0x%8.8x, val=0x%16'
	DB	'.16llx', 0aH, 00H
$SG177355 DB	'SR: sr_read_hdr:   key=0x%8.8x, len=0x%8.8x', 0aH, 00H
	ORG $+3
$SG177372 DB	'SR: sr_read_skip:                  len=0x%8.8x', 0aH, 00H
$SG177408 DB	'SR: sr_read_buf:                   len=0x%16.16llx', 0aH
	DB	00H
$SG177464 DB	'read()', 00H
	ORG $+5
$SG177440 DB	'SR: sr_read_value:              suslen=0x%8.8x, reslen=0'
	DB	'x%8.8x,', 0aH, 00H
	ORG $+7
$SG177450 DB	'                           val=0x%16.16llx', 0aH, 00H
$SG177465 DB	'E', 00H
	ORG $+2
$SG177458 DB	'write()', 00H
$SG177442 DB	'SR: sr_read_value:              suslen=0x%8.8x, reslen=0'
	DB	'x%8.8x,', 0aH, 00H
	ORG $+3
$SG177476 DB	'E', 00H
	ORG $+2
$SG177452 DB	'                           val=0x%16.16llx', 0aH, 00H
$SG177675 DB	'E', 00H
	ORG $+2
$SG177460 DB	'HHC02001%s SR: error in function %s: %s', 0aH, 00H
	ORG $+3
$SG177689 DB	'TTYPE', 00H
	ORG $+2
$SG177690 DB	'enable', 00H
	ORG $+1
$SG177691 DB	'W', 00H
	ORG $+2
$SG177461 DB	'sr_write_error_', 00H
$SG177462 DB	'C:\papa\MyGit\hyperion-zvector\sr.h', 00H
$SG177698 DB	'W', 00H
	ORG $+2
$SG177466 DB	'HHC02001%s SR: error in function %s: %s', 0aH, 00H
	ORG $+3
$SG177697 DB	'enable', 00H
	ORG $+1
$SG177709 DB	'W', 00H
	ORG $+2
$SG177467 DB	'sr_read_error_', 00H
	ORG $+1
$SG177468 DB	'C:\papa\MyGit\hyperion-zvector\sr.h', 00H
$SG177718 DB	'W', 00H
	ORG $+2
$SG177477 DB	'HHC02020%s SR: value error, incorrect length', 0aH, 00H
	ORG $+2
$SG177478 DB	'sr_value_error_', 00H
$SG177479 DB	'C:\papa\MyGit\hyperion-zvector\sr.h', 00H
$SG177729 DB	'W', 00H
	ORG $+2
?ttype@?BP@??telnet_ev_handler@@9@9 DQ FLAT:$SG177780	; `telnet_ev_handler'::`31'::ttype
herclogo DQ	FLAT:$SG177487
	DQ	FLAT:$SG177488
	DQ	FLAT:$SG177489
	DQ	FLAT:$SG177490
	DQ	FLAT:$SG177491
	DQ	FLAT:$SG177492
	DQ	FLAT:$SG177493
	DQ	FLAT:$SG177494
	DQ	FLAT:$SG177495
	DQ	FLAT:$SG177496
	DQ	FLAT:$SG177497
	DQ	FLAT:$SG177498
	DQ	FLAT:$SG177499
	DQ	FLAT:$SG177500
	DQ	FLAT:$SG177501
	DQ	FLAT:$SG177502
	DQ	FLAT:$SG177503
	DQ	FLAT:$SG177504
	DQ	FLAT:$SG177505
	DQ	FLAT:$SG177506
	DQ	FLAT:$SG177507
	DQ	FLAT:$SG177508
	DQ	FLAT:$SG177509
	DQ	FLAT:$SG177510
	DQ	FLAT:$SG177511
	DQ	FLAT:$SG177512
	DQ	FLAT:$SG177513
	DQ	FLAT:$SG177514
	DQ	FLAT:$SG177515
	DQ	FLAT:$SG177516
	DQ	FLAT:$SG177517
	DQ	FLAT:$SG177518
	DQ	FLAT:$SG177519
	DQ	FLAT:$SG177520
	DQ	FLAT:$SG177521
	DQ	FLAT:$SG177522
	DQ	FLAT:$SG177523
	DQ	FLAT:$SG177524
	DQ	FLAT:$SG177525
	DQ	FLAT:$SG177526
	DQ	FLAT:$SG177527
	DQ	FLAT:$SG177528
	DQ	FLAT:$SG177529
	DQ	FLAT:$SG177530
	DQ	FLAT:$SG177531
	DQ	FLAT:$SG177532
	DQ	FLAT:$SG177533
	DQ	FLAT:$SG177534
	DQ	FLAT:$SG177535
	DQ	FLAT:$SG177536
	DQ	FLAT:$SG177537
	DQ	FLAT:$SG177538
	DQ	FLAT:$SG177539
	DQ	FLAT:$SG177540
	DQ	FLAT:$SG177541
	DQ	FLAT:$SG177542
	DQ	FLAT:$SG177543
	DQ	FLAT:$SG177544
	DQ	FLAT:$SG177545
$SG177676 DB	'HHC02900%s %s COMM: Send() failed: %s', 0aH, 00H
	ORG $+1
$SG177677 DB	'telnet_ev_handler', 00H
	ORG $+2
$SG177747 DB	'enable', 00H
	ORG $+1
$SG177748 DB	'W', 00H
	ORG $+2
$SG177678 DB	'console.c', 00H
	ORG $+2
$SG177755 DB	'enable', 00H
	ORG $+1
$SG177756 DB	'W', 00H
	ORG $+2
$SG177692 DB	'HHC02901%s %s COMM: Refusing client demand to %s %s', 0aH
	DB	00H
	ORG $+3
$SG177693 DB	'telnet_ev_handler', 00H
	ORG $+2
$SG177763 DB	'enable', 00H
	ORG $+1
$SG177764 DB	'W', 00H
	ORG $+2
$SG177694 DB	'console.c', 00H
	ORG $+2
$SG177771 DB	'enable', 00H
	ORG $+1
$SG177772 DB	'W', 00H
	ORG $+2
$SG177699 DB	'HHC02901%s %s COMM: Refusing client demand to %s %s', 0aH
	DB	00H
	ORG $+3
$SG177700 DB	'telnet_ev_handler', 00H
	ORG $+2
$SG177801 DB	'I', 00H
	ORG $+2
$SG177701 DB	'console.c', 00H
	ORG $+2
$SG177807 DB	'W', 00H
	ORG $+2
$SG177707 DB	'BINARY mode', 00H
$SG177811 DB	'W', 00H
	ORG $+2
$SG177708 DB	'disable', 00H
$SG177710 DB	'HHC02901%s %s COMM: Refusing client demand to %s %s', 0aH
	DB	00H
	ORG $+3
$SG177711 DB	'telnet_ev_handler', 00H
	ORG $+2
$SG177817 DB	'I', 00H
	ORG $+2
$SG177712 DB	'console.c', 00H
	ORG $+2
$SG177821 DB	'E', 00H
	ORG $+2
$SG177716 DB	'Suppress Go Aheads', 00H
	ORG $+1
$SG177826 DB	'W', 00H
	ORG $+2
$SG177717 DB	'disable', 00H
$SG177719 DB	'HHC02901%s %s COMM: Refusing client demand to %s %s', 0aH
	DB	00H
	ORG $+3
$SG177720 DB	'telnet_ev_handler', 00H
	ORG $+2
$SG177845 DB	'%s', 00H
	ORG $+1
$SG177721 DB	'console.c', 00H
	ORG $+2
$SG177873 DB	'E', 00H
	ORG $+2
$SG177727 DB	'EOR mode', 00H
	ORG $+3
$SG177762 DB	'TTYPE', 00H
	ORG $+2
$SG177963 DB	'%hx', 00H
$SG177728 DB	'disable', 00H
$SG177730 DB	'HHC02901%s %s COMM: Refusing client demand to %s %s', 0aH
	DB	00H
	ORG $+3
$SG177731 DB	'telnet_ev_handler', 00H
	ORG $+2
$SG177967 DB	'E', 00H
	ORG $+2
$SG177732 DB	'console.c', 00H
	ORG $+2
$SG177979 DB	'E', 00H
	ORG $+2
$SG177746 DB	'BINARY mode', 00H
$SG177986 DB	'E', 00H
	ORG $+2
$SG177749 DB	'HHC02902%s %s COMM: Client refused to %s %s', 0aH, 00H
	ORG $+3
$SG177750 DB	'telnet_ev_handler', 00H
	ORG $+2
$SG177994 DB	'E', 00H
	ORG $+2
$SG177751 DB	'console.c', 00H
	ORG $+2
$SG178004 DB	'E', 00H
	ORG $+2
$SG177754 DB	'Suppress Go Aheads', 00H
	ORG $+1
$SG178009 DB	'E', 00H
	ORG $+2
$SG177757 DB	'HHC02902%s %s COMM: Client refused to %s %s', 0aH, 00H
	ORG $+3
$SG177758 DB	'telnet_ev_handler', 00H
	ORG $+2
$SG178035 DB	'%hx', 00H
$SG177759 DB	'console.c', 00H
	ORG $+2
$SG178043 DB	'E', 00H
	ORG $+2
$SG177765 DB	'HHC02902%s %s COMM: Client refused to %s %s', 0aH, 00H
	ORG $+3
$SG177766 DB	'telnet_ev_handler', 00H
	ORG $+2
$SG178053 DB	'E', 00H
	ORG $+2
$SG177767 DB	'console.c', 00H
	ORG $+2
$SG178058 DB	'E', 00H
	ORG $+2
$SG177770 DB	'EOR mode', 00H
	ORG $+3
$SG177816 DB	'ERROR', 00H
	ORG $+2
$SG178089 DB	'E', 00H
	ORG $+2
$SG177773 DB	'HHC02902%s %s COMM: Client refused to %s %s', 0aH, 00H
	ORG $+3
$SG177774 DB	'telnet_ev_handler', 00H
	ORG $+2
$SG178099 DB	'I', 00H
	ORG $+2
$SG177775 DB	'console.c', 00H
	ORG $+2
$SG178105 DB	'tcp', 00H
$SG177800 DB	'WARNING', 00H
$SG177802 DB	'HHC02907%s %s COMM: Libtelnet %s: %s in %s() at %s(%d): '
	DB	'%s', 0aH, 00H
$SG178108 DB	'I', 00H
	ORG $+2
$SG177803 DB	'telnet_ev_handler', 00H
	ORG $+2
$SG178285 DB	' ', 09H, 00H
	ORG $+1
$SG177804 DB	'console.c', 00H
	ORG $+2
$SG178286 DB	' ', 09H, 00H
	ORG $+1
$SG177808 DB	'HHC02905%s %s COMM: Libtelnet negotiation error', 0aH, 00H
	ORG $+3
$SG178292 DB	',', 00H
	ORG $+2
$SG177809 DB	'telnet_ev_handler', 00H
	ORG $+2
$SG178293 DB	',', 00H
	ORG $+2
$SG177810 DB	'console.c', 00H
	ORG $+2
$SG178300 DB	'@sf', 00H
$SG177812 DB	'HHC02903%s %s COMM: Libtelnet error', 0aH, 00H
	ORG $+3
$SG177813 DB	'telnet_ev_handler', 00H
	ORG $+2
$SG178312 DB	'@nl', 00H
$SG177814 DB	'console.c', 00H
	ORG $+2
$SG178315 DB	'@align', 00H
	ORG $+1
$SG178600 DB	'E', 00H
	ORG $+2
$SG177818 DB	'HHC02907%s %s COMM: Libtelnet %s: %s in %s() at %s(%d): '
	DB	'%s', 0aH, 00H
$SG178632 DB	'CON', 00H
$SG177819 DB	'telnet_ev_handler', 00H
	ORG $+2
$SG178328 DB	'center', 00H
	ORG $+1
$SG178638 DB	'.', 00H
	ORG $+2
$SG177820 DB	'console.c', 00H
	ORG $+2
$SG178416 DB	'%s%c%s', 00H
	ORG $+1
$SG178647 DB	'%s', 00H
	ORG $+1
$SG177822 DB	'HHC02904%s %s COMM: Libtelnet FATAL error', 0aH, 00H
	ORG $+1
$SG178648 DB	'%s', 00H
	ORG $+1
$SG177823 DB	'telnet_ev_handler', 00H
	ORG $+2
$SG178652 DB	' ', 00H
	ORG $+2
$SG177824 DB	'console.c', 00H
	ORG $+2
$SG178685 DB	'DSP', 00H
$SG177827 DB	'HHC02906%s %s COMM: Unsupported libtelnet event ''%s''', 0aH
	DB	00H
	ORG $+2
$SG177828 DB	'telnet_ev_handler', 00H
	ORG $+2
$SG178691 DB	'.', 00H
	ORG $+2
$SG177829 DB	'console.c', 00H
	ORG $+2
$SG178698 DB	'%s', 00H
	ORG $+1
$SG177871 DB	'console.c:720', 00H
	ORG $+2
$SG177872 DB	'console_connect', 00H
$SG177874 DB	'HHC00102%s Error in function create_thread(): %s', 0aH, 00H
	ORG $+2
$SG178699 DB	'%s', 00H
	ORG $+1
$SG177875 DB	'finish_console_init', 00H
$SG178703 DB	' ', 00H
	ORG $+2
$SG177876 DB	'console.c', 00H
	ORG $+2
$SG178768 DB	'E', 00H
	ORG $+2
$SG177910 DB	'console.c:791', 00H
	ORG $+2
$SG177912 DB	'console.c:791', 00H
	ORG $+2
$SG177915 DB	'finish_console_close', 00H
	ORG $+3
$SG177916 DB	'console.c', 00H
	ORG $+6
$SG177917 DB	'%s(%d) : warning HHC90999W : *** Assertion Failed! *** f'
	DB	'unction: %s', 0aH, 00H
	ORG $+3
$SG177919 DB	'finish_console_close', 00H
	ORG $+3
$SG177920 DB	'console.c', 00H
	ORG $+6
$SG177921 DB	'%s(%d) : warning HHC90999W : *** Assertion Failed! *** f'
	DB	'unction: %s', 0aH, 00H
	ORG $+3
$SG177924 DB	'console.c:795', 00H
	ORG $+2
$SG177925 DB	'console.c:797', 00H
	ORG $+2
$SG177926 DB	'console.c:799', 00H
	ORG $+2
?badmask@?BA@??loc3270_init_handler@@9@9 DQ FLAT:$SG178000 ; `loc3270_init_handler'::`16'::badmask
$SG177965 DB	'SYSG', 00H
	ORG $+3
$SG177968 DB	'HHC01025%s %1d:%04X COMM: duplicate SYSG console definit'
	DB	'ion', 0aH, 00H
	ORG $+3
$SG177969 DB	'loc3270_init_handler', 00H
	ORG $+3
$SG177970 DB	'console.c', 00H
	ORG $+6
$SG177980 DB	'HHC01091%s %1d:%04X COMM: %s has an invalid GROUP name l'
	DB	'ength or format; must be a valid luname or poolname', 0aH, 00H
	ORG $+3
$SG177981 DB	'loc3270_init_handler', 00H
	ORG $+3
$SG177982 DB	'console.c', 00H
	ORG $+6
$SG177988 DB	'loc3270_init_handler', 00H
	ORG $+3
$SG177987 DB	'HHC01091%s %1d:%04X COMM: %s has an invalid GROUP name l'
	DB	'ength or format; must be a valid luname or poolname', 0aH, 00H
	ORG $+3
$SG177989 DB	'console.c', 00H
	ORG $+2
$SG178772 DB	'W', 00H
	ORG $+2
$SG177993 DB	'IP address', 00H
	ORG $+1
$SG178788 DB	'W', 00H
	ORG $+2
$SG177995 DB	'HHC01007%s %1d:%04X COMM: option %s value %s invalid', 0aH
	DB	00H
	ORG $+2
$SG177996 DB	'loc3270_init_handler', 00H
	ORG $+3
$SG177997 DB	'console.c', 00H
	ORG $+2
$SG178003 DB	'mask', 00H
	ORG $+3
$SG178325 DB	'right', 00H
	ORG $+2
$SG178794 DB	'E', 00H
	ORG $+2
$SG178005 DB	'HHC01007%s %1d:%04X COMM: option %s value %s invalid', 0aH
	DB	00H
	ORG $+2
$SG178006 DB	'loc3270_init_handler', 00H
	ORG $+3
$SG178007 DB	'console.c', 00H
	ORG $+2
$SG178813 DB	'W', 00H
	ORG $+2
$SG178010 DB	'HHC01019%s %1d:%04X COMM: unrecognized parameter %s', 0aH
	DB	00H
	ORG $+3
$SG178011 DB	'loc3270_init_handler', 00H
	ORG $+3
$SG178012 DB	'console.c', 00H
	ORG $+2
$SG178014 DB	'SYSG', 00H
	ORG $+3
$SG178759 DB	'%hx%c', 00H
	ORG $+2
$SG178820 DB	'E', 00H
	ORG $+2
?badmask@?8??constty_init_handler@@9@9 DQ FLAT:$SG178049 ; `constty_init_handler'::`9'::badmask
$SG178033 DB	'noprompt', 00H
	ORG $+3
$SG178828 DB	'E', 00H
	ORG $+2
$SG178042 DB	'IP address', 00H
	ORG $+1
$SG178846 DB	'I', 00H
	ORG $+2
$SG178044 DB	'HHC01007%s %1d:%04X COMM: option %s value %s invalid', 0aH
	DB	00H
	ORG $+2
$SG178045 DB	'constty_init_handler', 00H
	ORG $+3
$SG178046 DB	'console.c', 00H
	ORG $+2
$SG178052 DB	'mask', 00H
	ORG $+3
$SG178850 DB	'D', 00H
	ORG $+2
$SG178054 DB	'HHC01007%s %1d:%04X COMM: option %s value %s invalid', 0aH
	DB	00H
	ORG $+2
$SG178055 DB	'constty_init_handler', 00H
	ORG $+3
$SG178056 DB	'console.c', 00H
	ORG $+2
$SG178857 DB	'I', 00H
	ORG $+2
$SG178059 DB	'HHC01019%s %1d:%04X COMM: unrecognized parameter %s', 0aH
	DB	00H
	ORG $+3
$SG178060 DB	'constty_init_handler', 00H
	ORG $+3
$SG178061 DB	'console.c', 00H
	ORG $+2
$SG178887 DB	'D', 00H
	ORG $+2
$SG178090 DB	'HHC00152%s Out of memory', 0aH, 00H
	ORG $+2
$SG178894 DB	'I', 00H
	ORG $+2
$SG178091 DB	'parse_sockspec', 00H
	ORG $+1
$SG178092 DB	'console.c', 00H
	ORG $+2
$SG178985 DB	'I', 00H
	ORG $+2
$SG178098 DB	'IP address', 00H
	ORG $+1
$SG178992 DB	'I', 00H
	ORG $+2
$SG178100 DB	'HHC01016%s COMM: unable to determine %s from %s', 0aH, 00H
	ORG $+3
$SG178999 DB	'MP=%d', 00H
	ORG $+2
$SG179002 DB	'UP', 00H
	ORG $+1
$SG178101 DB	'parse_sockspec', 00H
	ORG $+1
$SG178102 DB	'console.c', 00H
	ORG $+2
$SG179004 DB	'I', 00H
	ORG $+2
$SG178107 DB	'port number', 00H
$SG179007 DB	'D', 00H
	ORG $+2
$SG178109 DB	'HHC01016%s COMM: unable to determine %s from %s', 0aH, 00H
	ORG $+3
$SG179015 DB	'E', 00H
	ORG $+2
$SG178110 DB	'parse_sockspec', 00H
	ORG $+1
$SG178111 DB	'console.c', 00H
	ORG $+2
$SG179019 DB	'E', 00H
	ORG $+2
$SG178280 DB	'LOGIC ERROR!', 00H
	ORG $+3
$SG178289 DB	'@sba', 00H
	ORG $+3
$SG178296 DB	'missing @sba ..,X value', 00H
$SG178297 DB	'missing @sba Y,X values', 00H
$SG178309 DB	'unrecognized @sf value: %c', 00H
	ORG $+1
$SG178319 DB	'none', 00H
	ORG $+3
$SG178322 DB	'left', 00H
	ORG $+3
$SG179047 DB	'I', 00H
	ORG $+2
$SG178329 DB	'unrecognized @align value: %s', 00H
	ORG $+2
$SG178330 DB	'unrecognized order: %s', 00H
	ORG $+1
$SG178332 DB	'out of memory', 00H
	ORG $+2
$SG178438 DB	'console.c:1932', 00H
	ORG $+1
$SG178443 DB	'constty_redrive_pselect', 00H
sba_code DB	'@', 0c1H, 0c2H, 0c3H, 0c4H, 0c5H, 0c6H, 0c7H, 0c8H, 0c9H
	DB	'JKLMNOP', 0d1H, 0d2H, 0d3H, 0d4H, 0d5H, 0d6H, 0d7H, 0d8H, 0d9H
	DB	'Z[\]^_`a', 0e2H, 0e3H, 0e4H, 0e5H, 0e6H, 0e7H, 0e8H, 0e9H, 'j'
	DB	'klmno', 0f0H, 0f1H, 0f2H, 0f3H, 0f4H, 0f5H, 0f6H, 0f7H, 0f8H, 0f9H
	DB	'z{|}~', 07fH, 00H
	ORG $+3
$SG179060 DB	'E', 00H
	ORG $+2
$SG178413 DB	'HERCLOGO', 00H
	ORG $+3
$SG179065 DB	'E', 00H
	ORG $+2
$SG178414 DB	'herclogo.txt', 00H
	ORG $+3
$SG178440 DB	'console.c:1932', 00H
	ORG $+1
$SG178444 DB	'console.c', 00H
	ORG $+6
$SG178447 DB	'constty_redrive_pselect', 00H
$SG178445 DB	'%s(%d) : warning HHC90999W : *** Assertion Failed! *** f'
	DB	'unction: %s', 0aH, 00H
	ORG $+3
$SG178448 DB	'console.c', 00H
	ORG $+6
$SG178469 DB	'console.c:1938', 00H
	ORG $+1
$SG178474 DB	'loc3270_redrive_pselect', 00H
$SG178449 DB	'%s(%d) : warning HHC90999W : *** Assertion Failed! *** f'
	DB	'unction: %s', 0aH, 00H
	ORG $+3
$SG178471 DB	'console.c:1938', 00H
	ORG $+1
$SG178475 DB	'console.c', 00H
	ORG $+6
$SG178478 DB	'loc3270_redrive_pselect', 00H
$SG178476 DB	'%s(%d) : warning HHC90999W : *** Assertion Failed! *** f'
	DB	'unction: %s', 0aH, 00H
	ORG $+3
$SG178479 DB	'console.c', 00H
	ORG $+6
$SG178524 DB	'console.c:1974', 00H
	ORG $+1
$SG178601 DB	'HHC01000%s %1d:%04X COMM: error in function %s: %s', 0aH
	DB	00H
	ORG $+4
$SG178480 DB	'%s(%d) : warning HHC90999W : *** Assertion Failed! *** f'
	DB	'unction: %s', 0aH, 00H
	ORG $+3
$SG178527 DB	'console.c:1990', 00H
	ORG $+1
$SG178599 DB	'malloc(%d)', 00H
	ORG $+1
$SG179067 DB	'I', 00H
	ORG $+2
$SG178602 DB	'loc3270_hresume', 00H
$SG178603 DB	'console.c', 00H
	ORG $+2
$SG179069 DB	'%s', 0aH, 00H
$SG178607 DB	'console.c:2053', 00H
	ORG $+1
$SG178608 DB	'console.c:2054', 00H
	ORG $+1
$SG178609 DB	'console.c:2055', 00H
	ORG $+1
$SG178611 DB	'console.c:2064', 00H
	ORG $+1
$SG178612 DB	'console.c:2083', 00H
	ORG $+1
$SG178642 DB	' noprompt', 00H
	ORG $+2
$SG179080 DB	'I', 00H
	ORG $+2
$SG178643 DB	'%s%s IO[%llu]', 00H
	ORG $+2
$SG178649 DB	'%s mask %s', 00H
	ORG $+1
$SG179082 DB	'%s', 0aH, 00H
$SG178654 DB	' noprompt', 00H
	ORG $+2
$SG179094 DB	'CUU', 00H
$SG178656 DB	'GROUP=%s%s%s%s IO[%llu]', 00H
$SG178661 DB	'noprompt %s IO[%llu]', 00H
	ORG $+3
$SG178662 DB	'* %s', 00H
	ORG $+3
$SG178665 DB	'noprompt IO[%llu]', 00H
	ORG $+2
$SG179097 DB	'%d', 00H
	ORG $+1
$SG178666 DB	'IO[%llu]', 00H
	ORG $+3
$SG179090 DB	'%4.4X', 00H
	ORG $+2
$SG179098 DB	'CSS', 00H
$SG178694 DB	'%s IO[%llu]', 00H
$SG179133 DB	'D', 00H
	ORG $+2
$SG178700 DB	'%s mask %s', 00H
	ORG $+1
$SG179177 DB	'E', 00H
	ORG $+2
$SG178705 DB	'GROUP=%s%s%s IO[%llu]', 00H
	ORG $+2
$SG178708 DB	'* %s IO[%llu]', 00H
	ORG $+2
$SG178709 DB	'* IO[%llu]', 00H
	ORG $+1
$SG178762 DB	'IBM-', 00H
	ORG $+7
tttab	DQ	FLAT:$SG178716
	DB	058H
	DB	01H
	ORG $+6
	DQ	FLAT:$SG178717
	DB	032H
	DB	00H
	ORG $+6
	DQ	FLAT:$SG178718
	DB	035H
	DB	00H
	ORG $+6
	DQ	FLAT:$SG178719
	DB	032H
	DB	00H
	ORG $+6
	DQ	FLAT:$SG178720
	DB	032H
	DB	00H
	ORG $+6
	DQ	FLAT:$SG178721
	DB	033H
	DB	00H
	ORG $+6
	DQ	FLAT:$SG178722
	DB	034H
	DB	00H
	ORG $+6
	DQ	FLAT:$SG178723
	DB	035H
	DB	00H
	ORG $+6
	DQ	FLAT:$SG178724
	DB	032H
	DB	01H
	ORG $+6
	DQ	FLAT:$SG178725
	DB	033H
	DB	01H
	ORG $+6
	DQ	FLAT:$SG178726
	DB	034H
	DB	01H
	ORG $+6
	DQ	FLAT:$SG178727
	DB	035H
	DB	01H
	ORG $+6
	DQ	FLAT:$SG178728
	DB	032H
	DB	00H
	ORG $+6
	DQ	FLAT:$SG178729
	DB	033H
	DB	00H
	ORG $+6
	DQ	FLAT:$SG178730
	DB	034H
	DB	00H
	ORG $+6
	DQ	FLAT:$SG178731
	DB	035H
	DB	00H
	ORG $+6
	DQ	FLAT:$SG178732
	DB	032H
	DB	01H
	ORG $+6
	DQ	FLAT:$SG178733
	DB	033H
	DB	01H
	ORG $+6
	DQ	FLAT:$SG178734
	DB	034H
	DB	01H
	ORG $+6
	DQ	FLAT:$SG178735
	DB	035H
	DB	01H
	ORG $+6
$SG178765 DB	'IBM-3287-1', 00H
	ORG $+1
$SG179183 DB	'E', 00H
	ORG $+2
$SG178769 DB	'HHC02916%s %s COMM: No acceptable terminal types', 0aH, 00H
	ORG $+2
$SG179135 DB	'calcto', 00H
	ORG $+1
$SG179189 DB	'E', 00H
	ORG $+2
$SG178770 DB	'negotiate_ttype', 00H
$SG178771 DB	'console.c', 00H
	ORG $+2
$SG179195 DB	'W', 00H
	ORG $+2
$SG178773 DB	'HHC02910%s %s COMM: Unsupported terminal type: %s', 0aH, 00H
	ORG $+1
$SG179202 DB	'E', 00H
	ORG $+2
$SG178774 DB	'negotiate_ttype', 00H
$SG178775 DB	'console.c', 00H
	ORG $+2
$SG179201 DB	'bind()', 00H
	ORG $+1
$SG179208 DB	'E', 00H
	ORG $+2
$SG178789 DB	'HHC02911%s %s COMM: Discarding premature data', 0aH, 00H
	ORG $+1
$SG178790 DB	'loc3270_input', 00H
	ORG $+2
$SG178791 DB	'console.c', 00H
	ORG $+2
$SG179212 DB	'I', 00H
	ORG $+2
$SG178793 DB	'%1d:%04X', 00H
	ORG $+3
$SG179093 DB	'%3.3X', 00H
	ORG $+2
?issue_errmsg@?BM@??console_connection_handler@@9@9 DD 01H ; `console_connection_handler'::`28'::issue_errmsg
$SG178795 DB	'HHC02912%s %s COMM: Buffer overflow', 0aH, 00H
	ORG $+3
$SG178796 DB	'loc3270_input', 00H
	ORG $+2
$SG178797 DB	'console.c', 00H
	ORG $+2
?issue_errmsg@?CD@??console_connection_handler@@9@9 DD 01H ; `console_connection_handler'::`35'::issue_errmsg
$SG178814 DB	'HHC02911%s %s COMM: Discarding premature data', 0aH, 00H
	ORG $+1
$SG178815 DB	'constty_input', 00H
	ORG $+2
$SG178816 DB	'console.c', 00H
	ORG $+2
$SG179332 DB	'I', 00H
	ORG $+2
$SG178819 DB	'%1d:%04X', 00H
	ORG $+3
$SG179095 DB	'%4.4X', 00H
	ORG $+2
$SG179396 DB	'D', 00H
	ORG $+2
$SG178821 DB	'HHC02912%s %s COMM: Buffer overflow', 0aH, 00H
	ORG $+3
$SG178822 DB	'constty_input', 00H
	ORG $+2
$SG178823 DB	'console.c', 00H
	ORG $+2
$SG179411 DB	'D', 00H
	ORG $+2
$SG178827 DB	'%1d:%04X', 00H
	ORG $+3
$SG179340 DB	'SYSG ', 00H
	ORG $+2
$SG179417 DB	'E', 00H
	ORG $+2
$SG178829 DB	'HHC02913%s %s COMM: Buffer overrun', 0aH, 00H
$SG179424 DB	'E', 00H
	ORG $+2
$SG178830 DB	'constty_input', 00H
	ORG $+2
$SG178831 DB	'console.c', 00H
	ORG $+6
$SG178847 DB	'HHC01090%s %1d:%04X COMM: client %s devtype %4.4X: conne'
	DB	'ction reset', 0aH, 00H
	ORG $+3
$SG178848 DB	'recv_3270_data', 00H
	ORG $+1
$SG178849 DB	'console.c', 00H
	ORG $+2
$SG179431 DB	'E', 00H
	ORG $+2
$SG178851 DB	'HHC90507%s %s COMM: recv() failed: %s', 0aH, 00H
	ORG $+1
$SG178852 DB	'recv_3270_data', 00H
	ORG $+1
$SG178853 DB	'console.c', 00H
	ORG $+6
$SG178858 DB	'HHC01022%s %1d:%04X COMM: client %s devtype %4.4X: conne'
	DB	'ction closed by client', 0aH, 00H
$SG178859 DB	'recv_3270_data', 00H
	ORG $+1
$SG178860 DB	'console.c', 00H
	ORG $+2
$SG179468 DB	'I', 00H
	ORG $+2
$SG178888 DB	'HHC90507%s %s COMM: recv() failed: %s', 0aH, 00H
	ORG $+1
$SG178889 DB	'recv_1052_data', 00H
	ORG $+1
$SG178890 DB	'console.c', 00H
	ORG $+6
$SG178896 DB	'recv_1052_data', 00H
	ORG $+1
$SG178991 DB	'4.6.0.10893-SDL-DEV-g5b56a850-modified', 00H
	ORG $+1
$SG178895 DB	'HHC01022%s %1d:%04X COMM: client %s devtype %4.4X: conne'
	DB	'ction closed by client', 0aH, 00H
$SG178897 DB	'console.c', 00H
	ORG $+2
?bell@?BG@??constty_execute_ccw@@9@9 DB 07H		; `constty_execute_ccw'::`22'::bell
	DB	00H
	ORG $+2
$SG178986 DB	'HHC02915%s %s COMM: Connection received', 0aH, 00H
	ORG $+3
$SG179349 DB	'SYSG ', 00H
	ORG $+2
$SG179697 DB	'A', 00H
	ORG $+2
$SG178987 DB	'connect_client', 00H
	ORG $+1
$SG178988 DB	'console.c', 00H
	ORG $+2
$SG179768 DB	'DEVBLK', 00H
	ORG $+5
$SG178989 DB	'19:16:33', 00H
	ORG $+7
$SG178990 DB	'Feb  6 2023', 00H
	ORG $+4
$SG178993 DB	'HHC01027%s Hercules version %s, built on %s %s', 00H
	ORG $+1
$SG178996 DB	'LP=%d, Cores=%d, CPUs=%d', 00H
	ORG $+7
$SG179005 DB	'HHC01031%s Running on %s (%s-%s.%s %s %s)', 00H
	ORG $+6
$SG179008 DB	'HHC90510%s %s COMM: setsockopt() failed: %s', 0aH, 00H
	ORG $+3
$SG179009 DB	'connect_client', 00H
	ORG $+1
$SG179010 DB	'console.c', 00H
	ORG $+6
$SG179016 DB	'HHC02908%s %s COMM: Connection closed during negotiation'
	DB	's', 0aH, 00H
	ORG $+5
$SG179017 DB	'connect_client', 00H
	ORG $+1
$SG179018 DB	'console.c', 00H
	ORG $+6
$SG179020 DB	'HHC02909%s %s COMM: Recv() error during negotiations: %s'
	DB	0aH, 00H
	ORG $+6
$SG179021 DB	'connect_client', 00H
	ORG $+1
$SG179022 DB	'console.c', 00H
	ORG $+6
$SG179040 DB	'console.c:3048', 00H
	ORG $+1
$SG179042 DB	'console.c:3054', 00H
	ORG $+1
$SG179044 DB	'console.c:3061', 00H
	ORG $+1
$SG179046 DB	'%1d:%04X', 00H
	ORG $+7
$SG179048 DB	'HHC02914%s %s COMM: %s negotiations complete; ttype = '''
	DB	'%s''', 0aH, 00H
	ORG $+4
$SG179049 DB	'connect_client', 00H
	ORG $+1
$SG179050 DB	'console.c', 00H
	ORG $+6
$SG179051 DB	'console.c:3097', 00H
	ORG $+1
$SG179057 DB	'3270', 00H
	ORG $+3
$SG179058 DB	'3287', 00H
	ORG $+3
$SG179059 DB	'1052 or 3215', 00H
	ORG $+3
$SG179061 DB	'HHC01028%s Connection rejected, no available %s device', 00H
	ORG $+1
$SG179062 DB	'3270', 00H
	ORG $+3
$SG179063 DB	'3287', 00H
	ORG $+3
$SG179064 DB	'1052 or 3215', 00H
	ORG $+3
$SG179068 DB	'HHC01030%s Connection rejected, device %04X unavailable', 00H
$SG179066 DB	'HHC01029%s Connection rejected, no available %s device i'
	DB	'n the %s group', 00H
	ORG $+1
$SG179070 DB	'connect_client', 00H
	ORG $+1
$SG179071 DB	'console.c', 00H
	ORG $+6
$SG179074 DB	0f5H, '@', 011H, '@@', 01dH, '`%s', 011H, 0c1H, 'P', 01dH
	DB	'`%s', 011H, 0c2H, '`', 01dH, '`%s', 00H
$SG179076 DB	'%s', 0aH, '%s', 0aH, '%s', 0aH, 00H
	ORG $+6
$SG179081 DB	'HHC01018%s %1d:%04X COMM: client %s devtype %4.4X: conne'
	DB	'cted', 00H
	ORG $+3
$SG179083 DB	'connect_client', 00H
	ORG $+1
$SG179084 DB	'console.c', 00H
	ORG $+2
$SG179089 DB	'SYSG', 00H
	ORG $+3
$SG179091 DB	'DEVN', 00H
	ORG $+3
$SG179092 DB	'CCUU', 00H
	ORG $+7
$SG179096 DB	'SUBCHAN', 00H
$SG179102 DB	'%s', 0aH, '%s', 0aH, '%s', 0aH, 00H
	ORG $+6
$SG179106 DB	'console.c:3259', 00H
	ORG $+1
$SG179108 DB	'console.c:3259', 00H
	ORG $+1
$SG179111 DB	'connect_client', 00H
	ORG $+1
$SG179112 DB	'console.c', 00H
	ORG $+6
$SG179113 DB	'%s(%d) : warning HHC90999W : *** Assertion Failed! *** f'
	DB	'unction: %s', 0aH, 00H
	ORG $+3
$SG179115 DB	'connect_client', 00H
	ORG $+1
$SG179116 DB	'console.c', 00H
	ORG $+6
$SG179131 DB	'slow to FAST', 00H
	ORG $+3
$SG179179 DB	'get_listening_socket', 00H
	ORG $+3
$SG179117 DB	'%s(%d) : warning HHC90999W : *** Assertion Failed! *** f'
	DB	'unction: %s', 0aH, 00H
	ORG $+3
$SG179132 DB	'FAST to slow', 00H
	ORG $+3
$SG179134 DB	'HHC02917%s COMM: Switching from %s polling', 0aH, 00H
	ORG $+4
$SG179136 DB	'console.c', 00H
	ORG $+6
$SG179176 DB	'socket()', 00H
	ORG $+7
$SG179178 DB	'HHC01034%s COMM: error in function %s: %s', 0aH, 00H
	ORG $+5
$SG179180 DB	'console.c', 00H
	ORG $+6
$SG179182 DB	'setsockopt()', 00H
	ORG $+3
$SG179184 DB	'HHC01034%s COMM: error in function %s: %s', 0aH, 00H
	ORG $+5
$SG179185 DB	'get_listening_socket', 00H
	ORG $+3
$SG179186 DB	'console.c', 00H
	ORG $+6
$SG179188 DB	'%s = %s', 00H
$SG179190 DB	'HHC01017%s COMM: invalid parameter %s', 0aH, 00H
	ORG $+1
$SG179191 DB	'get_listening_socket', 00H
	ORG $+3
$SG179192 DB	'console.c', 00H
	ORG $+6
$SG179197 DB	'get_listening_socket', 00H
	ORG $+3
$SG179196 DB	'HHC01023%s Waiting for port %u to become free for consol'
	DB	'e connections', 0aH, 00H
	ORG $+1
$SG179198 DB	'console.c', 00H
	ORG $+6
$SG179203 DB	'HHC01034%s COMM: error in function %s: %s', 0aH, 00H
	ORG $+5
$SG179204 DB	'get_listening_socket', 00H
	ORG $+3
$SG179205 DB	'console.c', 00H
	ORG $+6
$SG179207 DB	'listen()', 00H
	ORG $+7
$SG179209 DB	'HHC01034%s COMM: error in function %s: %s', 0aH, 00H
	ORG $+5
$SG179210 DB	'get_listening_socket', 00H
	ORG $+3
$SG179211 DB	'console.c', 00H
	ORG $+6
$SG179213 DB	'HHC01024%s Waiting for %sconsole connections on port %u', 0aH
	DB	00H
	ORG $+7
$SG179214 DB	'get_listening_socket', 00H
	ORG $+3
$SG179215 DB	'console.c', 00H
	ORG $+6
$SG179329 DB	'console.c:3409', 00H
	ORG $+1
$SG179330 DB	'console_connect', 00H
$SG179331 DB	'console.c:3412', 00H
	ORG $+1
$SG179333 DB	'HHC00100%s Thread id %8.8x, prio %d, name ''%s'' started'
	DB	0aH, 00H
$SG179334 DB	'console_connection_handler', 00H
	ORG $+5
$SG179335 DB	'console.c', 00H
	ORG $+6
$SG179338 DB	'CNSLPORT', 00H
	ORG $+7
$SG179341 DB	'SYSGPORT', 00H
	ORG $+7
$SG179344 DB	'CNSLPORT', 00H
	ORG $+7
$SG179350 DB	'SYSGPORT', 00H
	ORG $+7
$SG179355 DB	'console.c:3500', 00H
	ORG $+1
$SG179357 DB	'console.c:3521', 00H
	ORG $+1
$SG179360 DB	'console_connection_handler', 00H
	ORG $+5
$SG179361 DB	'console.c', 00H
	ORG $+6
$SG179364 DB	'console_connection_handler', 00H
	ORG $+5
$SG179371 DB	'console.c:3544', 00H
	ORG $+1
$SG179397 DB	'HHC90508%s COMM: pselect() failed: %s', 0aH, 00H
	ORG $+1
$SG179362 DB	'%s(%d) : warning HHC90999W : *** Assertion Failed! *** f'
	DB	'unction: %s', 0aH, 00H
	ORG $+3
$SG179365 DB	'console.c', 00H
	ORG $+6
$SG179375 DB	'console.c:3584', 00H
	ORG $+1
$SG179412 DB	'HHC90509%s COMM: accept() failed: %s', 0aH, 00H
	ORG $+2
$SG179366 DB	'%s(%d) : warning HHC90999W : *** Assertion Failed! *** f'
	DB	'unction: %s', 0aH, 00H
	ORG $+3
$SG179374 DB	'console.c', 00H
	ORG $+6
$SG179377 DB	'console.c:3584', 00H
	ORG $+1
$SG179380 DB	'console_connection_handler', 00H
	ORG $+5
$SG179381 DB	'console.c', 00H
	ORG $+6
$SG179384 DB	'console_connection_handler', 00H
	ORG $+5
$SG179428 DB	'console.c:3734', 00H
	ORG $+1
$SG179432 DB	'HHC00102%s Error in function create_thread(): %s', 0aH, 00H
	ORG $+6
$SG179382 DB	'%s(%d) : warning HHC90999W : *** Assertion Failed! *** f'
	DB	'unction: %s', 0aH, 00H
	ORG $+3
$SG179385 DB	'console.c', 00H
	ORG $+6
$SG179398 DB	'console_connection_handler', 00H
	ORG $+5
$SG179429 DB	'connect_client', 00H
	ORG $+1
$SG179466 DB	'console_connect', 00H
$SG179469 DB	'HHC00101%s Thread id %8.8x, prio %d, name ''%s'' ended', 0aH
	DB	00H
	ORG $+2
$SG179386 DB	'%s(%d) : warning HHC90999W : *** Assertion Failed! *** f'
	DB	'unction: %s', 0aH, 00H
	ORG $+3
$SG179399 DB	'console.c', 00H
	ORG $+6
$SG179413 DB	'console_connection_handler', 00H
	ORG $+5
$SG179414 DB	'console.c', 00H
	ORG $+6
$SG179418 DB	'HHC00152%s Out of memory', 0aH, 00H
	ORG $+6
$SG179419 DB	'console_connection_handler', 00H
	ORG $+5
$SG179420 DB	'console.c', 00H
	ORG $+6
$SG179421 DB	'client %u', 00H
	ORG $+6
$SG179425 DB	'HHC00152%s Out of memory', 0aH, 00H
	ORG $+6
$SG179426 DB	'console_connection_handler', 00H
	ORG $+5
$SG179427 DB	'console.c', 00H
	ORG $+6
$SG179433 DB	'console_connection_handler', 00H
	ORG $+5
$SG179434 DB	'console.c', 00H
	ORG $+6
$SG179438 DB	'console.c:3773', 00H
	ORG $+1
$SG179440 DB	'console.c:3794', 00H
	ORG $+1
$SG179444 DB	'console.c:3811', 00H
	ORG $+1
$SG179450 DB	'console.c:3855', 00H
	ORG $+1
$SG179451 DB	'console.c:3860', 00H
	ORG $+1
$SG179458 DB	'console.c:3912', 00H
	ORG $+1
$SG179460 DB	'console.c:3933', 00H
	ORG $+1
$SG179462 DB	'console.c:3945', 00H
	ORG $+1
$SG179467 DB	'console.c:3967', 00H
	ORG $+1
$SG179470 DB	'console_connection_handler', 00H
	ORG $+5
$SG179471 DB	'console.c', 00H
	ORG $+6
$SG179562 DB	'console.c:4187', 00H
	ORG $+1
$SG179567 DB	'console.c:4204', 00H
	ORG $+1
$SG179574 DB	'console.c:4271', 00H
	ORG $+1
$SG179575 DB	'console.c:4274', 00H
	ORG $+1
$SG179577 DB	'console.c:4274', 00H
	ORG $+1
$SG179580 DB	'loc3270_execute_ccw', 00H
	ORG $+4
$SG179581 DB	'console.c', 00H
	ORG $+6
$SG179582 DB	'%s(%d) : warning HHC90999W : *** Assertion Failed! *** f'
	DB	'unction: %s', 0aH, 00H
	ORG $+3
$SG179584 DB	'loc3270_execute_ccw', 00H
	ORG $+4
$SG179585 DB	'console.c', 00H
	ORG $+6
$SG179586 DB	'%s(%d) : warning HHC90999W : *** Assertion Failed! *** f'
	DB	'unction: %s', 0aH, 00H
	ORG $+3
$SG179589 DB	'console.c:4283', 00H
	ORG $+1
$SG179594 DB	'console.c:4306', 00H
	ORG $+1
$SG179601 DB	'console.c:4372', 00H
	ORG $+1
$SG179602 DB	'console.c:4375', 00H
	ORG $+1
$SG179604 DB	'console.c:4375', 00H
	ORG $+1
$SG179607 DB	'loc3270_execute_ccw', 00H
	ORG $+4
$SG179608 DB	'console.c', 00H
	ORG $+6
$SG179609 DB	'%s(%d) : warning HHC90999W : *** Assertion Failed! *** f'
	DB	'unction: %s', 0aH, 00H
	ORG $+3
$SG179611 DB	'loc3270_execute_ccw', 00H
	ORG $+4
$SG179612 DB	'console.c', 00H
	ORG $+6
$SG179613 DB	'%s(%d) : warning HHC90999W : *** Assertion Failed! *** f'
	DB	'unction: %s', 0aH, 00H
	ORG $+3
$SG179682 DB	'constty_execute_ccw', 00H
	ORG $+4
$SG179683 DB	'console.c', 00H
	ORG $+6
$SG179684 DB	'%s(%d) : warning HHC90999W : *** Assertion Failed! *** f'
	DB	'unction: %s', 0aH, 00H
	ORG $+3
$SG179686 DB	'constty_execute_ccw', 00H
	ORG $+4
$SG179687 DB	'console.c', 00H
	ORG $+6
$SG179688 DB	'%s(%d) : warning HHC90999W : *** Assertion Failed! *** f'
	DB	'unction: %s', 0aH, 00H
	ORG $+3
$SG179698 DB	'HHC01026%s %1d:%04X COMM: enter console input', 0aH, 00H
	ORG $+1
$SG179770 DB	'SDL 4.2', 00H
constty_device_hndinfo DQ FLAT:constty_init_handler
	DQ	FLAT:constty_execute_ccw
	DQ	FLAT:constty_close_device
	DQ	FLAT:constty_query_device
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	FLAT:constty_redrive_pselect
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	FLAT:constty_halt_or_clear
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	FLAT:constty_immed
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
$SG179771 DB	'SYSBLK', 00H
	ORG $+1
loc3270_device_hndinfo DQ FLAT:loc3270_init_handler
	DQ	FLAT:loc3270_execute_ccw
	DQ	FLAT:loc3270_close_device
	DQ	FLAT:loc3270_query_device
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	FLAT:loc3270_redrive_pselect
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	FLAT:loc3270_halt_or_clear
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	FLAT:loc3270_immed
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	FLAT:loc3270_hsuspend
	DQ	FLAT:loc3270_hresume
$SG179764 DB	'SDL 4.60', 00H
	ORG $+7
$SG179765 DB	'HERCULES', 00H
	ORG $+7
$SG179767 DB	'SDL 4.00', 00H
	ORG $+3
$SG179776 DB	'1052', 00H
	ORG $+3
$SG179777 DB	'3215', 00H
	ORG $+3
$SG179778 DB	'3270', 00H
	ORG $+3
$SG179779 DB	'3287', 00H
	ORG $+3
$SG179780 DB	'SYSG', 00H
_DATA	ENDS
voltbl	SEGMENT
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:loc3270_execute_ccw
	DD	02cH
	DD	012e5H
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:get_listening_socket
	DD	020H
	DD	04f6H
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:connect_client
	DD	017H
	DD	013b3H
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:recv_1052_data
	DD	016H
	DD	0457H
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:recv_3270_data
	DD	01cH
	DD	04adH
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:loc3270_query_device
	DD	025H
	DD	038fH
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:constty_query_device
	DD	025H
	DD	04b3H
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:loc3270_hresume
	DD	023H
	DD	0577H
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:loc3270_hsuspend
	DD	023H
	DD	01c7H
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:init_logo
	DD	013H
	DD	016bH
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:build_logo
	DD	025H
	DD	07a0H
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:constty_init_handler
	DD	020H
	DD	072cH
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:loc3270_init_handler
	DD	020H
	DD	0adfH
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:constty_input
	DD	020H
	DD	0422H
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:loc3270_input
	DD	022H
	DD	0232H
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:console_connection_handler
	DD	01cH
	DD	01292H
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:sr_read_skip
	DD	01aH
	DD	0e0H
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:sr_read_value
	DD	021H
	DD	023aH
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:sr_read_hdr
	DD	01dH
	DD	0cbH
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:sr_write_value
	DD	021H
	DD	0168H
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:sr_write_hdr
	DD	01cH
	DD	0b5H
voltbl	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$fetch_dw_noswap DD 010901H
	DD	02209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$fetch_fw_noswap DD 010901H
	DD	02209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$fetch_hw_noswap DD 010901H
	DD	02209H
xdata	ENDS
xdata	SEGMENT
$unwind$DebuggerTrace DD 011801H
	DD	0a218H
$unwind$strupper DD 010e01H
	DD	0620eH
$unwind$sr_write_hdr DD 012119H
	DD	06212H
	DD	imagerel __GSHandlerCheck
	DD	028H
$unwind$sr_write_value DD 012619H
	DD	08217H
	DD	imagerel __GSHandlerCheck
	DD	030H
$unwind$sr_write_buf DD 011701H
	DD	08217H
$unwind$sr_read_hdr DD 012219H
	DD	06213H
	DD	imagerel __GSHandlerCheck
	DD	028H
$unwind$sr_read_value DD 012619H
	DD	0c217H
	DD	imagerel __GSHandlerCheck
	DD	058H
$unwind$sr_read_buf DD 011301H
	DD	08213H
$unwind$sr_read_skip DD 022219H
	DD	02b0110H
	DD	imagerel __GSHandlerCheck
	DD	0140H
$unwind$sr_write_error_ DD 010401H
	DD	0c204H
$unwind$sr_read_error_ DD 010401H
	DD	0c204H
$unwind$sr_value_error_ DD 010401H
	DD	08204H
$unwind$console_connection_handler DD 022419H
	DD	04270112H
	DD	imagerel __GSHandlerCheck
	DD	02120H
$unwind$solicit_3270_data DD 010d01H
	DD	0620dH
$unwind$loc3270_input DD 042a19H
	DD	0130118H
	DD	060107011H
	DD	imagerel __GSHandlerCheck
	DD	080H
$unwind$constty_input DD 022819H
	DD	0170116H
	DD	imagerel __GSHandlerCheck
	DD	0a8H
$unwind$negotiate_ttype DD 020c01H
	DD	011010cH
$unwind$telnet_ev_handler DD 021601H
	DD	0270116H
$unwind$sendto_client DD 011301H
	DD	06213H
$unwind$raise_device_attention DD 010d01H
	DD	0620dH
$unwind$finish_console_init DD 010901H
	DD	0a209H
$unwind$disconnect_telnet_client DD 010901H
	DD	04209H
$unwind$disconnect_console_device DD 010901H
	DD	04209H
$unwind$finish_console_close DD 010901H
	DD	06209H
$unwind$loc3270_close_device DD 010901H
	DD	04209H
$unwind$constty_close_device DD 010901H
	DD	04209H
$unwind$loc3270_init_handler DD 032819H
	DD	0200116H
	DD	0700fH
	DD	imagerel __GSHandlerCheck
	DD	0f0H
$unwind$constty_init_handler DD 032819H
	DD	0160116H
	DD	0700fH
	DD	imagerel __GSHandlerCheck
	DD	0a8H
$unwind$parse_sockspec DD 020c01H
	DD	011010cH
$unwind$next_3270_pos DD 011301H
	DD	02213H
$unwind$end_of_buf_pos DD 011201H
	DD	06212H
$unwind$pos_to_buff_offset DD 011201H
	DD	06212H
$unwind$buffer_addchar DD 011801H
	DD	06218H
$unwind$buffer_addstring DD 011801H
	DD	06218H
$unwind$buffer_addsba DD 011801H
	DD	06218H
$unwind$buffer_addsf DD 011801H
	DD	04218H
$unwind$build_logo DD 022d19H
	DD	027011bH
	DD	imagerel __GSHandlerCheck
	DD	0120H
$unwind$init_logo DD 031b19H
	DD	0700109H
	DD	07002H
	DD	imagerel __GSHandlerCheck
	DD	0370H
$unwind$constty_redrive_pselect DD 010901H
	DD	06209H
$unwind$loc3270_redrive_pselect DD 010901H
	DD	06209H
$unwind$constty_halt_or_clear DD 010901H
	DD	04209H
$unwind$loc3270_halt_or_clear DD 010901H
	DD	04209H
$unwind$loc3270_hsuspend DD 042b19H
	DD	020090119H
	DD	0600b700cH
	DD	imagerel __GSHandlerCheck
	DD	010030H
$unwind$loc3270_hresume DD 042b19H
	DD	0201f0119H
	DD	0600b700cH
	DD	imagerel __GSHandlerCheck
	DD	0100e0H
$unwind$constty_query_device DD 022d19H
	DD	043011bH
	DD	imagerel __GSHandlerCheck
	DD	0200H
$unwind$loc3270_query_device DD 022d19H
	DD	041011bH
	DD	imagerel __GSHandlerCheck
	DD	01f0H
$unwind$lookup_ttype DD 011301H
	DD	06213H
$unwind$recv_3270_data DD 022419H
	DD	020170112H
	DD	imagerel __GSHandlerCheck
	DD	0100a0H
$unwind$recv_1052_data DD 021e19H
	DD	029010cH
	DD	imagerel __GSHandlerCheck
	DD	0130H
$unwind$connect_client DD 031f19H
	DD	01be010dH
	DD	07006H
	DD	imagerel __GSHandlerCheck
	DD	0de0H
$unwind$calcto DD 010401H
	DD	0c204H
$unwind$consio DD 010401H
	DD	04204H
$unwind$consto DD 010401H
	DD	04204H
$unwind$get_listening_socket DD 022819H
	DD	01f0116H
	DD	imagerel __GSHandlerCheck
	DD	0e0H
$unwind$loc3270_execute_ccw DD 043419H
	DD	020190122H
	DD	060147015H
	DD	imagerel __GSHandlerCheck
	DD	0100b0H
$unwind$constty_execute_ccw DD 031901H
	DD	07015c219H
	DD	06014H
$unwind$hdl_check_depends_ep DD 010901H
	DD	06209H
$unwind$hdl_define_devtypes_ep DD 010901H
	DD	04209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$sscanf DD 011801H
	DD	06218H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$_vsscanf_l DD 011801H
	DD	06218H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$_vsnprintf_s DD 011801H
	DD	06218H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$_vsnprintf_s_l DD 011801H
	DD	0a218H
xdata	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\console.c
_TEXT	SEGMENT
defdev$ = 48
hdl_define_devtypes_ep PROC

; 4758 : HDL_DEVICE_SECTION

$LN3:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 4759 : {
; 4760 :     HDL_DEVICE( 1052, constty_device_hndinfo );

  00009	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:constty_device_hndinfo
  00010	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG179776
  00017	ff 54 24 30	 call	 QWORD PTR defdev$[rsp]

; 4761 :     HDL_DEVICE( 3215, constty_device_hndinfo );

  0001b	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:constty_device_hndinfo
  00022	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG179777
  00029	ff 54 24 30	 call	 QWORD PTR defdev$[rsp]

; 4762 :     HDL_DEVICE( 3270, loc3270_device_hndinfo );

  0002d	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:loc3270_device_hndinfo
  00034	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG179778
  0003b	ff 54 24 30	 call	 QWORD PTR defdev$[rsp]

; 4763 :     HDL_DEVICE( 3287, loc3270_device_hndinfo );

  0003f	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:loc3270_device_hndinfo
  00046	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG179779
  0004d	ff 54 24 30	 call	 QWORD PTR defdev$[rsp]

; 4764 : 
; 4765 : #if defined(_FEATURE_INTEGRATED_3270_CONSOLE)
; 4766 :     HDL_DEVICE( SYSG, loc3270_device_hndinfo );

  00051	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:loc3270_device_hndinfo
  00058	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG179780
  0005f	ff 54 24 30	 call	 QWORD PTR defdev$[rsp]

; 4767 : #endif
; 4768 : 
; 4769 : }
; 4770 : END_DEVICE_SECTION

  00063	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00067	c3		 ret	 0
hdl_define_devtypes_ep ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\console.c
_TEXT	SEGMENT
depchk_rc$ = 32
depchk$ = 64
hdl_check_depends_ep PROC

; 4739 : HDL_DEPENDENCY_SECTION;

$LN15:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 38	 sub	 rsp, 56			; 00000038H
  00009	c7 44 24 20 00
	00 00 00	 mov	 DWORD PTR depchk_rc$[rsp], 0
$LN4@hdl_check_:

; 4740 : {
; 4741 :     HDL_DEPENDENCY( HERCULES );

  00011	41 b8 08 00 00
	00		 mov	 r8d, 8
  00017	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG179764
  0001e	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG179765
  00025	ff 54 24 40	 call	 QWORD PTR depchk$[rsp]
  00029	85 c0		 test	 eax, eax
  0002b	74 08		 je	 SHORT $LN11@hdl_check_
  0002d	c7 44 24 20 01
	00 00 00	 mov	 DWORD PTR depchk_rc$[rsp], 1
$LN11@hdl_check_:
  00035	33 c0		 xor	 eax, eax
  00037	85 c0		 test	 eax, eax
  00039	75 d6		 jne	 SHORT $LN4@hdl_check_
$LN7@hdl_check_:

; 4742 :     HDL_DEPENDENCY( DEVBLK );

  0003b	41 b8 a0 1b 00
	00		 mov	 r8d, 7072		; 00001ba0H
  00041	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG179767
  00048	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG179768
  0004f	ff 54 24 40	 call	 QWORD PTR depchk$[rsp]
  00053	85 c0		 test	 eax, eax
  00055	74 08		 je	 SHORT $LN12@hdl_check_
  00057	c7 44 24 20 01
	00 00 00	 mov	 DWORD PTR depchk_rc$[rsp], 1
$LN12@hdl_check_:
  0005f	33 c0		 xor	 eax, eax
  00061	85 c0		 test	 eax, eax
  00063	75 d6		 jne	 SHORT $LN7@hdl_check_
$LN10@hdl_check_:

; 4743 :     HDL_DEPENDENCY( SYSBLK );

  00065	41 b8 00 76 01
	00		 mov	 r8d, 95744		; 00017600H
  0006b	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG179770
  00072	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG179771
  00079	ff 54 24 40	 call	 QWORD PTR depchk$[rsp]
  0007d	85 c0		 test	 eax, eax
  0007f	74 08		 je	 SHORT $LN13@hdl_check_
  00081	c7 44 24 20 01
	00 00 00	 mov	 DWORD PTR depchk_rc$[rsp], 1
$LN13@hdl_check_:
  00089	33 c0		 xor	 eax, eax
  0008b	85 c0		 test	 eax, eax
  0008d	75 d6		 jne	 SHORT $LN10@hdl_check_

; 4744 : }
; 4745 : END_DEPENDENCY_SECTION

  0008f	8b 44 24 20	 mov	 eax, DWORD PTR depchk_rc$[rsp]
  00093	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00097	c3		 ret	 0
hdl_check_depends_ep ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\console.c
_TEXT	SEGMENT
len$ = 48
_stat64$ = 52
num$ = 56
c$ = 60
tv78 = 64
bufsize$1 = 68
tv82 = 72
tv173 = 76
tv179 = 80
tv214 = 84
tv253 = 88
tv272 = 92
dev$ = 128
code$ = 136
flags$ = 144
chained$ = 152
count$ = 160
prevcode$ = 168
ccwseq$ = 176
iobuf$ = 184
more$ = 192
unitstat$ = 200
residual$ = 208
constty_execute_ccw PROC

; 4440 : {

  00000	44 88 4c 24 20	 mov	 BYTE PTR [rsp+32], r9b
  00005	44 88 44 24 18	 mov	 BYTE PTR [rsp+24], r8b
  0000a	88 54 24 10	 mov	 BYTE PTR [rsp+16], dl
  0000e	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00013	56		 push	 rsi
  00014	57		 push	 rdi
  00015	48 83 ec 68	 sub	 rsp, 104		; 00000068H
$LN4@constty_ex:

; 4441 : U32     len;                            /* Length of data            */
; 4442 : U32     num;                            /* Number of bytes to move   */
; 4443 : BYTE    c;                              /* Print character           */
; 4444 : BYTE    stat;                           /* Unit status               */
; 4445 : 
; 4446 :     UNREFERENCED( chained );

  00019	33 c0		 xor	 eax, eax
  0001b	85 c0		 test	 eax, eax
  0001d	75 fa		 jne	 SHORT $LN4@constty_ex
$LN7@constty_ex:

; 4447 :     UNREFERENCED( prevcode );

  0001f	33 c0		 xor	 eax, eax
  00021	85 c0		 test	 eax, eax
  00023	75 fa		 jne	 SHORT $LN7@constty_ex
$LN10@constty_ex:

; 4448 :     UNREFERENCED( ccwseq );

  00025	33 c0		 xor	 eax, eax
  00027	85 c0		 test	 eax, eax
  00029	75 fa		 jne	 SHORT $LN10@constty_ex

; 4449 : 
; 4450 :     /* Unit check with intervention required if no client connected */
; 4451 :     if (dev->connected == 0 && !IS_CCW_SENSE(code))

  0002b	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00033	8b 80 f8 05 00
	00		 mov	 eax, DWORD PTR [rax+1528]
  00039	c1 e8 05	 shr	 eax, 5
  0003c	83 e0 01	 and	 eax, 1
  0003f	85 c0		 test	 eax, eax
  00041	75 39		 jne	 SHORT $LN25@constty_ex
  00043	0f b6 84 24 88
	00 00 00	 movzx	 eax, BYTE PTR code$[rsp]
  0004b	83 e0 0f	 and	 eax, 15
  0004e	83 f8 04	 cmp	 eax, 4
  00051	74 29		 je	 SHORT $LN25@constty_ex

; 4452 :     {
; 4453 :         dev->sense[0] = SENSE_IR;

  00053	b8 01 00 00 00	 mov	 eax, 1
  00058	48 6b c0 00	 imul	 rax, rax, 0
  0005c	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  00064	c6 84 01 64 03
	00 00 40	 mov	 BYTE PTR [rcx+rax+868], 64 ; 00000040H

; 4454 :         *unitstat = CSW_UC;

  0006c	48 8b 84 24 c8
	00 00 00	 mov	 rax, QWORD PTR unitstat$[rsp]
  00074	c6 00 02	 mov	 BYTE PTR [rax], 2

; 4455 :         return;

  00077	e9 a0 06 00 00	 jmp	 $LN1@constty_ex
$LN25@constty_ex:

; 4456 :     }
; 4457 : 
; 4458 :     /* Process depending on CCW opcode */
; 4459 :     switch (code) {

  0007c	0f b6 84 24 88
	00 00 00	 movzx	 eax, BYTE PTR code$[rsp]
  00084	89 44 24 40	 mov	 DWORD PTR tv78[rsp], eax
  00088	8b 44 24 40	 mov	 eax, DWORD PTR tv78[rsp]
  0008c	ff c8		 dec	 eax
  0008e	89 44 24 40	 mov	 DWORD PTR tv78[rsp], eax
  00092	81 7c 24 40 e3
	00 00 00	 cmp	 DWORD PTR tv78[rsp], 227 ; 000000e3H
  0009a	0f 87 58 06 00
	00		 ja	 $LN49@constty_ex
  000a0	48 63 44 24 40	 movsxd	 rax, DWORD PTR tv78[rsp]
  000a5	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__ImageBase
  000ac	0f b6 84 01 00
	00 00 00	 movzx	 eax, BYTE PTR $LN63@constty_ex[rcx+rax]
  000b4	8b 84 81 00 00
	00 00		 mov	 eax, DWORD PTR $LN64@constty_ex[rcx+rax*4]
  000bb	48 03 c1	 add	 rax, rcx
  000be	ff e0		 jmp	 rax
$LN26@constty_ex:
$LN27@constty_ex:

; 4460 : 
; 4461 :     case 0x01:
; 4462 :     /*---------------------------------------------------------------*/
; 4463 :     /* WRITE, NO CARRIER RETURN                                      */
; 4464 :     /*---------------------------------------------------------------*/
; 4465 : 
; 4466 :     case 0x09:
; 4467 :     /*---------------------------------------------------------------*/
; 4468 :     /* WRITE, AUTO CARRIER RETURN                                    */
; 4469 :     /*---------------------------------------------------------------*/
; 4470 :     {
; 4471 :         /* PROGRAMMING NOTE: we use (dev->bufsize-2) to ensure we
; 4472 :            always have room to append a '\n' newline as well as a
; 4473 :            null byte to terminate the buffer. This is needed since
; 4474 :            sendto_client() always calls telnet_printf() for console
; 4475 :            tty devices to ensure that any CR and/or LF get properly
; 4476 :            translated by libtelnet before being sent to the client.
; 4477 :         */
; 4478 :         U32 bufsize = (U32)(dev->bufsize-2);   /* reserve extra room */

  000c0	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  000c8	8b 80 d8 01 00
	00		 mov	 eax, DWORD PTR [rax+472]
  000ce	83 e8 02	 sub	 eax, 2
  000d1	89 44 24 44	 mov	 DWORD PTR bufsize$1[rsp], eax

; 4479 : 
; 4480 :         /* Calculate number of bytes to write and set residual count */
; 4481 :         num = (count < bufsize) ? count : bufsize;

  000d5	8b 44 24 44	 mov	 eax, DWORD PTR bufsize$1[rsp]
  000d9	39 84 24 a0 00
	00 00		 cmp	 DWORD PTR count$[rsp], eax
  000e0	73 0d		 jae	 SHORT $LN51@constty_ex
  000e2	8b 84 24 a0 00
	00 00		 mov	 eax, DWORD PTR count$[rsp]
  000e9	89 44 24 48	 mov	 DWORD PTR tv82[rsp], eax
  000ed	eb 08		 jmp	 SHORT $LN52@constty_ex
$LN51@constty_ex:
  000ef	8b 44 24 44	 mov	 eax, DWORD PTR bufsize$1[rsp]
  000f3	89 44 24 48	 mov	 DWORD PTR tv82[rsp], eax
$LN52@constty_ex:
  000f7	8b 44 24 48	 mov	 eax, DWORD PTR tv82[rsp]
  000fb	89 44 24 38	 mov	 DWORD PTR num$[rsp], eax

; 4482 :         *residual = count - num;

  000ff	8b 44 24 38	 mov	 eax, DWORD PTR num$[rsp]
  00103	8b 8c 24 a0 00
	00 00		 mov	 ecx, DWORD PTR count$[rsp]
  0010a	2b c8		 sub	 ecx, eax
  0010c	8b c1		 mov	 eax, ecx
  0010e	48 8b 8c 24 d0
	00 00 00	 mov	 rcx, QWORD PTR residual$[rsp]
  00116	89 01		 mov	 DWORD PTR [rcx], eax

; 4483 : 
; 4484 :         /* Translate data in channel buffer to ASCII */
; 4485 :         for (len = 0; len < num; len++)

  00118	c7 44 24 30 00
	00 00 00	 mov	 DWORD PTR len$[rsp], 0
  00120	eb 0a		 jmp	 SHORT $LN15@constty_ex
$LN13@constty_ex:
  00122	8b 44 24 30	 mov	 eax, DWORD PTR len$[rsp]
  00126	ff c0		 inc	 eax
  00128	89 44 24 30	 mov	 DWORD PTR len$[rsp], eax
$LN15@constty_ex:
  0012c	8b 44 24 38	 mov	 eax, DWORD PTR num$[rsp]
  00130	39 44 24 30	 cmp	 DWORD PTR len$[rsp], eax
  00134	73 30		 jae	 SHORT $LN14@constty_ex

; 4486 :         {
; 4487 :             c = guest_to_host( iobuf[len] );

  00136	8b 44 24 30	 mov	 eax, DWORD PTR len$[rsp]
  0013a	48 8b 8c 24 b8
	00 00 00	 mov	 rcx, QWORD PTR iobuf$[rsp]
  00142	0f b6 0c 01	 movzx	 ecx, BYTE PTR [rcx+rax]
  00146	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_guest_to_host
  0014c	88 44 24 3c	 mov	 BYTE PTR c$[rsp], al

; 4488 :             /* Leave it up to guest OS to filter characters. */
; 4489 :             iobuf[len] = c;

  00150	8b 44 24 30	 mov	 eax, DWORD PTR len$[rsp]
  00154	48 8b 8c 24 b8
	00 00 00	 mov	 rcx, QWORD PTR iobuf$[rsp]
  0015c	0f b6 54 24 3c	 movzx	 edx, BYTE PTR c$[rsp]
  00161	88 14 01	 mov	 BYTE PTR [rcx+rax], dl

; 4490 :         } /* end for(len) */

  00164	eb bc		 jmp	 SHORT $LN13@constty_ex
$LN14@constty_ex:
$LN18@constty_ex:

; 4491 : 
; 4492 :         ASSERT(len == num);

  00166	8b 44 24 38	 mov	 eax, DWORD PTR num$[rsp]
  0016a	39 44 24 30	 cmp	 DWORD PTR len$[rsp], eax
  0016e	74 5c		 je	 SHORT $LN28@constty_ex
$LN21@constty_ex:
  00170	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG179682
  00177	41 b8 8c 11 00
	00		 mov	 r8d, 4492		; 0000118cH
  0017d	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG179683
  00184	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG179684
  0018b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_logmsg
  00191	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_IsDebuggerPresent
  00197	85 c0		 test	 eax, eax
  00199	74 20		 je	 SHORT $LN29@constty_ex
  0019b	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG179686
  001a2	41 b8 8c 11 00
	00		 mov	 r8d, 4492		; 0000118cH
  001a8	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG179687
  001af	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG179688
  001b6	e8 00 00 00 00	 call	 DebuggerTrace
$LN29@constty_ex:
  001bb	33 c0		 xor	 eax, eax
  001bd	85 c0		 test	 eax, eax
  001bf	75 af		 jne	 SHORT $LN21@constty_ex
  001c1	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_IsDebuggerPresent
  001c7	85 c0		 test	 eax, eax
  001c9	74 01		 je	 SHORT $LN30@constty_ex
  001cb	cc		 int	 3
$LN30@constty_ex:
$LN28@constty_ex:
  001cc	33 c0		 xor	 eax, eax
  001ce	85 c0		 test	 eax, eax
  001d0	75 94		 jne	 SHORT $LN18@constty_ex

; 4493 : 
; 4494 :         /* Perform end of record processing if not data-chaining */
; 4495 :         if ((flags & CCW_FLAGS_CD) == 0)

  001d2	0f b6 84 24 90
	00 00 00	 movzx	 eax, BYTE PTR flags$[rsp]
  001da	25 80 00 00 00	 and	 eax, 128		; 00000080H
  001df	85 c0		 test	 eax, eax
  001e1	75 27		 jne	 SHORT $LN31@constty_ex

; 4496 :         {
; 4497 :             /* Append newline if required */
; 4498 :             if (code == 0x09)

  001e3	0f b6 84 24 88
	00 00 00	 movzx	 eax, BYTE PTR code$[rsp]
  001eb	83 f8 09	 cmp	 eax, 9
  001ee	75 1a		 jne	 SHORT $LN32@constty_ex

; 4499 :                 iobuf[len++] = '\n';

  001f0	8b 44 24 30	 mov	 eax, DWORD PTR len$[rsp]
  001f4	48 8b 8c 24 b8
	00 00 00	 mov	 rcx, QWORD PTR iobuf$[rsp]
  001fc	c6 04 01 0a	 mov	 BYTE PTR [rcx+rax], 10
  00200	8b 44 24 30	 mov	 eax, DWORD PTR len$[rsp]
  00204	ff c0		 inc	 eax
  00206	89 44 24 30	 mov	 DWORD PTR len$[rsp], eax
$LN32@constty_ex:
$LN31@constty_ex:

; 4500 :         }
; 4501 : 
; 4502 :         /* Ensure buffer is always null terminated */
; 4503 :         iobuf[len] = 0;

  0020a	8b 44 24 30	 mov	 eax, DWORD PTR len$[rsp]
  0020e	48 8b 8c 24 b8
	00 00 00	 mov	 rcx, QWORD PTR iobuf$[rsp]
  00216	c6 04 01 00	 mov	 BYTE PTR [rcx+rax], 0

; 4504 : 
; 4505 :         /* Send the data to the client (via telnet_printf) */
; 4506 :         if (!sendto_client( dev->tn, iobuf, len ))

  0021a	44 8b 44 24 30	 mov	 r8d, DWORD PTR len$[rsp]
  0021f	48 8b 94 24 b8
	00 00 00	 mov	 rdx, QWORD PTR iobuf$[rsp]
  00227	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  0022f	48 8b 88 b0 06
	00 00		 mov	 rcx, QWORD PTR [rax+1712]
  00236	e8 00 00 00 00	 call	 sendto_client
  0023b	0f b6 c0	 movzx	 eax, al
  0023e	85 c0		 test	 eax, eax
  00240	75 29		 jne	 SHORT $LN33@constty_ex

; 4507 :         {
; 4508 :             /* Return with Unit Check status if the send failed */
; 4509 :             dev->sense[0] = SENSE_EC;

  00242	b8 01 00 00 00	 mov	 eax, 1
  00247	48 6b c0 00	 imul	 rax, rax, 0
  0024b	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  00253	c6 84 01 64 03
	00 00 10	 mov	 BYTE PTR [rcx+rax+868], 16

; 4510 :             *unitstat = CSW_CE | CSW_DE | CSW_UC;

  0025b	48 8b 84 24 c8
	00 00 00	 mov	 rax, QWORD PTR unitstat$[rsp]
  00263	c6 00 0e	 mov	 BYTE PTR [rax], 14

; 4511 :             break;

  00266	e9 b1 04 00 00	 jmp	 $LN11@constty_ex
$LN33@constty_ex:

; 4512 :         }
; 4513 : 
; 4514 :         /* Return normal status */
; 4515 :         *unitstat = CSW_CE | CSW_DE;

  0026b	48 8b 84 24 c8
	00 00 00	 mov	 rax, QWORD PTR unitstat$[rsp]
  00273	c6 00 0c	 mov	 BYTE PTR [rax], 12

; 4516 :         break;

  00276	e9 a1 04 00 00	 jmp	 $LN11@constty_ex
$LN34@constty_ex:

; 4517 :     }
; 4518 : 
; 4519 :     case 0x03:
; 4520 :     /*---------------------------------------------------------------*/
; 4521 :     /* CONTROL NO-OPERATION                                          */
; 4522 :     /*---------------------------------------------------------------*/
; 4523 :         *unitstat = CSW_CE | CSW_DE;

  0027b	48 8b 84 24 c8
	00 00 00	 mov	 rax, QWORD PTR unitstat$[rsp]
  00283	c6 00 0c	 mov	 BYTE PTR [rax], 12

; 4524 :         break;

  00286	e9 91 04 00 00	 jmp	 $LN11@constty_ex
$LN35@constty_ex:

; 4525 : 
; 4526 :     case 0x0A:
; 4527 :     /*---------------------------------------------------------------*/
; 4528 :     /* READ INQUIRY                                                  */
; 4529 :     /*---------------------------------------------------------------*/
; 4530 : 
; 4531 :         /* Solicit console input if no data in the device buffer */
; 4532 :         if (!dev->keybdrem)

  0028b	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00293	83 b8 c0 06 00
	00 00		 cmp	 DWORD PTR [rax+1728], 0
  0029a	0f 85 5e 01 00
	00		 jne	 $LN36@constty_ex

; 4533 :         {
; 4534 :             /* Display prompting message on console if allowed */
; 4535 :             if (dev->prompt1052)

  002a0	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  002a8	8b 80 d4 06 00
	00		 mov	 eax, DWORD PTR [rax+1748]
  002ae	c1 e8 02	 shr	 eax, 2
  002b1	83 e0 01	 and	 eax, 1
  002b4	85 c0		 test	 eax, eax
  002b6	0f 84 01 01 00
	00		 je	 $LN37@constty_ex

; 4536 :             {
; 4537 :                 snprintf( (char*)dev->buf, dev->bufsize,

  002bc	48 83 bc 24 80
	00 00 00 00	 cmp	 QWORD PTR dev$[rsp], 0
  002c5	74 12		 je	 SHORT $LN53@constty_ex
  002c7	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  002cf	0f b7 40 48	 movzx	 eax, WORD PTR [rax+72]
  002d3	89 44 24 4c	 mov	 DWORD PTR tv173[rsp], eax
  002d7	eb 08		 jmp	 SHORT $LN54@constty_ex
$LN53@constty_ex:
  002d9	c7 44 24 4c 00
	00 00 00	 mov	 DWORD PTR tv173[rsp], 0
$LN54@constty_ex:
  002e1	48 83 bc 24 80
	00 00 00 00	 cmp	 QWORD PTR dev$[rsp], 0
  002ea	74 14		 je	 SHORT $LN55@constty_ex
  002ec	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  002f4	0f b7 40 44	 movzx	 eax, WORD PTR [rax+68]
  002f8	d1 f8		 sar	 eax, 1
  002fa	89 44 24 50	 mov	 DWORD PTR tv179[rsp], eax
  002fe	eb 08		 jmp	 SHORT $LN56@constty_ex
$LN55@constty_ex:
  00300	c7 44 24 50 00
	00 00 00	 mov	 DWORD PTR tv179[rsp], 0
$LN56@constty_ex:
  00308	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00310	48 63 80 d8 01
	00 00		 movsxd	 rax, DWORD PTR [rax+472]
  00317	8b 4c 24 4c	 mov	 ecx, DWORD PTR tv173[rsp]
  0031b	89 4c 24 28	 mov	 DWORD PTR [rsp+40], ecx
  0031f	8b 4c 24 50	 mov	 ecx, DWORD PTR tv179[rsp]
  00323	89 4c 24 20	 mov	 DWORD PTR [rsp+32], ecx
  00327	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG179697
  0032e	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG179698
  00335	48 8b d0	 mov	 rdx, rax
  00338	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00340	48 8b 88 c8 01
	00 00		 mov	 rcx, QWORD PTR [rax+456]
  00347	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_snprintf

; 4538 :                         // "%1d:%04X COMM: enter console input"
; 4539 :                         // (Note: "MSG" macro used so message DOES end with newline)
; 4540 :                         MSG( HHC01026, "A", LCSS_DEVNUM)
; 4541 :                 );
; 4542 :                 len = (int) strlen( (char*)dev->buf );

  0034d	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00355	48 8b 88 c8 01
	00 00		 mov	 rcx, QWORD PTR [rax+456]
  0035c	e8 00 00 00 00	 call	 strlen
  00361	89 44 24 30	 mov	 DWORD PTR len$[rsp], eax

; 4543 : 
; 4544 :                 /* Send the data to the client */
; 4545 :                 if (!sendto_client( dev->tn, dev->buf, len ))

  00365	44 8b 44 24 30	 mov	 r8d, DWORD PTR len$[rsp]
  0036a	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00372	48 8b 90 c8 01
	00 00		 mov	 rdx, QWORD PTR [rax+456]
  00379	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00381	48 8b 88 b0 06
	00 00		 mov	 rcx, QWORD PTR [rax+1712]
  00388	e8 00 00 00 00	 call	 sendto_client
  0038d	0f b6 c0	 movzx	 eax, al
  00390	85 c0		 test	 eax, eax
  00392	75 29		 jne	 SHORT $LN38@constty_ex

; 4546 :                 {
; 4547 :                     /* Return with Unit Check status if the send failed */
; 4548 :                     dev->sense[0] = SENSE_EC;

  00394	b8 01 00 00 00	 mov	 eax, 1
  00399	48 6b c0 00	 imul	 rax, rax, 0
  0039d	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  003a5	c6 84 01 64 03
	00 00 10	 mov	 BYTE PTR [rcx+rax+868], 16

; 4549 :                     *unitstat = CSW_CE | CSW_DE | CSW_UC;

  003ad	48 8b 84 24 c8
	00 00 00	 mov	 rax, QWORD PTR unitstat$[rsp]
  003b5	c6 00 0e	 mov	 BYTE PTR [rax], 14

; 4550 :                     break;

  003b8	e9 5f 03 00 00	 jmp	 $LN11@constty_ex
$LN38@constty_ex:
$LN37@constty_ex:
$LN24@constty_ex:

; 4551 :                 }
; 4552 :             }
; 4553 : 
; 4554 :             /* Accumulate client input data into device buffer */
; 4555 :             do
; 4556 :             {
; 4557 :                 /* Receive client data and increment dev->keybdrem */
; 4558 :                 stat = recv_1052_data( dev );

  003bd	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  003c5	e8 00 00 00 00	 call	 recv_1052_data
  003ca	88 44 24 34	 mov	 BYTE PTR _stat64$[rsp], al

; 4559 :             }
; 4560 :             while (stat == 0);

  003ce	0f b6 44 24 34	 movzx	 eax, BYTE PTR _stat64$[rsp]
  003d3	85 c0		 test	 eax, eax
  003d5	74 e6		 je	 SHORT $LN24@constty_ex

; 4561 : 
; 4562 :             /* Exit if error status */
; 4563 :             if (stat != CSW_ATTN)

  003d7	0f b6 44 24 34	 movzx	 eax, BYTE PTR _stat64$[rsp]
  003dc	3d 80 00 00 00	 cmp	 eax, 128		; 00000080H
  003e1	74 1b		 je	 SHORT $LN39@constty_ex

; 4564 :             {
; 4565 :                 *unitstat = (CSW_CE | CSW_DE) | (stat & ~CSW_ATTN);

  003e3	0f b6 44 24 34	 movzx	 eax, BYTE PTR _stat64$[rsp]
  003e8	0f ba f0 07	 btr	 eax, 7
  003ec	83 c8 0c	 or	 eax, 12
  003ef	48 8b 8c 24 c8
	00 00 00	 mov	 rcx, QWORD PTR unitstat$[rsp]
  003f7	88 01		 mov	 BYTE PTR [rcx], al

; 4566 :                 break;

  003f9	e9 1e 03 00 00	 jmp	 $LN11@constty_ex
$LN39@constty_ex:
$LN36@constty_ex:

; 4567 :             }
; 4568 :         }
; 4569 : 
; 4570 :         /* Calculate number of bytes to move and residual byte count */
; 4571 :         len = dev->keybdrem;

  003fe	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00406	8b 80 c0 06 00
	00		 mov	 eax, DWORD PTR [rax+1728]
  0040c	89 44 24 30	 mov	 DWORD PTR len$[rsp], eax

; 4572 :         num = (count < len) ? count : len;

  00410	8b 44 24 30	 mov	 eax, DWORD PTR len$[rsp]
  00414	39 84 24 a0 00
	00 00		 cmp	 DWORD PTR count$[rsp], eax
  0041b	73 0d		 jae	 SHORT $LN57@constty_ex
  0041d	8b 84 24 a0 00
	00 00		 mov	 eax, DWORD PTR count$[rsp]
  00424	89 44 24 54	 mov	 DWORD PTR tv214[rsp], eax
  00428	eb 08		 jmp	 SHORT $LN58@constty_ex
$LN57@constty_ex:
  0042a	8b 44 24 30	 mov	 eax, DWORD PTR len$[rsp]
  0042e	89 44 24 54	 mov	 DWORD PTR tv214[rsp], eax
$LN58@constty_ex:
  00432	8b 44 24 54	 mov	 eax, DWORD PTR tv214[rsp]
  00436	89 44 24 38	 mov	 DWORD PTR num$[rsp], eax

; 4573 :         *residual = count - num;

  0043a	8b 44 24 38	 mov	 eax, DWORD PTR num$[rsp]
  0043e	8b 8c 24 a0 00
	00 00		 mov	 ecx, DWORD PTR count$[rsp]
  00445	2b c8		 sub	 ecx, eax
  00447	8b c1		 mov	 eax, ecx
  00449	48 8b 8c 24 d0
	00 00 00	 mov	 rcx, QWORD PTR residual$[rsp]
  00451	89 01		 mov	 DWORD PTR [rcx], eax

; 4574 :         if (count < len) *more = 1;

  00453	8b 44 24 30	 mov	 eax, DWORD PTR len$[rsp]
  00457	39 84 24 a0 00
	00 00		 cmp	 DWORD PTR count$[rsp], eax
  0045e	73 0b		 jae	 SHORT $LN40@constty_ex
  00460	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR more$[rsp]
  00468	c6 00 01	 mov	 BYTE PTR [rax], 1
$LN40@constty_ex:

; 4575 : 
; 4576 :         /* Copy data from device buffer to channel buffer */
; 4577 :         memcpy (iobuf, dev->buf, num);

  0046b	8b 44 24 38	 mov	 eax, DWORD PTR num$[rsp]
  0046f	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  00477	48 8b bc 24 b8
	00 00 00	 mov	 rdi, QWORD PTR iobuf$[rsp]
  0047f	48 8b b1 c8 01
	00 00		 mov	 rsi, QWORD PTR [rcx+456]
  00486	8b c8		 mov	 ecx, eax
  00488	f3 a4		 rep movsb

; 4578 : 
; 4579 :         /* If data chaining is specified, save remaining data */
; 4580 :         if ((flags & CCW_FLAGS_CD) && len > count)

  0048a	0f b6 84 24 90
	00 00 00	 movzx	 eax, BYTE PTR flags$[rsp]
  00492	25 80 00 00 00	 and	 eax, 128		; 00000080H
  00497	85 c0		 test	 eax, eax
  00499	74 6d		 je	 SHORT $LN41@constty_ex
  0049b	8b 84 24 a0 00
	00 00		 mov	 eax, DWORD PTR count$[rsp]
  004a2	39 44 24 30	 cmp	 DWORD PTR len$[rsp], eax
  004a6	76 60		 jbe	 SHORT $LN41@constty_ex

; 4581 :         {
; 4582 :             memmove (dev->buf, dev->buf + count, len - count);

  004a8	8b 84 24 a0 00
	00 00		 mov	 eax, DWORD PTR count$[rsp]
  004af	8b 4c 24 30	 mov	 ecx, DWORD PTR len$[rsp]
  004b3	2b c8		 sub	 ecx, eax
  004b5	8b c1		 mov	 eax, ecx
  004b7	8b c0		 mov	 eax, eax
  004b9	8b 8c 24 a0 00
	00 00		 mov	 ecx, DWORD PTR count$[rsp]
  004c0	48 8b 94 24 80
	00 00 00	 mov	 rdx, QWORD PTR dev$[rsp]
  004c8	48 03 8a c8 01
	00 00		 add	 rcx, QWORD PTR [rdx+456]
  004cf	44 8b c0	 mov	 r8d, eax
  004d2	48 8b d1	 mov	 rdx, rcx
  004d5	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  004dd	48 8b 88 c8 01
	00 00		 mov	 rcx, QWORD PTR [rax+456]
  004e4	e8 00 00 00 00	 call	 memmove

; 4583 :             dev->keybdrem = len - count;

  004e9	8b 84 24 a0 00
	00 00		 mov	 eax, DWORD PTR count$[rsp]
  004f0	8b 4c 24 30	 mov	 ecx, DWORD PTR len$[rsp]
  004f4	2b c8		 sub	 ecx, eax
  004f6	8b c1		 mov	 eax, ecx
  004f8	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  00500	89 81 c0 06 00
	00		 mov	 DWORD PTR [rcx+1728], eax

; 4584 :         }

  00506	eb 12		 jmp	 SHORT $LN42@constty_ex
$LN41@constty_ex:

; 4585 :         else
; 4586 :             dev->keybdrem = 0;

  00508	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00510	c7 80 c0 06 00
	00 00 00 00 00	 mov	 DWORD PTR [rax+1728], 0
$LN42@constty_ex:

; 4587 : 
; 4588 :         /* Return normal status */
; 4589 :         *unitstat = CSW_CE | CSW_DE;

  0051a	48 8b 84 24 c8
	00 00 00	 mov	 rax, QWORD PTR unitstat$[rsp]
  00522	c6 00 0c	 mov	 BYTE PTR [rax], 12

; 4590 :         break;

  00525	e9 f2 01 00 00	 jmp	 $LN11@constty_ex
$LN43@constty_ex:

; 4591 : 
; 4592 :     case 0x0B:
; 4593 :     /*---------------------------------------------------------------*/
; 4594 :     /* AUDIBLE ALARM                                                 */
; 4595 :     /*---------------------------------------------------------------*/
; 4596 :     {
; 4597 :         static BYTE bell[2] = {'\a','\0'};  // "Ding!" (ring the bell)
; 4598 : 
; 4599 :         if (!sendto_client( dev->tn, bell, 1 ))

  0052a	41 b8 01 00 00
	00		 mov	 r8d, 1
  00530	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:?bell@?BG@??constty_execute_ccw@@9@9
  00537	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  0053f	48 8b 88 b0 06
	00 00		 mov	 rcx, QWORD PTR [rax+1712]
  00546	e8 00 00 00 00	 call	 sendto_client
  0054b	0f b6 c0	 movzx	 eax, al
  0054e	85 c0		 test	 eax, eax
  00550	75 29		 jne	 SHORT $LN44@constty_ex

; 4600 :         {
; 4601 :             /* Return with Unit Check status if the send failed */
; 4602 :             dev->sense[0] = SENSE_EC;

  00552	b8 01 00 00 00	 mov	 eax, 1
  00557	48 6b c0 00	 imul	 rax, rax, 0
  0055b	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  00563	c6 84 01 64 03
	00 00 10	 mov	 BYTE PTR [rcx+rax+868], 16

; 4603 :             *unitstat = CSW_CE | CSW_DE | CSW_UC;

  0056b	48 8b 84 24 c8
	00 00 00	 mov	 rax, QWORD PTR unitstat$[rsp]
  00573	c6 00 0e	 mov	 BYTE PTR [rax], 14

; 4604 :             break;

  00576	e9 a1 01 00 00	 jmp	 $LN11@constty_ex
$LN44@constty_ex:

; 4605 :         }
; 4606 : 
; 4607 :         *unitstat = CSW_CE | CSW_DE;

  0057b	48 8b 84 24 c8
	00 00 00	 mov	 rax, QWORD PTR unitstat$[rsp]
  00583	c6 00 0c	 mov	 BYTE PTR [rax], 12

; 4608 :         break;

  00586	e9 91 01 00 00	 jmp	 $LN11@constty_ex
$LN45@constty_ex:

; 4609 :     }
; 4610 : 
; 4611 :     case 0x04:
; 4612 :     /*---------------------------------------------------------------*/
; 4613 :     /* SENSE                                                         */
; 4614 :     /*---------------------------------------------------------------*/
; 4615 :         /* Calculate residual byte count */
; 4616 :         num = (count < dev->numsense) ? count : dev->numsense;

  0058b	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00593	8b 80 60 03 00
	00		 mov	 eax, DWORD PTR [rax+864]
  00599	39 84 24 a0 00
	00 00		 cmp	 DWORD PTR count$[rsp], eax
  005a0	73 0d		 jae	 SHORT $LN59@constty_ex
  005a2	8b 84 24 a0 00
	00 00		 mov	 eax, DWORD PTR count$[rsp]
  005a9	89 44 24 58	 mov	 DWORD PTR tv253[rsp], eax
  005ad	eb 12		 jmp	 SHORT $LN60@constty_ex
$LN59@constty_ex:
  005af	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  005b7	8b 80 60 03 00
	00		 mov	 eax, DWORD PTR [rax+864]
  005bd	89 44 24 58	 mov	 DWORD PTR tv253[rsp], eax
$LN60@constty_ex:
  005c1	8b 44 24 58	 mov	 eax, DWORD PTR tv253[rsp]
  005c5	89 44 24 38	 mov	 DWORD PTR num$[rsp], eax

; 4617 :         *residual = count - num;

  005c9	8b 44 24 38	 mov	 eax, DWORD PTR num$[rsp]
  005cd	8b 8c 24 a0 00
	00 00		 mov	 ecx, DWORD PTR count$[rsp]
  005d4	2b c8		 sub	 ecx, eax
  005d6	8b c1		 mov	 eax, ecx
  005d8	48 8b 8c 24 d0
	00 00 00	 mov	 rcx, QWORD PTR residual$[rsp]
  005e0	89 01		 mov	 DWORD PTR [rcx], eax

; 4618 :         if (count < dev->numsense) *more = 1;

  005e2	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  005ea	8b 80 60 03 00
	00		 mov	 eax, DWORD PTR [rax+864]
  005f0	39 84 24 a0 00
	00 00		 cmp	 DWORD PTR count$[rsp], eax
  005f7	73 0b		 jae	 SHORT $LN46@constty_ex
  005f9	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR more$[rsp]
  00601	c6 00 01	 mov	 BYTE PTR [rax], 1
$LN46@constty_ex:

; 4619 : 
; 4620 :         /* Copy device sense bytes to channel I/O buffer */
; 4621 :         memcpy (iobuf, dev->sense, num);

  00604	8b 44 24 38	 mov	 eax, DWORD PTR num$[rsp]
  00608	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  00610	48 81 c1 64 03
	00 00		 add	 rcx, 868		; 00000364H
  00617	48 8b bc 24 b8
	00 00 00	 mov	 rdi, QWORD PTR iobuf$[rsp]
  0061f	48 8b f1	 mov	 rsi, rcx
  00622	8b c8		 mov	 ecx, eax
  00624	f3 a4		 rep movsb

; 4622 : 
; 4623 :         /* Clear the device sense bytes */
; 4624 :         memset( dev->sense, 0, sizeof(dev->sense) );

  00626	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  0062e	48 05 64 03 00
	00		 add	 rax, 868		; 00000364H
  00634	48 8b f8	 mov	 rdi, rax
  00637	33 c0		 xor	 eax, eax
  00639	b9 00 01 00 00	 mov	 ecx, 256		; 00000100H
  0063e	f3 aa		 rep stosb

; 4625 : 
; 4626 :         /* Return unit status */
; 4627 :         *unitstat = CSW_CE | CSW_DE;

  00640	48 8b 84 24 c8
	00 00 00	 mov	 rax, QWORD PTR unitstat$[rsp]
  00648	c6 00 0c	 mov	 BYTE PTR [rax], 12

; 4628 :         break;

  0064b	e9 cc 00 00 00	 jmp	 $LN11@constty_ex
$LN47@constty_ex:

; 4629 : 
; 4630 :     case 0xE4:
; 4631 :     /*---------------------------------------------------------------*/
; 4632 :     /* SENSE ID                                                      */
; 4633 :     /*---------------------------------------------------------------*/
; 4634 :         /* Calculate residual byte count */
; 4635 :         num = (count < dev->numdevid) ? count : dev->numdevid;

  00650	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00658	8b 80 64 04 00
	00		 mov	 eax, DWORD PTR [rax+1124]
  0065e	39 84 24 a0 00
	00 00		 cmp	 DWORD PTR count$[rsp], eax
  00665	73 0d		 jae	 SHORT $LN61@constty_ex
  00667	8b 84 24 a0 00
	00 00		 mov	 eax, DWORD PTR count$[rsp]
  0066e	89 44 24 5c	 mov	 DWORD PTR tv272[rsp], eax
  00672	eb 12		 jmp	 SHORT $LN62@constty_ex
$LN61@constty_ex:
  00674	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  0067c	8b 80 64 04 00
	00		 mov	 eax, DWORD PTR [rax+1124]
  00682	89 44 24 5c	 mov	 DWORD PTR tv272[rsp], eax
$LN62@constty_ex:
  00686	8b 44 24 5c	 mov	 eax, DWORD PTR tv272[rsp]
  0068a	89 44 24 38	 mov	 DWORD PTR num$[rsp], eax

; 4636 :         *residual = count - num;

  0068e	8b 44 24 38	 mov	 eax, DWORD PTR num$[rsp]
  00692	8b 8c 24 a0 00
	00 00		 mov	 ecx, DWORD PTR count$[rsp]
  00699	2b c8		 sub	 ecx, eax
  0069b	8b c1		 mov	 eax, ecx
  0069d	48 8b 8c 24 d0
	00 00 00	 mov	 rcx, QWORD PTR residual$[rsp]
  006a5	89 01		 mov	 DWORD PTR [rcx], eax

; 4637 :         if (count < dev->numdevid) *more = 1;

  006a7	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  006af	8b 80 64 04 00
	00		 mov	 eax, DWORD PTR [rax+1124]
  006b5	39 84 24 a0 00
	00 00		 cmp	 DWORD PTR count$[rsp], eax
  006bc	73 0b		 jae	 SHORT $LN48@constty_ex
  006be	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR more$[rsp]
  006c6	c6 00 01	 mov	 BYTE PTR [rax], 1
$LN48@constty_ex:

; 4638 : 
; 4639 :         /* Copy device identifier bytes to channel I/O buffer */
; 4640 :         memcpy (iobuf, dev->devid, num);

  006c9	8b 44 24 38	 mov	 eax, DWORD PTR num$[rsp]
  006cd	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  006d5	48 81 c1 68 04
	00 00		 add	 rcx, 1128		; 00000468H
  006dc	48 8b bc 24 b8
	00 00 00	 mov	 rdi, QWORD PTR iobuf$[rsp]
  006e4	48 8b f1	 mov	 rsi, rcx
  006e7	8b c8		 mov	 ecx, eax
  006e9	f3 a4		 rep movsb

; 4641 : 
; 4642 :         /* Return unit status */
; 4643 :         *unitstat = CSW_CE | CSW_DE;

  006eb	48 8b 84 24 c8
	00 00 00	 mov	 rax, QWORD PTR unitstat$[rsp]
  006f3	c6 00 0c	 mov	 BYTE PTR [rax], 12

; 4644 :         break;

  006f6	eb 24		 jmp	 SHORT $LN11@constty_ex
$LN49@constty_ex:

; 4645 : 
; 4646 :     default:
; 4647 :     /*---------------------------------------------------------------*/
; 4648 :     /* INVALID OPERATION                                             */
; 4649 :     /*---------------------------------------------------------------*/
; 4650 :         /* Set command reject sense byte, and unit check status */
; 4651 :         dev->sense[0] = SENSE_CR;

  006f8	b8 01 00 00 00	 mov	 eax, 1
  006fd	48 6b c0 00	 imul	 rax, rax, 0
  00701	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  00709	c6 84 01 64 03
	00 00 80	 mov	 BYTE PTR [rcx+rax+868], 128 ; 00000080H

; 4652 :         *unitstat = CSW_CE | CSW_DE | CSW_UC;

  00711	48 8b 84 24 c8
	00 00 00	 mov	 rax, QWORD PTR unitstat$[rsp]
  00719	c6 00 0e	 mov	 BYTE PTR [rax], 14
$LN11@constty_ex:
$LN1@constty_ex:

; 4653 : 
; 4654 :     } /* end switch(code) */
; 4655 : 
; 4656 : } /* end function constty_execute_ccw */

  0071c	48 83 c4 68	 add	 rsp, 104		; 00000068H
  00720	5f		 pop	 rdi
  00721	5e		 pop	 rsi
  00722	c3		 ret	 0
  00723	90		 npad	 1
$LN64@constty_ex:
  00724	00 00 00 00	 DD	 $LN26@constty_ex
  00728	00 00 00 00	 DD	 $LN34@constty_ex
  0072c	00 00 00 00	 DD	 $LN45@constty_ex
  00730	00 00 00 00	 DD	 $LN27@constty_ex
  00734	00 00 00 00	 DD	 $LN35@constty_ex
  00738	00 00 00 00	 DD	 $LN43@constty_ex
  0073c	00 00 00 00	 DD	 $LN47@constty_ex
  00740	00 00 00 00	 DD	 $LN49@constty_ex
$LN63@constty_ex:
  00744	00		 DB	 0
  00745	07		 DB	 7
  00746	01		 DB	 1
  00747	02		 DB	 2
  00748	07		 DB	 7
  00749	07		 DB	 7
  0074a	07		 DB	 7
  0074b	07		 DB	 7
  0074c	03		 DB	 3
  0074d	04		 DB	 4
  0074e	05		 DB	 5
  0074f	07		 DB	 7
  00750	07		 DB	 7
  00751	07		 DB	 7
  00752	07		 DB	 7
  00753	07		 DB	 7
  00754	07		 DB	 7
  00755	07		 DB	 7
  00756	07		 DB	 7
  00757	07		 DB	 7
  00758	07		 DB	 7
  00759	07		 DB	 7
  0075a	07		 DB	 7
  0075b	07		 DB	 7
  0075c	07		 DB	 7
  0075d	07		 DB	 7
  0075e	07		 DB	 7
  0075f	07		 DB	 7
  00760	07		 DB	 7
  00761	07		 DB	 7
  00762	07		 DB	 7
  00763	07		 DB	 7
  00764	07		 DB	 7
  00765	07		 DB	 7
  00766	07		 DB	 7
  00767	07		 DB	 7
  00768	07		 DB	 7
  00769	07		 DB	 7
  0076a	07		 DB	 7
  0076b	07		 DB	 7
  0076c	07		 DB	 7
  0076d	07		 DB	 7
  0076e	07		 DB	 7
  0076f	07		 DB	 7
  00770	07		 DB	 7
  00771	07		 DB	 7
  00772	07		 DB	 7
  00773	07		 DB	 7
  00774	07		 DB	 7
  00775	07		 DB	 7
  00776	07		 DB	 7
  00777	07		 DB	 7
  00778	07		 DB	 7
  00779	07		 DB	 7
  0077a	07		 DB	 7
  0077b	07		 DB	 7
  0077c	07		 DB	 7
  0077d	07		 DB	 7
  0077e	07		 DB	 7
  0077f	07		 DB	 7
  00780	07		 DB	 7
  00781	07		 DB	 7
  00782	07		 DB	 7
  00783	07		 DB	 7
  00784	07		 DB	 7
  00785	07		 DB	 7
  00786	07		 DB	 7
  00787	07		 DB	 7
  00788	07		 DB	 7
  00789	07		 DB	 7
  0078a	07		 DB	 7
  0078b	07		 DB	 7
  0078c	07		 DB	 7
  0078d	07		 DB	 7
  0078e	07		 DB	 7
  0078f	07		 DB	 7
  00790	07		 DB	 7
  00791	07		 DB	 7
  00792	07		 DB	 7
  00793	07		 DB	 7
  00794	07		 DB	 7
  00795	07		 DB	 7
  00796	07		 DB	 7
  00797	07		 DB	 7
  00798	07		 DB	 7
  00799	07		 DB	 7
  0079a	07		 DB	 7
  0079b	07		 DB	 7
  0079c	07		 DB	 7
  0079d	07		 DB	 7
  0079e	07		 DB	 7
  0079f	07		 DB	 7
  007a0	07		 DB	 7
  007a1	07		 DB	 7
  007a2	07		 DB	 7
  007a3	07		 DB	 7
  007a4	07		 DB	 7
  007a5	07		 DB	 7
  007a6	07		 DB	 7
  007a7	07		 DB	 7
  007a8	07		 DB	 7
  007a9	07		 DB	 7
  007aa	07		 DB	 7
  007ab	07		 DB	 7
  007ac	07		 DB	 7
  007ad	07		 DB	 7
  007ae	07		 DB	 7
  007af	07		 DB	 7
  007b0	07		 DB	 7
  007b1	07		 DB	 7
  007b2	07		 DB	 7
  007b3	07		 DB	 7
  007b4	07		 DB	 7
  007b5	07		 DB	 7
  007b6	07		 DB	 7
  007b7	07		 DB	 7
  007b8	07		 DB	 7
  007b9	07		 DB	 7
  007ba	07		 DB	 7
  007bb	07		 DB	 7
  007bc	07		 DB	 7
  007bd	07		 DB	 7
  007be	07		 DB	 7
  007bf	07		 DB	 7
  007c0	07		 DB	 7
  007c1	07		 DB	 7
  007c2	07		 DB	 7
  007c3	07		 DB	 7
  007c4	07		 DB	 7
  007c5	07		 DB	 7
  007c6	07		 DB	 7
  007c7	07		 DB	 7
  007c8	07		 DB	 7
  007c9	07		 DB	 7
  007ca	07		 DB	 7
  007cb	07		 DB	 7
  007cc	07		 DB	 7
  007cd	07		 DB	 7
  007ce	07		 DB	 7
  007cf	07		 DB	 7
  007d0	07		 DB	 7
  007d1	07		 DB	 7
  007d2	07		 DB	 7
  007d3	07		 DB	 7
  007d4	07		 DB	 7
  007d5	07		 DB	 7
  007d6	07		 DB	 7
  007d7	07		 DB	 7
  007d8	07		 DB	 7
  007d9	07		 DB	 7
  007da	07		 DB	 7
  007db	07		 DB	 7
  007dc	07		 DB	 7
  007dd	07		 DB	 7
  007de	07		 DB	 7
  007df	07		 DB	 7
  007e0	07		 DB	 7
  007e1	07		 DB	 7
  007e2	07		 DB	 7
  007e3	07		 DB	 7
  007e4	07		 DB	 7
  007e5	07		 DB	 7
  007e6	07		 DB	 7
  007e7	07		 DB	 7
  007e8	07		 DB	 7
  007e9	07		 DB	 7
  007ea	07		 DB	 7
  007eb	07		 DB	 7
  007ec	07		 DB	 7
  007ed	07		 DB	 7
  007ee	07		 DB	 7
  007ef	07		 DB	 7
  007f0	07		 DB	 7
  007f1	07		 DB	 7
  007f2	07		 DB	 7
  007f3	07		 DB	 7
  007f4	07		 DB	 7
  007f5	07		 DB	 7
  007f6	07		 DB	 7
  007f7	07		 DB	 7
  007f8	07		 DB	 7
  007f9	07		 DB	 7
  007fa	07		 DB	 7
  007fb	07		 DB	 7
  007fc	07		 DB	 7
  007fd	07		 DB	 7
  007fe	07		 DB	 7
  007ff	07		 DB	 7
  00800	07		 DB	 7
  00801	07		 DB	 7
  00802	07		 DB	 7
  00803	07		 DB	 7
  00804	07		 DB	 7
  00805	07		 DB	 7
  00806	07		 DB	 7
  00807	07		 DB	 7
  00808	07		 DB	 7
  00809	07		 DB	 7
  0080a	07		 DB	 7
  0080b	07		 DB	 7
  0080c	07		 DB	 7
  0080d	07		 DB	 7
  0080e	07		 DB	 7
  0080f	07		 DB	 7
  00810	07		 DB	 7
  00811	07		 DB	 7
  00812	07		 DB	 7
  00813	07		 DB	 7
  00814	07		 DB	 7
  00815	07		 DB	 7
  00816	07		 DB	 7
  00817	07		 DB	 7
  00818	07		 DB	 7
  00819	07		 DB	 7
  0081a	07		 DB	 7
  0081b	07		 DB	 7
  0081c	07		 DB	 7
  0081d	07		 DB	 7
  0081e	07		 DB	 7
  0081f	07		 DB	 7
  00820	07		 DB	 7
  00821	07		 DB	 7
  00822	07		 DB	 7
  00823	07		 DB	 7
  00824	07		 DB	 7
  00825	07		 DB	 7
  00826	07		 DB	 7
  00827	06		 DB	 6
constty_execute_ccw ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\console.c
_TEXT	SEGMENT
len$ = 32
cmd$ = 36
num$ = 40
aid$ = 44
c$1 = 48
c$2 = 49
off$ = 52
tv80 = 56
rc$ = 60
tv132 = 64
tv214 = 68
tv222 = 72
tv217 = 76
tv255 = 80
tv296 = 84
tv310 = 88
tv320 = 92
f$3 = 96
tv409 = 100
tv454 = 104
tv468 = 108
tv478 = 112
f$4 = 116
tv563 = 120
tv583 = 124
saved_errno$5 = 128
saved_errno$6 = 132
tv225 = 136
tv326 = 144
tv484 = 152
tv305 = 160
tv463 = 168
buf$ = 176
__$ArrayPad$ = 65712
dev$ = 65760
code$ = 65768
flags$ = 65776
chained$ = 65784
count$ = 65792
prevcode$ = 65800
ccwseq$ = 65808
iobuf$ = 65816
more$ = 65824
unitstat$ = 65832
residual$ = 65840
loc3270_execute_ccw PROC

; 3980 : {

  00000	44 88 4c 24 20	 mov	 BYTE PTR [rsp+32], r9b
  00005	44 88 44 24 18	 mov	 BYTE PTR [rsp+24], r8b
  0000a	88 54 24 10	 mov	 BYTE PTR [rsp+16], dl
  0000e	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00013	56		 push	 rsi
  00014	57		 push	 rdi
  00015	b8 c8 00 01 00	 mov	 eax, 65736		; 000100c8H
  0001a	e8 00 00 00 00	 call	 __chkstk
  0001f	48 2b e0	 sub	 rsp, rax
  00022	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00029	48 33 c4	 xor	 rax, rsp
  0002c	48 89 84 24 b0
	00 01 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax
$LN4@loc3270_ex:

; 3981 : int             rc;                     /* Return code               */
; 3982 : U32             num;                    /* Number of bytes to copy   */
; 3983 : U32             len;                    /* Data length               */
; 3984 : int             aid;                    /* First read: AID present   */
; 3985 : U32             off;                    /* Offset in device buffer   */
; 3986 : BYTE            cmd;                    /* tn3270 command code       */
; 3987 : BYTE            buf[BUFLEN_3270];       /* tn3270 write buffer       */
; 3988 : 
; 3989 :     UNREFERENCED( prevcode );

  00034	33 c0		 xor	 eax, eax
  00036	85 c0		 test	 eax, eax
  00038	75 fa		 jne	 SHORT $LN4@loc3270_ex
$LN7@loc3270_ex:

; 3990 :     UNREFERENCED( ccwseq );

  0003a	33 c0		 xor	 eax, eax
  0003c	85 c0		 test	 eax, eax
  0003e	75 fa		 jne	 SHORT $LN7@loc3270_ex

; 3991 : 
; 3992 :     /* Clear the current screen position at start of CCW chain */
; 3993 :     if (!chained)

  00040	0f b6 84 24 f8
	00 01 00	 movzx	 eax, BYTE PTR chained$[rsp]
  00048	85 c0		 test	 eax, eax
  0004a	75 12		 jne	 SHORT $LN28@loc3270_ex

; 3994 :         dev->pos3270 = 0;

  0004c	48 8b 84 24 e0
	00 01 00	 mov	 rax, QWORD PTR dev$[rsp]
  00054	c7 80 bc 06 00
	00 00 00 00 00	 mov	 DWORD PTR [rax+1724], 0
$LN28@loc3270_ex:

; 3995 : 
; 3996 :     /* Unit check with intervention required if no client connected */
; 3997 :     if (!dev->connected && !IS_CCW_SENSE( code ))

  0005e	48 8b 84 24 e0
	00 01 00	 mov	 rax, QWORD PTR dev$[rsp]
  00066	8b 80 f8 05 00
	00		 mov	 eax, DWORD PTR [rax+1528]
  0006c	c1 e8 05	 shr	 eax, 5
  0006f	83 e0 01	 and	 eax, 1
  00072	85 c0		 test	 eax, eax
  00074	75 39		 jne	 SHORT $LN29@loc3270_ex
  00076	0f b6 84 24 e8
	00 01 00	 movzx	 eax, BYTE PTR code$[rsp]
  0007e	83 e0 0f	 and	 eax, 15
  00081	83 f8 04	 cmp	 eax, 4
  00084	74 29		 je	 SHORT $LN29@loc3270_ex

; 3998 :     {
; 3999 :         dev->sense[0] = SENSE_IR;

  00086	b8 01 00 00 00	 mov	 eax, 1
  0008b	48 6b c0 00	 imul	 rax, rax, 0
  0008f	48 8b 8c 24 e0
	00 01 00	 mov	 rcx, QWORD PTR dev$[rsp]
  00097	c6 84 01 64 03
	00 00 40	 mov	 BYTE PTR [rcx+rax+868], 64 ; 00000040H

; 4000 : 
; 4001 :         // NO!  *unitstat = CSW_CE | CSW_DE | CSW_UC;
; 4002 : 
; 4003 :         /*  ISW3274DR:  as per manual GA23-0218-11: "3174 Establishment
; 4004 :             Controller: Functional Description", section 3.1.3.2.2:
; 4005 :             "Solicited Status", Table 5-6: "Initial Status Conditions
; 4006 :             (Non-SNA)", the proper Intervention Required status is
; 4007 :             Unit Check (UC) only.
; 4008 :         */
; 4009 :         *unitstat = CSW_UC;    // (see above)

  0009f	48 8b 84 24 28
	01 01 00	 mov	 rax, QWORD PTR unitstat$[rsp]
  000a7	c6 00 02	 mov	 BYTE PTR [rax], 2

; 4010 :         return;

  000aa	e9 36 12 00 00	 jmp	 $LN1@loc3270_ex
$LN29@loc3270_ex:

; 4011 :     }
; 4012 : 
; 4013 :     /* Process depending on CCW opcode */
; 4014 :     switch (code) {

  000af	0f b6 84 24 e8
	00 01 00	 movzx	 eax, BYTE PTR code$[rsp]
  000b7	89 44 24 38	 mov	 DWORD PTR tv80[rsp], eax
  000bb	8b 44 24 38	 mov	 eax, DWORD PTR tv80[rsp]
  000bf	ff c8		 dec	 eax
  000c1	89 44 24 38	 mov	 DWORD PTR tv80[rsp], eax
  000c5	81 7c 24 38 e3
	00 00 00	 cmp	 DWORD PTR tv80[rsp], 227 ; 000000e3H
  000cd	0f 87 ee 11 00
	00		 ja	 $LN85@loc3270_ex
  000d3	48 63 44 24 38	 movsxd	 rax, DWORD PTR tv80[rsp]
  000d8	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__ImageBase
  000df	0f b6 84 01 00
	00 00 00	 movzx	 eax, BYTE PTR $LN121@loc3270_ex[rcx+rax]
  000e7	8b 84 81 00 00
	00 00		 mov	 eax, DWORD PTR $LN122@loc3270_ex[rcx+rax*4]
  000ee	48 03 c1	 add	 rax, rcx
  000f1	ff e0		 jmp	 rax
$LN30@loc3270_ex:

; 4015 : 
; 4016 :     case L3270_NOP:
; 4017 :     /*---------------------------------------------------------------*/
; 4018 :     /* CONTROL NO-OPERATION                                          */
; 4019 :     /*---------------------------------------------------------------*/
; 4020 :         /* Reset the buffer address */
; 4021 :         dev->pos3270 = 0;

  000f3	48 8b 84 24 e0
	00 01 00	 mov	 rax, QWORD PTR dev$[rsp]
  000fb	c7 80 bc 06 00
	00 00 00 00 00	 mov	 DWORD PTR [rax+1724], 0

; 4022 : 
; 4023 :         *unitstat = CSW_CE | CSW_DE;

  00105	48 8b 84 24 28
	01 01 00	 mov	 rax, QWORD PTR unitstat$[rsp]
  0010d	c6 00 0c	 mov	 BYTE PTR [rax], 12

; 4024 :         break;

  00110	e9 d0 11 00 00	 jmp	 $LN8@loc3270_ex
$LN31@loc3270_ex:
$LN32@loc3270_ex:
$LN33@loc3270_ex:
$LN34@loc3270_ex:
$LN35@loc3270_ex:

; 4025 : 
; 4026 :     case L3270_SELRM:
; 4027 :     case L3270_SELRB:
; 4028 :     case L3270_SELRMP:
; 4029 :     case L3270_SELRBP:
; 4030 :     case L3270_SELWRT:
; 4031 :     /*---------------------------------------------------------------*/
; 4032 :     /* SELECT                                                        */
; 4033 :     /*---------------------------------------------------------------*/
; 4034 :         /* Reset the buffer address */
; 4035 :         dev->pos3270 = 0;

  00115	48 8b 84 24 e0
	00 01 00	 mov	 rax, QWORD PTR dev$[rsp]
  0011d	c7 80 bc 06 00
	00 00 00 00 00	 mov	 DWORD PTR [rax+1724], 0

; 4036 : 
; 4037 :     /*
; 4038 :         *residual = 0;
; 4039 :     */
; 4040 :         *unitstat = CSW_CE | CSW_DE;

  00127	48 8b 84 24 28
	01 01 00	 mov	 rax, QWORD PTR unitstat$[rsp]
  0012f	c6 00 0c	 mov	 BYTE PTR [rax], 12

; 4041 :         break;

  00132	e9 ae 11 00 00	 jmp	 $LN8@loc3270_ex
$LN36@loc3270_ex:

; 4042 : 
; 4043 :     case L3270_EAU:
; 4044 :     /*---------------------------------------------------------------*/
; 4045 :     /* ERASE ALL UNPROTECTED                                         */
; 4046 :     /*---------------------------------------------------------------*/
; 4047 :         dev->pos3270 = 0;

  00137	48 8b 84 24 e0
	00 01 00	 mov	 rax, QWORD PTR dev$[rsp]
  0013f	c7 80 bc 06 00
	00 00 00 00 00	 mov	 DWORD PTR [rax+1724], 0

; 4048 :         cmd = R3270_EAU;

  00149	c6 44 24 24 6f	 mov	 BYTE PTR cmd$[rsp], 111	; 0000006fH

; 4049 :         goto write;

  0014e	e9 d4 00 00 00	 jmp	 $write$123
$LN37@loc3270_ex:

; 4050 : 
; 4051 :     case L3270_WRT:
; 4052 :     /*---------------------------------------------------------------*/
; 4053 :     /* WRITE                                                         */
; 4054 :     /*---------------------------------------------------------------*/
; 4055 :         cmd = R3270_WRT;

  00153	c6 44 24 24 f1	 mov	 BYTE PTR cmd$[rsp], 241	; 000000f1H

; 4056 :         goto write;

  00158	e9 ca 00 00 00	 jmp	 $write$123
$LN38@loc3270_ex:

; 4057 : 
; 4058 :     case L3270_EW:
; 4059 :     /*---------------------------------------------------------------*/
; 4060 :     /* ERASE/WRITE                                                   */
; 4061 :     /*---------------------------------------------------------------*/
; 4062 :         dev->pos3270 = 0;

  0015d	48 8b 84 24 e0
	00 01 00	 mov	 rax, QWORD PTR dev$[rsp]
  00165	c7 80 bc 06 00
	00 00 00 00 00	 mov	 DWORD PTR [rax+1724], 0

; 4063 :         cmd = R3270_EW;

  0016f	c6 44 24 24 f5	 mov	 BYTE PTR cmd$[rsp], 245	; 000000f5H

; 4064 :         dev->ewa3270 = 0;

  00174	48 8b 84 24 e0
	00 01 00	 mov	 rax, QWORD PTR dev$[rsp]
  0017c	8b 80 d4 06 00
	00		 mov	 eax, DWORD PTR [rax+1748]
  00182	83 e0 fd	 and	 eax, -3			; fffffffdH
  00185	48 8b 8c 24 e0
	00 01 00	 mov	 rcx, QWORD PTR dev$[rsp]
  0018d	89 81 d4 06 00
	00		 mov	 DWORD PTR [rcx+1748], eax

; 4065 :         goto write;

  00193	e9 8f 00 00 00	 jmp	 $write$123
$LN39@loc3270_ex:

; 4066 : 
; 4067 :     case L3270_EWA:
; 4068 :     /*---------------------------------------------------------------*/
; 4069 :     /* ERASE/WRITE ALTERNATE                                         */
; 4070 :     /*---------------------------------------------------------------*/
; 4071 :         dev->pos3270 = 0;

  00198	48 8b 84 24 e0
	00 01 00	 mov	 rax, QWORD PTR dev$[rsp]
  001a0	c7 80 bc 06 00
	00 00 00 00 00	 mov	 DWORD PTR [rax+1724], 0

; 4072 :         cmd = R3270_EWA;

  001aa	c6 44 24 24 7e	 mov	 BYTE PTR cmd$[rsp], 126	; 0000007eH

; 4073 :         dev->ewa3270 = 1;

  001af	48 8b 84 24 e0
	00 01 00	 mov	 rax, QWORD PTR dev$[rsp]
  001b7	8b 80 d4 06 00
	00		 mov	 eax, DWORD PTR [rax+1748]
  001bd	83 c8 02	 or	 eax, 2
  001c0	48 8b 8c 24 e0
	00 01 00	 mov	 rcx, QWORD PTR dev$[rsp]
  001c8	89 81 d4 06 00
	00		 mov	 DWORD PTR [rcx+1748], eax

; 4074 :         goto write;

  001ce	eb 57		 jmp	 SHORT $write$123
$LN40@loc3270_ex:

; 4075 : 
; 4076 :     case L3270_WSF:
; 4077 :     /*---------------------------------------------------------------*/
; 4078 :     /* WRITE STRUCTURED FIELD                                        */
; 4079 :     /*---------------------------------------------------------------*/
; 4080 :         /* Process WSF command if device has extended attributes */
; 4081 :         if (dev->eab3270)

  001d0	48 8b 84 24 e0
	00 01 00	 mov	 rax, QWORD PTR dev$[rsp]
  001d8	8b 80 d4 06 00
	00		 mov	 eax, DWORD PTR [rax+1748]
  001de	83 e0 01	 and	 eax, 1
  001e1	85 c0		 test	 eax, eax
  001e3	74 19		 je	 SHORT $LN41@loc3270_ex

; 4082 :         {
; 4083 :             dev->pos3270 = 0;

  001e5	48 8b 84 24 e0
	00 01 00	 mov	 rax, QWORD PTR dev$[rsp]
  001ed	c7 80 bc 06 00
	00 00 00 00 00	 mov	 DWORD PTR [rax+1724], 0

; 4084 :             cmd = R3270_WSF;

  001f7	c6 44 24 24 f3	 mov	 BYTE PTR cmd$[rsp], 243	; 000000f3H

; 4085 :             goto write;

  001fc	eb 29		 jmp	 SHORT $write$123
$LN41@loc3270_ex:

; 4086 :         }
; 4087 : 
; 4088 :         /* Operation check, device does not have extended attributes */
; 4089 :         dev->sense[0] = SENSE_OC;

  001fe	b8 01 00 00 00	 mov	 eax, 1
  00203	48 6b c0 00	 imul	 rax, rax, 0
  00207	48 8b 8c 24 e0
	00 01 00	 mov	 rcx, QWORD PTR dev$[rsp]
  0020f	c6 84 01 64 03
	00 00 01	 mov	 BYTE PTR [rcx+rax+868], 1

; 4090 :         *unitstat = CSW_CE | CSW_DE | CSW_UC;

  00217	48 8b 84 24 28
	01 01 00	 mov	 rax, QWORD PTR unitstat$[rsp]
  0021f	c6 00 0e	 mov	 BYTE PTR [rax], 14

; 4091 :         break;

  00222	e9 be 10 00 00	 jmp	 $LN8@loc3270_ex
$write$123:

; 4092 : 
; 4093 :     write:
; 4094 :     /*---------------------------------------------------------------*/
; 4095 :     /* All write commands, and the EAU control command, come here    */
; 4096 :     /*---------------------------------------------------------------*/
; 4097 :         /* Initialize the data length */
; 4098 :         len = 0;

  00227	c7 44 24 20 00
	00 00 00	 mov	 DWORD PTR len$[rsp], 0

; 4099 : 
; 4100 :         /* Calculate number of bytes to move and residual byte count */
; 4101 :         num = sizeof(buf) / 2;

  0022f	c7 44 24 28 00
	80 00 00	 mov	 DWORD PTR num$[rsp], 32768 ; 00008000H

; 4102 :         num = (count < num) ? count : num;

  00237	8b 44 24 28	 mov	 eax, DWORD PTR num$[rsp]
  0023b	39 84 24 00 01
	01 00		 cmp	 DWORD PTR count$[rsp], eax
  00242	73 0d		 jae	 SHORT $LN87@loc3270_ex
  00244	8b 84 24 00 01
	01 00		 mov	 eax, DWORD PTR count$[rsp]
  0024b	89 44 24 40	 mov	 DWORD PTR tv132[rsp], eax
  0024f	eb 08		 jmp	 SHORT $LN88@loc3270_ex
$LN87@loc3270_ex:
  00251	8b 44 24 28	 mov	 eax, DWORD PTR num$[rsp]
  00255	89 44 24 40	 mov	 DWORD PTR tv132[rsp], eax
$LN88@loc3270_ex:
  00259	8b 44 24 40	 mov	 eax, DWORD PTR tv132[rsp]
  0025d	89 44 24 28	 mov	 DWORD PTR num$[rsp], eax

; 4103 :         if (cmd == R3270_EAU) num = 0;

  00261	0f b6 44 24 24	 movzx	 eax, BYTE PTR cmd$[rsp]
  00266	83 f8 6f	 cmp	 eax, 111		; 0000006fH
  00269	75 08		 jne	 SHORT $LN42@loc3270_ex
  0026b	c7 44 24 28 00
	00 00 00	 mov	 DWORD PTR num$[rsp], 0
$LN42@loc3270_ex:

; 4104 :         *residual = count - num;

  00273	8b 44 24 28	 mov	 eax, DWORD PTR num$[rsp]
  00277	8b 8c 24 00 01
	01 00		 mov	 ecx, DWORD PTR count$[rsp]
  0027e	2b c8		 sub	 ecx, eax
  00280	8b c1		 mov	 eax, ecx
  00282	48 8b 8c 24 30
	01 01 00	 mov	 rcx, QWORD PTR residual$[rsp]
  0028a	89 01		 mov	 DWORD PTR [rcx], eax

; 4105 : 
; 4106 :         /* Move the 3270 command code to the first byte of the buffer
; 4107 :            unless data-chained from previous CCW
; 4108 :         */
; 4109 :         if (!(chained & CCW_FLAGS_CD))

  0028c	0f b6 84 24 f8
	00 01 00	 movzx	 eax, BYTE PTR chained$[rsp]
  00294	25 80 00 00 00	 and	 eax, 128		; 00000080H
  00299	85 c0		 test	 eax, eax
  0029b	0f 85 dc 01 00
	00		 jne	 $LN43@loc3270_ex

; 4110 :         {
; 4111 :             buf[len++] = cmd;

  002a1	8b 44 24 20	 mov	 eax, DWORD PTR len$[rsp]
  002a5	0f b6 4c 24 24	 movzx	 ecx, BYTE PTR cmd$[rsp]
  002aa	88 8c 04 b0 00
	00 00		 mov	 BYTE PTR buf$[rsp+rax], cl
  002b1	8b 44 24 20	 mov	 eax, DWORD PTR len$[rsp]
  002b5	ff c0		 inc	 eax
  002b7	89 44 24 20	 mov	 DWORD PTR len$[rsp], eax

; 4112 : 
; 4113 :             /* If this is a chained write then we start at the
; 4114 :                current buffer address, not the cursor address,
; 4115 :                and if the datastream's first action isn't already
; 4116 :                a positioning action, we also insert an SBA order
; 4117 :                to reposition to that buffer address.
; 4118 :             */
; 4119 :             if (1
; 4120 :                 && (chained && R3270_WRT == cmd) // (chained write?)
; 4121 :                 && dev->pos3270 != 0             // (not positioned at beginning?)
; 4122 :                 && (1                            // (position wasn't specified?)

  002bb	33 c0		 xor	 eax, eax
  002bd	83 f8 01	 cmp	 eax, 1
  002c0	0f 84 b7 01 00
	00		 je	 $LN44@loc3270_ex
  002c6	0f b6 84 24 f8
	00 01 00	 movzx	 eax, BYTE PTR chained$[rsp]
  002ce	85 c0		 test	 eax, eax
  002d0	0f 84 a7 01 00
	00		 je	 $LN44@loc3270_ex
  002d6	0f b6 44 24 24	 movzx	 eax, BYTE PTR cmd$[rsp]
  002db	3d f1 00 00 00	 cmp	 eax, 241		; 000000f1H
  002e0	0f 85 97 01 00
	00		 jne	 $LN44@loc3270_ex
  002e6	48 8b 84 24 e0
	00 01 00	 mov	 rax, QWORD PTR dev$[rsp]
  002ee	83 b8 bc 06 00
	00 00		 cmp	 DWORD PTR [rax+1724], 0
  002f5	0f 84 82 01 00
	00		 je	 $LN44@loc3270_ex
  002fb	33 c0		 xor	 eax, eax
  002fd	83 f8 01	 cmp	 eax, 1
  00300	0f 84 77 01 00
	00		 je	 $LN44@loc3270_ex
  00306	b8 01 00 00 00	 mov	 eax, 1
  0030b	48 6b c0 01	 imul	 rax, rax, 1
  0030f	48 8b 8c 24 18
	01 01 00	 mov	 rcx, QWORD PTR iobuf$[rsp]
  00317	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  0031b	83 f8 11	 cmp	 eax, 17
  0031e	0f 84 59 01 00
	00		 je	 $LN44@loc3270_ex
  00324	b8 01 00 00 00	 mov	 eax, 1
  00329	48 6b c0 01	 imul	 rax, rax, 1
  0032d	48 8b 8c 24 18
	01 01 00	 mov	 rcx, QWORD PTR iobuf$[rsp]
  00335	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00339	83 f8 3c	 cmp	 eax, 60			; 0000003cH
  0033c	0f 84 3b 01 00
	00		 je	 $LN44@loc3270_ex
  00342	b8 01 00 00 00	 mov	 eax, 1
  00347	48 6b c0 01	 imul	 rax, rax, 1
  0034b	48 8b 8c 24 18
	01 01 00	 mov	 rcx, QWORD PTR iobuf$[rsp]
  00353	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00357	83 f8 12	 cmp	 eax, 18
  0035a	0f 84 1d 01 00
	00		 je	 $LN44@loc3270_ex

; 4123 :                     && iobuf[1] != O3270_SBA
; 4124 :                     && iobuf[1] != O3270_RA
; 4125 :                     && iobuf[1] != O3270_EUA
; 4126 :                    )
; 4127 :             )
; 4128 :             {
; 4129 :                 /* Copy the write control character and adjust buffer */
; 4130 :                 buf[len++] = *iobuf++;

  00360	8b 44 24 20	 mov	 eax, DWORD PTR len$[rsp]
  00364	48 8b 8c 24 18
	01 01 00	 mov	 rcx, QWORD PTR iobuf$[rsp]
  0036c	0f b6 09	 movzx	 ecx, BYTE PTR [rcx]
  0036f	88 8c 04 b0 00
	00 00		 mov	 BYTE PTR buf$[rsp+rax], cl
  00376	8b 44 24 20	 mov	 eax, DWORD PTR len$[rsp]
  0037a	ff c0		 inc	 eax
  0037c	89 44 24 20	 mov	 DWORD PTR len$[rsp], eax
  00380	48 8b 84 24 18
	01 01 00	 mov	 rax, QWORD PTR iobuf$[rsp]
  00388	48 ff c0	 inc	 rax
  0038b	48 89 84 24 18
	01 01 00	 mov	 QWORD PTR iobuf$[rsp], rax

; 4131 :                 num--;

  00393	8b 44 24 28	 mov	 eax, DWORD PTR num$[rsp]
  00397	ff c8		 dec	 eax
  00399	89 44 24 28	 mov	 DWORD PTR num$[rsp], eax

; 4132 : 
; 4133 :                 /* Insert the SBA order */
; 4134 :                 buf[len++] = O3270_SBA;

  0039d	8b 44 24 20	 mov	 eax, DWORD PTR len$[rsp]
  003a1	c6 84 04 b0 00
	00 00 11	 mov	 BYTE PTR buf$[rsp+rax], 17
  003a9	8b 44 24 20	 mov	 eax, DWORD PTR len$[rsp]
  003ad	ff c0		 inc	 eax
  003af	89 44 24 20	 mov	 DWORD PTR len$[rsp], eax

; 4135 : 
; 4136 :                 if (dev->pos3270 < 4096)

  003b3	48 8b 84 24 e0
	00 01 00	 mov	 rax, QWORD PTR dev$[rsp]
  003bb	81 b8 bc 06 00
	00 00 10 00 00	 cmp	 DWORD PTR [rax+1724], 4096 ; 00001000H
  003c5	7d 68		 jge	 SHORT $LN45@loc3270_ex

; 4137 :                 {
; 4138 :                     buf[len++] = sba_code[ dev->pos3270 >> 6 ];

  003c7	48 8b 84 24 e0
	00 01 00	 mov	 rax, QWORD PTR dev$[rsp]
  003cf	8b 80 bc 06 00
	00		 mov	 eax, DWORD PTR [rax+1724]
  003d5	c1 f8 06	 sar	 eax, 6
  003d8	48 98		 cdqe
  003da	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:sba_code
  003e1	8b 54 24 20	 mov	 edx, DWORD PTR len$[rsp]
  003e5	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  003e9	88 84 14 b0 00
	00 00		 mov	 BYTE PTR buf$[rsp+rdx], al
  003f0	8b 44 24 20	 mov	 eax, DWORD PTR len$[rsp]
  003f4	ff c0		 inc	 eax
  003f6	89 44 24 20	 mov	 DWORD PTR len$[rsp], eax

; 4139 :                     buf[len++] = sba_code[ dev->pos3270 & 0x3F ];

  003fa	48 8b 84 24 e0
	00 01 00	 mov	 rax, QWORD PTR dev$[rsp]
  00402	8b 80 bc 06 00
	00		 mov	 eax, DWORD PTR [rax+1724]
  00408	83 e0 3f	 and	 eax, 63			; 0000003fH
  0040b	48 98		 cdqe
  0040d	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:sba_code
  00414	8b 54 24 20	 mov	 edx, DWORD PTR len$[rsp]
  00418	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  0041c	88 84 14 b0 00
	00 00		 mov	 BYTE PTR buf$[rsp+rdx], al
  00423	8b 44 24 20	 mov	 eax, DWORD PTR len$[rsp]
  00427	ff c0		 inc	 eax
  00429	89 44 24 20	 mov	 DWORD PTR len$[rsp], eax

; 4140 :                 }

  0042d	eb 4e		 jmp	 SHORT $LN46@loc3270_ex
$LN45@loc3270_ex:

; 4141 :                 else // (pos3270 >= 4096)
; 4142 :                 {
; 4143 :                     buf[len++] = dev->pos3270 >> 8;

  0042f	48 8b 84 24 e0
	00 01 00	 mov	 rax, QWORD PTR dev$[rsp]
  00437	8b 80 bc 06 00
	00		 mov	 eax, DWORD PTR [rax+1724]
  0043d	c1 f8 08	 sar	 eax, 8
  00440	8b 4c 24 20	 mov	 ecx, DWORD PTR len$[rsp]
  00444	88 84 0c b0 00
	00 00		 mov	 BYTE PTR buf$[rsp+rcx], al
  0044b	8b 44 24 20	 mov	 eax, DWORD PTR len$[rsp]
  0044f	ff c0		 inc	 eax
  00451	89 44 24 20	 mov	 DWORD PTR len$[rsp], eax

; 4144 :                     buf[len++] = dev->pos3270 & 0xFF;

  00455	48 8b 84 24 e0
	00 01 00	 mov	 rax, QWORD PTR dev$[rsp]
  0045d	8b 80 bc 06 00
	00		 mov	 eax, DWORD PTR [rax+1724]
  00463	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  00468	8b 4c 24 20	 mov	 ecx, DWORD PTR len$[rsp]
  0046c	88 84 0c b0 00
	00 00		 mov	 BYTE PTR buf$[rsp+rcx], al
  00473	8b 44 24 20	 mov	 eax, DWORD PTR len$[rsp]
  00477	ff c0		 inc	 eax
  00479	89 44 24 20	 mov	 DWORD PTR len$[rsp], eax
$LN46@loc3270_ex:
$LN44@loc3270_ex:
$LN43@loc3270_ex:

; 4145 :                 }
; 4146 :             }
; 4147 :         }
; 4148 : 
; 4149 :         /* Save the screen position at completion of the write.
; 4150 :            This is necessary in case a Read Buffer command is
; 4151 :            chained from another write or read.  Note that this
; 4152 :            does NOT apply for the Write Structured Field cmd.
; 4153 :         */
; 4154 :         if (cmd != R3270_WSF)

  0047d	0f b6 44 24 24	 movzx	 eax, BYTE PTR cmd$[rsp]
  00482	3d f3 00 00 00	 cmp	 eax, 243		; 000000f3H
  00487	0f 84 bb 00 00
	00		 je	 $LN47@loc3270_ex

; 4155 :         {
; 4156 :             dev->pos3270 = end_of_buf_pos

  0048d	0f b6 84 24 f8
	00 01 00	 movzx	 eax, BYTE PTR chained$[rsp]
  00495	25 80 00 00 00	 and	 eax, 128		; 00000080H
  0049a	85 c0		 test	 eax, eax
  0049c	75 0a		 jne	 SHORT $LN89@loc3270_ex
  0049e	c7 44 24 44 01
	00 00 00	 mov	 DWORD PTR tv214[rsp], 1
  004a6	eb 08		 jmp	 SHORT $LN90@loc3270_ex
$LN89@loc3270_ex:
  004a8	c7 44 24 44 00
	00 00 00	 mov	 DWORD PTR tv214[rsp], 0
$LN90@loc3270_ex:
  004b0	83 7c 24 44 00	 cmp	 DWORD PTR tv214[rsp], 0
  004b5	74 0c		 je	 SHORT $LN91@loc3270_ex
  004b7	8b 44 24 28	 mov	 eax, DWORD PTR num$[rsp]
  004bb	ff c8		 dec	 eax
  004bd	89 44 24 4c	 mov	 DWORD PTR tv217[rsp], eax
  004c1	eb 08		 jmp	 SHORT $LN92@loc3270_ex
$LN91@loc3270_ex:
  004c3	8b 44 24 28	 mov	 eax, DWORD PTR num$[rsp]
  004c7	89 44 24 4c	 mov	 DWORD PTR tv217[rsp], eax
$LN92@loc3270_ex:
  004cb	0f b6 84 24 f8
	00 01 00	 movzx	 eax, BYTE PTR chained$[rsp]
  004d3	25 80 00 00 00	 and	 eax, 128		; 00000080H
  004d8	85 c0		 test	 eax, eax
  004da	75 0a		 jne	 SHORT $LN93@loc3270_ex
  004dc	c7 44 24 48 01
	00 00 00	 mov	 DWORD PTR tv222[rsp], 1
  004e4	eb 08		 jmp	 SHORT $LN94@loc3270_ex
$LN93@loc3270_ex:
  004e6	c7 44 24 48 00
	00 00 00	 mov	 DWORD PTR tv222[rsp], 0
$LN94@loc3270_ex:
  004ee	83 7c 24 48 00	 cmp	 DWORD PTR tv222[rsp], 0
  004f3	74 15		 je	 SHORT $LN95@loc3270_ex
  004f5	48 8b 84 24 18
	01 01 00	 mov	 rax, QWORD PTR iobuf$[rsp]
  004fd	48 ff c0	 inc	 rax
  00500	48 89 84 24 88
	00 00 00	 mov	 QWORD PTR tv225[rsp], rax
  00508	eb 10		 jmp	 SHORT $LN96@loc3270_ex
$LN95@loc3270_ex:
  0050a	48 8b 84 24 18
	01 01 00	 mov	 rax, QWORD PTR iobuf$[rsp]
  00512	48 89 84 24 88
	00 00 00	 mov	 QWORD PTR tv225[rsp], rax
$LN96@loc3270_ex:
  0051a	44 8b 44 24 4c	 mov	 r8d, DWORD PTR tv217[rsp]
  0051f	48 8b 94 24 88
	00 00 00	 mov	 rdx, QWORD PTR tv225[rsp]
  00527	48 8b 84 24 e0
	00 01 00	 mov	 rax, QWORD PTR dev$[rsp]
  0052f	8b 88 bc 06 00
	00		 mov	 ecx, DWORD PTR [rax+1724]
  00535	e8 00 00 00 00	 call	 end_of_buf_pos
  0053a	48 8b 8c 24 e0
	00 01 00	 mov	 rcx, QWORD PTR dev$[rsp]
  00542	89 81 bc 06 00
	00		 mov	 DWORD PTR [rcx+1724], eax
$LN47@loc3270_ex:

; 4157 :             (
; 4158 :                 dev->pos3270,
; 4159 :                 //                           CD       not CD
; 4160 :                 !(chained & CCW_FLAGS_CD) ? iobuf+1 : iobuf,
; 4161 :                 !(chained & CCW_FLAGS_CD) ? num-1   : num
; 4162 :             );
; 4163 :         }
; 4164 : 
; 4165 :         /* Copy data from channel buffer to device buffer */
; 4166 :         memcpy( buf + len, iobuf, num );

  00548	8b 44 24 28	 mov	 eax, DWORD PTR num$[rsp]
  0054c	8b 4c 24 20	 mov	 ecx, DWORD PTR len$[rsp]
  00550	48 8d 8c 0c b0
	00 00 00	 lea	 rcx, QWORD PTR buf$[rsp+rcx]
  00558	48 8b f9	 mov	 rdi, rcx
  0055b	48 8b b4 24 18
	01 01 00	 mov	 rsi, QWORD PTR iobuf$[rsp]
  00563	8b c8		 mov	 ecx, eax
  00565	f3 a4		 rep movsb

; 4167 :         len += num;

  00567	8b 44 24 28	 mov	 eax, DWORD PTR num$[rsp]
  0056b	8b 4c 24 20	 mov	 ecx, DWORD PTR len$[rsp]
  0056f	03 c8		 add	 ecx, eax
  00571	8b c1		 mov	 eax, ecx
  00573	89 44 24 20	 mov	 DWORD PTR len$[rsp], eax

; 4168 : 
; 4169 :         /* Send the data to the client */
; 4170 :         if (!sendto_client( dev->tn, buf, len ))

  00577	44 8b 44 24 20	 mov	 r8d, DWORD PTR len$[rsp]
  0057c	48 8d 94 24 b0
	00 00 00	 lea	 rdx, QWORD PTR buf$[rsp]
  00584	48 8b 84 24 e0
	00 01 00	 mov	 rax, QWORD PTR dev$[rsp]
  0058c	48 8b 88 b0 06
	00 00		 mov	 rcx, QWORD PTR [rax+1712]
  00593	e8 00 00 00 00	 call	 sendto_client
  00598	0f b6 c0	 movzx	 eax, al
  0059b	85 c0		 test	 eax, eax
  0059d	75 29		 jne	 SHORT $LN48@loc3270_ex

; 4171 :         {
; 4172 :             /* Return with Unit Check status if the send failed */
; 4173 :             dev->sense[0] = SENSE_DC;

  0059f	b8 01 00 00 00	 mov	 eax, 1
  005a4	48 6b c0 00	 imul	 rax, rax, 0
  005a8	48 8b 8c 24 e0
	00 01 00	 mov	 rcx, QWORD PTR dev$[rsp]
  005b0	c6 84 01 64 03
	00 00 08	 mov	 BYTE PTR [rcx+rax+868], 8

; 4174 :             *unitstat = CSW_CE | CSW_DE | CSW_UC;

  005b8	48 8b 84 24 28
	01 01 00	 mov	 rax, QWORD PTR unitstat$[rsp]
  005c0	c6 00 0e	 mov	 BYTE PTR [rax], 14

; 4175 :             break;

  005c3	e9 1d 0d 00 00	 jmp	 $LN8@loc3270_ex
$LN48@loc3270_ex:

; 4176 :         }
; 4177 : 
; 4178 :         /* Return normal status */
; 4179 :         *unitstat = CSW_CE | CSW_DE;

  005c8	48 8b 84 24 28
	01 01 00	 mov	 rax, QWORD PTR unitstat$[rsp]
  005d0	c6 00 0c	 mov	 BYTE PTR [rax], 12

; 4180 :         break;

  005d3	e9 0d 0d 00 00	 jmp	 $LN8@loc3270_ex
$LN49@loc3270_ex:

; 4181 : 
; 4182 :     case L3270_RB:
; 4183 :     /*---------------------------------------------------------------*/
; 4184 :     /* READ BUFFER                                                   */
; 4185 :     /*---------------------------------------------------------------*/
; 4186 :         /* Obtain the device lock */
; 4187 :         obtain_lock (&dev->lock);

  005d8	48 8b 84 24 e0
	00 01 00	 mov	 rax, QWORD PTR dev$[rsp]
  005e0	48 83 c0 38	 add	 rax, 56			; 00000038H
  005e4	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG179562
  005eb	48 8b c8	 mov	 rcx, rax
  005ee	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_obtain_lock

; 4188 : 
; 4189 :         /* AID is only present during the first read */
; 4190 :         aid = dev->readpending != 2;

  005f4	48 8b 84 24 e0
	00 01 00	 mov	 rax, QWORD PTR dev$[rsp]
  005fc	8b 80 f8 05 00
	00		 mov	 eax, DWORD PTR [rax+1528]
  00602	c1 e8 06	 shr	 eax, 6
  00605	83 e0 03	 and	 eax, 3
  00608	83 f8 02	 cmp	 eax, 2
  0060b	74 0a		 je	 SHORT $LN97@loc3270_ex
  0060d	c7 44 24 50 01
	00 00 00	 mov	 DWORD PTR tv255[rsp], 1
  00615	eb 08		 jmp	 SHORT $LN98@loc3270_ex
$LN97@loc3270_ex:
  00617	c7 44 24 50 00
	00 00 00	 mov	 DWORD PTR tv255[rsp], 0
$LN98@loc3270_ex:
  0061f	8b 44 24 50	 mov	 eax, DWORD PTR tv255[rsp]
  00623	89 44 24 2c	 mov	 DWORD PTR aid$[rsp], eax

; 4191 :         if (dev->readpending == 3)

  00627	48 8b 84 24 e0
	00 01 00	 mov	 rax, QWORD PTR dev$[rsp]
  0062f	8b 80 f8 05 00
	00		 mov	 eax, DWORD PTR [rax+1528]
  00635	c1 e8 06	 shr	 eax, 6
  00638	83 e0 03	 and	 eax, 3
  0063b	83 f8 03	 cmp	 eax, 3
  0063e	75 2c		 jne	 SHORT $LN50@loc3270_ex

; 4192 :         {
; 4193 :             dev->readpending = 1;

  00640	48 8b 84 24 e0
	00 01 00	 mov	 rax, QWORD PTR dev$[rsp]
  00648	8b 80 f8 05 00
	00		 mov	 eax, DWORD PTR [rax+1528]
  0064e	25 3f ff ff ff	 and	 eax, -193		; ffffff3fH
  00653	83 c8 40	 or	 eax, 64			; 00000040H
  00656	48 8b 8c 24 e0
	00 01 00	 mov	 rcx, QWORD PTR dev$[rsp]
  0065e	89 81 f8 05 00
	00		 mov	 DWORD PTR [rcx+1528], eax

; 4194 :             aid = 3;

  00664	c7 44 24 2c 03
	00 00 00	 mov	 DWORD PTR aid$[rsp], 3
$LN50@loc3270_ex:

; 4195 :         }
; 4196 :         /* Receive buffer data from client if not data chained */
; 4197 :         if (!(chained & CCW_FLAGS_CD))

  0066c	0f b6 84 24 f8
	00 01 00	 movzx	 eax, BYTE PTR chained$[rsp]
  00674	25 80 00 00 00	 and	 eax, 128		; 00000080H
  00679	85 c0		 test	 eax, eax
  0067b	0f 85 80 01 00
	00		 jne	 $LN51@loc3270_ex

; 4198 :         {
; 4199 :             /* Send read buffer command to client and await response */
; 4200 :             rc = solicit_3270_data (dev, R3270_RB);

  00681	b2 f2		 mov	 dl, 242			; 000000f2H
  00683	48 8b 8c 24 e0
	00 01 00	 mov	 rcx, QWORD PTR dev$[rsp]
  0068b	e8 00 00 00 00	 call	 solicit_3270_data
  00690	0f b6 c0	 movzx	 eax, al
  00693	89 44 24 3c	 mov	 DWORD PTR rc$[rsp], eax

; 4201 :             if (rc & CSW_UC)

  00697	8b 44 24 3c	 mov	 eax, DWORD PTR rc$[rsp]
  0069b	83 e0 02	 and	 eax, 2
  0069e	85 c0		 test	 eax, eax
  006a0	74 2c		 je	 SHORT $LN53@loc3270_ex

; 4202 :             {
; 4203 :                 *unitstat = CSW_CE | CSW_DE | CSW_UC;

  006a2	48 8b 84 24 28
	01 01 00	 mov	 rax, QWORD PTR unitstat$[rsp]
  006aa	c6 00 0e	 mov	 BYTE PTR [rax], 14

; 4204 :                 release_lock (&dev->lock);

  006ad	48 8b 84 24 e0
	00 01 00	 mov	 rax, QWORD PTR dev$[rsp]
  006b5	48 83 c0 38	 add	 rax, 56			; 00000038H
  006b9	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG179567
  006c0	48 8b c8	 mov	 rcx, rax
  006c3	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_release_lock

; 4205 :                 break;

  006c9	e9 17 0c 00 00	 jmp	 $LN8@loc3270_ex
$LN53@loc3270_ex:

; 4206 :             }
; 4207 : 
; 4208 :             /* Set AID in buffer flag */
; 4209 :             aid = 1;

  006ce	c7 44 24 2c 01
	00 00 00	 mov	 DWORD PTR aid$[rsp], 1

; 4210 : 
; 4211 :             /* Save the AID of the current inbound transmission */
; 4212 :             dev->aid3270 = dev->buf[0];

  006d6	b8 01 00 00 00	 mov	 eax, 1
  006db	48 6b c0 00	 imul	 rax, rax, 0
  006df	48 8b 8c 24 e0
	00 01 00	 mov	 rcx, QWORD PTR dev$[rsp]
  006e7	48 8b 89 c8 01
	00 00		 mov	 rcx, QWORD PTR [rcx+456]
  006ee	48 8b 94 24 e0
	00 01 00	 mov	 rdx, QWORD PTR dev$[rsp]
  006f6	0f b6 04 08	 movzx	 eax, BYTE PTR [rax+rcx]
  006fa	88 82 d8 06 00
	00		 mov	 BYTE PTR [rdx+1752], al

; 4213 : 
; 4214 :             if (dev->pos3270 != 0 && dev->aid3270 != SF3270_AID)

  00700	48 8b 84 24 e0
	00 01 00	 mov	 rax, QWORD PTR dev$[rsp]
  00708	83 b8 bc 06 00
	00 00		 cmp	 DWORD PTR [rax+1724], 0
  0070f	0f 84 ea 00 00
	00		 je	 $LN54@loc3270_ex
  00715	48 8b 84 24 e0
	00 01 00	 mov	 rax, QWORD PTR dev$[rsp]
  0071d	0f b6 80 d8 06
	00 00		 movzx	 eax, BYTE PTR [rax+1752]
  00724	3d 88 00 00 00	 cmp	 eax, 136		; 00000088H
  00729	0f 84 d0 00 00
	00		 je	 $LN54@loc3270_ex

; 4215 :             {
; 4216 :                 /* Find offset in buffer of current screen position */
; 4217 :                 off = pos_to_buff_offset( dev->pos3270,

  0072f	48 8b 84 24 e0
	00 01 00	 mov	 rax, QWORD PTR dev$[rsp]
  00737	44 8b 80 b8 06
	00 00		 mov	 r8d, DWORD PTR [rax+1720]
  0073e	48 8b 84 24 e0
	00 01 00	 mov	 rax, QWORD PTR dev$[rsp]
  00746	48 8b 90 c8 01
	00 00		 mov	 rdx, QWORD PTR [rax+456]
  0074d	48 8b 84 24 e0
	00 01 00	 mov	 rax, QWORD PTR dev$[rsp]
  00755	8b 88 bc 06 00
	00		 mov	 ecx, DWORD PTR [rax+1724]
  0075b	e8 00 00 00 00	 call	 pos_to_buff_offset
  00760	89 44 24 34	 mov	 DWORD PTR off$[rsp], eax

; 4218 :                     dev->buf, dev->rlen3270 );
; 4219 : 
; 4220 :                 /* Shift out unwanted characters from buffer */
; 4221 :                 num = (dev->rlen3270 > off ? dev->rlen3270 - off : 0);

  00764	48 8b 84 24 e0
	00 01 00	 mov	 rax, QWORD PTR dev$[rsp]
  0076c	8b 4c 24 34	 mov	 ecx, DWORD PTR off$[rsp]
  00770	39 88 b8 06 00
	00		 cmp	 DWORD PTR [rax+1720], ecx
  00776	76 1a		 jbe	 SHORT $LN99@loc3270_ex
  00778	48 8b 84 24 e0
	00 01 00	 mov	 rax, QWORD PTR dev$[rsp]
  00780	8b 4c 24 34	 mov	 ecx, DWORD PTR off$[rsp]
  00784	8b 80 b8 06 00
	00		 mov	 eax, DWORD PTR [rax+1720]
  0078a	2b c1		 sub	 eax, ecx
  0078c	89 44 24 54	 mov	 DWORD PTR tv296[rsp], eax
  00790	eb 08		 jmp	 SHORT $LN100@loc3270_ex
$LN99@loc3270_ex:
  00792	c7 44 24 54 00
	00 00 00	 mov	 DWORD PTR tv296[rsp], 0
$LN100@loc3270_ex:
  0079a	8b 44 24 54	 mov	 eax, DWORD PTR tv296[rsp]
  0079e	89 44 24 28	 mov	 DWORD PTR num$[rsp], eax

; 4222 :                 memmove (dev->buf + 3, dev->buf + off, num);

  007a2	8b 44 24 28	 mov	 eax, DWORD PTR num$[rsp]
  007a6	8b 4c 24 34	 mov	 ecx, DWORD PTR off$[rsp]
  007aa	48 8b 94 24 e0
	00 01 00	 mov	 rdx, QWORD PTR dev$[rsp]
  007b2	48 03 8a c8 01
	00 00		 add	 rcx, QWORD PTR [rdx+456]
  007b9	48 8b 94 24 e0
	00 01 00	 mov	 rdx, QWORD PTR dev$[rsp]
  007c1	48 8b 92 c8 01
	00 00		 mov	 rdx, QWORD PTR [rdx+456]
  007c8	48 83 c2 03	 add	 rdx, 3
  007cc	48 89 94 24 a0
	00 00 00	 mov	 QWORD PTR tv305[rsp], rdx
  007d4	44 8b c0	 mov	 r8d, eax
  007d7	48 8b d1	 mov	 rdx, rcx
  007da	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR tv305[rsp]
  007e2	48 8b c8	 mov	 rcx, rax
  007e5	e8 00 00 00 00	 call	 memmove

; 4223 :                 dev->rlen3270 = 3 + num;

  007ea	8b 44 24 28	 mov	 eax, DWORD PTR num$[rsp]
  007ee	83 c0 03	 add	 eax, 3
  007f1	48 8b 8c 24 e0
	00 01 00	 mov	 rcx, QWORD PTR dev$[rsp]
  007f9	89 81 b8 06 00
	00		 mov	 DWORD PTR [rcx+1720], eax
$LN54@loc3270_ex:

; 4224 :             }
; 4225 :         }

  007ff	eb 08		 jmp	 SHORT $LN52@loc3270_ex
$LN51@loc3270_ex:

; 4226 : 
; 4227 :         else aid = 0;

  00801	c7 44 24 2c 00
	00 00 00	 mov	 DWORD PTR aid$[rsp], 0
$LN52@loc3270_ex:

; 4228 : 
; 4229 :         /* Calculate number of bytes to move and residual byte count */
; 4230 :         len = dev->rlen3270;

  00809	48 8b 84 24 e0
	00 01 00	 mov	 rax, QWORD PTR dev$[rsp]
  00811	8b 80 b8 06 00
	00		 mov	 eax, DWORD PTR [rax+1720]
  00817	89 44 24 20	 mov	 DWORD PTR len$[rsp], eax

; 4231 :         num = (count < len) ? count : len;

  0081b	8b 44 24 20	 mov	 eax, DWORD PTR len$[rsp]
  0081f	39 84 24 00 01
	01 00		 cmp	 DWORD PTR count$[rsp], eax
  00826	73 0d		 jae	 SHORT $LN101@loc3270_ex
  00828	8b 84 24 00 01
	01 00		 mov	 eax, DWORD PTR count$[rsp]
  0082f	89 44 24 58	 mov	 DWORD PTR tv310[rsp], eax
  00833	eb 08		 jmp	 SHORT $LN102@loc3270_ex
$LN101@loc3270_ex:
  00835	8b 44 24 20	 mov	 eax, DWORD PTR len$[rsp]
  00839	89 44 24 58	 mov	 DWORD PTR tv310[rsp], eax
$LN102@loc3270_ex:
  0083d	8b 44 24 58	 mov	 eax, DWORD PTR tv310[rsp]
  00841	89 44 24 28	 mov	 DWORD PTR num$[rsp], eax

; 4232 :         *residual = count - num;

  00845	8b 44 24 28	 mov	 eax, DWORD PTR num$[rsp]
  00849	8b 8c 24 00 01
	01 00		 mov	 ecx, DWORD PTR count$[rsp]
  00850	2b c8		 sub	 ecx, eax
  00852	8b c1		 mov	 eax, ecx
  00854	48 8b 8c 24 30
	01 01 00	 mov	 rcx, QWORD PTR residual$[rsp]
  0085c	89 01		 mov	 DWORD PTR [rcx], eax

; 4233 :         if (count < len) *more = 1;

  0085e	8b 44 24 20	 mov	 eax, DWORD PTR len$[rsp]
  00862	39 84 24 00 01
	01 00		 cmp	 DWORD PTR count$[rsp], eax
  00869	73 0b		 jae	 SHORT $LN55@loc3270_ex
  0086b	48 8b 84 24 20
	01 01 00	 mov	 rax, QWORD PTR more$[rsp]
  00873	c6 00 01	 mov	 BYTE PTR [rax], 1
$LN55@loc3270_ex:

; 4234 : 
; 4235 :         /*  Save the screen position at completion of the read.
; 4236 :            This is necessary in case a Read Buffer command is chained
; 4237 :            from another write or read.
; 4238 :         */
; 4239 :         if (dev->aid3270 != SF3270_AID)

  00876	48 8b 84 24 e0
	00 01 00	 mov	 rax, QWORD PTR dev$[rsp]
  0087e	0f b6 80 d8 06
	00 00		 movzx	 eax, BYTE PTR [rax+1752]
  00885	3d 88 00 00 00	 cmp	 eax, 136		; 00000088H
  0088a	0f 84 85 00 00
	00		 je	 $LN56@loc3270_ex

; 4240 :         {
; 4241 :             dev->pos3270 = end_of_buf_pos( dev->pos3270,

  00890	83 7c 24 2c 00	 cmp	 DWORD PTR aid$[rsp], 0
  00895	74 0d		 je	 SHORT $LN103@loc3270_ex
  00897	8b 44 24 28	 mov	 eax, DWORD PTR num$[rsp]
  0089b	83 e8 03	 sub	 eax, 3
  0089e	89 44 24 5c	 mov	 DWORD PTR tv320[rsp], eax
  008a2	eb 08		 jmp	 SHORT $LN104@loc3270_ex
$LN103@loc3270_ex:
  008a4	8b 44 24 28	 mov	 eax, DWORD PTR num$[rsp]
  008a8	89 44 24 5c	 mov	 DWORD PTR tv320[rsp], eax
$LN104@loc3270_ex:
  008ac	83 7c 24 2c 00	 cmp	 DWORD PTR aid$[rsp], 0
  008b1	74 1d		 je	 SHORT $LN105@loc3270_ex
  008b3	48 8b 84 24 e0
	00 01 00	 mov	 rax, QWORD PTR dev$[rsp]
  008bb	48 8b 80 c8 01
	00 00		 mov	 rax, QWORD PTR [rax+456]
  008c2	48 83 c0 03	 add	 rax, 3
  008c6	48 89 84 24 90
	00 00 00	 mov	 QWORD PTR tv326[rsp], rax
  008ce	eb 17		 jmp	 SHORT $LN106@loc3270_ex
$LN105@loc3270_ex:
  008d0	48 8b 84 24 e0
	00 01 00	 mov	 rax, QWORD PTR dev$[rsp]
  008d8	48 8b 80 c8 01
	00 00		 mov	 rax, QWORD PTR [rax+456]
  008df	48 89 84 24 90
	00 00 00	 mov	 QWORD PTR tv326[rsp], rax
$LN106@loc3270_ex:
  008e7	44 8b 44 24 5c	 mov	 r8d, DWORD PTR tv320[rsp]
  008ec	48 8b 94 24 90
	00 00 00	 mov	 rdx, QWORD PTR tv326[rsp]
  008f4	48 8b 84 24 e0
	00 01 00	 mov	 rax, QWORD PTR dev$[rsp]
  008fc	8b 88 bc 06 00
	00		 mov	 ecx, DWORD PTR [rax+1724]
  00902	e8 00 00 00 00	 call	 end_of_buf_pos
  00907	48 8b 8c 24 e0
	00 01 00	 mov	 rcx, QWORD PTR dev$[rsp]
  0090f	89 81 bc 06 00
	00		 mov	 DWORD PTR [rcx+1724], eax
$LN56@loc3270_ex:

; 4242 :                 //    (aid)        (!aid)
; 4243 :                 aid ? dev->buf+3 : dev->buf,
; 4244 :                 aid ? num-3      : num
; 4245 :             );
; 4246 :         }
; 4247 : 
; 4248 :         /* Indicate that the AID bytes have been skipped */
; 4249 :         if (dev->readpending == 1)

  00915	48 8b 84 24 e0
	00 01 00	 mov	 rax, QWORD PTR dev$[rsp]
  0091d	8b 80 f8 05 00
	00		 mov	 eax, DWORD PTR [rax+1528]
  00923	c1 e8 06	 shr	 eax, 6
  00926	83 e0 03	 and	 eax, 3
  00929	83 f8 01	 cmp	 eax, 1
  0092c	75 25		 jne	 SHORT $LN57@loc3270_ex

; 4250 :             dev->readpending = 2;

  0092e	48 8b 84 24 e0
	00 01 00	 mov	 rax, QWORD PTR dev$[rsp]
  00936	8b 80 f8 05 00
	00		 mov	 eax, DWORD PTR [rax+1528]
  0093c	25 3f ff ff ff	 and	 eax, -193		; ffffff3fH
  00941	0f ba e8 07	 bts	 eax, 7
  00945	48 8b 8c 24 e0
	00 01 00	 mov	 rcx, QWORD PTR dev$[rsp]
  0094d	89 81 f8 05 00
	00		 mov	 DWORD PTR [rcx+1528], eax
$LN57@loc3270_ex:

; 4251 : 
; 4252 :         /* Copy data from device buffer to channel buffer */
; 4253 :         memcpy (iobuf, dev->buf, num);

  00953	8b 44 24 28	 mov	 eax, DWORD PTR num$[rsp]
  00957	48 8b 8c 24 e0
	00 01 00	 mov	 rcx, QWORD PTR dev$[rsp]
  0095f	48 8b bc 24 18
	01 01 00	 mov	 rdi, QWORD PTR iobuf$[rsp]
  00967	48 8b b1 c8 01
	00 00		 mov	 rsi, QWORD PTR [rcx+456]
  0096e	8b c8		 mov	 ecx, eax
  00970	f3 a4		 rep movsb

; 4254 : 
; 4255 :         /* If data chaining is specified, save remaining data */
; 4256 :         if ((flags & CCW_FLAGS_CD) && len > count)

  00972	0f b6 84 24 f0
	00 01 00	 movzx	 eax, BYTE PTR flags$[rsp]
  0097a	25 80 00 00 00	 and	 eax, 128		; 00000080H
  0097f	85 c0		 test	 eax, eax
  00981	74 6d		 je	 SHORT $LN58@loc3270_ex
  00983	8b 84 24 00 01
	01 00		 mov	 eax, DWORD PTR count$[rsp]
  0098a	39 44 24 20	 cmp	 DWORD PTR len$[rsp], eax
  0098e	76 60		 jbe	 SHORT $LN58@loc3270_ex

; 4257 :         {
; 4258 :             memmove (dev->buf, dev->buf + count, len - count);

  00990	8b 84 24 00 01
	01 00		 mov	 eax, DWORD PTR count$[rsp]
  00997	8b 4c 24 20	 mov	 ecx, DWORD PTR len$[rsp]
  0099b	2b c8		 sub	 ecx, eax
  0099d	8b c1		 mov	 eax, ecx
  0099f	8b c0		 mov	 eax, eax
  009a1	8b 8c 24 00 01
	01 00		 mov	 ecx, DWORD PTR count$[rsp]
  009a8	48 8b 94 24 e0
	00 01 00	 mov	 rdx, QWORD PTR dev$[rsp]
  009b0	48 03 8a c8 01
	00 00		 add	 rcx, QWORD PTR [rdx+456]
  009b7	44 8b c0	 mov	 r8d, eax
  009ba	48 8b d1	 mov	 rdx, rcx
  009bd	48 8b 84 24 e0
	00 01 00	 mov	 rax, QWORD PTR dev$[rsp]
  009c5	48 8b 88 c8 01
	00 00		 mov	 rcx, QWORD PTR [rax+456]
  009cc	e8 00 00 00 00	 call	 memmove

; 4259 :             dev->rlen3270 = len - count;

  009d1	8b 84 24 00 01
	01 00		 mov	 eax, DWORD PTR count$[rsp]
  009d8	8b 4c 24 20	 mov	 ecx, DWORD PTR len$[rsp]
  009dc	2b c8		 sub	 ecx, eax
  009de	8b c1		 mov	 eax, ecx
  009e0	48 8b 8c 24 e0
	00 01 00	 mov	 rcx, QWORD PTR dev$[rsp]
  009e8	89 81 b8 06 00
	00		 mov	 DWORD PTR [rcx+1720], eax

; 4260 :         }

  009ee	eb 33		 jmp	 SHORT $LN59@loc3270_ex
$LN58@loc3270_ex:

; 4261 :         else
; 4262 :         {
; 4263 :             dev->rlen3270 = 0;

  009f0	48 8b 84 24 e0
	00 01 00	 mov	 rax, QWORD PTR dev$[rsp]
  009f8	c7 80 b8 06 00
	00 00 00 00 00	 mov	 DWORD PTR [rax+1720], 0

; 4264 :             dev->readpending = 0;

  00a02	48 8b 84 24 e0
	00 01 00	 mov	 rax, QWORD PTR dev$[rsp]
  00a0a	8b 80 f8 05 00
	00		 mov	 eax, DWORD PTR [rax+1528]
  00a10	25 3f ff ff ff	 and	 eax, -193		; ffffff3fH
  00a15	48 8b 8c 24 e0
	00 01 00	 mov	 rcx, QWORD PTR dev$[rsp]
  00a1d	89 81 f8 05 00
	00		 mov	 DWORD PTR [rcx+1528], eax
$LN59@loc3270_ex:

; 4265 :         }
; 4266 : 
; 4267 :         /* Return normal status */
; 4268 :         *unitstat = CSW_CE | CSW_DE;

  00a23	48 8b 84 24 28
	01 01 00	 mov	 rax, QWORD PTR unitstat$[rsp]
  00a2b	c6 00 0c	 mov	 BYTE PTR [rax], 12

; 4269 : 
; 4270 :         /* Release the device lock */
; 4271 :         release_lock (&dev->lock);

  00a2e	48 8b 84 24 e0
	00 01 00	 mov	 rax, QWORD PTR dev$[rsp]
  00a36	48 83 c0 38	 add	 rax, 56			; 00000038H
  00a3a	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG179574
  00a41	48 8b c8	 mov	 rcx, rax
  00a44	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_release_lock
$LN12@loc3270_ex:

; 4272 : 
; 4273 :         /* Signal connection thread to redrive its pselect loop */
; 4274 :         SIGNAL_CONSOLE_THREAD();

  00a4a	c6 44 24 30 00	 mov	 BYTE PTR c$1[rsp], 0
  00a4f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_WSAGetLastError
  00a55	89 84 24 80 00
	00 00		 mov	 DWORD PTR saved_errno$5[rsp], eax
  00a5c	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00a63	48 05 c0 10 00
	00		 add	 rax, 4288		; 000010c0H
  00a69	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG179575
  00a70	48 8b c8	 mov	 rcx, rax
  00a73	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_obtain_lock
  00a79	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00a80	8b 80 c8 10 00
	00		 mov	 eax, DWORD PTR [rax+4296]
  00a86	89 44 24 60	 mov	 DWORD PTR f$3[rsp], eax
  00a8a	83 7c 24 60 00	 cmp	 DWORD PTR f$3[rsp], 0
  00a8f	7f 11		 jg	 SHORT $LN60@loc3270_ex
  00a91	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00a98	c7 80 c8 10 00
	00 01 00 00 00	 mov	 DWORD PTR [rax+4296], 1
$LN60@loc3270_ex:
  00aa2	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00aa9	48 05 c0 10 00
	00		 add	 rax, 4288		; 000010c0H
  00aaf	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG179577
  00ab6	48 8b c8	 mov	 rcx, rax
  00ab9	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_release_lock
  00abf	83 7c 24 60 00	 cmp	 DWORD PTR f$3[rsp], 0
  00ac4	0f 8f 90 00 00
	00		 jg	 $LN61@loc3270_ex
$LN15@loc3270_ex:
  00aca	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00ad1	48 63 80 cc 10
	00 00		 movsxd	 rax, DWORD PTR [rax+4300]
  00ad8	45 33 c9	 xor	 r9d, r9d
  00adb	41 b8 01 00 00
	00		 mov	 r8d, 1
  00ae1	48 8d 54 24 30	 lea	 rdx, QWORD PTR c$1[rsp]
  00ae6	48 8b c8	 mov	 rcx, rax
  00ae9	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_send
  00aef	83 f8 01	 cmp	 eax, 1
  00af2	74 5c		 je	 SHORT $LN62@loc3270_ex
$LN18@loc3270_ex:
  00af4	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG179580
  00afb	41 b8 b2 10 00
	00		 mov	 r8d, 4274		; 000010b2H
  00b01	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG179581
  00b08	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG179582
  00b0f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_logmsg
  00b15	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_IsDebuggerPresent
  00b1b	85 c0		 test	 eax, eax
  00b1d	74 20		 je	 SHORT $LN63@loc3270_ex
  00b1f	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG179584
  00b26	41 b8 b2 10 00
	00		 mov	 r8d, 4274		; 000010b2H
  00b2c	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG179585
  00b33	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG179586
  00b3a	e8 00 00 00 00	 call	 DebuggerTrace
$LN63@loc3270_ex:
  00b3f	33 c0		 xor	 eax, eax
  00b41	85 c0		 test	 eax, eax
  00b43	75 af		 jne	 SHORT $LN18@loc3270_ex
  00b45	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_IsDebuggerPresent
  00b4b	85 c0		 test	 eax, eax
  00b4d	74 01		 je	 SHORT $LN64@loc3270_ex
  00b4f	cc		 int	 3
$LN64@loc3270_ex:
$LN62@loc3270_ex:
  00b50	33 c0		 xor	 eax, eax
  00b52	85 c0		 test	 eax, eax
  00b54	0f 85 70 ff ff
	ff		 jne	 $LN15@loc3270_ex
$LN61@loc3270_ex:
  00b5a	8b 8c 24 80 00
	00 00		 mov	 ecx, DWORD PTR saved_errno$5[rsp]
  00b61	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_WSASetLastError
  00b67	33 c0		 xor	 eax, eax
  00b69	85 c0		 test	 eax, eax
  00b6b	0f 85 d9 fe ff
	ff		 jne	 $LN12@loc3270_ex

; 4275 : 
; 4276 :         break;

  00b71	e9 6f 07 00 00	 jmp	 $LN8@loc3270_ex
$LN65@loc3270_ex:

; 4277 : 
; 4278 :     case L3270_RM:
; 4279 :     /*---------------------------------------------------------------*/
; 4280 :     /* READ MODIFIED                                                 */
; 4281 :     /*---------------------------------------------------------------*/
; 4282 :         /* Obtain the device lock */
; 4283 :         obtain_lock (&dev->lock);

  00b76	48 8b 84 24 e0
	00 01 00	 mov	 rax, QWORD PTR dev$[rsp]
  00b7e	48 83 c0 38	 add	 rax, 56			; 00000038H
  00b82	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG179589
  00b89	48 8b c8	 mov	 rcx, rax
  00b8c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_obtain_lock

; 4284 : 
; 4285 :         /* AID is only present during the first read */
; 4286 :         aid = dev->readpending != 2;

  00b92	48 8b 84 24 e0
	00 01 00	 mov	 rax, QWORD PTR dev$[rsp]
  00b9a	8b 80 f8 05 00
	00		 mov	 eax, DWORD PTR [rax+1528]
  00ba0	c1 e8 06	 shr	 eax, 6
  00ba3	83 e0 03	 and	 eax, 3
  00ba6	83 f8 02	 cmp	 eax, 2
  00ba9	74 0a		 je	 SHORT $LN107@loc3270_ex
  00bab	c7 44 24 64 01
	00 00 00	 mov	 DWORD PTR tv409[rsp], 1
  00bb3	eb 08		 jmp	 SHORT $LN108@loc3270_ex
$LN107@loc3270_ex:
  00bb5	c7 44 24 64 00
	00 00 00	 mov	 DWORD PTR tv409[rsp], 0
$LN108@loc3270_ex:
  00bbd	8b 44 24 64	 mov	 eax, DWORD PTR tv409[rsp]
  00bc1	89 44 24 2c	 mov	 DWORD PTR aid$[rsp], eax

; 4287 :         if (dev->readpending == 3)

  00bc5	48 8b 84 24 e0
	00 01 00	 mov	 rax, QWORD PTR dev$[rsp]
  00bcd	8b 80 f8 05 00
	00		 mov	 eax, DWORD PTR [rax+1528]
  00bd3	c1 e8 06	 shr	 eax, 6
  00bd6	83 e0 03	 and	 eax, 3
  00bd9	83 f8 03	 cmp	 eax, 3
  00bdc	75 2c		 jne	 SHORT $LN66@loc3270_ex

; 4288 :         {
; 4289 :             dev->readpending = 1;

  00bde	48 8b 84 24 e0
	00 01 00	 mov	 rax, QWORD PTR dev$[rsp]
  00be6	8b 80 f8 05 00
	00		 mov	 eax, DWORD PTR [rax+1528]
  00bec	25 3f ff ff ff	 and	 eax, -193		; ffffff3fH
  00bf1	83 c8 40	 or	 eax, 64			; 00000040H
  00bf4	48 8b 8c 24 e0
	00 01 00	 mov	 rcx, QWORD PTR dev$[rsp]
  00bfc	89 81 f8 05 00
	00		 mov	 DWORD PTR [rcx+1528], eax

; 4290 :             aid = 3;

  00c02	c7 44 24 2c 03
	00 00 00	 mov	 DWORD PTR aid$[rsp], 3
$LN66@loc3270_ex:

; 4291 :         }
; 4292 : 
; 4293 :         /* If not data chained from previous Read Modified CCW,
; 4294 :            and if the connection thread has not already accumulated
; 4295 :            a complete Read Modified record in the inbound buffer,
; 4296 :            then solicit a Read Modified operation at the client
; 4297 :         */
; 4298 :         if ((chained & CCW_FLAGS_CD) == 0
; 4299 :             && !dev->readpending)

  00c0a	0f b6 84 24 f8
	00 01 00	 movzx	 eax, BYTE PTR chained$[rsp]
  00c12	25 80 00 00 00	 and	 eax, 128		; 00000080H
  00c17	85 c0		 test	 eax, eax
  00c19	0f 85 9c 01 00
	00		 jne	 $LN67@loc3270_ex
  00c1f	48 8b 84 24 e0
	00 01 00	 mov	 rax, QWORD PTR dev$[rsp]
  00c27	8b 80 f8 05 00
	00		 mov	 eax, DWORD PTR [rax+1528]
  00c2d	c1 e8 06	 shr	 eax, 6
  00c30	83 e0 03	 and	 eax, 3
  00c33	85 c0		 test	 eax, eax
  00c35	0f 85 80 01 00
	00		 jne	 $LN67@loc3270_ex

; 4300 :         {
; 4301 :             /* Send read modified command to client, await response */
; 4302 :             rc = solicit_3270_data (dev, R3270_RM);

  00c3b	b2 f6		 mov	 dl, 246			; 000000f6H
  00c3d	48 8b 8c 24 e0
	00 01 00	 mov	 rcx, QWORD PTR dev$[rsp]
  00c45	e8 00 00 00 00	 call	 solicit_3270_data
  00c4a	0f b6 c0	 movzx	 eax, al
  00c4d	89 44 24 3c	 mov	 DWORD PTR rc$[rsp], eax

; 4303 :             if (rc & CSW_UC)

  00c51	8b 44 24 3c	 mov	 eax, DWORD PTR rc$[rsp]
  00c55	83 e0 02	 and	 eax, 2
  00c58	85 c0		 test	 eax, eax
  00c5a	74 2c		 je	 SHORT $LN69@loc3270_ex

; 4304 :             {
; 4305 :                 *unitstat = CSW_CE | CSW_DE | CSW_UC;

  00c5c	48 8b 84 24 28
	01 01 00	 mov	 rax, QWORD PTR unitstat$[rsp]
  00c64	c6 00 0e	 mov	 BYTE PTR [rax], 14

; 4306 :                 release_lock (&dev->lock);

  00c67	48 8b 84 24 e0
	00 01 00	 mov	 rax, QWORD PTR dev$[rsp]
  00c6f	48 83 c0 38	 add	 rax, 56			; 00000038H
  00c73	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG179594
  00c7a	48 8b c8	 mov	 rcx, rax
  00c7d	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_release_lock

; 4307 :                 break;

  00c83	e9 5d 06 00 00	 jmp	 $LN8@loc3270_ex
$LN69@loc3270_ex:

; 4308 :             }
; 4309 : 
; 4310 :             /* Set AID in buffer flag */
; 4311 :             aid = 1;

  00c88	c7 44 24 2c 01
	00 00 00	 mov	 DWORD PTR aid$[rsp], 1

; 4312 : 
; 4313 :             dev->aid3270 = dev->buf[0];

  00c90	b8 01 00 00 00	 mov	 eax, 1
  00c95	48 6b c0 00	 imul	 rax, rax, 0
  00c99	48 8b 8c 24 e0
	00 01 00	 mov	 rcx, QWORD PTR dev$[rsp]
  00ca1	48 8b 89 c8 01
	00 00		 mov	 rcx, QWORD PTR [rcx+456]
  00ca8	48 8b 94 24 e0
	00 01 00	 mov	 rdx, QWORD PTR dev$[rsp]
  00cb0	0f b6 04 08	 movzx	 eax, BYTE PTR [rax+rcx]
  00cb4	88 82 d8 06 00
	00		 mov	 BYTE PTR [rdx+1752], al

; 4314 : 
; 4315 :             if (dev->pos3270 != 0 && dev->aid3270 != SF3270_AID)

  00cba	48 8b 84 24 e0
	00 01 00	 mov	 rax, QWORD PTR dev$[rsp]
  00cc2	83 b8 bc 06 00
	00 00		 cmp	 DWORD PTR [rax+1724], 0
  00cc9	0f 84 ea 00 00
	00		 je	 $LN70@loc3270_ex
  00ccf	48 8b 84 24 e0
	00 01 00	 mov	 rax, QWORD PTR dev$[rsp]
  00cd7	0f b6 80 d8 06
	00 00		 movzx	 eax, BYTE PTR [rax+1752]
  00cde	3d 88 00 00 00	 cmp	 eax, 136		; 00000088H
  00ce3	0f 84 d0 00 00
	00		 je	 $LN70@loc3270_ex

; 4316 :             {
; 4317 :                 /* Find offset in buffer of current screen position */
; 4318 :                 off = pos_to_buff_offset( dev->pos3270,

  00ce9	48 8b 84 24 e0
	00 01 00	 mov	 rax, QWORD PTR dev$[rsp]
  00cf1	44 8b 80 b8 06
	00 00		 mov	 r8d, DWORD PTR [rax+1720]
  00cf8	48 8b 84 24 e0
	00 01 00	 mov	 rax, QWORD PTR dev$[rsp]
  00d00	48 8b 90 c8 01
	00 00		 mov	 rdx, QWORD PTR [rax+456]
  00d07	48 8b 84 24 e0
	00 01 00	 mov	 rax, QWORD PTR dev$[rsp]
  00d0f	8b 88 bc 06 00
	00		 mov	 ecx, DWORD PTR [rax+1724]
  00d15	e8 00 00 00 00	 call	 pos_to_buff_offset
  00d1a	89 44 24 34	 mov	 DWORD PTR off$[rsp], eax

; 4319 :                     dev->buf, dev->rlen3270 );
; 4320 : 
; 4321 :                 /* Shift out unwanted characters from buffer */
; 4322 :                 num = (dev->rlen3270 > off ? dev->rlen3270 - off : 0);

  00d1e	48 8b 84 24 e0
	00 01 00	 mov	 rax, QWORD PTR dev$[rsp]
  00d26	8b 4c 24 34	 mov	 ecx, DWORD PTR off$[rsp]
  00d2a	39 88 b8 06 00
	00		 cmp	 DWORD PTR [rax+1720], ecx
  00d30	76 1a		 jbe	 SHORT $LN109@loc3270_ex
  00d32	48 8b 84 24 e0
	00 01 00	 mov	 rax, QWORD PTR dev$[rsp]
  00d3a	8b 4c 24 34	 mov	 ecx, DWORD PTR off$[rsp]
  00d3e	8b 80 b8 06 00
	00		 mov	 eax, DWORD PTR [rax+1720]
  00d44	2b c1		 sub	 eax, ecx
  00d46	89 44 24 68	 mov	 DWORD PTR tv454[rsp], eax
  00d4a	eb 08		 jmp	 SHORT $LN110@loc3270_ex
$LN109@loc3270_ex:
  00d4c	c7 44 24 68 00
	00 00 00	 mov	 DWORD PTR tv454[rsp], 0
$LN110@loc3270_ex:
  00d54	8b 44 24 68	 mov	 eax, DWORD PTR tv454[rsp]
  00d58	89 44 24 28	 mov	 DWORD PTR num$[rsp], eax

; 4323 :                 memmove (dev->buf + 3, dev->buf + off, num);

  00d5c	8b 44 24 28	 mov	 eax, DWORD PTR num$[rsp]
  00d60	8b 4c 24 34	 mov	 ecx, DWORD PTR off$[rsp]
  00d64	48 8b 94 24 e0
	00 01 00	 mov	 rdx, QWORD PTR dev$[rsp]
  00d6c	48 03 8a c8 01
	00 00		 add	 rcx, QWORD PTR [rdx+456]
  00d73	48 8b 94 24 e0
	00 01 00	 mov	 rdx, QWORD PTR dev$[rsp]
  00d7b	48 8b 92 c8 01
	00 00		 mov	 rdx, QWORD PTR [rdx+456]
  00d82	48 83 c2 03	 add	 rdx, 3
  00d86	48 89 94 24 a8
	00 00 00	 mov	 QWORD PTR tv463[rsp], rdx
  00d8e	44 8b c0	 mov	 r8d, eax
  00d91	48 8b d1	 mov	 rdx, rcx
  00d94	48 8b 84 24 a8
	00 00 00	 mov	 rax, QWORD PTR tv463[rsp]
  00d9c	48 8b c8	 mov	 rcx, rax
  00d9f	e8 00 00 00 00	 call	 memmove

; 4324 :                 dev->rlen3270 = 3 + num;

  00da4	8b 44 24 28	 mov	 eax, DWORD PTR num$[rsp]
  00da8	83 c0 03	 add	 eax, 3
  00dab	48 8b 8c 24 e0
	00 01 00	 mov	 rcx, QWORD PTR dev$[rsp]
  00db3	89 81 b8 06 00
	00		 mov	 DWORD PTR [rcx+1720], eax
$LN70@loc3270_ex:

; 4325 :             }
; 4326 :         }

  00db9	eb 08		 jmp	 SHORT $LN68@loc3270_ex
$LN67@loc3270_ex:

; 4327 : 
; 4328 :         else aid = 0;

  00dbb	c7 44 24 2c 00
	00 00 00	 mov	 DWORD PTR aid$[rsp], 0
$LN68@loc3270_ex:

; 4329 : 
; 4330 :         /* Calculate number of bytes to move and residual byte count */
; 4331 :         len = dev->rlen3270;

  00dc3	48 8b 84 24 e0
	00 01 00	 mov	 rax, QWORD PTR dev$[rsp]
  00dcb	8b 80 b8 06 00
	00		 mov	 eax, DWORD PTR [rax+1720]
  00dd1	89 44 24 20	 mov	 DWORD PTR len$[rsp], eax

; 4332 :         num = (count < len) ? count : len;

  00dd5	8b 44 24 20	 mov	 eax, DWORD PTR len$[rsp]
  00dd9	39 84 24 00 01
	01 00		 cmp	 DWORD PTR count$[rsp], eax
  00de0	73 0d		 jae	 SHORT $LN111@loc3270_ex
  00de2	8b 84 24 00 01
	01 00		 mov	 eax, DWORD PTR count$[rsp]
  00de9	89 44 24 6c	 mov	 DWORD PTR tv468[rsp], eax
  00ded	eb 08		 jmp	 SHORT $LN112@loc3270_ex
$LN111@loc3270_ex:
  00def	8b 44 24 20	 mov	 eax, DWORD PTR len$[rsp]
  00df3	89 44 24 6c	 mov	 DWORD PTR tv468[rsp], eax
$LN112@loc3270_ex:
  00df7	8b 44 24 6c	 mov	 eax, DWORD PTR tv468[rsp]
  00dfb	89 44 24 28	 mov	 DWORD PTR num$[rsp], eax

; 4333 :         *residual = count - num;

  00dff	8b 44 24 28	 mov	 eax, DWORD PTR num$[rsp]
  00e03	8b 8c 24 00 01
	01 00		 mov	 ecx, DWORD PTR count$[rsp]
  00e0a	2b c8		 sub	 ecx, eax
  00e0c	8b c1		 mov	 eax, ecx
  00e0e	48 8b 8c 24 30
	01 01 00	 mov	 rcx, QWORD PTR residual$[rsp]
  00e16	89 01		 mov	 DWORD PTR [rcx], eax

; 4334 :         if (count < len) *more = 1;

  00e18	8b 44 24 20	 mov	 eax, DWORD PTR len$[rsp]
  00e1c	39 84 24 00 01
	01 00		 cmp	 DWORD PTR count$[rsp], eax
  00e23	73 0b		 jae	 SHORT $LN71@loc3270_ex
  00e25	48 8b 84 24 20
	01 01 00	 mov	 rax, QWORD PTR more$[rsp]
  00e2d	c6 00 01	 mov	 BYTE PTR [rax], 1
$LN71@loc3270_ex:

; 4335 : 
; 4336 :         /*  Save the screen position at completion of the read.
; 4337 :            This is necessary in case a Read Buffer command is chained
; 4338 :            from another write or read.
; 4339 :         */
; 4340 :         if (dev->aid3270 != SF3270_AID)

  00e30	48 8b 84 24 e0
	00 01 00	 mov	 rax, QWORD PTR dev$[rsp]
  00e38	0f b6 80 d8 06
	00 00		 movzx	 eax, BYTE PTR [rax+1752]
  00e3f	3d 88 00 00 00	 cmp	 eax, 136		; 00000088H
  00e44	0f 84 85 00 00
	00		 je	 $LN72@loc3270_ex

; 4341 :         {
; 4342 :             dev->pos3270 = end_of_buf_pos( dev->pos3270,

  00e4a	83 7c 24 2c 00	 cmp	 DWORD PTR aid$[rsp], 0
  00e4f	74 0d		 je	 SHORT $LN113@loc3270_ex
  00e51	8b 44 24 28	 mov	 eax, DWORD PTR num$[rsp]
  00e55	83 e8 03	 sub	 eax, 3
  00e58	89 44 24 70	 mov	 DWORD PTR tv478[rsp], eax
  00e5c	eb 08		 jmp	 SHORT $LN114@loc3270_ex
$LN113@loc3270_ex:
  00e5e	8b 44 24 28	 mov	 eax, DWORD PTR num$[rsp]
  00e62	89 44 24 70	 mov	 DWORD PTR tv478[rsp], eax
$LN114@loc3270_ex:
  00e66	83 7c 24 2c 00	 cmp	 DWORD PTR aid$[rsp], 0
  00e6b	74 1d		 je	 SHORT $LN115@loc3270_ex
  00e6d	48 8b 84 24 e0
	00 01 00	 mov	 rax, QWORD PTR dev$[rsp]
  00e75	48 8b 80 c8 01
	00 00		 mov	 rax, QWORD PTR [rax+456]
  00e7c	48 83 c0 03	 add	 rax, 3
  00e80	48 89 84 24 98
	00 00 00	 mov	 QWORD PTR tv484[rsp], rax
  00e88	eb 17		 jmp	 SHORT $LN116@loc3270_ex
$LN115@loc3270_ex:
  00e8a	48 8b 84 24 e0
	00 01 00	 mov	 rax, QWORD PTR dev$[rsp]
  00e92	48 8b 80 c8 01
	00 00		 mov	 rax, QWORD PTR [rax+456]
  00e99	48 89 84 24 98
	00 00 00	 mov	 QWORD PTR tv484[rsp], rax
$LN116@loc3270_ex:
  00ea1	44 8b 44 24 70	 mov	 r8d, DWORD PTR tv478[rsp]
  00ea6	48 8b 94 24 98
	00 00 00	 mov	 rdx, QWORD PTR tv484[rsp]
  00eae	48 8b 84 24 e0
	00 01 00	 mov	 rax, QWORD PTR dev$[rsp]
  00eb6	8b 88 bc 06 00
	00		 mov	 ecx, DWORD PTR [rax+1724]
  00ebc	e8 00 00 00 00	 call	 end_of_buf_pos
  00ec1	48 8b 8c 24 e0
	00 01 00	 mov	 rcx, QWORD PTR dev$[rsp]
  00ec9	89 81 bc 06 00
	00		 mov	 DWORD PTR [rcx+1724], eax
$LN72@loc3270_ex:

; 4343 :                 //    (aid)        (!aid)
; 4344 :                 aid ? dev->buf+3 : dev->buf,
; 4345 :                 aid ? num-3      : num
; 4346 :             );
; 4347 :         }
; 4348 : 
; 4349 :         /* Indicate that the AID bytes have been skipped */
; 4350 :         if (dev->readpending == 1)

  00ecf	48 8b 84 24 e0
	00 01 00	 mov	 rax, QWORD PTR dev$[rsp]
  00ed7	8b 80 f8 05 00
	00		 mov	 eax, DWORD PTR [rax+1528]
  00edd	c1 e8 06	 shr	 eax, 6
  00ee0	83 e0 03	 and	 eax, 3
  00ee3	83 f8 01	 cmp	 eax, 1
  00ee6	75 25		 jne	 SHORT $LN73@loc3270_ex

; 4351 :             dev->readpending = 2;

  00ee8	48 8b 84 24 e0
	00 01 00	 mov	 rax, QWORD PTR dev$[rsp]
  00ef0	8b 80 f8 05 00
	00		 mov	 eax, DWORD PTR [rax+1528]
  00ef6	25 3f ff ff ff	 and	 eax, -193		; ffffff3fH
  00efb	0f ba e8 07	 bts	 eax, 7
  00eff	48 8b 8c 24 e0
	00 01 00	 mov	 rcx, QWORD PTR dev$[rsp]
  00f07	89 81 f8 05 00
	00		 mov	 DWORD PTR [rcx+1528], eax
$LN73@loc3270_ex:

; 4352 : 
; 4353 :         /* Copy data from device buffer to channel buffer */
; 4354 :         memcpy (iobuf, dev->buf, num);

  00f0d	8b 44 24 28	 mov	 eax, DWORD PTR num$[rsp]
  00f11	48 8b 8c 24 e0
	00 01 00	 mov	 rcx, QWORD PTR dev$[rsp]
  00f19	48 8b bc 24 18
	01 01 00	 mov	 rdi, QWORD PTR iobuf$[rsp]
  00f21	48 8b b1 c8 01
	00 00		 mov	 rsi, QWORD PTR [rcx+456]
  00f28	8b c8		 mov	 ecx, eax
  00f2a	f3 a4		 rep movsb

; 4355 : 
; 4356 :         /* If data chaining is specified, save remaining data */
; 4357 :         if ((flags & CCW_FLAGS_CD) && len > count)

  00f2c	0f b6 84 24 f0
	00 01 00	 movzx	 eax, BYTE PTR flags$[rsp]
  00f34	25 80 00 00 00	 and	 eax, 128		; 00000080H
  00f39	85 c0		 test	 eax, eax
  00f3b	74 6d		 je	 SHORT $LN74@loc3270_ex
  00f3d	8b 84 24 00 01
	01 00		 mov	 eax, DWORD PTR count$[rsp]
  00f44	39 44 24 20	 cmp	 DWORD PTR len$[rsp], eax
  00f48	76 60		 jbe	 SHORT $LN74@loc3270_ex

; 4358 :         {
; 4359 :             memmove (dev->buf, dev->buf + count, len - count);

  00f4a	8b 84 24 00 01
	01 00		 mov	 eax, DWORD PTR count$[rsp]
  00f51	8b 4c 24 20	 mov	 ecx, DWORD PTR len$[rsp]
  00f55	2b c8		 sub	 ecx, eax
  00f57	8b c1		 mov	 eax, ecx
  00f59	8b c0		 mov	 eax, eax
  00f5b	8b 8c 24 00 01
	01 00		 mov	 ecx, DWORD PTR count$[rsp]
  00f62	48 8b 94 24 e0
	00 01 00	 mov	 rdx, QWORD PTR dev$[rsp]
  00f6a	48 03 8a c8 01
	00 00		 add	 rcx, QWORD PTR [rdx+456]
  00f71	44 8b c0	 mov	 r8d, eax
  00f74	48 8b d1	 mov	 rdx, rcx
  00f77	48 8b 84 24 e0
	00 01 00	 mov	 rax, QWORD PTR dev$[rsp]
  00f7f	48 8b 88 c8 01
	00 00		 mov	 rcx, QWORD PTR [rax+456]
  00f86	e8 00 00 00 00	 call	 memmove

; 4360 :             dev->rlen3270 = len - count;

  00f8b	8b 84 24 00 01
	01 00		 mov	 eax, DWORD PTR count$[rsp]
  00f92	8b 4c 24 20	 mov	 ecx, DWORD PTR len$[rsp]
  00f96	2b c8		 sub	 ecx, eax
  00f98	8b c1		 mov	 eax, ecx
  00f9a	48 8b 8c 24 e0
	00 01 00	 mov	 rcx, QWORD PTR dev$[rsp]
  00fa2	89 81 b8 06 00
	00		 mov	 DWORD PTR [rcx+1720], eax

; 4361 :         }

  00fa8	eb 33		 jmp	 SHORT $LN75@loc3270_ex
$LN74@loc3270_ex:

; 4362 :         else
; 4363 :         {
; 4364 :             dev->rlen3270 = 0;

  00faa	48 8b 84 24 e0
	00 01 00	 mov	 rax, QWORD PTR dev$[rsp]
  00fb2	c7 80 b8 06 00
	00 00 00 00 00	 mov	 DWORD PTR [rax+1720], 0

; 4365 :             dev->readpending = 0;

  00fbc	48 8b 84 24 e0
	00 01 00	 mov	 rax, QWORD PTR dev$[rsp]
  00fc4	8b 80 f8 05 00
	00		 mov	 eax, DWORD PTR [rax+1528]
  00fca	25 3f ff ff ff	 and	 eax, -193		; ffffff3fH
  00fcf	48 8b 8c 24 e0
	00 01 00	 mov	 rcx, QWORD PTR dev$[rsp]
  00fd7	89 81 f8 05 00
	00		 mov	 DWORD PTR [rcx+1528], eax
$LN75@loc3270_ex:

; 4366 :         }
; 4367 : 
; 4368 :         /* Set normal status */
; 4369 :         *unitstat = CSW_CE | CSW_DE;

  00fdd	48 8b 84 24 28
	01 01 00	 mov	 rax, QWORD PTR unitstat$[rsp]
  00fe5	c6 00 0c	 mov	 BYTE PTR [rax], 12

; 4370 : 
; 4371 :         /* Release the device lock */
; 4372 :         release_lock (&dev->lock);

  00fe8	48 8b 84 24 e0
	00 01 00	 mov	 rax, QWORD PTR dev$[rsp]
  00ff0	48 83 c0 38	 add	 rax, 56			; 00000038H
  00ff4	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG179601
  00ffb	48 8b c8	 mov	 rcx, rax
  00ffe	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_release_lock
$LN21@loc3270_ex:

; 4373 : 
; 4374 :         /* Signal connection thread to redrive its pselect loop */
; 4375 :         SIGNAL_CONSOLE_THREAD();

  01004	c6 44 24 31 00	 mov	 BYTE PTR c$2[rsp], 0
  01009	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_WSAGetLastError
  0100f	89 84 24 84 00
	00 00		 mov	 DWORD PTR saved_errno$6[rsp], eax
  01016	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  0101d	48 05 c0 10 00
	00		 add	 rax, 4288		; 000010c0H
  01023	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG179602
  0102a	48 8b c8	 mov	 rcx, rax
  0102d	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_obtain_lock
  01033	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  0103a	8b 80 c8 10 00
	00		 mov	 eax, DWORD PTR [rax+4296]
  01040	89 44 24 74	 mov	 DWORD PTR f$4[rsp], eax
  01044	83 7c 24 74 00	 cmp	 DWORD PTR f$4[rsp], 0
  01049	7f 11		 jg	 SHORT $LN76@loc3270_ex
  0104b	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  01052	c7 80 c8 10 00
	00 01 00 00 00	 mov	 DWORD PTR [rax+4296], 1
$LN76@loc3270_ex:
  0105c	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  01063	48 05 c0 10 00
	00		 add	 rax, 4288		; 000010c0H
  01069	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG179604
  01070	48 8b c8	 mov	 rcx, rax
  01073	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_release_lock
  01079	83 7c 24 74 00	 cmp	 DWORD PTR f$4[rsp], 0
  0107e	0f 8f 90 00 00
	00		 jg	 $LN77@loc3270_ex
$LN24@loc3270_ex:
  01084	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  0108b	48 63 80 cc 10
	00 00		 movsxd	 rax, DWORD PTR [rax+4300]
  01092	45 33 c9	 xor	 r9d, r9d
  01095	41 b8 01 00 00
	00		 mov	 r8d, 1
  0109b	48 8d 54 24 31	 lea	 rdx, QWORD PTR c$2[rsp]
  010a0	48 8b c8	 mov	 rcx, rax
  010a3	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_send
  010a9	83 f8 01	 cmp	 eax, 1
  010ac	74 5c		 je	 SHORT $LN78@loc3270_ex
$LN27@loc3270_ex:
  010ae	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG179607
  010b5	41 b8 17 11 00
	00		 mov	 r8d, 4375		; 00001117H
  010bb	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG179608
  010c2	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG179609
  010c9	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_logmsg
  010cf	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_IsDebuggerPresent
  010d5	85 c0		 test	 eax, eax
  010d7	74 20		 je	 SHORT $LN79@loc3270_ex
  010d9	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG179611
  010e0	41 b8 17 11 00
	00		 mov	 r8d, 4375		; 00001117H
  010e6	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG179612
  010ed	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG179613
  010f4	e8 00 00 00 00	 call	 DebuggerTrace
$LN79@loc3270_ex:
  010f9	33 c0		 xor	 eax, eax
  010fb	85 c0		 test	 eax, eax
  010fd	75 af		 jne	 SHORT $LN27@loc3270_ex
  010ff	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_IsDebuggerPresent
  01105	85 c0		 test	 eax, eax
  01107	74 01		 je	 SHORT $LN80@loc3270_ex
  01109	cc		 int	 3
$LN80@loc3270_ex:
$LN78@loc3270_ex:
  0110a	33 c0		 xor	 eax, eax
  0110c	85 c0		 test	 eax, eax
  0110e	0f 85 70 ff ff
	ff		 jne	 $LN24@loc3270_ex
$LN77@loc3270_ex:
  01114	8b 8c 24 84 00
	00 00		 mov	 ecx, DWORD PTR saved_errno$6[rsp]
  0111b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_WSASetLastError
  01121	33 c0		 xor	 eax, eax
  01123	85 c0		 test	 eax, eax
  01125	0f 85 d9 fe ff
	ff		 jne	 $LN21@loc3270_ex

; 4376 : 
; 4377 :         break;

  0112b	e9 b5 01 00 00	 jmp	 $LN8@loc3270_ex
$LN81@loc3270_ex:

; 4378 : 
; 4379 :     case L3270_SENSE:
; 4380 :     /*---------------------------------------------------------------*/
; 4381 :     /* SENSE                                                         */
; 4382 :     /*---------------------------------------------------------------*/
; 4383 :         /* Calculate residual byte count */
; 4384 :         num = (count < dev->numsense) ? count : dev->numsense;

  01130	48 8b 84 24 e0
	00 01 00	 mov	 rax, QWORD PTR dev$[rsp]
  01138	8b 80 60 03 00
	00		 mov	 eax, DWORD PTR [rax+864]
  0113e	39 84 24 00 01
	01 00		 cmp	 DWORD PTR count$[rsp], eax
  01145	73 0d		 jae	 SHORT $LN117@loc3270_ex
  01147	8b 84 24 00 01
	01 00		 mov	 eax, DWORD PTR count$[rsp]
  0114e	89 44 24 78	 mov	 DWORD PTR tv563[rsp], eax
  01152	eb 12		 jmp	 SHORT $LN118@loc3270_ex
$LN117@loc3270_ex:
  01154	48 8b 84 24 e0
	00 01 00	 mov	 rax, QWORD PTR dev$[rsp]
  0115c	8b 80 60 03 00
	00		 mov	 eax, DWORD PTR [rax+864]
  01162	89 44 24 78	 mov	 DWORD PTR tv563[rsp], eax
$LN118@loc3270_ex:
  01166	8b 44 24 78	 mov	 eax, DWORD PTR tv563[rsp]
  0116a	89 44 24 28	 mov	 DWORD PTR num$[rsp], eax

; 4385 :         *residual = count - num;

  0116e	8b 44 24 28	 mov	 eax, DWORD PTR num$[rsp]
  01172	8b 8c 24 00 01
	01 00		 mov	 ecx, DWORD PTR count$[rsp]
  01179	2b c8		 sub	 ecx, eax
  0117b	8b c1		 mov	 eax, ecx
  0117d	48 8b 8c 24 30
	01 01 00	 mov	 rcx, QWORD PTR residual$[rsp]
  01185	89 01		 mov	 DWORD PTR [rcx], eax

; 4386 :         if (count < dev->numsense) *more = 1;

  01187	48 8b 84 24 e0
	00 01 00	 mov	 rax, QWORD PTR dev$[rsp]
  0118f	8b 80 60 03 00
	00		 mov	 eax, DWORD PTR [rax+864]
  01195	39 84 24 00 01
	01 00		 cmp	 DWORD PTR count$[rsp], eax
  0119c	73 0b		 jae	 SHORT $LN82@loc3270_ex
  0119e	48 8b 84 24 20
	01 01 00	 mov	 rax, QWORD PTR more$[rsp]
  011a6	c6 00 01	 mov	 BYTE PTR [rax], 1
$LN82@loc3270_ex:

; 4387 : 
; 4388 :         /* Copy device sense bytes to channel I/O buffer */
; 4389 :         memcpy (iobuf, dev->sense, num);

  011a9	8b 44 24 28	 mov	 eax, DWORD PTR num$[rsp]
  011ad	48 8b 8c 24 e0
	00 01 00	 mov	 rcx, QWORD PTR dev$[rsp]
  011b5	48 81 c1 64 03
	00 00		 add	 rcx, 868		; 00000364H
  011bc	48 8b bc 24 18
	01 01 00	 mov	 rdi, QWORD PTR iobuf$[rsp]
  011c4	48 8b f1	 mov	 rsi, rcx
  011c7	8b c8		 mov	 ecx, eax
  011c9	f3 a4		 rep movsb

; 4390 : 
; 4391 :         /* Clear the device sense bytes */
; 4392 :         memset( dev->sense, 0, sizeof(dev->sense) );

  011cb	48 8b 84 24 e0
	00 01 00	 mov	 rax, QWORD PTR dev$[rsp]
  011d3	48 05 64 03 00
	00		 add	 rax, 868		; 00000364H
  011d9	48 8b f8	 mov	 rdi, rax
  011dc	33 c0		 xor	 eax, eax
  011de	b9 00 01 00 00	 mov	 ecx, 256		; 00000100H
  011e3	f3 aa		 rep stosb

; 4393 : 
; 4394 :         /* Reset the buffer address */
; 4395 :         dev->pos3270 = 0;

  011e5	48 8b 84 24 e0
	00 01 00	 mov	 rax, QWORD PTR dev$[rsp]
  011ed	c7 80 bc 06 00
	00 00 00 00 00	 mov	 DWORD PTR [rax+1724], 0

; 4396 : 
; 4397 :         /* Return unit status */
; 4398 :         *unitstat = CSW_CE | CSW_DE;

  011f7	48 8b 84 24 28
	01 01 00	 mov	 rax, QWORD PTR unitstat$[rsp]
  011ff	c6 00 0c	 mov	 BYTE PTR [rax], 12

; 4399 :         break;

  01202	e9 de 00 00 00	 jmp	 $LN8@loc3270_ex
$LN83@loc3270_ex:

; 4400 : 
; 4401 :     case L3270_SENSEID:
; 4402 :     /*---------------------------------------------------------------*/
; 4403 :     /* SENSE ID                                                      */
; 4404 :     /*---------------------------------------------------------------*/
; 4405 :         /* Calculate residual byte count */
; 4406 :         num = (count < dev->numdevid) ? count : dev->numdevid;

  01207	48 8b 84 24 e0
	00 01 00	 mov	 rax, QWORD PTR dev$[rsp]
  0120f	8b 80 64 04 00
	00		 mov	 eax, DWORD PTR [rax+1124]
  01215	39 84 24 00 01
	01 00		 cmp	 DWORD PTR count$[rsp], eax
  0121c	73 0d		 jae	 SHORT $LN119@loc3270_ex
  0121e	8b 84 24 00 01
	01 00		 mov	 eax, DWORD PTR count$[rsp]
  01225	89 44 24 7c	 mov	 DWORD PTR tv583[rsp], eax
  01229	eb 12		 jmp	 SHORT $LN120@loc3270_ex
$LN119@loc3270_ex:
  0122b	48 8b 84 24 e0
	00 01 00	 mov	 rax, QWORD PTR dev$[rsp]
  01233	8b 80 64 04 00
	00		 mov	 eax, DWORD PTR [rax+1124]
  01239	89 44 24 7c	 mov	 DWORD PTR tv583[rsp], eax
$LN120@loc3270_ex:
  0123d	8b 44 24 7c	 mov	 eax, DWORD PTR tv583[rsp]
  01241	89 44 24 28	 mov	 DWORD PTR num$[rsp], eax

; 4407 :         *residual = count - num;

  01245	8b 44 24 28	 mov	 eax, DWORD PTR num$[rsp]
  01249	8b 8c 24 00 01
	01 00		 mov	 ecx, DWORD PTR count$[rsp]
  01250	2b c8		 sub	 ecx, eax
  01252	8b c1		 mov	 eax, ecx
  01254	48 8b 8c 24 30
	01 01 00	 mov	 rcx, QWORD PTR residual$[rsp]
  0125c	89 01		 mov	 DWORD PTR [rcx], eax

; 4408 :         if (count < dev->numdevid) *more = 1;

  0125e	48 8b 84 24 e0
	00 01 00	 mov	 rax, QWORD PTR dev$[rsp]
  01266	8b 80 64 04 00
	00		 mov	 eax, DWORD PTR [rax+1124]
  0126c	39 84 24 00 01
	01 00		 cmp	 DWORD PTR count$[rsp], eax
  01273	73 0b		 jae	 SHORT $LN84@loc3270_ex
  01275	48 8b 84 24 20
	01 01 00	 mov	 rax, QWORD PTR more$[rsp]
  0127d	c6 00 01	 mov	 BYTE PTR [rax], 1
$LN84@loc3270_ex:

; 4409 : 
; 4410 :         /* Copy device identifier bytes to channel I/O buffer */
; 4411 :         memcpy (iobuf, dev->devid, num);

  01280	8b 44 24 28	 mov	 eax, DWORD PTR num$[rsp]
  01284	48 8b 8c 24 e0
	00 01 00	 mov	 rcx, QWORD PTR dev$[rsp]
  0128c	48 81 c1 68 04
	00 00		 add	 rcx, 1128		; 00000468H
  01293	48 8b bc 24 18
	01 01 00	 mov	 rdi, QWORD PTR iobuf$[rsp]
  0129b	48 8b f1	 mov	 rsi, rcx
  0129e	8b c8		 mov	 ecx, eax
  012a0	f3 a4		 rep movsb

; 4412 : 
; 4413 :         /* Reset the buffer address */
; 4414 :         dev->pos3270 = 0;

  012a2	48 8b 84 24 e0
	00 01 00	 mov	 rax, QWORD PTR dev$[rsp]
  012aa	c7 80 bc 06 00
	00 00 00 00 00	 mov	 DWORD PTR [rax+1724], 0

; 4415 : 
; 4416 :         /* Return unit status */
; 4417 :         *unitstat = CSW_CE | CSW_DE;

  012b4	48 8b 84 24 28
	01 01 00	 mov	 rax, QWORD PTR unitstat$[rsp]
  012bc	c6 00 0c	 mov	 BYTE PTR [rax], 12

; 4418 :         break;

  012bf	eb 24		 jmp	 SHORT $LN8@loc3270_ex
$LN85@loc3270_ex:

; 4419 : 
; 4420 :     default:
; 4421 :     /*---------------------------------------------------------------*/
; 4422 :     /* INVALID OPERATION                                             */
; 4423 :     /*---------------------------------------------------------------*/
; 4424 :         /* Set command reject sense byte, and unit check status */
; 4425 :         dev->sense[0] = SENSE_CR;

  012c1	b8 01 00 00 00	 mov	 eax, 1
  012c6	48 6b c0 00	 imul	 rax, rax, 0
  012ca	48 8b 8c 24 e0
	00 01 00	 mov	 rcx, QWORD PTR dev$[rsp]
  012d2	c6 84 01 64 03
	00 00 80	 mov	 BYTE PTR [rcx+rax+868], 128 ; 00000080H

; 4426 :         *unitstat = CSW_CE | CSW_DE | CSW_UC;

  012da	48 8b 84 24 28
	01 01 00	 mov	 rax, QWORD PTR unitstat$[rsp]
  012e2	c6 00 0e	 mov	 BYTE PTR [rax], 14
$LN8@loc3270_ex:
$LN1@loc3270_ex:

; 4427 : 
; 4428 :     } /* end switch(code) */
; 4429 : 
; 4430 : } /* end function loc3270_execute_ccw */

  012e5	48 8b 8c 24 b0
	00 01 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  012ed	48 33 cc	 xor	 rcx, rsp
  012f0	e8 00 00 00 00	 call	 __security_check_cookie
  012f5	48 81 c4 c8 00
	01 00		 add	 rsp, 65736		; 000100c8H
  012fc	5f		 pop	 rdi
  012fd	5e		 pop	 rsi
  012fe	c3		 ret	 0
  012ff	90		 npad	 1
$LN122@loc3270_ex:
  01300	00 00 00 00	 DD	 $LN37@loc3270_ex
  01304	00 00 00 00	 DD	 $LN49@loc3270_ex
  01308	00 00 00 00	 DD	 $LN30@loc3270_ex
  0130c	00 00 00 00	 DD	 $LN81@loc3270_ex
  01310	00 00 00 00	 DD	 $LN38@loc3270_ex
  01314	00 00 00 00	 DD	 $LN65@loc3270_ex
  01318	00 00 00 00	 DD	 $LN31@loc3270_ex
  0131c	00 00 00 00	 DD	 $LN39@loc3270_ex
  01320	00 00 00 00	 DD	 $LN36@loc3270_ex
  01324	00 00 00 00	 DD	 $LN40@loc3270_ex
  01328	00 00 00 00	 DD	 $LN32@loc3270_ex
  0132c	00 00 00 00	 DD	 $LN33@loc3270_ex
  01330	00 00 00 00	 DD	 $LN34@loc3270_ex
  01334	00 00 00 00	 DD	 $LN35@loc3270_ex
  01338	00 00 00 00	 DD	 $LN83@loc3270_ex
  0133c	00 00 00 00	 DD	 $LN85@loc3270_ex
$LN121@loc3270_ex:
  01340	00		 DB	 0
  01341	01		 DB	 1
  01342	02		 DB	 2
  01343	03		 DB	 3
  01344	04		 DB	 4
  01345	05		 DB	 5
  01346	0f		 DB	 15
  01347	0f		 DB	 15
  01348	0f		 DB	 15
  01349	0f		 DB	 15
  0134a	06		 DB	 6
  0134b	0f		 DB	 15
  0134c	07		 DB	 7
  0134d	0f		 DB	 15
  0134e	08		 DB	 8
  0134f	0f		 DB	 15
  01350	09		 DB	 9
  01351	0f		 DB	 15
  01352	0f		 DB	 15
  01353	0f		 DB	 15
  01354	0f		 DB	 15
  01355	0f		 DB	 15
  01356	0f		 DB	 15
  01357	0f		 DB	 15
  01358	0f		 DB	 15
  01359	0f		 DB	 15
  0135a	0a		 DB	 10
  0135b	0f		 DB	 15
  0135c	0f		 DB	 15
  0135d	0f		 DB	 15
  0135e	0f		 DB	 15
  0135f	0f		 DB	 15
  01360	0f		 DB	 15
  01361	0f		 DB	 15
  01362	0f		 DB	 15
  01363	0f		 DB	 15
  01364	0f		 DB	 15
  01365	0f		 DB	 15
  01366	0f		 DB	 15
  01367	0f		 DB	 15
  01368	0f		 DB	 15
  01369	0f		 DB	 15
  0136a	0b		 DB	 11
  0136b	0f		 DB	 15
  0136c	0f		 DB	 15
  0136d	0f		 DB	 15
  0136e	0f		 DB	 15
  0136f	0f		 DB	 15
  01370	0f		 DB	 15
  01371	0f		 DB	 15
  01372	0f		 DB	 15
  01373	0f		 DB	 15
  01374	0f		 DB	 15
  01375	0f		 DB	 15
  01376	0f		 DB	 15
  01377	0f		 DB	 15
  01378	0f		 DB	 15
  01379	0f		 DB	 15
  0137a	0c		 DB	 12
  0137b	0f		 DB	 15
  0137c	0f		 DB	 15
  0137d	0f		 DB	 15
  0137e	0f		 DB	 15
  0137f	0f		 DB	 15
  01380	0f		 DB	 15
  01381	0f		 DB	 15
  01382	0f		 DB	 15
  01383	0f		 DB	 15
  01384	0f		 DB	 15
  01385	0f		 DB	 15
  01386	0f		 DB	 15
  01387	0f		 DB	 15
  01388	0f		 DB	 15
  01389	0f		 DB	 15
  0138a	0d		 DB	 13
  0138b	0f		 DB	 15
  0138c	0f		 DB	 15
  0138d	0f		 DB	 15
  0138e	0f		 DB	 15
  0138f	0f		 DB	 15
  01390	0f		 DB	 15
  01391	0f		 DB	 15
  01392	0f		 DB	 15
  01393	0f		 DB	 15
  01394	0f		 DB	 15
  01395	0f		 DB	 15
  01396	0f		 DB	 15
  01397	0f		 DB	 15
  01398	0f		 DB	 15
  01399	0f		 DB	 15
  0139a	0f		 DB	 15
  0139b	0f		 DB	 15
  0139c	0f		 DB	 15
  0139d	0f		 DB	 15
  0139e	0f		 DB	 15
  0139f	0f		 DB	 15
  013a0	0f		 DB	 15
  013a1	0f		 DB	 15
  013a2	0f		 DB	 15
  013a3	0f		 DB	 15
  013a4	0f		 DB	 15
  013a5	0f		 DB	 15
  013a6	0f		 DB	 15
  013a7	0f		 DB	 15
  013a8	0f		 DB	 15
  013a9	0f		 DB	 15
  013aa	0f		 DB	 15
  013ab	0f		 DB	 15
  013ac	0f		 DB	 15
  013ad	0f		 DB	 15
  013ae	0f		 DB	 15
  013af	0f		 DB	 15
  013b0	0f		 DB	 15
  013b1	0f		 DB	 15
  013b2	0f		 DB	 15
  013b3	0f		 DB	 15
  013b4	0f		 DB	 15
  013b5	0f		 DB	 15
  013b6	0f		 DB	 15
  013b7	0f		 DB	 15
  013b8	0f		 DB	 15
  013b9	0f		 DB	 15
  013ba	0f		 DB	 15
  013bb	0f		 DB	 15
  013bc	0f		 DB	 15
  013bd	0f		 DB	 15
  013be	0f		 DB	 15
  013bf	0f		 DB	 15
  013c0	0f		 DB	 15
  013c1	0f		 DB	 15
  013c2	0f		 DB	 15
  013c3	0f		 DB	 15
  013c4	0f		 DB	 15
  013c5	0f		 DB	 15
  013c6	0f		 DB	 15
  013c7	0f		 DB	 15
  013c8	0f		 DB	 15
  013c9	0f		 DB	 15
  013ca	0f		 DB	 15
  013cb	0f		 DB	 15
  013cc	0f		 DB	 15
  013cd	0f		 DB	 15
  013ce	0f		 DB	 15
  013cf	0f		 DB	 15
  013d0	0f		 DB	 15
  013d1	0f		 DB	 15
  013d2	0f		 DB	 15
  013d3	0f		 DB	 15
  013d4	0f		 DB	 15
  013d5	0f		 DB	 15
  013d6	0f		 DB	 15
  013d7	0f		 DB	 15
  013d8	0f		 DB	 15
  013d9	0f		 DB	 15
  013da	0f		 DB	 15
  013db	0f		 DB	 15
  013dc	0f		 DB	 15
  013dd	0f		 DB	 15
  013de	0f		 DB	 15
  013df	0f		 DB	 15
  013e0	0f		 DB	 15
  013e1	0f		 DB	 15
  013e2	0f		 DB	 15
  013e3	0f		 DB	 15
  013e4	0f		 DB	 15
  013e5	0f		 DB	 15
  013e6	0f		 DB	 15
  013e7	0f		 DB	 15
  013e8	0f		 DB	 15
  013e9	0f		 DB	 15
  013ea	0f		 DB	 15
  013eb	0f		 DB	 15
  013ec	0f		 DB	 15
  013ed	0f		 DB	 15
  013ee	0f		 DB	 15
  013ef	0f		 DB	 15
  013f0	0f		 DB	 15
  013f1	0f		 DB	 15
  013f2	0f		 DB	 15
  013f3	0f		 DB	 15
  013f4	0f		 DB	 15
  013f5	0f		 DB	 15
  013f6	0f		 DB	 15
  013f7	0f		 DB	 15
  013f8	0f		 DB	 15
  013f9	0f		 DB	 15
  013fa	0f		 DB	 15
  013fb	0f		 DB	 15
  013fc	0f		 DB	 15
  013fd	0f		 DB	 15
  013fe	0f		 DB	 15
  013ff	0f		 DB	 15
  01400	0f		 DB	 15
  01401	0f		 DB	 15
  01402	0f		 DB	 15
  01403	0f		 DB	 15
  01404	0f		 DB	 15
  01405	0f		 DB	 15
  01406	0f		 DB	 15
  01407	0f		 DB	 15
  01408	0f		 DB	 15
  01409	0f		 DB	 15
  0140a	0f		 DB	 15
  0140b	0f		 DB	 15
  0140c	0f		 DB	 15
  0140d	0f		 DB	 15
  0140e	0f		 DB	 15
  0140f	0f		 DB	 15
  01410	0f		 DB	 15
  01411	0f		 DB	 15
  01412	0f		 DB	 15
  01413	0f		 DB	 15
  01414	0f		 DB	 15
  01415	0f		 DB	 15
  01416	0f		 DB	 15
  01417	0f		 DB	 15
  01418	0f		 DB	 15
  01419	0f		 DB	 15
  0141a	0f		 DB	 15
  0141b	0f		 DB	 15
  0141c	0f		 DB	 15
  0141d	0f		 DB	 15
  0141e	0f		 DB	 15
  0141f	0f		 DB	 15
  01420	0f		 DB	 15
  01421	0f		 DB	 15
  01422	0f		 DB	 15
  01423	0e		 DB	 14
loc3270_execute_ccw ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\console.c
_TEXT	SEGMENT
lsock$ = 80
rc$ = 84
rc$1 = 88
server$ = 96
optval$ = 104
tv168 = 108
tv226 = 112
tv69 = 120
tv91 = 128
tv186 = 136
tv207 = 144
msgbuf$2 = 160
__$ArrayPad$ = 224
stmt$ = 256
typ$ = 264
port$ = 272
get_listening_socket PROC

; 3304 : {

  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	48 81 ec f8 00
	00 00		 sub	 rsp, 248		; 000000f8H
  00016	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  0001d	48 33 c4	 xor	 rax, rsp
  00020	48 89 84 24 e0
	00 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 3305 : int                    rc = 0;          /* Return code               */

  00028	c7 44 24 54 00
	00 00 00	 mov	 DWORD PTR rc$[rsp], 0

; 3306 : int                    lsock;           /* Socket for listening      */
; 3307 : int                    optval;          /* Argument for setsockopt   */
; 3308 : struct sockaddr_in    *server;          /* Server address structure  */
; 3309 : 
; 3310 :     /* Obtain a socket */
; 3311 :     lsock = socket( AF_INET, SOCK_STREAM, 0 );

  00030	45 33 c0	 xor	 r8d, r8d
  00033	ba 01 00 00 00	 mov	 edx, 1
  00038	b9 02 00 00 00	 mov	 ecx, 2
  0003d	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_socket
  00043	89 44 24 50	 mov	 DWORD PTR lsock$[rsp], eax

; 3312 : 
; 3313 :     if (lsock < 0)

  00047	83 7c 24 50 00	 cmp	 DWORD PTR lsock$[rsp], 0
  0004c	7d 7a		 jge	 SHORT $LN10@get_listen

; 3314 :     {
; 3315 :         // "COMM: error in function %s: %s"
; 3316 :         WRMSG( HHC01034, "E", "socket()", strerror( HSO_errno ));

  0004e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_WSAGetLastError
  00054	8b c8		 mov	 ecx, eax
  00056	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_strerror
  0005c	48 89 44 24 78	 mov	 QWORD PTR tv69[rsp], rax
  00061	b9 01 00 00 00	 mov	 ecx, 1
  00066	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  0006c	48 8b 4c 24 78	 mov	 rcx, QWORD PTR tv69[rsp]
  00071	48 89 4c 24 40	 mov	 QWORD PTR [rsp+64], rcx
  00076	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG179176
  0007d	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  00082	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG179177
  00089	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  0008e	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG179178
  00095	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  0009a	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  0009f	41 b9 03 00 00
	00		 mov	 r9d, 3
  000a5	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG179179
  000ac	ba f4 0c 00 00	 mov	 edx, 3316		; 00000cf4H
  000b1	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG179180
  000b8	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 3317 :         return -1;

  000be	b8 ff ff ff ff	 mov	 eax, -1
  000c3	e9 2e 04 00 00	 jmp	 $LN1@get_listen
$LN10@get_listen:

; 3318 :     }
; 3319 : 
; 3320 :     /* Allow previous instance of socket to be reused */
; 3321 :     optval = 1;

  000c8	c7 44 24 68 01
	00 00 00	 mov	 DWORD PTR optval$[rsp], 1

; 3322 :     rc = setsockopt( lsock, SOL_SOCKET, SO_REUSEADDR,

  000d0	48 63 44 24 50	 movsxd	 rax, DWORD PTR lsock$[rsp]
  000d5	c7 44 24 20 04
	00 00 00	 mov	 DWORD PTR [rsp+32], 4
  000dd	4c 8d 4c 24 68	 lea	 r9, QWORD PTR optval$[rsp]
  000e2	41 b8 04 00 00
	00		 mov	 r8d, 4
  000e8	ba ff ff 00 00	 mov	 edx, 65535		; 0000ffffH
  000ed	48 8b c8	 mov	 rcx, rax
  000f0	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_setsockopt
  000f6	89 44 24 54	 mov	 DWORD PTR rc$[rsp], eax

; 3323 :                      (GETSET_SOCKOPT_T*) &optval, sizeof( optval ));
; 3324 :     if (rc < 0)

  000fa	83 7c 24 54 00	 cmp	 DWORD PTR rc$[rsp], 0
  000ff	0f 8d 8a 00 00
	00		 jge	 $LN11@get_listen

; 3325 :     {
; 3326 :         // "COMM: error in function %s: %s"
; 3327 :         WRMSG( HHC01034, "E", "setsockopt()", strerror( HSO_errno ));

  00105	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_WSAGetLastError
  0010b	8b c8		 mov	 ecx, eax
  0010d	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_strerror
  00113	48 89 84 24 80
	00 00 00	 mov	 QWORD PTR tv91[rsp], rax
  0011b	b9 01 00 00 00	 mov	 ecx, 1
  00120	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  00126	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR tv91[rsp]
  0012e	48 89 4c 24 40	 mov	 QWORD PTR [rsp+64], rcx
  00133	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG179182
  0013a	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  0013f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG179183
  00146	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  0014b	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG179184
  00152	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00157	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  0015c	41 b9 03 00 00
	00		 mov	 r9d, 3
  00162	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG179185
  00169	ba ff 0c 00 00	 mov	 edx, 3327		; 00000cffH
  0016e	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG179186
  00175	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 3328 :         close_socket( lsock );

  0017b	8b 4c 24 50	 mov	 ecx, DWORD PTR lsock$[rsp]
  0017f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_close_socket

; 3329 :         return -1;

  00185	b8 ff ff ff ff	 mov	 eax, -1
  0018a	e9 67 03 00 00	 jmp	 $LN1@get_listen
$LN11@get_listen:

; 3330 :     }
; 3331 : 
; 3332 :     /* Prepare the sockaddr structure for the bind */
; 3333 :     if (!(server = parse_sockspec( port )))

  0018f	48 8b 8c 24 10
	01 00 00	 mov	 rcx, QWORD PTR port$[rsp]
  00197	e8 00 00 00 00	 call	 parse_sockspec
  0019c	48 89 44 24 60	 mov	 QWORD PTR server$[rsp], rax
  001a1	48 83 7c 24 60
	00		 cmp	 QWORD PTR server$[rsp], 0
  001a7	0f 85 97 00 00
	00		 jne	 $LN12@get_listen

; 3334 :     {
; 3335 :         char msgbuf[64];
; 3336 :         MSGBUF( msgbuf, "%s = %s", stmt, port );

  001ad	48 8b 84 24 10
	01 00 00	 mov	 rax, QWORD PTR port$[rsp]
  001b5	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  001ba	4c 8b 8c 24 00
	01 00 00	 mov	 r9, QWORD PTR stmt$[rsp]
  001c2	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG179188
  001c9	ba 40 00 00 00	 mov	 edx, 64			; 00000040H
  001ce	48 8d 8c 24 a0
	00 00 00	 lea	 rcx, QWORD PTR msgbuf$2[rsp]
  001d6	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_snprintf

; 3337 :         // "COMM: invalid parameter %s"
; 3338 :         WRMSG( HHC01017, "E", msgbuf );

  001dc	b9 01 00 00 00	 mov	 ecx, 1
  001e1	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  001e7	48 8d 8c 24 a0
	00 00 00	 lea	 rcx, QWORD PTR msgbuf$2[rsp]
  001ef	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  001f4	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG179189
  001fb	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  00200	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG179190
  00207	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  0020c	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00211	41 b9 03 00 00
	00		 mov	 r9d, 3
  00217	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG179191
  0021e	ba 0a 0d 00 00	 mov	 edx, 3338		; 00000d0aH
  00223	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG179192
  0022a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 3339 :         close_socket( lsock );

  00230	8b 4c 24 50	 mov	 ecx, DWORD PTR lsock$[rsp]
  00234	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_close_socket

; 3340 :         return -1;

  0023a	b8 ff ff ff ff	 mov	 eax, -1
  0023f	e9 b2 02 00 00	 jmp	 $LN1@get_listen
$LN12@get_listen:
$LN4@get_listen:

; 3341 :     }
; 3342 : 
; 3343 :     /* Attempt to bind the socket to the port */
; 3344 :     do
; 3345 :     {
; 3346 :         rc = bind( lsock, (struct sockaddr*) server,

  00244	48 63 44 24 50	 movsxd	 rax, DWORD PTR lsock$[rsp]
  00249	41 b8 10 00 00
	00		 mov	 r8d, 16
  0024f	48 8b 54 24 60	 mov	 rdx, QWORD PTR server$[rsp]
  00254	48 8b c8	 mov	 rcx, rax
  00257	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_bind
  0025d	89 44 24 54	 mov	 DWORD PTR rc$[rsp], eax

; 3347 :             sizeof( struct sockaddr_in ));
; 3348 : 
; 3349 :         if (rc == 0 || HSO_errno != HSO_EADDRINUSE)

  00261	83 7c 24 54 00	 cmp	 DWORD PTR rc$[rsp], 0
  00266	74 0d		 je	 SHORT $LN14@get_listen
  00268	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_WSAGetLastError
  0026e	3d 40 27 00 00	 cmp	 eax, 10048		; 00002740H
  00273	74 05		 je	 SHORT $LN13@get_listen
$LN14@get_listen:

; 3350 :             break;

  00275	e9 a4 00 00 00	 jmp	 $LN3@get_listen
$LN13@get_listen:

; 3351 : 
; 3352 :         // "Waiting for port %u to become free for console connections"
; 3353 :         WRMSG( HHC01023, "W", ntohs( server->sin_port ));

  0027a	48 8b 44 24 60	 mov	 rax, QWORD PTR server$[rsp]
  0027f	0f b7 48 02	 movzx	 ecx, WORD PTR [rax+2]
  00283	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ntohs
  00289	0f b7 c0	 movzx	 eax, ax
  0028c	89 44 24 6c	 mov	 DWORD PTR tv168[rsp], eax
  00290	b9 01 00 00 00	 mov	 ecx, 1
  00295	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  0029b	8b 4c 24 6c	 mov	 ecx, DWORD PTR tv168[rsp]
  0029f	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  002a3	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG179195
  002aa	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  002af	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG179196
  002b6	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  002bb	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  002c0	41 b9 03 00 00
	00		 mov	 r9d, 3
  002c6	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG179197
  002cd	ba 19 0d 00 00	 mov	 edx, 3353		; 00000d19H
  002d2	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG179198
  002d9	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg
$LN7@get_listen:

; 3354 :         SLEEP( 10 );

  002df	c7 44 24 58 0a
	00 00 00	 mov	 DWORD PTR rc$1[rsp], 10
$LN8@get_listen:
  002e7	83 7c 24 58 00	 cmp	 DWORD PTR rc$1[rsp], 0
  002ec	74 1d		 je	 SHORT $LN9@get_listen
  002ee	8b 4c 24 58	 mov	 ecx, DWORD PTR rc$1[rsp]
  002f2	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_sleep
  002f8	89 44 24 58	 mov	 DWORD PTR rc$1[rsp], eax
  002fc	83 7c 24 58 00	 cmp	 DWORD PTR rc$1[rsp], 0
  00301	74 06		 je	 SHORT $LN15@get_listen
  00303	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_sched_yield
$LN15@get_listen:
  00309	eb dc		 jmp	 SHORT $LN8@get_listen
$LN9@get_listen:
  0030b	33 c0		 xor	 eax, eax
  0030d	85 c0		 test	 eax, eax
  0030f	75 ce		 jne	 SHORT $LN7@get_listen

; 3355 :     }
; 3356 :     while (console_cnslcnt > 0);

  00311	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR console_cnslcnt, 0
  00318	0f 8f 26 ff ff
	ff		 jg	 $LN4@get_listen
$LN3@get_listen:

; 3357 : 
; 3358 :     if (rc != 0)

  0031e	83 7c 24 54 00	 cmp	 DWORD PTR rc$[rsp], 0
  00323	0f 84 95 00 00
	00		 je	 $LN16@get_listen

; 3359 :     {
; 3360 :         // "COMM: error in function %s: %s"
; 3361 :         WRMSG( HHC01034, "E", "bind()", strerror( HSO_errno ));

  00329	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_WSAGetLastError
  0032f	8b c8		 mov	 ecx, eax
  00331	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_strerror
  00337	48 89 84 24 88
	00 00 00	 mov	 QWORD PTR tv186[rsp], rax
  0033f	b9 01 00 00 00	 mov	 ecx, 1
  00344	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  0034a	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR tv186[rsp]
  00352	48 89 4c 24 40	 mov	 QWORD PTR [rsp+64], rcx
  00357	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG179201
  0035e	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  00363	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG179202
  0036a	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  0036f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG179203
  00376	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  0037b	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00380	41 b9 03 00 00
	00		 mov	 r9d, 3
  00386	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG179204
  0038d	ba 21 0d 00 00	 mov	 edx, 3361		; 00000d21H
  00392	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG179205
  00399	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 3362 :         free( server );

  0039f	48 8b 4c 24 60	 mov	 rcx, QWORD PTR server$[rsp]
  003a4	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free

; 3363 :         close_socket( lsock );

  003aa	8b 4c 24 50	 mov	 ecx, DWORD PTR lsock$[rsp]
  003ae	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_close_socket

; 3364 :         return -1;

  003b4	b8 ff ff ff ff	 mov	 eax, -1
  003b9	e9 38 01 00 00	 jmp	 $LN1@get_listen
$LN16@get_listen:

; 3365 :     }
; 3366 : 
; 3367 :     /* Put the socket into listening state */
; 3368 :     if ((rc = listen ( lsock, 10 )) < 0)

  003be	48 63 44 24 50	 movsxd	 rax, DWORD PTR lsock$[rsp]
  003c3	ba 0a 00 00 00	 mov	 edx, 10
  003c8	48 8b c8	 mov	 rcx, rax
  003cb	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_listen
  003d1	89 44 24 54	 mov	 DWORD PTR rc$[rsp], eax
  003d5	83 7c 24 54 00	 cmp	 DWORD PTR rc$[rsp], 0
  003da	0f 8d 95 00 00
	00		 jge	 $LN17@get_listen

; 3369 :     {
; 3370 :         // "COMM: error in function %s: %s"
; 3371 :         WRMSG( HHC01034, "E", "listen()", strerror( HSO_errno ));

  003e0	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_WSAGetLastError
  003e6	8b c8		 mov	 ecx, eax
  003e8	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_strerror
  003ee	48 89 84 24 90
	00 00 00	 mov	 QWORD PTR tv207[rsp], rax
  003f6	b9 01 00 00 00	 mov	 ecx, 1
  003fb	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  00401	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR tv207[rsp]
  00409	48 89 4c 24 40	 mov	 QWORD PTR [rsp+64], rcx
  0040e	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG179207
  00415	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  0041a	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG179208
  00421	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  00426	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG179209
  0042d	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00432	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00437	41 b9 03 00 00
	00		 mov	 r9d, 3
  0043d	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG179210
  00444	ba 2b 0d 00 00	 mov	 edx, 3371		; 00000d2bH
  00449	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG179211
  00450	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 3372 :         free( server );

  00456	48 8b 4c 24 60	 mov	 rcx, QWORD PTR server$[rsp]
  0045b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free

; 3373 :         close_socket( lsock );

  00461	8b 4c 24 50	 mov	 ecx, DWORD PTR lsock$[rsp]
  00465	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_close_socket

; 3374 :         return -1;

  0046b	b8 ff ff ff ff	 mov	 eax, -1
  00470	e9 81 00 00 00	 jmp	 $LN1@get_listen
$LN17@get_listen:

; 3375 :     }
; 3376 : 
; 3377 :     // "Waiting for %sconsole connections on port %u"
; 3378 :     WRMSG( HHC01024, "I", typ, ntohs( server->sin_port ));

  00475	48 8b 44 24 60	 mov	 rax, QWORD PTR server$[rsp]
  0047a	0f b7 48 02	 movzx	 ecx, WORD PTR [rax+2]
  0047e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ntohs
  00484	0f b7 c0	 movzx	 eax, ax
  00487	89 44 24 70	 mov	 DWORD PTR tv226[rsp], eax
  0048b	b9 01 00 00 00	 mov	 ecx, 1
  00490	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  00496	8b 4c 24 70	 mov	 ecx, DWORD PTR tv226[rsp]
  0049a	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  0049e	48 8b 8c 24 08
	01 00 00	 mov	 rcx, QWORD PTR typ$[rsp]
  004a6	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  004ab	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG179212
  004b2	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  004b7	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG179213
  004be	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  004c3	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  004c8	41 b9 03 00 00
	00		 mov	 r9d, 3
  004ce	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG179214
  004d5	ba 32 0d 00 00	 mov	 edx, 3378		; 00000d32H
  004da	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG179215
  004e1	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 3379 :     free( server );

  004e7	48 8b 4c 24 60	 mov	 rcx, QWORD PTR server$[rsp]
  004ec	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free

; 3380 :     return lsock;

  004f2	8b 44 24 50	 mov	 eax, DWORD PTR lsock$[rsp]
$LN1@get_listen:

; 3381 : }

  004f6	48 8b 8c 24 e0
	00 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  004fe	48 33 cc	 xor	 rcx, rsp
  00501	e8 00 00 00 00	 call	 __security_check_cookie
  00506	48 81 c4 f8 00
	00 00		 add	 rsp, 248		; 000000f8H
  0050d	c3		 ret	 0
get_listening_socket ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\console.c
_TEXT	SEGMENT
consto	PROC

; 3296 : {

  00000	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 3297 :     calcto();

  00004	e8 00 00 00 00	 call	 calcto

; 3298 : }

  00009	48 83 c4 28	 add	 rsp, 40			; 00000028H
  0000d	c3		 ret	 0
consto	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\console.c
_TEXT	SEGMENT
consio	PROC

; 3290 : {

  00000	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 3291 :     calcto();

  00004	e8 00 00 00 00	 call	 calcto

; 3292 :     memcpy( &previo, &currio, sizeof( struct timeval ));

  00009	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR currio
  00010	48 89 05 00 00
	00 00		 mov	 QWORD PTR previo, rax

; 3293 : }

  00017	48 83 c4 28	 add	 rsp, 40			; 00000028H
  0001b	c3		 ret	 0
consio	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\console.c
_TEXT	SEGMENT
tv71 = 64
prev_timeout$ = 72
tv77 = 80
calcto	PROC

; 3277 : {

  00000	48 83 ec 68	 sub	 rsp, 104		; 00000068H

; 3278 :     struct timespec* prev_timeout = timeout;

  00004	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR timeout
  0000b	48 89 44 24 48	 mov	 QWORD PTR prev_timeout$[rsp], rax

; 3279 :     gettimeofday( &currio, NULL );

  00010	33 d2		 xor	 edx, edx
  00012	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:currio
  00019	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_gettimeofday

; 3280 :     timeval_subtract( &previo, &currio, &diffio );

  0001f	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:diffio
  00026	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:currio
  0002d	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:previo
  00034	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_timeval_subtract

; 3281 :     timeout = (diffio.tv_sec  > 0 || diffio.tv_usec > 100000) ?

  0003a	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR diffio, 0
  00041	7f 1a		 jg	 SHORT $LN5@calcto
  00043	81 3d 04 00 00
	00 a0 86 01 00	 cmp	 DWORD PTR diffio+4, 100000 ; 000186a0H
  0004d	7f 0e		 jg	 SHORT $LN5@calcto
  0004f	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:fastpoll
  00056	48 89 44 24 40	 mov	 QWORD PTR tv71[rsp], rax
  0005b	eb 0c		 jmp	 SHORT $LN6@calcto
$LN5@calcto:
  0005d	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:slowpoll
  00064	48 89 44 24 40	 mov	 QWORD PTR tv71[rsp], rax
$LN6@calcto:
  00069	48 8b 44 24 40	 mov	 rax, QWORD PTR tv71[rsp]
  0006e	48 89 05 00 00
	00 00		 mov	 QWORD PTR timeout, rax

; 3282 :         &slowpoll : &fastpoll;
; 3283 :     if (MLVL( DEBUG ))

  00075	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  0007c	8b 80 80 75 01
	00		 mov	 eax, DWORD PTR [rax+95616]
  00082	25 00 00 00 40	 and	 eax, 1073741824		; 40000000H
  00087	85 c0		 test	 eax, eax
  00089	0f 84 87 00 00
	00		 je	 $LN2@calcto

; 3284 :         if (timeout != prev_timeout)

  0008f	48 8b 44 24 48	 mov	 rax, QWORD PTR prev_timeout$[rsp]
  00094	48 39 05 00 00
	00 00		 cmp	 QWORD PTR timeout, rax
  0009b	74 79		 je	 SHORT $LN3@calcto

; 3285 :             WRMSG( HHC02917, "D", &slowpoll == prev_timeout ?

  0009d	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:slowpoll
  000a4	48 3b 44 24 48	 cmp	 rax, QWORD PTR prev_timeout$[rsp]
  000a9	75 0e		 jne	 SHORT $LN7@calcto
  000ab	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG179131
  000b2	48 89 44 24 50	 mov	 QWORD PTR tv77[rsp], rax
  000b7	eb 0c		 jmp	 SHORT $LN8@calcto
$LN7@calcto:
  000b9	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG179132
  000c0	48 89 44 24 50	 mov	 QWORD PTR tv77[rsp], rax
$LN8@calcto:
  000c5	b9 01 00 00 00	 mov	 ecx, 1
  000ca	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  000d0	48 8b 4c 24 50	 mov	 rcx, QWORD PTR tv77[rsp]
  000d5	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  000da	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG179133
  000e1	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  000e6	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG179134
  000ed	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  000f2	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  000f7	41 b9 03 00 00
	00		 mov	 r9d, 3
  000fd	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG179135
  00104	ba d6 0c 00 00	 mov	 edx, 3286		; 00000cd6H
  00109	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG179136
  00110	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg
$LN3@calcto:
$LN2@calcto:

; 3286 :                 "slow to FAST" : "FAST to slow" );
; 3287 : }

  00116	48 83 c4 68	 add	 rsp, 104		; 00000068H
  0011a	c3		 ret	 0
calcto	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\console.c
_TEXT	SEGMENT
dev$ = 80
tn$ = 88
c$1 = 96
csock$ = 100
rc$ = 104
rc$2 = 108
clientip$ = 112
logobfr$ = 120
len$ = 128
tv386 = 136
tv392 = 140
tv422 = 144
tv583 = 148
tv589 = 152
f$3 = 156
namelen$ = 160
saved_errno$4 = 164
tv481 = 168
tv482 = 176
tv496 = 184
tv497 = 192
tv66 = 200
tv174 = 208
tv178 = 216
ctl$ = 224
tv200 = 232
tv211 = 240
tv215 = 248
tv346 = 256
tv400 = 264
tv522 = 272
tv530 = 280
logoheight$ = 288
client$ = 296
orig_cid$ = 312
rejmsg$ = 352
hostmsg$ = 608
hvermsg$ = 864
procsmsg$ = 1120
devmsg$ = 1376
buf$ = 1632
__$ArrayPad$ = 3552
pArg$ = 3584
connect_client PROC

; 2860 : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	57		 push	 rdi
  00006	48 81 ec f0 0d
	00 00		 sub	 rsp, 3568		; 00000df0H
  0000d	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00014	48 33 c4	 xor	 rax, rsp
  00017	48 89 84 24 e0
	0d 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 2861 : TELNET                 *tn;             /* Telnet Control Block      */
; 2862 : telnet_t               *ctl;            /* libtelnet state tracker   */
; 2863 : int                     csock;          /* Client socket             */
; 2864 : 
; 2865 : int                     rc;             /* Return code               */
; 2866 : DEVBLK                 *dev;            /* -> Device block           */
; 2867 : size_t                  len;            /* Data length               */
; 2868 : 
; 2869 : struct sockaddr_in      client;         /* Client address structure  */
; 2870 : socklen_t               namelen;        /* Length of client structure*/
; 2871 : char                   *clientip;       /* Addr of client ip address */
; 2872 : char                    buf[1920];      /* Work buffer               */
; 2873 : char                    orig_cid[32];   /* e.g. "client 123"         */
; 2874 : 
; 2875 : char                    hvermsg[256];   /* "Hercules version ..."    */
; 2876 : char                    hostmsg[256];   /* "Running on..."           */
; 2877 : char                    procsmsg[256];  /* #of processors string     */
; 2878 : 
; 2879 : char                    rejmsg[256];    /* Rejection message         */
; 2880 : char                    devmsg[256];    /* Device message            */
; 2881 : 
; 2882 : BYTE                   *logobfr;        /* Constructed logo screen   */
; 2883 : size_t                  logoheight;     /* Logo file number of lines */
; 2884 : 
; 2885 :     /* Initialize some local variables */
; 2886 :     tn    = (TELNET*) pArg;

  0001f	48 8b 84 24 00
	0e 00 00	 mov	 rax, QWORD PTR pArg$[rsp]
  00027	48 89 44 24 58	 mov	 QWORD PTR tn$[rsp], rax

; 2887 :     csock = tn->csock;

  0002c	48 8b 44 24 58	 mov	 rax, QWORD PTR tn$[rsp]
  00031	8b 80 84 00 00
	00		 mov	 eax, DWORD PTR [rax+132]
  00037	89 44 24 64	 mov	 DWORD PTR csock$[rsp], eax

; 2888 :     ctl   = tn->ctl;

  0003b	48 8b 44 24 58	 mov	 rax, QWORD PTR tn$[rsp]
  00040	48 8b 80 98 00
	00 00		 mov	 rax, QWORD PTR [rax+152]
  00047	48 89 84 24 e0
	00 00 00	 mov	 QWORD PTR ctl$[rsp], rax

; 2889 : 
; 2890 :     // "%s COMM: connection received"
; 2891 :     WRMSG( HHC02915, "I", tn->clientid );

  0004f	48 8b 44 24 58	 mov	 rax, QWORD PTR tn$[rsp]
  00054	48 83 c0 62	 add	 rax, 98			; 00000062H
  00058	48 89 84 24 c8
	00 00 00	 mov	 QWORD PTR tv66[rsp], rax
  00060	b9 01 00 00 00	 mov	 ecx, 1
  00065	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  0006b	48 8b 8c 24 c8
	00 00 00	 mov	 rcx, QWORD PTR tv66[rsp]
  00073	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  00078	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG178985
  0007f	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  00084	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG178986
  0008b	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00090	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00095	41 b9 03 00 00
	00		 mov	 r9d, 3
  0009b	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG178987
  000a2	ba 4b 0b 00 00	 mov	 edx, 2891		; 00000b4bH
  000a7	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG178988
  000ae	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 2892 : 
; 2893 :     // "Hercules version %s, built on %s %s"
; 2894 :     // (Note: "MSG_C" used so message does NOT end with newline)
; 2895 :     MSGBUF( hvermsg, MSG_C( HHC01027, "I", VERSION, __DATE__, __TIME__ ));

  000b4	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG178989
  000bb	48 89 44 24 30	 mov	 QWORD PTR [rsp+48], rax
  000c0	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG178990
  000c7	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  000cc	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG178991
  000d3	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  000d8	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG178992
  000df	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG178993
  000e6	ba 00 01 00 00	 mov	 edx, 256		; 00000100H
  000eb	48 8d 8c 24 60
	03 00 00	 lea	 rcx, QWORD PTR hvermsg$[rsp]
  000f3	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_snprintf

; 2896 : 
; 2897 :     // "LP=%d, Cores=%d, CPUs=%d",
; 2898 :     // or "MP=%d", or "UP" or ""
; 2899 :     if (1
; 2900 :         && hostinfo.num_packages      !=  0
; 2901 :         && hostinfo.num_physical_cpu  !=  0
; 2902 :         && hostinfo.num_logical_cpu   !=  0

  000f9	33 c0		 xor	 eax, eax
  000fb	83 f8 01	 cmp	 eax, 1
  000fe	74 7f		 je	 SHORT $LN22@connect_cl
  00100	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_hostinfo
  00107	83 b8 c4 01 00
	00 00		 cmp	 DWORD PTR [rax+452], 0
  0010e	74 6f		 je	 SHORT $LN22@connect_cl
  00110	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_hostinfo
  00117	83 b8 bc 01 00
	00 00		 cmp	 DWORD PTR [rax+444], 0
  0011e	74 5f		 je	 SHORT $LN22@connect_cl
  00120	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_hostinfo
  00127	83 b8 c0 01 00
	00 00		 cmp	 DWORD PTR [rax+448], 0
  0012e	74 4f		 je	 SHORT $LN22@connect_cl

; 2903 :     )
; 2904 :     {
; 2905 :         MSGBUF( procsmsg, "LP=%d, Cores=%d, CPUs=%d"

  00130	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_hostinfo
  00137	8b 80 c4 01 00
	00		 mov	 eax, DWORD PTR [rax+452]
  0013d	89 44 24 28	 mov	 DWORD PTR [rsp+40], eax
  00141	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_hostinfo
  00148	8b 80 bc 01 00
	00		 mov	 eax, DWORD PTR [rax+444]
  0014e	89 44 24 20	 mov	 DWORD PTR [rsp+32], eax
  00152	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_hostinfo
  00159	44 8b 88 c0 01
	00 00		 mov	 r9d, DWORD PTR [rax+448]
  00160	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG178996
  00167	ba 00 01 00 00	 mov	 edx, 256		; 00000100H
  0016c	48 8d 8c 24 60
	04 00 00	 lea	 rcx, QWORD PTR procsmsg$[rsp]
  00174	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_snprintf

; 2906 :             , hostinfo.num_logical_cpu
; 2907 :             , hostinfo.num_physical_cpu
; 2908 :             , hostinfo.num_packages
; 2909 :         );
; 2910 :     }

  0017a	e9 82 00 00 00	 jmp	 $LN23@connect_cl
$LN22@connect_cl:

; 2911 :     else
; 2912 :     {
; 2913 :         if (hostinfo.num_procs > 1)

  0017f	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_hostinfo
  00186	83 b8 b8 01 00
	00 01		 cmp	 DWORD PTR [rax+440], 1
  0018d	7e 2a		 jle	 SHORT $LN24@connect_cl

; 2914 :             MSGBUF(  procsmsg, "MP=%d", hostinfo.num_procs );

  0018f	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_hostinfo
  00196	44 8b 88 b8 01
	00 00		 mov	 r9d, DWORD PTR [rax+440]
  0019d	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG178999
  001a4	ba 00 01 00 00	 mov	 edx, 256		; 00000100H
  001a9	48 8d 8c 24 60
	04 00 00	 lea	 rcx, QWORD PTR procsmsg$[rsp]
  001b1	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_snprintf
  001b7	eb 48		 jmp	 SHORT $LN25@connect_cl
$LN24@connect_cl:

; 2915 :         else if (hostinfo.num_procs == 1)

  001b9	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_hostinfo
  001c0	83 b8 b8 01 00
	00 01		 cmp	 DWORD PTR [rax+440], 1
  001c7	75 1d		 jne	 SHORT $LN26@connect_cl

; 2916 :             STRLCPY( procsmsg, "UP" );

  001c9	41 b8 00 01 00
	00		 mov	 r8d, 256		; 00000100H
  001cf	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG179002
  001d6	48 8d 8c 24 60
	04 00 00	 lea	 rcx, QWORD PTR procsmsg$[rsp]
  001de	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_strlcpy
  001e4	eb 1b		 jmp	 SHORT $LN27@connect_cl
$LN26@connect_cl:

; 2917 :         else
; 2918 :             STRLCPY( procsmsg, "" );

  001e6	41 b8 00 01 00
	00		 mov	 r8d, 256		; 00000100H
  001ec	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG179003
  001f3	48 8d 8c 24 60
	04 00 00	 lea	 rcx, QWORD PTR procsmsg$[rsp]
  001fb	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_strlcpy
$LN27@connect_cl:
$LN25@connect_cl:
$LN23@connect_cl:

; 2919 :     }
; 2920 : 
; 2921 :     // "Running on %s (%s-%s.%s %s %s)"
; 2922 :     // (Note: "MSG_C" used so message does NOT end with newline)
; 2923 :     MSGBUF( hostmsg, MSG_C( HHC01031, "I"

  00201	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_hostinfo
  00208	48 05 30 01 00
	00		 add	 rax, 304		; 00000130H
  0020e	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_hostinfo
  00215	48 81 c1 f0 00
	00 00		 add	 rcx, 240		; 000000f0H
  0021c	48 8b 15 00 00
	00 00		 mov	 rdx, QWORD PTR __imp_hostinfo
  00223	48 81 c2 b0 00
	00 00		 add	 rdx, 176		; 000000b0H
  0022a	4c 8b 05 00 00
	00 00		 mov	 r8, QWORD PTR __imp_hostinfo
  00231	49 83 c0 30	 add	 r8, 48			; 00000030H
  00235	4c 8b 0d 00 00
	00 00		 mov	 r9, QWORD PTR __imp_hostinfo
  0023c	49 83 c1 70	 add	 r9, 112			; 00000070H
  00240	4c 8d 94 24 60
	04 00 00	 lea	 r10, QWORD PTR procsmsg$[rsp]
  00248	4c 89 54 24 48	 mov	 QWORD PTR [rsp+72], r10
  0024d	48 89 44 24 40	 mov	 QWORD PTR [rsp+64], rax
  00252	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  00257	48 89 54 24 30	 mov	 QWORD PTR [rsp+48], rdx
  0025c	4c 89 44 24 28	 mov	 QWORD PTR [rsp+40], r8
  00261	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00266	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG179004
  0026d	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG179005
  00274	ba 00 01 00 00	 mov	 edx, 256		; 00000100H
  00279	48 8d 8c 24 60
	02 00 00	 lea	 rcx, QWORD PTR hostmsg$[rsp]
  00281	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_snprintf

; 2924 :         , hostinfo.nodename
; 2925 :         , hostinfo.sysname
; 2926 :         , hostinfo.release
; 2927 :         , hostinfo.version
; 2928 :         , hostinfo.machine
; 2929 :         , procsmsg)
; 2930 :     );
; 2931 : 
; 2932 :     /* Obtain the client's IP address */
; 2933 :     namelen = sizeof( client );

  00287	c7 84 24 a0 00
	00 00 10 00 00
	00		 mov	 DWORD PTR namelen$[rsp], 16

; 2934 :     rc = getpeername( csock, (struct sockaddr*) &client, &namelen );

  00292	48 63 44 24 64	 movsxd	 rax, DWORD PTR csock$[rsp]
  00297	4c 8d 84 24 a0
	00 00 00	 lea	 r8, QWORD PTR namelen$[rsp]
  0029f	48 8d 94 24 28
	01 00 00	 lea	 rdx, QWORD PTR client$[rsp]
  002a7	48 8b c8	 mov	 rcx, rax
  002aa	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_getpeername
  002b0	89 44 24 68	 mov	 DWORD PTR rc$[rsp], eax

; 2935 : 
; 2936 :     // "%s COMM: received connection from %s"
; 2937 :     clientip = strdup( inet_ntoa( client.sin_addr ));

  002b4	8b 8c 24 2c 01
	00 00		 mov	 ecx, DWORD PTR client$[rsp+4]
  002bb	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_inet_ntoa
  002c1	48 8b c8	 mov	 rcx, rax
  002c4	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_strdup
  002ca	48 89 44 24 70	 mov	 QWORD PTR clientip$[rsp], rax

; 2938 :     CONDEBUG1( HHC90505, "D", tn->clientid, clientip );
; 2939 : 
; 2940 :     /* Dr. Hans-Walter Latz -- binary xfer mode performance tweak
; 2941 :        See: http://www.unixguide.net/network/socketfaq/2.16.shtml
; 2942 :     */
; 2943 :     if (disable_nagle(csock) < 0)

  002cf	8b 4c 24 64	 mov	 ecx, DWORD PTR csock$[rsp]
  002d3	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_disable_nagle
  002d9	85 c0		 test	 eax, eax
  002db	0f 8d 88 00 00
	00		 jge	 $LN28@connect_cl

; 2944 :         // "%s COMM: setsockopt() failed: %s"
; 2945 :         CONERROR( HHC90510, "D", tn->clientid, strerror( HSO_errno ));

  002e1	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_WSAGetLastError
  002e7	8b c8		 mov	 ecx, eax
  002e9	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_strerror
  002ef	48 89 84 24 d0
	00 00 00	 mov	 QWORD PTR tv174[rsp], rax
  002f7	48 8b 4c 24 58	 mov	 rcx, QWORD PTR tn$[rsp]
  002fc	48 83 c1 62	 add	 rcx, 98			; 00000062H
  00300	48 89 8c 24 d8
	00 00 00	 mov	 QWORD PTR tv178[rsp], rcx
  00308	b9 01 00 00 00	 mov	 ecx, 1
  0030d	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  00313	48 8b 8c 24 d0
	00 00 00	 mov	 rcx, QWORD PTR tv174[rsp]
  0031b	48 89 4c 24 40	 mov	 QWORD PTR [rsp+64], rcx
  00320	48 8b 8c 24 d8
	00 00 00	 mov	 rcx, QWORD PTR tv178[rsp]
  00328	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  0032d	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG179007
  00334	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  00339	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG179008
  00340	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00345	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  0034a	41 b9 03 00 00
	00		 mov	 r9d, 3
  00350	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG179009
  00357	ba 81 0b 00 00	 mov	 edx, 2945		; 00000b81H
  0035c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG179010
  00363	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg
$LN28@connect_cl:
$LN4@connect_cl:

; 2946 : 
; 2947 :     /* Determine client's terminal type by reading from the socket
; 2948 :        and passing all data to libtelnet so it can pass it to our
; 2949 :        telnet event handler until we eventually learn their TTYPE.
; 2950 :        Note that during this process any non-telnet client data we
; 2951 :        may receive is discarded by our event handler as premature;
; 2952 :        we shouldn't be receiving data from the client until we ask
; 2953 :        for it which we never do until negotiations are complete.
; 2954 :     */
; 2955 :     do
; 2956 :     {
; 2957 :         /* Read client telnet negotiation data */
; 2958 :         if ((rc = recv( csock, buf, sizeof( buf ), 0 )) > 0)

  00369	48 63 44 24 64	 movsxd	 rax, DWORD PTR csock$[rsp]
  0036e	45 33 c9	 xor	 r9d, r9d
  00371	41 b8 80 07 00
	00		 mov	 r8d, 1920		; 00000780H
  00377	48 8d 94 24 60
	06 00 00	 lea	 rdx, QWORD PTR buf$[rsp]
  0037f	48 8b c8	 mov	 rcx, rax
  00382	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_recv
  00388	89 44 24 68	 mov	 DWORD PTR rc$[rsp], eax
  0038c	83 7c 24 68 00	 cmp	 DWORD PTR rc$[rsp], 0
  00391	7e 1f		 jle	 SHORT $LN29@connect_cl

; 2959 :         {
; 2960 :             // "%s COMM: received %d bytes"
; 2961 :             CONDEBUG2( HHC90501, "D", tn->clientid, rc );
; 2962 :             DUMPBUF(   HHC90501, buf, rc, tn->do_tn3270 ? 1 : 0 );
; 2963 : 
; 2964 :             /* Pass data to libtelnet to pass to our event handler */
; 2965 :             telnet_recv( ctl, (BYTE*) buf, rc );

  00393	44 8b 44 24 68	 mov	 r8d, DWORD PTR rc$[rsp]
  00398	48 8d 94 24 60
	06 00 00	 lea	 rdx, QWORD PTR buf$[rsp]
  003a0	48 8b 8c 24 e0
	00 00 00	 mov	 rcx, QWORD PTR ctl$[rsp]
  003a8	e8 00 00 00 00	 call	 telnet_recv

; 2966 :         }

  003ad	e9 1d 01 00 00	 jmp	 $LN30@connect_cl
$LN29@connect_cl:

; 2967 :         else /* recv() error or connection closed */
; 2968 :         {
; 2969 :             if (rc == 0)

  003b2	83 7c 24 68 00	 cmp	 DWORD PTR rc$[rsp], 0
  003b7	75 6a		 jne	 SHORT $LN31@connect_cl

; 2970 :                 // "%s COMM: connection closed during negotiations"
; 2971 :                 WRMSG( HHC02908, "E", tn->clientid );

  003b9	48 8b 44 24 58	 mov	 rax, QWORD PTR tn$[rsp]
  003be	48 83 c0 62	 add	 rax, 98			; 00000062H
  003c2	48 89 84 24 e8
	00 00 00	 mov	 QWORD PTR tv200[rsp], rax
  003ca	b9 01 00 00 00	 mov	 ecx, 1
  003cf	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  003d5	48 8b 8c 24 e8
	00 00 00	 mov	 rcx, QWORD PTR tv200[rsp]
  003dd	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  003e2	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG179015
  003e9	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  003ee	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG179016
  003f5	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  003fa	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  003ff	41 b9 03 00 00
	00		 mov	 r9d, 3
  00405	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG179017
  0040c	ba 9b 0b 00 00	 mov	 edx, 2971		; 00000b9bH
  00411	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG179018
  00418	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg
  0041e	e9 88 00 00 00	 jmp	 $LN32@connect_cl
$LN31@connect_cl:

; 2972 :             else
; 2973 :                 // "%s COMM: recv() error during negotiations: %s"
; 2974 :                 WRMSG( HHC02909, "E", tn->clientid, strerror( errno ));

  00423	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno
  00429	8b 08		 mov	 ecx, DWORD PTR [rax]
  0042b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_strerror
  00431	48 89 84 24 f0
	00 00 00	 mov	 QWORD PTR tv211[rsp], rax
  00439	48 8b 4c 24 58	 mov	 rcx, QWORD PTR tn$[rsp]
  0043e	48 83 c1 62	 add	 rcx, 98			; 00000062H
  00442	48 89 8c 24 f8
	00 00 00	 mov	 QWORD PTR tv215[rsp], rcx
  0044a	b9 01 00 00 00	 mov	 ecx, 1
  0044f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  00455	48 8b 8c 24 f0
	00 00 00	 mov	 rcx, QWORD PTR tv211[rsp]
  0045d	48 89 4c 24 40	 mov	 QWORD PTR [rsp+64], rcx
  00462	48 8b 8c 24 f8
	00 00 00	 mov	 rcx, QWORD PTR tv215[rsp]
  0046a	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  0046f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG179019
  00476	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  0047b	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG179020
  00482	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00487	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  0048c	41 b9 03 00 00
	00		 mov	 r9d, 3
  00492	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG179021
  00499	ba 9e 0b 00 00	 mov	 edx, 2974		; 00000b9eH
  0049e	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG179022
  004a5	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg
$LN32@connect_cl:

; 2975 : 
; 2976 :             /* Discard client connection */
; 2977 :             disconnect_telnet_client( tn );

  004ab	48 8b 4c 24 58	 mov	 rcx, QWORD PTR tn$[rsp]
  004b0	e8 00 00 00 00	 call	 disconnect_telnet_client

; 2978 :             if (clientip)

  004b5	48 83 7c 24 70
	00		 cmp	 QWORD PTR clientip$[rsp], 0
  004bb	74 0b		 je	 SHORT $LN33@connect_cl

; 2979 :                 free( clientip );

  004bd	48 8b 4c 24 70	 mov	 rcx, QWORD PTR clientip$[rsp]
  004c2	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free
$LN33@connect_cl:

; 2980 :             return NULL;

  004c8	33 c0		 xor	 eax, eax
  004ca	e9 e4 0e 00 00	 jmp	 $LN1@connect_cl
$LN30@connect_cl:

; 2981 :         }
; 2982 :     }
; 2983 :     while (1
; 2984 :         && !tn->ttype[0]        /* (what we're really interested in) */
; 2985 :         && !tn->neg_fail
; 2986 :         && !tn->send_err
; 2987 :         && !tn->overflow

  004cf	33 c0		 xor	 eax, eax
  004d1	83 f8 01	 cmp	 eax, 1
  004d4	74 4b		 je	 SHORT $LN34@connect_cl
  004d6	b8 01 00 00 00	 mov	 eax, 1
  004db	48 6b c0 00	 imul	 rax, rax, 0
  004df	48 8b 4c 24 58	 mov	 rcx, QWORD PTR tn$[rsp]
  004e4	0f be 44 01 29	 movsx	 eax, BYTE PTR [rcx+rax+41]
  004e9	85 c0		 test	 eax, eax
  004eb	75 34		 jne	 SHORT $LN34@connect_cl
  004ed	48 8b 44 24 58	 mov	 rax, QWORD PTR tn$[rsp]
  004f2	0f b6 80 b3 00
	00 00		 movzx	 eax, BYTE PTR [rax+179]
  004f9	85 c0		 test	 eax, eax
  004fb	75 24		 jne	 SHORT $LN34@connect_cl
  004fd	48 8b 44 24 58	 mov	 rax, QWORD PTR tn$[rsp]
  00502	0f b6 80 b4 00
	00 00		 movzx	 eax, BYTE PTR [rax+180]
  00509	85 c0		 test	 eax, eax
  0050b	75 14		 jne	 SHORT $LN34@connect_cl
  0050d	48 8b 44 24 58	 mov	 rax, QWORD PTR tn$[rsp]
  00512	0f b6 80 b5 00
	00 00		 movzx	 eax, BYTE PTR [rax+181]
  00519	85 c0		 test	 eax, eax
  0051b	0f 84 48 fe ff
	ff		 je	 $LN4@connect_cl
$LN34@connect_cl:

; 2988 :     );
; 2989 : 
; 2990 :     /* Abort connection on error */
; 2991 :     if (0
; 2992 :         || tn->neg_fail
; 2993 :         || tn->send_err
; 2994 :         || tn->overflow

  00521	33 c0		 xor	 eax, eax
  00523	85 c0		 test	 eax, eax
  00525	75 30		 jne	 SHORT $LN36@connect_cl
  00527	48 8b 44 24 58	 mov	 rax, QWORD PTR tn$[rsp]
  0052c	0f b6 80 b3 00
	00 00		 movzx	 eax, BYTE PTR [rax+179]
  00533	85 c0		 test	 eax, eax
  00535	75 20		 jne	 SHORT $LN36@connect_cl
  00537	48 8b 44 24 58	 mov	 rax, QWORD PTR tn$[rsp]
  0053c	0f b6 80 b4 00
	00 00		 movzx	 eax, BYTE PTR [rax+180]
  00543	85 c0		 test	 eax, eax
  00545	75 10		 jne	 SHORT $LN36@connect_cl
  00547	48 8b 44 24 58	 mov	 rax, QWORD PTR tn$[rsp]
  0054c	0f b6 80 b5 00
	00 00		 movzx	 eax, BYTE PTR [rax+181]
  00553	85 c0		 test	 eax, eax
  00555	74 24		 je	 SHORT $LN35@connect_cl
$LN36@connect_cl:

; 2995 :     )
; 2996 :     {
; 2997 :         /* (error message already issued) */
; 2998 :         disconnect_telnet_client( tn );

  00557	48 8b 4c 24 58	 mov	 rcx, QWORD PTR tn$[rsp]
  0055c	e8 00 00 00 00	 call	 disconnect_telnet_client

; 2999 :         if (clientip)

  00561	48 83 7c 24 70
	00		 cmp	 QWORD PTR clientip$[rsp], 0
  00567	74 0b		 je	 SHORT $LN37@connect_cl

; 3000 :             free( clientip );

  00569	48 8b 4c 24 70	 mov	 rcx, QWORD PTR clientip$[rsp]
  0056e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free
$LN37@connect_cl:

; 3001 :         return NULL;

  00574	33 c0		 xor	 eax, eax
  00576	e9 38 0e 00 00	 jmp	 $LN1@connect_cl
$LN35@connect_cl:

; 3002 :     }
; 3003 : 
; 3004 :     /* Look for an available console device */
; 3005 :     for (dev = sysblk.firstdev; dev != NULL; dev = dev->nextdev)

  0057b	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00582	48 8b 80 c0 11
	00 00		 mov	 rax, QWORD PTR [rax+4544]
  00589	48 89 44 24 50	 mov	 QWORD PTR dev$[rsp], rax
  0058e	eb 0e		 jmp	 SHORT $LN7@connect_cl
$LN5@connect_cl:
  00590	48 8b 44 24 50	 mov	 rax, QWORD PTR dev$[rsp]
  00595	48 8b 40 30	 mov	 rax, QWORD PTR [rax+48]
  00599	48 89 44 24 50	 mov	 QWORD PTR dev$[rsp], rax
$LN7@connect_cl:
  0059e	48 83 7c 24 50
	00		 cmp	 QWORD PTR dev$[rsp], 0
  005a4	0f 84 69 05 00
	00		 je	 $LN6@connect_cl

; 3006 :     {
; 3007 :         if (sysblk.sysgport)

  005aa	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  005b1	48 83 b8 f0 13
	00 00 00	 cmp	 QWORD PTR [rax+5104], 0
  005b9	74 52		 je	 SHORT $LN38@connect_cl

; 3008 :         {
; 3009 :             /* Loop if they want the SYSG device and this isn't it,
; 3010 :                or they DON'T want the SYSG device and this IS it. */
; 3011 :             if (0
; 3012 :                 || ( tn->sysg && dev != sysblk.sysgdev)
; 3013 :                 || (!tn->sysg && dev == sysblk.sysgdev)

  005bb	33 c0		 xor	 eax, eax
  005bd	85 c0		 test	 eax, eax
  005bf	75 4a		 jne	 SHORT $LN40@connect_cl
  005c1	48 8b 44 24 58	 mov	 rax, QWORD PTR tn$[rsp]
  005c6	0f b6 80 88 00
	00 00		 movzx	 eax, BYTE PTR [rax+136]
  005cd	85 c0		 test	 eax, eax
  005cf	74 15		 je	 SHORT $LN41@connect_cl
  005d1	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  005d8	48 8b 80 c8 11
	00 00		 mov	 rax, QWORD PTR [rax+4552]
  005df	48 39 44 24 50	 cmp	 QWORD PTR dev$[rsp], rax
  005e4	75 25		 jne	 SHORT $LN40@connect_cl
$LN41@connect_cl:
  005e6	48 8b 44 24 58	 mov	 rax, QWORD PTR tn$[rsp]
  005eb	0f b6 80 88 00
	00 00		 movzx	 eax, BYTE PTR [rax+136]
  005f2	85 c0		 test	 eax, eax
  005f4	75 17		 jne	 SHORT $LN39@connect_cl
  005f6	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  005fd	48 8b 80 c8 11
	00 00		 mov	 rax, QWORD PTR [rax+4552]
  00604	48 39 44 24 50	 cmp	 QWORD PTR dev$[rsp], rax
  00609	75 02		 jne	 SHORT $LN39@connect_cl
$LN40@connect_cl:

; 3014 :             )
; 3015 :                 continue;

  0060b	eb 83		 jmp	 SHORT $LN5@connect_cl
$LN39@connect_cl:
$LN38@connect_cl:

; 3016 :         }
; 3017 : 
; 3018 :         /* Loop if the device is invalid */
; 3019 :         if ( !dev->allocated )

  0060d	48 8b 44 24 50	 mov	 rax, QWORD PTR dev$[rsp]
  00612	83 78 40 00	 cmp	 DWORD PTR [rax+64], 0
  00616	75 05		 jne	 SHORT $LN42@connect_cl

; 3020 :             continue;

  00618	e9 73 ff ff ff	 jmp	 $LN5@connect_cl
$LN42@connect_cl:

; 3021 : 
; 3022 :         /* Loop if non-matching device type */
; 3023 :         if (tn->devclass == 'D' && dev->devtype != 0x3270)

  0061d	48 8b 44 24 58	 mov	 rax, QWORD PTR tn$[rsp]
  00622	0f b6 80 aa 00
	00 00		 movzx	 eax, BYTE PTR [rax+170]
  00629	83 f8 44	 cmp	 eax, 68			; 00000044H
  0062c	75 15		 jne	 SHORT $LN43@connect_cl
  0062e	48 8b 44 24 50	 mov	 rax, QWORD PTR dev$[rsp]
  00633	0f b7 40 4a	 movzx	 eax, WORD PTR [rax+74]
  00637	3d 70 32 00 00	 cmp	 eax, 12912		; 00003270H
  0063c	74 05		 je	 SHORT $LN43@connect_cl

; 3024 :             continue;

  0063e	e9 4d ff ff ff	 jmp	 $LN5@connect_cl
$LN43@connect_cl:

; 3025 : 
; 3026 :         if (tn->devclass == 'P' && dev->devtype != 0x3287)

  00643	48 8b 44 24 58	 mov	 rax, QWORD PTR tn$[rsp]
  00648	0f b6 80 aa 00
	00 00		 movzx	 eax, BYTE PTR [rax+170]
  0064f	83 f8 50	 cmp	 eax, 80			; 00000050H
  00652	75 15		 jne	 SHORT $LN44@connect_cl
  00654	48 8b 44 24 50	 mov	 rax, QWORD PTR dev$[rsp]
  00659	0f b7 40 4a	 movzx	 eax, WORD PTR [rax+74]
  0065d	3d 87 32 00 00	 cmp	 eax, 12935		; 00003287H
  00662	74 05		 je	 SHORT $LN44@connect_cl

; 3027 :             continue;

  00664	e9 27 ff ff ff	 jmp	 $LN5@connect_cl
$LN44@connect_cl:

; 3028 : 
; 3029 :         if (tn->devclass == 'K' && dev->devtype != 0x1052
; 3030 :                                 && dev->devtype != 0x3215)

  00669	48 8b 44 24 58	 mov	 rax, QWORD PTR tn$[rsp]
  0066e	0f b6 80 aa 00
	00 00		 movzx	 eax, BYTE PTR [rax+170]
  00675	83 f8 4b	 cmp	 eax, 75			; 0000004bH
  00678	75 25		 jne	 SHORT $LN45@connect_cl
  0067a	48 8b 44 24 50	 mov	 rax, QWORD PTR dev$[rsp]
  0067f	0f b7 40 4a	 movzx	 eax, WORD PTR [rax+74]
  00683	3d 52 10 00 00	 cmp	 eax, 4178		; 00001052H
  00688	74 15		 je	 SHORT $LN45@connect_cl
  0068a	48 8b 44 24 50	 mov	 rax, QWORD PTR dev$[rsp]
  0068f	0f b7 40 4a	 movzx	 eax, WORD PTR [rax+74]
  00693	3d 15 32 00 00	 cmp	 eax, 12821		; 00003215H
  00698	74 05		 je	 SHORT $LN45@connect_cl

; 3031 :             continue;

  0069a	e9 f1 fe ff ff	 jmp	 $LN5@connect_cl
$LN45@connect_cl:

; 3032 : 
; 3033 :         /* Loop if a specific device number was requested and
; 3034 :            this device is not the requested device number */
; 3035 :         if (tn->devnum != 0xFFFF && dev->devnum != tn->devnum)

  0069f	48 8b 44 24 58	 mov	 rax, QWORD PTR tn$[rsp]
  006a4	0f b7 80 a8 00
	00 00		 movzx	 eax, WORD PTR [rax+168]
  006ab	3d ff ff 00 00	 cmp	 eax, 65535		; 0000ffffH
  006b0	74 1e		 je	 SHORT $LN46@connect_cl
  006b2	48 8b 44 24 50	 mov	 rax, QWORD PTR dev$[rsp]
  006b7	0f b7 40 48	 movzx	 eax, WORD PTR [rax+72]
  006bb	48 8b 4c 24 58	 mov	 rcx, QWORD PTR tn$[rsp]
  006c0	0f b7 89 a8 00
	00 00		 movzx	 ecx, WORD PTR [rcx+168]
  006c7	3b c1		 cmp	 eax, ecx
  006c9	74 05		 je	 SHORT $LN46@connect_cl

; 3036 :             continue;  /* (not our device) */

  006cb	e9 c0 fe ff ff	 jmp	 $LN5@connect_cl
$LN46@connect_cl:

; 3037 : 
; 3038 :         /* Loop if no specific device number was requested, and
; 3039 :            either a group was requested OR the device is in a group,
; 3040 :            and the device group does not match the requested group */
; 3041 :         if (tn->devnum == 0xFFFF && (tn->tgroup[0] || dev->filename[0]))

  006d0	48 8b 44 24 58	 mov	 rax, QWORD PTR tn$[rsp]
  006d5	0f b7 80 a8 00
	00 00		 movzx	 eax, WORD PTR [rax+168]
  006dc	3d ff ff 00 00	 cmp	 eax, 65535		; 0000ffffH
  006e1	75 5d		 jne	 SHORT $LN47@connect_cl
  006e3	b8 01 00 00 00	 mov	 eax, 1
  006e8	48 6b c0 00	 imul	 rax, rax, 0
  006ec	48 8b 4c 24 58	 mov	 rcx, QWORD PTR tn$[rsp]
  006f1	0f be 44 01 52	 movsx	 eax, BYTE PTR [rcx+rax+82]
  006f6	85 c0		 test	 eax, eax
  006f8	75 1a		 jne	 SHORT $LN48@connect_cl
  006fa	b8 01 00 00 00	 mov	 eax, 1
  006ff	48 6b c0 00	 imul	 rax, rax, 0
  00703	48 8b 4c 24 50	 mov	 rcx, QWORD PTR dev$[rsp]
  00708	0f be 84 01 a4
	00 00 00	 movsx	 eax, BYTE PTR [rcx+rax+164]
  00710	85 c0		 test	 eax, eax
  00712	74 2c		 je	 SHORT $LN47@connect_cl
$LN48@connect_cl:

; 3042 :         {
; 3043 :             if (strncasecmp( tn->tgroup, dev->filename, sizeof( tn->tgroup )) != 0)

  00714	48 8b 44 24 50	 mov	 rax, QWORD PTR dev$[rsp]
  00719	48 05 a4 00 00
	00		 add	 rax, 164		; 000000a4H
  0071f	48 8b 4c 24 58	 mov	 rcx, QWORD PTR tn$[rsp]
  00724	48 83 c1 52	 add	 rcx, 82			; 00000052H
  00728	41 b8 10 00 00
	00		 mov	 r8d, 16
  0072e	48 8b d0	 mov	 rdx, rax
  00731	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__strnicmp
  00737	85 c0		 test	 eax, eax
  00739	74 05		 je	 SHORT $LN49@connect_cl

; 3044 :                 continue;  /* (not our terminal group) */

  0073b	e9 50 fe ff ff	 jmp	 $LN5@connect_cl
$LN49@connect_cl:
$LN47@connect_cl:

; 3045 :         }
; 3046 : 
; 3047 :         /* Obtain the device lock */
; 3048 :         obtain_lock( &dev->lock );

  00740	48 8b 44 24 50	 mov	 rax, QWORD PTR dev$[rsp]
  00745	48 83 c0 38	 add	 rax, 56			; 00000038H
  00749	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG179040
  00750	48 8b c8	 mov	 rcx, rax
  00753	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_obtain_lock

; 3049 : 
; 3050 :         /* Test for available device */
; 3051 :         if (dev->connected != 0)

  00759	48 8b 44 24 50	 mov	 rax, QWORD PTR dev$[rsp]
  0075e	8b 80 f8 05 00
	00		 mov	 eax, DWORD PTR [rax+1528]
  00764	c1 e8 05	 shr	 eax, 5
  00767	83 e0 01	 and	 eax, 1
  0076a	85 c0		 test	 eax, eax
  0076c	74 1e		 je	 SHORT $LN50@connect_cl

; 3052 :         {
; 3053 :             /* Release the device lock */
; 3054 :             release_lock (&dev->lock);

  0076e	48 8b 44 24 50	 mov	 rax, QWORD PTR dev$[rsp]
  00773	48 83 c0 38	 add	 rax, 56			; 00000038H
  00777	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG179042
  0077e	48 8b c8	 mov	 rcx, rax
  00781	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_release_lock

; 3055 :             continue;

  00787	e9 04 fe ff ff	 jmp	 $LN5@connect_cl
$LN50@connect_cl:

; 3056 :         }
; 3057 : 
; 3058 :         /* Check ipaddr mask to see if client allowed on this device */
; 3059 :         if ((client.sin_addr.s_addr & dev->acc_ipmask) != dev->acc_ipaddr)

  0078c	48 8b 44 24 50	 mov	 rax, QWORD PTR dev$[rsp]
  00791	8b 80 a8 06 00
	00		 mov	 eax, DWORD PTR [rax+1704]
  00797	8b 8c 24 2c 01
	00 00		 mov	 ecx, DWORD PTR client$[rsp+4]
  0079e	23 c8		 and	 ecx, eax
  007a0	8b c1		 mov	 eax, ecx
  007a2	48 8b 4c 24 50	 mov	 rcx, QWORD PTR dev$[rsp]
  007a7	3b 81 a4 06 00
	00		 cmp	 eax, DWORD PTR [rcx+1700]
  007ad	74 3f		 je	 SHORT $LN51@connect_cl

; 3060 :         {
; 3061 :             release_lock( &dev->lock );     /* Release device lock   */

  007af	48 8b 44 24 50	 mov	 rax, QWORD PTR dev$[rsp]
  007b4	48 83 c0 38	 add	 rax, 56			; 00000038H
  007b8	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG179044
  007bf	48 8b c8	 mov	 rcx, rax
  007c2	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_release_lock

; 3062 :             if (0xFFFF == tn->devnum )      /* Non-specific devnum?  */

  007c8	48 8b 44 24 58	 mov	 rax, QWORD PTR tn$[rsp]
  007cd	0f b7 80 a8 00
	00 00		 movzx	 eax, WORD PTR [rax+168]
  007d4	3d ff ff 00 00	 cmp	 eax, 65535		; 0000ffffH
  007d9	75 05		 jne	 SHORT $LN52@connect_cl

; 3063 :                 continue;                   /* Then keep looking     */

  007db	e9 b0 fd ff ff	 jmp	 $LN5@connect_cl
$LN52@connect_cl:

; 3064 :             dev = NULL;                     /* Else specific devnum, */

  007e0	48 c7 44 24 50
	00 00 00 00	 mov	 QWORD PTR dev$[rsp], 0

; 3065 :             break;                          /* but it's unavailable  */

  007e9	e9 25 03 00 00	 jmp	 $LN6@connect_cl
$LN51@connect_cl:

; 3066 :         }
; 3067 : 
; 3068 :         /* --- WE FOUND OUR DEVBLK --- */
; 3069 : 
; 3070 :         /* Claim this device for the client */
; 3071 :         tn->dev = dev;      /* tn  -->  dev */

  007ee	48 8b 44 24 58	 mov	 rax, QWORD PTR tn$[rsp]
  007f3	48 8b 4c 24 50	 mov	 rcx, QWORD PTR dev$[rsp]
  007f8	48 89 88 a0 00
	00 00		 mov	 QWORD PTR [rax+160], rcx

; 3072 :         dev->tn = tn;       /* tn  <--  dev */

  007ff	48 8b 44 24 50	 mov	 rax, QWORD PTR dev$[rsp]
  00804	48 8b 4c 24 58	 mov	 rcx, QWORD PTR tn$[rsp]
  00809	48 89 88 b0 06
	00 00		 mov	 QWORD PTR [rax+1712], rcx

; 3073 : 
; 3074 :         STRLCPY( orig_cid, tn->clientid );

  00810	48 8b 44 24 58	 mov	 rax, QWORD PTR tn$[rsp]
  00815	48 83 c0 62	 add	 rax, 98			; 00000062H
  00819	41 b8 20 00 00
	00		 mov	 r8d, 32			; 00000020H
  0081f	48 8b d0	 mov	 rdx, rax
  00822	48 8d 8c 24 38
	01 00 00	 lea	 rcx, QWORD PTR orig_cid$[rsp]
  0082a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_strlcpy

; 3075 :         MSGBUF( tn->clientid, "%1d:%04X", LCSS_DEVNUM );

  00830	48 83 7c 24 50
	00		 cmp	 QWORD PTR dev$[rsp], 0
  00836	74 12		 je	 SHORT $LN80@connect_cl
  00838	48 8b 44 24 50	 mov	 rax, QWORD PTR dev$[rsp]
  0083d	0f b7 40 48	 movzx	 eax, WORD PTR [rax+72]
  00841	89 84 24 88 00
	00 00		 mov	 DWORD PTR tv386[rsp], eax
  00848	eb 0b		 jmp	 SHORT $LN81@connect_cl
$LN80@connect_cl:
  0084a	c7 84 24 88 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv386[rsp], 0
$LN81@connect_cl:
  00855	48 83 7c 24 50
	00		 cmp	 QWORD PTR dev$[rsp], 0
  0085b	74 14		 je	 SHORT $LN82@connect_cl
  0085d	48 8b 44 24 50	 mov	 rax, QWORD PTR dev$[rsp]
  00862	0f b7 40 44	 movzx	 eax, WORD PTR [rax+68]
  00866	d1 f8		 sar	 eax, 1
  00868	89 84 24 8c 00
	00 00		 mov	 DWORD PTR tv392[rsp], eax
  0086f	eb 0b		 jmp	 SHORT $LN83@connect_cl
$LN82@connect_cl:
  00871	c7 84 24 8c 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv392[rsp], 0
$LN83@connect_cl:
  0087c	48 8b 44 24 58	 mov	 rax, QWORD PTR tn$[rsp]
  00881	48 83 c0 62	 add	 rax, 98			; 00000062H
  00885	8b 8c 24 88 00
	00 00		 mov	 ecx, DWORD PTR tv386[rsp]
  0088c	89 4c 24 20	 mov	 DWORD PTR [rsp+32], ecx
  00890	44 8b 8c 24 8c
	00 00 00	 mov	 r9d, DWORD PTR tv392[rsp]
  00898	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG179046
  0089f	ba 20 00 00 00	 mov	 edx, 32			; 00000020H
  008a4	48 8b c8	 mov	 rcx, rax
  008a7	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_snprintf

; 3076 :         // "%s COMM: %s negotiations complete; ttype = '%s'"
; 3077 :         WRMSG( HHC02914, "I", tn->clientid, orig_cid, tn->ttype );

  008ad	48 8b 44 24 58	 mov	 rax, QWORD PTR tn$[rsp]
  008b2	48 83 c0 29	 add	 rax, 41			; 00000029H
  008b6	48 89 84 24 00
	01 00 00	 mov	 QWORD PTR tv346[rsp], rax
  008be	48 8b 4c 24 58	 mov	 rcx, QWORD PTR tn$[rsp]
  008c3	48 83 c1 62	 add	 rcx, 98			; 00000062H
  008c7	48 89 8c 24 08
	01 00 00	 mov	 QWORD PTR tv400[rsp], rcx
  008cf	b9 01 00 00 00	 mov	 ecx, 1
  008d4	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  008da	48 8b 8c 24 00
	01 00 00	 mov	 rcx, QWORD PTR tv346[rsp]
  008e2	48 89 4c 24 48	 mov	 QWORD PTR [rsp+72], rcx
  008e7	48 8d 8c 24 38
	01 00 00	 lea	 rcx, QWORD PTR orig_cid$[rsp]
  008ef	48 89 4c 24 40	 mov	 QWORD PTR [rsp+64], rcx
  008f4	48 8b 8c 24 08
	01 00 00	 mov	 rcx, QWORD PTR tv400[rsp]
  008fc	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  00901	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG179047
  00908	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  0090d	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG179048
  00914	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00919	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  0091e	41 b9 03 00 00
	00		 mov	 r9d, 3
  00924	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG179049
  0092b	ba 05 0c 00 00	 mov	 edx, 3077		; 00000c05H
  00930	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG179050
  00937	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 3078 : 
; 3079 :         dev->connected = 1;

  0093d	48 8b 44 24 50	 mov	 rax, QWORD PTR dev$[rsp]
  00942	8b 80 f8 05 00
	00		 mov	 eax, DWORD PTR [rax+1528]
  00948	83 c8 20	 or	 eax, 32			; 00000020H
  0094b	48 8b 4c 24 50	 mov	 rcx, QWORD PTR dev$[rsp]
  00950	89 81 f8 05 00
	00		 mov	 DWORD PTR [rcx+1528], eax

; 3080 :         dev->fd        = csock;

  00956	48 8b 44 24 50	 mov	 rax, QWORD PTR dev$[rsp]
  0095b	8b 4c 24 64	 mov	 ecx, DWORD PTR csock$[rsp]
  0095f	89 88 ac 01 00
	00		 mov	 DWORD PTR [rax+428], ecx

; 3081 :         dev->ipaddr    = client.sin_addr;

  00965	48 8b 44 24 50	 mov	 rax, QWORD PTR dev$[rsp]
  0096a	8b 8c 24 2c 01
	00 00		 mov	 ecx, DWORD PTR client$[rsp+4]
  00971	89 88 a0 06 00
	00		 mov	 DWORD PTR [rax+1696], ecx

; 3082 :         dev->mod3270   = tn->model;

  00977	48 8b 44 24 50	 mov	 rax, QWORD PTR dev$[rsp]
  0097c	48 8b 4c 24 58	 mov	 rcx, QWORD PTR tn$[rsp]
  00981	0f b6 89 ab 00
	00 00		 movzx	 ecx, BYTE PTR [rcx+171]
  00988	88 88 d9 06 00
	00		 mov	 BYTE PTR [rax+1753], cl

; 3083 :         dev->eab3270   = tn->extatr ? 1 : 0;

  0098e	48 8b 44 24 58	 mov	 rax, QWORD PTR tn$[rsp]
  00993	0f b6 80 b1 00
	00 00		 movzx	 eax, BYTE PTR [rax+177]
  0099a	85 c0		 test	 eax, eax
  0099c	74 0d		 je	 SHORT $LN84@connect_cl
  0099e	c7 84 24 90 00
	00 00 01 00 00
	00		 mov	 DWORD PTR tv422[rsp], 1
  009a9	eb 0b		 jmp	 SHORT $LN85@connect_cl
$LN84@connect_cl:
  009ab	c7 84 24 90 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv422[rsp], 0
$LN85@connect_cl:
  009b6	8b 84 24 90 00
	00 00		 mov	 eax, DWORD PTR tv422[rsp]
  009bd	83 e0 01	 and	 eax, 1
  009c0	48 8b 4c 24 50	 mov	 rcx, QWORD PTR dev$[rsp]
  009c5	8b 89 d4 06 00
	00		 mov	 ecx, DWORD PTR [rcx+1748]
  009cb	83 e1 fe	 and	 ecx, -2			; fffffffeH
  009ce	0b c8		 or	 ecx, eax
  009d0	8b c1		 mov	 eax, ecx
  009d2	48 8b 4c 24 50	 mov	 rcx, QWORD PTR dev$[rsp]
  009d7	89 81 d4 06 00
	00		 mov	 DWORD PTR [rcx+1748], eax

; 3084 : 
; 3085 :         /* Reset the console device */
; 3086 :         dev->readpending = 0;

  009dd	48 8b 44 24 50	 mov	 rax, QWORD PTR dev$[rsp]
  009e2	8b 80 f8 05 00
	00		 mov	 eax, DWORD PTR [rax+1528]
  009e8	25 3f ff ff ff	 and	 eax, -193		; ffffff3fH
  009ed	48 8b 4c 24 50	 mov	 rcx, QWORD PTR dev$[rsp]
  009f2	89 81 f8 05 00
	00		 mov	 DWORD PTR [rcx+1528], eax

; 3087 :         dev->rlen3270    = 0;

  009f8	48 8b 44 24 50	 mov	 rax, QWORD PTR dev$[rsp]
  009fd	c7 80 b8 06 00
	00 00 00 00 00	 mov	 DWORD PTR [rax+1720], 0

; 3088 :         dev->keybdrem    = 0;

  00a07	48 8b 44 24 50	 mov	 rax, QWORD PTR dev$[rsp]
  00a0c	c7 80 c0 06 00
	00 00 00 00 00	 mov	 DWORD PTR [rax+1728], 0

; 3089 :         dev->tn->got_eor = FALSE;

  00a16	48 8b 44 24 50	 mov	 rax, QWORD PTR dev$[rsp]
  00a1b	48 8b 80 b0 06
	00 00		 mov	 rax, QWORD PTR [rax+1712]
  00a22	c6 80 af 00 00
	00 00		 mov	 BYTE PTR [rax+175], 0

; 3090 : 
; 3091 :         memset( &dev->scsw,    0, sizeof(SCSW) );

  00a29	48 8b 44 24 50	 mov	 rax, QWORD PTR dev$[rsp]
  00a2e	48 05 08 03 00
	00		 add	 rax, 776		; 00000308H
  00a34	48 8b f8	 mov	 rdi, rax
  00a37	33 c0		 xor	 eax, eax
  00a39	b9 0c 00 00 00	 mov	 ecx, 12
  00a3e	f3 aa		 rep stosb

; 3092 :         memset( &dev->pciscsw, 0, sizeof(SCSW) );

  00a40	48 8b 44 24 50	 mov	 rax, QWORD PTR dev$[rsp]
  00a45	48 05 14 03 00
	00		 add	 rax, 788		; 00000314H
  00a4b	48 8b f8	 mov	 rdi, rax
  00a4e	33 c0		 xor	 eax, eax
  00a50	b9 0c 00 00 00	 mov	 ecx, 12
  00a55	f3 aa		 rep stosb

; 3093 : 
; 3094 :         dev->busy = dev->reserved = dev->suspended =

  00a57	48 8b 44 24 50	 mov	 rax, QWORD PTR dev$[rsp]
  00a5c	8b 80 f8 05 00
	00		 mov	 eax, DWORD PTR [rax+1528]
  00a62	0f ba f0 18	 btr	 eax, 24
  00a66	48 8b 4c 24 50	 mov	 rcx, QWORD PTR dev$[rsp]
  00a6b	89 81 f8 05 00
	00		 mov	 DWORD PTR [rcx+1528], eax
  00a71	48 8b 44 24 50	 mov	 rax, QWORD PTR dev$[rsp]
  00a76	8b 80 f8 05 00
	00		 mov	 eax, DWORD PTR [rax+1528]
  00a7c	0f ba f0 17	 btr	 eax, 23
  00a80	48 8b 4c 24 50	 mov	 rcx, QWORD PTR dev$[rsp]
  00a85	89 81 f8 05 00
	00		 mov	 DWORD PTR [rcx+1528], eax
  00a8b	48 8b 44 24 50	 mov	 rax, QWORD PTR dev$[rsp]
  00a90	8b 80 f8 05 00
	00		 mov	 eax, DWORD PTR [rax+1528]
  00a96	0f ba f0 16	 btr	 eax, 22
  00a9a	48 8b 4c 24 50	 mov	 rcx, QWORD PTR dev$[rsp]
  00a9f	89 81 f8 05 00
	00		 mov	 DWORD PTR [rcx+1528], eax
  00aa5	48 8b 44 24 50	 mov	 rax, QWORD PTR dev$[rsp]
  00aaa	8b 80 f8 05 00
	00		 mov	 eax, DWORD PTR [rax+1528]
  00ab0	0f ba f0 15	 btr	 eax, 21
  00ab4	48 8b 4c 24 50	 mov	 rcx, QWORD PTR dev$[rsp]
  00ab9	89 81 f8 05 00
	00		 mov	 DWORD PTR [rcx+1528], eax
  00abf	48 8b 44 24 50	 mov	 rax, QWORD PTR dev$[rsp]
  00ac4	8b 80 f8 05 00
	00		 mov	 eax, DWORD PTR [rax+1528]
  00aca	0f ba f0 14	 btr	 eax, 20
  00ace	48 8b 4c 24 50	 mov	 rcx, QWORD PTR dev$[rsp]
  00ad3	89 81 f8 05 00
	00		 mov	 DWORD PTR [rcx+1528], eax
  00ad9	48 8b 44 24 50	 mov	 rax, QWORD PTR dev$[rsp]
  00ade	8b 80 f8 05 00
	00		 mov	 eax, DWORD PTR [rax+1528]
  00ae4	0f ba f0 13	 btr	 eax, 19
  00ae8	48 8b 4c 24 50	 mov	 rcx, QWORD PTR dev$[rsp]
  00aed	89 81 f8 05 00
	00		 mov	 DWORD PTR [rcx+1528], eax

; 3095 :         dev->pending = dev->pcipending = dev->attnpending = 0;
; 3096 : 
; 3097 :         release_lock( &dev->lock );

  00af3	48 8b 44 24 50	 mov	 rax, QWORD PTR dev$[rsp]
  00af8	48 83 c0 38	 add	 rax, 56			; 00000038H
  00afc	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG179051
  00b03	48 8b c8	 mov	 rcx, rax
  00b06	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_release_lock

; 3098 :         break;

  00b0c	eb 05		 jmp	 SHORT $LN6@connect_cl

; 3099 : 
; 3100 :     } /* end for(dev) */

  00b0e	e9 7d fa ff ff	 jmp	 $LN5@connect_cl
$LN6@connect_cl:

; 3101 : 
; 3102 :     /* Reject the connection if no available console device */
; 3103 :     if (dev == NULL)

  00b13	48 83 7c 24 50
	00		 cmp	 QWORD PTR dev$[rsp], 0
  00b19	0f 85 94 03 00
	00		 jne	 $LN53@connect_cl

; 3104 :     {
; 3105 :         /* Build rejection message to log to HMC */
; 3106 :         if (tn->devnum == 0xFFFF)

  00b1f	48 8b 44 24 58	 mov	 rax, QWORD PTR tn$[rsp]
  00b24	0f b7 80 a8 00
	00 00		 movzx	 eax, WORD PTR [rax+168]
  00b2b	3d ff ff 00 00	 cmp	 eax, 65535		; 0000ffffH
  00b30	0f 85 52 01 00
	00		 jne	 $LN54@connect_cl

; 3107 :         {
; 3108 :             if (!tn->tgroup[0])

  00b36	b8 01 00 00 00	 mov	 eax, 1
  00b3b	48 6b c0 00	 imul	 rax, rax, 0
  00b3f	48 8b 4c 24 58	 mov	 rcx, QWORD PTR tn$[rsp]
  00b44	0f be 44 01 52	 movsx	 eax, BYTE PTR [rcx+rax+82]
  00b49	85 c0		 test	 eax, eax
  00b4b	0f 85 96 00 00
	00		 jne	 $LN56@connect_cl

; 3109 :             {
; 3110 :                 // "Connection rejected, no available %s device"
; 3111 :                 // (Note: "MSG_C" used so message does NOT end with newline)
; 3112 :                 MSGBUF( rejmsg, MSG_C( HHC01028, "E",

  00b51	48 8b 44 24 58	 mov	 rax, QWORD PTR tn$[rsp]
  00b56	0f b6 80 aa 00
	00 00		 movzx	 eax, BYTE PTR [rax+170]
  00b5d	83 f8 44	 cmp	 eax, 68			; 00000044H
  00b60	75 11		 jne	 SHORT $LN88@connect_cl
  00b62	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG179057
  00b69	48 89 84 24 b0
	00 00 00	 mov	 QWORD PTR tv482[rsp], rax
  00b71	eb 41		 jmp	 SHORT $LN89@connect_cl
$LN88@connect_cl:
  00b73	48 8b 44 24 58	 mov	 rax, QWORD PTR tn$[rsp]
  00b78	0f b6 80 aa 00
	00 00		 movzx	 eax, BYTE PTR [rax+170]
  00b7f	83 f8 50	 cmp	 eax, 80			; 00000050H
  00b82	75 11		 jne	 SHORT $LN86@connect_cl
  00b84	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG179058
  00b8b	48 89 84 24 a8
	00 00 00	 mov	 QWORD PTR tv481[rsp], rax
  00b93	eb 0f		 jmp	 SHORT $LN87@connect_cl
$LN86@connect_cl:
  00b95	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG179059
  00b9c	48 89 84 24 a8
	00 00 00	 mov	 QWORD PTR tv481[rsp], rax
$LN87@connect_cl:
  00ba4	48 8b 84 24 a8
	00 00 00	 mov	 rax, QWORD PTR tv481[rsp]
  00bac	48 89 84 24 b0
	00 00 00	 mov	 QWORD PTR tv482[rsp], rax
$LN89@connect_cl:
  00bb4	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR tv482[rsp]
  00bbc	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00bc1	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG179060
  00bc8	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG179061
  00bcf	ba 00 01 00 00	 mov	 edx, 256		; 00000100H
  00bd4	48 8d 8c 24 60
	01 00 00	 lea	 rcx, QWORD PTR rejmsg$[rsp]
  00bdc	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_snprintf

; 3113 :                     (tn->devclass == 'D' ? "3270" :
; 3114 :                     (tn->devclass == 'P' ? "3287" : "1052 or 3215"))));
; 3115 :             }

  00be2	e9 9f 00 00 00	 jmp	 $LN57@connect_cl
$LN56@connect_cl:

; 3116 :             else
; 3117 :             {
; 3118 :                 // "Connection rejected, no available %s device in the %s group"
; 3119 :                 // (Note: "MSG_C" used so message does NOT end with newline)
; 3120 :                 MSGBUF( rejmsg, MSG_C( HHC01029, "E",

  00be7	48 8b 44 24 58	 mov	 rax, QWORD PTR tn$[rsp]
  00bec	0f b6 80 aa 00
	00 00		 movzx	 eax, BYTE PTR [rax+170]
  00bf3	83 f8 44	 cmp	 eax, 68			; 00000044H
  00bf6	75 11		 jne	 SHORT $LN92@connect_cl
  00bf8	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG179062
  00bff	48 89 84 24 c0
	00 00 00	 mov	 QWORD PTR tv497[rsp], rax
  00c07	eb 41		 jmp	 SHORT $LN93@connect_cl
$LN92@connect_cl:
  00c09	48 8b 44 24 58	 mov	 rax, QWORD PTR tn$[rsp]
  00c0e	0f b6 80 aa 00
	00 00		 movzx	 eax, BYTE PTR [rax+170]
  00c15	83 f8 50	 cmp	 eax, 80			; 00000050H
  00c18	75 11		 jne	 SHORT $LN90@connect_cl
  00c1a	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG179063
  00c21	48 89 84 24 b8
	00 00 00	 mov	 QWORD PTR tv496[rsp], rax
  00c29	eb 0f		 jmp	 SHORT $LN91@connect_cl
$LN90@connect_cl:
  00c2b	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG179064
  00c32	48 89 84 24 b8
	00 00 00	 mov	 QWORD PTR tv496[rsp], rax
$LN91@connect_cl:
  00c3a	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR tv496[rsp]
  00c42	48 89 84 24 c0
	00 00 00	 mov	 QWORD PTR tv497[rsp], rax
$LN93@connect_cl:
  00c4a	48 8b 44 24 58	 mov	 rax, QWORD PTR tn$[rsp]
  00c4f	48 83 c0 52	 add	 rax, 82			; 00000052H
  00c53	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  00c58	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR tv497[rsp]
  00c60	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00c65	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG179065
  00c6c	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG179066
  00c73	ba 00 01 00 00	 mov	 edx, 256		; 00000100H
  00c78	48 8d 8c 24 60
	01 00 00	 lea	 rcx, QWORD PTR rejmsg$[rsp]
  00c80	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_snprintf
$LN57@connect_cl:

; 3121 :                     (tn->devclass == 'D' ? "3270" :
; 3122 :                     (tn->devclass == 'P' ? "3287" : "1052 or 3215")), tn->tgroup));
; 3123 :             }
; 3124 :         }

  00c86	eb 31		 jmp	 SHORT $LN55@connect_cl
$LN54@connect_cl:

; 3125 :         else
; 3126 :         {
; 3127 :             // "Connection rejected, device %04X unavailable"
; 3128 :             // (Note: "MSG_C" used so message does NOT end with newline)
; 3129 :             MSGBUF( rejmsg, MSG_C( HHC01030, "I", tn->devnum ));

  00c88	48 8b 44 24 58	 mov	 rax, QWORD PTR tn$[rsp]
  00c8d	0f b7 80 a8 00
	00 00		 movzx	 eax, WORD PTR [rax+168]
  00c94	89 44 24 20	 mov	 DWORD PTR [rsp+32], eax
  00c98	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG179067
  00c9f	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG179068
  00ca6	ba 00 01 00 00	 mov	 edx, 256		; 00000100H
  00cab	48 8d 8c 24 60
	01 00 00	 lea	 rcx, QWORD PTR rejmsg$[rsp]
  00cb3	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_snprintf
$LN55@connect_cl:

; 3130 :         }
; 3131 : 
; 3132 :         /* Log rejection message to HMC */
; 3133 :         LOGMSG( "%s\n", rejmsg );

  00cb9	b9 01 00 00 00	 mov	 ecx, 1
  00cbe	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  00cc4	48 8d 8c 24 60
	01 00 00	 lea	 rcx, QWORD PTR rejmsg$[rsp]
  00ccc	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  00cd1	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG179069
  00cd8	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00cdd	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00ce2	41 b9 03 00 00
	00		 mov	 r9d, 3
  00ce8	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG179070
  00cef	ba 3d 0c 00 00	 mov	 edx, 3133		; 00000c3dH
  00cf4	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG179071
  00cfb	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 3134 : 
; 3135 :         /* Build rejection message to send back to client */
; 3136 :         if (tn->devclass == 'D')

  00d01	48 8b 44 24 58	 mov	 rax, QWORD PTR tn$[rsp]
  00d06	0f b6 80 aa 00
	00 00		 movzx	 eax, BYTE PTR [rax+170]
  00d0d	83 f8 44	 cmp	 eax, 68			; 00000044H
  00d10	0f 85 c5 00 00
	00		 jne	 $LN58@connect_cl

; 3137 :         {
; 3138 :             len = MSGBUF

  00d16	48 8d 8c 24 60
	01 00 00	 lea	 rcx, QWORD PTR rejmsg$[rsp]
  00d1e	e8 00 00 00 00	 call	 strlen
  00d23	44 8b c0	 mov	 r8d, eax
  00d26	48 8d 94 24 60
	01 00 00	 lea	 rdx, QWORD PTR rejmsg$[rsp]
  00d2e	48 8d 8c 24 60
	01 00 00	 lea	 rcx, QWORD PTR rejmsg$[rsp]
  00d36	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_prt_host_to_guest
  00d3c	48 89 84 24 10
	01 00 00	 mov	 QWORD PTR tv522[rsp], rax
  00d44	48 8d 8c 24 60
	02 00 00	 lea	 rcx, QWORD PTR hostmsg$[rsp]
  00d4c	e8 00 00 00 00	 call	 strlen
  00d51	44 8b c0	 mov	 r8d, eax
  00d54	48 8d 94 24 60
	02 00 00	 lea	 rdx, QWORD PTR hostmsg$[rsp]
  00d5c	48 8d 8c 24 60
	02 00 00	 lea	 rcx, QWORD PTR hostmsg$[rsp]
  00d64	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_prt_host_to_guest
  00d6a	48 89 84 24 18
	01 00 00	 mov	 QWORD PTR tv530[rsp], rax
  00d72	48 8d 8c 24 60
	03 00 00	 lea	 rcx, QWORD PTR hvermsg$[rsp]
  00d7a	e8 00 00 00 00	 call	 strlen
  00d7f	44 8b c0	 mov	 r8d, eax
  00d82	48 8d 94 24 60
	03 00 00	 lea	 rdx, QWORD PTR hvermsg$[rsp]
  00d8a	48 8d 8c 24 60
	03 00 00	 lea	 rcx, QWORD PTR hvermsg$[rsp]
  00d92	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_prt_host_to_guest
  00d98	48 8b 8c 24 10
	01 00 00	 mov	 rcx, QWORD PTR tv522[rsp]
  00da0	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00da5	48 8b 8c 24 18
	01 00 00	 mov	 rcx, QWORD PTR tv530[rsp]
  00dad	48 89 4c 24 20	 mov	 QWORD PTR [rsp+32], rcx
  00db2	4c 8b c8	 mov	 r9, rax
  00db5	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG179074
  00dbc	ba 80 07 00 00	 mov	 edx, 1920		; 00000780H
  00dc1	48 8d 8c 24 60
	06 00 00	 lea	 rcx, QWORD PTR buf$[rsp]
  00dc9	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_snprintf
  00dcf	48 98		 cdqe
  00dd1	48 89 84 24 80
	00 00 00	 mov	 QWORD PTR len$[rsp], rax

; 3139 :             (
; 3140 :                 buf,
; 3141 : 
; 3142 :                 "\xF5\x40"
; 3143 :                 "\x11\x40\x40\x1D\x60%s"        /* First line   */
; 3144 :                 "\x11\xC1\x50\x1D\x60%s"        /* Second line  */
; 3145 :                 "\x11\xC2\x60\x1D\x60%s",       /* Third line   */
; 3146 : 
; 3147 :                 prt_host_to_guest( (BYTE*) hvermsg, (BYTE*) hvermsg, strlen( hvermsg )),
; 3148 :                 prt_host_to_guest( (BYTE*) hostmsg, (BYTE*) hostmsg, strlen( hostmsg )),
; 3149 :                 prt_host_to_guest( (BYTE*) rejmsg,  (BYTE*) rejmsg,  strlen( rejmsg  ))
; 3150 :             );
; 3151 :         }

  00dd9	eb 57		 jmp	 SHORT $LN59@connect_cl
$LN58@connect_cl:

; 3152 :         else if (tn->devclass == 'K')

  00ddb	48 8b 44 24 58	 mov	 rax, QWORD PTR tn$[rsp]
  00de0	0f b6 80 aa 00
	00 00		 movzx	 eax, BYTE PTR [rax+170]
  00de7	83 f8 4b	 cmp	 eax, 75			; 0000004bH
  00dea	75 46		 jne	 SHORT $LN60@connect_cl

; 3153 :         {
; 3154 :             len = MSGBUF

  00dec	48 8d 84 24 60
	01 00 00	 lea	 rax, QWORD PTR rejmsg$[rsp]
  00df4	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  00df9	48 8d 84 24 60
	02 00 00	 lea	 rax, QWORD PTR hostmsg$[rsp]
  00e01	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00e06	4c 8d 8c 24 60
	03 00 00	 lea	 r9, QWORD PTR hvermsg$[rsp]
  00e0e	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG179076
  00e15	ba 80 07 00 00	 mov	 edx, 1920		; 00000780H
  00e1a	48 8d 8c 24 60
	06 00 00	 lea	 rcx, QWORD PTR buf$[rsp]
  00e22	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_snprintf
  00e28	48 98		 cdqe
  00e2a	48 89 84 24 80
	00 00 00	 mov	 QWORD PTR len$[rsp], rax
$LN60@connect_cl:
$LN59@connect_cl:

; 3155 :             (
; 3156 :                 buf,
; 3157 : 
; 3158 :                 "%s\n"          /* First line   */
; 3159 :                 "%s\n"          /* Second line  */
; 3160 :                 "%s\n",         /* Third line   */
; 3161 : 
; 3162 :                 hvermsg,
; 3163 :                 hostmsg,
; 3164 :                 rejmsg
; 3165 :             );
; 3166 :         }
; 3167 : 
; 3168 :         /* Send the connection rejection message back to the client */
; 3169 :         if (tn->devclass != 'P')

  00e32	48 8b 44 24 58	 mov	 rax, QWORD PTR tn$[rsp]
  00e37	0f b6 80 aa 00
	00 00		 movzx	 eax, BYTE PTR [rax+170]
  00e3e	83 f8 50	 cmp	 eax, 80			; 00000050H
  00e41	74 1a		 je	 SHORT $LN61@connect_cl

; 3170 :             sendto_client( tn, (BYTE*) buf, len );

  00e43	44 8b 84 24 80
	00 00 00	 mov	 r8d, DWORD PTR len$[rsp]
  00e4b	48 8d 94 24 60
	06 00 00	 lea	 rdx, QWORD PTR buf$[rsp]
  00e53	48 8b 4c 24 58	 mov	 rcx, QWORD PTR tn$[rsp]
  00e58	e8 00 00 00 00	 call	 sendto_client
$LN61@connect_cl:
$LN10@connect_cl:

; 3171 : 
; 3172 :         /* Give them time to read the message before disconnecting */
; 3173 :         SLEEP(10);

  00e5d	c7 44 24 6c 0a
	00 00 00	 mov	 DWORD PTR rc$2[rsp], 10
$LN11@connect_cl:
  00e65	83 7c 24 6c 00	 cmp	 DWORD PTR rc$2[rsp], 0
  00e6a	74 1d		 je	 SHORT $LN12@connect_cl
  00e6c	8b 4c 24 6c	 mov	 ecx, DWORD PTR rc$2[rsp]
  00e70	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_sleep
  00e76	89 44 24 6c	 mov	 DWORD PTR rc$2[rsp], eax
  00e7a	83 7c 24 6c 00	 cmp	 DWORD PTR rc$2[rsp], 0
  00e7f	74 06		 je	 SHORT $LN62@connect_cl
  00e81	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_sched_yield
$LN62@connect_cl:
  00e87	eb dc		 jmp	 SHORT $LN11@connect_cl
$LN12@connect_cl:
  00e89	33 c0		 xor	 eax, eax
  00e8b	85 c0		 test	 eax, eax
  00e8d	75 ce		 jne	 SHORT $LN10@connect_cl

; 3174 : 
; 3175 :         /* Close the connection and terminate the thread */
; 3176 :         disconnect_telnet_client( tn );

  00e8f	48 8b 4c 24 58	 mov	 rcx, QWORD PTR tn$[rsp]
  00e94	e8 00 00 00 00	 call	 disconnect_telnet_client

; 3177 :         if (clientip)

  00e99	48 83 7c 24 70
	00		 cmp	 QWORD PTR clientip$[rsp], 0
  00e9f	74 0b		 je	 SHORT $LN63@connect_cl

; 3178 :             free( clientip );

  00ea1	48 8b 4c 24 70	 mov	 rcx, QWORD PTR clientip$[rsp]
  00ea6	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free
$LN63@connect_cl:

; 3179 :         return NULL;

  00eac	33 c0		 xor	 eax, eax
  00eae	e9 00 05 00 00	 jmp	 $LN1@connect_cl
$LN53@connect_cl:

; 3180 :     }
; 3181 : 
; 3182 :     // "%1d:%04X COMM: client %s devtype %4.4X: connected"
; 3183 :     // (Note: "MSG_C" used so message does NOT end with newline)
; 3184 :     MSGBUF( devmsg, MSG_C( HHC01018, "I",

  00eb3	48 83 7c 24 50
	00		 cmp	 QWORD PTR dev$[rsp], 0
  00eb9	74 12		 je	 SHORT $LN94@connect_cl
  00ebb	48 8b 44 24 50	 mov	 rax, QWORD PTR dev$[rsp]
  00ec0	0f b7 40 48	 movzx	 eax, WORD PTR [rax+72]
  00ec4	89 84 24 94 00
	00 00		 mov	 DWORD PTR tv583[rsp], eax
  00ecb	eb 0b		 jmp	 SHORT $LN95@connect_cl
$LN94@connect_cl:
  00ecd	c7 84 24 94 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv583[rsp], 0
$LN95@connect_cl:
  00ed8	48 83 7c 24 50
	00		 cmp	 QWORD PTR dev$[rsp], 0
  00ede	74 14		 je	 SHORT $LN96@connect_cl
  00ee0	48 8b 44 24 50	 mov	 rax, QWORD PTR dev$[rsp]
  00ee5	0f b7 40 44	 movzx	 eax, WORD PTR [rax+68]
  00ee9	d1 f8		 sar	 eax, 1
  00eeb	89 84 24 98 00
	00 00		 mov	 DWORD PTR tv589[rsp], eax
  00ef2	eb 0b		 jmp	 SHORT $LN97@connect_cl
$LN96@connect_cl:
  00ef4	c7 84 24 98 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv589[rsp], 0
$LN97@connect_cl:
  00eff	48 8b 44 24 50	 mov	 rax, QWORD PTR dev$[rsp]
  00f04	0f b7 40 4a	 movzx	 eax, WORD PTR [rax+74]
  00f08	89 44 24 38	 mov	 DWORD PTR [rsp+56], eax
  00f0c	48 8b 44 24 70	 mov	 rax, QWORD PTR clientip$[rsp]
  00f11	48 89 44 24 30	 mov	 QWORD PTR [rsp+48], rax
  00f16	8b 84 24 94 00
	00 00		 mov	 eax, DWORD PTR tv583[rsp]
  00f1d	89 44 24 28	 mov	 DWORD PTR [rsp+40], eax
  00f21	8b 84 24 98 00
	00 00		 mov	 eax, DWORD PTR tv589[rsp]
  00f28	89 44 24 20	 mov	 DWORD PTR [rsp+32], eax
  00f2c	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG179080
  00f33	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG179081
  00f3a	ba 00 01 00 00	 mov	 edx, 256		; 00000100H
  00f3f	48 8d 8c 24 60
	05 00 00	 lea	 rcx, QWORD PTR devmsg$[rsp]
  00f47	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_snprintf

; 3185 :               LCSS_DEVNUM, clientip, dev->devtype ));
; 3186 :     LOGMSG( "%s\n", devmsg );

  00f4d	b9 01 00 00 00	 mov	 ecx, 1
  00f52	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  00f58	48 8d 8c 24 60
	05 00 00	 lea	 rcx, QWORD PTR devmsg$[rsp]
  00f60	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  00f65	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG179082
  00f6c	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00f71	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00f76	41 b9 03 00 00
	00		 mov	 r9d, 3
  00f7c	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG179083
  00f83	ba 72 0c 00 00	 mov	 edx, 3186		; 00000c72H
  00f88	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG179084
  00f8f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 3187 : 
; 3188 :     /* Negotiations are complete; we can begin accepting data now */
; 3189 :     tn->neg_done = TRUE;

  00f95	48 8b 44 24 58	 mov	 rax, QWORD PTR tn$[rsp]
  00f9a	c6 80 b2 00 00
	00 01		 mov	 BYTE PTR [rax+178], 1

; 3190 : 
; 3191 :     /* Initialize size of send buffer for one shot send operations */
; 3192 :     tn->sendbuf_size = 0;

  00fa1	48 8b 44 24 58	 mov	 rax, QWORD PTR tn$[rsp]
  00fa6	c7 80 8c 00 00
	00 00 00 00 00	 mov	 DWORD PTR [rax+140], 0

; 3193 : 
; 3194 :     /* Try to detect dropped connections */
; 3195 :     set_socket_keepalive( csock, sysblk.kaidle, sysblk.kaintv, sysblk.kacnt );

  00fb0	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00fb7	44 8b 88 b8 10
	00 00		 mov	 r9d, DWORD PTR [rax+4280]
  00fbe	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00fc5	44 8b 80 b4 10
	00 00		 mov	 r8d, DWORD PTR [rax+4276]
  00fcc	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00fd3	8b 90 b0 10 00
	00		 mov	 edx, DWORD PTR [rax+4272]
  00fd9	8b 4c 24 64	 mov	 ecx, DWORD PTR csock$[rsp]
  00fdd	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_set_socket_keepalive

; 3196 : 
; 3197 :     /* Construct Hercules logo or connected message */
; 3198 : 
; 3199 :     logobfr = NULL;

  00fe3	48 c7 44 24 78
	00 00 00 00	 mov	 QWORD PTR logobfr$[rsp], 0

; 3200 : 
; 3201 :     if (tn->devclass == 'D')

  00fec	48 8b 44 24 58	 mov	 rax, QWORD PTR tn$[rsp]
  00ff1	0f b6 80 aa 00
	00 00		 movzx	 eax, BYTE PTR [rax+170]
  00ff8	83 f8 44	 cmp	 eax, 68			; 00000044H
  00ffb	0f 85 ab 01 00
	00		 jne	 $LN64@connect_cl

; 3202 :     {
; 3203 :         /* Construct display terminal logo */
; 3204 : 
; 3205 : #if defined( _FEATURE_INTEGRATED_3270_CONSOLE )
; 3206 :         if  (dev == sysblk.sysgdev)

  01001	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  01008	48 8b 80 c8 11
	00 00		 mov	 rax, QWORD PTR [rax+4552]
  0100f	48 39 44 24 50	 cmp	 QWORD PTR dev$[rsp], rax
  01014	75 1d		 jne	 SHORT $LN66@connect_cl

; 3207 :             STRLCPY( buf, "SYSG" );

  01016	41 b8 80 07 00
	00		 mov	 r8d, 1920		; 00000780H
  0101c	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG179089
  01023	48 8d 8c 24 60
	06 00 00	 lea	 rcx, QWORD PTR buf$[rsp]
  0102b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_strlcpy
  01031	eb 26		 jmp	 SHORT $LN67@connect_cl
$LN66@connect_cl:

; 3208 :         else
; 3209 : #endif
; 3210 :         MSGBUF( buf, "%4.4X", dev->devnum );           set_symbol( "DEVN",    buf );

  01033	48 8b 44 24 50	 mov	 rax, QWORD PTR dev$[rsp]
  01038	0f b7 40 48	 movzx	 eax, WORD PTR [rax+72]
  0103c	44 8b c8	 mov	 r9d, eax
  0103f	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG179090
  01046	ba 80 07 00 00	 mov	 edx, 1920		; 00000780H
  0104b	48 8d 8c 24 60
	06 00 00	 lea	 rcx, QWORD PTR buf$[rsp]
  01053	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_snprintf
$LN67@connect_cl:
  01059	48 8d 94 24 60
	06 00 00	 lea	 rdx, QWORD PTR buf$[rsp]
  01061	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG179091
  01068	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_set_symbol

; 3211 :                                                        set_symbol( "CCUU",    buf );

  0106e	48 8d 94 24 60
	06 00 00	 lea	 rdx, QWORD PTR buf$[rsp]
  01076	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG179092
  0107d	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_set_symbol

; 3212 :         MSGBUF( buf, "%3.3X", dev->devnum );           set_symbol( "CUU",     buf );

  01083	48 8b 44 24 50	 mov	 rax, QWORD PTR dev$[rsp]
  01088	0f b7 40 48	 movzx	 eax, WORD PTR [rax+72]
  0108c	44 8b c8	 mov	 r9d, eax
  0108f	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG179093
  01096	ba 80 07 00 00	 mov	 edx, 1920		; 00000780H
  0109b	48 8d 8c 24 60
	06 00 00	 lea	 rcx, QWORD PTR buf$[rsp]
  010a3	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_snprintf
  010a9	48 8d 94 24 60
	06 00 00	 lea	 rdx, QWORD PTR buf$[rsp]
  010b1	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG179094
  010b8	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_set_symbol

; 3213 :         MSGBUF( buf, "%4.4X", dev->subchan );          set_symbol( "SUBCHAN", buf );

  010be	48 8b 44 24 50	 mov	 rax, QWORD PTR dev$[rsp]
  010c3	0f b7 40 46	 movzx	 eax, WORD PTR [rax+70]
  010c7	44 8b c8	 mov	 r9d, eax
  010ca	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG179095
  010d1	ba 80 07 00 00	 mov	 edx, 1920		; 00000780H
  010d6	48 8d 8c 24 60
	06 00 00	 lea	 rcx, QWORD PTR buf$[rsp]
  010de	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_snprintf
  010e4	48 8d 94 24 60
	06 00 00	 lea	 rdx, QWORD PTR buf$[rsp]
  010ec	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG179096
  010f3	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_set_symbol

; 3214 :         MSGBUF( buf, "%d", SSID_TO_LCSS( dev->ssid )); set_symbol( "CSS",     buf );

  010f9	48 8b 44 24 50	 mov	 rax, QWORD PTR dev$[rsp]
  010fe	0f b7 40 44	 movzx	 eax, WORD PTR [rax+68]
  01102	d1 f8		 sar	 eax, 1
  01104	44 8b c8	 mov	 r9d, eax
  01107	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG179097
  0110e	ba 80 07 00 00	 mov	 edx, 1920		; 00000780H
  01113	48 8d 8c 24 60
	06 00 00	 lea	 rcx, QWORD PTR buf$[rsp]
  0111b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_snprintf
  01121	48 8d 94 24 60
	06 00 00	 lea	 rdx, QWORD PTR buf$[rsp]
  01129	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG179098
  01130	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_set_symbol

; 3215 : 
; 3216 :         if (sysblk.herclogo != NULL)

  01136	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  0113d	48 83 b8 f8 13
	00 00 00	 cmp	 QWORD PTR [rax+5112], 0
  01145	74 33		 je	 SHORT $LN68@connect_cl

; 3217 :         {
; 3218 :             logobfr = build_logo( sysblk.herclogo, sysblk.logolines, &len, NULL );

  01147	45 33 c9	 xor	 r9d, r9d
  0114a	4c 8d 84 24 80
	00 00 00	 lea	 r8, QWORD PTR len$[rsp]
  01152	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  01159	48 8b 90 08 14
	00 00		 mov	 rdx, QWORD PTR [rax+5128]
  01160	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  01167	48 8b 88 f8 13
	00 00		 mov	 rcx, QWORD PTR [rax+5112]
  0116e	e8 00 00 00 00	 call	 build_logo
  01173	48 89 44 24 78	 mov	 QWORD PTR logobfr$[rsp], rax

; 3219 :         }

  01178	eb 30		 jmp	 SHORT $LN69@connect_cl
$LN68@connect_cl:

; 3220 :         else // (use hard coded built-in default logo)
; 3221 :         {
; 3222 :             logoheight = sizeof( herclogo ) / sizeof( char* );

  0117a	48 c7 84 24 20
	01 00 00 3b 00
	00 00		 mov	 QWORD PTR logoheight$[rsp], 59 ; 0000003bH

; 3223 :             logobfr    = build_logo( herclogo, logoheight, &len, NULL );

  01186	45 33 c9	 xor	 r9d, r9d
  01189	4c 8d 84 24 80
	00 00 00	 lea	 r8, QWORD PTR len$[rsp]
  01191	48 8b 94 24 20
	01 00 00	 mov	 rdx, QWORD PTR logoheight$[rsp]
  01199	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:herclogo
  011a0	e8 00 00 00 00	 call	 build_logo
  011a5	48 89 44 24 78	 mov	 QWORD PTR logobfr$[rsp], rax
$LN69@connect_cl:

; 3224 :         }
; 3225 :     }

  011aa	eb 64		 jmp	 SHORT $LN65@connect_cl
$LN64@connect_cl:

; 3226 :     else if (tn->devclass == 'K')

  011ac	48 8b 44 24 58	 mov	 rax, QWORD PTR tn$[rsp]
  011b1	0f b6 80 aa 00
	00 00		 movzx	 eax, BYTE PTR [rax+170]
  011b8	83 f8 4b	 cmp	 eax, 75			; 0000004bH
  011bb	75 53		 jne	 SHORT $LN70@connect_cl

; 3227 :     {
; 3228 :         /* Construct keyboard device connected message */
; 3229 : 
; 3230 :         len = MSGBUF

  011bd	48 8d 84 24 60
	05 00 00	 lea	 rax, QWORD PTR devmsg$[rsp]
  011c5	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  011ca	48 8d 84 24 60
	02 00 00	 lea	 rax, QWORD PTR hostmsg$[rsp]
  011d2	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  011d7	4c 8d 8c 24 60
	03 00 00	 lea	 r9, QWORD PTR hvermsg$[rsp]
  011df	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG179102
  011e6	ba 80 07 00 00	 mov	 edx, 1920		; 00000780H
  011eb	48 8d 8c 24 60
	06 00 00	 lea	 rcx, QWORD PTR buf$[rsp]
  011f3	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_snprintf
  011f9	48 98		 cdqe
  011fb	48 89 84 24 80
	00 00 00	 mov	 QWORD PTR len$[rsp], rax

; 3231 :         (
; 3232 :             buf,                /* (just a convenient buffer) */
; 3233 : 
; 3234 :             "%s\n"              /* First line   */
; 3235 :             "%s\n"              /* Second line  */
; 3236 :             "%s\n",             /* Third line   */
; 3237 : 
; 3238 :             hvermsg,
; 3239 :             hostmsg,
; 3240 :             devmsg
; 3241 :         );
; 3242 :         logobfr = (BYTE*) buf;

  01203	48 8d 84 24 60
	06 00 00	 lea	 rax, QWORD PTR buf$[rsp]
  0120b	48 89 44 24 78	 mov	 QWORD PTR logobfr$[rsp], rax
$LN70@connect_cl:
$LN65@connect_cl:

; 3243 :     }
; 3244 : 
; 3245 :     /* Send the Hercules logo or connected message to the client */
; 3246 :     if (tn->devclass != 'P' && logobfr)

  01210	48 8b 44 24 58	 mov	 rax, QWORD PTR tn$[rsp]
  01215	0f b6 80 aa 00
	00 00		 movzx	 eax, BYTE PTR [rax+170]
  0121c	83 f8 50	 cmp	 eax, 80			; 00000050H
  0121f	74 1f		 je	 SHORT $LN71@connect_cl
  01221	48 83 7c 24 78
	00		 cmp	 QWORD PTR logobfr$[rsp], 0
  01227	74 17		 je	 SHORT $LN71@connect_cl

; 3247 :         sendto_client( tn, logobfr, len );

  01229	44 8b 84 24 80
	00 00 00	 mov	 r8d, DWORD PTR len$[rsp]
  01231	48 8b 54 24 78	 mov	 rdx, QWORD PTR logobfr$[rsp]
  01236	48 8b 4c 24 58	 mov	 rcx, QWORD PTR tn$[rsp]
  0123b	e8 00 00 00 00	 call	 sendto_client
$LN71@connect_cl:

; 3248 : 
; 3249 :     if (logobfr && logobfr != (BYTE*) buf)

  01240	48 83 7c 24 78
	00		 cmp	 QWORD PTR logobfr$[rsp], 0
  01246	74 1a		 je	 SHORT $LN72@connect_cl
  01248	48 8d 84 24 60
	06 00 00	 lea	 rax, QWORD PTR buf$[rsp]
  01250	48 39 44 24 78	 cmp	 QWORD PTR logobfr$[rsp], rax
  01255	74 0b		 je	 SHORT $LN72@connect_cl

; 3250 :         free( logobfr );

  01257	48 8b 4c 24 78	 mov	 rcx, QWORD PTR logobfr$[rsp]
  0125c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free
$LN72@connect_cl:

; 3251 : 
; 3252 :     if (clientip)

  01262	48 83 7c 24 70
	00		 cmp	 QWORD PTR clientip$[rsp], 0
  01268	74 0b		 je	 SHORT $LN73@connect_cl

; 3253 :         free( clientip );

  0126a	48 8b 4c 24 70	 mov	 rcx, QWORD PTR clientip$[rsp]
  0126f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free
$LN73@connect_cl:

; 3254 : 
; 3255 :     /* Raise attention interrupt for the device */
; 3256 :     raise_device_attention( dev, CSW_DE );

  01275	b2 04		 mov	 dl, 4
  01277	48 8b 4c 24 50	 mov	 rcx, QWORD PTR dev$[rsp]
  0127c	e8 00 00 00 00	 call	 raise_device_attention
$LN15@connect_cl:

; 3257 : 
; 3258 :     /* Signal connection thread to redrive its pselect loop */
; 3259 :     SIGNAL_CONSOLE_THREAD();

  01281	c6 44 24 60 00	 mov	 BYTE PTR c$1[rsp], 0
  01286	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_WSAGetLastError
  0128c	89 84 24 a4 00
	00 00		 mov	 DWORD PTR saved_errno$4[rsp], eax
  01293	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  0129a	48 05 c0 10 00
	00		 add	 rax, 4288		; 000010c0H
  012a0	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG179106
  012a7	48 8b c8	 mov	 rcx, rax
  012aa	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_obtain_lock
  012b0	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  012b7	8b 80 c8 10 00
	00		 mov	 eax, DWORD PTR [rax+4296]
  012bd	89 84 24 9c 00
	00 00		 mov	 DWORD PTR f$3[rsp], eax
  012c4	83 bc 24 9c 00
	00 00 00	 cmp	 DWORD PTR f$3[rsp], 0
  012cc	7f 11		 jg	 SHORT $LN74@connect_cl
  012ce	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  012d5	c7 80 c8 10 00
	00 01 00 00 00	 mov	 DWORD PTR [rax+4296], 1
$LN74@connect_cl:
  012df	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  012e6	48 05 c0 10 00
	00		 add	 rax, 4288		; 000010c0H
  012ec	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG179108
  012f3	48 8b c8	 mov	 rcx, rax
  012f6	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_release_lock
  012fc	83 bc 24 9c 00
	00 00 00	 cmp	 DWORD PTR f$3[rsp], 0
  01304	0f 8f 90 00 00
	00		 jg	 $LN75@connect_cl
$LN18@connect_cl:
  0130a	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  01311	48 63 80 cc 10
	00 00		 movsxd	 rax, DWORD PTR [rax+4300]
  01318	45 33 c9	 xor	 r9d, r9d
  0131b	41 b8 01 00 00
	00		 mov	 r8d, 1
  01321	48 8d 54 24 60	 lea	 rdx, QWORD PTR c$1[rsp]
  01326	48 8b c8	 mov	 rcx, rax
  01329	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_send
  0132f	83 f8 01	 cmp	 eax, 1
  01332	74 5c		 je	 SHORT $LN76@connect_cl
$LN21@connect_cl:
  01334	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG179111
  0133b	41 b8 bb 0c 00
	00		 mov	 r8d, 3259		; 00000cbbH
  01341	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG179112
  01348	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG179113
  0134f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_logmsg
  01355	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_IsDebuggerPresent
  0135b	85 c0		 test	 eax, eax
  0135d	74 20		 je	 SHORT $LN77@connect_cl
  0135f	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG179115
  01366	41 b8 bb 0c 00
	00		 mov	 r8d, 3259		; 00000cbbH
  0136c	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG179116
  01373	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG179117
  0137a	e8 00 00 00 00	 call	 DebuggerTrace
$LN77@connect_cl:
  0137f	33 c0		 xor	 eax, eax
  01381	85 c0		 test	 eax, eax
  01383	75 af		 jne	 SHORT $LN21@connect_cl
  01385	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_IsDebuggerPresent
  0138b	85 c0		 test	 eax, eax
  0138d	74 01		 je	 SHORT $LN78@connect_cl
  0138f	cc		 int	 3
$LN78@connect_cl:
$LN76@connect_cl:
  01390	33 c0		 xor	 eax, eax
  01392	85 c0		 test	 eax, eax
  01394	0f 85 70 ff ff
	ff		 jne	 $LN18@connect_cl
$LN75@connect_cl:
  0139a	8b 8c 24 a4 00
	00 00		 mov	 ecx, DWORD PTR saved_errno$4[rsp]
  013a1	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_WSASetLastError
  013a7	33 c0		 xor	 eax, eax
  013a9	85 c0		 test	 eax, eax
  013ab	0f 85 d0 fe ff
	ff		 jne	 $LN15@connect_cl

; 3260 : 
; 3261 :     return NULL;

  013b1	33 c0		 xor	 eax, eax
$LN1@connect_cl:

; 3262 : 
; 3263 : } /* end function connect_client */

  013b3	48 8b 8c 24 e0
	0d 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  013bb	48 33 cc	 xor	 rcx, rsp
  013be	e8 00 00 00 00	 call	 __security_check_cookie
  013c3	48 81 c4 f0 0d
	00 00		 add	 rsp, 3568		; 00000df0H
  013ca	5f		 pop	 rdi
  013cb	c3		 ret	 0
connect_client ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\console.c
_TEXT	SEGMENT
num$ = 96
tv148 = 100
tv154 = 104
tv139 = 108
tv84 = 112
tv89 = 120
tv141 = 128
buf$ = 144
__$ArrayPad$ = 304
dev$ = 336
recv_1052_data PROC

; 2766 : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 81 ec 48 01
	00 00		 sub	 rsp, 328		; 00000148H
  0000c	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00013	48 33 c4	 xor	 rax, rsp
  00016	48 89 84 24 30
	01 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 2767 : int     num;                            /* Number of bytes received  */
; 2768 : BYTE    buf[BUFLEN_1052];               /* Receive buffer            */
; 2769 : 
; 2770 :     dev->tn->got_eor   = FALSE;

  0001e	48 8b 84 24 50
	01 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00026	48 8b 80 b0 06
	00 00		 mov	 rax, QWORD PTR [rax+1712]
  0002d	c6 80 af 00 00
	00 00		 mov	 BYTE PTR [rax+175], 0

; 2771 :     dev->tn->got_break = FALSE;

  00034	48 8b 84 24 50
	01 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  0003c	48 8b 80 b0 06
	00 00		 mov	 rax, QWORD PTR [rax+1712]
  00043	c6 80 b0 00 00
	00 00		 mov	 BYTE PTR [rax+176], 0

; 2772 :     dev->tn->neg_fail  = FALSE;

  0004a	48 8b 84 24 50
	01 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00052	48 8b 80 b0 06
	00 00		 mov	 rax, QWORD PTR [rax+1712]
  00059	c6 80 b3 00 00
	00 00		 mov	 BYTE PTR [rax+179], 0

; 2773 :     dev->tn->send_err  = FALSE;

  00060	48 8b 84 24 50
	01 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00068	48 8b 80 b0 06
	00 00		 mov	 rax, QWORD PTR [rax+1712]
  0006f	c6 80 b4 00 00
	00 00		 mov	 BYTE PTR [rax+180], 0

; 2774 :     dev->tn->overflow  = FALSE;

  00076	48 8b 84 24 50
	01 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  0007e	48 8b 80 b0 06
	00 00		 mov	 rax, QWORD PTR [rax+1712]
  00085	c6 80 b5 00 00
	00 00		 mov	 BYTE PTR [rax+181], 0

; 2775 :     dev->tn->overrun   = FALSE;

  0008c	48 8b 84 24 50
	01 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00094	48 8b 80 b0 06
	00 00		 mov	 rax, QWORD PTR [rax+1712]
  0009b	c6 80 b6 00 00
	00 00		 mov	 BYTE PTR [rax+182], 0

; 2776 : 
; 2777 :     /* Read bytes from client */
; 2778 :     num = recv( dev->fd, buf, sizeof( buf ), 0 );

  000a2	48 8b 84 24 50
	01 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  000aa	48 63 80 ac 01
	00 00		 movsxd	 rax, DWORD PTR [rax+428]
  000b1	45 33 c9	 xor	 r9d, r9d
  000b4	41 b8 96 00 00
	00		 mov	 r8d, 150		; 00000096H
  000ba	48 8d 94 24 90
	00 00 00	 lea	 rdx, QWORD PTR buf$[rsp]
  000c2	48 8b c8	 mov	 rcx, rax
  000c5	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_recv
  000cb	89 44 24 60	 mov	 DWORD PTR num$[rsp], eax

; 2779 : 
; 2780 :     /* Return unit check if error on receive */
; 2781 :     if (num < 0)

  000cf	83 7c 24 60 00	 cmp	 DWORD PTR num$[rsp], 0
  000d4	0f 8d bc 00 00
	00		 jge	 $LN2@recv_1052_

; 2782 :     {
; 2783 :         // "%s COMM: recv() failed: %s"
; 2784 :         CONERROR( HHC90507, "D", dev->tn->clientid, strerror( HSO_errno ));

  000da	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_WSAGetLastError
  000e0	8b c8		 mov	 ecx, eax
  000e2	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_strerror
  000e8	48 89 44 24 70	 mov	 QWORD PTR tv84[rsp], rax
  000ed	48 8b 8c 24 50
	01 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  000f5	48 8b 89 b0 06
	00 00		 mov	 rcx, QWORD PTR [rcx+1712]
  000fc	48 83 c1 62	 add	 rcx, 98			; 00000062H
  00100	48 89 4c 24 78	 mov	 QWORD PTR tv89[rsp], rcx
  00105	b9 01 00 00 00	 mov	 ecx, 1
  0010a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  00110	48 8b 4c 24 70	 mov	 rcx, QWORD PTR tv84[rsp]
  00115	48 89 4c 24 40	 mov	 QWORD PTR [rsp+64], rcx
  0011a	48 8b 4c 24 78	 mov	 rcx, QWORD PTR tv89[rsp]
  0011f	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  00124	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG178887
  0012b	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  00130	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG178888
  00137	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  0013c	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00141	41 b9 03 00 00
	00		 mov	 r9d, 3
  00147	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG178889
  0014e	ba e0 0a 00 00	 mov	 edx, 2784		; 00000ae0H
  00153	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG178890
  0015a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 2785 : 
; 2786 :         if (HSO_EAGAIN == HSO_errno)

  00160	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_WSAGetLastError
  00166	3d 33 27 00 00	 cmp	 eax, 10035		; 00002733H
  0016b	75 09		 jne	 SHORT $LN3@recv_1052_

; 2787 :             // non blocking call and no data
; 2788 :             return 0;

  0016d	32 c0		 xor	 al, al
  0016f	e9 e3 02 00 00	 jmp	 $LN1@recv_1052_
  00174	eb 20		 jmp	 SHORT $LN4@recv_1052_
$LN3@recv_1052_:

; 2789 :         else
; 2790 :         {
; 2791 :             dev->sense[0] = SENSE_EC;

  00176	b8 01 00 00 00	 mov	 eax, 1
  0017b	48 6b c0 00	 imul	 rax, rax, 0
  0017f	48 8b 8c 24 50
	01 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  00187	c6 84 01 64 03
	00 00 10	 mov	 BYTE PTR [rcx+rax+868], 16

; 2792 :             return (CSW_ATTN | CSW_UC);

  0018f	b0 82		 mov	 al, 130			; 00000082H
  00191	e9 c1 02 00 00	 jmp	 $LN1@recv_1052_
$LN4@recv_1052_:
$LN2@recv_1052_:

; 2793 :         }
; 2794 :     }
; 2795 : 
; 2796 :     /* If zero bytes were received then client has closed connection */
; 2797 :     if (num == 0)

  00196	83 7c 24 60 00	 cmp	 DWORD PTR num$[rsp], 0
  0019b	0f 85 04 01 00
	00		 jne	 $LN5@recv_1052_

; 2798 :     {
; 2799 :         WRMSG( HHC01022, "I", LCSS_DEVNUM,

  001a1	48 83 bc 24 50
	01 00 00 00	 cmp	 QWORD PTR dev$[rsp], 0
  001aa	74 12		 je	 SHORT $LN12@recv_1052_
  001ac	48 8b 84 24 50
	01 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  001b4	0f b7 40 48	 movzx	 eax, WORD PTR [rax+72]
  001b8	89 44 24 64	 mov	 DWORD PTR tv148[rsp], eax
  001bc	eb 08		 jmp	 SHORT $LN13@recv_1052_
$LN12@recv_1052_:
  001be	c7 44 24 64 00
	00 00 00	 mov	 DWORD PTR tv148[rsp], 0
$LN13@recv_1052_:
  001c6	48 83 bc 24 50
	01 00 00 00	 cmp	 QWORD PTR dev$[rsp], 0
  001cf	74 14		 je	 SHORT $LN14@recv_1052_
  001d1	48 8b 84 24 50
	01 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  001d9	0f b7 40 44	 movzx	 eax, WORD PTR [rax+68]
  001dd	d1 f8		 sar	 eax, 1
  001df	89 44 24 68	 mov	 DWORD PTR tv154[rsp], eax
  001e3	eb 08		 jmp	 SHORT $LN15@recv_1052_
$LN14@recv_1052_:
  001e5	c7 44 24 68 00
	00 00 00	 mov	 DWORD PTR tv154[rsp], 0
$LN15@recv_1052_:
  001ed	48 8b 84 24 50
	01 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  001f5	0f b7 40 4a	 movzx	 eax, WORD PTR [rax+74]
  001f9	89 44 24 6c	 mov	 DWORD PTR tv139[rsp], eax
  001fd	48 8b 8c 24 50
	01 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  00205	8b 89 a0 06 00
	00		 mov	 ecx, DWORD PTR [rcx+1696]
  0020b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_inet_ntoa
  00211	48 89 84 24 80
	00 00 00	 mov	 QWORD PTR tv141[rsp], rax
  00219	b9 01 00 00 00	 mov	 ecx, 1
  0021e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  00224	8b 4c 24 6c	 mov	 ecx, DWORD PTR tv139[rsp]
  00228	89 4c 24 50	 mov	 DWORD PTR [rsp+80], ecx
  0022c	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR tv141[rsp]
  00234	48 89 4c 24 48	 mov	 QWORD PTR [rsp+72], rcx
  00239	8b 4c 24 64	 mov	 ecx, DWORD PTR tv148[rsp]
  0023d	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  00241	8b 4c 24 68	 mov	 ecx, DWORD PTR tv154[rsp]
  00245	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  00249	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG178894
  00250	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  00255	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG178895
  0025c	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00261	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00266	41 b9 03 00 00
	00		 mov	 r9d, 3
  0026c	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG178896
  00273	ba f0 0a 00 00	 mov	 edx, 2800		; 00000af0H
  00278	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG178897
  0027f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 2800 :                inet_ntoa(dev->ipaddr), dev->devtype );
; 2801 :         dev->sense[0] = SENSE_IR;

  00285	b8 01 00 00 00	 mov	 eax, 1
  0028a	48 6b c0 00	 imul	 rax, rax, 0
  0028e	48 8b 8c 24 50
	01 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  00296	c6 84 01 64 03
	00 00 40	 mov	 BYTE PTR [rcx+rax+868], 64 ; 00000040H

; 2802 :         return (CSW_ATTN | CSW_UC);

  0029e	b0 82		 mov	 al, 130			; 00000082H
  002a0	e9 b2 01 00 00	 jmp	 $LN1@recv_1052_
$LN5@recv_1052_:

; 2803 :     }
; 2804 : 
; 2805 :     // "%s COMM: received %d bytes"
; 2806 :     CONDEBUG2( HHC90501, "D", dev->tn->clientid, num );
; 2807 :     DUMPBUF(   HHC90501, buf, num, 0 );
; 2808 : 
; 2809 :     /* Pass received data to libtelnet for processing */
; 2810 :     telnet_recv( dev->tn->ctl, buf, num );

  002a5	48 8b 84 24 50
	01 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  002ad	48 8b 80 b0 06
	00 00		 mov	 rax, QWORD PTR [rax+1712]
  002b4	44 8b 44 24 60	 mov	 r8d, DWORD PTR num$[rsp]
  002b9	48 8d 94 24 90
	00 00 00	 lea	 rdx, QWORD PTR buf$[rsp]
  002c1	48 8b 88 98 00
	00 00		 mov	 rcx, QWORD PTR [rax+152]
  002c8	e8 00 00 00 00	 call	 telnet_recv

; 2811 : 
; 2812 :     /* Check results for any errors */
; 2813 :     if (0
; 2814 :         || dev->tn->neg_fail
; 2815 :         || dev->tn->send_err
; 2816 :         || dev->tn->overflow

  002cd	33 c0		 xor	 eax, eax
  002cf	85 c0		 test	 eax, eax
  002d1	75 4e		 jne	 SHORT $LN7@recv_1052_
  002d3	48 8b 84 24 50
	01 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  002db	48 8b 80 b0 06
	00 00		 mov	 rax, QWORD PTR [rax+1712]
  002e2	0f b6 80 b3 00
	00 00		 movzx	 eax, BYTE PTR [rax+179]
  002e9	85 c0		 test	 eax, eax
  002eb	75 34		 jne	 SHORT $LN7@recv_1052_
  002ed	48 8b 84 24 50
	01 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  002f5	48 8b 80 b0 06
	00 00		 mov	 rax, QWORD PTR [rax+1712]
  002fc	0f b6 80 b4 00
	00 00		 movzx	 eax, BYTE PTR [rax+180]
  00303	85 c0		 test	 eax, eax
  00305	75 1a		 jne	 SHORT $LN7@recv_1052_
  00307	48 8b 84 24 50
	01 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  0030f	48 8b 80 b0 06
	00 00		 mov	 rax, QWORD PTR [rax+1712]
  00316	0f b6 80 b5 00
	00 00		 movzx	 eax, BYTE PTR [rax+181]
  0031d	85 c0		 test	 eax, eax
  0031f	74 32		 je	 SHORT $LN6@recv_1052_
$LN7@recv_1052_:

; 2817 :     )
; 2818 :     {
; 2819 :         dev->keybdrem = 0;

  00321	48 8b 84 24 50
	01 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00329	c7 80 c0 06 00
	00 00 00 00 00	 mov	 DWORD PTR [rax+1728], 0

; 2820 :         dev->sense[0] = SENSE_EC;       /* Equipment Check */

  00333	b8 01 00 00 00	 mov	 eax, 1
  00338	48 6b c0 00	 imul	 rax, rax, 0
  0033c	48 8b 8c 24 50
	01 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  00344	c6 84 01 64 03
	00 00 10	 mov	 BYTE PTR [rcx+rax+868], 16

; 2821 :         return (CSW_ATTN | CSW_UC);

  0034c	b0 82		 mov	 al, 130			; 00000082H
  0034e	e9 04 01 00 00	 jmp	 $LN1@recv_1052_
$LN6@recv_1052_:

; 2822 :     }
; 2823 : 
; 2824 :     if (dev->tn->overrun)

  00353	48 8b 84 24 50
	01 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  0035b	48 8b 80 b0 06
	00 00		 mov	 rax, QWORD PTR [rax+1712]
  00362	0f b6 80 b6 00
	00 00		 movzx	 eax, BYTE PTR [rax+182]
  00369	85 c0		 test	 eax, eax
  0036b	74 32		 je	 SHORT $LN8@recv_1052_

; 2825 :     {
; 2826 :         dev->keybdrem = 0;

  0036d	48 8b 84 24 50
	01 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00375	c7 80 c0 06 00
	00 00 00 00 00	 mov	 DWORD PTR [rax+1728], 0

; 2827 :         dev->sense[0] = SENSE_OR;       /* Overrun */

  0037f	b8 01 00 00 00	 mov	 eax, 1
  00384	48 6b c0 00	 imul	 rax, rax, 0
  00388	48 8b 8c 24 50
	01 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  00390	c6 84 01 64 03
	00 00 04	 mov	 BYTE PTR [rcx+rax+868], 4

; 2828 :         return (CSW_ATTN | CSW_UC);

  00398	b0 82		 mov	 al, 130			; 00000082H
  0039a	e9 b8 00 00 00	 jmp	 $LN1@recv_1052_
$LN8@recv_1052_:

; 2829 :     }
; 2830 : 
; 2831 :     /* If a break indication (Ctrl-C, IAC BRK, or IAC IP) is received,
; 2832 :        then attention and unit exception status is returned.
; 2833 :     */
; 2834 :     if (dev->tn->got_break)

  0039f	48 8b 84 24 50
	01 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  003a7	48 8b 80 b0 06
	00 00		 mov	 rax, QWORD PTR [rax+1712]
  003ae	0f b6 80 b0 00
	00 00		 movzx	 eax, BYTE PTR [rax+176]
  003b5	85 c0		 test	 eax, eax
  003b7	74 2c		 je	 SHORT $LN9@recv_1052_

; 2835 :     {
; 2836 :         dev->tn->got_break = FALSE;

  003b9	48 8b 84 24 50
	01 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  003c1	48 8b 80 b0 06
	00 00		 mov	 rax, QWORD PTR [rax+1712]
  003c8	c6 80 b0 00 00
	00 00		 mov	 BYTE PTR [rax+176], 0

; 2837 :         dev->keybdrem = 0;

  003cf	48 8b 84 24 50
	01 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  003d7	c7 80 c0 06 00
	00 00 00 00 00	 mov	 DWORD PTR [rax+1728], 0

; 2838 :         return (CSW_ATTN | CSW_UX);

  003e1	b0 81		 mov	 al, 129			; 00000081H
  003e3	eb 72		 jmp	 SHORT $LN1@recv_1052_
$LN9@recv_1052_:

; 2839 :     }
; 2840 : 
; 2841 :     /* Return zero status if CRLF was not yet received */
; 2842 :     if (!dev->tn->got_eor)

  003e5	48 8b 84 24 50
	01 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  003ed	48 8b 80 b0 06
	00 00		 mov	 rax, QWORD PTR [rax+1712]
  003f4	0f b6 80 af 00
	00 00		 movzx	 eax, BYTE PTR [rax+175]
  003fb	85 c0		 test	 eax, eax
  003fd	75 04		 jne	 SHORT $LN10@recv_1052_

; 2843 :         return 0;

  003ff	32 c0		 xor	 al, al
  00401	eb 54		 jmp	 SHORT $LN1@recv_1052_
$LN10@recv_1052_:

; 2844 : 
; 2845 :     /* Strip off the CRLF sequence */
; 2846 :     dev->keybdrem -= 2;

  00403	48 8b 84 24 50
	01 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  0040b	8b 80 c0 06 00
	00		 mov	 eax, DWORD PTR [rax+1728]
  00411	83 e8 02	 sub	 eax, 2
  00414	48 8b 8c 24 50
	01 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  0041c	89 81 c0 06 00
	00		 mov	 DWORD PTR [rcx+1728], eax

; 2847 : 
; 2848 :     /* Translate the keyboard buffer to EBCDIC */
; 2849 :     prt_host_to_guest( dev->buf, dev->buf, dev->keybdrem );

  00422	48 8b 84 24 50
	01 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  0042a	44 8b 80 c0 06
	00 00		 mov	 r8d, DWORD PTR [rax+1728]
  00431	48 8b 84 24 50
	01 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00439	48 8b 90 c8 01
	00 00		 mov	 rdx, QWORD PTR [rax+456]
  00440	48 8b 84 24 50
	01 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00448	48 8b 88 c8 01
	00 00		 mov	 rcx, QWORD PTR [rax+456]
  0044f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_prt_host_to_guest

; 2850 : 
; 2851 :     /* Return attention status */
; 2852 :     return (CSW_ATTN);

  00455	b0 80		 mov	 al, 128			; 00000080H
$LN1@recv_1052_:

; 2853 : 
; 2854 : } /* end function recv_1052_data */

  00457	48 8b 8c 24 30
	01 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  0045f	48 33 cc	 xor	 rcx, rsp
  00462	e8 00 00 00 00	 call	 __security_check_cookie
  00467	48 81 c4 48 01
	00 00		 add	 rsp, 328		; 00000148H
  0046e	c3		 ret	 0
recv_1052_data ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\console.c
_TEXT	SEGMENT
rc$ = 96
tv132 = 100
tv138 = 104
tv181 = 108
tv187 = 112
tv91 = 116
tv172 = 120
tv93 = 128
tv149 = 136
tv154 = 144
tv174 = 152
buf$ = 160
__$ArrayPad$ = 65696
dev$ = 65728
recv_3270_data PROC

; 2588 : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	b8 b8 00 01 00	 mov	 eax, 65720		; 000100b8H
  0000a	e8 00 00 00 00	 call	 __chkstk
  0000f	48 2b e0	 sub	 rsp, rax
  00012	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00019	48 33 c4	 xor	 rax, rsp
  0001c	48 89 84 24 a0
	00 01 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 2589 : int     rc;                             /* Return code               */
; 2590 : BYTE    buf[ BUFLEN_3270 ];             /* Temporary recv() buffer   */
; 2591 : 
; 2592 :     /* If there is a complete data record already in the buffer
; 2593 :        then discard it before reading more data */
; 2594 :     if (dev->readpending)

  00024	48 8b 84 24 c0
	00 01 00	 mov	 rax, QWORD PTR dev$[rsp]
  0002c	8b 80 f8 05 00
	00		 mov	 eax, DWORD PTR [rax+1528]
  00032	c1 e8 06	 shr	 eax, 6
  00035	83 e0 03	 and	 eax, 3
  00038	85 c0		 test	 eax, eax
  0003a	74 33		 je	 SHORT $LN2@recv_3270_

; 2595 :     {
; 2596 :         dev->rlen3270 = 0;

  0003c	48 8b 84 24 c0
	00 01 00	 mov	 rax, QWORD PTR dev$[rsp]
  00044	c7 80 b8 06 00
	00 00 00 00 00	 mov	 DWORD PTR [rax+1720], 0

; 2597 :         dev->readpending = 0;

  0004e	48 8b 84 24 c0
	00 01 00	 mov	 rax, QWORD PTR dev$[rsp]
  00056	8b 80 f8 05 00
	00		 mov	 eax, DWORD PTR [rax+1528]
  0005c	25 3f ff ff ff	 and	 eax, -193		; ffffff3fH
  00061	48 8b 8c 24 c0
	00 01 00	 mov	 rcx, QWORD PTR dev$[rsp]
  00069	89 81 f8 05 00
	00		 mov	 DWORD PTR [rcx+1528], eax
$LN2@recv_3270_:

; 2598 :     }
; 2599 : 
; 2600 :     dev->tn->got_eor  = FALSE;

  0006f	48 8b 84 24 c0
	00 01 00	 mov	 rax, QWORD PTR dev$[rsp]
  00077	48 8b 80 b0 06
	00 00		 mov	 rax, QWORD PTR [rax+1712]
  0007e	c6 80 af 00 00
	00 00		 mov	 BYTE PTR [rax+175], 0

; 2601 :     dev->tn->neg_fail = FALSE;

  00085	48 8b 84 24 c0
	00 01 00	 mov	 rax, QWORD PTR dev$[rsp]
  0008d	48 8b 80 b0 06
	00 00		 mov	 rax, QWORD PTR [rax+1712]
  00094	c6 80 b3 00 00
	00 00		 mov	 BYTE PTR [rax+179], 0

; 2602 :     dev->tn->send_err = FALSE;

  0009b	48 8b 84 24 c0
	00 01 00	 mov	 rax, QWORD PTR dev$[rsp]
  000a3	48 8b 80 b0 06
	00 00		 mov	 rax, QWORD PTR [rax+1712]
  000aa	c6 80 b4 00 00
	00 00		 mov	 BYTE PTR [rax+180], 0

; 2603 :     dev->tn->overflow = FALSE;

  000b1	48 8b 84 24 c0
	00 01 00	 mov	 rax, QWORD PTR dev$[rsp]
  000b9	48 8b 80 b0 06
	00 00		 mov	 rax, QWORD PTR [rax+1712]
  000c0	c6 80 b5 00 00
	00 00		 mov	 BYTE PTR [rax+181], 0

; 2604 : 
; 2605 :     /* Read bytes from client */
; 2606 :     rc = recv( dev->fd, buf, sizeof( buf ), 0 );

  000c7	48 8b 84 24 c0
	00 01 00	 mov	 rax, QWORD PTR dev$[rsp]
  000cf	48 63 80 ac 01
	00 00		 movsxd	 rax, DWORD PTR [rax+428]
  000d6	45 33 c9	 xor	 r9d, r9d
  000d9	41 b8 00 00 01
	00		 mov	 r8d, 65536		; 00010000H
  000df	48 8d 94 24 a0
	00 00 00	 lea	 rdx, QWORD PTR buf$[rsp]
  000e7	48 8b c8	 mov	 rcx, rax
  000ea	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_recv
  000f0	89 44 24 60	 mov	 DWORD PTR rc$[rsp], eax

; 2607 : 
; 2608 :     /* Check for I/O error */
; 2609 :     if (rc < 0)

  000f4	83 7c 24 60 00	 cmp	 DWORD PTR rc$[rsp], 0
  000f9	0f 8d c2 01 00
	00		 jge	 $LN3@recv_3270_

; 2610 :     {
; 2611 :         if (HSO_ECONNRESET == HSO_errno)

  000ff	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_WSAGetLastError
  00105	3d 46 27 00 00	 cmp	 eax, 10054		; 00002746H
  0010a	0f 85 e9 00 00
	00		 jne	 $LN4@recv_3270_

; 2612 :             // "%1d:%04X COMM: client %s devtype %4.4X: connection reset"
; 2613 :             WRMSG( HHC01090, "I", LCSS_DEVNUM,

  00110	48 83 bc 24 c0
	00 01 00 00	 cmp	 QWORD PTR dev$[rsp], 0
  00119	74 12		 je	 SHORT $LN13@recv_3270_
  0011b	48 8b 84 24 c0
	00 01 00	 mov	 rax, QWORD PTR dev$[rsp]
  00123	0f b7 40 48	 movzx	 eax, WORD PTR [rax+72]
  00127	89 44 24 64	 mov	 DWORD PTR tv132[rsp], eax
  0012b	eb 08		 jmp	 SHORT $LN14@recv_3270_
$LN13@recv_3270_:
  0012d	c7 44 24 64 00
	00 00 00	 mov	 DWORD PTR tv132[rsp], 0
$LN14@recv_3270_:
  00135	48 83 bc 24 c0
	00 01 00 00	 cmp	 QWORD PTR dev$[rsp], 0
  0013e	74 14		 je	 SHORT $LN15@recv_3270_
  00140	48 8b 84 24 c0
	00 01 00	 mov	 rax, QWORD PTR dev$[rsp]
  00148	0f b7 40 44	 movzx	 eax, WORD PTR [rax+68]
  0014c	d1 f8		 sar	 eax, 1
  0014e	89 44 24 68	 mov	 DWORD PTR tv138[rsp], eax
  00152	eb 08		 jmp	 SHORT $LN16@recv_3270_
$LN15@recv_3270_:
  00154	c7 44 24 68 00
	00 00 00	 mov	 DWORD PTR tv138[rsp], 0
$LN16@recv_3270_:
  0015c	48 8b 84 24 c0
	00 01 00	 mov	 rax, QWORD PTR dev$[rsp]
  00164	0f b7 40 4a	 movzx	 eax, WORD PTR [rax+74]
  00168	89 44 24 74	 mov	 DWORD PTR tv91[rsp], eax
  0016c	48 8b 8c 24 c0
	00 01 00	 mov	 rcx, QWORD PTR dev$[rsp]
  00174	8b 89 a0 06 00
	00		 mov	 ecx, DWORD PTR [rcx+1696]
  0017a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_inet_ntoa
  00180	48 89 84 24 80
	00 00 00	 mov	 QWORD PTR tv93[rsp], rax
  00188	b9 01 00 00 00	 mov	 ecx, 1
  0018d	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  00193	8b 4c 24 74	 mov	 ecx, DWORD PTR tv91[rsp]
  00197	89 4c 24 50	 mov	 DWORD PTR [rsp+80], ecx
  0019b	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR tv93[rsp]
  001a3	48 89 4c 24 48	 mov	 QWORD PTR [rsp+72], rcx
  001a8	8b 4c 24 64	 mov	 ecx, DWORD PTR tv132[rsp]
  001ac	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  001b0	8b 4c 24 68	 mov	 ecx, DWORD PTR tv138[rsp]
  001b4	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  001b8	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG178846
  001bf	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  001c4	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG178847
  001cb	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  001d0	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  001d5	41 b9 03 00 00
	00		 mov	 r9d, 3
  001db	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG178848
  001e2	ba 36 0a 00 00	 mov	 edx, 2614		; 00000a36H
  001e7	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG178849
  001ee	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg
  001f4	e9 92 00 00 00	 jmp	 $LN5@recv_3270_
$LN4@recv_3270_:

; 2614 :                   inet_ntoa(dev->ipaddr), dev->devtype );
; 2615 :         else
; 2616 :             // "%s COMM: recv() failed: %s"
; 2617 :             CONERROR( HHC90507, "D", dev->tn->clientid, strerror( HSO_errno ));

  001f9	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_WSAGetLastError
  001ff	8b c8		 mov	 ecx, eax
  00201	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_strerror
  00207	48 89 84 24 88
	00 00 00	 mov	 QWORD PTR tv149[rsp], rax
  0020f	48 8b 8c 24 c0
	00 01 00	 mov	 rcx, QWORD PTR dev$[rsp]
  00217	48 8b 89 b0 06
	00 00		 mov	 rcx, QWORD PTR [rcx+1712]
  0021e	48 83 c1 62	 add	 rcx, 98			; 00000062H
  00222	48 89 8c 24 90
	00 00 00	 mov	 QWORD PTR tv154[rsp], rcx
  0022a	b9 01 00 00 00	 mov	 ecx, 1
  0022f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  00235	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR tv149[rsp]
  0023d	48 89 4c 24 40	 mov	 QWORD PTR [rsp+64], rcx
  00242	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR tv154[rsp]
  0024a	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  0024f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG178850
  00256	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  0025b	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG178851
  00262	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00267	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  0026c	41 b9 03 00 00
	00		 mov	 r9d, 3
  00272	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG178852
  00279	ba 39 0a 00 00	 mov	 edx, 2617		; 00000a39H
  0027e	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG178853
  00285	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg
$LN5@recv_3270_:

; 2618 :         if (HSO_EAGAIN == HSO_errno)

  0028b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_WSAGetLastError
  00291	3d 33 27 00 00	 cmp	 eax, 10035		; 00002733H
  00296	75 09		 jne	 SHORT $LN6@recv_3270_

; 2619 :             // non blocking call and no data
; 2620 :             return 0;

  00298	32 c0		 xor	 al, al
  0029a	e9 0e 02 00 00	 jmp	 $LN1@recv_3270_
  0029f	eb 20		 jmp	 SHORT $LN7@recv_3270_
$LN6@recv_3270_:

; 2621 :         else
; 2622 :         {
; 2623 :             dev->sense[0] = SENSE_EC;

  002a1	b8 01 00 00 00	 mov	 eax, 1
  002a6	48 6b c0 00	 imul	 rax, rax, 0
  002aa	48 8b 8c 24 c0
	00 01 00	 mov	 rcx, QWORD PTR dev$[rsp]
  002b2	c6 84 01 64 03
	00 00 10	 mov	 BYTE PTR [rcx+rax+868], 16

; 2624 :             return (CSW_ATTN | CSW_UC);

  002ba	b0 82		 mov	 al, 130			; 00000082H
  002bc	e9 ec 01 00 00	 jmp	 $LN1@recv_3270_
$LN7@recv_3270_:
$LN3@recv_3270_:

; 2625 :         }
; 2626 :     }
; 2627 : 
; 2628 :     /* If zero bytes were received then client has closed connection */
; 2629 :     if (rc == 0)

  002c1	83 7c 24 60 00	 cmp	 DWORD PTR rc$[rsp], 0
  002c6	0f 85 04 01 00
	00		 jne	 $LN8@recv_3270_

; 2630 :     {
; 2631 :         // "%1d:%04X COMM: client %s devtype %4.4X: connection closed by client"
; 2632 :         WRMSG( HHC01022, "I", LCSS_DEVNUM,

  002cc	48 83 bc 24 c0
	00 01 00 00	 cmp	 QWORD PTR dev$[rsp], 0
  002d5	74 12		 je	 SHORT $LN17@recv_3270_
  002d7	48 8b 84 24 c0
	00 01 00	 mov	 rax, QWORD PTR dev$[rsp]
  002df	0f b7 40 48	 movzx	 eax, WORD PTR [rax+72]
  002e3	89 44 24 6c	 mov	 DWORD PTR tv181[rsp], eax
  002e7	eb 08		 jmp	 SHORT $LN18@recv_3270_
$LN17@recv_3270_:
  002e9	c7 44 24 6c 00
	00 00 00	 mov	 DWORD PTR tv181[rsp], 0
$LN18@recv_3270_:
  002f1	48 83 bc 24 c0
	00 01 00 00	 cmp	 QWORD PTR dev$[rsp], 0
  002fa	74 14		 je	 SHORT $LN19@recv_3270_
  002fc	48 8b 84 24 c0
	00 01 00	 mov	 rax, QWORD PTR dev$[rsp]
  00304	0f b7 40 44	 movzx	 eax, WORD PTR [rax+68]
  00308	d1 f8		 sar	 eax, 1
  0030a	89 44 24 70	 mov	 DWORD PTR tv187[rsp], eax
  0030e	eb 08		 jmp	 SHORT $LN20@recv_3270_
$LN19@recv_3270_:
  00310	c7 44 24 70 00
	00 00 00	 mov	 DWORD PTR tv187[rsp], 0
$LN20@recv_3270_:
  00318	48 8b 84 24 c0
	00 01 00	 mov	 rax, QWORD PTR dev$[rsp]
  00320	0f b7 40 4a	 movzx	 eax, WORD PTR [rax+74]
  00324	89 44 24 78	 mov	 DWORD PTR tv172[rsp], eax
  00328	48 8b 8c 24 c0
	00 01 00	 mov	 rcx, QWORD PTR dev$[rsp]
  00330	8b 89 a0 06 00
	00		 mov	 ecx, DWORD PTR [rcx+1696]
  00336	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_inet_ntoa
  0033c	48 89 84 24 98
	00 00 00	 mov	 QWORD PTR tv174[rsp], rax
  00344	b9 01 00 00 00	 mov	 ecx, 1
  00349	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  0034f	8b 4c 24 78	 mov	 ecx, DWORD PTR tv172[rsp]
  00353	89 4c 24 50	 mov	 DWORD PTR [rsp+80], ecx
  00357	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR tv174[rsp]
  0035f	48 89 4c 24 48	 mov	 QWORD PTR [rsp+72], rcx
  00364	8b 4c 24 6c	 mov	 ecx, DWORD PTR tv181[rsp]
  00368	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  0036c	8b 4c 24 70	 mov	 ecx, DWORD PTR tv187[rsp]
  00370	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  00374	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG178857
  0037b	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  00380	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG178858
  00387	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  0038c	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00391	41 b9 03 00 00
	00		 mov	 r9d, 3
  00397	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG178859
  0039e	ba 49 0a 00 00	 mov	 edx, 2633		; 00000a49H
  003a3	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG178860
  003aa	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 2633 :               inet_ntoa(dev->ipaddr), dev->devtype );
; 2634 :         dev->sense[0] = SENSE_IR;

  003b0	b8 01 00 00 00	 mov	 eax, 1
  003b5	48 6b c0 00	 imul	 rax, rax, 0
  003b9	48 8b 8c 24 c0
	00 01 00	 mov	 rcx, QWORD PTR dev$[rsp]
  003c1	c6 84 01 64 03
	00 00 40	 mov	 BYTE PTR [rcx+rax+868], 64 ; 00000040H

; 2635 :         return (CSW_ATTN | CSW_UC | CSW_DE);

  003c9	b0 86		 mov	 al, 134			; 00000086H
  003cb	e9 dd 00 00 00	 jmp	 $LN1@recv_3270_
$LN8@recv_3270_:

; 2636 :     }
; 2637 : 
; 2638 :     // "%s COMM: received %d bytes"
; 2639 :     CONDEBUG2( HHC90501, "D", dev->tn->clientid, rc );
; 2640 :     DUMPBUF(   HHC90501, buf, rc, 1 );
; 2641 : 
; 2642 :     /* Pass received bytes to libtelnet for processing */
; 2643 :     telnet_recv( dev->tn->ctl, buf, rc );

  003d0	48 8b 84 24 c0
	00 01 00	 mov	 rax, QWORD PTR dev$[rsp]
  003d8	48 8b 80 b0 06
	00 00		 mov	 rax, QWORD PTR [rax+1712]
  003df	44 8b 44 24 60	 mov	 r8d, DWORD PTR rc$[rsp]
  003e4	48 8d 94 24 a0
	00 00 00	 lea	 rdx, QWORD PTR buf$[rsp]
  003ec	48 8b 88 98 00
	00 00		 mov	 rcx, QWORD PTR [rax+152]
  003f3	e8 00 00 00 00	 call	 telnet_recv

; 2644 : 
; 2645 :     /* Check results for any errors */
; 2646 :     if (0
; 2647 :         || dev->tn->neg_fail
; 2648 :         || dev->tn->send_err
; 2649 :         || dev->tn->overflow

  003f8	33 c0		 xor	 eax, eax
  003fa	85 c0		 test	 eax, eax
  003fc	75 4e		 jne	 SHORT $LN10@recv_3270_
  003fe	48 8b 84 24 c0
	00 01 00	 mov	 rax, QWORD PTR dev$[rsp]
  00406	48 8b 80 b0 06
	00 00		 mov	 rax, QWORD PTR [rax+1712]
  0040d	0f b6 80 b3 00
	00 00		 movzx	 eax, BYTE PTR [rax+179]
  00414	85 c0		 test	 eax, eax
  00416	75 34		 jne	 SHORT $LN10@recv_3270_
  00418	48 8b 84 24 c0
	00 01 00	 mov	 rax, QWORD PTR dev$[rsp]
  00420	48 8b 80 b0 06
	00 00		 mov	 rax, QWORD PTR [rax+1712]
  00427	0f b6 80 b4 00
	00 00		 movzx	 eax, BYTE PTR [rax+180]
  0042e	85 c0		 test	 eax, eax
  00430	75 1a		 jne	 SHORT $LN10@recv_3270_
  00432	48 8b 84 24 c0
	00 01 00	 mov	 rax, QWORD PTR dev$[rsp]
  0043a	48 8b 80 b0 06
	00 00		 mov	 rax, QWORD PTR [rax+1712]
  00441	0f b6 80 b5 00
	00 00		 movzx	 eax, BYTE PTR [rax+181]
  00448	85 c0		 test	 eax, eax
  0044a	74 1d		 je	 SHORT $LN9@recv_3270_
$LN10@recv_3270_:

; 2650 :     )
; 2651 :     {
; 2652 :         dev->sense[0] = SENSE_DC;

  0044c	b8 01 00 00 00	 mov	 eax, 1
  00451	48 6b c0 00	 imul	 rax, rax, 0
  00455	48 8b 8c 24 c0
	00 01 00	 mov	 rcx, QWORD PTR dev$[rsp]
  0045d	c6 84 01 64 03
	00 00 08	 mov	 BYTE PTR [rcx+rax+868], 8

; 2653 :         return (CSW_ATTN | CSW_UC);

  00465	b0 82		 mov	 al, 130			; 00000082H
  00467	eb 44		 jmp	 SHORT $LN1@recv_3270_
$LN9@recv_3270_:

; 2654 :     }
; 2655 : 
; 2656 :     /* Return zero status if record is incomplete */
; 2657 :     if (!dev->tn->got_eor)

  00469	48 8b 84 24 c0
	00 01 00	 mov	 rax, QWORD PTR dev$[rsp]
  00471	48 8b 80 b0 06
	00 00		 mov	 rax, QWORD PTR [rax+1712]
  00478	0f b6 80 af 00
	00 00		 movzx	 eax, BYTE PTR [rax+175]
  0047f	85 c0		 test	 eax, eax
  00481	75 04		 jne	 SHORT $LN11@recv_3270_

; 2658 :         return 0;

  00483	32 c0		 xor	 al, al
  00485	eb 26		 jmp	 SHORT $LN1@recv_3270_
$LN11@recv_3270_:

; 2659 : 
; 2660 :     /* Set the read pending indicator and return attention status */
; 2661 :     dev->readpending = 1;

  00487	48 8b 84 24 c0
	00 01 00	 mov	 rax, QWORD PTR dev$[rsp]
  0048f	8b 80 f8 05 00
	00		 mov	 eax, DWORD PTR [rax+1528]
  00495	25 3f ff ff ff	 and	 eax, -193		; ffffff3fH
  0049a	83 c8 40	 or	 eax, 64			; 00000040H
  0049d	48 8b 8c 24 c0
	00 01 00	 mov	 rcx, QWORD PTR dev$[rsp]
  004a5	89 81 f8 05 00
	00		 mov	 DWORD PTR [rcx+1528], eax

; 2662 :     return (CSW_ATTN);

  004ab	b0 80		 mov	 al, 128			; 00000080H
$LN1@recv_3270_:

; 2663 : 
; 2664 : } /* end function recv_3270_data */

  004ad	48 8b 8c 24 a0
	00 01 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  004b5	48 33 cc	 xor	 rcx, rsp
  004b8	e8 00 00 00 00	 call	 __security_check_cookie
  004bd	48 81 c4 b8 00
	01 00		 add	 rsp, 65720		; 000100b8H
  004c4	c3		 ret	 0
recv_3270_data ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\console.c
_TEXT	SEGMENT
i$ = 32
ttype$ = 64
model$ = 72
extatr$ = 80
lookup_ttype PROC

; 2294 : {

  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 2295 :     size_t i;
; 2296 :     for (i=0; i < _countof( tttab ); i++)

  00013	48 c7 44 24 20
	00 00 00 00	 mov	 QWORD PTR i$[rsp], 0
  0001c	eb 0d		 jmp	 SHORT $LN4@lookup_tty
$LN2@lookup_tty:
  0001e	48 8b 44 24 20	 mov	 rax, QWORD PTR i$[rsp]
  00023	48 ff c0	 inc	 rax
  00026	48 89 44 24 20	 mov	 QWORD PTR i$[rsp], rax
$LN4@lookup_tty:
  0002b	48 83 7c 24 20
	14		 cmp	 QWORD PTR i$[rsp], 20
  00031	73 58		 jae	 SHORT $LN3@lookup_tty

; 2297 :     {
; 2298 :         if (str_caseless_eq( tttab[i].ttype, ttype ))

  00033	48 6b 44 24 20
	10		 imul	 rax, QWORD PTR i$[rsp], 16
  00039	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:tttab
  00040	48 8b 54 24 40	 mov	 rdx, QWORD PTR ttype$[rsp]
  00045	48 8b 0c 01	 mov	 rcx, QWORD PTR [rcx+rax]
  00049	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__stricmp
  0004f	85 c0		 test	 eax, eax
  00051	75 36		 jne	 SHORT $LN5@lookup_tty

; 2299 :         {
; 2300 :             *model  = tttab[i].model;

  00053	48 6b 44 24 20
	10		 imul	 rax, QWORD PTR i$[rsp], 16
  00059	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:tttab
  00060	48 8b 54 24 48	 mov	 rdx, QWORD PTR model$[rsp]
  00065	0f b6 44 01 08	 movzx	 eax, BYTE PTR [rcx+rax+8]
  0006a	88 02		 mov	 BYTE PTR [rdx], al

; 2301 :             *extatr = tttab[i].extatr;

  0006c	48 6b 44 24 20
	10		 imul	 rax, QWORD PTR i$[rsp], 16
  00072	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:tttab
  00079	48 8b 54 24 50	 mov	 rdx, QWORD PTR extatr$[rsp]
  0007e	0f b6 44 01 09	 movzx	 eax, BYTE PTR [rcx+rax+9]
  00083	88 02		 mov	 BYTE PTR [rdx], al

; 2302 :             return true;

  00085	b0 01		 mov	 al, 1
  00087	eb 04		 jmp	 SHORT $LN1@lookup_tty
$LN5@lookup_tty:

; 2303 :         }
; 2304 :     }

  00089	eb 93		 jmp	 SHORT $LN2@lookup_tty
$LN3@lookup_tty:

; 2305 :     return false;

  0008b	32 c0		 xor	 al, al
$LN1@lookup_tty:

; 2306 : }

  0008d	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00091	c3		 ret	 0
lookup_ttype ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\console.c
_TEXT	SEGMENT
inaddr$1 = 64
$T2 = 72
$T3 = 80
tv174 = 88
acc$4 = 96
mask$5 = 160
ip$6 = 192
filename$ = 224
__$ArrayPad$ = 496
dev$ = 528
devclass$ = 536
buflen$ = 544
buffer$ = 552
loc3270_query_device PROC

; 2183 : {

  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	48 81 ec 08 02
	00 00		 sub	 rsp, 520		; 00000208H
  0001b	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00022	48 33 c4	 xor	 rax, rsp
  00025	48 89 84 24 f0
	01 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 2184 :     char  filename[ PATH_MAX + 1 ];     /* full path or just name    */
; 2185 : 
; 2186 :     BEGIN_DEVICE_CLASS_QUERY( "DSP", dev, devclass, buflen, buffer );

  0002d	48 83 bc 24 18
	02 00 00 00	 cmp	 QWORD PTR devclass$[rsp], 0
  00036	74 12		 je	 SHORT $LN2@loc3270_qu
  00038	48 8b 84 24 18
	02 00 00	 mov	 rax, QWORD PTR devclass$[rsp]
  00040	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG178685
  00047	48 89 08	 mov	 QWORD PTR [rax], rcx
$LN2@loc3270_qu:
  0004a	48 83 bc 24 10
	02 00 00 00	 cmp	 QWORD PTR dev$[rsp], 0
  00053	74 20		 je	 SHORT $LN4@loc3270_qu
  00055	48 83 bc 24 18
	02 00 00 00	 cmp	 QWORD PTR devclass$[rsp], 0
  0005e	74 15		 je	 SHORT $LN4@loc3270_qu
  00060	83 bc 24 20 02
	00 00 00	 cmp	 DWORD PTR buflen$[rsp], 0
  00068	74 0b		 je	 SHORT $LN4@loc3270_qu
  0006a	48 83 bc 24 28
	02 00 00 00	 cmp	 QWORD PTR buffer$[rsp], 0
  00073	75 05		 jne	 SHORT $LN3@loc3270_qu
$LN4@loc3270_qu:
  00075	e9 15 03 00 00	 jmp	 $LN1@loc3270_qu
$LN3@loc3270_qu:
  0007a	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00081	8b 80 94 12 00
	00		 mov	 eax, DWORD PTR [rax+4756]
  00087	c1 e8 1a	 shr	 eax, 26
  0008a	83 e0 01	 and	 eax, 1
  0008d	85 c0		 test	 eax, eax
  0008f	74 75		 je	 SHORT $LN5@loc3270_qu
  00091	48 8b 84 24 10
	02 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00099	48 05 a4 00 00
	00		 add	 rax, 164		; 000000a4H
  0009f	48 8b c8	 mov	 rcx, rax
  000a2	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_basename
  000a8	41 b8 05 01 00
	00		 mov	 r8d, 261		; 00000105H
  000ae	48 8b d0	 mov	 rdx, rax
  000b1	48 8d 8c 24 e0
	00 00 00	 lea	 rcx, QWORD PTR filename$[rsp]
  000b9	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_strlcpy
  000bf	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG178691
  000c6	48 8d 8c 24 e0
	00 00 00	 lea	 rcx, QWORD PTR filename$[rsp]
  000ce	e8 00 00 00 00	 call	 strcmp
  000d3	85 c0		 test	 eax, eax
  000d5	75 2d		 jne	 SHORT $LN7@loc3270_qu
  000d7	b8 01 00 00 00	 mov	 eax, 1
  000dc	48 6b c0 00	 imul	 rax, rax, 0
  000e0	48 89 44 24 48	 mov	 QWORD PTR $T2[rsp], rax
  000e5	48 81 7c 24 48
	05 01 00 00	 cmp	 QWORD PTR $T2[rsp], 261	; 00000105H
  000ee	73 02		 jae	 SHORT $LN18@loc3270_qu
  000f0	eb 05		 jmp	 SHORT $LN19@loc3270_qu
$LN18@loc3270_qu:
  000f2	e8 00 00 00 00	 call	 __report_rangecheckfailure
$LN19@loc3270_qu:
  000f7	48 8b 44 24 48	 mov	 rax, QWORD PTR $T2[rsp]
  000fc	c6 84 04 e0 00
	00 00 00	 mov	 BYTE PTR filename$[rsp+rax], 0
$LN7@loc3270_qu:
  00104	eb 25		 jmp	 SHORT $LN6@loc3270_qu
$LN5@loc3270_qu:
  00106	48 8b 84 24 10
	02 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  0010e	48 05 a4 00 00
	00		 add	 rax, 164		; 000000a4H
  00114	41 b8 05 01 00
	00		 mov	 r8d, 261		; 00000105H
  0011a	48 8b d0	 mov	 rdx, rax
  0011d	48 8d 8c 24 e0
	00 00 00	 lea	 rcx, QWORD PTR filename$[rsp]
  00125	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_strlcpy
$LN6@loc3270_qu:

; 2187 : 
; 2188 :     if (dev->connected)

  0012b	48 8b 84 24 10
	02 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00133	8b 80 f8 05 00
	00		 mov	 eax, DWORD PTR [rax+1528]
  00139	c1 e8 05	 shr	 eax, 5
  0013c	83 e0 01	 and	 eax, 1
  0013f	85 c0		 test	 eax, eax
  00141	74 50		 je	 SHORT $LN8@loc3270_qu

; 2189 :     {
; 2190 :         snprintf( buffer, buflen, "%s IO[%"PRIu64"]",

  00143	48 8b 84 24 10
	02 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  0014b	8b 88 a0 06 00
	00		 mov	 ecx, DWORD PTR [rax+1696]
  00151	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_inet_ntoa
  00157	48 63 8c 24 20
	02 00 00	 movsxd	 rcx, DWORD PTR buflen$[rsp]
  0015f	48 8b 94 24 10
	02 00 00	 mov	 rdx, QWORD PTR dev$[rsp]
  00167	48 8b 92 00 06
	00 00		 mov	 rdx, QWORD PTR [rdx+1536]
  0016e	48 89 54 24 20	 mov	 QWORD PTR [rsp+32], rdx
  00173	4c 8b c8	 mov	 r9, rax
  00176	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG178694
  0017d	48 8b d1	 mov	 rdx, rcx
  00180	48 8b 8c 24 28
	02 00 00	 mov	 rcx, QWORD PTR buffer$[rsp]
  00188	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_snprintf

; 2191 :             inet_ntoa( dev->ipaddr ), dev->excps );
; 2192 :     }

  0018e	e9 fc 01 00 00	 jmp	 $LN9@loc3270_qu
$LN8@loc3270_qu:

; 2193 :     else
; 2194 :     {
; 2195 :         char  acc[64];
; 2196 : 
; 2197 :         if (dev->acc_ipaddr || dev->acc_ipmask)

  00193	48 8b 84 24 10
	02 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  0019b	83 b8 a4 06 00
	00 00		 cmp	 DWORD PTR [rax+1700], 0
  001a2	75 15		 jne	 SHORT $LN12@loc3270_qu
  001a4	48 8b 84 24 10
	02 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  001ac	83 b8 a8 06 00
	00 00		 cmp	 DWORD PTR [rax+1704], 0
  001b3	0f 84 a0 00 00
	00		 je	 $LN10@loc3270_qu
$LN12@loc3270_qu:

; 2198 :         {
; 2199 :             char  ip   [32];
; 2200 :             char  mask [32];
; 2201 :             struct in_addr  inaddr;
; 2202 : 
; 2203 :             inaddr.s_addr = dev->acc_ipaddr;

  001b9	48 8b 84 24 10
	02 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  001c1	8b 80 a4 06 00
	00		 mov	 eax, DWORD PTR [rax+1700]
  001c7	89 44 24 40	 mov	 DWORD PTR inaddr$1[rsp], eax

; 2204 :             MSGBUF( ip, "%s", inet_ntoa( inaddr ));

  001cb	8b 4c 24 40	 mov	 ecx, DWORD PTR inaddr$1[rsp]
  001cf	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_inet_ntoa
  001d5	4c 8b c8	 mov	 r9, rax
  001d8	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG178698
  001df	ba 20 00 00 00	 mov	 edx, 32			; 00000020H
  001e4	48 8d 8c 24 c0
	00 00 00	 lea	 rcx, QWORD PTR ip$6[rsp]
  001ec	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_snprintf

; 2205 : 
; 2206 :             inaddr.s_addr = dev->acc_ipmask;

  001f2	48 8b 84 24 10
	02 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  001fa	8b 80 a8 06 00
	00		 mov	 eax, DWORD PTR [rax+1704]
  00200	89 44 24 40	 mov	 DWORD PTR inaddr$1[rsp], eax

; 2207 :             MSGBUF( mask, "%s", inet_ntoa( inaddr ));

  00204	8b 4c 24 40	 mov	 ecx, DWORD PTR inaddr$1[rsp]
  00208	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_inet_ntoa
  0020e	4c 8b c8	 mov	 r9, rax
  00211	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG178699
  00218	ba 20 00 00 00	 mov	 edx, 32			; 00000020H
  0021d	48 8d 8c 24 a0
	00 00 00	 lea	 rcx, QWORD PTR mask$5[rsp]
  00225	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_snprintf

; 2208 : 
; 2209 :             MSGBUF( acc, "%s mask %s", ip, mask );

  0022b	48 8d 84 24 a0
	00 00 00	 lea	 rax, QWORD PTR mask$5[rsp]
  00233	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00238	4c 8d 8c 24 c0
	00 00 00	 lea	 r9, QWORD PTR ip$6[rsp]
  00240	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG178700
  00247	ba 40 00 00 00	 mov	 edx, 64			; 00000040H
  0024c	48 8d 4c 24 60	 lea	 rcx, QWORD PTR acc$4[rsp]
  00251	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_snprintf

; 2210 :         }

  00257	eb 27		 jmp	 SHORT $LN11@loc3270_qu
$LN10@loc3270_qu:

; 2211 :         else
; 2212 :             acc[0] = 0;

  00259	b8 01 00 00 00	 mov	 eax, 1
  0025e	48 6b c0 00	 imul	 rax, rax, 0
  00262	48 89 44 24 50	 mov	 QWORD PTR $T3[rsp], rax
  00267	48 83 7c 24 50
	40		 cmp	 QWORD PTR $T3[rsp], 64	; 00000040H
  0026d	73 02		 jae	 SHORT $LN20@loc3270_qu
  0026f	eb 05		 jmp	 SHORT $LN21@loc3270_qu
$LN20@loc3270_qu:
  00271	e8 00 00 00 00	 call	 __report_rangecheckfailure
$LN21@loc3270_qu:
  00276	48 8b 44 24 50	 mov	 rax, QWORD PTR $T3[rsp]
  0027b	c6 44 04 60 00	 mov	 BYTE PTR acc$4[rsp+rax], 0
$LN11@loc3270_qu:

; 2213 : 
; 2214 :         if (filename[0])

  00280	b8 01 00 00 00	 mov	 eax, 1
  00285	48 6b c0 00	 imul	 rax, rax, 0
  00289	0f be 84 04 e0
	00 00 00	 movsx	 eax, BYTE PTR filename$[rsp+rax]
  00291	85 c0		 test	 eax, eax
  00293	74 7e		 je	 SHORT $LN13@loc3270_qu

; 2215 :         {
; 2216 :             snprintf( buffer, buflen,

  00295	b8 01 00 00 00	 mov	 eax, 1
  0029a	48 6b c0 00	 imul	 rax, rax, 0
  0029e	0f be 44 04 60	 movsx	 eax, BYTE PTR acc$4[rsp+rax]
  002a3	85 c0		 test	 eax, eax
  002a5	74 0e		 je	 SHORT $LN22@loc3270_qu
  002a7	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG178703
  002ae	48 89 44 24 58	 mov	 QWORD PTR tv174[rsp], rax
  002b3	eb 0c		 jmp	 SHORT $LN23@loc3270_qu
$LN22@loc3270_qu:
  002b5	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG178704
  002bc	48 89 44 24 58	 mov	 QWORD PTR tv174[rsp], rax
$LN23@loc3270_qu:
  002c1	48 63 84 24 20
	02 00 00	 movsxd	 rax, DWORD PTR buflen$[rsp]
  002c9	48 8b 8c 24 10
	02 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  002d1	48 8b 89 00 06
	00 00		 mov	 rcx, QWORD PTR [rcx+1536]
  002d8	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  002dd	48 8d 4c 24 60	 lea	 rcx, QWORD PTR acc$4[rsp]
  002e2	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  002e7	48 8b 4c 24 58	 mov	 rcx, QWORD PTR tv174[rsp]
  002ec	48 89 4c 24 20	 mov	 QWORD PTR [rsp+32], rcx
  002f1	4c 8d 8c 24 e0
	00 00 00	 lea	 r9, QWORD PTR filename$[rsp]
  002f9	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG178705
  00300	48 8b d0	 mov	 rdx, rax
  00303	48 8b 8c 24 28
	02 00 00	 mov	 rcx, QWORD PTR buffer$[rsp]
  0030b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_snprintf

; 2217 :                 "GROUP=%s%s%s IO[%"PRIu64"]",
; 2218 :                 filename, acc[0] ? " " : "", acc, dev->excps );
; 2219 :         }

  00311	eb 7c		 jmp	 SHORT $LN14@loc3270_qu
$LN13@loc3270_qu:

; 2220 :         else
; 2221 :         {
; 2222 :             if (acc[0])

  00313	b8 01 00 00 00	 mov	 eax, 1
  00318	48 6b c0 00	 imul	 rax, rax, 0
  0031c	0f be 44 04 60	 movsx	 eax, BYTE PTR acc$4[rsp+rax]
  00321	85 c0		 test	 eax, eax
  00323	74 3b		 je	 SHORT $LN15@loc3270_qu

; 2223 :             {
; 2224 :                 snprintf( buffer, buflen,

  00325	48 63 84 24 20
	02 00 00	 movsxd	 rax, DWORD PTR buflen$[rsp]
  0032d	48 8b 8c 24 10
	02 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  00335	48 8b 89 00 06
	00 00		 mov	 rcx, QWORD PTR [rcx+1536]
  0033c	48 89 4c 24 20	 mov	 QWORD PTR [rsp+32], rcx
  00341	4c 8d 4c 24 60	 lea	 r9, QWORD PTR acc$4[rsp]
  00346	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG178708
  0034d	48 8b d0	 mov	 rdx, rax
  00350	48 8b 8c 24 28
	02 00 00	 mov	 rcx, QWORD PTR buffer$[rsp]
  00358	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_snprintf

; 2225 :                     "* %s IO[%"PRIu64"]", acc, dev->excps );
; 2226 :             }

  0035e	eb 2f		 jmp	 SHORT $LN16@loc3270_qu
$LN15@loc3270_qu:

; 2227 :             else
; 2228 :             {
; 2229 :                 snprintf( buffer, buflen,

  00360	48 63 84 24 20
	02 00 00	 movsxd	 rax, DWORD PTR buflen$[rsp]
  00368	48 8b 8c 24 10
	02 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  00370	4c 8b 89 00 06
	00 00		 mov	 r9, QWORD PTR [rcx+1536]
  00377	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG178709
  0037e	48 8b d0	 mov	 rdx, rax
  00381	48 8b 8c 24 28
	02 00 00	 mov	 rcx, QWORD PTR buffer$[rsp]
  00389	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_snprintf
$LN16@loc3270_qu:
$LN14@loc3270_qu:
$LN9@loc3270_qu:
$LN1@loc3270_qu:
$LN17@loc3270_qu:

; 2230 :                     "* IO[%"PRIu64"]", dev->excps );
; 2231 :             }
; 2232 :         }
; 2233 :     }
; 2234 : 
; 2235 : } /* end function loc3270_query_device */

  0038f	48 8b 8c 24 f0
	01 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  00397	48 33 cc	 xor	 rcx, rsp
  0039a	e8 00 00 00 00	 call	 __security_check_cookie
  0039f	48 81 c4 08 02
	00 00		 add	 rsp, 520		; 00000208H
  003a6	c3		 ret	 0
loc3270_query_device ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\console.c
_TEXT	SEGMENT
inaddr$1 = 64
tv186 = 68
$T2 = 72
tv133 = 80
$T3 = 88
tv180 = 96
tv188 = 104
acc$4 = 112
mask$5 = 176
ip$6 = 208
filename$ = 240
__$ArrayPad$ = 512
dev$ = 544
devclass$ = 552
buflen$ = 560
buffer$ = 568
constty_query_device PROC

; 2098 : {

  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	48 81 ec 18 02
	00 00		 sub	 rsp, 536		; 00000218H
  0001b	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00022	48 33 c4	 xor	 rax, rsp
  00025	48 89 84 24 00
	02 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 2099 :     char  filename[ PATH_MAX + 1 ];     /* full path or just name    */
; 2100 : 
; 2101 :     BEGIN_DEVICE_CLASS_QUERY( "CON", dev, devclass, buflen, buffer );

  0002d	48 83 bc 24 28
	02 00 00 00	 cmp	 QWORD PTR devclass$[rsp], 0
  00036	74 12		 je	 SHORT $LN2@constty_qu
  00038	48 8b 84 24 28
	02 00 00	 mov	 rax, QWORD PTR devclass$[rsp]
  00040	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG178632
  00047	48 89 08	 mov	 QWORD PTR [rax], rcx
$LN2@constty_qu:
  0004a	48 83 bc 24 20
	02 00 00 00	 cmp	 QWORD PTR dev$[rsp], 0
  00053	74 20		 je	 SHORT $LN4@constty_qu
  00055	48 83 bc 24 28
	02 00 00 00	 cmp	 QWORD PTR devclass$[rsp], 0
  0005e	74 15		 je	 SHORT $LN4@constty_qu
  00060	83 bc 24 30 02
	00 00 00	 cmp	 DWORD PTR buflen$[rsp], 0
  00068	74 0b		 je	 SHORT $LN4@constty_qu
  0006a	48 83 bc 24 38
	02 00 00 00	 cmp	 QWORD PTR buffer$[rsp], 0
  00073	75 05		 jne	 SHORT $LN3@constty_qu
$LN4@constty_qu:
  00075	e9 39 04 00 00	 jmp	 $LN1@constty_qu
$LN3@constty_qu:
  0007a	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00081	8b 80 94 12 00
	00		 mov	 eax, DWORD PTR [rax+4756]
  00087	c1 e8 1a	 shr	 eax, 26
  0008a	83 e0 01	 and	 eax, 1
  0008d	85 c0		 test	 eax, eax
  0008f	74 75		 je	 SHORT $LN5@constty_qu
  00091	48 8b 84 24 20
	02 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00099	48 05 a4 00 00
	00		 add	 rax, 164		; 000000a4H
  0009f	48 8b c8	 mov	 rcx, rax
  000a2	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_basename
  000a8	41 b8 05 01 00
	00		 mov	 r8d, 261		; 00000105H
  000ae	48 8b d0	 mov	 rdx, rax
  000b1	48 8d 8c 24 f0
	00 00 00	 lea	 rcx, QWORD PTR filename$[rsp]
  000b9	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_strlcpy
  000bf	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG178638
  000c6	48 8d 8c 24 f0
	00 00 00	 lea	 rcx, QWORD PTR filename$[rsp]
  000ce	e8 00 00 00 00	 call	 strcmp
  000d3	85 c0		 test	 eax, eax
  000d5	75 2d		 jne	 SHORT $LN7@constty_qu
  000d7	b8 01 00 00 00	 mov	 eax, 1
  000dc	48 6b c0 00	 imul	 rax, rax, 0
  000e0	48 89 44 24 48	 mov	 QWORD PTR $T2[rsp], rax
  000e5	48 81 7c 24 48
	05 01 00 00	 cmp	 QWORD PTR $T2[rsp], 261	; 00000105H
  000ee	73 02		 jae	 SHORT $LN22@constty_qu
  000f0	eb 05		 jmp	 SHORT $LN23@constty_qu
$LN22@constty_qu:
  000f2	e8 00 00 00 00	 call	 __report_rangecheckfailure
$LN23@constty_qu:
  000f7	48 8b 44 24 48	 mov	 rax, QWORD PTR $T2[rsp]
  000fc	c6 84 04 f0 00
	00 00 00	 mov	 BYTE PTR filename$[rsp+rax], 0
$LN7@constty_qu:
  00104	eb 25		 jmp	 SHORT $LN6@constty_qu
$LN5@constty_qu:
  00106	48 8b 84 24 20
	02 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  0010e	48 05 a4 00 00
	00		 add	 rax, 164		; 000000a4H
  00114	41 b8 05 01 00
	00		 mov	 r8d, 261		; 00000105H
  0011a	48 8b d0	 mov	 rdx, rax
  0011d	48 8d 8c 24 f0
	00 00 00	 lea	 rcx, QWORD PTR filename$[rsp]
  00125	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_strlcpy
$LN6@constty_qu:

; 2102 : 
; 2103 :     if (dev->connected)

  0012b	48 8b 84 24 20
	02 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00133	8b 80 f8 05 00
	00		 mov	 eax, DWORD PTR [rax+1528]
  00139	c1 e8 05	 shr	 eax, 5
  0013c	83 e0 01	 and	 eax, 1
  0013f	85 c0		 test	 eax, eax
  00141	0f 84 8c 00 00
	00		 je	 $LN8@constty_qu

; 2104 :     {
; 2105 :         snprintf( buffer, buflen,

  00147	48 8b 84 24 20
	02 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  0014f	8b 80 d4 06 00
	00		 mov	 eax, DWORD PTR [rax+1748]
  00155	c1 e8 02	 shr	 eax, 2
  00158	83 e0 01	 and	 eax, 1
  0015b	85 c0		 test	 eax, eax
  0015d	74 0e		 je	 SHORT $LN24@constty_qu
  0015f	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG178641
  00166	48 89 44 24 50	 mov	 QWORD PTR tv133[rsp], rax
  0016b	eb 0c		 jmp	 SHORT $LN25@constty_qu
$LN24@constty_qu:
  0016d	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG178642
  00174	48 89 44 24 50	 mov	 QWORD PTR tv133[rsp], rax
$LN25@constty_qu:
  00179	48 8b 84 24 20
	02 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00181	8b 88 a0 06 00
	00		 mov	 ecx, DWORD PTR [rax+1696]
  00187	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_inet_ntoa
  0018d	48 63 8c 24 30
	02 00 00	 movsxd	 rcx, DWORD PTR buflen$[rsp]
  00195	48 8b 94 24 20
	02 00 00	 mov	 rdx, QWORD PTR dev$[rsp]
  0019d	48 8b 92 00 06
	00 00		 mov	 rdx, QWORD PTR [rdx+1536]
  001a4	48 89 54 24 28	 mov	 QWORD PTR [rsp+40], rdx
  001a9	48 8b 54 24 50	 mov	 rdx, QWORD PTR tv133[rsp]
  001ae	48 89 54 24 20	 mov	 QWORD PTR [rsp+32], rdx
  001b3	4c 8b c8	 mov	 r9, rax
  001b6	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG178643
  001bd	48 8b d1	 mov	 rdx, rcx
  001c0	48 8b 8c 24 38
	02 00 00	 mov	 rcx, QWORD PTR buffer$[rsp]
  001c8	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_snprintf

; 2106 : 
; 2107 :             "%s%s IO[%"PRIu64"]",
; 2108 : 
; 2109 :             inet_ntoa(dev->ipaddr),
; 2110 :             dev->prompt1052 ? "" : " noprompt",
; 2111 :             dev->excps );
; 2112 :     }

  001ce	e9 e0 02 00 00	 jmp	 $LN9@constty_qu
$LN8@constty_qu:

; 2113 :     else
; 2114 :     {
; 2115 :         char  acc[64];
; 2116 : 
; 2117 :         if (dev->acc_ipaddr || dev->acc_ipmask)

  001d3	48 8b 84 24 20
	02 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  001db	83 b8 a4 06 00
	00 00		 cmp	 DWORD PTR [rax+1700], 0
  001e2	75 15		 jne	 SHORT $LN12@constty_qu
  001e4	48 8b 84 24 20
	02 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  001ec	83 b8 a8 06 00
	00 00		 cmp	 DWORD PTR [rax+1704], 0
  001f3	0f 84 a0 00 00
	00		 je	 $LN10@constty_qu
$LN12@constty_qu:

; 2118 :         {
; 2119 :             char  ip   [32];
; 2120 :             char  mask [32];
; 2121 :             struct in_addr  inaddr;
; 2122 : 
; 2123 :             inaddr.s_addr = dev->acc_ipaddr;

  001f9	48 8b 84 24 20
	02 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00201	8b 80 a4 06 00
	00		 mov	 eax, DWORD PTR [rax+1700]
  00207	89 44 24 40	 mov	 DWORD PTR inaddr$1[rsp], eax

; 2124 :             MSGBUF( ip, "%s", inet_ntoa( inaddr ));

  0020b	8b 4c 24 40	 mov	 ecx, DWORD PTR inaddr$1[rsp]
  0020f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_inet_ntoa
  00215	4c 8b c8	 mov	 r9, rax
  00218	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG178647
  0021f	ba 20 00 00 00	 mov	 edx, 32			; 00000020H
  00224	48 8d 8c 24 d0
	00 00 00	 lea	 rcx, QWORD PTR ip$6[rsp]
  0022c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_snprintf

; 2125 : 
; 2126 :             inaddr.s_addr = dev->acc_ipmask;

  00232	48 8b 84 24 20
	02 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  0023a	8b 80 a8 06 00
	00		 mov	 eax, DWORD PTR [rax+1704]
  00240	89 44 24 40	 mov	 DWORD PTR inaddr$1[rsp], eax

; 2127 :             MSGBUF( mask, "%s", inet_ntoa( inaddr ));

  00244	8b 4c 24 40	 mov	 ecx, DWORD PTR inaddr$1[rsp]
  00248	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_inet_ntoa
  0024e	4c 8b c8	 mov	 r9, rax
  00251	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG178648
  00258	ba 20 00 00 00	 mov	 edx, 32			; 00000020H
  0025d	48 8d 8c 24 b0
	00 00 00	 lea	 rcx, QWORD PTR mask$5[rsp]
  00265	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_snprintf

; 2128 : 
; 2129 :             MSGBUF( acc, "%s mask %s", ip, mask );

  0026b	48 8d 84 24 b0
	00 00 00	 lea	 rax, QWORD PTR mask$5[rsp]
  00273	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00278	4c 8d 8c 24 d0
	00 00 00	 lea	 r9, QWORD PTR ip$6[rsp]
  00280	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG178649
  00287	ba 40 00 00 00	 mov	 edx, 64			; 00000040H
  0028c	48 8d 4c 24 70	 lea	 rcx, QWORD PTR acc$4[rsp]
  00291	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_snprintf

; 2130 :         }

  00297	eb 27		 jmp	 SHORT $LN11@constty_qu
$LN10@constty_qu:

; 2131 :         else
; 2132 :             acc[0] = 0;

  00299	b8 01 00 00 00	 mov	 eax, 1
  0029e	48 6b c0 00	 imul	 rax, rax, 0
  002a2	48 89 44 24 58	 mov	 QWORD PTR $T3[rsp], rax
  002a7	48 83 7c 24 58
	40		 cmp	 QWORD PTR $T3[rsp], 64	; 00000040H
  002ad	73 02		 jae	 SHORT $LN26@constty_qu
  002af	eb 05		 jmp	 SHORT $LN27@constty_qu
$LN26@constty_qu:
  002b1	e8 00 00 00 00	 call	 __report_rangecheckfailure
$LN27@constty_qu:
  002b6	48 8b 44 24 58	 mov	 rax, QWORD PTR $T3[rsp]
  002bb	c6 44 04 70 00	 mov	 BYTE PTR acc$4[rsp+rax], 0
$LN11@constty_qu:

; 2133 : 
; 2134 :         if (filename[0])

  002c0	b8 01 00 00 00	 mov	 eax, 1
  002c5	48 6b c0 00	 imul	 rax, rax, 0
  002c9	0f be 84 04 f0
	00 00 00	 movsx	 eax, BYTE PTR filename$[rsp+rax]
  002d1	85 c0		 test	 eax, eax
  002d3	0f 84 d6 00 00
	00		 je	 $LN13@constty_qu

; 2135 :         {
; 2136 :             snprintf( buffer, buflen,

  002d9	b8 01 00 00 00	 mov	 eax, 1
  002de	48 6b c0 00	 imul	 rax, rax, 0
  002e2	0f be 44 04 70	 movsx	 eax, BYTE PTR acc$4[rsp+rax]
  002e7	85 c0		 test	 eax, eax
  002e9	74 0e		 je	 SHORT $LN28@constty_qu
  002eb	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG178652
  002f2	48 89 44 24 60	 mov	 QWORD PTR tv180[rsp], rax
  002f7	eb 0c		 jmp	 SHORT $LN29@constty_qu
$LN28@constty_qu:
  002f9	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG178653
  00300	48 89 44 24 60	 mov	 QWORD PTR tv180[rsp], rax
$LN29@constty_qu:
  00305	48 8b 84 24 20
	02 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  0030d	8b 80 d4 06 00
	00		 mov	 eax, DWORD PTR [rax+1748]
  00313	c1 e8 02	 shr	 eax, 2
  00316	83 e0 01	 and	 eax, 1
  00319	85 c0		 test	 eax, eax
  0031b	75 0a		 jne	 SHORT $LN30@constty_qu
  0031d	c7 44 24 44 01
	00 00 00	 mov	 DWORD PTR tv186[rsp], 1
  00325	eb 08		 jmp	 SHORT $LN31@constty_qu
$LN30@constty_qu:
  00327	c7 44 24 44 00
	00 00 00	 mov	 DWORD PTR tv186[rsp], 0
$LN31@constty_qu:
  0032f	83 7c 24 44 00	 cmp	 DWORD PTR tv186[rsp], 0
  00334	74 0e		 je	 SHORT $LN32@constty_qu
  00336	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG178654
  0033d	48 89 44 24 68	 mov	 QWORD PTR tv188[rsp], rax
  00342	eb 0c		 jmp	 SHORT $LN33@constty_qu
$LN32@constty_qu:
  00344	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG178655
  0034b	48 89 44 24 68	 mov	 QWORD PTR tv188[rsp], rax
$LN33@constty_qu:
  00350	48 63 84 24 30
	02 00 00	 movsxd	 rax, DWORD PTR buflen$[rsp]
  00358	48 8b 8c 24 20
	02 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  00360	48 8b 89 00 06
	00 00		 mov	 rcx, QWORD PTR [rcx+1536]
  00367	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  0036c	48 8d 4c 24 70	 lea	 rcx, QWORD PTR acc$4[rsp]
  00371	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  00376	48 8b 4c 24 60	 mov	 rcx, QWORD PTR tv180[rsp]
  0037b	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00380	48 8b 4c 24 68	 mov	 rcx, QWORD PTR tv188[rsp]
  00385	48 89 4c 24 20	 mov	 QWORD PTR [rsp+32], rcx
  0038a	4c 8d 8c 24 f0
	00 00 00	 lea	 r9, QWORD PTR filename$[rsp]
  00392	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG178656
  00399	48 8b d0	 mov	 rdx, rax
  0039c	48 8b 8c 24 38
	02 00 00	 mov	 rcx, QWORD PTR buffer$[rsp]
  003a4	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_snprintf

; 2137 : 
; 2138 :                 "GROUP=%s%s%s%s IO[%"PRIu64"]",
; 2139 : 
; 2140 :                 filename,
; 2141 :                 !dev->prompt1052 ? " noprompt" : "",
; 2142 :                 acc[0] ? " " : "", acc,
; 2143 :                 dev->excps );
; 2144 :         }

  003aa	e9 04 01 00 00	 jmp	 $LN14@constty_qu
$LN13@constty_qu:

; 2145 :         else
; 2146 :         {
; 2147 :             if (acc[0])

  003af	b8 01 00 00 00	 mov	 eax, 1
  003b4	48 6b c0 00	 imul	 rax, rax, 0
  003b8	0f be 44 04 70	 movsx	 eax, BYTE PTR acc$4[rsp+rax]
  003bd	85 c0		 test	 eax, eax
  003bf	74 7a		 je	 SHORT $LN15@constty_qu

; 2148 :             {
; 2149 :                 if (!dev->prompt1052)

  003c1	48 8b 84 24 20
	02 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  003c9	8b 80 d4 06 00
	00		 mov	 eax, DWORD PTR [rax+1748]
  003cf	c1 e8 02	 shr	 eax, 2
  003d2	83 e0 01	 and	 eax, 1
  003d5	85 c0		 test	 eax, eax
  003d7	75 3b		 jne	 SHORT $LN17@constty_qu

; 2150 :                     snprintf( buffer, buflen,

  003d9	48 63 84 24 30
	02 00 00	 movsxd	 rax, DWORD PTR buflen$[rsp]
  003e1	48 8b 8c 24 20
	02 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  003e9	48 8b 89 00 06
	00 00		 mov	 rcx, QWORD PTR [rcx+1536]
  003f0	48 89 4c 24 20	 mov	 QWORD PTR [rsp+32], rcx
  003f5	4c 8d 4c 24 70	 lea	 r9, QWORD PTR acc$4[rsp]
  003fa	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG178661
  00401	48 8b d0	 mov	 rdx, rax
  00404	48 8b 8c 24 38
	02 00 00	 mov	 rcx, QWORD PTR buffer$[rsp]
  0040c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_snprintf
  00412	eb 25		 jmp	 SHORT $LN18@constty_qu
$LN17@constty_qu:

; 2151 : 
; 2152 :                         "noprompt %s IO[%"PRIu64"]",
; 2153 : 
; 2154 :                         acc, dev->excps );
; 2155 :                 else
; 2156 :                     snprintf( buffer, buflen, "* %s", acc );

  00414	48 63 84 24 30
	02 00 00	 movsxd	 rax, DWORD PTR buflen$[rsp]
  0041c	4c 8d 4c 24 70	 lea	 r9, QWORD PTR acc$4[rsp]
  00421	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG178662
  00428	48 8b d0	 mov	 rdx, rax
  0042b	48 8b 8c 24 38
	02 00 00	 mov	 rcx, QWORD PTR buffer$[rsp]
  00433	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_snprintf
$LN18@constty_qu:

; 2157 :             }

  00439	eb 78		 jmp	 SHORT $LN16@constty_qu
$LN15@constty_qu:

; 2158 :             else
; 2159 :             {
; 2160 :                 if (!dev->prompt1052)

  0043b	48 8b 84 24 20
	02 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00443	8b 80 d4 06 00
	00		 mov	 eax, DWORD PTR [rax+1748]
  00449	c1 e8 02	 shr	 eax, 2
  0044c	83 e0 01	 and	 eax, 1
  0044f	85 c0		 test	 eax, eax
  00451	75 31		 jne	 SHORT $LN19@constty_qu

; 2161 :                     snprintf( buffer, buflen,

  00453	48 63 84 24 30
	02 00 00	 movsxd	 rax, DWORD PTR buflen$[rsp]
  0045b	48 8b 8c 24 20
	02 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  00463	4c 8b 89 00 06
	00 00		 mov	 r9, QWORD PTR [rcx+1536]
  0046a	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG178665
  00471	48 8b d0	 mov	 rdx, rax
  00474	48 8b 8c 24 38
	02 00 00	 mov	 rcx, QWORD PTR buffer$[rsp]
  0047c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_snprintf
  00482	eb 2f		 jmp	 SHORT $LN20@constty_qu
$LN19@constty_qu:

; 2162 : 
; 2163 :                         "noprompt IO[%"PRIu64"]",
; 2164 : 
; 2165 :                         dev->excps );
; 2166 :                 else
; 2167 :                     snprintf( buffer, buflen,

  00484	48 63 84 24 30
	02 00 00	 movsxd	 rax, DWORD PTR buflen$[rsp]
  0048c	48 8b 8c 24 20
	02 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  00494	4c 8b 89 00 06
	00 00		 mov	 r9, QWORD PTR [rcx+1536]
  0049b	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG178666
  004a2	48 8b d0	 mov	 rdx, rax
  004a5	48 8b 8c 24 38
	02 00 00	 mov	 rcx, QWORD PTR buffer$[rsp]
  004ad	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_snprintf
$LN20@constty_qu:
$LN16@constty_qu:
$LN14@constty_qu:
$LN9@constty_qu:
$LN1@constty_qu:
$LN21@constty_qu:

; 2168 : 
; 2169 :                         "IO[%"PRIu64"]",
; 2170 : 
; 2171 :                         dev->excps );
; 2172 :             }
; 2173 :         }
; 2174 :     }
; 2175 : 
; 2176 : } /* end function constty_query_device */

  004b3	48 8b 8c 24 00
	02 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  004bb	48 33 cc	 xor	 rcx, rsp
  004be	e8 00 00 00 00	 call	 __security_check_cookie
  004c3	48 81 c4 18 02
	00 00		 add	 rsp, 536		; 00000218H
  004ca	c3		 ret	 0
constty_query_device ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\console.c
_TEXT	SEGMENT
len$ = 96
rbuf$ = 104
tv143 = 112
tv149 = 116
tv202 = 120
rbuflen$ = 128
k$1 = 136
l$2 = 140
tv72 = 144
key$ = 152
pos$ = 160
ewa3270$ = 168
tv131 = 176
buf$3 = 184
buf$ = 224
__$ArrayPad$ = 65760
dev$ = 65808
file$ = 65816
loc3270_hresume PROC

; 2002 : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	56		 push	 rsi
  0000b	57		 push	 rdi
  0000c	b8 f8 00 01 00	 mov	 eax, 65784		; 000100f8H
  00011	e8 00 00 00 00	 call	 __chkstk
  00016	48 2b e0	 sub	 rsp, rax
  00019	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00020	48 33 c4	 xor	 rax, rsp
  00023	48 89 84 24 e0
	00 01 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 2003 :     size_t  ewa3270, key, len;
; 2004 :     size_t  rbuflen = 0, pos = 0;

  0002b	48 c7 84 24 80
	00 00 00 00 00
	00 00		 mov	 QWORD PTR rbuflen$[rsp], 0
  00037	48 c7 84 24 a0
	00 00 00 00 00
	00 00		 mov	 QWORD PTR pos$[rsp], 0

; 2005 : 
; 2006 :     BYTE*   rbuf = NULL;

  00043	48 c7 44 24 68
	00 00 00 00	 mov	 QWORD PTR rbuf$[rsp], 0
$LN4@loc3270_hr:
$LN7@loc3270_hr:

; 2007 :     BYTE    buf[ BUFLEN_3270 ];
; 2008 : 
; 2009 :     do
; 2010 :     {
; 2011 :         SR_READ_HDR( file, key, len );

  0004c	4c 8d 84 24 8c
	00 00 00	 lea	 r8, QWORD PTR l$2[rsp]
  00054	48 8d 94 24 88
	00 00 00	 lea	 rdx, QWORD PTR k$1[rsp]
  0005c	48 8b 8c 24 18
	01 01 00	 mov	 rcx, QWORD PTR file$[rsp]
  00064	e8 00 00 00 00	 call	 sr_read_hdr
  00069	85 c0		 test	 eax, eax
  0006b	74 0a		 je	 SHORT $LN22@loc3270_hr
  0006d	b8 ff ff ff ff	 mov	 eax, -1
  00072	e9 00 05 00 00	 jmp	 $LN1@loc3270_hr
$LN22@loc3270_hr:
  00077	8b 84 24 88 00
	00 00		 mov	 eax, DWORD PTR k$1[rsp]
  0007e	48 89 84 24 98
	00 00 00	 mov	 QWORD PTR key$[rsp], rax
  00086	8b 84 24 8c 00
	00 00		 mov	 eax, DWORD PTR l$2[rsp]
  0008d	48 89 44 24 60	 mov	 QWORD PTR len$[rsp], rax
  00092	33 c0		 xor	 eax, eax
  00094	85 c0		 test	 eax, eax
  00096	75 b4		 jne	 SHORT $LN7@loc3270_hr

; 2012 : 
; 2013 :         switch (key)

  00098	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR key$[rsp]
  000a0	48 89 84 24 90
	00 00 00	 mov	 QWORD PTR tv72[rsp], rax
  000a8	b8 01 40 e3 ac	 mov	 eax, -1394393087	; ace34001H
  000ad	48 39 84 24 90
	00 00 00	 cmp	 QWORD PTR tv72[rsp], rax
  000b5	0f 84 c2 00 00
	00		 je	 $LN27@loc3270_hr
  000bb	b8 02 40 e3 ac	 mov	 eax, -1394393086	; ace34002H
  000c0	48 39 84 24 90
	00 00 00	 cmp	 QWORD PTR tv72[rsp], rax
  000c8	74 4c		 je	 SHORT $LN25@loc3270_hr
  000ca	b8 03 40 e3 ac	 mov	 eax, -1394393085	; ace34003H
  000cf	48 39 84 24 90
	00 00 00	 cmp	 QWORD PTR tv72[rsp], rax
  000d7	74 05		 je	 SHORT $LN23@loc3270_hr
  000d9	e9 f1 01 00 00	 jmp	 $LN30@loc3270_hr
$LN23@loc3270_hr:
$LN12@loc3270_hr:

; 2014 :         {
; 2015 :         case SR_DEV_3270_POS:
; 2016 : 
; 2017 :             SR_READ_VALUE( file, len, &pos, sizeof( pos ));

  000de	41 b9 08 00 00
	00		 mov	 r9d, 8
  000e4	4c 8d 84 24 a0
	00 00 00	 lea	 r8, QWORD PTR pos$[rsp]
  000ec	8b 54 24 60	 mov	 edx, DWORD PTR len$[rsp]
  000f0	48 8b 8c 24 18
	01 01 00	 mov	 rcx, QWORD PTR file$[rsp]
  000f8	e8 00 00 00 00	 call	 sr_read_value
  000fd	85 c0		 test	 eax, eax
  000ff	74 0a		 je	 SHORT $LN24@loc3270_hr
  00101	b8 ff ff ff ff	 mov	 eax, -1
  00106	e9 6c 04 00 00	 jmp	 $LN1@loc3270_hr
$LN24@loc3270_hr:
  0010b	33 c0		 xor	 eax, eax
  0010d	85 c0		 test	 eax, eax
  0010f	75 cd		 jne	 SHORT $LN12@loc3270_hr

; 2018 :             break;

  00111	e9 de 01 00 00	 jmp	 $LN8@loc3270_hr
$LN25@loc3270_hr:
$LN15@loc3270_hr:

; 2019 : 
; 2020 :         case SR_DEV_3270_EWA:
; 2021 : 
; 2022 :             SR_READ_VALUE( file, len, &ewa3270, sizeof( ewa3270 ));

  00116	41 b9 08 00 00
	00		 mov	 r9d, 8
  0011c	4c 8d 84 24 a8
	00 00 00	 lea	 r8, QWORD PTR ewa3270$[rsp]
  00124	8b 54 24 60	 mov	 edx, DWORD PTR len$[rsp]
  00128	48 8b 8c 24 18
	01 01 00	 mov	 rcx, QWORD PTR file$[rsp]
  00130	e8 00 00 00 00	 call	 sr_read_value
  00135	85 c0		 test	 eax, eax
  00137	74 0a		 je	 SHORT $LN26@loc3270_hr
  00139	b8 ff ff ff ff	 mov	 eax, -1
  0013e	e9 34 04 00 00	 jmp	 $LN1@loc3270_hr
$LN26@loc3270_hr:
  00143	33 c0		 xor	 eax, eax
  00145	85 c0		 test	 eax, eax
  00147	75 cd		 jne	 SHORT $LN15@loc3270_hr

; 2023 :             dev->ewa3270 = (u_int) ewa3270;

  00149	8b 84 24 a8 00
	00 00		 mov	 eax, DWORD PTR ewa3270$[rsp]
  00150	83 e0 01	 and	 eax, 1
  00153	d1 e0		 shl	 eax, 1
  00155	48 8b 8c 24 10
	01 01 00	 mov	 rcx, QWORD PTR dev$[rsp]
  0015d	8b 89 d4 06 00
	00		 mov	 ecx, DWORD PTR [rcx+1748]
  00163	83 e1 fd	 and	 ecx, -3			; fffffffdH
  00166	0b c8		 or	 ecx, eax
  00168	8b c1		 mov	 eax, ecx
  0016a	48 8b 8c 24 10
	01 01 00	 mov	 rcx, QWORD PTR dev$[rsp]
  00172	89 81 d4 06 00
	00		 mov	 DWORD PTR [rcx+1748], eax

; 2024 :             break;

  00178	e9 77 01 00 00	 jmp	 $LN8@loc3270_hr
$LN27@loc3270_hr:

; 2025 : 
; 2026 :         case SR_DEV_3270_BUF:
; 2027 : 
; 2028 :             rbuflen = len;

  0017d	48 8b 44 24 60	 mov	 rax, QWORD PTR len$[rsp]
  00182	48 89 84 24 80
	00 00 00	 mov	 QWORD PTR rbuflen$[rsp], rax

; 2029 :             rbuf    = malloc( len );

  0018a	48 8b 4c 24 60	 mov	 rcx, QWORD PTR len$[rsp]
  0018f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_malloc
  00195	48 89 44 24 68	 mov	 QWORD PTR rbuf$[rsp], rax

; 2030 : 
; 2031 :             if (rbuf == NULL)

  0019a	48 83 7c 24 68
	00		 cmp	 QWORD PTR rbuf$[rsp], 0
  001a0	0f 85 f9 00 00
	00		 jne	 $LN28@loc3270_hr

; 2032 :             {
; 2033 :                 char buf[40];
; 2034 :                 MSGBUF( buf, "malloc(%d)", (int) len );

  001a6	44 8b 4c 24 60	 mov	 r9d, DWORD PTR len$[rsp]
  001ab	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG178599
  001b2	ba 28 00 00 00	 mov	 edx, 40			; 00000028H
  001b7	48 8d 8c 24 b8
	00 00 00	 lea	 rcx, QWORD PTR buf$3[rsp]
  001bf	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_snprintf

; 2035 :                 // "%1d:%04X COMM: error in function %s: %s"
; 2036 :                 WRMSG( HHC01000, "E", LCSS_DEVNUM, buf,

  001c5	48 83 bc 24 10
	01 01 00 00	 cmp	 QWORD PTR dev$[rsp], 0
  001ce	74 12		 je	 SHORT $LN35@loc3270_hr
  001d0	48 8b 84 24 10
	01 01 00	 mov	 rax, QWORD PTR dev$[rsp]
  001d8	0f b7 40 48	 movzx	 eax, WORD PTR [rax+72]
  001dc	89 44 24 70	 mov	 DWORD PTR tv143[rsp], eax
  001e0	eb 08		 jmp	 SHORT $LN36@loc3270_hr
$LN35@loc3270_hr:
  001e2	c7 44 24 70 00
	00 00 00	 mov	 DWORD PTR tv143[rsp], 0
$LN36@loc3270_hr:
  001ea	48 83 bc 24 10
	01 01 00 00	 cmp	 QWORD PTR dev$[rsp], 0
  001f3	74 14		 je	 SHORT $LN37@loc3270_hr
  001f5	48 8b 84 24 10
	01 01 00	 mov	 rax, QWORD PTR dev$[rsp]
  001fd	0f b7 40 44	 movzx	 eax, WORD PTR [rax+68]
  00201	d1 f8		 sar	 eax, 1
  00203	89 44 24 74	 mov	 DWORD PTR tv149[rsp], eax
  00207	eb 08		 jmp	 SHORT $LN38@loc3270_hr
$LN37@loc3270_hr:
  00209	c7 44 24 74 00
	00 00 00	 mov	 DWORD PTR tv149[rsp], 0
$LN38@loc3270_hr:
  00211	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno
  00217	8b 08		 mov	 ecx, DWORD PTR [rax]
  00219	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_strerror
  0021f	48 89 84 24 b0
	00 00 00	 mov	 QWORD PTR tv131[rsp], rax
  00227	b9 01 00 00 00	 mov	 ecx, 1
  0022c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  00232	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR tv131[rsp]
  0023a	48 89 4c 24 50	 mov	 QWORD PTR [rsp+80], rcx
  0023f	48 8d 8c 24 b8
	00 00 00	 lea	 rcx, QWORD PTR buf$3[rsp]
  00247	48 89 4c 24 48	 mov	 QWORD PTR [rsp+72], rcx
  0024c	8b 4c 24 70	 mov	 ecx, DWORD PTR tv143[rsp]
  00250	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  00254	8b 4c 24 74	 mov	 ecx, DWORD PTR tv149[rsp]
  00258	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  0025c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG178600
  00263	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  00268	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG178601
  0026f	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00274	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00279	41 b9 03 00 00
	00		 mov	 r9d, 3
  0027f	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG178602
  00286	ba f5 07 00 00	 mov	 edx, 2037		; 000007f5H
  0028b	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG178603
  00292	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 2037 :                       strerror( errno ));
; 2038 :                 return 0;

  00298	33 c0		 xor	 eax, eax
  0029a	e9 d8 02 00 00	 jmp	 $LN1@loc3270_hr
$LN28@loc3270_hr:
$LN18@loc3270_hr:

; 2039 :             }
; 2040 : 
; 2041 :             SR_READ_BUF( file, rbuf, rbuflen );

  0029f	4c 8b 84 24 80
	00 00 00	 mov	 r8, QWORD PTR rbuflen$[rsp]
  002a7	48 8b 54 24 68	 mov	 rdx, QWORD PTR rbuf$[rsp]
  002ac	48 8b 8c 24 18
	01 01 00	 mov	 rcx, QWORD PTR file$[rsp]
  002b4	e8 00 00 00 00	 call	 sr_read_buf
  002b9	85 c0		 test	 eax, eax
  002bb	74 0a		 je	 SHORT $LN29@loc3270_hr
  002bd	b8 ff ff ff ff	 mov	 eax, -1
  002c2	e9 b0 02 00 00	 jmp	 $LN1@loc3270_hr
$LN29@loc3270_hr:
  002c7	33 c0		 xor	 eax, eax
  002c9	85 c0		 test	 eax, eax
  002cb	75 d2		 jne	 SHORT $LN18@loc3270_hr

; 2042 :             break;

  002cd	eb 25		 jmp	 SHORT $LN8@loc3270_hr
$LN30@loc3270_hr:
$LN21@loc3270_hr:

; 2043 : 
; 2044 :         default:
; 2045 : 
; 2046 :             SR_READ_SKIP( file, len );

  002cf	8b 54 24 60	 mov	 edx, DWORD PTR len$[rsp]
  002d3	48 8b 8c 24 18
	01 01 00	 mov	 rcx, QWORD PTR file$[rsp]
  002db	e8 00 00 00 00	 call	 sr_read_skip
  002e0	85 c0		 test	 eax, eax
  002e2	74 0a		 je	 SHORT $LN31@loc3270_hr
  002e4	b8 ff ff ff ff	 mov	 eax, -1
  002e9	e9 89 02 00 00	 jmp	 $LN1@loc3270_hr
$LN31@loc3270_hr:
  002ee	33 c0		 xor	 eax, eax
  002f0	85 c0		 test	 eax, eax
  002f2	75 db		 jne	 SHORT $LN21@loc3270_hr
$LN8@loc3270_hr:

; 2047 :             break;
; 2048 :         }
; 2049 :     }
; 2050 :     while ((key & SR_DEV_MASK) == SR_DEV_3270);

  002f4	b8 00 f0 ff ff	 mov	 eax, -4096		; fffff000H
  002f9	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR key$[rsp]
  00301	48 23 c8	 and	 rcx, rax
  00304	48 8b c1	 mov	 rax, rcx
  00307	b9 00 40 e3 ac	 mov	 ecx, -1394393088	; ace34000H
  0030c	48 3b c1	 cmp	 rax, rcx
  0030f	0f 84 37 fd ff
	ff		 je	 $LN4@loc3270_hr

; 2051 : 
; 2052 :     /* Dequeue any I/O interrupts for this device */
; 2053 :     DEQUEUE_IO_INTERRUPT( &dev->ioint );

  00315	48 8b 84 24 10
	01 01 00	 mov	 rax, QWORD PTR dev$[rsp]
  0031d	48 05 28 02 00
	00		 add	 rax, 552		; 00000228H
  00323	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG178607
  0032a	48 8b c8	 mov	 rcx, rax
  0032d	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_Dequeue_IO_Interrupt

; 2054 :     DEQUEUE_IO_INTERRUPT( &dev->pciioint );

  00333	48 8b 84 24 10
	01 01 00	 mov	 rax, QWORD PTR dev$[rsp]
  0033b	48 05 40 02 00
	00		 add	 rax, 576		; 00000240H
  00341	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG178608
  00348	48 8b c8	 mov	 rcx, rax
  0034b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_Dequeue_IO_Interrupt

; 2055 :     DEQUEUE_IO_INTERRUPT( &dev->attnioint );

  00351	48 8b 84 24 10
	01 01 00	 mov	 rax, QWORD PTR dev$[rsp]
  00359	48 05 58 02 00
	00		 add	 rax, 600		; 00000258H
  0035f	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG178609
  00366	48 8b c8	 mov	 rcx, rax
  00369	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_Dequeue_IO_Interrupt

; 2056 : 
; 2057 :     /* Restore the 3270 screen image if connected and buf was provided */
; 2058 :     if (1
; 2059 :         && dev->connected
; 2060 :         && rbuf
; 2061 :         && rbuflen > 3

  0036f	33 c0		 xor	 eax, eax
  00371	83 f8 01	 cmp	 eax, 1
  00374	0f 84 e8 01 00
	00		 je	 $LN32@loc3270_hr
  0037a	48 8b 84 24 10
	01 01 00	 mov	 rax, QWORD PTR dev$[rsp]
  00382	8b 80 f8 05 00
	00		 mov	 eax, DWORD PTR [rax+1528]
  00388	c1 e8 05	 shr	 eax, 5
  0038b	83 e0 01	 and	 eax, 1
  0038e	85 c0		 test	 eax, eax
  00390	0f 84 cc 01 00
	00		 je	 $LN32@loc3270_hr
  00396	48 83 7c 24 68
	00		 cmp	 QWORD PTR rbuf$[rsp], 0
  0039c	0f 84 c0 01 00
	00		 je	 $LN32@loc3270_hr
  003a2	48 83 bc 24 80
	00 00 00 03	 cmp	 QWORD PTR rbuflen$[rsp], 3
  003ab	0f 86 b1 01 00
	00		 jbe	 $LN32@loc3270_hr

; 2062 :     )
; 2063 :     {
; 2064 :         obtain_lock( &dev->lock );

  003b1	48 8b 84 24 10
	01 01 00	 mov	 rax, QWORD PTR dev$[rsp]
  003b9	48 83 c0 38	 add	 rax, 56			; 00000038H
  003bd	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG178611
  003c4	48 8b c8	 mov	 rcx, rax
  003c7	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_obtain_lock

; 2065 : 
; 2066 :         /* Construct buffer to send to the 3270 */
; 2067 :         len = 0;

  003cd	48 c7 44 24 60
	00 00 00 00	 mov	 QWORD PTR len$[rsp], 0

; 2068 :         buf[len++] = dev->ewa3270 ? R3270_EWA : R3270_EW;

  003d6	48 8b 84 24 10
	01 01 00	 mov	 rax, QWORD PTR dev$[rsp]
  003de	8b 80 d4 06 00
	00		 mov	 eax, DWORD PTR [rax+1748]
  003e4	d1 e8		 shr	 eax, 1
  003e6	83 e0 01	 and	 eax, 1
  003e9	85 c0		 test	 eax, eax
  003eb	74 0a		 je	 SHORT $LN39@loc3270_hr
  003ed	c7 44 24 78 7e
	00 00 00	 mov	 DWORD PTR tv202[rsp], 126 ; 0000007eH
  003f5	eb 08		 jmp	 SHORT $LN40@loc3270_hr
$LN39@loc3270_hr:
  003f7	c7 44 24 78 f5
	00 00 00	 mov	 DWORD PTR tv202[rsp], 245 ; 000000f5H
$LN40@loc3270_hr:
  003ff	48 8b 44 24 60	 mov	 rax, QWORD PTR len$[rsp]
  00404	0f b6 4c 24 78	 movzx	 ecx, BYTE PTR tv202[rsp]
  00409	88 8c 04 e0 00
	00 00		 mov	 BYTE PTR buf$[rsp+rax], cl
  00410	48 8b 44 24 60	 mov	 rax, QWORD PTR len$[rsp]
  00415	48 ff c0	 inc	 rax
  00418	48 89 44 24 60	 mov	 QWORD PTR len$[rsp], rax

; 2069 :         buf[len++] = 0xC2;

  0041d	48 8b 44 24 60	 mov	 rax, QWORD PTR len$[rsp]
  00422	c6 84 04 e0 00
	00 00 c2	 mov	 BYTE PTR buf$[rsp+rax], 194 ; 000000c2H
  0042a	48 8b 44 24 60	 mov	 rax, QWORD PTR len$[rsp]
  0042f	48 ff c0	 inc	 rax
  00432	48 89 44 24 60	 mov	 QWORD PTR len$[rsp], rax

; 2070 : 
; 2071 :         memcpy( &buf[len], &rbuf[3], rbuflen - 3 );

  00437	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR rbuflen$[rsp]
  0043f	48 83 e8 03	 sub	 rax, 3
  00443	b9 01 00 00 00	 mov	 ecx, 1
  00448	48 6b c9 03	 imul	 rcx, rcx, 3
  0044c	48 8b 54 24 68	 mov	 rdx, QWORD PTR rbuf$[rsp]
  00451	48 03 d1	 add	 rdx, rcx
  00454	48 8b ca	 mov	 rcx, rdx
  00457	48 8b 54 24 60	 mov	 rdx, QWORD PTR len$[rsp]
  0045c	48 8d 94 14 e0
	00 00 00	 lea	 rdx, QWORD PTR buf$[rsp+rdx]
  00464	48 8b fa	 mov	 rdi, rdx
  00467	48 8b f1	 mov	 rsi, rcx
  0046a	48 8b c8	 mov	 rcx, rax
  0046d	f3 a4		 rep movsb

; 2072 :         len += rbuflen - 3;

  0046f	48 8b 44 24 60	 mov	 rax, QWORD PTR len$[rsp]
  00474	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR rbuflen$[rsp]
  0047c	48 8d 44 08 fd	 lea	 rax, QWORD PTR [rax+rcx-3]
  00481	48 89 44 24 60	 mov	 QWORD PTR len$[rsp], rax

; 2073 : 
; 2074 :         buf[len++] = O3270_SBA;

  00486	48 8b 44 24 60	 mov	 rax, QWORD PTR len$[rsp]
  0048b	c6 84 04 e0 00
	00 00 11	 mov	 BYTE PTR buf$[rsp+rax], 17
  00493	48 8b 44 24 60	 mov	 rax, QWORD PTR len$[rsp]
  00498	48 ff c0	 inc	 rax
  0049b	48 89 44 24 60	 mov	 QWORD PTR len$[rsp], rax

; 2075 :         buf[len++] = rbuf[1];

  004a0	b8 01 00 00 00	 mov	 eax, 1
  004a5	48 6b c0 01	 imul	 rax, rax, 1
  004a9	48 8b 4c 24 60	 mov	 rcx, QWORD PTR len$[rsp]
  004ae	48 8b 54 24 68	 mov	 rdx, QWORD PTR rbuf$[rsp]
  004b3	0f b6 04 02	 movzx	 eax, BYTE PTR [rdx+rax]
  004b7	88 84 0c e0 00
	00 00		 mov	 BYTE PTR buf$[rsp+rcx], al
  004be	48 8b 44 24 60	 mov	 rax, QWORD PTR len$[rsp]
  004c3	48 ff c0	 inc	 rax
  004c6	48 89 44 24 60	 mov	 QWORD PTR len$[rsp], rax

; 2076 :         buf[len++] = rbuf[2];

  004cb	b8 01 00 00 00	 mov	 eax, 1
  004d0	48 6b c0 02	 imul	 rax, rax, 2
  004d4	48 8b 4c 24 60	 mov	 rcx, QWORD PTR len$[rsp]
  004d9	48 8b 54 24 68	 mov	 rdx, QWORD PTR rbuf$[rsp]
  004de	0f b6 04 02	 movzx	 eax, BYTE PTR [rdx+rax]
  004e2	88 84 0c e0 00
	00 00		 mov	 BYTE PTR buf$[rsp+rcx], al
  004e9	48 8b 44 24 60	 mov	 rax, QWORD PTR len$[rsp]
  004ee	48 ff c0	 inc	 rax
  004f1	48 89 44 24 60	 mov	 QWORD PTR len$[rsp], rax

; 2077 :         buf[len++] = O3270_IC;

  004f6	48 8b 44 24 60	 mov	 rax, QWORD PTR len$[rsp]
  004fb	c6 84 04 e0 00
	00 00 13	 mov	 BYTE PTR buf$[rsp+rax], 19
  00503	48 8b 44 24 60	 mov	 rax, QWORD PTR len$[rsp]
  00508	48 ff c0	 inc	 rax
  0050b	48 89 44 24 60	 mov	 QWORD PTR len$[rsp], rax

; 2078 : 
; 2079 :         /* Restore the 3270 screen */
; 2080 :         sendto_client( dev->tn, buf, len );

  00510	44 8b 44 24 60	 mov	 r8d, DWORD PTR len$[rsp]
  00515	48 8d 94 24 e0
	00 00 00	 lea	 rdx, QWORD PTR buf$[rsp]
  0051d	48 8b 84 24 10
	01 01 00	 mov	 rax, QWORD PTR dev$[rsp]
  00525	48 8b 88 b0 06
	00 00		 mov	 rcx, QWORD PTR [rax+1712]
  0052c	e8 00 00 00 00	 call	 sendto_client

; 2081 :         dev->pos3270 = (int) pos;

  00531	48 8b 84 24 10
	01 01 00	 mov	 rax, QWORD PTR dev$[rsp]
  00539	8b 8c 24 a0 00
	00 00		 mov	 ecx, DWORD PTR pos$[rsp]
  00540	89 88 bc 06 00
	00		 mov	 DWORD PTR [rax+1724], ecx

; 2082 : 
; 2083 :         release_lock( &dev->lock );

  00546	48 8b 84 24 10
	01 01 00	 mov	 rax, QWORD PTR dev$[rsp]
  0054e	48 83 c0 38	 add	 rax, 56			; 00000038H
  00552	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG178612
  00559	48 8b c8	 mov	 rcx, rax
  0055c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_release_lock
$LN32@loc3270_hr:

; 2084 :     }
; 2085 : 
; 2086 :     if (rbuf)

  00562	48 83 7c 24 68
	00		 cmp	 QWORD PTR rbuf$[rsp], 0
  00568	74 0b		 je	 SHORT $LN33@loc3270_hr

; 2087 :         free( rbuf );

  0056a	48 8b 4c 24 68	 mov	 rcx, QWORD PTR rbuf$[rsp]
  0056f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free
$LN33@loc3270_hr:

; 2088 : 
; 2089 :     return 0;

  00575	33 c0		 xor	 eax, eax
$LN1@loc3270_hr:

; 2090 : 
; 2091 : } /* end function loc3270_hresume */

  00577	48 8b 8c 24 e0
	00 01 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  0057f	48 33 cc	 xor	 rcx, rsp
  00582	e8 00 00 00 00	 call	 __security_check_cookie
  00587	48 81 c4 f8 00
	01 00		 add	 rsp, 65784		; 000100f8H
  0058e	5f		 pop	 rdi
  0058f	5e		 pop	 rsi
  00590	c3		 ret	 0
loc3270_hresume ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\console.c
_TEXT	SEGMENT
len$ = 32
rc$ = 40
buf$ = 48
__$ArrayPad$ = 65584
dev$ = 65632
file$ = 65640
loc3270_hsuspend PROC

; 1964 : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	56		 push	 rsi
  0000b	57		 push	 rdi
  0000c	b8 48 00 01 00	 mov	 eax, 65608		; 00010048H
  00011	e8 00 00 00 00	 call	 __chkstk
  00016	48 2b e0	 sub	 rsp, rax
  00019	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00020	48 33 c4	 xor	 rax, rsp
  00023	48 89 84 24 30
	00 01 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 1965 :     size_t  rc, len;
; 1966 :     BYTE    buf[ BUFLEN_3270 ];
; 1967 : 
; 1968 :     if (!dev->connected)

  0002b	48 8b 84 24 60
	00 01 00	 mov	 rax, QWORD PTR dev$[rsp]
  00033	8b 80 f8 05 00
	00		 mov	 eax, DWORD PTR [rax+1528]
  00039	c1 e8 05	 shr	 eax, 5
  0003c	83 e0 01	 and	 eax, 1
  0003f	85 c0		 test	 eax, eax
  00041	75 07		 jne	 SHORT $LN11@loc3270_hs

; 1969 :         return 0;

  00043	33 c0		 xor	 eax, eax
  00045	e9 7d 01 00 00	 jmp	 $LN1@loc3270_hs
$LN11@loc3270_hs:
$LN4@loc3270_hs:

; 1970 : 
; 1971 :     SR_WRITE_VALUE( file, SR_DEV_3270_POS, dev->pos3270, sizeof( dev->pos3270 ));

  0004a	48 8b 84 24 60
	00 01 00	 mov	 rax, QWORD PTR dev$[rsp]
  00052	48 63 80 bc 06
	00 00		 movsxd	 rax, DWORD PTR [rax+1724]
  00059	41 b9 04 00 00
	00		 mov	 r9d, 4
  0005f	4c 8b c0	 mov	 r8, rax
  00062	ba 03 40 e3 ac	 mov	 edx, -1394393085	; ace34003H
  00067	48 8b 8c 24 68
	00 01 00	 mov	 rcx, QWORD PTR file$[rsp]
  0006f	e8 00 00 00 00	 call	 sr_write_value
  00074	85 c0		 test	 eax, eax
  00076	74 0a		 je	 SHORT $LN12@loc3270_hs
  00078	b8 ff ff ff ff	 mov	 eax, -1
  0007d	e9 45 01 00 00	 jmp	 $LN1@loc3270_hs
$LN12@loc3270_hs:
  00082	33 c0		 xor	 eax, eax
  00084	85 c0		 test	 eax, eax
  00086	75 c2		 jne	 SHORT $LN4@loc3270_hs
$LN7@loc3270_hs:

; 1972 :     SR_WRITE_VALUE( file, SR_DEV_3270_EWA, dev->ewa3270, 1);

  00088	48 8b 84 24 60
	00 01 00	 mov	 rax, QWORD PTR dev$[rsp]
  00090	8b 80 d4 06 00
	00		 mov	 eax, DWORD PTR [rax+1748]
  00096	d1 e8		 shr	 eax, 1
  00098	83 e0 01	 and	 eax, 1
  0009b	8b c0		 mov	 eax, eax
  0009d	41 b9 01 00 00
	00		 mov	 r9d, 1
  000a3	44 8b c0	 mov	 r8d, eax
  000a6	ba 02 40 e3 ac	 mov	 edx, -1394393086	; ace34002H
  000ab	48 8b 8c 24 68
	00 01 00	 mov	 rcx, QWORD PTR file$[rsp]
  000b3	e8 00 00 00 00	 call	 sr_write_value
  000b8	85 c0		 test	 eax, eax
  000ba	74 0a		 je	 SHORT $LN13@loc3270_hs
  000bc	b8 ff ff ff ff	 mov	 eax, -1
  000c1	e9 01 01 00 00	 jmp	 $LN1@loc3270_hs
$LN13@loc3270_hs:
  000c6	33 c0		 xor	 eax, eax
  000c8	85 c0		 test	 eax, eax
  000ca	75 bc		 jne	 SHORT $LN7@loc3270_hs

; 1973 : 
; 1974 :     obtain_lock( &dev->lock );

  000cc	48 8b 84 24 60
	00 01 00	 mov	 rax, QWORD PTR dev$[rsp]
  000d4	48 83 c0 38	 add	 rax, 56			; 00000038H
  000d8	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG178524
  000df	48 8b c8	 mov	 rcx, rax
  000e2	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_obtain_lock

; 1975 : 
; 1976 :     rc = solicit_3270_data( dev, R3270_RB );

  000e8	b2 f2		 mov	 dl, 242			; 000000f2H
  000ea	48 8b 8c 24 60
	00 01 00	 mov	 rcx, QWORD PTR dev$[rsp]
  000f2	e8 00 00 00 00	 call	 solicit_3270_data
  000f7	0f b6 c0	 movzx	 eax, al
  000fa	48 89 44 24 28	 mov	 QWORD PTR rc$[rsp], rax

; 1977 : 
; 1978 :     if (1
; 1979 :         && rc == 0
; 1980 :         && dev->rlen3270 > 0
; 1981 :         && dev->rlen3270 <= sizeof( buf )

  000ff	33 c0		 xor	 eax, eax
  00101	83 f8 01	 cmp	 eax, 1
  00104	74 62		 je	 SHORT $LN14@loc3270_hs
  00106	48 83 7c 24 28
	00		 cmp	 QWORD PTR rc$[rsp], 0
  0010c	75 5a		 jne	 SHORT $LN14@loc3270_hs
  0010e	48 8b 84 24 60
	00 01 00	 mov	 rax, QWORD PTR dev$[rsp]
  00116	83 b8 b8 06 00
	00 00		 cmp	 DWORD PTR [rax+1720], 0
  0011d	76 49		 jbe	 SHORT $LN14@loc3270_hs
  0011f	48 8b 84 24 60
	00 01 00	 mov	 rax, QWORD PTR dev$[rsp]
  00127	8b 80 b8 06 00
	00		 mov	 eax, DWORD PTR [rax+1720]
  0012d	48 3d 00 00 01
	00		 cmp	 rax, 65536		; 00010000H
  00133	77 33		 ja	 SHORT $LN14@loc3270_hs

; 1982 :     )
; 1983 :     {
; 1984 :         len = dev->rlen3270;

  00135	48 8b 84 24 60
	00 01 00	 mov	 rax, QWORD PTR dev$[rsp]
  0013d	8b 80 b8 06 00
	00		 mov	 eax, DWORD PTR [rax+1720]
  00143	48 89 44 24 20	 mov	 QWORD PTR len$[rsp], rax

; 1985 :         memcpy( buf, dev->buf, len );

  00148	48 8d 44 24 30	 lea	 rax, QWORD PTR buf$[rsp]
  0014d	48 8b 8c 24 60
	00 01 00	 mov	 rcx, QWORD PTR dev$[rsp]
  00155	48 8b f8	 mov	 rdi, rax
  00158	48 8b b1 c8 01
	00 00		 mov	 rsi, QWORD PTR [rcx+456]
  0015f	48 8b 4c 24 20	 mov	 rcx, QWORD PTR len$[rsp]
  00164	f3 a4		 rep movsb

; 1986 :     }

  00166	eb 09		 jmp	 SHORT $LN15@loc3270_hs
$LN14@loc3270_hs:

; 1987 :     else
; 1988 :         len = 0;

  00168	48 c7 44 24 20
	00 00 00 00	 mov	 QWORD PTR len$[rsp], 0
$LN15@loc3270_hs:

; 1989 : 
; 1990 :     release_lock( &dev->lock );

  00171	48 8b 84 24 60
	00 01 00	 mov	 rax, QWORD PTR dev$[rsp]
  00179	48 83 c0 38	 add	 rax, 56			; 00000038H
  0017d	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG178527
  00184	48 8b c8	 mov	 rcx, rax
  00187	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_release_lock

; 1991 : 
; 1992 :     if (len)

  0018d	48 83 7c 24 20
	00		 cmp	 QWORD PTR len$[rsp], 0
  00193	74 30		 je	 SHORT $LN16@loc3270_hs
$LN10@loc3270_hs:

; 1993 :         SR_WRITE_BUF( file, SR_DEV_3270_BUF, buf, (int) len );

  00195	48 63 44 24 20	 movsxd	 rax, DWORD PTR len$[rsp]
  0019a	4c 8b c8	 mov	 r9, rax
  0019d	4c 8d 44 24 30	 lea	 r8, QWORD PTR buf$[rsp]
  001a2	ba 01 40 e3 ac	 mov	 edx, -1394393087	; ace34001H
  001a7	48 8b 8c 24 68
	00 01 00	 mov	 rcx, QWORD PTR file$[rsp]
  001af	e8 00 00 00 00	 call	 sr_write_buf
  001b4	85 c0		 test	 eax, eax
  001b6	74 07		 je	 SHORT $LN17@loc3270_hs
  001b8	b8 ff ff ff ff	 mov	 eax, -1
  001bd	eb 08		 jmp	 SHORT $LN1@loc3270_hs
$LN17@loc3270_hs:
  001bf	33 c0		 xor	 eax, eax
  001c1	85 c0		 test	 eax, eax
  001c3	75 d0		 jne	 SHORT $LN10@loc3270_hs
$LN16@loc3270_hs:

; 1994 : 
; 1995 :     return 0;

  001c5	33 c0		 xor	 eax, eax
$LN1@loc3270_hs:

; 1996 : }

  001c7	48 8b 8c 24 30
	00 01 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  001cf	48 33 cc	 xor	 rcx, rsp
  001d2	e8 00 00 00 00	 call	 __security_check_cookie
  001d7	48 81 c4 48 00
	01 00		 add	 rsp, 65608		; 00010048H
  001de	5f		 pop	 rdi
  001df	5e		 pop	 rsi
  001e0	c3		 ret	 0
loc3270_hsuspend ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\console.c
_TEXT	SEGMENT
dev$ = 48
loc3270_halt_or_clear PROC

; 1949 : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 1950 :     loc3270_redrive_pselect( dev );

  00009	48 8b 4c 24 30	 mov	 rcx, QWORD PTR dev$[rsp]
  0000e	e8 00 00 00 00	 call	 loc3270_redrive_pselect

; 1951 : }

  00013	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00017	c3		 ret	 0
loc3270_halt_or_clear ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\console.c
_TEXT	SEGMENT
dev$ = 48
constty_halt_or_clear PROC

; 1945 : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 1946 :     constty_redrive_pselect( dev );

  00009	48 8b 4c 24 30	 mov	 rcx, QWORD PTR dev$[rsp]
  0000e	e8 00 00 00 00	 call	 constty_redrive_pselect

; 1947 : }

  00013	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00017	c3		 ret	 0
constty_halt_or_clear ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\console.c
_TEXT	SEGMENT
c$1 = 32
f$2 = 36
saved_errno$3 = 40
dev$ = 64
loc3270_redrive_pselect PROC

; 1935 : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 1936 :     dev->readpending = 0;

  00009	48 8b 44 24 40	 mov	 rax, QWORD PTR dev$[rsp]
  0000e	8b 80 f8 05 00
	00		 mov	 eax, DWORD PTR [rax+1528]
  00014	25 3f ff ff ff	 and	 eax, -193		; ffffff3fH
  00019	48 8b 4c 24 40	 mov	 rcx, QWORD PTR dev$[rsp]
  0001e	89 81 f8 05 00
	00		 mov	 DWORD PTR [rcx+1528], eax

; 1937 :     dev->rlen3270    = 0;

  00024	48 8b 44 24 40	 mov	 rax, QWORD PTR dev$[rsp]
  00029	c7 80 b8 06 00
	00 00 00 00 00	 mov	 DWORD PTR [rax+1720], 0
$LN4@loc3270_re:

; 1938 :     SIGNAL_CONSOLE_THREAD();

  00033	c6 44 24 20 00	 mov	 BYTE PTR c$1[rsp], 0
  00038	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_WSAGetLastError
  0003e	89 44 24 28	 mov	 DWORD PTR saved_errno$3[rsp], eax
  00042	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00049	48 05 c0 10 00
	00		 add	 rax, 4288		; 000010c0H
  0004f	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG178469
  00056	48 8b c8	 mov	 rcx, rax
  00059	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_obtain_lock
  0005f	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00066	8b 80 c8 10 00
	00		 mov	 eax, DWORD PTR [rax+4296]
  0006c	89 44 24 24	 mov	 DWORD PTR f$2[rsp], eax
  00070	83 7c 24 24 00	 cmp	 DWORD PTR f$2[rsp], 0
  00075	7f 11		 jg	 SHORT $LN11@loc3270_re
  00077	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  0007e	c7 80 c8 10 00
	00 01 00 00 00	 mov	 DWORD PTR [rax+4296], 1
$LN11@loc3270_re:
  00088	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  0008f	48 05 c0 10 00
	00		 add	 rax, 4288		; 000010c0H
  00095	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG178471
  0009c	48 8b c8	 mov	 rcx, rax
  0009f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_release_lock
  000a5	83 7c 24 24 00	 cmp	 DWORD PTR f$2[rsp], 0
  000aa	0f 8f 90 00 00
	00		 jg	 $LN12@loc3270_re
$LN7@loc3270_re:
  000b0	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  000b7	48 63 80 cc 10
	00 00		 movsxd	 rax, DWORD PTR [rax+4300]
  000be	45 33 c9	 xor	 r9d, r9d
  000c1	41 b8 01 00 00
	00		 mov	 r8d, 1
  000c7	48 8d 54 24 20	 lea	 rdx, QWORD PTR c$1[rsp]
  000cc	48 8b c8	 mov	 rcx, rax
  000cf	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_send
  000d5	83 f8 01	 cmp	 eax, 1
  000d8	74 5c		 je	 SHORT $LN13@loc3270_re
$LN10@loc3270_re:
  000da	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG178474
  000e1	41 b8 92 07 00
	00		 mov	 r8d, 1938		; 00000792H
  000e7	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG178475
  000ee	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG178476
  000f5	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_logmsg
  000fb	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_IsDebuggerPresent
  00101	85 c0		 test	 eax, eax
  00103	74 20		 je	 SHORT $LN14@loc3270_re
  00105	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG178478
  0010c	41 b8 92 07 00
	00		 mov	 r8d, 1938		; 00000792H
  00112	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG178479
  00119	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG178480
  00120	e8 00 00 00 00	 call	 DebuggerTrace
$LN14@loc3270_re:
  00125	33 c0		 xor	 eax, eax
  00127	85 c0		 test	 eax, eax
  00129	75 af		 jne	 SHORT $LN10@loc3270_re
  0012b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_IsDebuggerPresent
  00131	85 c0		 test	 eax, eax
  00133	74 01		 je	 SHORT $LN15@loc3270_re
  00135	cc		 int	 3
$LN15@loc3270_re:
$LN13@loc3270_re:
  00136	33 c0		 xor	 eax, eax
  00138	85 c0		 test	 eax, eax
  0013a	0f 85 70 ff ff
	ff		 jne	 $LN7@loc3270_re
$LN12@loc3270_re:
  00140	8b 4c 24 28	 mov	 ecx, DWORD PTR saved_errno$3[rsp]
  00144	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_WSASetLastError
  0014a	33 c0		 xor	 eax, eax
  0014c	85 c0		 test	 eax, eax
  0014e	0f 85 df fe ff
	ff		 jne	 $LN4@loc3270_re

; 1939 : }

  00154	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00158	c3		 ret	 0
loc3270_redrive_pselect ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\console.c
_TEXT	SEGMENT
c$1 = 32
f$2 = 36
saved_errno$3 = 40
dev$ = 64
constty_redrive_pselect PROC

; 1930 : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 38	 sub	 rsp, 56			; 00000038H
$LN4@constty_re:

; 1931 :     UNREFERENCED( dev );

  00009	33 c0		 xor	 eax, eax
  0000b	85 c0		 test	 eax, eax
  0000d	75 fa		 jne	 SHORT $LN4@constty_re
$LN7@constty_re:

; 1932 :     SIGNAL_CONSOLE_THREAD();

  0000f	c6 44 24 20 00	 mov	 BYTE PTR c$1[rsp], 0
  00014	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_WSAGetLastError
  0001a	89 44 24 28	 mov	 DWORD PTR saved_errno$3[rsp], eax
  0001e	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00025	48 05 c0 10 00
	00		 add	 rax, 4288		; 000010c0H
  0002b	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG178438
  00032	48 8b c8	 mov	 rcx, rax
  00035	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_obtain_lock
  0003b	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00042	8b 80 c8 10 00
	00		 mov	 eax, DWORD PTR [rax+4296]
  00048	89 44 24 24	 mov	 DWORD PTR f$2[rsp], eax
  0004c	83 7c 24 24 00	 cmp	 DWORD PTR f$2[rsp], 0
  00051	7f 11		 jg	 SHORT $LN14@constty_re
  00053	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  0005a	c7 80 c8 10 00
	00 01 00 00 00	 mov	 DWORD PTR [rax+4296], 1
$LN14@constty_re:
  00064	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  0006b	48 05 c0 10 00
	00		 add	 rax, 4288		; 000010c0H
  00071	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG178440
  00078	48 8b c8	 mov	 rcx, rax
  0007b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_release_lock
  00081	83 7c 24 24 00	 cmp	 DWORD PTR f$2[rsp], 0
  00086	0f 8f 90 00 00
	00		 jg	 $LN15@constty_re
$LN10@constty_re:
  0008c	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00093	48 63 80 cc 10
	00 00		 movsxd	 rax, DWORD PTR [rax+4300]
  0009a	45 33 c9	 xor	 r9d, r9d
  0009d	41 b8 01 00 00
	00		 mov	 r8d, 1
  000a3	48 8d 54 24 20	 lea	 rdx, QWORD PTR c$1[rsp]
  000a8	48 8b c8	 mov	 rcx, rax
  000ab	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_send
  000b1	83 f8 01	 cmp	 eax, 1
  000b4	74 5c		 je	 SHORT $LN16@constty_re
$LN13@constty_re:
  000b6	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG178443
  000bd	41 b8 8c 07 00
	00		 mov	 r8d, 1932		; 0000078cH
  000c3	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG178444
  000ca	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG178445
  000d1	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_logmsg
  000d7	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_IsDebuggerPresent
  000dd	85 c0		 test	 eax, eax
  000df	74 20		 je	 SHORT $LN17@constty_re
  000e1	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG178447
  000e8	41 b8 8c 07 00
	00		 mov	 r8d, 1932		; 0000078cH
  000ee	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG178448
  000f5	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG178449
  000fc	e8 00 00 00 00	 call	 DebuggerTrace
$LN17@constty_re:
  00101	33 c0		 xor	 eax, eax
  00103	85 c0		 test	 eax, eax
  00105	75 af		 jne	 SHORT $LN13@constty_re
  00107	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_IsDebuggerPresent
  0010d	85 c0		 test	 eax, eax
  0010f	74 01		 je	 SHORT $LN18@constty_re
  00111	cc		 int	 3
$LN18@constty_re:
$LN16@constty_re:
  00112	33 c0		 xor	 eax, eax
  00114	85 c0		 test	 eax, eax
  00116	0f 85 70 ff ff
	ff		 jne	 $LN10@constty_re
$LN15@constty_re:
  0011c	8b 4c 24 28	 mov	 ecx, DWORD PTR saved_errno$3[rsp]
  00120	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_WSASetLastError
  00126	33 c0		 xor	 eax, eax
  00128	85 c0		 test	 eax, eax
  0012a	0f 85 df fe ff
	ff		 jne	 $LN7@constty_re

; 1933 : }

  00130	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00134	c3		 ret	 0
constty_redrive_pselect ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\console.c
_TEXT	SEGMENT
rc$ = 48
p$ = 56
fn$ = 64
altfn$1 = 336
pathname$2 = 608
__$ArrayPad$ = 880
init_logo PROC

; 1893 : {

  00000	40 57		 push	 rdi
  00002	48 81 ec 80 03
	00 00		 sub	 rsp, 896		; 00000380H
  00009	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00010	48 33 c4	 xor	 rax, rsp
  00013	48 89 84 24 70
	03 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 1894 :     const char*  p; /* pointer to logo filename */
; 1895 :     int          rc = 0;

  0001b	c7 44 24 30 00
	00 00 00	 mov	 DWORD PTR rc$[rsp], 0

; 1896 :     char         fn[FILENAME_MAX] = {0};

  00023	48 8d 44 24 40	 lea	 rax, QWORD PTR fn$[rsp]
  00028	48 8b f8	 mov	 rdi, rax
  0002b	33 c0		 xor	 eax, eax
  0002d	b9 04 01 00 00	 mov	 ecx, 260		; 00000104H
  00032	f3 aa		 rep stosb

; 1897 : 
; 1898 :     if (sysblk.logofile == NULL) /* LogoFile NOT passed in command line */

  00034	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  0003b	48 83 b8 00 14
	00 00 00	 cmp	 QWORD PTR [rax+5120], 0
  00043	75 34		 jne	 SHORT $LN2@init_logo

; 1899 :     {
; 1900 :         if (!(p = get_symbol("HERCLOGO")) || !*p)

  00045	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG178413
  0004c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_get_symbol
  00052	48 89 44 24 38	 mov	 QWORD PTR p$[rsp], rax
  00057	48 83 7c 24 38
	00		 cmp	 QWORD PTR p$[rsp], 0
  0005d	74 0c		 je	 SHORT $LN5@init_logo
  0005f	48 8b 44 24 38	 mov	 rax, QWORD PTR p$[rsp]
  00064	0f be 00	 movsx	 eax, BYTE PTR [rax]
  00067	85 c0		 test	 eax, eax
  00069	75 0c		 jne	 SHORT $LN4@init_logo
$LN5@init_logo:

; 1901 :             p = "herclogo.txt";

  0006b	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG178414
  00072	48 89 44 24 38	 mov	 QWORD PTR p$[rsp], rax
$LN4@init_logo:

; 1902 :     }

  00077	eb 13		 jmp	 SHORT $LN3@init_logo
$LN2@init_logo:

; 1903 :     else
; 1904 :         p = sysblk.logofile;

  00079	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00080	48 8b 80 00 14
	00 00		 mov	 rax, QWORD PTR [rax+5120]
  00087	48 89 44 24 38	 mov	 QWORD PTR p$[rsp], rax
$LN3@init_logo:

; 1905 : 
; 1906 :     hostpath( fn, p, sizeof(fn) );

  0008c	41 b8 04 01 00
	00		 mov	 r8d, 260		; 00000104H
  00092	48 8b 54 24 38	 mov	 rdx, QWORD PTR p$[rsp]
  00097	48 8d 4c 24 40	 lea	 rcx, QWORD PTR fn$[rsp]
  0009c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hostpath

; 1907 : 
; 1908 :     rc = readlogo(fn);

  000a2	48 8d 4c 24 40	 lea	 rcx, QWORD PTR fn$[rsp]
  000a7	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_readlogo
  000ad	89 44 24 30	 mov	 DWORD PTR rc$[rsp], eax

; 1909 : 
; 1910 :     if ( rc == -1 && strcasecmp(fn,basename(fn)) == 0
; 1911 :                && strlen(sysblk.hercules_pgmpath) > 0 )

  000b1	83 7c 24 30 ff	 cmp	 DWORD PTR rc$[rsp], -1
  000b6	0f 85 af 00 00
	00		 jne	 $LN6@init_logo
  000bc	48 8d 4c 24 40	 lea	 rcx, QWORD PTR fn$[rsp]
  000c1	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_basename
  000c7	48 8b d0	 mov	 rdx, rax
  000ca	48 8d 4c 24 40	 lea	 rcx, QWORD PTR fn$[rsp]
  000cf	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__stricmp
  000d5	85 c0		 test	 eax, eax
  000d7	0f 85 8e 00 00
	00		 jne	 $LN6@init_logo
  000dd	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  000e4	48 8b 48 38	 mov	 rcx, QWORD PTR [rax+56]
  000e8	e8 00 00 00 00	 call	 strlen
  000ed	48 85 c0	 test	 rax, rax
  000f0	76 79		 jbe	 SHORT $LN6@init_logo

; 1912 :     {
; 1913 :         char altfn[FILENAME_MAX];
; 1914 :         char pathname[MAX_PATH];
; 1915 : 
; 1916 :         memset(altfn, 0, sizeof(altfn));

  000f2	48 8d 84 24 50
	01 00 00	 lea	 rax, QWORD PTR altfn$1[rsp]
  000fa	48 8b f8	 mov	 rdi, rax
  000fd	33 c0		 xor	 eax, eax
  000ff	b9 04 01 00 00	 mov	 ecx, 260		; 00000104H
  00104	f3 aa		 rep stosb

; 1917 : 
; 1918 :         MSGBUF(altfn,"%s%c%s", sysblk.hercules_pgmpath, PATHSEPC, fn);

  00106	48 8d 44 24 40	 lea	 rax, QWORD PTR fn$[rsp]
  0010b	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  00110	c7 44 24 20 2f
	00 00 00	 mov	 DWORD PTR [rsp+32], 47	; 0000002fH
  00118	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  0011f	4c 8b 48 38	 mov	 r9, QWORD PTR [rax+56]
  00123	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG178416
  0012a	ba 04 01 00 00	 mov	 edx, 260		; 00000104H
  0012f	48 8d 8c 24 50
	01 00 00	 lea	 rcx, QWORD PTR altfn$1[rsp]
  00137	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_snprintf

; 1919 : 
; 1920 :         hostpath( pathname, altfn, sizeof(pathname));

  0013d	41 b8 04 01 00
	00		 mov	 r8d, 260		; 00000104H
  00143	48 8d 94 24 50
	01 00 00	 lea	 rdx, QWORD PTR altfn$1[rsp]
  0014b	48 8d 8c 24 60
	02 00 00	 lea	 rcx, QWORD PTR pathname$2[rsp]
  00153	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hostpath

; 1921 : 
; 1922 :         rc = readlogo(pathname);

  00159	48 8d 8c 24 60
	02 00 00	 lea	 rcx, QWORD PTR pathname$2[rsp]
  00161	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_readlogo
  00167	89 44 24 30	 mov	 DWORD PTR rc$[rsp], eax
$LN6@init_logo:

; 1923 :     }
; 1924 : }

  0016b	48 8b 8c 24 70
	03 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  00173	48 33 cc	 xor	 rcx, rsp
  00176	e8 00 00 00 00	 call	 __security_check_cookie
  0017b	48 81 c4 80 03
	00 00		 add	 rsp, 896		; 00000380H
  00182	5f		 pop	 rdi
  00183	c3		 ret	 0
init_logo ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\console.c
_TEXT	SEGMENT
col$ = 48
attr$ = 49
align$ = 50
line$ = 51
stmt$ = 56
bfr$ = 64
rest$ = 72
tv147 = 80
tv250 = 84
msg$ = 88
alen$ = 96
wrk$ = 104
len$ = 112
i$ = 120
j$ = 128
verb$ = 136
strtok_str$ = 144
stmt_len$ = 152
msgbuf$ = 160
__$ArrayPad$ = 288
logo_stmts$ = 320
num_stmts$ = 328
buflen$ = 336
errmsg$ = 344
build_logo PROC

; 1528 : {

  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	48 81 ec 38 01
	00 00		 sub	 rsp, 312		; 00000138H
  0001b	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00022	48 33 c4	 xor	 rax, rsp
  00025	48 89 84 24 20
	01 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 1529 :     char     msgbuf[ 128 ];             /* Used only if error oocurs */
; 1530 : 
; 1531 :     BYTE    *bfr        = NULL;

  0002d	48 c7 44 24 40
	00 00 00 00	 mov	 QWORD PTR bfr$[rsp], 0

; 1532 :     char    *stmt       = NULL;

  00036	48 c7 44 24 38
	00 00 00 00	 mov	 QWORD PTR stmt$[rsp], 0

; 1533 :     char    *msg        = NULL;

  0003f	48 c7 44 24 58
	00 00 00 00	 mov	 QWORD PTR msg$[rsp], 0

; 1534 :     char    *strtok_str = NULL;

  00048	48 c7 84 24 90
	00 00 00 00 00
	00 00		 mov	 QWORD PTR strtok_str$[rsp], 0

; 1535 : 
; 1536 :     char    *verb;
; 1537 :     char    *rest;
; 1538 :     char    *wrk;
; 1539 : 
; 1540 :     size_t   len = 0;

  00054	48 c7 44 24 70
	00 00 00 00	 mov	 QWORD PTR len$[rsp], 0

; 1541 :     size_t   alen = 0;

  0005d	48 c7 44 24 60
	00 00 00 00	 mov	 QWORD PTR alen$[rsp], 0

; 1542 :     size_t   stmt_len;
; 1543 :     size_t   i,j;
; 1544 : 
; 1545 :     BYTE     line, col;
; 1546 :     BYTE     attr;
; 1547 :     BYTE     align;
; 1548 : 
; 1549 :     if (errmsg)

  00066	48 83 bc 24 58
	01 00 00 00	 cmp	 QWORD PTR errmsg$[rsp], 0
  0006f	74 0f		 je	 SHORT $LN12@build_logo

; 1550 :         *errmsg = NULL;

  00071	48 8b 84 24 58
	01 00 00	 mov	 rax, QWORD PTR errmsg$[rsp]
  00079	48 c7 00 00 00
	00 00		 mov	 QWORD PTR [rax], 0
$LN12@build_logo:

; 1551 : 
; 1552 :     if (!logo_stmts)

  00080	48 83 bc 24 40
	01 00 00 00	 cmp	 QWORD PTR logo_stmts$[rsp], 0
  00089	75 1b		 jne	 SHORT $LN13@build_logo

; 1553 :     {
; 1554 :         logo_stmts = herclogo; /* use built-in default */

  0008b	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:herclogo
  00092	48 89 84 24 40
	01 00 00	 mov	 QWORD PTR logo_stmts$[rsp], rax

; 1555 :         num_stmts = sizeof( herclogo ) / sizeof( char* );

  0009a	48 c7 84 24 48
	01 00 00 3b 00
	00 00		 mov	 QWORD PTR num_stmts$[rsp], 59 ; 0000003bH
$LN13@build_logo:

; 1556 :     }
; 1557 : 
; 1558 :     /* Allocate a working screen buffer and initialize
; 1559 :        it with an Erase/Write and Restore Keyboard WCC.
; 1560 :     */
; 1561 :     if (0
; 1562 :         || !(bfr = malloc( alen = LOGO_BUFSZ_INCR ))
; 1563 :         || !(bfr = buffer_addchar( bfr, &len, &alen, 0xf5 ))
; 1564 :         || !(bfr = buffer_addchar( bfr, &len, &alen, 0x42 ))

  000a6	33 c0		 xor	 eax, eax
  000a8	85 c0		 test	 eax, eax
  000aa	75 69		 jne	 SHORT $LN15@build_logo
  000ac	48 c7 44 24 60
	00 01 00 00	 mov	 QWORD PTR alen$[rsp], 256 ; 00000100H
  000b5	48 8b 4c 24 60	 mov	 rcx, QWORD PTR alen$[rsp]
  000ba	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_malloc
  000c0	48 89 44 24 40	 mov	 QWORD PTR bfr$[rsp], rax
  000c5	48 83 7c 24 40
	00		 cmp	 QWORD PTR bfr$[rsp], 0
  000cb	74 48		 je	 SHORT $LN15@build_logo
  000cd	41 b1 f5	 mov	 r9b, 245		; 000000f5H
  000d0	4c 8d 44 24 60	 lea	 r8, QWORD PTR alen$[rsp]
  000d5	48 8d 54 24 70	 lea	 rdx, QWORD PTR len$[rsp]
  000da	48 8b 4c 24 40	 mov	 rcx, QWORD PTR bfr$[rsp]
  000df	e8 00 00 00 00	 call	 buffer_addchar
  000e4	48 89 44 24 40	 mov	 QWORD PTR bfr$[rsp], rax
  000e9	48 83 7c 24 40
	00		 cmp	 QWORD PTR bfr$[rsp], 0
  000ef	74 24		 je	 SHORT $LN15@build_logo
  000f1	41 b1 42	 mov	 r9b, 66			; 00000042H
  000f4	4c 8d 44 24 60	 lea	 r8, QWORD PTR alen$[rsp]
  000f9	48 8d 54 24 70	 lea	 rdx, QWORD PTR len$[rsp]
  000fe	48 8b 4c 24 40	 mov	 rcx, QWORD PTR bfr$[rsp]
  00103	e8 00 00 00 00	 call	 buffer_addchar
  00108	48 89 44 24 40	 mov	 QWORD PTR bfr$[rsp], rax
  0010d	48 83 7c 24 40
	00		 cmp	 QWORD PTR bfr$[rsp], 0
  00113	75 05		 jne	 SHORT $LN14@build_logo
$LN15@build_logo:

; 1565 :     )
; 1566 :         goto outofmem_error;

  00115	e9 31 06 00 00	 jmp	 $outofmem_error$68
$LN14@build_logo:

; 1567 : 
; 1568 :     /* Process logo statements and build screen buffer... */
; 1569 : 
; 1570 :     attr   =  SF_ATTR_PROTECTED;

  0011a	c6 44 24 31 20	 mov	 BYTE PTR attr$[rsp], 32	; 00000020H

; 1571 :     align  =  ALIGN_NONE;

  0011f	c6 44 24 32 00	 mov	 BYTE PTR align$[rsp], 0

; 1572 :     line   =  0;

  00124	c6 44 24 33 00	 mov	 BYTE PTR line$[rsp], 0

; 1573 :     col    =  0;

  00129	c6 44 24 30 00	 mov	 BYTE PTR col$[rsp], 0

; 1574 : 
; 1575 :     for (i=0, stmt = NULL, msg = NULL; bfr && i < num_stmts; i++)

  0012e	48 c7 44 24 78
	00 00 00 00	 mov	 QWORD PTR i$[rsp], 0
  00137	48 c7 44 24 38
	00 00 00 00	 mov	 QWORD PTR stmt$[rsp], 0
  00140	48 c7 44 24 58
	00 00 00 00	 mov	 QWORD PTR msg$[rsp], 0
  00149	eb 0d		 jmp	 SHORT $LN4@build_logo
$LN2@build_logo:
  0014b	48 8b 44 24 78	 mov	 rax, QWORD PTR i$[rsp]
  00150	48 ff c0	 inc	 rax
  00153	48 89 44 24 78	 mov	 QWORD PTR i$[rsp], rax
$LN4@build_logo:
  00158	48 83 7c 24 40
	00		 cmp	 QWORD PTR bfr$[rsp], 0
  0015e	0f 84 bd 05 00
	00		 je	 $LN3@build_logo
  00164	48 8b 84 24 48
	01 00 00	 mov	 rax, QWORD PTR num_stmts$[rsp]
  0016c	48 39 44 24 78	 cmp	 QWORD PTR i$[rsp], rax
  00171	0f 83 aa 05 00
	00		 jae	 $LN3@build_logo

; 1576 :     {
; 1577 :         if (stmt)

  00177	48 83 7c 24 38
	00		 cmp	 QWORD PTR stmt$[rsp], 0
  0017d	74 0b		 je	 SHORT $LN16@build_logo

; 1578 :             free( stmt );

  0017f	48 8b 4c 24 38	 mov	 rcx, QWORD PTR stmt$[rsp]
  00184	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free
$LN16@build_logo:

; 1579 : 
; 1580 :         /* Copy logo statement to dynamically allocated
; 1581 :            buffer so we can freely resolve any symbols. */
; 1582 : 
; 1583 :         stmt_len = strlen( logo_stmts[i] ) + 1;

  0018a	48 8b 84 24 40
	01 00 00	 mov	 rax, QWORD PTR logo_stmts$[rsp]
  00192	48 8b 4c 24 78	 mov	 rcx, QWORD PTR i$[rsp]
  00197	48 8b 0c c8	 mov	 rcx, QWORD PTR [rax+rcx*8]
  0019b	e8 00 00 00 00	 call	 strlen
  001a0	48 ff c0	 inc	 rax
  001a3	48 89 84 24 98
	00 00 00	 mov	 QWORD PTR stmt_len$[rsp], rax

; 1584 : 
; 1585 :         if (!(stmt = malloc( stmt_len )))

  001ab	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR stmt_len$[rsp]
  001b3	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_malloc
  001b9	48 89 44 24 38	 mov	 QWORD PTR stmt$[rsp], rax
  001be	48 83 7c 24 38
	00		 cmp	 QWORD PTR stmt$[rsp], 0
  001c4	75 05		 jne	 SHORT $LN17@build_logo

; 1586 :             goto outofmem_error;

  001c6	e9 80 05 00 00	 jmp	 $outofmem_error$68
$LN17@build_logo:

; 1587 : 
; 1588 :         strlcpy( stmt, logo_stmts[i], stmt_len );

  001cb	4c 8b 84 24 98
	00 00 00	 mov	 r8, QWORD PTR stmt_len$[rsp]
  001d3	48 8b 84 24 40
	01 00 00	 mov	 rax, QWORD PTR logo_stmts$[rsp]
  001db	48 8b 4c 24 78	 mov	 rcx, QWORD PTR i$[rsp]
  001e0	48 8b 14 c8	 mov	 rdx, QWORD PTR [rax+rcx*8]
  001e4	48 8b 4c 24 38	 mov	 rcx, QWORD PTR stmt$[rsp]
  001e9	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_strlcpy

; 1589 : 
; 1590 :         wrk = resolve_symbol_string( stmt );

  001ef	48 8b 4c 24 38	 mov	 rcx, QWORD PTR stmt$[rsp]
  001f4	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_resolve_symbol_string
  001fa	48 89 44 24 68	 mov	 QWORD PTR wrk$[rsp], rax

; 1591 :         if (wrk)

  001ff	48 83 7c 24 68
	00		 cmp	 QWORD PTR wrk$[rsp], 0
  00205	74 15		 je	 SHORT $LN18@build_logo

; 1592 :         {
; 1593 :             free( stmt );

  00207	48 8b 4c 24 38	 mov	 rcx, QWORD PTR stmt$[rsp]
  0020c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free

; 1594 :             stmt = wrk;

  00212	48 8b 44 24 68	 mov	 rax, QWORD PTR wrk$[rsp]
  00217	48 89 44 24 38	 mov	 QWORD PTR stmt$[rsp], rax
$LN18@build_logo:

; 1595 :         }
; 1596 : 
; 1597 :         if (stmt[0] != '@')

  0021c	b8 01 00 00 00	 mov	 eax, 1
  00221	48 6b c0 00	 imul	 rax, rax, 0
  00225	48 8b 4c 24 38	 mov	 rcx, QWORD PTR stmt$[rsp]
  0022a	0f be 04 01	 movsx	 eax, BYTE PTR [rcx+rax]
  0022e	83 f8 40	 cmp	 eax, 64			; 00000040H
  00231	0f 84 90 01 00
	00		 je	 $LN19@build_logo

; 1598 :         {
; 1599 :             /* Perform any previously requested alignment
; 1600 :                before processing this plain text string */
; 1601 : 
; 1602 :             switch (align)

  00237	0f b6 44 24 32	 movzx	 eax, BYTE PTR align$[rsp]
  0023c	88 44 24 50	 mov	 BYTE PTR tv147[rsp], al
  00240	80 7c 24 50 00	 cmp	 BYTE PTR tv147[rsp], 0
  00245	74 17		 je	 SHORT $LN20@build_logo
  00247	80 7c 24 50 01	 cmp	 BYTE PTR tv147[rsp], 1
  0024c	74 4c		 je	 SHORT $LN25@build_logo
  0024e	80 7c 24 50 02	 cmp	 BYTE PTR tv147[rsp], 2
  00253	74 0b		 je	 SHORT $LN21@build_logo
  00255	80 7c 24 50 03	 cmp	 BYTE PTR tv147[rsp], 3
  0025a	74 0b		 je	 SHORT $LN22@build_logo
  0025c	eb 6d		 jmp	 SHORT $LN27@build_logo
$LN20@build_logo:

; 1603 :             {
; 1604 :                 case ALIGN_NONE:
; 1605 :                     /* (nothing to do here) */
; 1606 :                     break;

  0025e	eb 7c		 jmp	 SHORT $LN5@build_logo
$LN21@build_logo:

; 1607 : 
; 1608 :                 case ALIGN_LEFT:
; 1609 : 
; 1610 :                     col = 0;

  00260	c6 44 24 30 00	 mov	 BYTE PTR col$[rsp], 0

; 1611 :                     break;

  00265	eb 75		 jmp	 SHORT $LN5@build_logo
$LN22@build_logo:

; 1612 : 
; 1613 :                 case ALIGN_RIGHT:
; 1614 : 
; 1615 :                     col = (int) strlen( stmt );

  00267	48 8b 4c 24 38	 mov	 rcx, QWORD PTR stmt$[rsp]
  0026c	e8 00 00 00 00	 call	 strlen
  00271	88 44 24 30	 mov	 BYTE PTR col$[rsp], al

; 1616 : 
; 1617 :                     if (col < 80)

  00275	0f b6 44 24 30	 movzx	 eax, BYTE PTR col$[rsp]
  0027a	83 f8 50	 cmp	 eax, 80			; 00000050H
  0027d	7d 14		 jge	 SHORT $LN23@build_logo

; 1618 :                         col = 80 - col;

  0027f	0f b6 44 24 30	 movzx	 eax, BYTE PTR col$[rsp]
  00284	b9 50 00 00 00	 mov	 ecx, 80			; 00000050H
  00289	2b c8		 sub	 ecx, eax
  0028b	8b c1		 mov	 eax, ecx
  0028d	88 44 24 30	 mov	 BYTE PTR col$[rsp], al
  00291	eb 05		 jmp	 SHORT $LN24@build_logo
$LN23@build_logo:

; 1619 :                     else
; 1620 :                         col = 0;

  00293	c6 44 24 30 00	 mov	 BYTE PTR col$[rsp], 0
$LN24@build_logo:

; 1621 :                     break;

  00298	eb 42		 jmp	 SHORT $LN5@build_logo
$LN25@build_logo:

; 1622 : 
; 1623 :                 case ALIGN_CENTER:
; 1624 : 
; 1625 :                     col = (int) strlen( stmt );

  0029a	48 8b 4c 24 38	 mov	 rcx, QWORD PTR stmt$[rsp]
  0029f	e8 00 00 00 00	 call	 strlen
  002a4	88 44 24 30	 mov	 BYTE PTR col$[rsp], al

; 1626 : 
; 1627 :                     if (col < 80)

  002a8	0f b6 44 24 30	 movzx	 eax, BYTE PTR col$[rsp]
  002ad	83 f8 50	 cmp	 eax, 80			; 00000050H
  002b0	7d 17		 jge	 SHORT $LN26@build_logo

; 1628 :                         col = (80 - col) / 2;

  002b2	0f b6 44 24 30	 movzx	 eax, BYTE PTR col$[rsp]
  002b7	b9 50 00 00 00	 mov	 ecx, 80			; 00000050H
  002bc	2b c8		 sub	 ecx, eax
  002be	8b c1		 mov	 eax, ecx
  002c0	99		 cdq
  002c1	2b c2		 sub	 eax, edx
  002c3	d1 f8		 sar	 eax, 1
  002c5	88 44 24 30	 mov	 BYTE PTR col$[rsp], al
$LN26@build_logo:

; 1629 :                     break;

  002c9	eb 11		 jmp	 SHORT $LN5@build_logo
$LN27@build_logo:

; 1630 : 
; 1631 :                 default:
; 1632 :                     msg = "LOGIC ERROR!";

  002cb	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG178280
  002d2	48 89 44 24 58	 mov	 QWORD PTR msg$[rsp], rax

; 1633 :                     goto error_exit;

  002d7	e9 7b 04 00 00	 jmp	 $error_exit$69
$LN5@build_logo:

; 1634 :             }
; 1635 : 
; 1636 :             /* Append a Buffer Address order for requested alignment,
; 1637 :                insert the Start Field attribute for the current field,
; 1638 :                and insert the field itself (the current statement).
; 1639 :             */
; 1640 :             if (0
; 1641 :                 || !(bfr = buffer_addsba    ( bfr, &len, &alen, line, col ))
; 1642 :                 || !(bfr = buffer_addsf     ( bfr, &len, &alen, attr ))
; 1643 :                 || !(bfr = buffer_addstring ( bfr, &len, &alen, prt_host_to_guest

  002dc	33 c0		 xor	 eax, eax
  002de	85 c0		 test	 eax, eax
  002e0	0f 85 98 00 00
	00		 jne	 $LN29@build_logo
  002e6	0f b6 44 24 30	 movzx	 eax, BYTE PTR col$[rsp]
  002eb	88 44 24 20	 mov	 BYTE PTR [rsp+32], al
  002ef	44 0f b6 4c 24
	33		 movzx	 r9d, BYTE PTR line$[rsp]
  002f5	4c 8d 44 24 60	 lea	 r8, QWORD PTR alen$[rsp]
  002fa	48 8d 54 24 70	 lea	 rdx, QWORD PTR len$[rsp]
  002ff	48 8b 4c 24 40	 mov	 rcx, QWORD PTR bfr$[rsp]
  00304	e8 00 00 00 00	 call	 buffer_addsba
  00309	48 89 44 24 40	 mov	 QWORD PTR bfr$[rsp], rax
  0030e	48 83 7c 24 40
	00		 cmp	 QWORD PTR bfr$[rsp], 0
  00314	74 68		 je	 SHORT $LN29@build_logo
  00316	44 0f b6 4c 24
	31		 movzx	 r9d, BYTE PTR attr$[rsp]
  0031c	4c 8d 44 24 60	 lea	 r8, QWORD PTR alen$[rsp]
  00321	48 8d 54 24 70	 lea	 rdx, QWORD PTR len$[rsp]
  00326	48 8b 4c 24 40	 mov	 rcx, QWORD PTR bfr$[rsp]
  0032b	e8 00 00 00 00	 call	 buffer_addsf
  00330	48 89 44 24 40	 mov	 QWORD PTR bfr$[rsp], rax
  00335	48 83 7c 24 40
	00		 cmp	 QWORD PTR bfr$[rsp], 0
  0033b	74 41		 je	 SHORT $LN29@build_logo
  0033d	48 8b 4c 24 38	 mov	 rcx, QWORD PTR stmt$[rsp]
  00342	e8 00 00 00 00	 call	 strlen
  00347	44 8b c0	 mov	 r8d, eax
  0034a	48 8b 54 24 38	 mov	 rdx, QWORD PTR stmt$[rsp]
  0034f	48 8b 4c 24 38	 mov	 rcx, QWORD PTR stmt$[rsp]
  00354	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_prt_host_to_guest
  0035a	4c 8b c8	 mov	 r9, rax
  0035d	4c 8d 44 24 60	 lea	 r8, QWORD PTR alen$[rsp]
  00362	48 8d 54 24 70	 lea	 rdx, QWORD PTR len$[rsp]
  00367	48 8b 4c 24 40	 mov	 rcx, QWORD PTR bfr$[rsp]
  0036c	e8 00 00 00 00	 call	 buffer_addstring
  00371	48 89 44 24 40	 mov	 QWORD PTR bfr$[rsp], rax
  00376	48 83 7c 24 40
	00		 cmp	 QWORD PTR bfr$[rsp], 0
  0037c	75 05		 jne	 SHORT $LN28@build_logo
$LN29@build_logo:

; 1644 :                                              ((BYTE*) stmt, (BYTE*) stmt, strlen( stmt )) ))
; 1645 :             )
; 1646 :                 goto outofmem_error;

  0037e	e9 c8 03 00 00	 jmp	 $outofmem_error$68
$LN28@build_logo:

; 1647 : 
; 1648 :             /* Update line/col variables to match current position */
; 1649 :             if (align == ALIGN_NONE)

  00383	0f b6 44 24 32	 movzx	 eax, BYTE PTR align$[rsp]
  00388	85 c0		 test	 eax, eax
  0038a	75 26		 jne	 SHORT $LN30@build_logo

; 1650 :             {
; 1651 :                 col += strlen( stmt );

  0038c	48 8b 4c 24 38	 mov	 rcx, QWORD PTR stmt$[rsp]
  00391	e8 00 00 00 00	 call	 strlen
  00396	0f b6 4c 24 30	 movzx	 ecx, BYTE PTR col$[rsp]
  0039b	48 03 c8	 add	 rcx, rax
  0039e	48 8b c1	 mov	 rax, rcx
  003a1	88 44 24 30	 mov	 BYTE PTR col$[rsp], al

; 1652 :                 col++;

  003a5	0f b6 44 24 30	 movzx	 eax, BYTE PTR col$[rsp]
  003aa	fe c0		 inc	 al
  003ac	88 44 24 30	 mov	 BYTE PTR col$[rsp], al

; 1653 :             }

  003b0	eb 10		 jmp	 SHORT $LN31@build_logo
$LN30@build_logo:

; 1654 :             else /* (position to beginning of next line) */
; 1655 :             {
; 1656 :                 col = 0;

  003b2	c6 44 24 30 00	 mov	 BYTE PTR col$[rsp], 0

; 1657 :                 line++;

  003b7	0f b6 44 24 33	 movzx	 eax, BYTE PTR line$[rsp]
  003bc	fe c0		 inc	 al
  003be	88 44 24 33	 mov	 BYTE PTR line$[rsp], al
$LN31@build_logo:

; 1658 :             }
; 1659 : 
; 1660 :             /* Go on to next logo statement */
; 1661 :             continue;

  003c2	e9 84 fd ff ff	 jmp	 $LN2@build_logo
$LN19@build_logo:

; 1662 :         }
; 1663 : 
; 1664 :         /* Process special logo '@' order */
; 1665 : 
; 1666 :         verb = strtok_r( stmt," \t", &strtok_str );

  003c7	4c 8d 84 24 90
	00 00 00	 lea	 r8, QWORD PTR strtok_str$[rsp]
  003cf	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG178285
  003d6	48 8b 4c 24 38	 mov	 rcx, QWORD PTR stmt$[rsp]
  003db	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_strtok_r
  003e1	48 89 84 24 88
	00 00 00	 mov	 QWORD PTR verb$[rsp], rax

; 1667 :         rest = strtok_r( NULL," \t", &strtok_str );

  003e9	4c 8d 84 24 90
	00 00 00	 lea	 r8, QWORD PTR strtok_str$[rsp]
  003f1	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG178286
  003f8	33 c9		 xor	 ecx, ecx
  003fa	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_strtok_r
  00400	48 89 44 24 48	 mov	 QWORD PTR rest$[rsp], rax

; 1668 : 
; 1669 :         /* Set Buffer Address? */
; 1670 : 
; 1671 :         if (strcasecmp( verb, "@sba" ) == 0)

  00405	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG178289
  0040c	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR verb$[rsp]
  00414	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__stricmp
  0041a	85 c0		 test	 eax, eax
  0041c	0f 85 94 00 00
	00		 jne	 $LN32@build_logo

; 1672 :         {
; 1673 :             if (rest != NULL)

  00422	48 83 7c 24 48
	00		 cmp	 QWORD PTR rest$[rsp], 0
  00428	74 76		 je	 SHORT $LN34@build_logo

; 1674 :             {
; 1675 :                 /* Parse "Y,X" (line,col) values */
; 1676 : 
; 1677 :                 wrk = strtok_r( rest, ",", &strtok_str );

  0042a	4c 8d 84 24 90
	00 00 00	 lea	 r8, QWORD PTR strtok_str$[rsp]
  00432	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG178292
  00439	48 8b 4c 24 48	 mov	 rcx, QWORD PTR rest$[rsp]
  0043e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_strtok_r
  00444	48 89 44 24 68	 mov	 QWORD PTR wrk$[rsp], rax

; 1678 :                 line = atoi( wrk );

  00449	48 8b 4c 24 68	 mov	 rcx, QWORD PTR wrk$[rsp]
  0044e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_atoi
  00454	88 44 24 33	 mov	 BYTE PTR line$[rsp], al

; 1679 : 
; 1680 :                 wrk = strtok_r( NULL, ",", &strtok_str );

  00458	4c 8d 84 24 90
	00 00 00	 lea	 r8, QWORD PTR strtok_str$[rsp]
  00460	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG178293
  00467	33 c9		 xor	 ecx, ecx
  00469	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_strtok_r
  0046f	48 89 44 24 68	 mov	 QWORD PTR wrk$[rsp], rax

; 1681 : 
; 1682 :                 if (wrk != NULL)

  00474	48 83 7c 24 68
	00		 cmp	 QWORD PTR wrk$[rsp], 0
  0047a	74 11		 je	 SHORT $LN36@build_logo

; 1683 :                     col = atoi( wrk );

  0047c	48 8b 4c 24 68	 mov	 rcx, QWORD PTR wrk$[rsp]
  00481	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_atoi
  00487	88 44 24 30	 mov	 BYTE PTR col$[rsp], al
  0048b	eb 11		 jmp	 SHORT $LN37@build_logo
$LN36@build_logo:

; 1684 :                 else
; 1685 :                 {
; 1686 :                     msg = "missing @sba ..,X value";

  0048d	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG178296
  00494	48 89 44 24 58	 mov	 QWORD PTR msg$[rsp], rax

; 1687 :                     goto error_exit;

  00499	e9 b9 02 00 00	 jmp	 $error_exit$69
$LN37@build_logo:

; 1688 :                 }
; 1689 :             }

  0049e	eb 11		 jmp	 SHORT $LN35@build_logo
$LN34@build_logo:

; 1690 :             else
; 1691 :             {
; 1692 :                 msg = "missing @sba Y,X values";

  004a0	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG178297
  004a7	48 89 44 24 58	 mov	 QWORD PTR msg$[rsp], rax

; 1693 :                 goto error_exit;

  004ac	e9 a6 02 00 00	 jmp	 $error_exit$69
$LN35@build_logo:

; 1694 :             }
; 1695 :         }

  004b1	e9 66 02 00 00	 jmp	 $LN33@build_logo
$LN32@build_logo:

; 1696 : 
; 1697 :         /* Start Field attribute? */
; 1698 : 
; 1699 :         else if (strcasecmp( verb, "@sf" ) == 0)

  004b6	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG178300
  004bd	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR verb$[rsp]
  004c5	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__stricmp
  004cb	85 c0		 test	 eax, eax
  004cd	0f 85 15 01 00
	00		 jne	 $LN38@build_logo

; 1700 :         {
; 1701 :             attr = SF_ATTR_PROTECTED;

  004d3	c6 44 24 31 20	 mov	 BYTE PTR attr$[rsp], 32	; 00000020H

; 1702 : 
; 1703 :             if (rest != NULL)

  004d8	48 83 7c 24 48
	00		 cmp	 QWORD PTR rest$[rsp], 0
  004de	0f 84 ff 00 00
	00		 je	 $LN40@build_logo

; 1704 :             {
; 1705 :                 for (j=0; rest[j] != 0; j++)

  004e4	48 c7 84 24 80
	00 00 00 00 00
	00 00		 mov	 QWORD PTR j$[rsp], 0
  004f0	eb 13		 jmp	 SHORT $LN9@build_logo
$LN7@build_logo:
  004f2	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR j$[rsp]
  004fa	48 ff c0	 inc	 rax
  004fd	48 89 84 24 80
	00 00 00	 mov	 QWORD PTR j$[rsp], rax
$LN9@build_logo:
  00505	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR j$[rsp]
  0050d	48 8b 4c 24 48	 mov	 rcx, QWORD PTR rest$[rsp]
  00512	48 03 c8	 add	 rcx, rax
  00515	48 8b c1	 mov	 rax, rcx
  00518	0f be 00	 movsx	 eax, BYTE PTR [rax]
  0051b	85 c0		 test	 eax, eax
  0051d	0f 84 c0 00 00
	00		 je	 $LN8@build_logo

; 1706 :                 {
; 1707 :                     switch( rest[j] )

  00523	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR j$[rsp]
  0052b	48 8b 4c 24 48	 mov	 rcx, QWORD PTR rest$[rsp]
  00530	48 03 c8	 add	 rcx, rax
  00533	48 8b c1	 mov	 rax, rcx
  00536	0f be 00	 movsx	 eax, BYTE PTR [rax]
  00539	89 44 24 54	 mov	 DWORD PTR tv250[rsp], eax
  0053d	8b 44 24 54	 mov	 eax, DWORD PTR tv250[rsp]
  00541	83 e8 48	 sub	 eax, 72			; 00000048H
  00544	89 44 24 54	 mov	 DWORD PTR tv250[rsp], eax
  00548	83 7c 24 54 28	 cmp	 DWORD PTR tv250[rsp], 40 ; 00000028H
  0054d	77 4a		 ja	 SHORT $LN47@build_logo
  0054f	48 63 44 24 54	 movsxd	 rax, DWORD PTR tv250[rsp]
  00554	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__ImageBase
  0055b	0f b6 84 01 00
	00 00 00	 movzx	 eax, BYTE PTR $LN66@build_logo[rcx+rax]
  00563	8b 84 81 00 00
	00 00		 mov	 eax, DWORD PTR $LN67@build_logo[rcx+rax*4]
  0056a	48 03 c1	 add	 rax, rcx
  0056d	ff e0		 jmp	 rax
$LN41@build_logo:
$LN42@build_logo:

; 1708 :                     {
; 1709 :                         case 'h':
; 1710 :                         case 'H':
; 1711 :                             attr |= SF_ATTR_HIGHLIGHT;

  0056f	0f b6 44 24 31	 movzx	 eax, BYTE PTR attr$[rsp]
  00574	83 c8 08	 or	 eax, 8
  00577	88 44 24 31	 mov	 BYTE PTR attr$[rsp], al

; 1712 :                             break;

  0057b	eb 61		 jmp	 SHORT $LN10@build_logo
$LN43@build_logo:
$LN44@build_logo:

; 1713 :                         case 'p':
; 1714 :                         case 'P':
; 1715 :                             attr |= SF_ATTR_PROTECTED;

  0057d	0f b6 44 24 31	 movzx	 eax, BYTE PTR attr$[rsp]
  00582	83 c8 20	 or	 eax, 32			; 00000020H
  00585	88 44 24 31	 mov	 BYTE PTR attr$[rsp], al

; 1716 :                             break;

  00589	eb 53		 jmp	 SHORT $LN10@build_logo
$LN45@build_logo:
$LN46@build_logo:

; 1717 :                         case 'i':
; 1718 :                         case 'I':
; 1719 :                             attr &=~ SF_ATTR_PROTECTED;

  0058b	0f b6 44 24 31	 movzx	 eax, BYTE PTR attr$[rsp]
  00590	83 e0 df	 and	 eax, -33		; ffffffffffffffdfH
  00593	88 44 24 31	 mov	 BYTE PTR attr$[rsp], al

; 1720 :                             break;

  00597	eb 45		 jmp	 SHORT $LN10@build_logo
$LN47@build_logo:

; 1721 :                         default:
; 1722 :                             MSGBUF( msgbuf, "unrecognized @sf value: %c", rest[j] );

  00599	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR j$[rsp]
  005a1	48 8b 4c 24 48	 mov	 rcx, QWORD PTR rest$[rsp]
  005a6	48 03 c8	 add	 rcx, rax
  005a9	48 8b c1	 mov	 rax, rcx
  005ac	0f be 00	 movsx	 eax, BYTE PTR [rax]
  005af	44 8b c8	 mov	 r9d, eax
  005b2	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG178309
  005b9	ba 80 00 00 00	 mov	 edx, 128		; 00000080H
  005be	48 8d 8c 24 a0
	00 00 00	 lea	 rcx, QWORD PTR msgbuf$[rsp]
  005c6	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_snprintf

; 1723 :                             msg = msgbuf;

  005cc	48 8d 84 24 a0
	00 00 00	 lea	 rax, QWORD PTR msgbuf$[rsp]
  005d4	48 89 44 24 58	 mov	 QWORD PTR msg$[rsp], rax

; 1724 :                             goto error_exit;

  005d9	e9 79 01 00 00	 jmp	 $error_exit$69
$LN10@build_logo:

; 1725 :                     }
; 1726 :                 }

  005de	e9 0f ff ff ff	 jmp	 $LN7@build_logo
$LN8@build_logo:
$LN40@build_logo:

; 1727 :             }
; 1728 :         }

  005e3	e9 34 01 00 00	 jmp	 $LN39@build_logo
$LN38@build_logo:

; 1729 : 
; 1730 :         /* Start a New Line? */
; 1731 : 
; 1732 :         else if (strcasecmp( verb, "@nl" ) == 0)

  005e8	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG178312
  005ef	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR verb$[rsp]
  005f7	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__stricmp
  005fd	85 c0		 test	 eax, eax
  005ff	75 15		 jne	 SHORT $LN48@build_logo

; 1733 :         {
; 1734 :             line++;

  00601	0f b6 44 24 33	 movzx	 eax, BYTE PTR line$[rsp]
  00606	fe c0		 inc	 al
  00608	88 44 24 33	 mov	 BYTE PTR line$[rsp], al

; 1735 :             col = 0;

  0060c	c6 44 24 30 00	 mov	 BYTE PTR col$[rsp], 0

; 1736 :         }

  00611	e9 06 01 00 00	 jmp	 $LN49@build_logo
$LN48@build_logo:

; 1737 : 
; 1738 :         /* Align next field? */
; 1739 : 
; 1740 :         else if (strcasecmp( verb, "@align" ) == 0)

  00616	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG178315
  0061d	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR verb$[rsp]
  00625	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__stricmp
  0062b	85 c0		 test	 eax, eax
  0062d	0f 85 b8 00 00
	00		 jne	 $LN50@build_logo

; 1741 :         {
; 1742 :             align = ALIGN_NONE;

  00633	c6 44 24 32 00	 mov	 BYTE PTR align$[rsp], 0

; 1743 : 
; 1744 :             if (rest != NULL)

  00638	48 83 7c 24 48
	00		 cmp	 QWORD PTR rest$[rsp], 0
  0063e	0f 84 a5 00 00
	00		 je	 $LN52@build_logo

; 1745 :             {
; 1746 :                 if      (strcasecmp( rest, "none"   ) == 0) align = ALIGN_NONE;

  00644	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG178319
  0064b	48 8b 4c 24 48	 mov	 rcx, QWORD PTR rest$[rsp]
  00650	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__stricmp
  00656	85 c0		 test	 eax, eax
  00658	75 0a		 jne	 SHORT $LN53@build_logo
  0065a	c6 44 24 32 00	 mov	 BYTE PTR align$[rsp], 0
  0065f	e9 85 00 00 00	 jmp	 $LN54@build_logo
$LN53@build_logo:

; 1747 :                 else if (strcasecmp( rest, "left"   ) == 0) align = ALIGN_LEFT;

  00664	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG178322
  0066b	48 8b 4c 24 48	 mov	 rcx, QWORD PTR rest$[rsp]
  00670	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__stricmp
  00676	85 c0		 test	 eax, eax
  00678	75 07		 jne	 SHORT $LN55@build_logo
  0067a	c6 44 24 32 02	 mov	 BYTE PTR align$[rsp], 2
  0067f	eb 68		 jmp	 SHORT $LN56@build_logo
$LN55@build_logo:

; 1748 :                 else if (strcasecmp( rest, "right"  ) == 0) align = ALIGN_RIGHT;

  00681	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG178325
  00688	48 8b 4c 24 48	 mov	 rcx, QWORD PTR rest$[rsp]
  0068d	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__stricmp
  00693	85 c0		 test	 eax, eax
  00695	75 07		 jne	 SHORT $LN57@build_logo
  00697	c6 44 24 32 03	 mov	 BYTE PTR align$[rsp], 3
  0069c	eb 4b		 jmp	 SHORT $LN58@build_logo
$LN57@build_logo:

; 1749 :                 else if (strcasecmp( rest, "center" ) == 0) align = ALIGN_CENTER;

  0069e	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG178328
  006a5	48 8b 4c 24 48	 mov	 rcx, QWORD PTR rest$[rsp]
  006aa	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__stricmp
  006b0	85 c0		 test	 eax, eax
  006b2	75 07		 jne	 SHORT $LN59@build_logo
  006b4	c6 44 24 32 01	 mov	 BYTE PTR align$[rsp], 1
  006b9	eb 2e		 jmp	 SHORT $LN60@build_logo
$LN59@build_logo:

; 1750 :                 else
; 1751 :                 {
; 1752 :                     MSGBUF( msgbuf, "unrecognized @align value: %s", rest );

  006bb	4c 8b 4c 24 48	 mov	 r9, QWORD PTR rest$[rsp]
  006c0	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG178329
  006c7	ba 80 00 00 00	 mov	 edx, 128		; 00000080H
  006cc	48 8d 8c 24 a0
	00 00 00	 lea	 rcx, QWORD PTR msgbuf$[rsp]
  006d4	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_snprintf

; 1753 :                     msg = msgbuf;

  006da	48 8d 84 24 a0
	00 00 00	 lea	 rax, QWORD PTR msgbuf$[rsp]
  006e2	48 89 44 24 58	 mov	 QWORD PTR msg$[rsp], rax

; 1754 :                     goto error_exit;

  006e7	eb 6e		 jmp	 SHORT $error_exit$69
$LN60@build_logo:
$LN58@build_logo:
$LN56@build_logo:
$LN54@build_logo:
$LN52@build_logo:

; 1755 :                 }
; 1756 :             }
; 1757 :         }

  006e9	eb 31		 jmp	 SHORT $LN51@build_logo
$LN50@build_logo:

; 1758 : 
; 1759 :         /* It's none of those */
; 1760 : 
; 1761 :         else
; 1762 :         {
; 1763 :             MSGBUF( msgbuf, "unrecognized order: %s", verb );

  006eb	4c 8b 8c 24 88
	00 00 00	 mov	 r9, QWORD PTR verb$[rsp]
  006f3	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG178330
  006fa	ba 80 00 00 00	 mov	 edx, 128		; 00000080H
  006ff	48 8d 8c 24 a0
	00 00 00	 lea	 rcx, QWORD PTR msgbuf$[rsp]
  00707	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_snprintf

; 1764 :             msg = msgbuf;

  0070d	48 8d 84 24 a0
	00 00 00	 lea	 rax, QWORD PTR msgbuf$[rsp]
  00715	48 89 44 24 58	 mov	 QWORD PTR msg$[rsp], rax

; 1765 :             goto error_exit;

  0071a	eb 3b		 jmp	 SHORT $error_exit$69
$LN51@build_logo:
$LN49@build_logo:
$LN39@build_logo:
$LN33@build_logo:

; 1766 :         }
; 1767 : 
; 1768 :     } /* end for (i=0; bfr && i < num_stmts; i++) */

  0071c	e9 2a fa ff ff	 jmp	 $LN2@build_logo
$LN3@build_logo:

; 1769 : 
; 1770 :     if (stmt)

  00721	48 83 7c 24 38
	00		 cmp	 QWORD PTR stmt$[rsp], 0
  00727	74 0b		 je	 SHORT $LN61@build_logo

; 1771 :         free( stmt );

  00729	48 8b 4c 24 38	 mov	 rcx, QWORD PTR stmt$[rsp]
  0072e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free
$LN61@build_logo:

; 1772 : 
; 1773 :     *buflen = len;

  00734	48 8b 84 24 50
	01 00 00	 mov	 rax, QWORD PTR buflen$[rsp]
  0073c	48 8b 4c 24 70	 mov	 rcx, QWORD PTR len$[rsp]
  00741	48 89 08	 mov	 QWORD PTR [rax], rcx

; 1774 : 
; 1775 :     return bfr;

  00744	48 8b 44 24 40	 mov	 rax, QWORD PTR bfr$[rsp]
  00749	eb 55		 jmp	 SHORT $LN1@build_logo
$outofmem_error$68:

; 1776 : 
; 1777 : outofmem_error:
; 1778 : 
; 1779 :     msg = "out of memory";

  0074b	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG178332
  00752	48 89 44 24 58	 mov	 QWORD PTR msg$[rsp], rax
$error_exit$69:

; 1780 : 
; 1781 : error_exit:
; 1782 : 
; 1783 :     if (stmt)

  00757	48 83 7c 24 38
	00		 cmp	 QWORD PTR stmt$[rsp], 0
  0075d	74 0b		 je	 SHORT $LN62@build_logo

; 1784 :         free( stmt );

  0075f	48 8b 4c 24 38	 mov	 rcx, QWORD PTR stmt$[rsp]
  00764	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free
$LN62@build_logo:

; 1785 : 
; 1786 :     if (bfr)

  0076a	48 83 7c 24 40
	00		 cmp	 QWORD PTR bfr$[rsp], 0
  00770	74 0b		 je	 SHORT $LN63@build_logo

; 1787 :         free( bfr );

  00772	48 8b 4c 24 40	 mov	 rcx, QWORD PTR bfr$[rsp]
  00777	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free
$LN63@build_logo:

; 1788 : 
; 1789 :     if (errmsg)

  0077d	48 83 bc 24 58
	01 00 00 00	 cmp	 QWORD PTR errmsg$[rsp], 0
  00786	74 16		 je	 SHORT $LN64@build_logo

; 1790 :         *errmsg = strdup( msg );

  00788	48 8b 4c 24 58	 mov	 rcx, QWORD PTR msg$[rsp]
  0078d	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_strdup
  00793	48 8b 8c 24 58
	01 00 00	 mov	 rcx, QWORD PTR errmsg$[rsp]
  0079b	48 89 01	 mov	 QWORD PTR [rcx], rax
$LN64@build_logo:

; 1791 : 
; 1792 :     return NULL;

  0079e	33 c0		 xor	 eax, eax
$LN1@build_logo:

; 1793 : 
; 1794 : } /* end function build_logo */

  007a0	48 8b 8c 24 20
	01 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  007a8	48 33 cc	 xor	 rcx, rsp
  007ab	e8 00 00 00 00	 call	 __security_check_cookie
  007b0	48 81 c4 38 01
	00 00		 add	 rsp, 312		; 00000138H
  007b7	c3		 ret	 0
$LN67@build_logo:
  007b8	00 00 00 00	 DD	 $LN42@build_logo
  007bc	00 00 00 00	 DD	 $LN46@build_logo
  007c0	00 00 00 00	 DD	 $LN44@build_logo
  007c4	00 00 00 00	 DD	 $LN41@build_logo
  007c8	00 00 00 00	 DD	 $LN45@build_logo
  007cc	00 00 00 00	 DD	 $LN43@build_logo
  007d0	00 00 00 00	 DD	 $LN47@build_logo
$LN66@build_logo:
  007d4	00		 DB	 0
  007d5	01		 DB	 1
  007d6	06		 DB	 6
  007d7	06		 DB	 6
  007d8	06		 DB	 6
  007d9	06		 DB	 6
  007da	06		 DB	 6
  007db	06		 DB	 6
  007dc	02		 DB	 2
  007dd	06		 DB	 6
  007de	06		 DB	 6
  007df	06		 DB	 6
  007e0	06		 DB	 6
  007e1	06		 DB	 6
  007e2	06		 DB	 6
  007e3	06		 DB	 6
  007e4	06		 DB	 6
  007e5	06		 DB	 6
  007e6	06		 DB	 6
  007e7	06		 DB	 6
  007e8	06		 DB	 6
  007e9	06		 DB	 6
  007ea	06		 DB	 6
  007eb	06		 DB	 6
  007ec	06		 DB	 6
  007ed	06		 DB	 6
  007ee	06		 DB	 6
  007ef	06		 DB	 6
  007f0	06		 DB	 6
  007f1	06		 DB	 6
  007f2	06		 DB	 6
  007f3	06		 DB	 6
  007f4	03		 DB	 3
  007f5	04		 DB	 4
  007f6	06		 DB	 6
  007f7	06		 DB	 6
  007f8	06		 DB	 6
  007f9	06		 DB	 6
  007fa	06		 DB	 6
  007fb	06		 DB	 6
  007fc	05		 DB	 5
build_logo ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\console.c
_TEXT	SEGMENT
bfr$ = 48
buflen$ = 56
alloc_len$ = 64
attr$ = 72
buffer_addsf PROC

; 1879 : {

  00000	44 88 4c 24 20	 mov	 BYTE PTR [rsp+32], r9b
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 1880 :     if (!(bfr = buffer_addchar( bfr, buflen, alloc_len, 0x1d )))

  00018	41 b1 1d	 mov	 r9b, 29
  0001b	4c 8b 44 24 40	 mov	 r8, QWORD PTR alloc_len$[rsp]
  00020	48 8b 54 24 38	 mov	 rdx, QWORD PTR buflen$[rsp]
  00025	48 8b 4c 24 30	 mov	 rcx, QWORD PTR bfr$[rsp]
  0002a	e8 00 00 00 00	 call	 buffer_addchar
  0002f	48 89 44 24 30	 mov	 QWORD PTR bfr$[rsp], rax
  00034	48 83 7c 24 30
	00		 cmp	 QWORD PTR bfr$[rsp], 0
  0003a	75 04		 jne	 SHORT $LN2@buffer_add

; 1881 :         return NULL;

  0003c	33 c0		 xor	 eax, eax
  0003e	eb 40		 jmp	 SHORT $LN1@buffer_add
$LN2@buffer_add:

; 1882 : 
; 1883 :     if (!(bfr = buffer_addchar( bfr, buflen, alloc_len, sba_code[ attr & 0x3f ])))

  00040	0f b6 44 24 48	 movzx	 eax, BYTE PTR attr$[rsp]
  00045	83 e0 3f	 and	 eax, 63			; 0000003fH
  00048	48 98		 cdqe
  0004a	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:sba_code
  00051	44 0f b6 0c 01	 movzx	 r9d, BYTE PTR [rcx+rax]
  00056	4c 8b 44 24 40	 mov	 r8, QWORD PTR alloc_len$[rsp]
  0005b	48 8b 54 24 38	 mov	 rdx, QWORD PTR buflen$[rsp]
  00060	48 8b 4c 24 30	 mov	 rcx, QWORD PTR bfr$[rsp]
  00065	e8 00 00 00 00	 call	 buffer_addchar
  0006a	48 89 44 24 30	 mov	 QWORD PTR bfr$[rsp], rax
  0006f	48 83 7c 24 30
	00		 cmp	 QWORD PTR bfr$[rsp], 0
  00075	75 04		 jne	 SHORT $LN3@buffer_add

; 1884 :         return NULL;

  00077	33 c0		 xor	 eax, eax
  00079	eb 05		 jmp	 SHORT $LN1@buffer_add
$LN3@buffer_add:

; 1885 : 
; 1886 :     return bfr;

  0007b	48 8b 44 24 30	 mov	 rax, QWORD PTR bfr$[rsp]
$LN1@buffer_add:

; 1887 : }

  00080	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00084	c3		 ret	 0
buffer_addsf ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\console.c
_TEXT	SEGMENT
pos$ = 32
bfr$ = 64
buflen$ = 72
alloc_len$ = 80
line$ = 88
col$ = 96
buffer_addsba PROC

; 1861 : {

  00000	44 88 4c 24 20	 mov	 BYTE PTR [rsp+32], r9b
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 1862 :     unsigned int pos = (line * 80) + col;

  00018	0f b6 44 24 58	 movzx	 eax, BYTE PTR line$[rsp]
  0001d	6b c0 50	 imul	 eax, eax, 80		; 00000050H
  00020	0f b6 4c 24 60	 movzx	 ecx, BYTE PTR col$[rsp]
  00025	03 c1		 add	 eax, ecx
  00027	89 44 24 20	 mov	 DWORD PTR pos$[rsp], eax

; 1863 : 
; 1864 :     if (!(bfr = buffer_addchar( bfr, buflen, alloc_len, 0x11 )))

  0002b	41 b1 11	 mov	 r9b, 17
  0002e	4c 8b 44 24 50	 mov	 r8, QWORD PTR alloc_len$[rsp]
  00033	48 8b 54 24 48	 mov	 rdx, QWORD PTR buflen$[rsp]
  00038	48 8b 4c 24 40	 mov	 rcx, QWORD PTR bfr$[rsp]
  0003d	e8 00 00 00 00	 call	 buffer_addchar
  00042	48 89 44 24 40	 mov	 QWORD PTR bfr$[rsp], rax
  00047	48 83 7c 24 40
	00		 cmp	 QWORD PTR bfr$[rsp], 0
  0004d	75 04		 jne	 SHORT $LN2@buffer_add

; 1865 :         return NULL;

  0004f	33 c0		 xor	 eax, eax
  00051	eb 79		 jmp	 SHORT $LN1@buffer_add
$LN2@buffer_add:

; 1866 : 
; 1867 :     if (!(bfr = buffer_addchar( bfr, buflen, alloc_len, sba_code[ pos >> 6 ])))

  00053	8b 44 24 20	 mov	 eax, DWORD PTR pos$[rsp]
  00057	c1 e8 06	 shr	 eax, 6
  0005a	8b c0		 mov	 eax, eax
  0005c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:sba_code
  00063	44 0f b6 0c 01	 movzx	 r9d, BYTE PTR [rcx+rax]
  00068	4c 8b 44 24 50	 mov	 r8, QWORD PTR alloc_len$[rsp]
  0006d	48 8b 54 24 48	 mov	 rdx, QWORD PTR buflen$[rsp]
  00072	48 8b 4c 24 40	 mov	 rcx, QWORD PTR bfr$[rsp]
  00077	e8 00 00 00 00	 call	 buffer_addchar
  0007c	48 89 44 24 40	 mov	 QWORD PTR bfr$[rsp], rax
  00081	48 83 7c 24 40
	00		 cmp	 QWORD PTR bfr$[rsp], 0
  00087	75 04		 jne	 SHORT $LN3@buffer_add

; 1868 :         return NULL;

  00089	33 c0		 xor	 eax, eax
  0008b	eb 3f		 jmp	 SHORT $LN1@buffer_add
$LN3@buffer_add:

; 1869 : 
; 1870 :     if (!(bfr = buffer_addchar( bfr, buflen, alloc_len, sba_code[ pos & 0x3f ])))

  0008d	8b 44 24 20	 mov	 eax, DWORD PTR pos$[rsp]
  00091	83 e0 3f	 and	 eax, 63			; 0000003fH
  00094	8b c0		 mov	 eax, eax
  00096	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:sba_code
  0009d	44 0f b6 0c 01	 movzx	 r9d, BYTE PTR [rcx+rax]
  000a2	4c 8b 44 24 50	 mov	 r8, QWORD PTR alloc_len$[rsp]
  000a7	48 8b 54 24 48	 mov	 rdx, QWORD PTR buflen$[rsp]
  000ac	48 8b 4c 24 40	 mov	 rcx, QWORD PTR bfr$[rsp]
  000b1	e8 00 00 00 00	 call	 buffer_addchar
  000b6	48 89 44 24 40	 mov	 QWORD PTR bfr$[rsp], rax
  000bb	48 83 7c 24 40
	00		 cmp	 QWORD PTR bfr$[rsp], 0
  000c1	75 04		 jne	 SHORT $LN4@buffer_add

; 1871 :         return NULL;

  000c3	33 c0		 xor	 eax, eax
  000c5	eb 05		 jmp	 SHORT $LN1@buffer_add
$LN4@buffer_add:

; 1872 : 
; 1873 :     return bfr;

  000c7	48 8b 44 24 40	 mov	 rax, QWORD PTR bfr$[rsp]
$LN1@buffer_add:

; 1874 : }

  000cc	48 83 c4 38	 add	 rsp, 56			; 00000038H
  000d0	c3		 ret	 0
buffer_addsba ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\console.c
_TEXT	SEGMENT
i$ = 32
bfr$ = 64
buflen$ = 72
alloc_len$ = 80
str$ = 88
buffer_addstring PROC

; 1834 : {

  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 1835 :     size_t i;
; 1836 : 
; 1837 :     for (i=0; str[i] != 0; i++)

  00018	48 c7 44 24 20
	00 00 00 00	 mov	 QWORD PTR i$[rsp], 0
  00021	eb 0d		 jmp	 SHORT $LN4@buffer_add
$LN2@buffer_add:
  00023	48 8b 44 24 20	 mov	 rax, QWORD PTR i$[rsp]
  00028	48 ff c0	 inc	 rax
  0002b	48 89 44 24 20	 mov	 QWORD PTR i$[rsp], rax
$LN4@buffer_add:
  00030	48 8b 44 24 20	 mov	 rax, QWORD PTR i$[rsp]
  00035	48 8b 4c 24 58	 mov	 rcx, QWORD PTR str$[rsp]
  0003a	48 03 c8	 add	 rcx, rax
  0003d	48 8b c1	 mov	 rax, rcx
  00040	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  00043	85 c0		 test	 eax, eax
  00045	74 3b		 je	 SHORT $LN3@buffer_add

; 1838 :     {
; 1839 :         if (!(bfr = buffer_addchar( bfr, buflen, alloc_len, str[i] )))

  00047	48 8b 44 24 20	 mov	 rax, QWORD PTR i$[rsp]
  0004c	48 8b 4c 24 58	 mov	 rcx, QWORD PTR str$[rsp]
  00051	48 03 c8	 add	 rcx, rax
  00054	48 8b c1	 mov	 rax, rcx
  00057	44 0f b6 08	 movzx	 r9d, BYTE PTR [rax]
  0005b	4c 8b 44 24 50	 mov	 r8, QWORD PTR alloc_len$[rsp]
  00060	48 8b 54 24 48	 mov	 rdx, QWORD PTR buflen$[rsp]
  00065	48 8b 4c 24 40	 mov	 rcx, QWORD PTR bfr$[rsp]
  0006a	e8 00 00 00 00	 call	 buffer_addchar
  0006f	48 89 44 24 40	 mov	 QWORD PTR bfr$[rsp], rax
  00074	48 83 7c 24 40
	00		 cmp	 QWORD PTR bfr$[rsp], 0
  0007a	75 04		 jne	 SHORT $LN5@buffer_add

; 1840 :             return NULL;

  0007c	33 c0		 xor	 eax, eax
  0007e	eb 07		 jmp	 SHORT $LN1@buffer_add
$LN5@buffer_add:

; 1841 :     }

  00080	eb a1		 jmp	 SHORT $LN2@buffer_add
$LN3@buffer_add:

; 1842 :     return bfr;

  00082	48 8b 44 24 40	 mov	 rax, QWORD PTR bfr$[rsp]
$LN1@buffer_add:

; 1843 : }

  00087	48 83 c4 38	 add	 rsp, 56			; 00000038H
  0008b	c3		 ret	 0
buffer_addstring ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\console.c
_TEXT	SEGMENT
alen$ = 32
len$ = 40
bfr$ = 64
buflen$ = 72
alloc_len$ = 80
c$ = 88
buffer_addchar PROC

; 1801 : {

  00000	44 88 4c 24 20	 mov	 BYTE PTR [rsp+32], r9b
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 1802 :     size_t  len   =  *buflen;

  00018	48 8b 44 24 48	 mov	 rax, QWORD PTR buflen$[rsp]
  0001d	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00020	48 89 44 24 28	 mov	 QWORD PTR len$[rsp], rax

; 1803 :     size_t  alen  =  *alloc_len;

  00025	48 8b 44 24 50	 mov	 rax, QWORD PTR alloc_len$[rsp]
  0002a	48 8b 00	 mov	 rax, QWORD PTR [rax]
  0002d	48 89 44 24 20	 mov	 QWORD PTR alen$[rsp], rax

; 1804 : 
; 1805 :     if (len >= alen)

  00032	48 8b 44 24 20	 mov	 rax, QWORD PTR alen$[rsp]
  00037	48 39 44 24 28	 cmp	 QWORD PTR len$[rsp], rax
  0003c	72 60		 jb	 SHORT $LN2@buffer_add

; 1806 :     {
; 1807 :         if (!alen)

  0003e	48 83 7c 24 20
	00		 cmp	 QWORD PTR alen$[rsp], 0
  00044	75 27		 jne	 SHORT $LN3@buffer_add

; 1808 :         {
; 1809 :             alen = LOGO_BUFSZ_INCR;             // (initialize)

  00046	48 c7 44 24 20
	00 01 00 00	 mov	 QWORD PTR alen$[rsp], 256 ; 00000100H

; 1810 : 
; 1811 :             if (!(bfr = malloc( alen )))        // (allocate)

  0004f	48 8b 4c 24 20	 mov	 rcx, QWORD PTR alen$[rsp]
  00054	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_malloc
  0005a	48 89 44 24 40	 mov	 QWORD PTR bfr$[rsp], rax
  0005f	48 83 7c 24 40
	00		 cmp	 QWORD PTR bfr$[rsp], 0
  00065	75 04		 jne	 SHORT $LN5@buffer_add

; 1812 :                 return NULL;

  00067	33 c0		 xor	 eax, eax
  00069	eb 76		 jmp	 SHORT $LN1@buffer_add
$LN5@buffer_add:

; 1813 :         }

  0006b	eb 31		 jmp	 SHORT $LN4@buffer_add
$LN3@buffer_add:

; 1814 :         else
; 1815 :         {
; 1816 :             alen += LOGO_BUFSZ_INCR;            // (increment)

  0006d	48 8b 44 24 20	 mov	 rax, QWORD PTR alen$[rsp]
  00072	48 05 00 01 00
	00		 add	 rax, 256		; 00000100H
  00078	48 89 44 24 20	 mov	 QWORD PTR alen$[rsp], rax

; 1817 : 
; 1818 :             if (!(bfr = realloc( bfr,alen )))   // (re-allocate)

  0007d	48 8b 54 24 20	 mov	 rdx, QWORD PTR alen$[rsp]
  00082	48 8b 4c 24 40	 mov	 rcx, QWORD PTR bfr$[rsp]
  00087	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_realloc
  0008d	48 89 44 24 40	 mov	 QWORD PTR bfr$[rsp], rax
  00092	48 83 7c 24 40
	00		 cmp	 QWORD PTR bfr$[rsp], 0
  00098	75 04		 jne	 SHORT $LN6@buffer_add

; 1819 :                 return NULL;

  0009a	33 c0		 xor	 eax, eax
  0009c	eb 43		 jmp	 SHORT $LN1@buffer_add
$LN6@buffer_add:
$LN4@buffer_add:
$LN2@buffer_add:

; 1820 :         }
; 1821 :     }
; 1822 : 
; 1823 :     bfr[ len++ ] = c;

  0009e	48 8b 44 24 28	 mov	 rax, QWORD PTR len$[rsp]
  000a3	48 8b 4c 24 40	 mov	 rcx, QWORD PTR bfr$[rsp]
  000a8	48 03 c8	 add	 rcx, rax
  000ab	48 8b c1	 mov	 rax, rcx
  000ae	0f b6 4c 24 58	 movzx	 ecx, BYTE PTR c$[rsp]
  000b3	88 08		 mov	 BYTE PTR [rax], cl
  000b5	48 8b 44 24 28	 mov	 rax, QWORD PTR len$[rsp]
  000ba	48 ff c0	 inc	 rax
  000bd	48 89 44 24 28	 mov	 QWORD PTR len$[rsp], rax

; 1824 : 
; 1825 :     *alloc_len  =  alen;

  000c2	48 8b 44 24 50	 mov	 rax, QWORD PTR alloc_len$[rsp]
  000c7	48 8b 4c 24 20	 mov	 rcx, QWORD PTR alen$[rsp]
  000cc	48 89 08	 mov	 QWORD PTR [rax], rcx

; 1826 :     *buflen     =  len;

  000cf	48 8b 44 24 48	 mov	 rax, QWORD PTR buflen$[rsp]
  000d4	48 8b 4c 24 28	 mov	 rcx, QWORD PTR len$[rsp]
  000d9	48 89 08	 mov	 QWORD PTR [rax], rcx

; 1827 : 
; 1828 :     return bfr;

  000dc	48 8b 44 24 40	 mov	 rax, QWORD PTR bfr$[rsp]
$LN1@buffer_add:

; 1829 : }

  000e1	48 83 c4 38	 add	 rsp, 56			; 00000038H
  000e5	c3		 ret	 0
buffer_addchar ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\console.c
_TEXT	SEGMENT
woff$ = 32
wpos$ = 36
pos$ = 64
buf$ = 72
size$ = 80
pos_to_buff_offset PROC

; 1413 : {

  00000	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	89 4c 24 08	 mov	 DWORD PTR [rsp+8], ecx
  0000e	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 1414 :     int  wpos;                          /* Working screen position   */
; 1415 :     int  woff;                          /* Working offset in buffer  */
; 1416 : 
; 1417 :     /* Screen position 0 is at offset 3 into the device buffer,
; 1418 :        immediately following the AID and cursor address bytes. */
; 1419 : 
; 1420 :     wpos = 0;

  00012	c7 44 24 24 00
	00 00 00	 mov	 DWORD PTR wpos$[rsp], 0

; 1421 :     woff = 3;

  0001a	c7 44 24 20 03
	00 00 00	 mov	 DWORD PTR woff$[rsp], 3
$LN2@pos_to_buf:

; 1422 : 
; 1423 :     /* Locate the desired screen position... */
; 1424 : 
; 1425 :     while (woff < size)       /* While not at or past end of buff */

  00022	8b 44 24 50	 mov	 eax, DWORD PTR size$[rsp]
  00026	39 44 24 20	 cmp	 DWORD PTR woff$[rsp], eax
  0002a	7d 26		 jge	 SHORT $LN3@pos_to_buf

; 1426 :     {
; 1427 :         if (wpos >= pos)      /* Desired screen position reached? */

  0002c	8b 44 24 40	 mov	 eax, DWORD PTR pos$[rsp]
  00030	39 44 24 24	 cmp	 DWORD PTR wpos$[rsp], eax
  00034	7c 06		 jl	 SHORT $LN4@pos_to_buf

; 1428 :         {
; 1429 : #ifdef FIX_QWS_BUG_FOR_MCS_CONSOLES
; 1430 : 
; 1431 :             /* There is a bug in QWS3270 when used to emulate an
; 1432 :                MCS console with EAB.  At position 1680 the Read
; 1433 :                Buffer contains two 6-byte SFE orders (12 bytes)
; 1434 :                preceding the entry area, whereas MCS expects the
; 1435 :                entry area to start 4 bytes after screen position
; 1436 :                1680 in the buffer.  The bypass is to add 8 to the
; 1437 :                calculated buffer offset if this appears to be an
; 1438 :                MCS console read buffer command
; 1439 :             */
; 1440 :             if (1
; 1441 :                 && pos         == 1680          // 0x0690
; 1442 :                 && buf[woff+0] == O3270_SFE
; 1443 :                 && buf[woff+6] == O3270_SFE
; 1444 :             )
; 1445 :             {
; 1446 :                 LOGMSG("*** OLD: wpos: %d (0x%4.4X), woff: %d (0x%4.4X)\n",
; 1447 :                     wpos, wpos, woff, woff );
; 1448 : 
; 1449 :                 woff += 8;
; 1450 : 
; 1451 :                 LOGMSG("*** NEW: wpos: %d (0x%4.4X), woff: %d (0x%4.4X)\n",
; 1452 :                     wpos, wpos, woff, woff );
; 1453 :         }
; 1454 : #endif /* FIX_QWS_BUG_FOR_MCS_CONSOLES */
; 1455 : 
; 1456 :             return woff;      /* Return calculated buffer offset  */

  00036	8b 44 24 20	 mov	 eax, DWORD PTR woff$[rsp]
  0003a	eb 18		 jmp	 SHORT $LN1@pos_to_buf
$LN4@pos_to_buf:

; 1457 :         }
; 1458 : 
; 1459 :         /* Advance to next character or order, updating the
; 1460 :            buffer offset and screen position as we go... */
; 1461 : 
; 1462 :         next_3270_pos( buf, &woff, &wpos );

  0003c	4c 8d 44 24 24	 lea	 r8, QWORD PTR wpos$[rsp]
  00041	48 8d 54 24 20	 lea	 rdx, QWORD PTR woff$[rsp]
  00046	48 8b 4c 24 48	 mov	 rcx, QWORD PTR buf$[rsp]
  0004b	e8 00 00 00 00	 call	 next_3270_pos

; 1463 :     }

  00050	eb d0		 jmp	 SHORT $LN2@pos_to_buf
$LN3@pos_to_buf:

; 1464 : 
; 1465 :     /*  Return offset zero if the position cannot be determined */
; 1466 : 
; 1467 :     return 0;

  00052	33 c0		 xor	 eax, eax
$LN1@pos_to_buf:

; 1468 : 
; 1469 : } /* end function pos_to_buff_offset */

  00054	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00058	c3		 ret	 0
pos_to_buff_offset ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\console.c
_TEXT	SEGMENT
offset$ = 32
eob_pos$ = 36
pos$ = 64
buf$ = 72
size$ = 80
end_of_buf_pos PROC

; 1392 : {

  00000	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	89 4c 24 08	 mov	 DWORD PTR [rsp+8], ecx
  0000e	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 1393 :     int eob_pos = pos;

  00012	8b 44 24 40	 mov	 eax, DWORD PTR pos$[rsp]
  00016	89 44 24 24	 mov	 DWORD PTR eob_pos$[rsp], eax

; 1394 :     int offset  = 0;

  0001a	c7 44 24 20 00
	00 00 00	 mov	 DWORD PTR offset$[rsp], 0
$LN2@end_of_buf:

; 1395 :     while (offset < size)

  00022	8b 44 24 50	 mov	 eax, DWORD PTR size$[rsp]
  00026	39 44 24 20	 cmp	 DWORD PTR offset$[rsp], eax
  0002a	7d 16		 jge	 SHORT $LN3@end_of_buf

; 1396 :         next_3270_pos( buf, &offset, &eob_pos );

  0002c	4c 8d 44 24 24	 lea	 r8, QWORD PTR eob_pos$[rsp]
  00031	48 8d 54 24 20	 lea	 rdx, QWORD PTR offset$[rsp]
  00036	48 8b 4c 24 48	 mov	 rcx, QWORD PTR buf$[rsp]
  0003b	e8 00 00 00 00	 call	 next_3270_pos
  00040	eb e0		 jmp	 SHORT $LN2@end_of_buf
$LN3@end_of_buf:

; 1397 :     return eob_pos;

  00042	8b 44 24 24	 mov	 eax, DWORD PTR eob_pos$[rsp]

; 1398 : }

  00046	48 83 c4 38	 add	 rsp, 56			; 00000038H
  0004a	c3		 ret	 0
end_of_buf_pos ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\console.c
_TEXT	SEGMENT
i$ = 0
tv69 = 4
tv76 = 8
buf$ = 32
poff$ = 40
ppos$ = 48
next_3270_pos PROC

; 1288 : {

  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	48 83 ec 18	 sub	 rsp, 24

; 1289 :     int i;
; 1290 : 
; 1291 :     /* Copy the offset and advance the offset by 1 byte */
; 1292 : 
; 1293 :     i = (*poff)++;

  00013	48 8b 44 24 28	 mov	 rax, QWORD PTR poff$[rsp]
  00018	8b 00		 mov	 eax, DWORD PTR [rax]
  0001a	89 04 24	 mov	 DWORD PTR i$[rsp], eax
  0001d	48 8b 44 24 28	 mov	 rax, QWORD PTR poff$[rsp]
  00022	8b 00		 mov	 eax, DWORD PTR [rax]
  00024	ff c0		 inc	 eax
  00026	48 8b 4c 24 28	 mov	 rcx, QWORD PTR poff$[rsp]
  0002b	89 01		 mov	 DWORD PTR [rcx], eax

; 1294 : 
; 1295 :     /*  Advance the offset past the argument bytes
; 1296 :         and update the screen position accordingly
; 1297 :     */
; 1298 :     switch (buf[i])

  0002d	48 63 04 24	 movsxd	 rax, DWORD PTR i$[rsp]
  00031	48 8b 4c 24 20	 mov	 rcx, QWORD PTR buf$[rsp]
  00036	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  0003a	89 44 24 04	 mov	 DWORD PTR tv69[rsp], eax
  0003e	8b 44 24 04	 mov	 eax, DWORD PTR tv69[rsp]
  00042	83 e8 05	 sub	 eax, 5
  00045	89 44 24 04	 mov	 DWORD PTR tv69[rsp], eax
  00049	83 7c 24 04 37	 cmp	 DWORD PTR tv69[rsp], 55	; 00000037H
  0004e	0f 87 da 01 00
	00		 ja	 $LN18@next_3270_
  00054	48 63 44 24 04	 movsxd	 rax, DWORD PTR tv69[rsp]
  00059	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__ImageBase
  00060	0f b6 84 01 00
	00 00 00	 movzx	 eax, BYTE PTR $LN22@next_3270_[rcx+rax]
  00068	8b 84 81 00 00
	00 00		 mov	 eax, DWORD PTR $LN23@next_3270_[rcx+rax*4]
  0006f	48 03 c1	 add	 rax, rcx
  00072	ff e0		 jmp	 rax
$LN4@next_3270_:

; 1299 :     {
; 1300 :     /*  The Repeat to Address order has 3 argument bytes (or in case
; 1301 :         of a Graphics Escape 4 bytes) and sets the screen position
; 1302 :     */
; 1303 :     case O3270_RA:
; 1304 : 
; 1305 :         *poff += (buf[i+3] == O3270_GE) ? 4 : 3;

  00074	8b 04 24	 mov	 eax, DWORD PTR i$[rsp]
  00077	83 c0 03	 add	 eax, 3
  0007a	48 98		 cdqe
  0007c	48 8b 4c 24 20	 mov	 rcx, QWORD PTR buf$[rsp]
  00081	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00085	83 f8 08	 cmp	 eax, 8
  00088	75 0a		 jne	 SHORT $LN20@next_3270_
  0008a	c7 44 24 08 04
	00 00 00	 mov	 DWORD PTR tv76[rsp], 4
  00092	eb 08		 jmp	 SHORT $LN21@next_3270_
$LN20@next_3270_:
  00094	c7 44 24 08 03
	00 00 00	 mov	 DWORD PTR tv76[rsp], 3
$LN21@next_3270_:
  0009c	48 8b 44 24 28	 mov	 rax, QWORD PTR poff$[rsp]
  000a1	8b 00		 mov	 eax, DWORD PTR [rax]
  000a3	03 44 24 08	 add	 eax, DWORD PTR tv76[rsp]
  000a7	48 8b 4c 24 28	 mov	 rcx, QWORD PTR poff$[rsp]
  000ac	89 01		 mov	 DWORD PTR [rcx], eax

; 1306 : 
; 1307 :         if ((buf[i+1] & 0xC0) == 0x00)

  000ae	8b 04 24	 mov	 eax, DWORD PTR i$[rsp]
  000b1	ff c0		 inc	 eax
  000b3	48 98		 cdqe
  000b5	48 8b 4c 24 20	 mov	 rcx, QWORD PTR buf$[rsp]
  000ba	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  000be	25 c0 00 00 00	 and	 eax, 192		; 000000c0H
  000c3	85 c0		 test	 eax, eax
  000c5	75 30		 jne	 SHORT $LN5@next_3270_

; 1308 :             *ppos = (buf[i+1] << 8)

  000c7	8b 04 24	 mov	 eax, DWORD PTR i$[rsp]
  000ca	ff c0		 inc	 eax
  000cc	48 98		 cdqe
  000ce	48 8b 4c 24 20	 mov	 rcx, QWORD PTR buf$[rsp]
  000d3	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  000d7	c1 e0 08	 shl	 eax, 8
  000da	8b 0c 24	 mov	 ecx, DWORD PTR i$[rsp]
  000dd	83 c1 02	 add	 ecx, 2
  000e0	48 63 c9	 movsxd	 rcx, ecx
  000e3	48 8b 54 24 20	 mov	 rdx, QWORD PTR buf$[rsp]
  000e8	0f b6 0c 0a	 movzx	 ecx, BYTE PTR [rdx+rcx]
  000ec	0b c1		 or	 eax, ecx
  000ee	48 8b 4c 24 30	 mov	 rcx, QWORD PTR ppos$[rsp]
  000f3	89 01		 mov	 DWORD PTR [rcx], eax
  000f5	eb 34		 jmp	 SHORT $LN6@next_3270_
$LN5@next_3270_:

; 1309 :                   |  buf[i+2];
; 1310 :         else
; 1311 :             *ppos = ((buf[i+1] & 0x3F) << 6)

  000f7	8b 04 24	 mov	 eax, DWORD PTR i$[rsp]
  000fa	ff c0		 inc	 eax
  000fc	48 98		 cdqe
  000fe	48 8b 4c 24 20	 mov	 rcx, QWORD PTR buf$[rsp]
  00103	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00107	83 e0 3f	 and	 eax, 63			; 0000003fH
  0010a	c1 e0 06	 shl	 eax, 6
  0010d	8b 0c 24	 mov	 ecx, DWORD PTR i$[rsp]
  00110	83 c1 02	 add	 ecx, 2
  00113	48 63 c9	 movsxd	 rcx, ecx
  00116	48 8b 54 24 20	 mov	 rdx, QWORD PTR buf$[rsp]
  0011b	0f b6 0c 0a	 movzx	 ecx, BYTE PTR [rdx+rcx]
  0011f	83 e1 3f	 and	 ecx, 63			; 0000003fH
  00122	0b c1		 or	 eax, ecx
  00124	48 8b 4c 24 30	 mov	 rcx, QWORD PTR ppos$[rsp]
  00129	89 01		 mov	 DWORD PTR [rcx], eax
$LN6@next_3270_:

; 1312 :                   |  (buf[i+2] & 0x3F);
; 1313 :         break;

  0012b	e9 0e 01 00 00	 jmp	 $LN2@next_3270_
$LN7@next_3270_:
$LN8@next_3270_:

; 1314 : 
; 1315 :     /*  The Start Field Extended and Modify Field orders have
; 1316 :         a count byte followed by a variable number of type-
; 1317 :         attribute pairs, and advance the screen position by 1
; 1318 :     */
; 1319 :     case O3270_SFE:
; 1320 :     case O3270_MF:
; 1321 : 
; 1322 :         *poff += (1 + (2 * buf[i+1]));

  00130	8b 04 24	 mov	 eax, DWORD PTR i$[rsp]
  00133	ff c0		 inc	 eax
  00135	48 98		 cdqe
  00137	48 8b 4c 24 20	 mov	 rcx, QWORD PTR buf$[rsp]
  0013c	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00140	48 8b 4c 24 28	 mov	 rcx, QWORD PTR poff$[rsp]
  00145	8b 09		 mov	 ecx, DWORD PTR [rcx]
  00147	8d 44 41 01	 lea	 eax, DWORD PTR [rcx+rax*2+1]
  0014b	48 8b 4c 24 28	 mov	 rcx, QWORD PTR poff$[rsp]
  00150	89 01		 mov	 DWORD PTR [rcx], eax

; 1323 : 
; 1324 :         (*ppos)++;

  00152	48 8b 44 24 30	 mov	 rax, QWORD PTR ppos$[rsp]
  00157	8b 00		 mov	 eax, DWORD PTR [rax]
  00159	ff c0		 inc	 eax
  0015b	48 8b 4c 24 30	 mov	 rcx, QWORD PTR ppos$[rsp]
  00160	89 01		 mov	 DWORD PTR [rcx], eax

; 1325 :         break;

  00162	e9 d7 00 00 00	 jmp	 $LN2@next_3270_
$LN9@next_3270_:
$LN10@next_3270_:

; 1326 : 
; 1327 :     /*  The Set Buffer Address and Erase Unprotected to Address
; 1328 :         orders have 2 argument bytes and set the screen position
; 1329 :     */
; 1330 :     case O3270_SBA:
; 1331 :     case O3270_EUA:
; 1332 : 
; 1333 :         *poff += 2;

  00167	48 8b 44 24 28	 mov	 rax, QWORD PTR poff$[rsp]
  0016c	8b 00		 mov	 eax, DWORD PTR [rax]
  0016e	83 c0 02	 add	 eax, 2
  00171	48 8b 4c 24 28	 mov	 rcx, QWORD PTR poff$[rsp]
  00176	89 01		 mov	 DWORD PTR [rcx], eax

; 1334 : 
; 1335 :         if ((buf[i+1] & 0xC0) == 0x00)

  00178	8b 04 24	 mov	 eax, DWORD PTR i$[rsp]
  0017b	ff c0		 inc	 eax
  0017d	48 98		 cdqe
  0017f	48 8b 4c 24 20	 mov	 rcx, QWORD PTR buf$[rsp]
  00184	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00188	25 c0 00 00 00	 and	 eax, 192		; 000000c0H
  0018d	85 c0		 test	 eax, eax
  0018f	75 30		 jne	 SHORT $LN11@next_3270_

; 1336 :             *ppos =  (buf[i+1] << 8)

  00191	8b 04 24	 mov	 eax, DWORD PTR i$[rsp]
  00194	ff c0		 inc	 eax
  00196	48 98		 cdqe
  00198	48 8b 4c 24 20	 mov	 rcx, QWORD PTR buf$[rsp]
  0019d	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  001a1	c1 e0 08	 shl	 eax, 8
  001a4	8b 0c 24	 mov	 ecx, DWORD PTR i$[rsp]
  001a7	83 c1 02	 add	 ecx, 2
  001aa	48 63 c9	 movsxd	 rcx, ecx
  001ad	48 8b 54 24 20	 mov	 rdx, QWORD PTR buf$[rsp]
  001b2	0f b6 0c 0a	 movzx	 ecx, BYTE PTR [rdx+rcx]
  001b6	0b c1		 or	 eax, ecx
  001b8	48 8b 4c 24 30	 mov	 rcx, QWORD PTR ppos$[rsp]
  001bd	89 01		 mov	 DWORD PTR [rcx], eax
  001bf	eb 34		 jmp	 SHORT $LN12@next_3270_
$LN11@next_3270_:

; 1337 :                   |   buf[i+2];
; 1338 :         else
; 1339 :             *ppos = ((buf[i+1] & 0x3F) << 6)

  001c1	8b 04 24	 mov	 eax, DWORD PTR i$[rsp]
  001c4	ff c0		 inc	 eax
  001c6	48 98		 cdqe
  001c8	48 8b 4c 24 20	 mov	 rcx, QWORD PTR buf$[rsp]
  001cd	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  001d1	83 e0 3f	 and	 eax, 63			; 0000003fH
  001d4	c1 e0 06	 shl	 eax, 6
  001d7	8b 0c 24	 mov	 ecx, DWORD PTR i$[rsp]
  001da	83 c1 02	 add	 ecx, 2
  001dd	48 63 c9	 movsxd	 rcx, ecx
  001e0	48 8b 54 24 20	 mov	 rdx, QWORD PTR buf$[rsp]
  001e5	0f b6 0c 0a	 movzx	 ecx, BYTE PTR [rdx+rcx]
  001e9	83 e1 3f	 and	 ecx, 63			; 0000003fH
  001ec	0b c1		 or	 eax, ecx
  001ee	48 8b 4c 24 30	 mov	 rcx, QWORD PTR ppos$[rsp]
  001f3	89 01		 mov	 DWORD PTR [rcx], eax
$LN12@next_3270_:

; 1340 :                   |  (buf[i+2] & 0x3F);
; 1341 :         break;

  001f5	eb 47		 jmp	 SHORT $LN2@next_3270_
$LN13@next_3270_:

; 1342 : 
; 1343 :     /*  The Set Attribute order has 2 argument bytes and
; 1344 :         does not change the screen position
; 1345 :     */
; 1346 :     case O3270_SA:
; 1347 : 
; 1348 :         *poff += 2;

  001f7	48 8b 44 24 28	 mov	 rax, QWORD PTR poff$[rsp]
  001fc	8b 00		 mov	 eax, DWORD PTR [rax]
  001fe	83 c0 02	 add	 eax, 2
  00201	48 8b 4c 24 28	 mov	 rcx, QWORD PTR poff$[rsp]
  00206	89 01		 mov	 DWORD PTR [rcx], eax

; 1349 :         break;

  00208	eb 34		 jmp	 SHORT $LN2@next_3270_
$LN14@next_3270_:
$LN15@next_3270_:

; 1350 : 
; 1351 :     /*  Insert Cursor and Program Tab have no argument
; 1352 :         bytes and do not change the screen position
; 1353 :     */
; 1354 :     case O3270_IC:
; 1355 :     case O3270_PT:
; 1356 : 
; 1357 :         break;

  0020a	eb 32		 jmp	 SHORT $LN2@next_3270_
$LN16@next_3270_:
$LN17@next_3270_:

; 1358 : 
; 1359 :     /*  The Start Field and Graphics Escape orders have one
; 1360 :         argument byte, and advance the screen position by 1
; 1361 :     */
; 1362 :     case O3270_SF:
; 1363 :     case O3270_GE:
; 1364 : 
; 1365 :         (*poff)++;

  0020c	48 8b 44 24 28	 mov	 rax, QWORD PTR poff$[rsp]
  00211	8b 00		 mov	 eax, DWORD PTR [rax]
  00213	ff c0		 inc	 eax
  00215	48 8b 4c 24 28	 mov	 rcx, QWORD PTR poff$[rsp]
  0021a	89 01		 mov	 DWORD PTR [rcx], eax

; 1366 :         (*ppos)++;

  0021c	48 8b 44 24 30	 mov	 rax, QWORD PTR ppos$[rsp]
  00221	8b 00		 mov	 eax, DWORD PTR [rax]
  00223	ff c0		 inc	 eax
  00225	48 8b 4c 24 30	 mov	 rcx, QWORD PTR ppos$[rsp]
  0022a	89 01		 mov	 DWORD PTR [rcx], eax

; 1367 :         break;

  0022c	eb 10		 jmp	 SHORT $LN2@next_3270_
$LN18@next_3270_:

; 1368 : 
; 1369 :     /* All other characters advance the screen position by 1 */
; 1370 :     default:
; 1371 : 
; 1372 :         (*ppos)++;

  0022e	48 8b 44 24 30	 mov	 rax, QWORD PTR ppos$[rsp]
  00233	8b 00		 mov	 eax, DWORD PTR [rax]
  00235	ff c0		 inc	 eax
  00237	48 8b 4c 24 30	 mov	 rcx, QWORD PTR ppos$[rsp]
  0023c	89 01		 mov	 DWORD PTR [rcx], eax
$LN2@next_3270_:

; 1373 :         break;
; 1374 : 
; 1375 :     } /* end switch */
; 1376 : 
; 1377 : } /* end function next_3270_pos */

  0023e	48 83 c4 18	 add	 rsp, 24
  00242	c3		 ret	 0
  00243	90		 npad	 1
$LN23@next_3270_:
  00244	00 00 00 00	 DD	 $LN15@next_3270_
  00248	00 00 00 00	 DD	 $LN17@next_3270_
  0024c	00 00 00 00	 DD	 $LN9@next_3270_
  00250	00 00 00 00	 DD	 $LN10@next_3270_
  00254	00 00 00 00	 DD	 $LN14@next_3270_
  00258	00 00 00 00	 DD	 $LN16@next_3270_
  0025c	00 00 00 00	 DD	 $LN13@next_3270_
  00260	00 00 00 00	 DD	 $LN7@next_3270_
  00264	00 00 00 00	 DD	 $LN8@next_3270_
  00268	00 00 00 00	 DD	 $LN4@next_3270_
  0026c	00 00 00 00	 DD	 $LN18@next_3270_
$LN22@next_3270_:
  00270	00		 DB	 0
  00271	0a		 DB	 10
  00272	0a		 DB	 10
  00273	01		 DB	 1
  00274	0a		 DB	 10
  00275	0a		 DB	 10
  00276	0a		 DB	 10
  00277	0a		 DB	 10
  00278	0a		 DB	 10
  00279	0a		 DB	 10
  0027a	0a		 DB	 10
  0027b	0a		 DB	 10
  0027c	02		 DB	 2
  0027d	03		 DB	 3
  0027e	04		 DB	 4
  0027f	0a		 DB	 10
  00280	0a		 DB	 10
  00281	0a		 DB	 10
  00282	0a		 DB	 10
  00283	0a		 DB	 10
  00284	0a		 DB	 10
  00285	0a		 DB	 10
  00286	0a		 DB	 10
  00287	0a		 DB	 10
  00288	05		 DB	 5
  00289	0a		 DB	 10
  0028a	0a		 DB	 10
  0028b	0a		 DB	 10
  0028c	0a		 DB	 10
  0028d	0a		 DB	 10
  0028e	0a		 DB	 10
  0028f	0a		 DB	 10
  00290	0a		 DB	 10
  00291	0a		 DB	 10
  00292	0a		 DB	 10
  00293	06		 DB	 6
  00294	07		 DB	 7
  00295	0a		 DB	 10
  00296	0a		 DB	 10
  00297	08		 DB	 8
  00298	0a		 DB	 10
  00299	0a		 DB	 10
  0029a	0a		 DB	 10
  0029b	0a		 DB	 10
  0029c	0a		 DB	 10
  0029d	0a		 DB	 10
  0029e	0a		 DB	 10
  0029f	0a		 DB	 10
  002a0	0a		 DB	 10
  002a1	0a		 DB	 10
  002a2	0a		 DB	 10
  002a3	0a		 DB	 10
  002a4	0a		 DB	 10
  002a5	0a		 DB	 10
  002a6	0a		 DB	 10
  002a7	09		 DB	 9
next_3270_pos ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\console.c
_TEXT	SEGMENT
port$ = 80
workspec$ = 88
sin$ = 96
host$ = 104
hostent$1 = 112
servent$2 = 120
sockspec$ = 144
parse_sockspec PROC

; 1141 : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 81 ec 88 00
	00 00		 sub	 rsp, 136		; 00000088H

; 1142 :     struct sockaddr_in*  sin;
; 1143 : 
; 1144 :     char*  workspec;
; 1145 :     char*  host;
; 1146 :     char*  port;
; 1147 : 
; 1148 :     if (!sockspec)

  0000c	48 83 bc 24 90
	00 00 00 00	 cmp	 QWORD PTR sockspec$[rsp], 0
  00015	75 07		 jne	 SHORT $LN2@parse_sock

; 1149 :         return NULL;

  00017	33 c0		 xor	 eax, eax
  00019	e9 a6 02 00 00	 jmp	 $LN1@parse_sock
$LN2@parse_sock:

; 1150 : 
; 1151 :     // Make working copy so we can modify it
; 1152 : 
; 1153 :     if (0
; 1154 :         || !(workspec = strdup( sockspec ))
; 1155 :         || !(sin = malloc( sizeof( struct sockaddr_in )))

  0001e	33 c0		 xor	 eax, eax
  00020	85 c0		 test	 eax, eax
  00022	75 33		 jne	 SHORT $LN4@parse_sock
  00024	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR sockspec$[rsp]
  0002c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_strdup
  00032	48 89 44 24 58	 mov	 QWORD PTR workspec$[rsp], rax
  00037	48 83 7c 24 58
	00		 cmp	 QWORD PTR workspec$[rsp], 0
  0003d	74 18		 je	 SHORT $LN4@parse_sock
  0003f	b9 10 00 00 00	 mov	 ecx, 16
  00044	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_malloc
  0004a	48 89 44 24 60	 mov	 QWORD PTR sin$[rsp], rax
  0004f	48 83 7c 24 60
	00		 cmp	 QWORD PTR sin$[rsp], 0
  00055	75 61		 jne	 SHORT $LN3@parse_sock
$LN4@parse_sock:

; 1156 :     )
; 1157 :     {
; 1158 :         if (workspec)

  00057	48 83 7c 24 58
	00		 cmp	 QWORD PTR workspec$[rsp], 0
  0005d	74 0b		 je	 SHORT $LN5@parse_sock

; 1159 :             free( workspec );

  0005f	48 8b 4c 24 58	 mov	 rcx, QWORD PTR workspec$[rsp]
  00064	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free
$LN5@parse_sock:

; 1160 :         // "Out of memory"
; 1161 :         WRMSG( HHC00152, "E" );

  0006a	b9 01 00 00 00	 mov	 ecx, 1
  0006f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  00075	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG178089
  0007c	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  00081	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG178090
  00088	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  0008d	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00092	41 b9 03 00 00
	00		 mov	 r9d, 3
  00098	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG178091
  0009f	ba 89 04 00 00	 mov	 edx, 1161		; 00000489H
  000a4	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG178092
  000ab	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 1162 :         return NULL;

  000b1	33 c0		 xor	 eax, eax
  000b3	e9 0c 02 00 00	 jmp	 $LN1@parse_sock
$LN3@parse_sock:

; 1163 :     }
; 1164 : 
; 1165 :     sin->sin_family = AF_INET;

  000b8	b8 02 00 00 00	 mov	 eax, 2
  000bd	48 8b 4c 24 60	 mov	 rcx, QWORD PTR sin$[rsp]
  000c2	66 89 01	 mov	 WORD PTR [rcx], ax

; 1166 : 
; 1167 :     // Parse spec into separate host and port components
; 1168 : 
; 1169 :     if (!(port = strchr( workspec, ':' )))

  000c5	ba 3a 00 00 00	 mov	 edx, 58			; 0000003aH
  000ca	48 8b 4c 24 58	 mov	 rcx, QWORD PTR workspec$[rsp]
  000cf	e8 00 00 00 00	 call	 strchr
  000d4	48 89 44 24 50	 mov	 QWORD PTR port$[rsp], rax
  000d9	48 83 7c 24 50
	00		 cmp	 QWORD PTR port$[rsp], 0
  000df	75 15		 jne	 SHORT $LN6@parse_sock

; 1170 :     {
; 1171 :         // Only the port number was specified
; 1172 :         host = NULL;

  000e1	48 c7 44 24 68
	00 00 00 00	 mov	 QWORD PTR host$[rsp], 0

; 1173 :         port = workspec;

  000ea	48 8b 44 24 58	 mov	 rax, QWORD PTR workspec$[rsp]
  000ef	48 89 44 24 50	 mov	 QWORD PTR port$[rsp], rax

; 1174 :     }

  000f4	eb 1f		 jmp	 SHORT $LN7@parse_sock
$LN6@parse_sock:

; 1175 :     else
; 1176 :     {
; 1177 :         // Both host and port were given
; 1178 :         host = workspec;

  000f6	48 8b 44 24 58	 mov	 rax, QWORD PTR workspec$[rsp]
  000fb	48 89 44 24 68	 mov	 QWORD PTR host$[rsp], rax

; 1179 :         *port++ = '\0';

  00100	48 8b 44 24 50	 mov	 rax, QWORD PTR port$[rsp]
  00105	c6 00 00	 mov	 BYTE PTR [rax], 0
  00108	48 8b 44 24 50	 mov	 rax, QWORD PTR port$[rsp]
  0010d	48 ff c0	 inc	 rax
  00110	48 89 44 24 50	 mov	 QWORD PTR port$[rsp], rax
$LN7@parse_sock:

; 1180 :     }
; 1181 : 
; 1182 :     // Convert host to ipaddr
; 1183 : 
; 1184 :     if (!host)

  00115	48 83 7c 24 68
	00		 cmp	 QWORD PTR host$[rsp], 0
  0011b	75 11		 jne	 SHORT $LN8@parse_sock

; 1185 :         sin->sin_addr.s_addr = INADDR_ANY;

  0011d	48 8b 44 24 60	 mov	 rax, QWORD PTR sin$[rsp]
  00122	c7 40 04 00 00
	00 00		 mov	 DWORD PTR [rax+4], 0
  00129	e9 a8 00 00 00	 jmp	 $LN9@parse_sock
$LN8@parse_sock:

; 1186 :     else
; 1187 :     {
; 1188 :         // (get ipaddr via host name)
; 1189 :         struct hostent* hostent = gethostbyname( host );

  0012e	48 8b 4c 24 68	 mov	 rcx, QWORD PTR host$[rsp]
  00133	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_gethostbyname
  00139	48 89 44 24 70	 mov	 QWORD PTR hostent$1[rsp], rax

; 1190 : 
; 1191 :         if (!hostent)

  0013e	48 83 7c 24 70
	00		 cmp	 QWORD PTR hostent$1[rsp], 0
  00144	75 7a		 jne	 SHORT $LN10@parse_sock

; 1192 :         {
; 1193 :             // "COMM: unable to determine %s from %s"
; 1194 :             WRMSG( HHC01016, "I", "IP address", host );

  00146	b9 01 00 00 00	 mov	 ecx, 1
  0014b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  00151	48 8b 4c 24 68	 mov	 rcx, QWORD PTR host$[rsp]
  00156	48 89 4c 24 40	 mov	 QWORD PTR [rsp+64], rcx
  0015b	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG178098
  00162	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  00167	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG178099
  0016e	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  00173	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG178100
  0017a	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  0017f	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00184	41 b9 03 00 00
	00		 mov	 r9d, 3
  0018a	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG178101
  00191	ba aa 04 00 00	 mov	 edx, 1194		; 000004aaH
  00196	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG178102
  0019d	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 1195 :             free( workspec );

  001a3	48 8b 4c 24 58	 mov	 rcx, QWORD PTR workspec$[rsp]
  001a8	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free

; 1196 :             free( sin );

  001ae	48 8b 4c 24 60	 mov	 rcx, QWORD PTR sin$[rsp]
  001b3	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free

; 1197 :             return NULL;

  001b9	33 c0		 xor	 eax, eax
  001bb	e9 04 01 00 00	 jmp	 $LN1@parse_sock
$LN10@parse_sock:

; 1198 :         }
; 1199 : 
; 1200 :         memcpy( &sin->sin_addr, *hostent->h_addr_list, sizeof( sin->sin_addr ));

  001c0	48 8b 44 24 70	 mov	 rax, QWORD PTR hostent$1[rsp]
  001c5	48 8b 40 18	 mov	 rax, QWORD PTR [rax+24]
  001c9	48 8b 00	 mov	 rax, QWORD PTR [rax]
  001cc	48 8b 4c 24 60	 mov	 rcx, QWORD PTR sin$[rsp]
  001d1	8b 00		 mov	 eax, DWORD PTR [rax]
  001d3	89 41 04	 mov	 DWORD PTR [rcx+4], eax
$LN9@parse_sock:

; 1201 :     }
; 1202 : 
; 1203 :     // Convert port to number
; 1204 : 
; 1205 :     if (isdigit( *port ))

  001d6	48 8b 44 24 50	 mov	 rax, QWORD PTR port$[rsp]
  001db	0f be 00	 movsx	 eax, BYTE PTR [rax]
  001de	8b c8		 mov	 ecx, eax
  001e0	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_isdigit
  001e6	85 c0		 test	 eax, eax
  001e8	74 22		 je	 SHORT $LN11@parse_sock

; 1206 :         sin->sin_port = htons( atoi( port ));

  001ea	48 8b 4c 24 50	 mov	 rcx, QWORD PTR port$[rsp]
  001ef	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_atoi
  001f5	0f b7 c8	 movzx	 ecx, ax
  001f8	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_htons
  001fe	48 8b 4c 24 60	 mov	 rcx, QWORD PTR sin$[rsp]
  00203	66 89 41 02	 mov	 WORD PTR [rcx+2], ax
  00207	e9 a8 00 00 00	 jmp	 $LN12@parse_sock
$LN11@parse_sock:

; 1207 :     else
; 1208 :     {
; 1209 :         // (get port number via service name)
; 1210 :         struct servent* servent = getservbyname( port, "tcp" );

  0020c	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG178105
  00213	48 8b 4c 24 50	 mov	 rcx, QWORD PTR port$[rsp]
  00218	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_getservbyname
  0021e	48 89 44 24 78	 mov	 QWORD PTR servent$2[rsp], rax

; 1211 : 
; 1212 :         if (!servent)

  00223	48 83 7c 24 78
	00		 cmp	 QWORD PTR servent$2[rsp], 0
  00229	75 77		 jne	 SHORT $LN13@parse_sock

; 1213 :         {
; 1214 :             // "COMM: unable to determine %s from %s"
; 1215 :             WRMSG( HHC01016, "I", "port number", port );

  0022b	b9 01 00 00 00	 mov	 ecx, 1
  00230	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  00236	48 8b 4c 24 50	 mov	 rcx, QWORD PTR port$[rsp]
  0023b	48 89 4c 24 40	 mov	 QWORD PTR [rsp+64], rcx
  00240	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG178107
  00247	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  0024c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG178108
  00253	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  00258	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG178109
  0025f	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00264	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00269	41 b9 03 00 00
	00		 mov	 r9d, 3
  0026f	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG178110
  00276	ba bf 04 00 00	 mov	 edx, 1215		; 000004bfH
  0027b	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG178111
  00282	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 1216 :             free( workspec );

  00288	48 8b 4c 24 58	 mov	 rcx, QWORD PTR workspec$[rsp]
  0028d	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free

; 1217 :             free( sin );

  00293	48 8b 4c 24 60	 mov	 rcx, QWORD PTR sin$[rsp]
  00298	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free

; 1218 :             return NULL;

  0029e	33 c0		 xor	 eax, eax
  002a0	eb 22		 jmp	 SHORT $LN1@parse_sock
$LN13@parse_sock:

; 1219 :         }
; 1220 : 
; 1221 :         sin->sin_port = servent->s_port;

  002a2	48 8b 44 24 60	 mov	 rax, QWORD PTR sin$[rsp]
  002a7	48 8b 4c 24 78	 mov	 rcx, QWORD PTR servent$2[rsp]
  002ac	0f b7 49 18	 movzx	 ecx, WORD PTR [rcx+24]
  002b0	66 89 48 02	 mov	 WORD PTR [rax+2], cx
$LN12@parse_sock:

; 1222 :     }
; 1223 : 
; 1224 :     free( workspec );

  002b4	48 8b 4c 24 58	 mov	 rcx, QWORD PTR workspec$[rsp]
  002b9	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free

; 1225 :     return sin;

  002bf	48 8b 44 24 60	 mov	 rax, QWORD PTR sin$[rsp]
$LN1@parse_sock:

; 1226 : }

  002c4	48 81 c4 88 00
	00 00		 add	 rsp, 136		; 00000088H
  002cb	c3		 ret	 0
parse_sockspec ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\console.c
_TEXT	SEGMENT
ac$ = 96
tv201 = 100
tv215 = 104
tv221 = 108
tv268 = 112
tv274 = 116
tv295 = 120
tv301 = 124
tv207 = 128
tv260 = 136
tv288 = 144
mask$1 = 152
__$ArrayPad$ = 168
dev$ = 192
argc$ = 200
argv$ = 208
constty_init_handler PROC

; 1021 : {

  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00009	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000e	57		 push	 rdi
  0000f	48 81 ec b0 00
	00 00		 sub	 rsp, 176		; 000000b0H
  00016	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  0001d	48 33 c4	 xor	 rax, rsp
  00020	48 89 84 24 a8
	00 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 1022 :     int ac=0;

  00028	c7 44 24 60 00
	00 00 00	 mov	 DWORD PTR ac$[rsp], 0

; 1023 : 
; 1024 :     /* Close the existing file in case we're re-initialising */
; 1025 :     if (dev->fd >= 0)

  00030	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00038	83 b8 ac 01 00
	00 00		 cmp	 DWORD PTR [rax+428], 0
  0003f	7c 1a		 jl	 SHORT $LN2@constty_in

; 1026 :         (dev->hnd->close)( dev );

  00041	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00049	48 8b 80 90 02
	00 00		 mov	 rax, QWORD PTR [rax+656]
  00050	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  00058	ff 50 10	 call	 QWORD PTR [rax+16]
$LN2@constty_in:

; 1027 : 
; 1028 :     /* reset excp count */
; 1029 :     dev->excps = 0;

  0005b	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00063	48 c7 80 00 06
	00 00 00 00 00
	00		 mov	 QWORD PTR [rax+1536], 0

; 1030 : 
; 1031 :     /* Indicate that this is a console device */
; 1032 :     dev->console = 1;

  0006e	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00076	8b 80 f8 05 00
	00		 mov	 eax, DWORD PTR [rax+1528]
  0007c	83 c8 10	 or	 eax, 16
  0007f	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  00087	89 81 f8 05 00
	00		 mov	 DWORD PTR [rcx+1528], eax

; 1033 : 
; 1034 :     /* Set number of sense bytes */
; 1035 :     dev->numsense = 1;

  0008d	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00095	c7 80 60 03 00
	00 01 00 00 00	 mov	 DWORD PTR [rax+864], 1

; 1036 : 
; 1037 :     /* Initialize device dependent fields */
; 1038 :     dev->keybdrem = 0;

  0009f	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  000a7	c7 80 c0 06 00
	00 00 00 00 00	 mov	 DWORD PTR [rax+1728], 0

; 1039 : 
; 1040 :     /* Set the size of the device buffer */
; 1041 :     dev->bufsize = BUFLEN_1052;

  000b1	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  000b9	c7 80 d8 01 00
	00 96 00 00 00	 mov	 DWORD PTR [rax+472], 150 ; 00000096H

; 1042 : 
; 1043 :     /* Assume we want to prompt */
; 1044 :     dev->prompt1052 = 1;

  000c3	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  000cb	8b 80 d4 06 00
	00		 mov	 eax, DWORD PTR [rax+1748]
  000d1	83 c8 04	 or	 eax, 4
  000d4	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  000dc	89 81 d4 06 00
	00		 mov	 DWORD PTR [rcx+1748], eax

; 1045 : 
; 1046 :     /* Is there an argument? */
; 1047 :     if (argc > 0)

  000e2	83 bc 24 c8 00
	00 00 00	 cmp	 DWORD PTR argc$[rsp], 0
  000ea	7e 5b		 jle	 SHORT $LN3@constty_in

; 1048 :     {
; 1049 :         /* Look at the argument and set noprompt flag if specified. */
; 1050 :         if (strcasecmp( argv[ac], "noprompt" ) == 0)

  000ec	48 63 44 24 60	 movsxd	 rax, DWORD PTR ac$[rsp]
  000f1	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG178033
  000f8	48 8b 8c 24 d0
	00 00 00	 mov	 rcx, QWORD PTR argv$[rsp]
  00100	48 8b 0c c1	 mov	 rcx, QWORD PTR [rcx+rax*8]
  00104	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__stricmp
  0010a	85 c0		 test	 eax, eax
  0010c	75 39		 jne	 SHORT $LN4@constty_in

; 1051 :         {
; 1052 :             dev->prompt1052 = 0;

  0010e	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00116	8b 80 d4 06 00
	00		 mov	 eax, DWORD PTR [rax+1748]
  0011c	83 e0 fb	 and	 eax, -5			; fffffffbH
  0011f	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  00127	89 81 d4 06 00
	00		 mov	 DWORD PTR [rcx+1748], eax

; 1053 : 
; 1054 :             ac++;

  0012d	8b 44 24 60	 mov	 eax, DWORD PTR ac$[rsp]
  00131	ff c0		 inc	 eax
  00133	89 44 24 60	 mov	 DWORD PTR ac$[rsp], eax

; 1055 :             argc--;

  00137	8b 84 24 c8 00
	00 00		 mov	 eax, DWORD PTR argc$[rsp]
  0013e	ff c8		 dec	 eax
  00140	89 84 24 c8 00
	00 00		 mov	 DWORD PTR argc$[rsp], eax
$LN4@constty_in:
$LN3@constty_in:

; 1056 :         }
; 1057 :         /* else it's a group name */
; 1058 :     }
; 1059 : 
; 1060 :     if (!sscanf( dev->typname, "%hx", &dev->devtype ))

  00147	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  0014f	48 83 c0 4a	 add	 rax, 74			; 0000004aH
  00153	4c 8b c0	 mov	 r8, rax
  00156	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG178035
  0015d	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00165	48 8b 48 50	 mov	 rcx, QWORD PTR [rax+80]
  00169	e8 00 00 00 00	 call	 sscanf
  0016e	85 c0		 test	 eax, eax
  00170	75 11		 jne	 SHORT $LN5@constty_in

; 1061 :         dev->devtype = 0x1052;

  00172	b8 52 10 00 00	 mov	 eax, 4178		; 00001052H
  00177	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  0017f	66 89 41 4a	 mov	 WORD PTR [rcx+74], ax
$LN5@constty_in:

; 1062 : 
; 1063 :     /* Initialize the device identifier bytes */
; 1064 :     dev->devid[0] = 0xFF;

  00183	b8 01 00 00 00	 mov	 eax, 1
  00188	48 6b c0 00	 imul	 rax, rax, 0
  0018c	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  00194	c6 84 01 68 04
	00 00 ff	 mov	 BYTE PTR [rcx+rax+1128], 255 ; 000000ffH

; 1065 :     dev->devid[1] = dev->devtype >> 8;

  0019c	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  001a4	0f b7 40 4a	 movzx	 eax, WORD PTR [rax+74]
  001a8	c1 f8 08	 sar	 eax, 8
  001ab	b9 01 00 00 00	 mov	 ecx, 1
  001b0	48 6b c9 01	 imul	 rcx, rcx, 1
  001b4	48 8b 94 24 c0
	00 00 00	 mov	 rdx, QWORD PTR dev$[rsp]
  001bc	88 84 0a 68 04
	00 00		 mov	 BYTE PTR [rdx+rcx+1128], al

; 1066 :     dev->devid[2] = dev->devtype & 0xFF;

  001c3	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  001cb	0f b7 40 4a	 movzx	 eax, WORD PTR [rax+74]
  001cf	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  001d4	b9 01 00 00 00	 mov	 ecx, 1
  001d9	48 6b c9 02	 imul	 rcx, rcx, 2
  001dd	48 8b 94 24 c0
	00 00 00	 mov	 rdx, QWORD PTR dev$[rsp]
  001e5	88 84 0a 68 04
	00 00		 mov	 BYTE PTR [rdx+rcx+1128], al

; 1067 :     dev->devid[3] = 0x00;

  001ec	b8 01 00 00 00	 mov	 eax, 1
  001f1	48 6b c0 03	 imul	 rax, rax, 3
  001f5	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  001fd	c6 84 01 68 04
	00 00 00	 mov	 BYTE PTR [rcx+rax+1128], 0

; 1068 :     dev->devid[4] = dev->devtype >> 8;

  00205	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  0020d	0f b7 40 4a	 movzx	 eax, WORD PTR [rax+74]
  00211	c1 f8 08	 sar	 eax, 8
  00214	b9 01 00 00 00	 mov	 ecx, 1
  00219	48 6b c9 04	 imul	 rcx, rcx, 4
  0021d	48 8b 94 24 c0
	00 00 00	 mov	 rdx, QWORD PTR dev$[rsp]
  00225	88 84 0a 68 04
	00 00		 mov	 BYTE PTR [rdx+rcx+1128], al

; 1069 :     dev->devid[5] = dev->devtype & 0xFF;

  0022c	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00234	0f b7 40 4a	 movzx	 eax, WORD PTR [rax+74]
  00238	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  0023d	b9 01 00 00 00	 mov	 ecx, 1
  00242	48 6b c9 05	 imul	 rcx, rcx, 5
  00246	48 8b 94 24 c0
	00 00 00	 mov	 rdx, QWORD PTR dev$[rsp]
  0024e	88 84 0a 68 04
	00 00		 mov	 BYTE PTR [rdx+rcx+1128], al

; 1070 :     dev->devid[6] = 0x00;

  00255	b8 01 00 00 00	 mov	 eax, 1
  0025a	48 6b c0 06	 imul	 rax, rax, 6
  0025e	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  00266	c6 84 01 68 04
	00 00 00	 mov	 BYTE PTR [rcx+rax+1128], 0

; 1071 :     dev->numdevid = 7;

  0026e	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00276	c7 80 64 04 00
	00 07 00 00 00	 mov	 DWORD PTR [rax+1124], 7

; 1072 : 
; 1073 :     dev->filename[0] = 0;

  00280	b8 01 00 00 00	 mov	 eax, 1
  00285	48 6b c0 00	 imul	 rax, rax, 0
  00289	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  00291	c6 84 01 a4 00
	00 00 00	 mov	 BYTE PTR [rcx+rax+164], 0

; 1074 :     dev->acc_ipaddr  = 0;

  00299	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  002a1	c7 80 a4 06 00
	00 00 00 00 00	 mov	 DWORD PTR [rax+1700], 0

; 1075 :     dev->acc_ipmask  = 0;

  002ab	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  002b3	c7 80 a8 06 00
	00 00 00 00 00	 mov	 DWORD PTR [rax+1704], 0

; 1076 : 
; 1077 :     if (argc > 0)   // group name?

  002bd	83 bc 24 c8 00
	00 00 00	 cmp	 DWORD PTR argc$[rsp], 0
  002c5	0f 8e 54 04 00
	00		 jle	 $LN6@constty_in

; 1078 :     {
; 1079 :         if ('*' == argv[ac][0] && '\0' == argv[ac][1])

  002cb	48 63 44 24 60	 movsxd	 rax, DWORD PTR ac$[rsp]
  002d0	b9 01 00 00 00	 mov	 ecx, 1
  002d5	48 6b c9 00	 imul	 rcx, rcx, 0
  002d9	48 8b 94 24 d0
	00 00 00	 mov	 rdx, QWORD PTR argv$[rsp]
  002e1	48 8b 04 c2	 mov	 rax, QWORD PTR [rdx+rax*8]
  002e5	0f be 04 08	 movsx	 eax, BYTE PTR [rax+rcx]
  002e9	83 f8 2a	 cmp	 eax, 42			; 0000002aH
  002ec	75 24		 jne	 SHORT $LN7@constty_in
  002ee	48 63 44 24 60	 movsxd	 rax, DWORD PTR ac$[rsp]
  002f3	b9 01 00 00 00	 mov	 ecx, 1
  002f8	48 6b c9 01	 imul	 rcx, rcx, 1
  002fc	48 8b 94 24 d0
	00 00 00	 mov	 rdx, QWORD PTR argv$[rsp]
  00304	48 8b 04 c2	 mov	 rax, QWORD PTR [rdx+rax*8]
  00308	0f be 04 08	 movsx	 eax, BYTE PTR [rax+rcx]
  0030c	85 c0		 test	 eax, eax
  0030e	75 02		 jne	 SHORT $LN7@constty_in

; 1080 :             ;   // NOP (not really a group name; an '*' is

  00310	eb 2c		 jmp	 SHORT $LN8@constty_in
$LN7@constty_in:

; 1081 :                 // simply used as an argument place holder)
; 1082 :         else
; 1083 :             STRLCPY( dev->filename, argv[ac] );

  00312	48 63 44 24 60	 movsxd	 rax, DWORD PTR ac$[rsp]
  00317	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  0031f	48 81 c1 a4 00
	00 00		 add	 rcx, 164		; 000000a4H
  00326	41 b8 05 01 00
	00		 mov	 r8d, 261		; 00000105H
  0032c	48 8b 94 24 d0
	00 00 00	 mov	 rdx, QWORD PTR argv$[rsp]
  00334	48 8b 14 c2	 mov	 rdx, QWORD PTR [rdx+rax*8]
  00338	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_strlcpy
$LN8@constty_in:

; 1084 : 
; 1085 :         argc--;

  0033e	8b 84 24 c8 00
	00 00		 mov	 eax, DWORD PTR argc$[rsp]
  00345	ff c8		 dec	 eax
  00347	89 84 24 c8 00
	00 00		 mov	 DWORD PTR argc$[rsp], eax

; 1086 :         ac++;

  0034e	8b 44 24 60	 mov	 eax, DWORD PTR ac$[rsp]
  00352	ff c0		 inc	 eax
  00354	89 44 24 60	 mov	 DWORD PTR ac$[rsp], eax

; 1087 : 
; 1088 :         if (argc > 0)   // ip address?

  00358	83 bc 24 c8 00
	00 00 00	 cmp	 DWORD PTR argc$[rsp], 0
  00360	0f 8e b9 03 00
	00		 jle	 $LN9@constty_in

; 1089 :         {
; 1090 :             if ((dev->acc_ipaddr = inet_addr( argv[ac] )) == (in_addr_t)(-1))

  00366	48 63 44 24 60	 movsxd	 rax, DWORD PTR ac$[rsp]
  0036b	48 8b 8c 24 d0
	00 00 00	 mov	 rcx, QWORD PTR argv$[rsp]
  00373	48 8b 0c c1	 mov	 rcx, QWORD PTR [rcx+rax*8]
  00377	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_inet_addr
  0037d	89 44 24 64	 mov	 DWORD PTR tv201[rsp], eax
  00381	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00389	8b 4c 24 64	 mov	 ecx, DWORD PTR tv201[rsp]
  0038d	89 88 a4 06 00
	00		 mov	 DWORD PTR [rax+1700], ecx
  00393	83 7c 24 64 ff	 cmp	 DWORD PTR tv201[rsp], -1 ; ffffffffH
  00398	0f 85 e4 00 00
	00		 jne	 $LN10@constty_in

; 1091 :             {
; 1092 :                 // "%1d:%04X COMM: option %s value %s invalid"
; 1093 :                 WRMSG( HHC01007, "E", LCSS_DEVNUM, "IP address", argv[ac] );

  0039e	48 83 bc 24 c0
	00 00 00 00	 cmp	 QWORD PTR dev$[rsp], 0
  003a7	74 12		 je	 SHORT $LN18@constty_in
  003a9	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  003b1	0f b7 40 48	 movzx	 eax, WORD PTR [rax+72]
  003b5	89 44 24 68	 mov	 DWORD PTR tv215[rsp], eax
  003b9	eb 08		 jmp	 SHORT $LN19@constty_in
$LN18@constty_in:
  003bb	c7 44 24 68 00
	00 00 00	 mov	 DWORD PTR tv215[rsp], 0
$LN19@constty_in:
  003c3	48 83 bc 24 c0
	00 00 00 00	 cmp	 QWORD PTR dev$[rsp], 0
  003cc	74 14		 je	 SHORT $LN20@constty_in
  003ce	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  003d6	0f b7 40 44	 movzx	 eax, WORD PTR [rax+68]
  003da	d1 f8		 sar	 eax, 1
  003dc	89 44 24 6c	 mov	 DWORD PTR tv221[rsp], eax
  003e0	eb 08		 jmp	 SHORT $LN21@constty_in
$LN20@constty_in:
  003e2	c7 44 24 6c 00
	00 00 00	 mov	 DWORD PTR tv221[rsp], 0
$LN21@constty_in:
  003ea	48 63 44 24 60	 movsxd	 rax, DWORD PTR ac$[rsp]
  003ef	48 89 84 24 80
	00 00 00	 mov	 QWORD PTR tv207[rsp], rax
  003f7	b9 01 00 00 00	 mov	 ecx, 1
  003fc	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  00402	48 8b 8c 24 d0
	00 00 00	 mov	 rcx, QWORD PTR argv$[rsp]
  0040a	48 8b 94 24 80
	00 00 00	 mov	 rdx, QWORD PTR tv207[rsp]
  00412	48 8b 0c d1	 mov	 rcx, QWORD PTR [rcx+rdx*8]
  00416	48 89 4c 24 50	 mov	 QWORD PTR [rsp+80], rcx
  0041b	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG178042
  00422	48 89 4c 24 48	 mov	 QWORD PTR [rsp+72], rcx
  00427	8b 4c 24 68	 mov	 ecx, DWORD PTR tv215[rsp]
  0042b	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  0042f	8b 4c 24 6c	 mov	 ecx, DWORD PTR tv221[rsp]
  00433	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  00437	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG178043
  0043e	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  00443	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG178044
  0044a	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  0044f	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00454	41 b9 03 00 00
	00		 mov	 r9d, 3
  0045a	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG178045
  00461	ba 45 04 00 00	 mov	 edx, 1093		; 00000445H
  00466	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG178046
  0046d	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 1094 :                 return -1;

  00473	b8 ff ff ff ff	 mov	 eax, -1
  00478	e9 af 02 00 00	 jmp	 $LN1@constty_in

; 1095 :             }

  0047d	e9 9d 02 00 00	 jmp	 $LN11@constty_in
$LN10@constty_in:

; 1096 :             else
; 1097 :             {
; 1098 :                 argc--;

  00482	8b 84 24 c8 00
	00 00		 mov	 eax, DWORD PTR argc$[rsp]
  00489	ff c8		 dec	 eax
  0048b	89 84 24 c8 00
	00 00		 mov	 DWORD PTR argc$[rsp], eax

; 1099 :                 ac++;

  00492	8b 44 24 60	 mov	 eax, DWORD PTR ac$[rsp]
  00496	ff c0		 inc	 eax
  00498	89 44 24 60	 mov	 DWORD PTR ac$[rsp], eax

; 1100 : 
; 1101 :                 if (argc <= 0)   // ip addr mask?

  0049c	83 bc 24 c8 00
	00 00 00	 cmp	 DWORD PTR argc$[rsp], 0
  004a4	7f 17		 jg	 SHORT $LN12@constty_in

; 1102 :                     dev->acc_ipmask = (in_addr_t)(-1);

  004a6	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  004ae	c7 80 a8 06 00
	00 ff ff ff ff	 mov	 DWORD PTR [rax+1704], -1 ; ffffffffH
  004b8	e9 62 02 00 00	 jmp	 $LN13@constty_in
$LN12@constty_in:

; 1103 :                 else
; 1104 :                 {
; 1105 :                     char mask[16] = {0};

  004bd	48 8d 84 24 98
	00 00 00	 lea	 rax, QWORD PTR mask$1[rsp]
  004c5	48 8b f8	 mov	 rdi, rax
  004c8	33 c0		 xor	 eax, eax
  004ca	b9 10 00 00 00	 mov	 ecx, 16
  004cf	f3 aa		 rep stosb

; 1106 :                     static const char* badmask = "0.0.0.0";
; 1107 : 
; 1108 :                     if (0
; 1109 :                         || inet_pton( AF_INET, argv[ac], &dev->acc_ipmask ) <= 0
; 1110 :                         || str_eq( badmask, inet_ntop( AF_INET, &dev->acc_ipmask,

  004d1	33 c0		 xor	 eax, eax
  004d3	85 c0		 test	 eax, eax
  004d5	75 71		 jne	 SHORT $LN15@constty_in
  004d7	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  004df	48 05 a8 06 00
	00		 add	 rax, 1704		; 000006a8H
  004e5	48 63 4c 24 60	 movsxd	 rcx, DWORD PTR ac$[rsp]
  004ea	4c 8b c0	 mov	 r8, rax
  004ed	48 8b 84 24 d0
	00 00 00	 mov	 rax, QWORD PTR argv$[rsp]
  004f5	48 8b 14 c8	 mov	 rdx, QWORD PTR [rax+rcx*8]
  004f9	b9 02 00 00 00	 mov	 ecx, 2
  004fe	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_inet_pton
  00504	85 c0		 test	 eax, eax
  00506	7e 40		 jle	 SHORT $LN15@constty_in
  00508	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00510	48 05 a8 06 00
	00		 add	 rax, 1704		; 000006a8H
  00516	41 b9 10 00 00
	00		 mov	 r9d, 16
  0051c	4c 8d 84 24 98
	00 00 00	 lea	 r8, QWORD PTR mask$1[rsp]
  00524	48 8b d0	 mov	 rdx, rax
  00527	b9 02 00 00 00	 mov	 ecx, 2
  0052c	e8 00 00 00 00	 call	 inet_ntop
  00531	48 8b d0	 mov	 rdx, rax
  00534	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR ?badmask@?8??constty_init_handler@@9@9
  0053b	e8 00 00 00 00	 call	 strcmp
  00540	85 c0		 test	 eax, eax
  00542	0f 85 df 00 00
	00		 jne	 $LN14@constty_in
$LN15@constty_in:

; 1111 :                                    mask, (int) sizeof( mask )))
; 1112 :                     )
; 1113 :                     {
; 1114 :                         // "%1d:%04X COMM: option %s value %s invalid"
; 1115 :                         WRMSG( HHC01007, "E", LCSS_DEVNUM, "mask", argv[ac] );

  00548	48 83 bc 24 c0
	00 00 00 00	 cmp	 QWORD PTR dev$[rsp], 0
  00551	74 12		 je	 SHORT $LN22@constty_in
  00553	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  0055b	0f b7 40 48	 movzx	 eax, WORD PTR [rax+72]
  0055f	89 44 24 70	 mov	 DWORD PTR tv268[rsp], eax
  00563	eb 08		 jmp	 SHORT $LN23@constty_in
$LN22@constty_in:
  00565	c7 44 24 70 00
	00 00 00	 mov	 DWORD PTR tv268[rsp], 0
$LN23@constty_in:
  0056d	48 83 bc 24 c0
	00 00 00 00	 cmp	 QWORD PTR dev$[rsp], 0
  00576	74 14		 je	 SHORT $LN24@constty_in
  00578	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00580	0f b7 40 44	 movzx	 eax, WORD PTR [rax+68]
  00584	d1 f8		 sar	 eax, 1
  00586	89 44 24 74	 mov	 DWORD PTR tv274[rsp], eax
  0058a	eb 08		 jmp	 SHORT $LN25@constty_in
$LN24@constty_in:
  0058c	c7 44 24 74 00
	00 00 00	 mov	 DWORD PTR tv274[rsp], 0
$LN25@constty_in:
  00594	48 63 44 24 60	 movsxd	 rax, DWORD PTR ac$[rsp]
  00599	48 89 84 24 88
	00 00 00	 mov	 QWORD PTR tv260[rsp], rax
  005a1	b9 01 00 00 00	 mov	 ecx, 1
  005a6	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  005ac	48 8b 8c 24 d0
	00 00 00	 mov	 rcx, QWORD PTR argv$[rsp]
  005b4	48 8b 94 24 88
	00 00 00	 mov	 rdx, QWORD PTR tv260[rsp]
  005bc	48 8b 0c d1	 mov	 rcx, QWORD PTR [rcx+rdx*8]
  005c0	48 89 4c 24 50	 mov	 QWORD PTR [rsp+80], rcx
  005c5	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG178052
  005cc	48 89 4c 24 48	 mov	 QWORD PTR [rsp+72], rcx
  005d1	8b 4c 24 70	 mov	 ecx, DWORD PTR tv268[rsp]
  005d5	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  005d9	8b 4c 24 74	 mov	 ecx, DWORD PTR tv274[rsp]
  005dd	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  005e1	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG178053
  005e8	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  005ed	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG178054
  005f4	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  005f9	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  005fe	41 b9 03 00 00
	00		 mov	 r9d, 3
  00604	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG178055
  0060b	ba 5b 04 00 00	 mov	 edx, 1115		; 0000045bH
  00610	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG178056
  00617	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 1116 :                         return -1;

  0061d	b8 ff ff ff ff	 mov	 eax, -1
  00622	e9 05 01 00 00	 jmp	 $LN1@constty_in
$LN14@constty_in:

; 1117 :                     }
; 1118 : 
; 1119 :                     argc--;

  00627	8b 84 24 c8 00
	00 00		 mov	 eax, DWORD PTR argc$[rsp]
  0062e	ff c8		 dec	 eax
  00630	89 84 24 c8 00
	00 00		 mov	 DWORD PTR argc$[rsp], eax

; 1120 :                     ac++;

  00637	8b 44 24 60	 mov	 eax, DWORD PTR ac$[rsp]
  0063b	ff c0		 inc	 eax
  0063d	89 44 24 60	 mov	 DWORD PTR ac$[rsp], eax

; 1121 : 
; 1122 :                     if (argc > 0)   // too many args?

  00641	83 bc 24 c8 00
	00 00 00	 cmp	 DWORD PTR argc$[rsp], 0
  00649	0f 8e d0 00 00
	00		 jle	 $LN16@constty_in

; 1123 :                     {
; 1124 :                         // "%1d:%04X COMM: unrecognized parameter %s"
; 1125 :                         WRMSG( HHC01019, "E", LCSS_DEVNUM, argv[ac] );

  0064f	48 83 bc 24 c0
	00 00 00 00	 cmp	 QWORD PTR dev$[rsp], 0
  00658	74 12		 je	 SHORT $LN26@constty_in
  0065a	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00662	0f b7 40 48	 movzx	 eax, WORD PTR [rax+72]
  00666	89 44 24 78	 mov	 DWORD PTR tv295[rsp], eax
  0066a	eb 08		 jmp	 SHORT $LN27@constty_in
$LN26@constty_in:
  0066c	c7 44 24 78 00
	00 00 00	 mov	 DWORD PTR tv295[rsp], 0
$LN27@constty_in:
  00674	48 83 bc 24 c0
	00 00 00 00	 cmp	 QWORD PTR dev$[rsp], 0
  0067d	74 14		 je	 SHORT $LN28@constty_in
  0067f	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00687	0f b7 40 44	 movzx	 eax, WORD PTR [rax+68]
  0068b	d1 f8		 sar	 eax, 1
  0068d	89 44 24 7c	 mov	 DWORD PTR tv301[rsp], eax
  00691	eb 08		 jmp	 SHORT $LN29@constty_in
$LN28@constty_in:
  00693	c7 44 24 7c 00
	00 00 00	 mov	 DWORD PTR tv301[rsp], 0
$LN29@constty_in:
  0069b	48 63 44 24 60	 movsxd	 rax, DWORD PTR ac$[rsp]
  006a0	48 89 84 24 90
	00 00 00	 mov	 QWORD PTR tv288[rsp], rax
  006a8	b9 01 00 00 00	 mov	 ecx, 1
  006ad	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  006b3	48 8b 8c 24 d0
	00 00 00	 mov	 rcx, QWORD PTR argv$[rsp]
  006bb	48 8b 94 24 90
	00 00 00	 mov	 rdx, QWORD PTR tv288[rsp]
  006c3	48 8b 0c d1	 mov	 rcx, QWORD PTR [rcx+rdx*8]
  006c7	48 89 4c 24 48	 mov	 QWORD PTR [rsp+72], rcx
  006cc	8b 4c 24 78	 mov	 ecx, DWORD PTR tv295[rsp]
  006d0	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  006d4	8b 4c 24 7c	 mov	 ecx, DWORD PTR tv301[rsp]
  006d8	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  006dc	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG178058
  006e3	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  006e8	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG178059
  006ef	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  006f4	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  006f9	41 b9 03 00 00
	00		 mov	 r9d, 3
  006ff	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG178060
  00706	ba 65 04 00 00	 mov	 edx, 1125		; 00000465H
  0070b	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG178061
  00712	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 1126 :                         return -1;

  00718	b8 ff ff ff ff	 mov	 eax, -1
  0071d	eb 0d		 jmp	 SHORT $LN1@constty_in
$LN16@constty_in:
$LN13@constty_in:
$LN11@constty_in:
$LN9@constty_in:
$LN6@constty_in:

; 1127 :                     }
; 1128 :                 }
; 1129 :             }
; 1130 :         }
; 1131 :     }
; 1132 : 
; 1133 :     return finish_console_init( dev );

  0071f	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  00727	e8 00 00 00 00	 call	 finish_console_init
$LN1@constty_in:

; 1134 : 
; 1135 : } /* end function constty_init_handler */

  0072c	48 8b 8c 24 a8
	00 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  00734	48 33 cc	 xor	 rcx, rsp
  00737	e8 00 00 00 00	 call	 __security_check_cookie
  0073c	48 81 c4 b0 00
	00 00		 add	 rsp, 176		; 000000b0H
  00743	5f		 pop	 rdi
  00744	c3		 ret	 0
constty_init_handler ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\console.c
_TEXT	SEGMENT
ac$ = 96
dt$ = 100
i$1 = 104
rc$2 = 108
tv128 = 112
tv134 = 116
tv224 = 120
tv230 = 124
tv277 = 128
tv283 = 132
tv298 = 136
tv312 = 140
tv318 = 144
tv365 = 148
tv371 = 152
tv392 = 156
tv398 = 160
tv217 = 168
tv266 = 176
tv304 = 184
tv357 = 192
tv385 = 200
group$3 = 208
mask$4 = 224
__$ArrayPad$ = 240
dev$ = 272
argc$ = 280
argv$ = 288
loc3270_init_handler PROC

; 846  : {

  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00009	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000e	57		 push	 rdi
  0000f	48 81 ec 00 01
	00 00		 sub	 rsp, 256		; 00000100H
  00016	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  0001d	48 33 c4	 xor	 rax, rsp
  00020	48 89 84 24 f0
	00 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 847  :     int ac = 0;

  00028	c7 44 24 60 00
	00 00 00	 mov	 DWORD PTR ac$[rsp], 0

; 848  :     BYTE dt;
; 849  : 
; 850  :     /* Close the existing file in case we're re-initialising */
; 851  :     if (dev->fd >= 0)

  00030	48 8b 84 24 10
	01 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00038	83 b8 ac 01 00
	00 00		 cmp	 DWORD PTR [rax+428], 0
  0003f	7c 1a		 jl	 SHORT $LN5@loc3270_in

; 852  :         (dev->hnd->close)( dev );

  00041	48 8b 84 24 10
	01 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00049	48 8b 80 90 02
	00 00		 mov	 rax, QWORD PTR [rax+656]
  00050	48 8b 8c 24 10
	01 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  00058	ff 50 10	 call	 QWORD PTR [rax+16]
$LN5@loc3270_in:

; 853  : 
; 854  :     /* reset excp count */
; 855  :     dev->excps = 0;

  0005b	48 8b 84 24 10
	01 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00063	48 c7 80 00 06
	00 00 00 00 00
	00		 mov	 QWORD PTR [rax+1536], 0

; 856  : 
; 857  :     /* Indicate that this is a console device */
; 858  :     dev->console = 1;

  0006e	48 8b 84 24 10
	01 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00076	8b 80 f8 05 00
	00		 mov	 eax, DWORD PTR [rax+1528]
  0007c	83 c8 10	 or	 eax, 16
  0007f	48 8b 8c 24 10
	01 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  00087	89 81 f8 05 00
	00		 mov	 DWORD PTR [rcx+1528], eax

; 859  : 
; 860  :     /* Reset device dependent flags */
; 861  :     dev->connected = 0;

  0008d	48 8b 84 24 10
	01 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00095	8b 80 f8 05 00
	00		 mov	 eax, DWORD PTR [rax+1528]
  0009b	83 e0 df	 and	 eax, -33		; ffffffdfH
  0009e	48 8b 8c 24 10
	01 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  000a6	89 81 f8 05 00
	00		 mov	 DWORD PTR [rcx+1528], eax

; 862  : 
; 863  :     /* Set number of sense bytes */
; 864  :     dev->numsense = 1;

  000ac	48 8b 84 24 10
	01 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  000b4	c7 80 60 03 00
	00 01 00 00 00	 mov	 DWORD PTR [rax+864], 1

; 865  : 
; 866  :     /* Set the size of the device buffer */
; 867  :     dev->bufsize = BUFLEN_3270;

  000be	48 8b 84 24 10
	01 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  000c6	c7 80 d8 01 00
	00 00 00 01 00	 mov	 DWORD PTR [rax+472], 65536 ; 00010000H

; 868  : 
; 869  :     if (!sscanf( dev->typname, "%hx", &dev->devtype ))

  000d0	48 8b 84 24 10
	01 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  000d8	48 83 c0 4a	 add	 rax, 74			; 0000004aH
  000dc	4c 8b c0	 mov	 r8, rax
  000df	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG177963
  000e6	48 8b 84 24 10
	01 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  000ee	48 8b 48 50	 mov	 rcx, QWORD PTR [rax+80]
  000f2	e8 00 00 00 00	 call	 sscanf
  000f7	85 c0		 test	 eax, eax
  000f9	75 11		 jne	 SHORT $LN6@loc3270_in

; 870  :         dev->devtype = 0x3270;

  000fb	b8 70 32 00 00	 mov	 eax, 12912		; 00003270H
  00100	48 8b 8c 24 10
	01 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  00108	66 89 41 4a	 mov	 WORD PTR [rcx+74], ax
$LN6@loc3270_in:

; 871  : 
; 872  : #if defined( _FEATURE_INTEGRATED_3270_CONSOLE )
; 873  : 
; 874  :     /* Extra initialisation for the SYSG console */
; 875  :     if (strcasecmp( dev->typname, "SYSG" ) == 0)

  0010c	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG177965
  00113	48 8b 84 24 10
	01 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  0011b	48 8b 48 50	 mov	 rcx, QWORD PTR [rax+80]
  0011f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__stricmp
  00125	85 c0		 test	 eax, eax
  00127	0f 85 e2 00 00
	00		 jne	 $LN7@loc3270_in

; 876  :     {
; 877  :         if (sysblk.sysgdev != NULL)

  0012d	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00134	48 83 b8 c8 11
	00 00 00	 cmp	 QWORD PTR [rax+4552], 0
  0013c	0f 84 ad 00 00
	00		 je	 $LN8@loc3270_in

; 878  :         {
; 879  :             // "%1d:%04X COMM: duplicate SYSG console definition"
; 880  :             WRMSG( HHC01025, "E", LCSS_DEVNUM );

  00142	48 83 bc 24 10
	01 00 00 00	 cmp	 QWORD PTR dev$[rsp], 0
  0014b	74 12		 je	 SHORT $LN30@loc3270_in
  0014d	48 8b 84 24 10
	01 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00155	0f b7 40 48	 movzx	 eax, WORD PTR [rax+72]
  00159	89 44 24 70	 mov	 DWORD PTR tv128[rsp], eax
  0015d	eb 08		 jmp	 SHORT $LN31@loc3270_in
$LN30@loc3270_in:
  0015f	c7 44 24 70 00
	00 00 00	 mov	 DWORD PTR tv128[rsp], 0
$LN31@loc3270_in:
  00167	48 83 bc 24 10
	01 00 00 00	 cmp	 QWORD PTR dev$[rsp], 0
  00170	74 14		 je	 SHORT $LN32@loc3270_in
  00172	48 8b 84 24 10
	01 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  0017a	0f b7 40 44	 movzx	 eax, WORD PTR [rax+68]
  0017e	d1 f8		 sar	 eax, 1
  00180	89 44 24 74	 mov	 DWORD PTR tv134[rsp], eax
  00184	eb 08		 jmp	 SHORT $LN33@loc3270_in
$LN32@loc3270_in:
  00186	c7 44 24 74 00
	00 00 00	 mov	 DWORD PTR tv134[rsp], 0
$LN33@loc3270_in:
  0018e	b9 01 00 00 00	 mov	 ecx, 1
  00193	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  00199	8b 4c 24 70	 mov	 ecx, DWORD PTR tv128[rsp]
  0019d	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  001a1	8b 4c 24 74	 mov	 ecx, DWORD PTR tv134[rsp]
  001a5	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  001a9	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG177967
  001b0	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  001b5	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG177968
  001bc	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  001c1	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  001c6	41 b9 03 00 00
	00		 mov	 r9d, 3
  001cc	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG177969
  001d3	ba 70 03 00 00	 mov	 edx, 880		; 00000370H
  001d8	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG177970
  001df	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 881  :             return -1;

  001e5	b8 ff ff ff ff	 mov	 eax, -1
  001ea	e9 f0 08 00 00	 jmp	 $LN1@loc3270_in
$LN8@loc3270_in:

; 882  :         }
; 883  : 
; 884  :         dev->pmcw.flag5 &= ~PMCW5_V;  // (not a regular device)

  001ef	48 8b 84 24 10
	01 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  001f7	0f b6 80 f1 02
	00 00		 movzx	 eax, BYTE PTR [rax+753]
  001fe	83 e0 fe	 and	 eax, -2
  00201	48 8b 8c 24 10
	01 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  00209	88 81 f1 02 00
	00		 mov	 BYTE PTR [rcx+753], al
$LN7@loc3270_in:

; 885  :     }
; 886  : #endif
; 887  : 
; 888  :     /* Initialize the device identifier bytes */
; 889  : 
; 890  :     dev->devid[0] = 0xFF;       /* First byte is always 0xFF */

  0020f	b8 01 00 00 00	 mov	 eax, 1
  00214	48 6b c0 00	 imul	 rax, rax, 0
  00218	48 8b 8c 24 10
	01 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  00220	c6 84 01 68 04
	00 00 ff	 mov	 BYTE PTR [rcx+rax+1128], 255 ; 000000ffH

; 891  : 
; 892  :     dev->devid[1] = 0x32;       /* Control unit type is 3274-1D */

  00228	b8 01 00 00 00	 mov	 eax, 1
  0022d	48 6b c0 01	 imul	 rax, rax, 1
  00231	48 8b 8c 24 10
	01 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  00239	c6 84 01 68 04
	00 00 32	 mov	 BYTE PTR [rcx+rax+1128], 50 ; 00000032H

; 893  :     dev->devid[2] = 0x74;       /* Control unit type is 3274-1D */

  00241	b8 01 00 00 00	 mov	 eax, 1
  00246	48 6b c0 02	 imul	 rax, rax, 2
  0024a	48 8b 8c 24 10
	01 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  00252	c6 84 01 68 04
	00 00 74	 mov	 BYTE PTR [rcx+rax+1128], 116 ; 00000074H

; 894  :     dev->devid[3] = 0x1D;       /* Control unit type is 3274-1D */

  0025a	b8 01 00 00 00	 mov	 eax, 1
  0025f	48 6b c0 03	 imul	 rax, rax, 3
  00263	48 8b 8c 24 10
	01 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  0026b	c6 84 01 68 04
	00 00 1d	 mov	 BYTE PTR [rcx+rax+1128], 29

; 895  : 
; 896  :     dev->devid[4] = 0x32;       /* Device type major */

  00273	b8 01 00 00 00	 mov	 eax, 1
  00278	48 6b c0 04	 imul	 rax, rax, 4
  0027c	48 8b 8c 24 10
	01 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  00284	c6 84 01 68 04
	00 00 32	 mov	 BYTE PTR [rcx+rax+1128], 50 ; 00000032H

; 897  :     dt = (dev->devtype & 0xFF); /* Device type minor */

  0028c	48 8b 84 24 10
	01 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00294	0f b7 40 4a	 movzx	 eax, WORD PTR [rax+74]
  00298	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  0029d	88 44 24 64	 mov	 BYTE PTR dt$[rsp], al

; 898  : 
; 899  :     if (dt == 0x70)             /* Device statement type = 3270? */

  002a1	0f b6 44 24 64	 movzx	 eax, BYTE PTR dt$[rsp]
  002a6	83 f8 70	 cmp	 eax, 112		; 00000070H
  002a9	75 34		 jne	 SHORT $LN9@loc3270_in

; 900  :     {
; 901  :         dev->devid[5] = 0x78;   /* then it's a 3278-2 by default */

  002ab	b8 01 00 00 00	 mov	 eax, 1
  002b0	48 6b c0 05	 imul	 rax, rax, 5
  002b4	48 8b 8c 24 10
	01 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  002bc	c6 84 01 68 04
	00 00 78	 mov	 BYTE PTR [rcx+rax+1128], 120 ; 00000078H

; 902  :         dev->devid[6] = 0x02;   /* then it's a 3278-2 by default */

  002c4	b8 01 00 00 00	 mov	 eax, 1
  002c9	48 6b c0 06	 imul	 rax, rax, 6
  002cd	48 8b 8c 24 10
	01 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  002d5	c6 84 01 68 04
	00 00 02	 mov	 BYTE PTR [rcx+rax+1128], 2

; 903  :     }

  002dd	eb 36		 jmp	 SHORT $LN10@loc3270_in
$LN9@loc3270_in:

; 904  :     else
; 905  :     {
; 906  :         /* Not a 3270 display. Use the device type
; 907  :            they specified on their device statement,
; 908  :            e.g. 3287, and force it to be a model 1.
; 909  :         */
; 910  :         dev->devid[5] = dt;     /* Device statement type */

  002df	b8 01 00 00 00	 mov	 eax, 1
  002e4	48 6b c0 05	 imul	 rax, rax, 5
  002e8	48 8b 8c 24 10
	01 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  002f0	0f b6 54 24 64	 movzx	 edx, BYTE PTR dt$[rsp]
  002f5	88 94 01 68 04
	00 00		 mov	 BYTE PTR [rcx+rax+1128], dl

; 911  :         dev->devid[6] = 0x01;   /* Model 1 */

  002fc	b8 01 00 00 00	 mov	 eax, 1
  00301	48 6b c0 06	 imul	 rax, rax, 6
  00305	48 8b 8c 24 10
	01 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  0030d	c6 84 01 68 04
	00 00 01	 mov	 BYTE PTR [rcx+rax+1128], 1
$LN10@loc3270_in:

; 912  :     }
; 913  :     dev->numdevid = 7;

  00315	48 8b 84 24 10
	01 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  0031d	c7 80 64 04 00
	00 07 00 00 00	 mov	 DWORD PTR [rax+1124], 7

; 914  : 
; 915  :     dev->filename[0] = 0;

  00327	b8 01 00 00 00	 mov	 eax, 1
  0032c	48 6b c0 00	 imul	 rax, rax, 0
  00330	48 8b 8c 24 10
	01 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  00338	c6 84 01 a4 00
	00 00 00	 mov	 BYTE PTR [rcx+rax+164], 0

; 916  :     dev->acc_ipaddr  = 0;

  00340	48 8b 84 24 10
	01 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00348	c7 80 a4 06 00
	00 00 00 00 00	 mov	 DWORD PTR [rax+1700], 0

; 917  :     dev->acc_ipmask  = 0;

  00352	48 8b 84 24 10
	01 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  0035a	c7 80 a8 06 00
	00 00 00 00 00	 mov	 DWORD PTR [rax+1704], 0

; 918  : 
; 919  :     if (argc > 0)   // group name?

  00364	83 bc 24 18 01
	00 00 00	 cmp	 DWORD PTR argc$[rsp], 0
  0036c	0f 8e 2d 07 00
	00		 jle	 $LN11@loc3270_in

; 920  :     {
; 921  :         if ('*' == argv[ac][0] && '\0' == argv[ac][1])

  00372	48 63 44 24 60	 movsxd	 rax, DWORD PTR ac$[rsp]
  00377	b9 01 00 00 00	 mov	 ecx, 1
  0037c	48 6b c9 00	 imul	 rcx, rcx, 0
  00380	48 8b 94 24 20
	01 00 00	 mov	 rdx, QWORD PTR argv$[rsp]
  00388	48 8b 04 c2	 mov	 rax, QWORD PTR [rdx+rax*8]
  0038c	0f be 04 08	 movsx	 eax, BYTE PTR [rax+rcx]
  00390	83 f8 2a	 cmp	 eax, 42			; 0000002aH
  00393	75 27		 jne	 SHORT $LN12@loc3270_in
  00395	48 63 44 24 60	 movsxd	 rax, DWORD PTR ac$[rsp]
  0039a	b9 01 00 00 00	 mov	 ecx, 1
  0039f	48 6b c9 01	 imul	 rcx, rcx, 1
  003a3	48 8b 94 24 20
	01 00 00	 mov	 rdx, QWORD PTR argv$[rsp]
  003ab	48 8b 04 c2	 mov	 rax, QWORD PTR [rdx+rax*8]
  003af	0f be 04 08	 movsx	 eax, BYTE PTR [rax+rcx]
  003b3	85 c0		 test	 eax, eax
  003b5	75 05		 jne	 SHORT $LN12@loc3270_in

; 922  :             ;   // NOP (not really a group name; an '*' is

  003b7	e9 c3 02 00 00	 jmp	 $LN13@loc3270_in
$LN12@loc3270_in:

; 923  :                 // simply used as an argument place holder)
; 924  :         else
; 925  :         {
; 926  :             if (0
; 927  :                 || strlen( argv[ac] ) <= 0
; 928  :                 || strlen( argv[ac] ) >= 9

  003bc	33 c0		 xor	 eax, eax
  003be	85 c0		 test	 eax, eax
  003c0	75 3b		 jne	 SHORT $LN16@loc3270_in
  003c2	48 63 44 24 60	 movsxd	 rax, DWORD PTR ac$[rsp]
  003c7	48 8b 8c 24 20
	01 00 00	 mov	 rcx, QWORD PTR argv$[rsp]
  003cf	48 8b 0c c1	 mov	 rcx, QWORD PTR [rcx+rax*8]
  003d3	e8 00 00 00 00	 call	 strlen
  003d8	48 85 c0	 test	 rax, rax
  003db	76 20		 jbe	 SHORT $LN16@loc3270_in
  003dd	48 63 44 24 60	 movsxd	 rax, DWORD PTR ac$[rsp]
  003e2	48 8b 8c 24 20
	01 00 00	 mov	 rcx, QWORD PTR argv$[rsp]
  003ea	48 8b 0c c1	 mov	 rcx, QWORD PTR [rcx+rax*8]
  003ee	e8 00 00 00 00	 call	 strlen
  003f3	48 83 f8 09	 cmp	 rax, 9
  003f7	0f 82 d8 00 00
	00		 jb	 $LN14@loc3270_in
$LN16@loc3270_in:

; 929  :             )
; 930  :             {
; 931  :                 // "%1d:%04X COMM: %s has an invalid GROUP name length or format; must be a valid luname or poolname"
; 932  :                 WRMSG( HHC01091, "E", LCSS_DEVNUM, argv[ac] );

  003fd	48 83 bc 24 10
	01 00 00 00	 cmp	 QWORD PTR dev$[rsp], 0
  00406	74 12		 je	 SHORT $LN34@loc3270_in
  00408	48 8b 84 24 10
	01 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00410	0f b7 40 48	 movzx	 eax, WORD PTR [rax+72]
  00414	89 44 24 78	 mov	 DWORD PTR tv224[rsp], eax
  00418	eb 08		 jmp	 SHORT $LN35@loc3270_in
$LN34@loc3270_in:
  0041a	c7 44 24 78 00
	00 00 00	 mov	 DWORD PTR tv224[rsp], 0
$LN35@loc3270_in:
  00422	48 83 bc 24 10
	01 00 00 00	 cmp	 QWORD PTR dev$[rsp], 0
  0042b	74 14		 je	 SHORT $LN36@loc3270_in
  0042d	48 8b 84 24 10
	01 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00435	0f b7 40 44	 movzx	 eax, WORD PTR [rax+68]
  00439	d1 f8		 sar	 eax, 1
  0043b	89 44 24 7c	 mov	 DWORD PTR tv230[rsp], eax
  0043f	eb 08		 jmp	 SHORT $LN37@loc3270_in
$LN36@loc3270_in:
  00441	c7 44 24 7c 00
	00 00 00	 mov	 DWORD PTR tv230[rsp], 0
$LN37@loc3270_in:
  00449	48 63 44 24 60	 movsxd	 rax, DWORD PTR ac$[rsp]
  0044e	48 89 84 24 a8
	00 00 00	 mov	 QWORD PTR tv217[rsp], rax
  00456	b9 01 00 00 00	 mov	 ecx, 1
  0045b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  00461	48 8b 8c 24 20
	01 00 00	 mov	 rcx, QWORD PTR argv$[rsp]
  00469	48 8b 94 24 a8
	00 00 00	 mov	 rdx, QWORD PTR tv217[rsp]
  00471	48 8b 0c d1	 mov	 rcx, QWORD PTR [rcx+rdx*8]
  00475	48 89 4c 24 48	 mov	 QWORD PTR [rsp+72], rcx
  0047a	8b 4c 24 78	 mov	 ecx, DWORD PTR tv224[rsp]
  0047e	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  00482	8b 4c 24 7c	 mov	 ecx, DWORD PTR tv230[rsp]
  00486	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  0048a	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG177979
  00491	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  00496	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG177980
  0049d	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  004a2	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  004a7	41 b9 03 00 00
	00		 mov	 r9d, 3
  004ad	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG177981
  004b4	ba a4 03 00 00	 mov	 edx, 932		; 000003a4H
  004b9	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG177982
  004c0	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 933  :                 return -1;

  004c6	b8 ff ff ff ff	 mov	 eax, -1
  004cb	e9 0f 06 00 00	 jmp	 $LN1@loc3270_in

; 934  :             }

  004d0	e9 aa 01 00 00	 jmp	 $LN15@loc3270_in
$LN14@loc3270_in:

; 935  :             else
; 936  :             {
; 937  :                 char group[9];
; 938  :                 int  i;
; 939  :                 int  rc;
; 940  : 
; 941  :                 strupper( group, argv[ac] );

  004d5	48 63 44 24 60	 movsxd	 rax, DWORD PTR ac$[rsp]
  004da	48 8b 8c 24 20
	01 00 00	 mov	 rcx, QWORD PTR argv$[rsp]
  004e2	48 8b 14 c1	 mov	 rdx, QWORD PTR [rcx+rax*8]
  004e6	48 8d 8c 24 d0
	00 00 00	 lea	 rcx, QWORD PTR group$3[rsp]
  004ee	e8 00 00 00 00	 call	 strupper

; 942  : 
; 943  :                 for (i=1, rc=0; i < (int) strlen( group ) && rc == 0; i++)

  004f3	c7 44 24 68 01
	00 00 00	 mov	 DWORD PTR i$1[rsp], 1
  004fb	c7 44 24 6c 00
	00 00 00	 mov	 DWORD PTR rc$2[rsp], 0
  00503	eb 0a		 jmp	 SHORT $LN4@loc3270_in
$LN2@loc3270_in:
  00505	8b 44 24 68	 mov	 eax, DWORD PTR i$1[rsp]
  00509	ff c0		 inc	 eax
  0050b	89 44 24 68	 mov	 DWORD PTR i$1[rsp], eax
$LN4@loc3270_in:
  0050f	48 8d 8c 24 d0
	00 00 00	 lea	 rcx, QWORD PTR group$3[rsp]
  00517	e8 00 00 00 00	 call	 strlen
  0051c	39 44 24 68	 cmp	 DWORD PTR i$1[rsp], eax
  00520	7d 2a		 jge	 SHORT $LN3@loc3270_in
  00522	83 7c 24 6c 00	 cmp	 DWORD PTR rc$2[rsp], 0
  00527	75 23		 jne	 SHORT $LN3@loc3270_in

; 944  :                     if (!isalnum( group[i] ))

  00529	48 63 44 24 68	 movsxd	 rax, DWORD PTR i$1[rsp]
  0052e	0f be 84 04 d0
	00 00 00	 movsx	 eax, BYTE PTR group$3[rsp+rax]
  00536	8b c8		 mov	 ecx, eax
  00538	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_isalnum
  0053e	85 c0		 test	 eax, eax
  00540	75 08		 jne	 SHORT $LN17@loc3270_in

; 945  :                         rc = -1;

  00542	c7 44 24 6c ff
	ff ff ff	 mov	 DWORD PTR rc$2[rsp], -1
$LN17@loc3270_in:
  0054a	eb b9		 jmp	 SHORT $LN2@loc3270_in
$LN3@loc3270_in:

; 946  : 
; 947  :                 if (rc == 0 && isalpha( group[0] ))

  0054c	83 7c 24 6c 00	 cmp	 DWORD PTR rc$2[rsp], 0
  00551	75 47		 jne	 SHORT $LN18@loc3270_in
  00553	b8 01 00 00 00	 mov	 eax, 1
  00558	48 6b c0 00	 imul	 rax, rax, 0
  0055c	0f be 84 04 d0
	00 00 00	 movsx	 eax, BYTE PTR group$3[rsp+rax]
  00564	8b c8		 mov	 ecx, eax
  00566	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_isalpha
  0056c	85 c0		 test	 eax, eax
  0056e	74 2a		 je	 SHORT $LN18@loc3270_in

; 948  :                     STRLCPY( dev->filename, group );

  00570	48 8b 84 24 10
	01 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00578	48 05 a4 00 00
	00		 add	 rax, 164		; 000000a4H
  0057e	41 b8 05 01 00
	00		 mov	 r8d, 261		; 00000105H
  00584	48 8d 94 24 d0
	00 00 00	 lea	 rdx, QWORD PTR group$3[rsp]
  0058c	48 8b c8	 mov	 rcx, rax
  0058f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_strlcpy
  00595	e9 e5 00 00 00	 jmp	 $LN19@loc3270_in
$LN18@loc3270_in:

; 949  :                 else
; 950  :                 {
; 951  :                     // "%1d:%04X COMM: %s has an invalid GROUP name length or format; must be a valid luname or poolname"
; 952  :                     WRMSG(HHC01091, "E", LCSS_DEVNUM, argv[ac] );

  0059a	48 83 bc 24 10
	01 00 00 00	 cmp	 QWORD PTR dev$[rsp], 0
  005a3	74 15		 je	 SHORT $LN38@loc3270_in
  005a5	48 8b 84 24 10
	01 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  005ad	0f b7 40 48	 movzx	 eax, WORD PTR [rax+72]
  005b1	89 84 24 80 00
	00 00		 mov	 DWORD PTR tv277[rsp], eax
  005b8	eb 0b		 jmp	 SHORT $LN39@loc3270_in
$LN38@loc3270_in:
  005ba	c7 84 24 80 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv277[rsp], 0
$LN39@loc3270_in:
  005c5	48 83 bc 24 10
	01 00 00 00	 cmp	 QWORD PTR dev$[rsp], 0
  005ce	74 17		 je	 SHORT $LN40@loc3270_in
  005d0	48 8b 84 24 10
	01 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  005d8	0f b7 40 44	 movzx	 eax, WORD PTR [rax+68]
  005dc	d1 f8		 sar	 eax, 1
  005de	89 84 24 84 00
	00 00		 mov	 DWORD PTR tv283[rsp], eax
  005e5	eb 0b		 jmp	 SHORT $LN41@loc3270_in
$LN40@loc3270_in:
  005e7	c7 84 24 84 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv283[rsp], 0
$LN41@loc3270_in:
  005f2	48 63 44 24 60	 movsxd	 rax, DWORD PTR ac$[rsp]
  005f7	48 89 84 24 b0
	00 00 00	 mov	 QWORD PTR tv266[rsp], rax
  005ff	b9 01 00 00 00	 mov	 ecx, 1
  00604	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  0060a	48 8b 8c 24 20
	01 00 00	 mov	 rcx, QWORD PTR argv$[rsp]
  00612	48 8b 94 24 b0
	00 00 00	 mov	 rdx, QWORD PTR tv266[rsp]
  0061a	48 8b 0c d1	 mov	 rcx, QWORD PTR [rcx+rdx*8]
  0061e	48 89 4c 24 48	 mov	 QWORD PTR [rsp+72], rcx
  00623	8b 8c 24 80 00
	00 00		 mov	 ecx, DWORD PTR tv277[rsp]
  0062a	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  0062e	8b 8c 24 84 00
	00 00		 mov	 ecx, DWORD PTR tv283[rsp]
  00635	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  00639	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG177986
  00640	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  00645	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG177987
  0064c	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00651	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00656	41 b9 03 00 00
	00		 mov	 r9d, 3
  0065c	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG177988
  00663	ba b8 03 00 00	 mov	 edx, 952		; 000003b8H
  00668	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG177989
  0066f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 953  :                     return -1;

  00675	b8 ff ff ff ff	 mov	 eax, -1
  0067a	e9 60 04 00 00	 jmp	 $LN1@loc3270_in
$LN19@loc3270_in:
$LN15@loc3270_in:
$LN13@loc3270_in:

; 954  :                 }
; 955  :             }
; 956  :         }
; 957  : 
; 958  :         argc--;

  0067f	8b 84 24 18 01
	00 00		 mov	 eax, DWORD PTR argc$[rsp]
  00686	ff c8		 dec	 eax
  00688	89 84 24 18 01
	00 00		 mov	 DWORD PTR argc$[rsp], eax

; 959  :         ac++;

  0068f	8b 44 24 60	 mov	 eax, DWORD PTR ac$[rsp]
  00693	ff c0		 inc	 eax
  00695	89 44 24 60	 mov	 DWORD PTR ac$[rsp], eax

; 960  : 
; 961  :         if (argc > 0)   // ip address?

  00699	83 bc 24 18 01
	00 00 00	 cmp	 DWORD PTR argc$[rsp], 0
  006a1	0f 8e f8 03 00
	00		 jle	 $LN20@loc3270_in

; 962  :         {
; 963  :             if ((dev->acc_ipaddr = inet_addr( argv[ac] )) == (in_addr_t)(-1))

  006a7	48 63 44 24 60	 movsxd	 rax, DWORD PTR ac$[rsp]
  006ac	48 8b 8c 24 20
	01 00 00	 mov	 rcx, QWORD PTR argv$[rsp]
  006b4	48 8b 0c c1	 mov	 rcx, QWORD PTR [rcx+rax*8]
  006b8	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_inet_addr
  006be	89 84 24 88 00
	00 00		 mov	 DWORD PTR tv298[rsp], eax
  006c5	48 8b 84 24 10
	01 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  006cd	8b 8c 24 88 00
	00 00		 mov	 ecx, DWORD PTR tv298[rsp]
  006d4	89 88 a4 06 00
	00		 mov	 DWORD PTR [rax+1700], ecx
  006da	83 bc 24 88 00
	00 00 ff	 cmp	 DWORD PTR tv298[rsp], -1 ; ffffffffH
  006e2	0f 85 f6 00 00
	00		 jne	 $LN21@loc3270_in

; 964  :             {
; 965  :                 // "%1d:%04X COMM: option %s value %s invalid"
; 966  :                 WRMSG( HHC01007, "E", LCSS_DEVNUM, "IP address", argv[ac] );

  006e8	48 83 bc 24 10
	01 00 00 00	 cmp	 QWORD PTR dev$[rsp], 0
  006f1	74 15		 je	 SHORT $LN42@loc3270_in
  006f3	48 8b 84 24 10
	01 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  006fb	0f b7 40 48	 movzx	 eax, WORD PTR [rax+72]
  006ff	89 84 24 8c 00
	00 00		 mov	 DWORD PTR tv312[rsp], eax
  00706	eb 0b		 jmp	 SHORT $LN43@loc3270_in
$LN42@loc3270_in:
  00708	c7 84 24 8c 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv312[rsp], 0
$LN43@loc3270_in:
  00713	48 83 bc 24 10
	01 00 00 00	 cmp	 QWORD PTR dev$[rsp], 0
  0071c	74 17		 je	 SHORT $LN44@loc3270_in
  0071e	48 8b 84 24 10
	01 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00726	0f b7 40 44	 movzx	 eax, WORD PTR [rax+68]
  0072a	d1 f8		 sar	 eax, 1
  0072c	89 84 24 90 00
	00 00		 mov	 DWORD PTR tv318[rsp], eax
  00733	eb 0b		 jmp	 SHORT $LN45@loc3270_in
$LN44@loc3270_in:
  00735	c7 84 24 90 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv318[rsp], 0
$LN45@loc3270_in:
  00740	48 63 44 24 60	 movsxd	 rax, DWORD PTR ac$[rsp]
  00745	48 89 84 24 b8
	00 00 00	 mov	 QWORD PTR tv304[rsp], rax
  0074d	b9 01 00 00 00	 mov	 ecx, 1
  00752	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  00758	48 8b 8c 24 20
	01 00 00	 mov	 rcx, QWORD PTR argv$[rsp]
  00760	48 8b 94 24 b8
	00 00 00	 mov	 rdx, QWORD PTR tv304[rsp]
  00768	48 8b 0c d1	 mov	 rcx, QWORD PTR [rcx+rdx*8]
  0076c	48 89 4c 24 50	 mov	 QWORD PTR [rsp+80], rcx
  00771	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG177993
  00778	48 89 4c 24 48	 mov	 QWORD PTR [rsp+72], rcx
  0077d	8b 8c 24 8c 00
	00 00		 mov	 ecx, DWORD PTR tv312[rsp]
  00784	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  00788	8b 8c 24 90 00
	00 00		 mov	 ecx, DWORD PTR tv318[rsp]
  0078f	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  00793	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG177994
  0079a	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  0079f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG177995
  007a6	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  007ab	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  007b0	41 b9 03 00 00
	00		 mov	 r9d, 3
  007b6	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG177996
  007bd	ba c6 03 00 00	 mov	 edx, 966		; 000003c6H
  007c2	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG177997
  007c9	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 967  :                 return -1;

  007cf	b8 ff ff ff ff	 mov	 eax, -1
  007d4	e9 06 03 00 00	 jmp	 $LN1@loc3270_in

; 968  :             }

  007d9	e9 c1 02 00 00	 jmp	 $LN22@loc3270_in
$LN21@loc3270_in:

; 969  :             else
; 970  :             {
; 971  :                 argc--;

  007de	8b 84 24 18 01
	00 00		 mov	 eax, DWORD PTR argc$[rsp]
  007e5	ff c8		 dec	 eax
  007e7	89 84 24 18 01
	00 00		 mov	 DWORD PTR argc$[rsp], eax

; 972  :                 ac++;

  007ee	8b 44 24 60	 mov	 eax, DWORD PTR ac$[rsp]
  007f2	ff c0		 inc	 eax
  007f4	89 44 24 60	 mov	 DWORD PTR ac$[rsp], eax

; 973  : 
; 974  :                 if (argc <= 0)   // ip addr mask?

  007f8	83 bc 24 18 01
	00 00 00	 cmp	 DWORD PTR argc$[rsp], 0
  00800	7f 17		 jg	 SHORT $LN23@loc3270_in

; 975  :                     dev->acc_ipmask = (in_addr_t)(-1);

  00802	48 8b 84 24 10
	01 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  0080a	c7 80 a8 06 00
	00 ff ff ff ff	 mov	 DWORD PTR [rax+1704], -1 ; ffffffffH
  00814	e9 86 02 00 00	 jmp	 $LN24@loc3270_in
$LN23@loc3270_in:

; 976  :                 else
; 977  :                 {
; 978  :                     char mask[16] = {0};

  00819	48 8d 84 24 e0
	00 00 00	 lea	 rax, QWORD PTR mask$4[rsp]
  00821	48 8b f8	 mov	 rdi, rax
  00824	33 c0		 xor	 eax, eax
  00826	b9 10 00 00 00	 mov	 ecx, 16
  0082b	f3 aa		 rep stosb

; 979  :                     static const char* badmask = "0.0.0.0";
; 980  : 
; 981  :                     if (0
; 982  :                         || inet_pton( AF_INET, argv[ac], &dev->acc_ipmask ) <= 0
; 983  :                         || str_eq( badmask, inet_ntop( AF_INET, &dev->acc_ipmask,

  0082d	33 c0		 xor	 eax, eax
  0082f	85 c0		 test	 eax, eax
  00831	75 71		 jne	 SHORT $LN26@loc3270_in
  00833	48 8b 84 24 10
	01 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  0083b	48 05 a8 06 00
	00		 add	 rax, 1704		; 000006a8H
  00841	48 63 4c 24 60	 movsxd	 rcx, DWORD PTR ac$[rsp]
  00846	4c 8b c0	 mov	 r8, rax
  00849	48 8b 84 24 20
	01 00 00	 mov	 rax, QWORD PTR argv$[rsp]
  00851	48 8b 14 c8	 mov	 rdx, QWORD PTR [rax+rcx*8]
  00855	b9 02 00 00 00	 mov	 ecx, 2
  0085a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_inet_pton
  00860	85 c0		 test	 eax, eax
  00862	7e 40		 jle	 SHORT $LN26@loc3270_in
  00864	48 8b 84 24 10
	01 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  0086c	48 05 a8 06 00
	00		 add	 rax, 1704		; 000006a8H
  00872	41 b9 10 00 00
	00		 mov	 r9d, 16
  00878	4c 8d 84 24 e0
	00 00 00	 lea	 r8, QWORD PTR mask$4[rsp]
  00880	48 8b d0	 mov	 rdx, rax
  00883	b9 02 00 00 00	 mov	 ecx, 2
  00888	e8 00 00 00 00	 call	 inet_ntop
  0088d	48 8b d0	 mov	 rdx, rax
  00890	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR ?badmask@?BA@??loc3270_init_handler@@9@9
  00897	e8 00 00 00 00	 call	 strcmp
  0089c	85 c0		 test	 eax, eax
  0089e	0f 85 f1 00 00
	00		 jne	 $LN25@loc3270_in
$LN26@loc3270_in:

; 984  :                                    mask, (int) sizeof( mask )))
; 985  :                     )
; 986  :                     {
; 987  :                         // "%1d:%04X COMM: option %s value %s invalid"
; 988  :                         WRMSG( HHC01007, "E", LCSS_DEVNUM, "mask", argv[ac] );

  008a4	48 83 bc 24 10
	01 00 00 00	 cmp	 QWORD PTR dev$[rsp], 0
  008ad	74 15		 je	 SHORT $LN46@loc3270_in
  008af	48 8b 84 24 10
	01 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  008b7	0f b7 40 48	 movzx	 eax, WORD PTR [rax+72]
  008bb	89 84 24 94 00
	00 00		 mov	 DWORD PTR tv365[rsp], eax
  008c2	eb 0b		 jmp	 SHORT $LN47@loc3270_in
$LN46@loc3270_in:
  008c4	c7 84 24 94 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv365[rsp], 0
$LN47@loc3270_in:
  008cf	48 83 bc 24 10
	01 00 00 00	 cmp	 QWORD PTR dev$[rsp], 0
  008d8	74 17		 je	 SHORT $LN48@loc3270_in
  008da	48 8b 84 24 10
	01 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  008e2	0f b7 40 44	 movzx	 eax, WORD PTR [rax+68]
  008e6	d1 f8		 sar	 eax, 1
  008e8	89 84 24 98 00
	00 00		 mov	 DWORD PTR tv371[rsp], eax
  008ef	eb 0b		 jmp	 SHORT $LN49@loc3270_in
$LN48@loc3270_in:
  008f1	c7 84 24 98 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv371[rsp], 0
$LN49@loc3270_in:
  008fc	48 63 44 24 60	 movsxd	 rax, DWORD PTR ac$[rsp]
  00901	48 89 84 24 c0
	00 00 00	 mov	 QWORD PTR tv357[rsp], rax
  00909	b9 01 00 00 00	 mov	 ecx, 1
  0090e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  00914	48 8b 8c 24 20
	01 00 00	 mov	 rcx, QWORD PTR argv$[rsp]
  0091c	48 8b 94 24 c0
	00 00 00	 mov	 rdx, QWORD PTR tv357[rsp]
  00924	48 8b 0c d1	 mov	 rcx, QWORD PTR [rcx+rdx*8]
  00928	48 89 4c 24 50	 mov	 QWORD PTR [rsp+80], rcx
  0092d	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG178003
  00934	48 89 4c 24 48	 mov	 QWORD PTR [rsp+72], rcx
  00939	8b 8c 24 94 00
	00 00		 mov	 ecx, DWORD PTR tv365[rsp]
  00940	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  00944	8b 8c 24 98 00
	00 00		 mov	 ecx, DWORD PTR tv371[rsp]
  0094b	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  0094f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG178004
  00956	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  0095b	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG178005
  00962	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00967	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  0096c	41 b9 03 00 00
	00		 mov	 r9d, 3
  00972	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG178006
  00979	ba dc 03 00 00	 mov	 edx, 988		; 000003dcH
  0097e	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG178007
  00985	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 989  :                         return -1;

  0098b	b8 ff ff ff ff	 mov	 eax, -1
  00990	e9 4a 01 00 00	 jmp	 $LN1@loc3270_in
$LN25@loc3270_in:

; 990  :                     }
; 991  : 
; 992  :                     argc--;

  00995	8b 84 24 18 01
	00 00		 mov	 eax, DWORD PTR argc$[rsp]
  0099c	ff c8		 dec	 eax
  0099e	89 84 24 18 01
	00 00		 mov	 DWORD PTR argc$[rsp], eax

; 993  :                     ac++;

  009a5	8b 44 24 60	 mov	 eax, DWORD PTR ac$[rsp]
  009a9	ff c0		 inc	 eax
  009ab	89 44 24 60	 mov	 DWORD PTR ac$[rsp], eax

; 994  : 
; 995  :                     if (argc > 0)   // too many args?

  009af	83 bc 24 18 01
	00 00 00	 cmp	 DWORD PTR argc$[rsp], 0
  009b7	0f 8e e2 00 00
	00		 jle	 $LN27@loc3270_in

; 996  :                     {
; 997  :                         // "%1d:%04X COMM: unrecognized parameter %s"
; 998  :                         WRMSG( HHC01019, "E", LCSS_DEVNUM, argv[ac] );

  009bd	48 83 bc 24 10
	01 00 00 00	 cmp	 QWORD PTR dev$[rsp], 0
  009c6	74 15		 je	 SHORT $LN50@loc3270_in
  009c8	48 8b 84 24 10
	01 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  009d0	0f b7 40 48	 movzx	 eax, WORD PTR [rax+72]
  009d4	89 84 24 9c 00
	00 00		 mov	 DWORD PTR tv392[rsp], eax
  009db	eb 0b		 jmp	 SHORT $LN51@loc3270_in
$LN50@loc3270_in:
  009dd	c7 84 24 9c 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv392[rsp], 0
$LN51@loc3270_in:
  009e8	48 83 bc 24 10
	01 00 00 00	 cmp	 QWORD PTR dev$[rsp], 0
  009f1	74 17		 je	 SHORT $LN52@loc3270_in
  009f3	48 8b 84 24 10
	01 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  009fb	0f b7 40 44	 movzx	 eax, WORD PTR [rax+68]
  009ff	d1 f8		 sar	 eax, 1
  00a01	89 84 24 a0 00
	00 00		 mov	 DWORD PTR tv398[rsp], eax
  00a08	eb 0b		 jmp	 SHORT $LN53@loc3270_in
$LN52@loc3270_in:
  00a0a	c7 84 24 a0 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv398[rsp], 0
$LN53@loc3270_in:
  00a15	48 63 44 24 60	 movsxd	 rax, DWORD PTR ac$[rsp]
  00a1a	48 89 84 24 c8
	00 00 00	 mov	 QWORD PTR tv385[rsp], rax
  00a22	b9 01 00 00 00	 mov	 ecx, 1
  00a27	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  00a2d	48 8b 8c 24 20
	01 00 00	 mov	 rcx, QWORD PTR argv$[rsp]
  00a35	48 8b 94 24 c8
	00 00 00	 mov	 rdx, QWORD PTR tv385[rsp]
  00a3d	48 8b 0c d1	 mov	 rcx, QWORD PTR [rcx+rdx*8]
  00a41	48 89 4c 24 48	 mov	 QWORD PTR [rsp+72], rcx
  00a46	8b 8c 24 9c 00
	00 00		 mov	 ecx, DWORD PTR tv392[rsp]
  00a4d	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  00a51	8b 8c 24 a0 00
	00 00		 mov	 ecx, DWORD PTR tv398[rsp]
  00a58	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  00a5c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG178009
  00a63	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  00a68	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG178010
  00a6f	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00a74	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00a79	41 b9 03 00 00
	00		 mov	 r9d, 3
  00a7f	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG178011
  00a86	ba e6 03 00 00	 mov	 edx, 998		; 000003e6H
  00a8b	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG178012
  00a92	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 999  :                         return -1;

  00a98	b8 ff ff ff ff	 mov	 eax, -1
  00a9d	eb 40		 jmp	 SHORT $LN1@loc3270_in
$LN27@loc3270_in:
$LN24@loc3270_in:
$LN22@loc3270_in:
$LN20@loc3270_in:
$LN11@loc3270_in:

; 1000 :                     }
; 1001 :                 }
; 1002 :             }
; 1003 :         }
; 1004 :     }
; 1005 : 
; 1006 : #if defined(_FEATURE_INTEGRATED_3270_CONSOLE)
; 1007 : 
; 1008 :     /* Save the address of the SYSG console devblk */
; 1009 :     if (strcasecmp( dev->typname, "SYSG" ) == 0)

  00a9f	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG178014
  00aa6	48 8b 84 24 10
	01 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00aae	48 8b 48 50	 mov	 rcx, QWORD PTR [rax+80]
  00ab2	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__stricmp
  00ab8	85 c0		 test	 eax, eax
  00aba	75 16		 jne	 SHORT $LN28@loc3270_in

; 1010 :         sysblk.sysgdev = dev;

  00abc	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00ac3	48 8b 8c 24 10
	01 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  00acb	48 89 88 c8 11
	00 00		 mov	 QWORD PTR [rax+4552], rcx
$LN28@loc3270_in:

; 1011 : #endif
; 1012 : 
; 1013 :     return finish_console_init( dev );

  00ad2	48 8b 8c 24 10
	01 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  00ada	e8 00 00 00 00	 call	 finish_console_init
$LN1@loc3270_in:

; 1014 : 
; 1015 : } /* end function loc3270_init_handler */

  00adf	48 8b 8c 24 f0
	00 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  00ae7	48 33 cc	 xor	 rcx, rsp
  00aea	e8 00 00 00 00	 call	 __security_check_cookie
  00aef	48 81 c4 00 01
	00 00		 add	 rsp, 256		; 00000100H
  00af6	5f		 pop	 rdi
  00af7	c3		 ret	 0
loc3270_init_handler ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\console.c
_TEXT	SEGMENT
dev$ = 48
constty_close_device PROC

; 831  : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 832  :     /* PROGRAMMING NOTE: this function is the device handler's
; 833  :        close function. It should only be called when detaching
; 834  :        a TTY console device. To disconnect a TTY console from
; 835  :        whatever telnet client is connected to it, you should use
; 836  :        the disconnect_console_device function instead.
; 837  :     */
; 838  :     finish_console_close (dev );

  00009	48 8b 4c 24 30	 mov	 rcx, QWORD PTR dev$[rsp]
  0000e	e8 00 00 00 00	 call	 finish_console_close

; 839  :     return 0;

  00013	33 c0		 xor	 eax, eax

; 840  : }

  00015	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00019	c3		 ret	 0
constty_close_device ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\console.c
_TEXT	SEGMENT
dev$ = 48
loc3270_close_device PROC

; 809  : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 810  :     /* PROGRAMMING NOTE: this function is the device handler's
; 811  :        close function. It should only be called when detaching
; 812  :        a 3270 console device. To disconnect a 3270 console from
; 813  :        whatever telnet client is connected to it, you should use
; 814  :        the disconnect_console_device function instead.
; 815  :     */
; 816  : #if defined(_FEATURE_INTEGRATED_3270_CONSOLE)
; 817  : 
; 818  :     if (dev == sysblk.sysgdev)

  00009	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00010	48 8b 80 c8 11
	00 00		 mov	 rax, QWORD PTR [rax+4552]
  00017	48 39 44 24 30	 cmp	 QWORD PTR dev$[rsp], rax
  0001c	75 12		 jne	 SHORT $LN2@loc3270_cl

; 819  :         sysblk.sysgdev = NULL;

  0001e	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00025	48 c7 80 c8 11
	00 00 00 00 00
	00		 mov	 QWORD PTR [rax+4552], 0
$LN2@loc3270_cl:

; 820  : 
; 821  : #endif
; 822  : 
; 823  :     finish_console_close( dev );

  00030	48 8b 4c 24 30	 mov	 rcx, QWORD PTR dev$[rsp]
  00035	e8 00 00 00 00	 call	 finish_console_close

; 824  :     return 0;

  0003a	33 c0		 xor	 eax, eax

; 825  : }

  0003c	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00040	c3		 ret	 0
loc3270_close_device ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\console.c
_TEXT	SEGMENT
c$1 = 32
f$2 = 36
saved_errno$3 = 40
dev$ = 64
finish_console_close PROC

; 782  : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 783  :     /* PROGRAMMING NOTE: this function should never be called
; 784  :        directly. It is a helper function for the device handler
; 785  :        close function.
; 786  :     */
; 787  :     disconnect_console_device( dev );

  00009	48 8b 4c 24 40	 mov	 rcx, QWORD PTR dev$[rsp]
  0000e	e8 00 00 00 00	 call	 disconnect_console_device

; 788  : 
; 789  :     console_cnslcnt--;

  00013	8b 05 00 00 00
	00		 mov	 eax, DWORD PTR console_cnslcnt
  00019	ff c8		 dec	 eax
  0001b	89 05 00 00 00
	00		 mov	 DWORD PTR console_cnslcnt, eax
$LN4@finish_con:

; 790  : 
; 791  :     SIGNAL_CONSOLE_THREAD();

  00021	c6 44 24 20 00	 mov	 BYTE PTR c$1[rsp], 0
  00026	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_WSAGetLastError
  0002c	89 44 24 28	 mov	 DWORD PTR saved_errno$3[rsp], eax
  00030	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00037	48 05 c0 10 00
	00		 add	 rax, 4288		; 000010c0H
  0003d	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG177910
  00044	48 8b c8	 mov	 rcx, rax
  00047	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_obtain_lock
  0004d	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00054	8b 80 c8 10 00
	00		 mov	 eax, DWORD PTR [rax+4296]
  0005a	89 44 24 24	 mov	 DWORD PTR f$2[rsp], eax
  0005e	83 7c 24 24 00	 cmp	 DWORD PTR f$2[rsp], 0
  00063	7f 11		 jg	 SHORT $LN11@finish_con
  00065	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  0006c	c7 80 c8 10 00
	00 01 00 00 00	 mov	 DWORD PTR [rax+4296], 1
$LN11@finish_con:
  00076	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  0007d	48 05 c0 10 00
	00		 add	 rax, 4288		; 000010c0H
  00083	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG177912
  0008a	48 8b c8	 mov	 rcx, rax
  0008d	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_release_lock
  00093	83 7c 24 24 00	 cmp	 DWORD PTR f$2[rsp], 0
  00098	0f 8f 90 00 00
	00		 jg	 $LN12@finish_con
$LN7@finish_con:
  0009e	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  000a5	48 63 80 cc 10
	00 00		 movsxd	 rax, DWORD PTR [rax+4300]
  000ac	45 33 c9	 xor	 r9d, r9d
  000af	41 b8 01 00 00
	00		 mov	 r8d, 1
  000b5	48 8d 54 24 20	 lea	 rdx, QWORD PTR c$1[rsp]
  000ba	48 8b c8	 mov	 rcx, rax
  000bd	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_send
  000c3	83 f8 01	 cmp	 eax, 1
  000c6	74 5c		 je	 SHORT $LN13@finish_con
$LN10@finish_con:
  000c8	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG177915
  000cf	41 b8 17 03 00
	00		 mov	 r8d, 791		; 00000317H
  000d5	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG177916
  000dc	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG177917
  000e3	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_logmsg
  000e9	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_IsDebuggerPresent
  000ef	85 c0		 test	 eax, eax
  000f1	74 20		 je	 SHORT $LN14@finish_con
  000f3	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG177919
  000fa	41 b8 17 03 00
	00		 mov	 r8d, 791		; 00000317H
  00100	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG177920
  00107	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG177921
  0010e	e8 00 00 00 00	 call	 DebuggerTrace
$LN14@finish_con:
  00113	33 c0		 xor	 eax, eax
  00115	85 c0		 test	 eax, eax
  00117	75 af		 jne	 SHORT $LN10@finish_con
  00119	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_IsDebuggerPresent
  0011f	85 c0		 test	 eax, eax
  00121	74 01		 je	 SHORT $LN15@finish_con
  00123	cc		 int	 3
$LN15@finish_con:
$LN13@finish_con:
  00124	33 c0		 xor	 eax, eax
  00126	85 c0		 test	 eax, eax
  00128	0f 85 70 ff ff
	ff		 jne	 $LN7@finish_con
$LN12@finish_con:
  0012e	8b 4c 24 28	 mov	 ecx, DWORD PTR saved_errno$3[rsp]
  00132	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_WSASetLastError
  00138	33 c0		 xor	 eax, eax
  0013a	85 c0		 test	 eax, eax
  0013c	0f 85 df fe ff
	ff		 jne	 $LN4@finish_con

; 792  : 
; 793  :     if (!console_cnslcnt)

  00142	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR console_cnslcnt, 0
  00149	75 5f		 jne	 SHORT $LN16@finish_con

; 794  :     {
; 795  :         release_lock( &dev->lock );

  0014b	48 8b 44 24 40	 mov	 rax, QWORD PTR dev$[rsp]
  00150	48 83 c0 38	 add	 rax, 56			; 00000038H
  00154	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG177924
  0015b	48 8b c8	 mov	 rcx, rax
  0015e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_release_lock

; 796  :         {
; 797  :             join_thread( sysblk.cnsltid, NULL);

  00164	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG177925
  0016b	33 d2		 xor	 edx, edx
  0016d	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00174	8b 88 a8 10 00
	00		 mov	 ecx, DWORD PTR [rax+4264]
  0017a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_join_thread

; 798  :         }
; 799  :         obtain_lock (&dev->lock );

  00180	48 8b 44 24 40	 mov	 rax, QWORD PTR dev$[rsp]
  00185	48 83 c0 38	 add	 rax, 56			; 00000038H
  00189	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG177926
  00190	48 8b c8	 mov	 rcx, rax
  00193	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_obtain_lock

; 800  : 
; 801  :         sysblk.cnsltid = 0;

  00199	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  001a0	c7 80 a8 10 00
	00 00 00 00 00	 mov	 DWORD PTR [rax+4264], 0
$LN16@finish_con:

; 802  :     }
; 803  : }

  001aa	48 83 c4 38	 add	 rsp, 56			; 00000038H
  001ae	c3		 ret	 0
finish_console_close ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\console.c
_TEXT	SEGMENT
dev$ = 48
disconnect_console_device PROC

; 764  : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 765  :     /* PROGRAMMING NOTE: this function should only be called to
; 766  :        disconnect a 3270/TTY console device from a telnet client
; 767  :        such as when a serious I/O error occurs. It physically
; 768  :        closes the device and marks it available for reuse.
; 769  :     */
; 770  :     dev->connected =  0;

  00009	48 8b 44 24 30	 mov	 rax, QWORD PTR dev$[rsp]
  0000e	8b 80 f8 05 00
	00		 mov	 eax, DWORD PTR [rax+1528]
  00014	83 e0 df	 and	 eax, -33		; ffffffdfH
  00017	48 8b 4c 24 30	 mov	 rcx, QWORD PTR dev$[rsp]
  0001c	89 81 f8 05 00
	00		 mov	 DWORD PTR [rcx+1528], eax

; 771  :     dev->fd        = -1;

  00022	48 8b 44 24 30	 mov	 rax, QWORD PTR dev$[rsp]
  00027	c7 80 ac 01 00
	00 ff ff ff ff	 mov	 DWORD PTR [rax+428], -1

; 772  : 
; 773  :     disconnect_telnet_client( dev->tn );

  00031	48 8b 44 24 30	 mov	 rax, QWORD PTR dev$[rsp]
  00036	48 8b 88 b0 06
	00 00		 mov	 rcx, QWORD PTR [rax+1712]
  0003d	e8 00 00 00 00	 call	 disconnect_telnet_client

; 774  : 
; 775  :     dev->tn        = NULL;

  00042	48 8b 44 24 30	 mov	 rax, QWORD PTR dev$[rsp]
  00047	48 c7 80 b0 06
	00 00 00 00 00
	00		 mov	 QWORD PTR [rax+1712], 0

; 776  : }

  00052	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00056	c3		 ret	 0
disconnect_console_device ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\console.c
_TEXT	SEGMENT
tn$ = 48
disconnect_telnet_client PROC

; 737  : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 738  :     /* PROGRAMMING NOTE: do not call this function once a DEVBLK
; 739  :        has been chosen. Only use it to disconnect a client before
; 740  :        negotiations have been completed (before a DEVBLK has been
; 741  :        chosen). Once a DEVBLK has been chosen, you should use the
; 742  :        disconnect_console_device function instead.
; 743  :     */
; 744  :     if (tn)

  00009	48 83 7c 24 30
	00		 cmp	 QWORD PTR tn$[rsp], 0
  0000f	74 5b		 je	 SHORT $LN2@disconnect

; 745  :     {
; 746  :         telnet_closesocket( tn->csock );

  00011	48 8b 44 24 30	 mov	 rax, QWORD PTR tn$[rsp]
  00016	8b 88 84 00 00
	00		 mov	 ecx, DWORD PTR [rax+132]
  0001c	e8 00 00 00 00	 call	 telnet_closesocket

; 747  :         telnet_free( tn->ctl );

  00021	48 8b 44 24 30	 mov	 rax, QWORD PTR tn$[rsp]
  00026	48 8b 88 98 00
	00 00		 mov	 rcx, QWORD PTR [rax+152]
  0002d	e8 00 00 00 00	 call	 telnet_free

; 748  : 
; 749  :         /* Free one shot send buffer if necessary */
; 750  :         if (tn->sendbuf_size) free( tn->sendbuf );

  00032	48 8b 44 24 30	 mov	 rax, QWORD PTR tn$[rsp]
  00037	83 b8 8c 00 00
	00 00		 cmp	 DWORD PTR [rax+140], 0
  0003e	74 12		 je	 SHORT $LN3@disconnect
  00040	48 8b 44 24 30	 mov	 rax, QWORD PTR tn$[rsp]
  00045	48 8b 88 90 00
	00 00		 mov	 rcx, QWORD PTR [rax+144]
  0004c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free
$LN3@disconnect:

; 751  :         tn->sendbuf_size = 0;

  00052	48 8b 44 24 30	 mov	 rax, QWORD PTR tn$[rsp]
  00057	c7 80 8c 00 00
	00 00 00 00 00	 mov	 DWORD PTR [rax+140], 0

; 752  : 
; 753  :         // "%s COMM: disconnected"
; 754  :         CONDEBUG1( HHC90504, "D", tn->clientid );
; 755  : 
; 756  :         free( tn );

  00061	48 8b 4c 24 30	 mov	 rcx, QWORD PTR tn$[rsp]
  00066	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free
$LN2@disconnect:

; 757  :     }
; 758  : }

  0006c	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00070	c3		 ret	 0
disconnect_telnet_client ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\console.c
_TEXT	SEGMENT
rc$1 = 64
tv79 = 72
dev$ = 96
finish_console_init PROC

; 708  : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 58	 sub	 rsp, 88			; 00000058H
$LN4@finish_con:

; 709  :     UNREFERENCED( dev );

  00009	33 c0		 xor	 eax, eax
  0000b	85 c0		 test	 eax, eax
  0000d	75 fa		 jne	 SHORT $LN4@finish_con

; 710  : 
; 711  :     if (!console_cnslcnt && !sysblk.cnsltid)

  0000f	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR console_cnslcnt, 0
  00016	0f 85 dc 00 00
	00		 jne	 $LN5@finish_con
  0001c	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00023	83 b8 a8 10 00
	00 00		 cmp	 DWORD PTR [rax+4264], 0
  0002a	0f 85 c8 00 00
	00		 jne	 $LN5@finish_con

; 712  :     {
; 713  :         int rc;
; 714  : 
; 715  :         console_cnslcnt++;  // No serialisation needed just yet, as

  00030	8b 05 00 00 00
	00		 mov	 eax, DWORD PTR console_cnslcnt
  00036	ff c0		 inc	 eax
  00038	89 05 00 00 00
	00		 mov	 DWORD PTR console_cnslcnt, eax

; 716  :                             // the console thread is not yet active
; 717  : 
; 718  :         if ((rc = create_thread( &sysblk.cnsltid, JOINABLE,

  0003e	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00045	48 05 98 10 00
	00		 add	 rax, 4248		; 00001098H
  0004b	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  00052	48 81 c1 a8 10
	00 00		 add	 rcx, 4264		; 000010a8H
  00059	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG177871
  00060	48 89 54 24 28	 mov	 QWORD PTR [rsp+40], rdx
  00065	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG177872
  0006c	48 89 54 24 20	 mov	 QWORD PTR [rsp+32], rdx
  00071	45 33 c9	 xor	 r9d, r9d
  00074	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:console_connection_handler
  0007b	48 8b d0	 mov	 rdx, rax
  0007e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_create_thread
  00084	89 44 24 40	 mov	 DWORD PTR rc$1[rsp], eax
  00088	83 7c 24 40 00	 cmp	 DWORD PTR rc$1[rsp], 0
  0008d	74 67		 je	 SHORT $LN7@finish_con

; 719  :                                 console_connection_handler, NULL,
; 720  :                                 CON_CONN_THREAD_NAME )))
; 721  :         {
; 722  :             // "Error in function create_thread(): %s"
; 723  :             WRMSG( HHC00102, "E", strerror( rc ));

  0008f	8b 4c 24 40	 mov	 ecx, DWORD PTR rc$1[rsp]
  00093	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_strerror
  00099	48 89 44 24 48	 mov	 QWORD PTR tv79[rsp], rax
  0009e	b9 01 00 00 00	 mov	 ecx, 1
  000a3	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  000a9	48 8b 4c 24 48	 mov	 rcx, QWORD PTR tv79[rsp]
  000ae	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  000b3	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG177873
  000ba	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  000bf	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG177874
  000c6	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  000cb	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  000d0	41 b9 03 00 00
	00		 mov	 r9d, 3
  000d6	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG177875
  000dd	ba d3 02 00 00	 mov	 edx, 723		; 000002d3H
  000e2	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG177876
  000e9	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 724  :             return 1;

  000ef	b8 01 00 00 00	 mov	 eax, 1
  000f4	eb 12		 jmp	 SHORT $LN1@finish_con
$LN7@finish_con:

; 725  :         }
; 726  :     }

  000f6	eb 0e		 jmp	 SHORT $LN6@finish_con
$LN5@finish_con:

; 727  :     else
; 728  :         console_cnslcnt++;

  000f8	8b 05 00 00 00
	00		 mov	 eax, DWORD PTR console_cnslcnt
  000fe	ff c0		 inc	 eax
  00100	89 05 00 00 00
	00		 mov	 DWORD PTR console_cnslcnt, eax
$LN6@finish_con:

; 729  : 
; 730  :     return 0;

  00106	33 c0		 xor	 eax, eax
$LN1@finish_con:

; 731  : }

  00108	48 83 c4 58	 add	 rsp, 88			; 00000058H
  0010c	c3		 ret	 0
finish_console_init ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\console.c
_TEXT	SEGMENT
rc$1 = 32
dev$ = 64
unitstat$ = 72
raise_device_attention PROC

; 683  : {

  00000	88 54 24 10	 mov	 BYTE PTR [rsp+16], dl
  00004	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00009	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 684  :     /* NOTE: the device lock must *NOT* be held! */
; 685  : 
; 686  : #if defined( _FEATURE_INTEGRATED_3270_CONSOLE )
; 687  :     if (dev == sysblk.sysgdev)

  0000d	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00014	48 8b 80 c8 11
	00 00		 mov	 rax, QWORD PTR [rax+4552]
  0001b	48 39 44 24 40	 cmp	 QWORD PTR dev$[rsp], rax
  00020	75 08		 jne	 SHORT $LN2@raise_devi

; 688  :     {
; 689  :         sclp_sysg_attention();

  00022	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_sclp_sysg_attention

; 690  :         return;

  00028	eb 52		 jmp	 SHORT $LN1@raise_devi
$LN2@raise_devi:

; 691  :     }
; 692  : #endif
; 693  : 
; 694  :     if (dev->tn->devclass != 'P' && !INITIAL_POWERON_370())

  0002a	48 8b 44 24 40	 mov	 rax, QWORD PTR dev$[rsp]
  0002f	48 8b 80 b0 06
	00 00		 mov	 rax, QWORD PTR [rax+1712]
  00036	0f b6 80 aa 00
	00 00		 movzx	 eax, BYTE PTR [rax+170]
  0003d	83 f8 50	 cmp	 eax, 80			; 00000050H
  00040	74 3a		 je	 SHORT $LN3@raise_devi
  00042	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00049	8b 80 94 12 00
	00		 mov	 eax, DWORD PTR [rax+4756]
  0004f	d1 e8		 shr	 eax, 1
  00051	83 e0 01	 and	 eax, 1
  00054	85 c0		 test	 eax, eax
  00056	75 10		 jne	 SHORT $LN4@raise_devi
  00058	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  0005f	83 b8 88 00 00
	00 00		 cmp	 DWORD PTR [rax+136], 0
  00066	74 14		 je	 SHORT $LN3@raise_devi
$LN4@raise_devi:

; 695  :     {
; 696  :         int rc = device_attention( dev, unitstat );

  00068	0f b6 54 24 48	 movzx	 edx, BYTE PTR unitstat$[rsp]
  0006d	48 8b 4c 24 40	 mov	 rcx, QWORD PTR dev$[rsp]
  00072	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_device_attention
  00078	89 44 24 20	 mov	 DWORD PTR rc$1[rsp], eax
$LN3@raise_devi:
$LN1@raise_devi:

; 697  : 
; 698  :         // "%s COMM: device attention %s; rc=%d"
; 699  :         CONDEBUG1( HHC90506, "D", dev->tn->clientid,
; 700  :             (rc == 0 ? "raised" : "REJECTED"), rc );
; 701  :     }
; 702  : }

  0007c	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00080	c3		 ret	 0
raise_device_attention ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\console.c
_TEXT	SEGMENT
success$ = 32
sendbuf_needed$ = 36
tv131 = 40
tn$ = 64
buf$ = 72
len$ = 80
sendto_client PROC

; 642  : {

  00000	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 643  :     BYTE success = TRUE;

  00013	c6 44 24 20 01	 mov	 BYTE PTR success$[rsp], 1

; 644  :     unsigned int sendbuf_needed;
; 645  : 
; 646  :     if (len > 0)

  00018	83 7c 24 50 00	 cmp	 DWORD PTR len$[rsp], 0
  0001d	0f 86 fc 00 00
	00		 jbe	 $LN2@sendto_cli

; 647  :     {
; 648  :         tn->send_err = FALSE;

  00023	48 8b 44 24 40	 mov	 rax, QWORD PTR tn$[rsp]
  00028	c6 80 b4 00 00
	00 00		 mov	 BYTE PTR [rax+180], 0

; 649  : 
; 650  :         if (tn->devclass == 'K')

  0002f	48 8b 44 24 40	 mov	 rax, QWORD PTR tn$[rsp]
  00034	0f b6 80 aa 00
	00 00		 movzx	 eax, BYTE PTR [rax+170]
  0003b	83 f8 4b	 cmp	 eax, 75			; 0000004bH
  0003e	75 22		 jne	 SHORT $LN3@sendto_cli

; 651  :         {
; 652  :             /* PROGRAMMING NOTE: the constty_execute_ccw() function
; 653  :                that calls us ensures the buffer it passes to us is
; 654  :                always null terminated so the below telnet_printf
; 655  :                does not print garbage past the end of actual data.
; 656  :             */
; 657  :             telnet_printf( tn->ctl, "%s", buf );

  00040	4c 8b 44 24 48	 mov	 r8, QWORD PTR buf$[rsp]
  00045	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG177845
  0004c	48 8b 44 24 40	 mov	 rax, QWORD PTR tn$[rsp]
  00051	48 8b 88 98 00
	00 00		 mov	 rcx, QWORD PTR [rax+152]
  00058	e8 00 00 00 00	 call	 telnet_printf

; 658  :         }

  0005d	e9 92 00 00 00	 jmp	 $LN4@sendto_cli
$LN3@sendto_cli:

; 659  :         else // (tn->devclass == 'D' || tn->devclass == 'P')
; 660  :         {
; 661  :             /* Adjust one shot send buffer */
; 662  :             sendbuf_needed = (len * 2) + 2;

  00062	8b 44 24 50	 mov	 eax, DWORD PTR len$[rsp]
  00066	8d 44 00 02	 lea	 eax, DWORD PTR [rax+rax+2]
  0006a	89 44 24 24	 mov	 DWORD PTR sendbuf_needed$[rsp], eax

; 663  :             if (sendbuf_needed > tn->sendbuf_size)

  0006e	48 8b 44 24 40	 mov	 rax, QWORD PTR tn$[rsp]
  00073	8b 80 8c 00 00
	00		 mov	 eax, DWORD PTR [rax+140]
  00079	39 44 24 24	 cmp	 DWORD PTR sendbuf_needed$[rsp], eax
  0007d	76 4e		 jbe	 SHORT $LN5@sendto_cli

; 664  :             {
; 665  :                 if (tn->sendbuf_size) free( tn->sendbuf );

  0007f	48 8b 44 24 40	 mov	 rax, QWORD PTR tn$[rsp]
  00084	83 b8 8c 00 00
	00 00		 cmp	 DWORD PTR [rax+140], 0
  0008b	74 12		 je	 SHORT $LN6@sendto_cli
  0008d	48 8b 44 24 40	 mov	 rax, QWORD PTR tn$[rsp]
  00092	48 8b 88 90 00
	00 00		 mov	 rcx, QWORD PTR [rax+144]
  00099	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free
$LN6@sendto_cli:

; 666  :                 tn->sendbuf_size = sendbuf_needed;

  0009f	48 8b 44 24 40	 mov	 rax, QWORD PTR tn$[rsp]
  000a4	8b 4c 24 24	 mov	 ecx, DWORD PTR sendbuf_needed$[rsp]
  000a8	89 88 8c 00 00
	00		 mov	 DWORD PTR [rax+140], ecx

; 667  :                 tn->sendbuf = (char*) malloc( tn->sendbuf_size );

  000ae	48 8b 44 24 40	 mov	 rax, QWORD PTR tn$[rsp]
  000b3	8b 80 8c 00 00
	00		 mov	 eax, DWORD PTR [rax+140]
  000b9	8b c8		 mov	 ecx, eax
  000bb	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_malloc
  000c1	48 8b 4c 24 40	 mov	 rcx, QWORD PTR tn$[rsp]
  000c6	48 89 81 90 00
	00 00		 mov	 QWORD PTR [rcx+144], rax
$LN5@sendto_cli:

; 668  :             }
; 669  : 
; 670  :             telnet_send_one_shot( tn->ctl, buf, len, tn->sendbuf );

  000cd	48 8b 44 24 40	 mov	 rax, QWORD PTR tn$[rsp]
  000d2	4c 8b 88 90 00
	00 00		 mov	 r9, QWORD PTR [rax+144]
  000d9	44 8b 44 24 50	 mov	 r8d, DWORD PTR len$[rsp]
  000de	48 8b 54 24 48	 mov	 rdx, QWORD PTR buf$[rsp]
  000e3	48 8b 44 24 40	 mov	 rax, QWORD PTR tn$[rsp]
  000e8	48 8b 88 98 00
	00 00		 mov	 rcx, QWORD PTR [rax+152]
  000ef	e8 00 00 00 00	 call	 telnet_send_one_shot
$LN4@sendto_cli:

; 671  :         }
; 672  : 
; 673  :         success = !tn->send_err;

  000f4	48 8b 44 24 40	 mov	 rax, QWORD PTR tn$[rsp]
  000f9	0f b6 80 b4 00
	00 00		 movzx	 eax, BYTE PTR [rax+180]
  00100	85 c0		 test	 eax, eax
  00102	75 0a		 jne	 SHORT $LN8@sendto_cli
  00104	c7 44 24 28 01
	00 00 00	 mov	 DWORD PTR tv131[rsp], 1
  0010c	eb 08		 jmp	 SHORT $LN9@sendto_cli
$LN8@sendto_cli:
  0010e	c7 44 24 28 00
	00 00 00	 mov	 DWORD PTR tv131[rsp], 0
$LN9@sendto_cli:
  00116	0f b6 44 24 28	 movzx	 eax, BYTE PTR tv131[rsp]
  0011b	88 44 24 20	 mov	 BYTE PTR success$[rsp], al
$LN2@sendto_cli:

; 674  :     }
; 675  : 
; 676  :     return success;

  0011f	0f b6 44 24 20	 movzx	 eax, BYTE PTR success$[rsp]

; 677  : }

  00124	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00128	c3		 ret	 0
sendto_client ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\console.c
_TEXT	SEGMENT
tn$ = 112
tv65 = 120
tv75 = 128
tv79 = 136
tv147 = 144
tv167 = 152
tv172 = 160
tv197 = 168
tv226 = 176
tv253 = 184
tv331 = 192
tv348 = 200
tv365 = 208
tv385 = 216
tv468 = 224
tv473 = 232
tv486 = 240
tv498 = 248
tv549 = 256
tv554 = 264
tv565 = 272
tv576 = 280
tv580 = 288
telnet$ = 320
ev$ = 328
user_data$ = 336
telnet_ev_handler PROC

; 282  : {

  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	48 81 ec 38 01
	00 00		 sub	 rsp, 312		; 00000138H

; 283  :     TELNET* tn = (TELNET*) user_data;

  00016	48 8b 84 24 50
	01 00 00	 mov	 rax, QWORD PTR user_data$[rsp]
  0001e	48 89 44 24 70	 mov	 QWORD PTR tn$[rsp], rax

; 284  : 
; 285  : #ifdef TN_DEBUG_NEGOTIATIONS
; 286  :     switch (ev->type)
; 287  :     {
; 288  :     case TELNET_EV_DO:
; 289  :     case TELNET_EV_DONT:
; 290  :     case TELNET_EV_WILL:
; 291  :     case TELNET_EV_WONT:
; 292  :         // "%s COMM: negotiating %-14s %s"
; 293  :         WRMSG( HHC90511, "D", tn->clientid,
; 294  :             telnet_evt_name( ev->neg.type ),
; 295  :             telnet_opt_name( ev->neg.telopt ));
; 296  :         break;
; 297  :     default:
; 298  :         break;
; 299  :     }
; 300  : #endif // TN_DEBUG_NEGOTIATIONS
; 301  : 
; 302  :     switch (ev->type)

  00023	48 8b 84 24 48
	01 00 00	 mov	 rax, QWORD PTR ev$[rsp]
  0002b	8b 00		 mov	 eax, DWORD PTR [rax]
  0002d	89 44 24 78	 mov	 DWORD PTR tv65[rsp], eax
  00031	83 7c 24 78 0b	 cmp	 DWORD PTR tv65[rsp], 11
  00036	0f 87 c0 0d 00
	00		 ja	 $LN76@telnet_ev_
  0003c	48 63 44 24 78	 movsxd	 rax, DWORD PTR tv65[rsp]
  00041	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__ImageBase
  00048	8b 84 81 00 00
	00 00		 mov	 eax, DWORD PTR $LN78@telnet_ev_[rcx+rax*4]
  0004f	48 03 c1	 add	 rax, rcx
  00052	ff e0		 jmp	 rax
$LN4@telnet_ev_:

; 303  :     {
; 304  : 
; 305  :     /* Raw data needs to be sent to peer */
; 306  :     case TELNET_EV_SEND:
; 307  : 
; 308  :         // "%s COMM: sending %d bytes"
; 309  :         CONDEBUG2( HHC90500, "D", tn->clientid, ev->data.size );
; 310  :         DUMPBUF(   HHC90500, ev->data.buffer, ev->data.size, tn->do_tn3270 ? 1 : 0 );
; 311  : 
; 312  :         if (write_socket( tn->csock, ev->data.buffer, ev->data.size ) <= 0)

  00054	48 8b 84 24 48
	01 00 00	 mov	 rax, QWORD PTR ev$[rsp]
  0005c	44 8b 40 10	 mov	 r8d, DWORD PTR [rax+16]
  00060	48 8b 84 24 48
	01 00 00	 mov	 rax, QWORD PTR ev$[rsp]
  00068	48 8b 50 08	 mov	 rdx, QWORD PTR [rax+8]
  0006c	48 8b 44 24 70	 mov	 rax, QWORD PTR tn$[rsp]
  00071	8b 88 84 00 00
	00		 mov	 ecx, DWORD PTR [rax+132]
  00077	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_write_socket
  0007d	85 c0		 test	 eax, eax
  0007f	0f 8f 94 00 00
	00		 jg	 $LN5@telnet_ev_

; 313  :         {
; 314  :             tn->send_err = TRUE;

  00085	48 8b 44 24 70	 mov	 rax, QWORD PTR tn$[rsp]
  0008a	c6 80 b4 00 00
	00 01		 mov	 BYTE PTR [rax+180], 1

; 315  :             // "%s COMM: send() failed: %s"
; 316  :             WRMSG( HHC02900, "E", tn->clientid, strerror( errno ));

  00091	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno
  00097	8b 08		 mov	 ecx, DWORD PTR [rax]
  00099	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_strerror
  0009f	48 89 84 24 80
	00 00 00	 mov	 QWORD PTR tv75[rsp], rax
  000a7	48 8b 4c 24 70	 mov	 rcx, QWORD PTR tn$[rsp]
  000ac	48 83 c1 62	 add	 rcx, 98			; 00000062H
  000b0	48 89 8c 24 88
	00 00 00	 mov	 QWORD PTR tv79[rsp], rcx
  000b8	b9 01 00 00 00	 mov	 ecx, 1
  000bd	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  000c3	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR tv75[rsp]
  000cb	48 89 4c 24 40	 mov	 QWORD PTR [rsp+64], rcx
  000d0	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR tv79[rsp]
  000d8	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  000dd	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG177675
  000e4	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  000e9	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG177676
  000f0	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  000f5	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  000fa	41 b9 03 00 00
	00		 mov	 r9d, 3
  00100	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG177677
  00107	ba 3c 01 00 00	 mov	 edx, 316		; 0000013cH
  0010c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG177678
  00113	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg
$LN5@telnet_ev_:

; 317  :         }
; 318  :         break;

  00119	e9 67 0d 00 00	 jmp	 $LN2@telnet_ev_
$LN6@telnet_ev_:

; 319  : 
; 320  : 
; 321  :     /* Non-telnet data received from peer */
; 322  :     case TELNET_EV_DATA:
; 323  : 
; 324  :         if (tn->do_tn3270)

  0011e	48 8b 44 24 70	 mov	 rax, QWORD PTR tn$[rsp]
  00123	0f b6 80 ac 00
	00 00		 movzx	 eax, BYTE PTR [rax+172]
  0012a	85 c0		 test	 eax, eax
  0012c	74 24		 je	 SHORT $LN7@telnet_ev_

; 325  :             loc3270_input( tn, ev->data.buffer, ev->data.size );

  0012e	48 8b 84 24 48
	01 00 00	 mov	 rax, QWORD PTR ev$[rsp]
  00136	44 8b 40 10	 mov	 r8d, DWORD PTR [rax+16]
  0013a	48 8b 84 24 48
	01 00 00	 mov	 rax, QWORD PTR ev$[rsp]
  00142	48 8b 50 08	 mov	 rdx, QWORD PTR [rax+8]
  00146	48 8b 4c 24 70	 mov	 rcx, QWORD PTR tn$[rsp]
  0014b	e8 00 00 00 00	 call	 loc3270_input
  00150	eb 22		 jmp	 SHORT $LN8@telnet_ev_
$LN7@telnet_ev_:

; 326  :         else
; 327  :             constty_input( tn, ev->data.buffer, ev->data.size );

  00152	48 8b 84 24 48
	01 00 00	 mov	 rax, QWORD PTR ev$[rsp]
  0015a	44 8b 40 10	 mov	 r8d, DWORD PTR [rax+16]
  0015e	48 8b 84 24 48
	01 00 00	 mov	 rax, QWORD PTR ev$[rsp]
  00166	48 8b 50 08	 mov	 rdx, QWORD PTR [rax+8]
  0016a	48 8b 4c 24 70	 mov	 rcx, QWORD PTR tn$[rsp]
  0016f	e8 00 00 00 00	 call	 constty_input
$LN8@telnet_ev_:

; 328  :         break;

  00174	e9 0c 0d 00 00	 jmp	 $LN2@telnet_ev_
$LN9@telnet_ev_:

; 329  : 
; 330  : 
; 331  :     /* Enable local option */
; 332  :     case TELNET_EV_DO:
; 333  : 
; 334  :         /* Enable BINARY mode when requested */
; 335  :         if (ev->neg.telopt == TELNET_TELOPT_BINARY)

  00179	48 8b 84 24 48
	01 00 00	 mov	 rax, QWORD PTR ev$[rsp]
  00181	0f b6 40 04	 movzx	 eax, BYTE PTR [rax+4]
  00185	85 c0		 test	 eax, eax
  00187	75 11		 jne	 SHORT $LN10@telnet_ev_

; 336  :         {
; 337  :             tn->do_bin = 1;

  00189	48 8b 44 24 70	 mov	 rax, QWORD PTR tn$[rsp]
  0018e	c6 80 ad 00 00
	00 01		 mov	 BYTE PTR [rax+173], 1

; 338  :         }

  00195	e9 b4 01 00 00	 jmp	 $LN11@telnet_ev_
$LN10@telnet_ev_:

; 339  : 
; 340  :         /* Enable "Suppress Go Aheads" when asked */
; 341  :         else if (ev->neg.telopt == TELNET_TELOPT_SGA)

  0019a	48 8b 84 24 48
	01 00 00	 mov	 rax, QWORD PTR ev$[rsp]
  001a2	0f b6 40 04	 movzx	 eax, BYTE PTR [rax+4]
  001a6	83 f8 03	 cmp	 eax, 3
  001a9	75 05		 jne	 SHORT $LN12@telnet_ev_

; 342  :         {
; 343  :             ; // (ignore; we always suppress go-aheads anyway)
; 344  :         }

  001ab	e9 9e 01 00 00	 jmp	 $LN13@telnet_ev_
$LN12@telnet_ev_:

; 345  : 
; 346  :         /* Refuse to enable TTYPE option when asked */
; 347  :         else if (ev->neg.telopt == TELNET_TELOPT_TTYPE)

  001b0	48 8b 84 24 48
	01 00 00	 mov	 rax, QWORD PTR ev$[rsp]
  001b8	0f b6 40 04	 movzx	 eax, BYTE PTR [rax+4]
  001bc	83 f8 18	 cmp	 eax, 24
  001bf	0f 85 a4 00 00
	00		 jne	 $LN14@telnet_ev_

; 348  :         {
; 349  :             /* We can't enable it since we don't HAVE a Terminal Type! */
; 350  :             // "%s COMM: refusing client demand to %s %s"
; 351  :             WRMSG( HHC02901, "W", tn->clientid, "enable", "TTYPE" );

  001c5	48 8b 44 24 70	 mov	 rax, QWORD PTR tn$[rsp]
  001ca	48 83 c0 62	 add	 rax, 98			; 00000062H
  001ce	48 89 84 24 90
	00 00 00	 mov	 QWORD PTR tv147[rsp], rax
  001d6	b9 01 00 00 00	 mov	 ecx, 1
  001db	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  001e1	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG177689
  001e8	48 89 4c 24 48	 mov	 QWORD PTR [rsp+72], rcx
  001ed	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG177690
  001f4	48 89 4c 24 40	 mov	 QWORD PTR [rsp+64], rcx
  001f9	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR tv147[rsp]
  00201	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  00206	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG177691
  0020d	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  00212	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG177692
  00219	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  0021e	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00223	41 b9 03 00 00
	00		 mov	 r9d, 3
  00229	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG177693
  00230	ba 5f 01 00 00	 mov	 edx, 351		; 0000015fH
  00235	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG177694
  0023c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 352  :             telnet_negotiate( tn->ctl, TELNET_WONT, TELNET_TELOPT_TTYPE );

  00242	41 b0 18	 mov	 r8b, 24
  00245	b2 fc		 mov	 dl, 252			; 000000fcH
  00247	48 8b 44 24 70	 mov	 rax, QWORD PTR tn$[rsp]
  0024c	48 8b 88 98 00
	00 00		 mov	 rcx, QWORD PTR [rax+152]
  00253	e8 00 00 00 00	 call	 telnet_negotiate

; 353  :             tn->neg_fail = TRUE;

  00258	48 8b 44 24 70	 mov	 rax, QWORD PTR tn$[rsp]
  0025d	c6 80 b3 00 00
	00 01		 mov	 BYTE PTR [rax+179], 1

; 354  :         }

  00264	e9 e5 00 00 00	 jmp	 $LN15@telnet_ev_
$LN14@telnet_ev_:

; 355  : 
; 356  :         /* Enable EOR mode when requested */
; 357  :         else if (ev->neg.telopt == TELNET_TELOPT_EOR)

  00269	48 8b 84 24 48
	01 00 00	 mov	 rax, QWORD PTR ev$[rsp]
  00271	0f b6 40 04	 movzx	 eax, BYTE PTR [rax+4]
  00275	83 f8 19	 cmp	 eax, 25
  00278	75 11		 jne	 SHORT $LN16@telnet_ev_

; 358  :         {
; 359  :             tn->do_eor = 1;

  0027a	48 8b 44 24 70	 mov	 rax, QWORD PTR tn$[rsp]
  0027f	c6 80 ae 00 00
	00 01		 mov	 BYTE PTR [rax+174], 1

; 360  :         }

  00286	e9 c3 00 00 00	 jmp	 $LN17@telnet_ev_
$LN16@telnet_ev_:

; 361  : 
; 362  :         /* Refuse to enable any other options we don't support */
; 363  :         else
; 364  :         {
; 365  :             // "%s COMM: refusing client demand to %s %s"
; 366  :             WRMSG( HHC02901, "W", tn->clientid, "enable",

  0028b	48 8b 84 24 48
	01 00 00	 mov	 rax, QWORD PTR ev$[rsp]
  00293	0f b6 48 04	 movzx	 ecx, BYTE PTR [rax+4]
  00297	e8 00 00 00 00	 call	 telnet_opt_name
  0029c	48 89 84 24 98
	00 00 00	 mov	 QWORD PTR tv167[rsp], rax
  002a4	48 8b 4c 24 70	 mov	 rcx, QWORD PTR tn$[rsp]
  002a9	48 83 c1 62	 add	 rcx, 98			; 00000062H
  002ad	48 89 8c 24 a0
	00 00 00	 mov	 QWORD PTR tv172[rsp], rcx
  002b5	b9 01 00 00 00	 mov	 ecx, 1
  002ba	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  002c0	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR tv167[rsp]
  002c8	48 89 4c 24 48	 mov	 QWORD PTR [rsp+72], rcx
  002cd	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG177697
  002d4	48 89 4c 24 40	 mov	 QWORD PTR [rsp+64], rcx
  002d9	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR tv172[rsp]
  002e1	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  002e6	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG177698
  002ed	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  002f2	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG177699
  002f9	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  002fe	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00303	41 b9 03 00 00
	00		 mov	 r9d, 3
  00309	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG177700
  00310	ba 6f 01 00 00	 mov	 edx, 367		; 0000016fH
  00315	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG177701
  0031c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 367  :                 telnet_opt_name( ev->neg.telopt ) );
; 368  :             telnet_negotiate( tn->ctl, TELNET_WONT, ev->neg.telopt );

  00322	48 8b 84 24 48
	01 00 00	 mov	 rax, QWORD PTR ev$[rsp]
  0032a	44 0f b6 40 04	 movzx	 r8d, BYTE PTR [rax+4]
  0032f	b2 fc		 mov	 dl, 252			; 000000fcH
  00331	48 8b 44 24 70	 mov	 rax, QWORD PTR tn$[rsp]
  00336	48 8b 88 98 00
	00 00		 mov	 rcx, QWORD PTR [rax+152]
  0033d	e8 00 00 00 00	 call	 telnet_negotiate

; 369  :             tn->neg_fail = TRUE;

  00342	48 8b 44 24 70	 mov	 rax, QWORD PTR tn$[rsp]
  00347	c6 80 b3 00 00
	00 01		 mov	 BYTE PTR [rax+179], 1
$LN17@telnet_ev_:
$LN15@telnet_ev_:
$LN13@telnet_ev_:
$LN11@telnet_ev_:

; 370  :         }
; 371  :         break;

  0034e	e9 32 0b 00 00	 jmp	 $LN2@telnet_ev_
$LN18@telnet_ev_:

; 372  : 
; 373  : 
; 374  :     /* Disable local option */
; 375  :     case TELNET_EV_DONT:
; 376  : 
; 377  :         /* Disable BINARY mode when requested (if possible) */
; 378  :         if (ev->neg.telopt == TELNET_TELOPT_BINARY)

  00353	48 8b 84 24 48
	01 00 00	 mov	 rax, QWORD PTR ev$[rsp]
  0035b	0f b6 40 04	 movzx	 eax, BYTE PTR [rax+4]
  0035f	85 c0		 test	 eax, eax
  00361	0f 85 ec 00 00
	00		 jne	 $LN19@telnet_ev_

; 379  :         {
; 380  :             if (tn->do_tn3270)

  00367	48 8b 44 24 70	 mov	 rax, QWORD PTR tn$[rsp]
  0036c	0f b6 80 ac 00
	00 00		 movzx	 eax, BYTE PTR [rax+172]
  00373	85 c0		 test	 eax, eax
  00375	0f 84 a1 00 00
	00		 je	 $LN21@telnet_ev_

; 381  :             {
; 382  :                 /* REFUSE! TN3270 mode requires it! */
; 383  :                 // "%s COMM: refusing client demand to %s %s"
; 384  :                 WRMSG( HHC02901, "W", tn->clientid, "disable", "BINARY mode" );

  0037b	48 8b 44 24 70	 mov	 rax, QWORD PTR tn$[rsp]
  00380	48 83 c0 62	 add	 rax, 98			; 00000062H
  00384	48 89 84 24 a8
	00 00 00	 mov	 QWORD PTR tv197[rsp], rax
  0038c	b9 01 00 00 00	 mov	 ecx, 1
  00391	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  00397	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG177707
  0039e	48 89 4c 24 48	 mov	 QWORD PTR [rsp+72], rcx
  003a3	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG177708
  003aa	48 89 4c 24 40	 mov	 QWORD PTR [rsp+64], rcx
  003af	48 8b 8c 24 a8
	00 00 00	 mov	 rcx, QWORD PTR tv197[rsp]
  003b7	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  003bc	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG177709
  003c3	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  003c8	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG177710
  003cf	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  003d4	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  003d9	41 b9 03 00 00
	00		 mov	 r9d, 3
  003df	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG177711
  003e6	ba 80 01 00 00	 mov	 edx, 384		; 00000180H
  003eb	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG177712
  003f2	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 385  :                 telnet_negotiate( tn->ctl, TELNET_WILL, TELNET_TELOPT_BINARY );

  003f8	45 33 c0	 xor	 r8d, r8d
  003fb	b2 fb		 mov	 dl, 251			; 000000fbH
  003fd	48 8b 44 24 70	 mov	 rax, QWORD PTR tn$[rsp]
  00402	48 8b 88 98 00
	00 00		 mov	 rcx, QWORD PTR [rax+152]
  00409	e8 00 00 00 00	 call	 telnet_negotiate

; 386  :                 tn->neg_fail = TRUE;

  0040e	48 8b 44 24 70	 mov	 rax, QWORD PTR tn$[rsp]
  00413	c6 80 b3 00 00
	00 01		 mov	 BYTE PTR [rax+179], 1

; 387  :             }

  0041a	eb 32		 jmp	 SHORT $LN22@telnet_ev_
$LN21@telnet_ev_:

; 388  :             else
; 389  :             {
; 390  :                 /* Otherwise do as requested */
; 391  :                 if (tn->do_bin)

  0041c	48 8b 44 24 70	 mov	 rax, QWORD PTR tn$[rsp]
  00421	0f b6 80 ad 00
	00 00		 movzx	 eax, BYTE PTR [rax+173]
  00428	85 c0		 test	 eax, eax
  0042a	74 22		 je	 SHORT $LN23@telnet_ev_

; 392  :                 {
; 393  :                     tn->do_bin = 0;

  0042c	48 8b 44 24 70	 mov	 rax, QWORD PTR tn$[rsp]
  00431	c6 80 ad 00 00
	00 00		 mov	 BYTE PTR [rax+173], 0

; 394  :                     telnet_negotiate( tn->ctl, TELNET_WONT, TELNET_TELOPT_BINARY );

  00438	45 33 c0	 xor	 r8d, r8d
  0043b	b2 fc		 mov	 dl, 252			; 000000fcH
  0043d	48 8b 44 24 70	 mov	 rax, QWORD PTR tn$[rsp]
  00442	48 8b 88 98 00
	00 00		 mov	 rcx, QWORD PTR [rax+152]
  00449	e8 00 00 00 00	 call	 telnet_negotiate
$LN23@telnet_ev_:
$LN22@telnet_ev_:

; 395  :                 }
; 396  :             }
; 397  :         }

  0044e	e9 cb 01 00 00	 jmp	 $LN20@telnet_ev_
$LN19@telnet_ev_:

; 398  : 
; 399  :         /* ALWAYS refuse to disable "Suppress Go Aheads" */
; 400  :         else if (ev->neg.telopt == TELNET_TELOPT_SGA)

  00453	48 8b 84 24 48
	01 00 00	 mov	 rax, QWORD PTR ev$[rsp]
  0045b	0f b6 40 04	 movzx	 eax, BYTE PTR [rax+4]
  0045f	83 f8 03	 cmp	 eax, 3
  00462	0f 85 a4 00 00
	00		 jne	 $LN24@telnet_ev_

; 401  :         {
; 402  :             // "%s COMM: refusing client demand to %s %s"
; 403  :             WRMSG( HHC02901, "W", tn->clientid, "disable", "Suppress Go Aheads" );

  00468	48 8b 44 24 70	 mov	 rax, QWORD PTR tn$[rsp]
  0046d	48 83 c0 62	 add	 rax, 98			; 00000062H
  00471	48 89 84 24 b0
	00 00 00	 mov	 QWORD PTR tv226[rsp], rax
  00479	b9 01 00 00 00	 mov	 ecx, 1
  0047e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  00484	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG177716
  0048b	48 89 4c 24 48	 mov	 QWORD PTR [rsp+72], rcx
  00490	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG177717
  00497	48 89 4c 24 40	 mov	 QWORD PTR [rsp+64], rcx
  0049c	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR tv226[rsp]
  004a4	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  004a9	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG177718
  004b0	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  004b5	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG177719
  004bc	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  004c1	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  004c6	41 b9 03 00 00
	00		 mov	 r9d, 3
  004cc	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG177720
  004d3	ba 93 01 00 00	 mov	 edx, 403		; 00000193H
  004d8	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG177721
  004df	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 404  :             telnet_negotiate( tn->ctl, TELNET_WILL, TELNET_TELOPT_SGA );

  004e5	41 b0 03	 mov	 r8b, 3
  004e8	b2 fb		 mov	 dl, 251			; 000000fbH
  004ea	48 8b 44 24 70	 mov	 rax, QWORD PTR tn$[rsp]
  004ef	48 8b 88 98 00
	00 00		 mov	 rcx, QWORD PTR [rax+152]
  004f6	e8 00 00 00 00	 call	 telnet_negotiate

; 405  :             tn->neg_fail = TRUE;

  004fb	48 8b 44 24 70	 mov	 rax, QWORD PTR tn$[rsp]
  00500	c6 80 b3 00 00
	00 01		 mov	 BYTE PTR [rax+179], 1

; 406  :         }

  00507	e9 12 01 00 00	 jmp	 $LN25@telnet_ev_
$LN24@telnet_ev_:

; 407  : 
; 408  :         /* This should never occur since we never said we wanted to enable
; 409  :            it, but if they want to demand we disable it anyway, then fine. */
; 410  :         else if (ev->neg.telopt == TELNET_TELOPT_TTYPE)

  0050c	48 8b 84 24 48
	01 00 00	 mov	 rax, QWORD PTR ev$[rsp]
  00514	0f b6 40 04	 movzx	 eax, BYTE PTR [rax+4]
  00518	83 f8 18	 cmp	 eax, 24
  0051b	75 05		 jne	 SHORT $LN26@telnet_ev_

; 411  :         {
; 412  :             ; // (ignore)
; 413  :         }

  0051d	e9 fc 00 00 00	 jmp	 $LN27@telnet_ev_
$LN26@telnet_ev_:

; 414  : 
; 415  :         /* Disable EOR mode when requested (if possible) */
; 416  :         else if (ev->neg.telopt == TELNET_TELOPT_EOR)

  00522	48 8b 84 24 48
	01 00 00	 mov	 rax, QWORD PTR ev$[rsp]
  0052a	0f b6 40 04	 movzx	 eax, BYTE PTR [rax+4]
  0052e	83 f8 19	 cmp	 eax, 25
  00531	0f 85 e7 00 00
	00		 jne	 $LN28@telnet_ev_

; 417  :         {
; 418  :             if (tn->do_tn3270)

  00537	48 8b 44 24 70	 mov	 rax, QWORD PTR tn$[rsp]
  0053c	0f b6 80 ac 00
	00 00		 movzx	 eax, BYTE PTR [rax+172]
  00543	85 c0		 test	 eax, eax
  00545	0f 84 a1 00 00
	00		 je	 $LN29@telnet_ev_

; 419  :             {
; 420  :                 /* REFUSE! TN3270 mode requires it! */
; 421  :                 // "%s COMM: refusing client demand to %s %s"
; 422  :                 WRMSG( HHC02901, "W", tn->clientid, "disable", "EOR mode" );

  0054b	48 8b 44 24 70	 mov	 rax, QWORD PTR tn$[rsp]
  00550	48 83 c0 62	 add	 rax, 98			; 00000062H
  00554	48 89 84 24 b8
	00 00 00	 mov	 QWORD PTR tv253[rsp], rax
  0055c	b9 01 00 00 00	 mov	 ecx, 1
  00561	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  00567	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG177727
  0056e	48 89 4c 24 48	 mov	 QWORD PTR [rsp+72], rcx
  00573	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG177728
  0057a	48 89 4c 24 40	 mov	 QWORD PTR [rsp+64], rcx
  0057f	48 8b 8c 24 b8
	00 00 00	 mov	 rcx, QWORD PTR tv253[rsp]
  00587	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  0058c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG177729
  00593	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  00598	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG177730
  0059f	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  005a4	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  005a9	41 b9 03 00 00
	00		 mov	 r9d, 3
  005af	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG177731
  005b6	ba a6 01 00 00	 mov	 edx, 422		; 000001a6H
  005bb	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG177732
  005c2	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 423  :                 telnet_negotiate( tn->ctl, TELNET_WILL, TELNET_TELOPT_EOR );

  005c8	41 b0 19	 mov	 r8b, 25
  005cb	b2 fb		 mov	 dl, 251			; 000000fbH
  005cd	48 8b 44 24 70	 mov	 rax, QWORD PTR tn$[rsp]
  005d2	48 8b 88 98 00
	00 00		 mov	 rcx, QWORD PTR [rax+152]
  005d9	e8 00 00 00 00	 call	 telnet_negotiate

; 424  :                 tn->neg_fail = TRUE;

  005de	48 8b 44 24 70	 mov	 rax, QWORD PTR tn$[rsp]
  005e3	c6 80 b3 00 00
	00 01		 mov	 BYTE PTR [rax+179], 1

; 425  :             }

  005ea	eb 32		 jmp	 SHORT $LN30@telnet_ev_
$LN29@telnet_ev_:

; 426  :             else
; 427  :             {
; 428  :                 /* Otherwise do as requested */
; 429  :                 if (tn->do_eor)

  005ec	48 8b 44 24 70	 mov	 rax, QWORD PTR tn$[rsp]
  005f1	0f b6 80 ae 00
	00 00		 movzx	 eax, BYTE PTR [rax+174]
  005f8	85 c0		 test	 eax, eax
  005fa	74 22		 je	 SHORT $LN31@telnet_ev_

; 430  :                 {
; 431  :                     tn->do_eor = 0;

  005fc	48 8b 44 24 70	 mov	 rax, QWORD PTR tn$[rsp]
  00601	c6 80 ae 00 00
	00 00		 mov	 BYTE PTR [rax+174], 0

; 432  :                     telnet_negotiate( tn->ctl, TELNET_WONT, TELNET_TELOPT_EOR );

  00608	41 b0 19	 mov	 r8b, 25
  0060b	b2 fc		 mov	 dl, 252			; 000000fcH
  0060d	48 8b 44 24 70	 mov	 rax, QWORD PTR tn$[rsp]
  00612	48 8b 88 98 00
	00 00		 mov	 rcx, QWORD PTR [rax+152]
  00619	e8 00 00 00 00	 call	 telnet_negotiate
$LN31@telnet_ev_:
$LN30@telnet_ev_:
$LN28@telnet_ev_:
$LN27@telnet_ev_:
$LN25@telnet_ev_:
$LN20@telnet_ev_:

; 433  :                 }
; 434  :             }
; 435  :         }
; 436  :         break;

  0061e	e9 62 08 00 00	 jmp	 $LN2@telnet_ev_
$LN32@telnet_ev_:

; 437  : 
; 438  : 
; 439  :     /* Remote option enabled */
; 440  :     case TELNET_EV_WILL:
; 441  : 
; 442  :         if (ev->neg.telopt == TELNET_TELOPT_BINARY)

  00623	48 8b 84 24 48
	01 00 00	 mov	 rax, QWORD PTR ev$[rsp]
  0062b	0f b6 40 04	 movzx	 eax, BYTE PTR [rax+4]
  0062f	85 c0		 test	 eax, eax
  00631	75 02		 jne	 SHORT $LN33@telnet_ev_

; 443  :         {
; 444  :             ; // (ignore)
; 445  :         }

  00633	eb 43		 jmp	 SHORT $LN34@telnet_ev_
$LN33@telnet_ev_:

; 446  : 
; 447  :         else if (ev->neg.telopt == TELNET_TELOPT_SGA)

  00635	48 8b 84 24 48
	01 00 00	 mov	 rax, QWORD PTR ev$[rsp]
  0063d	0f b6 40 04	 movzx	 eax, BYTE PTR [rax+4]
  00641	83 f8 03	 cmp	 eax, 3
  00644	75 02		 jne	 SHORT $LN35@telnet_ev_

; 448  :         {
; 449  :             ; // (ignore; we expect them to always suppress go-aheads anyway)
; 450  :         }

  00646	eb 30		 jmp	 SHORT $LN36@telnet_ev_
$LN35@telnet_ev_:

; 451  : 
; 452  :         /* Ask them to SEND us their TTYPE when they're willing to */
; 453  :         else if (ev->neg.telopt == TELNET_TELOPT_TTYPE)

  00648	48 8b 84 24 48
	01 00 00	 mov	 rax, QWORD PTR ev$[rsp]
  00650	0f b6 40 04	 movzx	 eax, BYTE PTR [rax+4]
  00654	83 f8 18	 cmp	 eax, 24
  00657	75 13		 jne	 SHORT $LN37@telnet_ev_

; 454  :         {
; 455  :             telnet_ttype_send( tn->ctl );

  00659	48 8b 44 24 70	 mov	 rax, QWORD PTR tn$[rsp]
  0065e	48 8b 88 98 00
	00 00		 mov	 rcx, QWORD PTR [rax+152]
  00665	e8 00 00 00 00	 call	 telnet_ttype_send

; 456  :         }

  0066a	eb 0c		 jmp	 SHORT $LN38@telnet_ev_
$LN37@telnet_ev_:

; 457  : 
; 458  :         else if (ev->neg.telopt == TELNET_TELOPT_EOR)

  0066c	48 8b 84 24 48
	01 00 00	 mov	 rax, QWORD PTR ev$[rsp]
  00674	0f b6 40 04	 movzx	 eax, BYTE PTR [rax+4]
$LN38@telnet_ev_:
$LN36@telnet_ev_:
$LN34@telnet_ev_:

; 459  :         {
; 460  :             ; // (ignore)
; 461  :         }
; 462  :         break;

  00678	e9 08 08 00 00	 jmp	 $LN2@telnet_ev_
$LN40@telnet_ev_:

; 463  : 
; 464  : 
; 465  :     /* Remote option disabled */
; 466  :     case TELNET_EV_WONT:
; 467  : 
; 468  :         /* Fail negotiations if they refused TN3270 BINARY mode */
; 469  :         if (ev->neg.telopt == TELNET_TELOPT_BINARY)

  0067d	48 8b 84 24 48
	01 00 00	 mov	 rax, QWORD PTR ev$[rsp]
  00685	0f b6 40 04	 movzx	 eax, BYTE PTR [rax+4]
  00689	85 c0		 test	 eax, eax
  0068b	0f 85 a2 00 00
	00		 jne	 $LN41@telnet_ev_

; 470  :         {
; 471  :             if (tn->do_tn3270)

  00691	48 8b 44 24 70	 mov	 rax, QWORD PTR tn$[rsp]
  00696	0f b6 80 ac 00
	00 00		 movzx	 eax, BYTE PTR [rax+172]
  0069d	85 c0		 test	 eax, eax
  0069f	0f 84 89 00 00
	00		 je	 $LN43@telnet_ev_

; 472  :             {
; 473  :                 /* TN3270 mode requires it! */
; 474  :                 // "%s COMM: client refused to %s %s"
; 475  :                 WRMSG( HHC02902, "W", tn->clientid, "enable", "BINARY mode" );

  006a5	48 8b 44 24 70	 mov	 rax, QWORD PTR tn$[rsp]
  006aa	48 83 c0 62	 add	 rax, 98			; 00000062H
  006ae	48 89 84 24 c0
	00 00 00	 mov	 QWORD PTR tv331[rsp], rax
  006b6	b9 01 00 00 00	 mov	 ecx, 1
  006bb	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  006c1	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG177746
  006c8	48 89 4c 24 48	 mov	 QWORD PTR [rsp+72], rcx
  006cd	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG177747
  006d4	48 89 4c 24 40	 mov	 QWORD PTR [rsp+64], rcx
  006d9	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR tv331[rsp]
  006e1	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  006e6	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG177748
  006ed	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  006f2	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG177749
  006f9	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  006fe	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00703	41 b9 03 00 00
	00		 mov	 r9d, 3
  00709	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG177750
  00710	ba db 01 00 00	 mov	 edx, 475		; 000001dbH
  00715	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG177751
  0071c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 476  :                 tn->neg_fail = TRUE;

  00722	48 8b 44 24 70	 mov	 rax, QWORD PTR tn$[rsp]
  00727	c6 80 b3 00 00
	00 01		 mov	 BYTE PTR [rax+179], 1
$LN43@telnet_ev_:

; 477  :             }
; 478  :         }

  0072e	e9 f8 01 00 00	 jmp	 $LN42@telnet_ev_
$LN41@telnet_ev_:

; 479  : 
; 480  :         /* Fail negotiations if they refuse to Suppress Go Aheads */
; 481  :         else if (ev->neg.telopt == TELNET_TELOPT_SGA)

  00733	48 8b 84 24 48
	01 00 00	 mov	 rax, QWORD PTR ev$[rsp]
  0073b	0f b6 40 04	 movzx	 eax, BYTE PTR [rax+4]
  0073f	83 f8 03	 cmp	 eax, 3
  00742	0f 85 8e 00 00
	00		 jne	 $LN44@telnet_ev_

; 482  :         {
; 483  :             // "%s COMM: client refused to %s %s"
; 484  :             WRMSG( HHC02902, "W", tn->clientid, "enable", "Suppress Go Aheads" );

  00748	48 8b 44 24 70	 mov	 rax, QWORD PTR tn$[rsp]
  0074d	48 83 c0 62	 add	 rax, 98			; 00000062H
  00751	48 89 84 24 c8
	00 00 00	 mov	 QWORD PTR tv348[rsp], rax
  00759	b9 01 00 00 00	 mov	 ecx, 1
  0075e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  00764	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG177754
  0076b	48 89 4c 24 48	 mov	 QWORD PTR [rsp+72], rcx
  00770	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG177755
  00777	48 89 4c 24 40	 mov	 QWORD PTR [rsp+64], rcx
  0077c	48 8b 8c 24 c8
	00 00 00	 mov	 rcx, QWORD PTR tv348[rsp]
  00784	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  00789	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG177756
  00790	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  00795	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG177757
  0079c	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  007a1	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  007a6	41 b9 03 00 00
	00		 mov	 r9d, 3
  007ac	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG177758
  007b3	ba e4 01 00 00	 mov	 edx, 484		; 000001e4H
  007b8	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG177759
  007bf	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 485  :             tn->neg_fail = TRUE;

  007c5	48 8b 44 24 70	 mov	 rax, QWORD PTR tn$[rsp]
  007ca	c6 80 b3 00 00
	00 01		 mov	 BYTE PTR [rax+179], 1

; 486  :         }

  007d1	e9 55 01 00 00	 jmp	 $LN45@telnet_ev_
$LN44@telnet_ev_:

; 487  : 
; 488  :         /* Fail negotiations if they refuse to send their TTYPE */
; 489  :         else if (ev->neg.telopt == TELNET_TELOPT_TTYPE)

  007d6	48 8b 84 24 48
	01 00 00	 mov	 rax, QWORD PTR ev$[rsp]
  007de	0f b6 40 04	 movzx	 eax, BYTE PTR [rax+4]
  007e2	83 f8 18	 cmp	 eax, 24
  007e5	0f 85 8e 00 00
	00		 jne	 $LN46@telnet_ev_

; 490  :         {
; 491  :             // "%s COMM: client refused to %s %s"
; 492  :             WRMSG( HHC02902, "W", tn->clientid, "enable", "TTYPE" );

  007eb	48 8b 44 24 70	 mov	 rax, QWORD PTR tn$[rsp]
  007f0	48 83 c0 62	 add	 rax, 98			; 00000062H
  007f4	48 89 84 24 d0
	00 00 00	 mov	 QWORD PTR tv365[rsp], rax
  007fc	b9 01 00 00 00	 mov	 ecx, 1
  00801	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  00807	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG177762
  0080e	48 89 4c 24 48	 mov	 QWORD PTR [rsp+72], rcx
  00813	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG177763
  0081a	48 89 4c 24 40	 mov	 QWORD PTR [rsp+64], rcx
  0081f	48 8b 8c 24 d0
	00 00 00	 mov	 rcx, QWORD PTR tv365[rsp]
  00827	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  0082c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG177764
  00833	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  00838	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG177765
  0083f	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00844	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00849	41 b9 03 00 00
	00		 mov	 r9d, 3
  0084f	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG177766
  00856	ba ec 01 00 00	 mov	 edx, 492		; 000001ecH
  0085b	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG177767
  00862	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 493  :             tn->neg_fail = TRUE;

  00868	48 8b 44 24 70	 mov	 rax, QWORD PTR tn$[rsp]
  0086d	c6 80 b3 00 00
	00 01		 mov	 BYTE PTR [rax+179], 1

; 494  :         }

  00874	e9 b2 00 00 00	 jmp	 $LN47@telnet_ev_
$LN46@telnet_ev_:

; 495  : 
; 496  :         /* Fail negotiations if they refused TN3270 EOR mode */
; 497  :         else if (ev->neg.telopt == TELNET_TELOPT_EOR)

  00879	48 8b 84 24 48
	01 00 00	 mov	 rax, QWORD PTR ev$[rsp]
  00881	0f b6 40 04	 movzx	 eax, BYTE PTR [rax+4]
  00885	83 f8 19	 cmp	 eax, 25
  00888	0f 85 9d 00 00
	00		 jne	 $LN48@telnet_ev_

; 498  :         {
; 499  :             if (tn->do_tn3270)

  0088e	48 8b 44 24 70	 mov	 rax, QWORD PTR tn$[rsp]
  00893	0f b6 80 ac 00
	00 00		 movzx	 eax, BYTE PTR [rax+172]
  0089a	85 c0		 test	 eax, eax
  0089c	0f 84 89 00 00
	00		 je	 $LN49@telnet_ev_

; 500  :             {
; 501  :                 /* TN3270 mode requires it! */
; 502  :                 // "%s COMM: client refused to %s %s"
; 503  :                 WRMSG( HHC02902, "W", tn->clientid, "enable", "EOR mode" );

  008a2	48 8b 44 24 70	 mov	 rax, QWORD PTR tn$[rsp]
  008a7	48 83 c0 62	 add	 rax, 98			; 00000062H
  008ab	48 89 84 24 d8
	00 00 00	 mov	 QWORD PTR tv385[rsp], rax
  008b3	b9 01 00 00 00	 mov	 ecx, 1
  008b8	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  008be	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG177770
  008c5	48 89 4c 24 48	 mov	 QWORD PTR [rsp+72], rcx
  008ca	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG177771
  008d1	48 89 4c 24 40	 mov	 QWORD PTR [rsp+64], rcx
  008d6	48 8b 8c 24 d8
	00 00 00	 mov	 rcx, QWORD PTR tv385[rsp]
  008de	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  008e3	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG177772
  008ea	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  008ef	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG177773
  008f6	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  008fb	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00900	41 b9 03 00 00
	00		 mov	 r9d, 3
  00906	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG177774
  0090d	ba f7 01 00 00	 mov	 edx, 503		; 000001f7H
  00912	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG177775
  00919	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 504  :                 tn->neg_fail = TRUE;

  0091f	48 8b 44 24 70	 mov	 rax, QWORD PTR tn$[rsp]
  00924	c6 80 b3 00 00
	00 01		 mov	 BYTE PTR [rax+179], 1
$LN49@telnet_ev_:
$LN48@telnet_ev_:
$LN47@telnet_ev_:
$LN45@telnet_ev_:
$LN42@telnet_ev_:

; 505  :             }
; 506  :         }
; 507  :         break;

  0092b	e9 55 05 00 00	 jmp	 $LN2@telnet_ev_
$LN50@telnet_ev_:

; 508  : 
; 509  : 
; 510  :     /* TTYPE command has been received */
; 511  :     case TELNET_EV_TTYPE:
; 512  : 
; 513  :         if (ev->ttype.cmd == TELNET_TTYPE_IS)

  00930	48 8b 84 24 48
	01 00 00	 mov	 rax, QWORD PTR ev$[rsp]
  00938	0f b6 40 04	 movzx	 eax, BYTE PTR [rax+4]
  0093c	85 c0		 test	 eax, eax
  0093e	75 30		 jne	 SHORT $LN51@telnet_ev_

; 514  :         {
; 515  :             /* Save terminal type */
; 516  :             STRLCPY( tn->ttype, ev->ttype.name );

  00940	48 8b 44 24 70	 mov	 rax, QWORD PTR tn$[rsp]
  00945	48 83 c0 29	 add	 rax, 41			; 00000029H
  00949	41 b8 29 00 00
	00		 mov	 r8d, 41			; 00000029H
  0094f	48 8b 8c 24 48
	01 00 00	 mov	 rcx, QWORD PTR ev$[rsp]
  00957	48 8b 51 08	 mov	 rdx, QWORD PTR [rcx+8]
  0095b	48 8b c8	 mov	 rcx, rax
  0095e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_strlcpy

; 517  : 
; 518  :             /* Finish negotiations based on terminal type */
; 519  :             negotiate_ttype( tn );

  00964	48 8b 4c 24 70	 mov	 rcx, QWORD PTR tn$[rsp]
  00969	e8 00 00 00 00	 call	 negotiate_ttype

; 520  :         }

  0096e	eb 25		 jmp	 SHORT $LN52@telnet_ev_
$LN51@telnet_ev_:

; 521  : 
; 522  :         /* Respond with NULL Terminal Type when asked to send it */
; 523  :         else if (ev->ttype.cmd == TELNET_TTYPE_SEND)

  00970	48 8b 84 24 48
	01 00 00	 mov	 rax, QWORD PTR ev$[rsp]
  00978	0f b6 40 04	 movzx	 eax, BYTE PTR [rax+4]
  0097c	83 f8 01	 cmp	 eax, 1
  0097f	75 14		 jne	 SHORT $LN53@telnet_ev_

; 524  :         {
; 525  :             static const char* ttype = "";
; 526  :             telnet_ttype_is( telnet, ttype );

  00981	48 8b 15 00 00
	00 00		 mov	 rdx, QWORD PTR ?ttype@?BP@??telnet_ev_handler@@9@9
  00988	48 8b 8c 24 40
	01 00 00	 mov	 rcx, QWORD PTR telnet$[rsp]
  00990	e8 00 00 00 00	 call	 telnet_ttype_is
$LN53@telnet_ev_:
$LN52@telnet_ev_:

; 527  :         }
; 528  :         break;

  00995	e9 eb 04 00 00	 jmp	 $LN2@telnet_ev_
$LN54@telnet_ev_:

; 529  : 
; 530  : 
; 531  :     /* Respond to particular subnegotiations */
; 532  :     case TELNET_EV_SUBNEGOTIATION:
; 533  :         break;

  0099a	e9 e6 04 00 00	 jmp	 $LN2@telnet_ev_
$LN55@telnet_ev_:

; 534  : 
; 535  : 
; 536  :     /* Generic IAC command received */
; 537  :     case TELNET_EV_IAC:
; 538  : 
; 539  : #ifdef  TN_DEBUG_SIMPLE_IAC
; 540  : #ifndef TN_DEBUG_NOP_IAC
; 541  :         if (ev->iac.cmd != TELNET_NOP)
; 542  : #endif
; 543  :         // "%s COMM: received IAC %s"
; 544  :         WRMSG( HHC90512, "D", tn->clientid, telnet_cmd_name( ev->iac.cmd ));
; 545  : #endif
; 546  : 
; 547  :         /* End of record */
; 548  :         if (ev->iac.cmd == TELNET_EOR)

  0099f	48 8b 84 24 48
	01 00 00	 mov	 rax, QWORD PTR ev$[rsp]
  009a7	0f b6 40 04	 movzx	 eax, BYTE PTR [rax+4]
  009ab	3d ef 00 00 00	 cmp	 eax, 239		; 000000efH
  009b0	75 21		 jne	 SHORT $LN56@telnet_ev_

; 549  :         {
; 550  :             if (tn->do_eor)

  009b2	48 8b 44 24 70	 mov	 rax, QWORD PTR tn$[rsp]
  009b7	0f b6 80 ae 00
	00 00		 movzx	 eax, BYTE PTR [rax+174]
  009be	85 c0		 test	 eax, eax
  009c0	74 0c		 je	 SHORT $LN58@telnet_ev_

; 551  :                 tn->got_eor = TRUE;

  009c2	48 8b 44 24 70	 mov	 rax, QWORD PTR tn$[rsp]
  009c7	c6 80 af 00 00
	00 01		 mov	 BYTE PTR [rax+175], 1
$LN58@telnet_ev_:

; 552  :         }

  009ce	e9 1f 01 00 00	 jmp	 $LN57@telnet_ev_
$LN56@telnet_ev_:

; 553  : 
; 554  :         /* Break */
; 555  :         else if (ev->iac.cmd == TELNET_BREAK)

  009d3	48 8b 84 24 48
	01 00 00	 mov	 rax, QWORD PTR ev$[rsp]
  009db	0f b6 40 04	 movzx	 eax, BYTE PTR [rax+4]
  009df	3d f3 00 00 00	 cmp	 eax, 243		; 000000f3H
  009e4	75 21		 jne	 SHORT $LN59@telnet_ev_

; 556  :         {
; 557  :             if (!tn->do_tn3270)

  009e6	48 8b 44 24 70	 mov	 rax, QWORD PTR tn$[rsp]
  009eb	0f b6 80 ac 00
	00 00		 movzx	 eax, BYTE PTR [rax+172]
  009f2	85 c0		 test	 eax, eax
  009f4	75 0c		 jne	 SHORT $LN61@telnet_ev_

; 558  :                 tn->got_break = TRUE;

  009f6	48 8b 44 24 70	 mov	 rax, QWORD PTR tn$[rsp]
  009fb	c6 80 b0 00 00
	00 01		 mov	 BYTE PTR [rax+176], 1
$LN61@telnet_ev_:

; 559  :         }

  00a02	e9 eb 00 00 00	 jmp	 $LN60@telnet_ev_
$LN59@telnet_ev_:

; 560  : 
; 561  :         /* Interrupt Process */
; 562  :         else if (ev->iac.cmd == TELNET_IP)

  00a07	48 8b 84 24 48
	01 00 00	 mov	 rax, QWORD PTR ev$[rsp]
  00a0f	0f b6 40 04	 movzx	 eax, BYTE PTR [rax+4]
  00a13	3d f4 00 00 00	 cmp	 eax, 244		; 000000f4H
  00a18	75 21		 jne	 SHORT $LN62@telnet_ev_

; 563  :         {
; 564  :             if (!tn->do_tn3270)

  00a1a	48 8b 44 24 70	 mov	 rax, QWORD PTR tn$[rsp]
  00a1f	0f b6 80 ac 00
	00 00		 movzx	 eax, BYTE PTR [rax+172]
  00a26	85 c0		 test	 eax, eax
  00a28	75 0c		 jne	 SHORT $LN64@telnet_ev_

; 565  :                 tn->got_break = TRUE;

  00a2a	48 8b 44 24 70	 mov	 rax, QWORD PTR tn$[rsp]
  00a2f	c6 80 b0 00 00
	00 01		 mov	 BYTE PTR [rax+176], 1
$LN64@telnet_ev_:

; 566  :         }

  00a36	e9 b7 00 00 00	 jmp	 $LN63@telnet_ev_
$LN62@telnet_ev_:

; 567  : 
; 568  :         /* Erase character */
; 569  :         else if (ev->iac.cmd == TELNET_EC)

  00a3b	48 8b 84 24 48
	01 00 00	 mov	 rax, QWORD PTR ev$[rsp]
  00a43	0f b6 40 04	 movzx	 eax, BYTE PTR [rax+4]
  00a47	3d f7 00 00 00	 cmp	 eax, 247		; 000000f7H
  00a4c	75 5c		 jne	 SHORT $LN65@telnet_ev_

; 570  :         {
; 571  :             if (!tn->do_tn3270)

  00a4e	48 8b 44 24 70	 mov	 rax, QWORD PTR tn$[rsp]
  00a53	0f b6 80 ac 00
	00 00		 movzx	 eax, BYTE PTR [rax+172]
  00a5a	85 c0		 test	 eax, eax
  00a5c	75 4a		 jne	 SHORT $LN67@telnet_ev_

; 572  :             {
; 573  :                 if (tn->dev && tn->dev->keybdrem > 0)

  00a5e	48 8b 44 24 70	 mov	 rax, QWORD PTR tn$[rsp]
  00a63	48 83 b8 a0 00
	00 00 00	 cmp	 QWORD PTR [rax+160], 0
  00a6b	74 3b		 je	 SHORT $LN68@telnet_ev_
  00a6d	48 8b 44 24 70	 mov	 rax, QWORD PTR tn$[rsp]
  00a72	48 8b 80 a0 00
	00 00		 mov	 rax, QWORD PTR [rax+160]
  00a79	83 b8 c0 06 00
	00 00		 cmp	 DWORD PTR [rax+1728], 0
  00a80	7e 26		 jle	 SHORT $LN68@telnet_ev_

; 574  :                     tn->dev->keybdrem--;

  00a82	48 8b 44 24 70	 mov	 rax, QWORD PTR tn$[rsp]
  00a87	48 8b 80 a0 00
	00 00		 mov	 rax, QWORD PTR [rax+160]
  00a8e	8b 80 c0 06 00
	00		 mov	 eax, DWORD PTR [rax+1728]
  00a94	ff c8		 dec	 eax
  00a96	48 8b 4c 24 70	 mov	 rcx, QWORD PTR tn$[rsp]
  00a9b	48 8b 89 a0 00
	00 00		 mov	 rcx, QWORD PTR [rcx+160]
  00aa2	89 81 c0 06 00
	00		 mov	 DWORD PTR [rcx+1728], eax
$LN68@telnet_ev_:
$LN67@telnet_ev_:

; 575  :             }
; 576  :         }

  00aa8	eb 48		 jmp	 SHORT $LN66@telnet_ev_
$LN65@telnet_ev_:

; 577  : 
; 578  :         /* Erase line */
; 579  :         else if (ev->iac.cmd == TELNET_EL)

  00aaa	48 8b 84 24 48
	01 00 00	 mov	 rax, QWORD PTR ev$[rsp]
  00ab2	0f b6 40 04	 movzx	 eax, BYTE PTR [rax+4]
  00ab6	3d f8 00 00 00	 cmp	 eax, 248		; 000000f8H
  00abb	75 35		 jne	 SHORT $LN69@telnet_ev_

; 580  :         {
; 581  :             if (!tn->do_tn3270)

  00abd	48 8b 44 24 70	 mov	 rax, QWORD PTR tn$[rsp]
  00ac2	0f b6 80 ac 00
	00 00		 movzx	 eax, BYTE PTR [rax+172]
  00ac9	85 c0		 test	 eax, eax
  00acb	75 25		 jne	 SHORT $LN70@telnet_ev_

; 582  :             {
; 583  :                 if (tn->dev)

  00acd	48 8b 44 24 70	 mov	 rax, QWORD PTR tn$[rsp]
  00ad2	48 83 b8 a0 00
	00 00 00	 cmp	 QWORD PTR [rax+160], 0
  00ada	74 16		 je	 SHORT $LN71@telnet_ev_

; 584  :                     tn->dev->keybdrem = 0;

  00adc	48 8b 44 24 70	 mov	 rax, QWORD PTR tn$[rsp]
  00ae1	48 8b 80 a0 00
	00 00		 mov	 rax, QWORD PTR [rax+160]
  00ae8	c7 80 c0 06 00
	00 00 00 00 00	 mov	 DWORD PTR [rax+1728], 0
$LN71@telnet_ev_:
$LN70@telnet_ev_:
$LN69@telnet_ev_:
$LN66@telnet_ev_:
$LN63@telnet_ev_:
$LN60@telnet_ev_:
$LN57@telnet_ev_:

; 585  :             }
; 586  :         }
; 587  :         break;

  00af2	e9 8e 03 00 00	 jmp	 $LN2@telnet_ev_
$LN72@telnet_ev_:

; 588  : 
; 589  : 
; 590  :     /* Recoverable error has occured */
; 591  :     case TELNET_EV_WARNING:
; 592  : 
; 593  :         LOG_WARNING_OR_ERROR_EVENT( "WARNING", tn, ev );

  00af7	48 8b 84 24 48
	01 00 00	 mov	 rax, QWORD PTR ev$[rsp]
  00aff	8b 48 24	 mov	 ecx, DWORD PTR [rax+36]
  00b02	e8 00 00 00 00	 call	 telnet_err_name
  00b07	48 89 84 24 e0
	00 00 00	 mov	 QWORD PTR tv468[rsp], rax
  00b0f	48 8b 4c 24 70	 mov	 rcx, QWORD PTR tn$[rsp]
  00b14	48 83 c1 62	 add	 rcx, 98			; 00000062H
  00b18	48 89 8c 24 e8
	00 00 00	 mov	 QWORD PTR tv473[rsp], rcx
  00b20	b9 01 00 00 00	 mov	 ecx, 1
  00b25	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  00b2b	48 8b 8c 24 48
	01 00 00	 mov	 rcx, QWORD PTR ev$[rsp]
  00b33	48 8b 49 18	 mov	 rcx, QWORD PTR [rcx+24]
  00b37	48 89 4c 24 68	 mov	 QWORD PTR [rsp+104], rcx
  00b3c	48 8b 8c 24 48
	01 00 00	 mov	 rcx, QWORD PTR ev$[rsp]
  00b44	8b 49 20	 mov	 ecx, DWORD PTR [rcx+32]
  00b47	89 4c 24 60	 mov	 DWORD PTR [rsp+96], ecx
  00b4b	48 8b 8c 24 48
	01 00 00	 mov	 rcx, QWORD PTR ev$[rsp]
  00b53	48 8b 49 08	 mov	 rcx, QWORD PTR [rcx+8]
  00b57	48 89 4c 24 58	 mov	 QWORD PTR [rsp+88], rcx
  00b5c	48 8b 8c 24 48
	01 00 00	 mov	 rcx, QWORD PTR ev$[rsp]
  00b64	48 8b 49 10	 mov	 rcx, QWORD PTR [rcx+16]
  00b68	48 89 4c 24 50	 mov	 QWORD PTR [rsp+80], rcx
  00b6d	48 8b 8c 24 e0
	00 00 00	 mov	 rcx, QWORD PTR tv468[rsp]
  00b75	48 89 4c 24 48	 mov	 QWORD PTR [rsp+72], rcx
  00b7a	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG177800
  00b81	48 89 4c 24 40	 mov	 QWORD PTR [rsp+64], rcx
  00b86	48 8b 8c 24 e8
	00 00 00	 mov	 rcx, QWORD PTR tv473[rsp]
  00b8e	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  00b93	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG177801
  00b9a	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  00b9f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG177802
  00ba6	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00bab	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00bb0	41 b9 03 00 00
	00		 mov	 r9d, 3
  00bb6	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG177803
  00bbd	ba 51 02 00 00	 mov	 edx, 593		; 00000251H
  00bc2	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG177804
  00bc9	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 594  : 
; 595  :         /* Remember negotiation errors */
; 596  :         if (ev->error.err == TELNET_ENEGOTIATION)

  00bcf	48 8b 84 24 48
	01 00 00	 mov	 rax, QWORD PTR ev$[rsp]
  00bd7	83 78 24 04	 cmp	 DWORD PTR [rax+36], 4
  00bdb	75 73		 jne	 SHORT $LN73@telnet_ev_

; 597  :         {
; 598  :             // "%s COMM: libtelnet negotiation error"
; 599  :             WRMSG( HHC02905, "W", tn->clientid );

  00bdd	48 8b 44 24 70	 mov	 rax, QWORD PTR tn$[rsp]
  00be2	48 83 c0 62	 add	 rax, 98			; 00000062H
  00be6	48 89 84 24 f0
	00 00 00	 mov	 QWORD PTR tv486[rsp], rax
  00bee	b9 01 00 00 00	 mov	 ecx, 1
  00bf3	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  00bf9	48 8b 8c 24 f0
	00 00 00	 mov	 rcx, QWORD PTR tv486[rsp]
  00c01	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  00c06	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG177807
  00c0d	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  00c12	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG177808
  00c19	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00c1e	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00c23	41 b9 03 00 00
	00		 mov	 r9d, 3
  00c29	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG177809
  00c30	ba 57 02 00 00	 mov	 edx, 599		; 00000257H
  00c35	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG177810
  00c3c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 600  :             tn->neg_fail = TRUE;

  00c42	48 8b 44 24 70	 mov	 rax, QWORD PTR tn$[rsp]
  00c47	c6 80 b3 00 00
	00 01		 mov	 BYTE PTR [rax+179], 1

; 601  :         }

  00c4e	eb 65		 jmp	 SHORT $LN74@telnet_ev_
$LN73@telnet_ev_:

; 602  :         else
; 603  :             // "%s COMM: libtelnet error"
; 604  :             WRMSG( HHC02903, "W", tn->clientid );

  00c50	48 8b 44 24 70	 mov	 rax, QWORD PTR tn$[rsp]
  00c55	48 83 c0 62	 add	 rax, 98			; 00000062H
  00c59	48 89 84 24 f8
	00 00 00	 mov	 QWORD PTR tv498[rsp], rax
  00c61	b9 01 00 00 00	 mov	 ecx, 1
  00c66	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  00c6c	48 8b 8c 24 f8
	00 00 00	 mov	 rcx, QWORD PTR tv498[rsp]
  00c74	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  00c79	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG177811
  00c80	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  00c85	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG177812
  00c8c	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00c91	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00c96	41 b9 03 00 00
	00		 mov	 r9d, 3
  00c9c	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG177813
  00ca3	ba 5c 02 00 00	 mov	 edx, 604		; 0000025cH
  00ca8	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG177814
  00caf	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg
$LN74@telnet_ev_:

; 605  : 
; 606  :         break;

  00cb5	e9 cb 01 00 00	 jmp	 $LN2@telnet_ev_
$LN75@telnet_ev_:

; 607  : 
; 608  : 
; 609  :     /* Non-recoverable error has occured */
; 610  :     case TELNET_EV_ERROR:
; 611  : 
; 612  :         LOG_WARNING_OR_ERROR_EVENT( "ERROR", tn, ev );

  00cba	48 8b 84 24 48
	01 00 00	 mov	 rax, QWORD PTR ev$[rsp]
  00cc2	8b 48 24	 mov	 ecx, DWORD PTR [rax+36]
  00cc5	e8 00 00 00 00	 call	 telnet_err_name
  00cca	48 89 84 24 00
	01 00 00	 mov	 QWORD PTR tv549[rsp], rax
  00cd2	48 8b 4c 24 70	 mov	 rcx, QWORD PTR tn$[rsp]
  00cd7	48 83 c1 62	 add	 rcx, 98			; 00000062H
  00cdb	48 89 8c 24 08
	01 00 00	 mov	 QWORD PTR tv554[rsp], rcx
  00ce3	b9 01 00 00 00	 mov	 ecx, 1
  00ce8	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  00cee	48 8b 8c 24 48
	01 00 00	 mov	 rcx, QWORD PTR ev$[rsp]
  00cf6	48 8b 49 18	 mov	 rcx, QWORD PTR [rcx+24]
  00cfa	48 89 4c 24 68	 mov	 QWORD PTR [rsp+104], rcx
  00cff	48 8b 8c 24 48
	01 00 00	 mov	 rcx, QWORD PTR ev$[rsp]
  00d07	8b 49 20	 mov	 ecx, DWORD PTR [rcx+32]
  00d0a	89 4c 24 60	 mov	 DWORD PTR [rsp+96], ecx
  00d0e	48 8b 8c 24 48
	01 00 00	 mov	 rcx, QWORD PTR ev$[rsp]
  00d16	48 8b 49 08	 mov	 rcx, QWORD PTR [rcx+8]
  00d1a	48 89 4c 24 58	 mov	 QWORD PTR [rsp+88], rcx
  00d1f	48 8b 8c 24 48
	01 00 00	 mov	 rcx, QWORD PTR ev$[rsp]
  00d27	48 8b 49 10	 mov	 rcx, QWORD PTR [rcx+16]
  00d2b	48 89 4c 24 50	 mov	 QWORD PTR [rsp+80], rcx
  00d30	48 8b 8c 24 00
	01 00 00	 mov	 rcx, QWORD PTR tv549[rsp]
  00d38	48 89 4c 24 48	 mov	 QWORD PTR [rsp+72], rcx
  00d3d	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG177816
  00d44	48 89 4c 24 40	 mov	 QWORD PTR [rsp+64], rcx
  00d49	48 8b 8c 24 08
	01 00 00	 mov	 rcx, QWORD PTR tv554[rsp]
  00d51	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  00d56	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG177817
  00d5d	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  00d62	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG177818
  00d69	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00d6e	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00d73	41 b9 03 00 00
	00		 mov	 r9d, 3
  00d79	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG177819
  00d80	ba 64 02 00 00	 mov	 edx, 612		; 00000264H
  00d85	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG177820
  00d8c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 613  : 
; 614  :         // "%s COMM: libtelnet FATAL error"
; 615  :         WRMSG( HHC02904, "E", tn->clientid );

  00d92	48 8b 44 24 70	 mov	 rax, QWORD PTR tn$[rsp]
  00d97	48 83 c0 62	 add	 rax, 98			; 00000062H
  00d9b	48 89 84 24 10
	01 00 00	 mov	 QWORD PTR tv565[rsp], rax
  00da3	b9 01 00 00 00	 mov	 ecx, 1
  00da8	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  00dae	48 8b 8c 24 10
	01 00 00	 mov	 rcx, QWORD PTR tv565[rsp]
  00db6	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  00dbb	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG177821
  00dc2	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  00dc7	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG177822
  00dce	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00dd3	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00dd8	41 b9 03 00 00
	00		 mov	 r9d, 3
  00dde	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG177823
  00de5	ba 67 02 00 00	 mov	 edx, 615		; 00000267H
  00dea	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG177824
  00df1	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 616  :         break;

  00df7	e9 89 00 00 00	 jmp	 $LN2@telnet_ev_
$LN76@telnet_ev_:

; 617  : 
; 618  : 
; 619  :     default:
; 620  : 
; 621  :         // "%s COMM: Unsupported libtelnet event '%s'"
; 622  :         WRMSG( HHC02906, "W", tn->clientid, telnet_evt_name( ev->type ));

  00dfc	48 8b 84 24 48
	01 00 00	 mov	 rax, QWORD PTR ev$[rsp]
  00e04	8b 08		 mov	 ecx, DWORD PTR [rax]
  00e06	e8 00 00 00 00	 call	 telnet_evt_name
  00e0b	48 89 84 24 18
	01 00 00	 mov	 QWORD PTR tv576[rsp], rax
  00e13	48 8b 4c 24 70	 mov	 rcx, QWORD PTR tn$[rsp]
  00e18	48 83 c1 62	 add	 rcx, 98			; 00000062H
  00e1c	48 89 8c 24 20
	01 00 00	 mov	 QWORD PTR tv580[rsp], rcx
  00e24	b9 01 00 00 00	 mov	 ecx, 1
  00e29	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  00e2f	48 8b 8c 24 18
	01 00 00	 mov	 rcx, QWORD PTR tv576[rsp]
  00e37	48 89 4c 24 40	 mov	 QWORD PTR [rsp+64], rcx
  00e3c	48 8b 8c 24 20
	01 00 00	 mov	 rcx, QWORD PTR tv580[rsp]
  00e44	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  00e49	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG177826
  00e50	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  00e55	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG177827
  00e5c	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00e61	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00e66	41 b9 03 00 00
	00		 mov	 r9d, 3
  00e6c	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG177828
  00e73	ba 6e 02 00 00	 mov	 edx, 622		; 0000026eH
  00e78	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG177829
  00e7f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg
$LN2@telnet_ev_:

; 623  :         break;
; 624  :     }
; 625  : 
; 626  : } /* end function telnet_ev_handler */

  00e85	48 81 c4 38 01
	00 00		 add	 rsp, 312		; 00000138H
  00e8c	c3		 ret	 0
  00e8d	0f 1f 00	 npad	 3
$LN78@telnet_ev_:
  00e90	00 00 00 00	 DD	 $LN6@telnet_ev_
  00e94	00 00 00 00	 DD	 $LN4@telnet_ev_
  00e98	00 00 00 00	 DD	 $LN55@telnet_ev_
  00e9c	00 00 00 00	 DD	 $LN32@telnet_ev_
  00ea0	00 00 00 00	 DD	 $LN40@telnet_ev_
  00ea4	00 00 00 00	 DD	 $LN9@telnet_ev_
  00ea8	00 00 00 00	 DD	 $LN18@telnet_ev_
  00eac	00 00 00 00	 DD	 $LN54@telnet_ev_
  00eb0	00 00 00 00	 DD	 $LN50@telnet_ev_
  00eb4	00 00 00 00	 DD	 $LN76@telnet_ev_
  00eb8	00 00 00 00	 DD	 $LN72@telnet_ev_
  00ebc	00 00 00 00	 DD	 $LN75@telnet_ev_
telnet_ev_handler ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\console.c
_TEXT	SEGMENT
c$1 = 80
devnum$2 = 84
suffix$ = 88
tv168 = 96
tv179 = 104
tv191 = 112
tv193 = 120
tn$ = 144
negotiate_ttype PROC

; 2331 : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 81 ec 88 00
	00 00		 sub	 rsp, 136		; 00000088H

; 2332 :     char* suffix;
; 2333 : 
; 2334 :     /* Check terminal type for optional device-number/group suffix */
; 2335 :     tn->devnum = 0xFFFF;

  0000c	b8 ff ff 00 00	 mov	 eax, 65535		; 0000ffffH
  00011	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR tn$[rsp]
  00019	66 89 81 a8 00
	00 00		 mov	 WORD PTR [rcx+168], ax

; 2336 :     if ((suffix = strchr( tn->ttype, '@' )) != NULL)

  00020	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR tn$[rsp]
  00028	48 83 c0 29	 add	 rax, 41			; 00000029H
  0002c	ba 40 00 00 00	 mov	 edx, 64			; 00000040H
  00031	48 8b c8	 mov	 rcx, rax
  00034	e8 00 00 00 00	 call	 strchr
  00039	48 89 44 24 58	 mov	 QWORD PTR suffix$[rsp], rax
  0003e	48 83 7c 24 58
	00		 cmp	 QWORD PTR suffix$[rsp], 0
  00044	74 7b		 je	 SHORT $LN2@negotiate_

; 2337 :     {
; 2338 :         U16   devnum;
; 2339 :         char  c;
; 2340 : 
; 2341 :         *suffix++ = 0;  // (suffix is not part of terminal type)

  00046	48 8b 44 24 58	 mov	 rax, QWORD PTR suffix$[rsp]
  0004b	c6 00 00	 mov	 BYTE PTR [rax], 0
  0004e	48 8b 44 24 58	 mov	 rax, QWORD PTR suffix$[rsp]
  00053	48 ff c0	 inc	 rax
  00056	48 89 44 24 58	 mov	 QWORD PTR suffix$[rsp], rax

; 2342 : 
; 2343 :         if (sscanf( suffix, "%hx%c", &devnum, &c ) == 1)

  0005b	4c 8d 4c 24 50	 lea	 r9, QWORD PTR c$1[rsp]
  00060	4c 8d 44 24 54	 lea	 r8, QWORD PTR devnum$2[rsp]
  00065	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG178759
  0006c	48 8b 4c 24 58	 mov	 rcx, QWORD PTR suffix$[rsp]
  00071	e8 00 00 00 00	 call	 sscanf
  00076	83 f8 01	 cmp	 eax, 1
  00079	75 16		 jne	 SHORT $LN3@negotiate_

; 2344 :             tn->devnum = devnum;

  0007b	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR tn$[rsp]
  00083	0f b7 4c 24 54	 movzx	 ecx, WORD PTR devnum$2[rsp]
  00088	66 89 88 a8 00
	00 00		 mov	 WORD PTR [rax+168], cx
  0008f	eb 30		 jmp	 SHORT $LN4@negotiate_
$LN3@negotiate_:

; 2345 :         else if (strlen( suffix ) < sizeof( tn->tgroup ))

  00091	48 8b 4c 24 58	 mov	 rcx, QWORD PTR suffix$[rsp]
  00096	e8 00 00 00 00	 call	 strlen
  0009b	48 83 f8 10	 cmp	 rax, 16
  0009f	73 20		 jae	 SHORT $LN5@negotiate_

; 2346 :             STRLCPY( tn->tgroup, suffix );

  000a1	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR tn$[rsp]
  000a9	48 83 c0 52	 add	 rax, 82			; 00000052H
  000ad	41 b8 10 00 00
	00		 mov	 r8d, 16
  000b3	48 8b 54 24 58	 mov	 rdx, QWORD PTR suffix$[rsp]
  000b8	48 8b c8	 mov	 rcx, rax
  000bb	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_strlcpy
$LN5@negotiate_:
$LN4@negotiate_:
$LN2@negotiate_:

; 2347 :     }
; 2348 : 
; 2349 :     /* Check for non-IBM terminal type (presumed TTY) */
; 2350 :     if (strncasecmp( tn->ttype, "IBM-", 4 ) != 0)

  000c1	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR tn$[rsp]
  000c9	48 83 c0 29	 add	 rax, 41			; 00000029H
  000cd	41 b8 04 00 00
	00		 mov	 r8d, 4
  000d3	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG178762
  000da	48 8b c8	 mov	 rcx, rax
  000dd	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__strnicmp
  000e3	85 c0		 test	 eax, eax
  000e5	74 55		 je	 SHORT $LN6@negotiate_

; 2351 :     {
; 2352 :         /* TTY: we don't care about BINARY or EOR mode. We can
; 2353 :            support it being either way (on or off) when their
; 2354 :            terminal type is a TTY, so don't bother asking them
; 2355 :            to disable or enable it. Whatever it's currently set
; 2356 :            to is fine with us.
; 2357 :         */
; 2358 :         tn->do_tn3270 = 0;

  000e7	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR tn$[rsp]
  000ef	c6 80 ac 00 00
	00 00		 mov	 BYTE PTR [rax+172], 0

; 2359 :         tn->devclass = 'K';

  000f6	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR tn$[rsp]
  000fe	c6 80 aa 00 00
	00 4b		 mov	 BYTE PTR [rax+170], 75	; 0000004bH

; 2360 : 
; 2361 :         /* Request the client to go into line-at-a-time mode by telling
; 2362 :            the client we won't be echoing characters back to it and that
; 2363 :            it should instead do all echoing itself.  This should cause
; 2364 :            it to stop sending us one character at a time and instead to
; 2365 :            only send us complete lines always ending with a <CR><LF>.
; 2366 : 
; 2367 :            This has the desired side effect of also enabling both local
; 2368 :            echoing and local EDITING on the client side as well.  That
; 2369 :            is to say, if the user presses the backspace key, the client
; 2370 :            should erase the previous character from both the screen and
; 2371 :            from its local internal buffer as well.  Then when the enter
; 2372 :            key is then pressed, the line it sends to us is sent already
; 2373 :            without those characters so Hercules needs to do nothing.
; 2374 :         */
; 2375 :         telnet_negotiate( tn->ctl, TELNET_WONT, TELNET_TELOPT_ECHO );

  00105	41 b0 01	 mov	 r8b, 1
  00108	b2 fc		 mov	 dl, 252			; 000000fcH
  0010a	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR tn$[rsp]
  00112	48 8b 88 98 00
	00 00		 mov	 rcx, QWORD PTR [rax+152]
  00119	e8 00 00 00 00	 call	 telnet_negotiate

; 2376 :         telnet_negotiate( tn->ctl, TELNET_DO,   TELNET_TELOPT_ECHO );

  0011e	41 b0 01	 mov	 r8b, 1
  00121	b2 fd		 mov	 dl, 253			; 000000fdH
  00123	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR tn$[rsp]
  0012b	48 8b 88 98 00
	00 00		 mov	 rcx, QWORD PTR [rax+152]
  00132	e8 00 00 00 00	 call	 telnet_negotiate

; 2377 :         return;

  00137	e9 d1 02 00 00	 jmp	 $LN1@negotiate_
$LN6@negotiate_:

; 2378 :     }
; 2379 : 
; 2380 :     /* TN3270 mode requires both BINARY mode and END-OF-RECORD mode */
; 2381 :     tn->do_tn3270 = 1;

  0013c	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR tn$[rsp]
  00144	c6 80 ac 00 00
	00 01		 mov	 BYTE PTR [rax+172], 1

; 2382 :     tn->do_bin    = 1;

  0014b	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR tn$[rsp]
  00153	c6 80 ad 00 00
	00 01		 mov	 BYTE PTR [rax+173], 1

; 2383 :     tn->do_eor    = 1;

  0015a	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR tn$[rsp]
  00162	c6 80 ae 00 00
	00 01		 mov	 BYTE PTR [rax+174], 1

; 2384 : 
; 2385 :     telnet_negotiate( tn->ctl, TELNET_WILL, TELNET_TELOPT_BINARY );

  00169	45 33 c0	 xor	 r8d, r8d
  0016c	b2 fb		 mov	 dl, 251			; 000000fbH
  0016e	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR tn$[rsp]
  00176	48 8b 88 98 00
	00 00		 mov	 rcx, QWORD PTR [rax+152]
  0017d	e8 00 00 00 00	 call	 telnet_negotiate

; 2386 :     telnet_negotiate( tn->ctl, TELNET_DO,   TELNET_TELOPT_BINARY );

  00182	45 33 c0	 xor	 r8d, r8d
  00185	b2 fd		 mov	 dl, 253			; 000000fdH
  00187	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR tn$[rsp]
  0018f	48 8b 88 98 00
	00 00		 mov	 rcx, QWORD PTR [rax+152]
  00196	e8 00 00 00 00	 call	 telnet_negotiate

; 2387 :     telnet_negotiate( tn->ctl, TELNET_WILL, TELNET_TELOPT_EOR );

  0019b	41 b0 19	 mov	 r8b, 25
  0019e	b2 fb		 mov	 dl, 251			; 000000fbH
  001a0	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR tn$[rsp]
  001a8	48 8b 88 98 00
	00 00		 mov	 rcx, QWORD PTR [rax+152]
  001af	e8 00 00 00 00	 call	 telnet_negotiate

; 2388 :     telnet_negotiate( tn->ctl, TELNET_DO,   TELNET_TELOPT_EOR );

  001b4	41 b0 19	 mov	 r8b, 25
  001b7	b2 fd		 mov	 dl, 253			; 000000fdH
  001b9	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR tn$[rsp]
  001c1	48 8b 88 98 00
	00 00		 mov	 rcx, QWORD PTR [rax+152]
  001c8	e8 00 00 00 00	 call	 telnet_negotiate

; 2389 : 
; 2390 :     /* No sense in going any further if TN3270 mode was refused */
; 2391 :     if (tn->neg_fail)

  001cd	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR tn$[rsp]
  001d5	0f b6 80 b3 00
	00 00		 movzx	 eax, BYTE PTR [rax+179]
  001dc	85 c0		 test	 eax, eax
  001de	74 05		 je	 SHORT $LN7@negotiate_

; 2392 :         return;

  001e0	e9 28 02 00 00	 jmp	 $LN1@negotiate_
$LN7@negotiate_:

; 2393 : 
; 2394 :     /* Printer? */
; 2395 :     if (strcasecmp( tn->ttype, "IBM-3287-1" ) == 0)

  001e5	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR tn$[rsp]
  001ed	48 83 c0 29	 add	 rax, 41			; 00000029H
  001f1	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG178765
  001f8	48 8b c8	 mov	 rcx, rax
  001fb	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__stricmp
  00201	85 c0		 test	 eax, eax
  00203	75 32		 jne	 SHORT $LN8@negotiate_

; 2396 :     {
; 2397 :         tn->devclass = 'P';

  00205	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR tn$[rsp]
  0020d	c6 80 aa 00 00
	00 50		 mov	 BYTE PTR [rax+170], 80	; 00000050H

; 2398 :         tn->model    = '5';     // (132 columns)

  00214	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR tn$[rsp]
  0021c	c6 80 ab 00 00
	00 35		 mov	 BYTE PTR [rax+171], 53	; 00000035H

; 2399 :         tn->extatr   = FALSE;

  00223	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR tn$[rsp]
  0022b	c6 80 b1 00 00
	00 00		 mov	 BYTE PTR [rax+177], 0

; 2400 :         return;

  00232	e9 d6 01 00 00	 jmp	 $LN1@negotiate_
$LN8@negotiate_:

; 2401 :     }
; 2402 : 
; 2403 :     /* Otherwise determine terminal type attributes from our table */
; 2404 :     if (lookup_ttype( tn->ttype, &tn->model, &tn->extatr ))

  00237	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR tn$[rsp]
  0023f	48 05 b1 00 00
	00		 add	 rax, 177		; 000000b1H
  00245	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR tn$[rsp]
  0024d	48 81 c1 ab 00
	00 00		 add	 rcx, 171		; 000000abH
  00254	48 8b 94 24 90
	00 00 00	 mov	 rdx, QWORD PTR tn$[rsp]
  0025c	48 83 c2 29	 add	 rdx, 41			; 00000029H
  00260	48 89 54 24 60	 mov	 QWORD PTR tv168[rsp], rdx
  00265	4c 8b c0	 mov	 r8, rax
  00268	48 8b d1	 mov	 rdx, rcx
  0026b	48 8b 44 24 60	 mov	 rax, QWORD PTR tv168[rsp]
  00270	48 8b c8	 mov	 rcx, rax
  00273	e8 00 00 00 00	 call	 lookup_ttype
  00278	0f b6 c0	 movzx	 eax, al
  0027b	85 c0		 test	 eax, eax
  0027d	74 14		 je	 SHORT $LN9@negotiate_

; 2405 :     {
; 2406 :         tn->devclass = 'D';

  0027f	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR tn$[rsp]
  00287	c6 80 aa 00 00
	00 44		 mov	 BYTE PTR [rax+170], 68	; 00000044H

; 2407 :         return;

  0028e	e9 7a 01 00 00	 jmp	 $LN1@negotiate_
$LN9@negotiate_:

; 2408 :     }
; 2409 : 
; 2410 :     /* The current terminal type wasn't in our table and is therefore
; 2411 :        unacceptable to us. Tell them to try again by sending us their
; 2412 :        NEXT terminal type in their list. If NONE of the types in their
; 2413 :        list are acceptable to us (detected by their wrapping around
; 2414 :        and sending us the first entry in their list again), then fail
; 2415 :        the terminal type negotiations.
; 2416 :     */
; 2417 :     if (str_caseless_eq( tn->ttype, tn->tt1st ))  /* Tried them all? */

  00293	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR tn$[rsp]
  0029b	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR tn$[rsp]
  002a3	48 83 c1 29	 add	 rcx, 41			; 00000029H
  002a7	48 8b d0	 mov	 rdx, rax
  002aa	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__stricmp
  002b0	85 c0		 test	 eax, eax
  002b2	75 76		 jne	 SHORT $LN10@negotiate_

; 2418 :     {
; 2419 :         // "%s COMM: No acceptable terminal types"
; 2420 :         WRMSG( HHC02916, "E", tn->clientid );

  002b4	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR tn$[rsp]
  002bc	48 83 c0 62	 add	 rax, 98			; 00000062H
  002c0	48 89 44 24 68	 mov	 QWORD PTR tv179[rsp], rax
  002c5	b9 01 00 00 00	 mov	 ecx, 1
  002ca	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  002d0	48 8b 4c 24 68	 mov	 rcx, QWORD PTR tv179[rsp]
  002d5	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  002da	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG178768
  002e1	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  002e6	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG178769
  002ed	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  002f2	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  002f7	41 b9 03 00 00
	00		 mov	 r9d, 3
  002fd	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG178770
  00304	ba 74 09 00 00	 mov	 edx, 2420		; 00000974H
  00309	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG178771
  00310	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 2421 :         tn->neg_fail = TRUE;

  00316	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR tn$[rsp]
  0031e	c6 80 b3 00 00
	00 01		 mov	 BYTE PTR [rax+179], 1

; 2422 :         return;

  00325	e9 e3 00 00 00	 jmp	 $LN1@negotiate_
$LN10@negotiate_:

; 2423 :     }
; 2424 : 
; 2425 :     // "%s COMM: unsupported terminal type: %s"
; 2426 :     WRMSG( HHC02910, "W", tn->clientid, tn->ttype );

  0032a	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR tn$[rsp]
  00332	48 83 c0 29	 add	 rax, 41			; 00000029H
  00336	48 89 44 24 70	 mov	 QWORD PTR tv191[rsp], rax
  0033b	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR tn$[rsp]
  00343	48 83 c1 62	 add	 rcx, 98			; 00000062H
  00347	48 89 4c 24 78	 mov	 QWORD PTR tv193[rsp], rcx
  0034c	b9 01 00 00 00	 mov	 ecx, 1
  00351	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  00357	48 8b 4c 24 70	 mov	 rcx, QWORD PTR tv191[rsp]
  0035c	48 89 4c 24 40	 mov	 QWORD PTR [rsp+64], rcx
  00361	48 8b 4c 24 78	 mov	 rcx, QWORD PTR tv193[rsp]
  00366	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  0036b	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG178772
  00372	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  00377	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG178773
  0037e	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00383	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00388	41 b9 03 00 00
	00		 mov	 r9d, 3
  0038e	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG178774
  00395	ba 7a 09 00 00	 mov	 edx, 2426		; 0000097aH
  0039a	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG178775
  003a1	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 2427 : 
; 2428 :     /* Save this terminal type if it's the first entry in their list */
; 2429 :     if (!tn->tt1st[0])

  003a7	b8 01 00 00 00	 mov	 eax, 1
  003ac	48 6b c0 00	 imul	 rax, rax, 0
  003b0	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR tn$[rsp]
  003b8	0f be 04 01	 movsx	 eax, BYTE PTR [rcx+rax]
  003bc	85 c0		 test	 eax, eax
  003be	75 23		 jne	 SHORT $LN11@negotiate_

; 2430 :         STRLCPY( tn->tt1st, tn->ttype );

  003c0	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR tn$[rsp]
  003c8	48 83 c0 29	 add	 rax, 41			; 00000029H
  003cc	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR tn$[rsp]
  003d4	41 b8 29 00 00
	00		 mov	 r8d, 41			; 00000029H
  003da	48 8b d0	 mov	 rdx, rax
  003dd	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_strlcpy
$LN11@negotiate_:

; 2431 : 
; 2432 :     /* Continue negotiating... */
; 2433 :     tn->ttype[0] = 0; // (prevent premature 'connect_client' loop exit)

  003e3	b8 01 00 00 00	 mov	 eax, 1
  003e8	48 6b c0 00	 imul	 rax, rax, 0
  003ec	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR tn$[rsp]
  003f4	c6 44 01 29 00	 mov	 BYTE PTR [rcx+rax+41], 0

; 2434 : 
; 2435 :     /* Tell them to send us the NEXT terminal type in their list... */
; 2436 :     telnet_ttype_send( tn->ctl );

  003f9	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR tn$[rsp]
  00401	48 8b 88 98 00
	00 00		 mov	 rcx, QWORD PTR [rax+152]
  00408	e8 00 00 00 00	 call	 telnet_ttype_send
$LN1@negotiate_:

; 2437 : 
; 2438 : } /* end function negotiate_ttype */

  0040d	48 81 c4 88 00
	00 00		 add	 rsp, 136		; 00000088H
  00414	c3		 ret	 0
negotiate_ttype ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\console.c
_TEXT	SEGMENT
dev$ = 64
i$ = 72
tv92 = 76
tv130 = 80
tv206 = 84
tv212 = 88
tv67 = 96
clientid$1 = 104
clientid$2 = 136
__$ArrayPad$ = 168
tn$ = 192
buffer$ = 200
size$ = 208
constty_input PROC

; 2485 : {

  00000	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	48 81 ec b8 00
	00 00		 sub	 rsp, 184		; 000000b8H
  00016	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  0001d	48 33 c4	 xor	 rax, rsp
  00020	48 89 84 24 a8
	00 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 2486 :     DEVBLK *dev;
; 2487 :     U32 i;
; 2488 : 
; 2489 :     /* Discard client data until negotiations are complete */
; 2490 :     if (!tn->neg_done)

  00028	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR tn$[rsp]
  00030	0f b6 80 b2 00
	00 00		 movzx	 eax, BYTE PTR [rax+178]
  00037	85 c0		 test	 eax, eax
  00039	75 67		 jne	 SHORT $LN5@constty_in

; 2491 :     {
; 2492 :         // "%s COMM: discarding premature data"
; 2493 :         WRMSG( HHC02911, "W", tn->clientid );

  0003b	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR tn$[rsp]
  00043	48 83 c0 62	 add	 rax, 98			; 00000062H
  00047	48 89 44 24 60	 mov	 QWORD PTR tv67[rsp], rax
  0004c	b9 01 00 00 00	 mov	 ecx, 1
  00051	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  00057	48 8b 4c 24 60	 mov	 rcx, QWORD PTR tv67[rsp]
  0005c	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  00061	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG178813
  00068	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  0006d	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG178814
  00074	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00079	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  0007e	41 b9 03 00 00
	00		 mov	 r9d, 3
  00084	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG178815
  0008b	ba bd 09 00 00	 mov	 edx, 2493		; 000009bdH
  00090	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG178816
  00097	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 2494 :         return;

  0009d	e9 80 03 00 00	 jmp	 $LN1@constty_in
$LN5@constty_in:

; 2495 :     }
; 2496 : 
; 2497 :     /* Initialize DEVBLK pointer */
; 2498 :     dev = tn->dev;

  000a2	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR tn$[rsp]
  000aa	48 8b 80 a0 00
	00 00		 mov	 rax, QWORD PTR [rax+160]
  000b1	48 89 44 24 40	 mov	 QWORD PTR dev$[rsp], rax

; 2499 : 
; 2500 :     /* Check for break indication (IAC BRK or IAC IP) */
; 2501 :     if (tn->got_break)

  000b6	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR tn$[rsp]
  000be	0f b6 80 b0 00
	00 00		 movzx	 eax, BYTE PTR [rax+176]
  000c5	85 c0		 test	 eax, eax
  000c7	74 14		 je	 SHORT $LN6@constty_in

; 2502 :     {
; 2503 :         dev->keybdrem = 0;

  000c9	48 8b 44 24 40	 mov	 rax, QWORD PTR dev$[rsp]
  000ce	c7 80 c0 06 00
	00 00 00 00 00	 mov	 DWORD PTR [rax+1728], 0

; 2504 :         return;

  000d8	e9 45 03 00 00	 jmp	 $LN1@constty_in
$LN6@constty_in:

; 2505 :     }
; 2506 : 
; 2507 :     /* Copy received bytes to keyboard buffer */
; 2508 :     for (i=0; i < size; i++)

  000dd	c7 44 24 48 00
	00 00 00	 mov	 DWORD PTR i$[rsp], 0
  000e5	eb 0a		 jmp	 SHORT $LN4@constty_in
$LN2@constty_in:
  000e7	8b 44 24 48	 mov	 eax, DWORD PTR i$[rsp]
  000eb	ff c0		 inc	 eax
  000ed	89 44 24 48	 mov	 DWORD PTR i$[rsp], eax
$LN4@constty_in:
  000f1	8b 84 24 d0 00
	00 00		 mov	 eax, DWORD PTR size$[rsp]
  000f8	39 44 24 48	 cmp	 DWORD PTR i$[rsp], eax
  000fc	0f 83 1d 02 00
	00		 jae	 $LN3@constty_in

; 2509 :     {
; 2510 :         /* Check for buffer overflow */
; 2511 :         if (dev->keybdrem >= dev->bufsize)

  00102	48 8b 44 24 40	 mov	 rax, QWORD PTR dev$[rsp]
  00107	48 8b 4c 24 40	 mov	 rcx, QWORD PTR dev$[rsp]
  0010c	8b 89 d8 01 00
	00		 mov	 ecx, DWORD PTR [rcx+472]
  00112	39 88 c0 06 00
	00		 cmp	 DWORD PTR [rax+1728], ecx
  00118	0f 8c d8 00 00
	00		 jl	 $LN7@constty_in

; 2512 :         {
; 2513 :             char clientid[32];
; 2514 :             MSGBUF( clientid, "%1d:%04X",

  0011e	48 83 7c 24 40
	00		 cmp	 QWORD PTR dev$[rsp], 0
  00124	74 0f		 je	 SHORT $LN12@constty_in
  00126	48 8b 44 24 40	 mov	 rax, QWORD PTR dev$[rsp]
  0012b	0f b7 40 48	 movzx	 eax, WORD PTR [rax+72]
  0012f	89 44 24 4c	 mov	 DWORD PTR tv92[rsp], eax
  00133	eb 08		 jmp	 SHORT $LN13@constty_in
$LN12@constty_in:
  00135	c7 44 24 4c 00
	00 00 00	 mov	 DWORD PTR tv92[rsp], 0
$LN13@constty_in:
  0013d	48 83 7c 24 40
	00		 cmp	 QWORD PTR dev$[rsp], 0
  00143	74 11		 je	 SHORT $LN14@constty_in
  00145	48 8b 44 24 40	 mov	 rax, QWORD PTR dev$[rsp]
  0014a	0f b7 40 44	 movzx	 eax, WORD PTR [rax+68]
  0014e	d1 f8		 sar	 eax, 1
  00150	89 44 24 50	 mov	 DWORD PTR tv130[rsp], eax
  00154	eb 08		 jmp	 SHORT $LN15@constty_in
$LN14@constty_in:
  00156	c7 44 24 50 00
	00 00 00	 mov	 DWORD PTR tv130[rsp], 0
$LN15@constty_in:
  0015e	8b 44 24 4c	 mov	 eax, DWORD PTR tv92[rsp]
  00162	89 44 24 20	 mov	 DWORD PTR [rsp+32], eax
  00166	44 8b 4c 24 50	 mov	 r9d, DWORD PTR tv130[rsp]
  0016b	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG178819
  00172	ba 20 00 00 00	 mov	 edx, 32			; 00000020H
  00177	48 8d 4c 24 68	 lea	 rcx, QWORD PTR clientid$1[rsp]
  0017c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_snprintf

; 2515 :                 LCSS_DEVNUM );
; 2516 :             // "%s COMM: buffer overflow"
; 2517 :             WRMSG( HHC02912, "E", clientid );

  00182	b9 01 00 00 00	 mov	 ecx, 1
  00187	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  0018d	48 8d 4c 24 68	 lea	 rcx, QWORD PTR clientid$1[rsp]
  00192	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  00197	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG178820
  0019e	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  001a3	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG178821
  001aa	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  001af	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  001b4	41 b9 03 00 00
	00		 mov	 r9d, 3
  001ba	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG178822
  001c1	ba d5 09 00 00	 mov	 edx, 2517		; 000009d5H
  001c6	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG178823
  001cd	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 2518 :             tn->overflow = TRUE;

  001d3	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR tn$[rsp]
  001db	c6 80 b5 00 00
	00 01		 mov	 BYTE PTR [rax+181], 1

; 2519 :             dev->keybdrem = 0;

  001e2	48 8b 44 24 40	 mov	 rax, QWORD PTR dev$[rsp]
  001e7	c7 80 c0 06 00
	00 00 00 00 00	 mov	 DWORD PTR [rax+1728], 0

; 2520 :             return;

  001f1	e9 2c 02 00 00	 jmp	 $LN1@constty_in
$LN7@constty_in:

; 2521 :         }
; 2522 : 
; 2523 :         /* Copy character to keyboard buffer */
; 2524 :         dev->buf[ dev->keybdrem++ ] = buffer[i];

  001f6	8b 44 24 48	 mov	 eax, DWORD PTR i$[rsp]
  001fa	48 8b 4c 24 40	 mov	 rcx, QWORD PTR dev$[rsp]
  001ff	48 63 89 c0 06
	00 00		 movsxd	 rcx, DWORD PTR [rcx+1728]
  00206	48 8b 54 24 40	 mov	 rdx, QWORD PTR dev$[rsp]
  0020b	48 8b 92 c8 01
	00 00		 mov	 rdx, QWORD PTR [rdx+456]
  00212	4c 8b 84 24 c8
	00 00 00	 mov	 r8, QWORD PTR buffer$[rsp]
  0021a	41 0f b6 04 00	 movzx	 eax, BYTE PTR [r8+rax]
  0021f	88 04 0a	 mov	 BYTE PTR [rdx+rcx], al
  00222	48 8b 44 24 40	 mov	 rax, QWORD PTR dev$[rsp]
  00227	8b 80 c0 06 00
	00		 mov	 eax, DWORD PTR [rax+1728]
  0022d	ff c0		 inc	 eax
  0022f	48 8b 4c 24 40	 mov	 rcx, QWORD PTR dev$[rsp]
  00234	89 81 c0 06 00
	00		 mov	 DWORD PTR [rcx+1728], eax

; 2525 : 
; 2526 :         /* Check for carriage return */
; 2527 :         if (1
; 2528 :             &&           dev->keybdrem >= 2
; 2529 :             && dev->buf[ dev->keybdrem  - 2 ] == '\r'
; 2530 :             && dev->buf[ dev->keybdrem  - 1 ] == '\0'

  0023a	33 c0		 xor	 eax, eax
  0023c	83 f8 01	 cmp	 eax, 1
  0023f	74 6a		 je	 SHORT $LN8@constty_in
  00241	48 8b 44 24 40	 mov	 rax, QWORD PTR dev$[rsp]
  00246	83 b8 c0 06 00
	00 02		 cmp	 DWORD PTR [rax+1728], 2
  0024d	7c 5c		 jl	 SHORT $LN8@constty_in
  0024f	48 8b 44 24 40	 mov	 rax, QWORD PTR dev$[rsp]
  00254	8b 80 c0 06 00
	00		 mov	 eax, DWORD PTR [rax+1728]
  0025a	83 e8 02	 sub	 eax, 2
  0025d	48 98		 cdqe
  0025f	48 8b 4c 24 40	 mov	 rcx, QWORD PTR dev$[rsp]
  00264	48 8b 89 c8 01
	00 00		 mov	 rcx, QWORD PTR [rcx+456]
  0026b	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  0026f	83 f8 0d	 cmp	 eax, 13
  00272	75 37		 jne	 SHORT $LN8@constty_in
  00274	48 8b 44 24 40	 mov	 rax, QWORD PTR dev$[rsp]
  00279	8b 80 c0 06 00
	00		 mov	 eax, DWORD PTR [rax+1728]
  0027f	ff c8		 dec	 eax
  00281	48 98		 cdqe
  00283	48 8b 4c 24 40	 mov	 rcx, QWORD PTR dev$[rsp]
  00288	48 8b 89 c8 01
	00 00		 mov	 rcx, QWORD PTR [rcx+456]
  0028f	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00293	85 c0		 test	 eax, eax
  00295	75 14		 jne	 SHORT $LN8@constty_in

; 2531 :         )
; 2532 :         {
; 2533 :             dev->keybdrem = 0;

  00297	48 8b 44 24 40	 mov	 rax, QWORD PTR dev$[rsp]
  0029c	c7 80 c0 06 00
	00 00 00 00 00	 mov	 DWORD PTR [rax+1728], 0

; 2534 :             continue;

  002a6	e9 3c fe ff ff	 jmp	 $LN2@constty_in
$LN8@constty_in:

; 2535 :         }
; 2536 : 
; 2537 :         /* Check for CRLF (end of record) */
; 2538 :         if (1
; 2539 :             &&           dev->keybdrem >= 2
; 2540 :             && dev->buf[ dev->keybdrem  - 2 ] == '\r'
; 2541 :             && dev->buf[ dev->keybdrem  - 1 ] == '\n'

  002ab	33 c0		 xor	 eax, eax
  002ad	83 f8 01	 cmp	 eax, 1
  002b0	74 68		 je	 SHORT $LN9@constty_in
  002b2	48 8b 44 24 40	 mov	 rax, QWORD PTR dev$[rsp]
  002b7	83 b8 c0 06 00
	00 02		 cmp	 DWORD PTR [rax+1728], 2
  002be	7c 5a		 jl	 SHORT $LN9@constty_in
  002c0	48 8b 44 24 40	 mov	 rax, QWORD PTR dev$[rsp]
  002c5	8b 80 c0 06 00
	00		 mov	 eax, DWORD PTR [rax+1728]
  002cb	83 e8 02	 sub	 eax, 2
  002ce	48 98		 cdqe
  002d0	48 8b 4c 24 40	 mov	 rcx, QWORD PTR dev$[rsp]
  002d5	48 8b 89 c8 01
	00 00		 mov	 rcx, QWORD PTR [rcx+456]
  002dc	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  002e0	83 f8 0d	 cmp	 eax, 13
  002e3	75 35		 jne	 SHORT $LN9@constty_in
  002e5	48 8b 44 24 40	 mov	 rax, QWORD PTR dev$[rsp]
  002ea	8b 80 c0 06 00
	00		 mov	 eax, DWORD PTR [rax+1728]
  002f0	ff c8		 dec	 eax
  002f2	48 98		 cdqe
  002f4	48 8b 4c 24 40	 mov	 rcx, QWORD PTR dev$[rsp]
  002f9	48 8b 89 c8 01
	00 00		 mov	 rcx, QWORD PTR [rcx+456]
  00300	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00304	83 f8 0a	 cmp	 eax, 10
  00307	75 11		 jne	 SHORT $LN9@constty_in

; 2542 :         )
; 2543 :         {
; 2544 :             tn->got_eor = TRUE;

  00309	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR tn$[rsp]
  00311	c6 80 af 00 00
	00 01		 mov	 BYTE PTR [rax+175], 1

; 2545 :             break;

  00318	eb 05		 jmp	 SHORT $LN3@constty_in
$LN9@constty_in:

; 2546 :         }
; 2547 : 
; 2548 :     } /* end for(i) */

  0031a	e9 c8 fd ff ff	 jmp	 $LN2@constty_in
$LN3@constty_in:

; 2549 : 
; 2550 :     /* Check for unexpected data following CRLF */
; 2551 :     if (tn->got_eor && i < (size - 1))

  0031f	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR tn$[rsp]
  00327	0f b6 80 af 00
	00 00		 movzx	 eax, BYTE PTR [rax+175]
  0032e	85 c0		 test	 eax, eax
  00330	0f 84 ec 00 00
	00		 je	 $LN10@constty_in
  00336	8b 84 24 d0 00
	00 00		 mov	 eax, DWORD PTR size$[rsp]
  0033d	ff c8		 dec	 eax
  0033f	39 44 24 48	 cmp	 DWORD PTR i$[rsp], eax
  00343	0f 83 d9 00 00
	00		 jae	 $LN10@constty_in

; 2552 :     {
; 2553 :         char clientid[32];
; 2554 :         MSGBUF( clientid, "%1d:%04X",

  00349	48 83 7c 24 40
	00		 cmp	 QWORD PTR dev$[rsp], 0
  0034f	74 0f		 je	 SHORT $LN16@constty_in
  00351	48 8b 44 24 40	 mov	 rax, QWORD PTR dev$[rsp]
  00356	0f b7 40 48	 movzx	 eax, WORD PTR [rax+72]
  0035a	89 44 24 54	 mov	 DWORD PTR tv206[rsp], eax
  0035e	eb 08		 jmp	 SHORT $LN17@constty_in
$LN16@constty_in:
  00360	c7 44 24 54 00
	00 00 00	 mov	 DWORD PTR tv206[rsp], 0
$LN17@constty_in:
  00368	48 83 7c 24 40
	00		 cmp	 QWORD PTR dev$[rsp], 0
  0036e	74 11		 je	 SHORT $LN18@constty_in
  00370	48 8b 44 24 40	 mov	 rax, QWORD PTR dev$[rsp]
  00375	0f b7 40 44	 movzx	 eax, WORD PTR [rax+68]
  00379	d1 f8		 sar	 eax, 1
  0037b	89 44 24 58	 mov	 DWORD PTR tv212[rsp], eax
  0037f	eb 08		 jmp	 SHORT $LN19@constty_in
$LN18@constty_in:
  00381	c7 44 24 58 00
	00 00 00	 mov	 DWORD PTR tv212[rsp], 0
$LN19@constty_in:
  00389	8b 44 24 54	 mov	 eax, DWORD PTR tv206[rsp]
  0038d	89 44 24 20	 mov	 DWORD PTR [rsp+32], eax
  00391	44 8b 4c 24 58	 mov	 r9d, DWORD PTR tv212[rsp]
  00396	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG178827
  0039d	ba 20 00 00 00	 mov	 edx, 32			; 00000020H
  003a2	48 8d 8c 24 88
	00 00 00	 lea	 rcx, QWORD PTR clientid$2[rsp]
  003aa	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_snprintf

; 2555 :             LCSS_DEVNUM );
; 2556 :         // "%s COMM: buffer overrun"
; 2557 :         WRMSG( HHC02913, "E", clientid );

  003b0	b9 01 00 00 00	 mov	 ecx, 1
  003b5	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  003bb	48 8d 8c 24 88
	00 00 00	 lea	 rcx, QWORD PTR clientid$2[rsp]
  003c3	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  003c8	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG178828
  003cf	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  003d4	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG178829
  003db	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  003e0	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  003e5	41 b9 03 00 00
	00		 mov	 r9d, 3
  003eb	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG178830
  003f2	ba fd 09 00 00	 mov	 edx, 2557		; 000009fdH
  003f7	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG178831
  003fe	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 2558 :         tn->overrun = TRUE;

  00404	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR tn$[rsp]
  0040c	c6 80 b6 00 00
	00 01		 mov	 BYTE PTR [rax+182], 1

; 2559 :         dev->keybdrem = 0;

  00413	48 8b 44 24 40	 mov	 rax, QWORD PTR dev$[rsp]
  00418	c7 80 c0 06 00
	00 00 00 00 00	 mov	 DWORD PTR [rax+1728], 0
$LN10@constty_in:
$LN1@constty_in:

; 2560 :     }
; 2561 : 
; 2562 : } /* end function constty_input */

  00422	48 8b 8c 24 a8
	00 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  0042a	48 33 cc	 xor	 rcx, rsp
  0042d	e8 00 00 00 00	 call	 __security_check_cookie
  00432	48 81 c4 b8 00
	00 00		 add	 rsp, 184		; 000000b8H
  00439	c3		 ret	 0
constty_input ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\console.c
_TEXT	SEGMENT
dev$ = 64
amt$ = 72
tv86 = 76
tv137 = 80
tv143 = 84
tv67 = 88
clientid$1 = 96
__$ArrayPad$ = 128
tn$ = 176
buffer$ = 184
size$ = 192
loc3270_input PROC

; 2444 : {

  00000	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	56		 push	 rsi
  00010	57		 push	 rdi
  00011	48 81 ec 98 00
	00 00		 sub	 rsp, 152		; 00000098H
  00018	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  0001f	48 33 c4	 xor	 rax, rsp
  00022	48 89 84 24 80
	00 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 2445 :     DEVBLK *dev;
; 2446 :     U32     amt;
; 2447 : 
; 2448 :     /* Discard client data until negotiations are complete */
; 2449 :     if (!tn->neg_done)

  0002a	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR tn$[rsp]
  00032	0f b6 80 b2 00
	00 00		 movzx	 eax, BYTE PTR [rax+178]
  00039	85 c0		 test	 eax, eax
  0003b	75 67		 jne	 SHORT $LN2@loc3270_in

; 2450 :     {
; 2451 :         // "%s COMM: discarding premature data"
; 2452 :         WRMSG( HHC02911, "W", tn->clientid );

  0003d	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR tn$[rsp]
  00045	48 83 c0 62	 add	 rax, 98			; 00000062H
  00049	48 89 44 24 58	 mov	 QWORD PTR tv67[rsp], rax
  0004e	b9 01 00 00 00	 mov	 ecx, 1
  00053	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  00059	48 8b 4c 24 58	 mov	 rcx, QWORD PTR tv67[rsp]
  0005e	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  00063	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG178788
  0006a	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  0006f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG178789
  00076	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  0007b	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00080	41 b9 03 00 00
	00		 mov	 r9d, 3
  00086	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG178790
  0008d	ba 94 09 00 00	 mov	 edx, 2452		; 00000994H
  00092	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG178791
  00099	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 2453 :         return;

  0009f	e9 8e 01 00 00	 jmp	 $LN1@loc3270_in
$LN2@loc3270_in:

; 2454 :     }
; 2455 : 
; 2456 :     /* Initialize DEVBLK pointer */
; 2457 :     dev = tn->dev;

  000a4	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR tn$[rsp]
  000ac	48 8b 80 a0 00
	00 00		 mov	 rax, QWORD PTR [rax+160]
  000b3	48 89 44 24 40	 mov	 QWORD PTR dev$[rsp], rax

; 2458 : 
; 2459 :     /* Calculate amount to copy */
; 2460 :     amt = min( dev->bufsize - dev->rlen3270, size );

  000b8	48 8b 44 24 40	 mov	 rax, QWORD PTR dev$[rsp]
  000bd	48 8b 4c 24 40	 mov	 rcx, QWORD PTR dev$[rsp]
  000c2	8b 89 b8 06 00
	00		 mov	 ecx, DWORD PTR [rcx+1720]
  000c8	8b 80 d8 01 00
	00		 mov	 eax, DWORD PTR [rax+472]
  000ce	2b c1		 sub	 eax, ecx
  000d0	3b 84 24 c0 00
	00 00		 cmp	 eax, DWORD PTR size$[rsp]
  000d7	73 1e		 jae	 SHORT $LN5@loc3270_in
  000d9	48 8b 44 24 40	 mov	 rax, QWORD PTR dev$[rsp]
  000de	48 8b 4c 24 40	 mov	 rcx, QWORD PTR dev$[rsp]
  000e3	8b 89 b8 06 00
	00		 mov	 ecx, DWORD PTR [rcx+1720]
  000e9	8b 80 d8 01 00
	00		 mov	 eax, DWORD PTR [rax+472]
  000ef	2b c1		 sub	 eax, ecx
  000f1	89 44 24 4c	 mov	 DWORD PTR tv86[rsp], eax
  000f5	eb 0b		 jmp	 SHORT $LN6@loc3270_in
$LN5@loc3270_in:
  000f7	8b 84 24 c0 00
	00 00		 mov	 eax, DWORD PTR size$[rsp]
  000fe	89 44 24 4c	 mov	 DWORD PTR tv86[rsp], eax
$LN6@loc3270_in:
  00102	8b 44 24 4c	 mov	 eax, DWORD PTR tv86[rsp]
  00106	89 44 24 48	 mov	 DWORD PTR amt$[rsp], eax

; 2461 : 
; 2462 :     /* Copy received data into device buffer */
; 2463 :     memcpy( dev->buf + dev->rlen3270, buffer, amt );

  0010a	8b 44 24 48	 mov	 eax, DWORD PTR amt$[rsp]
  0010e	48 8b 4c 24 40	 mov	 rcx, QWORD PTR dev$[rsp]
  00113	8b 89 b8 06 00
	00		 mov	 ecx, DWORD PTR [rcx+1720]
  00119	48 8b 54 24 40	 mov	 rdx, QWORD PTR dev$[rsp]
  0011e	48 03 8a c8 01
	00 00		 add	 rcx, QWORD PTR [rdx+456]
  00125	48 8b f9	 mov	 rdi, rcx
  00128	48 8b b4 24 b8
	00 00 00	 mov	 rsi, QWORD PTR buffer$[rsp]
  00130	8b c8		 mov	 ecx, eax
  00132	f3 a4		 rep movsb

; 2464 : 
; 2465 :     /* Update number of bytes in receive buffer */
; 2466 :     dev->rlen3270 += amt;

  00134	48 8b 44 24 40	 mov	 rax, QWORD PTR dev$[rsp]
  00139	8b 80 b8 06 00
	00		 mov	 eax, DWORD PTR [rax+1720]
  0013f	03 44 24 48	 add	 eax, DWORD PTR amt$[rsp]
  00143	48 8b 4c 24 40	 mov	 rcx, QWORD PTR dev$[rsp]
  00148	89 81 b8 06 00
	00		 mov	 DWORD PTR [rcx+1720], eax

; 2467 : 
; 2468 :     /* Check for buffer overflow */
; 2469 :     if (size > amt)

  0014e	8b 44 24 48	 mov	 eax, DWORD PTR amt$[rsp]
  00152	39 84 24 c0 00
	00 00		 cmp	 DWORD PTR size$[rsp], eax
  00159	0f 86 d3 00 00
	00		 jbe	 $LN3@loc3270_in

; 2470 :     {
; 2471 :         char clientid[32];
; 2472 :         MSGBUF( clientid, "%1d:%04X",

  0015f	48 83 7c 24 40
	00		 cmp	 QWORD PTR dev$[rsp], 0
  00165	74 0f		 je	 SHORT $LN7@loc3270_in
  00167	48 8b 44 24 40	 mov	 rax, QWORD PTR dev$[rsp]
  0016c	0f b7 40 48	 movzx	 eax, WORD PTR [rax+72]
  00170	89 44 24 50	 mov	 DWORD PTR tv137[rsp], eax
  00174	eb 08		 jmp	 SHORT $LN8@loc3270_in
$LN7@loc3270_in:
  00176	c7 44 24 50 00
	00 00 00	 mov	 DWORD PTR tv137[rsp], 0
$LN8@loc3270_in:
  0017e	48 83 7c 24 40
	00		 cmp	 QWORD PTR dev$[rsp], 0
  00184	74 11		 je	 SHORT $LN9@loc3270_in
  00186	48 8b 44 24 40	 mov	 rax, QWORD PTR dev$[rsp]
  0018b	0f b7 40 44	 movzx	 eax, WORD PTR [rax+68]
  0018f	d1 f8		 sar	 eax, 1
  00191	89 44 24 54	 mov	 DWORD PTR tv143[rsp], eax
  00195	eb 08		 jmp	 SHORT $LN10@loc3270_in
$LN9@loc3270_in:
  00197	c7 44 24 54 00
	00 00 00	 mov	 DWORD PTR tv143[rsp], 0
$LN10@loc3270_in:
  0019f	8b 44 24 50	 mov	 eax, DWORD PTR tv137[rsp]
  001a3	89 44 24 20	 mov	 DWORD PTR [rsp+32], eax
  001a7	44 8b 4c 24 54	 mov	 r9d, DWORD PTR tv143[rsp]
  001ac	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG178793
  001b3	ba 20 00 00 00	 mov	 edx, 32			; 00000020H
  001b8	48 8d 4c 24 60	 lea	 rcx, QWORD PTR clientid$1[rsp]
  001bd	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_snprintf

; 2473 :             LCSS_DEVNUM );
; 2474 :         // "%s COMM: buffer overflow"
; 2475 :         WRMSG( HHC02912, "E", clientid );

  001c3	b9 01 00 00 00	 mov	 ecx, 1
  001c8	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  001ce	48 8d 4c 24 60	 lea	 rcx, QWORD PTR clientid$1[rsp]
  001d3	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  001d8	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG178794
  001df	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  001e4	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG178795
  001eb	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  001f0	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  001f5	41 b9 03 00 00
	00		 mov	 r9d, 3
  001fb	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG178796
  00202	ba ab 09 00 00	 mov	 edx, 2475		; 000009abH
  00207	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG178797
  0020e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 2476 :         tn->overflow = TRUE;

  00214	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR tn$[rsp]
  0021c	c6 80 b5 00 00
	00 01		 mov	 BYTE PTR [rax+181], 1

; 2477 :         dev->rlen3270 = 0;

  00223	48 8b 44 24 40	 mov	 rax, QWORD PTR dev$[rsp]
  00228	c7 80 b8 06 00
	00 00 00 00 00	 mov	 DWORD PTR [rax+1720], 0
$LN3@loc3270_in:
$LN1@loc3270_in:

; 2478 :     }
; 2479 : }

  00232	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  0023a	48 33 cc	 xor	 rcx, rsp
  0023d	e8 00 00 00 00	 call	 __security_check_cookie
  00242	48 81 c4 98 00
	00 00		 add	 rsp, 152		; 00000098H
  00249	5f		 pop	 rdi
  0024a	5e		 pop	 rsi
  0024b	c3		 ret	 0
loc3270_input ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\console.c
_TEXT	SEGMENT
status$ = 32
prev_rlen3270$ = 36
dev$ = 64
cmd$ = 72
solicit_3270_data PROC

; 2693 : {

  00000	88 54 24 10	 mov	 BYTE PTR [rsp+16], dl
  00004	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00009	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 2694 :     int prev_rlen3270;
; 2695 :     BYTE status;
; 2696 : 
; 2697 :     /* Clear the inbound buffer of any unsolicited
; 2698 :        data accumulated by the connection thread */
; 2699 :     dev->rlen3270    = 0;

  0000d	48 8b 44 24 40	 mov	 rax, QWORD PTR dev$[rsp]
  00012	c7 80 b8 06 00
	00 00 00 00 00	 mov	 DWORD PTR [rax+1720], 0

; 2700 :     dev->readpending = 0;

  0001c	48 8b 44 24 40	 mov	 rax, QWORD PTR dev$[rsp]
  00021	8b 80 f8 05 00
	00		 mov	 eax, DWORD PTR [rax+1528]
  00027	25 3f ff ff ff	 and	 eax, -193		; ffffff3fH
  0002c	48 8b 4c 24 40	 mov	 rcx, QWORD PTR dev$[rsp]
  00031	89 81 f8 05 00
	00		 mov	 DWORD PTR [rcx+1528], eax

; 2701 :     dev->tn->got_eor = FALSE;

  00037	48 8b 44 24 40	 mov	 rax, QWORD PTR dev$[rsp]
  0003c	48 8b 80 b0 06
	00 00		 mov	 rax, QWORD PTR [rax+1712]
  00043	c6 80 af 00 00
	00 00		 mov	 BYTE PTR [rax+175], 0

; 2702 : 
; 2703 :     /* Send the 3270 read command to the client */
; 2704 : 
; 2705 :     telnet_3270_cmd( dev->tn->ctl, cmd );

  0004a	48 8b 44 24 40	 mov	 rax, QWORD PTR dev$[rsp]
  0004f	48 8b 80 b0 06
	00 00		 mov	 rax, QWORD PTR [rax+1712]
  00056	0f b6 54 24 48	 movzx	 edx, BYTE PTR cmd$[rsp]
  0005b	48 8b 88 98 00
	00 00		 mov	 rcx, QWORD PTR [rax+152]
  00062	e8 00 00 00 00	 call	 telnet_3270_cmd

; 2706 : 
; 2707 :     if (dev->tn->send_err)

  00067	48 8b 44 24 40	 mov	 rax, QWORD PTR dev$[rsp]
  0006c	48 8b 80 b0 06
	00 00		 mov	 rax, QWORD PTR [rax+1712]
  00073	0f b6 80 b4 00
	00 00		 movzx	 eax, BYTE PTR [rax+180]
  0007a	85 c0		 test	 eax, eax
  0007c	74 24		 je	 SHORT $LN5@solicit_32

; 2708 :     {
; 2709 :         /* Close the connection if an error occurred */
; 2710 :         disconnect_console_device( dev );

  0007e	48 8b 4c 24 40	 mov	 rcx, QWORD PTR dev$[rsp]
  00083	e8 00 00 00 00	 call	 disconnect_console_device

; 2711 :         dev->sense[0] = SENSE_DC;

  00088	b8 01 00 00 00	 mov	 eax, 1
  0008d	48 6b c0 00	 imul	 rax, rax, 0
  00091	48 8b 4c 24 40	 mov	 rcx, QWORD PTR dev$[rsp]
  00096	c6 84 01 64 03
	00 00 08	 mov	 BYTE PTR [rcx+rax+868], 8

; 2712 :         return (CSW_UC);

  0009e	b0 02		 mov	 al, 2
  000a0	eb 58		 jmp	 SHORT $LN1@solicit_32
$LN5@solicit_32:
$LN4@solicit_32:

; 2713 :     }
; 2714 : 
; 2715 :     /* Receive response data from the client */
; 2716 :     do
; 2717 :     {
; 2718 :         prev_rlen3270 = dev->rlen3270;

  000a2	48 8b 44 24 40	 mov	 rax, QWORD PTR dev$[rsp]
  000a7	8b 80 b8 06 00
	00		 mov	 eax, DWORD PTR [rax+1720]
  000ad	89 44 24 24	 mov	 DWORD PTR prev_rlen3270$[rsp], eax

; 2719 :         status = recv_3270_data( dev );

  000b1	48 8b 4c 24 40	 mov	 rcx, QWORD PTR dev$[rsp]
  000b6	e8 00 00 00 00	 call	 recv_3270_data
  000bb	88 44 24 20	 mov	 BYTE PTR status$[rsp], al

; 2720 : 
; 2721 :         // "%s COMM: recv_3270_data: %d bytes received"
; 2722 :         CONDEBUG2( HHC90502, "D", dev->tn->clientid,
; 2723 :             dev->rlen3270 - prev_rlen3270 );
; 2724 :     }
; 2725 :     while (status == 0);

  000bf	0f b6 44 24 20	 movzx	 eax, BYTE PTR status$[rsp]
  000c4	85 c0		 test	 eax, eax
  000c6	74 da		 je	 SHORT $LN4@solicit_32

; 2726 : 
; 2727 :     /* Close the connection if an error occurred */
; 2728 :     if (status & CSW_UC)

  000c8	0f b6 44 24 20	 movzx	 eax, BYTE PTR status$[rsp]
  000cd	83 e0 02	 and	 eax, 2
  000d0	85 c0		 test	 eax, eax
  000d2	74 24		 je	 SHORT $LN6@solicit_32

; 2729 :     {
; 2730 :         disconnect_console_device( dev );

  000d4	48 8b 4c 24 40	 mov	 rcx, QWORD PTR dev$[rsp]
  000d9	e8 00 00 00 00	 call	 disconnect_console_device

; 2731 :         dev->sense[0] = SENSE_DC;

  000de	b8 01 00 00 00	 mov	 eax, 1
  000e3	48 6b c0 00	 imul	 rax, rax, 0
  000e7	48 8b 4c 24 40	 mov	 rcx, QWORD PTR dev$[rsp]
  000ec	c6 84 01 64 03
	00 00 08	 mov	 BYTE PTR [rcx+rax+868], 8

; 2732 :         return (CSW_UC);

  000f4	b0 02		 mov	 al, 2
  000f6	eb 02		 jmp	 SHORT $LN1@solicit_32
$LN6@solicit_32:

; 2733 :     }
; 2734 : 
; 2735 :     /* Return zero status to indicate response received */
; 2736 :     return 0;

  000f8	32 c0		 xor	 al, al
$LN1@solicit_32:

; 2737 : 
; 2738 : } /* end function solicit_3270_data */

  000fa	48 83 c4 38	 add	 rsp, 56			; 00000038H
  000fe	c3		 ret	 0
solicit_3270_data ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\console.c
_TEXT	SEGMENT
dev$ = 80
unitstat$ = 88
sysg$ = 89
lsock2$ = 92
scan_retries$ = 96
scan_complete$ = 100
lsock$ = 104
c$1 = 108
maxfd$ = 112
rc$ = 116
csock$ = 120
tn$ = 128
select_errno$2 = 136
accept_errno$3 = 140
curr_sysgport$ = 144
tv191 = 152
tv198 = 156
f$4 = 160
curr_cnslport$ = 168
tv759 = 176
tv764 = 180
tv71 = 184
tv76 = 188
saved_errno$5 = 192
tv518 = 196
curr$6 = 200
curr$7 = 208
tidneg$ = 216
prev_rlen3270$ = 220
diff$8 = 224
tv405 = 232
diff$9 = 240
tv452 = 248
tv583 = 256
readset$ = 272
__$ArrayPad$ = 8480
arg$ = 8512
console_connection_handler PROC

; 3387 : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	b8 38 21 00 00	 mov	 eax, 8504		; 00002138H
  0000a	e8 00 00 00 00	 call	 __chkstk
  0000f	48 2b e0	 sub	 rsp, rax
  00012	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00019	48 33 c4	 xor	 rax, rsp
  0001c	48 89 84 24 20
	21 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 3388 : int           rc = 0;                   /* Return code               */

  00024	c7 44 24 74 00
	00 00 00	 mov	 DWORD PTR rc$[rsp], 0

; 3389 : int           lsock;                    /* Console listening socket  */
; 3390 : int           lsock2 = 0;               /* SYSG listening socket     */

  0002c	c7 44 24 5c 00
	00 00 00	 mov	 DWORD PTR lsock2$[rsp], 0

; 3391 : int           csock;                    /* Socket for conversation   */
; 3392 : bool          sysg = false;             /* SYSG port connection      */

  00034	c6 44 24 59 00	 mov	 BYTE PTR sysg$[rsp], 0

; 3393 : fd_set        readset;                  /* Read bit map for pselect  */
; 3394 : int           maxfd;                    /* Highest fd for pselect    */
; 3395 : int           scan_complete;            /* DEVBLK scan complete      */
; 3396 : int           scan_retries;             /* DEVBLK scan retries       */
; 3397 : TID           tidneg;                   /* Negotiation thread id     */
; 3398 : DEVBLK*       dev;                      /* -> Device block           */
; 3399 : BYTE          unitstat;                 /* Status after receive data */
; 3400 : TELNET*       tn;                       /* Telnet Control Block      */
; 3401 : const char*   curr_cnslport;            /* Current sysblk.cnslport   */
; 3402 : const char*   curr_sysgport = NULL;     /* Current sysblk.sysgport   */

  00039	48 c7 84 24 90
	00 00 00 00 00
	00 00		 mov	 QWORD PTR curr_sysgport$[rsp], 0
$LN4@console_co:

; 3403 : 
; 3404 : int prev_rlen3270;
; 3405 : 
; 3406 :     UNREFERENCED( arg );

  00045	33 c0		 xor	 eax, eax
  00047	85 c0		 test	 eax, eax
  00049	75 fa		 jne	 SHORT $LN4@console_co

; 3407 : 
; 3408 :     /* Set server thread priority; ignore any errors */
; 3409 :     set_thread_priority( sysblk.srvprio );

  0004b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fthread_self
  00051	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG179329
  00058	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  0005f	8b 91 74 13 00
	00		 mov	 edx, DWORD PTR [rcx+4980]
  00065	8b c8		 mov	 ecx, eax
  00067	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_set_thread_prio

; 3410 : 
; 3411 :     // "Thread id "TIDPAT", prio %2d, name %s started"
; 3412 :     LOG_THREAD_BEGIN( CON_CONN_THREAD_NAME  );

  0006d	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fthread_self
  00073	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG179331
  0007a	8b c8		 mov	 ecx, eax
  0007c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_get_thread_prio
  00082	89 84 24 b8 00
	00 00		 mov	 DWORD PTR tv71[rsp], eax
  00089	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fthread_self
  0008f	89 84 24 bc 00
	00 00		 mov	 DWORD PTR tv76[rsp], eax
  00096	b9 01 00 00 00	 mov	 ecx, 1
  0009b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  000a1	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG179330
  000a8	48 89 4c 24 48	 mov	 QWORD PTR [rsp+72], rcx
  000ad	8b 8c 24 b8 00
	00 00		 mov	 ecx, DWORD PTR tv71[rsp]
  000b4	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  000b8	8b 8c 24 bc 00
	00 00		 mov	 ecx, DWORD PTR tv76[rsp]
  000bf	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  000c3	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG179332
  000ca	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  000cf	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG179333
  000d6	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  000db	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  000e0	41 b9 03 00 00
	00		 mov	 r9d, 3
  000e6	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG179334
  000ed	ba 54 0d 00 00	 mov	 edx, 3412		; 00000d54H
  000f2	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG179335
  000f9	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 3413 : 
; 3414 :     /* Get information about this system */
; 3415 :     init_hostinfo( NULL );

  000ff	33 c9		 xor	 ecx, ecx
  00101	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_init_hostinfo

; 3416 : 
; 3417 :     /* If logo hasn't been built yet, build it now */
; 3418 :     if (sysblk.herclogo == NULL)

  00107	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  0010e	48 83 b8 f8 13
	00 00 00	 cmp	 QWORD PTR [rax+5112], 0
  00116	75 05		 jne	 SHORT $LN46@console_co

; 3419 :         init_logo();

  00118	e8 00 00 00 00	 call	 init_logo
$LN46@console_co:

; 3420 : 
; 3421 :     /* Save starting sysblk.cnslport value
; 3422 :        and create starting listening socket */
; 3423 :     curr_cnslport = strdup( sysblk.cnslport );

  0011d	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00124	48 8b 88 e8 13
	00 00		 mov	 rcx, QWORD PTR [rax+5096]
  0012b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_strdup
  00131	48 89 84 24 a8
	00 00 00	 mov	 QWORD PTR curr_cnslport$[rsp], rax

; 3424 :     lsock = get_listening_socket( "CNSLPORT", "", sysblk.cnslport );

  00139	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00140	4c 8b 80 e8 13
	00 00		 mov	 r8, QWORD PTR [rax+5096]
  00147	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG179337
  0014e	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG179338
  00155	e8 00 00 00 00	 call	 get_listening_socket
  0015a	89 44 24 68	 mov	 DWORD PTR lsock$[rsp], eax

; 3425 : 
; 3426 :     if (sysblk.sysgport)

  0015e	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00165	48 83 b8 f0 13
	00 00 00	 cmp	 QWORD PTR [rax+5104], 0
  0016d	74 41		 je	 SHORT $LN47@console_co

; 3427 :     {
; 3428 :         /* Save starting sysblk.sysgport value
; 3429 :            and create starting listening socket */
; 3430 :         curr_sysgport = strdup( sysblk.sysgport );

  0016f	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00176	48 8b 88 f0 13
	00 00		 mov	 rcx, QWORD PTR [rax+5104]
  0017d	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_strdup
  00183	48 89 84 24 90
	00 00 00	 mov	 QWORD PTR curr_sysgport$[rsp], rax

; 3431 :         lsock2 = get_listening_socket( "SYSGPORT", "SYSG ", sysblk.sysgport );

  0018b	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00192	4c 8b 80 f0 13
	00 00		 mov	 r8, QWORD PTR [rax+5104]
  00199	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG179340
  001a0	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG179341
  001a7	e8 00 00 00 00	 call	 get_listening_socket
  001ac	89 44 24 5c	 mov	 DWORD PTR lsock2$[rsp], eax
$LN47@console_co:
$LN126@console_co:
$LN125@console_co:
$LN124@console_co:
$LN5@console_co:

; 3432 :     }
; 3433 : 
; 3434 :     /* Handle connection requests and attention interrupts */
; 3435 :     while (console_cnslcnt > 0)

  001b0	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR console_cnslcnt, 0
  001b7	0f 8e f3 0e 00
	00		 jle	 $LN6@console_co

; 3436 :     {
; 3437 :         /* Did they set a new CNSLPORT value? */
; 3438 :         if (strcmp( curr_cnslport, sysblk.cnslport ) != 0)

  001bd	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  001c4	48 8b 90 e8 13
	00 00		 mov	 rdx, QWORD PTR [rax+5096]
  001cb	48 8b 8c 24 a8
	00 00 00	 mov	 rcx, QWORD PTR curr_cnslport$[rsp]
  001d3	e8 00 00 00 00	 call	 strcmp
  001d8	85 c0		 test	 eax, eax
  001da	74 59		 je	 SHORT $LN48@console_co

; 3439 :         {
; 3440 :             /* Close the current listening socket, save
; 3441 :                the new CNSLPORT value and obtain a fresh
; 3442 :                listening socket. */
; 3443 :             close_socket( lsock );

  001dc	8b 4c 24 68	 mov	 ecx, DWORD PTR lsock$[rsp]
  001e0	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_close_socket

; 3444 :             free( curr_cnslport );

  001e6	48 8b 8c 24 a8
	00 00 00	 mov	 rcx, QWORD PTR curr_cnslport$[rsp]
  001ee	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free

; 3445 :             curr_cnslport = strdup( sysblk.cnslport );

  001f4	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  001fb	48 8b 88 e8 13
	00 00		 mov	 rcx, QWORD PTR [rax+5096]
  00202	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_strdup
  00208	48 89 84 24 a8
	00 00 00	 mov	 QWORD PTR curr_cnslport$[rsp], rax

; 3446 :             lsock = get_listening_socket( "CNSLPORT", "", sysblk.cnslport );

  00210	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00217	4c 8b 80 e8 13
	00 00		 mov	 r8, QWORD PTR [rax+5096]
  0021e	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG179343
  00225	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG179344
  0022c	e8 00 00 00 00	 call	 get_listening_socket
  00231	89 44 24 68	 mov	 DWORD PTR lsock$[rsp], eax
$LN48@console_co:

; 3447 :         }
; 3448 : 
; 3449 :         /* Did they set a new SYSGPORT value? */
; 3450 :         if (0
; 3451 :             || (sysblk.sysgport && !curr_sysgport)
; 3452 :             || (sysblk.sysgport && strcmp( curr_sysgport, sysblk.sysgport ) != 0)

  00235	33 c0		 xor	 eax, eax
  00237	85 c0		 test	 eax, eax
  00239	75 4c		 jne	 SHORT $LN50@console_co
  0023b	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00242	48 83 b8 f0 13
	00 00 00	 cmp	 QWORD PTR [rax+5104], 0
  0024a	74 0b		 je	 SHORT $LN51@console_co
  0024c	48 83 bc 24 90
	00 00 00 00	 cmp	 QWORD PTR curr_sysgport$[rsp], 0
  00255	74 30		 je	 SHORT $LN50@console_co
$LN51@console_co:
  00257	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  0025e	48 83 b8 f0 13
	00 00 00	 cmp	 QWORD PTR [rax+5104], 0
  00266	74 7f		 je	 SHORT $LN49@console_co
  00268	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  0026f	48 8b 90 f0 13
	00 00		 mov	 rdx, QWORD PTR [rax+5104]
  00276	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR curr_sysgport$[rsp]
  0027e	e8 00 00 00 00	 call	 strcmp
  00283	85 c0		 test	 eax, eax
  00285	74 60		 je	 SHORT $LN49@console_co
$LN50@console_co:

; 3453 :         )
; 3454 :         {
; 3455 :             /* Close the current listening socket, save
; 3456 :                the new SYSGPORT value and obtain a fresh
; 3457 :                listening socket. */
; 3458 :             if (lsock2) close_socket( lsock2 );

  00287	83 7c 24 5c 00	 cmp	 DWORD PTR lsock2$[rsp], 0
  0028c	74 0a		 je	 SHORT $LN52@console_co
  0028e	8b 4c 24 5c	 mov	 ecx, DWORD PTR lsock2$[rsp]
  00292	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_close_socket
$LN52@console_co:

; 3459 :             free( curr_sysgport );

  00298	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR curr_sysgport$[rsp]
  002a0	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free

; 3460 :             curr_sysgport  = strdup( sysblk.sysgport );

  002a6	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  002ad	48 8b 88 f0 13
	00 00		 mov	 rcx, QWORD PTR [rax+5104]
  002b4	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_strdup
  002ba	48 89 84 24 90
	00 00 00	 mov	 QWORD PTR curr_sysgport$[rsp], rax

; 3461 :             lsock2 = get_listening_socket( "SYSGPORT", "SYSG ", sysblk.sysgport );

  002c2	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  002c9	4c 8b 80 f0 13
	00 00		 mov	 r8, QWORD PTR [rax+5104]
  002d0	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG179349
  002d7	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG179350
  002de	e8 00 00 00 00	 call	 get_listening_socket
  002e3	89 44 24 5c	 mov	 DWORD PTR lsock2$[rsp], eax
$LN49@console_co:

; 3462 :         }
; 3463 : 
; 3464 :         /* Initialize scan flags */
; 3465 :         scan_complete = TRUE;

  002e7	c7 44 24 64 01
	00 00 00	 mov	 DWORD PTR scan_complete$[rsp], 1

; 3466 :         scan_retries = 0;

  002ef	c7 44 24 60 00
	00 00 00	 mov	 DWORD PTR scan_retries$[rsp], 0
$LN7@console_co:

; 3467 : 
; 3468 :         /* Build pselect() read set */
; 3469 :         for (;;)
; 3470 :         {
; 3471 :             /* Initialize the pselect parameters */
; 3472 :             FD_ZERO( &readset );

  002f7	c7 84 24 10 01
	00 00 00 00 00
	00		 mov	 DWORD PTR readset$[rsp], 0

; 3473 : 
; 3474 :             FD_SET( lsock, &readset );  // (normal local 3270 devices)

  00302	48 8d 94 24 10
	01 00 00	 lea	 rdx, QWORD PTR readset$[rsp]
  0030a	8b 4c 24 68	 mov	 ecx, DWORD PTR lsock$[rsp]
  0030e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_FD_SET

; 3475 :             maxfd = lsock;              // (normal local 3270 devices)

  00314	8b 44 24 68	 mov	 eax, DWORD PTR lsock$[rsp]
  00318	89 44 24 70	 mov	 DWORD PTR maxfd$[rsp], eax

; 3476 : 
; 3477 :             /* If SYSGPORT defined and SYSG not connected yet... */
; 3478 :             if (lsock2 && sysblk.sysgdev && !sysblk.sysgdev->connected)

  0031c	83 7c 24 5c 00	 cmp	 DWORD PTR lsock2$[rsp], 0
  00321	74 6e		 je	 SHORT $LN53@console_co
  00323	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  0032a	48 83 b8 c8 11
	00 00 00	 cmp	 QWORD PTR [rax+4552], 0
  00332	74 5d		 je	 SHORT $LN53@console_co
  00334	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  0033b	48 8b 80 c8 11
	00 00		 mov	 rax, QWORD PTR [rax+4552]
  00342	8b 80 f8 05 00
	00		 mov	 eax, DWORD PTR [rax+1528]
  00348	c1 e8 05	 shr	 eax, 5
  0034b	83 e0 01	 and	 eax, 1
  0034e	85 c0		 test	 eax, eax
  00350	75 3f		 jne	 SHORT $LN53@console_co

; 3479 :             {
; 3480 :                 FD_SET( lsock2, &readset );     // (add SYSG port too)

  00352	48 8d 94 24 10
	01 00 00	 lea	 rdx, QWORD PTR readset$[rsp]
  0035a	8b 4c 24 5c	 mov	 ecx, DWORD PTR lsock2$[rsp]
  0035e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_FD_SET

; 3481 :                 maxfd = MAX( lsock, lsock2 );   // (then adjust maxfd)

  00364	8b 44 24 5c	 mov	 eax, DWORD PTR lsock2$[rsp]
  00368	39 44 24 68	 cmp	 DWORD PTR lsock$[rsp], eax
  0036c	7e 0d		 jle	 SHORT $LN120@console_co
  0036e	8b 44 24 68	 mov	 eax, DWORD PTR lsock$[rsp]
  00372	89 84 24 98 00
	00 00		 mov	 DWORD PTR tv191[rsp], eax
  00379	eb 0b		 jmp	 SHORT $LN121@console_co
$LN120@console_co:
  0037b	8b 44 24 5c	 mov	 eax, DWORD PTR lsock2$[rsp]
  0037f	89 84 24 98 00
	00 00		 mov	 DWORD PTR tv191[rsp], eax
$LN121@console_co:
  00386	8b 84 24 98 00
	00 00		 mov	 eax, DWORD PTR tv191[rsp]
  0038d	89 44 24 70	 mov	 DWORD PTR maxfd$[rsp], eax
$LN53@console_co:
$LN12@console_co:

; 3482 :             }
; 3483 : 
; 3484 :             SUPPORT_WAKEUP_CONSOLE_SELECT_VIA_PIPE( maxfd, &readset );

  00391	48 8d 94 24 10
	01 00 00	 lea	 rdx, QWORD PTR readset$[rsp]
  00399	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  003a0	8b 88 d0 10 00
	00		 mov	 ecx, DWORD PTR [rax+4304]
  003a6	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_FD_SET
  003ac	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  003b3	8b 80 d0 10 00
	00		 mov	 eax, DWORD PTR [rax+4304]
  003b9	39 44 24 70	 cmp	 DWORD PTR maxfd$[rsp], eax
  003bd	7e 0d		 jle	 SHORT $LN122@console_co
  003bf	8b 44 24 70	 mov	 eax, DWORD PTR maxfd$[rsp]
  003c3	89 84 24 9c 00
	00 00		 mov	 DWORD PTR tv198[rsp], eax
  003ca	eb 14		 jmp	 SHORT $LN123@console_co
$LN122@console_co:
  003cc	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  003d3	8b 80 d0 10 00
	00		 mov	 eax, DWORD PTR [rax+4304]
  003d9	89 84 24 9c 00
	00 00		 mov	 DWORD PTR tv198[rsp], eax
$LN123@console_co:
  003e0	8b 84 24 9c 00
	00 00		 mov	 eax, DWORD PTR tv198[rsp]
  003e7	89 44 24 70	 mov	 DWORD PTR maxfd$[rsp], eax
  003eb	33 c0		 xor	 eax, eax
  003ed	85 c0		 test	 eax, eax
  003ef	75 a0		 jne	 SHORT $LN12@console_co

; 3485 : 
; 3486 :             /* FIXME: Incorrectly running chain that may have a DEVBLK
; 3487 :              *        removed while in flight. For example, a device may
; 3488 :              *        be deleted between the loading of the nextdev and
; 3489 :              *        before the check for dev != NULL. This will result
; 3490 :              *        in an invalid storage reference and may result in
; 3491 :              *        a crash.
; 3492 :              */
; 3493 :             for (dev = sysblk.firstdev; dev != NULL; dev = dev->nextdev)

  003f1	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  003f8	48 8b 80 c0 11
	00 00		 mov	 rax, QWORD PTR [rax+4544]
  003ff	48 89 44 24 50	 mov	 QWORD PTR dev$[rsp], rax
  00404	eb 0e		 jmp	 SHORT $LN15@console_co
$LN13@console_co:
  00406	48 8b 44 24 50	 mov	 rax, QWORD PTR dev$[rsp]
  0040b	48 8b 40 30	 mov	 rax, QWORD PTR [rax+48]
  0040f	48 89 44 24 50	 mov	 QWORD PTR dev$[rsp], rax
$LN15@console_co:
  00414	48 83 7c 24 50
	00		 cmp	 QWORD PTR dev$[rsp], 0
  0041a	0f 84 07 02 00
	00		 je	 $LN14@console_co

; 3494 :             {
; 3495 :                 if (!dev->allocated ||

  00420	48 8b 44 24 50	 mov	 rax, QWORD PTR dev$[rsp]
  00425	83 78 40 00	 cmp	 DWORD PTR [rax+64], 0
  00429	74 15		 je	 SHORT $LN55@console_co
  0042b	48 8b 44 24 50	 mov	 rax, QWORD PTR dev$[rsp]
  00430	8b 80 f8 05 00
	00		 mov	 eax, DWORD PTR [rax+1528]
  00436	c1 e8 04	 shr	 eax, 4
  00439	83 e0 01	 and	 eax, 1
  0043c	85 c0		 test	 eax, eax
  0043e	75 02		 jne	 SHORT $LN54@console_co
$LN55@console_co:

; 3496 :                     !dev->console)
; 3497 :                     continue;

  00440	eb c4		 jmp	 SHORT $LN13@console_co
$LN54@console_co:

; 3498 : 
; 3499 :                 /* Try to obtain the device lock */
; 3500 :                 if (try_obtain_lock( &dev->lock ))

  00442	48 8b 44 24 50	 mov	 rax, QWORD PTR dev$[rsp]
  00447	48 83 c0 38	 add	 rax, 56			; 00000038H
  0044b	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG179355
  00452	48 8b c8	 mov	 rcx, rax
  00455	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_try_obtain_lock
  0045b	85 c0		 test	 eax, eax
  0045d	74 2d		 je	 SHORT $LN56@console_co

; 3501 :                 {
; 3502 :                     /* Unable to obtain device lock. Abort current scan
; 3503 :                        and retry our device block scan again if we have
; 3504 :                        not yet reached our retry limit. Otherwise if we
; 3505 :                        have reached our retry limit, do a normal obtain
; 3506 :                        to wait for the lock since the sched_yield we did
; 3507 :                        further below failed to accomplish what we hoped.
; 3508 :                     */
; 3509 :                     if (scan_retries < 10)

  0045f	83 7c 24 60 0a	 cmp	 DWORD PTR scan_retries$[rsp], 10
  00464	7d 0d		 jge	 SHORT $LN57@console_co

; 3510 :                     {
; 3511 :                         /* Try the scan over again from the beginning */
; 3512 :                         scan_complete = FALSE;

  00466	c7 44 24 64 00
	00 00 00	 mov	 DWORD PTR scan_complete$[rsp], 0

; 3513 :                         break;

  0046e	e9 b4 01 00 00	 jmp	 $LN14@console_co
$LN57@console_co:

; 3514 :                     }
; 3515 : 
; 3516 :                     /* Our sched_yield that we do when our retry limit
; 3517 :                        is reached failed to accomplish our objective.
; 3518 :                        Do a normal obtain_lock to wait forever for the
; 3519 :                        lock to be acquired.
; 3520 :                     */
; 3521 :                     obtain_lock( &dev->lock );

  00473	48 8b 44 24 50	 mov	 rax, QWORD PTR dev$[rsp]
  00478	48 83 c0 38	 add	 rax, 56			; 00000038H
  0047c	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG179357
  00483	48 8b c8	 mov	 rcx, rax
  00486	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_obtain_lock
$LN56@console_co:

; 3522 :                 }
; 3523 : 
; 3524 :                 if (dev->console && dev->connected)

  0048c	48 8b 44 24 50	 mov	 rax, QWORD PTR dev$[rsp]
  00491	8b 80 f8 05 00
	00		 mov	 eax, DWORD PTR [rax+1528]
  00497	c1 e8 04	 shr	 eax, 4
  0049a	83 e0 01	 and	 eax, 1
  0049d	85 c0		 test	 eax, eax
  0049f	0f 84 64 01 00
	00		 je	 $LN58@console_co
  004a5	48 8b 44 24 50	 mov	 rax, QWORD PTR dev$[rsp]
  004aa	8b 80 f8 05 00
	00		 mov	 eax, DWORD PTR [rax+1528]
  004b0	c1 e8 05	 shr	 eax, 5
  004b3	83 e0 01	 and	 eax, 1
  004b6	85 c0		 test	 eax, eax
  004b8	0f 84 4b 01 00
	00		 je	 $LN58@console_co
$LN18@console_co:

; 3525 :                 {
; 3526 :                     ASSERT( dev->fd >= 0 ); /* (sanity check) */

  004be	48 8b 44 24 50	 mov	 rax, QWORD PTR dev$[rsp]
  004c3	83 b8 ac 01 00
	00 00		 cmp	 DWORD PTR [rax+428], 0
  004ca	7d 5c		 jge	 SHORT $LN59@console_co
$LN21@console_co:
  004cc	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG179360
  004d3	41 b8 c6 0d 00
	00		 mov	 r8d, 3526		; 00000dc6H
  004d9	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG179361
  004e0	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG179362
  004e7	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_logmsg
  004ed	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_IsDebuggerPresent
  004f3	85 c0		 test	 eax, eax
  004f5	74 20		 je	 SHORT $LN60@console_co
  004f7	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG179364
  004fe	41 b8 c6 0d 00
	00		 mov	 r8d, 3526		; 00000dc6H
  00504	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG179365
  0050b	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG179366
  00512	e8 00 00 00 00	 call	 DebuggerTrace
$LN60@console_co:
  00517	33 c0		 xor	 eax, eax
  00519	85 c0		 test	 eax, eax
  0051b	75 af		 jne	 SHORT $LN21@console_co
  0051d	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_IsDebuggerPresent
  00523	85 c0		 test	 eax, eax
  00525	74 01		 je	 SHORT $LN61@console_co
  00527	cc		 int	 3
$LN61@console_co:
$LN59@console_co:
  00528	33 c0		 xor	 eax, eax
  0052a	85 c0		 test	 eax, eax
  0052c	75 90		 jne	 SHORT $LN18@console_co

; 3527 : 
; 3528 :                     /* Add it to our read set only if it's
; 3529 :                        not busy nor interrupt pending
; 3530 :                     */
; 3531 :                     if (1
; 3532 :                         && (!dev->busy || (dev->scsw.flag3 & SCSW3_AC_SUSP))
; 3533 :                         && !IOPENDING( dev )
; 3534 :                         && !(dev->scsw.flag3 & SCSW3_SC_PEND)

  0052e	33 c0		 xor	 eax, eax
  00530	83 f8 01	 cmp	 eax, 1
  00533	0f 84 d0 00 00
	00		 je	 $LN62@console_co
  00539	48 8b 44 24 50	 mov	 rax, QWORD PTR dev$[rsp]
  0053e	8b 80 f8 05 00
	00		 mov	 eax, DWORD PTR [rax+1528]
  00544	c1 e8 13	 shr	 eax, 19
  00547	83 e0 01	 and	 eax, 1
  0054a	85 c0		 test	 eax, eax
  0054c	74 17		 je	 SHORT $LN63@console_co
  0054e	48 8b 44 24 50	 mov	 rax, QWORD PTR dev$[rsp]
  00553	0f b6 80 0b 03
	00 00		 movzx	 eax, BYTE PTR [rax+779]
  0055a	83 e0 20	 and	 eax, 32			; 00000020H
  0055d	85 c0		 test	 eax, eax
  0055f	0f 84 a4 00 00
	00		 je	 $LN62@console_co
$LN63@console_co:
  00565	48 8b 44 24 50	 mov	 rax, QWORD PTR dev$[rsp]
  0056a	8b 80 f8 05 00
	00		 mov	 eax, DWORD PTR [rax+1528]
  00570	c1 e8 16	 shr	 eax, 22
  00573	83 e0 01	 and	 eax, 1
  00576	85 c0		 test	 eax, eax
  00578	0f 85 8b 00 00
	00		 jne	 $LN62@console_co
  0057e	48 8b 44 24 50	 mov	 rax, QWORD PTR dev$[rsp]
  00583	8b 80 f8 05 00
	00		 mov	 eax, DWORD PTR [rax+1528]
  00589	c1 e8 17	 shr	 eax, 23
  0058c	83 e0 01	 and	 eax, 1
  0058f	85 c0		 test	 eax, eax
  00591	75 76		 jne	 SHORT $LN62@console_co
  00593	48 8b 44 24 50	 mov	 rax, QWORD PTR dev$[rsp]
  00598	8b 80 f8 05 00
	00		 mov	 eax, DWORD PTR [rax+1528]
  0059e	c1 e8 18	 shr	 eax, 24
  005a1	83 e0 01	 and	 eax, 1
  005a4	85 c0		 test	 eax, eax
  005a6	75 61		 jne	 SHORT $LN62@console_co
  005a8	48 8b 44 24 50	 mov	 rax, QWORD PTR dev$[rsp]
  005ad	8b 80 f8 05 00
	00		 mov	 eax, DWORD PTR [rax+1528]
  005b3	c1 e8 1b	 shr	 eax, 27
  005b6	83 e0 01	 and	 eax, 1
  005b9	85 c0		 test	 eax, eax
  005bb	75 4c		 jne	 SHORT $LN62@console_co
  005bd	48 8b 44 24 50	 mov	 rax, QWORD PTR dev$[rsp]
  005c2	0f b6 80 0b 03
	00 00		 movzx	 eax, BYTE PTR [rax+779]
  005c9	83 e0 01	 and	 eax, 1
  005cc	85 c0		 test	 eax, eax
  005ce	75 39		 jne	 SHORT $LN62@console_co

; 3535 :                     )
; 3536 :                     {
; 3537 :                         FD_SET( dev->fd, &readset );

  005d0	48 8d 94 24 10
	01 00 00	 lea	 rdx, QWORD PTR readset$[rsp]
  005d8	48 8b 44 24 50	 mov	 rax, QWORD PTR dev$[rsp]
  005dd	8b 88 ac 01 00
	00		 mov	 ecx, DWORD PTR [rax+428]
  005e3	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_FD_SET

; 3538 :                         if (dev->fd > maxfd)

  005e9	48 8b 44 24 50	 mov	 rax, QWORD PTR dev$[rsp]
  005ee	8b 4c 24 70	 mov	 ecx, DWORD PTR maxfd$[rsp]
  005f2	39 88 ac 01 00
	00		 cmp	 DWORD PTR [rax+428], ecx
  005f8	7e 0f		 jle	 SHORT $LN64@console_co

; 3539 :                             maxfd = dev->fd;

  005fa	48 8b 44 24 50	 mov	 rax, QWORD PTR dev$[rsp]
  005ff	8b 80 ac 01 00
	00		 mov	 eax, DWORD PTR [rax+428]
  00605	89 44 24 70	 mov	 DWORD PTR maxfd$[rsp], eax
$LN64@console_co:
$LN62@console_co:
$LN58@console_co:

; 3540 :                     }
; 3541 : 
; 3542 :                 } /* end if connected console */
; 3543 : 
; 3544 :                 release_lock( &dev->lock );

  00609	48 8b 44 24 50	 mov	 rax, QWORD PTR dev$[rsp]
  0060e	48 83 c0 38	 add	 rax, 56			; 00000038H
  00612	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG179371
  00619	48 8b c8	 mov	 rcx, rax
  0061c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_release_lock

; 3545 : 
; 3546 :             } /* end scan DEVBLK chain */

  00622	e9 df fd ff ff	 jmp	 $LN13@console_co
$LN14@console_co:

; 3547 : 
; 3548 :             /* Entire DEVBLK chain scanned without any problems? */
; 3549 :             if (scan_complete)

  00627	83 7c 24 64 00	 cmp	 DWORD PTR scan_complete$[rsp], 0
  0062c	74 02		 je	 SHORT $LN65@console_co

; 3550 :                 break;

  0062e	eb 24		 jmp	 SHORT $LN8@console_co
$LN65@console_co:

; 3551 : 
; 3552 :             /* Lock conflict; wait a moment before trying again */
; 3553 :             if (++scan_retries >= 10)

  00630	8b 44 24 60	 mov	 eax, DWORD PTR scan_retries$[rsp]
  00634	ff c0		 inc	 eax
  00636	89 44 24 60	 mov	 DWORD PTR scan_retries$[rsp], eax
  0063a	83 7c 24 60 0a	 cmp	 DWORD PTR scan_retries$[rsp], 10
  0063f	7c 06		 jl	 SHORT $LN66@console_co

; 3554 :                 sched_yield();

  00641	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_sched_yield
$LN66@console_co:

; 3555 : 
; 3556 :             /* Reset scan flag and try again */
; 3557 :             scan_complete = TRUE;

  00647	c7 44 24 64 01
	00 00 00	 mov	 DWORD PTR scan_complete$[rsp], 1

; 3558 : 
; 3559 :         } /* end build pselect() read set */

  0064f	e9 a3 fc ff ff	 jmp	 $LN7@console_co
$LN8@console_co:

; 3560 : 
; 3561 :         /* Wait for a file descriptor to become ready.
; 3562 :          *
; 3563 :          * We use the POSIX pselect() function (and NOT the select()
; 3564 :          * function used in previous versions of Hercules) to address
; 3565 :          * several issues, including:
; 3566 :          *
; 3567 :          *     1)  Timeout values, as previously used in the console.c
; 3568 :          *         select() statements, are now constants.
; 3569 :          *
; 3570 :          *     2)  While debugging with POSIX, the need arose to manage
; 3571 :          *         interrupts for temporary debug code, and to avoid
; 3572 :          *         both real and induced deadlocks with other tasks
; 3573 :          *         (including the debuggers).
; 3574 :          *
; 3575 :          * For clarity, and rather than make additional botched attempts
; 3576 :          * to debug with pselect() and then release the final code with
; 3577 :          * the original select(), we now ALWAYS use pselect() with a NULL
; 3578 :          * interrupt mask instead which should be functionally equivalent
; 3579 :          * to select() anyway.
; 3580 :          */
; 3581 :         rc = pselect( maxfd+1, &readset, NULL, NULL, timeout, NULL );

  00654	8b 44 24 70	 mov	 eax, DWORD PTR maxfd$[rsp]
  00658	ff c0		 inc	 eax
  0065a	c7 44 24 38 fd
	0d 00 00	 mov	 DWORD PTR [rsp+56], 3581 ; 00000dfdH
  00662	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG179374
  00669	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  0066e	48 c7 44 24 28
	00 00 00 00	 mov	 QWORD PTR [rsp+40], 0
  00677	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR timeout
  0067e	48 89 4c 24 20	 mov	 QWORD PTR [rsp+32], rcx
  00683	45 33 c9	 xor	 r9d, r9d
  00686	45 33 c0	 xor	 r8d, r8d
  00689	48 8d 94 24 10
	01 00 00	 lea	 rdx, QWORD PTR readset$[rsp]
  00691	8b c8		 mov	 ecx, eax
  00693	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_pselect
  00699	89 44 24 74	 mov	 DWORD PTR rc$[rsp], eax
$LN24@console_co:

; 3582 : 
; 3583 :         /* Clear the pipe signal if necessary */
; 3584 :         RECV_CONSOLE_THREAD_PIPE_SIGNAL();

  0069d	c6 44 24 6c 00	 mov	 BYTE PTR c$1[rsp], 0
  006a2	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_WSAGetLastError
  006a8	89 84 24 c0 00
	00 00		 mov	 DWORD PTR saved_errno$5[rsp], eax
  006af	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  006b6	48 05 c0 10 00
	00		 add	 rax, 4288		; 000010c0H
  006bc	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG179375
  006c3	48 8b c8	 mov	 rcx, rax
  006c6	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_obtain_lock
  006cc	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  006d3	8b 80 c8 10 00
	00		 mov	 eax, DWORD PTR [rax+4296]
  006d9	89 84 24 a0 00
	00 00		 mov	 DWORD PTR f$4[rsp], eax
  006e0	83 bc 24 a0 00
	00 00 01	 cmp	 DWORD PTR f$4[rsp], 1
  006e8	7c 11		 jl	 SHORT $LN67@console_co
  006ea	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  006f1	c7 80 c8 10 00
	00 00 00 00 00	 mov	 DWORD PTR [rax+4296], 0
$LN67@console_co:
  006fb	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00702	48 05 c0 10 00
	00		 add	 rax, 4288		; 000010c0H
  00708	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG179377
  0070f	48 8b c8	 mov	 rcx, rax
  00712	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_release_lock
  00718	83 bc 24 a0 00
	00 00 01	 cmp	 DWORD PTR f$4[rsp], 1
  00720	0f 8c 90 00 00
	00		 jl	 $LN68@console_co
$LN27@console_co:
  00726	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  0072d	48 63 80 d0 10
	00 00		 movsxd	 rax, DWORD PTR [rax+4304]
  00734	45 33 c9	 xor	 r9d, r9d
  00737	41 b8 01 00 00
	00		 mov	 r8d, 1
  0073d	48 8d 54 24 6c	 lea	 rdx, QWORD PTR c$1[rsp]
  00742	48 8b c8	 mov	 rcx, rax
  00745	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_recv
  0074b	83 f8 01	 cmp	 eax, 1
  0074e	74 5c		 je	 SHORT $LN69@console_co
$LN30@console_co:
  00750	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG179380
  00757	41 b8 00 0e 00
	00		 mov	 r8d, 3584		; 00000e00H
  0075d	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG179381
  00764	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG179382
  0076b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_logmsg
  00771	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_IsDebuggerPresent
  00777	85 c0		 test	 eax, eax
  00779	74 20		 je	 SHORT $LN70@console_co
  0077b	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG179384
  00782	41 b8 00 0e 00
	00		 mov	 r8d, 3584		; 00000e00H
  00788	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG179385
  0078f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG179386
  00796	e8 00 00 00 00	 call	 DebuggerTrace
$LN70@console_co:
  0079b	33 c0		 xor	 eax, eax
  0079d	85 c0		 test	 eax, eax
  0079f	75 af		 jne	 SHORT $LN30@console_co
  007a1	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_IsDebuggerPresent
  007a7	85 c0		 test	 eax, eax
  007a9	74 01		 je	 SHORT $LN71@console_co
  007ab	cc		 int	 3
$LN71@console_co:
$LN69@console_co:
  007ac	33 c0		 xor	 eax, eax
  007ae	85 c0		 test	 eax, eax
  007b0	0f 85 70 ff ff
	ff		 jne	 $LN27@console_co
$LN68@console_co:
  007b6	8b 8c 24 c0 00
	00 00		 mov	 ecx, DWORD PTR saved_errno$5[rsp]
  007bd	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_WSASetLastError
  007c3	33 c0		 xor	 eax, eax
  007c5	85 c0		 test	 eax, eax
  007c7	0f 85 d0 fe ff
	ff		 jne	 $LN24@console_co

; 3585 : 
; 3586 :         /* Check for thread exit condition */
; 3587 :         if (console_cnslcnt <= 0)

  007cd	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR console_cnslcnt, 0
  007d4	7f 05		 jg	 SHORT $LN72@console_co

; 3588 :             break;

  007d6	e9 d5 08 00 00	 jmp	 $LN6@console_co
$LN72@console_co:

; 3589 : 
; 3590 :         /* Check for select timeout */
; 3591 :         if (rc == 0)

  007db	83 7c 24 74 00	 cmp	 DWORD PTR rc$[rsp], 0
  007e0	75 0a		 jne	 SHORT $LN73@console_co

; 3592 :         {
; 3593 :             consto();

  007e2	e8 00 00 00 00	 call	 consto

; 3594 :             continue;

  007e7	e9 c4 f9 ff ff	 jmp	 $LN5@console_co
$LN73@console_co:

; 3595 :         }
; 3596 : 
; 3597 :         /* Log pselect error */
; 3598 :         if (rc < 0 )

  007ec	83 7c 24 74 00	 cmp	 DWORD PTR rc$[rsp], 0
  007f1	0f 8d 16 01 00
	00		 jge	 $LN74@console_co

; 3599 :         {
; 3600 :             int select_errno = HSO_errno; // (preserve orig errno)

  007f7	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_WSAGetLastError
  007fd	89 84 24 88 00
	00 00		 mov	 DWORD PTR select_errno$2[rsp], eax

; 3601 :             static int issue_errmsg = 1;  // (prevents msgs flood)
; 3602 : 
; 3603 :             if (EBADF == select_errno)

  00804	83 bc 24 88 00
	00 00 09	 cmp	 DWORD PTR select_errno$2[rsp], 9
  0080c	75 69		 jne	 SHORT $LN75@console_co

; 3604 :             {
; 3605 :                 // Don't issue message more frequently
; 3606 :                 // than once every second or so, just in
; 3607 :                 // case the condition that's causing it
; 3608 :                 // keeps reoccurring over and over...
; 3609 : 
; 3610 :                 static struct timeval  prev = {0,0};
; 3611 :                        struct timeval  curr;
; 3612 :                        struct timeval  diff;
; 3613 : 
; 3614 :                 gettimeofday( &curr, NULL );

  0080e	33 d2		 xor	 edx, edx
  00810	48 8d 8c 24 c8
	00 00 00	 lea	 rcx, QWORD PTR curr$6[rsp]
  00818	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_gettimeofday

; 3615 :                 timeval_subtract( &prev, &curr, &diff );

  0081e	4c 8d 84 24 e0
	00 00 00	 lea	 r8, QWORD PTR diff$8[rsp]
  00826	48 8d 94 24 c8
	00 00 00	 lea	 rdx, QWORD PTR curr$6[rsp]
  0082e	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:?prev@?BN@??console_connection_handler@@9@9
  00835	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_timeval_subtract

; 3616 : 
; 3617 :                 // Has it been longer than one second
; 3618 :                 // since we last issued this message?
; 3619 : 
; 3620 :                 if (diff.tv_sec >= 1)

  0083b	83 bc 24 e0 00
	00 00 01	 cmp	 DWORD PTR diff$8[rsp], 1
  00843	7c 26		 jl	 SHORT $LN77@console_co

; 3621 :                 {
; 3622 :                     issue_errmsg = 1;

  00845	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR ?issue_errmsg@?BM@??console_connection_handler@@9@9, 1

; 3623 :                     prev.tv_sec  = curr.tv_sec;

  0084f	8b 84 24 c8 00
	00 00		 mov	 eax, DWORD PTR curr$6[rsp]
  00856	89 05 00 00 00
	00		 mov	 DWORD PTR ?prev@?BN@??console_connection_handler@@9@9, eax

; 3624 :                     prev.tv_usec = curr.tv_usec;

  0085c	8b 84 24 cc 00
	00 00		 mov	 eax, DWORD PTR curr$6[rsp+4]
  00863	89 05 04 00 00
	00		 mov	 DWORD PTR ?prev@?BN@??console_connection_handler@@9@9+4, eax

; 3625 :                 }

  00869	eb 0a		 jmp	 SHORT $LN78@console_co
$LN77@console_co:

; 3626 :                 else
; 3627 :                     issue_errmsg = 0;   // (prevents msgs flood)

  0086b	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?issue_errmsg@?BM@??console_connection_handler@@9@9, 0
$LN78@console_co:

; 3628 :             }

  00875	eb 0a		 jmp	 SHORT $LN76@console_co
$LN75@console_co:

; 3629 :             else
; 3630 :                 issue_errmsg = 1;

  00877	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR ?issue_errmsg@?BM@??console_connection_handler@@9@9, 1
$LN76@console_co:

; 3631 : 
; 3632 :             if (issue_errmsg && EINTR != select_errno)

  00881	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?issue_errmsg@?BM@??console_connection_handler@@9@9, 0
  00888	74 7e		 je	 SHORT $LN79@console_co
  0088a	83 bc 24 88 00
	00 00 04	 cmp	 DWORD PTR select_errno$2[rsp], 4
  00892	74 74		 je	 SHORT $LN79@console_co

; 3633 :             {
; 3634 :                 // "COMM: pselect() failed: %s"
; 3635 :                 CONERROR( HHC90508, "D", strerror( select_errno ));

  00894	8b 8c 24 88 00
	00 00		 mov	 ecx, DWORD PTR select_errno$2[rsp]
  0089b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_strerror
  008a1	48 89 84 24 e8
	00 00 00	 mov	 QWORD PTR tv405[rsp], rax
  008a9	b9 01 00 00 00	 mov	 ecx, 1
  008ae	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  008b4	48 8b 8c 24 e8
	00 00 00	 mov	 rcx, QWORD PTR tv405[rsp]
  008bc	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  008c1	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG179396
  008c8	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  008cd	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG179397
  008d4	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  008d9	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  008de	41 b9 03 00 00
	00		 mov	 r9d, 3
  008e4	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG179398
  008eb	ba 33 0e 00 00	 mov	 edx, 3635		; 00000e33H
  008f0	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG179399
  008f7	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 3636 :                 usleep( 50000 ); // (wait a bit; maybe it'll fix itself??)

  008fd	b9 50 c3 00 00	 mov	 ecx, 50000		; 0000c350H
  00902	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_usleep
$LN79@console_co:

; 3637 :             }
; 3638 :             continue;

  00908	e9 a3 f8 ff ff	 jmp	 $LN124@console_co
$LN74@console_co:

; 3639 : 
; 3640 :         } /* end log pselect error */
; 3641 : 
; 3642 :         /* Accept incoming client connections */
; 3643 :         if (0
; 3644 :             || (lsock2 && FD_ISSET( lsock2, &readset ))
; 3645 :             || FD_ISSET( lsock,  &readset )

  0090d	33 c0		 xor	 eax, eax
  0090f	85 c0		 test	 eax, eax
  00911	75 37		 jne	 SHORT $LN81@console_co
  00913	83 7c 24 5c 00	 cmp	 DWORD PTR lsock2$[rsp], 0
  00918	74 16		 je	 SHORT $LN82@console_co
  0091a	48 8d 94 24 10
	01 00 00	 lea	 rdx, QWORD PTR readset$[rsp]
  00922	8b 4c 24 5c	 mov	 ecx, DWORD PTR lsock2$[rsp]
  00926	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_FD_ISSET
  0092c	85 c0		 test	 eax, eax
  0092e	75 1a		 jne	 SHORT $LN81@console_co
$LN82@console_co:
  00930	48 8d 94 24 10
	01 00 00	 lea	 rdx, QWORD PTR readset$[rsp]
  00938	8b 4c 24 68	 mov	 ecx, DWORD PTR lsock$[rsp]
  0093c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_FD_ISSET
  00942	85 c0		 test	 eax, eax
  00944	0f 84 db 03 00
	00		 je	 $LN80@console_co
$LN81@console_co:

; 3646 :         )
; 3647 :         {
; 3648 :             /* Accept a connection and create conversation socket */
; 3649 :             if (lsock2 && FD_ISSET( lsock2, &readset ))

  0094a	83 7c 24 5c 00	 cmp	 DWORD PTR lsock2$[rsp], 0
  0094f	74 30		 je	 SHORT $LN83@console_co
  00951	48 8d 94 24 10
	01 00 00	 lea	 rdx, QWORD PTR readset$[rsp]
  00959	8b 4c 24 5c	 mov	 ecx, DWORD PTR lsock2$[rsp]
  0095d	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_FD_ISSET
  00963	85 c0		 test	 eax, eax
  00965	74 1a		 je	 SHORT $LN83@console_co

; 3650 :             {
; 3651 :                 csock = accept( lsock2, NULL, NULL );

  00967	45 33 c0	 xor	 r8d, r8d
  0096a	33 d2		 xor	 edx, edx
  0096c	8b 4c 24 5c	 mov	 ecx, DWORD PTR lsock2$[rsp]
  00970	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_accept
  00976	89 44 24 78	 mov	 DWORD PTR csock$[rsp], eax

; 3652 :                 sysg = true;

  0097a	c6 44 24 59 01	 mov	 BYTE PTR sysg$[rsp], 1

; 3653 :             }

  0097f	eb 18		 jmp	 SHORT $LN84@console_co
$LN83@console_co:

; 3654 :             else
; 3655 :             {
; 3656 :                 csock = accept( lsock,  NULL, NULL );

  00981	45 33 c0	 xor	 r8d, r8d
  00984	33 d2		 xor	 edx, edx
  00986	8b 4c 24 68	 mov	 ecx, DWORD PTR lsock$[rsp]
  0098a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_accept
  00990	89 44 24 78	 mov	 DWORD PTR csock$[rsp], eax

; 3657 :                 sysg = false;

  00994	c6 44 24 59 00	 mov	 BYTE PTR sysg$[rsp], 0
$LN84@console_co:

; 3658 :             }
; 3659 : 
; 3660 :             if (csock < 0)

  00999	83 7c 24 78 00	 cmp	 DWORD PTR csock$[rsp], 0
  0099e	0f 8d 19 01 00
	00		 jge	 $LN85@console_co

; 3661 :             {
; 3662 :                 // (use same technique as pselect error above)
; 3663 : 
; 3664 :                 int accept_errno = HSO_errno; // (preserve orig errno)

  009a4	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_WSAGetLastError
  009aa	89 84 24 8c 00
	00 00		 mov	 DWORD PTR accept_errno$3[rsp], eax

; 3665 :                 static int issue_errmsg = 1;  // (prevents msgs flood)
; 3666 : 
; 3667 :                 if (HSO_EMFILE == accept_errno)

  009b1	81 bc 24 8c 00
	00 00 28 27 00
	00		 cmp	 DWORD PTR accept_errno$3[rsp], 10024 ; 00002728H
  009bc	75 69		 jne	 SHORT $LN86@console_co

; 3668 :                 {
; 3669 :                     // Don't issue message more frequently
; 3670 :                     // than once every second or so, just in
; 3671 :                     // case the condition that's causing it
; 3672 :                     // keeps reoccurring over and over...
; 3673 : 
; 3674 :                     static struct timeval  prev = {0,0};
; 3675 :                            struct timeval  curr;
; 3676 :                            struct timeval  diff;
; 3677 : 
; 3678 :                     gettimeofday( &curr, NULL );

  009be	33 d2		 xor	 edx, edx
  009c0	48 8d 8c 24 d0
	00 00 00	 lea	 rcx, QWORD PTR curr$7[rsp]
  009c8	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_gettimeofday

; 3679 :                     timeval_subtract( &prev, &curr, &diff );

  009ce	4c 8d 84 24 f0
	00 00 00	 lea	 r8, QWORD PTR diff$9[rsp]
  009d6	48 8d 94 24 d0
	00 00 00	 lea	 rdx, QWORD PTR curr$7[rsp]
  009de	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:?prev@?CE@??console_connection_handler@@9@9
  009e5	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_timeval_subtract

; 3680 : 
; 3681 :                     // Has it been longer than one second
; 3682 :                     // since we last issued this message?
; 3683 : 
; 3684 :                     if (diff.tv_sec >= 1)

  009eb	83 bc 24 f0 00
	00 00 01	 cmp	 DWORD PTR diff$9[rsp], 1
  009f3	7c 26		 jl	 SHORT $LN88@console_co

; 3685 :                     {
; 3686 :                         issue_errmsg = 1;

  009f5	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR ?issue_errmsg@?CD@??console_connection_handler@@9@9, 1

; 3687 :                         prev.tv_sec  = curr.tv_sec;

  009ff	8b 84 24 d0 00
	00 00		 mov	 eax, DWORD PTR curr$7[rsp]
  00a06	89 05 00 00 00
	00		 mov	 DWORD PTR ?prev@?CE@??console_connection_handler@@9@9, eax

; 3688 :                         prev.tv_usec = curr.tv_usec;

  00a0c	8b 84 24 d4 00
	00 00		 mov	 eax, DWORD PTR curr$7[rsp+4]
  00a13	89 05 04 00 00
	00		 mov	 DWORD PTR ?prev@?CE@??console_connection_handler@@9@9+4, eax

; 3689 :                     }

  00a19	eb 0a		 jmp	 SHORT $LN89@console_co
$LN88@console_co:

; 3690 :                     else
; 3691 :                         issue_errmsg = 0;   // (prevents msgs flood)

  00a1b	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?issue_errmsg@?CD@??console_connection_handler@@9@9, 0
$LN89@console_co:

; 3692 :                 }

  00a25	eb 0a		 jmp	 SHORT $LN87@console_co
$LN86@console_co:

; 3693 :                 else
; 3694 :                     issue_errmsg = 1;

  00a27	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR ?issue_errmsg@?CD@??console_connection_handler@@9@9, 1
$LN87@console_co:

; 3695 : 
; 3696 :                 if (issue_errmsg && EINTR != accept_errno)

  00a31	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?issue_errmsg@?CD@??console_connection_handler@@9@9, 0
  00a38	74 7e		 je	 SHORT $LN90@console_co
  00a3a	83 bc 24 8c 00
	00 00 04	 cmp	 DWORD PTR accept_errno$3[rsp], 4
  00a42	74 74		 je	 SHORT $LN90@console_co

; 3697 :                 {
; 3698 :                     // "COMM: accept() failed: %s"
; 3699 :                     CONERROR( HHC90509, "D", strerror( accept_errno ));

  00a44	8b 8c 24 8c 00
	00 00		 mov	 ecx, DWORD PTR accept_errno$3[rsp]
  00a4b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_strerror
  00a51	48 89 84 24 f8
	00 00 00	 mov	 QWORD PTR tv452[rsp], rax
  00a59	b9 01 00 00 00	 mov	 ecx, 1
  00a5e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  00a64	48 8b 8c 24 f8
	00 00 00	 mov	 rcx, QWORD PTR tv452[rsp]
  00a6c	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  00a71	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG179411
  00a78	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  00a7d	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG179412
  00a84	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00a89	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00a8e	41 b9 03 00 00
	00		 mov	 r9d, 3
  00a94	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG179413
  00a9b	ba 73 0e 00 00	 mov	 edx, 3699		; 00000e73H
  00aa0	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG179414
  00aa7	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 3700 :                     usleep( 50000 ); // (wait a bit; maybe it'll fix itself??)

  00aad	b9 50 c3 00 00	 mov	 ecx, 50000		; 0000c350H
  00ab2	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_usleep
$LN90@console_co:

; 3701 :                 }
; 3702 :                 continue;

  00ab8	e9 f3 f6 ff ff	 jmp	 $LN125@console_co
$LN85@console_co:

; 3703 :             }
; 3704 : 
; 3705 :             /* Allocate Telnet Control Block for this client */
; 3706 :             if (!(tn = (TELNET*) calloc( 1, sizeof( TELNET ))))

  00abd	ba b8 00 00 00	 mov	 edx, 184		; 000000b8H
  00ac2	b9 01 00 00 00	 mov	 ecx, 1
  00ac7	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_calloc
  00acd	48 89 84 24 80
	00 00 00	 mov	 QWORD PTR tn$[rsp], rax
  00ad5	48 83 bc 24 80
	00 00 00 00	 cmp	 QWORD PTR tn$[rsp], 0
  00ade	75 55		 jne	 SHORT $LN91@console_co

; 3707 :             {
; 3708 :                 // "Out of memory"
; 3709 :                 WRMSG( HHC00152, "E" );

  00ae0	b9 01 00 00 00	 mov	 ecx, 1
  00ae5	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  00aeb	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG179417
  00af2	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  00af7	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG179418
  00afe	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00b03	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00b08	41 b9 03 00 00
	00		 mov	 r9d, 3
  00b0e	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG179419
  00b15	ba 7d 0e 00 00	 mov	 edx, 3709		; 00000e7dH
  00b1a	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG179420
  00b21	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 3710 :                 telnet_closesocket( csock );

  00b27	8b 4c 24 78	 mov	 ecx, DWORD PTR csock$[rsp]
  00b2b	e8 00 00 00 00	 call	 telnet_closesocket

; 3711 :             }

  00b30	e9 f0 01 00 00	 jmp	 $LN92@console_co
$LN91@console_co:

; 3712 :             else
; 3713 :             {
; 3714 :                 static U32 clid = 0;
; 3715 :                 tn->csock = csock;

  00b35	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR tn$[rsp]
  00b3d	8b 4c 24 78	 mov	 ecx, DWORD PTR csock$[rsp]
  00b41	89 88 84 00 00
	00		 mov	 DWORD PTR [rax+132], ecx

; 3716 :                 tn->sysg  = sysg;

  00b47	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR tn$[rsp]
  00b4f	0f b6 4c 24 59	 movzx	 ecx, BYTE PTR sysg$[rsp]
  00b54	88 88 88 00 00
	00		 mov	 BYTE PTR [rax+136], cl

; 3717 :                 MSGBUF( tn->clientid, "client %u", clid++ );

  00b5a	8b 05 00 00 00
	00		 mov	 eax, DWORD PTR ?clid@?CI@??console_connection_handler@@9@9
  00b60	89 84 24 c4 00
	00 00		 mov	 DWORD PTR tv518[rsp], eax
  00b67	8b 05 00 00 00
	00		 mov	 eax, DWORD PTR ?clid@?CI@??console_connection_handler@@9@9
  00b6d	ff c0		 inc	 eax
  00b6f	89 05 00 00 00
	00		 mov	 DWORD PTR ?clid@?CI@??console_connection_handler@@9@9, eax
  00b75	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR tn$[rsp]
  00b7d	48 83 c0 62	 add	 rax, 98			; 00000062H
  00b81	44 8b 8c 24 c4
	00 00 00	 mov	 r9d, DWORD PTR tv518[rsp]
  00b89	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG179421
  00b90	ba 20 00 00 00	 mov	 edx, 32			; 00000020H
  00b95	48 8b c8	 mov	 rcx, rax
  00b98	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_snprintf

; 3718 : 
; 3719 :                 /* Initialize libtelnet package */
; 3720 :                 tn->ctl = telnet_init( telnet_opts,

  00b9e	4c 8b 8c 24 80
	00 00 00	 mov	 r9, QWORD PTR tn$[rsp]
  00ba6	41 b0 80	 mov	 r8b, 128		; 00000080H
  00ba9	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:telnet_ev_handler
  00bb0	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:telnet_opts
  00bb7	e8 00 00 00 00	 call	 telnet_init
  00bbc	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR tn$[rsp]
  00bc4	48 89 81 98 00
	00 00		 mov	 QWORD PTR [rcx+152], rax

; 3721 :                     telnet_ev_handler, TELNET_FLAG_ACTIVE_NEG, tn );
; 3722 : 
; 3723 :                 if (!tn->ctl)

  00bcb	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR tn$[rsp]
  00bd3	48 83 b8 98 00
	00 00 00	 cmp	 QWORD PTR [rax+152], 0
  00bdb	75 63		 jne	 SHORT $LN93@console_co

; 3724 :                 {
; 3725 :                     // "Out of memory"
; 3726 :                     WRMSG( HHC00152, "E" );

  00bdd	b9 01 00 00 00	 mov	 ecx, 1
  00be2	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  00be8	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG179424
  00bef	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  00bf4	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG179425
  00bfb	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00c00	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00c05	41 b9 03 00 00
	00		 mov	 r9d, 3
  00c0b	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG179426
  00c12	ba 8e 0e 00 00	 mov	 edx, 3726		; 00000e8eH
  00c17	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG179427
  00c1e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 3727 :                     free( tn );

  00c24	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR tn$[rsp]
  00c2c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free

; 3728 :                     telnet_closesocket( csock );

  00c32	8b 4c 24 78	 mov	 ecx, DWORD PTR csock$[rsp]
  00c36	e8 00 00 00 00	 call	 telnet_closesocket

; 3729 :                 }

  00c3b	e9 e5 00 00 00	 jmp	 $LN94@console_co
$LN93@console_co:

; 3730 :                 else
; 3731 :                 {
; 3732 :                     /* Create a thread to complete the client connection */
; 3733 :                     rc = create_thread( &tidneg, DETACHED,

  00c40	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00c47	48 05 88 10 00
	00		 add	 rax, 4232		; 00001088H
  00c4d	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG179428
  00c54	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00c59	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG179429
  00c60	48 89 4c 24 20	 mov	 QWORD PTR [rsp+32], rcx
  00c65	4c 8b 8c 24 80
	00 00 00	 mov	 r9, QWORD PTR tn$[rsp]
  00c6d	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:connect_client
  00c74	48 8b d0	 mov	 rdx, rax
  00c77	48 8d 8c 24 d8
	00 00 00	 lea	 rcx, QWORD PTR tidneg$[rsp]
  00c7f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_create_thread
  00c85	89 44 24 74	 mov	 DWORD PTR rc$[rsp], eax

; 3734 :                                 connect_client, tn, CONN_CLI_THREAD_NAME );
; 3735 :                     if (rc)

  00c89	83 7c 24 74 00	 cmp	 DWORD PTR rc$[rsp], 0
  00c8e	0f 84 91 00 00
	00		 je	 $LN95@console_co

; 3736 :                     {
; 3737 :                         // "Error in function create_thread(): %s"
; 3738 :                         WRMSG( HHC00102, "E", strerror( rc ));

  00c94	8b 4c 24 74	 mov	 ecx, DWORD PTR rc$[rsp]
  00c98	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_strerror
  00c9e	48 89 84 24 00
	01 00 00	 mov	 QWORD PTR tv583[rsp], rax
  00ca6	b9 01 00 00 00	 mov	 ecx, 1
  00cab	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  00cb1	48 8b 8c 24 00
	01 00 00	 mov	 rcx, QWORD PTR tv583[rsp]
  00cb9	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  00cbe	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG179431
  00cc5	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  00cca	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG179432
  00cd1	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00cd6	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00cdb	41 b9 03 00 00
	00		 mov	 r9d, 3
  00ce1	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG179433
  00ce8	ba 9a 0e 00 00	 mov	 edx, 3738		; 00000e9aH
  00ced	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG179434
  00cf4	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 3739 : 
; 3740 :                         telnet_free( tn->ctl );

  00cfa	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR tn$[rsp]
  00d02	48 8b 88 98 00
	00 00		 mov	 rcx, QWORD PTR [rax+152]
  00d09	e8 00 00 00 00	 call	 telnet_free

; 3741 :                         free( tn );

  00d0e	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR tn$[rsp]
  00d16	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free

; 3742 :                         telnet_closesocket( csock );

  00d1c	8b 4c 24 78	 mov	 ecx, DWORD PTR csock$[rsp]
  00d20	e8 00 00 00 00	 call	 telnet_closesocket
$LN95@console_co:
$LN94@console_co:
$LN92@console_co:
$LN80@console_co:

; 3743 :                     }
; 3744 :                 }
; 3745 :             }
; 3746 :         } /* end accept incoming client connections */
; 3747 : 
; 3748 :         /* Initialize scan flags */
; 3749 :         scan_complete = TRUE;

  00d25	c7 44 24 64 01
	00 00 00	 mov	 DWORD PTR scan_complete$[rsp], 1

; 3750 :         scan_retries = 0;

  00d2d	c7 44 24 60 00
	00 00 00	 mov	 DWORD PTR scan_retries$[rsp], 0
$LN31@console_co:

; 3751 : 
; 3752 :         /* Check connected consoles for available data */
; 3753 :         for (;;)
; 3754 :         {
; 3755 :             /* FIXME: Incorrectly running chain that may have a DEVBLK
; 3756 :              *        removed while in flight. For example, a device may
; 3757 :              *        be deleted between the loading of the nextdev and
; 3758 :              *        before the check for dev != NULL. This will result
; 3759 :              *        in an invalid storage reference and may result in
; 3760 :              *        a crash.
; 3761 :              */
; 3762 :             for (dev = sysblk.firstdev; dev != NULL; dev = dev->nextdev)

  00d35	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00d3c	48 8b 80 c0 11
	00 00		 mov	 rax, QWORD PTR [rax+4544]
  00d43	48 89 44 24 50	 mov	 QWORD PTR dev$[rsp], rax
  00d48	eb 0e		 jmp	 SHORT $LN36@console_co
$LN34@console_co:
  00d4a	48 8b 44 24 50	 mov	 rax, QWORD PTR dev$[rsp]
  00d4f	48 8b 40 30	 mov	 rax, QWORD PTR [rax+48]
  00d53	48 89 44 24 50	 mov	 QWORD PTR dev$[rsp], rax
$LN36@console_co:
  00d58	48 83 7c 24 50
	00		 cmp	 QWORD PTR dev$[rsp], 0
  00d5e	0f 84 1a 03 00
	00		 je	 $LN35@console_co

; 3763 :             {
; 3764 :                 /* Skip devices which aren't valid connected consoles */
; 3765 :                 if (0
; 3766 :                     || !dev->allocated
; 3767 :                     || !dev->console
; 3768 :                     || !dev->connected

  00d64	33 c0		 xor	 eax, eax
  00d66	85 c0		 test	 eax, eax
  00d68	75 35		 jne	 SHORT $LN97@console_co
  00d6a	48 8b 44 24 50	 mov	 rax, QWORD PTR dev$[rsp]
  00d6f	83 78 40 00	 cmp	 DWORD PTR [rax+64], 0
  00d73	74 2a		 je	 SHORT $LN97@console_co
  00d75	48 8b 44 24 50	 mov	 rax, QWORD PTR dev$[rsp]
  00d7a	8b 80 f8 05 00
	00		 mov	 eax, DWORD PTR [rax+1528]
  00d80	c1 e8 04	 shr	 eax, 4
  00d83	83 e0 01	 and	 eax, 1
  00d86	85 c0		 test	 eax, eax
  00d88	74 15		 je	 SHORT $LN97@console_co
  00d8a	48 8b 44 24 50	 mov	 rax, QWORD PTR dev$[rsp]
  00d8f	8b 80 f8 05 00
	00		 mov	 eax, DWORD PTR [rax+1528]
  00d95	c1 e8 05	 shr	 eax, 5
  00d98	83 e0 01	 and	 eax, 1
  00d9b	85 c0		 test	 eax, eax
  00d9d	75 02		 jne	 SHORT $LN96@console_co
$LN97@console_co:

; 3769 :                 )
; 3770 :                     continue;

  00d9f	eb a9		 jmp	 SHORT $LN34@console_co
$LN96@console_co:

; 3771 : 
; 3772 :                 /* Try to obtain the device lock */
; 3773 :                 if (try_obtain_lock( &dev->lock ))

  00da1	48 8b 44 24 50	 mov	 rax, QWORD PTR dev$[rsp]
  00da6	48 83 c0 38	 add	 rax, 56			; 00000038H
  00daa	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG179438
  00db1	48 8b c8	 mov	 rcx, rax
  00db4	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_try_obtain_lock
  00dba	85 c0		 test	 eax, eax
  00dbc	74 2d		 je	 SHORT $LN98@console_co

; 3774 :                 {
; 3775 :                     /* Unable to obtain device lock. Abort current scan
; 3776 :                        and retry our device block scan again if we have
; 3777 :                        not yet reached our retry limit. Otherwise if we
; 3778 :                        have reached our retry limit, do a normal obtain
; 3779 :                        to wait for the lock since the sched_yield we did
; 3780 :                        further below failed to accomplish what we hoped.
; 3781 :                     */
; 3782 :                     if (scan_retries < 10)

  00dbe	83 7c 24 60 0a	 cmp	 DWORD PTR scan_retries$[rsp], 10
  00dc3	7d 0d		 jge	 SHORT $LN99@console_co

; 3783 :                     {
; 3784 :                         /* Try the scan over again from the beginning */
; 3785 :                         scan_complete = FALSE;

  00dc5	c7 44 24 64 00
	00 00 00	 mov	 DWORD PTR scan_complete$[rsp], 0

; 3786 :                         break;

  00dcd	e9 ac 02 00 00	 jmp	 $LN35@console_co
$LN99@console_co:

; 3787 :                     }
; 3788 : 
; 3789 :                     /* Our sched_yield that we do when our retry limit
; 3790 :                        is reached failed to accomplish our objective.
; 3791 :                        Do a normal obtain_lock to wait forever for the
; 3792 :                        lock to be acquired.
; 3793 :                     */
; 3794 :                     obtain_lock( &dev->lock );

  00dd2	48 8b 44 24 50	 mov	 rax, QWORD PTR dev$[rsp]
  00dd7	48 83 c0 38	 add	 rax, 56			; 00000038H
  00ddb	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG179440
  00de2	48 8b c8	 mov	 rcx, rax
  00de5	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_obtain_lock
$LN98@console_co:

; 3795 :                 }
; 3796 : 
; 3797 :                 /* Test for valid connected console with data available.
; 3798 :                  * Note this test must be done with the device lock held.
; 3799 :                  */
; 3800 :                 if (0
; 3801 :                     || !dev->allocated
; 3802 :                     || !dev->console
; 3803 :                     || !dev->connected
; 3804 :                     || (dev->busy && !(dev->scsw.flag3 & SCSW3_AC_SUSP))
; 3805 :                     || (dev->scsw.flag3 & SCSW3_SC_PEND)
; 3806 :                     || IOPENDING( dev )
; 3807 :                     || !FD_ISSET( dev->fd, &readset )
; 3808 :                     || sysblk.cnslpipe_flag

  00deb	33 c0		 xor	 eax, eax
  00ded	85 c0		 test	 eax, eax
  00def	0f 85 05 01 00
	00		 jne	 $LN101@console_co
  00df5	48 8b 44 24 50	 mov	 rax, QWORD PTR dev$[rsp]
  00dfa	83 78 40 00	 cmp	 DWORD PTR [rax+64], 0
  00dfe	0f 84 f6 00 00
	00		 je	 $LN101@console_co
  00e04	48 8b 44 24 50	 mov	 rax, QWORD PTR dev$[rsp]
  00e09	8b 80 f8 05 00
	00		 mov	 eax, DWORD PTR [rax+1528]
  00e0f	c1 e8 04	 shr	 eax, 4
  00e12	83 e0 01	 and	 eax, 1
  00e15	85 c0		 test	 eax, eax
  00e17	0f 84 dd 00 00
	00		 je	 $LN101@console_co
  00e1d	48 8b 44 24 50	 mov	 rax, QWORD PTR dev$[rsp]
  00e22	8b 80 f8 05 00
	00		 mov	 eax, DWORD PTR [rax+1528]
  00e28	c1 e8 05	 shr	 eax, 5
  00e2b	83 e0 01	 and	 eax, 1
  00e2e	85 c0		 test	 eax, eax
  00e30	0f 84 c4 00 00
	00		 je	 $LN101@console_co
  00e36	48 8b 44 24 50	 mov	 rax, QWORD PTR dev$[rsp]
  00e3b	8b 80 f8 05 00
	00		 mov	 eax, DWORD PTR [rax+1528]
  00e41	c1 e8 13	 shr	 eax, 19
  00e44	83 e0 01	 and	 eax, 1
  00e47	85 c0		 test	 eax, eax
  00e49	74 17		 je	 SHORT $LN102@console_co
  00e4b	48 8b 44 24 50	 mov	 rax, QWORD PTR dev$[rsp]
  00e50	0f b6 80 0b 03
	00 00		 movzx	 eax, BYTE PTR [rax+779]
  00e57	83 e0 20	 and	 eax, 32			; 00000020H
  00e5a	85 c0		 test	 eax, eax
  00e5c	0f 84 98 00 00
	00		 je	 $LN101@console_co
$LN102@console_co:
  00e62	48 8b 44 24 50	 mov	 rax, QWORD PTR dev$[rsp]
  00e67	0f b6 80 0b 03
	00 00		 movzx	 eax, BYTE PTR [rax+779]
  00e6e	83 e0 01	 and	 eax, 1
  00e71	85 c0		 test	 eax, eax
  00e73	0f 85 81 00 00
	00		 jne	 $LN101@console_co
  00e79	48 8b 44 24 50	 mov	 rax, QWORD PTR dev$[rsp]
  00e7e	8b 80 f8 05 00
	00		 mov	 eax, DWORD PTR [rax+1528]
  00e84	c1 e8 16	 shr	 eax, 22
  00e87	83 e0 01	 and	 eax, 1
  00e8a	85 c0		 test	 eax, eax
  00e8c	75 6c		 jne	 SHORT $LN101@console_co
  00e8e	48 8b 44 24 50	 mov	 rax, QWORD PTR dev$[rsp]
  00e93	8b 80 f8 05 00
	00		 mov	 eax, DWORD PTR [rax+1528]
  00e99	c1 e8 17	 shr	 eax, 23
  00e9c	83 e0 01	 and	 eax, 1
  00e9f	85 c0		 test	 eax, eax
  00ea1	75 57		 jne	 SHORT $LN101@console_co
  00ea3	48 8b 44 24 50	 mov	 rax, QWORD PTR dev$[rsp]
  00ea8	8b 80 f8 05 00
	00		 mov	 eax, DWORD PTR [rax+1528]
  00eae	c1 e8 18	 shr	 eax, 24
  00eb1	83 e0 01	 and	 eax, 1
  00eb4	85 c0		 test	 eax, eax
  00eb6	75 42		 jne	 SHORT $LN101@console_co
  00eb8	48 8b 44 24 50	 mov	 rax, QWORD PTR dev$[rsp]
  00ebd	8b 80 f8 05 00
	00		 mov	 eax, DWORD PTR [rax+1528]
  00ec3	c1 e8 1b	 shr	 eax, 27
  00ec6	83 e0 01	 and	 eax, 1
  00ec9	85 c0		 test	 eax, eax
  00ecb	75 2d		 jne	 SHORT $LN101@console_co
  00ecd	48 8d 94 24 10
	01 00 00	 lea	 rdx, QWORD PTR readset$[rsp]
  00ed5	48 8b 44 24 50	 mov	 rax, QWORD PTR dev$[rsp]
  00eda	8b 88 ac 01 00
	00		 mov	 ecx, DWORD PTR [rax+428]
  00ee0	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_FD_ISSET
  00ee6	85 c0		 test	 eax, eax
  00ee8	74 10		 je	 SHORT $LN101@console_co
  00eea	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00ef1	83 b8 c8 10 00
	00 00		 cmp	 DWORD PTR [rax+4296], 0
  00ef8	74 1e		 je	 SHORT $LN100@console_co
$LN101@console_co:

; 3809 :                 )
; 3810 :                 {
; 3811 :                     release_lock( &dev->lock );

  00efa	48 8b 44 24 50	 mov	 rax, QWORD PTR dev$[rsp]
  00eff	48 83 c0 38	 add	 rax, 56			; 00000038H
  00f03	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG179444
  00f0a	48 8b c8	 mov	 rcx, rax
  00f0d	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_release_lock

; 3812 :                     continue;

  00f13	e9 32 fe ff ff	 jmp	 $LN34@console_co
$LN100@console_co:

; 3813 :                 }
; 3814 : 
; 3815 :                 consio();

  00f18	e8 00 00 00 00	 call	 consio

; 3816 : 
; 3817 :                 /* Receive console input data from the client */
; 3818 : 
; 3819 :                 /* Make the first call to recv below non-blocking
; 3820 :                    in case pselect lied to us and there isn't any
; 3821 :                    data available.  If we do multiple recv's then
; 3822 :                    the subsequent ones are blocking. See the linux
; 3823 :                    man page for select(2) for more info.
; 3824 :                 */
; 3825 :                 socket_set_blocking_mode( dev->fd, 0 );

  00f1d	33 d2		 xor	 edx, edx
  00f1f	48 8b 44 24 50	 mov	 rax, QWORD PTR dev$[rsp]
  00f24	8b 88 ac 01 00
	00		 mov	 ecx, DWORD PTR [rax+428]
  00f2a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_socket_set_blocking_mode

; 3826 :                 if ((dev->devtype == 0x3270) ||

  00f30	48 8b 44 24 50	 mov	 rax, QWORD PTR dev$[rsp]
  00f35	0f b7 40 4a	 movzx	 eax, WORD PTR [rax+74]
  00f39	3d 70 32 00 00	 cmp	 eax, 12912		; 00003270H
  00f3e	74 10		 je	 SHORT $LN105@console_co
  00f40	48 8b 44 24 50	 mov	 rax, QWORD PTR dev$[rsp]
  00f45	0f b7 40 4a	 movzx	 eax, WORD PTR [rax+74]
  00f49	3d 87 32 00 00	 cmp	 eax, 12935		; 00003287H
  00f4e	75 6a		 jne	 SHORT $LN103@console_co
$LN105@console_co:
$LN39@console_co:

; 3827 :                     (dev->devtype == 0x3287))
; 3828 :                 {
; 3829 :                     do
; 3830 :                         {
; 3831 :                             prev_rlen3270 = dev->rlen3270;

  00f50	48 8b 44 24 50	 mov	 rax, QWORD PTR dev$[rsp]
  00f55	8b 80 b8 06 00
	00		 mov	 eax, DWORD PTR [rax+1720]
  00f5b	89 84 24 dc 00
	00 00		 mov	 DWORD PTR prev_rlen3270$[rsp], eax

; 3832 :                             unitstat = recv_3270_data( dev );

  00f62	48 8b 4c 24 50	 mov	 rcx, QWORD PTR dev$[rsp]
  00f67	e8 00 00 00 00	 call	 recv_3270_data
  00f6c	88 44 24 58	 mov	 BYTE PTR unitstat$[rsp], al

; 3833 : 
; 3834 :                             // "%s COMM: recv_3270_data: %d bytes received"
; 3835 :                             CONDEBUG2( HHC90502, "D", dev->tn->clientid,
; 3836 :                                 dev->rlen3270 - prev_rlen3270 );
; 3837 :                             /* If we do another recv, make it blocking.
; 3838 :                                Otherwise we might just spin. */
; 3839 :                             socket_set_blocking_mode( dev->fd, 1 );

  00f70	ba 01 00 00 00	 mov	 edx, 1
  00f75	48 8b 44 24 50	 mov	 rax, QWORD PTR dev$[rsp]
  00f7a	8b 88 ac 01 00
	00		 mov	 ecx, DWORD PTR [rax+428]
  00f80	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_socket_set_blocking_mode

; 3840 :                         }
; 3841 :                         while ((unitstat == 0) && dev->rlen3270);

  00f86	0f b6 44 24 58	 movzx	 eax, BYTE PTR unitstat$[rsp]
  00f8b	85 c0		 test	 eax, eax
  00f8d	75 0e		 jne	 SHORT $LN106@console_co
  00f8f	48 8b 44 24 50	 mov	 rax, QWORD PTR dev$[rsp]
  00f94	83 b8 b8 06 00
	00 00		 cmp	 DWORD PTR [rax+1720], 0
  00f9b	75 b3		 jne	 SHORT $LN39@console_co
$LN106@console_co:

; 3842 : 
; 3843 :                     dev->readpending = 3;

  00f9d	48 8b 44 24 50	 mov	 rax, QWORD PTR dev$[rsp]
  00fa2	8b 80 f8 05 00
	00		 mov	 eax, DWORD PTR [rax+1528]
  00fa8	0d c0 00 00 00	 or	 eax, 192		; 000000c0H
  00fad	48 8b 4c 24 50	 mov	 rcx, QWORD PTR dev$[rsp]
  00fb2	89 81 f8 05 00
	00		 mov	 DWORD PTR [rcx+1528], eax

; 3844 :                 }

  00fb8	eb 24		 jmp	 SHORT $LN104@console_co
$LN103@console_co:

; 3845 :                 else
; 3846 :                 {
; 3847 :                     unitstat = recv_1052_data( dev );

  00fba	48 8b 4c 24 50	 mov	 rcx, QWORD PTR dev$[rsp]
  00fbf	e8 00 00 00 00	 call	 recv_1052_data
  00fc4	88 44 24 58	 mov	 BYTE PTR unitstat$[rsp], al

; 3848 :                     socket_set_blocking_mode( dev->fd, 1 );

  00fc8	ba 01 00 00 00	 mov	 edx, 1
  00fcd	48 8b 44 24 50	 mov	 rax, QWORD PTR dev$[rsp]
  00fd2	8b 88 ac 01 00
	00		 mov	 ecx, DWORD PTR [rax+428]
  00fd8	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_socket_set_blocking_mode
$LN104@console_co:

; 3849 :                 }
; 3850 : 
; 3851 :                 /* Close the connection if an error occurred */
; 3852 :                 if (unitstat & CSW_UC)

  00fde	0f b6 44 24 58	 movzx	 eax, BYTE PTR unitstat$[rsp]
  00fe3	83 e0 02	 and	 eax, 2
  00fe6	85 c0		 test	 eax, eax
  00fe8	74 28		 je	 SHORT $LN107@console_co

; 3853 :                 {
; 3854 :                     disconnect_console_device( dev );

  00fea	48 8b 4c 24 50	 mov	 rcx, QWORD PTR dev$[rsp]
  00fef	e8 00 00 00 00	 call	 disconnect_console_device

; 3855 :                     release_lock( &dev->lock );

  00ff4	48 8b 44 24 50	 mov	 rax, QWORD PTR dev$[rsp]
  00ff9	48 83 c0 38	 add	 rax, 56			; 00000038H
  00ffd	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG179450
  01004	48 8b c8	 mov	 rcx, rax
  01007	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_release_lock

; 3856 :                     continue;

  0100d	e9 38 fd ff ff	 jmp	 $LN34@console_co
$LN107@console_co:

; 3857 :                 }
; 3858 : 
; 3859 :                 /* Release the device lock */
; 3860 :                 release_lock( &dev->lock );

  01012	48 8b 44 24 50	 mov	 rax, QWORD PTR dev$[rsp]
  01017	48 83 c0 38	 add	 rax, 56			; 00000038H
  0101b	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG179451
  01022	48 8b c8	 mov	 rcx, rax
  01025	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_release_lock

; 3861 : 
; 3862 :                 if ((dev->devtype != 0x3270) &&

  0102b	48 8b 44 24 50	 mov	 rax, QWORD PTR dev$[rsp]
  01030	0f b7 40 4a	 movzx	 eax, WORD PTR [rax+74]
  01034	3d 70 32 00 00	 cmp	 eax, 12912		; 00003270H
  01039	74 21		 je	 SHORT $LN108@console_co
  0103b	48 8b 44 24 50	 mov	 rax, QWORD PTR dev$[rsp]
  01040	0f b7 40 4a	 movzx	 eax, WORD PTR [rax+74]
  01044	3d 87 32 00 00	 cmp	 eax, 12935		; 00003287H
  01049	74 11		 je	 SHORT $LN108@console_co

; 3863 :                     (dev->devtype != 0x3287))
; 3864 :                     raise_device_attention( dev, unitstat );

  0104b	0f b6 54 24 58	 movzx	 edx, BYTE PTR unitstat$[rsp]
  01050	48 8b 4c 24 50	 mov	 rcx, QWORD PTR dev$[rsp]
  01055	e8 00 00 00 00	 call	 raise_device_attention
  0105a	eb 1d		 jmp	 SHORT $LN109@console_co
$LN108@console_co:

; 3865 :                 else
; 3866 :                 /* Raise attention interrupt for device, but only
; 3867 :                    if we actually received any 3270 data.  Telnet
; 3868 :                    keepalive messages for example, arrive as pure
; 3869 :                    telnet control messages which, once processed,
; 3870 :                    result in no actual 3270 client data remaining.
; 3871 :                 */
; 3872 :                 if (dev->rlen3270)

  0105c	48 8b 44 24 50	 mov	 rax, QWORD PTR dev$[rsp]
  01061	83 b8 b8 06 00
	00 00		 cmp	 DWORD PTR [rax+1720], 0
  01068	74 0f		 je	 SHORT $LN110@console_co

; 3873 :                     raise_device_attention( dev, unitstat );

  0106a	0f b6 54 24 58	 movzx	 edx, BYTE PTR unitstat$[rsp]
  0106f	48 8b 4c 24 50	 mov	 rcx, QWORD PTR dev$[rsp]
  01074	e8 00 00 00 00	 call	 raise_device_attention
$LN110@console_co:
$LN109@console_co:

; 3874 : 
; 3875 :             } /* end scan DEVBLK chain */

  01079	e9 cc fc ff ff	 jmp	 $LN34@console_co
$LN35@console_co:

; 3876 : 
; 3877 :             /* Entire DEVBLK chain scanned without any problems? */
; 3878 :             if (scan_complete)

  0107e	83 7c 24 64 00	 cmp	 DWORD PTR scan_complete$[rsp], 0
  01083	74 02		 je	 SHORT $LN111@console_co

; 3879 :                 break;

  01085	eb 24		 jmp	 SHORT $LN32@console_co
$LN111@console_co:

; 3880 : 
; 3881 :             /* Lock conflict; wait a moment before trying again */
; 3882 :             if (++scan_retries >= 10)

  01087	8b 44 24 60	 mov	 eax, DWORD PTR scan_retries$[rsp]
  0108b	ff c0		 inc	 eax
  0108d	89 44 24 60	 mov	 DWORD PTR scan_retries$[rsp], eax
  01091	83 7c 24 60 0a	 cmp	 DWORD PTR scan_retries$[rsp], 10
  01096	7c 06		 jl	 SHORT $LN112@console_co

; 3883 :                 sched_yield();

  01098	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_sched_yield
$LN112@console_co:

; 3884 : 
; 3885 :             /* Reset scan flag and try again */
; 3886 :             scan_complete = TRUE;

  0109e	c7 44 24 64 01
	00 00 00	 mov	 DWORD PTR scan_complete$[rsp], 1

; 3887 : 
; 3888 :         } /* end for(;;) check connected consoles for available data */

  010a6	e9 8a fc ff ff	 jmp	 $LN31@console_co
$LN32@console_co:

; 3889 : 
; 3890 :     } /* end while (console_cnslcnt > 0) */

  010ab	e9 00 f1 ff ff	 jmp	 $LN126@console_co
$LN6@console_co:

; 3891 : 
; 3892 :     free( curr_cnslport );

  010b0	48 8b 8c 24 a8
	00 00 00	 mov	 rcx, QWORD PTR curr_cnslport$[rsp]
  010b8	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free

; 3893 :     free( curr_sysgport );

  010be	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR curr_sysgport$[rsp]
  010c6	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free

; 3894 : 
; 3895 :     /* Initialize scan flags */
; 3896 :     scan_complete = TRUE;

  010cc	c7 44 24 64 01
	00 00 00	 mov	 DWORD PTR scan_complete$[rsp], 1

; 3897 :     scan_retries = 0;

  010d4	c7 44 24 60 00
	00 00 00	 mov	 DWORD PTR scan_retries$[rsp], 0
$LN40@console_co:

; 3898 : 
; 3899 :     /* Close all connected consoles */
; 3900 :     for (;;)
; 3901 :     {
; 3902 :         /* FIXME: Incorrectly running chain that may have a DEVBLK
; 3903 :          *        removed while in flight. For example, a device may
; 3904 :          *        be deleted between the loading of the nextdev and
; 3905 :          *        before the check for dev != NULL. This will result
; 3906 :          *        in an invalid storage reference and may result in a
; 3907 :          *        crash.
; 3908 :          */
; 3909 :         for (dev = sysblk.firstdev; dev != NULL; dev = dev->nextdev)

  010dc	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  010e3	48 8b 80 c0 11
	00 00		 mov	 rax, QWORD PTR [rax+4544]
  010ea	48 89 44 24 50	 mov	 QWORD PTR dev$[rsp], rax
  010ef	eb 0e		 jmp	 SHORT $LN45@console_co
$LN43@console_co:
  010f1	48 8b 44 24 50	 mov	 rax, QWORD PTR dev$[rsp]
  010f6	48 8b 40 30	 mov	 rax, QWORD PTR [rax+48]
  010fa	48 89 44 24 50	 mov	 QWORD PTR dev$[rsp], rax
$LN45@console_co:
  010ff	48 83 7c 24 50
	00		 cmp	 QWORD PTR dev$[rsp], 0
  01105	0f 84 ab 00 00
	00		 je	 $LN44@console_co

; 3910 :         {
; 3911 :             /* Try to obtain the device lock */
; 3912 :             if (try_obtain_lock( &dev->lock ))

  0110b	48 8b 44 24 50	 mov	 rax, QWORD PTR dev$[rsp]
  01110	48 83 c0 38	 add	 rax, 56			; 00000038H
  01114	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG179458
  0111b	48 8b c8	 mov	 rcx, rax
  0111e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_try_obtain_lock
  01124	85 c0		 test	 eax, eax
  01126	74 2a		 je	 SHORT $LN113@console_co

; 3913 :             {
; 3914 :                 /* Unable to obtain device lock. Abort current scan
; 3915 :                    and retry our device block scan again if we have
; 3916 :                    not yet reached our retry limit. Otherwise if we
; 3917 :                    have reached our retry limit, do a normal obtain
; 3918 :                    to wait for the lock since the sched_yield we did
; 3919 :                    further below failed to accomplish what we hoped.
; 3920 :                 */
; 3921 :                 if (scan_retries < 10)

  01128	83 7c 24 60 0a	 cmp	 DWORD PTR scan_retries$[rsp], 10
  0112d	7d 0a		 jge	 SHORT $LN114@console_co

; 3922 :                 {
; 3923 :                     /* Try the scan over again from the beginning */
; 3924 :                     scan_complete = FALSE;

  0112f	c7 44 24 64 00
	00 00 00	 mov	 DWORD PTR scan_complete$[rsp], 0

; 3925 :                     break;

  01137	eb 7d		 jmp	 SHORT $LN44@console_co
$LN114@console_co:

; 3926 :                 }
; 3927 : 
; 3928 :                 /* Our sched_yield that we do when our retry limit
; 3929 :                    is reached failed to accomplish our objective.
; 3930 :                    Do a normal obtain_lock to wait forever for the
; 3931 :                    lock to be acquired.
; 3932 :                 */
; 3933 :                 obtain_lock( &dev->lock );

  01139	48 8b 44 24 50	 mov	 rax, QWORD PTR dev$[rsp]
  0113e	48 83 c0 38	 add	 rax, 56			; 00000038H
  01142	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG179460
  01149	48 8b c8	 mov	 rcx, rax
  0114c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_obtain_lock
$LN113@console_co:

; 3934 :             }
; 3935 : 
; 3936 :             /* Close console if still connected */
; 3937 :             if (1
; 3938 :                 && dev->allocated
; 3939 :                 && dev->console
; 3940 :                 && dev->connected

  01152	33 c0		 xor	 eax, eax
  01154	83 f8 01	 cmp	 eax, 1
  01157	74 3f		 je	 SHORT $LN115@console_co
  01159	48 8b 44 24 50	 mov	 rax, QWORD PTR dev$[rsp]
  0115e	83 78 40 00	 cmp	 DWORD PTR [rax+64], 0
  01162	74 34		 je	 SHORT $LN115@console_co
  01164	48 8b 44 24 50	 mov	 rax, QWORD PTR dev$[rsp]
  01169	8b 80 f8 05 00
	00		 mov	 eax, DWORD PTR [rax+1528]
  0116f	c1 e8 04	 shr	 eax, 4
  01172	83 e0 01	 and	 eax, 1
  01175	85 c0		 test	 eax, eax
  01177	74 1f		 je	 SHORT $LN115@console_co
  01179	48 8b 44 24 50	 mov	 rax, QWORD PTR dev$[rsp]
  0117e	8b 80 f8 05 00
	00		 mov	 eax, DWORD PTR [rax+1528]
  01184	c1 e8 05	 shr	 eax, 5
  01187	83 e0 01	 and	 eax, 1
  0118a	85 c0		 test	 eax, eax
  0118c	74 0a		 je	 SHORT $LN115@console_co

; 3941 :             )
; 3942 :                 disconnect_console_device( dev );

  0118e	48 8b 4c 24 50	 mov	 rcx, QWORD PTR dev$[rsp]
  01193	e8 00 00 00 00	 call	 disconnect_console_device
$LN115@console_co:

; 3943 : 
; 3944 :             /* Release the device lock */
; 3945 :             release_lock( &dev->lock );

  01198	48 8b 44 24 50	 mov	 rax, QWORD PTR dev$[rsp]
  0119d	48 83 c0 38	 add	 rax, 56			; 00000038H
  011a1	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG179462
  011a8	48 8b c8	 mov	 rcx, rax
  011ab	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_release_lock

; 3946 : 
; 3947 :         } /* end scan DEVBLK chain */

  011b1	e9 3b ff ff ff	 jmp	 $LN43@console_co
$LN44@console_co:

; 3948 : 
; 3949 :         /* Entire DEVBLK chain scanned without any problems? */
; 3950 :         if (scan_complete)

  011b6	83 7c 24 64 00	 cmp	 DWORD PTR scan_complete$[rsp], 0
  011bb	74 02		 je	 SHORT $LN116@console_co

; 3951 :             break;

  011bd	eb 24		 jmp	 SHORT $LN41@console_co
$LN116@console_co:

; 3952 : 
; 3953 :         /* Lock conflict; wait a moment before trying again */
; 3954 :         if (++scan_retries >= 10)

  011bf	8b 44 24 60	 mov	 eax, DWORD PTR scan_retries$[rsp]
  011c3	ff c0		 inc	 eax
  011c5	89 44 24 60	 mov	 DWORD PTR scan_retries$[rsp], eax
  011c9	83 7c 24 60 0a	 cmp	 DWORD PTR scan_retries$[rsp], 10
  011ce	7c 06		 jl	 SHORT $LN117@console_co

; 3955 :             sched_yield();

  011d0	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_sched_yield
$LN117@console_co:

; 3956 : 
; 3957 :         /* Reset scan flag and try again */
; 3958 :         scan_complete = TRUE;

  011d6	c7 44 24 64 01
	00 00 00	 mov	 DWORD PTR scan_complete$[rsp], 1

; 3959 : 
; 3960 :     } /* end close all connected consoles */

  011de	e9 f9 fe ff ff	 jmp	 $LN40@console_co
$LN41@console_co:

; 3961 : 
; 3962 :     /* Close the listening sockets */
; 3963 :     close_socket( lsock  );

  011e3	8b 4c 24 68	 mov	 ecx, DWORD PTR lsock$[rsp]
  011e7	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_close_socket

; 3964 :     if (lsock2) close_socket( lsock2 );

  011ed	83 7c 24 5c 00	 cmp	 DWORD PTR lsock2$[rsp], 0
  011f2	74 0a		 je	 SHORT $LN118@console_co
  011f4	8b 4c 24 5c	 mov	 ecx, DWORD PTR lsock2$[rsp]
  011f8	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_close_socket
$LN118@console_co:

; 3965 : 
; 3966 :     // "Thread id "TIDPAT", prio %2d, name %s ended"
; 3967 :     LOG_THREAD_END( CON_CONN_THREAD_NAME  );

  011fe	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fthread_self
  01204	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG179467
  0120b	8b c8		 mov	 ecx, eax
  0120d	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_get_thread_prio
  01213	89 84 24 b0 00
	00 00		 mov	 DWORD PTR tv759[rsp], eax
  0121a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fthread_self
  01220	89 84 24 b4 00
	00 00		 mov	 DWORD PTR tv764[rsp], eax
  01227	b9 01 00 00 00	 mov	 ecx, 1
  0122c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  01232	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG179466
  01239	48 89 4c 24 48	 mov	 QWORD PTR [rsp+72], rcx
  0123e	8b 8c 24 b0 00
	00 00		 mov	 ecx, DWORD PTR tv759[rsp]
  01245	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  01249	8b 8c 24 b4 00
	00 00		 mov	 ecx, DWORD PTR tv764[rsp]
  01250	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  01254	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG179468
  0125b	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  01260	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG179469
  01267	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  0126c	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  01271	41 b9 03 00 00
	00		 mov	 r9d, 3
  01277	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG179470
  0127e	ba 7f 0f 00 00	 mov	 edx, 3967		; 00000f7fH
  01283	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG179471
  0128a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 3968 : 
; 3969 :     return NULL;

  01290	33 c0		 xor	 eax, eax

; 3970 : 
; 3971 : } /* end function console_connection_handler */

  01292	48 8b 8c 24 20
	21 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  0129a	48 33 cc	 xor	 rcx, rsp
  0129d	e8 00 00 00 00	 call	 __security_check_cookie
  012a2	48 81 c4 38 21
	00 00		 add	 rsp, 8504		; 00002138H
  012a9	c3		 ret	 0
console_connection_handler ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\sr.h
_TEXT	SEGMENT
sr_value_error_ PROC

; 836  : {

  00000	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 837  :     // "SR: value error, incorrect length"
; 838  :     WRMSG(HHC02020, "E");

  00004	b9 01 00 00 00	 mov	 ecx, 1
  00009	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  0000f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG177476
  00016	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  0001b	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG177477
  00022	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00027	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  0002c	41 b9 03 00 00
	00		 mov	 r9d, 3
  00032	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG177478
  00039	ba 46 03 00 00	 mov	 edx, 838		; 00000346H
  0003e	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG177479
  00045	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 839  : }

  0004b	48 83 c4 48	 add	 rsp, 72			; 00000048H
  0004f	c3		 ret	 0
sr_value_error_ ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\sr.h
_TEXT	SEGMENT
tv64 = 80
sr_read_error_ PROC

; 824  : {

  00000	48 83 ec 68	 sub	 rsp, 104		; 00000068H

; 825  :     // "SR: error in function '%s': '%s'"
; 826  :     WRMSG(HHC02001, "E", "read()", strerror(errno));

  00004	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno
  0000a	8b 08		 mov	 ecx, DWORD PTR [rax]
  0000c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_strerror
  00012	48 89 44 24 50	 mov	 QWORD PTR tv64[rsp], rax
  00017	b9 01 00 00 00	 mov	 ecx, 1
  0001c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  00022	48 8b 4c 24 50	 mov	 rcx, QWORD PTR tv64[rsp]
  00027	48 89 4c 24 40	 mov	 QWORD PTR [rsp+64], rcx
  0002c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG177464
  00033	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  00038	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG177465
  0003f	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  00044	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG177466
  0004b	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00050	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00055	41 b9 03 00 00
	00		 mov	 r9d, 3
  0005b	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG177467
  00062	ba 3a 03 00 00	 mov	 edx, 826		; 0000033aH
  00067	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG177468
  0006e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 827  : }

  00074	48 83 c4 68	 add	 rsp, 104		; 00000068H
  00078	c3		 ret	 0
sr_read_error_ ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\sr.h
_TEXT	SEGMENT
tv64 = 80
sr_write_error_ PROC

; 818  : {

  00000	48 83 ec 68	 sub	 rsp, 104		; 00000068H

; 819  :     // "SR: error in function '%s': '%s'"
; 820  :     WRMSG(HHC02001, "E", "write()", strerror(errno));

  00004	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno
  0000a	8b 08		 mov	 ecx, DWORD PTR [rax]
  0000c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_strerror
  00012	48 89 44 24 50	 mov	 QWORD PTR tv64[rsp], rax
  00017	b9 01 00 00 00	 mov	 ecx, 1
  0001c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  00022	48 8b 4c 24 50	 mov	 rcx, QWORD PTR tv64[rsp]
  00027	48 89 4c 24 40	 mov	 QWORD PTR [rsp+64], rcx
  0002c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG177458
  00033	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  00038	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG177459
  0003f	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  00044	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG177460
  0004b	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00050	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00055	41 b9 03 00 00
	00		 mov	 r9d, 3
  0005b	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG177461
  00062	ba 34 03 00 00	 mov	 edx, 820		; 00000334H
  00067	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG177462
  0006e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 821  : }

  00074	48 83 c4 68	 add	 rsp, 104		; 00000068H
  00078	c3		 ret	 0
sr_write_error_ ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\sr.h
_TEXT	SEGMENT
tot$ = 32
siz$ = 40
tv74 = 48
buf$ = 64
__$ArrayPad$ = 320
file$ = 352
len$ = 360
sr_read_skip PROC

; 677  : {

  00000	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00004	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00009	48 81 ec 58 01
	00 00		 sub	 rsp, 344		; 00000158H
  00010	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00017	48 33 c4	 xor	 rax, rsp
  0001a	48 89 84 24 40
	01 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax
$LN4@sr_read_sk:

; 678  : /* FIXME: Workaround for problem involving gzseek
; 679  :           and large files.  Just read the data. */
; 680  : 
; 681  : BYTE    buf[SR_SKIP_CHUNKSIZE];
; 682  : size_t  siz;
; 683  : size_t  tot;
; 684  : 
; 685  :     TRACE("SR: sr_read_skip:                  len=0x%8.8x\n", len);

  00022	8b 94 24 68 01
	00 00		 mov	 edx, DWORD PTR len$[rsp]
  00029	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG177370
  00030	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_logmsg
  00036	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_IsDebuggerPresent
  0003c	85 c0		 test	 eax, eax
  0003e	74 13		 je	 SHORT $LN7@sr_read_sk
  00040	8b 94 24 68 01
	00 00		 mov	 edx, DWORD PTR len$[rsp]
  00047	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG177372
  0004e	e8 00 00 00 00	 call	 DebuggerTrace
$LN7@sr_read_sk:
  00053	33 c0		 xor	 eax, eax
  00055	85 c0		 test	 eax, eax
  00057	75 c9		 jne	 SHORT $LN4@sr_read_sk

; 686  : 
; 687  :     tot = len;

  00059	8b 84 24 68 01
	00 00		 mov	 eax, DWORD PTR len$[rsp]
  00060	48 89 44 24 20	 mov	 QWORD PTR tot$[rsp], rax
$LN5@sr_read_sk:

; 688  : 
; 689  :     while (tot)

  00065	48 83 7c 24 20
	00		 cmp	 QWORD PTR tot$[rsp], 0
  0006b	74 71		 je	 SHORT $LN6@sr_read_sk

; 690  :     {
; 691  :         siz = tot < SR_SKIP_CHUNKSIZE ? tot : SR_SKIP_CHUNKSIZE;

  0006d	48 81 7c 24 20
	00 01 00 00	 cmp	 QWORD PTR tot$[rsp], 256 ; 00000100H
  00076	73 0c		 jae	 SHORT $LN10@sr_read_sk
  00078	48 8b 44 24 20	 mov	 rax, QWORD PTR tot$[rsp]
  0007d	48 89 44 24 30	 mov	 QWORD PTR tv74[rsp], rax
  00082	eb 09		 jmp	 SHORT $LN11@sr_read_sk
$LN10@sr_read_sk:
  00084	48 c7 44 24 30
	00 01 00 00	 mov	 QWORD PTR tv74[rsp], 256 ; 00000100H
$LN11@sr_read_sk:
  0008d	48 8b 44 24 30	 mov	 rax, QWORD PTR tv74[rsp]
  00092	48 89 44 24 28	 mov	 QWORD PTR siz$[rsp], rax

; 692  : 
; 693  :         if ((size_t)SR_READ(buf, 1, siz, file) != siz)

  00097	4c 8b 8c 24 60
	01 00 00	 mov	 r9, QWORD PTR file$[rsp]
  0009f	4c 8b 44 24 28	 mov	 r8, QWORD PTR siz$[rsp]
  000a4	ba 01 00 00 00	 mov	 edx, 1
  000a9	48 8d 4c 24 40	 lea	 rcx, QWORD PTR buf$[rsp]
  000ae	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fread
  000b4	48 3b 44 24 28	 cmp	 rax, QWORD PTR siz$[rsp]
  000b9	74 0c		 je	 SHORT $LN8@sr_read_sk

; 694  :         {
; 695  :             sr_read_error_();

  000bb	e8 00 00 00 00	 call	 sr_read_error_

; 696  :             return -1;

  000c0	b8 ff ff ff ff	 mov	 eax, -1
  000c5	eb 19		 jmp	 SHORT $LN1@sr_read_sk
$LN8@sr_read_sk:

; 697  :         }
; 698  :         tot -= siz;

  000c7	48 8b 44 24 28	 mov	 rax, QWORD PTR siz$[rsp]
  000cc	48 8b 4c 24 20	 mov	 rcx, QWORD PTR tot$[rsp]
  000d1	48 2b c8	 sub	 rcx, rax
  000d4	48 8b c1	 mov	 rax, rcx
  000d7	48 89 44 24 20	 mov	 QWORD PTR tot$[rsp], rax

; 699  :     }

  000dc	eb 87		 jmp	 SHORT $LN5@sr_read_sk
$LN6@sr_read_sk:

; 700  :     return 0;

  000de	33 c0		 xor	 eax, eax
$LN1@sr_read_sk:

; 701  : }

  000e0	48 8b 8c 24 40
	01 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  000e8	48 33 cc	 xor	 rcx, rsp
  000eb	e8 00 00 00 00	 call	 __security_check_cookie
  000f0	48 81 c4 58 01
	00 00		 add	 rsp, 344		; 00000158H
  000f7	c3		 ret	 0
sr_read_skip ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\sr.h
_TEXT	SEGMENT
siz$ = 32
tot$ = 40
buf$ = 48
tv73 = 56
file$ = 80
p$ = 88
len$ = 96
sr_read_buf PROC

; 727  : {

  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 728  : U32    siz;
; 729  : U64    tot  = len;

  00013	48 8b 44 24 60	 mov	 rax, QWORD PTR len$[rsp]
  00018	48 89 44 24 28	 mov	 QWORD PTR tot$[rsp], rax

; 730  : BYTE*  buf  = p;

  0001d	48 8b 44 24 58	 mov	 rax, QWORD PTR p$[rsp]
  00022	48 89 44 24 30	 mov	 QWORD PTR buf$[rsp], rax
$LN4@sr_read_bu:

; 731  : 
; 732  :     TRACE("SR: sr_read_buf:                   len=0x%16.16"PRIx64"\n", len);

  00027	48 8b 54 24 60	 mov	 rdx, QWORD PTR len$[rsp]
  0002c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG177406
  00033	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_logmsg
  00039	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_IsDebuggerPresent
  0003f	85 c0		 test	 eax, eax
  00041	74 11		 je	 SHORT $LN7@sr_read_bu
  00043	48 8b 54 24 60	 mov	 rdx, QWORD PTR len$[rsp]
  00048	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG177408
  0004f	e8 00 00 00 00	 call	 DebuggerTrace
$LN7@sr_read_bu:
  00054	33 c0		 xor	 eax, eax
  00056	85 c0		 test	 eax, eax
  00058	75 cd		 jne	 SHORT $LN4@sr_read_bu
$LN5@sr_read_bu:

; 733  : 
; 734  :     while (tot)

  0005a	48 83 7c 24 28
	00		 cmp	 QWORD PTR tot$[rsp], 0
  00060	0f 84 83 00 00
	00		 je	 $LN6@sr_read_bu

; 735  :     {
; 736  :         siz = tot < SR_BUF_CHUNKSIZE ? tot : SR_BUF_CHUNKSIZE;

  00066	48 81 7c 24 28
	00 00 00 10	 cmp	 QWORD PTR tot$[rsp], 268435456 ; 10000000H
  0006f	73 0c		 jae	 SHORT $LN10@sr_read_bu
  00071	48 8b 44 24 28	 mov	 rax, QWORD PTR tot$[rsp]
  00076	48 89 44 24 38	 mov	 QWORD PTR tv73[rsp], rax
  0007b	eb 09		 jmp	 SHORT $LN11@sr_read_bu
$LN10@sr_read_bu:
  0007d	48 c7 44 24 38
	00 00 00 10	 mov	 QWORD PTR tv73[rsp], 268435456 ; 10000000H
$LN11@sr_read_bu:
  00086	8b 44 24 38	 mov	 eax, DWORD PTR tv73[rsp]
  0008a	89 44 24 20	 mov	 DWORD PTR siz$[rsp], eax

; 737  : 
; 738  :         if ((U32)SR_READ(buf, 1, siz, file) != siz)

  0008e	8b 44 24 20	 mov	 eax, DWORD PTR siz$[rsp]
  00092	4c 8b 4c 24 50	 mov	 r9, QWORD PTR file$[rsp]
  00097	44 8b c0	 mov	 r8d, eax
  0009a	ba 01 00 00 00	 mov	 edx, 1
  0009f	48 8b 4c 24 30	 mov	 rcx, QWORD PTR buf$[rsp]
  000a4	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fread
  000aa	3b 44 24 20	 cmp	 eax, DWORD PTR siz$[rsp]
  000ae	74 0c		 je	 SHORT $LN8@sr_read_bu

; 739  :         {
; 740  :             sr_read_error_();

  000b0	e8 00 00 00 00	 call	 sr_read_error_

; 741  :             return -1;

  000b5	b8 ff ff ff ff	 mov	 eax, -1
  000ba	eb 2f		 jmp	 SHORT $LN1@sr_read_bu
$LN8@sr_read_bu:

; 742  :         }
; 743  :         tot -= siz;

  000bc	8b 44 24 20	 mov	 eax, DWORD PTR siz$[rsp]
  000c0	48 8b 4c 24 28	 mov	 rcx, QWORD PTR tot$[rsp]
  000c5	48 2b c8	 sub	 rcx, rax
  000c8	48 8b c1	 mov	 rax, rcx
  000cb	48 89 44 24 28	 mov	 QWORD PTR tot$[rsp], rax

; 744  :         buf += siz;

  000d0	8b 44 24 20	 mov	 eax, DWORD PTR siz$[rsp]
  000d4	48 8b 4c 24 30	 mov	 rcx, QWORD PTR buf$[rsp]
  000d9	48 03 c8	 add	 rcx, rax
  000dc	48 8b c1	 mov	 rax, rcx
  000df	48 89 44 24 30	 mov	 QWORD PTR buf$[rsp], rax

; 745  :     }

  000e4	e9 71 ff ff ff	 jmp	 $LN5@sr_read_bu
$LN6@sr_read_bu:

; 746  : 
; 747  :     return 0;

  000e9	33 c0		 xor	 eax, eax
$LN1@sr_read_bu:

; 748  : }

  000eb	48 83 c4 48	 add	 rsp, 72			; 00000048H
  000ef	c3		 ret	 0
sr_read_buf ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\sr.h
_TEXT	SEGMENT
value$ = 32
tv85 = 40
tv146 = 44
ptr$1 = 48
ptr$2 = 56
ptr$3 = 64
ptr$4 = 72
buf$ = 80
__$ArrayPad$ = 88
file$ = 112
suslen$ = 120
p$ = 128
reslen$ = 136
sr_read_value PROC

; 754  : {

  00000	44 89 4c 24 20	 mov	 DWORD PTR [rsp+32], r9d
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  0000e	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00013	48 83 ec 68	 sub	 rsp, 104		; 00000068H
  00017	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  0001e	48 33 c4	 xor	 rax, rsp
  00021	48 89 44 24 58	 mov	 QWORD PTR __$ArrayPad$[rsp], rax
$LN4@sr_read_va:

; 755  : BYTE    buf[8];
; 756  : U64     value;
; 757  : 
; 758  :     TRACE("SR: sr_read_value:              suslen=0x%8.8x, reslen=0x%8.8x,\n", suslen, reslen);

  00026	44 8b 84 24 88
	00 00 00	 mov	 r8d, DWORD PTR reslen$[rsp]
  0002e	8b 54 24 78	 mov	 edx, DWORD PTR suslen$[rsp]
  00032	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG177440
  00039	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_logmsg
  0003f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_IsDebuggerPresent
  00045	85 c0		 test	 eax, eax
  00047	74 18		 je	 SHORT $LN12@sr_read_va
  00049	44 8b 84 24 88
	00 00 00	 mov	 r8d, DWORD PTR reslen$[rsp]
  00051	8b 54 24 78	 mov	 edx, DWORD PTR suslen$[rsp]
  00055	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG177442
  0005c	e8 00 00 00 00	 call	 DebuggerTrace
$LN12@sr_read_va:
  00061	33 c0		 xor	 eax, eax
  00063	85 c0		 test	 eax, eax
  00065	75 bf		 jne	 SHORT $LN4@sr_read_va

; 759  : 
; 760  :     if (suslen != 1 && suslen != 2 && suslen != 4 && suslen != 8)

  00067	83 7c 24 78 01	 cmp	 DWORD PTR suslen$[rsp], 1
  0006c	74 24		 je	 SHORT $LN13@sr_read_va
  0006e	83 7c 24 78 02	 cmp	 DWORD PTR suslen$[rsp], 2
  00073	74 1d		 je	 SHORT $LN13@sr_read_va
  00075	83 7c 24 78 04	 cmp	 DWORD PTR suslen$[rsp], 4
  0007a	74 16		 je	 SHORT $LN13@sr_read_va
  0007c	83 7c 24 78 08	 cmp	 DWORD PTR suslen$[rsp], 8
  00081	74 0f		 je	 SHORT $LN13@sr_read_va

; 761  :     {
; 762  :         sr_value_error_();

  00083	e8 00 00 00 00	 call	 sr_value_error_

; 763  :         return -1;

  00088	b8 ff ff ff ff	 mov	 eax, -1
  0008d	e9 a8 01 00 00	 jmp	 $LN1@sr_read_va
$LN13@sr_read_va:

; 764  :     }
; 765  : 
; 766  :     if ((U32)SR_READ(buf, 1, suslen, file) != suslen)

  00092	8b 44 24 78	 mov	 eax, DWORD PTR suslen$[rsp]
  00096	4c 8b 4c 24 70	 mov	 r9, QWORD PTR file$[rsp]
  0009b	44 8b c0	 mov	 r8d, eax
  0009e	ba 01 00 00 00	 mov	 edx, 1
  000a3	48 8d 4c 24 50	 lea	 rcx, QWORD PTR buf$[rsp]
  000a8	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fread
  000ae	3b 44 24 78	 cmp	 eax, DWORD PTR suslen$[rsp]
  000b2	74 0f		 je	 SHORT $LN14@sr_read_va

; 767  :     {
; 768  :         sr_read_error_();

  000b4	e8 00 00 00 00	 call	 sr_read_error_

; 769  :         return -1;

  000b9	b8 ff ff ff ff	 mov	 eax, -1
  000be	e9 77 01 00 00	 jmp	 $LN1@sr_read_va
$LN14@sr_read_va:

; 770  :     }
; 771  : 
; 772  :     switch (suslen)

  000c3	8b 44 24 78	 mov	 eax, DWORD PTR suslen$[rsp]
  000c7	89 44 24 28	 mov	 DWORD PTR tv85[rsp], eax
  000cb	83 7c 24 28 01	 cmp	 DWORD PTR tv85[rsp], 1
  000d0	74 17		 je	 SHORT $LN15@sr_read_va
  000d2	83 7c 24 28 02	 cmp	 DWORD PTR tv85[rsp], 2
  000d7	74 25		 je	 SHORT $LN16@sr_read_va
  000d9	83 7c 24 28 04	 cmp	 DWORD PTR tv85[rsp], 4
  000de	74 3a		 je	 SHORT $LN17@sr_read_va
  000e0	83 7c 24 28 08	 cmp	 DWORD PTR tv85[rsp], 8
  000e5	74 4d		 je	 SHORT $LN18@sr_read_va
  000e7	eb 64		 jmp	 SHORT $LN19@sr_read_va
$LN15@sr_read_va:

; 773  :     {
; 774  :         case 1:  value = buf[0];         break;

  000e9	b8 01 00 00 00	 mov	 eax, 1
  000ee	48 6b c0 00	 imul	 rax, rax, 0
  000f2	0f b6 44 04 50	 movzx	 eax, BYTE PTR buf$[rsp+rax]
  000f7	48 89 44 24 20	 mov	 QWORD PTR value$[rsp], rax
  000fc	eb 58		 jmp	 SHORT $LN5@sr_read_va
$LN16@sr_read_va:

; 775  :         case 2:  value = fetch_hw (buf); break;

  000fe	48 8d 4c 24 50	 lea	 rcx, QWORD PTR buf$[rsp]
  00103	e8 00 00 00 00	 call	 fetch_hw_noswap
  00108	0f b7 c8	 movzx	 ecx, ax
  0010b	e8 00 00 00 00	 call	 _byteswap_ushort
  00110	0f b7 c0	 movzx	 eax, ax
  00113	48 89 44 24 20	 mov	 QWORD PTR value$[rsp], rax
  00118	eb 3c		 jmp	 SHORT $LN5@sr_read_va
$LN17@sr_read_va:

; 776  :         case 4:  value = fetch_fw (buf); break;

  0011a	48 8d 4c 24 50	 lea	 rcx, QWORD PTR buf$[rsp]
  0011f	e8 00 00 00 00	 call	 fetch_fw_noswap
  00124	8b c8		 mov	 ecx, eax
  00126	e8 00 00 00 00	 call	 _byteswap_ulong
  0012b	8b c0		 mov	 eax, eax
  0012d	48 89 44 24 20	 mov	 QWORD PTR value$[rsp], rax
  00132	eb 22		 jmp	 SHORT $LN5@sr_read_va
$LN18@sr_read_va:

; 777  :         case 8:  value = fetch_dw (buf); break;

  00134	48 8d 4c 24 50	 lea	 rcx, QWORD PTR buf$[rsp]
  00139	e8 00 00 00 00	 call	 fetch_dw_noswap
  0013e	48 8b c8	 mov	 rcx, rax
  00141	e8 00 00 00 00	 call	 _byteswap_uint64
  00146	48 89 44 24 20	 mov	 QWORD PTR value$[rsp], rax
  0014b	eb 09		 jmp	 SHORT $LN5@sr_read_va
$LN19@sr_read_va:

; 778  :         default: value = 0;              break; /* To ward off gcc -Wall */

  0014d	48 c7 44 24 20
	00 00 00 00	 mov	 QWORD PTR value$[rsp], 0
$LN5@sr_read_va:
$LN9@sr_read_va:

; 779  :     }
; 780  : 
; 781  :     TRACE("                           val=0x%16.16"PRIx64"\n", value);

  00156	48 8b 54 24 20	 mov	 rdx, QWORD PTR value$[rsp]
  0015b	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG177450
  00162	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_logmsg
  00168	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_IsDebuggerPresent
  0016e	85 c0		 test	 eax, eax
  00170	74 11		 je	 SHORT $LN20@sr_read_va
  00172	48 8b 54 24 20	 mov	 rdx, QWORD PTR value$[rsp]
  00177	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG177452
  0017e	e8 00 00 00 00	 call	 DebuggerTrace
$LN20@sr_read_va:
  00183	33 c0		 xor	 eax, eax
  00185	85 c0		 test	 eax, eax
  00187	75 cd		 jne	 SHORT $LN9@sr_read_va

; 782  : 
; 783  :     switch (reslen)

  00189	8b 84 24 88 00
	00 00		 mov	 eax, DWORD PTR reslen$[rsp]
  00190	89 44 24 2c	 mov	 DWORD PTR tv146[rsp], eax
  00194	83 7c 24 2c 01	 cmp	 DWORD PTR tv146[rsp], 1
  00199	74 1a		 je	 SHORT $LN21@sr_read_va
  0019b	83 7c 24 2c 02	 cmp	 DWORD PTR tv146[rsp], 2
  001a0	74 34		 je	 SHORT $LN22@sr_read_va
  001a2	83 7c 24 2c 04	 cmp	 DWORD PTR tv146[rsp], 4
  001a7	74 4f		 je	 SHORT $LN23@sr_read_va
  001a9	83 7c 24 2c 08	 cmp	 DWORD PTR tv146[rsp], 8
  001ae	74 6e		 je	 SHORT $LN24@sr_read_va
  001b0	e9 83 00 00 00	 jmp	 $LN10@sr_read_va
$LN21@sr_read_va:

; 784  :     {
; 785  :         case 1:
; 786  :         {
; 787  :             BYTE* ptr = p;

  001b5	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR p$[rsp]
  001bd	48 89 44 24 30	 mov	 QWORD PTR ptr$1[rsp], rax

; 788  :             *ptr = (BYTE)(value & 0xFF);

  001c2	48 8b 44 24 20	 mov	 rax, QWORD PTR value$[rsp]
  001c7	48 25 ff 00 00
	00		 and	 rax, 255		; 000000ffH
  001cd	48 8b 4c 24 30	 mov	 rcx, QWORD PTR ptr$1[rsp]
  001d2	88 01		 mov	 BYTE PTR [rcx], al

; 789  :             break;

  001d4	eb 62		 jmp	 SHORT $LN10@sr_read_va
$LN22@sr_read_va:

; 790  :         }
; 791  :         case 2:
; 792  :         {
; 793  :             U16* ptr = p;

  001d6	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR p$[rsp]
  001de	48 89 44 24 38	 mov	 QWORD PTR ptr$2[rsp], rax

; 794  :             *ptr = (U16)(value & 0xFFFF);

  001e3	48 8b 44 24 20	 mov	 rax, QWORD PTR value$[rsp]
  001e8	48 25 ff ff 00
	00		 and	 rax, 65535		; 0000ffffH
  001ee	48 8b 4c 24 38	 mov	 rcx, QWORD PTR ptr$2[rsp]
  001f3	66 89 01	 mov	 WORD PTR [rcx], ax

; 795  :             break;

  001f6	eb 40		 jmp	 SHORT $LN10@sr_read_va
$LN23@sr_read_va:

; 796  :         }
; 797  :         case 4:
; 798  :         {
; 799  :             U32* ptr = p;

  001f8	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR p$[rsp]
  00200	48 89 44 24 40	 mov	 QWORD PTR ptr$3[rsp], rax

; 800  :             *ptr = (U32)(value & 0xFFFFFFFF);

  00205	b8 ff ff ff ff	 mov	 eax, -1			; ffffffffH
  0020a	48 8b 4c 24 20	 mov	 rcx, QWORD PTR value$[rsp]
  0020f	48 23 c8	 and	 rcx, rax
  00212	48 8b c1	 mov	 rax, rcx
  00215	48 8b 4c 24 40	 mov	 rcx, QWORD PTR ptr$3[rsp]
  0021a	89 01		 mov	 DWORD PTR [rcx], eax

; 801  :             break;

  0021c	eb 1a		 jmp	 SHORT $LN10@sr_read_va
$LN24@sr_read_va:

; 802  :         }
; 803  :         case 8:
; 804  :         {
; 805  :             U64* ptr = p;

  0021e	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR p$[rsp]
  00226	48 89 44 24 48	 mov	 QWORD PTR ptr$4[rsp], rax

; 806  :             *ptr = (U64)(value & 0xFFFFFFFFFFFFFFFFULL);

  0022b	48 8b 44 24 48	 mov	 rax, QWORD PTR ptr$4[rsp]
  00230	48 8b 4c 24 20	 mov	 rcx, QWORD PTR value$[rsp]
  00235	48 89 08	 mov	 QWORD PTR [rax], rcx
$LN10@sr_read_va:

; 807  :             break;
; 808  :         }
; 809  :     }
; 810  :     return 0;

  00238	33 c0		 xor	 eax, eax
$LN1@sr_read_va:

; 811  : }

  0023a	48 8b 4c 24 58	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  0023f	48 33 cc	 xor	 rcx, rsp
  00242	e8 00 00 00 00	 call	 __security_check_cookie
  00247	48 83 c4 68	 add	 rsp, 104		; 00000068H
  0024b	c3		 ret	 0
sr_read_value ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\sr.h
_TEXT	SEGMENT
buf$ = 32
__$ArrayPad$ = 40
file$ = 64
key$ = 72
len$ = 80
sr_read_hdr PROC

; 656  : {

  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	48 83 ec 38	 sub	 rsp, 56			; 00000038H
  00013	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  0001a	48 33 c4	 xor	 rax, rsp
  0001d	48 89 44 24 28	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 657  : BYTE  buf[8];
; 658  : 
; 659  :     if (SR_READ(buf, 1, 8, file) != 8)

  00022	4c 8b 4c 24 40	 mov	 r9, QWORD PTR file$[rsp]
  00027	41 b8 08 00 00
	00		 mov	 r8d, 8
  0002d	ba 01 00 00 00	 mov	 edx, 1
  00032	48 8d 4c 24 20	 lea	 rcx, QWORD PTR buf$[rsp]
  00037	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fread
  0003d	48 83 f8 08	 cmp	 rax, 8
  00041	74 0c		 je	 SHORT $LN5@sr_read_hd

; 660  :     {
; 661  :         sr_read_error_();

  00043	e8 00 00 00 00	 call	 sr_read_error_

; 662  :         return -1;

  00048	b8 ff ff ff ff	 mov	 eax, -1
  0004d	eb 7c		 jmp	 SHORT $LN1@sr_read_hd
$LN5@sr_read_hd:

; 663  :     }
; 664  : 
; 665  :     *key = fetch_fw (buf);

  0004f	48 8d 4c 24 20	 lea	 rcx, QWORD PTR buf$[rsp]
  00054	e8 00 00 00 00	 call	 fetch_fw_noswap
  00059	8b c8		 mov	 ecx, eax
  0005b	e8 00 00 00 00	 call	 _byteswap_ulong
  00060	48 8b 4c 24 48	 mov	 rcx, QWORD PTR key$[rsp]
  00065	89 01		 mov	 DWORD PTR [rcx], eax

; 666  :     *len = fetch_fw (buf+4);

  00067	48 8d 44 24 24	 lea	 rax, QWORD PTR buf$[rsp+4]
  0006c	48 8b c8	 mov	 rcx, rax
  0006f	e8 00 00 00 00	 call	 fetch_fw_noswap
  00074	8b c8		 mov	 ecx, eax
  00076	e8 00 00 00 00	 call	 _byteswap_ulong
  0007b	48 8b 4c 24 50	 mov	 rcx, QWORD PTR len$[rsp]
  00080	89 01		 mov	 DWORD PTR [rcx], eax
$LN4@sr_read_hd:

; 667  : 
; 668  :     TRACE("SR: sr_read_hdr:   key=0x%8.8x, len=0x%8.8x\n", *key, *len);

  00082	48 8b 44 24 50	 mov	 rax, QWORD PTR len$[rsp]
  00087	44 8b 00	 mov	 r8d, DWORD PTR [rax]
  0008a	48 8b 44 24 48	 mov	 rax, QWORD PTR key$[rsp]
  0008f	8b 10		 mov	 edx, DWORD PTR [rax]
  00091	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG177353
  00098	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_logmsg
  0009e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_IsDebuggerPresent
  000a4	85 c0		 test	 eax, eax
  000a6	74 1b		 je	 SHORT $LN6@sr_read_hd
  000a8	48 8b 44 24 50	 mov	 rax, QWORD PTR len$[rsp]
  000ad	44 8b 00	 mov	 r8d, DWORD PTR [rax]
  000b0	48 8b 44 24 48	 mov	 rax, QWORD PTR key$[rsp]
  000b5	8b 10		 mov	 edx, DWORD PTR [rax]
  000b7	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG177355
  000be	e8 00 00 00 00	 call	 DebuggerTrace
$LN6@sr_read_hd:
  000c3	33 c0		 xor	 eax, eax
  000c5	85 c0		 test	 eax, eax
  000c7	75 b9		 jne	 SHORT $LN4@sr_read_hd

; 669  : 
; 670  :     return 0;

  000c9	33 c0		 xor	 eax, eax
$LN1@sr_read_hd:

; 671  : }

  000cb	48 8b 4c 24 28	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  000d0	48 33 cc	 xor	 rcx, rsp
  000d3	e8 00 00 00 00	 call	 __security_check_cookie
  000d8	48 83 c4 38	 add	 rsp, 56			; 00000038H
  000dc	c3		 ret	 0
sr_read_hdr ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\sr.h
_TEXT	SEGMENT
siz$ = 32
tot$ = 40
buf$ = 48
tv80 = 56
file$ = 80
key$ = 88
p$ = 96
len$ = 104
sr_write_buf PROC

; 592  : {

  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  0000e	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00013	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 593  : U32    siz;
; 594  : U64    tot  = len;

  00017	48 8b 44 24 68	 mov	 rax, QWORD PTR len$[rsp]
  0001c	48 89 44 24 28	 mov	 QWORD PTR tot$[rsp], rax

; 595  : BYTE*  buf  = p;

  00021	48 8b 44 24 60	 mov	 rax, QWORD PTR p$[rsp]
  00026	48 89 44 24 30	 mov	 QWORD PTR buf$[rsp], rax

; 596  : 
; 597  :     if (sr_write_hdr(file, key, len) != 0)

  0002b	44 8b 44 24 68	 mov	 r8d, DWORD PTR len$[rsp]
  00030	8b 54 24 58	 mov	 edx, DWORD PTR key$[rsp]
  00034	48 8b 4c 24 50	 mov	 rcx, QWORD PTR file$[rsp]
  00039	e8 00 00 00 00	 call	 sr_write_hdr
  0003e	85 c0		 test	 eax, eax
  00040	74 0a		 je	 SHORT $LN7@sr_write_b

; 598  :         return -1;

  00042	b8 ff ff ff ff	 mov	 eax, -1
  00047	e9 cc 00 00 00	 jmp	 $LN1@sr_write_b
$LN7@sr_write_b:
$LN4@sr_write_b:

; 599  : 
; 600  :     TRACE("SR: sr_write_buf:    key=0x%8.8x, len=0x%16.16"PRIx64"\n", key, len);

  0004c	4c 8b 44 24 68	 mov	 r8, QWORD PTR len$[rsp]
  00051	8b 54 24 58	 mov	 edx, DWORD PTR key$[rsp]
  00055	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG177307
  0005c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_logmsg
  00062	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_IsDebuggerPresent
  00068	85 c0		 test	 eax, eax
  0006a	74 15		 je	 SHORT $LN8@sr_write_b
  0006c	4c 8b 44 24 68	 mov	 r8, QWORD PTR len$[rsp]
  00071	8b 54 24 58	 mov	 edx, DWORD PTR key$[rsp]
  00075	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG177309
  0007c	e8 00 00 00 00	 call	 DebuggerTrace
$LN8@sr_write_b:
  00081	33 c0		 xor	 eax, eax
  00083	85 c0		 test	 eax, eax
  00085	75 c5		 jne	 SHORT $LN4@sr_write_b
$LN5@sr_write_b:

; 601  : 
; 602  :     while (tot)

  00087	48 83 7c 24 28
	00		 cmp	 QWORD PTR tot$[rsp], 0
  0008d	0f 84 83 00 00
	00		 je	 $LN6@sr_write_b

; 603  :     {
; 604  :         siz = tot < SR_BUF_CHUNKSIZE ? tot : SR_BUF_CHUNKSIZE;

  00093	48 81 7c 24 28
	00 00 00 10	 cmp	 QWORD PTR tot$[rsp], 268435456 ; 10000000H
  0009c	73 0c		 jae	 SHORT $LN11@sr_write_b
  0009e	48 8b 44 24 28	 mov	 rax, QWORD PTR tot$[rsp]
  000a3	48 89 44 24 38	 mov	 QWORD PTR tv80[rsp], rax
  000a8	eb 09		 jmp	 SHORT $LN12@sr_write_b
$LN11@sr_write_b:
  000aa	48 c7 44 24 38
	00 00 00 10	 mov	 QWORD PTR tv80[rsp], 268435456 ; 10000000H
$LN12@sr_write_b:
  000b3	8b 44 24 38	 mov	 eax, DWORD PTR tv80[rsp]
  000b7	89 44 24 20	 mov	 DWORD PTR siz$[rsp], eax

; 605  : 
; 606  :         if ((U32)SR_WRITE(buf, 1, siz, file) != siz)

  000bb	8b 44 24 20	 mov	 eax, DWORD PTR siz$[rsp]
  000bf	4c 8b 4c 24 50	 mov	 r9, QWORD PTR file$[rsp]
  000c4	44 8b c0	 mov	 r8d, eax
  000c7	ba 01 00 00 00	 mov	 edx, 1
  000cc	48 8b 4c 24 30	 mov	 rcx, QWORD PTR buf$[rsp]
  000d1	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_fwrite
  000d7	3b 44 24 20	 cmp	 eax, DWORD PTR siz$[rsp]
  000db	74 0c		 je	 SHORT $LN9@sr_write_b

; 607  :         {
; 608  :             sr_write_error_();

  000dd	e8 00 00 00 00	 call	 sr_write_error_

; 609  :             return -1;

  000e2	b8 ff ff ff ff	 mov	 eax, -1
  000e7	eb 2f		 jmp	 SHORT $LN1@sr_write_b
$LN9@sr_write_b:

; 610  :         }
; 611  :         tot -= siz;

  000e9	8b 44 24 20	 mov	 eax, DWORD PTR siz$[rsp]
  000ed	48 8b 4c 24 28	 mov	 rcx, QWORD PTR tot$[rsp]
  000f2	48 2b c8	 sub	 rcx, rax
  000f5	48 8b c1	 mov	 rax, rcx
  000f8	48 89 44 24 28	 mov	 QWORD PTR tot$[rsp], rax

; 612  :         buf += siz;

  000fd	8b 44 24 20	 mov	 eax, DWORD PTR siz$[rsp]
  00101	48 8b 4c 24 30	 mov	 rcx, QWORD PTR buf$[rsp]
  00106	48 03 c8	 add	 rcx, rax
  00109	48 8b c1	 mov	 rax, rcx
  0010c	48 89 44 24 30	 mov	 QWORD PTR buf$[rsp], rax

; 613  :     }

  00111	e9 71 ff ff ff	 jmp	 $LN5@sr_write_b
$LN6@sr_write_b:

; 614  : 
; 615  :     return 0;

  00116	33 c0		 xor	 eax, eax
$LN1@sr_write_b:

; 616  : }

  00118	48 83 c4 48	 add	 rsp, 72			; 00000048H
  0011c	c3		 ret	 0
sr_write_buf ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\sr.h
_TEXT	SEGMENT
tv84 = 32
buf$ = 40
__$ArrayPad$ = 48
file$ = 80
key$ = 88
val$ = 96
len$ = 104
sr_write_value PROC

; 622  : {

  00000	44 89 4c 24 20	 mov	 DWORD PTR [rsp+32], r9d
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  0000e	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00013	48 83 ec 48	 sub	 rsp, 72			; 00000048H
  00017	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  0001e	48 33 c4	 xor	 rax, rsp
  00021	48 89 44 24 30	 mov	 QWORD PTR __$ArrayPad$[rsp], rax
$LN4@sr_write_v:

; 623  : BYTE    buf[8];
; 624  : 
; 625  :     TRACE("SR: sr_write_value:  key=0x%8.8x, len=0x%8.8x, val=0x%16.16"PRIx64"\n", key, len, val);

  00026	4c 8b 4c 24 60	 mov	 r9, QWORD PTR val$[rsp]
  0002b	44 8b 44 24 68	 mov	 r8d, DWORD PTR len$[rsp]
  00030	8b 54 24 58	 mov	 edx, DWORD PTR key$[rsp]
  00034	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG177331
  0003b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_logmsg
  00041	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_IsDebuggerPresent
  00047	85 c0		 test	 eax, eax
  00049	74 1a		 je	 SHORT $LN7@sr_write_v
  0004b	4c 8b 4c 24 60	 mov	 r9, QWORD PTR val$[rsp]
  00050	44 8b 44 24 68	 mov	 r8d, DWORD PTR len$[rsp]
  00055	8b 54 24 58	 mov	 edx, DWORD PTR key$[rsp]
  00059	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG177333
  00060	e8 00 00 00 00	 call	 DebuggerTrace
$LN7@sr_write_v:
  00065	33 c0		 xor	 eax, eax
  00067	85 c0		 test	 eax, eax
  00069	75 bb		 jne	 SHORT $LN4@sr_write_v

; 626  : 
; 627  :     if (len != 1 && len != 2 && len != 4 && len != 8)

  0006b	83 7c 24 68 01	 cmp	 DWORD PTR len$[rsp], 1
  00070	74 24		 je	 SHORT $LN8@sr_write_v
  00072	83 7c 24 68 02	 cmp	 DWORD PTR len$[rsp], 2
  00077	74 1d		 je	 SHORT $LN8@sr_write_v
  00079	83 7c 24 68 04	 cmp	 DWORD PTR len$[rsp], 4
  0007e	74 16		 je	 SHORT $LN8@sr_write_v
  00080	83 7c 24 68 08	 cmp	 DWORD PTR len$[rsp], 8
  00085	74 0f		 je	 SHORT $LN8@sr_write_v

; 628  :     {
; 629  :         sr_value_error_();

  00087	e8 00 00 00 00	 call	 sr_value_error_

; 630  :         return -1;

  0008c	b8 ff ff ff ff	 mov	 eax, -1
  00091	e9 d2 00 00 00	 jmp	 $LN1@sr_write_v
$LN8@sr_write_v:

; 631  :     }
; 632  : 
; 633  :     if (sr_write_hdr(file, key, len) != 0)

  00096	44 8b 44 24 68	 mov	 r8d, DWORD PTR len$[rsp]
  0009b	8b 54 24 58	 mov	 edx, DWORD PTR key$[rsp]
  0009f	48 8b 4c 24 50	 mov	 rcx, QWORD PTR file$[rsp]
  000a4	e8 00 00 00 00	 call	 sr_write_hdr
  000a9	85 c0		 test	 eax, eax
  000ab	74 0a		 je	 SHORT $LN9@sr_write_v

; 634  :         return -1;

  000ad	b8 ff ff ff ff	 mov	 eax, -1
  000b2	e9 b1 00 00 00	 jmp	 $LN1@sr_write_v
$LN9@sr_write_v:

; 635  : 
; 636  :     switch (len)

  000b7	8b 44 24 68	 mov	 eax, DWORD PTR len$[rsp]
  000bb	89 44 24 20	 mov	 DWORD PTR tv84[rsp], eax
  000bf	83 7c 24 20 01	 cmp	 DWORD PTR tv84[rsp], 1
  000c4	74 17		 je	 SHORT $LN10@sr_write_v
  000c6	83 7c 24 20 02	 cmp	 DWORD PTR tv84[rsp], 2
  000cb	74 24		 je	 SHORT $LN11@sr_write_v
  000cd	83 7c 24 20 04	 cmp	 DWORD PTR tv84[rsp], 4
  000d2	74 36		 je	 SHORT $LN12@sr_write_v
  000d4	83 7c 24 20 08	 cmp	 DWORD PTR tv84[rsp], 8
  000d9	74 46		 je	 SHORT $LN13@sr_write_v
  000db	eb 5b		 jmp	 SHORT $LN5@sr_write_v
$LN10@sr_write_v:

; 637  :     {
; 638  :         case 1: buf[0]     =  (BYTE)val;  break;

  000dd	b8 01 00 00 00	 mov	 eax, 1
  000e2	48 6b c0 00	 imul	 rax, rax, 0
  000e6	0f b6 4c 24 60	 movzx	 ecx, BYTE PTR val$[rsp]
  000eb	88 4c 04 28	 mov	 BYTE PTR buf$[rsp+rax], cl
  000ef	eb 47		 jmp	 SHORT $LN5@sr_write_v
$LN11@sr_write_v:

; 639  :         case 2: store_hw (buf, (U16)val); break;

  000f1	0f b7 4c 24 60	 movzx	 ecx, WORD PTR val$[rsp]
  000f6	e8 00 00 00 00	 call	 _byteswap_ushort
  000fb	0f b7 d0	 movzx	 edx, ax
  000fe	48 8d 4c 24 28	 lea	 rcx, QWORD PTR buf$[rsp]
  00103	e8 00 00 00 00	 call	 store_hw_noswap
  00108	eb 2e		 jmp	 SHORT $LN5@sr_write_v
$LN12@sr_write_v:

; 640  :         case 4: store_fw (buf, (U32)val); break;

  0010a	8b 4c 24 60	 mov	 ecx, DWORD PTR val$[rsp]
  0010e	e8 00 00 00 00	 call	 _byteswap_ulong
  00113	8b d0		 mov	 edx, eax
  00115	48 8d 4c 24 28	 lea	 rcx, QWORD PTR buf$[rsp]
  0011a	e8 00 00 00 00	 call	 store_fw_noswap
  0011f	eb 17		 jmp	 SHORT $LN5@sr_write_v
$LN13@sr_write_v:

; 641  :         case 8: store_dw (buf, (U64)val); break;

  00121	48 8b 4c 24 60	 mov	 rcx, QWORD PTR val$[rsp]
  00126	e8 00 00 00 00	 call	 _byteswap_uint64
  0012b	48 8b d0	 mov	 rdx, rax
  0012e	48 8d 4c 24 28	 lea	 rcx, QWORD PTR buf$[rsp]
  00133	e8 00 00 00 00	 call	 store_dw_noswap
$LN5@sr_write_v:

; 642  :     }
; 643  : 
; 644  :     if ((U32)SR_WRITE(buf, 1, len, file) != len)

  00138	8b 44 24 68	 mov	 eax, DWORD PTR len$[rsp]
  0013c	4c 8b 4c 24 50	 mov	 r9, QWORD PTR file$[rsp]
  00141	44 8b c0	 mov	 r8d, eax
  00144	ba 01 00 00 00	 mov	 edx, 1
  00149	48 8d 4c 24 28	 lea	 rcx, QWORD PTR buf$[rsp]
  0014e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_fwrite
  00154	3b 44 24 68	 cmp	 eax, DWORD PTR len$[rsp]
  00158	74 0c		 je	 SHORT $LN14@sr_write_v

; 645  :     {
; 646  :         sr_write_error_();

  0015a	e8 00 00 00 00	 call	 sr_write_error_

; 647  :         return -1;

  0015f	b8 ff ff ff ff	 mov	 eax, -1
  00164	eb 02		 jmp	 SHORT $LN1@sr_write_v
$LN14@sr_write_v:

; 648  :     }
; 649  :     return 0;

  00166	33 c0		 xor	 eax, eax
$LN1@sr_write_v:

; 650  : }

  00168	48 8b 4c 24 30	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  0016d	48 33 cc	 xor	 rcx, rsp
  00170	e8 00 00 00 00	 call	 __security_check_cookie
  00175	48 83 c4 48	 add	 rsp, 72			; 00000048H
  00179	c3		 ret	 0
sr_write_value ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\sr.h
_TEXT	SEGMENT
buf$ = 32
__$ArrayPad$ = 40
file$ = 64
key$ = 72
len$ = 80
sr_write_hdr PROC

; 546  : {

  00000	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  00005	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00009	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000e	48 83 ec 38	 sub	 rsp, 56			; 00000038H
  00012	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00019	48 33 c4	 xor	 rax, rsp
  0001c	48 89 44 24 28	 mov	 QWORD PTR __$ArrayPad$[rsp], rax
$LN4@sr_write_h:

; 547  : BYTE  buf[8];
; 548  : 
; 549  :     TRACE("SR: sr_write_hdr:    key=0x%8.8x, len=0x%8.8x\n", key, len);

  00021	44 8b 44 24 50	 mov	 r8d, DWORD PTR len$[rsp]
  00026	8b 54 24 48	 mov	 edx, DWORD PTR key$[rsp]
  0002a	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG177265
  00031	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_logmsg
  00037	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_IsDebuggerPresent
  0003d	85 c0		 test	 eax, eax
  0003f	74 15		 je	 SHORT $LN5@sr_write_h
  00041	44 8b 44 24 50	 mov	 r8d, DWORD PTR len$[rsp]
  00046	8b 54 24 48	 mov	 edx, DWORD PTR key$[rsp]
  0004a	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG177267
  00051	e8 00 00 00 00	 call	 DebuggerTrace
$LN5@sr_write_h:
  00056	33 c0		 xor	 eax, eax
  00058	85 c0		 test	 eax, eax
  0005a	75 c5		 jne	 SHORT $LN4@sr_write_h

; 550  : 
; 551  :     store_fw (buf, key);

  0005c	8b 4c 24 48	 mov	 ecx, DWORD PTR key$[rsp]
  00060	e8 00 00 00 00	 call	 _byteswap_ulong
  00065	8b d0		 mov	 edx, eax
  00067	48 8d 4c 24 20	 lea	 rcx, QWORD PTR buf$[rsp]
  0006c	e8 00 00 00 00	 call	 store_fw_noswap

; 552  :     store_fw (buf+4, len);

  00071	8b 4c 24 50	 mov	 ecx, DWORD PTR len$[rsp]
  00075	e8 00 00 00 00	 call	 _byteswap_ulong
  0007a	48 8d 4c 24 24	 lea	 rcx, QWORD PTR buf$[rsp+4]
  0007f	8b d0		 mov	 edx, eax
  00081	e8 00 00 00 00	 call	 store_fw_noswap

; 553  : 
; 554  :     if (SR_WRITE(buf, 1, 8, file) != 8)

  00086	4c 8b 4c 24 40	 mov	 r9, QWORD PTR file$[rsp]
  0008b	41 b8 08 00 00
	00		 mov	 r8d, 8
  00091	ba 01 00 00 00	 mov	 edx, 1
  00096	48 8d 4c 24 20	 lea	 rcx, QWORD PTR buf$[rsp]
  0009b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_fwrite
  000a1	48 83 f8 08	 cmp	 rax, 8
  000a5	74 0c		 je	 SHORT $LN6@sr_write_h

; 555  :     {
; 556  :         sr_write_error_();

  000a7	e8 00 00 00 00	 call	 sr_write_error_

; 557  :         return -1;

  000ac	b8 ff ff ff ff	 mov	 eax, -1
  000b1	eb 02		 jmp	 SHORT $LN1@sr_write_h
$LN6@sr_write_h:

; 558  :     }
; 559  :     return 0;

  000b3	33 c0		 xor	 eax, eax
$LN1@sr_write_h:

; 560  : }

  000b5	48 8b 4c 24 28	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  000ba	48 33 cc	 xor	 rcx, rsp
  000bd	e8 00 00 00 00	 call	 __security_check_cookie
  000c2	48 83 c4 38	 add	 rsp, 56			; 00000038H
  000c6	c3		 ret	 0
sr_write_hdr ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\machdep.h
;	COMDAT store_dw_noswap
_TEXT	SEGMENT
ptr$ = 8
value$ = 16
store_dw_noswap PROC					; COMDAT

; 834  :     inline void store_dw_noswap(void *ptr, U64 value) {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx

; 835  :       memcpy((BYTE *)ptr, (BYTE *)&value, 8);

  0000a	48 8b 44 24 08	 mov	 rax, QWORD PTR ptr$[rsp]
  0000f	48 8b 4c 24 10	 mov	 rcx, QWORD PTR value$[rsp]
  00014	48 89 08	 mov	 QWORD PTR [rax], rcx

; 836  :     }

  00017	c3		 ret	 0
store_dw_noswap ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\machdep.h
;	COMDAT fetch_dw_noswap
_TEXT	SEGMENT
value$ = 0
ptr$ = 32
fetch_dw_noswap PROC					; COMDAT

; 816  :     inline U64 fetch_dw_noswap(const void *ptr) {

$LN3:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 18	 sub	 rsp, 24

; 817  :       U64 value;
; 818  :       memcpy(&value, (BYTE *)ptr, 8);

  00009	48 8b 44 24 20	 mov	 rax, QWORD PTR ptr$[rsp]
  0000e	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00011	48 89 04 24	 mov	 QWORD PTR value$[rsp], rax

; 819  :       return value;

  00015	48 8b 04 24	 mov	 rax, QWORD PTR value$[rsp]

; 820  :     }

  00019	48 83 c4 18	 add	 rsp, 24
  0001d	c3		 ret	 0
fetch_dw_noswap ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\machdep.h
;	COMDAT store_fw_noswap
_TEXT	SEGMENT
ptr$ = 8
value$ = 16
store_fw_noswap PROC					; COMDAT

; 764  :     inline void store_fw_noswap(void *ptr, U32 value) {

  00000	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00004	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx

; 765  :       memcpy((BYTE *)ptr, (BYTE *)&value, 4);

  00009	48 8b 44 24 08	 mov	 rax, QWORD PTR ptr$[rsp]
  0000e	8b 4c 24 10	 mov	 ecx, DWORD PTR value$[rsp]
  00012	89 08		 mov	 DWORD PTR [rax], ecx

; 766  :     }

  00014	c3		 ret	 0
store_fw_noswap ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\machdep.h
;	COMDAT fetch_fw_noswap
_TEXT	SEGMENT
value$ = 0
ptr$ = 32
fetch_fw_noswap PROC					; COMDAT

; 746  :     inline U32 fetch_fw_noswap(const void *ptr) {

$LN3:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 18	 sub	 rsp, 24

; 747  :       U32 value;
; 748  :       memcpy(&value, (BYTE *)ptr, 4);

  00009	48 8b 44 24 20	 mov	 rax, QWORD PTR ptr$[rsp]
  0000e	8b 00		 mov	 eax, DWORD PTR [rax]
  00010	89 04 24	 mov	 DWORD PTR value$[rsp], eax

; 749  :       return value;

  00013	8b 04 24	 mov	 eax, DWORD PTR value$[rsp]

; 750  :     }

  00016	48 83 c4 18	 add	 rsp, 24
  0001a	c3		 ret	 0
fetch_fw_noswap ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\machdep.h
;	COMDAT store_hw_noswap
_TEXT	SEGMENT
ptr$ = 8
value$ = 16
store_hw_noswap PROC					; COMDAT

; 730  :     inline void store_hw_noswap(void *ptr, U16 value) {

  00000	66 89 54 24 10	 mov	 WORD PTR [rsp+16], dx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx

; 731  :       memcpy((BYTE *)ptr, (BYTE *)&value, 2);

  0000a	48 8b 44 24 08	 mov	 rax, QWORD PTR ptr$[rsp]
  0000f	0f b7 4c 24 10	 movzx	 ecx, WORD PTR value$[rsp]
  00014	66 89 08	 mov	 WORD PTR [rax], cx

; 732  :     }

  00017	c3		 ret	 0
store_hw_noswap ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\machdep.h
;	COMDAT fetch_hw_noswap
_TEXT	SEGMENT
value$ = 0
ptr$ = 32
fetch_hw_noswap PROC					; COMDAT

; 712  :     inline U16 fetch_hw_noswap(const void *ptr) {

$LN3:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 18	 sub	 rsp, 24

; 713  :       U16 value;
; 714  :       memcpy(&value, (BYTE *)ptr, 2);

  00009	48 8b 44 24 20	 mov	 rax, QWORD PTR ptr$[rsp]
  0000e	0f b7 00	 movzx	 eax, WORD PTR [rax]
  00011	66 89 04 24	 mov	 WORD PTR value$[rsp], ax

; 715  :       return value;

  00015	0f b7 04 24	 movzx	 eax, WORD PTR value$[rsp]

; 716  :     }

  00019	48 83 c4 18	 add	 rsp, 24
  0001d	c3		 ret	 0
fetch_hw_noswap ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\extstring.h
_TEXT	SEGMENT
s$ = 32
r$ = 40
result$ = 64
string$ = 72
strupper PROC

; 157  : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 158  :     register char *r = result;

  0000e	48 8b 44 24 40	 mov	 rax, QWORD PTR result$[rsp]
  00013	48 89 44 24 28	 mov	 QWORD PTR r$[rsp], rax

; 159  :     register char *s = string;

  00018	48 8b 44 24 48	 mov	 rax, QWORD PTR string$[rsp]
  0001d	48 89 44 24 20	 mov	 QWORD PTR s$[rsp], rax

; 160  :     for (; *s; r++, s++)

  00022	eb 1a		 jmp	 SHORT $LN4@strupper
$LN2@strupper:
  00024	48 8b 44 24 28	 mov	 rax, QWORD PTR r$[rsp]
  00029	48 ff c0	 inc	 rax
  0002c	48 89 44 24 28	 mov	 QWORD PTR r$[rsp], rax
  00031	48 8b 44 24 20	 mov	 rax, QWORD PTR s$[rsp]
  00036	48 ff c0	 inc	 rax
  00039	48 89 44 24 20	 mov	 QWORD PTR s$[rsp], rax
$LN4@strupper:
  0003e	48 8b 44 24 20	 mov	 rax, QWORD PTR s$[rsp]
  00043	0f be 00	 movsx	 eax, BYTE PTR [rax]
  00046	85 c0		 test	 eax, eax
  00048	74 16		 je	 SHORT $LN3@strupper

; 161  :     {
; 162  :         *r = asciitoupper(*s);

  0004a	48 8b 44 24 20	 mov	 rax, QWORD PTR s$[rsp]
  0004f	0f b6 08	 movzx	 ecx, BYTE PTR [rax]
  00052	e8 00 00 00 00	 call	 asciitoupper
  00057	48 8b 4c 24 28	 mov	 rcx, QWORD PTR r$[rsp]
  0005c	88 01		 mov	 BYTE PTR [rcx], al

; 163  :     }

  0005e	eb c4		 jmp	 SHORT $LN2@strupper
$LN3@strupper:

; 164  :     *r = 0;

  00060	48 8b 44 24 28	 mov	 rax, QWORD PTR r$[rsp]
  00065	c6 00 00	 mov	 BYTE PTR [rax], 0

; 165  :     return result;

  00068	48 8b 44 24 40	 mov	 rax, QWORD PTR result$[rsp]

; 166  : }

  0006d	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00071	c3		 ret	 0
strupper ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\extstring.h
_TEXT	SEGMENT
c$ = 8
asciitoupper PROC

; 29   : {

  00000	88 4c 24 08	 mov	 BYTE PTR [rsp+8], cl

; 30   :   if (c < 'a' || c > 'z')

  00004	0f be 44 24 08	 movsx	 eax, BYTE PTR c$[rsp]
  00009	83 f8 61	 cmp	 eax, 97			; 00000061H
  0000c	7c 0a		 jl	 SHORT $LN3@asciitoupp
  0000e	0f be 44 24 08	 movsx	 eax, BYTE PTR c$[rsp]
  00013	83 f8 7a	 cmp	 eax, 122		; 0000007aH
  00016	7e 07		 jle	 SHORT $LN2@asciitoupp
$LN3@asciitoupp:

; 31   :       return c;

  00018	0f b6 44 24 08	 movzx	 eax, BYTE PTR c$[rsp]
  0001d	eb 08		 jmp	 SHORT $LN1@asciitoupp
$LN2@asciitoupp:

; 32   :   return (c - 32);

  0001f	0f be 44 24 08	 movsx	 eax, BYTE PTR c$[rsp]
  00024	83 e8 20	 sub	 eax, 32			; 00000020H
$LN1@asciitoupp:

; 33   : }

  00027	c3		 ret	 0
asciitoupper ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\dbgtrace.h
_TEXT	SEGMENT
buffsize$ = 48
rc$ = 52
chunksize$ = 56
buffer$ = 64
args$ = 72
fmt$ = 96
DebuggerTrace PROC

; 94   :   static inline void DebuggerTrace(char* fmt, ...) {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000f	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00014	48 83 ec 58	 sub	 rsp, 88			; 00000058H

; 95   :       const int chunksize = 512;

  00018	c7 44 24 38 00
	02 00 00	 mov	 DWORD PTR chunksize$[rsp], 512 ; 00000200H

; 96   :       int buffsize = 0;

  00020	c7 44 24 30 00
	00 00 00	 mov	 DWORD PTR buffsize$[rsp], 0

; 97   :       char* buffer = NULL;

  00028	48 c7 44 24 40
	00 00 00 00	 mov	 QWORD PTR buffer$[rsp], 0

; 98   :       int rc = -1;

  00031	c7 44 24 34 ff
	ff ff ff	 mov	 DWORD PTR rc$[rsp], -1

; 99   :       va_list args;
; 100  :       va_start( args, fmt );

  00039	48 8d 44 24 68	 lea	 rax, QWORD PTR fmt$[rsp+8]
  0003e	48 89 44 24 48	 mov	 QWORD PTR args$[rsp], rax
$LN9@DebuggerTr:
$LN4@DebuggerTr:

; 101  :       do {
; 102  :           if (buffer) free( buffer );

  00043	48 83 7c 24 40
	00		 cmp	 QWORD PTR buffer$[rsp], 0
  00049	74 0b		 je	 SHORT $LN5@DebuggerTr
  0004b	48 8b 4c 24 40	 mov	 rcx, QWORD PTR buffer$[rsp]
  00050	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free
$LN5@DebuggerTr:

; 103  :           buffsize += chunksize;

  00056	8b 44 24 38	 mov	 eax, DWORD PTR chunksize$[rsp]
  0005a	8b 4c 24 30	 mov	 ecx, DWORD PTR buffsize$[rsp]
  0005e	03 c8		 add	 ecx, eax
  00060	8b c1		 mov	 eax, ecx
  00062	89 44 24 30	 mov	 DWORD PTR buffsize$[rsp], eax

; 104  :           buffer = malloc( buffsize + 1 );

  00066	8b 44 24 30	 mov	 eax, DWORD PTR buffsize$[rsp]
  0006a	ff c0		 inc	 eax
  0006c	48 98		 cdqe
  0006e	48 8b c8	 mov	 rcx, rax
  00071	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_malloc
  00077	48 89 44 24 40	 mov	 QWORD PTR buffer$[rsp], rax

; 105  :           if (!buffer) BREAK_INTO_DEBUGGER();

  0007c	48 83 7c 24 40
	00		 cmp	 QWORD PTR buffer$[rsp], 0
  00082	75 01		 jne	 SHORT $LN6@DebuggerTr
  00084	cc		 int	 3
$LN6@DebuggerTr:

; 106  :           rc = _vsnprintf_s( buffer, buffsize+1, buffsize, fmt, args);

  00085	48 63 44 24 30	 movsxd	 rax, DWORD PTR buffsize$[rsp]
  0008a	8b 4c 24 30	 mov	 ecx, DWORD PTR buffsize$[rsp]
  0008e	ff c1		 inc	 ecx
  00090	48 63 c9	 movsxd	 rcx, ecx
  00093	48 8b 54 24 48	 mov	 rdx, QWORD PTR args$[rsp]
  00098	48 89 54 24 20	 mov	 QWORD PTR [rsp+32], rdx
  0009d	4c 8b 4c 24 60	 mov	 r9, QWORD PTR fmt$[rsp]
  000a2	4c 8b c0	 mov	 r8, rax
  000a5	48 8b d1	 mov	 rdx, rcx
  000a8	48 8b 4c 24 40	 mov	 rcx, QWORD PTR buffer$[rsp]
  000ad	e8 00 00 00 00	 call	 _vsnprintf_s
  000b2	89 44 24 34	 mov	 DWORD PTR rc$[rsp], eax

; 107  :       } while (rc < 0 || rc >= buffsize);

  000b6	83 7c 24 34 00	 cmp	 DWORD PTR rc$[rsp], 0
  000bb	7c 86		 jl	 SHORT $LN4@DebuggerTr
  000bd	8b 44 24 30	 mov	 eax, DWORD PTR buffsize$[rsp]
  000c1	39 44 24 34	 cmp	 DWORD PTR rc$[rsp], eax
  000c5	0f 8d 78 ff ff
	ff		 jge	 $LN9@DebuggerTr

; 108  :       OutputDebugStringA( buffer ); /* send to debugger pane */

  000cb	48 8b 4c 24 40	 mov	 rcx, QWORD PTR buffer$[rsp]
  000d0	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_OutputDebugStringA

; 109  :       if (buffer) free( buffer );

  000d6	48 83 7c 24 40
	00		 cmp	 QWORD PTR buffer$[rsp], 0
  000dc	74 0b		 je	 SHORT $LN7@DebuggerTr
  000de	48 8b 4c 24 40	 mov	 rcx, QWORD PTR buffer$[rsp]
  000e3	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free
$LN7@DebuggerTr:

; 110  :       va_end( args );

  000e9	48 c7 44 24 48
	00 00 00 00	 mov	 QWORD PTR args$[rsp], 0

; 111  :   }

  000f2	48 83 c4 58	 add	 rsp, 88			; 00000058H
  000f6	c3		 ret	 0
DebuggerTrace ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files (x86)\Windows Kits\10\include\10.0.22000.0\ucrt\stdio.h
;	COMDAT sscanf
_TEXT	SEGMENT
_Result$ = 32
_ArgList$ = 40
_Buffer$ = 64
_Format$ = 72
sscanf	PROC						; COMDAT

; 2247 :     {

$LN3:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000f	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00014	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 2248 :         int _Result;
; 2249 :         va_list _ArgList;
; 2250 :         __crt_va_start(_ArgList, _Format);

  00018	48 8d 44 24 50	 lea	 rax, QWORD PTR _Format$[rsp+8]
  0001d	48 89 44 24 28	 mov	 QWORD PTR _ArgList$[rsp], rax

; 2251 :         _Result = _vsscanf_l(_Buffer, _Format, NULL, _ArgList);

  00022	4c 8b 4c 24 28	 mov	 r9, QWORD PTR _ArgList$[rsp]
  00027	45 33 c0	 xor	 r8d, r8d
  0002a	48 8b 54 24 48	 mov	 rdx, QWORD PTR _Format$[rsp]
  0002f	48 8b 4c 24 40	 mov	 rcx, QWORD PTR _Buffer$[rsp]
  00034	e8 00 00 00 00	 call	 _vsscanf_l
  00039	89 44 24 20	 mov	 DWORD PTR _Result$[rsp], eax

; 2252 :         __crt_va_end(_ArgList);

  0003d	48 c7 44 24 28
	00 00 00 00	 mov	 QWORD PTR _ArgList$[rsp], 0

; 2253 :         return _Result;

  00046	8b 44 24 20	 mov	 eax, DWORD PTR _Result$[rsp]

; 2254 :     }

  0004a	48 83 c4 38	 add	 rsp, 56			; 00000038H
  0004e	c3		 ret	 0
sscanf	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files (x86)\Windows Kits\10\include\10.0.22000.0\ucrt\stdio.h
;	COMDAT _vsscanf_l
_TEXT	SEGMENT
_Buffer$ = 64
_Format$ = 72
_Locale$ = 80
_ArgList$ = 88
_vsscanf_l PROC						; COMDAT

; 2152 :     {

$LN3:
  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 2153 :         return __stdio_common_vsscanf(

  00018	e8 00 00 00 00	 call	 __local_stdio_scanf_options
  0001d	48 8b 4c 24 58	 mov	 rcx, QWORD PTR _ArgList$[rsp]
  00022	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00027	48 8b 4c 24 50	 mov	 rcx, QWORD PTR _Locale$[rsp]
  0002c	48 89 4c 24 20	 mov	 QWORD PTR [rsp+32], rcx
  00031	4c 8b 4c 24 48	 mov	 r9, QWORD PTR _Format$[rsp]
  00036	49 c7 c0 ff ff
	ff ff		 mov	 r8, -1
  0003d	48 8b 54 24 40	 mov	 rdx, QWORD PTR _Buffer$[rsp]
  00042	48 8b 08	 mov	 rcx, QWORD PTR [rax]
  00045	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___stdio_common_vsscanf

; 2154 :             _CRT_INTERNAL_LOCAL_SCANF_OPTIONS,
; 2155 :             _Buffer, (size_t)-1, _Format, _Locale, _ArgList);
; 2156 :     }

  0004b	48 83 c4 38	 add	 rsp, 56			; 00000038H
  0004f	c3		 ret	 0
_vsscanf_l ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files (x86)\Windows Kits\10\include\10.0.22000.0\ucrt\stdio.h
;	COMDAT _vsnprintf_s
_TEXT	SEGMENT
_Buffer$ = 64
_BufferCount$ = 72
_MaxCount$ = 80
_Format$ = 88
_ArgList$ = 96
_vsnprintf_s PROC					; COMDAT

; 1598 :     {

$LN3:
  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 1599 :         return _vsnprintf_s_l(_Buffer, _BufferCount, _MaxCount, _Format, NULL, _ArgList);

  00018	48 8b 44 24 60	 mov	 rax, QWORD PTR _ArgList$[rsp]
  0001d	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  00022	48 c7 44 24 20
	00 00 00 00	 mov	 QWORD PTR [rsp+32], 0
  0002b	4c 8b 4c 24 58	 mov	 r9, QWORD PTR _Format$[rsp]
  00030	4c 8b 44 24 50	 mov	 r8, QWORD PTR _MaxCount$[rsp]
  00035	48 8b 54 24 48	 mov	 rdx, QWORD PTR _BufferCount$[rsp]
  0003a	48 8b 4c 24 40	 mov	 rcx, QWORD PTR _Buffer$[rsp]
  0003f	e8 00 00 00 00	 call	 _vsnprintf_s_l

; 1600 :     }

  00044	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00048	c3		 ret	 0
_vsnprintf_s ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files (x86)\Windows Kits\10\include\10.0.22000.0\ucrt\stdio.h
;	COMDAT _vsnprintf_s_l
_TEXT	SEGMENT
_Result$ = 64
tv74 = 68
_Buffer$ = 96
_BufferCount$ = 104
_MaxCount$ = 112
_Format$ = 120
_Locale$ = 128
_ArgList$ = 136
_vsnprintf_s_l PROC					; COMDAT

; 1577 :     {

$LN5:
  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	48 83 ec 58	 sub	 rsp, 88			; 00000058H

; 1578 :         int const _Result = __stdio_common_vsnprintf_s(

  00018	e8 00 00 00 00	 call	 __local_stdio_printf_options
  0001d	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR _ArgList$[rsp]
  00025	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  0002a	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR _Locale$[rsp]
  00032	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00037	48 8b 4c 24 78	 mov	 rcx, QWORD PTR _Format$[rsp]
  0003c	48 89 4c 24 20	 mov	 QWORD PTR [rsp+32], rcx
  00041	4c 8b 4c 24 70	 mov	 r9, QWORD PTR _MaxCount$[rsp]
  00046	4c 8b 44 24 68	 mov	 r8, QWORD PTR _BufferCount$[rsp]
  0004b	48 8b 54 24 60	 mov	 rdx, QWORD PTR _Buffer$[rsp]
  00050	48 8b 08	 mov	 rcx, QWORD PTR [rax]
  00053	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___stdio_common_vsnprintf_s
  00059	89 44 24 40	 mov	 DWORD PTR _Result$[rsp], eax

; 1579 :             _CRT_INTERNAL_LOCAL_PRINTF_OPTIONS,
; 1580 :             _Buffer, _BufferCount, _MaxCount, _Format, _Locale, _ArgList);
; 1581 : 
; 1582 :         return _Result < 0 ? -1 : _Result;

  0005d	83 7c 24 40 00	 cmp	 DWORD PTR _Result$[rsp], 0
  00062	7d 0a		 jge	 SHORT $LN3@vsnprintf_
  00064	c7 44 24 44 ff
	ff ff ff	 mov	 DWORD PTR tv74[rsp], -1
  0006c	eb 08		 jmp	 SHORT $LN4@vsnprintf_
$LN3@vsnprintf_:
  0006e	8b 44 24 40	 mov	 eax, DWORD PTR _Result$[rsp]
  00072	89 44 24 44	 mov	 DWORD PTR tv74[rsp], eax
$LN4@vsnprintf_:
  00076	8b 44 24 44	 mov	 eax, DWORD PTR tv74[rsp]

; 1583 :     }

  0007a	48 83 c4 58	 add	 rsp, 88			; 00000058H
  0007e	c3		 ret	 0
_vsnprintf_s_l ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files (x86)\Windows Kits\10\include\10.0.22000.0\ucrt\corecrt_stdio_config.h
;	COMDAT __local_stdio_scanf_options
_TEXT	SEGMENT
__local_stdio_scanf_options PROC			; COMDAT

; 101  :         static unsigned __int64 _OptionsStorage;
; 102  :         return &_OptionsStorage;

  00000	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:?_OptionsStorage@?1??__local_stdio_scanf_options@@9@9 ; `__local_stdio_scanf_options'::`2'::_OptionsStorage

; 103  :     }

  00007	c3		 ret	 0
__local_stdio_scanf_options ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files (x86)\Windows Kits\10\include\10.0.22000.0\ucrt\corecrt_stdio_config.h
;	COMDAT __local_stdio_printf_options
_TEXT	SEGMENT
__local_stdio_printf_options PROC			; COMDAT

; 91   :         static unsigned __int64 _OptionsStorage;
; 92   :         return &_OptionsStorage;

  00000	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:?_OptionsStorage@?1??__local_stdio_printf_options@@9@9 ; `__local_stdio_printf_options'::`2'::_OptionsStorage

; 93   :     }

  00007	c3		 ret	 0
__local_stdio_printf_options ENDP
_TEXT	ENDS
END
