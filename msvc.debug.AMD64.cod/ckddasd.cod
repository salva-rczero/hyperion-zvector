; Listing generated by Microsoft (R) Optimizing Compiler Version 19.34.31937.0 

include listing.inc

INCLUDELIB MSVCRTD
INCLUDELIB OLDNAMES

PUBLIC	ckd_dasd_init_handler
PUBLIC	ckd_dasd_execute_ccw
PUBLIC	ckd_dasd_close_device
PUBLIC	ckd_dasd_query_device
PUBLIC	ckd_dasd_hsuspend
PUBLIC	ckd_dasd_hresume
PUBLIC	ckd_dasd_device_hndinfo
PUBLIC	ckd_dasd_start
PUBLIC	ckd_dasd_end
PUBLIC	ckd_dasd_used
_DATA	SEGMENT
ckd_dasd_device_hndinfo DQ FLAT:ckd_dasd_init_handler
	DQ	FLAT:ckd_dasd_execute_ccw
	DQ	FLAT:ckd_dasd_close_device
	DQ	FLAT:ckd_dasd_query_device
	DQ	0000000000000000H
	DQ	FLAT:ckd_dasd_start
	DQ	FLAT:ckd_dasd_end
	DQ	FLAT:ckd_dasd_start
	DQ	FLAT:ckd_dasd_end
	DQ	0000000000000000H
	DQ	FLAT:ckd_dasd_read_track
	DQ	FLAT:ckd_dasd_update_track
	DQ	FLAT:ckd_dasd_used
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	FLAT:ckd_dasd_hsuspend
	DQ	FLAT:ckd_dasd_hresume
_DATA	ENDS
CONST	SEGMENT
CKD_ENDTRK DB	0ffH
	DB	0ffH
	DB	0ffH
	DB	0ffH
	DB	0ffH
	DB	0ffH
	DB	0ffH
	DB	0ffH
VOL1_KEYA DB	056H
	DB	04fH
	DB	04cH
	DB	031H
VOL1_KEY DB	0e5H
	DB	0d6H
	DB	0d3H
	DB	0f1H
IPL1_KEY DB	0c9H
	DB	0d7H
	DB	0d3H
	DB	0f1H
IPL2_KEY DB	0c9H
	DB	0d7H
	DB	0d3H
	DB	0f2H
iplpsw	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
iplccw1	DB	06H
	DB	00H
	DB	03aH
	DB	098H
	DB	060H
	DB	00H
	DB	00H
	DB	060H
iplccw2	DB	08H
	DB	00H
	DB	03aH
	DB	098H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
noiplpsw DB	00H
	DB	02H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	0fH
noiplccw1 DB	03H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	01H
noiplccw2 DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
ipl2data DB	07H
	DB	00H
	DB	03aH
	DB	0b8H
	DB	040H
	DB	00H
	DB	00H
	DB	06H
	DB	031H
	DB	00H
	DB	03aH
	DB	0beH
	DB	040H
	DB	00H
	DB	00H
	DB	05H
	DB	08H
	DB	00H
	DB	03aH
	DB	0a0H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	06H
	DB	00H
	DB	00H
	DB	00H
	DB	020H
	DB	00H
	DB	07fH
	DB	0ffH
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	04H
	ORG $+5
eighthex00 DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
?nulls@?BL@??ckd_dasd_init_handler@@9@9	ORG $+12	; `ckd_dasd_init_handler'::`27'::nulls
CONST	ENDS
PUBLIC	__local_stdio_printf_options
PUBLIC	__local_stdio_scanf_options
PUBLIC	_vsnprintf_l
PUBLIC	_vsprintf_l
PUBLIC	_vsnprintf_s_l
PUBLIC	_vsnprintf_s
PUBLIC	sprintf
PUBLIC	_vsscanf_l
PUBLIC	sscanf
PUBLIC	fetch_hw_noswap
PUBLIC	store_hw_noswap
PUBLIC	fetch_fw_noswap
PUBLIC	store_fw_noswap
PUBLIC	fetch_dw_noswap
PUBLIC	store_dw_noswap
PUBLIC	ckd_build_sense
PUBLIC	ckddasd_purge_cache
PUBLIC	ckd_trklen
EXTRN	__report_rangecheckfailure:PROC
EXTRN	__imp_isprint:PROC
EXTRN	__imp__errno:PROC
EXTRN	memmove:PROC
EXTRN	strchr:PROC
EXTRN	strrchr:PROC
EXTRN	strcmp:PROC
EXTRN	__imp__stricmp:PROC
EXTRN	strlen:PROC
EXTRN	__imp_IsDebuggerPresent:PROC
EXTRN	__imp_OutputDebugStringA:PROC
EXTRN	__imp_free:PROC
EXTRN	__imp_malloc:PROC
EXTRN	_byteswap_ushort:PROC
EXTRN	_byteswap_ulong:PROC
EXTRN	_byteswap_uint64:PROC
EXTRN	__imp__lseeki64:PROC
EXTRN	__imp_close:PROC
EXTRN	__imp_read:PROC
EXTRN	__imp_write:PROC
EXTRN	__imp___acrt_iob_func:PROC
EXTRN	__imp_fread:PROC
EXTRN	__imp___stdio_common_vsprintf:PROC
EXTRN	__imp___stdio_common_vsnprintf_s:PROC
EXTRN	__imp___stdio_common_vsscanf:PROC
EXTRN	__imp__fstat64:PROC
EXTRN	__imp__stat64:PROC
EXTRN	__imp_hthread_obtain_lock:PROC
EXTRN	__imp_hthread_release_lock:PROC
EXTRN	__imp_strlcpy:PROC
EXTRN	__imp_rtrim:PROC
EXTRN	__imp_is_numeric:PROC
EXTRN	__imp_tf_0423:PROC
EXTRN	__imp_tf_0424:PROC
EXTRN	__imp_tf_0425:PROC
EXTRN	__imp_tf_0426:PROC
EXTRN	__imp_tf_0427:PROC
EXTRN	__imp_tf_0428:PROC
EXTRN	__imp_tf_0429:PROC
EXTRN	__imp_tf_0430:PROC
EXTRN	__imp_tf_0431:PROC
EXTRN	__imp_tf_0432:PROC
EXTRN	__imp_tf_0433:PROC
EXTRN	__imp_tf_0434:PROC
EXTRN	__imp_tf_0435:PROC
EXTRN	__imp_tf_0436:PROC
EXTRN	__imp_tf_0437:PROC
EXTRN	__imp_tf_0438:PROC
EXTRN	__imp_tf_0439:PROC
EXTRN	__imp_tf_0440:PROC
EXTRN	__imp_tf_0441:PROC
EXTRN	__imp_tf_0442:PROC
EXTRN	__imp_w32_strerror:PROC
EXTRN	__imp_hostpath:PROC
EXTRN	__imp_w32_fwrite:PROC
EXTRN	__imp_w32_snprintf:PROC
EXTRN	__imp_w32_hopen:PROC
EXTRN	__imp_w32_basename:PROC
EXTRN	__imp_host_to_guest:PROC
EXTRN	__imp_guest_to_host:PROC
EXTRN	__imp_str_guest_to_host:PROC
EXTRN	cache_lookup:PROC
EXTRN	cache_scan:PROC
EXTRN	cache_lock:PROC
EXTRN	cache_unlock:PROC
EXTRN	cache_wait:PROC
EXTRN	cache_getkey:PROC
EXTRN	cache_setkey:PROC
EXTRN	cache_setflag:PROC
EXTRN	cache_setage:PROC
EXTRN	cache_getbuf:PROC
EXTRN	cache_getlen:PROC
EXTRN	cache_release:PROC
EXTRN	dasd_lookup:PROC
EXTRN	dasd_build_ckd_devid:PROC
EXTRN	dasd_build_ckd_devchar:PROC
EXTRN	dasd_build_ckd_config_data:PROC
EXTRN	dasd_build_ckd_subsys_status:PROC
EXTRN	shared_update_notify:PROC
EXTRN	shared_ckd_init:PROC
EXTRN	ckd64_dasd_init_handler:PROC
EXTRN	cckd_dasd_init_handler:PROC
EXTRN	__imp_fwritemsg:PROC
EXTRN	__imp_logmsg:PROC
EXTRN	gen_dasd_serial:PROC
EXTRN	ckd_tracklen:PROC
EXTRN	is_dh_devid_typ:PROC
EXTRN	cckd_sf_parse_sfn:PROC
EXTRN	__GSHandlerCheck:PROC
EXTRN	__security_check_cookie:PROC
EXTRN	memcmp:PROC
EXTRN	__imp_sysblk:BYTE
EXTRN	__ImageBase:BYTE
EXTRN	__security_cookie:QWORD
_DATA	SEGMENT
COMM	?_OptionsStorage@?1??__local_stdio_printf_options@@9@9:QWORD							; `__local_stdio_printf_options'::`2'::_OptionsStorage
COMM	?_OptionsStorage@?1??__local_stdio_scanf_options@@9@9:QWORD							; `__local_stdio_scanf_options'::`2'::_OptionsStorage
_DATA	ENDS
_BSS	SEGMENT
$SG169972 DB	01H DUP (?)
	ALIGN	4

$SG170098 DB	01H DUP (?)
	ALIGN	4

$SG170101 DB	01H DUP (?)
	ALIGN	4

$SG170104 DB	01H DUP (?)
	ALIGN	4

$SG172251 DB	0cH DUP (?)
_BSS	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$_vsnprintf_l DD imagerel $LN5
	DD	imagerel $LN5+118
	DD	imagerel $unwind$_vsnprintf_l
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$_vsprintf_l DD imagerel $LN3
	DD	imagerel $LN3+66
	DD	imagerel $unwind$_vsprintf_l
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$_vsnprintf_s_l DD imagerel $LN5
	DD	imagerel $LN5+127
	DD	imagerel $unwind$_vsnprintf_s_l
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$_vsnprintf_s DD imagerel $LN3
	DD	imagerel $LN3+73
	DD	imagerel $unwind$_vsnprintf_s
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$sprintf DD imagerel $LN3
	DD	imagerel $LN3+79
	DD	imagerel $unwind$sprintf
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$_vsscanf_l DD imagerel $LN3
	DD	imagerel $LN3+80
	DD	imagerel $unwind$_vsscanf_l
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$sscanf DD imagerel $LN3
	DD	imagerel $LN3+79
	DD	imagerel $unwind$sscanf
pdata	ENDS
pdata	SEGMENT
$pdata$DebuggerTrace DD imagerel DebuggerTrace
	DD	imagerel DebuggerTrace+247
	DD	imagerel $unwind$DebuggerTrace
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$fetch_hw_noswap DD imagerel $LN3
	DD	imagerel $LN3+30
	DD	imagerel $unwind$fetch_hw_noswap
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$fetch_fw_noswap DD imagerel $LN3
	DD	imagerel $LN3+27
	DD	imagerel $unwind$fetch_fw_noswap
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$fetch_dw_noswap DD imagerel $LN3
	DD	imagerel $LN3+30
	DD	imagerel $unwind$fetch_dw_noswap
pdata	ENDS
pdata	SEGMENT
$pdata$ckd_build_sense DD imagerel $LN32
	DD	imagerel $LN32+1471
	DD	imagerel $unwind$ckd_build_sense
$pdata$ckd_dasd_init_handler DD imagerel $LN202
	DD	imagerel $LN202+10573
	DD	imagerel $unwind$ckd_dasd_init_handler
$pdata$ckd_dasd_execute_ccw DD imagerel $LN785
	DD	imagerel $LN785+43630
	DD	imagerel $unwind$ckd_dasd_execute_ccw
$pdata$ckd_dasd_close_device DD imagerel $LN13
	DD	imagerel $LN13+530
	DD	imagerel $unwind$ckd_dasd_close_device
$pdata$ckd_dasd_query_device DD imagerel $LN21
	DD	imagerel $LN21+809
	DD	imagerel $unwind$ckd_dasd_query_device
$pdata$ckd_dasd_hsuspend DD imagerel $LN160
	DD	imagerel $LN160+2328
	DD	imagerel $unwind$ckd_dasd_hsuspend
$pdata$ckd_dasd_hresume DD imagerel $LN217
	DD	imagerel $LN217+3344
	DD	imagerel $unwind$ckd_dasd_hresume
$pdata$sr_write_hdr DD imagerel sr_write_hdr
	DD	imagerel sr_write_hdr+199
	DD	imagerel $unwind$sr_write_hdr
$pdata$sr_write_value DD imagerel sr_write_value
	DD	imagerel sr_write_value+378
	DD	imagerel $unwind$sr_write_value
$pdata$sr_read_hdr DD imagerel sr_read_hdr
	DD	imagerel sr_read_hdr+221
	DD	imagerel $unwind$sr_read_hdr
$pdata$sr_read_value DD imagerel sr_read_value
	DD	imagerel sr_read_value+588
	DD	imagerel $unwind$sr_read_value
$pdata$sr_read_skip DD imagerel sr_read_skip
	DD	imagerel sr_read_skip+248
	DD	imagerel $unwind$sr_read_skip
$pdata$sr_write_error_ DD imagerel sr_write_error_
	DD	imagerel sr_write_error_+121
	DD	imagerel $unwind$sr_write_error_
$pdata$sr_read_error_ DD imagerel sr_read_error_
	DD	imagerel sr_read_error_+121
	DD	imagerel $unwind$sr_read_error_
$pdata$sr_value_error_ DD imagerel sr_value_error_
	DD	imagerel sr_value_error_+80
	DD	imagerel $unwind$sr_value_error_
$pdata$ckddasd_purge_cache DD imagerel $LN10
	DD	imagerel $LN10+138
	DD	imagerel $unwind$ckddasd_purge_cache
$pdata$ckd_dasd_read_track DD imagerel ckd_dasd_read_track
	DD	imagerel ckd_dasd_read_track+6899
	DD	imagerel $unwind$ckd_dasd_read_track
$pdata$ckd_read_cchh DD imagerel ckd_read_cchh
	DD	imagerel ckd_read_cchh+168
	DD	imagerel $unwind$ckd_read_cchh
$pdata$ckd_trklen DD imagerel $LN4
	DD	imagerel $LN4+74
	DD	imagerel $unwind$ckd_trklen
$pdata$ckd_dasd_update_track DD imagerel ckd_dasd_update_track
	DD	imagerel ckd_dasd_update_track+508
	DD	imagerel $unwind$ckd_dasd_update_track
$pdata$ckd_dasd_end DD imagerel $LN3
	DD	imagerel $LN3+44
	DD	imagerel $unwind$ckd_dasd_end
$pdata$ckd_seek DD imagerel ckd_seek
	DD	imagerel ckd_seek+605
	DD	imagerel $unwind$ckd_seek
$pdata$mt_advance DD imagerel mt_advance
	DD	imagerel mt_advance+1348
	DD	imagerel $unwind$mt_advance
$pdata$ckd_read_count DD imagerel ckd_read_count
	DD	imagerel ckd_read_count+2968
	DD	imagerel $unwind$ckd_read_count
$pdata$ckd_read_key DD imagerel ckd_read_key
	DD	imagerel ckd_read_key+915
	DD	imagerel $unwind$ckd_read_key
$pdata$ckd_read_data DD imagerel ckd_read_data
	DD	imagerel ckd_read_data+1005
	DD	imagerel $unwind$ckd_read_data
$pdata$ckd_erase DD imagerel ckd_erase
	DD	imagerel ckd_erase+592
	DD	imagerel $unwind$ckd_erase
$pdata$ckd_write_ckd DD imagerel ckd_write_ckd
	DD	imagerel ckd_write_ckd+1825
	DD	imagerel $unwind$ckd_write_ckd
$pdata$ckd_write_kd DD imagerel ckd_write_kd
	DD	imagerel ckd_write_kd+972
	DD	imagerel $unwind$ckd_write_kd
$pdata$ckd_write_data DD imagerel ckd_write_data
	DD	imagerel ckd_write_data+1008
	DD	imagerel $unwind$ckd_write_data
pdata	ENDS
_DATA	SEGMENT
$SG168200 DB	'SR: sr_write_hdr:    key=0x%8.8x, len=0x%8.8x', 0aH, 00H
	ORG $+1
$SG168202 DB	'SR: sr_write_hdr:    key=0x%8.8x, len=0x%8.8x', 0aH, 00H
	ORG $+1
$SG168305 DB	'SR: sr_read_skip:                  len=0x%8.8x', 0aH, 00H
$SG168393 DB	'write()', 00H
$SG168266 DB	'SR: sr_write_value:  key=0x%8.8x, len=0x%8.8x, val=0x%16'
	DB	'.16llx', 0aH, 00H
$SG168268 DB	'SR: sr_write_value:  key=0x%8.8x, len=0x%8.8x, val=0x%16'
	DB	'.16llx', 0aH, 00H
$SG168288 DB	'SR: sr_read_hdr:   key=0x%8.8x, len=0x%8.8x', 0aH, 00H
	ORG $+3
$SG168290 DB	'SR: sr_read_hdr:   key=0x%8.8x, len=0x%8.8x', 0aH, 00H
	ORG $+3
$SG168307 DB	'SR: sr_read_skip:                  len=0x%8.8x', 0aH, 00H
$SG168375 DB	'SR: sr_read_value:              suslen=0x%8.8x, reslen=0'
	DB	'x%8.8x,', 0aH, 00H
	ORG $+7
$SG168385 DB	'                           val=0x%16.16llx', 0aH, 00H
$SG168394 DB	'E', 00H
	ORG $+2
$SG168396 DB	'sr_write_error_', 00H
$SG168397 DB	'C:\papa\MyGit\hyperion-zvector\sr.h', 00H
	ORG $+4
$SG168377 DB	'SR: sr_read_value:              suslen=0x%8.8x, reslen=0'
	DB	'x%8.8x,', 0aH, 00H
	ORG $+3
$SG168399 DB	'read()', 00H
	ORG $+1
$SG168400 DB	'E', 00H
	ORG $+2
$SG168387 DB	'                           val=0x%16.16llx', 0aH, 00H
$SG168411 DB	'E', 00H
	ORG $+2
$SG168395 DB	'HHC02001%s SR: error in function %s: %s', 0aH, 00H
	ORG $+3
$SG169864 DB	'%hx', 00H
$SG168401 DB	'HHC02001%s SR: error in function %s: %s', 0aH, 00H
	ORG $+3
$SG169867 DB	'E', 00H
	ORG $+2
$SG168402 DB	'sr_read_error_', 00H
	ORG $+1
$SG168403 DB	'C:\papa\MyGit\hyperion-zvector\sr.h', 00H
$SG169873 DB	'%s', 00H
	ORG $+1
$SG168412 DB	'HHC02020%s SR: value error, incorrect length', 0aH, 00H
	ORG $+2
$SG168413 DB	'sr_value_error_', 00H
$SG168414 DB	'C:\papa\MyGit\hyperion-zvector\sr.h', 00H
	ORG $+4
$SG169868 DB	'HHC00400%s %1d:%04X CKD file: name missing or invalid fi'
	DB	'lename length', 0aH, 00H
	ORG $+1
$SG169869 DB	'ckd_dasd_init_handler', 00H
	ORG $+2
$SG169870 DB	'ckddasd.c', 00H
	ORG $+2
$SG169874 DB	'''%s''', 00H
	ORG $+3
$SG169878 DB	'E', 00H
	ORG $+2
$SG169879 DB	'HHC00401%s %1d:%04X CKD file %s: open error: not found', 0aH
	DB	00H
$SG169880 DB	'ckd_dasd_init_handler', 00H
	ORG $+2
$SG169881 DB	'ckddasd.c', 00H
	ORG $+2
$SG169897 DB	'noftio', 00H
	ORG $+1
$SG169902 DB	'ro', 00H
	ORG $+1
$SG169885 DB	'lazywrite', 00H
	ORG $+2
$SG169901 DB	'rdonly', 00H
	ORG $+1
$SG169907 DB	'fw', 00H
	ORG $+1
$SG169887 DB	'nolazywrite', 00H
$SG169909 DB	'sf=', 00H
$SG169890 DB	'fulltrackio', 00H
$SG169911 DB	'cu=', 00H
$SG169891 DB	'fulltrkio', 00H
	ORG $+2
$SG169892 DB	'ftio', 00H
	ORG $+3
$SG169915 DB	'E', 00H
	ORG $+2
$SG169895 DB	'nofulltrackio', 00H
	ORG $+2
$SG169896 DB	'nofulltrkio', 00H
$SG169923 DB	'E', 00H
	ORG $+2
$SG169900 DB	'readonly', 00H
	ORG $+3
$SG169922 DB	'open()', 00H
	ORG $+1
$SG169928 DB	'E', 00H
	ORG $+2
$SG169905 DB	'fakewrite', 00H
	ORG $+2
$SG169934 DB	'E', 00H
	ORG $+2
$SG169906 DB	'fakewrt', 00H
$SG169913 DB	'ser=', 00H
	ORG $+3
$SG169917 DB	'ckd_dasd_init_handler', 00H
	ORG $+2
$SG169916 DB	'HHC00402%s %1d:%04X CKD file: parameter %s in argument %'
	DB	'd is invalid', 0aH, 00H
	ORG $+2
$SG169918 DB	'ckddasd.c', 00H
	ORG $+2
$SG169941 DB	'read()', 00H
	ORG $+1
$SG169942 DB	'E', 00H
	ORG $+2
$SG169924 DB	'HHC00404%s %1d:%04X CKD file %s: error in function %s: %'
	DB	's', 0aH, 00H
	ORG $+1
$SG169948 DB	'E', 00H
	ORG $+2
$SG169925 DB	'ckd_dasd_init_handler', 00H
	ORG $+2
$SG169926 DB	'ckddasd.c', 00H
	ORG $+6
$SG169930 DB	'ckd_dasd_init_handler', 00H
	ORG $+2
$SG169929 DB	'HHC00405%s %1d:%04X CKD file %s: only one base file is a'
	DB	'llowed', 0aH, 00H
$SG169931 DB	'ckddasd.c', 00H
	ORG $+2
$SG169947 DB	'read()', 00H
	ORG $+1
$SG169957 DB	'E', 00H
	ORG $+2
$SG169933 DB	'fstat()', 00H
$SG169935 DB	'HHC00404%s %1d:%04X CKD file %s: error in function %s: %'
	DB	's', 0aH, 00H
	ORG $+1
$SG169964 DB	'CKD', 00H
$SG169936 DB	'ckd_dasd_init_handler', 00H
	ORG $+2
$SG169937 DB	'ckddasd.c', 00H
	ORG $+2
$SG169965 DB	'E', 00H
	ORG $+2
$SG169943 DB	'HHC00404%s %1d:%04X CKD file %s: error in function %s: %'
	DB	's', 0aH, 00H
	ORG $+1
$SG169974 DB	'CKD', 00H
$SG169944 DB	'ckd_dasd_init_handler', 00H
	ORG $+2
$SG169945 DB	'ckddasd.c', 00H
	ORG $+2
$SG169975 DB	'I', 00H
	ORG $+2
$SG169946 DB	'CKD header incomplete', 00H
	ORG $+2
$SG169949 DB	'HHC00404%s %1d:%04X CKD file %s: error in function %s: %'
	DB	's', 0aH, 00H
	ORG $+1
$SG169984 DB	'E', 00H
	ORG $+2
$SG169950 DB	'ckd_dasd_init_handler', 00H
	ORG $+2
$SG169951 DB	'ckddasd.c', 00H
	ORG $+2
$SG169983 DB	'read()', 00H
	ORG $+1
$SG169990 DB	'E', 00H
	ORG $+2
$SG169958 DB	'HHC00406%s %1d:%04X CKD file %s: ckd header invalid', 0aH
	DB	00H
	ORG $+3
$SG169959 DB	'ckd_dasd_init_handler', 00H
	ORG $+2
$SG169960 DB	'ckddasd.c', 00H
	ORG $+2
$SG169963 DB	'CCKD', 00H
	ORG $+3
$SG169989 DB	'read()', 00H
	ORG $+1
$SG170003 DB	'CKD', 00H
$SG169966 DB	'HHC00407%s %1d:%04X %s file %s: only 1 CCKD file allowed'
	DB	0aH, 00H
	ORG $+2
$SG170004 DB	'E', 00H
	ORG $+2
$SG169967 DB	'ckd_dasd_init_handler', 00H
	ORG $+2
$SG169968 DB	'ckddasd.c', 00H
	ORG $+2
$SG170011 DB	'CKD', 00H
$SG169971 DB	' with fake writing', 00H
	ORG $+1
$SG169973 DB	'CCKD', 00H
	ORG $+3
$SG170012 DB	'I', 00H
	ORG $+2
$SG169976 DB	'HHC00403%s %1d:%04X %s file %s: opened r/o%s', 0aH, 00H
	ORG $+2
$SG169977 DB	'ckd_dasd_init_handler', 00H
	ORG $+2
$SG169978 DB	'ckddasd.c', 00H
	ORG $+2
$SG170021 DB	'CKD', 00H
$SG169985 DB	'HHC00404%s %1d:%04X CKD file %s: error in function %s: %'
	DB	's', 0aH, 00H
	ORG $+1
$SG170022 DB	'E', 00H
	ORG $+2
$SG169986 DB	'ckd_dasd_init_handler', 00H
	ORG $+2
$SG169987 DB	'ckddasd.c', 00H
	ORG $+2
$SG170029 DB	'CKD', 00H
$SG169988 DB	'CCKD header incomplete', 00H
	ORG $+1
$SG169991 DB	'HHC00404%s %1d:%04X CKD file %s: error in function %s: %'
	DB	's', 0aH, 00H
	ORG $+1
$SG170030 DB	'E', 00H
	ORG $+2
$SG169992 DB	'ckd_dasd_init_handler', 00H
	ORG $+2
$SG169993 DB	'ckddasd.c', 00H
	ORG $+2
$SG170002 DB	'CCKD', 00H
	ORG $+7
$SG170006 DB	'ckd_dasd_init_handler', 00H
	ORG $+2
$SG170005 DB	'HHC00408%s %1d:%04X %s file %s: ckd file out of sequence'
	DB	' or bad size', 0aH, 00H
	ORG $+2
$SG170007 DB	'ckddasd.c', 00H
	ORG $+2
$SG170010 DB	'CCKD', 00H
	ORG $+3
$SG170036 DB	'CKD', 00H
$SG170013 DB	'HHC00409%s %1d:%04X %s file %s: seq %02d cyls %6d-%-6d', 0aH
	DB	00H
$SG170014 DB	'ckd_dasd_init_handler', 00H
	ORG $+2
$SG170015 DB	'ckddasd.c', 00H
	ORG $+2
$SG170020 DB	'CCKD', 00H
	ORG $+7
$SG170024 DB	'ckd_dasd_init_handler', 00H
	ORG $+2
$SG170023 DB	'HHC00410%s %1d:%04X %s file %s: found heads %d trklen %d'
	DB	', expected heads %d trklen %d', 0aH, 00H
	ORG $+1
$SG170025 DB	'ckddasd.c', 00H
	ORG $+2
$SG170028 DB	'CCKD', 00H
	ORG $+7
$SG170031 DB	'HHC00411%s %1d:%04X %s file %s: ckd header inconsistent '
	DB	'with file size', 0aH, 00H
$SG170032 DB	'ckd_dasd_init_handler', 00H
	ORG $+2
$SG170033 DB	'ckddasd.c', 00H
	ORG $+2
$SG170035 DB	'CCKD', 00H
	ORG $+3
$SG170037 DB	'E', 00H
	ORG $+2
$SG170039 DB	'ckd_dasd_init_handler', 00H
	ORG $+2
$SG170038 DB	'HHC00412%s %1d:%04X %s file %s: ckd header high cylinder'
	DB	' incorrect', 0aH, 00H
$SG170046 DB	'CKD', 00H
$SG170040 DB	'ckddasd.c', 00H
	ORG $+2
$SG170045 DB	'CCKD', 00H
	ORG $+3
$SG170047 DB	'E', 00H
	ORG $+2
$SG170048 DB	'HHC00413%s %1d:%04X %s file %s: maximum CKD files exceed'
	DB	'ed: %d', 0aH, 00H
$SG170049 DB	'ckd_dasd_init_handler', 00H
	ORG $+2
$SG170050 DB	'ckddasd.c', 00H
	ORG $+2
$SG170052 DB	'E', 00H
	ORG $+2
$SG170054 DB	'ckd_dasd_init_handler', 00H
	ORG $+2
$SG170053 DB	'HHC00415%s %1d:%04X CKD file %s: device type %4.4X not f'
	DB	'ound in dasd table', 0aH, 00H
$SG170058 DB	'CKD', 00H
$SG170055 DB	'ckddasd.c', 00H
	ORG $+2
$SG170057 DB	'CCKD', 00H
	ORG $+3
$SG170059 DB	'I', 00H
	ORG $+2
$SG170061 DB	'ckd_dasd_init_handler', 00H
	ORG $+2
$SG170060 DB	'HHC00414%s %1d:%04X %s file %s: model %s cyls %d heads %'
	DB	'd tracks %d trklen %d', 0aH, 00H
	ORG $+1
$SG170062 DB	'ckddasd.c', 00H
	ORG $+2
$SG170064 DB	'CCKD', 00H
	ORG $+3
$SG170065 DB	'CKD', 00H
$SG170066 DB	'E', 00H
	ORG $+6
$SG170067 DB	'HHC00416%s %1d:%04X %s file %s: control unit %s not foun'
	DB	'd in dasd table', 0aH, 00H
	ORG $+3
$SG170092 DB	'.', 00H
	ORG $+2
$SG170068 DB	'ckd_dasd_init_handler', 00H
	ORG $+2
$SG170069 DB	'ckddasd.c', 00H
	ORG $+2
$SG170086 DB	'DASD', 00H
	ORG $+3
$SG170097 DB	'*64* ', 00H
	ORG $+2
$SG170146 DB	'I', 00H
	ORG $+2
$SG170099 DB	'%s%s [%d cyls] [%d segs] IO[%llu]', 00H
	ORG $+2
$SG170100 DB	'*64* ', 00H
	ORG $+2
$SG170239 DB	'I', 00H
	ORG $+2
$SG170102 DB	'%s%s [%d cyls] IO[%llu]', 00H
$SG170103 DB	'*64* ', 00H
	ORG $+2
$SG170105 DB	'%s%s [%d cyls] [%d sfs] IO[%llu]', 00H
	ORG $+7
$SG170147 DB	'HHC00417%s %1d:%04X CKD file %s: cache hits %d, misses %'
	DB	'd, waits %d', 0aH, 00H
	ORG $+3
$SG170148 DB	'ckd_dasd_close_device', 00H
	ORG $+2
$SG170149 DB	'ckddasd.c', 00H
	ORG $+2
$SG170249 DB	'I', 00H
	ORG $+2
$SG170240 DB	'HHC00424%s %1d:%04X CKD file %s: read trk %d cur trk %d', 0aH
	DB	00H
	ORG $+3
$SG170255 DB	'E', 00H
	ORG $+2
$SG170241 DB	'ckd_dasd_read_track', 00H
$SG170261 DB	'E', 00H
	ORG $+2
$SG170242 DB	'ckddasd.c', 00H
	ORG $+2
$SG170271 DB	'I', 00H
	ORG $+2
$SG170250 DB	'HHC00425%s %1d:%04X CKD file %s: read track updating tra'
	DB	'ck %d', 0aH, 00H
	ORG $+1
$SG170251 DB	'ckd_dasd_read_track', 00H
$SG170280 DB	'I', 00H
	ORG $+2
$SG170252 DB	'ckddasd.c', 00H
	ORG $+2
$SG170287 DB	'I', 00H
	ORG $+2
$SG170254 DB	'lseek()', 00H
$SG170256 DB	'HHC00404%s %1d:%04X CKD file %s: error in function %s: %'
	DB	's', 0aH, 00H
	ORG $+1
$SG170295 DB	'I', 00H
	ORG $+2
$SG170257 DB	'ckd_dasd_read_track', 00H
$SG170301 DB	'E', 00H
	ORG $+2
$SG170258 DB	'ckddasd.c', 00H
	ORG $+2
$SG170309 DB	'read()', 00H
	ORG $+1
$SG170310 DB	'E', 00H
	ORG $+2
$SG170260 DB	'write()', 00H
$SG170262 DB	'HHC00404%s %1d:%04X CKD file %s: error in function %s: %'
	DB	's', 0aH, 00H
	ORG $+1
$SG170317 DB	'I', 00H
	ORG $+2
$SG170263 DB	'ckd_dasd_read_track', 00H
$SG170323 DB	'E', 00H
	ORG $+2
$SG170264 DB	'ckddasd.c', 00H
	ORG $+6
$SG170273 DB	'ckd_dasd_read_track', 00H
	ORG $+4
$SG170272 DB	'HHC00426%s %1d:%04X CKD file %s: read trk %d cache hit, '
	DB	'using cache[%d]', 0aH, 00H
	ORG $+3
$SG171136 DB	'I', 00H
	ORG $+2
$SG170274 DB	'ckddasd.c', 00H
	ORG $+6
$SG170281 DB	'HHC00427%s %1d:%04X CKD file %s: read trk %d no availabl'
	DB	'e cache entry, waiting', 0aH, 00H
$SG170282 DB	'ckd_dasd_read_track', 00H
$SG171166 DB	'E', 00H
	ORG $+2
$SG170283 DB	'ckddasd.c', 00H
	ORG $+6
$SG170289 DB	'ckd_dasd_read_track', 00H
	ORG $+4
$SG170288 DB	'HHC00428%s %1d:%04X CKD file %s: read trk %d cache miss,'
	DB	' using cache[%d]', 0aH, 00H
	ORG $+2
$SG171178 DB	'I', 00H
	ORG $+2
$SG170290 DB	'ckddasd.c', 00H
	ORG $+6
$SG170296 DB	'HHC00429%s %1d:%04X CKD file %s: read trk %d reading fil'
	DB	'e %d offset %lld len %d', 0aH, 00H
	ORG $+3
$SG171226 DB	'index', 00H
	ORG $+2
$SG171230 DB	'key', 00H
$SG170297 DB	'ckd_dasd_read_track', 00H
$SG171234 DB	'eot', 00H
$SG170298 DB	'ckddasd.c', 00H
	ORG $+2
$SG171239 DB	'I', 00H
	ORG $+2
$SG170300 DB	'lseek()', 00H
$SG170302 DB	'HHC00404%s %1d:%04X CKD file %s: error in function %s: %'
	DB	's', 0aH, 00H
	ORG $+1
$SG171249 DB	'E', 00H
	ORG $+2
$SG170303 DB	'ckd_dasd_read_track', 00H
$SG171258 DB	'I', 00H
	ORG $+2
$SG170304 DB	'ckddasd.c', 00H
	ORG $+2
$SG171298 DB	'I', 00H
	ORG $+2
$SG170308 DB	'unexpected end of file', 00H
	ORG $+1
$SG170311 DB	'HHC00404%s %1d:%04X CKD file %s: error in function %s: %'
	DB	's', 0aH, 00H
	ORG $+1
$SG171304 DB	'E', 00H
	ORG $+2
$SG170312 DB	'ckd_dasd_read_track', 00H
$SG171329 DB	'I', 00H
	ORG $+2
$SG170313 DB	'ckddasd.c', 00H
	ORG $+6
$SG170319 DB	'ckd_dasd_read_track', 00H
	ORG $+4
$SG170318 DB	'HHC00430%s %1d:%04X CKD file %s: read trk %d trkhdr %02X'
	DB	' %02X%02X %02X%02X', 0aH, 00H
$SG171335 DB	'E', 00H
	ORG $+2
$SG170320 DB	'ckddasd.c', 00H
	ORG $+6
$SG170324 DB	'HHC00418%s %1d:%04X CKD file %s: invalid track header fo'
	DB	'r cyl %d head %d %02X %02X%02X %02X%02X', 0aH, 00H
	ORG $+3
$SG171228 DB	'count', 00H
	ORG $+2
$SG171418 DB	'I', 00H
	ORG $+2
$SG170325 DB	'ckd_dasd_read_track', 00H
$SG171426 DB	'I', 00H
	ORG $+2
$SG170326 DB	'ckddasd.c', 00H
	ORG $+2
$SG171451 DB	'E', 00H
	ORG $+2
$SG171137 DB	'HHC00431%s %1d:%04X CKD file %s: seeking to cyl %d head '
	DB	'%d', 0aH, 00H
$SG171458 DB	'I', 00H
	ORG $+2
$SG171138 DB	'ckd_seek', 00H
	ORG $+3
$SG171480 DB	'E', 00H
	ORG $+2
$SG171139 DB	'ckddasd.c', 00H
	ORG $+6
$SG171168 DB	'mt_advance', 00H
	ORG $+1
$SG171224 DB	'none', 00H
	ORG $+7
$SG171167 DB	'HHC00432%s %1d:%04X CKD file %s: error: MT advance: loca'
	DB	'te record %d file mask %02X', 0aH, 00H
	ORG $+3
$SG171169 DB	'ckddasd.c', 00H
	ORG $+6
$SG171180 DB	'mt_advance', 00H
	ORG $+1
$SG171232 DB	'data', 00H
	ORG $+7
$SG171179 DB	'HHC00433%s %1d:%04X CKD file %s: MT advance to cyl(%d) h'
	DB	'ead(%d)', 0aH, 00H
	ORG $+3
$SG171488 DB	'I', 00H
	ORG $+2
$SG171181 DB	'ckddasd.c', 00H
	ORG $+2
$SG171680 DB	'E', 00H
	ORG $+2
$SG171240 DB	'HHC00434%s %1d:%04X CKD file %s: read count orientation '
	DB	'%s', 0aH, 00H
$SG171894 DB	'I', 00H
	ORG $+2
$SG171241 DB	'ckd_read_count', 00H
	ORG $+1
$SG171242 DB	'ckddasd.c', 00H
	ORG $+6
$SG171251 DB	'ckd_read_count', 00H
	ORG $+1
$SG171299 DB	'HHC00436%s %1d:%04X CKD file %s: read key %d bytes', 0aH
	DB	00H
	ORG $+4
$SG171250 DB	'HHC00419%s %1d:%04X CKD file %s: error attempting to rea'
	DB	'd past end of track %d %d', 0aH, 00H
	ORG $+1
$SG171926 DB	'I', 00H
	ORG $+2
$SG171252 DB	'ckddasd.c', 00H
	ORG $+6
$SG171260 DB	'ckd_read_count', 00H
	ORG $+1
$SG171330 DB	'HHC00437%s %1d:%04X CKD file %s: read data %d bytes', 0aH
	DB	00H
	ORG $+3
$SG171259 DB	'HHC00435%s %1d:%04X CKD file %s: cyl %d head %d record %'
	DB	'd kl %d dl %d of %d', 0aH, 00H
	ORG $+3
$SG171261 DB	'ckddasd.c', 00H
	ORG $+2
$SG171925 DB	' ', 09H, 0aH, 0bH, 0cH, 0dH, 00H
	ORG $+5
$SG171300 DB	'ckd_read_key', 00H
	ORG $+3
$SG171301 DB	'ckddasd.c', 00H
	ORG $+14
$SG171305 DB	'HHC00419%s %1d:%04X CKD file %s: error attempting to rea'
	DB	'd past end of track %d %d', 0aH, 00H
	ORG $+5
$SG171306 DB	'ckd_read_key', 00H
	ORG $+3
$SG171307 DB	'ckddasd.c', 00H
	ORG $+6
$SG171331 DB	'ckd_read_data', 00H
	ORG $+2
$SG171332 DB	'ckddasd.c', 00H
	ORG $+14
$SG171336 DB	'HHC00419%s %1d:%04X CKD file %s: error attempting to rea'
	DB	'd past end of track %d %d', 0aH, 00H
	ORG $+5
$SG171337 DB	'ckd_read_data', 00H
	ORG $+2
$SG171338 DB	'ckddasd.c', 00H
	ORG $+14
$SG171419 DB	'HHC00438%s %1d:%04X CKD file %s: writing cyl %d head %d '
	DB	'record %d kl %d dl %d', 0aH, 00H
	ORG $+1
$SG171420 DB	'ckd_write_ckd', 00H
	ORG $+2
$SG171421 DB	'ckddasd.c', 00H
	ORG $+6
$SG171427 DB	'HHC00439%s %1d:%04X CKD file %s: setting track overflow '
	DB	'flag for cyl %d head %d record %d', 0aH, 00H
	ORG $+5
$SG171428 DB	'ckd_write_ckd', 00H
	ORG $+2
$SG171429 DB	'ckddasd.c', 00H
	ORG $+6
$SG171452 DB	'HHC00420%s %1d:%04X CKD file %s: error write kd orientat'
	DB	'ion', 0aH, 00H
	ORG $+3
$SG171453 DB	'ckd_write_kd', 00H
	ORG $+3
$SG171454 DB	'ckddasd.c', 00H
	ORG $+6
$SG171459 DB	'HHC00440%s %1d:%04X CKD file %s: updating cyl %d head %d'
	DB	' record %d kl %d dl %d', 0aH, 00H
$SG171460 DB	'ckd_write_kd', 00H
	ORG $+3
$SG171461 DB	'ckddasd.c', 00H
	ORG $+6
$SG171481 DB	'HHC00421%s %1d:%04X CKD file %s: error write data orient'
	DB	'ation', 0aH, 00H
	ORG $+1
$SG171482 DB	'ckd_write_data', 00H
	ORG $+1
$SG171483 DB	'ckddasd.c', 00H
	ORG $+6
$SG171489 DB	'HHC00441%s %1d:%04X CKD file %s: updating cyl %d head %d'
	DB	' record %d dl %d', 0aH, 00H
	ORG $+6
$SG171490 DB	'ckd_write_data', 00H
	ORG $+1
$SG171491 DB	'ckddasd.c', 00H
	ORG $+6
$SG171681 DB	'HHC00422%s %1d:%04X CKD file %s: data chaining not suppo'
	DB	'rted for non-read CCW %02X', 0aH, 00H
	ORG $+4
$SG171682 DB	'ckd_dasd_execute_ccw', 00H
	ORG $+3
$SG171683 DB	'ckddasd.c', 00H
	ORG $+6
$SG171858 DB	'00%4.4X   HRCZZ000000000001', 00H
	ORG $+4
$SG171895 DB	'HHC00442%s %1d:%04X CKD file %s: set file mask %02X', 0aH
	DB	00H
	ORG $+3
$SG171896 DB	'ckd_dasd_execute_ccw', 00H
	ORG $+3
$SG171897 DB	'ckddasd.c', 00H
	ORG $+6
$SG171927 DB	'HHC00423%s %1d:%04X CKD file %s: search key %s', 0aH, 00H
$SG171928 DB	'ckd_dasd_execute_ccw', 00H
	ORG $+3
$SG171929 DB	'ckddasd.c', 00H
	ORG $+6
$SG172029 DB	'DEBUG : WR0 OUTSIDE PACK', 0aH, 00H
	ORG $+6
$SG172031 DB	'DEBUG : WR0 CASE 2', 0aH, 00H
	ORG $+4
$SG172033 DB	'DEBUG : WR0 BAD FM', 0aH, 00H
	ORG $+4
$SG172037 DB	'DEBUG : LOC REC 2', 0aH, 00H
	ORG $+5
$SG172227 DB	'ckddasd.c:5835', 00H
	ORG $+1
$SG172228 DB	'ckddasd.c:5837', 00H
	ORG $+1
$SG172233 DB	'ckddasd.c:5862', 00H
	ORG $+1
$SG172234 DB	'ckddasd.c:5864', 00H
_DATA	ENDS
voltbl	SEGMENT
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:ckd_write_ckd
	DD	027H
	DD	0707H
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:ckd_erase
	DD	024H
	DD	023cH
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:ckd_read_data
	DD	026H
	DD	03d3H
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:ckd_read_key
	DD	026H
	DD	0379H
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:ckd_read_count
	DD	024H
	DD	0b80H
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:sr_read_skip
	DD	01aH
	DD	0e0H
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:sr_read_value
	DD	021H
	DD	023aH
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:sr_read_hdr
	DD	01dH
	DD	0cbH
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:sr_write_value
	DD	021H
	DD	0168H
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:sr_write_hdr
	DD	01cH
	DD	0b5H
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:ckd_dasd_query_device
	DD	025H
	DD	0311H
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:ckd_dasd_execute_ccw
	DD	026H
	DD	0a7d6H
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:ckd_dasd_init_handler
	DD	021H
	DD	02933H
voltbl	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$fetch_dw_noswap DD 010901H
	DD	02209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$fetch_fw_noswap DD 010901H
	DD	02209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$fetch_hw_noswap DD 010901H
	DD	02209H
xdata	ENDS
xdata	SEGMENT
$unwind$DebuggerTrace DD 011801H
	DD	0a218H
$unwind$ckd_build_sense DD 021801H
	DD	070147218H
$unwind$ckd_dasd_init_handler DD 042919H
	DD	0f30117H
	DD	0600f7010H
	DD	imagerel __GSHandlerCheck
	DD	0780H
$unwind$ckd_dasd_execute_ccw DD 042e19H
	DD	075011cH
	DD	060147015H
	DD	imagerel __GSHandlerCheck
	DD	0390H
$unwind$ckd_dasd_close_device DD 020c01H
	DD	013010cH
$unwind$ckd_dasd_query_device DD 022d19H
	DD	033011bH
	DD	imagerel __GSHandlerCheck
	DD	0180H
$unwind$ckd_dasd_hsuspend DD 010e01H
	DD	0420eH
$unwind$ckd_dasd_hresume DD 010e01H
	DD	0a20eH
$unwind$sr_write_hdr DD 012119H
	DD	06212H
	DD	imagerel __GSHandlerCheck
	DD	028H
$unwind$sr_write_value DD 012619H
	DD	08217H
	DD	imagerel __GSHandlerCheck
	DD	030H
$unwind$sr_read_hdr DD 012219H
	DD	06213H
	DD	imagerel __GSHandlerCheck
	DD	028H
$unwind$sr_read_value DD 012619H
	DD	0c217H
	DD	imagerel __GSHandlerCheck
	DD	058H
$unwind$sr_read_skip DD 022219H
	DD	02b0110H
	DD	imagerel __GSHandlerCheck
	DD	0140H
$unwind$sr_write_error_ DD 010401H
	DD	0c204H
$unwind$sr_read_error_ DD 010401H
	DD	0c204H
$unwind$sr_value_error_ DD 010401H
	DD	08204H
$unwind$ckddasd_purge_cache DD 011701H
	DD	06217H
$unwind$ckd_dasd_read_track DD 031601H
	DD	03a0116H
	DD	0700fH
$unwind$ckd_read_cchh DD 011701H
	DD	08217H
$unwind$ckd_trklen DD 010e01H
	DD	0620eH
$unwind$ckd_dasd_update_track DD 031901H
	DD	070158219H
	DD	06014H
$unwind$ckd_dasd_end DD 010901H
	DD	06209H
$unwind$ckd_seek DD 041c01H
	DD	011011cH
	DD	060147015H
$unwind$mt_advance DD 021601H
	DD	0150116H
$unwind$ckd_read_count DD 022c19H
	DD	023011aH
	DD	imagerel __GSHandlerCheck
	DD	0108H
$unwind$ckd_read_key DD 042e19H
	DD	015011cH
	DD	060147015H
	DD	imagerel __GSHandlerCheck
	DD	090H
$unwind$ckd_read_data DD 042e19H
	DD	015011cH
	DD	060147015H
	DD	imagerel __GSHandlerCheck
	DD	090H
$unwind$ckd_erase DD 032919H
	DD	07016c21aH
	DD	06015H
	DD	imagerel __GSHandlerCheck
	DD	050H
$unwind$ckd_write_ckd DD 042f19H
	DD	01b011dH
	DD	060157016H
	DD	imagerel __GSHandlerCheck
	DD	0c8H
$unwind$ckd_write_kd DD 021b01H
	DD	017011bH
$unwind$ckd_write_data DD 021b01H
	DD	015011bH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$sscanf DD 011801H
	DD	06218H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$_vsscanf_l DD 011801H
	DD	06218H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$sprintf DD 011801H
	DD	06218H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$_vsnprintf_s DD 011801H
	DD	06218H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$_vsnprintf_s_l DD 011801H
	DD	0a218H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$_vsprintf_l DD 011801H
	DD	06218H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$_vsnprintf_l DD 011801H
	DD	08218H
xdata	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\ckddasd.c
_TEXT	SEGMENT
tv73 = 112
tv79 = 116
tv153 = 120
tv164 = 124
tv168 = 128
rc$ = 132
tv68 = 136
tv161 = 144
tv202 = 152
dev$ = 176
buf$ = 184
len$ = 192
unitstat$ = 200
ckd_write_data PROC

; 2139 : {

  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	48 81 ec a8 00
	00 00		 sub	 rsp, 168		; 000000a8H

; 2140 : int             rc;                     /* Return code               */
; 2141 : 
; 2142 :     /* Unit check if not oriented to count or key areas */
; 2143 :     if (dev->ckdorient != CKDORIENT_COUNT
; 2144 :         && dev->ckdorient != CKDORIENT_KEY)

  0001b	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00023	83 b8 d8 12 00
	00 02		 cmp	 DWORD PTR [rax+4824], 2
  0002a	0f 84 0f 01 00
	00		 je	 $LN7@ckd_write_
  00030	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00038	83 b8 d8 12 00
	00 03		 cmp	 DWORD PTR [rax+4824], 3
  0003f	0f 84 fa 00 00
	00		 je	 $LN7@ckd_write_

; 2145 :     {
; 2146 :         // "%1d:%04X CKD file %s: error write data orientation"
; 2147 :         WRMSG( HHC00421, "E", LCSS_DEVNUM, dev->filename );

  00045	48 83 bc 24 b0
	00 00 00 00	 cmp	 QWORD PTR dev$[rsp], 0
  0004e	74 12		 je	 SHORT $LN14@ckd_write_
  00050	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00058	0f b7 40 48	 movzx	 eax, WORD PTR [rax+72]
  0005c	89 44 24 70	 mov	 DWORD PTR tv73[rsp], eax
  00060	eb 08		 jmp	 SHORT $LN15@ckd_write_
$LN14@ckd_write_:
  00062	c7 44 24 70 00
	00 00 00	 mov	 DWORD PTR tv73[rsp], 0
$LN15@ckd_write_:
  0006a	48 83 bc 24 b0
	00 00 00 00	 cmp	 QWORD PTR dev$[rsp], 0
  00073	74 14		 je	 SHORT $LN16@ckd_write_
  00075	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  0007d	0f b7 40 44	 movzx	 eax, WORD PTR [rax+68]
  00081	d1 f8		 sar	 eax, 1
  00083	89 44 24 74	 mov	 DWORD PTR tv79[rsp], eax
  00087	eb 08		 jmp	 SHORT $LN17@ckd_write_
$LN16@ckd_write_:
  00089	c7 44 24 74 00
	00 00 00	 mov	 DWORD PTR tv79[rsp], 0
$LN17@ckd_write_:
  00091	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00099	48 05 a4 00 00
	00		 add	 rax, 164		; 000000a4H
  0009f	48 89 84 24 88
	00 00 00	 mov	 QWORD PTR tv68[rsp], rax
  000a7	b9 01 00 00 00	 mov	 ecx, 1
  000ac	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  000b2	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR tv68[rsp]
  000ba	48 89 4c 24 48	 mov	 QWORD PTR [rsp+72], rcx
  000bf	8b 4c 24 70	 mov	 ecx, DWORD PTR tv73[rsp]
  000c3	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  000c7	8b 4c 24 74	 mov	 ecx, DWORD PTR tv79[rsp]
  000cb	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  000cf	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG171480
  000d6	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  000db	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG171481
  000e2	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  000e7	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  000ec	41 b9 03 00 00
	00		 mov	 r9d, 3
  000f2	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG171482
  000f9	ba 63 08 00 00	 mov	 edx, 2147		; 00000863H
  000fe	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG171483
  00105	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 2148 :         ckd_build_sense (dev, SENSE_CR, 0, 0,

  0010b	c6 44 24 28 02	 mov	 BYTE PTR [rsp+40], 2
  00110	c6 44 24 20 00	 mov	 BYTE PTR [rsp+32], 0
  00115	45 33 c9	 xor	 r9d, r9d
  00118	45 33 c0	 xor	 r8d, r8d
  0011b	b2 80		 mov	 dl, 128			; 00000080H
  0011d	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  00125	e8 00 00 00 00	 call	 ckd_build_sense

; 2149 :                         FORMAT_0, MESSAGE_2);
; 2150 :         *unitstat = CSW_CE | CSW_DE | CSW_UC;

  0012a	48 8b 84 24 c8
	00 00 00	 mov	 rax, QWORD PTR unitstat$[rsp]
  00132	c6 00 0e	 mov	 BYTE PTR [rax], 14

; 2151 :         return -1;

  00135	b8 ff ff ff ff	 mov	 eax, -1
  0013a	e9 a9 02 00 00	 jmp	 $LN1@ckd_write_
$LN7@ckd_write_:

; 2152 :     }
; 2153 : 
; 2154 :     /* If oriented to count field, skip the key field */
; 2155 :     if (dev->ckdorient == CKDORIENT_COUNT)

  0013f	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00147	83 b8 d8 12 00
	00 02		 cmp	 DWORD PTR [rax+4824], 2
  0014e	75 2a		 jne	 SHORT $LN8@ckd_write_

; 2156 :         dev->bufoff += dev->ckdcurkl;

  00150	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00158	8b 80 e0 01 00
	00		 mov	 eax, DWORD PTR [rax+480]
  0015e	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  00166	03 81 d4 12 00
	00		 add	 eax, DWORD PTR [rcx+4820]
  0016c	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  00174	89 81 e0 01 00
	00		 mov	 DWORD PTR [rcx+480], eax
$LN8@ckd_write_:
$LN2@ckd_write_:

; 2157 : 
; 2158 :     /* Pad the I/O buffer with zeroes if necessary */
; 2159 :     while (len < dev->ckdcurdl) buf[len++] = '\0';

  0017a	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00182	0f b7 80 ea 12
	00 00		 movzx	 eax, WORD PTR [rax+4842]
  00189	39 84 24 c0 00
	00 00		 cmp	 DWORD PTR len$[rsp], eax
  00190	7d 26		 jge	 SHORT $LN3@ckd_write_
  00192	48 63 84 24 c0
	00 00 00	 movsxd	 rax, DWORD PTR len$[rsp]
  0019a	48 8b 8c 24 b8
	00 00 00	 mov	 rcx, QWORD PTR buf$[rsp]
  001a2	c6 04 01 00	 mov	 BYTE PTR [rcx+rax], 0
  001a6	8b 84 24 c0 00
	00 00		 mov	 eax, DWORD PTR len$[rsp]
  001ad	ff c0		 inc	 eax
  001af	89 84 24 c0 00
	00 00		 mov	 DWORD PTR len$[rsp], eax
  001b6	eb c2		 jmp	 SHORT $LN2@ckd_write_
$LN3@ckd_write_:

; 2160 : 
; 2161 :     // "%1d:%04X CKD file %s: updating cyl %d head %d record %d dl %d"
; 2162 :     if (dev->ccwtrace && sysblk.traceFILE)

  001b8	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  001c0	8b 80 f8 05 00
	00		 mov	 eax, DWORD PTR [rax+1528]
  001c6	c1 e8 0f	 shr	 eax, 15
  001c9	83 e0 01	 and	 eax, 1
  001cc	85 c0		 test	 eax, eax
  001ce	74 24		 je	 SHORT $LN9@ckd_write_
  001d0	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  001d7	48 83 b8 20 14
	00 00 00	 cmp	 QWORD PTR [rax+5152], 0
  001df	74 13		 je	 SHORT $LN9@ckd_write_

; 2163 :         tf_0441( dev );

  001e1	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  001e9	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_tf_0441
  001ef	e9 1d 01 00 00	 jmp	 $LN10@ckd_write_
$LN9@ckd_write_:
$LN6@ckd_write_:

; 2164 :     else
; 2165 :         LOGDEVTR( HHC00441, "I",  dev->filename,

  001f4	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  001fc	8b 80 f8 05 00
	00		 mov	 eax, DWORD PTR [rax+1528]
  00202	c1 e8 0f	 shr	 eax, 15
  00205	83 e0 01	 and	 eax, 1
  00208	85 c0		 test	 eax, eax
  0020a	0f 84 f7 00 00
	00		 je	 $LN11@ckd_write_
  00210	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00218	0f b7 80 ea 12
	00 00		 movzx	 eax, WORD PTR [rax+4842]
  0021f	89 44 24 78	 mov	 DWORD PTR tv153[rsp], eax
  00223	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  0022b	48 81 c1 a4 00
	00 00		 add	 rcx, 164		; 000000a4H
  00232	48 89 8c 24 90
	00 00 00	 mov	 QWORD PTR tv161[rsp], rcx
  0023a	48 8b 94 24 b0
	00 00 00	 mov	 rdx, QWORD PTR dev$[rsp]
  00242	0f b7 52 48	 movzx	 edx, WORD PTR [rdx+72]
  00246	89 54 24 7c	 mov	 DWORD PTR tv164[rsp], edx
  0024a	4c 8b 84 24 b0
	00 00 00	 mov	 r8, QWORD PTR dev$[rsp]
  00252	45 0f b7 40 44	 movzx	 r8d, WORD PTR [r8+68]
  00257	41 d1 f8	 sar	 r8d, 1
  0025a	44 89 84 24 80
	00 00 00	 mov	 DWORD PTR tv168[rsp], r8d
  00262	b9 01 00 00 00	 mov	 ecx, 1
  00267	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  0026d	8b 4c 24 78	 mov	 ecx, DWORD PTR tv153[rsp]
  00271	89 4c 24 68	 mov	 DWORD PTR [rsp+104], ecx
  00275	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  0027d	8b 89 d0 12 00
	00		 mov	 ecx, DWORD PTR [rcx+4816]
  00283	89 4c 24 60	 mov	 DWORD PTR [rsp+96], ecx
  00287	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  0028f	8b 89 cc 12 00
	00		 mov	 ecx, DWORD PTR [rcx+4812]
  00295	89 4c 24 58	 mov	 DWORD PTR [rsp+88], ecx
  00299	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  002a1	8b 89 c8 12 00
	00		 mov	 ecx, DWORD PTR [rcx+4808]
  002a7	89 4c 24 50	 mov	 DWORD PTR [rsp+80], ecx
  002ab	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR tv161[rsp]
  002b3	48 89 4c 24 48	 mov	 QWORD PTR [rsp+72], rcx
  002b8	8b 4c 24 7c	 mov	 ecx, DWORD PTR tv164[rsp]
  002bc	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  002c0	8b 8c 24 80 00
	00 00		 mov	 ecx, DWORD PTR tv168[rsp]
  002c7	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  002cb	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG171488
  002d2	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  002d7	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG171489
  002de	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  002e3	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  002e8	41 b9 03 00 00
	00		 mov	 r9d, 3
  002ee	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG171490
  002f5	ba 76 08 00 00	 mov	 edx, 2166		; 00000876H
  002fa	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG171491
  00301	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg
$LN11@ckd_write_:
  00307	33 c0		 xor	 eax, eax
  00309	85 c0		 test	 eax, eax
  0030b	0f 85 e3 fe ff
	ff		 jne	 $LN6@ckd_write_
$LN10@ckd_write_:

; 2166 :                   dev->ckdcurcyl, dev->ckdcurhead, dev->ckdcurrec, dev->ckdcurdl );
; 2167 : 
; 2168 :     /* Write data */
; 2169 :     rc = (dev->hnd->write) (dev, dev->bufcur, dev->bufoff, buf, dev->ckdcurdl, unitstat);

  00311	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00319	0f b7 80 ea 12
	00 00		 movzx	 eax, WORD PTR [rax+4842]
  00320	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  00328	48 8b 89 90 02
	00 00		 mov	 rcx, QWORD PTR [rcx+656]
  0032f	48 89 8c 24 98
	00 00 00	 mov	 QWORD PTR tv202[rsp], rcx
  00337	48 8b 94 24 c8
	00 00 00	 mov	 rdx, QWORD PTR unitstat$[rsp]
  0033f	48 89 54 24 28	 mov	 QWORD PTR [rsp+40], rdx
  00344	89 44 24 20	 mov	 DWORD PTR [rsp+32], eax
  00348	4c 8b 8c 24 b8
	00 00 00	 mov	 r9, QWORD PTR buf$[rsp]
  00350	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00358	44 8b 80 e0 01
	00 00		 mov	 r8d, DWORD PTR [rax+480]
  0035f	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00367	8b 90 c0 01 00
	00		 mov	 edx, DWORD PTR [rax+448]
  0036d	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  00375	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR tv202[rsp]
  0037d	ff 50 58	 call	 QWORD PTR [rax+88]
  00380	89 84 24 84 00
	00 00		 mov	 DWORD PTR rc$[rsp], eax

; 2170 :     if (rc < 0) return -1;

  00387	83 bc 24 84 00
	00 00 00	 cmp	 DWORD PTR rc$[rsp], 0
  0038f	7d 07		 jge	 SHORT $LN12@ckd_write_
  00391	b8 ff ff ff ff	 mov	 eax, -1
  00396	eb 50		 jmp	 SHORT $LN1@ckd_write_
$LN12@ckd_write_:

; 2171 :     dev->bufoff += dev->ckdcurdl;

  00398	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  003a0	0f b7 80 ea 12
	00 00		 movzx	 eax, WORD PTR [rax+4842]
  003a7	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  003af	03 81 e0 01 00
	00		 add	 eax, DWORD PTR [rcx+480]
  003b5	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  003bd	89 81 e0 01 00
	00		 mov	 DWORD PTR [rcx+480], eax

; 2172 : 
; 2173 :     /* Set the device orientation fields */
; 2174 :     dev->ckdrem = 0;

  003c3	33 c0		 xor	 eax, eax
  003c5	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  003cd	66 89 81 ec 12
	00 00		 mov	 WORD PTR [rcx+4844], ax

; 2175 :     dev->ckdorient = CKDORIENT_DATA;

  003d4	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  003dc	c7 80 d8 12 00
	00 04 00 00 00	 mov	 DWORD PTR [rax+4824], 4

; 2176 : 
; 2177 :     return 0;

  003e6	33 c0		 xor	 eax, eax
$LN1@ckd_write_:

; 2178 : } /* end function ckd_write_data */

  003e8	48 81 c4 a8 00
	00 00		 add	 rsp, 168		; 000000a8H
  003ef	c3		 ret	 0
ckd_write_data ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\ckddasd.c
_TEXT	SEGMENT
kdlen$ = 128
tv71 = 132
tv77 = 136
tv147 = 140
tv160 = 144
tv164 = 148
rc$ = 152
tv66 = 160
tv157 = 168
dev$ = 192
buf$ = 200
len$ = 208
unitstat$ = 216
ckd_write_kd PROC

; 2092 : {

  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	48 81 ec b8 00
	00 00		 sub	 rsp, 184		; 000000b8H

; 2093 : int             rc;                     /* Return code               */
; 2094 : int             kdlen;                  /* Key+data length           */
; 2095 : 
; 2096 :     /* Unit check if not oriented to count area */
; 2097 :     if (dev->ckdorient != CKDORIENT_COUNT)

  0001b	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00023	83 b8 d8 12 00
	00 02		 cmp	 DWORD PTR [rax+4824], 2
  0002a	0f 84 0c 01 00
	00		 je	 $LN7@ckd_write_

; 2098 :     {
; 2099 :         // "%1d:%04X CKD file %s: error write kd orientation"
; 2100 :         WRMSG( HHC00420, "E", LCSS_DEVNUM, dev->filename );

  00030	48 83 bc 24 c0
	00 00 00 00	 cmp	 QWORD PTR dev$[rsp], 0
  00039	74 15		 je	 SHORT $LN13@ckd_write_
  0003b	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00043	0f b7 40 48	 movzx	 eax, WORD PTR [rax+72]
  00047	89 84 24 84 00
	00 00		 mov	 DWORD PTR tv71[rsp], eax
  0004e	eb 0b		 jmp	 SHORT $LN14@ckd_write_
$LN13@ckd_write_:
  00050	c7 84 24 84 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv71[rsp], 0
$LN14@ckd_write_:
  0005b	48 83 bc 24 c0
	00 00 00 00	 cmp	 QWORD PTR dev$[rsp], 0
  00064	74 17		 je	 SHORT $LN15@ckd_write_
  00066	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  0006e	0f b7 40 44	 movzx	 eax, WORD PTR [rax+68]
  00072	d1 f8		 sar	 eax, 1
  00074	89 84 24 88 00
	00 00		 mov	 DWORD PTR tv77[rsp], eax
  0007b	eb 0b		 jmp	 SHORT $LN16@ckd_write_
$LN15@ckd_write_:
  0007d	c7 84 24 88 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv77[rsp], 0
$LN16@ckd_write_:
  00088	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00090	48 05 a4 00 00
	00		 add	 rax, 164		; 000000a4H
  00096	48 89 84 24 a0
	00 00 00	 mov	 QWORD PTR tv66[rsp], rax
  0009e	b9 01 00 00 00	 mov	 ecx, 1
  000a3	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  000a9	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR tv66[rsp]
  000b1	48 89 4c 24 48	 mov	 QWORD PTR [rsp+72], rcx
  000b6	8b 8c 24 84 00
	00 00		 mov	 ecx, DWORD PTR tv71[rsp]
  000bd	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  000c1	8b 8c 24 88 00
	00 00		 mov	 ecx, DWORD PTR tv77[rsp]
  000c8	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  000cc	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG171451
  000d3	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  000d8	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG171452
  000df	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  000e4	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  000e9	41 b9 03 00 00
	00		 mov	 r9d, 3
  000ef	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG171453
  000f6	ba 34 08 00 00	 mov	 edx, 2100		; 00000834H
  000fb	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG171454
  00102	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 2101 :         ckd_build_sense (dev, SENSE_CR, 0, 0,

  00108	c6 44 24 28 02	 mov	 BYTE PTR [rsp+40], 2
  0010d	c6 44 24 20 00	 mov	 BYTE PTR [rsp+32], 0
  00112	45 33 c9	 xor	 r9d, r9d
  00115	45 33 c0	 xor	 r8d, r8d
  00118	b2 80		 mov	 dl, 128			; 00000080H
  0011a	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  00122	e8 00 00 00 00	 call	 ckd_build_sense

; 2102 :                         FORMAT_0, MESSAGE_2);
; 2103 :         *unitstat = CSW_CE | CSW_DE | CSW_UC;

  00127	48 8b 84 24 d8
	00 00 00	 mov	 rax, QWORD PTR unitstat$[rsp]
  0012f	c6 00 0e	 mov	 BYTE PTR [rax], 14

; 2104 :         return -1;

  00132	b8 ff ff ff ff	 mov	 eax, -1
  00137	e9 88 02 00 00	 jmp	 $LN1@ckd_write_
$LN7@ckd_write_:

; 2105 :     }
; 2106 : 
; 2107 :     /* Calculate total key and data size */
; 2108 :     kdlen = dev->ckdcurkl + dev->ckdcurdl;

  0013c	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00144	0f b7 80 ea 12
	00 00		 movzx	 eax, WORD PTR [rax+4842]
  0014b	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  00153	03 81 d4 12 00
	00		 add	 eax, DWORD PTR [rcx+4820]
  00159	89 84 24 80 00
	00 00		 mov	 DWORD PTR kdlen$[rsp], eax
$LN2@ckd_write_:

; 2109 : 
; 2110 :     /* Pad the I/O buffer with zeroes if necessary */
; 2111 :     while (len < kdlen) buf[len++] = '\0';

  00160	8b 84 24 80 00
	00 00		 mov	 eax, DWORD PTR kdlen$[rsp]
  00167	39 84 24 d0 00
	00 00		 cmp	 DWORD PTR len$[rsp], eax
  0016e	7d 26		 jge	 SHORT $LN3@ckd_write_
  00170	48 63 84 24 d0
	00 00 00	 movsxd	 rax, DWORD PTR len$[rsp]
  00178	48 8b 8c 24 c8
	00 00 00	 mov	 rcx, QWORD PTR buf$[rsp]
  00180	c6 04 01 00	 mov	 BYTE PTR [rcx+rax], 0
  00184	8b 84 24 d0 00
	00 00		 mov	 eax, DWORD PTR len$[rsp]
  0018b	ff c0		 inc	 eax
  0018d	89 84 24 d0 00
	00 00		 mov	 DWORD PTR len$[rsp], eax
  00194	eb ca		 jmp	 SHORT $LN2@ckd_write_
$LN3@ckd_write_:

; 2112 : 
; 2113 :     // "%1d:%04X CKD file %s: updating cyl %d head %d record %d kl %d dl %d"
; 2114 :     if (dev->ccwtrace && sysblk.traceFILE)

  00196	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  0019e	8b 80 f8 05 00
	00		 mov	 eax, DWORD PTR [rax+1528]
  001a4	c1 e8 0f	 shr	 eax, 15
  001a7	83 e0 01	 and	 eax, 1
  001aa	85 c0		 test	 eax, eax
  001ac	74 24		 je	 SHORT $LN8@ckd_write_
  001ae	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  001b5	48 83 b8 20 14
	00 00 00	 cmp	 QWORD PTR [rax+5152], 0
  001bd	74 13		 je	 SHORT $LN8@ckd_write_

; 2115 :         tf_0440( dev );

  001bf	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  001c7	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_tf_0440
  001cd	e9 3b 01 00 00	 jmp	 $LN9@ckd_write_
$LN8@ckd_write_:
$LN6@ckd_write_:

; 2116 :     else
; 2117 :         LOGDEVTR( HHC00440, "I",  dev->filename,

  001d2	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  001da	8b 80 f8 05 00
	00		 mov	 eax, DWORD PTR [rax+1528]
  001e0	c1 e8 0f	 shr	 eax, 15
  001e3	83 e0 01	 and	 eax, 1
  001e6	85 c0		 test	 eax, eax
  001e8	0f 84 15 01 00
	00		 je	 $LN10@ckd_write_
  001ee	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  001f6	0f b7 80 ea 12
	00 00		 movzx	 eax, WORD PTR [rax+4842]
  001fd	89 84 24 8c 00
	00 00		 mov	 DWORD PTR tv147[rsp], eax
  00204	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  0020c	48 81 c1 a4 00
	00 00		 add	 rcx, 164		; 000000a4H
  00213	48 89 8c 24 a8
	00 00 00	 mov	 QWORD PTR tv157[rsp], rcx
  0021b	48 8b 94 24 c0
	00 00 00	 mov	 rdx, QWORD PTR dev$[rsp]
  00223	0f b7 52 48	 movzx	 edx, WORD PTR [rdx+72]
  00227	89 94 24 90 00
	00 00		 mov	 DWORD PTR tv160[rsp], edx
  0022e	4c 8b 84 24 c0
	00 00 00	 mov	 r8, QWORD PTR dev$[rsp]
  00236	45 0f b7 40 44	 movzx	 r8d, WORD PTR [r8+68]
  0023b	41 d1 f8	 sar	 r8d, 1
  0023e	44 89 84 24 94
	00 00 00	 mov	 DWORD PTR tv164[rsp], r8d
  00246	b9 01 00 00 00	 mov	 ecx, 1
  0024b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  00251	8b 8c 24 8c 00
	00 00		 mov	 ecx, DWORD PTR tv147[rsp]
  00258	89 4c 24 70	 mov	 DWORD PTR [rsp+112], ecx
  0025c	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  00264	8b 89 d4 12 00
	00		 mov	 ecx, DWORD PTR [rcx+4820]
  0026a	89 4c 24 68	 mov	 DWORD PTR [rsp+104], ecx
  0026e	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  00276	8b 89 d0 12 00
	00		 mov	 ecx, DWORD PTR [rcx+4816]
  0027c	89 4c 24 60	 mov	 DWORD PTR [rsp+96], ecx
  00280	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  00288	8b 89 cc 12 00
	00		 mov	 ecx, DWORD PTR [rcx+4812]
  0028e	89 4c 24 58	 mov	 DWORD PTR [rsp+88], ecx
  00292	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  0029a	8b 89 c8 12 00
	00		 mov	 ecx, DWORD PTR [rcx+4808]
  002a0	89 4c 24 50	 mov	 DWORD PTR [rsp+80], ecx
  002a4	48 8b 8c 24 a8
	00 00 00	 mov	 rcx, QWORD PTR tv157[rsp]
  002ac	48 89 4c 24 48	 mov	 QWORD PTR [rsp+72], rcx
  002b1	8b 8c 24 90 00
	00 00		 mov	 ecx, DWORD PTR tv160[rsp]
  002b8	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  002bc	8b 8c 24 94 00
	00 00		 mov	 ecx, DWORD PTR tv164[rsp]
  002c3	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  002c7	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG171458
  002ce	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  002d3	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG171459
  002da	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  002df	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  002e4	41 b9 03 00 00
	00		 mov	 r9d, 3
  002ea	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG171460
  002f1	ba 47 08 00 00	 mov	 edx, 2119		; 00000847H
  002f6	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG171461
  002fd	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg
$LN10@ckd_write_:
  00303	33 c0		 xor	 eax, eax
  00305	85 c0		 test	 eax, eax
  00307	0f 85 c5 fe ff
	ff		 jne	 $LN6@ckd_write_
$LN9@ckd_write_:

; 2118 :                   dev->ckdcurcyl, dev->ckdcurhead, dev->ckdcurrec,
; 2119 :                   dev->ckdcurkl,  dev->ckdcurdl );
; 2120 : 
; 2121 :     /* Write key and data */
; 2122 :     rc = (dev->hnd->write) (dev, dev->bufcur, dev->bufoff, buf, kdlen, unitstat);

  0030d	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00315	48 8b 80 90 02
	00 00		 mov	 rax, QWORD PTR [rax+656]
  0031c	48 8b 8c 24 d8
	00 00 00	 mov	 rcx, QWORD PTR unitstat$[rsp]
  00324	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00329	8b 8c 24 80 00
	00 00		 mov	 ecx, DWORD PTR kdlen$[rsp]
  00330	89 4c 24 20	 mov	 DWORD PTR [rsp+32], ecx
  00334	4c 8b 8c 24 c8
	00 00 00	 mov	 r9, QWORD PTR buf$[rsp]
  0033c	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  00344	44 8b 81 e0 01
	00 00		 mov	 r8d, DWORD PTR [rcx+480]
  0034b	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  00353	8b 91 c0 01 00
	00		 mov	 edx, DWORD PTR [rcx+448]
  00359	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  00361	ff 50 58	 call	 QWORD PTR [rax+88]
  00364	89 84 24 98 00
	00 00		 mov	 DWORD PTR rc$[rsp], eax

; 2123 :     if (rc < 0) return -1;

  0036b	83 bc 24 98 00
	00 00 00	 cmp	 DWORD PTR rc$[rsp], 0
  00373	7d 07		 jge	 SHORT $LN11@ckd_write_
  00375	b8 ff ff ff ff	 mov	 eax, -1
  0037a	eb 48		 jmp	 SHORT $LN1@ckd_write_
$LN11@ckd_write_:

; 2124 :     dev->bufoff += kdlen;

  0037c	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00384	8b 80 e0 01 00
	00		 mov	 eax, DWORD PTR [rax+480]
  0038a	03 84 24 80 00
	00 00		 add	 eax, DWORD PTR kdlen$[rsp]
  00391	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  00399	89 81 e0 01 00
	00		 mov	 DWORD PTR [rcx+480], eax

; 2125 : 
; 2126 :     /* Set the device orientation fields */
; 2127 :     dev->ckdrem = 0;

  0039f	33 c0		 xor	 eax, eax
  003a1	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  003a9	66 89 81 ec 12
	00 00		 mov	 WORD PTR [rcx+4844], ax

; 2128 :     dev->ckdorient = CKDORIENT_DATA;

  003b0	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  003b8	c7 80 d8 12 00
	00 04 00 00 00	 mov	 DWORD PTR [rax+4824], 4

; 2129 : 
; 2130 :     return 0;

  003c2	33 c0		 xor	 eax, eax
$LN1@ckd_write_:

; 2131 : } /* end function ckd_write_kd */

  003c4	48 81 c4 b8 00
	00 00		 add	 rsp, 184		; 000000b8H
  003cb	c3		 ret	 0
ckd_write_kd ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\ckddasd.c
_TEXT	SEGMENT
recnum$ = 128
keylen$ = 129
datalen$ = 132
ckdlen$ = 136
rc$ = 140
tv289 = 144
tv166 = 148
tv168 = 152
tv170 = 156
tv183 = 160
tv209 = 164
tv218 = 168
tv90 = 176
tv215 = 184
rechdr$ = 192
__$ArrayPad$ = 200
dev$ = 240
buf$ = 248
len$ = 256
unitstat$ = 264
trk_ovfl$ = 272
ckd_write_ckd PROC

; 2003 : {

  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	56		 push	 rsi
  00015	57		 push	 rdi
  00016	48 81 ec d8 00
	00 00		 sub	 rsp, 216		; 000000d8H
  0001d	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00024	48 33 c4	 xor	 rax, rsp
  00027	48 89 84 24 c8
	00 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 2004 : int             rc;                     /* Return code               */
; 2005 : CKD_RECHDR      rechdr;                 /* CKD record header         */
; 2006 : BYTE            recnum;                 /* Record number             */
; 2007 : BYTE            keylen;                 /* Key length                */
; 2008 : U16             datalen;                /* Data length               */
; 2009 : U32             ckdlen;                 /* Count+key+data length     */
; 2010 : 
; 2011 :     /* If oriented to count or key field, skip key and data */
; 2012 :     if (dev->ckdorient == CKDORIENT_COUNT)

  0002f	48 8b 84 24 f0
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00037	83 b8 d8 12 00
	00 02		 cmp	 DWORD PTR [rax+4824], 2
  0003e	75 3f		 jne	 SHORT $LN10@ckd_write_

; 2013 :         dev->bufoff += dev->ckdcurkl + dev->ckdcurdl;

  00040	48 8b 84 24 f0
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00048	0f b7 80 ea 12
	00 00		 movzx	 eax, WORD PTR [rax+4842]
  0004f	48 8b 8c 24 f0
	00 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  00057	8b 89 d4 12 00
	00		 mov	 ecx, DWORD PTR [rcx+4820]
  0005d	03 c8		 add	 ecx, eax
  0005f	8b c1		 mov	 eax, ecx
  00061	48 8b 8c 24 f0
	00 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  00069	03 81 e0 01 00
	00		 add	 eax, DWORD PTR [rcx+480]
  0006f	48 8b 8c 24 f0
	00 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  00077	89 81 e0 01 00
	00		 mov	 DWORD PTR [rcx+480], eax
  0007d	eb 3c		 jmp	 SHORT $LN11@ckd_write_
$LN10@ckd_write_:

; 2014 :     else if (dev->ckdorient == CKDORIENT_KEY)

  0007f	48 8b 84 24 f0
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00087	83 b8 d8 12 00
	00 03		 cmp	 DWORD PTR [rax+4824], 3
  0008e	75 2b		 jne	 SHORT $LN12@ckd_write_

; 2015 :         dev->bufoff += dev->ckdcurdl;

  00090	48 8b 84 24 f0
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00098	0f b7 80 ea 12
	00 00		 movzx	 eax, WORD PTR [rax+4842]
  0009f	48 8b 8c 24 f0
	00 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  000a7	03 81 e0 01 00
	00		 add	 eax, DWORD PTR [rcx+480]
  000ad	48 8b 8c 24 f0
	00 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  000b5	89 81 e0 01 00
	00		 mov	 DWORD PTR [rcx+480], eax
$LN12@ckd_write_:
$LN11@ckd_write_:

; 2016 : 
; 2017 :     /* Copy the count field from the buffer */
; 2018 :     memset( &rechdr, 0,          CKD_RECHDR_SIZE );

  000bb	48 8d 84 24 c0
	00 00 00	 lea	 rax, QWORD PTR rechdr$[rsp]
  000c3	48 8b f8	 mov	 rdi, rax
  000c6	33 c0		 xor	 eax, eax
  000c8	b9 08 00 00 00	 mov	 ecx, 8
  000cd	f3 aa		 rep stosb

; 2019 :     memcpy( &rechdr, buf, (len < CKD_RECHDR_SIZE) ?

  000cf	48 63 84 24 00
	01 00 00	 movsxd	 rax, DWORD PTR len$[rsp]
  000d7	48 83 f8 08	 cmp	 rax, 8
  000db	7d 12		 jge	 SHORT $LN25@ckd_write_
  000dd	48 63 84 24 00
	01 00 00	 movsxd	 rax, DWORD PTR len$[rsp]
  000e5	48 89 84 24 b0
	00 00 00	 mov	 QWORD PTR tv90[rsp], rax
  000ed	eb 0c		 jmp	 SHORT $LN26@ckd_write_
$LN25@ckd_write_:
  000ef	48 c7 84 24 b0
	00 00 00 08 00
	00 00		 mov	 QWORD PTR tv90[rsp], 8
$LN26@ckd_write_:
  000fb	48 8d 84 24 c0
	00 00 00	 lea	 rax, QWORD PTR rechdr$[rsp]
  00103	48 8b f8	 mov	 rdi, rax
  00106	48 8b b4 24 f8
	00 00 00	 mov	 rsi, QWORD PTR buf$[rsp]
  0010e	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR tv90[rsp]
  00116	f3 a4		 rep movsb

; 2020 :                            len : CKD_RECHDR_SIZE);
; 2021 : 
; 2022 :     /* Extract the record number, key length and data length */
; 2023 :     recnum  =            rechdr.rec;

  00118	0f b6 84 24 c4
	00 00 00	 movzx	 eax, BYTE PTR rechdr$[rsp+4]
  00120	88 84 24 80 00
	00 00		 mov	 BYTE PTR recnum$[rsp], al

; 2024 :     keylen  =            rechdr.klen;

  00127	0f b6 84 24 c5
	00 00 00	 movzx	 eax, BYTE PTR rechdr$[rsp+5]
  0012f	88 84 24 81 00
	00 00		 mov	 BYTE PTR keylen$[rsp], al

; 2025 :     datalen =  fetch_hw( rechdr.dlen );

  00136	48 8d 8c 24 c6
	00 00 00	 lea	 rcx, QWORD PTR rechdr$[rsp+6]
  0013e	e8 00 00 00 00	 call	 fetch_hw_noswap
  00143	0f b7 c8	 movzx	 ecx, ax
  00146	e8 00 00 00 00	 call	 _byteswap_ushort
  0014b	66 89 84 24 84
	00 00 00	 mov	 WORD PTR datalen$[rsp], ax

; 2026 : 
; 2027 :     /* Calculate total count key and data size */
; 2028 :     ckdlen = CKD_RECHDR_SIZE + keylen + datalen;

  00153	0f b6 84 24 81
	00 00 00	 movzx	 eax, BYTE PTR keylen$[rsp]
  0015b	0f b7 8c 24 84
	00 00 00	 movzx	 ecx, WORD PTR datalen$[rsp]
  00163	48 8d 44 08 08	 lea	 rax, QWORD PTR [rax+rcx+8]
  00168	89 84 24 88 00
	00 00		 mov	 DWORD PTR ckdlen$[rsp], eax

; 2029 : 
; 2030 :     if ((int)(dev->bufoff + ckdlen + CKD_ENDTRK_SIZE) >= dev->bufoffhi)

  0016f	48 8b 84 24 f0
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00177	8b 80 e0 01 00
	00		 mov	 eax, DWORD PTR [rax+480]
  0017d	03 84 24 88 00
	00 00		 add	 eax, DWORD PTR ckdlen$[rsp]
  00184	8b c0		 mov	 eax, eax
  00186	48 83 c0 08	 add	 rax, 8
  0018a	48 8b 8c 24 f0
	00 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  00192	3b 81 e8 01 00
	00		 cmp	 eax, DWORD PTR [rcx+488]
  00198	7c 34		 jl	 SHORT $LN13@ckd_write_

; 2031 :     {
; 2032 :         /* Unit check with invalid track format */
; 2033 :         ckd_build_sense (dev, 0, SENSE1_ITF, 0, 0, 0);

  0019a	c6 44 24 28 00	 mov	 BYTE PTR [rsp+40], 0
  0019f	c6 44 24 20 00	 mov	 BYTE PTR [rsp+32], 0
  001a4	45 33 c9	 xor	 r9d, r9d
  001a7	41 b0 40	 mov	 r8b, 64			; 00000040H
  001aa	33 d2		 xor	 edx, edx
  001ac	48 8b 8c 24 f0
	00 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  001b4	e8 00 00 00 00	 call	 ckd_build_sense

; 2034 :         *unitstat = CSW_CE | CSW_DE | CSW_UC;

  001b9	48 8b 84 24 08
	01 00 00	 mov	 rax, QWORD PTR unitstat$[rsp]
  001c1	c6 00 0e	 mov	 BYTE PTR [rax], 14

; 2035 :         return -1;

  001c4	b8 ff ff ff ff	 mov	 eax, -1
  001c9	e9 39 05 00 00	 jmp	 $LN1@ckd_write_
$LN13@ckd_write_:
$LN2@ckd_write_:

; 2036 :     }
; 2037 : 
; 2038 :     /* Pad the I/O buffer with zeroes if necessary */
; 2039 :     while (len < (int)ckdlen) buf[len++] = '\0';

  001ce	8b 84 24 88 00
	00 00		 mov	 eax, DWORD PTR ckdlen$[rsp]
  001d5	39 84 24 00 01
	00 00		 cmp	 DWORD PTR len$[rsp], eax
  001dc	7d 26		 jge	 SHORT $LN3@ckd_write_
  001de	48 63 84 24 00
	01 00 00	 movsxd	 rax, DWORD PTR len$[rsp]
  001e6	48 8b 8c 24 f8
	00 00 00	 mov	 rcx, QWORD PTR buf$[rsp]
  001ee	c6 04 01 00	 mov	 BYTE PTR [rcx+rax], 0
  001f2	8b 84 24 00 01
	00 00		 mov	 eax, DWORD PTR len$[rsp]
  001f9	ff c0		 inc	 eax
  001fb	89 84 24 00 01
	00 00		 mov	 DWORD PTR len$[rsp], eax
  00202	eb ca		 jmp	 SHORT $LN2@ckd_write_
$LN3@ckd_write_:

; 2040 : 
; 2041 :     // "%1d:%04X CKD file %s: writing cyl %d head %d record %d kl %d dl %d"
; 2042 :     if (dev->ccwtrace && sysblk.traceFILE)

  00204	48 8b 84 24 f0
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  0020c	8b 80 f8 05 00
	00		 mov	 eax, DWORD PTR [rax+1528]
  00212	c1 e8 0f	 shr	 eax, 15
  00215	83 e0 01	 and	 eax, 1
  00218	85 c0		 test	 eax, eax
  0021a	74 3e		 je	 SHORT $LN14@ckd_write_
  0021c	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00223	48 83 b8 20 14
	00 00 00	 cmp	 QWORD PTR [rax+5152], 0
  0022b	74 2d		 je	 SHORT $LN14@ckd_write_

; 2043 :         tf_0438( dev, recnum, keylen, datalen );

  0022d	44 0f b7 8c 24
	84 00 00 00	 movzx	 r9d, WORD PTR datalen$[rsp]
  00236	44 0f b6 84 24
	81 00 00 00	 movzx	 r8d, BYTE PTR keylen$[rsp]
  0023f	0f b6 94 24 80
	00 00 00	 movzx	 edx, BYTE PTR recnum$[rsp]
  00247	48 8b 8c 24 f0
	00 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  0024f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_tf_0438
  00255	e9 26 01 00 00	 jmp	 $LN15@ckd_write_
$LN14@ckd_write_:
$LN6@ckd_write_:

; 2044 :     else
; 2045 :         LOGDEVTR( HHC00438, "I",  dev->filename,

  0025a	48 8b 84 24 f0
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00262	8b 80 f8 05 00
	00		 mov	 eax, DWORD PTR [rax+1528]
  00268	c1 e8 0f	 shr	 eax, 15
  0026b	83 e0 01	 and	 eax, 1
  0026e	85 c0		 test	 eax, eax
  00270	0f 84 00 01 00
	00		 je	 $LN16@ckd_write_
  00276	0f b7 84 24 84
	00 00 00	 movzx	 eax, WORD PTR datalen$[rsp]
  0027e	89 84 24 94 00
	00 00		 mov	 DWORD PTR tv166[rsp], eax
  00285	0f b6 8c 24 81
	00 00 00	 movzx	 ecx, BYTE PTR keylen$[rsp]
  0028d	89 8c 24 98 00
	00 00		 mov	 DWORD PTR tv168[rsp], ecx
  00294	0f b6 94 24 80
	00 00 00	 movzx	 edx, BYTE PTR recnum$[rsp]
  0029c	89 94 24 9c 00
	00 00		 mov	 DWORD PTR tv170[rsp], edx
  002a3	48 8b bc 24 f0
	00 00 00	 mov	 rdi, QWORD PTR dev$[rsp]
  002ab	48 81 c7 a4 00
	00 00		 add	 rdi, 164		; 000000a4H
  002b2	48 8b b4 24 f0
	00 00 00	 mov	 rsi, QWORD PTR dev$[rsp]
  002ba	0f b7 76 48	 movzx	 esi, WORD PTR [rsi+72]
  002be	4c 8b 84 24 f0
	00 00 00	 mov	 r8, QWORD PTR dev$[rsp]
  002c6	45 0f b7 40 44	 movzx	 r8d, WORD PTR [r8+68]
  002cb	41 d1 f8	 sar	 r8d, 1
  002ce	44 89 84 24 a0
	00 00 00	 mov	 DWORD PTR tv183[rsp], r8d
  002d6	b9 01 00 00 00	 mov	 ecx, 1
  002db	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  002e1	8b 8c 24 94 00
	00 00		 mov	 ecx, DWORD PTR tv166[rsp]
  002e8	89 4c 24 70	 mov	 DWORD PTR [rsp+112], ecx
  002ec	8b 8c 24 98 00
	00 00		 mov	 ecx, DWORD PTR tv168[rsp]
  002f3	89 4c 24 68	 mov	 DWORD PTR [rsp+104], ecx
  002f7	8b 8c 24 9c 00
	00 00		 mov	 ecx, DWORD PTR tv170[rsp]
  002fe	89 4c 24 60	 mov	 DWORD PTR [rsp+96], ecx
  00302	48 8b 8c 24 f0
	00 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  0030a	8b 89 cc 12 00
	00		 mov	 ecx, DWORD PTR [rcx+4812]
  00310	89 4c 24 58	 mov	 DWORD PTR [rsp+88], ecx
  00314	48 8b 8c 24 f0
	00 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  0031c	8b 89 c8 12 00
	00		 mov	 ecx, DWORD PTR [rcx+4808]
  00322	89 4c 24 50	 mov	 DWORD PTR [rsp+80], ecx
  00326	48 89 7c 24 48	 mov	 QWORD PTR [rsp+72], rdi
  0032b	89 74 24 40	 mov	 DWORD PTR [rsp+64], esi
  0032f	8b 8c 24 a0 00
	00 00		 mov	 ecx, DWORD PTR tv183[rsp]
  00336	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  0033a	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG171418
  00341	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  00346	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG171419
  0034d	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00352	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00357	41 b9 03 00 00
	00		 mov	 r9d, 3
  0035d	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG171420
  00364	ba fe 07 00 00	 mov	 edx, 2046		; 000007feH
  00369	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG171421
  00370	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg
$LN16@ckd_write_:
  00376	33 c0		 xor	 eax, eax
  00378	85 c0		 test	 eax, eax
  0037a	0f 85 da fe ff
	ff		 jne	 $LN6@ckd_write_
$LN15@ckd_write_:

; 2046 :                   dev->ckdcurcyl, dev->ckdcurhead, recnum, keylen, datalen );
; 2047 : 
; 2048 :     /* Set track overflow flag if called for */
; 2049 :     if (trk_ovfl)

  00380	0f b6 84 24 10
	01 00 00	 movzx	 eax, BYTE PTR trk_ovfl$[rsp]
  00388	85 c0		 test	 eax, eax
  0038a	0f 84 70 01 00
	00		 je	 $LN17@ckd_write_

; 2050 :     {
; 2051 :         // "%1d:%04X CKD file %s: setting track overflow flag for cyl %d head %d record %d"
; 2052 :         if (dev->ccwtrace && sysblk.traceFILE)

  00390	48 8b 84 24 f0
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00398	8b 80 f8 05 00
	00		 mov	 eax, DWORD PTR [rax+1528]
  0039e	c1 e8 0f	 shr	 eax, 15
  003a1	83 e0 01	 and	 eax, 1
  003a4	85 c0		 test	 eax, eax
  003a6	74 2c		 je	 SHORT $LN18@ckd_write_
  003a8	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  003af	48 83 b8 20 14
	00 00 00	 cmp	 QWORD PTR [rax+5152], 0
  003b7	74 1b		 je	 SHORT $LN18@ckd_write_

; 2053 :             tf_0439( dev, recnum );

  003b9	0f b6 94 24 80
	00 00 00	 movzx	 edx, BYTE PTR recnum$[rsp]
  003c1	48 8b 8c 24 f0
	00 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  003c9	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_tf_0439
  003cf	e9 ff 00 00 00	 jmp	 $LN19@ckd_write_
$LN18@ckd_write_:
$LN9@ckd_write_:

; 2054 :         else
; 2055 :             LOGDEVTR( HHC00439, "I",  dev->filename,

  003d4	48 8b 84 24 f0
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  003dc	8b 80 f8 05 00
	00		 mov	 eax, DWORD PTR [rax+1528]
  003e2	c1 e8 0f	 shr	 eax, 15
  003e5	83 e0 01	 and	 eax, 1
  003e8	85 c0		 test	 eax, eax
  003ea	0f 84 d9 00 00
	00		 je	 $LN20@ckd_write_
  003f0	0f b6 84 24 80
	00 00 00	 movzx	 eax, BYTE PTR recnum$[rsp]
  003f8	89 84 24 a4 00
	00 00		 mov	 DWORD PTR tv209[rsp], eax
  003ff	48 8b 8c 24 f0
	00 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  00407	48 81 c1 a4 00
	00 00		 add	 rcx, 164		; 000000a4H
  0040e	48 89 8c 24 b8
	00 00 00	 mov	 QWORD PTR tv215[rsp], rcx
  00416	48 8b 94 24 f0
	00 00 00	 mov	 rdx, QWORD PTR dev$[rsp]
  0041e	0f b7 52 48	 movzx	 edx, WORD PTR [rdx+72]
  00422	89 94 24 a8 00
	00 00		 mov	 DWORD PTR tv218[rsp], edx
  00429	48 8b bc 24 f0
	00 00 00	 mov	 rdi, QWORD PTR dev$[rsp]
  00431	0f b7 7f 44	 movzx	 edi, WORD PTR [rdi+68]
  00435	d1 ff		 sar	 edi, 1
  00437	b9 01 00 00 00	 mov	 ecx, 1
  0043c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  00442	8b 8c 24 a4 00
	00 00		 mov	 ecx, DWORD PTR tv209[rsp]
  00449	89 4c 24 60	 mov	 DWORD PTR [rsp+96], ecx
  0044d	48 8b 8c 24 f0
	00 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  00455	8b 89 cc 12 00
	00		 mov	 ecx, DWORD PTR [rcx+4812]
  0045b	89 4c 24 58	 mov	 DWORD PTR [rsp+88], ecx
  0045f	48 8b 8c 24 f0
	00 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  00467	8b 89 c8 12 00
	00		 mov	 ecx, DWORD PTR [rcx+4808]
  0046d	89 4c 24 50	 mov	 DWORD PTR [rsp+80], ecx
  00471	48 8b 8c 24 b8
	00 00 00	 mov	 rcx, QWORD PTR tv215[rsp]
  00479	48 89 4c 24 48	 mov	 QWORD PTR [rsp+72], rcx
  0047e	8b 8c 24 a8 00
	00 00		 mov	 ecx, DWORD PTR tv218[rsp]
  00485	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  00489	89 7c 24 38	 mov	 DWORD PTR [rsp+56], edi
  0048d	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG171426
  00494	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  00499	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG171427
  004a0	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  004a5	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  004aa	41 b9 03 00 00
	00		 mov	 r9d, 3
  004b0	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG171428
  004b7	ba 08 08 00 00	 mov	 edx, 2056		; 00000808H
  004bc	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG171429
  004c3	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg
$LN20@ckd_write_:
  004c9	33 c0		 xor	 eax, eax
  004cb	85 c0		 test	 eax, eax
  004cd	0f 85 01 ff ff
	ff		 jne	 $LN9@ckd_write_
$LN19@ckd_write_:

; 2056 :                       dev->ckdcurcyl, dev->ckdcurhead, recnum );
; 2057 :         buf[0] |= 0x80;

  004d3	b8 01 00 00 00	 mov	 eax, 1
  004d8	48 6b c0 00	 imul	 rax, rax, 0
  004dc	48 8b 8c 24 f8
	00 00 00	 mov	 rcx, QWORD PTR buf$[rsp]
  004e4	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  004e8	0f ba e8 07	 bts	 eax, 7
  004ec	b9 01 00 00 00	 mov	 ecx, 1
  004f1	48 6b c9 00	 imul	 rcx, rcx, 0
  004f5	48 8b 94 24 f8
	00 00 00	 mov	 rdx, QWORD PTR buf$[rsp]
  004fd	88 04 0a	 mov	 BYTE PTR [rdx+rcx], al
$LN17@ckd_write_:

; 2058 :     }
; 2059 : 
; 2060 :     /* Write count key and data */
; 2061 :     rc = (dev->hnd->write) (dev, dev->bufcur, dev->bufoff, buf, ckdlen, unitstat);

  00500	48 8b 84 24 f0
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00508	48 8b 80 90 02
	00 00		 mov	 rax, QWORD PTR [rax+656]
  0050f	48 8b 8c 24 08
	01 00 00	 mov	 rcx, QWORD PTR unitstat$[rsp]
  00517	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  0051c	8b 8c 24 88 00
	00 00		 mov	 ecx, DWORD PTR ckdlen$[rsp]
  00523	89 4c 24 20	 mov	 DWORD PTR [rsp+32], ecx
  00527	4c 8b 8c 24 f8
	00 00 00	 mov	 r9, QWORD PTR buf$[rsp]
  0052f	48 8b 8c 24 f0
	00 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  00537	44 8b 81 e0 01
	00 00		 mov	 r8d, DWORD PTR [rcx+480]
  0053e	48 8b 8c 24 f0
	00 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  00546	8b 91 c0 01 00
	00		 mov	 edx, DWORD PTR [rcx+448]
  0054c	48 8b 8c 24 f0
	00 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  00554	ff 50 58	 call	 QWORD PTR [rax+88]
  00557	89 84 24 8c 00
	00 00		 mov	 DWORD PTR rc$[rsp], eax

; 2062 :     if (rc < 0) return -1;

  0055e	83 bc 24 8c 00
	00 00 00	 cmp	 DWORD PTR rc$[rsp], 0
  00566	7d 0a		 jge	 SHORT $LN21@ckd_write_
  00568	b8 ff ff ff ff	 mov	 eax, -1
  0056d	e9 95 01 00 00	 jmp	 $LN1@ckd_write_
$LN21@ckd_write_:

; 2063 :     dev->bufoff += ckdlen;

  00572	48 8b 84 24 f0
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  0057a	8b 80 e0 01 00
	00		 mov	 eax, DWORD PTR [rax+480]
  00580	03 84 24 88 00
	00 00		 add	 eax, DWORD PTR ckdlen$[rsp]
  00587	48 8b 8c 24 f0
	00 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  0058f	89 81 e0 01 00
	00		 mov	 DWORD PTR [rcx+480], eax

; 2064 : 
; 2065 :     /* Clear track overflow flag if we set it above */
; 2066 :     if (trk_ovfl)

  00595	0f b6 84 24 10
	01 00 00	 movzx	 eax, BYTE PTR trk_ovfl$[rsp]
  0059d	85 c0		 test	 eax, eax
  0059f	74 2c		 je	 SHORT $LN22@ckd_write_

; 2067 :     {
; 2068 :         buf[0] &= 0x7F;

  005a1	b8 01 00 00 00	 mov	 eax, 1
  005a6	48 6b c0 00	 imul	 rax, rax, 0
  005aa	48 8b 8c 24 f8
	00 00 00	 mov	 rcx, QWORD PTR buf$[rsp]
  005b2	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  005b6	83 e0 7f	 and	 eax, 127		; 0000007fH
  005b9	b9 01 00 00 00	 mov	 ecx, 1
  005be	48 6b c9 00	 imul	 rcx, rcx, 0
  005c2	48 8b 94 24 f8
	00 00 00	 mov	 rdx, QWORD PTR buf$[rsp]
  005ca	88 04 0a	 mov	 BYTE PTR [rdx+rcx], al
$LN22@ckd_write_:

; 2069 :     }
; 2070 : 
; 2071 :     /* Logically erase rest of track by writing end of track marker */
; 2072 :     rc = (dev->hnd->write)( dev, dev->bufcur, dev->bufoff, (BYTE*) &CKD_ENDTRK, CKD_ENDTRK_SIZE, unitstat );

  005cd	48 8b 84 24 f0
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  005d5	48 8b 80 90 02
	00 00		 mov	 rax, QWORD PTR [rax+656]
  005dc	48 8b 8c 24 08
	01 00 00	 mov	 rcx, QWORD PTR unitstat$[rsp]
  005e4	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  005e9	c7 44 24 20 08
	00 00 00	 mov	 DWORD PTR [rsp+32], 8
  005f1	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:CKD_ENDTRK
  005f8	48 8b 8c 24 f0
	00 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  00600	44 8b 81 e0 01
	00 00		 mov	 r8d, DWORD PTR [rcx+480]
  00607	48 8b 8c 24 f0
	00 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  0060f	8b 91 c0 01 00
	00		 mov	 edx, DWORD PTR [rcx+448]
  00615	48 8b 8c 24 f0
	00 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  0061d	ff 50 58	 call	 QWORD PTR [rax+88]
  00620	89 84 24 8c 00
	00 00		 mov	 DWORD PTR rc$[rsp], eax

; 2073 :     if (rc < 0) return -1;

  00627	83 bc 24 8c 00
	00 00 00	 cmp	 DWORD PTR rc$[rsp], 0
  0062f	7d 0a		 jge	 SHORT $LN23@ckd_write_
  00631	b8 ff ff ff ff	 mov	 eax, -1
  00636	e9 cc 00 00 00	 jmp	 $LN1@ckd_write_
$LN23@ckd_write_:

; 2074 : 
; 2075 :     /* Set the device orientation fields */
; 2076 :     dev->ckdcurrec = recnum;

  0063b	0f b6 84 24 80
	00 00 00	 movzx	 eax, BYTE PTR recnum$[rsp]
  00643	48 8b 8c 24 f0
	00 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  0064b	89 81 d0 12 00
	00		 mov	 DWORD PTR [rcx+4816], eax

; 2077 :     dev->ckdcurkl = keylen;

  00651	0f b6 84 24 81
	00 00 00	 movzx	 eax, BYTE PTR keylen$[rsp]
  00659	48 8b 8c 24 f0
	00 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  00661	89 81 d4 12 00
	00		 mov	 DWORD PTR [rcx+4820], eax

; 2078 :     dev->ckdcurdl = datalen;

  00667	48 8b 84 24 f0
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  0066f	0f b7 8c 24 84
	00 00 00	 movzx	 ecx, WORD PTR datalen$[rsp]
  00677	66 89 88 ea 12
	00 00		 mov	 WORD PTR [rax+4842], cx

; 2079 :     dev->ckdrem = 0;

  0067e	33 c0		 xor	 eax, eax
  00680	48 8b 8c 24 f0
	00 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  00688	66 89 81 ec 12
	00 00		 mov	 WORD PTR [rcx+4844], ax

; 2080 :     dev->ckdorient = CKDORIENT_DATA;

  0068f	48 8b 84 24 f0
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00697	c7 80 d8 12 00
	00 04 00 00 00	 mov	 DWORD PTR [rax+4824], 4

; 2081 :     dev->ckdtrkof = dev->ckdcyls < 32768 ? trk_ovfl & 1 : 0;

  006a1	48 8b 84 24 f0
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  006a9	81 b8 b8 12 00
	00 00 80 00 00	 cmp	 DWORD PTR [rax+4792], 32768 ; 00008000H
  006b3	7d 14		 jge	 SHORT $LN27@ckd_write_
  006b5	0f b6 84 24 10
	01 00 00	 movzx	 eax, BYTE PTR trk_ovfl$[rsp]
  006bd	83 e0 01	 and	 eax, 1
  006c0	89 84 24 90 00
	00 00		 mov	 DWORD PTR tv289[rsp], eax
  006c7	eb 0b		 jmp	 SHORT $LN28@ckd_write_
$LN27@ckd_write_:
  006c9	c7 84 24 90 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv289[rsp], 0
$LN28@ckd_write_:
  006d4	8b 84 24 90 00
	00 00		 mov	 eax, DWORD PTR tv289[rsp]
  006db	83 e0 01	 and	 eax, 1
  006de	c1 e0 0f	 shl	 eax, 15
  006e1	48 8b 8c 24 f0
	00 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  006e9	8b 89 14 13 00
	00		 mov	 ecx, DWORD PTR [rcx+4884]
  006ef	0f ba f1 0f	 btr	 ecx, 15
  006f3	0b c8		 or	 ecx, eax
  006f5	8b c1		 mov	 eax, ecx
  006f7	48 8b 8c 24 f0
	00 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  006ff	89 81 14 13 00
	00		 mov	 DWORD PTR [rcx+4884], eax

; 2082 : 
; 2083 :     return 0;

  00705	33 c0		 xor	 eax, eax
$LN1@ckd_write_:

; 2084 : } /* end function ckd_write_ckd */

  00707	48 8b 8c 24 c8
	00 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  0070f	48 33 cc	 xor	 rcx, rsp
  00712	e8 00 00 00 00	 call	 __security_check_cookie
  00717	48 81 c4 d8 00
	00 00		 add	 rsp, 216		; 000000d8H
  0071e	5f		 pop	 rdi
  0071f	5e		 pop	 rsi
  00720	c3		 ret	 0
ckd_write_ckd ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\ckddasd.c
_TEXT	SEGMENT
ckdlen$ = 48
keylen$ = 52
datalen$ = 56
rc$ = 60
tv90 = 64
rechdr$ = 72
__$ArrayPad$ = 80
dev$ = 128
buf$ = 136
len$ = 144
size$ = 152
unitstat$ = 160
ckd_erase PROC

; 1948 : {

  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	56		 push	 rsi
  00015	57		 push	 rdi
  00016	48 83 ec 68	 sub	 rsp, 104		; 00000068H
  0001a	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00021	48 33 c4	 xor	 rax, rsp
  00024	48 89 44 24 50	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 1949 : int             rc;                     /* Return code               */
; 1950 : CKD_RECHDR      rechdr;                 /* CKD record header         */
; 1951 : int             keylen;                 /* Key length                */
; 1952 : int             datalen;                /* Data length               */
; 1953 : int             ckdlen;                 /* Count+key+data length     */
; 1954 : 
; 1955 :     /* If oriented to count or key field, skip key and data */
; 1956 :     if (dev->ckdorient == CKDORIENT_COUNT)

  00029	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00031	83 b8 d8 12 00
	00 02		 cmp	 DWORD PTR [rax+4824], 2
  00038	75 3f		 jne	 SHORT $LN2@ckd_erase

; 1957 :         dev->bufoff += dev->ckdcurkl + dev->ckdcurdl;

  0003a	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00042	0f b7 80 ea 12
	00 00		 movzx	 eax, WORD PTR [rax+4842]
  00049	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  00051	8b 89 d4 12 00
	00		 mov	 ecx, DWORD PTR [rcx+4820]
  00057	03 c8		 add	 ecx, eax
  00059	8b c1		 mov	 eax, ecx
  0005b	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  00063	03 81 e0 01 00
	00		 add	 eax, DWORD PTR [rcx+480]
  00069	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  00071	89 81 e0 01 00
	00		 mov	 DWORD PTR [rcx+480], eax
  00077	eb 3c		 jmp	 SHORT $LN3@ckd_erase
$LN2@ckd_erase:

; 1958 :     else if (dev->ckdorient == CKDORIENT_KEY)

  00079	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00081	83 b8 d8 12 00
	00 03		 cmp	 DWORD PTR [rax+4824], 3
  00088	75 2b		 jne	 SHORT $LN4@ckd_erase

; 1959 :         dev->bufoff += dev->ckdcurdl;

  0008a	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00092	0f b7 80 ea 12
	00 00		 movzx	 eax, WORD PTR [rax+4842]
  00099	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  000a1	03 81 e0 01 00
	00		 add	 eax, DWORD PTR [rcx+480]
  000a7	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  000af	89 81 e0 01 00
	00		 mov	 DWORD PTR [rcx+480], eax
$LN4@ckd_erase:
$LN3@ckd_erase:

; 1960 : 
; 1961 :     /* Copy the count field from the buffer */
; 1962 :     memset( &rechdr, 0,          CKD_RECHDR_SIZE);

  000b5	48 8d 44 24 48	 lea	 rax, QWORD PTR rechdr$[rsp]
  000ba	48 8b f8	 mov	 rdi, rax
  000bd	33 c0		 xor	 eax, eax
  000bf	b9 08 00 00 00	 mov	 ecx, 8
  000c4	f3 aa		 rep stosb

; 1963 :     memcpy( &rechdr, buf, (len < CKD_RECHDR_SIZE) ?

  000c6	48 63 84 24 90
	00 00 00	 movsxd	 rax, DWORD PTR len$[rsp]
  000ce	48 83 f8 08	 cmp	 rax, 8
  000d2	7d 0f		 jge	 SHORT $LN8@ckd_erase
  000d4	48 63 84 24 90
	00 00 00	 movsxd	 rax, DWORD PTR len$[rsp]
  000dc	48 89 44 24 40	 mov	 QWORD PTR tv90[rsp], rax
  000e1	eb 09		 jmp	 SHORT $LN9@ckd_erase
$LN8@ckd_erase:
  000e3	48 c7 44 24 40
	08 00 00 00	 mov	 QWORD PTR tv90[rsp], 8
$LN9@ckd_erase:
  000ec	48 8d 44 24 48	 lea	 rax, QWORD PTR rechdr$[rsp]
  000f1	48 8b f8	 mov	 rdi, rax
  000f4	48 8b b4 24 88
	00 00 00	 mov	 rsi, QWORD PTR buf$[rsp]
  000fc	48 8b 4c 24 40	 mov	 rcx, QWORD PTR tv90[rsp]
  00101	f3 a4		 rep movsb

; 1964 :                            len : CKD_RECHDR_SIZE);
; 1965 : 
; 1966 :     /* Extract the key length and data length */
; 1967 :     keylen = rechdr.klen;

  00103	0f b6 44 24 4d	 movzx	 eax, BYTE PTR rechdr$[rsp+5]
  00108	89 44 24 34	 mov	 DWORD PTR keylen$[rsp], eax

; 1968 :     datalen = (rechdr.dlen[0] << 8) + rechdr.dlen[1];

  0010c	b8 01 00 00 00	 mov	 eax, 1
  00111	48 6b c0 00	 imul	 rax, rax, 0
  00115	0f b6 44 04 4e	 movzx	 eax, BYTE PTR rechdr$[rsp+rax+6]
  0011a	c1 e0 08	 shl	 eax, 8
  0011d	b9 01 00 00 00	 mov	 ecx, 1
  00122	48 6b c9 01	 imul	 rcx, rcx, 1
  00126	0f b6 4c 0c 4e	 movzx	 ecx, BYTE PTR rechdr$[rsp+rcx+6]
  0012b	03 c1		 add	 eax, ecx
  0012d	89 44 24 38	 mov	 DWORD PTR datalen$[rsp], eax

; 1969 : 
; 1970 :     /* Calculate total count key and data size */
; 1971 :     ckdlen = CKD_RECHDR_SIZE + keylen + datalen;

  00131	48 63 44 24 34	 movsxd	 rax, DWORD PTR keylen$[rsp]
  00136	48 63 4c 24 38	 movsxd	 rcx, DWORD PTR datalen$[rsp]
  0013b	48 8d 44 08 08	 lea	 rax, QWORD PTR [rax+rcx+8]
  00140	89 44 24 30	 mov	 DWORD PTR ckdlen$[rsp], eax

; 1972 : 
; 1973 :     /* Check that there is enough space on the current track to
; 1974 :        contain the complete erase plus an end of track marker */
; 1975 :     if (dev->bufoff + ckdlen + CKD_ENDTRK_SIZE >= dev->bufoffhi)

  00144	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  0014c	8b 80 e0 01 00
	00		 mov	 eax, DWORD PTR [rax+480]
  00152	03 44 24 30	 add	 eax, DWORD PTR ckdlen$[rsp]
  00156	48 98		 cdqe
  00158	48 83 c0 08	 add	 rax, 8
  0015c	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  00164	48 63 89 e8 01
	00 00		 movsxd	 rcx, DWORD PTR [rcx+488]
  0016b	48 3b c1	 cmp	 rax, rcx
  0016e	7c 34		 jl	 SHORT $LN5@ckd_erase

; 1976 :     {
; 1977 :         /* Unit check with invalid track format */
; 1978 :         ckd_build_sense (dev, 0, SENSE1_ITF, 0, 0, 0);

  00170	c6 44 24 28 00	 mov	 BYTE PTR [rsp+40], 0
  00175	c6 44 24 20 00	 mov	 BYTE PTR [rsp+32], 0
  0017a	45 33 c9	 xor	 r9d, r9d
  0017d	41 b0 40	 mov	 r8b, 64			; 00000040H
  00180	33 d2		 xor	 edx, edx
  00182	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  0018a	e8 00 00 00 00	 call	 ckd_build_sense

; 1979 :         *unitstat = CSW_CE | CSW_DE | CSW_UC;

  0018f	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR unitstat$[rsp]
  00197	c6 00 0e	 mov	 BYTE PTR [rax], 14

; 1980 :         return -1;

  0019a	b8 ff ff ff ff	 mov	 eax, -1
  0019f	e9 98 00 00 00	 jmp	 $LN1@ckd_erase
$LN5@ckd_erase:

; 1981 :     }
; 1982 : 
; 1983 :     /* Logically erase rest of track by writing end of track marker */
; 1984 :     rc = (dev->hnd->write)( dev, dev->bufcur, dev->bufoff, (BYTE*) &CKD_ENDTRK, CKD_ENDTRK_SIZE, unitstat );

  001a4	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  001ac	48 8b 80 90 02
	00 00		 mov	 rax, QWORD PTR [rax+656]
  001b3	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR unitstat$[rsp]
  001bb	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  001c0	c7 44 24 20 08
	00 00 00	 mov	 DWORD PTR [rsp+32], 8
  001c8	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:CKD_ENDTRK
  001cf	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  001d7	44 8b 81 e0 01
	00 00		 mov	 r8d, DWORD PTR [rcx+480]
  001de	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  001e6	8b 91 c0 01 00
	00		 mov	 edx, DWORD PTR [rcx+448]
  001ec	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  001f4	ff 50 58	 call	 QWORD PTR [rax+88]
  001f7	89 44 24 3c	 mov	 DWORD PTR rc$[rsp], eax

; 1985 :     if (rc < 0) return -1;

  001fb	83 7c 24 3c 00	 cmp	 DWORD PTR rc$[rsp], 0
  00200	7d 07		 jge	 SHORT $LN6@ckd_erase
  00202	b8 ff ff ff ff	 mov	 eax, -1
  00207	eb 33		 jmp	 SHORT $LN1@ckd_erase
$LN6@ckd_erase:

; 1986 : 
; 1987 :     /* Return total count key and data size */
; 1988 :     *size = ckdlen;

  00209	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR size$[rsp]
  00211	8b 4c 24 30	 mov	 ecx, DWORD PTR ckdlen$[rsp]
  00215	89 08		 mov	 DWORD PTR [rax], ecx

; 1989 : 
; 1990 :     /* Set the device orientation fields */
; 1991 :     dev->ckdrem = 0;

  00217	33 c0		 xor	 eax, eax
  00219	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  00221	66 89 81 ec 12
	00 00		 mov	 WORD PTR [rcx+4844], ax

; 1992 :     dev->ckdorient = CKDORIENT_DATA;

  00228	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00230	c7 80 d8 12 00
	00 04 00 00 00	 mov	 DWORD PTR [rax+4824], 4

; 1993 : 
; 1994 :     return 0;

  0023a	33 c0		 xor	 eax, eax
$LN1@ckd_erase:

; 1995 : } /* end function ckd_erase */

  0023c	48 8b 4c 24 50	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  00241	48 33 cc	 xor	 rcx, rsp
  00244	e8 00 00 00 00	 call	 __security_check_cookie
  00249	48 83 c4 68	 add	 rsp, 104		; 00000068H
  0024d	5f		 pop	 rdi
  0024e	5e		 pop	 rsi
  0024f	c3		 ret	 0
ckd_erase ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\ckddasd.c
_TEXT	SEGMENT
rc$ = 96
tv163 = 100
tv169 = 104
tv92 = 108
tv129 = 112
tv133 = 116
tv94 = 120
tv158 = 128
rechdr$ = 136
__$ArrayPad$ = 144
dev$ = 192
code$ = 200
buf$ = 208
unitstat$ = 216
ckd_read_data PROC

; 1893 : {

  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	88 54 24 10	 mov	 BYTE PTR [rsp+16], dl
  0000e	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00013	56		 push	 rsi
  00014	57		 push	 rdi
  00015	48 81 ec a8 00
	00 00		 sub	 rsp, 168		; 000000a8H
  0001c	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00023	48 33 c4	 xor	 rax, rsp
  00026	48 89 84 24 90
	00 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 1894 : int             rc;                     /* Return code               */
; 1895 : CKD_RECHDR      rechdr;                 /* Record header             */
; 1896 : 
; 1897 :     /* If not oriented to count or key field, read next count field */
; 1898 :     if (dev->ckdorient != CKDORIENT_COUNT
; 1899 :         && dev->ckdorient != CKDORIENT_KEY)

  0002e	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00036	83 b8 d8 12 00
	00 02		 cmp	 DWORD PTR [rax+4824], 2
  0003d	74 4a		 je	 SHORT $LN5@ckd_read_d
  0003f	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00047	83 b8 d8 12 00
	00 03		 cmp	 DWORD PTR [rax+4824], 3
  0004e	74 39		 je	 SHORT $LN5@ckd_read_d

; 1900 :     {
; 1901 :         rc = ckd_read_count (dev, code, &rechdr, unitstat);

  00050	4c 8b 8c 24 d8
	00 00 00	 mov	 r9, QWORD PTR unitstat$[rsp]
  00058	4c 8d 84 24 88
	00 00 00	 lea	 r8, QWORD PTR rechdr$[rsp]
  00060	0f b6 94 24 c8
	00 00 00	 movzx	 edx, BYTE PTR code$[rsp]
  00068	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  00070	e8 00 00 00 00	 call	 ckd_read_count
  00075	89 44 24 60	 mov	 DWORD PTR rc$[rsp], eax

; 1902 :         if (rc < 0) return rc;

  00079	83 7c 24 60 00	 cmp	 DWORD PTR rc$[rsp], 0
  0007e	7d 09		 jge	 SHORT $LN6@ckd_read_d
  00080	8b 44 24 60	 mov	 eax, DWORD PTR rc$[rsp]
  00084	e9 4a 03 00 00	 jmp	 $LN1@ckd_read_d
$LN6@ckd_read_d:
$LN5@ckd_read_d:

; 1903 :     }
; 1904 : 
; 1905 :     /* If oriented to count field, skip the key field */
; 1906 :     if (dev->ckdorient == CKDORIENT_COUNT)

  00089	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00091	83 b8 d8 12 00
	00 02		 cmp	 DWORD PTR [rax+4824], 2
  00098	75 2a		 jne	 SHORT $LN7@ckd_read_d

; 1907 :         dev->bufoff += dev->ckdcurkl;

  0009a	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  000a2	8b 80 e0 01 00
	00		 mov	 eax, DWORD PTR [rax+480]
  000a8	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  000b0	03 81 d4 12 00
	00		 add	 eax, DWORD PTR [rcx+4820]
  000b6	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  000be	89 81 e0 01 00
	00		 mov	 DWORD PTR [rcx+480], eax
$LN7@ckd_read_d:

; 1908 : 
; 1909 :     // "%1d:%04X CKD file %s: read data %d bytes"
; 1910 :     if (dev->ccwtrace && sysblk.traceFILE)

  000c4	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  000cc	8b 80 f8 05 00
	00		 mov	 eax, DWORD PTR [rax+1528]
  000d2	c1 e8 0f	 shr	 eax, 15
  000d5	83 e0 01	 and	 eax, 1
  000d8	85 c0		 test	 eax, eax
  000da	74 24		 je	 SHORT $LN8@ckd_read_d
  000dc	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  000e3	48 83 b8 20 14
	00 00 00	 cmp	 QWORD PTR [rax+5152], 0
  000eb	74 13		 je	 SHORT $LN8@ckd_read_d

; 1911 :         tf_0437( dev );

  000ed	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  000f5	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_tf_0437
  000fb	e9 db 00 00 00	 jmp	 $LN9@ckd_read_d
$LN8@ckd_read_d:
$LN4@ckd_read_d:

; 1912 :     else
; 1913 :         LOGDEVTR( HHC00437, "I", dev->filename, dev->ckdcurdl );

  00100	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00108	8b 80 f8 05 00
	00		 mov	 eax, DWORD PTR [rax+1528]
  0010e	c1 e8 0f	 shr	 eax, 15
  00111	83 e0 01	 and	 eax, 1
  00114	85 c0		 test	 eax, eax
  00116	0f 84 b5 00 00
	00		 je	 $LN10@ckd_read_d
  0011c	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00124	0f b7 80 ea 12
	00 00		 movzx	 eax, WORD PTR [rax+4842]
  0012b	89 44 24 6c	 mov	 DWORD PTR tv92[rsp], eax
  0012f	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  00137	48 81 c1 a4 00
	00 00		 add	 rcx, 164		; 000000a4H
  0013e	48 89 4c 24 78	 mov	 QWORD PTR tv94[rsp], rcx
  00143	48 8b 94 24 c0
	00 00 00	 mov	 rdx, QWORD PTR dev$[rsp]
  0014b	0f b7 52 48	 movzx	 edx, WORD PTR [rdx+72]
  0014f	89 54 24 70	 mov	 DWORD PTR tv129[rsp], edx
  00153	4c 8b 84 24 c0
	00 00 00	 mov	 r8, QWORD PTR dev$[rsp]
  0015b	45 0f b7 40 44	 movzx	 r8d, WORD PTR [r8+68]
  00160	41 d1 f8	 sar	 r8d, 1
  00163	44 89 44 24 74	 mov	 DWORD PTR tv133[rsp], r8d
  00168	b9 01 00 00 00	 mov	 ecx, 1
  0016d	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  00173	8b 4c 24 6c	 mov	 ecx, DWORD PTR tv92[rsp]
  00177	89 4c 24 50	 mov	 DWORD PTR [rsp+80], ecx
  0017b	48 8b 4c 24 78	 mov	 rcx, QWORD PTR tv94[rsp]
  00180	48 89 4c 24 48	 mov	 QWORD PTR [rsp+72], rcx
  00185	8b 4c 24 70	 mov	 ecx, DWORD PTR tv129[rsp]
  00189	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  0018d	8b 4c 24 74	 mov	 ecx, DWORD PTR tv133[rsp]
  00191	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  00195	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG171329
  0019c	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  001a1	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG171330
  001a8	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  001ad	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  001b2	41 b9 03 00 00
	00		 mov	 r9d, 3
  001b8	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG171331
  001bf	ba 79 07 00 00	 mov	 edx, 1913		; 00000779H
  001c4	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG171332
  001cb	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg
$LN10@ckd_read_d:
  001d1	33 c0		 xor	 eax, eax
  001d3	85 c0		 test	 eax, eax
  001d5	0f 85 25 ff ff
	ff		 jne	 $LN4@ckd_read_d
$LN9@ckd_read_d:

; 1914 : 
; 1915 :     /* Read data field */
; 1916 :     if (dev->ckdcurdl > 0)

  001db	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  001e3	0f b7 80 ea 12
	00 00		 movzx	 eax, WORD PTR [rax+4842]
  001ea	85 c0		 test	 eax, eax
  001ec	0f 8e bc 01 00
	00		 jle	 $LN11@ckd_read_d

; 1917 :     {
; 1918 :         if (dev->bufoff + dev->ckdcurdl >= dev->bufoffhi)

  001f2	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  001fa	0f b7 80 ea 12
	00 00		 movzx	 eax, WORD PTR [rax+4842]
  00201	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  00209	03 81 e0 01 00
	00		 add	 eax, DWORD PTR [rcx+480]
  0020f	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  00217	3b 81 e8 01 00
	00		 cmp	 eax, DWORD PTR [rcx+488]
  0021d	0f 8c 1e 01 00
	00		 jl	 $LN12@ckd_read_d

; 1919 :         {
; 1920 :             /* Handle error condition */
; 1921 :             // "%1d:%04X CKD file %s: error attempting to read past end of track %d %d"
; 1922 :             WRMSG( HHC00419, "E", LCSS_DEVNUM,

  00223	48 83 bc 24 c0
	00 00 00 00	 cmp	 QWORD PTR dev$[rsp], 0
  0022c	74 12		 je	 SHORT $LN14@ckd_read_d
  0022e	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00236	0f b7 40 48	 movzx	 eax, WORD PTR [rax+72]
  0023a	89 44 24 64	 mov	 DWORD PTR tv163[rsp], eax
  0023e	eb 08		 jmp	 SHORT $LN15@ckd_read_d
$LN14@ckd_read_d:
  00240	c7 44 24 64 00
	00 00 00	 mov	 DWORD PTR tv163[rsp], 0
$LN15@ckd_read_d:
  00248	48 83 bc 24 c0
	00 00 00 00	 cmp	 QWORD PTR dev$[rsp], 0
  00251	74 14		 je	 SHORT $LN16@ckd_read_d
  00253	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  0025b	0f b7 40 44	 movzx	 eax, WORD PTR [rax+68]
  0025f	d1 f8		 sar	 eax, 1
  00261	89 44 24 68	 mov	 DWORD PTR tv169[rsp], eax
  00265	eb 08		 jmp	 SHORT $LN17@ckd_read_d
$LN16@ckd_read_d:
  00267	c7 44 24 68 00
	00 00 00	 mov	 DWORD PTR tv169[rsp], 0
$LN17@ckd_read_d:
  0026f	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00277	48 05 a4 00 00
	00		 add	 rax, 164		; 000000a4H
  0027d	48 89 84 24 80
	00 00 00	 mov	 QWORD PTR tv158[rsp], rax
  00285	b9 01 00 00 00	 mov	 ecx, 1
  0028a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  00290	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  00298	8b 89 e8 01 00
	00		 mov	 ecx, DWORD PTR [rcx+488]
  0029e	89 4c 24 58	 mov	 DWORD PTR [rsp+88], ecx
  002a2	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  002aa	8b 89 e0 01 00
	00		 mov	 ecx, DWORD PTR [rcx+480]
  002b0	89 4c 24 50	 mov	 DWORD PTR [rsp+80], ecx
  002b4	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR tv158[rsp]
  002bc	48 89 4c 24 48	 mov	 QWORD PTR [rsp+72], rcx
  002c1	8b 4c 24 64	 mov	 ecx, DWORD PTR tv163[rsp]
  002c5	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  002c9	8b 4c 24 68	 mov	 ecx, DWORD PTR tv169[rsp]
  002cd	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  002d1	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG171335
  002d8	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  002dd	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG171336
  002e4	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  002e9	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  002ee	41 b9 03 00 00
	00		 mov	 r9d, 3
  002f4	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG171337
  002fb	ba 83 07 00 00	 mov	 edx, 1923		; 00000783H
  00300	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG171338
  00307	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 1923 :                    dev->filename, dev->bufoff, dev->bufoffhi );
; 1924 : 
; 1925 :             /* Set unit check with equipment check */
; 1926 :             ckd_build_sense (dev, SENSE_EC, 0, 0,

  0030d	c6 44 24 28 00	 mov	 BYTE PTR [rsp+40], 0
  00312	c6 44 24 20 01	 mov	 BYTE PTR [rsp+32], 1
  00317	45 33 c9	 xor	 r9d, r9d
  0031a	45 33 c0	 xor	 r8d, r8d
  0031d	b2 10		 mov	 dl, 16
  0031f	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  00327	e8 00 00 00 00	 call	 ckd_build_sense

; 1927 :                             FORMAT_1, MESSAGE_0);
; 1928 :             *unitstat = CSW_CE | CSW_DE | CSW_UC;

  0032c	48 8b 84 24 d8
	00 00 00	 mov	 rax, QWORD PTR unitstat$[rsp]
  00334	c6 00 0e	 mov	 BYTE PTR [rax], 14

; 1929 :             return -1;

  00337	b8 ff ff ff ff	 mov	 eax, -1
  0033c	e9 92 00 00 00	 jmp	 $LN1@ckd_read_d
$LN12@ckd_read_d:

; 1930 :         }
; 1931 :         memcpy (buf, &dev->buf[dev->bufoff], dev->ckdcurdl);

  00341	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00349	0f b7 80 ea 12
	00 00		 movzx	 eax, WORD PTR [rax+4842]
  00350	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  00358	48 63 89 e0 01
	00 00		 movsxd	 rcx, DWORD PTR [rcx+480]
  0035f	48 8b 94 24 c0
	00 00 00	 mov	 rdx, QWORD PTR dev$[rsp]
  00367	48 8b 92 c8 01
	00 00		 mov	 rdx, QWORD PTR [rdx+456]
  0036e	48 03 d1	 add	 rdx, rcx
  00371	48 8b ca	 mov	 rcx, rdx
  00374	48 8b bc 24 d0
	00 00 00	 mov	 rdi, QWORD PTR buf$[rsp]
  0037c	48 8b f1	 mov	 rsi, rcx
  0037f	8b c8		 mov	 ecx, eax
  00381	f3 a4		 rep movsb

; 1932 :         dev->bufoff += dev->ckdcurdl;

  00383	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  0038b	0f b7 80 ea 12
	00 00		 movzx	 eax, WORD PTR [rax+4842]
  00392	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  0039a	03 81 e0 01 00
	00		 add	 eax, DWORD PTR [rcx+480]
  003a0	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  003a8	89 81 e0 01 00
	00		 mov	 DWORD PTR [rcx+480], eax
$LN11@ckd_read_d:

; 1933 :     }
; 1934 : 
; 1935 :     /* Set the device orientation fields */
; 1936 :     dev->ckdrem = 0;

  003ae	33 c0		 xor	 eax, eax
  003b0	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  003b8	66 89 81 ec 12
	00 00		 mov	 WORD PTR [rcx+4844], ax

; 1937 :     dev->ckdorient = CKDORIENT_DATA;

  003bf	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  003c7	c7 80 d8 12 00
	00 04 00 00 00	 mov	 DWORD PTR [rax+4824], 4

; 1938 : 
; 1939 :     return 0;

  003d1	33 c0		 xor	 eax, eax
$LN1@ckd_read_d:

; 1940 : } /* end function ckd_read_data */

  003d3	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  003db	48 33 cc	 xor	 rcx, rsp
  003de	e8 00 00 00 00	 call	 __security_check_cookie
  003e3	48 81 c4 a8 00
	00 00		 add	 rsp, 168		; 000000a8H
  003ea	5f		 pop	 rdi
  003eb	5e		 pop	 rsi
  003ec	c3		 ret	 0
ckd_read_data ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\ckddasd.c
_TEXT	SEGMENT
rc$ = 96
tv152 = 100
tv158 = 104
tv88 = 108
tv92 = 112
tv85 = 120
tv147 = 128
rechdr$ = 136
__$ArrayPad$ = 144
dev$ = 192
code$ = 200
buf$ = 208
unitstat$ = 216
ckd_read_key PROC

; 1842 : {

  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	88 54 24 10	 mov	 BYTE PTR [rsp+16], dl
  0000e	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00013	56		 push	 rsi
  00014	57		 push	 rdi
  00015	48 81 ec a8 00
	00 00		 sub	 rsp, 168		; 000000a8H
  0001c	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00023	48 33 c4	 xor	 rax, rsp
  00026	48 89 84 24 90
	00 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 1843 : int             rc;                     /* Return code               */
; 1844 : CKD_RECHDR      rechdr;                 /* CKD record header         */
; 1845 : 
; 1846 :     /* If not oriented to count field, read next count field */
; 1847 :     if (dev->ckdorient != CKDORIENT_COUNT)

  0002e	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00036	83 b8 d8 12 00
	00 02		 cmp	 DWORD PTR [rax+4824], 2
  0003d	74 39		 je	 SHORT $LN5@ckd_read_k

; 1848 :     {
; 1849 :         rc = ckd_read_count (dev, code, &rechdr, unitstat);

  0003f	4c 8b 8c 24 d8
	00 00 00	 mov	 r9, QWORD PTR unitstat$[rsp]
  00047	4c 8d 84 24 88
	00 00 00	 lea	 r8, QWORD PTR rechdr$[rsp]
  0004f	0f b6 94 24 c8
	00 00 00	 movzx	 edx, BYTE PTR code$[rsp]
  00057	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  0005f	e8 00 00 00 00	 call	 ckd_read_count
  00064	89 44 24 60	 mov	 DWORD PTR rc$[rsp], eax

; 1850 :         if (rc < 0) return rc;

  00068	83 7c 24 60 00	 cmp	 DWORD PTR rc$[rsp], 0
  0006d	7d 09		 jge	 SHORT $LN6@ckd_read_k
  0006f	8b 44 24 60	 mov	 eax, DWORD PTR rc$[rsp]
  00073	e9 01 03 00 00	 jmp	 $LN1@ckd_read_k
$LN6@ckd_read_k:
$LN5@ckd_read_k:

; 1851 :     }
; 1852 : 
; 1853 :     // "%1d:%04X CKD file %s: read key %d bytes"
; 1854 :     if (dev->ccwtrace && sysblk.traceFILE)

  00078	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00080	8b 80 f8 05 00
	00		 mov	 eax, DWORD PTR [rax+1528]
  00086	c1 e8 0f	 shr	 eax, 15
  00089	83 e0 01	 and	 eax, 1
  0008c	85 c0		 test	 eax, eax
  0008e	74 24		 je	 SHORT $LN7@ckd_read_k
  00090	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00097	48 83 b8 20 14
	00 00 00	 cmp	 QWORD PTR [rax+5152], 0
  0009f	74 13		 je	 SHORT $LN7@ckd_read_k

; 1855 :         tf_0436( dev );

  000a1	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  000a9	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_tf_0436
  000af	e9 ce 00 00 00	 jmp	 $LN8@ckd_read_k
$LN7@ckd_read_k:
$LN4@ckd_read_k:

; 1856 :     else
; 1857 :         LOGDEVTR( HHC00436, "I", dev->filename, dev->ckdcurkl );

  000b4	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  000bc	8b 80 f8 05 00
	00		 mov	 eax, DWORD PTR [rax+1528]
  000c2	c1 e8 0f	 shr	 eax, 15
  000c5	83 e0 01	 and	 eax, 1
  000c8	85 c0		 test	 eax, eax
  000ca	0f 84 a8 00 00
	00		 je	 $LN9@ckd_read_k
  000d0	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  000d8	48 05 a4 00 00
	00		 add	 rax, 164		; 000000a4H
  000de	48 89 44 24 78	 mov	 QWORD PTR tv85[rsp], rax
  000e3	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  000eb	0f b7 49 48	 movzx	 ecx, WORD PTR [rcx+72]
  000ef	89 4c 24 6c	 mov	 DWORD PTR tv88[rsp], ecx
  000f3	48 8b 94 24 c0
	00 00 00	 mov	 rdx, QWORD PTR dev$[rsp]
  000fb	0f b7 52 44	 movzx	 edx, WORD PTR [rdx+68]
  000ff	d1 fa		 sar	 edx, 1
  00101	89 54 24 70	 mov	 DWORD PTR tv92[rsp], edx
  00105	b9 01 00 00 00	 mov	 ecx, 1
  0010a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  00110	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  00118	8b 89 d4 12 00
	00		 mov	 ecx, DWORD PTR [rcx+4820]
  0011e	89 4c 24 50	 mov	 DWORD PTR [rsp+80], ecx
  00122	48 8b 4c 24 78	 mov	 rcx, QWORD PTR tv85[rsp]
  00127	48 89 4c 24 48	 mov	 QWORD PTR [rsp+72], rcx
  0012c	8b 4c 24 6c	 mov	 ecx, DWORD PTR tv88[rsp]
  00130	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  00134	8b 4c 24 70	 mov	 ecx, DWORD PTR tv92[rsp]
  00138	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  0013c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG171298
  00143	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  00148	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG171299
  0014f	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00154	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00159	41 b9 03 00 00
	00		 mov	 r9d, 3
  0015f	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG171300
  00166	ba 41 07 00 00	 mov	 edx, 1857		; 00000741H
  0016b	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG171301
  00172	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg
$LN9@ckd_read_k:
  00178	33 c0		 xor	 eax, eax
  0017a	85 c0		 test	 eax, eax
  0017c	0f 85 32 ff ff
	ff		 jne	 $LN4@ckd_read_k
$LN8@ckd_read_k:

; 1858 : 
; 1859 :     /* Read key field */
; 1860 :     if (dev->ckdcurkl > 0)

  00182	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  0018a	83 b8 d4 12 00
	00 00		 cmp	 DWORD PTR [rax+4820], 0
  00191	0f 8e bd 01 00
	00		 jle	 $LN10@ckd_read_k

; 1861 :     {
; 1862 :         if (dev->bufoffhi - dev->bufoff < dev->ckdcurkl)

  00197	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  0019f	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  001a7	8b 89 e0 01 00
	00		 mov	 ecx, DWORD PTR [rcx+480]
  001ad	8b 80 e8 01 00
	00		 mov	 eax, DWORD PTR [rax+488]
  001b3	2b c1		 sub	 eax, ecx
  001b5	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  001bd	3b 81 d4 12 00
	00		 cmp	 eax, DWORD PTR [rcx+4820]
  001c3	0f 8d 1e 01 00
	00		 jge	 $LN11@ckd_read_k

; 1863 :         {
; 1864 :             /* Handle error condition */
; 1865 :             // "%1d:%04X CKD file %s: error attempting to read past end of track %d %d"
; 1866 :             WRMSG( HHC00419, "E", LCSS_DEVNUM,

  001c9	48 83 bc 24 c0
	00 00 00 00	 cmp	 QWORD PTR dev$[rsp], 0
  001d2	74 12		 je	 SHORT $LN13@ckd_read_k
  001d4	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  001dc	0f b7 40 48	 movzx	 eax, WORD PTR [rax+72]
  001e0	89 44 24 64	 mov	 DWORD PTR tv152[rsp], eax
  001e4	eb 08		 jmp	 SHORT $LN14@ckd_read_k
$LN13@ckd_read_k:
  001e6	c7 44 24 64 00
	00 00 00	 mov	 DWORD PTR tv152[rsp], 0
$LN14@ckd_read_k:
  001ee	48 83 bc 24 c0
	00 00 00 00	 cmp	 QWORD PTR dev$[rsp], 0
  001f7	74 14		 je	 SHORT $LN15@ckd_read_k
  001f9	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00201	0f b7 40 44	 movzx	 eax, WORD PTR [rax+68]
  00205	d1 f8		 sar	 eax, 1
  00207	89 44 24 68	 mov	 DWORD PTR tv158[rsp], eax
  0020b	eb 08		 jmp	 SHORT $LN16@ckd_read_k
$LN15@ckd_read_k:
  0020d	c7 44 24 68 00
	00 00 00	 mov	 DWORD PTR tv158[rsp], 0
$LN16@ckd_read_k:
  00215	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  0021d	48 05 a4 00 00
	00		 add	 rax, 164		; 000000a4H
  00223	48 89 84 24 80
	00 00 00	 mov	 QWORD PTR tv147[rsp], rax
  0022b	b9 01 00 00 00	 mov	 ecx, 1
  00230	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  00236	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  0023e	8b 89 e8 01 00
	00		 mov	 ecx, DWORD PTR [rcx+488]
  00244	89 4c 24 58	 mov	 DWORD PTR [rsp+88], ecx
  00248	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  00250	8b 89 e0 01 00
	00		 mov	 ecx, DWORD PTR [rcx+480]
  00256	89 4c 24 50	 mov	 DWORD PTR [rsp+80], ecx
  0025a	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR tv147[rsp]
  00262	48 89 4c 24 48	 mov	 QWORD PTR [rsp+72], rcx
  00267	8b 4c 24 64	 mov	 ecx, DWORD PTR tv152[rsp]
  0026b	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  0026f	8b 4c 24 68	 mov	 ecx, DWORD PTR tv158[rsp]
  00273	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  00277	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG171304
  0027e	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  00283	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG171305
  0028a	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  0028f	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00294	41 b9 03 00 00
	00		 mov	 r9d, 3
  0029a	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG171306
  002a1	ba 4b 07 00 00	 mov	 edx, 1867		; 0000074bH
  002a6	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG171307
  002ad	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 1867 :                    dev->filename, dev->bufoff, dev->bufoffhi );
; 1868 : 
; 1869 :             /* Set unit check with equipment check */
; 1870 :             ckd_build_sense (dev, SENSE_EC, 0, 0,

  002b3	c6 44 24 28 00	 mov	 BYTE PTR [rsp+40], 0
  002b8	c6 44 24 20 01	 mov	 BYTE PTR [rsp+32], 1
  002bd	45 33 c9	 xor	 r9d, r9d
  002c0	45 33 c0	 xor	 r8d, r8d
  002c3	b2 10		 mov	 dl, 16
  002c5	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  002cd	e8 00 00 00 00	 call	 ckd_build_sense

; 1871 :                             FORMAT_1, MESSAGE_0);
; 1872 :             *unitstat = CSW_CE | CSW_DE | CSW_UC;

  002d2	48 8b 84 24 d8
	00 00 00	 mov	 rax, QWORD PTR unitstat$[rsp]
  002da	c6 00 0e	 mov	 BYTE PTR [rax], 14

; 1873 :             return -1;

  002dd	b8 ff ff ff ff	 mov	 eax, -1
  002e2	e9 92 00 00 00	 jmp	 $LN1@ckd_read_k
$LN11@ckd_read_k:

; 1874 :         }
; 1875 : 
; 1876 :         memcpy (buf, &dev->buf[dev->bufoff], dev->ckdcurkl);

  002e7	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  002ef	48 63 80 d4 12
	00 00		 movsxd	 rax, DWORD PTR [rax+4820]
  002f6	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  002fe	48 63 89 e0 01
	00 00		 movsxd	 rcx, DWORD PTR [rcx+480]
  00305	48 8b 94 24 c0
	00 00 00	 mov	 rdx, QWORD PTR dev$[rsp]
  0030d	48 8b 92 c8 01
	00 00		 mov	 rdx, QWORD PTR [rdx+456]
  00314	48 03 d1	 add	 rdx, rcx
  00317	48 8b ca	 mov	 rcx, rdx
  0031a	48 8b bc 24 d0
	00 00 00	 mov	 rdi, QWORD PTR buf$[rsp]
  00322	48 8b f1	 mov	 rsi, rcx
  00325	48 8b c8	 mov	 rcx, rax
  00328	f3 a4		 rep movsb

; 1877 :         dev->bufoff += dev->ckdcurkl;

  0032a	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00332	8b 80 e0 01 00
	00		 mov	 eax, DWORD PTR [rax+480]
  00338	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  00340	03 81 d4 12 00
	00		 add	 eax, DWORD PTR [rcx+4820]
  00346	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  0034e	89 81 e0 01 00
	00		 mov	 DWORD PTR [rcx+480], eax
$LN10@ckd_read_k:

; 1878 :     }
; 1879 : 
; 1880 :     /* Set the device orientation fields */
; 1881 :     dev->ckdrem = 0;

  00354	33 c0		 xor	 eax, eax
  00356	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  0035e	66 89 81 ec 12
	00 00		 mov	 WORD PTR [rcx+4844], ax

; 1882 :     dev->ckdorient = CKDORIENT_KEY;

  00365	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  0036d	c7 80 d8 12 00
	00 03 00 00 00	 mov	 DWORD PTR [rax+4824], 3

; 1883 : 
; 1884 :     return 0;

  00377	33 c0		 xor	 eax, eax
$LN1@ckd_read_k:

; 1885 : } /* end function ckd_read_key */

  00379	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  00381	48 33 cc	 xor	 rcx, rsp
  00384	e8 00 00 00 00	 call	 __security_check_cookie
  00389	48 81 c4 a8 00
	00 00		 add	 rsp, 168		; 000000a8H
  00390	5f		 pop	 rdi
  00391	5e		 pop	 rsi
  00392	c3		 ret	 0
ckd_read_key ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\ckddasd.c
_TEXT	SEGMENT
rc$ = 128
head$ = 132
cyl$ = 136
tv189 = 140
tv195 = 144
tv262 = 148
skipr0$ = 152
tv135 = 156
tv139 = 160
tv284 = 164
tv287 = 168
tv300 = 172
tv304 = 176
tv128 = 184
tv132 = 192
tv184 = 200
tv297 = 208
orient$ = 216
__$ArrayPad$ = 264
dev$ = 288
code$ = 296
rechdr$ = 304
unitstat$ = 312
ckd_read_count PROC

; 1672 : {

  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	88 54 24 10	 mov	 BYTE PTR [rsp+16], dl
  0000e	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00013	48 81 ec 18 01
	00 00		 sub	 rsp, 280		; 00000118H
  0001a	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00021	48 33 c4	 xor	 rax, rsp
  00024	48 89 84 24 08
	01 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 1673 : int             rc;                     /* Return code               */
; 1674 : int             skipr0 = 0;             /* 1=Skip record zero        */

  0002c	c7 84 24 98 00
	00 00 00 00 00
	00		 mov	 DWORD PTR skipr0$[rsp], 0

; 1675 : int             cyl;                    /* Cylinder number for seek  */
; 1676 : int             head;                   /* Head number for seek      */
; 1677 : char           *orient[] = {"none", "index", "count", "key", "data", "eot"};

  00037	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG171224
  0003e	48 89 84 24 d8
	00 00 00	 mov	 QWORD PTR orient$[rsp], rax
  00046	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG171226
  0004d	48 89 84 24 e0
	00 00 00	 mov	 QWORD PTR orient$[rsp+8], rax
  00055	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG171228
  0005c	48 89 84 24 e8
	00 00 00	 mov	 QWORD PTR orient$[rsp+16], rax
  00064	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG171230
  0006b	48 89 84 24 f0
	00 00 00	 mov	 QWORD PTR orient$[rsp+24], rax
  00073	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG171232
  0007a	48 89 84 24 f8
	00 00 00	 mov	 QWORD PTR orient$[rsp+32], rax
  00082	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG171234
  00089	48 89 84 24 00
	01 00 00	 mov	 QWORD PTR orient$[rsp+40], rax

; 1678 : 
; 1679 :     /* Skip record 0 for all operations except READ TRACK, READ R0,
; 1680 :        SEARCH ID EQUAL, SEARCH ID HIGH, SEARCH ID EQUAL OR HIGH,
; 1681 :        LOCATE RECORD, and WRITE CKD NEXT TRACK */
; 1682 :     if (code != 0xDE
; 1683 :         && (code & 0x7F) != 0x16
; 1684 :         && (code & 0x7F) != 0x31
; 1685 :         && (code & 0x7F) != 0x51
; 1686 :         && (code & 0x7F) != 0x71
; 1687 :         && code != 0x47
; 1688 :         && code != 0x4B
; 1689 :         && code != 0x9D)

  00091	0f b6 84 24 28
	01 00 00	 movzx	 eax, BYTE PTR code$[rsp]
  00099	3d de 00 00 00	 cmp	 eax, 222		; 000000deH
  0009e	74 74		 je	 SHORT $LN11@ckd_read_c
  000a0	0f b6 84 24 28
	01 00 00	 movzx	 eax, BYTE PTR code$[rsp]
  000a8	83 e0 7f	 and	 eax, 127		; 0000007fH
  000ab	83 f8 16	 cmp	 eax, 22
  000ae	74 64		 je	 SHORT $LN11@ckd_read_c
  000b0	0f b6 84 24 28
	01 00 00	 movzx	 eax, BYTE PTR code$[rsp]
  000b8	83 e0 7f	 and	 eax, 127		; 0000007fH
  000bb	83 f8 31	 cmp	 eax, 49			; 00000031H
  000be	74 54		 je	 SHORT $LN11@ckd_read_c
  000c0	0f b6 84 24 28
	01 00 00	 movzx	 eax, BYTE PTR code$[rsp]
  000c8	83 e0 7f	 and	 eax, 127		; 0000007fH
  000cb	83 f8 51	 cmp	 eax, 81			; 00000051H
  000ce	74 44		 je	 SHORT $LN11@ckd_read_c
  000d0	0f b6 84 24 28
	01 00 00	 movzx	 eax, BYTE PTR code$[rsp]
  000d8	83 e0 7f	 and	 eax, 127		; 0000007fH
  000db	83 f8 71	 cmp	 eax, 113		; 00000071H
  000de	74 34		 je	 SHORT $LN11@ckd_read_c
  000e0	0f b6 84 24 28
	01 00 00	 movzx	 eax, BYTE PTR code$[rsp]
  000e8	83 f8 47	 cmp	 eax, 71			; 00000047H
  000eb	74 27		 je	 SHORT $LN11@ckd_read_c
  000ed	0f b6 84 24 28
	01 00 00	 movzx	 eax, BYTE PTR code$[rsp]
  000f5	83 f8 4b	 cmp	 eax, 75			; 0000004bH
  000f8	74 1a		 je	 SHORT $LN11@ckd_read_c
  000fa	0f b6 84 24 28
	01 00 00	 movzx	 eax, BYTE PTR code$[rsp]
  00102	3d 9d 00 00 00	 cmp	 eax, 157		; 0000009dH
  00107	74 0b		 je	 SHORT $LN11@ckd_read_c

; 1690 :         skipr0 = 1;

  00109	c7 84 24 98 00
	00 00 01 00 00
	00		 mov	 DWORD PTR skipr0$[rsp], 1
$LN11@ckd_read_c:

; 1691 : 
; 1692 :     // "%1d:%04X CKD file %s: read count orientation %s"
; 1693 :     if (dev->ccwtrace && sysblk.traceFILE)

  00114	48 8b 84 24 20
	01 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  0011c	8b 80 f8 05 00
	00		 mov	 eax, DWORD PTR [rax+1528]
  00122	c1 e8 0f	 shr	 eax, 15
  00125	83 e0 01	 and	 eax, 1
  00128	85 c0		 test	 eax, eax
  0012a	74 24		 je	 SHORT $LN12@ckd_read_c
  0012c	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00133	48 83 b8 20 14
	00 00 00	 cmp	 QWORD PTR [rax+5152], 0
  0013b	74 13		 je	 SHORT $LN12@ckd_read_c

; 1694 :         tf_0434( dev );

  0013d	48 8b 8c 24 20
	01 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  00145	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_tf_0434
  0014b	e9 fe 00 00 00	 jmp	 $LN13@ckd_read_c
$LN12@ckd_read_c:
$LN4@ckd_read_c:

; 1695 :     else
; 1696 :         LOGDEVTR( HHC00434, "I", dev->filename, orient[dev->ckdorient] );

  00150	48 8b 84 24 20
	01 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00158	8b 80 f8 05 00
	00		 mov	 eax, DWORD PTR [rax+1528]
  0015e	c1 e8 0f	 shr	 eax, 15
  00161	83 e0 01	 and	 eax, 1
  00164	85 c0		 test	 eax, eax
  00166	0f 84 d8 00 00
	00		 je	 $LN14@ckd_read_c
  0016c	48 8b 84 24 20
	01 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00174	48 63 80 d8 12
	00 00		 movsxd	 rax, DWORD PTR [rax+4824]
  0017b	48 89 84 24 b8
	00 00 00	 mov	 QWORD PTR tv128[rsp], rax
  00183	48 8b 8c 24 20
	01 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  0018b	48 81 c1 a4 00
	00 00		 add	 rcx, 164		; 000000a4H
  00192	48 89 8c 24 c0
	00 00 00	 mov	 QWORD PTR tv132[rsp], rcx
  0019a	48 8b 94 24 20
	01 00 00	 mov	 rdx, QWORD PTR dev$[rsp]
  001a2	0f b7 52 48	 movzx	 edx, WORD PTR [rdx+72]
  001a6	89 94 24 9c 00
	00 00		 mov	 DWORD PTR tv135[rsp], edx
  001ad	4c 8b 84 24 20
	01 00 00	 mov	 r8, QWORD PTR dev$[rsp]
  001b5	45 0f b7 40 44	 movzx	 r8d, WORD PTR [r8+68]
  001ba	41 d1 f8	 sar	 r8d, 1
  001bd	44 89 84 24 a0
	00 00 00	 mov	 DWORD PTR tv139[rsp], r8d
  001c5	b9 01 00 00 00	 mov	 ecx, 1
  001ca	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  001d0	48 8b 8c 24 b8
	00 00 00	 mov	 rcx, QWORD PTR tv128[rsp]
  001d8	48 8b 8c cc d8
	00 00 00	 mov	 rcx, QWORD PTR orient$[rsp+rcx*8]
  001e0	48 89 4c 24 50	 mov	 QWORD PTR [rsp+80], rcx
  001e5	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR tv132[rsp]
  001ed	48 89 4c 24 48	 mov	 QWORD PTR [rsp+72], rcx
  001f2	8b 8c 24 9c 00
	00 00		 mov	 ecx, DWORD PTR tv135[rsp]
  001f9	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  001fd	8b 8c 24 a0 00
	00 00		 mov	 ecx, DWORD PTR tv139[rsp]
  00204	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  00208	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG171239
  0020f	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  00214	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG171240
  0021b	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00220	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00225	41 b9 03 00 00
	00		 mov	 r9d, 3
  0022b	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG171241
  00232	ba a0 06 00 00	 mov	 edx, 1696		; 000006a0H
  00237	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG171242
  0023e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg
$LN14@ckd_read_c:
  00244	33 c0		 xor	 eax, eax
  00246	85 c0		 test	 eax, eax
  00248	0f 85 02 ff ff
	ff		 jne	 $LN4@ckd_read_c
$LN13@ckd_read_c:

; 1697 : 
; 1698 :     /* If orientation is at End-Of_Track then a multi-track advance
; 1699 :        failed previously during synchronous I/O */
; 1700 :     if (dev->ckdorient == CKDORIENT_EOT)

  0024e	48 8b 84 24 20
	01 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00256	83 b8 d8 12 00
	00 05		 cmp	 DWORD PTR [rax+4824], 5
  0025d	75 36		 jne	 SHORT $LN15@ckd_read_c

; 1701 :     {
; 1702 :         rc = mt_advance (dev, unitstat, 1);

  0025f	41 b8 01 00 00
	00		 mov	 r8d, 1
  00265	48 8b 94 24 38
	01 00 00	 mov	 rdx, QWORD PTR unitstat$[rsp]
  0026d	48 8b 8c 24 20
	01 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  00275	e8 00 00 00 00	 call	 mt_advance
  0027a	89 84 24 80 00
	00 00		 mov	 DWORD PTR rc$[rsp], eax

; 1703 :         if (rc < 0) return -1;

  00281	83 bc 24 80 00
	00 00 00	 cmp	 DWORD PTR rc$[rsp], 0
  00289	7d 0a		 jge	 SHORT $LN16@ckd_read_c
  0028b	b8 ff ff ff ff	 mov	 eax, -1
  00290	e9 eb 08 00 00	 jmp	 $LN1@ckd_read_c
$LN16@ckd_read_c:
$LN15@ckd_read_c:
$LN5@ckd_read_c:

; 1704 :     }
; 1705 : 
; 1706 :     /* Search for next count field */
; 1707 :     for ( ; ; )
; 1708 :     {
; 1709 :         /* If oriented to count or key field, skip key and data */
; 1710 :         if (dev->ckdorient == CKDORIENT_COUNT)

  00295	48 8b 84 24 20
	01 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  0029d	83 b8 d8 12 00
	00 02		 cmp	 DWORD PTR [rax+4824], 2
  002a4	75 3f		 jne	 SHORT $LN17@ckd_read_c

; 1711 :             dev->bufoff += dev->ckdcurkl + dev->ckdcurdl;

  002a6	48 8b 84 24 20
	01 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  002ae	0f b7 80 ea 12
	00 00		 movzx	 eax, WORD PTR [rax+4842]
  002b5	48 8b 8c 24 20
	01 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  002bd	8b 89 d4 12 00
	00		 mov	 ecx, DWORD PTR [rcx+4820]
  002c3	03 c8		 add	 ecx, eax
  002c5	8b c1		 mov	 eax, ecx
  002c7	48 8b 8c 24 20
	01 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  002cf	03 81 e0 01 00
	00		 add	 eax, DWORD PTR [rcx+480]
  002d5	48 8b 8c 24 20
	01 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  002dd	89 81 e0 01 00
	00		 mov	 DWORD PTR [rcx+480], eax
  002e3	eb 3c		 jmp	 SHORT $LN18@ckd_read_c
$LN17@ckd_read_c:

; 1712 :         else if (dev->ckdorient == CKDORIENT_KEY)

  002e5	48 8b 84 24 20
	01 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  002ed	83 b8 d8 12 00
	00 03		 cmp	 DWORD PTR [rax+4824], 3
  002f4	75 2b		 jne	 SHORT $LN19@ckd_read_c

; 1713 :             dev->bufoff += dev->ckdcurdl;

  002f6	48 8b 84 24 20
	01 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  002fe	0f b7 80 ea 12
	00 00		 movzx	 eax, WORD PTR [rax+4842]
  00305	48 8b 8c 24 20
	01 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  0030d	03 81 e0 01 00
	00		 add	 eax, DWORD PTR [rcx+480]
  00313	48 8b 8c 24 20
	01 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  0031b	89 81 e0 01 00
	00		 mov	 DWORD PTR [rcx+480], eax
$LN19@ckd_read_c:
$LN18@ckd_read_c:

; 1714 : 
; 1715 :         /* Make sure we don't copy past the end of the buffer */
; 1716 :         if (dev->bufoff + CKD_RECHDR_SIZE >= dev->bufoffhi)

  00321	48 8b 84 24 20
	01 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00329	48 63 80 e0 01
	00 00		 movsxd	 rax, DWORD PTR [rax+480]
  00330	48 83 c0 08	 add	 rax, 8
  00334	48 8b 8c 24 20
	01 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  0033c	48 63 89 e8 01
	00 00		 movsxd	 rcx, DWORD PTR [rcx+488]
  00343	48 3b c1	 cmp	 rax, rcx
  00346	0f 8c 30 01 00
	00		 jl	 $LN20@ckd_read_c

; 1717 :         {
; 1718 :             /* Handle error condition */
; 1719 :             // "%1d:%04X CKD file %s: error attempting to read past end of track %d %d"
; 1720 :             WRMSG( HHC00419, "E", LCSS_DEVNUM,

  0034c	48 83 bc 24 20
	01 00 00 00	 cmp	 QWORD PTR dev$[rsp], 0
  00355	74 15		 je	 SHORT $LN43@ckd_read_c
  00357	48 8b 84 24 20
	01 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  0035f	0f b7 40 48	 movzx	 eax, WORD PTR [rax+72]
  00363	89 84 24 8c 00
	00 00		 mov	 DWORD PTR tv189[rsp], eax
  0036a	eb 0b		 jmp	 SHORT $LN44@ckd_read_c
$LN43@ckd_read_c:
  0036c	c7 84 24 8c 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv189[rsp], 0
$LN44@ckd_read_c:
  00377	48 83 bc 24 20
	01 00 00 00	 cmp	 QWORD PTR dev$[rsp], 0
  00380	74 17		 je	 SHORT $LN45@ckd_read_c
  00382	48 8b 84 24 20
	01 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  0038a	0f b7 40 44	 movzx	 eax, WORD PTR [rax+68]
  0038e	d1 f8		 sar	 eax, 1
  00390	89 84 24 90 00
	00 00		 mov	 DWORD PTR tv195[rsp], eax
  00397	eb 0b		 jmp	 SHORT $LN46@ckd_read_c
$LN45@ckd_read_c:
  00399	c7 84 24 90 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv195[rsp], 0
$LN46@ckd_read_c:
  003a4	48 8b 84 24 20
	01 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  003ac	48 05 a4 00 00
	00		 add	 rax, 164		; 000000a4H
  003b2	48 89 84 24 c8
	00 00 00	 mov	 QWORD PTR tv184[rsp], rax
  003ba	b9 01 00 00 00	 mov	 ecx, 1
  003bf	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  003c5	48 8b 8c 24 20
	01 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  003cd	8b 89 e8 01 00
	00		 mov	 ecx, DWORD PTR [rcx+488]
  003d3	89 4c 24 58	 mov	 DWORD PTR [rsp+88], ecx
  003d7	48 8b 8c 24 20
	01 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  003df	8b 89 e0 01 00
	00		 mov	 ecx, DWORD PTR [rcx+480]
  003e5	89 4c 24 50	 mov	 DWORD PTR [rsp+80], ecx
  003e9	48 8b 8c 24 c8
	00 00 00	 mov	 rcx, QWORD PTR tv184[rsp]
  003f1	48 89 4c 24 48	 mov	 QWORD PTR [rsp+72], rcx
  003f6	8b 8c 24 8c 00
	00 00		 mov	 ecx, DWORD PTR tv189[rsp]
  003fd	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  00401	8b 8c 24 90 00
	00 00		 mov	 ecx, DWORD PTR tv195[rsp]
  00408	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  0040c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG171249
  00413	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  00418	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG171250
  0041f	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00424	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00429	41 b9 03 00 00
	00		 mov	 r9d, 3
  0042f	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG171251
  00436	ba b9 06 00 00	 mov	 edx, 1721		; 000006b9H
  0043b	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG171252
  00442	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 1721 :                    dev->filename, dev->bufoff, dev->bufoffhi );
; 1722 : 
; 1723 :             /* Set unit check with equipment check */
; 1724 :             ckd_build_sense (dev, SENSE_EC, 0, 0,

  00448	c6 44 24 28 00	 mov	 BYTE PTR [rsp+40], 0
  0044d	c6 44 24 20 01	 mov	 BYTE PTR [rsp+32], 1
  00452	45 33 c9	 xor	 r9d, r9d
  00455	45 33 c0	 xor	 r8d, r8d
  00458	b2 10		 mov	 dl, 16
  0045a	48 8b 8c 24 20
	01 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  00462	e8 00 00 00 00	 call	 ckd_build_sense

; 1725 :                             FORMAT_1, MESSAGE_0);
; 1726 :             *unitstat = CSW_CE | CSW_DE | CSW_UC;

  00467	48 8b 84 24 38
	01 00 00	 mov	 rax, QWORD PTR unitstat$[rsp]
  0046f	c6 00 0e	 mov	 BYTE PTR [rax], 14

; 1727 :             return -1;

  00472	b8 ff ff ff ff	 mov	 eax, -1
  00477	e9 04 07 00 00	 jmp	 $LN1@ckd_read_c
$LN20@ckd_read_c:

; 1728 :         }
; 1729 : 
; 1730 :         /* Copy the record header (count field) */
; 1731 :         memcpy (rechdr, &dev->buf[dev->bufoff], CKD_RECHDR_SIZE);

  0047c	48 8b 84 24 20
	01 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00484	48 63 80 e0 01
	00 00		 movsxd	 rax, DWORD PTR [rax+480]
  0048b	48 8b 8c 24 20
	01 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  00493	48 8b 89 c8 01
	00 00		 mov	 rcx, QWORD PTR [rcx+456]
  0049a	48 8b 94 24 30
	01 00 00	 mov	 rdx, QWORD PTR rechdr$[rsp]
  004a2	48 8b 04 01	 mov	 rax, QWORD PTR [rcx+rax]
  004a6	48 89 02	 mov	 QWORD PTR [rdx], rax

; 1732 :         dev->bufoff += CKD_RECHDR_SIZE;

  004a9	48 8b 84 24 20
	01 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  004b1	48 63 80 e0 01
	00 00		 movsxd	 rax, DWORD PTR [rax+480]
  004b8	48 83 c0 08	 add	 rax, 8
  004bc	48 8b 8c 24 20
	01 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  004c4	89 81 e0 01 00
	00		 mov	 DWORD PTR [rcx+480], eax

; 1733 : 
; 1734 :         /* Set the device orientation fields */
; 1735 :         dev->ckdcurrec = rechdr->rec;

  004ca	48 8b 84 24 30
	01 00 00	 mov	 rax, QWORD PTR rechdr$[rsp]
  004d2	0f b6 40 04	 movzx	 eax, BYTE PTR [rax+4]
  004d6	48 8b 8c 24 20
	01 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  004de	89 81 d0 12 00
	00		 mov	 DWORD PTR [rcx+4816], eax

; 1736 :         dev->ckdrem = 0;

  004e4	33 c0		 xor	 eax, eax
  004e6	48 8b 8c 24 20
	01 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  004ee	66 89 81 ec 12
	00 00		 mov	 WORD PTR [rcx+4844], ax

; 1737 :         dev->ckdorient = CKDORIENT_COUNT;

  004f5	48 8b 84 24 20
	01 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  004fd	c7 80 d8 12 00
	00 02 00 00 00	 mov	 DWORD PTR [rax+4824], 2

; 1738 :         dev->ckdcurkl = rechdr->klen;

  00507	48 8b 84 24 30
	01 00 00	 mov	 rax, QWORD PTR rechdr$[rsp]
  0050f	0f b6 40 05	 movzx	 eax, BYTE PTR [rax+5]
  00513	48 8b 8c 24 20
	01 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  0051b	89 81 d4 12 00
	00		 mov	 DWORD PTR [rcx+4820], eax

; 1739 :         dev->ckdcurdl = (rechdr->dlen[0] << 8) + rechdr->dlen[1];

  00521	b8 01 00 00 00	 mov	 eax, 1
  00526	48 6b c0 00	 imul	 rax, rax, 0
  0052a	48 8b 8c 24 30
	01 00 00	 mov	 rcx, QWORD PTR rechdr$[rsp]
  00532	0f b6 44 01 06	 movzx	 eax, BYTE PTR [rcx+rax+6]
  00537	c1 e0 08	 shl	 eax, 8
  0053a	b9 01 00 00 00	 mov	 ecx, 1
  0053f	48 6b c9 01	 imul	 rcx, rcx, 1
  00543	48 8b 94 24 30
	01 00 00	 mov	 rdx, QWORD PTR rechdr$[rsp]
  0054b	0f b6 4c 0a 06	 movzx	 ecx, BYTE PTR [rdx+rcx+6]
  00550	03 c1		 add	 eax, ecx
  00552	48 8b 8c 24 20
	01 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  0055a	66 89 81 ea 12
	00 00		 mov	 WORD PTR [rcx+4842], ax

; 1740 :         if(dev->ckdcyls < 32768)

  00561	48 8b 84 24 20
	01 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00569	81 b8 b8 12 00
	00 00 80 00 00	 cmp	 DWORD PTR [rax+4792], 32768 ; 00008000H
  00573	7d 7b		 jge	 SHORT $LN21@ckd_read_c

; 1741 :             dev->ckdtrkof = (rechdr->cyl[0] == 0xFF) ? 0 : rechdr->cyl[0] >> 7;

  00575	b8 01 00 00 00	 mov	 eax, 1
  0057a	48 6b c0 00	 imul	 rax, rax, 0
  0057e	48 8b 8c 24 30
	01 00 00	 mov	 rcx, QWORD PTR rechdr$[rsp]
  00586	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  0058a	3d ff 00 00 00	 cmp	 eax, 255		; 000000ffH
  0058f	75 0d		 jne	 SHORT $LN47@ckd_read_c
  00591	c7 84 24 94 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv262[rsp], 0
  0059c	eb 1f		 jmp	 SHORT $LN48@ckd_read_c
$LN47@ckd_read_c:
  0059e	b8 01 00 00 00	 mov	 eax, 1
  005a3	48 6b c0 00	 imul	 rax, rax, 0
  005a7	48 8b 8c 24 30
	01 00 00	 mov	 rcx, QWORD PTR rechdr$[rsp]
  005af	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  005b3	c1 f8 07	 sar	 eax, 7
  005b6	89 84 24 94 00
	00 00		 mov	 DWORD PTR tv262[rsp], eax
$LN48@ckd_read_c:
  005bd	8b 84 24 94 00
	00 00		 mov	 eax, DWORD PTR tv262[rsp]
  005c4	83 e0 01	 and	 eax, 1
  005c7	c1 e0 0f	 shl	 eax, 15
  005ca	48 8b 8c 24 20
	01 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  005d2	8b 89 14 13 00
	00		 mov	 ecx, DWORD PTR [rcx+4884]
  005d8	0f ba f1 0f	 btr	 ecx, 15
  005dc	0b c8		 or	 ecx, eax
  005de	8b c1		 mov	 eax, ecx
  005e0	48 8b 8c 24 20
	01 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  005e8	89 81 14 13 00
	00		 mov	 DWORD PTR [rcx+4884], eax
  005ee	eb 20		 jmp	 SHORT $LN22@ckd_read_c
$LN21@ckd_read_c:

; 1742 :         else
; 1743 :             dev->ckdtrkof = 0;

  005f0	48 8b 84 24 20
	01 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  005f8	8b 80 14 13 00
	00		 mov	 eax, DWORD PTR [rax+4884]
  005fe	0f ba f0 0f	 btr	 eax, 15
  00602	48 8b 8c 24 20
	01 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  0060a	89 81 14 13 00
	00		 mov	 DWORD PTR [rcx+4884], eax
$LN22@ckd_read_c:

; 1744 : 
; 1745 :         // "%1d:%04X CKD file %s: cyl %d head %d record %d kl %d dl %d of %d"
; 1746 :         if (dev->ccwtrace && sysblk.traceFILE)

  00610	48 8b 84 24 20
	01 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00618	8b 80 f8 05 00
	00		 mov	 eax, DWORD PTR [rax+1528]
  0061e	c1 e8 0f	 shr	 eax, 15
  00621	83 e0 01	 and	 eax, 1
  00624	85 c0		 test	 eax, eax
  00626	74 24		 je	 SHORT $LN23@ckd_read_c
  00628	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  0062f	48 83 b8 20 14
	00 00 00	 cmp	 QWORD PTR [rax+5152], 0
  00637	74 13		 je	 SHORT $LN23@ckd_read_c

; 1747 :             tf_0435( dev );

  00639	48 8b 8c 24 20
	01 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  00641	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_tf_0435
  00647	e9 63 01 00 00	 jmp	 $LN24@ckd_read_c
$LN23@ckd_read_c:
$LN10@ckd_read_c:

; 1748 :         else
; 1749 :             LOGDEVTR( HHC00435, "I",  dev->filename,

  0064c	48 8b 84 24 20
	01 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00654	8b 80 f8 05 00
	00		 mov	 eax, DWORD PTR [rax+1528]
  0065a	c1 e8 0f	 shr	 eax, 15
  0065d	83 e0 01	 and	 eax, 1
  00660	85 c0		 test	 eax, eax
  00662	0f 84 3d 01 00
	00		 je	 $LN25@ckd_read_c
  00668	48 8b 84 24 20
	01 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00670	8b 80 14 13 00
	00		 mov	 eax, DWORD PTR [rax+4884]
  00676	c1 e8 0f	 shr	 eax, 15
  00679	83 e0 01	 and	 eax, 1
  0067c	89 84 24 a4 00
	00 00		 mov	 DWORD PTR tv284[rsp], eax
  00683	48 8b 8c 24 20
	01 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  0068b	0f b7 89 ea 12
	00 00		 movzx	 ecx, WORD PTR [rcx+4842]
  00692	89 8c 24 a8 00
	00 00		 mov	 DWORD PTR tv287[rsp], ecx
  00699	48 8b 94 24 20
	01 00 00	 mov	 rdx, QWORD PTR dev$[rsp]
  006a1	48 81 c2 a4 00
	00 00		 add	 rdx, 164		; 000000a4H
  006a8	48 89 94 24 d0
	00 00 00	 mov	 QWORD PTR tv297[rsp], rdx
  006b0	4c 8b 84 24 20
	01 00 00	 mov	 r8, QWORD PTR dev$[rsp]
  006b8	45 0f b7 40 48	 movzx	 r8d, WORD PTR [r8+72]
  006bd	44 89 84 24 ac
	00 00 00	 mov	 DWORD PTR tv300[rsp], r8d
  006c5	4c 8b 8c 24 20
	01 00 00	 mov	 r9, QWORD PTR dev$[rsp]
  006cd	45 0f b7 49 44	 movzx	 r9d, WORD PTR [r9+68]
  006d2	41 d1 f9	 sar	 r9d, 1
  006d5	44 89 8c 24 b0
	00 00 00	 mov	 DWORD PTR tv304[rsp], r9d
  006dd	b9 01 00 00 00	 mov	 ecx, 1
  006e2	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  006e8	8b 8c 24 a4 00
	00 00		 mov	 ecx, DWORD PTR tv284[rsp]
  006ef	89 4c 24 78	 mov	 DWORD PTR [rsp+120], ecx
  006f3	8b 8c 24 a8 00
	00 00		 mov	 ecx, DWORD PTR tv287[rsp]
  006fa	89 4c 24 70	 mov	 DWORD PTR [rsp+112], ecx
  006fe	48 8b 8c 24 20
	01 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  00706	8b 89 d4 12 00
	00		 mov	 ecx, DWORD PTR [rcx+4820]
  0070c	89 4c 24 68	 mov	 DWORD PTR [rsp+104], ecx
  00710	48 8b 8c 24 20
	01 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  00718	8b 89 d0 12 00
	00		 mov	 ecx, DWORD PTR [rcx+4816]
  0071e	89 4c 24 60	 mov	 DWORD PTR [rsp+96], ecx
  00722	48 8b 8c 24 20
	01 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  0072a	8b 89 cc 12 00
	00		 mov	 ecx, DWORD PTR [rcx+4812]
  00730	89 4c 24 58	 mov	 DWORD PTR [rsp+88], ecx
  00734	48 8b 8c 24 20
	01 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  0073c	8b 89 c8 12 00
	00		 mov	 ecx, DWORD PTR [rcx+4808]
  00742	89 4c 24 50	 mov	 DWORD PTR [rsp+80], ecx
  00746	48 8b 8c 24 d0
	00 00 00	 mov	 rcx, QWORD PTR tv297[rsp]
  0074e	48 89 4c 24 48	 mov	 QWORD PTR [rsp+72], rcx
  00753	8b 8c 24 ac 00
	00 00		 mov	 ecx, DWORD PTR tv300[rsp]
  0075a	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  0075e	8b 8c 24 b0 00
	00 00		 mov	 ecx, DWORD PTR tv304[rsp]
  00765	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  00769	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG171258
  00770	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  00775	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG171259
  0077c	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00781	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00786	41 b9 03 00 00
	00		 mov	 r9d, 3
  0078c	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG171260
  00793	ba d7 06 00 00	 mov	 edx, 1751		; 000006d7H
  00798	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG171261
  0079f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg
$LN25@ckd_read_c:
  007a5	33 c0		 xor	 eax, eax
  007a7	85 c0		 test	 eax, eax
  007a9	0f 85 9d fe ff
	ff		 jne	 $LN10@ckd_read_c
$LN24@ckd_read_c:

; 1750 :                       dev->ckdcurcyl, dev->ckdcurhead, dev->ckdcurrec,
; 1751 :                       dev->ckdcurkl,  dev->ckdcurdl,   dev->ckdtrkof );
; 1752 : 
; 1753 :         /* Skip record zero if user data record required */
; 1754 :         if (skipr0 && rechdr->rec == 0)

  007af	83 bc 24 98 00
	00 00 00	 cmp	 DWORD PTR skipr0$[rsp], 0
  007b7	74 15		 je	 SHORT $LN26@ckd_read_c
  007b9	48 8b 84 24 30
	01 00 00	 mov	 rax, QWORD PTR rechdr$[rsp]
  007c1	0f b6 40 04	 movzx	 eax, BYTE PTR [rax+4]
  007c5	85 c0		 test	 eax, eax
  007c7	75 05		 jne	 SHORT $LN26@ckd_read_c

; 1755 :             continue;

  007c9	e9 c7 fa ff ff	 jmp	 $LN5@ckd_read_c
$LN26@ckd_read_c:

; 1756 : 
; 1757 :         /* Test for logical end of track and exit if not */
; 1758 :         if (memcmp( rechdr, &CKD_ENDTRK, CKD_ENDTRK_SIZE ) != 0)

  007ce	41 b8 08 00 00
	00		 mov	 r8d, 8
  007d4	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:CKD_ENDTRK
  007db	48 8b 8c 24 30
	01 00 00	 mov	 rcx, QWORD PTR rechdr$[rsp]
  007e3	e8 00 00 00 00	 call	 memcmp
  007e8	85 c0		 test	 eax, eax
  007ea	74 05		 je	 SHORT $LN27@ckd_read_c

; 1759 :             break;

  007ec	e9 8d 03 00 00	 jmp	 $LN6@ckd_read_c
$LN27@ckd_read_c:

; 1760 :         dev->ckdorient = CKDORIENT_EOT;

  007f1	48 8b 84 24 20
	01 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  007f9	c7 80 d8 12 00
	00 05 00 00 00	 mov	 DWORD PTR [rax+4824], 5

; 1761 : 
; 1762 :         /* For READ TRACK or READ MULTIPLE CKD, return with the
; 1763 :            end of track marker in the record header field */
; 1764 :         if (code == 0xDE || code == 0x5E)

  00803	0f b6 84 24 28
	01 00 00	 movzx	 eax, BYTE PTR code$[rsp]
  0080b	3d de 00 00 00	 cmp	 eax, 222		; 000000deH
  00810	74 0d		 je	 SHORT $LN29@ckd_read_c
  00812	0f b6 84 24 28
	01 00 00	 movzx	 eax, BYTE PTR code$[rsp]
  0081a	83 f8 5e	 cmp	 eax, 94			; 0000005eH
  0081d	75 05		 jne	 SHORT $LN28@ckd_read_c
$LN29@ckd_read_c:

; 1765 :             break;

  0081f	e9 5a 03 00 00	 jmp	 $LN6@ckd_read_c
$LN28@ckd_read_c:

; 1766 : 
; 1767 :         /* End of track found, so terminate with no record found
; 1768 :            error if this is a LOCATE RECORD or WRITE CKD NEXT TRACK
; 1769 :            command; or if this is the second end of track in this
; 1770 :            channel program without an intervening read of the home
; 1771 :            address or data area and without an intervening write,
; 1772 :            sense, or control command --
; 1773 :            -- except when multitrack READ or SEARCH [KEY?] command
; 1774 :            operates outside the domain of a locate record */
; 1775 :         if (1
; 1776 :             && (code & 0x80)
; 1777 :             && (dev->ckdlaux & CKDLAUX_RDCNTSUF)
; 1778 :             && dev->ckdlcount > 0

  00824	33 c0		 xor	 eax, eax
  00826	83 f8 01	 cmp	 eax, 1
  00829	0f 84 f4 00 00
	00		 je	 $LN30@ckd_read_c
  0082f	0f b6 84 24 28
	01 00 00	 movzx	 eax, BYTE PTR code$[rsp]
  00837	25 80 00 00 00	 and	 eax, 128		; 00000080H
  0083c	85 c0		 test	 eax, eax
  0083e	0f 84 df 00 00
	00		 je	 $LN30@ckd_read_c
  00844	48 8b 84 24 20
	01 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  0084c	0f b6 80 01 13
	00 00		 movzx	 eax, BYTE PTR [rax+4865]
  00853	83 e0 01	 and	 eax, 1
  00856	85 c0		 test	 eax, eax
  00858	0f 84 c5 00 00
	00		 je	 $LN30@ckd_read_c
  0085e	48 8b 84 24 20
	01 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00866	0f b6 80 02 13
	00 00		 movzx	 eax, BYTE PTR [rax+4866]
  0086d	85 c0		 test	 eax, eax
  0086f	0f 8e ae 00 00
	00		 jle	 $LN30@ckd_read_c

; 1779 :         )
; 1780 :         {
; 1781 :             memcpy( rechdr, dev->ckdfcwrk, CKD_RECHDR_SIZE );

  00875	48 8b 84 24 30
	01 00 00	 mov	 rax, QWORD PTR rechdr$[rsp]
  0087d	48 8b 8c 24 20
	01 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  00885	48 8b 89 e0 12
	00 00		 mov	 rcx, QWORD PTR [rcx+4832]
  0088c	48 89 08	 mov	 QWORD PTR [rax], rcx

; 1782 :             cyl  = fetch_hw( rechdr->cyl );

  0088f	48 8b 84 24 30
	01 00 00	 mov	 rax, QWORD PTR rechdr$[rsp]
  00897	48 8b c8	 mov	 rcx, rax
  0089a	e8 00 00 00 00	 call	 fetch_hw_noswap
  0089f	0f b7 c8	 movzx	 ecx, ax
  008a2	e8 00 00 00 00	 call	 _byteswap_ushort
  008a7	0f b7 c0	 movzx	 eax, ax
  008aa	89 84 24 88 00
	00 00		 mov	 DWORD PTR cyl$[rsp], eax

; 1783 :             head = fetch_hw( rechdr->head );

  008b1	48 8b 84 24 30
	01 00 00	 mov	 rax, QWORD PTR rechdr$[rsp]
  008b9	48 83 c0 02	 add	 rax, 2
  008bd	48 8b c8	 mov	 rcx, rax
  008c0	e8 00 00 00 00	 call	 fetch_hw_noswap
  008c5	0f b7 c8	 movzx	 ecx, ax
  008c8	e8 00 00 00 00	 call	 _byteswap_ushort
  008cd	0f b7 c0	 movzx	 eax, ax
  008d0	89 84 24 84 00
	00 00		 mov	 DWORD PTR head$[rsp], eax

; 1784 :             if ((rc = ckd_seek( dev, cyl, head, NULL, unitstat )) < 0)

  008d7	48 8b 84 24 38
	01 00 00	 mov	 rax, QWORD PTR unitstat$[rsp]
  008df	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  008e4	45 33 c9	 xor	 r9d, r9d
  008e7	44 8b 84 24 84
	00 00 00	 mov	 r8d, DWORD PTR head$[rsp]
  008ef	8b 94 24 88 00
	00 00		 mov	 edx, DWORD PTR cyl$[rsp]
  008f6	48 8b 8c 24 20
	01 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  008fe	e8 00 00 00 00	 call	 ckd_seek
  00903	89 84 24 80 00
	00 00		 mov	 DWORD PTR rc$[rsp], eax
  0090a	83 bc 24 80 00
	00 00 00	 cmp	 DWORD PTR rc$[rsp], 0
  00912	7d 0a		 jge	 SHORT $LN31@ckd_read_c

; 1785 :                 return -1;

  00914	b8 ff ff ff ff	 mov	 eax, -1
  00919	e9 62 02 00 00	 jmp	 $LN1@ckd_read_c
$LN31@ckd_read_c:

; 1786 :             continue;

  0091e	e9 72 f9 ff ff	 jmp	 $LN5@ckd_read_c
$LN30@ckd_read_c:

; 1787 :         }
; 1788 :         if (code != 0xe7)

  00923	0f b6 84 24 28
	01 00 00	 movzx	 eax, BYTE PTR code$[rsp]
  0092b	3d e7 00 00 00	 cmp	 eax, 231		; 000000e7H
  00930	0f 84 e2 00 00
	00		 je	 $LN32@ckd_read_c

; 1789 :         {
; 1790 :             if (code == 0x47 || code == 0x4B || code == 0x9D
; 1791 :                 || (dev->ckdxmark

  00936	0f b6 84 24 28
	01 00 00	 movzx	 eax, BYTE PTR code$[rsp]
  0093e	83 f8 47	 cmp	 eax, 71			; 00000047H
  00941	0f 84 9d 00 00
	00		 je	 $LN34@ckd_read_c
  00947	0f b6 84 24 28
	01 00 00	 movzx	 eax, BYTE PTR code$[rsp]
  0094f	83 f8 4b	 cmp	 eax, 75			; 0000004bH
  00952	0f 84 8c 00 00
	00		 je	 $LN34@ckd_read_c
  00958	0f b6 84 24 28
	01 00 00	 movzx	 eax, BYTE PTR code$[rsp]
  00960	3d 9d 00 00 00	 cmp	 eax, 157		; 0000009dH
  00965	74 7d		 je	 SHORT $LN34@ckd_read_c
  00967	48 8b 84 24 20
	01 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  0096f	8b 80 14 13 00
	00		 mov	 eax, DWORD PTR [rax+4884]
  00975	c1 e8 0a	 shr	 eax, 10
  00978	83 e0 01	 and	 eax, 1
  0097b	85 c0		 test	 eax, eax
  0097d	0f 84 95 00 00
	00		 je	 $LN33@ckd_read_c
  00983	48 8b 84 24 20
	01 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  0098b	0f b6 80 02 13
	00 00		 movzx	 eax, BYTE PTR [rax+4866]
  00992	85 c0		 test	 eax, eax
  00994	75 4e		 jne	 SHORT $LN35@ckd_read_c
  00996	0f b6 84 24 28
	01 00 00	 movzx	 eax, BYTE PTR code$[rsp]
  0099e	83 e0 03	 and	 eax, 3
  009a1	83 f8 02	 cmp	 eax, 2
  009a4	75 11		 jne	 SHORT $LN36@ckd_read_c
  009a6	0f b6 84 24 28
	01 00 00	 movzx	 eax, BYTE PTR code$[rsp]
  009ae	25 80 00 00 00	 and	 eax, 128		; 00000080H
  009b3	85 c0		 test	 eax, eax
  009b5	75 61		 jne	 SHORT $LN33@ckd_read_c
$LN36@ckd_read_c:
  009b7	0f b6 84 24 28
	01 00 00	 movzx	 eax, BYTE PTR code$[rsp]
  009bf	3d a9 00 00 00	 cmp	 eax, 169		; 000000a9H
  009c4	74 52		 je	 SHORT $LN33@ckd_read_c
  009c6	0f b6 84 24 28
	01 00 00	 movzx	 eax, BYTE PTR code$[rsp]
  009ce	3d c9 00 00 00	 cmp	 eax, 201		; 000000c9H
  009d3	74 43		 je	 SHORT $LN33@ckd_read_c
  009d5	0f b6 84 24 28
	01 00 00	 movzx	 eax, BYTE PTR code$[rsp]
  009dd	3d e9 00 00 00	 cmp	 eax, 233		; 000000e9H
  009e2	74 34		 je	 SHORT $LN33@ckd_read_c
$LN35@ckd_read_c:
$LN34@ckd_read_c:

; 1792 :                     && !((dev->ckdlcount == 0)
; 1793 :                         && ((IS_CCW_READ(code) && (code & 0x80))
; 1794 :                             || code == 0xA9 || code == 0xC9 || code == 0xE9))))
; 1795 :             {
; 1796 :                 ckd_build_sense(dev, 0, SENSE1_NRF, 0, 0, 0);

  009e4	c6 44 24 28 00	 mov	 BYTE PTR [rsp+40], 0
  009e9	c6 44 24 20 00	 mov	 BYTE PTR [rsp+32], 0
  009ee	45 33 c9	 xor	 r9d, r9d
  009f1	41 b0 08	 mov	 r8b, 8
  009f4	33 d2		 xor	 edx, edx
  009f6	48 8b 8c 24 20
	01 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  009fe	e8 00 00 00 00	 call	 ckd_build_sense

; 1797 :                 *unitstat = CSW_CE | CSW_DE | CSW_UC;

  00a03	48 8b 84 24 38
	01 00 00	 mov	 rax, QWORD PTR unitstat$[rsp]
  00a0b	c6 00 0e	 mov	 BYTE PTR [rax], 14

; 1798 :                 return -1;

  00a0e	b8 ff ff ff ff	 mov	 eax, -1
  00a13	e9 68 01 00 00	 jmp	 $LN1@ckd_read_c
$LN33@ckd_read_c:
$LN32@ckd_read_c:

; 1799 :             }
; 1800 :         }
; 1801 : 
; 1802 :         /* Test for multitrack operation */
; 1803 :         if ((code & 0x80) == 0)

  00a18	0f b6 84 24 28
	01 00 00	 movzx	 eax, BYTE PTR code$[rsp]
  00a20	25 80 00 00 00	 and	 eax, 128		; 00000080H
  00a25	85 c0		 test	 eax, eax
  00a27	0f 85 96 00 00
	00		 jne	 $LN37@ckd_read_c

; 1804 :         {
; 1805 :             /* If non-multitrack, return to start of current track */
; 1806 :             cyl = dev->ckdcurcyl;

  00a2d	48 8b 84 24 20
	01 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00a35	8b 80 c8 12 00
	00		 mov	 eax, DWORD PTR [rax+4808]
  00a3b	89 84 24 88 00
	00 00		 mov	 DWORD PTR cyl$[rsp], eax

; 1807 :             head = dev->ckdcurhead;

  00a42	48 8b 84 24 20
	01 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00a4a	8b 80 cc 12 00
	00		 mov	 eax, DWORD PTR [rax+4812]
  00a50	89 84 24 84 00
	00 00		 mov	 DWORD PTR head$[rsp], eax

; 1808 :             rc = ckd_seek (dev, cyl, head, NULL, unitstat);

  00a57	48 8b 84 24 38
	01 00 00	 mov	 rax, QWORD PTR unitstat$[rsp]
  00a5f	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00a64	45 33 c9	 xor	 r9d, r9d
  00a67	44 8b 84 24 84
	00 00 00	 mov	 r8d, DWORD PTR head$[rsp]
  00a6f	8b 94 24 88 00
	00 00		 mov	 edx, DWORD PTR cyl$[rsp]
  00a76	48 8b 8c 24 20
	01 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  00a7e	e8 00 00 00 00	 call	 ckd_seek
  00a83	89 84 24 80 00
	00 00		 mov	 DWORD PTR rc$[rsp], eax

; 1809 :             if (rc < 0) return -1;

  00a8a	83 bc 24 80 00
	00 00 00	 cmp	 DWORD PTR rc$[rsp], 0
  00a92	7d 0a		 jge	 SHORT $LN39@ckd_read_c
  00a94	b8 ff ff ff ff	 mov	 eax, -1
  00a99	e9 e2 00 00 00	 jmp	 $LN1@ckd_read_c
$LN39@ckd_read_c:

; 1810 : 
; 1811 :             /* Set index marker found flag */
; 1812 :             dev->ckdxmark = 1;

  00a9e	48 8b 84 24 20
	01 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00aa6	8b 80 14 13 00
	00		 mov	 eax, DWORD PTR [rax+4884]
  00aac	0f ba e8 0a	 bts	 eax, 10
  00ab0	48 8b 8c 24 20
	01 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  00ab8	89 81 14 13 00
	00		 mov	 DWORD PTR [rcx+4884], eax

; 1813 :         }

  00abe	e9 b6 00 00 00	 jmp	 $LN38@ckd_read_c
$LN37@ckd_read_c:

; 1814 :         else
; 1815 :         {
; 1816 :             /* If multitrack, attempt to advance to next track */
; 1817 :             rc = mt_advance (dev, unitstat, 1);

  00ac3	41 b8 01 00 00
	00		 mov	 r8d, 1
  00ac9	48 8b 94 24 38
	01 00 00	 mov	 rdx, QWORD PTR unitstat$[rsp]
  00ad1	48 8b 8c 24 20
	01 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  00ad9	e8 00 00 00 00	 call	 mt_advance
  00ade	89 84 24 80 00
	00 00		 mov	 DWORD PTR rc$[rsp], eax

; 1818 :             if (rc < 0) return -1;

  00ae5	83 bc 24 80 00
	00 00 00	 cmp	 DWORD PTR rc$[rsp], 0
  00aed	7d 0a		 jge	 SHORT $LN40@ckd_read_c
  00aef	b8 ff ff ff ff	 mov	 eax, -1
  00af4	e9 87 00 00 00	 jmp	 $LN1@ckd_read_c
$LN40@ckd_read_c:

; 1819 : 
; 1820 :             /* Set index marker flag if non-search command */
; 1821 :             if ((code & 0x7F) != 0x31
; 1822 :                 && (code & 0x7F) != 0x51
; 1823 :                 && (code & 0x7F) != 0x71
; 1824 :                 && (code & 0x7F) != 0x29
; 1825 :                 && (code & 0x7F) != 0x49
; 1826 :                 && (code & 0x7F) != 0x69)

  00af9	0f b6 84 24 28
	01 00 00	 movzx	 eax, BYTE PTR code$[rsp]
  00b01	83 e0 7f	 and	 eax, 127		; 0000007fH
  00b04	83 f8 31	 cmp	 eax, 49			; 00000031H
  00b07	74 70		 je	 SHORT $LN41@ckd_read_c
  00b09	0f b6 84 24 28
	01 00 00	 movzx	 eax, BYTE PTR code$[rsp]
  00b11	83 e0 7f	 and	 eax, 127		; 0000007fH
  00b14	83 f8 51	 cmp	 eax, 81			; 00000051H
  00b17	74 60		 je	 SHORT $LN41@ckd_read_c
  00b19	0f b6 84 24 28
	01 00 00	 movzx	 eax, BYTE PTR code$[rsp]
  00b21	83 e0 7f	 and	 eax, 127		; 0000007fH
  00b24	83 f8 71	 cmp	 eax, 113		; 00000071H
  00b27	74 50		 je	 SHORT $LN41@ckd_read_c
  00b29	0f b6 84 24 28
	01 00 00	 movzx	 eax, BYTE PTR code$[rsp]
  00b31	83 e0 7f	 and	 eax, 127		; 0000007fH
  00b34	83 f8 29	 cmp	 eax, 41			; 00000029H
  00b37	74 40		 je	 SHORT $LN41@ckd_read_c
  00b39	0f b6 84 24 28
	01 00 00	 movzx	 eax, BYTE PTR code$[rsp]
  00b41	83 e0 7f	 and	 eax, 127		; 0000007fH
  00b44	83 f8 49	 cmp	 eax, 73			; 00000049H
  00b47	74 30		 je	 SHORT $LN41@ckd_read_c
  00b49	0f b6 84 24 28
	01 00 00	 movzx	 eax, BYTE PTR code$[rsp]
  00b51	83 e0 7f	 and	 eax, 127		; 0000007fH
  00b54	83 f8 69	 cmp	 eax, 105		; 00000069H
  00b57	74 20		 je	 SHORT $LN41@ckd_read_c

; 1827 :                 dev->ckdxmark = 1;

  00b59	48 8b 84 24 20
	01 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00b61	8b 80 14 13 00
	00		 mov	 eax, DWORD PTR [rax+4884]
  00b67	0f ba e8 0a	 bts	 eax, 10
  00b6b	48 8b 8c 24 20
	01 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  00b73	89 81 14 13 00
	00		 mov	 DWORD PTR [rcx+4884], eax
$LN41@ckd_read_c:
$LN38@ckd_read_c:

; 1828 :         }
; 1829 : 
; 1830 :     } /* end for */

  00b79	e9 17 f7 ff ff	 jmp	 $LN5@ckd_read_c
$LN6@ckd_read_c:

; 1831 : 
; 1832 :     return 0;

  00b7e	33 c0		 xor	 eax, eax
$LN1@ckd_read_c:

; 1833 : 
; 1834 : } /* end function ckd_read_count */

  00b80	48 8b 8c 24 08
	01 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  00b88	48 33 cc	 xor	 rcx, rsp
  00b8b	e8 00 00 00 00	 call	 __security_check_cookie
  00b90	48 81 c4 18 01
	00 00		 add	 rsp, 280		; 00000118H
  00b97	c3		 ret	 0
ckd_read_count ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\ckddasd.c
_TEXT	SEGMENT
cyl$ = 96
head$ = 100
tv83 = 104
tv86 = 108
tv91 = 112
tv95 = 116
tv204 = 120
tv208 = 124
rc$ = 128
tv88 = 136
tv201 = 144
dev$ = 176
unitstat$ = 184
trks$ = 192
mt_advance PROC

; 1594 : {

  00000	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	48 81 ec a8 00
	00 00		 sub	 rsp, 168		; 000000a8H

; 1595 : int             rc;                     /* Return code               */
; 1596 : int             cyl;                    /* Next cyl for multitrack   */
; 1597 : int             head;                   /* Next head for multitrack  */
; 1598 : 
; 1599 :     /* File protect error if not within domain of Locate Record
; 1600 :        and file mask inhibits seek and multitrack operations */
; 1601 :     if (dev->ckdlcount == 0 &&

  00016	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  0001e	0f b6 80 02 13
	00 00		 movzx	 eax, BYTE PTR [rax+4866]
  00025	85 c0		 test	 eax, eax
  00027	0f 85 c2 01 00
	00		 jne	 $LN10@mt_advance
  0002d	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00035	0f b6 80 fa 12
	00 00		 movzx	 eax, BYTE PTR [rax+4858]
  0003c	83 e0 18	 and	 eax, 24
  0003f	83 f8 18	 cmp	 eax, 24
  00042	0f 85 a7 01 00
	00		 jne	 $LN10@mt_advance

; 1602 :         (dev->ckdfmask & CKDMASK_SKCTL) == CKDMASK_SKCTL_INHSMT)
; 1603 :     {
; 1604 :         // "%1d:%04X CKD file %s: error: MT advance: locate record %d file mask %02X"
; 1605 :         if (dev->ccwtrace && sysblk.traceFILE)

  00048	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00050	8b 80 f8 05 00
	00		 mov	 eax, DWORD PTR [rax+1528]
  00056	c1 e8 0f	 shr	 eax, 15
  00059	83 e0 01	 and	 eax, 1
  0005c	85 c0		 test	 eax, eax
  0005e	74 24		 je	 SHORT $LN11@mt_advance
  00060	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00067	48 83 b8 20 14
	00 00 00	 cmp	 QWORD PTR [rax+5152], 0
  0006f	74 13		 je	 SHORT $LN11@mt_advance

; 1606 :             tf_0432( dev );

  00071	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  00079	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_tf_0432
  0007f	e9 fe 00 00 00	 jmp	 $LN12@mt_advance
$LN11@mt_advance:
$LN4@mt_advance:

; 1607 :         else
; 1608 :             LOGDEVTR( HHC00432, "E", dev->filename, dev->ckdlcount, dev->ckdfmask );

  00084	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  0008c	8b 80 f8 05 00
	00		 mov	 eax, DWORD PTR [rax+1528]
  00092	c1 e8 0f	 shr	 eax, 15
  00095	83 e0 01	 and	 eax, 1
  00098	85 c0		 test	 eax, eax
  0009a	0f 84 d8 00 00
	00		 je	 $LN13@mt_advance
  000a0	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  000a8	0f b6 80 fa 12
	00 00		 movzx	 eax, BYTE PTR [rax+4858]
  000af	89 44 24 68	 mov	 DWORD PTR tv83[rsp], eax
  000b3	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  000bb	0f b6 89 02 13
	00 00		 movzx	 ecx, BYTE PTR [rcx+4866]
  000c2	89 4c 24 6c	 mov	 DWORD PTR tv86[rsp], ecx
  000c6	48 8b 94 24 b0
	00 00 00	 mov	 rdx, QWORD PTR dev$[rsp]
  000ce	48 81 c2 a4 00
	00 00		 add	 rdx, 164		; 000000a4H
  000d5	48 89 94 24 88
	00 00 00	 mov	 QWORD PTR tv88[rsp], rdx
  000dd	4c 8b 84 24 b0
	00 00 00	 mov	 r8, QWORD PTR dev$[rsp]
  000e5	45 0f b7 40 48	 movzx	 r8d, WORD PTR [r8+72]
  000ea	44 89 44 24 70	 mov	 DWORD PTR tv91[rsp], r8d
  000ef	4c 8b 8c 24 b0
	00 00 00	 mov	 r9, QWORD PTR dev$[rsp]
  000f7	45 0f b7 49 44	 movzx	 r9d, WORD PTR [r9+68]
  000fc	41 d1 f9	 sar	 r9d, 1
  000ff	44 89 4c 24 74	 mov	 DWORD PTR tv95[rsp], r9d
  00104	b9 01 00 00 00	 mov	 ecx, 1
  00109	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  0010f	8b 4c 24 68	 mov	 ecx, DWORD PTR tv83[rsp]
  00113	89 4c 24 58	 mov	 DWORD PTR [rsp+88], ecx
  00117	8b 4c 24 6c	 mov	 ecx, DWORD PTR tv86[rsp]
  0011b	89 4c 24 50	 mov	 DWORD PTR [rsp+80], ecx
  0011f	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR tv88[rsp]
  00127	48 89 4c 24 48	 mov	 QWORD PTR [rsp+72], rcx
  0012c	8b 4c 24 70	 mov	 ecx, DWORD PTR tv91[rsp]
  00130	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  00134	8b 4c 24 74	 mov	 ecx, DWORD PTR tv95[rsp]
  00138	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  0013c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG171166
  00143	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  00148	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG171167
  0014f	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00154	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00159	41 b9 03 00 00
	00		 mov	 r9d, 3
  0015f	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG171168
  00166	ba 48 06 00 00	 mov	 edx, 1608		; 00000648H
  0016b	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG171169
  00172	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg
$LN13@mt_advance:
  00178	33 c0		 xor	 eax, eax
  0017a	85 c0		 test	 eax, eax
  0017c	0f 85 02 ff ff
	ff		 jne	 $LN4@mt_advance
$LN12@mt_advance:

; 1609 : 
; 1610 :         if (dev->ckdtrkof)

  00182	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  0018a	8b 80 14 13 00
	00		 mov	 eax, DWORD PTR [rax+4884]
  00190	c1 e8 0f	 shr	 eax, 15
  00193	83 e0 01	 and	 eax, 1
  00196	85 c0		 test	 eax, eax
  00198	74 21		 je	 SHORT $LN14@mt_advance

; 1611 :             ckd_build_sense (dev, 0, SENSE1_FP | SENSE1_IE, 0, 0, 0);

  0019a	c6 44 24 28 00	 mov	 BYTE PTR [rsp+40], 0
  0019f	c6 44 24 20 00	 mov	 BYTE PTR [rsp+32], 0
  001a4	45 33 c9	 xor	 r9d, r9d
  001a7	41 b0 05	 mov	 r8b, 5
  001aa	33 d2		 xor	 edx, edx
  001ac	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  001b4	e8 00 00 00 00	 call	 ckd_build_sense
  001b9	eb 1f		 jmp	 SHORT $LN15@mt_advance
$LN14@mt_advance:

; 1612 :         else
; 1613 :            ckd_build_sense (dev, 0, SENSE1_FP, 0, 0, 0);

  001bb	c6 44 24 28 00	 mov	 BYTE PTR [rsp+40], 0
  001c0	c6 44 24 20 00	 mov	 BYTE PTR [rsp+32], 0
  001c5	45 33 c9	 xor	 r9d, r9d
  001c8	41 b0 04	 mov	 r8b, 4
  001cb	33 d2		 xor	 edx, edx
  001cd	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  001d5	e8 00 00 00 00	 call	 ckd_build_sense
$LN15@mt_advance:

; 1614 :         *unitstat = CSW_CE | CSW_DE | CSW_UC;

  001da	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR unitstat$[rsp]
  001e2	c6 00 0e	 mov	 BYTE PTR [rax], 14

; 1615 :         return -1;

  001e5	b8 ff ff ff ff	 mov	 eax, -1
  001ea	e9 4d 03 00 00	 jmp	 $LN1@mt_advance
$LN10@mt_advance:

; 1616 :     }
; 1617 : 
; 1618 :     /* End of cylinder error if not within domain of Locate Record
; 1619 :        and current track is last track of cylinder */
; 1620 :     if (dev->ckdlcount == 0
; 1621 :         && dev->ckdcurhead + trks >= dev->ckdheads)

  001ef	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  001f7	0f b6 80 02 13
	00 00		 movzx	 eax, BYTE PTR [rax+4866]
  001fe	85 c0		 test	 eax, eax
  00200	0f 85 92 00 00
	00		 jne	 $LN16@mt_advance
  00206	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  0020e	8b 80 cc 12 00
	00		 mov	 eax, DWORD PTR [rax+4812]
  00214	03 84 24 c0 00
	00 00		 add	 eax, DWORD PTR trks$[rsp]
  0021b	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  00223	3b 81 c0 12 00
	00		 cmp	 eax, DWORD PTR [rcx+4800]
  00229	7c 6d		 jl	 SHORT $LN16@mt_advance

; 1622 :     {
; 1623 :         if (dev->ckdtrkof)

  0022b	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00233	8b 80 14 13 00
	00		 mov	 eax, DWORD PTR [rax+4884]
  00239	c1 e8 0f	 shr	 eax, 15
  0023c	83 e0 01	 and	 eax, 1
  0023f	85 c0		 test	 eax, eax
  00241	74 21		 je	 SHORT $LN17@mt_advance

; 1624 :             ckd_build_sense (dev, 0, SENSE1_EOC | SENSE1_IE, 0, 0, 0);

  00243	c6 44 24 28 00	 mov	 BYTE PTR [rsp+40], 0
  00248	c6 44 24 20 00	 mov	 BYTE PTR [rsp+32], 0
  0024d	45 33 c9	 xor	 r9d, r9d
  00250	41 b0 21	 mov	 r8b, 33			; 00000021H
  00253	33 d2		 xor	 edx, edx
  00255	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  0025d	e8 00 00 00 00	 call	 ckd_build_sense
  00262	eb 1f		 jmp	 SHORT $LN18@mt_advance
$LN17@mt_advance:

; 1625 :         else
; 1626 :             ckd_build_sense (dev, 0, SENSE1_EOC, 0, 0, 0);

  00264	c6 44 24 28 00	 mov	 BYTE PTR [rsp+40], 0
  00269	c6 44 24 20 00	 mov	 BYTE PTR [rsp+32], 0
  0026e	45 33 c9	 xor	 r9d, r9d
  00271	41 b0 20	 mov	 r8b, 32			; 00000020H
  00274	33 d2		 xor	 edx, edx
  00276	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  0027e	e8 00 00 00 00	 call	 ckd_build_sense
$LN18@mt_advance:

; 1627 :         *unitstat = CSW_CE | CSW_DE | CSW_UC;

  00283	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR unitstat$[rsp]
  0028b	c6 00 0e	 mov	 BYTE PTR [rax], 14

; 1628 :         return -1;

  0028e	b8 ff ff ff ff	 mov	 eax, -1
  00293	e9 a4 02 00 00	 jmp	 $LN1@mt_advance
$LN16@mt_advance:

; 1629 :     }
; 1630 : 
; 1631 :     /* Advance to next track */
; 1632 :     cyl = dev->ckdcurcyl;

  00298	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  002a0	8b 80 c8 12 00
	00		 mov	 eax, DWORD PTR [rax+4808]
  002a6	89 44 24 60	 mov	 DWORD PTR cyl$[rsp], eax

; 1633 :     head = dev->ckdcurhead + trks;

  002aa	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  002b2	8b 80 cc 12 00
	00		 mov	 eax, DWORD PTR [rax+4812]
  002b8	03 84 24 c0 00
	00 00		 add	 eax, DWORD PTR trks$[rsp]
  002bf	89 44 24 64	 mov	 DWORD PTR head$[rsp], eax
$LN5@mt_advance:

; 1634 :     while (head >= dev->ckdheads)

  002c3	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  002cb	8b 80 c0 12 00
	00		 mov	 eax, DWORD PTR [rax+4800]
  002d1	39 44 24 64	 cmp	 DWORD PTR head$[rsp], eax
  002d5	7c 26		 jl	 SHORT $LN6@mt_advance

; 1635 :     {
; 1636 :         head -= dev->ckdheads;

  002d7	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  002df	8b 80 c0 12 00
	00		 mov	 eax, DWORD PTR [rax+4800]
  002e5	8b 4c 24 64	 mov	 ecx, DWORD PTR head$[rsp]
  002e9	2b c8		 sub	 ecx, eax
  002eb	8b c1		 mov	 eax, ecx
  002ed	89 44 24 64	 mov	 DWORD PTR head$[rsp], eax

; 1637 :         cyl++;

  002f1	8b 44 24 60	 mov	 eax, DWORD PTR cyl$[rsp]
  002f5	ff c0		 inc	 eax
  002f7	89 44 24 60	 mov	 DWORD PTR cyl$[rsp], eax

; 1638 :     }

  002fb	eb c6		 jmp	 SHORT $LN5@mt_advance
$LN6@mt_advance:

; 1639 : 
; 1640 :     // "%1d:%04X CKD file %s: MT advance to cyl(%d) head(%d)"
; 1641 :     if (dev->ccwtrace && sysblk.traceFILE)

  002fd	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00305	8b 80 f8 05 00
	00		 mov	 eax, DWORD PTR [rax+1528]
  0030b	c1 e8 0f	 shr	 eax, 15
  0030e	83 e0 01	 and	 eax, 1
  00311	85 c0		 test	 eax, eax
  00313	74 2d		 je	 SHORT $LN19@mt_advance
  00315	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  0031c	48 83 b8 20 14
	00 00 00	 cmp	 QWORD PTR [rax+5152], 0
  00324	74 1c		 je	 SHORT $LN19@mt_advance

; 1642 :         tf_0433( dev, cyl, head );

  00326	44 8b 44 24 64	 mov	 r8d, DWORD PTR head$[rsp]
  0032b	8b 54 24 60	 mov	 edx, DWORD PTR cyl$[rsp]
  0032f	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  00337	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_tf_0433
  0033d	e9 d2 00 00 00	 jmp	 $LN20@mt_advance
$LN19@mt_advance:
$LN9@mt_advance:

; 1643 :     else
; 1644 :         LOGDEVTR( HHC00433, "I", dev->filename, cyl, head );

  00342	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  0034a	8b 80 f8 05 00
	00		 mov	 eax, DWORD PTR [rax+1528]
  00350	c1 e8 0f	 shr	 eax, 15
  00353	83 e0 01	 and	 eax, 1
  00356	85 c0		 test	 eax, eax
  00358	0f 84 ac 00 00
	00		 je	 $LN21@mt_advance
  0035e	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00366	48 05 a4 00 00
	00		 add	 rax, 164		; 000000a4H
  0036c	48 89 84 24 90
	00 00 00	 mov	 QWORD PTR tv201[rsp], rax
  00374	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  0037c	0f b7 49 48	 movzx	 ecx, WORD PTR [rcx+72]
  00380	89 4c 24 78	 mov	 DWORD PTR tv204[rsp], ecx
  00384	48 8b 94 24 b0
	00 00 00	 mov	 rdx, QWORD PTR dev$[rsp]
  0038c	0f b7 52 44	 movzx	 edx, WORD PTR [rdx+68]
  00390	d1 fa		 sar	 edx, 1
  00392	89 54 24 7c	 mov	 DWORD PTR tv208[rsp], edx
  00396	b9 01 00 00 00	 mov	 ecx, 1
  0039b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  003a1	8b 4c 24 64	 mov	 ecx, DWORD PTR head$[rsp]
  003a5	89 4c 24 58	 mov	 DWORD PTR [rsp+88], ecx
  003a9	8b 4c 24 60	 mov	 ecx, DWORD PTR cyl$[rsp]
  003ad	89 4c 24 50	 mov	 DWORD PTR [rsp+80], ecx
  003b1	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR tv201[rsp]
  003b9	48 89 4c 24 48	 mov	 QWORD PTR [rsp+72], rcx
  003be	8b 4c 24 78	 mov	 ecx, DWORD PTR tv204[rsp]
  003c2	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  003c6	8b 4c 24 7c	 mov	 ecx, DWORD PTR tv208[rsp]
  003ca	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  003ce	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG171178
  003d5	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  003da	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG171179
  003e1	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  003e6	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  003eb	41 b9 03 00 00
	00		 mov	 r9d, 3
  003f1	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG171180
  003f8	ba 6c 06 00 00	 mov	 edx, 1644		; 0000066cH
  003fd	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG171181
  00404	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg
$LN21@mt_advance:
  0040a	33 c0		 xor	 eax, eax
  0040c	85 c0		 test	 eax, eax
  0040e	0f 85 2e ff ff
	ff		 jne	 $LN9@mt_advance
$LN20@mt_advance:

; 1645 : 
; 1646 :     /* File protect error if next track is outside the
; 1647 :        limits of the device or outside the defined extent */
; 1648 :     if ( EXTENT_CHECK(dev, cyl, head) )

  00414	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  0041c	0f b7 80 f2 12
	00 00		 movzx	 eax, WORD PTR [rax+4850]
  00423	39 44 24 60	 cmp	 DWORD PTR cyl$[rsp], eax
  00427	7c 69		 jl	 SHORT $LN23@mt_advance
  00429	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00431	0f b7 80 f6 12
	00 00		 movzx	 eax, WORD PTR [rax+4854]
  00438	39 44 24 60	 cmp	 DWORD PTR cyl$[rsp], eax
  0043c	7f 54		 jg	 SHORT $LN23@mt_advance
  0043e	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00446	0f b7 80 f2 12
	00 00		 movzx	 eax, WORD PTR [rax+4850]
  0044d	39 44 24 60	 cmp	 DWORD PTR cyl$[rsp], eax
  00451	75 15		 jne	 SHORT $LN24@mt_advance
  00453	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  0045b	0f b7 80 f4 12
	00 00		 movzx	 eax, WORD PTR [rax+4852]
  00462	39 44 24 64	 cmp	 DWORD PTR head$[rsp], eax
  00466	7c 2a		 jl	 SHORT $LN23@mt_advance
$LN24@mt_advance:
  00468	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00470	0f b7 80 f6 12
	00 00		 movzx	 eax, WORD PTR [rax+4854]
  00477	39 44 24 60	 cmp	 DWORD PTR cyl$[rsp], eax
  0047b	75 7f		 jne	 SHORT $LN22@mt_advance
  0047d	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00485	0f b7 80 f8 12
	00 00		 movzx	 eax, WORD PTR [rax+4856]
  0048c	39 44 24 64	 cmp	 DWORD PTR head$[rsp], eax
  00490	7e 6a		 jle	 SHORT $LN22@mt_advance
$LN23@mt_advance:

; 1649 :     {
; 1650 :         if (dev->ckdtrkof)

  00492	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  0049a	8b 80 14 13 00
	00		 mov	 eax, DWORD PTR [rax+4884]
  004a0	c1 e8 0f	 shr	 eax, 15
  004a3	83 e0 01	 and	 eax, 1
  004a6	85 c0		 test	 eax, eax
  004a8	74 21		 je	 SHORT $LN25@mt_advance

; 1651 :             ckd_build_sense (dev, 0, SENSE1_FP | SENSE1_IE, 0, 0, 0);

  004aa	c6 44 24 28 00	 mov	 BYTE PTR [rsp+40], 0
  004af	c6 44 24 20 00	 mov	 BYTE PTR [rsp+32], 0
  004b4	45 33 c9	 xor	 r9d, r9d
  004b7	41 b0 05	 mov	 r8b, 5
  004ba	33 d2		 xor	 edx, edx
  004bc	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  004c4	e8 00 00 00 00	 call	 ckd_build_sense
  004c9	eb 1f		 jmp	 SHORT $LN26@mt_advance
$LN25@mt_advance:

; 1652 :         else
; 1653 :             ckd_build_sense (dev, 0, SENSE1_FP, 0, 0, 0);

  004cb	c6 44 24 28 00	 mov	 BYTE PTR [rsp+40], 0
  004d0	c6 44 24 20 00	 mov	 BYTE PTR [rsp+32], 0
  004d5	45 33 c9	 xor	 r9d, r9d
  004d8	41 b0 04	 mov	 r8b, 4
  004db	33 d2		 xor	 edx, edx
  004dd	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  004e5	e8 00 00 00 00	 call	 ckd_build_sense
$LN26@mt_advance:

; 1654 :         *unitstat = CSW_CE | CSW_DE | CSW_UC;

  004ea	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR unitstat$[rsp]
  004f2	c6 00 0e	 mov	 BYTE PTR [rax], 14

; 1655 :         return -1;

  004f5	b8 ff ff ff ff	 mov	 eax, -1
  004fa	eb 40		 jmp	 SHORT $LN1@mt_advance
$LN22@mt_advance:

; 1656 :     }
; 1657 : 
; 1658 :     /* Seek to next track */
; 1659 :     rc = ckd_seek (dev, cyl, head, NULL, unitstat);

  004fc	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR unitstat$[rsp]
  00504	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00509	45 33 c9	 xor	 r9d, r9d
  0050c	44 8b 44 24 64	 mov	 r8d, DWORD PTR head$[rsp]
  00511	8b 54 24 60	 mov	 edx, DWORD PTR cyl$[rsp]
  00515	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  0051d	e8 00 00 00 00	 call	 ckd_seek
  00522	89 84 24 80 00
	00 00		 mov	 DWORD PTR rc$[rsp], eax

; 1660 :     if (rc < 0) return -1;

  00529	83 bc 24 80 00
	00 00 00	 cmp	 DWORD PTR rc$[rsp], 0
  00531	7d 07		 jge	 SHORT $LN27@mt_advance
  00533	b8 ff ff ff ff	 mov	 eax, -1
  00538	eb 02		 jmp	 SHORT $LN1@mt_advance
$LN27@mt_advance:

; 1661 : 
; 1662 :     /* Successful return */
; 1663 :     return 0;

  0053a	33 c0		 xor	 eax, eax
$LN1@mt_advance:

; 1664 : 
; 1665 : } /* end function mt_advance */

  0053c	48 81 c4 a8 00
	00 00		 add	 rsp, 168		; 000000a8H
  00543	c3		 ret	 0
mt_advance ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\ckddasd.c
_TEXT	SEGMENT
tv82 = 96
tv86 = 100
rc$ = 104
tv79 = 112
dev$ = 160
cyl$ = 168
head$ = 176
trkhdr$ = 184
unitstat$ = 192
ckd_seek PROC

; 1558 : {

  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  0000a	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  0000e	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00013	56		 push	 rsi
  00014	57		 push	 rdi
  00015	48 81 ec 88 00
	00 00		 sub	 rsp, 136		; 00000088H

; 1559 : int             rc;                     /* Return code               */
; 1560 : 
; 1561 :     // "%1d:%04X CKD file %s: seeking to cyl %d head %d"
; 1562 :     if (dev->ccwtrace && sysblk.traceFILE)

  0001c	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00024	8b 80 f8 05 00
	00		 mov	 eax, DWORD PTR [rax+1528]
  0002a	c1 e8 0f	 shr	 eax, 15
  0002d	83 e0 01	 and	 eax, 1
  00030	85 c0		 test	 eax, eax
  00032	74 33		 je	 SHORT $LN5@ckd_seek
  00034	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  0003b	48 83 b8 20 14
	00 00 00	 cmp	 QWORD PTR [rax+5152], 0
  00043	74 22		 je	 SHORT $LN5@ckd_seek

; 1563 :         tf_0431( dev, cyl, head );

  00045	44 8b 84 24 b0
	00 00 00	 mov	 r8d, DWORD PTR head$[rsp]
  0004d	8b 94 24 a8 00
	00 00		 mov	 edx, DWORD PTR cyl$[rsp]
  00054	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  0005c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_tf_0431
  00062	e9 d2 00 00 00	 jmp	 $LN6@ckd_seek
$LN5@ckd_seek:
$LN4@ckd_seek:

; 1564 :     else
; 1565 :         LOGDEVTR( HHC00431, "I", dev->filename, cyl, head );

  00067	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  0006f	8b 80 f8 05 00
	00		 mov	 eax, DWORD PTR [rax+1528]
  00075	c1 e8 0f	 shr	 eax, 15
  00078	83 e0 01	 and	 eax, 1
  0007b	85 c0		 test	 eax, eax
  0007d	0f 84 ac 00 00
	00		 je	 $LN7@ckd_seek
  00083	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  0008b	48 05 a4 00 00
	00		 add	 rax, 164		; 000000a4H
  00091	48 89 44 24 70	 mov	 QWORD PTR tv79[rsp], rax
  00096	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  0009e	0f b7 49 48	 movzx	 ecx, WORD PTR [rcx+72]
  000a2	89 4c 24 60	 mov	 DWORD PTR tv82[rsp], ecx
  000a6	48 8b 94 24 a0
	00 00 00	 mov	 rdx, QWORD PTR dev$[rsp]
  000ae	0f b7 52 44	 movzx	 edx, WORD PTR [rdx+68]
  000b2	d1 fa		 sar	 edx, 1
  000b4	89 54 24 64	 mov	 DWORD PTR tv86[rsp], edx
  000b8	b9 01 00 00 00	 mov	 ecx, 1
  000bd	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  000c3	8b 8c 24 b0 00
	00 00		 mov	 ecx, DWORD PTR head$[rsp]
  000ca	89 4c 24 58	 mov	 DWORD PTR [rsp+88], ecx
  000ce	8b 8c 24 a8 00
	00 00		 mov	 ecx, DWORD PTR cyl$[rsp]
  000d5	89 4c 24 50	 mov	 DWORD PTR [rsp+80], ecx
  000d9	48 8b 4c 24 70	 mov	 rcx, QWORD PTR tv79[rsp]
  000de	48 89 4c 24 48	 mov	 QWORD PTR [rsp+72], rcx
  000e3	8b 4c 24 60	 mov	 ecx, DWORD PTR tv82[rsp]
  000e7	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  000eb	8b 4c 24 64	 mov	 ecx, DWORD PTR tv86[rsp]
  000ef	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  000f3	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG171136
  000fa	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  000ff	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG171137
  00106	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  0010b	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00110	41 b9 03 00 00
	00		 mov	 r9d, 3
  00116	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG171138
  0011d	ba 1d 06 00 00	 mov	 edx, 1565		; 0000061dH
  00122	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG171139
  00129	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg
$LN7@ckd_seek:
  0012f	33 c0		 xor	 eax, eax
  00131	85 c0		 test	 eax, eax
  00133	0f 85 2e ff ff
	ff		 jne	 $LN4@ckd_seek
$LN6@ckd_seek:

; 1566 : 
; 1567 :     /* Read the track image */
; 1568 :     rc = ckd_read_cchh (dev, cyl, head, unitstat);

  00139	4c 8b 8c 24 c0
	00 00 00	 mov	 r9, QWORD PTR unitstat$[rsp]
  00141	44 8b 84 24 b0
	00 00 00	 mov	 r8d, DWORD PTR head$[rsp]
  00149	8b 94 24 a8 00
	00 00		 mov	 edx, DWORD PTR cyl$[rsp]
  00150	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  00158	e8 00 00 00 00	 call	 ckd_read_cchh
  0015d	89 44 24 68	 mov	 DWORD PTR rc$[rsp], eax

; 1569 :     if (rc < 0) return -1;

  00161	83 7c 24 68 00	 cmp	 DWORD PTR rc$[rsp], 0
  00166	7d 0a		 jge	 SHORT $LN8@ckd_seek
  00168	b8 ff ff ff ff	 mov	 eax, -1
  0016d	e9 e1 00 00 00	 jmp	 $LN1@ckd_seek
$LN8@ckd_seek:

; 1570 : 
; 1571 :     /* Set device orientation fields */
; 1572 :     dev->ckdcurcyl = cyl;

  00172	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  0017a	8b 8c 24 a8 00
	00 00		 mov	 ecx, DWORD PTR cyl$[rsp]
  00181	89 88 c8 12 00
	00		 mov	 DWORD PTR [rax+4808], ecx

; 1573 :     dev->ckdcurhead = head;

  00187	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  0018f	8b 8c 24 b0 00
	00 00		 mov	 ecx, DWORD PTR head$[rsp]
  00196	89 88 cc 12 00
	00		 mov	 DWORD PTR [rax+4812], ecx

; 1574 :     dev->ckdcurrec = 0;

  0019c	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  001a4	c7 80 d0 12 00
	00 00 00 00 00	 mov	 DWORD PTR [rax+4816], 0

; 1575 :     dev->ckdcurkl = 0;

  001ae	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  001b6	c7 80 d4 12 00
	00 00 00 00 00	 mov	 DWORD PTR [rax+4820], 0

; 1576 :     dev->ckdcurdl = 0;

  001c0	33 c0		 xor	 eax, eax
  001c2	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  001ca	66 89 81 ea 12
	00 00		 mov	 WORD PTR [rcx+4842], ax

; 1577 :     dev->ckdrem = 0;

  001d1	33 c0		 xor	 eax, eax
  001d3	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  001db	66 89 81 ec 12
	00 00		 mov	 WORD PTR [rcx+4844], ax

; 1578 :     dev->ckdorient = CKDORIENT_INDEX;

  001e2	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  001ea	c7 80 d8 12 00
	00 01 00 00 00	 mov	 DWORD PTR [rax+4824], 1

; 1579 : 
; 1580 :     /* Copy the track header */
; 1581 :     if (trkhdr) memcpy (trkhdr, &dev->buf[dev->bufoff], CKD_TRKHDR_SIZE);

  001f4	48 83 bc 24 b8
	00 00 00 00	 cmp	 QWORD PTR trkhdr$[rsp], 0
  001fd	74 31		 je	 SHORT $LN9@ckd_seek
  001ff	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00207	48 63 80 e0 01
	00 00		 movsxd	 rax, DWORD PTR [rax+480]
  0020e	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  00216	48 8b 89 c8 01
	00 00		 mov	 rcx, QWORD PTR [rcx+456]
  0021d	48 8b bc 24 b8
	00 00 00	 mov	 rdi, QWORD PTR trkhdr$[rsp]
  00225	48 8d 34 01	 lea	 rsi, QWORD PTR [rcx+rax]
  00229	b9 05 00 00 00	 mov	 ecx, 5
  0022e	f3 a4		 rep movsb
$LN9@ckd_seek:

; 1582 : 
; 1583 :     /* Increment offset past the track header */
; 1584 :     dev->bufoff += CKD_TRKHDR_SIZE;

  00230	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00238	48 63 80 e0 01
	00 00		 movsxd	 rax, DWORD PTR [rax+480]
  0023f	48 83 c0 05	 add	 rax, 5
  00243	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  0024b	89 81 e0 01 00
	00		 mov	 DWORD PTR [rcx+480], eax

; 1585 : 
; 1586 :     return 0;

  00251	33 c0		 xor	 eax, eax
$LN1@ckd_seek:

; 1587 : } /* end function ckd_seek */

  00253	48 81 c4 88 00
	00 00		 add	 rsp, 136		; 00000088H
  0025a	5f		 pop	 rdi
  0025b	5e		 pop	 rsi
  0025c	c3		 ret	 0
ckd_seek ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\ckddasd.c
_TEXT	SEGMENT
dev$ = 8
ckd_dasd_used PROC

; 1150 : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx

; 1151 :     return dev->ckdcyls;

  00005	48 8b 44 24 08	 mov	 rax, QWORD PTR dev$[rsp]
  0000a	8b 80 b8 12 00
	00		 mov	 eax, DWORD PTR [rax+4792]

; 1152 : }

  00010	c3		 ret	 0
ckd_dasd_used ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\ckddasd.c
_TEXT	SEGMENT
unitstat$ = 32
dev$ = 64
ckd_dasd_end PROC

; 1139 : {

$LN3:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 1140 : BYTE    unitstat;                       /* Unit Status               */
; 1141 : 
; 1142 :     /* Write the last track image if it's modified */
; 1143 :     (dev->hnd->read) (dev, -1, &unitstat);

  00009	48 8b 44 24 40	 mov	 rax, QWORD PTR dev$[rsp]
  0000e	48 8b 80 90 02
	00 00		 mov	 rax, QWORD PTR [rax+656]
  00015	4c 8d 44 24 20	 lea	 r8, QWORD PTR unitstat$[rsp]
  0001a	ba ff ff ff ff	 mov	 edx, -1
  0001f	48 8b 4c 24 40	 mov	 rcx, QWORD PTR dev$[rsp]
  00024	ff 50 50	 call	 QWORD PTR [rax+80]

; 1144 : }

  00027	48 83 c4 38	 add	 rsp, 56			; 00000038H
  0002b	c3		 ret	 0
ckd_dasd_end ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\ckddasd.c
_TEXT	SEGMENT
dev$ = 8
ckd_dasd_start PROC

; 1129 : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx

; 1130 :     /* Reset buffer offsets */
; 1131 :     dev->bufoff = 0;

  00005	48 8b 44 24 08	 mov	 rax, QWORD PTR dev$[rsp]
  0000a	c7 80 e0 01 00
	00 00 00 00 00	 mov	 DWORD PTR [rax+480], 0

; 1132 :     dev->bufoffhi = dev->ckdtrksz;

  00014	48 8b 44 24 08	 mov	 rax, QWORD PTR dev$[rsp]
  00019	48 8b 4c 24 08	 mov	 rcx, QWORD PTR dev$[rsp]
  0001e	8b 89 c4 12 00
	00		 mov	 ecx, DWORD PTR [rcx+4804]
  00024	89 88 e8 01 00
	00		 mov	 DWORD PTR [rax+488], ecx

; 1133 : }

  0002a	c3		 ret	 0
ckd_dasd_start ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\ckddasd.c
_TEXT	SEGMENT
rc$ = 48
dev$ = 96
trk$ = 104
off$ = 112
buf$ = 120
len$ = 128
unitstat$ = 136
ckd_dasd_update_track PROC

; 1071 : {

  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  0000a	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  0000e	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00013	56		 push	 rsi
  00014	57		 push	 rdi
  00015	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 1072 : int             rc;                     /* Return code               */
; 1073 : 
; 1074 :     /* Immediately return if fake writing */
; 1075 :     if (dev->ckdfakewr)

  00019	48 8b 44 24 60	 mov	 rax, QWORD PTR dev$[rsp]
  0001e	8b 80 14 13 00
	00		 mov	 eax, DWORD PTR [rax+4884]
  00024	c1 e8 14	 shr	 eax, 20
  00027	83 e0 01	 and	 eax, 1
  0002a	85 c0		 test	 eax, eax
  0002c	74 0c		 je	 SHORT $LN2@ckd_dasd_u

; 1076 :         return len;

  0002e	8b 84 24 80 00
	00 00		 mov	 eax, DWORD PTR len$[rsp]
  00035	e9 bb 01 00 00	 jmp	 $LN1@ckd_dasd_u
$LN2@ckd_dasd_u:

; 1077 : 
; 1078 :     /* Error if opened read-only */
; 1079 :     if (dev->ckdrdonly)

  0003a	48 8b 44 24 60	 mov	 rax, QWORD PTR dev$[rsp]
  0003f	8b 80 14 13 00
	00		 mov	 eax, DWORD PTR [rax+4884]
  00045	c1 e8 12	 shr	 eax, 18
  00048	83 e0 01	 and	 eax, 1
  0004b	85 c0		 test	 eax, eax
  0004d	74 31		 je	 SHORT $LN3@ckd_dasd_u

; 1080 :     {
; 1081 :         ckd_build_sense (dev, SENSE_EC, SENSE1_WRI, 0,

  0004f	c6 44 24 28 00	 mov	 BYTE PTR [rsp+40], 0
  00054	c6 44 24 20 01	 mov	 BYTE PTR [rsp+32], 1
  00059	45 33 c9	 xor	 r9d, r9d
  0005c	41 b0 02	 mov	 r8b, 2
  0005f	b2 10		 mov	 dl, 16
  00061	48 8b 4c 24 60	 mov	 rcx, QWORD PTR dev$[rsp]
  00066	e8 00 00 00 00	 call	 ckd_build_sense

; 1082 :                         FORMAT_1, MESSAGE_0);
; 1083 :         *unitstat = CSW_CE | CSW_DE | CSW_UC;

  0006b	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR unitstat$[rsp]
  00073	c6 00 0e	 mov	 BYTE PTR [rax], 14

; 1084 :         return -1;

  00076	b8 ff ff ff ff	 mov	 eax, -1
  0007b	e9 75 01 00 00	 jmp	 $LN1@ckd_dasd_u
$LN3@ckd_dasd_u:

; 1085 :     }
; 1086 : 
; 1087 :     /* Read the track if it's not current */
; 1088 :     if (trk != dev->bufcur)

  00080	48 8b 44 24 60	 mov	 rax, QWORD PTR dev$[rsp]
  00085	8b 80 c0 01 00
	00		 mov	 eax, DWORD PTR [rax+448]
  0008b	39 44 24 68	 cmp	 DWORD PTR trk$[rsp], eax
  0008f	74 53		 je	 SHORT $LN4@ckd_dasd_u

; 1089 :     {
; 1090 :         rc = (dev->hnd->read) (dev, trk, unitstat);

  00091	48 8b 44 24 60	 mov	 rax, QWORD PTR dev$[rsp]
  00096	48 8b 80 90 02
	00 00		 mov	 rax, QWORD PTR [rax+656]
  0009d	4c 8b 84 24 88
	00 00 00	 mov	 r8, QWORD PTR unitstat$[rsp]
  000a5	8b 54 24 68	 mov	 edx, DWORD PTR trk$[rsp]
  000a9	48 8b 4c 24 60	 mov	 rcx, QWORD PTR dev$[rsp]
  000ae	ff 50 50	 call	 QWORD PTR [rax+80]
  000b1	89 44 24 30	 mov	 DWORD PTR rc$[rsp], eax

; 1091 :         if (rc < 0)

  000b5	83 7c 24 30 00	 cmp	 DWORD PTR rc$[rsp], 0
  000ba	7d 28		 jge	 SHORT $LN5@ckd_dasd_u

; 1092 :         {
; 1093 :             dev->bufcur = dev->cache = -1;

  000bc	48 8b 44 24 60	 mov	 rax, QWORD PTR dev$[rsp]
  000c1	c7 80 f8 01 00
	00 ff ff ff ff	 mov	 DWORD PTR [rax+504], -1
  000cb	48 8b 44 24 60	 mov	 rax, QWORD PTR dev$[rsp]
  000d0	c7 80 c0 01 00
	00 ff ff ff ff	 mov	 DWORD PTR [rax+448], -1

; 1094 :             return -1;

  000da	b8 ff ff ff ff	 mov	 eax, -1
  000df	e9 11 01 00 00	 jmp	 $LN1@ckd_dasd_u
$LN5@ckd_dasd_u:
$LN4@ckd_dasd_u:

; 1095 :         }
; 1096 :     }
; 1097 : 
; 1098 :     /* Invalid track format if going past buffer end */
; 1099 :     if (off + len > dev->bufoffhi)

  000e4	8b 84 24 80 00
	00 00		 mov	 eax, DWORD PTR len$[rsp]
  000eb	8b 4c 24 70	 mov	 ecx, DWORD PTR off$[rsp]
  000ef	03 c8		 add	 ecx, eax
  000f1	8b c1		 mov	 eax, ecx
  000f3	48 8b 4c 24 60	 mov	 rcx, QWORD PTR dev$[rsp]
  000f8	3b 81 e8 01 00
	00		 cmp	 eax, DWORD PTR [rcx+488]
  000fe	7e 31		 jle	 SHORT $LN6@ckd_dasd_u

; 1100 :     {
; 1101 :         ckd_build_sense (dev, 0, SENSE1_ITF, 0, 0, 0);

  00100	c6 44 24 28 00	 mov	 BYTE PTR [rsp+40], 0
  00105	c6 44 24 20 00	 mov	 BYTE PTR [rsp+32], 0
  0010a	45 33 c9	 xor	 r9d, r9d
  0010d	41 b0 40	 mov	 r8b, 64			; 00000040H
  00110	33 d2		 xor	 edx, edx
  00112	48 8b 4c 24 60	 mov	 rcx, QWORD PTR dev$[rsp]
  00117	e8 00 00 00 00	 call	 ckd_build_sense

; 1102 :         *unitstat = CSW_CE | CSW_DE | CSW_UC;

  0011c	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR unitstat$[rsp]
  00124	c6 00 0e	 mov	 BYTE PTR [rax], 14

; 1103 :         return -1;

  00127	b8 ff ff ff ff	 mov	 eax, -1
  0012c	e9 c4 00 00 00	 jmp	 $LN1@ckd_dasd_u
$LN6@ckd_dasd_u:

; 1104 :     }
; 1105 : 
; 1106 :     /* Copy the data into the buffer */
; 1107 :     if (buf) memcpy (dev->buf + off, buf, len);

  00131	48 83 7c 24 78
	00		 cmp	 QWORD PTR buf$[rsp], 0
  00137	74 26		 je	 SHORT $LN7@ckd_dasd_u
  00139	48 63 84 24 80
	00 00 00	 movsxd	 rax, DWORD PTR len$[rsp]
  00141	48 63 4c 24 70	 movsxd	 rcx, DWORD PTR off$[rsp]
  00146	48 8b 54 24 60	 mov	 rdx, QWORD PTR dev$[rsp]
  0014b	48 03 8a c8 01
	00 00		 add	 rcx, QWORD PTR [rdx+456]
  00152	48 8b f9	 mov	 rdi, rcx
  00155	48 8b 74 24 78	 mov	 rsi, QWORD PTR buf$[rsp]
  0015a	48 8b c8	 mov	 rcx, rax
  0015d	f3 a4		 rep movsb
$LN7@ckd_dasd_u:

; 1108 : 
; 1109 :     /* Set low and high updated offsets */
; 1110 :     if (!dev->bufupd || off < dev->bufupdlo)

  0015f	48 8b 44 24 60	 mov	 rax, QWORD PTR dev$[rsp]
  00164	83 b8 f4 01 00
	00 00		 cmp	 DWORD PTR [rax+500], 0
  0016b	74 11		 je	 SHORT $LN9@ckd_dasd_u
  0016d	48 8b 44 24 60	 mov	 rax, QWORD PTR dev$[rsp]
  00172	8b 80 ec 01 00
	00		 mov	 eax, DWORD PTR [rax+492]
  00178	39 44 24 70	 cmp	 DWORD PTR off$[rsp], eax
  0017c	7d 0f		 jge	 SHORT $LN8@ckd_dasd_u
$LN9@ckd_dasd_u:

; 1111 :         dev->bufupdlo = off;

  0017e	48 8b 44 24 60	 mov	 rax, QWORD PTR dev$[rsp]
  00183	8b 4c 24 70	 mov	 ecx, DWORD PTR off$[rsp]
  00187	89 88 ec 01 00
	00		 mov	 DWORD PTR [rax+492], ecx
$LN8@ckd_dasd_u:

; 1112 :     if (off + len > dev->bufupdhi)

  0018d	8b 84 24 80 00
	00 00		 mov	 eax, DWORD PTR len$[rsp]
  00194	8b 4c 24 70	 mov	 ecx, DWORD PTR off$[rsp]
  00198	03 c8		 add	 ecx, eax
  0019a	8b c1		 mov	 eax, ecx
  0019c	48 8b 4c 24 60	 mov	 rcx, QWORD PTR dev$[rsp]
  001a1	3b 81 f0 01 00
	00		 cmp	 eax, DWORD PTR [rcx+496]
  001a7	7e 1a		 jle	 SHORT $LN10@ckd_dasd_u

; 1113 :         dev->bufupdhi = off + len;

  001a9	8b 84 24 80 00
	00 00		 mov	 eax, DWORD PTR len$[rsp]
  001b0	8b 4c 24 70	 mov	 ecx, DWORD PTR off$[rsp]
  001b4	03 c8		 add	 ecx, eax
  001b6	8b c1		 mov	 eax, ecx
  001b8	48 8b 4c 24 60	 mov	 rcx, QWORD PTR dev$[rsp]
  001bd	89 81 f0 01 00
	00		 mov	 DWORD PTR [rcx+496], eax
$LN10@ckd_dasd_u:

; 1114 : 
; 1115 :     /* Indicate track image has been modified */
; 1116 :     if (!dev->bufupd)

  001c3	48 8b 44 24 60	 mov	 rax, QWORD PTR dev$[rsp]
  001c8	83 b8 f4 01 00
	00 00		 cmp	 DWORD PTR [rax+500], 0
  001cf	75 1d		 jne	 SHORT $LN11@ckd_dasd_u

; 1117 :     {
; 1118 :         dev->bufupd = 1;

  001d1	48 8b 44 24 60	 mov	 rax, QWORD PTR dev$[rsp]
  001d6	c7 80 f4 01 00
	00 01 00 00 00	 mov	 DWORD PTR [rax+500], 1

; 1119 :         shared_update_notify (dev, trk);

  001e0	8b 54 24 68	 mov	 edx, DWORD PTR trk$[rsp]
  001e4	48 8b 4c 24 60	 mov	 rcx, QWORD PTR dev$[rsp]
  001e9	e8 00 00 00 00	 call	 shared_update_notify
$LN11@ckd_dasd_u:

; 1120 :     }
; 1121 : 
; 1122 :     return len;

  001ee	8b 84 24 80 00
	00 00		 mov	 eax, DWORD PTR len$[rsp]
$LN1@ckd_dasd_u:

; 1123 : } /* end function ckd_update_track */

  001f5	48 83 c4 48	 add	 rsp, 72			; 00000048H
  001f9	5f		 pop	 rdi
  001fa	5e		 pop	 rsi
  001fb	c3		 ret	 0
ckd_dasd_update_track ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\ckddasd.c
_TEXT	SEGMENT
sz$ = 32
dev$ = 64
buf$ = 72
ckd_trklen PROC

; 781  : {

$LN4:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 782  :     int sz = ckd_tracklen( dev, buf );

  0000e	48 8b 54 24 48	 mov	 rdx, QWORD PTR buf$[rsp]
  00013	48 8b 4c 24 40	 mov	 rcx, QWORD PTR dev$[rsp]
  00018	e8 00 00 00 00	 call	 ckd_tracklen
  0001d	89 44 24 20	 mov	 DWORD PTR sz$[rsp], eax

; 783  : 
; 784  :     if (sz > dev->ckdtrksz)

  00021	48 8b 44 24 40	 mov	 rax, QWORD PTR dev$[rsp]
  00026	8b 80 c4 12 00
	00		 mov	 eax, DWORD PTR [rax+4804]
  0002c	39 44 24 20	 cmp	 DWORD PTR sz$[rsp], eax
  00030	7e 0f		 jle	 SHORT $LN2@ckd_trklen

; 785  :         sz = dev->ckdtrksz;

  00032	48 8b 44 24 40	 mov	 rax, QWORD PTR dev$[rsp]
  00037	8b 80 c4 12 00
	00		 mov	 eax, DWORD PTR [rax+4804]
  0003d	89 44 24 20	 mov	 DWORD PTR sz$[rsp], eax
$LN2@ckd_trklen:

; 786  : 
; 787  :     return sz;

  00041	8b 44 24 20	 mov	 eax, DWORD PTR sz$[rsp]

; 788  : }

  00045	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00049	c3		 ret	 0
ckd_trklen ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\ckddasd.c
_TEXT	SEGMENT
trk$ = 48
rc$ = 52
dev$ = 80
cyl$ = 88
head$ = 96
unitstat$ = 104
ckd_read_cchh PROC

; 755  : {

  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  0000a	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  0000e	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00013	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 756  : int             rc;                     /* Return code               */
; 757  : int             trk;                    /* Track number              */
; 758  : 
; 759  :     /* Command reject if seek position is outside volume */
; 760  :     if (cyl >= dev->ckdcyls || head >= dev->ckdheads)

  00017	48 8b 44 24 50	 mov	 rax, QWORD PTR dev$[rsp]
  0001c	8b 80 b8 12 00
	00		 mov	 eax, DWORD PTR [rax+4792]
  00022	39 44 24 58	 cmp	 DWORD PTR cyl$[rsp], eax
  00026	7d 11		 jge	 SHORT $LN3@ckd_read_c
  00028	48 8b 44 24 50	 mov	 rax, QWORD PTR dev$[rsp]
  0002d	8b 80 c0 12 00
	00		 mov	 eax, DWORD PTR [rax+4800]
  00033	39 44 24 60	 cmp	 DWORD PTR head$[rsp], eax
  00037	7c 2b		 jl	 SHORT $LN2@ckd_read_c
$LN3@ckd_read_c:

; 761  :     {
; 762  :         ckd_build_sense (dev, SENSE_CR, 0, 0,

  00039	c6 44 24 28 04	 mov	 BYTE PTR [rsp+40], 4
  0003e	c6 44 24 20 00	 mov	 BYTE PTR [rsp+32], 0
  00043	45 33 c9	 xor	 r9d, r9d
  00046	45 33 c0	 xor	 r8d, r8d
  00049	b2 80		 mov	 dl, 128			; 00000080H
  0004b	48 8b 4c 24 50	 mov	 rcx, QWORD PTR dev$[rsp]
  00050	e8 00 00 00 00	 call	 ckd_build_sense

; 763  :                         FORMAT_0, MESSAGE_4);
; 764  :         *unitstat = CSW_CE | CSW_DE | CSW_UC;

  00055	48 8b 44 24 68	 mov	 rax, QWORD PTR unitstat$[rsp]
  0005a	c6 00 0e	 mov	 BYTE PTR [rax], 14

; 765  :         return -1;

  0005d	b8 ff ff ff ff	 mov	 eax, -1
  00062	eb 3f		 jmp	 SHORT $LN1@ckd_read_c
$LN2@ckd_read_c:

; 766  :     }
; 767  : 
; 768  :     /* Calculate the track number */
; 769  :     trk = cyl * dev->ckdheads + head;

  00064	48 8b 44 24 50	 mov	 rax, QWORD PTR dev$[rsp]
  00069	8b 4c 24 58	 mov	 ecx, DWORD PTR cyl$[rsp]
  0006d	0f af 88 c0 12
	00 00		 imul	 ecx, DWORD PTR [rax+4800]
  00074	8b c1		 mov	 eax, ecx
  00076	03 44 24 60	 add	 eax, DWORD PTR head$[rsp]
  0007a	89 44 24 30	 mov	 DWORD PTR trk$[rsp], eax

; 770  : 
; 771  :     /* Call the read exit */
; 772  :     rc = (dev->hnd->read) (dev, trk, unitstat);

  0007e	48 8b 44 24 50	 mov	 rax, QWORD PTR dev$[rsp]
  00083	48 8b 80 90 02
	00 00		 mov	 rax, QWORD PTR [rax+656]
  0008a	4c 8b 44 24 68	 mov	 r8, QWORD PTR unitstat$[rsp]
  0008f	8b 54 24 30	 mov	 edx, DWORD PTR trk$[rsp]
  00093	48 8b 4c 24 50	 mov	 rcx, QWORD PTR dev$[rsp]
  00098	ff 50 50	 call	 QWORD PTR [rax+80]
  0009b	89 44 24 34	 mov	 DWORD PTR rc$[rsp], eax

; 773  : 
; 774  :     return rc;

  0009f	8b 44 24 34	 mov	 eax, DWORD PTR rc$[rsp]
$LN1@ckd_read_c:

; 775  : } /* end function ckd_read_cchh */

  000a3	48 83 c4 48	 add	 rsp, 72			; 00000048H
  000a7	c3		 ret	 0
ckd_read_cchh ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\ckddasd.c
_TEXT	SEGMENT
f$ = 144
o$ = 148
i$ = 152
trkhdr$ = 160
rc$ = 168
head$ = 172
cyl$ = 176
offset$ = 184
tv197 = 192
tv203 = 196
tv258 = 200
tv264 = 204
tv402 = 208
tv526 = 212
tv622 = 216
tv628 = 220
tv677 = 224
tv683 = 228
tv831 = 232
tv837 = 236
tv160 = 240
tv164 = 244
tv341 = 248
tv345 = 252
tv426 = 256
tv430 = 260
tv465 = 264
tv469 = 268
tv551 = 272
tv557 = 276
tv561 = 280
tv740 = 284
tv745 = 288
tv750 = 292
tv760 = 296
tv766 = 300
tv770 = 304
tv804 = 308
tv809 = 312
tv814 = 316
tv822 = 320
tv82 = 324
tv86 = 328
tv669 = 336
tv79 = 344
tv157 = 352
tv187 = 360
tv192 = 368
tv248 = 376
tv253 = 384
tv338 = 392
tv423 = 400
tv462 = 408
tv554 = 416
tv612 = 424
tv617 = 432
tv672 = 440
tv763 = 448
tv826 = 456
dev$ = 480
trk$ = 488
unitstat$ = 496
ckd_dasd_read_track PROC

; 795  : {

  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00009	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000e	57		 push	 rdi
  0000f	48 81 ec d0 01
	00 00		 sub	 rsp, 464		; 000001d0H

; 796  : int             rc;                     /* Return code               */
; 797  : int             cyl = 0;                /* Cylinder                  */

  00016	c7 84 24 b0 00
	00 00 00 00 00
	00		 mov	 DWORD PTR cyl$[rsp], 0

; 798  : int             head = 0;               /* Head                      */

  00021	c7 84 24 ac 00
	00 00 00 00 00
	00		 mov	 DWORD PTR head$[rsp], 0

; 799  : U64             offset;                 /* File offsets              */
; 800  : int             i,o,f;                  /* Indexes                   */
; 801  : CKD_TRKHDR     *trkhdr;                 /* -> New track header       */
; 802  : 
; 803  :     // "%1d:%04X CKD file %s: read trk %d cur trk %d"
; 804  :     if (dev->ccwtrace && sysblk.traceFILE)

  0002c	48 8b 84 24 e0
	01 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00034	8b 80 f8 05 00
	00		 mov	 eax, DWORD PTR [rax+1528]
  0003a	c1 e8 0f	 shr	 eax, 15
  0003d	83 e0 01	 and	 eax, 1
  00040	85 c0		 test	 eax, eax
  00042	74 2b		 je	 SHORT $LN29@ckd_dasd_r
  00044	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  0004b	48 83 b8 20 14
	00 00 00	 cmp	 QWORD PTR [rax+5152], 0
  00053	74 1a		 je	 SHORT $LN29@ckd_dasd_r

; 805  :         tf_0424( dev, trk );

  00055	8b 94 24 e8 01
	00 00		 mov	 edx, DWORD PTR trk$[rsp]
  0005c	48 8b 8c 24 e0
	01 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  00064	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_tf_0424
  0006a	e9 eb 00 00 00	 jmp	 $LN30@ckd_dasd_r
$LN29@ckd_dasd_r:
$LN4@ckd_dasd_r:

; 806  :     else
; 807  :         LOGDEVTR( HHC00424, "I", dev->filename, trk, dev->bufcur );

  0006f	48 8b 84 24 e0
	01 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00077	8b 80 f8 05 00
	00		 mov	 eax, DWORD PTR [rax+1528]
  0007d	c1 e8 0f	 shr	 eax, 15
  00080	83 e0 01	 and	 eax, 1
  00083	85 c0		 test	 eax, eax
  00085	0f 84 c5 00 00
	00		 je	 $LN31@ckd_dasd_r
  0008b	48 8b 84 24 e0
	01 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00093	48 05 a4 00 00
	00		 add	 rax, 164		; 000000a4H
  00099	48 89 84 24 58
	01 00 00	 mov	 QWORD PTR tv79[rsp], rax
  000a1	48 8b 8c 24 e0
	01 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  000a9	0f b7 49 48	 movzx	 ecx, WORD PTR [rcx+72]
  000ad	89 8c 24 44 01
	00 00		 mov	 DWORD PTR tv82[rsp], ecx
  000b4	48 8b 94 24 e0
	01 00 00	 mov	 rdx, QWORD PTR dev$[rsp]
  000bc	0f b7 52 44	 movzx	 edx, WORD PTR [rdx+68]
  000c0	d1 fa		 sar	 edx, 1
  000c2	89 94 24 48 01
	00 00		 mov	 DWORD PTR tv86[rsp], edx
  000c9	b9 01 00 00 00	 mov	 ecx, 1
  000ce	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  000d4	48 8b 8c 24 e0
	01 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  000dc	8b 89 c0 01 00
	00		 mov	 ecx, DWORD PTR [rcx+448]
  000e2	89 4c 24 58	 mov	 DWORD PTR [rsp+88], ecx
  000e6	8b 8c 24 e8 01
	00 00		 mov	 ecx, DWORD PTR trk$[rsp]
  000ed	89 4c 24 50	 mov	 DWORD PTR [rsp+80], ecx
  000f1	48 8b 8c 24 58
	01 00 00	 mov	 rcx, QWORD PTR tv79[rsp]
  000f9	48 89 4c 24 48	 mov	 QWORD PTR [rsp+72], rcx
  000fe	8b 8c 24 44 01
	00 00		 mov	 ecx, DWORD PTR tv82[rsp]
  00105	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  00109	8b 8c 24 48 01
	00 00		 mov	 ecx, DWORD PTR tv86[rsp]
  00110	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  00114	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170239
  0011b	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  00120	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170240
  00127	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  0012c	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00131	41 b9 03 00 00
	00		 mov	 r9d, 3
  00137	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG170241
  0013e	ba 27 03 00 00	 mov	 edx, 807		; 00000327H
  00143	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170242
  0014a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg
$LN31@ckd_dasd_r:
  00150	33 c0		 xor	 eax, eax
  00152	85 c0		 test	 eax, eax
  00154	0f 85 15 ff ff
	ff		 jne	 $LN4@ckd_dasd_r
$LN30@ckd_dasd_r:

; 808  : 
; 809  :     /* Calculate cylinder and head */
; 810  :     if (dev->ckdheads) /* (might be 0 if init failed!) */

  0015a	48 8b 84 24 e0
	01 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00162	83 b8 c0 12 00
	00 00		 cmp	 DWORD PTR [rax+4800], 0
  00169	74 3c		 je	 SHORT $LN32@ckd_dasd_r

; 811  :     {
; 812  :         cyl  = trk / dev->ckdheads;

  0016b	8b 84 24 e8 01
	00 00		 mov	 eax, DWORD PTR trk$[rsp]
  00172	99		 cdq
  00173	48 8b 8c 24 e0
	01 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  0017b	f7 b9 c0 12 00
	00		 idiv	 DWORD PTR [rcx+4800]
  00181	89 84 24 b0 00
	00 00		 mov	 DWORD PTR cyl$[rsp], eax

; 813  :         head = trk % dev->ckdheads;

  00188	8b 84 24 e8 01
	00 00		 mov	 eax, DWORD PTR trk$[rsp]
  0018f	99		 cdq
  00190	48 8b 8c 24 e0
	01 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  00198	f7 b9 c0 12 00
	00		 idiv	 DWORD PTR [rcx+4800]
  0019e	8b c2		 mov	 eax, edx
  001a0	89 84 24 ac 00
	00 00		 mov	 DWORD PTR head$[rsp], eax
$LN32@ckd_dasd_r:

; 814  :     }
; 815  : 
; 816  :     /* Reset buffer offsets */
; 817  :     dev->bufoff = 0;

  001a7	48 8b 84 24 e0
	01 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  001af	c7 80 e0 01 00
	00 00 00 00 00	 mov	 DWORD PTR [rax+480], 0

; 818  :     dev->bufoffhi = dev->ckdtrksz;

  001b9	48 8b 84 24 e0
	01 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  001c1	48 8b 8c 24 e0
	01 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  001c9	8b 89 c4 12 00
	00		 mov	 ecx, DWORD PTR [rcx+4804]
  001cf	89 88 e8 01 00
	00		 mov	 DWORD PTR [rax+488], ecx

; 819  : 
; 820  :     /* Return if reading the same track image */
; 821  :     if (trk >= 0 && trk == dev->bufcur)

  001d5	83 bc 24 e8 01
	00 00 00	 cmp	 DWORD PTR trk$[rsp], 0
  001dd	7c 1e		 jl	 SHORT $LN33@ckd_dasd_r
  001df	48 8b 84 24 e0
	01 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  001e7	8b 80 c0 01 00
	00		 mov	 eax, DWORD PTR [rax+448]
  001ed	39 84 24 e8 01
	00 00		 cmp	 DWORD PTR trk$[rsp], eax
  001f4	75 07		 jne	 SHORT $LN33@ckd_dasd_r

; 822  :         return 0;

  001f6	33 c0		 xor	 eax, eax
  001f8	e9 ed 18 00 00	 jmp	 $LN1@ckd_dasd_r
$LN33@ckd_dasd_r:

; 823  : 
; 824  :     /* Write the previous track image if modified */
; 825  :     if (dev->bufupd)

  001fd	48 8b 84 24 e0
	01 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00205	83 b8 f4 01 00
	00 00		 cmp	 DWORD PTR [rax+500], 0
  0020c	0f 84 9c 05 00
	00		 je	 $LN34@ckd_dasd_r

; 826  :     {
; 827  :         // "%1d:%04X CKD file %s: read track updating track %d"
; 828  :         if (dev->ccwtrace && sysblk.traceFILE)

  00212	48 8b 84 24 e0
	01 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  0021a	8b 80 f8 05 00
	00		 mov	 eax, DWORD PTR [rax+1528]
  00220	c1 e8 0f	 shr	 eax, 15
  00223	83 e0 01	 and	 eax, 1
  00226	85 c0		 test	 eax, eax
  00228	74 24		 je	 SHORT $LN35@ckd_dasd_r
  0022a	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00231	48 83 b8 20 14
	00 00 00	 cmp	 QWORD PTR [rax+5152], 0
  00239	74 13		 je	 SHORT $LN35@ckd_dasd_r

; 829  :             tf_0425( dev );

  0023b	48 8b 8c 24 e0
	01 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  00243	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_tf_0425
  00249	e9 e0 00 00 00	 jmp	 $LN36@ckd_dasd_r
$LN35@ckd_dasd_r:
$LN7@ckd_dasd_r:

; 830  :         else
; 831  :             LOGDEVTR( HHC00425, "I", dev->filename, dev->bufcur );

  0024e	48 8b 84 24 e0
	01 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00256	8b 80 f8 05 00
	00		 mov	 eax, DWORD PTR [rax+1528]
  0025c	c1 e8 0f	 shr	 eax, 15
  0025f	83 e0 01	 and	 eax, 1
  00262	85 c0		 test	 eax, eax
  00264	0f 84 ba 00 00
	00		 je	 $LN37@ckd_dasd_r
  0026a	48 8b 84 24 e0
	01 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00272	48 05 a4 00 00
	00		 add	 rax, 164		; 000000a4H
  00278	48 89 84 24 60
	01 00 00	 mov	 QWORD PTR tv157[rsp], rax
  00280	48 8b 8c 24 e0
	01 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  00288	0f b7 49 48	 movzx	 ecx, WORD PTR [rcx+72]
  0028c	89 8c 24 f0 00
	00 00		 mov	 DWORD PTR tv160[rsp], ecx
  00293	48 8b 94 24 e0
	01 00 00	 mov	 rdx, QWORD PTR dev$[rsp]
  0029b	0f b7 52 44	 movzx	 edx, WORD PTR [rdx+68]
  0029f	d1 fa		 sar	 edx, 1
  002a1	89 94 24 f4 00
	00 00		 mov	 DWORD PTR tv164[rsp], edx
  002a8	b9 01 00 00 00	 mov	 ecx, 1
  002ad	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  002b3	48 8b 8c 24 e0
	01 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  002bb	8b 89 c0 01 00
	00		 mov	 ecx, DWORD PTR [rcx+448]
  002c1	89 4c 24 50	 mov	 DWORD PTR [rsp+80], ecx
  002c5	48 8b 8c 24 60
	01 00 00	 mov	 rcx, QWORD PTR tv157[rsp]
  002cd	48 89 4c 24 48	 mov	 QWORD PTR [rsp+72], rcx
  002d2	8b 8c 24 f0 00
	00 00		 mov	 ecx, DWORD PTR tv160[rsp]
  002d9	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  002dd	8b 8c 24 f4 00
	00 00		 mov	 ecx, DWORD PTR tv164[rsp]
  002e4	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  002e8	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170249
  002ef	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  002f4	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170250
  002fb	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00300	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00305	41 b9 03 00 00
	00		 mov	 r9d, 3
  0030b	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG170251
  00312	ba 3f 03 00 00	 mov	 edx, 831		; 0000033fH
  00317	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170252
  0031e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg
$LN37@ckd_dasd_r:
  00324	33 c0		 xor	 eax, eax
  00326	85 c0		 test	 eax, eax
  00328	0f 85 20 ff ff
	ff		 jne	 $LN7@ckd_dasd_r
$LN36@ckd_dasd_r:

; 832  : 
; 833  :         dev->bufupd = 0;

  0032e	48 8b 84 24 e0
	01 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00336	c7 80 f4 01 00
	00 00 00 00 00	 mov	 DWORD PTR [rax+500], 0

; 834  : 
; 835  :         /* Seek to the old track image offset */
; 836  :         offset = (dev->ckdtrkoff + dev->bufupdlo);

  00340	48 8b 84 24 e0
	01 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00348	48 63 80 ec 01
	00 00		 movsxd	 rax, DWORD PTR [rax+492]
  0034f	48 8b 8c 24 e0
	01 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  00357	48 03 81 b0 12
	00 00		 add	 rax, QWORD PTR [rcx+4784]
  0035e	48 89 84 24 b8
	00 00 00	 mov	 QWORD PTR offset$[rsp], rax

; 837  :         offset = lseek (dev->fd, offset, SEEK_SET);

  00366	45 33 c0	 xor	 r8d, r8d
  00369	48 8b 94 24 b8
	00 00 00	 mov	 rdx, QWORD PTR offset$[rsp]
  00371	48 8b 84 24 e0
	01 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00379	8b 88 ac 01 00
	00		 mov	 ecx, DWORD PTR [rax+428]
  0037f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__lseeki64
  00385	48 89 84 24 b8
	00 00 00	 mov	 QWORD PTR offset$[rsp], rax

; 838  :         if ((S64)offset < 0)

  0038d	48 83 bc 24 b8
	00 00 00 00	 cmp	 QWORD PTR offset$[rsp], 0
  00396	0f 8d b0 01 00
	00		 jge	 $LN38@ckd_dasd_r

; 839  :         {
; 840  :             /* Handle seek error condition */
; 841  :             // "%1d:%04X CKD file %s: error in function %s: %s"
; 842  :             WRMSG( HHC00404, "E", LCSS_DEVNUM,

  0039c	48 83 bc 24 e0
	01 00 00 00	 cmp	 QWORD PTR dev$[rsp], 0
  003a5	74 15		 je	 SHORT $LN68@ckd_dasd_r
  003a7	48 8b 84 24 e0
	01 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  003af	0f b7 40 48	 movzx	 eax, WORD PTR [rax+72]
  003b3	89 84 24 c0 00
	00 00		 mov	 DWORD PTR tv197[rsp], eax
  003ba	eb 0b		 jmp	 SHORT $LN69@ckd_dasd_r
$LN68@ckd_dasd_r:
  003bc	c7 84 24 c0 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv197[rsp], 0
$LN69@ckd_dasd_r:
  003c7	48 83 bc 24 e0
	01 00 00 00	 cmp	 QWORD PTR dev$[rsp], 0
  003d0	74 17		 je	 SHORT $LN70@ckd_dasd_r
  003d2	48 8b 84 24 e0
	01 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  003da	0f b7 40 44	 movzx	 eax, WORD PTR [rax+68]
  003de	d1 f8		 sar	 eax, 1
  003e0	89 84 24 c4 00
	00 00		 mov	 DWORD PTR tv203[rsp], eax
  003e7	eb 0b		 jmp	 SHORT $LN71@ckd_dasd_r
$LN70@ckd_dasd_r:
  003e9	c7 84 24 c4 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv203[rsp], 0
$LN71@ckd_dasd_r:
  003f4	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno
  003fa	8b 08		 mov	 ecx, DWORD PTR [rax]
  003fc	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_strerror
  00402	48 89 84 24 68
	01 00 00	 mov	 QWORD PTR tv187[rsp], rax
  0040a	48 8b 8c 24 e0
	01 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  00412	48 81 c1 a4 00
	00 00		 add	 rcx, 164		; 000000a4H
  00419	48 89 8c 24 70
	01 00 00	 mov	 QWORD PTR tv192[rsp], rcx
  00421	b9 01 00 00 00	 mov	 ecx, 1
  00426	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  0042c	48 8b 8c 24 68
	01 00 00	 mov	 rcx, QWORD PTR tv187[rsp]
  00434	48 89 4c 24 58	 mov	 QWORD PTR [rsp+88], rcx
  00439	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170254
  00440	48 89 4c 24 50	 mov	 QWORD PTR [rsp+80], rcx
  00445	48 8b 8c 24 70
	01 00 00	 mov	 rcx, QWORD PTR tv192[rsp]
  0044d	48 89 4c 24 48	 mov	 QWORD PTR [rsp+72], rcx
  00452	8b 8c 24 c0 00
	00 00		 mov	 ecx, DWORD PTR tv197[rsp]
  00459	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  0045d	8b 8c 24 c4 00
	00 00		 mov	 ecx, DWORD PTR tv203[rsp]
  00464	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  00468	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170255
  0046f	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  00474	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170256
  0047b	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00480	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00485	41 b9 03 00 00
	00		 mov	 r9d, 3
  0048b	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG170257
  00492	ba 4b 03 00 00	 mov	 edx, 843		; 0000034bH
  00497	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170258
  0049e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 843  :                    dev->filename, "lseek()", strerror( errno ));
; 844  :             ckd_build_sense (dev, SENSE_EC, 0, 0,

  004a4	c6 44 24 28 00	 mov	 BYTE PTR [rsp+40], 0
  004a9	c6 44 24 20 01	 mov	 BYTE PTR [rsp+32], 1
  004ae	45 33 c9	 xor	 r9d, r9d
  004b1	45 33 c0	 xor	 r8d, r8d
  004b4	b2 10		 mov	 dl, 16
  004b6	48 8b 8c 24 e0
	01 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  004be	e8 00 00 00 00	 call	 ckd_build_sense

; 845  :                             FORMAT_1, MESSAGE_0);
; 846  :             *unitstat = CSW_CE | CSW_DE | CSW_UC;

  004c3	48 8b 84 24 f0
	01 00 00	 mov	 rax, QWORD PTR unitstat$[rsp]
  004cb	c6 00 0e	 mov	 BYTE PTR [rax], 14

; 847  :             cache_lock(CACHE_DEVBUF);

  004ce	33 c9		 xor	 ecx, ecx
  004d0	e8 00 00 00 00	 call	 cache_lock

; 848  :             cache_setflag(CACHE_DEVBUF, dev->cache, ~CKD_CACHE_ACTIVE, 0);

  004d5	45 33 c9	 xor	 r9d, r9d
  004d8	41 b8 ff ff ff
	7f		 mov	 r8d, 2147483647		; 7fffffffH
  004de	48 8b 84 24 e0
	01 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  004e6	8b 90 f8 01 00
	00		 mov	 edx, DWORD PTR [rax+504]
  004ec	33 c9		 xor	 ecx, ecx
  004ee	e8 00 00 00 00	 call	 cache_setflag

; 849  :             cache_unlock(CACHE_DEVBUF);

  004f3	33 c9		 xor	 ecx, ecx
  004f5	e8 00 00 00 00	 call	 cache_unlock

; 850  :             dev->bufupdlo = dev->bufupdhi = 0;

  004fa	48 8b 84 24 e0
	01 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00502	c7 80 f0 01 00
	00 00 00 00 00	 mov	 DWORD PTR [rax+496], 0
  0050c	48 8b 84 24 e0
	01 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00514	c7 80 ec 01 00
	00 00 00 00 00	 mov	 DWORD PTR [rax+492], 0

; 851  :             dev->bufcur = dev->cache = -1;

  0051e	48 8b 84 24 e0
	01 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00526	c7 80 f8 01 00
	00 ff ff ff ff	 mov	 DWORD PTR [rax+504], -1
  00530	48 8b 84 24 e0
	01 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00538	c7 80 c0 01 00
	00 ff ff ff ff	 mov	 DWORD PTR [rax+448], -1

; 852  :             return -1;

  00542	b8 ff ff ff ff	 mov	 eax, -1
  00547	e9 9e 15 00 00	 jmp	 $LN1@ckd_dasd_r
$LN38@ckd_dasd_r:

; 853  :         }
; 854  : 
; 855  :         /* Write the portion of the track image that was modified */
; 856  :         rc = write (dev->fd, &dev->buf[dev->bufupdlo],

  0054c	48 8b 84 24 e0
	01 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00554	48 8b 8c 24 e0
	01 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  0055c	8b 89 ec 01 00
	00		 mov	 ecx, DWORD PTR [rcx+492]
  00562	8b 80 f0 01 00
	00		 mov	 eax, DWORD PTR [rax+496]
  00568	2b c1		 sub	 eax, ecx
  0056a	48 8b 8c 24 e0
	01 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  00572	48 63 89 ec 01
	00 00		 movsxd	 rcx, DWORD PTR [rcx+492]
  00579	48 8b 94 24 e0
	01 00 00	 mov	 rdx, QWORD PTR dev$[rsp]
  00581	48 8b 92 c8 01
	00 00		 mov	 rdx, QWORD PTR [rdx+456]
  00588	48 03 d1	 add	 rdx, rcx
  0058b	48 8b ca	 mov	 rcx, rdx
  0058e	44 8b c0	 mov	 r8d, eax
  00591	48 8b d1	 mov	 rdx, rcx
  00594	48 8b 84 24 e0
	01 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  0059c	8b 88 ac 01 00
	00		 mov	 ecx, DWORD PTR [rax+428]
  005a2	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_write
  005a8	89 84 24 a8 00
	00 00		 mov	 DWORD PTR rc$[rsp], eax

; 857  :                     dev->bufupdhi - dev->bufupdlo);
; 858  :         if (rc < dev->bufupdhi - dev->bufupdlo)

  005af	48 8b 84 24 e0
	01 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  005b7	48 8b 8c 24 e0
	01 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  005bf	8b 89 ec 01 00
	00		 mov	 ecx, DWORD PTR [rcx+492]
  005c5	8b 80 f0 01 00
	00		 mov	 eax, DWORD PTR [rax+496]
  005cb	2b c1		 sub	 eax, ecx
  005cd	39 84 24 a8 00
	00 00		 cmp	 DWORD PTR rc$[rsp], eax
  005d4	0f 8d b0 01 00
	00		 jge	 $LN39@ckd_dasd_r

; 859  :         {
; 860  :             /* Handle write error condition */
; 861  :             // "%1d:%04X CKD file %s: error in function %s: %s"
; 862  :             WRMSG( HHC00404, "E", LCSS_DEVNUM,

  005da	48 83 bc 24 e0
	01 00 00 00	 cmp	 QWORD PTR dev$[rsp], 0
  005e3	74 15		 je	 SHORT $LN72@ckd_dasd_r
  005e5	48 8b 84 24 e0
	01 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  005ed	0f b7 40 48	 movzx	 eax, WORD PTR [rax+72]
  005f1	89 84 24 c8 00
	00 00		 mov	 DWORD PTR tv258[rsp], eax
  005f8	eb 0b		 jmp	 SHORT $LN73@ckd_dasd_r
$LN72@ckd_dasd_r:
  005fa	c7 84 24 c8 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv258[rsp], 0
$LN73@ckd_dasd_r:
  00605	48 83 bc 24 e0
	01 00 00 00	 cmp	 QWORD PTR dev$[rsp], 0
  0060e	74 17		 je	 SHORT $LN74@ckd_dasd_r
  00610	48 8b 84 24 e0
	01 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00618	0f b7 40 44	 movzx	 eax, WORD PTR [rax+68]
  0061c	d1 f8		 sar	 eax, 1
  0061e	89 84 24 cc 00
	00 00		 mov	 DWORD PTR tv264[rsp], eax
  00625	eb 0b		 jmp	 SHORT $LN75@ckd_dasd_r
$LN74@ckd_dasd_r:
  00627	c7 84 24 cc 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv264[rsp], 0
$LN75@ckd_dasd_r:
  00632	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno
  00638	8b 08		 mov	 ecx, DWORD PTR [rax]
  0063a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_strerror
  00640	48 89 84 24 78
	01 00 00	 mov	 QWORD PTR tv248[rsp], rax
  00648	48 8b 8c 24 e0
	01 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  00650	48 81 c1 a4 00
	00 00		 add	 rcx, 164		; 000000a4H
  00657	48 89 8c 24 80
	01 00 00	 mov	 QWORD PTR tv253[rsp], rcx
  0065f	b9 01 00 00 00	 mov	 ecx, 1
  00664	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  0066a	48 8b 8c 24 78
	01 00 00	 mov	 rcx, QWORD PTR tv248[rsp]
  00672	48 89 4c 24 58	 mov	 QWORD PTR [rsp+88], rcx
  00677	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170260
  0067e	48 89 4c 24 50	 mov	 QWORD PTR [rsp+80], rcx
  00683	48 8b 8c 24 80
	01 00 00	 mov	 rcx, QWORD PTR tv253[rsp]
  0068b	48 89 4c 24 48	 mov	 QWORD PTR [rsp+72], rcx
  00690	8b 8c 24 c8 00
	00 00		 mov	 ecx, DWORD PTR tv258[rsp]
  00697	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  0069b	8b 8c 24 cc 00
	00 00		 mov	 ecx, DWORD PTR tv264[rsp]
  006a2	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  006a6	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170261
  006ad	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  006b2	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170262
  006b9	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  006be	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  006c3	41 b9 03 00 00
	00		 mov	 r9d, 3
  006c9	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG170263
  006d0	ba 5f 03 00 00	 mov	 edx, 863		; 0000035fH
  006d5	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170264
  006dc	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 863  :                    dev->filename, "write()", strerror( errno ));
; 864  :             ckd_build_sense (dev, SENSE_EC, 0, 0,

  006e2	c6 44 24 28 00	 mov	 BYTE PTR [rsp+40], 0
  006e7	c6 44 24 20 01	 mov	 BYTE PTR [rsp+32], 1
  006ec	45 33 c9	 xor	 r9d, r9d
  006ef	45 33 c0	 xor	 r8d, r8d
  006f2	b2 10		 mov	 dl, 16
  006f4	48 8b 8c 24 e0
	01 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  006fc	e8 00 00 00 00	 call	 ckd_build_sense

; 865  :                             FORMAT_1, MESSAGE_0);
; 866  :             *unitstat = CSW_CE | CSW_DE | CSW_UC;

  00701	48 8b 84 24 f0
	01 00 00	 mov	 rax, QWORD PTR unitstat$[rsp]
  00709	c6 00 0e	 mov	 BYTE PTR [rax], 14

; 867  :             cache_lock(CACHE_DEVBUF);

  0070c	33 c9		 xor	 ecx, ecx
  0070e	e8 00 00 00 00	 call	 cache_lock

; 868  :             cache_setflag(CACHE_DEVBUF, dev->cache, ~CKD_CACHE_ACTIVE, 0);

  00713	45 33 c9	 xor	 r9d, r9d
  00716	41 b8 ff ff ff
	7f		 mov	 r8d, 2147483647		; 7fffffffH
  0071c	48 8b 84 24 e0
	01 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00724	8b 90 f8 01 00
	00		 mov	 edx, DWORD PTR [rax+504]
  0072a	33 c9		 xor	 ecx, ecx
  0072c	e8 00 00 00 00	 call	 cache_setflag

; 869  :             cache_unlock(CACHE_DEVBUF);

  00731	33 c9		 xor	 ecx, ecx
  00733	e8 00 00 00 00	 call	 cache_unlock

; 870  :             dev->bufupdlo = dev->bufupdhi = 0;

  00738	48 8b 84 24 e0
	01 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00740	c7 80 f0 01 00
	00 00 00 00 00	 mov	 DWORD PTR [rax+496], 0
  0074a	48 8b 84 24 e0
	01 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00752	c7 80 ec 01 00
	00 00 00 00 00	 mov	 DWORD PTR [rax+492], 0

; 871  :             dev->bufcur = dev->cache = -1;

  0075c	48 8b 84 24 e0
	01 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00764	c7 80 f8 01 00
	00 ff ff ff ff	 mov	 DWORD PTR [rax+504], -1
  0076e	48 8b 84 24 e0
	01 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00776	c7 80 c0 01 00
	00 ff ff ff ff	 mov	 DWORD PTR [rax+448], -1

; 872  :             return -1;

  00780	b8 ff ff ff ff	 mov	 eax, -1
  00785	e9 60 13 00 00	 jmp	 $LN1@ckd_dasd_r
$LN39@ckd_dasd_r:

; 873  :         }
; 874  : 
; 875  :         dev->bufupdlo = dev->bufupdhi = 0;

  0078a	48 8b 84 24 e0
	01 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00792	c7 80 f0 01 00
	00 00 00 00 00	 mov	 DWORD PTR [rax+496], 0
  0079c	48 8b 84 24 e0
	01 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  007a4	c7 80 ec 01 00
	00 00 00 00 00	 mov	 DWORD PTR [rax+492], 0
$LN34@ckd_dasd_r:

; 876  :     }
; 877  : 
; 878  :     cache_lock (CACHE_DEVBUF);

  007ae	33 c9		 xor	 ecx, ecx
  007b0	e8 00 00 00 00	 call	 cache_lock

; 879  : 
; 880  :     /* Make the previous cache entry inactive */
; 881  :     if (dev->cache >= 0)

  007b5	48 8b 84 24 e0
	01 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  007bd	83 b8 f8 01 00
	00 00		 cmp	 DWORD PTR [rax+504], 0
  007c4	7c 1e		 jl	 SHORT $LN40@ckd_dasd_r

; 882  :         cache_setflag(CACHE_DEVBUF, dev->cache, ~CKD_CACHE_ACTIVE, 0);

  007c6	45 33 c9	 xor	 r9d, r9d
  007c9	41 b8 ff ff ff
	7f		 mov	 r8d, 2147483647		; 7fffffffH
  007cf	48 8b 84 24 e0
	01 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  007d7	8b 90 f8 01 00
	00		 mov	 edx, DWORD PTR [rax+504]
  007dd	33 c9		 xor	 ecx, ecx
  007df	e8 00 00 00 00	 call	 cache_setflag
$LN40@ckd_dasd_r:

; 883  :     dev->bufcur = dev->cache = -1;

  007e4	48 8b 84 24 e0
	01 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  007ec	c7 80 f8 01 00
	00 ff ff ff ff	 mov	 DWORD PTR [rax+504], -1
  007f6	48 8b 84 24 e0
	01 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  007fe	c7 80 c0 01 00
	00 ff ff ff ff	 mov	 DWORD PTR [rax+448], -1

; 884  : 
; 885  :     /* Return on special case when called by the close handler */
; 886  :     if (trk < 0)

  00808	83 bc 24 e8 01
	00 00 00	 cmp	 DWORD PTR trk$[rsp], 0
  00810	7d 0e		 jge	 SHORT $LN41@ckd_dasd_r

; 887  :     {
; 888  :         cache_unlock (CACHE_DEVBUF);

  00812	33 c9		 xor	 ecx, ecx
  00814	e8 00 00 00 00	 call	 cache_unlock

; 889  :         return 0;

  00819	33 c0		 xor	 eax, eax
  0081b	e9 ca 12 00 00	 jmp	 $LN1@ckd_dasd_r
$LN41@ckd_dasd_r:
$ckd_read_track_retry$94:

; 890  :     }
; 891  : 
; 892  : ckd_read_track_retry:
; 893  : 
; 894  :     /* Search the cache */
; 895  :     i = cache_lookup (CACHE_DEVBUF, CKD_CACHE_SETKEY(dev->devnum, trk), &o);

  00820	48 8b 84 24 e0
	01 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00828	0f b7 40 48	 movzx	 eax, WORD PTR [rax+72]
  0082c	48 c1 e0 20	 shl	 rax, 32			; 00000020H
  00830	48 63 8c 24 e8
	01 00 00	 movsxd	 rcx, DWORD PTR trk$[rsp]
  00838	48 0b c1	 or	 rax, rcx
  0083b	4c 8d 84 24 94
	00 00 00	 lea	 r8, QWORD PTR o$[rsp]
  00843	48 8b d0	 mov	 rdx, rax
  00846	33 c9		 xor	 ecx, ecx
  00848	e8 00 00 00 00	 call	 cache_lookup
  0084d	89 84 24 98 00
	00 00		 mov	 DWORD PTR i$[rsp], eax

; 896  : 
; 897  :     /* Cache hit */
; 898  :     if (i >= 0)

  00854	83 bc 24 98 00
	00 00 00	 cmp	 DWORD PTR i$[rsp], 0
  0085c	0f 8c 40 03 00
	00		 jl	 $LN42@ckd_dasd_r

; 899  :     {
; 900  :         cache_setflag(CACHE_DEVBUF, i, ~0, CKD_CACHE_ACTIVE);

  00862	41 b9 00 00 00
	80		 mov	 r9d, -2147483648	; 80000000H
  00868	41 b8 ff ff ff
	ff		 mov	 r8d, -1			; ffffffffH
  0086e	8b 94 24 98 00
	00 00		 mov	 edx, DWORD PTR i$[rsp]
  00875	33 c9		 xor	 ecx, ecx
  00877	e8 00 00 00 00	 call	 cache_setflag

; 901  :         cache_setage(CACHE_DEVBUF, i);

  0087c	8b 94 24 98 00
	00 00		 mov	 edx, DWORD PTR i$[rsp]
  00883	33 c9		 xor	 ecx, ecx
  00885	e8 00 00 00 00	 call	 cache_setage

; 902  :         cache_unlock(CACHE_DEVBUF);

  0088a	33 c9		 xor	 ecx, ecx
  0088c	e8 00 00 00 00	 call	 cache_unlock

; 903  : 
; 904  :         // "%1d:%04X CKD file %s: read trk %d cache hit, using cache[%d]"
; 905  :         if (dev->ccwtrace && sysblk.traceFILE)

  00891	48 8b 84 24 e0
	01 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00899	8b 80 f8 05 00
	00		 mov	 eax, DWORD PTR [rax+1528]
  0089f	c1 e8 0f	 shr	 eax, 15
  008a2	83 e0 01	 and	 eax, 1
  008a5	85 c0		 test	 eax, eax
  008a7	74 33		 je	 SHORT $LN43@ckd_dasd_r
  008a9	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  008b0	48 83 b8 20 14
	00 00 00	 cmp	 QWORD PTR [rax+5152], 0
  008b8	74 22		 je	 SHORT $LN43@ckd_dasd_r

; 906  :             tf_0426( dev, trk, i );

  008ba	44 8b 84 24 98
	00 00 00	 mov	 r8d, DWORD PTR i$[rsp]
  008c2	8b 94 24 e8 01
	00 00		 mov	 edx, DWORD PTR trk$[rsp]
  008c9	48 8b 8c 24 e0
	01 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  008d1	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_tf_0426
  008d7	e9 e4 00 00 00	 jmp	 $LN44@ckd_dasd_r
$LN43@ckd_dasd_r:
$LN10@ckd_dasd_r:

; 907  :         else
; 908  :             LOGDEVTR( HHC00426, "I", dev->filename, trk, i );

  008dc	48 8b 84 24 e0
	01 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  008e4	8b 80 f8 05 00
	00		 mov	 eax, DWORD PTR [rax+1528]
  008ea	c1 e8 0f	 shr	 eax, 15
  008ed	83 e0 01	 and	 eax, 1
  008f0	85 c0		 test	 eax, eax
  008f2	0f 84 be 00 00
	00		 je	 $LN45@ckd_dasd_r
  008f8	48 8b 84 24 e0
	01 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00900	48 05 a4 00 00
	00		 add	 rax, 164		; 000000a4H
  00906	48 89 84 24 88
	01 00 00	 mov	 QWORD PTR tv338[rsp], rax
  0090e	48 8b 8c 24 e0
	01 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  00916	0f b7 49 48	 movzx	 ecx, WORD PTR [rcx+72]
  0091a	89 8c 24 f8 00
	00 00		 mov	 DWORD PTR tv341[rsp], ecx
  00921	48 8b 94 24 e0
	01 00 00	 mov	 rdx, QWORD PTR dev$[rsp]
  00929	0f b7 52 44	 movzx	 edx, WORD PTR [rdx+68]
  0092d	d1 fa		 sar	 edx, 1
  0092f	89 94 24 fc 00
	00 00		 mov	 DWORD PTR tv345[rsp], edx
  00936	b9 01 00 00 00	 mov	 ecx, 1
  0093b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  00941	8b 8c 24 98 00
	00 00		 mov	 ecx, DWORD PTR i$[rsp]
  00948	89 4c 24 58	 mov	 DWORD PTR [rsp+88], ecx
  0094c	8b 8c 24 e8 01
	00 00		 mov	 ecx, DWORD PTR trk$[rsp]
  00953	89 4c 24 50	 mov	 DWORD PTR [rsp+80], ecx
  00957	48 8b 8c 24 88
	01 00 00	 mov	 rcx, QWORD PTR tv338[rsp]
  0095f	48 89 4c 24 48	 mov	 QWORD PTR [rsp+72], rcx
  00964	8b 8c 24 f8 00
	00 00		 mov	 ecx, DWORD PTR tv341[rsp]
  0096b	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  0096f	8b 8c 24 fc 00
	00 00		 mov	 ecx, DWORD PTR tv345[rsp]
  00976	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  0097a	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170271
  00981	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  00986	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170272
  0098d	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00992	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00997	41 b9 03 00 00
	00		 mov	 r9d, 3
  0099d	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG170273
  009a4	ba 8c 03 00 00	 mov	 edx, 908		; 0000038cH
  009a9	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170274
  009b0	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg
$LN45@ckd_dasd_r:
  009b6	33 c0		 xor	 eax, eax
  009b8	85 c0		 test	 eax, eax
  009ba	0f 85 1c ff ff
	ff		 jne	 $LN10@ckd_dasd_r
$LN44@ckd_dasd_r:

; 909  : 
; 910  :         dev->cachehits++;

  009c0	48 8b 84 24 e0
	01 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  009c8	8b 80 fc 01 00
	00		 mov	 eax, DWORD PTR [rax+508]
  009ce	ff c0		 inc	 eax
  009d0	48 8b 8c 24 e0
	01 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  009d8	89 81 fc 01 00
	00		 mov	 DWORD PTR [rcx+508], eax

; 911  :         dev->cache = i;

  009de	48 8b 84 24 e0
	01 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  009e6	8b 8c 24 98 00
	00 00		 mov	 ecx, DWORD PTR i$[rsp]
  009ed	89 88 f8 01 00
	00		 mov	 DWORD PTR [rax+504], ecx

; 912  :         dev->buf = cache_getbuf(CACHE_DEVBUF, dev->cache, 0);

  009f3	45 33 c0	 xor	 r8d, r8d
  009f6	48 8b 84 24 e0
	01 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  009fe	8b 90 f8 01 00
	00		 mov	 edx, DWORD PTR [rax+504]
  00a04	33 c9		 xor	 ecx, ecx
  00a06	e8 00 00 00 00	 call	 cache_getbuf
  00a0b	48 8b 8c 24 e0
	01 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  00a13	48 89 81 c8 01
	00 00		 mov	 QWORD PTR [rcx+456], rax

; 913  :         dev->bufcur = trk;

  00a1a	48 8b 84 24 e0
	01 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00a22	8b 8c 24 e8 01
	00 00		 mov	 ecx, DWORD PTR trk$[rsp]
  00a29	89 88 c0 01 00
	00		 mov	 DWORD PTR [rax+448], ecx

; 914  :         dev->bufoff = 0;

  00a2f	48 8b 84 24 e0
	01 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00a37	c7 80 e0 01 00
	00 00 00 00 00	 mov	 DWORD PTR [rax+480], 0

; 915  :         dev->bufoffhi = dev->ckdtrksz;

  00a41	48 8b 84 24 e0
	01 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00a49	48 8b 8c 24 e0
	01 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  00a51	8b 89 c4 12 00
	00		 mov	 ecx, DWORD PTR [rcx+4804]
  00a57	89 88 e8 01 00
	00		 mov	 DWORD PTR [rax+488], ecx

; 916  :         dev->buflen = ckd_trklen (dev, dev->buf);

  00a5d	48 8b 84 24 e0
	01 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00a65	48 8b 90 c8 01
	00 00		 mov	 rdx, QWORD PTR [rax+456]
  00a6c	48 8b 8c 24 e0
	01 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  00a74	e8 00 00 00 00	 call	 ckd_trklen
  00a79	48 8b 8c 24 e0
	01 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  00a81	89 81 dc 01 00
	00		 mov	 DWORD PTR [rcx+476], eax

; 917  :         dev->bufsize = cache_getlen(CACHE_DEVBUF, dev->cache);

  00a87	48 8b 84 24 e0
	01 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00a8f	8b 90 f8 01 00
	00		 mov	 edx, DWORD PTR [rax+504]
  00a95	33 c9		 xor	 ecx, ecx
  00a97	e8 00 00 00 00	 call	 cache_getlen
  00a9c	48 8b 8c 24 e0
	01 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  00aa4	89 81 d8 01 00
	00		 mov	 DWORD PTR [rcx+472], eax

; 918  : 
; 919  :         /* Set the file descriptor */
; 920  :         for (f = 0; f < dev->ckdnumfd; f++)

  00aaa	c7 84 24 90 00
	00 00 00 00 00
	00		 mov	 DWORD PTR f$[rsp], 0
  00ab5	eb 10		 jmp	 SHORT $LN13@ckd_dasd_r
$LN11@ckd_dasd_r:
  00ab7	8b 84 24 90 00
	00 00		 mov	 eax, DWORD PTR f$[rsp]
  00abe	ff c0		 inc	 eax
  00ac0	89 84 24 90 00
	00 00		 mov	 DWORD PTR f$[rsp], eax
$LN13@ckd_dasd_r:
  00ac7	48 8b 84 24 e0
	01 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00acf	8b 80 c4 11 00
	00		 mov	 eax, DWORD PTR [rax+4548]
  00ad5	39 84 24 90 00
	00 00		 cmp	 DWORD PTR f$[rsp], eax
  00adc	7d 24		 jge	 SHORT $LN12@ckd_dasd_r

; 921  :             if (trk < dev->ckdhitrk[f]) break;

  00ade	48 63 84 24 90
	00 00 00	 movsxd	 rax, DWORD PTR f$[rsp]
  00ae6	48 8b 8c 24 e0
	01 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  00aee	8b 84 81 34 12
	00 00		 mov	 eax, DWORD PTR [rcx+rax*4+4660]
  00af5	39 84 24 e8 01
	00 00		 cmp	 DWORD PTR trk$[rsp], eax
  00afc	7d 02		 jge	 SHORT $LN46@ckd_dasd_r
  00afe	eb 02		 jmp	 SHORT $LN12@ckd_dasd_r
$LN46@ckd_dasd_r:
  00b00	eb b5		 jmp	 SHORT $LN11@ckd_dasd_r
$LN12@ckd_dasd_r:

; 922  :         dev->fd = dev->ckdfd[f];

  00b02	48 63 84 24 90
	00 00 00	 movsxd	 rax, DWORD PTR f$[rsp]
  00b0a	48 8b 8c 24 e0
	01 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  00b12	48 8b 94 24 e0
	01 00 00	 mov	 rdx, QWORD PTR dev$[rsp]
  00b1a	8b 84 82 c8 11
	00 00		 mov	 eax, DWORD PTR [rdx+rax*4+4552]
  00b21	89 81 ac 01 00
	00		 mov	 DWORD PTR [rcx+428], eax

; 923  : 
; 924  :         /* Calculate the track offset */
; 925  :         dev->ckdtrkoff = (U64)(CKD_DEVHDR_SIZE +

  00b27	83 bc 24 90 00
	00 00 00	 cmp	 DWORD PTR f$[rsp], 0
  00b2f	74 23		 je	 SHORT $LN76@ckd_dasd_r
  00b31	8b 84 24 90 00
	00 00		 mov	 eax, DWORD PTR f$[rsp]
  00b38	ff c8		 dec	 eax
  00b3a	48 98		 cdqe
  00b3c	48 8b 8c 24 e0
	01 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  00b44	8b 84 81 34 12
	00 00		 mov	 eax, DWORD PTR [rcx+rax*4+4660]
  00b4b	89 84 24 d0 00
	00 00		 mov	 DWORD PTR tv402[rsp], eax
  00b52	eb 0b		 jmp	 SHORT $LN77@ckd_dasd_r
$LN76@ckd_dasd_r:
  00b54	c7 84 24 d0 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv402[rsp], 0
$LN77@ckd_dasd_r:
  00b5f	8b 84 24 d0 00
	00 00		 mov	 eax, DWORD PTR tv402[rsp]
  00b66	8b 8c 24 e8 01
	00 00		 mov	 ecx, DWORD PTR trk$[rsp]
  00b6d	2b c8		 sub	 ecx, eax
  00b6f	8b c1		 mov	 eax, ecx
  00b71	48 98		 cdqe
  00b73	48 8b 8c 24 e0
	01 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  00b7b	48 63 89 c4 12
	00 00		 movsxd	 rcx, DWORD PTR [rcx+4804]
  00b82	48 0f af c1	 imul	 rax, rcx
  00b86	48 05 00 02 00
	00		 add	 rax, 512		; 00000200H
  00b8c	48 8b 8c 24 e0
	01 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  00b94	48 89 81 b0 12
	00 00		 mov	 QWORD PTR [rcx+4784], rax

; 926  :              ((U64)(trk - (f ? dev->ckdhitrk[f-1] : 0))) * dev->ckdtrksz);
; 927  : 
; 928  :         return 0;

  00b9b	33 c0		 xor	 eax, eax
  00b9d	e9 48 0f 00 00	 jmp	 $LN1@ckd_dasd_r
$LN42@ckd_dasd_r:

; 929  :      }
; 930  : 
; 931  :     /* Wait if no available cache entry */
; 932  :     if (o < 0)

  00ba2	83 bc 24 94 00
	00 00 00	 cmp	 DWORD PTR o$[rsp], 0
  00baa	0f 8d 46 01 00
	00		 jge	 $LN47@ckd_dasd_r

; 933  :     {
; 934  :         // "%1d:%04X CKD file %s: read trk %d no available cache entry, waiting"
; 935  :         if (dev->ccwtrace && sysblk.traceFILE)

  00bb0	48 8b 84 24 e0
	01 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00bb8	8b 80 f8 05 00
	00		 mov	 eax, DWORD PTR [rax+1528]
  00bbe	c1 e8 0f	 shr	 eax, 15
  00bc1	83 e0 01	 and	 eax, 1
  00bc4	85 c0		 test	 eax, eax
  00bc6	74 2b		 je	 SHORT $LN48@ckd_dasd_r
  00bc8	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00bcf	48 83 b8 20 14
	00 00 00	 cmp	 QWORD PTR [rax+5152], 0
  00bd7	74 1a		 je	 SHORT $LN48@ckd_dasd_r

; 936  :             tf_0427( dev, trk );

  00bd9	8b 94 24 e8 01
	00 00		 mov	 edx, DWORD PTR trk$[rsp]
  00be0	48 8b 8c 24 e0
	01 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  00be8	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_tf_0427
  00bee	e9 d9 00 00 00	 jmp	 $LN49@ckd_dasd_r
$LN48@ckd_dasd_r:
$LN16@ckd_dasd_r:

; 937  :         else
; 938  :             LOGDEVTR( HHC00427, "I", dev->filename, trk );

  00bf3	48 8b 84 24 e0
	01 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00bfb	8b 80 f8 05 00
	00		 mov	 eax, DWORD PTR [rax+1528]
  00c01	c1 e8 0f	 shr	 eax, 15
  00c04	83 e0 01	 and	 eax, 1
  00c07	85 c0		 test	 eax, eax
  00c09	0f 84 b3 00 00
	00		 je	 $LN50@ckd_dasd_r
  00c0f	48 8b 84 24 e0
	01 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00c17	48 05 a4 00 00
	00		 add	 rax, 164		; 000000a4H
  00c1d	48 89 84 24 90
	01 00 00	 mov	 QWORD PTR tv423[rsp], rax
  00c25	48 8b 8c 24 e0
	01 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  00c2d	0f b7 49 48	 movzx	 ecx, WORD PTR [rcx+72]
  00c31	89 8c 24 00 01
	00 00		 mov	 DWORD PTR tv426[rsp], ecx
  00c38	48 8b 94 24 e0
	01 00 00	 mov	 rdx, QWORD PTR dev$[rsp]
  00c40	0f b7 52 44	 movzx	 edx, WORD PTR [rdx+68]
  00c44	d1 fa		 sar	 edx, 1
  00c46	89 94 24 04 01
	00 00		 mov	 DWORD PTR tv430[rsp], edx
  00c4d	b9 01 00 00 00	 mov	 ecx, 1
  00c52	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  00c58	8b 8c 24 e8 01
	00 00		 mov	 ecx, DWORD PTR trk$[rsp]
  00c5f	89 4c 24 50	 mov	 DWORD PTR [rsp+80], ecx
  00c63	48 8b 8c 24 90
	01 00 00	 mov	 rcx, QWORD PTR tv423[rsp]
  00c6b	48 89 4c 24 48	 mov	 QWORD PTR [rsp+72], rcx
  00c70	8b 8c 24 00 01
	00 00		 mov	 ecx, DWORD PTR tv426[rsp]
  00c77	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  00c7b	8b 8c 24 04 01
	00 00		 mov	 ecx, DWORD PTR tv430[rsp]
  00c82	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  00c86	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170280
  00c8d	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  00c92	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170281
  00c99	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00c9e	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00ca3	41 b9 03 00 00
	00		 mov	 r9d, 3
  00ca9	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG170282
  00cb0	ba aa 03 00 00	 mov	 edx, 938		; 000003aaH
  00cb5	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170283
  00cbc	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg
$LN50@ckd_dasd_r:
  00cc2	33 c0		 xor	 eax, eax
  00cc4	85 c0		 test	 eax, eax
  00cc6	0f 85 27 ff ff
	ff		 jne	 $LN16@ckd_dasd_r
$LN49@ckd_dasd_r:

; 939  : 
; 940  :         dev->cachewaits++;

  00ccc	48 8b 84 24 e0
	01 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00cd4	8b 80 04 02 00
	00		 mov	 eax, DWORD PTR [rax+516]
  00cda	ff c0		 inc	 eax
  00cdc	48 8b 8c 24 e0
	01 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  00ce4	89 81 04 02 00
	00		 mov	 DWORD PTR [rcx+516], eax

; 941  :         cache_wait(CACHE_DEVBUF);

  00cea	33 c9		 xor	 ecx, ecx
  00cec	e8 00 00 00 00	 call	 cache_wait

; 942  :         goto ckd_read_track_retry;

  00cf1	e9 2a fb ff ff	 jmp	 $ckd_read_track_retry$94
$LN47@ckd_dasd_r:

; 943  :     }
; 944  : 
; 945  :     /* Cache miss */
; 946  : 
; 947  :     // "%1d:%04X CKD file %s: read trk %d cache miss, using cache[%d]"
; 948  :     if (dev->ccwtrace && sysblk.traceFILE)

  00cf6	48 8b 84 24 e0
	01 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00cfe	8b 80 f8 05 00
	00		 mov	 eax, DWORD PTR [rax+1528]
  00d04	c1 e8 0f	 shr	 eax, 15
  00d07	83 e0 01	 and	 eax, 1
  00d0a	85 c0		 test	 eax, eax
  00d0c	74 33		 je	 SHORT $LN51@ckd_dasd_r
  00d0e	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00d15	48 83 b8 20 14
	00 00 00	 cmp	 QWORD PTR [rax+5152], 0
  00d1d	74 22		 je	 SHORT $LN51@ckd_dasd_r

; 949  :         tf_0428( dev, trk, o );

  00d1f	44 8b 84 24 94
	00 00 00	 mov	 r8d, DWORD PTR o$[rsp]
  00d27	8b 94 24 e8 01
	00 00		 mov	 edx, DWORD PTR trk$[rsp]
  00d2e	48 8b 8c 24 e0
	01 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  00d36	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_tf_0428
  00d3c	e9 e4 00 00 00	 jmp	 $LN52@ckd_dasd_r
$LN51@ckd_dasd_r:
$LN19@ckd_dasd_r:

; 950  :     else
; 951  :         LOGDEVTR( HHC00428, "I", dev->filename, trk, o );

  00d41	48 8b 84 24 e0
	01 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00d49	8b 80 f8 05 00
	00		 mov	 eax, DWORD PTR [rax+1528]
  00d4f	c1 e8 0f	 shr	 eax, 15
  00d52	83 e0 01	 and	 eax, 1
  00d55	85 c0		 test	 eax, eax
  00d57	0f 84 be 00 00
	00		 je	 $LN53@ckd_dasd_r
  00d5d	48 8b 84 24 e0
	01 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00d65	48 05 a4 00 00
	00		 add	 rax, 164		; 000000a4H
  00d6b	48 89 84 24 98
	01 00 00	 mov	 QWORD PTR tv462[rsp], rax
  00d73	48 8b 8c 24 e0
	01 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  00d7b	0f b7 49 48	 movzx	 ecx, WORD PTR [rcx+72]
  00d7f	89 8c 24 08 01
	00 00		 mov	 DWORD PTR tv465[rsp], ecx
  00d86	48 8b 94 24 e0
	01 00 00	 mov	 rdx, QWORD PTR dev$[rsp]
  00d8e	0f b7 52 44	 movzx	 edx, WORD PTR [rdx+68]
  00d92	d1 fa		 sar	 edx, 1
  00d94	89 94 24 0c 01
	00 00		 mov	 DWORD PTR tv469[rsp], edx
  00d9b	b9 01 00 00 00	 mov	 ecx, 1
  00da0	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  00da6	8b 8c 24 94 00
	00 00		 mov	 ecx, DWORD PTR o$[rsp]
  00dad	89 4c 24 58	 mov	 DWORD PTR [rsp+88], ecx
  00db1	8b 8c 24 e8 01
	00 00		 mov	 ecx, DWORD PTR trk$[rsp]
  00db8	89 4c 24 50	 mov	 DWORD PTR [rsp+80], ecx
  00dbc	48 8b 8c 24 98
	01 00 00	 mov	 rcx, QWORD PTR tv462[rsp]
  00dc4	48 89 4c 24 48	 mov	 QWORD PTR [rsp+72], rcx
  00dc9	8b 8c 24 08 01
	00 00		 mov	 ecx, DWORD PTR tv465[rsp]
  00dd0	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  00dd4	8b 8c 24 0c 01
	00 00		 mov	 ecx, DWORD PTR tv469[rsp]
  00ddb	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  00ddf	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170287
  00de6	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  00deb	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170288
  00df2	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00df7	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00dfc	41 b9 03 00 00
	00		 mov	 r9d, 3
  00e02	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG170289
  00e09	ba b7 03 00 00	 mov	 edx, 951		; 000003b7H
  00e0e	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170290
  00e15	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg
$LN53@ckd_dasd_r:
  00e1b	33 c0		 xor	 eax, eax
  00e1d	85 c0		 test	 eax, eax
  00e1f	0f 85 1c ff ff
	ff		 jne	 $LN19@ckd_dasd_r
$LN52@ckd_dasd_r:

; 952  : 
; 953  :     dev->cachemisses++;

  00e25	48 8b 84 24 e0
	01 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00e2d	8b 80 00 02 00
	00		 mov	 eax, DWORD PTR [rax+512]
  00e33	ff c0		 inc	 eax
  00e35	48 8b 8c 24 e0
	01 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  00e3d	89 81 00 02 00
	00		 mov	 DWORD PTR [rcx+512], eax

; 954  : 
; 955  :     /* Make this cache entry active */
; 956  :     cache_setkey (CACHE_DEVBUF, o, CKD_CACHE_SETKEY(dev->devnum, trk));

  00e43	48 8b 84 24 e0
	01 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00e4b	0f b7 40 48	 movzx	 eax, WORD PTR [rax+72]
  00e4f	48 c1 e0 20	 shl	 rax, 32			; 00000020H
  00e53	48 63 8c 24 e8
	01 00 00	 movsxd	 rcx, DWORD PTR trk$[rsp]
  00e5b	48 0b c1	 or	 rax, rcx
  00e5e	4c 8b c0	 mov	 r8, rax
  00e61	8b 94 24 94 00
	00 00		 mov	 edx, DWORD PTR o$[rsp]
  00e68	33 c9		 xor	 ecx, ecx
  00e6a	e8 00 00 00 00	 call	 cache_setkey

; 957  :     cache_setflag(CACHE_DEVBUF, o, 0, CKD_CACHE_ACTIVE|DEVBUF_TYPE_CKD);

  00e6f	41 b9 02 00 00
	80		 mov	 r9d, -2147483646	; 80000002H
  00e75	45 33 c0	 xor	 r8d, r8d
  00e78	8b 94 24 94 00
	00 00		 mov	 edx, DWORD PTR o$[rsp]
  00e7f	33 c9		 xor	 ecx, ecx
  00e81	e8 00 00 00 00	 call	 cache_setflag

; 958  :     cache_setage (CACHE_DEVBUF, o);

  00e86	8b 94 24 94 00
	00 00		 mov	 edx, DWORD PTR o$[rsp]
  00e8d	33 c9		 xor	 ecx, ecx
  00e8f	e8 00 00 00 00	 call	 cache_setage

; 959  :     dev->buf = cache_getbuf(CACHE_DEVBUF, o, dev->ckdtrksz);

  00e94	48 8b 84 24 e0
	01 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00e9c	44 8b 80 c4 12
	00 00		 mov	 r8d, DWORD PTR [rax+4804]
  00ea3	8b 94 24 94 00
	00 00		 mov	 edx, DWORD PTR o$[rsp]
  00eaa	33 c9		 xor	 ecx, ecx
  00eac	e8 00 00 00 00	 call	 cache_getbuf
  00eb1	48 8b 8c 24 e0
	01 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  00eb9	48 89 81 c8 01
	00 00		 mov	 QWORD PTR [rcx+456], rax

; 960  :     cache_unlock (CACHE_DEVBUF);

  00ec0	33 c9		 xor	 ecx, ecx
  00ec2	e8 00 00 00 00	 call	 cache_unlock

; 961  : 
; 962  :     /* Set the file descriptor */
; 963  :     for (f = 0; f < dev->ckdnumfd; f++)

  00ec7	c7 84 24 90 00
	00 00 00 00 00
	00		 mov	 DWORD PTR f$[rsp], 0
  00ed2	eb 10		 jmp	 SHORT $LN22@ckd_dasd_r
$LN20@ckd_dasd_r:
  00ed4	8b 84 24 90 00
	00 00		 mov	 eax, DWORD PTR f$[rsp]
  00edb	ff c0		 inc	 eax
  00edd	89 84 24 90 00
	00 00		 mov	 DWORD PTR f$[rsp], eax
$LN22@ckd_dasd_r:
  00ee4	48 8b 84 24 e0
	01 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00eec	8b 80 c4 11 00
	00		 mov	 eax, DWORD PTR [rax+4548]
  00ef2	39 84 24 90 00
	00 00		 cmp	 DWORD PTR f$[rsp], eax
  00ef9	7d 24		 jge	 SHORT $LN21@ckd_dasd_r

; 964  :         if (trk < dev->ckdhitrk[f]) break;

  00efb	48 63 84 24 90
	00 00 00	 movsxd	 rax, DWORD PTR f$[rsp]
  00f03	48 8b 8c 24 e0
	01 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  00f0b	8b 84 81 34 12
	00 00		 mov	 eax, DWORD PTR [rcx+rax*4+4660]
  00f12	39 84 24 e8 01
	00 00		 cmp	 DWORD PTR trk$[rsp], eax
  00f19	7d 02		 jge	 SHORT $LN54@ckd_dasd_r
  00f1b	eb 02		 jmp	 SHORT $LN21@ckd_dasd_r
$LN54@ckd_dasd_r:
  00f1d	eb b5		 jmp	 SHORT $LN20@ckd_dasd_r
$LN21@ckd_dasd_r:

; 965  :     dev->fd = dev->ckdfd[f];

  00f1f	48 63 84 24 90
	00 00 00	 movsxd	 rax, DWORD PTR f$[rsp]
  00f27	48 8b 8c 24 e0
	01 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  00f2f	48 8b 94 24 e0
	01 00 00	 mov	 rdx, QWORD PTR dev$[rsp]
  00f37	8b 84 82 c8 11
	00 00		 mov	 eax, DWORD PTR [rdx+rax*4+4552]
  00f3e	89 81 ac 01 00
	00		 mov	 DWORD PTR [rcx+428], eax

; 966  : 
; 967  :     /* Calculate the track offset */
; 968  :     dev->ckdtrkoff = (U64)(CKD_DEVHDR_SIZE +

  00f44	83 bc 24 90 00
	00 00 00	 cmp	 DWORD PTR f$[rsp], 0
  00f4c	74 23		 je	 SHORT $LN78@ckd_dasd_r
  00f4e	8b 84 24 90 00
	00 00		 mov	 eax, DWORD PTR f$[rsp]
  00f55	ff c8		 dec	 eax
  00f57	48 98		 cdqe
  00f59	48 8b 8c 24 e0
	01 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  00f61	8b 84 81 34 12
	00 00		 mov	 eax, DWORD PTR [rcx+rax*4+4660]
  00f68	89 84 24 d4 00
	00 00		 mov	 DWORD PTR tv526[rsp], eax
  00f6f	eb 0b		 jmp	 SHORT $LN79@ckd_dasd_r
$LN78@ckd_dasd_r:
  00f71	c7 84 24 d4 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv526[rsp], 0
$LN79@ckd_dasd_r:
  00f7c	8b 84 24 d4 00
	00 00		 mov	 eax, DWORD PTR tv526[rsp]
  00f83	8b 8c 24 e8 01
	00 00		 mov	 ecx, DWORD PTR trk$[rsp]
  00f8a	2b c8		 sub	 ecx, eax
  00f8c	8b c1		 mov	 eax, ecx
  00f8e	48 98		 cdqe
  00f90	48 8b 8c 24 e0
	01 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  00f98	48 63 89 c4 12
	00 00		 movsxd	 rcx, DWORD PTR [rcx+4804]
  00f9f	48 0f af c1	 imul	 rax, rcx
  00fa3	48 05 00 02 00
	00		 add	 rax, 512		; 00000200H
  00fa9	48 8b 8c 24 e0
	01 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  00fb1	48 89 81 b0 12
	00 00		 mov	 QWORD PTR [rcx+4784], rax

; 969  :          ((U64)(trk - (f ? dev->ckdhitrk[f-1] : 0))) * dev->ckdtrksz);
; 970  : 
; 971  :     // "%1d:%04X CKD file %s: read trk %d reading file %d offset %"PRId64" len %d"
; 972  :     if (dev->ccwtrace && sysblk.traceFILE)

  00fb8	48 8b 84 24 e0
	01 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00fc0	8b 80 f8 05 00
	00		 mov	 eax, DWORD PTR [rax+1528]
  00fc6	c1 e8 0f	 shr	 eax, 15
  00fc9	83 e0 01	 and	 eax, 1
  00fcc	85 c0		 test	 eax, eax
  00fce	74 37		 je	 SHORT $LN55@ckd_dasd_r
  00fd0	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00fd7	48 83 b8 20 14
	00 00 00	 cmp	 QWORD PTR [rax+5152], 0
  00fdf	74 26		 je	 SHORT $LN55@ckd_dasd_r

; 973  :         tf_0429( dev, trk, f+1 );

  00fe1	8b 84 24 90 00
	00 00		 mov	 eax, DWORD PTR f$[rsp]
  00fe8	ff c0		 inc	 eax
  00fea	44 8b c0	 mov	 r8d, eax
  00fed	8b 94 24 e8 01
	00 00		 mov	 edx, DWORD PTR trk$[rsp]
  00ff4	48 8b 8c 24 e0
	01 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  00ffc	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_tf_0429
  01002	e9 1e 01 00 00	 jmp	 $LN56@ckd_dasd_r
$LN55@ckd_dasd_r:
$LN25@ckd_dasd_r:

; 974  :     else
; 975  :         LOGDEVTR( HHC00429, "I", dev->filename, trk, f+1, dev->ckdtrkoff, dev->ckdtrksz );

  01007	48 8b 84 24 e0
	01 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  0100f	8b 80 f8 05 00
	00		 mov	 eax, DWORD PTR [rax+1528]
  01015	c1 e8 0f	 shr	 eax, 15
  01018	83 e0 01	 and	 eax, 1
  0101b	85 c0		 test	 eax, eax
  0101d	0f 84 f8 00 00
	00		 je	 $LN57@ckd_dasd_r
  01023	8b 84 24 90 00
	00 00		 mov	 eax, DWORD PTR f$[rsp]
  0102a	ff c0		 inc	 eax
  0102c	89 84 24 10 01
	00 00		 mov	 DWORD PTR tv551[rsp], eax
  01033	48 8b 8c 24 e0
	01 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  0103b	48 81 c1 a4 00
	00 00		 add	 rcx, 164		; 000000a4H
  01042	48 89 8c 24 a0
	01 00 00	 mov	 QWORD PTR tv554[rsp], rcx
  0104a	48 8b 94 24 e0
	01 00 00	 mov	 rdx, QWORD PTR dev$[rsp]
  01052	0f b7 52 48	 movzx	 edx, WORD PTR [rdx+72]
  01056	89 94 24 14 01
	00 00		 mov	 DWORD PTR tv557[rsp], edx
  0105d	4c 8b 84 24 e0
	01 00 00	 mov	 r8, QWORD PTR dev$[rsp]
  01065	45 0f b7 40 44	 movzx	 r8d, WORD PTR [r8+68]
  0106a	41 d1 f8	 sar	 r8d, 1
  0106d	44 89 84 24 18
	01 00 00	 mov	 DWORD PTR tv561[rsp], r8d
  01075	b9 01 00 00 00	 mov	 ecx, 1
  0107a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  01080	48 8b 8c 24 e0
	01 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  01088	8b 89 c4 12 00
	00		 mov	 ecx, DWORD PTR [rcx+4804]
  0108e	89 4c 24 68	 mov	 DWORD PTR [rsp+104], ecx
  01092	48 8b 8c 24 e0
	01 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  0109a	48 8b 89 b0 12
	00 00		 mov	 rcx, QWORD PTR [rcx+4784]
  010a1	48 89 4c 24 60	 mov	 QWORD PTR [rsp+96], rcx
  010a6	8b 8c 24 10 01
	00 00		 mov	 ecx, DWORD PTR tv551[rsp]
  010ad	89 4c 24 58	 mov	 DWORD PTR [rsp+88], ecx
  010b1	8b 8c 24 e8 01
	00 00		 mov	 ecx, DWORD PTR trk$[rsp]
  010b8	89 4c 24 50	 mov	 DWORD PTR [rsp+80], ecx
  010bc	48 8b 8c 24 a0
	01 00 00	 mov	 rcx, QWORD PTR tv554[rsp]
  010c4	48 89 4c 24 48	 mov	 QWORD PTR [rsp+72], rcx
  010c9	8b 8c 24 14 01
	00 00		 mov	 ecx, DWORD PTR tv557[rsp]
  010d0	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  010d4	8b 8c 24 18 01
	00 00		 mov	 ecx, DWORD PTR tv561[rsp]
  010db	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  010df	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170295
  010e6	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  010eb	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170296
  010f2	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  010f7	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  010fc	41 b9 03 00 00
	00		 mov	 r9d, 3
  01102	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG170297
  01109	ba cf 03 00 00	 mov	 edx, 975		; 000003cfH
  0110e	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170298
  01115	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg
$LN57@ckd_dasd_r:
  0111b	33 c0		 xor	 eax, eax
  0111d	85 c0		 test	 eax, eax
  0111f	0f 85 e2 fe ff
	ff		 jne	 $LN25@ckd_dasd_r
$LN56@ckd_dasd_r:

; 976  : 
; 977  :     /* Seek to the track image offset */
; 978  :     offset = dev->ckdtrkoff;

  01125	48 8b 84 24 e0
	01 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  0112d	48 8b 80 b0 12
	00 00		 mov	 rax, QWORD PTR [rax+4784]
  01134	48 89 84 24 b8
	00 00 00	 mov	 QWORD PTR offset$[rsp], rax

; 979  :     offset = lseek (dev->fd, offset, SEEK_SET);

  0113c	45 33 c0	 xor	 r8d, r8d
  0113f	48 8b 94 24 b8
	00 00 00	 mov	 rdx, QWORD PTR offset$[rsp]
  01147	48 8b 84 24 e0
	01 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  0114f	8b 88 ac 01 00
	00		 mov	 ecx, DWORD PTR [rax+428]
  01155	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__lseeki64
  0115b	48 89 84 24 b8
	00 00 00	 mov	 QWORD PTR offset$[rsp], rax

; 980  :     if ((S64)offset < 0)

  01163	48 83 bc 24 b8
	00 00 00 00	 cmp	 QWORD PTR offset$[rsp], 0
  0116c	0f 8d 7f 01 00
	00		 jge	 $LN58@ckd_dasd_r

; 981  :     {
; 982  :         /* Handle seek error condition */
; 983  :         // "%1d:%04X CKD file %s: error in function %s: %s"
; 984  :         WRMSG( HHC00404, "E", LCSS_DEVNUM,

  01172	48 83 bc 24 e0
	01 00 00 00	 cmp	 QWORD PTR dev$[rsp], 0
  0117b	74 15		 je	 SHORT $LN80@ckd_dasd_r
  0117d	48 8b 84 24 e0
	01 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  01185	0f b7 40 48	 movzx	 eax, WORD PTR [rax+72]
  01189	89 84 24 d8 00
	00 00		 mov	 DWORD PTR tv622[rsp], eax
  01190	eb 0b		 jmp	 SHORT $LN81@ckd_dasd_r
$LN80@ckd_dasd_r:
  01192	c7 84 24 d8 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv622[rsp], 0
$LN81@ckd_dasd_r:
  0119d	48 83 bc 24 e0
	01 00 00 00	 cmp	 QWORD PTR dev$[rsp], 0
  011a6	74 17		 je	 SHORT $LN82@ckd_dasd_r
  011a8	48 8b 84 24 e0
	01 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  011b0	0f b7 40 44	 movzx	 eax, WORD PTR [rax+68]
  011b4	d1 f8		 sar	 eax, 1
  011b6	89 84 24 dc 00
	00 00		 mov	 DWORD PTR tv628[rsp], eax
  011bd	eb 0b		 jmp	 SHORT $LN83@ckd_dasd_r
$LN82@ckd_dasd_r:
  011bf	c7 84 24 dc 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv628[rsp], 0
$LN83@ckd_dasd_r:
  011ca	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno
  011d0	8b 08		 mov	 ecx, DWORD PTR [rax]
  011d2	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_strerror
  011d8	48 89 84 24 a8
	01 00 00	 mov	 QWORD PTR tv612[rsp], rax
  011e0	48 8b 8c 24 e0
	01 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  011e8	48 81 c1 a4 00
	00 00		 add	 rcx, 164		; 000000a4H
  011ef	48 89 8c 24 b0
	01 00 00	 mov	 QWORD PTR tv617[rsp], rcx
  011f7	b9 01 00 00 00	 mov	 ecx, 1
  011fc	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  01202	48 8b 8c 24 a8
	01 00 00	 mov	 rcx, QWORD PTR tv612[rsp]
  0120a	48 89 4c 24 58	 mov	 QWORD PTR [rsp+88], rcx
  0120f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170300
  01216	48 89 4c 24 50	 mov	 QWORD PTR [rsp+80], rcx
  0121b	48 8b 8c 24 b0
	01 00 00	 mov	 rcx, QWORD PTR tv617[rsp]
  01223	48 89 4c 24 48	 mov	 QWORD PTR [rsp+72], rcx
  01228	8b 8c 24 d8 00
	00 00		 mov	 ecx, DWORD PTR tv622[rsp]
  0122f	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  01233	8b 8c 24 dc 00
	00 00		 mov	 ecx, DWORD PTR tv628[rsp]
  0123a	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  0123e	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170301
  01245	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  0124a	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170302
  01251	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  01256	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  0125b	41 b9 03 00 00
	00		 mov	 r9d, 3
  01261	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG170303
  01268	ba d9 03 00 00	 mov	 edx, 985		; 000003d9H
  0126d	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170304
  01274	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 985  :                dev->filename, "lseek()", strerror( errno ));
; 986  :         ckd_build_sense (dev, SENSE_EC, 0, 0, FORMAT_1, MESSAGE_0);

  0127a	c6 44 24 28 00	 mov	 BYTE PTR [rsp+40], 0
  0127f	c6 44 24 20 01	 mov	 BYTE PTR [rsp+32], 1
  01284	45 33 c9	 xor	 r9d, r9d
  01287	45 33 c0	 xor	 r8d, r8d
  0128a	b2 10		 mov	 dl, 16
  0128c	48 8b 8c 24 e0
	01 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  01294	e8 00 00 00 00	 call	 ckd_build_sense

; 987  :         *unitstat = CSW_CE | CSW_DE | CSW_UC;

  01299	48 8b 84 24 f0
	01 00 00	 mov	 rax, QWORD PTR unitstat$[rsp]
  012a1	c6 00 0e	 mov	 BYTE PTR [rax], 14

; 988  :         dev->bufcur = dev->cache = -1;

  012a4	48 8b 84 24 e0
	01 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  012ac	c7 80 f8 01 00
	00 ff ff ff ff	 mov	 DWORD PTR [rax+504], -1
  012b6	48 8b 84 24 e0
	01 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  012be	c7 80 c0 01 00
	00 ff ff ff ff	 mov	 DWORD PTR [rax+448], -1

; 989  :         cache_lock(CACHE_DEVBUF);

  012c8	33 c9		 xor	 ecx, ecx
  012ca	e8 00 00 00 00	 call	 cache_lock

; 990  :         cache_release(CACHE_DEVBUF, o, 0);

  012cf	45 33 c0	 xor	 r8d, r8d
  012d2	8b 94 24 94 00
	00 00		 mov	 edx, DWORD PTR o$[rsp]
  012d9	33 c9		 xor	 ecx, ecx
  012db	e8 00 00 00 00	 call	 cache_release

; 991  :         cache_unlock(CACHE_DEVBUF);

  012e0	33 c9		 xor	 ecx, ecx
  012e2	e8 00 00 00 00	 call	 cache_unlock

; 992  :         return -1;

  012e7	b8 ff ff ff ff	 mov	 eax, -1
  012ec	e9 f9 07 00 00	 jmp	 $LN1@ckd_dasd_r
$LN58@ckd_dasd_r:

; 993  :     }
; 994  : 
; 995  :     /* Read the track image */
; 996  :     if (dev->dasdcopy == 0)

  012f1	48 8b 84 24 e0
	01 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  012f9	8b 80 f8 05 00
	00		 mov	 eax, DWORD PTR [rax+1528]
  012ff	c1 e8 0b	 shr	 eax, 11
  01302	83 e0 01	 and	 eax, 1
  01305	85 c0		 test	 eax, eax
  01307	0f 85 f2 01 00
	00		 jne	 $LN59@ckd_dasd_r

; 997  :     {
; 998  :         rc = read (dev->fd, dev->buf, dev->ckdtrksz);

  0130d	48 8b 84 24 e0
	01 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  01315	44 8b 80 c4 12
	00 00		 mov	 r8d, DWORD PTR [rax+4804]
  0131c	48 8b 84 24 e0
	01 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  01324	48 8b 90 c8 01
	00 00		 mov	 rdx, QWORD PTR [rax+456]
  0132b	48 8b 84 24 e0
	01 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  01333	8b 88 ac 01 00
	00		 mov	 ecx, DWORD PTR [rax+428]
  01339	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_read
  0133f	89 84 24 a8 00
	00 00		 mov	 DWORD PTR rc$[rsp], eax

; 999  :         if (rc < dev->ckdtrksz)

  01346	48 8b 84 24 e0
	01 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  0134e	8b 80 c4 12 00
	00		 mov	 eax, DWORD PTR [rax+4804]
  01354	39 84 24 a8 00
	00 00		 cmp	 DWORD PTR rc$[rsp], eax
  0135b	0f 8d 99 01 00
	00		 jge	 $LN61@ckd_dasd_r

; 1000 :         {
; 1001 :             /* Handle read error condition */
; 1002 :             // "%1d:%04X CKD file %s: error in function %s: %s"
; 1003 :             WRMSG( HHC00404, "E", LCSS_DEVNUM,

  01361	83 bc 24 a8 00
	00 00 00	 cmp	 DWORD PTR rc$[rsp], 0
  01369	7d 18		 jge	 SHORT $LN84@ckd_dasd_r
  0136b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno
  01371	8b 08		 mov	 ecx, DWORD PTR [rax]
  01373	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_strerror
  01379	48 89 84 24 50
	01 00 00	 mov	 QWORD PTR tv669[rsp], rax
  01381	eb 0f		 jmp	 SHORT $LN85@ckd_dasd_r
$LN84@ckd_dasd_r:
  01383	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG170308
  0138a	48 89 84 24 50
	01 00 00	 mov	 QWORD PTR tv669[rsp], rax
$LN85@ckd_dasd_r:
  01392	48 83 bc 24 e0
	01 00 00 00	 cmp	 QWORD PTR dev$[rsp], 0
  0139b	74 15		 je	 SHORT $LN86@ckd_dasd_r
  0139d	48 8b 84 24 e0
	01 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  013a5	0f b7 40 48	 movzx	 eax, WORD PTR [rax+72]
  013a9	89 84 24 e0 00
	00 00		 mov	 DWORD PTR tv677[rsp], eax
  013b0	eb 0b		 jmp	 SHORT $LN87@ckd_dasd_r
$LN86@ckd_dasd_r:
  013b2	c7 84 24 e0 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv677[rsp], 0
$LN87@ckd_dasd_r:
  013bd	48 83 bc 24 e0
	01 00 00 00	 cmp	 QWORD PTR dev$[rsp], 0
  013c6	74 17		 je	 SHORT $LN88@ckd_dasd_r
  013c8	48 8b 84 24 e0
	01 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  013d0	0f b7 40 44	 movzx	 eax, WORD PTR [rax+68]
  013d4	d1 f8		 sar	 eax, 1
  013d6	89 84 24 e4 00
	00 00		 mov	 DWORD PTR tv683[rsp], eax
  013dd	eb 0b		 jmp	 SHORT $LN89@ckd_dasd_r
$LN88@ckd_dasd_r:
  013df	c7 84 24 e4 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv683[rsp], 0
$LN89@ckd_dasd_r:
  013ea	48 8b 84 24 e0
	01 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  013f2	48 05 a4 00 00
	00		 add	 rax, 164		; 000000a4H
  013f8	48 89 84 24 b8
	01 00 00	 mov	 QWORD PTR tv672[rsp], rax
  01400	b9 01 00 00 00	 mov	 ecx, 1
  01405	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  0140b	48 8b 8c 24 50
	01 00 00	 mov	 rcx, QWORD PTR tv669[rsp]
  01413	48 89 4c 24 58	 mov	 QWORD PTR [rsp+88], rcx
  01418	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170309
  0141f	48 89 4c 24 50	 mov	 QWORD PTR [rsp+80], rcx
  01424	48 8b 8c 24 b8
	01 00 00	 mov	 rcx, QWORD PTR tv672[rsp]
  0142c	48 89 4c 24 48	 mov	 QWORD PTR [rsp+72], rcx
  01431	8b 8c 24 e0 00
	00 00		 mov	 ecx, DWORD PTR tv677[rsp]
  01438	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  0143c	8b 8c 24 e4 00
	00 00		 mov	 ecx, DWORD PTR tv683[rsp]
  01443	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  01447	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170310
  0144e	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  01453	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170311
  0145a	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  0145f	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  01464	41 b9 03 00 00
	00		 mov	 r9d, 3
  0146a	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG170312
  01471	ba ec 03 00 00	 mov	 edx, 1004		; 000003ecH
  01476	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170313
  0147d	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 1004 :                    dev->filename, "read()", (rc < 0 ? strerror( errno ) : "unexpected end of file" ));
; 1005 :             ckd_build_sense (dev, SENSE_EC, 0, 0, FORMAT_1, MESSAGE_0);

  01483	c6 44 24 28 00	 mov	 BYTE PTR [rsp+40], 0
  01488	c6 44 24 20 01	 mov	 BYTE PTR [rsp+32], 1
  0148d	45 33 c9	 xor	 r9d, r9d
  01490	45 33 c0	 xor	 r8d, r8d
  01493	b2 10		 mov	 dl, 16
  01495	48 8b 8c 24 e0
	01 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  0149d	e8 00 00 00 00	 call	 ckd_build_sense

; 1006 :             *unitstat = CSW_CE | CSW_DE | CSW_UC;

  014a2	48 8b 84 24 f0
	01 00 00	 mov	 rax, QWORD PTR unitstat$[rsp]
  014aa	c6 00 0e	 mov	 BYTE PTR [rax], 14

; 1007 :             dev->bufcur = dev->cache = -1;

  014ad	48 8b 84 24 e0
	01 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  014b5	c7 80 f8 01 00
	00 ff ff ff ff	 mov	 DWORD PTR [rax+504], -1
  014bf	48 8b 84 24 e0
	01 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  014c7	c7 80 c0 01 00
	00 ff ff ff ff	 mov	 DWORD PTR [rax+448], -1

; 1008 :             cache_lock(CACHE_DEVBUF);

  014d1	33 c9		 xor	 ecx, ecx
  014d3	e8 00 00 00 00	 call	 cache_lock

; 1009 :             cache_release(CACHE_DEVBUF, o, 0);

  014d8	45 33 c0	 xor	 r8d, r8d
  014db	8b 94 24 94 00
	00 00		 mov	 edx, DWORD PTR o$[rsp]
  014e2	33 c9		 xor	 ecx, ecx
  014e4	e8 00 00 00 00	 call	 cache_release

; 1010 :             cache_unlock(CACHE_DEVBUF);

  014e9	33 c9		 xor	 ecx, ecx
  014eb	e8 00 00 00 00	 call	 cache_unlock

; 1011 :             return -1;

  014f0	b8 ff ff ff ff	 mov	 eax, -1
  014f5	e9 f0 05 00 00	 jmp	 $LN1@ckd_dasd_r
$LN61@ckd_dasd_r:

; 1012 :         }
; 1013 :     }

  014fa	e9 85 00 00 00	 jmp	 $LN60@ckd_dasd_r
$LN59@ckd_dasd_r:

; 1014 :     else
; 1015 :     {
; 1016 :         trkhdr = (CKD_TRKHDR*)dev->buf;

  014ff	48 8b 84 24 e0
	01 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  01507	48 8b 80 c8 01
	00 00		 mov	 rax, QWORD PTR [rax+456]
  0150e	48 89 84 24 a0
	00 00 00	 mov	 QWORD PTR trkhdr$[rsp], rax

; 1017 :         trkhdr->bin = 0;

  01516	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR trkhdr$[rsp]
  0151e	c6 00 00	 mov	 BYTE PTR [rax], 0

; 1018 :         store_hw( trkhdr->cyl,  cyl  );

  01521	0f b7 8c 24 b0
	00 00 00	 movzx	 ecx, WORD PTR cyl$[rsp]
  01529	e8 00 00 00 00	 call	 _byteswap_ushort
  0152e	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR trkhdr$[rsp]
  01536	48 ff c1	 inc	 rcx
  01539	0f b7 d0	 movzx	 edx, ax
  0153c	e8 00 00 00 00	 call	 store_hw_noswap

; 1019 :         store_hw( trkhdr->head, head );

  01541	0f b7 8c 24 ac
	00 00 00	 movzx	 ecx, WORD PTR head$[rsp]
  01549	e8 00 00 00 00	 call	 _byteswap_ushort
  0154e	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR trkhdr$[rsp]
  01556	48 83 c1 03	 add	 rcx, 3
  0155a	0f b7 d0	 movzx	 edx, ax
  0155d	e8 00 00 00 00	 call	 store_hw_noswap

; 1020 :         memset (dev->buf + CKD_TRKHDR_SIZE, 0xFF, 8);

  01562	48 8b 84 24 e0
	01 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  0156a	48 8b 80 c8 01
	00 00		 mov	 rax, QWORD PTR [rax+456]
  01571	48 83 c0 05	 add	 rax, 5
  01575	48 8b f8	 mov	 rdi, rax
  01578	b8 ff 00 00 00	 mov	 eax, 255		; 000000ffH
  0157d	b9 08 00 00 00	 mov	 ecx, 8
  01582	f3 aa		 rep stosb
$LN60@ckd_dasd_r:

; 1021 :     }
; 1022 : 
; 1023 :     /* Validate the track header */
; 1024 : 
; 1025 :     // "%1d:%04X CKD file %s: read trk %d trkhdr %02X %02X%02X %02X%02X"
; 1026 :     if (dev->ccwtrace && sysblk.traceFILE)

  01584	48 8b 84 24 e0
	01 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  0158c	8b 80 f8 05 00
	00		 mov	 eax, DWORD PTR [rax+1528]
  01592	c1 e8 0f	 shr	 eax, 15
  01595	83 e0 01	 and	 eax, 1
  01598	85 c0		 test	 eax, eax
  0159a	74 2b		 je	 SHORT $LN62@ckd_dasd_r
  0159c	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  015a3	48 83 b8 20 14
	00 00 00	 cmp	 QWORD PTR [rax+5152], 0
  015ab	74 1a		 je	 SHORT $LN62@ckd_dasd_r

; 1027 :         tf_0430( dev, trk );

  015ad	8b 94 24 e8 01
	00 00		 mov	 edx, DWORD PTR trk$[rsp]
  015b4	48 8b 8c 24 e0
	01 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  015bc	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_tf_0430
  015c2	e9 bb 01 00 00	 jmp	 $LN63@ckd_dasd_r
$LN62@ckd_dasd_r:
$LN28@ckd_dasd_r:

; 1028 :     else
; 1029 :         LOGDEVTR( HHC00430, "I", dev->filename, trk,

  015c7	48 8b 84 24 e0
	01 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  015cf	8b 80 f8 05 00
	00		 mov	 eax, DWORD PTR [rax+1528]
  015d5	c1 e8 0f	 shr	 eax, 15
  015d8	83 e0 01	 and	 eax, 1
  015db	85 c0		 test	 eax, eax
  015dd	0f 84 95 01 00
	00		 je	 $LN64@ckd_dasd_r
  015e3	b8 01 00 00 00	 mov	 eax, 1
  015e8	48 6b c0 04	 imul	 rax, rax, 4
  015ec	48 8b 8c 24 e0
	01 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  015f4	48 8b 89 c8 01
	00 00		 mov	 rcx, QWORD PTR [rcx+456]
  015fb	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  015ff	89 84 24 1c 01
	00 00		 mov	 DWORD PTR tv740[rsp], eax
  01606	b9 01 00 00 00	 mov	 ecx, 1
  0160b	48 6b c9 03	 imul	 rcx, rcx, 3
  0160f	48 8b 94 24 e0
	01 00 00	 mov	 rdx, QWORD PTR dev$[rsp]
  01617	48 8b 92 c8 01
	00 00		 mov	 rdx, QWORD PTR [rdx+456]
  0161e	0f b6 0c 0a	 movzx	 ecx, BYTE PTR [rdx+rcx]
  01622	89 8c 24 20 01
	00 00		 mov	 DWORD PTR tv745[rsp], ecx
  01629	ba 01 00 00 00	 mov	 edx, 1
  0162e	48 6b d2 02	 imul	 rdx, rdx, 2
  01632	48 8b bc 24 e0
	01 00 00	 mov	 rdi, QWORD PTR dev$[rsp]
  0163a	48 8b bf c8 01
	00 00		 mov	 rdi, QWORD PTR [rdi+456]
  01641	0f b6 14 17	 movzx	 edx, BYTE PTR [rdi+rdx]
  01645	89 94 24 24 01
	00 00		 mov	 DWORD PTR tv750[rsp], edx
  0164c	bf 01 00 00 00	 mov	 edi, 1
  01651	48 6b ff 01	 imul	 rdi, rdi, 1
  01655	4c 8b 84 24 e0
	01 00 00	 mov	 r8, QWORD PTR dev$[rsp]
  0165d	4d 8b 80 c8 01
	00 00		 mov	 r8, QWORD PTR [r8+456]
  01664	41 0f b6 3c 38	 movzx	 edi, BYTE PTR [r8+rdi]
  01669	41 b8 01 00 00
	00		 mov	 r8d, 1
  0166f	4d 6b c0 00	 imul	 r8, r8, 0
  01673	4c 8b 8c 24 e0
	01 00 00	 mov	 r9, QWORD PTR dev$[rsp]
  0167b	4d 8b 89 c8 01
	00 00		 mov	 r9, QWORD PTR [r9+456]
  01682	47 0f b6 04 01	 movzx	 r8d, BYTE PTR [r9+r8]
  01687	44 89 84 24 28
	01 00 00	 mov	 DWORD PTR tv760[rsp], r8d
  0168f	4c 8b 8c 24 e0
	01 00 00	 mov	 r9, QWORD PTR dev$[rsp]
  01697	49 81 c1 a4 00
	00 00		 add	 r9, 164			; 000000a4H
  0169e	4c 89 8c 24 c0
	01 00 00	 mov	 QWORD PTR tv763[rsp], r9
  016a6	4c 8b 94 24 e0
	01 00 00	 mov	 r10, QWORD PTR dev$[rsp]
  016ae	45 0f b7 52 48	 movzx	 r10d, WORD PTR [r10+72]
  016b3	44 89 94 24 2c
	01 00 00	 mov	 DWORD PTR tv766[rsp], r10d
  016bb	4c 8b 9c 24 e0
	01 00 00	 mov	 r11, QWORD PTR dev$[rsp]
  016c3	45 0f b7 5b 44	 movzx	 r11d, WORD PTR [r11+68]
  016c8	41 d1 fb	 sar	 r11d, 1
  016cb	44 89 9c 24 30
	01 00 00	 mov	 DWORD PTR tv770[rsp], r11d
  016d3	b9 01 00 00 00	 mov	 ecx, 1
  016d8	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  016de	8b 8c 24 1c 01
	00 00		 mov	 ecx, DWORD PTR tv740[rsp]
  016e5	89 4c 24 78	 mov	 DWORD PTR [rsp+120], ecx
  016e9	8b 8c 24 20 01
	00 00		 mov	 ecx, DWORD PTR tv745[rsp]
  016f0	89 4c 24 70	 mov	 DWORD PTR [rsp+112], ecx
  016f4	8b 8c 24 24 01
	00 00		 mov	 ecx, DWORD PTR tv750[rsp]
  016fb	89 4c 24 68	 mov	 DWORD PTR [rsp+104], ecx
  016ff	89 7c 24 60	 mov	 DWORD PTR [rsp+96], edi
  01703	8b 8c 24 28 01
	00 00		 mov	 ecx, DWORD PTR tv760[rsp]
  0170a	89 4c 24 58	 mov	 DWORD PTR [rsp+88], ecx
  0170e	8b 8c 24 e8 01
	00 00		 mov	 ecx, DWORD PTR trk$[rsp]
  01715	89 4c 24 50	 mov	 DWORD PTR [rsp+80], ecx
  01719	48 8b 8c 24 c0
	01 00 00	 mov	 rcx, QWORD PTR tv763[rsp]
  01721	48 89 4c 24 48	 mov	 QWORD PTR [rsp+72], rcx
  01726	8b 8c 24 2c 01
	00 00		 mov	 ecx, DWORD PTR tv766[rsp]
  0172d	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  01731	8b 8c 24 30 01
	00 00		 mov	 ecx, DWORD PTR tv770[rsp]
  01738	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  0173c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170317
  01743	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  01748	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170318
  0174f	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  01754	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  01759	41 b9 03 00 00
	00		 mov	 r9d, 3
  0175f	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG170319
  01766	ba 06 04 00 00	 mov	 edx, 1030		; 00000406H
  0176b	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170320
  01772	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg
$LN64@ckd_dasd_r:
  01778	33 c0		 xor	 eax, eax
  0177a	85 c0		 test	 eax, eax
  0177c	0f 85 45 fe ff
	ff		 jne	 $LN28@ckd_dasd_r
$LN63@ckd_dasd_r:

; 1030 :             dev->buf[0], dev->buf[1], dev->buf[2], dev->buf[3], dev->buf[4] );
; 1031 : 
; 1032 :     trkhdr = (CKD_TRKHDR*)dev->buf;

  01782	48 8b 84 24 e0
	01 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  0178a	48 8b 80 c8 01
	00 00		 mov	 rax, QWORD PTR [rax+456]
  01791	48 89 84 24 a0
	00 00 00	 mov	 QWORD PTR trkhdr$[rsp], rax

; 1033 :     if (0
; 1034 :         || trkhdr->bin              != 0
; 1035 :         || fetch_hw( trkhdr->cyl  ) != cyl
; 1036 :         || fetch_hw( trkhdr->head ) != head

  01799	33 c0		 xor	 eax, eax
  0179b	85 c0		 test	 eax, eax
  0179d	75 62		 jne	 SHORT $LN66@ckd_dasd_r
  0179f	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR trkhdr$[rsp]
  017a7	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  017aa	85 c0		 test	 eax, eax
  017ac	75 53		 jne	 SHORT $LN66@ckd_dasd_r
  017ae	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR trkhdr$[rsp]
  017b6	48 ff c0	 inc	 rax
  017b9	48 8b c8	 mov	 rcx, rax
  017bc	e8 00 00 00 00	 call	 fetch_hw_noswap
  017c1	0f b7 c8	 movzx	 ecx, ax
  017c4	e8 00 00 00 00	 call	 _byteswap_ushort
  017c9	0f b7 c0	 movzx	 eax, ax
  017cc	3b 84 24 b0 00
	00 00		 cmp	 eax, DWORD PTR cyl$[rsp]
  017d3	75 2c		 jne	 SHORT $LN66@ckd_dasd_r
  017d5	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR trkhdr$[rsp]
  017dd	48 83 c0 03	 add	 rax, 3
  017e1	48 8b c8	 mov	 rcx, rax
  017e4	e8 00 00 00 00	 call	 fetch_hw_noswap
  017e9	0f b7 c8	 movzx	 ecx, ax
  017ec	e8 00 00 00 00	 call	 _byteswap_ushort
  017f1	0f b7 c0	 movzx	 eax, ax
  017f4	3b 84 24 ac 00
	00 00		 cmp	 eax, DWORD PTR head$[rsp]
  017fb	0f 84 1b 02 00
	00		 je	 $LN65@ckd_dasd_r
$LN66@ckd_dasd_r:

; 1037 :     )
; 1038 :     {
; 1039 :         // "%1d:%04X CKD file %s: invalid track header for cyl %d head %d %02X %02X%02X %02X%02X"
; 1040 :         WRMSG( HHC00418, "E", LCSS_DEVNUM,

  01801	48 83 bc 24 e0
	01 00 00 00	 cmp	 QWORD PTR dev$[rsp], 0
  0180a	74 15		 je	 SHORT $LN90@ckd_dasd_r
  0180c	48 8b 84 24 e0
	01 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  01814	0f b7 40 48	 movzx	 eax, WORD PTR [rax+72]
  01818	89 84 24 e8 00
	00 00		 mov	 DWORD PTR tv831[rsp], eax
  0181f	eb 0b		 jmp	 SHORT $LN91@ckd_dasd_r
$LN90@ckd_dasd_r:
  01821	c7 84 24 e8 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv831[rsp], 0
$LN91@ckd_dasd_r:
  0182c	48 83 bc 24 e0
	01 00 00 00	 cmp	 QWORD PTR dev$[rsp], 0
  01835	74 17		 je	 SHORT $LN92@ckd_dasd_r
  01837	48 8b 84 24 e0
	01 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  0183f	0f b7 40 44	 movzx	 eax, WORD PTR [rax+68]
  01843	d1 f8		 sar	 eax, 1
  01845	89 84 24 ec 00
	00 00		 mov	 DWORD PTR tv837[rsp], eax
  0184c	eb 0b		 jmp	 SHORT $LN93@ckd_dasd_r
$LN92@ckd_dasd_r:
  0184e	c7 84 24 ec 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv837[rsp], 0
$LN93@ckd_dasd_r:
  01859	b8 01 00 00 00	 mov	 eax, 1
  0185e	48 6b c0 01	 imul	 rax, rax, 1
  01862	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR trkhdr$[rsp]
  0186a	0f b6 44 01 03	 movzx	 eax, BYTE PTR [rcx+rax+3]
  0186f	89 84 24 34 01
	00 00		 mov	 DWORD PTR tv804[rsp], eax
  01876	b9 01 00 00 00	 mov	 ecx, 1
  0187b	48 6b c9 00	 imul	 rcx, rcx, 0
  0187f	48 8b 94 24 a0
	00 00 00	 mov	 rdx, QWORD PTR trkhdr$[rsp]
  01887	0f b6 4c 0a 03	 movzx	 ecx, BYTE PTR [rdx+rcx+3]
  0188c	89 8c 24 38 01
	00 00		 mov	 DWORD PTR tv809[rsp], ecx
  01893	ba 01 00 00 00	 mov	 edx, 1
  01898	48 6b d2 01	 imul	 rdx, rdx, 1
  0189c	48 8b bc 24 a0
	00 00 00	 mov	 rdi, QWORD PTR trkhdr$[rsp]
  018a4	0f b6 54 17 01	 movzx	 edx, BYTE PTR [rdi+rdx+1]
  018a9	89 94 24 3c 01
	00 00		 mov	 DWORD PTR tv814[rsp], edx
  018b0	bf 01 00 00 00	 mov	 edi, 1
  018b5	48 6b ff 00	 imul	 rdi, rdi, 0
  018b9	4c 8b 84 24 a0
	00 00 00	 mov	 r8, QWORD PTR trkhdr$[rsp]
  018c1	41 0f b6 7c 38
	01		 movzx	 edi, BYTE PTR [r8+rdi+1]
  018c7	4c 8b 84 24 a0
	00 00 00	 mov	 r8, QWORD PTR trkhdr$[rsp]
  018cf	45 0f b6 00	 movzx	 r8d, BYTE PTR [r8]
  018d3	44 89 84 24 40
	01 00 00	 mov	 DWORD PTR tv822[rsp], r8d
  018db	4c 8b 8c 24 e0
	01 00 00	 mov	 r9, QWORD PTR dev$[rsp]
  018e3	49 81 c1 a4 00
	00 00		 add	 r9, 164			; 000000a4H
  018ea	4c 89 8c 24 c8
	01 00 00	 mov	 QWORD PTR tv826[rsp], r9
  018f2	b9 01 00 00 00	 mov	 ecx, 1
  018f7	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  018fd	8b 8c 24 34 01
	00 00		 mov	 ecx, DWORD PTR tv804[rsp]
  01904	89 8c 24 80 00
	00 00		 mov	 DWORD PTR [rsp+128], ecx
  0190b	8b 8c 24 38 01
	00 00		 mov	 ecx, DWORD PTR tv809[rsp]
  01912	89 4c 24 78	 mov	 DWORD PTR [rsp+120], ecx
  01916	8b 8c 24 3c 01
	00 00		 mov	 ecx, DWORD PTR tv814[rsp]
  0191d	89 4c 24 70	 mov	 DWORD PTR [rsp+112], ecx
  01921	89 7c 24 68	 mov	 DWORD PTR [rsp+104], edi
  01925	8b 8c 24 40 01
	00 00		 mov	 ecx, DWORD PTR tv822[rsp]
  0192c	89 4c 24 60	 mov	 DWORD PTR [rsp+96], ecx
  01930	8b 8c 24 ac 00
	00 00		 mov	 ecx, DWORD PTR head$[rsp]
  01937	89 4c 24 58	 mov	 DWORD PTR [rsp+88], ecx
  0193b	8b 8c 24 b0 00
	00 00		 mov	 ecx, DWORD PTR cyl$[rsp]
  01942	89 4c 24 50	 mov	 DWORD PTR [rsp+80], ecx
  01946	48 8b 8c 24 c8
	01 00 00	 mov	 rcx, QWORD PTR tv826[rsp]
  0194e	48 89 4c 24 48	 mov	 QWORD PTR [rsp+72], rcx
  01953	8b 8c 24 e8 00
	00 00		 mov	 ecx, DWORD PTR tv831[rsp]
  0195a	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  0195e	8b 8c 24 ec 00
	00 00		 mov	 ecx, DWORD PTR tv837[rsp]
  01965	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  01969	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170323
  01970	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  01975	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170324
  0197c	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  01981	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  01986	41 b9 03 00 00
	00		 mov	 r9d, 3
  0198c	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG170325
  01993	ba 13 04 00 00	 mov	 edx, 1043		; 00000413H
  01998	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170326
  0199f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 1041 :                dev->filename, cyl, head, trkhdr->bin,
; 1042 :                trkhdr->cyl[0], trkhdr->cyl[1],
; 1043 :                trkhdr->head[0], trkhdr->head[1] );
; 1044 :         ckd_build_sense (dev, 0, SENSE1_ITF, 0, 0, 0);

  019a5	c6 44 24 28 00	 mov	 BYTE PTR [rsp+40], 0
  019aa	c6 44 24 20 00	 mov	 BYTE PTR [rsp+32], 0
  019af	45 33 c9	 xor	 r9d, r9d
  019b2	41 b0 40	 mov	 r8b, 64			; 00000040H
  019b5	33 d2		 xor	 edx, edx
  019b7	48 8b 8c 24 e0
	01 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  019bf	e8 00 00 00 00	 call	 ckd_build_sense

; 1045 :         *unitstat = CSW_CE | CSW_DE | CSW_UC;

  019c4	48 8b 84 24 f0
	01 00 00	 mov	 rax, QWORD PTR unitstat$[rsp]
  019cc	c6 00 0e	 mov	 BYTE PTR [rax], 14

; 1046 :         dev->bufcur = dev->cache = -1;

  019cf	48 8b 84 24 e0
	01 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  019d7	c7 80 f8 01 00
	00 ff ff ff ff	 mov	 DWORD PTR [rax+504], -1
  019e1	48 8b 84 24 e0
	01 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  019e9	c7 80 c0 01 00
	00 ff ff ff ff	 mov	 DWORD PTR [rax+448], -1

; 1047 :         cache_lock(CACHE_DEVBUF);

  019f3	33 c9		 xor	 ecx, ecx
  019f5	e8 00 00 00 00	 call	 cache_lock

; 1048 :         cache_release(CACHE_DEVBUF, o, 0);

  019fa	45 33 c0	 xor	 r8d, r8d
  019fd	8b 94 24 94 00
	00 00		 mov	 edx, DWORD PTR o$[rsp]
  01a04	33 c9		 xor	 ecx, ecx
  01a06	e8 00 00 00 00	 call	 cache_release

; 1049 :         cache_unlock(CACHE_DEVBUF);

  01a0b	33 c9		 xor	 ecx, ecx
  01a0d	e8 00 00 00 00	 call	 cache_unlock

; 1050 :         return -1;

  01a12	b8 ff ff ff ff	 mov	 eax, -1
  01a17	e9 ce 00 00 00	 jmp	 $LN1@ckd_dasd_r
$LN65@ckd_dasd_r:

; 1051 :     }
; 1052 : 
; 1053 :     dev->cache = o;

  01a1c	48 8b 84 24 e0
	01 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  01a24	8b 8c 24 94 00
	00 00		 mov	 ecx, DWORD PTR o$[rsp]
  01a2b	89 88 f8 01 00
	00		 mov	 DWORD PTR [rax+504], ecx

; 1054 :     dev->buf = cache_getbuf(CACHE_DEVBUF, dev->cache, 0);

  01a31	45 33 c0	 xor	 r8d, r8d
  01a34	48 8b 84 24 e0
	01 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  01a3c	8b 90 f8 01 00
	00		 mov	 edx, DWORD PTR [rax+504]
  01a42	33 c9		 xor	 ecx, ecx
  01a44	e8 00 00 00 00	 call	 cache_getbuf
  01a49	48 8b 8c 24 e0
	01 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  01a51	48 89 81 c8 01
	00 00		 mov	 QWORD PTR [rcx+456], rax

; 1055 :     dev->bufcur = trk;

  01a58	48 8b 84 24 e0
	01 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  01a60	8b 8c 24 e8 01
	00 00		 mov	 ecx, DWORD PTR trk$[rsp]
  01a67	89 88 c0 01 00
	00		 mov	 DWORD PTR [rax+448], ecx

; 1056 :     dev->bufoff = 0;

  01a6d	48 8b 84 24 e0
	01 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  01a75	c7 80 e0 01 00
	00 00 00 00 00	 mov	 DWORD PTR [rax+480], 0

; 1057 :     dev->bufoffhi = dev->ckdtrksz;

  01a7f	48 8b 84 24 e0
	01 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  01a87	48 8b 8c 24 e0
	01 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  01a8f	8b 89 c4 12 00
	00		 mov	 ecx, DWORD PTR [rcx+4804]
  01a95	89 88 e8 01 00
	00		 mov	 DWORD PTR [rax+488], ecx

; 1058 :     dev->buflen = ckd_trklen (dev, dev->buf);

  01a9b	48 8b 84 24 e0
	01 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  01aa3	48 8b 90 c8 01
	00 00		 mov	 rdx, QWORD PTR [rax+456]
  01aaa	48 8b 8c 24 e0
	01 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  01ab2	e8 00 00 00 00	 call	 ckd_trklen
  01ab7	48 8b 8c 24 e0
	01 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  01abf	89 81 dc 01 00
	00		 mov	 DWORD PTR [rcx+476], eax

; 1059 :     dev->bufsize = cache_getlen(CACHE_DEVBUF, dev->cache);

  01ac5	48 8b 84 24 e0
	01 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  01acd	8b 90 f8 01 00
	00		 mov	 edx, DWORD PTR [rax+504]
  01ad3	33 c9		 xor	 ecx, ecx
  01ad5	e8 00 00 00 00	 call	 cache_getlen
  01ada	48 8b 8c 24 e0
	01 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  01ae2	89 81 d8 01 00
	00		 mov	 DWORD PTR [rcx+472], eax

; 1060 : 
; 1061 :     return 0;

  01ae8	33 c0		 xor	 eax, eax
$LN1@ckd_dasd_r:

; 1062 : } /* end function ckdread_read_track */

  01aea	48 81 c4 d0 01
	00 00		 add	 rsp, 464		; 000001d0H
  01af1	5f		 pop	 rdi
  01af2	c3		 ret	 0
ckd_dasd_read_track ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\ckddasd.c
_TEXT	SEGMENT
devnum$ = 32
trk$ = 36
dev$ = 40
answer$ = 64
ix$ = 72
i$ = 80
data$ = 88
ckddasd_purge_cache PROC

; 701  : {

$LN10:
  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  0000a	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  0000e	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00013	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 702  : U16             devnum;                 /* Cached device number      */
; 703  : int             trk;                    /* Cached track              */
; 704  : DEVBLK         *dev = data;             /* -> device block           */

  00017	48 8b 44 24 58	 mov	 rax, QWORD PTR data$[rsp]
  0001c	48 89 44 24 28	 mov	 QWORD PTR dev$[rsp], rax
$LN4@ckddasd_pu:

; 705  : 
; 706  :     UNREFERENCED(answer);

  00021	33 c0		 xor	 eax, eax
  00023	85 c0		 test	 eax, eax
  00025	75 fa		 jne	 SHORT $LN4@ckddasd_pu
$LN7@ckddasd_pu:

; 707  :     UNREFERENCED( trk ); // (silence "set but not used" warning)

  00027	33 c0		 xor	 eax, eax
  00029	85 c0		 test	 eax, eax
  0002b	75 fa		 jne	 SHORT $LN7@ckddasd_pu

; 708  :     CKD_CACHE_GETKEY(i, devnum, trk);

  0002d	8b 54 24 50	 mov	 edx, DWORD PTR i$[rsp]
  00031	33 c9		 xor	 ecx, ecx
  00033	e8 00 00 00 00	 call	 cache_getkey
  00038	48 c1 e8 20	 shr	 rax, 32			; 00000020H
  0003c	48 25 ff ff 00
	00		 and	 rax, 65535		; 0000ffffH
  00042	66 89 44 24 20	 mov	 WORD PTR devnum$[rsp], ax
  00047	8b 54 24 50	 mov	 edx, DWORD PTR i$[rsp]
  0004b	33 c9		 xor	 ecx, ecx
  0004d	e8 00 00 00 00	 call	 cache_getkey
  00052	b9 ff ff ff ff	 mov	 ecx, -1			; ffffffffH
  00057	48 23 c1	 and	 rax, rcx
  0005a	89 44 24 24	 mov	 DWORD PTR trk$[rsp], eax

; 709  :     if (dev->devnum == devnum)

  0005e	48 8b 44 24 28	 mov	 rax, QWORD PTR dev$[rsp]
  00063	0f b7 40 48	 movzx	 eax, WORD PTR [rax+72]
  00067	0f b7 4c 24 20	 movzx	 ecx, WORD PTR devnum$[rsp]
  0006c	3b c1		 cmp	 eax, ecx
  0006e	75 13		 jne	 SHORT $LN8@ckddasd_pu

; 710  :         cache_release (ix, i, CACHE_FREEBUF);

  00070	41 b8 01 00 00
	00		 mov	 r8d, 1
  00076	8b 54 24 50	 mov	 edx, DWORD PTR i$[rsp]
  0007a	8b 4c 24 48	 mov	 ecx, DWORD PTR ix$[rsp]
  0007e	e8 00 00 00 00	 call	 cache_release
$LN8@ckddasd_pu:

; 711  :     return 0;

  00083	33 c0		 xor	 eax, eax

; 712  : }

  00085	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00089	c3		 ret	 0
ckddasd_purge_cache ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\sr.h
_TEXT	SEGMENT
sr_value_error_ PROC

; 836  : {

  00000	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 837  :     // "SR: value error, incorrect length"
; 838  :     WRMSG(HHC02020, "E");

  00004	b9 01 00 00 00	 mov	 ecx, 1
  00009	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  0000f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG168411
  00016	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  0001b	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG168412
  00022	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00027	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  0002c	41 b9 03 00 00
	00		 mov	 r9d, 3
  00032	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG168413
  00039	ba 46 03 00 00	 mov	 edx, 838		; 00000346H
  0003e	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG168414
  00045	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 839  : }

  0004b	48 83 c4 48	 add	 rsp, 72			; 00000048H
  0004f	c3		 ret	 0
sr_value_error_ ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\sr.h
_TEXT	SEGMENT
tv64 = 80
sr_read_error_ PROC

; 824  : {

  00000	48 83 ec 68	 sub	 rsp, 104		; 00000068H

; 825  :     // "SR: error in function '%s': '%s'"
; 826  :     WRMSG(HHC02001, "E", "read()", strerror(errno));

  00004	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno
  0000a	8b 08		 mov	 ecx, DWORD PTR [rax]
  0000c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_strerror
  00012	48 89 44 24 50	 mov	 QWORD PTR tv64[rsp], rax
  00017	b9 01 00 00 00	 mov	 ecx, 1
  0001c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  00022	48 8b 4c 24 50	 mov	 rcx, QWORD PTR tv64[rsp]
  00027	48 89 4c 24 40	 mov	 QWORD PTR [rsp+64], rcx
  0002c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG168399
  00033	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  00038	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG168400
  0003f	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  00044	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG168401
  0004b	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00050	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00055	41 b9 03 00 00
	00		 mov	 r9d, 3
  0005b	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG168402
  00062	ba 3a 03 00 00	 mov	 edx, 826		; 0000033aH
  00067	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG168403
  0006e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 827  : }

  00074	48 83 c4 68	 add	 rsp, 104		; 00000068H
  00078	c3		 ret	 0
sr_read_error_ ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\sr.h
_TEXT	SEGMENT
tv64 = 80
sr_write_error_ PROC

; 818  : {

  00000	48 83 ec 68	 sub	 rsp, 104		; 00000068H

; 819  :     // "SR: error in function '%s': '%s'"
; 820  :     WRMSG(HHC02001, "E", "write()", strerror(errno));

  00004	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno
  0000a	8b 08		 mov	 ecx, DWORD PTR [rax]
  0000c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_strerror
  00012	48 89 44 24 50	 mov	 QWORD PTR tv64[rsp], rax
  00017	b9 01 00 00 00	 mov	 ecx, 1
  0001c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  00022	48 8b 4c 24 50	 mov	 rcx, QWORD PTR tv64[rsp]
  00027	48 89 4c 24 40	 mov	 QWORD PTR [rsp+64], rcx
  0002c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG168393
  00033	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  00038	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG168394
  0003f	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  00044	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG168395
  0004b	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00050	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00055	41 b9 03 00 00
	00		 mov	 r9d, 3
  0005b	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG168396
  00062	ba 34 03 00 00	 mov	 edx, 820		; 00000334H
  00067	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG168397
  0006e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 821  : }

  00074	48 83 c4 68	 add	 rsp, 104		; 00000068H
  00078	c3		 ret	 0
sr_write_error_ ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\sr.h
_TEXT	SEGMENT
tot$ = 32
siz$ = 40
tv74 = 48
buf$ = 64
__$ArrayPad$ = 320
file$ = 352
len$ = 360
sr_read_skip PROC

; 677  : {

  00000	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00004	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00009	48 81 ec 58 01
	00 00		 sub	 rsp, 344		; 00000158H
  00010	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00017	48 33 c4	 xor	 rax, rsp
  0001a	48 89 84 24 40
	01 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax
$LN4@sr_read_sk:

; 678  : /* FIXME: Workaround for problem involving gzseek
; 679  :           and large files.  Just read the data. */
; 680  : 
; 681  : BYTE    buf[SR_SKIP_CHUNKSIZE];
; 682  : size_t  siz;
; 683  : size_t  tot;
; 684  : 
; 685  :     TRACE("SR: sr_read_skip:                  len=0x%8.8x\n", len);

  00022	8b 94 24 68 01
	00 00		 mov	 edx, DWORD PTR len$[rsp]
  00029	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG168305
  00030	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_logmsg
  00036	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_IsDebuggerPresent
  0003c	85 c0		 test	 eax, eax
  0003e	74 13		 je	 SHORT $LN7@sr_read_sk
  00040	8b 94 24 68 01
	00 00		 mov	 edx, DWORD PTR len$[rsp]
  00047	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG168307
  0004e	e8 00 00 00 00	 call	 DebuggerTrace
$LN7@sr_read_sk:
  00053	33 c0		 xor	 eax, eax
  00055	85 c0		 test	 eax, eax
  00057	75 c9		 jne	 SHORT $LN4@sr_read_sk

; 686  : 
; 687  :     tot = len;

  00059	8b 84 24 68 01
	00 00		 mov	 eax, DWORD PTR len$[rsp]
  00060	48 89 44 24 20	 mov	 QWORD PTR tot$[rsp], rax
$LN5@sr_read_sk:

; 688  : 
; 689  :     while (tot)

  00065	48 83 7c 24 20
	00		 cmp	 QWORD PTR tot$[rsp], 0
  0006b	74 71		 je	 SHORT $LN6@sr_read_sk

; 690  :     {
; 691  :         siz = tot < SR_SKIP_CHUNKSIZE ? tot : SR_SKIP_CHUNKSIZE;

  0006d	48 81 7c 24 20
	00 01 00 00	 cmp	 QWORD PTR tot$[rsp], 256 ; 00000100H
  00076	73 0c		 jae	 SHORT $LN10@sr_read_sk
  00078	48 8b 44 24 20	 mov	 rax, QWORD PTR tot$[rsp]
  0007d	48 89 44 24 30	 mov	 QWORD PTR tv74[rsp], rax
  00082	eb 09		 jmp	 SHORT $LN11@sr_read_sk
$LN10@sr_read_sk:
  00084	48 c7 44 24 30
	00 01 00 00	 mov	 QWORD PTR tv74[rsp], 256 ; 00000100H
$LN11@sr_read_sk:
  0008d	48 8b 44 24 30	 mov	 rax, QWORD PTR tv74[rsp]
  00092	48 89 44 24 28	 mov	 QWORD PTR siz$[rsp], rax

; 692  : 
; 693  :         if ((size_t)SR_READ(buf, 1, siz, file) != siz)

  00097	4c 8b 8c 24 60
	01 00 00	 mov	 r9, QWORD PTR file$[rsp]
  0009f	4c 8b 44 24 28	 mov	 r8, QWORD PTR siz$[rsp]
  000a4	ba 01 00 00 00	 mov	 edx, 1
  000a9	48 8d 4c 24 40	 lea	 rcx, QWORD PTR buf$[rsp]
  000ae	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fread
  000b4	48 3b 44 24 28	 cmp	 rax, QWORD PTR siz$[rsp]
  000b9	74 0c		 je	 SHORT $LN8@sr_read_sk

; 694  :         {
; 695  :             sr_read_error_();

  000bb	e8 00 00 00 00	 call	 sr_read_error_

; 696  :             return -1;

  000c0	b8 ff ff ff ff	 mov	 eax, -1
  000c5	eb 19		 jmp	 SHORT $LN1@sr_read_sk
$LN8@sr_read_sk:

; 697  :         }
; 698  :         tot -= siz;

  000c7	48 8b 44 24 28	 mov	 rax, QWORD PTR siz$[rsp]
  000cc	48 8b 4c 24 20	 mov	 rcx, QWORD PTR tot$[rsp]
  000d1	48 2b c8	 sub	 rcx, rax
  000d4	48 8b c1	 mov	 rax, rcx
  000d7	48 89 44 24 20	 mov	 QWORD PTR tot$[rsp], rax

; 699  :     }

  000dc	eb 87		 jmp	 SHORT $LN5@sr_read_sk
$LN6@sr_read_sk:

; 700  :     return 0;

  000de	33 c0		 xor	 eax, eax
$LN1@sr_read_sk:

; 701  : }

  000e0	48 8b 8c 24 40
	01 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  000e8	48 33 cc	 xor	 rcx, rsp
  000eb	e8 00 00 00 00	 call	 __security_check_cookie
  000f0	48 81 c4 58 01
	00 00		 add	 rsp, 344		; 00000158H
  000f7	c3		 ret	 0
sr_read_skip ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\sr.h
_TEXT	SEGMENT
value$ = 32
tv85 = 40
tv146 = 44
ptr$1 = 48
ptr$2 = 56
ptr$3 = 64
ptr$4 = 72
buf$ = 80
__$ArrayPad$ = 88
file$ = 112
suslen$ = 120
p$ = 128
reslen$ = 136
sr_read_value PROC

; 754  : {

  00000	44 89 4c 24 20	 mov	 DWORD PTR [rsp+32], r9d
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  0000e	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00013	48 83 ec 68	 sub	 rsp, 104		; 00000068H
  00017	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  0001e	48 33 c4	 xor	 rax, rsp
  00021	48 89 44 24 58	 mov	 QWORD PTR __$ArrayPad$[rsp], rax
$LN4@sr_read_va:

; 755  : BYTE    buf[8];
; 756  : U64     value;
; 757  : 
; 758  :     TRACE("SR: sr_read_value:              suslen=0x%8.8x, reslen=0x%8.8x,\n", suslen, reslen);

  00026	44 8b 84 24 88
	00 00 00	 mov	 r8d, DWORD PTR reslen$[rsp]
  0002e	8b 54 24 78	 mov	 edx, DWORD PTR suslen$[rsp]
  00032	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG168375
  00039	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_logmsg
  0003f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_IsDebuggerPresent
  00045	85 c0		 test	 eax, eax
  00047	74 18		 je	 SHORT $LN12@sr_read_va
  00049	44 8b 84 24 88
	00 00 00	 mov	 r8d, DWORD PTR reslen$[rsp]
  00051	8b 54 24 78	 mov	 edx, DWORD PTR suslen$[rsp]
  00055	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG168377
  0005c	e8 00 00 00 00	 call	 DebuggerTrace
$LN12@sr_read_va:
  00061	33 c0		 xor	 eax, eax
  00063	85 c0		 test	 eax, eax
  00065	75 bf		 jne	 SHORT $LN4@sr_read_va

; 759  : 
; 760  :     if (suslen != 1 && suslen != 2 && suslen != 4 && suslen != 8)

  00067	83 7c 24 78 01	 cmp	 DWORD PTR suslen$[rsp], 1
  0006c	74 24		 je	 SHORT $LN13@sr_read_va
  0006e	83 7c 24 78 02	 cmp	 DWORD PTR suslen$[rsp], 2
  00073	74 1d		 je	 SHORT $LN13@sr_read_va
  00075	83 7c 24 78 04	 cmp	 DWORD PTR suslen$[rsp], 4
  0007a	74 16		 je	 SHORT $LN13@sr_read_va
  0007c	83 7c 24 78 08	 cmp	 DWORD PTR suslen$[rsp], 8
  00081	74 0f		 je	 SHORT $LN13@sr_read_va

; 761  :     {
; 762  :         sr_value_error_();

  00083	e8 00 00 00 00	 call	 sr_value_error_

; 763  :         return -1;

  00088	b8 ff ff ff ff	 mov	 eax, -1
  0008d	e9 a8 01 00 00	 jmp	 $LN1@sr_read_va
$LN13@sr_read_va:

; 764  :     }
; 765  : 
; 766  :     if ((U32)SR_READ(buf, 1, suslen, file) != suslen)

  00092	8b 44 24 78	 mov	 eax, DWORD PTR suslen$[rsp]
  00096	4c 8b 4c 24 70	 mov	 r9, QWORD PTR file$[rsp]
  0009b	44 8b c0	 mov	 r8d, eax
  0009e	ba 01 00 00 00	 mov	 edx, 1
  000a3	48 8d 4c 24 50	 lea	 rcx, QWORD PTR buf$[rsp]
  000a8	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fread
  000ae	3b 44 24 78	 cmp	 eax, DWORD PTR suslen$[rsp]
  000b2	74 0f		 je	 SHORT $LN14@sr_read_va

; 767  :     {
; 768  :         sr_read_error_();

  000b4	e8 00 00 00 00	 call	 sr_read_error_

; 769  :         return -1;

  000b9	b8 ff ff ff ff	 mov	 eax, -1
  000be	e9 77 01 00 00	 jmp	 $LN1@sr_read_va
$LN14@sr_read_va:

; 770  :     }
; 771  : 
; 772  :     switch (suslen)

  000c3	8b 44 24 78	 mov	 eax, DWORD PTR suslen$[rsp]
  000c7	89 44 24 28	 mov	 DWORD PTR tv85[rsp], eax
  000cb	83 7c 24 28 01	 cmp	 DWORD PTR tv85[rsp], 1
  000d0	74 17		 je	 SHORT $LN15@sr_read_va
  000d2	83 7c 24 28 02	 cmp	 DWORD PTR tv85[rsp], 2
  000d7	74 25		 je	 SHORT $LN16@sr_read_va
  000d9	83 7c 24 28 04	 cmp	 DWORD PTR tv85[rsp], 4
  000de	74 3a		 je	 SHORT $LN17@sr_read_va
  000e0	83 7c 24 28 08	 cmp	 DWORD PTR tv85[rsp], 8
  000e5	74 4d		 je	 SHORT $LN18@sr_read_va
  000e7	eb 64		 jmp	 SHORT $LN19@sr_read_va
$LN15@sr_read_va:

; 773  :     {
; 774  :         case 1:  value = buf[0];         break;

  000e9	b8 01 00 00 00	 mov	 eax, 1
  000ee	48 6b c0 00	 imul	 rax, rax, 0
  000f2	0f b6 44 04 50	 movzx	 eax, BYTE PTR buf$[rsp+rax]
  000f7	48 89 44 24 20	 mov	 QWORD PTR value$[rsp], rax
  000fc	eb 58		 jmp	 SHORT $LN5@sr_read_va
$LN16@sr_read_va:

; 775  :         case 2:  value = fetch_hw (buf); break;

  000fe	48 8d 4c 24 50	 lea	 rcx, QWORD PTR buf$[rsp]
  00103	e8 00 00 00 00	 call	 fetch_hw_noswap
  00108	0f b7 c8	 movzx	 ecx, ax
  0010b	e8 00 00 00 00	 call	 _byteswap_ushort
  00110	0f b7 c0	 movzx	 eax, ax
  00113	48 89 44 24 20	 mov	 QWORD PTR value$[rsp], rax
  00118	eb 3c		 jmp	 SHORT $LN5@sr_read_va
$LN17@sr_read_va:

; 776  :         case 4:  value = fetch_fw (buf); break;

  0011a	48 8d 4c 24 50	 lea	 rcx, QWORD PTR buf$[rsp]
  0011f	e8 00 00 00 00	 call	 fetch_fw_noswap
  00124	8b c8		 mov	 ecx, eax
  00126	e8 00 00 00 00	 call	 _byteswap_ulong
  0012b	8b c0		 mov	 eax, eax
  0012d	48 89 44 24 20	 mov	 QWORD PTR value$[rsp], rax
  00132	eb 22		 jmp	 SHORT $LN5@sr_read_va
$LN18@sr_read_va:

; 777  :         case 8:  value = fetch_dw (buf); break;

  00134	48 8d 4c 24 50	 lea	 rcx, QWORD PTR buf$[rsp]
  00139	e8 00 00 00 00	 call	 fetch_dw_noswap
  0013e	48 8b c8	 mov	 rcx, rax
  00141	e8 00 00 00 00	 call	 _byteswap_uint64
  00146	48 89 44 24 20	 mov	 QWORD PTR value$[rsp], rax
  0014b	eb 09		 jmp	 SHORT $LN5@sr_read_va
$LN19@sr_read_va:

; 778  :         default: value = 0;              break; /* To ward off gcc -Wall */

  0014d	48 c7 44 24 20
	00 00 00 00	 mov	 QWORD PTR value$[rsp], 0
$LN5@sr_read_va:
$LN9@sr_read_va:

; 779  :     }
; 780  : 
; 781  :     TRACE("                           val=0x%16.16"PRIx64"\n", value);

  00156	48 8b 54 24 20	 mov	 rdx, QWORD PTR value$[rsp]
  0015b	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG168385
  00162	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_logmsg
  00168	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_IsDebuggerPresent
  0016e	85 c0		 test	 eax, eax
  00170	74 11		 je	 SHORT $LN20@sr_read_va
  00172	48 8b 54 24 20	 mov	 rdx, QWORD PTR value$[rsp]
  00177	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG168387
  0017e	e8 00 00 00 00	 call	 DebuggerTrace
$LN20@sr_read_va:
  00183	33 c0		 xor	 eax, eax
  00185	85 c0		 test	 eax, eax
  00187	75 cd		 jne	 SHORT $LN9@sr_read_va

; 782  : 
; 783  :     switch (reslen)

  00189	8b 84 24 88 00
	00 00		 mov	 eax, DWORD PTR reslen$[rsp]
  00190	89 44 24 2c	 mov	 DWORD PTR tv146[rsp], eax
  00194	83 7c 24 2c 01	 cmp	 DWORD PTR tv146[rsp], 1
  00199	74 1a		 je	 SHORT $LN21@sr_read_va
  0019b	83 7c 24 2c 02	 cmp	 DWORD PTR tv146[rsp], 2
  001a0	74 34		 je	 SHORT $LN22@sr_read_va
  001a2	83 7c 24 2c 04	 cmp	 DWORD PTR tv146[rsp], 4
  001a7	74 4f		 je	 SHORT $LN23@sr_read_va
  001a9	83 7c 24 2c 08	 cmp	 DWORD PTR tv146[rsp], 8
  001ae	74 6e		 je	 SHORT $LN24@sr_read_va
  001b0	e9 83 00 00 00	 jmp	 $LN10@sr_read_va
$LN21@sr_read_va:

; 784  :     {
; 785  :         case 1:
; 786  :         {
; 787  :             BYTE* ptr = p;

  001b5	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR p$[rsp]
  001bd	48 89 44 24 30	 mov	 QWORD PTR ptr$1[rsp], rax

; 788  :             *ptr = (BYTE)(value & 0xFF);

  001c2	48 8b 44 24 20	 mov	 rax, QWORD PTR value$[rsp]
  001c7	48 25 ff 00 00
	00		 and	 rax, 255		; 000000ffH
  001cd	48 8b 4c 24 30	 mov	 rcx, QWORD PTR ptr$1[rsp]
  001d2	88 01		 mov	 BYTE PTR [rcx], al

; 789  :             break;

  001d4	eb 62		 jmp	 SHORT $LN10@sr_read_va
$LN22@sr_read_va:

; 790  :         }
; 791  :         case 2:
; 792  :         {
; 793  :             U16* ptr = p;

  001d6	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR p$[rsp]
  001de	48 89 44 24 38	 mov	 QWORD PTR ptr$2[rsp], rax

; 794  :             *ptr = (U16)(value & 0xFFFF);

  001e3	48 8b 44 24 20	 mov	 rax, QWORD PTR value$[rsp]
  001e8	48 25 ff ff 00
	00		 and	 rax, 65535		; 0000ffffH
  001ee	48 8b 4c 24 38	 mov	 rcx, QWORD PTR ptr$2[rsp]
  001f3	66 89 01	 mov	 WORD PTR [rcx], ax

; 795  :             break;

  001f6	eb 40		 jmp	 SHORT $LN10@sr_read_va
$LN23@sr_read_va:

; 796  :         }
; 797  :         case 4:
; 798  :         {
; 799  :             U32* ptr = p;

  001f8	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR p$[rsp]
  00200	48 89 44 24 40	 mov	 QWORD PTR ptr$3[rsp], rax

; 800  :             *ptr = (U32)(value & 0xFFFFFFFF);

  00205	b8 ff ff ff ff	 mov	 eax, -1			; ffffffffH
  0020a	48 8b 4c 24 20	 mov	 rcx, QWORD PTR value$[rsp]
  0020f	48 23 c8	 and	 rcx, rax
  00212	48 8b c1	 mov	 rax, rcx
  00215	48 8b 4c 24 40	 mov	 rcx, QWORD PTR ptr$3[rsp]
  0021a	89 01		 mov	 DWORD PTR [rcx], eax

; 801  :             break;

  0021c	eb 1a		 jmp	 SHORT $LN10@sr_read_va
$LN24@sr_read_va:

; 802  :         }
; 803  :         case 8:
; 804  :         {
; 805  :             U64* ptr = p;

  0021e	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR p$[rsp]
  00226	48 89 44 24 48	 mov	 QWORD PTR ptr$4[rsp], rax

; 806  :             *ptr = (U64)(value & 0xFFFFFFFFFFFFFFFFULL);

  0022b	48 8b 44 24 48	 mov	 rax, QWORD PTR ptr$4[rsp]
  00230	48 8b 4c 24 20	 mov	 rcx, QWORD PTR value$[rsp]
  00235	48 89 08	 mov	 QWORD PTR [rax], rcx
$LN10@sr_read_va:

; 807  :             break;
; 808  :         }
; 809  :     }
; 810  :     return 0;

  00238	33 c0		 xor	 eax, eax
$LN1@sr_read_va:

; 811  : }

  0023a	48 8b 4c 24 58	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  0023f	48 33 cc	 xor	 rcx, rsp
  00242	e8 00 00 00 00	 call	 __security_check_cookie
  00247	48 83 c4 68	 add	 rsp, 104		; 00000068H
  0024b	c3		 ret	 0
sr_read_value ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\sr.h
_TEXT	SEGMENT
buf$ = 32
__$ArrayPad$ = 40
file$ = 64
key$ = 72
len$ = 80
sr_read_hdr PROC

; 656  : {

  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	48 83 ec 38	 sub	 rsp, 56			; 00000038H
  00013	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  0001a	48 33 c4	 xor	 rax, rsp
  0001d	48 89 44 24 28	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 657  : BYTE  buf[8];
; 658  : 
; 659  :     if (SR_READ(buf, 1, 8, file) != 8)

  00022	4c 8b 4c 24 40	 mov	 r9, QWORD PTR file$[rsp]
  00027	41 b8 08 00 00
	00		 mov	 r8d, 8
  0002d	ba 01 00 00 00	 mov	 edx, 1
  00032	48 8d 4c 24 20	 lea	 rcx, QWORD PTR buf$[rsp]
  00037	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fread
  0003d	48 83 f8 08	 cmp	 rax, 8
  00041	74 0c		 je	 SHORT $LN5@sr_read_hd

; 660  :     {
; 661  :         sr_read_error_();

  00043	e8 00 00 00 00	 call	 sr_read_error_

; 662  :         return -1;

  00048	b8 ff ff ff ff	 mov	 eax, -1
  0004d	eb 7c		 jmp	 SHORT $LN1@sr_read_hd
$LN5@sr_read_hd:

; 663  :     }
; 664  : 
; 665  :     *key = fetch_fw (buf);

  0004f	48 8d 4c 24 20	 lea	 rcx, QWORD PTR buf$[rsp]
  00054	e8 00 00 00 00	 call	 fetch_fw_noswap
  00059	8b c8		 mov	 ecx, eax
  0005b	e8 00 00 00 00	 call	 _byteswap_ulong
  00060	48 8b 4c 24 48	 mov	 rcx, QWORD PTR key$[rsp]
  00065	89 01		 mov	 DWORD PTR [rcx], eax

; 666  :     *len = fetch_fw (buf+4);

  00067	48 8d 44 24 24	 lea	 rax, QWORD PTR buf$[rsp+4]
  0006c	48 8b c8	 mov	 rcx, rax
  0006f	e8 00 00 00 00	 call	 fetch_fw_noswap
  00074	8b c8		 mov	 ecx, eax
  00076	e8 00 00 00 00	 call	 _byteswap_ulong
  0007b	48 8b 4c 24 50	 mov	 rcx, QWORD PTR len$[rsp]
  00080	89 01		 mov	 DWORD PTR [rcx], eax
$LN4@sr_read_hd:

; 667  : 
; 668  :     TRACE("SR: sr_read_hdr:   key=0x%8.8x, len=0x%8.8x\n", *key, *len);

  00082	48 8b 44 24 50	 mov	 rax, QWORD PTR len$[rsp]
  00087	44 8b 00	 mov	 r8d, DWORD PTR [rax]
  0008a	48 8b 44 24 48	 mov	 rax, QWORD PTR key$[rsp]
  0008f	8b 10		 mov	 edx, DWORD PTR [rax]
  00091	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG168288
  00098	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_logmsg
  0009e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_IsDebuggerPresent
  000a4	85 c0		 test	 eax, eax
  000a6	74 1b		 je	 SHORT $LN6@sr_read_hd
  000a8	48 8b 44 24 50	 mov	 rax, QWORD PTR len$[rsp]
  000ad	44 8b 00	 mov	 r8d, DWORD PTR [rax]
  000b0	48 8b 44 24 48	 mov	 rax, QWORD PTR key$[rsp]
  000b5	8b 10		 mov	 edx, DWORD PTR [rax]
  000b7	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG168290
  000be	e8 00 00 00 00	 call	 DebuggerTrace
$LN6@sr_read_hd:
  000c3	33 c0		 xor	 eax, eax
  000c5	85 c0		 test	 eax, eax
  000c7	75 b9		 jne	 SHORT $LN4@sr_read_hd

; 669  : 
; 670  :     return 0;

  000c9	33 c0		 xor	 eax, eax
$LN1@sr_read_hd:

; 671  : }

  000cb	48 8b 4c 24 28	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  000d0	48 33 cc	 xor	 rcx, rsp
  000d3	e8 00 00 00 00	 call	 __security_check_cookie
  000d8	48 83 c4 38	 add	 rsp, 56			; 00000038H
  000dc	c3		 ret	 0
sr_read_hdr ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\sr.h
_TEXT	SEGMENT
tv84 = 32
buf$ = 40
__$ArrayPad$ = 48
file$ = 80
key$ = 88
val$ = 96
len$ = 104
sr_write_value PROC

; 622  : {

  00000	44 89 4c 24 20	 mov	 DWORD PTR [rsp+32], r9d
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  0000e	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00013	48 83 ec 48	 sub	 rsp, 72			; 00000048H
  00017	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  0001e	48 33 c4	 xor	 rax, rsp
  00021	48 89 44 24 30	 mov	 QWORD PTR __$ArrayPad$[rsp], rax
$LN4@sr_write_v:

; 623  : BYTE    buf[8];
; 624  : 
; 625  :     TRACE("SR: sr_write_value:  key=0x%8.8x, len=0x%8.8x, val=0x%16.16"PRIx64"\n", key, len, val);

  00026	4c 8b 4c 24 60	 mov	 r9, QWORD PTR val$[rsp]
  0002b	44 8b 44 24 68	 mov	 r8d, DWORD PTR len$[rsp]
  00030	8b 54 24 58	 mov	 edx, DWORD PTR key$[rsp]
  00034	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG168266
  0003b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_logmsg
  00041	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_IsDebuggerPresent
  00047	85 c0		 test	 eax, eax
  00049	74 1a		 je	 SHORT $LN7@sr_write_v
  0004b	4c 8b 4c 24 60	 mov	 r9, QWORD PTR val$[rsp]
  00050	44 8b 44 24 68	 mov	 r8d, DWORD PTR len$[rsp]
  00055	8b 54 24 58	 mov	 edx, DWORD PTR key$[rsp]
  00059	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG168268
  00060	e8 00 00 00 00	 call	 DebuggerTrace
$LN7@sr_write_v:
  00065	33 c0		 xor	 eax, eax
  00067	85 c0		 test	 eax, eax
  00069	75 bb		 jne	 SHORT $LN4@sr_write_v

; 626  : 
; 627  :     if (len != 1 && len != 2 && len != 4 && len != 8)

  0006b	83 7c 24 68 01	 cmp	 DWORD PTR len$[rsp], 1
  00070	74 24		 je	 SHORT $LN8@sr_write_v
  00072	83 7c 24 68 02	 cmp	 DWORD PTR len$[rsp], 2
  00077	74 1d		 je	 SHORT $LN8@sr_write_v
  00079	83 7c 24 68 04	 cmp	 DWORD PTR len$[rsp], 4
  0007e	74 16		 je	 SHORT $LN8@sr_write_v
  00080	83 7c 24 68 08	 cmp	 DWORD PTR len$[rsp], 8
  00085	74 0f		 je	 SHORT $LN8@sr_write_v

; 628  :     {
; 629  :         sr_value_error_();

  00087	e8 00 00 00 00	 call	 sr_value_error_

; 630  :         return -1;

  0008c	b8 ff ff ff ff	 mov	 eax, -1
  00091	e9 d2 00 00 00	 jmp	 $LN1@sr_write_v
$LN8@sr_write_v:

; 631  :     }
; 632  : 
; 633  :     if (sr_write_hdr(file, key, len) != 0)

  00096	44 8b 44 24 68	 mov	 r8d, DWORD PTR len$[rsp]
  0009b	8b 54 24 58	 mov	 edx, DWORD PTR key$[rsp]
  0009f	48 8b 4c 24 50	 mov	 rcx, QWORD PTR file$[rsp]
  000a4	e8 00 00 00 00	 call	 sr_write_hdr
  000a9	85 c0		 test	 eax, eax
  000ab	74 0a		 je	 SHORT $LN9@sr_write_v

; 634  :         return -1;

  000ad	b8 ff ff ff ff	 mov	 eax, -1
  000b2	e9 b1 00 00 00	 jmp	 $LN1@sr_write_v
$LN9@sr_write_v:

; 635  : 
; 636  :     switch (len)

  000b7	8b 44 24 68	 mov	 eax, DWORD PTR len$[rsp]
  000bb	89 44 24 20	 mov	 DWORD PTR tv84[rsp], eax
  000bf	83 7c 24 20 01	 cmp	 DWORD PTR tv84[rsp], 1
  000c4	74 17		 je	 SHORT $LN10@sr_write_v
  000c6	83 7c 24 20 02	 cmp	 DWORD PTR tv84[rsp], 2
  000cb	74 24		 je	 SHORT $LN11@sr_write_v
  000cd	83 7c 24 20 04	 cmp	 DWORD PTR tv84[rsp], 4
  000d2	74 36		 je	 SHORT $LN12@sr_write_v
  000d4	83 7c 24 20 08	 cmp	 DWORD PTR tv84[rsp], 8
  000d9	74 46		 je	 SHORT $LN13@sr_write_v
  000db	eb 5b		 jmp	 SHORT $LN5@sr_write_v
$LN10@sr_write_v:

; 637  :     {
; 638  :         case 1: buf[0]     =  (BYTE)val;  break;

  000dd	b8 01 00 00 00	 mov	 eax, 1
  000e2	48 6b c0 00	 imul	 rax, rax, 0
  000e6	0f b6 4c 24 60	 movzx	 ecx, BYTE PTR val$[rsp]
  000eb	88 4c 04 28	 mov	 BYTE PTR buf$[rsp+rax], cl
  000ef	eb 47		 jmp	 SHORT $LN5@sr_write_v
$LN11@sr_write_v:

; 639  :         case 2: store_hw (buf, (U16)val); break;

  000f1	0f b7 4c 24 60	 movzx	 ecx, WORD PTR val$[rsp]
  000f6	e8 00 00 00 00	 call	 _byteswap_ushort
  000fb	0f b7 d0	 movzx	 edx, ax
  000fe	48 8d 4c 24 28	 lea	 rcx, QWORD PTR buf$[rsp]
  00103	e8 00 00 00 00	 call	 store_hw_noswap
  00108	eb 2e		 jmp	 SHORT $LN5@sr_write_v
$LN12@sr_write_v:

; 640  :         case 4: store_fw (buf, (U32)val); break;

  0010a	8b 4c 24 60	 mov	 ecx, DWORD PTR val$[rsp]
  0010e	e8 00 00 00 00	 call	 _byteswap_ulong
  00113	8b d0		 mov	 edx, eax
  00115	48 8d 4c 24 28	 lea	 rcx, QWORD PTR buf$[rsp]
  0011a	e8 00 00 00 00	 call	 store_fw_noswap
  0011f	eb 17		 jmp	 SHORT $LN5@sr_write_v
$LN13@sr_write_v:

; 641  :         case 8: store_dw (buf, (U64)val); break;

  00121	48 8b 4c 24 60	 mov	 rcx, QWORD PTR val$[rsp]
  00126	e8 00 00 00 00	 call	 _byteswap_uint64
  0012b	48 8b d0	 mov	 rdx, rax
  0012e	48 8d 4c 24 28	 lea	 rcx, QWORD PTR buf$[rsp]
  00133	e8 00 00 00 00	 call	 store_dw_noswap
$LN5@sr_write_v:

; 642  :     }
; 643  : 
; 644  :     if ((U32)SR_WRITE(buf, 1, len, file) != len)

  00138	8b 44 24 68	 mov	 eax, DWORD PTR len$[rsp]
  0013c	4c 8b 4c 24 50	 mov	 r9, QWORD PTR file$[rsp]
  00141	44 8b c0	 mov	 r8d, eax
  00144	ba 01 00 00 00	 mov	 edx, 1
  00149	48 8d 4c 24 28	 lea	 rcx, QWORD PTR buf$[rsp]
  0014e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_fwrite
  00154	3b 44 24 68	 cmp	 eax, DWORD PTR len$[rsp]
  00158	74 0c		 je	 SHORT $LN14@sr_write_v

; 645  :     {
; 646  :         sr_write_error_();

  0015a	e8 00 00 00 00	 call	 sr_write_error_

; 647  :         return -1;

  0015f	b8 ff ff ff ff	 mov	 eax, -1
  00164	eb 02		 jmp	 SHORT $LN1@sr_write_v
$LN14@sr_write_v:

; 648  :     }
; 649  :     return 0;

  00166	33 c0		 xor	 eax, eax
$LN1@sr_write_v:

; 650  : }

  00168	48 8b 4c 24 30	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  0016d	48 33 cc	 xor	 rcx, rsp
  00170	e8 00 00 00 00	 call	 __security_check_cookie
  00175	48 83 c4 48	 add	 rsp, 72			; 00000048H
  00179	c3		 ret	 0
sr_write_value ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\sr.h
_TEXT	SEGMENT
buf$ = 32
__$ArrayPad$ = 40
file$ = 64
key$ = 72
len$ = 80
sr_write_hdr PROC

; 546  : {

  00000	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  00005	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00009	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000e	48 83 ec 38	 sub	 rsp, 56			; 00000038H
  00012	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00019	48 33 c4	 xor	 rax, rsp
  0001c	48 89 44 24 28	 mov	 QWORD PTR __$ArrayPad$[rsp], rax
$LN4@sr_write_h:

; 547  : BYTE  buf[8];
; 548  : 
; 549  :     TRACE("SR: sr_write_hdr:    key=0x%8.8x, len=0x%8.8x\n", key, len);

  00021	44 8b 44 24 50	 mov	 r8d, DWORD PTR len$[rsp]
  00026	8b 54 24 48	 mov	 edx, DWORD PTR key$[rsp]
  0002a	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG168200
  00031	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_logmsg
  00037	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_IsDebuggerPresent
  0003d	85 c0		 test	 eax, eax
  0003f	74 15		 je	 SHORT $LN5@sr_write_h
  00041	44 8b 44 24 50	 mov	 r8d, DWORD PTR len$[rsp]
  00046	8b 54 24 48	 mov	 edx, DWORD PTR key$[rsp]
  0004a	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG168202
  00051	e8 00 00 00 00	 call	 DebuggerTrace
$LN5@sr_write_h:
  00056	33 c0		 xor	 eax, eax
  00058	85 c0		 test	 eax, eax
  0005a	75 c5		 jne	 SHORT $LN4@sr_write_h

; 550  : 
; 551  :     store_fw (buf, key);

  0005c	8b 4c 24 48	 mov	 ecx, DWORD PTR key$[rsp]
  00060	e8 00 00 00 00	 call	 _byteswap_ulong
  00065	8b d0		 mov	 edx, eax
  00067	48 8d 4c 24 20	 lea	 rcx, QWORD PTR buf$[rsp]
  0006c	e8 00 00 00 00	 call	 store_fw_noswap

; 552  :     store_fw (buf+4, len);

  00071	8b 4c 24 50	 mov	 ecx, DWORD PTR len$[rsp]
  00075	e8 00 00 00 00	 call	 _byteswap_ulong
  0007a	48 8d 4c 24 24	 lea	 rcx, QWORD PTR buf$[rsp+4]
  0007f	8b d0		 mov	 edx, eax
  00081	e8 00 00 00 00	 call	 store_fw_noswap

; 553  : 
; 554  :     if (SR_WRITE(buf, 1, 8, file) != 8)

  00086	4c 8b 4c 24 40	 mov	 r9, QWORD PTR file$[rsp]
  0008b	41 b8 08 00 00
	00		 mov	 r8d, 8
  00091	ba 01 00 00 00	 mov	 edx, 1
  00096	48 8d 4c 24 20	 lea	 rcx, QWORD PTR buf$[rsp]
  0009b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_fwrite
  000a1	48 83 f8 08	 cmp	 rax, 8
  000a5	74 0c		 je	 SHORT $LN6@sr_write_h

; 555  :     {
; 556  :         sr_write_error_();

  000a7	e8 00 00 00 00	 call	 sr_write_error_

; 557  :         return -1;

  000ac	b8 ff ff ff ff	 mov	 eax, -1
  000b1	eb 02		 jmp	 SHORT $LN1@sr_write_h
$LN6@sr_write_h:

; 558  :     }
; 559  :     return 0;

  000b3	33 c0		 xor	 eax, eax
$LN1@sr_write_h:

; 560  : }

  000b5	48 8b 4c 24 28	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  000ba	48 33 cc	 xor	 rcx, rsp
  000bd	e8 00 00 00 00	 call	 __security_check_cookie
  000c2	48 83 c4 38	 add	 rsp, 56			; 00000038H
  000c6	c3		 ret	 0
sr_write_hdr ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\ckddasd.c
_TEXT	SEGMENT
byte$ = 32
rc$ = 36
tv89 = 40
k$1 = 44
l$2 = 48
len$ = 56
tv72 = 64
key$ = 72
dev$ = 96
file$ = 104
ckd_dasd_hresume PROC

; 1253 : {

$LN217:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 58	 sub	 rsp, 88			; 00000058H
$LN4@ckd_dasd_h:
$LN7@ckd_dasd_h:

; 1254 : u_int   rc;
; 1255 : size_t  key, len;
; 1256 : BYTE byte;
; 1257 : 
; 1258 :     do {
; 1259 :         SR_READ_HDR(file, key, len);

  0000e	4c 8d 44 24 30	 lea	 r8, QWORD PTR l$2[rsp]
  00013	48 8d 54 24 2c	 lea	 rdx, QWORD PTR k$1[rsp]
  00018	48 8b 4c 24 68	 mov	 rcx, QWORD PTR file$[rsp]
  0001d	e8 00 00 00 00	 call	 sr_read_hdr
  00022	85 c0		 test	 eax, eax
  00024	74 0a		 je	 SHORT $LN130@ckd_dasd_h
  00026	b8 ff ff ff ff	 mov	 eax, -1
  0002b	e9 e9 0b 00 00	 jmp	 $LN1@ckd_dasd_h
$LN130@ckd_dasd_h:
  00030	8b 44 24 2c	 mov	 eax, DWORD PTR k$1[rsp]
  00034	48 89 44 24 48	 mov	 QWORD PTR key$[rsp], rax
  00039	8b 44 24 30	 mov	 eax, DWORD PTR l$2[rsp]
  0003d	48 89 44 24 38	 mov	 QWORD PTR len$[rsp], rax
  00042	33 c0		 xor	 eax, eax
  00044	85 c0		 test	 eax, eax
  00046	75 c6		 jne	 SHORT $LN7@ckd_dasd_h

; 1260 :         switch (key) {

  00048	48 8b 44 24 48	 mov	 rax, QWORD PTR key$[rsp]
  0004d	48 89 44 24 40	 mov	 QWORD PTR tv72[rsp], rax
  00052	b8 01 10 e3 ac	 mov	 eax, -1394405375	; ace31001H
  00057	48 8b 4c 24 40	 mov	 rcx, QWORD PTR tv72[rsp]
  0005c	48 2b c8	 sub	 rcx, rax
  0005f	48 8b c1	 mov	 rax, rcx
  00062	48 89 44 24 40	 mov	 QWORD PTR tv72[rsp], rax
  00067	48 83 7c 24 40
	4f		 cmp	 QWORD PTR tv72[rsp], 79	; 0000004fH
  0006d	0f 87 67 0b 00
	00		 ja	 $LN210@ckd_dasd_h
  00073	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:__ImageBase
  0007a	48 8b 4c 24 40	 mov	 rcx, QWORD PTR tv72[rsp]
  0007f	0f b6 8c 08 00
	00 00 00	 movzx	 ecx, BYTE PTR $LN215@ckd_dasd_h[rax+rcx]
  00087	8b 8c 88 00 00
	00 00		 mov	 ecx, DWORD PTR $LN216@ckd_dasd_h[rax+rcx*4]
  0008e	48 03 c8	 add	 rcx, rax
  00091	ff e1		 jmp	 rcx
$LN131@ckd_dasd_h:
$LN12@ckd_dasd_h:

; 1261 :         case SR_DEV_CKD_BUFCUR:
; 1262 :             SR_READ_VALUE(file, len, &rc, sizeof(rc));

  00093	41 b9 04 00 00
	00		 mov	 r9d, 4
  00099	4c 8d 44 24 24	 lea	 r8, QWORD PTR rc$[rsp]
  0009e	8b 54 24 38	 mov	 edx, DWORD PTR len$[rsp]
  000a2	48 8b 4c 24 68	 mov	 rcx, QWORD PTR file$[rsp]
  000a7	e8 00 00 00 00	 call	 sr_read_value
  000ac	85 c0		 test	 eax, eax
  000ae	74 0a		 je	 SHORT $LN132@ckd_dasd_h
  000b0	b8 ff ff ff ff	 mov	 eax, -1
  000b5	e9 5f 0b 00 00	 jmp	 $LN1@ckd_dasd_h
$LN132@ckd_dasd_h:
  000ba	33 c0		 xor	 eax, eax
  000bc	85 c0		 test	 eax, eax
  000be	75 d3		 jne	 SHORT $LN12@ckd_dasd_h

; 1263 :             rc = (dev->hnd->read) ? (dev->hnd->read)(dev, rc, &byte) : -1;

  000c0	48 8b 44 24 60	 mov	 rax, QWORD PTR dev$[rsp]
  000c5	48 8b 80 90 02
	00 00		 mov	 rax, QWORD PTR [rax+656]
  000cc	48 83 78 50 00	 cmp	 QWORD PTR [rax+80], 0
  000d1	74 23		 je	 SHORT $LN213@ckd_dasd_h
  000d3	48 8b 44 24 60	 mov	 rax, QWORD PTR dev$[rsp]
  000d8	48 8b 80 90 02
	00 00		 mov	 rax, QWORD PTR [rax+656]
  000df	4c 8d 44 24 20	 lea	 r8, QWORD PTR byte$[rsp]
  000e4	8b 54 24 24	 mov	 edx, DWORD PTR rc$[rsp]
  000e8	48 8b 4c 24 60	 mov	 rcx, QWORD PTR dev$[rsp]
  000ed	ff 50 50	 call	 QWORD PTR [rax+80]
  000f0	89 44 24 28	 mov	 DWORD PTR tv89[rsp], eax
  000f4	eb 08		 jmp	 SHORT $LN214@ckd_dasd_h
$LN213@ckd_dasd_h:
  000f6	c7 44 24 28 ff
	ff ff ff	 mov	 DWORD PTR tv89[rsp], -1
$LN214@ckd_dasd_h:
  000fe	8b 44 24 28	 mov	 eax, DWORD PTR tv89[rsp]
  00102	89 44 24 24	 mov	 DWORD PTR rc$[rsp], eax

; 1264 :             if ((int)rc < 0) return -1;

  00106	83 7c 24 24 00	 cmp	 DWORD PTR rc$[rsp], 0
  0010b	7d 0a		 jge	 SHORT $LN133@ckd_dasd_h
  0010d	b8 ff ff ff ff	 mov	 eax, -1
  00112	e9 02 0b 00 00	 jmp	 $LN1@ckd_dasd_h
$LN133@ckd_dasd_h:

; 1265 :             break;

  00117	e9 dd 0a 00 00	 jmp	 $LN8@ckd_dasd_h
$LN134@ckd_dasd_h:
$LN15@ckd_dasd_h:

; 1266 :         case SR_DEV_CKD_BUFOFF:
; 1267 :             SR_READ_VALUE(file, len, &dev->bufoff, sizeof(dev->bufoff));

  0011c	48 8b 44 24 60	 mov	 rax, QWORD PTR dev$[rsp]
  00121	48 05 e0 01 00
	00		 add	 rax, 480		; 000001e0H
  00127	41 b9 04 00 00
	00		 mov	 r9d, 4
  0012d	4c 8b c0	 mov	 r8, rax
  00130	8b 54 24 38	 mov	 edx, DWORD PTR len$[rsp]
  00134	48 8b 4c 24 68	 mov	 rcx, QWORD PTR file$[rsp]
  00139	e8 00 00 00 00	 call	 sr_read_value
  0013e	85 c0		 test	 eax, eax
  00140	74 0a		 je	 SHORT $LN135@ckd_dasd_h
  00142	b8 ff ff ff ff	 mov	 eax, -1
  00147	e9 cd 0a 00 00	 jmp	 $LN1@ckd_dasd_h
$LN135@ckd_dasd_h:
  0014c	33 c0		 xor	 eax, eax
  0014e	85 c0		 test	 eax, eax
  00150	75 ca		 jne	 SHORT $LN15@ckd_dasd_h

; 1268 :             break;

  00152	e9 a2 0a 00 00	 jmp	 $LN8@ckd_dasd_h
$LN136@ckd_dasd_h:
$LN18@ckd_dasd_h:

; 1269 :         case SR_DEV_CKD_CURCYL:
; 1270 :             SR_READ_VALUE(file, len, &dev->ckdcurcyl, sizeof(dev->ckdcurcyl));

  00157	48 8b 44 24 60	 mov	 rax, QWORD PTR dev$[rsp]
  0015c	48 05 c8 12 00
	00		 add	 rax, 4808		; 000012c8H
  00162	41 b9 04 00 00
	00		 mov	 r9d, 4
  00168	4c 8b c0	 mov	 r8, rax
  0016b	8b 54 24 38	 mov	 edx, DWORD PTR len$[rsp]
  0016f	48 8b 4c 24 68	 mov	 rcx, QWORD PTR file$[rsp]
  00174	e8 00 00 00 00	 call	 sr_read_value
  00179	85 c0		 test	 eax, eax
  0017b	74 0a		 je	 SHORT $LN137@ckd_dasd_h
  0017d	b8 ff ff ff ff	 mov	 eax, -1
  00182	e9 92 0a 00 00	 jmp	 $LN1@ckd_dasd_h
$LN137@ckd_dasd_h:
  00187	33 c0		 xor	 eax, eax
  00189	85 c0		 test	 eax, eax
  0018b	75 ca		 jne	 SHORT $LN18@ckd_dasd_h

; 1271 :             break;

  0018d	e9 67 0a 00 00	 jmp	 $LN8@ckd_dasd_h
$LN138@ckd_dasd_h:
$LN21@ckd_dasd_h:

; 1272 :         case SR_DEV_CKD_CURHEAD:
; 1273 :             SR_READ_VALUE(file, len, &dev->ckdcurhead, sizeof(dev->ckdcurhead));

  00192	48 8b 44 24 60	 mov	 rax, QWORD PTR dev$[rsp]
  00197	48 05 cc 12 00
	00		 add	 rax, 4812		; 000012ccH
  0019d	41 b9 04 00 00
	00		 mov	 r9d, 4
  001a3	4c 8b c0	 mov	 r8, rax
  001a6	8b 54 24 38	 mov	 edx, DWORD PTR len$[rsp]
  001aa	48 8b 4c 24 68	 mov	 rcx, QWORD PTR file$[rsp]
  001af	e8 00 00 00 00	 call	 sr_read_value
  001b4	85 c0		 test	 eax, eax
  001b6	74 0a		 je	 SHORT $LN139@ckd_dasd_h
  001b8	b8 ff ff ff ff	 mov	 eax, -1
  001bd	e9 57 0a 00 00	 jmp	 $LN1@ckd_dasd_h
$LN139@ckd_dasd_h:
  001c2	33 c0		 xor	 eax, eax
  001c4	85 c0		 test	 eax, eax
  001c6	75 ca		 jne	 SHORT $LN21@ckd_dasd_h

; 1274 :             break;

  001c8	e9 2c 0a 00 00	 jmp	 $LN8@ckd_dasd_h
$LN140@ckd_dasd_h:
$LN24@ckd_dasd_h:

; 1275 :         case SR_DEV_CKD_CURREC:
; 1276 :             SR_READ_VALUE(file, len, &dev->ckdcurrec, sizeof(dev->ckdcurrec));

  001cd	48 8b 44 24 60	 mov	 rax, QWORD PTR dev$[rsp]
  001d2	48 05 d0 12 00
	00		 add	 rax, 4816		; 000012d0H
  001d8	41 b9 04 00 00
	00		 mov	 r9d, 4
  001de	4c 8b c0	 mov	 r8, rax
  001e1	8b 54 24 38	 mov	 edx, DWORD PTR len$[rsp]
  001e5	48 8b 4c 24 68	 mov	 rcx, QWORD PTR file$[rsp]
  001ea	e8 00 00 00 00	 call	 sr_read_value
  001ef	85 c0		 test	 eax, eax
  001f1	74 0a		 je	 SHORT $LN141@ckd_dasd_h
  001f3	b8 ff ff ff ff	 mov	 eax, -1
  001f8	e9 1c 0a 00 00	 jmp	 $LN1@ckd_dasd_h
$LN141@ckd_dasd_h:
  001fd	33 c0		 xor	 eax, eax
  001ff	85 c0		 test	 eax, eax
  00201	75 ca		 jne	 SHORT $LN24@ckd_dasd_h

; 1277 :             break;

  00203	e9 f1 09 00 00	 jmp	 $LN8@ckd_dasd_h
$LN142@ckd_dasd_h:
$LN27@ckd_dasd_h:

; 1278 :         case SR_DEV_CKD_CURKL:
; 1279 :             SR_READ_VALUE(file, len, &dev->ckdcurkl, sizeof(dev->ckdcurkl));

  00208	48 8b 44 24 60	 mov	 rax, QWORD PTR dev$[rsp]
  0020d	48 05 d4 12 00
	00		 add	 rax, 4820		; 000012d4H
  00213	41 b9 04 00 00
	00		 mov	 r9d, 4
  00219	4c 8b c0	 mov	 r8, rax
  0021c	8b 54 24 38	 mov	 edx, DWORD PTR len$[rsp]
  00220	48 8b 4c 24 68	 mov	 rcx, QWORD PTR file$[rsp]
  00225	e8 00 00 00 00	 call	 sr_read_value
  0022a	85 c0		 test	 eax, eax
  0022c	74 0a		 je	 SHORT $LN143@ckd_dasd_h
  0022e	b8 ff ff ff ff	 mov	 eax, -1
  00233	e9 e1 09 00 00	 jmp	 $LN1@ckd_dasd_h
$LN143@ckd_dasd_h:
  00238	33 c0		 xor	 eax, eax
  0023a	85 c0		 test	 eax, eax
  0023c	75 ca		 jne	 SHORT $LN27@ckd_dasd_h

; 1280 :             break;

  0023e	e9 b6 09 00 00	 jmp	 $LN8@ckd_dasd_h
$LN144@ckd_dasd_h:
$LN30@ckd_dasd_h:

; 1281 :         case SR_DEV_CKD_ORIENT:
; 1282 :             SR_READ_VALUE(file, len, &dev->ckdorient, sizeof(dev->ckdorient));

  00243	48 8b 44 24 60	 mov	 rax, QWORD PTR dev$[rsp]
  00248	48 05 d8 12 00
	00		 add	 rax, 4824		; 000012d8H
  0024e	41 b9 04 00 00
	00		 mov	 r9d, 4
  00254	4c 8b c0	 mov	 r8, rax
  00257	8b 54 24 38	 mov	 edx, DWORD PTR len$[rsp]
  0025b	48 8b 4c 24 68	 mov	 rcx, QWORD PTR file$[rsp]
  00260	e8 00 00 00 00	 call	 sr_read_value
  00265	85 c0		 test	 eax, eax
  00267	74 0a		 je	 SHORT $LN145@ckd_dasd_h
  00269	b8 ff ff ff ff	 mov	 eax, -1
  0026e	e9 a6 09 00 00	 jmp	 $LN1@ckd_dasd_h
$LN145@ckd_dasd_h:
  00273	33 c0		 xor	 eax, eax
  00275	85 c0		 test	 eax, eax
  00277	75 ca		 jne	 SHORT $LN30@ckd_dasd_h

; 1283 :             break;

  00279	e9 7b 09 00 00	 jmp	 $LN8@ckd_dasd_h
$LN146@ckd_dasd_h:
$LN33@ckd_dasd_h:

; 1284 :         case SR_DEV_CKD_CUROPER:
; 1285 :             SR_READ_VALUE(file, len, &dev->ckdcuroper, sizeof(dev->ckdcuroper));

  0027e	48 8b 44 24 60	 mov	 rax, QWORD PTR dev$[rsp]
  00283	48 05 dc 12 00
	00		 add	 rax, 4828		; 000012dcH
  00289	41 b9 04 00 00
	00		 mov	 r9d, 4
  0028f	4c 8b c0	 mov	 r8, rax
  00292	8b 54 24 38	 mov	 edx, DWORD PTR len$[rsp]
  00296	48 8b 4c 24 68	 mov	 rcx, QWORD PTR file$[rsp]
  0029b	e8 00 00 00 00	 call	 sr_read_value
  002a0	85 c0		 test	 eax, eax
  002a2	74 0a		 je	 SHORT $LN147@ckd_dasd_h
  002a4	b8 ff ff ff ff	 mov	 eax, -1
  002a9	e9 6b 09 00 00	 jmp	 $LN1@ckd_dasd_h
$LN147@ckd_dasd_h:
  002ae	33 c0		 xor	 eax, eax
  002b0	85 c0		 test	 eax, eax
  002b2	75 ca		 jne	 SHORT $LN33@ckd_dasd_h

; 1286 :             break;

  002b4	e9 40 09 00 00	 jmp	 $LN8@ckd_dasd_h
$LN148@ckd_dasd_h:
$LN36@ckd_dasd_h:

; 1287 :         case SR_DEV_CKD_CURDL:
; 1288 :             SR_READ_VALUE(file, len, &dev->ckdcurdl, sizeof(dev->ckdcurdl));

  002b9	48 8b 44 24 60	 mov	 rax, QWORD PTR dev$[rsp]
  002be	48 05 ea 12 00
	00		 add	 rax, 4842		; 000012eaH
  002c4	41 b9 02 00 00
	00		 mov	 r9d, 2
  002ca	4c 8b c0	 mov	 r8, rax
  002cd	8b 54 24 38	 mov	 edx, DWORD PTR len$[rsp]
  002d1	48 8b 4c 24 68	 mov	 rcx, QWORD PTR file$[rsp]
  002d6	e8 00 00 00 00	 call	 sr_read_value
  002db	85 c0		 test	 eax, eax
  002dd	74 0a		 je	 SHORT $LN149@ckd_dasd_h
  002df	b8 ff ff ff ff	 mov	 eax, -1
  002e4	e9 30 09 00 00	 jmp	 $LN1@ckd_dasd_h
$LN149@ckd_dasd_h:
  002e9	33 c0		 xor	 eax, eax
  002eb	85 c0		 test	 eax, eax
  002ed	75 ca		 jne	 SHORT $LN36@ckd_dasd_h

; 1289 :             break;

  002ef	e9 05 09 00 00	 jmp	 $LN8@ckd_dasd_h
$LN150@ckd_dasd_h:
$LN39@ckd_dasd_h:

; 1290 :         case SR_DEV_CKD_REM:
; 1291 :             SR_READ_VALUE(file, len, &dev->ckdrem, sizeof(dev->ckdrem));

  002f4	48 8b 44 24 60	 mov	 rax, QWORD PTR dev$[rsp]
  002f9	48 05 ec 12 00
	00		 add	 rax, 4844		; 000012ecH
  002ff	41 b9 02 00 00
	00		 mov	 r9d, 2
  00305	4c 8b c0	 mov	 r8, rax
  00308	8b 54 24 38	 mov	 edx, DWORD PTR len$[rsp]
  0030c	48 8b 4c 24 68	 mov	 rcx, QWORD PTR file$[rsp]
  00311	e8 00 00 00 00	 call	 sr_read_value
  00316	85 c0		 test	 eax, eax
  00318	74 0a		 je	 SHORT $LN151@ckd_dasd_h
  0031a	b8 ff ff ff ff	 mov	 eax, -1
  0031f	e9 f5 08 00 00	 jmp	 $LN1@ckd_dasd_h
$LN151@ckd_dasd_h:
  00324	33 c0		 xor	 eax, eax
  00326	85 c0		 test	 eax, eax
  00328	75 ca		 jne	 SHORT $LN39@ckd_dasd_h

; 1292 :             break;

  0032a	e9 ca 08 00 00	 jmp	 $LN8@ckd_dasd_h
$LN152@ckd_dasd_h:
$LN42@ckd_dasd_h:

; 1293 :         case SR_DEV_CKD_POS:
; 1294 :             SR_READ_VALUE(file, len, &dev->ckdpos, sizeof(dev->ckdpos));

  0032f	48 8b 44 24 60	 mov	 rax, QWORD PTR dev$[rsp]
  00334	48 05 ee 12 00
	00		 add	 rax, 4846		; 000012eeH
  0033a	41 b9 02 00 00
	00		 mov	 r9d, 2
  00340	4c 8b c0	 mov	 r8, rax
  00343	8b 54 24 38	 mov	 edx, DWORD PTR len$[rsp]
  00347	48 8b 4c 24 68	 mov	 rcx, QWORD PTR file$[rsp]
  0034c	e8 00 00 00 00	 call	 sr_read_value
  00351	85 c0		 test	 eax, eax
  00353	74 0a		 je	 SHORT $LN153@ckd_dasd_h
  00355	b8 ff ff ff ff	 mov	 eax, -1
  0035a	e9 ba 08 00 00	 jmp	 $LN1@ckd_dasd_h
$LN153@ckd_dasd_h:
  0035f	33 c0		 xor	 eax, eax
  00361	85 c0		 test	 eax, eax
  00363	75 ca		 jne	 SHORT $LN42@ckd_dasd_h

; 1295 :             break;

  00365	e9 8f 08 00 00	 jmp	 $LN8@ckd_dasd_h
$LN154@ckd_dasd_h:
$LN45@ckd_dasd_h:

; 1296 :         case SR_DEV_CKD_DXBLKSZ:
; 1297 :             SR_READ_VALUE(file, len, &dev->ckdxblksz, sizeof(dev->ckdxblksz));

  0036a	48 8b 44 24 60	 mov	 rax, QWORD PTR dev$[rsp]
  0036f	48 05 f0 12 00
	00		 add	 rax, 4848		; 000012f0H
  00375	41 b9 02 00 00
	00		 mov	 r9d, 2
  0037b	4c 8b c0	 mov	 r8, rax
  0037e	8b 54 24 38	 mov	 edx, DWORD PTR len$[rsp]
  00382	48 8b 4c 24 68	 mov	 rcx, QWORD PTR file$[rsp]
  00387	e8 00 00 00 00	 call	 sr_read_value
  0038c	85 c0		 test	 eax, eax
  0038e	74 0a		 je	 SHORT $LN155@ckd_dasd_h
  00390	b8 ff ff ff ff	 mov	 eax, -1
  00395	e9 7f 08 00 00	 jmp	 $LN1@ckd_dasd_h
$LN155@ckd_dasd_h:
  0039a	33 c0		 xor	 eax, eax
  0039c	85 c0		 test	 eax, eax
  0039e	75 ca		 jne	 SHORT $LN45@ckd_dasd_h

; 1298 :             break;

  003a0	e9 54 08 00 00	 jmp	 $LN8@ckd_dasd_h
$LN156@ckd_dasd_h:
$LN48@ckd_dasd_h:

; 1299 :         case SR_DEV_CKD_DXBCYL:
; 1300 :             SR_READ_VALUE(file, len, &dev->ckdxbcyl, sizeof(dev->ckdxbcyl));

  003a5	48 8b 44 24 60	 mov	 rax, QWORD PTR dev$[rsp]
  003aa	48 05 f2 12 00
	00		 add	 rax, 4850		; 000012f2H
  003b0	41 b9 02 00 00
	00		 mov	 r9d, 2
  003b6	4c 8b c0	 mov	 r8, rax
  003b9	8b 54 24 38	 mov	 edx, DWORD PTR len$[rsp]
  003bd	48 8b 4c 24 68	 mov	 rcx, QWORD PTR file$[rsp]
  003c2	e8 00 00 00 00	 call	 sr_read_value
  003c7	85 c0		 test	 eax, eax
  003c9	74 0a		 je	 SHORT $LN157@ckd_dasd_h
  003cb	b8 ff ff ff ff	 mov	 eax, -1
  003d0	e9 44 08 00 00	 jmp	 $LN1@ckd_dasd_h
$LN157@ckd_dasd_h:
  003d5	33 c0		 xor	 eax, eax
  003d7	85 c0		 test	 eax, eax
  003d9	75 ca		 jne	 SHORT $LN48@ckd_dasd_h

; 1301 :             break;

  003db	e9 19 08 00 00	 jmp	 $LN8@ckd_dasd_h
$LN158@ckd_dasd_h:
$LN51@ckd_dasd_h:

; 1302 :         case SR_DEV_CKD_DXBHEAD:
; 1303 :             SR_READ_VALUE(file, len, &dev->ckdxbhead, sizeof(dev->ckdxbhead));

  003e0	48 8b 44 24 60	 mov	 rax, QWORD PTR dev$[rsp]
  003e5	48 05 f4 12 00
	00		 add	 rax, 4852		; 000012f4H
  003eb	41 b9 02 00 00
	00		 mov	 r9d, 2
  003f1	4c 8b c0	 mov	 r8, rax
  003f4	8b 54 24 38	 mov	 edx, DWORD PTR len$[rsp]
  003f8	48 8b 4c 24 68	 mov	 rcx, QWORD PTR file$[rsp]
  003fd	e8 00 00 00 00	 call	 sr_read_value
  00402	85 c0		 test	 eax, eax
  00404	74 0a		 je	 SHORT $LN159@ckd_dasd_h
  00406	b8 ff ff ff ff	 mov	 eax, -1
  0040b	e9 09 08 00 00	 jmp	 $LN1@ckd_dasd_h
$LN159@ckd_dasd_h:
  00410	33 c0		 xor	 eax, eax
  00412	85 c0		 test	 eax, eax
  00414	75 ca		 jne	 SHORT $LN51@ckd_dasd_h

; 1304 :             break;

  00416	e9 de 07 00 00	 jmp	 $LN8@ckd_dasd_h
$LN160@ckd_dasd_h:
$LN54@ckd_dasd_h:

; 1305 :         case SR_DEV_CKD_DXECYL:
; 1306 :             SR_READ_VALUE(file, len, &dev->ckdxecyl, sizeof(dev->ckdxecyl));

  0041b	48 8b 44 24 60	 mov	 rax, QWORD PTR dev$[rsp]
  00420	48 05 f6 12 00
	00		 add	 rax, 4854		; 000012f6H
  00426	41 b9 02 00 00
	00		 mov	 r9d, 2
  0042c	4c 8b c0	 mov	 r8, rax
  0042f	8b 54 24 38	 mov	 edx, DWORD PTR len$[rsp]
  00433	48 8b 4c 24 68	 mov	 rcx, QWORD PTR file$[rsp]
  00438	e8 00 00 00 00	 call	 sr_read_value
  0043d	85 c0		 test	 eax, eax
  0043f	74 0a		 je	 SHORT $LN161@ckd_dasd_h
  00441	b8 ff ff ff ff	 mov	 eax, -1
  00446	e9 ce 07 00 00	 jmp	 $LN1@ckd_dasd_h
$LN161@ckd_dasd_h:
  0044b	33 c0		 xor	 eax, eax
  0044d	85 c0		 test	 eax, eax
  0044f	75 ca		 jne	 SHORT $LN54@ckd_dasd_h

; 1307 :             break;

  00451	e9 a3 07 00 00	 jmp	 $LN8@ckd_dasd_h
$LN162@ckd_dasd_h:
$LN57@ckd_dasd_h:

; 1308 :         case SR_DEV_CKD_DXEHEAD:
; 1309 :             SR_READ_VALUE(file, len, &dev->ckdxehead, sizeof(dev->ckdxehead));

  00456	48 8b 44 24 60	 mov	 rax, QWORD PTR dev$[rsp]
  0045b	48 05 f8 12 00
	00		 add	 rax, 4856		; 000012f8H
  00461	41 b9 02 00 00
	00		 mov	 r9d, 2
  00467	4c 8b c0	 mov	 r8, rax
  0046a	8b 54 24 38	 mov	 edx, DWORD PTR len$[rsp]
  0046e	48 8b 4c 24 68	 mov	 rcx, QWORD PTR file$[rsp]
  00473	e8 00 00 00 00	 call	 sr_read_value
  00478	85 c0		 test	 eax, eax
  0047a	74 0a		 je	 SHORT $LN163@ckd_dasd_h
  0047c	b8 ff ff ff ff	 mov	 eax, -1
  00481	e9 93 07 00 00	 jmp	 $LN1@ckd_dasd_h
$LN163@ckd_dasd_h:
  00486	33 c0		 xor	 eax, eax
  00488	85 c0		 test	 eax, eax
  0048a	75 ca		 jne	 SHORT $LN57@ckd_dasd_h

; 1310 :             break;

  0048c	e9 68 07 00 00	 jmp	 $LN8@ckd_dasd_h
$LN164@ckd_dasd_h:
$LN60@ckd_dasd_h:

; 1311 :         case SR_DEV_CKD_DXFMASK:
; 1312 :             SR_READ_VALUE(file, len, &dev->ckdfmask, sizeof(dev->ckdfmask));

  00491	48 8b 44 24 60	 mov	 rax, QWORD PTR dev$[rsp]
  00496	48 05 fa 12 00
	00		 add	 rax, 4858		; 000012faH
  0049c	41 b9 01 00 00
	00		 mov	 r9d, 1
  004a2	4c 8b c0	 mov	 r8, rax
  004a5	8b 54 24 38	 mov	 edx, DWORD PTR len$[rsp]
  004a9	48 8b 4c 24 68	 mov	 rcx, QWORD PTR file$[rsp]
  004ae	e8 00 00 00 00	 call	 sr_read_value
  004b3	85 c0		 test	 eax, eax
  004b5	74 0a		 je	 SHORT $LN165@ckd_dasd_h
  004b7	b8 ff ff ff ff	 mov	 eax, -1
  004bc	e9 58 07 00 00	 jmp	 $LN1@ckd_dasd_h
$LN165@ckd_dasd_h:
  004c1	33 c0		 xor	 eax, eax
  004c3	85 c0		 test	 eax, eax
  004c5	75 ca		 jne	 SHORT $LN60@ckd_dasd_h

; 1313 :             break;

  004c7	e9 2d 07 00 00	 jmp	 $LN8@ckd_dasd_h
$LN166@ckd_dasd_h:
$LN63@ckd_dasd_h:

; 1314 :         case SR_DEV_CKD_DXGATTR:
; 1315 :             SR_READ_VALUE(file, len, &dev->ckdxgattr, sizeof(dev->ckdxgattr));

  004cc	48 8b 44 24 60	 mov	 rax, QWORD PTR dev$[rsp]
  004d1	48 05 fb 12 00
	00		 add	 rax, 4859		; 000012fbH
  004d7	41 b9 01 00 00
	00		 mov	 r9d, 1
  004dd	4c 8b c0	 mov	 r8, rax
  004e0	8b 54 24 38	 mov	 edx, DWORD PTR len$[rsp]
  004e4	48 8b 4c 24 68	 mov	 rcx, QWORD PTR file$[rsp]
  004e9	e8 00 00 00 00	 call	 sr_read_value
  004ee	85 c0		 test	 eax, eax
  004f0	74 0a		 je	 SHORT $LN167@ckd_dasd_h
  004f2	b8 ff ff ff ff	 mov	 eax, -1
  004f7	e9 1d 07 00 00	 jmp	 $LN1@ckd_dasd_h
$LN167@ckd_dasd_h:
  004fc	33 c0		 xor	 eax, eax
  004fe	85 c0		 test	 eax, eax
  00500	75 ca		 jne	 SHORT $LN63@ckd_dasd_h

; 1316 :             break;

  00502	e9 f2 06 00 00	 jmp	 $LN8@ckd_dasd_h
$LN168@ckd_dasd_h:
$LN66@ckd_dasd_h:

; 1317 :         case SR_DEV_CKD_LRTRANLF:
; 1318 :             SR_READ_VALUE(file, len, &dev->ckdltranlf, sizeof(dev->ckdltranlf));

  00507	48 8b 44 24 60	 mov	 rax, QWORD PTR dev$[rsp]
  0050c	48 05 fc 12 00
	00		 add	 rax, 4860		; 000012fcH
  00512	41 b9 02 00 00
	00		 mov	 r9d, 2
  00518	4c 8b c0	 mov	 r8, rax
  0051b	8b 54 24 38	 mov	 edx, DWORD PTR len$[rsp]
  0051f	48 8b 4c 24 68	 mov	 rcx, QWORD PTR file$[rsp]
  00524	e8 00 00 00 00	 call	 sr_read_value
  00529	85 c0		 test	 eax, eax
  0052b	74 0a		 je	 SHORT $LN169@ckd_dasd_h
  0052d	b8 ff ff ff ff	 mov	 eax, -1
  00532	e9 e2 06 00 00	 jmp	 $LN1@ckd_dasd_h
$LN169@ckd_dasd_h:
  00537	33 c0		 xor	 eax, eax
  00539	85 c0		 test	 eax, eax
  0053b	75 ca		 jne	 SHORT $LN66@ckd_dasd_h

; 1319 :             break;

  0053d	e9 b7 06 00 00	 jmp	 $LN8@ckd_dasd_h
$LN170@ckd_dasd_h:
$LN69@ckd_dasd_h:

; 1320 :         case SR_DEV_CKD_LROPER:
; 1321 :             SR_READ_VALUE(file, len, &dev->ckdloper, sizeof(dev->ckdloper));

  00542	48 8b 44 24 60	 mov	 rax, QWORD PTR dev$[rsp]
  00547	48 05 00 13 00
	00		 add	 rax, 4864		; 00001300H
  0054d	41 b9 01 00 00
	00		 mov	 r9d, 1
  00553	4c 8b c0	 mov	 r8, rax
  00556	8b 54 24 38	 mov	 edx, DWORD PTR len$[rsp]
  0055a	48 8b 4c 24 68	 mov	 rcx, QWORD PTR file$[rsp]
  0055f	e8 00 00 00 00	 call	 sr_read_value
  00564	85 c0		 test	 eax, eax
  00566	74 0a		 je	 SHORT $LN171@ckd_dasd_h
  00568	b8 ff ff ff ff	 mov	 eax, -1
  0056d	e9 a7 06 00 00	 jmp	 $LN1@ckd_dasd_h
$LN171@ckd_dasd_h:
  00572	33 c0		 xor	 eax, eax
  00574	85 c0		 test	 eax, eax
  00576	75 ca		 jne	 SHORT $LN69@ckd_dasd_h

; 1322 :             break;

  00578	e9 7c 06 00 00	 jmp	 $LN8@ckd_dasd_h
$LN172@ckd_dasd_h:
$LN72@ckd_dasd_h:

; 1323 :         case SR_DEV_CKD_LRAUX:
; 1324 :             SR_READ_VALUE(file, len, &dev->ckdlaux, sizeof(dev->ckdlaux));

  0057d	48 8b 44 24 60	 mov	 rax, QWORD PTR dev$[rsp]
  00582	48 05 01 13 00
	00		 add	 rax, 4865		; 00001301H
  00588	41 b9 01 00 00
	00		 mov	 r9d, 1
  0058e	4c 8b c0	 mov	 r8, rax
  00591	8b 54 24 38	 mov	 edx, DWORD PTR len$[rsp]
  00595	48 8b 4c 24 68	 mov	 rcx, QWORD PTR file$[rsp]
  0059a	e8 00 00 00 00	 call	 sr_read_value
  0059f	85 c0		 test	 eax, eax
  005a1	74 0a		 je	 SHORT $LN173@ckd_dasd_h
  005a3	b8 ff ff ff ff	 mov	 eax, -1
  005a8	e9 6c 06 00 00	 jmp	 $LN1@ckd_dasd_h
$LN173@ckd_dasd_h:
  005ad	33 c0		 xor	 eax, eax
  005af	85 c0		 test	 eax, eax
  005b1	75 ca		 jne	 SHORT $LN72@ckd_dasd_h

; 1325 :             break;

  005b3	e9 41 06 00 00	 jmp	 $LN8@ckd_dasd_h
$LN174@ckd_dasd_h:
$LN75@ckd_dasd_h:

; 1326 :         case SR_DEV_CKD_LRCOUNT:
; 1327 :             SR_READ_VALUE(file, len, &dev->ckdltranlf, sizeof(dev->ckdltranlf));

  005b8	48 8b 44 24 60	 mov	 rax, QWORD PTR dev$[rsp]
  005bd	48 05 fc 12 00
	00		 add	 rax, 4860		; 000012fcH
  005c3	41 b9 02 00 00
	00		 mov	 r9d, 2
  005c9	4c 8b c0	 mov	 r8, rax
  005cc	8b 54 24 38	 mov	 edx, DWORD PTR len$[rsp]
  005d0	48 8b 4c 24 68	 mov	 rcx, QWORD PTR file$[rsp]
  005d5	e8 00 00 00 00	 call	 sr_read_value
  005da	85 c0		 test	 eax, eax
  005dc	74 0a		 je	 SHORT $LN175@ckd_dasd_h
  005de	b8 ff ff ff ff	 mov	 eax, -1
  005e3	e9 31 06 00 00	 jmp	 $LN1@ckd_dasd_h
$LN175@ckd_dasd_h:
  005e8	33 c0		 xor	 eax, eax
  005ea	85 c0		 test	 eax, eax
  005ec	75 ca		 jne	 SHORT $LN75@ckd_dasd_h

; 1328 :             break;

  005ee	e9 06 06 00 00	 jmp	 $LN8@ckd_dasd_h
$LN176@ckd_dasd_h:
$LN78@ckd_dasd_h:

; 1329 :         case SR_DEV_CKD_3990:
; 1330 :             SR_READ_VALUE(file, len, &rc, sizeof(rc));

  005f3	41 b9 04 00 00
	00		 mov	 r9d, 4
  005f9	4c 8d 44 24 24	 lea	 r8, QWORD PTR rc$[rsp]
  005fe	8b 54 24 38	 mov	 edx, DWORD PTR len$[rsp]
  00602	48 8b 4c 24 68	 mov	 rcx, QWORD PTR file$[rsp]
  00607	e8 00 00 00 00	 call	 sr_read_value
  0060c	85 c0		 test	 eax, eax
  0060e	74 0a		 je	 SHORT $LN177@ckd_dasd_h
  00610	b8 ff ff ff ff	 mov	 eax, -1
  00615	e9 ff 05 00 00	 jmp	 $LN1@ckd_dasd_h
$LN177@ckd_dasd_h:
  0061a	33 c0		 xor	 eax, eax
  0061c	85 c0		 test	 eax, eax
  0061e	75 d3		 jne	 SHORT $LN78@ckd_dasd_h

; 1331 :             dev->ckd3990 = rc;

  00620	8b 44 24 24	 mov	 eax, DWORD PTR rc$[rsp]
  00624	83 e0 01	 and	 eax, 1
  00627	48 8b 4c 24 60	 mov	 rcx, QWORD PTR dev$[rsp]
  0062c	8b 89 14 13 00
	00		 mov	 ecx, DWORD PTR [rcx+4884]
  00632	83 e1 fe	 and	 ecx, -2			; fffffffeH
  00635	0b c8		 or	 ecx, eax
  00637	8b c1		 mov	 eax, ecx
  00639	48 8b 4c 24 60	 mov	 rcx, QWORD PTR dev$[rsp]
  0063e	89 81 14 13 00
	00		 mov	 DWORD PTR [rcx+4884], eax

; 1332 :             break;

  00644	e9 b0 05 00 00	 jmp	 $LN8@ckd_dasd_h
$LN178@ckd_dasd_h:
$LN81@ckd_dasd_h:

; 1333 :         case SR_DEV_CKD_XTDEF:
; 1334 :             SR_READ_VALUE(file, len, &rc, sizeof(rc));

  00649	41 b9 04 00 00
	00		 mov	 r9d, 4
  0064f	4c 8d 44 24 24	 lea	 r8, QWORD PTR rc$[rsp]
  00654	8b 54 24 38	 mov	 edx, DWORD PTR len$[rsp]
  00658	48 8b 4c 24 68	 mov	 rcx, QWORD PTR file$[rsp]
  0065d	e8 00 00 00 00	 call	 sr_read_value
  00662	85 c0		 test	 eax, eax
  00664	74 0a		 je	 SHORT $LN179@ckd_dasd_h
  00666	b8 ff ff ff ff	 mov	 eax, -1
  0066b	e9 a9 05 00 00	 jmp	 $LN1@ckd_dasd_h
$LN179@ckd_dasd_h:
  00670	33 c0		 xor	 eax, eax
  00672	85 c0		 test	 eax, eax
  00674	75 d3		 jne	 SHORT $LN81@ckd_dasd_h

; 1335 :             dev->ckdxtdef = rc;

  00676	8b 44 24 24	 mov	 eax, DWORD PTR rc$[rsp]
  0067a	83 e0 01	 and	 eax, 1
  0067d	d1 e0		 shl	 eax, 1
  0067f	48 8b 4c 24 60	 mov	 rcx, QWORD PTR dev$[rsp]
  00684	8b 89 14 13 00
	00		 mov	 ecx, DWORD PTR [rcx+4884]
  0068a	83 e1 fd	 and	 ecx, -3			; fffffffdH
  0068d	0b c8		 or	 ecx, eax
  0068f	8b c1		 mov	 eax, ecx
  00691	48 8b 4c 24 60	 mov	 rcx, QWORD PTR dev$[rsp]
  00696	89 81 14 13 00
	00		 mov	 DWORD PTR [rcx+4884], eax

; 1336 :             break;

  0069c	e9 58 05 00 00	 jmp	 $LN8@ckd_dasd_h
$LN180@ckd_dasd_h:
$LN84@ckd_dasd_h:

; 1337 :         case SR_DEV_CKD_SETFM:
; 1338 :             SR_READ_VALUE(file, len, &rc, sizeof(rc));

  006a1	41 b9 04 00 00
	00		 mov	 r9d, 4
  006a7	4c 8d 44 24 24	 lea	 r8, QWORD PTR rc$[rsp]
  006ac	8b 54 24 38	 mov	 edx, DWORD PTR len$[rsp]
  006b0	48 8b 4c 24 68	 mov	 rcx, QWORD PTR file$[rsp]
  006b5	e8 00 00 00 00	 call	 sr_read_value
  006ba	85 c0		 test	 eax, eax
  006bc	74 0a		 je	 SHORT $LN181@ckd_dasd_h
  006be	b8 ff ff ff ff	 mov	 eax, -1
  006c3	e9 51 05 00 00	 jmp	 $LN1@ckd_dasd_h
$LN181@ckd_dasd_h:
  006c8	33 c0		 xor	 eax, eax
  006ca	85 c0		 test	 eax, eax
  006cc	75 d3		 jne	 SHORT $LN84@ckd_dasd_h

; 1339 :             dev->ckdsetfm = rc;

  006ce	8b 44 24 24	 mov	 eax, DWORD PTR rc$[rsp]
  006d2	83 e0 01	 and	 eax, 1
  006d5	c1 e0 02	 shl	 eax, 2
  006d8	48 8b 4c 24 60	 mov	 rcx, QWORD PTR dev$[rsp]
  006dd	8b 89 14 13 00
	00		 mov	 ecx, DWORD PTR [rcx+4884]
  006e3	83 e1 fb	 and	 ecx, -5			; fffffffbH
  006e6	0b c8		 or	 ecx, eax
  006e8	8b c1		 mov	 eax, ecx
  006ea	48 8b 4c 24 60	 mov	 rcx, QWORD PTR dev$[rsp]
  006ef	89 81 14 13 00
	00		 mov	 DWORD PTR [rcx+4884], eax

; 1340 :             break;

  006f5	e9 ff 04 00 00	 jmp	 $LN8@ckd_dasd_h
$LN182@ckd_dasd_h:
$LN87@ckd_dasd_h:

; 1341 :         case SR_DEV_CKD_LOCAT:
; 1342 :             SR_READ_VALUE(file, len, &rc, sizeof(rc));

  006fa	41 b9 04 00 00
	00		 mov	 r9d, 4
  00700	4c 8d 44 24 24	 lea	 r8, QWORD PTR rc$[rsp]
  00705	8b 54 24 38	 mov	 edx, DWORD PTR len$[rsp]
  00709	48 8b 4c 24 68	 mov	 rcx, QWORD PTR file$[rsp]
  0070e	e8 00 00 00 00	 call	 sr_read_value
  00713	85 c0		 test	 eax, eax
  00715	74 0a		 je	 SHORT $LN183@ckd_dasd_h
  00717	b8 ff ff ff ff	 mov	 eax, -1
  0071c	e9 f8 04 00 00	 jmp	 $LN1@ckd_dasd_h
$LN183@ckd_dasd_h:
  00721	33 c0		 xor	 eax, eax
  00723	85 c0		 test	 eax, eax
  00725	75 d3		 jne	 SHORT $LN87@ckd_dasd_h

; 1343 :             dev->ckdlocat = rc;

  00727	8b 44 24 24	 mov	 eax, DWORD PTR rc$[rsp]
  0072b	83 e0 01	 and	 eax, 1
  0072e	c1 e0 03	 shl	 eax, 3
  00731	48 8b 4c 24 60	 mov	 rcx, QWORD PTR dev$[rsp]
  00736	8b 89 14 13 00
	00		 mov	 ecx, DWORD PTR [rcx+4884]
  0073c	83 e1 f7	 and	 ecx, -9			; fffffff7H
  0073f	0b c8		 or	 ecx, eax
  00741	8b c1		 mov	 eax, ecx
  00743	48 8b 4c 24 60	 mov	 rcx, QWORD PTR dev$[rsp]
  00748	89 81 14 13 00
	00		 mov	 DWORD PTR [rcx+4884], eax

; 1344 :             break;

  0074e	e9 a6 04 00 00	 jmp	 $LN8@ckd_dasd_h
$LN184@ckd_dasd_h:
$LN90@ckd_dasd_h:

; 1345 :         case SR_DEV_CKD_SPCNT:
; 1346 :             SR_READ_VALUE(file, len, &rc, sizeof(rc));

  00753	41 b9 04 00 00
	00		 mov	 r9d, 4
  00759	4c 8d 44 24 24	 lea	 r8, QWORD PTR rc$[rsp]
  0075e	8b 54 24 38	 mov	 edx, DWORD PTR len$[rsp]
  00762	48 8b 4c 24 68	 mov	 rcx, QWORD PTR file$[rsp]
  00767	e8 00 00 00 00	 call	 sr_read_value
  0076c	85 c0		 test	 eax, eax
  0076e	74 0a		 je	 SHORT $LN185@ckd_dasd_h
  00770	b8 ff ff ff ff	 mov	 eax, -1
  00775	e9 9f 04 00 00	 jmp	 $LN1@ckd_dasd_h
$LN185@ckd_dasd_h:
  0077a	33 c0		 xor	 eax, eax
  0077c	85 c0		 test	 eax, eax
  0077e	75 d3		 jne	 SHORT $LN90@ckd_dasd_h

; 1347 :             dev->ckdspcnt = rc;

  00780	8b 44 24 24	 mov	 eax, DWORD PTR rc$[rsp]
  00784	83 e0 01	 and	 eax, 1
  00787	c1 e0 05	 shl	 eax, 5
  0078a	48 8b 4c 24 60	 mov	 rcx, QWORD PTR dev$[rsp]
  0078f	8b 89 14 13 00
	00		 mov	 ecx, DWORD PTR [rcx+4884]
  00795	83 e1 df	 and	 ecx, -33		; ffffffdfH
  00798	0b c8		 or	 ecx, eax
  0079a	8b c1		 mov	 eax, ecx
  0079c	48 8b 4c 24 60	 mov	 rcx, QWORD PTR dev$[rsp]
  007a1	89 81 14 13 00
	00		 mov	 DWORD PTR [rcx+4884], eax

; 1348 :             break;

  007a7	e9 4d 04 00 00	 jmp	 $LN8@ckd_dasd_h
$LN186@ckd_dasd_h:
$LN93@ckd_dasd_h:

; 1349 :         case SR_DEV_CKD_SEEK:
; 1350 :             SR_READ_VALUE(file, len, &rc, sizeof(rc));

  007ac	41 b9 04 00 00
	00		 mov	 r9d, 4
  007b2	4c 8d 44 24 24	 lea	 r8, QWORD PTR rc$[rsp]
  007b7	8b 54 24 38	 mov	 edx, DWORD PTR len$[rsp]
  007bb	48 8b 4c 24 68	 mov	 rcx, QWORD PTR file$[rsp]
  007c0	e8 00 00 00 00	 call	 sr_read_value
  007c5	85 c0		 test	 eax, eax
  007c7	74 0a		 je	 SHORT $LN187@ckd_dasd_h
  007c9	b8 ff ff ff ff	 mov	 eax, -1
  007ce	e9 46 04 00 00	 jmp	 $LN1@ckd_dasd_h
$LN187@ckd_dasd_h:
  007d3	33 c0		 xor	 eax, eax
  007d5	85 c0		 test	 eax, eax
  007d7	75 d3		 jne	 SHORT $LN93@ckd_dasd_h

; 1351 :             dev->ckdseek = rc;

  007d9	8b 44 24 24	 mov	 eax, DWORD PTR rc$[rsp]
  007dd	83 e0 01	 and	 eax, 1
  007e0	c1 e0 06	 shl	 eax, 6
  007e3	48 8b 4c 24 60	 mov	 rcx, QWORD PTR dev$[rsp]
  007e8	8b 89 14 13 00
	00		 mov	 ecx, DWORD PTR [rcx+4884]
  007ee	83 e1 bf	 and	 ecx, -65		; ffffffbfH
  007f1	0b c8		 or	 ecx, eax
  007f3	8b c1		 mov	 eax, ecx
  007f5	48 8b 4c 24 60	 mov	 rcx, QWORD PTR dev$[rsp]
  007fa	89 81 14 13 00
	00		 mov	 DWORD PTR [rcx+4884], eax

; 1352 :             break;

  00800	e9 f4 03 00 00	 jmp	 $LN8@ckd_dasd_h
$LN188@ckd_dasd_h:
$LN96@ckd_dasd_h:

; 1353 :         case SR_DEV_CKD_SKCYL:
; 1354 :             SR_READ_VALUE(file, len, &rc, sizeof(rc));

  00805	41 b9 04 00 00
	00		 mov	 r9d, 4
  0080b	4c 8d 44 24 24	 lea	 r8, QWORD PTR rc$[rsp]
  00810	8b 54 24 38	 mov	 edx, DWORD PTR len$[rsp]
  00814	48 8b 4c 24 68	 mov	 rcx, QWORD PTR file$[rsp]
  00819	e8 00 00 00 00	 call	 sr_read_value
  0081e	85 c0		 test	 eax, eax
  00820	74 0a		 je	 SHORT $LN189@ckd_dasd_h
  00822	b8 ff ff ff ff	 mov	 eax, -1
  00827	e9 ed 03 00 00	 jmp	 $LN1@ckd_dasd_h
$LN189@ckd_dasd_h:
  0082c	33 c0		 xor	 eax, eax
  0082e	85 c0		 test	 eax, eax
  00830	75 d3		 jne	 SHORT $LN96@ckd_dasd_h

; 1355 :             dev->ckdskcyl = rc;

  00832	8b 44 24 24	 mov	 eax, DWORD PTR rc$[rsp]
  00836	83 e0 01	 and	 eax, 1
  00839	c1 e0 07	 shl	 eax, 7
  0083c	48 8b 4c 24 60	 mov	 rcx, QWORD PTR dev$[rsp]
  00841	8b 89 14 13 00
	00		 mov	 ecx, DWORD PTR [rcx+4884]
  00847	0f ba f1 07	 btr	 ecx, 7
  0084b	0b c8		 or	 ecx, eax
  0084d	8b c1		 mov	 eax, ecx
  0084f	48 8b 4c 24 60	 mov	 rcx, QWORD PTR dev$[rsp]
  00854	89 81 14 13 00
	00		 mov	 DWORD PTR [rcx+4884], eax

; 1356 :             break;

  0085a	e9 9a 03 00 00	 jmp	 $LN8@ckd_dasd_h
$LN190@ckd_dasd_h:
$LN99@ckd_dasd_h:

; 1357 :         case SR_DEV_CKD_RECAL:
; 1358 :             SR_READ_VALUE(file, len, &rc, sizeof(rc));

  0085f	41 b9 04 00 00
	00		 mov	 r9d, 4
  00865	4c 8d 44 24 24	 lea	 r8, QWORD PTR rc$[rsp]
  0086a	8b 54 24 38	 mov	 edx, DWORD PTR len$[rsp]
  0086e	48 8b 4c 24 68	 mov	 rcx, QWORD PTR file$[rsp]
  00873	e8 00 00 00 00	 call	 sr_read_value
  00878	85 c0		 test	 eax, eax
  0087a	74 0a		 je	 SHORT $LN191@ckd_dasd_h
  0087c	b8 ff ff ff ff	 mov	 eax, -1
  00881	e9 93 03 00 00	 jmp	 $LN1@ckd_dasd_h
$LN191@ckd_dasd_h:
  00886	33 c0		 xor	 eax, eax
  00888	85 c0		 test	 eax, eax
  0088a	75 d3		 jne	 SHORT $LN99@ckd_dasd_h

; 1359 :             dev->ckdrecal = rc;

  0088c	8b 44 24 24	 mov	 eax, DWORD PTR rc$[rsp]
  00890	83 e0 01	 and	 eax, 1
  00893	c1 e0 08	 shl	 eax, 8
  00896	48 8b 4c 24 60	 mov	 rcx, QWORD PTR dev$[rsp]
  0089b	8b 89 14 13 00
	00		 mov	 ecx, DWORD PTR [rcx+4884]
  008a1	0f ba f1 08	 btr	 ecx, 8
  008a5	0b c8		 or	 ecx, eax
  008a7	8b c1		 mov	 eax, ecx
  008a9	48 8b 4c 24 60	 mov	 rcx, QWORD PTR dev$[rsp]
  008ae	89 81 14 13 00
	00		 mov	 DWORD PTR [rcx+4884], eax

; 1360 :             break;

  008b4	e9 40 03 00 00	 jmp	 $LN8@ckd_dasd_h
$LN192@ckd_dasd_h:
$LN102@ckd_dasd_h:

; 1361 :         case SR_DEV_CKD_RDIPL:
; 1362 :             SR_READ_VALUE(file, len, &rc, sizeof(rc));

  008b9	41 b9 04 00 00
	00		 mov	 r9d, 4
  008bf	4c 8d 44 24 24	 lea	 r8, QWORD PTR rc$[rsp]
  008c4	8b 54 24 38	 mov	 edx, DWORD PTR len$[rsp]
  008c8	48 8b 4c 24 68	 mov	 rcx, QWORD PTR file$[rsp]
  008cd	e8 00 00 00 00	 call	 sr_read_value
  008d2	85 c0		 test	 eax, eax
  008d4	74 0a		 je	 SHORT $LN193@ckd_dasd_h
  008d6	b8 ff ff ff ff	 mov	 eax, -1
  008db	e9 39 03 00 00	 jmp	 $LN1@ckd_dasd_h
$LN193@ckd_dasd_h:
  008e0	33 c0		 xor	 eax, eax
  008e2	85 c0		 test	 eax, eax
  008e4	75 d3		 jne	 SHORT $LN102@ckd_dasd_h

; 1363 :             dev->ckdrdipl = rc;

  008e6	8b 44 24 24	 mov	 eax, DWORD PTR rc$[rsp]
  008ea	83 e0 01	 and	 eax, 1
  008ed	c1 e0 09	 shl	 eax, 9
  008f0	48 8b 4c 24 60	 mov	 rcx, QWORD PTR dev$[rsp]
  008f5	8b 89 14 13 00
	00		 mov	 ecx, DWORD PTR [rcx+4884]
  008fb	0f ba f1 09	 btr	 ecx, 9
  008ff	0b c8		 or	 ecx, eax
  00901	8b c1		 mov	 eax, ecx
  00903	48 8b 4c 24 60	 mov	 rcx, QWORD PTR dev$[rsp]
  00908	89 81 14 13 00
	00		 mov	 DWORD PTR [rcx+4884], eax

; 1364 :             break;

  0090e	e9 e6 02 00 00	 jmp	 $LN8@ckd_dasd_h
$LN194@ckd_dasd_h:
$LN105@ckd_dasd_h:

; 1365 :         case SR_DEV_CKD_XMARK:
; 1366 :             SR_READ_VALUE(file, len, &rc, sizeof(rc));

  00913	41 b9 04 00 00
	00		 mov	 r9d, 4
  00919	4c 8d 44 24 24	 lea	 r8, QWORD PTR rc$[rsp]
  0091e	8b 54 24 38	 mov	 edx, DWORD PTR len$[rsp]
  00922	48 8b 4c 24 68	 mov	 rcx, QWORD PTR file$[rsp]
  00927	e8 00 00 00 00	 call	 sr_read_value
  0092c	85 c0		 test	 eax, eax
  0092e	74 0a		 je	 SHORT $LN195@ckd_dasd_h
  00930	b8 ff ff ff ff	 mov	 eax, -1
  00935	e9 df 02 00 00	 jmp	 $LN1@ckd_dasd_h
$LN195@ckd_dasd_h:
  0093a	33 c0		 xor	 eax, eax
  0093c	85 c0		 test	 eax, eax
  0093e	75 d3		 jne	 SHORT $LN105@ckd_dasd_h

; 1367 :             dev->ckdxmark = rc;

  00940	8b 44 24 24	 mov	 eax, DWORD PTR rc$[rsp]
  00944	83 e0 01	 and	 eax, 1
  00947	c1 e0 0a	 shl	 eax, 10
  0094a	48 8b 4c 24 60	 mov	 rcx, QWORD PTR dev$[rsp]
  0094f	8b 89 14 13 00
	00		 mov	 ecx, DWORD PTR [rcx+4884]
  00955	0f ba f1 0a	 btr	 ecx, 10
  00959	0b c8		 or	 ecx, eax
  0095b	8b c1		 mov	 eax, ecx
  0095d	48 8b 4c 24 60	 mov	 rcx, QWORD PTR dev$[rsp]
  00962	89 81 14 13 00
	00		 mov	 DWORD PTR [rcx+4884], eax

; 1368 :             break;

  00968	e9 8c 02 00 00	 jmp	 $LN8@ckd_dasd_h
$LN196@ckd_dasd_h:
$LN108@ckd_dasd_h:

; 1369 :         case SR_DEV_CKD_HAEQ:
; 1370 :             SR_READ_VALUE(file, len, &rc, sizeof(rc));

  0096d	41 b9 04 00 00
	00		 mov	 r9d, 4
  00973	4c 8d 44 24 24	 lea	 r8, QWORD PTR rc$[rsp]
  00978	8b 54 24 38	 mov	 edx, DWORD PTR len$[rsp]
  0097c	48 8b 4c 24 68	 mov	 rcx, QWORD PTR file$[rsp]
  00981	e8 00 00 00 00	 call	 sr_read_value
  00986	85 c0		 test	 eax, eax
  00988	74 0a		 je	 SHORT $LN197@ckd_dasd_h
  0098a	b8 ff ff ff ff	 mov	 eax, -1
  0098f	e9 85 02 00 00	 jmp	 $LN1@ckd_dasd_h
$LN197@ckd_dasd_h:
  00994	33 c0		 xor	 eax, eax
  00996	85 c0		 test	 eax, eax
  00998	75 d3		 jne	 SHORT $LN108@ckd_dasd_h

; 1371 :             dev->ckdhaeq = rc;

  0099a	8b 44 24 24	 mov	 eax, DWORD PTR rc$[rsp]
  0099e	83 e0 01	 and	 eax, 1
  009a1	c1 e0 0b	 shl	 eax, 11
  009a4	48 8b 4c 24 60	 mov	 rcx, QWORD PTR dev$[rsp]
  009a9	8b 89 14 13 00
	00		 mov	 ecx, DWORD PTR [rcx+4884]
  009af	0f ba f1 0b	 btr	 ecx, 11
  009b3	0b c8		 or	 ecx, eax
  009b5	8b c1		 mov	 eax, ecx
  009b7	48 8b 4c 24 60	 mov	 rcx, QWORD PTR dev$[rsp]
  009bc	89 81 14 13 00
	00		 mov	 DWORD PTR [rcx+4884], eax

; 1372 :             break;

  009c2	e9 32 02 00 00	 jmp	 $LN8@ckd_dasd_h
$LN198@ckd_dasd_h:
$LN111@ckd_dasd_h:

; 1373 :         case SR_DEV_CKD_IDEQ:
; 1374 :             SR_READ_VALUE(file, len, &rc, sizeof(rc));

  009c7	41 b9 04 00 00
	00		 mov	 r9d, 4
  009cd	4c 8d 44 24 24	 lea	 r8, QWORD PTR rc$[rsp]
  009d2	8b 54 24 38	 mov	 edx, DWORD PTR len$[rsp]
  009d6	48 8b 4c 24 68	 mov	 rcx, QWORD PTR file$[rsp]
  009db	e8 00 00 00 00	 call	 sr_read_value
  009e0	85 c0		 test	 eax, eax
  009e2	74 0a		 je	 SHORT $LN199@ckd_dasd_h
  009e4	b8 ff ff ff ff	 mov	 eax, -1
  009e9	e9 2b 02 00 00	 jmp	 $LN1@ckd_dasd_h
$LN199@ckd_dasd_h:
  009ee	33 c0		 xor	 eax, eax
  009f0	85 c0		 test	 eax, eax
  009f2	75 d3		 jne	 SHORT $LN111@ckd_dasd_h

; 1375 :             dev->ckdideq = rc;

  009f4	8b 44 24 24	 mov	 eax, DWORD PTR rc$[rsp]
  009f8	83 e0 01	 and	 eax, 1
  009fb	c1 e0 0c	 shl	 eax, 12
  009fe	48 8b 4c 24 60	 mov	 rcx, QWORD PTR dev$[rsp]
  00a03	8b 89 14 13 00
	00		 mov	 ecx, DWORD PTR [rcx+4884]
  00a09	0f ba f1 0c	 btr	 ecx, 12
  00a0d	0b c8		 or	 ecx, eax
  00a0f	8b c1		 mov	 eax, ecx
  00a11	48 8b 4c 24 60	 mov	 rcx, QWORD PTR dev$[rsp]
  00a16	89 81 14 13 00
	00		 mov	 DWORD PTR [rcx+4884], eax

; 1376 :             break;

  00a1c	e9 d8 01 00 00	 jmp	 $LN8@ckd_dasd_h
$LN200@ckd_dasd_h:
$LN114@ckd_dasd_h:

; 1377 :         case SR_DEV_CKD_KYEQ:
; 1378 :             SR_READ_VALUE(file, len, &rc, sizeof(rc));

  00a21	41 b9 04 00 00
	00		 mov	 r9d, 4
  00a27	4c 8d 44 24 24	 lea	 r8, QWORD PTR rc$[rsp]
  00a2c	8b 54 24 38	 mov	 edx, DWORD PTR len$[rsp]
  00a30	48 8b 4c 24 68	 mov	 rcx, QWORD PTR file$[rsp]
  00a35	e8 00 00 00 00	 call	 sr_read_value
  00a3a	85 c0		 test	 eax, eax
  00a3c	74 0a		 je	 SHORT $LN201@ckd_dasd_h
  00a3e	b8 ff ff ff ff	 mov	 eax, -1
  00a43	e9 d1 01 00 00	 jmp	 $LN1@ckd_dasd_h
$LN201@ckd_dasd_h:
  00a48	33 c0		 xor	 eax, eax
  00a4a	85 c0		 test	 eax, eax
  00a4c	75 d3		 jne	 SHORT $LN114@ckd_dasd_h

; 1379 :             dev->ckdkyeq = rc;

  00a4e	8b 44 24 24	 mov	 eax, DWORD PTR rc$[rsp]
  00a52	83 e0 01	 and	 eax, 1
  00a55	c1 e0 0d	 shl	 eax, 13
  00a58	48 8b 4c 24 60	 mov	 rcx, QWORD PTR dev$[rsp]
  00a5d	8b 89 14 13 00
	00		 mov	 ecx, DWORD PTR [rcx+4884]
  00a63	0f ba f1 0d	 btr	 ecx, 13
  00a67	0b c8		 or	 ecx, eax
  00a69	8b c1		 mov	 eax, ecx
  00a6b	48 8b 4c 24 60	 mov	 rcx, QWORD PTR dev$[rsp]
  00a70	89 81 14 13 00
	00		 mov	 DWORD PTR [rcx+4884], eax

; 1380 :             break;

  00a76	e9 7e 01 00 00	 jmp	 $LN8@ckd_dasd_h
$LN202@ckd_dasd_h:
$LN117@ckd_dasd_h:

; 1381 :         case SR_DEV_CKD_WCKD:
; 1382 :             SR_READ_VALUE(file, len, &rc, sizeof(rc));

  00a7b	41 b9 04 00 00
	00		 mov	 r9d, 4
  00a81	4c 8d 44 24 24	 lea	 r8, QWORD PTR rc$[rsp]
  00a86	8b 54 24 38	 mov	 edx, DWORD PTR len$[rsp]
  00a8a	48 8b 4c 24 68	 mov	 rcx, QWORD PTR file$[rsp]
  00a8f	e8 00 00 00 00	 call	 sr_read_value
  00a94	85 c0		 test	 eax, eax
  00a96	74 0a		 je	 SHORT $LN203@ckd_dasd_h
  00a98	b8 ff ff ff ff	 mov	 eax, -1
  00a9d	e9 77 01 00 00	 jmp	 $LN1@ckd_dasd_h
$LN203@ckd_dasd_h:
  00aa2	33 c0		 xor	 eax, eax
  00aa4	85 c0		 test	 eax, eax
  00aa6	75 d3		 jne	 SHORT $LN117@ckd_dasd_h

; 1383 :             dev->ckdwckd = rc;

  00aa8	8b 44 24 24	 mov	 eax, DWORD PTR rc$[rsp]
  00aac	83 e0 01	 and	 eax, 1
  00aaf	c1 e0 0e	 shl	 eax, 14
  00ab2	48 8b 4c 24 60	 mov	 rcx, QWORD PTR dev$[rsp]
  00ab7	8b 89 14 13 00
	00		 mov	 ecx, DWORD PTR [rcx+4884]
  00abd	0f ba f1 0e	 btr	 ecx, 14
  00ac1	0b c8		 or	 ecx, eax
  00ac3	8b c1		 mov	 eax, ecx
  00ac5	48 8b 4c 24 60	 mov	 rcx, QWORD PTR dev$[rsp]
  00aca	89 81 14 13 00
	00		 mov	 DWORD PTR [rcx+4884], eax

; 1384 :             break;

  00ad0	e9 24 01 00 00	 jmp	 $LN8@ckd_dasd_h
$LN204@ckd_dasd_h:
$LN120@ckd_dasd_h:

; 1385 :         case SR_DEV_CKD_TRKOF:
; 1386 :             SR_READ_VALUE(file, len, &rc, sizeof(rc));

  00ad5	41 b9 04 00 00
	00		 mov	 r9d, 4
  00adb	4c 8d 44 24 24	 lea	 r8, QWORD PTR rc$[rsp]
  00ae0	8b 54 24 38	 mov	 edx, DWORD PTR len$[rsp]
  00ae4	48 8b 4c 24 68	 mov	 rcx, QWORD PTR file$[rsp]
  00ae9	e8 00 00 00 00	 call	 sr_read_value
  00aee	85 c0		 test	 eax, eax
  00af0	74 0a		 je	 SHORT $LN205@ckd_dasd_h
  00af2	b8 ff ff ff ff	 mov	 eax, -1
  00af7	e9 1d 01 00 00	 jmp	 $LN1@ckd_dasd_h
$LN205@ckd_dasd_h:
  00afc	33 c0		 xor	 eax, eax
  00afe	85 c0		 test	 eax, eax
  00b00	75 d3		 jne	 SHORT $LN120@ckd_dasd_h

; 1387 :             dev->ckdtrkof = rc;

  00b02	8b 44 24 24	 mov	 eax, DWORD PTR rc$[rsp]
  00b06	83 e0 01	 and	 eax, 1
  00b09	c1 e0 0f	 shl	 eax, 15
  00b0c	48 8b 4c 24 60	 mov	 rcx, QWORD PTR dev$[rsp]
  00b11	8b 89 14 13 00
	00		 mov	 ecx, DWORD PTR [rcx+4884]
  00b17	0f ba f1 0f	 btr	 ecx, 15
  00b1b	0b c8		 or	 ecx, eax
  00b1d	8b c1		 mov	 eax, ecx
  00b1f	48 8b 4c 24 60	 mov	 rcx, QWORD PTR dev$[rsp]
  00b24	89 81 14 13 00
	00		 mov	 DWORD PTR [rcx+4884], eax

; 1388 :             break;

  00b2a	e9 ca 00 00 00	 jmp	 $LN8@ckd_dasd_h
$LN206@ckd_dasd_h:
$LN123@ckd_dasd_h:

; 1389 :         case SR_DEV_CKD_SSI:
; 1390 :             SR_READ_VALUE(file, len, &rc, sizeof(rc));

  00b2f	41 b9 04 00 00
	00		 mov	 r9d, 4
  00b35	4c 8d 44 24 24	 lea	 r8, QWORD PTR rc$[rsp]
  00b3a	8b 54 24 38	 mov	 edx, DWORD PTR len$[rsp]
  00b3e	48 8b 4c 24 68	 mov	 rcx, QWORD PTR file$[rsp]
  00b43	e8 00 00 00 00	 call	 sr_read_value
  00b48	85 c0		 test	 eax, eax
  00b4a	74 0a		 je	 SHORT $LN207@ckd_dasd_h
  00b4c	b8 ff ff ff ff	 mov	 eax, -1
  00b51	e9 c3 00 00 00	 jmp	 $LN1@ckd_dasd_h
$LN207@ckd_dasd_h:
  00b56	33 c0		 xor	 eax, eax
  00b58	85 c0		 test	 eax, eax
  00b5a	75 d3		 jne	 SHORT $LN123@ckd_dasd_h

; 1391 :             dev->ckdssi = rc;

  00b5c	8b 44 24 24	 mov	 eax, DWORD PTR rc$[rsp]
  00b60	83 e0 01	 and	 eax, 1
  00b63	c1 e0 10	 shl	 eax, 16
  00b66	48 8b 4c 24 60	 mov	 rcx, QWORD PTR dev$[rsp]
  00b6b	8b 89 14 13 00
	00		 mov	 ecx, DWORD PTR [rcx+4884]
  00b71	0f ba f1 10	 btr	 ecx, 16
  00b75	0b c8		 or	 ecx, eax
  00b77	8b c1		 mov	 eax, ecx
  00b79	48 8b 4c 24 60	 mov	 rcx, QWORD PTR dev$[rsp]
  00b7e	89 81 14 13 00
	00		 mov	 DWORD PTR [rcx+4884], eax

; 1392 :             break;

  00b84	eb 73		 jmp	 SHORT $LN8@ckd_dasd_h
$LN208@ckd_dasd_h:
$LN126@ckd_dasd_h:

; 1393 :         case SR_DEV_CKD_WRHA:
; 1394 :             SR_READ_VALUE(file, len, &rc, sizeof(rc));

  00b86	41 b9 04 00 00
	00		 mov	 r9d, 4
  00b8c	4c 8d 44 24 24	 lea	 r8, QWORD PTR rc$[rsp]
  00b91	8b 54 24 38	 mov	 edx, DWORD PTR len$[rsp]
  00b95	48 8b 4c 24 68	 mov	 rcx, QWORD PTR file$[rsp]
  00b9a	e8 00 00 00 00	 call	 sr_read_value
  00b9f	85 c0		 test	 eax, eax
  00ba1	74 07		 je	 SHORT $LN209@ckd_dasd_h
  00ba3	b8 ff ff ff ff	 mov	 eax, -1
  00ba8	eb 6f		 jmp	 SHORT $LN1@ckd_dasd_h
$LN209@ckd_dasd_h:
  00baa	33 c0		 xor	 eax, eax
  00bac	85 c0		 test	 eax, eax
  00bae	75 d6		 jne	 SHORT $LN126@ckd_dasd_h

; 1395 :             dev->ckdwrha = rc;

  00bb0	8b 44 24 24	 mov	 eax, DWORD PTR rc$[rsp]
  00bb4	83 e0 01	 and	 eax, 1
  00bb7	c1 e0 13	 shl	 eax, 19
  00bba	48 8b 4c 24 60	 mov	 rcx, QWORD PTR dev$[rsp]
  00bbf	8b 89 14 13 00
	00		 mov	 ecx, DWORD PTR [rcx+4884]
  00bc5	0f ba f1 13	 btr	 ecx, 19
  00bc9	0b c8		 or	 ecx, eax
  00bcb	8b c1		 mov	 eax, ecx
  00bcd	48 8b 4c 24 60	 mov	 rcx, QWORD PTR dev$[rsp]
  00bd2	89 81 14 13 00
	00		 mov	 DWORD PTR [rcx+4884], eax

; 1396 :             break;

  00bd8	eb 1f		 jmp	 SHORT $LN8@ckd_dasd_h
$LN210@ckd_dasd_h:
$LN129@ckd_dasd_h:

; 1397 :         default:
; 1398 :             SR_READ_SKIP(file, len);

  00bda	8b 54 24 38	 mov	 edx, DWORD PTR len$[rsp]
  00bde	48 8b 4c 24 68	 mov	 rcx, QWORD PTR file$[rsp]
  00be3	e8 00 00 00 00	 call	 sr_read_skip
  00be8	85 c0		 test	 eax, eax
  00bea	74 07		 je	 SHORT $LN211@ckd_dasd_h
  00bec	b8 ff ff ff ff	 mov	 eax, -1
  00bf1	eb 26		 jmp	 SHORT $LN1@ckd_dasd_h
$LN211@ckd_dasd_h:
  00bf3	33 c0		 xor	 eax, eax
  00bf5	85 c0		 test	 eax, eax
  00bf7	75 e1		 jne	 SHORT $LN129@ckd_dasd_h
$LN8@ckd_dasd_h:

; 1399 :             break;
; 1400 :         } /* switch (key) */
; 1401 :     } while ((key & SR_DEV_MASK) == SR_DEV_CKD);

  00bf9	b8 00 f0 ff ff	 mov	 eax, -4096		; fffff000H
  00bfe	48 8b 4c 24 48	 mov	 rcx, QWORD PTR key$[rsp]
  00c03	48 23 c8	 and	 rcx, rax
  00c06	48 8b c1	 mov	 rax, rcx
  00c09	b9 00 10 e3 ac	 mov	 ecx, -1394405376	; ace31000H
  00c0e	48 3b c1	 cmp	 rax, rcx
  00c11	0f 84 f7 f3 ff
	ff		 je	 $LN4@ckd_dasd_h

; 1402 :     return 0;

  00c17	33 c0		 xor	 eax, eax
$LN1@ckd_dasd_h:

; 1403 : }

  00c19	48 83 c4 58	 add	 rsp, 88			; 00000058H
  00c1d	c3		 ret	 0
  00c1e	66 90		 npad	 2
$LN216@ckd_dasd_h:
  00c20	00 00 00 00	 DD	 $LN131@ckd_dasd_h
  00c24	00 00 00 00	 DD	 $LN134@ckd_dasd_h
  00c28	00 00 00 00	 DD	 $LN136@ckd_dasd_h
  00c2c	00 00 00 00	 DD	 $LN138@ckd_dasd_h
  00c30	00 00 00 00	 DD	 $LN140@ckd_dasd_h
  00c34	00 00 00 00	 DD	 $LN142@ckd_dasd_h
  00c38	00 00 00 00	 DD	 $LN144@ckd_dasd_h
  00c3c	00 00 00 00	 DD	 $LN146@ckd_dasd_h
  00c40	00 00 00 00	 DD	 $LN148@ckd_dasd_h
  00c44	00 00 00 00	 DD	 $LN150@ckd_dasd_h
  00c48	00 00 00 00	 DD	 $LN152@ckd_dasd_h
  00c4c	00 00 00 00	 DD	 $LN154@ckd_dasd_h
  00c50	00 00 00 00	 DD	 $LN156@ckd_dasd_h
  00c54	00 00 00 00	 DD	 $LN158@ckd_dasd_h
  00c58	00 00 00 00	 DD	 $LN160@ckd_dasd_h
  00c5c	00 00 00 00	 DD	 $LN162@ckd_dasd_h
  00c60	00 00 00 00	 DD	 $LN164@ckd_dasd_h
  00c64	00 00 00 00	 DD	 $LN166@ckd_dasd_h
  00c68	00 00 00 00	 DD	 $LN168@ckd_dasd_h
  00c6c	00 00 00 00	 DD	 $LN170@ckd_dasd_h
  00c70	00 00 00 00	 DD	 $LN172@ckd_dasd_h
  00c74	00 00 00 00	 DD	 $LN174@ckd_dasd_h
  00c78	00 00 00 00	 DD	 $LN176@ckd_dasd_h
  00c7c	00 00 00 00	 DD	 $LN178@ckd_dasd_h
  00c80	00 00 00 00	 DD	 $LN180@ckd_dasd_h
  00c84	00 00 00 00	 DD	 $LN182@ckd_dasd_h
  00c88	00 00 00 00	 DD	 $LN184@ckd_dasd_h
  00c8c	00 00 00 00	 DD	 $LN186@ckd_dasd_h
  00c90	00 00 00 00	 DD	 $LN188@ckd_dasd_h
  00c94	00 00 00 00	 DD	 $LN190@ckd_dasd_h
  00c98	00 00 00 00	 DD	 $LN192@ckd_dasd_h
  00c9c	00 00 00 00	 DD	 $LN194@ckd_dasd_h
  00ca0	00 00 00 00	 DD	 $LN196@ckd_dasd_h
  00ca4	00 00 00 00	 DD	 $LN198@ckd_dasd_h
  00ca8	00 00 00 00	 DD	 $LN200@ckd_dasd_h
  00cac	00 00 00 00	 DD	 $LN202@ckd_dasd_h
  00cb0	00 00 00 00	 DD	 $LN204@ckd_dasd_h
  00cb4	00 00 00 00	 DD	 $LN206@ckd_dasd_h
  00cb8	00 00 00 00	 DD	 $LN208@ckd_dasd_h
  00cbc	00 00 00 00	 DD	 $LN210@ckd_dasd_h
$LN215@ckd_dasd_h:
  00cc0	00		 DB	 0
  00cc1	01		 DB	 1
  00cc2	02		 DB	 2
  00cc3	03		 DB	 3
  00cc4	04		 DB	 4
  00cc5	05		 DB	 5
  00cc6	06		 DB	 6
  00cc7	07		 DB	 7
  00cc8	08		 DB	 8
  00cc9	09		 DB	 9
  00cca	0a		 DB	 10
  00ccb	27		 DB	 39			; 00000027H
  00ccc	27		 DB	 39			; 00000027H
  00ccd	27		 DB	 39			; 00000027H
  00cce	27		 DB	 39			; 00000027H
  00ccf	0b		 DB	 11
  00cd0	0c		 DB	 12
  00cd1	0d		 DB	 13
  00cd2	0e		 DB	 14
  00cd3	0f		 DB	 15
  00cd4	10		 DB	 16
  00cd5	11		 DB	 17
  00cd6	27		 DB	 39			; 00000027H
  00cd7	27		 DB	 39			; 00000027H
  00cd8	27		 DB	 39			; 00000027H
  00cd9	27		 DB	 39			; 00000027H
  00cda	27		 DB	 39			; 00000027H
  00cdb	27		 DB	 39			; 00000027H
  00cdc	27		 DB	 39			; 00000027H
  00cdd	27		 DB	 39			; 00000027H
  00cde	27		 DB	 39			; 00000027H
  00cdf	12		 DB	 18
  00ce0	13		 DB	 19
  00ce1	14		 DB	 20
  00ce2	15		 DB	 21
  00ce3	27		 DB	 39			; 00000027H
  00ce4	27		 DB	 39			; 00000027H
  00ce5	27		 DB	 39			; 00000027H
  00ce6	27		 DB	 39			; 00000027H
  00ce7	27		 DB	 39			; 00000027H
  00ce8	27		 DB	 39			; 00000027H
  00ce9	27		 DB	 39			; 00000027H
  00cea	27		 DB	 39			; 00000027H
  00ceb	27		 DB	 39			; 00000027H
  00cec	27		 DB	 39			; 00000027H
  00ced	27		 DB	 39			; 00000027H
  00cee	27		 DB	 39			; 00000027H
  00cef	27		 DB	 39			; 00000027H
  00cf0	27		 DB	 39			; 00000027H
  00cf1	27		 DB	 39			; 00000027H
  00cf2	27		 DB	 39			; 00000027H
  00cf3	27		 DB	 39			; 00000027H
  00cf4	27		 DB	 39			; 00000027H
  00cf5	27		 DB	 39			; 00000027H
  00cf6	27		 DB	 39			; 00000027H
  00cf7	27		 DB	 39			; 00000027H
  00cf8	27		 DB	 39			; 00000027H
  00cf9	27		 DB	 39			; 00000027H
  00cfa	27		 DB	 39			; 00000027H
  00cfb	27		 DB	 39			; 00000027H
  00cfc	27		 DB	 39			; 00000027H
  00cfd	27		 DB	 39			; 00000027H
  00cfe	27		 DB	 39			; 00000027H
  00cff	16		 DB	 22
  00d00	17		 DB	 23
  00d01	18		 DB	 24
  00d02	19		 DB	 25
  00d03	1a		 DB	 26
  00d04	1b		 DB	 27
  00d05	1c		 DB	 28
  00d06	1d		 DB	 29
  00d07	1e		 DB	 30
  00d08	1f		 DB	 31
  00d09	20		 DB	 32			; 00000020H
  00d0a	21		 DB	 33			; 00000021H
  00d0b	22		 DB	 34			; 00000022H
  00d0c	23		 DB	 35			; 00000023H
  00d0d	24		 DB	 36			; 00000024H
  00d0e	25		 DB	 37			; 00000025H
  00d0f	26		 DB	 38			; 00000026H
ckd_dasd_hresume ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\ckddasd.c
_TEXT	SEGMENT
dev$ = 48
file$ = 56
ckd_dasd_hsuspend PROC

; 1201 : {

$LN160:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 1202 :     if (dev->bufcur >= 0)

  0000e	48 8b 44 24 30	 mov	 rax, QWORD PTR dev$[rsp]
  00013	83 b8 c0 01 00
	00 00		 cmp	 DWORD PTR [rax+448], 0
  0001a	7c 70		 jl	 SHORT $LN119@ckd_dasd_h
$LN4@ckd_dasd_h:

; 1203 :     {
; 1204 :         SR_WRITE_VALUE( file, SR_DEV_CKD_BUFCUR, dev->bufcur, sizeof( dev->bufcur ));

  0001c	48 8b 44 24 30	 mov	 rax, QWORD PTR dev$[rsp]
  00021	48 63 80 c0 01
	00 00		 movsxd	 rax, DWORD PTR [rax+448]
  00028	41 b9 04 00 00
	00		 mov	 r9d, 4
  0002e	4c 8b c0	 mov	 r8, rax
  00031	ba 01 10 e3 ac	 mov	 edx, -1394405375	; ace31001H
  00036	48 8b 4c 24 38	 mov	 rcx, QWORD PTR file$[rsp]
  0003b	e8 00 00 00 00	 call	 sr_write_value
  00040	85 c0		 test	 eax, eax
  00042	74 0a		 je	 SHORT $LN120@ckd_dasd_h
  00044	b8 ff ff ff ff	 mov	 eax, -1
  00049	e9 c5 08 00 00	 jmp	 $LN1@ckd_dasd_h
$LN120@ckd_dasd_h:
  0004e	33 c0		 xor	 eax, eax
  00050	85 c0		 test	 eax, eax
  00052	75 c8		 jne	 SHORT $LN4@ckd_dasd_h
$LN7@ckd_dasd_h:

; 1205 :         SR_WRITE_VALUE( file, SR_DEV_CKD_BUFOFF, dev->bufoff, sizeof( dev->bufoff ));

  00054	48 8b 44 24 30	 mov	 rax, QWORD PTR dev$[rsp]
  00059	48 63 80 e0 01
	00 00		 movsxd	 rax, DWORD PTR [rax+480]
  00060	41 b9 04 00 00
	00		 mov	 r9d, 4
  00066	4c 8b c0	 mov	 r8, rax
  00069	ba 02 10 e3 ac	 mov	 edx, -1394405374	; ace31002H
  0006e	48 8b 4c 24 38	 mov	 rcx, QWORD PTR file$[rsp]
  00073	e8 00 00 00 00	 call	 sr_write_value
  00078	85 c0		 test	 eax, eax
  0007a	74 0a		 je	 SHORT $LN121@ckd_dasd_h
  0007c	b8 ff ff ff ff	 mov	 eax, -1
  00081	e9 8d 08 00 00	 jmp	 $LN1@ckd_dasd_h
$LN121@ckd_dasd_h:
  00086	33 c0		 xor	 eax, eax
  00088	85 c0		 test	 eax, eax
  0008a	75 c8		 jne	 SHORT $LN7@ckd_dasd_h
$LN119@ckd_dasd_h:
$LN10@ckd_dasd_h:

; 1206 :     }
; 1207 : 
; 1208 :     SR_WRITE_VALUE( file, SR_DEV_CKD_CURCYL,   dev->ckdcurcyl,  sizeof( dev->ckdcurcyl  ));

  0008c	48 8b 44 24 30	 mov	 rax, QWORD PTR dev$[rsp]
  00091	48 63 80 c8 12
	00 00		 movsxd	 rax, DWORD PTR [rax+4808]
  00098	41 b9 04 00 00
	00		 mov	 r9d, 4
  0009e	4c 8b c0	 mov	 r8, rax
  000a1	ba 03 10 e3 ac	 mov	 edx, -1394405373	; ace31003H
  000a6	48 8b 4c 24 38	 mov	 rcx, QWORD PTR file$[rsp]
  000ab	e8 00 00 00 00	 call	 sr_write_value
  000b0	85 c0		 test	 eax, eax
  000b2	74 0a		 je	 SHORT $LN122@ckd_dasd_h
  000b4	b8 ff ff ff ff	 mov	 eax, -1
  000b9	e9 55 08 00 00	 jmp	 $LN1@ckd_dasd_h
$LN122@ckd_dasd_h:
  000be	33 c0		 xor	 eax, eax
  000c0	85 c0		 test	 eax, eax
  000c2	75 c8		 jne	 SHORT $LN10@ckd_dasd_h
$LN13@ckd_dasd_h:

; 1209 :     SR_WRITE_VALUE( file, SR_DEV_CKD_CURHEAD,  dev->ckdcurhead, sizeof( dev->ckdcurhead ));

  000c4	48 8b 44 24 30	 mov	 rax, QWORD PTR dev$[rsp]
  000c9	48 63 80 cc 12
	00 00		 movsxd	 rax, DWORD PTR [rax+4812]
  000d0	41 b9 04 00 00
	00		 mov	 r9d, 4
  000d6	4c 8b c0	 mov	 r8, rax
  000d9	ba 04 10 e3 ac	 mov	 edx, -1394405372	; ace31004H
  000de	48 8b 4c 24 38	 mov	 rcx, QWORD PTR file$[rsp]
  000e3	e8 00 00 00 00	 call	 sr_write_value
  000e8	85 c0		 test	 eax, eax
  000ea	74 0a		 je	 SHORT $LN123@ckd_dasd_h
  000ec	b8 ff ff ff ff	 mov	 eax, -1
  000f1	e9 1d 08 00 00	 jmp	 $LN1@ckd_dasd_h
$LN123@ckd_dasd_h:
  000f6	33 c0		 xor	 eax, eax
  000f8	85 c0		 test	 eax, eax
  000fa	75 c8		 jne	 SHORT $LN13@ckd_dasd_h
$LN16@ckd_dasd_h:

; 1210 :     SR_WRITE_VALUE( file, SR_DEV_CKD_CURREC,   dev->ckdcurrec,  sizeof( dev->ckdcurrec  ));

  000fc	48 8b 44 24 30	 mov	 rax, QWORD PTR dev$[rsp]
  00101	48 63 80 d0 12
	00 00		 movsxd	 rax, DWORD PTR [rax+4816]
  00108	41 b9 04 00 00
	00		 mov	 r9d, 4
  0010e	4c 8b c0	 mov	 r8, rax
  00111	ba 05 10 e3 ac	 mov	 edx, -1394405371	; ace31005H
  00116	48 8b 4c 24 38	 mov	 rcx, QWORD PTR file$[rsp]
  0011b	e8 00 00 00 00	 call	 sr_write_value
  00120	85 c0		 test	 eax, eax
  00122	74 0a		 je	 SHORT $LN124@ckd_dasd_h
  00124	b8 ff ff ff ff	 mov	 eax, -1
  00129	e9 e5 07 00 00	 jmp	 $LN1@ckd_dasd_h
$LN124@ckd_dasd_h:
  0012e	33 c0		 xor	 eax, eax
  00130	85 c0		 test	 eax, eax
  00132	75 c8		 jne	 SHORT $LN16@ckd_dasd_h
$LN19@ckd_dasd_h:

; 1211 :     SR_WRITE_VALUE( file, SR_DEV_CKD_CURKL,    dev->ckdcurkl,   sizeof( dev->ckdcurkl   ));

  00134	48 8b 44 24 30	 mov	 rax, QWORD PTR dev$[rsp]
  00139	48 63 80 d4 12
	00 00		 movsxd	 rax, DWORD PTR [rax+4820]
  00140	41 b9 04 00 00
	00		 mov	 r9d, 4
  00146	4c 8b c0	 mov	 r8, rax
  00149	ba 06 10 e3 ac	 mov	 edx, -1394405370	; ace31006H
  0014e	48 8b 4c 24 38	 mov	 rcx, QWORD PTR file$[rsp]
  00153	e8 00 00 00 00	 call	 sr_write_value
  00158	85 c0		 test	 eax, eax
  0015a	74 0a		 je	 SHORT $LN125@ckd_dasd_h
  0015c	b8 ff ff ff ff	 mov	 eax, -1
  00161	e9 ad 07 00 00	 jmp	 $LN1@ckd_dasd_h
$LN125@ckd_dasd_h:
  00166	33 c0		 xor	 eax, eax
  00168	85 c0		 test	 eax, eax
  0016a	75 c8		 jne	 SHORT $LN19@ckd_dasd_h
$LN22@ckd_dasd_h:

; 1212 :     SR_WRITE_VALUE( file, SR_DEV_CKD_ORIENT,   dev->ckdorient,  sizeof( dev->ckdorient  ));

  0016c	48 8b 44 24 30	 mov	 rax, QWORD PTR dev$[rsp]
  00171	48 63 80 d8 12
	00 00		 movsxd	 rax, DWORD PTR [rax+4824]
  00178	41 b9 04 00 00
	00		 mov	 r9d, 4
  0017e	4c 8b c0	 mov	 r8, rax
  00181	ba 07 10 e3 ac	 mov	 edx, -1394405369	; ace31007H
  00186	48 8b 4c 24 38	 mov	 rcx, QWORD PTR file$[rsp]
  0018b	e8 00 00 00 00	 call	 sr_write_value
  00190	85 c0		 test	 eax, eax
  00192	74 0a		 je	 SHORT $LN126@ckd_dasd_h
  00194	b8 ff ff ff ff	 mov	 eax, -1
  00199	e9 75 07 00 00	 jmp	 $LN1@ckd_dasd_h
$LN126@ckd_dasd_h:
  0019e	33 c0		 xor	 eax, eax
  001a0	85 c0		 test	 eax, eax
  001a2	75 c8		 jne	 SHORT $LN22@ckd_dasd_h
$LN25@ckd_dasd_h:

; 1213 :     SR_WRITE_VALUE( file, SR_DEV_CKD_CUROPER,  dev->ckdcuroper, sizeof( dev->ckdcuroper ));

  001a4	48 8b 44 24 30	 mov	 rax, QWORD PTR dev$[rsp]
  001a9	48 63 80 dc 12
	00 00		 movsxd	 rax, DWORD PTR [rax+4828]
  001b0	41 b9 04 00 00
	00		 mov	 r9d, 4
  001b6	4c 8b c0	 mov	 r8, rax
  001b9	ba 08 10 e3 ac	 mov	 edx, -1394405368	; ace31008H
  001be	48 8b 4c 24 38	 mov	 rcx, QWORD PTR file$[rsp]
  001c3	e8 00 00 00 00	 call	 sr_write_value
  001c8	85 c0		 test	 eax, eax
  001ca	74 0a		 je	 SHORT $LN127@ckd_dasd_h
  001cc	b8 ff ff ff ff	 mov	 eax, -1
  001d1	e9 3d 07 00 00	 jmp	 $LN1@ckd_dasd_h
$LN127@ckd_dasd_h:
  001d6	33 c0		 xor	 eax, eax
  001d8	85 c0		 test	 eax, eax
  001da	75 c8		 jne	 SHORT $LN25@ckd_dasd_h
$LN28@ckd_dasd_h:

; 1214 :     SR_WRITE_VALUE( file, SR_DEV_CKD_CURDL,    dev->ckdcurdl,   sizeof( dev->ckdcurdl   ));

  001dc	48 8b 44 24 30	 mov	 rax, QWORD PTR dev$[rsp]
  001e1	0f b7 80 ea 12
	00 00		 movzx	 eax, WORD PTR [rax+4842]
  001e8	41 b9 02 00 00
	00		 mov	 r9d, 2
  001ee	44 8b c0	 mov	 r8d, eax
  001f1	ba 09 10 e3 ac	 mov	 edx, -1394405367	; ace31009H
  001f6	48 8b 4c 24 38	 mov	 rcx, QWORD PTR file$[rsp]
  001fb	e8 00 00 00 00	 call	 sr_write_value
  00200	85 c0		 test	 eax, eax
  00202	74 0a		 je	 SHORT $LN128@ckd_dasd_h
  00204	b8 ff ff ff ff	 mov	 eax, -1
  00209	e9 05 07 00 00	 jmp	 $LN1@ckd_dasd_h
$LN128@ckd_dasd_h:
  0020e	33 c0		 xor	 eax, eax
  00210	85 c0		 test	 eax, eax
  00212	75 c8		 jne	 SHORT $LN28@ckd_dasd_h
$LN31@ckd_dasd_h:

; 1215 :     SR_WRITE_VALUE( file, SR_DEV_CKD_REM,      dev->ckdrem,     sizeof( dev->ckdrem     ));

  00214	48 8b 44 24 30	 mov	 rax, QWORD PTR dev$[rsp]
  00219	0f b7 80 ec 12
	00 00		 movzx	 eax, WORD PTR [rax+4844]
  00220	41 b9 02 00 00
	00		 mov	 r9d, 2
  00226	44 8b c0	 mov	 r8d, eax
  00229	ba 0a 10 e3 ac	 mov	 edx, -1394405366	; ace3100aH
  0022e	48 8b 4c 24 38	 mov	 rcx, QWORD PTR file$[rsp]
  00233	e8 00 00 00 00	 call	 sr_write_value
  00238	85 c0		 test	 eax, eax
  0023a	74 0a		 je	 SHORT $LN129@ckd_dasd_h
  0023c	b8 ff ff ff ff	 mov	 eax, -1
  00241	e9 cd 06 00 00	 jmp	 $LN1@ckd_dasd_h
$LN129@ckd_dasd_h:
  00246	33 c0		 xor	 eax, eax
  00248	85 c0		 test	 eax, eax
  0024a	75 c8		 jne	 SHORT $LN31@ckd_dasd_h
$LN34@ckd_dasd_h:

; 1216 :     SR_WRITE_VALUE( file, SR_DEV_CKD_POS,      dev->ckdpos,     sizeof( dev->ckdpos     ));

  0024c	48 8b 44 24 30	 mov	 rax, QWORD PTR dev$[rsp]
  00251	0f b7 80 ee 12
	00 00		 movzx	 eax, WORD PTR [rax+4846]
  00258	41 b9 02 00 00
	00		 mov	 r9d, 2
  0025e	44 8b c0	 mov	 r8d, eax
  00261	ba 0b 10 e3 ac	 mov	 edx, -1394405365	; ace3100bH
  00266	48 8b 4c 24 38	 mov	 rcx, QWORD PTR file$[rsp]
  0026b	e8 00 00 00 00	 call	 sr_write_value
  00270	85 c0		 test	 eax, eax
  00272	74 0a		 je	 SHORT $LN130@ckd_dasd_h
  00274	b8 ff ff ff ff	 mov	 eax, -1
  00279	e9 95 06 00 00	 jmp	 $LN1@ckd_dasd_h
$LN130@ckd_dasd_h:
  0027e	33 c0		 xor	 eax, eax
  00280	85 c0		 test	 eax, eax
  00282	75 c8		 jne	 SHORT $LN34@ckd_dasd_h
$LN37@ckd_dasd_h:

; 1217 :     SR_WRITE_VALUE( file, SR_DEV_CKD_DXBLKSZ,  dev->ckdxblksz,  sizeof( dev->ckdxblksz  ));

  00284	48 8b 44 24 30	 mov	 rax, QWORD PTR dev$[rsp]
  00289	0f b7 80 f0 12
	00 00		 movzx	 eax, WORD PTR [rax+4848]
  00290	41 b9 02 00 00
	00		 mov	 r9d, 2
  00296	44 8b c0	 mov	 r8d, eax
  00299	ba 10 10 e3 ac	 mov	 edx, -1394405360	; ace31010H
  0029e	48 8b 4c 24 38	 mov	 rcx, QWORD PTR file$[rsp]
  002a3	e8 00 00 00 00	 call	 sr_write_value
  002a8	85 c0		 test	 eax, eax
  002aa	74 0a		 je	 SHORT $LN131@ckd_dasd_h
  002ac	b8 ff ff ff ff	 mov	 eax, -1
  002b1	e9 5d 06 00 00	 jmp	 $LN1@ckd_dasd_h
$LN131@ckd_dasd_h:
  002b6	33 c0		 xor	 eax, eax
  002b8	85 c0		 test	 eax, eax
  002ba	75 c8		 jne	 SHORT $LN37@ckd_dasd_h
$LN40@ckd_dasd_h:

; 1218 :     SR_WRITE_VALUE( file, SR_DEV_CKD_DXBCYL,   dev->ckdxbcyl,   sizeof( dev->ckdxbcyl   ));

  002bc	48 8b 44 24 30	 mov	 rax, QWORD PTR dev$[rsp]
  002c1	0f b7 80 f2 12
	00 00		 movzx	 eax, WORD PTR [rax+4850]
  002c8	41 b9 02 00 00
	00		 mov	 r9d, 2
  002ce	44 8b c0	 mov	 r8d, eax
  002d1	ba 11 10 e3 ac	 mov	 edx, -1394405359	; ace31011H
  002d6	48 8b 4c 24 38	 mov	 rcx, QWORD PTR file$[rsp]
  002db	e8 00 00 00 00	 call	 sr_write_value
  002e0	85 c0		 test	 eax, eax
  002e2	74 0a		 je	 SHORT $LN132@ckd_dasd_h
  002e4	b8 ff ff ff ff	 mov	 eax, -1
  002e9	e9 25 06 00 00	 jmp	 $LN1@ckd_dasd_h
$LN132@ckd_dasd_h:
  002ee	33 c0		 xor	 eax, eax
  002f0	85 c0		 test	 eax, eax
  002f2	75 c8		 jne	 SHORT $LN40@ckd_dasd_h
$LN43@ckd_dasd_h:

; 1219 :     SR_WRITE_VALUE( file, SR_DEV_CKD_DXBHEAD,  dev->ckdxbhead,  sizeof( dev->ckdxbhead  ));

  002f4	48 8b 44 24 30	 mov	 rax, QWORD PTR dev$[rsp]
  002f9	0f b7 80 f4 12
	00 00		 movzx	 eax, WORD PTR [rax+4852]
  00300	41 b9 02 00 00
	00		 mov	 r9d, 2
  00306	44 8b c0	 mov	 r8d, eax
  00309	ba 12 10 e3 ac	 mov	 edx, -1394405358	; ace31012H
  0030e	48 8b 4c 24 38	 mov	 rcx, QWORD PTR file$[rsp]
  00313	e8 00 00 00 00	 call	 sr_write_value
  00318	85 c0		 test	 eax, eax
  0031a	74 0a		 je	 SHORT $LN133@ckd_dasd_h
  0031c	b8 ff ff ff ff	 mov	 eax, -1
  00321	e9 ed 05 00 00	 jmp	 $LN1@ckd_dasd_h
$LN133@ckd_dasd_h:
  00326	33 c0		 xor	 eax, eax
  00328	85 c0		 test	 eax, eax
  0032a	75 c8		 jne	 SHORT $LN43@ckd_dasd_h
$LN46@ckd_dasd_h:

; 1220 :     SR_WRITE_VALUE( file, SR_DEV_CKD_DXECYL,   dev->ckdxecyl,   sizeof( dev->ckdxecyl   ));

  0032c	48 8b 44 24 30	 mov	 rax, QWORD PTR dev$[rsp]
  00331	0f b7 80 f6 12
	00 00		 movzx	 eax, WORD PTR [rax+4854]
  00338	41 b9 02 00 00
	00		 mov	 r9d, 2
  0033e	44 8b c0	 mov	 r8d, eax
  00341	ba 13 10 e3 ac	 mov	 edx, -1394405357	; ace31013H
  00346	48 8b 4c 24 38	 mov	 rcx, QWORD PTR file$[rsp]
  0034b	e8 00 00 00 00	 call	 sr_write_value
  00350	85 c0		 test	 eax, eax
  00352	74 0a		 je	 SHORT $LN134@ckd_dasd_h
  00354	b8 ff ff ff ff	 mov	 eax, -1
  00359	e9 b5 05 00 00	 jmp	 $LN1@ckd_dasd_h
$LN134@ckd_dasd_h:
  0035e	33 c0		 xor	 eax, eax
  00360	85 c0		 test	 eax, eax
  00362	75 c8		 jne	 SHORT $LN46@ckd_dasd_h
$LN49@ckd_dasd_h:

; 1221 :     SR_WRITE_VALUE( file, SR_DEV_CKD_DXEHEAD,  dev->ckdxehead,  sizeof( dev->ckdxehead  ));

  00364	48 8b 44 24 30	 mov	 rax, QWORD PTR dev$[rsp]
  00369	0f b7 80 f8 12
	00 00		 movzx	 eax, WORD PTR [rax+4856]
  00370	41 b9 02 00 00
	00		 mov	 r9d, 2
  00376	44 8b c0	 mov	 r8d, eax
  00379	ba 14 10 e3 ac	 mov	 edx, -1394405356	; ace31014H
  0037e	48 8b 4c 24 38	 mov	 rcx, QWORD PTR file$[rsp]
  00383	e8 00 00 00 00	 call	 sr_write_value
  00388	85 c0		 test	 eax, eax
  0038a	74 0a		 je	 SHORT $LN135@ckd_dasd_h
  0038c	b8 ff ff ff ff	 mov	 eax, -1
  00391	e9 7d 05 00 00	 jmp	 $LN1@ckd_dasd_h
$LN135@ckd_dasd_h:
  00396	33 c0		 xor	 eax, eax
  00398	85 c0		 test	 eax, eax
  0039a	75 c8		 jne	 SHORT $LN49@ckd_dasd_h
$LN52@ckd_dasd_h:

; 1222 :     SR_WRITE_VALUE( file, SR_DEV_CKD_DXFMASK,  dev->ckdfmask,   sizeof( dev->ckdfmask   ));

  0039c	48 8b 44 24 30	 mov	 rax, QWORD PTR dev$[rsp]
  003a1	0f b6 80 fa 12
	00 00		 movzx	 eax, BYTE PTR [rax+4858]
  003a8	41 b9 01 00 00
	00		 mov	 r9d, 1
  003ae	44 8b c0	 mov	 r8d, eax
  003b1	ba 15 10 e3 ac	 mov	 edx, -1394405355	; ace31015H
  003b6	48 8b 4c 24 38	 mov	 rcx, QWORD PTR file$[rsp]
  003bb	e8 00 00 00 00	 call	 sr_write_value
  003c0	85 c0		 test	 eax, eax
  003c2	74 0a		 je	 SHORT $LN136@ckd_dasd_h
  003c4	b8 ff ff ff ff	 mov	 eax, -1
  003c9	e9 45 05 00 00	 jmp	 $LN1@ckd_dasd_h
$LN136@ckd_dasd_h:
  003ce	33 c0		 xor	 eax, eax
  003d0	85 c0		 test	 eax, eax
  003d2	75 c8		 jne	 SHORT $LN52@ckd_dasd_h
$LN55@ckd_dasd_h:

; 1223 :     SR_WRITE_VALUE( file, SR_DEV_CKD_DXGATTR,  dev->ckdxgattr,  sizeof( dev->ckdxgattr  ));

  003d4	48 8b 44 24 30	 mov	 rax, QWORD PTR dev$[rsp]
  003d9	0f b6 80 fb 12
	00 00		 movzx	 eax, BYTE PTR [rax+4859]
  003e0	41 b9 01 00 00
	00		 mov	 r9d, 1
  003e6	44 8b c0	 mov	 r8d, eax
  003e9	ba 16 10 e3 ac	 mov	 edx, -1394405354	; ace31016H
  003ee	48 8b 4c 24 38	 mov	 rcx, QWORD PTR file$[rsp]
  003f3	e8 00 00 00 00	 call	 sr_write_value
  003f8	85 c0		 test	 eax, eax
  003fa	74 0a		 je	 SHORT $LN137@ckd_dasd_h
  003fc	b8 ff ff ff ff	 mov	 eax, -1
  00401	e9 0d 05 00 00	 jmp	 $LN1@ckd_dasd_h
$LN137@ckd_dasd_h:
  00406	33 c0		 xor	 eax, eax
  00408	85 c0		 test	 eax, eax
  0040a	75 c8		 jne	 SHORT $LN55@ckd_dasd_h
$LN58@ckd_dasd_h:

; 1224 :     SR_WRITE_VALUE( file, SR_DEV_CKD_LRTRANLF, dev->ckdltranlf, sizeof( dev->ckdltranlf ));

  0040c	48 8b 44 24 30	 mov	 rax, QWORD PTR dev$[rsp]
  00411	0f b7 80 fc 12
	00 00		 movzx	 eax, WORD PTR [rax+4860]
  00418	41 b9 02 00 00
	00		 mov	 r9d, 2
  0041e	44 8b c0	 mov	 r8d, eax
  00421	ba 20 10 e3 ac	 mov	 edx, -1394405344	; ace31020H
  00426	48 8b 4c 24 38	 mov	 rcx, QWORD PTR file$[rsp]
  0042b	e8 00 00 00 00	 call	 sr_write_value
  00430	85 c0		 test	 eax, eax
  00432	74 0a		 je	 SHORT $LN138@ckd_dasd_h
  00434	b8 ff ff ff ff	 mov	 eax, -1
  00439	e9 d5 04 00 00	 jmp	 $LN1@ckd_dasd_h
$LN138@ckd_dasd_h:
  0043e	33 c0		 xor	 eax, eax
  00440	85 c0		 test	 eax, eax
  00442	75 c8		 jne	 SHORT $LN58@ckd_dasd_h
$LN61@ckd_dasd_h:

; 1225 :     SR_WRITE_VALUE( file, SR_DEV_CKD_LROPER,   dev->ckdloper,   sizeof( dev->ckdloper   ));

  00444	48 8b 44 24 30	 mov	 rax, QWORD PTR dev$[rsp]
  00449	0f b6 80 00 13
	00 00		 movzx	 eax, BYTE PTR [rax+4864]
  00450	41 b9 01 00 00
	00		 mov	 r9d, 1
  00456	44 8b c0	 mov	 r8d, eax
  00459	ba 21 10 e3 ac	 mov	 edx, -1394405343	; ace31021H
  0045e	48 8b 4c 24 38	 mov	 rcx, QWORD PTR file$[rsp]
  00463	e8 00 00 00 00	 call	 sr_write_value
  00468	85 c0		 test	 eax, eax
  0046a	74 0a		 je	 SHORT $LN139@ckd_dasd_h
  0046c	b8 ff ff ff ff	 mov	 eax, -1
  00471	e9 9d 04 00 00	 jmp	 $LN1@ckd_dasd_h
$LN139@ckd_dasd_h:
  00476	33 c0		 xor	 eax, eax
  00478	85 c0		 test	 eax, eax
  0047a	75 c8		 jne	 SHORT $LN61@ckd_dasd_h
$LN64@ckd_dasd_h:

; 1226 :     SR_WRITE_VALUE( file, SR_DEV_CKD_LRAUX,    dev->ckdlaux,    sizeof( dev->ckdlaux    ));

  0047c	48 8b 44 24 30	 mov	 rax, QWORD PTR dev$[rsp]
  00481	0f b6 80 01 13
	00 00		 movzx	 eax, BYTE PTR [rax+4865]
  00488	41 b9 01 00 00
	00		 mov	 r9d, 1
  0048e	44 8b c0	 mov	 r8d, eax
  00491	ba 22 10 e3 ac	 mov	 edx, -1394405342	; ace31022H
  00496	48 8b 4c 24 38	 mov	 rcx, QWORD PTR file$[rsp]
  0049b	e8 00 00 00 00	 call	 sr_write_value
  004a0	85 c0		 test	 eax, eax
  004a2	74 0a		 je	 SHORT $LN140@ckd_dasd_h
  004a4	b8 ff ff ff ff	 mov	 eax, -1
  004a9	e9 65 04 00 00	 jmp	 $LN1@ckd_dasd_h
$LN140@ckd_dasd_h:
  004ae	33 c0		 xor	 eax, eax
  004b0	85 c0		 test	 eax, eax
  004b2	75 c8		 jne	 SHORT $LN64@ckd_dasd_h
$LN67@ckd_dasd_h:

; 1227 :     SR_WRITE_VALUE( file, SR_DEV_CKD_LRCOUNT,  dev->ckdlcount,  sizeof( dev->ckdlcount  ));

  004b4	48 8b 44 24 30	 mov	 rax, QWORD PTR dev$[rsp]
  004b9	0f b6 80 02 13
	00 00		 movzx	 eax, BYTE PTR [rax+4866]
  004c0	41 b9 01 00 00
	00		 mov	 r9d, 1
  004c6	44 8b c0	 mov	 r8d, eax
  004c9	ba 23 10 e3 ac	 mov	 edx, -1394405341	; ace31023H
  004ce	48 8b 4c 24 38	 mov	 rcx, QWORD PTR file$[rsp]
  004d3	e8 00 00 00 00	 call	 sr_write_value
  004d8	85 c0		 test	 eax, eax
  004da	74 0a		 je	 SHORT $LN141@ckd_dasd_h
  004dc	b8 ff ff ff ff	 mov	 eax, -1
  004e1	e9 2d 04 00 00	 jmp	 $LN1@ckd_dasd_h
$LN141@ckd_dasd_h:
  004e6	33 c0		 xor	 eax, eax
  004e8	85 c0		 test	 eax, eax
  004ea	75 c8		 jne	 SHORT $LN67@ckd_dasd_h
$LN70@ckd_dasd_h:

; 1228 :     SR_WRITE_VALUE( file, SR_DEV_CKD_3990,     dev->ckd3990,                  1          );

  004ec	48 8b 44 24 30	 mov	 rax, QWORD PTR dev$[rsp]
  004f1	8b 80 14 13 00
	00		 mov	 eax, DWORD PTR [rax+4884]
  004f7	83 e0 01	 and	 eax, 1
  004fa	8b c0		 mov	 eax, eax
  004fc	41 b9 01 00 00
	00		 mov	 r9d, 1
  00502	44 8b c0	 mov	 r8d, eax
  00505	ba 40 10 e3 ac	 mov	 edx, -1394405312	; ace31040H
  0050a	48 8b 4c 24 38	 mov	 rcx, QWORD PTR file$[rsp]
  0050f	e8 00 00 00 00	 call	 sr_write_value
  00514	85 c0		 test	 eax, eax
  00516	74 0a		 je	 SHORT $LN142@ckd_dasd_h
  00518	b8 ff ff ff ff	 mov	 eax, -1
  0051d	e9 f1 03 00 00	 jmp	 $LN1@ckd_dasd_h
$LN142@ckd_dasd_h:
  00522	33 c0		 xor	 eax, eax
  00524	85 c0		 test	 eax, eax
  00526	75 c4		 jne	 SHORT $LN70@ckd_dasd_h
$LN73@ckd_dasd_h:

; 1229 :     SR_WRITE_VALUE( file, SR_DEV_CKD_XTDEF,    dev->ckdxtdef,                 1          );

  00528	48 8b 44 24 30	 mov	 rax, QWORD PTR dev$[rsp]
  0052d	8b 80 14 13 00
	00		 mov	 eax, DWORD PTR [rax+4884]
  00533	d1 e8		 shr	 eax, 1
  00535	83 e0 01	 and	 eax, 1
  00538	8b c0		 mov	 eax, eax
  0053a	41 b9 01 00 00
	00		 mov	 r9d, 1
  00540	44 8b c0	 mov	 r8d, eax
  00543	ba 41 10 e3 ac	 mov	 edx, -1394405311	; ace31041H
  00548	48 8b 4c 24 38	 mov	 rcx, QWORD PTR file$[rsp]
  0054d	e8 00 00 00 00	 call	 sr_write_value
  00552	85 c0		 test	 eax, eax
  00554	74 0a		 je	 SHORT $LN143@ckd_dasd_h
  00556	b8 ff ff ff ff	 mov	 eax, -1
  0055b	e9 b3 03 00 00	 jmp	 $LN1@ckd_dasd_h
$LN143@ckd_dasd_h:
  00560	33 c0		 xor	 eax, eax
  00562	85 c0		 test	 eax, eax
  00564	75 c2		 jne	 SHORT $LN73@ckd_dasd_h
$LN76@ckd_dasd_h:

; 1230 :     SR_WRITE_VALUE( file, SR_DEV_CKD_SETFM,    dev->ckdsetfm,                 1          );

  00566	48 8b 44 24 30	 mov	 rax, QWORD PTR dev$[rsp]
  0056b	8b 80 14 13 00
	00		 mov	 eax, DWORD PTR [rax+4884]
  00571	c1 e8 02	 shr	 eax, 2
  00574	83 e0 01	 and	 eax, 1
  00577	8b c0		 mov	 eax, eax
  00579	41 b9 01 00 00
	00		 mov	 r9d, 1
  0057f	44 8b c0	 mov	 r8d, eax
  00582	ba 42 10 e3 ac	 mov	 edx, -1394405310	; ace31042H
  00587	48 8b 4c 24 38	 mov	 rcx, QWORD PTR file$[rsp]
  0058c	e8 00 00 00 00	 call	 sr_write_value
  00591	85 c0		 test	 eax, eax
  00593	74 0a		 je	 SHORT $LN144@ckd_dasd_h
  00595	b8 ff ff ff ff	 mov	 eax, -1
  0059a	e9 74 03 00 00	 jmp	 $LN1@ckd_dasd_h
$LN144@ckd_dasd_h:
  0059f	33 c0		 xor	 eax, eax
  005a1	85 c0		 test	 eax, eax
  005a3	75 c1		 jne	 SHORT $LN76@ckd_dasd_h
$LN79@ckd_dasd_h:

; 1231 :     SR_WRITE_VALUE( file, SR_DEV_CKD_LOCAT,    dev->ckdlocat,                 1          );

  005a5	48 8b 44 24 30	 mov	 rax, QWORD PTR dev$[rsp]
  005aa	8b 80 14 13 00
	00		 mov	 eax, DWORD PTR [rax+4884]
  005b0	c1 e8 03	 shr	 eax, 3
  005b3	83 e0 01	 and	 eax, 1
  005b6	8b c0		 mov	 eax, eax
  005b8	41 b9 01 00 00
	00		 mov	 r9d, 1
  005be	44 8b c0	 mov	 r8d, eax
  005c1	ba 43 10 e3 ac	 mov	 edx, -1394405309	; ace31043H
  005c6	48 8b 4c 24 38	 mov	 rcx, QWORD PTR file$[rsp]
  005cb	e8 00 00 00 00	 call	 sr_write_value
  005d0	85 c0		 test	 eax, eax
  005d2	74 0a		 je	 SHORT $LN145@ckd_dasd_h
  005d4	b8 ff ff ff ff	 mov	 eax, -1
  005d9	e9 35 03 00 00	 jmp	 $LN1@ckd_dasd_h
$LN145@ckd_dasd_h:
  005de	33 c0		 xor	 eax, eax
  005e0	85 c0		 test	 eax, eax
  005e2	75 c1		 jne	 SHORT $LN79@ckd_dasd_h
$LN82@ckd_dasd_h:

; 1232 :     SR_WRITE_VALUE( file, SR_DEV_CKD_SPCNT,    dev->ckdspcnt,                 1          );

  005e4	48 8b 44 24 30	 mov	 rax, QWORD PTR dev$[rsp]
  005e9	8b 80 14 13 00
	00		 mov	 eax, DWORD PTR [rax+4884]
  005ef	c1 e8 05	 shr	 eax, 5
  005f2	83 e0 01	 and	 eax, 1
  005f5	8b c0		 mov	 eax, eax
  005f7	41 b9 01 00 00
	00		 mov	 r9d, 1
  005fd	44 8b c0	 mov	 r8d, eax
  00600	ba 44 10 e3 ac	 mov	 edx, -1394405308	; ace31044H
  00605	48 8b 4c 24 38	 mov	 rcx, QWORD PTR file$[rsp]
  0060a	e8 00 00 00 00	 call	 sr_write_value
  0060f	85 c0		 test	 eax, eax
  00611	74 0a		 je	 SHORT $LN146@ckd_dasd_h
  00613	b8 ff ff ff ff	 mov	 eax, -1
  00618	e9 f6 02 00 00	 jmp	 $LN1@ckd_dasd_h
$LN146@ckd_dasd_h:
  0061d	33 c0		 xor	 eax, eax
  0061f	85 c0		 test	 eax, eax
  00621	75 c1		 jne	 SHORT $LN82@ckd_dasd_h
$LN85@ckd_dasd_h:

; 1233 :     SR_WRITE_VALUE( file, SR_DEV_CKD_SEEK,     dev->ckdseek,                  1          );

  00623	48 8b 44 24 30	 mov	 rax, QWORD PTR dev$[rsp]
  00628	8b 80 14 13 00
	00		 mov	 eax, DWORD PTR [rax+4884]
  0062e	c1 e8 06	 shr	 eax, 6
  00631	83 e0 01	 and	 eax, 1
  00634	8b c0		 mov	 eax, eax
  00636	41 b9 01 00 00
	00		 mov	 r9d, 1
  0063c	44 8b c0	 mov	 r8d, eax
  0063f	ba 45 10 e3 ac	 mov	 edx, -1394405307	; ace31045H
  00644	48 8b 4c 24 38	 mov	 rcx, QWORD PTR file$[rsp]
  00649	e8 00 00 00 00	 call	 sr_write_value
  0064e	85 c0		 test	 eax, eax
  00650	74 0a		 je	 SHORT $LN147@ckd_dasd_h
  00652	b8 ff ff ff ff	 mov	 eax, -1
  00657	e9 b7 02 00 00	 jmp	 $LN1@ckd_dasd_h
$LN147@ckd_dasd_h:
  0065c	33 c0		 xor	 eax, eax
  0065e	85 c0		 test	 eax, eax
  00660	75 c1		 jne	 SHORT $LN85@ckd_dasd_h
$LN88@ckd_dasd_h:

; 1234 :     SR_WRITE_VALUE( file, SR_DEV_CKD_SKCYL,    dev->ckdskcyl,                 1          );

  00662	48 8b 44 24 30	 mov	 rax, QWORD PTR dev$[rsp]
  00667	8b 80 14 13 00
	00		 mov	 eax, DWORD PTR [rax+4884]
  0066d	c1 e8 07	 shr	 eax, 7
  00670	83 e0 01	 and	 eax, 1
  00673	8b c0		 mov	 eax, eax
  00675	41 b9 01 00 00
	00		 mov	 r9d, 1
  0067b	44 8b c0	 mov	 r8d, eax
  0067e	ba 46 10 e3 ac	 mov	 edx, -1394405306	; ace31046H
  00683	48 8b 4c 24 38	 mov	 rcx, QWORD PTR file$[rsp]
  00688	e8 00 00 00 00	 call	 sr_write_value
  0068d	85 c0		 test	 eax, eax
  0068f	74 0a		 je	 SHORT $LN148@ckd_dasd_h
  00691	b8 ff ff ff ff	 mov	 eax, -1
  00696	e9 78 02 00 00	 jmp	 $LN1@ckd_dasd_h
$LN148@ckd_dasd_h:
  0069b	33 c0		 xor	 eax, eax
  0069d	85 c0		 test	 eax, eax
  0069f	75 c1		 jne	 SHORT $LN88@ckd_dasd_h
$LN91@ckd_dasd_h:

; 1235 :     SR_WRITE_VALUE( file, SR_DEV_CKD_RECAL,    dev->ckdrecal,                 1          );

  006a1	48 8b 44 24 30	 mov	 rax, QWORD PTR dev$[rsp]
  006a6	8b 80 14 13 00
	00		 mov	 eax, DWORD PTR [rax+4884]
  006ac	c1 e8 08	 shr	 eax, 8
  006af	83 e0 01	 and	 eax, 1
  006b2	8b c0		 mov	 eax, eax
  006b4	41 b9 01 00 00
	00		 mov	 r9d, 1
  006ba	44 8b c0	 mov	 r8d, eax
  006bd	ba 47 10 e3 ac	 mov	 edx, -1394405305	; ace31047H
  006c2	48 8b 4c 24 38	 mov	 rcx, QWORD PTR file$[rsp]
  006c7	e8 00 00 00 00	 call	 sr_write_value
  006cc	85 c0		 test	 eax, eax
  006ce	74 0a		 je	 SHORT $LN149@ckd_dasd_h
  006d0	b8 ff ff ff ff	 mov	 eax, -1
  006d5	e9 39 02 00 00	 jmp	 $LN1@ckd_dasd_h
$LN149@ckd_dasd_h:
  006da	33 c0		 xor	 eax, eax
  006dc	85 c0		 test	 eax, eax
  006de	75 c1		 jne	 SHORT $LN91@ckd_dasd_h
$LN94@ckd_dasd_h:

; 1236 :     SR_WRITE_VALUE( file, SR_DEV_CKD_RDIPL,    dev->ckdrdipl,                 1          );

  006e0	48 8b 44 24 30	 mov	 rax, QWORD PTR dev$[rsp]
  006e5	8b 80 14 13 00
	00		 mov	 eax, DWORD PTR [rax+4884]
  006eb	c1 e8 09	 shr	 eax, 9
  006ee	83 e0 01	 and	 eax, 1
  006f1	8b c0		 mov	 eax, eax
  006f3	41 b9 01 00 00
	00		 mov	 r9d, 1
  006f9	44 8b c0	 mov	 r8d, eax
  006fc	ba 48 10 e3 ac	 mov	 edx, -1394405304	; ace31048H
  00701	48 8b 4c 24 38	 mov	 rcx, QWORD PTR file$[rsp]
  00706	e8 00 00 00 00	 call	 sr_write_value
  0070b	85 c0		 test	 eax, eax
  0070d	74 0a		 je	 SHORT $LN150@ckd_dasd_h
  0070f	b8 ff ff ff ff	 mov	 eax, -1
  00714	e9 fa 01 00 00	 jmp	 $LN1@ckd_dasd_h
$LN150@ckd_dasd_h:
  00719	33 c0		 xor	 eax, eax
  0071b	85 c0		 test	 eax, eax
  0071d	75 c1		 jne	 SHORT $LN94@ckd_dasd_h
$LN97@ckd_dasd_h:

; 1237 :     SR_WRITE_VALUE( file, SR_DEV_CKD_XMARK,    dev->ckdxmark,                 1          );

  0071f	48 8b 44 24 30	 mov	 rax, QWORD PTR dev$[rsp]
  00724	8b 80 14 13 00
	00		 mov	 eax, DWORD PTR [rax+4884]
  0072a	c1 e8 0a	 shr	 eax, 10
  0072d	83 e0 01	 and	 eax, 1
  00730	8b c0		 mov	 eax, eax
  00732	41 b9 01 00 00
	00		 mov	 r9d, 1
  00738	44 8b c0	 mov	 r8d, eax
  0073b	ba 49 10 e3 ac	 mov	 edx, -1394405303	; ace31049H
  00740	48 8b 4c 24 38	 mov	 rcx, QWORD PTR file$[rsp]
  00745	e8 00 00 00 00	 call	 sr_write_value
  0074a	85 c0		 test	 eax, eax
  0074c	74 0a		 je	 SHORT $LN151@ckd_dasd_h
  0074e	b8 ff ff ff ff	 mov	 eax, -1
  00753	e9 bb 01 00 00	 jmp	 $LN1@ckd_dasd_h
$LN151@ckd_dasd_h:
  00758	33 c0		 xor	 eax, eax
  0075a	85 c0		 test	 eax, eax
  0075c	75 c1		 jne	 SHORT $LN97@ckd_dasd_h
$LN100@ckd_dasd_h:

; 1238 :     SR_WRITE_VALUE( file, SR_DEV_CKD_HAEQ,     dev->ckdhaeq,                  1          );

  0075e	48 8b 44 24 30	 mov	 rax, QWORD PTR dev$[rsp]
  00763	8b 80 14 13 00
	00		 mov	 eax, DWORD PTR [rax+4884]
  00769	c1 e8 0b	 shr	 eax, 11
  0076c	83 e0 01	 and	 eax, 1
  0076f	8b c0		 mov	 eax, eax
  00771	41 b9 01 00 00
	00		 mov	 r9d, 1
  00777	44 8b c0	 mov	 r8d, eax
  0077a	ba 4a 10 e3 ac	 mov	 edx, -1394405302	; ace3104aH
  0077f	48 8b 4c 24 38	 mov	 rcx, QWORD PTR file$[rsp]
  00784	e8 00 00 00 00	 call	 sr_write_value
  00789	85 c0		 test	 eax, eax
  0078b	74 0a		 je	 SHORT $LN152@ckd_dasd_h
  0078d	b8 ff ff ff ff	 mov	 eax, -1
  00792	e9 7c 01 00 00	 jmp	 $LN1@ckd_dasd_h
$LN152@ckd_dasd_h:
  00797	33 c0		 xor	 eax, eax
  00799	85 c0		 test	 eax, eax
  0079b	75 c1		 jne	 SHORT $LN100@ckd_dasd_h
$LN103@ckd_dasd_h:

; 1239 :     SR_WRITE_VALUE( file, SR_DEV_CKD_IDEQ,     dev->ckdideq,                  1          );

  0079d	48 8b 44 24 30	 mov	 rax, QWORD PTR dev$[rsp]
  007a2	8b 80 14 13 00
	00		 mov	 eax, DWORD PTR [rax+4884]
  007a8	c1 e8 0c	 shr	 eax, 12
  007ab	83 e0 01	 and	 eax, 1
  007ae	8b c0		 mov	 eax, eax
  007b0	41 b9 01 00 00
	00		 mov	 r9d, 1
  007b6	44 8b c0	 mov	 r8d, eax
  007b9	ba 4b 10 e3 ac	 mov	 edx, -1394405301	; ace3104bH
  007be	48 8b 4c 24 38	 mov	 rcx, QWORD PTR file$[rsp]
  007c3	e8 00 00 00 00	 call	 sr_write_value
  007c8	85 c0		 test	 eax, eax
  007ca	74 0a		 je	 SHORT $LN153@ckd_dasd_h
  007cc	b8 ff ff ff ff	 mov	 eax, -1
  007d1	e9 3d 01 00 00	 jmp	 $LN1@ckd_dasd_h
$LN153@ckd_dasd_h:
  007d6	33 c0		 xor	 eax, eax
  007d8	85 c0		 test	 eax, eax
  007da	75 c1		 jne	 SHORT $LN103@ckd_dasd_h
$LN106@ckd_dasd_h:

; 1240 :     SR_WRITE_VALUE( file, SR_DEV_CKD_KYEQ,     dev->ckdkyeq,                  1          );

  007dc	48 8b 44 24 30	 mov	 rax, QWORD PTR dev$[rsp]
  007e1	8b 80 14 13 00
	00		 mov	 eax, DWORD PTR [rax+4884]
  007e7	c1 e8 0d	 shr	 eax, 13
  007ea	83 e0 01	 and	 eax, 1
  007ed	8b c0		 mov	 eax, eax
  007ef	41 b9 01 00 00
	00		 mov	 r9d, 1
  007f5	44 8b c0	 mov	 r8d, eax
  007f8	ba 4c 10 e3 ac	 mov	 edx, -1394405300	; ace3104cH
  007fd	48 8b 4c 24 38	 mov	 rcx, QWORD PTR file$[rsp]
  00802	e8 00 00 00 00	 call	 sr_write_value
  00807	85 c0		 test	 eax, eax
  00809	74 0a		 je	 SHORT $LN154@ckd_dasd_h
  0080b	b8 ff ff ff ff	 mov	 eax, -1
  00810	e9 fe 00 00 00	 jmp	 $LN1@ckd_dasd_h
$LN154@ckd_dasd_h:
  00815	33 c0		 xor	 eax, eax
  00817	85 c0		 test	 eax, eax
  00819	75 c1		 jne	 SHORT $LN106@ckd_dasd_h
$LN109@ckd_dasd_h:

; 1241 :     SR_WRITE_VALUE( file, SR_DEV_CKD_WCKD,     dev->ckdwckd,                  1          );

  0081b	48 8b 44 24 30	 mov	 rax, QWORD PTR dev$[rsp]
  00820	8b 80 14 13 00
	00		 mov	 eax, DWORD PTR [rax+4884]
  00826	c1 e8 0e	 shr	 eax, 14
  00829	83 e0 01	 and	 eax, 1
  0082c	8b c0		 mov	 eax, eax
  0082e	41 b9 01 00 00
	00		 mov	 r9d, 1
  00834	44 8b c0	 mov	 r8d, eax
  00837	ba 4d 10 e3 ac	 mov	 edx, -1394405299	; ace3104dH
  0083c	48 8b 4c 24 38	 mov	 rcx, QWORD PTR file$[rsp]
  00841	e8 00 00 00 00	 call	 sr_write_value
  00846	85 c0		 test	 eax, eax
  00848	74 0a		 je	 SHORT $LN155@ckd_dasd_h
  0084a	b8 ff ff ff ff	 mov	 eax, -1
  0084f	e9 bf 00 00 00	 jmp	 $LN1@ckd_dasd_h
$LN155@ckd_dasd_h:
  00854	33 c0		 xor	 eax, eax
  00856	85 c0		 test	 eax, eax
  00858	75 c1		 jne	 SHORT $LN109@ckd_dasd_h
$LN112@ckd_dasd_h:

; 1242 :     SR_WRITE_VALUE( file, SR_DEV_CKD_TRKOF,    dev->ckdtrkof,                 1          );

  0085a	48 8b 44 24 30	 mov	 rax, QWORD PTR dev$[rsp]
  0085f	8b 80 14 13 00
	00		 mov	 eax, DWORD PTR [rax+4884]
  00865	c1 e8 0f	 shr	 eax, 15
  00868	83 e0 01	 and	 eax, 1
  0086b	8b c0		 mov	 eax, eax
  0086d	41 b9 01 00 00
	00		 mov	 r9d, 1
  00873	44 8b c0	 mov	 r8d, eax
  00876	ba 4e 10 e3 ac	 mov	 edx, -1394405298	; ace3104eH
  0087b	48 8b 4c 24 38	 mov	 rcx, QWORD PTR file$[rsp]
  00880	e8 00 00 00 00	 call	 sr_write_value
  00885	85 c0		 test	 eax, eax
  00887	74 0a		 je	 SHORT $LN156@ckd_dasd_h
  00889	b8 ff ff ff ff	 mov	 eax, -1
  0088e	e9 80 00 00 00	 jmp	 $LN1@ckd_dasd_h
$LN156@ckd_dasd_h:
  00893	33 c0		 xor	 eax, eax
  00895	85 c0		 test	 eax, eax
  00897	75 c1		 jne	 SHORT $LN112@ckd_dasd_h
$LN115@ckd_dasd_h:

; 1243 :     SR_WRITE_VALUE( file, SR_DEV_CKD_SSI,      dev->ckdssi,                   1          );

  00899	48 8b 44 24 30	 mov	 rax, QWORD PTR dev$[rsp]
  0089e	8b 80 14 13 00
	00		 mov	 eax, DWORD PTR [rax+4884]
  008a4	c1 e8 10	 shr	 eax, 16
  008a7	83 e0 01	 and	 eax, 1
  008aa	8b c0		 mov	 eax, eax
  008ac	41 b9 01 00 00
	00		 mov	 r9d, 1
  008b2	44 8b c0	 mov	 r8d, eax
  008b5	ba 4f 10 e3 ac	 mov	 edx, -1394405297	; ace3104fH
  008ba	48 8b 4c 24 38	 mov	 rcx, QWORD PTR file$[rsp]
  008bf	e8 00 00 00 00	 call	 sr_write_value
  008c4	85 c0		 test	 eax, eax
  008c6	74 07		 je	 SHORT $LN157@ckd_dasd_h
  008c8	b8 ff ff ff ff	 mov	 eax, -1
  008cd	eb 44		 jmp	 SHORT $LN1@ckd_dasd_h
$LN157@ckd_dasd_h:
  008cf	33 c0		 xor	 eax, eax
  008d1	85 c0		 test	 eax, eax
  008d3	75 c4		 jne	 SHORT $LN115@ckd_dasd_h
$LN118@ckd_dasd_h:

; 1244 :     SR_WRITE_VALUE( file, SR_DEV_CKD_WRHA,     dev->ckdwrha,                  1          );

  008d5	48 8b 44 24 30	 mov	 rax, QWORD PTR dev$[rsp]
  008da	8b 80 14 13 00
	00		 mov	 eax, DWORD PTR [rax+4884]
  008e0	c1 e8 13	 shr	 eax, 19
  008e3	83 e0 01	 and	 eax, 1
  008e6	8b c0		 mov	 eax, eax
  008e8	41 b9 01 00 00
	00		 mov	 r9d, 1
  008ee	44 8b c0	 mov	 r8d, eax
  008f1	ba 50 10 e3 ac	 mov	 edx, -1394405296	; ace31050H
  008f6	48 8b 4c 24 38	 mov	 rcx, QWORD PTR file$[rsp]
  008fb	e8 00 00 00 00	 call	 sr_write_value
  00900	85 c0		 test	 eax, eax
  00902	74 07		 je	 SHORT $LN158@ckd_dasd_h
  00904	b8 ff ff ff ff	 mov	 eax, -1
  00909	eb 08		 jmp	 SHORT $LN1@ckd_dasd_h
$LN158@ckd_dasd_h:
  0090b	33 c0		 xor	 eax, eax
  0090d	85 c0		 test	 eax, eax
  0090f	75 c4		 jne	 SHORT $LN118@ckd_dasd_h

; 1245 : 
; 1246 :     return 0;

  00911	33 c0		 xor	 eax, eax
$LN1@ckd_dasd_h:

; 1247 : }

  00913	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00917	c3		 ret	 0
ckd_dasd_hsuspend ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\ckddasd.c
_TEXT	SEGMENT
$T1 = 64
tv138 = 72
tv153 = 80
cckd$ = 88
tv170 = 96
filename$ = 112
__$ArrayPad$ = 384
dev$ = 416
devclass$ = 424
buflen$ = 432
buffer$ = 440
ckd_dasd_query_device PROC

; 657  : {

$LN21:
  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	48 81 ec 98 01
	00 00		 sub	 rsp, 408		; 00000198H
  0001b	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00022	48 33 c4	 xor	 rax, rsp
  00025	48 89 84 24 80
	01 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 658  :     char       filename[ PATH_MAX + 1 ];/* full path or just name    */
; 659  :     CCKD_EXT*  cckd;                    /* CCKD Extension Block      */
; 660  : 
; 661  :     BEGIN_DEVICE_CLASS_QUERY( "DASD", dev, devclass, buflen, buffer );

  0002d	48 83 bc 24 a8
	01 00 00 00	 cmp	 QWORD PTR devclass$[rsp], 0
  00036	74 12		 je	 SHORT $LN2@ckd_dasd_q
  00038	48 8b 84 24 a8
	01 00 00	 mov	 rax, QWORD PTR devclass$[rsp]
  00040	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170086
  00047	48 89 08	 mov	 QWORD PTR [rax], rcx
$LN2@ckd_dasd_q:
  0004a	48 83 bc 24 a0
	01 00 00 00	 cmp	 QWORD PTR dev$[rsp], 0
  00053	74 20		 je	 SHORT $LN4@ckd_dasd_q
  00055	48 83 bc 24 a8
	01 00 00 00	 cmp	 QWORD PTR devclass$[rsp], 0
  0005e	74 15		 je	 SHORT $LN4@ckd_dasd_q
  00060	83 bc 24 b0 01
	00 00 00	 cmp	 DWORD PTR buflen$[rsp], 0
  00068	74 0b		 je	 SHORT $LN4@ckd_dasd_q
  0006a	48 83 bc 24 b8
	01 00 00 00	 cmp	 QWORD PTR buffer$[rsp], 0
  00073	75 05		 jne	 SHORT $LN3@ckd_dasd_q
$LN4@ckd_dasd_q:
  00075	e9 97 02 00 00	 jmp	 $LN1@ckd_dasd_q
$LN3@ckd_dasd_q:
  0007a	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00081	8b 80 94 12 00
	00		 mov	 eax, DWORD PTR [rax+4756]
  00087	c1 e8 1a	 shr	 eax, 26
  0008a	83 e0 01	 and	 eax, 1
  0008d	85 c0		 test	 eax, eax
  0008f	74 6c		 je	 SHORT $LN5@ckd_dasd_q
  00091	48 8b 84 24 a0
	01 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00099	48 05 a4 00 00
	00		 add	 rax, 164		; 000000a4H
  0009f	48 8b c8	 mov	 rcx, rax
  000a2	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_basename
  000a8	41 b8 05 01 00
	00		 mov	 r8d, 261		; 00000105H
  000ae	48 8b d0	 mov	 rdx, rax
  000b1	48 8d 4c 24 70	 lea	 rcx, QWORD PTR filename$[rsp]
  000b6	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_strlcpy
  000bc	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG170092
  000c3	48 8d 4c 24 70	 lea	 rcx, QWORD PTR filename$[rsp]
  000c8	e8 00 00 00 00	 call	 strcmp
  000cd	85 c0		 test	 eax, eax
  000cf	75 2a		 jne	 SHORT $LN7@ckd_dasd_q
  000d1	b8 01 00 00 00	 mov	 eax, 1
  000d6	48 6b c0 00	 imul	 rax, rax, 0
  000da	48 89 44 24 40	 mov	 QWORD PTR $T1[rsp], rax
  000df	48 81 7c 24 40
	05 01 00 00	 cmp	 QWORD PTR $T1[rsp], 261	; 00000105H
  000e8	73 02		 jae	 SHORT $LN13@ckd_dasd_q
  000ea	eb 05		 jmp	 SHORT $LN14@ckd_dasd_q
$LN13@ckd_dasd_q:
  000ec	e8 00 00 00 00	 call	 __report_rangecheckfailure
$LN14@ckd_dasd_q:
  000f1	48 8b 44 24 40	 mov	 rax, QWORD PTR $T1[rsp]
  000f6	c6 44 04 70 00	 mov	 BYTE PTR filename$[rsp+rax], 0
$LN7@ckd_dasd_q:
  000fb	eb 22		 jmp	 SHORT $LN6@ckd_dasd_q
$LN5@ckd_dasd_q:
  000fd	48 8b 84 24 a0
	01 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00105	48 05 a4 00 00
	00		 add	 rax, 164		; 000000a4H
  0010b	41 b8 05 01 00
	00		 mov	 r8d, 261		; 00000105H
  00111	48 8b d0	 mov	 rdx, rax
  00114	48 8d 4c 24 70	 lea	 rcx, QWORD PTR filename$[rsp]
  00119	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_strlcpy
$LN6@ckd_dasd_q:

; 662  : 
; 663  :     cckd = dev->cckd_ext;

  0011f	48 8b 84 24 a0
	01 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00127	48 8b 80 08 13
	00 00		 mov	 rax, QWORD PTR [rax+4872]
  0012e	48 89 44 24 58	 mov	 QWORD PTR cckd$[rsp], rax

; 664  : 
; 665  :     if (!cckd)

  00133	48 83 7c 24 58
	00		 cmp	 QWORD PTR cckd$[rsp], 0
  00139	0f 85 3f 01 00
	00		 jne	 $LN8@ckd_dasd_q

; 666  :     {
; 667  :         if ( dev->ckdnumfd > 1)

  0013f	48 8b 84 24 a0
	01 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00147	83 b8 c4 11 00
	00 01		 cmp	 DWORD PTR [rax+4548], 1
  0014e	0f 8e 9e 00 00
	00		 jle	 $LN10@ckd_dasd_q

; 668  :         {
; 669  :             snprintf( buffer, buflen, "%s%s [%d cyls] [%d segs] IO[%"PRIu64"]",

  00154	48 8b 84 24 a0
	01 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  0015c	0f b6 80 10 13
	00 00		 movzx	 eax, BYTE PTR [rax+4880]
  00163	24 01		 and	 al, 1
  00165	0f b6 c0	 movzx	 eax, al
  00168	85 c0		 test	 eax, eax
  0016a	74 0e		 je	 SHORT $LN15@ckd_dasd_q
  0016c	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG170097
  00173	48 89 44 24 48	 mov	 QWORD PTR tv138[rsp], rax
  00178	eb 0c		 jmp	 SHORT $LN16@ckd_dasd_q
$LN15@ckd_dasd_q:
  0017a	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG170098
  00181	48 89 44 24 48	 mov	 QWORD PTR tv138[rsp], rax
$LN16@ckd_dasd_q:
  00186	48 63 84 24 b0
	01 00 00	 movsxd	 rax, DWORD PTR buflen$[rsp]
  0018e	48 8b 8c 24 a0
	01 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  00196	48 8b 89 00 06
	00 00		 mov	 rcx, QWORD PTR [rcx+1536]
  0019d	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  001a2	48 8b 8c 24 a0
	01 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  001aa	8b 89 c4 11 00
	00		 mov	 ecx, DWORD PTR [rcx+4548]
  001b0	89 4c 24 30	 mov	 DWORD PTR [rsp+48], ecx
  001b4	48 8b 8c 24 a0
	01 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  001bc	8b 89 b8 12 00
	00		 mov	 ecx, DWORD PTR [rcx+4792]
  001c2	89 4c 24 28	 mov	 DWORD PTR [rsp+40], ecx
  001c6	48 8d 4c 24 70	 lea	 rcx, QWORD PTR filename$[rsp]
  001cb	48 89 4c 24 20	 mov	 QWORD PTR [rsp+32], rcx
  001d0	4c 8b 4c 24 48	 mov	 r9, QWORD PTR tv138[rsp]
  001d5	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG170099
  001dc	48 8b d0	 mov	 rdx, rax
  001df	48 8b 8c 24 b8
	01 00 00	 mov	 rcx, QWORD PTR buffer$[rsp]
  001e7	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_snprintf

; 670  :                       dev->cckd64 ? "*64* " : "",
; 671  :                       filename,
; 672  :                       dev->ckdcyls,
; 673  :                       dev->ckdnumfd,
; 674  :                       dev->excps );
; 675  :         }

  001ed	e9 87 00 00 00	 jmp	 $LN11@ckd_dasd_q
$LN10@ckd_dasd_q:

; 676  :         else
; 677  :         {
; 678  :             snprintf( buffer, buflen, "%s%s [%d cyls] IO[%"PRIu64"]",

  001f2	48 8b 84 24 a0
	01 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  001fa	0f b6 80 10 13
	00 00		 movzx	 eax, BYTE PTR [rax+4880]
  00201	24 01		 and	 al, 1
  00203	0f b6 c0	 movzx	 eax, al
  00206	85 c0		 test	 eax, eax
  00208	74 0e		 je	 SHORT $LN17@ckd_dasd_q
  0020a	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG170100
  00211	48 89 44 24 50	 mov	 QWORD PTR tv153[rsp], rax
  00216	eb 0c		 jmp	 SHORT $LN18@ckd_dasd_q
$LN17@ckd_dasd_q:
  00218	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG170101
  0021f	48 89 44 24 50	 mov	 QWORD PTR tv153[rsp], rax
$LN18@ckd_dasd_q:
  00224	48 63 84 24 b0
	01 00 00	 movsxd	 rax, DWORD PTR buflen$[rsp]
  0022c	48 8b 8c 24 a0
	01 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  00234	48 8b 89 00 06
	00 00		 mov	 rcx, QWORD PTR [rcx+1536]
  0023b	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  00240	48 8b 8c 24 a0
	01 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  00248	8b 89 b8 12 00
	00		 mov	 ecx, DWORD PTR [rcx+4792]
  0024e	89 4c 24 28	 mov	 DWORD PTR [rsp+40], ecx
  00252	48 8d 4c 24 70	 lea	 rcx, QWORD PTR filename$[rsp]
  00257	48 89 4c 24 20	 mov	 QWORD PTR [rsp+32], rcx
  0025c	4c 8b 4c 24 50	 mov	 r9, QWORD PTR tv153[rsp]
  00261	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG170102
  00268	48 8b d0	 mov	 rdx, rax
  0026b	48 8b 8c 24 b8
	01 00 00	 mov	 rcx, QWORD PTR buffer$[rsp]
  00273	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_snprintf
$LN11@ckd_dasd_q:

; 679  :                       dev->cckd64 ? "*64* " : "",
; 680  :                       filename,
; 681  :                       dev->ckdcyls,
; 682  :                       dev->excps );
; 683  :         }
; 684  :     }

  00279	e9 93 00 00 00	 jmp	 $LN9@ckd_dasd_q
$LN8@ckd_dasd_q:

; 685  :     else
; 686  :     {
; 687  :         snprintf( buffer, buflen, "%s%s [%d cyls] [%d sfs] IO[%"PRIu64"]",

  0027e	48 8b 84 24 a0
	01 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00286	0f b6 80 10 13
	00 00		 movzx	 eax, BYTE PTR [rax+4880]
  0028d	24 01		 and	 al, 1
  0028f	0f b6 c0	 movzx	 eax, al
  00292	85 c0		 test	 eax, eax
  00294	74 0e		 je	 SHORT $LN19@ckd_dasd_q
  00296	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG170103
  0029d	48 89 44 24 60	 mov	 QWORD PTR tv170[rsp], rax
  002a2	eb 0c		 jmp	 SHORT $LN20@ckd_dasd_q
$LN19@ckd_dasd_q:
  002a4	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG170104
  002ab	48 89 44 24 60	 mov	 QWORD PTR tv170[rsp], rax
$LN20@ckd_dasd_q:
  002b0	48 63 84 24 b0
	01 00 00	 movsxd	 rax, DWORD PTR buflen$[rsp]
  002b8	48 8b 8c 24 a0
	01 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  002c0	48 8b 89 00 06
	00 00		 mov	 rcx, QWORD PTR [rcx+1536]
  002c7	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  002cc	48 8b 4c 24 58	 mov	 rcx, QWORD PTR cckd$[rsp]
  002d1	8b 49 3c	 mov	 ecx, DWORD PTR [rcx+60]
  002d4	89 4c 24 30	 mov	 DWORD PTR [rsp+48], ecx
  002d8	48 8b 8c 24 a0
	01 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  002e0	8b 89 b8 12 00
	00		 mov	 ecx, DWORD PTR [rcx+4792]
  002e6	89 4c 24 28	 mov	 DWORD PTR [rsp+40], ecx
  002ea	48 8d 4c 24 70	 lea	 rcx, QWORD PTR filename$[rsp]
  002ef	48 89 4c 24 20	 mov	 QWORD PTR [rsp+32], rcx
  002f4	4c 8b 4c 24 60	 mov	 r9, QWORD PTR tv170[rsp]
  002f9	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG170105
  00300	48 8b d0	 mov	 rdx, rax
  00303	48 8b 8c 24 b8
	01 00 00	 mov	 rcx, QWORD PTR buffer$[rsp]
  0030b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_snprintf
$LN9@ckd_dasd_q:
$LN1@ckd_dasd_q:
$LN12@ckd_dasd_q:

; 688  :                   dev->cckd64 ? "*64* " : "",
; 689  :                   filename,
; 690  :                   dev->ckdcyls,
; 691  :                   cckd->sfn,
; 692  :                   dev->excps );
; 693  :     }
; 694  : 
; 695  : } /* end function ckd_dasd_query_device */

  00311	48 8b 8c 24 80
	01 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  00319	48 33 cc	 xor	 rcx, rsp
  0031c	e8 00 00 00 00	 call	 __security_check_cookie
  00321	48 81 c4 98 01
	00 00		 add	 rsp, 408		; 00000198H
  00328	c3		 ret	 0
ckd_dasd_query_device ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\ckddasd.c
_TEXT	SEGMENT
unitstat$ = 112
i$ = 116
tv93 = 120
tv131 = 124
tv88 = 128
dev$ = 160
ckd_dasd_close_device PROC

; 720  : {

$LN13:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 81 ec 98 00
	00 00		 sub	 rsp, 152		; 00000098H

; 721  : int     i;                              /* Index                     */
; 722  : BYTE    unitstat;                       /* Unit Status               */
; 723  : 
; 724  :     /* Write the last track image if it's modified */
; 725  :     (dev->hnd->read) (dev, -1, &unitstat);

  0000c	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00014	48 8b 80 90 02
	00 00		 mov	 rax, QWORD PTR [rax+656]
  0001b	4c 8d 44 24 70	 lea	 r8, QWORD PTR unitstat$[rsp]
  00020	ba ff ff ff ff	 mov	 edx, -1
  00025	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  0002d	ff 50 50	 call	 QWORD PTR [rax+80]

; 726  : 
; 727  :     /* Free the cache */
; 728  :     cache_lock(CACHE_DEVBUF);

  00030	33 c9		 xor	 ecx, ecx
  00032	e8 00 00 00 00	 call	 cache_lock

; 729  :     cache_scan(CACHE_DEVBUF, ckddasd_purge_cache, dev);

  00037	4c 8b 84 24 a0
	00 00 00	 mov	 r8, QWORD PTR dev$[rsp]
  0003f	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:ckddasd_purge_cache
  00046	33 c9		 xor	 ecx, ecx
  00048	e8 00 00 00 00	 call	 cache_scan

; 730  :     cache_unlock(CACHE_DEVBUF);

  0004d	33 c9		 xor	 ecx, ecx
  0004f	e8 00 00 00 00	 call	 cache_unlock

; 731  : 
; 732  :     if (!dev->batch)

  00054	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  0005c	8b 80 f8 05 00
	00		 mov	 eax, DWORD PTR [rax+1528]
  00062	c1 e8 0a	 shr	 eax, 10
  00065	83 e0 01	 and	 eax, 1
  00068	85 c0		 test	 eax, eax
  0006a	0f 85 18 01 00
	00		 jne	 $LN5@ckd_dasd_c

; 733  :         if (!dev->quiet)

  00070	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00078	8b 80 f8 05 00
	00		 mov	 eax, DWORD PTR [rax+1528]
  0007e	c1 e8 0c	 shr	 eax, 12
  00081	83 e0 01	 and	 eax, 1
  00084	85 c0		 test	 eax, eax
  00086	0f 85 fc 00 00
	00		 jne	 $LN6@ckd_dasd_c

; 734  :             // "%1d:%04X CKD file %s: cache hits %d, misses %d, waits %d"
; 735  :             WRMSG( HHC00417, "I", LCSS_DEVNUM,

  0008c	48 83 bc 24 a0
	00 00 00 00	 cmp	 QWORD PTR dev$[rsp], 0
  00095	74 12		 je	 SHORT $LN9@ckd_dasd_c
  00097	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  0009f	0f b7 40 48	 movzx	 eax, WORD PTR [rax+72]
  000a3	89 44 24 78	 mov	 DWORD PTR tv93[rsp], eax
  000a7	eb 08		 jmp	 SHORT $LN10@ckd_dasd_c
$LN9@ckd_dasd_c:
  000a9	c7 44 24 78 00
	00 00 00	 mov	 DWORD PTR tv93[rsp], 0
$LN10@ckd_dasd_c:
  000b1	48 83 bc 24 a0
	00 00 00 00	 cmp	 QWORD PTR dev$[rsp], 0
  000ba	74 14		 je	 SHORT $LN11@ckd_dasd_c
  000bc	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  000c4	0f b7 40 44	 movzx	 eax, WORD PTR [rax+68]
  000c8	d1 f8		 sar	 eax, 1
  000ca	89 44 24 7c	 mov	 DWORD PTR tv131[rsp], eax
  000ce	eb 08		 jmp	 SHORT $LN12@ckd_dasd_c
$LN11@ckd_dasd_c:
  000d0	c7 44 24 7c 00
	00 00 00	 mov	 DWORD PTR tv131[rsp], 0
$LN12@ckd_dasd_c:
  000d8	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  000e0	48 05 a4 00 00
	00		 add	 rax, 164		; 000000a4H
  000e6	48 89 84 24 80
	00 00 00	 mov	 QWORD PTR tv88[rsp], rax
  000ee	b9 01 00 00 00	 mov	 ecx, 1
  000f3	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  000f9	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  00101	8b 89 04 02 00
	00		 mov	 ecx, DWORD PTR [rcx+516]
  00107	89 4c 24 60	 mov	 DWORD PTR [rsp+96], ecx
  0010b	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  00113	8b 89 00 02 00
	00		 mov	 ecx, DWORD PTR [rcx+512]
  00119	89 4c 24 58	 mov	 DWORD PTR [rsp+88], ecx
  0011d	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  00125	8b 89 fc 01 00
	00		 mov	 ecx, DWORD PTR [rcx+508]
  0012b	89 4c 24 50	 mov	 DWORD PTR [rsp+80], ecx
  0012f	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR tv88[rsp]
  00137	48 89 4c 24 48	 mov	 QWORD PTR [rsp+72], rcx
  0013c	8b 4c 24 78	 mov	 ecx, DWORD PTR tv93[rsp]
  00140	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  00144	8b 4c 24 7c	 mov	 ecx, DWORD PTR tv131[rsp]
  00148	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  0014c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170146
  00153	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  00158	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170147
  0015f	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00164	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00169	41 b9 03 00 00
	00		 mov	 r9d, 3
  0016f	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG170148
  00176	ba e0 02 00 00	 mov	 edx, 736		; 000002e0H
  0017b	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170149
  00182	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg
$LN6@ckd_dasd_c:
$LN5@ckd_dasd_c:

; 736  :                    dev->filename, dev->cachehits, dev->cachemisses, dev->cachewaits );
; 737  : 
; 738  :     /* Close all of the CKD image files */
; 739  :     for (i = 0; i < dev->ckdnumfd; i++)

  00188	c7 44 24 74 00
	00 00 00	 mov	 DWORD PTR i$[rsp], 0
  00190	eb 0a		 jmp	 SHORT $LN4@ckd_dasd_c
$LN2@ckd_dasd_c:
  00192	8b 44 24 74	 mov	 eax, DWORD PTR i$[rsp]
  00196	ff c0		 inc	 eax
  00198	89 44 24 74	 mov	 DWORD PTR i$[rsp], eax
$LN4@ckd_dasd_c:
  0019c	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  001a4	8b 80 c4 11 00
	00		 mov	 eax, DWORD PTR [rax+4548]
  001aa	39 44 24 74	 cmp	 DWORD PTR i$[rsp], eax
  001ae	7d 33		 jge	 SHORT $LN3@ckd_dasd_c

; 740  :         if (dev->ckdfd[i] > 2)

  001b0	48 63 44 24 74	 movsxd	 rax, DWORD PTR i$[rsp]
  001b5	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  001bd	83 bc 81 c8 11
	00 00 02	 cmp	 DWORD PTR [rcx+rax*4+4552], 2
  001c5	7e 1a		 jle	 SHORT $LN7@ckd_dasd_c

; 741  :             close (dev->ckdfd[i]);

  001c7	48 63 44 24 74	 movsxd	 rax, DWORD PTR i$[rsp]
  001cc	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  001d4	8b 8c 81 c8 11
	00 00		 mov	 ecx, DWORD PTR [rcx+rax*4+4552]
  001db	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_close
$LN7@ckd_dasd_c:
  001e1	eb af		 jmp	 SHORT $LN2@ckd_dasd_c
$LN3@ckd_dasd_c:

; 742  : 
; 743  :     dev->buf = NULL;

  001e3	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  001eb	48 c7 80 c8 01
	00 00 00 00 00
	00		 mov	 QWORD PTR [rax+456], 0

; 744  :     dev->bufsize = 0;

  001f6	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  001fe	c7 80 d8 01 00
	00 00 00 00 00	 mov	 DWORD PTR [rax+472], 0

; 745  : 
; 746  :     return 0;

  00208	33 c0		 xor	 eax, eax

; 747  : } /* end function ckd_dasd_close_device */

  0020a	48 81 c4 98 00
	00 00		 add	 rsp, 152		; 00000098H
  00211	c3		 ret	 0
ckd_dasd_close_device ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\ckddasd.c
_TEXT	SEGMENT
rc$ = 96
num$ = 100
size$ = 104
cyl$ = 108
head$ = 112
offset$ = 116
mask$1 = 120
sector$ = 124
bcyl$2 = 128
ecyl$3 = 132
lastcyl$4 = 136
fmask$5 = 140
xgattr$6 = 141
lasthead$7 = 144
xblksz$8 = 148
xblksz$9 = 152
bhead$10 = 156
ehead$11 = 160
i$ = 164
j$ = 168
bin$ = 172
trk_ovfl$ = 173
tv298 = 176
tv1440 = 180
tv3712 = 184
tv4385 = 188
tv80 = 192
tv137 = 196
tv143 = 200
tv273 = 204
tv274 = 208
tv342 = 212
tv445 = 216
tv479 = 220
tv557 = 224
tv601 = 228
tv688 = 232
tv814 = 236
tv924 = 240
tv1008 = 244
tv1076 = 248
tv1137 = 252
tv1250 = 256
tv1365 = 260
tv1421 = 264
tv1422 = 268
tv1423 = 272
tv1424 = 276
tv1425 = 280
tv1426 = 284
tv1427 = 288
tv1428 = 292
tv1550 = 296
tv1570 = 300
tv1577 = 304
tv1775 = 308
tv1863 = 312
tv2033 = 316
tv2111 = 320
tv2165 = 324
tv2221 = 328
tv2276 = 332
tv2282 = 336
tv2350 = 340
tv2443 = 344
tv2510 = 348
tv2549 = 352
tv2576 = 356
tv2635 = 360
tv2662 = 364
tv2718 = 368
tv2755 = 372
tv2783 = 376
tv2842 = 380
tv2870 = 384
tv2946 = 388
tv3024 = 392
tv3114 = 396
tv3131 = 400
tv3193 = 404
tv3198 = 408
tv3797 = 412
tv4462 = 416
tv4698 = 420
tv4740 = 424
tv4768 = 428
tv4796 = 432
tv4933 = 436
tv4934 = 440
tv4946 = 444
tv4982 = 448
tv4994 = 452
tv5020 = 456
tv5088 = 460
tv5090 = 464
tv5115 = 468
tv5151 = 472
tv5275 = 476
tv5277 = 480
tv130 = 484
tv2057 = 488
tv2062 = 492
bcyl$12 = 496
bhead$13 = 500
ecyl$14 = 504
ehead$15 = 508
tv2258 = 512
kl$16 = 520
tv132 = 528
tv1582 = 536
tv2059 = 544
tv2261 = 552
tv2271 = 560
rechdr$ = 568
trkhdr$ = 576
cchhr$ = 584
binzero$ = 592
module$17 = 600
key$ = 656
__$ArrayPad$ = 912
dev$ = 960
code$ = 968
flags$ = 976
chained$ = 984
count$ = 992
prevcode$ = 1000
ccwseq$ = 1008
iobuf$ = 1016
more$ = 1024
unitstat$ = 1032
residual$ = 1040
ckd_dasd_execute_ccw PROC

; 2187 : {

$LN785:
  00000	44 88 4c 24 20	 mov	 BYTE PTR [rsp+32], r9b
  00005	44 88 44 24 18	 mov	 BYTE PTR [rsp+24], r8b
  0000a	88 54 24 10	 mov	 BYTE PTR [rsp+16], dl
  0000e	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00013	56		 push	 rsi
  00014	57		 push	 rdi
  00015	48 81 ec a8 03
	00 00		 sub	 rsp, 936		; 000003a8H
  0001c	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00023	48 33 c4	 xor	 rax, rsp
  00026	48 89 84 24 90
	03 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 2188 : int             rc;                     /* Return code               */
; 2189 : int             i, j;                   /* Loop index                */
; 2190 : CKD_TRKHDR      trkhdr;                 /* CKD track header (HA)     */
; 2191 : CKD_RECHDR      rechdr;                 /* CKD record header (count) */
; 2192 : U32             size;                   /* Number of bytes available */
; 2193 : U32             num;                    /* Number of bytes to move   */
; 2194 : U32             offset;                 /* Offset into buf for I/O   */
; 2195 : BYTE            bin;                    /* Bin number                */
; 2196 : U16             cyl;                    /* Cylinder number           */
; 2197 : U16             head;                   /* Head number               */
; 2198 : BYTE            cchhr[5];               /* Search argument           */
; 2199 : BYTE            binzero[5];             /* Binary zeros              */
; 2200 : BYTE            sector;                 /* Sector number             */
; 2201 : BYTE            key[256];               /* Key for search operations */
; 2202 : BYTE            trk_ovfl;               /* == 1 if track ovfl write  */
; 2203 : 
; 2204 :     /* If this is a data-chained READ, then return any data remaining
; 2205 :        in the buffer which was not used by the previous CCW */
; 2206 :     if (chained & CCW_FLAGS_CD)

  0002e	0f b6 84 24 d8
	03 00 00	 movzx	 eax, BYTE PTR chained$[rsp]
  00036	25 80 00 00 00	 and	 eax, 128		; 00000080H
  0003b	85 c0		 test	 eax, eax
  0003d	0f 84 0f 01 00
	00		 je	 $LN49@ckd_dasd_e

; 2207 :     {
; 2208 :         memmove (iobuf, iobuf + dev->ckdpos, dev->ckdrem);

  00043	48 8b 84 24 c0
	03 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  0004b	0f b7 80 ec 12
	00 00		 movzx	 eax, WORD PTR [rax+4844]
  00052	48 8b 8c 24 c0
	03 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  0005a	0f b7 89 ee 12
	00 00		 movzx	 ecx, WORD PTR [rcx+4846]
  00061	48 8b 94 24 f8
	03 00 00	 mov	 rdx, QWORD PTR iobuf$[rsp]
  00069	48 03 d1	 add	 rdx, rcx
  0006c	48 8b ca	 mov	 rcx, rdx
  0006f	44 8b c0	 mov	 r8d, eax
  00072	48 8b d1	 mov	 rdx, rcx
  00075	48 8b 8c 24 f8
	03 00 00	 mov	 rcx, QWORD PTR iobuf$[rsp]
  0007d	e8 00 00 00 00	 call	 memmove

; 2209 :         num = (count < dev->ckdrem) ? count : dev->ckdrem;

  00082	48 8b 84 24 c0
	03 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  0008a	0f b7 80 ec 12
	00 00		 movzx	 eax, WORD PTR [rax+4844]
  00091	39 84 24 e0 03
	00 00		 cmp	 DWORD PTR count$[rsp], eax
  00098	73 10		 jae	 SHORT $LN635@ckd_dasd_e
  0009a	8b 84 24 e0 03
	00 00		 mov	 eax, DWORD PTR count$[rsp]
  000a1	89 84 24 c0 00
	00 00		 mov	 DWORD PTR tv80[rsp], eax
  000a8	eb 16		 jmp	 SHORT $LN636@ckd_dasd_e
$LN635@ckd_dasd_e:
  000aa	48 8b 84 24 c0
	03 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  000b2	0f b7 80 ec 12
	00 00		 movzx	 eax, WORD PTR [rax+4844]
  000b9	89 84 24 c0 00
	00 00		 mov	 DWORD PTR tv80[rsp], eax
$LN636@ckd_dasd_e:
  000c0	8b 84 24 c0 00
	00 00		 mov	 eax, DWORD PTR tv80[rsp]
  000c7	89 44 24 64	 mov	 DWORD PTR num$[rsp], eax

; 2210 :         *residual = count - num;

  000cb	8b 44 24 64	 mov	 eax, DWORD PTR num$[rsp]
  000cf	8b 8c 24 e0 03
	00 00		 mov	 ecx, DWORD PTR count$[rsp]
  000d6	2b c8		 sub	 ecx, eax
  000d8	8b c1		 mov	 eax, ecx
  000da	48 8b 8c 24 10
	04 00 00	 mov	 rcx, QWORD PTR residual$[rsp]
  000e2	89 01		 mov	 DWORD PTR [rcx], eax

; 2211 :         if (count < dev->ckdrem) *more = 1;

  000e4	48 8b 84 24 c0
	03 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  000ec	0f b7 80 ec 12
	00 00		 movzx	 eax, WORD PTR [rax+4844]
  000f3	39 84 24 e0 03
	00 00		 cmp	 DWORD PTR count$[rsp], eax
  000fa	73 0b		 jae	 SHORT $LN50@ckd_dasd_e
  000fc	48 8b 84 24 00
	04 00 00	 mov	 rax, QWORD PTR more$[rsp]
  00104	c6 00 01	 mov	 BYTE PTR [rax], 1
$LN50@ckd_dasd_e:

; 2212 :         dev->ckdrem -= (U16)num;

  00107	0f b7 44 24 64	 movzx	 eax, WORD PTR num$[rsp]
  0010c	48 8b 8c 24 c0
	03 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  00114	0f b7 89 ec 12
	00 00		 movzx	 ecx, WORD PTR [rcx+4844]
  0011b	2b c8		 sub	 ecx, eax
  0011d	8b c1		 mov	 eax, ecx
  0011f	48 8b 8c 24 c0
	03 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  00127	66 89 81 ec 12
	00 00		 mov	 WORD PTR [rcx+4844], ax

; 2213 :         dev->ckdpos  = (U16)num;

  0012e	48 8b 84 24 c0
	03 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00136	0f b7 4c 24 64	 movzx	 ecx, WORD PTR num$[rsp]
  0013b	66 89 88 ee 12
	00 00		 mov	 WORD PTR [rax+4846], cx

; 2214 :         *unitstat = CSW_CE | CSW_DE;

  00142	48 8b 84 24 08
	04 00 00	 mov	 rax, QWORD PTR unitstat$[rsp]
  0014a	c6 00 0c	 mov	 BYTE PTR [rax], 12

; 2215 :         return;

  0014d	e9 84 a6 00 00	 jmp	 $LN1@ckd_dasd_e
$LN49@ckd_dasd_e:

; 2216 :     }
; 2217 : 
; 2218 :     /* Command reject if data chaining and command is not READ */
; 2219 :     if ((flags & CCW_FLAGS_CD) && !IS_CCW_READ( code ))

  00152	0f b6 84 24 d0
	03 00 00	 movzx	 eax, BYTE PTR flags$[rsp]
  0015a	25 80 00 00 00	 and	 eax, 128		; 00000080H
  0015f	85 c0		 test	 eax, eax
  00161	0f 84 36 01 00
	00		 je	 $LN51@ckd_dasd_e
  00167	0f b6 84 24 c8
	03 00 00	 movzx	 eax, BYTE PTR code$[rsp]
  0016f	83 e0 03	 and	 eax, 3
  00172	83 f8 02	 cmp	 eax, 2
  00175	0f 84 22 01 00
	00		 je	 $LN51@ckd_dasd_e

; 2220 :     {
; 2221 :         // "%1d:%04X CKD file %s: data chaining not supported for non-read CCW %02X"
; 2222 :         WRMSG( HHC00422, "E", LCSS_DEVNUM, dev->filename, code );

  0017b	48 83 bc 24 c0
	03 00 00 00	 cmp	 QWORD PTR dev$[rsp], 0
  00184	74 15		 je	 SHORT $LN637@ckd_dasd_e
  00186	48 8b 84 24 c0
	03 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  0018e	0f b7 40 48	 movzx	 eax, WORD PTR [rax+72]
  00192	89 84 24 c4 00
	00 00		 mov	 DWORD PTR tv137[rsp], eax
  00199	eb 0b		 jmp	 SHORT $LN638@ckd_dasd_e
$LN637@ckd_dasd_e:
  0019b	c7 84 24 c4 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv137[rsp], 0
$LN638@ckd_dasd_e:
  001a6	48 83 bc 24 c0
	03 00 00 00	 cmp	 QWORD PTR dev$[rsp], 0
  001af	74 17		 je	 SHORT $LN639@ckd_dasd_e
  001b1	48 8b 84 24 c0
	03 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  001b9	0f b7 40 44	 movzx	 eax, WORD PTR [rax+68]
  001bd	d1 f8		 sar	 eax, 1
  001bf	89 84 24 c8 00
	00 00		 mov	 DWORD PTR tv143[rsp], eax
  001c6	eb 0b		 jmp	 SHORT $LN640@ckd_dasd_e
$LN639@ckd_dasd_e:
  001c8	c7 84 24 c8 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv143[rsp], 0
$LN640@ckd_dasd_e:
  001d3	0f b6 84 24 c8
	03 00 00	 movzx	 eax, BYTE PTR code$[rsp]
  001db	89 84 24 e4 01
	00 00		 mov	 DWORD PTR tv130[rsp], eax
  001e2	48 8b 8c 24 c0
	03 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  001ea	48 81 c1 a4 00
	00 00		 add	 rcx, 164		; 000000a4H
  001f1	48 89 8c 24 10
	02 00 00	 mov	 QWORD PTR tv132[rsp], rcx
  001f9	b9 01 00 00 00	 mov	 ecx, 1
  001fe	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  00204	8b 8c 24 e4 01
	00 00		 mov	 ecx, DWORD PTR tv130[rsp]
  0020b	89 4c 24 50	 mov	 DWORD PTR [rsp+80], ecx
  0020f	48 8b 8c 24 10
	02 00 00	 mov	 rcx, QWORD PTR tv132[rsp]
  00217	48 89 4c 24 48	 mov	 QWORD PTR [rsp+72], rcx
  0021c	8b 8c 24 c4 00
	00 00		 mov	 ecx, DWORD PTR tv137[rsp]
  00223	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  00227	8b 8c 24 c8 00
	00 00		 mov	 ecx, DWORD PTR tv143[rsp]
  0022e	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  00232	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG171680
  00239	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  0023e	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG171681
  00245	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  0024a	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  0024f	41 b9 03 00 00
	00		 mov	 r9d, 3
  00255	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG171682
  0025c	ba ae 08 00 00	 mov	 edx, 2222		; 000008aeH
  00261	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG171683
  00268	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 2223 :         ckd_build_sense( dev, SENSE_CR, 0, 0, FORMAT_0, MESSAGE_1 );

  0026e	c6 44 24 28 01	 mov	 BYTE PTR [rsp+40], 1
  00273	c6 44 24 20 00	 mov	 BYTE PTR [rsp+32], 0
  00278	45 33 c9	 xor	 r9d, r9d
  0027b	45 33 c0	 xor	 r8d, r8d
  0027e	b2 80		 mov	 dl, 128			; 00000080H
  00280	48 8b 8c 24 c0
	03 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  00288	e8 00 00 00 00	 call	 ckd_build_sense

; 2224 :         *unitstat = CSW_CE | CSW_DE | CSW_UC;

  0028d	48 8b 84 24 08
	04 00 00	 mov	 rax, QWORD PTR unitstat$[rsp]
  00295	c6 00 0e	 mov	 BYTE PTR [rax], 14

; 2225 :         return;

  00298	e9 39 a5 00 00	 jmp	 $LN1@ckd_dasd_e
$LN51@ckd_dasd_e:

; 2226 :     }
; 2227 : 
; 2228 :     /* Reset flags at start of CCW chain */
; 2229 :     if (chained == 0)

  0029d	0f b6 84 24 d8
	03 00 00	 movzx	 eax, BYTE PTR chained$[rsp]
  002a5	85 c0		 test	 eax, eax
  002a7	0f 85 d8 02 00
	00		 jne	 $LN52@ckd_dasd_e

; 2230 :     {
; 2231 :         dev->ckdlocat = 0;

  002ad	48 8b 84 24 c0
	03 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  002b5	8b 80 14 13 00
	00		 mov	 eax, DWORD PTR [rax+4884]
  002bb	83 e0 f7	 and	 eax, -9			; fffffff7H
  002be	48 8b 8c 24 c0
	03 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  002c6	89 81 14 13 00
	00		 mov	 DWORD PTR [rcx+4884], eax

; 2232 :         dev->ckdspcnt = 0;

  002cc	48 8b 84 24 c0
	03 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  002d4	8b 80 14 13 00
	00		 mov	 eax, DWORD PTR [rax+4884]
  002da	83 e0 df	 and	 eax, -33		; ffffffdfH
  002dd	48 8b 8c 24 c0
	03 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  002e5	89 81 14 13 00
	00		 mov	 DWORD PTR [rcx+4884], eax

; 2233 :         dev->ckdseek = 0;

  002eb	48 8b 84 24 c0
	03 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  002f3	8b 80 14 13 00
	00		 mov	 eax, DWORD PTR [rax+4884]
  002f9	83 e0 bf	 and	 eax, -65		; ffffffbfH
  002fc	48 8b 8c 24 c0
	03 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  00304	89 81 14 13 00
	00		 mov	 DWORD PTR [rcx+4884], eax

; 2234 :         dev->ckdskcyl = 0;

  0030a	48 8b 84 24 c0
	03 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00312	8b 80 14 13 00
	00		 mov	 eax, DWORD PTR [rax+4884]
  00318	0f ba f0 07	 btr	 eax, 7
  0031c	48 8b 8c 24 c0
	03 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  00324	89 81 14 13 00
	00		 mov	 DWORD PTR [rcx+4884], eax

; 2235 :         dev->ckdrecal = 0;

  0032a	48 8b 84 24 c0
	03 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00332	8b 80 14 13 00
	00		 mov	 eax, DWORD PTR [rax+4884]
  00338	0f ba f0 08	 btr	 eax, 8
  0033c	48 8b 8c 24 c0
	03 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  00344	89 81 14 13 00
	00		 mov	 DWORD PTR [rcx+4884], eax

; 2236 :         dev->ckdrdipl = 0;

  0034a	48 8b 84 24 c0
	03 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00352	8b 80 14 13 00
	00		 mov	 eax, DWORD PTR [rax+4884]
  00358	0f ba f0 09	 btr	 eax, 9
  0035c	48 8b 8c 24 c0
	03 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  00364	89 81 14 13 00
	00		 mov	 DWORD PTR [rcx+4884], eax

; 2237 :         dev->ckdfmask = 0;

  0036a	48 8b 84 24 c0
	03 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00372	c6 80 fa 12 00
	00 00		 mov	 BYTE PTR [rax+4858], 0

; 2238 :         dev->ckdxmark = 0;

  00379	48 8b 84 24 c0
	03 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00381	8b 80 14 13 00
	00		 mov	 eax, DWORD PTR [rax+4884]
  00387	0f ba f0 0a	 btr	 eax, 10
  0038b	48 8b 8c 24 c0
	03 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  00393	89 81 14 13 00
	00		 mov	 DWORD PTR [rcx+4884], eax

; 2239 :         dev->ckdhaeq = 0;

  00399	48 8b 84 24 c0
	03 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  003a1	8b 80 14 13 00
	00		 mov	 eax, DWORD PTR [rax+4884]
  003a7	0f ba f0 0b	 btr	 eax, 11
  003ab	48 8b 8c 24 c0
	03 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  003b3	89 81 14 13 00
	00		 mov	 DWORD PTR [rcx+4884], eax

; 2240 :         dev->ckdideq = 0;

  003b9	48 8b 84 24 c0
	03 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  003c1	8b 80 14 13 00
	00		 mov	 eax, DWORD PTR [rax+4884]
  003c7	0f ba f0 0c	 btr	 eax, 12
  003cb	48 8b 8c 24 c0
	03 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  003d3	89 81 14 13 00
	00		 mov	 DWORD PTR [rcx+4884], eax

; 2241 :         dev->ckdkyeq = 0;

  003d9	48 8b 84 24 c0
	03 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  003e1	8b 80 14 13 00
	00		 mov	 eax, DWORD PTR [rax+4884]
  003e7	0f ba f0 0d	 btr	 eax, 13
  003eb	48 8b 8c 24 c0
	03 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  003f3	89 81 14 13 00
	00		 mov	 DWORD PTR [rcx+4884], eax

; 2242 :         dev->ckdwckd = 0;

  003f9	48 8b 84 24 c0
	03 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00401	8b 80 14 13 00
	00		 mov	 eax, DWORD PTR [rax+4884]
  00407	0f ba f0 0e	 btr	 eax, 14
  0040b	48 8b 8c 24 c0
	03 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  00413	89 81 14 13 00
	00		 mov	 DWORD PTR [rcx+4884], eax

; 2243 :         dev->ckdlcount = 0;

  00419	48 8b 84 24 c0
	03 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00421	c6 80 02 13 00
	00 00		 mov	 BYTE PTR [rax+4866], 0

; 2244 :         dev->ckdextcd = 0x00;

  00428	48 8b 84 24 c0
	03 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00430	c6 80 03 13 00
	00 00		 mov	 BYTE PTR [rax+4867], 0

; 2245 :         dev->ckdfcoun = 0;

  00437	48 8b 84 24 c0
	03 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  0043f	8b 80 14 13 00
	00		 mov	 eax, DWORD PTR [rax+4884]
  00445	83 e0 ef	 and	 eax, -17		; ffffffefH
  00448	48 8b 8c 24 c0
	03 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  00450	89 81 14 13 00
	00		 mov	 DWORD PTR [rcx+4884], eax

; 2246 :         dev->ckdlmask = 0;

  00456	33 c0		 xor	 eax, eax
  00458	48 8b 8c 24 c0
	03 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  00460	66 89 81 fe 12
	00 00		 mov	 WORD PTR [rcx+4862], ax

; 2247 :         dev->ckdtrkof = 0;

  00467	48 8b 84 24 c0
	03 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  0046f	8b 80 14 13 00
	00		 mov	 eax, DWORD PTR [rax+4884]
  00475	0f ba f0 0f	 btr	 eax, 15
  00479	48 8b 8c 24 c0
	03 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  00481	89 81 14 13 00
	00		 mov	 DWORD PTR [rcx+4884], eax

; 2248 :         /* ISW20030819-1 : Clear Write HA flag */
; 2249 :         dev->ckdwrha = 0;

  00487	48 8b 84 24 c0
	03 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  0048f	8b 80 14 13 00
	00		 mov	 eax, DWORD PTR [rax+4884]
  00495	0f ba f0 13	 btr	 eax, 19
  00499	48 8b 8c 24 c0
	03 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  004a1	89 81 14 13 00
	00		 mov	 DWORD PTR [rcx+4884], eax

; 2250 :         dev->ckdssdlen = 0;

  004a7	33 c0		 xor	 eax, eax
  004a9	48 8b 8c 24 c0
	03 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  004b1	66 89 81 1a 13
	00 00		 mov	 WORD PTR [rcx+4890], ax

; 2251 : 
; 2252 :         /* Set initial define extent parameters */
; 2253 :         dev->ckdxtdef = 0;

  004b8	48 8b 84 24 c0
	03 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  004c0	8b 80 14 13 00
	00		 mov	 eax, DWORD PTR [rax+4884]
  004c6	83 e0 fd	 and	 eax, -3			; fffffffdH
  004c9	48 8b 8c 24 c0
	03 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  004d1	89 81 14 13 00
	00		 mov	 DWORD PTR [rcx+4884], eax

; 2254 :         dev->ckdsetfm = 0;

  004d7	48 8b 84 24 c0
	03 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  004df	8b 80 14 13 00
	00		 mov	 eax, DWORD PTR [rax+4884]
  004e5	83 e0 fb	 and	 eax, -5			; fffffffbH
  004e8	48 8b 8c 24 c0
	03 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  004f0	89 81 14 13 00
	00		 mov	 DWORD PTR [rcx+4884], eax

; 2255 :         dev->ckdfmask = 0;

  004f6	48 8b 84 24 c0
	03 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  004fe	c6 80 fa 12 00
	00 00		 mov	 BYTE PTR [rax+4858], 0

; 2256 :         dev->ckdxgattr = 0;

  00505	48 8b 84 24 c0
	03 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  0050d	c6 80 fb 12 00
	00 00		 mov	 BYTE PTR [rax+4859], 0

; 2257 :         dev->ckdxblksz = 0;

  00514	33 c0		 xor	 eax, eax
  00516	48 8b 8c 24 c0
	03 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  0051e	66 89 81 f0 12
	00 00		 mov	 WORD PTR [rcx+4848], ax

; 2258 :         dev->ckdxbcyl = 0;

  00525	33 c0		 xor	 eax, eax
  00527	48 8b 8c 24 c0
	03 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  0052f	66 89 81 f2 12
	00 00		 mov	 WORD PTR [rcx+4850], ax

; 2259 :         dev->ckdxbhead = 0;

  00536	33 c0		 xor	 eax, eax
  00538	48 8b 8c 24 c0
	03 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  00540	66 89 81 f4 12
	00 00		 mov	 WORD PTR [rcx+4852], ax

; 2260 :         dev->ckdxecyl  = (U16)(dev->ckdcyls  - 1);

  00547	48 8b 84 24 c0
	03 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  0054f	8b 80 b8 12 00
	00		 mov	 eax, DWORD PTR [rax+4792]
  00555	ff c8		 dec	 eax
  00557	48 8b 8c 24 c0
	03 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  0055f	66 89 81 f6 12
	00 00		 mov	 WORD PTR [rcx+4854], ax

; 2261 :         dev->ckdxehead = (U16)(dev->ckdheads - 1);

  00566	48 8b 84 24 c0
	03 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  0056e	8b 80 c0 12 00
	00		 mov	 eax, DWORD PTR [rax+4800]
  00574	ff c8		 dec	 eax
  00576	48 8b 8c 24 c0
	03 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  0057e	66 89 81 f8 12
	00 00		 mov	 WORD PTR [rcx+4856], ax
$LN52@ckd_dasd_e:

; 2262 :     }
; 2263 : 
; 2264 :     /* Reset index marker flag if sense or control command,
; 2265 :        or any write command (other search ID or search key),
; 2266 :        or any read command except read sector --
; 2267 :        -- and except single track Read Count */
; 2268 :     if (IS_CCW_SENSE(code) || IS_CCW_CONTROL(code)
; 2269 :         || (IS_CCW_WRITE(code)
; 2270 :             && (code & 0x7F) != 0x31
; 2271 :             && (code & 0x7F) != 0x51
; 2272 :             && (code & 0x7F) != 0x71
; 2273 :             && (code & 0x7F) != 0x29
; 2274 :             && (code & 0x7F) != 0x49
; 2275 :             && (code & 0x7F) != 0x69)
; 2276 :         || (IS_CCW_READ(code)

  00585	0f b6 84 24 c8
	03 00 00	 movzx	 eax, BYTE PTR code$[rsp]
  0058d	83 e0 0f	 and	 eax, 15
  00590	83 f8 04	 cmp	 eax, 4
  00593	0f 84 b1 00 00
	00		 je	 $LN54@ckd_dasd_e
  00599	0f b6 84 24 c8
	03 00 00	 movzx	 eax, BYTE PTR code$[rsp]
  005a1	83 e0 03	 and	 eax, 3
  005a4	83 f8 03	 cmp	 eax, 3
  005a7	0f 84 9d 00 00
	00		 je	 $LN54@ckd_dasd_e
  005ad	0f b6 84 24 c8
	03 00 00	 movzx	 eax, BYTE PTR code$[rsp]
  005b5	83 e0 03	 and	 eax, 3
  005b8	83 f8 01	 cmp	 eax, 1
  005bb	75 60		 jne	 SHORT $LN55@ckd_dasd_e
  005bd	0f b6 84 24 c8
	03 00 00	 movzx	 eax, BYTE PTR code$[rsp]
  005c5	83 e0 7f	 and	 eax, 127		; 0000007fH
  005c8	83 f8 31	 cmp	 eax, 49			; 00000031H
  005cb	74 50		 je	 SHORT $LN55@ckd_dasd_e
  005cd	0f b6 84 24 c8
	03 00 00	 movzx	 eax, BYTE PTR code$[rsp]
  005d5	83 e0 7f	 and	 eax, 127		; 0000007fH
  005d8	83 f8 51	 cmp	 eax, 81			; 00000051H
  005db	74 40		 je	 SHORT $LN55@ckd_dasd_e
  005dd	0f b6 84 24 c8
	03 00 00	 movzx	 eax, BYTE PTR code$[rsp]
  005e5	83 e0 7f	 and	 eax, 127		; 0000007fH
  005e8	83 f8 71	 cmp	 eax, 113		; 00000071H
  005eb	74 30		 je	 SHORT $LN55@ckd_dasd_e
  005ed	0f b6 84 24 c8
	03 00 00	 movzx	 eax, BYTE PTR code$[rsp]
  005f5	83 e0 7f	 and	 eax, 127		; 0000007fH
  005f8	83 f8 29	 cmp	 eax, 41			; 00000029H
  005fb	74 20		 je	 SHORT $LN55@ckd_dasd_e
  005fd	0f b6 84 24 c8
	03 00 00	 movzx	 eax, BYTE PTR code$[rsp]
  00605	83 e0 7f	 and	 eax, 127		; 0000007fH
  00608	83 f8 49	 cmp	 eax, 73			; 00000049H
  0060b	74 10		 je	 SHORT $LN55@ckd_dasd_e
  0060d	0f b6 84 24 c8
	03 00 00	 movzx	 eax, BYTE PTR code$[rsp]
  00615	83 e0 7f	 and	 eax, 127		; 0000007fH
  00618	83 f8 69	 cmp	 eax, 105		; 00000069H
  0061b	75 2d		 jne	 SHORT $LN54@ckd_dasd_e
$LN55@ckd_dasd_e:
  0061d	0f b6 84 24 c8
	03 00 00	 movzx	 eax, BYTE PTR code$[rsp]
  00625	83 e0 03	 and	 eax, 3
  00628	83 f8 02	 cmp	 eax, 2
  0062b	75 3d		 jne	 SHORT $LN53@ckd_dasd_e
  0062d	0f b6 84 24 c8
	03 00 00	 movzx	 eax, BYTE PTR code$[rsp]
  00635	83 f8 12	 cmp	 eax, 18
  00638	74 30		 je	 SHORT $LN53@ckd_dasd_e
  0063a	0f b6 84 24 c8
	03 00 00	 movzx	 eax, BYTE PTR code$[rsp]
  00642	83 e0 7f	 and	 eax, 127		; 0000007fH
  00645	83 f8 22	 cmp	 eax, 34			; 00000022H
  00648	74 20		 je	 SHORT $LN53@ckd_dasd_e
$LN54@ckd_dasd_e:

; 2277 :             &&  code         != 0x12
; 2278 :             && (code & 0x7F) != 0x22))
; 2279 :         dev->ckdxmark = 0;

  0064a	48 8b 84 24 c0
	03 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00652	8b 80 14 13 00
	00		 mov	 eax, DWORD PTR [rax+4884]
  00658	0f ba f0 0a	 btr	 eax, 10
  0065c	48 8b 8c 24 c0
	03 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  00664	89 81 14 13 00
	00		 mov	 DWORD PTR [rcx+4884], eax
$LN53@ckd_dasd_e:

; 2280 : 
; 2281 :     /* Note current operation for track overflow sense byte 3 */
; 2282 :     dev->ckdcuroper = (IS_CCW_READ(code)) ? 6 :

  0066a	0f b6 84 24 c8
	03 00 00	 movzx	 eax, BYTE PTR code$[rsp]
  00672	83 e0 03	 and	 eax, 3
  00675	83 f8 02	 cmp	 eax, 2
  00678	75 0d		 jne	 SHORT $LN643@ckd_dasd_e
  0067a	c7 84 24 d0 00
	00 00 06 00 00
	00		 mov	 DWORD PTR tv274[rsp], 6
  00685	eb 36		 jmp	 SHORT $LN644@ckd_dasd_e
$LN643@ckd_dasd_e:
  00687	0f b6 84 24 c8
	03 00 00	 movzx	 eax, BYTE PTR code$[rsp]
  0068f	83 e0 03	 and	 eax, 3
  00692	83 f8 01	 cmp	 eax, 1
  00695	75 0d		 jne	 SHORT $LN641@ckd_dasd_e
  00697	c7 84 24 cc 00
	00 00 05 00 00
	00		 mov	 DWORD PTR tv273[rsp], 5
  006a2	eb 0b		 jmp	 SHORT $LN642@ckd_dasd_e
$LN641@ckd_dasd_e:
  006a4	c7 84 24 cc 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv273[rsp], 0
$LN642@ckd_dasd_e:
  006af	8b 84 24 cc 00
	00 00		 mov	 eax, DWORD PTR tv273[rsp]
  006b6	89 84 24 d0 00
	00 00		 mov	 DWORD PTR tv274[rsp], eax
$LN644@ckd_dasd_e:
  006bd	48 8b 84 24 c0
	03 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  006c5	8b 8c 24 d0 00
	00 00		 mov	 ecx, DWORD PTR tv274[rsp]
  006cc	89 88 dc 12 00
	00		 mov	 DWORD PTR [rax+4828], ecx

; 2283 :         ((IS_CCW_WRITE(code)) ? 5 : 0);
; 2284 : 
; 2285 :     /* If subsystem data has been prepared in the channel buffer by
; 2286 :        a previous Perform Subsystem Function command, generate a
; 2287 :        command reject if next command is not Read Subsystem Data */
; 2288 :     if (dev->ckdssdlen > 0 && code != 0x3E)

  006d2	48 8b 84 24 c0
	03 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  006da	0f b7 80 1a 13
	00 00		 movzx	 eax, WORD PTR [rax+4890]
  006e1	85 c0		 test	 eax, eax
  006e3	7e 3c		 jle	 SHORT $LN56@ckd_dasd_e
  006e5	0f b6 84 24 c8
	03 00 00	 movzx	 eax, BYTE PTR code$[rsp]
  006ed	83 f8 3e	 cmp	 eax, 62			; 0000003eH
  006f0	74 2f		 je	 SHORT $LN56@ckd_dasd_e

; 2289 :     {
; 2290 :         ckd_build_sense (dev, SENSE_CR, 0, 0,

  006f2	c6 44 24 28 02	 mov	 BYTE PTR [rsp+40], 2
  006f7	c6 44 24 20 00	 mov	 BYTE PTR [rsp+32], 0
  006fc	45 33 c9	 xor	 r9d, r9d
  006ff	45 33 c0	 xor	 r8d, r8d
  00702	b2 80		 mov	 dl, 128			; 00000080H
  00704	48 8b 8c 24 c0
	03 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  0070c	e8 00 00 00 00	 call	 ckd_build_sense

; 2291 :                         FORMAT_0, MESSAGE_2);
; 2292 :         *unitstat = CSW_CE | CSW_DE | CSW_UC;

  00711	48 8b 84 24 08
	04 00 00	 mov	 rax, QWORD PTR unitstat$[rsp]
  00719	c6 00 0e	 mov	 BYTE PTR [rax], 14

; 2293 :         return;

  0071c	e9 b5 a0 00 00	 jmp	 $LN1@ckd_dasd_e
$LN56@ckd_dasd_e:

; 2294 :     }
; 2295 : 
; 2296 :     /* If within Locate Record Extended domain and not RT command
; 2297 :        reject with status that includes Unit Check (Command Reject,
; 2298 :        format X'02', Invalid Command Sequence) */
; 2299 :     if (dev->ckdlmask && code != 0xDE)

  00721	48 8b 84 24 c0
	03 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00729	0f b7 80 fe 12
	00 00		 movzx	 eax, WORD PTR [rax+4862]
  00730	85 c0		 test	 eax, eax
  00732	74 3e		 je	 SHORT $LN57@ckd_dasd_e
  00734	0f b6 84 24 c8
	03 00 00	 movzx	 eax, BYTE PTR code$[rsp]
  0073c	3d de 00 00 00	 cmp	 eax, 222		; 000000deH
  00741	74 2f		 je	 SHORT $LN57@ckd_dasd_e

; 2300 :     {
; 2301 :         ckd_build_sense (dev, SENSE_CR, 0, 0,FORMAT_0, MESSAGE_2);

  00743	c6 44 24 28 02	 mov	 BYTE PTR [rsp+40], 2
  00748	c6 44 24 20 00	 mov	 BYTE PTR [rsp+32], 0
  0074d	45 33 c9	 xor	 r9d, r9d
  00750	45 33 c0	 xor	 r8d, r8d
  00753	b2 80		 mov	 dl, 128			; 00000080H
  00755	48 8b 8c 24 c0
	03 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  0075d	e8 00 00 00 00	 call	 ckd_build_sense

; 2302 :         *unitstat = CSW_CE | CSW_DE | CSW_UC;

  00762	48 8b 84 24 08
	04 00 00	 mov	 rax, QWORD PTR unitstat$[rsp]
  0076a	c6 00 0e	 mov	 BYTE PTR [rax], 14

; 2303 :         return;

  0076d	e9 64 a0 00 00	 jmp	 $LN1@ckd_dasd_e
$LN57@ckd_dasd_e:

; 2304 :     }
; 2305 : 
; 2306 :     /* Process depending on CCW opcode */
; 2307 :     switch (code) {

  00772	0f b6 84 24 c8
	03 00 00	 movzx	 eax, BYTE PTR code$[rsp]
  0077a	89 84 24 b0 00
	00 00		 mov	 DWORD PTR tv298[rsp], eax
  00781	8b 84 24 b0 00
	00 00		 mov	 eax, DWORD PTR tv298[rsp]
  00788	ff c8		 dec	 eax
  0078a	89 84 24 b0 00
	00 00		 mov	 DWORD PTR tv298[rsp], eax
  00791	81 bc 24 b0 00
	00 00 f9 00 00
	00		 cmp	 DWORD PTR tv298[rsp], 249 ; 000000f9H
  0079c	0f 87 84 9d 00
	00		 ja	 $LN622@ckd_dasd_e
  007a2	48 63 84 24 b0
	00 00 00	 movsxd	 rax, DWORD PTR tv298[rsp]
  007aa	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__ImageBase
  007b1	0f b6 84 01 00
	00 00 00	 movzx	 eax, BYTE PTR $LN783@ckd_dasd_e[rcx+rax]
  007b9	8b 84 81 00 00
	00 00		 mov	 eax, DWORD PTR $LN784@ckd_dasd_e[rcx+rax*4]
  007c0	48 03 c1	 add	 rax, rcx
  007c3	ff e0		 jmp	 rax
$LN58@ckd_dasd_e:

; 2308 : 
; 2309 :     case 0x02:
; 2310 :     /*---------------------------------------------------------------*/
; 2311 :     /* READ IPL                                                      */
; 2312 :     /*---------------------------------------------------------------*/
; 2313 :         /* Command reject if preceded by a Define Extent or
; 2314 :            Set File Mask, or within the domain of a Locate Record */
; 2315 :         if (dev->ckdxtdef || dev->ckdsetfm || dev->ckdlcount > 0)

  007c5	48 8b 84 24 c0
	03 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  007cd	8b 80 14 13 00
	00		 mov	 eax, DWORD PTR [rax+4884]
  007d3	d1 e8		 shr	 eax, 1
  007d5	83 e0 01	 and	 eax, 1
  007d8	85 c0		 test	 eax, eax
  007da	75 2b		 jne	 SHORT $LN60@ckd_dasd_e
  007dc	48 8b 84 24 c0
	03 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  007e4	8b 80 14 13 00
	00		 mov	 eax, DWORD PTR [rax+4884]
  007ea	c1 e8 02	 shr	 eax, 2
  007ed	83 e0 01	 and	 eax, 1
  007f0	85 c0		 test	 eax, eax
  007f2	75 13		 jne	 SHORT $LN60@ckd_dasd_e
  007f4	48 8b 84 24 c0
	03 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  007fc	0f b6 80 02 13
	00 00		 movzx	 eax, BYTE PTR [rax+4866]
  00803	85 c0		 test	 eax, eax
  00805	7e 2f		 jle	 SHORT $LN59@ckd_dasd_e
$LN60@ckd_dasd_e:

; 2316 :         {
; 2317 :             ckd_build_sense (dev, SENSE_CR, 0, 0,

  00807	c6 44 24 28 02	 mov	 BYTE PTR [rsp+40], 2
  0080c	c6 44 24 20 00	 mov	 BYTE PTR [rsp+32], 0
  00811	45 33 c9	 xor	 r9d, r9d
  00814	45 33 c0	 xor	 r8d, r8d
  00817	b2 80		 mov	 dl, 128			; 00000080H
  00819	48 8b 8c 24 c0
	03 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  00821	e8 00 00 00 00	 call	 ckd_build_sense

; 2318 :                             FORMAT_0, MESSAGE_2);
; 2319 :             *unitstat = CSW_CE | CSW_DE | CSW_UC;

  00826	48 8b 84 24 08
	04 00 00	 mov	 rax, QWORD PTR unitstat$[rsp]
  0082e	c6 00 0e	 mov	 BYTE PTR [rax], 14

; 2320 :             break;

  00831	e9 1a 9d 00 00	 jmp	 $LN2@ckd_dasd_e
$LN59@ckd_dasd_e:

; 2321 :         }
; 2322 : 
; 2323 :         /* No more define extend allowed */
; 2324 :         dev->ckdxtdef = 1;

  00836	48 8b 84 24 c0
	03 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  0083e	8b 80 14 13 00
	00		 mov	 eax, DWORD PTR [rax+4884]
  00844	83 c8 02	 or	 eax, 2
  00847	48 8b 8c 24 c0
	03 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  0084f	89 81 14 13 00
	00		 mov	 DWORD PTR [rcx+4884], eax

; 2325 :         dev->ckdsetfm = 1;

  00855	48 8b 84 24 c0
	03 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  0085d	8b 80 14 13 00
	00		 mov	 eax, DWORD PTR [rax+4884]
  00863	83 c8 04	 or	 eax, 4
  00866	48 8b 8c 24 c0
	03 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  0086e	89 81 14 13 00
	00		 mov	 DWORD PTR [rcx+4884], eax

; 2326 : 
; 2327 :         /* Set locate record parameters */
; 2328 :         dev->ckdloper = CKDOPER_ORIENT_DATA | CKDOPER_RDDATA;

  00874	48 8b 84 24 c0
	03 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  0087c	c6 80 00 13 00
	00 86		 mov	 BYTE PTR [rax+4864], 134 ; 00000086H

; 2329 :         dev->ckdlaux = 0;

  00883	48 8b 84 24 c0
	03 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  0088b	c6 80 01 13 00
	00 00		 mov	 BYTE PTR [rax+4865], 0

; 2330 :         dev->ckdlcount = 2;

  00892	48 8b 84 24 c0
	03 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  0089a	c6 80 02 13 00
	00 02		 mov	 BYTE PTR [rax+4866], 2

; 2331 :         dev->ckdltranlf = 0;

  008a1	33 c0		 xor	 eax, eax
  008a3	48 8b 8c 24 c0
	03 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  008ab	66 89 81 fc 12
	00 00		 mov	 WORD PTR [rcx+4860], ax

; 2332 : 
; 2333 :         /* Seek to start of cylinder zero track zero */
; 2334 :         rc = ckd_seek (dev, 0, 0, &trkhdr, unitstat);

  008b2	48 8b 84 24 08
	04 00 00	 mov	 rax, QWORD PTR unitstat$[rsp]
  008ba	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  008bf	4c 8d 8c 24 40
	02 00 00	 lea	 r9, QWORD PTR trkhdr$[rsp]
  008c7	45 33 c0	 xor	 r8d, r8d
  008ca	33 d2		 xor	 edx, edx
  008cc	48 8b 8c 24 c0
	03 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  008d4	e8 00 00 00 00	 call	 ckd_seek
  008d9	89 44 24 60	 mov	 DWORD PTR rc$[rsp], eax

; 2335 :         if (rc < 0) break;

  008dd	83 7c 24 60 00	 cmp	 DWORD PTR rc$[rsp], 0
  008e2	7d 05		 jge	 SHORT $LN61@ckd_dasd_e
  008e4	e9 67 9c 00 00	 jmp	 $LN2@ckd_dasd_e
$LN61@ckd_dasd_e:

; 2336 : 
; 2337 :         /* Read count field for first record following R0 */
; 2338 :         rc = ckd_read_count (dev, code, &rechdr, unitstat);

  008e9	4c 8b 8c 24 08
	04 00 00	 mov	 r9, QWORD PTR unitstat$[rsp]
  008f1	4c 8d 84 24 38
	02 00 00	 lea	 r8, QWORD PTR rechdr$[rsp]
  008f9	0f b6 94 24 c8
	03 00 00	 movzx	 edx, BYTE PTR code$[rsp]
  00901	48 8b 8c 24 c0
	03 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  00909	e8 00 00 00 00	 call	 ckd_read_count
  0090e	89 44 24 60	 mov	 DWORD PTR rc$[rsp], eax

; 2339 :         if (rc < 0) break;

  00912	83 7c 24 60 00	 cmp	 DWORD PTR rc$[rsp], 0
  00917	7d 05		 jge	 SHORT $LN62@ckd_dasd_e
  00919	e9 32 9c 00 00	 jmp	 $LN2@ckd_dasd_e
$LN62@ckd_dasd_e:

; 2340 : 
; 2341 :         /* Calculate number of bytes to read and set residual count */
; 2342 :         size = dev->ckdcurdl;

  0091e	48 8b 84 24 c0
	03 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00926	0f b7 80 ea 12
	00 00		 movzx	 eax, WORD PTR [rax+4842]
  0092d	89 44 24 68	 mov	 DWORD PTR size$[rsp], eax

; 2343 :         num = (count < size) ? count : size;

  00931	8b 44 24 68	 mov	 eax, DWORD PTR size$[rsp]
  00935	39 84 24 e0 03
	00 00		 cmp	 DWORD PTR count$[rsp], eax
  0093c	73 10		 jae	 SHORT $LN645@ckd_dasd_e
  0093e	8b 84 24 e0 03
	00 00		 mov	 eax, DWORD PTR count$[rsp]
  00945	89 84 24 d4 00
	00 00		 mov	 DWORD PTR tv342[rsp], eax
  0094c	eb 0b		 jmp	 SHORT $LN646@ckd_dasd_e
$LN645@ckd_dasd_e:
  0094e	8b 44 24 68	 mov	 eax, DWORD PTR size$[rsp]
  00952	89 84 24 d4 00
	00 00		 mov	 DWORD PTR tv342[rsp], eax
$LN646@ckd_dasd_e:
  00959	8b 84 24 d4 00
	00 00		 mov	 eax, DWORD PTR tv342[rsp]
  00960	89 44 24 64	 mov	 DWORD PTR num$[rsp], eax

; 2344 :         *residual = count - num;

  00964	8b 44 24 64	 mov	 eax, DWORD PTR num$[rsp]
  00968	8b 8c 24 e0 03
	00 00		 mov	 ecx, DWORD PTR count$[rsp]
  0096f	2b c8		 sub	 ecx, eax
  00971	8b c1		 mov	 eax, ecx
  00973	48 8b 8c 24 10
	04 00 00	 mov	 rcx, QWORD PTR residual$[rsp]
  0097b	89 01		 mov	 DWORD PTR [rcx], eax

; 2345 :         if (count < size) *more = 1;

  0097d	8b 44 24 68	 mov	 eax, DWORD PTR size$[rsp]
  00981	39 84 24 e0 03
	00 00		 cmp	 DWORD PTR count$[rsp], eax
  00988	73 0b		 jae	 SHORT $LN63@ckd_dasd_e
  0098a	48 8b 84 24 00
	04 00 00	 mov	 rax, QWORD PTR more$[rsp]
  00992	c6 00 01	 mov	 BYTE PTR [rax], 1
$LN63@ckd_dasd_e:

; 2346 : 
; 2347 :         /* Read data field */
; 2348 :         rc = ckd_read_data (dev, code, iobuf, unitstat);

  00995	4c 8b 8c 24 08
	04 00 00	 mov	 r9, QWORD PTR unitstat$[rsp]
  0099d	4c 8b 84 24 f8
	03 00 00	 mov	 r8, QWORD PTR iobuf$[rsp]
  009a5	0f b6 94 24 c8
	03 00 00	 movzx	 edx, BYTE PTR code$[rsp]
  009ad	48 8b 8c 24 c0
	03 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  009b5	e8 00 00 00 00	 call	 ckd_read_data
  009ba	89 44 24 60	 mov	 DWORD PTR rc$[rsp], eax

; 2349 :         if (rc < 0) break;

  009be	83 7c 24 60 00	 cmp	 DWORD PTR rc$[rsp], 0
  009c3	7d 05		 jge	 SHORT $LN64@ckd_dasd_e
  009c5	e9 86 9b 00 00	 jmp	 $LN2@ckd_dasd_e
$LN64@ckd_dasd_e:

; 2350 : 
; 2351 :         /* Set command processed flag */
; 2352 :         dev->ckdrdipl = 1;

  009ca	48 8b 84 24 c0
	03 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  009d2	8b 80 14 13 00
	00		 mov	 eax, DWORD PTR [rax+4884]
  009d8	0f ba e8 09	 bts	 eax, 9
  009dc	48 8b 8c 24 c0
	03 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  009e4	89 81 14 13 00
	00		 mov	 DWORD PTR [rcx+4884], eax

; 2353 : 
; 2354 :         /* Save size and offset of data not used by this CCW */
; 2355 :         dev->ckdrem = (U16)(size - num);

  009ea	8b 44 24 64	 mov	 eax, DWORD PTR num$[rsp]
  009ee	8b 4c 24 68	 mov	 ecx, DWORD PTR size$[rsp]
  009f2	2b c8		 sub	 ecx, eax
  009f4	8b c1		 mov	 eax, ecx
  009f6	48 8b 8c 24 c0
	03 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  009fe	66 89 81 ec 12
	00 00		 mov	 WORD PTR [rcx+4844], ax

; 2356 :         dev->ckdpos = (U16)(       num);

  00a05	48 8b 84 24 c0
	03 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00a0d	0f b7 4c 24 64	 movzx	 ecx, WORD PTR num$[rsp]
  00a12	66 89 88 ee 12
	00 00		 mov	 WORD PTR [rax+4846], cx

; 2357 : 
; 2358 :         /* Return unit exception if data length is zero */
; 2359 :         if (dev->ckdcurdl == 0)

  00a19	48 8b 84 24 c0
	03 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00a21	0f b7 80 ea 12
	00 00		 movzx	 eax, WORD PTR [rax+4842]
  00a28	85 c0		 test	 eax, eax
  00a2a	75 0d		 jne	 SHORT $LN65@ckd_dasd_e

; 2360 :             *unitstat = CSW_CE | CSW_DE | CSW_UX;

  00a2c	48 8b 84 24 08
	04 00 00	 mov	 rax, QWORD PTR unitstat$[rsp]
  00a34	c6 00 0d	 mov	 BYTE PTR [rax], 13
  00a37	eb 0b		 jmp	 SHORT $LN66@ckd_dasd_e
$LN65@ckd_dasd_e:

; 2361 :         else
; 2362 :             *unitstat = CSW_CE | CSW_DE;

  00a39	48 8b 84 24 08
	04 00 00	 mov	 rax, QWORD PTR unitstat$[rsp]
  00a41	c6 00 0c	 mov	 BYTE PTR [rax], 12
$LN66@ckd_dasd_e:

; 2363 : 
; 2364 :         break;

  00a44	e9 07 9b 00 00	 jmp	 $LN2@ckd_dasd_e
$LN67@ckd_dasd_e:

; 2365 : 
; 2366 :     case 0x03:
; 2367 :     /*---------------------------------------------------------------*/
; 2368 :     /* CONTROL NO-OPERATION                                          */
; 2369 :     /*---------------------------------------------------------------*/
; 2370 :         /* Command reject if within the domain of a Locate Record,   */
; 2371 :         /* except if Read IPL                          2012-08-14    */
; 2372 :         if (dev->ckdlcount > 0 && dev->prevcode != 0x02)

  00a49	48 8b 84 24 c0
	03 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00a51	0f b6 80 02 13
	00 00		 movzx	 eax, BYTE PTR [rax+4866]
  00a58	85 c0		 test	 eax, eax
  00a5a	7e 43		 jle	 SHORT $LN68@ckd_dasd_e
  00a5c	48 8b 84 24 c0
	03 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00a64	0f b6 80 7b 02
	00 00		 movzx	 eax, BYTE PTR [rax+635]
  00a6b	83 f8 02	 cmp	 eax, 2
  00a6e	74 2f		 je	 SHORT $LN68@ckd_dasd_e

; 2373 :         {
; 2374 :             ckd_build_sense (dev, SENSE_CR, 0, 0,

  00a70	c6 44 24 28 02	 mov	 BYTE PTR [rsp+40], 2
  00a75	c6 44 24 20 00	 mov	 BYTE PTR [rsp+32], 0
  00a7a	45 33 c9	 xor	 r9d, r9d
  00a7d	45 33 c0	 xor	 r8d, r8d
  00a80	b2 80		 mov	 dl, 128			; 00000080H
  00a82	48 8b 8c 24 c0
	03 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  00a8a	e8 00 00 00 00	 call	 ckd_build_sense

; 2375 :                             FORMAT_0, MESSAGE_2);
; 2376 :             *unitstat = CSW_CE | CSW_DE | CSW_UC;

  00a8f	48 8b 84 24 08
	04 00 00	 mov	 rax, QWORD PTR unitstat$[rsp]
  00a97	c6 00 0e	 mov	 BYTE PTR [rax], 14

; 2377 :             break;

  00a9a	e9 b1 9a 00 00	 jmp	 $LN2@ckd_dasd_e
$LN68@ckd_dasd_e:

; 2378 :         }
; 2379 : 
; 2380 :         /* Return normal status */
; 2381 :         *unitstat = CSW_CE | CSW_DE;

  00a9f	48 8b 84 24 08
	04 00 00	 mov	 rax, QWORD PTR unitstat$[rsp]
  00aa7	c6 00 0c	 mov	 BYTE PTR [rax], 12

; 2382 :         break;

  00aaa	e9 a1 9a 00 00	 jmp	 $LN2@ckd_dasd_e
$LN69@ckd_dasd_e:

; 2383 : 
; 2384 :     case 0x17:
; 2385 :     /*---------------------------------------------------------------*/
; 2386 :     /* RESTORE                                                       */
; 2387 :     /*---------------------------------------------------------------*/
; 2388 :         /* Command reject if within the domain of a Locate Record */
; 2389 :         if (dev->ckdlcount > 0)

  00aaf	48 8b 84 24 c0
	03 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00ab7	0f b6 80 02 13
	00 00		 movzx	 eax, BYTE PTR [rax+4866]
  00abe	85 c0		 test	 eax, eax
  00ac0	7e 2f		 jle	 SHORT $LN70@ckd_dasd_e

; 2390 :         {
; 2391 :             ckd_build_sense (dev, SENSE_CR, 0, 0,

  00ac2	c6 44 24 28 02	 mov	 BYTE PTR [rsp+40], 2
  00ac7	c6 44 24 20 00	 mov	 BYTE PTR [rsp+32], 0
  00acc	45 33 c9	 xor	 r9d, r9d
  00acf	45 33 c0	 xor	 r8d, r8d
  00ad2	b2 80		 mov	 dl, 128			; 00000080H
  00ad4	48 8b 8c 24 c0
	03 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  00adc	e8 00 00 00 00	 call	 ckd_build_sense

; 2392 :                             FORMAT_0, MESSAGE_2);
; 2393 :             *unitstat = CSW_CE | CSW_DE | CSW_UC;

  00ae1	48 8b 84 24 08
	04 00 00	 mov	 rax, QWORD PTR unitstat$[rsp]
  00ae9	c6 00 0e	 mov	 BYTE PTR [rax], 14

; 2394 :             break;

  00aec	e9 5f 9a 00 00	 jmp	 $LN2@ckd_dasd_e
$LN70@ckd_dasd_e:

; 2395 :         }
; 2396 : 
; 2397 :         /* Return normal status */
; 2398 :         *unitstat = CSW_CE | CSW_DE;

  00af1	48 8b 84 24 08
	04 00 00	 mov	 rax, QWORD PTR unitstat$[rsp]
  00af9	c6 00 0c	 mov	 BYTE PTR [rax], 12

; 2399 :         break;

  00afc	e9 4f 9a 00 00	 jmp	 $LN2@ckd_dasd_e
$LN71@ckd_dasd_e:
$LN72@ckd_dasd_e:
$LN73@ckd_dasd_e:
$LN74@ckd_dasd_e:

; 2400 : 
; 2401 :     case 0xA6:
; 2402 :     case 0xB6:
; 2403 : //FIXME: 0xA6/0xB6 ccw is undoc'd.  We are treating it as 0x86 except
; 2404 : //       we will allow a DX ccw to follow.
; 2405 :     case 0x06:
; 2406 :     case 0x86:
; 2407 :     /*---------------------------------------------------------------*/
; 2408 :     /* READ DATA                                                     */
; 2409 :     /*---------------------------------------------------------------*/
; 2410 :         /* For 3990, command reject if not preceded by Seek, Seek Cyl,
; 2411 :            Locate Record, Read IPL, or Recalibrate command */
; 2412 :         if (dev->ckd3990
; 2413 :             && dev->ckdseek == 0 && dev->ckdskcyl == 0
; 2414 :             && dev->ckdlocat == 0 && dev->ckdrdipl == 0
; 2415 :             && dev->ckdrecal == 0)

  00b01	48 8b 84 24 c0
	03 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00b09	8b 80 14 13 00
	00		 mov	 eax, DWORD PTR [rax+4884]
  00b0f	83 e0 01	 and	 eax, 1
  00b12	85 c0		 test	 eax, eax
  00b14	0f 84 ab 00 00
	00		 je	 $LN75@ckd_dasd_e
  00b1a	48 8b 84 24 c0
	03 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00b22	8b 80 14 13 00
	00		 mov	 eax, DWORD PTR [rax+4884]
  00b28	c1 e8 06	 shr	 eax, 6
  00b2b	83 e0 01	 and	 eax, 1
  00b2e	85 c0		 test	 eax, eax
  00b30	0f 85 8f 00 00
	00		 jne	 $LN75@ckd_dasd_e
  00b36	48 8b 84 24 c0
	03 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00b3e	8b 80 14 13 00
	00		 mov	 eax, DWORD PTR [rax+4884]
  00b44	c1 e8 07	 shr	 eax, 7
  00b47	83 e0 01	 and	 eax, 1
  00b4a	85 c0		 test	 eax, eax
  00b4c	75 77		 jne	 SHORT $LN75@ckd_dasd_e
  00b4e	48 8b 84 24 c0
	03 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00b56	8b 80 14 13 00
	00		 mov	 eax, DWORD PTR [rax+4884]
  00b5c	c1 e8 03	 shr	 eax, 3
  00b5f	83 e0 01	 and	 eax, 1
  00b62	85 c0		 test	 eax, eax
  00b64	75 5f		 jne	 SHORT $LN75@ckd_dasd_e
  00b66	48 8b 84 24 c0
	03 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00b6e	8b 80 14 13 00
	00		 mov	 eax, DWORD PTR [rax+4884]
  00b74	c1 e8 09	 shr	 eax, 9
  00b77	83 e0 01	 and	 eax, 1
  00b7a	85 c0		 test	 eax, eax
  00b7c	75 47		 jne	 SHORT $LN75@ckd_dasd_e
  00b7e	48 8b 84 24 c0
	03 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00b86	8b 80 14 13 00
	00		 mov	 eax, DWORD PTR [rax+4884]
  00b8c	c1 e8 08	 shr	 eax, 8
  00b8f	83 e0 01	 and	 eax, 1
  00b92	85 c0		 test	 eax, eax
  00b94	75 2f		 jne	 SHORT $LN75@ckd_dasd_e

; 2416 :         {
; 2417 :             ckd_build_sense (dev, SENSE_CR, 0, 0,

  00b96	c6 44 24 28 02	 mov	 BYTE PTR [rsp+40], 2
  00b9b	c6 44 24 20 00	 mov	 BYTE PTR [rsp+32], 0
  00ba0	45 33 c9	 xor	 r9d, r9d
  00ba3	45 33 c0	 xor	 r8d, r8d
  00ba6	b2 80		 mov	 dl, 128			; 00000080H
  00ba8	48 8b 8c 24 c0
	03 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  00bb0	e8 00 00 00 00	 call	 ckd_build_sense

; 2418 :                             FORMAT_0, MESSAGE_2);
; 2419 :             *unitstat = CSW_CE | CSW_DE | CSW_UC;

  00bb5	48 8b 84 24 08
	04 00 00	 mov	 rax, QWORD PTR unitstat$[rsp]
  00bbd	c6 00 0e	 mov	 BYTE PTR [rax], 14

; 2420 :             break;

  00bc0	e9 8b 99 00 00	 jmp	 $LN2@ckd_dasd_e
$LN75@ckd_dasd_e:

; 2421 :         }
; 2422 : 
; 2423 :         /* Check operation code if within domain of a Locate Record */
; 2424 :         if (dev->ckdlcount > 0)

  00bc5	48 8b 84 24 c0
	03 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00bcd	0f b6 80 02 13
	00 00		 movzx	 eax, BYTE PTR [rax+4866]
  00bd4	85 c0		 test	 eax, eax
  00bd6	7e 74		 jle	 SHORT $LN76@ckd_dasd_e

; 2425 :         {
; 2426 :             if (!((dev->ckdloper & CKDOPER_CODE) == CKDOPER_RDDATA

  00bd8	48 8b 84 24 c0
	03 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00be0	0f b6 80 00 13
	00 00		 movzx	 eax, BYTE PTR [rax+4864]
  00be7	83 e0 3f	 and	 eax, 63			; 0000003fH
  00bea	83 f8 06	 cmp	 eax, 6
  00bed	74 5d		 je	 SHORT $LN77@ckd_dasd_e
  00bef	48 8b 84 24 c0
	03 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00bf7	0f b6 80 00 13
	00 00		 movzx	 eax, BYTE PTR [rax+4864]
  00bfe	83 e0 3f	 and	 eax, 63			; 0000003fH
  00c01	83 f8 0a	 cmp	 eax, 10
  00c04	74 46		 je	 SHORT $LN77@ckd_dasd_e
  00c06	48 8b 84 24 c0
	03 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00c0e	0f b6 80 00 13
	00 00		 movzx	 eax, BYTE PTR [rax+4864]
  00c15	83 e0 3f	 and	 eax, 63			; 0000003fH
  00c18	83 f8 16	 cmp	 eax, 22
  00c1b	74 2f		 je	 SHORT $LN77@ckd_dasd_e

; 2427 :                   || (dev->ckdloper & CKDOPER_CODE) == CKDOPER_RDANY
; 2428 :                   || (dev->ckdloper & CKDOPER_CODE) == CKDOPER_READ))
; 2429 :             {
; 2430 :                 ckd_build_sense (dev, SENSE_CR, 0, 0,

  00c1d	c6 44 24 28 02	 mov	 BYTE PTR [rsp+40], 2
  00c22	c6 44 24 20 00	 mov	 BYTE PTR [rsp+32], 0
  00c27	45 33 c9	 xor	 r9d, r9d
  00c2a	45 33 c0	 xor	 r8d, r8d
  00c2d	b2 80		 mov	 dl, 128			; 00000080H
  00c2f	48 8b 8c 24 c0
	03 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  00c37	e8 00 00 00 00	 call	 ckd_build_sense

; 2431 :                                 FORMAT_0, MESSAGE_2);
; 2432 :                 *unitstat = CSW_CE | CSW_DE | CSW_UC;

  00c3c	48 8b 84 24 08
	04 00 00	 mov	 rax, QWORD PTR unitstat$[rsp]
  00c44	c6 00 0e	 mov	 BYTE PTR [rax], 14

; 2433 :                 break;

  00c47	e9 04 99 00 00	 jmp	 $LN2@ckd_dasd_e
$LN77@ckd_dasd_e:
$LN76@ckd_dasd_e:

; 2434 :             }
; 2435 :         }
; 2436 : 
; 2437 :         /* If not oriented to count or key field, read next count */
; 2438 :         if (dev->ckdorient != CKDORIENT_COUNT
; 2439 :             && dev->ckdorient != CKDORIENT_KEY)

  00c4c	48 8b 84 24 c0
	03 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00c54	83 b8 d8 12 00
	00 02		 cmp	 DWORD PTR [rax+4824], 2
  00c5b	74 46		 je	 SHORT $LN78@ckd_dasd_e
  00c5d	48 8b 84 24 c0
	03 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00c65	83 b8 d8 12 00
	00 03		 cmp	 DWORD PTR [rax+4824], 3
  00c6c	74 35		 je	 SHORT $LN78@ckd_dasd_e

; 2440 :         {
; 2441 :             rc = ckd_read_count (dev, code, &rechdr, unitstat);

  00c6e	4c 8b 8c 24 08
	04 00 00	 mov	 r9, QWORD PTR unitstat$[rsp]
  00c76	4c 8d 84 24 38
	02 00 00	 lea	 r8, QWORD PTR rechdr$[rsp]
  00c7e	0f b6 94 24 c8
	03 00 00	 movzx	 edx, BYTE PTR code$[rsp]
  00c86	48 8b 8c 24 c0
	03 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  00c8e	e8 00 00 00 00	 call	 ckd_read_count
  00c93	89 44 24 60	 mov	 DWORD PTR rc$[rsp], eax

; 2442 :             if (rc < 0) break;

  00c97	83 7c 24 60 00	 cmp	 DWORD PTR rc$[rsp], 0
  00c9c	7d 05		 jge	 SHORT $LN79@ckd_dasd_e
  00c9e	e9 ad 98 00 00	 jmp	 $LN2@ckd_dasd_e
$LN79@ckd_dasd_e:
$LN78@ckd_dasd_e:

; 2443 :         }
; 2444 : 
; 2445 :         /* Calculate number of bytes to read and set residual count */
; 2446 :         size = dev->ckdcurdl;

  00ca3	48 8b 84 24 c0
	03 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00cab	0f b7 80 ea 12
	00 00		 movzx	 eax, WORD PTR [rax+4842]
  00cb2	89 44 24 68	 mov	 DWORD PTR size$[rsp], eax

; 2447 :         num = (count < size) ? count : size;

  00cb6	8b 44 24 68	 mov	 eax, DWORD PTR size$[rsp]
  00cba	39 84 24 e0 03
	00 00		 cmp	 DWORD PTR count$[rsp], eax
  00cc1	73 10		 jae	 SHORT $LN647@ckd_dasd_e
  00cc3	8b 84 24 e0 03
	00 00		 mov	 eax, DWORD PTR count$[rsp]
  00cca	89 84 24 d8 00
	00 00		 mov	 DWORD PTR tv445[rsp], eax
  00cd1	eb 0b		 jmp	 SHORT $LN648@ckd_dasd_e
$LN647@ckd_dasd_e:
  00cd3	8b 44 24 68	 mov	 eax, DWORD PTR size$[rsp]
  00cd7	89 84 24 d8 00
	00 00		 mov	 DWORD PTR tv445[rsp], eax
$LN648@ckd_dasd_e:
  00cde	8b 84 24 d8 00
	00 00		 mov	 eax, DWORD PTR tv445[rsp]
  00ce5	89 44 24 64	 mov	 DWORD PTR num$[rsp], eax

; 2448 :         *residual = count - num;

  00ce9	8b 44 24 64	 mov	 eax, DWORD PTR num$[rsp]
  00ced	8b 8c 24 e0 03
	00 00		 mov	 ecx, DWORD PTR count$[rsp]
  00cf4	2b c8		 sub	 ecx, eax
  00cf6	8b c1		 mov	 eax, ecx
  00cf8	48 8b 8c 24 10
	04 00 00	 mov	 rcx, QWORD PTR residual$[rsp]
  00d00	89 01		 mov	 DWORD PTR [rcx], eax

; 2449 :         if (count < size) *more = 1;

  00d02	8b 44 24 68	 mov	 eax, DWORD PTR size$[rsp]
  00d06	39 84 24 e0 03
	00 00		 cmp	 DWORD PTR count$[rsp], eax
  00d0d	73 0b		 jae	 SHORT $LN80@ckd_dasd_e
  00d0f	48 8b 84 24 00
	04 00 00	 mov	 rax, QWORD PTR more$[rsp]
  00d17	c6 00 01	 mov	 BYTE PTR [rax], 1
$LN80@ckd_dasd_e:

; 2450 :         offset = 0;

  00d1a	c7 44 24 74 00
	00 00 00	 mov	 DWORD PTR offset$[rsp], 0

; 2451 : 
; 2452 :         /* Read data field */
; 2453 :         rc = ckd_read_data (dev, code, iobuf, unitstat);

  00d22	4c 8b 8c 24 08
	04 00 00	 mov	 r9, QWORD PTR unitstat$[rsp]
  00d2a	4c 8b 84 24 f8
	03 00 00	 mov	 r8, QWORD PTR iobuf$[rsp]
  00d32	0f b6 94 24 c8
	03 00 00	 movzx	 edx, BYTE PTR code$[rsp]
  00d3a	48 8b 8c 24 c0
	03 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  00d42	e8 00 00 00 00	 call	 ckd_read_data
  00d47	89 44 24 60	 mov	 DWORD PTR rc$[rsp], eax

; 2454 :         if (rc < 0) break;

  00d4b	83 7c 24 60 00	 cmp	 DWORD PTR rc$[rsp], 0
  00d50	7d 05		 jge	 SHORT $LN81@ckd_dasd_e
  00d52	e9 f9 97 00 00	 jmp	 $LN2@ckd_dasd_e
$LN81@ckd_dasd_e:
$LN4@ckd_dasd_e:

; 2455 : 
; 2456 :         /* If track overflow, keep reading */
; 2457 :         while (dev->ckdtrkof)

  00d57	48 8b 84 24 c0
	03 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00d5f	8b 80 14 13 00
	00		 mov	 eax, DWORD PTR [rax+4884]
  00d65	c1 e8 0f	 shr	 eax, 15
  00d68	83 e0 01	 and	 eax, 1
  00d6b	85 c0		 test	 eax, eax
  00d6d	0f 84 7d 01 00
	00		 je	 $LN5@ckd_dasd_e

; 2458 :         {
; 2459 :             /* Advance to next track */
; 2460 :             rc = mt_advance (dev, unitstat, 1);

  00d73	41 b8 01 00 00
	00		 mov	 r8d, 1
  00d79	48 8b 94 24 08
	04 00 00	 mov	 rdx, QWORD PTR unitstat$[rsp]
  00d81	48 8b 8c 24 c0
	03 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  00d89	e8 00 00 00 00	 call	 mt_advance
  00d8e	89 44 24 60	 mov	 DWORD PTR rc$[rsp], eax

; 2461 :             if (rc < 0) break;

  00d92	83 7c 24 60 00	 cmp	 DWORD PTR rc$[rsp], 0
  00d97	7d 05		 jge	 SHORT $LN82@ckd_dasd_e
  00d99	e9 52 01 00 00	 jmp	 $LN5@ckd_dasd_e
$LN82@ckd_dasd_e:

; 2462 : 
; 2463 :             /* Read the first count field */
; 2464 :             rc = ckd_read_count (dev, code, &rechdr, unitstat);

  00d9e	4c 8b 8c 24 08
	04 00 00	 mov	 r9, QWORD PTR unitstat$[rsp]
  00da6	4c 8d 84 24 38
	02 00 00	 lea	 r8, QWORD PTR rechdr$[rsp]
  00dae	0f b6 94 24 c8
	03 00 00	 movzx	 edx, BYTE PTR code$[rsp]
  00db6	48 8b 8c 24 c0
	03 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  00dbe	e8 00 00 00 00	 call	 ckd_read_count
  00dc3	89 44 24 60	 mov	 DWORD PTR rc$[rsp], eax

; 2465 :             if (rc < 0) break;

  00dc7	83 7c 24 60 00	 cmp	 DWORD PTR rc$[rsp], 0
  00dcc	7d 05		 jge	 SHORT $LN83@ckd_dasd_e
  00dce	e9 1d 01 00 00	 jmp	 $LN5@ckd_dasd_e
$LN83@ckd_dasd_e:

; 2466 : 
; 2467 :             /* Skip the key field if present */
; 2468 :             if (dev->ckdcurkl > 0)

  00dd3	48 8b 84 24 c0
	03 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00ddb	83 b8 d4 12 00
	00 00		 cmp	 DWORD PTR [rax+4820], 0
  00de2	7e 2a		 jle	 SHORT $LN84@ckd_dasd_e

; 2469 :                 dev->bufoff += dev->ckdcurkl;

  00de4	48 8b 84 24 c0
	03 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00dec	8b 80 e0 01 00
	00		 mov	 eax, DWORD PTR [rax+480]
  00df2	48 8b 8c 24 c0
	03 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  00dfa	03 81 d4 12 00
	00		 add	 eax, DWORD PTR [rcx+4820]
  00e00	48 8b 8c 24 c0
	03 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  00e08	89 81 e0 01 00
	00		 mov	 DWORD PTR [rcx+480], eax
$LN84@ckd_dasd_e:

; 2470 : 
; 2471 :             /* Set offset into buffer for this read */
; 2472 :             offset += num;

  00e0e	8b 44 24 64	 mov	 eax, DWORD PTR num$[rsp]
  00e12	8b 4c 24 74	 mov	 ecx, DWORD PTR offset$[rsp]
  00e16	03 c8		 add	 ecx, eax
  00e18	8b c1		 mov	 eax, ecx
  00e1a	89 44 24 74	 mov	 DWORD PTR offset$[rsp], eax

; 2473 : 
; 2474 :             /* Account for size of this overflow record */
; 2475 :             size = dev->ckdcurdl;

  00e1e	48 8b 84 24 c0
	03 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00e26	0f b7 80 ea 12
	00 00		 movzx	 eax, WORD PTR [rax+4842]
  00e2d	89 44 24 68	 mov	 DWORD PTR size$[rsp], eax

; 2476 :             num = (*residual < size) ? *residual : size;

  00e31	48 8b 84 24 10
	04 00 00	 mov	 rax, QWORD PTR residual$[rsp]
  00e39	8b 4c 24 68	 mov	 ecx, DWORD PTR size$[rsp]
  00e3d	39 08		 cmp	 DWORD PTR [rax], ecx
  00e3f	73 13		 jae	 SHORT $LN649@ckd_dasd_e
  00e41	48 8b 84 24 10
	04 00 00	 mov	 rax, QWORD PTR residual$[rsp]
  00e49	8b 00		 mov	 eax, DWORD PTR [rax]
  00e4b	89 84 24 dc 00
	00 00		 mov	 DWORD PTR tv479[rsp], eax
  00e52	eb 0b		 jmp	 SHORT $LN650@ckd_dasd_e
$LN649@ckd_dasd_e:
  00e54	8b 44 24 68	 mov	 eax, DWORD PTR size$[rsp]
  00e58	89 84 24 dc 00
	00 00		 mov	 DWORD PTR tv479[rsp], eax
$LN650@ckd_dasd_e:
  00e5f	8b 84 24 dc 00
	00 00		 mov	 eax, DWORD PTR tv479[rsp]
  00e66	89 44 24 64	 mov	 DWORD PTR num$[rsp], eax

; 2477 :             if (*residual < size) *more = 1;

  00e6a	48 8b 84 24 10
	04 00 00	 mov	 rax, QWORD PTR residual$[rsp]
  00e72	8b 4c 24 68	 mov	 ecx, DWORD PTR size$[rsp]
  00e76	39 08		 cmp	 DWORD PTR [rax], ecx
  00e78	73 0d		 jae	 SHORT $LN85@ckd_dasd_e
  00e7a	48 8b 84 24 00
	04 00 00	 mov	 rax, QWORD PTR more$[rsp]
  00e82	c6 00 01	 mov	 BYTE PTR [rax], 1
  00e85	eb 0b		 jmp	 SHORT $LN86@ckd_dasd_e
$LN85@ckd_dasd_e:

; 2478 :             else *more = 0;

  00e87	48 8b 84 24 00
	04 00 00	 mov	 rax, QWORD PTR more$[rsp]
  00e8f	c6 00 00	 mov	 BYTE PTR [rax], 0
$LN86@ckd_dasd_e:

; 2479 :             *residual -= num;

  00e92	48 8b 84 24 10
	04 00 00	 mov	 rax, QWORD PTR residual$[rsp]
  00e9a	8b 4c 24 64	 mov	 ecx, DWORD PTR num$[rsp]
  00e9e	8b 00		 mov	 eax, DWORD PTR [rax]
  00ea0	2b c1		 sub	 eax, ecx
  00ea2	48 8b 8c 24 10
	04 00 00	 mov	 rcx, QWORD PTR residual$[rsp]
  00eaa	89 01		 mov	 DWORD PTR [rcx], eax

; 2480 : 
; 2481 :             /* Read the next data field */
; 2482 :             rc = ckd_read_data (dev, code, iobuf+offset, unitstat);

  00eac	8b 44 24 74	 mov	 eax, DWORD PTR offset$[rsp]
  00eb0	48 8b 8c 24 f8
	03 00 00	 mov	 rcx, QWORD PTR iobuf$[rsp]
  00eb8	48 03 c8	 add	 rcx, rax
  00ebb	48 8b c1	 mov	 rax, rcx
  00ebe	4c 8b 8c 24 08
	04 00 00	 mov	 r9, QWORD PTR unitstat$[rsp]
  00ec6	4c 8b c0	 mov	 r8, rax
  00ec9	0f b6 94 24 c8
	03 00 00	 movzx	 edx, BYTE PTR code$[rsp]
  00ed1	48 8b 8c 24 c0
	03 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  00ed9	e8 00 00 00 00	 call	 ckd_read_data
  00ede	89 44 24 60	 mov	 DWORD PTR rc$[rsp], eax

; 2483 :             if (rc < 0) break;

  00ee2	83 7c 24 60 00	 cmp	 DWORD PTR rc$[rsp], 0
  00ee7	7d 02		 jge	 SHORT $LN87@ckd_dasd_e
  00ee9	eb 05		 jmp	 SHORT $LN5@ckd_dasd_e
$LN87@ckd_dasd_e:

; 2484 :         }

  00eeb	e9 67 fe ff ff	 jmp	 $LN4@ckd_dasd_e
$LN5@ckd_dasd_e:

; 2485 : 
; 2486 :         /* Bail out if track overflow produced I/O error */
; 2487 :         if (rc < 0) break;

  00ef0	83 7c 24 60 00	 cmp	 DWORD PTR rc$[rsp], 0
  00ef5	7d 05		 jge	 SHORT $LN88@ckd_dasd_e
  00ef7	e9 54 96 00 00	 jmp	 $LN2@ckd_dasd_e
$LN88@ckd_dasd_e:

; 2488 : 
; 2489 :         /* Save size and offset of data not used by this CCW */
; 2490 :         dev->ckdrem = (U16)(size - num);

  00efc	8b 44 24 64	 mov	 eax, DWORD PTR num$[rsp]
  00f00	8b 4c 24 68	 mov	 ecx, DWORD PTR size$[rsp]
  00f04	2b c8		 sub	 ecx, eax
  00f06	8b c1		 mov	 eax, ecx
  00f08	48 8b 8c 24 c0
	03 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  00f10	66 89 81 ec 12
	00 00		 mov	 WORD PTR [rcx+4844], ax

; 2491 :         dev->ckdpos = (U16)(       num);

  00f17	48 8b 84 24 c0
	03 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00f1f	0f b7 4c 24 64	 movzx	 ecx, WORD PTR num$[rsp]
  00f24	66 89 88 ee 12
	00 00		 mov	 WORD PTR [rax+4846], cx

; 2492 : 
; 2493 :         /* Return unit exception if data length is zero */
; 2494 :         if (dev->ckdcurdl == 0)

  00f2b	48 8b 84 24 c0
	03 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00f33	0f b7 80 ea 12
	00 00		 movzx	 eax, WORD PTR [rax+4842]
  00f3a	85 c0		 test	 eax, eax
  00f3c	75 0d		 jne	 SHORT $LN89@ckd_dasd_e

; 2495 :             *unitstat = CSW_CE | CSW_DE | CSW_UX;

  00f3e	48 8b 84 24 08
	04 00 00	 mov	 rax, QWORD PTR unitstat$[rsp]
  00f46	c6 00 0d	 mov	 BYTE PTR [rax], 13
  00f49	eb 0b		 jmp	 SHORT $LN90@ckd_dasd_e
$LN89@ckd_dasd_e:

; 2496 :         else
; 2497 :             *unitstat = CSW_CE | CSW_DE;

  00f4b	48 8b 84 24 08
	04 00 00	 mov	 rax, QWORD PTR unitstat$[rsp]
  00f53	c6 00 0c	 mov	 BYTE PTR [rax], 12
$LN90@ckd_dasd_e:

; 2498 : 
; 2499 :         break;

  00f56	e9 f5 95 00 00	 jmp	 $LN2@ckd_dasd_e
$LN91@ckd_dasd_e:
$LN92@ckd_dasd_e:

; 2500 : 
; 2501 :     case 0x0E:
; 2502 :     case 0x8E:
; 2503 :     /*---------------------------------------------------------------*/
; 2504 :     /* READ KEY AND DATA                                             */
; 2505 :     /*---------------------------------------------------------------*/
; 2506 :         /* For 3990, command reject if not preceded by Seek, Seek Cyl,
; 2507 :            Locate Record, Read IPL, or Recalibrate command */
; 2508 :         if (dev->ckd3990
; 2509 :             && dev->ckdseek == 0 && dev->ckdskcyl == 0
; 2510 :             && dev->ckdlocat == 0 && dev->ckdrdipl == 0
; 2511 :             && dev->ckdrecal == 0)

  00f5b	48 8b 84 24 c0
	03 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00f63	8b 80 14 13 00
	00		 mov	 eax, DWORD PTR [rax+4884]
  00f69	83 e0 01	 and	 eax, 1
  00f6c	85 c0		 test	 eax, eax
  00f6e	0f 84 ab 00 00
	00		 je	 $LN93@ckd_dasd_e
  00f74	48 8b 84 24 c0
	03 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00f7c	8b 80 14 13 00
	00		 mov	 eax, DWORD PTR [rax+4884]
  00f82	c1 e8 06	 shr	 eax, 6
  00f85	83 e0 01	 and	 eax, 1
  00f88	85 c0		 test	 eax, eax
  00f8a	0f 85 8f 00 00
	00		 jne	 $LN93@ckd_dasd_e
  00f90	48 8b 84 24 c0
	03 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00f98	8b 80 14 13 00
	00		 mov	 eax, DWORD PTR [rax+4884]
  00f9e	c1 e8 07	 shr	 eax, 7
  00fa1	83 e0 01	 and	 eax, 1
  00fa4	85 c0		 test	 eax, eax
  00fa6	75 77		 jne	 SHORT $LN93@ckd_dasd_e
  00fa8	48 8b 84 24 c0
	03 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00fb0	8b 80 14 13 00
	00		 mov	 eax, DWORD PTR [rax+4884]
  00fb6	c1 e8 03	 shr	 eax, 3
  00fb9	83 e0 01	 and	 eax, 1
  00fbc	85 c0		 test	 eax, eax
  00fbe	75 5f		 jne	 SHORT $LN93@ckd_dasd_e
  00fc0	48 8b 84 24 c0
	03 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00fc8	8b 80 14 13 00
	00		 mov	 eax, DWORD PTR [rax+4884]
  00fce	c1 e8 09	 shr	 eax, 9
  00fd1	83 e0 01	 and	 eax, 1
  00fd4	85 c0		 test	 eax, eax
  00fd6	75 47		 jne	 SHORT $LN93@ckd_dasd_e
  00fd8	48 8b 84 24 c0
	03 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00fe0	8b 80 14 13 00
	00		 mov	 eax, DWORD PTR [rax+4884]
  00fe6	c1 e8 08	 shr	 eax, 8
  00fe9	83 e0 01	 and	 eax, 1
  00fec	85 c0		 test	 eax, eax
  00fee	75 2f		 jne	 SHORT $LN93@ckd_dasd_e

; 2512 :         {
; 2513 :             ckd_build_sense (dev, SENSE_CR, 0, 0,

  00ff0	c6 44 24 28 02	 mov	 BYTE PTR [rsp+40], 2
  00ff5	c6 44 24 20 00	 mov	 BYTE PTR [rsp+32], 0
  00ffa	45 33 c9	 xor	 r9d, r9d
  00ffd	45 33 c0	 xor	 r8d, r8d
  01000	b2 80		 mov	 dl, 128			; 00000080H
  01002	48 8b 8c 24 c0
	03 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  0100a	e8 00 00 00 00	 call	 ckd_build_sense

; 2514 :                             FORMAT_0, MESSAGE_2);
; 2515 :             *unitstat = CSW_CE | CSW_DE | CSW_UC;

  0100f	48 8b 84 24 08
	04 00 00	 mov	 rax, QWORD PTR unitstat$[rsp]
  01017	c6 00 0e	 mov	 BYTE PTR [rax], 14

; 2516 :             break;

  0101a	e9 31 95 00 00	 jmp	 $LN2@ckd_dasd_e
$LN93@ckd_dasd_e:

; 2517 :         }
; 2518 : 
; 2519 :         /* Check operation code if within domain of a Locate Record */
; 2520 :         if (dev->ckdlcount > 0)

  0101f	48 8b 84 24 c0
	03 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  01027	0f b6 80 02 13
	00 00		 movzx	 eax, BYTE PTR [rax+4866]
  0102e	85 c0		 test	 eax, eax
  01030	7e 5d		 jle	 SHORT $LN94@ckd_dasd_e

; 2521 :         {
; 2522 :             /*
; 2523 :              * 3990 reference says LRE CKDOPER_RDANY "must be followed
; 2524 :              * by a sequence of multi-track Read Count, Read Count Key
; 2525 :              * and Data, or Read Data commands".  That is, it doesn't
; 2526 :              * mention Read Key and Data.
; 2527 :              */
; 2528 :             if (!((dev->ckdloper & CKDOPER_CODE) == CKDOPER_RDDATA

  01032	48 8b 84 24 c0
	03 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  0103a	0f b6 80 00 13
	00 00		 movzx	 eax, BYTE PTR [rax+4864]
  01041	83 e0 3f	 and	 eax, 63			; 0000003fH
  01044	83 f8 06	 cmp	 eax, 6
  01047	74 46		 je	 SHORT $LN95@ckd_dasd_e
  01049	48 8b 84 24 c0
	03 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  01051	0f b6 80 00 13
	00 00		 movzx	 eax, BYTE PTR [rax+4864]
  01058	83 e0 3f	 and	 eax, 63			; 0000003fH
  0105b	83 f8 16	 cmp	 eax, 22
  0105e	74 2f		 je	 SHORT $LN95@ckd_dasd_e

; 2529 :                /* || (dev->ckdloper & CKDOPER_CODE) == CKDOPER_RDANY */
; 2530 :                   || (dev->ckdloper & CKDOPER_CODE) == CKDOPER_READ))
; 2531 :             {
; 2532 :                 ckd_build_sense (dev, SENSE_CR, 0, 0,

  01060	c6 44 24 28 02	 mov	 BYTE PTR [rsp+40], 2
  01065	c6 44 24 20 00	 mov	 BYTE PTR [rsp+32], 0
  0106a	45 33 c9	 xor	 r9d, r9d
  0106d	45 33 c0	 xor	 r8d, r8d
  01070	b2 80		 mov	 dl, 128			; 00000080H
  01072	48 8b 8c 24 c0
	03 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  0107a	e8 00 00 00 00	 call	 ckd_build_sense

; 2533 :                                 FORMAT_0, MESSAGE_2);
; 2534 :                 *unitstat = CSW_CE | CSW_DE | CSW_UC;

  0107f	48 8b 84 24 08
	04 00 00	 mov	 rax, QWORD PTR unitstat$[rsp]
  01087	c6 00 0e	 mov	 BYTE PTR [rax], 14

; 2535 :                 break;

  0108a	e9 c1 94 00 00	 jmp	 $LN2@ckd_dasd_e
$LN95@ckd_dasd_e:
$LN94@ckd_dasd_e:

; 2536 :             }
; 2537 :         }
; 2538 : 
; 2539 :         /* If not oriented to count field, read next count */
; 2540 :         if (dev->ckdorient != CKDORIENT_COUNT)

  0108f	48 8b 84 24 c0
	03 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  01097	83 b8 d8 12 00
	00 02		 cmp	 DWORD PTR [rax+4824], 2
  0109e	74 35		 je	 SHORT $LN96@ckd_dasd_e

; 2541 :         {
; 2542 :             rc = ckd_read_count (dev, code, &rechdr, unitstat);

  010a0	4c 8b 8c 24 08
	04 00 00	 mov	 r9, QWORD PTR unitstat$[rsp]
  010a8	4c 8d 84 24 38
	02 00 00	 lea	 r8, QWORD PTR rechdr$[rsp]
  010b0	0f b6 94 24 c8
	03 00 00	 movzx	 edx, BYTE PTR code$[rsp]
  010b8	48 8b 8c 24 c0
	03 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  010c0	e8 00 00 00 00	 call	 ckd_read_count
  010c5	89 44 24 60	 mov	 DWORD PTR rc$[rsp], eax

; 2543 :             if (rc < 0) break;

  010c9	83 7c 24 60 00	 cmp	 DWORD PTR rc$[rsp], 0
  010ce	7d 05		 jge	 SHORT $LN97@ckd_dasd_e
  010d0	e9 7b 94 00 00	 jmp	 $LN2@ckd_dasd_e
$LN97@ckd_dasd_e:
$LN96@ckd_dasd_e:

; 2544 :         }
; 2545 : 
; 2546 :         /* Calculate number of bytes to read and set residual count */
; 2547 :         size = dev->ckdcurkl + dev->ckdcurdl;

  010d5	48 8b 84 24 c0
	03 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  010dd	0f b7 80 ea 12
	00 00		 movzx	 eax, WORD PTR [rax+4842]
  010e4	48 8b 8c 24 c0
	03 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  010ec	03 81 d4 12 00
	00		 add	 eax, DWORD PTR [rcx+4820]
  010f2	89 44 24 68	 mov	 DWORD PTR size$[rsp], eax

; 2548 :         num = (count < size) ? count : size;

  010f6	8b 44 24 68	 mov	 eax, DWORD PTR size$[rsp]
  010fa	39 84 24 e0 03
	00 00		 cmp	 DWORD PTR count$[rsp], eax
  01101	73 10		 jae	 SHORT $LN651@ckd_dasd_e
  01103	8b 84 24 e0 03
	00 00		 mov	 eax, DWORD PTR count$[rsp]
  0110a	89 84 24 e0 00
	00 00		 mov	 DWORD PTR tv557[rsp], eax
  01111	eb 0b		 jmp	 SHORT $LN652@ckd_dasd_e
$LN651@ckd_dasd_e:
  01113	8b 44 24 68	 mov	 eax, DWORD PTR size$[rsp]
  01117	89 84 24 e0 00
	00 00		 mov	 DWORD PTR tv557[rsp], eax
$LN652@ckd_dasd_e:
  0111e	8b 84 24 e0 00
	00 00		 mov	 eax, DWORD PTR tv557[rsp]
  01125	89 44 24 64	 mov	 DWORD PTR num$[rsp], eax

; 2549 :         *residual = count - num;

  01129	8b 44 24 64	 mov	 eax, DWORD PTR num$[rsp]
  0112d	8b 8c 24 e0 03
	00 00		 mov	 ecx, DWORD PTR count$[rsp]
  01134	2b c8		 sub	 ecx, eax
  01136	8b c1		 mov	 eax, ecx
  01138	48 8b 8c 24 10
	04 00 00	 mov	 rcx, QWORD PTR residual$[rsp]
  01140	89 01		 mov	 DWORD PTR [rcx], eax

; 2550 :         if (count < size) *more = 1;

  01142	8b 44 24 68	 mov	 eax, DWORD PTR size$[rsp]
  01146	39 84 24 e0 03
	00 00		 cmp	 DWORD PTR count$[rsp], eax
  0114d	73 0b		 jae	 SHORT $LN98@ckd_dasd_e
  0114f	48 8b 84 24 00
	04 00 00	 mov	 rax, QWORD PTR more$[rsp]
  01157	c6 00 01	 mov	 BYTE PTR [rax], 1
$LN98@ckd_dasd_e:

; 2551 :         offset = dev->ckdcurkl;

  0115a	48 8b 84 24 c0
	03 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  01162	8b 80 d4 12 00
	00		 mov	 eax, DWORD PTR [rax+4820]
  01168	89 44 24 74	 mov	 DWORD PTR offset$[rsp], eax

; 2552 : 
; 2553 :         /* Read key field */
; 2554 :         rc = ckd_read_key (dev, code, iobuf, unitstat);

  0116c	4c 8b 8c 24 08
	04 00 00	 mov	 r9, QWORD PTR unitstat$[rsp]
  01174	4c 8b 84 24 f8
	03 00 00	 mov	 r8, QWORD PTR iobuf$[rsp]
  0117c	0f b6 94 24 c8
	03 00 00	 movzx	 edx, BYTE PTR code$[rsp]
  01184	48 8b 8c 24 c0
	03 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  0118c	e8 00 00 00 00	 call	 ckd_read_key
  01191	89 44 24 60	 mov	 DWORD PTR rc$[rsp], eax

; 2555 :         if (rc < 0) break;

  01195	83 7c 24 60 00	 cmp	 DWORD PTR rc$[rsp], 0
  0119a	7d 05		 jge	 SHORT $LN99@ckd_dasd_e
  0119c	e9 af 93 00 00	 jmp	 $LN2@ckd_dasd_e
$LN99@ckd_dasd_e:

; 2556 : 
; 2557 :         /* Read data field */
; 2558 :         rc = ckd_read_data (dev, code, iobuf+dev->ckdcurkl, unitstat);

  011a1	48 8b 84 24 c0
	03 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  011a9	48 63 80 d4 12
	00 00		 movsxd	 rax, DWORD PTR [rax+4820]
  011b0	48 8b 8c 24 f8
	03 00 00	 mov	 rcx, QWORD PTR iobuf$[rsp]
  011b8	48 03 c8	 add	 rcx, rax
  011bb	48 8b c1	 mov	 rax, rcx
  011be	4c 8b 8c 24 08
	04 00 00	 mov	 r9, QWORD PTR unitstat$[rsp]
  011c6	4c 8b c0	 mov	 r8, rax
  011c9	0f b6 94 24 c8
	03 00 00	 movzx	 edx, BYTE PTR code$[rsp]
  011d1	48 8b 8c 24 c0
	03 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  011d9	e8 00 00 00 00	 call	 ckd_read_data
  011de	89 44 24 60	 mov	 DWORD PTR rc$[rsp], eax

; 2559 :         if (rc < 0) break;

  011e2	83 7c 24 60 00	 cmp	 DWORD PTR rc$[rsp], 0
  011e7	7d 05		 jge	 SHORT $LN100@ckd_dasd_e
  011e9	e9 62 93 00 00	 jmp	 $LN2@ckd_dasd_e
$LN100@ckd_dasd_e:
$LN6@ckd_dasd_e:

; 2560 : 
; 2561 :         /* If track overflow, keep reading */
; 2562 :         while (dev->ckdtrkof)

  011ee	48 8b 84 24 c0
	03 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  011f6	8b 80 14 13 00
	00		 mov	 eax, DWORD PTR [rax+4884]
  011fc	c1 e8 0f	 shr	 eax, 15
  011ff	83 e0 01	 and	 eax, 1
  01202	85 c0		 test	 eax, eax
  01204	0f 84 7d 01 00
	00		 je	 $LN7@ckd_dasd_e

; 2563 :         {
; 2564 :             /* Advance to next track */
; 2565 :             rc = mt_advance (dev, unitstat, 1);

  0120a	41 b8 01 00 00
	00		 mov	 r8d, 1
  01210	48 8b 94 24 08
	04 00 00	 mov	 rdx, QWORD PTR unitstat$[rsp]
  01218	48 8b 8c 24 c0
	03 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  01220	e8 00 00 00 00	 call	 mt_advance
  01225	89 44 24 60	 mov	 DWORD PTR rc$[rsp], eax

; 2566 :             if (rc < 0) break;

  01229	83 7c 24 60 00	 cmp	 DWORD PTR rc$[rsp], 0
  0122e	7d 05		 jge	 SHORT $LN101@ckd_dasd_e
  01230	e9 52 01 00 00	 jmp	 $LN7@ckd_dasd_e
$LN101@ckd_dasd_e:

; 2567 : 
; 2568 :             /* Read the first count field */
; 2569 :             rc = ckd_read_count (dev, code, &rechdr, unitstat);

  01235	4c 8b 8c 24 08
	04 00 00	 mov	 r9, QWORD PTR unitstat$[rsp]
  0123d	4c 8d 84 24 38
	02 00 00	 lea	 r8, QWORD PTR rechdr$[rsp]
  01245	0f b6 94 24 c8
	03 00 00	 movzx	 edx, BYTE PTR code$[rsp]
  0124d	48 8b 8c 24 c0
	03 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  01255	e8 00 00 00 00	 call	 ckd_read_count
  0125a	89 44 24 60	 mov	 DWORD PTR rc$[rsp], eax

; 2570 :             if (rc < 0) break;

  0125e	83 7c 24 60 00	 cmp	 DWORD PTR rc$[rsp], 0
  01263	7d 05		 jge	 SHORT $LN102@ckd_dasd_e
  01265	e9 1d 01 00 00	 jmp	 $LN7@ckd_dasd_e
$LN102@ckd_dasd_e:

; 2571 : 
; 2572 :             /* Skip the key field if present */
; 2573 :             if (dev->ckdcurkl > 0)

  0126a	48 8b 84 24 c0
	03 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  01272	83 b8 d4 12 00
	00 00		 cmp	 DWORD PTR [rax+4820], 0
  01279	7e 2a		 jle	 SHORT $LN103@ckd_dasd_e

; 2574 :                 dev->bufoff += dev->ckdcurkl;

  0127b	48 8b 84 24 c0
	03 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  01283	8b 80 e0 01 00
	00		 mov	 eax, DWORD PTR [rax+480]
  01289	48 8b 8c 24 c0
	03 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  01291	03 81 d4 12 00
	00		 add	 eax, DWORD PTR [rcx+4820]
  01297	48 8b 8c 24 c0
	03 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  0129f	89 81 e0 01 00
	00		 mov	 DWORD PTR [rcx+480], eax
$LN103@ckd_dasd_e:

; 2575 : 
; 2576 :             /* Set offset into buffer for this read */
; 2577 :             offset += num;

  012a5	8b 44 24 64	 mov	 eax, DWORD PTR num$[rsp]
  012a9	8b 4c 24 74	 mov	 ecx, DWORD PTR offset$[rsp]
  012ad	03 c8		 add	 ecx, eax
  012af	8b c1		 mov	 eax, ecx
  012b1	89 44 24 74	 mov	 DWORD PTR offset$[rsp], eax

; 2578 : 
; 2579 :             /* Account for size of this overflow record */
; 2580 :             size = dev->ckdcurdl;

  012b5	48 8b 84 24 c0
	03 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  012bd	0f b7 80 ea 12
	00 00		 movzx	 eax, WORD PTR [rax+4842]
  012c4	89 44 24 68	 mov	 DWORD PTR size$[rsp], eax

; 2581 :             num = (*residual < size) ? *residual : size;

  012c8	48 8b 84 24 10
	04 00 00	 mov	 rax, QWORD PTR residual$[rsp]
  012d0	8b 4c 24 68	 mov	 ecx, DWORD PTR size$[rsp]
  012d4	39 08		 cmp	 DWORD PTR [rax], ecx
  012d6	73 13		 jae	 SHORT $LN653@ckd_dasd_e
  012d8	48 8b 84 24 10
	04 00 00	 mov	 rax, QWORD PTR residual$[rsp]
  012e0	8b 00		 mov	 eax, DWORD PTR [rax]
  012e2	89 84 24 e4 00
	00 00		 mov	 DWORD PTR tv601[rsp], eax
  012e9	eb 0b		 jmp	 SHORT $LN654@ckd_dasd_e
$LN653@ckd_dasd_e:
  012eb	8b 44 24 68	 mov	 eax, DWORD PTR size$[rsp]
  012ef	89 84 24 e4 00
	00 00		 mov	 DWORD PTR tv601[rsp], eax
$LN654@ckd_dasd_e:
  012f6	8b 84 24 e4 00
	00 00		 mov	 eax, DWORD PTR tv601[rsp]
  012fd	89 44 24 64	 mov	 DWORD PTR num$[rsp], eax

; 2582 :             if (*residual < size) *more = 1;

  01301	48 8b 84 24 10
	04 00 00	 mov	 rax, QWORD PTR residual$[rsp]
  01309	8b 4c 24 68	 mov	 ecx, DWORD PTR size$[rsp]
  0130d	39 08		 cmp	 DWORD PTR [rax], ecx
  0130f	73 0d		 jae	 SHORT $LN104@ckd_dasd_e
  01311	48 8b 84 24 00
	04 00 00	 mov	 rax, QWORD PTR more$[rsp]
  01319	c6 00 01	 mov	 BYTE PTR [rax], 1
  0131c	eb 0b		 jmp	 SHORT $LN105@ckd_dasd_e
$LN104@ckd_dasd_e:

; 2583 :             else *more = 0;

  0131e	48 8b 84 24 00
	04 00 00	 mov	 rax, QWORD PTR more$[rsp]
  01326	c6 00 00	 mov	 BYTE PTR [rax], 0
$LN105@ckd_dasd_e:

; 2584 :             *residual -= num;

  01329	48 8b 84 24 10
	04 00 00	 mov	 rax, QWORD PTR residual$[rsp]
  01331	8b 4c 24 64	 mov	 ecx, DWORD PTR num$[rsp]
  01335	8b 00		 mov	 eax, DWORD PTR [rax]
  01337	2b c1		 sub	 eax, ecx
  01339	48 8b 8c 24 10
	04 00 00	 mov	 rcx, QWORD PTR residual$[rsp]
  01341	89 01		 mov	 DWORD PTR [rcx], eax

; 2585 : 
; 2586 :             /* Read the next data field */
; 2587 :             rc = ckd_read_data (dev, code, iobuf+offset, unitstat);

  01343	8b 44 24 74	 mov	 eax, DWORD PTR offset$[rsp]
  01347	48 8b 8c 24 f8
	03 00 00	 mov	 rcx, QWORD PTR iobuf$[rsp]
  0134f	48 03 c8	 add	 rcx, rax
  01352	48 8b c1	 mov	 rax, rcx
  01355	4c 8b 8c 24 08
	04 00 00	 mov	 r9, QWORD PTR unitstat$[rsp]
  0135d	4c 8b c0	 mov	 r8, rax
  01360	0f b6 94 24 c8
	03 00 00	 movzx	 edx, BYTE PTR code$[rsp]
  01368	48 8b 8c 24 c0
	03 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  01370	e8 00 00 00 00	 call	 ckd_read_data
  01375	89 44 24 60	 mov	 DWORD PTR rc$[rsp], eax

; 2588 :             if (rc < 0) break;

  01379	83 7c 24 60 00	 cmp	 DWORD PTR rc$[rsp], 0
  0137e	7d 02		 jge	 SHORT $LN106@ckd_dasd_e
  01380	eb 05		 jmp	 SHORT $LN7@ckd_dasd_e
$LN106@ckd_dasd_e:

; 2589 :         }

  01382	e9 67 fe ff ff	 jmp	 $LN6@ckd_dasd_e
$LN7@ckd_dasd_e:

; 2590 : 
; 2591 :         /* Bail out if track overflow produced I/O error */
; 2592 :         if (rc < 0) break;

  01387	83 7c 24 60 00	 cmp	 DWORD PTR rc$[rsp], 0
  0138c	7d 05		 jge	 SHORT $LN107@ckd_dasd_e
  0138e	e9 bd 91 00 00	 jmp	 $LN2@ckd_dasd_e
$LN107@ckd_dasd_e:

; 2593 : 
; 2594 :         /* Save size and offset of data not used by this CCW */
; 2595 :         dev->ckdrem = (U16)(size - num);

  01393	8b 44 24 64	 mov	 eax, DWORD PTR num$[rsp]
  01397	8b 4c 24 68	 mov	 ecx, DWORD PTR size$[rsp]
  0139b	2b c8		 sub	 ecx, eax
  0139d	8b c1		 mov	 eax, ecx
  0139f	48 8b 8c 24 c0
	03 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  013a7	66 89 81 ec 12
	00 00		 mov	 WORD PTR [rcx+4844], ax

; 2596 :         dev->ckdpos = (U16)(       num);

  013ae	48 8b 84 24 c0
	03 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  013b6	0f b7 4c 24 64	 movzx	 ecx, WORD PTR num$[rsp]
  013bb	66 89 88 ee 12
	00 00		 mov	 WORD PTR [rax+4846], cx

; 2597 : 
; 2598 :         /* Return unit exception if data length is zero */
; 2599 :         if (dev->ckdcurdl == 0)

  013c2	48 8b 84 24 c0
	03 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  013ca	0f b7 80 ea 12
	00 00		 movzx	 eax, WORD PTR [rax+4842]
  013d1	85 c0		 test	 eax, eax
  013d3	75 0d		 jne	 SHORT $LN108@ckd_dasd_e

; 2600 :             *unitstat = CSW_CE | CSW_DE | CSW_UX;

  013d5	48 8b 84 24 08
	04 00 00	 mov	 rax, QWORD PTR unitstat$[rsp]
  013dd	c6 00 0d	 mov	 BYTE PTR [rax], 13
  013e0	eb 0b		 jmp	 SHORT $LN109@ckd_dasd_e
$LN108@ckd_dasd_e:

; 2601 :         else
; 2602 :             *unitstat = CSW_CE | CSW_DE;

  013e2	48 8b 84 24 08
	04 00 00	 mov	 rax, QWORD PTR unitstat$[rsp]
  013ea	c6 00 0c	 mov	 BYTE PTR [rax], 12
$LN109@ckd_dasd_e:

; 2603 : 
; 2604 :         break;

  013ed	e9 5e 91 00 00	 jmp	 $LN2@ckd_dasd_e
$LN110@ckd_dasd_e:
$LN111@ckd_dasd_e:

; 2605 : 
; 2606 :     case 0x12:
; 2607 :     case 0x92:
; 2608 :     /*---------------------------------------------------------------*/
; 2609 :     /* READ COUNT                                                    */
; 2610 :     /*---------------------------------------------------------------*/
; 2611 :         /* For 3990, command reject if not preceded by Seek, Seek Cyl,
; 2612 :            Locate Record, Read IPL, or Recalibrate command */
; 2613 :         if (dev->ckd3990
; 2614 :             && dev->ckdseek == 0 && dev->ckdskcyl == 0
; 2615 :             && dev->ckdlocat == 0 && dev->ckdrdipl == 0
; 2616 :             && dev->ckdrecal == 0)

  013f2	48 8b 84 24 c0
	03 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  013fa	8b 80 14 13 00
	00		 mov	 eax, DWORD PTR [rax+4884]
  01400	83 e0 01	 and	 eax, 1
  01403	85 c0		 test	 eax, eax
  01405	0f 84 ab 00 00
	00		 je	 $LN112@ckd_dasd_e
  0140b	48 8b 84 24 c0
	03 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  01413	8b 80 14 13 00
	00		 mov	 eax, DWORD PTR [rax+4884]
  01419	c1 e8 06	 shr	 eax, 6
  0141c	83 e0 01	 and	 eax, 1
  0141f	85 c0		 test	 eax, eax
  01421	0f 85 8f 00 00
	00		 jne	 $LN112@ckd_dasd_e
  01427	48 8b 84 24 c0
	03 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  0142f	8b 80 14 13 00
	00		 mov	 eax, DWORD PTR [rax+4884]
  01435	c1 e8 07	 shr	 eax, 7
  01438	83 e0 01	 and	 eax, 1
  0143b	85 c0		 test	 eax, eax
  0143d	75 77		 jne	 SHORT $LN112@ckd_dasd_e
  0143f	48 8b 84 24 c0
	03 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  01447	8b 80 14 13 00
	00		 mov	 eax, DWORD PTR [rax+4884]
  0144d	c1 e8 03	 shr	 eax, 3
  01450	83 e0 01	 and	 eax, 1
  01453	85 c0		 test	 eax, eax
  01455	75 5f		 jne	 SHORT $LN112@ckd_dasd_e
  01457	48 8b 84 24 c0
	03 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  0145f	8b 80 14 13 00
	00		 mov	 eax, DWORD PTR [rax+4884]
  01465	c1 e8 09	 shr	 eax, 9
  01468	83 e0 01	 and	 eax, 1
  0146b	85 c0		 test	 eax, eax
  0146d	75 47		 jne	 SHORT $LN112@ckd_dasd_e
  0146f	48 8b 84 24 c0
	03 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  01477	8b 80 14 13 00
	00		 mov	 eax, DWORD PTR [rax+4884]
  0147d	c1 e8 08	 shr	 eax, 8
  01480	83 e0 01	 and	 eax, 1
  01483	85 c0		 test	 eax, eax
  01485	75 2f		 jne	 SHORT $LN112@ckd_dasd_e

; 2617 :         {
; 2618 :             ckd_build_sense (dev, SENSE_CR, 0, 0,

  01487	c6 44 24 28 02	 mov	 BYTE PTR [rsp+40], 2
  0148c	c6 44 24 20 00	 mov	 BYTE PTR [rsp+32], 0
  01491	45 33 c9	 xor	 r9d, r9d
  01494	45 33 c0	 xor	 r8d, r8d
  01497	b2 80		 mov	 dl, 128			; 00000080H
  01499	48 8b 8c 24 c0
	03 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  014a1	e8 00 00 00 00	 call	 ckd_build_sense

; 2619 :                             FORMAT_0, MESSAGE_2);
; 2620 :             *unitstat = CSW_CE | CSW_DE | CSW_UC;

  014a6	48 8b 84 24 08
	04 00 00	 mov	 rax, QWORD PTR unitstat$[rsp]
  014ae	c6 00 0e	 mov	 BYTE PTR [rax], 14

; 2621 :             break;

  014b1	e9 9a 90 00 00	 jmp	 $LN2@ckd_dasd_e
$LN112@ckd_dasd_e:

; 2622 :         }
; 2623 : 
; 2624 :         /* Check operation code if within domain of a Locate Record */
; 2625 :         if (dev->ckdlcount > 0)

  014b6	48 8b 84 24 c0
	03 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  014be	0f b6 80 02 13
	00 00		 movzx	 eax, BYTE PTR [rax+4866]
  014c5	85 c0		 test	 eax, eax
  014c7	0f 8e bd 00 00
	00		 jle	 $LN113@ckd_dasd_e

; 2626 :         {
; 2627 :             if (!((dev->ckdloper & CKDOPER_CODE) == CKDOPER_RDDATA

  014cd	48 8b 84 24 c0
	03 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  014d5	0f b6 80 00 13
	00 00		 movzx	 eax, BYTE PTR [rax+4864]
  014dc	83 e0 3f	 and	 eax, 63			; 0000003fH
  014df	83 f8 06	 cmp	 eax, 6
  014e2	0f 84 a2 00 00
	00		 je	 $LN114@ckd_dasd_e
  014e8	48 8b 84 24 c0
	03 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  014f0	0f b6 80 00 13
	00 00		 movzx	 eax, BYTE PTR [rax+4864]
  014f7	83 e0 3f	 and	 eax, 63			; 0000003fH
  014fa	83 f8 0a	 cmp	 eax, 10
  014fd	0f 84 87 00 00
	00		 je	 $LN114@ckd_dasd_e
  01503	48 8b 84 24 c0
	03 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  0150b	0f b6 80 00 13
	00 00		 movzx	 eax, BYTE PTR [rax+4864]
  01512	83 e0 3f	 and	 eax, 63			; 0000003fH
  01515	83 f8 16	 cmp	 eax, 22
  01518	74 70		 je	 SHORT $LN114@ckd_dasd_e
  0151a	48 8b 84 24 c0
	03 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  01522	0f b6 80 00 13
	00 00		 movzx	 eax, BYTE PTR [rax+4864]
  01529	83 e0 3f	 and	 eax, 63			; 0000003fH
  0152c	83 f8 01	 cmp	 eax, 1
  0152f	75 2a		 jne	 SHORT $LN115@ckd_dasd_e
  01531	48 8b 84 24 c0
	03 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  01539	0f b6 80 01 13
	00 00		 movzx	 eax, BYTE PTR [rax+4865]
  01540	83 e0 01	 and	 eax, 1
  01543	85 c0		 test	 eax, eax
  01545	74 14		 je	 SHORT $LN115@ckd_dasd_e
  01547	48 8b 84 24 c0
	03 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  0154f	0f b6 80 02 13
	00 00		 movzx	 eax, BYTE PTR [rax+4866]
  01556	83 f8 01	 cmp	 eax, 1
  01559	74 2f		 je	 SHORT $LN114@ckd_dasd_e
$LN115@ckd_dasd_e:

; 2628 :                   || (dev->ckdloper & CKDOPER_CODE) == CKDOPER_RDANY
; 2629 :                   || (dev->ckdloper & CKDOPER_CODE) == CKDOPER_READ
; 2630 :                   || ((dev->ckdloper & CKDOPER_CODE) == CKDOPER_WRITE
; 2631 :                       && (dev->ckdlaux & CKDLAUX_RDCNTSUF)
; 2632 :                       && dev->ckdlcount == 1)))
; 2633 :             {
; 2634 :                 ckd_build_sense (dev, SENSE_CR, 0, 0,

  0155b	c6 44 24 28 02	 mov	 BYTE PTR [rsp+40], 2
  01560	c6 44 24 20 00	 mov	 BYTE PTR [rsp+32], 0
  01565	45 33 c9	 xor	 r9d, r9d
  01568	45 33 c0	 xor	 r8d, r8d
  0156b	b2 80		 mov	 dl, 128			; 00000080H
  0156d	48 8b 8c 24 c0
	03 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  01575	e8 00 00 00 00	 call	 ckd_build_sense

; 2635 :                                 FORMAT_0, MESSAGE_2);
; 2636 :                 *unitstat = CSW_CE | CSW_DE | CSW_UC;

  0157a	48 8b 84 24 08
	04 00 00	 mov	 rax, QWORD PTR unitstat$[rsp]
  01582	c6 00 0e	 mov	 BYTE PTR [rax], 14

; 2637 :                 break;

  01585	e9 c6 8f 00 00	 jmp	 $LN2@ckd_dasd_e
$LN114@ckd_dasd_e:
$LN113@ckd_dasd_e:

; 2638 :             }
; 2639 :         }
; 2640 : 
; 2641 :         /* Read next count field */
; 2642 :         rc = ckd_read_count (dev, code, &rechdr, unitstat);

  0158a	4c 8b 8c 24 08
	04 00 00	 mov	 r9, QWORD PTR unitstat$[rsp]
  01592	4c 8d 84 24 38
	02 00 00	 lea	 r8, QWORD PTR rechdr$[rsp]
  0159a	0f b6 94 24 c8
	03 00 00	 movzx	 edx, BYTE PTR code$[rsp]
  015a2	48 8b 8c 24 c0
	03 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  015aa	e8 00 00 00 00	 call	 ckd_read_count
  015af	89 44 24 60	 mov	 DWORD PTR rc$[rsp], eax

; 2643 :         if (rc < 0) break;

  015b3	83 7c 24 60 00	 cmp	 DWORD PTR rc$[rsp], 0
  015b8	7d 05		 jge	 SHORT $LN116@ckd_dasd_e
  015ba	e9 91 8f 00 00	 jmp	 $LN2@ckd_dasd_e
$LN116@ckd_dasd_e:

; 2644 : 
; 2645 :         /* Calculate number of bytes to read and set residual count */
; 2646 :         size = CKD_RECHDR_SIZE;

  015bf	c7 44 24 68 08
	00 00 00	 mov	 DWORD PTR size$[rsp], 8

; 2647 :         num = (count < size) ? count : size;

  015c7	8b 44 24 68	 mov	 eax, DWORD PTR size$[rsp]
  015cb	39 84 24 e0 03
	00 00		 cmp	 DWORD PTR count$[rsp], eax
  015d2	73 10		 jae	 SHORT $LN655@ckd_dasd_e
  015d4	8b 84 24 e0 03
	00 00		 mov	 eax, DWORD PTR count$[rsp]
  015db	89 84 24 e8 00
	00 00		 mov	 DWORD PTR tv688[rsp], eax
  015e2	eb 0b		 jmp	 SHORT $LN656@ckd_dasd_e
$LN655@ckd_dasd_e:
  015e4	8b 44 24 68	 mov	 eax, DWORD PTR size$[rsp]
  015e8	89 84 24 e8 00
	00 00		 mov	 DWORD PTR tv688[rsp], eax
$LN656@ckd_dasd_e:
  015ef	8b 84 24 e8 00
	00 00		 mov	 eax, DWORD PTR tv688[rsp]
  015f6	89 44 24 64	 mov	 DWORD PTR num$[rsp], eax

; 2648 :         *residual = count - num;

  015fa	8b 44 24 64	 mov	 eax, DWORD PTR num$[rsp]
  015fe	8b 8c 24 e0 03
	00 00		 mov	 ecx, DWORD PTR count$[rsp]
  01605	2b c8		 sub	 ecx, eax
  01607	8b c1		 mov	 eax, ecx
  01609	48 8b 8c 24 10
	04 00 00	 mov	 rcx, QWORD PTR residual$[rsp]
  01611	89 01		 mov	 DWORD PTR [rcx], eax

; 2649 :         if (count < size) *more = 1;

  01613	8b 44 24 68	 mov	 eax, DWORD PTR size$[rsp]
  01617	39 84 24 e0 03
	00 00		 cmp	 DWORD PTR count$[rsp], eax
  0161e	73 0b		 jae	 SHORT $LN117@ckd_dasd_e
  01620	48 8b 84 24 00
	04 00 00	 mov	 rax, QWORD PTR more$[rsp]
  01628	c6 00 01	 mov	 BYTE PTR [rax], 1
$LN117@ckd_dasd_e:

; 2650 : 
; 2651 :         /* Copy count field to I/O buffer */
; 2652 :         memcpy (iobuf, &rechdr, CKD_RECHDR_SIZE);

  0162b	48 8b 84 24 f8
	03 00 00	 mov	 rax, QWORD PTR iobuf$[rsp]
  01633	48 8b 8c 24 38
	02 00 00	 mov	 rcx, QWORD PTR rechdr$[rsp]
  0163b	48 89 08	 mov	 QWORD PTR [rax], rcx

; 2653 :         if (!dev->ckdfcoun && dev->ckdlaux & CKDLAUX_RDCNTSUF)

  0163e	48 8b 84 24 c0
	03 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  01646	8b 80 14 13 00
	00		 mov	 eax, DWORD PTR [rax+4884]
  0164c	c1 e8 04	 shr	 eax, 4
  0164f	83 e0 01	 and	 eax, 1
  01652	85 c0		 test	 eax, eax
  01654	75 2d		 jne	 SHORT $LN118@ckd_dasd_e
  01656	48 8b 84 24 c0
	03 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  0165e	0f b6 80 01 13
	00 00		 movzx	 eax, BYTE PTR [rax+4865]
  01665	83 e0 01	 and	 eax, 1
  01668	85 c0		 test	 eax, eax
  0166a	74 17		 je	 SHORT $LN118@ckd_dasd_e

; 2654 :             memcpy(dev->ckdfcwrk, &rechdr, CKD_RECHDR_SIZE);

  0166c	48 8b 84 24 c0
	03 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  01674	48 8b 8c 24 38
	02 00 00	 mov	 rcx, QWORD PTR rechdr$[rsp]
  0167c	48 89 88 e0 12
	00 00		 mov	 QWORD PTR [rax+4832], rcx
$LN118@ckd_dasd_e:

; 2655 :         dev->ckdfcoun = 1;

  01683	48 8b 84 24 c0
	03 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  0168b	8b 80 14 13 00
	00		 mov	 eax, DWORD PTR [rax+4884]
  01691	83 c8 10	 or	 eax, 16
  01694	48 8b 8c 24 c0
	03 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  0169c	89 81 14 13 00
	00		 mov	 DWORD PTR [rcx+4884], eax

; 2656 :         /* Turn off track overflow flag in read record header */
; 2657 :         if(dev->ckdcyls < 32768)

  016a2	48 8b 84 24 c0
	03 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  016aa	81 b8 b8 12 00
	00 00 80 00 00	 cmp	 DWORD PTR [rax+4792], 32768 ; 00008000H
  016b4	7d 18		 jge	 SHORT $LN119@ckd_dasd_e

; 2658 :             *iobuf &= 0x7F;

  016b6	48 8b 84 24 f8
	03 00 00	 mov	 rax, QWORD PTR iobuf$[rsp]
  016be	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  016c1	83 e0 7f	 and	 eax, 127		; 0000007fH
  016c4	48 8b 8c 24 f8
	03 00 00	 mov	 rcx, QWORD PTR iobuf$[rsp]
  016cc	88 01		 mov	 BYTE PTR [rcx], al
$LN119@ckd_dasd_e:

; 2659 : 
; 2660 :         /* Save size and offset of data not used by this CCW */
; 2661 :         dev->ckdrem = (U16)(size - num);

  016ce	8b 44 24 64	 mov	 eax, DWORD PTR num$[rsp]
  016d2	8b 4c 24 68	 mov	 ecx, DWORD PTR size$[rsp]
  016d6	2b c8		 sub	 ecx, eax
  016d8	8b c1		 mov	 eax, ecx
  016da	48 8b 8c 24 c0
	03 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  016e2	66 89 81 ec 12
	00 00		 mov	 WORD PTR [rcx+4844], ax

; 2662 :         dev->ckdpos = (U16)(       num);

  016e9	48 8b 84 24 c0
	03 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  016f1	0f b7 4c 24 64	 movzx	 ecx, WORD PTR num$[rsp]
  016f6	66 89 88 ee 12
	00 00		 mov	 WORD PTR [rax+4846], cx

; 2663 : 
; 2664 :         /* Return normal status */
; 2665 :         *unitstat = CSW_CE | CSW_DE;

  016fd	48 8b 84 24 08
	04 00 00	 mov	 rax, QWORD PTR unitstat$[rsp]
  01705	c6 00 0c	 mov	 BYTE PTR [rax], 12

; 2666 :         break;

  01708	e9 43 8e 00 00	 jmp	 $LN2@ckd_dasd_e
$LN120@ckd_dasd_e:
$LN121@ckd_dasd_e:

; 2667 : 
; 2668 :     case 0x16:
; 2669 :     case 0x96:
; 2670 :     /*---------------------------------------------------------------*/
; 2671 :     /* READ RECORD ZERO                                              */
; 2672 :     /*---------------------------------------------------------------*/
; 2673 :         /* For 3990, command reject if not preceded by Seek, Seek Cyl,
; 2674 :            Locate Record, Read IPL, or Recalibrate command */
; 2675 :         if (dev->ckd3990
; 2676 :             && dev->ckdseek == 0 && dev->ckdskcyl == 0
; 2677 :             && dev->ckdlocat == 0 && dev->ckdrdipl == 0
; 2678 :             && dev->ckdrecal == 0)

  0170d	48 8b 84 24 c0
	03 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  01715	8b 80 14 13 00
	00		 mov	 eax, DWORD PTR [rax+4884]
  0171b	83 e0 01	 and	 eax, 1
  0171e	85 c0		 test	 eax, eax
  01720	0f 84 ab 00 00
	00		 je	 $LN122@ckd_dasd_e
  01726	48 8b 84 24 c0
	03 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  0172e	8b 80 14 13 00
	00		 mov	 eax, DWORD PTR [rax+4884]
  01734	c1 e8 06	 shr	 eax, 6
  01737	83 e0 01	 and	 eax, 1
  0173a	85 c0		 test	 eax, eax
  0173c	0f 85 8f 00 00
	00		 jne	 $LN122@ckd_dasd_e
  01742	48 8b 84 24 c0
	03 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  0174a	8b 80 14 13 00
	00		 mov	 eax, DWORD PTR [rax+4884]
  01750	c1 e8 07	 shr	 eax, 7
  01753	83 e0 01	 and	 eax, 1
  01756	85 c0		 test	 eax, eax
  01758	75 77		 jne	 SHORT $LN122@ckd_dasd_e
  0175a	48 8b 84 24 c0
	03 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  01762	8b 80 14 13 00
	00		 mov	 eax, DWORD PTR [rax+4884]
  01768	c1 e8 03	 shr	 eax, 3
  0176b	83 e0 01	 and	 eax, 1
  0176e	85 c0		 test	 eax, eax
  01770	75 5f		 jne	 SHORT $LN122@ckd_dasd_e
  01772	48 8b 84 24 c0
	03 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  0177a	8b 80 14 13 00
	00		 mov	 eax, DWORD PTR [rax+4884]
  01780	c1 e8 09	 shr	 eax, 9
  01783	83 e0 01	 and	 eax, 1
  01786	85 c0		 test	 eax, eax
  01788	75 47		 jne	 SHORT $LN122@ckd_dasd_e
  0178a	48 8b 84 24 c0
	03 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  01792	8b 80 14 13 00
	00		 mov	 eax, DWORD PTR [rax+4884]
  01798	c1 e8 08	 shr	 eax, 8
  0179b	83 e0 01	 and	 eax, 1
  0179e	85 c0		 test	 eax, eax
  017a0	75 2f		 jne	 SHORT $LN122@ckd_dasd_e

; 2679 :         {
; 2680 :             ckd_build_sense (dev, SENSE_CR, 0, 0,

  017a2	c6 44 24 28 02	 mov	 BYTE PTR [rsp+40], 2
  017a7	c6 44 24 20 00	 mov	 BYTE PTR [rsp+32], 0
  017ac	45 33 c9	 xor	 r9d, r9d
  017af	45 33 c0	 xor	 r8d, r8d
  017b2	b2 80		 mov	 dl, 128			; 00000080H
  017b4	48 8b 8c 24 c0
	03 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  017bc	e8 00 00 00 00	 call	 ckd_build_sense

; 2681 :                             FORMAT_0, MESSAGE_2);
; 2682 :             *unitstat = CSW_CE | CSW_DE | CSW_UC;

  017c1	48 8b 84 24 08
	04 00 00	 mov	 rax, QWORD PTR unitstat$[rsp]
  017c9	c6 00 0e	 mov	 BYTE PTR [rax], 14

; 2683 :             break;

  017cc	e9 7f 8d 00 00	 jmp	 $LN2@ckd_dasd_e
$LN122@ckd_dasd_e:

; 2684 :         }
; 2685 : 
; 2686 :         /* Check operation code if within domain of a Locate Record */
; 2687 :         if (dev->ckdlcount > 0)

  017d1	48 8b 84 24 c0
	03 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  017d9	0f b6 80 02 13
	00 00		 movzx	 eax, BYTE PTR [rax+4866]
  017e0	85 c0		 test	 eax, eax
  017e2	0f 8e 91 00 00
	00		 jle	 $LN123@ckd_dasd_e

; 2688 :         {
; 2689 :             if (!((dev->ckdloper & CKDOPER_CODE) == CKDOPER_RDDATA

  017e8	48 8b 84 24 c0
	03 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  017f0	0f b6 80 00 13
	00 00		 movzx	 eax, BYTE PTR [rax+4864]
  017f7	83 e0 3f	 and	 eax, 63			; 0000003fH
  017fa	83 f8 06	 cmp	 eax, 6
  017fd	74 7a		 je	 SHORT $LN124@ckd_dasd_e
  017ff	48 8b 84 24 c0
	03 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  01807	0f b6 80 00 13
	00 00		 movzx	 eax, BYTE PTR [rax+4864]
  0180e	83 e0 3f	 and	 eax, 63			; 0000003fH
  01811	83 f8 16	 cmp	 eax, 22
  01814	75 34		 jne	 SHORT $LN125@ckd_dasd_e
  01816	48 8b 84 24 c0
	03 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  0181e	0f b6 80 00 13
	00 00		 movzx	 eax, BYTE PTR [rax+4864]
  01825	25 c0 00 00 00	 and	 eax, 192		; 000000c0H
  0182a	83 f8 40	 cmp	 eax, 64			; 00000040H
  0182d	74 4a		 je	 SHORT $LN124@ckd_dasd_e
  0182f	48 8b 84 24 c0
	03 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  01837	0f b6 80 00 13
	00 00		 movzx	 eax, BYTE PTR [rax+4864]
  0183e	25 c0 00 00 00	 and	 eax, 192		; 000000c0H
  01843	3d c0 00 00 00	 cmp	 eax, 192		; 000000c0H
  01848	74 2f		 je	 SHORT $LN124@ckd_dasd_e
$LN125@ckd_dasd_e:

; 2690 :                   || ((dev->ckdloper & CKDOPER_CODE) == CKDOPER_READ
; 2691 :                       && ((dev->ckdloper & CKDOPER_ORIENTATION)
; 2692 :                                 == CKDOPER_ORIENT_HOME
; 2693 :                           || (dev->ckdloper & CKDOPER_ORIENTATION)
; 2694 :                                 == CKDOPER_ORIENT_INDEX
; 2695 :                         ))))
; 2696 :             {
; 2697 :                 ckd_build_sense (dev, SENSE_CR, 0, 0,

  0184a	c6 44 24 28 02	 mov	 BYTE PTR [rsp+40], 2
  0184f	c6 44 24 20 00	 mov	 BYTE PTR [rsp+32], 0
  01854	45 33 c9	 xor	 r9d, r9d
  01857	45 33 c0	 xor	 r8d, r8d
  0185a	b2 80		 mov	 dl, 128			; 00000080H
  0185c	48 8b 8c 24 c0
	03 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  01864	e8 00 00 00 00	 call	 ckd_build_sense

; 2698 :                                 FORMAT_0, MESSAGE_2);
; 2699 :                 *unitstat = CSW_CE | CSW_DE | CSW_UC;

  01869	48 8b 84 24 08
	04 00 00	 mov	 rax, QWORD PTR unitstat$[rsp]
  01871	c6 00 0e	 mov	 BYTE PTR [rax], 14

; 2700 :                 break;

  01874	e9 d7 8c 00 00	 jmp	 $LN2@ckd_dasd_e
$LN124@ckd_dasd_e:
$LN123@ckd_dasd_e:

; 2701 :             }
; 2702 :         }
; 2703 : 
; 2704 :         /* For multitrack operation outside domain of a Locate Record,
; 2705 :            attempt to advance to the next track before reading R0 */
; 2706 :         if ((code & 0x80) && dev->ckdlcount == 0)

  01879	0f b6 84 24 c8
	03 00 00	 movzx	 eax, BYTE PTR code$[rsp]
  01881	25 80 00 00 00	 and	 eax, 128		; 00000080H
  01886	85 c0		 test	 eax, eax
  01888	74 3e		 je	 SHORT $LN126@ckd_dasd_e
  0188a	48 8b 84 24 c0
	03 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  01892	0f b6 80 02 13
	00 00		 movzx	 eax, BYTE PTR [rax+4866]
  01899	85 c0		 test	 eax, eax
  0189b	75 2b		 jne	 SHORT $LN126@ckd_dasd_e

; 2707 :         {
; 2708 :             rc = mt_advance (dev, unitstat, 1);

  0189d	41 b8 01 00 00
	00		 mov	 r8d, 1
  018a3	48 8b 94 24 08
	04 00 00	 mov	 rdx, QWORD PTR unitstat$[rsp]
  018ab	48 8b 8c 24 c0
	03 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  018b3	e8 00 00 00 00	 call	 mt_advance
  018b8	89 44 24 60	 mov	 DWORD PTR rc$[rsp], eax

; 2709 :             if (rc < 0) break;

  018bc	83 7c 24 60 00	 cmp	 DWORD PTR rc$[rsp], 0
  018c1	7d 05		 jge	 SHORT $LN127@ckd_dasd_e
  018c3	e9 88 8c 00 00	 jmp	 $LN2@ckd_dasd_e
$LN127@ckd_dasd_e:
$LN126@ckd_dasd_e:

; 2710 :         }
; 2711 : 
; 2712 :         /* Seek to beginning of track */
; 2713 :         rc = ckd_seek (dev, dev->ckdcurcyl, dev->ckdcurhead, &trkhdr, unitstat);

  018c8	48 8b 84 24 08
	04 00 00	 mov	 rax, QWORD PTR unitstat$[rsp]
  018d0	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  018d5	4c 8d 8c 24 40
	02 00 00	 lea	 r9, QWORD PTR trkhdr$[rsp]
  018dd	48 8b 84 24 c0
	03 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  018e5	44 8b 80 cc 12
	00 00		 mov	 r8d, DWORD PTR [rax+4812]
  018ec	48 8b 84 24 c0
	03 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  018f4	8b 90 c8 12 00
	00		 mov	 edx, DWORD PTR [rax+4808]
  018fa	48 8b 8c 24 c0
	03 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  01902	e8 00 00 00 00	 call	 ckd_seek
  01907	89 44 24 60	 mov	 DWORD PTR rc$[rsp], eax

; 2714 :         if (rc < 0) break;

  0190b	83 7c 24 60 00	 cmp	 DWORD PTR rc$[rsp], 0
  01910	7d 05		 jge	 SHORT $LN128@ckd_dasd_e
  01912	e9 39 8c 00 00	 jmp	 $LN2@ckd_dasd_e
$LN128@ckd_dasd_e:

; 2715 : 
; 2716 :         /* Read the count field for record zero */
; 2717 :         rc = ckd_read_count (dev, code, &rechdr, unitstat);

  01917	4c 8b 8c 24 08
	04 00 00	 mov	 r9, QWORD PTR unitstat$[rsp]
  0191f	4c 8d 84 24 38
	02 00 00	 lea	 r8, QWORD PTR rechdr$[rsp]
  01927	0f b6 94 24 c8
	03 00 00	 movzx	 edx, BYTE PTR code$[rsp]
  0192f	48 8b 8c 24 c0
	03 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  01937	e8 00 00 00 00	 call	 ckd_read_count
  0193c	89 44 24 60	 mov	 DWORD PTR rc$[rsp], eax

; 2718 :         if (rc < 0) break;

  01940	83 7c 24 60 00	 cmp	 DWORD PTR rc$[rsp], 0
  01945	7d 05		 jge	 SHORT $LN129@ckd_dasd_e
  01947	e9 04 8c 00 00	 jmp	 $LN2@ckd_dasd_e
$LN129@ckd_dasd_e:

; 2719 : 
; 2720 :         /* Calculate number of bytes to read and set residual count */
; 2721 :         size = CKD_RECHDR_SIZE + dev->ckdcurkl + dev->ckdcurdl;

  0194c	48 8b 84 24 c0
	03 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  01954	48 63 80 d4 12
	00 00		 movsxd	 rax, DWORD PTR [rax+4820]
  0195b	48 8b 8c 24 c0
	03 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  01963	0f b7 89 ea 12
	00 00		 movzx	 ecx, WORD PTR [rcx+4842]
  0196a	48 8d 44 08 08	 lea	 rax, QWORD PTR [rax+rcx+8]
  0196f	89 44 24 68	 mov	 DWORD PTR size$[rsp], eax

; 2722 :         num = (count < size) ? count : size;

  01973	8b 44 24 68	 mov	 eax, DWORD PTR size$[rsp]
  01977	39 84 24 e0 03
	00 00		 cmp	 DWORD PTR count$[rsp], eax
  0197e	73 10		 jae	 SHORT $LN657@ckd_dasd_e
  01980	8b 84 24 e0 03
	00 00		 mov	 eax, DWORD PTR count$[rsp]
  01987	89 84 24 ec 00
	00 00		 mov	 DWORD PTR tv814[rsp], eax
  0198e	eb 0b		 jmp	 SHORT $LN658@ckd_dasd_e
$LN657@ckd_dasd_e:
  01990	8b 44 24 68	 mov	 eax, DWORD PTR size$[rsp]
  01994	89 84 24 ec 00
	00 00		 mov	 DWORD PTR tv814[rsp], eax
$LN658@ckd_dasd_e:
  0199b	8b 84 24 ec 00
	00 00		 mov	 eax, DWORD PTR tv814[rsp]
  019a2	89 44 24 64	 mov	 DWORD PTR num$[rsp], eax

; 2723 :         *residual = count - num;

  019a6	8b 44 24 64	 mov	 eax, DWORD PTR num$[rsp]
  019aa	8b 8c 24 e0 03
	00 00		 mov	 ecx, DWORD PTR count$[rsp]
  019b1	2b c8		 sub	 ecx, eax
  019b3	8b c1		 mov	 eax, ecx
  019b5	48 8b 8c 24 10
	04 00 00	 mov	 rcx, QWORD PTR residual$[rsp]
  019bd	89 01		 mov	 DWORD PTR [rcx], eax

; 2724 :         if (count < size) *more = 1;

  019bf	8b 44 24 68	 mov	 eax, DWORD PTR size$[rsp]
  019c3	39 84 24 e0 03
	00 00		 cmp	 DWORD PTR count$[rsp], eax
  019ca	73 0b		 jae	 SHORT $LN130@ckd_dasd_e
  019cc	48 8b 84 24 00
	04 00 00	 mov	 rax, QWORD PTR more$[rsp]
  019d4	c6 00 01	 mov	 BYTE PTR [rax], 1
$LN130@ckd_dasd_e:

; 2725 : 
; 2726 :         /* Copy count field to I/O buffer */
; 2727 :         memcpy (iobuf, &rechdr, CKD_RECHDR_SIZE);

  019d7	48 8b 84 24 f8
	03 00 00	 mov	 rax, QWORD PTR iobuf$[rsp]
  019df	48 8b 8c 24 38
	02 00 00	 mov	 rcx, QWORD PTR rechdr$[rsp]
  019e7	48 89 08	 mov	 QWORD PTR [rax], rcx

; 2728 : 
; 2729 :         /* Turn off track overflow flag in read record header */
; 2730 :         if(dev->ckdcyls < 32768)

  019ea	48 8b 84 24 c0
	03 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  019f2	81 b8 b8 12 00
	00 00 80 00 00	 cmp	 DWORD PTR [rax+4792], 32768 ; 00008000H
  019fc	7d 18		 jge	 SHORT $LN131@ckd_dasd_e

; 2731 :             *iobuf &= 0x7F;

  019fe	48 8b 84 24 f8
	03 00 00	 mov	 rax, QWORD PTR iobuf$[rsp]
  01a06	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  01a09	83 e0 7f	 and	 eax, 127		; 0000007fH
  01a0c	48 8b 8c 24 f8
	03 00 00	 mov	 rcx, QWORD PTR iobuf$[rsp]
  01a14	88 01		 mov	 BYTE PTR [rcx], al
$LN131@ckd_dasd_e:

; 2732 : 
; 2733 :         /* Read key field */
; 2734 :         rc = ckd_read_key (dev, code,

  01a16	48 8b 84 24 f8
	03 00 00	 mov	 rax, QWORD PTR iobuf$[rsp]
  01a1e	48 83 c0 08	 add	 rax, 8
  01a22	4c 8b 8c 24 08
	04 00 00	 mov	 r9, QWORD PTR unitstat$[rsp]
  01a2a	4c 8b c0	 mov	 r8, rax
  01a2d	0f b6 94 24 c8
	03 00 00	 movzx	 edx, BYTE PTR code$[rsp]
  01a35	48 8b 8c 24 c0
	03 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  01a3d	e8 00 00 00 00	 call	 ckd_read_key
  01a42	89 44 24 60	 mov	 DWORD PTR rc$[rsp], eax

; 2735 :                             iobuf + CKD_RECHDR_SIZE, unitstat);
; 2736 :         if (rc < 0) break;

  01a46	83 7c 24 60 00	 cmp	 DWORD PTR rc$[rsp], 0
  01a4b	7d 05		 jge	 SHORT $LN132@ckd_dasd_e
  01a4d	e9 fe 8a 00 00	 jmp	 $LN2@ckd_dasd_e
$LN132@ckd_dasd_e:

; 2737 : 
; 2738 :         /* Read data field */
; 2739 :         rc = ckd_read_data (dev, code,

  01a52	48 8b 84 24 c0
	03 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  01a5a	48 63 80 d4 12
	00 00		 movsxd	 rax, DWORD PTR [rax+4820]
  01a61	48 8b 8c 24 f8
	03 00 00	 mov	 rcx, QWORD PTR iobuf$[rsp]
  01a69	48 8d 44 01 08	 lea	 rax, QWORD PTR [rcx+rax+8]
  01a6e	4c 8b 8c 24 08
	04 00 00	 mov	 r9, QWORD PTR unitstat$[rsp]
  01a76	4c 8b c0	 mov	 r8, rax
  01a79	0f b6 94 24 c8
	03 00 00	 movzx	 edx, BYTE PTR code$[rsp]
  01a81	48 8b 8c 24 c0
	03 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  01a89	e8 00 00 00 00	 call	 ckd_read_data
  01a8e	89 44 24 60	 mov	 DWORD PTR rc$[rsp], eax

; 2740 :                             iobuf + CKD_RECHDR_SIZE + dev->ckdcurkl,
; 2741 :                             unitstat);
; 2742 :         if (rc < 0) break;

  01a92	83 7c 24 60 00	 cmp	 DWORD PTR rc$[rsp], 0
  01a97	7d 05		 jge	 SHORT $LN133@ckd_dasd_e
  01a99	e9 b2 8a 00 00	 jmp	 $LN2@ckd_dasd_e
$LN133@ckd_dasd_e:

; 2743 : 
; 2744 :         /* Save size and offset of data not used by this CCW */
; 2745 :         dev->ckdrem = (U16)(size - num);

  01a9e	8b 44 24 64	 mov	 eax, DWORD PTR num$[rsp]
  01aa2	8b 4c 24 68	 mov	 ecx, DWORD PTR size$[rsp]
  01aa6	2b c8		 sub	 ecx, eax
  01aa8	8b c1		 mov	 eax, ecx
  01aaa	48 8b 8c 24 c0
	03 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  01ab2	66 89 81 ec 12
	00 00		 mov	 WORD PTR [rcx+4844], ax

; 2746 :         dev->ckdpos = (U16)(       num);

  01ab9	48 8b 84 24 c0
	03 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  01ac1	0f b7 4c 24 64	 movzx	 ecx, WORD PTR num$[rsp]
  01ac6	66 89 88 ee 12
	00 00		 mov	 WORD PTR [rax+4846], cx

; 2747 : 
; 2748 :         /* Return unit exception if data length is zero */
; 2749 :         if (dev->ckdcurdl == 0)

  01acd	48 8b 84 24 c0
	03 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  01ad5	0f b7 80 ea 12
	00 00		 movzx	 eax, WORD PTR [rax+4842]
  01adc	85 c0		 test	 eax, eax
  01ade	75 0d		 jne	 SHORT $LN134@ckd_dasd_e

; 2750 :             *unitstat = CSW_CE | CSW_DE | CSW_UX;

  01ae0	48 8b 84 24 08
	04 00 00	 mov	 rax, QWORD PTR unitstat$[rsp]
  01ae8	c6 00 0d	 mov	 BYTE PTR [rax], 13
  01aeb	eb 0b		 jmp	 SHORT $LN135@ckd_dasd_e
$LN134@ckd_dasd_e:

; 2751 :         else
; 2752 :             *unitstat = CSW_CE | CSW_DE;

  01aed	48 8b 84 24 08
	04 00 00	 mov	 rax, QWORD PTR unitstat$[rsp]
  01af5	c6 00 0c	 mov	 BYTE PTR [rax], 12
$LN135@ckd_dasd_e:

; 2753 : 
; 2754 :         break;

  01af8	e9 53 8a 00 00	 jmp	 $LN2@ckd_dasd_e
$LN136@ckd_dasd_e:
$LN137@ckd_dasd_e:

; 2755 : 
; 2756 :     case 0x1A:
; 2757 :     case 0x9A:
; 2758 :     /*---------------------------------------------------------------*/
; 2759 :     /* READ HOME ADDRESS                                             */
; 2760 :     /*---------------------------------------------------------------*/
; 2761 :         /* For 3990, command reject if not preceded by Seek, Seek Cyl,
; 2762 :            Locate Record, Read IPL, or Recalibrate command */
; 2763 :         if (dev->ckd3990
; 2764 :             && dev->ckdseek == 0 && dev->ckdskcyl == 0
; 2765 :             && dev->ckdlocat == 0 && dev->ckdrdipl == 0
; 2766 :             && dev->ckdrecal == 0)

  01afd	48 8b 84 24 c0
	03 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  01b05	8b 80 14 13 00
	00		 mov	 eax, DWORD PTR [rax+4884]
  01b0b	83 e0 01	 and	 eax, 1
  01b0e	85 c0		 test	 eax, eax
  01b10	0f 84 ab 00 00
	00		 je	 $LN138@ckd_dasd_e
  01b16	48 8b 84 24 c0
	03 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  01b1e	8b 80 14 13 00
	00		 mov	 eax, DWORD PTR [rax+4884]
  01b24	c1 e8 06	 shr	 eax, 6
  01b27	83 e0 01	 and	 eax, 1
  01b2a	85 c0		 test	 eax, eax
  01b2c	0f 85 8f 00 00
	00		 jne	 $LN138@ckd_dasd_e
  01b32	48 8b 84 24 c0
	03 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  01b3a	8b 80 14 13 00
	00		 mov	 eax, DWORD PTR [rax+4884]
  01b40	c1 e8 07	 shr	 eax, 7
  01b43	83 e0 01	 and	 eax, 1
  01b46	85 c0		 test	 eax, eax
  01b48	75 77		 jne	 SHORT $LN138@ckd_dasd_e
  01b4a	48 8b 84 24 c0
	03 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  01b52	8b 80 14 13 00
	00		 mov	 eax, DWORD PTR [rax+4884]
  01b58	c1 e8 03	 shr	 eax, 3
  01b5b	83 e0 01	 and	 eax, 1
  01b5e	85 c0		 test	 eax, eax
  01b60	75 5f		 jne	 SHORT $LN138@ckd_dasd_e
  01b62	48 8b 84 24 c0
	03 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  01b6a	8b 80 14 13 00
	00		 mov	 eax, DWORD PTR [rax+4884]
  01b70	c1 e8 09	 shr	 eax, 9
  01b73	83 e0 01	 and	 eax, 1
  01b76	85 c0		 test	 eax, eax
  01b78	75 47		 jne	 SHORT $LN138@ckd_dasd_e
  01b7a	48 8b 84 24 c0
	03 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  01b82	8b 80 14 13 00
	00		 mov	 eax, DWORD PTR [rax+4884]
  01b88	c1 e8 08	 shr	 eax, 8
  01b8b	83 e0 01	 and	 eax, 1
  01b8e	85 c0		 test	 eax, eax
  01b90	75 2f		 jne	 SHORT $LN138@ckd_dasd_e

; 2767 :         {
; 2768 :             ckd_build_sense (dev, SENSE_CR, 0, 0,

  01b92	c6 44 24 28 02	 mov	 BYTE PTR [rsp+40], 2
  01b97	c6 44 24 20 00	 mov	 BYTE PTR [rsp+32], 0
  01b9c	45 33 c9	 xor	 r9d, r9d
  01b9f	45 33 c0	 xor	 r8d, r8d
  01ba2	b2 80		 mov	 dl, 128			; 00000080H
  01ba4	48 8b 8c 24 c0
	03 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  01bac	e8 00 00 00 00	 call	 ckd_build_sense

; 2769 :                             FORMAT_0, MESSAGE_2);
; 2770 :             *unitstat = CSW_CE | CSW_DE | CSW_UC;

  01bb1	48 8b 84 24 08
	04 00 00	 mov	 rax, QWORD PTR unitstat$[rsp]
  01bb9	c6 00 0e	 mov	 BYTE PTR [rax], 14

; 2771 :             break;

  01bbc	e9 8f 89 00 00	 jmp	 $LN2@ckd_dasd_e
$LN138@ckd_dasd_e:

; 2772 :         }
; 2773 : 
; 2774 :         /* Check operation code if within domain of a Locate Record */
; 2775 :         if (dev->ckdlcount > 0)

  01bc1	48 8b 84 24 c0
	03 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  01bc9	0f b6 80 02 13
	00 00		 movzx	 eax, BYTE PTR [rax+4866]
  01bd0	85 c0		 test	 eax, eax
  01bd2	7e 78		 jle	 SHORT $LN139@ckd_dasd_e

; 2776 :         {
; 2777 :             if (!((dev->ckdloper & CKDOPER_CODE) == CKDOPER_RDDATA

  01bd4	48 8b 84 24 c0
	03 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  01bdc	0f b6 80 00 13
	00 00		 movzx	 eax, BYTE PTR [rax+4864]
  01be3	83 e0 3f	 and	 eax, 63			; 0000003fH
  01be6	83 f8 06	 cmp	 eax, 6
  01be9	74 61		 je	 SHORT $LN140@ckd_dasd_e
  01beb	48 8b 84 24 c0
	03 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  01bf3	0f b6 80 00 13
	00 00		 movzx	 eax, BYTE PTR [rax+4864]
  01bfa	83 e0 3f	 and	 eax, 63			; 0000003fH
  01bfd	83 f8 16	 cmp	 eax, 22
  01c00	75 1b		 jne	 SHORT $LN141@ckd_dasd_e
  01c02	48 8b 84 24 c0
	03 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  01c0a	0f b6 80 00 13
	00 00		 movzx	 eax, BYTE PTR [rax+4864]
  01c11	25 c0 00 00 00	 and	 eax, 192		; 000000c0H
  01c16	3d c0 00 00 00	 cmp	 eax, 192		; 000000c0H
  01c1b	74 2f		 je	 SHORT $LN140@ckd_dasd_e
$LN141@ckd_dasd_e:

; 2778 :                   || ((dev->ckdloper & CKDOPER_CODE) == CKDOPER_READ
; 2779 :                       && (dev->ckdloper & CKDOPER_ORIENTATION)
; 2780 :                                 == CKDOPER_ORIENT_INDEX
; 2781 :                     )))
; 2782 :             {
; 2783 :                 ckd_build_sense (dev, SENSE_CR, 0, 0,

  01c1d	c6 44 24 28 02	 mov	 BYTE PTR [rsp+40], 2
  01c22	c6 44 24 20 00	 mov	 BYTE PTR [rsp+32], 0
  01c27	45 33 c9	 xor	 r9d, r9d
  01c2a	45 33 c0	 xor	 r8d, r8d
  01c2d	b2 80		 mov	 dl, 128			; 00000080H
  01c2f	48 8b 8c 24 c0
	03 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  01c37	e8 00 00 00 00	 call	 ckd_build_sense

; 2784 :                                 FORMAT_0, MESSAGE_2);
; 2785 :                 *unitstat = CSW_CE | CSW_DE | CSW_UC;

  01c3c	48 8b 84 24 08
	04 00 00	 mov	 rax, QWORD PTR unitstat$[rsp]
  01c44	c6 00 0e	 mov	 BYTE PTR [rax], 14

; 2786 :                 break;

  01c47	e9 04 89 00 00	 jmp	 $LN2@ckd_dasd_e
$LN140@ckd_dasd_e:
$LN139@ckd_dasd_e:

; 2787 :             }
; 2788 :         }
; 2789 : 
; 2790 :         /* For multitrack operation outside domain of a Locate Record,
; 2791 :            attempt to advance to the next track before reading HA */
; 2792 :         if ((code & 0x80) && dev->ckdlcount == 0)

  01c4c	0f b6 84 24 c8
	03 00 00	 movzx	 eax, BYTE PTR code$[rsp]
  01c54	25 80 00 00 00	 and	 eax, 128		; 00000080H
  01c59	85 c0		 test	 eax, eax
  01c5b	74 3e		 je	 SHORT $LN142@ckd_dasd_e
  01c5d	48 8b 84 24 c0
	03 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  01c65	0f b6 80 02 13
	00 00		 movzx	 eax, BYTE PTR [rax+4866]
  01c6c	85 c0		 test	 eax, eax
  01c6e	75 2b		 jne	 SHORT $LN142@ckd_dasd_e

; 2793 :         {
; 2794 :             rc = mt_advance (dev, unitstat, 1);

  01c70	41 b8 01 00 00
	00		 mov	 r8d, 1
  01c76	48 8b 94 24 08
	04 00 00	 mov	 rdx, QWORD PTR unitstat$[rsp]
  01c7e	48 8b 8c 24 c0
	03 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  01c86	e8 00 00 00 00	 call	 mt_advance
  01c8b	89 44 24 60	 mov	 DWORD PTR rc$[rsp], eax

; 2795 :             if (rc < 0) break;

  01c8f	83 7c 24 60 00	 cmp	 DWORD PTR rc$[rsp], 0
  01c94	7d 05		 jge	 SHORT $LN143@ckd_dasd_e
  01c96	e9 b5 88 00 00	 jmp	 $LN2@ckd_dasd_e
$LN143@ckd_dasd_e:
$LN142@ckd_dasd_e:

; 2796 :         }
; 2797 : 
; 2798 :         /* Seek to beginning of track */
; 2799 :         rc = ckd_seek (dev, dev->ckdcurcyl, dev->ckdcurhead, &trkhdr, unitstat);

  01c9b	48 8b 84 24 08
	04 00 00	 mov	 rax, QWORD PTR unitstat$[rsp]
  01ca3	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  01ca8	4c 8d 8c 24 40
	02 00 00	 lea	 r9, QWORD PTR trkhdr$[rsp]
  01cb0	48 8b 84 24 c0
	03 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  01cb8	44 8b 80 cc 12
	00 00		 mov	 r8d, DWORD PTR [rax+4812]
  01cbf	48 8b 84 24 c0
	03 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  01cc7	8b 90 c8 12 00
	00		 mov	 edx, DWORD PTR [rax+4808]
  01ccd	48 8b 8c 24 c0
	03 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  01cd5	e8 00 00 00 00	 call	 ckd_seek
  01cda	89 44 24 60	 mov	 DWORD PTR rc$[rsp], eax

; 2800 :         if (rc < 0) break;

  01cde	83 7c 24 60 00	 cmp	 DWORD PTR rc$[rsp], 0
  01ce3	7d 05		 jge	 SHORT $LN144@ckd_dasd_e
  01ce5	e9 66 88 00 00	 jmp	 $LN2@ckd_dasd_e
$LN144@ckd_dasd_e:

; 2801 : 
; 2802 :         /* Calculate number of bytes to read and set residual count */
; 2803 :         size = CKD_TRKHDR_SIZE;

  01cea	c7 44 24 68 05
	00 00 00	 mov	 DWORD PTR size$[rsp], 5

; 2804 :         num = (count < size) ? count : size;

  01cf2	8b 44 24 68	 mov	 eax, DWORD PTR size$[rsp]
  01cf6	39 84 24 e0 03
	00 00		 cmp	 DWORD PTR count$[rsp], eax
  01cfd	73 10		 jae	 SHORT $LN659@ckd_dasd_e
  01cff	8b 84 24 e0 03
	00 00		 mov	 eax, DWORD PTR count$[rsp]
  01d06	89 84 24 f0 00
	00 00		 mov	 DWORD PTR tv924[rsp], eax
  01d0d	eb 0b		 jmp	 SHORT $LN660@ckd_dasd_e
$LN659@ckd_dasd_e:
  01d0f	8b 44 24 68	 mov	 eax, DWORD PTR size$[rsp]
  01d13	89 84 24 f0 00
	00 00		 mov	 DWORD PTR tv924[rsp], eax
$LN660@ckd_dasd_e:
  01d1a	8b 84 24 f0 00
	00 00		 mov	 eax, DWORD PTR tv924[rsp]
  01d21	89 44 24 64	 mov	 DWORD PTR num$[rsp], eax

; 2805 :         *residual = count - num;

  01d25	8b 44 24 64	 mov	 eax, DWORD PTR num$[rsp]
  01d29	8b 8c 24 e0 03
	00 00		 mov	 ecx, DWORD PTR count$[rsp]
  01d30	2b c8		 sub	 ecx, eax
  01d32	8b c1		 mov	 eax, ecx
  01d34	48 8b 8c 24 10
	04 00 00	 mov	 rcx, QWORD PTR residual$[rsp]
  01d3c	89 01		 mov	 DWORD PTR [rcx], eax

; 2806 :         if (count < size) *more = 1;

  01d3e	8b 44 24 68	 mov	 eax, DWORD PTR size$[rsp]
  01d42	39 84 24 e0 03
	00 00		 cmp	 DWORD PTR count$[rsp], eax
  01d49	73 0b		 jae	 SHORT $LN145@ckd_dasd_e
  01d4b	48 8b 84 24 00
	04 00 00	 mov	 rax, QWORD PTR more$[rsp]
  01d53	c6 00 01	 mov	 BYTE PTR [rax], 1
$LN145@ckd_dasd_e:

; 2807 : 
; 2808 :         /* Copy home address field to I/O buffer */
; 2809 :         memcpy (iobuf, &trkhdr, CKD_TRKHDR_SIZE);

  01d56	48 8d 84 24 40
	02 00 00	 lea	 rax, QWORD PTR trkhdr$[rsp]
  01d5e	48 8b bc 24 f8
	03 00 00	 mov	 rdi, QWORD PTR iobuf$[rsp]
  01d66	48 8b f0	 mov	 rsi, rax
  01d69	b9 05 00 00 00	 mov	 ecx, 5
  01d6e	f3 a4		 rep movsb

; 2810 : 
; 2811 :         /* Save size and offset of data not used by this CCW */
; 2812 :         dev->ckdrem = (U16)(size - num);

  01d70	8b 44 24 64	 mov	 eax, DWORD PTR num$[rsp]
  01d74	8b 4c 24 68	 mov	 ecx, DWORD PTR size$[rsp]
  01d78	2b c8		 sub	 ecx, eax
  01d7a	8b c1		 mov	 eax, ecx
  01d7c	48 8b 8c 24 c0
	03 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  01d84	66 89 81 ec 12
	00 00		 mov	 WORD PTR [rcx+4844], ax

; 2813 :         dev->ckdpos = (U16)(       num);

  01d8b	48 8b 84 24 c0
	03 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  01d93	0f b7 4c 24 64	 movzx	 ecx, WORD PTR num$[rsp]
  01d98	66 89 88 ee 12
	00 00		 mov	 WORD PTR [rax+4846], cx

; 2814 : 
; 2815 :         /* Return normal status */
; 2816 :         *unitstat = CSW_CE | CSW_DE;

  01d9f	48 8b 84 24 08
	04 00 00	 mov	 rax, QWORD PTR unitstat$[rsp]
  01da7	c6 00 0c	 mov	 BYTE PTR [rax], 12

; 2817 : 
; 2818 :         break;

  01daa	e9 a1 87 00 00	 jmp	 $LN2@ckd_dasd_e
$LN146@ckd_dasd_e:

; 2819 : 
; 2820 :     case 0x19:
; 2821 :     /*---------------------------------------------------------------*/
; 2822 :     /* WRITE HOME ADDRESS                                            */
; 2823 :     /*---------------------------------------------------------------*/
; 2824 :         /* For 3990, command reject if not preceded by Seek, Seek Cyl,
; 2825 :            Locate Record, Read IPL, or Recalibrate command */
; 2826 :         if (dev->ckd3990
; 2827 :             && dev->ckdseek == 0 && dev->ckdskcyl == 0
; 2828 :             && dev->ckdlocat == 0 && dev->ckdrdipl == 0
; 2829 :             && dev->ckdrecal == 0)

  01daf	48 8b 84 24 c0
	03 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  01db7	8b 80 14 13 00
	00		 mov	 eax, DWORD PTR [rax+4884]
  01dbd	83 e0 01	 and	 eax, 1
  01dc0	85 c0		 test	 eax, eax
  01dc2	0f 84 ab 00 00
	00		 je	 $LN147@ckd_dasd_e
  01dc8	48 8b 84 24 c0
	03 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  01dd0	8b 80 14 13 00
	00		 mov	 eax, DWORD PTR [rax+4884]
  01dd6	c1 e8 06	 shr	 eax, 6
  01dd9	83 e0 01	 and	 eax, 1
  01ddc	85 c0		 test	 eax, eax
  01dde	0f 85 8f 00 00
	00		 jne	 $LN147@ckd_dasd_e
  01de4	48 8b 84 24 c0
	03 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  01dec	8b 80 14 13 00
	00		 mov	 eax, DWORD PTR [rax+4884]
  01df2	c1 e8 07	 shr	 eax, 7
  01df5	83 e0 01	 and	 eax, 1
  01df8	85 c0		 test	 eax, eax
  01dfa	75 77		 jne	 SHORT $LN147@ckd_dasd_e
  01dfc	48 8b 84 24 c0
	03 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  01e04	8b 80 14 13 00
	00		 mov	 eax, DWORD PTR [rax+4884]
  01e0a	c1 e8 03	 shr	 eax, 3
  01e0d	83 e0 01	 and	 eax, 1
  01e10	85 c0		 test	 eax, eax
  01e12	75 5f		 jne	 SHORT $LN147@ckd_dasd_e
  01e14	48 8b 84 24 c0
	03 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  01e1c	8b 80 14 13 00
	00		 mov	 eax, DWORD PTR [rax+4884]
  01e22	c1 e8 09	 shr	 eax, 9
  01e25	83 e0 01	 and	 eax, 1
  01e28	85 c0		 test	 eax, eax
  01e2a	75 47		 jne	 SHORT $LN147@ckd_dasd_e
  01e2c	48 8b 84 24 c0
	03 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  01e34	8b 80 14 13 00
	00		 mov	 eax, DWORD PTR [rax+4884]
  01e3a	c1 e8 08	 shr	 eax, 8
  01e3d	83 e0 01	 and	 eax, 1
  01e40	85 c0		 test	 eax, eax
  01e42	75 2f		 jne	 SHORT $LN147@ckd_dasd_e

; 2830 :         {
; 2831 :             ckd_build_sense (dev, SENSE_CR, 0, 0,

  01e44	c6 44 24 28 02	 mov	 BYTE PTR [rsp+40], 2
  01e49	c6 44 24 20 00	 mov	 BYTE PTR [rsp+32], 0
  01e4e	45 33 c9	 xor	 r9d, r9d
  01e51	45 33 c0	 xor	 r8d, r8d
  01e54	b2 80		 mov	 dl, 128			; 00000080H
  01e56	48 8b 8c 24 c0
	03 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  01e5e	e8 00 00 00 00	 call	 ckd_build_sense

; 2832 :                             FORMAT_0, MESSAGE_2);
; 2833 :             *unitstat = CSW_CE | CSW_DE | CSW_UC;

  01e63	48 8b 84 24 08
	04 00 00	 mov	 rax, QWORD PTR unitstat$[rsp]
  01e6b	c6 00 0e	 mov	 BYTE PTR [rax], 14

; 2834 :             break;

  01e6e	e9 dd 86 00 00	 jmp	 $LN2@ckd_dasd_e
$LN147@ckd_dasd_e:

; 2835 :         }
; 2836 : 
; 2837 :         /* Check operation code if within domain of a Locate Record */
; 2838 :         if (dev->ckdlcount > 0)

  01e73	48 8b 84 24 c0
	03 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  01e7b	0f b6 80 02 13
	00 00		 movzx	 eax, BYTE PTR [rax+4866]
  01e82	85 c0		 test	 eax, eax
  01e84	7e 78		 jle	 SHORT $LN148@ckd_dasd_e

; 2839 :         {
; 2840 :             if (!((dev->ckdloper & CKDOPER_CODE) == CKDOPER_RDDATA

  01e86	48 8b 84 24 c0
	03 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  01e8e	0f b6 80 00 13
	00 00		 movzx	 eax, BYTE PTR [rax+4864]
  01e95	83 e0 3f	 and	 eax, 63			; 0000003fH
  01e98	83 f8 06	 cmp	 eax, 6
  01e9b	74 61		 je	 SHORT $LN149@ckd_dasd_e
  01e9d	48 8b 84 24 c0
	03 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  01ea5	0f b6 80 00 13
	00 00		 movzx	 eax, BYTE PTR [rax+4864]
  01eac	83 e0 3f	 and	 eax, 63			; 0000003fH
  01eaf	83 f8 16	 cmp	 eax, 22
  01eb2	75 1b		 jne	 SHORT $LN150@ckd_dasd_e
  01eb4	48 8b 84 24 c0
	03 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  01ebc	0f b6 80 00 13
	00 00		 movzx	 eax, BYTE PTR [rax+4864]
  01ec3	25 c0 00 00 00	 and	 eax, 192		; 000000c0H
  01ec8	3d c0 00 00 00	 cmp	 eax, 192		; 000000c0H
  01ecd	74 2f		 je	 SHORT $LN149@ckd_dasd_e
$LN150@ckd_dasd_e:

; 2841 :                   || ((dev->ckdloper & CKDOPER_CODE) == CKDOPER_READ
; 2842 :                       && (dev->ckdloper & CKDOPER_ORIENTATION)
; 2843 :                                 == CKDOPER_ORIENT_INDEX
; 2844 :                     )))
; 2845 :             {
; 2846 :                 ckd_build_sense (dev, SENSE_CR, 0, 0,

  01ecf	c6 44 24 28 02	 mov	 BYTE PTR [rsp+40], 2
  01ed4	c6 44 24 20 00	 mov	 BYTE PTR [rsp+32], 0
  01ed9	45 33 c9	 xor	 r9d, r9d
  01edc	45 33 c0	 xor	 r8d, r8d
  01edf	b2 80		 mov	 dl, 128			; 00000080H
  01ee1	48 8b 8c 24 c0
	03 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  01ee9	e8 00 00 00 00	 call	 ckd_build_sense

; 2847 :                                 FORMAT_0, MESSAGE_2);
; 2848 :                 *unitstat = CSW_CE | CSW_DE | CSW_UC;

  01eee	48 8b 84 24 08
	04 00 00	 mov	 rax, QWORD PTR unitstat$[rsp]
  01ef6	c6 00 0e	 mov	 BYTE PTR [rax], 14

; 2849 :                 break;

  01ef9	e9 52 86 00 00	 jmp	 $LN2@ckd_dasd_e
$LN149@ckd_dasd_e:
$LN148@ckd_dasd_e:

; 2850 :             }
; 2851 :         }
; 2852 : 
; 2853 :         /* File protected if file mask does not allow Write HA */
; 2854 :         if ((dev->ckdfmask & CKDMASK_WRCTL) != CKDMASK_WRCTL_ALLWRT)

  01efe	48 8b 84 24 c0
	03 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  01f06	0f b6 80 fa 12
	00 00		 movzx	 eax, BYTE PTR [rax+4858]
  01f0d	25 c0 00 00 00	 and	 eax, 192		; 000000c0H
  01f12	3d c0 00 00 00	 cmp	 eax, 192		; 000000c0H
  01f17	74 2f		 je	 SHORT $LN151@ckd_dasd_e

; 2855 :         {
; 2856 :             ckd_build_sense (dev, 0, SENSE1_FP, 0, 0, 0);

  01f19	c6 44 24 28 00	 mov	 BYTE PTR [rsp+40], 0
  01f1e	c6 44 24 20 00	 mov	 BYTE PTR [rsp+32], 0
  01f23	45 33 c9	 xor	 r9d, r9d
  01f26	41 b0 04	 mov	 r8b, 4
  01f29	33 d2		 xor	 edx, edx
  01f2b	48 8b 8c 24 c0
	03 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  01f33	e8 00 00 00 00	 call	 ckd_build_sense

; 2857 :             *unitstat = CSW_CE | CSW_DE | CSW_UC;

  01f38	48 8b 84 24 08
	04 00 00	 mov	 rax, QWORD PTR unitstat$[rsp]
  01f40	c6 00 0e	 mov	 BYTE PTR [rax], 14

; 2858 :             break;

  01f43	e9 08 86 00 00	 jmp	 $LN2@ckd_dasd_e
$LN151@ckd_dasd_e:

; 2859 :         }
; 2860 : 
; 2861 :         /* Seek to beginning of track */
; 2862 :         rc = ckd_seek (dev, dev->ckdcurcyl, dev->ckdcurhead, &trkhdr, unitstat);

  01f48	48 8b 84 24 08
	04 00 00	 mov	 rax, QWORD PTR unitstat$[rsp]
  01f50	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  01f55	4c 8d 8c 24 40
	02 00 00	 lea	 r9, QWORD PTR trkhdr$[rsp]
  01f5d	48 8b 84 24 c0
	03 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  01f65	44 8b 80 cc 12
	00 00		 mov	 r8d, DWORD PTR [rax+4812]
  01f6c	48 8b 84 24 c0
	03 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  01f74	8b 90 c8 12 00
	00		 mov	 edx, DWORD PTR [rax+4808]
  01f7a	48 8b 8c 24 c0
	03 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  01f82	e8 00 00 00 00	 call	 ckd_seek
  01f87	89 44 24 60	 mov	 DWORD PTR rc$[rsp], eax

; 2863 :         if (rc < 0) break;

  01f8b	83 7c 24 60 00	 cmp	 DWORD PTR rc$[rsp], 0
  01f90	7d 05		 jge	 SHORT $LN152@ckd_dasd_e
  01f92	e9 b9 85 00 00	 jmp	 $LN2@ckd_dasd_e
$LN152@ckd_dasd_e:

; 2864 : 
; 2865 :         /* Calculate number of bytes to write and set residual count */
; 2866 :         size = CKD_TRKHDR_SIZE;

  01f97	c7 44 24 68 05
	00 00 00	 mov	 DWORD PTR size$[rsp], 5

; 2867 :         num = (count < size) ? count : size;

  01f9f	8b 44 24 68	 mov	 eax, DWORD PTR size$[rsp]
  01fa3	39 84 24 e0 03
	00 00		 cmp	 DWORD PTR count$[rsp], eax
  01faa	73 10		 jae	 SHORT $LN661@ckd_dasd_e
  01fac	8b 84 24 e0 03
	00 00		 mov	 eax, DWORD PTR count$[rsp]
  01fb3	89 84 24 f4 00
	00 00		 mov	 DWORD PTR tv1008[rsp], eax
  01fba	eb 0b		 jmp	 SHORT $LN662@ckd_dasd_e
$LN661@ckd_dasd_e:
  01fbc	8b 44 24 68	 mov	 eax, DWORD PTR size$[rsp]
  01fc0	89 84 24 f4 00
	00 00		 mov	 DWORD PTR tv1008[rsp], eax
$LN662@ckd_dasd_e:
  01fc7	8b 84 24 f4 00
	00 00		 mov	 eax, DWORD PTR tv1008[rsp]
  01fce	89 44 24 64	 mov	 DWORD PTR num$[rsp], eax

; 2868 :     /* FIXME: what devices want 5 bytes, what ones want 7, and what
; 2869 :         ones want 11? Do this right when we figure that out */
; 2870 :         /* ISW20030819-1 Indicate WRHA performed */
; 2871 :         dev->ckdwrha=1;

  01fd2	48 8b 84 24 c0
	03 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  01fda	8b 80 14 13 00
	00		 mov	 eax, DWORD PTR [rax+4884]
  01fe0	0f ba e8 13	 bts	 eax, 19
  01fe4	48 8b 8c 24 c0
	03 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  01fec	89 81 14 13 00
	00		 mov	 DWORD PTR [rcx+4884], eax

; 2872 :         *residual = 0;

  01ff2	48 8b 84 24 10
	04 00 00	 mov	 rax, QWORD PTR residual$[rsp]
  01ffa	c7 00 00 00 00
	00		 mov	 DWORD PTR [rax], 0

; 2873 : 
; 2874 :         /* Return normal status */
; 2875 :         *unitstat = CSW_CE | CSW_DE;

  02000	48 8b 84 24 08
	04 00 00	 mov	 rax, QWORD PTR unitstat$[rsp]
  02008	c6 00 0c	 mov	 BYTE PTR [rax], 12

; 2876 : 
; 2877 :         break;

  0200b	e9 40 85 00 00	 jmp	 $LN2@ckd_dasd_e
$LN153@ckd_dasd_e:
$LN154@ckd_dasd_e:

; 2878 : 
; 2879 :     case 0x1E:
; 2880 :     case 0x9E:
; 2881 :     /*---------------------------------------------------------------*/
; 2882 :     /* READ COUNT KEY AND DATA                                       */
; 2883 :     /*---------------------------------------------------------------*/
; 2884 :         /* For 3990, command reject if not preceded by Seek, Seek Cyl,
; 2885 :            Locate Record, Read IPL, or Recalibrate command */
; 2886 :         if (dev->ckd3990
; 2887 :             && dev->ckdseek == 0 && dev->ckdskcyl == 0
; 2888 :             && dev->ckdlocat == 0 && dev->ckdrdipl == 0
; 2889 :             && dev->ckdrecal == 0)

  02010	48 8b 84 24 c0
	03 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  02018	8b 80 14 13 00
	00		 mov	 eax, DWORD PTR [rax+4884]
  0201e	83 e0 01	 and	 eax, 1
  02021	85 c0		 test	 eax, eax
  02023	0f 84 ab 00 00
	00		 je	 $LN155@ckd_dasd_e
  02029	48 8b 84 24 c0
	03 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  02031	8b 80 14 13 00
	00		 mov	 eax, DWORD PTR [rax+4884]
  02037	c1 e8 06	 shr	 eax, 6
  0203a	83 e0 01	 and	 eax, 1
  0203d	85 c0		 test	 eax, eax
  0203f	0f 85 8f 00 00
	00		 jne	 $LN155@ckd_dasd_e
  02045	48 8b 84 24 c0
	03 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  0204d	8b 80 14 13 00
	00		 mov	 eax, DWORD PTR [rax+4884]
  02053	c1 e8 07	 shr	 eax, 7
  02056	83 e0 01	 and	 eax, 1
  02059	85 c0		 test	 eax, eax
  0205b	75 77		 jne	 SHORT $LN155@ckd_dasd_e
  0205d	48 8b 84 24 c0
	03 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  02065	8b 80 14 13 00
	00		 mov	 eax, DWORD PTR [rax+4884]
  0206b	c1 e8 03	 shr	 eax, 3
  0206e	83 e0 01	 and	 eax, 1
  02071	85 c0		 test	 eax, eax
  02073	75 5f		 jne	 SHORT $LN155@ckd_dasd_e
  02075	48 8b 84 24 c0
	03 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  0207d	8b 80 14 13 00
	00		 mov	 eax, DWORD PTR [rax+4884]
  02083	c1 e8 09	 shr	 eax, 9
  02086	83 e0 01	 and	 eax, 1
  02089	85 c0		 test	 eax, eax
  0208b	75 47		 jne	 SHORT $LN155@ckd_dasd_e
  0208d	48 8b 84 24 c0
	03 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  02095	8b 80 14 13 00
	00		 mov	 eax, DWORD PTR [rax+4884]
  0209b	c1 e8 08	 shr	 eax, 8
  0209e	83 e0 01	 and	 eax, 1
  020a1	85 c0		 test	 eax, eax
  020a3	75 2f		 jne	 SHORT $LN155@ckd_dasd_e

; 2890 :         {
; 2891 :             ckd_build_sense (dev, SENSE_CR, 0, 0,

  020a5	c6 44 24 28 02	 mov	 BYTE PTR [rsp+40], 2
  020aa	c6 44 24 20 00	 mov	 BYTE PTR [rsp+32], 0
  020af	45 33 c9	 xor	 r9d, r9d
  020b2	45 33 c0	 xor	 r8d, r8d
  020b5	b2 80		 mov	 dl, 128			; 00000080H
  020b7	48 8b 8c 24 c0
	03 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  020bf	e8 00 00 00 00	 call	 ckd_build_sense

; 2892 :                             FORMAT_0, MESSAGE_2);
; 2893 :             *unitstat = CSW_CE | CSW_DE | CSW_UC;

  020c4	48 8b 84 24 08
	04 00 00	 mov	 rax, QWORD PTR unitstat$[rsp]
  020cc	c6 00 0e	 mov	 BYTE PTR [rax], 14

; 2894 :             break;

  020cf	e9 7c 84 00 00	 jmp	 $LN2@ckd_dasd_e
$LN155@ckd_dasd_e:

; 2895 :         }
; 2896 : 
; 2897 :         /* Check operation code if within domain of a Locate Record */
; 2898 :         if (dev->ckdlcount > 0)

  020d4	48 8b 84 24 c0
	03 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  020dc	0f b6 80 02 13
	00 00		 movzx	 eax, BYTE PTR [rax+4866]
  020e3	85 c0		 test	 eax, eax
  020e5	7e 74		 jle	 SHORT $LN156@ckd_dasd_e

; 2899 :         {
; 2900 :             if (!((dev->ckdloper & CKDOPER_CODE) == CKDOPER_RDDATA

  020e7	48 8b 84 24 c0
	03 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  020ef	0f b6 80 00 13
	00 00		 movzx	 eax, BYTE PTR [rax+4864]
  020f6	83 e0 3f	 and	 eax, 63			; 0000003fH
  020f9	83 f8 06	 cmp	 eax, 6
  020fc	74 5d		 je	 SHORT $LN157@ckd_dasd_e
  020fe	48 8b 84 24 c0
	03 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  02106	0f b6 80 00 13
	00 00		 movzx	 eax, BYTE PTR [rax+4864]
  0210d	83 e0 3f	 and	 eax, 63			; 0000003fH
  02110	83 f8 0a	 cmp	 eax, 10
  02113	74 46		 je	 SHORT $LN157@ckd_dasd_e
  02115	48 8b 84 24 c0
	03 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  0211d	0f b6 80 00 13
	00 00		 movzx	 eax, BYTE PTR [rax+4864]
  02124	83 e0 3f	 and	 eax, 63			; 0000003fH
  02127	83 f8 16	 cmp	 eax, 22
  0212a	74 2f		 je	 SHORT $LN157@ckd_dasd_e

; 2901 :                   || (dev->ckdloper & CKDOPER_CODE) == CKDOPER_RDANY
; 2902 :                   || (dev->ckdloper & CKDOPER_CODE) == CKDOPER_READ))
; 2903 :             {
; 2904 :                 ckd_build_sense (dev, SENSE_CR, 0, 0,

  0212c	c6 44 24 28 02	 mov	 BYTE PTR [rsp+40], 2
  02131	c6 44 24 20 00	 mov	 BYTE PTR [rsp+32], 0
  02136	45 33 c9	 xor	 r9d, r9d
  02139	45 33 c0	 xor	 r8d, r8d
  0213c	b2 80		 mov	 dl, 128			; 00000080H
  0213e	48 8b 8c 24 c0
	03 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  02146	e8 00 00 00 00	 call	 ckd_build_sense

; 2905 :                                 FORMAT_0, MESSAGE_2);
; 2906 :                 *unitstat = CSW_CE | CSW_DE | CSW_UC;

  0214b	48 8b 84 24 08
	04 00 00	 mov	 rax, QWORD PTR unitstat$[rsp]
  02153	c6 00 0e	 mov	 BYTE PTR [rax], 14

; 2907 :                 break;

  02156	e9 f5 83 00 00	 jmp	 $LN2@ckd_dasd_e
$LN157@ckd_dasd_e:
$LN156@ckd_dasd_e:

; 2908 :             }
; 2909 :         }
; 2910 : 
; 2911 :         /* Read next count field */
; 2912 :         rc = ckd_read_count (dev, code, &rechdr, unitstat);

  0215b	4c 8b 8c 24 08
	04 00 00	 mov	 r9, QWORD PTR unitstat$[rsp]
  02163	4c 8d 84 24 38
	02 00 00	 lea	 r8, QWORD PTR rechdr$[rsp]
  0216b	0f b6 94 24 c8
	03 00 00	 movzx	 edx, BYTE PTR code$[rsp]
  02173	48 8b 8c 24 c0
	03 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  0217b	e8 00 00 00 00	 call	 ckd_read_count
  02180	89 44 24 60	 mov	 DWORD PTR rc$[rsp], eax

; 2913 :         if (rc < 0) break;

  02184	83 7c 24 60 00	 cmp	 DWORD PTR rc$[rsp], 0
  02189	7d 05		 jge	 SHORT $LN158@ckd_dasd_e
  0218b	e9 c0 83 00 00	 jmp	 $LN2@ckd_dasd_e
$LN158@ckd_dasd_e:

; 2914 : 
; 2915 :         /* Calculate number of bytes to read and set residual count */
; 2916 :         size = CKD_RECHDR_SIZE + dev->ckdcurkl + dev->ckdcurdl;

  02190	48 8b 84 24 c0
	03 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  02198	48 63 80 d4 12
	00 00		 movsxd	 rax, DWORD PTR [rax+4820]
  0219f	48 8b 8c 24 c0
	03 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  021a7	0f b7 89 ea 12
	00 00		 movzx	 ecx, WORD PTR [rcx+4842]
  021ae	48 8d 44 08 08	 lea	 rax, QWORD PTR [rax+rcx+8]
  021b3	89 44 24 68	 mov	 DWORD PTR size$[rsp], eax

; 2917 :         num = (count < size) ? count : size;

  021b7	8b 44 24 68	 mov	 eax, DWORD PTR size$[rsp]
  021bb	39 84 24 e0 03
	00 00		 cmp	 DWORD PTR count$[rsp], eax
  021c2	73 10		 jae	 SHORT $LN663@ckd_dasd_e
  021c4	8b 84 24 e0 03
	00 00		 mov	 eax, DWORD PTR count$[rsp]
  021cb	89 84 24 f8 00
	00 00		 mov	 DWORD PTR tv1076[rsp], eax
  021d2	eb 0b		 jmp	 SHORT $LN664@ckd_dasd_e
$LN663@ckd_dasd_e:
  021d4	8b 44 24 68	 mov	 eax, DWORD PTR size$[rsp]
  021d8	89 84 24 f8 00
	00 00		 mov	 DWORD PTR tv1076[rsp], eax
$LN664@ckd_dasd_e:
  021df	8b 84 24 f8 00
	00 00		 mov	 eax, DWORD PTR tv1076[rsp]
  021e6	89 44 24 64	 mov	 DWORD PTR num$[rsp], eax

; 2918 :         *residual = count - num;

  021ea	8b 44 24 64	 mov	 eax, DWORD PTR num$[rsp]
  021ee	8b 8c 24 e0 03
	00 00		 mov	 ecx, DWORD PTR count$[rsp]
  021f5	2b c8		 sub	 ecx, eax
  021f7	8b c1		 mov	 eax, ecx
  021f9	48 8b 8c 24 10
	04 00 00	 mov	 rcx, QWORD PTR residual$[rsp]
  02201	89 01		 mov	 DWORD PTR [rcx], eax

; 2919 :         if (count < size) *more = 1;

  02203	8b 44 24 68	 mov	 eax, DWORD PTR size$[rsp]
  02207	39 84 24 e0 03
	00 00		 cmp	 DWORD PTR count$[rsp], eax
  0220e	73 0b		 jae	 SHORT $LN159@ckd_dasd_e
  02210	48 8b 84 24 00
	04 00 00	 mov	 rax, QWORD PTR more$[rsp]
  02218	c6 00 01	 mov	 BYTE PTR [rax], 1
$LN159@ckd_dasd_e:

; 2920 :         offset = CKD_RECHDR_SIZE + dev->ckdcurkl;

  0221b	48 8b 84 24 c0
	03 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  02223	48 63 80 d4 12
	00 00		 movsxd	 rax, DWORD PTR [rax+4820]
  0222a	48 83 c0 08	 add	 rax, 8
  0222e	89 44 24 74	 mov	 DWORD PTR offset$[rsp], eax

; 2921 : 
; 2922 :         /* Copy count field to I/O buffer */
; 2923 :         memcpy (iobuf, &rechdr, CKD_RECHDR_SIZE);

  02232	48 8b 84 24 f8
	03 00 00	 mov	 rax, QWORD PTR iobuf$[rsp]
  0223a	48 8b 8c 24 38
	02 00 00	 mov	 rcx, QWORD PTR rechdr$[rsp]
  02242	48 89 08	 mov	 QWORD PTR [rax], rcx

; 2924 : 
; 2925 :         /* Turn off track overflow flag in read record header */
; 2926 :         if(dev->ckdcyls < 32768)

  02245	48 8b 84 24 c0
	03 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  0224d	81 b8 b8 12 00
	00 00 80 00 00	 cmp	 DWORD PTR [rax+4792], 32768 ; 00008000H
  02257	7d 18		 jge	 SHORT $LN160@ckd_dasd_e

; 2927 :             *iobuf &= 0x7F;

  02259	48 8b 84 24 f8
	03 00 00	 mov	 rax, QWORD PTR iobuf$[rsp]
  02261	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  02264	83 e0 7f	 and	 eax, 127		; 0000007fH
  02267	48 8b 8c 24 f8
	03 00 00	 mov	 rcx, QWORD PTR iobuf$[rsp]
  0226f	88 01		 mov	 BYTE PTR [rcx], al
$LN160@ckd_dasd_e:

; 2928 : 
; 2929 :         /* Read key field */
; 2930 :         rc = ckd_read_key (dev, code,

  02271	48 8b 84 24 f8
	03 00 00	 mov	 rax, QWORD PTR iobuf$[rsp]
  02279	48 83 c0 08	 add	 rax, 8
  0227d	4c 8b 8c 24 08
	04 00 00	 mov	 r9, QWORD PTR unitstat$[rsp]
  02285	4c 8b c0	 mov	 r8, rax
  02288	0f b6 94 24 c8
	03 00 00	 movzx	 edx, BYTE PTR code$[rsp]
  02290	48 8b 8c 24 c0
	03 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  02298	e8 00 00 00 00	 call	 ckd_read_key
  0229d	89 44 24 60	 mov	 DWORD PTR rc$[rsp], eax

; 2931 :                             iobuf + CKD_RECHDR_SIZE, unitstat);
; 2932 :         if (rc < 0) break;

  022a1	83 7c 24 60 00	 cmp	 DWORD PTR rc$[rsp], 0
  022a6	7d 05		 jge	 SHORT $LN161@ckd_dasd_e
  022a8	e9 a3 82 00 00	 jmp	 $LN2@ckd_dasd_e
$LN161@ckd_dasd_e:

; 2933 : 
; 2934 :         /* Read data field */
; 2935 :         rc = ckd_read_data (dev, code,

  022ad	48 8b 84 24 c0
	03 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  022b5	48 63 80 d4 12
	00 00		 movsxd	 rax, DWORD PTR [rax+4820]
  022bc	48 8b 8c 24 f8
	03 00 00	 mov	 rcx, QWORD PTR iobuf$[rsp]
  022c4	48 8d 44 01 08	 lea	 rax, QWORD PTR [rcx+rax+8]
  022c9	4c 8b 8c 24 08
	04 00 00	 mov	 r9, QWORD PTR unitstat$[rsp]
  022d1	4c 8b c0	 mov	 r8, rax
  022d4	0f b6 94 24 c8
	03 00 00	 movzx	 edx, BYTE PTR code$[rsp]
  022dc	48 8b 8c 24 c0
	03 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  022e4	e8 00 00 00 00	 call	 ckd_read_data
  022e9	89 44 24 60	 mov	 DWORD PTR rc$[rsp], eax

; 2936 :                             iobuf + CKD_RECHDR_SIZE + dev->ckdcurkl,
; 2937 :                             unitstat);
; 2938 :         if (rc < 0) break;

  022ed	83 7c 24 60 00	 cmp	 DWORD PTR rc$[rsp], 0
  022f2	7d 05		 jge	 SHORT $LN162@ckd_dasd_e
  022f4	e9 57 82 00 00	 jmp	 $LN2@ckd_dasd_e
$LN162@ckd_dasd_e:
$LN8@ckd_dasd_e:

; 2939 : 
; 2940 :         /* If track overflow, keep reading */
; 2941 :         while (dev->ckdtrkof)

  022f9	48 8b 84 24 c0
	03 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  02301	8b 80 14 13 00
	00		 mov	 eax, DWORD PTR [rax+4884]
  02307	c1 e8 0f	 shr	 eax, 15
  0230a	83 e0 01	 and	 eax, 1
  0230d	85 c0		 test	 eax, eax
  0230f	0f 84 7d 01 00
	00		 je	 $LN9@ckd_dasd_e

; 2942 :         {
; 2943 :             /* Advance to next track */
; 2944 :             rc = mt_advance (dev, unitstat, 1);

  02315	41 b8 01 00 00
	00		 mov	 r8d, 1
  0231b	48 8b 94 24 08
	04 00 00	 mov	 rdx, QWORD PTR unitstat$[rsp]
  02323	48 8b 8c 24 c0
	03 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  0232b	e8 00 00 00 00	 call	 mt_advance
  02330	89 44 24 60	 mov	 DWORD PTR rc$[rsp], eax

; 2945 :             if (rc < 0) break;

  02334	83 7c 24 60 00	 cmp	 DWORD PTR rc$[rsp], 0
  02339	7d 05		 jge	 SHORT $LN163@ckd_dasd_e
  0233b	e9 52 01 00 00	 jmp	 $LN9@ckd_dasd_e
$LN163@ckd_dasd_e:

; 2946 : 
; 2947 :             /* Read the first count field */
; 2948 :             rc = ckd_read_count (dev, code, &rechdr, unitstat);

  02340	4c 8b 8c 24 08
	04 00 00	 mov	 r9, QWORD PTR unitstat$[rsp]
  02348	4c 8d 84 24 38
	02 00 00	 lea	 r8, QWORD PTR rechdr$[rsp]
  02350	0f b6 94 24 c8
	03 00 00	 movzx	 edx, BYTE PTR code$[rsp]
  02358	48 8b 8c 24 c0
	03 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  02360	e8 00 00 00 00	 call	 ckd_read_count
  02365	89 44 24 60	 mov	 DWORD PTR rc$[rsp], eax

; 2949 :             if (rc < 0) break;

  02369	83 7c 24 60 00	 cmp	 DWORD PTR rc$[rsp], 0
  0236e	7d 05		 jge	 SHORT $LN164@ckd_dasd_e
  02370	e9 1d 01 00 00	 jmp	 $LN9@ckd_dasd_e
$LN164@ckd_dasd_e:

; 2950 : 
; 2951 :             /* Skip the key field if present */
; 2952 :             if (dev->ckdcurkl > 0)

  02375	48 8b 84 24 c0
	03 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  0237d	83 b8 d4 12 00
	00 00		 cmp	 DWORD PTR [rax+4820], 0
  02384	7e 2a		 jle	 SHORT $LN165@ckd_dasd_e

; 2953 :                 dev->bufoff += dev->ckdcurkl;

  02386	48 8b 84 24 c0
	03 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  0238e	8b 80 e0 01 00
	00		 mov	 eax, DWORD PTR [rax+480]
  02394	48 8b 8c 24 c0
	03 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  0239c	03 81 d4 12 00
	00		 add	 eax, DWORD PTR [rcx+4820]
  023a2	48 8b 8c 24 c0
	03 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  023aa	89 81 e0 01 00
	00		 mov	 DWORD PTR [rcx+480], eax
$LN165@ckd_dasd_e:

; 2954 : 
; 2955 :             /* Set offset into buffer for this read */
; 2956 :             offset += num;

  023b0	8b 44 24 64	 mov	 eax, DWORD PTR num$[rsp]
  023b4	8b 4c 24 74	 mov	 ecx, DWORD PTR offset$[rsp]
  023b8	03 c8		 add	 ecx, eax
  023ba	8b c1		 mov	 eax, ecx
  023bc	89 44 24 74	 mov	 DWORD PTR offset$[rsp], eax

; 2957 : 
; 2958 :             /* Account for size of this overflow record */
; 2959 :             size = dev->ckdcurdl;

  023c0	48 8b 84 24 c0
	03 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  023c8	0f b7 80 ea 12
	00 00		 movzx	 eax, WORD PTR [rax+4842]
  023cf	89 44 24 68	 mov	 DWORD PTR size$[rsp], eax

; 2960 :             num = (*residual < size) ? *residual : size;

  023d3	48 8b 84 24 10
	04 00 00	 mov	 rax, QWORD PTR residual$[rsp]
  023db	8b 4c 24 68	 mov	 ecx, DWORD PTR size$[rsp]
  023df	39 08		 cmp	 DWORD PTR [rax], ecx
  023e1	73 13		 jae	 SHORT $LN665@ckd_dasd_e
  023e3	48 8b 84 24 10
	04 00 00	 mov	 rax, QWORD PTR residual$[rsp]
  023eb	8b 00		 mov	 eax, DWORD PTR [rax]
  023ed	89 84 24 fc 00
	00 00		 mov	 DWORD PTR tv1137[rsp], eax
  023f4	eb 0b		 jmp	 SHORT $LN666@ckd_dasd_e
$LN665@ckd_dasd_e:
  023f6	8b 44 24 68	 mov	 eax, DWORD PTR size$[rsp]
  023fa	89 84 24 fc 00
	00 00		 mov	 DWORD PTR tv1137[rsp], eax
$LN666@ckd_dasd_e:
  02401	8b 84 24 fc 00
	00 00		 mov	 eax, DWORD PTR tv1137[rsp]
  02408	89 44 24 64	 mov	 DWORD PTR num$[rsp], eax

; 2961 :             if (*residual < size) *more = 1;

  0240c	48 8b 84 24 10
	04 00 00	 mov	 rax, QWORD PTR residual$[rsp]
  02414	8b 4c 24 68	 mov	 ecx, DWORD PTR size$[rsp]
  02418	39 08		 cmp	 DWORD PTR [rax], ecx
  0241a	73 0d		 jae	 SHORT $LN166@ckd_dasd_e
  0241c	48 8b 84 24 00
	04 00 00	 mov	 rax, QWORD PTR more$[rsp]
  02424	c6 00 01	 mov	 BYTE PTR [rax], 1
  02427	eb 0b		 jmp	 SHORT $LN167@ckd_dasd_e
$LN166@ckd_dasd_e:

; 2962 :             else *more = 0;

  02429	48 8b 84 24 00
	04 00 00	 mov	 rax, QWORD PTR more$[rsp]
  02431	c6 00 00	 mov	 BYTE PTR [rax], 0
$LN167@ckd_dasd_e:

; 2963 :             *residual -= num;

  02434	48 8b 84 24 10
	04 00 00	 mov	 rax, QWORD PTR residual$[rsp]
  0243c	8b 4c 24 64	 mov	 ecx, DWORD PTR num$[rsp]
  02440	8b 00		 mov	 eax, DWORD PTR [rax]
  02442	2b c1		 sub	 eax, ecx
  02444	48 8b 8c 24 10
	04 00 00	 mov	 rcx, QWORD PTR residual$[rsp]
  0244c	89 01		 mov	 DWORD PTR [rcx], eax

; 2964 : 
; 2965 :             /* Read the next data field */
; 2966 :             rc = ckd_read_data (dev, code, iobuf+offset, unitstat);

  0244e	8b 44 24 74	 mov	 eax, DWORD PTR offset$[rsp]
  02452	48 8b 8c 24 f8
	03 00 00	 mov	 rcx, QWORD PTR iobuf$[rsp]
  0245a	48 03 c8	 add	 rcx, rax
  0245d	48 8b c1	 mov	 rax, rcx
  02460	4c 8b 8c 24 08
	04 00 00	 mov	 r9, QWORD PTR unitstat$[rsp]
  02468	4c 8b c0	 mov	 r8, rax
  0246b	0f b6 94 24 c8
	03 00 00	 movzx	 edx, BYTE PTR code$[rsp]
  02473	48 8b 8c 24 c0
	03 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  0247b	e8 00 00 00 00	 call	 ckd_read_data
  02480	89 44 24 60	 mov	 DWORD PTR rc$[rsp], eax

; 2967 :             if (rc < 0) break;

  02484	83 7c 24 60 00	 cmp	 DWORD PTR rc$[rsp], 0
  02489	7d 02		 jge	 SHORT $LN168@ckd_dasd_e
  0248b	eb 05		 jmp	 SHORT $LN9@ckd_dasd_e
$LN168@ckd_dasd_e:

; 2968 :         }

  0248d	e9 67 fe ff ff	 jmp	 $LN8@ckd_dasd_e
$LN9@ckd_dasd_e:

; 2969 : 
; 2970 :         /* Bail out if track overflow produced I/O error */
; 2971 :         if (rc < 0) break;

  02492	83 7c 24 60 00	 cmp	 DWORD PTR rc$[rsp], 0
  02497	7d 05		 jge	 SHORT $LN169@ckd_dasd_e
  02499	e9 b2 80 00 00	 jmp	 $LN2@ckd_dasd_e
$LN169@ckd_dasd_e:

; 2972 : 
; 2973 :         /* Save size and offset of data not used by this CCW */
; 2974 :         dev->ckdrem = (U16)(size - num);

  0249e	8b 44 24 64	 mov	 eax, DWORD PTR num$[rsp]
  024a2	8b 4c 24 68	 mov	 ecx, DWORD PTR size$[rsp]
  024a6	2b c8		 sub	 ecx, eax
  024a8	8b c1		 mov	 eax, ecx
  024aa	48 8b 8c 24 c0
	03 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  024b2	66 89 81 ec 12
	00 00		 mov	 WORD PTR [rcx+4844], ax

; 2975 :         dev->ckdpos = (U16)(       num);

  024b9	48 8b 84 24 c0
	03 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  024c1	0f b7 4c 24 64	 movzx	 ecx, WORD PTR num$[rsp]
  024c6	66 89 88 ee 12
	00 00		 mov	 WORD PTR [rax+4846], cx

; 2976 : 
; 2977 :         /* Return unit exception if data length is zero */
; 2978 :         if (dev->ckdcurdl == 0)

  024cd	48 8b 84 24 c0
	03 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  024d5	0f b7 80 ea 12
	00 00		 movzx	 eax, WORD PTR [rax+4842]
  024dc	85 c0		 test	 eax, eax
  024de	75 0d		 jne	 SHORT $LN170@ckd_dasd_e

; 2979 :             *unitstat = CSW_CE | CSW_DE | CSW_UX;

  024e0	48 8b 84 24 08
	04 00 00	 mov	 rax, QWORD PTR unitstat$[rsp]
  024e8	c6 00 0d	 mov	 BYTE PTR [rax], 13
  024eb	eb 0b		 jmp	 SHORT $LN171@ckd_dasd_e
$LN170@ckd_dasd_e:

; 2980 :         else
; 2981 :             *unitstat = CSW_CE | CSW_DE;

  024ed	48 8b 84 24 08
	04 00 00	 mov	 rax, QWORD PTR unitstat$[rsp]
  024f5	c6 00 0c	 mov	 BYTE PTR [rax], 12
$LN171@ckd_dasd_e:

; 2982 : 
; 2983 :         break;

  024f8	e9 53 80 00 00	 jmp	 $LN2@ckd_dasd_e
$LN172@ckd_dasd_e:

; 2984 : 
; 2985 :     case 0x5E:
; 2986 :     /*---------------------------------------------------------------*/
; 2987 :     /* READ MULTIPLE COUNT KEY AND DATA                              */
; 2988 :     /*---------------------------------------------------------------*/
; 2989 :         /* For 3990, command reject if not preceded by Seek, Seek Cyl,
; 2990 :            Locate Record, Read IPL, or Recalibrate */
; 2991 :         if (dev->ckd3990
; 2992 :             && dev->ckdseek == 0 && dev->ckdskcyl == 0
; 2993 :             && dev->ckdlocat == 0 && dev->ckdrdipl == 0
; 2994 :             && dev->ckdrecal == 0)

  024fd	48 8b 84 24 c0
	03 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  02505	8b 80 14 13 00
	00		 mov	 eax, DWORD PTR [rax+4884]
  0250b	83 e0 01	 and	 eax, 1
  0250e	85 c0		 test	 eax, eax
  02510	0f 84 ab 00 00
	00		 je	 $LN173@ckd_dasd_e
  02516	48 8b 84 24 c0
	03 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  0251e	8b 80 14 13 00
	00		 mov	 eax, DWORD PTR [rax+4884]
  02524	c1 e8 06	 shr	 eax, 6
  02527	83 e0 01	 and	 eax, 1
  0252a	85 c0		 test	 eax, eax
  0252c	0f 85 8f 00 00
	00		 jne	 $LN173@ckd_dasd_e
  02532	48 8b 84 24 c0
	03 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  0253a	8b 80 14 13 00
	00		 mov	 eax, DWORD PTR [rax+4884]
  02540	c1 e8 07	 shr	 eax, 7
  02543	83 e0 01	 and	 eax, 1
  02546	85 c0		 test	 eax, eax
  02548	75 77		 jne	 SHORT $LN173@ckd_dasd_e
  0254a	48 8b 84 24 c0
	03 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  02552	8b 80 14 13 00
	00		 mov	 eax, DWORD PTR [rax+4884]
  02558	c1 e8 03	 shr	 eax, 3
  0255b	83 e0 01	 and	 eax, 1
  0255e	85 c0		 test	 eax, eax
  02560	75 5f		 jne	 SHORT $LN173@ckd_dasd_e
  02562	48 8b 84 24 c0
	03 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  0256a	8b 80 14 13 00
	00		 mov	 eax, DWORD PTR [rax+4884]
  02570	c1 e8 09	 shr	 eax, 9
  02573	83 e0 01	 and	 eax, 1
  02576	85 c0		 test	 eax, eax
  02578	75 47		 jne	 SHORT $LN173@ckd_dasd_e
  0257a	48 8b 84 24 c0
	03 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  02582	8b 80 14 13 00
	00		 mov	 eax, DWORD PTR [rax+4884]
  02588	c1 e8 08	 shr	 eax, 8
  0258b	83 e0 01	 and	 eax, 1
  0258e	85 c0		 test	 eax, eax
  02590	75 2f		 jne	 SHORT $LN173@ckd_dasd_e

; 2995 :         {
; 2996 :             ckd_build_sense (dev, SENSE_CR, 0, 0,

  02592	c6 44 24 28 02	 mov	 BYTE PTR [rsp+40], 2
  02597	c6 44 24 20 00	 mov	 BYTE PTR [rsp+32], 0
  0259c	45 33 c9	 xor	 r9d, r9d
  0259f	45 33 c0	 xor	 r8d, r8d
  025a2	b2 80		 mov	 dl, 128			; 00000080H
  025a4	48 8b 8c 24 c0
	03 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  025ac	e8 00 00 00 00	 call	 ckd_build_sense

; 2997 :                             FORMAT_0, MESSAGE_2);
; 2998 :             *unitstat = CSW_CE | CSW_DE | CSW_UC;

  025b1	48 8b 84 24 08
	04 00 00	 mov	 rax, QWORD PTR unitstat$[rsp]
  025b9	c6 00 0e	 mov	 BYTE PTR [rax], 14

; 2999 :             break;

  025bc	e9 8f 7f 00 00	 jmp	 $LN2@ckd_dasd_e
$LN173@ckd_dasd_e:

; 3000 :         }
; 3001 : 
; 3002 :         /* Command reject if within the domain of a Locate Record */
; 3003 :         if (dev->ckdlcount > 0)

  025c1	48 8b 84 24 c0
	03 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  025c9	0f b6 80 02 13
	00 00		 movzx	 eax, BYTE PTR [rax+4866]
  025d0	85 c0		 test	 eax, eax
  025d2	7e 2f		 jle	 SHORT $LN174@ckd_dasd_e

; 3004 :         {
; 3005 :             ckd_build_sense (dev, SENSE_CR, 0, 0,

  025d4	c6 44 24 28 02	 mov	 BYTE PTR [rsp+40], 2
  025d9	c6 44 24 20 00	 mov	 BYTE PTR [rsp+32], 0
  025de	45 33 c9	 xor	 r9d, r9d
  025e1	45 33 c0	 xor	 r8d, r8d
  025e4	b2 80		 mov	 dl, 128			; 00000080H
  025e6	48 8b 8c 24 c0
	03 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  025ee	e8 00 00 00 00	 call	 ckd_build_sense

; 3006 :                             FORMAT_0, MESSAGE_2);
; 3007 :             *unitstat = CSW_CE | CSW_DE | CSW_UC;

  025f3	48 8b 84 24 08
	04 00 00	 mov	 rax, QWORD PTR unitstat$[rsp]
  025fb	c6 00 0e	 mov	 BYTE PTR [rax], 14

; 3008 :             break;

  025fe	e9 4d 7f 00 00	 jmp	 $LN2@ckd_dasd_e
$LN174@ckd_dasd_e:

; 3009 :         }
; 3010 : 
; 3011 :         /* Read records into the I/O buffer until end of track */
; 3012 :         for (size = 0; ; )

  02603	c7 44 24 68 00
	00 00 00	 mov	 DWORD PTR size$[rsp], 0
$LN10@ckd_dasd_e:

; 3013 :         {
; 3014 :             /* Read next count field */
; 3015 :             rc = ckd_read_count (dev, code, &rechdr, unitstat);

  0260b	4c 8b 8c 24 08
	04 00 00	 mov	 r9, QWORD PTR unitstat$[rsp]
  02613	4c 8d 84 24 38
	02 00 00	 lea	 r8, QWORD PTR rechdr$[rsp]
  0261b	0f b6 94 24 c8
	03 00 00	 movzx	 edx, BYTE PTR code$[rsp]
  02623	48 8b 8c 24 c0
	03 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  0262b	e8 00 00 00 00	 call	 ckd_read_count
  02630	89 44 24 60	 mov	 DWORD PTR rc$[rsp], eax

; 3016 :             if (rc < 0) break;

  02634	83 7c 24 60 00	 cmp	 DWORD PTR rc$[rsp], 0
  02639	7d 05		 jge	 SHORT $LN175@ckd_dasd_e
  0263b	e9 35 01 00 00	 jmp	 $LN11@ckd_dasd_e
$LN175@ckd_dasd_e:

; 3017 : 
; 3018 :             /* Exit if end of track marker was read */
; 3019 :             if (memcmp( &rechdr, &CKD_ENDTRK, CKD_ENDTRK_SIZE ) == 0)

  02640	41 b8 08 00 00
	00		 mov	 r8d, 8
  02646	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:CKD_ENDTRK
  0264d	48 8d 8c 24 38
	02 00 00	 lea	 rcx, QWORD PTR rechdr$[rsp]
  02655	e8 00 00 00 00	 call	 memcmp
  0265a	85 c0		 test	 eax, eax
  0265c	75 05		 jne	 SHORT $LN176@ckd_dasd_e

; 3020 :                 break;

  0265e	e9 12 01 00 00	 jmp	 $LN11@ckd_dasd_e
$LN176@ckd_dasd_e:

; 3021 : 
; 3022 :             /* Copy count field to I/O buffer */
; 3023 :             memcpy (iobuf + size, &rechdr, CKD_RECHDR_SIZE);

  02663	8b 44 24 68	 mov	 eax, DWORD PTR size$[rsp]
  02667	48 8b 8c 24 f8
	03 00 00	 mov	 rcx, QWORD PTR iobuf$[rsp]
  0266f	48 8b 94 24 38
	02 00 00	 mov	 rdx, QWORD PTR rechdr$[rsp]
  02677	48 89 14 01	 mov	 QWORD PTR [rcx+rax], rdx

; 3024 :             size += CKD_RECHDR_SIZE;

  0267b	8b 44 24 68	 mov	 eax, DWORD PTR size$[rsp]
  0267f	48 83 c0 08	 add	 rax, 8
  02683	89 44 24 68	 mov	 DWORD PTR size$[rsp], eax

; 3025 : 
; 3026 :             /* Turn off track overflow flag */
; 3027 :             if(dev->ckdcyls < 32768)

  02687	48 8b 84 24 c0
	03 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  0268f	81 b8 b8 12 00
	00 00 80 00 00	 cmp	 DWORD PTR [rax+4792], 32768 ; 00008000H
  02699	7d 22		 jge	 SHORT $LN177@ckd_dasd_e

; 3028 :                 *(iobuf + size) &= 0x7F;

  0269b	8b 44 24 68	 mov	 eax, DWORD PTR size$[rsp]
  0269f	48 8b 8c 24 f8
	03 00 00	 mov	 rcx, QWORD PTR iobuf$[rsp]
  026a7	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  026ab	83 e0 7f	 and	 eax, 127		; 0000007fH
  026ae	8b 4c 24 68	 mov	 ecx, DWORD PTR size$[rsp]
  026b2	48 8b 94 24 f8
	03 00 00	 mov	 rdx, QWORD PTR iobuf$[rsp]
  026ba	88 04 0a	 mov	 BYTE PTR [rdx+rcx], al
$LN177@ckd_dasd_e:

; 3029 : 
; 3030 :             /* Read key field */
; 3031 :             rc = ckd_read_key (dev, code, iobuf + size, unitstat);

  026bd	8b 44 24 68	 mov	 eax, DWORD PTR size$[rsp]
  026c1	48 8b 8c 24 f8
	03 00 00	 mov	 rcx, QWORD PTR iobuf$[rsp]
  026c9	48 03 c8	 add	 rcx, rax
  026cc	48 8b c1	 mov	 rax, rcx
  026cf	4c 8b 8c 24 08
	04 00 00	 mov	 r9, QWORD PTR unitstat$[rsp]
  026d7	4c 8b c0	 mov	 r8, rax
  026da	0f b6 94 24 c8
	03 00 00	 movzx	 edx, BYTE PTR code$[rsp]
  026e2	48 8b 8c 24 c0
	03 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  026ea	e8 00 00 00 00	 call	 ckd_read_key
  026ef	89 44 24 60	 mov	 DWORD PTR rc$[rsp], eax

; 3032 :             if (rc < 0) break;

  026f3	83 7c 24 60 00	 cmp	 DWORD PTR rc$[rsp], 0
  026f8	7d 02		 jge	 SHORT $LN178@ckd_dasd_e
  026fa	eb 79		 jmp	 SHORT $LN11@ckd_dasd_e
$LN178@ckd_dasd_e:

; 3033 :             size += dev->ckdcurkl;

  026fc	48 8b 84 24 c0
	03 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  02704	8b 80 d4 12 00
	00		 mov	 eax, DWORD PTR [rax+4820]
  0270a	8b 4c 24 68	 mov	 ecx, DWORD PTR size$[rsp]
  0270e	03 c8		 add	 ecx, eax
  02710	8b c1		 mov	 eax, ecx
  02712	89 44 24 68	 mov	 DWORD PTR size$[rsp], eax

; 3034 : 
; 3035 :             /* Read data field */
; 3036 :             rc = ckd_read_data (dev, code, iobuf + size, unitstat);

  02716	8b 44 24 68	 mov	 eax, DWORD PTR size$[rsp]
  0271a	48 8b 8c 24 f8
	03 00 00	 mov	 rcx, QWORD PTR iobuf$[rsp]
  02722	48 03 c8	 add	 rcx, rax
  02725	48 8b c1	 mov	 rax, rcx
  02728	4c 8b 8c 24 08
	04 00 00	 mov	 r9, QWORD PTR unitstat$[rsp]
  02730	4c 8b c0	 mov	 r8, rax
  02733	0f b6 94 24 c8
	03 00 00	 movzx	 edx, BYTE PTR code$[rsp]
  0273b	48 8b 8c 24 c0
	03 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  02743	e8 00 00 00 00	 call	 ckd_read_data
  02748	89 44 24 60	 mov	 DWORD PTR rc$[rsp], eax

; 3037 :             if (rc < 0) break;

  0274c	83 7c 24 60 00	 cmp	 DWORD PTR rc$[rsp], 0
  02751	7d 02		 jge	 SHORT $LN179@ckd_dasd_e
  02753	eb 20		 jmp	 SHORT $LN11@ckd_dasd_e
$LN179@ckd_dasd_e:

; 3038 :             size += dev->ckdcurdl;

  02755	48 8b 84 24 c0
	03 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  0275d	0f b7 80 ea 12
	00 00		 movzx	 eax, WORD PTR [rax+4842]
  02764	8b 4c 24 68	 mov	 ecx, DWORD PTR size$[rsp]
  02768	03 c8		 add	 ecx, eax
  0276a	8b c1		 mov	 eax, ecx
  0276c	89 44 24 68	 mov	 DWORD PTR size$[rsp], eax

; 3039 : 
; 3040 :         } /* end for(size) */

  02770	e9 96 fe ff ff	 jmp	 $LN10@ckd_dasd_e
$LN11@ckd_dasd_e:

; 3041 : 
; 3042 :         /* Set the residual count */
; 3043 :         num = (count < size) ? count : size;

  02775	8b 44 24 68	 mov	 eax, DWORD PTR size$[rsp]
  02779	39 84 24 e0 03
	00 00		 cmp	 DWORD PTR count$[rsp], eax
  02780	73 10		 jae	 SHORT $LN667@ckd_dasd_e
  02782	8b 84 24 e0 03
	00 00		 mov	 eax, DWORD PTR count$[rsp]
  02789	89 84 24 00 01
	00 00		 mov	 DWORD PTR tv1250[rsp], eax
  02790	eb 0b		 jmp	 SHORT $LN668@ckd_dasd_e
$LN667@ckd_dasd_e:
  02792	8b 44 24 68	 mov	 eax, DWORD PTR size$[rsp]
  02796	89 84 24 00 01
	00 00		 mov	 DWORD PTR tv1250[rsp], eax
$LN668@ckd_dasd_e:
  0279d	8b 84 24 00 01
	00 00		 mov	 eax, DWORD PTR tv1250[rsp]
  027a4	89 44 24 64	 mov	 DWORD PTR num$[rsp], eax

; 3044 :         *residual = count - num;

  027a8	8b 44 24 64	 mov	 eax, DWORD PTR num$[rsp]
  027ac	8b 8c 24 e0 03
	00 00		 mov	 ecx, DWORD PTR count$[rsp]
  027b3	2b c8		 sub	 ecx, eax
  027b5	8b c1		 mov	 eax, ecx
  027b7	48 8b 8c 24 10
	04 00 00	 mov	 rcx, QWORD PTR residual$[rsp]
  027bf	89 01		 mov	 DWORD PTR [rcx], eax

; 3045 :         if (count < size) *more = 1;

  027c1	8b 44 24 68	 mov	 eax, DWORD PTR size$[rsp]
  027c5	39 84 24 e0 03
	00 00		 cmp	 DWORD PTR count$[rsp], eax
  027cc	73 0b		 jae	 SHORT $LN180@ckd_dasd_e
  027ce	48 8b 84 24 00
	04 00 00	 mov	 rax, QWORD PTR more$[rsp]
  027d6	c6 00 01	 mov	 BYTE PTR [rax], 1
$LN180@ckd_dasd_e:

; 3046 : 
; 3047 :         /* Save size and offset of data not used by this CCW */
; 3048 :         dev->ckdrem = (U16)(size - num);

  027d9	8b 44 24 64	 mov	 eax, DWORD PTR num$[rsp]
  027dd	8b 4c 24 68	 mov	 ecx, DWORD PTR size$[rsp]
  027e1	2b c8		 sub	 ecx, eax
  027e3	8b c1		 mov	 eax, ecx
  027e5	48 8b 8c 24 c0
	03 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  027ed	66 89 81 ec 12
	00 00		 mov	 WORD PTR [rcx+4844], ax

; 3049 :         dev->ckdpos = (U16)(       num);

  027f4	48 8b 84 24 c0
	03 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  027fc	0f b7 4c 24 64	 movzx	 ecx, WORD PTR num$[rsp]
  02801	66 89 88 ee 12
	00 00		 mov	 WORD PTR [rax+4846], cx

; 3050 : 
; 3051 :         /* Return normal status */
; 3052 :         *unitstat = CSW_CE | CSW_DE;

  02808	48 8b 84 24 08
	04 00 00	 mov	 rax, QWORD PTR unitstat$[rsp]
  02810	c6 00 0c	 mov	 BYTE PTR [rax], 12

; 3053 : 
; 3054 :         break;

  02813	e9 38 7d 00 00	 jmp	 $LN2@ckd_dasd_e
$LN181@ckd_dasd_e:

; 3055 : 
; 3056 :     case 0xDE:
; 3057 :     /*---------------------------------------------------------------*/
; 3058 :     /* READ TRACK                                                    */
; 3059 :     /*---------------------------------------------------------------*/
; 3060 :         /* Command reject if not within the domain of a Locate Record
; 3061 :            that specifies a read tracks operation */
; 3062 :         if (dev->ckdlcount == 0
; 3063 :          || (((dev->ckdloper & CKDOPER_CODE) != CKDOPER_RDTRKS)

  02818	48 8b 84 24 c0
	03 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  02820	0f b6 80 02 13
	00 00		 movzx	 eax, BYTE PTR [rax+4866]
  02827	85 c0		 test	 eax, eax
  02829	74 2e		 je	 SHORT $LN183@ckd_dasd_e
  0282b	48 8b 84 24 c0
	03 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  02833	0f b6 80 00 13
	00 00		 movzx	 eax, BYTE PTR [rax+4864]
  0283a	83 e0 3f	 and	 eax, 63			; 0000003fH
  0283d	83 f8 0c	 cmp	 eax, 12
  02840	74 46		 je	 SHORT $LN182@ckd_dasd_e
  02842	48 8b 84 24 c0
	03 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  0284a	0f b6 80 00 13
	00 00		 movzx	 eax, BYTE PTR [rax+4864]
  02851	83 e0 3f	 and	 eax, 63			; 0000003fH
  02854	83 f8 0e	 cmp	 eax, 14
  02857	74 2f		 je	 SHORT $LN182@ckd_dasd_e
$LN183@ckd_dasd_e:

; 3064 :           && ((dev->ckdloper & CKDOPER_CODE) != CKDOPER_RDTSET)))
; 3065 :         {
; 3066 :             ckd_build_sense (dev, SENSE_CR, 0, 0,

  02859	c6 44 24 28 02	 mov	 BYTE PTR [rsp+40], 2
  0285e	c6 44 24 20 00	 mov	 BYTE PTR [rsp+32], 0
  02863	45 33 c9	 xor	 r9d, r9d
  02866	45 33 c0	 xor	 r8d, r8d
  02869	b2 80		 mov	 dl, 128			; 00000080H
  0286b	48 8b 8c 24 c0
	03 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  02873	e8 00 00 00 00	 call	 ckd_build_sense

; 3067 :                             FORMAT_0, MESSAGE_2);
; 3068 :             *unitstat = CSW_CE | CSW_DE | CSW_UC;

  02878	48 8b 84 24 08
	04 00 00	 mov	 rax, QWORD PTR unitstat$[rsp]
  02880	c6 00 0e	 mov	 BYTE PTR [rax], 14

; 3069 :             break;

  02883	e9 c8 7c 00 00	 jmp	 $LN2@ckd_dasd_e
$LN182@ckd_dasd_e:

; 3070 :         }
; 3071 : 
; 3072 :         /* Command reject if not chained from a Locate Record
; 3073 :            command or from another Read Track command */
; 3074 :         if (chained == 0
; 3075 :          || (prevcode != 0x47 && prevcode != 0x4B && prevcode != 0xDE))

  02888	0f b6 84 24 d8
	03 00 00	 movzx	 eax, BYTE PTR chained$[rsp]
  02890	85 c0		 test	 eax, eax
  02892	74 29		 je	 SHORT $LN185@ckd_dasd_e
  02894	0f b6 84 24 e8
	03 00 00	 movzx	 eax, BYTE PTR prevcode$[rsp]
  0289c	83 f8 47	 cmp	 eax, 71			; 00000047H
  0289f	74 4b		 je	 SHORT $LN184@ckd_dasd_e
  028a1	0f b6 84 24 e8
	03 00 00	 movzx	 eax, BYTE PTR prevcode$[rsp]
  028a9	83 f8 4b	 cmp	 eax, 75			; 0000004bH
  028ac	74 3e		 je	 SHORT $LN184@ckd_dasd_e
  028ae	0f b6 84 24 e8
	03 00 00	 movzx	 eax, BYTE PTR prevcode$[rsp]
  028b6	3d de 00 00 00	 cmp	 eax, 222		; 000000deH
  028bb	74 2f		 je	 SHORT $LN184@ckd_dasd_e
$LN185@ckd_dasd_e:

; 3076 :         {
; 3077 :             ckd_build_sense (dev, SENSE_CR, 0, 0,

  028bd	c6 44 24 28 02	 mov	 BYTE PTR [rsp+40], 2
  028c2	c6 44 24 20 00	 mov	 BYTE PTR [rsp+32], 0
  028c7	45 33 c9	 xor	 r9d, r9d
  028ca	45 33 c0	 xor	 r8d, r8d
  028cd	b2 80		 mov	 dl, 128			; 00000080H
  028cf	48 8b 8c 24 c0
	03 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  028d7	e8 00 00 00 00	 call	 ckd_build_sense

; 3078 :                             FORMAT_0, MESSAGE_2);
; 3079 :             *unitstat = CSW_CE | CSW_DE | CSW_UC;

  028dc	48 8b 84 24 08
	04 00 00	 mov	 rax, QWORD PTR unitstat$[rsp]
  028e4	c6 00 0e	 mov	 BYTE PTR [rax], 14

; 3080 :             break;

  028e7	e9 64 7c 00 00	 jmp	 $LN2@ckd_dasd_e
$LN184@ckd_dasd_e:

; 3081 :         }
; 3082 : 
; 3083 :         /* Advance to next track if chained from previous read track */
; 3084 :         if (prevcode == 0xDE)

  028ec	0f b6 84 24 e8
	03 00 00	 movzx	 eax, BYTE PTR prevcode$[rsp]
  028f4	3d de 00 00 00	 cmp	 eax, 222		; 000000deH
  028f9	0f 85 96 00 00
	00		 jne	 $LN186@ckd_dasd_e

; 3085 :         {
; 3086 :             j = 1;

  028ff	c7 84 24 a8 00
	00 00 01 00 00
	00		 mov	 DWORD PTR j$[rsp], 1

; 3087 :             /* Skip tracks while hi bit off in ckdlmask */
; 3088 :             if (dev->ckdlmask)

  0290a	48 8b 84 24 c0
	03 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  02912	0f b7 80 fe 12
	00 00		 movzx	 eax, WORD PTR [rax+4862]
  02919	85 c0		 test	 eax, eax
  0291b	74 4b		 je	 SHORT $LN187@ckd_dasd_e
$LN13@ckd_dasd_e:

; 3089 :             {
; 3090 :                 while (!(dev->ckdlmask & 0x8000))

  0291d	48 8b 84 24 c0
	03 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  02925	0f b7 80 fe 12
	00 00		 movzx	 eax, WORD PTR [rax+4862]
  0292c	25 00 80 00 00	 and	 eax, 32768		; 00008000H
  02931	85 c0		 test	 eax, eax
  02933	75 33		 jne	 SHORT $LN14@ckd_dasd_e

; 3091 :                 {
; 3092 :                     j++;

  02935	8b 84 24 a8 00
	00 00		 mov	 eax, DWORD PTR j$[rsp]
  0293c	ff c0		 inc	 eax
  0293e	89 84 24 a8 00
	00 00		 mov	 DWORD PTR j$[rsp], eax

; 3093 :                     dev->ckdlmask <<= 1;

  02945	48 8b 84 24 c0
	03 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  0294d	0f b7 80 fe 12
	00 00		 movzx	 eax, WORD PTR [rax+4862]
  02954	66 d1 e0	 shl	 ax, 1
  02957	48 8b 8c 24 c0
	03 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  0295f	66 89 81 fe 12
	00 00		 mov	 WORD PTR [rcx+4862], ax

; 3094 :                 }

  02966	eb b5		 jmp	 SHORT $LN13@ckd_dasd_e
$LN14@ckd_dasd_e:
$LN187@ckd_dasd_e:

; 3095 :             }
; 3096 :             rc = mt_advance (dev, unitstat, j);

  02968	44 8b 84 24 a8
	00 00 00	 mov	 r8d, DWORD PTR j$[rsp]
  02970	48 8b 94 24 08
	04 00 00	 mov	 rdx, QWORD PTR unitstat$[rsp]
  02978	48 8b 8c 24 c0
	03 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  02980	e8 00 00 00 00	 call	 mt_advance
  02985	89 44 24 60	 mov	 DWORD PTR rc$[rsp], eax

; 3097 :             if (rc < 0) break;

  02989	83 7c 24 60 00	 cmp	 DWORD PTR rc$[rsp], 0
  0298e	7d 05		 jge	 SHORT $LN188@ckd_dasd_e
  02990	e9 bb 7b 00 00	 jmp	 $LN2@ckd_dasd_e
$LN188@ckd_dasd_e:
$LN186@ckd_dasd_e:

; 3098 :         }
; 3099 : 
; 3100 :         /* Shift read track set mask left a bit */
; 3101 :         dev->ckdlmask <<= 1;

  02995	48 8b 84 24 c0
	03 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  0299d	0f b7 80 fe 12
	00 00		 movzx	 eax, WORD PTR [rax+4862]
  029a4	66 d1 e0	 shl	 ax, 1
  029a7	48 8b 8c 24 c0
	03 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  029af	66 89 81 fe 12
	00 00		 mov	 WORD PTR [rcx+4862], ax

; 3102 : 
; 3103 :         /* Read each record on the track into the I/O buffer */
; 3104 :         for (size = 0; ; )

  029b6	c7 44 24 68 00
	00 00 00	 mov	 DWORD PTR size$[rsp], 0
$LN15@ckd_dasd_e:

; 3105 :         {
; 3106 :             /* Read next count field */
; 3107 :             rc = ckd_read_count (dev, code, &rechdr, unitstat);

  029be	4c 8b 8c 24 08
	04 00 00	 mov	 r9, QWORD PTR unitstat$[rsp]
  029c6	4c 8d 84 24 38
	02 00 00	 lea	 r8, QWORD PTR rechdr$[rsp]
  029ce	0f b6 94 24 c8
	03 00 00	 movzx	 edx, BYTE PTR code$[rsp]
  029d6	48 8b 8c 24 c0
	03 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  029de	e8 00 00 00 00	 call	 ckd_read_count
  029e3	89 44 24 60	 mov	 DWORD PTR rc$[rsp], eax

; 3108 :             if (rc < 0) break;

  029e7	83 7c 24 60 00	 cmp	 DWORD PTR rc$[rsp], 0
  029ec	7d 05		 jge	 SHORT $LN189@ckd_dasd_e
  029ee	e9 35 01 00 00	 jmp	 $LN16@ckd_dasd_e
$LN189@ckd_dasd_e:

; 3109 : 
; 3110 :             /* Copy count field to I/O buffer */
; 3111 :             memcpy (iobuf + size, &rechdr, CKD_RECHDR_SIZE);

  029f3	8b 44 24 68	 mov	 eax, DWORD PTR size$[rsp]
  029f7	48 8b 8c 24 f8
	03 00 00	 mov	 rcx, QWORD PTR iobuf$[rsp]
  029ff	48 8b 94 24 38
	02 00 00	 mov	 rdx, QWORD PTR rechdr$[rsp]
  02a07	48 89 14 01	 mov	 QWORD PTR [rcx+rax], rdx

; 3112 :             size += CKD_RECHDR_SIZE;

  02a0b	8b 44 24 68	 mov	 eax, DWORD PTR size$[rsp]
  02a0f	48 83 c0 08	 add	 rax, 8
  02a13	89 44 24 68	 mov	 DWORD PTR size$[rsp], eax

; 3113 : 
; 3114 :             /* Turn off track overflow flag */
; 3115 :             if(dev->ckdcyls < 32768)

  02a17	48 8b 84 24 c0
	03 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  02a1f	81 b8 b8 12 00
	00 00 80 00 00	 cmp	 DWORD PTR [rax+4792], 32768 ; 00008000H
  02a29	7d 22		 jge	 SHORT $LN190@ckd_dasd_e

; 3116 :                 *(iobuf+size) &= 0x7F;

  02a2b	8b 44 24 68	 mov	 eax, DWORD PTR size$[rsp]
  02a2f	48 8b 8c 24 f8
	03 00 00	 mov	 rcx, QWORD PTR iobuf$[rsp]
  02a37	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  02a3b	83 e0 7f	 and	 eax, 127		; 0000007fH
  02a3e	8b 4c 24 68	 mov	 ecx, DWORD PTR size$[rsp]
  02a42	48 8b 94 24 f8
	03 00 00	 mov	 rdx, QWORD PTR iobuf$[rsp]
  02a4a	88 04 0a	 mov	 BYTE PTR [rdx+rcx], al
$LN190@ckd_dasd_e:

; 3117 : 
; 3118 :             /* Exit if end of track marker was read */
; 3119 :             if (memcmp( &rechdr, &CKD_ENDTRK, CKD_ENDTRK_SIZE ) == 0)

  02a4d	41 b8 08 00 00
	00		 mov	 r8d, 8
  02a53	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:CKD_ENDTRK
  02a5a	48 8d 8c 24 38
	02 00 00	 lea	 rcx, QWORD PTR rechdr$[rsp]
  02a62	e8 00 00 00 00	 call	 memcmp
  02a67	85 c0		 test	 eax, eax
  02a69	75 05		 jne	 SHORT $LN191@ckd_dasd_e

; 3120 :                 break;

  02a6b	e9 b8 00 00 00	 jmp	 $LN16@ckd_dasd_e
$LN191@ckd_dasd_e:

; 3121 : 
; 3122 :             /* Read key field */
; 3123 :             rc = ckd_read_key (dev, code, iobuf + size, unitstat);

  02a70	8b 44 24 68	 mov	 eax, DWORD PTR size$[rsp]
  02a74	48 8b 8c 24 f8
	03 00 00	 mov	 rcx, QWORD PTR iobuf$[rsp]
  02a7c	48 03 c8	 add	 rcx, rax
  02a7f	48 8b c1	 mov	 rax, rcx
  02a82	4c 8b 8c 24 08
	04 00 00	 mov	 r9, QWORD PTR unitstat$[rsp]
  02a8a	4c 8b c0	 mov	 r8, rax
  02a8d	0f b6 94 24 c8
	03 00 00	 movzx	 edx, BYTE PTR code$[rsp]
  02a95	48 8b 8c 24 c0
	03 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  02a9d	e8 00 00 00 00	 call	 ckd_read_key
  02aa2	89 44 24 60	 mov	 DWORD PTR rc$[rsp], eax

; 3124 :             if (rc < 0) break;

  02aa6	83 7c 24 60 00	 cmp	 DWORD PTR rc$[rsp], 0
  02aab	7d 02		 jge	 SHORT $LN192@ckd_dasd_e
  02aad	eb 79		 jmp	 SHORT $LN16@ckd_dasd_e
$LN192@ckd_dasd_e:

; 3125 :             size += dev->ckdcurkl;

  02aaf	48 8b 84 24 c0
	03 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  02ab7	8b 80 d4 12 00
	00		 mov	 eax, DWORD PTR [rax+4820]
  02abd	8b 4c 24 68	 mov	 ecx, DWORD PTR size$[rsp]
  02ac1	03 c8		 add	 ecx, eax
  02ac3	8b c1		 mov	 eax, ecx
  02ac5	89 44 24 68	 mov	 DWORD PTR size$[rsp], eax

; 3126 : 
; 3127 :             /* Read data field */
; 3128 :             rc = ckd_read_data (dev, code, iobuf + size, unitstat);

  02ac9	8b 44 24 68	 mov	 eax, DWORD PTR size$[rsp]
  02acd	48 8b 8c 24 f8
	03 00 00	 mov	 rcx, QWORD PTR iobuf$[rsp]
  02ad5	48 03 c8	 add	 rcx, rax
  02ad8	48 8b c1	 mov	 rax, rcx
  02adb	4c 8b 8c 24 08
	04 00 00	 mov	 r9, QWORD PTR unitstat$[rsp]
  02ae3	4c 8b c0	 mov	 r8, rax
  02ae6	0f b6 94 24 c8
	03 00 00	 movzx	 edx, BYTE PTR code$[rsp]
  02aee	48 8b 8c 24 c0
	03 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  02af6	e8 00 00 00 00	 call	 ckd_read_data
  02afb	89 44 24 60	 mov	 DWORD PTR rc$[rsp], eax

; 3129 :             if (rc < 0) break;

  02aff	83 7c 24 60 00	 cmp	 DWORD PTR rc$[rsp], 0
  02b04	7d 02		 jge	 SHORT $LN193@ckd_dasd_e
  02b06	eb 20		 jmp	 SHORT $LN16@ckd_dasd_e
$LN193@ckd_dasd_e:

; 3130 :             size += dev->ckdcurdl;

  02b08	48 8b 84 24 c0
	03 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  02b10	0f b7 80 ea 12
	00 00		 movzx	 eax, WORD PTR [rax+4842]
  02b17	8b 4c 24 68	 mov	 ecx, DWORD PTR size$[rsp]
  02b1b	03 c8		 add	 ecx, eax
  02b1d	8b c1		 mov	 eax, ecx
  02b1f	89 44 24 68	 mov	 DWORD PTR size$[rsp], eax

; 3131 : 
; 3132 :         } /* end for(size) */

  02b23	e9 96 fe ff ff	 jmp	 $LN15@ckd_dasd_e
$LN16@ckd_dasd_e:

; 3133 : 
; 3134 :         /* Set the residual count */
; 3135 :         num = (count < size) ? count : size;

  02b28	8b 44 24 68	 mov	 eax, DWORD PTR size$[rsp]
  02b2c	39 84 24 e0 03
	00 00		 cmp	 DWORD PTR count$[rsp], eax
  02b33	73 10		 jae	 SHORT $LN669@ckd_dasd_e
  02b35	8b 84 24 e0 03
	00 00		 mov	 eax, DWORD PTR count$[rsp]
  02b3c	89 84 24 04 01
	00 00		 mov	 DWORD PTR tv1365[rsp], eax
  02b43	eb 0b		 jmp	 SHORT $LN670@ckd_dasd_e
$LN669@ckd_dasd_e:
  02b45	8b 44 24 68	 mov	 eax, DWORD PTR size$[rsp]
  02b49	89 84 24 04 01
	00 00		 mov	 DWORD PTR tv1365[rsp], eax
$LN670@ckd_dasd_e:
  02b50	8b 84 24 04 01
	00 00		 mov	 eax, DWORD PTR tv1365[rsp]
  02b57	89 44 24 64	 mov	 DWORD PTR num$[rsp], eax

; 3136 :         *residual = count - num;

  02b5b	8b 44 24 64	 mov	 eax, DWORD PTR num$[rsp]
  02b5f	8b 8c 24 e0 03
	00 00		 mov	 ecx, DWORD PTR count$[rsp]
  02b66	2b c8		 sub	 ecx, eax
  02b68	8b c1		 mov	 eax, ecx
  02b6a	48 8b 8c 24 10
	04 00 00	 mov	 rcx, QWORD PTR residual$[rsp]
  02b72	89 01		 mov	 DWORD PTR [rcx], eax

; 3137 :         if (count < size) *more = 1;

  02b74	8b 44 24 68	 mov	 eax, DWORD PTR size$[rsp]
  02b78	39 84 24 e0 03
	00 00		 cmp	 DWORD PTR count$[rsp], eax
  02b7f	73 0b		 jae	 SHORT $LN194@ckd_dasd_e
  02b81	48 8b 84 24 00
	04 00 00	 mov	 rax, QWORD PTR more$[rsp]
  02b89	c6 00 01	 mov	 BYTE PTR [rax], 1
$LN194@ckd_dasd_e:

; 3138 : 
; 3139 :         /* Save size and offset of data not used by this CCW */
; 3140 :         dev->ckdrem = (U16)(size - num);

  02b8c	8b 44 24 64	 mov	 eax, DWORD PTR num$[rsp]
  02b90	8b 4c 24 68	 mov	 ecx, DWORD PTR size$[rsp]
  02b94	2b c8		 sub	 ecx, eax
  02b96	8b c1		 mov	 eax, ecx
  02b98	48 8b 8c 24 c0
	03 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  02ba0	66 89 81 ec 12
	00 00		 mov	 WORD PTR [rcx+4844], ax

; 3141 :         dev->ckdpos = (U16)(       num);

  02ba7	48 8b 84 24 c0
	03 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  02baf	0f b7 4c 24 64	 movzx	 ecx, WORD PTR num$[rsp]
  02bb4	66 89 88 ee 12
	00 00		 mov	 WORD PTR [rax+4846], cx

; 3142 : 
; 3143 :         /* Return normal status */
; 3144 :         *unitstat = CSW_CE | CSW_DE;

  02bbb	48 8b 84 24 08
	04 00 00	 mov	 rax, QWORD PTR unitstat$[rsp]
  02bc3	c6 00 0c	 mov	 BYTE PTR [rax], 12

; 3145 : 
; 3146 :         break;

  02bc6	e9 85 79 00 00	 jmp	 $LN2@ckd_dasd_e
$LN195@ckd_dasd_e:

; 3147 : 
; 3148 :     case 0x27:
; 3149 :     /*---------------------------------------------------------------*/
; 3150 :     /* PERFORM SUBSYSTEM FUNCTION                                    */
; 3151 :     /*---------------------------------------------------------------*/
; 3152 :         /* If the control unit is not a 3990 then CCW code 0x27 is
; 3153 :            treated as a SEEK AND SET SECTOR (Itel 7330 controller) */
; 3154 :         if (dev->ckd3990 == 0)

  02bcb	48 8b 84 24 c0
	03 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  02bd3	8b 80 14 13 00
	00		 mov	 eax, DWORD PTR [rax+4884]
  02bd9	83 e0 01	 and	 eax, 1
  02bdc	85 c0		 test	 eax, eax
  02bde	75 05		 jne	 SHORT $LN196@ckd_dasd_e

; 3155 :             goto seek_0x27;

  02be0	e9 ea 0c 00 00	 jmp	 $seek_0x27$786
$LN196@ckd_dasd_e:

; 3156 : 
; 3157 :         /* Command reject if within the domain of a Locate Record */
; 3158 :         if (dev->ckdlcount > 0)

  02be5	48 8b 84 24 c0
	03 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  02bed	0f b6 80 02 13
	00 00		 movzx	 eax, BYTE PTR [rax+4866]
  02bf4	85 c0		 test	 eax, eax
  02bf6	7e 2f		 jle	 SHORT $LN197@ckd_dasd_e

; 3159 :         {
; 3160 :             ckd_build_sense (dev, SENSE_CR, 0, 0,

  02bf8	c6 44 24 28 02	 mov	 BYTE PTR [rsp+40], 2
  02bfd	c6 44 24 20 00	 mov	 BYTE PTR [rsp+32], 0
  02c02	45 33 c9	 xor	 r9d, r9d
  02c05	45 33 c0	 xor	 r8d, r8d
  02c08	b2 80		 mov	 dl, 128			; 00000080H
  02c0a	48 8b 8c 24 c0
	03 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  02c12	e8 00 00 00 00	 call	 ckd_build_sense

; 3161 :                             FORMAT_0, MESSAGE_2);
; 3162 :             *unitstat = CSW_CE | CSW_DE | CSW_UC;

  02c17	48 8b 84 24 08
	04 00 00	 mov	 rax, QWORD PTR unitstat$[rsp]
  02c1f	c6 00 0e	 mov	 BYTE PTR [rax], 14

; 3163 :             break;

  02c22	e9 29 79 00 00	 jmp	 $LN2@ckd_dasd_e
$LN197@ckd_dasd_e:

; 3164 :         }
; 3165 : 
; 3166 :         /* Use the order code to determine the required count */
; 3167 :         num = (count < 2) ? 2 :

  02c27	83 bc 24 e0 03
	00 00 02	 cmp	 DWORD PTR count$[rsp], 2
  02c2f	73 10		 jae	 SHORT $LN685@ckd_dasd_e
  02c31	c7 84 24 24 01
	00 00 02 00 00
	00		 mov	 DWORD PTR tv1428[rsp], 2
  02c3c	e9 ca 01 00 00	 jmp	 $LN686@ckd_dasd_e
$LN685@ckd_dasd_e:
  02c41	b8 01 00 00 00	 mov	 eax, 1
  02c46	48 6b c0 00	 imul	 rax, rax, 0
  02c4a	48 8b 8c 24 f8
	03 00 00	 mov	 rcx, QWORD PTR iobuf$[rsp]
  02c52	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  02c56	83 f8 10	 cmp	 eax, 16
  02c59	75 10		 jne	 SHORT $LN683@ckd_dasd_e
  02c5b	c7 84 24 20 01
	00 00 0e 00 00
	00		 mov	 DWORD PTR tv1427[rsp], 14
  02c66	e9 92 01 00 00	 jmp	 $LN684@ckd_dasd_e
$LN683@ckd_dasd_e:
  02c6b	b8 01 00 00 00	 mov	 eax, 1
  02c70	48 6b c0 00	 imul	 rax, rax, 0
  02c74	48 8b 8c 24 f8
	03 00 00	 mov	 rcx, QWORD PTR iobuf$[rsp]
  02c7c	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  02c80	83 f8 11	 cmp	 eax, 17
  02c83	0f 84 5b 01 00
	00		 je	 $LN671@ckd_dasd_e
  02c89	b8 01 00 00 00	 mov	 eax, 1
  02c8e	48 6b c0 00	 imul	 rax, rax, 0
  02c92	48 8b 8c 24 f8
	03 00 00	 mov	 rcx, QWORD PTR iobuf$[rsp]
  02c9a	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  02c9e	83 f8 18	 cmp	 eax, 24
  02ca1	0f 84 3d 01 00
	00		 je	 $LN671@ckd_dasd_e
  02ca7	b8 01 00 00 00	 mov	 eax, 1
  02cac	48 6b c0 00	 imul	 rax, rax, 0
  02cb0	48 8b 8c 24 f8
	03 00 00	 mov	 rcx, QWORD PTR iobuf$[rsp]
  02cb8	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  02cbc	83 f8 12	 cmp	 eax, 18
  02cbf	75 10		 jne	 SHORT $LN680@ckd_dasd_e
  02cc1	c7 84 24 18 01
	00 00 05 00 00
	00		 mov	 DWORD PTR tv1425[rsp], 5
  02ccc	e9 03 01 00 00	 jmp	 $LN681@ckd_dasd_e
$LN680@ckd_dasd_e:
  02cd1	b8 01 00 00 00	 mov	 eax, 1
  02cd6	48 6b c0 00	 imul	 rax, rax, 0
  02cda	48 8b 8c 24 f8
	03 00 00	 mov	 rcx, QWORD PTR iobuf$[rsp]
  02ce2	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  02ce6	83 f8 13	 cmp	 eax, 19
  02ce9	0f 84 cc 00 00
	00		 je	 $LN672@ckd_dasd_e
  02cef	b8 01 00 00 00	 mov	 eax, 1
  02cf4	48 6b c0 00	 imul	 rax, rax, 0
  02cf8	48 8b 8c 24 f8
	03 00 00	 mov	 rcx, QWORD PTR iobuf$[rsp]
  02d00	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  02d04	83 f8 14	 cmp	 eax, 20
  02d07	0f 84 ae 00 00
	00		 je	 $LN672@ckd_dasd_e
  02d0d	b8 01 00 00 00	 mov	 eax, 1
  02d12	48 6b c0 00	 imul	 rax, rax, 0
  02d16	48 8b 8c 24 f8
	03 00 00	 mov	 rcx, QWORD PTR iobuf$[rsp]
  02d1e	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  02d22	83 f8 16	 cmp	 eax, 22
  02d25	75 0d		 jne	 SHORT $LN677@ckd_dasd_e
  02d27	c7 84 24 10 01
	00 00 04 00 00
	00		 mov	 DWORD PTR tv1423[rsp], 4
  02d32	eb 77		 jmp	 SHORT $LN678@ckd_dasd_e
$LN677@ckd_dasd_e:
  02d34	b8 01 00 00 00	 mov	 eax, 1
  02d39	48 6b c0 00	 imul	 rax, rax, 0
  02d3d	48 8b 8c 24 f8
	03 00 00	 mov	 rcx, QWORD PTR iobuf$[rsp]
  02d45	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  02d49	83 f8 1d	 cmp	 eax, 29
  02d4c	75 0d		 jne	 SHORT $LN675@ckd_dasd_e
  02d4e	c7 84 24 0c 01
	00 00 42 00 00
	00		 mov	 DWORD PTR tv1422[rsp], 66 ; 00000042H
  02d59	eb 42		 jmp	 SHORT $LN676@ckd_dasd_e
$LN675@ckd_dasd_e:
  02d5b	b8 01 00 00 00	 mov	 eax, 1
  02d60	48 6b c0 00	 imul	 rax, rax, 0
  02d64	48 8b 8c 24 f8
	03 00 00	 mov	 rcx, QWORD PTR iobuf$[rsp]
  02d6c	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  02d70	3d b0 00 00 00	 cmp	 eax, 176		; 000000b0H
  02d75	75 0d		 jne	 SHORT $LN673@ckd_dasd_e
  02d77	c7 84 24 08 01
	00 00 04 00 00
	00		 mov	 DWORD PTR tv1421[rsp], 4
  02d82	eb 0b		 jmp	 SHORT $LN674@ckd_dasd_e
$LN673@ckd_dasd_e:
  02d84	c7 84 24 08 01
	00 00 02 00 00
	00		 mov	 DWORD PTR tv1421[rsp], 2
$LN674@ckd_dasd_e:
  02d8f	8b 84 24 08 01
	00 00		 mov	 eax, DWORD PTR tv1421[rsp]
  02d96	89 84 24 0c 01
	00 00		 mov	 DWORD PTR tv1422[rsp], eax
$LN676@ckd_dasd_e:
  02d9d	8b 84 24 0c 01
	00 00		 mov	 eax, DWORD PTR tv1422[rsp]
  02da4	89 84 24 10 01
	00 00		 mov	 DWORD PTR tv1423[rsp], eax
$LN678@ckd_dasd_e:
  02dab	8b 84 24 10 01
	00 00		 mov	 eax, DWORD PTR tv1423[rsp]
  02db2	89 84 24 14 01
	00 00		 mov	 DWORD PTR tv1424[rsp], eax
  02db9	eb 0b		 jmp	 SHORT $LN679@ckd_dasd_e
$LN672@ckd_dasd_e:
  02dbb	c7 84 24 14 01
	00 00 04 00 00
	00		 mov	 DWORD PTR tv1424[rsp], 4
$LN679@ckd_dasd_e:
  02dc6	8b 84 24 14 01
	00 00		 mov	 eax, DWORD PTR tv1424[rsp]
  02dcd	89 84 24 18 01
	00 00		 mov	 DWORD PTR tv1425[rsp], eax
$LN681@ckd_dasd_e:
  02dd4	8b 84 24 18 01
	00 00		 mov	 eax, DWORD PTR tv1425[rsp]
  02ddb	89 84 24 1c 01
	00 00		 mov	 DWORD PTR tv1426[rsp], eax
  02de2	eb 0b		 jmp	 SHORT $LN682@ckd_dasd_e
$LN671@ckd_dasd_e:
  02de4	c7 84 24 1c 01
	00 00 0c 00 00
	00		 mov	 DWORD PTR tv1426[rsp], 12
$LN682@ckd_dasd_e:
  02def	8b 84 24 1c 01
	00 00		 mov	 eax, DWORD PTR tv1426[rsp]
  02df6	89 84 24 20 01
	00 00		 mov	 DWORD PTR tv1427[rsp], eax
$LN684@ckd_dasd_e:
  02dfd	8b 84 24 20 01
	00 00		 mov	 eax, DWORD PTR tv1427[rsp]
  02e04	89 84 24 24 01
	00 00		 mov	 DWORD PTR tv1428[rsp], eax
$LN686@ckd_dasd_e:
  02e0b	8b 84 24 24 01
	00 00		 mov	 eax, DWORD PTR tv1428[rsp]
  02e12	89 44 24 64	 mov	 DWORD PTR num$[rsp], eax

; 3168 :               (iobuf[0] == 0x10) ? 14 :
; 3169 :               (iobuf[0] == 0x11 || iobuf[0] == 0x18) ? 12 :
; 3170 :               (iobuf[0] == 0x12) ? 5 :
; 3171 :               (iobuf[0] == 0x13 || iobuf[0] == 0x14) ? 4 :
; 3172 :               (iobuf[0] == 0x16) ? 4 :
; 3173 :               (iobuf[0] == 0x1D) ? 66 :
; 3174 :               (iobuf[0] == 0xB0) ? 4 :
; 3175 :               2;
; 3176 : 
; 3177 :         /* Command reject if count is less than required */
; 3178 :         if (count < num)

  02e16	8b 44 24 64	 mov	 eax, DWORD PTR num$[rsp]
  02e1a	39 84 24 e0 03
	00 00		 cmp	 DWORD PTR count$[rsp], eax
  02e21	73 2f		 jae	 SHORT $LN198@ckd_dasd_e

; 3179 :         {
; 3180 :             ckd_build_sense (dev, SENSE_CR, 0, 0,

  02e23	c6 44 24 28 03	 mov	 BYTE PTR [rsp+40], 3
  02e28	c6 44 24 20 00	 mov	 BYTE PTR [rsp+32], 0
  02e2d	45 33 c9	 xor	 r9d, r9d
  02e30	45 33 c0	 xor	 r8d, r8d
  02e33	b2 80		 mov	 dl, 128			; 00000080H
  02e35	48 8b 8c 24 c0
	03 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  02e3d	e8 00 00 00 00	 call	 ckd_build_sense

; 3181 :                             FORMAT_0, MESSAGE_3);
; 3182 :             *unitstat = CSW_CE | CSW_DE | CSW_UC;

  02e42	48 8b 84 24 08
	04 00 00	 mov	 rax, QWORD PTR unitstat$[rsp]
  02e4a	c6 00 0e	 mov	 BYTE PTR [rax], 14

; 3183 :             break;

  02e4d	e9 fe 76 00 00	 jmp	 $LN2@ckd_dasd_e
$LN198@ckd_dasd_e:

; 3184 :         }
; 3185 : 
; 3186 :         /* Set residual count */
; 3187 :         *residual = count - num;

  02e52	8b 44 24 64	 mov	 eax, DWORD PTR num$[rsp]
  02e56	8b 8c 24 e0 03
	00 00		 mov	 ecx, DWORD PTR count$[rsp]
  02e5d	2b c8		 sub	 ecx, eax
  02e5f	8b c1		 mov	 eax, ecx
  02e61	48 8b 8c 24 10
	04 00 00	 mov	 rcx, QWORD PTR residual$[rsp]
  02e69	89 01		 mov	 DWORD PTR [rcx], eax

; 3188 : 
; 3189 : #if 0
; 3190 :         /* Command reject if SSI active */
; 3191 :         if(dev->ckdssi)
; 3192 :         {
; 3193 :             /* Reset SSI condition */
; 3194 :             dev->ckdssi = 0;
; 3195 :             ckd_build_sense (dev, SENSE_CR, 0, 0,
; 3196 :                             FORMAT_0, MESSAGE_F);
; 3197 :             *unitstat = CSW_CE | CSW_DE | CSW_UC;
; 3198 :             break;
; 3199 :         }
; 3200 : #endif
; 3201 : 
; 3202 :         /* Process depending on order code in byte 0 of data */
; 3203 :         switch (iobuf[0]) {

  02e6b	b8 01 00 00 00	 mov	 eax, 1
  02e70	48 6b c0 00	 imul	 rax, rax, 0
  02e74	48 8b 8c 24 f8
	03 00 00	 mov	 rcx, QWORD PTR iobuf$[rsp]
  02e7c	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  02e80	88 84 24 b4 00
	00 00		 mov	 BYTE PTR tv1440[rsp], al
  02e87	80 bc 24 b4 00
	00 00 18	 cmp	 BYTE PTR tv1440[rsp], 24
  02e8f	74 2f		 je	 SHORT $LN199@ckd_dasd_e
  02e91	80 bc 24 b4 00
	00 00 1b	 cmp	 BYTE PTR tv1440[rsp], 27
  02e99	0f 84 34 06 00
	00		 je	 $LN217@ckd_dasd_e
  02e9f	80 bc 24 b4 00
	00 00 1d	 cmp	 BYTE PTR tv1440[rsp], 29
  02ea7	0f 84 23 07 00
	00		 je	 $LN222@ckd_dasd_e
  02ead	80 bc 24 b4 00
	00 00 b0	 cmp	 BYTE PTR tv1440[rsp], 176 ; 000000b0H
  02eb5	0f 84 62 07 00
	00		 je	 $LN224@ckd_dasd_e
  02ebb	e9 be 09 00 00	 jmp	 $LN226@ckd_dasd_e
$LN199@ckd_dasd_e:

; 3204 : 
; 3205 :         case 0x18: /* Prepare for Read Subsystem Data */
; 3206 : 
; 3207 :             // Reject invalid parameter bytes...
; 3208 : 
; 3209 :             if (0
; 3210 :                 //---------------------------------------------------
; 3211 :                 //  Flag byte must be zero
; 3212 :                 //---------------------------------------------------
; 3213 :                 || iobuf[1]
; 3214 : 
; 3215 :                 //---------------------------------------------------
; 3216 :                 //  If byte 6 == 01 then byte 7 can only be 00 or FF.
; 3217 :                 //  For any other byte 6 value, byte 7 must be 00.
; 3218 :                 //---------------------------------------------------
; 3219 : 
; 3220 :                 || (iobuf[6] == 0x01 && (iobuf[7] != 0x00 && iobuf[7] != 0xff))
; 3221 :                 || (iobuf[6] != 0x01 && (iobuf[7] != 0x00))
; 3222 : 
; 3223 :                 //---------------------------------------------------
; 3224 :                 //  If byte 6 == 00, 02, 04, or 06-FF, then
; 3225 :                 //  bytes 8-11 are reserved and must be zero.
; 3226 :                 //---------------------------------------------------
; 3227 :                 || ((0
; 3228 :                      || iobuf[6] == 0x00
; 3229 :                      || iobuf[6] == 0x02
; 3230 :                      || iobuf[6] == 0x04
; 3231 :                      || iobuf[6] >= 0x06    // (06 through FF)
; 3232 :                     )
; 3233 :                     && mem_ne( &iobuf[8], eighthex00, 4 )
; 3234 :                    )
; 3235 : 
; 3236 :                 //---------------------------------------------------
; 3237 :                 //  If byte 6 == 01, then byte 8 must be 00 or 01
; 3238 :                 //  and bytes 9-11 are reserved and must be zero.
; 3239 :                 //---------------------------------------------------
; 3240 :                 || (1
; 3241 :                     && iobuf[6] == 0x01
; 3242 :                     && (0
; 3243 :                         || (iobuf[8] != 0x00 && iobuf[8] != 0x01)
; 3244 :                         || mem_ne( &iobuf[9], eighthex00, 3 )
; 3245 :                        )
; 3246 :                    )
; 3247 : 
; 3248 :                 //---------------------------------------------------
; 3249 :                 //  If byte 6 == 1C, bytes 2-3 must be zero.
; 3250 :                 //  Otherwise bytes 2-5 must always be zero.
; 3251 :                 //---------------------------------------------------
; 3252 :                 || (iobuf[6] == 0x1C && mem_ne( &iobuf[2], eighthex00, 2 ))
; 3253 :                 || (iobuf[6] != 0x1C && mem_ne( &iobuf[2], eighthex00, 4 ))

  02ec0	33 c0		 xor	 eax, eax
  02ec2	85 c0		 test	 eax, eax
  02ec4	0f 85 76 02 00
	00		 jne	 $LN201@ckd_dasd_e
  02eca	b8 01 00 00 00	 mov	 eax, 1
  02ecf	48 6b c0 01	 imul	 rax, rax, 1
  02ed3	48 8b 8c 24 f8
	03 00 00	 mov	 rcx, QWORD PTR iobuf$[rsp]
  02edb	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  02edf	85 c0		 test	 eax, eax
  02ee1	0f 85 59 02 00
	00		 jne	 $LN201@ckd_dasd_e
  02ee7	b8 01 00 00 00	 mov	 eax, 1
  02eec	48 6b c0 06	 imul	 rax, rax, 6
  02ef0	48 8b 8c 24 f8
	03 00 00	 mov	 rcx, QWORD PTR iobuf$[rsp]
  02ef8	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  02efc	83 f8 01	 cmp	 eax, 1
  02eff	75 39		 jne	 SHORT $LN202@ckd_dasd_e
  02f01	b8 01 00 00 00	 mov	 eax, 1
  02f06	48 6b c0 07	 imul	 rax, rax, 7
  02f0a	48 8b 8c 24 f8
	03 00 00	 mov	 rcx, QWORD PTR iobuf$[rsp]
  02f12	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  02f16	85 c0		 test	 eax, eax
  02f18	74 20		 je	 SHORT $LN203@ckd_dasd_e
  02f1a	b8 01 00 00 00	 mov	 eax, 1
  02f1f	48 6b c0 07	 imul	 rax, rax, 7
  02f23	48 8b 8c 24 f8
	03 00 00	 mov	 rcx, QWORD PTR iobuf$[rsp]
  02f2b	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  02f2f	3d ff 00 00 00	 cmp	 eax, 255		; 000000ffH
  02f34	0f 85 06 02 00
	00		 jne	 $LN201@ckd_dasd_e
$LN203@ckd_dasd_e:
$LN202@ckd_dasd_e:
  02f3a	b8 01 00 00 00	 mov	 eax, 1
  02f3f	48 6b c0 06	 imul	 rax, rax, 6
  02f43	48 8b 8c 24 f8
	03 00 00	 mov	 rcx, QWORD PTR iobuf$[rsp]
  02f4b	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  02f4f	83 f8 01	 cmp	 eax, 1
  02f52	74 1d		 je	 SHORT $LN204@ckd_dasd_e
  02f54	b8 01 00 00 00	 mov	 eax, 1
  02f59	48 6b c0 07	 imul	 rax, rax, 7
  02f5d	48 8b 8c 24 f8
	03 00 00	 mov	 rcx, QWORD PTR iobuf$[rsp]
  02f65	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  02f69	85 c0		 test	 eax, eax
  02f6b	0f 85 cf 01 00
	00		 jne	 $LN201@ckd_dasd_e
$LN204@ckd_dasd_e:
  02f71	33 c0		 xor	 eax, eax
  02f73	85 c0		 test	 eax, eax
  02f75	75 67		 jne	 SHORT $LN206@ckd_dasd_e
  02f77	b8 01 00 00 00	 mov	 eax, 1
  02f7c	48 6b c0 06	 imul	 rax, rax, 6
  02f80	48 8b 8c 24 f8
	03 00 00	 mov	 rcx, QWORD PTR iobuf$[rsp]
  02f88	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  02f8c	85 c0		 test	 eax, eax
  02f8e	74 4e		 je	 SHORT $LN206@ckd_dasd_e
  02f90	b8 01 00 00 00	 mov	 eax, 1
  02f95	48 6b c0 06	 imul	 rax, rax, 6
  02f99	48 8b 8c 24 f8
	03 00 00	 mov	 rcx, QWORD PTR iobuf$[rsp]
  02fa1	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  02fa5	83 f8 02	 cmp	 eax, 2
  02fa8	74 34		 je	 SHORT $LN206@ckd_dasd_e
  02faa	b8 01 00 00 00	 mov	 eax, 1
  02faf	48 6b c0 06	 imul	 rax, rax, 6
  02fb3	48 8b 8c 24 f8
	03 00 00	 mov	 rcx, QWORD PTR iobuf$[rsp]
  02fbb	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  02fbf	83 f8 04	 cmp	 eax, 4
  02fc2	74 1a		 je	 SHORT $LN206@ckd_dasd_e
  02fc4	b8 01 00 00 00	 mov	 eax, 1
  02fc9	48 6b c0 06	 imul	 rax, rax, 6
  02fcd	48 8b 8c 24 f8
	03 00 00	 mov	 rcx, QWORD PTR iobuf$[rsp]
  02fd5	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  02fd9	83 f8 06	 cmp	 eax, 6
  02fdc	7c 34		 jl	 SHORT $LN205@ckd_dasd_e
$LN206@ckd_dasd_e:
  02fde	b8 01 00 00 00	 mov	 eax, 1
  02fe3	48 6b c0 08	 imul	 rax, rax, 8
  02fe7	48 8b 8c 24 f8
	03 00 00	 mov	 rcx, QWORD PTR iobuf$[rsp]
  02fef	48 03 c8	 add	 rcx, rax
  02ff2	48 8b c1	 mov	 rax, rcx
  02ff5	41 b8 04 00 00
	00		 mov	 r8d, 4
  02ffb	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:eighthex00
  03002	48 8b c8	 mov	 rcx, rax
  03005	e8 00 00 00 00	 call	 memcmp
  0300a	85 c0		 test	 eax, eax
  0300c	0f 85 2e 01 00
	00		 jne	 $LN201@ckd_dasd_e
$LN205@ckd_dasd_e:
  03012	33 c0		 xor	 eax, eax
  03014	83 f8 01	 cmp	 eax, 1
  03017	0f 84 8f 00 00
	00		 je	 $LN207@ckd_dasd_e
  0301d	b8 01 00 00 00	 mov	 eax, 1
  03022	48 6b c0 06	 imul	 rax, rax, 6
  03026	48 8b 8c 24 f8
	03 00 00	 mov	 rcx, QWORD PTR iobuf$[rsp]
  0302e	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  03032	83 f8 01	 cmp	 eax, 1
  03035	75 75		 jne	 SHORT $LN207@ckd_dasd_e
  03037	33 c0		 xor	 eax, eax
  03039	85 c0		 test	 eax, eax
  0303b	0f 85 ff 00 00
	00		 jne	 $LN201@ckd_dasd_e
  03041	b8 01 00 00 00	 mov	 eax, 1
  03046	48 6b c0 08	 imul	 rax, rax, 8
  0304a	48 8b 8c 24 f8
	03 00 00	 mov	 rcx, QWORD PTR iobuf$[rsp]
  03052	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  03056	85 c0		 test	 eax, eax
  03058	74 1e		 je	 SHORT $LN208@ckd_dasd_e
  0305a	b8 01 00 00 00	 mov	 eax, 1
  0305f	48 6b c0 08	 imul	 rax, rax, 8
  03063	48 8b 8c 24 f8
	03 00 00	 mov	 rcx, QWORD PTR iobuf$[rsp]
  0306b	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  0306f	83 f8 01	 cmp	 eax, 1
  03072	0f 85 c8 00 00
	00		 jne	 $LN201@ckd_dasd_e
$LN208@ckd_dasd_e:
  03078	b8 01 00 00 00	 mov	 eax, 1
  0307d	48 6b c0 09	 imul	 rax, rax, 9
  03081	48 8b 8c 24 f8
	03 00 00	 mov	 rcx, QWORD PTR iobuf$[rsp]
  03089	48 03 c8	 add	 rcx, rax
  0308c	48 8b c1	 mov	 rax, rcx
  0308f	41 b8 03 00 00
	00		 mov	 r8d, 3
  03095	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:eighthex00
  0309c	48 8b c8	 mov	 rcx, rax
  0309f	e8 00 00 00 00	 call	 memcmp
  030a4	85 c0		 test	 eax, eax
  030a6	0f 85 94 00 00
	00		 jne	 $LN201@ckd_dasd_e
$LN207@ckd_dasd_e:
  030ac	b8 01 00 00 00	 mov	 eax, 1
  030b1	48 6b c0 06	 imul	 rax, rax, 6
  030b5	48 8b 8c 24 f8
	03 00 00	 mov	 rcx, QWORD PTR iobuf$[rsp]
  030bd	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  030c1	83 f8 1c	 cmp	 eax, 28
  030c4	75 30		 jne	 SHORT $LN209@ckd_dasd_e
  030c6	b8 01 00 00 00	 mov	 eax, 1
  030cb	48 6b c0 02	 imul	 rax, rax, 2
  030cf	48 8b 8c 24 f8
	03 00 00	 mov	 rcx, QWORD PTR iobuf$[rsp]
  030d7	48 03 c8	 add	 rcx, rax
  030da	48 8b c1	 mov	 rax, rcx
  030dd	41 b8 02 00 00
	00		 mov	 r8d, 2
  030e3	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:eighthex00
  030ea	48 8b c8	 mov	 rcx, rax
  030ed	e8 00 00 00 00	 call	 memcmp
  030f2	85 c0		 test	 eax, eax
  030f4	75 4a		 jne	 SHORT $LN201@ckd_dasd_e
$LN209@ckd_dasd_e:
  030f6	b8 01 00 00 00	 mov	 eax, 1
  030fb	48 6b c0 06	 imul	 rax, rax, 6
  030ff	48 8b 8c 24 f8
	03 00 00	 mov	 rcx, QWORD PTR iobuf$[rsp]
  03107	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  0310b	83 f8 1c	 cmp	 eax, 28
  0310e	74 5f		 je	 SHORT $LN200@ckd_dasd_e
  03110	b8 01 00 00 00	 mov	 eax, 1
  03115	48 6b c0 02	 imul	 rax, rax, 2
  03119	48 8b 8c 24 f8
	03 00 00	 mov	 rcx, QWORD PTR iobuf$[rsp]
  03121	48 03 c8	 add	 rcx, rax
  03124	48 8b c1	 mov	 rax, rcx
  03127	41 b8 04 00 00
	00		 mov	 r8d, 4
  0312d	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:eighthex00
  03134	48 8b c8	 mov	 rcx, rax
  03137	e8 00 00 00 00	 call	 memcmp
  0313c	85 c0		 test	 eax, eax
  0313e	74 2f		 je	 SHORT $LN200@ckd_dasd_e
$LN201@ckd_dasd_e:

; 3254 :             )
; 3255 :             {
; 3256 :                 ckd_build_sense (dev, SENSE_CR, 0, 0,

  03140	c6 44 24 28 04	 mov	 BYTE PTR [rsp+40], 4
  03145	c6 44 24 20 00	 mov	 BYTE PTR [rsp+32], 0
  0314a	45 33 c9	 xor	 r9d, r9d
  0314d	45 33 c0	 xor	 r8d, r8d
  03150	b2 80		 mov	 dl, 128			; 00000080H
  03152	48 8b 8c 24 c0
	03 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  0315a	e8 00 00 00 00	 call	 ckd_build_sense

; 3257 :                                 FORMAT_0, MESSAGE_4);
; 3258 :                 *unitstat = CSW_CE | CSW_DE | CSW_UC;

  0315f	48 8b 84 24 08
	04 00 00	 mov	 rax, QWORD PTR unitstat$[rsp]
  03167	c6 00 0e	 mov	 BYTE PTR [rax], 14

; 3259 :                 break;

  0316a	e9 39 07 00 00	 jmp	 $LN18@ckd_dasd_e
$LN200@ckd_dasd_e:

; 3260 :             }
; 3261 : 
; 3262 :             /* Process suborder code in byte 6 of data */
; 3263 :             switch (iobuf[6]) {

  0316f	b8 01 00 00 00	 mov	 eax, 1
  03174	48 6b c0 06	 imul	 rax, rax, 6
  03178	48 8b 8c 24 f8
	03 00 00	 mov	 rcx, QWORD PTR iobuf$[rsp]
  03180	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  03184	89 84 24 28 01
	00 00		 mov	 DWORD PTR tv1550[rsp], eax
  0318b	83 bc 24 28 01
	00 00 41	 cmp	 DWORD PTR tv1550[rsp], 65 ; 00000041H
  03193	0f 87 0b 03 00
	00		 ja	 $LN216@ckd_dasd_e
  03199	48 63 84 24 28
	01 00 00	 movsxd	 rax, DWORD PTR tv1550[rsp]
  031a1	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__ImageBase
  031a8	0f b6 84 01 00
	00 00 00	 movzx	 eax, BYTE PTR $LN781@ckd_dasd_e[rcx+rax]
  031b0	8b 84 81 00 00
	00 00		 mov	 eax, DWORD PTR $LN782@ckd_dasd_e[rcx+rax*4]
  031b7	48 03 c1	 add	 rax, rcx
  031ba	ff e0		 jmp	 rax
$LN210@ckd_dasd_e:

; 3264 : 
; 3265 :             case 0x00: /* Storage path status */
; 3266 :                 /* Prepare storage path status record */
; 3267 :                 memset (iobuf, 0, 16);

  031bc	48 8b bc 24 f8
	03 00 00	 mov	 rdi, QWORD PTR iobuf$[rsp]
  031c4	33 c0		 xor	 eax, eax
  031c6	b9 10 00 00 00	 mov	 ecx, 16
  031cb	f3 aa		 rep stosb

; 3268 :                 iobuf[0] = 0xC0; /* Storage path valid and attached */

  031cd	b8 01 00 00 00	 mov	 eax, 1
  031d2	48 6b c0 00	 imul	 rax, rax, 0
  031d6	48 8b 8c 24 f8
	03 00 00	 mov	 rcx, QWORD PTR iobuf$[rsp]
  031de	c6 04 01 c0	 mov	 BYTE PTR [rcx+rax], 192	; 000000c0H

; 3269 :                 iobuf[1] = 0x80; /* Logical paths configured bitmap */

  031e2	b8 01 00 00 00	 mov	 eax, 1
  031e7	48 6b c0 01	 imul	 rax, rax, 1
  031eb	48 8b 8c 24 f8
	03 00 00	 mov	 rcx, QWORD PTR iobuf$[rsp]
  031f3	c6 04 01 80	 mov	 BYTE PTR [rcx+rax], 128	; 00000080H

; 3270 :                 iobuf[2] = 0x00; /* Channels enabled bitmap */

  031f7	b8 01 00 00 00	 mov	 eax, 1
  031fc	48 6b c0 02	 imul	 rax, rax, 2
  03200	48 8b 8c 24 f8
	03 00 00	 mov	 rcx, QWORD PTR iobuf$[rsp]
  03208	c6 04 01 00	 mov	 BYTE PTR [rcx+rax], 0

; 3271 :                 iobuf[3] = 0x00; /* Channels fenced bitmap */

  0320c	b8 01 00 00 00	 mov	 eax, 1
  03211	48 6b c0 03	 imul	 rax, rax, 3
  03215	48 8b 8c 24 f8
	03 00 00	 mov	 rcx, QWORD PTR iobuf$[rsp]
  0321d	c6 04 01 00	 mov	 BYTE PTR [rcx+rax], 0

; 3272 :                 iobuf[16] = 1;   /* #logical paths thru cluster 0 */

  03221	b8 01 00 00 00	 mov	 eax, 1
  03226	48 6b c0 10	 imul	 rax, rax, 16
  0322a	48 8b 8c 24 f8
	03 00 00	 mov	 rcx, QWORD PTR iobuf$[rsp]
  03232	c6 04 01 01	 mov	 BYTE PTR [rcx+rax], 1

; 3273 : 
; 3274 :                 /* Indicate the length of subsystem data prepared */
; 3275 :                 dev->ckdssdlen = (dev->ckdcu->code==0x15) ? 24 : 16;

  03236	48 8b 84 24 c0
	03 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  0323e	48 8b 80 a8 12
	00 00		 mov	 rax, QWORD PTR [rax+4776]
  03245	0f b6 40 0b	 movzx	 eax, BYTE PTR [rax+11]
  03249	83 f8 15	 cmp	 eax, 21
  0324c	75 0d		 jne	 SHORT $LN687@ckd_dasd_e
  0324e	c7 84 24 2c 01
	00 00 18 00 00
	00		 mov	 DWORD PTR tv1570[rsp], 24
  03259	eb 0b		 jmp	 SHORT $LN688@ckd_dasd_e
$LN687@ckd_dasd_e:
  0325b	c7 84 24 2c 01
	00 00 10 00 00
	00		 mov	 DWORD PTR tv1570[rsp], 16
$LN688@ckd_dasd_e:
  03266	48 8b 84 24 c0
	03 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  0326e	0f b7 8c 24 2c
	01 00 00	 movzx	 ecx, WORD PTR tv1570[rsp]
  03276	66 89 88 1a 13
	00 00		 mov	 WORD PTR [rax+4890], cx

; 3276 :                 break;

  0327d	e9 4c 02 00 00	 jmp	 $LN20@ckd_dasd_e
$LN211@ckd_dasd_e:

; 3277 : 
; 3278 :             case 0x01: /* Subsystem statistics */
; 3279 :                 /* Indicate the length of subsystem data prepared */
; 3280 :                 dev->ckdssdlen = (iobuf[8]==0x00) ? 96 : 192;

  03282	b8 01 00 00 00	 mov	 eax, 1
  03287	48 6b c0 08	 imul	 rax, rax, 8
  0328b	48 8b 8c 24 f8
	03 00 00	 mov	 rcx, QWORD PTR iobuf$[rsp]
  03293	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  03297	85 c0		 test	 eax, eax
  03299	75 0d		 jne	 SHORT $LN689@ckd_dasd_e
  0329b	c7 84 24 30 01
	00 00 60 00 00
	00		 mov	 DWORD PTR tv1577[rsp], 96 ; 00000060H
  032a6	eb 0b		 jmp	 SHORT $LN690@ckd_dasd_e
$LN689@ckd_dasd_e:
  032a8	c7 84 24 30 01
	00 00 c0 00 00
	00		 mov	 DWORD PTR tv1577[rsp], 192 ; 000000c0H
$LN690@ckd_dasd_e:
  032b3	48 8b 84 24 c0
	03 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  032bb	0f b7 8c 24 30
	01 00 00	 movzx	 ecx, WORD PTR tv1577[rsp]
  032c3	66 89 88 1a 13
	00 00		 mov	 WORD PTR [rax+4890], cx

; 3281 : 
; 3282 :                 /* Prepare subsystem statistics record */
; 3283 :                 memset (iobuf, 0, dev->ckdssdlen);

  032ca	48 8b 84 24 c0
	03 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  032d2	0f b7 80 1a 13
	00 00		 movzx	 eax, WORD PTR [rax+4890]
  032d9	48 89 84 24 18
	02 00 00	 mov	 QWORD PTR tv1582[rsp], rax
  032e1	48 8b bc 24 f8
	03 00 00	 mov	 rdi, QWORD PTR iobuf$[rsp]
  032e9	33 c0		 xor	 eax, eax
  032eb	48 8b 8c 24 18
	02 00 00	 mov	 rcx, QWORD PTR tv1582[rsp]
  032f3	f3 aa		 rep stosb

; 3284 :                 iobuf[1] = dev->devnum & 0xFF;

  032f5	48 8b 84 24 c0
	03 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  032fd	0f b7 40 48	 movzx	 eax, WORD PTR [rax+72]
  03301	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  03306	b9 01 00 00 00	 mov	 ecx, 1
  0330b	48 6b c9 01	 imul	 rcx, rcx, 1
  0330f	48 8b 94 24 f8
	03 00 00	 mov	 rdx, QWORD PTR iobuf$[rsp]
  03317	88 04 0a	 mov	 BYTE PTR [rdx+rcx], al

; 3285 :                 store_hw( &iobuf[94], myssid );

  0331a	48 8b 84 24 c0
	03 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  03322	0f b7 40 48	 movzx	 eax, WORD PTR [rax+72]
  03326	83 e0 e0	 and	 eax, -32		; ffffffffffffffe0H
  03329	0f b7 c8	 movzx	 ecx, ax
  0332c	e8 00 00 00 00	 call	 _byteswap_ushort
  03331	b9 01 00 00 00	 mov	 ecx, 1
  03336	48 6b c9 5e	 imul	 rcx, rcx, 94		; 0000005eH
  0333a	48 8b 94 24 f8
	03 00 00	 mov	 rdx, QWORD PTR iobuf$[rsp]
  03342	48 03 d1	 add	 rdx, rcx
  03345	48 8b ca	 mov	 rcx, rdx
  03348	0f b7 d0	 movzx	 edx, ax
  0334b	e8 00 00 00 00	 call	 store_hw_noswap

; 3286 :                 break;

  03350	e9 79 01 00 00	 jmp	 $LN20@ckd_dasd_e
$LN212@ckd_dasd_e:

; 3287 : 
; 3288 :             case 0x03:  /* Read attention message for this path-group for
; 3289 :                            the addressed device Return a "No Message"
; 3290 :                            message */
; 3291 :                 /*------------------------------------------------------*/
; 3292 :                 /* PROGRAMMING NOTE: 2013/01/09 Fish                    */
; 3293 :                 /* According to GA32-0274 IBM 3990,9390 Storage Control */
; 3294 :                 /* Reference the Read Attention Message response should */
; 3295 :                 /* be 11 bytes for a 3990-6 with Message Format byte 2  */
; 3296 :                 /* being 0x02 (3990-6/ESS message) with byte 9 and 10   */
; 3297 :                 /* containing additional response information such as a */
; 3298 :                 /* bit map indicating which physical subsystem SPs are  */
; 3299 :                 /* caching. Since Hercules doesn't support a compatible */
; 3300 :                 /* form of caching and an equivalent SP caching bit map */
; 3301 :                 /* isn't maintained we return a 9 byte response instead */
; 3302 :                 /* with byte 2 = 0x00 (No Message) since an 11 byte re- */
; 3303 :                 /* sponse with zeros in bytes 9 and 10 causes problems  */
; 3304 :                 /* with certain operating systems. Returning a 9-byte   */
; 3305 :                 /* response with byte 2 = 0x00 instead is therefore the */
; 3306 :                 /* safest approach to take since most operating systems */
; 3307 :                 /* seem to accept such a response without complaint.    */
; 3308 :                 /*------------------------------------------------------*/
; 3309 :                 iobuf[0] = 0x00;               /* Message...            */

  03355	b8 01 00 00 00	 mov	 eax, 1
  0335a	48 6b c0 00	 imul	 rax, rax, 0
  0335e	48 8b 8c 24 f8
	03 00 00	 mov	 rcx, QWORD PTR iobuf$[rsp]
  03366	c6 04 01 00	 mov	 BYTE PTR [rcx+rax], 0

; 3310 :                 iobuf[1] = 0x09;               /* ...Length             */

  0336a	b8 01 00 00 00	 mov	 eax, 1
  0336f	48 6b c0 01	 imul	 rax, rax, 1
  03373	48 8b 8c 24 f8
	03 00 00	 mov	 rcx, QWORD PTR iobuf$[rsp]
  0337b	c6 04 01 09	 mov	 BYTE PTR [rcx+rax], 9

; 3311 :                 iobuf[2] = 0x00;               /* Format: "No message"  */

  0337f	b8 01 00 00 00	 mov	 eax, 1
  03384	48 6b c0 02	 imul	 rax, rax, 2
  03388	48 8b 8c 24 f8
	03 00 00	 mov	 rcx, QWORD PTR iobuf$[rsp]
  03390	c6 04 01 00	 mov	 BYTE PTR [rcx+rax], 0

; 3312 :                 iobuf[3] = 0x00;               /* Message code: n/a     */

  03394	b8 01 00 00 00	 mov	 eax, 1
  03399	48 6b c0 03	 imul	 rax, rax, 3
  0339d	48 8b 8c 24 f8
	03 00 00	 mov	 rcx, QWORD PTR iobuf$[rsp]
  033a5	c6 04 01 00	 mov	 BYTE PTR [rcx+rax], 0

; 3313 :                 memcpy (iobuf+4, iobuf+8, 4);  /* Copy same message Id

  033a9	48 8b 84 24 f8
	03 00 00	 mov	 rax, QWORD PTR iobuf$[rsp]
  033b1	48 8b 8c 24 f8
	03 00 00	 mov	 rcx, QWORD PTR iobuf$[rsp]
  033b9	8b 49 08	 mov	 ecx, DWORD PTR [rcx+8]
  033bc	89 48 04	 mov	 DWORD PTR [rax+4], ecx

; 3314 :                                                   from bytes 8-11       */
; 3315 :                 iobuf[8] = 0x00;               /* Flags = 00            */

  033bf	b8 01 00 00 00	 mov	 eax, 1
  033c4	48 6b c0 08	 imul	 rax, rax, 8
  033c8	48 8b 8c 24 f8
	03 00 00	 mov	 rcx, QWORD PTR iobuf$[rsp]
  033d0	c6 04 01 00	 mov	 BYTE PTR [rcx+rax], 0

; 3316 :                 dev->ckdssdlen = 9;            /* Len of prepared data  */

  033d4	b8 09 00 00 00	 mov	 eax, 9
  033d9	48 8b 8c 24 c0
	03 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  033e1	66 89 81 1a 13
	00 00		 mov	 WORD PTR [rcx+4890], ax

; 3317 :                 break;

  033e8	e9 e1 00 00 00	 jmp	 $LN20@ckd_dasd_e
$LN213@ckd_dasd_e:

; 3318 : 
; 3319 :             case 0x0E: /* Unit address configuration */
; 3320 :                 /* Prepare unit address configuration record */
; 3321 :                 memset (iobuf, 0, 512);

  033ed	48 8b bc 24 f8
	03 00 00	 mov	 rdi, QWORD PTR iobuf$[rsp]
  033f5	33 c0		 xor	 eax, eax
  033f7	b9 00 02 00 00	 mov	 ecx, 512		; 00000200H
  033fc	f3 aa		 rep stosb

; 3322 :                 /* 256 pairs (UA type, base UA) */
; 3323 : 
; 3324 :                 /* Indicate the length of subsystem data prepared */
; 3325 :                 dev->ckdssdlen = 512;

  033fe	b8 00 02 00 00	 mov	 eax, 512		; 00000200H
  03403	48 8b 8c 24 c0
	03 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  0340b	66 89 81 1a 13
	00 00		 mov	 WORD PTR [rcx+4890], ax

; 3326 :                 break;

  03412	e9 b7 00 00 00	 jmp	 $LN20@ckd_dasd_e
$LN214@ckd_dasd_e:

; 3327 : 
; 3328 :             case 0x1C: /* Query Host Access */
; 3329 :                 /*------------------------------------------------------*/
; 3330 :                 /* PROGRAMMING NOTE: 2017-02-14 Ian                     */
; 3331 :                 /*                                                      */
; 3332 :                 /* IBM OA40720 PROBLEM DESCRIPTION says:-               */
; 3333 :                 /*                                                      */
; 3334 :                 /*   This provides new function support for DS8870      */
; 3335 :                 /*   Query Host Access function                         */
; 3336 :                 /*                                                      */
; 3337 :                 /*   The MVS System DEVSERV QDASD command was enhanced  */
; 3338 :                 /*   to support a new keyword 'QHA' which allows user   */
; 3339 :                 /*   to query host access information for a CKD volume. */
; 3340 :                 /*   The host access information includes a list of     */
; 3341 :                 /*   Path Group IDs or systems that have a device       */
; 3342 :                 /*   grouped (online) and/or ungrouped (offline) or     */
; 3343 :                 /*   Reserved. In addition, the Path Status Flags, z/OS */
; 3344 :                 /*   Sysplex name, and Maximum number of Cylinders per  */
; 3345 :                 /*   Volume supported by the host are also returned for */
; 3346 :                 /*   each Path Group entry.                             */
; 3347 :                 /*                                                      */
; 3348 :                 /* Linux support for QHA was added to kernel 4.6 with   */
; 3349 :                 /* patch 8712731 in March 2016.                         */
; 3350 :                 /*                                                      */
; 3351 :                 /* iobuf[4]-[5] contains the device being queried.      */
; 3352 :                 /* Other than the Linux kernel source (see structures   */
; 3353 :                 /* dasd_psf_query_host_access and                       */
; 3354 :                 /* dasd_ckd_host_information in                         */
; 3355 :                 /* drivers/s390/block/dasd_eckd.h) I haven't discovered */
; 3356 :                 /* any documentation explaining the contents of the     */
; 3357 :                 /* response.                                            */
; 3358 :                 /*------------------------------------------------------*/
; 3359 : 
; 3360 : #define QHA_RESPONSE_SIZE  16+4+32   /* 16 = the first 16-bytes of the  */
; 3361 :                                      /*      dasd_psf_query_host_access */
; 3362 :                                      /*      structure.                 */
; 3363 :                                      /*  4 = the first 4-bytes of the   */
; 3364 :                                      /*      dasd_ckd_host_information  */
; 3365 :                                      /*      structure.                 */
; 3366 :                                      /* 32 = an arbitrary entry length  */
; 3367 : 
; 3368 :                 /* Indicate the length of prepared host access response */
; 3369 :                 dev->ckdssdlen = QHA_RESPONSE_SIZE;

  03417	b8 34 00 00 00	 mov	 eax, 52			; 00000034H
  0341c	48 8b 8c 24 c0
	03 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  03424	66 89 81 1a 13
	00 00		 mov	 WORD PTR [rcx+4890], ax

; 3370 : 
; 3371 :                 /* Prepare host access response */
; 3372 :                 memset (iobuf, 0, QHA_RESPONSE_SIZE);

  0342b	48 8b bc 24 f8
	03 00 00	 mov	 rdi, QWORD PTR iobuf$[rsp]
  03433	33 c0		 xor	 eax, eax
  03435	b9 34 00 00 00	 mov	 ecx, 52			; 00000034H
  0343a	f3 aa		 rep stosb

; 3373 : 
; 3374 :                 iobuf[17] = 0x20;              /* Entry size = 32       */

  0343c	b8 01 00 00 00	 mov	 eax, 1
  03441	48 6b c0 11	 imul	 rax, rax, 17
  03445	48 8b 8c 24 f8
	03 00 00	 mov	 rcx, QWORD PTR iobuf$[rsp]
  0344d	c6 04 01 20	 mov	 BYTE PTR [rcx+rax], 32	; 00000020H

; 3375 :                 iobuf[18] = 0x00;              /* Entry...              */

  03451	b8 01 00 00 00	 mov	 eax, 1
  03456	48 6b c0 12	 imul	 rax, rax, 18
  0345a	48 8b 8c 24 f8
	03 00 00	 mov	 rcx, QWORD PTR iobuf$[rsp]
  03462	c6 04 01 00	 mov	 BYTE PTR [rcx+rax], 0

; 3376 :                 iobuf[19] = 0x01;              /* ...count = 1          */

  03466	b8 01 00 00 00	 mov	 eax, 1
  0346b	48 6b c0 13	 imul	 rax, rax, 19
  0346f	48 8b 8c 24 f8
	03 00 00	 mov	 rcx, QWORD PTR iobuf$[rsp]
  03477	c6 04 01 01	 mov	 BYTE PTR [rcx+rax], 1

; 3377 : 
; 3378 :                 break;

  0347b	eb 51		 jmp	 SHORT $LN20@ckd_dasd_e
$LN215@ckd_dasd_e:

; 3379 : 
; 3380 :             case 0x41: /* Feature codes */
; 3381 :                 /* Prepare feature codes record */
; 3382 :                 memset (iobuf, 0, 256);

  0347d	48 8b bc 24 f8
	03 00 00	 mov	 rdi, QWORD PTR iobuf$[rsp]
  03485	33 c0		 xor	 eax, eax
  03487	b9 00 01 00 00	 mov	 ecx, 256		; 00000100H
  0348c	f3 aa		 rep stosb

; 3383 : 
; 3384 :                 /* Indicate the length of subsystem data prepared */
; 3385 :                 dev->ckdssdlen = 256;

  0348e	b8 00 01 00 00	 mov	 eax, 256		; 00000100H
  03493	48 8b 8c 24 c0
	03 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  0349b	66 89 81 1a 13
	00 00		 mov	 WORD PTR [rcx+4890], ax

; 3386 :                 break;

  034a2	eb 2a		 jmp	 SHORT $LN20@ckd_dasd_e
$LN216@ckd_dasd_e:

; 3387 : 
; 3388 :             default: /* Unknown suborder code */
; 3389 :                 ckd_build_sense (dev, SENSE_CR, 0, 0,

  034a4	c6 44 24 28 04	 mov	 BYTE PTR [rsp+40], 4
  034a9	c6 44 24 20 00	 mov	 BYTE PTR [rsp+32], 0
  034ae	45 33 c9	 xor	 r9d, r9d
  034b1	45 33 c0	 xor	 r8d, r8d
  034b4	b2 80		 mov	 dl, 128			; 00000080H
  034b6	48 8b 8c 24 c0
	03 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  034be	e8 00 00 00 00	 call	 ckd_build_sense

; 3390 :                                 FORMAT_0, MESSAGE_4);
; 3391 :                 *unitstat = CSW_CE | CSW_DE | CSW_UC;

  034c3	48 8b 84 24 08
	04 00 00	 mov	 rax, QWORD PTR unitstat$[rsp]
  034cb	c6 00 0e	 mov	 BYTE PTR [rax], 14
$LN20@ckd_dasd_e:

; 3392 : 
; 3393 :             } /* end switch(iobuf[6]) */
; 3394 : 
; 3395 :             break;

  034ce	e9 d5 03 00 00	 jmp	 $LN18@ckd_dasd_e
$LN217@ckd_dasd_e:

; 3396 : 
; 3397 :         case 0x1B: /* Set Special Intercept Condition */
; 3398 : 
; 3399 :             /* Command reject if not the first command in the chain
; 3400 :                or indeed if preceded by any command at all apart from
; 3401 :                Suspend Multipath Reconnection */
; 3402 :             if (ccwseq > 1
; 3403 :                 || (chained && prevcode != 0x5B))

  034d3	83 bc 24 f0 03
	00 00 01	 cmp	 DWORD PTR ccwseq$[rsp], 1
  034db	7f 19		 jg	 SHORT $LN219@ckd_dasd_e
  034dd	0f b6 84 24 d8
	03 00 00	 movzx	 eax, BYTE PTR chained$[rsp]
  034e5	85 c0		 test	 eax, eax
  034e7	74 3c		 je	 SHORT $LN218@ckd_dasd_e
  034e9	0f b6 84 24 e8
	03 00 00	 movzx	 eax, BYTE PTR prevcode$[rsp]
  034f1	83 f8 5b	 cmp	 eax, 91			; 0000005bH
  034f4	74 2f		 je	 SHORT $LN218@ckd_dasd_e
$LN219@ckd_dasd_e:

; 3404 :             {
; 3405 :                 ckd_build_sense (dev, SENSE_CR, 0, 0,

  034f6	c6 44 24 28 02	 mov	 BYTE PTR [rsp+40], 2
  034fb	c6 44 24 20 00	 mov	 BYTE PTR [rsp+32], 0
  03500	45 33 c9	 xor	 r9d, r9d
  03503	45 33 c0	 xor	 r8d, r8d
  03506	b2 80		 mov	 dl, 128			; 00000080H
  03508	48 8b 8c 24 c0
	03 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  03510	e8 00 00 00 00	 call	 ckd_build_sense

; 3406 :                                 FORMAT_0, MESSAGE_2);
; 3407 :                 *unitstat = CSW_CE | CSW_DE | CSW_UC;

  03515	48 8b 84 24 08
	04 00 00	 mov	 rax, QWORD PTR unitstat$[rsp]
  0351d	c6 00 0e	 mov	 BYTE PTR [rax], 14

; 3408 :                 break;

  03520	e9 83 03 00 00	 jmp	 $LN18@ckd_dasd_e
$LN218@ckd_dasd_e:

; 3409 :             }
; 3410 : 
; 3411 :             /* Command reject if flag byte is not zero */
; 3412 :             if (iobuf[1] != 0x00)

  03525	b8 01 00 00 00	 mov	 eax, 1
  0352a	48 6b c0 01	 imul	 rax, rax, 1
  0352e	48 8b 8c 24 f8
	03 00 00	 mov	 rcx, QWORD PTR iobuf$[rsp]
  03536	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  0353a	85 c0		 test	 eax, eax
  0353c	74 2f		 je	 SHORT $LN220@ckd_dasd_e

; 3413 :             {
; 3414 :                 ckd_build_sense (dev, SENSE_CR, 0, 0,

  0353e	c6 44 24 28 04	 mov	 BYTE PTR [rsp+40], 4
  03543	c6 44 24 20 00	 mov	 BYTE PTR [rsp+32], 0
  03548	45 33 c9	 xor	 r9d, r9d
  0354b	45 33 c0	 xor	 r8d, r8d
  0354e	b2 80		 mov	 dl, 128			; 00000080H
  03550	48 8b 8c 24 c0
	03 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  03558	e8 00 00 00 00	 call	 ckd_build_sense

; 3415 :                                 FORMAT_0, MESSAGE_4);
; 3416 :                 *unitstat = CSW_CE | CSW_DE | CSW_UC;

  0355d	48 8b 84 24 08
	04 00 00	 mov	 rax, QWORD PTR unitstat$[rsp]
  03565	c6 00 0e	 mov	 BYTE PTR [rax], 14

; 3417 :                 break;

  03568	e9 3b 03 00 00	 jmp	 $LN18@ckd_dasd_e
$LN220@ckd_dasd_e:

; 3418 :             }
; 3419 : 
; 3420 :             /* Command reject if any command is chained from this command */
; 3421 :             if (flags & CCW_FLAGS_CC)

  0356d	0f b6 84 24 d0
	03 00 00	 movzx	 eax, BYTE PTR flags$[rsp]
  03575	83 e0 40	 and	 eax, 64			; 00000040H
  03578	85 c0		 test	 eax, eax
  0357a	74 2f		 je	 SHORT $LN221@ckd_dasd_e

; 3422 :             {
; 3423 :                 ckd_build_sense (dev, SENSE_CR, 0, 0,

  0357c	c6 44 24 28 02	 mov	 BYTE PTR [rsp+40], 2
  03581	c6 44 24 20 00	 mov	 BYTE PTR [rsp+32], 0
  03586	45 33 c9	 xor	 r9d, r9d
  03589	45 33 c0	 xor	 r8d, r8d
  0358c	b2 80		 mov	 dl, 128			; 00000080H
  0358e	48 8b 8c 24 c0
	03 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  03596	e8 00 00 00 00	 call	 ckd_build_sense

; 3424 :                                 FORMAT_0, MESSAGE_2);
; 3425 :                 *unitstat = CSW_CE | CSW_DE | CSW_UC;

  0359b	48 8b 84 24 08
	04 00 00	 mov	 rax, QWORD PTR unitstat$[rsp]
  035a3	c6 00 0e	 mov	 BYTE PTR [rax], 14

; 3426 :                 break;

  035a6	e9 fd 02 00 00	 jmp	 $LN18@ckd_dasd_e
$LN221@ckd_dasd_e:

; 3427 :             }
; 3428 : 
; 3429 :             /* Mark Set Special Intercept inactive */
; 3430 :             dev->ckdssi = 1;

  035ab	48 8b 84 24 c0
	03 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  035b3	8b 80 14 13 00
	00		 mov	 eax, DWORD PTR [rax+4884]
  035b9	0f ba e8 10	 bts	 eax, 16
  035bd	48 8b 8c 24 c0
	03 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  035c5	89 81 14 13 00
	00		 mov	 DWORD PTR [rcx+4884], eax

; 3431 : 
; 3432 :             break;

  035cb	e9 d8 02 00 00	 jmp	 $LN18@ckd_dasd_e
$LN222@ckd_dasd_e:

; 3433 : 
; 3434 :         case 0x1D: /* Set Subsystem Characteristics */
; 3435 : 
; 3436 :             /* Command reject if flag byte is not zero */
; 3437 :             if (iobuf[1] != 0x00)

  035d0	b8 01 00 00 00	 mov	 eax, 1
  035d5	48 6b c0 01	 imul	 rax, rax, 1
  035d9	48 8b 8c 24 f8
	03 00 00	 mov	 rcx, QWORD PTR iobuf$[rsp]
  035e1	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  035e5	85 c0		 test	 eax, eax
  035e7	74 2f		 je	 SHORT $LN223@ckd_dasd_e

; 3438 :             {
; 3439 :                 ckd_build_sense (dev, SENSE_CR, 0, 0,

  035e9	c6 44 24 28 04	 mov	 BYTE PTR [rsp+40], 4
  035ee	c6 44 24 20 00	 mov	 BYTE PTR [rsp+32], 0
  035f3	45 33 c9	 xor	 r9d, r9d
  035f6	45 33 c0	 xor	 r8d, r8d
  035f9	b2 80		 mov	 dl, 128			; 00000080H
  035fb	48 8b 8c 24 c0
	03 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  03603	e8 00 00 00 00	 call	 ckd_build_sense

; 3440 :                                 FORMAT_0, MESSAGE_4);
; 3441 :                 *unitstat = CSW_CE | CSW_DE | CSW_UC;

  03608	48 8b 84 24 08
	04 00 00	 mov	 rax, QWORD PTR unitstat$[rsp]
  03610	c6 00 0e	 mov	 BYTE PTR [rax], 14

; 3442 :                 break;

  03613	e9 90 02 00 00	 jmp	 $LN18@ckd_dasd_e
$LN223@ckd_dasd_e:

; 3443 :             }
; 3444 : 
; 3445 :             break;

  03618	e9 8b 02 00 00	 jmp	 $LN18@ckd_dasd_e
$LN224@ckd_dasd_e:

; 3446 : 
; 3447 :         case 0xB0: /* Set Interface Identifier */
; 3448 : 
; 3449 :             /* Command reject if flag byte bits 0-5 are not zero
; 3450 :                or bits 6-7 are 11 or 10 */
; 3451 :             if ((iobuf[1] & 0xFE) != 0x00)

  0361d	b8 01 00 00 00	 mov	 eax, 1
  03622	48 6b c0 01	 imul	 rax, rax, 1
  03626	48 8b 8c 24 f8
	03 00 00	 mov	 rcx, QWORD PTR iobuf$[rsp]
  0362e	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  03632	25 fe 00 00 00	 and	 eax, 254		; 000000feH
  03637	85 c0		 test	 eax, eax
  03639	74 2f		 je	 SHORT $LN225@ckd_dasd_e

; 3452 :             {
; 3453 :                 ckd_build_sense (dev, SENSE_CR, 0, 0,

  0363b	c6 44 24 28 04	 mov	 BYTE PTR [rsp+40], 4
  03640	c6 44 24 20 00	 mov	 BYTE PTR [rsp+32], 0
  03645	45 33 c9	 xor	 r9d, r9d
  03648	45 33 c0	 xor	 r8d, r8d
  0364b	b2 80		 mov	 dl, 128			; 00000080H
  0364d	48 8b 8c 24 c0
	03 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  03655	e8 00 00 00 00	 call	 ckd_build_sense

; 3454 :                                 FORMAT_0, MESSAGE_4);
; 3455 :                 *unitstat = CSW_CE | CSW_DE | CSW_UC;

  0365a	48 8b 84 24 08
	04 00 00	 mov	 rax, QWORD PTR unitstat$[rsp]
  03662	c6 00 0e	 mov	 BYTE PTR [rax], 14

; 3456 :                 break;

  03665	e9 3e 02 00 00	 jmp	 $LN18@ckd_dasd_e
$LN225@ckd_dasd_e:

; 3457 :             }
; 3458 : 
; 3459 :             /* Prepare subsystem data (node descriptor record) */
; 3460 :             memset (iobuf, 0, 96);

  0366a	48 8b bc 24 f8
	03 00 00	 mov	 rdi, QWORD PTR iobuf$[rsp]
  03672	33 c0		 xor	 eax, eax
  03674	b9 60 00 00 00	 mov	 ecx, 96			; 00000060H
  03679	f3 aa		 rep stosb

; 3461 : 
; 3462 :             /* Bytes 0-31 contain the subsystem node descriptor */
; 3463 :             store_fw(&iobuf[0], 0x00000100);

  0367b	b9 00 01 00 00	 mov	 ecx, 256		; 00000100H
  03680	e8 00 00 00 00	 call	 _byteswap_ulong
  03685	b9 01 00 00 00	 mov	 ecx, 1
  0368a	48 6b c9 00	 imul	 rcx, rcx, 0
  0368e	48 8b 94 24 f8
	03 00 00	 mov	 rdx, QWORD PTR iobuf$[rsp]
  03696	48 03 d1	 add	 rdx, rcx
  03699	48 8b ca	 mov	 rcx, rdx
  0369c	8b d0		 mov	 edx, eax
  0369e	e8 00 00 00 00	 call	 store_fw_noswap

; 3464 :             sprintf ((char *)&iobuf[4], "00%4.4X   HRCZZ000000000001",

  036a3	48 8b 84 24 c0
	03 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  036ab	48 8b 80 a8 12
	00 00		 mov	 rax, QWORD PTR [rax+4776]
  036b2	0f b7 40 08	 movzx	 eax, WORD PTR [rax+8]
  036b6	b9 01 00 00 00	 mov	 ecx, 1
  036bb	48 6b c9 04	 imul	 rcx, rcx, 4
  036bf	48 8b 94 24 f8
	03 00 00	 mov	 rdx, QWORD PTR iobuf$[rsp]
  036c7	48 03 d1	 add	 rdx, rcx
  036ca	48 8b ca	 mov	 rcx, rdx
  036cd	44 8b c0	 mov	 r8d, eax
  036d0	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG171858
  036d7	e8 00 00 00 00	 call	 sprintf

; 3465 :                                 dev->ckdcu->devt);
; 3466 :             for (i = 4; i < 30; i++)

  036dc	c7 84 24 a4 00
	00 00 04 00 00
	00		 mov	 DWORD PTR i$[rsp], 4
  036e7	eb 10		 jmp	 SHORT $LN24@ckd_dasd_e
$LN22@ckd_dasd_e:
  036e9	8b 84 24 a4 00
	00 00		 mov	 eax, DWORD PTR i$[rsp]
  036f0	ff c0		 inc	 eax
  036f2	89 84 24 a4 00
	00 00		 mov	 DWORD PTR i$[rsp], eax
$LN24@ckd_dasd_e:
  036f9	83 bc 24 a4 00
	00 00 1e	 cmp	 DWORD PTR i$[rsp], 30
  03701	7d 2f		 jge	 SHORT $LN23@ckd_dasd_e

; 3467 :                 iobuf[i] = host_to_guest(iobuf[i]);

  03703	48 63 84 24 a4
	00 00 00	 movsxd	 rax, DWORD PTR i$[rsp]
  0370b	48 8b 8c 24 f8
	03 00 00	 mov	 rcx, QWORD PTR iobuf$[rsp]
  03713	0f b6 0c 01	 movzx	 ecx, BYTE PTR [rcx+rax]
  03717	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_host_to_guest
  0371d	48 63 8c 24 a4
	00 00 00	 movsxd	 rcx, DWORD PTR i$[rsp]
  03725	48 8b 94 24 f8
	03 00 00	 mov	 rdx, QWORD PTR iobuf$[rsp]
  0372d	88 04 0a	 mov	 BYTE PTR [rdx+rcx], al
  03730	eb b7		 jmp	 SHORT $LN22@ckd_dasd_e
$LN23@ckd_dasd_e:

; 3468 : 
; 3469 :             /* Bytes 32-63 contain node qualifier data */
; 3470 :             store_fw(&iobuf[32],0x00000000); // flags+zeros

  03732	33 c9		 xor	 ecx, ecx
  03734	e8 00 00 00 00	 call	 _byteswap_ulong
  03739	b9 01 00 00 00	 mov	 ecx, 1
  0373e	48 6b c9 20	 imul	 rcx, rcx, 32		; 00000020H
  03742	48 8b 94 24 f8
	03 00 00	 mov	 rdx, QWORD PTR iobuf$[rsp]
  0374a	48 03 d1	 add	 rdx, rcx
  0374d	48 8b ca	 mov	 rcx, rdx
  03750	8b d0		 mov	 edx, eax
  03752	e8 00 00 00 00	 call	 store_fw_noswap

; 3471 :             store_fw(&iobuf[40],0x00000000);

  03757	33 c9		 xor	 ecx, ecx
  03759	e8 00 00 00 00	 call	 _byteswap_ulong
  0375e	b9 01 00 00 00	 mov	 ecx, 1
  03763	48 6b c9 28	 imul	 rcx, rcx, 40		; 00000028H
  03767	48 8b 94 24 f8
	03 00 00	 mov	 rdx, QWORD PTR iobuf$[rsp]
  0376f	48 03 d1	 add	 rdx, rcx
  03772	48 8b ca	 mov	 rcx, rdx
  03775	8b d0		 mov	 edx, eax
  03777	e8 00 00 00 00	 call	 store_fw_noswap

; 3472 :             store_fw(&iobuf[40],0x41010000); // start range

  0377c	b9 00 00 01 41	 mov	 ecx, 1090584576		; 41010000H
  03781	e8 00 00 00 00	 call	 _byteswap_ulong
  03786	b9 01 00 00 00	 mov	 ecx, 1
  0378b	48 6b c9 28	 imul	 rcx, rcx, 40		; 00000028H
  0378f	48 8b 94 24 f8
	03 00 00	 mov	 rdx, QWORD PTR iobuf$[rsp]
  03797	48 03 d1	 add	 rdx, rcx
  0379a	48 8b ca	 mov	 rcx, rdx
  0379d	8b d0		 mov	 edx, eax
  0379f	e8 00 00 00 00	 call	 store_fw_noswap

; 3473 :             store_fw(&iobuf[44],0x41010001); // end range

  037a4	b9 01 00 01 41	 mov	 ecx, 1090584577		; 41010001H
  037a9	e8 00 00 00 00	 call	 _byteswap_ulong
  037ae	b9 01 00 00 00	 mov	 ecx, 1
  037b3	48 6b c9 2c	 imul	 rcx, rcx, 44		; 0000002cH
  037b7	48 8b 94 24 f8
	03 00 00	 mov	 rdx, QWORD PTR iobuf$[rsp]
  037bf	48 03 d1	 add	 rdx, rcx
  037c2	48 8b ca	 mov	 rcx, rdx
  037c5	8b d0		 mov	 edx, eax
  037c7	e8 00 00 00 00	 call	 store_fw_noswap

; 3474 :             store_fw(&iobuf[48],0x41010010); // start range

  037cc	b9 10 00 01 41	 mov	 ecx, 1090584592		; 41010010H
  037d1	e8 00 00 00 00	 call	 _byteswap_ulong
  037d6	b9 01 00 00 00	 mov	 ecx, 1
  037db	48 6b c9 30	 imul	 rcx, rcx, 48		; 00000030H
  037df	48 8b 94 24 f8
	03 00 00	 mov	 rdx, QWORD PTR iobuf$[rsp]
  037e7	48 03 d1	 add	 rdx, rcx
  037ea	48 8b ca	 mov	 rcx, rdx
  037ed	8b d0		 mov	 edx, eax
  037ef	e8 00 00 00 00	 call	 store_fw_noswap

; 3475 :             store_fw(&iobuf[52],0x41010011); // end range

  037f4	b9 11 00 01 41	 mov	 ecx, 1090584593		; 41010011H
  037f9	e8 00 00 00 00	 call	 _byteswap_ulong
  037fe	b9 01 00 00 00	 mov	 ecx, 1
  03803	48 6b c9 34	 imul	 rcx, rcx, 52		; 00000034H
  03807	48 8b 94 24 f8
	03 00 00	 mov	 rdx, QWORD PTR iobuf$[rsp]
  0380f	48 03 d1	 add	 rdx, rcx
  03812	48 8b ca	 mov	 rcx, rdx
  03815	8b d0		 mov	 edx, eax
  03817	e8 00 00 00 00	 call	 store_fw_noswap

; 3476 : 
; 3477 :             /* Bytes 64-95 contain a 2nd subsystem node descriptor */
; 3478 :             iobuf[64] = 0x00;

  0381c	b8 01 00 00 00	 mov	 eax, 1
  03821	48 6b c0 40	 imul	 rax, rax, 64		; 00000040H
  03825	48 8b 8c 24 f8
	03 00 00	 mov	 rcx, QWORD PTR iobuf$[rsp]
  0382d	c6 04 01 00	 mov	 BYTE PTR [rcx+rax], 0

; 3479 : 
; 3480 :             /* Indicate the length of subsystem data prepared */
; 3481 :             dev->ckdssdlen = (iobuf[1] & 0x03) ? 32 : 96;

  03831	b8 01 00 00 00	 mov	 eax, 1
  03836	48 6b c0 01	 imul	 rax, rax, 1
  0383a	48 8b 8c 24 f8
	03 00 00	 mov	 rcx, QWORD PTR iobuf$[rsp]
  03842	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  03846	83 e0 03	 and	 eax, 3
  03849	85 c0		 test	 eax, eax
  0384b	74 0d		 je	 SHORT $LN691@ckd_dasd_e
  0384d	c7 84 24 34 01
	00 00 20 00 00
	00		 mov	 DWORD PTR tv1775[rsp], 32 ; 00000020H
  03858	eb 0b		 jmp	 SHORT $LN692@ckd_dasd_e
$LN691@ckd_dasd_e:
  0385a	c7 84 24 34 01
	00 00 60 00 00
	00		 mov	 DWORD PTR tv1775[rsp], 96 ; 00000060H
$LN692@ckd_dasd_e:
  03865	48 8b 84 24 c0
	03 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  0386d	0f b7 8c 24 34
	01 00 00	 movzx	 ecx, WORD PTR tv1775[rsp]
  03875	66 89 88 1a 13
	00 00		 mov	 WORD PTR [rax+4890], cx

; 3482 : 
; 3483 :             break;

  0387c	eb 2a		 jmp	 SHORT $LN18@ckd_dasd_e
$LN226@ckd_dasd_e:

; 3484 : 
; 3485 :         default: /* Unknown order code */
; 3486 : 
; 3487 :             ckd_build_sense (dev, SENSE_CR, 0, 0,

  0387e	c6 44 24 28 04	 mov	 BYTE PTR [rsp+40], 4
  03883	c6 44 24 20 00	 mov	 BYTE PTR [rsp+32], 0
  03888	45 33 c9	 xor	 r9d, r9d
  0388b	45 33 c0	 xor	 r8d, r8d
  0388e	b2 80		 mov	 dl, 128			; 00000080H
  03890	48 8b 8c 24 c0
	03 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  03898	e8 00 00 00 00	 call	 ckd_build_sense

; 3488 :                             FORMAT_0, MESSAGE_4);
; 3489 :             *unitstat = CSW_CE | CSW_DE | CSW_UC;

  0389d	48 8b 84 24 08
	04 00 00	 mov	 rax, QWORD PTR unitstat$[rsp]
  038a5	c6 00 0e	 mov	 BYTE PTR [rax], 14
$LN18@ckd_dasd_e:

; 3490 : 
; 3491 :         } /* end switch(iobuf[0]) */
; 3492 : 
; 3493 :         /* Exit if unit check has already been set */
; 3494 :         if (*unitstat & CSW_UC)

  038a8	48 8b 84 24 08
	04 00 00	 mov	 rax, QWORD PTR unitstat$[rsp]
  038b0	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  038b3	83 e0 02	 and	 eax, 2
  038b6	85 c0		 test	 eax, eax
  038b8	74 05		 je	 SHORT $LN227@ckd_dasd_e

; 3495 :             break;

  038ba	e9 91 6c 00 00	 jmp	 $LN2@ckd_dasd_e
$LN227@ckd_dasd_e:

; 3496 : 
; 3497 :         /* Return normal status */
; 3498 :         *unitstat = CSW_CE | CSW_DE;

  038bf	48 8b 84 24 08
	04 00 00	 mov	 rax, QWORD PTR unitstat$[rsp]
  038c7	c6 00 0c	 mov	 BYTE PTR [rax], 12

; 3499 : 
; 3500 :         break;

  038ca	e9 81 6c 00 00	 jmp	 $LN2@ckd_dasd_e
$seek_0x27$786:
$LN228@ckd_dasd_e:
$LN229@ckd_dasd_e:
$LN230@ckd_dasd_e:

; 3501 : 
; 3502 :     seek_0x27: /* SEEK AND SET SECTOR (Itel 7330 controller only) */
; 3503 :     case 0x07: /* SEEK */
; 3504 :     case 0x0B: /* SEEK CYLINDER */
; 3505 :     case 0x1B: /* SEEK HEAD */
; 3506 :     /*---------------------------------------------------------------*/
; 3507 :     /* SEEK                                                          */
; 3508 :     /*---------------------------------------------------------------*/
; 3509 :         /* Command reject if within the domain of a Locate Record */
; 3510 :         if (dev->ckdlcount > 0)

  038cf	48 8b 84 24 c0
	03 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  038d7	0f b6 80 02 13
	00 00		 movzx	 eax, BYTE PTR [rax+4866]
  038de	85 c0		 test	 eax, eax
  038e0	7e 2f		 jle	 SHORT $LN231@ckd_dasd_e

; 3511 :         {
; 3512 :             ckd_build_sense (dev, SENSE_CR, 0, 0,

  038e2	c6 44 24 28 02	 mov	 BYTE PTR [rsp+40], 2
  038e7	c6 44 24 20 00	 mov	 BYTE PTR [rsp+32], 0
  038ec	45 33 c9	 xor	 r9d, r9d
  038ef	45 33 c0	 xor	 r8d, r8d
  038f2	b2 80		 mov	 dl, 128			; 00000080H
  038f4	48 8b 8c 24 c0
	03 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  038fc	e8 00 00 00 00	 call	 ckd_build_sense

; 3513 :                             FORMAT_0, MESSAGE_2);
; 3514 :             *unitstat = CSW_CE | CSW_DE | CSW_UC;

  03901	48 8b 84 24 08
	04 00 00	 mov	 rax, QWORD PTR unitstat$[rsp]
  03909	c6 00 0e	 mov	 BYTE PTR [rax], 14

; 3515 :             break;

  0390c	e9 3f 6c 00 00	 jmp	 $LN2@ckd_dasd_e
$LN231@ckd_dasd_e:

; 3516 :         }
; 3517 : 
; 3518 :         /* For 3990, command reject if Seek Head not preceded by Seek,
; 3519 :            Seek Cylinder, Locate Record, Read IPL, or Recalibrate */
; 3520 :         if (code == 0x1B && dev->ckd3990
; 3521 :             && dev->ckdseek == 0 && dev->ckdskcyl == 0
; 3522 :             && dev->ckdlocat == 0 && dev->ckdrdipl == 0
; 3523 :             && dev->ckdrecal == 0)

  03911	0f b6 84 24 c8
	03 00 00	 movzx	 eax, BYTE PTR code$[rsp]
  03919	83 f8 1b	 cmp	 eax, 27
  0391c	0f 85 c4 00 00
	00		 jne	 $LN232@ckd_dasd_e
  03922	48 8b 84 24 c0
	03 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  0392a	8b 80 14 13 00
	00		 mov	 eax, DWORD PTR [rax+4884]
  03930	83 e0 01	 and	 eax, 1
  03933	85 c0		 test	 eax, eax
  03935	0f 84 ab 00 00
	00		 je	 $LN232@ckd_dasd_e
  0393b	48 8b 84 24 c0
	03 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  03943	8b 80 14 13 00
	00		 mov	 eax, DWORD PTR [rax+4884]
  03949	c1 e8 06	 shr	 eax, 6
  0394c	83 e0 01	 and	 eax, 1
  0394f	85 c0		 test	 eax, eax
  03951	0f 85 8f 00 00
	00		 jne	 $LN232@ckd_dasd_e
  03957	48 8b 84 24 c0
	03 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  0395f	8b 80 14 13 00
	00		 mov	 eax, DWORD PTR [rax+4884]
  03965	c1 e8 07	 shr	 eax, 7
  03968	83 e0 01	 and	 eax, 1
  0396b	85 c0		 test	 eax, eax
  0396d	75 77		 jne	 SHORT $LN232@ckd_dasd_e
  0396f	48 8b 84 24 c0
	03 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  03977	8b 80 14 13 00
	00		 mov	 eax, DWORD PTR [rax+4884]
  0397d	c1 e8 03	 shr	 eax, 3
  03980	83 e0 01	 and	 eax, 1
  03983	85 c0		 test	 eax, eax
  03985	75 5f		 jne	 SHORT $LN232@ckd_dasd_e
  03987	48 8b 84 24 c0
	03 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  0398f	8b 80 14 13 00
	00		 mov	 eax, DWORD PTR [rax+4884]
  03995	c1 e8 09	 shr	 eax, 9
  03998	83 e0 01	 and	 eax, 1
  0399b	85 c0		 test	 eax, eax
  0399d	75 47		 jne	 SHORT $LN232@ckd_dasd_e
  0399f	48 8b 84 24 c0
	03 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  039a7	8b 80 14 13 00
	00		 mov	 eax, DWORD PTR [rax+4884]
  039ad	c1 e8 08	 shr	 eax, 8
  039b0	83 e0 01	 and	 eax, 1
  039b3	85 c0		 test	 eax, eax
  039b5	75 2f		 jne	 SHORT $LN232@ckd_dasd_e

; 3524 :         {
; 3525 :             ckd_build_sense (dev, SENSE_CR, 0, 0,

  039b7	c6 44 24 28 02	 mov	 BYTE PTR [rsp+40], 2
  039bc	c6 44 24 20 00	 mov	 BYTE PTR [rsp+32], 0
  039c1	45 33 c9	 xor	 r9d, r9d
  039c4	45 33 c0	 xor	 r8d, r8d
  039c7	b2 80		 mov	 dl, 128			; 00000080H
  039c9	48 8b 8c 24 c0
	03 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  039d1	e8 00 00 00 00	 call	 ckd_build_sense

; 3526 :                             FORMAT_0, MESSAGE_2);
; 3527 :             *unitstat = CSW_CE | CSW_DE | CSW_UC;

  039d6	48 8b 84 24 08
	04 00 00	 mov	 rax, QWORD PTR unitstat$[rsp]
  039de	c6 00 0e	 mov	 BYTE PTR [rax], 14

; 3528 :             break;

  039e1	e9 6a 6b 00 00	 jmp	 $LN2@ckd_dasd_e
$LN232@ckd_dasd_e:

; 3529 :         }
; 3530 : 
; 3531 :         /* File protected if file mask does not allow requested seek */
; 3532 :         if (((code == 0x07 || code == 0x27)
; 3533 :             && (dev->ckdfmask & CKDMASK_SKCTL) != CKDMASK_SKCTL_ALLSKR)
; 3534 :            || (code == 0x0B
; 3535 :             && (dev->ckdfmask & CKDMASK_SKCTL) != CKDMASK_SKCTL_ALLSKR
; 3536 :             && (dev->ckdfmask & CKDMASK_SKCTL) != CKDMASK_SKCTL_CYLHD)
; 3537 :            || (code == 0x1B

  039e6	0f b6 84 24 c8
	03 00 00	 movzx	 eax, BYTE PTR code$[rsp]
  039ee	83 f8 07	 cmp	 eax, 7
  039f1	74 0d		 je	 SHORT $LN236@ckd_dasd_e
  039f3	0f b6 84 24 c8
	03 00 00	 movzx	 eax, BYTE PTR code$[rsp]
  039fb	83 f8 27	 cmp	 eax, 39			; 00000027H
  039fe	75 16		 jne	 SHORT $LN235@ckd_dasd_e
$LN236@ckd_dasd_e:
  03a00	48 8b 84 24 c0
	03 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  03a08	0f b6 80 fa 12
	00 00		 movzx	 eax, BYTE PTR [rax+4858]
  03a0f	83 e0 18	 and	 eax, 24
  03a12	85 c0		 test	 eax, eax
  03a14	75 5e		 jne	 SHORT $LN234@ckd_dasd_e
$LN235@ckd_dasd_e:
  03a16	0f b6 84 24 c8
	03 00 00	 movzx	 eax, BYTE PTR code$[rsp]
  03a1e	83 f8 0b	 cmp	 eax, 11
  03a21	75 2d		 jne	 SHORT $LN237@ckd_dasd_e
  03a23	48 8b 84 24 c0
	03 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  03a2b	0f b6 80 fa 12
	00 00		 movzx	 eax, BYTE PTR [rax+4858]
  03a32	83 e0 18	 and	 eax, 24
  03a35	85 c0		 test	 eax, eax
  03a37	74 17		 je	 SHORT $LN237@ckd_dasd_e
  03a39	48 8b 84 24 c0
	03 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  03a41	0f b6 80 fa 12
	00 00		 movzx	 eax, BYTE PTR [rax+4858]
  03a48	83 e0 18	 and	 eax, 24
  03a4b	83 f8 08	 cmp	 eax, 8
  03a4e	75 24		 jne	 SHORT $LN234@ckd_dasd_e
$LN237@ckd_dasd_e:
  03a50	0f b6 84 24 c8
	03 00 00	 movzx	 eax, BYTE PTR code$[rsp]
  03a58	83 f8 1b	 cmp	 eax, 27
  03a5b	75 46		 jne	 SHORT $LN233@ckd_dasd_e
  03a5d	48 8b 84 24 c0
	03 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  03a65	0f b6 80 fa 12
	00 00		 movzx	 eax, BYTE PTR [rax+4858]
  03a6c	83 e0 18	 and	 eax, 24
  03a6f	83 f8 18	 cmp	 eax, 24
  03a72	75 2f		 jne	 SHORT $LN233@ckd_dasd_e
$LN234@ckd_dasd_e:

; 3538 :             && (dev->ckdfmask & CKDMASK_SKCTL) == CKDMASK_SKCTL_INHSMT))
; 3539 :         {
; 3540 :             ckd_build_sense (dev, 0, SENSE1_FP, 0, 0, 0);

  03a74	c6 44 24 28 00	 mov	 BYTE PTR [rsp+40], 0
  03a79	c6 44 24 20 00	 mov	 BYTE PTR [rsp+32], 0
  03a7e	45 33 c9	 xor	 r9d, r9d
  03a81	41 b0 04	 mov	 r8b, 4
  03a84	33 d2		 xor	 edx, edx
  03a86	48 8b 8c 24 c0
	03 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  03a8e	e8 00 00 00 00	 call	 ckd_build_sense

; 3541 :             *unitstat = CSW_CE | CSW_DE | CSW_UC;

  03a93	48 8b 84 24 08
	04 00 00	 mov	 rax, QWORD PTR unitstat$[rsp]
  03a9b	c6 00 0e	 mov	 BYTE PTR [rax], 14

; 3542 :             break;

  03a9e	e9 ad 6a 00 00	 jmp	 $LN2@ckd_dasd_e
$LN233@ckd_dasd_e:

; 3543 :         }
; 3544 : 
; 3545 :         /* Set residual count */
; 3546 :         num = (count < 6) ? count : 6;

  03aa3	83 bc 24 e0 03
	00 00 06	 cmp	 DWORD PTR count$[rsp], 6
  03aab	73 10		 jae	 SHORT $LN693@ckd_dasd_e
  03aad	8b 84 24 e0 03
	00 00		 mov	 eax, DWORD PTR count$[rsp]
  03ab4	89 84 24 38 01
	00 00		 mov	 DWORD PTR tv1863[rsp], eax
  03abb	eb 0b		 jmp	 SHORT $LN694@ckd_dasd_e
$LN693@ckd_dasd_e:
  03abd	c7 84 24 38 01
	00 00 06 00 00
	00		 mov	 DWORD PTR tv1863[rsp], 6
$LN694@ckd_dasd_e:
  03ac8	8b 84 24 38 01
	00 00		 mov	 eax, DWORD PTR tv1863[rsp]
  03acf	89 44 24 64	 mov	 DWORD PTR num$[rsp], eax

; 3547 :         *residual = count - num;

  03ad3	8b 44 24 64	 mov	 eax, DWORD PTR num$[rsp]
  03ad7	8b 8c 24 e0 03
	00 00		 mov	 ecx, DWORD PTR count$[rsp]
  03ade	2b c8		 sub	 ecx, eax
  03ae0	8b c1		 mov	 eax, ecx
  03ae2	48 8b 8c 24 10
	04 00 00	 mov	 rcx, QWORD PTR residual$[rsp]
  03aea	89 01		 mov	 DWORD PTR [rcx], eax

; 3548 : 
; 3549 :         /* Command reject if count is less than 6 */
; 3550 :         if (count < 6)

  03aec	83 bc 24 e0 03
	00 00 06	 cmp	 DWORD PTR count$[rsp], 6
  03af4	73 2f		 jae	 SHORT $LN238@ckd_dasd_e

; 3551 :         {
; 3552 :             ckd_build_sense (dev, SENSE_CR, 0, 0,

  03af6	c6 44 24 28 03	 mov	 BYTE PTR [rsp+40], 3
  03afb	c6 44 24 20 00	 mov	 BYTE PTR [rsp+32], 0
  03b00	45 33 c9	 xor	 r9d, r9d
  03b03	45 33 c0	 xor	 r8d, r8d
  03b06	b2 80		 mov	 dl, 128			; 00000080H
  03b08	48 8b 8c 24 c0
	03 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  03b10	e8 00 00 00 00	 call	 ckd_build_sense

; 3553 :                             FORMAT_0, MESSAGE_3);
; 3554 :             *unitstat = CSW_CE | CSW_DE | CSW_UC;

  03b15	48 8b 84 24 08
	04 00 00	 mov	 rax, QWORD PTR unitstat$[rsp]
  03b1d	c6 00 0e	 mov	 BYTE PTR [rax], 14

; 3555 :             break;

  03b20	e9 2b 6a 00 00	 jmp	 $LN2@ckd_dasd_e
$LN238@ckd_dasd_e:

; 3556 :         }
; 3557 : 
; 3558 :         /* Extract the BBCCHH seek address from the I/O buffer */
; 3559 :         bin = (iobuf[0] << 8) | iobuf[1];

  03b25	b8 01 00 00 00	 mov	 eax, 1
  03b2a	48 6b c0 00	 imul	 rax, rax, 0
  03b2e	48 8b 8c 24 f8
	03 00 00	 mov	 rcx, QWORD PTR iobuf$[rsp]
  03b36	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  03b3a	c1 e0 08	 shl	 eax, 8
  03b3d	b9 01 00 00 00	 mov	 ecx, 1
  03b42	48 6b c9 01	 imul	 rcx, rcx, 1
  03b46	48 8b 94 24 f8
	03 00 00	 mov	 rdx, QWORD PTR iobuf$[rsp]
  03b4e	0f b6 0c 0a	 movzx	 ecx, BYTE PTR [rdx+rcx]
  03b52	0b c1		 or	 eax, ecx
  03b54	88 84 24 ac 00
	00 00		 mov	 BYTE PTR bin$[rsp], al

; 3560 :         cyl = (iobuf[2] << 8) | iobuf[3];

  03b5b	b8 01 00 00 00	 mov	 eax, 1
  03b60	48 6b c0 02	 imul	 rax, rax, 2
  03b64	48 8b 8c 24 f8
	03 00 00	 mov	 rcx, QWORD PTR iobuf$[rsp]
  03b6c	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  03b70	c1 e0 08	 shl	 eax, 8
  03b73	b9 01 00 00 00	 mov	 ecx, 1
  03b78	48 6b c9 03	 imul	 rcx, rcx, 3
  03b7c	48 8b 94 24 f8
	03 00 00	 mov	 rdx, QWORD PTR iobuf$[rsp]
  03b84	0f b6 0c 0a	 movzx	 ecx, BYTE PTR [rdx+rcx]
  03b88	0b c1		 or	 eax, ecx
  03b8a	66 89 44 24 6c	 mov	 WORD PTR cyl$[rsp], ax

; 3561 :         head = (iobuf[4] << 8) | iobuf[5];

  03b8f	b8 01 00 00 00	 mov	 eax, 1
  03b94	48 6b c0 04	 imul	 rax, rax, 4
  03b98	48 8b 8c 24 f8
	03 00 00	 mov	 rcx, QWORD PTR iobuf$[rsp]
  03ba0	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  03ba4	c1 e0 08	 shl	 eax, 8
  03ba7	b9 01 00 00 00	 mov	 ecx, 1
  03bac	48 6b c9 05	 imul	 rcx, rcx, 5
  03bb0	48 8b 94 24 f8
	03 00 00	 mov	 rdx, QWORD PTR iobuf$[rsp]
  03bb8	0f b6 0c 0a	 movzx	 ecx, BYTE PTR [rdx+rcx]
  03bbc	0b c1		 or	 eax, ecx
  03bbe	66 89 44 24 70	 mov	 WORD PTR head$[rsp], ax

; 3562 : 
; 3563 :         /* For Seek Head, use the current cylinder number */
; 3564 :         if (code == 0x1B)

  03bc3	0f b6 84 24 c8
	03 00 00	 movzx	 eax, BYTE PTR code$[rsp]
  03bcb	83 f8 1b	 cmp	 eax, 27
  03bce	75 14		 jne	 SHORT $LN239@ckd_dasd_e

; 3565 :             cyl = (U16) dev->ckdcurcyl;

  03bd0	48 8b 84 24 c0
	03 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  03bd8	0f b7 80 c8 12
	00 00		 movzx	 eax, WORD PTR [rax+4808]
  03bdf	66 89 44 24 6c	 mov	 WORD PTR cyl$[rsp], ax
$LN239@ckd_dasd_e:

; 3566 : 
; 3567 :         /* Command reject if seek address is invalid */
; 3568 :         if (bin != 0 || cyl >= dev->ckdcyls || head >= dev->ckdheads)

  03be4	0f b6 84 24 ac
	00 00 00	 movzx	 eax, BYTE PTR bin$[rsp]
  03bec	85 c0		 test	 eax, eax
  03bee	75 2a		 jne	 SHORT $LN241@ckd_dasd_e
  03bf0	0f b7 44 24 6c	 movzx	 eax, WORD PTR cyl$[rsp]
  03bf5	48 8b 8c 24 c0
	03 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  03bfd	3b 81 b8 12 00
	00		 cmp	 eax, DWORD PTR [rcx+4792]
  03c03	7d 15		 jge	 SHORT $LN241@ckd_dasd_e
  03c05	0f b7 44 24 70	 movzx	 eax, WORD PTR head$[rsp]
  03c0a	48 8b 8c 24 c0
	03 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  03c12	3b 81 c0 12 00
	00		 cmp	 eax, DWORD PTR [rcx+4800]
  03c18	7c 2f		 jl	 SHORT $LN240@ckd_dasd_e
$LN241@ckd_dasd_e:

; 3569 :         {
; 3570 :             ckd_build_sense (dev, SENSE_CR, 0, 0,

  03c1a	c6 44 24 28 04	 mov	 BYTE PTR [rsp+40], 4
  03c1f	c6 44 24 20 00	 mov	 BYTE PTR [rsp+32], 0
  03c24	45 33 c9	 xor	 r9d, r9d
  03c27	45 33 c0	 xor	 r8d, r8d
  03c2a	b2 80		 mov	 dl, 128			; 00000080H
  03c2c	48 8b 8c 24 c0
	03 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  03c34	e8 00 00 00 00	 call	 ckd_build_sense

; 3571 :                             FORMAT_0, MESSAGE_4);
; 3572 :             *unitstat = CSW_CE | CSW_DE | CSW_UC;

  03c39	48 8b 84 24 08
	04 00 00	 mov	 rax, QWORD PTR unitstat$[rsp]
  03c41	c6 00 0e	 mov	 BYTE PTR [rax], 14

; 3573 :             break;

  03c44	e9 07 69 00 00	 jmp	 $LN2@ckd_dasd_e
$LN240@ckd_dasd_e:

; 3574 :         }
; 3575 : 
; 3576 :         /* File protected if outside defined extent */
; 3577 :         if ( EXTENT_CHECK(dev, cyl, head) )

  03c49	0f b7 44 24 6c	 movzx	 eax, WORD PTR cyl$[rsp]
  03c4e	48 8b 8c 24 c0
	03 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  03c56	0f b7 89 f2 12
	00 00		 movzx	 ecx, WORD PTR [rcx+4850]
  03c5d	3b c1		 cmp	 eax, ecx
  03c5f	7c 78		 jl	 SHORT $LN243@ckd_dasd_e
  03c61	0f b7 44 24 6c	 movzx	 eax, WORD PTR cyl$[rsp]
  03c66	48 8b 8c 24 c0
	03 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  03c6e	0f b7 89 f6 12
	00 00		 movzx	 ecx, WORD PTR [rcx+4854]
  03c75	3b c1		 cmp	 eax, ecx
  03c77	7f 60		 jg	 SHORT $LN243@ckd_dasd_e
  03c79	0f b7 44 24 6c	 movzx	 eax, WORD PTR cyl$[rsp]
  03c7e	48 8b 8c 24 c0
	03 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  03c86	0f b7 89 f2 12
	00 00		 movzx	 ecx, WORD PTR [rcx+4850]
  03c8d	3b c1		 cmp	 eax, ecx
  03c8f	75 18		 jne	 SHORT $LN244@ckd_dasd_e
  03c91	0f b7 44 24 70	 movzx	 eax, WORD PTR head$[rsp]
  03c96	48 8b 8c 24 c0
	03 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  03c9e	0f b7 89 f4 12
	00 00		 movzx	 ecx, WORD PTR [rcx+4852]
  03ca5	3b c1		 cmp	 eax, ecx
  03ca7	7c 30		 jl	 SHORT $LN243@ckd_dasd_e
$LN244@ckd_dasd_e:
  03ca9	0f b7 44 24 6c	 movzx	 eax, WORD PTR cyl$[rsp]
  03cae	48 8b 8c 24 c0
	03 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  03cb6	0f b7 89 f6 12
	00 00		 movzx	 ecx, WORD PTR [rcx+4854]
  03cbd	3b c1		 cmp	 eax, ecx
  03cbf	75 47		 jne	 SHORT $LN242@ckd_dasd_e
  03cc1	0f b7 44 24 70	 movzx	 eax, WORD PTR head$[rsp]
  03cc6	48 8b 8c 24 c0
	03 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  03cce	0f b7 89 f8 12
	00 00		 movzx	 ecx, WORD PTR [rcx+4856]
  03cd5	3b c1		 cmp	 eax, ecx
  03cd7	7e 2f		 jle	 SHORT $LN242@ckd_dasd_e
$LN243@ckd_dasd_e:

; 3578 :         {
; 3579 :             ckd_build_sense (dev, 0, SENSE1_FP, 0, 0, 0);

  03cd9	c6 44 24 28 00	 mov	 BYTE PTR [rsp+40], 0
  03cde	c6 44 24 20 00	 mov	 BYTE PTR [rsp+32], 0
  03ce3	45 33 c9	 xor	 r9d, r9d
  03ce6	41 b0 04	 mov	 r8b, 4
  03ce9	33 d2		 xor	 edx, edx
  03ceb	48 8b 8c 24 c0
	03 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  03cf3	e8 00 00 00 00	 call	 ckd_build_sense

; 3580 :             *unitstat = CSW_CE | CSW_DE | CSW_UC;

  03cf8	48 8b 84 24 08
	04 00 00	 mov	 rax, QWORD PTR unitstat$[rsp]
  03d00	c6 00 0e	 mov	 BYTE PTR [rax], 14

; 3581 :             break;

  03d03	e9 48 68 00 00	 jmp	 $LN2@ckd_dasd_e
$LN242@ckd_dasd_e:

; 3582 :         }
; 3583 : 
; 3584 :         /* Seek to specified cylinder and head */
; 3585 :         rc = ckd_seek (dev, cyl, head, &trkhdr, unitstat);

  03d08	0f b7 44 24 70	 movzx	 eax, WORD PTR head$[rsp]
  03d0d	0f b7 4c 24 6c	 movzx	 ecx, WORD PTR cyl$[rsp]
  03d12	48 8b 94 24 08
	04 00 00	 mov	 rdx, QWORD PTR unitstat$[rsp]
  03d1a	48 89 54 24 20	 mov	 QWORD PTR [rsp+32], rdx
  03d1f	4c 8d 8c 24 40
	02 00 00	 lea	 r9, QWORD PTR trkhdr$[rsp]
  03d27	44 8b c0	 mov	 r8d, eax
  03d2a	8b d1		 mov	 edx, ecx
  03d2c	48 8b 8c 24 c0
	03 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  03d34	e8 00 00 00 00	 call	 ckd_seek
  03d39	89 44 24 60	 mov	 DWORD PTR rc$[rsp], eax

; 3586 :         if (rc < 0) break;

  03d3d	83 7c 24 60 00	 cmp	 DWORD PTR rc$[rsp], 0
  03d42	7d 05		 jge	 SHORT $LN245@ckd_dasd_e
  03d44	e9 07 68 00 00	 jmp	 $LN2@ckd_dasd_e
$LN245@ckd_dasd_e:

; 3587 : 
; 3588 :         /* Set command processed flag */
; 3589 :         dev->ckdseek = 1;

  03d49	48 8b 84 24 c0
	03 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  03d51	8b 80 14 13 00
	00		 mov	 eax, DWORD PTR [rax+4884]
  03d57	83 c8 40	 or	 eax, 64			; 00000040H
  03d5a	48 8b 8c 24 c0
	03 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  03d62	89 81 14 13 00
	00		 mov	 DWORD PTR [rcx+4884], eax

; 3590 : 
; 3591 :         /* Return normal status */
; 3592 :         *unitstat = CSW_CE | CSW_DE;

  03d68	48 8b 84 24 08
	04 00 00	 mov	 rax, QWORD PTR unitstat$[rsp]
  03d70	c6 00 0c	 mov	 BYTE PTR [rax], 12

; 3593 :         break;

  03d73	e9 d8 67 00 00	 jmp	 $LN2@ckd_dasd_e
$LN246@ckd_dasd_e:

; 3594 : 
; 3595 :     case 0x13:
; 3596 :     /*---------------------------------------------------------------*/
; 3597 :     /* RECALIBRATE                                                   */
; 3598 :     /*---------------------------------------------------------------*/
; 3599 :         /* Command reject if recalibrate is issued to a 3390 */
; 3600 :         if (dev->devtype == 0x3390)

  03d78	48 8b 84 24 c0
	03 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  03d80	0f b7 40 4a	 movzx	 eax, WORD PTR [rax+74]
  03d84	3d 90 33 00 00	 cmp	 eax, 13200		; 00003390H
  03d89	75 2f		 jne	 SHORT $LN247@ckd_dasd_e

; 3601 :         {
; 3602 :             ckd_build_sense (dev, SENSE_CR, 0, 0,

  03d8b	c6 44 24 28 01	 mov	 BYTE PTR [rsp+40], 1
  03d90	c6 44 24 20 00	 mov	 BYTE PTR [rsp+32], 0
  03d95	45 33 c9	 xor	 r9d, r9d
  03d98	45 33 c0	 xor	 r8d, r8d
  03d9b	b2 80		 mov	 dl, 128			; 00000080H
  03d9d	48 8b 8c 24 c0
	03 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  03da5	e8 00 00 00 00	 call	 ckd_build_sense

; 3603 :                             FORMAT_0, MESSAGE_1);
; 3604 :             *unitstat = CSW_CE | CSW_DE | CSW_UC;

  03daa	48 8b 84 24 08
	04 00 00	 mov	 rax, QWORD PTR unitstat$[rsp]
  03db2	c6 00 0e	 mov	 BYTE PTR [rax], 14

; 3605 :             break;

  03db5	e9 96 67 00 00	 jmp	 $LN2@ckd_dasd_e
$LN247@ckd_dasd_e:

; 3606 :         }
; 3607 : 
; 3608 :         /* Command reject if within the domain of a Locate Record */
; 3609 :         if (dev->ckdlcount > 0)

  03dba	48 8b 84 24 c0
	03 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  03dc2	0f b6 80 02 13
	00 00		 movzx	 eax, BYTE PTR [rax+4866]
  03dc9	85 c0		 test	 eax, eax
  03dcb	7e 2f		 jle	 SHORT $LN248@ckd_dasd_e

; 3610 :         {
; 3611 :             ckd_build_sense (dev, SENSE_CR, 0, 0,

  03dcd	c6 44 24 28 02	 mov	 BYTE PTR [rsp+40], 2
  03dd2	c6 44 24 20 00	 mov	 BYTE PTR [rsp+32], 0
  03dd7	45 33 c9	 xor	 r9d, r9d
  03dda	45 33 c0	 xor	 r8d, r8d
  03ddd	b2 80		 mov	 dl, 128			; 00000080H
  03ddf	48 8b 8c 24 c0
	03 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  03de7	e8 00 00 00 00	 call	 ckd_build_sense

; 3612 :                             FORMAT_0, MESSAGE_2);
; 3613 :             *unitstat = CSW_CE | CSW_DE | CSW_UC;

  03dec	48 8b 84 24 08
	04 00 00	 mov	 rax, QWORD PTR unitstat$[rsp]
  03df4	c6 00 0e	 mov	 BYTE PTR [rax], 14

; 3614 :             break;

  03df7	e9 54 67 00 00	 jmp	 $LN2@ckd_dasd_e
$LN248@ckd_dasd_e:

; 3615 :         }
; 3616 : 
; 3617 :         /* File protected if the file mask does not allow recalibrate,
; 3618 :            or if the file mask specifies diagnostic authorization */
; 3619 :         if ((dev->ckdfmask & CKDMASK_SKCTL) != CKDMASK_SKCTL_ALLSKR
; 3620 :             || (dev->ckdfmask & CKDMASK_AAUTH) == CKDMASK_AAUTH_DIAG)

  03dfc	48 8b 84 24 c0
	03 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  03e04	0f b6 80 fa 12
	00 00		 movzx	 eax, BYTE PTR [rax+4858]
  03e0b	83 e0 18	 and	 eax, 24
  03e0e	85 c0		 test	 eax, eax
  03e10	75 17		 jne	 SHORT $LN250@ckd_dasd_e
  03e12	48 8b 84 24 c0
	03 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  03e1a	0f b6 80 fa 12
	00 00		 movzx	 eax, BYTE PTR [rax+4858]
  03e21	83 e0 06	 and	 eax, 6
  03e24	83 f8 04	 cmp	 eax, 4
  03e27	75 2f		 jne	 SHORT $LN249@ckd_dasd_e
$LN250@ckd_dasd_e:

; 3621 :         {
; 3622 :             ckd_build_sense (dev, 0, SENSE1_FP, 0, 0, 0);

  03e29	c6 44 24 28 00	 mov	 BYTE PTR [rsp+40], 0
  03e2e	c6 44 24 20 00	 mov	 BYTE PTR [rsp+32], 0
  03e33	45 33 c9	 xor	 r9d, r9d
  03e36	41 b0 04	 mov	 r8b, 4
  03e39	33 d2		 xor	 edx, edx
  03e3b	48 8b 8c 24 c0
	03 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  03e43	e8 00 00 00 00	 call	 ckd_build_sense

; 3623 :             *unitstat = CSW_CE | CSW_DE | CSW_UC;

  03e48	48 8b 84 24 08
	04 00 00	 mov	 rax, QWORD PTR unitstat$[rsp]
  03e50	c6 00 0e	 mov	 BYTE PTR [rax], 14

; 3624 :             break;

  03e53	e9 f8 66 00 00	 jmp	 $LN2@ckd_dasd_e
$LN249@ckd_dasd_e:

; 3625 :         }
; 3626 : 
; 3627 :         /* File protected if cyl 0 head 0 is outside defined extent */
; 3628 :         if ( EXTENT_CHECK0(dev) )

  03e58	48 8b 84 24 c0
	03 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  03e60	0f b7 80 f2 12
	00 00		 movzx	 eax, WORD PTR [rax+4850]
  03e67	85 c0		 test	 eax, eax
  03e69	7f 26		 jg	 SHORT $LN252@ckd_dasd_e
  03e6b	48 8b 84 24 c0
	03 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  03e73	0f b7 80 f2 12
	00 00		 movzx	 eax, WORD PTR [rax+4850]
  03e7a	85 c0		 test	 eax, eax
  03e7c	75 42		 jne	 SHORT $LN251@ckd_dasd_e
  03e7e	48 8b 84 24 c0
	03 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  03e86	0f b7 80 f4 12
	00 00		 movzx	 eax, WORD PTR [rax+4852]
  03e8d	85 c0		 test	 eax, eax
  03e8f	7e 2f		 jle	 SHORT $LN251@ckd_dasd_e
$LN252@ckd_dasd_e:

; 3629 :         {
; 3630 :             ckd_build_sense (dev, 0, SENSE1_FP, 0, 0, 0);

  03e91	c6 44 24 28 00	 mov	 BYTE PTR [rsp+40], 0
  03e96	c6 44 24 20 00	 mov	 BYTE PTR [rsp+32], 0
  03e9b	45 33 c9	 xor	 r9d, r9d
  03e9e	41 b0 04	 mov	 r8b, 4
  03ea1	33 d2		 xor	 edx, edx
  03ea3	48 8b 8c 24 c0
	03 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  03eab	e8 00 00 00 00	 call	 ckd_build_sense

; 3631 :             *unitstat = CSW_CE | CSW_DE | CSW_UC;

  03eb0	48 8b 84 24 08
	04 00 00	 mov	 rax, QWORD PTR unitstat$[rsp]
  03eb8	c6 00 0e	 mov	 BYTE PTR [rax], 14

; 3632 :             break;

  03ebb	e9 90 66 00 00	 jmp	 $LN2@ckd_dasd_e
$LN251@ckd_dasd_e:

; 3633 :         }
; 3634 : 
; 3635 :         /* Seek to cylinder 0 head 0 */
; 3636 :         rc = ckd_seek (dev, 0, 0, &trkhdr, unitstat);

  03ec0	48 8b 84 24 08
	04 00 00	 mov	 rax, QWORD PTR unitstat$[rsp]
  03ec8	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  03ecd	4c 8d 8c 24 40
	02 00 00	 lea	 r9, QWORD PTR trkhdr$[rsp]
  03ed5	45 33 c0	 xor	 r8d, r8d
  03ed8	33 d2		 xor	 edx, edx
  03eda	48 8b 8c 24 c0
	03 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  03ee2	e8 00 00 00 00	 call	 ckd_seek
  03ee7	89 44 24 60	 mov	 DWORD PTR rc$[rsp], eax

; 3637 :         if (rc < 0) break;

  03eeb	83 7c 24 60 00	 cmp	 DWORD PTR rc$[rsp], 0
  03ef0	7d 05		 jge	 SHORT $LN253@ckd_dasd_e
  03ef2	e9 59 66 00 00	 jmp	 $LN2@ckd_dasd_e
$LN253@ckd_dasd_e:

; 3638 : 
; 3639 :         /* Set command processed flag */
; 3640 :         dev->ckdrecal = 1;

  03ef7	48 8b 84 24 c0
	03 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  03eff	8b 80 14 13 00
	00		 mov	 eax, DWORD PTR [rax+4884]
  03f05	0f ba e8 08	 bts	 eax, 8
  03f09	48 8b 8c 24 c0
	03 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  03f11	89 81 14 13 00
	00		 mov	 DWORD PTR [rcx+4884], eax

; 3641 : 
; 3642 :         /* Return normal status */
; 3643 :         *unitstat = CSW_CE | CSW_DE;

  03f17	48 8b 84 24 08
	04 00 00	 mov	 rax, QWORD PTR unitstat$[rsp]
  03f1f	c6 00 0c	 mov	 BYTE PTR [rax], 12

; 3644 :         break;

  03f22	e9 29 66 00 00	 jmp	 $LN2@ckd_dasd_e
$LN254@ckd_dasd_e:

; 3645 : 
; 3646 :     case 0x1F:
; 3647 :     /*---------------------------------------------------------------*/
; 3648 :     /* SET FILE MASK                                                 */
; 3649 :     /*---------------------------------------------------------------*/
; 3650 :         /* Command reject if preceded by a Define Extent or
; 3651 :            Set File Mask, or within the domain of a Locate Record */
; 3652 :         if (dev->ckdxtdef || dev->ckdsetfm || dev->ckdlcount > 0)

  03f27	48 8b 84 24 c0
	03 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  03f2f	8b 80 14 13 00
	00		 mov	 eax, DWORD PTR [rax+4884]
  03f35	d1 e8		 shr	 eax, 1
  03f37	83 e0 01	 and	 eax, 1
  03f3a	85 c0		 test	 eax, eax
  03f3c	75 2b		 jne	 SHORT $LN256@ckd_dasd_e
  03f3e	48 8b 84 24 c0
	03 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  03f46	8b 80 14 13 00
	00		 mov	 eax, DWORD PTR [rax+4884]
  03f4c	c1 e8 02	 shr	 eax, 2
  03f4f	83 e0 01	 and	 eax, 1
  03f52	85 c0		 test	 eax, eax
  03f54	75 13		 jne	 SHORT $LN256@ckd_dasd_e
  03f56	48 8b 84 24 c0
	03 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  03f5e	0f b6 80 02 13
	00 00		 movzx	 eax, BYTE PTR [rax+4866]
  03f65	85 c0		 test	 eax, eax
  03f67	7e 2f		 jle	 SHORT $LN255@ckd_dasd_e
$LN256@ckd_dasd_e:

; 3653 :         {
; 3654 :             ckd_build_sense (dev, SENSE_CR, 0, 0,

  03f69	c6 44 24 28 02	 mov	 BYTE PTR [rsp+40], 2
  03f6e	c6 44 24 20 00	 mov	 BYTE PTR [rsp+32], 0
  03f73	45 33 c9	 xor	 r9d, r9d
  03f76	45 33 c0	 xor	 r8d, r8d
  03f79	b2 80		 mov	 dl, 128			; 00000080H
  03f7b	48 8b 8c 24 c0
	03 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  03f83	e8 00 00 00 00	 call	 ckd_build_sense

; 3655 :                             FORMAT_0, MESSAGE_2);
; 3656 :             *unitstat = CSW_CE | CSW_DE | CSW_UC;

  03f88	48 8b 84 24 08
	04 00 00	 mov	 rax, QWORD PTR unitstat$[rsp]
  03f90	c6 00 0e	 mov	 BYTE PTR [rax], 14

; 3657 :             break;

  03f93	e9 b8 65 00 00	 jmp	 $LN2@ckd_dasd_e
$LN255@ckd_dasd_e:

; 3658 :         }
; 3659 : 
; 3660 :         /* Set residual count */
; 3661 :         num = (count < 1) ? count : 1;

  03f98	83 bc 24 e0 03
	00 00 01	 cmp	 DWORD PTR count$[rsp], 1
  03fa0	73 10		 jae	 SHORT $LN695@ckd_dasd_e
  03fa2	8b 84 24 e0 03
	00 00		 mov	 eax, DWORD PTR count$[rsp]
  03fa9	89 84 24 3c 01
	00 00		 mov	 DWORD PTR tv2033[rsp], eax
  03fb0	eb 0b		 jmp	 SHORT $LN696@ckd_dasd_e
$LN695@ckd_dasd_e:
  03fb2	c7 84 24 3c 01
	00 00 01 00 00
	00		 mov	 DWORD PTR tv2033[rsp], 1
$LN696@ckd_dasd_e:
  03fbd	8b 84 24 3c 01
	00 00		 mov	 eax, DWORD PTR tv2033[rsp]
  03fc4	89 44 24 64	 mov	 DWORD PTR num$[rsp], eax

; 3662 :         *residual = count - num;

  03fc8	8b 44 24 64	 mov	 eax, DWORD PTR num$[rsp]
  03fcc	8b 8c 24 e0 03
	00 00		 mov	 ecx, DWORD PTR count$[rsp]
  03fd3	2b c8		 sub	 ecx, eax
  03fd5	8b c1		 mov	 eax, ecx
  03fd7	48 8b 8c 24 10
	04 00 00	 mov	 rcx, QWORD PTR residual$[rsp]
  03fdf	89 01		 mov	 DWORD PTR [rcx], eax

; 3663 : 
; 3664 :         /* Command reject if count is less than 1 */
; 3665 :         if (count < 1)

  03fe1	83 bc 24 e0 03
	00 00 01	 cmp	 DWORD PTR count$[rsp], 1
  03fe9	73 2f		 jae	 SHORT $LN257@ckd_dasd_e

; 3666 :         {
; 3667 :             ckd_build_sense (dev, SENSE_CR, 0, 0,

  03feb	c6 44 24 28 03	 mov	 BYTE PTR [rsp+40], 3
  03ff0	c6 44 24 20 00	 mov	 BYTE PTR [rsp+32], 0
  03ff5	45 33 c9	 xor	 r9d, r9d
  03ff8	45 33 c0	 xor	 r8d, r8d
  03ffb	b2 80		 mov	 dl, 128			; 00000080H
  03ffd	48 8b 8c 24 c0
	03 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  04005	e8 00 00 00 00	 call	 ckd_build_sense

; 3668 :                             FORMAT_0, MESSAGE_3);
; 3669 :             *unitstat = CSW_CE | CSW_DE | CSW_UC;

  0400a	48 8b 84 24 08
	04 00 00	 mov	 rax, QWORD PTR unitstat$[rsp]
  04012	c6 00 0e	 mov	 BYTE PTR [rax], 14

; 3670 :             break;

  04015	e9 36 65 00 00	 jmp	 $LN2@ckd_dasd_e
$LN257@ckd_dasd_e:

; 3671 :         }
; 3672 : 
; 3673 :         /* Extract the file mask from the I/O buffer */
; 3674 :         dev->ckdfmask = iobuf[0];

  0401a	b8 01 00 00 00	 mov	 eax, 1
  0401f	48 6b c0 00	 imul	 rax, rax, 0
  04023	48 8b 8c 24 c0
	03 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  0402b	48 8b 94 24 f8
	03 00 00	 mov	 rdx, QWORD PTR iobuf$[rsp]
  04033	0f b6 04 02	 movzx	 eax, BYTE PTR [rdx+rax]
  04037	88 81 fa 12 00
	00		 mov	 BYTE PTR [rcx+4858], al

; 3675 : 
; 3676 :         // "%1d:%04X CKD file %s: set file mask %02X"
; 3677 :         if (dev->ccwtrace && sysblk.traceFILE)

  0403d	48 8b 84 24 c0
	03 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  04045	8b 80 f8 05 00
	00		 mov	 eax, DWORD PTR [rax+1528]
  0404b	c1 e8 0f	 shr	 eax, 15
  0404e	83 e0 01	 and	 eax, 1
  04051	85 c0		 test	 eax, eax
  04053	74 24		 je	 SHORT $LN258@ckd_dasd_e
  04055	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  0405c	48 83 b8 20 14
	00 00 00	 cmp	 QWORD PTR [rax+5152], 0
  04064	74 13		 je	 SHORT $LN258@ckd_dasd_e

; 3678 :             tf_0442( dev );

  04066	48 8b 8c 24 c0
	03 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  0406e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_tf_0442
  04074	e9 e2 00 00 00	 jmp	 $LN259@ckd_dasd_e
$LN258@ckd_dasd_e:
$LN27@ckd_dasd_e:

; 3679 :         else
; 3680 :             LOGDEVTR( HHC00442, "I", dev->filename, dev->ckdfmask );

  04079	48 8b 84 24 c0
	03 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  04081	8b 80 f8 05 00
	00		 mov	 eax, DWORD PTR [rax+1528]
  04087	c1 e8 0f	 shr	 eax, 15
  0408a	83 e0 01	 and	 eax, 1
  0408d	85 c0		 test	 eax, eax
  0408f	0f 84 bc 00 00
	00		 je	 $LN260@ckd_dasd_e
  04095	48 8b 84 24 c0
	03 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  0409d	0f b6 80 fa 12
	00 00		 movzx	 eax, BYTE PTR [rax+4858]
  040a4	89 84 24 e8 01
	00 00		 mov	 DWORD PTR tv2057[rsp], eax
  040ab	48 8b 8c 24 c0
	03 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  040b3	48 81 c1 a4 00
	00 00		 add	 rcx, 164		; 000000a4H
  040ba	48 89 8c 24 20
	02 00 00	 mov	 QWORD PTR tv2059[rsp], rcx
  040c2	48 8b 94 24 c0
	03 00 00	 mov	 rdx, QWORD PTR dev$[rsp]
  040ca	0f b7 52 48	 movzx	 edx, WORD PTR [rdx+72]
  040ce	89 94 24 ec 01
	00 00		 mov	 DWORD PTR tv2062[rsp], edx
  040d5	48 8b bc 24 c0
	03 00 00	 mov	 rdi, QWORD PTR dev$[rsp]
  040dd	0f b7 7f 44	 movzx	 edi, WORD PTR [rdi+68]
  040e1	d1 ff		 sar	 edi, 1
  040e3	b9 01 00 00 00	 mov	 ecx, 1
  040e8	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  040ee	8b 8c 24 e8 01
	00 00		 mov	 ecx, DWORD PTR tv2057[rsp]
  040f5	89 4c 24 50	 mov	 DWORD PTR [rsp+80], ecx
  040f9	48 8b 8c 24 20
	02 00 00	 mov	 rcx, QWORD PTR tv2059[rsp]
  04101	48 89 4c 24 48	 mov	 QWORD PTR [rsp+72], rcx
  04106	8b 8c 24 ec 01
	00 00		 mov	 ecx, DWORD PTR tv2062[rsp]
  0410d	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  04111	89 7c 24 38	 mov	 DWORD PTR [rsp+56], edi
  04115	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG171894
  0411c	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  04121	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG171895
  04128	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  0412d	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  04132	41 b9 03 00 00
	00		 mov	 r9d, 3
  04138	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG171896
  0413f	ba 60 0e 00 00	 mov	 edx, 3680		; 00000e60H
  04144	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG171897
  0414b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg
$LN260@ckd_dasd_e:
  04151	33 c0		 xor	 eax, eax
  04153	85 c0		 test	 eax, eax
  04155	0f 85 1e ff ff
	ff		 jne	 $LN27@ckd_dasd_e
$LN259@ckd_dasd_e:

; 3681 : 
; 3682 :         /* Command reject if file mask is invalid */
; 3683 :         if ((dev->ckdfmask & CKDMASK_RESV) != 0)

  0415b	48 8b 84 24 c0
	03 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  04163	0f b6 80 fa 12
	00 00		 movzx	 eax, BYTE PTR [rax+4858]
  0416a	83 e0 20	 and	 eax, 32			; 00000020H
  0416d	85 c0		 test	 eax, eax
  0416f	74 2f		 je	 SHORT $LN261@ckd_dasd_e

; 3684 :         {
; 3685 :             ckd_build_sense (dev, SENSE_CR, 0, 0,

  04171	c6 44 24 28 04	 mov	 BYTE PTR [rsp+40], 4
  04176	c6 44 24 20 00	 mov	 BYTE PTR [rsp+32], 0
  0417b	45 33 c9	 xor	 r9d, r9d
  0417e	45 33 c0	 xor	 r8d, r8d
  04181	b2 80		 mov	 dl, 128			; 00000080H
  04183	48 8b 8c 24 c0
	03 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  0418b	e8 00 00 00 00	 call	 ckd_build_sense

; 3686 :                             FORMAT_0, MESSAGE_4);
; 3687 :             *unitstat = CSW_CE | CSW_DE | CSW_UC;

  04190	48 8b 84 24 08
	04 00 00	 mov	 rax, QWORD PTR unitstat$[rsp]
  04198	c6 00 0e	 mov	 BYTE PTR [rax], 14

; 3688 :             break;

  0419b	e9 b0 63 00 00	 jmp	 $LN2@ckd_dasd_e
$LN261@ckd_dasd_e:

; 3689 :         }
; 3690 : 
; 3691 :         /* Set command processed flag */
; 3692 :         dev->ckdsetfm = 1;

  041a0	48 8b 84 24 c0
	03 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  041a8	8b 80 14 13 00
	00		 mov	 eax, DWORD PTR [rax+4884]
  041ae	83 c8 04	 or	 eax, 4
  041b1	48 8b 8c 24 c0
	03 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  041b9	89 81 14 13 00
	00		 mov	 DWORD PTR [rcx+4884], eax

; 3693 : 
; 3694 :         /* Return normal status */
; 3695 :         *unitstat = CSW_CE | CSW_DE;

  041bf	48 8b 84 24 08
	04 00 00	 mov	 rax, QWORD PTR unitstat$[rsp]
  041c7	c6 00 0c	 mov	 BYTE PTR [rax], 12

; 3696 :         break;

  041ca	e9 81 63 00 00	 jmp	 $LN2@ckd_dasd_e
$LN262@ckd_dasd_e:

; 3697 : 
; 3698 :     case 0x22:
; 3699 :     /*---------------------------------------------------------------*/
; 3700 :     /* READ SECTOR                                                   */
; 3701 :     /*---------------------------------------------------------------*/
; 3702 :         /* Command reject if non-RPS device */
; 3703 :         if (dev->ckdtab->sectors == 0)

  041cf	48 8b 84 24 c0
	03 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  041d7	48 8b 80 a0 12
	00 00		 mov	 rax, QWORD PTR [rax+4768]
  041de	0f b7 40 1c	 movzx	 eax, WORD PTR [rax+28]
  041e2	85 c0		 test	 eax, eax
  041e4	75 2f		 jne	 SHORT $LN263@ckd_dasd_e

; 3704 :         {
; 3705 :             ckd_build_sense (dev, SENSE_CR, 0, 0,

  041e6	c6 44 24 28 01	 mov	 BYTE PTR [rsp+40], 1
  041eb	c6 44 24 20 00	 mov	 BYTE PTR [rsp+32], 0
  041f0	45 33 c9	 xor	 r9d, r9d
  041f3	45 33 c0	 xor	 r8d, r8d
  041f6	b2 80		 mov	 dl, 128			; 00000080H
  041f8	48 8b 8c 24 c0
	03 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  04200	e8 00 00 00 00	 call	 ckd_build_sense

; 3706 :                             FORMAT_0, MESSAGE_1);
; 3707 :             *unitstat = CSW_CE | CSW_DE | CSW_UC;

  04205	48 8b 84 24 08
	04 00 00	 mov	 rax, QWORD PTR unitstat$[rsp]
  0420d	c6 00 0e	 mov	 BYTE PTR [rax], 14

; 3708 :             break;

  04210	e9 3b 63 00 00	 jmp	 $LN2@ckd_dasd_e
$LN263@ckd_dasd_e:

; 3709 :         }
; 3710 : 
; 3711 :         /* Command reject if within the domain of a Locate Record */
; 3712 :         if (dev->ckdlcount > 0)

  04215	48 8b 84 24 c0
	03 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  0421d	0f b6 80 02 13
	00 00		 movzx	 eax, BYTE PTR [rax+4866]
  04224	85 c0		 test	 eax, eax
  04226	7e 2f		 jle	 SHORT $LN264@ckd_dasd_e

; 3713 :         {
; 3714 :             ckd_build_sense (dev, SENSE_CR, 0, 0,

  04228	c6 44 24 28 02	 mov	 BYTE PTR [rsp+40], 2
  0422d	c6 44 24 20 00	 mov	 BYTE PTR [rsp+32], 0
  04232	45 33 c9	 xor	 r9d, r9d
  04235	45 33 c0	 xor	 r8d, r8d
  04238	b2 80		 mov	 dl, 128			; 00000080H
  0423a	48 8b 8c 24 c0
	03 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  04242	e8 00 00 00 00	 call	 ckd_build_sense

; 3715 :                             FORMAT_0, MESSAGE_2);
; 3716 :             *unitstat = CSW_CE | CSW_DE | CSW_UC;

  04247	48 8b 84 24 08
	04 00 00	 mov	 rax, QWORD PTR unitstat$[rsp]
  0424f	c6 00 0e	 mov	 BYTE PTR [rax], 14

; 3717 :             break;

  04252	e9 f9 62 00 00	 jmp	 $LN2@ckd_dasd_e
$LN264@ckd_dasd_e:

; 3718 :         }
; 3719 : 
; 3720 :         /* Set residual count */
; 3721 :         num = (count < 1) ? count : 1;

  04257	83 bc 24 e0 03
	00 00 01	 cmp	 DWORD PTR count$[rsp], 1
  0425f	73 10		 jae	 SHORT $LN697@ckd_dasd_e
  04261	8b 84 24 e0 03
	00 00		 mov	 eax, DWORD PTR count$[rsp]
  04268	89 84 24 40 01
	00 00		 mov	 DWORD PTR tv2111[rsp], eax
  0426f	eb 0b		 jmp	 SHORT $LN698@ckd_dasd_e
$LN697@ckd_dasd_e:
  04271	c7 84 24 40 01
	00 00 01 00 00
	00		 mov	 DWORD PTR tv2111[rsp], 1
$LN698@ckd_dasd_e:
  0427c	8b 84 24 40 01
	00 00		 mov	 eax, DWORD PTR tv2111[rsp]
  04283	89 44 24 64	 mov	 DWORD PTR num$[rsp], eax

; 3722 :         *residual = count - num;

  04287	8b 44 24 64	 mov	 eax, DWORD PTR num$[rsp]
  0428b	8b 8c 24 e0 03
	00 00		 mov	 ecx, DWORD PTR count$[rsp]
  04292	2b c8		 sub	 ecx, eax
  04294	8b c1		 mov	 eax, ecx
  04296	48 8b 8c 24 10
	04 00 00	 mov	 rcx, QWORD PTR residual$[rsp]
  0429e	89 01		 mov	 DWORD PTR [rcx], eax

; 3723 :         if (count < 1) *more = 1;

  042a0	83 bc 24 e0 03
	00 00 01	 cmp	 DWORD PTR count$[rsp], 1
  042a8	73 0b		 jae	 SHORT $LN265@ckd_dasd_e
  042aa	48 8b 84 24 00
	04 00 00	 mov	 rax, QWORD PTR more$[rsp]
  042b2	c6 00 01	 mov	 BYTE PTR [rax], 1
$LN265@ckd_dasd_e:

; 3724 : 
; 3725 :         /* Return sector number in I/O buffer */
; 3726 :         iobuf[0] = 0;

  042b5	b8 01 00 00 00	 mov	 eax, 1
  042ba	48 6b c0 00	 imul	 rax, rax, 0
  042be	48 8b 8c 24 f8
	03 00 00	 mov	 rcx, QWORD PTR iobuf$[rsp]
  042c6	c6 04 01 00	 mov	 BYTE PTR [rcx+rax], 0

; 3727 : 
; 3728 :         /* Return normal status */
; 3729 :         *unitstat = CSW_CE | CSW_DE;

  042ca	48 8b 84 24 08
	04 00 00	 mov	 rax, QWORD PTR unitstat$[rsp]
  042d2	c6 00 0c	 mov	 BYTE PTR [rax], 12

; 3730 :         break;

  042d5	e9 76 62 00 00	 jmp	 $LN2@ckd_dasd_e
$LN266@ckd_dasd_e:

; 3731 : 
; 3732 :     case 0x23:
; 3733 :     /*---------------------------------------------------------------*/
; 3734 :     /* SET SECTOR                                                    */
; 3735 :     /*---------------------------------------------------------------*/
; 3736 :         /* Command reject if non-RPS device */
; 3737 :         if (dev->ckdtab->sectors == 0)

  042da	48 8b 84 24 c0
	03 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  042e2	48 8b 80 a0 12
	00 00		 mov	 rax, QWORD PTR [rax+4768]
  042e9	0f b7 40 1c	 movzx	 eax, WORD PTR [rax+28]
  042ed	85 c0		 test	 eax, eax
  042ef	75 2f		 jne	 SHORT $LN267@ckd_dasd_e

; 3738 :         {
; 3739 :             ckd_build_sense (dev, SENSE_CR, 0, 0,

  042f1	c6 44 24 28 01	 mov	 BYTE PTR [rsp+40], 1
  042f6	c6 44 24 20 00	 mov	 BYTE PTR [rsp+32], 0
  042fb	45 33 c9	 xor	 r9d, r9d
  042fe	45 33 c0	 xor	 r8d, r8d
  04301	b2 80		 mov	 dl, 128			; 00000080H
  04303	48 8b 8c 24 c0
	03 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  0430b	e8 00 00 00 00	 call	 ckd_build_sense

; 3740 :                             FORMAT_0, MESSAGE_1);
; 3741 :             *unitstat = CSW_CE | CSW_DE | CSW_UC;

  04310	48 8b 84 24 08
	04 00 00	 mov	 rax, QWORD PTR unitstat$[rsp]
  04318	c6 00 0e	 mov	 BYTE PTR [rax], 14

; 3742 :             break;

  0431b	e9 30 62 00 00	 jmp	 $LN2@ckd_dasd_e
$LN267@ckd_dasd_e:

; 3743 :         }
; 3744 : 
; 3745 :         /* Command reject if within the domain of a Locate Record */
; 3746 :         if (dev->ckdlcount > 0)

  04320	48 8b 84 24 c0
	03 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  04328	0f b6 80 02 13
	00 00		 movzx	 eax, BYTE PTR [rax+4866]
  0432f	85 c0		 test	 eax, eax
  04331	7e 2f		 jle	 SHORT $LN268@ckd_dasd_e

; 3747 :         {
; 3748 :             ckd_build_sense (dev, SENSE_CR, 0, 0,

  04333	c6 44 24 28 02	 mov	 BYTE PTR [rsp+40], 2
  04338	c6 44 24 20 00	 mov	 BYTE PTR [rsp+32], 0
  0433d	45 33 c9	 xor	 r9d, r9d
  04340	45 33 c0	 xor	 r8d, r8d
  04343	b2 80		 mov	 dl, 128			; 00000080H
  04345	48 8b 8c 24 c0
	03 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  0434d	e8 00 00 00 00	 call	 ckd_build_sense

; 3749 :                             FORMAT_0, MESSAGE_2);
; 3750 :             *unitstat = CSW_CE | CSW_DE | CSW_UC;

  04352	48 8b 84 24 08
	04 00 00	 mov	 rax, QWORD PTR unitstat$[rsp]
  0435a	c6 00 0e	 mov	 BYTE PTR [rax], 14

; 3751 :             break;

  0435d	e9 ee 61 00 00	 jmp	 $LN2@ckd_dasd_e
$LN268@ckd_dasd_e:

; 3752 :         }
; 3753 : 
; 3754 :         /* For 3990, command reject if not preceded by Seek, Seek Cyl,
; 3755 :            Locate Record, Read IPL, or Recalibrate command */
; 3756 :         if (dev->ckd3990
; 3757 :             && dev->ckdseek == 0 && dev->ckdskcyl == 0
; 3758 :             && dev->ckdlocat == 0 && dev->ckdrdipl == 0
; 3759 :             && dev->ckdrecal == 0)

  04362	48 8b 84 24 c0
	03 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  0436a	8b 80 14 13 00
	00		 mov	 eax, DWORD PTR [rax+4884]
  04370	83 e0 01	 and	 eax, 1
  04373	85 c0		 test	 eax, eax
  04375	0f 84 ab 00 00
	00		 je	 $LN269@ckd_dasd_e
  0437b	48 8b 84 24 c0
	03 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  04383	8b 80 14 13 00
	00		 mov	 eax, DWORD PTR [rax+4884]
  04389	c1 e8 06	 shr	 eax, 6
  0438c	83 e0 01	 and	 eax, 1
  0438f	85 c0		 test	 eax, eax
  04391	0f 85 8f 00 00
	00		 jne	 $LN269@ckd_dasd_e
  04397	48 8b 84 24 c0
	03 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  0439f	8b 80 14 13 00
	00		 mov	 eax, DWORD PTR [rax+4884]
  043a5	c1 e8 07	 shr	 eax, 7
  043a8	83 e0 01	 and	 eax, 1
  043ab	85 c0		 test	 eax, eax
  043ad	75 77		 jne	 SHORT $LN269@ckd_dasd_e
  043af	48 8b 84 24 c0
	03 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  043b7	8b 80 14 13 00
	00		 mov	 eax, DWORD PTR [rax+4884]
  043bd	c1 e8 03	 shr	 eax, 3
  043c0	83 e0 01	 and	 eax, 1
  043c3	85 c0		 test	 eax, eax
  043c5	75 5f		 jne	 SHORT $LN269@ckd_dasd_e
  043c7	48 8b 84 24 c0
	03 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  043cf	8b 80 14 13 00
	00		 mov	 eax, DWORD PTR [rax+4884]
  043d5	c1 e8 09	 shr	 eax, 9
  043d8	83 e0 01	 and	 eax, 1
  043db	85 c0		 test	 eax, eax
  043dd	75 47		 jne	 SHORT $LN269@ckd_dasd_e
  043df	48 8b 84 24 c0
	03 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  043e7	8b 80 14 13 00
	00		 mov	 eax, DWORD PTR [rax+4884]
  043ed	c1 e8 08	 shr	 eax, 8
  043f0	83 e0 01	 and	 eax, 1
  043f3	85 c0		 test	 eax, eax
  043f5	75 2f		 jne	 SHORT $LN269@ckd_dasd_e

; 3760 :         {
; 3761 :             ckd_build_sense (dev, SENSE_CR, 0, 0,

  043f7	c6 44 24 28 02	 mov	 BYTE PTR [rsp+40], 2
  043fc	c6 44 24 20 00	 mov	 BYTE PTR [rsp+32], 0
  04401	45 33 c9	 xor	 r9d, r9d
  04404	45 33 c0	 xor	 r8d, r8d
  04407	b2 80		 mov	 dl, 128			; 00000080H
  04409	48 8b 8c 24 c0
	03 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  04411	e8 00 00 00 00	 call	 ckd_build_sense

; 3762 :                             FORMAT_0, MESSAGE_2);
; 3763 :             *unitstat = CSW_CE | CSW_DE | CSW_UC;

  04416	48 8b 84 24 08
	04 00 00	 mov	 rax, QWORD PTR unitstat$[rsp]
  0441e	c6 00 0e	 mov	 BYTE PTR [rax], 14

; 3764 :             break;

  04421	e9 2a 61 00 00	 jmp	 $LN2@ckd_dasd_e
$LN269@ckd_dasd_e:

; 3765 :         }
; 3766 : 
; 3767 :         /* Set residual count */
; 3768 :         num = (count < 1) ? count : 1;

  04426	83 bc 24 e0 03
	00 00 01	 cmp	 DWORD PTR count$[rsp], 1
  0442e	73 10		 jae	 SHORT $LN699@ckd_dasd_e
  04430	8b 84 24 e0 03
	00 00		 mov	 eax, DWORD PTR count$[rsp]
  04437	89 84 24 44 01
	00 00		 mov	 DWORD PTR tv2165[rsp], eax
  0443e	eb 0b		 jmp	 SHORT $LN700@ckd_dasd_e
$LN699@ckd_dasd_e:
  04440	c7 84 24 44 01
	00 00 01 00 00
	00		 mov	 DWORD PTR tv2165[rsp], 1
$LN700@ckd_dasd_e:
  0444b	8b 84 24 44 01
	00 00		 mov	 eax, DWORD PTR tv2165[rsp]
  04452	89 44 24 64	 mov	 DWORD PTR num$[rsp], eax

; 3769 :         *residual = count - num;

  04456	8b 44 24 64	 mov	 eax, DWORD PTR num$[rsp]
  0445a	8b 8c 24 e0 03
	00 00		 mov	 ecx, DWORD PTR count$[rsp]
  04461	2b c8		 sub	 ecx, eax
  04463	8b c1		 mov	 eax, ecx
  04465	48 8b 8c 24 10
	04 00 00	 mov	 rcx, QWORD PTR residual$[rsp]
  0446d	89 01		 mov	 DWORD PTR [rcx], eax

; 3770 : 
; 3771 :         /* Command reject if count is less than 1 */
; 3772 :         if (count < 1)

  0446f	83 bc 24 e0 03
	00 00 01	 cmp	 DWORD PTR count$[rsp], 1
  04477	73 2f		 jae	 SHORT $LN270@ckd_dasd_e

; 3773 :         {
; 3774 :             ckd_build_sense (dev, SENSE_CR, 0, 0,

  04479	c6 44 24 28 03	 mov	 BYTE PTR [rsp+40], 3
  0447e	c6 44 24 20 00	 mov	 BYTE PTR [rsp+32], 0
  04483	45 33 c9	 xor	 r9d, r9d
  04486	45 33 c0	 xor	 r8d, r8d
  04489	b2 80		 mov	 dl, 128			; 00000080H
  0448b	48 8b 8c 24 c0
	03 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  04493	e8 00 00 00 00	 call	 ckd_build_sense

; 3775 :                             FORMAT_0, MESSAGE_3);
; 3776 :             *unitstat = CSW_CE | CSW_DE | CSW_UC;

  04498	48 8b 84 24 08
	04 00 00	 mov	 rax, QWORD PTR unitstat$[rsp]
  044a0	c6 00 0e	 mov	 BYTE PTR [rax], 14

; 3777 :             break;

  044a3	e9 a8 60 00 00	 jmp	 $LN2@ckd_dasd_e
$LN270@ckd_dasd_e:

; 3778 :         }
; 3779 : 
; 3780 :         /* Return normal status */
; 3781 :         *unitstat = CSW_CE | CSW_DE;

  044a8	48 8b 84 24 08
	04 00 00	 mov	 rax, QWORD PTR unitstat$[rsp]
  044b0	c6 00 0c	 mov	 BYTE PTR [rax], 12

; 3782 :         break;

  044b3	e9 98 60 00 00	 jmp	 $LN2@ckd_dasd_e
$LN271@ckd_dasd_e:
$LN272@ckd_dasd_e:
$LN273@ckd_dasd_e:
$LN274@ckd_dasd_e:
$LN275@ckd_dasd_e:
$LN276@ckd_dasd_e:

; 3783 : 
; 3784 :     case 0x29: case 0xA9: /* SEARCH KEY EQUAL */
; 3785 :     case 0x49: case 0xC9: /* SEARCH KEY HIGH */
; 3786 :     case 0x69: case 0xE9: /* SEARCH KEY EQUAL OR HIGH */
; 3787 :     /*---------------------------------------------------------------*/
; 3788 :     /* SEARCH KEY                                                    */
; 3789 :     /*---------------------------------------------------------------*/
; 3790 :         /* For 3990, command reject if not preceded by Seek, Seek Cyl,
; 3791 :            Locate Record, Read IPL, or Recalibrate command */
; 3792 :         if (dev->ckd3990
; 3793 :             && dev->ckdseek == 0 && dev->ckdskcyl == 0
; 3794 :             && dev->ckdlocat == 0 && dev->ckdrdipl == 0
; 3795 :             && dev->ckdrecal == 0)

  044b8	48 8b 84 24 c0
	03 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  044c0	8b 80 14 13 00
	00		 mov	 eax, DWORD PTR [rax+4884]
  044c6	83 e0 01	 and	 eax, 1
  044c9	85 c0		 test	 eax, eax
  044cb	0f 84 ab 00 00
	00		 je	 $LN277@ckd_dasd_e
  044d1	48 8b 84 24 c0
	03 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  044d9	8b 80 14 13 00
	00		 mov	 eax, DWORD PTR [rax+4884]
  044df	c1 e8 06	 shr	 eax, 6
  044e2	83 e0 01	 and	 eax, 1
  044e5	85 c0		 test	 eax, eax
  044e7	0f 85 8f 00 00
	00		 jne	 $LN277@ckd_dasd_e
  044ed	48 8b 84 24 c0
	03 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  044f5	8b 80 14 13 00
	00		 mov	 eax, DWORD PTR [rax+4884]
  044fb	c1 e8 07	 shr	 eax, 7
  044fe	83 e0 01	 and	 eax, 1
  04501	85 c0		 test	 eax, eax
  04503	75 77		 jne	 SHORT $LN277@ckd_dasd_e
  04505	48 8b 84 24 c0
	03 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  0450d	8b 80 14 13 00
	00		 mov	 eax, DWORD PTR [rax+4884]
  04513	c1 e8 03	 shr	 eax, 3
  04516	83 e0 01	 and	 eax, 1
  04519	85 c0		 test	 eax, eax
  0451b	75 5f		 jne	 SHORT $LN277@ckd_dasd_e
  0451d	48 8b 84 24 c0
	03 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  04525	8b 80 14 13 00
	00		 mov	 eax, DWORD PTR [rax+4884]
  0452b	c1 e8 09	 shr	 eax, 9
  0452e	83 e0 01	 and	 eax, 1
  04531	85 c0		 test	 eax, eax
  04533	75 47		 jne	 SHORT $LN277@ckd_dasd_e
  04535	48 8b 84 24 c0
	03 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  0453d	8b 80 14 13 00
	00		 mov	 eax, DWORD PTR [rax+4884]
  04543	c1 e8 08	 shr	 eax, 8
  04546	83 e0 01	 and	 eax, 1
  04549	85 c0		 test	 eax, eax
  0454b	75 2f		 jne	 SHORT $LN277@ckd_dasd_e

; 3796 :         {
; 3797 :             ckd_build_sense (dev, SENSE_CR, 0, 0,

  0454d	c6 44 24 28 02	 mov	 BYTE PTR [rsp+40], 2
  04552	c6 44 24 20 00	 mov	 BYTE PTR [rsp+32], 0
  04557	45 33 c9	 xor	 r9d, r9d
  0455a	45 33 c0	 xor	 r8d, r8d
  0455d	b2 80		 mov	 dl, 128			; 00000080H
  0455f	48 8b 8c 24 c0
	03 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  04567	e8 00 00 00 00	 call	 ckd_build_sense

; 3798 :                             FORMAT_0, MESSAGE_2);
; 3799 :             *unitstat = CSW_CE | CSW_DE | CSW_UC;

  0456c	48 8b 84 24 08
	04 00 00	 mov	 rax, QWORD PTR unitstat$[rsp]
  04574	c6 00 0e	 mov	 BYTE PTR [rax], 14

; 3800 :             break;

  04577	e9 d4 5f 00 00	 jmp	 $LN2@ckd_dasd_e
$LN277@ckd_dasd_e:

; 3801 :         }
; 3802 : 
; 3803 :         /* Command reject if within the domain of a Locate Record */
; 3804 :         if (dev->ckdlcount > 0)

  0457c	48 8b 84 24 c0
	03 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  04584	0f b6 80 02 13
	00 00		 movzx	 eax, BYTE PTR [rax+4866]
  0458b	85 c0		 test	 eax, eax
  0458d	7e 2f		 jle	 SHORT $LN278@ckd_dasd_e

; 3805 :         {
; 3806 :             ckd_build_sense (dev, SENSE_CR, 0, 0,

  0458f	c6 44 24 28 02	 mov	 BYTE PTR [rsp+40], 2
  04594	c6 44 24 20 00	 mov	 BYTE PTR [rsp+32], 0
  04599	45 33 c9	 xor	 r9d, r9d
  0459c	45 33 c0	 xor	 r8d, r8d
  0459f	b2 80		 mov	 dl, 128			; 00000080H
  045a1	48 8b 8c 24 c0
	03 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  045a9	e8 00 00 00 00	 call	 ckd_build_sense

; 3807 :                             FORMAT_0, MESSAGE_2);
; 3808 :             *unitstat = CSW_CE | CSW_DE | CSW_UC;

  045ae	48 8b 84 24 08
	04 00 00	 mov	 rax, QWORD PTR unitstat$[rsp]
  045b6	c6 00 0e	 mov	 BYTE PTR [rax], 14

; 3809 :             break;

  045b9	e9 92 5f 00 00	 jmp	 $LN2@ckd_dasd_e
$LN278@ckd_dasd_e:

; 3810 :         }
; 3811 : 
; 3812 :         /* Read next key */
; 3813 :         rc = ckd_read_key (dev, code, key, unitstat);

  045be	4c 8b 8c 24 08
	04 00 00	 mov	 r9, QWORD PTR unitstat$[rsp]
  045c6	4c 8d 84 24 90
	02 00 00	 lea	 r8, QWORD PTR key$[rsp]
  045ce	0f b6 94 24 c8
	03 00 00	 movzx	 edx, BYTE PTR code$[rsp]
  045d6	48 8b 8c 24 c0
	03 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  045de	e8 00 00 00 00	 call	 ckd_read_key
  045e3	89 44 24 60	 mov	 DWORD PTR rc$[rsp], eax

; 3814 :         if (rc < 0) break;

  045e7	83 7c 24 60 00	 cmp	 DWORD PTR rc$[rsp], 0
  045ec	7d 05		 jge	 SHORT $LN279@ckd_dasd_e
  045ee	e9 5d 5f 00 00	 jmp	 $LN2@ckd_dasd_e
$LN279@ckd_dasd_e:

; 3815 : 
; 3816 :         /* Calculate number of compare bytes and set residual count */
; 3817 :         num = (count < (U32)dev->ckdcurkl) ?

  045f3	48 8b 84 24 c0
	03 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  045fb	8b 80 d4 12 00
	00		 mov	 eax, DWORD PTR [rax+4820]
  04601	39 84 24 e0 03
	00 00		 cmp	 DWORD PTR count$[rsp], eax
  04608	73 10		 jae	 SHORT $LN701@ckd_dasd_e
  0460a	8b 84 24 e0 03
	00 00		 mov	 eax, DWORD PTR count$[rsp]
  04611	89 84 24 48 01
	00 00		 mov	 DWORD PTR tv2221[rsp], eax
  04618	eb 15		 jmp	 SHORT $LN702@ckd_dasd_e
$LN701@ckd_dasd_e:
  0461a	48 8b 84 24 c0
	03 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  04622	8b 80 d4 12 00
	00		 mov	 eax, DWORD PTR [rax+4820]
  04628	89 84 24 48 01
	00 00		 mov	 DWORD PTR tv2221[rsp], eax
$LN702@ckd_dasd_e:
  0462f	8b 84 24 48 01
	00 00		 mov	 eax, DWORD PTR tv2221[rsp]
  04636	89 44 24 64	 mov	 DWORD PTR num$[rsp], eax

; 3818 :                count : (U32)dev->ckdcurkl;
; 3819 :         *residual = count - num;

  0463a	8b 44 24 64	 mov	 eax, DWORD PTR num$[rsp]
  0463e	8b 8c 24 e0 03
	00 00		 mov	 ecx, DWORD PTR count$[rsp]
  04645	2b c8		 sub	 ecx, eax
  04647	8b c1		 mov	 eax, ecx
  04649	48 8b 8c 24 10
	04 00 00	 mov	 rcx, QWORD PTR residual$[rsp]
  04651	89 01		 mov	 DWORD PTR [rcx], eax

; 3820 : 
; 3821 :         /* Nothing to compare if key length is zero */
; 3822 :         if (dev->ckdcurkl == 0)

  04653	48 8b 84 24 c0
	03 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  0465b	83 b8 d4 12 00
	00 00		 cmp	 DWORD PTR [rax+4820], 0
  04662	75 10		 jne	 SHORT $LN280@ckd_dasd_e

; 3823 :         {
; 3824 :             *unitstat = CSW_CE | CSW_DE;

  04664	48 8b 84 24 08
	04 00 00	 mov	 rax, QWORD PTR unitstat$[rsp]
  0466c	c6 00 0c	 mov	 BYTE PTR [rax], 12

; 3825 :             break;

  0466f	e9 dc 5e 00 00	 jmp	 $LN2@ckd_dasd_e
$LN280@ckd_dasd_e:

; 3826 :         }
; 3827 : 
; 3828 :         /* Compare key with search argument */
; 3829 :         rc = memcmp(key, iobuf, num);

  04674	8b 44 24 64	 mov	 eax, DWORD PTR num$[rsp]
  04678	44 8b c0	 mov	 r8d, eax
  0467b	48 8b 94 24 f8
	03 00 00	 mov	 rdx, QWORD PTR iobuf$[rsp]
  04683	48 8d 8c 24 90
	02 00 00	 lea	 rcx, QWORD PTR key$[rsp]
  0468b	e8 00 00 00 00	 call	 memcmp
  04690	89 44 24 60	 mov	 DWORD PTR rc$[rsp], eax

; 3830 : 
; 3831 :         /* Return status modifier if compare result matches */
; 3832 :         if (((code & 0x20) && (rc == 0))
; 3833 :             || ((code & 0x40) && (rc > 0)))

  04694	0f b6 84 24 c8
	03 00 00	 movzx	 eax, BYTE PTR code$[rsp]
  0469c	83 e0 20	 and	 eax, 32			; 00000020H
  0469f	85 c0		 test	 eax, eax
  046a1	74 07		 je	 SHORT $LN284@ckd_dasd_e
  046a3	83 7c 24 60 00	 cmp	 DWORD PTR rc$[rsp], 0
  046a8	74 16		 je	 SHORT $LN283@ckd_dasd_e
$LN284@ckd_dasd_e:
  046aa	0f b6 84 24 c8
	03 00 00	 movzx	 eax, BYTE PTR code$[rsp]
  046b2	83 e0 40	 and	 eax, 64			; 00000040H
  046b5	85 c0		 test	 eax, eax
  046b7	74 14		 je	 SHORT $LN281@ckd_dasd_e
  046b9	83 7c 24 60 00	 cmp	 DWORD PTR rc$[rsp], 0
  046be	7e 0d		 jle	 SHORT $LN281@ckd_dasd_e
$LN283@ckd_dasd_e:

; 3834 :             *unitstat = CSW_SM | CSW_CE | CSW_DE;

  046c0	48 8b 84 24 08
	04 00 00	 mov	 rax, QWORD PTR unitstat$[rsp]
  046c8	c6 00 4c	 mov	 BYTE PTR [rax], 76	; 0000004cH
  046cb	eb 0b		 jmp	 SHORT $LN282@ckd_dasd_e
$LN281@ckd_dasd_e:

; 3835 :         else
; 3836 :             *unitstat = CSW_CE | CSW_DE;

  046cd	48 8b 84 24 08
	04 00 00	 mov	 rax, QWORD PTR unitstat$[rsp]
  046d5	c6 00 0c	 mov	 BYTE PTR [rax], 12
$LN282@ckd_dasd_e:

; 3837 : 
; 3838 :         /* If the search was successful, trace the first 8 bytes of
; 3839 :            the key, which will usually be a dataset name or member
; 3840 :            name and can provide useful debugging information */
; 3841 :         if ((*unitstat & CSW_SM) && dev->ckdkeytrace
; 3842 :             && isprint(guest_to_host(iobuf[0])))

  046d8	48 8b 84 24 08
	04 00 00	 mov	 rax, QWORD PTR unitstat$[rsp]
  046e0	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  046e3	83 e0 40	 and	 eax, 64			; 00000040H
  046e6	85 c0		 test	 eax, eax
  046e8	0f 84 d3 01 00
	00		 je	 $LN285@ckd_dasd_e
  046ee	48 8b 84 24 c0
	03 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  046f6	8b 80 f8 05 00
	00		 mov	 eax, DWORD PTR [rax+1528]
  046fc	c1 e8 02	 shr	 eax, 2
  046ff	83 e0 01	 and	 eax, 1
  04702	85 c0		 test	 eax, eax
  04704	0f 84 b7 01 00
	00		 je	 $LN285@ckd_dasd_e
  0470a	b8 01 00 00 00	 mov	 eax, 1
  0470f	48 6b c0 00	 imul	 rax, rax, 0
  04713	48 8b 8c 24 f8
	03 00 00	 mov	 rcx, QWORD PTR iobuf$[rsp]
  0471b	0f b6 0c 01	 movzx	 ecx, BYTE PTR [rcx+rax]
  0471f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_guest_to_host
  04725	0f b6 c0	 movzx	 eax, al
  04728	8b c8		 mov	 ecx, eax
  0472a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_isprint
  04730	85 c0		 test	 eax, eax
  04732	0f 84 89 01 00
	00		 je	 $LN285@ckd_dasd_e

; 3843 :         {
; 3844 :             BYTE module[45];
; 3845 :             size_t kl = MIN( (size_t)num, sizeof( module ) - 1 );

  04738	8b 44 24 64	 mov	 eax, DWORD PTR num$[rsp]
  0473c	48 83 f8 2c	 cmp	 rax, 44			; 0000002cH
  04740	73 0e		 jae	 SHORT $LN703@ckd_dasd_e
  04742	8b 44 24 64	 mov	 eax, DWORD PTR num$[rsp]
  04746	48 89 84 24 00
	02 00 00	 mov	 QWORD PTR tv2258[rsp], rax
  0474e	eb 0c		 jmp	 SHORT $LN704@ckd_dasd_e
$LN703@ckd_dasd_e:
  04750	48 c7 84 24 00
	02 00 00 2c 00
	00 00		 mov	 QWORD PTR tv2258[rsp], 44 ; 0000002cH
$LN704@ckd_dasd_e:
  0475c	48 8b 84 24 00
	02 00 00	 mov	 rax, QWORD PTR tv2258[rsp]
  04764	48 89 84 24 08
	02 00 00	 mov	 QWORD PTR kl$16[rsp], rax

; 3846 : 
; 3847 :             if (sysblk.traceFILE)

  0476c	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  04773	48 83 b8 20 14
	00 00 00	 cmp	 QWORD PTR [rax+5152], 0
  0477b	74 23		 je	 SHORT $LN286@ckd_dasd_e

; 3848 :                 tf_0423( dev, kl, iobuf );

  0477d	4c 8b 84 24 f8
	03 00 00	 mov	 r8, QWORD PTR iobuf$[rsp]
  04785	48 8b 94 24 08
	02 00 00	 mov	 rdx, QWORD PTR kl$16[rsp]
  0478d	48 8b 8c 24 c0
	03 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  04795	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_tf_0423
  0479b	e9 21 01 00 00	 jmp	 $LN287@ckd_dasd_e
$LN286@ckd_dasd_e:

; 3849 :             else
; 3850 :             {
; 3851 :                 str_guest_to_host( iobuf, module, (u_int)kl );

  047a0	44 8b 84 24 08
	02 00 00	 mov	 r8d, DWORD PTR kl$16[rsp]
  047a8	48 8d 94 24 58
	02 00 00	 lea	 rdx, QWORD PTR module$17[rsp]
  047b0	48 8b 8c 24 f8
	03 00 00	 mov	 rcx, QWORD PTR iobuf$[rsp]
  047b8	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_str_guest_to_host

; 3852 :                 // "%1d:%04X CKD file %s: search key %s"
; 3853 :                 WRMSG( HHC00423, "I", LCSS_DEVNUM, dev->filename, RTRIM( module ));

  047be	48 83 bc 24 c0
	03 00 00 00	 cmp	 QWORD PTR dev$[rsp], 0
  047c7	74 15		 je	 SHORT $LN705@ckd_dasd_e
  047c9	48 8b 84 24 c0
	03 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  047d1	0f b7 40 48	 movzx	 eax, WORD PTR [rax+72]
  047d5	89 84 24 4c 01
	00 00		 mov	 DWORD PTR tv2276[rsp], eax
  047dc	eb 0b		 jmp	 SHORT $LN706@ckd_dasd_e
$LN705@ckd_dasd_e:
  047de	c7 84 24 4c 01
	00 00 00 00 00
	00		 mov	 DWORD PTR tv2276[rsp], 0
$LN706@ckd_dasd_e:
  047e9	48 83 bc 24 c0
	03 00 00 00	 cmp	 QWORD PTR dev$[rsp], 0
  047f2	74 17		 je	 SHORT $LN707@ckd_dasd_e
  047f4	48 8b 84 24 c0
	03 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  047fc	0f b7 40 44	 movzx	 eax, WORD PTR [rax+68]
  04800	d1 f8		 sar	 eax, 1
  04802	89 84 24 50 01
	00 00		 mov	 DWORD PTR tv2282[rsp], eax
  04809	eb 0b		 jmp	 SHORT $LN708@ckd_dasd_e
$LN707@ckd_dasd_e:
  0480b	c7 84 24 50 01
	00 00 00 00 00
	00		 mov	 DWORD PTR tv2282[rsp], 0
$LN708@ckd_dasd_e:
  04816	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG171925
  0481d	48 8d 8c 24 58
	02 00 00	 lea	 rcx, QWORD PTR module$17[rsp]
  04825	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_rtrim
  0482b	48 89 84 24 28
	02 00 00	 mov	 QWORD PTR tv2261[rsp], rax
  04833	48 8b 8c 24 c0
	03 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  0483b	48 81 c1 a4 00
	00 00		 add	 rcx, 164		; 000000a4H
  04842	48 89 8c 24 30
	02 00 00	 mov	 QWORD PTR tv2271[rsp], rcx
  0484a	b9 01 00 00 00	 mov	 ecx, 1
  0484f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  04855	48 8b 8c 24 28
	02 00 00	 mov	 rcx, QWORD PTR tv2261[rsp]
  0485d	48 89 4c 24 50	 mov	 QWORD PTR [rsp+80], rcx
  04862	48 8b 8c 24 30
	02 00 00	 mov	 rcx, QWORD PTR tv2271[rsp]
  0486a	48 89 4c 24 48	 mov	 QWORD PTR [rsp+72], rcx
  0486f	8b 8c 24 4c 01
	00 00		 mov	 ecx, DWORD PTR tv2276[rsp]
  04876	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  0487a	8b 8c 24 50 01
	00 00		 mov	 ecx, DWORD PTR tv2282[rsp]
  04881	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  04885	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG171926
  0488c	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  04891	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG171927
  04898	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  0489d	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  048a2	41 b9 03 00 00
	00		 mov	 r9d, 3
  048a8	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG171928
  048af	ba 0d 0f 00 00	 mov	 edx, 3853		; 00000f0dH
  048b4	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG171929
  048bb	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg
$LN287@ckd_dasd_e:
$LN285@ckd_dasd_e:

; 3854 :             }
; 3855 :         }
; 3856 : 
; 3857 :         /* Set flag if entire key was equal for SEARCH KEY EQUAL */
; 3858 :         if (rc == 0 && num == (U32)dev->ckdcurkl && (code & 0x7F) == 0x29)

  048c1	83 7c 24 60 00	 cmp	 DWORD PTR rc$[rsp], 0
  048c6	75 46		 jne	 SHORT $LN288@ckd_dasd_e
  048c8	48 8b 84 24 c0
	03 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  048d0	8b 80 d4 12 00
	00		 mov	 eax, DWORD PTR [rax+4820]
  048d6	39 44 24 64	 cmp	 DWORD PTR num$[rsp], eax
  048da	75 32		 jne	 SHORT $LN288@ckd_dasd_e
  048dc	0f b6 84 24 c8
	03 00 00	 movzx	 eax, BYTE PTR code$[rsp]
  048e4	83 e0 7f	 and	 eax, 127		; 0000007fH
  048e7	83 f8 29	 cmp	 eax, 41			; 00000029H
  048ea	75 22		 jne	 SHORT $LN288@ckd_dasd_e

; 3859 :             dev->ckdkyeq = 1;

  048ec	48 8b 84 24 c0
	03 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  048f4	8b 80 14 13 00
	00		 mov	 eax, DWORD PTR [rax+4884]
  048fa	0f ba e8 0d	 bts	 eax, 13
  048fe	48 8b 8c 24 c0
	03 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  04906	89 81 14 13 00
	00		 mov	 DWORD PTR [rcx+4884], eax
  0490c	eb 20		 jmp	 SHORT $LN289@ckd_dasd_e
$LN288@ckd_dasd_e:

; 3860 :         else
; 3861 :             dev->ckdkyeq = 0;

  0490e	48 8b 84 24 c0
	03 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  04916	8b 80 14 13 00
	00		 mov	 eax, DWORD PTR [rax+4884]
  0491c	0f ba f0 0d	 btr	 eax, 13
  04920	48 8b 8c 24 c0
	03 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  04928	89 81 14 13 00
	00		 mov	 DWORD PTR [rcx+4884], eax
$LN289@ckd_dasd_e:

; 3862 : 
; 3863 :         break;

  0492e	e9 1d 5c 00 00	 jmp	 $LN2@ckd_dasd_e
$LN290@ckd_dasd_e:
$LN291@ckd_dasd_e:
$LN292@ckd_dasd_e:
$LN293@ckd_dasd_e:
$LN294@ckd_dasd_e:
$LN295@ckd_dasd_e:

; 3864 : 
; 3865 :     case 0x31: case 0xB1: /* SEARCH ID EQUAL */
; 3866 :     case 0x51: case 0xD1: /* SEARCH ID HIGH */
; 3867 :     case 0x71: case 0xF1: /* SEARCH ID EQUAL OR HIGH */
; 3868 :     /*---------------------------------------------------------------*/
; 3869 :     /* SEARCH ID                                                     */
; 3870 :     /*---------------------------------------------------------------*/
; 3871 :         /* For 3990, command reject if not preceded by Seek, Seek Cyl,
; 3872 :            Locate Record, Read IPL, or Recalibrate command */
; 3873 :         if (dev->ckd3990
; 3874 :             && dev->ckdseek == 0 && dev->ckdskcyl == 0
; 3875 :             && dev->ckdlocat == 0 && dev->ckdrdipl == 0
; 3876 :             && dev->ckdrecal == 0)

  04933	48 8b 84 24 c0
	03 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  0493b	8b 80 14 13 00
	00		 mov	 eax, DWORD PTR [rax+4884]
  04941	83 e0 01	 and	 eax, 1
  04944	85 c0		 test	 eax, eax
  04946	0f 84 ab 00 00
	00		 je	 $LN296@ckd_dasd_e
  0494c	48 8b 84 24 c0
	03 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  04954	8b 80 14 13 00
	00		 mov	 eax, DWORD PTR [rax+4884]
  0495a	c1 e8 06	 shr	 eax, 6
  0495d	83 e0 01	 and	 eax, 1
  04960	85 c0		 test	 eax, eax
  04962	0f 85 8f 00 00
	00		 jne	 $LN296@ckd_dasd_e
  04968	48 8b 84 24 c0
	03 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  04970	8b 80 14 13 00
	00		 mov	 eax, DWORD PTR [rax+4884]
  04976	c1 e8 07	 shr	 eax, 7
  04979	83 e0 01	 and	 eax, 1
  0497c	85 c0		 test	 eax, eax
  0497e	75 77		 jne	 SHORT $LN296@ckd_dasd_e
  04980	48 8b 84 24 c0
	03 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  04988	8b 80 14 13 00
	00		 mov	 eax, DWORD PTR [rax+4884]
  0498e	c1 e8 03	 shr	 eax, 3
  04991	83 e0 01	 and	 eax, 1
  04994	85 c0		 test	 eax, eax
  04996	75 5f		 jne	 SHORT $LN296@ckd_dasd_e
  04998	48 8b 84 24 c0
	03 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  049a0	8b 80 14 13 00
	00		 mov	 eax, DWORD PTR [rax+4884]
  049a6	c1 e8 09	 shr	 eax, 9
  049a9	83 e0 01	 and	 eax, 1
  049ac	85 c0		 test	 eax, eax
  049ae	75 47		 jne	 SHORT $LN296@ckd_dasd_e
  049b0	48 8b 84 24 c0
	03 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  049b8	8b 80 14 13 00
	00		 mov	 eax, DWORD PTR [rax+4884]
  049be	c1 e8 08	 shr	 eax, 8
  049c1	83 e0 01	 and	 eax, 1
  049c4	85 c0		 test	 eax, eax
  049c6	75 2f		 jne	 SHORT $LN296@ckd_dasd_e

; 3877 :         {
; 3878 :             ckd_build_sense (dev, SENSE_CR, 0, 0,

  049c8	c6 44 24 28 02	 mov	 BYTE PTR [rsp+40], 2
  049cd	c6 44 24 20 00	 mov	 BYTE PTR [rsp+32], 0
  049d2	45 33 c9	 xor	 r9d, r9d
  049d5	45 33 c0	 xor	 r8d, r8d
  049d8	b2 80		 mov	 dl, 128			; 00000080H
  049da	48 8b 8c 24 c0
	03 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  049e2	e8 00 00 00 00	 call	 ckd_build_sense

; 3879 :                             FORMAT_0, MESSAGE_2);
; 3880 :             *unitstat = CSW_CE | CSW_DE | CSW_UC;

  049e7	48 8b 84 24 08
	04 00 00	 mov	 rax, QWORD PTR unitstat$[rsp]
  049ef	c6 00 0e	 mov	 BYTE PTR [rax], 14

; 3881 :             break;

  049f2	e9 59 5b 00 00	 jmp	 $LN2@ckd_dasd_e
$LN296@ckd_dasd_e:

; 3882 :         }
; 3883 : 
; 3884 :         /* Command reject if within the domain of a Locate Record */
; 3885 :         if (dev->ckdlcount > 0)

  049f7	48 8b 84 24 c0
	03 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  049ff	0f b6 80 02 13
	00 00		 movzx	 eax, BYTE PTR [rax+4866]
  04a06	85 c0		 test	 eax, eax
  04a08	7e 2f		 jle	 SHORT $LN297@ckd_dasd_e

; 3886 :         {
; 3887 :             ckd_build_sense (dev, SENSE_CR, 0, 0,

  04a0a	c6 44 24 28 02	 mov	 BYTE PTR [rsp+40], 2
  04a0f	c6 44 24 20 00	 mov	 BYTE PTR [rsp+32], 0
  04a14	45 33 c9	 xor	 r9d, r9d
  04a17	45 33 c0	 xor	 r8d, r8d
  04a1a	b2 80		 mov	 dl, 128			; 00000080H
  04a1c	48 8b 8c 24 c0
	03 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  04a24	e8 00 00 00 00	 call	 ckd_build_sense

; 3888 :                             FORMAT_0, MESSAGE_2);
; 3889 :             *unitstat = CSW_CE | CSW_DE | CSW_UC;

  04a29	48 8b 84 24 08
	04 00 00	 mov	 rax, QWORD PTR unitstat$[rsp]
  04a31	c6 00 0e	 mov	 BYTE PTR [rax], 14

; 3890 :             break;

  04a34	e9 17 5b 00 00	 jmp	 $LN2@ckd_dasd_e
$LN297@ckd_dasd_e:

; 3891 :         }
; 3892 : 
; 3893 :         /* Read next count field */
; 3894 :         rc = ckd_read_count (dev, code, &rechdr, unitstat);

  04a39	4c 8b 8c 24 08
	04 00 00	 mov	 r9, QWORD PTR unitstat$[rsp]
  04a41	4c 8d 84 24 38
	02 00 00	 lea	 r8, QWORD PTR rechdr$[rsp]
  04a49	0f b6 94 24 c8
	03 00 00	 movzx	 edx, BYTE PTR code$[rsp]
  04a51	48 8b 8c 24 c0
	03 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  04a59	e8 00 00 00 00	 call	 ckd_read_count
  04a5e	89 44 24 60	 mov	 DWORD PTR rc$[rsp], eax

; 3895 :         if (rc < 0) break;

  04a62	83 7c 24 60 00	 cmp	 DWORD PTR rc$[rsp], 0
  04a67	7d 05		 jge	 SHORT $LN298@ckd_dasd_e
  04a69	e9 e2 5a 00 00	 jmp	 $LN2@ckd_dasd_e
$LN298@ckd_dasd_e:

; 3896 : 
; 3897 :         /* Calculate number of compare bytes and set residual count */
; 3898 :         num = (count < 5) ? count : 5;

  04a6e	83 bc 24 e0 03
	00 00 05	 cmp	 DWORD PTR count$[rsp], 5
  04a76	73 10		 jae	 SHORT $LN709@ckd_dasd_e
  04a78	8b 84 24 e0 03
	00 00		 mov	 eax, DWORD PTR count$[rsp]
  04a7f	89 84 24 54 01
	00 00		 mov	 DWORD PTR tv2350[rsp], eax
  04a86	eb 0b		 jmp	 SHORT $LN710@ckd_dasd_e
$LN709@ckd_dasd_e:
  04a88	c7 84 24 54 01
	00 00 05 00 00
	00		 mov	 DWORD PTR tv2350[rsp], 5
$LN710@ckd_dasd_e:
  04a93	8b 84 24 54 01
	00 00		 mov	 eax, DWORD PTR tv2350[rsp]
  04a9a	89 44 24 64	 mov	 DWORD PTR num$[rsp], eax

; 3899 :         *residual = count - num;

  04a9e	8b 44 24 64	 mov	 eax, DWORD PTR num$[rsp]
  04aa2	8b 8c 24 e0 03
	00 00		 mov	 ecx, DWORD PTR count$[rsp]
  04aa9	2b c8		 sub	 ecx, eax
  04aab	8b c1		 mov	 eax, ecx
  04aad	48 8b 8c 24 10
	04 00 00	 mov	 rcx, QWORD PTR residual$[rsp]
  04ab5	89 01		 mov	 DWORD PTR [rcx], eax

; 3900 : 
; 3901 :         /* Turn off track overflow flag in record header if present */
; 3902 :         if(dev->ckdcyls < 32768)

  04ab7	48 8b 84 24 c0
	03 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  04abf	81 b8 b8 12 00
	00 00 80 00 00	 cmp	 DWORD PTR [rax+4792], 32768 ; 00008000H
  04ac9	7d 24		 jge	 SHORT $LN299@ckd_dasd_e

; 3903 :             rechdr.cyl[0] &= 0x7F;

  04acb	b8 01 00 00 00	 mov	 eax, 1
  04ad0	48 6b c0 00	 imul	 rax, rax, 0
  04ad4	0f b6 84 04 38
	02 00 00	 movzx	 eax, BYTE PTR rechdr$[rsp+rax]
  04adc	83 e0 7f	 and	 eax, 127		; 0000007fH
  04adf	b9 01 00 00 00	 mov	 ecx, 1
  04ae4	48 6b c9 00	 imul	 rcx, rcx, 0
  04ae8	88 84 0c 38 02
	00 00		 mov	 BYTE PTR rechdr$[rsp+rcx], al
$LN299@ckd_dasd_e:

; 3904 : 
; 3905 :         /* Compare count with search argument */
; 3906 :         rc = memcmp(&rechdr, iobuf, num);

  04aef	8b 44 24 64	 mov	 eax, DWORD PTR num$[rsp]
  04af3	44 8b c0	 mov	 r8d, eax
  04af6	48 8b 94 24 f8
	03 00 00	 mov	 rdx, QWORD PTR iobuf$[rsp]
  04afe	48 8d 8c 24 38
	02 00 00	 lea	 rcx, QWORD PTR rechdr$[rsp]
  04b06	e8 00 00 00 00	 call	 memcmp
  04b0b	89 44 24 60	 mov	 DWORD PTR rc$[rsp], eax

; 3907 : 
; 3908 :         /* Return status modifier if compare result matches */
; 3909 :         if (((code & 0x20) && (rc == 0))
; 3910 :             || ((code & 0x40) && (rc > 0)))

  04b0f	0f b6 84 24 c8
	03 00 00	 movzx	 eax, BYTE PTR code$[rsp]
  04b17	83 e0 20	 and	 eax, 32			; 00000020H
  04b1a	85 c0		 test	 eax, eax
  04b1c	74 07		 je	 SHORT $LN303@ckd_dasd_e
  04b1e	83 7c 24 60 00	 cmp	 DWORD PTR rc$[rsp], 0
  04b23	74 16		 je	 SHORT $LN302@ckd_dasd_e
$LN303@ckd_dasd_e:
  04b25	0f b6 84 24 c8
	03 00 00	 movzx	 eax, BYTE PTR code$[rsp]
  04b2d	83 e0 40	 and	 eax, 64			; 00000040H
  04b30	85 c0		 test	 eax, eax
  04b32	74 14		 je	 SHORT $LN300@ckd_dasd_e
  04b34	83 7c 24 60 00	 cmp	 DWORD PTR rc$[rsp], 0
  04b39	7e 0d		 jle	 SHORT $LN300@ckd_dasd_e
$LN302@ckd_dasd_e:

; 3911 :             *unitstat = CSW_SM | CSW_CE | CSW_DE;

  04b3b	48 8b 84 24 08
	04 00 00	 mov	 rax, QWORD PTR unitstat$[rsp]
  04b43	c6 00 4c	 mov	 BYTE PTR [rax], 76	; 0000004cH
  04b46	eb 0b		 jmp	 SHORT $LN301@ckd_dasd_e
$LN300@ckd_dasd_e:

; 3912 :         else
; 3913 :             *unitstat = CSW_CE | CSW_DE;

  04b48	48 8b 84 24 08
	04 00 00	 mov	 rax, QWORD PTR unitstat$[rsp]
  04b50	c6 00 0c	 mov	 BYTE PTR [rax], 12
$LN301@ckd_dasd_e:

; 3914 : 
; 3915 :         /* Set flag if entire id compared equal for SEARCH ID EQUAL */
; 3916 :         if (rc == 0 && num == 5 && (code & 0x7F) == 0x31)

  04b53	83 7c 24 60 00	 cmp	 DWORD PTR rc$[rsp], 0
  04b58	75 39		 jne	 SHORT $LN304@ckd_dasd_e
  04b5a	83 7c 24 64 05	 cmp	 DWORD PTR num$[rsp], 5
  04b5f	75 32		 jne	 SHORT $LN304@ckd_dasd_e
  04b61	0f b6 84 24 c8
	03 00 00	 movzx	 eax, BYTE PTR code$[rsp]
  04b69	83 e0 7f	 and	 eax, 127		; 0000007fH
  04b6c	83 f8 31	 cmp	 eax, 49			; 00000031H
  04b6f	75 22		 jne	 SHORT $LN304@ckd_dasd_e

; 3917 :             dev->ckdideq = 1;

  04b71	48 8b 84 24 c0
	03 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  04b79	8b 80 14 13 00
	00		 mov	 eax, DWORD PTR [rax+4884]
  04b7f	0f ba e8 0c	 bts	 eax, 12
  04b83	48 8b 8c 24 c0
	03 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  04b8b	89 81 14 13 00
	00		 mov	 DWORD PTR [rcx+4884], eax
  04b91	eb 20		 jmp	 SHORT $LN305@ckd_dasd_e
$LN304@ckd_dasd_e:

; 3918 :         else
; 3919 :             dev->ckdideq = 0;

  04b93	48 8b 84 24 c0
	03 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  04b9b	8b 80 14 13 00
	00		 mov	 eax, DWORD PTR [rax+4884]
  04ba1	0f ba f0 0c	 btr	 eax, 12
  04ba5	48 8b 8c 24 c0
	03 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  04bad	89 81 14 13 00
	00		 mov	 DWORD PTR [rcx+4884], eax
$LN305@ckd_dasd_e:

; 3920 : 
; 3921 :         break;

  04bb3	e9 98 59 00 00	 jmp	 $LN2@ckd_dasd_e
$LN306@ckd_dasd_e:
$LN307@ckd_dasd_e:

; 3922 : 
; 3923 :     case 0x39:
; 3924 :     case 0xB9:
; 3925 :     /*---------------------------------------------------------------*/
; 3926 :     /* SEARCH HOME ADDRESS EQUAL                                     */
; 3927 :     /*---------------------------------------------------------------*/
; 3928 :         /* For 3990, command reject if not preceded by Seek, Seek Cyl,
; 3929 :            Locate Record, Read IPL, or Recalibrate command */
; 3930 :         if (dev->ckd3990
; 3931 :             && dev->ckdseek == 0 && dev->ckdskcyl == 0
; 3932 :             && dev->ckdlocat == 0 && dev->ckdrdipl == 0
; 3933 :             && dev->ckdrecal == 0)

  04bb8	48 8b 84 24 c0
	03 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  04bc0	8b 80 14 13 00
	00		 mov	 eax, DWORD PTR [rax+4884]
  04bc6	83 e0 01	 and	 eax, 1
  04bc9	85 c0		 test	 eax, eax
  04bcb	0f 84 ab 00 00
	00		 je	 $LN308@ckd_dasd_e
  04bd1	48 8b 84 24 c0
	03 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  04bd9	8b 80 14 13 00
	00		 mov	 eax, DWORD PTR [rax+4884]
  04bdf	c1 e8 06	 shr	 eax, 6
  04be2	83 e0 01	 and	 eax, 1
  04be5	85 c0		 test	 eax, eax
  04be7	0f 85 8f 00 00
	00		 jne	 $LN308@ckd_dasd_e
  04bed	48 8b 84 24 c0
	03 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  04bf5	8b 80 14 13 00
	00		 mov	 eax, DWORD PTR [rax+4884]
  04bfb	c1 e8 07	 shr	 eax, 7
  04bfe	83 e0 01	 and	 eax, 1
  04c01	85 c0		 test	 eax, eax
  04c03	75 77		 jne	 SHORT $LN308@ckd_dasd_e
  04c05	48 8b 84 24 c0
	03 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  04c0d	8b 80 14 13 00
	00		 mov	 eax, DWORD PTR [rax+4884]
  04c13	c1 e8 03	 shr	 eax, 3
  04c16	83 e0 01	 and	 eax, 1
  04c19	85 c0		 test	 eax, eax
  04c1b	75 5f		 jne	 SHORT $LN308@ckd_dasd_e
  04c1d	48 8b 84 24 c0
	03 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  04c25	8b 80 14 13 00
	00		 mov	 eax, DWORD PTR [rax+4884]
  04c2b	c1 e8 09	 shr	 eax, 9
  04c2e	83 e0 01	 and	 eax, 1
  04c31	85 c0		 test	 eax, eax
  04c33	75 47		 jne	 SHORT $LN308@ckd_dasd_e
  04c35	48 8b 84 24 c0
	03 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  04c3d	8b 80 14 13 00
	00		 mov	 eax, DWORD PTR [rax+4884]
  04c43	c1 e8 08	 shr	 eax, 8
  04c46	83 e0 01	 and	 eax, 1
  04c49	85 c0		 test	 eax, eax
  04c4b	75 2f		 jne	 SHORT $LN308@ckd_dasd_e

; 3934 :         {
; 3935 :             ckd_build_sense (dev, SENSE_CR, 0, 0,

  04c4d	c6 44 24 28 02	 mov	 BYTE PTR [rsp+40], 2
  04c52	c6 44 24 20 00	 mov	 BYTE PTR [rsp+32], 0
  04c57	45 33 c9	 xor	 r9d, r9d
  04c5a	45 33 c0	 xor	 r8d, r8d
  04c5d	b2 80		 mov	 dl, 128			; 00000080H
  04c5f	48 8b 8c 24 c0
	03 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  04c67	e8 00 00 00 00	 call	 ckd_build_sense

; 3936 :                             FORMAT_0, MESSAGE_2);
; 3937 :             *unitstat = CSW_CE | CSW_DE | CSW_UC;

  04c6c	48 8b 84 24 08
	04 00 00	 mov	 rax, QWORD PTR unitstat$[rsp]
  04c74	c6 00 0e	 mov	 BYTE PTR [rax], 14

; 3938 :             break;

  04c77	e9 d4 58 00 00	 jmp	 $LN2@ckd_dasd_e
$LN308@ckd_dasd_e:

; 3939 :         }
; 3940 : 
; 3941 :         /* Command reject if within the domain of a Locate Record */
; 3942 :         if (dev->ckdlcount > 0)

  04c7c	48 8b 84 24 c0
	03 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  04c84	0f b6 80 02 13
	00 00		 movzx	 eax, BYTE PTR [rax+4866]
  04c8b	85 c0		 test	 eax, eax
  04c8d	7e 2f		 jle	 SHORT $LN309@ckd_dasd_e

; 3943 :         {
; 3944 :             ckd_build_sense (dev, SENSE_CR, 0, 0,

  04c8f	c6 44 24 28 02	 mov	 BYTE PTR [rsp+40], 2
  04c94	c6 44 24 20 00	 mov	 BYTE PTR [rsp+32], 0
  04c99	45 33 c9	 xor	 r9d, r9d
  04c9c	45 33 c0	 xor	 r8d, r8d
  04c9f	b2 80		 mov	 dl, 128			; 00000080H
  04ca1	48 8b 8c 24 c0
	03 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  04ca9	e8 00 00 00 00	 call	 ckd_build_sense

; 3945 :                             FORMAT_0, MESSAGE_2);
; 3946 :             *unitstat = CSW_CE | CSW_DE | CSW_UC;

  04cae	48 8b 84 24 08
	04 00 00	 mov	 rax, QWORD PTR unitstat$[rsp]
  04cb6	c6 00 0e	 mov	 BYTE PTR [rax], 14

; 3947 :             break;

  04cb9	e9 92 58 00 00	 jmp	 $LN2@ckd_dasd_e
$LN309@ckd_dasd_e:

; 3948 :         }
; 3949 : 
; 3950 :         /* For multitrack operation, advance to next track */
; 3951 :         if (code & 0x80)

  04cbe	0f b6 84 24 c8
	03 00 00	 movzx	 eax, BYTE PTR code$[rsp]
  04cc6	25 80 00 00 00	 and	 eax, 128		; 00000080H
  04ccb	85 c0		 test	 eax, eax
  04ccd	74 2b		 je	 SHORT $LN310@ckd_dasd_e

; 3952 :         {
; 3953 :             rc = mt_advance (dev, unitstat, 1);

  04ccf	41 b8 01 00 00
	00		 mov	 r8d, 1
  04cd5	48 8b 94 24 08
	04 00 00	 mov	 rdx, QWORD PTR unitstat$[rsp]
  04cdd	48 8b 8c 24 c0
	03 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  04ce5	e8 00 00 00 00	 call	 mt_advance
  04cea	89 44 24 60	 mov	 DWORD PTR rc$[rsp], eax

; 3954 :             if (rc < 0) break;

  04cee	83 7c 24 60 00	 cmp	 DWORD PTR rc$[rsp], 0
  04cf3	7d 05		 jge	 SHORT $LN311@ckd_dasd_e
  04cf5	e9 56 58 00 00	 jmp	 $LN2@ckd_dasd_e
$LN311@ckd_dasd_e:
$LN310@ckd_dasd_e:

; 3955 :         }
; 3956 : 
; 3957 :         /* Seek to beginning of track */
; 3958 :         rc = ckd_seek (dev, dev->ckdcurcyl, dev->ckdcurhead, &trkhdr, unitstat);

  04cfa	48 8b 84 24 08
	04 00 00	 mov	 rax, QWORD PTR unitstat$[rsp]
  04d02	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  04d07	4c 8d 8c 24 40
	02 00 00	 lea	 r9, QWORD PTR trkhdr$[rsp]
  04d0f	48 8b 84 24 c0
	03 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  04d17	44 8b 80 cc 12
	00 00		 mov	 r8d, DWORD PTR [rax+4812]
  04d1e	48 8b 84 24 c0
	03 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  04d26	8b 90 c8 12 00
	00		 mov	 edx, DWORD PTR [rax+4808]
  04d2c	48 8b 8c 24 c0
	03 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  04d34	e8 00 00 00 00	 call	 ckd_seek
  04d39	89 44 24 60	 mov	 DWORD PTR rc$[rsp], eax

; 3959 :         if (rc < 0) break;

  04d3d	83 7c 24 60 00	 cmp	 DWORD PTR rc$[rsp], 0
  04d42	7d 05		 jge	 SHORT $LN312@ckd_dasd_e
  04d44	e9 07 58 00 00	 jmp	 $LN2@ckd_dasd_e
$LN312@ckd_dasd_e:

; 3960 : 
; 3961 :         /* Calculate number of compare bytes and set residual count */
; 3962 :         num = (count < 4) ? count : 4;

  04d49	83 bc 24 e0 03
	00 00 04	 cmp	 DWORD PTR count$[rsp], 4
  04d51	73 10		 jae	 SHORT $LN711@ckd_dasd_e
  04d53	8b 84 24 e0 03
	00 00		 mov	 eax, DWORD PTR count$[rsp]
  04d5a	89 84 24 58 01
	00 00		 mov	 DWORD PTR tv2443[rsp], eax
  04d61	eb 0b		 jmp	 SHORT $LN712@ckd_dasd_e
$LN711@ckd_dasd_e:
  04d63	c7 84 24 58 01
	00 00 04 00 00
	00		 mov	 DWORD PTR tv2443[rsp], 4
$LN712@ckd_dasd_e:
  04d6e	8b 84 24 58 01
	00 00		 mov	 eax, DWORD PTR tv2443[rsp]
  04d75	89 44 24 64	 mov	 DWORD PTR num$[rsp], eax

; 3963 :         *residual = count - num;

  04d79	8b 44 24 64	 mov	 eax, DWORD PTR num$[rsp]
  04d7d	8b 8c 24 e0 03
	00 00		 mov	 ecx, DWORD PTR count$[rsp]
  04d84	2b c8		 sub	 ecx, eax
  04d86	8b c1		 mov	 eax, ecx
  04d88	48 8b 8c 24 10
	04 00 00	 mov	 rcx, QWORD PTR residual$[rsp]
  04d90	89 01		 mov	 DWORD PTR [rcx], eax

; 3964 : 
; 3965 :         /* Compare CCHH portion of track header with search argument */
; 3966 :         rc = memcmp(&(trkhdr.cyl), iobuf, num);

  04d92	8b 44 24 64	 mov	 eax, DWORD PTR num$[rsp]
  04d96	44 8b c0	 mov	 r8d, eax
  04d99	48 8b 94 24 f8
	03 00 00	 mov	 rdx, QWORD PTR iobuf$[rsp]
  04da1	48 8d 8c 24 41
	02 00 00	 lea	 rcx, QWORD PTR trkhdr$[rsp+1]
  04da9	e8 00 00 00 00	 call	 memcmp
  04dae	89 44 24 60	 mov	 DWORD PTR rc$[rsp], eax

; 3967 : 
; 3968 :         /* Return status modifier if compare result matches */
; 3969 :         if (rc == 0)

  04db2	83 7c 24 60 00	 cmp	 DWORD PTR rc$[rsp], 0
  04db7	75 0d		 jne	 SHORT $LN313@ckd_dasd_e

; 3970 :             *unitstat = CSW_SM | CSW_CE | CSW_DE;

  04db9	48 8b 84 24 08
	04 00 00	 mov	 rax, QWORD PTR unitstat$[rsp]
  04dc1	c6 00 4c	 mov	 BYTE PTR [rax], 76	; 0000004cH
  04dc4	eb 0b		 jmp	 SHORT $LN314@ckd_dasd_e
$LN313@ckd_dasd_e:

; 3971 :         else
; 3972 :             *unitstat = CSW_CE | CSW_DE;

  04dc6	48 8b 84 24 08
	04 00 00	 mov	 rax, QWORD PTR unitstat$[rsp]
  04dce	c6 00 0c	 mov	 BYTE PTR [rax], 12
$LN314@ckd_dasd_e:

; 3973 : 
; 3974 :         /* Set flag if entire home address compared equal */
; 3975 :         if (rc == 0 && num == 4)

  04dd1	83 7c 24 60 00	 cmp	 DWORD PTR rc$[rsp], 0
  04dd6	75 29		 jne	 SHORT $LN315@ckd_dasd_e
  04dd8	83 7c 24 64 04	 cmp	 DWORD PTR num$[rsp], 4
  04ddd	75 22		 jne	 SHORT $LN315@ckd_dasd_e

; 3976 :             dev->ckdhaeq = 1;

  04ddf	48 8b 84 24 c0
	03 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  04de7	8b 80 14 13 00
	00		 mov	 eax, DWORD PTR [rax+4884]
  04ded	0f ba e8 0b	 bts	 eax, 11
  04df1	48 8b 8c 24 c0
	03 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  04df9	89 81 14 13 00
	00		 mov	 DWORD PTR [rcx+4884], eax
  04dff	eb 20		 jmp	 SHORT $LN316@ckd_dasd_e
$LN315@ckd_dasd_e:

; 3977 :         else
; 3978 :             dev->ckdhaeq = 0;

  04e01	48 8b 84 24 c0
	03 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  04e09	8b 80 14 13 00
	00		 mov	 eax, DWORD PTR [rax+4884]
  04e0f	0f ba f0 0b	 btr	 eax, 11
  04e13	48 8b 8c 24 c0
	03 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  04e1b	89 81 14 13 00
	00		 mov	 DWORD PTR [rcx+4884], eax
$LN316@ckd_dasd_e:

; 3979 : 
; 3980 :         break;

  04e21	e9 2a 57 00 00	 jmp	 $LN2@ckd_dasd_e
$LN317@ckd_dasd_e:

; 3981 : 
; 3982 :     case 0x05:
; 3983 :     /*---------------------------------------------------------------*/
; 3984 :     /* WRITE DATA                                                    */
; 3985 :     /*---------------------------------------------------------------*/
; 3986 :         /* Command reject if the current track is in the DSF area */
; 3987 :         if (dev->ckdcurcyl >= dev->ckdcyls)

  04e26	48 8b 84 24 c0
	03 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  04e2e	48 8b 8c 24 c0
	03 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  04e36	8b 89 b8 12 00
	00		 mov	 ecx, DWORD PTR [rcx+4792]
  04e3c	39 88 c8 12 00
	00		 cmp	 DWORD PTR [rax+4808], ecx
  04e42	7c 2f		 jl	 SHORT $LN318@ckd_dasd_e

; 3988 :         {
; 3989 :             ckd_build_sense (dev, SENSE_CR, 0, 0,

  04e44	c6 44 24 28 02	 mov	 BYTE PTR [rsp+40], 2
  04e49	c6 44 24 20 00	 mov	 BYTE PTR [rsp+32], 0
  04e4e	45 33 c9	 xor	 r9d, r9d
  04e51	45 33 c0	 xor	 r8d, r8d
  04e54	b2 80		 mov	 dl, 128			; 00000080H
  04e56	48 8b 8c 24 c0
	03 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  04e5e	e8 00 00 00 00	 call	 ckd_build_sense

; 3990 :                             FORMAT_0, MESSAGE_2);
; 3991 :             *unitstat = CSW_CE | CSW_DE | CSW_UC;

  04e63	48 8b 84 24 08
	04 00 00	 mov	 rax, QWORD PTR unitstat$[rsp]
  04e6b	c6 00 0e	 mov	 BYTE PTR [rax], 14

; 3992 :             break;

  04e6e	e9 dd 56 00 00	 jmp	 $LN2@ckd_dasd_e
$LN318@ckd_dasd_e:

; 3993 :         }
; 3994 : 
; 3995 :         /* Command reject if not within the domain of a Locate Record
; 3996 :            and not preceded by either a Search ID Equal or Search Key
; 3997 :            Equal that compared equal on all bytes */
; 3998 :            /*INCOMPLETE*/ /*Write CKD allows intervening Read/Write
; 3999 :              key and data commands, Write Data does not!!! Rethink
; 4000 :              the handling of these flags*/
; 4001 :         if (dev->ckdlcount == 0 && dev->ckdideq == 0
; 4002 :             && dev->ckdkyeq == 0)

  04e73	48 8b 84 24 c0
	03 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  04e7b	0f b6 80 02 13
	00 00		 movzx	 eax, BYTE PTR [rax+4866]
  04e82	85 c0		 test	 eax, eax
  04e84	75 5f		 jne	 SHORT $LN319@ckd_dasd_e
  04e86	48 8b 84 24 c0
	03 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  04e8e	8b 80 14 13 00
	00		 mov	 eax, DWORD PTR [rax+4884]
  04e94	c1 e8 0c	 shr	 eax, 12
  04e97	83 e0 01	 and	 eax, 1
  04e9a	85 c0		 test	 eax, eax
  04e9c	75 47		 jne	 SHORT $LN319@ckd_dasd_e
  04e9e	48 8b 84 24 c0
	03 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  04ea6	8b 80 14 13 00
	00		 mov	 eax, DWORD PTR [rax+4884]
  04eac	c1 e8 0d	 shr	 eax, 13
  04eaf	83 e0 01	 and	 eax, 1
  04eb2	85 c0		 test	 eax, eax
  04eb4	75 2f		 jne	 SHORT $LN319@ckd_dasd_e

; 4003 :         {
; 4004 :             ckd_build_sense (dev, SENSE_CR, 0, 0,

  04eb6	c6 44 24 28 02	 mov	 BYTE PTR [rsp+40], 2
  04ebb	c6 44 24 20 00	 mov	 BYTE PTR [rsp+32], 0
  04ec0	45 33 c9	 xor	 r9d, r9d
  04ec3	45 33 c0	 xor	 r8d, r8d
  04ec6	b2 80		 mov	 dl, 128			; 00000080H
  04ec8	48 8b 8c 24 c0
	03 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  04ed0	e8 00 00 00 00	 call	 ckd_build_sense

; 4005 :                             FORMAT_0, MESSAGE_2);
; 4006 :             *unitstat = CSW_CE | CSW_DE | CSW_UC;

  04ed5	48 8b 84 24 08
	04 00 00	 mov	 rax, QWORD PTR unitstat$[rsp]
  04edd	c6 00 0e	 mov	 BYTE PTR [rax], 14

; 4007 :             break;

  04ee0	e9 6b 56 00 00	 jmp	 $LN2@ckd_dasd_e
$LN319@ckd_dasd_e:

; 4008 :         }
; 4009 : 
; 4010 :         /* Command reject if file mask inhibits all write commands */
; 4011 :         if ((dev->ckdfmask & CKDMASK_WRCTL) == CKDMASK_WRCTL_INHWRT)

  04ee5	48 8b 84 24 c0
	03 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  04eed	0f b6 80 fa 12
	00 00		 movzx	 eax, BYTE PTR [rax+4858]
  04ef4	25 c0 00 00 00	 and	 eax, 192		; 000000c0H
  04ef9	83 f8 40	 cmp	 eax, 64			; 00000040H
  04efc	75 2f		 jne	 SHORT $LN320@ckd_dasd_e

; 4012 :         {
; 4013 :             ckd_build_sense (dev, SENSE_CR, 0, 0,

  04efe	c6 44 24 28 02	 mov	 BYTE PTR [rsp+40], 2
  04f03	c6 44 24 20 00	 mov	 BYTE PTR [rsp+32], 0
  04f08	45 33 c9	 xor	 r9d, r9d
  04f0b	45 33 c0	 xor	 r8d, r8d
  04f0e	b2 80		 mov	 dl, 128			; 00000080H
  04f10	48 8b 8c 24 c0
	03 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  04f18	e8 00 00 00 00	 call	 ckd_build_sense

; 4014 :                             FORMAT_0, MESSAGE_2);
; 4015 :             *unitstat = CSW_CE | CSW_DE | CSW_UC;

  04f1d	48 8b 84 24 08
	04 00 00	 mov	 rax, QWORD PTR unitstat$[rsp]
  04f25	c6 00 0e	 mov	 BYTE PTR [rax], 14

; 4016 :             break;

  04f28	e9 23 56 00 00	 jmp	 $LN2@ckd_dasd_e
$LN320@ckd_dasd_e:

; 4017 :         }
; 4018 : 
; 4019 :         /* Check operation code if within domain of a Locate Record */
; 4020 :         if (dev->ckdlcount > 0)

  04f2d	48 8b 84 24 c0
	03 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  04f35	0f b6 80 02 13
	00 00		 movzx	 eax, BYTE PTR [rax+4866]
  04f3c	85 c0		 test	 eax, eax
  04f3e	0f 8e 46 01 00
	00		 jle	 $LN321@ckd_dasd_e

; 4021 :         {
; 4022 :             if (!(((dev->ckdloper & CKDOPER_CODE) == CKDOPER_WRITE

  04f44	48 8b 84 24 c0
	03 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  04f4c	0f b6 80 00 13
	00 00		 movzx	 eax, BYTE PTR [rax+4864]
  04f53	83 e0 3f	 and	 eax, 63			; 0000003fH
  04f56	83 f8 01	 cmp	 eax, 1
  04f59	75 46		 jne	 SHORT $LN323@ckd_dasd_e
  04f5b	48 8b 84 24 c0
	03 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  04f63	0f b6 80 01 13
	00 00		 movzx	 eax, BYTE PTR [rax+4865]
  04f6a	83 e0 01	 and	 eax, 1
  04f6d	85 c0		 test	 eax, eax
  04f6f	74 0d		 je	 SHORT $LN713@ckd_dasd_e
  04f71	c7 84 24 5c 01
	00 00 02 00 00
	00		 mov	 DWORD PTR tv2510[rsp], 2
  04f7c	eb 0b		 jmp	 SHORT $LN714@ckd_dasd_e
$LN713@ckd_dasd_e:
  04f7e	c7 84 24 5c 01
	00 00 01 00 00
	00		 mov	 DWORD PTR tv2510[rsp], 1
$LN714@ckd_dasd_e:
  04f89	48 8b 84 24 c0
	03 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  04f91	0f b6 80 02 13
	00 00		 movzx	 eax, BYTE PTR [rax+4866]
  04f98	3b 84 24 5c 01
	00 00		 cmp	 eax, DWORD PTR tv2510[rsp]
  04f9f	74 46		 je	 SHORT $LN322@ckd_dasd_e
$LN323@ckd_dasd_e:
  04fa1	48 8b 84 24 c0
	03 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  04fa9	0f b6 80 00 13
	00 00		 movzx	 eax, BYTE PTR [rax+4864]
  04fb0	83 e0 3f	 and	 eax, 63			; 0000003fH
  04fb3	83 f8 0b	 cmp	 eax, 11
  04fb6	74 2f		 je	 SHORT $LN322@ckd_dasd_e

; 4023 :                        && dev->ckdlcount ==
; 4024 :                            ((dev->ckdlaux & CKDLAUX_RDCNTSUF) ? 2 : 1))
; 4025 :                   || (dev->ckdloper & CKDOPER_CODE) == CKDOPER_WRTTRK))
; 4026 :             {
; 4027 :                 ckd_build_sense (dev, SENSE_CR, 0, 0,

  04fb8	c6 44 24 28 02	 mov	 BYTE PTR [rsp+40], 2
  04fbd	c6 44 24 20 00	 mov	 BYTE PTR [rsp+32], 0
  04fc2	45 33 c9	 xor	 r9d, r9d
  04fc5	45 33 c0	 xor	 r8d, r8d
  04fc8	b2 80		 mov	 dl, 128			; 00000080H
  04fca	48 8b 8c 24 c0
	03 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  04fd2	e8 00 00 00 00	 call	 ckd_build_sense

; 4028 :                                 FORMAT_0, MESSAGE_2);
; 4029 :                 *unitstat = CSW_CE | CSW_DE | CSW_UC;

  04fd7	48 8b 84 24 08
	04 00 00	 mov	 rax, QWORD PTR unitstat$[rsp]
  04fdf	c6 00 0e	 mov	 BYTE PTR [rax], 14

; 4030 :                 break;

  04fe2	e9 69 55 00 00	 jmp	 $LN2@ckd_dasd_e
$LN322@ckd_dasd_e:

; 4031 :             }
; 4032 : 
; 4033 :             /* If not operating in CKD conversion mode, check that the
; 4034 :                data length is equal to the transfer length factor,
; 4035 :                except when writing a R0 data area under the control
; 4036 :                of a Locate Record Write Track operation, in which
; 4037 :                case a transfer length factor of 8 is used instead */
; 4038 :             if ((dev->ckdxgattr & CKDGATR_CKDCONV) == 0)

  04fe7	48 8b 84 24 c0
	03 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  04fef	0f b6 80 fb 12
	00 00		 movzx	 eax, BYTE PTR [rax+4859]
  04ff6	83 e0 20	 and	 eax, 32			; 00000020H
  04ff9	85 c0		 test	 eax, eax
  04ffb	0f 85 89 00 00
	00		 jne	 $LN324@ckd_dasd_e

; 4039 :             {
; 4040 :                 if ((dev->ckdloper & CKDOPER_CODE) == CKDOPER_WRTTRK
; 4041 :                     && dev->ckdcurrec == 0)

  05001	48 8b 84 24 c0
	03 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  05009	0f b6 80 00 13
	00 00		 movzx	 eax, BYTE PTR [rax+4864]
  05010	83 e0 3f	 and	 eax, 63			; 0000003fH
  05013	83 f8 0b	 cmp	 eax, 11
  05016	75 1b		 jne	 SHORT $LN325@ckd_dasd_e
  05018	48 8b 84 24 c0
	03 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  05020	83 b8 d0 12 00
	00 00		 cmp	 DWORD PTR [rax+4816], 0
  05027	75 0a		 jne	 SHORT $LN325@ckd_dasd_e

; 4042 :                     num = 8;

  05029	c7 44 24 64 08
	00 00 00	 mov	 DWORD PTR num$[rsp], 8
  05031	eb 13		 jmp	 SHORT $LN326@ckd_dasd_e
$LN325@ckd_dasd_e:

; 4043 :                 else
; 4044 :                     num = dev->ckdltranlf;

  05033	48 8b 84 24 c0
	03 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  0503b	0f b7 80 fc 12
	00 00		 movzx	 eax, WORD PTR [rax+4860]
  05042	89 44 24 64	 mov	 DWORD PTR num$[rsp], eax
$LN326@ckd_dasd_e:

; 4045 : 
; 4046 :                 if (dev->ckdcurdl != num)

  05046	48 8b 84 24 c0
	03 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  0504e	0f b7 80 ea 12
	00 00		 movzx	 eax, WORD PTR [rax+4842]
  05055	3b 44 24 64	 cmp	 eax, DWORD PTR num$[rsp]
  05059	74 2f		 je	 SHORT $LN327@ckd_dasd_e

; 4047 :                 {
; 4048 :                     /* Unit check with invalid track format */
; 4049 :                     ckd_build_sense (dev, 0, SENSE1_ITF, 0, 0, 0);

  0505b	c6 44 24 28 00	 mov	 BYTE PTR [rsp+40], 0
  05060	c6 44 24 20 00	 mov	 BYTE PTR [rsp+32], 0
  05065	45 33 c9	 xor	 r9d, r9d
  05068	41 b0 40	 mov	 r8b, 64			; 00000040H
  0506b	33 d2		 xor	 edx, edx
  0506d	48 8b 8c 24 c0
	03 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  05075	e8 00 00 00 00	 call	 ckd_build_sense

; 4050 :                     *unitstat = CSW_CE | CSW_DE | CSW_UC;

  0507a	48 8b 84 24 08
	04 00 00	 mov	 rax, QWORD PTR unitstat$[rsp]
  05082	c6 00 0e	 mov	 BYTE PTR [rax], 14

; 4051 :                     break;

  05085	e9 c6 54 00 00	 jmp	 $LN2@ckd_dasd_e
$LN327@ckd_dasd_e:
$LN324@ckd_dasd_e:
$LN321@ckd_dasd_e:

; 4052 :                 }
; 4053 :             }
; 4054 :         } /* end if(ckdlcount) */
; 4055 : 
; 4056 :         /* If data length is zero, terminate with unit exception */
; 4057 :         if (dev->ckdcurdl == 0)

  0508a	48 8b 84 24 c0
	03 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  05092	0f b7 80 ea 12
	00 00		 movzx	 eax, WORD PTR [rax+4842]
  05099	85 c0		 test	 eax, eax
  0509b	75 10		 jne	 SHORT $LN328@ckd_dasd_e

; 4058 :         {
; 4059 :             *unitstat = CSW_CE | CSW_DE | CSW_UX;

  0509d	48 8b 84 24 08
	04 00 00	 mov	 rax, QWORD PTR unitstat$[rsp]
  050a5	c6 00 0d	 mov	 BYTE PTR [rax], 13

; 4060 :             break;

  050a8	e9 a3 54 00 00	 jmp	 $LN2@ckd_dasd_e
$LN328@ckd_dasd_e:

; 4061 :         }
; 4062 : 
; 4063 :         /* Calculate number of bytes written and set residual count */
; 4064 :         size = dev->ckdcurdl;

  050ad	48 8b 84 24 c0
	03 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  050b5	0f b7 80 ea 12
	00 00		 movzx	 eax, WORD PTR [rax+4842]
  050bc	89 44 24 68	 mov	 DWORD PTR size$[rsp], eax

; 4065 :         num = (count < size) ? count : size;

  050c0	8b 44 24 68	 mov	 eax, DWORD PTR size$[rsp]
  050c4	39 84 24 e0 03
	00 00		 cmp	 DWORD PTR count$[rsp], eax
  050cb	73 10		 jae	 SHORT $LN715@ckd_dasd_e
  050cd	8b 84 24 e0 03
	00 00		 mov	 eax, DWORD PTR count$[rsp]
  050d4	89 84 24 60 01
	00 00		 mov	 DWORD PTR tv2549[rsp], eax
  050db	eb 0b		 jmp	 SHORT $LN716@ckd_dasd_e
$LN715@ckd_dasd_e:
  050dd	8b 44 24 68	 mov	 eax, DWORD PTR size$[rsp]
  050e1	89 84 24 60 01
	00 00		 mov	 DWORD PTR tv2549[rsp], eax
$LN716@ckd_dasd_e:
  050e8	8b 84 24 60 01
	00 00		 mov	 eax, DWORD PTR tv2549[rsp]
  050ef	89 44 24 64	 mov	 DWORD PTR num$[rsp], eax

; 4066 :         *residual = count - num;

  050f3	8b 44 24 64	 mov	 eax, DWORD PTR num$[rsp]
  050f7	8b 8c 24 e0 03
	00 00		 mov	 ecx, DWORD PTR count$[rsp]
  050fe	2b c8		 sub	 ecx, eax
  05100	8b c1		 mov	 eax, ecx
  05102	48 8b 8c 24 10
	04 00 00	 mov	 rcx, QWORD PTR residual$[rsp]
  0510a	89 01		 mov	 DWORD PTR [rcx], eax

; 4067 : 
; 4068 :         /* Write data */
; 4069 :         rc = ckd_write_data (dev, iobuf, num, unitstat);

  0510c	4c 8b 8c 24 08
	04 00 00	 mov	 r9, QWORD PTR unitstat$[rsp]
  05114	44 8b 44 24 64	 mov	 r8d, DWORD PTR num$[rsp]
  05119	48 8b 94 24 f8
	03 00 00	 mov	 rdx, QWORD PTR iobuf$[rsp]
  05121	48 8b 8c 24 c0
	03 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  05129	e8 00 00 00 00	 call	 ckd_write_data
  0512e	89 44 24 60	 mov	 DWORD PTR rc$[rsp], eax

; 4070 :         if (rc < 0) break;

  05132	83 7c 24 60 00	 cmp	 DWORD PTR rc$[rsp], 0
  05137	7d 05		 jge	 SHORT $LN329@ckd_dasd_e
  05139	e9 12 54 00 00	 jmp	 $LN2@ckd_dasd_e
$LN329@ckd_dasd_e:

; 4071 : 
; 4072 :         /* If track overflow, keep writing */
; 4073 :         offset = 0;

  0513e	c7 44 24 74 00
	00 00 00	 mov	 DWORD PTR offset$[rsp], 0
$LN28@ckd_dasd_e:

; 4074 :         while (dev->ckdtrkof)

  05146	48 8b 84 24 c0
	03 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  0514e	8b 80 14 13 00
	00		 mov	 eax, DWORD PTR [rax+4884]
  05154	c1 e8 0f	 shr	 eax, 15
  05157	83 e0 01	 and	 eax, 1
  0515a	85 c0		 test	 eax, eax
  0515c	0f 84 17 01 00
	00		 je	 $LN29@ckd_dasd_e

; 4075 :         {
; 4076 :             /* Advance to next track */
; 4077 :             rc = mt_advance (dev, unitstat, 1);

  05162	41 b8 01 00 00
	00		 mov	 r8d, 1
  05168	48 8b 94 24 08
	04 00 00	 mov	 rdx, QWORD PTR unitstat$[rsp]
  05170	48 8b 8c 24 c0
	03 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  05178	e8 00 00 00 00	 call	 mt_advance
  0517d	89 44 24 60	 mov	 DWORD PTR rc$[rsp], eax

; 4078 :             if (rc < 0) break;

  05181	83 7c 24 60 00	 cmp	 DWORD PTR rc$[rsp], 0
  05186	7d 05		 jge	 SHORT $LN330@ckd_dasd_e
  05188	e9 ec 00 00 00	 jmp	 $LN29@ckd_dasd_e
$LN330@ckd_dasd_e:

; 4079 : 
; 4080 :             /* Read the first count field */
; 4081 :             rc = ckd_read_count (dev, code, &rechdr, unitstat);

  0518d	4c 8b 8c 24 08
	04 00 00	 mov	 r9, QWORD PTR unitstat$[rsp]
  05195	4c 8d 84 24 38
	02 00 00	 lea	 r8, QWORD PTR rechdr$[rsp]
  0519d	0f b6 94 24 c8
	03 00 00	 movzx	 edx, BYTE PTR code$[rsp]
  051a5	48 8b 8c 24 c0
	03 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  051ad	e8 00 00 00 00	 call	 ckd_read_count
  051b2	89 44 24 60	 mov	 DWORD PTR rc$[rsp], eax

; 4082 :             if (rc < 0) break;

  051b6	83 7c 24 60 00	 cmp	 DWORD PTR rc$[rsp], 0
  051bb	7d 05		 jge	 SHORT $LN331@ckd_dasd_e
  051bd	e9 b7 00 00 00	 jmp	 $LN29@ckd_dasd_e
$LN331@ckd_dasd_e:

; 4083 : 
; 4084 :             /* Set offset into buffer for this write */
; 4085 :             offset += size;

  051c2	8b 44 24 68	 mov	 eax, DWORD PTR size$[rsp]
  051c6	8b 4c 24 74	 mov	 ecx, DWORD PTR offset$[rsp]
  051ca	03 c8		 add	 ecx, eax
  051cc	8b c1		 mov	 eax, ecx
  051ce	89 44 24 74	 mov	 DWORD PTR offset$[rsp], eax

; 4086 : 
; 4087 :             /* Account for size of this overflow record */
; 4088 :             size = dev->ckdcurdl;

  051d2	48 8b 84 24 c0
	03 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  051da	0f b7 80 ea 12
	00 00		 movzx	 eax, WORD PTR [rax+4842]
  051e1	89 44 24 68	 mov	 DWORD PTR size$[rsp], eax

; 4089 :             num = (*residual < size) ? *residual : size;

  051e5	48 8b 84 24 10
	04 00 00	 mov	 rax, QWORD PTR residual$[rsp]
  051ed	8b 4c 24 68	 mov	 ecx, DWORD PTR size$[rsp]
  051f1	39 08		 cmp	 DWORD PTR [rax], ecx
  051f3	73 13		 jae	 SHORT $LN717@ckd_dasd_e
  051f5	48 8b 84 24 10
	04 00 00	 mov	 rax, QWORD PTR residual$[rsp]
  051fd	8b 00		 mov	 eax, DWORD PTR [rax]
  051ff	89 84 24 64 01
	00 00		 mov	 DWORD PTR tv2576[rsp], eax
  05206	eb 0b		 jmp	 SHORT $LN718@ckd_dasd_e
$LN717@ckd_dasd_e:
  05208	8b 44 24 68	 mov	 eax, DWORD PTR size$[rsp]
  0520c	89 84 24 64 01
	00 00		 mov	 DWORD PTR tv2576[rsp], eax
$LN718@ckd_dasd_e:
  05213	8b 84 24 64 01
	00 00		 mov	 eax, DWORD PTR tv2576[rsp]
  0521a	89 44 24 64	 mov	 DWORD PTR num$[rsp], eax

; 4090 :             *residual -= num;

  0521e	48 8b 84 24 10
	04 00 00	 mov	 rax, QWORD PTR residual$[rsp]
  05226	8b 4c 24 64	 mov	 ecx, DWORD PTR num$[rsp]
  0522a	8b 00		 mov	 eax, DWORD PTR [rax]
  0522c	2b c1		 sub	 eax, ecx
  0522e	48 8b 8c 24 10
	04 00 00	 mov	 rcx, QWORD PTR residual$[rsp]
  05236	89 01		 mov	 DWORD PTR [rcx], eax

; 4091 : 
; 4092 :             /* Write the next data field */
; 4093 :             rc = ckd_write_data (dev, iobuf+offset, num, unitstat);

  05238	8b 44 24 74	 mov	 eax, DWORD PTR offset$[rsp]
  0523c	48 8b 8c 24 f8
	03 00 00	 mov	 rcx, QWORD PTR iobuf$[rsp]
  05244	48 03 c8	 add	 rcx, rax
  05247	48 8b c1	 mov	 rax, rcx
  0524a	4c 8b 8c 24 08
	04 00 00	 mov	 r9, QWORD PTR unitstat$[rsp]
  05252	44 8b 44 24 64	 mov	 r8d, DWORD PTR num$[rsp]
  05257	48 8b d0	 mov	 rdx, rax
  0525a	48 8b 8c 24 c0
	03 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  05262	e8 00 00 00 00	 call	 ckd_write_data
  05267	89 44 24 60	 mov	 DWORD PTR rc$[rsp], eax

; 4094 :             if (rc < 0) break;

  0526b	83 7c 24 60 00	 cmp	 DWORD PTR rc$[rsp], 0
  05270	7d 02		 jge	 SHORT $LN332@ckd_dasd_e
  05272	eb 05		 jmp	 SHORT $LN29@ckd_dasd_e
$LN332@ckd_dasd_e:

; 4095 :         }

  05274	e9 cd fe ff ff	 jmp	 $LN28@ckd_dasd_e
$LN29@ckd_dasd_e:

; 4096 : 
; 4097 :         /* Bail out if track overflow produced I/O error */
; 4098 :         if (rc < 0) break;

  05279	83 7c 24 60 00	 cmp	 DWORD PTR rc$[rsp], 0
  0527e	7d 05		 jge	 SHORT $LN333@ckd_dasd_e
  05280	e9 cb 52 00 00	 jmp	 $LN2@ckd_dasd_e
$LN333@ckd_dasd_e:

; 4099 : 
; 4100 :         /* Return normal status */
; 4101 :         *unitstat = CSW_CE | CSW_DE;

  05285	48 8b 84 24 08
	04 00 00	 mov	 rax, QWORD PTR unitstat$[rsp]
  0528d	c6 00 0c	 mov	 BYTE PTR [rax], 12

; 4102 : 
; 4103 :         break;

  05290	e9 bb 52 00 00	 jmp	 $LN2@ckd_dasd_e
$LN334@ckd_dasd_e:
$LN335@ckd_dasd_e:
$LN336@ckd_dasd_e:

; 4104 : 
; 4105 :     case 0xA5:
; 4106 :     case 0xB5:
; 4107 : //FIXME: 0xA5/0xB5 ccw is undoc'd.  We are treating it as 0x85 except
; 4108 : //       we will allow a DX ccw to follow.
; 4109 :     case 0x85:
; 4110 :     /*---------------------------------------------------------------*/
; 4111 :     /* WRITE UPDATE DATA                                             */
; 4112 :     /*---------------------------------------------------------------*/
; 4113 :         /* Command reject if not within the domain of a Locate Record
; 4114 :            that specifies the Write Data operation code */
; 4115 :         if (dev->ckdlcount == 0
; 4116 :          || ((dev->ckdloper & CKDOPER_CODE) != CKDOPER_WRITE

  05295	48 8b 84 24 c0
	03 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  0529d	0f b6 80 02 13
	00 00		 movzx	 eax, BYTE PTR [rax+4866]
  052a4	85 c0		 test	 eax, eax
  052a6	74 2e		 je	 SHORT $LN338@ckd_dasd_e
  052a8	48 8b 84 24 c0
	03 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  052b0	0f b6 80 00 13
	00 00		 movzx	 eax, BYTE PTR [rax+4864]
  052b7	83 e0 3f	 and	 eax, 63			; 0000003fH
  052ba	83 f8 01	 cmp	 eax, 1
  052bd	74 46		 je	 SHORT $LN337@ckd_dasd_e
  052bf	48 8b 84 24 c0
	03 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  052c7	0f b6 80 00 13
	00 00		 movzx	 eax, BYTE PTR [rax+4864]
  052ce	83 e0 3f	 and	 eax, 63			; 0000003fH
  052d1	83 f8 09	 cmp	 eax, 9
  052d4	74 2f		 je	 SHORT $LN337@ckd_dasd_e
$LN338@ckd_dasd_e:

; 4117 :           && (dev->ckdloper & CKDOPER_CODE) != CKDOPER_WRTANY))
; 4118 :         {
; 4119 :             ckd_build_sense (dev, SENSE_CR, 0, 0,

  052d6	c6 44 24 28 02	 mov	 BYTE PTR [rsp+40], 2
  052db	c6 44 24 20 00	 mov	 BYTE PTR [rsp+32], 0
  052e0	45 33 c9	 xor	 r9d, r9d
  052e3	45 33 c0	 xor	 r8d, r8d
  052e6	b2 80		 mov	 dl, 128			; 00000080H
  052e8	48 8b 8c 24 c0
	03 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  052f0	e8 00 00 00 00	 call	 ckd_build_sense

; 4120 :                             FORMAT_0, MESSAGE_2);
; 4121 :             *unitstat = CSW_CE | CSW_DE | CSW_UC;

  052f5	48 8b 84 24 08
	04 00 00	 mov	 rax, QWORD PTR unitstat$[rsp]
  052fd	c6 00 0e	 mov	 BYTE PTR [rax], 14

; 4122 :             break;

  05300	e9 4b 52 00 00	 jmp	 $LN2@ckd_dasd_e
$LN337@ckd_dasd_e:

; 4123 :         }
; 4124 : 
; 4125 :         /* Orient to next user record count field */
; 4126 :         if (dev->ckdorient != CKDORIENT_COUNT
; 4127 :             || dev->ckdcurrec == 0)

  05305	48 8b 84 24 c0
	03 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  0530d	83 b8 d8 12 00
	00 02		 cmp	 DWORD PTR [rax+4824], 2
  05314	75 11		 jne	 SHORT $LN340@ckd_dasd_e
  05316	48 8b 84 24 c0
	03 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  0531e	83 b8 d0 12 00
	00 00		 cmp	 DWORD PTR [rax+4816], 0
  05325	75 35		 jne	 SHORT $LN339@ckd_dasd_e
$LN340@ckd_dasd_e:

; 4128 :         {
; 4129 :             /* Read next count field */
; 4130 :             rc = ckd_read_count (dev, code, &rechdr, unitstat);

  05327	4c 8b 8c 24 08
	04 00 00	 mov	 r9, QWORD PTR unitstat$[rsp]
  0532f	4c 8d 84 24 38
	02 00 00	 lea	 r8, QWORD PTR rechdr$[rsp]
  05337	0f b6 94 24 c8
	03 00 00	 movzx	 edx, BYTE PTR code$[rsp]
  0533f	48 8b 8c 24 c0
	03 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  05347	e8 00 00 00 00	 call	 ckd_read_count
  0534c	89 44 24 60	 mov	 DWORD PTR rc$[rsp], eax

; 4131 :             if (rc < 0) break;

  05350	83 7c 24 60 00	 cmp	 DWORD PTR rc$[rsp], 0
  05355	7d 05		 jge	 SHORT $LN341@ckd_dasd_e
  05357	e9 f4 51 00 00	 jmp	 $LN2@ckd_dasd_e
$LN341@ckd_dasd_e:
$LN339@ckd_dasd_e:

; 4132 :         }
; 4133 : 
; 4134 :         /* If not operating in CKD conversion mode, check that the
; 4135 :            data length is equal to the transfer length factor */
; 4136 :         if ((dev->ckdxgattr & CKDGATR_CKDCONV) == 0)

  0535c	48 8b 84 24 c0
	03 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  05364	0f b6 80 fb 12
	00 00		 movzx	 eax, BYTE PTR [rax+4859]
  0536b	83 e0 20	 and	 eax, 32			; 00000020H
  0536e	85 c0		 test	 eax, eax
  05370	75 51		 jne	 SHORT $LN342@ckd_dasd_e

; 4137 :         {
; 4138 :             if (dev->ckdcurdl != dev->ckdltranlf)

  05372	48 8b 84 24 c0
	03 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  0537a	0f b7 80 ea 12
	00 00		 movzx	 eax, WORD PTR [rax+4842]
  05381	48 8b 8c 24 c0
	03 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  05389	0f b7 89 fc 12
	00 00		 movzx	 ecx, WORD PTR [rcx+4860]
  05390	3b c1		 cmp	 eax, ecx
  05392	74 2f		 je	 SHORT $LN343@ckd_dasd_e

; 4139 :             {
; 4140 :                 /* Unit check with invalid track format */
; 4141 :                 ckd_build_sense (dev, 0, SENSE1_ITF, 0, 0, 0);

  05394	c6 44 24 28 00	 mov	 BYTE PTR [rsp+40], 0
  05399	c6 44 24 20 00	 mov	 BYTE PTR [rsp+32], 0
  0539e	45 33 c9	 xor	 r9d, r9d
  053a1	41 b0 40	 mov	 r8b, 64			; 00000040H
  053a4	33 d2		 xor	 edx, edx
  053a6	48 8b 8c 24 c0
	03 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  053ae	e8 00 00 00 00	 call	 ckd_build_sense

; 4142 :                 *unitstat = CSW_CE | CSW_DE | CSW_UC;

  053b3	48 8b 84 24 08
	04 00 00	 mov	 rax, QWORD PTR unitstat$[rsp]
  053bb	c6 00 0e	 mov	 BYTE PTR [rax], 14

; 4143 :                 break;

  053be	e9 8d 51 00 00	 jmp	 $LN2@ckd_dasd_e
$LN343@ckd_dasd_e:
$LN342@ckd_dasd_e:

; 4144 :             }
; 4145 :         }
; 4146 : 
; 4147 :         /* If data length is zero, terminate with unit exception */
; 4148 :         if (dev->ckdcurdl == 0)

  053c3	48 8b 84 24 c0
	03 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  053cb	0f b7 80 ea 12
	00 00		 movzx	 eax, WORD PTR [rax+4842]
  053d2	85 c0		 test	 eax, eax
  053d4	75 10		 jne	 SHORT $LN344@ckd_dasd_e

; 4149 :         {
; 4150 :             *unitstat = CSW_CE | CSW_DE | CSW_UX;

  053d6	48 8b 84 24 08
	04 00 00	 mov	 rax, QWORD PTR unitstat$[rsp]
  053de	c6 00 0d	 mov	 BYTE PTR [rax], 13

; 4151 :             break;

  053e1	e9 6a 51 00 00	 jmp	 $LN2@ckd_dasd_e
$LN344@ckd_dasd_e:

; 4152 :         }
; 4153 : 
; 4154 :         /* Calculate number of bytes written and set residual count */
; 4155 :         size = dev->ckdcurdl;

  053e6	48 8b 84 24 c0
	03 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  053ee	0f b7 80 ea 12
	00 00		 movzx	 eax, WORD PTR [rax+4842]
  053f5	89 44 24 68	 mov	 DWORD PTR size$[rsp], eax

; 4156 :         num = (count < size) ? count : size;

  053f9	8b 44 24 68	 mov	 eax, DWORD PTR size$[rsp]
  053fd	39 84 24 e0 03
	00 00		 cmp	 DWORD PTR count$[rsp], eax
  05404	73 10		 jae	 SHORT $LN719@ckd_dasd_e
  05406	8b 84 24 e0 03
	00 00		 mov	 eax, DWORD PTR count$[rsp]
  0540d	89 84 24 68 01
	00 00		 mov	 DWORD PTR tv2635[rsp], eax
  05414	eb 0b		 jmp	 SHORT $LN720@ckd_dasd_e
$LN719@ckd_dasd_e:
  05416	8b 44 24 68	 mov	 eax, DWORD PTR size$[rsp]
  0541a	89 84 24 68 01
	00 00		 mov	 DWORD PTR tv2635[rsp], eax
$LN720@ckd_dasd_e:
  05421	8b 84 24 68 01
	00 00		 mov	 eax, DWORD PTR tv2635[rsp]
  05428	89 44 24 64	 mov	 DWORD PTR num$[rsp], eax

; 4157 :         *residual = count - num;

  0542c	8b 44 24 64	 mov	 eax, DWORD PTR num$[rsp]
  05430	8b 8c 24 e0 03
	00 00		 mov	 ecx, DWORD PTR count$[rsp]
  05437	2b c8		 sub	 ecx, eax
  05439	8b c1		 mov	 eax, ecx
  0543b	48 8b 8c 24 10
	04 00 00	 mov	 rcx, QWORD PTR residual$[rsp]
  05443	89 01		 mov	 DWORD PTR [rcx], eax

; 4158 : 
; 4159 :         /* Write data */
; 4160 :         rc = ckd_write_data (dev, iobuf, num, unitstat);

  05445	4c 8b 8c 24 08
	04 00 00	 mov	 r9, QWORD PTR unitstat$[rsp]
  0544d	44 8b 44 24 64	 mov	 r8d, DWORD PTR num$[rsp]
  05452	48 8b 94 24 f8
	03 00 00	 mov	 rdx, QWORD PTR iobuf$[rsp]
  0545a	48 8b 8c 24 c0
	03 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  05462	e8 00 00 00 00	 call	 ckd_write_data
  05467	89 44 24 60	 mov	 DWORD PTR rc$[rsp], eax

; 4161 :         if (rc < 0) break;

  0546b	83 7c 24 60 00	 cmp	 DWORD PTR rc$[rsp], 0
  05470	7d 05		 jge	 SHORT $LN345@ckd_dasd_e
  05472	e9 d9 50 00 00	 jmp	 $LN2@ckd_dasd_e
$LN345@ckd_dasd_e:

; 4162 : 
; 4163 :         /* If track overflow, keep writing */
; 4164 :         offset = 0;

  05477	c7 44 24 74 00
	00 00 00	 mov	 DWORD PTR offset$[rsp], 0
$LN30@ckd_dasd_e:

; 4165 :         while (dev->ckdtrkof)

  0547f	48 8b 84 24 c0
	03 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  05487	8b 80 14 13 00
	00		 mov	 eax, DWORD PTR [rax+4884]
  0548d	c1 e8 0f	 shr	 eax, 15
  05490	83 e0 01	 and	 eax, 1
  05493	85 c0		 test	 eax, eax
  05495	0f 84 17 01 00
	00		 je	 $LN31@ckd_dasd_e

; 4166 :         {
; 4167 :             /* Advance to next track */
; 4168 :             rc = mt_advance (dev, unitstat, 1);

  0549b	41 b8 01 00 00
	00		 mov	 r8d, 1
  054a1	48 8b 94 24 08
	04 00 00	 mov	 rdx, QWORD PTR unitstat$[rsp]
  054a9	48 8b 8c 24 c0
	03 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  054b1	e8 00 00 00 00	 call	 mt_advance
  054b6	89 44 24 60	 mov	 DWORD PTR rc$[rsp], eax

; 4169 :             if (rc < 0) break;

  054ba	83 7c 24 60 00	 cmp	 DWORD PTR rc$[rsp], 0
  054bf	7d 05		 jge	 SHORT $LN346@ckd_dasd_e
  054c1	e9 ec 00 00 00	 jmp	 $LN31@ckd_dasd_e
$LN346@ckd_dasd_e:

; 4170 : 
; 4171 :             /* Read the first count field */
; 4172 :             rc = ckd_read_count (dev, code, &rechdr, unitstat);

  054c6	4c 8b 8c 24 08
	04 00 00	 mov	 r9, QWORD PTR unitstat$[rsp]
  054ce	4c 8d 84 24 38
	02 00 00	 lea	 r8, QWORD PTR rechdr$[rsp]
  054d6	0f b6 94 24 c8
	03 00 00	 movzx	 edx, BYTE PTR code$[rsp]
  054de	48 8b 8c 24 c0
	03 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  054e6	e8 00 00 00 00	 call	 ckd_read_count
  054eb	89 44 24 60	 mov	 DWORD PTR rc$[rsp], eax

; 4173 :             if (rc < 0) break;

  054ef	83 7c 24 60 00	 cmp	 DWORD PTR rc$[rsp], 0
  054f4	7d 05		 jge	 SHORT $LN347@ckd_dasd_e
  054f6	e9 b7 00 00 00	 jmp	 $LN31@ckd_dasd_e
$LN347@ckd_dasd_e:

; 4174 : 
; 4175 :             /* Set offset into buffer for this write */
; 4176 :             offset += size;

  054fb	8b 44 24 68	 mov	 eax, DWORD PTR size$[rsp]
  054ff	8b 4c 24 74	 mov	 ecx, DWORD PTR offset$[rsp]
  05503	03 c8		 add	 ecx, eax
  05505	8b c1		 mov	 eax, ecx
  05507	89 44 24 74	 mov	 DWORD PTR offset$[rsp], eax

; 4177 : 
; 4178 :             /* Account for size of this overflow record */
; 4179 :             size = dev->ckdcurdl;

  0550b	48 8b 84 24 c0
	03 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  05513	0f b7 80 ea 12
	00 00		 movzx	 eax, WORD PTR [rax+4842]
  0551a	89 44 24 68	 mov	 DWORD PTR size$[rsp], eax

; 4180 :             num = (*residual < size) ? *residual : size;

  0551e	48 8b 84 24 10
	04 00 00	 mov	 rax, QWORD PTR residual$[rsp]
  05526	8b 4c 24 68	 mov	 ecx, DWORD PTR size$[rsp]
  0552a	39 08		 cmp	 DWORD PTR [rax], ecx
  0552c	73 13		 jae	 SHORT $LN721@ckd_dasd_e
  0552e	48 8b 84 24 10
	04 00 00	 mov	 rax, QWORD PTR residual$[rsp]
  05536	8b 00		 mov	 eax, DWORD PTR [rax]
  05538	89 84 24 6c 01
	00 00		 mov	 DWORD PTR tv2662[rsp], eax
  0553f	eb 0b		 jmp	 SHORT $LN722@ckd_dasd_e
$LN721@ckd_dasd_e:
  05541	8b 44 24 68	 mov	 eax, DWORD PTR size$[rsp]
  05545	89 84 24 6c 01
	00 00		 mov	 DWORD PTR tv2662[rsp], eax
$LN722@ckd_dasd_e:
  0554c	8b 84 24 6c 01
	00 00		 mov	 eax, DWORD PTR tv2662[rsp]
  05553	89 44 24 64	 mov	 DWORD PTR num$[rsp], eax

; 4181 :             *residual -= num;

  05557	48 8b 84 24 10
	04 00 00	 mov	 rax, QWORD PTR residual$[rsp]
  0555f	8b 4c 24 64	 mov	 ecx, DWORD PTR num$[rsp]
  05563	8b 00		 mov	 eax, DWORD PTR [rax]
  05565	2b c1		 sub	 eax, ecx
  05567	48 8b 8c 24 10
	04 00 00	 mov	 rcx, QWORD PTR residual$[rsp]
  0556f	89 01		 mov	 DWORD PTR [rcx], eax

; 4182 : 
; 4183 :             /* Write the next data field */
; 4184 :             rc = ckd_write_data (dev, iobuf+offset, num, unitstat);

  05571	8b 44 24 74	 mov	 eax, DWORD PTR offset$[rsp]
  05575	48 8b 8c 24 f8
	03 00 00	 mov	 rcx, QWORD PTR iobuf$[rsp]
  0557d	48 03 c8	 add	 rcx, rax
  05580	48 8b c1	 mov	 rax, rcx
  05583	4c 8b 8c 24 08
	04 00 00	 mov	 r9, QWORD PTR unitstat$[rsp]
  0558b	44 8b 44 24 64	 mov	 r8d, DWORD PTR num$[rsp]
  05590	48 8b d0	 mov	 rdx, rax
  05593	48 8b 8c 24 c0
	03 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  0559b	e8 00 00 00 00	 call	 ckd_write_data
  055a0	89 44 24 60	 mov	 DWORD PTR rc$[rsp], eax

; 4185 :             if (rc < 0) break;

  055a4	83 7c 24 60 00	 cmp	 DWORD PTR rc$[rsp], 0
  055a9	7d 02		 jge	 SHORT $LN348@ckd_dasd_e
  055ab	eb 05		 jmp	 SHORT $LN31@ckd_dasd_e
$LN348@ckd_dasd_e:

; 4186 :         }

  055ad	e9 cd fe ff ff	 jmp	 $LN30@ckd_dasd_e
$LN31@ckd_dasd_e:

; 4187 : 
; 4188 :         /* Bail out if track overflow produced I/O error */
; 4189 :         if (rc < 0) break;

  055b2	83 7c 24 60 00	 cmp	 DWORD PTR rc$[rsp], 0
  055b7	7d 05		 jge	 SHORT $LN349@ckd_dasd_e
  055b9	e9 92 4f 00 00	 jmp	 $LN2@ckd_dasd_e
$LN349@ckd_dasd_e:

; 4190 : 
; 4191 :         /* Return normal status */
; 4192 :         *unitstat = CSW_CE | CSW_DE;

  055be	48 8b 84 24 08
	04 00 00	 mov	 rax, QWORD PTR unitstat$[rsp]
  055c6	c6 00 0c	 mov	 BYTE PTR [rax], 12

; 4193 : 
; 4194 :         break;

  055c9	e9 82 4f 00 00	 jmp	 $LN2@ckd_dasd_e
$LN350@ckd_dasd_e:

; 4195 : 
; 4196 :     case 0x0D:
; 4197 :     /*---------------------------------------------------------------*/
; 4198 :     /* WRITE KEY AND DATA                                            */
; 4199 :     /*---------------------------------------------------------------*/
; 4200 :         /* Command reject if the current track is in the DSF area */
; 4201 :         if (dev->ckdcurcyl >= dev->ckdcyls)

  055ce	48 8b 84 24 c0
	03 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  055d6	48 8b 8c 24 c0
	03 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  055de	8b 89 b8 12 00
	00		 mov	 ecx, DWORD PTR [rcx+4792]
  055e4	39 88 c8 12 00
	00		 cmp	 DWORD PTR [rax+4808], ecx
  055ea	7c 2f		 jl	 SHORT $LN351@ckd_dasd_e

; 4202 :         {
; 4203 :             ckd_build_sense (dev, SENSE_CR, 0, 0,

  055ec	c6 44 24 28 02	 mov	 BYTE PTR [rsp+40], 2
  055f1	c6 44 24 20 00	 mov	 BYTE PTR [rsp+32], 0
  055f6	45 33 c9	 xor	 r9d, r9d
  055f9	45 33 c0	 xor	 r8d, r8d
  055fc	b2 80		 mov	 dl, 128			; 00000080H
  055fe	48 8b 8c 24 c0
	03 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  05606	e8 00 00 00 00	 call	 ckd_build_sense

; 4204 :                             FORMAT_0, MESSAGE_2);
; 4205 :             *unitstat = CSW_CE | CSW_DE | CSW_UC;

  0560b	48 8b 84 24 08
	04 00 00	 mov	 rax, QWORD PTR unitstat$[rsp]
  05613	c6 00 0e	 mov	 BYTE PTR [rax], 14

; 4206 :             break;

  05616	e9 35 4f 00 00	 jmp	 $LN2@ckd_dasd_e
$LN351@ckd_dasd_e:

; 4207 :         }
; 4208 : 
; 4209 :         /* Command reject if not within the domain of a Locate Record
; 4210 :            and not preceded by a Search ID Equal that compared equal
; 4211 :            on all bytes */
; 4212 :            /*INCOMPLETE*/ /*Write CKD allows intervening Read/Write
; 4213 :              key and data commands, Write Key Data does not!!! Rethink
; 4214 :              the handling of these flags*/
; 4215 :         if (dev->ckdlcount == 0 && dev->ckdideq == 0)

  0561b	48 8b 84 24 c0
	03 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  05623	0f b6 80 02 13
	00 00		 movzx	 eax, BYTE PTR [rax+4866]
  0562a	85 c0		 test	 eax, eax
  0562c	75 47		 jne	 SHORT $LN352@ckd_dasd_e
  0562e	48 8b 84 24 c0
	03 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  05636	8b 80 14 13 00
	00		 mov	 eax, DWORD PTR [rax+4884]
  0563c	c1 e8 0c	 shr	 eax, 12
  0563f	83 e0 01	 and	 eax, 1
  05642	85 c0		 test	 eax, eax
  05644	75 2f		 jne	 SHORT $LN352@ckd_dasd_e

; 4216 :         {
; 4217 :             ckd_build_sense (dev, SENSE_CR, 0, 0,

  05646	c6 44 24 28 02	 mov	 BYTE PTR [rsp+40], 2
  0564b	c6 44 24 20 00	 mov	 BYTE PTR [rsp+32], 0
  05650	45 33 c9	 xor	 r9d, r9d
  05653	45 33 c0	 xor	 r8d, r8d
  05656	b2 80		 mov	 dl, 128			; 00000080H
  05658	48 8b 8c 24 c0
	03 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  05660	e8 00 00 00 00	 call	 ckd_build_sense

; 4218 :                             FORMAT_0, MESSAGE_2);
; 4219 :             *unitstat = CSW_CE | CSW_DE | CSW_UC;

  05665	48 8b 84 24 08
	04 00 00	 mov	 rax, QWORD PTR unitstat$[rsp]
  0566d	c6 00 0e	 mov	 BYTE PTR [rax], 14

; 4220 :             break;

  05670	e9 db 4e 00 00	 jmp	 $LN2@ckd_dasd_e
$LN352@ckd_dasd_e:

; 4221 :         }
; 4222 : 
; 4223 :         /* Command reject if file mask inhibits all write commands */
; 4224 :         if ((dev->ckdfmask & CKDMASK_WRCTL) == CKDMASK_WRCTL_INHWRT)

  05675	48 8b 84 24 c0
	03 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  0567d	0f b6 80 fa 12
	00 00		 movzx	 eax, BYTE PTR [rax+4858]
  05684	25 c0 00 00 00	 and	 eax, 192		; 000000c0H
  05689	83 f8 40	 cmp	 eax, 64			; 00000040H
  0568c	75 2f		 jne	 SHORT $LN353@ckd_dasd_e

; 4225 :         {
; 4226 :             ckd_build_sense (dev, SENSE_CR, 0, 0,

  0568e	c6 44 24 28 02	 mov	 BYTE PTR [rsp+40], 2
  05693	c6 44 24 20 00	 mov	 BYTE PTR [rsp+32], 0
  05698	45 33 c9	 xor	 r9d, r9d
  0569b	45 33 c0	 xor	 r8d, r8d
  0569e	b2 80		 mov	 dl, 128			; 00000080H
  056a0	48 8b 8c 24 c0
	03 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  056a8	e8 00 00 00 00	 call	 ckd_build_sense

; 4227 :                             FORMAT_0, MESSAGE_2);
; 4228 :             *unitstat = CSW_CE | CSW_DE | CSW_UC;

  056ad	48 8b 84 24 08
	04 00 00	 mov	 rax, QWORD PTR unitstat$[rsp]
  056b5	c6 00 0e	 mov	 BYTE PTR [rax], 14

; 4229 :             break;

  056b8	e9 93 4e 00 00	 jmp	 $LN2@ckd_dasd_e
$LN353@ckd_dasd_e:

; 4230 :         }
; 4231 : 
; 4232 :         /* Check operation code if within domain of a Locate Record */
; 4233 :         if (dev->ckdlcount > 0)

  056bd	48 8b 84 24 c0
	03 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  056c5	0f b6 80 02 13
	00 00		 movzx	 eax, BYTE PTR [rax+4866]
  056cc	85 c0		 test	 eax, eax
  056ce	0f 8e 18 01 00
	00		 jle	 $LN354@ckd_dasd_e

; 4234 :         {
; 4235 :             if (!(((dev->ckdloper & CKDOPER_CODE) == CKDOPER_WRITE

  056d4	48 8b 84 24 c0
	03 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  056dc	0f b6 80 00 13
	00 00		 movzx	 eax, BYTE PTR [rax+4864]
  056e3	83 e0 3f	 and	 eax, 63			; 0000003fH
  056e6	83 f8 01	 cmp	 eax, 1
  056e9	75 46		 jne	 SHORT $LN356@ckd_dasd_e
  056eb	48 8b 84 24 c0
	03 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  056f3	0f b6 80 01 13
	00 00		 movzx	 eax, BYTE PTR [rax+4865]
  056fa	83 e0 01	 and	 eax, 1
  056fd	85 c0		 test	 eax, eax
  056ff	74 0d		 je	 SHORT $LN723@ckd_dasd_e
  05701	c7 84 24 70 01
	00 00 02 00 00
	00		 mov	 DWORD PTR tv2718[rsp], 2
  0570c	eb 0b		 jmp	 SHORT $LN724@ckd_dasd_e
$LN723@ckd_dasd_e:
  0570e	c7 84 24 70 01
	00 00 01 00 00
	00		 mov	 DWORD PTR tv2718[rsp], 1
$LN724@ckd_dasd_e:
  05719	48 8b 84 24 c0
	03 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  05721	0f b6 80 02 13
	00 00		 movzx	 eax, BYTE PTR [rax+4866]
  05728	3b 84 24 70 01
	00 00		 cmp	 eax, DWORD PTR tv2718[rsp]
  0572f	74 46		 je	 SHORT $LN355@ckd_dasd_e
$LN356@ckd_dasd_e:
  05731	48 8b 84 24 c0
	03 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  05739	0f b6 80 00 13
	00 00		 movzx	 eax, BYTE PTR [rax+4864]
  05740	83 e0 3f	 and	 eax, 63			; 0000003fH
  05743	83 f8 0b	 cmp	 eax, 11
  05746	74 2f		 je	 SHORT $LN355@ckd_dasd_e

; 4236 :                        && dev->ckdlcount ==
; 4237 :                            ((dev->ckdlaux & CKDLAUX_RDCNTSUF) ? 2 : 1))
; 4238 :                   || (dev->ckdloper & CKDOPER_CODE) == CKDOPER_WRTTRK))
; 4239 :             {
; 4240 :                 ckd_build_sense (dev, SENSE_CR, 0, 0,

  05748	c6 44 24 28 02	 mov	 BYTE PTR [rsp+40], 2
  0574d	c6 44 24 20 00	 mov	 BYTE PTR [rsp+32], 0
  05752	45 33 c9	 xor	 r9d, r9d
  05755	45 33 c0	 xor	 r8d, r8d
  05758	b2 80		 mov	 dl, 128			; 00000080H
  0575a	48 8b 8c 24 c0
	03 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  05762	e8 00 00 00 00	 call	 ckd_build_sense

; 4241 :                                 FORMAT_0, MESSAGE_2);
; 4242 :                 *unitstat = CSW_CE | CSW_DE | CSW_UC;

  05767	48 8b 84 24 08
	04 00 00	 mov	 rax, QWORD PTR unitstat$[rsp]
  0576f	c6 00 0e	 mov	 BYTE PTR [rax], 14

; 4243 :                 break;

  05772	e9 d9 4d 00 00	 jmp	 $LN2@ckd_dasd_e
$LN355@ckd_dasd_e:

; 4244 :             }
; 4245 : 
; 4246 :             /* If not operating in CKD conversion mode, check that the
; 4247 :                key + data length equals the transfer length factor */
; 4248 :             if ((dev->ckdxgattr & CKDGATR_CKDCONV) == 0
; 4249 :                 && dev->ckdcurkl + dev->ckdcurdl != dev->ckdltranlf)

  05777	48 8b 84 24 c0
	03 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  0577f	0f b6 80 fb 12
	00 00		 movzx	 eax, BYTE PTR [rax+4859]
  05786	83 e0 20	 and	 eax, 32			; 00000020H
  05789	85 c0		 test	 eax, eax
  0578b	75 5f		 jne	 SHORT $LN357@ckd_dasd_e
  0578d	48 8b 84 24 c0
	03 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  05795	0f b7 80 ea 12
	00 00		 movzx	 eax, WORD PTR [rax+4842]
  0579c	48 8b 8c 24 c0
	03 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  057a4	03 81 d4 12 00
	00		 add	 eax, DWORD PTR [rcx+4820]
  057aa	48 8b 8c 24 c0
	03 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  057b2	0f b7 89 fc 12
	00 00		 movzx	 ecx, WORD PTR [rcx+4860]
  057b9	3b c1		 cmp	 eax, ecx
  057bb	74 2f		 je	 SHORT $LN357@ckd_dasd_e

; 4250 :             {
; 4251 :                 /* Unit check with invalid track format */
; 4252 :                 ckd_build_sense (dev, 0, SENSE1_ITF, 0, 0, 0);

  057bd	c6 44 24 28 00	 mov	 BYTE PTR [rsp+40], 0
  057c2	c6 44 24 20 00	 mov	 BYTE PTR [rsp+32], 0
  057c7	45 33 c9	 xor	 r9d, r9d
  057ca	41 b0 40	 mov	 r8b, 64			; 00000040H
  057cd	33 d2		 xor	 edx, edx
  057cf	48 8b 8c 24 c0
	03 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  057d7	e8 00 00 00 00	 call	 ckd_build_sense

; 4253 :                 *unitstat = CSW_CE | CSW_DE | CSW_UC;

  057dc	48 8b 84 24 08
	04 00 00	 mov	 rax, QWORD PTR unitstat$[rsp]
  057e4	c6 00 0e	 mov	 BYTE PTR [rax], 14

; 4254 :                 break;

  057e7	e9 64 4d 00 00	 jmp	 $LN2@ckd_dasd_e
$LN357@ckd_dasd_e:
$LN354@ckd_dasd_e:

; 4255 :             }
; 4256 :         } /* end if(ckdlcount) */
; 4257 : 
; 4258 :         /* If data length is zero, terminate with unit exception */
; 4259 :         if (dev->ckdcurdl == 0)

  057ec	48 8b 84 24 c0
	03 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  057f4	0f b7 80 ea 12
	00 00		 movzx	 eax, WORD PTR [rax+4842]
  057fb	85 c0		 test	 eax, eax
  057fd	75 10		 jne	 SHORT $LN358@ckd_dasd_e

; 4260 :         {
; 4261 :             *unitstat = CSW_CE | CSW_DE | CSW_UX;

  057ff	48 8b 84 24 08
	04 00 00	 mov	 rax, QWORD PTR unitstat$[rsp]
  05807	c6 00 0d	 mov	 BYTE PTR [rax], 13

; 4262 :             break;

  0580a	e9 41 4d 00 00	 jmp	 $LN2@ckd_dasd_e
$LN358@ckd_dasd_e:

; 4263 :         }
; 4264 : 
; 4265 :         /* Calculate number of bytes written and set residual count */
; 4266 :         size = dev->ckdcurkl + dev->ckdcurdl;

  0580f	48 8b 84 24 c0
	03 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  05817	0f b7 80 ea 12
	00 00		 movzx	 eax, WORD PTR [rax+4842]
  0581e	48 8b 8c 24 c0
	03 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  05826	03 81 d4 12 00
	00		 add	 eax, DWORD PTR [rcx+4820]
  0582c	89 44 24 68	 mov	 DWORD PTR size$[rsp], eax

; 4267 :         num = (count < size) ? count : size;

  05830	8b 44 24 68	 mov	 eax, DWORD PTR size$[rsp]
  05834	39 84 24 e0 03
	00 00		 cmp	 DWORD PTR count$[rsp], eax
  0583b	73 10		 jae	 SHORT $LN725@ckd_dasd_e
  0583d	8b 84 24 e0 03
	00 00		 mov	 eax, DWORD PTR count$[rsp]
  05844	89 84 24 74 01
	00 00		 mov	 DWORD PTR tv2755[rsp], eax
  0584b	eb 0b		 jmp	 SHORT $LN726@ckd_dasd_e
$LN725@ckd_dasd_e:
  0584d	8b 44 24 68	 mov	 eax, DWORD PTR size$[rsp]
  05851	89 84 24 74 01
	00 00		 mov	 DWORD PTR tv2755[rsp], eax
$LN726@ckd_dasd_e:
  05858	8b 84 24 74 01
	00 00		 mov	 eax, DWORD PTR tv2755[rsp]
  0585f	89 44 24 64	 mov	 DWORD PTR num$[rsp], eax

; 4268 :         *residual = count - num;

  05863	8b 44 24 64	 mov	 eax, DWORD PTR num$[rsp]
  05867	8b 8c 24 e0 03
	00 00		 mov	 ecx, DWORD PTR count$[rsp]
  0586e	2b c8		 sub	 ecx, eax
  05870	8b c1		 mov	 eax, ecx
  05872	48 8b 8c 24 10
	04 00 00	 mov	 rcx, QWORD PTR residual$[rsp]
  0587a	89 01		 mov	 DWORD PTR [rcx], eax

; 4269 : 
; 4270 :         /* Write key and data */
; 4271 :         rc = ckd_write_kd (dev, iobuf, num, unitstat);

  0587c	4c 8b 8c 24 08
	04 00 00	 mov	 r9, QWORD PTR unitstat$[rsp]
  05884	44 8b 44 24 64	 mov	 r8d, DWORD PTR num$[rsp]
  05889	48 8b 94 24 f8
	03 00 00	 mov	 rdx, QWORD PTR iobuf$[rsp]
  05891	48 8b 8c 24 c0
	03 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  05899	e8 00 00 00 00	 call	 ckd_write_kd
  0589e	89 44 24 60	 mov	 DWORD PTR rc$[rsp], eax

; 4272 :         if (rc < 0) break;

  058a2	83 7c 24 60 00	 cmp	 DWORD PTR rc$[rsp], 0
  058a7	7d 05		 jge	 SHORT $LN359@ckd_dasd_e
  058a9	e9 a2 4c 00 00	 jmp	 $LN2@ckd_dasd_e
$LN359@ckd_dasd_e:

; 4273 : 
; 4274 :         /* If track overflow, keep writing */
; 4275 :         offset = dev->ckdcurkl;

  058ae	48 8b 84 24 c0
	03 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  058b6	8b 80 d4 12 00
	00		 mov	 eax, DWORD PTR [rax+4820]
  058bc	89 44 24 74	 mov	 DWORD PTR offset$[rsp], eax
$LN32@ckd_dasd_e:

; 4276 :         while (dev->ckdtrkof)

  058c0	48 8b 84 24 c0
	03 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  058c8	8b 80 14 13 00
	00		 mov	 eax, DWORD PTR [rax+4884]
  058ce	c1 e8 0f	 shr	 eax, 15
  058d1	83 e0 01	 and	 eax, 1
  058d4	85 c0		 test	 eax, eax
  058d6	0f 84 17 01 00
	00		 je	 $LN33@ckd_dasd_e

; 4277 :         {
; 4278 :             /* Advance to next track */
; 4279 :             rc = mt_advance (dev, unitstat, 1);

  058dc	41 b8 01 00 00
	00		 mov	 r8d, 1
  058e2	48 8b 94 24 08
	04 00 00	 mov	 rdx, QWORD PTR unitstat$[rsp]
  058ea	48 8b 8c 24 c0
	03 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  058f2	e8 00 00 00 00	 call	 mt_advance
  058f7	89 44 24 60	 mov	 DWORD PTR rc$[rsp], eax

; 4280 :             if (rc < 0) break;

  058fb	83 7c 24 60 00	 cmp	 DWORD PTR rc$[rsp], 0
  05900	7d 05		 jge	 SHORT $LN360@ckd_dasd_e
  05902	e9 ec 00 00 00	 jmp	 $LN33@ckd_dasd_e
$LN360@ckd_dasd_e:

; 4281 : 
; 4282 :             /* Read the first count field */
; 4283 :             rc = ckd_read_count (dev, code, &rechdr, unitstat);

  05907	4c 8b 8c 24 08
	04 00 00	 mov	 r9, QWORD PTR unitstat$[rsp]
  0590f	4c 8d 84 24 38
	02 00 00	 lea	 r8, QWORD PTR rechdr$[rsp]
  05917	0f b6 94 24 c8
	03 00 00	 movzx	 edx, BYTE PTR code$[rsp]
  0591f	48 8b 8c 24 c0
	03 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  05927	e8 00 00 00 00	 call	 ckd_read_count
  0592c	89 44 24 60	 mov	 DWORD PTR rc$[rsp], eax

; 4284 :             if (rc < 0) break;

  05930	83 7c 24 60 00	 cmp	 DWORD PTR rc$[rsp], 0
  05935	7d 05		 jge	 SHORT $LN361@ckd_dasd_e
  05937	e9 b7 00 00 00	 jmp	 $LN33@ckd_dasd_e
$LN361@ckd_dasd_e:

; 4285 : 
; 4286 :             /* Set offset into buffer for this write */
; 4287 :             offset += size;

  0593c	8b 44 24 68	 mov	 eax, DWORD PTR size$[rsp]
  05940	8b 4c 24 74	 mov	 ecx, DWORD PTR offset$[rsp]
  05944	03 c8		 add	 ecx, eax
  05946	8b c1		 mov	 eax, ecx
  05948	89 44 24 74	 mov	 DWORD PTR offset$[rsp], eax

; 4288 : 
; 4289 :             /* Account for size of this overflow record */
; 4290 :             size = dev->ckdcurdl;

  0594c	48 8b 84 24 c0
	03 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  05954	0f b7 80 ea 12
	00 00		 movzx	 eax, WORD PTR [rax+4842]
  0595b	89 44 24 68	 mov	 DWORD PTR size$[rsp], eax

; 4291 :             num = (*residual < size) ? *residual : size;

  0595f	48 8b 84 24 10
	04 00 00	 mov	 rax, QWORD PTR residual$[rsp]
  05967	8b 4c 24 68	 mov	 ecx, DWORD PTR size$[rsp]
  0596b	39 08		 cmp	 DWORD PTR [rax], ecx
  0596d	73 13		 jae	 SHORT $LN727@ckd_dasd_e
  0596f	48 8b 84 24 10
	04 00 00	 mov	 rax, QWORD PTR residual$[rsp]
  05977	8b 00		 mov	 eax, DWORD PTR [rax]
  05979	89 84 24 78 01
	00 00		 mov	 DWORD PTR tv2783[rsp], eax
  05980	eb 0b		 jmp	 SHORT $LN728@ckd_dasd_e
$LN727@ckd_dasd_e:
  05982	8b 44 24 68	 mov	 eax, DWORD PTR size$[rsp]
  05986	89 84 24 78 01
	00 00		 mov	 DWORD PTR tv2783[rsp], eax
$LN728@ckd_dasd_e:
  0598d	8b 84 24 78 01
	00 00		 mov	 eax, DWORD PTR tv2783[rsp]
  05994	89 44 24 64	 mov	 DWORD PTR num$[rsp], eax

; 4292 :             *residual -= num;

  05998	48 8b 84 24 10
	04 00 00	 mov	 rax, QWORD PTR residual$[rsp]
  059a0	8b 4c 24 64	 mov	 ecx, DWORD PTR num$[rsp]
  059a4	8b 00		 mov	 eax, DWORD PTR [rax]
  059a6	2b c1		 sub	 eax, ecx
  059a8	48 8b 8c 24 10
	04 00 00	 mov	 rcx, QWORD PTR residual$[rsp]
  059b0	89 01		 mov	 DWORD PTR [rcx], eax

; 4293 : 
; 4294 :             /* Write the next data field */
; 4295 :             rc = ckd_write_data (dev, iobuf+offset, num, unitstat);

  059b2	8b 44 24 74	 mov	 eax, DWORD PTR offset$[rsp]
  059b6	48 8b 8c 24 f8
	03 00 00	 mov	 rcx, QWORD PTR iobuf$[rsp]
  059be	48 03 c8	 add	 rcx, rax
  059c1	48 8b c1	 mov	 rax, rcx
  059c4	4c 8b 8c 24 08
	04 00 00	 mov	 r9, QWORD PTR unitstat$[rsp]
  059cc	44 8b 44 24 64	 mov	 r8d, DWORD PTR num$[rsp]
  059d1	48 8b d0	 mov	 rdx, rax
  059d4	48 8b 8c 24 c0
	03 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  059dc	e8 00 00 00 00	 call	 ckd_write_data
  059e1	89 44 24 60	 mov	 DWORD PTR rc$[rsp], eax

; 4296 :             if (rc < 0) break;

  059e5	83 7c 24 60 00	 cmp	 DWORD PTR rc$[rsp], 0
  059ea	7d 02		 jge	 SHORT $LN362@ckd_dasd_e
  059ec	eb 05		 jmp	 SHORT $LN33@ckd_dasd_e
$LN362@ckd_dasd_e:

; 4297 :         }

  059ee	e9 cd fe ff ff	 jmp	 $LN32@ckd_dasd_e
$LN33@ckd_dasd_e:

; 4298 : 
; 4299 :         /* Bail out if track overflow produced I/O error */
; 4300 :         if (rc < 0) break;

  059f3	83 7c 24 60 00	 cmp	 DWORD PTR rc$[rsp], 0
  059f8	7d 05		 jge	 SHORT $LN363@ckd_dasd_e
  059fa	e9 51 4b 00 00	 jmp	 $LN2@ckd_dasd_e
$LN363@ckd_dasd_e:

; 4301 : 
; 4302 :         /* Return normal status */
; 4303 :         *unitstat = CSW_CE | CSW_DE;

  059ff	48 8b 84 24 08
	04 00 00	 mov	 rax, QWORD PTR unitstat$[rsp]
  05a07	c6 00 0c	 mov	 BYTE PTR [rax], 12

; 4304 : 
; 4305 :         break;

  05a0a	e9 41 4b 00 00	 jmp	 $LN2@ckd_dasd_e
$LN364@ckd_dasd_e:

; 4306 : 
; 4307 :     case 0x8D:
; 4308 :     /*---------------------------------------------------------------*/
; 4309 :     /* WRITE UPDATE KEY AND DATA                                     */
; 4310 :     /*---------------------------------------------------------------*/
; 4311 :         /* Command reject if not within the domain of a Locate Record
; 4312 :            that specifies the Write Data operation code */
; 4313 :         if (dev->ckdlcount == 0
; 4314 :             || (dev->ckdloper & CKDOPER_CODE) != CKDOPER_WRITE)

  05a0f	48 8b 84 24 c0
	03 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  05a17	0f b6 80 02 13
	00 00		 movzx	 eax, BYTE PTR [rax+4866]
  05a1e	85 c0		 test	 eax, eax
  05a20	74 17		 je	 SHORT $LN366@ckd_dasd_e
  05a22	48 8b 84 24 c0
	03 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  05a2a	0f b6 80 00 13
	00 00		 movzx	 eax, BYTE PTR [rax+4864]
  05a31	83 e0 3f	 and	 eax, 63			; 0000003fH
  05a34	83 f8 01	 cmp	 eax, 1
  05a37	74 2f		 je	 SHORT $LN365@ckd_dasd_e
$LN366@ckd_dasd_e:

; 4315 :         {
; 4316 :             ckd_build_sense (dev, SENSE_CR, 0, 0,

  05a39	c6 44 24 28 02	 mov	 BYTE PTR [rsp+40], 2
  05a3e	c6 44 24 20 00	 mov	 BYTE PTR [rsp+32], 0
  05a43	45 33 c9	 xor	 r9d, r9d
  05a46	45 33 c0	 xor	 r8d, r8d
  05a49	b2 80		 mov	 dl, 128			; 00000080H
  05a4b	48 8b 8c 24 c0
	03 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  05a53	e8 00 00 00 00	 call	 ckd_build_sense

; 4317 :                             FORMAT_0, MESSAGE_2);
; 4318 :             *unitstat = CSW_CE | CSW_DE | CSW_UC;

  05a58	48 8b 84 24 08
	04 00 00	 mov	 rax, QWORD PTR unitstat$[rsp]
  05a60	c6 00 0e	 mov	 BYTE PTR [rax], 14

; 4319 :             break;

  05a63	e9 e8 4a 00 00	 jmp	 $LN2@ckd_dasd_e
$LN365@ckd_dasd_e:

; 4320 :         }
; 4321 : 
; 4322 :         /* Orient to next user record count field */
; 4323 :         if (dev->ckdorient != CKDORIENT_COUNT
; 4324 :             || dev->ckdcurrec == 0)

  05a68	48 8b 84 24 c0
	03 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  05a70	83 b8 d8 12 00
	00 02		 cmp	 DWORD PTR [rax+4824], 2
  05a77	75 11		 jne	 SHORT $LN368@ckd_dasd_e
  05a79	48 8b 84 24 c0
	03 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  05a81	83 b8 d0 12 00
	00 00		 cmp	 DWORD PTR [rax+4816], 0
  05a88	75 35		 jne	 SHORT $LN367@ckd_dasd_e
$LN368@ckd_dasd_e:

; 4325 :         {
; 4326 :             /* Read next count field */
; 4327 :             rc = ckd_read_count (dev, code, &rechdr, unitstat);

  05a8a	4c 8b 8c 24 08
	04 00 00	 mov	 r9, QWORD PTR unitstat$[rsp]
  05a92	4c 8d 84 24 38
	02 00 00	 lea	 r8, QWORD PTR rechdr$[rsp]
  05a9a	0f b6 94 24 c8
	03 00 00	 movzx	 edx, BYTE PTR code$[rsp]
  05aa2	48 8b 8c 24 c0
	03 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  05aaa	e8 00 00 00 00	 call	 ckd_read_count
  05aaf	89 44 24 60	 mov	 DWORD PTR rc$[rsp], eax

; 4328 :             if (rc < 0) break;

  05ab3	83 7c 24 60 00	 cmp	 DWORD PTR rc$[rsp], 0
  05ab8	7d 05		 jge	 SHORT $LN369@ckd_dasd_e
  05aba	e9 91 4a 00 00	 jmp	 $LN2@ckd_dasd_e
$LN369@ckd_dasd_e:
$LN367@ckd_dasd_e:

; 4329 :         }
; 4330 : 
; 4331 :         /* If not operating in CKD conversion mode, check that the
; 4332 :            data length is equal to the transfer length factor */
; 4333 :         if ((dev->ckdxgattr & CKDGATR_CKDCONV) == 0)

  05abf	48 8b 84 24 c0
	03 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  05ac7	0f b6 80 fb 12
	00 00		 movzx	 eax, BYTE PTR [rax+4859]
  05ace	83 e0 20	 and	 eax, 32			; 00000020H
  05ad1	85 c0		 test	 eax, eax
  05ad3	75 5f		 jne	 SHORT $LN370@ckd_dasd_e

; 4334 :         {
; 4335 :             if ((dev->ckdcurkl + dev->ckdcurdl) != dev->ckdltranlf)

  05ad5	48 8b 84 24 c0
	03 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  05add	0f b7 80 ea 12
	00 00		 movzx	 eax, WORD PTR [rax+4842]
  05ae4	48 8b 8c 24 c0
	03 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  05aec	03 81 d4 12 00
	00		 add	 eax, DWORD PTR [rcx+4820]
  05af2	48 8b 8c 24 c0
	03 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  05afa	0f b7 89 fc 12
	00 00		 movzx	 ecx, WORD PTR [rcx+4860]
  05b01	3b c1		 cmp	 eax, ecx
  05b03	74 2f		 je	 SHORT $LN371@ckd_dasd_e

; 4336 :             {
; 4337 :                 /* Unit check with invalid track format */
; 4338 :                 ckd_build_sense (dev, 0, SENSE1_ITF, 0, 0, 0);

  05b05	c6 44 24 28 00	 mov	 BYTE PTR [rsp+40], 0
  05b0a	c6 44 24 20 00	 mov	 BYTE PTR [rsp+32], 0
  05b0f	45 33 c9	 xor	 r9d, r9d
  05b12	41 b0 40	 mov	 r8b, 64			; 00000040H
  05b15	33 d2		 xor	 edx, edx
  05b17	48 8b 8c 24 c0
	03 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  05b1f	e8 00 00 00 00	 call	 ckd_build_sense

; 4339 :                 *unitstat = CSW_CE | CSW_DE | CSW_UC;

  05b24	48 8b 84 24 08
	04 00 00	 mov	 rax, QWORD PTR unitstat$[rsp]
  05b2c	c6 00 0e	 mov	 BYTE PTR [rax], 14

; 4340 :                 break;

  05b2f	e9 1c 4a 00 00	 jmp	 $LN2@ckd_dasd_e
$LN371@ckd_dasd_e:
$LN370@ckd_dasd_e:

; 4341 :             }
; 4342 :         }
; 4343 : 
; 4344 :         /* If data length is zero, terminate with unit exception */
; 4345 :         if (dev->ckdcurdl == 0)

  05b34	48 8b 84 24 c0
	03 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  05b3c	0f b7 80 ea 12
	00 00		 movzx	 eax, WORD PTR [rax+4842]
  05b43	85 c0		 test	 eax, eax
  05b45	75 10		 jne	 SHORT $LN372@ckd_dasd_e

; 4346 :         {
; 4347 :             *unitstat = CSW_CE | CSW_DE | CSW_UX;

  05b47	48 8b 84 24 08
	04 00 00	 mov	 rax, QWORD PTR unitstat$[rsp]
  05b4f	c6 00 0d	 mov	 BYTE PTR [rax], 13

; 4348 :             break;

  05b52	e9 f9 49 00 00	 jmp	 $LN2@ckd_dasd_e
$LN372@ckd_dasd_e:

; 4349 :         }
; 4350 : 
; 4351 :         /* Calculate number of bytes written and set residual count */
; 4352 :         size = dev->ckdcurkl + dev->ckdcurdl;

  05b57	48 8b 84 24 c0
	03 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  05b5f	0f b7 80 ea 12
	00 00		 movzx	 eax, WORD PTR [rax+4842]
  05b66	48 8b 8c 24 c0
	03 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  05b6e	03 81 d4 12 00
	00		 add	 eax, DWORD PTR [rcx+4820]
  05b74	89 44 24 68	 mov	 DWORD PTR size$[rsp], eax

; 4353 :         num = (count < size) ? count : size;

  05b78	8b 44 24 68	 mov	 eax, DWORD PTR size$[rsp]
  05b7c	39 84 24 e0 03
	00 00		 cmp	 DWORD PTR count$[rsp], eax
  05b83	73 10		 jae	 SHORT $LN729@ckd_dasd_e
  05b85	8b 84 24 e0 03
	00 00		 mov	 eax, DWORD PTR count$[rsp]
  05b8c	89 84 24 7c 01
	00 00		 mov	 DWORD PTR tv2842[rsp], eax
  05b93	eb 0b		 jmp	 SHORT $LN730@ckd_dasd_e
$LN729@ckd_dasd_e:
  05b95	8b 44 24 68	 mov	 eax, DWORD PTR size$[rsp]
  05b99	89 84 24 7c 01
	00 00		 mov	 DWORD PTR tv2842[rsp], eax
$LN730@ckd_dasd_e:
  05ba0	8b 84 24 7c 01
	00 00		 mov	 eax, DWORD PTR tv2842[rsp]
  05ba7	89 44 24 64	 mov	 DWORD PTR num$[rsp], eax

; 4354 :         *residual = count - num;

  05bab	8b 44 24 64	 mov	 eax, DWORD PTR num$[rsp]
  05baf	8b 8c 24 e0 03
	00 00		 mov	 ecx, DWORD PTR count$[rsp]
  05bb6	2b c8		 sub	 ecx, eax
  05bb8	8b c1		 mov	 eax, ecx
  05bba	48 8b 8c 24 10
	04 00 00	 mov	 rcx, QWORD PTR residual$[rsp]
  05bc2	89 01		 mov	 DWORD PTR [rcx], eax

; 4355 : 
; 4356 :         /* Write key and data */
; 4357 :         rc = ckd_write_kd (dev, iobuf, num, unitstat);

  05bc4	4c 8b 8c 24 08
	04 00 00	 mov	 r9, QWORD PTR unitstat$[rsp]
  05bcc	44 8b 44 24 64	 mov	 r8d, DWORD PTR num$[rsp]
  05bd1	48 8b 94 24 f8
	03 00 00	 mov	 rdx, QWORD PTR iobuf$[rsp]
  05bd9	48 8b 8c 24 c0
	03 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  05be1	e8 00 00 00 00	 call	 ckd_write_kd
  05be6	89 44 24 60	 mov	 DWORD PTR rc$[rsp], eax

; 4358 :         if (rc < 0) break;

  05bea	83 7c 24 60 00	 cmp	 DWORD PTR rc$[rsp], 0
  05bef	7d 05		 jge	 SHORT $LN373@ckd_dasd_e
  05bf1	e9 5a 49 00 00	 jmp	 $LN2@ckd_dasd_e
$LN373@ckd_dasd_e:

; 4359 : 
; 4360 :         /* If track overflow, keep writing */
; 4361 :         offset = dev->ckdcurkl;

  05bf6	48 8b 84 24 c0
	03 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  05bfe	8b 80 d4 12 00
	00		 mov	 eax, DWORD PTR [rax+4820]
  05c04	89 44 24 74	 mov	 DWORD PTR offset$[rsp], eax
$LN34@ckd_dasd_e:

; 4362 :         while (dev->ckdtrkof)

  05c08	48 8b 84 24 c0
	03 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  05c10	8b 80 14 13 00
	00		 mov	 eax, DWORD PTR [rax+4884]
  05c16	c1 e8 0f	 shr	 eax, 15
  05c19	83 e0 01	 and	 eax, 1
  05c1c	85 c0		 test	 eax, eax
  05c1e	0f 84 17 01 00
	00		 je	 $LN35@ckd_dasd_e

; 4363 :         {
; 4364 :             /* Advance to next track */
; 4365 :             rc = mt_advance (dev, unitstat, 1);

  05c24	41 b8 01 00 00
	00		 mov	 r8d, 1
  05c2a	48 8b 94 24 08
	04 00 00	 mov	 rdx, QWORD PTR unitstat$[rsp]
  05c32	48 8b 8c 24 c0
	03 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  05c3a	e8 00 00 00 00	 call	 mt_advance
  05c3f	89 44 24 60	 mov	 DWORD PTR rc$[rsp], eax

; 4366 :             if (rc < 0) break;

  05c43	83 7c 24 60 00	 cmp	 DWORD PTR rc$[rsp], 0
  05c48	7d 05		 jge	 SHORT $LN374@ckd_dasd_e
  05c4a	e9 ec 00 00 00	 jmp	 $LN35@ckd_dasd_e
$LN374@ckd_dasd_e:

; 4367 : 
; 4368 :             /* Read the first count field */
; 4369 :             rc = ckd_read_count (dev, code, &rechdr, unitstat);

  05c4f	4c 8b 8c 24 08
	04 00 00	 mov	 r9, QWORD PTR unitstat$[rsp]
  05c57	4c 8d 84 24 38
	02 00 00	 lea	 r8, QWORD PTR rechdr$[rsp]
  05c5f	0f b6 94 24 c8
	03 00 00	 movzx	 edx, BYTE PTR code$[rsp]
  05c67	48 8b 8c 24 c0
	03 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  05c6f	e8 00 00 00 00	 call	 ckd_read_count
  05c74	89 44 24 60	 mov	 DWORD PTR rc$[rsp], eax

; 4370 :             if (rc < 0) break;

  05c78	83 7c 24 60 00	 cmp	 DWORD PTR rc$[rsp], 0
  05c7d	7d 05		 jge	 SHORT $LN375@ckd_dasd_e
  05c7f	e9 b7 00 00 00	 jmp	 $LN35@ckd_dasd_e
$LN375@ckd_dasd_e:

; 4371 : 
; 4372 :             /* Set offset into buffer for this write */
; 4373 :             offset += size;

  05c84	8b 44 24 68	 mov	 eax, DWORD PTR size$[rsp]
  05c88	8b 4c 24 74	 mov	 ecx, DWORD PTR offset$[rsp]
  05c8c	03 c8		 add	 ecx, eax
  05c8e	8b c1		 mov	 eax, ecx
  05c90	89 44 24 74	 mov	 DWORD PTR offset$[rsp], eax

; 4374 : 
; 4375 :             /* Account for size of this overflow record */
; 4376 :             size = dev->ckdcurdl;

  05c94	48 8b 84 24 c0
	03 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  05c9c	0f b7 80 ea 12
	00 00		 movzx	 eax, WORD PTR [rax+4842]
  05ca3	89 44 24 68	 mov	 DWORD PTR size$[rsp], eax

; 4377 :             num = (*residual < size) ? *residual : size;

  05ca7	48 8b 84 24 10
	04 00 00	 mov	 rax, QWORD PTR residual$[rsp]
  05caf	8b 4c 24 68	 mov	 ecx, DWORD PTR size$[rsp]
  05cb3	39 08		 cmp	 DWORD PTR [rax], ecx
  05cb5	73 13		 jae	 SHORT $LN731@ckd_dasd_e
  05cb7	48 8b 84 24 10
	04 00 00	 mov	 rax, QWORD PTR residual$[rsp]
  05cbf	8b 00		 mov	 eax, DWORD PTR [rax]
  05cc1	89 84 24 80 01
	00 00		 mov	 DWORD PTR tv2870[rsp], eax
  05cc8	eb 0b		 jmp	 SHORT $LN732@ckd_dasd_e
$LN731@ckd_dasd_e:
  05cca	8b 44 24 68	 mov	 eax, DWORD PTR size$[rsp]
  05cce	89 84 24 80 01
	00 00		 mov	 DWORD PTR tv2870[rsp], eax
$LN732@ckd_dasd_e:
  05cd5	8b 84 24 80 01
	00 00		 mov	 eax, DWORD PTR tv2870[rsp]
  05cdc	89 44 24 64	 mov	 DWORD PTR num$[rsp], eax

; 4378 :             *residual -= num;

  05ce0	48 8b 84 24 10
	04 00 00	 mov	 rax, QWORD PTR residual$[rsp]
  05ce8	8b 4c 24 64	 mov	 ecx, DWORD PTR num$[rsp]
  05cec	8b 00		 mov	 eax, DWORD PTR [rax]
  05cee	2b c1		 sub	 eax, ecx
  05cf0	48 8b 8c 24 10
	04 00 00	 mov	 rcx, QWORD PTR residual$[rsp]
  05cf8	89 01		 mov	 DWORD PTR [rcx], eax

; 4379 : 
; 4380 :             /* Write the next data field */
; 4381 :             rc = ckd_write_data (dev, iobuf+offset, num, unitstat);

  05cfa	8b 44 24 74	 mov	 eax, DWORD PTR offset$[rsp]
  05cfe	48 8b 8c 24 f8
	03 00 00	 mov	 rcx, QWORD PTR iobuf$[rsp]
  05d06	48 03 c8	 add	 rcx, rax
  05d09	48 8b c1	 mov	 rax, rcx
  05d0c	4c 8b 8c 24 08
	04 00 00	 mov	 r9, QWORD PTR unitstat$[rsp]
  05d14	44 8b 44 24 64	 mov	 r8d, DWORD PTR num$[rsp]
  05d19	48 8b d0	 mov	 rdx, rax
  05d1c	48 8b 8c 24 c0
	03 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  05d24	e8 00 00 00 00	 call	 ckd_write_data
  05d29	89 44 24 60	 mov	 DWORD PTR rc$[rsp], eax

; 4382 :             if (rc < 0) break;

  05d2d	83 7c 24 60 00	 cmp	 DWORD PTR rc$[rsp], 0
  05d32	7d 02		 jge	 SHORT $LN376@ckd_dasd_e
  05d34	eb 05		 jmp	 SHORT $LN35@ckd_dasd_e
$LN376@ckd_dasd_e:

; 4383 :         }

  05d36	e9 cd fe ff ff	 jmp	 $LN34@ckd_dasd_e
$LN35@ckd_dasd_e:

; 4384 : 
; 4385 :         /* Bail out if track overflow produced I/O error */
; 4386 :         if (rc < 0) break;

  05d3b	83 7c 24 60 00	 cmp	 DWORD PTR rc$[rsp], 0
  05d40	7d 05		 jge	 SHORT $LN377@ckd_dasd_e
  05d42	e9 09 48 00 00	 jmp	 $LN2@ckd_dasd_e
$LN377@ckd_dasd_e:

; 4387 : 
; 4388 :         /* Return normal status */
; 4389 :         *unitstat = CSW_CE | CSW_DE;

  05d47	48 8b 84 24 08
	04 00 00	 mov	 rax, QWORD PTR unitstat$[rsp]
  05d4f	c6 00 0c	 mov	 BYTE PTR [rax], 12

; 4390 : 
; 4391 :         break;

  05d52	e9 f9 47 00 00	 jmp	 $LN2@ckd_dasd_e
$LN378@ckd_dasd_e:

; 4392 : 
; 4393 :     case 0x11:
; 4394 :     /*---------------------------------------------------------------*/
; 4395 :     /* ERASE                                                         */
; 4396 :     /*---------------------------------------------------------------*/
; 4397 :         /* Command reject if the current track is in the DSF area */
; 4398 :         if (dev->ckdcurcyl >= dev->ckdcyls)

  05d57	48 8b 84 24 c0
	03 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  05d5f	48 8b 8c 24 c0
	03 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  05d67	8b 89 b8 12 00
	00		 mov	 ecx, DWORD PTR [rcx+4792]
  05d6d	39 88 c8 12 00
	00		 cmp	 DWORD PTR [rax+4808], ecx
  05d73	7c 2f		 jl	 SHORT $LN379@ckd_dasd_e

; 4399 :         {
; 4400 :             ckd_build_sense (dev, SENSE_CR, 0, 0,

  05d75	c6 44 24 28 02	 mov	 BYTE PTR [rsp+40], 2
  05d7a	c6 44 24 20 00	 mov	 BYTE PTR [rsp+32], 0
  05d7f	45 33 c9	 xor	 r9d, r9d
  05d82	45 33 c0	 xor	 r8d, r8d
  05d85	b2 80		 mov	 dl, 128			; 00000080H
  05d87	48 8b 8c 24 c0
	03 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  05d8f	e8 00 00 00 00	 call	 ckd_build_sense

; 4401 :                             FORMAT_0, MESSAGE_2);
; 4402 :             *unitstat = CSW_CE | CSW_DE | CSW_UC;

  05d94	48 8b 84 24 08
	04 00 00	 mov	 rax, QWORD PTR unitstat$[rsp]
  05d9c	c6 00 0e	 mov	 BYTE PTR [rax], 14

; 4403 :             break;

  05d9f	e9 ac 47 00 00	 jmp	 $LN2@ckd_dasd_e
$LN379@ckd_dasd_e:

; 4404 :         }
; 4405 : 
; 4406 :         /* Command reject if not within the domain of a Locate Record
; 4407 :            and not preceded by either a Search ID Equal or Search Key
; 4408 :            Equal that compared equal on all bytes, or a Write R0 or
; 4409 :            Write CKD not within the domain of a Locate Record */
; 4410 :         if (dev->ckdlcount == 0 && dev->ckdideq == 0
; 4411 :             && dev->ckdkyeq == 0 && dev->ckdwckd == 0)

  05da4	48 8b 84 24 c0
	03 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  05dac	0f b6 80 02 13
	00 00		 movzx	 eax, BYTE PTR [rax+4866]
  05db3	85 c0		 test	 eax, eax
  05db5	75 77		 jne	 SHORT $LN380@ckd_dasd_e
  05db7	48 8b 84 24 c0
	03 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  05dbf	8b 80 14 13 00
	00		 mov	 eax, DWORD PTR [rax+4884]
  05dc5	c1 e8 0c	 shr	 eax, 12
  05dc8	83 e0 01	 and	 eax, 1
  05dcb	85 c0		 test	 eax, eax
  05dcd	75 5f		 jne	 SHORT $LN380@ckd_dasd_e
  05dcf	48 8b 84 24 c0
	03 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  05dd7	8b 80 14 13 00
	00		 mov	 eax, DWORD PTR [rax+4884]
  05ddd	c1 e8 0d	 shr	 eax, 13
  05de0	83 e0 01	 and	 eax, 1
  05de3	85 c0		 test	 eax, eax
  05de5	75 47		 jne	 SHORT $LN380@ckd_dasd_e
  05de7	48 8b 84 24 c0
	03 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  05def	8b 80 14 13 00
	00		 mov	 eax, DWORD PTR [rax+4884]
  05df5	c1 e8 0e	 shr	 eax, 14
  05df8	83 e0 01	 and	 eax, 1
  05dfb	85 c0		 test	 eax, eax
  05dfd	75 2f		 jne	 SHORT $LN380@ckd_dasd_e

; 4412 :         {
; 4413 :             ckd_build_sense (dev, SENSE_CR, 0, 0,

  05dff	c6 44 24 28 02	 mov	 BYTE PTR [rsp+40], 2
  05e04	c6 44 24 20 00	 mov	 BYTE PTR [rsp+32], 0
  05e09	45 33 c9	 xor	 r9d, r9d
  05e0c	45 33 c0	 xor	 r8d, r8d
  05e0f	b2 80		 mov	 dl, 128			; 00000080H
  05e11	48 8b 8c 24 c0
	03 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  05e19	e8 00 00 00 00	 call	 ckd_build_sense

; 4414 :                             FORMAT_0, MESSAGE_2);
; 4415 :             *unitstat = CSW_CE | CSW_DE | CSW_UC;

  05e1e	48 8b 84 24 08
	04 00 00	 mov	 rax, QWORD PTR unitstat$[rsp]
  05e26	c6 00 0e	 mov	 BYTE PTR [rax], 14

; 4416 :             break;

  05e29	e9 22 47 00 00	 jmp	 $LN2@ckd_dasd_e
$LN380@ckd_dasd_e:

; 4417 :         }
; 4418 : 
; 4419 :         /* Command reject if file mask does not permit Write CKD */
; 4420 :         if ((dev->ckdfmask & CKDMASK_WRCTL) != CKDMASK_WRCTL_ALLWRT
; 4421 :             && (dev->ckdfmask & CKDMASK_WRCTL) != CKDMASK_WRCTL_INHWR0)

  05e2e	48 8b 84 24 c0
	03 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  05e36	0f b6 80 fa 12
	00 00		 movzx	 eax, BYTE PTR [rax+4858]
  05e3d	25 c0 00 00 00	 and	 eax, 192		; 000000c0H
  05e42	3d c0 00 00 00	 cmp	 eax, 192		; 000000c0H
  05e47	74 47		 je	 SHORT $LN381@ckd_dasd_e
  05e49	48 8b 84 24 c0
	03 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  05e51	0f b6 80 fa 12
	00 00		 movzx	 eax, BYTE PTR [rax+4858]
  05e58	25 c0 00 00 00	 and	 eax, 192		; 000000c0H
  05e5d	85 c0		 test	 eax, eax
  05e5f	74 2f		 je	 SHORT $LN381@ckd_dasd_e

; 4422 :         {
; 4423 :             ckd_build_sense (dev, SENSE_CR, 0, 0,

  05e61	c6 44 24 28 02	 mov	 BYTE PTR [rsp+40], 2
  05e66	c6 44 24 20 00	 mov	 BYTE PTR [rsp+32], 0
  05e6b	45 33 c9	 xor	 r9d, r9d
  05e6e	45 33 c0	 xor	 r8d, r8d
  05e71	b2 80		 mov	 dl, 128			; 00000080H
  05e73	48 8b 8c 24 c0
	03 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  05e7b	e8 00 00 00 00	 call	 ckd_build_sense

; 4424 :                             FORMAT_0, MESSAGE_2);
; 4425 :             *unitstat = CSW_CE | CSW_DE | CSW_UC;

  05e80	48 8b 84 24 08
	04 00 00	 mov	 rax, QWORD PTR unitstat$[rsp]
  05e88	c6 00 0e	 mov	 BYTE PTR [rax], 14

; 4426 :             break;

  05e8b	e9 c0 46 00 00	 jmp	 $LN2@ckd_dasd_e
$LN381@ckd_dasd_e:

; 4427 :         }
; 4428 : 
; 4429 :         /* Check operation code if within domain of a Locate Record */
; 4430 :         if (dev->ckdlcount > 0)

  05e90	48 8b 84 24 c0
	03 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  05e98	0f b6 80 02 13
	00 00		 movzx	 eax, BYTE PTR [rax+4866]
  05e9f	85 c0		 test	 eax, eax
  05ea1	7e 46		 jle	 SHORT $LN382@ckd_dasd_e

; 4431 :         {
; 4432 :             if ((dev->ckdloper & CKDOPER_CODE) != CKDOPER_WRTTRK)

  05ea3	48 8b 84 24 c0
	03 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  05eab	0f b6 80 00 13
	00 00		 movzx	 eax, BYTE PTR [rax+4864]
  05eb2	83 e0 3f	 and	 eax, 63			; 0000003fH
  05eb5	83 f8 0b	 cmp	 eax, 11
  05eb8	74 2f		 je	 SHORT $LN383@ckd_dasd_e

; 4433 :             {
; 4434 :                 ckd_build_sense (dev, SENSE_CR, 0, 0,

  05eba	c6 44 24 28 02	 mov	 BYTE PTR [rsp+40], 2
  05ebf	c6 44 24 20 00	 mov	 BYTE PTR [rsp+32], 0
  05ec4	45 33 c9	 xor	 r9d, r9d
  05ec7	45 33 c0	 xor	 r8d, r8d
  05eca	b2 80		 mov	 dl, 128			; 00000080H
  05ecc	48 8b 8c 24 c0
	03 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  05ed4	e8 00 00 00 00	 call	 ckd_build_sense

; 4435 :                                 FORMAT_0, MESSAGE_2);
; 4436 :                 *unitstat = CSW_CE | CSW_DE | CSW_UC;

  05ed9	48 8b 84 24 08
	04 00 00	 mov	 rax, QWORD PTR unitstat$[rsp]
  05ee1	c6 00 0e	 mov	 BYTE PTR [rax], 14

; 4437 :                 break;

  05ee4	e9 67 46 00 00	 jmp	 $LN2@ckd_dasd_e
$LN383@ckd_dasd_e:
$LN382@ckd_dasd_e:

; 4438 :             }
; 4439 :         }
; 4440 : 
; 4441 :         /* Write end of track marker */
; 4442 :         rc = ckd_erase (dev, iobuf, count, (int*)&size, unitstat);

  05ee9	48 8b 84 24 08
	04 00 00	 mov	 rax, QWORD PTR unitstat$[rsp]
  05ef1	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  05ef6	4c 8d 4c 24 68	 lea	 r9, QWORD PTR size$[rsp]
  05efb	44 8b 84 24 e0
	03 00 00	 mov	 r8d, DWORD PTR count$[rsp]
  05f03	48 8b 94 24 f8
	03 00 00	 mov	 rdx, QWORD PTR iobuf$[rsp]
  05f0b	48 8b 8c 24 c0
	03 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  05f13	e8 00 00 00 00	 call	 ckd_erase
  05f18	89 44 24 60	 mov	 DWORD PTR rc$[rsp], eax

; 4443 :         if (rc < 0) break;

  05f1c	83 7c 24 60 00	 cmp	 DWORD PTR rc$[rsp], 0
  05f21	7d 05		 jge	 SHORT $LN384@ckd_dasd_e
  05f23	e9 28 46 00 00	 jmp	 $LN2@ckd_dasd_e
$LN384@ckd_dasd_e:

; 4444 : 
; 4445 :         /* Calculate number of bytes used and set residual count */
; 4446 :         num = (count < size) ? count : size;

  05f28	8b 44 24 68	 mov	 eax, DWORD PTR size$[rsp]
  05f2c	39 84 24 e0 03
	00 00		 cmp	 DWORD PTR count$[rsp], eax
  05f33	73 10		 jae	 SHORT $LN733@ckd_dasd_e
  05f35	8b 84 24 e0 03
	00 00		 mov	 eax, DWORD PTR count$[rsp]
  05f3c	89 84 24 84 01
	00 00		 mov	 DWORD PTR tv2946[rsp], eax
  05f43	eb 0b		 jmp	 SHORT $LN734@ckd_dasd_e
$LN733@ckd_dasd_e:
  05f45	8b 44 24 68	 mov	 eax, DWORD PTR size$[rsp]
  05f49	89 84 24 84 01
	00 00		 mov	 DWORD PTR tv2946[rsp], eax
$LN734@ckd_dasd_e:
  05f50	8b 84 24 84 01
	00 00		 mov	 eax, DWORD PTR tv2946[rsp]
  05f57	89 44 24 64	 mov	 DWORD PTR num$[rsp], eax

; 4447 :         *residual = count - num;

  05f5b	8b 44 24 64	 mov	 eax, DWORD PTR num$[rsp]
  05f5f	8b 8c 24 e0 03
	00 00		 mov	 ecx, DWORD PTR count$[rsp]
  05f66	2b c8		 sub	 ecx, eax
  05f68	8b c1		 mov	 eax, ecx
  05f6a	48 8b 8c 24 10
	04 00 00	 mov	 rcx, QWORD PTR residual$[rsp]
  05f72	89 01		 mov	 DWORD PTR [rcx], eax

; 4448 : 
; 4449 :         /* Return normal status */
; 4450 :         *unitstat = CSW_CE | CSW_DE;

  05f74	48 8b 84 24 08
	04 00 00	 mov	 rax, QWORD PTR unitstat$[rsp]
  05f7c	c6 00 0c	 mov	 BYTE PTR [rax], 12

; 4451 : 
; 4452 :         break;

  05f7f	e9 cc 45 00 00	 jmp	 $LN2@ckd_dasd_e
$LN385@ckd_dasd_e:

; 4453 : 
; 4454 :     case 0x15:
; 4455 :     /*---------------------------------------------------------------*/
; 4456 :     /* WRITE RECORD ZERO                                             */
; 4457 :     /*---------------------------------------------------------------*/
; 4458 :         /* Command reject if the current track is in the DSF area */
; 4459 :         if (dev->ckdcurcyl >= dev->ckdcyls)

  05f84	48 8b 84 24 c0
	03 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  05f8c	48 8b 8c 24 c0
	03 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  05f94	8b 89 b8 12 00
	00		 mov	 ecx, DWORD PTR [rcx+4792]
  05f9a	39 88 c8 12 00
	00		 cmp	 DWORD PTR [rax+4808], ecx
  05fa0	7c 3c		 jl	 SHORT $LN386@ckd_dasd_e

; 4460 :         {
; 4461 :             ckd_build_sense (dev, SENSE_CR, 0, 0,

  05fa2	c6 44 24 28 02	 mov	 BYTE PTR [rsp+40], 2
  05fa7	c6 44 24 20 00	 mov	 BYTE PTR [rsp+32], 0
  05fac	45 33 c9	 xor	 r9d, r9d
  05faf	45 33 c0	 xor	 r8d, r8d
  05fb2	b2 80		 mov	 dl, 128			; 00000080H
  05fb4	48 8b 8c 24 c0
	03 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  05fbc	e8 00 00 00 00	 call	 ckd_build_sense

; 4462 :                             FORMAT_0, MESSAGE_2);
; 4463 :             *unitstat = CSW_CE | CSW_DE | CSW_UC;

  05fc1	48 8b 84 24 08
	04 00 00	 mov	 rax, QWORD PTR unitstat$[rsp]
  05fc9	c6 00 0e	 mov	 BYTE PTR [rax], 14

; 4464 :             logmsg("DEBUG : WR0 OUTSIDE PACK\n");

  05fcc	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG172029
  05fd3	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_logmsg

; 4465 :             break;

  05fd9	e9 72 45 00 00	 jmp	 $LN2@ckd_dasd_e
$LN386@ckd_dasd_e:

; 4466 :         }
; 4467 : 
; 4468 :         /* Command reject if not within the domain of a Locate Record
; 4469 :            and not preceded by either a Search Home Address that
; 4470 :            compared equal on all 4 bytes, or a Write Home Address not
; 4471 :            within the domain of a Locate Record */
; 4472 :         /* ISW20030819-1 : Added check for previously issued WRHA */
; 4473 :         if (dev->ckdlcount == 0 && dev->ckdhaeq == 0 && dev->ckdwrha==0)

  05fde	48 8b 84 24 c0
	03 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  05fe6	0f b6 80 02 13
	00 00		 movzx	 eax, BYTE PTR [rax+4866]
  05fed	85 c0		 test	 eax, eax
  05fef	75 6c		 jne	 SHORT $LN387@ckd_dasd_e
  05ff1	48 8b 84 24 c0
	03 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  05ff9	8b 80 14 13 00
	00		 mov	 eax, DWORD PTR [rax+4884]
  05fff	c1 e8 0b	 shr	 eax, 11
  06002	83 e0 01	 and	 eax, 1
  06005	85 c0		 test	 eax, eax
  06007	75 54		 jne	 SHORT $LN387@ckd_dasd_e
  06009	48 8b 84 24 c0
	03 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  06011	8b 80 14 13 00
	00		 mov	 eax, DWORD PTR [rax+4884]
  06017	c1 e8 13	 shr	 eax, 19
  0601a	83 e0 01	 and	 eax, 1
  0601d	85 c0		 test	 eax, eax
  0601f	75 3c		 jne	 SHORT $LN387@ckd_dasd_e

; 4474 :         {
; 4475 :             ckd_build_sense (dev, SENSE_CR, 0, 0,

  06021	c6 44 24 28 02	 mov	 BYTE PTR [rsp+40], 2
  06026	c6 44 24 20 00	 mov	 BYTE PTR [rsp+32], 0
  0602b	45 33 c9	 xor	 r9d, r9d
  0602e	45 33 c0	 xor	 r8d, r8d
  06031	b2 80		 mov	 dl, 128			; 00000080H
  06033	48 8b 8c 24 c0
	03 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  0603b	e8 00 00 00 00	 call	 ckd_build_sense

; 4476 :                             FORMAT_0, MESSAGE_2);
; 4477 :             *unitstat = CSW_CE | CSW_DE | CSW_UC;

  06040	48 8b 84 24 08
	04 00 00	 mov	 rax, QWORD PTR unitstat$[rsp]
  06048	c6 00 0e	 mov	 BYTE PTR [rax], 14

; 4478 :             logmsg("DEBUG : WR0 CASE 2\n");

  0604b	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG172031
  06052	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_logmsg

; 4479 :             break;

  06058	e9 f3 44 00 00	 jmp	 $LN2@ckd_dasd_e
$LN387@ckd_dasd_e:

; 4480 :         }
; 4481 : 
; 4482 :         /* Command reject if file mask does not permit Write R0 */
; 4483 :         if ((dev->ckdfmask & CKDMASK_WRCTL) != CKDMASK_WRCTL_ALLWRT)

  0605d	48 8b 84 24 c0
	03 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  06065	0f b6 80 fa 12
	00 00		 movzx	 eax, BYTE PTR [rax+4858]
  0606c	25 c0 00 00 00	 and	 eax, 192		; 000000c0H
  06071	3d c0 00 00 00	 cmp	 eax, 192		; 000000c0H
  06076	74 3c		 je	 SHORT $LN388@ckd_dasd_e

; 4484 :         {
; 4485 :             ckd_build_sense (dev, SENSE_CR, 0, 0,

  06078	c6 44 24 28 02	 mov	 BYTE PTR [rsp+40], 2
  0607d	c6 44 24 20 00	 mov	 BYTE PTR [rsp+32], 0
  06082	45 33 c9	 xor	 r9d, r9d
  06085	45 33 c0	 xor	 r8d, r8d
  06088	b2 80		 mov	 dl, 128			; 00000080H
  0608a	48 8b 8c 24 c0
	03 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  06092	e8 00 00 00 00	 call	 ckd_build_sense

; 4486 :                             FORMAT_0, MESSAGE_2);
; 4487 :             *unitstat = CSW_CE | CSW_DE | CSW_UC;

  06097	48 8b 84 24 08
	04 00 00	 mov	 rax, QWORD PTR unitstat$[rsp]
  0609f	c6 00 0e	 mov	 BYTE PTR [rax], 14

; 4488 :             logmsg("DEBUG : WR0 BAD FM\n");

  060a2	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG172033
  060a9	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_logmsg

; 4489 :             break;

  060af	e9 9c 44 00 00	 jmp	 $LN2@ckd_dasd_e
$LN388@ckd_dasd_e:

; 4490 :         }
; 4491 : 
; 4492 :         /* Check operation code if within domain of a Locate Record */
; 4493 :         if (dev->ckdlcount > 0)

  060b4	48 8b 84 24 c0
	03 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  060bc	0f b6 80 02 13
	00 00		 movzx	 eax, BYTE PTR [rax+4866]
  060c3	85 c0		 test	 eax, eax
  060c5	0f 8e 87 00 00
	00		 jle	 $LN389@ckd_dasd_e

; 4494 :         {
; 4495 :             if (!((dev->ckdloper & CKDOPER_CODE) == CKDOPER_FORMAT

  060cb	48 8b 84 24 c0
	03 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  060d3	0f b6 80 00 13
	00 00		 movzx	 eax, BYTE PTR [rax+4864]
  060da	83 e0 3f	 and	 eax, 63			; 0000003fH
  060dd	83 f8 03	 cmp	 eax, 3
  060e0	75 34		 jne	 SHORT $LN391@ckd_dasd_e
  060e2	48 8b 84 24 c0
	03 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  060ea	0f b6 80 00 13
	00 00		 movzx	 eax, BYTE PTR [rax+4864]
  060f1	25 c0 00 00 00	 and	 eax, 192		; 000000c0H
  060f6	83 f8 40	 cmp	 eax, 64			; 00000040H
  060f9	74 57		 je	 SHORT $LN390@ckd_dasd_e
  060fb	48 8b 84 24 c0
	03 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  06103	0f b6 80 00 13
	00 00		 movzx	 eax, BYTE PTR [rax+4864]
  0610a	25 c0 00 00 00	 and	 eax, 192		; 000000c0H
  0610f	3d c0 00 00 00	 cmp	 eax, 192		; 000000c0H
  06114	74 3c		 je	 SHORT $LN390@ckd_dasd_e
$LN391@ckd_dasd_e:

; 4496 :                     && ((dev->ckdloper & CKDOPER_ORIENTATION)
; 4497 :                                 == CKDOPER_ORIENT_HOME
; 4498 :                           || (dev->ckdloper & CKDOPER_ORIENTATION)
; 4499 :                                 == CKDOPER_ORIENT_INDEX
; 4500 :                        )))
; 4501 :             {
; 4502 :                 ckd_build_sense (dev, SENSE_CR, 0, 0,

  06116	c6 44 24 28 02	 mov	 BYTE PTR [rsp+40], 2
  0611b	c6 44 24 20 00	 mov	 BYTE PTR [rsp+32], 0
  06120	45 33 c9	 xor	 r9d, r9d
  06123	45 33 c0	 xor	 r8d, r8d
  06126	b2 80		 mov	 dl, 128			; 00000080H
  06128	48 8b 8c 24 c0
	03 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  06130	e8 00 00 00 00	 call	 ckd_build_sense

; 4503 :                                 FORMAT_0, MESSAGE_2);
; 4504 :                 *unitstat = CSW_CE | CSW_DE | CSW_UC;

  06135	48 8b 84 24 08
	04 00 00	 mov	 rax, QWORD PTR unitstat$[rsp]
  0613d	c6 00 0e	 mov	 BYTE PTR [rax], 14

; 4505 :                 logmsg("DEBUG : LOC REC 2\n");

  06140	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG172037
  06147	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_logmsg

; 4506 :                 break;

  0614d	e9 fe 43 00 00	 jmp	 $LN2@ckd_dasd_e
$LN390@ckd_dasd_e:
$LN389@ckd_dasd_e:

; 4507 :             }
; 4508 :         }
; 4509 : 
; 4510 :         /* Write R0 count key and data */
; 4511 :         rc = ckd_write_ckd (dev, iobuf, count, unitstat, 0);

  06152	c6 44 24 20 00	 mov	 BYTE PTR [rsp+32], 0
  06157	4c 8b 8c 24 08
	04 00 00	 mov	 r9, QWORD PTR unitstat$[rsp]
  0615f	44 8b 84 24 e0
	03 00 00	 mov	 r8d, DWORD PTR count$[rsp]
  06167	48 8b 94 24 f8
	03 00 00	 mov	 rdx, QWORD PTR iobuf$[rsp]
  0616f	48 8b 8c 24 c0
	03 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  06177	e8 00 00 00 00	 call	 ckd_write_ckd
  0617c	89 44 24 60	 mov	 DWORD PTR rc$[rsp], eax

; 4512 :         if (rc < 0) break;

  06180	83 7c 24 60 00	 cmp	 DWORD PTR rc$[rsp], 0
  06185	7d 05		 jge	 SHORT $LN392@ckd_dasd_e
  06187	e9 c4 43 00 00	 jmp	 $LN2@ckd_dasd_e
$LN392@ckd_dasd_e:

; 4513 : 
; 4514 :         /* Calculate number of bytes written and set residual count */
; 4515 :         size = CKD_RECHDR_SIZE + dev->ckdcurkl + dev->ckdcurdl;

  0618c	48 8b 84 24 c0
	03 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  06194	48 63 80 d4 12
	00 00		 movsxd	 rax, DWORD PTR [rax+4820]
  0619b	48 8b 8c 24 c0
	03 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  061a3	0f b7 89 ea 12
	00 00		 movzx	 ecx, WORD PTR [rcx+4842]
  061aa	48 8d 44 08 08	 lea	 rax, QWORD PTR [rax+rcx+8]
  061af	89 44 24 68	 mov	 DWORD PTR size$[rsp], eax

; 4516 :         num = (count < size) ? count : size;

  061b3	8b 44 24 68	 mov	 eax, DWORD PTR size$[rsp]
  061b7	39 84 24 e0 03
	00 00		 cmp	 DWORD PTR count$[rsp], eax
  061be	73 10		 jae	 SHORT $LN735@ckd_dasd_e
  061c0	8b 84 24 e0 03
	00 00		 mov	 eax, DWORD PTR count$[rsp]
  061c7	89 84 24 88 01
	00 00		 mov	 DWORD PTR tv3024[rsp], eax
  061ce	eb 0b		 jmp	 SHORT $LN736@ckd_dasd_e
$LN735@ckd_dasd_e:
  061d0	8b 44 24 68	 mov	 eax, DWORD PTR size$[rsp]
  061d4	89 84 24 88 01
	00 00		 mov	 DWORD PTR tv3024[rsp], eax
$LN736@ckd_dasd_e:
  061db	8b 84 24 88 01
	00 00		 mov	 eax, DWORD PTR tv3024[rsp]
  061e2	89 44 24 64	 mov	 DWORD PTR num$[rsp], eax

; 4517 :         *residual = count - num;

  061e6	8b 44 24 64	 mov	 eax, DWORD PTR num$[rsp]
  061ea	8b 8c 24 e0 03
	00 00		 mov	 ecx, DWORD PTR count$[rsp]
  061f1	2b c8		 sub	 ecx, eax
  061f3	8b c1		 mov	 eax, ecx
  061f5	48 8b 8c 24 10
	04 00 00	 mov	 rcx, QWORD PTR residual$[rsp]
  061fd	89 01		 mov	 DWORD PTR [rcx], eax

; 4518 : 
; 4519 :         /* Return normal status */
; 4520 :         *unitstat = CSW_CE | CSW_DE;

  061ff	48 8b 84 24 08
	04 00 00	 mov	 rax, QWORD PTR unitstat$[rsp]
  06207	c6 00 0c	 mov	 BYTE PTR [rax], 12

; 4521 : 
; 4522 :         /* Set flag if Write R0 outside domain of a locate record */
; 4523 :         if (dev->ckdlcount == 0)

  0620a	48 8b 84 24 c0
	03 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  06212	0f b6 80 02 13
	00 00		 movzx	 eax, BYTE PTR [rax+4866]
  06219	85 c0		 test	 eax, eax
  0621b	75 22		 jne	 SHORT $LN393@ckd_dasd_e

; 4524 :             dev->ckdwckd = 1;

  0621d	48 8b 84 24 c0
	03 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  06225	8b 80 14 13 00
	00		 mov	 eax, DWORD PTR [rax+4884]
  0622b	0f ba e8 0e	 bts	 eax, 14
  0622f	48 8b 8c 24 c0
	03 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  06237	89 81 14 13 00
	00		 mov	 DWORD PTR [rcx+4884], eax
  0623d	eb 20		 jmp	 SHORT $LN394@ckd_dasd_e
$LN393@ckd_dasd_e:

; 4525 :         else
; 4526 :             dev->ckdwckd = 0;

  0623f	48 8b 84 24 c0
	03 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  06247	8b 80 14 13 00
	00		 mov	 eax, DWORD PTR [rax+4884]
  0624d	0f ba f0 0e	 btr	 eax, 14
  06251	48 8b 8c 24 c0
	03 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  06259	89 81 14 13 00
	00		 mov	 DWORD PTR [rcx+4884], eax
$LN394@ckd_dasd_e:

; 4527 : 
; 4528 :         break;

  0625f	e9 ec 42 00 00	 jmp	 $LN2@ckd_dasd_e
$LN395@ckd_dasd_e:
$LN396@ckd_dasd_e:

; 4529 : 
; 4530 :     case 0x1D: /* WRITE CKD */
; 4531 :     case 0x01: /* WRITE SPECIAL CKD */
; 4532 :     /*---------------------------------------------------------------*/
; 4533 :     /* WRITE COUNT KEY AND DATA                                      */
; 4534 :     /*---------------------------------------------------------------*/
; 4535 :         /* Command reject if the current track is in the DSF area */
; 4536 :         if (dev->ckdcurcyl >= dev->ckdcyls)

  06264	48 8b 84 24 c0
	03 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  0626c	48 8b 8c 24 c0
	03 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  06274	8b 89 b8 12 00
	00		 mov	 ecx, DWORD PTR [rcx+4792]
  0627a	39 88 c8 12 00
	00		 cmp	 DWORD PTR [rax+4808], ecx
  06280	7c 2f		 jl	 SHORT $LN397@ckd_dasd_e

; 4537 :         {
; 4538 :             ckd_build_sense (dev, SENSE_CR, 0, 0,

  06282	c6 44 24 28 02	 mov	 BYTE PTR [rsp+40], 2
  06287	c6 44 24 20 00	 mov	 BYTE PTR [rsp+32], 0
  0628c	45 33 c9	 xor	 r9d, r9d
  0628f	45 33 c0	 xor	 r8d, r8d
  06292	b2 80		 mov	 dl, 128			; 00000080H
  06294	48 8b 8c 24 c0
	03 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  0629c	e8 00 00 00 00	 call	 ckd_build_sense

; 4539 :                             FORMAT_0, MESSAGE_2);
; 4540 :             *unitstat = CSW_CE | CSW_DE | CSW_UC;

  062a1	48 8b 84 24 08
	04 00 00	 mov	 rax, QWORD PTR unitstat$[rsp]
  062a9	c6 00 0e	 mov	 BYTE PTR [rax], 14

; 4541 :             break;

  062ac	e9 9f 42 00 00	 jmp	 $LN2@ckd_dasd_e
$LN397@ckd_dasd_e:

; 4542 :         }
; 4543 : 
; 4544 :         /* Command reject if previous command was a Write R0 that
; 4545 :            assigned an alternate track - not implemented */
; 4546 : 
; 4547 :         /* Command reject if not within the domain of a Locate Record
; 4548 :            and not preceded by either a Search ID Equal or Search Key
; 4549 :            Equal that compared equal on all bytes, or a Write R0 or
; 4550 :            Write CKD not within the domain of a Locate Record */
; 4551 :         if (dev->ckdlcount == 0 && dev->ckdideq == 0
; 4552 :             && dev->ckdkyeq == 0 && dev->ckdwckd == 0)

  062b1	48 8b 84 24 c0
	03 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  062b9	0f b6 80 02 13
	00 00		 movzx	 eax, BYTE PTR [rax+4866]
  062c0	85 c0		 test	 eax, eax
  062c2	75 77		 jne	 SHORT $LN398@ckd_dasd_e
  062c4	48 8b 84 24 c0
	03 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  062cc	8b 80 14 13 00
	00		 mov	 eax, DWORD PTR [rax+4884]
  062d2	c1 e8 0c	 shr	 eax, 12
  062d5	83 e0 01	 and	 eax, 1
  062d8	85 c0		 test	 eax, eax
  062da	75 5f		 jne	 SHORT $LN398@ckd_dasd_e
  062dc	48 8b 84 24 c0
	03 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  062e4	8b 80 14 13 00
	00		 mov	 eax, DWORD PTR [rax+4884]
  062ea	c1 e8 0d	 shr	 eax, 13
  062ed	83 e0 01	 and	 eax, 1
  062f0	85 c0		 test	 eax, eax
  062f2	75 47		 jne	 SHORT $LN398@ckd_dasd_e
  062f4	48 8b 84 24 c0
	03 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  062fc	8b 80 14 13 00
	00		 mov	 eax, DWORD PTR [rax+4884]
  06302	c1 e8 0e	 shr	 eax, 14
  06305	83 e0 01	 and	 eax, 1
  06308	85 c0		 test	 eax, eax
  0630a	75 2f		 jne	 SHORT $LN398@ckd_dasd_e

; 4553 :         {
; 4554 :             ckd_build_sense (dev, SENSE_CR, 0, 0,

  0630c	c6 44 24 28 02	 mov	 BYTE PTR [rsp+40], 2
  06311	c6 44 24 20 00	 mov	 BYTE PTR [rsp+32], 0
  06316	45 33 c9	 xor	 r9d, r9d
  06319	45 33 c0	 xor	 r8d, r8d
  0631c	b2 80		 mov	 dl, 128			; 00000080H
  0631e	48 8b 8c 24 c0
	03 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  06326	e8 00 00 00 00	 call	 ckd_build_sense

; 4555 :                             FORMAT_0, MESSAGE_2);
; 4556 :             *unitstat = CSW_CE | CSW_DE | CSW_UC;

  0632b	48 8b 84 24 08
	04 00 00	 mov	 rax, QWORD PTR unitstat$[rsp]
  06333	c6 00 0e	 mov	 BYTE PTR [rax], 14

; 4557 :             break;

  06336	e9 15 42 00 00	 jmp	 $LN2@ckd_dasd_e
$LN398@ckd_dasd_e:

; 4558 :         }
; 4559 : 
; 4560 :         /* Command reject if file mask does not permit Write CKD */
; 4561 :         if ((dev->ckdfmask & CKDMASK_WRCTL) != CKDMASK_WRCTL_ALLWRT
; 4562 :             && (dev->ckdfmask & CKDMASK_WRCTL) != CKDMASK_WRCTL_INHWR0)

  0633b	48 8b 84 24 c0
	03 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  06343	0f b6 80 fa 12
	00 00		 movzx	 eax, BYTE PTR [rax+4858]
  0634a	25 c0 00 00 00	 and	 eax, 192		; 000000c0H
  0634f	3d c0 00 00 00	 cmp	 eax, 192		; 000000c0H
  06354	74 47		 je	 SHORT $LN399@ckd_dasd_e
  06356	48 8b 84 24 c0
	03 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  0635e	0f b6 80 fa 12
	00 00		 movzx	 eax, BYTE PTR [rax+4858]
  06365	25 c0 00 00 00	 and	 eax, 192		; 000000c0H
  0636a	85 c0		 test	 eax, eax
  0636c	74 2f		 je	 SHORT $LN399@ckd_dasd_e

; 4563 :         {
; 4564 :             ckd_build_sense (dev, SENSE_CR, 0, 0,

  0636e	c6 44 24 28 02	 mov	 BYTE PTR [rsp+40], 2
  06373	c6 44 24 20 00	 mov	 BYTE PTR [rsp+32], 0
  06378	45 33 c9	 xor	 r9d, r9d
  0637b	45 33 c0	 xor	 r8d, r8d
  0637e	b2 80		 mov	 dl, 128			; 00000080H
  06380	48 8b 8c 24 c0
	03 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  06388	e8 00 00 00 00	 call	 ckd_build_sense

; 4565 :                             FORMAT_0, MESSAGE_2);
; 4566 :             *unitstat = CSW_CE | CSW_DE | CSW_UC;

  0638d	48 8b 84 24 08
	04 00 00	 mov	 rax, QWORD PTR unitstat$[rsp]
  06395	c6 00 0e	 mov	 BYTE PTR [rax], 14

; 4567 :             break;

  06398	e9 b3 41 00 00	 jmp	 $LN2@ckd_dasd_e
$LN399@ckd_dasd_e:

; 4568 :         }
; 4569 : 
; 4570 :         /* Command reject if WRITE SPECIAL CKD to a 3380 or 3390 */
; 4571 :         if ((code == 0x01)
; 4572 :             && ((dev->devtype == 0x3380) || (dev->devtype == 0x3390)))

  0639d	0f b6 84 24 c8
	03 00 00	 movzx	 eax, BYTE PTR code$[rsp]
  063a5	83 f8 01	 cmp	 eax, 1
  063a8	75 55		 jne	 SHORT $LN400@ckd_dasd_e
  063aa	48 8b 84 24 c0
	03 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  063b2	0f b7 40 4a	 movzx	 eax, WORD PTR [rax+74]
  063b6	3d 80 33 00 00	 cmp	 eax, 13184		; 00003380H
  063bb	74 13		 je	 SHORT $LN401@ckd_dasd_e
  063bd	48 8b 84 24 c0
	03 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  063c5	0f b7 40 4a	 movzx	 eax, WORD PTR [rax+74]
  063c9	3d 90 33 00 00	 cmp	 eax, 13200		; 00003390H
  063ce	75 2f		 jne	 SHORT $LN400@ckd_dasd_e
$LN401@ckd_dasd_e:

; 4573 :         {
; 4574 :             ckd_build_sense (dev, SENSE_CR, 0, 0,

  063d0	c6 44 24 28 02	 mov	 BYTE PTR [rsp+40], 2
  063d5	c6 44 24 20 00	 mov	 BYTE PTR [rsp+32], 0
  063da	45 33 c9	 xor	 r9d, r9d
  063dd	45 33 c0	 xor	 r8d, r8d
  063e0	b2 80		 mov	 dl, 128			; 00000080H
  063e2	48 8b 8c 24 c0
	03 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  063ea	e8 00 00 00 00	 call	 ckd_build_sense

; 4575 :                             FORMAT_0, MESSAGE_2);
; 4576 :             *unitstat = CSW_CE | CSW_DE | CSW_UC;

  063ef	48 8b 84 24 08
	04 00 00	 mov	 rax, QWORD PTR unitstat$[rsp]
  063f7	c6 00 0e	 mov	 BYTE PTR [rax], 14

; 4577 :             break;

  063fa	e9 51 41 00 00	 jmp	 $LN2@ckd_dasd_e
$LN400@ckd_dasd_e:

; 4578 :         }
; 4579 : 
; 4580 :         /* Check operation code if within domain of a Locate Record */
; 4581 :         if (dev->ckdlcount > 0)

  063ff	48 8b 84 24 c0
	03 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  06407	0f b6 80 02 13
	00 00		 movzx	 eax, BYTE PTR [rax+4866]
  0640e	85 c0		 test	 eax, eax
  06410	7e 5d		 jle	 SHORT $LN402@ckd_dasd_e

; 4582 :         {
; 4583 :             if (!((dev->ckdloper & CKDOPER_CODE) == CKDOPER_FORMAT

  06412	48 8b 84 24 c0
	03 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  0641a	0f b6 80 00 13
	00 00		 movzx	 eax, BYTE PTR [rax+4864]
  06421	83 e0 3f	 and	 eax, 63			; 0000003fH
  06424	83 f8 03	 cmp	 eax, 3
  06427	74 46		 je	 SHORT $LN403@ckd_dasd_e
  06429	48 8b 84 24 c0
	03 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  06431	0f b6 80 00 13
	00 00		 movzx	 eax, BYTE PTR [rax+4864]
  06438	83 e0 3f	 and	 eax, 63			; 0000003fH
  0643b	83 f8 0b	 cmp	 eax, 11
  0643e	74 2f		 je	 SHORT $LN403@ckd_dasd_e

; 4584 :                   || (dev->ckdloper & CKDOPER_CODE) == CKDOPER_WRTTRK))
; 4585 :             {
; 4586 :                 ckd_build_sense (dev, SENSE_CR, 0, 0,

  06440	c6 44 24 28 02	 mov	 BYTE PTR [rsp+40], 2
  06445	c6 44 24 20 00	 mov	 BYTE PTR [rsp+32], 0
  0644a	45 33 c9	 xor	 r9d, r9d
  0644d	45 33 c0	 xor	 r8d, r8d
  06450	b2 80		 mov	 dl, 128			; 00000080H
  06452	48 8b 8c 24 c0
	03 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  0645a	e8 00 00 00 00	 call	 ckd_build_sense

; 4587 :                                 FORMAT_0, MESSAGE_2);
; 4588 :                 *unitstat = CSW_CE | CSW_DE | CSW_UC;

  0645f	48 8b 84 24 08
	04 00 00	 mov	 rax, QWORD PTR unitstat$[rsp]
  06467	c6 00 0e	 mov	 BYTE PTR [rax], 14

; 4589 :                 break;

  0646a	e9 e1 40 00 00	 jmp	 $LN2@ckd_dasd_e
$LN403@ckd_dasd_e:
$LN402@ckd_dasd_e:

; 4590 :             }
; 4591 :         }
; 4592 : 
; 4593 :         /* Set track overflow flag if WRITE SPECIAL CKD */
; 4594 :         trk_ovfl = (dev->ckdcyls < 32768 && code==0x01) ? 1 : 0;

  0646f	48 8b 84 24 c0
	03 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  06477	81 b8 b8 12 00
	00 00 80 00 00	 cmp	 DWORD PTR [rax+4792], 32768 ; 00008000H
  06481	7d 1a		 jge	 SHORT $LN737@ckd_dasd_e
  06483	0f b6 84 24 c8
	03 00 00	 movzx	 eax, BYTE PTR code$[rsp]
  0648b	83 f8 01	 cmp	 eax, 1
  0648e	75 0d		 jne	 SHORT $LN737@ckd_dasd_e
  06490	c7 84 24 8c 01
	00 00 01 00 00
	00		 mov	 DWORD PTR tv3114[rsp], 1
  0649b	eb 0b		 jmp	 SHORT $LN738@ckd_dasd_e
$LN737@ckd_dasd_e:
  0649d	c7 84 24 8c 01
	00 00 00 00 00
	00		 mov	 DWORD PTR tv3114[rsp], 0
$LN738@ckd_dasd_e:
  064a8	0f b6 84 24 8c
	01 00 00	 movzx	 eax, BYTE PTR tv3114[rsp]
  064b0	88 84 24 ad 00
	00 00		 mov	 BYTE PTR trk_ovfl$[rsp], al

; 4595 : 
; 4596 :         /* Write count key and data */
; 4597 :         rc = ckd_write_ckd (dev, iobuf, count, unitstat, trk_ovfl);

  064b7	0f b6 84 24 ad
	00 00 00	 movzx	 eax, BYTE PTR trk_ovfl$[rsp]
  064bf	88 44 24 20	 mov	 BYTE PTR [rsp+32], al
  064c3	4c 8b 8c 24 08
	04 00 00	 mov	 r9, QWORD PTR unitstat$[rsp]
  064cb	44 8b 84 24 e0
	03 00 00	 mov	 r8d, DWORD PTR count$[rsp]
  064d3	48 8b 94 24 f8
	03 00 00	 mov	 rdx, QWORD PTR iobuf$[rsp]
  064db	48 8b 8c 24 c0
	03 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  064e3	e8 00 00 00 00	 call	 ckd_write_ckd
  064e8	89 44 24 60	 mov	 DWORD PTR rc$[rsp], eax

; 4598 :         if (rc < 0) break;

  064ec	83 7c 24 60 00	 cmp	 DWORD PTR rc$[rsp], 0
  064f1	7d 05		 jge	 SHORT $LN404@ckd_dasd_e
  064f3	e9 58 40 00 00	 jmp	 $LN2@ckd_dasd_e
$LN404@ckd_dasd_e:

; 4599 : 
; 4600 :         /* Calculate number of bytes written and set residual count */
; 4601 :         size = CKD_RECHDR_SIZE + dev->ckdcurkl + dev->ckdcurdl;

  064f8	48 8b 84 24 c0
	03 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  06500	48 63 80 d4 12
	00 00		 movsxd	 rax, DWORD PTR [rax+4820]
  06507	48 8b 8c 24 c0
	03 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  0650f	0f b7 89 ea 12
	00 00		 movzx	 ecx, WORD PTR [rcx+4842]
  06516	48 8d 44 08 08	 lea	 rax, QWORD PTR [rax+rcx+8]
  0651b	89 44 24 68	 mov	 DWORD PTR size$[rsp], eax

; 4602 :         num = (count < size) ? count : size;

  0651f	8b 44 24 68	 mov	 eax, DWORD PTR size$[rsp]
  06523	39 84 24 e0 03
	00 00		 cmp	 DWORD PTR count$[rsp], eax
  0652a	73 10		 jae	 SHORT $LN739@ckd_dasd_e
  0652c	8b 84 24 e0 03
	00 00		 mov	 eax, DWORD PTR count$[rsp]
  06533	89 84 24 90 01
	00 00		 mov	 DWORD PTR tv3131[rsp], eax
  0653a	eb 0b		 jmp	 SHORT $LN740@ckd_dasd_e
$LN739@ckd_dasd_e:
  0653c	8b 44 24 68	 mov	 eax, DWORD PTR size$[rsp]
  06540	89 84 24 90 01
	00 00		 mov	 DWORD PTR tv3131[rsp], eax
$LN740@ckd_dasd_e:
  06547	8b 84 24 90 01
	00 00		 mov	 eax, DWORD PTR tv3131[rsp]
  0654e	89 44 24 64	 mov	 DWORD PTR num$[rsp], eax

; 4603 :         *residual = count - num;

  06552	8b 44 24 64	 mov	 eax, DWORD PTR num$[rsp]
  06556	8b 8c 24 e0 03
	00 00		 mov	 ecx, DWORD PTR count$[rsp]
  0655d	2b c8		 sub	 ecx, eax
  0655f	8b c1		 mov	 eax, ecx
  06561	48 8b 8c 24 10
	04 00 00	 mov	 rcx, QWORD PTR residual$[rsp]
  06569	89 01		 mov	 DWORD PTR [rcx], eax

; 4604 : 
; 4605 :         /* Return normal status */
; 4606 :         *unitstat = CSW_CE | CSW_DE;

  0656b	48 8b 84 24 08
	04 00 00	 mov	 rax, QWORD PTR unitstat$[rsp]
  06573	c6 00 0c	 mov	 BYTE PTR [rax], 12

; 4607 : 
; 4608 :         /* Set flag if Write CKD outside domain of a locate record */
; 4609 :         if (dev->ckdlcount == 0)

  06576	48 8b 84 24 c0
	03 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  0657e	0f b6 80 02 13
	00 00		 movzx	 eax, BYTE PTR [rax+4866]
  06585	85 c0		 test	 eax, eax
  06587	75 22		 jne	 SHORT $LN405@ckd_dasd_e

; 4610 :             dev->ckdwckd = 1;

  06589	48 8b 84 24 c0
	03 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  06591	8b 80 14 13 00
	00		 mov	 eax, DWORD PTR [rax+4884]
  06597	0f ba e8 0e	 bts	 eax, 14
  0659b	48 8b 8c 24 c0
	03 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  065a3	89 81 14 13 00
	00		 mov	 DWORD PTR [rcx+4884], eax
  065a9	eb 20		 jmp	 SHORT $LN406@ckd_dasd_e
$LN405@ckd_dasd_e:

; 4611 :         else
; 4612 :             dev->ckdwckd = 0;

  065ab	48 8b 84 24 c0
	03 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  065b3	8b 80 14 13 00
	00		 mov	 eax, DWORD PTR [rax+4884]
  065b9	0f ba f0 0e	 btr	 eax, 14
  065bd	48 8b 8c 24 c0
	03 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  065c5	89 81 14 13 00
	00		 mov	 DWORD PTR [rcx+4884], eax
$LN406@ckd_dasd_e:

; 4613 : 
; 4614 :         break;

  065cb	e9 80 3f 00 00	 jmp	 $LN2@ckd_dasd_e
$LN407@ckd_dasd_e:

; 4615 : 
; 4616 :     case 0x9D:
; 4617 :     /*---------------------------------------------------------------*/
; 4618 :     /* WRITE COUNT KEY AND DATA NEXT TRACK                           */
; 4619 :     /*---------------------------------------------------------------*/
; 4620 :         /* Command reject if not within the domain of a Locate Record
; 4621 :            that specifies a format write operation */
; 4622 :         if (dev->ckdlcount == 0
; 4623 :             || (dev->ckdloper & CKDOPER_CODE) != CKDOPER_FORMAT)

  065d0	48 8b 84 24 c0
	03 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  065d8	0f b6 80 02 13
	00 00		 movzx	 eax, BYTE PTR [rax+4866]
  065df	85 c0		 test	 eax, eax
  065e1	74 17		 je	 SHORT $LN409@ckd_dasd_e
  065e3	48 8b 84 24 c0
	03 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  065eb	0f b6 80 00 13
	00 00		 movzx	 eax, BYTE PTR [rax+4864]
  065f2	83 e0 3f	 and	 eax, 63			; 0000003fH
  065f5	83 f8 03	 cmp	 eax, 3
  065f8	74 2f		 je	 SHORT $LN408@ckd_dasd_e
$LN409@ckd_dasd_e:

; 4624 :         {
; 4625 :             ckd_build_sense (dev, SENSE_CR, 0, 0,

  065fa	c6 44 24 28 02	 mov	 BYTE PTR [rsp+40], 2
  065ff	c6 44 24 20 00	 mov	 BYTE PTR [rsp+32], 0
  06604	45 33 c9	 xor	 r9d, r9d
  06607	45 33 c0	 xor	 r8d, r8d
  0660a	b2 80		 mov	 dl, 128			; 00000080H
  0660c	48 8b 8c 24 c0
	03 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  06614	e8 00 00 00 00	 call	 ckd_build_sense

; 4626 :                             FORMAT_0, MESSAGE_2);
; 4627 :             *unitstat = CSW_CE | CSW_DE | CSW_UC;

  06619	48 8b 84 24 08
	04 00 00	 mov	 rax, QWORD PTR unitstat$[rsp]
  06621	c6 00 0e	 mov	 BYTE PTR [rax], 14

; 4628 :             break;

  06624	e9 27 3f 00 00	 jmp	 $LN2@ckd_dasd_e
$LN408@ckd_dasd_e:

; 4629 :         }
; 4630 : 
; 4631 :         /* Command reject if not chained from a Write CKD or
; 4632 :            another Write CKD Next Track command */
; 4633 :         if (chained == 0
; 4634 :             || (prevcode != 0x1D && prevcode != 0x9D))

  06629	0f b6 84 24 d8
	03 00 00	 movzx	 eax, BYTE PTR chained$[rsp]
  06631	85 c0		 test	 eax, eax
  06633	74 1c		 je	 SHORT $LN411@ckd_dasd_e
  06635	0f b6 84 24 e8
	03 00 00	 movzx	 eax, BYTE PTR prevcode$[rsp]
  0663d	83 f8 1d	 cmp	 eax, 29
  06640	74 3e		 je	 SHORT $LN410@ckd_dasd_e
  06642	0f b6 84 24 e8
	03 00 00	 movzx	 eax, BYTE PTR prevcode$[rsp]
  0664a	3d 9d 00 00 00	 cmp	 eax, 157		; 0000009dH
  0664f	74 2f		 je	 SHORT $LN410@ckd_dasd_e
$LN411@ckd_dasd_e:

; 4635 :         {
; 4636 :             ckd_build_sense (dev, SENSE_CR, 0, 0,

  06651	c6 44 24 28 02	 mov	 BYTE PTR [rsp+40], 2
  06656	c6 44 24 20 00	 mov	 BYTE PTR [rsp+32], 0
  0665b	45 33 c9	 xor	 r9d, r9d
  0665e	45 33 c0	 xor	 r8d, r8d
  06661	b2 80		 mov	 dl, 128			; 00000080H
  06663	48 8b 8c 24 c0
	03 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  0666b	e8 00 00 00 00	 call	 ckd_build_sense

; 4637 :                             FORMAT_0, MESSAGE_2);
; 4638 :             *unitstat = CSW_CE | CSW_DE | CSW_UC;

  06670	48 8b 84 24 08
	04 00 00	 mov	 rax, QWORD PTR unitstat$[rsp]
  06678	c6 00 0e	 mov	 BYTE PTR [rax], 14

; 4639 :             break;

  0667b	e9 d0 3e 00 00	 jmp	 $LN2@ckd_dasd_e
$LN410@ckd_dasd_e:

; 4640 :         }
; 4641 : 
; 4642 :         /* Advance to next track */
; 4643 :         rc = mt_advance (dev, unitstat, 1);

  06680	41 b8 01 00 00
	00		 mov	 r8d, 1
  06686	48 8b 94 24 08
	04 00 00	 mov	 rdx, QWORD PTR unitstat$[rsp]
  0668e	48 8b 8c 24 c0
	03 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  06696	e8 00 00 00 00	 call	 mt_advance
  0669b	89 44 24 60	 mov	 DWORD PTR rc$[rsp], eax

; 4644 :         if (rc < 0) break;

  0669f	83 7c 24 60 00	 cmp	 DWORD PTR rc$[rsp], 0
  066a4	7d 05		 jge	 SHORT $LN412@ckd_dasd_e
  066a6	e9 a5 3e 00 00	 jmp	 $LN2@ckd_dasd_e
$LN412@ckd_dasd_e:

; 4645 : 
; 4646 :         /* Read the count field for record zero */
; 4647 :         rc = ckd_read_count (dev, code, &rechdr, unitstat);

  066ab	4c 8b 8c 24 08
	04 00 00	 mov	 r9, QWORD PTR unitstat$[rsp]
  066b3	4c 8d 84 24 38
	02 00 00	 lea	 r8, QWORD PTR rechdr$[rsp]
  066bb	0f b6 94 24 c8
	03 00 00	 movzx	 edx, BYTE PTR code$[rsp]
  066c3	48 8b 8c 24 c0
	03 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  066cb	e8 00 00 00 00	 call	 ckd_read_count
  066d0	89 44 24 60	 mov	 DWORD PTR rc$[rsp], eax

; 4648 :         if (rc < 0) break;

  066d4	83 7c 24 60 00	 cmp	 DWORD PTR rc$[rsp], 0
  066d9	7d 05		 jge	 SHORT $LN413@ckd_dasd_e
  066db	e9 70 3e 00 00	 jmp	 $LN2@ckd_dasd_e
$LN413@ckd_dasd_e:

; 4649 : 
; 4650 :         /* Write count key and data */
; 4651 :         rc = ckd_write_ckd (dev, iobuf, count, unitstat, 0);

  066e0	c6 44 24 20 00	 mov	 BYTE PTR [rsp+32], 0
  066e5	4c 8b 8c 24 08
	04 00 00	 mov	 r9, QWORD PTR unitstat$[rsp]
  066ed	44 8b 84 24 e0
	03 00 00	 mov	 r8d, DWORD PTR count$[rsp]
  066f5	48 8b 94 24 f8
	03 00 00	 mov	 rdx, QWORD PTR iobuf$[rsp]
  066fd	48 8b 8c 24 c0
	03 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  06705	e8 00 00 00 00	 call	 ckd_write_ckd
  0670a	89 44 24 60	 mov	 DWORD PTR rc$[rsp], eax

; 4652 :         if (rc < 0) break;

  0670e	83 7c 24 60 00	 cmp	 DWORD PTR rc$[rsp], 0
  06713	7d 05		 jge	 SHORT $LN414@ckd_dasd_e
  06715	e9 36 3e 00 00	 jmp	 $LN2@ckd_dasd_e
$LN414@ckd_dasd_e:

; 4653 : 
; 4654 :         /* Calculate number of bytes written and set residual count */
; 4655 :         size = CKD_RECHDR_SIZE + dev->ckdcurkl + dev->ckdcurdl;

  0671a	48 8b 84 24 c0
	03 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  06722	48 63 80 d4 12
	00 00		 movsxd	 rax, DWORD PTR [rax+4820]
  06729	48 8b 8c 24 c0
	03 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  06731	0f b7 89 ea 12
	00 00		 movzx	 ecx, WORD PTR [rcx+4842]
  06738	48 8d 44 08 08	 lea	 rax, QWORD PTR [rax+rcx+8]
  0673d	89 44 24 68	 mov	 DWORD PTR size$[rsp], eax

; 4656 :         num = (count < size) ? count : size;

  06741	8b 44 24 68	 mov	 eax, DWORD PTR size$[rsp]
  06745	39 84 24 e0 03
	00 00		 cmp	 DWORD PTR count$[rsp], eax
  0674c	73 10		 jae	 SHORT $LN741@ckd_dasd_e
  0674e	8b 84 24 e0 03
	00 00		 mov	 eax, DWORD PTR count$[rsp]
  06755	89 84 24 94 01
	00 00		 mov	 DWORD PTR tv3193[rsp], eax
  0675c	eb 0b		 jmp	 SHORT $LN742@ckd_dasd_e
$LN741@ckd_dasd_e:
  0675e	8b 44 24 68	 mov	 eax, DWORD PTR size$[rsp]
  06762	89 84 24 94 01
	00 00		 mov	 DWORD PTR tv3193[rsp], eax
$LN742@ckd_dasd_e:
  06769	8b 84 24 94 01
	00 00		 mov	 eax, DWORD PTR tv3193[rsp]
  06770	89 44 24 64	 mov	 DWORD PTR num$[rsp], eax

; 4657 :         *residual = count - num;

  06774	8b 44 24 64	 mov	 eax, DWORD PTR num$[rsp]
  06778	8b 8c 24 e0 03
	00 00		 mov	 ecx, DWORD PTR count$[rsp]
  0677f	2b c8		 sub	 ecx, eax
  06781	8b c1		 mov	 eax, ecx
  06783	48 8b 8c 24 10
	04 00 00	 mov	 rcx, QWORD PTR residual$[rsp]
  0678b	89 01		 mov	 DWORD PTR [rcx], eax

; 4658 : 
; 4659 :         /* Return normal status */
; 4660 :         *unitstat = CSW_CE | CSW_DE;

  0678d	48 8b 84 24 08
	04 00 00	 mov	 rax, QWORD PTR unitstat$[rsp]
  06795	c6 00 0c	 mov	 BYTE PTR [rax], 12

; 4661 : 
; 4662 :         break;

  06798	e9 b3 3d 00 00	 jmp	 $LN2@ckd_dasd_e
$LN415@ckd_dasd_e:
$LN416@ckd_dasd_e:

; 4663 : 
; 4664 :     case 0x47:
; 4665 :     case 0xe7:
; 4666 :     {
; 4667 :         /*---------------------------------------------------------------*/
; 4668 :         /* LOCATE RECORD                                                 */
; 4669 :         /*---------------------------------------------------------------*/
; 4670 :             /* Calculate residual byte count */
; 4671 :         int bcyl, bhead, ecyl, ehead;
; 4672 :         U16 xblksz;
; 4673 :         if (code == 0x47)

  0679d	0f b6 84 24 c8
	03 00 00	 movzx	 eax, BYTE PTR code$[rsp]
  067a5	83 f8 47	 cmp	 eax, 71			; 00000047H
  067a8	0f 85 1b 01 00
	00		 jne	 $LN417@ckd_dasd_e

; 4674 :         {
; 4675 :             num = (count < 16) ? count : 16;

  067ae	83 bc 24 e0 03
	00 00 10	 cmp	 DWORD PTR count$[rsp], 16
  067b6	73 10		 jae	 SHORT $LN743@ckd_dasd_e
  067b8	8b 84 24 e0 03
	00 00		 mov	 eax, DWORD PTR count$[rsp]
  067bf	89 84 24 98 01
	00 00		 mov	 DWORD PTR tv3198[rsp], eax
  067c6	eb 0b		 jmp	 SHORT $LN744@ckd_dasd_e
$LN743@ckd_dasd_e:
  067c8	c7 84 24 98 01
	00 00 10 00 00
	00		 mov	 DWORD PTR tv3198[rsp], 16
$LN744@ckd_dasd_e:
  067d3	8b 84 24 98 01
	00 00		 mov	 eax, DWORD PTR tv3198[rsp]
  067da	89 44 24 64	 mov	 DWORD PTR num$[rsp], eax

; 4676 :             *residual = count - num;

  067de	8b 44 24 64	 mov	 eax, DWORD PTR num$[rsp]
  067e2	8b 8c 24 e0 03
	00 00		 mov	 ecx, DWORD PTR count$[rsp]
  067e9	2b c8		 sub	 ecx, eax
  067eb	8b c1		 mov	 eax, ecx
  067ed	48 8b 8c 24 10
	04 00 00	 mov	 rcx, QWORD PTR residual$[rsp]
  067f5	89 01		 mov	 DWORD PTR [rcx], eax

; 4677 : 
; 4678 :             /* Control information length must be at least 16 bytes */
; 4679 :             if (count < 16)

  067f7	83 bc 24 e0 03
	00 00 10	 cmp	 DWORD PTR count$[rsp], 16
  067ff	73 2f		 jae	 SHORT $LN419@ckd_dasd_e

; 4680 :             {
; 4681 :                 ckd_build_sense(dev, SENSE_CR, 0, 0,

  06801	c6 44 24 28 03	 mov	 BYTE PTR [rsp+40], 3
  06806	c6 44 24 20 00	 mov	 BYTE PTR [rsp+32], 0
  0680b	45 33 c9	 xor	 r9d, r9d
  0680e	45 33 c0	 xor	 r8d, r8d
  06811	b2 80		 mov	 dl, 128			; 00000080H
  06813	48 8b 8c 24 c0
	03 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  0681b	e8 00 00 00 00	 call	 ckd_build_sense

; 4682 :                     FORMAT_0, MESSAGE_3);
; 4683 :                 *unitstat = CSW_CE | CSW_DE | CSW_UC;

  06820	48 8b 84 24 08
	04 00 00	 mov	 rax, QWORD PTR unitstat$[rsp]
  06828	c6 00 0e	 mov	 BYTE PTR [rax], 14

; 4684 :                 break;

  0682b	e9 20 3d 00 00	 jmp	 $LN2@ckd_dasd_e
$LN419@ckd_dasd_e:

; 4685 :             }
; 4686 :             /* Command reject if within the domain of a Locate Record,
; 4687 :                or not preceded by a Define Extent or Read IPL command */
; 4688 :             if (dev->ckdlcount > 0
; 4689 :                 || (dev->ckdxtdef == 0 && dev->ckdrdipl == 0))

  06830	48 8b 84 24 c0
	03 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  06838	0f b6 80 02 13
	00 00		 movzx	 eax, BYTE PTR [rax+4866]
  0683f	85 c0		 test	 eax, eax
  06841	7f 2f		 jg	 SHORT $LN421@ckd_dasd_e
  06843	48 8b 84 24 c0
	03 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  0684b	8b 80 14 13 00
	00		 mov	 eax, DWORD PTR [rax+4884]
  06851	d1 e8		 shr	 eax, 1
  06853	83 e0 01	 and	 eax, 1
  06856	85 c0		 test	 eax, eax
  06858	75 47		 jne	 SHORT $LN420@ckd_dasd_e
  0685a	48 8b 84 24 c0
	03 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  06862	8b 80 14 13 00
	00		 mov	 eax, DWORD PTR [rax+4884]
  06868	c1 e8 09	 shr	 eax, 9
  0686b	83 e0 01	 and	 eax, 1
  0686e	85 c0		 test	 eax, eax
  06870	75 2f		 jne	 SHORT $LN420@ckd_dasd_e
$LN421@ckd_dasd_e:

; 4690 :             {
; 4691 :                 ckd_build_sense(dev, SENSE_CR, 0, 0,

  06872	c6 44 24 28 02	 mov	 BYTE PTR [rsp+40], 2
  06877	c6 44 24 20 00	 mov	 BYTE PTR [rsp+32], 0
  0687c	45 33 c9	 xor	 r9d, r9d
  0687f	45 33 c0	 xor	 r8d, r8d
  06882	b2 80		 mov	 dl, 128			; 00000080H
  06884	48 8b 8c 24 c0
	03 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  0688c	e8 00 00 00 00	 call	 ckd_build_sense

; 4692 :                     FORMAT_0, MESSAGE_2);
; 4693 :                 *unitstat = CSW_CE | CSW_DE | CSW_UC;

  06891	48 8b 84 24 08
	04 00 00	 mov	 rax, QWORD PTR unitstat$[rsp]
  06899	c6 00 0e	 mov	 BYTE PTR [rax], 14

; 4694 :                 break;

  0689c	e9 af 3c 00 00	 jmp	 $LN2@ckd_dasd_e
$LN420@ckd_dasd_e:

; 4695 :             }
; 4696 : 
; 4697 :             /* Byte 0 contains the locate record operation byte */
; 4698 :             dev->ckdloper = iobuf[0];

  068a1	b8 01 00 00 00	 mov	 eax, 1
  068a6	48 6b c0 00	 imul	 rax, rax, 0
  068aa	48 8b 8c 24 c0
	03 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  068b2	48 8b 94 24 f8
	03 00 00	 mov	 rdx, QWORD PTR iobuf$[rsp]
  068ba	0f b6 04 02	 movzx	 eax, BYTE PTR [rdx+rax]
  068be	88 81 00 13 00
	00		 mov	 BYTE PTR [rcx+4864], al

; 4699 :         }

  068c4	e9 5d 02 00 00	 jmp	 $LN418@ckd_dasd_e
$LN417@ckd_dasd_e:

; 4700 :         else
; 4701 :         {
; 4702 :             /* Bytes 8-11 contain the extent begin cylinder and head */
; 4703 :             bcyl = (iobuf[20] << 8) | iobuf[21];

  068c9	b8 01 00 00 00	 mov	 eax, 1
  068ce	48 6b c0 14	 imul	 rax, rax, 20
  068d2	48 8b 8c 24 f8
	03 00 00	 mov	 rcx, QWORD PTR iobuf$[rsp]
  068da	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  068de	c1 e0 08	 shl	 eax, 8
  068e1	b9 01 00 00 00	 mov	 ecx, 1
  068e6	48 6b c9 15	 imul	 rcx, rcx, 21
  068ea	48 8b 94 24 f8
	03 00 00	 mov	 rdx, QWORD PTR iobuf$[rsp]
  068f2	0f b6 0c 0a	 movzx	 ecx, BYTE PTR [rdx+rcx]
  068f6	0b c1		 or	 eax, ecx
  068f8	89 84 24 f0 01
	00 00		 mov	 DWORD PTR bcyl$12[rsp], eax

; 4704 :             bhead = (iobuf[22] << 8) | iobuf[23];

  068ff	b8 01 00 00 00	 mov	 eax, 1
  06904	48 6b c0 16	 imul	 rax, rax, 22
  06908	48 8b 8c 24 f8
	03 00 00	 mov	 rcx, QWORD PTR iobuf$[rsp]
  06910	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  06914	c1 e0 08	 shl	 eax, 8
  06917	b9 01 00 00 00	 mov	 ecx, 1
  0691c	48 6b c9 17	 imul	 rcx, rcx, 23
  06920	48 8b 94 24 f8
	03 00 00	 mov	 rdx, QWORD PTR iobuf$[rsp]
  06928	0f b6 0c 0a	 movzx	 ecx, BYTE PTR [rdx+rcx]
  0692c	0b c1		 or	 eax, ecx
  0692e	89 84 24 f4 01
	00 00		 mov	 DWORD PTR bhead$13[rsp], eax

; 4705 :             /* Bytes 12-15 contain the extent end cylinder and head */
; 4706 :             ecyl = (iobuf[24] << 8) | iobuf[25];

  06935	b8 01 00 00 00	 mov	 eax, 1
  0693a	48 6b c0 18	 imul	 rax, rax, 24
  0693e	48 8b 8c 24 f8
	03 00 00	 mov	 rcx, QWORD PTR iobuf$[rsp]
  06946	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  0694a	c1 e0 08	 shl	 eax, 8
  0694d	b9 01 00 00 00	 mov	 ecx, 1
  06952	48 6b c9 19	 imul	 rcx, rcx, 25
  06956	48 8b 94 24 f8
	03 00 00	 mov	 rdx, QWORD PTR iobuf$[rsp]
  0695e	0f b6 0c 0a	 movzx	 ecx, BYTE PTR [rdx+rcx]
  06962	0b c1		 or	 eax, ecx
  06964	89 84 24 f8 01
	00 00		 mov	 DWORD PTR ecyl$14[rsp], eax

; 4707 :             ehead = (iobuf[26] << 8) | iobuf[27];

  0696b	b8 01 00 00 00	 mov	 eax, 1
  06970	48 6b c0 1a	 imul	 rax, rax, 26
  06974	48 8b 8c 24 f8
	03 00 00	 mov	 rcx, QWORD PTR iobuf$[rsp]
  0697c	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  06980	c1 e0 08	 shl	 eax, 8
  06983	b9 01 00 00 00	 mov	 ecx, 1
  06988	48 6b c9 1b	 imul	 rcx, rcx, 27
  0698c	48 8b 94 24 f8
	03 00 00	 mov	 rdx, QWORD PTR iobuf$[rsp]
  06994	0f b6 0c 0a	 movzx	 ecx, BYTE PTR [rdx+rcx]
  06998	0b c1		 or	 eax, ecx
  0699a	89 84 24 fc 01
	00 00		 mov	 DWORD PTR ehead$15[rsp], eax

; 4708 :             dev->ckdxbcyl = bcyl;

  069a1	48 8b 84 24 c0
	03 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  069a9	0f b7 8c 24 f0
	01 00 00	 movzx	 ecx, WORD PTR bcyl$12[rsp]
  069b1	66 89 88 f2 12
	00 00		 mov	 WORD PTR [rax+4850], cx

; 4709 :             dev->ckdxbhead = bhead;

  069b8	48 8b 84 24 c0
	03 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  069c0	0f b7 8c 24 f4
	01 00 00	 movzx	 ecx, WORD PTR bhead$13[rsp]
  069c8	66 89 88 f4 12
	00 00		 mov	 WORD PTR [rax+4852], cx

; 4710 :             dev->ckdxecyl = ecyl;

  069cf	48 8b 84 24 c0
	03 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  069d7	0f b7 8c 24 f8
	01 00 00	 movzx	 ecx, WORD PTR ecyl$14[rsp]
  069df	66 89 88 f6 12
	00 00		 mov	 WORD PTR [rax+4854], cx

; 4711 :             dev->ckdxehead = ehead;

  069e6	48 8b 84 24 c0
	03 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  069ee	0f b7 8c 24 fc
	01 00 00	 movzx	 ecx, WORD PTR ehead$15[rsp]
  069f6	66 89 88 f8 12
	00 00		 mov	 WORD PTR [rax+4856], cx

; 4712 :             *residual = 0;

  069fd	48 8b 84 24 10
	04 00 00	 mov	 rax, QWORD PTR residual$[rsp]
  06a05	c7 00 00 00 00
	00		 mov	 DWORD PTR [rax], 0

; 4713 :             dev->ckdloper = iobuf[44];

  06a0b	b8 01 00 00 00	 mov	 eax, 1
  06a10	48 6b c0 2c	 imul	 rax, rax, 44		; 0000002cH
  06a14	48 8b 8c 24 c0
	03 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  06a1c	48 8b 94 24 f8
	03 00 00	 mov	 rdx, QWORD PTR iobuf$[rsp]
  06a24	0f b6 04 02	 movzx	 eax, BYTE PTR [rdx+rax]
  06a28	88 81 00 13 00
	00		 mov	 BYTE PTR [rcx+4864], al

; 4714 :             /* Bytes 2-3 contain the extent block size */
; 4715 :             xblksz = (iobuf[14] << 8) | iobuf[15];

  06a2e	b8 01 00 00 00	 mov	 eax, 1
  06a33	48 6b c0 0e	 imul	 rax, rax, 14
  06a37	48 8b 8c 24 f8
	03 00 00	 mov	 rcx, QWORD PTR iobuf$[rsp]
  06a3f	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  06a43	c1 e0 08	 shl	 eax, 8
  06a46	b9 01 00 00 00	 mov	 ecx, 1
  06a4b	48 6b c9 0f	 imul	 rcx, rcx, 15
  06a4f	48 8b 94 24 f8
	03 00 00	 mov	 rdx, QWORD PTR iobuf$[rsp]
  06a57	0f b6 0c 0a	 movzx	 ecx, BYTE PTR [rdx+rcx]
  06a5b	0b c1		 or	 eax, ecx
  06a5d	66 89 84 24 94
	00 00 00	 mov	 WORD PTR xblksz$8[rsp], ax

; 4716 : 
; 4717 :             /* If extent block size is zero then use the maximum R0
; 4718 :                record length (as returned in device characteristics
; 4719 :                bytes 44 and 45) plus 8 */
; 4720 :             if (xblksz == 0)

  06a65	0f b7 84 24 94
	00 00 00	 movzx	 eax, WORD PTR xblksz$8[rsp]
  06a6d	85 c0		 test	 eax, eax
  06a6f	75 1e		 jne	 SHORT $LN422@ckd_dasd_e

; 4721 :                 xblksz = dev->ckdtab->r0 + 8;

  06a71	48 8b 84 24 c0
	03 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  06a79	48 8b 80 a0 12
	00 00		 mov	 rax, QWORD PTR [rax+4768]
  06a80	0f b7 40 14	 movzx	 eax, WORD PTR [rax+20]
  06a84	83 c0 08	 add	 eax, 8
  06a87	66 89 84 24 94
	00 00 00	 mov	 WORD PTR xblksz$8[rsp], ax
$LN422@ckd_dasd_e:

; 4722 : 
; 4723 :             if (dev->ckdxtdef
; 4724 :                 && dev->ckdxblksz != xblksz)

  06a8f	48 8b 84 24 c0
	03 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  06a97	8b 80 14 13 00
	00		 mov	 eax, DWORD PTR [rax+4884]
  06a9d	d1 e8		 shr	 eax, 1
  06a9f	83 e0 01	 and	 eax, 1
  06aa2	85 c0		 test	 eax, eax
  06aa4	74 4a		 je	 SHORT $LN423@ckd_dasd_e
  06aa6	48 8b 84 24 c0
	03 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  06aae	0f b7 80 f0 12
	00 00		 movzx	 eax, WORD PTR [rax+4848]
  06ab5	0f b7 8c 24 94
	00 00 00	 movzx	 ecx, WORD PTR xblksz$8[rsp]
  06abd	3b c1		 cmp	 eax, ecx
  06abf	74 2f		 je	 SHORT $LN423@ckd_dasd_e

; 4725 :             {
; 4726 :                 ckd_build_sense(dev, SENSE_CR, 0, 0,

  06ac1	c6 44 24 28 02	 mov	 BYTE PTR [rsp+40], 2
  06ac6	c6 44 24 20 00	 mov	 BYTE PTR [rsp+32], 0
  06acb	45 33 c9	 xor	 r9d, r9d
  06ace	45 33 c0	 xor	 r8d, r8d
  06ad1	b2 80		 mov	 dl, 128			; 00000080H
  06ad3	48 8b 8c 24 c0
	03 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  06adb	e8 00 00 00 00	 call	 ckd_build_sense

; 4727 :                     FORMAT_0, MESSAGE_2);
; 4728 :                 *unitstat = CSW_CE | CSW_DE | CSW_UC;

  06ae0	48 8b 84 24 08
	04 00 00	 mov	 rax, QWORD PTR unitstat$[rsp]
  06ae8	c6 00 0e	 mov	 BYTE PTR [rax], 14

; 4729 :                 break;

  06aeb	e9 60 3a 00 00	 jmp	 $LN2@ckd_dasd_e
$LN423@ckd_dasd_e:

; 4730 :             }
; 4731 :             dev->ckdxblksz = xblksz;

  06af0	48 8b 84 24 c0
	03 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  06af8	0f b7 8c 24 94
	00 00 00	 movzx	 ecx, WORD PTR xblksz$8[rsp]
  06b00	66 89 88 f0 12
	00 00		 mov	 WORD PTR [rax+4848], cx

; 4732 :             dev->ckdxtdef = 1;

  06b07	48 8b 84 24 c0
	03 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  06b0f	8b 80 14 13 00
	00		 mov	 eax, DWORD PTR [rax+4884]
  06b15	83 c8 02	 or	 eax, 2
  06b18	48 8b 8c 24 c0
	03 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  06b20	89 81 14 13 00
	00		 mov	 DWORD PTR [rcx+4884], eax
$LN418@ckd_dasd_e:

; 4733 :         }
; 4734 :         /* Validate the locate record operation code (bits 2-7) */
; 4735 :         if (!((dev->ckdloper & CKDOPER_CODE) == CKDOPER_ORIENT

  06b26	48 8b 84 24 c0
	03 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  06b2e	0f b6 80 00 13
	00 00		 movzx	 eax, BYTE PTR [rax+4864]
  06b35	83 e0 3f	 and	 eax, 63			; 0000003fH
  06b38	85 c0		 test	 eax, eax
  06b3a	0f 84 c1 00 00
	00		 je	 $LN424@ckd_dasd_e
  06b40	48 8b 84 24 c0
	03 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  06b48	0f b6 80 00 13
	00 00		 movzx	 eax, BYTE PTR [rax+4864]
  06b4f	83 e0 3f	 and	 eax, 63			; 0000003fH
  06b52	83 f8 01	 cmp	 eax, 1
  06b55	0f 84 a6 00 00
	00		 je	 $LN424@ckd_dasd_e
  06b5b	48 8b 84 24 c0
	03 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  06b63	0f b6 80 00 13
	00 00		 movzx	 eax, BYTE PTR [rax+4864]
  06b6a	83 e0 3f	 and	 eax, 63			; 0000003fH
  06b6d	83 f8 03	 cmp	 eax, 3
  06b70	0f 84 8b 00 00
	00		 je	 $LN424@ckd_dasd_e
  06b76	48 8b 84 24 c0
	03 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  06b7e	0f b6 80 00 13
	00 00		 movzx	 eax, BYTE PTR [rax+4864]
  06b85	83 e0 3f	 and	 eax, 63			; 0000003fH
  06b88	83 f8 06	 cmp	 eax, 6
  06b8b	74 74		 je	 SHORT $LN424@ckd_dasd_e
  06b8d	48 8b 84 24 c0
	03 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  06b95	0f b6 80 00 13
	00 00		 movzx	 eax, BYTE PTR [rax+4864]
  06b9c	83 e0 3f	 and	 eax, 63			; 0000003fH
  06b9f	83 f8 0b	 cmp	 eax, 11
  06ba2	74 5d		 je	 SHORT $LN424@ckd_dasd_e
  06ba4	48 8b 84 24 c0
	03 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  06bac	0f b6 80 00 13
	00 00		 movzx	 eax, BYTE PTR [rax+4864]
  06bb3	83 e0 3f	 and	 eax, 63			; 0000003fH
  06bb6	83 f8 0c	 cmp	 eax, 12
  06bb9	74 46		 je	 SHORT $LN424@ckd_dasd_e
  06bbb	48 8b 84 24 c0
	03 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  06bc3	0f b6 80 00 13
	00 00		 movzx	 eax, BYTE PTR [rax+4864]
  06bca	83 e0 3f	 and	 eax, 63			; 0000003fH
  06bcd	83 f8 16	 cmp	 eax, 22
  06bd0	74 2f		 je	 SHORT $LN424@ckd_dasd_e

; 4736 :             || (dev->ckdloper & CKDOPER_CODE) == CKDOPER_WRITE
; 4737 :             || (dev->ckdloper & CKDOPER_CODE) == CKDOPER_FORMAT
; 4738 :             || (dev->ckdloper & CKDOPER_CODE) == CKDOPER_RDDATA
; 4739 :             || (dev->ckdloper & CKDOPER_CODE) == CKDOPER_WRTTRK
; 4740 :             || (dev->ckdloper & CKDOPER_CODE) == CKDOPER_RDTRKS
; 4741 :             || (dev->ckdloper & CKDOPER_CODE) == CKDOPER_READ))
; 4742 :         {
; 4743 :             ckd_build_sense(dev, SENSE_CR, 0, 0,

  06bd2	c6 44 24 28 04	 mov	 BYTE PTR [rsp+40], 4
  06bd7	c6 44 24 20 00	 mov	 BYTE PTR [rsp+32], 0
  06bdc	45 33 c9	 xor	 r9d, r9d
  06bdf	45 33 c0	 xor	 r8d, r8d
  06be2	b2 80		 mov	 dl, 128			; 00000080H
  06be4	48 8b 8c 24 c0
	03 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  06bec	e8 00 00 00 00	 call	 ckd_build_sense

; 4744 :                 FORMAT_0, MESSAGE_4);
; 4745 :             *unitstat = CSW_CE | CSW_DE | CSW_UC;

  06bf1	48 8b 84 24 08
	04 00 00	 mov	 rax, QWORD PTR unitstat$[rsp]
  06bf9	c6 00 0e	 mov	 BYTE PTR [rax], 14

; 4746 :             break;

  06bfc	e9 4f 39 00 00	 jmp	 $LN2@ckd_dasd_e
$LN424@ckd_dasd_e:

; 4747 :         }
; 4748 : 
; 4749 :         /* Check for valid combination of orientation and opcode */
; 4750 :         if (((dev->ckdloper & CKDOPER_ORIENTATION)
; 4751 :             == CKDOPER_ORIENT_HOME
; 4752 :             && !((dev->ckdloper & CKDOPER_CODE) == CKDOPER_ORIENT
; 4753 :                 || (dev->ckdloper & CKDOPER_CODE) == CKDOPER_FORMAT
; 4754 :                 || (dev->ckdloper & CKDOPER_CODE) == CKDOPER_RDDATA
; 4755 :                 || (dev->ckdloper & CKDOPER_CODE) == CKDOPER_RDTRKS
; 4756 :                 || (dev->ckdloper & CKDOPER_CODE) == CKDOPER_READ))
; 4757 :             ||
; 4758 :             ((dev->ckdloper & CKDOPER_ORIENTATION)
; 4759 :                 == CKDOPER_ORIENT_DATA
; 4760 :                 && !((dev->ckdloper & CKDOPER_CODE) == CKDOPER_ORIENT
; 4761 :                     || (dev->ckdloper & CKDOPER_CODE) == CKDOPER_WRITE
; 4762 :                     || (dev->ckdloper & CKDOPER_CODE) == CKDOPER_RDDATA
; 4763 :                     || (dev->ckdloper & CKDOPER_CODE) == CKDOPER_READ))
; 4764 :             ||

  06c01	48 8b 84 24 c0
	03 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  06c09	0f b6 80 00 13
	00 00		 movzx	 eax, BYTE PTR [rax+4864]
  06c10	25 c0 00 00 00	 and	 eax, 192		; 000000c0H
  06c15	83 f8 40	 cmp	 eax, 64			; 00000040H
  06c18	75 76		 jne	 SHORT $LN427@ckd_dasd_e
  06c1a	48 8b 84 24 c0
	03 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  06c22	0f b6 80 00 13
	00 00		 movzx	 eax, BYTE PTR [rax+4864]
  06c29	83 e0 3f	 and	 eax, 63			; 0000003fH
  06c2c	85 c0		 test	 eax, eax
  06c2e	74 60		 je	 SHORT $LN428@ckd_dasd_e
  06c30	48 8b 84 24 c0
	03 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  06c38	0f b6 80 00 13
	00 00		 movzx	 eax, BYTE PTR [rax+4864]
  06c3f	83 e0 3f	 and	 eax, 63			; 0000003fH
  06c42	83 f8 03	 cmp	 eax, 3
  06c45	74 49		 je	 SHORT $LN428@ckd_dasd_e
  06c47	48 8b 84 24 c0
	03 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  06c4f	0f b6 80 00 13
	00 00		 movzx	 eax, BYTE PTR [rax+4864]
  06c56	83 e0 3f	 and	 eax, 63			; 0000003fH
  06c59	83 f8 06	 cmp	 eax, 6
  06c5c	74 32		 je	 SHORT $LN428@ckd_dasd_e
  06c5e	48 8b 84 24 c0
	03 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  06c66	0f b6 80 00 13
	00 00		 movzx	 eax, BYTE PTR [rax+4864]
  06c6d	83 e0 3f	 and	 eax, 63			; 0000003fH
  06c70	83 f8 0c	 cmp	 eax, 12
  06c73	74 1b		 je	 SHORT $LN428@ckd_dasd_e
  06c75	48 8b 84 24 c0
	03 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  06c7d	0f b6 80 00 13
	00 00		 movzx	 eax, BYTE PTR [rax+4864]
  06c84	83 e0 3f	 and	 eax, 63			; 0000003fH
  06c87	83 f8 16	 cmp	 eax, 22
  06c8a	0f 85 bf 00 00
	00		 jne	 $LN426@ckd_dasd_e
$LN428@ckd_dasd_e:
$LN427@ckd_dasd_e:
  06c90	48 8b 84 24 c0
	03 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  06c98	0f b6 80 00 13
	00 00		 movzx	 eax, BYTE PTR [rax+4864]
  06c9f	25 c0 00 00 00	 and	 eax, 192		; 000000c0H
  06ca4	3d 80 00 00 00	 cmp	 eax, 128		; 00000080H
  06ca9	75 5b		 jne	 SHORT $LN429@ckd_dasd_e
  06cab	48 8b 84 24 c0
	03 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  06cb3	0f b6 80 00 13
	00 00		 movzx	 eax, BYTE PTR [rax+4864]
  06cba	83 e0 3f	 and	 eax, 63			; 0000003fH
  06cbd	85 c0		 test	 eax, eax
  06cbf	74 45		 je	 SHORT $LN430@ckd_dasd_e
  06cc1	48 8b 84 24 c0
	03 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  06cc9	0f b6 80 00 13
	00 00		 movzx	 eax, BYTE PTR [rax+4864]
  06cd0	83 e0 3f	 and	 eax, 63			; 0000003fH
  06cd3	83 f8 01	 cmp	 eax, 1
  06cd6	74 2e		 je	 SHORT $LN430@ckd_dasd_e
  06cd8	48 8b 84 24 c0
	03 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  06ce0	0f b6 80 00 13
	00 00		 movzx	 eax, BYTE PTR [rax+4864]
  06ce7	83 e0 3f	 and	 eax, 63			; 0000003fH
  06cea	83 f8 06	 cmp	 eax, 6
  06ced	74 17		 je	 SHORT $LN430@ckd_dasd_e
  06cef	48 8b 84 24 c0
	03 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  06cf7	0f b6 80 00 13
	00 00		 movzx	 eax, BYTE PTR [rax+4864]
  06cfe	83 e0 3f	 and	 eax, 63			; 0000003fH
  06d01	83 f8 16	 cmp	 eax, 22
  06d04	75 49		 jne	 SHORT $LN426@ckd_dasd_e
$LN430@ckd_dasd_e:
$LN429@ckd_dasd_e:
  06d06	48 8b 84 24 c0
	03 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  06d0e	0f b6 80 00 13
	00 00		 movzx	 eax, BYTE PTR [rax+4864]
  06d15	25 c0 00 00 00	 and	 eax, 192		; 000000c0H
  06d1a	3d c0 00 00 00	 cmp	 eax, 192		; 000000c0H
  06d1f	75 5d		 jne	 SHORT $LN425@ckd_dasd_e
  06d21	48 8b 84 24 c0
	03 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  06d29	0f b6 80 00 13
	00 00		 movzx	 eax, BYTE PTR [rax+4864]
  06d30	83 e0 3f	 and	 eax, 63			; 0000003fH
  06d33	83 f8 03	 cmp	 eax, 3
  06d36	74 46		 je	 SHORT $LN425@ckd_dasd_e
  06d38	48 8b 84 24 c0
	03 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  06d40	0f b6 80 00 13
	00 00		 movzx	 eax, BYTE PTR [rax+4864]
  06d47	83 e0 3f	 and	 eax, 63			; 0000003fH
  06d4a	83 f8 16	 cmp	 eax, 22
  06d4d	74 2f		 je	 SHORT $LN425@ckd_dasd_e
$LN426@ckd_dasd_e:

; 4765 :             ((dev->ckdloper & CKDOPER_ORIENTATION)
; 4766 :                 == CKDOPER_ORIENT_INDEX
; 4767 :                 && !((dev->ckdloper & CKDOPER_CODE) == CKDOPER_FORMAT
; 4768 :                     || (dev->ckdloper & CKDOPER_CODE) == CKDOPER_READ))
; 4769 :             )
; 4770 :         {
; 4771 :             ckd_build_sense(dev, SENSE_CR, 0, 0,

  06d4f	c6 44 24 28 04	 mov	 BYTE PTR [rsp+40], 4
  06d54	c6 44 24 20 00	 mov	 BYTE PTR [rsp+32], 0
  06d59	45 33 c9	 xor	 r9d, r9d
  06d5c	45 33 c0	 xor	 r8d, r8d
  06d5f	b2 80		 mov	 dl, 128			; 00000080H
  06d61	48 8b 8c 24 c0
	03 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  06d69	e8 00 00 00 00	 call	 ckd_build_sense

; 4772 :                 FORMAT_0, MESSAGE_4);
; 4773 :             *unitstat = CSW_CE | CSW_DE | CSW_UC;

  06d6e	48 8b 84 24 08
	04 00 00	 mov	 rax, QWORD PTR unitstat$[rsp]
  06d76	c6 00 0e	 mov	 BYTE PTR [rax], 14

; 4774 :             break;

  06d79	e9 d2 37 00 00	 jmp	 $LN2@ckd_dasd_e
$LN425@ckd_dasd_e:

; 4775 :         }
; 4776 : 
; 4777 :         /* Check for write operation on a read only disk */
; 4778 :         if ((dev->ckdrdonly && !dev->ckdfakewr && !dev->dasdsfn)
; 4779 :             && ((dev->ckdloper & CKDOPER_CODE) == CKDOPER_WRITE

  06d7e	48 8b 84 24 c0
	03 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  06d86	8b 80 14 13 00
	00		 mov	 eax, DWORD PTR [rax+4884]
  06d8c	c1 e8 12	 shr	 eax, 18
  06d8f	83 e0 01	 and	 eax, 1
  06d92	85 c0		 test	 eax, eax
  06d94	0f 84 a2 00 00
	00		 je	 $LN431@ckd_dasd_e
  06d9a	48 8b 84 24 c0
	03 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  06da2	8b 80 14 13 00
	00		 mov	 eax, DWORD PTR [rax+4884]
  06da8	c1 e8 14	 shr	 eax, 20
  06dab	83 e0 01	 and	 eax, 1
  06dae	85 c0		 test	 eax, eax
  06db0	0f 85 86 00 00
	00		 jne	 $LN431@ckd_dasd_e
  06db6	48 8b 84 24 c0
	03 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  06dbe	48 83 b8 70 11
	00 00 00	 cmp	 QWORD PTR [rax+4464], 0
  06dc6	75 74		 jne	 SHORT $LN431@ckd_dasd_e
  06dc8	48 8b 84 24 c0
	03 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  06dd0	0f b6 80 00 13
	00 00		 movzx	 eax, BYTE PTR [rax+4864]
  06dd7	83 e0 3f	 and	 eax, 63			; 0000003fH
  06dda	83 f8 01	 cmp	 eax, 1
  06ddd	74 2e		 je	 SHORT $LN432@ckd_dasd_e
  06ddf	48 8b 84 24 c0
	03 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  06de7	0f b6 80 00 13
	00 00		 movzx	 eax, BYTE PTR [rax+4864]
  06dee	83 e0 3f	 and	 eax, 63			; 0000003fH
  06df1	83 f8 03	 cmp	 eax, 3
  06df4	74 17		 je	 SHORT $LN432@ckd_dasd_e
  06df6	48 8b 84 24 c0
	03 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  06dfe	0f b6 80 00 13
	00 00		 movzx	 eax, BYTE PTR [rax+4864]
  06e05	83 e0 3f	 and	 eax, 63			; 0000003fH
  06e08	83 f8 0b	 cmp	 eax, 11
  06e0b	75 2f		 jne	 SHORT $LN431@ckd_dasd_e
$LN432@ckd_dasd_e:

; 4780 :                 || (dev->ckdloper & CKDOPER_CODE) == CKDOPER_FORMAT
; 4781 :                 || (dev->ckdloper & CKDOPER_CODE) == CKDOPER_WRTTRK)
; 4782 :             )
; 4783 :         {
; 4784 :             ckd_build_sense(dev, SENSE_EC, SENSE1_WRI, 0,

  06e0d	c6 44 24 28 04	 mov	 BYTE PTR [rsp+40], 4
  06e12	c6 44 24 20 00	 mov	 BYTE PTR [rsp+32], 0
  06e17	45 33 c9	 xor	 r9d, r9d
  06e1a	41 b0 02	 mov	 r8b, 2
  06e1d	b2 10		 mov	 dl, 16
  06e1f	48 8b 8c 24 c0
	03 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  06e27	e8 00 00 00 00	 call	 ckd_build_sense

; 4785 :                 FORMAT_0, MESSAGE_4);
; 4786 :             *unitstat = CSW_CE | CSW_DE | CSW_UC;

  06e2c	48 8b 84 24 08
	04 00 00	 mov	 rax, QWORD PTR unitstat$[rsp]
  06e34	c6 00 0e	 mov	 BYTE PTR [rax], 14

; 4787 :             break;

  06e37	e9 14 37 00 00	 jmp	 $LN2@ckd_dasd_e
$LN431@ckd_dasd_e:

; 4788 :         }
; 4789 : 
; 4790 :         /* Byte 1 contains the locate record auxiliary byte */
; 4791 :         if (code == 0x47)

  06e3c	0f b6 84 24 c8
	03 00 00	 movzx	 eax, BYTE PTR code$[rsp]
  06e44	83 f8 47	 cmp	 eax, 71			; 00000047H
  06e47	75 25		 jne	 SHORT $LN433@ckd_dasd_e

; 4792 :             dev->ckdlaux = iobuf[1];

  06e49	b8 01 00 00 00	 mov	 eax, 1
  06e4e	48 6b c0 01	 imul	 rax, rax, 1
  06e52	48 8b 8c 24 c0
	03 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  06e5a	48 8b 94 24 f8
	03 00 00	 mov	 rdx, QWORD PTR iobuf$[rsp]
  06e62	0f b6 04 02	 movzx	 eax, BYTE PTR [rdx+rax]
  06e66	88 81 01 13 00
	00		 mov	 BYTE PTR [rcx+4865], al
  06e6c	eb 23		 jmp	 SHORT $LN434@ckd_dasd_e
$LN433@ckd_dasd_e:

; 4793 :         else
; 4794 :             dev->ckdlaux = iobuf[45];

  06e6e	b8 01 00 00 00	 mov	 eax, 1
  06e73	48 6b c0 2d	 imul	 rax, rax, 45		; 0000002dH
  06e77	48 8b 8c 24 c0
	03 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  06e7f	48 8b 94 24 f8
	03 00 00	 mov	 rdx, QWORD PTR iobuf$[rsp]
  06e87	0f b6 04 02	 movzx	 eax, BYTE PTR [rdx+rax]
  06e8b	88 81 01 13 00
	00		 mov	 BYTE PTR [rcx+4865], al
$LN434@ckd_dasd_e:

; 4795 : 
; 4796 :         /* Validate the auxiliary byte */
; 4797 :         if ((dev->ckdlaux & CKDLAUX_RESV) != 0
; 4798 :             || ((dev->ckdlaux & CKDLAUX_RDCNTSUF)

  06e91	48 8b 84 24 c0
	03 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  06e99	0f b6 80 01 13
	00 00		 movzx	 eax, BYTE PTR [rax+4865]
  06ea0	83 e0 7e	 and	 eax, 126		; 0000007eH
  06ea3	85 c0		 test	 eax, eax
  06ea5	75 44		 jne	 SHORT $LN436@ckd_dasd_e
  06ea7	48 8b 84 24 c0
	03 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  06eaf	0f b6 80 01 13
	00 00		 movzx	 eax, BYTE PTR [rax+4865]
  06eb6	83 e0 01	 and	 eax, 1
  06eb9	85 c0		 test	 eax, eax
  06ebb	74 5d		 je	 SHORT $LN435@ckd_dasd_e
  06ebd	48 8b 84 24 c0
	03 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  06ec5	0f b6 80 00 13
	00 00		 movzx	 eax, BYTE PTR [rax+4864]
  06ecc	83 e0 3f	 and	 eax, 63			; 0000003fH
  06ecf	83 f8 01	 cmp	 eax, 1
  06ed2	74 46		 je	 SHORT $LN435@ckd_dasd_e
  06ed4	48 8b 84 24 c0
	03 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  06edc	0f b6 80 00 13
	00 00		 movzx	 eax, BYTE PTR [rax+4864]
  06ee3	83 e0 3f	 and	 eax, 63			; 0000003fH
  06ee6	83 f8 16	 cmp	 eax, 22
  06ee9	74 2f		 je	 SHORT $LN435@ckd_dasd_e
$LN436@ckd_dasd_e:

; 4799 :                 && !((dev->ckdloper & CKDOPER_CODE) == CKDOPER_WRITE
; 4800 :                     || (dev->ckdloper & CKDOPER_CODE) == CKDOPER_READ))
; 4801 :             )
; 4802 :         {
; 4803 :             ckd_build_sense(dev, SENSE_CR, 0, 0,

  06eeb	c6 44 24 28 04	 mov	 BYTE PTR [rsp+40], 4
  06ef0	c6 44 24 20 00	 mov	 BYTE PTR [rsp+32], 0
  06ef5	45 33 c9	 xor	 r9d, r9d
  06ef8	45 33 c0	 xor	 r8d, r8d
  06efb	b2 80		 mov	 dl, 128			; 00000080H
  06efd	48 8b 8c 24 c0
	03 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  06f05	e8 00 00 00 00	 call	 ckd_build_sense

; 4804 :                 FORMAT_0, MESSAGE_4);
; 4805 :             *unitstat = CSW_CE | CSW_DE | CSW_UC;

  06f0a	48 8b 84 24 08
	04 00 00	 mov	 rax, QWORD PTR unitstat$[rsp]
  06f12	c6 00 0e	 mov	 BYTE PTR [rax], 14

; 4806 :             break;

  06f15	e9 36 36 00 00	 jmp	 $LN2@ckd_dasd_e
$LN435@ckd_dasd_e:

; 4807 :         }
; 4808 : 
; 4809 :         /* Byte 2 must contain zeroes */
; 4810 :         if (code == 0x47)

  06f1a	0f b6 84 24 c8
	03 00 00	 movzx	 eax, BYTE PTR code$[rsp]
  06f22	83 f8 47	 cmp	 eax, 71			; 00000047H
  06f25	75 70		 jne	 SHORT $LN437@ckd_dasd_e

; 4811 :         {
; 4812 :             if (iobuf[2] != 0)

  06f27	b8 01 00 00 00	 mov	 eax, 1
  06f2c	48 6b c0 02	 imul	 rax, rax, 2
  06f30	48 8b 8c 24 f8
	03 00 00	 mov	 rcx, QWORD PTR iobuf$[rsp]
  06f38	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  06f3c	85 c0		 test	 eax, eax
  06f3e	74 2f		 je	 SHORT $LN439@ckd_dasd_e

; 4813 :             {
; 4814 :                 ckd_build_sense(dev, SENSE_CR, 0, 0,

  06f40	c6 44 24 28 04	 mov	 BYTE PTR [rsp+40], 4
  06f45	c6 44 24 20 00	 mov	 BYTE PTR [rsp+32], 0
  06f4a	45 33 c9	 xor	 r9d, r9d
  06f4d	45 33 c0	 xor	 r8d, r8d
  06f50	b2 80		 mov	 dl, 128			; 00000080H
  06f52	48 8b 8c 24 c0
	03 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  06f5a	e8 00 00 00 00	 call	 ckd_build_sense

; 4815 :                     FORMAT_0, MESSAGE_4);
; 4816 :                 *unitstat = CSW_CE | CSW_DE | CSW_UC;

  06f5f	48 8b 84 24 08
	04 00 00	 mov	 rax, QWORD PTR unitstat$[rsp]
  06f67	c6 00 0e	 mov	 BYTE PTR [rax], 14

; 4817 :                 break;

  06f6a	e9 e1 35 00 00	 jmp	 $LN2@ckd_dasd_e
$LN439@ckd_dasd_e:

; 4818 :             }
; 4819 : 
; 4820 :             /* Byte 3 contains the locate record domain count */
; 4821 :             dev->ckdlcount = iobuf[3];

  06f6f	b8 01 00 00 00	 mov	 eax, 1
  06f74	48 6b c0 03	 imul	 rax, rax, 3
  06f78	48 8b 8c 24 c0
	03 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  06f80	48 8b 94 24 f8
	03 00 00	 mov	 rdx, QWORD PTR iobuf$[rsp]
  06f88	0f b6 04 02	 movzx	 eax, BYTE PTR [rdx+rax]
  06f8c	88 81 02 13 00
	00		 mov	 BYTE PTR [rcx+4866], al

; 4822 :         }

  06f92	e9 81 00 00 00	 jmp	 $LN438@ckd_dasd_e
$LN437@ckd_dasd_e:

; 4823 :         else
; 4824 :         {
; 4825 :             if (iobuf[46] != 0)

  06f97	b8 01 00 00 00	 mov	 eax, 1
  06f9c	48 6b c0 2e	 imul	 rax, rax, 46		; 0000002eH
  06fa0	48 8b 8c 24 f8
	03 00 00	 mov	 rcx, QWORD PTR iobuf$[rsp]
  06fa8	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  06fac	85 c0		 test	 eax, eax
  06fae	74 45		 je	 SHORT $LN440@ckd_dasd_e

; 4826 :             {
; 4827 :                 ckd_build_sense(dev, SENSE_CR, 0, 0,

  06fb0	c6 44 24 28 04	 mov	 BYTE PTR [rsp+40], 4
  06fb5	c6 44 24 20 00	 mov	 BYTE PTR [rsp+32], 0
  06fba	45 33 c9	 xor	 r9d, r9d
  06fbd	45 33 c0	 xor	 r8d, r8d
  06fc0	b2 80		 mov	 dl, 128			; 00000080H
  06fc2	48 8b 8c 24 c0
	03 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  06fca	e8 00 00 00 00	 call	 ckd_build_sense

; 4828 :                     FORMAT_0, MESSAGE_4);
; 4829 :                 *unitstat = CSW_CE | CSW_DE | CSW_UC;

  06fcf	48 8b 84 24 08
	04 00 00	 mov	 rax, QWORD PTR unitstat$[rsp]
  06fd7	c6 00 0e	 mov	 BYTE PTR [rax], 14

; 4830 :                 if (code == 0xe7)

  06fda	0f b6 84 24 c8
	03 00 00	 movzx	 eax, BYTE PTR code$[rsp]
  06fe2	3d e7 00 00 00	 cmp	 eax, 231		; 000000e7H
  06fe7	75 07		 jne	 SHORT $LN441@ckd_dasd_e

; 4831 :                     cyl = 0;

  06fe9	33 c0		 xor	 eax, eax
  06feb	66 89 44 24 6c	 mov	 WORD PTR cyl$[rsp], ax
$LN441@ckd_dasd_e:

; 4832 :                 break;

  06ff0	e9 5b 35 00 00	 jmp	 $LN2@ckd_dasd_e
$LN440@ckd_dasd_e:

; 4833 :             }
; 4834 :             /* Byte 3 contains the locate record domain count */
; 4835 :             dev->ckdlcount = iobuf[47];

  06ff5	b8 01 00 00 00	 mov	 eax, 1
  06ffa	48 6b c0 2f	 imul	 rax, rax, 47		; 0000002fH
  06ffe	48 8b 8c 24 c0
	03 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  07006	48 8b 94 24 f8
	03 00 00	 mov	 rdx, QWORD PTR iobuf$[rsp]
  0700e	0f b6 04 02	 movzx	 eax, BYTE PTR [rdx+rax]
  07012	88 81 02 13 00
	00		 mov	 BYTE PTR [rcx+4866], al
$LN438@ckd_dasd_e:

; 4836 :         }
; 4837 :         /* Validate the locate record domain count */
; 4838 :         if (((dev->ckdloper & CKDOPER_CODE) == CKDOPER_ORIENT
; 4839 :             && dev->ckdlcount != 0)
; 4840 :             || ((dev->ckdloper & CKDOPER_CODE) != CKDOPER_ORIENT
; 4841 :                 && dev->ckdlcount == 0)
; 4842 :             || ((dev->ckdlaux & CKDLAUX_RDCNTSUF)

  07018	48 8b 84 24 c0
	03 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  07020	0f b6 80 00 13
	00 00		 movzx	 eax, BYTE PTR [rax+4864]
  07027	83 e0 3f	 and	 eax, 63			; 0000003fH
  0702a	85 c0		 test	 eax, eax
  0702c	75 13		 jne	 SHORT $LN444@ckd_dasd_e
  0702e	48 8b 84 24 c0
	03 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  07036	0f b6 80 02 13
	00 00		 movzx	 eax, BYTE PTR [rax+4866]
  0703d	85 c0		 test	 eax, eax
  0703f	75 53		 jne	 SHORT $LN443@ckd_dasd_e
$LN444@ckd_dasd_e:
  07041	48 8b 84 24 c0
	03 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  07049	0f b6 80 00 13
	00 00		 movzx	 eax, BYTE PTR [rax+4864]
  07050	83 e0 3f	 and	 eax, 63			; 0000003fH
  07053	85 c0		 test	 eax, eax
  07055	74 13		 je	 SHORT $LN445@ckd_dasd_e
  07057	48 8b 84 24 c0
	03 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  0705f	0f b6 80 02 13
	00 00		 movzx	 eax, BYTE PTR [rax+4866]
  07066	85 c0		 test	 eax, eax
  07068	74 2a		 je	 SHORT $LN443@ckd_dasd_e
$LN445@ckd_dasd_e:
  0706a	48 8b 84 24 c0
	03 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  07072	0f b6 80 01 13
	00 00		 movzx	 eax, BYTE PTR [rax+4865]
  07079	83 e0 01	 and	 eax, 1
  0707c	85 c0		 test	 eax, eax
  0707e	74 43		 je	 SHORT $LN442@ckd_dasd_e
  07080	48 8b 84 24 c0
	03 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  07088	0f b6 80 02 13
	00 00		 movzx	 eax, BYTE PTR [rax+4866]
  0708f	83 f8 02	 cmp	 eax, 2
  07092	7d 2f		 jge	 SHORT $LN442@ckd_dasd_e
$LN443@ckd_dasd_e:

; 4843 :                 && dev->ckdlcount < 2)
; 4844 :             )
; 4845 :         {
; 4846 :             ckd_build_sense(dev, SENSE_CR, 0, 0,

  07094	c6 44 24 28 04	 mov	 BYTE PTR [rsp+40], 4
  07099	c6 44 24 20 00	 mov	 BYTE PTR [rsp+32], 0
  0709e	45 33 c9	 xor	 r9d, r9d
  070a1	45 33 c0	 xor	 r8d, r8d
  070a4	b2 80		 mov	 dl, 128			; 00000080H
  070a6	48 8b 8c 24 c0
	03 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  070ae	e8 00 00 00 00	 call	 ckd_build_sense

; 4847 :                 FORMAT_0, MESSAGE_4);
; 4848 :             *unitstat = CSW_CE | CSW_DE | CSW_UC;

  070b3	48 8b 84 24 08
	04 00 00	 mov	 rax, QWORD PTR unitstat$[rsp]
  070bb	c6 00 0e	 mov	 BYTE PTR [rax], 14

; 4849 :             break;

  070be	e9 8d 34 00 00	 jmp	 $LN2@ckd_dasd_e
$LN442@ckd_dasd_e:

; 4850 :         }
; 4851 : 
; 4852 :         /* Bytes 4-7 contain the seek address */
; 4853 :         if (code == 0x47)

  070c3	0f b6 84 24 c8
	03 00 00	 movzx	 eax, BYTE PTR code$[rsp]
  070cb	83 f8 47	 cmp	 eax, 71			; 00000047H
  070ce	75 6a		 jne	 SHORT $LN446@ckd_dasd_e

; 4854 :         {
; 4855 :             cyl = (iobuf[4] << 8) | iobuf[5];

  070d0	b8 01 00 00 00	 mov	 eax, 1
  070d5	48 6b c0 04	 imul	 rax, rax, 4
  070d9	48 8b 8c 24 f8
	03 00 00	 mov	 rcx, QWORD PTR iobuf$[rsp]
  070e1	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  070e5	c1 e0 08	 shl	 eax, 8
  070e8	b9 01 00 00 00	 mov	 ecx, 1
  070ed	48 6b c9 05	 imul	 rcx, rcx, 5
  070f1	48 8b 94 24 f8
	03 00 00	 mov	 rdx, QWORD PTR iobuf$[rsp]
  070f9	0f b6 0c 0a	 movzx	 ecx, BYTE PTR [rdx+rcx]
  070fd	0b c1		 or	 eax, ecx
  070ff	66 89 44 24 6c	 mov	 WORD PTR cyl$[rsp], ax

; 4856 :             head = (iobuf[6] << 8) | iobuf[7];

  07104	b8 01 00 00 00	 mov	 eax, 1
  07109	48 6b c0 06	 imul	 rax, rax, 6
  0710d	48 8b 8c 24 f8
	03 00 00	 mov	 rcx, QWORD PTR iobuf$[rsp]
  07115	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  07119	c1 e0 08	 shl	 eax, 8
  0711c	b9 01 00 00 00	 mov	 ecx, 1
  07121	48 6b c9 07	 imul	 rcx, rcx, 7
  07125	48 8b 94 24 f8
	03 00 00	 mov	 rdx, QWORD PTR iobuf$[rsp]
  0712d	0f b6 0c 0a	 movzx	 ecx, BYTE PTR [rdx+rcx]
  07131	0b c1		 or	 eax, ecx
  07133	66 89 44 24 70	 mov	 WORD PTR head$[rsp], ax

; 4857 :         }

  07138	eb 68		 jmp	 SHORT $LN447@ckd_dasd_e
$LN446@ckd_dasd_e:

; 4858 :         else
; 4859 :         {
; 4860 :             cyl = (iobuf[20] << 8) | iobuf[21];

  0713a	b8 01 00 00 00	 mov	 eax, 1
  0713f	48 6b c0 14	 imul	 rax, rax, 20
  07143	48 8b 8c 24 f8
	03 00 00	 mov	 rcx, QWORD PTR iobuf$[rsp]
  0714b	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  0714f	c1 e0 08	 shl	 eax, 8
  07152	b9 01 00 00 00	 mov	 ecx, 1
  07157	48 6b c9 15	 imul	 rcx, rcx, 21
  0715b	48 8b 94 24 f8
	03 00 00	 mov	 rdx, QWORD PTR iobuf$[rsp]
  07163	0f b6 0c 0a	 movzx	 ecx, BYTE PTR [rdx+rcx]
  07167	0b c1		 or	 eax, ecx
  07169	66 89 44 24 6c	 mov	 WORD PTR cyl$[rsp], ax

; 4861 :             head = (iobuf[22] << 8) | iobuf[23];

  0716e	b8 01 00 00 00	 mov	 eax, 1
  07173	48 6b c0 16	 imul	 rax, rax, 22
  07177	48 8b 8c 24 f8
	03 00 00	 mov	 rcx, QWORD PTR iobuf$[rsp]
  0717f	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  07183	c1 e0 08	 shl	 eax, 8
  07186	b9 01 00 00 00	 mov	 ecx, 1
  0718b	48 6b c9 17	 imul	 rcx, rcx, 23
  0718f	48 8b 94 24 f8
	03 00 00	 mov	 rdx, QWORD PTR iobuf$[rsp]
  07197	0f b6 0c 0a	 movzx	 ecx, BYTE PTR [rdx+rcx]
  0719b	0b c1		 or	 eax, ecx
  0719d	66 89 44 24 70	 mov	 WORD PTR head$[rsp], ax
$LN447@ckd_dasd_e:

; 4862 :         }
; 4863 : 
; 4864 :         /* Command reject if seek address is not valid */
; 4865 :         if (cyl >= dev->ckdcyls || head >= dev->ckdheads)

  071a2	0f b7 44 24 6c	 movzx	 eax, WORD PTR cyl$[rsp]
  071a7	48 8b 8c 24 c0
	03 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  071af	3b 81 b8 12 00
	00		 cmp	 eax, DWORD PTR [rcx+4792]
  071b5	7d 15		 jge	 SHORT $LN449@ckd_dasd_e
  071b7	0f b7 44 24 70	 movzx	 eax, WORD PTR head$[rsp]
  071bc	48 8b 8c 24 c0
	03 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  071c4	3b 81 c0 12 00
	00		 cmp	 eax, DWORD PTR [rcx+4800]
  071ca	7c 2f		 jl	 SHORT $LN448@ckd_dasd_e
$LN449@ckd_dasd_e:

; 4866 :         {
; 4867 :             ckd_build_sense(dev, SENSE_CR, 0, 0,

  071cc	c6 44 24 28 04	 mov	 BYTE PTR [rsp+40], 4
  071d1	c6 44 24 20 00	 mov	 BYTE PTR [rsp+32], 0
  071d6	45 33 c9	 xor	 r9d, r9d
  071d9	45 33 c0	 xor	 r8d, r8d
  071dc	b2 80		 mov	 dl, 128			; 00000080H
  071de	48 8b 8c 24 c0
	03 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  071e6	e8 00 00 00 00	 call	 ckd_build_sense

; 4868 :                 FORMAT_0, MESSAGE_4);
; 4869 :             *unitstat = CSW_CE | CSW_DE | CSW_UC;

  071eb	48 8b 84 24 08
	04 00 00	 mov	 rax, QWORD PTR unitstat$[rsp]
  071f3	c6 00 0e	 mov	 BYTE PTR [rax], 14

; 4870 :             break;

  071f6	e9 55 33 00 00	 jmp	 $LN2@ckd_dasd_e
$LN448@ckd_dasd_e:

; 4871 :         }
; 4872 : 
; 4873 :         /* File protect error if seek address is outside extent */
; 4874 :         if (EXTENT_CHECK(dev, cyl, head))

  071fb	0f b7 44 24 6c	 movzx	 eax, WORD PTR cyl$[rsp]
  07200	48 8b 8c 24 c0
	03 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  07208	0f b7 89 f2 12
	00 00		 movzx	 ecx, WORD PTR [rcx+4850]
  0720f	3b c1		 cmp	 eax, ecx
  07211	7c 78		 jl	 SHORT $LN451@ckd_dasd_e
  07213	0f b7 44 24 6c	 movzx	 eax, WORD PTR cyl$[rsp]
  07218	48 8b 8c 24 c0
	03 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  07220	0f b7 89 f6 12
	00 00		 movzx	 ecx, WORD PTR [rcx+4854]
  07227	3b c1		 cmp	 eax, ecx
  07229	7f 60		 jg	 SHORT $LN451@ckd_dasd_e
  0722b	0f b7 44 24 6c	 movzx	 eax, WORD PTR cyl$[rsp]
  07230	48 8b 8c 24 c0
	03 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  07238	0f b7 89 f2 12
	00 00		 movzx	 ecx, WORD PTR [rcx+4850]
  0723f	3b c1		 cmp	 eax, ecx
  07241	75 18		 jne	 SHORT $LN452@ckd_dasd_e
  07243	0f b7 44 24 70	 movzx	 eax, WORD PTR head$[rsp]
  07248	48 8b 8c 24 c0
	03 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  07250	0f b7 89 f4 12
	00 00		 movzx	 ecx, WORD PTR [rcx+4852]
  07257	3b c1		 cmp	 eax, ecx
  07259	7c 30		 jl	 SHORT $LN451@ckd_dasd_e
$LN452@ckd_dasd_e:
  0725b	0f b7 44 24 6c	 movzx	 eax, WORD PTR cyl$[rsp]
  07260	48 8b 8c 24 c0
	03 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  07268	0f b7 89 f6 12
	00 00		 movzx	 ecx, WORD PTR [rcx+4854]
  0726f	3b c1		 cmp	 eax, ecx
  07271	75 47		 jne	 SHORT $LN450@ckd_dasd_e
  07273	0f b7 44 24 70	 movzx	 eax, WORD PTR head$[rsp]
  07278	48 8b 8c 24 c0
	03 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  07280	0f b7 89 f8 12
	00 00		 movzx	 ecx, WORD PTR [rcx+4856]
  07287	3b c1		 cmp	 eax, ecx
  07289	7e 2f		 jle	 SHORT $LN450@ckd_dasd_e
$LN451@ckd_dasd_e:

; 4875 :         {
; 4876 :             ckd_build_sense(dev, 0, SENSE1_FP, 0, 0, 0);

  0728b	c6 44 24 28 00	 mov	 BYTE PTR [rsp+40], 0
  07290	c6 44 24 20 00	 mov	 BYTE PTR [rsp+32], 0
  07295	45 33 c9	 xor	 r9d, r9d
  07298	41 b0 04	 mov	 r8b, 4
  0729b	33 d2		 xor	 edx, edx
  0729d	48 8b 8c 24 c0
	03 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  072a5	e8 00 00 00 00	 call	 ckd_build_sense

; 4877 :             *unitstat = CSW_CE | CSW_DE | CSW_UC;

  072aa	48 8b 84 24 08
	04 00 00	 mov	 rax, QWORD PTR unitstat$[rsp]
  072b2	c6 00 0e	 mov	 BYTE PTR [rax], 14

; 4878 :             break;

  072b5	e9 96 32 00 00	 jmp	 $LN2@ckd_dasd_e
$LN450@ckd_dasd_e:

; 4879 :         }
; 4880 : 
; 4881 :         /* Bytes 8-12 contain the search argument */
; 4882 :         if (code == 0x47)

  072ba	0f b6 84 24 c8
	03 00 00	 movzx	 eax, BYTE PTR code$[rsp]
  072c2	83 f8 47	 cmp	 eax, 71			; 00000047H
  072c5	75 20		 jne	 SHORT $LN453@ckd_dasd_e

; 4883 :             memcpy(cchhr, iobuf + 8, 5);

  072c7	48 8d 84 24 48
	02 00 00	 lea	 rax, QWORD PTR cchhr$[rsp]
  072cf	48 8b 8c 24 f8
	03 00 00	 mov	 rcx, QWORD PTR iobuf$[rsp]
  072d7	48 8b f8	 mov	 rdi, rax
  072da	48 8d 71 08	 lea	 rsi, QWORD PTR [rcx+8]
  072de	b9 05 00 00 00	 mov	 ecx, 5
  072e3	f3 a4		 rep movsb
  072e5	eb 1e		 jmp	 SHORT $LN454@ckd_dasd_e
$LN453@ckd_dasd_e:

; 4884 :         else
; 4885 :             memcpy(cchhr, iobuf + 52, 5);

  072e7	48 8d 84 24 48
	02 00 00	 lea	 rax, QWORD PTR cchhr$[rsp]
  072ef	48 8b 8c 24 f8
	03 00 00	 mov	 rcx, QWORD PTR iobuf$[rsp]
  072f7	48 8b f8	 mov	 rdi, rax
  072fa	48 8d 71 34	 lea	 rsi, QWORD PTR [rcx+52]
  072fe	b9 05 00 00 00	 mov	 ecx, 5
  07303	f3 a4		 rep movsb
$LN454@ckd_dasd_e:

; 4886 : 
; 4887 :         /* Byte 13 contains the sector number */
; 4888 :         sector = iobuf[13];

  07305	b8 01 00 00 00	 mov	 eax, 1
  0730a	48 6b c0 0d	 imul	 rax, rax, 13
  0730e	48 8b 8c 24 f8
	03 00 00	 mov	 rcx, QWORD PTR iobuf$[rsp]
  07316	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  0731a	88 44 24 7c	 mov	 BYTE PTR sector$[rsp], al

; 4889 : 
; 4890 :         /* Command reject if sector number is not valid */
; 4891 :         if (sector != 0xFF && sector >= dev->ckdtab->sectors)

  0731e	0f b6 44 24 7c	 movzx	 eax, BYTE PTR sector$[rsp]
  07323	3d ff 00 00 00	 cmp	 eax, 255		; 000000ffH
  07328	74 4b		 je	 SHORT $LN455@ckd_dasd_e
  0732a	0f b6 44 24 7c	 movzx	 eax, BYTE PTR sector$[rsp]
  0732f	48 8b 8c 24 c0
	03 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  07337	48 8b 89 a0 12
	00 00		 mov	 rcx, QWORD PTR [rcx+4768]
  0733e	0f b7 49 1c	 movzx	 ecx, WORD PTR [rcx+28]
  07342	3b c1		 cmp	 eax, ecx
  07344	7c 2f		 jl	 SHORT $LN455@ckd_dasd_e

; 4892 :         {
; 4893 :             ckd_build_sense(dev, SENSE_CR, 0, 0,

  07346	c6 44 24 28 04	 mov	 BYTE PTR [rsp+40], 4
  0734b	c6 44 24 20 00	 mov	 BYTE PTR [rsp+32], 0
  07350	45 33 c9	 xor	 r9d, r9d
  07353	45 33 c0	 xor	 r8d, r8d
  07356	b2 80		 mov	 dl, 128			; 00000080H
  07358	48 8b 8c 24 c0
	03 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  07360	e8 00 00 00 00	 call	 ckd_build_sense

; 4894 :                 FORMAT_0, MESSAGE_4);
; 4895 :             *unitstat = CSW_CE | CSW_DE | CSW_UC;

  07365	48 8b 84 24 08
	04 00 00	 mov	 rax, QWORD PTR unitstat$[rsp]
  0736d	c6 00 0e	 mov	 BYTE PTR [rax], 14

; 4896 :             break;

  07370	e9 db 31 00 00	 jmp	 $LN2@ckd_dasd_e
$LN455@ckd_dasd_e:

; 4897 :         }
; 4898 :         if (code == 0x47)

  07375	0f b6 84 24 c8
	03 00 00	 movzx	 eax, BYTE PTR code$[rsp]
  0737d	83 f8 47	 cmp	 eax, 71			; 00000047H
  07380	75 40		 jne	 SHORT $LN456@ckd_dasd_e

; 4899 :             /* Bytes 14-15 contain the transfer length factor */
; 4900 :             dev->ckdltranlf = (iobuf[14] << 8) | iobuf[15];

  07382	b8 01 00 00 00	 mov	 eax, 1
  07387	48 6b c0 0e	 imul	 rax, rax, 14
  0738b	48 8b 8c 24 f8
	03 00 00	 mov	 rcx, QWORD PTR iobuf$[rsp]
  07393	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  07397	c1 e0 08	 shl	 eax, 8
  0739a	b9 01 00 00 00	 mov	 ecx, 1
  0739f	48 6b c9 0f	 imul	 rcx, rcx, 15
  073a3	48 8b 94 24 f8
	03 00 00	 mov	 rdx, QWORD PTR iobuf$[rsp]
  073ab	0f b6 0c 0a	 movzx	 ecx, BYTE PTR [rdx+rcx]
  073af	0b c1		 or	 eax, ecx
  073b1	48 8b 8c 24 c0
	03 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  073b9	66 89 81 fc 12
	00 00		 mov	 WORD PTR [rcx+4860], ax
  073c0	eb 11		 jmp	 SHORT $LN457@ckd_dasd_e
$LN456@ckd_dasd_e:

; 4901 :         else
; 4902 :             dev->ckdltranlf = 0;

  073c2	33 c0		 xor	 eax, eax
  073c4	48 8b 8c 24 c0
	03 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  073cc	66 89 81 fc 12
	00 00		 mov	 WORD PTR [rcx+4860], ax
$LN457@ckd_dasd_e:

; 4903 :         /* Validate the transfer length factor */
; 4904 :         if (((dev->ckdlaux & CKDLAUX_TLFVALID) == 0
; 4905 :             && dev->ckdltranlf != 0)
; 4906 :             || ((dev->ckdlaux & CKDLAUX_TLFVALID)
; 4907 :                 && dev->ckdltranlf == 0)
; 4908 :             || dev->ckdltranlf > dev->ckdxblksz)

  073d3	48 8b 84 24 c0
	03 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  073db	0f b6 80 01 13
	00 00		 movzx	 eax, BYTE PTR [rax+4865]
  073e2	25 80 00 00 00	 and	 eax, 128		; 00000080H
  073e7	85 c0		 test	 eax, eax
  073e9	75 13		 jne	 SHORT $LN460@ckd_dasd_e
  073eb	48 8b 84 24 c0
	03 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  073f3	0f b7 80 fc 12
	00 00		 movzx	 eax, WORD PTR [rax+4860]
  073fa	85 c0		 test	 eax, eax
  073fc	75 4d		 jne	 SHORT $LN459@ckd_dasd_e
$LN460@ckd_dasd_e:
  073fe	48 8b 84 24 c0
	03 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  07406	0f b6 80 01 13
	00 00		 movzx	 eax, BYTE PTR [rax+4865]
  0740d	25 80 00 00 00	 and	 eax, 128		; 00000080H
  07412	85 c0		 test	 eax, eax
  07414	74 13		 je	 SHORT $LN461@ckd_dasd_e
  07416	48 8b 84 24 c0
	03 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  0741e	0f b7 80 fc 12
	00 00		 movzx	 eax, WORD PTR [rax+4860]
  07425	85 c0		 test	 eax, eax
  07427	74 22		 je	 SHORT $LN459@ckd_dasd_e
$LN461@ckd_dasd_e:
  07429	48 8b 84 24 c0
	03 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  07431	0f b7 80 fc 12
	00 00		 movzx	 eax, WORD PTR [rax+4860]
  07438	48 8b 8c 24 c0
	03 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  07440	0f b7 89 f0 12
	00 00		 movzx	 ecx, WORD PTR [rcx+4848]
  07447	3b c1		 cmp	 eax, ecx
  07449	7e 2f		 jle	 SHORT $LN458@ckd_dasd_e
$LN459@ckd_dasd_e:

; 4909 :         {
; 4910 :             ckd_build_sense(dev, SENSE_CR, 0, 0,

  0744b	c6 44 24 28 04	 mov	 BYTE PTR [rsp+40], 4
  07450	c6 44 24 20 00	 mov	 BYTE PTR [rsp+32], 0
  07455	45 33 c9	 xor	 r9d, r9d
  07458	45 33 c0	 xor	 r8d, r8d
  0745b	b2 80		 mov	 dl, 128			; 00000080H
  0745d	48 8b 8c 24 c0
	03 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  07465	e8 00 00 00 00	 call	 ckd_build_sense

; 4911 :                 FORMAT_0, MESSAGE_4);
; 4912 :             *unitstat = CSW_CE | CSW_DE | CSW_UC;

  0746a	48 8b 84 24 08
	04 00 00	 mov	 rax, QWORD PTR unitstat$[rsp]
  07472	c6 00 0e	 mov	 BYTE PTR [rax], 14

; 4913 :             break;

  07475	e9 d6 30 00 00	 jmp	 $LN2@ckd_dasd_e
$LN458@ckd_dasd_e:

; 4914 :         }
; 4915 : 
; 4916 :         /* If transfer length factor is not supplied then use
; 4917 :            the blocksize from the define extent command */
; 4918 :         if ((dev->ckdlaux & CKDLAUX_TLFVALID) == 0)

  0747a	48 8b 84 24 c0
	03 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  07482	0f b6 80 01 13
	00 00		 movzx	 eax, BYTE PTR [rax+4865]
  07489	25 80 00 00 00	 and	 eax, 128		; 00000080H
  0748e	85 c0		 test	 eax, eax
  07490	75 1e		 jne	 SHORT $LN462@ckd_dasd_e

; 4919 :             dev->ckdltranlf = dev->ckdxblksz;

  07492	48 8b 84 24 c0
	03 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  0749a	48 8b 8c 24 c0
	03 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  074a2	0f b7 89 f0 12
	00 00		 movzx	 ecx, WORD PTR [rcx+4848]
  074a9	66 89 88 fc 12
	00 00		 mov	 WORD PTR [rax+4860], cx
$LN462@ckd_dasd_e:

; 4920 : 
; 4921 :         /* Seek to the required track */
; 4922 :         rc = ckd_seek(dev, cyl, head, &trkhdr, unitstat);

  074b0	0f b7 44 24 70	 movzx	 eax, WORD PTR head$[rsp]
  074b5	0f b7 4c 24 6c	 movzx	 ecx, WORD PTR cyl$[rsp]
  074ba	48 8b 94 24 08
	04 00 00	 mov	 rdx, QWORD PTR unitstat$[rsp]
  074c2	48 89 54 24 20	 mov	 QWORD PTR [rsp+32], rdx
  074c7	4c 8d 8c 24 40
	02 00 00	 lea	 r9, QWORD PTR trkhdr$[rsp]
  074cf	44 8b c0	 mov	 r8d, eax
  074d2	8b d1		 mov	 edx, ecx
  074d4	48 8b 8c 24 c0
	03 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  074dc	e8 00 00 00 00	 call	 ckd_seek
  074e1	89 44 24 60	 mov	 DWORD PTR rc$[rsp], eax

; 4923 :         if (rc < 0)

  074e5	83 7c 24 60 00	 cmp	 DWORD PTR rc$[rsp], 0
  074ea	7d 05		 jge	 SHORT $LN463@ckd_dasd_e

; 4924 :             break;

  074ec	e9 5f 30 00 00	 jmp	 $LN2@ckd_dasd_e
$LN463@ckd_dasd_e:

; 4925 : 
; 4926 :         /* Set normal status */
; 4927 :         *unitstat = CSW_CE | CSW_DE;

  074f1	48 8b 84 24 08
	04 00 00	 mov	 rax, QWORD PTR unitstat$[rsp]
  074f9	c6 00 0c	 mov	 BYTE PTR [rax], 12

; 4928 : 
; 4929 :         /* Perform search according to specified orientation */
; 4930 :         switch ((dev->ckdloper & CKDOPER_ORIENTATION)) {

  074fc	48 8b 84 24 c0
	03 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  07504	0f b6 80 00 13
	00 00		 movzx	 eax, BYTE PTR [rax+4864]
  0750b	25 c0 00 00 00	 and	 eax, 192		; 000000c0H
  07510	89 84 24 b8 00
	00 00		 mov	 DWORD PTR tv3712[rsp], eax
  07517	83 bc 24 b8 00
	00 00 00	 cmp	 DWORD PTR tv3712[rsp], 0
  0751f	74 6a		 je	 SHORT $LN466@ckd_dasd_e
  07521	83 bc 24 b8 00
	00 00 40	 cmp	 DWORD PTR tv3712[rsp], 64 ; 00000040H
  07529	74 12		 je	 SHORT $LN464@ckd_dasd_e
  0752b	81 bc 24 b8 00
	00 00 80 00 00
	00		 cmp	 DWORD PTR tv3712[rsp], 128 ; 00000080H
  07536	74 53		 je	 SHORT $LN467@ckd_dasd_e
  07538	e9 e9 00 00 00	 jmp	 $LN36@ckd_dasd_e
$LN464@ckd_dasd_e:

; 4931 : 
; 4932 :         case CKDOPER_ORIENT_HOME:
; 4933 :             /* For home orientation, compare the search CCHH
; 4934 :                with the CCHH in the track header */
; 4935 :             if (memcmp(&(trkhdr.cyl), cchhr, 4) != 0)

  0753d	41 b8 04 00 00
	00		 mov	 r8d, 4
  07543	48 8d 94 24 48
	02 00 00	 lea	 rdx, QWORD PTR cchhr$[rsp]
  0754b	48 8d 8c 24 41
	02 00 00	 lea	 rcx, QWORD PTR trkhdr$[rsp+1]
  07553	e8 00 00 00 00	 call	 memcmp
  07558	85 c0		 test	 eax, eax
  0755a	74 2a		 je	 SHORT $LN465@ckd_dasd_e

; 4936 :             {
; 4937 :                 ckd_build_sense(dev, 0, SENSE1_NRF, 0, 0, 0);

  0755c	c6 44 24 28 00	 mov	 BYTE PTR [rsp+40], 0
  07561	c6 44 24 20 00	 mov	 BYTE PTR [rsp+32], 0
  07566	45 33 c9	 xor	 r9d, r9d
  07569	41 b0 08	 mov	 r8b, 8
  0756c	33 d2		 xor	 edx, edx
  0756e	48 8b 8c 24 c0
	03 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  07576	e8 00 00 00 00	 call	 ckd_build_sense

; 4938 :                 *unitstat = CSW_CE | CSW_DE | CSW_UC;

  0757b	48 8b 84 24 08
	04 00 00	 mov	 rax, QWORD PTR unitstat$[rsp]
  07583	c6 00 0e	 mov	 BYTE PTR [rax], 14
$LN465@ckd_dasd_e:

; 4939 :             }
; 4940 :             break;

  07586	e9 9b 00 00 00	 jmp	 $LN36@ckd_dasd_e
$LN466@ckd_dasd_e:
$LN467@ckd_dasd_e:
$LN38@ckd_dasd_e:

; 4941 : 
; 4942 :         case CKDOPER_ORIENT_COUNT:
; 4943 :         case CKDOPER_ORIENT_DATA:
; 4944 :             /* For count or data orientation, search the track
; 4945 :                for a count field matching the specified CCHHR */
; 4946 :             while (1)

  0758b	33 c0		 xor	 eax, eax
  0758d	83 f8 01	 cmp	 eax, 1
  07590	0f 84 90 00 00
	00		 je	 $LN39@ckd_dasd_e

; 4947 :             {
; 4948 :                 /* Read next count field and exit at end of track
; 4949 :                    with sense data indicating no record found */
; 4950 :                 rc = ckd_read_count(dev, code, &rechdr, unitstat);

  07596	4c 8b 8c 24 08
	04 00 00	 mov	 r9, QWORD PTR unitstat$[rsp]
  0759e	4c 8d 84 24 38
	02 00 00	 lea	 r8, QWORD PTR rechdr$[rsp]
  075a6	0f b6 94 24 c8
	03 00 00	 movzx	 edx, BYTE PTR code$[rsp]
  075ae	48 8b 8c 24 c0
	03 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  075b6	e8 00 00 00 00	 call	 ckd_read_count
  075bb	89 44 24 60	 mov	 DWORD PTR rc$[rsp], eax

; 4951 :                 if (rc < 0) break;

  075bf	83 7c 24 60 00	 cmp	 DWORD PTR rc$[rsp], 0
  075c4	7d 02		 jge	 SHORT $LN468@ckd_dasd_e
  075c6	eb 5e		 jmp	 SHORT $LN39@ckd_dasd_e
$LN468@ckd_dasd_e:

; 4952 : 
; 4953 :                 /* Turn off track overflow flag */
; 4954 :                 if (dev->ckdcyls < 32768)

  075c8	48 8b 84 24 c0
	03 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  075d0	81 b8 b8 12 00
	00 00 80 00 00	 cmp	 DWORD PTR [rax+4792], 32768 ; 00008000H
  075da	7d 24		 jge	 SHORT $LN469@ckd_dasd_e

; 4955 :                     rechdr.cyl[0] &= 0x7F;

  075dc	b8 01 00 00 00	 mov	 eax, 1
  075e1	48 6b c0 00	 imul	 rax, rax, 0
  075e5	0f b6 84 04 38
	02 00 00	 movzx	 eax, BYTE PTR rechdr$[rsp+rax]
  075ed	83 e0 7f	 and	 eax, 127		; 0000007fH
  075f0	b9 01 00 00 00	 mov	 ecx, 1
  075f5	48 6b c9 00	 imul	 rcx, rcx, 0
  075f9	88 84 0c 38 02
	00 00		 mov	 BYTE PTR rechdr$[rsp+rcx], al
$LN469@ckd_dasd_e:

; 4956 : 
; 4957 :                 /* Compare the count field with the search CCHHR */
; 4958 :                 if (memcmp(&rechdr, cchhr, 5) == 0)

  07600	41 b8 05 00 00
	00		 mov	 r8d, 5
  07606	48 8d 94 24 48
	02 00 00	 lea	 rdx, QWORD PTR cchhr$[rsp]
  0760e	48 8d 8c 24 38
	02 00 00	 lea	 rcx, QWORD PTR rechdr$[rsp]
  07616	e8 00 00 00 00	 call	 memcmp
  0761b	85 c0		 test	 eax, eax
  0761d	75 02		 jne	 SHORT $LN470@ckd_dasd_e

; 4959 :                     break;

  0761f	eb 05		 jmp	 SHORT $LN39@ckd_dasd_e
$LN470@ckd_dasd_e:

; 4960 : 
; 4961 :             } /* end while */

  07621	e9 65 ff ff ff	 jmp	 $LN38@ckd_dasd_e
$LN39@ckd_dasd_e:
$LN36@ckd_dasd_e:

; 4962 : 
; 4963 :         } /* end switch(CKDOPER_ORIENTATION) */
; 4964 : 
; 4965 :         /* Exit if search ended with error status */
; 4966 :         if (*unitstat != (CSW_CE | CSW_DE))

  07626	48 8b 84 24 08
	04 00 00	 mov	 rax, QWORD PTR unitstat$[rsp]
  0762e	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  07631	83 f8 0c	 cmp	 eax, 12
  07634	74 05		 je	 SHORT $LN471@ckd_dasd_e

; 4967 :             break;

  07636	e9 15 2f 00 00	 jmp	 $LN2@ckd_dasd_e
$LN471@ckd_dasd_e:

; 4968 : 
; 4969 :         /* Reorient past data if data orientation is specified */
; 4970 :         if ((dev->ckdloper & CKDOPER_ORIENTATION)
; 4971 :             == CKDOPER_ORIENT_DATA)

  0763b	48 8b 84 24 c0
	03 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  07643	0f b6 80 00 13
	00 00		 movzx	 eax, BYTE PTR [rax+4864]
  0764a	25 c0 00 00 00	 and	 eax, 192		; 000000c0H
  0764f	3d 80 00 00 00	 cmp	 eax, 128		; 00000080H
  07654	75 60		 jne	 SHORT $LN472@ckd_dasd_e

; 4972 :         {
; 4973 :             /* Skip past key and data fields */
; 4974 :             dev->bufoff += dev->ckdcurkl + dev->ckdcurdl;

  07656	48 8b 84 24 c0
	03 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  0765e	0f b7 80 ea 12
	00 00		 movzx	 eax, WORD PTR [rax+4842]
  07665	48 8b 8c 24 c0
	03 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  0766d	8b 89 d4 12 00
	00		 mov	 ecx, DWORD PTR [rcx+4820]
  07673	03 c8		 add	 ecx, eax
  07675	8b c1		 mov	 eax, ecx
  07677	48 8b 8c 24 c0
	03 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  0767f	03 81 e0 01 00
	00		 add	 eax, DWORD PTR [rcx+480]
  07685	48 8b 8c 24 c0
	03 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  0768d	89 81 e0 01 00
	00		 mov	 DWORD PTR [rcx+480], eax

; 4975 : 
; 4976 :             /* Set the device orientation fields */
; 4977 :             dev->ckdrem = 0;

  07693	33 c0		 xor	 eax, eax
  07695	48 8b 8c 24 c0
	03 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  0769d	66 89 81 ec 12
	00 00		 mov	 WORD PTR [rcx+4844], ax

; 4978 :             dev->ckdorient = CKDORIENT_DATA;

  076a4	48 8b 84 24 c0
	03 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  076ac	c7 80 d8 12 00
	00 04 00 00 00	 mov	 DWORD PTR [rax+4824], 4
$LN472@ckd_dasd_e:

; 4979 :         }
; 4980 : 
; 4981 :         /* Set locate record flag and return normal status */
; 4982 :         dev->ckdlocat = 1;

  076b6	48 8b 84 24 c0
	03 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  076be	8b 80 14 13 00
	00		 mov	 eax, DWORD PTR [rax+4884]
  076c4	83 c8 08	 or	 eax, 8
  076c7	48 8b 8c 24 c0
	03 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  076cf	89 81 14 13 00
	00		 mov	 DWORD PTR [rcx+4884], eax

; 4983 :         break;

  076d5	e9 76 2e 00 00	 jmp	 $LN2@ckd_dasd_e
$LN473@ckd_dasd_e:

; 4984 :     }
; 4985 :     case 0x4B:
; 4986 :     /*---------------------------------------------------------------*/
; 4987 :     /* LOCATE RECORD EXTENDED                                        */
; 4988 :     /*---------------------------------------------------------------*/
; 4989 : 
; 4990 :     /* LRE only valid for 3990-3 or 3990-6 (or greater) */
; 4991 :     if (dev->ckdcu->devt != 0x3990 ||

  076da	48 8b 84 24 c0
	03 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  076e2	48 8b 80 a8 12
	00 00		 mov	 rax, QWORD PTR [rax+4776]
  076e9	0f b7 40 08	 movzx	 eax, WORD PTR [rax+8]
  076ed	3d 90 39 00 00	 cmp	 eax, 14736		; 00003990H
  076f2	75 68		 jne	 SHORT $LN475@ckd_dasd_e
  076f4	48 8b 84 24 c0
	03 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  076fc	48 8b 80 a8 12
	00 00		 mov	 rax, QWORD PTR [rax+4776]
  07703	0f b7 40 08	 movzx	 eax, WORD PTR [rax+8]
  07707	3d 90 39 00 00	 cmp	 eax, 14736		; 00003990H
  0770c	75 1a		 jne	 SHORT $LN476@ckd_dasd_e
  0770e	48 8b 84 24 c0
	03 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  07716	48 8b 80 a8 12
	00 00		 mov	 rax, QWORD PTR [rax+4776]
  0771d	0f b6 40 0a	 movzx	 eax, BYTE PTR [rax+10]
  07721	3d ec 00 00 00	 cmp	 eax, 236		; 000000ecH
  07726	74 63		 je	 SHORT $LN474@ckd_dasd_e
$LN476@ckd_dasd_e:
  07728	48 8b 84 24 c0
	03 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  07730	48 8b 80 a8 12
	00 00		 mov	 rax, QWORD PTR [rax+4776]
  07737	0f b7 40 08	 movzx	 eax, WORD PTR [rax+8]
  0773b	3d 90 39 00 00	 cmp	 eax, 14736		; 00003990H
  07740	75 1a		 jne	 SHORT $LN477@ckd_dasd_e
  07742	48 8b 84 24 c0
	03 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  0774a	48 8b 80 a8 12
	00 00		 mov	 rax, QWORD PTR [rax+4776]
  07751	0f b6 40 0a	 movzx	 eax, BYTE PTR [rax+10]
  07755	3d e9 00 00 00	 cmp	 eax, 233		; 000000e9H
  0775a	74 2f		 je	 SHORT $LN474@ckd_dasd_e
$LN477@ckd_dasd_e:
$LN475@ckd_dasd_e:

; 4992 :         !(MODEL3( dev->ckdcu ) || MODEL6( dev->ckdcu )))
; 4993 :     {
; 4994 :         /* Set command reject sense byte, and unit check status */
; 4995 :         ckd_build_sense (dev, SENSE_CR, 0, 0, FORMAT_0, MESSAGE_1);

  0775c	c6 44 24 28 01	 mov	 BYTE PTR [rsp+40], 1
  07761	c6 44 24 20 00	 mov	 BYTE PTR [rsp+32], 0
  07766	45 33 c9	 xor	 r9d, r9d
  07769	45 33 c0	 xor	 r8d, r8d
  0776c	b2 80		 mov	 dl, 128			; 00000080H
  0776e	48 8b 8c 24 c0
	03 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  07776	e8 00 00 00 00	 call	 ckd_build_sense

; 4996 :         *unitstat = CSW_CE | CSW_DE | CSW_UC;

  0777b	48 8b 84 24 08
	04 00 00	 mov	 rax, QWORD PTR unitstat$[rsp]
  07783	c6 00 0e	 mov	 BYTE PTR [rax], 14

; 4997 :         break;

  07786	e9 c5 2d 00 00	 jmp	 $LN2@ckd_dasd_e
$LN474@ckd_dasd_e:

; 4998 :     }
; 4999 :     /*
; 5000 :      * The Storage Director initially requests 20 bytes of parameters
; 5001 :      * from the channel; if the channel provides fewer than 20 bytes,
; 5002 :      * execution is terminated with status that includes unit check
; 5003 :      * (Command Reject, format X'03', CCW byte count less than required).
; 5004 :      */
; 5005 :     num = (count < 20) ? count : 20;

  0778b	83 bc 24 e0 03
	00 00 14	 cmp	 DWORD PTR count$[rsp], 20
  07793	73 10		 jae	 SHORT $LN745@ckd_dasd_e
  07795	8b 84 24 e0 03
	00 00		 mov	 eax, DWORD PTR count$[rsp]
  0779c	89 84 24 9c 01
	00 00		 mov	 DWORD PTR tv3797[rsp], eax
  077a3	eb 0b		 jmp	 SHORT $LN746@ckd_dasd_e
$LN745@ckd_dasd_e:
  077a5	c7 84 24 9c 01
	00 00 14 00 00
	00		 mov	 DWORD PTR tv3797[rsp], 20
$LN746@ckd_dasd_e:
  077b0	8b 84 24 9c 01
	00 00		 mov	 eax, DWORD PTR tv3797[rsp]
  077b7	89 44 24 64	 mov	 DWORD PTR num$[rsp], eax

; 5006 :     *residual = count - num;

  077bb	8b 44 24 64	 mov	 eax, DWORD PTR num$[rsp]
  077bf	8b 8c 24 e0 03
	00 00		 mov	 ecx, DWORD PTR count$[rsp]
  077c6	2b c8		 sub	 ecx, eax
  077c8	8b c1		 mov	 eax, ecx
  077ca	48 8b 8c 24 10
	04 00 00	 mov	 rcx, QWORD PTR residual$[rsp]
  077d2	89 01		 mov	 DWORD PTR [rcx], eax

; 5007 :     if (count < 20)

  077d4	83 bc 24 e0 03
	00 00 14	 cmp	 DWORD PTR count$[rsp], 20
  077dc	73 2f		 jae	 SHORT $LN478@ckd_dasd_e

; 5008 :     {
; 5009 :         ckd_build_sense (dev, SENSE_CR, 0, 0, FORMAT_0, MESSAGE_3);

  077de	c6 44 24 28 03	 mov	 BYTE PTR [rsp+40], 3
  077e3	c6 44 24 20 00	 mov	 BYTE PTR [rsp+32], 0
  077e8	45 33 c9	 xor	 r9d, r9d
  077eb	45 33 c0	 xor	 r8d, r8d
  077ee	b2 80		 mov	 dl, 128			; 00000080H
  077f0	48 8b 8c 24 c0
	03 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  077f8	e8 00 00 00 00	 call	 ckd_build_sense

; 5010 :         *unitstat = CSW_CE | CSW_DE | CSW_UC;

  077fd	48 8b 84 24 08
	04 00 00	 mov	 rax, QWORD PTR unitstat$[rsp]
  07805	c6 00 0e	 mov	 BYTE PTR [rax], 14

; 5011 :         break;

  07808	e9 43 2d 00 00	 jmp	 $LN2@ckd_dasd_e
$LN478@ckd_dasd_e:

; 5012 :     }
; 5013 :     /*
; 5014 :      * If Locate Record Extended is received within a Locate Record
; 5015 :      * domain, execution is terminated with status that includes unit
; 5016 :      * check (Command Reject, format X'02', Invalid Command Sequence).
; 5017 :      */
; 5018 :     if (dev->ckdlcount > 0)

  0780d	48 8b 84 24 c0
	03 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  07815	0f b6 80 02 13
	00 00		 movzx	 eax, BYTE PTR [rax+4866]
  0781c	85 c0		 test	 eax, eax
  0781e	7e 2f		 jle	 SHORT $LN479@ckd_dasd_e

; 5019 :     {
; 5020 :         ckd_build_sense (dev, SENSE_CR, 0, 0, FORMAT_0, MESSAGE_2);

  07820	c6 44 24 28 02	 mov	 BYTE PTR [rsp+40], 2
  07825	c6 44 24 20 00	 mov	 BYTE PTR [rsp+32], 0
  0782a	45 33 c9	 xor	 r9d, r9d
  0782d	45 33 c0	 xor	 r8d, r8d
  07830	b2 80		 mov	 dl, 128			; 00000080H
  07832	48 8b 8c 24 c0
	03 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  0783a	e8 00 00 00 00	 call	 ckd_build_sense

; 5021 :         *unitstat = CSW_CE | CSW_DE | CSW_UC;

  0783f	48 8b 84 24 08
	04 00 00	 mov	 rax, QWORD PTR unitstat$[rsp]
  07847	c6 00 0e	 mov	 BYTE PTR [rax], 14

; 5022 :         break;

  0784a	e9 01 2d 00 00	 jmp	 $LN2@ckd_dasd_e
$LN479@ckd_dasd_e:

; 5023 :     }
; 5024 :     /*
; 5025 :      * If Locate Record Extended was not preceded by a Define Extent
; 5026 :      * or Read IPL command in the same channel program, execution is
; 5027 :      * terminated with status that includes unit check (Command Reject,
; 5028 :      * format X'02', Invalid Command Sequence). If any other operation
; 5029 :      * is specified, the command is terminated with status that
; 5030 :      * includes unit check (Command Reject, format X'02', Invalid
; 5031 :      * Command Sequence).
; 5032 :      */
; 5033 :     //FIXME not sure what that last sentence means
; 5034 :     if (dev->ckdxtdef == 0 && dev->ckdrdipl == 0)

  0784f	48 8b 84 24 c0
	03 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  07857	8b 80 14 13 00
	00		 mov	 eax, DWORD PTR [rax+4884]
  0785d	d1 e8		 shr	 eax, 1
  0785f	83 e0 01	 and	 eax, 1
  07862	85 c0		 test	 eax, eax
  07864	75 47		 jne	 SHORT $LN480@ckd_dasd_e
  07866	48 8b 84 24 c0
	03 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  0786e	8b 80 14 13 00
	00		 mov	 eax, DWORD PTR [rax+4884]
  07874	c1 e8 09	 shr	 eax, 9
  07877	83 e0 01	 and	 eax, 1
  0787a	85 c0		 test	 eax, eax
  0787c	75 2f		 jne	 SHORT $LN480@ckd_dasd_e

; 5035 :     {
; 5036 :         ckd_build_sense (dev, SENSE_CR, 0, 0, FORMAT_0, MESSAGE_2);

  0787e	c6 44 24 28 02	 mov	 BYTE PTR [rsp+40], 2
  07883	c6 44 24 20 00	 mov	 BYTE PTR [rsp+32], 0
  07888	45 33 c9	 xor	 r9d, r9d
  0788b	45 33 c0	 xor	 r8d, r8d
  0788e	b2 80		 mov	 dl, 128			; 00000080H
  07890	48 8b 8c 24 c0
	03 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  07898	e8 00 00 00 00	 call	 ckd_build_sense

; 5037 :         *unitstat = CSW_CE | CSW_DE | CSW_UC;

  0789d	48 8b 84 24 08
	04 00 00	 mov	 rax, QWORD PTR unitstat$[rsp]
  078a5	c6 00 0e	 mov	 BYTE PTR [rax], 14

; 5038 :         break;

  078a8	e9 a3 2c 00 00	 jmp	 $LN2@ckd_dasd_e
$LN480@ckd_dasd_e:

; 5039 :     }
; 5040 : 
; 5041 :     /* Byte 0 contains the locate record operation byte */
; 5042 :     dev->ckdloper = iobuf[0];

  078ad	b8 01 00 00 00	 mov	 eax, 1
  078b2	48 6b c0 00	 imul	 rax, rax, 0
  078b6	48 8b 8c 24 c0
	03 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  078be	48 8b 94 24 f8
	03 00 00	 mov	 rdx, QWORD PTR iobuf$[rsp]
  078c6	0f b6 04 02	 movzx	 eax, BYTE PTR [rdx+rax]
  078ca	88 81 00 13 00
	00		 mov	 BYTE PTR [rcx+4864], al

; 5043 : 
; 5044 :     /* Validate the locate record operation code (byte 0 bits 2-7) */
; 5045 :     if ((dev->ckdloper & CKDOPER_CODE) != CKDOPER_WRITE
; 5046 :      && (dev->ckdloper & CKDOPER_CODE) != CKDOPER_FORMAT
; 5047 :      && (dev->ckdloper & CKDOPER_CODE) != CKDOPER_WRTTRK
; 5048 :      && (dev->ckdloper & CKDOPER_CODE) != CKDOPER_RDTRKS
; 5049 :      && (dev->ckdloper & CKDOPER_CODE) != CKDOPER_READ
; 5050 :      && (dev->ckdloper & CKDOPER_CODE) != CKDOPER_EXTOP)

  078d0	48 8b 84 24 c0
	03 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  078d8	0f b6 80 00 13
	00 00		 movzx	 eax, BYTE PTR [rax+4864]
  078df	83 e0 3f	 and	 eax, 63			; 0000003fH
  078e2	83 f8 01	 cmp	 eax, 1
  078e5	0f 84 a6 00 00
	00		 je	 $LN481@ckd_dasd_e
  078eb	48 8b 84 24 c0
	03 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  078f3	0f b6 80 00 13
	00 00		 movzx	 eax, BYTE PTR [rax+4864]
  078fa	83 e0 3f	 and	 eax, 63			; 0000003fH
  078fd	83 f8 03	 cmp	 eax, 3
  07900	0f 84 8b 00 00
	00		 je	 $LN481@ckd_dasd_e
  07906	48 8b 84 24 c0
	03 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  0790e	0f b6 80 00 13
	00 00		 movzx	 eax, BYTE PTR [rax+4864]
  07915	83 e0 3f	 and	 eax, 63			; 0000003fH
  07918	83 f8 0b	 cmp	 eax, 11
  0791b	74 74		 je	 SHORT $LN481@ckd_dasd_e
  0791d	48 8b 84 24 c0
	03 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  07925	0f b6 80 00 13
	00 00		 movzx	 eax, BYTE PTR [rax+4864]
  0792c	83 e0 3f	 and	 eax, 63			; 0000003fH
  0792f	83 f8 0c	 cmp	 eax, 12
  07932	74 5d		 je	 SHORT $LN481@ckd_dasd_e
  07934	48 8b 84 24 c0
	03 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  0793c	0f b6 80 00 13
	00 00		 movzx	 eax, BYTE PTR [rax+4864]
  07943	83 e0 3f	 and	 eax, 63			; 0000003fH
  07946	83 f8 16	 cmp	 eax, 22
  07949	74 46		 je	 SHORT $LN481@ckd_dasd_e
  0794b	48 8b 84 24 c0
	03 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  07953	0f b6 80 00 13
	00 00		 movzx	 eax, BYTE PTR [rax+4864]
  0795a	83 e0 3f	 and	 eax, 63			; 0000003fH
  0795d	83 f8 3f	 cmp	 eax, 63			; 0000003fH
  07960	74 2f		 je	 SHORT $LN481@ckd_dasd_e

; 5051 :     {
; 5052 :         ckd_build_sense (dev, SENSE_CR, 0, 0, FORMAT_0, MESSAGE_4);

  07962	c6 44 24 28 04	 mov	 BYTE PTR [rsp+40], 4
  07967	c6 44 24 20 00	 mov	 BYTE PTR [rsp+32], 0
  0796c	45 33 c9	 xor	 r9d, r9d
  0796f	45 33 c0	 xor	 r8d, r8d
  07972	b2 80		 mov	 dl, 128			; 00000080H
  07974	48 8b 8c 24 c0
	03 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  0797c	e8 00 00 00 00	 call	 ckd_build_sense

; 5053 :         *unitstat = CSW_CE | CSW_DE | CSW_UC;

  07981	48 8b 84 24 08
	04 00 00	 mov	 rax, QWORD PTR unitstat$[rsp]
  07989	c6 00 0e	 mov	 BYTE PTR [rax], 14

; 5054 :         break;

  0798c	e9 bf 2b 00 00	 jmp	 $LN2@ckd_dasd_e
$LN481@ckd_dasd_e:

; 5055 :     }
; 5056 :     /* Validate the locate record extended operation code (byte 17) */
; 5057 :     if ((dev->ckdloper & CKDOPER_CODE) == CKDOPER_EXTOP)

  07991	48 8b 84 24 c0
	03 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  07999	0f b6 80 00 13
	00 00		 movzx	 eax, BYTE PTR [rax+4864]
  079a0	83 e0 3f	 and	 eax, 63			; 0000003fH
  079a3	83 f8 3f	 cmp	 eax, 63			; 0000003fH
  079a6	0f 85 d7 00 00
	00		 jne	 $LN482@ckd_dasd_e

; 5058 :     {
; 5059 :         if (iobuf[17] != CKDOPER_WRTANY
; 5060 :          && iobuf[17] != CKDOPER_RDANY
; 5061 :          && iobuf[17] != CKDOPER_RDTSET)

  079ac	b8 01 00 00 00	 mov	 eax, 1
  079b1	48 6b c0 11	 imul	 rax, rax, 17
  079b5	48 8b 8c 24 f8
	03 00 00	 mov	 rcx, QWORD PTR iobuf$[rsp]
  079bd	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  079c1	83 f8 09	 cmp	 eax, 9
  079c4	74 63		 je	 SHORT $LN484@ckd_dasd_e
  079c6	b8 01 00 00 00	 mov	 eax, 1
  079cb	48 6b c0 11	 imul	 rax, rax, 17
  079cf	48 8b 8c 24 f8
	03 00 00	 mov	 rcx, QWORD PTR iobuf$[rsp]
  079d7	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  079db	83 f8 0a	 cmp	 eax, 10
  079de	74 49		 je	 SHORT $LN484@ckd_dasd_e
  079e0	b8 01 00 00 00	 mov	 eax, 1
  079e5	48 6b c0 11	 imul	 rax, rax, 17
  079e9	48 8b 8c 24 f8
	03 00 00	 mov	 rcx, QWORD PTR iobuf$[rsp]
  079f1	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  079f5	83 f8 0e	 cmp	 eax, 14
  079f8	74 2f		 je	 SHORT $LN484@ckd_dasd_e

; 5062 :         {
; 5063 :             ckd_build_sense (dev, SENSE_CR, 0, 0, FORMAT_0, MESSAGE_4);

  079fa	c6 44 24 28 04	 mov	 BYTE PTR [rsp+40], 4
  079ff	c6 44 24 20 00	 mov	 BYTE PTR [rsp+32], 0
  07a04	45 33 c9	 xor	 r9d, r9d
  07a07	45 33 c0	 xor	 r8d, r8d
  07a0a	b2 80		 mov	 dl, 128			; 00000080H
  07a0c	48 8b 8c 24 c0
	03 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  07a14	e8 00 00 00 00	 call	 ckd_build_sense

; 5064 :             *unitstat = CSW_CE | CSW_DE | CSW_UC;

  07a19	48 8b 84 24 08
	04 00 00	 mov	 rax, QWORD PTR unitstat$[rsp]
  07a21	c6 00 0e	 mov	 BYTE PTR [rax], 14

; 5065 :             break;

  07a24	e9 27 2b 00 00	 jmp	 $LN2@ckd_dasd_e
$LN484@ckd_dasd_e:

; 5066 :         }
; 5067 :         dev->ckdloper &= CKDOPER_ORIENTATION;

  07a29	48 8b 84 24 c0
	03 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  07a31	0f b6 80 00 13
	00 00		 movzx	 eax, BYTE PTR [rax+4864]
  07a38	25 c0 00 00 00	 and	 eax, 192		; 000000c0H
  07a3d	48 8b 8c 24 c0
	03 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  07a45	88 81 00 13 00
	00		 mov	 BYTE PTR [rcx+4864], al

; 5068 :         dev->ckdloper |= iobuf[17];

  07a4b	b8 01 00 00 00	 mov	 eax, 1
  07a50	48 6b c0 11	 imul	 rax, rax, 17
  07a54	48 8b 8c 24 f8
	03 00 00	 mov	 rcx, QWORD PTR iobuf$[rsp]
  07a5c	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  07a60	48 8b 8c 24 c0
	03 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  07a68	0f b6 89 00 13
	00 00		 movzx	 ecx, BYTE PTR [rcx+4864]
  07a6f	0b c8		 or	 ecx, eax
  07a71	8b c1		 mov	 eax, ecx
  07a73	48 8b 8c 24 c0
	03 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  07a7b	88 81 00 13 00
	00		 mov	 BYTE PTR [rcx+4864], al

; 5069 :     }

  07a81	eb 48		 jmp	 SHORT $LN483@ckd_dasd_e
$LN482@ckd_dasd_e:

; 5070 :     else if (iobuf[17] != 0)

  07a83	b8 01 00 00 00	 mov	 eax, 1
  07a88	48 6b c0 11	 imul	 rax, rax, 17
  07a8c	48 8b 8c 24 f8
	03 00 00	 mov	 rcx, QWORD PTR iobuf$[rsp]
  07a94	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  07a98	85 c0		 test	 eax, eax
  07a9a	74 2f		 je	 SHORT $LN485@ckd_dasd_e

; 5071 :     {
; 5072 :         ckd_build_sense (dev, SENSE_CR, 0, 0, FORMAT_0, MESSAGE_4);

  07a9c	c6 44 24 28 04	 mov	 BYTE PTR [rsp+40], 4
  07aa1	c6 44 24 20 00	 mov	 BYTE PTR [rsp+32], 0
  07aa6	45 33 c9	 xor	 r9d, r9d
  07aa9	45 33 c0	 xor	 r8d, r8d
  07aac	b2 80		 mov	 dl, 128			; 00000080H
  07aae	48 8b 8c 24 c0
	03 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  07ab6	e8 00 00 00 00	 call	 ckd_build_sense

; 5073 :         *unitstat = CSW_CE | CSW_DE | CSW_UC;

  07abb	48 8b 84 24 08
	04 00 00	 mov	 rax, QWORD PTR unitstat$[rsp]
  07ac3	c6 00 0e	 mov	 BYTE PTR [rax], 14

; 5074 :         break;

  07ac6	e9 85 2a 00 00	 jmp	 $LN2@ckd_dasd_e
$LN485@ckd_dasd_e:
$LN483@ckd_dasd_e:

; 5075 :     }
; 5076 : 
; 5077 :     /* Check for write operation on a read only disk */
; 5078 : //FIXME Not sure if this is right here
; 5079 :     if ( (dev->ckdrdonly && !dev->ckdfakewr && !dev->dasdsfn)
; 5080 :          &&  ((dev->ckdloper & CKDOPER_CODE) == CKDOPER_WRITE

  07acb	48 8b 84 24 c0
	03 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  07ad3	8b 80 14 13 00
	00		 mov	 eax, DWORD PTR [rax+4884]
  07ad9	c1 e8 12	 shr	 eax, 18
  07adc	83 e0 01	 and	 eax, 1
  07adf	85 c0		 test	 eax, eax
  07ae1	0f 84 bd 00 00
	00		 je	 $LN486@ckd_dasd_e
  07ae7	48 8b 84 24 c0
	03 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  07aef	8b 80 14 13 00
	00		 mov	 eax, DWORD PTR [rax+4884]
  07af5	c1 e8 14	 shr	 eax, 20
  07af8	83 e0 01	 and	 eax, 1
  07afb	85 c0		 test	 eax, eax
  07afd	0f 85 a1 00 00
	00		 jne	 $LN486@ckd_dasd_e
  07b03	48 8b 84 24 c0
	03 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  07b0b	48 83 b8 70 11
	00 00 00	 cmp	 QWORD PTR [rax+4464], 0
  07b13	0f 85 8b 00 00
	00		 jne	 $LN486@ckd_dasd_e
  07b19	48 8b 84 24 c0
	03 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  07b21	0f b6 80 00 13
	00 00		 movzx	 eax, BYTE PTR [rax+4864]
  07b28	83 e0 3f	 and	 eax, 63			; 0000003fH
  07b2b	83 f8 01	 cmp	 eax, 1
  07b2e	74 45		 je	 SHORT $LN487@ckd_dasd_e
  07b30	48 8b 84 24 c0
	03 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  07b38	0f b6 80 00 13
	00 00		 movzx	 eax, BYTE PTR [rax+4864]
  07b3f	83 e0 3f	 and	 eax, 63			; 0000003fH
  07b42	83 f8 09	 cmp	 eax, 9
  07b45	74 2e		 je	 SHORT $LN487@ckd_dasd_e
  07b47	48 8b 84 24 c0
	03 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  07b4f	0f b6 80 00 13
	00 00		 movzx	 eax, BYTE PTR [rax+4864]
  07b56	83 e0 3f	 and	 eax, 63			; 0000003fH
  07b59	83 f8 03	 cmp	 eax, 3
  07b5c	74 17		 je	 SHORT $LN487@ckd_dasd_e
  07b5e	48 8b 84 24 c0
	03 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  07b66	0f b6 80 00 13
	00 00		 movzx	 eax, BYTE PTR [rax+4864]
  07b6d	83 e0 3f	 and	 eax, 63			; 0000003fH
  07b70	83 f8 0b	 cmp	 eax, 11
  07b73	75 2f		 jne	 SHORT $LN486@ckd_dasd_e
$LN487@ckd_dasd_e:

; 5081 :            || (dev->ckdloper & CKDOPER_CODE) == CKDOPER_WRTANY
; 5082 :            || (dev->ckdloper & CKDOPER_CODE) == CKDOPER_FORMAT
; 5083 :            || (dev->ckdloper & CKDOPER_CODE) == CKDOPER_WRTTRK)
; 5084 :            )
; 5085 :         {
; 5086 :             ckd_build_sense (dev, SENSE_EC, SENSE1_WRI, 0,

  07b75	c6 44 24 28 04	 mov	 BYTE PTR [rsp+40], 4
  07b7a	c6 44 24 20 00	 mov	 BYTE PTR [rsp+32], 0
  07b7f	45 33 c9	 xor	 r9d, r9d
  07b82	41 b0 02	 mov	 r8b, 2
  07b85	b2 10		 mov	 dl, 16
  07b87	48 8b 8c 24 c0
	03 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  07b8f	e8 00 00 00 00	 call	 ckd_build_sense

; 5087 :                             FORMAT_0, MESSAGE_4);
; 5088 :             *unitstat = CSW_CE | CSW_DE | CSW_UC;

  07b94	48 8b 84 24 08
	04 00 00	 mov	 rax, QWORD PTR unitstat$[rsp]
  07b9c	c6 00 0e	 mov	 BYTE PTR [rax], 14

; 5089 :             break;

  07b9f	e9 ac 29 00 00	 jmp	 $LN2@ckd_dasd_e
$LN486@ckd_dasd_e:

; 5090 :         }
; 5091 :     /*
; 5092 :      * Check for valid combination of orientation and opcode
; 5093 :      *
; 5094 :      * +------------------------------------------------+
; 5095 :      * | Operation Code          Orientation      Byte  |
; 5096 :      * |                      Cnt  HA Data Index    17  |
; 5097 :      * +------------------------------------------------+
; 5098 :      * | Write Data            01   x   81     x    00  |
; 5099 :      * | Format Write          03  43    x    C3    00  |
; 5100 :      * | Write Track           0B   x    x     x    00  |
; 5101 :      * | Read Tracks           0C  4C    x     x    00  |
; 5102 :      * | Read                  16  56   96    D6    00  |
; 5103 :      * | Write Any             3F   x    x     x    09  |
; 5104 :      * | Read Any              3F   x    x     x    0A  |
; 5105 :      * | Read Trackset         3F  7F    x     x    0E  |
; 5106 :      * +------------------------------------------------+
; 5107 :      * | Note:  x - Combination is not valid.           |
; 5108 :      * +------------------------------------------------+
; 5109 :      * Table: valid orientation + operation code values
; 5110 :      */
; 5111 :     if (dev->ckdloper != 0x01 && dev->ckdloper != 0x81
; 5112 :      && dev->ckdloper != 0x03 && dev->ckdloper != 0x43 &&
; 5113 :         dev->ckdloper != 0xC3
; 5114 :      && dev->ckdloper != 0x0B
; 5115 :      && dev->ckdloper != 0x0C && dev->ckdloper != 0x4C
; 5116 :      && dev->ckdloper != 0x16 && dev->ckdloper != 0x56 &&
; 5117 :         dev->ckdloper != 0x96 && dev->ckdloper != 0xD6
; 5118 :      && dev->ckdloper != 0x09
; 5119 :      && dev->ckdloper != 0x0A
; 5120 :      && dev->ckdloper != 0x0E && dev->ckdloper != 0x4E)

  07ba4	48 8b 84 24 c0
	03 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  07bac	0f b6 80 00 13
	00 00		 movzx	 eax, BYTE PTR [rax+4864]
  07bb3	83 f8 01	 cmp	 eax, 1
  07bb6	0f 84 8b 01 00
	00		 je	 $LN488@ckd_dasd_e
  07bbc	48 8b 84 24 c0
	03 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  07bc4	0f b6 80 00 13
	00 00		 movzx	 eax, BYTE PTR [rax+4864]
  07bcb	3d 81 00 00 00	 cmp	 eax, 129		; 00000081H
  07bd0	0f 84 71 01 00
	00		 je	 $LN488@ckd_dasd_e
  07bd6	48 8b 84 24 c0
	03 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  07bde	0f b6 80 00 13
	00 00		 movzx	 eax, BYTE PTR [rax+4864]
  07be5	83 f8 03	 cmp	 eax, 3
  07be8	0f 84 59 01 00
	00		 je	 $LN488@ckd_dasd_e
  07bee	48 8b 84 24 c0
	03 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  07bf6	0f b6 80 00 13
	00 00		 movzx	 eax, BYTE PTR [rax+4864]
  07bfd	83 f8 43	 cmp	 eax, 67			; 00000043H
  07c00	0f 84 41 01 00
	00		 je	 $LN488@ckd_dasd_e
  07c06	48 8b 84 24 c0
	03 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  07c0e	0f b6 80 00 13
	00 00		 movzx	 eax, BYTE PTR [rax+4864]
  07c15	3d c3 00 00 00	 cmp	 eax, 195		; 000000c3H
  07c1a	0f 84 27 01 00
	00		 je	 $LN488@ckd_dasd_e
  07c20	48 8b 84 24 c0
	03 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  07c28	0f b6 80 00 13
	00 00		 movzx	 eax, BYTE PTR [rax+4864]
  07c2f	83 f8 0b	 cmp	 eax, 11
  07c32	0f 84 0f 01 00
	00		 je	 $LN488@ckd_dasd_e
  07c38	48 8b 84 24 c0
	03 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  07c40	0f b6 80 00 13
	00 00		 movzx	 eax, BYTE PTR [rax+4864]
  07c47	83 f8 0c	 cmp	 eax, 12
  07c4a	0f 84 f7 00 00
	00		 je	 $LN488@ckd_dasd_e
  07c50	48 8b 84 24 c0
	03 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  07c58	0f b6 80 00 13
	00 00		 movzx	 eax, BYTE PTR [rax+4864]
  07c5f	83 f8 4c	 cmp	 eax, 76			; 0000004cH
  07c62	0f 84 df 00 00
	00		 je	 $LN488@ckd_dasd_e
  07c68	48 8b 84 24 c0
	03 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  07c70	0f b6 80 00 13
	00 00		 movzx	 eax, BYTE PTR [rax+4864]
  07c77	83 f8 16	 cmp	 eax, 22
  07c7a	0f 84 c7 00 00
	00		 je	 $LN488@ckd_dasd_e
  07c80	48 8b 84 24 c0
	03 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  07c88	0f b6 80 00 13
	00 00		 movzx	 eax, BYTE PTR [rax+4864]
  07c8f	83 f8 56	 cmp	 eax, 86			; 00000056H
  07c92	0f 84 af 00 00
	00		 je	 $LN488@ckd_dasd_e
  07c98	48 8b 84 24 c0
	03 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  07ca0	0f b6 80 00 13
	00 00		 movzx	 eax, BYTE PTR [rax+4864]
  07ca7	3d 96 00 00 00	 cmp	 eax, 150		; 00000096H
  07cac	0f 84 95 00 00
	00		 je	 $LN488@ckd_dasd_e
  07cb2	48 8b 84 24 c0
	03 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  07cba	0f b6 80 00 13
	00 00		 movzx	 eax, BYTE PTR [rax+4864]
  07cc1	3d d6 00 00 00	 cmp	 eax, 214		; 000000d6H
  07cc6	74 7f		 je	 SHORT $LN488@ckd_dasd_e
  07cc8	48 8b 84 24 c0
	03 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  07cd0	0f b6 80 00 13
	00 00		 movzx	 eax, BYTE PTR [rax+4864]
  07cd7	83 f8 09	 cmp	 eax, 9
  07cda	74 6b		 je	 SHORT $LN488@ckd_dasd_e
  07cdc	48 8b 84 24 c0
	03 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  07ce4	0f b6 80 00 13
	00 00		 movzx	 eax, BYTE PTR [rax+4864]
  07ceb	83 f8 0a	 cmp	 eax, 10
  07cee	74 57		 je	 SHORT $LN488@ckd_dasd_e
  07cf0	48 8b 84 24 c0
	03 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  07cf8	0f b6 80 00 13
	00 00		 movzx	 eax, BYTE PTR [rax+4864]
  07cff	83 f8 0e	 cmp	 eax, 14
  07d02	74 43		 je	 SHORT $LN488@ckd_dasd_e
  07d04	48 8b 84 24 c0
	03 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  07d0c	0f b6 80 00 13
	00 00		 movzx	 eax, BYTE PTR [rax+4864]
  07d13	83 f8 4e	 cmp	 eax, 78			; 0000004eH
  07d16	74 2f		 je	 SHORT $LN488@ckd_dasd_e

; 5121 :     {
; 5122 :         ckd_build_sense (dev, SENSE_CR, 0, 0, FORMAT_0, MESSAGE_4);

  07d18	c6 44 24 28 04	 mov	 BYTE PTR [rsp+40], 4
  07d1d	c6 44 24 20 00	 mov	 BYTE PTR [rsp+32], 0
  07d22	45 33 c9	 xor	 r9d, r9d
  07d25	45 33 c0	 xor	 r8d, r8d
  07d28	b2 80		 mov	 dl, 128			; 00000080H
  07d2a	48 8b 8c 24 c0
	03 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  07d32	e8 00 00 00 00	 call	 ckd_build_sense

; 5123 :         *unitstat = CSW_CE | CSW_DE | CSW_UC;

  07d37	48 8b 84 24 08
	04 00 00	 mov	 rax, QWORD PTR unitstat$[rsp]
  07d3f	c6 00 0e	 mov	 BYTE PTR [rax], 14

; 5124 :         break;

  07d42	e9 09 28 00 00	 jmp	 $LN2@ckd_dasd_e
$LN488@ckd_dasd_e:

; 5125 :     }
; 5126 :     /*
; 5127 :      * Byte 1 is the Auxiliary Byte
; 5128 :      * bit 0 = 0 : Bytes 14-15 are unused
; 5129 :      *         1 : Bytes 14-15 contain a TLF that overrides the
; 5130 :      *             blocksize specified by the DX parameter.
; 5131 :      * bits 1-6  : Must be zero
; 5132 :      *             If any of these bits are '1', the LRE is terminated
; 5133 :      *             with status that includes unit check (Command Reject,
; 5134 :      *             format X'04', Invalid Parameter).
; 5135 :      * bit 7 = 0 : No Read Count CCW is suffixed to the LR domain
; 5136 :      *         1 : A Read Count CCW is suffixed to the LR domain
; 5137 :      */
; 5138 :     if ((iobuf[1] & CKDLAUX_RESV) != 0)

  07d47	b8 01 00 00 00	 mov	 eax, 1
  07d4c	48 6b c0 01	 imul	 rax, rax, 1
  07d50	48 8b 8c 24 f8
	03 00 00	 mov	 rcx, QWORD PTR iobuf$[rsp]
  07d58	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  07d5c	83 e0 7e	 and	 eax, 126		; 0000007eH
  07d5f	85 c0		 test	 eax, eax
  07d61	74 2f		 je	 SHORT $LN489@ckd_dasd_e

; 5139 :     {
; 5140 :         ckd_build_sense (dev, SENSE_CR, 0, 0, FORMAT_0, MESSAGE_4);

  07d63	c6 44 24 28 04	 mov	 BYTE PTR [rsp+40], 4
  07d68	c6 44 24 20 00	 mov	 BYTE PTR [rsp+32], 0
  07d6d	45 33 c9	 xor	 r9d, r9d
  07d70	45 33 c0	 xor	 r8d, r8d
  07d73	b2 80		 mov	 dl, 128			; 00000080H
  07d75	48 8b 8c 24 c0
	03 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  07d7d	e8 00 00 00 00	 call	 ckd_build_sense

; 5141 :         *unitstat = CSW_CE | CSW_DE | CSW_UC;

  07d82	48 8b 84 24 08
	04 00 00	 mov	 rax, QWORD PTR unitstat$[rsp]
  07d8a	c6 00 0e	 mov	 BYTE PTR [rax], 14

; 5142 :         break;

  07d8d	e9 be 27 00 00	 jmp	 $LN2@ckd_dasd_e
$LN489@ckd_dasd_e:

; 5143 :     }
; 5144 :     /*
; 5145 :      * A Read Count command may only be suffixed to the domain of a LRE
; 5146 :      * that specifies a Write Data (01), Write Any (09), Read Any (0A),
; 5147 :      * or Read (16) operation code; if bit 7 = '1' when any other
; 5148 :      * Operation code is specified, Locate Record Extended is terminated
; 5149 :      * with status that includes unit check (Command Reject, format
; 5150 :      * X'04', Invalid Parameter).
; 5151 :      */
; 5152 :     if ((iobuf[1] & CKDLAUX_RDCNTSUF)
; 5153 :      && ((dev->ckdloper & CKDOPER_CODE) != CKDOPER_WRITE

  07d92	b8 01 00 00 00	 mov	 eax, 1
  07d97	48 6b c0 01	 imul	 rax, rax, 1
  07d9b	48 8b 8c 24 f8
	03 00 00	 mov	 rcx, QWORD PTR iobuf$[rsp]
  07da3	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  07da7	83 e0 01	 and	 eax, 1
  07daa	85 c0		 test	 eax, eax
  07dac	0f 84 8b 00 00
	00		 je	 $LN490@ckd_dasd_e
  07db2	48 8b 84 24 c0
	03 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  07dba	0f b6 80 00 13
	00 00		 movzx	 eax, BYTE PTR [rax+4864]
  07dc1	83 e0 3f	 and	 eax, 63			; 0000003fH
  07dc4	83 f8 01	 cmp	 eax, 1
  07dc7	74 74		 je	 SHORT $LN490@ckd_dasd_e
  07dc9	48 8b 84 24 c0
	03 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  07dd1	0f b6 80 00 13
	00 00		 movzx	 eax, BYTE PTR [rax+4864]
  07dd8	83 e0 3f	 and	 eax, 63			; 0000003fH
  07ddb	83 f8 09	 cmp	 eax, 9
  07dde	74 5d		 je	 SHORT $LN490@ckd_dasd_e
  07de0	48 8b 84 24 c0
	03 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  07de8	0f b6 80 00 13
	00 00		 movzx	 eax, BYTE PTR [rax+4864]
  07def	83 e0 3f	 and	 eax, 63			; 0000003fH
  07df2	83 f8 0a	 cmp	 eax, 10
  07df5	74 46		 je	 SHORT $LN490@ckd_dasd_e
  07df7	48 8b 84 24 c0
	03 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  07dff	0f b6 80 00 13
	00 00		 movzx	 eax, BYTE PTR [rax+4864]
  07e06	83 e0 3f	 and	 eax, 63			; 0000003fH
  07e09	83 f8 16	 cmp	 eax, 22
  07e0c	74 2f		 je	 SHORT $LN490@ckd_dasd_e

; 5154 :       && (dev->ckdloper & CKDOPER_CODE) != CKDOPER_WRTANY
; 5155 :       && (dev->ckdloper & CKDOPER_CODE) != CKDOPER_RDANY
; 5156 :       && (dev->ckdloper & CKDOPER_CODE) != CKDOPER_READ))
; 5157 :     {
; 5158 :         ckd_build_sense (dev, SENSE_CR, 0, 0, FORMAT_0, MESSAGE_4);

  07e0e	c6 44 24 28 04	 mov	 BYTE PTR [rsp+40], 4
  07e13	c6 44 24 20 00	 mov	 BYTE PTR [rsp+32], 0
  07e18	45 33 c9	 xor	 r9d, r9d
  07e1b	45 33 c0	 xor	 r8d, r8d
  07e1e	b2 80		 mov	 dl, 128			; 00000080H
  07e20	48 8b 8c 24 c0
	03 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  07e28	e8 00 00 00 00	 call	 ckd_build_sense

; 5159 :         *unitstat = CSW_CE | CSW_DE | CSW_UC;

  07e2d	48 8b 84 24 08
	04 00 00	 mov	 rax, QWORD PTR unitstat$[rsp]
  07e35	c6 00 0e	 mov	 BYTE PTR [rax], 14

; 5160 :         break;

  07e38	e9 13 27 00 00	 jmp	 $LN2@ckd_dasd_e
$LN490@ckd_dasd_e:

; 5161 :     }
; 5162 :     dev->ckdlaux = iobuf[1];

  07e3d	b8 01 00 00 00	 mov	 eax, 1
  07e42	48 6b c0 01	 imul	 rax, rax, 1
  07e46	48 8b 8c 24 c0
	03 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  07e4e	48 8b 94 24 f8
	03 00 00	 mov	 rdx, QWORD PTR iobuf$[rsp]
  07e56	0f b6 04 02	 movzx	 eax, BYTE PTR [rdx+rax]
  07e5a	88 81 01 13 00
	00		 mov	 BYTE PTR [rcx+4865], al

; 5163 : 
; 5164 :     /* Byte 2 must contain zeroes */
; 5165 :     if (iobuf[2] != 0)

  07e60	b8 01 00 00 00	 mov	 eax, 1
  07e65	48 6b c0 02	 imul	 rax, rax, 2
  07e69	48 8b 8c 24 f8
	03 00 00	 mov	 rcx, QWORD PTR iobuf$[rsp]
  07e71	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  07e75	85 c0		 test	 eax, eax
  07e77	74 2f		 je	 SHORT $LN491@ckd_dasd_e

; 5166 :     {
; 5167 :         ckd_build_sense (dev, SENSE_CR, 0, 0, FORMAT_0, MESSAGE_4);

  07e79	c6 44 24 28 04	 mov	 BYTE PTR [rsp+40], 4
  07e7e	c6 44 24 20 00	 mov	 BYTE PTR [rsp+32], 0
  07e83	45 33 c9	 xor	 r9d, r9d
  07e86	45 33 c0	 xor	 r8d, r8d
  07e89	b2 80		 mov	 dl, 128			; 00000080H
  07e8b	48 8b 8c 24 c0
	03 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  07e93	e8 00 00 00 00	 call	 ckd_build_sense

; 5168 :         *unitstat = CSW_CE | CSW_DE | CSW_UC;

  07e98	48 8b 84 24 08
	04 00 00	 mov	 rax, QWORD PTR unitstat$[rsp]
  07ea0	c6 00 0e	 mov	 BYTE PTR [rax], 14

; 5169 :         break;

  07ea3	e9 a8 26 00 00	 jmp	 $LN2@ckd_dasd_e
$LN491@ckd_dasd_e:

; 5170 :     }
; 5171 :     /*
; 5172 :      * Byte 3 is the Count parameter. In general, the count parameter
; 5173 :      * specifies the number of records, or tracks to be operated on by
; 5174 :      * data transfer commands that follow Locate Record Extended.
; 5175 :      * Specific interpretation of the Count parameter depends upon the
; 5176 :      * operation code in byte 0.
; 5177 :      *
; 5178 :      * The Count must be nonzero. If Read Count Suffixing is specified
; 5179 :      * in a Locate Record, the count must be greater than 1. If the
; 5180 :      * Count is invalid, Locate Record Extended is terminated with
; 5181 :      * status that includes unit check (Command Reject, format X'04',
; 5182 :      * Invalid Parameter).
; 5183 :      */
; 5184 :     if (iobuf[3] == 0
; 5185 :      || ((dev->ckdlaux & CKDLAUX_RDCNTSUF) && iobuf[3] < 2))

  07ea8	b8 01 00 00 00	 mov	 eax, 1
  07ead	48 6b c0 03	 imul	 rax, rax, 3
  07eb1	48 8b 8c 24 f8
	03 00 00	 mov	 rcx, QWORD PTR iobuf$[rsp]
  07eb9	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  07ebd	85 c0		 test	 eax, eax
  07ebf	74 30		 je	 SHORT $LN493@ckd_dasd_e
  07ec1	48 8b 84 24 c0
	03 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  07ec9	0f b6 80 01 13
	00 00		 movzx	 eax, BYTE PTR [rax+4865]
  07ed0	83 e0 01	 and	 eax, 1
  07ed3	85 c0		 test	 eax, eax
  07ed5	74 49		 je	 SHORT $LN492@ckd_dasd_e
  07ed7	b8 01 00 00 00	 mov	 eax, 1
  07edc	48 6b c0 03	 imul	 rax, rax, 3
  07ee0	48 8b 8c 24 f8
	03 00 00	 mov	 rcx, QWORD PTR iobuf$[rsp]
  07ee8	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  07eec	83 f8 02	 cmp	 eax, 2
  07eef	7d 2f		 jge	 SHORT $LN492@ckd_dasd_e
$LN493@ckd_dasd_e:

; 5186 :     {
; 5187 :         ckd_build_sense (dev, SENSE_CR, 0, 0, FORMAT_0, MESSAGE_4);

  07ef1	c6 44 24 28 04	 mov	 BYTE PTR [rsp+40], 4
  07ef6	c6 44 24 20 00	 mov	 BYTE PTR [rsp+32], 0
  07efb	45 33 c9	 xor	 r9d, r9d
  07efe	45 33 c0	 xor	 r8d, r8d
  07f01	b2 80		 mov	 dl, 128			; 00000080H
  07f03	48 8b 8c 24 c0
	03 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  07f0b	e8 00 00 00 00	 call	 ckd_build_sense

; 5188 :         *unitstat = CSW_CE | CSW_DE | CSW_UC;

  07f10	48 8b 84 24 08
	04 00 00	 mov	 rax, QWORD PTR unitstat$[rsp]
  07f18	c6 00 0e	 mov	 BYTE PTR [rax], 14

; 5189 :         break;

  07f1b	e9 30 26 00 00	 jmp	 $LN2@ckd_dasd_e
$LN492@ckd_dasd_e:

; 5190 :     }
; 5191 :     dev->ckdlcount = iobuf[3];

  07f20	b8 01 00 00 00	 mov	 eax, 1
  07f25	48 6b c0 03	 imul	 rax, rax, 3
  07f29	48 8b 8c 24 c0
	03 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  07f31	48 8b 94 24 f8
	03 00 00	 mov	 rdx, QWORD PTR iobuf$[rsp]
  07f39	0f b6 04 02	 movzx	 eax, BYTE PTR [rdx+rax]
  07f3d	88 81 02 13 00
	00		 mov	 BYTE PTR [rcx+4866], al

; 5192 :     /*
; 5193 :      * The value in bytes 4-7 must be a valid track address for the
; 5194 :      * device and must be within the extent boundaries specified by the
; 5195 :      * preceding Define Extent command.
; 5196 :      *
; 5197 :      * If the Seek Address is not valid for the device or if the Extended
; 5198 :      * Operation code is Write Any or Read Any and the seek address does
; 5199 :      * not specify a primary track, Locate Record Extended is terminated
; 5200 :      * with status that includes unit check (Command Reject, format X'04',
; 5201 :      * Invalid Parameter). If the Seek Address is not within the defined
; 5202 :      * extent, Locate Record Extended is terminated with status that
; 5203 :      * includes unit check (File Protected).
; 5204 :      */
; 5205 :     cyl = fetch_hw(iobuf+4);

  07f43	48 8b 84 24 f8
	03 00 00	 mov	 rax, QWORD PTR iobuf$[rsp]
  07f4b	48 83 c0 04	 add	 rax, 4
  07f4f	48 8b c8	 mov	 rcx, rax
  07f52	e8 00 00 00 00	 call	 fetch_hw_noswap
  07f57	0f b7 c8	 movzx	 ecx, ax
  07f5a	e8 00 00 00 00	 call	 _byteswap_ushort
  07f5f	66 89 44 24 6c	 mov	 WORD PTR cyl$[rsp], ax

; 5206 :     head = fetch_hw(iobuf+6);

  07f64	48 8b 84 24 f8
	03 00 00	 mov	 rax, QWORD PTR iobuf$[rsp]
  07f6c	48 83 c0 06	 add	 rax, 6
  07f70	48 8b c8	 mov	 rcx, rax
  07f73	e8 00 00 00 00	 call	 fetch_hw_noswap
  07f78	0f b7 c8	 movzx	 ecx, ax
  07f7b	e8 00 00 00 00	 call	 _byteswap_ushort
  07f80	66 89 44 24 70	 mov	 WORD PTR head$[rsp], ax

; 5207 :     if (cyl >= dev->ckdcyls || head >= dev->ckdheads)

  07f85	0f b7 44 24 6c	 movzx	 eax, WORD PTR cyl$[rsp]
  07f8a	48 8b 8c 24 c0
	03 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  07f92	3b 81 b8 12 00
	00		 cmp	 eax, DWORD PTR [rcx+4792]
  07f98	7d 15		 jge	 SHORT $LN495@ckd_dasd_e
  07f9a	0f b7 44 24 70	 movzx	 eax, WORD PTR head$[rsp]
  07f9f	48 8b 8c 24 c0
	03 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  07fa7	3b 81 c0 12 00
	00		 cmp	 eax, DWORD PTR [rcx+4800]
  07fad	7c 2f		 jl	 SHORT $LN494@ckd_dasd_e
$LN495@ckd_dasd_e:

; 5208 :     {
; 5209 :         ckd_build_sense (dev, SENSE_CR, 0, 0, FORMAT_0, MESSAGE_4);

  07faf	c6 44 24 28 04	 mov	 BYTE PTR [rsp+40], 4
  07fb4	c6 44 24 20 00	 mov	 BYTE PTR [rsp+32], 0
  07fb9	45 33 c9	 xor	 r9d, r9d
  07fbc	45 33 c0	 xor	 r8d, r8d
  07fbf	b2 80		 mov	 dl, 128			; 00000080H
  07fc1	48 8b 8c 24 c0
	03 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  07fc9	e8 00 00 00 00	 call	 ckd_build_sense

; 5210 :         *unitstat = CSW_CE | CSW_DE | CSW_UC;

  07fce	48 8b 84 24 08
	04 00 00	 mov	 rax, QWORD PTR unitstat$[rsp]
  07fd6	c6 00 0e	 mov	 BYTE PTR [rax], 14

; 5211 :         break;

  07fd9	e9 72 25 00 00	 jmp	 $LN2@ckd_dasd_e
$LN494@ckd_dasd_e:

; 5212 :     }
; 5213 :     if ( EXTENT_CHECK(dev, cyl, head) )

  07fde	0f b7 44 24 6c	 movzx	 eax, WORD PTR cyl$[rsp]
  07fe3	48 8b 8c 24 c0
	03 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  07feb	0f b7 89 f2 12
	00 00		 movzx	 ecx, WORD PTR [rcx+4850]
  07ff2	3b c1		 cmp	 eax, ecx
  07ff4	7c 78		 jl	 SHORT $LN497@ckd_dasd_e
  07ff6	0f b7 44 24 6c	 movzx	 eax, WORD PTR cyl$[rsp]
  07ffb	48 8b 8c 24 c0
	03 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  08003	0f b7 89 f6 12
	00 00		 movzx	 ecx, WORD PTR [rcx+4854]
  0800a	3b c1		 cmp	 eax, ecx
  0800c	7f 60		 jg	 SHORT $LN497@ckd_dasd_e
  0800e	0f b7 44 24 6c	 movzx	 eax, WORD PTR cyl$[rsp]
  08013	48 8b 8c 24 c0
	03 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  0801b	0f b7 89 f2 12
	00 00		 movzx	 ecx, WORD PTR [rcx+4850]
  08022	3b c1		 cmp	 eax, ecx
  08024	75 18		 jne	 SHORT $LN498@ckd_dasd_e
  08026	0f b7 44 24 70	 movzx	 eax, WORD PTR head$[rsp]
  0802b	48 8b 8c 24 c0
	03 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  08033	0f b7 89 f4 12
	00 00		 movzx	 ecx, WORD PTR [rcx+4852]
  0803a	3b c1		 cmp	 eax, ecx
  0803c	7c 30		 jl	 SHORT $LN497@ckd_dasd_e
$LN498@ckd_dasd_e:
  0803e	0f b7 44 24 6c	 movzx	 eax, WORD PTR cyl$[rsp]
  08043	48 8b 8c 24 c0
	03 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  0804b	0f b7 89 f6 12
	00 00		 movzx	 ecx, WORD PTR [rcx+4854]
  08052	3b c1		 cmp	 eax, ecx
  08054	75 47		 jne	 SHORT $LN496@ckd_dasd_e
  08056	0f b7 44 24 70	 movzx	 eax, WORD PTR head$[rsp]
  0805b	48 8b 8c 24 c0
	03 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  08063	0f b7 89 f8 12
	00 00		 movzx	 ecx, WORD PTR [rcx+4856]
  0806a	3b c1		 cmp	 eax, ecx
  0806c	7e 2f		 jle	 SHORT $LN496@ckd_dasd_e
$LN497@ckd_dasd_e:

; 5214 :     {
; 5215 :         ckd_build_sense (dev, 0, SENSE1_FP, 0, 0, 0);

  0806e	c6 44 24 28 00	 mov	 BYTE PTR [rsp+40], 0
  08073	c6 44 24 20 00	 mov	 BYTE PTR [rsp+32], 0
  08078	45 33 c9	 xor	 r9d, r9d
  0807b	41 b0 04	 mov	 r8b, 4
  0807e	33 d2		 xor	 edx, edx
  08080	48 8b 8c 24 c0
	03 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  08088	e8 00 00 00 00	 call	 ckd_build_sense

; 5216 :         *unitstat = CSW_CE | CSW_DE | CSW_UC;

  0808d	48 8b 84 24 08
	04 00 00	 mov	 rax, QWORD PTR unitstat$[rsp]
  08095	c6 00 0e	 mov	 BYTE PTR [rax], 14

; 5217 :         break;

  08098	e9 b3 24 00 00	 jmp	 $LN2@ckd_dasd_e
$LN496@ckd_dasd_e:

; 5218 :     }
; 5219 :     /*
; 5220 :      * Bytes 8-12 specify a value to be used as a search argument for
; 5221 :      * the Locate Record Extended search operation.
; 5222 :      *
; 5223 :      * When the operation specified in byte 0 does not require
; 5224 :      * orientation to a specific record, no search operation is
; 5225 :      * performed and bytes 8-12 are ignored. When Home Address
; 5226 :      * orientation is specified, byte 12 is ignored.
; 5227 :      */
; 5228 :     memcpy (cchhr, iobuf+8, 5);

  0809d	48 8d 84 24 48
	02 00 00	 lea	 rax, QWORD PTR cchhr$[rsp]
  080a5	48 8b 8c 24 f8
	03 00 00	 mov	 rcx, QWORD PTR iobuf$[rsp]
  080ad	48 8b f8	 mov	 rdi, rax
  080b0	48 8d 71 08	 lea	 rsi, QWORD PTR [rcx+8]
  080b4	b9 05 00 00 00	 mov	 ecx, 5
  080b9	f3 a4		 rep movsb

; 5229 :     /*
; 5230 :      * Byte 13 contains a sector number to which the device is to be
; 5231 :      * positioned before the Storage Director establishes orientation.
; 5232 :      *
; 5233 :      * The sector number must be within the range of valid sector
; 5234 :      * numbers for the device. If the sector number is invalid, Locate
; 5235 :      * Record Extended is terminated with status that includes unit
; 5236 :      * check (Command Reject, format X'04', Invalid Parameter).
; 5237 :      *
; 5238 :      * A value of X'FF' is valid and specifies that sector positioning
; 5239 :      * is not to be performed prior to establishing orientation.
; 5240 :      */
; 5241 :     if (iobuf[13] != 0xFF && iobuf[13] >= dev->ckdtab->sectors)

  080bb	b8 01 00 00 00	 mov	 eax, 1
  080c0	48 6b c0 0d	 imul	 rax, rax, 13
  080c4	48 8b 8c 24 f8
	03 00 00	 mov	 rcx, QWORD PTR iobuf$[rsp]
  080cc	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  080d0	3d ff 00 00 00	 cmp	 eax, 255		; 000000ffH
  080d5	74 5b		 je	 SHORT $LN499@ckd_dasd_e
  080d7	b8 01 00 00 00	 mov	 eax, 1
  080dc	48 6b c0 0d	 imul	 rax, rax, 13
  080e0	48 8b 8c 24 f8
	03 00 00	 mov	 rcx, QWORD PTR iobuf$[rsp]
  080e8	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  080ec	48 8b 8c 24 c0
	03 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  080f4	48 8b 89 a0 12
	00 00		 mov	 rcx, QWORD PTR [rcx+4768]
  080fb	0f b7 49 1c	 movzx	 ecx, WORD PTR [rcx+28]
  080ff	3b c1		 cmp	 eax, ecx
  08101	7c 2f		 jl	 SHORT $LN499@ckd_dasd_e

; 5242 :     {
; 5243 :         ckd_build_sense (dev, SENSE_CR, 0, 0, FORMAT_0, MESSAGE_4);

  08103	c6 44 24 28 04	 mov	 BYTE PTR [rsp+40], 4
  08108	c6 44 24 20 00	 mov	 BYTE PTR [rsp+32], 0
  0810d	45 33 c9	 xor	 r9d, r9d
  08110	45 33 c0	 xor	 r8d, r8d
  08113	b2 80		 mov	 dl, 128			; 00000080H
  08115	48 8b 8c 24 c0
	03 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  0811d	e8 00 00 00 00	 call	 ckd_build_sense

; 5244 :         *unitstat = CSW_CE | CSW_DE | CSW_UC;

  08122	48 8b 84 24 08
	04 00 00	 mov	 rax, QWORD PTR unitstat$[rsp]
  0812a	c6 00 0e	 mov	 BYTE PTR [rax], 14

; 5245 :         break;

  0812d	e9 1e 24 00 00	 jmp	 $LN2@ckd_dasd_e
$LN499@ckd_dasd_e:

; 5246 :     }
; 5247 :     sector = iobuf[13];

  08132	b8 01 00 00 00	 mov	 eax, 1
  08137	48 6b c0 0d	 imul	 rax, rax, 13
  0813b	48 8b 8c 24 f8
	03 00 00	 mov	 rcx, QWORD PTR iobuf$[rsp]
  08143	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  08147	88 44 24 7c	 mov	 BYTE PTR sector$[rsp], al

; 5248 :     /*
; 5249 :      * When byte 1, bit 0 is '0', bytes 14-15 must contain zeros; if
; 5250 :      * bytes 14-15 are not zero, Locate Record Extended is terminated
; 5251 :      * with status that includes unit check (Command Reject, format
; 5252 :      * X'04', Invalid Parameter).
; 5253 :      *
; 5254 :      * When byte 1 bit 0 is '1', bytes 14-15 contain a Transfer Length
; 5255 :      * Factor (TLF). The Transfer Length Factor must be non-zero; if it
; 5256 :      * is zero, Locate Record Extended is terminated with status that
; 5257 :      * includes unit check (Command Reject, format X'04', Invalid
; 5258 :      * Parameter).
; 5259 :      *
; 5260 :      * If the Transfer Length Factor value is greater than the value
; 5261 :      * specified (or implied) in the Define Extent Blocksize parameter,
; 5262 :      * Locate Record Extended is terminated with status that includes
; 5263 :      * unit check (Command Reject, format X'04', Invalid Parameter).
; 5264 :      *
; 5265 :      * The Storage Director uses the TLF to determine the number of
; 5266 :      * data bytes to be requested from the channel for each write
; 5267 :      * command that follows a Locate Record Extended that specified the
; 5268 :      * Write Data (01) Operation code. The product of the value in
; 5269 :      * bytes 14-15 and the count parameter is used to determine the
; 5270 :      * total number of bytes to be transferred by data transfer commands
; 5271 :      * that are executed within the domain of a Locate Record Extended
; 5272 :      * that specified the Format Write (03), Write Track (0B), or
; 5273 :      * Read (16) Operation codes.
; 5274 :      *
; 5275 :      * The TLF value is not retained by the Storage Director after the
; 5276 :      * expiration of the Locate Record domain.
; 5277 :      *
; 5278 :      * If Locate Record Extended does not specify a Transfer Length
; 5279 :      * Factor, the Storage Director will use the value from the Define
; 5280 :      * Extent Blocksize parameter for any required data transfer length
; 5281 :      * calculation.
; 5282 :      */
; 5283 :     if ((!(dev->ckdlaux & CKDLAUX_TLFVALID) &&  fetch_hw(iobuf+14))
; 5284 :      || ( (dev->ckdlaux & CKDLAUX_TLFVALID) && !fetch_hw(iobuf+14))
; 5285 :      || fetch_hw(iobuf+14) > dev->ckdxblksz)

  0814b	48 8b 84 24 c0
	03 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  08153	0f b6 80 01 13
	00 00		 movzx	 eax, BYTE PTR [rax+4865]
  0815a	25 80 00 00 00	 and	 eax, 128		; 00000080H
  0815f	85 c0		 test	 eax, eax
  08161	75 23		 jne	 SHORT $LN502@ckd_dasd_e
  08163	48 8b 84 24 f8
	03 00 00	 mov	 rax, QWORD PTR iobuf$[rsp]
  0816b	48 83 c0 0e	 add	 rax, 14
  0816f	48 8b c8	 mov	 rcx, rax
  08172	e8 00 00 00 00	 call	 fetch_hw_noswap
  08177	0f b7 c8	 movzx	 ecx, ax
  0817a	e8 00 00 00 00	 call	 _byteswap_ushort
  0817f	0f b7 c0	 movzx	 eax, ax
  08182	85 c0		 test	 eax, eax
  08184	75 6d		 jne	 SHORT $LN501@ckd_dasd_e
$LN502@ckd_dasd_e:
  08186	48 8b 84 24 c0
	03 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  0818e	0f b6 80 01 13
	00 00		 movzx	 eax, BYTE PTR [rax+4865]
  08195	25 80 00 00 00	 and	 eax, 128		; 00000080H
  0819a	85 c0		 test	 eax, eax
  0819c	74 23		 je	 SHORT $LN503@ckd_dasd_e
  0819e	48 8b 84 24 f8
	03 00 00	 mov	 rax, QWORD PTR iobuf$[rsp]
  081a6	48 83 c0 0e	 add	 rax, 14
  081aa	48 8b c8	 mov	 rcx, rax
  081ad	e8 00 00 00 00	 call	 fetch_hw_noswap
  081b2	0f b7 c8	 movzx	 ecx, ax
  081b5	e8 00 00 00 00	 call	 _byteswap_ushort
  081ba	0f b7 c0	 movzx	 eax, ax
  081bd	85 c0		 test	 eax, eax
  081bf	74 32		 je	 SHORT $LN501@ckd_dasd_e
$LN503@ckd_dasd_e:
  081c1	48 8b 84 24 f8
	03 00 00	 mov	 rax, QWORD PTR iobuf$[rsp]
  081c9	48 83 c0 0e	 add	 rax, 14
  081cd	48 8b c8	 mov	 rcx, rax
  081d0	e8 00 00 00 00	 call	 fetch_hw_noswap
  081d5	0f b7 c8	 movzx	 ecx, ax
  081d8	e8 00 00 00 00	 call	 _byteswap_ushort
  081dd	0f b7 c0	 movzx	 eax, ax
  081e0	48 8b 8c 24 c0
	03 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  081e8	0f b7 89 f0 12
	00 00		 movzx	 ecx, WORD PTR [rcx+4848]
  081ef	3b c1		 cmp	 eax, ecx
  081f1	7e 2f		 jle	 SHORT $LN500@ckd_dasd_e
$LN501@ckd_dasd_e:

; 5286 :     {
; 5287 :         ckd_build_sense (dev, SENSE_CR, 0, 0, FORMAT_0, MESSAGE_4);

  081f3	c6 44 24 28 04	 mov	 BYTE PTR [rsp+40], 4
  081f8	c6 44 24 20 00	 mov	 BYTE PTR [rsp+32], 0
  081fd	45 33 c9	 xor	 r9d, r9d
  08200	45 33 c0	 xor	 r8d, r8d
  08203	b2 80		 mov	 dl, 128			; 00000080H
  08205	48 8b 8c 24 c0
	03 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  0820d	e8 00 00 00 00	 call	 ckd_build_sense

; 5288 :         *unitstat = CSW_CE | CSW_DE | CSW_UC;

  08212	48 8b 84 24 08
	04 00 00	 mov	 rax, QWORD PTR unitstat$[rsp]
  0821a	c6 00 0e	 mov	 BYTE PTR [rax], 14

; 5289 :         break;

  0821d	e9 2e 23 00 00	 jmp	 $LN2@ckd_dasd_e
$LN500@ckd_dasd_e:

; 5290 :     }
; 5291 :     if ((dev->ckdlaux & CKDLAUX_TLFVALID) == 0)

  08222	48 8b 84 24 c0
	03 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  0822a	0f b6 80 01 13
	00 00		 movzx	 eax, BYTE PTR [rax+4865]
  08231	25 80 00 00 00	 and	 eax, 128		; 00000080H
  08236	85 c0		 test	 eax, eax
  08238	75 20		 jne	 SHORT $LN504@ckd_dasd_e

; 5292 :         dev->ckdltranlf = dev->ckdxblksz;

  0823a	48 8b 84 24 c0
	03 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  08242	48 8b 8c 24 c0
	03 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  0824a	0f b7 89 f0 12
	00 00		 movzx	 ecx, WORD PTR [rcx+4848]
  08251	66 89 88 fc 12
	00 00		 mov	 WORD PTR [rax+4860], cx
  08258	eb 2b		 jmp	 SHORT $LN505@ckd_dasd_e
$LN504@ckd_dasd_e:

; 5293 :     else
; 5294 :         dev->ckdltranlf = fetch_hw(iobuf+14);

  0825a	48 8b 84 24 f8
	03 00 00	 mov	 rax, QWORD PTR iobuf$[rsp]
  08262	48 83 c0 0e	 add	 rax, 14
  08266	48 8b c8	 mov	 rcx, rax
  08269	e8 00 00 00 00	 call	 fetch_hw_noswap
  0826e	0f b7 c8	 movzx	 ecx, ax
  08271	e8 00 00 00 00	 call	 _byteswap_ushort
  08276	48 8b 8c 24 c0
	03 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  0827e	66 89 81 fc 12
	00 00		 mov	 WORD PTR [rcx+4860], ax
$LN505@ckd_dasd_e:

; 5295 :     /*
; 5296 :      * Bytes 18-19 contain an unsigned 16-bit binary value that
; 5297 :      * specifies the total number of extended parameter bytes. The
; 5298 :      * format and content of the Extended Parameters are defined by
; 5299 :      * the Extended Operation code.
; 5300 :      *
; 5301 :      * The length for 3990 Mod 6 or 9390 for the Extended Operation
; 5302 :      * codes must be consistent with the Extended Operation code in
; 5303 :      * byte 17 as follows:
; 5304 :      *   09  0001
; 5305 :      *   0A  0001
; 5306 :      *   0E  0001 or 0002
; 5307 :      *
; 5308 :      * If the operation code is any code other than those defined, the
; 5309 :      * extended parameter length count must be zero. If these conditions
; 5310 :      * are not met the Locate Record Extended is terminated with status
; 5311 :      * that includes unit check (Command Reject, format X'04', Invalid
; 5312 :      * Parameter).
; 5313 :      */
; 5314 :     num = fetch_hw(iobuf+18);

  08285	48 8b 84 24 f8
	03 00 00	 mov	 rax, QWORD PTR iobuf$[rsp]
  0828d	48 83 c0 12	 add	 rax, 18
  08291	48 8b c8	 mov	 rcx, rax
  08294	e8 00 00 00 00	 call	 fetch_hw_noswap
  08299	0f b7 c8	 movzx	 ecx, ax
  0829c	e8 00 00 00 00	 call	 _byteswap_ushort
  082a1	0f b7 c0	 movzx	 eax, ax
  082a4	89 44 24 64	 mov	 DWORD PTR num$[rsp], eax

; 5315 :     if ((iobuf[17] == CKDOPER_WRTANY &&  num != 1)
; 5316 :      || (iobuf[17] == CKDOPER_RDANY  &&  num != 1)
; 5317 :      || (iobuf[17] == CKDOPER_RDTSET && (num != 1 && num != 2))
; 5318 :      || (iobuf[17] != CKDOPER_WRTANY &&  iobuf[17] != CKDOPER_RDANY

  082a8	b8 01 00 00 00	 mov	 eax, 1
  082ad	48 6b c0 11	 imul	 rax, rax, 17
  082b1	48 8b 8c 24 f8
	03 00 00	 mov	 rcx, QWORD PTR iobuf$[rsp]
  082b9	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  082bd	83 f8 09	 cmp	 eax, 9
  082c0	75 0b		 jne	 SHORT $LN508@ckd_dasd_e
  082c2	83 7c 24 64 01	 cmp	 DWORD PTR num$[rsp], 1
  082c7	0f 85 9e 00 00
	00		 jne	 $LN507@ckd_dasd_e
$LN508@ckd_dasd_e:
  082cd	b8 01 00 00 00	 mov	 eax, 1
  082d2	48 6b c0 11	 imul	 rax, rax, 17
  082d6	48 8b 8c 24 f8
	03 00 00	 mov	 rcx, QWORD PTR iobuf$[rsp]
  082de	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  082e2	83 f8 0a	 cmp	 eax, 10
  082e5	75 07		 jne	 SHORT $LN509@ckd_dasd_e
  082e7	83 7c 24 64 01	 cmp	 DWORD PTR num$[rsp], 1
  082ec	75 7d		 jne	 SHORT $LN507@ckd_dasd_e
$LN509@ckd_dasd_e:
  082ee	b8 01 00 00 00	 mov	 eax, 1
  082f3	48 6b c0 11	 imul	 rax, rax, 17
  082f7	48 8b 8c 24 f8
	03 00 00	 mov	 rcx, QWORD PTR iobuf$[rsp]
  082ff	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  08303	83 f8 0e	 cmp	 eax, 14
  08306	75 0e		 jne	 SHORT $LN510@ckd_dasd_e
  08308	83 7c 24 64 01	 cmp	 DWORD PTR num$[rsp], 1
  0830d	74 07		 je	 SHORT $LN511@ckd_dasd_e
  0830f	83 7c 24 64 02	 cmp	 DWORD PTR num$[rsp], 2
  08314	75 55		 jne	 SHORT $LN507@ckd_dasd_e
$LN511@ckd_dasd_e:
$LN510@ckd_dasd_e:
  08316	b8 01 00 00 00	 mov	 eax, 1
  0831b	48 6b c0 11	 imul	 rax, rax, 17
  0831f	48 8b 8c 24 f8
	03 00 00	 mov	 rcx, QWORD PTR iobuf$[rsp]
  08327	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  0832b	83 f8 09	 cmp	 eax, 9
  0832e	74 6a		 je	 SHORT $LN506@ckd_dasd_e
  08330	b8 01 00 00 00	 mov	 eax, 1
  08335	48 6b c0 11	 imul	 rax, rax, 17
  08339	48 8b 8c 24 f8
	03 00 00	 mov	 rcx, QWORD PTR iobuf$[rsp]
  08341	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  08345	83 f8 0a	 cmp	 eax, 10
  08348	74 50		 je	 SHORT $LN506@ckd_dasd_e
  0834a	b8 01 00 00 00	 mov	 eax, 1
  0834f	48 6b c0 11	 imul	 rax, rax, 17
  08353	48 8b 8c 24 f8
	03 00 00	 mov	 rcx, QWORD PTR iobuf$[rsp]
  0835b	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  0835f	83 f8 0e	 cmp	 eax, 14
  08362	74 36		 je	 SHORT $LN506@ckd_dasd_e
  08364	83 7c 24 64 00	 cmp	 DWORD PTR num$[rsp], 0
  08369	74 2f		 je	 SHORT $LN506@ckd_dasd_e
$LN507@ckd_dasd_e:

; 5319 :       && iobuf[17] != CKDOPER_RDTSET &&  num))
; 5320 :     {
; 5321 :         ckd_build_sense (dev, SENSE_CR, 0, 0, FORMAT_0, MESSAGE_4);

  0836b	c6 44 24 28 04	 mov	 BYTE PTR [rsp+40], 4
  08370	c6 44 24 20 00	 mov	 BYTE PTR [rsp+32], 0
  08375	45 33 c9	 xor	 r9d, r9d
  08378	45 33 c0	 xor	 r8d, r8d
  0837b	b2 80		 mov	 dl, 128			; 00000080H
  0837d	48 8b 8c 24 c0
	03 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  08385	e8 00 00 00 00	 call	 ckd_build_sense

; 5322 :         *unitstat = CSW_CE | CSW_DE | CSW_UC;

  0838a	48 8b 84 24 08
	04 00 00	 mov	 rax, QWORD PTR unitstat$[rsp]
  08392	c6 00 0e	 mov	 BYTE PTR [rax], 14

; 5323 :         break;

  08395	e9 b6 21 00 00	 jmp	 $LN2@ckd_dasd_e
$LN506@ckd_dasd_e:

; 5324 :     }
; 5325 :     /*
; 5326 :      * Request the extended parameter bytes from the channel. If the
; 5327 :      * channel provides fewer bytes, execution is terminated with status
; 5328 :      * that includes unit check (Command Reject, format X'03', CCW byte
; 5329 :      * count less than required).
; 5330 :      */
; 5331 :     if (count < 20 + num)

  0839a	8b 44 24 64	 mov	 eax, DWORD PTR num$[rsp]
  0839e	83 c0 14	 add	 eax, 20
  083a1	39 84 24 e0 03
	00 00		 cmp	 DWORD PTR count$[rsp], eax
  083a8	73 3d		 jae	 SHORT $LN512@ckd_dasd_e

; 5332 :     {
; 5333 :         *residual = 0;

  083aa	48 8b 84 24 10
	04 00 00	 mov	 rax, QWORD PTR residual$[rsp]
  083b2	c7 00 00 00 00
	00		 mov	 DWORD PTR [rax], 0

; 5334 :         ckd_build_sense (dev, SENSE_CR, 0, 0, FORMAT_0, MESSAGE_3);

  083b8	c6 44 24 28 03	 mov	 BYTE PTR [rsp+40], 3
  083bd	c6 44 24 20 00	 mov	 BYTE PTR [rsp+32], 0
  083c2	45 33 c9	 xor	 r9d, r9d
  083c5	45 33 c0	 xor	 r8d, r8d
  083c8	b2 80		 mov	 dl, 128			; 00000080H
  083ca	48 8b 8c 24 c0
	03 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  083d2	e8 00 00 00 00	 call	 ckd_build_sense

; 5335 :         *unitstat = CSW_CE | CSW_DE | CSW_UC;

  083d7	48 8b 84 24 08
	04 00 00	 mov	 rax, QWORD PTR unitstat$[rsp]
  083df	c6 00 0e	 mov	 BYTE PTR [rax], 14

; 5336 :         break;

  083e2	e9 69 21 00 00	 jmp	 $LN2@ckd_dasd_e
$LN512@ckd_dasd_e:

; 5337 :     }
; 5338 :     *residual -= num;

  083e7	48 8b 84 24 10
	04 00 00	 mov	 rax, QWORD PTR residual$[rsp]
  083ef	8b 4c 24 64	 mov	 ecx, DWORD PTR num$[rsp]
  083f3	8b 00		 mov	 eax, DWORD PTR [rax]
  083f5	2b c1		 sub	 eax, ecx
  083f7	48 8b 8c 24 10
	04 00 00	 mov	 rcx, QWORD PTR residual$[rsp]
  083ff	89 01		 mov	 DWORD PTR [rcx], eax

; 5339 :     /*
; 5340 :      * For `Read Any' (0x0A) or `Write Any' (0x09) the extended
; 5341 :      * length must be one and the extended parameter value (set size)
; 5342 :      * must be one.  Otherwise the Locate Record Extended command is
; 5343 :      * terminated with status that includes unit check (Command Reject,
; 5344 :      * format X'04', Invalid Parameter).
; 5345 :      */
; 5346 :     if (num > 0)

  08401	83 7c 24 64 00	 cmp	 DWORD PTR num$[rsp], 0
  08406	76 3c		 jbe	 SHORT $LN513@ckd_dasd_e

; 5347 :         if (iobuf[20] & 0x01)

  08408	b8 01 00 00 00	 mov	 eax, 1
  0840d	48 6b c0 14	 imul	 rax, rax, 20
  08411	48 8b 8c 24 f8
	03 00 00	 mov	 rcx, QWORD PTR iobuf$[rsp]
  08419	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  0841d	83 e0 01	 and	 eax, 1
  08420	85 c0		 test	 eax, eax
  08422	74 20		 je	 SHORT $LN514@ckd_dasd_e

; 5348 :             dev->ckdlaux |= CKDLAUX_RDCNTSUF;

  08424	48 8b 84 24 c0
	03 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  0842c	0f b6 80 01 13
	00 00		 movzx	 eax, BYTE PTR [rax+4865]
  08433	83 c8 01	 or	 eax, 1
  08436	48 8b 8c 24 c0
	03 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  0843e	88 81 01 13 00
	00		 mov	 BYTE PTR [rcx+4865], al
$LN514@ckd_dasd_e:
$LN513@ckd_dasd_e:

; 5349 :     dev->ckdfcoun = 0;

  08444	48 8b 84 24 c0
	03 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  0844c	8b 80 14 13 00
	00		 mov	 eax, DWORD PTR [rax+4884]
  08452	83 e0 ef	 and	 eax, -17		; ffffffefH
  08455	48 8b 8c 24 c0
	03 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  0845d	89 81 14 13 00
	00		 mov	 DWORD PTR [rcx+4884], eax

; 5350 :     memset(dev->ckdfcwrk, 0x00, sizeof(dev->ckdfcwrk));

  08463	48 8b 84 24 c0
	03 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  0846b	48 05 e0 12 00
	00		 add	 rax, 4832		; 000012e0H
  08471	48 8b f8	 mov	 rdi, rax
  08474	33 c0		 xor	 eax, eax
  08476	b9 08 00 00 00	 mov	 ecx, 8
  0847b	f3 aa		 rep stosb

; 5351 :     dev->ckdextcd = iobuf[17];

  0847d	b8 01 00 00 00	 mov	 eax, 1
  08482	48 6b c0 11	 imul	 rax, rax, 17
  08486	48 8b 8c 24 c0
	03 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  0848e	48 8b 94 24 f8
	03 00 00	 mov	 rdx, QWORD PTR iobuf$[rsp]
  08496	0f b6 04 02	 movzx	 eax, BYTE PTR [rdx+rax]
  0849a	88 81 03 13 00
	00		 mov	 BYTE PTR [rcx+4867], al

; 5352 :     if ((iobuf[17] == CKDOPER_WRTANY && iobuf[20] != 1)
; 5353 :      || (iobuf[17] == CKDOPER_RDANY  && iobuf[20] != 1))

  084a0	b8 01 00 00 00	 mov	 eax, 1
  084a5	48 6b c0 11	 imul	 rax, rax, 17
  084a9	48 8b 8c 24 f8
	03 00 00	 mov	 rcx, QWORD PTR iobuf$[rsp]
  084b1	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  084b5	83 f8 09	 cmp	 eax, 9
  084b8	75 1a		 jne	 SHORT $LN517@ckd_dasd_e
  084ba	b8 01 00 00 00	 mov	 eax, 1
  084bf	48 6b c0 14	 imul	 rax, rax, 20
  084c3	48 8b 8c 24 f8
	03 00 00	 mov	 rcx, QWORD PTR iobuf$[rsp]
  084cb	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  084cf	83 f8 01	 cmp	 eax, 1
  084d2	75 34		 jne	 SHORT $LN516@ckd_dasd_e
$LN517@ckd_dasd_e:
  084d4	b8 01 00 00 00	 mov	 eax, 1
  084d9	48 6b c0 11	 imul	 rax, rax, 17
  084dd	48 8b 8c 24 f8
	03 00 00	 mov	 rcx, QWORD PTR iobuf$[rsp]
  084e5	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  084e9	83 f8 0a	 cmp	 eax, 10
  084ec	75 49		 jne	 SHORT $LN515@ckd_dasd_e
  084ee	b8 01 00 00 00	 mov	 eax, 1
  084f3	48 6b c0 14	 imul	 rax, rax, 20
  084f7	48 8b 8c 24 f8
	03 00 00	 mov	 rcx, QWORD PTR iobuf$[rsp]
  084ff	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  08503	83 f8 01	 cmp	 eax, 1
  08506	74 2f		 je	 SHORT $LN515@ckd_dasd_e
$LN516@ckd_dasd_e:

; 5354 :     {
; 5355 :         ckd_build_sense (dev, SENSE_CR, 0, 0, FORMAT_0, MESSAGE_4);

  08508	c6 44 24 28 04	 mov	 BYTE PTR [rsp+40], 4
  0850d	c6 44 24 20 00	 mov	 BYTE PTR [rsp+32], 0
  08512	45 33 c9	 xor	 r9d, r9d
  08515	45 33 c0	 xor	 r8d, r8d
  08518	b2 80		 mov	 dl, 128			; 00000080H
  0851a	48 8b 8c 24 c0
	03 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  08522	e8 00 00 00 00	 call	 ckd_build_sense

; 5356 :         *unitstat = CSW_CE | CSW_DE | CSW_UC;

  08527	48 8b 84 24 08
	04 00 00	 mov	 rax, QWORD PTR unitstat$[rsp]
  0852f	c6 00 0e	 mov	 BYTE PTR [rax], 14

; 5357 :         break;

  08532	e9 19 20 00 00	 jmp	 $LN2@ckd_dasd_e
$LN515@ckd_dasd_e:

; 5358 :     }
; 5359 :     /*
; 5360 :      * Read Trackset - X'0E': The Read Trackset Operation Code prepares
; 5361 :      * the Storage Director to transfer all records from one or more
; 5362 :      * tracks to the channel. The tracks to be transferred are
; 5363 :      * specified by the Extended Parameter and the number of tracks to
; 5364 :      * be transferred is specified by the Count Parameter (byte 3).
; 5365 :      *
; 5366 :      * The maximum length of the Extended Parameter is specified in byte
; 5367 :      * 43 of the Device Characteristics Information.
; 5368 :      *
; 5369 :      * The Extended Parameter contains a bit map that represents a set
; 5370 :      * of sequentially addressed tracks within the defined extent. Each
; 5371 :      * bit in the parameter represent one track. A '1' bit indicates the
; 5372 :      * data associated with the corresponding track is to be read. A '0'
; 5373 :      * bit indicates the track is to be skipped.
; 5374 :      *
; 5375 :      * The first bit must be a '1' and represents the track whose
; 5376 :      * address is specified in the Seek Address parameter (bytes 4-7).
; 5377 :      * Subsequent bits represent consecutively addressed tracks in
; 5378 :      * ascending order. If the first bit is not a '1', the Locate Record
; 5379 :      * Extended command is terminated with status that includes unit
; 5380 :      * check (Command Reject, format X'04', Invalid Parameter).
; 5381 :      *
; 5382 :      * The number of '1' bits in the bit map must be equal to the value
; 5383 :      * in the count parameter (byte 3); otherwise Locate Record Extended
; 5384 :      * is terminated with status that includes unit check (Command
; 5385 :      * Reject, format X'04', Invalid Parameter).
; 5386 :      *
; 5387 :      * All tracks in the bit map represented by the '1' bits must be
; 5388 :      * contained within the defined extent; otherwise the Locate Record
; 5389 :      * Extended command is terminated with status that includes unit
; 5390 :      * check (File Protected).
; 5391 :      *
; 5392 :      * Track access is initiated using the Seek Address and Sector
; 5393 :      * Number parameters.
; 5394 :      *
; 5395 :      * When track access is completed, the search operation specified by
; 5396 :      * the Search Argument and the orientation modifiers (byte 0, bits
; 5397 :      * 0-1) is performed.
; 5398 :      *
; 5399 :      * Locate Record Extended must be followed by the number of Read
; 5400 :      * Track commands specified in the count parameter (byte 3). If any
; 5401 :      * other command sequence is detected within the Locate Record
; 5402 :      * domain, the non-conforming command will be rejected with status
; 5403 :      * that includes Unit Check (Command Reject, format X'02', Invalid
; 5404 :      * Command Sequence).
; 5405 :      */
; 5406 :     if (iobuf[17] == CKDOPER_RDTSET)

  08537	b8 01 00 00 00	 mov	 eax, 1
  0853c	48 6b c0 11	 imul	 rax, rax, 17
  08540	48 8b 8c 24 f8
	03 00 00	 mov	 rcx, QWORD PTR iobuf$[rsp]
  08548	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  0854c	83 f8 0e	 cmp	 eax, 14
  0854f	0f 85 8a 02 00
	00		 jne	 $LN518@ckd_dasd_e

; 5407 :     {
; 5408 :         U16 lastcyl, lasthead;
; 5409 :         U16 mask = iobuf[20] << 8;

  08555	b8 01 00 00 00	 mov	 eax, 1
  0855a	48 6b c0 14	 imul	 rax, rax, 20
  0855e	48 8b 8c 24 f8
	03 00 00	 mov	 rcx, QWORD PTR iobuf$[rsp]
  08566	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  0856a	c1 e0 08	 shl	 eax, 8
  0856d	66 89 44 24 78	 mov	 WORD PTR mask$1[rsp], ax

; 5410 :         if (num > 1)

  08572	83 7c 24 64 01	 cmp	 DWORD PTR num$[rsp], 1
  08577	76 23		 jbe	 SHORT $LN519@ckd_dasd_e

; 5411 :             mask |= iobuf[21];

  08579	b8 01 00 00 00	 mov	 eax, 1
  0857e	48 6b c0 15	 imul	 rax, rax, 21
  08582	48 8b 8c 24 f8
	03 00 00	 mov	 rcx, QWORD PTR iobuf$[rsp]
  0858a	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  0858e	0f b7 4c 24 78	 movzx	 ecx, WORD PTR mask$1[rsp]
  08593	0b c8		 or	 ecx, eax
  08595	8b c1		 mov	 eax, ecx
  08597	66 89 44 24 78	 mov	 WORD PTR mask$1[rsp], ax
$LN519@ckd_dasd_e:

; 5412 :         if (!(mask & 0x8000))

  0859c	0f b7 44 24 78	 movzx	 eax, WORD PTR mask$1[rsp]
  085a1	25 00 80 00 00	 and	 eax, 32768		; 00008000H
  085a6	85 c0		 test	 eax, eax
  085a8	75 2f		 jne	 SHORT $LN520@ckd_dasd_e

; 5413 :         {
; 5414 :             ckd_build_sense (dev, SENSE_CR, 0, 0, FORMAT_0, MESSAGE_4);

  085aa	c6 44 24 28 04	 mov	 BYTE PTR [rsp+40], 4
  085af	c6 44 24 20 00	 mov	 BYTE PTR [rsp+32], 0
  085b4	45 33 c9	 xor	 r9d, r9d
  085b7	45 33 c0	 xor	 r8d, r8d
  085ba	b2 80		 mov	 dl, 128			; 00000080H
  085bc	48 8b 8c 24 c0
	03 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  085c4	e8 00 00 00 00	 call	 ckd_build_sense

; 5415 :             *unitstat = CSW_CE | CSW_DE | CSW_UC;

  085c9	48 8b 84 24 08
	04 00 00	 mov	 rax, QWORD PTR unitstat$[rsp]
  085d1	c6 00 0e	 mov	 BYTE PTR [rax], 14

; 5416 :             break;

  085d4	e9 77 1f 00 00	 jmp	 $LN2@ckd_dasd_e
$LN520@ckd_dasd_e:

; 5417 :         }
; 5418 :         dev->ckdlmask = mask;

  085d9	48 8b 84 24 c0
	03 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  085e1	0f b7 4c 24 78	 movzx	 ecx, WORD PTR mask$1[rsp]
  085e6	66 89 88 fe 12
	00 00		 mov	 WORD PTR [rax+4862], cx

; 5419 :         /*
; 5420 :          * Count the one bits in mask.  There are elegant but obscure
; 5421 :          * ways to do this but just keeping it simple here.  Plus we
; 5422 :          * also figure out the last track we will read.
; 5423 :          */
; 5424 :         for (i = j = 0; mask; mask <<= 1)

  085ed	c7 84 24 a8 00
	00 00 00 00 00
	00		 mov	 DWORD PTR j$[rsp], 0
  085f8	8b 84 24 a8 00
	00 00		 mov	 eax, DWORD PTR j$[rsp]
  085ff	89 84 24 a4 00
	00 00		 mov	 DWORD PTR i$[rsp], eax
  08606	eb 0d		 jmp	 SHORT $LN42@ckd_dasd_e
$LN40@ckd_dasd_e:
  08608	0f b7 44 24 78	 movzx	 eax, WORD PTR mask$1[rsp]
  0860d	66 d1 e0	 shl	 ax, 1
  08610	66 89 44 24 78	 mov	 WORD PTR mask$1[rsp], ax
$LN42@ckd_dasd_e:
  08615	0f b7 44 24 78	 movzx	 eax, WORD PTR mask$1[rsp]
  0861a	85 c0		 test	 eax, eax
  0861c	74 30		 je	 SHORT $LN41@ckd_dasd_e

; 5425 :         {
; 5426 :             j++;

  0861e	8b 84 24 a8 00
	00 00		 mov	 eax, DWORD PTR j$[rsp]
  08625	ff c0		 inc	 eax
  08627	89 84 24 a8 00
	00 00		 mov	 DWORD PTR j$[rsp], eax

; 5427 :             if (mask & 0x8000)

  0862e	0f b7 44 24 78	 movzx	 eax, WORD PTR mask$1[rsp]
  08633	25 00 80 00 00	 and	 eax, 32768		; 00008000H
  08638	85 c0		 test	 eax, eax
  0863a	74 10		 je	 SHORT $LN521@ckd_dasd_e

; 5428 :                 i++;

  0863c	8b 84 24 a4 00
	00 00		 mov	 eax, DWORD PTR i$[rsp]
  08643	ff c0		 inc	 eax
  08645	89 84 24 a4 00
	00 00		 mov	 DWORD PTR i$[rsp], eax
$LN521@ckd_dasd_e:

; 5429 :         }

  0864c	eb ba		 jmp	 SHORT $LN40@ckd_dasd_e
$LN41@ckd_dasd_e:

; 5430 :         /* Number of one bits must match count */
; 5431 :         if (i != dev->ckdlcount)

  0864e	48 8b 84 24 c0
	03 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  08656	0f b6 80 02 13
	00 00		 movzx	 eax, BYTE PTR [rax+4866]
  0865d	39 84 24 a4 00
	00 00		 cmp	 DWORD PTR i$[rsp], eax
  08664	74 2f		 je	 SHORT $LN522@ckd_dasd_e

; 5432 :         {
; 5433 :             ckd_build_sense (dev, SENSE_CR, 0, 0, FORMAT_0, MESSAGE_4);

  08666	c6 44 24 28 04	 mov	 BYTE PTR [rsp+40], 4
  0866b	c6 44 24 20 00	 mov	 BYTE PTR [rsp+32], 0
  08670	45 33 c9	 xor	 r9d, r9d
  08673	45 33 c0	 xor	 r8d, r8d
  08676	b2 80		 mov	 dl, 128			; 00000080H
  08678	48 8b 8c 24 c0
	03 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  08680	e8 00 00 00 00	 call	 ckd_build_sense

; 5434 :             *unitstat = CSW_CE | CSW_DE | CSW_UC;

  08685	48 8b 84 24 08
	04 00 00	 mov	 rax, QWORD PTR unitstat$[rsp]
  0868d	c6 00 0e	 mov	 BYTE PTR [rax], 14

; 5435 :             break;

  08690	e9 bb 1e 00 00	 jmp	 $LN2@ckd_dasd_e
$LN522@ckd_dasd_e:

; 5436 :         }
; 5437 :         /* Check extent of last track to be read */
; 5438 :         lastcyl = cyl;

  08695	0f b7 44 24 6c	 movzx	 eax, WORD PTR cyl$[rsp]
  0869a	66 89 84 24 88
	00 00 00	 mov	 WORD PTR lastcyl$4[rsp], ax

; 5439 :         lasthead = (U16)(head + j - 1);

  086a2	0f b7 44 24 70	 movzx	 eax, WORD PTR head$[rsp]
  086a7	8b 8c 24 a8 00
	00 00		 mov	 ecx, DWORD PTR j$[rsp]
  086ae	8d 44 08 ff	 lea	 eax, DWORD PTR [rax+rcx-1]
  086b2	66 89 84 24 90
	00 00 00	 mov	 WORD PTR lasthead$7[rsp], ax
$LN43@ckd_dasd_e:

; 5440 :         while (lasthead >= dev->ckdheads)

  086ba	0f b7 84 24 90
	00 00 00	 movzx	 eax, WORD PTR lasthead$7[rsp]
  086c2	48 8b 8c 24 c0
	03 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  086ca	3b 81 c0 12 00
	00		 cmp	 eax, DWORD PTR [rcx+4800]
  086d0	7c 38		 jl	 SHORT $LN44@ckd_dasd_e

; 5441 :         {
; 5442 :             lastcyl++;

  086d2	0f b7 84 24 88
	00 00 00	 movzx	 eax, WORD PTR lastcyl$4[rsp]
  086da	66 ff c0	 inc	 ax
  086dd	66 89 84 24 88
	00 00 00	 mov	 WORD PTR lastcyl$4[rsp], ax

; 5443 :             lasthead -= (U16) dev->ckdheads;

  086e5	48 8b 84 24 c0
	03 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  086ed	0f b7 80 c0 12
	00 00		 movzx	 eax, WORD PTR [rax+4800]
  086f4	0f b7 8c 24 90
	00 00 00	 movzx	 ecx, WORD PTR lasthead$7[rsp]
  086fc	2b c8		 sub	 ecx, eax
  086fe	8b c1		 mov	 eax, ecx
  08700	66 89 84 24 90
	00 00 00	 mov	 WORD PTR lasthead$7[rsp], ax

; 5444 :         }

  08708	eb b0		 jmp	 SHORT $LN43@ckd_dasd_e
$LN44@ckd_dasd_e:

; 5445 :         if ( EXTENT_CHECK(dev, lastcyl, lasthead) )

  0870a	0f b7 84 24 88
	00 00 00	 movzx	 eax, WORD PTR lastcyl$4[rsp]
  08712	48 8b 8c 24 c0
	03 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  0871a	0f b7 89 f2 12
	00 00		 movzx	 ecx, WORD PTR [rcx+4850]
  08721	3b c1		 cmp	 eax, ecx
  08723	0f 8c 87 00 00
	00		 jl	 $LN524@ckd_dasd_e
  08729	0f b7 84 24 88
	00 00 00	 movzx	 eax, WORD PTR lastcyl$4[rsp]
  08731	48 8b 8c 24 c0
	03 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  08739	0f b7 89 f6 12
	00 00		 movzx	 ecx, WORD PTR [rcx+4854]
  08740	3b c1		 cmp	 eax, ecx
  08742	7f 6c		 jg	 SHORT $LN524@ckd_dasd_e
  08744	0f b7 84 24 88
	00 00 00	 movzx	 eax, WORD PTR lastcyl$4[rsp]
  0874c	48 8b 8c 24 c0
	03 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  08754	0f b7 89 f2 12
	00 00		 movzx	 ecx, WORD PTR [rcx+4850]
  0875b	3b c1		 cmp	 eax, ecx
  0875d	75 1b		 jne	 SHORT $LN525@ckd_dasd_e
  0875f	0f b7 84 24 90
	00 00 00	 movzx	 eax, WORD PTR lasthead$7[rsp]
  08767	48 8b 8c 24 c0
	03 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  0876f	0f b7 89 f4 12
	00 00		 movzx	 ecx, WORD PTR [rcx+4852]
  08776	3b c1		 cmp	 eax, ecx
  08778	7c 36		 jl	 SHORT $LN524@ckd_dasd_e
$LN525@ckd_dasd_e:
  0877a	0f b7 84 24 88
	00 00 00	 movzx	 eax, WORD PTR lastcyl$4[rsp]
  08782	48 8b 8c 24 c0
	03 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  0878a	0f b7 89 f6 12
	00 00		 movzx	 ecx, WORD PTR [rcx+4854]
  08791	3b c1		 cmp	 eax, ecx
  08793	75 4a		 jne	 SHORT $LN523@ckd_dasd_e
  08795	0f b7 84 24 90
	00 00 00	 movzx	 eax, WORD PTR lasthead$7[rsp]
  0879d	48 8b 8c 24 c0
	03 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  087a5	0f b7 89 f8 12
	00 00		 movzx	 ecx, WORD PTR [rcx+4856]
  087ac	3b c1		 cmp	 eax, ecx
  087ae	7e 2f		 jle	 SHORT $LN523@ckd_dasd_e
$LN524@ckd_dasd_e:

; 5446 :         {
; 5447 :             ckd_build_sense (dev, 0, SENSE1_FP, 0, 0, 0);

  087b0	c6 44 24 28 00	 mov	 BYTE PTR [rsp+40], 0
  087b5	c6 44 24 20 00	 mov	 BYTE PTR [rsp+32], 0
  087ba	45 33 c9	 xor	 r9d, r9d
  087bd	41 b0 04	 mov	 r8b, 4
  087c0	33 d2		 xor	 edx, edx
  087c2	48 8b 8c 24 c0
	03 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  087ca	e8 00 00 00 00	 call	 ckd_build_sense

; 5448 :             *unitstat = CSW_CE | CSW_DE | CSW_UC;

  087cf	48 8b 84 24 08
	04 00 00	 mov	 rax, QWORD PTR unitstat$[rsp]
  087d7	c6 00 0e	 mov	 BYTE PTR [rax], 14

; 5449 :             break;

  087da	e9 71 1d 00 00	 jmp	 $LN2@ckd_dasd_e
$LN523@ckd_dasd_e:
$LN518@ckd_dasd_e:

; 5450 :         }
; 5451 :     }
; 5452 : 
; 5453 :     /* Seek to the required track */
; 5454 :     rc = ckd_seek (dev, cyl, head, &trkhdr, unitstat);

  087df	0f b7 44 24 70	 movzx	 eax, WORD PTR head$[rsp]
  087e4	0f b7 4c 24 6c	 movzx	 ecx, WORD PTR cyl$[rsp]
  087e9	48 8b 94 24 08
	04 00 00	 mov	 rdx, QWORD PTR unitstat$[rsp]
  087f1	48 89 54 24 20	 mov	 QWORD PTR [rsp+32], rdx
  087f6	4c 8d 8c 24 40
	02 00 00	 lea	 r9, QWORD PTR trkhdr$[rsp]
  087fe	44 8b c0	 mov	 r8d, eax
  08801	8b d1		 mov	 edx, ecx
  08803	48 8b 8c 24 c0
	03 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  0880b	e8 00 00 00 00	 call	 ckd_seek
  08810	89 44 24 60	 mov	 DWORD PTR rc$[rsp], eax

; 5455 :     if (rc < 0)

  08814	83 7c 24 60 00	 cmp	 DWORD PTR rc$[rsp], 0
  08819	7d 05		 jge	 SHORT $LN526@ckd_dasd_e

; 5456 :         break;

  0881b	e9 30 1d 00 00	 jmp	 $LN2@ckd_dasd_e
$LN526@ckd_dasd_e:

; 5457 : 
; 5458 :     /* Set normal status */
; 5459 :     *unitstat = CSW_CE | CSW_DE;

  08820	48 8b 84 24 08
	04 00 00	 mov	 rax, QWORD PTR unitstat$[rsp]
  08828	c6 00 0c	 mov	 BYTE PTR [rax], 12

; 5460 : 
; 5461 :     /* Perform search according to specified orientation */
; 5462 :     switch ((dev->ckdloper & CKDOPER_ORIENTATION)) {

  0882b	48 8b 84 24 c0
	03 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  08833	0f b6 80 00 13
	00 00		 movzx	 eax, BYTE PTR [rax+4864]
  0883a	25 c0 00 00 00	 and	 eax, 192		; 000000c0H
  0883f	89 84 24 bc 00
	00 00		 mov	 DWORD PTR tv4385[rsp], eax
  08846	83 bc 24 bc 00
	00 00 00	 cmp	 DWORD PTR tv4385[rsp], 0
  0884e	74 6a		 je	 SHORT $LN529@ckd_dasd_e
  08850	83 bc 24 bc 00
	00 00 40	 cmp	 DWORD PTR tv4385[rsp], 64 ; 00000040H
  08858	74 12		 je	 SHORT $LN527@ckd_dasd_e
  0885a	81 bc 24 bc 00
	00 00 80 00 00
	00		 cmp	 DWORD PTR tv4385[rsp], 128 ; 00000080H
  08865	74 53		 je	 SHORT $LN530@ckd_dasd_e
  08867	e9 4e 01 00 00	 jmp	 $LN45@ckd_dasd_e
$LN527@ckd_dasd_e:

; 5463 : 
; 5464 :     case CKDOPER_ORIENT_HOME:
; 5465 :         /* For home orientation, compare the search CCHH
; 5466 :            with the CCHH in the track header */
; 5467 :         if (memcmp (&(trkhdr.cyl), cchhr, 4) != 0)

  0886c	41 b8 04 00 00
	00		 mov	 r8d, 4
  08872	48 8d 94 24 48
	02 00 00	 lea	 rdx, QWORD PTR cchhr$[rsp]
  0887a	48 8d 8c 24 41
	02 00 00	 lea	 rcx, QWORD PTR trkhdr$[rsp+1]
  08882	e8 00 00 00 00	 call	 memcmp
  08887	85 c0		 test	 eax, eax
  08889	74 2a		 je	 SHORT $LN528@ckd_dasd_e

; 5468 :         {
; 5469 :             ckd_build_sense (dev, 0, SENSE1_NRF, 0, 0, 0);

  0888b	c6 44 24 28 00	 mov	 BYTE PTR [rsp+40], 0
  08890	c6 44 24 20 00	 mov	 BYTE PTR [rsp+32], 0
  08895	45 33 c9	 xor	 r9d, r9d
  08898	41 b0 08	 mov	 r8b, 8
  0889b	33 d2		 xor	 edx, edx
  0889d	48 8b 8c 24 c0
	03 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  088a5	e8 00 00 00 00	 call	 ckd_build_sense

; 5470 :             *unitstat = CSW_CE | CSW_DE | CSW_UC;

  088aa	48 8b 84 24 08
	04 00 00	 mov	 rax, QWORD PTR unitstat$[rsp]
  088b2	c6 00 0e	 mov	 BYTE PTR [rax], 14
$LN528@ckd_dasd_e:

; 5471 :         }
; 5472 :         break;

  088b5	e9 00 01 00 00	 jmp	 $LN45@ckd_dasd_e
$LN529@ckd_dasd_e:
$LN530@ckd_dasd_e:

; 5473 : 
; 5474 :     case CKDOPER_ORIENT_COUNT:
; 5475 :     case CKDOPER_ORIENT_DATA:
; 5476 :         /* For count or data orientation, search the track
; 5477 :            for a count field matching the specified CCHHR */
; 5478 :         memset(binzero, 0x00, 5);

  088ba	48 8d 84 24 50
	02 00 00	 lea	 rax, QWORD PTR binzero$[rsp]
  088c2	48 8b f8	 mov	 rdi, rax
  088c5	33 c0		 xor	 eax, eax
  088c7	b9 05 00 00 00	 mov	 ecx, 5
  088cc	f3 aa		 rep stosb
$LN47@ckd_dasd_e:

; 5479 :         while (1)

  088ce	33 c0		 xor	 eax, eax
  088d0	83 f8 01	 cmp	 eax, 1
  088d3	0f 84 e1 00 00
	00		 je	 $LN48@ckd_dasd_e

; 5480 :         {
; 5481 :             /* Read next count field and exit at end of track
; 5482 :                with sense data indicating no record found */
; 5483 :             rc = ckd_read_count (dev, code, &rechdr, unitstat);

  088d9	4c 8b 8c 24 08
	04 00 00	 mov	 r9, QWORD PTR unitstat$[rsp]
  088e1	4c 8d 84 24 38
	02 00 00	 lea	 r8, QWORD PTR rechdr$[rsp]
  088e9	0f b6 94 24 c8
	03 00 00	 movzx	 edx, BYTE PTR code$[rsp]
  088f1	48 8b 8c 24 c0
	03 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  088f9	e8 00 00 00 00	 call	 ckd_read_count
  088fe	89 44 24 60	 mov	 DWORD PTR rc$[rsp], eax

; 5484 :             if (rc < 0) break;

  08902	83 7c 24 60 00	 cmp	 DWORD PTR rc$[rsp], 0
  08907	7d 05		 jge	 SHORT $LN531@ckd_dasd_e
  08909	e9 ac 00 00 00	 jmp	 $LN48@ckd_dasd_e
$LN531@ckd_dasd_e:

; 5485 : 
; 5486 :             /* Turn off track overflow flag */
; 5487 :             if(dev->ckdcyls < 32768)

  0890e	48 8b 84 24 c0
	03 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  08916	81 b8 b8 12 00
	00 00 80 00 00	 cmp	 DWORD PTR [rax+4792], 32768 ; 00008000H
  08920	7d 24		 jge	 SHORT $LN532@ckd_dasd_e

; 5488 :                 rechdr.cyl[0] &= 0x7F;

  08922	b8 01 00 00 00	 mov	 eax, 1
  08927	48 6b c0 00	 imul	 rax, rax, 0
  0892b	0f b6 84 04 38
	02 00 00	 movzx	 eax, BYTE PTR rechdr$[rsp+rax]
  08933	83 e0 7f	 and	 eax, 127		; 0000007fH
  08936	b9 01 00 00 00	 mov	 ecx, 1
  0893b	48 6b c9 00	 imul	 rcx, rcx, 0
  0893f	88 84 0c 38 02
	00 00		 mov	 BYTE PTR rechdr$[rsp+rcx], al
$LN532@ckd_dasd_e:

; 5489 : 
; 5490 :             /* For extended op code skip r0 */
; 5491 :             if ((iobuf[0] & CKDOPER_CODE) == CKDOPER_EXTOP)

  08946	b8 01 00 00 00	 mov	 eax, 1
  0894b	48 6b c0 00	 imul	 rax, rax, 0
  0894f	48 8b 8c 24 f8
	03 00 00	 mov	 rcx, QWORD PTR iobuf$[rsp]
  08957	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  0895b	83 e0 3f	 and	 eax, 63			; 0000003fH
  0895e	83 f8 3f	 cmp	 eax, 63			; 0000003fH
  08961	75 0e		 jne	 SHORT $LN533@ckd_dasd_e

; 5492 :             {
; 5493 :                 if (rechdr.rec != 0)

  08963	0f b6 84 24 3c
	02 00 00	 movzx	 eax, BYTE PTR rechdr$[rsp+4]
  0896b	85 c0		 test	 eax, eax
  0896d	74 02		 je	 SHORT $LN534@ckd_dasd_e

; 5494 :                     break;

  0896f	eb 49		 jmp	 SHORT $LN48@ckd_dasd_e
$LN534@ckd_dasd_e:
$LN533@ckd_dasd_e:

; 5495 :             }
; 5496 :             if (memcmp(cchhr, binzero, 5) == 0)

  08971	41 b8 05 00 00
	00		 mov	 r8d, 5
  08977	48 8d 94 24 50
	02 00 00	 lea	 rdx, QWORD PTR binzero$[rsp]
  0897f	48 8d 8c 24 48
	02 00 00	 lea	 rcx, QWORD PTR cchhr$[rsp]
  08987	e8 00 00 00 00	 call	 memcmp
  0898c	85 c0		 test	 eax, eax
  0898e	75 04		 jne	 SHORT $LN535@ckd_dasd_e

; 5497 :                 break;

  08990	eb 28		 jmp	 SHORT $LN48@ckd_dasd_e
  08992	eb 21		 jmp	 SHORT $LN536@ckd_dasd_e
$LN535@ckd_dasd_e:

; 5498 :             /* Compare the count field with the search CCHHR */
; 5499 :             else if (memcmp (&rechdr, cchhr, 5) == 0)

  08994	41 b8 05 00 00
	00		 mov	 r8d, 5
  0899a	48 8d 94 24 48
	02 00 00	 lea	 rdx, QWORD PTR cchhr$[rsp]
  089a2	48 8d 8c 24 38
	02 00 00	 lea	 rcx, QWORD PTR rechdr$[rsp]
  089aa	e8 00 00 00 00	 call	 memcmp
  089af	85 c0		 test	 eax, eax
  089b1	75 02		 jne	 SHORT $LN537@ckd_dasd_e

; 5500 :                 break;

  089b3	eb 05		 jmp	 SHORT $LN48@ckd_dasd_e
$LN537@ckd_dasd_e:
$LN536@ckd_dasd_e:

; 5501 :         } /* end while */

  089b5	e9 14 ff ff ff	 jmp	 $LN47@ckd_dasd_e
$LN48@ckd_dasd_e:
$LN45@ckd_dasd_e:

; 5502 :     } /* end switch(CKDOPER_ORIENTATION) */
; 5503 : 
; 5504 :     /* Exit if search ended with error status */
; 5505 :     if (*unitstat != (CSW_CE | CSW_DE))

  089ba	48 8b 84 24 08
	04 00 00	 mov	 rax, QWORD PTR unitstat$[rsp]
  089c2	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  089c5	83 f8 0c	 cmp	 eax, 12
  089c8	74 05		 je	 SHORT $LN538@ckd_dasd_e

; 5506 :         break;

  089ca	e9 81 1b 00 00	 jmp	 $LN2@ckd_dasd_e
$LN538@ckd_dasd_e:

; 5507 : 
; 5508 :     /* Reorient past data if data orientation is specified */
; 5509 :     if ((dev->ckdloper & CKDOPER_ORIENTATION)
; 5510 :                         == CKDOPER_ORIENT_DATA)

  089cf	48 8b 84 24 c0
	03 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  089d7	0f b6 80 00 13
	00 00		 movzx	 eax, BYTE PTR [rax+4864]
  089de	25 c0 00 00 00	 and	 eax, 192		; 000000c0H
  089e3	3d 80 00 00 00	 cmp	 eax, 128		; 00000080H
  089e8	75 60		 jne	 SHORT $LN539@ckd_dasd_e

; 5511 :     {
; 5512 :         /* Skip past key and data fields */
; 5513 :         dev->bufoff += dev->ckdcurkl + dev->ckdcurdl;

  089ea	48 8b 84 24 c0
	03 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  089f2	0f b7 80 ea 12
	00 00		 movzx	 eax, WORD PTR [rax+4842]
  089f9	48 8b 8c 24 c0
	03 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  08a01	8b 89 d4 12 00
	00		 mov	 ecx, DWORD PTR [rcx+4820]
  08a07	03 c8		 add	 ecx, eax
  08a09	8b c1		 mov	 eax, ecx
  08a0b	48 8b 8c 24 c0
	03 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  08a13	03 81 e0 01 00
	00		 add	 eax, DWORD PTR [rcx+480]
  08a19	48 8b 8c 24 c0
	03 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  08a21	89 81 e0 01 00
	00		 mov	 DWORD PTR [rcx+480], eax

; 5514 : 
; 5515 :         /* Set the device orientation fields */
; 5516 :         dev->ckdrem = 0;

  08a27	33 c0		 xor	 eax, eax
  08a29	48 8b 8c 24 c0
	03 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  08a31	66 89 81 ec 12
	00 00		 mov	 WORD PTR [rcx+4844], ax

; 5517 :         dev->ckdorient = CKDORIENT_DATA;

  08a38	48 8b 84 24 c0
	03 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  08a40	c7 80 d8 12 00
	00 04 00 00 00	 mov	 DWORD PTR [rax+4824], 4
$LN539@ckd_dasd_e:

; 5518 :     }
; 5519 : 
; 5520 :     /* Set locate record flag and return normal status */
; 5521 :     dev->ckdlocat = 1;

  08a4a	48 8b 84 24 c0
	03 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  08a52	8b 80 14 13 00
	00		 mov	 eax, DWORD PTR [rax+4884]
  08a58	83 c8 08	 or	 eax, 8
  08a5b	48 8b 8c 24 c0
	03 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  08a63	89 81 14 13 00
	00		 mov	 DWORD PTR [rcx+4884], eax

; 5522 :     break;

  08a69	e9 e2 1a 00 00	 jmp	 $LN2@ckd_dasd_e
$LN540@ckd_dasd_e:

; 5523 : 
; 5524 :     case 0x63:
; 5525 :     /*---------------------------------------------------------------*/
; 5526 :     /* DEFINE EXTENT                                                 */
; 5527 :     /*---------------------------------------------------------------*/
; 5528 :     {
; 5529 :     U16 bcyl, bhead, ecyl, ehead, xblksz;
; 5530 :     BYTE fmask, xgattr;
; 5531 : 
; 5532 :         /* Calculate residual byte count */
; 5533 :         num = (count < 16) ? count : 16;

  08a6e	83 bc 24 e0 03
	00 00 10	 cmp	 DWORD PTR count$[rsp], 16
  08a76	73 10		 jae	 SHORT $LN747@ckd_dasd_e
  08a78	8b 84 24 e0 03
	00 00		 mov	 eax, DWORD PTR count$[rsp]
  08a7f	89 84 24 a0 01
	00 00		 mov	 DWORD PTR tv4462[rsp], eax
  08a86	eb 0b		 jmp	 SHORT $LN748@ckd_dasd_e
$LN747@ckd_dasd_e:
  08a88	c7 84 24 a0 01
	00 00 10 00 00
	00		 mov	 DWORD PTR tv4462[rsp], 16
$LN748@ckd_dasd_e:
  08a93	8b 84 24 a0 01
	00 00		 mov	 eax, DWORD PTR tv4462[rsp]
  08a9a	89 44 24 64	 mov	 DWORD PTR num$[rsp], eax

; 5534 :         *residual = count - num;

  08a9e	8b 44 24 64	 mov	 eax, DWORD PTR num$[rsp]
  08aa2	8b 8c 24 e0 03
	00 00		 mov	 ecx, DWORD PTR count$[rsp]
  08aa9	2b c8		 sub	 ecx, eax
  08aab	8b c1		 mov	 eax, ecx
  08aad	48 8b 8c 24 10
	04 00 00	 mov	 rcx, QWORD PTR residual$[rsp]
  08ab5	89 01		 mov	 DWORD PTR [rcx], eax

; 5535 : 
; 5536 :         /* Control information length must be at least 16 bytes */
; 5537 :         if (count < 16)

  08ab7	83 bc 24 e0 03
	00 00 10	 cmp	 DWORD PTR count$[rsp], 16
  08abf	73 2f		 jae	 SHORT $LN541@ckd_dasd_e

; 5538 :         {
; 5539 :             ckd_build_sense (dev, SENSE_CR, 0, 0,

  08ac1	c6 44 24 28 03	 mov	 BYTE PTR [rsp+40], 3
  08ac6	c6 44 24 20 00	 mov	 BYTE PTR [rsp+32], 0
  08acb	45 33 c9	 xor	 r9d, r9d
  08ace	45 33 c0	 xor	 r8d, r8d
  08ad1	b2 80		 mov	 dl, 128			; 00000080H
  08ad3	48 8b 8c 24 c0
	03 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  08adb	e8 00 00 00 00	 call	 ckd_build_sense

; 5540 :                             FORMAT_0, MESSAGE_3);
; 5541 :             *unitstat = CSW_CE | CSW_DE | CSW_UC;

  08ae0	48 8b 84 24 08
	04 00 00	 mov	 rax, QWORD PTR unitstat$[rsp]
  08ae8	c6 00 0e	 mov	 BYTE PTR [rax], 14

; 5542 :             break;

  08aeb	e9 60 1a 00 00	 jmp	 $LN2@ckd_dasd_e
$LN541@ckd_dasd_e:

; 5543 :         }
; 5544 : 
; 5545 :         /* Command reject if within the domain of a Locate Record, or
; 5546 :            preceded by Define Extent, Space Count, or Set File Mask,
; 5547 :            or (for 3390 only) preceded by Read IPL */
; 5548 :         if (dev->ckdlcount > 0
; 5549 : #if 0
; 5550 :             || dev->ckdxtdef
; 5551 : #endif
; 5552 :             || dev->ckdsetfm || dev->ckdspcnt
; 5553 :             || (dev->ckdrdipl && dev->devtype == 0x3390))

  08af0	48 8b 84 24 c0
	03 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  08af8	0f b6 80 02 13
	00 00		 movzx	 eax, BYTE PTR [rax+4866]
  08aff	85 c0		 test	 eax, eax
  08b01	7f 5b		 jg	 SHORT $LN543@ckd_dasd_e
  08b03	48 8b 84 24 c0
	03 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  08b0b	8b 80 14 13 00
	00		 mov	 eax, DWORD PTR [rax+4884]
  08b11	c1 e8 02	 shr	 eax, 2
  08b14	83 e0 01	 and	 eax, 1
  08b17	85 c0		 test	 eax, eax
  08b19	75 43		 jne	 SHORT $LN543@ckd_dasd_e
  08b1b	48 8b 84 24 c0
	03 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  08b23	8b 80 14 13 00
	00		 mov	 eax, DWORD PTR [rax+4884]
  08b29	c1 e8 05	 shr	 eax, 5
  08b2c	83 e0 01	 and	 eax, 1
  08b2f	85 c0		 test	 eax, eax
  08b31	75 2b		 jne	 SHORT $LN543@ckd_dasd_e
  08b33	48 8b 84 24 c0
	03 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  08b3b	8b 80 14 13 00
	00		 mov	 eax, DWORD PTR [rax+4884]
  08b41	c1 e8 09	 shr	 eax, 9
  08b44	83 e0 01	 and	 eax, 1
  08b47	85 c0		 test	 eax, eax
  08b49	74 42		 je	 SHORT $LN542@ckd_dasd_e
  08b4b	48 8b 84 24 c0
	03 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  08b53	0f b7 40 4a	 movzx	 eax, WORD PTR [rax+74]
  08b57	3d 90 33 00 00	 cmp	 eax, 13200		; 00003390H
  08b5c	75 2f		 jne	 SHORT $LN542@ckd_dasd_e
$LN543@ckd_dasd_e:

; 5554 :         {
; 5555 :             ckd_build_sense (dev, SENSE_CR, 0, 0,

  08b5e	c6 44 24 28 02	 mov	 BYTE PTR [rsp+40], 2
  08b63	c6 44 24 20 00	 mov	 BYTE PTR [rsp+32], 0
  08b68	45 33 c9	 xor	 r9d, r9d
  08b6b	45 33 c0	 xor	 r8d, r8d
  08b6e	b2 80		 mov	 dl, 128			; 00000080H
  08b70	48 8b 8c 24 c0
	03 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  08b78	e8 00 00 00 00	 call	 ckd_build_sense

; 5556 :                             FORMAT_0, MESSAGE_2);
; 5557 :             *unitstat = CSW_CE | CSW_DE | CSW_UC;

  08b7d	48 8b 84 24 08
	04 00 00	 mov	 rax, QWORD PTR unitstat$[rsp]
  08b85	c6 00 0e	 mov	 BYTE PTR [rax], 14

; 5558 :             break;

  08b88	e9 c3 19 00 00	 jmp	 $LN2@ckd_dasd_e
$LN542@ckd_dasd_e:

; 5559 :         }
; 5560 : 
; 5561 :         /* Bytes 0-1 contain the file mask and global attributes */
; 5562 :         fmask = iobuf[0];

  08b8d	b8 01 00 00 00	 mov	 eax, 1
  08b92	48 6b c0 00	 imul	 rax, rax, 0
  08b96	48 8b 8c 24 f8
	03 00 00	 mov	 rcx, QWORD PTR iobuf$[rsp]
  08b9e	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  08ba2	88 84 24 8c 00
	00 00		 mov	 BYTE PTR fmask$5[rsp], al

; 5563 :         xgattr = iobuf[1];

  08ba9	b8 01 00 00 00	 mov	 eax, 1
  08bae	48 6b c0 01	 imul	 rax, rax, 1
  08bb2	48 8b 8c 24 f8
	03 00 00	 mov	 rcx, QWORD PTR iobuf$[rsp]
  08bba	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  08bbe	88 84 24 8d 00
	00 00		 mov	 BYTE PTR xgattr$6[rsp], al

; 5564 : 
; 5565 :         if(dev->ckdxtdef
; 5566 :          && (dev->ckdfmask != fmask || dev->ckdxgattr != xgattr) )

  08bc5	48 8b 84 24 c0
	03 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  08bcd	8b 80 14 13 00
	00		 mov	 eax, DWORD PTR [rax+4884]
  08bd3	d1 e8		 shr	 eax, 1
  08bd5	83 e0 01	 and	 eax, 1
  08bd8	85 c0		 test	 eax, eax
  08bda	74 65		 je	 SHORT $LN544@ckd_dasd_e
  08bdc	48 8b 84 24 c0
	03 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  08be4	0f b6 80 fa 12
	00 00		 movzx	 eax, BYTE PTR [rax+4858]
  08beb	0f b6 8c 24 8c
	00 00 00	 movzx	 ecx, BYTE PTR fmask$5[rsp]
  08bf3	3b c1		 cmp	 eax, ecx
  08bf5	75 1b		 jne	 SHORT $LN545@ckd_dasd_e
  08bf7	48 8b 84 24 c0
	03 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  08bff	0f b6 80 fb 12
	00 00		 movzx	 eax, BYTE PTR [rax+4859]
  08c06	0f b6 8c 24 8d
	00 00 00	 movzx	 ecx, BYTE PTR xgattr$6[rsp]
  08c0e	3b c1		 cmp	 eax, ecx
  08c10	74 2f		 je	 SHORT $LN544@ckd_dasd_e
$LN545@ckd_dasd_e:

; 5567 :         {
; 5568 :             ckd_build_sense (dev, SENSE_CR, 0, 0,

  08c12	c6 44 24 28 02	 mov	 BYTE PTR [rsp+40], 2
  08c17	c6 44 24 20 00	 mov	 BYTE PTR [rsp+32], 0
  08c1c	45 33 c9	 xor	 r9d, r9d
  08c1f	45 33 c0	 xor	 r8d, r8d
  08c22	b2 80		 mov	 dl, 128			; 00000080H
  08c24	48 8b 8c 24 c0
	03 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  08c2c	e8 00 00 00 00	 call	 ckd_build_sense

; 5569 :                             FORMAT_0, MESSAGE_2);
; 5570 :             *unitstat = CSW_CE | CSW_DE | CSW_UC;

  08c31	48 8b 84 24 08
	04 00 00	 mov	 rax, QWORD PTR unitstat$[rsp]
  08c39	c6 00 0e	 mov	 BYTE PTR [rax], 14

; 5571 :             break;

  08c3c	e9 0f 19 00 00	 jmp	 $LN2@ckd_dasd_e
$LN544@ckd_dasd_e:

; 5572 :         }
; 5573 : 
; 5574 :         dev->ckdfmask = fmask;

  08c41	48 8b 84 24 c0
	03 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  08c49	0f b6 8c 24 8c
	00 00 00	 movzx	 ecx, BYTE PTR fmask$5[rsp]
  08c51	88 88 fa 12 00
	00		 mov	 BYTE PTR [rax+4858], cl

; 5575 :         dev->ckdxgattr = xgattr;

  08c57	48 8b 84 24 c0
	03 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  08c5f	0f b6 8c 24 8d
	00 00 00	 movzx	 ecx, BYTE PTR xgattr$6[rsp]
  08c67	88 88 fb 12 00
	00		 mov	 BYTE PTR [rax+4859], cl

; 5576 : 
; 5577 :         /* Validate the global attributes byte bits 0-1 */
; 5578 :         if ((dev->ckdxgattr & CKDGATR_ARCH) != CKDGATR_ARCH_ECKD)

  08c6d	48 8b 84 24 c0
	03 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  08c75	0f b6 80 fb 12
	00 00		 movzx	 eax, BYTE PTR [rax+4859]
  08c7c	25 c0 00 00 00	 and	 eax, 192		; 000000c0H
  08c81	3d c0 00 00 00	 cmp	 eax, 192		; 000000c0H
  08c86	74 2f		 je	 SHORT $LN546@ckd_dasd_e

; 5579 :         {
; 5580 :             ckd_build_sense (dev, SENSE_CR, 0, 0,

  08c88	c6 44 24 28 04	 mov	 BYTE PTR [rsp+40], 4
  08c8d	c6 44 24 20 00	 mov	 BYTE PTR [rsp+32], 0
  08c92	45 33 c9	 xor	 r9d, r9d
  08c95	45 33 c0	 xor	 r8d, r8d
  08c98	b2 80		 mov	 dl, 128			; 00000080H
  08c9a	48 8b 8c 24 c0
	03 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  08ca2	e8 00 00 00 00	 call	 ckd_build_sense

; 5581 :                             FORMAT_0, MESSAGE_4);
; 5582 :             *unitstat = CSW_CE | CSW_DE | CSW_UC;

  08ca7	48 8b 84 24 08
	04 00 00	 mov	 rax, QWORD PTR unitstat$[rsp]
  08caf	c6 00 0e	 mov	 BYTE PTR [rax], 14

; 5583 :             break;

  08cb2	e9 99 18 00 00	 jmp	 $LN2@ckd_dasd_e
$LN546@ckd_dasd_e:

; 5584 :         }
; 5585 : 
; 5586 :         /* Validate the file mask */
; 5587 :         if ((dev->ckdfmask & CKDMASK_RESV) != 0)

  08cb7	48 8b 84 24 c0
	03 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  08cbf	0f b6 80 fa 12
	00 00		 movzx	 eax, BYTE PTR [rax+4858]
  08cc6	83 e0 20	 and	 eax, 32			; 00000020H
  08cc9	85 c0		 test	 eax, eax
  08ccb	74 2f		 je	 SHORT $LN547@ckd_dasd_e

; 5588 :         {
; 5589 :             ckd_build_sense (dev, SENSE_CR, 0, 0,

  08ccd	c6 44 24 28 04	 mov	 BYTE PTR [rsp+40], 4
  08cd2	c6 44 24 20 00	 mov	 BYTE PTR [rsp+32], 0
  08cd7	45 33 c9	 xor	 r9d, r9d
  08cda	45 33 c0	 xor	 r8d, r8d
  08cdd	b2 80		 mov	 dl, 128			; 00000080H
  08cdf	48 8b 8c 24 c0
	03 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  08ce7	e8 00 00 00 00	 call	 ckd_build_sense

; 5590 :                             FORMAT_0, MESSAGE_4);
; 5591 :             *unitstat = CSW_CE | CSW_DE | CSW_UC;

  08cec	48 8b 84 24 08
	04 00 00	 mov	 rax, QWORD PTR unitstat$[rsp]
  08cf4	c6 00 0e	 mov	 BYTE PTR [rax], 14

; 5592 :             break;

  08cf7	e9 54 18 00 00	 jmp	 $LN2@ckd_dasd_e
$LN547@ckd_dasd_e:

; 5593 :         }
; 5594 : 
; 5595 :         /* Bytes 2-3 contain the extent block size */
; 5596 :         xblksz = (iobuf[2] << 8) | iobuf[3];

  08cfc	b8 01 00 00 00	 mov	 eax, 1
  08d01	48 6b c0 02	 imul	 rax, rax, 2
  08d05	48 8b 8c 24 f8
	03 00 00	 mov	 rcx, QWORD PTR iobuf$[rsp]
  08d0d	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  08d11	c1 e0 08	 shl	 eax, 8
  08d14	b9 01 00 00 00	 mov	 ecx, 1
  08d19	48 6b c9 03	 imul	 rcx, rcx, 3
  08d1d	48 8b 94 24 f8
	03 00 00	 mov	 rdx, QWORD PTR iobuf$[rsp]
  08d25	0f b6 0c 0a	 movzx	 ecx, BYTE PTR [rdx+rcx]
  08d29	0b c1		 or	 eax, ecx
  08d2b	66 89 84 24 98
	00 00 00	 mov	 WORD PTR xblksz$9[rsp], ax

; 5597 : 
; 5598 :         /* If extent block size is zero then use the maximum R0
; 5599 :            record length (as returned in device characteristics
; 5600 :            bytes 44 and 45) plus 8 */
; 5601 :         if (xblksz == 0)

  08d33	0f b7 84 24 98
	00 00 00	 movzx	 eax, WORD PTR xblksz$9[rsp]
  08d3b	85 c0		 test	 eax, eax
  08d3d	75 1e		 jne	 SHORT $LN548@ckd_dasd_e

; 5602 :             xblksz = dev->ckdtab->r0 + 8;

  08d3f	48 8b 84 24 c0
	03 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  08d47	48 8b 80 a0 12
	00 00		 mov	 rax, QWORD PTR [rax+4768]
  08d4e	0f b7 40 14	 movzx	 eax, WORD PTR [rax+20]
  08d52	83 c0 08	 add	 eax, 8
  08d55	66 89 84 24 98
	00 00 00	 mov	 WORD PTR xblksz$9[rsp], ax
$LN548@ckd_dasd_e:

; 5603 : 
; 5604 :         if (dev->ckdxtdef
; 5605 :          && dev->ckdxblksz != xblksz )

  08d5d	48 8b 84 24 c0
	03 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  08d65	8b 80 14 13 00
	00		 mov	 eax, DWORD PTR [rax+4884]
  08d6b	d1 e8		 shr	 eax, 1
  08d6d	83 e0 01	 and	 eax, 1
  08d70	85 c0		 test	 eax, eax
  08d72	74 4a		 je	 SHORT $LN549@ckd_dasd_e
  08d74	48 8b 84 24 c0
	03 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  08d7c	0f b7 80 f0 12
	00 00		 movzx	 eax, WORD PTR [rax+4848]
  08d83	0f b7 8c 24 98
	00 00 00	 movzx	 ecx, WORD PTR xblksz$9[rsp]
  08d8b	3b c1		 cmp	 eax, ecx
  08d8d	74 2f		 je	 SHORT $LN549@ckd_dasd_e

; 5606 :         {
; 5607 :             ckd_build_sense (dev, SENSE_CR, 0, 0,

  08d8f	c6 44 24 28 02	 mov	 BYTE PTR [rsp+40], 2
  08d94	c6 44 24 20 00	 mov	 BYTE PTR [rsp+32], 0
  08d99	45 33 c9	 xor	 r9d, r9d
  08d9c	45 33 c0	 xor	 r8d, r8d
  08d9f	b2 80		 mov	 dl, 128			; 00000080H
  08da1	48 8b 8c 24 c0
	03 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  08da9	e8 00 00 00 00	 call	 ckd_build_sense

; 5608 :                             FORMAT_0, MESSAGE_2);
; 5609 :             *unitstat = CSW_CE | CSW_DE | CSW_UC;

  08dae	48 8b 84 24 08
	04 00 00	 mov	 rax, QWORD PTR unitstat$[rsp]
  08db6	c6 00 0e	 mov	 BYTE PTR [rax], 14

; 5610 :             break;

  08db9	e9 92 17 00 00	 jmp	 $LN2@ckd_dasd_e
$LN549@ckd_dasd_e:

; 5611 :         }
; 5612 : 
; 5613 :         dev->ckdxblksz = xblksz;

  08dbe	48 8b 84 24 c0
	03 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  08dc6	0f b7 8c 24 98
	00 00 00	 movzx	 ecx, WORD PTR xblksz$9[rsp]
  08dce	66 89 88 f0 12
	00 00		 mov	 WORD PTR [rax+4848], cx

; 5614 : 
; 5615 :         /* Validate the extent block */
; 5616 :         if (dev->ckdxblksz > dev->ckdtab->r0 + 8)

  08dd5	48 8b 84 24 c0
	03 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  08ddd	0f b7 80 f0 12
	00 00		 movzx	 eax, WORD PTR [rax+4848]
  08de4	48 8b 8c 24 c0
	03 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  08dec	48 8b 89 a0 12
	00 00		 mov	 rcx, QWORD PTR [rcx+4768]
  08df3	0f b7 49 14	 movzx	 ecx, WORD PTR [rcx+20]
  08df7	83 c1 08	 add	 ecx, 8
  08dfa	3b c1		 cmp	 eax, ecx
  08dfc	7e 2f		 jle	 SHORT $LN550@ckd_dasd_e

; 5617 :         {
; 5618 :             ckd_build_sense (dev, SENSE_CR, 0, 0,

  08dfe	c6 44 24 28 04	 mov	 BYTE PTR [rsp+40], 4
  08e03	c6 44 24 20 00	 mov	 BYTE PTR [rsp+32], 0
  08e08	45 33 c9	 xor	 r9d, r9d
  08e0b	45 33 c0	 xor	 r8d, r8d
  08e0e	b2 80		 mov	 dl, 128			; 00000080H
  08e10	48 8b 8c 24 c0
	03 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  08e18	e8 00 00 00 00	 call	 ckd_build_sense

; 5619 :                             FORMAT_0, MESSAGE_4);
; 5620 :             *unitstat = CSW_CE | CSW_DE | CSW_UC;

  08e1d	48 8b 84 24 08
	04 00 00	 mov	 rax, QWORD PTR unitstat$[rsp]
  08e25	c6 00 0e	 mov	 BYTE PTR [rax], 14

; 5621 :             break;

  08e28	e9 23 17 00 00	 jmp	 $LN2@ckd_dasd_e
$LN550@ckd_dasd_e:

; 5622 :         }
; 5623 : 
; 5624 :         /* Bytes 4-6 must contain zeroes */
; 5625 :         if (iobuf[4] != 0 || iobuf[5] != 0 || iobuf[6] != 0)

  08e2d	b8 01 00 00 00	 mov	 eax, 1
  08e32	48 6b c0 04	 imul	 rax, rax, 4
  08e36	48 8b 8c 24 f8
	03 00 00	 mov	 rcx, QWORD PTR iobuf$[rsp]
  08e3e	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  08e42	85 c0		 test	 eax, eax
  08e44	75 32		 jne	 SHORT $LN552@ckd_dasd_e
  08e46	b8 01 00 00 00	 mov	 eax, 1
  08e4b	48 6b c0 05	 imul	 rax, rax, 5
  08e4f	48 8b 8c 24 f8
	03 00 00	 mov	 rcx, QWORD PTR iobuf$[rsp]
  08e57	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  08e5b	85 c0		 test	 eax, eax
  08e5d	75 19		 jne	 SHORT $LN552@ckd_dasd_e
  08e5f	b8 01 00 00 00	 mov	 eax, 1
  08e64	48 6b c0 06	 imul	 rax, rax, 6
  08e68	48 8b 8c 24 f8
	03 00 00	 mov	 rcx, QWORD PTR iobuf$[rsp]
  08e70	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  08e74	85 c0		 test	 eax, eax
  08e76	74 2f		 je	 SHORT $LN551@ckd_dasd_e
$LN552@ckd_dasd_e:

; 5626 :         {
; 5627 :             ckd_build_sense (dev, SENSE_CR, 0, 0,

  08e78	c6 44 24 28 04	 mov	 BYTE PTR [rsp+40], 4
  08e7d	c6 44 24 20 00	 mov	 BYTE PTR [rsp+32], 0
  08e82	45 33 c9	 xor	 r9d, r9d
  08e85	45 33 c0	 xor	 r8d, r8d
  08e88	b2 80		 mov	 dl, 128			; 00000080H
  08e8a	48 8b 8c 24 c0
	03 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  08e92	e8 00 00 00 00	 call	 ckd_build_sense

; 5628 :                             FORMAT_0, MESSAGE_4);
; 5629 :             *unitstat = CSW_CE | CSW_DE | CSW_UC;

  08e97	48 8b 84 24 08
	04 00 00	 mov	 rax, QWORD PTR unitstat$[rsp]
  08e9f	c6 00 0e	 mov	 BYTE PTR [rax], 14

; 5630 :             break;

  08ea2	e9 a9 16 00 00	 jmp	 $LN2@ckd_dasd_e
$LN551@ckd_dasd_e:

; 5631 :         }
; 5632 : 
; 5633 :         /* Bytes 8-11 contain the extent begin cylinder and head */
; 5634 :         bcyl = (iobuf[8] << 8) | iobuf[9];

  08ea7	b8 01 00 00 00	 mov	 eax, 1
  08eac	48 6b c0 08	 imul	 rax, rax, 8
  08eb0	48 8b 8c 24 f8
	03 00 00	 mov	 rcx, QWORD PTR iobuf$[rsp]
  08eb8	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  08ebc	c1 e0 08	 shl	 eax, 8
  08ebf	b9 01 00 00 00	 mov	 ecx, 1
  08ec4	48 6b c9 09	 imul	 rcx, rcx, 9
  08ec8	48 8b 94 24 f8
	03 00 00	 mov	 rdx, QWORD PTR iobuf$[rsp]
  08ed0	0f b6 0c 0a	 movzx	 ecx, BYTE PTR [rdx+rcx]
  08ed4	0b c1		 or	 eax, ecx
  08ed6	66 89 84 24 80
	00 00 00	 mov	 WORD PTR bcyl$2[rsp], ax

; 5635 :         bhead = (iobuf[10] << 8) | iobuf[11];

  08ede	b8 01 00 00 00	 mov	 eax, 1
  08ee3	48 6b c0 0a	 imul	 rax, rax, 10
  08ee7	48 8b 8c 24 f8
	03 00 00	 mov	 rcx, QWORD PTR iobuf$[rsp]
  08eef	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  08ef3	c1 e0 08	 shl	 eax, 8
  08ef6	b9 01 00 00 00	 mov	 ecx, 1
  08efb	48 6b c9 0b	 imul	 rcx, rcx, 11
  08eff	48 8b 94 24 f8
	03 00 00	 mov	 rdx, QWORD PTR iobuf$[rsp]
  08f07	0f b6 0c 0a	 movzx	 ecx, BYTE PTR [rdx+rcx]
  08f0b	0b c1		 or	 eax, ecx
  08f0d	66 89 84 24 9c
	00 00 00	 mov	 WORD PTR bhead$10[rsp], ax

; 5636 : 
; 5637 :         /* Bytes 12-15 contain the extent end cylinder and head */
; 5638 :         ecyl = (iobuf[12] << 8) | iobuf[13];

  08f15	b8 01 00 00 00	 mov	 eax, 1
  08f1a	48 6b c0 0c	 imul	 rax, rax, 12
  08f1e	48 8b 8c 24 f8
	03 00 00	 mov	 rcx, QWORD PTR iobuf$[rsp]
  08f26	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  08f2a	c1 e0 08	 shl	 eax, 8
  08f2d	b9 01 00 00 00	 mov	 ecx, 1
  08f32	48 6b c9 0d	 imul	 rcx, rcx, 13
  08f36	48 8b 94 24 f8
	03 00 00	 mov	 rdx, QWORD PTR iobuf$[rsp]
  08f3e	0f b6 0c 0a	 movzx	 ecx, BYTE PTR [rdx+rcx]
  08f42	0b c1		 or	 eax, ecx
  08f44	66 89 84 24 84
	00 00 00	 mov	 WORD PTR ecyl$3[rsp], ax

; 5639 :         ehead = (iobuf[14] << 8) | iobuf[15];

  08f4c	b8 01 00 00 00	 mov	 eax, 1
  08f51	48 6b c0 0e	 imul	 rax, rax, 14
  08f55	48 8b 8c 24 f8
	03 00 00	 mov	 rcx, QWORD PTR iobuf$[rsp]
  08f5d	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  08f61	c1 e0 08	 shl	 eax, 8
  08f64	b9 01 00 00 00	 mov	 ecx, 1
  08f69	48 6b c9 0f	 imul	 rcx, rcx, 15
  08f6d	48 8b 94 24 f8
	03 00 00	 mov	 rdx, QWORD PTR iobuf$[rsp]
  08f75	0f b6 0c 0a	 movzx	 ecx, BYTE PTR [rdx+rcx]
  08f79	0b c1		 or	 eax, ecx
  08f7b	66 89 84 24 a0
	00 00 00	 mov	 WORD PTR ehead$11[rsp], ax

; 5640 : 
; 5641 :         /* Validate the extent description by checking that the
; 5642 :            ending track is not less than the starting track and
; 5643 :            that the extent does not exceed the already defined extent */
; 5644 :         if ( bcyl > ecyl
; 5645 :             || (bcyl == ecyl && bhead > ehead)
; 5646 :             || EXTENT_CHECK(dev, bcyl, bhead)
; 5647 :             || EXTENT_CHECK(dev, ecyl, ehead) )

  08f83	0f b7 84 24 80
	00 00 00	 movzx	 eax, WORD PTR bcyl$2[rsp]
  08f8b	0f b7 8c 24 84
	00 00 00	 movzx	 ecx, WORD PTR ecyl$3[rsp]
  08f93	3b c1		 cmp	 eax, ecx
  08f95	0f 8f 88 01 00
	00		 jg	 $LN554@ckd_dasd_e
  08f9b	0f b7 84 24 80
	00 00 00	 movzx	 eax, WORD PTR bcyl$2[rsp]
  08fa3	0f b7 8c 24 84
	00 00 00	 movzx	 ecx, WORD PTR ecyl$3[rsp]
  08fab	3b c1		 cmp	 eax, ecx
  08fad	75 18		 jne	 SHORT $LN555@ckd_dasd_e
  08faf	0f b7 84 24 9c
	00 00 00	 movzx	 eax, WORD PTR bhead$10[rsp]
  08fb7	0f b7 8c 24 a0
	00 00 00	 movzx	 ecx, WORD PTR ehead$11[rsp]
  08fbf	3b c1		 cmp	 eax, ecx
  08fc1	0f 8f 5c 01 00
	00		 jg	 $LN554@ckd_dasd_e
$LN555@ckd_dasd_e:
  08fc7	0f b7 84 24 80
	00 00 00	 movzx	 eax, WORD PTR bcyl$2[rsp]
  08fcf	48 8b 8c 24 c0
	03 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  08fd7	0f b7 89 f2 12
	00 00		 movzx	 ecx, WORD PTR [rcx+4850]
  08fde	3b c1		 cmp	 eax, ecx
  08fe0	0f 8c 3d 01 00
	00		 jl	 $LN554@ckd_dasd_e
  08fe6	0f b7 84 24 80
	00 00 00	 movzx	 eax, WORD PTR bcyl$2[rsp]
  08fee	48 8b 8c 24 c0
	03 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  08ff6	0f b7 89 f6 12
	00 00		 movzx	 ecx, WORD PTR [rcx+4854]
  08ffd	3b c1		 cmp	 eax, ecx
  08fff	0f 8f 1e 01 00
	00		 jg	 $LN554@ckd_dasd_e
  09005	0f b7 84 24 80
	00 00 00	 movzx	 eax, WORD PTR bcyl$2[rsp]
  0900d	48 8b 8c 24 c0
	03 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  09015	0f b7 89 f2 12
	00 00		 movzx	 ecx, WORD PTR [rcx+4850]
  0901c	3b c1		 cmp	 eax, ecx
  0901e	75 1f		 jne	 SHORT $LN556@ckd_dasd_e
  09020	0f b7 84 24 9c
	00 00 00	 movzx	 eax, WORD PTR bhead$10[rsp]
  09028	48 8b 8c 24 c0
	03 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  09030	0f b7 89 f4 12
	00 00		 movzx	 ecx, WORD PTR [rcx+4852]
  09037	3b c1		 cmp	 eax, ecx
  09039	0f 8c e4 00 00
	00		 jl	 $LN554@ckd_dasd_e
$LN556@ckd_dasd_e:
  0903f	0f b7 84 24 80
	00 00 00	 movzx	 eax, WORD PTR bcyl$2[rsp]
  09047	48 8b 8c 24 c0
	03 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  0904f	0f b7 89 f6 12
	00 00		 movzx	 ecx, WORD PTR [rcx+4854]
  09056	3b c1		 cmp	 eax, ecx
  09058	75 1f		 jne	 SHORT $LN557@ckd_dasd_e
  0905a	0f b7 84 24 9c
	00 00 00	 movzx	 eax, WORD PTR bhead$10[rsp]
  09062	48 8b 8c 24 c0
	03 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  0906a	0f b7 89 f8 12
	00 00		 movzx	 ecx, WORD PTR [rcx+4856]
  09071	3b c1		 cmp	 eax, ecx
  09073	0f 8f aa 00 00
	00		 jg	 $LN554@ckd_dasd_e
$LN557@ckd_dasd_e:
  09079	0f b7 84 24 84
	00 00 00	 movzx	 eax, WORD PTR ecyl$3[rsp]
  09081	48 8b 8c 24 c0
	03 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  09089	0f b7 89 f2 12
	00 00		 movzx	 ecx, WORD PTR [rcx+4850]
  09090	3b c1		 cmp	 eax, ecx
  09092	0f 8c 8b 00 00
	00		 jl	 $LN558@ckd_dasd_e
  09098	0f b7 84 24 84
	00 00 00	 movzx	 eax, WORD PTR ecyl$3[rsp]
  090a0	48 8b 8c 24 c0
	03 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  090a8	0f b7 89 f6 12
	00 00		 movzx	 ecx, WORD PTR [rcx+4854]
  090af	3b c1		 cmp	 eax, ecx
  090b1	7f 70		 jg	 SHORT $LN558@ckd_dasd_e
  090b3	0f b7 84 24 84
	00 00 00	 movzx	 eax, WORD PTR ecyl$3[rsp]
  090bb	48 8b 8c 24 c0
	03 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  090c3	0f b7 89 f2 12
	00 00		 movzx	 ecx, WORD PTR [rcx+4850]
  090ca	3b c1		 cmp	 eax, ecx
  090cc	75 1b		 jne	 SHORT $LN559@ckd_dasd_e
  090ce	0f b7 84 24 a0
	00 00 00	 movzx	 eax, WORD PTR ehead$11[rsp]
  090d6	48 8b 8c 24 c0
	03 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  090de	0f b7 89 f4 12
	00 00		 movzx	 ecx, WORD PTR [rcx+4852]
  090e5	3b c1		 cmp	 eax, ecx
  090e7	7c 3a		 jl	 SHORT $LN558@ckd_dasd_e
$LN559@ckd_dasd_e:
  090e9	0f b7 84 24 84
	00 00 00	 movzx	 eax, WORD PTR ecyl$3[rsp]
  090f1	48 8b 8c 24 c0
	03 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  090f9	0f b7 89 f6 12
	00 00		 movzx	 ecx, WORD PTR [rcx+4854]
  09100	3b c1		 cmp	 eax, ecx
  09102	0f 85 80 00 00
	00		 jne	 $LN553@ckd_dasd_e
  09108	0f b7 84 24 a0
	00 00 00	 movzx	 eax, WORD PTR ehead$11[rsp]
  09110	48 8b 8c 24 c0
	03 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  09118	0f b7 89 f8 12
	00 00		 movzx	 ecx, WORD PTR [rcx+4856]
  0911f	3b c1		 cmp	 eax, ecx
  09121	7e 65		 jle	 SHORT $LN553@ckd_dasd_e
$LN558@ckd_dasd_e:
$LN554@ckd_dasd_e:

; 5648 :         {
; 5649 :             ckd_build_sense (dev, SENSE_CR, 0, 0,

  09123	48 8b 84 24 c0
	03 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  0912b	8b 80 14 13 00
	00		 mov	 eax, DWORD PTR [rax+4884]
  09131	d1 e8		 shr	 eax, 1
  09133	83 e0 01	 and	 eax, 1
  09136	85 c0		 test	 eax, eax
  09138	74 0d		 je	 SHORT $LN749@ckd_dasd_e
  0913a	c7 84 24 a4 01
	00 00 02 00 00
	00		 mov	 DWORD PTR tv4698[rsp], 2
  09145	eb 0b		 jmp	 SHORT $LN750@ckd_dasd_e
$LN749@ckd_dasd_e:
  09147	c7 84 24 a4 01
	00 00 04 00 00
	00		 mov	 DWORD PTR tv4698[rsp], 4
$LN750@ckd_dasd_e:
  09152	0f b6 84 24 a4
	01 00 00	 movzx	 eax, BYTE PTR tv4698[rsp]
  0915a	88 44 24 28	 mov	 BYTE PTR [rsp+40], al
  0915e	c6 44 24 20 00	 mov	 BYTE PTR [rsp+32], 0
  09163	45 33 c9	 xor	 r9d, r9d
  09166	45 33 c0	 xor	 r8d, r8d
  09169	b2 80		 mov	 dl, 128			; 00000080H
  0916b	48 8b 8c 24 c0
	03 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  09173	e8 00 00 00 00	 call	 ckd_build_sense

; 5650 :                             FORMAT_0, dev->ckdxtdef ? MESSAGE_2 : MESSAGE_4);
; 5651 :             *unitstat = CSW_CE | CSW_DE | CSW_UC;

  09178	48 8b 84 24 08
	04 00 00	 mov	 rax, QWORD PTR unitstat$[rsp]
  09180	c6 00 0e	 mov	 BYTE PTR [rax], 14

; 5652 :             break;

  09183	e9 c8 13 00 00	 jmp	 $LN2@ckd_dasd_e
$LN553@ckd_dasd_e:

; 5653 :         }
; 5654 : 
; 5655 :         /* Define the new extent */
; 5656 :         dev->ckdxbcyl = bcyl;

  09188	48 8b 84 24 c0
	03 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  09190	0f b7 8c 24 80
	00 00 00	 movzx	 ecx, WORD PTR bcyl$2[rsp]
  09198	66 89 88 f2 12
	00 00		 mov	 WORD PTR [rax+4850], cx

; 5657 :         dev->ckdxbhead = bhead;

  0919f	48 8b 84 24 c0
	03 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  091a7	0f b7 8c 24 9c
	00 00 00	 movzx	 ecx, WORD PTR bhead$10[rsp]
  091af	66 89 88 f4 12
	00 00		 mov	 WORD PTR [rax+4852], cx

; 5658 :         dev->ckdxecyl = ecyl;

  091b6	48 8b 84 24 c0
	03 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  091be	0f b7 8c 24 84
	00 00 00	 movzx	 ecx, WORD PTR ecyl$3[rsp]
  091c6	66 89 88 f6 12
	00 00		 mov	 WORD PTR [rax+4854], cx

; 5659 :         dev->ckdxehead = ehead;

  091cd	48 8b 84 24 c0
	03 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  091d5	0f b7 8c 24 a0
	00 00 00	 movzx	 ecx, WORD PTR ehead$11[rsp]
  091dd	66 89 88 f8 12
	00 00		 mov	 WORD PTR [rax+4856], cx

; 5660 : 
; 5661 :         /* Set extent defined flag and return normal status */
; 5662 :         dev->ckdxtdef = 1;

  091e4	48 8b 84 24 c0
	03 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  091ec	8b 80 14 13 00
	00		 mov	 eax, DWORD PTR [rax+4884]
  091f2	83 c8 02	 or	 eax, 2
  091f5	48 8b 8c 24 c0
	03 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  091fd	89 81 14 13 00
	00		 mov	 DWORD PTR [rcx+4884], eax

; 5663 :         *unitstat = CSW_CE | CSW_DE;

  09203	48 8b 84 24 08
	04 00 00	 mov	 rax, QWORD PTR unitstat$[rsp]
  0920b	c6 00 0c	 mov	 BYTE PTR [rax], 12

; 5664 :         break;

  0920e	e9 3d 13 00 00	 jmp	 $LN2@ckd_dasd_e
$LN560@ckd_dasd_e:

; 5665 :     }
; 5666 : 
; 5667 :     case 0x64:
; 5668 :     /*---------------------------------------------------------------*/
; 5669 :     /* READ DEVICE CHARACTERISTICS                                   */
; 5670 :     /*---------------------------------------------------------------*/
; 5671 :         /* Command reject if within the domain of a Locate Record */
; 5672 :         if (dev->ckdlcount > 0)

  09213	48 8b 84 24 c0
	03 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  0921b	0f b6 80 02 13
	00 00		 movzx	 eax, BYTE PTR [rax+4866]
  09222	85 c0		 test	 eax, eax
  09224	7e 2f		 jle	 SHORT $LN561@ckd_dasd_e

; 5673 :         {
; 5674 :             ckd_build_sense (dev, SENSE_CR, 0, 0,

  09226	c6 44 24 28 02	 mov	 BYTE PTR [rsp+40], 2
  0922b	c6 44 24 20 00	 mov	 BYTE PTR [rsp+32], 0
  09230	45 33 c9	 xor	 r9d, r9d
  09233	45 33 c0	 xor	 r8d, r8d
  09236	b2 80		 mov	 dl, 128			; 00000080H
  09238	48 8b 8c 24 c0
	03 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  09240	e8 00 00 00 00	 call	 ckd_build_sense

; 5675 :                             FORMAT_0, MESSAGE_2);
; 5676 :             *unitstat = CSW_CE | CSW_DE | CSW_UC;

  09245	48 8b 84 24 08
	04 00 00	 mov	 rax, QWORD PTR unitstat$[rsp]
  0924d	c6 00 0e	 mov	 BYTE PTR [rax], 14

; 5677 :             break;

  09250	e9 fb 12 00 00	 jmp	 $LN2@ckd_dasd_e
$LN561@ckd_dasd_e:

; 5678 :         }
; 5679 : 
; 5680 :         /* Command reject if not 3380 or 3390 or 9345 */
; 5681 :         if ((dev->devtype != 0x3380)
; 5682 :          && (dev->devtype != 0x3390)
; 5683 :          && (dev->devtype != 0x9345))

  09255	48 8b 84 24 c0
	03 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  0925d	0f b7 40 4a	 movzx	 eax, WORD PTR [rax+74]
  09261	3d 80 33 00 00	 cmp	 eax, 13184		; 00003380H
  09266	74 55		 je	 SHORT $LN562@ckd_dasd_e
  09268	48 8b 84 24 c0
	03 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  09270	0f b7 40 4a	 movzx	 eax, WORD PTR [rax+74]
  09274	3d 90 33 00 00	 cmp	 eax, 13200		; 00003390H
  09279	74 42		 je	 SHORT $LN562@ckd_dasd_e
  0927b	48 8b 84 24 c0
	03 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  09283	0f b7 40 4a	 movzx	 eax, WORD PTR [rax+74]
  09287	3d 45 93 00 00	 cmp	 eax, 37701		; 00009345H
  0928c	74 2f		 je	 SHORT $LN562@ckd_dasd_e

; 5684 :         {
; 5685 :             ckd_build_sense (dev, SENSE_CR, 0, 0,

  0928e	c6 44 24 28 02	 mov	 BYTE PTR [rsp+40], 2
  09293	c6 44 24 20 00	 mov	 BYTE PTR [rsp+32], 0
  09298	45 33 c9	 xor	 r9d, r9d
  0929b	45 33 c0	 xor	 r8d, r8d
  0929e	b2 80		 mov	 dl, 128			; 00000080H
  092a0	48 8b 8c 24 c0
	03 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  092a8	e8 00 00 00 00	 call	 ckd_build_sense

; 5686 :                             FORMAT_0, MESSAGE_2);
; 5687 :             *unitstat = CSW_CE | CSW_DE | CSW_UC;

  092ad	48 8b 84 24 08
	04 00 00	 mov	 rax, QWORD PTR unitstat$[rsp]
  092b5	c6 00 0e	 mov	 BYTE PTR [rax], 14

; 5688 :             break;

  092b8	e9 93 12 00 00	 jmp	 $LN2@ckd_dasd_e
$LN562@ckd_dasd_e:

; 5689 :         }
; 5690 : 
; 5691 :         /* Calculate residual byte count */
; 5692 :         num = (count < dev->numdevchar) ? count : dev->numdevchar;

  092bd	48 8b 84 24 c0
	03 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  092c5	8b 80 68 05 00
	00		 mov	 eax, DWORD PTR [rax+1384]
  092cb	39 84 24 e0 03
	00 00		 cmp	 DWORD PTR count$[rsp], eax
  092d2	73 10		 jae	 SHORT $LN751@ckd_dasd_e
  092d4	8b 84 24 e0 03
	00 00		 mov	 eax, DWORD PTR count$[rsp]
  092db	89 84 24 a8 01
	00 00		 mov	 DWORD PTR tv4740[rsp], eax
  092e2	eb 15		 jmp	 SHORT $LN752@ckd_dasd_e
$LN751@ckd_dasd_e:
  092e4	48 8b 84 24 c0
	03 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  092ec	8b 80 68 05 00
	00		 mov	 eax, DWORD PTR [rax+1384]
  092f2	89 84 24 a8 01
	00 00		 mov	 DWORD PTR tv4740[rsp], eax
$LN752@ckd_dasd_e:
  092f9	8b 84 24 a8 01
	00 00		 mov	 eax, DWORD PTR tv4740[rsp]
  09300	89 44 24 64	 mov	 DWORD PTR num$[rsp], eax

; 5693 :         *residual = count - num;

  09304	8b 44 24 64	 mov	 eax, DWORD PTR num$[rsp]
  09308	8b 8c 24 e0 03
	00 00		 mov	 ecx, DWORD PTR count$[rsp]
  0930f	2b c8		 sub	 ecx, eax
  09311	8b c1		 mov	 eax, ecx
  09313	48 8b 8c 24 10
	04 00 00	 mov	 rcx, QWORD PTR residual$[rsp]
  0931b	89 01		 mov	 DWORD PTR [rcx], eax

; 5694 :         if (count < dev->numdevchar) *more = 1;

  0931d	48 8b 84 24 c0
	03 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  09325	8b 80 68 05 00
	00		 mov	 eax, DWORD PTR [rax+1384]
  0932b	39 84 24 e0 03
	00 00		 cmp	 DWORD PTR count$[rsp], eax
  09332	73 0b		 jae	 SHORT $LN563@ckd_dasd_e
  09334	48 8b 84 24 00
	04 00 00	 mov	 rax, QWORD PTR more$[rsp]
  0933c	c6 00 01	 mov	 BYTE PTR [rax], 1
$LN563@ckd_dasd_e:

; 5695 : 
; 5696 :         /* Copy device characteristics bytes to channel buffer */
; 5697 :         memcpy (iobuf, dev->devchar, num);

  0933f	8b 44 24 64	 mov	 eax, DWORD PTR num$[rsp]
  09343	48 8b 8c 24 c0
	03 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  0934b	48 81 c1 6c 05
	00 00		 add	 rcx, 1388		; 0000056cH
  09352	48 8b bc 24 f8
	03 00 00	 mov	 rdi, QWORD PTR iobuf$[rsp]
  0935a	48 8b f1	 mov	 rsi, rcx
  0935d	8b c8		 mov	 ecx, eax
  0935f	f3 a4		 rep movsb

; 5698 : 
; 5699 :         *unitstat = CSW_CE | CSW_DE;

  09361	48 8b 84 24 08
	04 00 00	 mov	 rax, QWORD PTR unitstat$[rsp]
  09369	c6 00 0c	 mov	 BYTE PTR [rax], 12

; 5700 :         break;

  0936c	e9 df 11 00 00	 jmp	 $LN2@ckd_dasd_e
$LN564@ckd_dasd_e:

; 5701 : 
; 5702 :     case 0x3E:
; 5703 :     /*---------------------------------------------------------------*/
; 5704 :     /* READ SUBSYSTEM DATA                                           */
; 5705 :     /*---------------------------------------------------------------*/
; 5706 :         /* Command reject if within the domain of a Locate Record,
; 5707 :            or if subsystem data has not been prepared in the channel
; 5708 :            buffer by a previous Perform Subsystem Function command */
; 5709 :         if (dev->ckdlcount > 0 || dev->ckdssdlen == 0)

  09371	48 8b 84 24 c0
	03 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  09379	0f b6 80 02 13
	00 00		 movzx	 eax, BYTE PTR [rax+4866]
  09380	85 c0		 test	 eax, eax
  09382	7f 13		 jg	 SHORT $LN566@ckd_dasd_e
  09384	48 8b 84 24 c0
	03 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  0938c	0f b7 80 1a 13
	00 00		 movzx	 eax, WORD PTR [rax+4890]
  09393	85 c0		 test	 eax, eax
  09395	75 2f		 jne	 SHORT $LN565@ckd_dasd_e
$LN566@ckd_dasd_e:

; 5710 :         {
; 5711 :             ckd_build_sense (dev, SENSE_CR, 0, 0,

  09397	c6 44 24 28 02	 mov	 BYTE PTR [rsp+40], 2
  0939c	c6 44 24 20 00	 mov	 BYTE PTR [rsp+32], 0
  093a1	45 33 c9	 xor	 r9d, r9d
  093a4	45 33 c0	 xor	 r8d, r8d
  093a7	b2 80		 mov	 dl, 128			; 00000080H
  093a9	48 8b 8c 24 c0
	03 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  093b1	e8 00 00 00 00	 call	 ckd_build_sense

; 5712 :                             FORMAT_0, MESSAGE_2);
; 5713 :             *unitstat = CSW_CE | CSW_DE | CSW_UC;

  093b6	48 8b 84 24 08
	04 00 00	 mov	 rax, QWORD PTR unitstat$[rsp]
  093be	c6 00 0e	 mov	 BYTE PTR [rax], 14

; 5714 :             break;

  093c1	e9 8a 11 00 00	 jmp	 $LN2@ckd_dasd_e
$LN565@ckd_dasd_e:

; 5715 :         }
; 5716 : 
; 5717 :         /* Calculate residual byte count */
; 5718 :         num = (count < dev->ckdssdlen) ? count : dev->ckdssdlen;

  093c6	48 8b 84 24 c0
	03 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  093ce	0f b7 80 1a 13
	00 00		 movzx	 eax, WORD PTR [rax+4890]
  093d5	39 84 24 e0 03
	00 00		 cmp	 DWORD PTR count$[rsp], eax
  093dc	73 10		 jae	 SHORT $LN753@ckd_dasd_e
  093de	8b 84 24 e0 03
	00 00		 mov	 eax, DWORD PTR count$[rsp]
  093e5	89 84 24 ac 01
	00 00		 mov	 DWORD PTR tv4768[rsp], eax
  093ec	eb 16		 jmp	 SHORT $LN754@ckd_dasd_e
$LN753@ckd_dasd_e:
  093ee	48 8b 84 24 c0
	03 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  093f6	0f b7 80 1a 13
	00 00		 movzx	 eax, WORD PTR [rax+4890]
  093fd	89 84 24 ac 01
	00 00		 mov	 DWORD PTR tv4768[rsp], eax
$LN754@ckd_dasd_e:
  09404	8b 84 24 ac 01
	00 00		 mov	 eax, DWORD PTR tv4768[rsp]
  0940b	89 44 24 64	 mov	 DWORD PTR num$[rsp], eax

; 5719 :         *residual = count - num;

  0940f	8b 44 24 64	 mov	 eax, DWORD PTR num$[rsp]
  09413	8b 8c 24 e0 03
	00 00		 mov	 ecx, DWORD PTR count$[rsp]
  0941a	2b c8		 sub	 ecx, eax
  0941c	8b c1		 mov	 eax, ecx
  0941e	48 8b 8c 24 10
	04 00 00	 mov	 rcx, QWORD PTR residual$[rsp]
  09426	89 01		 mov	 DWORD PTR [rcx], eax

; 5720 :         if (count < dev->ckdssdlen) *more = 1;

  09428	48 8b 84 24 c0
	03 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  09430	0f b7 80 1a 13
	00 00		 movzx	 eax, WORD PTR [rax+4890]
  09437	39 84 24 e0 03
	00 00		 cmp	 DWORD PTR count$[rsp], eax
  0943e	73 0b		 jae	 SHORT $LN567@ckd_dasd_e
  09440	48 8b 84 24 00
	04 00 00	 mov	 rax, QWORD PTR more$[rsp]
  09448	c6 00 01	 mov	 BYTE PTR [rax], 1
$LN567@ckd_dasd_e:

; 5721 : 
; 5722 :         /* Subsystem data is already in the channel buffer, so
; 5723 :            just return channel end and device end */
; 5724 :         *unitstat = CSW_CE | CSW_DE;

  0944b	48 8b 84 24 08
	04 00 00	 mov	 rax, QWORD PTR unitstat$[rsp]
  09453	c6 00 0c	 mov	 BYTE PTR [rax], 12

; 5725 :         break;

  09456	e9 f5 10 00 00	 jmp	 $LN2@ckd_dasd_e
$LN568@ckd_dasd_e:

; 5726 : 
; 5727 :     case 0x5B:
; 5728 :     /*---------------------------------------------------------------*/
; 5729 :     /* SUSPEND MULTIPATH RECONNECTION                                */
; 5730 :     /*---------------------------------------------------------------*/
; 5731 :         /* Command reject if within the domain of a Locate Record */
; 5732 :         if (dev->ckdlcount > 0)

  0945b	48 8b 84 24 c0
	03 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  09463	0f b6 80 02 13
	00 00		 movzx	 eax, BYTE PTR [rax+4866]
  0946a	85 c0		 test	 eax, eax
  0946c	7e 2f		 jle	 SHORT $LN569@ckd_dasd_e

; 5733 :         {
; 5734 :             ckd_build_sense (dev, SENSE_CR, 0, 0,

  0946e	c6 44 24 28 02	 mov	 BYTE PTR [rsp+40], 2
  09473	c6 44 24 20 00	 mov	 BYTE PTR [rsp+32], 0
  09478	45 33 c9	 xor	 r9d, r9d
  0947b	45 33 c0	 xor	 r8d, r8d
  0947e	b2 80		 mov	 dl, 128			; 00000080H
  09480	48 8b 8c 24 c0
	03 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  09488	e8 00 00 00 00	 call	 ckd_build_sense

; 5735 :                             FORMAT_0, MESSAGE_2);
; 5736 :             *unitstat = CSW_CE | CSW_DE | CSW_UC;

  0948d	48 8b 84 24 08
	04 00 00	 mov	 rax, QWORD PTR unitstat$[rsp]
  09495	c6 00 0e	 mov	 BYTE PTR [rax], 14

; 5737 :             break;

  09498	e9 b3 10 00 00	 jmp	 $LN2@ckd_dasd_e
$LN569@ckd_dasd_e:

; 5738 :         }
; 5739 : 
; 5740 :         /* Return normal status */
; 5741 :         *unitstat = CSW_CE | CSW_DE;

  0949d	48 8b 84 24 08
	04 00 00	 mov	 rax, QWORD PTR unitstat$[rsp]
  094a5	c6 00 0c	 mov	 BYTE PTR [rax], 12

; 5742 :         break;

  094a8	e9 a3 10 00 00	 jmp	 $LN2@ckd_dasd_e
$LN570@ckd_dasd_e:

; 5743 : 
; 5744 :     case 0xF3:
; 5745 :     /*---------------------------------------------------------------*/
; 5746 :     /* DIAGNOSTIC CONTROL                                            */
; 5747 :     /*---------------------------------------------------------------*/
; 5748 :         /* Command reject if SSI active */
; 5749 :         if(dev->ckdssi)

  094ad	48 8b 84 24 c0
	03 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  094b5	8b 80 14 13 00
	00		 mov	 eax, DWORD PTR [rax+4884]
  094bb	c1 e8 10	 shr	 eax, 16
  094be	83 e0 01	 and	 eax, 1
  094c1	85 c0		 test	 eax, eax
  094c3	74 4f		 je	 SHORT $LN571@ckd_dasd_e

; 5750 :         {
; 5751 :             /* Mark Set Special Intercept inactive */
; 5752 :             dev->ckdssi = 0;

  094c5	48 8b 84 24 c0
	03 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  094cd	8b 80 14 13 00
	00		 mov	 eax, DWORD PTR [rax+4884]
  094d3	0f ba f0 10	 btr	 eax, 16
  094d7	48 8b 8c 24 c0
	03 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  094df	89 81 14 13 00
	00		 mov	 DWORD PTR [rcx+4884], eax

; 5753 :             ckd_build_sense (dev, SENSE_CR, 0, 0,

  094e5	c6 44 24 28 0f	 mov	 BYTE PTR [rsp+40], 15
  094ea	c6 44 24 20 00	 mov	 BYTE PTR [rsp+32], 0
  094ef	45 33 c9	 xor	 r9d, r9d
  094f2	45 33 c0	 xor	 r8d, r8d
  094f5	b2 80		 mov	 dl, 128			; 00000080H
  094f7	48 8b 8c 24 c0
	03 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  094ff	e8 00 00 00 00	 call	 ckd_build_sense

; 5754 :                             FORMAT_0, MESSAGE_F);
; 5755 :             *unitstat = CSW_CE | CSW_DE | CSW_UC;

  09504	48 8b 84 24 08
	04 00 00	 mov	 rax, QWORD PTR unitstat$[rsp]
  0950c	c6 00 0e	 mov	 BYTE PTR [rax], 14

; 5756 :             break;

  0950f	e9 3c 10 00 00	 jmp	 $LN2@ckd_dasd_e
$LN571@ckd_dasd_e:

; 5757 :         }
; 5758 : 
; 5759 :         /* Calculate residual byte count */
; 5760 :         num = (count < 4) ? count : 4;

  09514	83 bc 24 e0 03
	00 00 04	 cmp	 DWORD PTR count$[rsp], 4
  0951c	73 10		 jae	 SHORT $LN755@ckd_dasd_e
  0951e	8b 84 24 e0 03
	00 00		 mov	 eax, DWORD PTR count$[rsp]
  09525	89 84 24 b0 01
	00 00		 mov	 DWORD PTR tv4796[rsp], eax
  0952c	eb 0b		 jmp	 SHORT $LN756@ckd_dasd_e
$LN755@ckd_dasd_e:
  0952e	c7 84 24 b0 01
	00 00 04 00 00
	00		 mov	 DWORD PTR tv4796[rsp], 4
$LN756@ckd_dasd_e:
  09539	8b 84 24 b0 01
	00 00		 mov	 eax, DWORD PTR tv4796[rsp]
  09540	89 44 24 64	 mov	 DWORD PTR num$[rsp], eax

; 5761 :         *residual = count - num;

  09544	8b 44 24 64	 mov	 eax, DWORD PTR num$[rsp]
  09548	8b 8c 24 e0 03
	00 00		 mov	 ecx, DWORD PTR count$[rsp]
  0954f	2b c8		 sub	 ecx, eax
  09551	8b c1		 mov	 eax, ecx
  09553	48 8b 8c 24 10
	04 00 00	 mov	 rcx, QWORD PTR residual$[rsp]
  0955b	89 01		 mov	 DWORD PTR [rcx], eax

; 5762 : 
; 5763 :         /* Control information length must be at least 4 bytes */
; 5764 :         if (count < 4)

  0955d	83 bc 24 e0 03
	00 00 04	 cmp	 DWORD PTR count$[rsp], 4
  09565	73 2f		 jae	 SHORT $LN572@ckd_dasd_e

; 5765 :         {
; 5766 :             ckd_build_sense (dev, SENSE_CR, 0, 0,

  09567	c6 44 24 28 03	 mov	 BYTE PTR [rsp+40], 3
  0956c	c6 44 24 20 00	 mov	 BYTE PTR [rsp+32], 0
  09571	45 33 c9	 xor	 r9d, r9d
  09574	45 33 c0	 xor	 r8d, r8d
  09577	b2 80		 mov	 dl, 128			; 00000080H
  09579	48 8b 8c 24 c0
	03 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  09581	e8 00 00 00 00	 call	 ckd_build_sense

; 5767 :                             FORMAT_0, MESSAGE_3);
; 5768 :             *unitstat = CSW_CE | CSW_DE | CSW_UC;

  09586	48 8b 84 24 08
	04 00 00	 mov	 rax, QWORD PTR unitstat$[rsp]
  0958e	c6 00 0e	 mov	 BYTE PTR [rax], 14

; 5769 :             break;

  09591	e9 ba 0f 00 00	 jmp	 $LN2@ckd_dasd_e
$LN572@ckd_dasd_e:

; 5770 :         }
; 5771 : 
; 5772 :         /* Command reject if within the domain of a Locate Record */
; 5773 :         if (dev->ckdlcount > 0)

  09596	48 8b 84 24 c0
	03 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  0959e	0f b6 80 02 13
	00 00		 movzx	 eax, BYTE PTR [rax+4866]
  095a5	85 c0		 test	 eax, eax
  095a7	7e 2f		 jle	 SHORT $LN573@ckd_dasd_e

; 5774 :         {
; 5775 :             ckd_build_sense (dev, SENSE_CR, 0, 0,

  095a9	c6 44 24 28 02	 mov	 BYTE PTR [rsp+40], 2
  095ae	c6 44 24 20 00	 mov	 BYTE PTR [rsp+32], 0
  095b3	45 33 c9	 xor	 r9d, r9d
  095b6	45 33 c0	 xor	 r8d, r8d
  095b9	b2 80		 mov	 dl, 128			; 00000080H
  095bb	48 8b 8c 24 c0
	03 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  095c3	e8 00 00 00 00	 call	 ckd_build_sense

; 5776 :                             FORMAT_0, MESSAGE_2);
; 5777 :             *unitstat = CSW_CE | CSW_DE | CSW_UC;

  095c8	48 8b 84 24 08
	04 00 00	 mov	 rax, QWORD PTR unitstat$[rsp]
  095d0	c6 00 0e	 mov	 BYTE PTR [rax], 14

; 5778 :             break;

  095d3	e9 78 0f 00 00	 jmp	 $LN2@ckd_dasd_e
$LN573@ckd_dasd_e:

; 5779 :         }
; 5780 : 
; 5781 :         /* Command reject if byte 0 does not contain a valid
; 5782 :            subcommand code, or if bytes 2-3 are not zero */
; 5783 :         if (!(iobuf[0] == DIAGCTL_MAINT_QUERY
; 5784 : //            || iobuf[0] == DIAGCTL_MAINT_RESERVE
; 5785 : //            || iobuf[0] == DIAGCTL_MAINT_RELEASE
; 5786 : //            || iobuf[0] == DIAGCTL_INHIBIT_WRITE
; 5787 : //            || iobuf[0] == DIAGCTL_SET_GUAR_PATH
; 5788 : //            || iobuf[0] == DIAGCTL_ENABLE_WRITE
; 5789 : //            || iobuf[0] == DIAGCTL_3380_TC_MODE
; 5790 : //            || iobuf[0] == DIAGCTL_INIT_SUBSYS
; 5791 : //            || iobuf[0] == DIAGCTL_UNFENCE
; 5792 : //            || iobuf[0] == DIAGCTL_ACCDEV_UNKCOND
; 5793 :              ) || iobuf[2] != 0 || iobuf[3] != 0)

  095d8	b8 01 00 00 00	 mov	 eax, 1
  095dd	48 6b c0 00	 imul	 rax, rax, 0
  095e1	48 8b 8c 24 f8
	03 00 00	 mov	 rcx, QWORD PTR iobuf$[rsp]
  095e9	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  095ed	83 f8 12	 cmp	 eax, 18
  095f0	75 32		 jne	 SHORT $LN575@ckd_dasd_e
  095f2	b8 01 00 00 00	 mov	 eax, 1
  095f7	48 6b c0 02	 imul	 rax, rax, 2
  095fb	48 8b 8c 24 f8
	03 00 00	 mov	 rcx, QWORD PTR iobuf$[rsp]
  09603	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  09607	85 c0		 test	 eax, eax
  09609	75 19		 jne	 SHORT $LN575@ckd_dasd_e
  0960b	b8 01 00 00 00	 mov	 eax, 1
  09610	48 6b c0 03	 imul	 rax, rax, 3
  09614	48 8b 8c 24 f8
	03 00 00	 mov	 rcx, QWORD PTR iobuf$[rsp]
  0961c	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  09620	85 c0		 test	 eax, eax
  09622	74 2f		 je	 SHORT $LN574@ckd_dasd_e
$LN575@ckd_dasd_e:

; 5794 :         {
; 5795 :             ckd_build_sense (dev, SENSE_CR, 0, 0,

  09624	c6 44 24 28 04	 mov	 BYTE PTR [rsp+40], 4
  09629	c6 44 24 20 00	 mov	 BYTE PTR [rsp+32], 0
  0962e	45 33 c9	 xor	 r9d, r9d
  09631	45 33 c0	 xor	 r8d, r8d
  09634	b2 80		 mov	 dl, 128			; 00000080H
  09636	48 8b 8c 24 c0
	03 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  0963e	e8 00 00 00 00	 call	 ckd_build_sense

; 5796 :                             FORMAT_0, MESSAGE_4);
; 5797 :             *unitstat = CSW_CE | CSW_DE | CSW_UC;

  09643	48 8b 84 24 08
	04 00 00	 mov	 rax, QWORD PTR unitstat$[rsp]
  0964b	c6 00 0e	 mov	 BYTE PTR [rax], 14

; 5798 :             break;

  0964e	e9 fd 0e 00 00	 jmp	 $LN2@ckd_dasd_e
$LN574@ckd_dasd_e:

; 5799 :         }
; 5800 : 
; 5801 :         /* Command reject if file mask does not specify
; 5802 :            diagnostic or device support authorization */
; 5803 :         if ((dev->ckdfmask & CKDMASK_AAUTH) == CKDMASK_AAUTH_NORMAL)

  09653	48 8b 84 24 c0
	03 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  0965b	0f b6 80 fa 12
	00 00		 movzx	 eax, BYTE PTR [rax+4858]
  09662	83 e0 06	 and	 eax, 6
  09665	85 c0		 test	 eax, eax
  09667	75 2f		 jne	 SHORT $LN576@ckd_dasd_e

; 5804 :         {
; 5805 :             ckd_build_sense (dev, SENSE_CR, 0, 0,

  09669	c6 44 24 28 05	 mov	 BYTE PTR [rsp+40], 5
  0966e	c6 44 24 20 00	 mov	 BYTE PTR [rsp+32], 0
  09673	45 33 c9	 xor	 r9d, r9d
  09676	45 33 c0	 xor	 r8d, r8d
  09679	b2 80		 mov	 dl, 128			; 00000080H
  0967b	48 8b 8c 24 c0
	03 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  09683	e8 00 00 00 00	 call	 ckd_build_sense

; 5806 :                             FORMAT_0, MESSAGE_5);
; 5807 :             *unitstat = CSW_CE | CSW_DE | CSW_UC;

  09688	48 8b 84 24 08
	04 00 00	 mov	 rax, QWORD PTR unitstat$[rsp]
  09690	c6 00 0e	 mov	 BYTE PTR [rax], 14

; 5808 :             break;

  09693	e9 b8 0e 00 00	 jmp	 $LN2@ckd_dasd_e
$LN576@ckd_dasd_e:

; 5809 :         }
; 5810 : 
; 5811 :         /* Return normal status */
; 5812 :         *unitstat = CSW_CE | CSW_DE;

  09698	48 8b 84 24 08
	04 00 00	 mov	 rax, QWORD PTR unitstat$[rsp]
  096a0	c6 00 0c	 mov	 BYTE PTR [rax], 12

; 5813 :         break;

  096a3	e9 a8 0e 00 00	 jmp	 $LN2@ckd_dasd_e
$LN577@ckd_dasd_e:

; 5814 : 
; 5815 :     case 0x94:
; 5816 :     /*---------------------------------------------------------------*/
; 5817 :     /* DEVICE RELEASE                                                */
; 5818 :     /*---------------------------------------------------------------*/
; 5819 :         /* Command reject if within the domain of a Locate Record, or
; 5820 :            preceded by Define Extent, Space Count, or Set File Mask,
; 5821 :            or (for 3390 only) preceded by Read IPL */
; 5822 :         if (dev->ckdlcount > 0
; 5823 :             || dev->ckdxtdef || dev->ckdspcnt || dev->ckdsetfm
; 5824 :             || (dev->ckdrdipl && dev->devtype == 0x3390))

  096a8	48 8b 84 24 c0
	03 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  096b0	0f b6 80 02 13
	00 00		 movzx	 eax, BYTE PTR [rax+4866]
  096b7	85 c0		 test	 eax, eax
  096b9	7f 72		 jg	 SHORT $LN579@ckd_dasd_e
  096bb	48 8b 84 24 c0
	03 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  096c3	8b 80 14 13 00
	00		 mov	 eax, DWORD PTR [rax+4884]
  096c9	d1 e8		 shr	 eax, 1
  096cb	83 e0 01	 and	 eax, 1
  096ce	85 c0		 test	 eax, eax
  096d0	75 5b		 jne	 SHORT $LN579@ckd_dasd_e
  096d2	48 8b 84 24 c0
	03 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  096da	8b 80 14 13 00
	00		 mov	 eax, DWORD PTR [rax+4884]
  096e0	c1 e8 05	 shr	 eax, 5
  096e3	83 e0 01	 and	 eax, 1
  096e6	85 c0		 test	 eax, eax
  096e8	75 43		 jne	 SHORT $LN579@ckd_dasd_e
  096ea	48 8b 84 24 c0
	03 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  096f2	8b 80 14 13 00
	00		 mov	 eax, DWORD PTR [rax+4884]
  096f8	c1 e8 02	 shr	 eax, 2
  096fb	83 e0 01	 and	 eax, 1
  096fe	85 c0		 test	 eax, eax
  09700	75 2b		 jne	 SHORT $LN579@ckd_dasd_e
  09702	48 8b 84 24 c0
	03 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  0970a	8b 80 14 13 00
	00		 mov	 eax, DWORD PTR [rax+4884]
  09710	c1 e8 09	 shr	 eax, 9
  09713	83 e0 01	 and	 eax, 1
  09716	85 c0		 test	 eax, eax
  09718	74 42		 je	 SHORT $LN578@ckd_dasd_e
  0971a	48 8b 84 24 c0
	03 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  09722	0f b7 40 4a	 movzx	 eax, WORD PTR [rax+74]
  09726	3d 90 33 00 00	 cmp	 eax, 13200		; 00003390H
  0972b	75 2f		 jne	 SHORT $LN578@ckd_dasd_e
$LN579@ckd_dasd_e:

; 5825 :         {
; 5826 :             ckd_build_sense (dev, SENSE_CR, 0, 0,

  0972d	c6 44 24 28 02	 mov	 BYTE PTR [rsp+40], 2
  09732	c6 44 24 20 00	 mov	 BYTE PTR [rsp+32], 0
  09737	45 33 c9	 xor	 r9d, r9d
  0973a	45 33 c0	 xor	 r8d, r8d
  0973d	b2 80		 mov	 dl, 128			; 00000080H
  0973f	48 8b 8c 24 c0
	03 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  09747	e8 00 00 00 00	 call	 ckd_build_sense

; 5827 :                             FORMAT_0, MESSAGE_2);
; 5828 :             *unitstat = CSW_CE | CSW_DE | CSW_UC;

  0974c	48 8b 84 24 08
	04 00 00	 mov	 rax, QWORD PTR unitstat$[rsp]
  09754	c6 00 0e	 mov	 BYTE PTR [rax], 14

; 5829 :             break;

  09757	e9 f4 0d 00 00	 jmp	 $LN2@ckd_dasd_e
$LN578@ckd_dasd_e:

; 5830 :         }
; 5831 : 
; 5832 :         /* Call the release exit and mark the device not reserved */
; 5833 :         if (dev->hnd->release) (dev->hnd->release) (dev);

  0975c	48 8b 84 24 c0
	03 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  09764	48 8b 80 90 02
	00 00		 mov	 rax, QWORD PTR [rax+656]
  0976b	48 83 78 70 00	 cmp	 QWORD PTR [rax+112], 0
  09770	74 1a		 je	 SHORT $LN580@ckd_dasd_e
  09772	48 8b 84 24 c0
	03 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  0977a	48 8b 80 90 02
	00 00		 mov	 rax, QWORD PTR [rax+656]
  09781	48 8b 8c 24 c0
	03 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  09789	ff 50 70	 call	 QWORD PTR [rax+112]
$LN580@ckd_dasd_e:

; 5834 : 
; 5835 :         obtain_lock (&dev->lock);

  0978c	48 8b 84 24 c0
	03 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  09794	48 83 c0 38	 add	 rax, 56			; 00000038H
  09798	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG172227
  0979f	48 8b c8	 mov	 rcx, rax
  097a2	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_obtain_lock

; 5836 :         dev->reserved = 0;

  097a8	48 8b 84 24 c0
	03 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  097b0	8b 80 f8 05 00
	00		 mov	 eax, DWORD PTR [rax+1528]
  097b6	0f ba f0 14	 btr	 eax, 20
  097ba	48 8b 8c 24 c0
	03 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  097c2	89 81 f8 05 00
	00		 mov	 DWORD PTR [rcx+1528], eax

; 5837 :         release_lock (&dev->lock);

  097c8	48 8b 84 24 c0
	03 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  097d0	48 83 c0 38	 add	 rax, 56			; 00000038H
  097d4	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG172228
  097db	48 8b c8	 mov	 rcx, rax
  097de	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_release_lock

; 5838 : 
; 5839 :         /* Perform the operation of a sense command */
; 5840 :         goto sense;

  097e4	e9 31 01 00 00	 jmp	 $sense$787
$LN581@ckd_dasd_e:
$LN582@ckd_dasd_e:

; 5841 : 
; 5842 :     case 0x14: /* UNCONDITIONAL RESERVE */
; 5843 :     case 0xB4: /* DEVICE RESERVE */
; 5844 :     /*---------------------------------------------------------------*/
; 5845 :     /* DEVICE RESERVE                                                */
; 5846 :     /*---------------------------------------------------------------*/
; 5847 :         /* Command reject if within the domain of a Locate Record,
; 5848 :            or indeed if preceded by any command at all apart from
; 5849 :            Suspend Multipath Reconnection */
; 5850 :         if (dev->ckdlcount > 0
; 5851 :             || ccwseq > 1
; 5852 :             || (chained && prevcode != 0x5B))

  097e9	48 8b 84 24 c0
	03 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  097f1	0f b6 80 02 13
	00 00		 movzx	 eax, BYTE PTR [rax+4866]
  097f8	85 c0		 test	 eax, eax
  097fa	7f 23		 jg	 SHORT $LN584@ckd_dasd_e
  097fc	83 bc 24 f0 03
	00 00 01	 cmp	 DWORD PTR ccwseq$[rsp], 1
  09804	7f 19		 jg	 SHORT $LN584@ckd_dasd_e
  09806	0f b6 84 24 d8
	03 00 00	 movzx	 eax, BYTE PTR chained$[rsp]
  0980e	85 c0		 test	 eax, eax
  09810	74 3c		 je	 SHORT $LN583@ckd_dasd_e
  09812	0f b6 84 24 e8
	03 00 00	 movzx	 eax, BYTE PTR prevcode$[rsp]
  0981a	83 f8 5b	 cmp	 eax, 91			; 0000005bH
  0981d	74 2f		 je	 SHORT $LN583@ckd_dasd_e
$LN584@ckd_dasd_e:

; 5853 :         {
; 5854 :             ckd_build_sense (dev, SENSE_CR, 0, 0,

  0981f	c6 44 24 28 02	 mov	 BYTE PTR [rsp+40], 2
  09824	c6 44 24 20 00	 mov	 BYTE PTR [rsp+32], 0
  09829	45 33 c9	 xor	 r9d, r9d
  0982c	45 33 c0	 xor	 r8d, r8d
  0982f	b2 80		 mov	 dl, 128			; 00000080H
  09831	48 8b 8c 24 c0
	03 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  09839	e8 00 00 00 00	 call	 ckd_build_sense

; 5855 :                             FORMAT_0, MESSAGE_2);
; 5856 :             *unitstat = CSW_CE | CSW_DE | CSW_UC;

  0983e	48 8b 84 24 08
	04 00 00	 mov	 rax, QWORD PTR unitstat$[rsp]
  09846	c6 00 0e	 mov	 BYTE PTR [rax], 14

; 5857 :             break;

  09849	e9 02 0d 00 00	 jmp	 $LN2@ckd_dasd_e
$LN583@ckd_dasd_e:

; 5858 :         }
; 5859 : 
; 5860 :         /* Mark the device reserved and call the reserve exit */
; 5861 : 
; 5862 :         obtain_lock (&dev->lock);

  0984e	48 8b 84 24 c0
	03 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  09856	48 83 c0 38	 add	 rax, 56			; 00000038H
  0985a	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG172233
  09861	48 8b c8	 mov	 rcx, rax
  09864	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_obtain_lock

; 5863 :         dev->reserved = 1;

  0986a	48 8b 84 24 c0
	03 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  09872	8b 80 f8 05 00
	00		 mov	 eax, DWORD PTR [rax+1528]
  09878	0f ba e8 14	 bts	 eax, 20
  0987c	48 8b 8c 24 c0
	03 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  09884	89 81 f8 05 00
	00		 mov	 DWORD PTR [rcx+1528], eax

; 5864 :         release_lock (&dev->lock);

  0988a	48 8b 84 24 c0
	03 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  09892	48 83 c0 38	 add	 rax, 56			; 00000038H
  09896	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG172234
  0989d	48 8b c8	 mov	 rcx, rax
  098a0	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_release_lock

; 5865 : 
; 5866 :         if (dev->hnd->reserve) (dev->hnd->reserve) (dev);

  098a6	48 8b 84 24 c0
	03 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  098ae	48 8b 80 90 02
	00 00		 mov	 rax, QWORD PTR [rax+656]
  098b5	48 83 78 68 00	 cmp	 QWORD PTR [rax+104], 0
  098ba	74 1a		 je	 SHORT $LN585@ckd_dasd_e
  098bc	48 8b 84 24 c0
	03 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  098c4	48 8b 80 90 02
	00 00		 mov	 rax, QWORD PTR [rax+656]
  098cb	48 8b 8c 24 c0
	03 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  098d3	ff 50 68	 call	 QWORD PTR [rax+104]
$LN585@ckd_dasd_e:

; 5867 : 
; 5868 :         /* Perform the operation of a sense command */
; 5869 :         goto sense;

  098d6	eb 42		 jmp	 SHORT $sense$787
$LN586@ckd_dasd_e:

; 5870 : 
; 5871 :     case 0x04:
; 5872 :     /*---------------------------------------------------------------*/
; 5873 :     /* SENSE                                                         */
; 5874 :     /*---------------------------------------------------------------*/
; 5875 :         /* Command reject if within the domain of a Locate Record */
; 5876 :         if (dev->ckdlcount > 0)

  098d8	48 8b 84 24 c0
	03 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  098e0	0f b6 80 02 13
	00 00		 movzx	 eax, BYTE PTR [rax+4866]
  098e7	85 c0		 test	 eax, eax
  098e9	7e 2f		 jle	 SHORT $LN587@ckd_dasd_e

; 5877 :         {
; 5878 :             ckd_build_sense (dev, SENSE_CR, 0, 0,

  098eb	c6 44 24 28 02	 mov	 BYTE PTR [rsp+40], 2
  098f0	c6 44 24 20 00	 mov	 BYTE PTR [rsp+32], 0
  098f5	45 33 c9	 xor	 r9d, r9d
  098f8	45 33 c0	 xor	 r8d, r8d
  098fb	b2 80		 mov	 dl, 128			; 00000080H
  098fd	48 8b 8c 24 c0
	03 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  09905	e8 00 00 00 00	 call	 ckd_build_sense

; 5879 :                             FORMAT_0, MESSAGE_2);
; 5880 :             *unitstat = CSW_CE | CSW_DE | CSW_UC;

  0990a	48 8b 84 24 08
	04 00 00	 mov	 rax, QWORD PTR unitstat$[rsp]
  09912	c6 00 0e	 mov	 BYTE PTR [rax], 14

; 5881 :             break;

  09915	e9 36 0c 00 00	 jmp	 $LN2@ckd_dasd_e
$LN587@ckd_dasd_e:
$sense$787:

; 5882 :         }
; 5883 : 
; 5884 :     sense:
; 5885 :         /* If sense bytes are cleared then build sense */
; 5886 :         if ((dev->sense[0] == 0) & (dev->sense[1] == 0))

  0991a	b8 01 00 00 00	 mov	 eax, 1
  0991f	48 6b c0 00	 imul	 rax, rax, 0
  09923	48 8b 8c 24 c0
	03 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  0992b	0f b6 84 01 64
	03 00 00	 movzx	 eax, BYTE PTR [rcx+rax+868]
  09933	85 c0		 test	 eax, eax
  09935	75 0d		 jne	 SHORT $LN759@ckd_dasd_e
  09937	c7 84 24 b8 01
	00 00 01 00 00
	00		 mov	 DWORD PTR tv4934[rsp], 1
  09942	eb 0b		 jmp	 SHORT $LN760@ckd_dasd_e
$LN759@ckd_dasd_e:
  09944	c7 84 24 b8 01
	00 00 00 00 00
	00		 mov	 DWORD PTR tv4934[rsp], 0
$LN760@ckd_dasd_e:
  0994f	b8 01 00 00 00	 mov	 eax, 1
  09954	48 6b c0 01	 imul	 rax, rax, 1
  09958	48 8b 8c 24 c0
	03 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  09960	0f b6 84 01 64
	03 00 00	 movzx	 eax, BYTE PTR [rcx+rax+868]
  09968	85 c0		 test	 eax, eax
  0996a	75 0d		 jne	 SHORT $LN757@ckd_dasd_e
  0996c	c7 84 24 b4 01
	00 00 01 00 00
	00		 mov	 DWORD PTR tv4933[rsp], 1
  09977	eb 0b		 jmp	 SHORT $LN758@ckd_dasd_e
$LN757@ckd_dasd_e:
  09979	c7 84 24 b4 01
	00 00 00 00 00
	00		 mov	 DWORD PTR tv4933[rsp], 0
$LN758@ckd_dasd_e:
  09984	8b 84 24 b4 01
	00 00		 mov	 eax, DWORD PTR tv4933[rsp]
  0998b	8b 8c 24 b8 01
	00 00		 mov	 ecx, DWORD PTR tv4934[rsp]
  09992	23 c8		 and	 ecx, eax
  09994	8b c1		 mov	 eax, ecx
  09996	85 c0		 test	 eax, eax
  09998	74 1f		 je	 SHORT $LN588@ckd_dasd_e

; 5887 :             ckd_build_sense (dev, 0, 0, 0, 0, 0);

  0999a	c6 44 24 28 00	 mov	 BYTE PTR [rsp+40], 0
  0999f	c6 44 24 20 00	 mov	 BYTE PTR [rsp+32], 0
  099a4	45 33 c9	 xor	 r9d, r9d
  099a7	45 33 c0	 xor	 r8d, r8d
  099aa	33 d2		 xor	 edx, edx
  099ac	48 8b 8c 24 c0
	03 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  099b4	e8 00 00 00 00	 call	 ckd_build_sense
$LN588@ckd_dasd_e:

; 5888 : 
; 5889 :         /* Calculate residual byte count */
; 5890 :         num = (count < dev->numsense) ? count : dev->numsense;

  099b9	48 8b 84 24 c0
	03 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  099c1	8b 80 60 03 00
	00		 mov	 eax, DWORD PTR [rax+864]
  099c7	39 84 24 e0 03
	00 00		 cmp	 DWORD PTR count$[rsp], eax
  099ce	73 10		 jae	 SHORT $LN761@ckd_dasd_e
  099d0	8b 84 24 e0 03
	00 00		 mov	 eax, DWORD PTR count$[rsp]
  099d7	89 84 24 bc 01
	00 00		 mov	 DWORD PTR tv4946[rsp], eax
  099de	eb 15		 jmp	 SHORT $LN762@ckd_dasd_e
$LN761@ckd_dasd_e:
  099e0	48 8b 84 24 c0
	03 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  099e8	8b 80 60 03 00
	00		 mov	 eax, DWORD PTR [rax+864]
  099ee	89 84 24 bc 01
	00 00		 mov	 DWORD PTR tv4946[rsp], eax
$LN762@ckd_dasd_e:
  099f5	8b 84 24 bc 01
	00 00		 mov	 eax, DWORD PTR tv4946[rsp]
  099fc	89 44 24 64	 mov	 DWORD PTR num$[rsp], eax

; 5891 :         *residual = count - num;

  09a00	8b 44 24 64	 mov	 eax, DWORD PTR num$[rsp]
  09a04	8b 8c 24 e0 03
	00 00		 mov	 ecx, DWORD PTR count$[rsp]
  09a0b	2b c8		 sub	 ecx, eax
  09a0d	8b c1		 mov	 eax, ecx
  09a0f	48 8b 8c 24 10
	04 00 00	 mov	 rcx, QWORD PTR residual$[rsp]
  09a17	89 01		 mov	 DWORD PTR [rcx], eax

; 5892 :         if (count < dev->numsense) *more = 1;

  09a19	48 8b 84 24 c0
	03 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  09a21	8b 80 60 03 00
	00		 mov	 eax, DWORD PTR [rax+864]
  09a27	39 84 24 e0 03
	00 00		 cmp	 DWORD PTR count$[rsp], eax
  09a2e	73 0b		 jae	 SHORT $LN589@ckd_dasd_e
  09a30	48 8b 84 24 00
	04 00 00	 mov	 rax, QWORD PTR more$[rsp]
  09a38	c6 00 01	 mov	 BYTE PTR [rax], 1
$LN589@ckd_dasd_e:

; 5893 : 
; 5894 :         /* Copy device sense bytes to channel I/O buffer */
; 5895 :         memcpy (iobuf, dev->sense, num);

  09a3b	8b 44 24 64	 mov	 eax, DWORD PTR num$[rsp]
  09a3f	48 8b 8c 24 c0
	03 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  09a47	48 81 c1 64 03
	00 00		 add	 rcx, 868		; 00000364H
  09a4e	48 8b bc 24 f8
	03 00 00	 mov	 rdi, QWORD PTR iobuf$[rsp]
  09a56	48 8b f1	 mov	 rsi, rcx
  09a59	8b c8		 mov	 ecx, eax
  09a5b	f3 a4		 rep movsb

; 5896 : 
; 5897 :         /* Clear the device sense bytes */
; 5898 :         memset( dev->sense, 0, sizeof(dev->sense) );

  09a5d	48 8b 84 24 c0
	03 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  09a65	48 05 64 03 00
	00		 add	 rax, 868		; 00000364H
  09a6b	48 8b f8	 mov	 rdi, rax
  09a6e	33 c0		 xor	 eax, eax
  09a70	b9 00 01 00 00	 mov	 ecx, 256		; 00000100H
  09a75	f3 aa		 rep stosb

; 5899 : 
; 5900 :         *unitstat = CSW_CE | CSW_DE;

  09a77	48 8b 84 24 08
	04 00 00	 mov	 rax, QWORD PTR unitstat$[rsp]
  09a7f	c6 00 0c	 mov	 BYTE PTR [rax], 12

; 5901 :         break;

  09a82	e9 c9 0a 00 00	 jmp	 $LN2@ckd_dasd_e
$LN590@ckd_dasd_e:

; 5902 : 
; 5903 :     case 0xE4:
; 5904 :     /*---------------------------------------------------------------*/
; 5905 :     /* SENSE ID                                                      */
; 5906 :     /*---------------------------------------------------------------*/
; 5907 : 
; 5908 :         /* If numdevid is 0, then 0xE4 Sense ID is not supported */
; 5909 :         if (dev->numdevid == 0)

  09a87	48 8b 84 24 c0
	03 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  09a8f	83 b8 64 04 00
	00 00		 cmp	 DWORD PTR [rax+1124], 0
  09a96	75 2f		 jne	 SHORT $LN591@ckd_dasd_e

; 5910 :         {
; 5911 :             ckd_build_sense (dev, SENSE_CR, 0, 0,

  09a98	c6 44 24 28 01	 mov	 BYTE PTR [rsp+40], 1
  09a9d	c6 44 24 20 00	 mov	 BYTE PTR [rsp+32], 0
  09aa2	45 33 c9	 xor	 r9d, r9d
  09aa5	45 33 c0	 xor	 r8d, r8d
  09aa8	b2 80		 mov	 dl, 128			; 00000080H
  09aaa	48 8b 8c 24 c0
	03 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  09ab2	e8 00 00 00 00	 call	 ckd_build_sense

; 5912 :                             FORMAT_0, MESSAGE_1);
; 5913 :             *unitstat = CSW_CE | CSW_DE | CSW_UC;

  09ab7	48 8b 84 24 08
	04 00 00	 mov	 rax, QWORD PTR unitstat$[rsp]
  09abf	c6 00 0e	 mov	 BYTE PTR [rax], 14

; 5914 :             break;

  09ac2	e9 89 0a 00 00	 jmp	 $LN2@ckd_dasd_e
$LN591@ckd_dasd_e:

; 5915 :         }
; 5916 : 
; 5917 :         /* Command reject if within the domain of a Locate Record */
; 5918 :         if (dev->ckdlcount > 0)

  09ac7	48 8b 84 24 c0
	03 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  09acf	0f b6 80 02 13
	00 00		 movzx	 eax, BYTE PTR [rax+4866]
  09ad6	85 c0		 test	 eax, eax
  09ad8	7e 2f		 jle	 SHORT $LN592@ckd_dasd_e

; 5919 :         {
; 5920 :             ckd_build_sense (dev, SENSE_CR, 0, 0,

  09ada	c6 44 24 28 02	 mov	 BYTE PTR [rsp+40], 2
  09adf	c6 44 24 20 00	 mov	 BYTE PTR [rsp+32], 0
  09ae4	45 33 c9	 xor	 r9d, r9d
  09ae7	45 33 c0	 xor	 r8d, r8d
  09aea	b2 80		 mov	 dl, 128			; 00000080H
  09aec	48 8b 8c 24 c0
	03 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  09af4	e8 00 00 00 00	 call	 ckd_build_sense

; 5921 :                             FORMAT_0, MESSAGE_2);
; 5922 :             *unitstat = CSW_CE | CSW_DE | CSW_UC;

  09af9	48 8b 84 24 08
	04 00 00	 mov	 rax, QWORD PTR unitstat$[rsp]
  09b01	c6 00 0e	 mov	 BYTE PTR [rax], 14

; 5923 :             break;

  09b04	e9 47 0a 00 00	 jmp	 $LN2@ckd_dasd_e
$LN592@ckd_dasd_e:

; 5924 :         }
; 5925 : 
; 5926 :         /* Calculate residual byte count */
; 5927 :         num = (count < dev->numdevid) ? count : dev->numdevid;

  09b09	48 8b 84 24 c0
	03 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  09b11	8b 80 64 04 00
	00		 mov	 eax, DWORD PTR [rax+1124]
  09b17	39 84 24 e0 03
	00 00		 cmp	 DWORD PTR count$[rsp], eax
  09b1e	73 10		 jae	 SHORT $LN763@ckd_dasd_e
  09b20	8b 84 24 e0 03
	00 00		 mov	 eax, DWORD PTR count$[rsp]
  09b27	89 84 24 c0 01
	00 00		 mov	 DWORD PTR tv4982[rsp], eax
  09b2e	eb 15		 jmp	 SHORT $LN764@ckd_dasd_e
$LN763@ckd_dasd_e:
  09b30	48 8b 84 24 c0
	03 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  09b38	8b 80 64 04 00
	00		 mov	 eax, DWORD PTR [rax+1124]
  09b3e	89 84 24 c0 01
	00 00		 mov	 DWORD PTR tv4982[rsp], eax
$LN764@ckd_dasd_e:
  09b45	8b 84 24 c0 01
	00 00		 mov	 eax, DWORD PTR tv4982[rsp]
  09b4c	89 44 24 64	 mov	 DWORD PTR num$[rsp], eax

; 5928 :         *residual = count - num;

  09b50	8b 44 24 64	 mov	 eax, DWORD PTR num$[rsp]
  09b54	8b 8c 24 e0 03
	00 00		 mov	 ecx, DWORD PTR count$[rsp]
  09b5b	2b c8		 sub	 ecx, eax
  09b5d	8b c1		 mov	 eax, ecx
  09b5f	48 8b 8c 24 10
	04 00 00	 mov	 rcx, QWORD PTR residual$[rsp]
  09b67	89 01		 mov	 DWORD PTR [rcx], eax

; 5929 :         if (count < dev->numdevid) *more = 1;

  09b69	48 8b 84 24 c0
	03 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  09b71	8b 80 64 04 00
	00		 mov	 eax, DWORD PTR [rax+1124]
  09b77	39 84 24 e0 03
	00 00		 cmp	 DWORD PTR count$[rsp], eax
  09b7e	73 0b		 jae	 SHORT $LN593@ckd_dasd_e
  09b80	48 8b 84 24 00
	04 00 00	 mov	 rax, QWORD PTR more$[rsp]
  09b88	c6 00 01	 mov	 BYTE PTR [rax], 1
$LN593@ckd_dasd_e:

; 5930 : 
; 5931 :         /* Copy device identifier bytes to channel I/O buffer */
; 5932 :         memcpy (iobuf, dev->devid, num);

  09b8b	8b 44 24 64	 mov	 eax, DWORD PTR num$[rsp]
  09b8f	48 8b 8c 24 c0
	03 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  09b97	48 81 c1 68 04
	00 00		 add	 rcx, 1128		; 00000468H
  09b9e	48 8b bc 24 f8
	03 00 00	 mov	 rdi, QWORD PTR iobuf$[rsp]
  09ba6	48 8b f1	 mov	 rsi, rcx
  09ba9	8b c8		 mov	 ecx, eax
  09bab	f3 a4		 rep movsb

; 5933 : 
; 5934 :         /* Return unit status */
; 5935 :         *unitstat = CSW_CE | CSW_DE;

  09bad	48 8b 84 24 08
	04 00 00	 mov	 rax, QWORD PTR unitstat$[rsp]
  09bb5	c6 00 0c	 mov	 BYTE PTR [rax], 12

; 5936 :         break;

  09bb8	e9 93 09 00 00	 jmp	 $LN2@ckd_dasd_e
$LN594@ckd_dasd_e:

; 5937 : 
; 5938 :     case 0x34:
; 5939 :     /*---------------------------------------------------------------*/
; 5940 :     /* SENSE PATH GROUP ID                                           */
; 5941 :     /*---------------------------------------------------------------*/
; 5942 : 
; 5943 :         /* Calculate residual byte count */
; 5944 :         num = (count < 12) ? count : 12;

  09bbd	83 bc 24 e0 03
	00 00 0c	 cmp	 DWORD PTR count$[rsp], 12
  09bc5	73 10		 jae	 SHORT $LN765@ckd_dasd_e
  09bc7	8b 84 24 e0 03
	00 00		 mov	 eax, DWORD PTR count$[rsp]
  09bce	89 84 24 c4 01
	00 00		 mov	 DWORD PTR tv4994[rsp], eax
  09bd5	eb 0b		 jmp	 SHORT $LN766@ckd_dasd_e
$LN765@ckd_dasd_e:
  09bd7	c7 84 24 c4 01
	00 00 0c 00 00
	00		 mov	 DWORD PTR tv4994[rsp], 12
$LN766@ckd_dasd_e:
  09be2	8b 84 24 c4 01
	00 00		 mov	 eax, DWORD PTR tv4994[rsp]
  09be9	89 44 24 64	 mov	 DWORD PTR num$[rsp], eax

; 5945 :         *residual = count - num;

  09bed	8b 44 24 64	 mov	 eax, DWORD PTR num$[rsp]
  09bf1	8b 8c 24 e0 03
	00 00		 mov	 ecx, DWORD PTR count$[rsp]
  09bf8	2b c8		 sub	 ecx, eax
  09bfa	8b c1		 mov	 eax, ecx
  09bfc	48 8b 8c 24 10
	04 00 00	 mov	 rcx, QWORD PTR residual$[rsp]
  09c04	89 01		 mov	 DWORD PTR [rcx], eax

; 5946 :         if (count < 12) *more = 1;

  09c06	83 bc 24 e0 03
	00 00 0c	 cmp	 DWORD PTR count$[rsp], 12
  09c0e	73 0b		 jae	 SHORT $LN595@ckd_dasd_e
  09c10	48 8b 84 24 00
	04 00 00	 mov	 rax, QWORD PTR more$[rsp]
  09c18	c6 00 01	 mov	 BYTE PTR [rax], 1
$LN595@ckd_dasd_e:

; 5947 : 
; 5948 :         /* Byte 0 is the path group state byte */
; 5949 :         iobuf[0] = SPG_PATHSTAT_RESET

  09c1b	b8 01 00 00 00	 mov	 eax, 1
  09c20	48 6b c0 00	 imul	 rax, rax, 0
  09c24	48 8b 8c 24 f8
	03 00 00	 mov	 rcx, QWORD PTR iobuf$[rsp]
  09c2c	c6 04 01 00	 mov	 BYTE PTR [rcx+rax], 0

; 5950 :                 | SPG_PARTSTAT_IENABLED
; 5951 :                 | SPG_PATHMODE_SINGLE;
; 5952 : 
; 5953 :         /* If reserved then bits 2 & 3 must be set */
; 5954 :         if (dev->reserved)

  09c30	48 8b 84 24 c0
	03 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  09c38	8b 80 f8 05 00
	00		 mov	 eax, DWORD PTR [rax+1528]
  09c3e	c1 e8 14	 shr	 eax, 20
  09c41	83 e0 01	 and	 eax, 1
  09c44	85 c0		 test	 eax, eax
  09c46	74 2c		 je	 SHORT $LN596@ckd_dasd_e

; 5955 :         {
; 5956 :             iobuf[0] |= SPG_PATHSTAT_RESERVED;

  09c48	b8 01 00 00 00	 mov	 eax, 1
  09c4d	48 6b c0 00	 imul	 rax, rax, 0
  09c51	48 8b 8c 24 f8
	03 00 00	 mov	 rcx, QWORD PTR iobuf$[rsp]
  09c59	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  09c5d	83 c8 30	 or	 eax, 48			; 00000030H
  09c60	b9 01 00 00 00	 mov	 ecx, 1
  09c65	48 6b c9 00	 imul	 rcx, rcx, 0
  09c69	48 8b 94 24 f8
	03 00 00	 mov	 rdx, QWORD PTR iobuf$[rsp]
  09c71	88 04 0a	 mov	 BYTE PTR [rdx+rcx], al
$LN596@ckd_dasd_e:

; 5957 :         }
; 5958 : 
; 5959 :         /* Bytes 1-11 contain the path group identifier */
; 5960 :         memcpy (iobuf+1, dev->pgid, 11);

  09c74	48 8b 84 24 f8
	03 00 00	 mov	 rax, QWORD PTR iobuf$[rsp]
  09c7c	48 8b 8c 24 c0
	03 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  09c84	48 8d 78 01	 lea	 rdi, QWORD PTR [rax+1]
  09c88	48 8d b1 ad 05
	00 00		 lea	 rsi, QWORD PTR [rcx+1453]
  09c8f	b9 0b 00 00 00	 mov	 ecx, 11
  09c94	f3 a4		 rep movsb

; 5961 : 
; 5962 :         /* Return unit status */
; 5963 :         *unitstat = CSW_CE | CSW_DE;

  09c96	48 8b 84 24 08
	04 00 00	 mov	 rax, QWORD PTR unitstat$[rsp]
  09c9e	c6 00 0c	 mov	 BYTE PTR [rax], 12

; 5964 :         break;

  09ca1	e9 aa 08 00 00	 jmp	 $LN2@ckd_dasd_e
$LN597@ckd_dasd_e:

; 5965 : 
; 5966 :     case 0xAF:
; 5967 :     /*---------------------------------------------------------------*/
; 5968 :     /* SET PATH GROUP ID                                             */
; 5969 :     /*---------------------------------------------------------------*/
; 5970 : 
; 5971 :         /* Calculate residual byte count */
; 5972 :         num = (count < 12) ? count : 12;

  09ca6	83 bc 24 e0 03
	00 00 0c	 cmp	 DWORD PTR count$[rsp], 12
  09cae	73 10		 jae	 SHORT $LN767@ckd_dasd_e
  09cb0	8b 84 24 e0 03
	00 00		 mov	 eax, DWORD PTR count$[rsp]
  09cb7	89 84 24 c8 01
	00 00		 mov	 DWORD PTR tv5020[rsp], eax
  09cbe	eb 0b		 jmp	 SHORT $LN768@ckd_dasd_e
$LN767@ckd_dasd_e:
  09cc0	c7 84 24 c8 01
	00 00 0c 00 00
	00		 mov	 DWORD PTR tv5020[rsp], 12
$LN768@ckd_dasd_e:
  09ccb	8b 84 24 c8 01
	00 00		 mov	 eax, DWORD PTR tv5020[rsp]
  09cd2	89 44 24 64	 mov	 DWORD PTR num$[rsp], eax

; 5973 :         *residual = count - num;

  09cd6	8b 44 24 64	 mov	 eax, DWORD PTR num$[rsp]
  09cda	8b 8c 24 e0 03
	00 00		 mov	 ecx, DWORD PTR count$[rsp]
  09ce1	2b c8		 sub	 ecx, eax
  09ce3	8b c1		 mov	 eax, ecx
  09ce5	48 8b 8c 24 10
	04 00 00	 mov	 rcx, QWORD PTR residual$[rsp]
  09ced	89 01		 mov	 DWORD PTR [rcx], eax

; 5974 : 
; 5975 :         /* Control information length must be at least 12 bytes */
; 5976 :         if (count < 12)

  09cef	83 bc 24 e0 03
	00 00 0c	 cmp	 DWORD PTR count$[rsp], 12
  09cf7	73 29		 jae	 SHORT $LN598@ckd_dasd_e

; 5977 :         {
; 5978 :             dev->sense[0] = SENSE_CR;

  09cf9	b8 01 00 00 00	 mov	 eax, 1
  09cfe	48 6b c0 00	 imul	 rax, rax, 0
  09d02	48 8b 8c 24 c0
	03 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  09d0a	c6 84 01 64 03
	00 00 80	 mov	 BYTE PTR [rcx+rax+868], 128 ; 00000080H

; 5979 :             *unitstat = CSW_CE | CSW_DE | CSW_UC;

  09d12	48 8b 84 24 08
	04 00 00	 mov	 rax, QWORD PTR unitstat$[rsp]
  09d1a	c6 00 0e	 mov	 BYTE PTR [rax], 14

; 5980 :             break;

  09d1d	e9 2e 08 00 00	 jmp	 $LN2@ckd_dasd_e
$LN598@ckd_dasd_e:

; 5981 :         }
; 5982 : 
; 5983 :         /* Byte 0 is the path group state byte */
; 5984 :         if ((iobuf[0] & SPG_SET_COMMAND) == SPG_SET_ESTABLISH)

  09d22	b8 01 00 00 00	 mov	 eax, 1
  09d27	48 6b c0 00	 imul	 rax, rax, 0
  09d2b	48 8b 8c 24 f8
	03 00 00	 mov	 rcx, QWORD PTR iobuf$[rsp]
  09d33	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  09d37	83 e0 60	 and	 eax, 96			; 00000060H
  09d3a	85 c0		 test	 eax, eax
  09d3c	0f 85 9e 00 00
	00		 jne	 $LN599@ckd_dasd_e

; 5985 :         {
; 5986 :             /* Only accept the new pathgroup id when
; 5987 :                1) it has not yet been set (ie contains zeros) or
; 5988 :                2) It is set, but we are setting the same value */
; 5989 :             if(memcmp(dev->pgid,
; 5990 :                  "\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00", 11)
; 5991 :               && memcmp(dev->pgid, iobuf+1, 11))

  09d42	48 8b 84 24 c0
	03 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  09d4a	48 05 ad 05 00
	00		 add	 rax, 1453		; 000005adH
  09d50	41 b8 0b 00 00
	00		 mov	 r8d, 11
  09d56	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG172251
  09d5d	48 8b c8	 mov	 rcx, rax
  09d60	e8 00 00 00 00	 call	 memcmp
  09d65	85 c0		 test	 eax, eax
  09d67	74 55		 je	 SHORT $LN600@ckd_dasd_e
  09d69	48 8b 84 24 f8
	03 00 00	 mov	 rax, QWORD PTR iobuf$[rsp]
  09d71	48 ff c0	 inc	 rax
  09d74	48 8b 8c 24 c0
	03 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  09d7c	48 81 c1 ad 05
	00 00		 add	 rcx, 1453		; 000005adH
  09d83	41 b8 0b 00 00
	00		 mov	 r8d, 11
  09d89	48 8b d0	 mov	 rdx, rax
  09d8c	e8 00 00 00 00	 call	 memcmp
  09d91	85 c0		 test	 eax, eax
  09d93	74 29		 je	 SHORT $LN600@ckd_dasd_e

; 5992 :             {
; 5993 :                 dev->sense[0] = SENSE_CR;

  09d95	b8 01 00 00 00	 mov	 eax, 1
  09d9a	48 6b c0 00	 imul	 rax, rax, 0
  09d9e	48 8b 8c 24 c0
	03 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  09da6	c6 84 01 64 03
	00 00 80	 mov	 BYTE PTR [rcx+rax+868], 128 ; 00000080H

; 5994 :                 *unitstat = CSW_CE | CSW_DE | CSW_UC;

  09dae	48 8b 84 24 08
	04 00 00	 mov	 rax, QWORD PTR unitstat$[rsp]
  09db6	c6 00 0e	 mov	 BYTE PTR [rax], 14

; 5995 :                 break;

  09db9	e9 92 07 00 00	 jmp	 $LN2@ckd_dasd_e
$LN600@ckd_dasd_e:

; 5996 :             }
; 5997 : 
; 5998 :             /* Bytes 1-11 contain the path group identifier */
; 5999 :             memcpy (dev->pgid, iobuf+1, 11);

  09dbe	48 8b 84 24 c0
	03 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  09dc6	48 8b 8c 24 f8
	03 00 00	 mov	 rcx, QWORD PTR iobuf$[rsp]
  09dce	48 8d b8 ad 05
	00 00		 lea	 rdi, QWORD PTR [rax+1453]
  09dd5	48 8d 71 01	 lea	 rsi, QWORD PTR [rcx+1]
  09dd9	b9 0b 00 00 00	 mov	 ecx, 11
  09dde	f3 a4		 rep movsb
$LN599@ckd_dasd_e:

; 6000 :         }
; 6001 : 
; 6002 :         /* Return unit status */
; 6003 :         *unitstat = CSW_CE | CSW_DE;

  09de0	48 8b 84 24 08
	04 00 00	 mov	 rax, QWORD PTR unitstat$[rsp]
  09de8	c6 00 0c	 mov	 BYTE PTR [rax], 12

; 6004 :         break;

  09deb	e9 60 07 00 00	 jmp	 $LN2@ckd_dasd_e
$LN601@ckd_dasd_e:

; 6005 : 
; 6006 :     case 0x54:
; 6007 :     /*---------------------------------------------------------------*/
; 6008 :     /* SENSE SUBSYSTEM STATUS                                        */
; 6009 :     /*---------------------------------------------------------------*/
; 6010 :         /* Command reject if within the domain of a Locate Record,
; 6011 :            or if chained from any command unless the preceding command
; 6012 :            is Read Device Characteristics, Read Configuration Data, or
; 6013 :            a Suspend Multipath Reconnection command that was the first
; 6014 :            command in the chain */
; 6015 :         if (dev->ckdlcount > 0
; 6016 :             || (chained && prevcode != 0x64 && prevcode != 0xFA
; 6017 :                 && prevcode != 0x5B)
; 6018 :             || (chained && prevcode == 0x5B && ccwseq > 1))

  09df0	48 8b 84 24 c0
	03 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  09df8	0f b6 80 02 13
	00 00		 movzx	 eax, BYTE PTR [rax+4866]
  09dff	85 c0		 test	 eax, eax
  09e01	7f 58		 jg	 SHORT $LN603@ckd_dasd_e
  09e03	0f b6 84 24 d8
	03 00 00	 movzx	 eax, BYTE PTR chained$[rsp]
  09e0b	85 c0		 test	 eax, eax
  09e0d	74 29		 je	 SHORT $LN604@ckd_dasd_e
  09e0f	0f b6 84 24 e8
	03 00 00	 movzx	 eax, BYTE PTR prevcode$[rsp]
  09e17	83 f8 64	 cmp	 eax, 100		; 00000064H
  09e1a	74 1c		 je	 SHORT $LN604@ckd_dasd_e
  09e1c	0f b6 84 24 e8
	03 00 00	 movzx	 eax, BYTE PTR prevcode$[rsp]
  09e24	3d fa 00 00 00	 cmp	 eax, 250		; 000000faH
  09e29	74 0d		 je	 SHORT $LN604@ckd_dasd_e
  09e2b	0f b6 84 24 e8
	03 00 00	 movzx	 eax, BYTE PTR prevcode$[rsp]
  09e33	83 f8 5b	 cmp	 eax, 91			; 0000005bH
  09e36	75 23		 jne	 SHORT $LN603@ckd_dasd_e
$LN604@ckd_dasd_e:
  09e38	0f b6 84 24 d8
	03 00 00	 movzx	 eax, BYTE PTR chained$[rsp]
  09e40	85 c0		 test	 eax, eax
  09e42	74 46		 je	 SHORT $LN602@ckd_dasd_e
  09e44	0f b6 84 24 e8
	03 00 00	 movzx	 eax, BYTE PTR prevcode$[rsp]
  09e4c	83 f8 5b	 cmp	 eax, 91			; 0000005bH
  09e4f	75 39		 jne	 SHORT $LN602@ckd_dasd_e
  09e51	83 bc 24 f0 03
	00 00 01	 cmp	 DWORD PTR ccwseq$[rsp], 1
  09e59	7e 2f		 jle	 SHORT $LN602@ckd_dasd_e
$LN603@ckd_dasd_e:

; 6019 :         {
; 6020 :             ckd_build_sense (dev, SENSE_CR, 0, 0,

  09e5b	c6 44 24 28 02	 mov	 BYTE PTR [rsp+40], 2
  09e60	c6 44 24 20 00	 mov	 BYTE PTR [rsp+32], 0
  09e65	45 33 c9	 xor	 r9d, r9d
  09e68	45 33 c0	 xor	 r8d, r8d
  09e6b	b2 80		 mov	 dl, 128			; 00000080H
  09e6d	48 8b 8c 24 c0
	03 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  09e75	e8 00 00 00 00	 call	 ckd_build_sense

; 6021 :                             FORMAT_0, MESSAGE_2);
; 6022 :             *unitstat = CSW_CE | CSW_DE | CSW_UC;

  09e7a	48 8b 84 24 08
	04 00 00	 mov	 rax, QWORD PTR unitstat$[rsp]
  09e82	c6 00 0e	 mov	 BYTE PTR [rax], 14

; 6023 :             break;

  09e85	e9 c6 06 00 00	 jmp	 $LN2@ckd_dasd_e
$LN602@ckd_dasd_e:

; 6024 :         }
; 6025 : 
; 6026 :         /* Build the basic subsystem status data in the I/O area */
; 6027 :         num = dasd_build_ckd_subsys_status (dev, iobuf, count);

  09e8a	44 8b 84 24 e0
	03 00 00	 mov	 r8d, DWORD PTR count$[rsp]
  09e92	48 8b 94 24 f8
	03 00 00	 mov	 rdx, QWORD PTR iobuf$[rsp]
  09e9a	48 8b 8c 24 c0
	03 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  09ea2	e8 00 00 00 00	 call	 dasd_build_ckd_subsys_status
  09ea7	89 44 24 64	 mov	 DWORD PTR num$[rsp], eax

; 6028 : 
; 6029 :         /* Calculate residual byte count */
; 6030 :         *residual = count < num ? 0 : count - num;

  09eab	8b 44 24 64	 mov	 eax, DWORD PTR num$[rsp]
  09eaf	39 84 24 e0 03
	00 00		 cmp	 DWORD PTR count$[rsp], eax
  09eb6	73 0d		 jae	 SHORT $LN769@ckd_dasd_e
  09eb8	c7 84 24 cc 01
	00 00 00 00 00
	00		 mov	 DWORD PTR tv5088[rsp], 0
  09ec3	eb 16		 jmp	 SHORT $LN770@ckd_dasd_e
$LN769@ckd_dasd_e:
  09ec5	8b 44 24 64	 mov	 eax, DWORD PTR num$[rsp]
  09ec9	8b 8c 24 e0 03
	00 00		 mov	 ecx, DWORD PTR count$[rsp]
  09ed0	2b c8		 sub	 ecx, eax
  09ed2	8b c1		 mov	 eax, ecx
  09ed4	89 84 24 cc 01
	00 00		 mov	 DWORD PTR tv5088[rsp], eax
$LN770@ckd_dasd_e:
  09edb	48 8b 84 24 10
	04 00 00	 mov	 rax, QWORD PTR residual$[rsp]
  09ee3	8b 8c 24 cc 01
	00 00		 mov	 ecx, DWORD PTR tv5088[rsp]
  09eea	89 08		 mov	 DWORD PTR [rax], ecx

; 6031 :         *more = count < num;

  09eec	8b 44 24 64	 mov	 eax, DWORD PTR num$[rsp]
  09ef0	39 84 24 e0 03
	00 00		 cmp	 DWORD PTR count$[rsp], eax
  09ef7	73 0d		 jae	 SHORT $LN771@ckd_dasd_e
  09ef9	c7 84 24 d0 01
	00 00 01 00 00
	00		 mov	 DWORD PTR tv5090[rsp], 1
  09f04	eb 0b		 jmp	 SHORT $LN772@ckd_dasd_e
$LN771@ckd_dasd_e:
  09f06	c7 84 24 d0 01
	00 00 00 00 00
	00		 mov	 DWORD PTR tv5090[rsp], 0
$LN772@ckd_dasd_e:
  09f11	48 8b 84 24 00
	04 00 00	 mov	 rax, QWORD PTR more$[rsp]
  09f19	0f b6 8c 24 d0
	01 00 00	 movzx	 ecx, BYTE PTR tv5090[rsp]
  09f21	88 08		 mov	 BYTE PTR [rax], cl

; 6032 : 
; 6033 :         /* Return unit status */
; 6034 :         *unitstat = CSW_CE | CSW_DE;

  09f23	48 8b 84 24 08
	04 00 00	 mov	 rax, QWORD PTR unitstat$[rsp]
  09f2b	c6 00 0c	 mov	 BYTE PTR [rax], 12

; 6035 :         break;

  09f2e	e9 1d 06 00 00	 jmp	 $LN2@ckd_dasd_e
$LN605@ckd_dasd_e:

; 6036 : 
; 6037 :     case 0xA4:
; 6038 :     /*---------------------------------------------------------------*/
; 6039 :     /* READ AND RESET BUFFERED LOG                                   */
; 6040 :     /*---------------------------------------------------------------*/
; 6041 :         /* Command reject if within the domain of a Locate Record,
; 6042 :            or if chained from any command unless the preceding command
; 6043 :            is Read Device Characteristics, Read Configuration Data, or
; 6044 :            a Suspend Multipath Reconnection command that was the first
; 6045 :            command in the chain */
; 6046 :         if (dev->ckdlcount > 0
; 6047 :             || (chained && prevcode != 0x64 && prevcode != 0xFA
; 6048 :                 && prevcode != 0x5B)
; 6049 :             || (chained && prevcode == 0x5B && ccwseq > 1))

  09f33	48 8b 84 24 c0
	03 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  09f3b	0f b6 80 02 13
	00 00		 movzx	 eax, BYTE PTR [rax+4866]
  09f42	85 c0		 test	 eax, eax
  09f44	7f 58		 jg	 SHORT $LN607@ckd_dasd_e
  09f46	0f b6 84 24 d8
	03 00 00	 movzx	 eax, BYTE PTR chained$[rsp]
  09f4e	85 c0		 test	 eax, eax
  09f50	74 29		 je	 SHORT $LN608@ckd_dasd_e
  09f52	0f b6 84 24 e8
	03 00 00	 movzx	 eax, BYTE PTR prevcode$[rsp]
  09f5a	83 f8 64	 cmp	 eax, 100		; 00000064H
  09f5d	74 1c		 je	 SHORT $LN608@ckd_dasd_e
  09f5f	0f b6 84 24 e8
	03 00 00	 movzx	 eax, BYTE PTR prevcode$[rsp]
  09f67	3d fa 00 00 00	 cmp	 eax, 250		; 000000faH
  09f6c	74 0d		 je	 SHORT $LN608@ckd_dasd_e
  09f6e	0f b6 84 24 e8
	03 00 00	 movzx	 eax, BYTE PTR prevcode$[rsp]
  09f76	83 f8 5b	 cmp	 eax, 91			; 0000005bH
  09f79	75 23		 jne	 SHORT $LN607@ckd_dasd_e
$LN608@ckd_dasd_e:
  09f7b	0f b6 84 24 d8
	03 00 00	 movzx	 eax, BYTE PTR chained$[rsp]
  09f83	85 c0		 test	 eax, eax
  09f85	74 46		 je	 SHORT $LN606@ckd_dasd_e
  09f87	0f b6 84 24 e8
	03 00 00	 movzx	 eax, BYTE PTR prevcode$[rsp]
  09f8f	83 f8 5b	 cmp	 eax, 91			; 0000005bH
  09f92	75 39		 jne	 SHORT $LN606@ckd_dasd_e
  09f94	83 bc 24 f0 03
	00 00 01	 cmp	 DWORD PTR ccwseq$[rsp], 1
  09f9c	7e 2f		 jle	 SHORT $LN606@ckd_dasd_e
$LN607@ckd_dasd_e:

; 6050 :         {
; 6051 :             ckd_build_sense (dev, SENSE_CR, 0, 0,

  09f9e	c6 44 24 28 02	 mov	 BYTE PTR [rsp+40], 2
  09fa3	c6 44 24 20 00	 mov	 BYTE PTR [rsp+32], 0
  09fa8	45 33 c9	 xor	 r9d, r9d
  09fab	45 33 c0	 xor	 r8d, r8d
  09fae	b2 80		 mov	 dl, 128			; 00000080H
  09fb0	48 8b 8c 24 c0
	03 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  09fb8	e8 00 00 00 00	 call	 ckd_build_sense

; 6052 :                             FORMAT_0, MESSAGE_2);
; 6053 :             *unitstat = CSW_CE | CSW_DE | CSW_UC;

  09fbd	48 8b 84 24 08
	04 00 00	 mov	 rax, QWORD PTR unitstat$[rsp]
  09fc5	c6 00 0e	 mov	 BYTE PTR [rax], 14

; 6054 :             break;

  09fc8	e9 83 05 00 00	 jmp	 $LN2@ckd_dasd_e
$LN606@ckd_dasd_e:

; 6055 :         }
; 6056 : 
; 6057 :         /* Calculate residual byte count */
; 6058 :         num = (count < 32) ? count : 32;

  09fcd	83 bc 24 e0 03
	00 00 20	 cmp	 DWORD PTR count$[rsp], 32 ; 00000020H
  09fd5	73 10		 jae	 SHORT $LN773@ckd_dasd_e
  09fd7	8b 84 24 e0 03
	00 00		 mov	 eax, DWORD PTR count$[rsp]
  09fde	89 84 24 d4 01
	00 00		 mov	 DWORD PTR tv5115[rsp], eax
  09fe5	eb 0b		 jmp	 SHORT $LN774@ckd_dasd_e
$LN773@ckd_dasd_e:
  09fe7	c7 84 24 d4 01
	00 00 20 00 00
	00		 mov	 DWORD PTR tv5115[rsp], 32 ; 00000020H
$LN774@ckd_dasd_e:
  09ff2	8b 84 24 d4 01
	00 00		 mov	 eax, DWORD PTR tv5115[rsp]
  09ff9	89 44 24 64	 mov	 DWORD PTR num$[rsp], eax

; 6059 :         *residual = count - num;

  09ffd	8b 44 24 64	 mov	 eax, DWORD PTR num$[rsp]
  0a001	8b 8c 24 e0 03
	00 00		 mov	 ecx, DWORD PTR count$[rsp]
  0a008	2b c8		 sub	 ecx, eax
  0a00a	8b c1		 mov	 eax, ecx
  0a00c	48 8b 8c 24 10
	04 00 00	 mov	 rcx, QWORD PTR residual$[rsp]
  0a014	89 01		 mov	 DWORD PTR [rcx], eax

; 6060 :         if (count < 32) *more = 1;

  0a016	83 bc 24 e0 03
	00 00 20	 cmp	 DWORD PTR count$[rsp], 32 ; 00000020H
  0a01e	73 0b		 jae	 SHORT $LN609@ckd_dasd_e
  0a020	48 8b 84 24 00
	04 00 00	 mov	 rax, QWORD PTR more$[rsp]
  0a028	c6 00 01	 mov	 BYTE PTR [rax], 1
$LN609@ckd_dasd_e:

; 6061 : 
; 6062 :         /* Build the buffered error log in the I/O area */
; 6063 :         memset (iobuf, 0, 32);

  0a02b	48 8b bc 24 f8
	03 00 00	 mov	 rdi, QWORD PTR iobuf$[rsp]
  0a033	33 c0		 xor	 eax, eax
  0a035	b9 20 00 00 00	 mov	 ecx, 32			; 00000020H
  0a03a	f3 aa		 rep stosb

; 6064 : 
; 6065 :         /* Return unit status */
; 6066 :         *unitstat = CSW_CE | CSW_DE;

  0a03c	48 8b 84 24 08
	04 00 00	 mov	 rax, QWORD PTR unitstat$[rsp]
  0a044	c6 00 0c	 mov	 BYTE PTR [rax], 12

; 6067 :         break;

  0a047	e9 04 05 00 00	 jmp	 $LN2@ckd_dasd_e
$LN610@ckd_dasd_e:

; 6068 : 
; 6069 :     case 0x87:
; 6070 :     /*---------------------------------------------------------------*/
; 6071 :     /* Set Subsystem Mode                                            */
; 6072 :     /*---------------------------------------------------------------*/
; 6073 : 
; 6074 :         /* Command reject if within the domain of a Locate Record */
; 6075 :         if (dev->ckdlcount > 0)

  0a04c	48 8b 84 24 c0
	03 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  0a054	0f b6 80 02 13
	00 00		 movzx	 eax, BYTE PTR [rax+4866]
  0a05b	85 c0		 test	 eax, eax
  0a05d	7e 2f		 jle	 SHORT $LN611@ckd_dasd_e

; 6076 :         {
; 6077 :             ckd_build_sense (dev, SENSE_CR, 0, 0,

  0a05f	c6 44 24 28 02	 mov	 BYTE PTR [rsp+40], 2
  0a064	c6 44 24 20 00	 mov	 BYTE PTR [rsp+32], 0
  0a069	45 33 c9	 xor	 r9d, r9d
  0a06c	45 33 c0	 xor	 r8d, r8d
  0a06f	b2 80		 mov	 dl, 128			; 00000080H
  0a071	48 8b 8c 24 c0
	03 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  0a079	e8 00 00 00 00	 call	 ckd_build_sense

; 6078 :                             FORMAT_0, MESSAGE_2);
; 6079 :             *unitstat = CSW_CE | CSW_DE | CSW_UC;

  0a07e	48 8b 84 24 08
	04 00 00	 mov	 rax, QWORD PTR unitstat$[rsp]
  0a086	c6 00 0e	 mov	 BYTE PTR [rax], 14

; 6080 :             break;

  0a089	e9 c2 04 00 00	 jmp	 $LN2@ckd_dasd_e
$LN611@ckd_dasd_e:

; 6081 :         }
; 6082 : 
; 6083 :         /* Command reject if not a cached device, first in chain, or */
; 6084 :         /* immediately preceded by Suspend Multipath Connection      */
; 6085 :         /*                                                           */
; 6086 :         /* TBD: Add first in chain and Suspend Multipath check       */
; 6087 :         /*                                                           */
; 6088 :         if ((dev->ckdcu->devt != 0x3990 && dev->ckdcu->devt != 0x2105)
; 6089 :             || (dev->ckdcu->model & 0x07) == 0x02)      /* 3990-1/2  */

  0a08e	48 8b 84 24 c0
	03 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  0a096	48 8b 80 a8 12
	00 00		 mov	 rax, QWORD PTR [rax+4776]
  0a09d	0f b7 40 08	 movzx	 eax, WORD PTR [rax+8]
  0a0a1	3d 90 39 00 00	 cmp	 eax, 14736		; 00003990H
  0a0a6	74 1a		 je	 SHORT $LN614@ckd_dasd_e
  0a0a8	48 8b 84 24 c0
	03 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  0a0b0	48 8b 80 a8 12
	00 00		 mov	 rax, QWORD PTR [rax+4776]
  0a0b7	0f b7 40 08	 movzx	 eax, WORD PTR [rax+8]
  0a0bb	3d 05 21 00 00	 cmp	 eax, 8453		; 00002105H
  0a0c0	75 1b		 jne	 SHORT $LN613@ckd_dasd_e
$LN614@ckd_dasd_e:
  0a0c2	48 8b 84 24 c0
	03 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  0a0ca	48 8b 80 a8 12
	00 00		 mov	 rax, QWORD PTR [rax+4776]
  0a0d1	0f b6 40 0a	 movzx	 eax, BYTE PTR [rax+10]
  0a0d5	83 e0 07	 and	 eax, 7
  0a0d8	83 f8 02	 cmp	 eax, 2
  0a0db	75 2f		 jne	 SHORT $LN612@ckd_dasd_e
$LN613@ckd_dasd_e:

; 6090 :         {
; 6091 :             ckd_build_sense (dev, SENSE_CR, 0, 0,

  0a0dd	c6 44 24 28 02	 mov	 BYTE PTR [rsp+40], 2
  0a0e2	c6 44 24 20 00	 mov	 BYTE PTR [rsp+32], 0
  0a0e7	45 33 c9	 xor	 r9d, r9d
  0a0ea	45 33 c0	 xor	 r8d, r8d
  0a0ed	b2 80		 mov	 dl, 128			; 00000080H
  0a0ef	48 8b 8c 24 c0
	03 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  0a0f7	e8 00 00 00 00	 call	 ckd_build_sense

; 6092 :                             FORMAT_0, MESSAGE_2);
; 6093 :             *unitstat = CSW_CE | CSW_DE | CSW_UC;

  0a0fc	48 8b 84 24 08
	04 00 00	 mov	 rax, QWORD PTR unitstat$[rsp]
  0a104	c6 00 0e	 mov	 BYTE PTR [rax], 14

; 6094 :             break;

  0a107	e9 44 04 00 00	 jmp	 $LN2@ckd_dasd_e
$LN612@ckd_dasd_e:

; 6095 :         }
; 6096 : 
; 6097 :         /* Calculate residual byte count */
; 6098 :         num = (count < 2) ? count : 2;

  0a10c	83 bc 24 e0 03
	00 00 02	 cmp	 DWORD PTR count$[rsp], 2
  0a114	73 10		 jae	 SHORT $LN775@ckd_dasd_e
  0a116	8b 84 24 e0 03
	00 00		 mov	 eax, DWORD PTR count$[rsp]
  0a11d	89 84 24 d8 01
	00 00		 mov	 DWORD PTR tv5151[rsp], eax
  0a124	eb 0b		 jmp	 SHORT $LN776@ckd_dasd_e
$LN775@ckd_dasd_e:
  0a126	c7 84 24 d8 01
	00 00 02 00 00
	00		 mov	 DWORD PTR tv5151[rsp], 2
$LN776@ckd_dasd_e:
  0a131	8b 84 24 d8 01
	00 00		 mov	 eax, DWORD PTR tv5151[rsp]
  0a138	89 44 24 64	 mov	 DWORD PTR num$[rsp], eax

; 6099 :         *residual = count - num;

  0a13c	8b 44 24 64	 mov	 eax, DWORD PTR num$[rsp]
  0a140	8b 8c 24 e0 03
	00 00		 mov	 ecx, DWORD PTR count$[rsp]
  0a147	2b c8		 sub	 ecx, eax
  0a149	8b c1		 mov	 eax, ecx
  0a14b	48 8b 8c 24 10
	04 00 00	 mov	 rcx, QWORD PTR residual$[rsp]
  0a153	89 01		 mov	 DWORD PTR [rcx], eax

; 6100 : 
; 6101 :         /* Control information length must be at least 2 bytes */
; 6102 :         if (count < 2)

  0a155	83 bc 24 e0 03
	00 00 02	 cmp	 DWORD PTR count$[rsp], 2
  0a15d	73 2f		 jae	 SHORT $LN615@ckd_dasd_e

; 6103 :         {
; 6104 :             ckd_build_sense (dev, SENSE_CR, 0, 0,

  0a15f	c6 44 24 28 03	 mov	 BYTE PTR [rsp+40], 3
  0a164	c6 44 24 20 00	 mov	 BYTE PTR [rsp+32], 0
  0a169	45 33 c9	 xor	 r9d, r9d
  0a16c	45 33 c0	 xor	 r8d, r8d
  0a16f	b2 80		 mov	 dl, 128			; 00000080H
  0a171	48 8b 8c 24 c0
	03 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  0a179	e8 00 00 00 00	 call	 ckd_build_sense

; 6105 :                             FORMAT_0, MESSAGE_3);
; 6106 :             *unitstat = CSW_CE | CSW_DE | CSW_UC;

  0a17e	48 8b 84 24 08
	04 00 00	 mov	 rax, QWORD PTR unitstat$[rsp]
  0a186	c6 00 0e	 mov	 BYTE PTR [rax], 14

; 6107 :             break;

  0a189	e9 c2 03 00 00	 jmp	 $LN2@ckd_dasd_e
$LN615@ckd_dasd_e:

; 6108 :         }
; 6109 : 
; 6110 :         /* TBD / MGD:   Complete checks for Set Subsystem Mode      */
; 6111 :         /*              covering message required flag and read     */
; 6112 :         /*              message id check                            */
; 6113 : 
; 6114 :         /* Validate operands -- Refer to 2105 validation sequence   */
; 6115 :         if (((iobuf[0] & 0x02) != 0) || ((iobuf[1] & 0x07) != 0)    ||
; 6116 :             ((iobuf[1] & 0x18) != 0) /* zero unless in TPF mode */  ||
; 6117 :             ((iobuf[0] & 0xE0) > 0xA0)                              ||
; 6118 :             ((iobuf[0] & 0x1C) > 0x14)                              ||
; 6119 :             ((iobuf[1] & 0xE0) > 0xA0)                              ||
; 6120 :             ((iobuf[1] & 0x18) == 0x18) /* TPF reserved */          ||
; 6121 :             (((iobuf[0] & 0x10) != 0) && (
; 6122 :                ((iobuf[0] & 0xE0) >  0x80) ||
; 6123 :                ((iobuf[0] & 0xE0) <  0x40) ||
; 6124 :                ((iobuf[0] & 0x1C) != 0x10) ||
; 6125 :                ((iobuf[1] & 0xE0) >  0xA0) ||
; 6126 :                ((iobuf[1] & 0xE0) <  0x40) ||
; 6127 :                ((iobuf[1] & 0xE0) == 0x60)))                        ||
; 6128 :             (((iobuf[0] & 0xE0) != 0) && (
; 6129 :                ((iobuf[0] & 0x1C) != 0) || (iobuf[1] != 0)))        ||

  0a18e	b8 01 00 00 00	 mov	 eax, 1
  0a193	48 6b c0 00	 imul	 rax, rax, 0
  0a197	48 8b 8c 24 f8
	03 00 00	 mov	 rcx, QWORD PTR iobuf$[rsp]
  0a19f	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  0a1a3	83 e0 02	 and	 eax, 2
  0a1a6	85 c0		 test	 eax, eax
  0a1a8	0f 85 48 02 00
	00		 jne	 $LN617@ckd_dasd_e
  0a1ae	b8 01 00 00 00	 mov	 eax, 1
  0a1b3	48 6b c0 01	 imul	 rax, rax, 1
  0a1b7	48 8b 8c 24 f8
	03 00 00	 mov	 rcx, QWORD PTR iobuf$[rsp]
  0a1bf	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  0a1c3	83 e0 07	 and	 eax, 7
  0a1c6	85 c0		 test	 eax, eax
  0a1c8	0f 85 28 02 00
	00		 jne	 $LN617@ckd_dasd_e
  0a1ce	b8 01 00 00 00	 mov	 eax, 1
  0a1d3	48 6b c0 01	 imul	 rax, rax, 1
  0a1d7	48 8b 8c 24 f8
	03 00 00	 mov	 rcx, QWORD PTR iobuf$[rsp]
  0a1df	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  0a1e3	83 e0 18	 and	 eax, 24
  0a1e6	85 c0		 test	 eax, eax
  0a1e8	0f 85 08 02 00
	00		 jne	 $LN617@ckd_dasd_e
  0a1ee	b8 01 00 00 00	 mov	 eax, 1
  0a1f3	48 6b c0 00	 imul	 rax, rax, 0
  0a1f7	48 8b 8c 24 f8
	03 00 00	 mov	 rcx, QWORD PTR iobuf$[rsp]
  0a1ff	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  0a203	25 e0 00 00 00	 and	 eax, 224		; 000000e0H
  0a208	3d a0 00 00 00	 cmp	 eax, 160		; 000000a0H
  0a20d	0f 8f e3 01 00
	00		 jg	 $LN617@ckd_dasd_e
  0a213	b8 01 00 00 00	 mov	 eax, 1
  0a218	48 6b c0 00	 imul	 rax, rax, 0
  0a21c	48 8b 8c 24 f8
	03 00 00	 mov	 rcx, QWORD PTR iobuf$[rsp]
  0a224	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  0a228	83 e0 1c	 and	 eax, 28
  0a22b	83 f8 14	 cmp	 eax, 20
  0a22e	0f 8f c2 01 00
	00		 jg	 $LN617@ckd_dasd_e
  0a234	b8 01 00 00 00	 mov	 eax, 1
  0a239	48 6b c0 01	 imul	 rax, rax, 1
  0a23d	48 8b 8c 24 f8
	03 00 00	 mov	 rcx, QWORD PTR iobuf$[rsp]
  0a245	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  0a249	25 e0 00 00 00	 and	 eax, 224		; 000000e0H
  0a24e	3d a0 00 00 00	 cmp	 eax, 160		; 000000a0H
  0a253	0f 8f 9d 01 00
	00		 jg	 $LN617@ckd_dasd_e
  0a259	b8 01 00 00 00	 mov	 eax, 1
  0a25e	48 6b c0 01	 imul	 rax, rax, 1
  0a262	48 8b 8c 24 f8
	03 00 00	 mov	 rcx, QWORD PTR iobuf$[rsp]
  0a26a	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  0a26e	83 e0 18	 and	 eax, 24
  0a271	83 f8 18	 cmp	 eax, 24
  0a274	0f 84 7c 01 00
	00		 je	 $LN617@ckd_dasd_e
  0a27a	b8 01 00 00 00	 mov	 eax, 1
  0a27f	48 6b c0 00	 imul	 rax, rax, 0
  0a283	48 8b 8c 24 f8
	03 00 00	 mov	 rcx, QWORD PTR iobuf$[rsp]
  0a28b	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  0a28f	83 e0 10	 and	 eax, 16
  0a292	85 c0		 test	 eax, eax
  0a294	0f 84 d4 00 00
	00		 je	 $LN618@ckd_dasd_e
  0a29a	b8 01 00 00 00	 mov	 eax, 1
  0a29f	48 6b c0 00	 imul	 rax, rax, 0
  0a2a3	48 8b 8c 24 f8
	03 00 00	 mov	 rcx, QWORD PTR iobuf$[rsp]
  0a2ab	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  0a2af	25 e0 00 00 00	 and	 eax, 224		; 000000e0H
  0a2b4	3d 80 00 00 00	 cmp	 eax, 128		; 00000080H
  0a2b9	0f 8f 37 01 00
	00		 jg	 $LN617@ckd_dasd_e
  0a2bf	b8 01 00 00 00	 mov	 eax, 1
  0a2c4	48 6b c0 00	 imul	 rax, rax, 0
  0a2c8	48 8b 8c 24 f8
	03 00 00	 mov	 rcx, QWORD PTR iobuf$[rsp]
  0a2d0	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  0a2d4	25 e0 00 00 00	 and	 eax, 224		; 000000e0H
  0a2d9	83 f8 40	 cmp	 eax, 64			; 00000040H
  0a2dc	0f 8c 14 01 00
	00		 jl	 $LN617@ckd_dasd_e
  0a2e2	b8 01 00 00 00	 mov	 eax, 1
  0a2e7	48 6b c0 00	 imul	 rax, rax, 0
  0a2eb	48 8b 8c 24 f8
	03 00 00	 mov	 rcx, QWORD PTR iobuf$[rsp]
  0a2f3	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  0a2f7	83 e0 1c	 and	 eax, 28
  0a2fa	83 f8 10	 cmp	 eax, 16
  0a2fd	0f 85 f3 00 00
	00		 jne	 $LN617@ckd_dasd_e
  0a303	b8 01 00 00 00	 mov	 eax, 1
  0a308	48 6b c0 01	 imul	 rax, rax, 1
  0a30c	48 8b 8c 24 f8
	03 00 00	 mov	 rcx, QWORD PTR iobuf$[rsp]
  0a314	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  0a318	25 e0 00 00 00	 and	 eax, 224		; 000000e0H
  0a31d	3d a0 00 00 00	 cmp	 eax, 160		; 000000a0H
  0a322	0f 8f ce 00 00
	00		 jg	 $LN617@ckd_dasd_e
  0a328	b8 01 00 00 00	 mov	 eax, 1
  0a32d	48 6b c0 01	 imul	 rax, rax, 1
  0a331	48 8b 8c 24 f8
	03 00 00	 mov	 rcx, QWORD PTR iobuf$[rsp]
  0a339	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  0a33d	25 e0 00 00 00	 and	 eax, 224		; 000000e0H
  0a342	83 f8 40	 cmp	 eax, 64			; 00000040H
  0a345	0f 8c ab 00 00
	00		 jl	 $LN617@ckd_dasd_e
  0a34b	b8 01 00 00 00	 mov	 eax, 1
  0a350	48 6b c0 01	 imul	 rax, rax, 1
  0a354	48 8b 8c 24 f8
	03 00 00	 mov	 rcx, QWORD PTR iobuf$[rsp]
  0a35c	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  0a360	25 e0 00 00 00	 and	 eax, 224		; 000000e0H
  0a365	83 f8 60	 cmp	 eax, 96			; 00000060H
  0a368	0f 84 88 00 00
	00		 je	 $LN617@ckd_dasd_e
$LN618@ckd_dasd_e:
  0a36e	b8 01 00 00 00	 mov	 eax, 1
  0a373	48 6b c0 00	 imul	 rax, rax, 0
  0a377	48 8b 8c 24 f8
	03 00 00	 mov	 rcx, QWORD PTR iobuf$[rsp]
  0a37f	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  0a383	25 e0 00 00 00	 and	 eax, 224		; 000000e0H
  0a388	85 c0		 test	 eax, eax
  0a38a	74 35		 je	 SHORT $LN619@ckd_dasd_e
  0a38c	b8 01 00 00 00	 mov	 eax, 1
  0a391	48 6b c0 00	 imul	 rax, rax, 0
  0a395	48 8b 8c 24 f8
	03 00 00	 mov	 rcx, QWORD PTR iobuf$[rsp]
  0a39d	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  0a3a1	83 e0 1c	 and	 eax, 28
  0a3a4	85 c0		 test	 eax, eax
  0a3a6	75 4e		 jne	 SHORT $LN617@ckd_dasd_e
  0a3a8	b8 01 00 00 00	 mov	 eax, 1
  0a3ad	48 6b c0 01	 imul	 rax, rax, 1
  0a3b1	48 8b 8c 24 f8
	03 00 00	 mov	 rcx, QWORD PTR iobuf$[rsp]
  0a3b9	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  0a3bd	85 c0		 test	 eax, eax
  0a3bf	75 35		 jne	 SHORT $LN617@ckd_dasd_e
$LN619@ckd_dasd_e:
  0a3c1	b8 01 00 00 00	 mov	 eax, 1
  0a3c6	48 6b c0 00	 imul	 rax, rax, 0
  0a3ca	48 8b 8c 24 f8
	03 00 00	 mov	 rcx, QWORD PTR iobuf$[rsp]
  0a3d2	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  0a3d6	83 e0 1c	 and	 eax, 28
  0a3d9	85 c0		 test	 eax, eax
  0a3db	74 48		 je	 SHORT $LN616@ckd_dasd_e
  0a3dd	b8 01 00 00 00	 mov	 eax, 1
  0a3e2	48 6b c0 01	 imul	 rax, rax, 1
  0a3e6	48 8b 8c 24 f8
	03 00 00	 mov	 rcx, QWORD PTR iobuf$[rsp]
  0a3ee	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  0a3f2	85 c0		 test	 eax, eax
  0a3f4	74 2f		 je	 SHORT $LN616@ckd_dasd_e
$LN617@ckd_dasd_e:

; 6130 :             (((iobuf[0] & 0x1C) != 0) && (iobuf[1] != 0)))
; 6131 :         {
; 6132 : 
; 6133 :             ckd_build_sense (dev, SENSE_CR, 0, 0,

  0a3f6	c6 44 24 28 04	 mov	 BYTE PTR [rsp+40], 4
  0a3fb	c6 44 24 20 00	 mov	 BYTE PTR [rsp+32], 0
  0a400	45 33 c9	 xor	 r9d, r9d
  0a403	45 33 c0	 xor	 r8d, r8d
  0a406	b2 80		 mov	 dl, 128			; 00000080H
  0a408	48 8b 8c 24 c0
	03 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  0a410	e8 00 00 00 00	 call	 ckd_build_sense

; 6134 :                             FORMAT_0, MESSAGE_4);
; 6135 :             *unitstat = CSW_CE | CSW_DE | CSW_UC;

  0a415	48 8b 84 24 08
	04 00 00	 mov	 rax, QWORD PTR unitstat$[rsp]
  0a41d	c6 00 0e	 mov	 BYTE PTR [rax], 14

; 6136 :             break;

  0a420	e9 2b 01 00 00	 jmp	 $LN2@ckd_dasd_e
$LN616@ckd_dasd_e:

; 6137 :         }
; 6138 : 
; 6139 :         /* TBD / Future:        Cache Fast Write Data Control        */
; 6140 : 
; 6141 :         /* Treat as NOP and Return unit status */
; 6142 :         *unitstat = CSW_CE | CSW_DE;

  0a425	48 8b 84 24 08
	04 00 00	 mov	 rax, QWORD PTR unitstat$[rsp]
  0a42d	c6 00 0c	 mov	 BYTE PTR [rax], 12

; 6143 :         break;

  0a430	e9 1b 01 00 00	 jmp	 $LN2@ckd_dasd_e
$LN620@ckd_dasd_e:

; 6144 : 
; 6145 :     case 0xFA:
; 6146 :     /*---------------------------------------------------------------*/
; 6147 :     /* READ CONFIGURATION DATA                                       */
; 6148 :     /*---------------------------------------------------------------*/
; 6149 :         /* Command reject if within the domain of a Locate Record */
; 6150 :         if (dev->ckdlcount > 0)

  0a435	48 8b 84 24 c0
	03 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  0a43d	0f b6 80 02 13
	00 00		 movzx	 eax, BYTE PTR [rax+4866]
  0a444	85 c0		 test	 eax, eax
  0a446	7e 2f		 jle	 SHORT $LN621@ckd_dasd_e

; 6151 :         {
; 6152 :             ckd_build_sense (dev, SENSE_CR, 0, 0,

  0a448	c6 44 24 28 02	 mov	 BYTE PTR [rsp+40], 2
  0a44d	c6 44 24 20 00	 mov	 BYTE PTR [rsp+32], 0
  0a452	45 33 c9	 xor	 r9d, r9d
  0a455	45 33 c0	 xor	 r8d, r8d
  0a458	b2 80		 mov	 dl, 128			; 00000080H
  0a45a	48 8b 8c 24 c0
	03 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  0a462	e8 00 00 00 00	 call	 ckd_build_sense

; 6153 :                             FORMAT_0, MESSAGE_2);
; 6154 :             *unitstat = CSW_CE | CSW_DE | CSW_UC;

  0a467	48 8b 84 24 08
	04 00 00	 mov	 rax, QWORD PTR unitstat$[rsp]
  0a46f	c6 00 0e	 mov	 BYTE PTR [rax], 14

; 6155 :             break;

  0a472	e9 d9 00 00 00	 jmp	 $LN2@ckd_dasd_e
$LN621@ckd_dasd_e:

; 6156 :         }
; 6157 : 
; 6158 :         /* Build the configuration data area */
; 6159 :         num = dev->rcd( dev, iobuf, count );

  0a477	44 8b 84 24 e0
	03 00 00	 mov	 r8d, DWORD PTR count$[rsp]
  0a47f	48 8b 94 24 f8
	03 00 00	 mov	 rdx, QWORD PTR iobuf$[rsp]
  0a487	48 8b 8c 24 c0
	03 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  0a48f	48 8b 84 24 c0
	03 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  0a497	ff 90 b8 02 00
	00		 call	 QWORD PTR [rax+696]
  0a49d	89 44 24 64	 mov	 DWORD PTR num$[rsp], eax

; 6160 : 
; 6161 :         /* Calculate residual byte count */
; 6162 :         *residual = count < num ? 0 : count - num;

  0a4a1	8b 44 24 64	 mov	 eax, DWORD PTR num$[rsp]
  0a4a5	39 84 24 e0 03
	00 00		 cmp	 DWORD PTR count$[rsp], eax
  0a4ac	73 0d		 jae	 SHORT $LN777@ckd_dasd_e
  0a4ae	c7 84 24 dc 01
	00 00 00 00 00
	00		 mov	 DWORD PTR tv5275[rsp], 0
  0a4b9	eb 16		 jmp	 SHORT $LN778@ckd_dasd_e
$LN777@ckd_dasd_e:
  0a4bb	8b 44 24 64	 mov	 eax, DWORD PTR num$[rsp]
  0a4bf	8b 8c 24 e0 03
	00 00		 mov	 ecx, DWORD PTR count$[rsp]
  0a4c6	2b c8		 sub	 ecx, eax
  0a4c8	8b c1		 mov	 eax, ecx
  0a4ca	89 84 24 dc 01
	00 00		 mov	 DWORD PTR tv5275[rsp], eax
$LN778@ckd_dasd_e:
  0a4d1	48 8b 84 24 10
	04 00 00	 mov	 rax, QWORD PTR residual$[rsp]
  0a4d9	8b 8c 24 dc 01
	00 00		 mov	 ecx, DWORD PTR tv5275[rsp]
  0a4e0	89 08		 mov	 DWORD PTR [rax], ecx

; 6163 :         *more = count < num;

  0a4e2	8b 44 24 64	 mov	 eax, DWORD PTR num$[rsp]
  0a4e6	39 84 24 e0 03
	00 00		 cmp	 DWORD PTR count$[rsp], eax
  0a4ed	73 0d		 jae	 SHORT $LN779@ckd_dasd_e
  0a4ef	c7 84 24 e0 01
	00 00 01 00 00
	00		 mov	 DWORD PTR tv5277[rsp], 1
  0a4fa	eb 0b		 jmp	 SHORT $LN780@ckd_dasd_e
$LN779@ckd_dasd_e:
  0a4fc	c7 84 24 e0 01
	00 00 00 00 00
	00		 mov	 DWORD PTR tv5277[rsp], 0
$LN780@ckd_dasd_e:
  0a507	48 8b 84 24 00
	04 00 00	 mov	 rax, QWORD PTR more$[rsp]
  0a50f	0f b6 8c 24 e0
	01 00 00	 movzx	 ecx, BYTE PTR tv5277[rsp]
  0a517	88 08		 mov	 BYTE PTR [rax], cl

; 6164 : 
; 6165 :         /* Return unit status */
; 6166 :         *unitstat = CSW_CE | CSW_DE;

  0a519	48 8b 84 24 08
	04 00 00	 mov	 rax, QWORD PTR unitstat$[rsp]
  0a521	c6 00 0c	 mov	 BYTE PTR [rax], 12

; 6167 :         break;

  0a524	eb 2a		 jmp	 SHORT $LN2@ckd_dasd_e
$LN622@ckd_dasd_e:

; 6168 : 
; 6169 :     default:
; 6170 :     /*---------------------------------------------------------------*/
; 6171 :     /* INVALID OPERATION                                             */
; 6172 :     /*---------------------------------------------------------------*/
; 6173 :         /* Set command reject sense byte, and unit check status */
; 6174 :         ckd_build_sense (dev, SENSE_CR, 0, 0,

  0a526	c6 44 24 28 01	 mov	 BYTE PTR [rsp+40], 1
  0a52b	c6 44 24 20 00	 mov	 BYTE PTR [rsp+32], 0
  0a530	45 33 c9	 xor	 r9d, r9d
  0a533	45 33 c0	 xor	 r8d, r8d
  0a536	b2 80		 mov	 dl, 128			; 00000080H
  0a538	48 8b 8c 24 c0
	03 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  0a540	e8 00 00 00 00	 call	 ckd_build_sense

; 6175 :                         FORMAT_0, MESSAGE_1);
; 6176 :         *unitstat = CSW_CE | CSW_DE | CSW_UC;

  0a545	48 8b 84 24 08
	04 00 00	 mov	 rax, QWORD PTR unitstat$[rsp]
  0a54d	c6 00 0e	 mov	 BYTE PTR [rax], 14
$LN2@ckd_dasd_e:

; 6177 : 
; 6178 :     } /* end switch(code) */
; 6179 : 
; 6180 :     /* Reset the flags which ensure correct positioning for write
; 6181 :        commands */
; 6182 : 
; 6183 :     /* Reset search HA flag if command was not SEARCH HA EQUAL
; 6184 :        or WRITE HA */
; 6185 :     if ((code & 0x7F) != 0x39 && (code & 0x7F) != 0x19)

  0a550	0f b6 84 24 c8
	03 00 00	 movzx	 eax, BYTE PTR code$[rsp]
  0a558	83 e0 7f	 and	 eax, 127		; 0000007fH
  0a55b	83 f8 39	 cmp	 eax, 57			; 00000039H
  0a55e	74 30		 je	 SHORT $LN623@ckd_dasd_e
  0a560	0f b6 84 24 c8
	03 00 00	 movzx	 eax, BYTE PTR code$[rsp]
  0a568	83 e0 7f	 and	 eax, 127		; 0000007fH
  0a56b	83 f8 19	 cmp	 eax, 25
  0a56e	74 20		 je	 SHORT $LN623@ckd_dasd_e

; 6186 :         dev->ckdhaeq = 0;

  0a570	48 8b 84 24 c0
	03 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  0a578	8b 80 14 13 00
	00		 mov	 eax, DWORD PTR [rax+4884]
  0a57e	0f ba f0 0b	 btr	 eax, 11
  0a582	48 8b 8c 24 c0
	03 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  0a58a	89 81 14 13 00
	00		 mov	 DWORD PTR [rcx+4884], eax
$LN623@ckd_dasd_e:

; 6187 : 
; 6188 :     /* Reset search id flag if command was not SEARCH ID EQUAL,
; 6189 :        READ/WRITE KEY AND DATA, or READ/WRITE DATA */
; 6190 :     if ((code & 0x7F) != 0x31
; 6191 :         && (code & 0x7F) != 0x0E && (code & 0x7F) != 0x0D
; 6192 :         && (code & 0x7F) != 0x06 && (code & 0x7F) != 0x05)

  0a590	0f b6 84 24 c8
	03 00 00	 movzx	 eax, BYTE PTR code$[rsp]
  0a598	83 e0 7f	 and	 eax, 127		; 0000007fH
  0a59b	83 f8 31	 cmp	 eax, 49			; 00000031H
  0a59e	74 60		 je	 SHORT $LN624@ckd_dasd_e
  0a5a0	0f b6 84 24 c8
	03 00 00	 movzx	 eax, BYTE PTR code$[rsp]
  0a5a8	83 e0 7f	 and	 eax, 127		; 0000007fH
  0a5ab	83 f8 0e	 cmp	 eax, 14
  0a5ae	74 50		 je	 SHORT $LN624@ckd_dasd_e
  0a5b0	0f b6 84 24 c8
	03 00 00	 movzx	 eax, BYTE PTR code$[rsp]
  0a5b8	83 e0 7f	 and	 eax, 127		; 0000007fH
  0a5bb	83 f8 0d	 cmp	 eax, 13
  0a5be	74 40		 je	 SHORT $LN624@ckd_dasd_e
  0a5c0	0f b6 84 24 c8
	03 00 00	 movzx	 eax, BYTE PTR code$[rsp]
  0a5c8	83 e0 7f	 and	 eax, 127		; 0000007fH
  0a5cb	83 f8 06	 cmp	 eax, 6
  0a5ce	74 30		 je	 SHORT $LN624@ckd_dasd_e
  0a5d0	0f b6 84 24 c8
	03 00 00	 movzx	 eax, BYTE PTR code$[rsp]
  0a5d8	83 e0 7f	 and	 eax, 127		; 0000007fH
  0a5db	83 f8 05	 cmp	 eax, 5
  0a5de	74 20		 je	 SHORT $LN624@ckd_dasd_e

; 6193 :         dev->ckdideq = 0;

  0a5e0	48 8b 84 24 c0
	03 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  0a5e8	8b 80 14 13 00
	00		 mov	 eax, DWORD PTR [rax+4884]
  0a5ee	0f ba f0 0c	 btr	 eax, 12
  0a5f2	48 8b 8c 24 c0
	03 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  0a5fa	89 81 14 13 00
	00		 mov	 DWORD PTR [rcx+4884], eax
$LN624@ckd_dasd_e:

; 6194 : 
; 6195 :     /* Reset search key flag if command was not SEARCH KEY EQUAL
; 6196 :        or READ/WRITE DATA */
; 6197 :     if ((code & 0x7F) != 0x29
; 6198 :         && (code & 0x7F) != 0x06 && (code & 0x7F) != 0x05)

  0a600	0f b6 84 24 c8
	03 00 00	 movzx	 eax, BYTE PTR code$[rsp]
  0a608	83 e0 7f	 and	 eax, 127		; 0000007fH
  0a60b	83 f8 29	 cmp	 eax, 41			; 00000029H
  0a60e	74 40		 je	 SHORT $LN625@ckd_dasd_e
  0a610	0f b6 84 24 c8
	03 00 00	 movzx	 eax, BYTE PTR code$[rsp]
  0a618	83 e0 7f	 and	 eax, 127		; 0000007fH
  0a61b	83 f8 06	 cmp	 eax, 6
  0a61e	74 30		 je	 SHORT $LN625@ckd_dasd_e
  0a620	0f b6 84 24 c8
	03 00 00	 movzx	 eax, BYTE PTR code$[rsp]
  0a628	83 e0 7f	 and	 eax, 127		; 0000007fH
  0a62b	83 f8 05	 cmp	 eax, 5
  0a62e	74 20		 je	 SHORT $LN625@ckd_dasd_e

; 6199 :         dev->ckdkyeq = 0;

  0a630	48 8b 84 24 c0
	03 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  0a638	8b 80 14 13 00
	00		 mov	 eax, DWORD PTR [rax+4884]
  0a63e	0f ba f0 0d	 btr	 eax, 13
  0a642	48 8b 8c 24 c0
	03 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  0a64a	89 81 14 13 00
	00		 mov	 DWORD PTR [rcx+4884], eax
$LN625@ckd_dasd_e:

; 6200 : 
; 6201 :     /* Reset write CKD flag if command was not WRITE R0 or WRITE CKD */
; 6202 :     if (code != 0x15 && code != 0x1D)

  0a650	0f b6 84 24 c8
	03 00 00	 movzx	 eax, BYTE PTR code$[rsp]
  0a658	83 f8 15	 cmp	 eax, 21
  0a65b	74 2d		 je	 SHORT $LN626@ckd_dasd_e
  0a65d	0f b6 84 24 c8
	03 00 00	 movzx	 eax, BYTE PTR code$[rsp]
  0a665	83 f8 1d	 cmp	 eax, 29
  0a668	74 20		 je	 SHORT $LN626@ckd_dasd_e

; 6203 :         dev->ckdwckd = 0;

  0a66a	48 8b 84 24 c0
	03 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  0a672	8b 80 14 13 00
	00		 mov	 eax, DWORD PTR [rax+4884]
  0a678	0f ba f0 0e	 btr	 eax, 14
  0a67c	48 8b 8c 24 c0
	03 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  0a684	89 81 14 13 00
	00		 mov	 DWORD PTR [rcx+4884], eax
$LN626@ckd_dasd_e:

; 6204 : 
; 6205 :     /* If within the domain of a locate record then decrement the
; 6206 :        count of CCWs remaining to be processed within the domain */
; 6207 :     if (dev->ckdlcount > 0 && code != 0x047 && code != 0x4B && code != 0xe7)

  0a68a	48 8b 84 24 c0
	03 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  0a692	0f b6 80 02 13
	00 00		 movzx	 eax, BYTE PTR [rax+4866]
  0a699	85 c0		 test	 eax, eax
  0a69b	0f 8e 35 01 00
	00		 jle	 $LN627@ckd_dasd_e
  0a6a1	0f b6 84 24 c8
	03 00 00	 movzx	 eax, BYTE PTR code$[rsp]
  0a6a9	83 f8 47	 cmp	 eax, 71			; 00000047H
  0a6ac	0f 84 24 01 00
	00		 je	 $LN627@ckd_dasd_e
  0a6b2	0f b6 84 24 c8
	03 00 00	 movzx	 eax, BYTE PTR code$[rsp]
  0a6ba	83 f8 4b	 cmp	 eax, 75			; 0000004bH
  0a6bd	0f 84 13 01 00
	00		 je	 $LN627@ckd_dasd_e
  0a6c3	0f b6 84 24 c8
	03 00 00	 movzx	 eax, BYTE PTR code$[rsp]
  0a6cb	3d e7 00 00 00	 cmp	 eax, 231		; 000000e7H
  0a6d0	0f 84 00 01 00
	00		 je	 $LN627@ckd_dasd_e

; 6208 :     {
; 6209 :         /* Decrement the count of CCWs remaining in the domain */
; 6210 :         if (code == 0x92)

  0a6d6	0f b6 84 24 c8
	03 00 00	 movzx	 eax, BYTE PTR code$[rsp]
  0a6de	3d 92 00 00 00	 cmp	 eax, 146		; 00000092H
  0a6e3	75 79		 jne	 SHORT $LN628@ckd_dasd_e

; 6211 :         {
; 6212 :             if (!(flags & CCW_FLAGS_CC))

  0a6e5	0f b6 84 24 d0
	03 00 00	 movzx	 eax, BYTE PTR flags$[rsp]
  0a6ed	83 e0 40	 and	 eax, 64			; 00000040H
  0a6f0	85 c0		 test	 eax, eax
  0a6f2	75 21		 jne	 SHORT $LN630@ckd_dasd_e

; 6213 :                 dev->ckdlcount--;

  0a6f4	48 8b 84 24 c0
	03 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  0a6fc	0f b6 80 02 13
	00 00		 movzx	 eax, BYTE PTR [rax+4866]
  0a703	fe c8		 dec	 al
  0a705	48 8b 8c 24 c0
	03 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  0a70d	88 81 02 13 00
	00		 mov	 BYTE PTR [rcx+4866], al
  0a713	eb 47		 jmp	 SHORT $LN631@ckd_dasd_e
$LN630@ckd_dasd_e:

; 6214 :             else
; 6215 :                 if (dev->ckdextcd != 0x0a && dev->ckdxcode != 0x0e)

  0a715	48 8b 84 24 c0
	03 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  0a71d	0f b6 80 03 13
	00 00		 movzx	 eax, BYTE PTR [rax+4867]
  0a724	83 f8 0a	 cmp	 eax, 10
  0a727	74 33		 je	 SHORT $LN632@ckd_dasd_e
  0a729	48 8b 84 24 c0
	03 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  0a731	0f b6 80 e8 12
	00 00		 movzx	 eax, BYTE PTR [rax+4840]
  0a738	83 f8 0e	 cmp	 eax, 14
  0a73b	74 1f		 je	 SHORT $LN632@ckd_dasd_e

; 6216 :                     dev->ckdlcount--;

  0a73d	48 8b 84 24 c0
	03 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  0a745	0f b6 80 02 13
	00 00		 movzx	 eax, BYTE PTR [rax+4866]
  0a74c	fe c8		 dec	 al
  0a74e	48 8b 8c 24 c0
	03 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  0a756	88 81 02 13 00
	00		 mov	 BYTE PTR [rcx+4866], al
$LN632@ckd_dasd_e:
$LN631@ckd_dasd_e:

; 6217 :         }

  0a75c	eb 1f		 jmp	 SHORT $LN629@ckd_dasd_e
$LN628@ckd_dasd_e:

; 6218 :         else
; 6219 :             dev->ckdlcount--;

  0a75e	48 8b 84 24 c0
	03 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  0a766	0f b6 80 02 13
	00 00		 movzx	 eax, BYTE PTR [rax+4866]
  0a76d	fe c8		 dec	 al
  0a76f	48 8b 8c 24 c0
	03 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  0a777	88 81 02 13 00
	00		 mov	 BYTE PTR [rcx+4866], al
$LN629@ckd_dasd_e:

; 6220 : 
; 6221 :         /* Command reject with incomplete domain if CCWs remain
; 6222 :            but command chaining is not specified */
; 6223 :         if (dev->ckdlcount > 0 && (flags & CCW_FLAGS_CC) == 0 &&

  0a77d	48 8b 84 24 c0
	03 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  0a785	0f b6 80 02 13
	00 00		 movzx	 eax, BYTE PTR [rax+4866]
  0a78c	85 c0		 test	 eax, eax
  0a78e	7e 46		 jle	 SHORT $LN633@ckd_dasd_e
  0a790	0f b6 84 24 d0
	03 00 00	 movzx	 eax, BYTE PTR flags$[rsp]
  0a798	83 e0 40	 and	 eax, 64			; 00000040H
  0a79b	85 c0		 test	 eax, eax
  0a79d	75 37		 jne	 SHORT $LN633@ckd_dasd_e
  0a79f	0f b6 84 24 c8
	03 00 00	 movzx	 eax, BYTE PTR code$[rsp]
  0a7a7	83 f8 02	 cmp	 eax, 2
  0a7aa	74 2a		 je	 SHORT $LN633@ckd_dasd_e

; 6224 :             code != 0x02)
; 6225 :         {
; 6226 :             ckd_build_sense (dev, SENSE_CR | SENSE_OC, 0, 0, 0, 0);

  0a7ac	c6 44 24 28 00	 mov	 BYTE PTR [rsp+40], 0
  0a7b1	c6 44 24 20 00	 mov	 BYTE PTR [rsp+32], 0
  0a7b6	45 33 c9	 xor	 r9d, r9d
  0a7b9	45 33 c0	 xor	 r8d, r8d
  0a7bc	b2 81		 mov	 dl, 129			; 00000081H
  0a7be	48 8b 8c 24 c0
	03 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  0a7c6	e8 00 00 00 00	 call	 ckd_build_sense

; 6227 :             *unitstat = CSW_CE | CSW_DE | CSW_UC;

  0a7cb	48 8b 84 24 08
	04 00 00	 mov	 rax, QWORD PTR unitstat$[rsp]
  0a7d3	c6 00 0e	 mov	 BYTE PTR [rax], 14
$LN633@ckd_dasd_e:
$LN627@ckd_dasd_e:
$LN1@ckd_dasd_e:

; 6228 :         }
; 6229 :     } /* end if(ckdlcount) */
; 6230 : 
; 6231 : } /* end function ckd_dasd_execute_ccw */

  0a7d6	48 8b 8c 24 90
	03 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  0a7de	48 33 cc	 xor	 rcx, rsp
  0a7e1	e8 00 00 00 00	 call	 __security_check_cookie
  0a7e6	48 81 c4 a8 03
	00 00		 add	 rsp, 936		; 000003a8H
  0a7ed	5f		 pop	 rdi
  0a7ee	5e		 pop	 rsi
  0a7ef	c3		 ret	 0
$LN784@ckd_dasd_e:
  0a7f0	00 00 00 00	 DD	 $LN396@ckd_dasd_e
  0a7f4	00 00 00 00	 DD	 $LN58@ckd_dasd_e
  0a7f8	00 00 00 00	 DD	 $LN67@ckd_dasd_e
  0a7fc	00 00 00 00	 DD	 $LN586@ckd_dasd_e
  0a800	00 00 00 00	 DD	 $LN317@ckd_dasd_e
  0a804	00 00 00 00	 DD	 $LN73@ckd_dasd_e
  0a808	00 00 00 00	 DD	 $LN228@ckd_dasd_e
  0a80c	00 00 00 00	 DD	 $LN229@ckd_dasd_e
  0a810	00 00 00 00	 DD	 $LN350@ckd_dasd_e
  0a814	00 00 00 00	 DD	 $LN91@ckd_dasd_e
  0a818	00 00 00 00	 DD	 $LN378@ckd_dasd_e
  0a81c	00 00 00 00	 DD	 $LN110@ckd_dasd_e
  0a820	00 00 00 00	 DD	 $LN246@ckd_dasd_e
  0a824	00 00 00 00	 DD	 $LN581@ckd_dasd_e
  0a828	00 00 00 00	 DD	 $LN385@ckd_dasd_e
  0a82c	00 00 00 00	 DD	 $LN120@ckd_dasd_e
  0a830	00 00 00 00	 DD	 $LN69@ckd_dasd_e
  0a834	00 00 00 00	 DD	 $LN146@ckd_dasd_e
  0a838	00 00 00 00	 DD	 $LN136@ckd_dasd_e
  0a83c	00 00 00 00	 DD	 $LN230@ckd_dasd_e
  0a840	00 00 00 00	 DD	 $LN395@ckd_dasd_e
  0a844	00 00 00 00	 DD	 $LN153@ckd_dasd_e
  0a848	00 00 00 00	 DD	 $LN254@ckd_dasd_e
  0a84c	00 00 00 00	 DD	 $LN262@ckd_dasd_e
  0a850	00 00 00 00	 DD	 $LN266@ckd_dasd_e
  0a854	00 00 00 00	 DD	 $LN195@ckd_dasd_e
  0a858	00 00 00 00	 DD	 $LN271@ckd_dasd_e
  0a85c	00 00 00 00	 DD	 $LN290@ckd_dasd_e
  0a860	00 00 00 00	 DD	 $LN594@ckd_dasd_e
  0a864	00 00 00 00	 DD	 $LN306@ckd_dasd_e
  0a868	00 00 00 00	 DD	 $LN564@ckd_dasd_e
  0a86c	00 00 00 00	 DD	 $LN415@ckd_dasd_e
  0a870	00 00 00 00	 DD	 $LN273@ckd_dasd_e
  0a874	00 00 00 00	 DD	 $LN473@ckd_dasd_e
  0a878	00 00 00 00	 DD	 $LN292@ckd_dasd_e
  0a87c	00 00 00 00	 DD	 $LN601@ckd_dasd_e
  0a880	00 00 00 00	 DD	 $LN568@ckd_dasd_e
  0a884	00 00 00 00	 DD	 $LN172@ckd_dasd_e
  0a888	00 00 00 00	 DD	 $LN540@ckd_dasd_e
  0a88c	00 00 00 00	 DD	 $LN560@ckd_dasd_e
  0a890	00 00 00 00	 DD	 $LN275@ckd_dasd_e
  0a894	00 00 00 00	 DD	 $LN294@ckd_dasd_e
  0a898	00 00 00 00	 DD	 $LN336@ckd_dasd_e
  0a89c	00 00 00 00	 DD	 $LN74@ckd_dasd_e
  0a8a0	00 00 00 00	 DD	 $LN610@ckd_dasd_e
  0a8a4	00 00 00 00	 DD	 $LN364@ckd_dasd_e
  0a8a8	00 00 00 00	 DD	 $LN92@ckd_dasd_e
  0a8ac	00 00 00 00	 DD	 $LN111@ckd_dasd_e
  0a8b0	00 00 00 00	 DD	 $LN577@ckd_dasd_e
  0a8b4	00 00 00 00	 DD	 $LN121@ckd_dasd_e
  0a8b8	00 00 00 00	 DD	 $LN137@ckd_dasd_e
  0a8bc	00 00 00 00	 DD	 $LN407@ckd_dasd_e
  0a8c0	00 00 00 00	 DD	 $LN154@ckd_dasd_e
  0a8c4	00 00 00 00	 DD	 $LN605@ckd_dasd_e
  0a8c8	00 00 00 00	 DD	 $LN334@ckd_dasd_e
  0a8cc	00 00 00 00	 DD	 $LN71@ckd_dasd_e
  0a8d0	00 00 00 00	 DD	 $LN272@ckd_dasd_e
  0a8d4	00 00 00 00	 DD	 $LN597@ckd_dasd_e
  0a8d8	00 00 00 00	 DD	 $LN291@ckd_dasd_e
  0a8dc	00 00 00 00	 DD	 $LN582@ckd_dasd_e
  0a8e0	00 00 00 00	 DD	 $LN335@ckd_dasd_e
  0a8e4	00 00 00 00	 DD	 $LN72@ckd_dasd_e
  0a8e8	00 00 00 00	 DD	 $LN307@ckd_dasd_e
  0a8ec	00 00 00 00	 DD	 $LN274@ckd_dasd_e
  0a8f0	00 00 00 00	 DD	 $LN293@ckd_dasd_e
  0a8f4	00 00 00 00	 DD	 $LN181@ckd_dasd_e
  0a8f8	00 00 00 00	 DD	 $LN590@ckd_dasd_e
  0a8fc	00 00 00 00	 DD	 $LN416@ckd_dasd_e
  0a900	00 00 00 00	 DD	 $LN276@ckd_dasd_e
  0a904	00 00 00 00	 DD	 $LN295@ckd_dasd_e
  0a908	00 00 00 00	 DD	 $LN570@ckd_dasd_e
  0a90c	00 00 00 00	 DD	 $LN620@ckd_dasd_e
  0a910	00 00 00 00	 DD	 $LN622@ckd_dasd_e
$LN783@ckd_dasd_e:
  0a914	00		 DB	 0
  0a915	01		 DB	 1
  0a916	02		 DB	 2
  0a917	03		 DB	 3
  0a918	04		 DB	 4
  0a919	05		 DB	 5
  0a91a	06		 DB	 6
  0a91b	48		 DB	 72			; 00000048H
  0a91c	48		 DB	 72			; 00000048H
  0a91d	48		 DB	 72			; 00000048H
  0a91e	07		 DB	 7
  0a91f	48		 DB	 72			; 00000048H
  0a920	08		 DB	 8
  0a921	09		 DB	 9
  0a922	48		 DB	 72			; 00000048H
  0a923	48		 DB	 72			; 00000048H
  0a924	0a		 DB	 10
  0a925	0b		 DB	 11
  0a926	0c		 DB	 12
  0a927	0d		 DB	 13
  0a928	0e		 DB	 14
  0a929	0f		 DB	 15
  0a92a	10		 DB	 16
  0a92b	48		 DB	 72			; 00000048H
  0a92c	11		 DB	 17
  0a92d	12		 DB	 18
  0a92e	13		 DB	 19
  0a92f	48		 DB	 72			; 00000048H
  0a930	14		 DB	 20
  0a931	15		 DB	 21
  0a932	16		 DB	 22
  0a933	48		 DB	 72			; 00000048H
  0a934	48		 DB	 72			; 00000048H
  0a935	17		 DB	 23
  0a936	18		 DB	 24
  0a937	48		 DB	 72			; 00000048H
  0a938	48		 DB	 72			; 00000048H
  0a939	48		 DB	 72			; 00000048H
  0a93a	19		 DB	 25
  0a93b	48		 DB	 72			; 00000048H
  0a93c	1a		 DB	 26
  0a93d	48		 DB	 72			; 00000048H
  0a93e	48		 DB	 72			; 00000048H
  0a93f	48		 DB	 72			; 00000048H
  0a940	48		 DB	 72			; 00000048H
  0a941	48		 DB	 72			; 00000048H
  0a942	48		 DB	 72			; 00000048H
  0a943	48		 DB	 72			; 00000048H
  0a944	1b		 DB	 27
  0a945	48		 DB	 72			; 00000048H
  0a946	48		 DB	 72			; 00000048H
  0a947	1c		 DB	 28
  0a948	48		 DB	 72			; 00000048H
  0a949	48		 DB	 72			; 00000048H
  0a94a	48		 DB	 72			; 00000048H
  0a94b	48		 DB	 72			; 00000048H
  0a94c	1d		 DB	 29
  0a94d	48		 DB	 72			; 00000048H
  0a94e	48		 DB	 72			; 00000048H
  0a94f	48		 DB	 72			; 00000048H
  0a950	48		 DB	 72			; 00000048H
  0a951	1e		 DB	 30
  0a952	48		 DB	 72			; 00000048H
  0a953	48		 DB	 72			; 00000048H
  0a954	48		 DB	 72			; 00000048H
  0a955	48		 DB	 72			; 00000048H
  0a956	48		 DB	 72			; 00000048H
  0a957	48		 DB	 72			; 00000048H
  0a958	48		 DB	 72			; 00000048H
  0a959	48		 DB	 72			; 00000048H
  0a95a	1f		 DB	 31
  0a95b	48		 DB	 72			; 00000048H
  0a95c	20		 DB	 32			; 00000020H
  0a95d	48		 DB	 72			; 00000048H
  0a95e	21		 DB	 33			; 00000021H
  0a95f	48		 DB	 72			; 00000048H
  0a960	48		 DB	 72			; 00000048H
  0a961	48		 DB	 72			; 00000048H
  0a962	48		 DB	 72			; 00000048H
  0a963	48		 DB	 72			; 00000048H
  0a964	22		 DB	 34			; 00000022H
  0a965	48		 DB	 72			; 00000048H
  0a966	48		 DB	 72			; 00000048H
  0a967	23		 DB	 35			; 00000023H
  0a968	48		 DB	 72			; 00000048H
  0a969	48		 DB	 72			; 00000048H
  0a96a	48		 DB	 72			; 00000048H
  0a96b	48		 DB	 72			; 00000048H
  0a96c	48		 DB	 72			; 00000048H
  0a96d	48		 DB	 72			; 00000048H
  0a96e	24		 DB	 36			; 00000024H
  0a96f	48		 DB	 72			; 00000048H
  0a970	48		 DB	 72			; 00000048H
  0a971	25		 DB	 37			; 00000025H
  0a972	48		 DB	 72			; 00000048H
  0a973	48		 DB	 72			; 00000048H
  0a974	48		 DB	 72			; 00000048H
  0a975	48		 DB	 72			; 00000048H
  0a976	26		 DB	 38			; 00000026H
  0a977	27		 DB	 39			; 00000027H
  0a978	48		 DB	 72			; 00000048H
  0a979	48		 DB	 72			; 00000048H
  0a97a	48		 DB	 72			; 00000048H
  0a97b	48		 DB	 72			; 00000048H
  0a97c	28		 DB	 40			; 00000028H
  0a97d	48		 DB	 72			; 00000048H
  0a97e	48		 DB	 72			; 00000048H
  0a97f	48		 DB	 72			; 00000048H
  0a980	48		 DB	 72			; 00000048H
  0a981	48		 DB	 72			; 00000048H
  0a982	48		 DB	 72			; 00000048H
  0a983	48		 DB	 72			; 00000048H
  0a984	29		 DB	 41			; 00000029H
  0a985	48		 DB	 72			; 00000048H
  0a986	48		 DB	 72			; 00000048H
  0a987	48		 DB	 72			; 00000048H
  0a988	48		 DB	 72			; 00000048H
  0a989	48		 DB	 72			; 00000048H
  0a98a	48		 DB	 72			; 00000048H
  0a98b	48		 DB	 72			; 00000048H
  0a98c	48		 DB	 72			; 00000048H
  0a98d	48		 DB	 72			; 00000048H
  0a98e	48		 DB	 72			; 00000048H
  0a98f	48		 DB	 72			; 00000048H
  0a990	48		 DB	 72			; 00000048H
  0a991	48		 DB	 72			; 00000048H
  0a992	48		 DB	 72			; 00000048H
  0a993	48		 DB	 72			; 00000048H
  0a994	48		 DB	 72			; 00000048H
  0a995	48		 DB	 72			; 00000048H
  0a996	48		 DB	 72			; 00000048H
  0a997	48		 DB	 72			; 00000048H
  0a998	2a		 DB	 42			; 0000002aH
  0a999	2b		 DB	 43			; 0000002bH
  0a99a	2c		 DB	 44			; 0000002cH
  0a99b	48		 DB	 72			; 00000048H
  0a99c	48		 DB	 72			; 00000048H
  0a99d	48		 DB	 72			; 00000048H
  0a99e	48		 DB	 72			; 00000048H
  0a99f	48		 DB	 72			; 00000048H
  0a9a0	2d		 DB	 45			; 0000002dH
  0a9a1	2e		 DB	 46			; 0000002eH
  0a9a2	48		 DB	 72			; 00000048H
  0a9a3	48		 DB	 72			; 00000048H
  0a9a4	48		 DB	 72			; 00000048H
  0a9a5	2f		 DB	 47			; 0000002fH
  0a9a6	48		 DB	 72			; 00000048H
  0a9a7	30		 DB	 48			; 00000030H
  0a9a8	48		 DB	 72			; 00000048H
  0a9a9	31		 DB	 49			; 00000031H
  0a9aa	48		 DB	 72			; 00000048H
  0a9ab	48		 DB	 72			; 00000048H
  0a9ac	48		 DB	 72			; 00000048H
  0a9ad	32		 DB	 50			; 00000032H
  0a9ae	48		 DB	 72			; 00000048H
  0a9af	48		 DB	 72			; 00000048H
  0a9b0	33		 DB	 51			; 00000033H
  0a9b1	34		 DB	 52			; 00000034H
  0a9b2	48		 DB	 72			; 00000048H
  0a9b3	48		 DB	 72			; 00000048H
  0a9b4	48		 DB	 72			; 00000048H
  0a9b5	48		 DB	 72			; 00000048H
  0a9b6	48		 DB	 72			; 00000048H
  0a9b7	35		 DB	 53			; 00000035H
  0a9b8	36		 DB	 54			; 00000036H
  0a9b9	37		 DB	 55			; 00000037H
  0a9ba	48		 DB	 72			; 00000048H
  0a9bb	48		 DB	 72			; 00000048H
  0a9bc	38		 DB	 56			; 00000038H
  0a9bd	48		 DB	 72			; 00000048H
  0a9be	48		 DB	 72			; 00000048H
  0a9bf	48		 DB	 72			; 00000048H
  0a9c0	48		 DB	 72			; 00000048H
  0a9c1	48		 DB	 72			; 00000048H
  0a9c2	39		 DB	 57			; 00000039H
  0a9c3	48		 DB	 72			; 00000048H
  0a9c4	3a		 DB	 58			; 0000003aH
  0a9c5	48		 DB	 72			; 00000048H
  0a9c6	48		 DB	 72			; 00000048H
  0a9c7	3b		 DB	 59			; 0000003bH
  0a9c8	3c		 DB	 60			; 0000003cH
  0a9c9	3d		 DB	 61			; 0000003dH
  0a9ca	48		 DB	 72			; 00000048H
  0a9cb	48		 DB	 72			; 00000048H
  0a9cc	3e		 DB	 62			; 0000003eH
  0a9cd	48		 DB	 72			; 00000048H
  0a9ce	48		 DB	 72			; 00000048H
  0a9cf	48		 DB	 72			; 00000048H
  0a9d0	48		 DB	 72			; 00000048H
  0a9d1	48		 DB	 72			; 00000048H
  0a9d2	48		 DB	 72			; 00000048H
  0a9d3	48		 DB	 72			; 00000048H
  0a9d4	48		 DB	 72			; 00000048H
  0a9d5	48		 DB	 72			; 00000048H
  0a9d6	48		 DB	 72			; 00000048H
  0a9d7	48		 DB	 72			; 00000048H
  0a9d8	48		 DB	 72			; 00000048H
  0a9d9	48		 DB	 72			; 00000048H
  0a9da	48		 DB	 72			; 00000048H
  0a9db	48		 DB	 72			; 00000048H
  0a9dc	3f		 DB	 63			; 0000003fH
  0a9dd	48		 DB	 72			; 00000048H
  0a9de	48		 DB	 72			; 00000048H
  0a9df	48		 DB	 72			; 00000048H
  0a9e0	48		 DB	 72			; 00000048H
  0a9e1	48		 DB	 72			; 00000048H
  0a9e2	48		 DB	 72			; 00000048H
  0a9e3	48		 DB	 72			; 00000048H
  0a9e4	40		 DB	 64			; 00000040H
  0a9e5	48		 DB	 72			; 00000048H
  0a9e6	48		 DB	 72			; 00000048H
  0a9e7	48		 DB	 72			; 00000048H
  0a9e8	48		 DB	 72			; 00000048H
  0a9e9	48		 DB	 72			; 00000048H
  0a9ea	48		 DB	 72			; 00000048H
  0a9eb	48		 DB	 72			; 00000048H
  0a9ec	48		 DB	 72			; 00000048H
  0a9ed	48		 DB	 72			; 00000048H
  0a9ee	48		 DB	 72			; 00000048H
  0a9ef	48		 DB	 72			; 00000048H
  0a9f0	48		 DB	 72			; 00000048H
  0a9f1	41		 DB	 65			; 00000041H
  0a9f2	48		 DB	 72			; 00000048H
  0a9f3	48		 DB	 72			; 00000048H
  0a9f4	48		 DB	 72			; 00000048H
  0a9f5	48		 DB	 72			; 00000048H
  0a9f6	48		 DB	 72			; 00000048H
  0a9f7	42		 DB	 66			; 00000042H
  0a9f8	48		 DB	 72			; 00000048H
  0a9f9	48		 DB	 72			; 00000048H
  0a9fa	43		 DB	 67			; 00000043H
  0a9fb	48		 DB	 72			; 00000048H
  0a9fc	44		 DB	 68			; 00000044H
  0a9fd	48		 DB	 72			; 00000048H
  0a9fe	48		 DB	 72			; 00000048H
  0a9ff	48		 DB	 72			; 00000048H
  0aa00	48		 DB	 72			; 00000048H
  0aa01	48		 DB	 72			; 00000048H
  0aa02	48		 DB	 72			; 00000048H
  0aa03	48		 DB	 72			; 00000048H
  0aa04	45		 DB	 69			; 00000045H
  0aa05	48		 DB	 72			; 00000048H
  0aa06	46		 DB	 70			; 00000046H
  0aa07	48		 DB	 72			; 00000048H
  0aa08	48		 DB	 72			; 00000048H
  0aa09	48		 DB	 72			; 00000048H
  0aa0a	48		 DB	 72			; 00000048H
  0aa0b	48		 DB	 72			; 00000048H
  0aa0c	48		 DB	 72			; 00000048H
  0aa0d	47		 DB	 71			; 00000047H
  0aa0e	66 90		 npad	 2
$LN782@ckd_dasd_e:
  0aa10	00 00 00 00	 DD	 $LN210@ckd_dasd_e
  0aa14	00 00 00 00	 DD	 $LN211@ckd_dasd_e
  0aa18	00 00 00 00	 DD	 $LN212@ckd_dasd_e
  0aa1c	00 00 00 00	 DD	 $LN213@ckd_dasd_e
  0aa20	00 00 00 00	 DD	 $LN214@ckd_dasd_e
  0aa24	00 00 00 00	 DD	 $LN215@ckd_dasd_e
  0aa28	00 00 00 00	 DD	 $LN216@ckd_dasd_e
$LN781@ckd_dasd_e:
  0aa2c	00		 DB	 0
  0aa2d	01		 DB	 1
  0aa2e	06		 DB	 6
  0aa2f	02		 DB	 2
  0aa30	06		 DB	 6
  0aa31	06		 DB	 6
  0aa32	06		 DB	 6
  0aa33	06		 DB	 6
  0aa34	06		 DB	 6
  0aa35	06		 DB	 6
  0aa36	06		 DB	 6
  0aa37	06		 DB	 6
  0aa38	06		 DB	 6
  0aa39	06		 DB	 6
  0aa3a	03		 DB	 3
  0aa3b	06		 DB	 6
  0aa3c	06		 DB	 6
  0aa3d	06		 DB	 6
  0aa3e	06		 DB	 6
  0aa3f	06		 DB	 6
  0aa40	06		 DB	 6
  0aa41	06		 DB	 6
  0aa42	06		 DB	 6
  0aa43	06		 DB	 6
  0aa44	06		 DB	 6
  0aa45	06		 DB	 6
  0aa46	06		 DB	 6
  0aa47	06		 DB	 6
  0aa48	04		 DB	 4
  0aa49	06		 DB	 6
  0aa4a	06		 DB	 6
  0aa4b	06		 DB	 6
  0aa4c	06		 DB	 6
  0aa4d	06		 DB	 6
  0aa4e	06		 DB	 6
  0aa4f	06		 DB	 6
  0aa50	06		 DB	 6
  0aa51	06		 DB	 6
  0aa52	06		 DB	 6
  0aa53	06		 DB	 6
  0aa54	06		 DB	 6
  0aa55	06		 DB	 6
  0aa56	06		 DB	 6
  0aa57	06		 DB	 6
  0aa58	06		 DB	 6
  0aa59	06		 DB	 6
  0aa5a	06		 DB	 6
  0aa5b	06		 DB	 6
  0aa5c	06		 DB	 6
  0aa5d	06		 DB	 6
  0aa5e	06		 DB	 6
  0aa5f	06		 DB	 6
  0aa60	06		 DB	 6
  0aa61	06		 DB	 6
  0aa62	06		 DB	 6
  0aa63	06		 DB	 6
  0aa64	06		 DB	 6
  0aa65	06		 DB	 6
  0aa66	06		 DB	 6
  0aa67	06		 DB	 6
  0aa68	06		 DB	 6
  0aa69	06		 DB	 6
  0aa6a	06		 DB	 6
  0aa6b	06		 DB	 6
  0aa6c	06		 DB	 6
  0aa6d	05		 DB	 5
ckd_dasd_execute_ccw ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\ckddasd.c
_TEXT	SEGMENT
i$ = 128
fileseq$ = 132
cckd$ = 136
rc$ = 140
highcyl$ = 144
cyls$ = 148
sfxchar$ = 152
heads$ = 156
trks$ = 160
sfxptr$ = 168
trksize$ = 176
tv129 = 180
tv179 = 184
tv185 = 188
tv427 = 192
tv433 = 196
tv452 = 200
tv512 = 204
tv518 = 208
tv536 = 212
tv542 = 216
tv567 = 220
tv573 = 224
tv600 = 228
tv606 = 232
tv623 = 236
tv629 = 240
tv697 = 244
tv703 = 248
tv727 = 252
tv733 = 256
tv797 = 260
tv803 = 264
tv831 = 268
tv837 = 272
tv854 = 276
tv860 = 280
tv909 = 284
tv975 = 288
tv981 = 292
tv1002 = 296
tv1015 = 300
tv1021 = 304
tv1084 = 308
tv1090 = 312
tv1125 = 316
tv1131 = 320
tv1154 = 324
tv1160 = 328
tv1206 = 332
tv1212 = 336
tv1241 = 340
tv1247 = 344
tv1312 = 348
tv1318 = 352
tv1353 = 356
tv1359 = 360
tv91 = 364
cu$ = 368
tv1235 = 376
tv418 = 380
tv1006 = 384
tv722 = 392
tv788 = 400
tv792 = 408
tv970 = 416
tv1010 = 424
tv1079 = 432
tv1120 = 440
tv1149 = 448
tv1201 = 456
tv1275 = 464
tv1336 = 472
tv1344 = 480
tv1348 = 488
tv420 = 496
tv471 = 504
tv558 = 512
tv591 = 520
tv822 = 528
tv1419 = 536
statbuf$ = 544
devhdr$ = 608
cdevhdr$ = 1120
serial$ = 1632
filename$ = 1648
__$ArrayPad$ = 1920
dev$ = 1968
argc$ = 1976
argv$ = 1984
ckd_dasd_init_handler PROC

; 188  : {

$LN202:
  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00009	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000e	56		 push	 rsi
  0000f	57		 push	 rdi
  00010	48 81 ec 98 07
	00 00		 sub	 rsp, 1944		; 00000798H
  00017	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  0001e	48 33 c4	 xor	 rax, rsp
  00021	48 89 84 24 80
	07 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 189  : int             rc;                     /* Return code               */
; 190  : struct stat     statbuf;                /* File information          */
; 191  : CKD_DEVHDR      devhdr;                 /* Device header             */
; 192  : CCKD_DEVHDR     cdevhdr;                /* Compressed device header  */
; 193  : int             i;                      /* Loop index                */
; 194  : int             fileseq;                /* File sequence number      */
; 195  : char           *sfxptr;                 /* -> Last char of file name */
; 196  : char            sfxchar;                /* Last char of file name    */
; 197  : int             heads;                  /* #of heads in CKD file     */
; 198  : int             trksize;                /* Track size of CKD file    */
; 199  : int             trks;                   /* #of tracks in CKD file    */
; 200  : int             cyls;                   /* #of cylinders in CKD file */
; 201  : int             highcyl;                /* Highest cyl# in CKD file  */
; 202  : char           *cu = NULL;              /* Specified control unit    */

  00029	48 c7 84 24 70
	01 00 00 00 00
	00 00		 mov	 QWORD PTR cu$[rsp], 0

; 203  : int             cckd=0;                 /* 1 if compressed CKD       */

  00035	c7 84 24 88 00
	00 00 00 00 00
	00		 mov	 DWORD PTR cckd$[rsp], 0

; 204  : char         filename[FILENAME_MAX+3];  /* work area for display     */
; 205  : BYTE            serial[12+1] = {0};     /* Dasd serial number        */

  00040	48 8d 84 24 60
	06 00 00	 lea	 rax, QWORD PTR serial$[rsp]
  00048	48 8b f8	 mov	 rdi, rax
  0004b	33 c0		 xor	 eax, eax
  0004d	b9 0d 00 00 00	 mov	 ecx, 13
  00052	f3 aa		 rep stosb

; 206  : 
; 207  :     dev->rcd = &dasd_build_ckd_config_data;

  00054	48 8b 84 24 b0
	07 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  0005c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:dasd_build_ckd_config_data
  00063	48 89 88 b8 02
	00 00		 mov	 QWORD PTR [rax+696], rcx

; 208  : 
; 209  :     /* For re-initialisation, close the existing file, if any */
; 210  :     if (dev->fd >= 0)

  0006a	48 8b 84 24 b0
	07 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00072	83 b8 ac 01 00
	00 00		 cmp	 DWORD PTR [rax+428], 0
  00079	7c 1a		 jl	 SHORT $LN8@ckd_dasd_i

; 211  :         (dev->hnd->close)(dev);

  0007b	48 8b 84 24 b0
	07 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00083	48 8b 80 90 02
	00 00		 mov	 rax, QWORD PTR [rax+656]
  0008a	48 8b 8c 24 b0
	07 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  00092	ff 50 10	 call	 QWORD PTR [rax+16]
$LN8@ckd_dasd_i:

; 212  : 
; 213  :     if(!sscanf(dev->typname,"%hx",&(dev->devtype)))

  00095	48 8b 84 24 b0
	07 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  0009d	48 83 c0 4a	 add	 rax, 74			; 0000004aH
  000a1	4c 8b c0	 mov	 r8, rax
  000a4	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG169864
  000ab	48 8b 84 24 b0
	07 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  000b3	48 8b 48 50	 mov	 rcx, QWORD PTR [rax+80]
  000b7	e8 00 00 00 00	 call	 sscanf
  000bc	85 c0		 test	 eax, eax
  000be	75 11		 jne	 SHORT $LN9@ckd_dasd_i

; 214  :         dev->devtype = 0x3380;

  000c0	b8 80 33 00 00	 mov	 eax, 13184		; 00003380H
  000c5	48 8b 8c 24 b0
	07 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  000cd	66 89 41 4a	 mov	 WORD PTR [rcx+74], ax
$LN9@ckd_dasd_i:

; 215  : 
; 216  :     /* The first argument is the file name */
; 217  :     if (argc == 0 || strlen(argv[0]) >= sizeof(dev->filename))

  000d1	83 bc 24 b8 07
	00 00 00	 cmp	 DWORD PTR argc$[rsp], 0
  000d9	74 26		 je	 SHORT $LN11@ckd_dasd_i
  000db	b8 08 00 00 00	 mov	 eax, 8
  000e0	48 6b c0 00	 imul	 rax, rax, 0
  000e4	48 8b 8c 24 c0
	07 00 00	 mov	 rcx, QWORD PTR argv$[rsp]
  000ec	48 8b 0c 01	 mov	 rcx, QWORD PTR [rcx+rax]
  000f0	e8 00 00 00 00	 call	 strlen
  000f5	48 3d 05 01 00
	00		 cmp	 rax, 261		; 00000105H
  000fb	0f 82 bf 00 00
	00		 jb	 $LN10@ckd_dasd_i
$LN11@ckd_dasd_i:

; 218  :     {
; 219  :         // "%1d:%04X CKD file: name missing or invalid filename length"
; 220  :         WRMSG( HHC00400, "E", LCSS_DEVNUM );

  00101	48 83 bc 24 b0
	07 00 00 00	 cmp	 QWORD PTR dev$[rsp], 0
  0010a	74 15		 je	 SHORT $LN82@ckd_dasd_i
  0010c	48 8b 84 24 b0
	07 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00114	0f b7 40 48	 movzx	 eax, WORD PTR [rax+72]
  00118	89 84 24 6c 01
	00 00		 mov	 DWORD PTR tv91[rsp], eax
  0011f	eb 0b		 jmp	 SHORT $LN83@ckd_dasd_i
$LN82@ckd_dasd_i:
  00121	c7 84 24 6c 01
	00 00 00 00 00
	00		 mov	 DWORD PTR tv91[rsp], 0
$LN83@ckd_dasd_i:
  0012c	48 83 bc 24 b0
	07 00 00 00	 cmp	 QWORD PTR dev$[rsp], 0
  00135	74 17		 je	 SHORT $LN84@ckd_dasd_i
  00137	48 8b 84 24 b0
	07 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  0013f	0f b7 40 44	 movzx	 eax, WORD PTR [rax+68]
  00143	d1 f8		 sar	 eax, 1
  00145	89 84 24 b4 00
	00 00		 mov	 DWORD PTR tv129[rsp], eax
  0014c	eb 0b		 jmp	 SHORT $LN85@ckd_dasd_i
$LN84@ckd_dasd_i:
  0014e	c7 84 24 b4 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv129[rsp], 0
$LN85@ckd_dasd_i:
  00159	b9 01 00 00 00	 mov	 ecx, 1
  0015e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  00164	8b 8c 24 6c 01
	00 00		 mov	 ecx, DWORD PTR tv91[rsp]
  0016b	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  0016f	8b 8c 24 b4 00
	00 00		 mov	 ecx, DWORD PTR tv129[rsp]
  00176	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  0017a	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169867
  00181	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  00186	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169868
  0018d	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00192	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00197	41 b9 03 00 00
	00		 mov	 r9d, 3
  0019d	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG169869
  001a4	ba dc 00 00 00	 mov	 edx, 220		; 000000dcH
  001a9	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169870
  001b0	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 221  :         return -1;

  001b6	b8 ff ff ff ff	 mov	 eax, -1
  001bb	e9 73 27 00 00	 jmp	 $LN1@ckd_dasd_i
$LN10@ckd_dasd_i:

; 222  :     }
; 223  : 
; 224  :     /* reset excps count */
; 225  :     dev->excps = 0;

  001c0	48 8b 84 24 b0
	07 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  001c8	48 c7 80 00 06
	00 00 00 00 00
	00		 mov	 QWORD PTR [rax+1536], 0

; 226  : 
; 227  :     /* Save the file name in the device block */
; 228  :     hostpath(dev->filename, argv[0], sizeof(dev->filename));

  001d3	b8 08 00 00 00	 mov	 eax, 8
  001d8	48 6b c0 00	 imul	 rax, rax, 0
  001dc	48 8b 8c 24 b0
	07 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  001e4	48 81 c1 a4 00
	00 00		 add	 rcx, 164		; 000000a4H
  001eb	41 b8 05 01 00
	00		 mov	 r8d, 261		; 00000105H
  001f1	48 8b 94 24 c0
	07 00 00	 mov	 rdx, QWORD PTR argv$[rsp]
  001f9	48 8b 14 02	 mov	 rdx, QWORD PTR [rdx+rax]
  001fd	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hostpath

; 229  : 
; 230  :     if (strchr(dev->filename, SPACE) == NULL)

  00203	48 8b 84 24 b0
	07 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  0020b	48 05 a4 00 00
	00		 add	 rax, 164		; 000000a4H
  00211	ba 20 00 00 00	 mov	 edx, 32			; 00000020H
  00216	48 8b c8	 mov	 rcx, rax
  00219	e8 00 00 00 00	 call	 strchr
  0021e	48 85 c0	 test	 rax, rax
  00221	75 2d		 jne	 SHORT $LN12@ckd_dasd_i

; 231  :     {
; 232  :         MSGBUF(filename, "%s", dev->filename);

  00223	48 8b 84 24 b0
	07 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  0022b	48 05 a4 00 00
	00		 add	 rax, 164		; 000000a4H
  00231	4c 8b c8	 mov	 r9, rax
  00234	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG169873
  0023b	ba 07 01 00 00	 mov	 edx, 263		; 00000107H
  00240	48 8d 8c 24 70
	06 00 00	 lea	 rcx, QWORD PTR filename$[rsp]
  00248	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_snprintf

; 233  :     }

  0024e	eb 2b		 jmp	 SHORT $LN13@ckd_dasd_i
$LN12@ckd_dasd_i:

; 234  :     else
; 235  :     {
; 236  :         MSGBUF(filename, "'%s'", dev->filename);

  00250	48 8b 84 24 b0
	07 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00258	48 05 a4 00 00
	00		 add	 rax, 164		; 000000a4H
  0025e	4c 8b c8	 mov	 r9, rax
  00261	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG169874
  00268	ba 07 01 00 00	 mov	 edx, 263		; 00000107H
  0026d	48 8d 8c 24 70
	06 00 00	 lea	 rcx, QWORD PTR filename$[rsp]
  00275	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_snprintf
$LN13@ckd_dasd_i:

; 237  :     }
; 238  : 
; 239  : #if defined( OPTION_SHARED_DEVICES )
; 240  :     /* Device is shareable */
; 241  :     dev->shareable = 1;

  0027b	48 8b 84 24 b0
	07 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00283	8b 80 f8 05 00
	00		 mov	 eax, DWORD PTR [rax+1528]
  00289	83 c8 08	 or	 eax, 8
  0028c	48 8b 8c 24 b0
	07 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  00294	89 81 f8 05 00
	00		 mov	 DWORD PTR [rcx+1528], eax

; 242  : #endif // defined( OPTION_SHARED_DEVICES )
; 243  : 
; 244  :     /* Check for possible remote device */
; 245  :     if (stat(dev->filename, &statbuf) < 0)

  0029a	48 8b 84 24 b0
	07 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  002a2	48 05 a4 00 00
	00		 add	 rax, 164		; 000000a4H
  002a8	48 8d 94 24 20
	02 00 00	 lea	 rdx, QWORD PTR statbuf$[rsp]
  002b0	48 8b c8	 mov	 rcx, rax
  002b3	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__stat64
  002b9	85 c0		 test	 eax, eax
  002bb	0f 8d 0b 01 00
	00		 jge	 $LN14@ckd_dasd_i

; 246  :     {
; 247  :         rc = shared_ckd_init ( dev, argc, argv);

  002c1	4c 8b 84 24 c0
	07 00 00	 mov	 r8, QWORD PTR argv$[rsp]
  002c9	8b 94 24 b8 07
	00 00		 mov	 edx, DWORD PTR argc$[rsp]
  002d0	48 8b 8c 24 b0
	07 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  002d8	e8 00 00 00 00	 call	 shared_ckd_init
  002dd	89 84 24 8c 00
	00 00		 mov	 DWORD PTR rc$[rsp], eax

; 248  :         if (rc < 0)

  002e4	83 bc 24 8c 00
	00 00 00	 cmp	 DWORD PTR rc$[rsp], 0
  002ec	0f 8d ce 00 00
	00		 jge	 $LN15@ckd_dasd_i

; 249  :         {
; 250  :             // "%1d:%04X CKD file %s: open error: not found"
; 251  :             WRMSG( HHC00401, "E", LCSS_DEVNUM, filename );

  002f2	48 83 bc 24 b0
	07 00 00 00	 cmp	 QWORD PTR dev$[rsp], 0
  002fb	74 15		 je	 SHORT $LN86@ckd_dasd_i
  002fd	48 8b 84 24 b0
	07 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00305	0f b7 40 48	 movzx	 eax, WORD PTR [rax+72]
  00309	89 84 24 b8 00
	00 00		 mov	 DWORD PTR tv179[rsp], eax
  00310	eb 0b		 jmp	 SHORT $LN87@ckd_dasd_i
$LN86@ckd_dasd_i:
  00312	c7 84 24 b8 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv179[rsp], 0
$LN87@ckd_dasd_i:
  0031d	48 83 bc 24 b0
	07 00 00 00	 cmp	 QWORD PTR dev$[rsp], 0
  00326	74 17		 je	 SHORT $LN88@ckd_dasd_i
  00328	48 8b 84 24 b0
	07 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00330	0f b7 40 44	 movzx	 eax, WORD PTR [rax+68]
  00334	d1 f8		 sar	 eax, 1
  00336	89 84 24 bc 00
	00 00		 mov	 DWORD PTR tv185[rsp], eax
  0033d	eb 0b		 jmp	 SHORT $LN89@ckd_dasd_i
$LN88@ckd_dasd_i:
  0033f	c7 84 24 bc 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv185[rsp], 0
$LN89@ckd_dasd_i:
  0034a	b9 01 00 00 00	 mov	 ecx, 1
  0034f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  00355	48 8d 8c 24 70
	06 00 00	 lea	 rcx, QWORD PTR filename$[rsp]
  0035d	48 89 4c 24 48	 mov	 QWORD PTR [rsp+72], rcx
  00362	8b 8c 24 b8 00
	00 00		 mov	 ecx, DWORD PTR tv179[rsp]
  00369	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  0036d	8b 8c 24 bc 00
	00 00		 mov	 ecx, DWORD PTR tv185[rsp]
  00374	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  00378	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169878
  0037f	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  00384	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169879
  0038b	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00390	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00395	41 b9 03 00 00
	00		 mov	 r9d, 3
  0039b	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG169880
  003a2	ba fb 00 00 00	 mov	 edx, 251		; 000000fbH
  003a7	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169881
  003ae	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 252  :             return -1;

  003b4	b8 ff ff ff ff	 mov	 eax, -1
  003b9	e9 75 25 00 00	 jmp	 $LN1@ckd_dasd_i

; 253  :         }

  003be	eb 0c		 jmp	 SHORT $LN16@ckd_dasd_i
$LN15@ckd_dasd_i:

; 254  :         else
; 255  :             return rc;

  003c0	8b 84 24 8c 00
	00 00		 mov	 eax, DWORD PTR rc$[rsp]
  003c7	e9 67 25 00 00	 jmp	 $LN1@ckd_dasd_i
$LN16@ckd_dasd_i:
$LN14@ckd_dasd_i:

; 256  :     }
; 257  : 
; 258  :     /* No active track or cache entry */
; 259  :     dev->bufcur = dev->cache = -1;

  003cc	48 8b 84 24 b0
	07 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  003d4	c7 80 f8 01 00
	00 ff ff ff ff	 mov	 DWORD PTR [rax+504], -1
  003de	48 8b 84 24 b0
	07 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  003e6	c7 80 c0 01 00
	00 ff ff ff ff	 mov	 DWORD PTR [rax+448], -1

; 260  : 
; 261  :     /* Locate and save the last character of the file name */
; 262  :     sfxptr = strrchr (dev->filename, PATHSEPC);

  003f0	48 8b 84 24 b0
	07 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  003f8	48 05 a4 00 00
	00		 add	 rax, 164		; 000000a4H
  003fe	ba 2f 00 00 00	 mov	 edx, 47			; 0000002fH
  00403	48 8b c8	 mov	 rcx, rax
  00406	e8 00 00 00 00	 call	 strrchr
  0040b	48 89 84 24 a8
	00 00 00	 mov	 QWORD PTR sfxptr$[rsp], rax

; 263  :     if (sfxptr == NULL) sfxptr = dev->filename + 1;

  00413	48 83 bc 24 a8
	00 00 00 00	 cmp	 QWORD PTR sfxptr$[rsp], 0
  0041c	75 16		 jne	 SHORT $LN17@ckd_dasd_i
  0041e	48 8b 84 24 b0
	07 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00426	48 05 a5 00 00
	00		 add	 rax, 165		; 000000a5H
  0042c	48 89 84 24 a8
	00 00 00	 mov	 QWORD PTR sfxptr$[rsp], rax
$LN17@ckd_dasd_i:

; 264  :     sfxptr = strchr (sfxptr, '.');

  00434	ba 2e 00 00 00	 mov	 edx, 46			; 0000002eH
  00439	48 8b 8c 24 a8
	00 00 00	 mov	 rcx, QWORD PTR sfxptr$[rsp]
  00441	e8 00 00 00 00	 call	 strchr
  00446	48 89 84 24 a8
	00 00 00	 mov	 QWORD PTR sfxptr$[rsp], rax

; 265  :     if (sfxptr == NULL) sfxptr = dev->filename + strlen(dev->filename);

  0044e	48 83 bc 24 a8
	00 00 00 00	 cmp	 QWORD PTR sfxptr$[rsp], 0
  00457	75 2e		 jne	 SHORT $LN18@ckd_dasd_i
  00459	48 8b 84 24 b0
	07 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00461	48 05 a4 00 00
	00		 add	 rax, 164		; 000000a4H
  00467	48 8b c8	 mov	 rcx, rax
  0046a	e8 00 00 00 00	 call	 strlen
  0046f	48 8b 8c 24 b0
	07 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  00477	48 8d 84 01 a4
	00 00 00	 lea	 rax, QWORD PTR [rcx+rax+164]
  0047f	48 89 84 24 a8
	00 00 00	 mov	 QWORD PTR sfxptr$[rsp], rax
$LN18@ckd_dasd_i:

; 266  :     sfxptr--;

  00487	48 8b 84 24 a8
	00 00 00	 mov	 rax, QWORD PTR sfxptr$[rsp]
  0048f	48 ff c8	 dec	 rax
  00492	48 89 84 24 a8
	00 00 00	 mov	 QWORD PTR sfxptr$[rsp], rax

; 267  :     sfxchar = *sfxptr;

  0049a	48 8b 84 24 a8
	00 00 00	 mov	 rax, QWORD PTR sfxptr$[rsp]
  004a2	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  004a5	88 84 24 98 00
	00 00		 mov	 BYTE PTR sfxchar$[rsp], al

; 268  : 
; 269  :     /* process the remaining arguments */
; 270  :     for (i = 1; i < argc; i++)

  004ac	c7 84 24 80 00
	00 00 01 00 00
	00		 mov	 DWORD PTR i$[rsp], 1
  004b7	eb 10		 jmp	 SHORT $LN4@ckd_dasd_i
$LN2@ckd_dasd_i:
  004b9	8b 84 24 80 00
	00 00		 mov	 eax, DWORD PTR i$[rsp]
  004c0	ff c0		 inc	 eax
  004c2	89 84 24 80 00
	00 00		 mov	 DWORD PTR i$[rsp], eax
$LN4@ckd_dasd_i:
  004c9	8b 84 24 b8 07
	00 00		 mov	 eax, DWORD PTR argc$[rsp]
  004d0	39 84 24 80 00
	00 00		 cmp	 DWORD PTR i$[rsp], eax
  004d7	0f 8d a2 05 00
	00		 jge	 $LN3@ckd_dasd_i

; 271  :     {
; 272  :         if (strcasecmp ("lazywrite", argv[i]) == 0)

  004dd	48 63 84 24 80
	00 00 00	 movsxd	 rax, DWORD PTR i$[rsp]
  004e5	48 8b 8c 24 c0
	07 00 00	 mov	 rcx, QWORD PTR argv$[rsp]
  004ed	48 8b 14 c1	 mov	 rdx, QWORD PTR [rcx+rax*8]
  004f1	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169885
  004f8	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__stricmp
  004fe	85 c0		 test	 eax, eax
  00500	75 22		 jne	 SHORT $LN19@ckd_dasd_i

; 273  :         {
; 274  :             dev->ckdnolazywr = 0;

  00502	48 8b 84 24 b0
	07 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  0050a	8b 80 14 13 00
	00		 mov	 eax, DWORD PTR [rax+4884]
  00510	0f ba f0 11	 btr	 eax, 17
  00514	48 8b 8c 24 b0
	07 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  0051c	89 81 14 13 00
	00		 mov	 DWORD PTR [rcx+4884], eax

; 275  :             continue;

  00522	eb 95		 jmp	 SHORT $LN2@ckd_dasd_i
$LN19@ckd_dasd_i:

; 276  :         }
; 277  :         if (strcasecmp ("nolazywrite", argv[i]) == 0)

  00524	48 63 84 24 80
	00 00 00	 movsxd	 rax, DWORD PTR i$[rsp]
  0052c	48 8b 8c 24 c0
	07 00 00	 mov	 rcx, QWORD PTR argv$[rsp]
  00534	48 8b 14 c1	 mov	 rdx, QWORD PTR [rcx+rax*8]
  00538	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169887
  0053f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__stricmp
  00545	85 c0		 test	 eax, eax
  00547	75 25		 jne	 SHORT $LN20@ckd_dasd_i

; 278  :         {
; 279  :             dev->ckdnolazywr = 1;

  00549	48 8b 84 24 b0
	07 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00551	8b 80 14 13 00
	00		 mov	 eax, DWORD PTR [rax+4884]
  00557	0f ba e8 11	 bts	 eax, 17
  0055b	48 8b 8c 24 b0
	07 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  00563	89 81 14 13 00
	00		 mov	 DWORD PTR [rcx+4884], eax

; 280  :             continue;

  00569	e9 4b ff ff ff	 jmp	 $LN2@ckd_dasd_i
$LN20@ckd_dasd_i:

; 281  :         }
; 282  :         if (strcasecmp ("fulltrackio", argv[i]) == 0 ||
; 283  :             strcasecmp ("fulltrkio",   argv[i]) == 0 ||

  0056e	48 63 84 24 80
	00 00 00	 movsxd	 rax, DWORD PTR i$[rsp]
  00576	48 8b 8c 24 c0
	07 00 00	 mov	 rcx, QWORD PTR argv$[rsp]
  0057e	48 8b 14 c1	 mov	 rdx, QWORD PTR [rcx+rax*8]
  00582	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169890
  00589	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__stricmp
  0058f	85 c0		 test	 eax, eax
  00591	74 4a		 je	 SHORT $LN22@ckd_dasd_i
  00593	48 63 84 24 80
	00 00 00	 movsxd	 rax, DWORD PTR i$[rsp]
  0059b	48 8b 8c 24 c0
	07 00 00	 mov	 rcx, QWORD PTR argv$[rsp]
  005a3	48 8b 14 c1	 mov	 rdx, QWORD PTR [rcx+rax*8]
  005a7	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169891
  005ae	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__stricmp
  005b4	85 c0		 test	 eax, eax
  005b6	74 25		 je	 SHORT $LN22@ckd_dasd_i
  005b8	48 63 84 24 80
	00 00 00	 movsxd	 rax, DWORD PTR i$[rsp]
  005c0	48 8b 8c 24 c0
	07 00 00	 mov	 rcx, QWORD PTR argv$[rsp]
  005c8	48 8b 14 c1	 mov	 rdx, QWORD PTR [rcx+rax*8]
  005cc	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169892
  005d3	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__stricmp
  005d9	85 c0		 test	 eax, eax
  005db	75 25		 jne	 SHORT $LN21@ckd_dasd_i
$LN22@ckd_dasd_i:

; 284  :             strcasecmp ("ftio",        argv[i]) == 0)
; 285  :         {
; 286  :             dev->ckdnolazywr = 0;

  005dd	48 8b 84 24 b0
	07 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  005e5	8b 80 14 13 00
	00		 mov	 eax, DWORD PTR [rax+4884]
  005eb	0f ba f0 11	 btr	 eax, 17
  005ef	48 8b 8c 24 b0
	07 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  005f7	89 81 14 13 00
	00		 mov	 DWORD PTR [rcx+4884], eax

; 287  :             continue;

  005fd	e9 b7 fe ff ff	 jmp	 $LN2@ckd_dasd_i
$LN21@ckd_dasd_i:

; 288  :         }
; 289  :         if (strcasecmp ("nofulltrackio", argv[i]) == 0 ||
; 290  :             strcasecmp ("nofulltrkio",   argv[i]) == 0 ||

  00602	48 63 84 24 80
	00 00 00	 movsxd	 rax, DWORD PTR i$[rsp]
  0060a	48 8b 8c 24 c0
	07 00 00	 mov	 rcx, QWORD PTR argv$[rsp]
  00612	48 8b 14 c1	 mov	 rdx, QWORD PTR [rcx+rax*8]
  00616	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169895
  0061d	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__stricmp
  00623	85 c0		 test	 eax, eax
  00625	74 4a		 je	 SHORT $LN24@ckd_dasd_i
  00627	48 63 84 24 80
	00 00 00	 movsxd	 rax, DWORD PTR i$[rsp]
  0062f	48 8b 8c 24 c0
	07 00 00	 mov	 rcx, QWORD PTR argv$[rsp]
  00637	48 8b 14 c1	 mov	 rdx, QWORD PTR [rcx+rax*8]
  0063b	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169896
  00642	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__stricmp
  00648	85 c0		 test	 eax, eax
  0064a	74 25		 je	 SHORT $LN24@ckd_dasd_i
  0064c	48 63 84 24 80
	00 00 00	 movsxd	 rax, DWORD PTR i$[rsp]
  00654	48 8b 8c 24 c0
	07 00 00	 mov	 rcx, QWORD PTR argv$[rsp]
  0065c	48 8b 14 c1	 mov	 rdx, QWORD PTR [rcx+rax*8]
  00660	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169897
  00667	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__stricmp
  0066d	85 c0		 test	 eax, eax
  0066f	75 25		 jne	 SHORT $LN23@ckd_dasd_i
$LN24@ckd_dasd_i:

; 291  :             strcasecmp ("noftio",        argv[i]) == 0)
; 292  :         {
; 293  :             dev->ckdnolazywr = 1;

  00671	48 8b 84 24 b0
	07 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00679	8b 80 14 13 00
	00		 mov	 eax, DWORD PTR [rax+4884]
  0067f	0f ba e8 11	 bts	 eax, 17
  00683	48 8b 8c 24 b0
	07 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  0068b	89 81 14 13 00
	00		 mov	 DWORD PTR [rcx+4884], eax

; 294  :             continue;

  00691	e9 23 fe ff ff	 jmp	 $LN2@ckd_dasd_i
$LN23@ckd_dasd_i:

; 295  :         }
; 296  :         if (strcasecmp ("readonly", argv[i]) == 0 ||
; 297  :             strcasecmp ("rdonly",   argv[i]) == 0 ||

  00696	48 63 84 24 80
	00 00 00	 movsxd	 rax, DWORD PTR i$[rsp]
  0069e	48 8b 8c 24 c0
	07 00 00	 mov	 rcx, QWORD PTR argv$[rsp]
  006a6	48 8b 14 c1	 mov	 rdx, QWORD PTR [rcx+rax*8]
  006aa	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169900
  006b1	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__stricmp
  006b7	85 c0		 test	 eax, eax
  006b9	74 4a		 je	 SHORT $LN26@ckd_dasd_i
  006bb	48 63 84 24 80
	00 00 00	 movsxd	 rax, DWORD PTR i$[rsp]
  006c3	48 8b 8c 24 c0
	07 00 00	 mov	 rcx, QWORD PTR argv$[rsp]
  006cb	48 8b 14 c1	 mov	 rdx, QWORD PTR [rcx+rax*8]
  006cf	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169901
  006d6	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__stricmp
  006dc	85 c0		 test	 eax, eax
  006de	74 25		 je	 SHORT $LN26@ckd_dasd_i
  006e0	48 63 84 24 80
	00 00 00	 movsxd	 rax, DWORD PTR i$[rsp]
  006e8	48 8b 8c 24 c0
	07 00 00	 mov	 rcx, QWORD PTR argv$[rsp]
  006f0	48 8b 14 c1	 mov	 rdx, QWORD PTR [rcx+rax*8]
  006f4	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169902
  006fb	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__stricmp
  00701	85 c0		 test	 eax, eax
  00703	75 25		 jne	 SHORT $LN25@ckd_dasd_i
$LN26@ckd_dasd_i:

; 298  :             strcasecmp ("ro",       argv[i]) == 0)
; 299  :         {
; 300  :             dev->ckdrdonly = 1;

  00705	48 8b 84 24 b0
	07 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  0070d	8b 80 14 13 00
	00		 mov	 eax, DWORD PTR [rax+4884]
  00713	0f ba e8 12	 bts	 eax, 18
  00717	48 8b 8c 24 b0
	07 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  0071f	89 81 14 13 00
	00		 mov	 DWORD PTR [rcx+4884], eax

; 301  :             continue;

  00725	e9 8f fd ff ff	 jmp	 $LN2@ckd_dasd_i
$LN25@ckd_dasd_i:

; 302  :         }
; 303  :         if (strcasecmp ("fakewrite", argv[i]) == 0 ||
; 304  :             strcasecmp ("fakewrt",   argv[i]) == 0 ||

  0072a	48 63 84 24 80
	00 00 00	 movsxd	 rax, DWORD PTR i$[rsp]
  00732	48 8b 8c 24 c0
	07 00 00	 mov	 rcx, QWORD PTR argv$[rsp]
  0073a	48 8b 14 c1	 mov	 rdx, QWORD PTR [rcx+rax*8]
  0073e	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169905
  00745	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__stricmp
  0074b	85 c0		 test	 eax, eax
  0074d	74 4a		 je	 SHORT $LN28@ckd_dasd_i
  0074f	48 63 84 24 80
	00 00 00	 movsxd	 rax, DWORD PTR i$[rsp]
  00757	48 8b 8c 24 c0
	07 00 00	 mov	 rcx, QWORD PTR argv$[rsp]
  0075f	48 8b 14 c1	 mov	 rdx, QWORD PTR [rcx+rax*8]
  00763	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169906
  0076a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__stricmp
  00770	85 c0		 test	 eax, eax
  00772	74 25		 je	 SHORT $LN28@ckd_dasd_i
  00774	48 63 84 24 80
	00 00 00	 movsxd	 rax, DWORD PTR i$[rsp]
  0077c	48 8b 8c 24 c0
	07 00 00	 mov	 rcx, QWORD PTR argv$[rsp]
  00784	48 8b 14 c1	 mov	 rdx, QWORD PTR [rcx+rax*8]
  00788	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169907
  0078f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__stricmp
  00795	85 c0		 test	 eax, eax
  00797	75 25		 jne	 SHORT $LN27@ckd_dasd_i
$LN28@ckd_dasd_i:

; 305  :             strcasecmp ("fw",        argv[i]) == 0)
; 306  :         {
; 307  :             dev->ckdfakewr = 1;

  00799	48 8b 84 24 b0
	07 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  007a1	8b 80 14 13 00
	00		 mov	 eax, DWORD PTR [rax+4884]
  007a7	0f ba e8 14	 bts	 eax, 20
  007ab	48 8b 8c 24 b0
	07 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  007b3	89 81 14 13 00
	00		 mov	 DWORD PTR [rcx+4884], eax

; 308  :             continue;

  007b9	e9 fb fc ff ff	 jmp	 $LN2@ckd_dasd_i
$LN27@ckd_dasd_i:

; 309  :         }
; 310  :         if (strlen (argv[i]) > 3 &&

  007be	48 63 84 24 80
	00 00 00	 movsxd	 rax, DWORD PTR i$[rsp]
  007c6	48 8b 8c 24 c0
	07 00 00	 mov	 rcx, QWORD PTR argv$[rsp]
  007ce	48 8b 0c c1	 mov	 rcx, QWORD PTR [rcx+rax*8]
  007d2	e8 00 00 00 00	 call	 strlen
  007d7	48 83 f8 03	 cmp	 rax, 3
  007db	76 57		 jbe	 SHORT $LN29@ckd_dasd_i
  007dd	48 63 84 24 80
	00 00 00	 movsxd	 rax, DWORD PTR i$[rsp]
  007e5	41 b8 03 00 00
	00		 mov	 r8d, 3
  007eb	48 8b 8c 24 c0
	07 00 00	 mov	 rcx, QWORD PTR argv$[rsp]
  007f3	48 8b 14 c1	 mov	 rdx, QWORD PTR [rcx+rax*8]
  007f7	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169909
  007fe	e8 00 00 00 00	 call	 memcmp
  00803	85 c0		 test	 eax, eax
  00805	75 2d		 jne	 SHORT $LN29@ckd_dasd_i

; 311  :             memcmp ("sf=", argv[i], 3) == 0)
; 312  :         {
; 313  :             /* Parse the shadow file name parameter */
; 314  :             cckd_sf_parse_sfn( dev, argv[i]+3 );

  00807	48 63 84 24 80
	00 00 00	 movsxd	 rax, DWORD PTR i$[rsp]
  0080f	48 8b 8c 24 c0
	07 00 00	 mov	 rcx, QWORD PTR argv$[rsp]
  00817	48 8b 04 c1	 mov	 rax, QWORD PTR [rcx+rax*8]
  0081b	48 83 c0 03	 add	 rax, 3
  0081f	48 8b d0	 mov	 rdx, rax
  00822	48 8b 8c 24 b0
	07 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  0082a	e8 00 00 00 00	 call	 cckd_sf_parse_sfn

; 315  :             continue;

  0082f	e9 85 fc ff ff	 jmp	 $LN2@ckd_dasd_i
$LN29@ckd_dasd_i:

; 316  :         }
; 317  :         if (strlen (argv[i]) > 3
; 318  :          && memcmp("cu=", argv[i], 3) == 0)

  00834	48 63 84 24 80
	00 00 00	 movsxd	 rax, DWORD PTR i$[rsp]
  0083c	48 8b 8c 24 c0
	07 00 00	 mov	 rcx, QWORD PTR argv$[rsp]
  00844	48 8b 0c c1	 mov	 rcx, QWORD PTR [rcx+rax*8]
  00848	e8 00 00 00 00	 call	 strlen
  0084d	48 83 f8 03	 cmp	 rax, 3
  00851	76 4f		 jbe	 SHORT $LN30@ckd_dasd_i
  00853	48 63 84 24 80
	00 00 00	 movsxd	 rax, DWORD PTR i$[rsp]
  0085b	41 b8 03 00 00
	00		 mov	 r8d, 3
  00861	48 8b 8c 24 c0
	07 00 00	 mov	 rcx, QWORD PTR argv$[rsp]
  00869	48 8b 14 c1	 mov	 rdx, QWORD PTR [rcx+rax*8]
  0086d	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169911
  00874	e8 00 00 00 00	 call	 memcmp
  00879	85 c0		 test	 eax, eax
  0087b	75 25		 jne	 SHORT $LN30@ckd_dasd_i

; 319  :         {
; 320  :             cu = argv[i]+3;

  0087d	48 63 84 24 80
	00 00 00	 movsxd	 rax, DWORD PTR i$[rsp]
  00885	48 8b 8c 24 c0
	07 00 00	 mov	 rcx, QWORD PTR argv$[rsp]
  0088d	48 8b 04 c1	 mov	 rax, QWORD PTR [rcx+rax*8]
  00891	48 83 c0 03	 add	 rax, 3
  00895	48 89 84 24 70
	01 00 00	 mov	 QWORD PTR cu$[rsp], rax

; 321  :             continue;

  0089d	e9 17 fc ff ff	 jmp	 $LN2@ckd_dasd_i
$LN30@ckd_dasd_i:

; 322  :         }
; 323  :         if (strlen (argv[i]) > 4
; 324  :          && memcmp("ser=", argv[i], 4) == 0)

  008a2	48 63 84 24 80
	00 00 00	 movsxd	 rax, DWORD PTR i$[rsp]
  008aa	48 8b 8c 24 c0
	07 00 00	 mov	 rcx, QWORD PTR argv$[rsp]
  008b2	48 8b 0c c1	 mov	 rcx, QWORD PTR [rcx+rax*8]
  008b6	e8 00 00 00 00	 call	 strlen
  008bb	48 83 f8 04	 cmp	 rax, 4
  008bf	0f 86 b2 00 00
	00		 jbe	 $LN31@ckd_dasd_i
  008c5	48 63 84 24 80
	00 00 00	 movsxd	 rax, DWORD PTR i$[rsp]
  008cd	41 b8 04 00 00
	00		 mov	 r8d, 4
  008d3	48 8b 8c 24 c0
	07 00 00	 mov	 rcx, QWORD PTR argv$[rsp]
  008db	48 8b 14 c1	 mov	 rdx, QWORD PTR [rcx+rax*8]
  008df	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169913
  008e6	e8 00 00 00 00	 call	 memcmp
  008eb	85 c0		 test	 eax, eax
  008ed	0f 85 84 00 00
	00		 jne	 $LN31@ckd_dasd_i

; 325  :         {
; 326  :             if (1
; 327  :                 && is_numeric( argv[i]+4 )
; 328  :                 && strlen( argv[i]+4 ) == sizeof( dev->serial )

  008f3	33 c0		 xor	 eax, eax
  008f5	83 f8 01	 cmp	 eax, 1
  008f8	74 7d		 je	 SHORT $LN32@ckd_dasd_i
  008fa	48 63 84 24 80
	00 00 00	 movsxd	 rax, DWORD PTR i$[rsp]
  00902	48 8b 8c 24 c0
	07 00 00	 mov	 rcx, QWORD PTR argv$[rsp]
  0090a	48 8b 04 c1	 mov	 rax, QWORD PTR [rcx+rax*8]
  0090e	48 83 c0 04	 add	 rax, 4
  00912	48 8b c8	 mov	 rcx, rax
  00915	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_is_numeric
  0091b	0f b6 c0	 movzx	 eax, al
  0091e	85 c0		 test	 eax, eax
  00920	74 55		 je	 SHORT $LN32@ckd_dasd_i
  00922	48 63 84 24 80
	00 00 00	 movsxd	 rax, DWORD PTR i$[rsp]
  0092a	48 8b 8c 24 c0
	07 00 00	 mov	 rcx, QWORD PTR argv$[rsp]
  00932	48 8b 04 c1	 mov	 rax, QWORD PTR [rcx+rax*8]
  00936	48 83 c0 04	 add	 rax, 4
  0093a	48 8b c8	 mov	 rcx, rax
  0093d	e8 00 00 00 00	 call	 strlen
  00942	48 83 f8 0c	 cmp	 rax, 12
  00946	75 2f		 jne	 SHORT $LN32@ckd_dasd_i

; 329  :             )
; 330  :             {
; 331  :                 memcpy( serial, argv[i]+4, sizeof( dev->serial ));

  00948	48 63 84 24 80
	00 00 00	 movsxd	 rax, DWORD PTR i$[rsp]
  00950	48 8b 8c 24 c0
	07 00 00	 mov	 rcx, QWORD PTR argv$[rsp]
  00958	48 8b 04 c1	 mov	 rax, QWORD PTR [rcx+rax*8]
  0095c	48 8d 8c 24 60
	06 00 00	 lea	 rcx, QWORD PTR serial$[rsp]
  00964	48 8b f9	 mov	 rdi, rcx
  00967	48 8d 70 04	 lea	 rsi, QWORD PTR [rax+4]
  0096b	b9 0c 00 00 00	 mov	 ecx, 12
  00970	f3 a4		 rep movsb

; 332  :                 continue;

  00972	e9 42 fb ff ff	 jmp	 $LN2@ckd_dasd_i
$LN32@ckd_dasd_i:
$LN31@ckd_dasd_i:

; 333  :             }
; 334  :         }
; 335  : 
; 336  :         // "%1d:%04X CKD file: parameter %s in argument %d is invalid"
; 337  :         WRMSG( HHC00402, "E", LCSS_DEVNUM, argv[i], i + 1 );

  00977	48 83 bc 24 b0
	07 00 00 00	 cmp	 QWORD PTR dev$[rsp], 0
  00980	74 15		 je	 SHORT $LN90@ckd_dasd_i
  00982	48 8b 84 24 b0
	07 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  0098a	0f b7 40 48	 movzx	 eax, WORD PTR [rax+72]
  0098e	89 84 24 c0 00
	00 00		 mov	 DWORD PTR tv427[rsp], eax
  00995	eb 0b		 jmp	 SHORT $LN91@ckd_dasd_i
$LN90@ckd_dasd_i:
  00997	c7 84 24 c0 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv427[rsp], 0
$LN91@ckd_dasd_i:
  009a2	48 83 bc 24 b0
	07 00 00 00	 cmp	 QWORD PTR dev$[rsp], 0
  009ab	74 17		 je	 SHORT $LN92@ckd_dasd_i
  009ad	48 8b 84 24 b0
	07 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  009b5	0f b7 40 44	 movzx	 eax, WORD PTR [rax+68]
  009b9	d1 f8		 sar	 eax, 1
  009bb	89 84 24 c4 00
	00 00		 mov	 DWORD PTR tv433[rsp], eax
  009c2	eb 0b		 jmp	 SHORT $LN93@ckd_dasd_i
$LN92@ckd_dasd_i:
  009c4	c7 84 24 c4 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv433[rsp], 0
$LN93@ckd_dasd_i:
  009cf	8b 84 24 80 00
	00 00		 mov	 eax, DWORD PTR i$[rsp]
  009d6	ff c0		 inc	 eax
  009d8	89 84 24 7c 01
	00 00		 mov	 DWORD PTR tv418[rsp], eax
  009df	48 63 8c 24 80
	00 00 00	 movsxd	 rcx, DWORD PTR i$[rsp]
  009e7	48 89 8c 24 f0
	01 00 00	 mov	 QWORD PTR tv420[rsp], rcx
  009ef	b9 01 00 00 00	 mov	 ecx, 1
  009f4	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  009fa	8b 8c 24 7c 01
	00 00		 mov	 ecx, DWORD PTR tv418[rsp]
  00a01	89 4c 24 50	 mov	 DWORD PTR [rsp+80], ecx
  00a05	48 8b 8c 24 c0
	07 00 00	 mov	 rcx, QWORD PTR argv$[rsp]
  00a0d	48 8b 94 24 f0
	01 00 00	 mov	 rdx, QWORD PTR tv420[rsp]
  00a15	48 8b 0c d1	 mov	 rcx, QWORD PTR [rcx+rdx*8]
  00a19	48 89 4c 24 48	 mov	 QWORD PTR [rsp+72], rcx
  00a1e	8b 8c 24 c0 00
	00 00		 mov	 ecx, DWORD PTR tv427[rsp]
  00a25	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  00a29	8b 8c 24 c4 00
	00 00		 mov	 ecx, DWORD PTR tv433[rsp]
  00a30	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  00a34	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169915
  00a3b	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  00a40	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169916
  00a47	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00a4c	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00a51	41 b9 03 00 00
	00		 mov	 r9d, 3
  00a57	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG169917
  00a5e	ba 51 01 00 00	 mov	 edx, 337		; 00000151H
  00a63	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169918
  00a6a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 338  :         return -1;

  00a70	b8 ff ff ff ff	 mov	 eax, -1
  00a75	e9 b9 1e 00 00	 jmp	 $LN1@ckd_dasd_i

; 339  :     }

  00a7a	e9 3a fa ff ff	 jmp	 $LN2@ckd_dasd_i
$LN3@ckd_dasd_i:

; 340  : 
; 341  :     /* Initialize the total tracks and cylinders */
; 342  :     dev->ckdtrks = 0;

  00a7f	48 8b 84 24 b0
	07 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00a87	c7 80 bc 12 00
	00 00 00 00 00	 mov	 DWORD PTR [rax+4796], 0

; 343  :     dev->ckdcyls = 0;

  00a91	48 8b 84 24 b0
	07 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00a99	c7 80 b8 12 00
	00 00 00 00 00	 mov	 DWORD PTR [rax+4792], 0

; 344  : 
; 345  :     /* Open all of the CKD image files which comprise this volume */
; 346  :     for (fileseq = 1;;)

  00aa3	c7 84 24 84 00
	00 00 01 00 00
	00		 mov	 DWORD PTR fileseq$[rsp], 1
$LN5@ckd_dasd_i:

; 347  :     {
; 348  :         /* Open the CKD image file */
; 349  :         dev->fd = HOPEN (dev->filename, dev->ckdrdonly ?

  00aae	48 8b 84 24 b0
	07 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00ab6	8b 80 14 13 00
	00		 mov	 eax, DWORD PTR [rax+4884]
  00abc	c1 e8 12	 shr	 eax, 18
  00abf	83 e0 01	 and	 eax, 1
  00ac2	85 c0		 test	 eax, eax
  00ac4	74 0d		 je	 SHORT $LN94@ckd_dasd_i
  00ac6	c7 84 24 c8 00
	00 00 00 80 00
	00		 mov	 DWORD PTR tv452[rsp], 32768 ; 00008000H
  00ad1	eb 0b		 jmp	 SHORT $LN95@ckd_dasd_i
$LN94@ckd_dasd_i:
  00ad3	c7 84 24 c8 00
	00 00 02 80 00
	00		 mov	 DWORD PTR tv452[rsp], 32770 ; 00008002H
$LN95@ckd_dasd_i:
  00ade	48 8b 84 24 b0
	07 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00ae6	48 05 a4 00 00
	00		 add	 rax, 164		; 000000a4H
  00aec	8b 94 24 c8 00
	00 00		 mov	 edx, DWORD PTR tv452[rsp]
  00af3	48 8b c8	 mov	 rcx, rax
  00af6	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_hopen
  00afc	48 8b 8c 24 b0
	07 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  00b04	89 81 ac 01 00
	00		 mov	 DWORD PTR [rcx+428], eax

; 350  :                         O_RDONLY|O_BINARY : O_RDWR|O_BINARY);
; 351  :         if (dev->fd < 0)

  00b0a	48 8b 84 24 b0
	07 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00b12	83 b8 ac 01 00
	00 00		 cmp	 DWORD PTR [rax+428], 0
  00b19	0f 8d 64 01 00
	00		 jge	 $LN33@ckd_dasd_i

; 352  :         {   /* Try read-only if shadow file present */
; 353  :             if (!dev->ckdrdonly && dev->dasdsfn != NULL)

  00b1f	48 8b 84 24 b0
	07 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00b27	8b 80 14 13 00
	00		 mov	 eax, DWORD PTR [rax+4884]
  00b2d	c1 e8 12	 shr	 eax, 18
  00b30	83 e0 01	 and	 eax, 1
  00b33	85 c0		 test	 eax, eax
  00b35	75 3c		 jne	 SHORT $LN34@ckd_dasd_i
  00b37	48 8b 84 24 b0
	07 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00b3f	48 83 b8 70 11
	00 00 00	 cmp	 QWORD PTR [rax+4464], 0
  00b47	74 2a		 je	 SHORT $LN34@ckd_dasd_i

; 354  :                 dev->fd = HOPEN (dev->filename, O_RDONLY|O_BINARY);

  00b49	48 8b 84 24 b0
	07 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00b51	48 05 a4 00 00
	00		 add	 rax, 164		; 000000a4H
  00b57	ba 00 80 00 00	 mov	 edx, 32768		; 00008000H
  00b5c	48 8b c8	 mov	 rcx, rax
  00b5f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_hopen
  00b65	48 8b 8c 24 b0
	07 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  00b6d	89 81 ac 01 00
	00		 mov	 DWORD PTR [rcx+428], eax
$LN34@ckd_dasd_i:

; 355  :             if (dev->fd < 0)

  00b73	48 8b 84 24 b0
	07 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00b7b	83 b8 ac 01 00
	00 00		 cmp	 DWORD PTR [rax+428], 0
  00b82	0f 8d fb 00 00
	00		 jge	 $LN35@ckd_dasd_i

; 356  :             {
; 357  :                 // "%1d:%04X CKD file %s: error in function %s: %s"
; 358  :                 WRMSG( HHC00404, "E", LCSS_DEVNUM,

  00b88	48 83 bc 24 b0
	07 00 00 00	 cmp	 QWORD PTR dev$[rsp], 0
  00b91	74 15		 je	 SHORT $LN96@ckd_dasd_i
  00b93	48 8b 84 24 b0
	07 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00b9b	0f b7 40 48	 movzx	 eax, WORD PTR [rax+72]
  00b9f	89 84 24 cc 00
	00 00		 mov	 DWORD PTR tv512[rsp], eax
  00ba6	eb 0b		 jmp	 SHORT $LN97@ckd_dasd_i
$LN96@ckd_dasd_i:
  00ba8	c7 84 24 cc 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv512[rsp], 0
$LN97@ckd_dasd_i:
  00bb3	48 83 bc 24 b0
	07 00 00 00	 cmp	 QWORD PTR dev$[rsp], 0
  00bbc	74 17		 je	 SHORT $LN98@ckd_dasd_i
  00bbe	48 8b 84 24 b0
	07 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00bc6	0f b7 40 44	 movzx	 eax, WORD PTR [rax+68]
  00bca	d1 f8		 sar	 eax, 1
  00bcc	89 84 24 d0 00
	00 00		 mov	 DWORD PTR tv518[rsp], eax
  00bd3	eb 0b		 jmp	 SHORT $LN99@ckd_dasd_i
$LN98@ckd_dasd_i:
  00bd5	c7 84 24 d0 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv518[rsp], 0
$LN99@ckd_dasd_i:
  00be0	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno
  00be6	8b 08		 mov	 ecx, DWORD PTR [rax]
  00be8	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_strerror
  00bee	48 89 84 24 f8
	01 00 00	 mov	 QWORD PTR tv471[rsp], rax
  00bf6	b9 01 00 00 00	 mov	 ecx, 1
  00bfb	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  00c01	48 8b 8c 24 f8
	01 00 00	 mov	 rcx, QWORD PTR tv471[rsp]
  00c09	48 89 4c 24 58	 mov	 QWORD PTR [rsp+88], rcx
  00c0e	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169922
  00c15	48 89 4c 24 50	 mov	 QWORD PTR [rsp+80], rcx
  00c1a	48 8d 8c 24 70
	06 00 00	 lea	 rcx, QWORD PTR filename$[rsp]
  00c22	48 89 4c 24 48	 mov	 QWORD PTR [rsp+72], rcx
  00c27	8b 8c 24 cc 00
	00 00		 mov	 ecx, DWORD PTR tv512[rsp]
  00c2e	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  00c32	8b 8c 24 d0 00
	00 00		 mov	 ecx, DWORD PTR tv518[rsp]
  00c39	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  00c3d	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169923
  00c44	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  00c49	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169924
  00c50	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00c55	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00c5a	41 b9 03 00 00
	00		 mov	 r9d, 3
  00c60	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG169925
  00c67	ba 67 01 00 00	 mov	 edx, 359		; 00000167H
  00c6c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169926
  00c73	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 359  :                                  filename, "open()", strerror( errno ));
; 360  :                 return -1;

  00c79	b8 ff ff ff ff	 mov	 eax, -1
  00c7e	e9 b0 1c 00 00	 jmp	 $LN1@ckd_dasd_i
$LN35@ckd_dasd_i:
$LN33@ckd_dasd_i:

; 361  :             }
; 362  :         }
; 363  : 
; 364  :         /* If shadow file, only one base file is allowed */
; 365  :         if (fileseq > 1 && dev->dasdsfn != NULL)

  00c83	83 bc 24 84 00
	00 00 01	 cmp	 DWORD PTR fileseq$[rsp], 1
  00c8b	0f 8e e2 00 00
	00		 jle	 $LN36@ckd_dasd_i
  00c91	48 8b 84 24 b0
	07 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00c99	48 83 b8 70 11
	00 00 00	 cmp	 QWORD PTR [rax+4464], 0
  00ca1	0f 84 cc 00 00
	00		 je	 $LN36@ckd_dasd_i

; 366  :         {
; 367  :             // "%1d:%04X CKD file %s: only one base file is allowed"
; 368  :             WRMSG( HHC00405, "E", LCSS_DEVNUM, filename );

  00ca7	48 83 bc 24 b0
	07 00 00 00	 cmp	 QWORD PTR dev$[rsp], 0
  00cb0	74 15		 je	 SHORT $LN100@ckd_dasd_i
  00cb2	48 8b 84 24 b0
	07 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00cba	0f b7 40 48	 movzx	 eax, WORD PTR [rax+72]
  00cbe	89 84 24 d4 00
	00 00		 mov	 DWORD PTR tv536[rsp], eax
  00cc5	eb 0b		 jmp	 SHORT $LN101@ckd_dasd_i
$LN100@ckd_dasd_i:
  00cc7	c7 84 24 d4 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv536[rsp], 0
$LN101@ckd_dasd_i:
  00cd2	48 83 bc 24 b0
	07 00 00 00	 cmp	 QWORD PTR dev$[rsp], 0
  00cdb	74 17		 je	 SHORT $LN102@ckd_dasd_i
  00cdd	48 8b 84 24 b0
	07 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00ce5	0f b7 40 44	 movzx	 eax, WORD PTR [rax+68]
  00ce9	d1 f8		 sar	 eax, 1
  00ceb	89 84 24 d8 00
	00 00		 mov	 DWORD PTR tv542[rsp], eax
  00cf2	eb 0b		 jmp	 SHORT $LN103@ckd_dasd_i
$LN102@ckd_dasd_i:
  00cf4	c7 84 24 d8 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv542[rsp], 0
$LN103@ckd_dasd_i:
  00cff	b9 01 00 00 00	 mov	 ecx, 1
  00d04	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  00d0a	48 8d 8c 24 70
	06 00 00	 lea	 rcx, QWORD PTR filename$[rsp]
  00d12	48 89 4c 24 48	 mov	 QWORD PTR [rsp+72], rcx
  00d17	8b 8c 24 d4 00
	00 00		 mov	 ecx, DWORD PTR tv536[rsp]
  00d1e	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  00d22	8b 8c 24 d8 00
	00 00		 mov	 ecx, DWORD PTR tv542[rsp]
  00d29	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  00d2d	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169928
  00d34	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  00d39	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169929
  00d40	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00d45	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00d4a	41 b9 03 00 00
	00		 mov	 r9d, 3
  00d50	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG169930
  00d57	ba 70 01 00 00	 mov	 edx, 368		; 00000170H
  00d5c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169931
  00d63	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 369  :             return -1;

  00d69	b8 ff ff ff ff	 mov	 eax, -1
  00d6e	e9 c0 1b 00 00	 jmp	 $LN1@ckd_dasd_i
$LN36@ckd_dasd_i:

; 370  :         }
; 371  : 
; 372  :         /* Determine the device size */
; 373  :         rc = fstat (dev->fd, &statbuf);

  00d73	48 8d 94 24 20
	02 00 00	 lea	 rdx, QWORD PTR statbuf$[rsp]
  00d7b	48 8b 84 24 b0
	07 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00d83	8b 88 ac 01 00
	00		 mov	 ecx, DWORD PTR [rax+428]
  00d89	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__fstat64
  00d8f	89 84 24 8c 00
	00 00		 mov	 DWORD PTR rc$[rsp], eax

; 374  :         if (rc < 0)

  00d96	83 bc 24 8c 00
	00 00 00	 cmp	 DWORD PTR rc$[rsp], 0
  00d9e	0f 8d fb 00 00
	00		 jge	 $LN37@ckd_dasd_i

; 375  :         {
; 376  :             // "%1d:%04X CKD file %s: error in function %s: %s"
; 377  :             WRMSG( HHC00404, "E", LCSS_DEVNUM, filename, "fstat()", strerror( errno ));

  00da4	48 83 bc 24 b0
	07 00 00 00	 cmp	 QWORD PTR dev$[rsp], 0
  00dad	74 15		 je	 SHORT $LN104@ckd_dasd_i
  00daf	48 8b 84 24 b0
	07 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00db7	0f b7 40 48	 movzx	 eax, WORD PTR [rax+72]
  00dbb	89 84 24 dc 00
	00 00		 mov	 DWORD PTR tv567[rsp], eax
  00dc2	eb 0b		 jmp	 SHORT $LN105@ckd_dasd_i
$LN104@ckd_dasd_i:
  00dc4	c7 84 24 dc 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv567[rsp], 0
$LN105@ckd_dasd_i:
  00dcf	48 83 bc 24 b0
	07 00 00 00	 cmp	 QWORD PTR dev$[rsp], 0
  00dd8	74 17		 je	 SHORT $LN106@ckd_dasd_i
  00dda	48 8b 84 24 b0
	07 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00de2	0f b7 40 44	 movzx	 eax, WORD PTR [rax+68]
  00de6	d1 f8		 sar	 eax, 1
  00de8	89 84 24 e0 00
	00 00		 mov	 DWORD PTR tv573[rsp], eax
  00def	eb 0b		 jmp	 SHORT $LN107@ckd_dasd_i
$LN106@ckd_dasd_i:
  00df1	c7 84 24 e0 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv573[rsp], 0
$LN107@ckd_dasd_i:
  00dfc	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno
  00e02	8b 08		 mov	 ecx, DWORD PTR [rax]
  00e04	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_strerror
  00e0a	48 89 84 24 00
	02 00 00	 mov	 QWORD PTR tv558[rsp], rax
  00e12	b9 01 00 00 00	 mov	 ecx, 1
  00e17	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  00e1d	48 8b 8c 24 00
	02 00 00	 mov	 rcx, QWORD PTR tv558[rsp]
  00e25	48 89 4c 24 58	 mov	 QWORD PTR [rsp+88], rcx
  00e2a	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169933
  00e31	48 89 4c 24 50	 mov	 QWORD PTR [rsp+80], rcx
  00e36	48 8d 8c 24 70
	06 00 00	 lea	 rcx, QWORD PTR filename$[rsp]
  00e3e	48 89 4c 24 48	 mov	 QWORD PTR [rsp+72], rcx
  00e43	8b 8c 24 dc 00
	00 00		 mov	 ecx, DWORD PTR tv567[rsp]
  00e4a	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  00e4e	8b 8c 24 e0 00
	00 00		 mov	 ecx, DWORD PTR tv573[rsp]
  00e55	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  00e59	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169934
  00e60	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  00e65	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169935
  00e6c	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00e71	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00e76	41 b9 03 00 00
	00		 mov	 r9d, 3
  00e7c	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG169936
  00e83	ba 79 01 00 00	 mov	 edx, 377		; 00000179H
  00e88	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169937
  00e8f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 378  :             return -1;

  00e95	b8 ff ff ff ff	 mov	 eax, -1
  00e9a	e9 94 1a 00 00	 jmp	 $LN1@ckd_dasd_i
$LN37@ckd_dasd_i:

; 379  :         }
; 380  : 
; 381  :         /* Read the device header */
; 382  :         rc = read (dev->fd, &devhdr, CKD_DEVHDR_SIZE);

  00e9f	41 b8 00 02 00
	00		 mov	 r8d, 512		; 00000200H
  00ea5	48 8d 94 24 60
	02 00 00	 lea	 rdx, QWORD PTR devhdr$[rsp]
  00ead	48 8b 84 24 b0
	07 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00eb5	8b 88 ac 01 00
	00		 mov	 ecx, DWORD PTR [rax+428]
  00ebb	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_read
  00ec1	89 84 24 8c 00
	00 00		 mov	 DWORD PTR rc$[rsp], eax

; 383  :         if (rc < (int)CKD_DEVHDR_SIZE)

  00ec8	81 bc 24 8c 00
	00 00 00 02 00
	00		 cmp	 DWORD PTR rc$[rsp], 512	; 00000200H
  00ed3	0f 8d e8 01 00
	00		 jge	 $LN38@ckd_dasd_i

; 384  :         {
; 385  :             if (rc < 0)

  00ed9	83 bc 24 8c 00
	00 00 00	 cmp	 DWORD PTR rc$[rsp], 0
  00ee1	0f 8d f6 00 00
	00		 jge	 $LN39@ckd_dasd_i

; 386  :                 // "%1d:%04X CKD file %s: error in function %s: %s"
; 387  :                 WRMSG( HHC00404, "E", LCSS_DEVNUM,

  00ee7	48 83 bc 24 b0
	07 00 00 00	 cmp	 QWORD PTR dev$[rsp], 0
  00ef0	74 15		 je	 SHORT $LN108@ckd_dasd_i
  00ef2	48 8b 84 24 b0
	07 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00efa	0f b7 40 48	 movzx	 eax, WORD PTR [rax+72]
  00efe	89 84 24 e4 00
	00 00		 mov	 DWORD PTR tv600[rsp], eax
  00f05	eb 0b		 jmp	 SHORT $LN109@ckd_dasd_i
$LN108@ckd_dasd_i:
  00f07	c7 84 24 e4 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv600[rsp], 0
$LN109@ckd_dasd_i:
  00f12	48 83 bc 24 b0
	07 00 00 00	 cmp	 QWORD PTR dev$[rsp], 0
  00f1b	74 17		 je	 SHORT $LN110@ckd_dasd_i
  00f1d	48 8b 84 24 b0
	07 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00f25	0f b7 40 44	 movzx	 eax, WORD PTR [rax+68]
  00f29	d1 f8		 sar	 eax, 1
  00f2b	89 84 24 e8 00
	00 00		 mov	 DWORD PTR tv606[rsp], eax
  00f32	eb 0b		 jmp	 SHORT $LN111@ckd_dasd_i
$LN110@ckd_dasd_i:
  00f34	c7 84 24 e8 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv606[rsp], 0
$LN111@ckd_dasd_i:
  00f3f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno
  00f45	8b 08		 mov	 ecx, DWORD PTR [rax]
  00f47	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_strerror
  00f4d	48 89 84 24 08
	02 00 00	 mov	 QWORD PTR tv591[rsp], rax
  00f55	b9 01 00 00 00	 mov	 ecx, 1
  00f5a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  00f60	48 8b 8c 24 08
	02 00 00	 mov	 rcx, QWORD PTR tv591[rsp]
  00f68	48 89 4c 24 58	 mov	 QWORD PTR [rsp+88], rcx
  00f6d	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169941
  00f74	48 89 4c 24 50	 mov	 QWORD PTR [rsp+80], rcx
  00f79	48 8d 8c 24 70
	06 00 00	 lea	 rcx, QWORD PTR filename$[rsp]
  00f81	48 89 4c 24 48	 mov	 QWORD PTR [rsp+72], rcx
  00f86	8b 8c 24 e4 00
	00 00		 mov	 ecx, DWORD PTR tv600[rsp]
  00f8d	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  00f91	8b 8c 24 e8 00
	00 00		 mov	 ecx, DWORD PTR tv606[rsp]
  00f98	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  00f9c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169942
  00fa3	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  00fa8	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169943
  00faf	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00fb4	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00fb9	41 b9 03 00 00
	00		 mov	 r9d, 3
  00fbf	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG169944
  00fc6	ba 84 01 00 00	 mov	 edx, 388		; 00000184H
  00fcb	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169945
  00fd2	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg
  00fd8	e9 da 00 00 00	 jmp	 $LN40@ckd_dasd_i
$LN39@ckd_dasd_i:

; 388  :                        filename, "read()", strerror( errno ));
; 389  :             else
; 390  :                 // "%1d:%04X CKD file %s: error in function %s: %s"
; 391  :                 WRMSG( HHC00404, "E", LCSS_DEVNUM,

  00fdd	48 83 bc 24 b0
	07 00 00 00	 cmp	 QWORD PTR dev$[rsp], 0
  00fe6	74 15		 je	 SHORT $LN112@ckd_dasd_i
  00fe8	48 8b 84 24 b0
	07 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00ff0	0f b7 40 48	 movzx	 eax, WORD PTR [rax+72]
  00ff4	89 84 24 ec 00
	00 00		 mov	 DWORD PTR tv623[rsp], eax
  00ffb	eb 0b		 jmp	 SHORT $LN113@ckd_dasd_i
$LN112@ckd_dasd_i:
  00ffd	c7 84 24 ec 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv623[rsp], 0
$LN113@ckd_dasd_i:
  01008	48 83 bc 24 b0
	07 00 00 00	 cmp	 QWORD PTR dev$[rsp], 0
  01011	74 17		 je	 SHORT $LN114@ckd_dasd_i
  01013	48 8b 84 24 b0
	07 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  0101b	0f b7 40 44	 movzx	 eax, WORD PTR [rax+68]
  0101f	d1 f8		 sar	 eax, 1
  01021	89 84 24 f0 00
	00 00		 mov	 DWORD PTR tv629[rsp], eax
  01028	eb 0b		 jmp	 SHORT $LN115@ckd_dasd_i
$LN114@ckd_dasd_i:
  0102a	c7 84 24 f0 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv629[rsp], 0
$LN115@ckd_dasd_i:
  01035	b9 01 00 00 00	 mov	 ecx, 1
  0103a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  01040	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169946
  01047	48 89 4c 24 58	 mov	 QWORD PTR [rsp+88], rcx
  0104c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169947
  01053	48 89 4c 24 50	 mov	 QWORD PTR [rsp+80], rcx
  01058	48 8d 8c 24 70
	06 00 00	 lea	 rcx, QWORD PTR filename$[rsp]
  01060	48 89 4c 24 48	 mov	 QWORD PTR [rsp+72], rcx
  01065	8b 8c 24 ec 00
	00 00		 mov	 ecx, DWORD PTR tv623[rsp]
  0106c	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  01070	8b 8c 24 f0 00
	00 00		 mov	 ecx, DWORD PTR tv629[rsp]
  01077	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  0107b	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169948
  01082	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  01087	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169949
  0108e	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  01093	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  01098	41 b9 03 00 00
	00		 mov	 r9d, 3
  0109e	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG169950
  010a5	ba 88 01 00 00	 mov	 edx, 392		; 00000188H
  010aa	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169951
  010b1	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg
$LN40@ckd_dasd_i:

; 392  :                        filename, "read()", "CKD header incomplete" );
; 393  :             return -1;

  010b7	b8 ff ff ff ff	 mov	 eax, -1
  010bc	e9 72 18 00 00	 jmp	 $LN1@ckd_dasd_i
$LN38@ckd_dasd_i:

; 394  :         }
; 395  : 
; 396  :         /* Save the serial number */
; 397  :         if (serial[0]) // (override?)

  010c1	b8 01 00 00 00	 mov	 eax, 1
  010c6	48 6b c0 00	 imul	 rax, rax, 0
  010ca	0f b6 84 04 60
	06 00 00	 movzx	 eax, BYTE PTR serial$[rsp+rax]
  010d2	85 c0		 test	 eax, eax
  010d4	74 23		 je	 SHORT $LN41@ckd_dasd_i

; 398  :             memcpy( dev->serial, serial, sizeof( dev->serial ));

  010d6	48 8b 84 24 b0
	07 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  010de	48 8d 8c 24 60
	06 00 00	 lea	 rcx, QWORD PTR serial$[rsp]
  010e6	48 8d b8 98 00
	00 00		 lea	 rdi, QWORD PTR [rax+152]
  010ed	48 8b f1	 mov	 rsi, rcx
  010f0	b9 0c 00 00 00	 mov	 ecx, 12
  010f5	f3 a4		 rep movsb
  010f7	eb 21		 jmp	 SHORT $LN42@ckd_dasd_i
$LN41@ckd_dasd_i:

; 399  :         else
; 400  :             memcpy( dev->serial, devhdr.dh_serial, sizeof( dev->serial ));

  010f9	48 8b 84 24 b0
	07 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  01101	48 8d 8c 24 74
	02 00 00	 lea	 rcx, QWORD PTR devhdr$[rsp+20]
  01109	48 8d b8 98 00
	00 00		 lea	 rdi, QWORD PTR [rax+152]
  01110	48 8b f1	 mov	 rsi, rcx
  01113	b9 0c 00 00 00	 mov	 ecx, 12
  01118	f3 a4		 rep movsb
$LN42@ckd_dasd_i:

; 401  :         {
; 402  :             static const BYTE nulls[12] = {0};
; 403  :             if (memcmp( dev->serial, nulls, 12 ) == 0)

  0111a	48 8b 84 24 b0
	07 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  01122	48 05 98 00 00
	00		 add	 rax, 152		; 00000098H
  01128	41 b8 0c 00 00
	00		 mov	 r8d, 12
  0112e	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:?nulls@?BL@??ckd_dasd_init_handler@@9@9
  01135	48 8b c8	 mov	 rcx, rax
  01138	e8 00 00 00 00	 call	 memcmp
  0113d	85 c0		 test	 eax, eax
  0113f	75 16		 jne	 SHORT $LN43@ckd_dasd_i

; 404  :                 gen_dasd_serial( dev->serial );

  01141	48 8b 84 24 b0
	07 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  01149	48 05 98 00 00
	00		 add	 rax, 152		; 00000098H
  0114f	48 8b c8	 mov	 rcx, rax
  01152	e8 00 00 00 00	 call	 gen_dasd_serial
$LN43@ckd_dasd_i:

; 405  :         }
; 406  : 
; 407  :         /* Check the device header identifier */
; 408  :         dev->cckd64 = 0;

  01157	48 8b 84 24 b0
	07 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  0115f	0f b6 80 10 13
	00 00		 movzx	 eax, BYTE PTR [rax+4880]
  01166	24 fe		 and	 al, 254			; 000000feH
  01168	48 8b 8c 24 b0
	07 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  01170	88 81 10 13 00
	00		 mov	 BYTE PTR [rcx+4880], al

; 409  :         if (!is_dh_devid_typ( devhdr.dh_devid, CKD32_CMP_OR_NML_TYP ))

  01176	ba 00 00 00 c0	 mov	 edx, -1073741824	; c0000000H
  0117b	48 8d 8c 24 60
	02 00 00	 lea	 rcx, QWORD PTR devhdr$[rsp]
  01183	e8 00 00 00 00	 call	 is_dh_devid_typ
  01188	0f b6 c0	 movzx	 eax, al
  0118b	85 c0		 test	 eax, eax
  0118d	0f 85 4b 01 00
	00		 jne	 $LN44@ckd_dasd_i

; 410  :         {
; 411  :             if (is_dh_devid_typ( devhdr.dh_devid, CKD64_CMP_OR_NML_TYP ))

  01193	ba 00 00 c0 00	 mov	 edx, 12582912		; 00c00000H
  01198	48 8d 8c 24 60
	02 00 00	 lea	 rcx, QWORD PTR devhdr$[rsp]
  011a0	e8 00 00 00 00	 call	 is_dh_devid_typ
  011a5	0f b6 c0	 movzx	 eax, al
  011a8	85 c0		 test	 eax, eax
  011aa	74 66		 je	 SHORT $LN45@ckd_dasd_i

; 412  :             {
; 413  :                 dev->cckd64 = 1;

  011ac	48 8b 84 24 b0
	07 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  011b4	0f b6 80 10 13
	00 00		 movzx	 eax, BYTE PTR [rax+4880]
  011bb	0c 01		 or	 al, 1
  011bd	48 8b 8c 24 b0
	07 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  011c5	88 81 10 13 00
	00		 mov	 BYTE PTR [rcx+4880], al

; 414  :                 close( dev->fd );

  011cb	48 8b 84 24 b0
	07 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  011d3	8b 88 ac 01 00
	00		 mov	 ecx, DWORD PTR [rax+428]
  011d9	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_close

; 415  :                 dev->fd = -1;

  011df	48 8b 84 24 b0
	07 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  011e7	c7 80 ac 01 00
	00 ff ff ff ff	 mov	 DWORD PTR [rax+428], -1

; 416  :                 return ckd64_dasd_init_handler( dev, argc, argv );

  011f1	4c 8b 84 24 c0
	07 00 00	 mov	 r8, QWORD PTR argv$[rsp]
  011f9	8b 94 24 b8 07
	00 00		 mov	 edx, DWORD PTR argc$[rsp]
  01200	48 8b 8c 24 b0
	07 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  01208	e8 00 00 00 00	 call	 ckd64_dasd_init_handler
  0120d	e9 21 17 00 00	 jmp	 $LN1@ckd_dasd_i
$LN45@ckd_dasd_i:

; 417  :             }
; 418  : 
; 419  :             // "%1d:%04X CKD file %s: ckd header invalid"
; 420  :             WRMSG( HHC00406, "E", LCSS_DEVNUM, filename );

  01212	48 83 bc 24 b0
	07 00 00 00	 cmp	 QWORD PTR dev$[rsp], 0
  0121b	74 15		 je	 SHORT $LN116@ckd_dasd_i
  0121d	48 8b 84 24 b0
	07 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  01225	0f b7 40 48	 movzx	 eax, WORD PTR [rax+72]
  01229	89 84 24 f4 00
	00 00		 mov	 DWORD PTR tv697[rsp], eax
  01230	eb 0b		 jmp	 SHORT $LN117@ckd_dasd_i
$LN116@ckd_dasd_i:
  01232	c7 84 24 f4 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv697[rsp], 0
$LN117@ckd_dasd_i:
  0123d	48 83 bc 24 b0
	07 00 00 00	 cmp	 QWORD PTR dev$[rsp], 0
  01246	74 17		 je	 SHORT $LN118@ckd_dasd_i
  01248	48 8b 84 24 b0
	07 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  01250	0f b7 40 44	 movzx	 eax, WORD PTR [rax+68]
  01254	d1 f8		 sar	 eax, 1
  01256	89 84 24 f8 00
	00 00		 mov	 DWORD PTR tv703[rsp], eax
  0125d	eb 0b		 jmp	 SHORT $LN119@ckd_dasd_i
$LN118@ckd_dasd_i:
  0125f	c7 84 24 f8 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv703[rsp], 0
$LN119@ckd_dasd_i:
  0126a	b9 01 00 00 00	 mov	 ecx, 1
  0126f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  01275	48 8d 8c 24 70
	06 00 00	 lea	 rcx, QWORD PTR filename$[rsp]
  0127d	48 89 4c 24 48	 mov	 QWORD PTR [rsp+72], rcx
  01282	8b 8c 24 f4 00
	00 00		 mov	 ecx, DWORD PTR tv697[rsp]
  01289	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  0128d	8b 8c 24 f8 00
	00 00		 mov	 ecx, DWORD PTR tv703[rsp]
  01294	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  01298	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169957
  0129f	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  012a4	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169958
  012ab	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  012b0	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  012b5	41 b9 03 00 00
	00		 mov	 r9d, 3
  012bb	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG169959
  012c2	ba a4 01 00 00	 mov	 edx, 420		; 000001a4H
  012c7	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169960
  012ce	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 421  :             return -1;

  012d4	b8 ff ff ff ff	 mov	 eax, -1
  012d9	e9 55 16 00 00	 jmp	 $LN1@ckd_dasd_i
$LN44@ckd_dasd_i:

; 422  :         }
; 423  : 
; 424  :         if (is_dh_devid_typ( devhdr.dh_devid, CKD_C370_TYP ))

  012de	ba 00 00 00 40	 mov	 edx, 1073741824		; 40000000H
  012e3	48 8d 8c 24 60
	02 00 00	 lea	 rcx, QWORD PTR devhdr$[rsp]
  012eb	e8 00 00 00 00	 call	 is_dh_devid_typ
  012f0	0f b6 c0	 movzx	 eax, al
  012f3	85 c0		 test	 eax, eax
  012f5	0f 84 1c 01 00
	00		 je	 $LN46@ckd_dasd_i

; 425  :         {
; 426  :             cckd = 1;

  012fb	c7 84 24 88 00
	00 00 01 00 00
	00		 mov	 DWORD PTR cckd$[rsp], 1

; 427  : 
; 428  :             if (fileseq != 1)

  01306	83 bc 24 84 00
	00 00 01	 cmp	 DWORD PTR fileseq$[rsp], 1
  0130e	0f 84 03 01 00
	00		 je	 $LN47@ckd_dasd_i

; 429  :             {
; 430  :                 // "%1d:%04X %s file %s: only 1 CCKD file allowed"
; 431  :                 WRMSG( HHC00407, "E", LCSS_DEVNUM, CKDTYP( cckd, 0 ), filename );

  01314	83 bc 24 88 00
	00 00 00	 cmp	 DWORD PTR cckd$[rsp], 0
  0131c	74 11		 je	 SHORT $LN120@ckd_dasd_i
  0131e	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG169963
  01325	48 89 84 24 88
	01 00 00	 mov	 QWORD PTR tv722[rsp], rax
  0132d	eb 0f		 jmp	 SHORT $LN121@ckd_dasd_i
$LN120@ckd_dasd_i:
  0132f	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG169964
  01336	48 89 84 24 88
	01 00 00	 mov	 QWORD PTR tv722[rsp], rax
$LN121@ckd_dasd_i:
  0133e	48 83 bc 24 b0
	07 00 00 00	 cmp	 QWORD PTR dev$[rsp], 0
  01347	74 15		 je	 SHORT $LN122@ckd_dasd_i
  01349	48 8b 84 24 b0
	07 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  01351	0f b7 40 48	 movzx	 eax, WORD PTR [rax+72]
  01355	89 84 24 fc 00
	00 00		 mov	 DWORD PTR tv727[rsp], eax
  0135c	eb 0b		 jmp	 SHORT $LN123@ckd_dasd_i
$LN122@ckd_dasd_i:
  0135e	c7 84 24 fc 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv727[rsp], 0
$LN123@ckd_dasd_i:
  01369	48 83 bc 24 b0
	07 00 00 00	 cmp	 QWORD PTR dev$[rsp], 0
  01372	74 17		 je	 SHORT $LN124@ckd_dasd_i
  01374	48 8b 84 24 b0
	07 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  0137c	0f b7 40 44	 movzx	 eax, WORD PTR [rax+68]
  01380	d1 f8		 sar	 eax, 1
  01382	89 84 24 00 01
	00 00		 mov	 DWORD PTR tv733[rsp], eax
  01389	eb 0b		 jmp	 SHORT $LN125@ckd_dasd_i
$LN124@ckd_dasd_i:
  0138b	c7 84 24 00 01
	00 00 00 00 00
	00		 mov	 DWORD PTR tv733[rsp], 0
$LN125@ckd_dasd_i:
  01396	b9 01 00 00 00	 mov	 ecx, 1
  0139b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  013a1	48 8d 8c 24 70
	06 00 00	 lea	 rcx, QWORD PTR filename$[rsp]
  013a9	48 89 4c 24 50	 mov	 QWORD PTR [rsp+80], rcx
  013ae	48 8b 8c 24 88
	01 00 00	 mov	 rcx, QWORD PTR tv722[rsp]
  013b6	48 89 4c 24 48	 mov	 QWORD PTR [rsp+72], rcx
  013bb	8b 8c 24 fc 00
	00 00		 mov	 ecx, DWORD PTR tv727[rsp]
  013c2	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  013c6	8b 8c 24 00 01
	00 00		 mov	 ecx, DWORD PTR tv733[rsp]
  013cd	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  013d1	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169965
  013d8	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  013dd	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169966
  013e4	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  013e9	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  013ee	41 b9 03 00 00
	00		 mov	 r9d, 3
  013f4	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG169967
  013fb	ba af 01 00 00	 mov	 edx, 431		; 000001afH
  01400	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169968
  01407	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 432  :                 return -1;

  0140d	b8 ff ff ff ff	 mov	 eax, -1
  01412	e9 1c 15 00 00	 jmp	 $LN1@ckd_dasd_i
$LN47@ckd_dasd_i:
$LN46@ckd_dasd_i:

; 433  :             }
; 434  :         }
; 435  : 
; 436  :         if (dev->ckdrdonly)

  01417	48 8b 84 24 b0
	07 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  0141f	8b 80 14 13 00
	00		 mov	 eax, DWORD PTR [rax+4884]
  01425	c1 e8 12	 shr	 eax, 18
  01428	83 e0 01	 and	 eax, 1
  0142b	85 c0		 test	 eax, eax
  0142d	0f 84 5a 01 00
	00		 je	 $LN48@ckd_dasd_i

; 437  :             if (!dev->quiet)

  01433	48 8b 84 24 b0
	07 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  0143b	8b 80 f8 05 00
	00		 mov	 eax, DWORD PTR [rax+1528]
  01441	c1 e8 0c	 shr	 eax, 12
  01444	83 e0 01	 and	 eax, 1
  01447	85 c0		 test	 eax, eax
  01449	0f 85 3e 01 00
	00		 jne	 $LN49@ckd_dasd_i

; 438  :                 // "%1d:%04X %s file %s: opened r/o%s"
; 439  :                 WRMSG( HHC00403, "I", LCSS_DEVNUM, CKDTYP( cckd, 0 ),

  0144f	48 8b 84 24 b0
	07 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  01457	8b 80 14 13 00
	00		 mov	 eax, DWORD PTR [rax+4884]
  0145d	c1 e8 14	 shr	 eax, 20
  01460	83 e0 01	 and	 eax, 1
  01463	85 c0		 test	 eax, eax
  01465	74 11		 je	 SHORT $LN126@ckd_dasd_i
  01467	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG169971
  0146e	48 89 84 24 90
	01 00 00	 mov	 QWORD PTR tv788[rsp], rax
  01476	eb 0f		 jmp	 SHORT $LN127@ckd_dasd_i
$LN126@ckd_dasd_i:
  01478	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG169972
  0147f	48 89 84 24 90
	01 00 00	 mov	 QWORD PTR tv788[rsp], rax
$LN127@ckd_dasd_i:
  01487	83 bc 24 88 00
	00 00 00	 cmp	 DWORD PTR cckd$[rsp], 0
  0148f	74 11		 je	 SHORT $LN128@ckd_dasd_i
  01491	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG169973
  01498	48 89 84 24 98
	01 00 00	 mov	 QWORD PTR tv792[rsp], rax
  014a0	eb 0f		 jmp	 SHORT $LN129@ckd_dasd_i
$LN128@ckd_dasd_i:
  014a2	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG169974
  014a9	48 89 84 24 98
	01 00 00	 mov	 QWORD PTR tv792[rsp], rax
$LN129@ckd_dasd_i:
  014b1	48 83 bc 24 b0
	07 00 00 00	 cmp	 QWORD PTR dev$[rsp], 0
  014ba	74 15		 je	 SHORT $LN130@ckd_dasd_i
  014bc	48 8b 84 24 b0
	07 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  014c4	0f b7 40 48	 movzx	 eax, WORD PTR [rax+72]
  014c8	89 84 24 04 01
	00 00		 mov	 DWORD PTR tv797[rsp], eax
  014cf	eb 0b		 jmp	 SHORT $LN131@ckd_dasd_i
$LN130@ckd_dasd_i:
  014d1	c7 84 24 04 01
	00 00 00 00 00
	00		 mov	 DWORD PTR tv797[rsp], 0
$LN131@ckd_dasd_i:
  014dc	48 83 bc 24 b0
	07 00 00 00	 cmp	 QWORD PTR dev$[rsp], 0
  014e5	74 17		 je	 SHORT $LN132@ckd_dasd_i
  014e7	48 8b 84 24 b0
	07 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  014ef	0f b7 40 44	 movzx	 eax, WORD PTR [rax+68]
  014f3	d1 f8		 sar	 eax, 1
  014f5	89 84 24 08 01
	00 00		 mov	 DWORD PTR tv803[rsp], eax
  014fc	eb 0b		 jmp	 SHORT $LN133@ckd_dasd_i
$LN132@ckd_dasd_i:
  014fe	c7 84 24 08 01
	00 00 00 00 00
	00		 mov	 DWORD PTR tv803[rsp], 0
$LN133@ckd_dasd_i:
  01509	b9 01 00 00 00	 mov	 ecx, 1
  0150e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  01514	48 8b 8c 24 90
	01 00 00	 mov	 rcx, QWORD PTR tv788[rsp]
  0151c	48 89 4c 24 58	 mov	 QWORD PTR [rsp+88], rcx
  01521	48 8d 8c 24 70
	06 00 00	 lea	 rcx, QWORD PTR filename$[rsp]
  01529	48 89 4c 24 50	 mov	 QWORD PTR [rsp+80], rcx
  0152e	48 8b 8c 24 98
	01 00 00	 mov	 rcx, QWORD PTR tv792[rsp]
  01536	48 89 4c 24 48	 mov	 QWORD PTR [rsp+72], rcx
  0153b	8b 8c 24 04 01
	00 00		 mov	 ecx, DWORD PTR tv797[rsp]
  01542	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  01546	8b 8c 24 08 01
	00 00		 mov	 ecx, DWORD PTR tv803[rsp]
  0154d	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  01551	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169975
  01558	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  0155d	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169976
  01564	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  01569	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  0156e	41 b9 03 00 00
	00		 mov	 r9d, 3
  01574	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG169977
  0157b	ba b8 01 00 00	 mov	 edx, 440		; 000001b8H
  01580	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169978
  01587	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg
$LN49@ckd_dasd_i:
$LN48@ckd_dasd_i:

; 440  :                     filename, dev->ckdfakewr ? " with fake writing" : "" );
; 441  : 
; 442  :         /* Read the compressed device header */
; 443  :         if (cckd)

  0158d	83 bc 24 88 00
	00 00 00	 cmp	 DWORD PTR cckd$[rsp], 0
  01595	0f 84 22 02 00
	00		 je	 $LN50@ckd_dasd_i

; 444  :         {
; 445  :             rc = read (dev->fd, &cdevhdr, CCKD_DEVHDR_SIZE);

  0159b	41 b8 00 02 00
	00		 mov	 r8d, 512		; 00000200H
  015a1	48 8d 94 24 60
	04 00 00	 lea	 rdx, QWORD PTR cdevhdr$[rsp]
  015a9	48 8b 84 24 b0
	07 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  015b1	8b 88 ac 01 00
	00		 mov	 ecx, DWORD PTR [rax+428]
  015b7	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_read
  015bd	89 84 24 8c 00
	00 00		 mov	 DWORD PTR rc$[rsp], eax

; 446  :             if (rc < (int)                CCKD_DEVHDR_SIZE)

  015c4	81 bc 24 8c 00
	00 00 00 02 00
	00		 cmp	 DWORD PTR rc$[rsp], 512	; 00000200H
  015cf	0f 8d e8 01 00
	00		 jge	 $LN51@ckd_dasd_i

; 447  :             {
; 448  :                 if (rc < 0)

  015d5	83 bc 24 8c 00
	00 00 00	 cmp	 DWORD PTR rc$[rsp], 0
  015dd	0f 8d f6 00 00
	00		 jge	 $LN52@ckd_dasd_i

; 449  :                 {
; 450  :                     // "%1d:%04X CKD file %s: error in function %s: %s"
; 451  :                     WRMSG( HHC00404, "E", LCSS_DEVNUM,

  015e3	48 83 bc 24 b0
	07 00 00 00	 cmp	 QWORD PTR dev$[rsp], 0
  015ec	74 15		 je	 SHORT $LN134@ckd_dasd_i
  015ee	48 8b 84 24 b0
	07 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  015f6	0f b7 40 48	 movzx	 eax, WORD PTR [rax+72]
  015fa	89 84 24 0c 01
	00 00		 mov	 DWORD PTR tv831[rsp], eax
  01601	eb 0b		 jmp	 SHORT $LN135@ckd_dasd_i
$LN134@ckd_dasd_i:
  01603	c7 84 24 0c 01
	00 00 00 00 00
	00		 mov	 DWORD PTR tv831[rsp], 0
$LN135@ckd_dasd_i:
  0160e	48 83 bc 24 b0
	07 00 00 00	 cmp	 QWORD PTR dev$[rsp], 0
  01617	74 17		 je	 SHORT $LN136@ckd_dasd_i
  01619	48 8b 84 24 b0
	07 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  01621	0f b7 40 44	 movzx	 eax, WORD PTR [rax+68]
  01625	d1 f8		 sar	 eax, 1
  01627	89 84 24 10 01
	00 00		 mov	 DWORD PTR tv837[rsp], eax
  0162e	eb 0b		 jmp	 SHORT $LN137@ckd_dasd_i
$LN136@ckd_dasd_i:
  01630	c7 84 24 10 01
	00 00 00 00 00
	00		 mov	 DWORD PTR tv837[rsp], 0
$LN137@ckd_dasd_i:
  0163b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno
  01641	8b 08		 mov	 ecx, DWORD PTR [rax]
  01643	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_strerror
  01649	48 89 84 24 10
	02 00 00	 mov	 QWORD PTR tv822[rsp], rax
  01651	b9 01 00 00 00	 mov	 ecx, 1
  01656	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  0165c	48 8b 8c 24 10
	02 00 00	 mov	 rcx, QWORD PTR tv822[rsp]
  01664	48 89 4c 24 58	 mov	 QWORD PTR [rsp+88], rcx
  01669	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169983
  01670	48 89 4c 24 50	 mov	 QWORD PTR [rsp+80], rcx
  01675	48 8d 8c 24 70
	06 00 00	 lea	 rcx, QWORD PTR filename$[rsp]
  0167d	48 89 4c 24 48	 mov	 QWORD PTR [rsp+72], rcx
  01682	8b 8c 24 0c 01
	00 00		 mov	 ecx, DWORD PTR tv831[rsp]
  01689	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  0168d	8b 8c 24 10 01
	00 00		 mov	 ecx, DWORD PTR tv837[rsp]
  01694	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  01698	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169984
  0169f	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  016a4	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169985
  016ab	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  016b0	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  016b5	41 b9 03 00 00
	00		 mov	 r9d, 3
  016bb	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG169986
  016c2	ba c4 01 00 00	 mov	 edx, 452		; 000001c4H
  016c7	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169987
  016ce	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 452  :                            filename, "read()", strerror( errno ));
; 453  :                 }

  016d4	e9 da 00 00 00	 jmp	 $LN53@ckd_dasd_i
$LN52@ckd_dasd_i:

; 454  :                 else
; 455  :                 {
; 456  :                     // "%1d:%04X CKD file %s: error in function %s: %s"
; 457  :                     WRMSG( HHC00404, "E", LCSS_DEVNUM,

  016d9	48 83 bc 24 b0
	07 00 00 00	 cmp	 QWORD PTR dev$[rsp], 0
  016e2	74 15		 je	 SHORT $LN138@ckd_dasd_i
  016e4	48 8b 84 24 b0
	07 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  016ec	0f b7 40 48	 movzx	 eax, WORD PTR [rax+72]
  016f0	89 84 24 14 01
	00 00		 mov	 DWORD PTR tv854[rsp], eax
  016f7	eb 0b		 jmp	 SHORT $LN139@ckd_dasd_i
$LN138@ckd_dasd_i:
  016f9	c7 84 24 14 01
	00 00 00 00 00
	00		 mov	 DWORD PTR tv854[rsp], 0
$LN139@ckd_dasd_i:
  01704	48 83 bc 24 b0
	07 00 00 00	 cmp	 QWORD PTR dev$[rsp], 0
  0170d	74 17		 je	 SHORT $LN140@ckd_dasd_i
  0170f	48 8b 84 24 b0
	07 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  01717	0f b7 40 44	 movzx	 eax, WORD PTR [rax+68]
  0171b	d1 f8		 sar	 eax, 1
  0171d	89 84 24 18 01
	00 00		 mov	 DWORD PTR tv860[rsp], eax
  01724	eb 0b		 jmp	 SHORT $LN141@ckd_dasd_i
$LN140@ckd_dasd_i:
  01726	c7 84 24 18 01
	00 00 00 00 00
	00		 mov	 DWORD PTR tv860[rsp], 0
$LN141@ckd_dasd_i:
  01731	b9 01 00 00 00	 mov	 ecx, 1
  01736	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  0173c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169988
  01743	48 89 4c 24 58	 mov	 QWORD PTR [rsp+88], rcx
  01748	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169989
  0174f	48 89 4c 24 50	 mov	 QWORD PTR [rsp+80], rcx
  01754	48 8d 8c 24 70
	06 00 00	 lea	 rcx, QWORD PTR filename$[rsp]
  0175c	48 89 4c 24 48	 mov	 QWORD PTR [rsp+72], rcx
  01761	8b 8c 24 14 01
	00 00		 mov	 ecx, DWORD PTR tv854[rsp]
  01768	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  0176c	8b 8c 24 18 01
	00 00		 mov	 ecx, DWORD PTR tv860[rsp]
  01773	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  01777	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169990
  0177e	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  01783	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169991
  0178a	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  0178f	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  01794	41 b9 03 00 00
	00		 mov	 r9d, 3
  0179a	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG169992
  017a1	ba ca 01 00 00	 mov	 edx, 458		; 000001caH
  017a6	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169993
  017ad	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg
$LN53@ckd_dasd_i:

; 458  :                            filename, "read()", "CCKD header incomplete" );
; 459  :                 }
; 460  :                 return -1;

  017b3	b8 ff ff ff ff	 mov	 eax, -1
  017b8	e9 76 11 00 00	 jmp	 $LN1@ckd_dasd_i
$LN51@ckd_dasd_i:
$LN50@ckd_dasd_i:

; 461  :             }
; 462  :         }
; 463  : 
; 464  :         /* Extract fields from device header */
; 465  :         FETCH_LE_FW( heads,   devhdr.dh_heads   );

  017bd	48 8d 8c 24 68
	02 00 00	 lea	 rcx, QWORD PTR devhdr$[rsp+8]
  017c5	e8 00 00 00 00	 call	 fetch_fw_noswap
  017ca	8b c8		 mov	 ecx, eax
  017cc	e8 00 00 00 00	 call	 _byteswap_ulong
  017d1	8b c8		 mov	 ecx, eax
  017d3	e8 00 00 00 00	 call	 _byteswap_ulong
  017d8	89 84 24 9c 00
	00 00		 mov	 DWORD PTR heads$[rsp], eax

; 466  :         FETCH_LE_FW( trksize, devhdr.dh_trksize );

  017df	48 8d 8c 24 6c
	02 00 00	 lea	 rcx, QWORD PTR devhdr$[rsp+12]
  017e7	e8 00 00 00 00	 call	 fetch_fw_noswap
  017ec	8b c8		 mov	 ecx, eax
  017ee	e8 00 00 00 00	 call	 _byteswap_ulong
  017f3	8b c8		 mov	 ecx, eax
  017f5	e8 00 00 00 00	 call	 _byteswap_ulong
  017fa	89 84 24 b0 00
	00 00		 mov	 DWORD PTR trksize$[rsp], eax

; 467  :         FETCH_LE_HW( highcyl, devhdr.dh_highcyl );

  01801	48 8d 8c 24 72
	02 00 00	 lea	 rcx, QWORD PTR devhdr$[rsp+18]
  01809	e8 00 00 00 00	 call	 fetch_hw_noswap
  0180e	0f b7 c8	 movzx	 ecx, ax
  01811	e8 00 00 00 00	 call	 _byteswap_ushort
  01816	0f b7 c8	 movzx	 ecx, ax
  01819	e8 00 00 00 00	 call	 _byteswap_ushort
  0181e	0f b7 c0	 movzx	 eax, ax
  01821	89 84 24 90 00
	00 00		 mov	 DWORD PTR highcyl$[rsp], eax

; 468  : 
; 469  :         if (cckd == 0)

  01828	83 bc 24 88 00
	00 00 00	 cmp	 DWORD PTR cckd$[rsp], 0
  01830	0f 85 67 01 00
	00		 jne	 $LN54@ckd_dasd_i

; 470  :         {
; 471  :             if (dev->dasdcopy == 0)

  01836	48 8b 84 24 b0
	07 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  0183e	8b 80 f8 05 00
	00		 mov	 eax, DWORD PTR [rax+1528]
  01844	c1 e8 0b	 shr	 eax, 11
  01847	83 e0 01	 and	 eax, 1
  0184a	85 c0		 test	 eax, eax
  0184c	75 6a		 jne	 SHORT $LN56@ckd_dasd_i

; 472  :             {
; 473  :                 trks = (int)((statbuf.st_size - CKD_DEVHDR_SIZE) / trksize);

  0184e	48 8b 84 24 38
	02 00 00	 mov	 rax, QWORD PTR statbuf$[rsp+24]
  01856	48 2d 00 02 00
	00		 sub	 rax, 512		; 00000200H
  0185c	48 63 8c 24 b0
	00 00 00	 movsxd	 rcx, DWORD PTR trksize$[rsp]
  01864	48 99		 cdq
  01866	48 f7 f9	 idiv	 rcx
  01869	89 84 24 a0 00
	00 00		 mov	 DWORD PTR trks$[rsp], eax

; 474  :                 cyls = trks / heads;

  01870	8b 84 24 a0 00
	00 00		 mov	 eax, DWORD PTR trks$[rsp]
  01877	99		 cdq
  01878	f7 bc 24 9c 00
	00 00		 idiv	 DWORD PTR heads$[rsp]
  0187f	89 84 24 94 00
	00 00		 mov	 DWORD PTR cyls$[rsp], eax

; 475  :                 if (fileseq == 1 && highcyl == cyls)

  01886	83 bc 24 84 00
	00 00 01	 cmp	 DWORD PTR fileseq$[rsp], 1
  0188e	75 23		 jne	 SHORT $LN58@ckd_dasd_i
  01890	8b 84 24 94 00
	00 00		 mov	 eax, DWORD PTR cyls$[rsp]
  01897	39 84 24 90 00
	00 00		 cmp	 DWORD PTR highcyl$[rsp], eax
  0189e	75 13		 jne	 SHORT $LN58@ckd_dasd_i

; 476  :                 {
; 477  :                     devhdr.dh_fileseq = 0;

  018a0	c6 84 24 71 02
	00 00 00	 mov	 BYTE PTR devhdr$[rsp+17], 0

; 478  :                     highcyl = 0;

  018a8	c7 84 24 90 00
	00 00 00 00 00
	00		 mov	 DWORD PTR highcyl$[rsp], 0
$LN58@ckd_dasd_i:

; 479  :                 }
; 480  :             }

  018b3	e9 e3 00 00 00	 jmp	 $LN57@ckd_dasd_i
$LN56@ckd_dasd_i:

; 481  :             else
; 482  :             {
; 483  :                 /*
; 484  :                  * For dasdcopy we get the number of cylinders and tracks from
; 485  :                  * the highcyl in the device header.  The last file will have
; 486  :                  * a sequence number of 0xFF.
; 487  :                  */
; 488  :                 cyls = highcyl - dev->ckdcyls + 1;

  018b8	48 8b 84 24 b0
	07 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  018c0	8b 80 b8 12 00
	00		 mov	 eax, DWORD PTR [rax+4792]
  018c6	8b 8c 24 90 00
	00 00		 mov	 ecx, DWORD PTR highcyl$[rsp]
  018cd	2b c8		 sub	 ecx, eax
  018cf	8b c1		 mov	 eax, ecx
  018d1	ff c0		 inc	 eax
  018d3	89 84 24 94 00
	00 00		 mov	 DWORD PTR cyls$[rsp], eax

; 489  :                 trks = cyls * heads;

  018da	8b 84 24 94 00
	00 00		 mov	 eax, DWORD PTR cyls$[rsp]
  018e1	0f af 84 24 9c
	00 00 00	 imul	 eax, DWORD PTR heads$[rsp]
  018e9	89 84 24 a0 00
	00 00		 mov	 DWORD PTR trks$[rsp], eax

; 490  :                 if (devhdr.dh_fileseq == 0xFF)

  018f0	0f b6 84 24 71
	02 00 00	 movzx	 eax, BYTE PTR devhdr$[rsp+17]
  018f8	3d ff 00 00 00	 cmp	 eax, 255		; 000000ffH
  018fd	0f 85 98 00 00
	00		 jne	 $LN59@ckd_dasd_i

; 491  :                 {
; 492  :                     devhdr.dh_fileseq = (fileseq == 1 ? 0 : fileseq);

  01903	83 bc 24 84 00
	00 00 01	 cmp	 DWORD PTR fileseq$[rsp], 1
  0190b	75 0d		 jne	 SHORT $LN142@ckd_dasd_i
  0190d	c7 84 24 1c 01
	00 00 00 00 00
	00		 mov	 DWORD PTR tv909[rsp], 0
  01918	eb 0e		 jmp	 SHORT $LN143@ckd_dasd_i
$LN142@ckd_dasd_i:
  0191a	8b 84 24 84 00
	00 00		 mov	 eax, DWORD PTR fileseq$[rsp]
  01921	89 84 24 1c 01
	00 00		 mov	 DWORD PTR tv909[rsp], eax
$LN143@ckd_dasd_i:
  01928	0f b6 84 24 1c
	01 00 00	 movzx	 eax, BYTE PTR tv909[rsp]
  01930	88 84 24 71 02
	00 00		 mov	 BYTE PTR devhdr$[rsp+17], al

; 493  :                     highcyl = 0;

  01937	c7 84 24 90 00
	00 00 00 00 00
	00		 mov	 DWORD PTR highcyl$[rsp], 0

; 494  :                     store_hw( devhdr.dh_highcyl, 0 );

  01942	33 c9		 xor	 ecx, ecx
  01944	e8 00 00 00 00	 call	 _byteswap_ushort
  01949	0f b7 d0	 movzx	 edx, ax
  0194c	48 8d 8c 24 72
	02 00 00	 lea	 rcx, QWORD PTR devhdr$[rsp+18]
  01954	e8 00 00 00 00	 call	 store_hw_noswap

; 495  :                     lseek (dev->fd, 0, SEEK_SET);

  01959	45 33 c0	 xor	 r8d, r8d
  0195c	33 d2		 xor	 edx, edx
  0195e	48 8b 84 24 b0
	07 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  01966	8b 88 ac 01 00
	00		 mov	 ecx, DWORD PTR [rax+428]
  0196c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__lseeki64

; 496  :                     rc = write (dev->fd, &devhdr, CKD_DEVHDR_SIZE);

  01972	41 b8 00 02 00
	00		 mov	 r8d, 512		; 00000200H
  01978	48 8d 94 24 60
	02 00 00	 lea	 rdx, QWORD PTR devhdr$[rsp]
  01980	48 8b 84 24 b0
	07 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  01988	8b 88 ac 01 00
	00		 mov	 ecx, DWORD PTR [rax+428]
  0198e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_write
  01994	89 84 24 8c 00
	00 00		 mov	 DWORD PTR rc$[rsp], eax
$LN59@ckd_dasd_i:
$LN57@ckd_dasd_i:

; 497  :                 }
; 498  :             }
; 499  :         }

  0199b	eb 38		 jmp	 SHORT $LN55@ckd_dasd_i
$LN54@ckd_dasd_i:

; 500  :         else
; 501  :         {
; 502  :             FETCH_LE_FW( cyls, cdevhdr.cdh_cyls );

  0199d	48 8d 8c 24 88
	04 00 00	 lea	 rcx, QWORD PTR cdevhdr$[rsp+40]
  019a5	e8 00 00 00 00	 call	 fetch_fw_noswap
  019aa	8b c8		 mov	 ecx, eax
  019ac	e8 00 00 00 00	 call	 _byteswap_ulong
  019b1	8b c8		 mov	 ecx, eax
  019b3	e8 00 00 00 00	 call	 _byteswap_ulong
  019b8	89 84 24 94 00
	00 00		 mov	 DWORD PTR cyls$[rsp], eax

; 503  :             trks = cyls * heads;

  019bf	8b 84 24 94 00
	00 00		 mov	 eax, DWORD PTR cyls$[rsp]
  019c6	0f af 84 24 9c
	00 00 00	 imul	 eax, DWORD PTR heads$[rsp]
  019ce	89 84 24 a0 00
	00 00		 mov	 DWORD PTR trks$[rsp], eax
$LN55@ckd_dasd_i:

; 504  :         }
; 505  : 
; 506  :         /* Check for correct file sequence number */
; 507  :         if (devhdr.dh_fileseq != fileseq
; 508  :             && !(devhdr.dh_fileseq == 0 && fileseq == 1))

  019d5	0f b6 84 24 71
	02 00 00	 movzx	 eax, BYTE PTR devhdr$[rsp+17]
  019dd	3b 84 24 84 00
	00 00		 cmp	 eax, DWORD PTR fileseq$[rsp]
  019e4	0f 84 1d 01 00
	00		 je	 $LN60@ckd_dasd_i
  019ea	0f b6 84 24 71
	02 00 00	 movzx	 eax, BYTE PTR devhdr$[rsp+17]
  019f2	85 c0		 test	 eax, eax
  019f4	75 0e		 jne	 SHORT $LN61@ckd_dasd_i
  019f6	83 bc 24 84 00
	00 00 01	 cmp	 DWORD PTR fileseq$[rsp], 1
  019fe	0f 84 03 01 00
	00		 je	 $LN60@ckd_dasd_i
$LN61@ckd_dasd_i:

; 509  :         {
; 510  :             // "%1d:%04X %s file %s: ckd file out of sequence or bad size"
; 511  :             WRMSG( HHC00408, "E", LCSS_DEVNUM, CKDTYP( cckd, 0 ), filename );

  01a04	83 bc 24 88 00
	00 00 00	 cmp	 DWORD PTR cckd$[rsp], 0
  01a0c	74 11		 je	 SHORT $LN144@ckd_dasd_i
  01a0e	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG170002
  01a15	48 89 84 24 a0
	01 00 00	 mov	 QWORD PTR tv970[rsp], rax
  01a1d	eb 0f		 jmp	 SHORT $LN145@ckd_dasd_i
$LN144@ckd_dasd_i:
  01a1f	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG170003
  01a26	48 89 84 24 a0
	01 00 00	 mov	 QWORD PTR tv970[rsp], rax
$LN145@ckd_dasd_i:
  01a2e	48 83 bc 24 b0
	07 00 00 00	 cmp	 QWORD PTR dev$[rsp], 0
  01a37	74 15		 je	 SHORT $LN146@ckd_dasd_i
  01a39	48 8b 84 24 b0
	07 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  01a41	0f b7 40 48	 movzx	 eax, WORD PTR [rax+72]
  01a45	89 84 24 20 01
	00 00		 mov	 DWORD PTR tv975[rsp], eax
  01a4c	eb 0b		 jmp	 SHORT $LN147@ckd_dasd_i
$LN146@ckd_dasd_i:
  01a4e	c7 84 24 20 01
	00 00 00 00 00
	00		 mov	 DWORD PTR tv975[rsp], 0
$LN147@ckd_dasd_i:
  01a59	48 83 bc 24 b0
	07 00 00 00	 cmp	 QWORD PTR dev$[rsp], 0
  01a62	74 17		 je	 SHORT $LN148@ckd_dasd_i
  01a64	48 8b 84 24 b0
	07 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  01a6c	0f b7 40 44	 movzx	 eax, WORD PTR [rax+68]
  01a70	d1 f8		 sar	 eax, 1
  01a72	89 84 24 24 01
	00 00		 mov	 DWORD PTR tv981[rsp], eax
  01a79	eb 0b		 jmp	 SHORT $LN149@ckd_dasd_i
$LN148@ckd_dasd_i:
  01a7b	c7 84 24 24 01
	00 00 00 00 00
	00		 mov	 DWORD PTR tv981[rsp], 0
$LN149@ckd_dasd_i:
  01a86	b9 01 00 00 00	 mov	 ecx, 1
  01a8b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  01a91	48 8d 8c 24 70
	06 00 00	 lea	 rcx, QWORD PTR filename$[rsp]
  01a99	48 89 4c 24 50	 mov	 QWORD PTR [rsp+80], rcx
  01a9e	48 8b 8c 24 a0
	01 00 00	 mov	 rcx, QWORD PTR tv970[rsp]
  01aa6	48 89 4c 24 48	 mov	 QWORD PTR [rsp+72], rcx
  01aab	8b 8c 24 20 01
	00 00		 mov	 ecx, DWORD PTR tv975[rsp]
  01ab2	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  01ab6	8b 8c 24 24 01
	00 00		 mov	 ecx, DWORD PTR tv981[rsp]
  01abd	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  01ac1	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170004
  01ac8	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  01acd	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170005
  01ad4	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  01ad9	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  01ade	41 b9 03 00 00
	00		 mov	 r9d, 3
  01ae4	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG170006
  01aeb	ba ff 01 00 00	 mov	 edx, 511		; 000001ffH
  01af0	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170007
  01af7	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 512  :             return -1;

  01afd	b8 ff ff ff ff	 mov	 eax, -1
  01b02	e9 2c 0e 00 00	 jmp	 $LN1@ckd_dasd_i
$LN60@ckd_dasd_i:

; 513  :         }
; 514  : 
; 515  :         if (devhdr.dh_fileseq > 0)

  01b07	0f b6 84 24 71
	02 00 00	 movzx	 eax, BYTE PTR devhdr$[rsp+17]
  01b0f	85 c0		 test	 eax, eax
  01b11	0f 8e 86 01 00
	00		 jle	 $LN62@ckd_dasd_i

; 516  :         {
; 517  :             if (!dev->quiet)

  01b17	48 8b 84 24 b0
	07 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  01b1f	8b 80 f8 05 00
	00		 mov	 eax, DWORD PTR [rax+1528]
  01b25	c1 e8 0c	 shr	 eax, 12
  01b28	83 e0 01	 and	 eax, 1
  01b2b	85 c0		 test	 eax, eax
  01b2d	0f 85 6a 01 00
	00		 jne	 $LN63@ckd_dasd_i

; 518  :                 // "%1d:%04X %s file %s: seq %02d cyls %6d-%-6d"
; 519  :                 WRMSG( HHC00409, "I", LCSS_DEVNUM, CKDTYP( cckd, 0 ),

  01b33	83 bc 24 90 00
	00 00 00	 cmp	 DWORD PTR highcyl$[rsp], 0
  01b3b	7e 10		 jle	 SHORT $LN150@ckd_dasd_i
  01b3d	8b 84 24 90 00
	00 00		 mov	 eax, DWORD PTR highcyl$[rsp]
  01b44	89 84 24 28 01
	00 00		 mov	 DWORD PTR tv1002[rsp], eax
  01b4b	eb 20		 jmp	 SHORT $LN151@ckd_dasd_i
$LN150@ckd_dasd_i:
  01b4d	48 8b 84 24 b0
	07 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  01b55	8b 80 b8 12 00
	00		 mov	 eax, DWORD PTR [rax+4792]
  01b5b	8b 8c 24 94 00
	00 00		 mov	 ecx, DWORD PTR cyls$[rsp]
  01b62	8d 44 08 ff	 lea	 eax, DWORD PTR [rax+rcx-1]
  01b66	89 84 24 28 01
	00 00		 mov	 DWORD PTR tv1002[rsp], eax
$LN151@ckd_dasd_i:
  01b6d	83 bc 24 88 00
	00 00 00	 cmp	 DWORD PTR cckd$[rsp], 0
  01b75	74 11		 je	 SHORT $LN152@ckd_dasd_i
  01b77	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG170010
  01b7e	48 89 84 24 a8
	01 00 00	 mov	 QWORD PTR tv1010[rsp], rax
  01b86	eb 0f		 jmp	 SHORT $LN153@ckd_dasd_i
$LN152@ckd_dasd_i:
  01b88	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG170011
  01b8f	48 89 84 24 a8
	01 00 00	 mov	 QWORD PTR tv1010[rsp], rax
$LN153@ckd_dasd_i:
  01b97	48 83 bc 24 b0
	07 00 00 00	 cmp	 QWORD PTR dev$[rsp], 0
  01ba0	74 15		 je	 SHORT $LN154@ckd_dasd_i
  01ba2	48 8b 84 24 b0
	07 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  01baa	0f b7 40 48	 movzx	 eax, WORD PTR [rax+72]
  01bae	89 84 24 2c 01
	00 00		 mov	 DWORD PTR tv1015[rsp], eax
  01bb5	eb 0b		 jmp	 SHORT $LN155@ckd_dasd_i
$LN154@ckd_dasd_i:
  01bb7	c7 84 24 2c 01
	00 00 00 00 00
	00		 mov	 DWORD PTR tv1015[rsp], 0
$LN155@ckd_dasd_i:
  01bc2	48 83 bc 24 b0
	07 00 00 00	 cmp	 QWORD PTR dev$[rsp], 0
  01bcb	74 17		 je	 SHORT $LN156@ckd_dasd_i
  01bcd	48 8b 84 24 b0
	07 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  01bd5	0f b7 40 44	 movzx	 eax, WORD PTR [rax+68]
  01bd9	d1 f8		 sar	 eax, 1
  01bdb	89 84 24 30 01
	00 00		 mov	 DWORD PTR tv1021[rsp], eax
  01be2	eb 0b		 jmp	 SHORT $LN157@ckd_dasd_i
$LN156@ckd_dasd_i:
  01be4	c7 84 24 30 01
	00 00 00 00 00
	00		 mov	 DWORD PTR tv1021[rsp], 0
$LN157@ckd_dasd_i:
  01bef	0f b6 84 24 71
	02 00 00	 movzx	 eax, BYTE PTR devhdr$[rsp+17]
  01bf7	89 84 24 80 01
	00 00		 mov	 DWORD PTR tv1006[rsp], eax
  01bfe	b9 01 00 00 00	 mov	 ecx, 1
  01c03	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  01c09	8b 8c 24 28 01
	00 00		 mov	 ecx, DWORD PTR tv1002[rsp]
  01c10	89 4c 24 68	 mov	 DWORD PTR [rsp+104], ecx
  01c14	48 8b 8c 24 b0
	07 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  01c1c	8b 89 b8 12 00
	00		 mov	 ecx, DWORD PTR [rcx+4792]
  01c22	89 4c 24 60	 mov	 DWORD PTR [rsp+96], ecx
  01c26	8b 8c 24 80 01
	00 00		 mov	 ecx, DWORD PTR tv1006[rsp]
  01c2d	89 4c 24 58	 mov	 DWORD PTR [rsp+88], ecx
  01c31	48 8d 8c 24 70
	06 00 00	 lea	 rcx, QWORD PTR filename$[rsp]
  01c39	48 89 4c 24 50	 mov	 QWORD PTR [rsp+80], rcx
  01c3e	48 8b 8c 24 a8
	01 00 00	 mov	 rcx, QWORD PTR tv1010[rsp]
  01c46	48 89 4c 24 48	 mov	 QWORD PTR [rsp+72], rcx
  01c4b	8b 8c 24 2c 01
	00 00		 mov	 ecx, DWORD PTR tv1015[rsp]
  01c52	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  01c56	8b 8c 24 30 01
	00 00		 mov	 ecx, DWORD PTR tv1021[rsp]
  01c5d	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  01c61	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170012
  01c68	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  01c6d	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170013
  01c74	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  01c79	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  01c7e	41 b9 03 00 00
	00		 mov	 r9d, 3
  01c84	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG170014
  01c8b	ba 09 02 00 00	 mov	 edx, 521		; 00000209H
  01c90	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170015
  01c97	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg
$LN63@ckd_dasd_i:
$LN62@ckd_dasd_i:

; 520  :                        filename, devhdr.dh_fileseq, dev->ckdcyls,
; 521  :                        (highcyl > 0 ? highcyl : dev->ckdcyls + cyls - 1));
; 522  :         }
; 523  : 
; 524  :         /* Save device geometry of first file, or check that device
; 525  :            geometry of subsequent files matches that of first file */
; 526  :         if (fileseq == 1)

  01c9d	83 bc 24 84 00
	00 00 01	 cmp	 DWORD PTR fileseq$[rsp], 1
  01ca5	75 2f		 jne	 SHORT $LN64@ckd_dasd_i

; 527  :         {
; 528  :             dev->ckdheads = heads;

  01ca7	48 8b 84 24 b0
	07 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  01caf	8b 8c 24 9c 00
	00 00		 mov	 ecx, DWORD PTR heads$[rsp]
  01cb6	89 88 c0 12 00
	00		 mov	 DWORD PTR [rax+4800], ecx

; 529  :             dev->ckdtrksz = trksize;

  01cbc	48 8b 84 24 b0
	07 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  01cc4	8b 8c 24 b0 00
	00 00		 mov	 ecx, DWORD PTR trksize$[rsp]
  01ccb	89 88 c4 12 00
	00		 mov	 DWORD PTR [rax+4804], ecx

; 530  :         }

  01cd1	e9 6f 01 00 00	 jmp	 $LN65@ckd_dasd_i
$LN64@ckd_dasd_i:

; 531  :         else if (heads != dev->ckdheads || trksize != dev->ckdtrksz)

  01cd6	48 8b 84 24 b0
	07 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  01cde	8b 80 c0 12 00
	00		 mov	 eax, DWORD PTR [rax+4800]
  01ce4	39 84 24 9c 00
	00 00		 cmp	 DWORD PTR heads$[rsp], eax
  01ceb	75 1b		 jne	 SHORT $LN67@ckd_dasd_i
  01ced	48 8b 84 24 b0
	07 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  01cf5	8b 80 c4 12 00
	00		 mov	 eax, DWORD PTR [rax+4804]
  01cfb	39 84 24 b0 00
	00 00		 cmp	 DWORD PTR trksize$[rsp], eax
  01d02	0f 84 3d 01 00
	00		 je	 $LN66@ckd_dasd_i
$LN67@ckd_dasd_i:

; 532  :         {
; 533  :             // "%1d:%04X %s file %s: found heads %d trklen %d, expected heads %d trklen %d"
; 534  :             WRMSG( HHC00410, "E", LCSS_DEVNUM, CKDTYP( cckd, 0 ),

  01d08	83 bc 24 88 00
	00 00 00	 cmp	 DWORD PTR cckd$[rsp], 0
  01d10	74 11		 je	 SHORT $LN158@ckd_dasd_i
  01d12	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG170020
  01d19	48 89 84 24 b0
	01 00 00	 mov	 QWORD PTR tv1079[rsp], rax
  01d21	eb 0f		 jmp	 SHORT $LN159@ckd_dasd_i
$LN158@ckd_dasd_i:
  01d23	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG170021
  01d2a	48 89 84 24 b0
	01 00 00	 mov	 QWORD PTR tv1079[rsp], rax
$LN159@ckd_dasd_i:
  01d32	48 83 bc 24 b0
	07 00 00 00	 cmp	 QWORD PTR dev$[rsp], 0
  01d3b	74 15		 je	 SHORT $LN160@ckd_dasd_i
  01d3d	48 8b 84 24 b0
	07 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  01d45	0f b7 40 48	 movzx	 eax, WORD PTR [rax+72]
  01d49	89 84 24 34 01
	00 00		 mov	 DWORD PTR tv1084[rsp], eax
  01d50	eb 0b		 jmp	 SHORT $LN161@ckd_dasd_i
$LN160@ckd_dasd_i:
  01d52	c7 84 24 34 01
	00 00 00 00 00
	00		 mov	 DWORD PTR tv1084[rsp], 0
$LN161@ckd_dasd_i:
  01d5d	48 83 bc 24 b0
	07 00 00 00	 cmp	 QWORD PTR dev$[rsp], 0
  01d66	74 17		 je	 SHORT $LN162@ckd_dasd_i
  01d68	48 8b 84 24 b0
	07 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  01d70	0f b7 40 44	 movzx	 eax, WORD PTR [rax+68]
  01d74	d1 f8		 sar	 eax, 1
  01d76	89 84 24 38 01
	00 00		 mov	 DWORD PTR tv1090[rsp], eax
  01d7d	eb 0b		 jmp	 SHORT $LN163@ckd_dasd_i
$LN162@ckd_dasd_i:
  01d7f	c7 84 24 38 01
	00 00 00 00 00
	00		 mov	 DWORD PTR tv1090[rsp], 0
$LN163@ckd_dasd_i:
  01d8a	b9 01 00 00 00	 mov	 ecx, 1
  01d8f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  01d95	48 8b 8c 24 b0
	07 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  01d9d	8b 89 c4 12 00
	00		 mov	 ecx, DWORD PTR [rcx+4804]
  01da3	89 4c 24 70	 mov	 DWORD PTR [rsp+112], ecx
  01da7	48 8b 8c 24 b0
	07 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  01daf	8b 89 c0 12 00
	00		 mov	 ecx, DWORD PTR [rcx+4800]
  01db5	89 4c 24 68	 mov	 DWORD PTR [rsp+104], ecx
  01db9	8b 8c 24 b0 00
	00 00		 mov	 ecx, DWORD PTR trksize$[rsp]
  01dc0	89 4c 24 60	 mov	 DWORD PTR [rsp+96], ecx
  01dc4	8b 8c 24 9c 00
	00 00		 mov	 ecx, DWORD PTR heads$[rsp]
  01dcb	89 4c 24 58	 mov	 DWORD PTR [rsp+88], ecx
  01dcf	48 8d 8c 24 70
	06 00 00	 lea	 rcx, QWORD PTR filename$[rsp]
  01dd7	48 89 4c 24 50	 mov	 QWORD PTR [rsp+80], rcx
  01ddc	48 8b 8c 24 b0
	01 00 00	 mov	 rcx, QWORD PTR tv1079[rsp]
  01de4	48 89 4c 24 48	 mov	 QWORD PTR [rsp+72], rcx
  01de9	8b 8c 24 34 01
	00 00		 mov	 ecx, DWORD PTR tv1084[rsp]
  01df0	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  01df4	8b 8c 24 38 01
	00 00		 mov	 ecx, DWORD PTR tv1090[rsp]
  01dfb	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  01dff	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170022
  01e06	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  01e0b	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170023
  01e12	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  01e17	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  01e1c	41 b9 03 00 00
	00		 mov	 r9d, 3
  01e22	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG170024
  01e29	ba 17 02 00 00	 mov	 edx, 535		; 00000217H
  01e2e	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170025
  01e35	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 535  :                    filename, heads, trksize, dev->ckdheads, dev->ckdtrksz );
; 536  :             return -1;

  01e3b	b8 ff ff ff ff	 mov	 eax, -1
  01e40	e9 ee 0a 00 00	 jmp	 $LN1@ckd_dasd_i
$LN66@ckd_dasd_i:
$LN65@ckd_dasd_i:

; 537  :         }
; 538  : 
; 539  :         /* Consistency check device header */
; 540  :         if (cckd == 0 && dev->dasdcopy == 0 && (cyls * heads != trks

  01e45	83 bc 24 88 00
	00 00 00	 cmp	 DWORD PTR cckd$[rsp], 0
  01e4d	0f 85 8f 01 00
	00		 jne	 $LN68@ckd_dasd_i
  01e53	48 8b 84 24 b0
	07 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  01e5b	8b 80 f8 05 00
	00		 mov	 eax, DWORD PTR [rax+1528]
  01e61	c1 e8 0b	 shr	 eax, 11
  01e64	83 e0 01	 and	 eax, 1
  01e67	85 c0		 test	 eax, eax
  01e69	0f 85 73 01 00
	00		 jne	 $LN68@ckd_dasd_i
  01e6f	8b 84 24 94 00
	00 00		 mov	 eax, DWORD PTR cyls$[rsp]
  01e76	0f af 84 24 9c
	00 00 00	 imul	 eax, DWORD PTR heads$[rsp]
  01e7e	3b 84 24 a0 00
	00 00		 cmp	 eax, DWORD PTR trks$[rsp]
  01e85	75 58		 jne	 SHORT $LN69@ckd_dasd_i
  01e87	48 63 84 24 a0
	00 00 00	 movsxd	 rax, DWORD PTR trks$[rsp]
  01e8f	48 63 8c 24 b0
	00 00 00	 movsxd	 rcx, DWORD PTR trksize$[rsp]
  01e97	48 0f af c1	 imul	 rax, rcx
  01e9b	48 05 00 02 00
	00		 add	 rax, 512		; 00000200H
  01ea1	48 3b 84 24 38
	02 00 00	 cmp	 rax, QWORD PTR statbuf$[rsp+24]
  01ea9	75 34		 jne	 SHORT $LN69@ckd_dasd_i
  01eab	83 bc 24 90 00
	00 00 00	 cmp	 DWORD PTR highcyl$[rsp], 0
  01eb3	0f 84 29 01 00
	00		 je	 $LN68@ckd_dasd_i
  01eb9	48 8b 84 24 b0
	07 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  01ec1	8b 80 b8 12 00
	00		 mov	 eax, DWORD PTR [rax+4792]
  01ec7	8b 8c 24 94 00
	00 00		 mov	 ecx, DWORD PTR cyls$[rsp]
  01ece	8d 44 08 ff	 lea	 eax, DWORD PTR [rax+rcx-1]
  01ed2	39 84 24 90 00
	00 00		 cmp	 DWORD PTR highcyl$[rsp], eax
  01ed9	0f 84 03 01 00
	00		 je	 $LN68@ckd_dasd_i
$LN69@ckd_dasd_i:

; 541  :             || ((off_t)trks * trksize) + CKD_DEVHDR_SIZE
; 542  :                             != statbuf.st_size
; 543  :             || (highcyl != 0 && highcyl != dev->ckdcyls + cyls - 1)))
; 544  :         {
; 545  :             // "%1d:%04X %s file %s: ckd header inconsistent with file size"
; 546  :             WRMSG( HHC00411, "E", LCSS_DEVNUM, CKDTYP( cckd, 0 ), filename );

  01edf	83 bc 24 88 00
	00 00 00	 cmp	 DWORD PTR cckd$[rsp], 0
  01ee7	74 11		 je	 SHORT $LN164@ckd_dasd_i
  01ee9	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG170028
  01ef0	48 89 84 24 b8
	01 00 00	 mov	 QWORD PTR tv1120[rsp], rax
  01ef8	eb 0f		 jmp	 SHORT $LN165@ckd_dasd_i
$LN164@ckd_dasd_i:
  01efa	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG170029
  01f01	48 89 84 24 b8
	01 00 00	 mov	 QWORD PTR tv1120[rsp], rax
$LN165@ckd_dasd_i:
  01f09	48 83 bc 24 b0
	07 00 00 00	 cmp	 QWORD PTR dev$[rsp], 0
  01f12	74 15		 je	 SHORT $LN166@ckd_dasd_i
  01f14	48 8b 84 24 b0
	07 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  01f1c	0f b7 40 48	 movzx	 eax, WORD PTR [rax+72]
  01f20	89 84 24 3c 01
	00 00		 mov	 DWORD PTR tv1125[rsp], eax
  01f27	eb 0b		 jmp	 SHORT $LN167@ckd_dasd_i
$LN166@ckd_dasd_i:
  01f29	c7 84 24 3c 01
	00 00 00 00 00
	00		 mov	 DWORD PTR tv1125[rsp], 0
$LN167@ckd_dasd_i:
  01f34	48 83 bc 24 b0
	07 00 00 00	 cmp	 QWORD PTR dev$[rsp], 0
  01f3d	74 17		 je	 SHORT $LN168@ckd_dasd_i
  01f3f	48 8b 84 24 b0
	07 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  01f47	0f b7 40 44	 movzx	 eax, WORD PTR [rax+68]
  01f4b	d1 f8		 sar	 eax, 1
  01f4d	89 84 24 40 01
	00 00		 mov	 DWORD PTR tv1131[rsp], eax
  01f54	eb 0b		 jmp	 SHORT $LN169@ckd_dasd_i
$LN168@ckd_dasd_i:
  01f56	c7 84 24 40 01
	00 00 00 00 00
	00		 mov	 DWORD PTR tv1131[rsp], 0
$LN169@ckd_dasd_i:
  01f61	b9 01 00 00 00	 mov	 ecx, 1
  01f66	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  01f6c	48 8d 8c 24 70
	06 00 00	 lea	 rcx, QWORD PTR filename$[rsp]
  01f74	48 89 4c 24 50	 mov	 QWORD PTR [rsp+80], rcx
  01f79	48 8b 8c 24 b8
	01 00 00	 mov	 rcx, QWORD PTR tv1120[rsp]
  01f81	48 89 4c 24 48	 mov	 QWORD PTR [rsp+72], rcx
  01f86	8b 8c 24 3c 01
	00 00		 mov	 ecx, DWORD PTR tv1125[rsp]
  01f8d	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  01f91	8b 8c 24 40 01
	00 00		 mov	 ecx, DWORD PTR tv1131[rsp]
  01f98	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  01f9c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170030
  01fa3	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  01fa8	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170031
  01faf	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  01fb4	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  01fb9	41 b9 03 00 00
	00		 mov	 r9d, 3
  01fbf	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG170032
  01fc6	ba 22 02 00 00	 mov	 edx, 546		; 00000222H
  01fcb	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170033
  01fd2	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 547  :             return -1;

  01fd8	b8 ff ff ff ff	 mov	 eax, -1
  01fdd	e9 51 09 00 00	 jmp	 $LN1@ckd_dasd_i
$LN68@ckd_dasd_i:

; 548  :         }
; 549  : 
; 550  :         /* Check for correct high cylinder number */
; 551  :         if (highcyl != 0 && highcyl != dev->ckdcyls + cyls - 1)

  01fe2	83 bc 24 90 00
	00 00 00	 cmp	 DWORD PTR highcyl$[rsp], 0
  01fea	0f 84 29 01 00
	00		 je	 $LN70@ckd_dasd_i
  01ff0	48 8b 84 24 b0
	07 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  01ff8	8b 80 b8 12 00
	00		 mov	 eax, DWORD PTR [rax+4792]
  01ffe	8b 8c 24 94 00
	00 00		 mov	 ecx, DWORD PTR cyls$[rsp]
  02005	8d 44 08 ff	 lea	 eax, DWORD PTR [rax+rcx-1]
  02009	39 84 24 90 00
	00 00		 cmp	 DWORD PTR highcyl$[rsp], eax
  02010	0f 84 03 01 00
	00		 je	 $LN70@ckd_dasd_i

; 552  :         {
; 553  :             // "%1d:%04X %s file %s: ckd header high cylinder incorrect"
; 554  :             WRMSG( HHC00412, "E", LCSS_DEVNUM, CKDTYP( cckd, 0 ), filename );

  02016	83 bc 24 88 00
	00 00 00	 cmp	 DWORD PTR cckd$[rsp], 0
  0201e	74 11		 je	 SHORT $LN170@ckd_dasd_i
  02020	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG170035
  02027	48 89 84 24 c0
	01 00 00	 mov	 QWORD PTR tv1149[rsp], rax
  0202f	eb 0f		 jmp	 SHORT $LN171@ckd_dasd_i
$LN170@ckd_dasd_i:
  02031	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG170036
  02038	48 89 84 24 c0
	01 00 00	 mov	 QWORD PTR tv1149[rsp], rax
$LN171@ckd_dasd_i:
  02040	48 83 bc 24 b0
	07 00 00 00	 cmp	 QWORD PTR dev$[rsp], 0
  02049	74 15		 je	 SHORT $LN172@ckd_dasd_i
  0204b	48 8b 84 24 b0
	07 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  02053	0f b7 40 48	 movzx	 eax, WORD PTR [rax+72]
  02057	89 84 24 44 01
	00 00		 mov	 DWORD PTR tv1154[rsp], eax
  0205e	eb 0b		 jmp	 SHORT $LN173@ckd_dasd_i
$LN172@ckd_dasd_i:
  02060	c7 84 24 44 01
	00 00 00 00 00
	00		 mov	 DWORD PTR tv1154[rsp], 0
$LN173@ckd_dasd_i:
  0206b	48 83 bc 24 b0
	07 00 00 00	 cmp	 QWORD PTR dev$[rsp], 0
  02074	74 17		 je	 SHORT $LN174@ckd_dasd_i
  02076	48 8b 84 24 b0
	07 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  0207e	0f b7 40 44	 movzx	 eax, WORD PTR [rax+68]
  02082	d1 f8		 sar	 eax, 1
  02084	89 84 24 48 01
	00 00		 mov	 DWORD PTR tv1160[rsp], eax
  0208b	eb 0b		 jmp	 SHORT $LN175@ckd_dasd_i
$LN174@ckd_dasd_i:
  0208d	c7 84 24 48 01
	00 00 00 00 00
	00		 mov	 DWORD PTR tv1160[rsp], 0
$LN175@ckd_dasd_i:
  02098	b9 01 00 00 00	 mov	 ecx, 1
  0209d	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  020a3	48 8d 8c 24 70
	06 00 00	 lea	 rcx, QWORD PTR filename$[rsp]
  020ab	48 89 4c 24 50	 mov	 QWORD PTR [rsp+80], rcx
  020b0	48 8b 8c 24 c0
	01 00 00	 mov	 rcx, QWORD PTR tv1149[rsp]
  020b8	48 89 4c 24 48	 mov	 QWORD PTR [rsp+72], rcx
  020bd	8b 8c 24 44 01
	00 00		 mov	 ecx, DWORD PTR tv1154[rsp]
  020c4	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  020c8	8b 8c 24 48 01
	00 00		 mov	 ecx, DWORD PTR tv1160[rsp]
  020cf	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  020d3	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170037
  020da	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  020df	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170038
  020e6	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  020eb	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  020f0	41 b9 03 00 00
	00		 mov	 r9d, 3
  020f6	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG170039
  020fd	ba 2a 02 00 00	 mov	 edx, 554		; 0000022aH
  02102	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170040
  02109	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 555  :             return -1;

  0210f	b8 ff ff ff ff	 mov	 eax, -1
  02114	e9 1a 08 00 00	 jmp	 $LN1@ckd_dasd_i
$LN70@ckd_dasd_i:

; 556  :         }
; 557  : 
; 558  :         /* Accumulate total volume size */
; 559  :         dev->ckdtrks += trks;

  02119	48 8b 84 24 b0
	07 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  02121	8b 80 bc 12 00
	00		 mov	 eax, DWORD PTR [rax+4796]
  02127	03 84 24 a0 00
	00 00		 add	 eax, DWORD PTR trks$[rsp]
  0212e	48 8b 8c 24 b0
	07 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  02136	89 81 bc 12 00
	00		 mov	 DWORD PTR [rcx+4796], eax

; 560  :         dev->ckdcyls += cyls;

  0213c	48 8b 84 24 b0
	07 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  02144	8b 80 b8 12 00
	00		 mov	 eax, DWORD PTR [rax+4792]
  0214a	03 84 24 94 00
	00 00		 add	 eax, DWORD PTR cyls$[rsp]
  02151	48 8b 8c 24 b0
	07 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  02159	89 81 b8 12 00
	00		 mov	 DWORD PTR [rcx+4792], eax

; 561  : 
; 562  :         /* Save file descriptor and high track number */
; 563  :         dev->ckdfd[fileseq-1] = dev->fd;

  0215f	8b 84 24 84 00
	00 00		 mov	 eax, DWORD PTR fileseq$[rsp]
  02166	ff c8		 dec	 eax
  02168	48 98		 cdqe
  0216a	48 8b 8c 24 b0
	07 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  02172	48 8b 94 24 b0
	07 00 00	 mov	 rdx, QWORD PTR dev$[rsp]
  0217a	8b 92 ac 01 00
	00		 mov	 edx, DWORD PTR [rdx+428]
  02180	89 94 81 c8 11
	00 00		 mov	 DWORD PTR [rcx+rax*4+4552], edx

; 564  :         dev->ckdhitrk[fileseq-1] = dev->ckdtrks;

  02187	8b 84 24 84 00
	00 00		 mov	 eax, DWORD PTR fileseq$[rsp]
  0218e	ff c8		 dec	 eax
  02190	48 98		 cdqe
  02192	48 8b 8c 24 b0
	07 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  0219a	48 8b 94 24 b0
	07 00 00	 mov	 rdx, QWORD PTR dev$[rsp]
  021a2	8b 92 bc 12 00
	00		 mov	 edx, DWORD PTR [rdx+4796]
  021a8	89 94 81 34 12
	00 00		 mov	 DWORD PTR [rcx+rax*4+4660], edx

; 565  :         dev->ckdnumfd = fileseq;

  021af	48 8b 84 24 b0
	07 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  021b7	8b 8c 24 84 00
	00 00		 mov	 ecx, DWORD PTR fileseq$[rsp]
  021be	89 88 c4 11 00
	00		 mov	 DWORD PTR [rax+4548], ecx

; 566  : 
; 567  :         /* Exit loop if this is the last file */
; 568  :         if (highcyl == 0) break;

  021c4	83 bc 24 90 00
	00 00 00	 cmp	 DWORD PTR highcyl$[rsp], 0
  021cc	75 05		 jne	 SHORT $LN71@ckd_dasd_i
  021ce	e9 62 01 00 00	 jmp	 $LN6@ckd_dasd_i
$LN71@ckd_dasd_i:

; 569  : 
; 570  :         /* Increment the file sequence number */
; 571  :         fileseq++;

  021d3	8b 84 24 84 00
	00 00		 mov	 eax, DWORD PTR fileseq$[rsp]
  021da	ff c0		 inc	 eax
  021dc	89 84 24 84 00
	00 00		 mov	 DWORD PTR fileseq$[rsp], eax

; 572  : 
; 573  :         /* Alter the file name suffix ready for the next file */
; 574  :         if ( fileseq <= 9 )

  021e3	83 bc 24 84 00
	00 00 09	 cmp	 DWORD PTR fileseq$[rsp], 9
  021eb	7f 16		 jg	 SHORT $LN72@ckd_dasd_i

; 575  :             *sfxptr = '0' + fileseq;

  021ed	8b 84 24 84 00
	00 00		 mov	 eax, DWORD PTR fileseq$[rsp]
  021f4	83 c0 30	 add	 eax, 48			; 00000030H
  021f7	48 8b 8c 24 a8
	00 00 00	 mov	 rcx, QWORD PTR sfxptr$[rsp]
  021ff	88 01		 mov	 BYTE PTR [rcx], al
  02201	eb 14		 jmp	 SHORT $LN73@ckd_dasd_i
$LN72@ckd_dasd_i:

; 576  :         else
; 577  :             *sfxptr = 'A' - 10 + fileseq;

  02203	8b 84 24 84 00
	00 00		 mov	 eax, DWORD PTR fileseq$[rsp]
  0220a	83 c0 37	 add	 eax, 55			; 00000037H
  0220d	48 8b 8c 24 a8
	00 00 00	 mov	 rcx, QWORD PTR sfxptr$[rsp]
  02215	88 01		 mov	 BYTE PTR [rcx], al
$LN73@ckd_dasd_i:

; 578  : 
; 579  :         /* Check that maximum files has not been exceeded */
; 580  :         if (fileseq > CKD_MAXFILES)

  02217	83 bc 24 84 00
	00 00 1b	 cmp	 DWORD PTR fileseq$[rsp], 27
  0221f	0f 8e 0b 01 00
	00		 jle	 $LN74@ckd_dasd_i

; 581  :         {
; 582  :             // "%1d:%04X %s file %s: maximum CKD files exceeded: %d"
; 583  :             WRMSG( HHC00413, "E", LCSS_DEVNUM, CKDTYP( cckd, 0 ), filename, CKD_MAXFILES );

  02225	83 bc 24 88 00
	00 00 00	 cmp	 DWORD PTR cckd$[rsp], 0
  0222d	74 11		 je	 SHORT $LN176@ckd_dasd_i
  0222f	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG170045
  02236	48 89 84 24 c8
	01 00 00	 mov	 QWORD PTR tv1201[rsp], rax
  0223e	eb 0f		 jmp	 SHORT $LN177@ckd_dasd_i
$LN176@ckd_dasd_i:
  02240	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG170046
  02247	48 89 84 24 c8
	01 00 00	 mov	 QWORD PTR tv1201[rsp], rax
$LN177@ckd_dasd_i:
  0224f	48 83 bc 24 b0
	07 00 00 00	 cmp	 QWORD PTR dev$[rsp], 0
  02258	74 15		 je	 SHORT $LN178@ckd_dasd_i
  0225a	48 8b 84 24 b0
	07 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  02262	0f b7 40 48	 movzx	 eax, WORD PTR [rax+72]
  02266	89 84 24 4c 01
	00 00		 mov	 DWORD PTR tv1206[rsp], eax
  0226d	eb 0b		 jmp	 SHORT $LN179@ckd_dasd_i
$LN178@ckd_dasd_i:
  0226f	c7 84 24 4c 01
	00 00 00 00 00
	00		 mov	 DWORD PTR tv1206[rsp], 0
$LN179@ckd_dasd_i:
  0227a	48 83 bc 24 b0
	07 00 00 00	 cmp	 QWORD PTR dev$[rsp], 0
  02283	74 17		 je	 SHORT $LN180@ckd_dasd_i
  02285	48 8b 84 24 b0
	07 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  0228d	0f b7 40 44	 movzx	 eax, WORD PTR [rax+68]
  02291	d1 f8		 sar	 eax, 1
  02293	89 84 24 50 01
	00 00		 mov	 DWORD PTR tv1212[rsp], eax
  0229a	eb 0b		 jmp	 SHORT $LN181@ckd_dasd_i
$LN180@ckd_dasd_i:
  0229c	c7 84 24 50 01
	00 00 00 00 00
	00		 mov	 DWORD PTR tv1212[rsp], 0
$LN181@ckd_dasd_i:
  022a7	b9 01 00 00 00	 mov	 ecx, 1
  022ac	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  022b2	c7 44 24 58 1b
	00 00 00	 mov	 DWORD PTR [rsp+88], 27
  022ba	48 8d 8c 24 70
	06 00 00	 lea	 rcx, QWORD PTR filename$[rsp]
  022c2	48 89 4c 24 50	 mov	 QWORD PTR [rsp+80], rcx
  022c7	48 8b 8c 24 c8
	01 00 00	 mov	 rcx, QWORD PTR tv1201[rsp]
  022cf	48 89 4c 24 48	 mov	 QWORD PTR [rsp+72], rcx
  022d4	8b 8c 24 4c 01
	00 00		 mov	 ecx, DWORD PTR tv1206[rsp]
  022db	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  022df	8b 8c 24 50 01
	00 00		 mov	 ecx, DWORD PTR tv1212[rsp]
  022e6	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  022ea	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170047
  022f1	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  022f6	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170048
  022fd	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  02302	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  02307	41 b9 03 00 00
	00		 mov	 r9d, 3
  0230d	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG170049
  02314	ba 47 02 00 00	 mov	 edx, 583		; 00000247H
  02319	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170050
  02320	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 584  :             return -1;

  02326	b8 ff ff ff ff	 mov	 eax, -1
  0232b	e9 03 06 00 00	 jmp	 $LN1@ckd_dasd_i
$LN74@ckd_dasd_i:

; 585  :         }
; 586  : 
; 587  :     } /* end for(fileseq) */

  02330	e9 79 e7 ff ff	 jmp	 $LN5@ckd_dasd_i
$LN6@ckd_dasd_i:

; 588  : 
; 589  :     /* Restore the last character of the file name */
; 590  :     *sfxptr = sfxchar;

  02335	48 8b 84 24 a8
	00 00 00	 mov	 rax, QWORD PTR sfxptr$[rsp]
  0233d	0f b6 8c 24 98
	00 00 00	 movzx	 ecx, BYTE PTR sfxchar$[rsp]
  02345	88 08		 mov	 BYTE PTR [rax], cl

; 591  : 
; 592  :     /* Locate the CKD dasd table entry */
; 593  :     dev->ckdtab = dasd_lookup (DASD_CKDDEV, NULL, dev->devtype, dev->ckdcyls);

  02347	48 8b 84 24 b0
	07 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  0234f	0f b7 40 4a	 movzx	 eax, WORD PTR [rax+74]
  02353	48 8b 8c 24 b0
	07 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  0235b	44 8b 89 b8 12
	00 00		 mov	 r9d, DWORD PTR [rcx+4792]
  02362	44 8b c0	 mov	 r8d, eax
  02365	33 d2		 xor	 edx, edx
  02367	b9 01 00 00 00	 mov	 ecx, 1
  0236c	e8 00 00 00 00	 call	 dasd_lookup
  02371	48 8b 8c 24 b0
	07 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  02379	48 89 81 a0 12
	00 00		 mov	 QWORD PTR [rcx+4768], rax

; 594  :     if (dev->ckdtab == NULL)

  02380	48 8b 84 24 b0
	07 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  02388	48 83 b8 a0 12
	00 00 00	 cmp	 QWORD PTR [rax+4768], 0
  02390	0f 85 ea 00 00
	00		 jne	 $LN75@ckd_dasd_i

; 595  :     {
; 596  :         // "%1d:%04X CKD file %s: device type %4.4X not found in dasd table"
; 597  :         WRMSG( HHC00415, "E", LCSS_DEVNUM,

  02396	48 83 bc 24 b0
	07 00 00 00	 cmp	 QWORD PTR dev$[rsp], 0
  0239f	74 15		 je	 SHORT $LN182@ckd_dasd_i
  023a1	48 8b 84 24 b0
	07 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  023a9	0f b7 40 48	 movzx	 eax, WORD PTR [rax+72]
  023ad	89 84 24 54 01
	00 00		 mov	 DWORD PTR tv1241[rsp], eax
  023b4	eb 0b		 jmp	 SHORT $LN183@ckd_dasd_i
$LN182@ckd_dasd_i:
  023b6	c7 84 24 54 01
	00 00 00 00 00
	00		 mov	 DWORD PTR tv1241[rsp], 0
$LN183@ckd_dasd_i:
  023c1	48 83 bc 24 b0
	07 00 00 00	 cmp	 QWORD PTR dev$[rsp], 0
  023ca	74 17		 je	 SHORT $LN184@ckd_dasd_i
  023cc	48 8b 84 24 b0
	07 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  023d4	0f b7 40 44	 movzx	 eax, WORD PTR [rax+68]
  023d8	d1 f8		 sar	 eax, 1
  023da	89 84 24 58 01
	00 00		 mov	 DWORD PTR tv1247[rsp], eax
  023e1	eb 0b		 jmp	 SHORT $LN185@ckd_dasd_i
$LN184@ckd_dasd_i:
  023e3	c7 84 24 58 01
	00 00 00 00 00
	00		 mov	 DWORD PTR tv1247[rsp], 0
$LN185@ckd_dasd_i:
  023ee	48 8b 84 24 b0
	07 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  023f6	0f b7 40 4a	 movzx	 eax, WORD PTR [rax+74]
  023fa	89 84 24 78 01
	00 00		 mov	 DWORD PTR tv1235[rsp], eax
  02401	b9 01 00 00 00	 mov	 ecx, 1
  02406	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  0240c	8b 8c 24 78 01
	00 00		 mov	 ecx, DWORD PTR tv1235[rsp]
  02413	89 4c 24 50	 mov	 DWORD PTR [rsp+80], ecx
  02417	48 8d 8c 24 70
	06 00 00	 lea	 rcx, QWORD PTR filename$[rsp]
  0241f	48 89 4c 24 48	 mov	 QWORD PTR [rsp+72], rcx
  02424	8b 8c 24 54 01
	00 00		 mov	 ecx, DWORD PTR tv1241[rsp]
  0242b	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  0242f	8b 8c 24 58 01
	00 00		 mov	 ecx, DWORD PTR tv1247[rsp]
  02436	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  0243a	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170052
  02441	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  02446	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170053
  0244d	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  02452	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  02457	41 b9 03 00 00
	00		 mov	 r9d, 3
  0245d	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG170054
  02464	ba 56 02 00 00	 mov	 edx, 598		; 00000256H
  02469	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170055
  02470	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 598  :                filename, dev->devtype );
; 599  :         return -1;

  02476	b8 ff ff ff ff	 mov	 eax, -1
  0247b	e9 b3 04 00 00	 jmp	 $LN1@ckd_dasd_i
$LN75@ckd_dasd_i:

; 600  :     }
; 601  : 
; 602  :     /* Log the device geometry */
; 603  :     if (!dev->quiet)

  02480	48 8b 84 24 b0
	07 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  02488	8b 80 f8 05 00
	00		 mov	 eax, DWORD PTR [rax+1528]
  0248e	c1 e8 0c	 shr	 eax, 12
  02491	83 e0 01	 and	 eax, 1
  02494	85 c0		 test	 eax, eax
  02496	0f 85 68 01 00
	00		 jne	 $LN76@ckd_dasd_i

; 604  :         // "%1d:%04X %s file %s: model %s cyls %d heads %d tracks %d trklen %d"
; 605  :         WRMSG( HHC00414, "I", LCSS_DEVNUM, CKDTYP( cckd, 0 ), filename, dev->ckdtab->name,

  0249c	83 bc 24 88 00
	00 00 00	 cmp	 DWORD PTR cckd$[rsp], 0
  024a4	74 11		 je	 SHORT $LN186@ckd_dasd_i
  024a6	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG170057
  024ad	48 89 84 24 d0
	01 00 00	 mov	 QWORD PTR tv1275[rsp], rax
  024b5	eb 0f		 jmp	 SHORT $LN187@ckd_dasd_i
$LN186@ckd_dasd_i:
  024b7	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG170058
  024be	48 89 84 24 d0
	01 00 00	 mov	 QWORD PTR tv1275[rsp], rax
$LN187@ckd_dasd_i:
  024c6	48 83 bc 24 b0
	07 00 00 00	 cmp	 QWORD PTR dev$[rsp], 0
  024cf	74 15		 je	 SHORT $LN188@ckd_dasd_i
  024d1	48 8b 84 24 b0
	07 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  024d9	0f b7 40 48	 movzx	 eax, WORD PTR [rax+72]
  024dd	89 84 24 5c 01
	00 00		 mov	 DWORD PTR tv1312[rsp], eax
  024e4	eb 0b		 jmp	 SHORT $LN189@ckd_dasd_i
$LN188@ckd_dasd_i:
  024e6	c7 84 24 5c 01
	00 00 00 00 00
	00		 mov	 DWORD PTR tv1312[rsp], 0
$LN189@ckd_dasd_i:
  024f1	48 83 bc 24 b0
	07 00 00 00	 cmp	 QWORD PTR dev$[rsp], 0
  024fa	74 17		 je	 SHORT $LN190@ckd_dasd_i
  024fc	48 8b 84 24 b0
	07 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  02504	0f b7 40 44	 movzx	 eax, WORD PTR [rax+68]
  02508	d1 f8		 sar	 eax, 1
  0250a	89 84 24 60 01
	00 00		 mov	 DWORD PTR tv1318[rsp], eax
  02511	eb 0b		 jmp	 SHORT $LN191@ckd_dasd_i
$LN190@ckd_dasd_i:
  02513	c7 84 24 60 01
	00 00 00 00 00
	00		 mov	 DWORD PTR tv1318[rsp], 0
$LN191@ckd_dasd_i:
  0251e	48 8b 84 24 b0
	07 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  02526	48 8b 80 a0 12
	00 00		 mov	 rax, QWORD PTR [rax+4768]
  0252d	48 89 84 24 18
	02 00 00	 mov	 QWORD PTR tv1419[rsp], rax
  02535	b9 01 00 00 00	 mov	 ecx, 1
  0253a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  02540	48 8b 8c 24 b0
	07 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  02548	8b 89 c4 12 00
	00		 mov	 ecx, DWORD PTR [rcx+4804]
  0254e	89 4c 24 78	 mov	 DWORD PTR [rsp+120], ecx
  02552	48 8b 8c 24 b0
	07 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  0255a	8b 89 bc 12 00
	00		 mov	 ecx, DWORD PTR [rcx+4796]
  02560	89 4c 24 70	 mov	 DWORD PTR [rsp+112], ecx
  02564	48 8b 8c 24 b0
	07 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  0256c	8b 89 c0 12 00
	00		 mov	 ecx, DWORD PTR [rcx+4800]
  02572	89 4c 24 68	 mov	 DWORD PTR [rsp+104], ecx
  02576	48 8b 8c 24 b0
	07 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  0257e	8b 89 b8 12 00
	00		 mov	 ecx, DWORD PTR [rcx+4792]
  02584	89 4c 24 60	 mov	 DWORD PTR [rsp+96], ecx
  02588	48 8b 8c 24 18
	02 00 00	 mov	 rcx, QWORD PTR tv1419[rsp]
  02590	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  02593	48 89 4c 24 58	 mov	 QWORD PTR [rsp+88], rcx
  02598	48 8d 8c 24 70
	06 00 00	 lea	 rcx, QWORD PTR filename$[rsp]
  025a0	48 89 4c 24 50	 mov	 QWORD PTR [rsp+80], rcx
  025a5	48 8b 8c 24 d0
	01 00 00	 mov	 rcx, QWORD PTR tv1275[rsp]
  025ad	48 89 4c 24 48	 mov	 QWORD PTR [rsp+72], rcx
  025b2	8b 8c 24 5c 01
	00 00		 mov	 ecx, DWORD PTR tv1312[rsp]
  025b9	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  025bd	8b 8c 24 60 01
	00 00		 mov	 ecx, DWORD PTR tv1318[rsp]
  025c4	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  025c8	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170059
  025cf	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  025d4	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170060
  025db	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  025e0	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  025e5	41 b9 03 00 00
	00		 mov	 r9d, 3
  025eb	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG170061
  025f2	ba 5e 02 00 00	 mov	 edx, 606		; 0000025eH
  025f7	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170062
  025fe	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg
$LN76@ckd_dasd_i:

; 606  :                dev->ckdcyls, dev->ckdheads, dev->ckdtrks, dev->ckdtrksz );
; 607  : 
; 608  :     /* Locate the CKD control unit dasd table entry */
; 609  :     dev->ckdcu = dasd_lookup (DASD_CKDCU, cu ? cu : dev->ckdtab->cu, 0, 0);

  02604	48 83 bc 24 70
	01 00 00 00	 cmp	 QWORD PTR cu$[rsp], 0
  0260d	74 12		 je	 SHORT $LN192@ckd_dasd_i
  0260f	48 8b 84 24 70
	01 00 00	 mov	 rax, QWORD PTR cu$[rsp]
  02617	48 89 84 24 d8
	01 00 00	 mov	 QWORD PTR tv1336[rsp], rax
  0261f	eb 1b		 jmp	 SHORT $LN193@ckd_dasd_i
$LN192@ckd_dasd_i:
  02621	48 8b 84 24 b0
	07 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  02629	48 8b 80 a0 12
	00 00		 mov	 rax, QWORD PTR [rax+4768]
  02630	48 8b 40 30	 mov	 rax, QWORD PTR [rax+48]
  02634	48 89 84 24 d8
	01 00 00	 mov	 QWORD PTR tv1336[rsp], rax
$LN193@ckd_dasd_i:
  0263c	45 33 c9	 xor	 r9d, r9d
  0263f	45 33 c0	 xor	 r8d, r8d
  02642	48 8b 94 24 d8
	01 00 00	 mov	 rdx, QWORD PTR tv1336[rsp]
  0264a	b9 02 00 00 00	 mov	 ecx, 2
  0264f	e8 00 00 00 00	 call	 dasd_lookup
  02654	48 8b 8c 24 b0
	07 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  0265c	48 89 81 a8 12
	00 00		 mov	 QWORD PTR [rcx+4776], rax

; 610  :     if (dev->ckdcu == NULL)

  02663	48 8b 84 24 b0
	07 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  0266b	48 83 b8 a8 12
	00 00 00	 cmp	 QWORD PTR [rax+4776], 0
  02673	0f 85 48 01 00
	00		 jne	 $LN77@ckd_dasd_i

; 611  :     {
; 612  :         // "%1d:%04X %s file %s: control unit %s not found in dasd table"
; 613  :         WRMSG( HHC00416, "E", LCSS_DEVNUM, CKDTYP( cckd, 0 ),

  02679	48 83 bc 24 70
	01 00 00 00	 cmp	 QWORD PTR cu$[rsp], 0
  02682	74 12		 je	 SHORT $LN194@ckd_dasd_i
  02684	48 8b 84 24 70
	01 00 00	 mov	 rax, QWORD PTR cu$[rsp]
  0268c	48 89 84 24 e0
	01 00 00	 mov	 QWORD PTR tv1344[rsp], rax
  02694	eb 1b		 jmp	 SHORT $LN195@ckd_dasd_i
$LN194@ckd_dasd_i:
  02696	48 8b 84 24 b0
	07 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  0269e	48 8b 80 a0 12
	00 00		 mov	 rax, QWORD PTR [rax+4768]
  026a5	48 8b 40 30	 mov	 rax, QWORD PTR [rax+48]
  026a9	48 89 84 24 e0
	01 00 00	 mov	 QWORD PTR tv1344[rsp], rax
$LN195@ckd_dasd_i:
  026b1	83 bc 24 88 00
	00 00 00	 cmp	 DWORD PTR cckd$[rsp], 0
  026b9	74 11		 je	 SHORT $LN196@ckd_dasd_i
  026bb	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG170064
  026c2	48 89 84 24 e8
	01 00 00	 mov	 QWORD PTR tv1348[rsp], rax
  026ca	eb 0f		 jmp	 SHORT $LN197@ckd_dasd_i
$LN196@ckd_dasd_i:
  026cc	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG170065
  026d3	48 89 84 24 e8
	01 00 00	 mov	 QWORD PTR tv1348[rsp], rax
$LN197@ckd_dasd_i:
  026db	48 83 bc 24 b0
	07 00 00 00	 cmp	 QWORD PTR dev$[rsp], 0
  026e4	74 15		 je	 SHORT $LN198@ckd_dasd_i
  026e6	48 8b 84 24 b0
	07 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  026ee	0f b7 40 48	 movzx	 eax, WORD PTR [rax+72]
  026f2	89 84 24 64 01
	00 00		 mov	 DWORD PTR tv1353[rsp], eax
  026f9	eb 0b		 jmp	 SHORT $LN199@ckd_dasd_i
$LN198@ckd_dasd_i:
  026fb	c7 84 24 64 01
	00 00 00 00 00
	00		 mov	 DWORD PTR tv1353[rsp], 0
$LN199@ckd_dasd_i:
  02706	48 83 bc 24 b0
	07 00 00 00	 cmp	 QWORD PTR dev$[rsp], 0
  0270f	74 17		 je	 SHORT $LN200@ckd_dasd_i
  02711	48 8b 84 24 b0
	07 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  02719	0f b7 40 44	 movzx	 eax, WORD PTR [rax+68]
  0271d	d1 f8		 sar	 eax, 1
  0271f	89 84 24 68 01
	00 00		 mov	 DWORD PTR tv1359[rsp], eax
  02726	eb 0b		 jmp	 SHORT $LN201@ckd_dasd_i
$LN200@ckd_dasd_i:
  02728	c7 84 24 68 01
	00 00 00 00 00
	00		 mov	 DWORD PTR tv1359[rsp], 0
$LN201@ckd_dasd_i:
  02733	b9 01 00 00 00	 mov	 ecx, 1
  02738	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  0273e	48 8b 8c 24 e0
	01 00 00	 mov	 rcx, QWORD PTR tv1344[rsp]
  02746	48 89 4c 24 58	 mov	 QWORD PTR [rsp+88], rcx
  0274b	48 8d 8c 24 70
	06 00 00	 lea	 rcx, QWORD PTR filename$[rsp]
  02753	48 89 4c 24 50	 mov	 QWORD PTR [rsp+80], rcx
  02758	48 8b 8c 24 e8
	01 00 00	 mov	 rcx, QWORD PTR tv1348[rsp]
  02760	48 89 4c 24 48	 mov	 QWORD PTR [rsp+72], rcx
  02765	8b 8c 24 64 01
	00 00		 mov	 ecx, DWORD PTR tv1353[rsp]
  0276c	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  02770	8b 8c 24 68 01
	00 00		 mov	 ecx, DWORD PTR tv1359[rsp]
  02777	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  0277b	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170066
  02782	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  02787	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170067
  0278e	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  02793	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  02798	41 b9 03 00 00
	00		 mov	 r9d, 3
  0279e	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG170068
  027a5	ba 66 02 00 00	 mov	 edx, 614		; 00000266H
  027aa	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170069
  027b1	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 614  :                filename, cu ? cu : dev->ckdtab->cu );
; 615  :         return -1;

  027b7	b8 ff ff ff ff	 mov	 eax, -1
  027bc	e9 72 01 00 00	 jmp	 $LN1@ckd_dasd_i
$LN77@ckd_dasd_i:

; 616  :     }
; 617  : 
; 618  :     /* Set number of sense bytes according to controller specification */
; 619  :     dev->numsense = dev->ckdcu->senselength;

  027c1	48 8b 84 24 b0
	07 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  027c9	48 8b 80 a8 12
	00 00		 mov	 rax, QWORD PTR [rax+4776]
  027d0	0f b6 40 34	 movzx	 eax, BYTE PTR [rax+52]
  027d4	48 8b 8c 24 b0
	07 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  027dc	89 81 60 03 00
	00		 mov	 DWORD PTR [rcx+864], eax

; 620  : 
; 621  :     /* Set flag bit if 3990 controller */
; 622  :     if (dev->ckdcu->devt == 0x3990)

  027e2	48 8b 84 24 b0
	07 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  027ea	48 8b 80 a8 12
	00 00		 mov	 rax, QWORD PTR [rax+4776]
  027f1	0f b7 40 08	 movzx	 eax, WORD PTR [rax+8]
  027f5	3d 90 39 00 00	 cmp	 eax, 14736		; 00003990H
  027fa	75 1f		 jne	 SHORT $LN78@ckd_dasd_i

; 623  :         dev->ckd3990 = 1;

  027fc	48 8b 84 24 b0
	07 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  02804	8b 80 14 13 00
	00		 mov	 eax, DWORD PTR [rax+4884]
  0280a	83 c8 01	 or	 eax, 1
  0280d	48 8b 8c 24 b0
	07 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  02815	89 81 14 13 00
	00		 mov	 DWORD PTR [rcx+4884], eax
$LN78@ckd_dasd_i:

; 624  : 
; 625  :     /* Build the dh_devid area */
; 626  :     dev->numdevid = dasd_build_ckd_devid (dev->ckdtab, dev->ckdcu,

  0281b	48 8b 84 24 b0
	07 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  02823	48 05 68 04 00
	00		 add	 rax, 1128		; 00000468H
  02829	4c 8b c0	 mov	 r8, rax
  0282c	48 8b 84 24 b0
	07 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  02834	48 8b 90 a8 12
	00 00		 mov	 rdx, QWORD PTR [rax+4776]
  0283b	48 8b 84 24 b0
	07 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  02843	48 8b 88 a0 12
	00 00		 mov	 rcx, QWORD PTR [rax+4768]
  0284a	e8 00 00 00 00	 call	 dasd_build_ckd_devid
  0284f	48 8b 8c 24 b0
	07 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  02857	89 81 64 04 00
	00		 mov	 DWORD PTR [rcx+1124], eax

; 627  :                                           (BYTE *)&dev->devid);
; 628  : 
; 629  :     /* Build the devchar area */
; 630  :     dev->numdevchar = dasd_build_ckd_devchar (dev->ckdtab, dev->ckdcu,

  0285d	48 8b 84 24 b0
	07 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  02865	48 05 6c 05 00
	00		 add	 rax, 1388		; 0000056cH
  0286b	48 8b 8c 24 b0
	07 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  02873	44 8b 89 b8 12
	00 00		 mov	 r9d, DWORD PTR [rcx+4792]
  0287a	4c 8b c0	 mov	 r8, rax
  0287d	48 8b 84 24 b0
	07 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  02885	48 8b 90 a8 12
	00 00		 mov	 rdx, QWORD PTR [rax+4776]
  0288c	48 8b 84 24 b0
	07 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  02894	48 8b 88 a0 12
	00 00		 mov	 rcx, QWORD PTR [rax+4768]
  0289b	e8 00 00 00 00	 call	 dasd_build_ckd_devchar
  028a0	48 8b 8c 24 b0
	07 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  028a8	89 81 68 05 00
	00		 mov	 DWORD PTR [rcx+1384], eax

; 631  :                                   (BYTE *)&dev->devchar, dev->ckdcyls);
; 632  : 
; 633  :     /* Clear the DPA */
; 634  :     memset(dev->pgid, 0, sizeof(dev->pgid));

  028ae	48 8b 84 24 b0
	07 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  028b6	48 05 ad 05 00
	00		 add	 rax, 1453		; 000005adH
  028bc	48 8b f8	 mov	 rdi, rax
  028bf	33 c0		 xor	 eax, eax
  028c1	b9 0b 00 00 00	 mov	 ecx, 11
  028c6	f3 aa		 rep stosb

; 635  : 
; 636  :     /* Activate I/O tracing */
; 637  : //  dev->ccwtrace = 1;
; 638  : 
; 639  :     /* Request the channel to merge data chained write CCWs into
; 640  :        a single buffer before passing data to the device handler */
; 641  :     dev->cdwmerge = 1;

  028c8	48 8b 84 24 b0
	07 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  028d0	8b 80 f8 05 00
	00		 mov	 eax, DWORD PTR [rax+1528]
  028d6	0f ba e8 10	 bts	 eax, 16
  028da	48 8b 8c 24 b0
	07 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  028e2	89 81 f8 05 00
	00		 mov	 DWORD PTR [rcx+1528], eax

; 642  : 
; 643  :     /* default for device cache is on */
; 644  :     dev->devcache = TRUE;

  028e8	48 8b 84 24 b0
	07 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  028f0	0f b6 80 10 13
	00 00		 movzx	 eax, BYTE PTR [rax+4880]
  028f7	0c 02		 or	 al, 2
  028f9	48 8b 8c 24 b0
	07 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  02901	88 81 10 13 00
	00		 mov	 BYTE PTR [rcx+4880], al

; 645  : 
; 646  :     if (!cckd) return 0;

  02907	83 bc 24 88 00
	00 00 00	 cmp	 DWORD PTR cckd$[rsp], 0
  0290f	75 06		 jne	 SHORT $LN79@ckd_dasd_i
  02911	33 c0		 xor	 eax, eax
  02913	eb 1e		 jmp	 SHORT $LN1@ckd_dasd_i
  02915	eb 1c		 jmp	 SHORT $LN80@ckd_dasd_i
$LN79@ckd_dasd_i:

; 647  :     else return cckd_dasd_init_handler(dev, argc, argv);

  02917	4c 8b 84 24 c0
	07 00 00	 mov	 r8, QWORD PTR argv$[rsp]
  0291f	8b 94 24 b8 07
	00 00		 mov	 edx, DWORD PTR argc$[rsp]
  02926	48 8b 8c 24 b0
	07 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  0292e	e8 00 00 00 00	 call	 cckd_dasd_init_handler
$LN80@ckd_dasd_i:
$LN1@ckd_dasd_i:

; 648  : 
; 649  : } /* end function ckd_dasd_init_handler */

  02933	48 8b 8c 24 80
	07 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  0293b	48 33 cc	 xor	 rcx, rsp
  0293e	e8 00 00 00 00	 call	 __security_check_cookie
  02943	48 81 c4 98 07
	00 00		 add	 rsp, 1944		; 00000798H
  0294a	5f		 pop	 rdi
  0294b	5e		 pop	 rsi
  0294c	c3		 ret	 0
ckd_dasd_init_handler ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\ckddasd.c
_TEXT	SEGMENT
shift$ = 32
tv267 = 36
tv297 = 40
tv423 = 44
tv431 = 48
dev$ = 80
sense0$ = 88
sense1$ = 96
sense2$ = 104
format$ = 112
message$ = 120
ckd_build_sense PROC

; 1410 : {

$LN32:
  00000	44 88 4c 24 20	 mov	 BYTE PTR [rsp+32], r9b
  00005	44 88 44 24 18	 mov	 BYTE PTR [rsp+24], r8b
  0000a	88 54 24 10	 mov	 BYTE PTR [rsp+16], dl
  0000e	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00013	57		 push	 rdi
  00014	48 83 ec 40	 sub	 rsp, 64			; 00000040H

; 1411 : int shift;  /* num of bits to shift left 'high cyl' in sense6 */
; 1412 :     /* Clear the sense bytes */
; 1413 :     memset( dev->sense, 0, sizeof(dev->sense) );

  00018	48 8b 44 24 50	 mov	 rax, QWORD PTR dev$[rsp]
  0001d	48 05 64 03 00
	00		 add	 rax, 868		; 00000364H
  00023	48 8b f8	 mov	 rdi, rax
  00026	33 c0		 xor	 eax, eax
  00028	b9 00 01 00 00	 mov	 ecx, 256		; 00000100H
  0002d	f3 aa		 rep stosb

; 1414 : 
; 1415 :     /* Sense bytes 0-2 are specified by caller */
; 1416 :     dev->sense[0] = sense0;

  0002f	b8 01 00 00 00	 mov	 eax, 1
  00034	48 6b c0 00	 imul	 rax, rax, 0
  00038	48 8b 4c 24 50	 mov	 rcx, QWORD PTR dev$[rsp]
  0003d	0f b6 54 24 58	 movzx	 edx, BYTE PTR sense0$[rsp]
  00042	88 94 01 64 03
	00 00		 mov	 BYTE PTR [rcx+rax+868], dl

; 1417 :     dev->sense[1] = sense1;

  00049	b8 01 00 00 00	 mov	 eax, 1
  0004e	48 6b c0 01	 imul	 rax, rax, 1
  00052	48 8b 4c 24 50	 mov	 rcx, QWORD PTR dev$[rsp]
  00057	0f b6 54 24 60	 movzx	 edx, BYTE PTR sense1$[rsp]
  0005c	88 94 01 64 03
	00 00		 mov	 BYTE PTR [rcx+rax+868], dl

; 1418 :     dev->sense[2] = sense2;

  00063	b8 01 00 00 00	 mov	 eax, 1
  00068	48 6b c0 02	 imul	 rax, rax, 2
  0006c	48 8b 4c 24 50	 mov	 rcx, QWORD PTR dev$[rsp]
  00071	0f b6 54 24 68	 movzx	 edx, BYTE PTR sense2$[rsp]
  00076	88 94 01 64 03
	00 00		 mov	 BYTE PTR [rcx+rax+868], dl

; 1419 : 
; 1420 :     /* Sense byte 3 contains the residual locate record count
; 1421 :        if imprecise ending is indicated in sense byte 1 */
; 1422 :     if (sense1 & SENSE1_IE)

  0007d	0f b6 44 24 60	 movzx	 eax, BYTE PTR sense1$[rsp]
  00082	83 e0 01	 and	 eax, 1
  00085	85 c0		 test	 eax, eax
  00087	74 59		 je	 SHORT $LN6@ckd_build_

; 1423 :     {
; 1424 :         if (dev->ckdtrkof)

  00089	48 8b 44 24 50	 mov	 rax, QWORD PTR dev$[rsp]
  0008e	8b 80 14 13 00
	00		 mov	 eax, DWORD PTR [rax+4884]
  00094	c1 e8 0f	 shr	 eax, 15
  00097	83 e0 01	 and	 eax, 1
  0009a	85 c0		 test	 eax, eax
  0009c	74 23		 je	 SHORT $LN7@ckd_build_

; 1425 :             dev->sense[3] = (BYTE) dev->ckdcuroper;

  0009e	b8 01 00 00 00	 mov	 eax, 1
  000a3	48 6b c0 03	 imul	 rax, rax, 3
  000a7	48 8b 4c 24 50	 mov	 rcx, QWORD PTR dev$[rsp]
  000ac	48 8b 54 24 50	 mov	 rdx, QWORD PTR dev$[rsp]
  000b1	0f b6 92 dc 12
	00 00		 movzx	 edx, BYTE PTR [rdx+4828]
  000b8	88 94 01 64 03
	00 00		 mov	 BYTE PTR [rcx+rax+868], dl
  000bf	eb 21		 jmp	 SHORT $LN8@ckd_build_
$LN7@ckd_build_:

; 1426 :         else
; 1427 :             dev->sense[3] = dev->ckdlcount;

  000c1	b8 01 00 00 00	 mov	 eax, 1
  000c6	48 6b c0 03	 imul	 rax, rax, 3
  000ca	48 8b 4c 24 50	 mov	 rcx, QWORD PTR dev$[rsp]
  000cf	48 8b 54 24 50	 mov	 rdx, QWORD PTR dev$[rsp]
  000d4	0f b6 92 02 13
	00 00		 movzx	 edx, BYTE PTR [rdx+4866]
  000db	88 94 01 64 03
	00 00		 mov	 BYTE PTR [rcx+rax+868], dl
$LN8@ckd_build_:
$LN6@ckd_build_:

; 1428 :     }
; 1429 : 
; 1430 :     /* Sense byte 4 is the physical device address */
; 1431 :     dev->sense[4] = 0;

  000e2	b8 01 00 00 00	 mov	 eax, 1
  000e7	48 6b c0 04	 imul	 rax, rax, 4
  000eb	48 8b 4c 24 50	 mov	 rcx, QWORD PTR dev$[rsp]
  000f0	c6 84 01 64 03
	00 00 00	 mov	 BYTE PTR [rcx+rax+868], 0

; 1432 : 
; 1433 :     if (dev->devtype == 0x2305)

  000f8	48 8b 44 24 50	 mov	 rax, QWORD PTR dev$[rsp]
  000fd	0f b7 40 4a	 movzx	 eax, WORD PTR [rax+74]
  00101	3d 05 23 00 00	 cmp	 eax, 8965		; 00002305H
  00106	75 34		 jne	 SHORT $LN9@ckd_build_

; 1434 :     {
; 1435 :        /*             0x40=ONLINE             0x04=END OF CYL */
; 1436 :         dev->sense[3] = (((dev->sense[1]) & 0x20) >> 3) | 0x40;

  00108	b8 01 00 00 00	 mov	 eax, 1
  0010d	48 6b c0 01	 imul	 rax, rax, 1
  00111	48 8b 4c 24 50	 mov	 rcx, QWORD PTR dev$[rsp]
  00116	0f b6 84 01 64
	03 00 00	 movzx	 eax, BYTE PTR [rcx+rax+868]
  0011e	83 e0 20	 and	 eax, 32			; 00000020H
  00121	c1 f8 03	 sar	 eax, 3
  00124	83 c8 40	 or	 eax, 64			; 00000040H
  00127	b9 01 00 00 00	 mov	 ecx, 1
  0012c	48 6b c9 03	 imul	 rcx, rcx, 3
  00130	48 8b 54 24 50	 mov	 rdx, QWORD PTR dev$[rsp]
  00135	88 84 0a 64 03
	00 00		 mov	 BYTE PTR [rdx+rcx+868], al
$LN9@ckd_build_:

; 1437 :     }
; 1438 :     if (dev->devtype == 0x2311)

  0013c	48 8b 44 24 50	 mov	 rax, QWORD PTR dev$[rsp]
  00141	0f b7 40 4a	 movzx	 eax, WORD PTR [rax+74]
  00145	3d 11 23 00 00	 cmp	 eax, 8977		; 00002311H
  0014a	75 36		 jne	 SHORT $LN10@ckd_build_

; 1439 :     {
; 1440 :        /* 0x80=READY, 0x40=ONLINE 0x08=ONLINE 0x04=END OF CYL */
; 1441 :         dev->sense[3] = (((dev->sense[1]) & 0x20) >> 3) | 0xC8;

  0014c	b8 01 00 00 00	 mov	 eax, 1
  00151	48 6b c0 01	 imul	 rax, rax, 1
  00155	48 8b 4c 24 50	 mov	 rcx, QWORD PTR dev$[rsp]
  0015a	0f b6 84 01 64
	03 00 00	 movzx	 eax, BYTE PTR [rcx+rax+868]
  00162	83 e0 20	 and	 eax, 32			; 00000020H
  00165	c1 f8 03	 sar	 eax, 3
  00168	0d c8 00 00 00	 or	 eax, 200		; 000000c8H
  0016d	b9 01 00 00 00	 mov	 ecx, 1
  00172	48 6b c9 03	 imul	 rcx, rcx, 3
  00176	48 8b 54 24 50	 mov	 rdx, QWORD PTR dev$[rsp]
  0017b	88 84 0a 64 03
	00 00		 mov	 BYTE PTR [rdx+rcx+868], al
$LN10@ckd_build_:

; 1442 :     }
; 1443 :     if (dev->devtype == 0x2314)

  00182	48 8b 44 24 50	 mov	 rax, QWORD PTR dev$[rsp]
  00187	0f b7 40 4a	 movzx	 eax, WORD PTR [rax+74]
  0018b	3d 14 23 00 00	 cmp	 eax, 8980		; 00002314H
  00190	75 34		 jne	 SHORT $LN11@ckd_build_

; 1444 :     {
; 1445 :        /*             0x40=ONLINE             0x04=END OF CYL */
; 1446 :         dev->sense[3] = (((dev->sense[1]) & 0x20) >> 3) | 0x40;

  00192	b8 01 00 00 00	 mov	 eax, 1
  00197	48 6b c0 01	 imul	 rax, rax, 1
  0019b	48 8b 4c 24 50	 mov	 rcx, QWORD PTR dev$[rsp]
  001a0	0f b6 84 01 64
	03 00 00	 movzx	 eax, BYTE PTR [rcx+rax+868]
  001a8	83 e0 20	 and	 eax, 32			; 00000020H
  001ab	c1 f8 03	 sar	 eax, 3
  001ae	83 c8 40	 or	 eax, 64			; 00000040H
  001b1	b9 01 00 00 00	 mov	 ecx, 1
  001b6	48 6b c9 03	 imul	 rcx, rcx, 3
  001ba	48 8b 54 24 50	 mov	 rdx, QWORD PTR dev$[rsp]
  001bf	88 84 0a 64 03
	00 00		 mov	 BYTE PTR [rdx+rcx+868], al
$LN11@ckd_build_:

; 1447 :     }
; 1448 :     if (dev->devtype == 0x3330)

  001c6	48 8b 44 24 50	 mov	 rax, QWORD PTR dev$[rsp]
  001cb	0f b7 40 4a	 movzx	 eax, WORD PTR [rax+74]
  001cf	3d 30 33 00 00	 cmp	 eax, 13104		; 00003330H
  001d4	75 34		 jne	 SHORT $LN12@ckd_build_

; 1449 :     {
; 1450 :      /* bits 0-1 = controller address */
; 1451 :      /* bits 2-7: drive A = 111000, B = 110001, ... H = 000111 */
; 1452 :        dev->sense[4] = (dev->devnum & 0x07) | ((~(dev->devnum) & 0x07) << 3);

  001d6	48 8b 44 24 50	 mov	 rax, QWORD PTR dev$[rsp]
  001db	0f b7 40 48	 movzx	 eax, WORD PTR [rax+72]
  001df	83 e0 07	 and	 eax, 7
  001e2	48 8b 4c 24 50	 mov	 rcx, QWORD PTR dev$[rsp]
  001e7	0f b7 49 48	 movzx	 ecx, WORD PTR [rcx+72]
  001eb	f7 d1		 not	 ecx
  001ed	83 e1 07	 and	 ecx, 7
  001f0	c1 e1 03	 shl	 ecx, 3
  001f3	0b c1		 or	 eax, ecx
  001f5	b9 01 00 00 00	 mov	 ecx, 1
  001fa	48 6b c9 04	 imul	 rcx, rcx, 4
  001fe	48 8b 54 24 50	 mov	 rdx, QWORD PTR dev$[rsp]
  00203	88 84 0a 64 03
	00 00		 mov	 BYTE PTR [rdx+rcx+868], al
$LN12@ckd_build_:

; 1453 :     }
; 1454 :     if (dev->devtype == 0x3340)

  0020a	48 8b 44 24 50	 mov	 rax, QWORD PTR dev$[rsp]
  0020f	0f b7 40 4a	 movzx	 eax, WORD PTR [rax+74]
  00213	3d 40 33 00 00	 cmp	 eax, 13120		; 00003340H
  00218	75 7a		 jne	 SHORT $LN13@ckd_build_

; 1455 :     {
; 1456 :      /* X'01' = 35 MB drive, X'02' = 70 MB drive  (same as 'model') */
; 1457 :      /* X'80' RPS feature installed */
; 1458 :        dev->sense[2] |= 0x80 | dev->devid[6];  /* RPS + model */

  0021a	b8 01 00 00 00	 mov	 eax, 1
  0021f	48 6b c0 02	 imul	 rax, rax, 2
  00223	b9 01 00 00 00	 mov	 ecx, 1
  00228	48 6b c9 06	 imul	 rcx, rcx, 6
  0022c	48 8b 54 24 50	 mov	 rdx, QWORD PTR dev$[rsp]
  00231	0f b6 8c 0a 68
	04 00 00	 movzx	 ecx, BYTE PTR [rdx+rcx+1128]
  00239	0f ba e9 07	 bts	 ecx, 7
  0023d	48 8b 54 24 50	 mov	 rdx, QWORD PTR dev$[rsp]
  00242	0f b6 84 02 64
	03 00 00	 movzx	 eax, BYTE PTR [rdx+rax+868]
  0024a	0b c1		 or	 eax, ecx
  0024c	b9 01 00 00 00	 mov	 ecx, 1
  00251	48 6b c9 02	 imul	 rcx, rcx, 2
  00255	48 8b 54 24 50	 mov	 rdx, QWORD PTR dev$[rsp]
  0025a	88 84 0a 64 03
	00 00		 mov	 BYTE PTR [rdx+rcx+868], al

; 1459 :        /* drive A = bit 0 (0x80), ... drive H = bit 7 (0x01) */
; 1460 :        dev->sense[4] =  0x80 >> (dev->devnum & 0x07);

  00261	48 8b 44 24 50	 mov	 rax, QWORD PTR dev$[rsp]
  00266	0f b7 40 48	 movzx	 eax, WORD PTR [rax+72]
  0026a	83 e0 07	 and	 eax, 7
  0026d	b9 80 00 00 00	 mov	 ecx, 128		; 00000080H
  00272	89 4c 24 2c	 mov	 DWORD PTR tv423[rsp], ecx
  00276	0f b6 c8	 movzx	 ecx, al
  00279	8b 44 24 2c	 mov	 eax, DWORD PTR tv423[rsp]
  0027d	d3 f8		 sar	 eax, cl
  0027f	b9 01 00 00 00	 mov	 ecx, 1
  00284	48 6b c9 04	 imul	 rcx, rcx, 4
  00288	48 8b 54 24 50	 mov	 rdx, QWORD PTR dev$[rsp]
  0028d	88 84 0a 64 03
	00 00		 mov	 BYTE PTR [rdx+rcx+868], al
$LN13@ckd_build_:

; 1461 :     }
; 1462 :     if (dev->devtype == 0x3350)

  00294	48 8b 44 24 50	 mov	 rax, QWORD PTR dev$[rsp]
  00299	0f b7 40 4a	 movzx	 eax, WORD PTR [rax+74]
  0029d	3d 50 33 00 00	 cmp	 eax, 13136		; 00003350H
  002a2	75 33		 jne	 SHORT $LN14@ckd_build_

; 1463 :     {
; 1464 :        /* drive 0 = bit 0 (0x80), ... drive 7 = bit 7 (0x01) */
; 1465 :        dev->sense[4] =  0x80 >> (dev->devnum & 0x07);

  002a4	48 8b 44 24 50	 mov	 rax, QWORD PTR dev$[rsp]
  002a9	0f b7 40 48	 movzx	 eax, WORD PTR [rax+72]
  002ad	83 e0 07	 and	 eax, 7
  002b0	b9 80 00 00 00	 mov	 ecx, 128		; 00000080H
  002b5	89 4c 24 30	 mov	 DWORD PTR tv431[rsp], ecx
  002b9	0f b6 c8	 movzx	 ecx, al
  002bc	8b 44 24 30	 mov	 eax, DWORD PTR tv431[rsp]
  002c0	d3 f8		 sar	 eax, cl
  002c2	b9 01 00 00 00	 mov	 ecx, 1
  002c7	48 6b c9 04	 imul	 rcx, rcx, 4
  002cb	48 8b 54 24 50	 mov	 rdx, QWORD PTR dev$[rsp]
  002d0	88 84 0a 64 03
	00 00		 mov	 BYTE PTR [rdx+rcx+868], al
$LN14@ckd_build_:

; 1466 :     }
; 1467 :     if (dev->devtype == 0x3375)

  002d7	48 8b 44 24 50	 mov	 rax, QWORD PTR dev$[rsp]
  002dc	0f b7 40 4a	 movzx	 eax, WORD PTR [rax+74]
  002e0	3d 75 33 00 00	 cmp	 eax, 13173		; 00003375H
  002e5	75 21		 jne	 SHORT $LN15@ckd_build_

; 1468 :     {
; 1469 :        /* bits 3-4 = controller address, bits 5-7 = device address */
; 1470 :        dev->sense[4] = dev->devnum & 0x07;

  002e7	48 8b 44 24 50	 mov	 rax, QWORD PTR dev$[rsp]
  002ec	0f b7 40 48	 movzx	 eax, WORD PTR [rax+72]
  002f0	83 e0 07	 and	 eax, 7
  002f3	b9 01 00 00 00	 mov	 ecx, 1
  002f8	48 6b c9 04	 imul	 rcx, rcx, 4
  002fc	48 8b 54 24 50	 mov	 rdx, QWORD PTR dev$[rsp]
  00301	88 84 0a 64 03
	00 00		 mov	 BYTE PTR [rdx+rcx+868], al
$LN15@ckd_build_:

; 1471 :     }
; 1472 :     if (dev->devtype == 0x3380)

  00308	48 8b 44 24 50	 mov	 rax, QWORD PTR dev$[rsp]
  0030d	0f b7 40 4a	 movzx	 eax, WORD PTR [rax+74]
  00311	3d 80 33 00 00	 cmp	 eax, 13184		; 00003380H
  00316	75 21		 jne	 SHORT $LN16@ckd_build_

; 1473 :     {
; 1474 :        /* bits 4-7 = device address */
; 1475 :        dev->sense[4] = dev->devnum & 0x0F;

  00318	48 8b 44 24 50	 mov	 rax, QWORD PTR dev$[rsp]
  0031d	0f b7 40 48	 movzx	 eax, WORD PTR [rax+72]
  00321	83 e0 0f	 and	 eax, 15
  00324	b9 01 00 00 00	 mov	 ecx, 1
  00329	48 6b c9 04	 imul	 rcx, rcx, 4
  0032d	48 8b 54 24 50	 mov	 rdx, QWORD PTR dev$[rsp]
  00332	88 84 0a 64 03
	00 00		 mov	 BYTE PTR [rdx+rcx+868], al
$LN16@ckd_build_:

; 1476 :     }
; 1477 : 
; 1478 :     /* Sense byte 5 contains bits 8-15 of the cylinder address
; 1479 :        and sense byte 6 contains bits 4-7 of the cylinder
; 1480 :        address followed by bits 12-15 of the head address,
; 1481 :        unless the device has more than 4095 cylinders, in
; 1482 :        which case sense bytes 5 and 6 both contain X'FF' */
; 1483 :     if (dev->ckdcyls > 4095)

  00339	48 8b 44 24 50	 mov	 rax, QWORD PTR dev$[rsp]
  0033e	81 b8 b8 12 00
	00 ff 0f 00 00	 cmp	 DWORD PTR [rax+4792], 4095 ; 00000fffH
  00348	7e 31		 jle	 SHORT $LN17@ckd_build_

; 1484 :     {
; 1485 :         dev->sense[5] = 0xFF;

  0034a	b8 01 00 00 00	 mov	 eax, 1
  0034f	48 6b c0 05	 imul	 rax, rax, 5
  00353	48 8b 4c 24 50	 mov	 rcx, QWORD PTR dev$[rsp]
  00358	c6 84 01 64 03
	00 00 ff	 mov	 BYTE PTR [rcx+rax+868], 255 ; 000000ffH

; 1486 :         dev->sense[6] = 0xFF;

  00360	b8 01 00 00 00	 mov	 eax, 1
  00365	48 6b c0 06	 imul	 rax, rax, 6
  00369	48 8b 4c 24 50	 mov	 rcx, QWORD PTR dev$[rsp]
  0036e	c6 84 01 64 03
	00 00 ff	 mov	 BYTE PTR [rcx+rax+868], 255 ; 000000ffH

; 1487 :     }

  00376	e9 15 01 00 00	 jmp	 $LN18@ckd_build_
$LN17@ckd_build_:

; 1488 :     else
; 1489 :     {
; 1490 :      if ((dev->devtype == 0x2311 ) || (dev->devtype == 0x2314 )
; 1491 :       || (dev->devtype == 0x2305 ))

  0037b	48 8b 44 24 50	 mov	 rax, QWORD PTR dev$[rsp]
  00380	0f b7 40 4a	 movzx	 eax, WORD PTR [rax+74]
  00384	3d 11 23 00 00	 cmp	 eax, 8977		; 00002311H
  00389	74 20		 je	 SHORT $LN21@ckd_build_
  0038b	48 8b 44 24 50	 mov	 rax, QWORD PTR dev$[rsp]
  00390	0f b7 40 4a	 movzx	 eax, WORD PTR [rax+74]
  00394	3d 14 23 00 00	 cmp	 eax, 8980		; 00002314H
  00399	74 10		 je	 SHORT $LN21@ckd_build_
  0039b	48 8b 44 24 50	 mov	 rax, QWORD PTR dev$[rsp]
  003a0	0f b7 40 4a	 movzx	 eax, WORD PTR [rax+74]
  003a4	3d 05 23 00 00	 cmp	 eax, 8965		; 00002305H
  003a9	75 05		 jne	 SHORT $LN19@ckd_build_
$LN21@ckd_build_:

; 1492 :      {
; 1493 :      }

  003ab	e9 e0 00 00 00	 jmp	 $LN20@ckd_build_
$LN19@ckd_build_:

; 1494 :      else
; 1495 :      {
; 1496 :         dev->sense[5] = dev->ckdcurcyl & 0xFF;

  003b0	48 8b 44 24 50	 mov	 rax, QWORD PTR dev$[rsp]
  003b5	8b 80 c8 12 00
	00		 mov	 eax, DWORD PTR [rax+4808]
  003bb	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  003c0	b9 01 00 00 00	 mov	 ecx, 1
  003c5	48 6b c9 05	 imul	 rcx, rcx, 5
  003c9	48 8b 54 24 50	 mov	 rdx, QWORD PTR dev$[rsp]
  003ce	88 84 0a 64 03
	00 00		 mov	 BYTE PTR [rdx+rcx+868], al

; 1497 : 
; 1498 :      /* sense byte 6 bits     c = cyl high byte, h=head    */
; 1499 :      /*                          0 1 2 3 4 5 6 7   shift   */
; 1500 :      /* 3330-1                   - c - h h h h h      6    */
; 1501 :      /* 3330-11 3350             - c c h h h h h      5    */
; 1502 :      /* 3340                     - c c - h h h h      5    */
; 1503 :      /* 3375                     c c - - h h h h      6    */
; 1504 :      /* 3380                     c c c c h h h h      4    */
; 1505 :        switch (dev->devtype) {

  003d5	48 8b 44 24 50	 mov	 rax, QWORD PTR dev$[rsp]
  003da	0f b7 40 4a	 movzx	 eax, WORD PTR [rax+74]
  003de	89 44 24 24	 mov	 DWORD PTR tv267[rsp], eax
  003e2	81 7c 24 24 30
	33 00 00	 cmp	 DWORD PTR tv267[rsp], 13104 ; 00003330H
  003ea	74 20		 je	 SHORT $LN22@ckd_build_
  003ec	81 7c 24 24 40
	33 00 00	 cmp	 DWORD PTR tv267[rsp], 13120 ; 00003340H
  003f4	74 45		 je	 SHORT $LN25@ckd_build_
  003f6	81 7c 24 24 50
	33 00 00	 cmp	 DWORD PTR tv267[rsp], 13136 ; 00003350H
  003fe	74 3b		 je	 SHORT $LN26@ckd_build_
  00400	81 7c 24 24 75
	33 00 00	 cmp	 DWORD PTR tv267[rsp], 13173 ; 00003375H
  00408	74 3b		 je	 SHORT $LN27@ckd_build_
  0040a	eb 43		 jmp	 SHORT $LN28@ckd_build_
$LN22@ckd_build_:

; 1506 :         case 0x3330:
; 1507 :             if (dev->devid[6] == 0x01)

  0040c	b8 01 00 00 00	 mov	 eax, 1
  00411	48 6b c0 06	 imul	 rax, rax, 6
  00415	48 8b 4c 24 50	 mov	 rcx, QWORD PTR dev$[rsp]
  0041a	0f b6 84 01 68
	04 00 00	 movzx	 eax, BYTE PTR [rcx+rax+1128]
  00422	83 f8 01	 cmp	 eax, 1
  00425	75 0a		 jne	 SHORT $LN23@ckd_build_

; 1508 :                 shift = 6;        /* 3330-1  */

  00427	c7 44 24 20 06
	00 00 00	 mov	 DWORD PTR shift$[rsp], 6
  0042f	eb 08		 jmp	 SHORT $LN24@ckd_build_
$LN23@ckd_build_:

; 1509 :             else
; 1510 :                 shift = 5;        /* 3330-11 */

  00431	c7 44 24 20 05
	00 00 00	 mov	 DWORD PTR shift$[rsp], 5
$LN24@ckd_build_:

; 1511 :             break;

  00439	eb 1c		 jmp	 SHORT $LN2@ckd_build_
$LN25@ckd_build_:
$LN26@ckd_build_:

; 1512 :         case 0x3340:
; 1513 :         case 0x3350:
; 1514 :             shift = 5;

  0043b	c7 44 24 20 05
	00 00 00	 mov	 DWORD PTR shift$[rsp], 5

; 1515 :             break;

  00443	eb 12		 jmp	 SHORT $LN2@ckd_build_
$LN27@ckd_build_:

; 1516 :         case 0x3375:
; 1517 :             shift = 6;

  00445	c7 44 24 20 06
	00 00 00	 mov	 DWORD PTR shift$[rsp], 6

; 1518 :             break;

  0044d	eb 08		 jmp	 SHORT $LN2@ckd_build_
$LN28@ckd_build_:

; 1519 :         default:                        shift = 4; break;

  0044f	c7 44 24 20 04
	00 00 00	 mov	 DWORD PTR shift$[rsp], 4
$LN2@ckd_build_:

; 1520 :        }
; 1521 :         dev->sense[6] = (BYTE)(( (dev->ckdcurcyl >> 8) << shift )

  00457	48 8b 44 24 50	 mov	 rax, QWORD PTR dev$[rsp]
  0045c	8b 80 c8 12 00
	00		 mov	 eax, DWORD PTR [rax+4808]
  00462	c1 f8 08	 sar	 eax, 8
  00465	8b 4c 24 20	 mov	 ecx, DWORD PTR shift$[rsp]
  00469	d3 e0		 shl	 eax, cl
  0046b	48 8b 4c 24 50	 mov	 rcx, QWORD PTR dev$[rsp]
  00470	8b 89 cc 12 00
	00		 mov	 ecx, DWORD PTR [rcx+4812]
  00476	83 e1 1f	 and	 ecx, 31
  00479	0b c1		 or	 eax, ecx
  0047b	b9 01 00 00 00	 mov	 ecx, 1
  00480	48 6b c9 06	 imul	 rcx, rcx, 6
  00484	48 8b 54 24 50	 mov	 rdx, QWORD PTR dev$[rsp]
  00489	88 84 0a 64 03
	00 00		 mov	 BYTE PTR [rdx+rcx+868], al
$LN20@ckd_build_:
$LN18@ckd_build_:

; 1522 :                         | (dev->ckdcurhead & 0x1F));
; 1523 :      }
; 1524 :     }
; 1525 : 
; 1526 :     /* Sense byte 7 contains the format code and message type */
; 1527 :     dev->sense[7] = (format << 4) | (message & 0x0F);

  00490	0f b6 44 24 70	 movzx	 eax, BYTE PTR format$[rsp]
  00495	c1 e0 04	 shl	 eax, 4
  00498	0f b6 4c 24 78	 movzx	 ecx, BYTE PTR message$[rsp]
  0049d	83 e1 0f	 and	 ecx, 15
  004a0	0b c1		 or	 eax, ecx
  004a2	b9 01 00 00 00	 mov	 ecx, 1
  004a7	48 6b c9 07	 imul	 rcx, rcx, 7
  004ab	48 8b 54 24 50	 mov	 rdx, QWORD PTR dev$[rsp]
  004b0	88 84 0a 64 03
	00 00		 mov	 BYTE PTR [rdx+rcx+868], al

; 1528 : 
; 1529 :     /* Sense bytes 8-23 depend on the format code */
; 1530 :     switch (format) {

  004b7	0f b6 44 24 70	 movzx	 eax, BYTE PTR format$[rsp]
  004bc	88 44 24 28	 mov	 BYTE PTR tv297[rsp], al
  004c0	80 7c 24 28 04	 cmp	 BYTE PTR tv297[rsp], 4
  004c5	74 09		 je	 SHORT $LN29@ckd_build_
  004c7	80 7c 24 28 05	 cmp	 BYTE PTR tv297[rsp], 5
  004cc	74 02		 je	 SHORT $LN30@ckd_build_
  004ce	eb 7f		 jmp	 SHORT $LN4@ckd_build_
$LN29@ckd_build_:
$LN30@ckd_build_:

; 1531 : 
; 1532 :     case FORMAT_4: /* Data check */
; 1533 :     case FORMAT_5: /* Data check with displacement information */
; 1534 :         /* Sense bytes 8-12 contain the CCHHR of the record in error */
; 1535 :         store_hw( &dev->sense[ 8], (U16)dev->ckdcurcyl  );

  004d0	48 8b 44 24 50	 mov	 rax, QWORD PTR dev$[rsp]
  004d5	0f b7 88 c8 12
	00 00		 movzx	 ecx, WORD PTR [rax+4808]
  004dc	e8 00 00 00 00	 call	 _byteswap_ushort
  004e1	b9 01 00 00 00	 mov	 ecx, 1
  004e6	48 6b c9 08	 imul	 rcx, rcx, 8
  004ea	48 8b 54 24 50	 mov	 rdx, QWORD PTR dev$[rsp]
  004ef	48 8d 8c 0a 64
	03 00 00	 lea	 rcx, QWORD PTR [rdx+rcx+868]
  004f7	0f b7 d0	 movzx	 edx, ax
  004fa	e8 00 00 00 00	 call	 store_hw_noswap

; 1536 :         store_hw( &dev->sense[10], (U16)dev->ckdcurhead );

  004ff	48 8b 44 24 50	 mov	 rax, QWORD PTR dev$[rsp]
  00504	0f b7 88 cc 12
	00 00		 movzx	 ecx, WORD PTR [rax+4812]
  0050b	e8 00 00 00 00	 call	 _byteswap_ushort
  00510	b9 01 00 00 00	 mov	 ecx, 1
  00515	48 6b c9 0a	 imul	 rcx, rcx, 10
  00519	48 8b 54 24 50	 mov	 rdx, QWORD PTR dev$[rsp]
  0051e	48 8d 8c 0a 64
	03 00 00	 lea	 rcx, QWORD PTR [rdx+rcx+868]
  00526	0f b7 d0	 movzx	 edx, ax
  00529	e8 00 00 00 00	 call	 store_hw_noswap

; 1537 :         dev->sense[12] = (BYTE) dev->ckdcurrec;

  0052e	b8 01 00 00 00	 mov	 eax, 1
  00533	48 6b c0 0c	 imul	 rax, rax, 12
  00537	48 8b 4c 24 50	 mov	 rcx, QWORD PTR dev$[rsp]
  0053c	48 8b 54 24 50	 mov	 rdx, QWORD PTR dev$[rsp]
  00541	0f b6 92 d0 12
	00 00		 movzx	 edx, BYTE PTR [rdx+4816]
  00548	88 94 01 64 03
	00 00		 mov	 BYTE PTR [rcx+rax+868], dl
$LN4@ckd_build_:

; 1538 :         break;
; 1539 : 
; 1540 :     } /* end switch(format) */
; 1541 : 
; 1542 :     /* Sense byte 27 bit 0 indicates 24-byte compatibility sense data*/
; 1543 :     dev->sense[27] = 0x80;

  0054f	b8 01 00 00 00	 mov	 eax, 1
  00554	48 6b c0 1b	 imul	 rax, rax, 27
  00558	48 8b 4c 24 50	 mov	 rcx, QWORD PTR dev$[rsp]
  0055d	c6 84 01 64 03
	00 00 80	 mov	 BYTE PTR [rcx+rax+868], 128 ; 00000080H

; 1544 : 
; 1545 :     /* Sense bytes 29-30 contain the cylinder address */
; 1546 :     store_hw( &dev->sense[29], (U16)dev->ckdcurcyl  );

  00565	48 8b 44 24 50	 mov	 rax, QWORD PTR dev$[rsp]
  0056a	0f b7 88 c8 12
	00 00		 movzx	 ecx, WORD PTR [rax+4808]
  00571	e8 00 00 00 00	 call	 _byteswap_ushort
  00576	b9 01 00 00 00	 mov	 ecx, 1
  0057b	48 6b c9 1d	 imul	 rcx, rcx, 29
  0057f	48 8b 54 24 50	 mov	 rdx, QWORD PTR dev$[rsp]
  00584	48 8d 8c 0a 64
	03 00 00	 lea	 rcx, QWORD PTR [rdx+rcx+868]
  0058c	0f b7 d0	 movzx	 edx, ax
  0058f	e8 00 00 00 00	 call	 store_hw_noswap

; 1547 : 
; 1548 :     /* Sense byte 31 contains the head address */
; 1549 :     dev->sense[31] = dev->ckdcurhead & 0xFF;

  00594	48 8b 44 24 50	 mov	 rax, QWORD PTR dev$[rsp]
  00599	8b 80 cc 12 00
	00		 mov	 eax, DWORD PTR [rax+4812]
  0059f	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  005a4	b9 01 00 00 00	 mov	 ecx, 1
  005a9	48 6b c9 1f	 imul	 rcx, rcx, 31
  005ad	48 8b 54 24 50	 mov	 rdx, QWORD PTR dev$[rsp]
  005b2	88 84 0a 64 03
	00 00		 mov	 BYTE PTR [rdx+rcx+868], al

; 1550 : 
; 1551 : } /* end function ckd_build_sense */

  005b9	48 83 c4 40	 add	 rsp, 64			; 00000040H
  005bd	5f		 pop	 rdi
  005be	c3		 ret	 0
ckd_build_sense ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\machdep.h
;	COMDAT store_dw_noswap
_TEXT	SEGMENT
ptr$ = 8
value$ = 16
store_dw_noswap PROC					; COMDAT

; 834  :     inline void store_dw_noswap(void *ptr, U64 value) {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx

; 835  :       memcpy((BYTE *)ptr, (BYTE *)&value, 8);

  0000a	48 8b 44 24 08	 mov	 rax, QWORD PTR ptr$[rsp]
  0000f	48 8b 4c 24 10	 mov	 rcx, QWORD PTR value$[rsp]
  00014	48 89 08	 mov	 QWORD PTR [rax], rcx

; 836  :     }

  00017	c3		 ret	 0
store_dw_noswap ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\machdep.h
;	COMDAT fetch_dw_noswap
_TEXT	SEGMENT
value$ = 0
ptr$ = 32
fetch_dw_noswap PROC					; COMDAT

; 816  :     inline U64 fetch_dw_noswap(const void *ptr) {

$LN3:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 18	 sub	 rsp, 24

; 817  :       U64 value;
; 818  :       memcpy(&value, (BYTE *)ptr, 8);

  00009	48 8b 44 24 20	 mov	 rax, QWORD PTR ptr$[rsp]
  0000e	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00011	48 89 04 24	 mov	 QWORD PTR value$[rsp], rax

; 819  :       return value;

  00015	48 8b 04 24	 mov	 rax, QWORD PTR value$[rsp]

; 820  :     }

  00019	48 83 c4 18	 add	 rsp, 24
  0001d	c3		 ret	 0
fetch_dw_noswap ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\machdep.h
;	COMDAT store_fw_noswap
_TEXT	SEGMENT
ptr$ = 8
value$ = 16
store_fw_noswap PROC					; COMDAT

; 764  :     inline void store_fw_noswap(void *ptr, U32 value) {

  00000	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00004	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx

; 765  :       memcpy((BYTE *)ptr, (BYTE *)&value, 4);

  00009	48 8b 44 24 08	 mov	 rax, QWORD PTR ptr$[rsp]
  0000e	8b 4c 24 10	 mov	 ecx, DWORD PTR value$[rsp]
  00012	89 08		 mov	 DWORD PTR [rax], ecx

; 766  :     }

  00014	c3		 ret	 0
store_fw_noswap ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\machdep.h
;	COMDAT fetch_fw_noswap
_TEXT	SEGMENT
value$ = 0
ptr$ = 32
fetch_fw_noswap PROC					; COMDAT

; 746  :     inline U32 fetch_fw_noswap(const void *ptr) {

$LN3:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 18	 sub	 rsp, 24

; 747  :       U32 value;
; 748  :       memcpy(&value, (BYTE *)ptr, 4);

  00009	48 8b 44 24 20	 mov	 rax, QWORD PTR ptr$[rsp]
  0000e	8b 00		 mov	 eax, DWORD PTR [rax]
  00010	89 04 24	 mov	 DWORD PTR value$[rsp], eax

; 749  :       return value;

  00013	8b 04 24	 mov	 eax, DWORD PTR value$[rsp]

; 750  :     }

  00016	48 83 c4 18	 add	 rsp, 24
  0001a	c3		 ret	 0
fetch_fw_noswap ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\machdep.h
;	COMDAT store_hw_noswap
_TEXT	SEGMENT
ptr$ = 8
value$ = 16
store_hw_noswap PROC					; COMDAT

; 730  :     inline void store_hw_noswap(void *ptr, U16 value) {

  00000	66 89 54 24 10	 mov	 WORD PTR [rsp+16], dx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx

; 731  :       memcpy((BYTE *)ptr, (BYTE *)&value, 2);

  0000a	48 8b 44 24 08	 mov	 rax, QWORD PTR ptr$[rsp]
  0000f	0f b7 4c 24 10	 movzx	 ecx, WORD PTR value$[rsp]
  00014	66 89 08	 mov	 WORD PTR [rax], cx

; 732  :     }

  00017	c3		 ret	 0
store_hw_noswap ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\machdep.h
;	COMDAT fetch_hw_noswap
_TEXT	SEGMENT
value$ = 0
ptr$ = 32
fetch_hw_noswap PROC					; COMDAT

; 712  :     inline U16 fetch_hw_noswap(const void *ptr) {

$LN3:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 18	 sub	 rsp, 24

; 713  :       U16 value;
; 714  :       memcpy(&value, (BYTE *)ptr, 2);

  00009	48 8b 44 24 20	 mov	 rax, QWORD PTR ptr$[rsp]
  0000e	0f b7 00	 movzx	 eax, WORD PTR [rax]
  00011	66 89 04 24	 mov	 WORD PTR value$[rsp], ax

; 715  :       return value;

  00015	0f b7 04 24	 movzx	 eax, WORD PTR value$[rsp]

; 716  :     }

  00019	48 83 c4 18	 add	 rsp, 24
  0001d	c3		 ret	 0
fetch_hw_noswap ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\dbgtrace.h
_TEXT	SEGMENT
buffsize$ = 48
rc$ = 52
chunksize$ = 56
buffer$ = 64
args$ = 72
fmt$ = 96
DebuggerTrace PROC

; 94   :   static inline void DebuggerTrace(char* fmt, ...) {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000f	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00014	48 83 ec 58	 sub	 rsp, 88			; 00000058H

; 95   :       const int chunksize = 512;

  00018	c7 44 24 38 00
	02 00 00	 mov	 DWORD PTR chunksize$[rsp], 512 ; 00000200H

; 96   :       int buffsize = 0;

  00020	c7 44 24 30 00
	00 00 00	 mov	 DWORD PTR buffsize$[rsp], 0

; 97   :       char* buffer = NULL;

  00028	48 c7 44 24 40
	00 00 00 00	 mov	 QWORD PTR buffer$[rsp], 0

; 98   :       int rc = -1;

  00031	c7 44 24 34 ff
	ff ff ff	 mov	 DWORD PTR rc$[rsp], -1

; 99   :       va_list args;
; 100  :       va_start( args, fmt );

  00039	48 8d 44 24 68	 lea	 rax, QWORD PTR fmt$[rsp+8]
  0003e	48 89 44 24 48	 mov	 QWORD PTR args$[rsp], rax
$LN9@DebuggerTr:
$LN4@DebuggerTr:

; 101  :       do {
; 102  :           if (buffer) free( buffer );

  00043	48 83 7c 24 40
	00		 cmp	 QWORD PTR buffer$[rsp], 0
  00049	74 0b		 je	 SHORT $LN5@DebuggerTr
  0004b	48 8b 4c 24 40	 mov	 rcx, QWORD PTR buffer$[rsp]
  00050	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free
$LN5@DebuggerTr:

; 103  :           buffsize += chunksize;

  00056	8b 44 24 38	 mov	 eax, DWORD PTR chunksize$[rsp]
  0005a	8b 4c 24 30	 mov	 ecx, DWORD PTR buffsize$[rsp]
  0005e	03 c8		 add	 ecx, eax
  00060	8b c1		 mov	 eax, ecx
  00062	89 44 24 30	 mov	 DWORD PTR buffsize$[rsp], eax

; 104  :           buffer = malloc( buffsize + 1 );

  00066	8b 44 24 30	 mov	 eax, DWORD PTR buffsize$[rsp]
  0006a	ff c0		 inc	 eax
  0006c	48 98		 cdqe
  0006e	48 8b c8	 mov	 rcx, rax
  00071	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_malloc
  00077	48 89 44 24 40	 mov	 QWORD PTR buffer$[rsp], rax

; 105  :           if (!buffer) BREAK_INTO_DEBUGGER();

  0007c	48 83 7c 24 40
	00		 cmp	 QWORD PTR buffer$[rsp], 0
  00082	75 01		 jne	 SHORT $LN6@DebuggerTr
  00084	cc		 int	 3
$LN6@DebuggerTr:

; 106  :           rc = _vsnprintf_s( buffer, buffsize+1, buffsize, fmt, args);

  00085	48 63 44 24 30	 movsxd	 rax, DWORD PTR buffsize$[rsp]
  0008a	8b 4c 24 30	 mov	 ecx, DWORD PTR buffsize$[rsp]
  0008e	ff c1		 inc	 ecx
  00090	48 63 c9	 movsxd	 rcx, ecx
  00093	48 8b 54 24 48	 mov	 rdx, QWORD PTR args$[rsp]
  00098	48 89 54 24 20	 mov	 QWORD PTR [rsp+32], rdx
  0009d	4c 8b 4c 24 60	 mov	 r9, QWORD PTR fmt$[rsp]
  000a2	4c 8b c0	 mov	 r8, rax
  000a5	48 8b d1	 mov	 rdx, rcx
  000a8	48 8b 4c 24 40	 mov	 rcx, QWORD PTR buffer$[rsp]
  000ad	e8 00 00 00 00	 call	 _vsnprintf_s
  000b2	89 44 24 34	 mov	 DWORD PTR rc$[rsp], eax

; 107  :       } while (rc < 0 || rc >= buffsize);

  000b6	83 7c 24 34 00	 cmp	 DWORD PTR rc$[rsp], 0
  000bb	7c 86		 jl	 SHORT $LN4@DebuggerTr
  000bd	8b 44 24 30	 mov	 eax, DWORD PTR buffsize$[rsp]
  000c1	39 44 24 34	 cmp	 DWORD PTR rc$[rsp], eax
  000c5	0f 8d 78 ff ff
	ff		 jge	 $LN9@DebuggerTr

; 108  :       OutputDebugStringA( buffer ); /* send to debugger pane */

  000cb	48 8b 4c 24 40	 mov	 rcx, QWORD PTR buffer$[rsp]
  000d0	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_OutputDebugStringA

; 109  :       if (buffer) free( buffer );

  000d6	48 83 7c 24 40
	00		 cmp	 QWORD PTR buffer$[rsp], 0
  000dc	74 0b		 je	 SHORT $LN7@DebuggerTr
  000de	48 8b 4c 24 40	 mov	 rcx, QWORD PTR buffer$[rsp]
  000e3	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free
$LN7@DebuggerTr:

; 110  :       va_end( args );

  000e9	48 c7 44 24 48
	00 00 00 00	 mov	 QWORD PTR args$[rsp], 0

; 111  :   }

  000f2	48 83 c4 58	 add	 rsp, 88			; 00000058H
  000f6	c3		 ret	 0
DebuggerTrace ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files (x86)\Windows Kits\10\include\10.0.22000.0\ucrt\stdio.h
;	COMDAT sscanf
_TEXT	SEGMENT
_Result$ = 32
_ArgList$ = 40
_Buffer$ = 64
_Format$ = 72
sscanf	PROC						; COMDAT

; 2247 :     {

$LN3:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000f	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00014	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 2248 :         int _Result;
; 2249 :         va_list _ArgList;
; 2250 :         __crt_va_start(_ArgList, _Format);

  00018	48 8d 44 24 50	 lea	 rax, QWORD PTR _Format$[rsp+8]
  0001d	48 89 44 24 28	 mov	 QWORD PTR _ArgList$[rsp], rax

; 2251 :         _Result = _vsscanf_l(_Buffer, _Format, NULL, _ArgList);

  00022	4c 8b 4c 24 28	 mov	 r9, QWORD PTR _ArgList$[rsp]
  00027	45 33 c0	 xor	 r8d, r8d
  0002a	48 8b 54 24 48	 mov	 rdx, QWORD PTR _Format$[rsp]
  0002f	48 8b 4c 24 40	 mov	 rcx, QWORD PTR _Buffer$[rsp]
  00034	e8 00 00 00 00	 call	 _vsscanf_l
  00039	89 44 24 20	 mov	 DWORD PTR _Result$[rsp], eax

; 2252 :         __crt_va_end(_ArgList);

  0003d	48 c7 44 24 28
	00 00 00 00	 mov	 QWORD PTR _ArgList$[rsp], 0

; 2253 :         return _Result;

  00046	8b 44 24 20	 mov	 eax, DWORD PTR _Result$[rsp]

; 2254 :     }

  0004a	48 83 c4 38	 add	 rsp, 56			; 00000038H
  0004e	c3		 ret	 0
sscanf	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files (x86)\Windows Kits\10\include\10.0.22000.0\ucrt\stdio.h
;	COMDAT _vsscanf_l
_TEXT	SEGMENT
_Buffer$ = 64
_Format$ = 72
_Locale$ = 80
_ArgList$ = 88
_vsscanf_l PROC						; COMDAT

; 2152 :     {

$LN3:
  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 2153 :         return __stdio_common_vsscanf(

  00018	e8 00 00 00 00	 call	 __local_stdio_scanf_options
  0001d	48 8b 4c 24 58	 mov	 rcx, QWORD PTR _ArgList$[rsp]
  00022	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00027	48 8b 4c 24 50	 mov	 rcx, QWORD PTR _Locale$[rsp]
  0002c	48 89 4c 24 20	 mov	 QWORD PTR [rsp+32], rcx
  00031	4c 8b 4c 24 48	 mov	 r9, QWORD PTR _Format$[rsp]
  00036	49 c7 c0 ff ff
	ff ff		 mov	 r8, -1
  0003d	48 8b 54 24 40	 mov	 rdx, QWORD PTR _Buffer$[rsp]
  00042	48 8b 08	 mov	 rcx, QWORD PTR [rax]
  00045	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___stdio_common_vsscanf

; 2154 :             _CRT_INTERNAL_LOCAL_SCANF_OPTIONS,
; 2155 :             _Buffer, (size_t)-1, _Format, _Locale, _ArgList);
; 2156 :     }

  0004b	48 83 c4 38	 add	 rsp, 56			; 00000038H
  0004f	c3		 ret	 0
_vsscanf_l ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files (x86)\Windows Kits\10\include\10.0.22000.0\ucrt\stdio.h
;	COMDAT sprintf
_TEXT	SEGMENT
_Result$ = 32
_ArgList$ = 40
_Buffer$ = 64
_Format$ = 72
sprintf	PROC						; COMDAT

; 1771 :     {

$LN3:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000f	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00014	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 1772 :         int _Result;
; 1773 :         va_list _ArgList;
; 1774 :         __crt_va_start(_ArgList, _Format);

  00018	48 8d 44 24 50	 lea	 rax, QWORD PTR _Format$[rsp+8]
  0001d	48 89 44 24 28	 mov	 QWORD PTR _ArgList$[rsp], rax

; 1775 : 
; 1776 :         _Result = _vsprintf_l(_Buffer, _Format, NULL, _ArgList);

  00022	4c 8b 4c 24 28	 mov	 r9, QWORD PTR _ArgList$[rsp]
  00027	45 33 c0	 xor	 r8d, r8d
  0002a	48 8b 54 24 48	 mov	 rdx, QWORD PTR _Format$[rsp]
  0002f	48 8b 4c 24 40	 mov	 rcx, QWORD PTR _Buffer$[rsp]
  00034	e8 00 00 00 00	 call	 _vsprintf_l
  00039	89 44 24 20	 mov	 DWORD PTR _Result$[rsp], eax

; 1777 : 
; 1778 :         __crt_va_end(_ArgList);

  0003d	48 c7 44 24 28
	00 00 00 00	 mov	 QWORD PTR _ArgList$[rsp], 0

; 1779 :         return _Result;

  00046	8b 44 24 20	 mov	 eax, DWORD PTR _Result$[rsp]

; 1780 :     }

  0004a	48 83 c4 38	 add	 rsp, 56			; 00000038H
  0004e	c3		 ret	 0
sprintf	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files (x86)\Windows Kits\10\include\10.0.22000.0\ucrt\stdio.h
;	COMDAT _vsnprintf_s
_TEXT	SEGMENT
_Buffer$ = 64
_BufferCount$ = 72
_MaxCount$ = 80
_Format$ = 88
_ArgList$ = 96
_vsnprintf_s PROC					; COMDAT

; 1598 :     {

$LN3:
  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 1599 :         return _vsnprintf_s_l(_Buffer, _BufferCount, _MaxCount, _Format, NULL, _ArgList);

  00018	48 8b 44 24 60	 mov	 rax, QWORD PTR _ArgList$[rsp]
  0001d	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  00022	48 c7 44 24 20
	00 00 00 00	 mov	 QWORD PTR [rsp+32], 0
  0002b	4c 8b 4c 24 58	 mov	 r9, QWORD PTR _Format$[rsp]
  00030	4c 8b 44 24 50	 mov	 r8, QWORD PTR _MaxCount$[rsp]
  00035	48 8b 54 24 48	 mov	 rdx, QWORD PTR _BufferCount$[rsp]
  0003a	48 8b 4c 24 40	 mov	 rcx, QWORD PTR _Buffer$[rsp]
  0003f	e8 00 00 00 00	 call	 _vsnprintf_s_l

; 1600 :     }

  00044	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00048	c3		 ret	 0
_vsnprintf_s ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files (x86)\Windows Kits\10\include\10.0.22000.0\ucrt\stdio.h
;	COMDAT _vsnprintf_s_l
_TEXT	SEGMENT
_Result$ = 64
tv74 = 68
_Buffer$ = 96
_BufferCount$ = 104
_MaxCount$ = 112
_Format$ = 120
_Locale$ = 128
_ArgList$ = 136
_vsnprintf_s_l PROC					; COMDAT

; 1577 :     {

$LN5:
  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	48 83 ec 58	 sub	 rsp, 88			; 00000058H

; 1578 :         int const _Result = __stdio_common_vsnprintf_s(

  00018	e8 00 00 00 00	 call	 __local_stdio_printf_options
  0001d	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR _ArgList$[rsp]
  00025	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  0002a	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR _Locale$[rsp]
  00032	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00037	48 8b 4c 24 78	 mov	 rcx, QWORD PTR _Format$[rsp]
  0003c	48 89 4c 24 20	 mov	 QWORD PTR [rsp+32], rcx
  00041	4c 8b 4c 24 70	 mov	 r9, QWORD PTR _MaxCount$[rsp]
  00046	4c 8b 44 24 68	 mov	 r8, QWORD PTR _BufferCount$[rsp]
  0004b	48 8b 54 24 60	 mov	 rdx, QWORD PTR _Buffer$[rsp]
  00050	48 8b 08	 mov	 rcx, QWORD PTR [rax]
  00053	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___stdio_common_vsnprintf_s
  00059	89 44 24 40	 mov	 DWORD PTR _Result$[rsp], eax

; 1579 :             _CRT_INTERNAL_LOCAL_PRINTF_OPTIONS,
; 1580 :             _Buffer, _BufferCount, _MaxCount, _Format, _Locale, _ArgList);
; 1581 : 
; 1582 :         return _Result < 0 ? -1 : _Result;

  0005d	83 7c 24 40 00	 cmp	 DWORD PTR _Result$[rsp], 0
  00062	7d 0a		 jge	 SHORT $LN3@vsnprintf_
  00064	c7 44 24 44 ff
	ff ff ff	 mov	 DWORD PTR tv74[rsp], -1
  0006c	eb 08		 jmp	 SHORT $LN4@vsnprintf_
$LN3@vsnprintf_:
  0006e	8b 44 24 40	 mov	 eax, DWORD PTR _Result$[rsp]
  00072	89 44 24 44	 mov	 DWORD PTR tv74[rsp], eax
$LN4@vsnprintf_:
  00076	8b 44 24 44	 mov	 eax, DWORD PTR tv74[rsp]

; 1583 :     }

  0007a	48 83 c4 58	 add	 rsp, 88			; 00000058H
  0007e	c3		 ret	 0
_vsnprintf_s_l ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files (x86)\Windows Kits\10\include\10.0.22000.0\ucrt\stdio.h
;	COMDAT _vsprintf_l
_TEXT	SEGMENT
_Buffer$ = 64
_Format$ = 72
_Locale$ = 80
_ArgList$ = 88
_vsprintf_l PROC					; COMDAT

; 1458 :     {

$LN3:
  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 1459 :         return _vsnprintf_l(_Buffer, (size_t)-1, _Format, _Locale, _ArgList);

  00018	48 8b 44 24 58	 mov	 rax, QWORD PTR _ArgList$[rsp]
  0001d	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00022	4c 8b 4c 24 50	 mov	 r9, QWORD PTR _Locale$[rsp]
  00027	4c 8b 44 24 48	 mov	 r8, QWORD PTR _Format$[rsp]
  0002c	48 c7 c2 ff ff
	ff ff		 mov	 rdx, -1
  00033	48 8b 4c 24 40	 mov	 rcx, QWORD PTR _Buffer$[rsp]
  00038	e8 00 00 00 00	 call	 _vsnprintf_l

; 1460 :     }

  0003d	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00041	c3		 ret	 0
_vsprintf_l ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files (x86)\Windows Kits\10\include\10.0.22000.0\ucrt\stdio.h
;	COMDAT _vsnprintf_l
_TEXT	SEGMENT
_Result$ = 48
tv74 = 52
_Buffer$ = 80
_BufferCount$ = 88
_Format$ = 96
_Locale$ = 104
_ArgList$ = 112
_vsnprintf_l PROC					; COMDAT

; 1391 :     {

$LN5:
  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 1392 :         int const _Result = __stdio_common_vsprintf(

  00018	e8 00 00 00 00	 call	 __local_stdio_printf_options
  0001d	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00020	48 83 c8 01	 or	 rax, 1
  00024	48 8b 4c 24 70	 mov	 rcx, QWORD PTR _ArgList$[rsp]
  00029	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  0002e	48 8b 4c 24 68	 mov	 rcx, QWORD PTR _Locale$[rsp]
  00033	48 89 4c 24 20	 mov	 QWORD PTR [rsp+32], rcx
  00038	4c 8b 4c 24 60	 mov	 r9, QWORD PTR _Format$[rsp]
  0003d	4c 8b 44 24 58	 mov	 r8, QWORD PTR _BufferCount$[rsp]
  00042	48 8b 54 24 50	 mov	 rdx, QWORD PTR _Buffer$[rsp]
  00047	48 8b c8	 mov	 rcx, rax
  0004a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___stdio_common_vsprintf
  00050	89 44 24 30	 mov	 DWORD PTR _Result$[rsp], eax

; 1393 :             _CRT_INTERNAL_LOCAL_PRINTF_OPTIONS | _CRT_INTERNAL_PRINTF_LEGACY_VSPRINTF_NULL_TERMINATION,
; 1394 :             _Buffer, _BufferCount, _Format, _Locale, _ArgList);
; 1395 : 
; 1396 :         return _Result < 0 ? -1 : _Result;

  00054	83 7c 24 30 00	 cmp	 DWORD PTR _Result$[rsp], 0
  00059	7d 0a		 jge	 SHORT $LN3@vsnprintf_
  0005b	c7 44 24 34 ff
	ff ff ff	 mov	 DWORD PTR tv74[rsp], -1
  00063	eb 08		 jmp	 SHORT $LN4@vsnprintf_
$LN3@vsnprintf_:
  00065	8b 44 24 30	 mov	 eax, DWORD PTR _Result$[rsp]
  00069	89 44 24 34	 mov	 DWORD PTR tv74[rsp], eax
$LN4@vsnprintf_:
  0006d	8b 44 24 34	 mov	 eax, DWORD PTR tv74[rsp]

; 1397 :     }

  00071	48 83 c4 48	 add	 rsp, 72			; 00000048H
  00075	c3		 ret	 0
_vsnprintf_l ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files (x86)\Windows Kits\10\include\10.0.22000.0\ucrt\corecrt_stdio_config.h
;	COMDAT __local_stdio_scanf_options
_TEXT	SEGMENT
__local_stdio_scanf_options PROC			; COMDAT

; 101  :         static unsigned __int64 _OptionsStorage;
; 102  :         return &_OptionsStorage;

  00000	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:?_OptionsStorage@?1??__local_stdio_scanf_options@@9@9 ; `__local_stdio_scanf_options'::`2'::_OptionsStorage

; 103  :     }

  00007	c3		 ret	 0
__local_stdio_scanf_options ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files (x86)\Windows Kits\10\include\10.0.22000.0\ucrt\corecrt_stdio_config.h
;	COMDAT __local_stdio_printf_options
_TEXT	SEGMENT
__local_stdio_printf_options PROC			; COMDAT

; 91   :         static unsigned __int64 _OptionsStorage;
; 92   :         return &_OptionsStorage;

  00000	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:?_OptionsStorage@?1??__local_stdio_printf_options@@9@9 ; `__local_stdio_printf_options'::`2'::_OptionsStorage

; 93   :     }

  00007	c3		 ret	 0
__local_stdio_printf_options ENDP
_TEXT	ENDS
END
