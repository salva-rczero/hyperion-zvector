; Listing generated by Microsoft (R) Optimizing Compiler Version 19.34.31937.0 

include listing.inc

INCLUDELIB MSVCRTD
INCLUDELIB OLDNAMES

CONST	SEGMENT
CKD_ENDTRK DB	0ffH
	DB	0ffH
	DB	0ffH
	DB	0ffH
	DB	0ffH
	DB	0ffH
	DB	0ffH
	DB	0ffH
?minmax_mainsize@?1??adjust_mainsize@@9@9 DQ 0000000000010000H ; `adjust_mainsize'::`2'::minmax_mainsize
	DQ	0000000080000000H
	DQ	0000000000100000H
	DQ	0000000080000000H
	DQ	0000000000100000H
	DQ	ffffffffffffffffH
CONST	ENDS
PUBLIC	__local_stdio_printf_options
PUBLIC	_vsnprintf_s_l
PUBLIC	_vsnprintf_s
PUBLIC	release_config
PUBLIC	find_device_by_devnum
PUBLIC	find_device_by_subchan
PUBLIC	attach_device
PUBLIC	detach_device
PUBLIC	define_device
PUBLIC	group_device
PUBLIC	free_group
PUBLIC	configure_cpu
PUBLIC	deconfigure_cpu
PUBLIC	configure_numcpu
PUBLIC	configure_maxcpu
PUBLIC	configure_memfree
PUBLIC	configure_storage
PUBLIC	configure_xstorage
PUBLIC	adjust_mainsize
PUBLIC	configure_shrdport
PUBLIC	parse_and_attach_devices
PUBLIC	parse_single_devnum
PUBLIC	parse_single_devnum_silent
PUBLIC	parse_devnums
PUBLIC	readlogo
PUBLIC	clearlogo
PUBLIC	parse_conkpalv
PUBLIC	is_diag_instr
PUBLIC	are_cpu_thread
EXTRN	__imp__errno:PROC
EXTRN	strchr:PROC
EXTRN	strcmp:PROC
EXTRN	__imp__stricmp:PROC
EXTRN	strlen:PROC
EXTRN	__imp_strspn:PROC
EXTRN	__imp_strdup:PROC
EXTRN	__imp_IsDebuggerPresent:PROC
EXTRN	__imp_OutputDebugStringA:PROC
EXTRN	__imp_calloc:PROC
EXTRN	__imp_free:PROC
EXTRN	__imp_malloc:PROC
EXTRN	__imp_realloc:PROC
EXTRN	__imp__aligned_free:PROC
EXTRN	__imp__aligned_malloc:PROC
EXTRN	_byteswap_ulong:PROC
EXTRN	_byteswap_uint64:PROC
EXTRN	__imp_atoi:PROC
EXTRN	__imp_strtoul:PROC
EXTRN	__imp___acrt_iob_func:PROC
EXTRN	__imp_fgets:PROC
EXTRN	__imp_fopen:PROC
EXTRN	__imp___stdio_common_vsnprintf_s:PROC
EXTRN	__imp_fthread_self:PROC
EXTRN	__imp_hthread_initialize_lock:PROC
EXTRN	__imp_hthread_obtain_lock:PROC
EXTRN	__imp_hthread_have_lock:PROC
EXTRN	__imp_hthread_release_lock:PROC
EXTRN	__imp_hthread_initialize_condition:PROC
EXTRN	__imp_hthread_signal_condition:PROC
EXTRN	__imp_hthread_broadcast_condition:PROC
EXTRN	__imp_hthread_wait_condition:PROC
EXTRN	__imp_hthread_create_thread:PROC
EXTRN	__imp_hthread_join_thread:PROC
EXTRN	__imp_hthread_detach_thread:PROC
EXTRN	__imp_hthread_equal_threads:PROC
EXTRN	__imp_hthread_set_lock_name:PROC
EXTRN	__imp_ptt_pthread_print:PROC
EXTRN	__imp_ptt_dtax:PROC
EXTRN	__imp_resolve_symbol_string:PROC
EXTRN	__imp_set_symbol:PROC
EXTRN	__imp_strlcpy:PROC
EXTRN	__imp_strlcat:PROC
EXTRN	__imp_fmt_memsize_KB:PROC
EXTRN	__imp_fmt_memsize_MB:PROC
EXTRN	__imp_ptyp2short:PROC
EXTRN	__imp_w32_strerror:PROC
EXTRN	__imp_strtok_r:PROC
EXTRN	__imp_pthread_getcpuclockid:PROC
EXTRN	__imp_w32_snprintf:PROC
EXTRN	__imp_w32_fclose:PROC
EXTRN	__imp_hdl_DEVHND:PROC
EXTRN	__imp_shared_server:PROC
EXTRN	__imp_shared_print_trace_table:PROC
EXTRN	cpu_thread:PROC
EXTRN	initial_cpu_reset_all:PROC
EXTRN	initial_cpu_reset:PROC
EXTRN	storage_clear:PROC
EXTRN	xstorage_clear:PROC
EXTRN	build_attach_chrpt:PROC
EXTRN	build_detach_chrpt:PROC
EXTRN	__imp_shutdown_shared_server_locked:PROC
EXTRN	resetAllCpuIds:PROC
EXTRN	__imp_fwritemsg:PROC
EXTRN	__imp_logmsg:PROC
EXTRN	__imp_cckd_print_itrace:PROC
EXTRN	__imp_cckd_dtax:PROC
EXTRN	__GSHandlerCheck:PROC
EXTRN	__security_check_cookie:PROC
EXTRN	__imp_sysblk:BYTE
EXTRN	__security_cookie:QWORD
_DATA	SEGMENT
COMM	?_OptionsStorage@?1??__local_stdio_printf_options@@9@9:QWORD							; `__local_stdio_printf_options'::`2'::_OptionsStorage
_DATA	ENDS
_BSS	SEGMENT
config_allocmsize DQ 01H DUP (?)
config_allocmaddr DQ 01H DUP (?)
config_allocxsize DQ 01H DUP (?)
config_allocxaddr DQ 01H DUP (?)
$SG190308 DB	01H DUP (?)
	ALIGN	4

$SG190315 DB	01H DUP (?)
_BSS	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$_vsnprintf_s_l DD imagerel $LN5
	DD	imagerel $LN5+127
	DD	imagerel $unwind$_vsnprintf_s_l
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$_vsnprintf_s DD imagerel $LN3
	DD	imagerel $LN3+73
	DD	imagerel $unwind$_vsnprintf_s
pdata	ENDS
pdata	SEGMENT
$pdata$DebuggerTrace DD imagerel DebuggerTrace
	DD	imagerel DebuggerTrace+247
	DD	imagerel $unwind$DebuggerTrace
$pdata$calloc_aligned DD imagerel calloc_aligned
	DD	imagerel calloc_aligned+81
	DD	imagerel $unwind$calloc_aligned
$pdata$release_config DD imagerel $LN31
	DD	imagerel $LN31+944
	DD	imagerel $unwind$release_config
$pdata$find_device_by_devnum DD imagerel $LN14
	DD	imagerel $LN14+417
	DD	imagerel $unwind$find_device_by_devnum
$pdata$find_device_by_subchan DD imagerel $LN10
	DD	imagerel $LN10+343
	DD	imagerel $unwind$find_device_by_subchan
$pdata$attach_device DD imagerel $LN18
	DD	imagerel $LN18+1778
	DD	imagerel $unwind$attach_device
$pdata$detach_device DD imagerel $LN5
	DD	imagerel $LN5+321
	DD	imagerel $unwind$detach_device
$pdata$define_device DD imagerel $LN7
	DD	imagerel $LN7+698
	DD	imagerel $unwind$define_device
$pdata$group_device DD imagerel $LN12
	DD	imagerel $LN12+438
	DD	imagerel $unwind$group_device
$pdata$free_group DD imagerel $LN11
	DD	imagerel $LN11+232
	DD	imagerel $unwind$free_group
$pdata$configure_cpu DD imagerel $LN12
	DD	imagerel $LN12+768
	DD	imagerel $unwind$configure_cpu
$pdata$deconfigure_cpu DD imagerel $LN18
	DD	imagerel $LN18+710
	DD	imagerel $unwind$deconfigure_cpu
$pdata$configure_numcpu DD imagerel $LN4
	DD	imagerel $LN4+78
	DD	imagerel $unwind$configure_numcpu
$pdata$configure_maxcpu DD imagerel $LN6
	DD	imagerel $LN6+184
	DD	imagerel $unwind$configure_maxcpu
$pdata$configure_storage DD imagerel $LN25
	DD	imagerel $LN25+1368
	DD	imagerel $unwind$configure_storage
$pdata$configure_xstorage DD imagerel $LN13
	DD	imagerel $LN13+772
	DD	imagerel $unwind$configure_xstorage
$pdata$configure_shrdport DD imagerel $LN11
	DD	imagerel $LN11+786
	DD	imagerel $unwind$configure_shrdport
$pdata$parse_and_attach_devices DD imagerel $LN23
	DD	imagerel $LN23+870
	DD	imagerel $unwind$parse_and_attach_devices
$pdata$parse_single_devnum DD imagerel $LN3
	DD	imagerel $LN3+57
	DD	imagerel $unwind$parse_single_devnum
$pdata$parse_single_devnum_silent DD imagerel $LN3
	DD	imagerel $LN3+57
	DD	imagerel $unwind$parse_single_devnum_silent
$pdata$parse_devnums DD imagerel $LN29
	DD	imagerel $LN29+1725
	DD	imagerel $unwind$parse_devnums
$pdata$readlogo DD imagerel $LN7
	DD	imagerel $LN7+376
	DD	imagerel $unwind$readlogo
$pdata$clearlogo DD imagerel $LN7
	DD	imagerel $LN7+140
	DD	imagerel $unwind$clearlogo
$pdata$parse_conkpalv DD imagerel $LN29
	DD	imagerel $LN29+1056
	DD	imagerel $unwind$parse_conkpalv
$pdata$is_diag_instr DD imagerel $LN8
	DD	imagerel $LN8+130
	DD	imagerel $unwind$is_diag_instr
$pdata$are_cpu_thread DD imagerel $LN9
	DD	imagerel $LN9+142
	DD	imagerel $unwind$are_cpu_thread
$pdata$wakeup_cpu DD imagerel wakeup_cpu
	DD	imagerel wakeup_cpu+44
	DD	imagerel $unwind$wakeup_cpu
$pdata$Interrupt_Lock_Obtained DD imagerel Interrupt_Lock_Obtained
	DD	imagerel Interrupt_Lock_Obtained+269
	DD	imagerel $unwind$Interrupt_Lock_Obtained
$pdata$Obtain_Interrupt_Lock DD imagerel Obtain_Interrupt_Lock
	DD	imagerel Obtain_Interrupt_Lock+88
	DD	imagerel $unwind$Obtain_Interrupt_Lock
$pdata$Release_Interrupt_Lock DD imagerel Release_Interrupt_Lock
	DD	imagerel Release_Interrupt_Lock+71
	DD	imagerel $unwind$Release_Interrupt_Lock
$pdata$are_any_cpus_started_intlock_held DD imagerel are_any_cpus_started_intlock_held
	DD	imagerel are_any_cpus_started_intlock_held+118
	DD	imagerel $unwind$are_any_cpus_started_intlock_held
$pdata$are_all_cpus_stopped_intlock_held DD imagerel are_all_cpus_stopped_intlock_held
	DD	imagerel are_all_cpus_stopped_intlock_held+118
	DD	imagerel $unwind$are_all_cpus_stopped_intlock_held
$pdata$are_any_cpus_started DD imagerel are_any_cpus_started
	DD	imagerel are_any_cpus_started+51
	DD	imagerel $unwind$are_any_cpus_started
$pdata$configure_region_reloc DD imagerel configure_region_reloc
	DD	imagerel configure_region_reloc+659
	DD	imagerel $unwind$configure_region_reloc
$pdata$AddDevnumFastLookup DD imagerel AddDevnumFastLookup
	DD	imagerel AddDevnumFastLookup+303
	DD	imagerel $unwind$AddDevnumFastLookup
$pdata$AddSubchanFastLookup DD imagerel AddSubchanFastLookup
	DD	imagerel AddSubchanFastLookup+302
	DD	imagerel $unwind$AddSubchanFastLookup
$pdata$DelDevnumFastLookup DD imagerel DelDevnumFastLookup
	DD	imagerel DelDevnumFastLookup+136
	DD	imagerel $unwind$DelDevnumFastLookup
$pdata$DelSubchanFastLookup DD imagerel DelSubchanFastLookup
	DD	imagerel DelSubchanFastLookup+135
	DD	imagerel $unwind$DelSubchanFastLookup
$pdata$get_devblk DD imagerel get_devblk
	DD	imagerel get_devblk+2186
	DD	imagerel $unwind$get_devblk
$pdata$ret_devblk DD imagerel ret_devblk
	DD	imagerel ret_devblk+77
	DD	imagerel $unwind$ret_devblk
$pdata$detach_devblk DD imagerel detach_devblk
	DD	imagerel detach_devblk+781
	DD	imagerel $unwind$detach_devblk
$pdata$detach_subchan DD imagerel detach_subchan
	DD	imagerel detach_subchan+450
	DD	imagerel $unwind$detach_subchan
$pdata$shrd_devinit DD imagerel shrd_devinit
	DD	imagerel shrd_devinit+50
	DD	imagerel $unwind$shrd_devinit
$pdata$configure_numcpu_intlock_held DD imagerel configure_numcpu_intlock_held
	DD	imagerel configure_numcpu_intlock_held+265
	DD	imagerel $unwind$configure_numcpu_intlock_held
$pdata$parse_lcss DD imagerel parse_lcss
	DD	imagerel parse_lcss+795
	DD	imagerel $unwind$parse_lcss
$pdata$parse_single_devnum_INTERNAL DD imagerel parse_single_devnum_INTERNAL
	DD	imagerel parse_single_devnum_INTERNAL+518
	DD	imagerel $unwind$parse_single_devnum_INTERNAL
pdata	ENDS
_DATA	SEGMENT
$SG158966 DB	'C:\papa\MyGit\hyperion-zvector\hinlines.h:534', 00H
	ORG $+2
$SG158967 DB	'C:\papa\MyGit\hyperion-zvector\hinlines.h:538', 00H
	ORG $+2
config_mfree DQ	000000000c800000H
$SG190042 DB	'configure_storage( %s )', 00H
$SG190043 DB	'S', 00H
	ORG $+2
$SG190083 DB	'S', 00H
	ORG $+2
$SG190044 DB	'HHC01430%s Error in function %s: %s', 0aH, 00H
	ORG $+3
$SG190045 DB	'configure_storage', 00H
	ORG $+2
$SG190199 DB	'E', 00H
	ORG $+2
$SG190046 DB	'C:\papa\MyGit\hyperion-zvector\config.c', 00H
$SG190082 DB	'configure_xstorage(%s)', 00H
	ORG $+1
$SG190084 DB	'HHC01430%s Error in function %s: %s', 0aH, 00H
	ORG $+3
$SG190085 DB	'configure_xstorage', 00H
	ORG $+1
$SG190247 DB	'I', 00H
	ORG $+2
$SG190086 DB	'C:\papa\MyGit\hyperion-zvector\config.c', 00H
$SG190105 DB	'C:\papa\MyGit\hyperion-zvector\config.c:549', 00H
$SG190270 DB	'E', 00H
	ORG $+2
$SG190109 DB	'C:\papa\MyGit\hyperion-zvector\config.c:564', 00H
$SG190311 DB	'I', 00H
	ORG $+2
$SG190127 DB	'C:\papa\MyGit\hyperion-zvector\config.c:574', 00H
$SG190318 DB	'I', 00H
	ORG $+2
$SG190131 DB	'C:\papa\MyGit\hyperion-zvector\config.c:589', 00H
$SG190322 DB	'I', 00H
	ORG $+2
$SG190198 DB	'calloc(%d)', 00H
	ORG $+1
$SG190349 DB	'E', 00H
	ORG $+2
$SG190200 DB	'HHC01460%s %1d:%04X error in function %s: %s', 0aH, 00H
	ORG $+2
$SG190201 DB	'get_devblk', 00H
	ORG $+1
$SG190359 DB	'E', 00H
	ORG $+2
$SG190202 DB	'C:\papa\MyGit\hyperion-zvector\config.c', 00H
$SG190203 DB	'END ', 00H
	ORG $+3
$SG190204 DB	'DEVBLK', 00H
	ORG $+1
$SG190205 DB	'DEVBLK', 00H
	ORG $+1
$SG190206 DB	'SDL 4.00', 00H
	ORG $+3
$SG190368 DB	'E', 00H
	ORG $+2
$SG190207 DB	'C:\papa\MyGit\hyperion-zvector\config.c:658', 00H
$SG190404 DB	'E', 00H
	ORG $+2
$SG190208 DB	'&dev->lock', 00H
	ORG $+1
$SG190409 DB	'I', 00H
	ORG $+2
$SG190209 DB	'C:\papa\MyGit\hyperion-zvector\config.c:659', 00H
$SG190516 DB	'E', 00H
	ORG $+2
$SG190210 DB	'C:\papa\MyGit\hyperion-zvector\config.c:661', 00H
$SG190522 DB	'E', 00H
	ORG $+2
$SG190211 DB	'C:\papa\MyGit\hyperion-zvector\config.c:664', 00H
$SG190532 DB	'E', 00H
	ORG $+2
$SG190212 DB	'C:\papa\MyGit\hyperion-zvector\config.c:682', 00H
$SG190542 DB	'E', 00H
	ORG $+2
$SG190213 DB	'&dev->lock %1d:%04X', 00H
$SG190552 DB	'I', 00H
	ORG $+2
$SG190219 DB	'C:\papa\MyGit\hyperion-zvector\config.c:764', 00H
$SG190568 DB	'E', 00H
	ORG $+2
$SG190241 DB	'C:\papa\MyGit\hyperion-zvector\config.c:790', 00H
$SG190589 DB	'E', 00H
	ORG $+2
$SG190248 DB	'HHC01465%s %1d:%04X %s detached', 0aH, 00H
	ORG $+3
$SG190536 DB	'device', 00H
	ORG $+1
$SG190595 DB	'E', 00H
	ORG $+2
$SG190249 DB	'detach_devblk', 00H
	ORG $+2
$SG190250 DB	'C:\papa\MyGit\hyperion-zvector\config.c', 00H
$SG190268 DB	'subchannel %1d:%04X', 00H
$SG190700 DB	':', 00H
	ORG $+2
$SG190271 DB	'HHC01464%s %1d:%04X %s does not exist', 0aH, 00H
	ORG $+1
$SG190272 DB	'detach_subchan', 00H
	ORG $+1
$SG190273 DB	'C:\papa\MyGit\hyperion-zvector\config.c', 00H
$SG190274 DB	'C:\papa\MyGit\hyperion-zvector\config.c:858', 00H
$SG190702 DB	'E', 00H
	ORG $+2
$SG190276 DB	'group subchannel %1d:%04X', 00H
	ORG $+2
$SG190546 DB	'device', 00H
	ORG $+1
$SG190707 DB	':', 00H
	ORG $+2
$SG190277 DB	'C:\papa\MyGit\hyperion-zvector\config.c:865', 00H
$SG190708 DB	':', 00H
	ORG $+2
$SG190296 DB	'C:\papa\MyGit\hyperion-zvector\config.c:881', 00H
$SG190711 DB	'E', 00H
	ORG $+2
$SG190298 DB	'C:\papa\MyGit\hyperion-zvector\config.c:885', 00H
$SG190717 DB	'E', 00H
	ORG $+2
$SG190305 DB	'C:\papa\MyGit\hyperion-zvector\config.c:908', 00H
$SG190723 DB	'E', 00H
	ORG $+2
$SG190306 DB	'C:\papa\MyGit\hyperion-zvector\config.c:910', 00H
$SG190758 DB	'E', 00H
	ORG $+2
$SG190307 DB	'C:\papa\MyGit\hyperion-zvector\config.c:911', 00H
$SG190309 DB	'not ', 00H
	ORG $+3
$SG190310 DB	'Main', 00H
	ORG $+3
$SG190566 DB	'device', 00H
	ORG $+1
$SG190813 DB	',', 00H
	ORG $+2
$SG190312 DB	'HHC01427%s %s storage %sreleased', 0aH, 00H
	ORG $+2
$SG190588 DB	'device', 00H
	ORG $+1
$SG190820 DB	'E', 00H
	ORG $+2
$SG190313 DB	'release_config', 00H
	ORG $+1
$SG190314 DB	'C:\papa\MyGit\hyperion-zvector\config.c', 00H
$SG190316 DB	'not ', 00H
	ORG $+3
$SG190317 DB	'Expanded', 00H
	ORG $+3
$SG190827 DB	'E', 00H
	ORG $+2
$SG190319 DB	'HHC01427%s %s storage %sreleased', 0aH, 00H
	ORG $+2
$SG190833 DB	'E', 00H
	ORG $+2
$SG190320 DB	'release_config', 00H
	ORG $+1
$SG190321 DB	'C:\papa\MyGit\hyperion-zvector\config.c', 00H
$SG190323 DB	'HHC01422%s Configuration released', 0aH, 00H
	ORG $+1
$SG190838 DB	'E', 00H
	ORG $+2
$SG190324 DB	'release_config', 00H
	ORG $+1
$SG190325 DB	'C:\papa\MyGit\hyperion-zvector\config.c', 00H
$SG190346 DB	'C:\papa\MyGit\hyperion-zvector\config.c:945', 00H
$SG190847 DB	'E', 00H
	ORG $+2
$SG190348 DB	'C:\papa\MyGit\hyperion-zvector\config.c:949', 00H
$SG190855 DB	'E', 00H
	ORG $+2
$SG190350 DB	'HHC00744%s Shared: Server already active', 0aH, 00H
	ORG $+2
$SG190859 DB	',', 00H
	ORG $+2
$SG190351 DB	'configure_shrdport', 00H
	ORG $+1
$SG190906 DB	'CUU', 00H
$SG190352 DB	'C:\papa\MyGit\hyperion-zvector\config.c', 00H
$SG190354 DB	'C:\papa\MyGit\hyperion-zvector\config.c:962', 00H
$SG190910 DB	'%d', 00H
	ORG $+1
$SG190355 DB	'C:\papa\MyGit\hyperion-zvector\config.c:968', 00H
$SG190911 DB	'CSS', 00H
$SG190356 DB	'shared_server', 00H
	ORG $+2
$SG190358 DB	'C:\papa\MyGit\hyperion-zvector\config.c:972', 00H
$SG190937 DB	'r', 00H
	ORG $+2
$SG190360 DB	'HHC00102%s Error in function create_thread(): %s', 0aH, 00H
	ORG $+6
$SG190361 DB	'configure_shrdport', 00H
	ORG $+5
$SG190362 DB	'C:\papa\MyGit\hyperion-zvector\config.c', 00H
$SG190363 DB	'C:\papa\MyGit\hyperion-zvector\config.c:978', 00H
	ORG $+4
$SG190365 DB	'C:\papa\MyGit\hyperion-zvector\config.c:986', 00H
	ORG $+4
$SG190366 DB	'shrd_devinit', 00H
	ORG $+3
$SG190369 DB	'HHC00102%s Error in function create_thread(): %s', 0aH, 00H
	ORG $+6
$SG190370 DB	'configure_shrdport', 00H
	ORG $+5
$SG190371 DB	'C:\papa\MyGit\hyperion-zvector\config.c', 00H
$SG190401 DB	'Processor %s%02X', 00H
	ORG $+7
$SG190402 DB	'C:\papa\MyGit\hyperion-zvector\config.c:1066', 00H
	ORG $+3
$SG190405 DB	'HHC00102%s Error in function create_thread(): %s', 0aH, 00H
	ORG $+6
$SG190406 DB	'configure_cpu', 00H
	ORG $+2
$SG190407 DB	'C:\papa\MyGit\hyperion-zvector\config.c', 00H
$SG190410 DB	'HHC00111%s Thread CPU Time IS available (_POSIX_THREAD_C'
	DB	'PUTIME=%d)', 0aH, 00H
	ORG $+4
$SG190411 DB	'configure_cpu', 00H
	ORG $+2
$SG190412 DB	'C:\papa\MyGit\hyperion-zvector\config.c', 00H
$SG190414 DB	'C:\papa\MyGit\hyperion-zvector\config.c:1097', 00H
	ORG $+3
$SG190439 DB	'C:\papa\MyGit\hyperion-zvector\config.c:1136', 00H
	ORG $+3
$SG190441 DB	'C:\papa\MyGit\hyperion-zvector\config.c:1144', 00H
	ORG $+3
$SG190443 DB	'C:\papa\MyGit\hyperion-zvector\config.c:1151', 00H
	ORG $+3
$SG190444 DB	'C:\papa\MyGit\hyperion-zvector\config.c:1152', 00H
	ORG $+3
$SG190469 DB	'C:\papa\MyGit\hyperion-zvector\config.c:1234', 00H
	ORG $+3
$SG190471 DB	'C:\papa\MyGit\hyperion-zvector\config.c:1242', 00H
	ORG $+3
$SG190480 DB	'C:\papa\MyGit\hyperion-zvector\config.c:1253', 00H
	ORG $+3
$SG190482 DB	'C:\papa\MyGit\hyperion-zvector\config.c:1258', 00H
	ORG $+3
$SG190484 DB	'C:\papa\MyGit\hyperion-zvector\config.c:1265', 00H
	ORG $+3
$SG190486 DB	'C:\papa\MyGit\hyperion-zvector\config.c:1279', 00H
	ORG $+3
$SG190514 DB	'C:\papa\MyGit\hyperion-zvector\config.c:1295', 00H
	ORG $+3
$SG190517 DB	'HHC01461%s %1d:%04X device already exists', 0aH, 00H
	ORG $+5
$SG190518 DB	'attach_device', 00H
	ORG $+2
$SG190519 DB	'C:\papa\MyGit\hyperion-zvector\config.c', 00H
$SG190520 DB	'C:\papa\MyGit\hyperion-zvector\config.c:1302', 00H
	ORG $+3
$SG190523 DB	'HHC01462%s %1d:%04X devtype %s not recognized', 0aH, 00H
	ORG $+1
$SG190524 DB	'attach_device', 00H
	ORG $+2
$SG190525 DB	'C:\papa\MyGit\hyperion-zvector\config.c', 00H
$SG190526 DB	'C:\papa\MyGit\hyperion-zvector\config.c:1321', 00H
	ORG $+3
$SG190533 DB	'HHC01463%s %1d:%04X device initialization failed', 0aH, 00H
	ORG $+6
$SG190534 DB	'attach_device', 00H
	ORG $+2
$SG190535 DB	'C:\papa\MyGit\hyperion-zvector\config.c', 00H
$SG190537 DB	'C:\papa\MyGit\hyperion-zvector\config.c:1355', 00H
	ORG $+3
$SG190541 DB	'malloc(%lu)', 00H
	ORG $+4
$SG190543 DB	'HHC01460%s %1d:%04X error in function %s: %s', 0aH, 00H
	ORG $+2
$SG190544 DB	'attach_device', 00H
	ORG $+2
$SG190545 DB	'C:\papa\MyGit\hyperion-zvector\config.c', 00H
$SG190547 DB	'C:\papa\MyGit\hyperion-zvector\config.c:1384', 00H
	ORG $+3
$SG190548 DB	'C:\papa\MyGit\hyperion-zvector\config.c:1390', 00H
	ORG $+3
$SG190550 DB	'C:\papa\MyGit\hyperion-zvector\config.c:1408', 00H
	ORG $+3
$SG190553 DB	'HHC02198%s Device %04X type %04X subchannel %d:%04X atta'
	DB	'ched', 0aH, 00H
	ORG $+2
$SG190554 DB	'attach_device', 00H
	ORG $+2
$SG190555 DB	'C:\papa\MyGit\hyperion-zvector\config.c', 00H
$SG190569 DB	'HHC01464%s %1d:%04X %s does not exist', 0aH, 00H
	ORG $+1
$SG190570 DB	'detach_device', 00H
	ORG $+2
$SG190571 DB	'C:\papa\MyGit\hyperion-zvector\config.c', 00H
$SG190572 DB	'C:\papa\MyGit\hyperion-zvector\config.c:1438', 00H
	ORG $+3
$SG190574 DB	'group device', 00H
	ORG $+3
$SG190575 DB	'C:\papa\MyGit\hyperion-zvector\config.c:1445', 00H
	ORG $+3
$SG190586 DB	'C:\papa\MyGit\hyperion-zvector\config.c:1458', 00H
	ORG $+3
$SG190590 DB	'HHC01464%s %1d:%04X %s does not exist', 0aH, 00H
	ORG $+1
$SG190591 DB	'define_device', 00H
	ORG $+2
$SG190592 DB	'C:\papa\MyGit\hyperion-zvector\config.c', 00H
$SG190593 DB	'C:\papa\MyGit\hyperion-zvector\config.c:1466', 00H
	ORG $+3
$SG190596 DB	'HHC01461%s %1d:%04X device already exists', 0aH, 00H
	ORG $+5
$SG190597 DB	'define_device', 00H
	ORG $+2
$SG190598 DB	'C:\papa\MyGit\hyperion-zvector\config.c', 00H
$SG190599 DB	'C:\papa\MyGit\hyperion-zvector\config.c:1474', 00H
	ORG $+3
$SG190601 DB	'C:\papa\MyGit\hyperion-zvector\config.c:1487', 00H
	ORG $+3
$SG190602 DB	'C:\papa\MyGit\hyperion-zvector\config.c:1500', 00H
	ORG $+3
$SG190604 DB	'C:\papa\MyGit\hyperion-zvector\config.c:1512', 00H
	ORG $+3
$SG190705 DB	'C:\papa\MyGit\hyperion-zvector\config.c', 00H
$SG190703 DB	'HHC01466%s Unspecified error occured while parsing Logic'
	DB	'al Channel Subsystem Identification', 0aH, 00H
	ORG $+3
$SG190704 DB	'parse_lcss', 00H
	ORG $+5
$SG190712 DB	'HHC01467%s No more than 1 Logical Channel Subsystem Iden'
	DB	'tification may be specified', 0aH, 00H
	ORG $+3
$SG190713 DB	'parse_lcss', 00H
	ORG $+5
$SG190714 DB	'C:\papa\MyGit\hyperion-zvector\config.c', 00H
$SG190718 DB	'HHC01468%s Non-numeric Logical Channel Subsystem Identif'
	DB	'ication %s', 0aH, 00H
	ORG $+4
$SG190719 DB	'parse_lcss', 00H
	ORG $+5
$SG190720 DB	'C:\papa\MyGit\hyperion-zvector\config.c', 00H
$SG190724 DB	'HHC01469%s Logical Channel Subsystem Identification %d e'
	DB	'xceeds maximum of %d', 0aH, 00H
	ORG $+2
$SG190725 DB	'parse_lcss', 00H
	ORG $+5
$SG190726 DB	'C:\papa\MyGit\hyperion-zvector\config.c', 00H
$SG190749 DB	'sysg', 00H
	ORG $+3
$SG190757 DB	'device address specification', 00H
	ORG $+3
$SG190759 DB	'HHC01470%s Incorrect %s near character ''%c''', 0aH, 00H
	ORG $+3
$SG190760 DB	'parse_single_devnum_INTERNAL', 00H
	ORG $+3
$SG190761 DB	'C:\papa\MyGit\hyperion-zvector\config.c', 00H
$SG190819 DB	'second device number in device range', 00H
	ORG $+3
$SG190821 DB	'HHC01470%s Incorrect %s near character ''%c''', 0aH, 00H
	ORG $+3
$SG190822 DB	'parse_devnums', 00H
	ORG $+2
$SG190823 DB	'C:\papa\MyGit\hyperion-zvector\config.c', 00H
$SG190826 DB	'device count', 00H
	ORG $+3
$SG190828 DB	'HHC01470%s Incorrect %s near character ''%c''', 0aH, 00H
	ORG $+3
$SG190829 DB	'parse_devnums', 00H
	ORG $+2
$SG190830 DB	'C:\papa\MyGit\hyperion-zvector\config.c', 00H
$SG190832 DB	'device specification', 00H
	ORG $+3
$SG190834 DB	'HHC01470%s Incorrect %s near character ''%c''', 0aH, 00H
	ORG $+3
$SG190835 DB	'parse_devnums', 00H
	ORG $+2
$SG190836 DB	'C:\papa\MyGit\hyperion-zvector\config.c', 00H
$SG190839 DB	'HHC01471%s Incorrect device address range %04X < %04X', 0aH
	DB	00H
	ORG $+1
$SG190840 DB	'parse_devnums', 00H
	ORG $+2
$SG190841 DB	'C:\papa\MyGit\hyperion-zvector\config.c', 00H
$SG190848 DB	'HHC01472%s %1d:%04X is on wrong channel, 1st device defi'
	DB	'ned on channel %02X', 0aH, 00H
	ORG $+3
$SG190849 DB	'parse_devnums', 00H
	ORG $+2
$SG190850 DB	'C:\papa\MyGit\hyperion-zvector\config.c', 00H
$SG190858 DB	'C:\papa\MyGit\hyperion-zvector\config.c', 00H
$SG190856 DB	'HHC01473%s Some or all devices in %04X-%04X duplicate al'
	DB	'ready defined devices', 0aH, 00H
	ORG $+1
$SG190857 DB	'parse_devnums', 00H
	ORG $+2
$SG190905 DB	'%3.3X', 00H
	ORG $+2
$SG190907 DB	'%4.4X', 00H
	ORG $+2
$SG190908 DB	'CCUU', 00H
	ORG $+3
$SG190909 DB	'DEVN', 00H
	ORG $+3
$SG190962 DB	'parse_conkpalv', 00H
	ORG $+1
$SG190963 DB	'C:\papa\MyGit\hyperion-zvector\config.c', 00H
$SG190967 DB	'C:\papa\MyGit\hyperion-zvector\config.c', 00H
$SG190964 DB	'%s(%d) : warning HHC90999W : *** Assertion Failed! *** f'
	DB	'unction: %s', 0aH, 00H
	ORG $+3
$SG190966 DB	'parse_conkpalv', 00H
	ORG $+9
$SG190968 DB	'%s(%d) : warning HHC90999W : *** Assertion Failed! *** f'
	DB	'unction: %s', 0aH, 00H
	ORG $+3
$SG190976 DB	'0123456789', 00H
	ORG $+5
$SG190979 DB	'0123456789', 00H
	ORG $+5
$SG190982 DB	'0123456789', 00H
_DATA	ENDS
voltbl	SEGMENT
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:detach_subchan
	DD	021H
	DD	01aaH
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:get_devblk
	DD	01cH
	DD	0871H
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:readlogo
	DD	016H
	DD	0160H
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:parse_and_attach_devices
	DD	025H
	DD	034eH
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:configure_xstorage
	DD	016H
	DD	02ecH
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:configure_storage
	DD	016H
	DD	0540H
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:configure_cpu
	DD	015H
	DD	02ebH
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:attach_device
	DD	025H
	DD	06daH
voltbl	ENDS
xdata	SEGMENT
$unwind$DebuggerTrace DD 011801H
	DD	0a218H
$unwind$calloc_aligned DD 020f01H
	DD	0700b520fH
$unwind$release_config DD 020c01H
	DD	011010cH
$unwind$find_device_by_devnum DD 010e01H
	DD	0820eH
$unwind$find_device_by_subchan DD 010801H
	DD	06208H
$unwind$attach_device DD 022d19H
	DD	023011bH
	DD	imagerel __GSHandlerCheck
	DD	0100H
$unwind$detach_device DD 010e01H
	DD	0e20eH
$unwind$define_device DD 011401H
	DD	0e214H
$unwind$group_device DD 020e01H
	DD	0700a720eH
$unwind$free_group DD 011701H
	DD	08217H
$unwind$configure_cpu DD 021a19H
	DD	011010bH
	DD	imagerel __GSHandlerCheck
	DD	078H
$unwind$deconfigure_cpu DD 010801H
	DD	06208H
$unwind$configure_numcpu DD 010801H
	DD	06208H
$unwind$configure_maxcpu DD 010801H
	DD	06208H
$unwind$configure_storage DD 021e19H
	DD	027010cH
	DD	imagerel __GSHandlerCheck
	DD	0120H
$unwind$configure_xstorage DD 021e19H
	DD	021010cH
	DD	imagerel __GSHandlerCheck
	DD	0f0H
$unwind$configure_shrdport DD 010901H
	DD	0c209H
$unwind$parse_and_attach_devices DD 022d19H
	DD	017011bH
	DD	imagerel __GSHandlerCheck
	DD	0a8H
$unwind$parse_single_devnum DD 011301H
	DD	06213H
$unwind$parse_single_devnum_silent DD 011301H
	DD	06213H
$unwind$parse_devnums DD 021101H
	DD	01b0111H
$unwind$readlogo DD 021e19H
	DD	02b010cH
	DD	imagerel __GSHandlerCheck
	DD	0140H
$unwind$clearlogo DD 010401H
	DD	06204H
$unwind$parse_conkpalv DD 011801H
	DD	0c218H
$unwind$is_diag_instr DD 010401H
	DD	08204H
$unwind$are_cpu_thread DD 010901H
	DD	06209H
$unwind$wakeup_cpu DD 010e01H
	DD	0420eH
$unwind$Interrupt_Lock_Obtained DD 010e01H
	DD	0420eH
$unwind$Obtain_Interrupt_Lock DD 010e01H
	DD	0420eH
$unwind$Release_Interrupt_Lock DD 010e01H
	DD	0420eH
$unwind$are_any_cpus_started_intlock_held DD 010401H
	DD	02204H
$unwind$are_all_cpus_stopped_intlock_held DD 010401H
	DD	02204H
$unwind$are_any_cpus_started DD 010401H
	DD	06204H
$unwind$configure_region_reloc DD 010401H
	DD	04204H
$unwind$AddDevnumFastLookup DD 011401H
	DD	06214H
$unwind$AddSubchanFastLookup DD 011401H
	DD	06214H
$unwind$DelDevnumFastLookup DD 010e01H
	DD	0220eH
$unwind$DelSubchanFastLookup DD 010e01H
	DD	0220eH
$unwind$get_devblk DD 032419H
	DD	01a0112H
	DD	0700bH
	DD	imagerel __GSHandlerCheck
	DD	0c0H
$unwind$ret_devblk DD 010901H
	DD	04209H
$unwind$detach_devblk DD 011701H
	DD	0e217H
$unwind$detach_subchan DD 022919H
	DD	0190117H
	DD	imagerel __GSHandlerCheck
	DD	0b0H
$unwind$shrd_devinit DD 010901H
	DD	06209H
$unwind$configure_numcpu_intlock_held DD 010801H
	DD	06208H
$unwind$parse_lcss DD 021601H
	DD	0130116H
$unwind$parse_single_devnum_INTERNAL DD 011801H
	DD	0e218H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$_vsnprintf_s DD 011801H
	DD	06218H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$_vsnprintf_s_l DD 011801H
	DD	0a218H
xdata	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\config.c
_TEXT	SEGMENT
lcss$ = 80
rc$ = 84
err$1 = 88
tv130 = 92
strptr$ = 96
r$ = 104
spec$ = 128
p_lcss$ = 136
p_devnum$ = 144
verbose$ = 152
parse_single_devnum_INTERNAL PROC

; 1824 : {

  00000	44 89 4c 24 20	 mov	 DWORD PTR [rsp+32], r9d
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	48 83 ec 78	 sub	 rsp, 120		; 00000078H

; 1825 :     int     rc;
; 1826 :     U16     lcss;
; 1827 :     char    *r;
; 1828 :     char    *strptr;
; 1829 : 
; 1830 :     if ((rc = parse_lcss( spec, &r, verbose )) < 0)

  00018	44 8b 84 24 98
	00 00 00	 mov	 r8d, DWORD PTR verbose$[rsp]
  00020	48 8d 54 24 68	 lea	 rdx, QWORD PTR r$[rsp]
  00025	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR spec$[rsp]
  0002d	e8 00 00 00 00	 call	 parse_lcss
  00032	89 44 24 54	 mov	 DWORD PTR rc$[rsp], eax
  00036	83 7c 24 54 00	 cmp	 DWORD PTR rc$[rsp], 0
  0003b	7d 0a		 jge	 SHORT $LN4@parse_sing

; 1831 :         return -1;

  0003d	b8 ff ff ff ff	 mov	 eax, -1
  00042	e9 ba 01 00 00	 jmp	 $LN1@parse_sing
$LN4@parse_sing:

; 1832 : 
; 1833 :     lcss = rc;

  00047	0f b7 44 24 54	 movzx	 eax, WORD PTR rc$[rsp]
  0004c	66 89 44 24 50	 mov	 WORD PTR lcss$[rsp], ax

; 1834 : 
; 1835 :     if (str_caseless_eq( r, "sysg" ))

  00051	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG190749
  00058	48 8b 4c 24 68	 mov	 rcx, QWORD PTR r$[rsp]
  0005d	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__stricmp
  00063	85 c0		 test	 eax, eax
  00065	75 2f		 jne	 SHORT $LN5@parse_sing

; 1836 :     {
; 1837 :         *p_devnum = 0;

  00067	33 c0		 xor	 eax, eax
  00069	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR p_devnum$[rsp]
  00071	66 89 01	 mov	 WORD PTR [rcx], ax

; 1838 :         *p_lcss   = lcss;

  00074	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR p_lcss$[rsp]
  0007c	0f b7 4c 24 50	 movzx	 ecx, WORD PTR lcss$[rsp]
  00081	66 89 08	 mov	 WORD PTR [rax], cx

; 1839 :         free( r );

  00084	48 8b 4c 24 68	 mov	 rcx, QWORD PTR r$[rsp]
  00089	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free

; 1840 :         return 0;

  0008f	33 c0		 xor	 eax, eax
  00091	e9 6b 01 00 00	 jmp	 $LN1@parse_sing
$LN5@parse_sing:

; 1841 :     }
; 1842 : 
; 1843 :     rc = strtoul( r, &strptr, 16 );

  00096	41 b8 10 00 00
	00		 mov	 r8d, 16
  0009c	48 8d 54 24 60	 lea	 rdx, QWORD PTR strptr$[rsp]
  000a1	48 8b 4c 24 68	 mov	 rcx, QWORD PTR r$[rsp]
  000a6	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_strtoul
  000ac	89 44 24 54	 mov	 DWORD PTR rc$[rsp], eax

; 1844 : 
; 1845 :     if (0
; 1846 :         || rc < 0
; 1847 :         || rc > 0xffff
; 1848 :         || *strptr != 0

  000b0	33 c0		 xor	 eax, eax
  000b2	85 c0		 test	 eax, eax
  000b4	75 21		 jne	 SHORT $LN7@parse_sing
  000b6	83 7c 24 54 00	 cmp	 DWORD PTR rc$[rsp], 0
  000bb	7c 1a		 jl	 SHORT $LN7@parse_sing
  000bd	81 7c 24 54 ff
	ff 00 00	 cmp	 DWORD PTR rc$[rsp], 65535 ; 0000ffffH
  000c5	7f 10		 jg	 SHORT $LN7@parse_sing
  000c7	48 8b 44 24 60	 mov	 rax, QWORD PTR strptr$[rsp]
  000cc	0f be 00	 movsx	 eax, BYTE PTR [rax]
  000cf	85 c0		 test	 eax, eax
  000d1	0f 84 fd 00 00
	00		 je	 $LN6@parse_sing
$LN7@parse_sing:

; 1849 :     )
; 1850 :     {
; 1851 :         int err = 1;

  000d7	c7 44 24 58 01
	00 00 00	 mov	 DWORD PTR err$1[rsp], 1

; 1852 : 
; 1853 :         /* Maybe it's just a statement comment? */
; 1854 :         if (1
; 1855 :             && rc >= 0
; 1856 :             && rc <= 0xffff
; 1857 :             && *strptr != 0

  000df	33 c0		 xor	 eax, eax
  000e1	83 f8 01	 cmp	 eax, 1
  000e4	74 60		 je	 SHORT $LN8@parse_sing
  000e6	83 7c 24 54 00	 cmp	 DWORD PTR rc$[rsp], 0
  000eb	7c 59		 jl	 SHORT $LN8@parse_sing
  000ed	81 7c 24 54 ff
	ff 00 00	 cmp	 DWORD PTR rc$[rsp], 65535 ; 0000ffffH
  000f5	7f 4f		 jg	 SHORT $LN8@parse_sing
  000f7	48 8b 44 24 60	 mov	 rax, QWORD PTR strptr$[rsp]
  000fc	0f be 00	 movsx	 eax, BYTE PTR [rax]
  000ff	85 c0		 test	 eax, eax
  00101	74 43		 je	 SHORT $LN8@parse_sing
$LN2@parse_sing:

; 1858 :         )
; 1859 :         {
; 1860 :             while (*strptr == ' ')

  00103	48 8b 44 24 60	 mov	 rax, QWORD PTR strptr$[rsp]
  00108	0f be 00	 movsx	 eax, BYTE PTR [rax]
  0010b	83 f8 20	 cmp	 eax, 32			; 00000020H
  0010e	75 0f		 jne	 SHORT $LN3@parse_sing

; 1861 :                 strptr++;

  00110	48 8b 44 24 60	 mov	 rax, QWORD PTR strptr$[rsp]
  00115	48 ff c0	 inc	 rax
  00118	48 89 44 24 60	 mov	 QWORD PTR strptr$[rsp], rax
  0011d	eb e4		 jmp	 SHORT $LN2@parse_sing
$LN3@parse_sing:

; 1862 : 
; 1863 :             /* End of statement or start of comment? */
; 1864 :             if (0
; 1865 :                 || *strptr ==  0
; 1866 :                 || *strptr == '#'

  0011f	33 c0		 xor	 eax, eax
  00121	85 c0		 test	 eax, eax
  00123	75 19		 jne	 SHORT $LN10@parse_sing
  00125	48 8b 44 24 60	 mov	 rax, QWORD PTR strptr$[rsp]
  0012a	0f be 00	 movsx	 eax, BYTE PTR [rax]
  0012d	85 c0		 test	 eax, eax
  0012f	74 0d		 je	 SHORT $LN10@parse_sing
  00131	48 8b 44 24 60	 mov	 rax, QWORD PTR strptr$[rsp]
  00136	0f be 00	 movsx	 eax, BYTE PTR [rax]
  00139	83 f8 23	 cmp	 eax, 35			; 00000023H
  0013c	75 08		 jne	 SHORT $LN9@parse_sing
$LN10@parse_sing:

; 1867 :             )
; 1868 :                 err = 0;  /* Then not an error! */

  0013e	c7 44 24 58 00
	00 00 00	 mov	 DWORD PTR err$1[rsp], 0
$LN9@parse_sing:
$LN8@parse_sing:

; 1869 :         }
; 1870 : 
; 1871 :         if (err)

  00146	83 7c 24 58 00	 cmp	 DWORD PTR err$1[rsp], 0
  0014b	0f 84 83 00 00
	00		 je	 $LN11@parse_sing

; 1872 :         {
; 1873 :             if (verbose)

  00151	83 bc 24 98 00
	00 00 00	 cmp	 DWORD PTR verbose$[rsp], 0
  00159	74 67		 je	 SHORT $LN12@parse_sing

; 1874 :             {
; 1875 :                 // "Incorrect %s near character '%c'"
; 1876 :                 WRMSG( HHC01470, "E", "device address specification", *strptr );

  0015b	48 8b 44 24 60	 mov	 rax, QWORD PTR strptr$[rsp]
  00160	0f be 00	 movsx	 eax, BYTE PTR [rax]
  00163	89 44 24 5c	 mov	 DWORD PTR tv130[rsp], eax
  00167	b9 01 00 00 00	 mov	 ecx, 1
  0016c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  00172	8b 4c 24 5c	 mov	 ecx, DWORD PTR tv130[rsp]
  00176	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  0017a	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG190757
  00181	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  00186	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG190758
  0018d	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  00192	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG190759
  00199	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  0019e	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  001a3	41 b9 03 00 00
	00		 mov	 r9d, 3
  001a9	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG190760
  001b0	ba 54 07 00 00	 mov	 edx, 1876		; 00000754H
  001b5	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG190761
  001bc	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg
$LN12@parse_sing:

; 1877 :             }
; 1878 :             free( r );

  001c2	48 8b 4c 24 68	 mov	 rcx, QWORD PTR r$[rsp]
  001c7	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free

; 1879 :             return -1;

  001cd	b8 ff ff ff ff	 mov	 eax, -1
  001d2	eb 2d		 jmp	 SHORT $LN1@parse_sing
$LN11@parse_sing:
$LN6@parse_sing:

; 1880 :         }
; 1881 :     }
; 1882 : 
; 1883 :     *p_devnum = rc;

  001d4	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR p_devnum$[rsp]
  001dc	0f b7 4c 24 54	 movzx	 ecx, WORD PTR rc$[rsp]
  001e1	66 89 08	 mov	 WORD PTR [rax], cx

; 1884 :     *p_lcss   = lcss;

  001e4	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR p_lcss$[rsp]
  001ec	0f b7 4c 24 50	 movzx	 ecx, WORD PTR lcss$[rsp]
  001f1	66 89 08	 mov	 WORD PTR [rax], cx

; 1885 : 
; 1886 :     free( r );

  001f4	48 8b 4c 24 68	 mov	 rcx, QWORD PTR r$[rsp]
  001f9	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free

; 1887 :     return 0;

  001ff	33 c0		 xor	 eax, eax
$LN1@parse_sing:

; 1888 : }

  00201	48 83 c4 78	 add	 rsp, 120		; 00000078H
  00205	c3		 ret	 0
parse_single_devnum_INTERNAL ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\config.c
_TEXT	SEGMENT
lcssid$ = 80
wrk$ = 88
len$ = 96
strtok_str$ = 104
lcss$ = 112
r$ = 120
garbage$ = 128
strptr$ = 136
spec$ = 160
rest$ = 168
verbose$ = 176
parse_lcss PROC

; 1737 : {

  00000	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	48 81 ec 98 00
	00 00		 sub	 rsp, 152		; 00000098H

; 1738 :     int     lcssid;
; 1739 :     char*   wrk;
; 1740 :     char*   lcss;
; 1741 :     char*   r;
; 1742 :     char*   strptr;
; 1743 :     char*   garbage;
; 1744 :     char*   strtok_str = NULL;

  00016	48 c7 44 24 68
	00 00 00 00	 mov	 QWORD PTR strtok_str$[rsp], 0

; 1745 :     size_t  len;
; 1746 : 
; 1747 :     len = strlen( spec ) + 1;

  0001f	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR spec$[rsp]
  00027	e8 00 00 00 00	 call	 strlen
  0002c	48 ff c0	 inc	 rax
  0002f	48 89 44 24 60	 mov	 QWORD PTR len$[rsp], rax

; 1748 :     wrk = malloc( len );

  00034	48 8b 4c 24 60	 mov	 rcx, QWORD PTR len$[rsp]
  00039	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_malloc
  0003f	48 89 44 24 58	 mov	 QWORD PTR wrk$[rsp], rax

; 1749 :     strlcpy( wrk, spec, len );

  00044	4c 8b 44 24 60	 mov	 r8, QWORD PTR len$[rsp]
  00049	48 8b 94 24 a0
	00 00 00	 mov	 rdx, QWORD PTR spec$[rsp]
  00051	48 8b 4c 24 58	 mov	 rcx, QWORD PTR wrk$[rsp]
  00056	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_strlcpy

; 1750 : 
; 1751 :     if (!(lcss = strtok_r( wrk, ":", &strtok_str )))

  0005c	4c 8d 44 24 68	 lea	 r8, QWORD PTR strtok_str$[rsp]
  00061	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG190700
  00068	48 8b 4c 24 58	 mov	 rcx, QWORD PTR wrk$[rsp]
  0006d	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_strtok_r
  00073	48 89 44 24 70	 mov	 QWORD PTR lcss$[rsp], rax
  00078	48 83 7c 24 70
	00		 cmp	 QWORD PTR lcss$[rsp], 0
  0007e	75 66		 jne	 SHORT $LN2@parse_lcss

; 1752 :     {
; 1753 :         if (verbose)

  00080	83 bc 24 b0 00
	00 00 00	 cmp	 DWORD PTR verbose$[rsp], 0
  00088	74 47		 je	 SHORT $LN3@parse_lcss

; 1754 :         {
; 1755 :             // "Unspecified error occured while parsing Logical Channel Subsystem Identification"
; 1756 :             WRMSG( HHC01466, "E" );

  0008a	b9 01 00 00 00	 mov	 ecx, 1
  0008f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  00095	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG190702
  0009c	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  000a1	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG190703
  000a8	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  000ad	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  000b2	41 b9 03 00 00
	00		 mov	 r9d, 3
  000b8	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG190704
  000bf	ba dc 06 00 00	 mov	 edx, 1756		; 000006dcH
  000c4	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG190705
  000cb	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg
$LN3@parse_lcss:

; 1757 :         }
; 1758 :         free( wrk );

  000d1	48 8b 4c 24 58	 mov	 rcx, QWORD PTR wrk$[rsp]
  000d6	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free

; 1759 :         return -1;

  000dc	b8 ff ff ff ff	 mov	 eax, -1
  000e1	e9 2d 02 00 00	 jmp	 $LN1@parse_lcss
$LN2@parse_lcss:

; 1760 :     }
; 1761 : 
; 1762 : 
; 1763 :     if (!(r=strtok_r( NULL, ":", &strtok_str )))

  000e6	4c 8d 44 24 68	 lea	 r8, QWORD PTR strtok_str$[rsp]
  000eb	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG190707
  000f2	33 c9		 xor	 ecx, ecx
  000f4	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_strtok_r
  000fa	48 89 44 24 78	 mov	 QWORD PTR r$[rsp], rax
  000ff	48 83 7c 24 78
	00		 cmp	 QWORD PTR r$[rsp], 0
  00105	75 17		 jne	 SHORT $LN4@parse_lcss

; 1764 :     {
; 1765 :         *rest = wrk;

  00107	48 8b 84 24 a8
	00 00 00	 mov	 rax, QWORD PTR rest$[rsp]
  0010f	48 8b 4c 24 58	 mov	 rcx, QWORD PTR wrk$[rsp]
  00114	48 89 08	 mov	 QWORD PTR [rax], rcx

; 1766 :         return 0;

  00117	33 c0		 xor	 eax, eax
  00119	e9 f5 01 00 00	 jmp	 $LN1@parse_lcss
$LN4@parse_lcss:

; 1767 :     }
; 1768 : 
; 1769 :     garbage = strtok_r( NULL, ":", &strtok_str );

  0011e	4c 8d 44 24 68	 lea	 r8, QWORD PTR strtok_str$[rsp]
  00123	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG190708
  0012a	33 c9		 xor	 ecx, ecx
  0012c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_strtok_r
  00132	48 89 84 24 80
	00 00 00	 mov	 QWORD PTR garbage$[rsp], rax

; 1770 : 
; 1771 :     if (garbage)

  0013a	48 83 bc 24 80
	00 00 00 00	 cmp	 QWORD PTR garbage$[rsp], 0
  00143	74 66		 je	 SHORT $LN5@parse_lcss

; 1772 :     {
; 1773 :         if (verbose)

  00145	83 bc 24 b0 00
	00 00 00	 cmp	 DWORD PTR verbose$[rsp], 0
  0014d	74 47		 je	 SHORT $LN6@parse_lcss

; 1774 :         {
; 1775 :             // "No more than 1 Logical Channel Subsystem Identification may be specified"
; 1776 :             WRMSG( HHC01467, "E" );

  0014f	b9 01 00 00 00	 mov	 ecx, 1
  00154	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  0015a	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG190711
  00161	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  00166	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG190712
  0016d	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00172	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00177	41 b9 03 00 00
	00		 mov	 r9d, 3
  0017d	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG190713
  00184	ba f0 06 00 00	 mov	 edx, 1776		; 000006f0H
  00189	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG190714
  00190	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg
$LN6@parse_lcss:

; 1777 :         }
; 1778 :         free( wrk );

  00196	48 8b 4c 24 58	 mov	 rcx, QWORD PTR wrk$[rsp]
  0019b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free

; 1779 :         return -1;

  001a1	b8 ff ff ff ff	 mov	 eax, -1
  001a6	e9 68 01 00 00	 jmp	 $LN1@parse_lcss
$LN5@parse_lcss:

; 1780 :     }
; 1781 : 
; 1782 :     lcssid = strtoul( lcss, &strptr, 10 );

  001ab	41 b8 0a 00 00
	00		 mov	 r8d, 10
  001b1	48 8d 94 24 88
	00 00 00	 lea	 rdx, QWORD PTR strptr$[rsp]
  001b9	48 8b 4c 24 70	 mov	 rcx, QWORD PTR lcss$[rsp]
  001be	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_strtoul
  001c4	89 44 24 50	 mov	 DWORD PTR lcssid$[rsp], eax

; 1783 : 
; 1784 :     if (*strptr != 0)

  001c8	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR strptr$[rsp]
  001d0	0f be 00	 movsx	 eax, BYTE PTR [rax]
  001d3	85 c0		 test	 eax, eax
  001d5	74 70		 je	 SHORT $LN7@parse_lcss

; 1785 :     {
; 1786 :         if (verbose)

  001d7	83 bc 24 b0 00
	00 00 00	 cmp	 DWORD PTR verbose$[rsp], 0
  001df	74 51		 je	 SHORT $LN8@parse_lcss

; 1787 :         {
; 1788 :             // "Non-numeric Logical Channel Subsystem Identification %s"
; 1789 :             WRMSG( HHC01468, "E", lcss );

  001e1	b9 01 00 00 00	 mov	 ecx, 1
  001e6	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  001ec	48 8b 4c 24 70	 mov	 rcx, QWORD PTR lcss$[rsp]
  001f1	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  001f6	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG190717
  001fd	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  00202	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG190718
  00209	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  0020e	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00213	41 b9 03 00 00
	00		 mov	 r9d, 3
  00219	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG190719
  00220	ba fd 06 00 00	 mov	 edx, 1789		; 000006fdH
  00225	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG190720
  0022c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg
$LN8@parse_lcss:

; 1790 :         }
; 1791 :         free( wrk );

  00232	48 8b 4c 24 58	 mov	 rcx, QWORD PTR wrk$[rsp]
  00237	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free

; 1792 :         return -1;

  0023d	b8 ff ff ff ff	 mov	 eax, -1
  00242	e9 cc 00 00 00	 jmp	 $LN1@parse_lcss
$LN7@parse_lcss:

; 1793 :     }
; 1794 : 
; 1795 :     if (lcssid >= FEATURE_LCSS_MAX)

  00247	83 7c 24 50 04	 cmp	 DWORD PTR lcssid$[rsp], 4
  0024c	7c 73		 jl	 SHORT $LN9@parse_lcss

; 1796 :     {
; 1797 :         if (verbose)

  0024e	83 bc 24 b0 00
	00 00 00	 cmp	 DWORD PTR verbose$[rsp], 0
  00256	74 57		 je	 SHORT $LN10@parse_lcss

; 1798 :         {
; 1799 :             // "Logical Channel Subsystem Identification %d exceeds maximum of %d"
; 1800 :             WRMSG( HHC01469, "E", lcssid, FEATURE_LCSS_MAX-1 );

  00258	b9 01 00 00 00	 mov	 ecx, 1
  0025d	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  00263	c7 44 24 40 03
	00 00 00	 mov	 DWORD PTR [rsp+64], 3
  0026b	8b 4c 24 50	 mov	 ecx, DWORD PTR lcssid$[rsp]
  0026f	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  00273	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG190723
  0027a	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  0027f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG190724
  00286	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  0028b	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00290	41 b9 03 00 00
	00		 mov	 r9d, 3
  00296	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG190725
  0029d	ba 08 07 00 00	 mov	 edx, 1800		; 00000708H
  002a2	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG190726
  002a9	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg
$LN10@parse_lcss:

; 1801 :         }
; 1802 :         free( wrk );

  002af	48 8b 4c 24 58	 mov	 rcx, QWORD PTR wrk$[rsp]
  002b4	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free

; 1803 :         return -1;

  002ba	b8 ff ff ff ff	 mov	 eax, -1
  002bf	eb 52		 jmp	 SHORT $LN1@parse_lcss
$LN9@parse_lcss:

; 1804 :     }
; 1805 : 
; 1806 :     len = strlen( r ) + 1;

  002c1	48 8b 4c 24 78	 mov	 rcx, QWORD PTR r$[rsp]
  002c6	e8 00 00 00 00	 call	 strlen
  002cb	48 ff c0	 inc	 rax
  002ce	48 89 44 24 60	 mov	 QWORD PTR len$[rsp], rax

; 1807 :     *rest = malloc( len );

  002d3	48 8b 4c 24 60	 mov	 rcx, QWORD PTR len$[rsp]
  002d8	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_malloc
  002de	48 8b 8c 24 a8
	00 00 00	 mov	 rcx, QWORD PTR rest$[rsp]
  002e6	48 89 01	 mov	 QWORD PTR [rcx], rax

; 1808 :     strlcpy( *rest, r, len );

  002e9	4c 8b 44 24 60	 mov	 r8, QWORD PTR len$[rsp]
  002ee	48 8b 54 24 78	 mov	 rdx, QWORD PTR r$[rsp]
  002f3	48 8b 84 24 a8
	00 00 00	 mov	 rax, QWORD PTR rest$[rsp]
  002fb	48 8b 08	 mov	 rcx, QWORD PTR [rax]
  002fe	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_strlcpy

; 1809 :     free( wrk );

  00304	48 8b 4c 24 58	 mov	 rcx, QWORD PTR wrk$[rsp]
  00309	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free

; 1810 : 
; 1811 :     return lcssid;

  0030f	8b 44 24 50	 mov	 eax, DWORD PTR lcssid$[rsp]
$LN1@parse_lcss:

; 1812 : }

  00313	48 81 c4 98 00
	00 00		 add	 rsp, 152		; 00000098H
  0031a	c3		 ret	 0
parse_lcss ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\config.c
_TEXT	SEGMENT
cpu$ = 32
numcpu$ = 64
configure_numcpu_intlock_held PROC

; 1197 : {

  00000	89 4c 24 08	 mov	 DWORD PTR [rsp+8], ecx
  00004	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 1198 :     int cpu;
; 1199 : 
; 1200 :     /* Requested number of online CPUs must be <= maximum */
; 1201 :     if (numcpu > sysblk.maxcpu)

  00008	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  0000f	8b 80 00 01 00
	00		 mov	 eax, DWORD PTR [rax+256]
  00015	39 44 24 40	 cmp	 DWORD PTR numcpu$[rsp], eax
  00019	7e 0a		 jle	 SHORT $LN8@configure_

; 1202 :         return HERRCPUOFF;  /* CPU offline; number > maximum */

  0001b	b8 fe ff ff ff	 mov	 eax, -2
  00020	e9 df 00 00 00	 jmp	 $LN1@configure_
$LN8@configure_:

; 1203 : 
; 1204 :     /* All CPUs must be stopped beforehand */
; 1205 :     if (sysblk.cpus && !are_all_cpus_stopped_intlock_held())

  00025	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  0002c	83 b8 04 01 00
	00 00		 cmp	 DWORD PTR [rax+260], 0
  00033	74 16		 je	 SHORT $LN9@configure_
  00035	e8 00 00 00 00	 call	 are_all_cpus_stopped_intlock_held
  0003a	0f b6 c0	 movzx	 eax, al
  0003d	85 c0		 test	 eax, eax
  0003f	75 0a		 jne	 SHORT $LN9@configure_

; 1206 :         return HERRCPUONL; /* CPU online; not all are stopped */

  00041	b8 fd ff ff ff	 mov	 eax, -3
  00046	e9 b9 00 00 00	 jmp	 $LN1@configure_
$LN9@configure_:

; 1207 : 
; 1208 :     /* Keep deconfiguring CPUS until within desired range */
; 1209 :     for (cpu=sysblk.hicpu-1; cpu >= 0 && sysblk.cpus > numcpu; cpu--)

  0004b	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00052	8b 80 08 01 00
	00		 mov	 eax, DWORD PTR [rax+264]
  00058	ff c8		 dec	 eax
  0005a	89 44 24 20	 mov	 DWORD PTR cpu$[rsp], eax
  0005e	eb 0a		 jmp	 SHORT $LN4@configure_
$LN2@configure_:
  00060	8b 44 24 20	 mov	 eax, DWORD PTR cpu$[rsp]
  00064	ff c8		 dec	 eax
  00066	89 44 24 20	 mov	 DWORD PTR cpu$[rsp], eax
$LN4@configure_:
  0006a	83 7c 24 20 00	 cmp	 DWORD PTR cpu$[rsp], 0
  0006f	7c 35		 jl	 SHORT $LN3@configure_
  00071	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00078	8b 4c 24 40	 mov	 ecx, DWORD PTR numcpu$[rsp]
  0007c	39 88 04 01 00
	00		 cmp	 DWORD PTR [rax+260], ecx
  00082	7e 22		 jle	 SHORT $LN3@configure_

; 1210 :     {
; 1211 :         /* Deconfigure this CPU if it's currently configured */
; 1212 :         if (IS_CPU_ONLINE( cpu ))

  00084	48 63 44 24 20	 movsxd	 rax, DWORD PTR cpu$[rsp]
  00089	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  00090	48 83 bc c1 98
	0b 00 00 00	 cmp	 QWORD PTR [rcx+rax*8+2968], 0
  00099	74 09		 je	 SHORT $LN10@configure_

; 1213 :             deconfigure_cpu( cpu );

  0009b	8b 4c 24 20	 mov	 ecx, DWORD PTR cpu$[rsp]
  0009f	e8 00 00 00 00	 call	 deconfigure_cpu
$LN10@configure_:

; 1214 :     }

  000a4	eb ba		 jmp	 SHORT $LN2@configure_
$LN3@configure_:

; 1215 : 
; 1216 :     /* Keep configuring CPUs until desired amount reached */
; 1217 :     for (cpu=0; cpu < sysblk.maxcpu && sysblk.cpus < numcpu; cpu++)

  000a6	c7 44 24 20 00
	00 00 00	 mov	 DWORD PTR cpu$[rsp], 0
  000ae	eb 0a		 jmp	 SHORT $LN7@configure_
$LN5@configure_:
  000b0	8b 44 24 20	 mov	 eax, DWORD PTR cpu$[rsp]
  000b4	ff c0		 inc	 eax
  000b6	89 44 24 20	 mov	 DWORD PTR cpu$[rsp], eax
$LN7@configure_:
  000ba	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  000c1	8b 80 00 01 00
	00		 mov	 eax, DWORD PTR [rax+256]
  000c7	39 44 24 20	 cmp	 DWORD PTR cpu$[rsp], eax
  000cb	7d 35		 jge	 SHORT $LN6@configure_
  000cd	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  000d4	8b 4c 24 40	 mov	 ecx, DWORD PTR numcpu$[rsp]
  000d8	39 88 04 01 00
	00		 cmp	 DWORD PTR [rax+260], ecx
  000de	7d 22		 jge	 SHORT $LN6@configure_

; 1218 :     {
; 1219 :         /* Configure this CPU if it's not currently configured */
; 1220 :         if (!IS_CPU_ONLINE( cpu ))

  000e0	48 63 44 24 20	 movsxd	 rax, DWORD PTR cpu$[rsp]
  000e5	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  000ec	48 83 bc c1 98
	0b 00 00 00	 cmp	 QWORD PTR [rcx+rax*8+2968], 0
  000f5	75 09		 jne	 SHORT $LN11@configure_

; 1221 :             configure_cpu( cpu );

  000f7	8b 4c 24 20	 mov	 ecx, DWORD PTR cpu$[rsp]
  000fb	e8 00 00 00 00	 call	 configure_cpu
$LN11@configure_:

; 1222 :     }

  00100	eb ae		 jmp	 SHORT $LN5@configure_
$LN6@configure_:

; 1223 : 
; 1224 :     return 0;

  00102	33 c0		 xor	 eax, eax
$LN1@configure_:

; 1225 : }

  00104	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00108	c3		 ret	 0
configure_numcpu_intlock_held ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\config.c
_TEXT	SEGMENT
dev$ = 32
arg$ = 64
shrd_devinit PROC

; 930  : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 931  :     DEVBLK* dev = (DEVBLK*) arg;

  00009	48 8b 44 24 40	 mov	 rax, QWORD PTR arg$[rsp]
  0000e	48 89 44 24 20	 mov	 QWORD PTR dev$[rsp], rax

; 932  :     dev->hnd->init( dev, 0, NULL );

  00013	48 8b 44 24 20	 mov	 rax, QWORD PTR dev$[rsp]
  00018	48 8b 80 90 02
	00 00		 mov	 rax, QWORD PTR [rax+656]
  0001f	45 33 c0	 xor	 r8d, r8d
  00022	33 d2		 xor	 edx, edx
  00024	48 8b 4c 24 20	 mov	 rcx, QWORD PTR dev$[rsp]
  00029	ff 10		 call	 QWORD PTR [rax]

; 933  :     return NULL;

  0002b	33 c0		 xor	 eax, eax

; 934  : }

  0002d	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00031	c3		 ret	 0
shrd_devinit ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\config.c
_TEXT	SEGMENT
dev$ = 80
tv81 = 88
tv83 = 92
rc$ = 96
str$ = 112
__$ArrayPad$ = 176
lcss$ = 208
subchan$ = 216
devnum$ = 224
detach_subchan PROC

; 842  : {

  00000	66 44 89 44 24
	18		 mov	 WORD PTR [rsp+24], r8w
  00006	66 89 54 24 10	 mov	 WORD PTR [rsp+16], dx
  0000b	66 89 4c 24 08	 mov	 WORD PTR [rsp+8], cx
  00010	48 81 ec c8 00
	00 00		 sub	 rsp, 200		; 000000c8H
  00017	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  0001e	48 33 c4	 xor	 rax, rsp
  00021	48 89 84 24 b0
	00 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 843  : DEVBLK *dev;                            /* -> Device block           */
; 844  : int    rc;
; 845  : char   str[64];
; 846  :     /* Find the device block */
; 847  :     dev = find_device_by_subchan ((LCSS_TO_SSID(lcss)<<16)|subchan);

  00029	0f b7 84 24 d0
	00 00 00	 movzx	 eax, WORD PTR lcss$[rsp]
  00031	d1 e0		 shl	 eax, 1
  00033	83 c8 01	 or	 eax, 1
  00036	c1 e0 10	 shl	 eax, 16
  00039	0f b7 8c 24 d8
	00 00 00	 movzx	 ecx, WORD PTR subchan$[rsp]
  00041	0b c1		 or	 eax, ecx
  00043	8b c8		 mov	 ecx, eax
  00045	e8 00 00 00 00	 call	 find_device_by_subchan
  0004a	48 89 44 24 50	 mov	 QWORD PTR dev$[rsp], rax

; 848  : 
; 849  :     MSGBUF( str, "subchannel %1d:%04X", lcss, subchan);

  0004f	0f b7 84 24 d8
	00 00 00	 movzx	 eax, WORD PTR subchan$[rsp]
  00057	0f b7 8c 24 d0
	00 00 00	 movzx	 ecx, WORD PTR lcss$[rsp]
  0005f	89 44 24 20	 mov	 DWORD PTR [rsp+32], eax
  00063	44 8b c9	 mov	 r9d, ecx
  00066	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG190268
  0006d	ba 40 00 00 00	 mov	 edx, 64			; 00000040H
  00072	48 8d 4c 24 70	 lea	 rcx, QWORD PTR str$[rsp]
  00077	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_snprintf

; 850  : 
; 851  :     if (dev == NULL)

  0007d	48 83 7c 24 50
	00		 cmp	 QWORD PTR dev$[rsp], 0
  00083	0f 85 83 00 00
	00		 jne	 $LN2@detach_sub

; 852  :     {
; 853  :         // "%1d:%04X %s does not exist"
; 854  :         WRMSG (HHC01464, "E", lcss, devnum, str);

  00089	0f b7 84 24 e0
	00 00 00	 movzx	 eax, WORD PTR devnum$[rsp]
  00091	89 44 24 58	 mov	 DWORD PTR tv81[rsp], eax
  00095	0f b7 8c 24 d0
	00 00 00	 movzx	 ecx, WORD PTR lcss$[rsp]
  0009d	89 4c 24 5c	 mov	 DWORD PTR tv83[rsp], ecx
  000a1	b9 01 00 00 00	 mov	 ecx, 1
  000a6	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  000ac	48 8d 4c 24 70	 lea	 rcx, QWORD PTR str$[rsp]
  000b1	48 89 4c 24 48	 mov	 QWORD PTR [rsp+72], rcx
  000b6	8b 4c 24 58	 mov	 ecx, DWORD PTR tv81[rsp]
  000ba	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  000be	8b 4c 24 5c	 mov	 ecx, DWORD PTR tv83[rsp]
  000c2	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  000c6	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG190270
  000cd	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  000d2	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG190271
  000d9	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  000de	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  000e3	41 b9 03 00 00
	00		 mov	 r9d, 3
  000e9	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG190272
  000f0	ba 56 03 00 00	 mov	 edx, 854		; 00000356H
  000f5	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG190273
  000fc	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 855  :         return 1;

  00102	b8 01 00 00 00	 mov	 eax, 1
  00107	e9 9e 00 00 00	 jmp	 $LN1@detach_sub
$LN2@detach_sub:

; 856  :     }
; 857  : 
; 858  :     obtain_lock(&sysblk.config);

  0010c	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00113	48 05 80 00 00
	00		 add	 rax, 128		; 00000080H
  00119	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG190274
  00120	48 8b c8	 mov	 rcx, rax
  00123	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_obtain_lock

; 859  : 
; 860  :     if (dev->group)

  00129	48 8b 44 24 50	 mov	 rax, QWORD PTR dev$[rsp]
  0012e	48 83 78 60 00	 cmp	 QWORD PTR [rax+96], 0
  00133	74 2e		 je	 SHORT $LN3@detach_sub

; 861  :         MSGBUF( str, "group subchannel %1d:%04X", lcss, subchan);

  00135	0f b7 84 24 d8
	00 00 00	 movzx	 eax, WORD PTR subchan$[rsp]
  0013d	0f b7 8c 24 d0
	00 00 00	 movzx	 ecx, WORD PTR lcss$[rsp]
  00145	89 44 24 20	 mov	 DWORD PTR [rsp+32], eax
  00149	44 8b c9	 mov	 r9d, ecx
  0014c	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG190276
  00153	ba 40 00 00 00	 mov	 edx, 64			; 00000040H
  00158	48 8d 4c 24 70	 lea	 rcx, QWORD PTR str$[rsp]
  0015d	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_snprintf
$LN3@detach_sub:

; 862  : 
; 863  :     rc = detach_devblk( dev, FALSE, str, NULL, dev->group );

  00163	48 8b 44 24 50	 mov	 rax, QWORD PTR dev$[rsp]
  00168	48 8b 40 60	 mov	 rax, QWORD PTR [rax+96]
  0016c	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00171	45 33 c9	 xor	 r9d, r9d
  00174	4c 8d 44 24 70	 lea	 r8, QWORD PTR str$[rsp]
  00179	33 d2		 xor	 edx, edx
  0017b	48 8b 4c 24 50	 mov	 rcx, QWORD PTR dev$[rsp]
  00180	e8 00 00 00 00	 call	 detach_devblk
  00185	89 44 24 60	 mov	 DWORD PTR rc$[rsp], eax

; 864  : 
; 865  :     release_lock(&sysblk.config);

  00189	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00190	48 05 80 00 00
	00		 add	 rax, 128		; 00000080H
  00196	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG190277
  0019d	48 8b c8	 mov	 rcx, rax
  001a0	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_release_lock

; 866  : 
; 867  :     return rc;

  001a6	8b 44 24 60	 mov	 eax, DWORD PTR rc$[rsp]
$LN1@detach_sub:

; 868  : }

  001aa	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  001b2	48 33 cc	 xor	 rcx, rsp
  001b5	e8 00 00 00 00	 call	 __security_check_cookie
  001ba	48 81 c4 c8 00
	00 00		 add	 rsp, 200		; 000000c8H
  001c1	c3		 ret	 0
detach_subchan ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\config.c
_TEXT	SEGMENT
i$ = 80
tv88 = 84
tv95 = 88
tv147 = 92
tv153 = 96
dev$ = 128
locked$ = 136
msg$ = 144
errdev$ = 152
group$ = 160
detach_devblk PROC

; 772  : {

  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  0000e	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00013	48 83 ec 78	 sub	 rsp, 120		; 00000078H

; 773  : int     i;                              /* Loop index                */
; 774  : 
; 775  :     /* Free the entire group if this is a grouped device */
; 776  :     if (free_group( dev->group, locked, msg, errdev ))

  00017	4c 8b 8c 24 98
	00 00 00	 mov	 r9, QWORD PTR errdev$[rsp]
  0001f	4c 8b 84 24 90
	00 00 00	 mov	 r8, QWORD PTR msg$[rsp]
  00027	8b 94 24 88 00
	00 00		 mov	 edx, DWORD PTR locked$[rsp]
  0002e	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00036	48 8b 48 60	 mov	 rcx, QWORD PTR [rax+96]
  0003a	e8 00 00 00 00	 call	 free_group
  0003f	0f b6 c0	 movzx	 eax, al
  00042	85 c0		 test	 eax, eax
  00044	74 07		 je	 SHORT $LN5@detach_dev

; 777  :     {
; 778  :         /* Group successfully freed. All devices in the group
; 779  :            have been detached. Nothing remains for us to do.
; 780  :            All work has been completed. Return to caller.
; 781  :         */
; 782  :         return 0;

  00046	33 c0		 xor	 eax, eax
  00048	e9 bb 02 00 00	 jmp	 $LN1@detach_dev
$LN5@detach_dev:

; 783  :     }
; 784  : 
; 785  :     /* Restore group ptr that that 'free_group' may have set to NULL */
; 786  :     dev->group = group;

  0004d	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00055	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR group$[rsp]
  0005d	48 89 48 60	 mov	 QWORD PTR [rax+96], rcx

; 787  : 
; 788  :     /* Obtain the device lock. ret_devblk will release it */
; 789  :     if (!locked)

  00061	83 bc 24 88 00
	00 00 00	 cmp	 DWORD PTR locked$[rsp], 0
  00069	75 1c		 jne	 SHORT $LN6@detach_dev

; 790  :         obtain_lock(&dev->lock);

  0006b	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00073	48 83 c0 38	 add	 rax, 56			; 00000038H
  00077	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG190241
  0007e	48 8b c8	 mov	 rcx, rax
  00081	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_obtain_lock
$LN6@detach_dev:

; 791  : 
; 792  :     DelSubchanFastLookup(dev->ssid, dev->subchan);

  00087	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  0008f	0f b7 50 46	 movzx	 edx, WORD PTR [rax+70]
  00093	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  0009b	0f b7 48 44	 movzx	 ecx, WORD PTR [rax+68]
  0009f	e8 00 00 00 00	 call	 DelSubchanFastLookup

; 793  :     if(dev->pmcw.flag5 & PMCW5_V)

  000a4	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  000ac	0f b6 80 f1 02
	00 00		 movzx	 eax, BYTE PTR [rax+753]
  000b3	83 e0 01	 and	 eax, 1
  000b6	85 c0		 test	 eax, eax
  000b8	74 5b		 je	 SHORT $LN7@detach_dev

; 794  :         DelDevnumFastLookup(LCSS_DEVNUM);

  000ba	48 83 bc 24 80
	00 00 00 00	 cmp	 QWORD PTR dev$[rsp], 0
  000c3	74 12		 je	 SHORT $LN17@detach_dev
  000c5	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  000cd	0f b7 40 48	 movzx	 eax, WORD PTR [rax+72]
  000d1	89 44 24 54	 mov	 DWORD PTR tv88[rsp], eax
  000d5	eb 08		 jmp	 SHORT $LN18@detach_dev
$LN17@detach_dev:
  000d7	c7 44 24 54 00
	00 00 00	 mov	 DWORD PTR tv88[rsp], 0
$LN18@detach_dev:
  000df	48 83 bc 24 80
	00 00 00 00	 cmp	 QWORD PTR dev$[rsp], 0
  000e8	74 14		 je	 SHORT $LN19@detach_dev
  000ea	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  000f2	0f b7 40 44	 movzx	 eax, WORD PTR [rax+68]
  000f6	d1 f8		 sar	 eax, 1
  000f8	89 44 24 58	 mov	 DWORD PTR tv95[rsp], eax
  000fc	eb 08		 jmp	 SHORT $LN20@detach_dev
$LN19@detach_dev:
  000fe	c7 44 24 58 00
	00 00 00	 mov	 DWORD PTR tv95[rsp], 0
$LN20@detach_dev:
  00106	0f b7 54 24 54	 movzx	 edx, WORD PTR tv88[rsp]
  0010b	0f b7 4c 24 58	 movzx	 ecx, WORD PTR tv95[rsp]
  00110	e8 00 00 00 00	 call	 DelDevnumFastLookup
$LN7@detach_dev:

; 795  : 
; 796  :     /* Close file or socket */
; 797  :     if ((dev->fd > 2) || dev->console)

  00115	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  0011d	83 b8 ac 01 00
	00 02		 cmp	 DWORD PTR [rax+428], 2
  00124	7f 18		 jg	 SHORT $LN9@detach_dev
  00126	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  0012e	8b 80 f8 05 00
	00		 mov	 eax, DWORD PTR [rax+1528]
  00134	c1 e8 04	 shr	 eax, 4
  00137	83 e0 01	 and	 eax, 1
  0013a	85 c0		 test	 eax, eax
  0013c	74 1a		 je	 SHORT $LN8@detach_dev
$LN9@detach_dev:

; 798  :         /* Call the device close handler */
; 799  :         (dev->hnd->close)(dev);

  0013e	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00146	48 8b 80 90 02
	00 00		 mov	 rax, QWORD PTR [rax+656]
  0014d	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  00155	ff 50 10	 call	 QWORD PTR [rax+16]
$LN8@detach_dev:

; 800  : 
; 801  :     /* Issue device detached message and build channel report */
; 802  :     if (dev != errdev)

  00158	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR errdev$[rsp]
  00160	48 39 84 24 80
	00 00 00	 cmp	 QWORD PTR dev$[rsp], rax
  00168	0f 84 fe 00 00
	00		 je	 $LN10@detach_dev

; 803  :     {
; 804  :         if (MLVL(DEBUG))

  0016e	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00175	8b 80 80 75 01
	00		 mov	 eax, DWORD PTR [rax+95616]
  0017b	25 00 00 00 40	 and	 eax, 1073741824		; 40000000H
  00180	85 c0		 test	 eax, eax
  00182	0f 84 b0 00 00
	00		 je	 $LN11@detach_dev

; 805  :         {
; 806  :             // "%1d:%04X %s detached"
; 807  :             WRMSG (HHC01465, "I", LCSS_DEVNUM, msg);

  00188	48 83 bc 24 80
	00 00 00 00	 cmp	 QWORD PTR dev$[rsp], 0
  00191	74 12		 je	 SHORT $LN21@detach_dev
  00193	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  0019b	0f b7 40 48	 movzx	 eax, WORD PTR [rax+72]
  0019f	89 44 24 5c	 mov	 DWORD PTR tv147[rsp], eax
  001a3	eb 08		 jmp	 SHORT $LN22@detach_dev
$LN21@detach_dev:
  001a5	c7 44 24 5c 00
	00 00 00	 mov	 DWORD PTR tv147[rsp], 0
$LN22@detach_dev:
  001ad	48 83 bc 24 80
	00 00 00 00	 cmp	 QWORD PTR dev$[rsp], 0
  001b6	74 14		 je	 SHORT $LN23@detach_dev
  001b8	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  001c0	0f b7 40 44	 movzx	 eax, WORD PTR [rax+68]
  001c4	d1 f8		 sar	 eax, 1
  001c6	89 44 24 60	 mov	 DWORD PTR tv153[rsp], eax
  001ca	eb 08		 jmp	 SHORT $LN24@detach_dev
$LN23@detach_dev:
  001cc	c7 44 24 60 00
	00 00 00	 mov	 DWORD PTR tv153[rsp], 0
$LN24@detach_dev:
  001d4	b9 01 00 00 00	 mov	 ecx, 1
  001d9	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  001df	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR msg$[rsp]
  001e7	48 89 4c 24 48	 mov	 QWORD PTR [rsp+72], rcx
  001ec	8b 4c 24 5c	 mov	 ecx, DWORD PTR tv147[rsp]
  001f0	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  001f4	8b 4c 24 60	 mov	 ecx, DWORD PTR tv153[rsp]
  001f8	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  001fc	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG190247
  00203	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  00208	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG190248
  0020f	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00214	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00219	41 b9 03 00 00
	00		 mov	 r9d, 3
  0021f	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG190249
  00226	ba 27 03 00 00	 mov	 edx, 807		; 00000327H
  0022b	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG190250
  00232	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg
$LN11@detach_dev:

; 808  :         }
; 809  : 
; 810  : #ifdef _FEATURE_CHANNEL_SUBSYSTEM
; 811  :         /* Don't bother with channel report if we're shutting down */
; 812  :         if (!sysblk.shutdown)

  00238	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  0023f	8b 80 94 12 00
	00		 mov	 eax, DWORD PTR [rax+4756]
  00245	c1 e8 0b	 shr	 eax, 11
  00248	83 e0 01	 and	 eax, 1
  0024b	85 c0		 test	 eax, eax
  0024d	75 1d		 jne	 SHORT $LN12@detach_dev

; 813  :         {
; 814  : #if defined(_370)
; 815  :             if (sysblk.arch_mode != ARCH_370_IDX)

  0024f	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00256	83 b8 88 00 00
	00 00		 cmp	 DWORD PTR [rax+136], 0
  0025d	74 0d		 je	 SHORT $LN13@detach_dev

; 816  : #endif
; 817  :                 build_detach_chrpt( dev );

  0025f	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  00267	e8 00 00 00 00	 call	 build_detach_chrpt
$LN13@detach_dev:
$LN12@detach_dev:
$LN10@detach_dev:

; 818  :         }
; 819  : #endif /*_FEATURE_CHANNEL_SUBSYSTEM*/
; 820  :     }
; 821  : 
; 822  :     /* Free the argv array */
; 823  :     for (i = 0; i < dev->argc; i++)

  0026c	c7 44 24 50 00
	00 00 00	 mov	 DWORD PTR i$[rsp], 0
  00274	eb 0a		 jmp	 SHORT $LN4@detach_dev
$LN2@detach_dev:
  00276	8b 44 24 50	 mov	 eax, DWORD PTR i$[rsp]
  0027a	ff c0		 inc	 eax
  0027c	89 44 24 50	 mov	 DWORD PTR i$[rsp], eax
$LN4@detach_dev:
  00280	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00288	8b 40 68	 mov	 eax, DWORD PTR [rax+104]
  0028b	39 44 24 50	 cmp	 DWORD PTR i$[rsp], eax
  0028f	7d 35		 jge	 SHORT $LN3@detach_dev

; 824  :         if (dev->argv[i])

  00291	48 63 44 24 50	 movsxd	 rax, DWORD PTR i$[rsp]
  00296	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  0029e	48 8b 49 70	 mov	 rcx, QWORD PTR [rcx+112]
  002a2	48 83 3c c1 00	 cmp	 QWORD PTR [rcx+rax*8], 0
  002a7	74 1b		 je	 SHORT $LN14@detach_dev

; 825  :             free(dev->argv[i]);

  002a9	48 63 44 24 50	 movsxd	 rax, DWORD PTR i$[rsp]
  002ae	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  002b6	48 8b 49 70	 mov	 rcx, QWORD PTR [rcx+112]
  002ba	48 8b 0c c1	 mov	 rcx, QWORD PTR [rcx+rax*8]
  002be	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free
$LN14@detach_dev:
  002c4	eb b0		 jmp	 SHORT $LN2@detach_dev
$LN3@detach_dev:

; 826  :     if (dev->argv)

  002c6	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  002ce	48 83 78 70 00	 cmp	 QWORD PTR [rax+112], 0
  002d3	74 12		 je	 SHORT $LN15@detach_dev

; 827  :         free(dev->argv);

  002d5	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  002dd	48 8b 48 70	 mov	 rcx, QWORD PTR [rax+112]
  002e1	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free
$LN15@detach_dev:

; 828  : 
; 829  :     /* Free the device type name */
; 830  :     free(dev->typname);

  002e7	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  002ef	48 8b 48 50	 mov	 rcx, QWORD PTR [rax+80]
  002f3	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free

; 831  : 
; 832  :     /* Release lock and return the device to the DEVBLK pool */
; 833  :     ret_devblk( dev ); /* also does release_lock(&dev->lock);*/

  002f9	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  00301	e8 00 00 00 00	 call	 ret_devblk

; 834  : 
; 835  :     return 0;

  00306	33 c0		 xor	 eax, eax
$LN1@detach_dev:

; 836  : } /* end function detach_devblk */

  00308	48 83 c4 78	 add	 rsp, 120		; 00000078H
  0030c	c3		 ret	 0
detach_devblk ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\config.c
_TEXT	SEGMENT
dev$ = 48
ret_devblk PROC

; 753  : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 754  :     /* PROGRAMMING NOTE: the device buffer will be freed by the
; 755  :        'attach_device' function whenever it gets reused and not
; 756  :        here where you would normally expect it to be done since
; 757  :        doing it here might cause Hercules to crash due to poorly
; 758  :        written device handlers that still access the buffer for
; 759  :        a brief period after the device has been detached.
; 760  :     */
; 761  :     /* Mark device invalid */
; 762  :     dev->allocated = 0;

  00009	48 8b 44 24 30	 mov	 rax, QWORD PTR dev$[rsp]
  0000e	c7 40 40 00 00
	00 00		 mov	 DWORD PTR [rax+64], 0

; 763  :     dev->pmcw.flag5 &= ~PMCW5_V;

  00015	48 8b 44 24 30	 mov	 rax, QWORD PTR dev$[rsp]
  0001a	0f b6 80 f1 02
	00 00		 movzx	 eax, BYTE PTR [rax+753]
  00021	83 e0 fe	 and	 eax, -2
  00024	48 8b 4c 24 30	 mov	 rcx, QWORD PTR dev$[rsp]
  00029	88 81 f1 02 00
	00		 mov	 BYTE PTR [rcx+753], al

; 764  :     release_lock(&dev->lock);

  0002f	48 8b 44 24 30	 mov	 rax, QWORD PTR dev$[rsp]
  00034	48 83 c0 38	 add	 rax, 56			; 00000038H
  00038	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG190219
  0003f	48 8b c8	 mov	 rcx, rax
  00042	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_release_lock

; 765  : }

  00048	48 83 c4 28	 add	 rsp, 40			; 00000028H
  0004c	c3		 ret	 0
ret_devblk ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\config.c
_TEXT	SEGMENT
dev$ = 96
tv241 = 104
tv247 = 108
tv277 = 112
amt$1 = 120
dvpp$ = 128
tv128 = 136
tv130 = 140
tv82 = 144
tv87 = 152
buf$ = 160
__$ArrayPad$ = 192
lcss$ = 224
devnum$ = 232
get_devblk PROC

; 629  : {

  00000	66 89 54 24 10	 mov	 WORD PTR [rsp+16], dx
  00005	66 89 4c 24 08	 mov	 WORD PTR [rsp+8], cx
  0000a	57		 push	 rdi
  0000b	48 81 ec d0 00
	00 00		 sub	 rsp, 208		; 000000d0H
  00012	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00019	48 33 c4	 xor	 rax, rsp
  0001c	48 89 84 24 c0
	00 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 630  : DEVBLK*   dev;
; 631  : DEVBLK**  dvpp;
; 632  : char      buf[32];
; 633  : 
; 634  :     if (lcss >= FEATURE_LCSS_MAX)

  00024	0f b7 84 24 e0
	00 00 00	 movzx	 eax, WORD PTR lcss$[rsp]
  0002c	83 f8 04	 cmp	 eax, 4
  0002f	7c 0a		 jl	 SHORT $LN14@get_devblk

; 635  :         lcss = 0;

  00031	33 c0		 xor	 eax, eax
  00033	66 89 84 24 e0
	00 00 00	 mov	 WORD PTR lcss$[rsp], ax
$LN14@get_devblk:

; 636  : 
; 637  :     for (dev = sysblk.firstdev; dev != NULL; dev = dev->nextdev)

  0003b	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00042	48 8b 80 c0 11
	00 00		 mov	 rax, QWORD PTR [rax+4544]
  00049	48 89 44 24 60	 mov	 QWORD PTR dev$[rsp], rax
  0004e	eb 0e		 jmp	 SHORT $LN4@get_devblk
$LN2@get_devblk:
  00050	48 8b 44 24 60	 mov	 rax, QWORD PTR dev$[rsp]
  00055	48 8b 40 30	 mov	 rax, QWORD PTR [rax+48]
  00059	48 89 44 24 60	 mov	 QWORD PTR dev$[rsp], rax
$LN4@get_devblk:
  0005e	48 83 7c 24 60
	00		 cmp	 QWORD PTR dev$[rsp], 0
  00064	74 29		 je	 SHORT $LN3@get_devblk

; 638  :         if (!(dev->allocated) && dev->ssid == LCSS_TO_SSID( lcss ))

  00066	48 8b 44 24 60	 mov	 rax, QWORD PTR dev$[rsp]
  0006b	83 78 40 00	 cmp	 DWORD PTR [rax+64], 0
  0006f	75 1c		 jne	 SHORT $LN15@get_devblk
  00071	48 8b 44 24 60	 mov	 rax, QWORD PTR dev$[rsp]
  00076	0f b7 40 44	 movzx	 eax, WORD PTR [rax+68]
  0007a	0f b7 8c 24 e0
	00 00 00	 movzx	 ecx, WORD PTR lcss$[rsp]
  00082	d1 e1		 shl	 ecx, 1
  00084	83 c9 01	 or	 ecx, 1
  00087	3b c1		 cmp	 eax, ecx
  00089	75 02		 jne	 SHORT $LN15@get_devblk

; 639  :             break;

  0008b	eb 02		 jmp	 SHORT $LN3@get_devblk
$LN15@get_devblk:
  0008d	eb c1		 jmp	 SHORT $LN2@get_devblk
$LN3@get_devblk:

; 640  : 
; 641  :     if (!dev)

  0008f	48 83 7c 24 60
	00		 cmp	 QWORD PTR dev$[rsp], 0
  00095	0f 85 c3 03 00
	00		 jne	 $LN16@get_devblk

; 642  :     {
; 643  :         size_t  amt  = sizeof( DEVBLK );

  0009b	48 c7 44 24 78
	a0 1b 00 00	 mov	 QWORD PTR amt$1[rsp], 7072 ; 00001ba0H

; 644  :                 amt  = ROUND_UP( amt, _4K );

  000a4	48 83 7c 24 78
	00		 cmp	 QWORD PTR amt$1[rsp], 0
  000aa	74 26		 je	 SHORT $LN20@get_devblk
  000ac	48 8b 44 24 78	 mov	 rax, QWORD PTR amt$1[rsp]
  000b1	48 05 ff 0f 00
	00		 add	 rax, 4095		; 00000fffH
  000b7	33 d2		 xor	 edx, edx
  000b9	b9 00 10 00 00	 mov	 ecx, 4096		; 00001000H
  000be	48 f7 f1	 div	 rcx
  000c1	48 69 c0 00 10
	00 00		 imul	 rax, rax, 4096		; 00001000H
  000c8	48 89 84 24 90
	00 00 00	 mov	 QWORD PTR tv82[rsp], rax
  000d0	eb 0c		 jmp	 SHORT $LN21@get_devblk
$LN20@get_devblk:
  000d2	48 c7 84 24 90
	00 00 00 00 10
	00 00		 mov	 QWORD PTR tv82[rsp], 4096 ; 00001000H
$LN21@get_devblk:
  000de	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR tv82[rsp]
  000e6	48 89 44 24 78	 mov	 QWORD PTR amt$1[rsp], rax

; 645  : 
; 646  :         if (!(dev = (DEVBLK*) calloc_aligned( amt, _4K )))

  000eb	ba 00 10 00 00	 mov	 edx, 4096		; 00001000H
  000f0	48 8b 4c 24 78	 mov	 rcx, QWORD PTR amt$1[rsp]
  000f5	e8 00 00 00 00	 call	 calloc_aligned
  000fa	48 89 44 24 60	 mov	 QWORD PTR dev$[rsp], rax
  000ff	48 83 7c 24 60
	00		 cmp	 QWORD PTR dev$[rsp], 0
  00105	0f 85 d1 00 00
	00		 jne	 $LN17@get_devblk

; 647  :         {
; 648  :             MSGBUF( buf, "calloc(%d)", (int) amt );

  0010b	44 8b 4c 24 78	 mov	 r9d, DWORD PTR amt$1[rsp]
  00110	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG190198
  00117	ba 20 00 00 00	 mov	 edx, 32			; 00000020H
  0011c	48 8d 8c 24 a0
	00 00 00	 lea	 rcx, QWORD PTR buf$[rsp]
  00124	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_snprintf

; 649  :             // "%1d:%04X error in function %s: %s"
; 650  :             WRMSG( HHC01460, "E", lcss, devnum, buf, strerror( errno ));

  0012a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno
  00130	8b 08		 mov	 ecx, DWORD PTR [rax]
  00132	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_strerror
  00138	48 89 84 24 98
	00 00 00	 mov	 QWORD PTR tv87[rsp], rax
  00140	0f b7 8c 24 e8
	00 00 00	 movzx	 ecx, WORD PTR devnum$[rsp]
  00148	89 8c 24 88 00
	00 00		 mov	 DWORD PTR tv128[rsp], ecx
  0014f	0f b7 94 24 e0
	00 00 00	 movzx	 edx, WORD PTR lcss$[rsp]
  00157	89 94 24 8c 00
	00 00		 mov	 DWORD PTR tv130[rsp], edx
  0015e	b9 01 00 00 00	 mov	 ecx, 1
  00163	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  00169	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR tv87[rsp]
  00171	48 89 4c 24 50	 mov	 QWORD PTR [rsp+80], rcx
  00176	48 8d 8c 24 a0
	00 00 00	 lea	 rcx, QWORD PTR buf$[rsp]
  0017e	48 89 4c 24 48	 mov	 QWORD PTR [rsp+72], rcx
  00183	8b 8c 24 88 00
	00 00		 mov	 ecx, DWORD PTR tv128[rsp]
  0018a	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  0018e	8b 8c 24 8c 00
	00 00		 mov	 ecx, DWORD PTR tv130[rsp]
  00195	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  00199	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG190199
  001a0	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  001a5	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG190200
  001ac	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  001b1	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  001b6	41 b9 03 00 00
	00		 mov	 r9d, 3
  001bc	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG190201
  001c3	ba 8a 02 00 00	 mov	 edx, 650		; 0000028aH
  001c8	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG190202
  001cf	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 651  :             return NULL;

  001d5	33 c0		 xor	 eax, eax
  001d7	e9 95 06 00 00	 jmp	 $LN1@get_devblk
$LN17@get_devblk:
$LN7@get_devblk:
$LN10@get_devblk:

; 652  :         }
; 653  : 
; 654  :         INIT_BLOCK_HEADER_TRAILER( dev, DEVBLK );

  001dc	48 8b 44 24 60	 mov	 rax, QWORD PTR dev$[rsp]
  001e1	48 05 90 1b 00
	00		 add	 rax, 7056		; 00001b90H
  001e7	48 8b f8	 mov	 rdi, rax
  001ea	b8 20 00 00 00	 mov	 eax, 32			; 00000020H
  001ef	b9 10 00 00 00	 mov	 ecx, 16
  001f4	f3 aa		 rep stosb
  001f6	48 8b 44 24 60	 mov	 rax, QWORD PTR dev$[rsp]
  001fb	48 8b 7c 24 60	 mov	 rdi, QWORD PTR dev$[rsp]
  00200	b8 20 00 00 00	 mov	 eax, 32			; 00000020H
  00205	b9 10 00 00 00	 mov	 ecx, 16
  0020a	f3 aa		 rep stosb
  0020c	48 8b 44 24 60	 mov	 rax, QWORD PTR dev$[rsp]
  00211	48 05 90 1b 00
	00		 add	 rax, 7056		; 00001b90H
  00217	41 b8 10 00 00
	00		 mov	 r8d, 16
  0021d	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG190203
  00224	48 8b c8	 mov	 rcx, rax
  00227	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_strlcpy
  0022d	48 8b 44 24 60	 mov	 rax, QWORD PTR dev$[rsp]
  00232	48 05 90 1b 00
	00		 add	 rax, 7056		; 00001b90H
  00238	41 b8 10 00 00
	00		 mov	 r8d, 16
  0023e	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG190204
  00245	48 8b c8	 mov	 rcx, rax
  00248	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_strlcat
  0024e	48 8b 44 24 60	 mov	 rax, QWORD PTR dev$[rsp]
  00253	41 b8 10 00 00
	00		 mov	 r8d, 16
  00259	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG190205
  00260	48 8b c8	 mov	 rcx, rax
  00263	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_strlcpy
  00269	33 c0		 xor	 eax, eax
  0026b	85 c0		 test	 eax, eax
  0026d	0f 85 69 ff ff
	ff		 jne	 $LN10@get_devblk
  00273	48 8b 44 24 60	 mov	 rax, QWORD PTR dev$[rsp]
  00278	48 83 c0 10	 add	 rax, 16
  0027c	48 8b f8	 mov	 rdi, rax
  0027f	b8 20 00 00 00	 mov	 eax, 32			; 00000020H
  00284	b9 10 00 00 00	 mov	 ecx, 16
  00289	f3 aa		 rep stosb
  0028b	48 8b 44 24 60	 mov	 rax, QWORD PTR dev$[rsp]
  00290	48 83 c0 10	 add	 rax, 16
  00294	41 b8 10 00 00
	00		 mov	 r8d, 16
  0029a	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG190206
  002a1	48 8b c8	 mov	 rcx, rax
  002a4	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_strlcpy
  002aa	48 8b 4c 24 60	 mov	 rcx, QWORD PTR dev$[rsp]
  002af	e8 00 00 00 00	 call	 _byteswap_uint64
  002b4	48 8b 4c 24 60	 mov	 rcx, QWORD PTR dev$[rsp]
  002b9	48 89 41 20	 mov	 QWORD PTR [rcx+32], rax
  002bd	b9 a0 1b 00 00	 mov	 ecx, 7072		; 00001ba0H
  002c2	e8 00 00 00 00	 call	 _byteswap_ulong
  002c7	48 8b 4c 24 60	 mov	 rcx, QWORD PTR dev$[rsp]
  002cc	89 41 28	 mov	 DWORD PTR [rcx+40], eax
  002cf	33 c0		 xor	 eax, eax
  002d1	85 c0		 test	 eax, eax
  002d3	0f 85 03 ff ff
	ff		 jne	 $LN7@get_devblk

; 655  : 
; 656  :         /* Initialize the device lock and conditions */
; 657  : 
; 658  :         initialize_lock      ( &dev->lock               );

  002d9	48 8b 44 24 60	 mov	 rax, QWORD PTR dev$[rsp]
  002de	48 83 c0 38	 add	 rax, 56			; 00000038H
  002e2	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG190207
  002e9	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG190208
  002f0	48 8b c8	 mov	 rcx, rax
  002f3	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_initialize_lock

; 659  :         initialize_condition ( &dev->kbcond             );

  002f9	48 8b 44 24 60	 mov	 rax, QWORD PTR dev$[rsp]
  002fe	48 05 c8 06 00
	00		 add	 rax, 1736		; 000006c8H
  00304	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG190209
  0030b	48 8b c8	 mov	 rcx, rax
  0030e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_initialize_condition

; 660  : #if defined( OPTION_SHARED_DEVICES )
; 661  :         initialize_condition ( &dev->shiocond           );

  00314	48 8b 44 24 60	 mov	 rax, QWORD PTR dev$[rsp]
  00319	48 05 d8 05 00
	00		 add	 rax, 1496		; 000005d8H
  0031f	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG190210
  00326	48 8b c8	 mov	 rcx, rax
  00329	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_initialize_condition

; 662  : #endif // defined( OPTION_SHARED_DEVICES )
; 663  : #if defined(OPTION_SCSI_TAPE)
; 664  :         initialize_condition ( &dev->stape_sstat_cond   );

  0032f	48 8b 44 24 60	 mov	 rax, QWORD PTR dev$[rsp]
  00334	48 05 a0 10 00
	00		 add	 rax, 4256		; 000010a0H
  0033a	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG190211
  00341	48 8b c8	 mov	 rcx, rax
  00344	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_initialize_condition

; 665  :         InitializeListLink   ( &dev->stape_statrq.link  );

  0034a	48 8b 44 24 60	 mov	 rax, QWORD PTR dev$[rsp]
  0034f	48 c7 80 b0 10
	00 00 00 00 00
	00		 mov	 QWORD PTR [rax+4272], 0
  0035a	48 8b 44 24 60	 mov	 rax, QWORD PTR dev$[rsp]
  0035f	48 c7 80 a8 10
	00 00 00 00 00
	00		 mov	 QWORD PTR [rax+4264], 0

; 666  :         InitializeListLink   ( &dev->stape_mntdrq.link  );

  0036a	48 8b 44 24 60	 mov	 rax, QWORD PTR dev$[rsp]
  0036f	48 c7 80 c8 10
	00 00 00 00 00
	00		 mov	 QWORD PTR [rax+4296], 0
  0037a	48 8b 44 24 60	 mov	 rax, QWORD PTR dev$[rsp]
  0037f	48 c7 80 c0 10
	00 00 00 00 00
	00		 mov	 QWORD PTR [rax+4288], 0

; 667  :         dev->stape_statrq.dev = dev;

  0038a	48 8b 44 24 60	 mov	 rax, QWORD PTR dev$[rsp]
  0038f	48 8b 4c 24 60	 mov	 rcx, QWORD PTR dev$[rsp]
  00394	48 89 88 b8 10
	00 00		 mov	 QWORD PTR [rax+4280], rcx

; 668  :         dev->stape_mntdrq.dev = dev;

  0039b	48 8b 44 24 60	 mov	 rax, QWORD PTR dev$[rsp]
  003a0	48 8b 4c 24 60	 mov	 rcx, QWORD PTR dev$[rsp]
  003a5	48 89 88 d0 10
	00 00		 mov	 QWORD PTR [rax+4304], rcx

; 669  : #endif
; 670  :         /* Search for the last device block on the chain */
; 671  :         for (dvpp = &(sysblk.firstdev); *dvpp != NULL;

  003ac	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  003b3	48 05 c0 11 00
	00		 add	 rax, 4544		; 000011c0H
  003b9	48 89 84 24 80
	00 00 00	 mov	 QWORD PTR dvpp$[rsp], rax
  003c1	eb 17		 jmp	 SHORT $LN13@get_devblk
$LN11@get_devblk:

; 672  :             dvpp = &((*dvpp)->nextdev));

  003c3	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR dvpp$[rsp]
  003cb	48 8b 00	 mov	 rax, QWORD PTR [rax]
  003ce	48 83 c0 30	 add	 rax, 48			; 00000030H
  003d2	48 89 84 24 80
	00 00 00	 mov	 QWORD PTR dvpp$[rsp], rax
$LN13@get_devblk:

; 669  : #endif
; 670  :         /* Search for the last device block on the chain */
; 671  :         for (dvpp = &(sysblk.firstdev); *dvpp != NULL;

  003da	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR dvpp$[rsp]
  003e2	48 83 38 00	 cmp	 QWORD PTR [rax], 0
  003e6	74 02		 je	 SHORT $LN12@get_devblk

; 672  :             dvpp = &((*dvpp)->nextdev));

  003e8	eb d9		 jmp	 SHORT $LN11@get_devblk
$LN12@get_devblk:

; 673  : 
; 674  :         /* Add the new device block to the end of the chain */
; 675  :         *dvpp = dev;

  003ea	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR dvpp$[rsp]
  003f2	48 8b 4c 24 60	 mov	 rcx, QWORD PTR dev$[rsp]
  003f7	48 89 08	 mov	 QWORD PTR [rax], rcx

; 676  : 
; 677  :         dev->ssid = LCSS_TO_SSID( lcss );

  003fa	0f b7 84 24 e0
	00 00 00	 movzx	 eax, WORD PTR lcss$[rsp]
  00402	d1 e0		 shl	 eax, 1
  00404	83 c8 01	 or	 eax, 1
  00407	48 8b 4c 24 60	 mov	 rcx, QWORD PTR dev$[rsp]
  0040c	66 89 41 44	 mov	 WORD PTR [rcx+68], ax

; 678  :         dev->subchan = sysblk.highsubchan[ lcss ]++;

  00410	0f b7 84 24 e0
	00 00 00	 movzx	 eax, WORD PTR lcss$[rsp]
  00418	48 8b 4c 24 60	 mov	 rcx, QWORD PTR dev$[rsp]
  0041d	48 8b 15 00 00
	00 00		 mov	 rdx, QWORD PTR __imp_sysblk
  00424	0f b7 84 82 e0
	11 00 00	 movzx	 eax, WORD PTR [rdx+rax*4+4576]
  0042c	66 89 41 46	 mov	 WORD PTR [rcx+70], ax
  00430	0f b7 84 24 e0
	00 00 00	 movzx	 eax, WORD PTR lcss$[rsp]
  00438	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  0043f	8b 84 81 e0 11
	00 00		 mov	 eax, DWORD PTR [rcx+rax*4+4576]
  00446	ff c0		 inc	 eax
  00448	0f b7 8c 24 e0
	00 00 00	 movzx	 ecx, WORD PTR lcss$[rsp]
  00450	48 8b 15 00 00
	00 00		 mov	 rdx, QWORD PTR __imp_sysblk
  00457	89 84 8a e0 11
	00 00		 mov	 DWORD PTR [rdx+rcx*4+4576], eax
$LN16@get_devblk:

; 679  :     }
; 680  : 
; 681  :     /* Obtain the device lock. Caller will release it. */
; 682  :     obtain_lock (&dev->lock);

  0045e	48 8b 44 24 60	 mov	 rax, QWORD PTR dev$[rsp]
  00463	48 83 c0 38	 add	 rax, 56			; 00000038H
  00467	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG190212
  0046e	48 8b c8	 mov	 rcx, rax
  00471	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_obtain_lock

; 683  : 
; 684  :     dev->group = NULL;

  00477	48 8b 44 24 60	 mov	 rax, QWORD PTR dev$[rsp]
  0047c	48 c7 40 60 00
	00 00 00	 mov	 QWORD PTR [rax+96], 0

; 685  :     dev->member = 0;

  00484	48 8b 44 24 60	 mov	 rax, QWORD PTR dev$[rsp]
  00489	c7 40 58 00 00
	00 00		 mov	 DWORD PTR [rax+88], 0

; 686  : 
; 687  :     memset(dev->filename, 0, sizeof(dev->filename));

  00490	48 8b 44 24 60	 mov	 rax, QWORD PTR dev$[rsp]
  00495	48 05 a4 00 00
	00		 add	 rax, 164		; 000000a4H
  0049b	48 8b f8	 mov	 rdi, rax
  0049e	33 c0		 xor	 eax, eax
  004a0	b9 05 01 00 00	 mov	 ecx, 261		; 00000105H
  004a5	f3 aa		 rep stosb

; 688  : 
; 689  :     dev->cpuprio = sysblk.cpuprio;

  004a7	48 8b 44 24 60	 mov	 rax, QWORD PTR dev$[rsp]
  004ac	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  004b3	8b 89 6c 13 00
	00		 mov	 ecx, DWORD PTR [rcx+4972]
  004b9	89 88 70 02 00
	00		 mov	 DWORD PTR [rax+624], ecx

; 690  :     dev->devprio = sysblk.devprio;

  004bf	48 8b 44 24 60	 mov	 rax, QWORD PTR dev$[rsp]
  004c4	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  004cb	8b 89 70 13 00
	00		 mov	 ecx, DWORD PTR [rcx+4976]
  004d1	89 88 74 02 00
	00		 mov	 DWORD PTR [rax+628], ecx

; 691  :     dev->hnd = NULL;

  004d7	48 8b 44 24 60	 mov	 rax, QWORD PTR dev$[rsp]
  004dc	48 c7 80 90 02
	00 00 00 00 00
	00		 mov	 QWORD PTR [rax+656], 0

; 692  :     dev->devnum = devnum;

  004e7	48 8b 44 24 60	 mov	 rax, QWORD PTR dev$[rsp]
  004ec	0f b7 8c 24 e8
	00 00 00	 movzx	 ecx, WORD PTR devnum$[rsp]
  004f4	66 89 48 48	 mov	 WORD PTR [rax+72], cx

; 693  : 
; 694  :     MSGBUF( buf,  "&dev->lock %1d:%04X", LCSS_DEVNUM );

  004f8	48 83 7c 24 60
	00		 cmp	 QWORD PTR dev$[rsp], 0
  004fe	74 0f		 je	 SHORT $LN22@get_devblk
  00500	48 8b 44 24 60	 mov	 rax, QWORD PTR dev$[rsp]
  00505	0f b7 40 48	 movzx	 eax, WORD PTR [rax+72]
  00509	89 44 24 68	 mov	 DWORD PTR tv241[rsp], eax
  0050d	eb 08		 jmp	 SHORT $LN23@get_devblk
$LN22@get_devblk:
  0050f	c7 44 24 68 00
	00 00 00	 mov	 DWORD PTR tv241[rsp], 0
$LN23@get_devblk:
  00517	48 83 7c 24 60
	00		 cmp	 QWORD PTR dev$[rsp], 0
  0051d	74 11		 je	 SHORT $LN24@get_devblk
  0051f	48 8b 44 24 60	 mov	 rax, QWORD PTR dev$[rsp]
  00524	0f b7 40 44	 movzx	 eax, WORD PTR [rax+68]
  00528	d1 f8		 sar	 eax, 1
  0052a	89 44 24 6c	 mov	 DWORD PTR tv247[rsp], eax
  0052e	eb 08		 jmp	 SHORT $LN25@get_devblk
$LN24@get_devblk:
  00530	c7 44 24 6c 00
	00 00 00	 mov	 DWORD PTR tv247[rsp], 0
$LN25@get_devblk:
  00538	8b 44 24 68	 mov	 eax, DWORD PTR tv241[rsp]
  0053c	89 44 24 20	 mov	 DWORD PTR [rsp+32], eax
  00540	44 8b 4c 24 6c	 mov	 r9d, DWORD PTR tv247[rsp]
  00545	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG190213
  0054c	ba 20 00 00 00	 mov	 edx, 32			; 00000020H
  00551	48 8d 8c 24 a0
	00 00 00	 lea	 rcx, QWORD PTR buf$[rsp]
  00559	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_snprintf

; 695  :     set_lock_name( &dev->lock, buf );

  0055f	48 8b 44 24 60	 mov	 rax, QWORD PTR dev$[rsp]
  00564	48 83 c0 38	 add	 rax, 56			; 00000038H
  00568	48 8d 94 24 a0
	00 00 00	 lea	 rdx, QWORD PTR buf$[rsp]
  00570	48 8b c8	 mov	 rcx, rax
  00573	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_set_lock_name

; 696  : 
; 697  :     dev->chanset = lcss;

  00579	48 8b 44 24 60	 mov	 rax, QWORD PTR dev$[rsp]
  0057e	0f b7 8c 24 e0
	00 00 00	 movzx	 ecx, WORD PTR lcss$[rsp]
  00586	66 89 48 4c	 mov	 WORD PTR [rax+76], cx

; 698  :     dev->chptype[0] = CHP_TYPE_EIO; /* Interim - default to emulated */

  0058a	b8 01 00 00 00	 mov	 eax, 1
  0058f	48 6b c0 00	 imul	 rax, rax, 0
  00593	48 8b 4c 24 60	 mov	 rcx, QWORD PTR dev$[rsp]
  00598	c6 84 01 cc 05
	00 00 1f	 mov	 BYTE PTR [rcx+rax+1484], 31

; 699  :     dev->fd = -1;

  005a0	48 8b 44 24 60	 mov	 rax, QWORD PTR dev$[rsp]
  005a5	c7 80 ac 01 00
	00 ff ff ff ff	 mov	 DWORD PTR [rax+428], -1

; 700  :     dev->ioint.dev = dev;

  005af	48 8b 44 24 60	 mov	 rax, QWORD PTR dev$[rsp]
  005b4	48 8b 4c 24 60	 mov	 rcx, QWORD PTR dev$[rsp]
  005b9	48 89 88 30 02
	00 00		 mov	 QWORD PTR [rax+560], rcx

; 701  :     dev->ioint.pending = 1;

  005c0	48 8b 44 24 60	 mov	 rax, QWORD PTR dev$[rsp]
  005c5	8b 80 3c 02 00
	00		 mov	 eax, DWORD PTR [rax+572]
  005cb	83 c8 01	 or	 eax, 1
  005ce	48 8b 4c 24 60	 mov	 rcx, QWORD PTR dev$[rsp]
  005d3	89 81 3c 02 00
	00		 mov	 DWORD PTR [rcx+572], eax

; 702  :     dev->ioint.priority = -1;

  005d9	48 8b 44 24 60	 mov	 rax, QWORD PTR dev$[rsp]
  005de	c7 80 38 02 00
	00 ff ff ff ff	 mov	 DWORD PTR [rax+568], -1

; 703  :     dev->pciioint.dev = dev;

  005e8	48 8b 44 24 60	 mov	 rax, QWORD PTR dev$[rsp]
  005ed	48 8b 4c 24 60	 mov	 rcx, QWORD PTR dev$[rsp]
  005f2	48 89 88 48 02
	00 00		 mov	 QWORD PTR [rax+584], rcx

; 704  :     dev->pciioint.pcipending = 1;

  005f9	48 8b 44 24 60	 mov	 rax, QWORD PTR dev$[rsp]
  005fe	8b 80 54 02 00
	00		 mov	 eax, DWORD PTR [rax+596]
  00604	83 c8 02	 or	 eax, 2
  00607	48 8b 4c 24 60	 mov	 rcx, QWORD PTR dev$[rsp]
  0060c	89 81 54 02 00
	00		 mov	 DWORD PTR [rcx+596], eax

; 705  :     dev->pciioint.priority = -1;

  00612	48 8b 44 24 60	 mov	 rax, QWORD PTR dev$[rsp]
  00617	c7 80 50 02 00
	00 ff ff ff ff	 mov	 DWORD PTR [rax+592], -1

; 706  :     dev->attnioint.dev = dev;

  00621	48 8b 44 24 60	 mov	 rax, QWORD PTR dev$[rsp]
  00626	48 8b 4c 24 60	 mov	 rcx, QWORD PTR dev$[rsp]
  0062b	48 89 88 60 02
	00 00		 mov	 QWORD PTR [rax+608], rcx

; 707  :     dev->attnioint.attnpending = 1;

  00632	48 8b 44 24 60	 mov	 rax, QWORD PTR dev$[rsp]
  00637	8b 80 6c 02 00
	00		 mov	 eax, DWORD PTR [rax+620]
  0063d	83 c8 04	 or	 eax, 4
  00640	48 8b 4c 24 60	 mov	 rcx, QWORD PTR dev$[rsp]
  00645	89 81 6c 02 00
	00		 mov	 DWORD PTR [rcx+620], eax

; 708  :     dev->attnioint.priority = -1;

  0064b	48 8b 44 24 60	 mov	 rax, QWORD PTR dev$[rsp]
  00650	c7 80 68 02 00
	00 ff ff ff ff	 mov	 DWORD PTR [rax+616], -1

; 709  :     dev->oslinux = (OS_LINUX == sysblk.pgminttr);

  0065a	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00661	48 b9 f7 7f de
	f7 ff ff ff 78	 mov	 rcx, 8718968878452867063 ; 78fffffff7de7ff7H
  0066b	48 39 88 48 13
	00 00		 cmp	 QWORD PTR [rax+4936], rcx
  00672	75 0a		 jne	 SHORT $LN26@get_devblk
  00674	c7 44 24 70 01
	00 00 00	 mov	 DWORD PTR tv277[rsp], 1
  0067c	eb 08		 jmp	 SHORT $LN27@get_devblk
$LN26@get_devblk:
  0067e	c7 44 24 70 00
	00 00 00	 mov	 DWORD PTR tv277[rsp], 0
$LN27@get_devblk:
  00686	8b 44 24 70	 mov	 eax, DWORD PTR tv277[rsp]
  0068a	83 e0 01	 and	 eax, 1
  0068d	c1 e0 0d	 shl	 eax, 13
  00690	48 8b 4c 24 60	 mov	 rcx, QWORD PTR dev$[rsp]
  00695	8b 89 f8 05 00
	00		 mov	 ecx, DWORD PTR [rcx+1528]
  0069b	0f ba f1 0d	 btr	 ecx, 13
  0069f	0b c8		 or	 ecx, eax
  006a1	8b c1		 mov	 eax, ecx
  006a3	48 8b 4c 24 60	 mov	 rcx, QWORD PTR dev$[rsp]
  006a8	89 81 f8 05 00
	00		 mov	 DWORD PTR [rcx+1528], eax

; 710  : 
; 711  :     /* Initialize storage view */
; 712  :     dev->mainstor = sysblk.mainstor;

  006ae	48 8b 44 24 60	 mov	 rax, QWORD PTR dev$[rsp]
  006b3	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  006ba	48 8b 89 98 00
	00 00		 mov	 rcx, QWORD PTR [rcx+152]
  006c1	48 89 88 80 00
	00 00		 mov	 QWORD PTR [rax+128], rcx

; 713  :     dev->storkeys = sysblk.storkeys;

  006c8	48 8b 44 24 60	 mov	 rax, QWORD PTR dev$[rsp]
  006cd	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  006d4	48 8b 89 a0 00
	00 00		 mov	 rcx, QWORD PTR [rcx+160]
  006db	48 89 88 88 00
	00 00		 mov	 QWORD PTR [rax+136], rcx

; 714  :     dev->mainlim = sysblk.mainsize - 1;

  006e2	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  006e9	48 8b 80 90 00
	00 00		 mov	 rax, QWORD PTR [rax+144]
  006f0	48 ff c8	 dec	 rax
  006f3	48 8b 4c 24 60	 mov	 rcx, QWORD PTR dev$[rsp]
  006f8	48 89 81 90 00
	00 00		 mov	 QWORD PTR [rcx+144], rax

; 715  : 
; 716  :     /* Initialize the path management control word */
; 717  :     memset (&dev->pmcw, 0, sizeof(PMCW));

  006ff	48 8b 44 24 60	 mov	 rax, QWORD PTR dev$[rsp]
  00704	48 05 ec 02 00
	00		 add	 rax, 748		; 000002ecH
  0070a	48 8b f8	 mov	 rdi, rax
  0070d	33 c0		 xor	 eax, eax
  0070f	b9 1c 00 00 00	 mov	 ecx, 28
  00714	f3 aa		 rep stosb

; 718  :     dev->pmcw.devnum[0] = dev->devnum >> 8;

  00716	48 8b 44 24 60	 mov	 rax, QWORD PTR dev$[rsp]
  0071b	0f b7 40 48	 movzx	 eax, WORD PTR [rax+72]
  0071f	c1 f8 08	 sar	 eax, 8
  00722	b9 01 00 00 00	 mov	 ecx, 1
  00727	48 6b c9 00	 imul	 rcx, rcx, 0
  0072b	48 8b 54 24 60	 mov	 rdx, QWORD PTR dev$[rsp]
  00730	88 84 0a f2 02
	00 00		 mov	 BYTE PTR [rdx+rcx+754], al

; 719  :     dev->pmcw.devnum[1] = dev->devnum & 0xFF;

  00737	48 8b 44 24 60	 mov	 rax, QWORD PTR dev$[rsp]
  0073c	0f b7 40 48	 movzx	 eax, WORD PTR [rax+72]
  00740	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  00745	b9 01 00 00 00	 mov	 ecx, 1
  0074a	48 6b c9 01	 imul	 rcx, rcx, 1
  0074e	48 8b 54 24 60	 mov	 rdx, QWORD PTR dev$[rsp]
  00753	88 84 0a f2 02
	00 00		 mov	 BYTE PTR [rdx+rcx+754], al

; 720  :     dev->pmcw.lpm = 0x80;

  0075a	48 8b 44 24 60	 mov	 rax, QWORD PTR dev$[rsp]
  0075f	c6 80 f4 02 00
	00 80		 mov	 BYTE PTR [rax+756], 128	; 00000080H

; 721  :     dev->pmcw.pim = 0x80;

  00766	48 8b 44 24 60	 mov	 rax, QWORD PTR dev$[rsp]
  0076b	c6 80 f7 02 00
	00 80		 mov	 BYTE PTR [rax+759], 128	; 00000080H

; 722  :     dev->pmcw.pom = 0xFF;

  00772	48 8b 44 24 60	 mov	 rax, QWORD PTR dev$[rsp]
  00777	c6 80 fa 02 00
	00 ff		 mov	 BYTE PTR [rax+762], 255	; 000000ffH

; 723  :     dev->pmcw.pam = 0x80;

  0077e	48 8b 44 24 60	 mov	 rax, QWORD PTR dev$[rsp]
  00783	c6 80 fb 02 00
	00 80		 mov	 BYTE PTR [rax+763], 128	; 00000080H

; 724  :     dev->pmcw.chpid[0] = dev->devnum >> 8;

  0078a	48 8b 44 24 60	 mov	 rax, QWORD PTR dev$[rsp]
  0078f	0f b7 40 48	 movzx	 eax, WORD PTR [rax+72]
  00793	c1 f8 08	 sar	 eax, 8
  00796	b9 01 00 00 00	 mov	 ecx, 1
  0079b	48 6b c9 00	 imul	 rcx, rcx, 0
  0079f	48 8b 54 24 60	 mov	 rdx, QWORD PTR dev$[rsp]
  007a4	88 84 0a fc 02
	00 00		 mov	 BYTE PTR [rdx+rcx+764], al

; 725  : 
; 726  : #if defined(OPTION_SHARED_DEVICES)
; 727  :     dev->shrdwait = -1;

  007ab	48 8b 44 24 60	 mov	 rax, QWORD PTR dev$[rsp]
  007b0	c7 80 5c 06 00
	00 ff ff ff ff	 mov	 DWORD PTR [rax+1628], -1

; 728  : #endif /*defined(OPTION_SHARED_DEVICES)*/
; 729  : 
; 730  :     if (!dev->pGUIStat)

  007ba	48 8b 44 24 60	 mov	 rax, QWORD PTR dev$[rsp]
  007bf	48 83 b8 10 06
	00 00 00	 cmp	 QWORD PTR [rax+1552], 0
  007c7	75 7d		 jne	 SHORT $LN18@get_devblk

; 731  :     {
; 732  :          dev->pGUIStat = malloc( sizeof(GUISTAT) );

  007c9	b9 10 02 00 00	 mov	 ecx, 528		; 00000210H
  007ce	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_malloc
  007d4	48 8b 4c 24 60	 mov	 rcx, QWORD PTR dev$[rsp]
  007d9	48 89 81 10 06
	00 00		 mov	 QWORD PTR [rcx+1552], rax

; 733  :          dev->pGUIStat->pszOldStatStr = dev->pGUIStat->szStatStrBuff1;

  007e0	48 8b 44 24 60	 mov	 rax, QWORD PTR dev$[rsp]
  007e5	48 8b 80 10 06
	00 00		 mov	 rax, QWORD PTR [rax+1552]
  007ec	48 83 c0 10	 add	 rax, 16
  007f0	48 8b 4c 24 60	 mov	 rcx, QWORD PTR dev$[rsp]
  007f5	48 8b 89 10 06
	00 00		 mov	 rcx, QWORD PTR [rcx+1552]
  007fc	48 89 01	 mov	 QWORD PTR [rcx], rax

; 734  :          dev->pGUIStat->pszNewStatStr = dev->pGUIStat->szStatStrBuff2;

  007ff	48 8b 44 24 60	 mov	 rax, QWORD PTR dev$[rsp]
  00804	48 8b 80 10 06
	00 00		 mov	 rax, QWORD PTR [rax+1552]
  0080b	48 05 10 01 00
	00		 add	 rax, 272		; 00000110H
  00811	48 8b 4c 24 60	 mov	 rcx, QWORD PTR dev$[rsp]
  00816	48 8b 89 10 06
	00 00		 mov	 rcx, QWORD PTR [rcx+1552]
  0081d	48 89 41 08	 mov	 QWORD PTR [rcx+8], rax

; 735  :         *dev->pGUIStat->pszOldStatStr = 0;

  00821	48 8b 44 24 60	 mov	 rax, QWORD PTR dev$[rsp]
  00826	48 8b 80 10 06
	00 00		 mov	 rax, QWORD PTR [rax+1552]
  0082d	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00830	c6 00 00	 mov	 BYTE PTR [rax], 0

; 736  :         *dev->pGUIStat->pszNewStatStr = 0;

  00833	48 8b 44 24 60	 mov	 rax, QWORD PTR dev$[rsp]
  00838	48 8b 80 10 06
	00 00		 mov	 rax, QWORD PTR [rax+1552]
  0083f	48 8b 40 08	 mov	 rax, QWORD PTR [rax+8]
  00843	c6 00 00	 mov	 BYTE PTR [rax], 0
$LN18@get_devblk:

; 737  :     }
; 738  : 
; 739  :     /* Mark device valid */
; 740  :     dev->pmcw.flag5 |= PMCW5_V;

  00846	48 8b 44 24 60	 mov	 rax, QWORD PTR dev$[rsp]
  0084b	0f b6 80 f1 02
	00 00		 movzx	 eax, BYTE PTR [rax+753]
  00852	83 c8 01	 or	 eax, 1
  00855	48 8b 4c 24 60	 mov	 rcx, QWORD PTR dev$[rsp]
  0085a	88 81 f1 02 00
	00		 mov	 BYTE PTR [rcx+753], al

; 741  :     dev->allocated = 1;

  00860	48 8b 44 24 60	 mov	 rax, QWORD PTR dev$[rsp]
  00865	c7 40 40 01 00
	00 00		 mov	 DWORD PTR [rax+64], 1

; 742  : 
; 743  :     return dev;

  0086c	48 8b 44 24 60	 mov	 rax, QWORD PTR dev$[rsp]
$LN1@get_devblk:

; 744  : }

  00871	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  00879	48 33 cc	 xor	 rcx, rsp
  0087c	e8 00 00 00 00	 call	 __security_check_cookie
  00881	48 81 c4 d0 00
	00 00		 add	 rsp, 208		; 000000d0H
  00888	5f		 pop	 rdi
  00889	c3		 ret	 0
get_devblk ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\config.c
_TEXT	SEGMENT
schw$ = 0
ssid$ = 32
subchan$ = 40
DelSubchanFastLookup PROC

; 608  : {

  00000	66 89 54 24 10	 mov	 WORD PTR [rsp+16], dx
  00005	66 89 4c 24 08	 mov	 WORD PTR [rsp+8], cx
  0000a	48 83 ec 18	 sub	 rsp, 24

; 609  :     unsigned int schw;
; 610  :     if(sysblk.subchan_fl==NULL)

  0000e	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00015	48 83 b8 d8 11
	00 00 00	 cmp	 QWORD PTR [rax+4568], 0
  0001d	75 02		 jne	 SHORT $LN2@DelSubchan

; 611  :     {
; 612  :         return;

  0001f	eb 61		 jmp	 SHORT $LN1@DelSubchan
$LN2@DelSubchan:

; 613  :     }
; 614  :     schw=((subchan & 0xff00)>>8)|(SSID_TO_LCSS(ssid) << 8);

  00021	0f b7 44 24 28	 movzx	 eax, WORD PTR subchan$[rsp]
  00026	25 00 ff 00 00	 and	 eax, 65280		; 0000ff00H
  0002b	c1 f8 08	 sar	 eax, 8
  0002e	0f b7 4c 24 20	 movzx	 ecx, WORD PTR ssid$[rsp]
  00033	d1 f9		 sar	 ecx, 1
  00035	c1 e1 08	 shl	 ecx, 8
  00038	0b c1		 or	 eax, ecx
  0003a	89 04 24	 mov	 DWORD PTR schw$[rsp], eax

; 615  :     if(sysblk.subchan_fl[schw]==NULL)

  0003d	8b 04 24	 mov	 eax, DWORD PTR schw$[rsp]
  00040	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  00047	48 8b 89 d8 11
	00 00		 mov	 rcx, QWORD PTR [rcx+4568]
  0004e	48 83 3c c1 00	 cmp	 QWORD PTR [rcx+rax*8], 0
  00053	75 02		 jne	 SHORT $LN3@DelSubchan

; 616  :     {
; 617  :         return;

  00055	eb 2b		 jmp	 SHORT $LN1@DelSubchan
$LN3@DelSubchan:

; 618  :     }
; 619  :     sysblk.subchan_fl[schw][subchan & 0xff]=NULL;

  00057	8b 04 24	 mov	 eax, DWORD PTR schw$[rsp]
  0005a	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  00061	48 8b 89 d8 11
	00 00		 mov	 rcx, QWORD PTR [rcx+4568]
  00068	0f b7 54 24 28	 movzx	 edx, WORD PTR subchan$[rsp]
  0006d	81 e2 ff 00 00
	00		 and	 edx, 255		; 000000ffH
  00073	48 63 d2	 movsxd	 rdx, edx
  00076	48 8b 04 c1	 mov	 rax, QWORD PTR [rcx+rax*8]
  0007a	48 c7 04 d0 00
	00 00 00	 mov	 QWORD PTR [rax+rdx*8], 0
$LN1@DelSubchan:

; 620  : }

  00082	48 83 c4 18	 add	 rsp, 24
  00086	c3		 ret	 0
DelSubchanFastLookup ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\config.c
_TEXT	SEGMENT
Channel$ = 0
lcss$ = 32
devnum$ = 40
DelDevnumFastLookup PROC

; 593  : {

  00000	66 89 54 24 10	 mov	 WORD PTR [rsp+16], dx
  00005	66 89 4c 24 08	 mov	 WORD PTR [rsp+8], cx
  0000a	48 83 ec 18	 sub	 rsp, 24

; 594  :     unsigned int Channel;
; 595  :     if(sysblk.devnum_fl==NULL)

  0000e	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00015	48 83 b8 d0 11
	00 00 00	 cmp	 QWORD PTR [rax+4560], 0
  0001d	75 02		 jne	 SHORT $LN2@DelDevnumF

; 596  :     {
; 597  :         return;

  0001f	eb 62		 jmp	 SHORT $LN1@DelDevnumF
$LN2@DelDevnumF:

; 598  :     }
; 599  :     Channel=(devnum & 0xff00)>>8 | ((lcss & (FEATURE_LCSS_MAX-1))<<8);

  00021	0f b7 44 24 28	 movzx	 eax, WORD PTR devnum$[rsp]
  00026	25 00 ff 00 00	 and	 eax, 65280		; 0000ff00H
  0002b	c1 f8 08	 sar	 eax, 8
  0002e	0f b7 4c 24 20	 movzx	 ecx, WORD PTR lcss$[rsp]
  00033	83 e1 03	 and	 ecx, 3
  00036	c1 e1 08	 shl	 ecx, 8
  00039	0b c1		 or	 eax, ecx
  0003b	89 04 24	 mov	 DWORD PTR Channel$[rsp], eax

; 600  :     if(sysblk.devnum_fl[Channel]==NULL)

  0003e	8b 04 24	 mov	 eax, DWORD PTR Channel$[rsp]
  00041	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  00048	48 8b 89 d0 11
	00 00		 mov	 rcx, QWORD PTR [rcx+4560]
  0004f	48 83 3c c1 00	 cmp	 QWORD PTR [rcx+rax*8], 0
  00054	75 02		 jne	 SHORT $LN3@DelDevnumF

; 601  :     {
; 602  :         return;

  00056	eb 2b		 jmp	 SHORT $LN1@DelDevnumF
$LN3@DelDevnumF:

; 603  :     }
; 604  :     sysblk.devnum_fl[Channel][devnum & 0xff]=NULL;

  00058	8b 04 24	 mov	 eax, DWORD PTR Channel$[rsp]
  0005b	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  00062	48 8b 89 d0 11
	00 00		 mov	 rcx, QWORD PTR [rcx+4560]
  00069	0f b7 54 24 28	 movzx	 edx, WORD PTR devnum$[rsp]
  0006e	81 e2 ff 00 00
	00		 and	 edx, 255		; 000000ffH
  00074	48 63 d2	 movsxd	 rdx, edx
  00077	48 8b 04 c1	 mov	 rax, QWORD PTR [rcx+rax*8]
  0007b	48 c7 04 d0 00
	00 00 00	 mov	 QWORD PTR [rax+rdx*8], 0
$LN1@DelDevnumF:

; 605  : }

  00083	48 83 c4 18	 add	 rsp, 24
  00087	c3		 ret	 0
DelDevnumFastLookup ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\config.c
_TEXT	SEGMENT
schw$ = 32
have_config_lock$ = 36
dev$ = 64
ssid$ = 72
subchan$ = 80
AddSubchanFastLookup PROC

; 568  : {

  00000	66 44 89 44 24
	18		 mov	 WORD PTR [rsp+24], r8w
  00006	66 89 54 24 10	 mov	 WORD PTR [rsp+16], dx
  0000b	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00010	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 569  :     unsigned int schw;
; 570  : 
; 571  :     int  have_config_lock  = have_lock( &sysblk.config );

  00014	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  0001b	48 05 80 00 00
	00		 add	 rax, 128		; 00000080H
  00021	48 8b c8	 mov	 rcx, rax
  00024	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_have_lock
  0002a	89 44 24 24	 mov	 DWORD PTR have_config_lock$[rsp], eax

; 572  : 
; 573  :     if (!have_config_lock)

  0002e	83 7c 24 24 00	 cmp	 DWORD PTR have_config_lock$[rsp], 0
  00033	75 1d		 jne	 SHORT $LN2@AddSubchan

; 574  :         obtain_lock( &sysblk.config );

  00035	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  0003c	48 05 80 00 00
	00		 add	 rax, 128		; 00000080H
  00042	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG190127
  00049	48 8b c8	 mov	 rcx, rax
  0004c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_obtain_lock
$LN2@AddSubchan:

; 575  :     {
; 576  :         if (sysblk.subchan_fl == NULL)

  00052	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00059	48 83 b8 d8 11
	00 00 00	 cmp	 QWORD PTR [rax+4568], 0
  00061	75 1e		 jne	 SHORT $LN3@AddSubchan

; 577  :             sysblk.subchan_fl = (DEVBLK***)

  00063	ba 08 00 00 00	 mov	 edx, 8
  00068	b9 00 04 00 00	 mov	 ecx, 1024		; 00000400H
  0006d	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_calloc
  00073	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  0007a	48 89 81 d8 11
	00 00		 mov	 QWORD PTR [rcx+4568], rax
$LN3@AddSubchan:

; 578  :                 calloc( 256 * FEATURE_LCSS_MAX, sizeof( DEVBLK** ));
; 579  : 
; 580  :         schw = (subchan >> 8) | (SSID_TO_LCSS( ssid ) << 8);

  00081	0f b7 44 24 50	 movzx	 eax, WORD PTR subchan$[rsp]
  00086	c1 f8 08	 sar	 eax, 8
  00089	0f b7 4c 24 48	 movzx	 ecx, WORD PTR ssid$[rsp]
  0008e	d1 f9		 sar	 ecx, 1
  00090	c1 e1 08	 shl	 ecx, 8
  00093	0b c1		 or	 eax, ecx
  00095	89 44 24 20	 mov	 DWORD PTR schw$[rsp], eax

; 581  : 
; 582  :         if (sysblk.subchan_fl[schw] == NULL)

  00099	8b 44 24 20	 mov	 eax, DWORD PTR schw$[rsp]
  0009d	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  000a4	48 8b 89 d8 11
	00 00		 mov	 rcx, QWORD PTR [rcx+4568]
  000ab	48 83 3c c1 00	 cmp	 QWORD PTR [rcx+rax*8], 0
  000b0	75 26		 jne	 SHORT $LN4@AddSubchan

; 583  :             sysblk.subchan_fl[schw] = (DEVBLK**)

  000b2	ba 08 00 00 00	 mov	 edx, 8
  000b7	b9 00 01 00 00	 mov	 ecx, 256		; 00000100H
  000bc	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_calloc
  000c2	8b 4c 24 20	 mov	 ecx, DWORD PTR schw$[rsp]
  000c6	48 8b 15 00 00
	00 00		 mov	 rdx, QWORD PTR __imp_sysblk
  000cd	48 8b 92 d8 11
	00 00		 mov	 rdx, QWORD PTR [rdx+4568]
  000d4	48 89 04 ca	 mov	 QWORD PTR [rdx+rcx*8], rax
$LN4@AddSubchan:

; 584  :                 calloc( 256, sizeof( DEVBLK* ));
; 585  : 
; 586  :         sysblk.subchan_fl[schw][subchan & 0xff] = dev;

  000d8	8b 44 24 20	 mov	 eax, DWORD PTR schw$[rsp]
  000dc	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  000e3	48 8b 89 d8 11
	00 00		 mov	 rcx, QWORD PTR [rcx+4568]
  000ea	0f b7 54 24 50	 movzx	 edx, WORD PTR subchan$[rsp]
  000ef	81 e2 ff 00 00
	00		 and	 edx, 255		; 000000ffH
  000f5	48 63 d2	 movsxd	 rdx, edx
  000f8	48 8b 04 c1	 mov	 rax, QWORD PTR [rcx+rax*8]
  000fc	48 8b 4c 24 40	 mov	 rcx, QWORD PTR dev$[rsp]
  00101	48 89 0c d0	 mov	 QWORD PTR [rax+rdx*8], rcx

; 587  :     }
; 588  :     if (!have_config_lock)

  00105	83 7c 24 24 00	 cmp	 DWORD PTR have_config_lock$[rsp], 0
  0010a	75 1d		 jne	 SHORT $LN5@AddSubchan

; 589  :         release_lock( &sysblk.config );

  0010c	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00113	48 05 80 00 00
	00		 add	 rax, 128		; 00000080H
  00119	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG190131
  00120	48 8b c8	 mov	 rcx, rax
  00123	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_release_lock
$LN5@AddSubchan:

; 590  : }

  00129	48 83 c4 38	 add	 rsp, 56			; 00000038H
  0012d	c3		 ret	 0
AddSubchanFastLookup ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\config.c
_TEXT	SEGMENT
Channel$ = 32
have_config_lock$ = 36
dev$ = 64
lcss$ = 72
devnum$ = 80
AddDevnumFastLookup PROC

; 543  : {

  00000	66 44 89 44 24
	18		 mov	 WORD PTR [rsp+24], r8w
  00006	66 89 54 24 10	 mov	 WORD PTR [rsp+16], dx
  0000b	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00010	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 544  :     unsigned int Channel;
; 545  : 
; 546  :     int  have_config_lock  = have_lock( &sysblk.config );

  00014	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  0001b	48 05 80 00 00
	00		 add	 rax, 128		; 00000080H
  00021	48 8b c8	 mov	 rcx, rax
  00024	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_have_lock
  0002a	89 44 24 24	 mov	 DWORD PTR have_config_lock$[rsp], eax

; 547  : 
; 548  :     if (!have_config_lock)

  0002e	83 7c 24 24 00	 cmp	 DWORD PTR have_config_lock$[rsp], 0
  00033	75 1d		 jne	 SHORT $LN2@AddDevnumF

; 549  :         obtain_lock( &sysblk.config );

  00035	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  0003c	48 05 80 00 00
	00		 add	 rax, 128		; 00000080H
  00042	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG190105
  00049	48 8b c8	 mov	 rcx, rax
  0004c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_obtain_lock
$LN2@AddDevnumF:

; 550  :     {
; 551  :         if (sysblk.devnum_fl == NULL)

  00052	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00059	48 83 b8 d0 11
	00 00 00	 cmp	 QWORD PTR [rax+4560], 0
  00061	75 1e		 jne	 SHORT $LN3@AddDevnumF

; 552  :             sysblk.devnum_fl = (DEVBLK***)

  00063	ba 08 00 00 00	 mov	 edx, 8
  00068	b9 00 04 00 00	 mov	 ecx, 1024		; 00000400H
  0006d	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_calloc
  00073	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  0007a	48 89 81 d0 11
	00 00		 mov	 QWORD PTR [rcx+4560], rax
$LN3@AddDevnumF:

; 553  :                 calloc( 256 * FEATURE_LCSS_MAX, sizeof( DEVBLK** ));
; 554  : 
; 555  :         Channel = (devnum >> 8) | ((lcss & (FEATURE_LCSS_MAX-1)) << 8);

  00081	0f b7 44 24 50	 movzx	 eax, WORD PTR devnum$[rsp]
  00086	c1 f8 08	 sar	 eax, 8
  00089	0f b7 4c 24 48	 movzx	 ecx, WORD PTR lcss$[rsp]
  0008e	83 e1 03	 and	 ecx, 3
  00091	c1 e1 08	 shl	 ecx, 8
  00094	0b c1		 or	 eax, ecx
  00096	89 44 24 20	 mov	 DWORD PTR Channel$[rsp], eax

; 556  : 
; 557  :         if (sysblk.devnum_fl[Channel] == NULL)

  0009a	8b 44 24 20	 mov	 eax, DWORD PTR Channel$[rsp]
  0009e	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  000a5	48 8b 89 d0 11
	00 00		 mov	 rcx, QWORD PTR [rcx+4560]
  000ac	48 83 3c c1 00	 cmp	 QWORD PTR [rcx+rax*8], 0
  000b1	75 26		 jne	 SHORT $LN4@AddDevnumF

; 558  :             sysblk.devnum_fl[Channel] = (DEVBLK**)

  000b3	ba 08 00 00 00	 mov	 edx, 8
  000b8	b9 00 01 00 00	 mov	 ecx, 256		; 00000100H
  000bd	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_calloc
  000c3	8b 4c 24 20	 mov	 ecx, DWORD PTR Channel$[rsp]
  000c7	48 8b 15 00 00
	00 00		 mov	 rdx, QWORD PTR __imp_sysblk
  000ce	48 8b 92 d0 11
	00 00		 mov	 rdx, QWORD PTR [rdx+4560]
  000d5	48 89 04 ca	 mov	 QWORD PTR [rdx+rcx*8], rax
$LN4@AddDevnumF:

; 559  :                 calloc( 256, sizeof( DEVBLK* ));
; 560  : 
; 561  :         sysblk.devnum_fl[Channel][devnum & 0xff] = dev;

  000d9	8b 44 24 20	 mov	 eax, DWORD PTR Channel$[rsp]
  000dd	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  000e4	48 8b 89 d0 11
	00 00		 mov	 rcx, QWORD PTR [rcx+4560]
  000eb	0f b7 54 24 50	 movzx	 edx, WORD PTR devnum$[rsp]
  000f0	81 e2 ff 00 00
	00		 and	 edx, 255		; 000000ffH
  000f6	48 63 d2	 movsxd	 rdx, edx
  000f9	48 8b 04 c1	 mov	 rax, QWORD PTR [rcx+rax*8]
  000fd	48 8b 4c 24 40	 mov	 rcx, QWORD PTR dev$[rsp]
  00102	48 89 0c d0	 mov	 QWORD PTR [rax+rdx*8], rcx

; 562  :     }
; 563  :     if (!have_config_lock)

  00106	83 7c 24 24 00	 cmp	 DWORD PTR have_config_lock$[rsp], 0
  0010b	75 1d		 jne	 SHORT $LN5@AddDevnumF

; 564  :         release_lock( &sysblk.config );

  0010d	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00114	48 05 80 00 00
	00		 add	 rax, 128		; 00000080H
  0011a	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG190109
  00121	48 8b c8	 mov	 rcx, rax
  00124	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_release_lock
$LN5@AddDevnumF:

; 565  : }

  0012a	48 83 c4 38	 add	 rsp, 56			; 00000038H
  0012e	c3		 ret	 0
AddDevnumFastLookup ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\config.c
_TEXT	SEGMENT
i$ = 0
dev$ = 8
tv150 = 16
tv180 = 24
configure_region_reloc PROC

; 104  : {

  00000	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 105  :     DEVBLK*  dev;
; 106  :     int      i;
; 107  : 
; 108  : #if defined(_FEATURE_REGION_RELOCATE)
; 109  : 
; 110  :     /* Initialize base zone storage view (SIE compat) */
; 111  :     for (i=0; i < FEATURE_SIE_MAXZONES; i++)

  00004	c7 04 24 00 00
	00 00		 mov	 DWORD PTR i$[rsp], 0
  0000b	eb 08		 jmp	 SHORT $LN4@configure_
$LN2@configure_:
  0000d	8b 04 24	 mov	 eax, DWORD PTR i$[rsp]
  00010	ff c0		 inc	 eax
  00012	89 04 24	 mov	 DWORD PTR i$[rsp], eax
$LN4@configure_:
  00015	83 3c 24 08	 cmp	 DWORD PTR i$[rsp], 8
  00019	0f 8d e1 00 00
	00		 jge	 $LN3@configure_

; 112  :     {
; 113  :         sysblk.zpb[i].mso = 0;

  0001f	48 63 04 24	 movsxd	 rax, DWORD PTR i$[rsp]
  00023	48 6b c0 38	 imul	 rax, rax, 56		; 00000038H
  00027	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  0002e	48 c7 84 01 a0
	0e 00 00 00 00
	00 00		 mov	 QWORD PTR [rcx+rax+3744], 0

; 114  :         sysblk.zpb[i].msl = (sysblk.mainsize - 1) >> SHIFT_MEGABYTE;

  0003a	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00041	48 8b 80 90 00
	00 00		 mov	 rax, QWORD PTR [rax+144]
  00048	48 ff c8	 dec	 rax
  0004b	48 c1 e8 14	 shr	 rax, 20
  0004f	48 63 0c 24	 movsxd	 rcx, DWORD PTR i$[rsp]
  00053	48 6b c9 38	 imul	 rcx, rcx, 56		; 00000038H
  00057	48 8b 15 00 00
	00 00		 mov	 rdx, QWORD PTR __imp_sysblk
  0005e	48 89 84 0a a8
	0e 00 00	 mov	 QWORD PTR [rdx+rcx+3752], rax

; 115  : 
; 116  :         if (sysblk.xpndsize)

  00066	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  0006d	83 b8 ac 00 00
	00 00		 cmp	 DWORD PTR [rax+172], 0
  00074	74 4f		 je	 SHORT $LN11@configure_

; 117  :         {
; 118  :             sysblk.zpb[i].eso = 0;

  00076	48 63 04 24	 movsxd	 rax, DWORD PTR i$[rsp]
  0007a	48 6b c0 38	 imul	 rax, rax, 56		; 00000038H
  0007e	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  00085	48 c7 84 01 b0
	0e 00 00 00 00
	00 00		 mov	 QWORD PTR [rcx+rax+3760], 0

; 119  :             sysblk.zpb[i].esl = ((size_t)sysblk.xpndsize * XSTORE_PAGESIZE - 1) >> SHIFT_MEGABYTE;

  00091	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00098	8b 80 ac 00 00
	00		 mov	 eax, DWORD PTR [rax+172]
  0009e	48 69 c0 00 10
	00 00		 imul	 rax, rax, 4096		; 00001000H
  000a5	48 ff c8	 dec	 rax
  000a8	48 c1 e8 14	 shr	 rax, 20
  000ac	48 63 0c 24	 movsxd	 rcx, DWORD PTR i$[rsp]
  000b0	48 6b c9 38	 imul	 rcx, rcx, 56		; 00000038H
  000b4	48 8b 15 00 00
	00 00		 mov	 rdx, QWORD PTR __imp_sysblk
  000bb	48 89 84 0a b8
	0e 00 00	 mov	 QWORD PTR [rdx+rcx+3768], rax

; 120  :         }

  000c3	eb 36		 jmp	 SHORT $LN12@configure_
$LN11@configure_:

; 121  :         else
; 122  :         {
; 123  :             sysblk.zpb[i].eso = -1;

  000c5	48 63 04 24	 movsxd	 rax, DWORD PTR i$[rsp]
  000c9	48 6b c0 38	 imul	 rax, rax, 56		; 00000038H
  000cd	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  000d4	48 c7 84 01 b0
	0e 00 00 ff ff
	ff ff		 mov	 QWORD PTR [rcx+rax+3760], -1

; 124  :             sysblk.zpb[i].esl = -1;

  000e0	48 63 04 24	 movsxd	 rax, DWORD PTR i$[rsp]
  000e4	48 6b c0 38	 imul	 rax, rax, 56		; 00000038H
  000e8	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  000ef	48 c7 84 01 b8
	0e 00 00 ff ff
	ff ff		 mov	 QWORD PTR [rcx+rax+3768], -1
$LN12@configure_:

; 125  :         }
; 126  :     }

  000fb	e9 0d ff ff ff	 jmp	 $LN2@configure_
$LN3@configure_:

; 127  : #endif
; 128  : 
; 129  :     /* Relocate storage for all devices */
; 130  :     for (dev = sysblk.firstdev; dev; dev = dev->nextdev)

  00100	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00107	48 8b 80 c0 11
	00 00		 mov	 rax, QWORD PTR [rax+4544]
  0010e	48 89 44 24 08	 mov	 QWORD PTR dev$[rsp], rax
  00113	eb 0e		 jmp	 SHORT $LN7@configure_
$LN5@configure_:
  00115	48 8b 44 24 08	 mov	 rax, QWORD PTR dev$[rsp]
  0011a	48 8b 40 30	 mov	 rax, QWORD PTR [rax+48]
  0011e	48 89 44 24 08	 mov	 QWORD PTR dev$[rsp], rax
$LN7@configure_:
  00123	48 83 7c 24 08
	00		 cmp	 QWORD PTR dev$[rsp], 0
  00129	74 7c		 je	 SHORT $LN6@configure_

; 131  :     {
; 132  :         dev->mainstor = sysblk.mainstor;

  0012b	48 8b 44 24 08	 mov	 rax, QWORD PTR dev$[rsp]
  00130	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  00137	48 8b 89 98 00
	00 00		 mov	 rcx, QWORD PTR [rcx+152]
  0013e	48 89 88 80 00
	00 00		 mov	 QWORD PTR [rax+128], rcx

; 133  :         dev->storkeys = sysblk.storkeys;

  00145	48 8b 44 24 08	 mov	 rax, QWORD PTR dev$[rsp]
  0014a	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  00151	48 8b 89 a0 00
	00 00		 mov	 rcx, QWORD PTR [rcx+160]
  00158	48 89 88 88 00
	00 00		 mov	 QWORD PTR [rax+136], rcx

; 134  :         dev->mainlim  = sysblk.mainsize ? (sysblk.mainsize - 1) : 0;

  0015f	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00166	48 83 b8 90 00
	00 00 00	 cmp	 QWORD PTR [rax+144], 0
  0016e	74 18		 je	 SHORT $LN15@configure_
  00170	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00177	48 8b 80 90 00
	00 00		 mov	 rax, QWORD PTR [rax+144]
  0017e	48 ff c8	 dec	 rax
  00181	48 89 44 24 10	 mov	 QWORD PTR tv150[rsp], rax
  00186	eb 09		 jmp	 SHORT $LN16@configure_
$LN15@configure_:
  00188	48 c7 44 24 10
	00 00 00 00	 mov	 QWORD PTR tv150[rsp], 0
$LN16@configure_:
  00191	48 8b 44 24 08	 mov	 rax, QWORD PTR dev$[rsp]
  00196	48 8b 4c 24 10	 mov	 rcx, QWORD PTR tv150[rsp]
  0019b	48 89 88 90 00
	00 00		 mov	 QWORD PTR [rax+144], rcx

; 135  :     }

  001a2	e9 6e ff ff ff	 jmp	 $LN5@configure_
$LN6@configure_:

; 136  : 
; 137  :     /* Relocate storage for all online cpus */
; 138  :     for (i=0; i < sysblk.maxcpu; i++)

  001a7	c7 04 24 00 00
	00 00		 mov	 DWORD PTR i$[rsp], 0
  001ae	eb 08		 jmp	 SHORT $LN10@configure_
$LN8@configure_:
  001b0	8b 04 24	 mov	 eax, DWORD PTR i$[rsp]
  001b3	ff c0		 inc	 eax
  001b5	89 04 24	 mov	 DWORD PTR i$[rsp], eax
$LN10@configure_:
  001b8	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  001bf	8b 80 00 01 00
	00		 mov	 eax, DWORD PTR [rax+256]
  001c5	39 04 24	 cmp	 DWORD PTR i$[rsp], eax
  001c8	0f 8d c0 00 00
	00		 jge	 $LN9@configure_

; 139  :         if (IS_CPU_ONLINE( i ))

  001ce	48 63 04 24	 movsxd	 rax, DWORD PTR i$[rsp]
  001d2	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  001d9	48 83 bc c1 98
	0b 00 00 00	 cmp	 QWORD PTR [rcx+rax*8+2968], 0
  001e2	0f 84 a1 00 00
	00		 je	 $LN13@configure_

; 140  :         {
; 141  :             sysblk.regs[i]->storkeys = sysblk.storkeys;

  001e8	48 63 04 24	 movsxd	 rax, DWORD PTR i$[rsp]
  001ec	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  001f3	48 8b 84 c1 98
	0b 00 00	 mov	 rax, QWORD PTR [rcx+rax*8+2968]
  001fb	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  00202	48 8b 89 a0 00
	00 00		 mov	 rcx, QWORD PTR [rcx+160]
  00209	48 89 88 50 08
	00 00		 mov	 QWORD PTR [rax+2128], rcx

; 142  :             sysblk.regs[i]->mainstor = sysblk.mainstor;

  00210	48 63 04 24	 movsxd	 rax, DWORD PTR i$[rsp]
  00214	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  0021b	48 8b 84 c1 98
	0b 00 00	 mov	 rax, QWORD PTR [rcx+rax*8+2968]
  00223	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  0022a	48 8b 89 98 00
	00 00		 mov	 rcx, QWORD PTR [rcx+152]
  00231	48 89 88 48 08
	00 00		 mov	 QWORD PTR [rax+2120], rcx

; 143  :             sysblk.regs[i]->mainlim  = sysblk.mainsize ? (sysblk.mainsize - 1) : 0;

  00238	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  0023f	48 83 b8 90 00
	00 00 00	 cmp	 QWORD PTR [rax+144], 0
  00247	74 18		 je	 SHORT $LN17@configure_
  00249	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00250	48 8b 80 90 00
	00 00		 mov	 rax, QWORD PTR [rax+144]
  00257	48 ff c8	 dec	 rax
  0025a	48 89 44 24 18	 mov	 QWORD PTR tv180[rsp], rax
  0025f	eb 09		 jmp	 SHORT $LN18@configure_
$LN17@configure_:
  00261	48 c7 44 24 18
	00 00 00 00	 mov	 QWORD PTR tv180[rsp], 0
$LN18@configure_:
  0026a	48 63 04 24	 movsxd	 rax, DWORD PTR i$[rsp]
  0026e	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  00275	48 8b 84 c1 98
	0b 00 00	 mov	 rax, QWORD PTR [rcx+rax*8+2968]
  0027d	48 8b 4c 24 18	 mov	 rcx, QWORD PTR tv180[rsp]
  00282	48 89 88 58 08
	00 00		 mov	 QWORD PTR [rax+2136], rcx
$LN13@configure_:

; 144  :         }

  00289	e9 22 ff ff ff	 jmp	 $LN8@configure_
$LN9@configure_:

; 145  : }

  0028e	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00292	c3		 ret	 0
configure_region_reloc ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\hinlines.h
_TEXT	SEGMENT
any_started$ = 32
are_any_cpus_started PROC

; 531  : {

  00000	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 532  :     bool any_started;
; 533  : 
; 534  :     OBTAIN_INTLOCK( NULL );

  00004	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG158966
  0000b	33 c9		 xor	 ecx, ecx
  0000d	e8 00 00 00 00	 call	 Obtain_Interrupt_Lock

; 535  :     {
; 536  :         any_started = are_any_cpus_started_intlock_held();

  00012	e8 00 00 00 00	 call	 are_any_cpus_started_intlock_held
  00017	88 44 24 20	 mov	 BYTE PTR any_started$[rsp], al

; 537  :     }
; 538  :     RELEASE_INTLOCK( NULL );

  0001b	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG158967
  00022	33 c9		 xor	 ecx, ecx
  00024	e8 00 00 00 00	 call	 Release_Interrupt_Lock

; 539  :     return any_started;

  00029	0f b6 44 24 20	 movzx	 eax, BYTE PTR any_started$[rsp]

; 540  : }

  0002e	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00032	c3		 ret	 0
are_any_cpus_started ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\hinlines.h
_TEXT	SEGMENT
cpu$ = 0
are_all_cpus_stopped_intlock_held PROC

; 516  : {

  00000	48 83 ec 18	 sub	 rsp, 24

; 517  :     int cpu;
; 518  : 
; 519  :     if (sysblk.cpus)

  00004	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  0000b	83 b8 04 01 00
	00 00		 cmp	 DWORD PTR [rax+260], 0
  00012	74 5b		 je	 SHORT $LN5@are_all_cp

; 520  :         for (cpu = 0; cpu < sysblk.hicpu; cpu++)

  00014	c7 04 24 00 00
	00 00		 mov	 DWORD PTR cpu$[rsp], 0
  0001b	eb 08		 jmp	 SHORT $LN4@are_all_cp
$LN2@are_all_cp:
  0001d	8b 04 24	 mov	 eax, DWORD PTR cpu$[rsp]
  00020	ff c0		 inc	 eax
  00022	89 04 24	 mov	 DWORD PTR cpu$[rsp], eax
$LN4@are_all_cp:
  00025	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  0002c	8b 80 08 01 00
	00		 mov	 eax, DWORD PTR [rax+264]
  00032	39 04 24	 cmp	 DWORD PTR cpu$[rsp], eax
  00035	7d 38		 jge	 SHORT $LN3@are_all_cp

; 521  :             if (IS_CPU_ONLINE( cpu ))

  00037	48 63 04 24	 movsxd	 rax, DWORD PTR cpu$[rsp]
  0003b	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  00042	48 83 bc c1 98
	0b 00 00 00	 cmp	 QWORD PTR [rcx+rax*8+2968], 0
  0004b	74 20		 je	 SHORT $LN6@are_all_cp

; 522  :                 if (sysblk.regs[ cpu ]->cpustate != CPUSTATE_STOPPED)

  0004d	48 63 04 24	 movsxd	 rax, DWORD PTR cpu$[rsp]
  00051	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  00058	48 8b 84 c1 98
	0b 00 00	 mov	 rax, QWORD PTR [rcx+rax*8+2968]
  00060	0f b6 40 60	 movzx	 eax, BYTE PTR [rax+96]
  00064	83 f8 03	 cmp	 eax, 3
  00067	74 04		 je	 SHORT $LN7@are_all_cp

; 523  :                     return false;

  00069	32 c0		 xor	 al, al
  0006b	eb 04		 jmp	 SHORT $LN1@are_all_cp
$LN7@are_all_cp:
$LN6@are_all_cp:
  0006d	eb ae		 jmp	 SHORT $LN2@are_all_cp
$LN3@are_all_cp:
$LN5@are_all_cp:

; 524  :     return true;

  0006f	b0 01		 mov	 al, 1
$LN1@are_all_cp:

; 525  : }

  00071	48 83 c4 18	 add	 rsp, 24
  00075	c3		 ret	 0
are_all_cpus_stopped_intlock_held ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\hinlines.h
_TEXT	SEGMENT
cpu$ = 0
are_any_cpus_started_intlock_held PROC

; 501  : {

  00000	48 83 ec 18	 sub	 rsp, 24

; 502  :     int cpu;
; 503  : 
; 504  :     if (sysblk.cpus)

  00004	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  0000b	83 b8 04 01 00
	00 00		 cmp	 DWORD PTR [rax+260], 0
  00012	74 5b		 je	 SHORT $LN5@are_any_cp

; 505  :         for (cpu = 0; cpu < sysblk.hicpu; cpu++)

  00014	c7 04 24 00 00
	00 00		 mov	 DWORD PTR cpu$[rsp], 0
  0001b	eb 08		 jmp	 SHORT $LN4@are_any_cp
$LN2@are_any_cp:
  0001d	8b 04 24	 mov	 eax, DWORD PTR cpu$[rsp]
  00020	ff c0		 inc	 eax
  00022	89 04 24	 mov	 DWORD PTR cpu$[rsp], eax
$LN4@are_any_cp:
  00025	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  0002c	8b 80 08 01 00
	00		 mov	 eax, DWORD PTR [rax+264]
  00032	39 04 24	 cmp	 DWORD PTR cpu$[rsp], eax
  00035	7d 38		 jge	 SHORT $LN3@are_any_cp

; 506  :             if (IS_CPU_ONLINE( cpu ))

  00037	48 63 04 24	 movsxd	 rax, DWORD PTR cpu$[rsp]
  0003b	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  00042	48 83 bc c1 98
	0b 00 00 00	 cmp	 QWORD PTR [rcx+rax*8+2968], 0
  0004b	74 20		 je	 SHORT $LN6@are_any_cp

; 507  :                 if (sysblk.regs[ cpu ]->cpustate == CPUSTATE_STARTED)

  0004d	48 63 04 24	 movsxd	 rax, DWORD PTR cpu$[rsp]
  00051	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  00058	48 8b 84 c1 98
	0b 00 00	 mov	 rax, QWORD PTR [rcx+rax*8+2968]
  00060	0f b6 40 60	 movzx	 eax, BYTE PTR [rax+96]
  00064	83 f8 01	 cmp	 eax, 1
  00067	75 04		 jne	 SHORT $LN7@are_any_cp

; 508  :                     return true;

  00069	b0 01		 mov	 al, 1
  0006b	eb 04		 jmp	 SHORT $LN1@are_any_cp
$LN7@are_any_cp:
$LN6@are_any_cp:
  0006d	eb ae		 jmp	 SHORT $LN2@are_any_cp
$LN3@are_any_cp:
$LN5@are_any_cp:

; 509  :     return false;

  0006f	32 c0		 xor	 al, al
$LN1@are_any_cp:

; 510  : }

  00071	48 83 c4 18	 add	 rsp, 24
  00075	c3		 ret	 0
are_any_cpus_started_intlock_held ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\hinlines.h
_TEXT	SEGMENT
regs$ = 48
location$ = 56
Release_Interrupt_Lock PROC

; 403  : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 28	 sub	 rsp, 40			; 00000028H
$LN4@Release_In:

; 404  :     UNREFERENCED( regs );

  0000e	33 c0		 xor	 eax, eax
  00010	85 c0		 test	 eax, eax
  00012	75 fa		 jne	 SHORT $LN4@Release_In

; 405  :     sysblk.intowner = LOCK_OWNER_NONE;

  00014	b8 ff ff 00 00	 mov	 eax, 65535		; 0000ffffH
  00019	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  00020	66 89 81 62 10
	00 00		 mov	 WORD PTR [rcx+4194], ax

; 406  :     hthread_release_lock( &sysblk.intlock, location );

  00027	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  0002e	48 05 70 10 00
	00		 add	 rax, 4208		; 00001070H
  00034	48 8b 54 24 38	 mov	 rdx, QWORD PTR location$[rsp]
  00039	48 8b c8	 mov	 rcx, rax
  0003c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_release_lock

; 407  : }

  00042	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00046	c3		 ret	 0
Release_Interrupt_Lock ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\hinlines.h
_TEXT	SEGMENT
regs$ = 48
location$ = 56
Obtain_Interrupt_Lock PROC

; 379  : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 380  :     if (regs)

  0000e	48 83 7c 24 30
	00		 cmp	 QWORD PTR regs$[rsp], 0
  00014	74 13		 je	 SHORT $LN2@Obtain_Int

; 381  :         HOSTREGS->intwait = true;

  00016	48 8b 44 24 30	 mov	 rax, QWORD PTR regs$[rsp]
  0001b	48 8b 80 68 08
	00 00		 mov	 rax, QWORD PTR [rax+2152]
  00022	c6 80 f0 08 00
	00 01		 mov	 BYTE PTR [rax+2288], 1
$LN2@Obtain_Int:

; 382  :     hthread_obtain_lock( &sysblk.intlock, location );

  00029	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00030	48 05 70 10 00
	00		 add	 rax, 4208		; 00001070H
  00036	48 8b 54 24 38	 mov	 rdx, QWORD PTR location$[rsp]
  0003b	48 8b c8	 mov	 rcx, rax
  0003e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_obtain_lock

; 383  :     Interrupt_Lock_Obtained( regs, location );

  00044	48 8b 54 24 38	 mov	 rdx, QWORD PTR location$[rsp]
  00049	48 8b 4c 24 30	 mov	 rcx, QWORD PTR regs$[rsp]
  0004e	e8 00 00 00 00	 call	 Interrupt_Lock_Obtained

; 384  : }

  00053	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00057	c3		 ret	 0
Obtain_Interrupt_Lock ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\hinlines.h
_TEXT	SEGMENT
regs$ = 48
location$ = 56
Interrupt_Lock_Obtained PROC

; 347  : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 348  :     if (regs)

  0000e	48 83 7c 24 30
	00		 cmp	 QWORD PTR regs$[rsp], 0
  00014	0f 84 db 00 00
	00		 je	 $LN4@Interrupt_
$LN2@Interrupt_:

; 349  :     {
; 350  :         /* Wait for any SYNCHRONIZE_CPUS to finish before proceeding */
; 351  :         while (sysblk.syncing)

  0001a	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00021	0f b6 80 7c 13
	00 00		 movzx	 eax, BYTE PTR [rax+4988]
  00028	85 c0		 test	 eax, eax
  0002a	0f 84 8f 00 00
	00		 je	 $LN3@Interrupt_

; 352  :         {
; 353  :             /* Indicate we have reached the sync point */
; 354  :             sysblk.sync_mask &= ~HOSTREGS->cpubit;

  00030	48 8b 44 24 30	 mov	 rax, QWORD PTR regs$[rsp]
  00035	48 8b 80 68 08
	00 00		 mov	 rax, QWORD PTR [rax+2152]
  0003c	48 8b 40 50	 mov	 rax, QWORD PTR [rax+80]
  00040	48 f7 d0	 not	 rax
  00043	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  0004a	48 8b 89 80 13
	00 00		 mov	 rcx, QWORD PTR [rcx+4992]
  00051	48 23 c8	 and	 rcx, rax
  00054	48 8b c1	 mov	 rax, rcx
  00057	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  0005e	48 89 81 80 13
	00 00		 mov	 QWORD PTR [rcx+4992], rax

; 355  : 
; 356  :             /* If we're the last CPU to reach this sync point,
; 357  :                signal the CPU that requested the sync that it
; 358  :                may now safely proceed with its exclusive logic.
; 359  :             */
; 360  :             if (!sysblk.sync_mask)

  00065	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  0006c	48 83 b8 80 13
	00 00 00	 cmp	 QWORD PTR [rax+4992], 0
  00074	75 1b		 jne	 SHORT $LN6@Interrupt_

; 361  :                 hthread_signal_condition( &sysblk.all_synced_cond, location );

  00076	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  0007d	48 05 88 13 00
	00		 add	 rax, 5000		; 00001388H
  00083	48 8b 54 24 38	 mov	 rdx, QWORD PTR location$[rsp]
  00088	48 8b c8	 mov	 rcx, rax
  0008b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_signal_condition
$LN6@Interrupt_:

; 362  : 
; 363  :             /* Wait for CPU that requested the sync to indicate
; 364  :                it's done and thus is now safe for us to proceed.
; 365  :             */
; 366  :             hthread_wait_condition( &sysblk.sync_done_cond, &sysblk.intlock, location );

  00091	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00098	48 05 70 10 00
	00		 add	 rax, 4208		; 00001070H
  0009e	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  000a5	48 81 c1 90 13
	00 00		 add	 rcx, 5008		; 00001390H
  000ac	4c 8b 44 24 38	 mov	 r8, QWORD PTR location$[rsp]
  000b1	48 8b d0	 mov	 rdx, rax
  000b4	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_wait_condition

; 367  :         }

  000ba	e9 5b ff ff ff	 jmp	 $LN2@Interrupt_
$LN3@Interrupt_:

; 368  : 
; 369  :         HOSTREGS->intwait = false;

  000bf	48 8b 44 24 30	 mov	 rax, QWORD PTR regs$[rsp]
  000c4	48 8b 80 68 08
	00 00		 mov	 rax, QWORD PTR [rax+2152]
  000cb	c6 80 f0 08 00
	00 00		 mov	 BYTE PTR [rax+2288], 0

; 370  :         sysblk.intowner = HOSTREGS->cpuad;

  000d2	48 8b 44 24 30	 mov	 rax, QWORD PTR regs$[rsp]
  000d7	48 8b 80 68 08
	00 00		 mov	 rax, QWORD PTR [rax+2152]
  000de	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  000e5	0f b7 80 3c 08
	00 00		 movzx	 eax, WORD PTR [rax+2108]
  000ec	66 89 81 62 10
	00 00		 mov	 WORD PTR [rcx+4194], ax

; 371  :     }

  000f3	eb 13		 jmp	 SHORT $LN5@Interrupt_
$LN4@Interrupt_:

; 372  :     else
; 373  :         sysblk.intowner = LOCK_OWNER_OTHER;

  000f5	b8 fe ff 00 00	 mov	 eax, 65534		; 0000fffeH
  000fa	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  00101	66 89 81 62 10
	00 00		 mov	 WORD PTR [rcx+4194], ax
$LN5@Interrupt_:

; 374  : }

  00108	48 83 c4 28	 add	 rsp, 40			; 00000028H
  0010c	c3		 ret	 0
Interrupt_Lock_Obtained ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\hinlines.h
_TEXT	SEGMENT
regs$ = 48
location$ = 56
wakeup_cpu PROC

; 268  : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 269  :     hthread_signal_condition( &regs->intcond, location );

  0000e	48 8b 44 24 30	 mov	 rax, QWORD PTR regs$[rsp]
  00013	48 05 80 0c 00
	00		 add	 rax, 3200		; 00000c80H
  00019	48 8b 54 24 38	 mov	 rdx, QWORD PTR location$[rsp]
  0001e	48 8b c8	 mov	 rcx, rax
  00021	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_signal_condition

; 270  : }

  00027	48 83 c4 28	 add	 rsp, 40			; 00000028H
  0002b	c3		 ret	 0
wakeup_cpu ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\config.c
_TEXT	SEGMENT
i$ = 32
tid$ = 36
cpunum$ = 64
are_cpu_thread PROC

; 1004 : {

$LN9:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 1005 :     TID  tid  = thread_id();

  00009	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fthread_self
  0000f	89 44 24 24	 mov	 DWORD PTR tid$[rsp], eax

; 1006 :     int  i;
; 1007 : 
; 1008 :     for (i=0; i < sysblk.maxcpu; i++)

  00013	c7 44 24 20 00
	00 00 00	 mov	 DWORD PTR i$[rsp], 0
  0001b	eb 0a		 jmp	 SHORT $LN4@are_cpu_th
$LN2@are_cpu_th:
  0001d	8b 44 24 20	 mov	 eax, DWORD PTR i$[rsp]
  00021	ff c0		 inc	 eax
  00023	89 44 24 20	 mov	 DWORD PTR i$[rsp], eax
$LN4@are_cpu_th:
  00027	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  0002e	8b 80 00 01 00
	00		 mov	 eax, DWORD PTR [rax+256]
  00034	39 44 24 20	 cmp	 DWORD PTR i$[rsp], eax
  00038	7d 3a		 jge	 SHORT $LN3@are_cpu_th

; 1009 :     {
; 1010 :         if (equal_threads( sysblk.cputid[ i ], tid ))

  0003a	48 63 44 24 20	 movsxd	 rax, DWORD PTR i$[rsp]
  0003f	8b 54 24 24	 mov	 edx, DWORD PTR tid$[rsp]
  00043	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  0004a	8b 8c 81 48 09
	00 00		 mov	 ecx, DWORD PTR [rcx+rax*4+2376]
  00051	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_equal_threads
  00057	85 c0		 test	 eax, eax
  00059	74 17		 je	 SHORT $LN5@are_cpu_th

; 1011 :         {
; 1012 :             if (cpunum)

  0005b	48 83 7c 24 40
	00		 cmp	 QWORD PTR cpunum$[rsp], 0
  00061	74 0b		 je	 SHORT $LN6@are_cpu_th

; 1013 :                 *cpunum = i;

  00063	48 8b 44 24 40	 mov	 rax, QWORD PTR cpunum$[rsp]
  00068	8b 4c 24 20	 mov	 ecx, DWORD PTR i$[rsp]
  0006c	89 08		 mov	 DWORD PTR [rax], ecx
$LN6@are_cpu_th:

; 1014 :             return true;        // (we ARE a CPU thread)

  0006e	b0 01		 mov	 al, 1
  00070	eb 17		 jmp	 SHORT $LN1@are_cpu_th
$LN5@are_cpu_th:

; 1015 :         }
; 1016 :     }

  00072	eb a9		 jmp	 SHORT $LN2@are_cpu_th
$LN3@are_cpu_th:

; 1017 : 
; 1018 :     if (cpunum)

  00074	48 83 7c 24 40
	00		 cmp	 QWORD PTR cpunum$[rsp], 0
  0007a	74 0b		 je	 SHORT $LN7@are_cpu_th

; 1019 :         *cpunum = -1;

  0007c	48 8b 44 24 40	 mov	 rax, QWORD PTR cpunum$[rsp]
  00081	c7 00 ff ff ff
	ff		 mov	 DWORD PTR [rax], -1
$LN7@are_cpu_th:

; 1020 : 
; 1021 :     return false;               // (we are NOT a CPU thead)

  00087	32 c0		 xor	 al, al
$LN1@are_cpu_th:

; 1022 : }

  00089	48 83 c4 38	 add	 rsp, 56			; 00000038H
  0008d	c3		 ret	 0
are_cpu_thread ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\config.c
_TEXT	SEGMENT
arecpu$ = 32
tv76 = 36
tv78 = 40
ourcpu$ = 44
regs$ = 48
is_diag_instr PROC

; 1028 : {

$LN8:
  00000	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 1029 :     REGS* regs;
; 1030 :     bool  arecpu;
; 1031 :     int   ourcpu;
; 1032 : 
; 1033 :     /* Find out if we are a cpu thread */
; 1034 :     if (!(arecpu = are_cpu_thread( &ourcpu )))

  00004	48 8d 4c 24 2c	 lea	 rcx, QWORD PTR ourcpu$[rsp]
  00009	e8 00 00 00 00	 call	 are_cpu_thread
  0000e	88 44 24 20	 mov	 BYTE PTR arecpu$[rsp], al
  00012	0f b6 44 24 20	 movzx	 eax, BYTE PTR arecpu$[rsp]
  00017	85 c0		 test	 eax, eax
  00019	75 04		 jne	 SHORT $LN2@is_diag_in

; 1035 :         return false;

  0001b	32 c0		 xor	 al, al
  0001d	eb 5e		 jmp	 SHORT $LN1@is_diag_in
$LN2@is_diag_in:

; 1036 : 
; 1037 :     /* Point to our REGS structure */
; 1038 :     regs = sysblk.regs[ ourcpu ];

  0001f	48 63 44 24 2c	 movsxd	 rax, DWORD PTR ourcpu$[rsp]
  00024	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  0002b	48 8b 84 c1 98
	0b 00 00	 mov	 rax, QWORD PTR [rcx+rax*8+2968]
  00033	48 89 44 24 30	 mov	 QWORD PTR regs$[rsp], rax

; 1039 : 
; 1040 :     /* Return TRUE/FALSE boolean as appropriate */
; 1041 :     return regs->diagnose ? true : false;

  00038	48 8b 44 24 30	 mov	 rax, QWORD PTR regs$[rsp]
  0003d	8b 80 28 07 00
	00		 mov	 eax, DWORD PTR [rax+1832]
  00043	c1 e8 09	 shr	 eax, 9
  00046	83 e0 01	 and	 eax, 1
  00049	85 c0		 test	 eax, eax
  0004b	74 0a		 je	 SHORT $LN4@is_diag_in
  0004d	c7 44 24 24 01
	00 00 00	 mov	 DWORD PTR tv76[rsp], 1
  00055	eb 08		 jmp	 SHORT $LN5@is_diag_in
$LN4@is_diag_in:
  00057	c7 44 24 24 00
	00 00 00	 mov	 DWORD PTR tv76[rsp], 0
$LN5@is_diag_in:
  0005f	83 7c 24 24 00	 cmp	 DWORD PTR tv76[rsp], 0
  00064	75 0a		 jne	 SHORT $LN6@is_diag_in
  00066	c7 44 24 28 00
	00 00 00	 mov	 DWORD PTR tv78[rsp], 0
  0006e	eb 08		 jmp	 SHORT $LN7@is_diag_in
$LN6@is_diag_in:
  00070	c7 44 24 28 01
	00 00 00	 mov	 DWORD PTR tv78[rsp], 1
$LN7@is_diag_in:
  00078	0f b6 44 24 28	 movzx	 eax, BYTE PTR tv78[rsp]
$LN1@is_diag_in:

; 1042 : }

  0007d	48 83 c4 48	 add	 rsp, 72			; 00000048H
  00081	c3		 ret	 0
is_diag_instr ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\config.c
_TEXT	SEGMENT
c$ = 32
p1$ = 40
p2$ = 48
p3$ = 56
n$ = 64
tv140 = 72
tv153 = 80
tv166 = 88
s$ = 112
idle$ = 120
intv$ = 128
cnt$ = 136
parse_conkpalv PROC

; 2244 : {

$LN29:
  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	48 83 ec 68	 sub	 rsp, 104		; 00000068H
$LN4@parse_conk:

; 2245 :     size_t n; char *p1, *p2, *p3, c;
; 2246 :     ASSERT(s && *s && idle && intv && cnt);

  00018	48 83 7c 24 70
	00		 cmp	 QWORD PTR s$[rsp], 0
  0001e	74 2a		 je	 SHORT $LN9@parse_conk
  00020	48 8b 44 24 70	 mov	 rax, QWORD PTR s$[rsp]
  00025	0f be 00	 movsx	 eax, BYTE PTR [rax]
  00028	85 c0		 test	 eax, eax
  0002a	74 1e		 je	 SHORT $LN9@parse_conk
  0002c	48 83 7c 24 78
	00		 cmp	 QWORD PTR idle$[rsp], 0
  00032	74 16		 je	 SHORT $LN9@parse_conk
  00034	48 83 bc 24 80
	00 00 00 00	 cmp	 QWORD PTR intv$[rsp], 0
  0003d	74 0b		 je	 SHORT $LN9@parse_conk
  0003f	48 83 bc 24 88
	00 00 00 00	 cmp	 QWORD PTR cnt$[rsp], 0
  00048	75 5c		 jne	 SHORT $LN8@parse_conk
$LN9@parse_conk:
$LN7@parse_conk:
  0004a	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG190962
  00051	41 b8 c6 08 00
	00		 mov	 r8d, 2246		; 000008c6H
  00057	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG190963
  0005e	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG190964
  00065	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_logmsg
  0006b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_IsDebuggerPresent
  00071	85 c0		 test	 eax, eax
  00073	74 20		 je	 SHORT $LN10@parse_conk
  00075	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG190966
  0007c	41 b8 c6 08 00
	00		 mov	 r8d, 2246		; 000008c6H
  00082	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG190967
  00089	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG190968
  00090	e8 00 00 00 00	 call	 DebuggerTrace
$LN10@parse_conk:
  00095	33 c0		 xor	 eax, eax
  00097	85 c0		 test	 eax, eax
  00099	75 af		 jne	 SHORT $LN7@parse_conk
  0009b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_IsDebuggerPresent
  000a1	85 c0		 test	 eax, eax
  000a3	74 01		 je	 SHORT $LN11@parse_conk
  000a5	cc		 int	 3
$LN11@parse_conk:
$LN8@parse_conk:
  000a6	33 c0		 xor	 eax, eax
  000a8	85 c0		 test	 eax, eax
  000aa	0f 85 68 ff ff
	ff		 jne	 $LN4@parse_conk

; 2247 :     if (!s || !*s || !idle || !intv || !cnt) return -1;

  000b0	48 83 7c 24 70
	00		 cmp	 QWORD PTR s$[rsp], 0
  000b6	74 2a		 je	 SHORT $LN13@parse_conk
  000b8	48 8b 44 24 70	 mov	 rax, QWORD PTR s$[rsp]
  000bd	0f be 00	 movsx	 eax, BYTE PTR [rax]
  000c0	85 c0		 test	 eax, eax
  000c2	74 1e		 je	 SHORT $LN13@parse_conk
  000c4	48 83 7c 24 78
	00		 cmp	 QWORD PTR idle$[rsp], 0
  000ca	74 16		 je	 SHORT $LN13@parse_conk
  000cc	48 83 bc 24 80
	00 00 00 00	 cmp	 QWORD PTR intv$[rsp], 0
  000d5	74 0b		 je	 SHORT $LN13@parse_conk
  000d7	48 83 bc 24 88
	00 00 00 00	 cmp	 QWORD PTR cnt$[rsp], 0
  000e0	75 0a		 jne	 SHORT $LN12@parse_conk
$LN13@parse_conk:
  000e2	b8 ff ff ff ff	 mov	 eax, -1
  000e7	e9 2f 03 00 00	 jmp	 $LN1@parse_conk
$LN12@parse_conk:

; 2248 :     // Format: "(idle,intv,cnt)". All numbers. No spaces.
; 2249 :     if (0
; 2250 :         || (n = strlen(s)) < 7
; 2251 :         || s[0]   != '('
; 2252 :         || s[n-1] != ')'

  000ec	33 c0		 xor	 eax, eax
  000ee	85 c0		 test	 eax, eax
  000f0	75 47		 jne	 SHORT $LN15@parse_conk
  000f2	48 8b 4c 24 70	 mov	 rcx, QWORD PTR s$[rsp]
  000f7	e8 00 00 00 00	 call	 strlen
  000fc	48 89 44 24 40	 mov	 QWORD PTR n$[rsp], rax
  00101	48 83 7c 24 40
	07		 cmp	 QWORD PTR n$[rsp], 7
  00107	72 30		 jb	 SHORT $LN15@parse_conk
  00109	b8 01 00 00 00	 mov	 eax, 1
  0010e	48 6b c0 00	 imul	 rax, rax, 0
  00112	48 8b 4c 24 70	 mov	 rcx, QWORD PTR s$[rsp]
  00117	0f be 04 01	 movsx	 eax, BYTE PTR [rcx+rax]
  0011b	83 f8 28	 cmp	 eax, 40			; 00000028H
  0011e	75 19		 jne	 SHORT $LN15@parse_conk
  00120	48 8b 44 24 40	 mov	 rax, QWORD PTR n$[rsp]
  00125	48 8b 4c 24 70	 mov	 rcx, QWORD PTR s$[rsp]
  0012a	48 03 c8	 add	 rcx, rax
  0012d	48 8b c1	 mov	 rax, rcx
  00130	0f be 40 ff	 movsx	 eax, BYTE PTR [rax-1]
  00134	83 f8 29	 cmp	 eax, 41			; 00000029H
  00137	74 0a		 je	 SHORT $LN14@parse_conk
$LN15@parse_conk:

; 2253 :     )
; 2254 :         return -1;

  00139	b8 ff ff ff ff	 mov	 eax, -1
  0013e	e9 d8 02 00 00	 jmp	 $LN1@parse_conk
$LN14@parse_conk:

; 2255 :     // 1st sub-operand
; 2256 :     if (!(p1 = strchr(s+1, ','))) return -1;

  00143	48 8b 44 24 70	 mov	 rax, QWORD PTR s$[rsp]
  00148	48 ff c0	 inc	 rax
  0014b	ba 2c 00 00 00	 mov	 edx, 44			; 0000002cH
  00150	48 8b c8	 mov	 rcx, rax
  00153	e8 00 00 00 00	 call	 strchr
  00158	48 89 44 24 28	 mov	 QWORD PTR p1$[rsp], rax
  0015d	48 83 7c 24 28
	00		 cmp	 QWORD PTR p1$[rsp], 0
  00163	75 0a		 jne	 SHORT $LN16@parse_conk
  00165	b8 ff ff ff ff	 mov	 eax, -1
  0016a	e9 ac 02 00 00	 jmp	 $LN1@parse_conk
$LN16@parse_conk:

; 2257 :     c = *p1; *p1 = 0;

  0016f	48 8b 44 24 28	 mov	 rax, QWORD PTR p1$[rsp]
  00174	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  00177	88 44 24 20	 mov	 BYTE PTR c$[rsp], al
  0017b	48 8b 44 24 28	 mov	 rax, QWORD PTR p1$[rsp]
  00180	c6 00 00	 mov	 BYTE PTR [rax], 0

; 2258 :     if ( strspn( s+1, "0123456789" ) != strlen(s+1) )

  00183	48 8b 44 24 70	 mov	 rax, QWORD PTR s$[rsp]
  00188	48 ff c0	 inc	 rax
  0018b	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG190976
  00192	48 8b c8	 mov	 rcx, rax
  00195	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_strspn
  0019b	48 89 44 24 48	 mov	 QWORD PTR tv140[rsp], rax
  001a0	48 8b 4c 24 70	 mov	 rcx, QWORD PTR s$[rsp]
  001a5	48 ff c1	 inc	 rcx
  001a8	e8 00 00 00 00	 call	 strlen
  001ad	48 8b 4c 24 48	 mov	 rcx, QWORD PTR tv140[rsp]
  001b2	48 3b c8	 cmp	 rcx, rax
  001b5	74 16		 je	 SHORT $LN17@parse_conk

; 2259 :     {
; 2260 :         *p1 = c;

  001b7	48 8b 44 24 28	 mov	 rax, QWORD PTR p1$[rsp]
  001bc	0f b6 4c 24 20	 movzx	 ecx, BYTE PTR c$[rsp]
  001c1	88 08		 mov	 BYTE PTR [rax], cl

; 2261 :         return -1;

  001c3	b8 ff ff ff ff	 mov	 eax, -1
  001c8	e9 4e 02 00 00	 jmp	 $LN1@parse_conk
$LN17@parse_conk:

; 2262 :     }
; 2263 :     *p1 = c;

  001cd	48 8b 44 24 28	 mov	 rax, QWORD PTR p1$[rsp]
  001d2	0f b6 4c 24 20	 movzx	 ecx, BYTE PTR c$[rsp]
  001d7	88 08		 mov	 BYTE PTR [rax], cl

; 2264 :     // 2nd sub-operand
; 2265 :     if (!(p2 = strchr(p1+1, ','))) return -1;

  001d9	48 8b 44 24 28	 mov	 rax, QWORD PTR p1$[rsp]
  001de	48 ff c0	 inc	 rax
  001e1	ba 2c 00 00 00	 mov	 edx, 44			; 0000002cH
  001e6	48 8b c8	 mov	 rcx, rax
  001e9	e8 00 00 00 00	 call	 strchr
  001ee	48 89 44 24 30	 mov	 QWORD PTR p2$[rsp], rax
  001f3	48 83 7c 24 30
	00		 cmp	 QWORD PTR p2$[rsp], 0
  001f9	75 0a		 jne	 SHORT $LN18@parse_conk
  001fb	b8 ff ff ff ff	 mov	 eax, -1
  00200	e9 16 02 00 00	 jmp	 $LN1@parse_conk
$LN18@parse_conk:

; 2266 :     c = *p2; *p2 = 0;

  00205	48 8b 44 24 30	 mov	 rax, QWORD PTR p2$[rsp]
  0020a	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  0020d	88 44 24 20	 mov	 BYTE PTR c$[rsp], al
  00211	48 8b 44 24 30	 mov	 rax, QWORD PTR p2$[rsp]
  00216	c6 00 00	 mov	 BYTE PTR [rax], 0

; 2267 :     if ( strspn( p1+1, "0123456789" ) != strlen(p1+1) )

  00219	48 8b 44 24 28	 mov	 rax, QWORD PTR p1$[rsp]
  0021e	48 ff c0	 inc	 rax
  00221	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG190979
  00228	48 8b c8	 mov	 rcx, rax
  0022b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_strspn
  00231	48 89 44 24 50	 mov	 QWORD PTR tv153[rsp], rax
  00236	48 8b 4c 24 28	 mov	 rcx, QWORD PTR p1$[rsp]
  0023b	48 ff c1	 inc	 rcx
  0023e	e8 00 00 00 00	 call	 strlen
  00243	48 8b 4c 24 50	 mov	 rcx, QWORD PTR tv153[rsp]
  00248	48 3b c8	 cmp	 rcx, rax
  0024b	74 16		 je	 SHORT $LN19@parse_conk

; 2268 :     {
; 2269 :         *p2 = c;

  0024d	48 8b 44 24 30	 mov	 rax, QWORD PTR p2$[rsp]
  00252	0f b6 4c 24 20	 movzx	 ecx, BYTE PTR c$[rsp]
  00257	88 08		 mov	 BYTE PTR [rax], cl

; 2270 :         return -1;

  00259	b8 ff ff ff ff	 mov	 eax, -1
  0025e	e9 b8 01 00 00	 jmp	 $LN1@parse_conk
$LN19@parse_conk:

; 2271 :     }
; 2272 :     *p2 = c;

  00263	48 8b 44 24 30	 mov	 rax, QWORD PTR p2$[rsp]
  00268	0f b6 4c 24 20	 movzx	 ecx, BYTE PTR c$[rsp]
  0026d	88 08		 mov	 BYTE PTR [rax], cl

; 2273 :     // 3rd sub-operand
; 2274 :     if (!(p3 = strchr(p2+1, ')'))) return -1;

  0026f	48 8b 44 24 30	 mov	 rax, QWORD PTR p2$[rsp]
  00274	48 ff c0	 inc	 rax
  00277	ba 29 00 00 00	 mov	 edx, 41			; 00000029H
  0027c	48 8b c8	 mov	 rcx, rax
  0027f	e8 00 00 00 00	 call	 strchr
  00284	48 89 44 24 38	 mov	 QWORD PTR p3$[rsp], rax
  00289	48 83 7c 24 38
	00		 cmp	 QWORD PTR p3$[rsp], 0
  0028f	75 0a		 jne	 SHORT $LN20@parse_conk
  00291	b8 ff ff ff ff	 mov	 eax, -1
  00296	e9 80 01 00 00	 jmp	 $LN1@parse_conk
$LN20@parse_conk:

; 2275 :     c = *p3; *p3 = 0;

  0029b	48 8b 44 24 38	 mov	 rax, QWORD PTR p3$[rsp]
  002a0	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  002a3	88 44 24 20	 mov	 BYTE PTR c$[rsp], al
  002a7	48 8b 44 24 38	 mov	 rax, QWORD PTR p3$[rsp]
  002ac	c6 00 00	 mov	 BYTE PTR [rax], 0

; 2276 :     if ( strspn( p2+1, "0123456789" ) != strlen(p2+1) )

  002af	48 8b 44 24 30	 mov	 rax, QWORD PTR p2$[rsp]
  002b4	48 ff c0	 inc	 rax
  002b7	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG190982
  002be	48 8b c8	 mov	 rcx, rax
  002c1	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_strspn
  002c7	48 89 44 24 58	 mov	 QWORD PTR tv166[rsp], rax
  002cc	48 8b 4c 24 30	 mov	 rcx, QWORD PTR p2$[rsp]
  002d1	48 ff c1	 inc	 rcx
  002d4	e8 00 00 00 00	 call	 strlen
  002d9	48 8b 4c 24 58	 mov	 rcx, QWORD PTR tv166[rsp]
  002de	48 3b c8	 cmp	 rcx, rax
  002e1	74 16		 je	 SHORT $LN21@parse_conk

; 2277 :     {
; 2278 :         *p3 = c;

  002e3	48 8b 44 24 38	 mov	 rax, QWORD PTR p3$[rsp]
  002e8	0f b6 4c 24 20	 movzx	 ecx, BYTE PTR c$[rsp]
  002ed	88 08		 mov	 BYTE PTR [rax], cl

; 2279 :         return -1;

  002ef	b8 ff ff ff ff	 mov	 eax, -1
  002f4	e9 22 01 00 00	 jmp	 $LN1@parse_conk
$LN21@parse_conk:

; 2280 :     }
; 2281 :     *p3 = c;

  002f9	48 8b 44 24 38	 mov	 rax, QWORD PTR p3$[rsp]
  002fe	0f b6 4c 24 20	 movzx	 ecx, BYTE PTR c$[rsp]
  00303	88 08		 mov	 BYTE PTR [rax], cl

; 2282 :     // convert each to number
; 2283 :     c = *p1; *p1 = 0; *idle = atoi(s+1);  *p1 = c;

  00305	48 8b 44 24 28	 mov	 rax, QWORD PTR p1$[rsp]
  0030a	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  0030d	88 44 24 20	 mov	 BYTE PTR c$[rsp], al
  00311	48 8b 44 24 28	 mov	 rax, QWORD PTR p1$[rsp]
  00316	c6 00 00	 mov	 BYTE PTR [rax], 0
  00319	48 8b 44 24 70	 mov	 rax, QWORD PTR s$[rsp]
  0031e	48 ff c0	 inc	 rax
  00321	48 8b c8	 mov	 rcx, rax
  00324	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_atoi
  0032a	48 8b 4c 24 78	 mov	 rcx, QWORD PTR idle$[rsp]
  0032f	89 01		 mov	 DWORD PTR [rcx], eax
  00331	48 8b 44 24 28	 mov	 rax, QWORD PTR p1$[rsp]
  00336	0f b6 4c 24 20	 movzx	 ecx, BYTE PTR c$[rsp]
  0033b	88 08		 mov	 BYTE PTR [rax], cl

; 2284 :     c = *p2; *p2 = 0; *intv = atoi(p1+1); *p2 = c;

  0033d	48 8b 44 24 30	 mov	 rax, QWORD PTR p2$[rsp]
  00342	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  00345	88 44 24 20	 mov	 BYTE PTR c$[rsp], al
  00349	48 8b 44 24 30	 mov	 rax, QWORD PTR p2$[rsp]
  0034e	c6 00 00	 mov	 BYTE PTR [rax], 0
  00351	48 8b 44 24 28	 mov	 rax, QWORD PTR p1$[rsp]
  00356	48 ff c0	 inc	 rax
  00359	48 8b c8	 mov	 rcx, rax
  0035c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_atoi
  00362	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR intv$[rsp]
  0036a	89 01		 mov	 DWORD PTR [rcx], eax
  0036c	48 8b 44 24 30	 mov	 rax, QWORD PTR p2$[rsp]
  00371	0f b6 4c 24 20	 movzx	 ecx, BYTE PTR c$[rsp]
  00376	88 08		 mov	 BYTE PTR [rax], cl

; 2285 :     c = *p3; *p3 = 0; *cnt  = atoi(p2+1); *p3 = c;

  00378	48 8b 44 24 38	 mov	 rax, QWORD PTR p3$[rsp]
  0037d	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  00380	88 44 24 20	 mov	 BYTE PTR c$[rsp], al
  00384	48 8b 44 24 38	 mov	 rax, QWORD PTR p3$[rsp]
  00389	c6 00 00	 mov	 BYTE PTR [rax], 0
  0038c	48 8b 44 24 30	 mov	 rax, QWORD PTR p2$[rsp]
  00391	48 ff c0	 inc	 rax
  00394	48 8b c8	 mov	 rcx, rax
  00397	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_atoi
  0039d	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR cnt$[rsp]
  003a5	89 01		 mov	 DWORD PTR [rcx], eax
  003a7	48 8b 44 24 38	 mov	 rax, QWORD PTR p3$[rsp]
  003ac	0f b6 4c 24 20	 movzx	 ecx, BYTE PTR c$[rsp]
  003b1	88 08		 mov	 BYTE PTR [rax], cl

; 2286 :     // check results
; 2287 :     if (*idle <= 0 || INT_MAX == *idle) return -1;

  003b3	48 8b 44 24 78	 mov	 rax, QWORD PTR idle$[rsp]
  003b8	83 38 00	 cmp	 DWORD PTR [rax], 0
  003bb	7e 0d		 jle	 SHORT $LN23@parse_conk
  003bd	48 8b 44 24 78	 mov	 rax, QWORD PTR idle$[rsp]
  003c2	81 38 ff ff ff
	7f		 cmp	 DWORD PTR [rax], 2147483647 ; 7fffffffH
  003c8	75 07		 jne	 SHORT $LN22@parse_conk
$LN23@parse_conk:
  003ca	b8 ff ff ff ff	 mov	 eax, -1
  003cf	eb 4a		 jmp	 SHORT $LN1@parse_conk
$LN22@parse_conk:

; 2288 :     if (*intv <= 0 || INT_MAX == *intv) return -1;

  003d1	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR intv$[rsp]
  003d9	83 38 00	 cmp	 DWORD PTR [rax], 0
  003dc	7e 10		 jle	 SHORT $LN25@parse_conk
  003de	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR intv$[rsp]
  003e6	81 38 ff ff ff
	7f		 cmp	 DWORD PTR [rax], 2147483647 ; 7fffffffH
  003ec	75 07		 jne	 SHORT $LN24@parse_conk
$LN25@parse_conk:
  003ee	b8 ff ff ff ff	 mov	 eax, -1
  003f3	eb 26		 jmp	 SHORT $LN1@parse_conk
$LN24@parse_conk:

; 2289 :     if (*cnt  <= 0 || INT_MAX == *cnt ) return -1;

  003f5	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR cnt$[rsp]
  003fd	83 38 00	 cmp	 DWORD PTR [rax], 0
  00400	7e 10		 jle	 SHORT $LN27@parse_conk
  00402	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR cnt$[rsp]
  0040a	81 38 ff ff ff
	7f		 cmp	 DWORD PTR [rax], 2147483647 ; 7fffffffH
  00410	75 07		 jne	 SHORT $LN26@parse_conk
$LN27@parse_conk:
  00412	b8 ff ff ff ff	 mov	 eax, -1
  00417	eb 02		 jmp	 SHORT $LN1@parse_conk
$LN26@parse_conk:

; 2290 :     return 0;

  00419	33 c0		 xor	 eax, eax
$LN1@parse_conk:

; 2291 : }

  0041b	48 83 c4 68	 add	 rsp, 104		; 00000068H
  0041f	c3		 ret	 0
parse_conkpalv ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\config.c
_TEXT	SEGMENT
i$ = 32
clearlogo PROC

; 2190 : {

$LN7:
  00000	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 2191 :     size_t i;
; 2192 :     if(sysblk.herclogo!=NULL)

  00004	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  0000b	48 83 b8 f8 13
	00 00 00	 cmp	 QWORD PTR [rax+5112], 0
  00013	74 72		 je	 SHORT $LN5@clearlogo

; 2193 :     {
; 2194 :         for(i=0;i<sysblk.logolines;i++)

  00015	48 c7 44 24 20
	00 00 00 00	 mov	 QWORD PTR i$[rsp], 0
  0001e	eb 0d		 jmp	 SHORT $LN4@clearlogo
$LN2@clearlogo:
  00020	48 8b 44 24 20	 mov	 rax, QWORD PTR i$[rsp]
  00025	48 ff c0	 inc	 rax
  00028	48 89 44 24 20	 mov	 QWORD PTR i$[rsp], rax
$LN4@clearlogo:
  0002d	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00034	48 8b 80 08 14
	00 00		 mov	 rax, QWORD PTR [rax+5128]
  0003b	48 39 44 24 20	 cmp	 QWORD PTR i$[rsp], rax
  00040	73 1f		 jae	 SHORT $LN3@clearlogo

; 2195 :         {
; 2196 :             free(sysblk.herclogo[i]);

  00042	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00049	48 8b 80 f8 13
	00 00		 mov	 rax, QWORD PTR [rax+5112]
  00050	48 8b 4c 24 20	 mov	 rcx, QWORD PTR i$[rsp]
  00055	48 8b 0c c8	 mov	 rcx, QWORD PTR [rax+rcx*8]
  00059	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free

; 2197 :         }

  0005f	eb bf		 jmp	 SHORT $LN2@clearlogo
$LN3@clearlogo:

; 2198 :         free(sysblk.herclogo);

  00061	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00068	48 8b 88 f8 13
	00 00		 mov	 rcx, QWORD PTR [rax+5112]
  0006f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free

; 2199 :         sysblk.herclogo=NULL;

  00075	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  0007c	48 c7 80 f8 13
	00 00 00 00 00
	00		 mov	 QWORD PTR [rax+5112], 0
$LN5@clearlogo:

; 2200 :     }
; 2201 : }

  00087	48 83 c4 38	 add	 rsp, 56			; 00000038H
  0008b	c3		 ret	 0
clearlogo ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\config.c
_TEXT	SEGMENT
rec$ = 32
lf$ = 40
data$ = 48
len$ = 56
bfr$ = 64
__$ArrayPad$ = 320
fn$ = 352
readlogo PROC

; 2207 : {

$LN7:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 81 ec 58 01
	00 00		 sub	 rsp, 344		; 00000158H
  0000c	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00013	48 33 c4	 xor	 rax, rsp
  00016	48 89 84 24 40
	01 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 2208 :     char    **data;
; 2209 :     char     bfr[256];
; 2210 :     char    *rec;
; 2211 :     FILE    *lf;
; 2212 :     size_t   len;
; 2213 : 
; 2214 :     clearlogo();

  0001e	e8 00 00 00 00	 call	 clearlogo

; 2215 : 
; 2216 :     lf=fopen(fn,"r");

  00023	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG190937
  0002a	48 8b 8c 24 60
	01 00 00	 mov	 rcx, QWORD PTR fn$[rsp]
  00032	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fopen
  00038	48 89 44 24 28	 mov	 QWORD PTR lf$[rsp], rax

; 2217 :     if(lf==NULL)

  0003d	48 83 7c 24 28
	00		 cmp	 QWORD PTR lf$[rsp], 0
  00043	75 0a		 jne	 SHORT $LN4@readlogo

; 2218 :     {
; 2219 :         return -1;

  00045	b8 ff ff ff ff	 mov	 eax, -1
  0004a	e9 11 01 00 00	 jmp	 $LN1@readlogo
$LN4@readlogo:

; 2220 :     }
; 2221 :     data=malloc(sizeof(char *)*MAX_LOGO_LINES);

  0004f	b9 00 08 00 00	 mov	 ecx, 2048		; 00000800H
  00054	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_malloc
  0005a	48 89 44 24 30	 mov	 QWORD PTR data$[rsp], rax

; 2222 :     sysblk.logolines=0;

  0005f	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00066	48 c7 80 08 14
	00 00 00 00 00
	00		 mov	 QWORD PTR [rax+5128], 0
$LN2@readlogo:

; 2223 :     while((rec=fgets(bfr,sizeof(bfr),lf))!=NULL)

  00071	4c 8b 44 24 28	 mov	 r8, QWORD PTR lf$[rsp]
  00076	ba 00 01 00 00	 mov	 edx, 256		; 00000100H
  0007b	48 8d 4c 24 40	 lea	 rcx, QWORD PTR bfr$[rsp]
  00080	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fgets
  00086	48 89 44 24 20	 mov	 QWORD PTR rec$[rsp], rax
  0008b	48 83 7c 24 20
	00		 cmp	 QWORD PTR rec$[rsp], 0
  00091	0f 84 a9 00 00
	00		 je	 $LN3@readlogo

; 2224 :     {
; 2225 :         rec[strlen(rec)-1]=0;

  00097	48 8b 4c 24 20	 mov	 rcx, QWORD PTR rec$[rsp]
  0009c	e8 00 00 00 00	 call	 strlen
  000a1	48 8b 4c 24 20	 mov	 rcx, QWORD PTR rec$[rsp]
  000a6	c6 44 01 ff 00	 mov	 BYTE PTR [rcx+rax-1], 0

; 2226 :         len = strlen(rec)+1;

  000ab	48 8b 4c 24 20	 mov	 rcx, QWORD PTR rec$[rsp]
  000b0	e8 00 00 00 00	 call	 strlen
  000b5	48 ff c0	 inc	 rax
  000b8	48 89 44 24 38	 mov	 QWORD PTR len$[rsp], rax

; 2227 :         data[sysblk.logolines]=malloc(len);

  000bd	48 8b 4c 24 38	 mov	 rcx, QWORD PTR len$[rsp]
  000c2	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_malloc
  000c8	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  000cf	48 8b 89 08 14
	00 00		 mov	 rcx, QWORD PTR [rcx+5128]
  000d6	48 8b 54 24 30	 mov	 rdx, QWORD PTR data$[rsp]
  000db	48 89 04 ca	 mov	 QWORD PTR [rdx+rcx*8], rax

; 2228 :         strlcpy(data[sysblk.logolines],rec,len);

  000df	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  000e6	48 8b 80 08 14
	00 00		 mov	 rax, QWORD PTR [rax+5128]
  000ed	4c 8b 44 24 38	 mov	 r8, QWORD PTR len$[rsp]
  000f2	48 8b 54 24 20	 mov	 rdx, QWORD PTR rec$[rsp]
  000f7	48 8b 4c 24 30	 mov	 rcx, QWORD PTR data$[rsp]
  000fc	48 8b 0c c1	 mov	 rcx, QWORD PTR [rcx+rax*8]
  00100	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_strlcpy

; 2229 :         sysblk.logolines++;

  00106	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  0010d	48 8b 80 08 14
	00 00		 mov	 rax, QWORD PTR [rax+5128]
  00114	48 ff c0	 inc	 rax
  00117	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  0011e	48 89 81 08 14
	00 00		 mov	 QWORD PTR [rcx+5128], rax

; 2230 :         if(sysblk.logolines>MAX_LOGO_LINES)

  00125	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  0012c	48 81 b8 08 14
	00 00 00 01 00
	00		 cmp	 QWORD PTR [rax+5128], 256 ; 00000100H
  00137	76 02		 jbe	 SHORT $LN5@readlogo

; 2231 :         {
; 2232 :             break;

  00139	eb 05		 jmp	 SHORT $LN3@readlogo
$LN5@readlogo:

; 2233 :         }
; 2234 :     }

  0013b	e9 31 ff ff ff	 jmp	 $LN2@readlogo
$LN3@readlogo:

; 2235 :     fclose(lf);

  00140	48 8b 4c 24 28	 mov	 rcx, QWORD PTR lf$[rsp]
  00145	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_fclose

; 2236 :     sysblk.herclogo=data;

  0014b	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00152	48 8b 4c 24 30	 mov	 rcx, QWORD PTR data$[rsp]
  00157	48 89 88 f8 13
	00 00		 mov	 QWORD PTR [rax+5112], rcx

; 2237 :     return 0;

  0015e	33 c0		 xor	 eax, eax
$LN1@readlogo:

; 2238 : }

  00160	48 8b 8c 24 40
	01 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  00168	48 33 cc	 xor	 rcx, rsp
  0016b	e8 00 00 00 00	 call	 __security_check_cookie
  00170	48 81 c4 58 01
	00 00		 add	 rsp, 344		; 00000158H
  00177	c3		 ret	 0
readlogo ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\config.c
_TEXT	SEGMENT
cuu1$ = 80
cuu2$ = 84
dgrs$ = 88
strptr$ = 96
basechan$ = 104
badcuu$ = 108
duplicate$ = 112
i$ = 120
gcount$ = 128
tv95 = 136
rc$ = 140
tv137 = 144
tv149 = 148
tv161 = 152
tv173 = 156
tv193 = 160
tv195 = 164
tv224 = 168
tv274 = 172
tv276 = 176
grps$ = 184
sc$ = 192
strtok_str$ = 200
spec$ = 224
dd$ = 232
parse_devnums PROC

; 1937 : {

$LN29:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 81 ec d8 00
	00 00		 sub	 rsp, 216		; 000000d8H

; 1938 :     size_t     gcount;          /* Group count                       */
; 1939 :     size_t     i;               /* Index runner                      */
; 1940 :     char*      grps;            /* Pointer to current devnum group   */
; 1941 :     char*      sc;              /* Specification string copy         */
; 1942 :     DEVARRAY*  dgrs;            /* Device groups                     */
; 1943 :     U16        cuu1, cuu2;      /* CUUs                              */
; 1944 :     char*      strptr;          /* strtoul ptr-ptr                   */
; 1945 :     int        basechan = 0;    /* Channel for all CUUs              */

  00011	c7 44 24 68 00
	00 00 00	 mov	 DWORD PTR basechan$[rsp], 0

; 1946 :     int        duplicate;       /* duplicated CUU indicator          */
; 1947 :     int        badcuu;          /* offending CUU                     */
; 1948 :     int        rc;              /* Return code work var              */
; 1949 :     char*      strtok_str;      /* Last token                        */
; 1950 : 
; 1951 :     strtok_str = NULL;

  00019	48 c7 84 24 c8
	00 00 00 00 00
	00 00		 mov	 QWORD PTR strtok_str$[rsp], 0

; 1952 : 
; 1953 :     if ((rc = parse_lcss( spec, &sc, 1 )) < 0)

  00025	41 b8 01 00 00
	00		 mov	 r8d, 1
  0002b	48 8d 94 24 c0
	00 00 00	 lea	 rdx, QWORD PTR sc$[rsp]
  00033	48 8b 8c 24 e0
	00 00 00	 mov	 rcx, QWORD PTR spec$[rsp]
  0003b	e8 00 00 00 00	 call	 parse_lcss
  00040	89 84 24 8c 00
	00 00		 mov	 DWORD PTR rc$[rsp], eax
  00047	83 bc 24 8c 00
	00 00 00	 cmp	 DWORD PTR rc$[rsp], 0
  0004f	7d 07		 jge	 SHORT $LN9@parse_devn

; 1954 :     {
; 1955 :         return 0;

  00051	33 c0		 xor	 eax, eax
  00053	e9 5d 06 00 00	 jmp	 $LN1@parse_devn
$LN9@parse_devn:

; 1956 :     }
; 1957 : 
; 1958 :     dd->lcss = rc;

  00058	48 8b 84 24 e8
	00 00 00	 mov	 rax, QWORD PTR dd$[rsp]
  00060	0f b6 8c 24 8c
	00 00 00	 movzx	 ecx, BYTE PTR rc$[rsp]
  00068	88 08		 mov	 BYTE PTR [rax], cl

; 1959 : 
; 1960 :     /* Split by ',' groups */
; 1961 : 
; 1962 :     gcount = 0;

  0006a	48 c7 84 24 80
	00 00 00 00 00
	00 00		 mov	 QWORD PTR gcount$[rsp], 0

; 1963 :     grps   = strtok_r( sc, ",", &strtok_str );

  00076	4c 8d 84 24 c8
	00 00 00	 lea	 r8, QWORD PTR strtok_str$[rsp]
  0007e	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG190813
  00085	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR sc$[rsp]
  0008d	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_strtok_r
  00093	48 89 84 24 b8
	00 00 00	 mov	 QWORD PTR grps$[rsp], rax

; 1964 :     dgrs   = NULL;

  0009b	48 c7 44 24 58
	00 00 00 00	 mov	 QWORD PTR dgrs$[rsp], 0
$LN2@parse_devn:

; 1965 : 
; 1966 :     while (grps)

  000a4	48 83 bc 24 b8
	00 00 00 00	 cmp	 QWORD PTR grps$[rsp], 0
  000ad	0f 84 be 05 00
	00		 je	 $LN3@parse_devn

; 1967 :     {
; 1968 :         if (!dgrs)

  000b3	48 83 7c 24 58
	00		 cmp	 QWORD PTR dgrs$[rsp], 0
  000b9	75 12		 jne	 SHORT $LN10@parse_devn

; 1969 :             dgrs = malloc( sizeof( DEVARRAY ));

  000bb	b9 04 00 00 00	 mov	 ecx, 4
  000c0	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_malloc
  000c6	48 89 44 24 58	 mov	 QWORD PTR dgrs$[rsp], rax
  000cb	eb 23		 jmp	 SHORT $LN11@parse_devn
$LN10@parse_devn:

; 1970 :         else
; 1971 :             dgrs = realloc( dgrs, sizeof( DEVARRAY ) * (gcount + 1));

  000cd	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR gcount$[rsp]
  000d5	48 8d 04 85 04
	00 00 00	 lea	 rax, QWORD PTR [rax*4+4]
  000dd	48 8b d0	 mov	 rdx, rax
  000e0	48 8b 4c 24 58	 mov	 rcx, QWORD PTR dgrs$[rsp]
  000e5	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_realloc
  000eb	48 89 44 24 58	 mov	 QWORD PTR dgrs$[rsp], rax
$LN11@parse_devn:

; 1972 : 
; 1973 :         cuu1 = strtoul( grps, &strptr, 16 );

  000f0	41 b8 10 00 00
	00		 mov	 r8d, 16
  000f6	48 8d 54 24 60	 lea	 rdx, QWORD PTR strptr$[rsp]
  000fb	48 8b 8c 24 b8
	00 00 00	 mov	 rcx, QWORD PTR grps$[rsp]
  00103	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_strtoul
  00109	66 89 44 24 50	 mov	 WORD PTR cuu1$[rsp], ax

; 1974 : 
; 1975 :         switch (*strptr)

  0010e	48 8b 44 24 60	 mov	 rax, QWORD PTR strptr$[rsp]
  00113	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  00116	88 84 24 88 00
	00 00		 mov	 BYTE PTR tv95[rsp], al
  0011d	80 bc 24 88 00
	00 00 00	 cmp	 BYTE PTR tv95[rsp], 0
  00125	74 1d		 je	 SHORT $LN12@parse_devn
  00127	80 bc 24 88 00
	00 00 2d	 cmp	 BYTE PTR tv95[rsp], 45	; 0000002dH
  0012f	74 22		 je	 SHORT $LN13@parse_devn
  00131	80 bc 24 88 00
	00 00 2e	 cmp	 BYTE PTR tv95[rsp], 46	; 0000002eH
  00139	0f 84 c4 00 00
	00		 je	 $LN15@parse_devn
  0013f	e9 8d 01 00 00	 jmp	 $LN17@parse_devn
$LN12@parse_devn:

; 1976 :         {
; 1977 :         case 0:     /* Single CUU */
; 1978 : 
; 1979 :             cuu2 = cuu1;

  00144	0f b7 44 24 50	 movzx	 eax, WORD PTR cuu1$[rsp]
  00149	66 89 44 24 54	 mov	 WORD PTR cuu2$[rsp], ax

; 1980 :             break;

  0014e	e9 f0 01 00 00	 jmp	 $LN4@parse_devn
$LN13@parse_devn:

; 1981 : 
; 1982 :         case '-':   /* CUU Range */
; 1983 : 
; 1984 :             cuu2 = strtoul( &strptr[1], &strptr, 16 );

  00153	b8 01 00 00 00	 mov	 eax, 1
  00158	48 6b c0 01	 imul	 rax, rax, 1
  0015c	48 8b 4c 24 60	 mov	 rcx, QWORD PTR strptr$[rsp]
  00161	48 03 c8	 add	 rcx, rax
  00164	48 8b c1	 mov	 rax, rcx
  00167	41 b8 10 00 00
	00		 mov	 r8d, 16
  0016d	48 8d 54 24 60	 lea	 rdx, QWORD PTR strptr$[rsp]
  00172	48 8b c8	 mov	 rcx, rax
  00175	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_strtoul
  0017b	66 89 44 24 54	 mov	 WORD PTR cuu2$[rsp], ax

; 1985 : 
; 1986 :             if (*strptr)

  00180	48 8b 44 24 60	 mov	 rax, QWORD PTR strptr$[rsp]
  00185	0f be 00	 movsx	 eax, BYTE PTR [rax]
  00188	85 c0		 test	 eax, eax
  0018a	74 72		 je	 SHORT $LN14@parse_devn

; 1987 :             {
; 1988 :                 // "Incorrect %s near character '%c'"
; 1989 :                 WRMSG( HHC01470, "E", "second device number in device range", *strptr );

  0018c	48 8b 44 24 60	 mov	 rax, QWORD PTR strptr$[rsp]
  00191	0f be 00	 movsx	 eax, BYTE PTR [rax]
  00194	89 84 24 90 00
	00 00		 mov	 DWORD PTR tv137[rsp], eax
  0019b	b9 01 00 00 00	 mov	 ecx, 1
  001a0	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  001a6	8b 8c 24 90 00
	00 00		 mov	 ecx, DWORD PTR tv137[rsp]
  001ad	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  001b1	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG190819
  001b8	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  001bd	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG190820
  001c4	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  001c9	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG190821
  001d0	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  001d5	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  001da	41 b9 03 00 00
	00		 mov	 r9d, 3
  001e0	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG190822
  001e7	ba c5 07 00 00	 mov	 edx, 1989		; 000007c5H
  001ec	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG190823
  001f3	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 1990 :                 goto error_ret;

  001f9	e9 9c 04 00 00	 jmp	 $error_ret$30
$LN14@parse_devn:

; 1991 :             }
; 1992 :             break;

  001fe	e9 40 01 00 00	 jmp	 $LN4@parse_devn
$LN15@parse_devn:

; 1993 : 
; 1994 :         case '.':   /* CUU Count */
; 1995 : 
; 1996 :             cuu2 = cuu1 + strtoul( &strptr[1], &strptr, 10 );

  00203	0f b7 44 24 50	 movzx	 eax, WORD PTR cuu1$[rsp]
  00208	89 84 24 94 00
	00 00		 mov	 DWORD PTR tv149[rsp], eax
  0020f	b9 01 00 00 00	 mov	 ecx, 1
  00214	48 6b c9 01	 imul	 rcx, rcx, 1
  00218	48 8b 54 24 60	 mov	 rdx, QWORD PTR strptr$[rsp]
  0021d	48 03 d1	 add	 rdx, rcx
  00220	48 8b ca	 mov	 rcx, rdx
  00223	41 b8 0a 00 00
	00		 mov	 r8d, 10
  00229	48 8d 54 24 60	 lea	 rdx, QWORD PTR strptr$[rsp]
  0022e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_strtoul
  00234	8b 8c 24 94 00
	00 00		 mov	 ecx, DWORD PTR tv149[rsp]
  0023b	03 c8		 add	 ecx, eax
  0023d	8b c1		 mov	 eax, ecx
  0023f	66 89 44 24 54	 mov	 WORD PTR cuu2$[rsp], ax

; 1997 :             cuu2--;

  00244	0f b7 44 24 54	 movzx	 eax, WORD PTR cuu2$[rsp]
  00249	66 ff c8	 dec	 ax
  0024c	66 89 44 24 54	 mov	 WORD PTR cuu2$[rsp], ax

; 1998 : 
; 1999 :             if (*strptr)

  00251	48 8b 44 24 60	 mov	 rax, QWORD PTR strptr$[rsp]
  00256	0f be 00	 movsx	 eax, BYTE PTR [rax]
  00259	85 c0		 test	 eax, eax
  0025b	74 72		 je	 SHORT $LN16@parse_devn

; 2000 :             {
; 2001 :                 // "Incorrect %s near character '%c'"
; 2002 :                 WRMSG( HHC01470, "E", "device count", *strptr );

  0025d	48 8b 44 24 60	 mov	 rax, QWORD PTR strptr$[rsp]
  00262	0f be 00	 movsx	 eax, BYTE PTR [rax]
  00265	89 84 24 98 00
	00 00		 mov	 DWORD PTR tv161[rsp], eax
  0026c	b9 01 00 00 00	 mov	 ecx, 1
  00271	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  00277	8b 8c 24 98 00
	00 00		 mov	 ecx, DWORD PTR tv161[rsp]
  0027e	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  00282	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG190826
  00289	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  0028e	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG190827
  00295	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  0029a	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG190828
  002a1	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  002a6	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  002ab	41 b9 03 00 00
	00		 mov	 r9d, 3
  002b1	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG190829
  002b8	ba d2 07 00 00	 mov	 edx, 2002		; 000007d2H
  002bd	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG190830
  002c4	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 2003 :                 goto error_ret;

  002ca	e9 cb 03 00 00	 jmp	 $error_ret$30
$LN16@parse_devn:

; 2004 :             }
; 2005 :             break;

  002cf	eb 72		 jmp	 SHORT $LN4@parse_devn
$LN17@parse_devn:

; 2006 : 
; 2007 :         default:
; 2008 : 
; 2009 :             // "Incorrect %s near character '%c'"
; 2010 :             WRMSG( HHC01470, "E", "device specification", *strptr );

  002d1	48 8b 44 24 60	 mov	 rax, QWORD PTR strptr$[rsp]
  002d6	0f be 00	 movsx	 eax, BYTE PTR [rax]
  002d9	89 84 24 9c 00
	00 00		 mov	 DWORD PTR tv173[rsp], eax
  002e0	b9 01 00 00 00	 mov	 ecx, 1
  002e5	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  002eb	8b 8c 24 9c 00
	00 00		 mov	 ecx, DWORD PTR tv173[rsp]
  002f2	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  002f6	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG190832
  002fd	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  00302	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG190833
  00309	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  0030e	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG190834
  00315	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  0031a	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  0031f	41 b9 03 00 00
	00		 mov	 r9d, 3
  00325	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG190835
  0032c	ba da 07 00 00	 mov	 edx, 2010		; 000007daH
  00331	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG190836
  00338	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 2011 :             goto error_ret;

  0033e	e9 57 03 00 00	 jmp	 $error_ret$30
$LN4@parse_devn:

; 2012 :         }
; 2013 : 
; 2014 :         /* Check cuu1 <= cuu2 */
; 2015 : 
; 2016 :         if (cuu1 > cuu2)

  00343	0f b7 44 24 50	 movzx	 eax, WORD PTR cuu1$[rsp]
  00348	0f b7 4c 24 54	 movzx	 ecx, WORD PTR cuu2$[rsp]
  0034d	3b c1		 cmp	 eax, ecx
  0034f	7e 7a		 jle	 SHORT $LN18@parse_devn

; 2017 :         {
; 2018 :             // "Incorrect device address range %04X < %04X"
; 2019 :             WRMSG( HHC01471, "E", cuu2, cuu1 );

  00351	0f b7 44 24 50	 movzx	 eax, WORD PTR cuu1$[rsp]
  00356	89 84 24 a0 00
	00 00		 mov	 DWORD PTR tv193[rsp], eax
  0035d	0f b7 4c 24 54	 movzx	 ecx, WORD PTR cuu2$[rsp]
  00362	89 8c 24 a4 00
	00 00		 mov	 DWORD PTR tv195[rsp], ecx
  00369	b9 01 00 00 00	 mov	 ecx, 1
  0036e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  00374	8b 8c 24 a0 00
	00 00		 mov	 ecx, DWORD PTR tv193[rsp]
  0037b	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  0037f	8b 8c 24 a4 00
	00 00		 mov	 ecx, DWORD PTR tv195[rsp]
  00386	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  0038a	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG190838
  00391	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  00396	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG190839
  0039d	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  003a2	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  003a7	41 b9 03 00 00
	00		 mov	 r9d, 3
  003ad	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG190840
  003b4	ba e3 07 00 00	 mov	 edx, 2019		; 000007e3H
  003b9	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG190841
  003c0	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 2020 :             goto error_ret;

  003c6	e9 cf 02 00 00	 jmp	 $error_ret$30
$LN18@parse_devn:

; 2021 :         }
; 2022 : 
; 2023 :         if (!gcount)

  003cb	48 83 bc 24 80
	00 00 00 00	 cmp	 QWORD PTR gcount$[rsp], 0
  003d4	75 11		 jne	 SHORT $LN19@parse_devn

; 2024 :         {
; 2025 :             basechan = (cuu1 >> 8) & 0xff;

  003d6	0f b7 44 24 50	 movzx	 eax, WORD PTR cuu1$[rsp]
  003db	c1 f8 08	 sar	 eax, 8
  003de	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  003e3	89 44 24 68	 mov	 DWORD PTR basechan$[rsp], eax
$LN19@parse_devn:

; 2026 :         }
; 2027 : 
; 2028 :         badcuu = -1;

  003e7	c7 44 24 6c ff
	ff ff ff	 mov	 DWORD PTR badcuu$[rsp], -1

; 2029 : 
; 2030 :         if (((cuu1 >> 8) & 0xff) != basechan)

  003ef	0f b7 44 24 50	 movzx	 eax, WORD PTR cuu1$[rsp]
  003f4	c1 f8 08	 sar	 eax, 8
  003f7	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  003fc	3b 44 24 68	 cmp	 eax, DWORD PTR basechan$[rsp]
  00400	74 0b		 je	 SHORT $LN20@parse_devn

; 2031 :         {
; 2032 :             badcuu = cuu1;

  00402	0f b7 44 24 50	 movzx	 eax, WORD PTR cuu1$[rsp]
  00407	89 44 24 6c	 mov	 DWORD PTR badcuu$[rsp], eax

; 2033 :         }

  0040b	eb 1c		 jmp	 SHORT $LN21@parse_devn
$LN20@parse_devn:

; 2034 :         else
; 2035 :         {
; 2036 :             if (((cuu2 >> 8) & 0xff) != basechan)

  0040d	0f b7 44 24 54	 movzx	 eax, WORD PTR cuu2$[rsp]
  00412	c1 f8 08	 sar	 eax, 8
  00415	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  0041a	3b 44 24 68	 cmp	 eax, DWORD PTR basechan$[rsp]
  0041e	74 09		 je	 SHORT $LN22@parse_devn

; 2037 :             {
; 2038 :                 badcuu = cuu2;

  00420	0f b7 44 24 54	 movzx	 eax, WORD PTR cuu2$[rsp]
  00425	89 44 24 6c	 mov	 DWORD PTR badcuu$[rsp], eax
$LN22@parse_devn:
$LN21@parse_devn:

; 2039 :             }
; 2040 :         }
; 2041 : 
; 2042 :         if (badcuu >= 0)

  00429	83 7c 24 6c 00	 cmp	 DWORD PTR badcuu$[rsp], 0
  0042e	7c 79		 jl	 SHORT $LN23@parse_devn

; 2043 :         {
; 2044 :             // "%1d:%04X is on wrong channel, 1st device defined on channel %02X"
; 2045 :             WRMSG( HHC01472, "E", dd->lcss, badcuu, basechan );

  00430	48 8b 84 24 e8
	00 00 00	 mov	 rax, QWORD PTR dd$[rsp]
  00438	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  0043b	89 84 24 a8 00
	00 00		 mov	 DWORD PTR tv224[rsp], eax
  00442	b9 01 00 00 00	 mov	 ecx, 1
  00447	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  0044d	8b 4c 24 68	 mov	 ecx, DWORD PTR basechan$[rsp]
  00451	89 4c 24 48	 mov	 DWORD PTR [rsp+72], ecx
  00455	8b 4c 24 6c	 mov	 ecx, DWORD PTR badcuu$[rsp]
  00459	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  0045d	8b 8c 24 a8 00
	00 00		 mov	 ecx, DWORD PTR tv224[rsp]
  00464	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  00468	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG190847
  0046f	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  00474	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG190848
  0047b	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00480	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00485	41 b9 03 00 00
	00		 mov	 r9d, 3
  0048b	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG190849
  00492	ba fd 07 00 00	 mov	 edx, 2045		; 000007fdH
  00497	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG190850
  0049e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 2046 :             goto error_ret;

  004a4	e9 f1 01 00 00	 jmp	 $error_ret$30
$LN23@parse_devn:

; 2047 :         }
; 2048 : 
; 2049 :         /* Check for duplicates */
; 2050 : 
; 2051 :         duplicate = 0;

  004a9	c7 44 24 70 00
	00 00 00	 mov	 DWORD PTR duplicate$[rsp], 0

; 2052 : 
; 2053 :         for (i=0; i < gcount; i++)

  004b1	48 c7 44 24 78
	00 00 00 00	 mov	 QWORD PTR i$[rsp], 0
  004ba	eb 0d		 jmp	 SHORT $LN8@parse_devn
$LN6@parse_devn:
  004bc	48 8b 44 24 78	 mov	 rax, QWORD PTR i$[rsp]
  004c1	48 ff c0	 inc	 rax
  004c4	48 89 44 24 78	 mov	 QWORD PTR i$[rsp], rax
$LN8@parse_devn:
  004c9	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR gcount$[rsp]
  004d1	48 39 44 24 78	 cmp	 QWORD PTR i$[rsp], rax
  004d6	0f 83 b0 00 00
	00		 jae	 $LN7@parse_devn

; 2054 :         {
; 2055 :             /* check 1st cuu not within existing range */
; 2056 :             if (cuu1 >= dgrs[i].cuu1 && cuu1 <= dgrs[i].cuu2)

  004dc	0f b7 44 24 50	 movzx	 eax, WORD PTR cuu1$[rsp]
  004e1	48 8b 4c 24 58	 mov	 rcx, QWORD PTR dgrs$[rsp]
  004e6	48 8b 54 24 78	 mov	 rdx, QWORD PTR i$[rsp]
  004eb	0f b7 0c 91	 movzx	 ecx, WORD PTR [rcx+rdx*4]
  004ef	3b c1		 cmp	 eax, ecx
  004f1	7c 22		 jl	 SHORT $LN24@parse_devn
  004f3	0f b7 44 24 50	 movzx	 eax, WORD PTR cuu1$[rsp]
  004f8	48 8b 4c 24 58	 mov	 rcx, QWORD PTR dgrs$[rsp]
  004fd	48 8b 54 24 78	 mov	 rdx, QWORD PTR i$[rsp]
  00502	0f b7 4c 91 02	 movzx	 ecx, WORD PTR [rcx+rdx*4+2]
  00507	3b c1		 cmp	 eax, ecx
  00509	7f 0a		 jg	 SHORT $LN24@parse_devn

; 2057 :             {
; 2058 :                 duplicate = 1;

  0050b	c7 44 24 70 01
	00 00 00	 mov	 DWORD PTR duplicate$[rsp], 1

; 2059 :                 break;

  00513	eb 77		 jmp	 SHORT $LN7@parse_devn
$LN24@parse_devn:

; 2060 :             }
; 2061 : 
; 2062 :             /* check 2nd cuu not within existing range */
; 2063 :             if (cuu2 >= dgrs[i].cuu1 && cuu1 <= dgrs[i].cuu2)

  00515	0f b7 44 24 54	 movzx	 eax, WORD PTR cuu2$[rsp]
  0051a	48 8b 4c 24 58	 mov	 rcx, QWORD PTR dgrs$[rsp]
  0051f	48 8b 54 24 78	 mov	 rdx, QWORD PTR i$[rsp]
  00524	0f b7 0c 91	 movzx	 ecx, WORD PTR [rcx+rdx*4]
  00528	3b c1		 cmp	 eax, ecx
  0052a	7c 22		 jl	 SHORT $LN25@parse_devn
  0052c	0f b7 44 24 50	 movzx	 eax, WORD PTR cuu1$[rsp]
  00531	48 8b 4c 24 58	 mov	 rcx, QWORD PTR dgrs$[rsp]
  00536	48 8b 54 24 78	 mov	 rdx, QWORD PTR i$[rsp]
  0053b	0f b7 4c 91 02	 movzx	 ecx, WORD PTR [rcx+rdx*4+2]
  00540	3b c1		 cmp	 eax, ecx
  00542	7f 0a		 jg	 SHORT $LN25@parse_devn

; 2064 :             {
; 2065 :                 duplicate = 1;

  00544	c7 44 24 70 01
	00 00 00	 mov	 DWORD PTR duplicate$[rsp], 1

; 2066 :                 break;

  0054c	eb 3e		 jmp	 SHORT $LN7@parse_devn
$LN25@parse_devn:

; 2067 :             }
; 2068 : 
; 2069 :             /* check current range doesn't completelly overlap existing range */
; 2070 :             if (cuu1 < dgrs[i].cuu1 && cuu2 > dgrs[i].cuu2)

  0054e	0f b7 44 24 50	 movzx	 eax, WORD PTR cuu1$[rsp]
  00553	48 8b 4c 24 58	 mov	 rcx, QWORD PTR dgrs$[rsp]
  00558	48 8b 54 24 78	 mov	 rdx, QWORD PTR i$[rsp]
  0055d	0f b7 0c 91	 movzx	 ecx, WORD PTR [rcx+rdx*4]
  00561	3b c1		 cmp	 eax, ecx
  00563	7d 22		 jge	 SHORT $LN26@parse_devn
  00565	0f b7 44 24 54	 movzx	 eax, WORD PTR cuu2$[rsp]
  0056a	48 8b 4c 24 58	 mov	 rcx, QWORD PTR dgrs$[rsp]
  0056f	48 8b 54 24 78	 mov	 rdx, QWORD PTR i$[rsp]
  00574	0f b7 4c 91 02	 movzx	 ecx, WORD PTR [rcx+rdx*4+2]
  00579	3b c1		 cmp	 eax, ecx
  0057b	7e 0a		 jle	 SHORT $LN26@parse_devn

; 2071 :             {
; 2072 :                 duplicate = 1;

  0057d	c7 44 24 70 01
	00 00 00	 mov	 DWORD PTR duplicate$[rsp], 1

; 2073 :                 break;

  00585	eb 05		 jmp	 SHORT $LN7@parse_devn
$LN26@parse_devn:

; 2074 :             }
; 2075 :         }

  00587	e9 30 ff ff ff	 jmp	 $LN6@parse_devn
$LN7@parse_devn:

; 2076 : 
; 2077 :         if (duplicate)

  0058c	83 7c 24 70 00	 cmp	 DWORD PTR duplicate$[rsp], 0
  00591	74 7a		 je	 SHORT $LN27@parse_devn

; 2078 :         {
; 2079 :             // "Some or all devices in %04X-%04X duplicate already defined devices"
; 2080 :             WRMSG( HHC01473, "E", cuu1, cuu2 );

  00593	0f b7 44 24 54	 movzx	 eax, WORD PTR cuu2$[rsp]
  00598	89 84 24 ac 00
	00 00		 mov	 DWORD PTR tv274[rsp], eax
  0059f	0f b7 4c 24 50	 movzx	 ecx, WORD PTR cuu1$[rsp]
  005a4	89 8c 24 b0 00
	00 00		 mov	 DWORD PTR tv276[rsp], ecx
  005ab	b9 01 00 00 00	 mov	 ecx, 1
  005b0	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  005b6	8b 8c 24 ac 00
	00 00		 mov	 ecx, DWORD PTR tv274[rsp]
  005bd	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  005c1	8b 8c 24 b0 00
	00 00		 mov	 ecx, DWORD PTR tv276[rsp]
  005c8	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  005cc	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG190855
  005d3	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  005d8	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG190856
  005df	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  005e4	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  005e9	41 b9 03 00 00
	00		 mov	 r9d, 3
  005ef	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG190857
  005f6	ba 20 08 00 00	 mov	 edx, 2080		; 00000820H
  005fb	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG190858
  00602	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 2081 :             goto error_ret;

  00608	e9 8d 00 00 00	 jmp	 $error_ret$30
$LN27@parse_devn:

; 2082 :         }
; 2083 : 
; 2084 :         dgrs[ gcount ].cuu1 = cuu1;

  0060d	48 8b 44 24 58	 mov	 rax, QWORD PTR dgrs$[rsp]
  00612	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR gcount$[rsp]
  0061a	0f b7 54 24 50	 movzx	 edx, WORD PTR cuu1$[rsp]
  0061f	66 89 14 88	 mov	 WORD PTR [rax+rcx*4], dx

; 2085 :         dgrs[ gcount ].cuu2 = cuu2;

  00623	48 8b 44 24 58	 mov	 rax, QWORD PTR dgrs$[rsp]
  00628	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR gcount$[rsp]
  00630	0f b7 54 24 54	 movzx	 edx, WORD PTR cuu2$[rsp]
  00635	66 89 54 88 02	 mov	 WORD PTR [rax+rcx*4+2], dx

; 2086 : 
; 2087 :         gcount++;

  0063a	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR gcount$[rsp]
  00642	48 ff c0	 inc	 rax
  00645	48 89 84 24 80
	00 00 00	 mov	 QWORD PTR gcount$[rsp], rax

; 2088 : 
; 2089 :         grps = strtok_r( NULL, ",", &strtok_str );

  0064d	4c 8d 84 24 c8
	00 00 00	 lea	 r8, QWORD PTR strtok_str$[rsp]
  00655	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG190859
  0065c	33 c9		 xor	 ecx, ecx
  0065e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_strtok_r
  00664	48 89 84 24 b8
	00 00 00	 mov	 QWORD PTR grps$[rsp], rax

; 2090 :     }

  0066c	e9 33 fa ff ff	 jmp	 $LN2@parse_devn
$LN3@parse_devn:

; 2091 : 
; 2092 :     dd->da = dgrs;

  00671	48 8b 84 24 e8
	00 00 00	 mov	 rax, QWORD PTR dd$[rsp]
  00679	48 8b 4c 24 58	 mov	 rcx, QWORD PTR dgrs$[rsp]
  0067e	48 89 48 08	 mov	 QWORD PTR [rax+8], rcx

; 2093 : 
; 2094 :     free( sc );

  00682	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR sc$[rsp]
  0068a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free

; 2095 : 
; 2096 :     return gcount;

  00690	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR gcount$[rsp]
  00698	eb 1b		 jmp	 SHORT $LN1@parse_devn
$error_ret$30:

; 2097 : 
; 2098 : error_ret:
; 2099 : 
; 2100 :     free( dgrs );

  0069a	48 8b 4c 24 58	 mov	 rcx, QWORD PTR dgrs$[rsp]
  0069f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free

; 2101 :     free( sc );

  006a5	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR sc$[rsp]
  006ad	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free

; 2102 : 
; 2103 :     return 0;

  006b3	33 c0		 xor	 eax, eax
$LN1@parse_devn:

; 2104 : }

  006b5	48 81 c4 d8 00
	00 00		 add	 rsp, 216		; 000000d8H
  006bc	c3		 ret	 0
parse_devnums ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\config.c
_TEXT	SEGMENT
verbose$ = 32
spec$ = 64
lcss$ = 72
devnum$ = 80
parse_single_devnum_silent PROC

; 1903 : {

$LN3:
  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 1904 :     int verbose = FALSE;

  00013	c7 44 24 20 00
	00 00 00	 mov	 DWORD PTR verbose$[rsp], 0

; 1905 :     return parse_single_devnum_INTERNAL( spec, lcss, devnum, verbose );

  0001b	44 8b 4c 24 20	 mov	 r9d, DWORD PTR verbose$[rsp]
  00020	4c 8b 44 24 50	 mov	 r8, QWORD PTR devnum$[rsp]
  00025	48 8b 54 24 48	 mov	 rdx, QWORD PTR lcss$[rsp]
  0002a	48 8b 4c 24 40	 mov	 rcx, QWORD PTR spec$[rsp]
  0002f	e8 00 00 00 00	 call	 parse_single_devnum_INTERNAL

; 1906 : }

  00034	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00038	c3		 ret	 0
parse_single_devnum_silent ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\config.c
_TEXT	SEGMENT
verbose$ = 32
spec$ = 64
lcss$ = 72
devnum$ = 80
parse_single_devnum PROC

; 1894 : {

$LN3:
  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 1895 :     int verbose = TRUE;

  00013	c7 44 24 20 01
	00 00 00	 mov	 DWORD PTR verbose$[rsp], 1

; 1896 :     return parse_single_devnum_INTERNAL( spec, lcss, devnum, verbose );

  0001b	44 8b 4c 24 20	 mov	 r9d, DWORD PTR verbose$[rsp]
  00020	4c 8b 44 24 50	 mov	 r8, QWORD PTR devnum$[rsp]
  00025	48 8b 54 24 48	 mov	 rdx, QWORD PTR lcss$[rsp]
  0002a	48 8b 4c 24 40	 mov	 rcx, QWORD PTR spec$[rsp]
  0002f	e8 00 00 00 00	 call	 parse_single_devnum_INTERNAL

; 1897 : }

  00034	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00038	c3		 ret	 0
parse_single_devnum ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\config.c
_TEXT	SEGMENT
devnum$ = 48
i$ = 52
j$ = 56
baddev$ = 60
da$ = 64
numconfdev$ = 72
tv203 = 76
rc$ = 80
devncount$ = 88
newargv$ = 96
orig_newargv$ = 104
tv170 = 112
dnd$ = 120
wrkbfr$1 = 136
__$ArrayPad$ = 168
sdevnum$ = 192
sdevtype$ = 200
addargc$ = 208
addargv$ = 216
parse_and_attach_devices PROC

; 2113 : {

$LN23:
  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	48 81 ec b8 00
	00 00		 sub	 rsp, 184		; 000000b8H
  0001b	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00022	48 33 c4	 xor	 rax, rsp
  00025	48 89 84 24 a8
	00 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 2114 :         DEVNUMSDESC dnd;
; 2115 :         int         baddev;
; 2116 :         size_t      devncount;
; 2117 :         DEVARRAY    *da;
; 2118 :         int         i;
; 2119 :         U16         devnum;
; 2120 :         int         rc;
; 2121 :         int         numconfdev = 0;

  0002d	c7 44 24 48 00
	00 00 00	 mov	 DWORD PTR numconfdev$[rsp], 0

; 2122 :         int         j;
; 2123 :         char        **newargv;
; 2124 :         char        **orig_newargv;
; 2125 : 
; 2126 :         devncount=parse_devnums(sdevnum,&dnd);

  00035	48 8d 54 24 78	 lea	 rdx, QWORD PTR dnd$[rsp]
  0003a	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR sdevnum$[rsp]
  00042	e8 00 00 00 00	 call	 parse_devnums
  00047	48 89 44 24 58	 mov	 QWORD PTR devncount$[rsp], rax

; 2127 : 
; 2128 :         if(devncount==0)

  0004c	48 83 7c 24 58
	00		 cmp	 QWORD PTR devncount$[rsp], 0
  00052	75 0a		 jne	 SHORT $LN17@parse_and_

; 2129 :             return HERRDEVIDA; /* Invalid Device Address */

  00054	b8 fe ff ff ff	 mov	 eax, -2
  00059	e9 f0 02 00 00	 jmp	 $LN1@parse_and_
$LN17@parse_and_:

; 2130 : 
; 2131 :         /* Calculate the number of config statement device addresses */
; 2132 :         for (i=0;i<(int)devncount;i++)

  0005e	c7 44 24 34 00
	00 00 00	 mov	 DWORD PTR i$[rsp], 0
  00066	eb 0a		 jmp	 SHORT $LN4@parse_and_
$LN2@parse_and_:
  00068	8b 44 24 34	 mov	 eax, DWORD PTR i$[rsp]
  0006c	ff c0		 inc	 eax
  0006e	89 44 24 34	 mov	 DWORD PTR i$[rsp], eax
$LN4@parse_and_:
  00072	8b 44 24 58	 mov	 eax, DWORD PTR devncount$[rsp]
  00076	39 44 24 34	 cmp	 DWORD PTR i$[rsp], eax
  0007a	7d 3a		 jge	 SHORT $LN3@parse_and_

; 2133 :         {
; 2134 :             da=dnd.da;

  0007c	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR dnd$[rsp+8]
  00084	48 89 44 24 40	 mov	 QWORD PTR da$[rsp], rax

; 2135 :             numconfdev = numconfdev + ((da[i].cuu2 - da[i].cuu1) + 1);

  00089	48 63 44 24 34	 movsxd	 rax, DWORD PTR i$[rsp]
  0008e	48 8b 4c 24 40	 mov	 rcx, QWORD PTR da$[rsp]
  00093	0f b7 44 81 02	 movzx	 eax, WORD PTR [rcx+rax*4+2]
  00098	48 63 4c 24 34	 movsxd	 rcx, DWORD PTR i$[rsp]
  0009d	48 8b 54 24 40	 mov	 rdx, QWORD PTR da$[rsp]
  000a2	0f b7 0c 8a	 movzx	 ecx, WORD PTR [rdx+rcx*4]
  000a6	2b c1		 sub	 eax, ecx
  000a8	8b 4c 24 48	 mov	 ecx, DWORD PTR numconfdev$[rsp]
  000ac	8d 44 01 01	 lea	 eax, DWORD PTR [rcx+rax+1]
  000b0	89 44 24 48	 mov	 DWORD PTR numconfdev$[rsp], eax

; 2136 :         }

  000b4	eb b2		 jmp	 SHORT $LN2@parse_and_
$LN3@parse_and_:

; 2137 : 
; 2138 :         newargv=malloc(MAX_ARGS*sizeof(char *));

  000b6	b9 00 20 00 00	 mov	 ecx, 8192		; 00002000H
  000bb	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_malloc
  000c1	48 89 44 24 60	 mov	 QWORD PTR newargv$[rsp], rax

; 2139 :         orig_newargv=malloc(MAX_ARGS*sizeof(char *));

  000c6	b9 00 20 00 00	 mov	 ecx, 8192		; 00002000H
  000cb	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_malloc
  000d1	48 89 44 24 68	 mov	 QWORD PTR orig_newargv$[rsp], rax

; 2140 : 
; 2141 :         for(baddev=0,i=0;i<(int)devncount;i++)

  000d6	c7 44 24 3c 00
	00 00 00	 mov	 DWORD PTR baddev$[rsp], 0
  000de	c7 44 24 34 00
	00 00 00	 mov	 DWORD PTR i$[rsp], 0
  000e6	eb 0a		 jmp	 SHORT $LN7@parse_and_
$LN5@parse_and_:
  000e8	8b 44 24 34	 mov	 eax, DWORD PTR i$[rsp]
  000ec	ff c0		 inc	 eax
  000ee	89 44 24 34	 mov	 DWORD PTR i$[rsp], eax
$LN7@parse_and_:
  000f2	8b 44 24 58	 mov	 eax, DWORD PTR devncount$[rsp]
  000f6	39 44 24 34	 cmp	 DWORD PTR i$[rsp], eax
  000fa	0f 8d 0d 02 00
	00		 jge	 $LN6@parse_and_

; 2142 :         {
; 2143 :             da=dnd.da;

  00100	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR dnd$[rsp+8]
  00108	48 89 44 24 40	 mov	 QWORD PTR da$[rsp], rax

; 2144 :             for(devnum=da[i].cuu1;devnum<=da[i].cuu2;devnum++)

  0010d	48 63 44 24 34	 movsxd	 rax, DWORD PTR i$[rsp]
  00112	48 8b 4c 24 40	 mov	 rcx, QWORD PTR da$[rsp]
  00117	0f b7 04 81	 movzx	 eax, WORD PTR [rcx+rax*4]
  0011b	66 89 44 24 30	 mov	 WORD PTR devnum$[rsp], ax
  00120	eb 0d		 jmp	 SHORT $LN10@parse_and_
$LN8@parse_and_:
  00122	0f b7 44 24 30	 movzx	 eax, WORD PTR devnum$[rsp]
  00127	66 ff c0	 inc	 ax
  0012a	66 89 44 24 30	 mov	 WORD PTR devnum$[rsp], ax
$LN10@parse_and_:
  0012f	0f b7 44 24 30	 movzx	 eax, WORD PTR devnum$[rsp]
  00134	48 63 4c 24 34	 movsxd	 rcx, DWORD PTR i$[rsp]
  00139	48 8b 54 24 40	 mov	 rdx, QWORD PTR da$[rsp]
  0013e	0f b7 4c 8a 02	 movzx	 ecx, WORD PTR [rdx+rcx*4+2]
  00143	3b c1		 cmp	 eax, ecx
  00145	0f 8f b4 01 00
	00		 jg	 $LN9@parse_and_

; 2145 :             {
; 2146 :                char wrkbfr[32];
; 2147 :                MSGBUF( wrkbfr, "%3.3X",devnum);

  0014b	0f b7 44 24 30	 movzx	 eax, WORD PTR devnum$[rsp]
  00150	44 8b c8	 mov	 r9d, eax
  00153	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG190905
  0015a	ba 20 00 00 00	 mov	 edx, 32			; 00000020H
  0015f	48 8d 8c 24 88
	00 00 00	 lea	 rcx, QWORD PTR wrkbfr$1[rsp]
  00167	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_snprintf

; 2148 :                set_symbol("CUU",wrkbfr);

  0016d	48 8d 94 24 88
	00 00 00	 lea	 rdx, QWORD PTR wrkbfr$1[rsp]
  00175	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG190906
  0017c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_set_symbol

; 2149 :                MSGBUF( wrkbfr, "%4.4X",devnum);

  00182	0f b7 44 24 30	 movzx	 eax, WORD PTR devnum$[rsp]
  00187	44 8b c8	 mov	 r9d, eax
  0018a	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG190907
  00191	ba 20 00 00 00	 mov	 edx, 32			; 00000020H
  00196	48 8d 8c 24 88
	00 00 00	 lea	 rcx, QWORD PTR wrkbfr$1[rsp]
  0019e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_snprintf

; 2150 :                set_symbol("CCUU",wrkbfr);

  001a4	48 8d 94 24 88
	00 00 00	 lea	 rdx, QWORD PTR wrkbfr$1[rsp]
  001ac	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG190908
  001b3	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_set_symbol

; 2151 :                set_symbol("DEVN", wrkbfr);

  001b9	48 8d 94 24 88
	00 00 00	 lea	 rdx, QWORD PTR wrkbfr$1[rsp]
  001c1	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG190909
  001c8	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_set_symbol

; 2152 :                MSGBUF( wrkbfr, "%d",dnd.lcss);

  001ce	0f b6 44 24 78	 movzx	 eax, BYTE PTR dnd$[rsp]
  001d3	44 8b c8	 mov	 r9d, eax
  001d6	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG190910
  001dd	ba 20 00 00 00	 mov	 edx, 32			; 00000020H
  001e2	48 8d 8c 24 88
	00 00 00	 lea	 rcx, QWORD PTR wrkbfr$1[rsp]
  001ea	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_snprintf

; 2153 :                set_symbol("CSS",wrkbfr);

  001f0	48 8d 94 24 88
	00 00 00	 lea	 rdx, QWORD PTR wrkbfr$1[rsp]
  001f8	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG190911
  001ff	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_set_symbol

; 2154 : 
; 2155 :                for(j=0;j<addargc;j++)

  00205	c7 44 24 38 00
	00 00 00	 mov	 DWORD PTR j$[rsp], 0
  0020d	eb 0a		 jmp	 SHORT $LN13@parse_and_
$LN11@parse_and_:
  0020f	8b 44 24 38	 mov	 eax, DWORD PTR j$[rsp]
  00213	ff c0		 inc	 eax
  00215	89 44 24 38	 mov	 DWORD PTR j$[rsp], eax
$LN13@parse_and_:
  00219	8b 84 24 d0 00
	00 00		 mov	 eax, DWORD PTR addargc$[rsp]
  00220	39 44 24 38	 cmp	 DWORD PTR j$[rsp], eax
  00224	7d 44		 jge	 SHORT $LN12@parse_and_

; 2156 :                {
; 2157 :                    orig_newargv[j]=newargv[j]=resolve_symbol_string(addargv[j]);

  00226	48 63 44 24 38	 movsxd	 rax, DWORD PTR j$[rsp]
  0022b	48 8b 8c 24 d8
	00 00 00	 mov	 rcx, QWORD PTR addargv$[rsp]
  00233	48 8b 0c c1	 mov	 rcx, QWORD PTR [rcx+rax*8]
  00237	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_resolve_symbol_string
  0023d	48 89 44 24 70	 mov	 QWORD PTR tv170[rsp], rax
  00242	48 63 44 24 38	 movsxd	 rax, DWORD PTR j$[rsp]
  00247	48 8b 4c 24 60	 mov	 rcx, QWORD PTR newargv$[rsp]
  0024c	48 8b 54 24 70	 mov	 rdx, QWORD PTR tv170[rsp]
  00251	48 89 14 c1	 mov	 QWORD PTR [rcx+rax*8], rdx
  00255	48 63 44 24 38	 movsxd	 rax, DWORD PTR j$[rsp]
  0025a	48 8b 4c 24 68	 mov	 rcx, QWORD PTR orig_newargv$[rsp]
  0025f	48 8b 54 24 70	 mov	 rdx, QWORD PTR tv170[rsp]
  00264	48 89 14 c1	 mov	 QWORD PTR [rcx+rax*8], rdx

; 2158 :                }

  00268	eb a5		 jmp	 SHORT $LN11@parse_and_
$LN12@parse_and_:

; 2159 :                /* Build the device configuration block */
; 2160 :                rc=attach_device(dnd.lcss, devnum, sdevtype, addargc, newargv, devnum - da[i].cuu1 + 1);

  0026a	0f b7 44 24 30	 movzx	 eax, WORD PTR devnum$[rsp]
  0026f	48 63 4c 24 34	 movsxd	 rcx, DWORD PTR i$[rsp]
  00274	48 8b 54 24 40	 mov	 rdx, QWORD PTR da$[rsp]
  00279	0f b7 0c 8a	 movzx	 ecx, WORD PTR [rdx+rcx*4]
  0027d	2b c1		 sub	 eax, ecx
  0027f	ff c0		 inc	 eax
  00281	0f b6 4c 24 78	 movzx	 ecx, BYTE PTR dnd$[rsp]
  00286	89 44 24 28	 mov	 DWORD PTR [rsp+40], eax
  0028a	48 8b 44 24 60	 mov	 rax, QWORD PTR newargv$[rsp]
  0028f	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00294	44 8b 8c 24 d0
	00 00 00	 mov	 r9d, DWORD PTR addargc$[rsp]
  0029c	4c 8b 84 24 c8
	00 00 00	 mov	 r8, QWORD PTR sdevtype$[rsp]
  002a4	0f b7 54 24 30	 movzx	 edx, WORD PTR devnum$[rsp]
  002a9	e8 00 00 00 00	 call	 attach_device
  002ae	89 44 24 50	 mov	 DWORD PTR rc$[rsp], eax

; 2161 :                for(j=0;j<addargc;j++)

  002b2	c7 44 24 38 00
	00 00 00	 mov	 DWORD PTR j$[rsp], 0
  002ba	eb 0a		 jmp	 SHORT $LN16@parse_and_
$LN14@parse_and_:
  002bc	8b 44 24 38	 mov	 eax, DWORD PTR j$[rsp]
  002c0	ff c0		 inc	 eax
  002c2	89 44 24 38	 mov	 DWORD PTR j$[rsp], eax
$LN16@parse_and_:
  002c6	8b 84 24 d0 00
	00 00		 mov	 eax, DWORD PTR addargc$[rsp]
  002cd	39 44 24 38	 cmp	 DWORD PTR j$[rsp], eax
  002d1	7d 16		 jge	 SHORT $LN15@parse_and_

; 2162 :                {
; 2163 :                    free(orig_newargv[j]);

  002d3	48 63 44 24 38	 movsxd	 rax, DWORD PTR j$[rsp]
  002d8	48 8b 4c 24 68	 mov	 rcx, QWORD PTR orig_newargv$[rsp]
  002dd	48 8b 0c c1	 mov	 rcx, QWORD PTR [rcx+rax*8]
  002e1	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free

; 2164 :                }

  002e7	eb d3		 jmp	 SHORT $LN14@parse_and_
$LN15@parse_and_:

; 2165 : 
; 2166 :                if(rc!=0)

  002e9	83 7c 24 50 00	 cmp	 DWORD PTR rc$[rsp], 0
  002ee	74 0a		 je	 SHORT $LN18@parse_and_

; 2167 :                {
; 2168 :                    baddev=1;

  002f0	c7 44 24 3c 01
	00 00 00	 mov	 DWORD PTR baddev$[rsp], 1

; 2169 :                    break;

  002f8	eb 05		 jmp	 SHORT $LN9@parse_and_
$LN18@parse_and_:

; 2170 :                }
; 2171 :             }

  002fa	e9 23 fe ff ff	 jmp	 $LN8@parse_and_
$LN9@parse_and_:

; 2172 :             if(baddev)

  002ff	83 7c 24 3c 00	 cmp	 DWORD PTR baddev$[rsp], 0
  00304	74 02		 je	 SHORT $LN19@parse_and_

; 2173 :             {
; 2174 :                 break;

  00306	eb 05		 jmp	 SHORT $LN6@parse_and_
$LN19@parse_and_:

; 2175 :             }
; 2176 :         }

  00308	e9 db fd ff ff	 jmp	 $LN5@parse_and_
$LN6@parse_and_:

; 2177 : 
; 2178 :         free(newargv);

  0030d	48 8b 4c 24 60	 mov	 rcx, QWORD PTR newargv$[rsp]
  00312	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free

; 2179 :         free(orig_newargv);

  00318	48 8b 4c 24 68	 mov	 rcx, QWORD PTR orig_newargv$[rsp]
  0031d	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free

; 2180 : 
; 2181 :         free(dnd.da);

  00323	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR dnd$[rsp+8]
  0032b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free

; 2182 :         return baddev?-1:0;

  00331	83 7c 24 3c 00	 cmp	 DWORD PTR baddev$[rsp], 0
  00336	74 0a		 je	 SHORT $LN21@parse_and_
  00338	c7 44 24 4c ff
	ff ff ff	 mov	 DWORD PTR tv203[rsp], -1
  00340	eb 08		 jmp	 SHORT $LN22@parse_and_
$LN21@parse_and_:
  00342	c7 44 24 4c 00
	00 00 00	 mov	 DWORD PTR tv203[rsp], 0
$LN22@parse_and_:
  0034a	8b 44 24 4c	 mov	 eax, DWORD PTR tv203[rsp]
$LN1@parse_and_:

; 2183 : }

  0034e	48 8b 8c 24 a8
	00 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  00356	48 33 cc	 xor	 rcx, rsp
  00359	e8 00 00 00 00	 call	 __security_check_cookie
  0035e	48 81 c4 b8 00
	00 00		 add	 rsp, 184		; 000000b8H
  00365	c3		 ret	 0
parse_and_attach_devices ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\config.c
_TEXT	SEGMENT
rc$ = 64
tid$ = 68
dev$ = 72
tv135 = 80
tv169 = 88
shrdport$ = 112
configure_shrdport PROC

; 940  : {

$LN11:
  00000	66 89 4c 24 08	 mov	 WORD PTR [rsp+8], cx
  00005	48 83 ec 68	 sub	 rsp, 104		; 00000068H

; 941  :     int      rc;
; 942  :     DEVBLK*  dev;
; 943  :     TID      tid;
; 944  : 
; 945  :     obtain_lock( &sysblk.shrdlock );

  00009	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00010	48 05 98 13 00
	00		 add	 rax, 5016		; 00001398H
  00016	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG190346
  0001d	48 8b c8	 mov	 rcx, rax
  00020	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_obtain_lock

; 946  : 
; 947  :     if (shrdport && sysblk.shrdport)

  00026	0f b7 44 24 70	 movzx	 eax, WORD PTR shrdport$[rsp]
  0002b	85 c0		 test	 eax, eax
  0002d	0f 84 80 00 00
	00		 je	 $LN5@configure_
  00033	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  0003a	0f b7 80 ac 13
	00 00		 movzx	 eax, WORD PTR [rax+5036]
  00041	85 c0		 test	 eax, eax
  00043	74 6e		 je	 SHORT $LN5@configure_

; 948  :     {
; 949  :         release_lock( &sysblk.shrdlock );

  00045	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  0004c	48 05 98 13 00
	00		 add	 rax, 5016		; 00001398H
  00052	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG190348
  00059	48 8b c8	 mov	 rcx, rax
  0005c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_release_lock

; 950  :         // "Shared: Server already active"
; 951  :         WRMSG( HHC00744, "E" );

  00062	b9 01 00 00 00	 mov	 ecx, 1
  00067	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  0006d	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG190349
  00074	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  00079	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG190350
  00080	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00085	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  0008a	41 b9 03 00 00
	00		 mov	 r9d, 3
  00090	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG190351
  00097	ba b7 03 00 00	 mov	 edx, 951		; 000003b7H
  0009c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG190352
  000a3	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 952  :         return -1;

  000a9	b8 ff ff ff ff	 mov	 eax, -1
  000ae	e9 5a 02 00 00	 jmp	 $LN1@configure_
$LN5@configure_:

; 953  :     }
; 954  : 
; 955  :     /* Set requested shared port number */
; 956  :     sysblk.shrdport = shrdport;

  000b3	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  000ba	0f b7 4c 24 70	 movzx	 ecx, WORD PTR shrdport$[rsp]
  000bf	66 89 88 ac 13
	00 00		 mov	 WORD PTR [rax+5036], cx

; 957  : 
; 958  :     /* Terminate the shared_server thread if requested */
; 959  :     if (!sysblk.shrdport)

  000c6	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  000cd	0f b7 80 ac 13
	00 00		 movzx	 eax, WORD PTR [rax+5036]
  000d4	85 c0		 test	 eax, eax
  000d6	75 2c		 jne	 SHORT $LN6@configure_

; 960  :     {
; 961  :         shutdown_shared_server_locked( NULL );

  000d8	33 c9		 xor	 ecx, ecx
  000da	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_shutdown_shared_server_locked

; 962  :         release_lock( &sysblk.shrdlock );

  000e0	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  000e7	48 05 98 13 00
	00		 add	 rax, 5016		; 00001398H
  000ed	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG190354
  000f4	48 8b c8	 mov	 rcx, rax
  000f7	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_release_lock

; 963  :         return 0;

  000fd	33 c0		 xor	 eax, eax
  000ff	e9 09 02 00 00	 jmp	 $LN1@configure_
$LN6@configure_:

; 964  :     }
; 965  : 
; 966  :     /* Start the shared server thread */
; 967  :     rc = create_thread( &sysblk.shrdtid, DETACHED,

  00104	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  0010b	48 05 88 10 00
	00		 add	 rax, 4232		; 00001088H
  00111	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  00118	48 81 c1 a8 13
	00 00		 add	 rcx, 5032		; 000013a8H
  0011f	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG190355
  00126	48 89 54 24 28	 mov	 QWORD PTR [rsp+40], rdx
  0012b	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG190356
  00132	48 89 54 24 20	 mov	 QWORD PTR [rsp+32], rdx
  00137	45 33 c9	 xor	 r9d, r9d
  0013a	4c 8b 05 00 00
	00 00		 mov	 r8, QWORD PTR __imp_shared_server
  00141	48 8b d0	 mov	 rdx, rax
  00144	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_create_thread
  0014a	89 44 24 40	 mov	 DWORD PTR rc$[rsp], eax

; 968  :                         shared_server, NULL, "shared_server" );
; 969  :     if (rc)

  0014e	83 7c 24 40 00	 cmp	 DWORD PTR rc$[rsp], 0
  00153	0f 84 97 00 00
	00		 je	 $LN7@configure_

; 970  :     {
; 971  :         sysblk.shrdport = 0;

  00159	33 c0		 xor	 eax, eax
  0015b	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  00162	66 89 81 ac 13
	00 00		 mov	 WORD PTR [rcx+5036], ax

; 972  :         release_lock( &sysblk.shrdlock );

  00169	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00170	48 05 98 13 00
	00		 add	 rax, 5016		; 00001398H
  00176	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG190358
  0017d	48 8b c8	 mov	 rcx, rax
  00180	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_release_lock

; 973  :         // "Error in function create_thread(): %s"
; 974  :         WRMSG( HHC00102, "E", strerror( rc ));

  00186	8b 4c 24 40	 mov	 ecx, DWORD PTR rc$[rsp]
  0018a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_strerror
  00190	48 89 44 24 50	 mov	 QWORD PTR tv135[rsp], rax
  00195	b9 01 00 00 00	 mov	 ecx, 1
  0019a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  001a0	48 8b 4c 24 50	 mov	 rcx, QWORD PTR tv135[rsp]
  001a5	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  001aa	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG190359
  001b1	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  001b6	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG190360
  001bd	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  001c2	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  001c7	41 b9 03 00 00
	00		 mov	 r9d, 3
  001cd	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG190361
  001d4	ba ce 03 00 00	 mov	 edx, 974		; 000003ceH
  001d9	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG190362
  001e0	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 975  :         return -1;

  001e6	b8 ff ff ff ff	 mov	 eax, -1
  001eb	e9 1d 01 00 00	 jmp	 $LN1@configure_
$LN7@configure_:

; 976  :     }
; 977  : 
; 978  :     release_lock( &sysblk.shrdlock );

  001f0	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  001f7	48 05 98 13 00
	00		 add	 rax, 5016		; 00001398H
  001fd	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG190363
  00204	48 8b c8	 mov	 rcx, rax
  00207	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_release_lock

; 979  : 
; 980  :     /* Retry any pending connections */
; 981  :     for (dev = sysblk.firstdev; dev != NULL; dev = dev->nextdev)

  0020d	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00214	48 8b 80 c0 11
	00 00		 mov	 rax, QWORD PTR [rax+4544]
  0021b	48 89 44 24 48	 mov	 QWORD PTR dev$[rsp], rax
  00220	eb 0e		 jmp	 SHORT $LN4@configure_
$LN2@configure_:
  00222	48 8b 44 24 48	 mov	 rax, QWORD PTR dev$[rsp]
  00227	48 8b 40 30	 mov	 rax, QWORD PTR [rax+48]
  0022b	48 89 44 24 48	 mov	 QWORD PTR dev$[rsp], rax
$LN4@configure_:
  00230	48 83 7c 24 48
	00		 cmp	 QWORD PTR dev$[rsp], 0
  00236	0f 84 cf 00 00
	00		 je	 $LN3@configure_

; 982  :     {
; 983  :         if (dev->connecting)

  0023c	48 8b 44 24 48	 mov	 rax, QWORD PTR dev$[rsp]
  00241	8b 80 f8 05 00
	00		 mov	 eax, DWORD PTR [rax+1528]
  00247	c1 e8 08	 shr	 eax, 8
  0024a	83 e0 01	 and	 eax, 1
  0024d	85 c0		 test	 eax, eax
  0024f	0f 84 b1 00 00
	00		 je	 $LN8@configure_

; 984  :         {
; 985  :             rc = create_thread( &tid, DETACHED,

  00255	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  0025c	48 05 88 10 00
	00		 add	 rax, 4232		; 00001088H
  00262	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG190365
  00269	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  0026e	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG190366
  00275	48 89 4c 24 20	 mov	 QWORD PTR [rsp+32], rcx
  0027a	4c 8b 4c 24 48	 mov	 r9, QWORD PTR dev$[rsp]
  0027f	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:shrd_devinit
  00286	48 8b d0	 mov	 rdx, rax
  00289	48 8d 4c 24 44	 lea	 rcx, QWORD PTR tid$[rsp]
  0028e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_create_thread
  00294	89 44 24 40	 mov	 DWORD PTR rc$[rsp], eax

; 986  :                        shrd_devinit, dev, "shrd_devinit" );
; 987  :             if (rc)

  00298	83 7c 24 40 00	 cmp	 DWORD PTR rc$[rsp], 0
  0029d	74 67		 je	 SHORT $LN9@configure_

; 988  :             {
; 989  :                 // "Error in function create_thread(): %s"
; 990  :                 WRMSG( HHC00102, "E", strerror( rc ));

  0029f	8b 4c 24 40	 mov	 ecx, DWORD PTR rc$[rsp]
  002a3	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_strerror
  002a9	48 89 44 24 58	 mov	 QWORD PTR tv169[rsp], rax
  002ae	b9 01 00 00 00	 mov	 ecx, 1
  002b3	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  002b9	48 8b 4c 24 58	 mov	 rcx, QWORD PTR tv169[rsp]
  002be	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  002c3	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG190368
  002ca	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  002cf	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG190369
  002d6	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  002db	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  002e0	41 b9 03 00 00
	00		 mov	 r9d, 3
  002e6	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG190370
  002ed	ba de 03 00 00	 mov	 edx, 990		; 000003deH
  002f2	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG190371
  002f9	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 991  :                 return -1;

  002ff	b8 ff ff ff ff	 mov	 eax, -1
  00304	eb 07		 jmp	 SHORT $LN1@configure_
$LN9@configure_:
$LN8@configure_:

; 992  :             }
; 993  :         }
; 994  :     }

  00306	e9 17 ff ff ff	 jmp	 $LN2@configure_
$LN3@configure_:

; 995  : 
; 996  :     return 0;

  0030b	33 c0		 xor	 eax, eax
$LN1@configure_:

; 997  : }

  0030d	48 83 c4 68	 add	 rsp, 104		; 00000068H
  00311	c3		 ret	 0
configure_shrdport ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\config.c
_TEXT	SEGMENT
archnum$ = 8
mainsize$ = 16
adjust_mainsize PROC

; 165  : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	89 4c 24 08	 mov	 DWORD PTR [rsp+8], ecx

; 166  :     static const U64 minmax_mainsize[ NUM_GEN_ARCHS ][2] =
; 167  :     {
; 168  : #if defined(       _ARCH_NUM_0 )
; 169  :   #if       370 == _ARCH_NUM_0
; 170  :       { MIN_370_MAINSIZE_BYTES,
; 171  :         MAX_370_MAINSIZE_BYTES },
; 172  : 
; 173  :   #elif     390 == _ARCH_NUM_0
; 174  :       { MIN_390_MAINSIZE_BYTES,
; 175  :         MAX_390_MAINSIZE_BYTES },
; 176  : 
; 177  :   #else //  900 == _ARCH_NUM_0
; 178  :       { MIN_900_MAINSIZE_BYTES,
; 179  :         MAX_900_MAINSIZE_BYTES },
; 180  :   #endif
; 181  : #endif
; 182  : #if defined(       _ARCH_NUM_1 )
; 183  :   #if       370 == _ARCH_NUM_1
; 184  :       { MIN_370_MAINSIZE_BYTES,
; 185  :         MAX_370_MAINSIZE_BYTES },
; 186  : 
; 187  :   #elif     390 == _ARCH_NUM_1
; 188  :       { MIN_390_MAINSIZE_BYTES,
; 189  :         MAX_390_MAINSIZE_BYTES },
; 190  : 
; 191  :   #else //  900 == _ARCH_NUM_1
; 192  :       { MIN_900_MAINSIZE_BYTES,
; 193  :         MAX_900_MAINSIZE_BYTES },
; 194  :   #endif
; 195  : #endif
; 196  : #if defined(       _ARCH_NUM_2 )
; 197  :   #if       370 == _ARCH_NUM_2
; 198  :       { MIN_370_MAINSIZE_BYTES,
; 199  :         MAX_370_MAINSIZE_BYTES },
; 200  : 
; 201  :   #elif     390 == _ARCH_NUM_2
; 202  :       { MIN_390_MAINSIZE_BYTES,
; 203  :         MAX_390_MAINSIZE_BYTES },
; 204  : 
; 205  :   #else //  900 == _ARCH_NUM_2
; 206  :       { MIN_900_MAINSIZE_BYTES,
; 207  :         MAX_900_MAINSIZE_BYTES },
; 208  :   #endif
; 209  : #endif
; 210  :     };
; 211  : 
; 212  :     if (mainsize < minmax_mainsize[ archnum ][0])

  00009	48 63 44 24 08	 movsxd	 rax, DWORD PTR archnum$[rsp]
  0000e	48 6b c0 10	 imul	 rax, rax, 16
  00012	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:?minmax_mainsize@?1??adjust_mainsize@@9@9
  00019	48 03 c8	 add	 rcx, rax
  0001c	48 8b c1	 mov	 rax, rcx
  0001f	b9 08 00 00 00	 mov	 ecx, 8
  00024	48 6b c9 00	 imul	 rcx, rcx, 0
  00028	48 8b 04 08	 mov	 rax, QWORD PTR [rax+rcx]
  0002c	48 39 44 24 10	 cmp	 QWORD PTR mainsize$[rsp], rax
  00031	73 28		 jae	 SHORT $LN2@adjust_mai

; 213  :         mainsize = minmax_mainsize[ archnum ][0];

  00033	48 63 44 24 08	 movsxd	 rax, DWORD PTR archnum$[rsp]
  00038	48 6b c0 10	 imul	 rax, rax, 16
  0003c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:?minmax_mainsize@?1??adjust_mainsize@@9@9
  00043	48 03 c8	 add	 rcx, rax
  00046	48 8b c1	 mov	 rax, rcx
  00049	b9 08 00 00 00	 mov	 ecx, 8
  0004e	48 6b c9 00	 imul	 rcx, rcx, 0
  00052	48 8b 04 08	 mov	 rax, QWORD PTR [rax+rcx]
  00056	48 89 44 24 10	 mov	 QWORD PTR mainsize$[rsp], rax
$LN2@adjust_mai:

; 214  : 
; 215  :     if (mainsize > minmax_mainsize[ archnum ][1])

  0005b	48 63 44 24 08	 movsxd	 rax, DWORD PTR archnum$[rsp]
  00060	48 6b c0 10	 imul	 rax, rax, 16
  00064	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:?minmax_mainsize@?1??adjust_mainsize@@9@9
  0006b	48 03 c8	 add	 rcx, rax
  0006e	48 8b c1	 mov	 rax, rcx
  00071	b9 08 00 00 00	 mov	 ecx, 8
  00076	48 6b c9 01	 imul	 rcx, rcx, 1
  0007a	48 8b 04 08	 mov	 rax, QWORD PTR [rax+rcx]
  0007e	48 39 44 24 10	 cmp	 QWORD PTR mainsize$[rsp], rax
  00083	76 28		 jbe	 SHORT $LN3@adjust_mai

; 216  :         mainsize = minmax_mainsize[ archnum ][1];

  00085	48 63 44 24 08	 movsxd	 rax, DWORD PTR archnum$[rsp]
  0008a	48 6b c0 10	 imul	 rax, rax, 16
  0008e	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:?minmax_mainsize@?1??adjust_mainsize@@9@9
  00095	48 03 c8	 add	 rcx, rax
  00098	48 8b c1	 mov	 rax, rcx
  0009b	b9 08 00 00 00	 mov	 ecx, 8
  000a0	48 6b c9 01	 imul	 rcx, rcx, 1
  000a4	48 8b 04 08	 mov	 rax, QWORD PTR [rax+rcx]
  000a8	48 89 44 24 10	 mov	 QWORD PTR mainsize$[rsp], rax
$LN3@adjust_mai:

; 217  : 
; 218  :     /* Special case: if no CPUs then no storage is needed */
; 219  :     if (sysblk.maxcpu <= 0)

  000ad	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  000b4	83 b8 00 01 00
	00 00		 cmp	 DWORD PTR [rax+256], 0
  000bb	7f 09		 jg	 SHORT $LN4@adjust_mai

; 220  :         mainsize = 0;

  000bd	48 c7 44 24 10
	00 00 00 00	 mov	 QWORD PTR mainsize$[rsp], 0
$LN4@adjust_mai:

; 221  : 
; 222  :     return mainsize;

  000c6	48 8b 44 24 10	 mov	 rax, QWORD PTR mainsize$[rsp]

; 223  : }

  000cb	c3		 ret	 0
adjust_mainsize ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\config.c
_TEXT	SEGMENT
xpndstor$ = 80
dofree$ = 88
mfree$ = 96
tv93 = 104
memsize$1 = 112
buf$2 = 176
__$ArrayPad$ = 240
xpndsize$ = 272
configure_xstorage PROC

; 429  : {

$LN13:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 81 ec 08 01
	00 00		 sub	 rsp, 264		; 00000108H
  0000c	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00013	48 33 c4	 xor	 rax, rsp
  00016	48 89 84 24 f0
	00 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 430  : #ifdef _FEATURE_EXPANDED_STORAGE
; 431  : 
; 432  :     BYTE*  xpndstor;
; 433  :     BYTE*  dofree = NULL;

  0001e	48 c7 44 24 58
	00 00 00 00	 mov	 QWORD PTR dofree$[rsp], 0

; 434  :     char*  mfree  = NULL;

  00027	48 c7 44 24 60
	00 00 00 00	 mov	 QWORD PTR mfree$[rsp], 0

; 435  : 
; 436  :     /* Ensure all CPUs have been stopped */
; 437  :     if (are_any_cpus_started())

  00030	e8 00 00 00 00	 call	 are_any_cpus_started
  00035	0f b6 c0	 movzx	 eax, al
  00038	85 c0		 test	 eax, eax
  0003a	74 0a		 je	 SHORT $LN2@configure_

; 438  :         return HERRCPUONL;

  0003c	b8 fd ff ff ff	 mov	 eax, -3
  00041	e9 a6 02 00 00	 jmp	 $LN1@configure_
$LN2@configure_:

; 439  : 
; 440  :     /* Release storage and return if zero or deconfiguring */
; 441  :     if (!xpndsize || xpndsize == ~0ULL)

  00046	48 83 bc 24 10
	01 00 00 00	 cmp	 QWORD PTR xpndsize$[rsp], 0
  0004f	74 0b		 je	 SHORT $LN4@configure_
  00051	48 83 bc 24 10
	01 00 00 ff	 cmp	 QWORD PTR xpndsize$[rsp], -1
  0005a	75 57		 jne	 SHORT $LN3@configure_
$LN4@configure_:

; 442  :     {
; 443  :         if (config_allocxaddr)

  0005c	48 83 3d 00 00
	00 00 00	 cmp	 QWORD PTR config_allocxaddr, 0
  00064	74 0d		 je	 SHORT $LN5@configure_

; 444  :             free(config_allocxaddr);

  00066	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR config_allocxaddr
  0006d	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free
$LN5@configure_:

; 445  : 
; 446  :         sysblk.xpndsize = 0;

  00073	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  0007a	c7 80 ac 00 00
	00 00 00 00 00	 mov	 DWORD PTR [rax+172], 0

; 447  :         sysblk.xpndstor = 0;

  00084	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  0008b	48 c7 80 b0 00
	00 00 00 00 00
	00		 mov	 QWORD PTR [rax+176], 0

; 448  : 
; 449  :         config_allocxsize = 0;

  00096	48 c7 05 00 00
	00 00 00 00 00
	00		 mov	 QWORD PTR config_allocxsize, 0

; 450  :         config_allocxaddr = NULL;

  000a1	48 c7 05 00 00
	00 00 00 00 00
	00		 mov	 QWORD PTR config_allocxaddr, 0

; 451  : 
; 452  :         return 0;

  000ac	33 c0		 xor	 eax, eax
  000ae	e9 39 02 00 00	 jmp	 $LN1@configure_
$LN3@configure_:

; 453  :     }
; 454  : 
; 455  :     /* New memory is obtained only if the requested and calculated size
; 456  :      * is larger than the last allocated size.
; 457  :      */
; 458  :     if (xpndsize > config_allocxsize)

  000b3	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR config_allocxsize
  000ba	48 39 84 24 10
	01 00 00	 cmp	 QWORD PTR xpndsize$[rsp], rax
  000c2	0f 86 9a 01 00
	00		 jbe	 $LN6@configure_

; 459  :     {
; 460  :         if (config_mfree)

  000c8	48 83 3d 00 00
	00 00 00	 cmp	 QWORD PTR config_mfree, 0
  000d0	74 12		 je	 SHORT $LN8@configure_

; 461  :             mfree = malloc( config_mfree );

  000d2	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR config_mfree
  000d9	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_malloc
  000df	48 89 44 24 60	 mov	 QWORD PTR mfree$[rsp], rax
$LN8@configure_:

; 462  : 
; 463  :         /* Obtain expanded storage, hinting to megabyte boundary */
; 464  :         xpndstor = calloc( (size_t)(xpndsize + 1), ONE_MEGABYTE );

  000e4	48 8b 84 24 10
	01 00 00	 mov	 rax, QWORD PTR xpndsize$[rsp]
  000ec	48 ff c0	 inc	 rax
  000ef	ba 00 00 10 00	 mov	 edx, 1048576		; 00100000H
  000f4	48 8b c8	 mov	 rcx, rax
  000f7	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_calloc
  000fd	48 89 44 24 50	 mov	 QWORD PTR xpndstor$[rsp], rax

; 465  : 
; 466  :         if (mfree)

  00102	48 83 7c 24 60
	00		 cmp	 QWORD PTR mfree$[rsp], 0
  00108	74 0b		 je	 SHORT $LN9@configure_

; 467  :             free( mfree );

  0010a	48 8b 4c 24 60	 mov	 rcx, QWORD PTR mfree$[rsp]
  0010f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free
$LN9@configure_:

; 468  : 
; 469  :         if (!xpndstor)

  00115	48 83 7c 24 50
	00		 cmp	 QWORD PTR xpndstor$[rsp], 0
  0011b	0f 85 d1 00 00
	00		 jne	 $LN10@configure_

; 470  :         {
; 471  :             char buf[64];
; 472  :             char memsize[64];
; 473  : 
; 474  :             sysblk.xpnd_clear = 0;

  00121	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00128	8b 80 94 12 00
	00		 mov	 eax, DWORD PTR [rax+4756]
  0012e	0f ba f0 0f	 btr	 eax, 15
  00132	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  00139	89 81 94 12 00
	00		 mov	 DWORD PTR [rcx+4756], eax

; 475  : 
; 476  :             fmt_memsize_MB( xpndsize, memsize, sizeof( memsize ));

  0013f	41 b8 40 00 00
	00		 mov	 r8d, 64			; 00000040H
  00145	48 8d 54 24 70	 lea	 rdx, QWORD PTR memsize$1[rsp]
  0014a	48 8b 8c 24 10
	01 00 00	 mov	 rcx, QWORD PTR xpndsize$[rsp]
  00152	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fmt_memsize_MB

; 477  :             MSGBUF( buf, "configure_xstorage(%s)", memsize );

  00158	4c 8d 4c 24 70	 lea	 r9, QWORD PTR memsize$1[rsp]
  0015d	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG190082
  00164	ba 40 00 00 00	 mov	 edx, 64			; 00000040H
  00169	48 8d 8c 24 b0
	00 00 00	 lea	 rcx, QWORD PTR buf$2[rsp]
  00171	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_snprintf

; 478  : 
; 479  :             // "Error in function %s: %s"
; 480  :             WRMSG( HHC01430, "S", buf, strerror( errno ));

  00177	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno
  0017d	8b 08		 mov	 ecx, DWORD PTR [rax]
  0017f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_strerror
  00185	48 89 44 24 68	 mov	 QWORD PTR tv93[rsp], rax
  0018a	b9 01 00 00 00	 mov	 ecx, 1
  0018f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  00195	48 8b 4c 24 68	 mov	 rcx, QWORD PTR tv93[rsp]
  0019a	48 89 4c 24 40	 mov	 QWORD PTR [rsp+64], rcx
  0019f	48 8d 8c 24 b0
	00 00 00	 lea	 rcx, QWORD PTR buf$2[rsp]
  001a7	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  001ac	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG190083
  001b3	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  001b8	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG190084
  001bf	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  001c4	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  001c9	41 b9 03 00 00
	00		 mov	 r9d, 3
  001cf	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG190085
  001d6	ba e0 01 00 00	 mov	 edx, 480		; 000001e0H
  001db	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG190086
  001e2	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 481  :             return -1;

  001e8	b8 ff ff ff ff	 mov	 eax, -1
  001ed	e9 fa 00 00 00	 jmp	 $LN1@configure_
$LN10@configure_:

; 482  :         }
; 483  : 
; 484  :         /* Previously allocated storage to be freed, update actual
; 485  :          * storage pointers and adjust new storage to megabyte boundary.
; 486  :          */
; 487  :         dofree = config_allocxaddr;

  001f2	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR config_allocxaddr
  001f9	48 89 44 24 58	 mov	 QWORD PTR dofree$[rsp], rax

; 488  : 
; 489  :         config_allocxsize = xpndsize;

  001fe	48 8b 84 24 10
	01 00 00	 mov	 rax, QWORD PTR xpndsize$[rsp]
  00206	48 89 05 00 00
	00 00		 mov	 QWORD PTR config_allocxsize, rax

; 490  :         config_allocxaddr = xpndstor;

  0020d	48 8b 44 24 50	 mov	 rax, QWORD PTR xpndstor$[rsp]
  00212	48 89 05 00 00
	00 00		 mov	 QWORD PTR config_allocxaddr, rax

; 491  : 
; 492  :         sysblk.xpnd_clear = 1;

  00219	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00220	8b 80 94 12 00
	00		 mov	 eax, DWORD PTR [rax+4756]
  00226	0f ba e8 0f	 bts	 eax, 15
  0022a	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  00231	89 81 94 12 00
	00		 mov	 DWORD PTR [rcx+4756], eax

; 493  : 
; 494  :         xpndstor = (BYTE*)(((U64)xpndstor + (ONE_MEGABYTE - 1)) &

  00237	48 8b 44 24 50	 mov	 rax, QWORD PTR xpndstor$[rsp]
  0023c	48 05 ff ff 0f
	00		 add	 rax, 1048575		; 000fffffH
  00242	48 25 00 00 f0
	ff		 and	 rax, -1048576		; fffffffffff00000H
  00248	48 89 44 24 50	 mov	 QWORD PTR xpndstor$[rsp], rax

; 495  :                            ~((U64)ONE_MEGABYTE - 1));
; 496  : 
; 497  :         sysblk.xpndstor = xpndstor;

  0024d	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00254	48 8b 4c 24 50	 mov	 rcx, QWORD PTR xpndstor$[rsp]
  00259	48 89 88 b0 00
	00 00		 mov	 QWORD PTR [rax+176], rcx

; 498  :     }

  00260	eb 3a		 jmp	 SHORT $LN7@configure_
$LN6@configure_:

; 499  :     else
; 500  :     {
; 501  :         xpndstor = sysblk.xpndstor;

  00262	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00269	48 8b 80 b0 00
	00 00		 mov	 rax, QWORD PTR [rax+176]
  00270	48 89 44 24 50	 mov	 QWORD PTR xpndstor$[rsp], rax

; 502  :         sysblk.xpnd_clear = 0;

  00275	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  0027c	8b 80 94 12 00
	00		 mov	 eax, DWORD PTR [rax+4756]
  00282	0f ba f0 0f	 btr	 eax, 15
  00286	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  0028d	89 81 94 12 00
	00		 mov	 DWORD PTR [rcx+4756], eax

; 503  :         dofree = NULL;

  00293	48 c7 44 24 58
	00 00 00 00	 mov	 QWORD PTR dofree$[rsp], 0
$LN7@configure_:

; 504  :     }
; 505  : 
; 506  :     sysblk.xpndstor = xpndstor;

  0029c	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  002a3	48 8b 4c 24 50	 mov	 rcx, QWORD PTR xpndstor$[rsp]
  002a8	48 89 88 b0 00
	00 00		 mov	 QWORD PTR [rax+176], rcx

; 507  :     sysblk.xpndsize = xpndsize << (SHIFT_MEBIBYTE - XSTORE_PAGESHIFT);

  002af	48 8b 84 24 10
	01 00 00	 mov	 rax, QWORD PTR xpndsize$[rsp]
  002b7	48 c1 e0 08	 shl	 rax, 8
  002bb	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  002c2	89 81 ac 00 00
	00		 mov	 DWORD PTR [rcx+172], eax

; 508  : 
; 509  :     /*  Free previously allocated storage if no longer needed
; 510  :      *
; 511  :      *  FIXME: The storage ordering further limits the amount of storage
; 512  :      *         that may be allocated following the initial storage
; 513  :      *         allocation.
; 514  :      */
; 515  :     if (dofree)

  002c8	48 83 7c 24 58
	00		 cmp	 QWORD PTR dofree$[rsp], 0
  002ce	74 0b		 je	 SHORT $LN11@configure_

; 516  :         free( dofree );

  002d0	48 8b 4c 24 58	 mov	 rcx, QWORD PTR dofree$[rsp]
  002d5	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free
$LN11@configure_:

; 517  : 
; 518  :     /* Initial power-on reset for expanded storage */
; 519  :     xstorage_clear();

  002db	e8 00 00 00 00	 call	 xstorage_clear

; 520  : 
; 521  :     configure_region_reloc();

  002e0	e8 00 00 00 00	 call	 configure_region_reloc

; 522  :     initial_cpu_reset_all();

  002e5	e8 00 00 00 00	 call	 initial_cpu_reset_all

; 523  : 
; 524  : #else /* !_FEATURE_EXPANDED_STORAGE */
; 525  : 
; 526  :     UNREFERENCED( xpndsize );
; 527  : 
; 528  :     // "Expanded storage support not installed"
; 529  :     WRMSG( HHC01431, "I" );
; 530  : 
; 531  : #endif /* !_FEATURE_EXPANDED_STORAGE */
; 532  : 
; 533  :     return 0;

  002ea	33 c0		 xor	 eax, eax
$LN1@configure_:

; 534  : }

  002ec	48 8b 8c 24 f0
	00 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  002f4	48 33 cc	 xor	 rcx, rsp
  002f7	e8 00 00 00 00	 call	 __security_check_cookie
  002fc	48 81 c4 08 01
	00 00		 add	 rsp, 264		; 00000108H
  00303	c3		 ret	 0
configure_xstorage ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\config.c
_TEXT	SEGMENT
skeysize$ = 80
storsize$ = 88
storkeys$ = 96
tv80 = 104
dofree$ = 112
mfree$ = 120
tv77 = 128
tv196 = 136
tv145 = 144
mainstor$ = 152
memsize$1 = 160
buf$2 = 224
__$ArrayPad$ = 288
mainsize$ = 320
configure_storage PROC

; 237  : {

$LN25:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 81 ec 38 01
	00 00		 sub	 rsp, 312		; 00000138H
  0000c	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00013	48 33 c4	 xor	 rax, rsp
  00016	48 89 84 24 20
	01 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 238  :     BYTE*  mainstor;
; 239  :     BYTE*  storkeys;
; 240  :     BYTE*  dofree = NULL;

  0001e	48 c7 44 24 70
	00 00 00 00	 mov	 QWORD PTR dofree$[rsp], 0

; 241  :     char*  mfree  = NULL;

  00027	48 c7 44 24 78
	00 00 00 00	 mov	 QWORD PTR mfree$[rsp], 0

; 242  :     U64    storsize;
; 243  :     U32    skeysize;
; 244  : 
; 245  :     /* Ensure all CPUs have been stopped */
; 246  :     if (are_any_cpus_started())

  00030	e8 00 00 00 00	 call	 are_any_cpus_started
  00035	0f b6 c0	 movzx	 eax, al
  00038	85 c0		 test	 eax, eax
  0003a	74 0a		 je	 SHORT $LN4@configure_

; 247  :         return HERRCPUONL;

  0003c	b8 fd ff ff ff	 mov	 eax, -3
  00041	e9 fa 04 00 00	 jmp	 $LN1@configure_
$LN4@configure_:

; 248  : 
; 249  :     /* Release storage and return if deconfiguring */
; 250  :     if (mainsize == ~0ULL)

  00046	48 83 bc 24 40
	01 00 00 ff	 cmp	 QWORD PTR mainsize$[rsp], -1
  0004f	75 6a		 jne	 SHORT $LN5@configure_

; 251  :     {
; 252  :         if (config_allocmaddr)

  00051	48 83 3d 00 00
	00 00 00	 cmp	 QWORD PTR config_allocmaddr, 0
  00059	74 0d		 je	 SHORT $LN6@configure_

; 253  :             free( config_allocmaddr );

  0005b	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR config_allocmaddr
  00062	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free
$LN6@configure_:

; 254  : 
; 255  :         sysblk.storkeys = 0;

  00068	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  0006f	48 c7 80 a0 00
	00 00 00 00 00
	00		 mov	 QWORD PTR [rax+160], 0

; 256  :         sysblk.mainstor = 0;

  0007a	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00081	48 c7 80 98 00
	00 00 00 00 00
	00		 mov	 QWORD PTR [rax+152], 0

; 257  :         sysblk.mainsize = 0;

  0008c	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00093	48 c7 80 90 00
	00 00 00 00 00
	00		 mov	 QWORD PTR [rax+144], 0

; 258  : 
; 259  :         config_allocmsize = 0;

  0009e	48 c7 05 00 00
	00 00 00 00 00
	00		 mov	 QWORD PTR config_allocmsize, 0

; 260  :         config_allocmaddr = NULL;

  000a9	48 c7 05 00 00
	00 00 00 00 00
	00		 mov	 QWORD PTR config_allocmaddr, 0

; 261  : 
; 262  :         return 0;

  000b4	33 c0		 xor	 eax, eax
  000b6	e9 85 04 00 00	 jmp	 $LN1@configure_
$LN5@configure_:

; 263  :     }
; 264  : 
; 265  :     /* Round requested storage size to architectural segment boundary
; 266  :      *
; 267  :      *    ARCH_370_IDX  1   4K page
; 268  :      *    ARCH_390_IDX  256 4K pages (or 1M)
; 269  :      *    ARCH_900_IDX  256 4K pages (or 1M)
; 270  :      */
; 271  :     if (mainsize)

  000bb	48 83 bc 24 40
	01 00 00 00	 cmp	 QWORD PTR mainsize$[rsp], 0
  000c4	74 70		 je	 SHORT $LN7@configure_

; 272  :     {
; 273  :         if (sysblk.arch_mode == ARCH_370_IDX)

  000c6	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  000cd	83 b8 88 00 00
	00 00		 cmp	 DWORD PTR [rax+136], 0
  000d4	75 38		 jne	 SHORT $LN9@configure_

; 274  :             storsize = MAX( 1, mainsize );

  000d6	48 83 bc 24 40
	01 00 00 01	 cmp	 QWORD PTR mainsize$[rsp], 1
  000df	73 0e		 jae	 SHORT $LN21@configure_
  000e1	48 c7 84 24 80
	00 00 00 01 00
	00 00		 mov	 QWORD PTR tv77[rsp], 1
  000ed	eb 10		 jmp	 SHORT $LN22@configure_
$LN21@configure_:
  000ef	48 8b 84 24 40
	01 00 00	 mov	 rax, QWORD PTR mainsize$[rsp]
  000f7	48 89 84 24 80
	00 00 00	 mov	 QWORD PTR tv77[rsp], rax
$LN22@configure_:
  000ff	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR tv77[rsp]
  00107	48 89 44 24 58	 mov	 QWORD PTR storsize$[rsp], rax
  0010c	eb 19		 jmp	 SHORT $LN10@configure_
$LN9@configure_:

; 275  :         else
; 276  :             storsize = (mainsize + 255) & ~255ULL;

  0010e	48 8b 84 24 40
	01 00 00	 mov	 rax, QWORD PTR mainsize$[rsp]
  00116	48 05 ff 00 00
	00		 add	 rax, 255		; 000000ffH
  0011c	48 25 00 ff ff
	ff		 and	 rax, -256		; ffffffffffffff00H
  00122	48 89 44 24 58	 mov	 QWORD PTR storsize$[rsp], rax
$LN10@configure_:

; 277  :         mainsize = storsize;

  00127	48 8b 44 24 58	 mov	 rax, QWORD PTR storsize$[rsp]
  0012c	48 89 84 24 40
	01 00 00	 mov	 QWORD PTR mainsize$[rsp], rax

; 278  :     }

  00134	eb 09		 jmp	 SHORT $LN8@configure_
$LN7@configure_:

; 279  :     else
; 280  :     {
; 281  :         /* Adjust zero storage case for a subsystem/device server
; 282  :          * (MAXCPU 0), allocating minimum storage of 4K.
; 283  :          */
; 284  :         storsize = 1;

  00136	48 c7 44 24 58
	01 00 00 00	 mov	 QWORD PTR storsize$[rsp], 1
$LN8@configure_:

; 285  :     }
; 286  : 
; 287  :     /* Storage key array size rounded to next page boundary */
; 288  :     switch (_STORKEY_ARRAY_UNITSIZE)

  0013f	c7 44 24 68 00
	08 00 00	 mov	 DWORD PTR tv80[rsp], 2048 ; 00000800H
  00147	81 7c 24 68 00
	08 00 00	 cmp	 DWORD PTR tv80[rsp], 2048 ; 00000800H
  0014f	74 0c		 je	 SHORT $LN11@configure_
  00151	81 7c 24 68 00
	10 00 00	 cmp	 DWORD PTR tv80[rsp], 4096 ; 00001000H
  00159	74 10		 je	 SHORT $LN12@configure_
  0015b	eb 16		 jmp	 SHORT $LN2@configure_
$LN11@configure_:

; 289  :     {
; 290  :         case _2K:
; 291  :             /* We need one storekey byte for every 2K page instead
; 292  :                of only one byte for every 4K page, so we need twice
; 293  :                as many pages as normal for our storage key array.
; 294  :             */
; 295  :             skeysize = storsize << (SHIFT_4K - SHIFT_2K);

  0015d	48 8b 44 24 58	 mov	 rax, QWORD PTR storsize$[rsp]
  00162	48 d1 e0	 shl	 rax, 1
  00165	89 44 24 50	 mov	 DWORD PTR skeysize$[rsp], eax

; 296  :             break;

  00169	eb 08		 jmp	 SHORT $LN2@configure_
$LN12@configure_:

; 297  :         case _4K:
; 298  :             skeysize = storsize;

  0016b	8b 44 24 58	 mov	 eax, DWORD PTR storsize$[rsp]
  0016f	89 44 24 50	 mov	 DWORD PTR skeysize$[rsp], eax
$LN2@configure_:

; 299  :             break;
; 300  :     }
; 301  : 
; 302  :     /* Calculate number of 4K pages we will need to allocate */
; 303  :     skeysize += (_4K-1);

  00173	8b 44 24 50	 mov	 eax, DWORD PTR skeysize$[rsp]
  00177	05 ff 0f 00 00	 add	 eax, 4095		; 00000fffH
  0017c	89 44 24 50	 mov	 DWORD PTR skeysize$[rsp], eax

; 304  :     skeysize >>= SHIFT_4K;

  00180	8b 44 24 50	 mov	 eax, DWORD PTR skeysize$[rsp]
  00184	c1 e8 0c	 shr	 eax, 12
  00187	89 44 24 50	 mov	 DWORD PTR skeysize$[rsp], eax

; 305  : 
; 306  :     /* Add number of pages needed for our storage key array */
; 307  :     storsize += skeysize;

  0018b	8b 44 24 50	 mov	 eax, DWORD PTR skeysize$[rsp]
  0018f	48 8b 4c 24 58	 mov	 rcx, QWORD PTR storsize$[rsp]
  00194	48 03 c8	 add	 rcx, rax
  00197	48 8b c1	 mov	 rax, rcx
  0019a	48 89 44 24 58	 mov	 QWORD PTR storsize$[rsp], rax

; 308  : 
; 309  :     /* New memory is obtained only if the requested and calculated size
; 310  :      * is larger than the last allocated size, or if the request is for
; 311  :      * less than 2M of memory.
; 312  :      */
; 313  :     if (0
; 314  :         || (storsize > config_allocmsize)
; 315  :         || (storsize < config_allocmsize && mainsize <= DEF_MAINSIZE_PAGES)

  0019f	33 c0		 xor	 eax, eax
  001a1	85 c0		 test	 eax, eax
  001a3	75 32		 jne	 SHORT $LN15@configure_
  001a5	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR config_allocmsize
  001ac	48 39 44 24 58	 cmp	 QWORD PTR storsize$[rsp], rax
  001b1	77 24		 ja	 SHORT $LN15@configure_
  001b3	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR config_allocmsize
  001ba	48 39 44 24 58	 cmp	 QWORD PTR storsize$[rsp], rax
  001bf	0f 83 b4 01 00
	00		 jae	 $LN13@configure_
  001c5	48 81 bc 24 40
	01 00 00 00 02
	00 00		 cmp	 QWORD PTR mainsize$[rsp], 512 ; 00000200H
  001d1	0f 87 a2 01 00
	00		 ja	 $LN13@configure_
$LN15@configure_:

; 316  :     )
; 317  :     {
; 318  :         if (config_mfree && mainsize > DEF_MAINSIZE_PAGES)

  001d7	48 83 3d 00 00
	00 00 00	 cmp	 QWORD PTR config_mfree, 0
  001df	74 20		 je	 SHORT $LN16@configure_
  001e1	48 81 bc 24 40
	01 00 00 00 02
	00 00		 cmp	 QWORD PTR mainsize$[rsp], 512 ; 00000200H
  001ed	76 12		 jbe	 SHORT $LN16@configure_

; 319  :             mfree = malloc( config_mfree );

  001ef	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR config_mfree
  001f6	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_malloc
  001fc	48 89 44 24 78	 mov	 QWORD PTR mfree$[rsp], rax
$LN16@configure_:

; 320  : 
; 321  :         /* Obtain storage with pagesize hint for cleanest allocation */
; 322  :         storkeys = calloc( (size_t)(storsize + 1), _4K );

  00201	48 8b 44 24 58	 mov	 rax, QWORD PTR storsize$[rsp]
  00206	48 ff c0	 inc	 rax
  00209	ba 00 10 00 00	 mov	 edx, 4096		; 00001000H
  0020e	48 8b c8	 mov	 rcx, rax
  00211	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_calloc
  00217	48 89 44 24 60	 mov	 QWORD PTR storkeys$[rsp], rax

; 323  : 
; 324  :         if (mfree)

  0021c	48 83 7c 24 78
	00		 cmp	 QWORD PTR mfree$[rsp], 0
  00222	74 0b		 je	 SHORT $LN17@configure_

; 325  :             free( mfree );

  00224	48 8b 4c 24 78	 mov	 rcx, QWORD PTR mfree$[rsp]
  00229	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free
$LN17@configure_:

; 326  : 
; 327  :         if (!storkeys)

  0022f	48 83 7c 24 60
	00		 cmp	 QWORD PTR storkeys$[rsp], 0
  00235	0f 85 e4 00 00
	00		 jne	 $LN18@configure_

; 328  :         {
; 329  :             char buf[64];
; 330  :             char memsize[64];
; 331  : 
; 332  :             sysblk.main_clear = 0;

  0023b	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00242	8b 80 94 12 00
	00		 mov	 eax, DWORD PTR [rax+4756]
  00248	0f ba f0 0e	 btr	 eax, 14
  0024c	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  00253	89 81 94 12 00
	00		 mov	 DWORD PTR [rcx+4756], eax

; 333  : 
; 334  :             fmt_memsize_KB( mainsize << (SHIFT_4K - SHIFT_1K), memsize, sizeof( memsize ));

  00259	48 8b 84 24 40
	01 00 00	 mov	 rax, QWORD PTR mainsize$[rsp]
  00261	48 c1 e0 02	 shl	 rax, 2
  00265	41 b8 40 00 00
	00		 mov	 r8d, 64			; 00000040H
  0026b	48 8d 94 24 a0
	00 00 00	 lea	 rdx, QWORD PTR memsize$1[rsp]
  00273	48 8b c8	 mov	 rcx, rax
  00276	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fmt_memsize_KB

; 335  :             MSGBUF( buf, "configure_storage( %s )", memsize );

  0027c	4c 8d 8c 24 a0
	00 00 00	 lea	 r9, QWORD PTR memsize$1[rsp]
  00284	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG190042
  0028b	ba 40 00 00 00	 mov	 edx, 64			; 00000040H
  00290	48 8d 8c 24 e0
	00 00 00	 lea	 rcx, QWORD PTR buf$2[rsp]
  00298	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_snprintf

; 336  : 
; 337  :             // "Error in function %s: %s"
; 338  :             WRMSG( HHC01430, "S", buf, strerror( errno ));

  0029e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno
  002a4	8b 08		 mov	 ecx, DWORD PTR [rax]
  002a6	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_strerror
  002ac	48 89 84 24 90
	00 00 00	 mov	 QWORD PTR tv145[rsp], rax
  002b4	b9 01 00 00 00	 mov	 ecx, 1
  002b9	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  002bf	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR tv145[rsp]
  002c7	48 89 4c 24 40	 mov	 QWORD PTR [rsp+64], rcx
  002cc	48 8d 8c 24 e0
	00 00 00	 lea	 rcx, QWORD PTR buf$2[rsp]
  002d4	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  002d9	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG190043
  002e0	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  002e5	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG190044
  002ec	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  002f1	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  002f6	41 b9 03 00 00
	00		 mov	 r9d, 3
  002fc	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG190045
  00303	ba 52 01 00 00	 mov	 edx, 338		; 00000152H
  00308	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG190046
  0030f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 339  :             return -1;

  00315	b8 ff ff ff ff	 mov	 eax, -1
  0031a	e9 21 02 00 00	 jmp	 $LN1@configure_
$LN18@configure_:

; 340  :         }
; 341  : 
; 342  :         /* Previously allocated storage to be freed, update actual
; 343  :          * storage pointers and adjust new storage to page boundary.
; 344  :          */
; 345  :         dofree = config_allocmaddr;

  0031f	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR config_allocmaddr
  00326	48 89 44 24 70	 mov	 QWORD PTR dofree$[rsp], rax

; 346  : 
; 347  :         config_allocmsize = storsize;

  0032b	48 8b 44 24 58	 mov	 rax, QWORD PTR storsize$[rsp]
  00330	48 89 05 00 00
	00 00		 mov	 QWORD PTR config_allocmsize, rax

; 348  :         config_allocmaddr = storkeys;

  00337	48 8b 44 24 60	 mov	 rax, QWORD PTR storkeys$[rsp]
  0033c	48 89 05 00 00
	00 00		 mov	 QWORD PTR config_allocmaddr, rax

; 349  : 
; 350  :         sysblk.main_clear = 1;

  00343	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  0034a	8b 80 94 12 00
	00		 mov	 eax, DWORD PTR [rax+4756]
  00350	0f ba e8 0e	 bts	 eax, 14
  00354	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  0035b	89 81 94 12 00
	00		 mov	 DWORD PTR [rcx+4756], eax

; 351  : 
; 352  :         storkeys = (BYTE*)(((U64)storkeys + (_4K-1)) & ~0x0FFFULL);

  00361	48 8b 44 24 60	 mov	 rax, QWORD PTR storkeys$[rsp]
  00366	48 05 ff 0f 00
	00		 add	 rax, 4095		; 00000fffH
  0036c	48 25 00 f0 ff
	ff		 and	 rax, -4096		; fffffffffffff000H
  00372	48 89 44 24 60	 mov	 QWORD PTR storkeys$[rsp], rax

; 353  :     }

  00377	eb 3a		 jmp	 SHORT $LN14@configure_
$LN13@configure_:

; 354  :     else
; 355  :     {
; 356  :         storkeys = sysblk.storkeys;

  00379	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00380	48 8b 80 a0 00
	00 00		 mov	 rax, QWORD PTR [rax+160]
  00387	48 89 44 24 60	 mov	 QWORD PTR storkeys$[rsp], rax

; 357  :         sysblk.main_clear = 0;

  0038c	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00393	8b 80 94 12 00
	00		 mov	 eax, DWORD PTR [rax+4756]
  00399	0f ba f0 0e	 btr	 eax, 14
  0039d	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  003a4	89 81 94 12 00
	00		 mov	 DWORD PTR [rcx+4756], eax

; 358  :         dofree = NULL;

  003aa	48 c7 44 24 70
	00 00 00 00	 mov	 QWORD PTR dofree$[rsp], 0
$LN14@configure_:

; 359  :     }
; 360  : 
; 361  :     /* MAINSTOR is located on the page boundary just beyond the
; 362  :        storage key array (which is already on a page boundary).
; 363  :      */
; 364  :     mainstor = (BYTE*)((U64)(storkeys + (skeysize << SHIFT_4K)));

  003b3	8b 44 24 50	 mov	 eax, DWORD PTR skeysize$[rsp]
  003b7	c1 e0 0c	 shl	 eax, 12
  003ba	8b c0		 mov	 eax, eax
  003bc	48 8b 4c 24 60	 mov	 rcx, QWORD PTR storkeys$[rsp]
  003c1	48 03 c8	 add	 rcx, rax
  003c4	48 8b c1	 mov	 rax, rcx
  003c7	48 89 84 24 98
	00 00 00	 mov	 QWORD PTR mainstor$[rsp], rax

; 365  : 
; 366  :     /* Update SYSBLK... */
; 367  :     sysblk.storkeys = storkeys;

  003cf	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  003d6	48 8b 4c 24 60	 mov	 rcx, QWORD PTR storkeys$[rsp]
  003db	48 89 88 a0 00
	00 00		 mov	 QWORD PTR [rax+160], rcx

; 368  :     sysblk.mainstor = mainstor;

  003e2	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  003e9	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR mainstor$[rsp]
  003f1	48 89 88 98 00
	00 00		 mov	 QWORD PTR [rax+152], rcx

; 369  :     sysblk.mainsize = mainsize << SHIFT_4K;

  003f8	48 8b 84 24 40
	01 00 00	 mov	 rax, QWORD PTR mainsize$[rsp]
  00400	48 c1 e0 0c	 shl	 rax, 12
  00404	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  0040b	48 89 81 90 00
	00 00		 mov	 QWORD PTR [rcx+144], rax

; 370  : 
; 371  :     /*  Free previously allocated storage if no longer needed
; 372  :      *
; 373  :      *  FIXME: The storage ordering further limits the amount of storage
; 374  :      *         that may be allocated following the initial storage
; 375  :      *         allocation.
; 376  :      */
; 377  :     if (dofree)

  00412	48 83 7c 24 70
	00		 cmp	 QWORD PTR dofree$[rsp], 0
  00418	74 0b		 je	 SHORT $LN19@configure_

; 378  :         free( dofree );

  0041a	48 8b 4c 24 70	 mov	 rcx, QWORD PTR dofree$[rsp]
  0041f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free
$LN19@configure_:

; 379  : 
; 380  :     /* Initial power-on reset for main storage */
; 381  :     storage_clear();  /* only clears if needed */

  00425	e8 00 00 00 00	 call	 storage_clear

; 382  : 
; 383  : #if 0   /* DEBUG-JJ - 20/03/2000 */
; 384  : 
; 385  :     /* Mark selected frames invalid for debugging purposes */
; 386  :     for (i = 64; i < (sysblk.mainsize / _STORKEY_ARRAY_UNITSIZE); i += 2)
; 387  :     {
; 388  :         if (i < (sysblk.mainsize / _STORKEY_ARRAY_UNITSIZE) - 64)
; 389  :             sysblk.storkeys[i]   = STORKEY_BADFRM;
; 390  :         else
; 391  :             sysblk.storkeys[i++] = STORKEY_BADFRM;
; 392  :     }
; 393  : 
; 394  : #endif
; 395  : 
; 396  : #if 1 // FIXME: The below is a kludge that will need to be cleaned up at some point in time
; 397  : 
; 398  :     /* Initialize dummy regs.
; 399  :      * Dummy regs are used by the panel or gui when the target cpu
; 400  :      * (sysblk.pcpu) is not configured (ie cpu_thread not started).
; 401  :      */
; 402  :     sysblk.dummyregs.mainstor = sysblk.mainstor;

  0042a	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00431	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  00438	48 8b 89 98 00
	00 00		 mov	 rcx, QWORD PTR [rcx+152]
  0043f	48 89 88 48 1d
	00 00		 mov	 QWORD PTR [rax+7496], rcx

; 403  :     sysblk.dummyregs.psa = (PSA_3XX*)sysblk.mainstor;

  00446	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  0044d	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  00454	48 8b 89 98 00
	00 00		 mov	 rcx, QWORD PTR [rcx+152]
  0045b	48 89 88 60 1d
	00 00		 mov	 QWORD PTR [rax+7520], rcx

; 404  :     sysblk.dummyregs.storkeys = sysblk.storkeys;

  00462	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00469	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  00470	48 8b 89 a0 00
	00 00		 mov	 rcx, QWORD PTR [rcx+160]
  00477	48 89 88 50 1d
	00 00		 mov	 QWORD PTR [rax+7504], rcx

; 405  :     sysblk.dummyregs.mainlim = sysblk.mainsize ? (sysblk.mainsize - 1) : 0;

  0047e	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00485	48 83 b8 90 00
	00 00 00	 cmp	 QWORD PTR [rax+144], 0
  0048d	74 1b		 je	 SHORT $LN23@configure_
  0048f	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00496	48 8b 80 90 00
	00 00		 mov	 rax, QWORD PTR [rax+144]
  0049d	48 ff c8	 dec	 rax
  004a0	48 89 84 24 88
	00 00 00	 mov	 QWORD PTR tv196[rsp], rax
  004a8	eb 0c		 jmp	 SHORT $LN24@configure_
$LN23@configure_:
  004aa	48 c7 84 24 88
	00 00 00 00 00
	00 00		 mov	 QWORD PTR tv196[rsp], 0
$LN24@configure_:
  004b6	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  004bd	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR tv196[rsp]
  004c5	48 89 88 58 1d
	00 00		 mov	 QWORD PTR [rax+7512], rcx

; 406  :     sysblk.dummyregs.dummy = 1;

  004cc	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  004d3	8b 80 28 1c 00
	00		 mov	 eax, DWORD PTR [rax+7208]
  004d9	0f ba e8 0a	 bts	 eax, 10
  004dd	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  004e4	89 81 28 1c 00
	00		 mov	 DWORD PTR [rcx+7208], eax

; 407  : 
; 408  :     initial_cpu_reset( &sysblk.dummyregs );

  004ea	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  004f1	48 05 00 15 00
	00		 add	 rax, 5376		; 00001500H
  004f7	48 8b c8	 mov	 rcx, rax
  004fa	e8 00 00 00 00	 call	 initial_cpu_reset

; 409  : 
; 410  :     sysblk.dummyregs.arch_mode = sysblk.arch_mode;

  004ff	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00506	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  0050d	8b 89 88 00 00
	00		 mov	 ecx, DWORD PTR [rcx+136]
  00513	89 88 64 15 00
	00		 mov	 DWORD PTR [rax+5476], ecx

; 411  :     sysblk.dummyregs.hostregs = &sysblk.dummyregs;

  00519	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00520	48 05 00 15 00
	00		 add	 rax, 5376		; 00001500H
  00526	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  0052d	48 89 81 68 1d
	00 00		 mov	 QWORD PTR [rcx+7528], rax

; 412  : 
; 413  : #endif // kludge?
; 414  : 
; 415  :     configure_region_reloc();

  00534	e8 00 00 00 00	 call	 configure_region_reloc

; 416  :     initial_cpu_reset_all();

  00539	e8 00 00 00 00	 call	 initial_cpu_reset_all

; 417  : 
; 418  :     return 0;

  0053e	33 c0		 xor	 eax, eax
$LN1@configure_:

; 419  : }

  00540	48 8b 8c 24 20
	01 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  00548	48 33 cc	 xor	 rcx, rsp
  0054b	e8 00 00 00 00	 call	 __security_check_cookie
  00550	48 81 c4 38 01
	00 00		 add	 rsp, 312		; 00000138H
  00557	c3		 ret	 0
configure_storage ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\config.c
_TEXT	SEGMENT
mfree$ = 8
configure_memfree PROC

; 153  : {

  00000	89 4c 24 08	 mov	 DWORD PTR [rsp+8], ecx

; 154  :     if (mfree < 0)

  00004	83 7c 24 08 00	 cmp	 DWORD PTR mfree$[rsp], 0
  00009	7d 0d		 jge	 SHORT $LN2@configure_

; 155  :         return config_mfree >> SHIFT_MEGABYTE;

  0000b	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR config_mfree
  00012	48 c1 e8 14	 shr	 rax, 20
  00016	eb 12		 jmp	 SHORT $LN1@configure_
$LN2@configure_:

; 156  : 
; 157  :     config_mfree = ((U64)mfree) << SHIFT_MEGABYTE;

  00018	48 63 44 24 08	 movsxd	 rax, DWORD PTR mfree$[rsp]
  0001d	48 c1 e0 14	 shl	 rax, 20
  00021	48 89 05 00 00
	00 00		 mov	 QWORD PTR config_mfree, rax

; 158  :     return 0;

  00028	33 c0		 xor	 eax, eax
$LN1@configure_:

; 159  : }

  0002a	c3		 ret	 0
configure_memfree ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\config.c
_TEXT	SEGMENT
rc$ = 32
maxcpu$ = 64
configure_maxcpu PROC

; 1251 : {

$LN6:
  00000	89 4c 24 08	 mov	 DWORD PTR [rsp+8], ecx
  00004	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 1252 :     int rc = 0;

  00008	c7 44 24 20 00
	00 00 00	 mov	 DWORD PTR rc$[rsp], 0

; 1253 :     OBTAIN_INTLOCK( NULL );

  00010	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG190480
  00017	33 c9		 xor	 ecx, ecx
  00019	e8 00 00 00 00	 call	 Obtain_Interrupt_Lock

; 1254 :     {
; 1255 :         /* Requested maxumim must be <= absolute maximum possible */
; 1256 :         if (maxcpu > MAX_CPU_ENGS)

  0001e	83 7c 24 40 40	 cmp	 DWORD PTR maxcpu$[rsp], 64 ; 00000040H
  00023	7e 15		 jle	 SHORT $LN2@configure_

; 1257 :         {
; 1258 :             RELEASE_INTLOCK( NULL );

  00025	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG190482
  0002c	33 c9		 xor	 ecx, ecx
  0002e	e8 00 00 00 00	 call	 Release_Interrupt_Lock

; 1259 :             return HERRCPUOFF;  /* CPU offline; number > maximum */

  00033	b8 fe ff ff ff	 mov	 eax, -2
  00038	eb 79		 jmp	 SHORT $LN1@configure_
$LN2@configure_:

; 1260 :         }
; 1261 : 
; 1262 :         /* All CPUs must be stopped beforehand */
; 1263 :         if (sysblk.cpus && !are_all_cpus_stopped_intlock_held())

  0003a	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00041	83 b8 04 01 00
	00 00		 cmp	 DWORD PTR [rax+260], 0
  00048	74 21		 je	 SHORT $LN3@configure_
  0004a	e8 00 00 00 00	 call	 are_all_cpus_stopped_intlock_held
  0004f	0f b6 c0	 movzx	 eax, al
  00052	85 c0		 test	 eax, eax
  00054	75 15		 jne	 SHORT $LN3@configure_

; 1264 :         {
; 1265 :             RELEASE_INTLOCK( NULL );

  00056	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG190484
  0005d	33 c9		 xor	 ecx, ecx
  0005f	e8 00 00 00 00	 call	 Release_Interrupt_Lock

; 1266 :             return HERRCPUONL; /* CPU online; not all are stopped */

  00064	b8 fd ff ff ff	 mov	 eax, -3
  00069	eb 48		 jmp	 SHORT $LN1@configure_
$LN3@configure_:

; 1267 :         }
; 1268 : 
; 1269 :         /* Set new maximum number of online CPUs */
; 1270 :         sysblk.maxcpu = maxcpu;

  0006b	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00072	8b 4c 24 40	 mov	 ecx, DWORD PTR maxcpu$[rsp]
  00076	89 88 00 01 00
	00		 mov	 DWORD PTR [rax+256], ecx

; 1271 : 
; 1272 :         /* Deconfigure excess online CPUs if necessary */
; 1273 :         if (sysblk.cpus > maxcpu)

  0007c	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00083	8b 4c 24 40	 mov	 ecx, DWORD PTR maxcpu$[rsp]
  00087	39 88 04 01 00
	00		 cmp	 DWORD PTR [rax+260], ecx
  0008d	7e 0d		 jle	 SHORT $LN4@configure_

; 1274 :             rc = configure_numcpu_intlock_held( maxcpu );

  0008f	8b 4c 24 40	 mov	 ecx, DWORD PTR maxcpu$[rsp]
  00093	e8 00 00 00 00	 call	 configure_numcpu_intlock_held
  00098	89 44 24 20	 mov	 DWORD PTR rc$[rsp], eax
$LN4@configure_:

; 1275 : 
; 1276 :         /* Update all CPU IDs to reflect new MAXCPU */
; 1277 :         resetAllCpuIds();

  0009c	e8 00 00 00 00	 call	 resetAllCpuIds

; 1278 :     }
; 1279 :     RELEASE_INTLOCK( NULL );

  000a1	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG190486
  000a8	33 c9		 xor	 ecx, ecx
  000aa	e8 00 00 00 00	 call	 Release_Interrupt_Lock

; 1280 :     return rc;

  000af	8b 44 24 20	 mov	 eax, DWORD PTR rc$[rsp]
$LN1@configure_:

; 1281 : }

  000b3	48 83 c4 38	 add	 rsp, 56			; 00000038H
  000b7	c3		 ret	 0
configure_maxcpu ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\config.c
_TEXT	SEGMENT
rc$ = 32
numcpu$ = 64
configure_numcpu PROC

; 1231 : {

$LN4:
  00000	89 4c 24 08	 mov	 DWORD PTR [rsp+8], ecx
  00004	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 1232 :     int rc = 0;

  00008	c7 44 24 20 00
	00 00 00	 mov	 DWORD PTR rc$[rsp], 0

; 1233 : 
; 1234 :     OBTAIN_INTLOCK( NULL );

  00010	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG190469
  00017	33 c9		 xor	 ecx, ecx
  00019	e8 00 00 00 00	 call	 Obtain_Interrupt_Lock

; 1235 :     {
; 1236 :         rc = configure_numcpu_intlock_held( numcpu );

  0001e	8b 4c 24 40	 mov	 ecx, DWORD PTR numcpu$[rsp]
  00022	e8 00 00 00 00	 call	 configure_numcpu_intlock_held
  00027	89 44 24 20	 mov	 DWORD PTR rc$[rsp], eax

; 1237 : 
; 1238 :         /* Update all CPU IDs to reflect new NUMCPU */
; 1239 :         if (rc == 0)

  0002b	83 7c 24 20 00	 cmp	 DWORD PTR rc$[rsp], 0
  00030	75 05		 jne	 SHORT $LN2@configure_

; 1240 :             resetAllCpuIds();

  00032	e8 00 00 00 00	 call	 resetAllCpuIds
$LN2@configure_:

; 1241 :     }
; 1242 :     RELEASE_INTLOCK( NULL );

  00037	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG190471
  0003e	33 c9		 xor	 ecx, ecx
  00040	e8 00 00 00 00	 call	 Release_Interrupt_Lock

; 1243 : 
; 1244 :     return rc;

  00045	8b 44 24 20	 mov	 eax, DWORD PTR rc$[rsp]

; 1245 : }

  00049	48 83 c4 38	 add	 rsp, 56			; 00000038H
  0004d	c3		 ret	 0
configure_numcpu ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\config.c
_TEXT	SEGMENT
arecpu$1 = 32
ourcpu$2 = 36
target_cpu$ = 64
deconfigure_cpu PROC

; 1117 : {

$LN18:
  00000	89 4c 24 08	 mov	 DWORD PTR [rsp+8], ecx
  00004	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 1118 :     /* If CPU isn't already deconfigured... */
; 1119 :     if (IS_CPU_ONLINE( target_cpu ))

  00008	48 63 44 24 40	 movsxd	 rax, DWORD PTR target_cpu$[rsp]
  0000d	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  00014	48 83 bc c1 98
	0b 00 00 00	 cmp	 QWORD PTR [rcx+rax*8+2968], 0
  0001d	0f 84 9c 02 00
	00		 je	 $LN10@deconfigur

; 1120 :     {
; 1121 :         int   ourcpu;
; 1122 :         bool  arecpu  = are_cpu_thread( &ourcpu );

  00023	48 8d 4c 24 24	 lea	 rcx, QWORD PTR ourcpu$2[rsp]
  00028	e8 00 00 00 00	 call	 are_cpu_thread
  0002d	88 44 24 20	 mov	 BYTE PTR arecpu$1[rsp], al

; 1123 : 
; 1124 :         if (!arecpu || target_cpu != ourcpu)  // NORMAL CASE

  00031	0f b6 44 24 20	 movzx	 eax, BYTE PTR arecpu$1[rsp]
  00036	85 c0		 test	 eax, eax
  00038	74 0e		 je	 SHORT $LN13@deconfigur
  0003a	8b 44 24 24	 mov	 eax, DWORD PTR ourcpu$2[rsp]
  0003e	39 44 24 40	 cmp	 DWORD PTR target_cpu$[rsp], eax
  00042	0f 84 7b 01 00
	00		 je	 $LN11@deconfigur
$LN13@deconfigur:

; 1125 :         {
; 1126 :             /* We're either not a CPU thread, or if we are,
; 1127 :                we're not attempting to deconfigure ourself.
; 1128 :             */
; 1129 : 
; 1130 :             /* Deconfigure CPU */
; 1131 :             sysblk.regs[ target_cpu ]->configured = 0;

  00048	48 63 44 24 40	 movsxd	 rax, DWORD PTR target_cpu$[rsp]
  0004d	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  00054	48 8b 84 c1 98
	0b 00 00	 mov	 rax, QWORD PTR [rcx+rax*8+2968]
  0005c	8b 80 28 07 00
	00		 mov	 eax, DWORD PTR [rax+1832]
  00062	0f ba f0 0b	 btr	 eax, 11
  00066	48 63 4c 24 40	 movsxd	 rcx, DWORD PTR target_cpu$[rsp]
  0006b	48 8b 15 00 00
	00 00		 mov	 rdx, QWORD PTR __imp_sysblk
  00072	48 8b 8c ca 98
	0b 00 00	 mov	 rcx, QWORD PTR [rdx+rcx*8+2968]
  0007a	89 81 28 07 00
	00		 mov	 DWORD PTR [rcx+1832], eax

; 1132 :             sysblk.regs[ target_cpu ]->cpustate = CPUSTATE_STOPPING;

  00080	48 63 44 24 40	 movsxd	 rax, DWORD PTR target_cpu$[rsp]
  00085	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  0008c	48 8b 84 c1 98
	0b 00 00	 mov	 rax, QWORD PTR [rcx+rax*8+2968]
  00094	c6 40 60 02	 mov	 BYTE PTR [rax+96], 2
$LN4@deconfigur:

; 1133 :             ON_IC_INTERRUPT( sysblk.regs[ target_cpu ]);

  00098	48 63 44 24 40	 movsxd	 rax, DWORD PTR target_cpu$[rsp]
  0009d	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  000a4	48 8b 84 c1 98
	0b 00 00	 mov	 rax, QWORD PTR [rcx+rax*8+2968]
  000ac	8b 40 48	 mov	 eax, DWORD PTR [rax+72]
  000af	0f ba e8 1f	 bts	 eax, 31
  000b3	48 63 4c 24 40	 movsxd	 rcx, DWORD PTR target_cpu$[rsp]
  000b8	48 8b 15 00 00
	00 00		 mov	 rdx, QWORD PTR __imp_sysblk
  000bf	48 8b 8c ca 98
	0b 00 00	 mov	 rcx, QWORD PTR [rdx+rcx*8+2968]
  000c7	89 41 48	 mov	 DWORD PTR [rcx+72], eax
  000ca	33 c0		 xor	 eax, eax
  000cc	85 c0		 test	 eax, eax
  000ce	75 c8		 jne	 SHORT $LN4@deconfigur

; 1134 : 
; 1135 :             /* Wake up CPU as it may be waiting */
; 1136 :             WAKEUP_CPU( sysblk.regs[ target_cpu ]);

  000d0	48 63 44 24 40	 movsxd	 rax, DWORD PTR target_cpu$[rsp]
  000d5	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG190439
  000dc	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  000e3	48 8b 8c c1 98
	0b 00 00	 mov	 rcx, QWORD PTR [rcx+rax*8+2968]
  000eb	e8 00 00 00 00	 call	 wakeup_cpu

; 1137 : 
; 1138 :             /* (if we're a cpu thread) */
; 1139 :             if (arecpu)

  000f0	0f b6 44 24 20	 movzx	 eax, BYTE PTR arecpu$1[rsp]
  000f5	85 c0		 test	 eax, eax
  000f7	74 1b		 je	 SHORT $LN14@deconfigur

; 1140 :                 sysblk.regs[ ourcpu ]->intwait = true;

  000f9	48 63 44 24 24	 movsxd	 rax, DWORD PTR ourcpu$2[rsp]
  000fe	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  00105	48 8b 84 c1 98
	0b 00 00	 mov	 rax, QWORD PTR [rcx+rax*8+2968]
  0010d	c6 80 f0 08 00
	00 01		 mov	 BYTE PTR [rax+2288], 1
$LN14@deconfigur:
$LN5@deconfigur:

; 1141 : 
; 1142 :             /* Wait for CPU thread to terminate */
; 1143 :             while (IS_CPU_ONLINE( target_cpu ))

  00114	48 63 44 24 40	 movsxd	 rax, DWORD PTR target_cpu$[rsp]
  00119	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  00120	48 83 bc c1 98
	0b 00 00 00	 cmp	 QWORD PTR [rcx+rax*8+2968], 0
  00129	74 2d		 je	 SHORT $LN6@deconfigur

; 1144 :                 wait_condition( &sysblk.cpucond, &sysblk.intlock );

  0012b	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00132	48 05 70 10 00
	00		 add	 rax, 4208		; 00001070H
  00138	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  0013f	48 81 c1 40 01
	00 00		 add	 rcx, 320		; 00000140H
  00146	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG190441
  0014d	48 8b d0	 mov	 rdx, rax
  00150	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_wait_condition
  00156	eb bc		 jmp	 SHORT $LN5@deconfigur
$LN6@deconfigur:

; 1145 : 
; 1146 :             /* (if we're a cpu thread) */
; 1147 :             if (arecpu)

  00158	0f b6 44 24 20	 movzx	 eax, BYTE PTR arecpu$1[rsp]
  0015d	85 c0		 test	 eax, eax
  0015f	74 1b		 je	 SHORT $LN15@deconfigur

; 1148 :                 sysblk.regs[ ourcpu ]->intwait = false;

  00161	48 63 44 24 24	 movsxd	 rax, DWORD PTR ourcpu$2[rsp]
  00166	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  0016d	48 8b 84 c1 98
	0b 00 00	 mov	 rax, QWORD PTR [rcx+rax*8+2968]
  00175	c6 80 f0 08 00
	00 00		 mov	 BYTE PTR [rax+2288], 0
$LN15@deconfigur:

; 1149 : 
; 1150 :             /* Wait for cpu_thread to completely exit */
; 1151 :             join_thread( sysblk.cputid[ target_cpu ], NULL );

  0017c	48 63 44 24 40	 movsxd	 rax, DWORD PTR target_cpu$[rsp]
  00181	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG190443
  00188	33 d2		 xor	 edx, edx
  0018a	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  00191	8b 8c 81 48 09
	00 00		 mov	 ecx, DWORD PTR [rcx+rax*4+2376]
  00198	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_join_thread

; 1152 :             detach_thread( sysblk.cputid[ target_cpu ]);

  0019e	48 63 44 24 40	 movsxd	 rax, DWORD PTR target_cpu$[rsp]
  001a3	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG190444
  001aa	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  001b1	8b 8c 81 48 09
	00 00		 mov	 ecx, DWORD PTR [rcx+rax*4+2376]
  001b8	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_detach_thread

; 1153 : 
; 1154 :             /*-----------------------------------------------------------*/
; 1155 :             /* Note: While this is the logical place to cleanup and to   */
; 1156 :             /*       release the associated regs context, there is also  */
; 1157 :             /*       post-processing that is done by various callers.    */
; 1158 :             /*-----------------------------------------------------------*/
; 1159 :         }

  001be	e9 88 00 00 00	 jmp	 $LN12@deconfigur
$LN11@deconfigur:

; 1160 :         else // (arecpu && target_cpu == ourcpu)    HIGHLY UNUSUAL!
; 1161 :         {
; 1162 :             /* We ARE a cpu thread *AND* we're trying to deconfigure
; 1163 :                ourself! This can only happen if B220 SERVC instruction
; 1164 :                is executed to deconfigure its own CPU, or else the CPU
; 1165 :                issues a Hercules command via the diagnose-8 interface
; 1166 :                to deconfigure its own CPU (i.e. itself).
; 1167 :             */
; 1168 :             sysblk.regs[ target_cpu ]->configured = 0;

  001c3	48 63 44 24 40	 movsxd	 rax, DWORD PTR target_cpu$[rsp]
  001c8	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  001cf	48 8b 84 c1 98
	0b 00 00	 mov	 rax, QWORD PTR [rcx+rax*8+2968]
  001d7	8b 80 28 07 00
	00		 mov	 eax, DWORD PTR [rax+1832]
  001dd	0f ba f0 0b	 btr	 eax, 11
  001e1	48 63 4c 24 40	 movsxd	 rcx, DWORD PTR target_cpu$[rsp]
  001e6	48 8b 15 00 00
	00 00		 mov	 rdx, QWORD PTR __imp_sysblk
  001ed	48 8b 8c ca 98
	0b 00 00	 mov	 rcx, QWORD PTR [rdx+rcx*8+2968]
  001f5	89 81 28 07 00
	00		 mov	 DWORD PTR [rcx+1832], eax

; 1169 :             sysblk.regs[ target_cpu ]->cpustate = CPUSTATE_STOPPING;

  001fb	48 63 44 24 40	 movsxd	 rax, DWORD PTR target_cpu$[rsp]
  00200	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  00207	48 8b 84 c1 98
	0b 00 00	 mov	 rax, QWORD PTR [rcx+rax*8+2968]
  0020f	c6 40 60 02	 mov	 BYTE PTR [rax+96], 2
$LN9@deconfigur:

; 1170 :             ON_IC_INTERRUPT( sysblk.regs[ target_cpu ]);

  00213	48 63 44 24 40	 movsxd	 rax, DWORD PTR target_cpu$[rsp]
  00218	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  0021f	48 8b 84 c1 98
	0b 00 00	 mov	 rax, QWORD PTR [rcx+rax*8+2968]
  00227	8b 40 48	 mov	 eax, DWORD PTR [rax+72]
  0022a	0f ba e8 1f	 bts	 eax, 31
  0022e	48 63 4c 24 40	 movsxd	 rcx, DWORD PTR target_cpu$[rsp]
  00233	48 8b 15 00 00
	00 00		 mov	 rdx, QWORD PTR __imp_sysblk
  0023a	48 8b 8c ca 98
	0b 00 00	 mov	 rcx, QWORD PTR [rdx+rcx*8+2968]
  00242	89 41 48	 mov	 DWORD PTR [rcx+72], eax
  00245	33 c0		 xor	 eax, eax
  00247	85 c0		 test	 eax, eax
  00249	75 c8		 jne	 SHORT $LN9@deconfigur
$LN12@deconfigur:

; 1171 :         }
; 1172 : 
; 1173 :         sysblk.cputid    [ target_cpu ] = 0;

  0024b	48 63 44 24 40	 movsxd	 rax, DWORD PTR target_cpu$[rsp]
  00250	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  00257	c7 84 81 48 09
	00 00 00 00 00
	00		 mov	 DWORD PTR [rcx+rax*4+2376], 0

; 1174 :         sysblk.cpuclockid[ target_cpu ] = 0;

  00262	48 63 44 24 40	 movsxd	 rax, DWORD PTR target_cpu$[rsp]
  00267	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  0026e	c7 84 81 48 0a
	00 00 00 00 00
	00		 mov	 DWORD PTR [rcx+rax*4+2632], 0

; 1175 : 
; 1176 : #if defined( FEATURE_011_CONFIG_TOPOLOGY_FACILITY )
; 1177 :         /* Set topology-change-report-pending condition */
; 1178 : 
; 1179 :         /* PROGRAMMING NOTE: because the CPU has been deconfigured,
; 1180 :            the REGS pointer in sysblk (i.e. sysblk.regs[ <cpunum> ])
; 1181 :            could now possibly be NULL so to be safe we will use the
; 1182 :            FACILITY_ENABLED_DEV macro instead as "sysblk.arch_mode"
; 1183 :            should ALWAYS be valid.
; 1184 :         */
; 1185 :         if (FACILITY_ENABLED_DEV( 011_CONFIG_TOPOLOGY ))

  00279	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00280	48 63 80 88 00
	00 00		 movsxd	 rax, DWORD PTR [rax+136]
  00287	48 6b c0 28	 imul	 rax, rax, 40		; 00000028H
  0028b	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  00292	48 8d 84 01 a0
	0d 00 00	 lea	 rax, QWORD PTR [rcx+rax+3488]
  0029a	b9 01 00 00 00	 mov	 ecx, 1
  0029f	48 6b c9 01	 imul	 rcx, rcx, 1
  002a3	0f b6 04 08	 movzx	 eax, BYTE PTR [rax+rcx]
  002a7	83 e0 10	 and	 eax, 16
  002aa	85 c0		 test	 eax, eax
  002ac	74 11		 je	 SHORT $LN16@deconfigur

; 1186 :             sysblk.topchnge = 1;

  002ae	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  002b5	c7 80 10 01 00
	00 01 00 00 00	 mov	 DWORD PTR [rax+272], 1
$LN16@deconfigur:
$LN10@deconfigur:

; 1187 : #endif
; 1188 :     }
; 1189 : 
; 1190 :     return 0;

  002bf	33 c0		 xor	 eax, eax

; 1191 : } /* end function deconfigure_cpu */

  002c1	48 83 c4 38	 add	 rsp, 56			; 00000038H
  002c5	c3		 ret	 0
deconfigure_cpu ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\config.c
_TEXT	SEGMENT
arecpu$1 = 64
rc$2 = 68
ourcpu$3 = 72
tv128 = 80
thread_name$4 = 88
__$ArrayPad$ = 120
target_cpu$ = 144
configure_cpu PROC

; 1049 : {

$LN12:
  00000	89 4c 24 08	 mov	 DWORD PTR [rsp+8], ecx
  00004	48 81 ec 88 00
	00 00		 sub	 rsp, 136		; 00000088H
  0000b	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00012	48 33 c4	 xor	 rax, rsp
  00015	48 89 44 24 78	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 1050 :     /* If CPU isn't already configured... */
; 1051 :     if (!IS_CPU_ONLINE( target_cpu ))

  0001a	48 63 84 24 90
	00 00 00	 movsxd	 rax, DWORD PTR target_cpu$[rsp]
  00022	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  00029	48 83 bc c1 98
	0b 00 00 00	 cmp	 QWORD PTR [rcx+rax*8+2968], 0
  00032	0f 85 b1 02 00
	00		 jne	 $LN4@configure_

; 1052 :     {
; 1053 :         int   rc;
; 1054 :         char  thread_name[32];
; 1055 :         bool  arecpu;
; 1056 :         int   ourcpu;
; 1057 : 
; 1058 :         /* If no more CPUs are permitted, exit */
; 1059 :         if (sysblk.cpus >= sysblk.maxcpu)

  00038	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  0003f	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  00046	8b 89 00 01 00
	00		 mov	 ecx, DWORD PTR [rcx+256]
  0004c	39 88 04 01 00
	00		 cmp	 DWORD PTR [rax+260], ecx
  00052	7c 0a		 jl	 SHORT $LN5@configure_

; 1060 :             return HERRCPUOFF; /* CPU offline; maximum reached */

  00054	b8 fe ff ff ff	 mov	 eax, -2
  00059	e9 8d 02 00 00	 jmp	 $LN1@configure_
$LN5@configure_:

; 1061 : 
; 1062 :         MSGBUF( thread_name, "Processor %s%02X",

  0005e	48 63 84 24 90
	00 00 00	 movsxd	 rax, DWORD PTR target_cpu$[rsp]
  00066	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  0006d	0f b6 8c 01 48
	0b 00 00	 movzx	 ecx, BYTE PTR [rcx+rax+2888]
  00075	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ptyp2short
  0007b	8b 8c 24 90 00
	00 00		 mov	 ecx, DWORD PTR target_cpu$[rsp]
  00082	89 4c 24 20	 mov	 DWORD PTR [rsp+32], ecx
  00086	4c 8b c8	 mov	 r9, rax
  00089	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG190401
  00090	ba 20 00 00 00	 mov	 edx, 32			; 00000020H
  00095	48 8d 4c 24 58	 lea	 rcx, QWORD PTR thread_name$4[rsp]
  0009a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_snprintf

; 1063 :             PTYPSTR( target_cpu ), target_cpu );
; 1064 : 
; 1065 :         rc = create_thread( &sysblk.cputid[ target_cpu ], JOINABLE,

  000a0	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  000a7	48 05 98 10 00
	00		 add	 rax, 4248		; 00001098H
  000ad	48 63 8c 24 90
	00 00 00	 movsxd	 rcx, DWORD PTR target_cpu$[rsp]
  000b5	48 8b 15 00 00
	00 00		 mov	 rdx, QWORD PTR __imp_sysblk
  000bc	48 8d 8c 8a 48
	09 00 00	 lea	 rcx, QWORD PTR [rdx+rcx*4+2376]
  000c4	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG190402
  000cb	48 89 54 24 28	 mov	 QWORD PTR [rsp+40], rdx
  000d0	48 8d 54 24 58	 lea	 rdx, QWORD PTR thread_name$4[rsp]
  000d5	48 89 54 24 20	 mov	 QWORD PTR [rsp+32], rdx
  000da	4c 8d 8c 24 90
	00 00 00	 lea	 r9, QWORD PTR target_cpu$[rsp]
  000e2	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:cpu_thread
  000e9	48 8b d0	 mov	 rdx, rax
  000ec	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_create_thread
  000f2	89 44 24 44	 mov	 DWORD PTR rc$2[rsp], eax

; 1066 :                             cpu_thread, &target_cpu, thread_name );
; 1067 :         if (rc)

  000f6	83 7c 24 44 00	 cmp	 DWORD PTR rc$2[rsp], 0
  000fb	74 6a		 je	 SHORT $LN6@configure_

; 1068 :         {
; 1069 :             // "Error in function create_thread(): %s"
; 1070 :             WRMSG( HHC00102, "E", strerror( rc ));

  000fd	8b 4c 24 44	 mov	 ecx, DWORD PTR rc$2[rsp]
  00101	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_strerror
  00107	48 89 44 24 50	 mov	 QWORD PTR tv128[rsp], rax
  0010c	b9 01 00 00 00	 mov	 ecx, 1
  00111	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  00117	48 8b 4c 24 50	 mov	 rcx, QWORD PTR tv128[rsp]
  0011c	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  00121	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG190404
  00128	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  0012d	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG190405
  00134	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00139	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  0013e	41 b9 03 00 00
	00		 mov	 r9d, 3
  00144	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG190406
  0014b	ba 2e 04 00 00	 mov	 edx, 1070		; 0000042eH
  00150	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG190407
  00157	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 1071 :             return HERRCPUOFF; /* CPU offline; create_thread failed */

  0015d	b8 fe ff ff ff	 mov	 eax, -2
  00162	e9 84 01 00 00	 jmp	 $LN1@configure_
$LN6@configure_:

; 1072 :         }
; 1073 : 
; 1074 : #if defined( _POSIX_THREAD_CPUTIME ) && (_POSIX_THREAD_CPUTIME >= 0)
; 1075 :         /* Initialise the CPU's thread clockid so that clock_gettime() can use it */
; 1076 :         /* provided the _POSIX_THREAD_CPUTIME is supported.                       */
; 1077 :         pthread_getcpuclockid( sysblk.cputid[ target_cpu ], &sysblk.cpuclockid[ target_cpu ]);

  00167	48 63 84 24 90
	00 00 00	 movsxd	 rax, DWORD PTR target_cpu$[rsp]
  0016f	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  00176	48 8d 84 81 48
	0a 00 00	 lea	 rax, QWORD PTR [rcx+rax*4+2632]
  0017e	48 63 8c 24 90
	00 00 00	 movsxd	 rcx, DWORD PTR target_cpu$[rsp]
  00186	48 8b d0	 mov	 rdx, rax
  00189	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00190	8b 8c 88 48 09
	00 00		 mov	 ecx, DWORD PTR [rax+rcx*4+2376]
  00197	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_pthread_getcpuclockid

; 1078 :         if (!sysblk.hhc_111_112)

  0019d	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  001a4	0f b6 80 3e 01
	00 00		 movzx	 eax, BYTE PTR [rax+318]
  001ab	85 c0		 test	 eax, eax
  001ad	75 4f		 jne	 SHORT $LN7@configure_

; 1079 :             WRMSG( HHC00111, "I", _POSIX_THREAD_CPUTIME );

  001af	b9 01 00 00 00	 mov	 ecx, 1
  001b4	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  001ba	c7 44 24 38 01
	00 00 00	 mov	 DWORD PTR [rsp+56], 1
  001c2	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG190409
  001c9	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  001ce	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG190410
  001d5	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  001da	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  001df	41 b9 03 00 00
	00		 mov	 r9d, 3
  001e5	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG190411
  001ec	ba 37 04 00 00	 mov	 edx, 1079		; 00000437H
  001f1	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG190412
  001f8	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg
$LN7@configure_:

; 1080 : #else
; 1081 :         /* When not supported, we zero the cpuclockid, which will trigger a       */
; 1082 :         /* different approach to obtain the thread CPU time in clock.c            */
; 1083 :         sysblk.cpuclockid[ target_cpu ] = 0;
; 1084 :         if (!sysblk.hhc_111_112)
; 1085 :             WRMSG( HHC00112, "W" );
; 1086 : #endif
; 1087 :         sysblk.hhc_111_112 = true;

  001fe	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00205	c6 80 3e 01 00
	00 01		 mov	 BYTE PTR [rax+318], 1

; 1088 : 
; 1089 :         /* Find out if we are a cpu thread */
; 1090 :         arecpu = are_cpu_thread( &ourcpu );

  0020c	48 8d 4c 24 48	 lea	 rcx, QWORD PTR ourcpu$3[rsp]
  00211	e8 00 00 00 00	 call	 are_cpu_thread
  00216	88 44 24 40	 mov	 BYTE PTR arecpu$1[rsp], al

; 1091 : 
; 1092 :         if (arecpu)

  0021a	0f b6 44 24 40	 movzx	 eax, BYTE PTR arecpu$1[rsp]
  0021f	85 c0		 test	 eax, eax
  00221	74 1b		 je	 SHORT $LN8@configure_

; 1093 :             sysblk.regs[ ourcpu ]->intwait = true;

  00223	48 63 44 24 48	 movsxd	 rax, DWORD PTR ourcpu$3[rsp]
  00228	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  0022f	48 8b 84 c1 98
	0b 00 00	 mov	 rax, QWORD PTR [rcx+rax*8+2968]
  00237	c6 80 f0 08 00
	00 01		 mov	 BYTE PTR [rax+2288], 1
$LN8@configure_:
$LN2@configure_:

; 1094 : 
; 1095 :         /* Wait for CPU thread to initialize */
; 1096 :         while (!IS_CPU_ONLINE( target_cpu ))

  0023e	48 63 84 24 90
	00 00 00	 movsxd	 rax, DWORD PTR target_cpu$[rsp]
  00246	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  0024d	48 83 bc c1 98
	0b 00 00 00	 cmp	 QWORD PTR [rcx+rax*8+2968], 0
  00256	75 2d		 jne	 SHORT $LN3@configure_

; 1097 :             wait_condition( &sysblk.cpucond, &sysblk.intlock );

  00258	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  0025f	48 05 70 10 00
	00		 add	 rax, 4208		; 00001070H
  00265	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  0026c	48 81 c1 40 01
	00 00		 add	 rcx, 320		; 00000140H
  00273	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG190414
  0027a	48 8b d0	 mov	 rdx, rax
  0027d	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_wait_condition
  00283	eb b9		 jmp	 SHORT $LN2@configure_
$LN3@configure_:

; 1098 : 
; 1099 :         if (arecpu)

  00285	0f b6 44 24 40	 movzx	 eax, BYTE PTR arecpu$1[rsp]
  0028a	85 c0		 test	 eax, eax
  0028c	74 1b		 je	 SHORT $LN9@configure_

; 1100 :             sysblk.regs[ ourcpu ]->intwait = false;

  0028e	48 63 44 24 48	 movsxd	 rax, DWORD PTR ourcpu$3[rsp]
  00293	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  0029a	48 8b 84 c1 98
	0b 00 00	 mov	 rax, QWORD PTR [rcx+rax*8+2968]
  002a2	c6 80 f0 08 00
	00 00		 mov	 BYTE PTR [rax+2288], 0
$LN9@configure_:

; 1101 : 
; 1102 : #if defined( FEATURE_011_CONFIG_TOPOLOGY_FACILITY )
; 1103 :         /* Set topology-change-report-pending condition */
; 1104 :         if (FACILITY_ENABLED( 011_CONFIG_TOPOLOGY, sysblk.regs[ target_cpu ]))

  002a9	48 63 84 24 90
	00 00 00	 movsxd	 rax, DWORD PTR target_cpu$[rsp]
  002b1	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  002b8	48 8b 84 c1 98
	0b 00 00	 mov	 rax, QWORD PTR [rcx+rax*8+2968]
  002c0	b9 01 00 00 00	 mov	 ecx, 1
  002c5	48 6b c9 01	 imul	 rcx, rcx, 1
  002c9	0f b6 84 08 28
	0d 00 00	 movzx	 eax, BYTE PTR [rax+rcx+3368]
  002d1	83 e0 10	 and	 eax, 16
  002d4	85 c0		 test	 eax, eax
  002d6	74 11		 je	 SHORT $LN10@configure_

; 1105 :             sysblk.topchnge = 1;

  002d8	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  002df	c7 80 10 01 00
	00 01 00 00 00	 mov	 DWORD PTR [rax+272], 1
$LN10@configure_:
$LN4@configure_:

; 1106 : #endif
; 1107 :     }
; 1108 : 
; 1109 :     return 0;

  002e9	33 c0		 xor	 eax, eax
$LN1@configure_:

; 1110 : } /* end function configure_cpu */

  002eb	48 8b 4c 24 78	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  002f0	48 33 cc	 xor	 rcx, rsp
  002f3	e8 00 00 00 00	 call	 __security_check_cookie
  002f8	48 81 c4 88 00
	00 00		 add	 rsp, 136		; 00000088H
  002ff	c3		 ret	 0
configure_cpu ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\config.c
_TEXT	SEGMENT
i$ = 48
tv84 = 52
dev$ = 56
group$ = 80
locked$ = 88
msg$ = 96
errdev$ = 104
free_group PROC

; 1628 : {

$LN11:
  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  0000e	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00013	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 1629 :     DEVBLK *dev;
; 1630 :     int i;
; 1631 : 
; 1632 :     if (!group || !group->members)

  00017	48 83 7c 24 50
	00		 cmp	 QWORD PTR group$[rsp], 0
  0001d	74 0a		 je	 SHORT $LN6@free_group
  0001f	48 8b 44 24 50	 mov	 rax, QWORD PTR group$[rsp]
  00024	83 38 00	 cmp	 DWORD PTR [rax], 0
  00027	75 07		 jne	 SHORT $LN5@free_group
$LN6@free_group:

; 1633 :         return FALSE;       // no group or group has no members

  00029	32 c0		 xor	 al, al
  0002b	e9 b3 00 00 00	 jmp	 $LN1@free_group
$LN5@free_group:

; 1634 : 
; 1635 :     for (i=0; i < group->acount; i++)

  00030	c7 44 24 30 00
	00 00 00	 mov	 DWORD PTR i$[rsp], 0
  00038	eb 0a		 jmp	 SHORT $LN4@free_group
$LN2@free_group:
  0003a	8b 44 24 30	 mov	 eax, DWORD PTR i$[rsp]
  0003e	ff c0		 inc	 eax
  00040	89 44 24 30	 mov	 DWORD PTR i$[rsp], eax
$LN4@free_group:
  00044	48 8b 44 24 50	 mov	 rax, QWORD PTR group$[rsp]
  00049	8b 40 04	 mov	 eax, DWORD PTR [rax+4]
  0004c	39 44 24 30	 cmp	 DWORD PTR i$[rsp], eax
  00050	0f 8d 80 00 00
	00		 jge	 $LN3@free_group

; 1636 :     {
; 1637 :         if ((dev = group->memdev[i]) && dev->allocated)

  00056	48 63 44 24 30	 movsxd	 rax, DWORD PTR i$[rsp]
  0005b	48 8b 4c 24 50	 mov	 rcx, QWORD PTR group$[rsp]
  00060	48 8b 44 c1 10	 mov	 rax, QWORD PTR [rcx+rax*8+16]
  00065	48 89 44 24 38	 mov	 QWORD PTR dev$[rsp], rax
  0006a	48 83 7c 24 38
	00		 cmp	 QWORD PTR dev$[rsp], 0
  00070	74 5f		 je	 SHORT $LN7@free_group
  00072	48 8b 44 24 38	 mov	 rax, QWORD PTR dev$[rsp]
  00077	83 78 40 00	 cmp	 DWORD PTR [rax+64], 0
  0007b	74 54		 je	 SHORT $LN7@free_group

; 1638 :         {
; 1639 :             // PROGRAMMING NOTE: detach_devblk automatically calls
; 1640 :             // free_group (i.e. THIS function) to try and free the
; 1641 :             // entire group at once in case it is a grouped device.
; 1642 :             // Therefore we must clear dev->group to NULL *before*
; 1643 :             // calling detach_devblk to prevent infinite recursion.
; 1644 : 
; 1645 :             dev->group = NULL;

  0007d	48 8b 44 24 38	 mov	 rax, QWORD PTR dev$[rsp]
  00082	48 c7 40 60 00
	00 00 00	 mov	 QWORD PTR [rax+96], 0

; 1646 :             detach_devblk( dev, dev == errdev && locked, msg, errdev,

  0008a	48 8b 44 24 68	 mov	 rax, QWORD PTR errdev$[rsp]
  0008f	48 39 44 24 38	 cmp	 QWORD PTR dev$[rsp], rax
  00094	75 11		 jne	 SHORT $LN9@free_group
  00096	83 7c 24 58 00	 cmp	 DWORD PTR locked$[rsp], 0
  0009b	74 0a		 je	 SHORT $LN9@free_group
  0009d	c7 44 24 34 01
	00 00 00	 mov	 DWORD PTR tv84[rsp], 1
  000a5	eb 08		 jmp	 SHORT $LN10@free_group
$LN9@free_group:
  000a7	c7 44 24 34 00
	00 00 00	 mov	 DWORD PTR tv84[rsp], 0
$LN10@free_group:
  000af	48 8b 44 24 50	 mov	 rax, QWORD PTR group$[rsp]
  000b4	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  000b9	4c 8b 4c 24 68	 mov	 r9, QWORD PTR errdev$[rsp]
  000be	4c 8b 44 24 60	 mov	 r8, QWORD PTR msg$[rsp]
  000c3	8b 54 24 34	 mov	 edx, DWORD PTR tv84[rsp]
  000c7	48 8b 4c 24 38	 mov	 rcx, QWORD PTR dev$[rsp]
  000cc	e8 00 00 00 00	 call	 detach_devblk
$LN7@free_group:

; 1647 :                            group );
; 1648 :         }
; 1649 :     }

  000d1	e9 64 ff ff ff	 jmp	 $LN2@free_group
$LN3@free_group:

; 1650 : 
; 1651 :     free( group );

  000d6	48 8b 4c 24 50	 mov	 rcx, QWORD PTR group$[rsp]
  000db	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free

; 1652 :     return TRUE;        // group successfully freed

  000e1	b0 01		 mov	 al, 1
$LN1@free_group:

; 1653 : }

  000e3	48 83 c4 48	 add	 rsp, 72			; 00000048H
  000e7	c3		 ret	 0
free_group ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\config.c
_TEXT	SEGMENT
tv162 = 32
tmp$ = 40
size$1 = 48
dev$ = 80
members$ = 88
group_device PROC

; 1589 : {

$LN12:
  00000	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00004	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00009	57		 push	 rdi
  0000a	48 83 ec 40	 sub	 rsp, 64			; 00000040H

; 1590 : DEVBLK *tmp;
; 1591 : 
; 1592 :     // Find a compatible group that is incomplete
; 1593 :     for (tmp = sysblk.firstdev;

  0000e	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00015	48 8b 80 c0 11
	00 00		 mov	 rax, QWORD PTR [rax+4544]
  0001c	48 89 44 24 28	 mov	 QWORD PTR tmp$[rsp], rax
  00021	eb 0e		 jmp	 SHORT $LN4@group_devi
$LN2@group_devi:

; 1596 :              || !tmp->group          // not a group device
; 1597 :              || strcmp(tmp->typname,dev->typname)  // unequal type
; 1598 :              || (tmp->group->members == tmp->group->acount) ); // complete
; 1599 :          tmp = tmp->nextdev) ;

  00023	48 8b 44 24 28	 mov	 rax, QWORD PTR tmp$[rsp]
  00028	48 8b 40 30	 mov	 rax, QWORD PTR [rax+48]
  0002c	48 89 44 24 28	 mov	 QWORD PTR tmp$[rsp], rax
$LN4@group_devi:

; 1594 :          tmp != NULL
; 1595 :            && (!tmp->allocated      // not allocated

  00031	48 83 7c 24 28
	00		 cmp	 QWORD PTR tmp$[rsp], 0
  00037	74 4d		 je	 SHORT $LN3@group_devi
  00039	48 8b 44 24 28	 mov	 rax, QWORD PTR tmp$[rsp]
  0003e	83 78 40 00	 cmp	 DWORD PTR [rax+64], 0
  00042	74 40		 je	 SHORT $LN5@group_devi
  00044	48 8b 44 24 28	 mov	 rax, QWORD PTR tmp$[rsp]
  00049	48 83 78 60 00	 cmp	 QWORD PTR [rax+96], 0
  0004e	74 34		 je	 SHORT $LN5@group_devi
  00050	48 8b 44 24 50	 mov	 rax, QWORD PTR dev$[rsp]
  00055	48 8b 50 50	 mov	 rdx, QWORD PTR [rax+80]
  00059	48 8b 44 24 28	 mov	 rax, QWORD PTR tmp$[rsp]
  0005e	48 8b 48 50	 mov	 rcx, QWORD PTR [rax+80]
  00062	e8 00 00 00 00	 call	 strcmp
  00067	85 c0		 test	 eax, eax
  00069	75 19		 jne	 SHORT $LN5@group_devi
  0006b	48 8b 44 24 28	 mov	 rax, QWORD PTR tmp$[rsp]
  00070	48 8b 40 60	 mov	 rax, QWORD PTR [rax+96]
  00074	48 8b 4c 24 28	 mov	 rcx, QWORD PTR tmp$[rsp]
  00079	48 8b 49 60	 mov	 rcx, QWORD PTR [rcx+96]
  0007d	8b 49 04	 mov	 ecx, DWORD PTR [rcx+4]
  00080	39 08		 cmp	 DWORD PTR [rax], ecx
  00082	75 02		 jne	 SHORT $LN3@group_devi
$LN5@group_devi:

; 1596 :              || !tmp->group          // not a group device
; 1597 :              || strcmp(tmp->typname,dev->typname)  // unequal type
; 1598 :              || (tmp->group->members == tmp->group->acount) ); // complete
; 1599 :          tmp = tmp->nextdev) ;

  00084	eb 9d		 jmp	 SHORT $LN2@group_devi
$LN3@group_devi:

; 1600 : 
; 1601 :     if(tmp)

  00086	48 83 7c 24 28
	00		 cmp	 QWORD PTR tmp$[rsp], 0
  0008c	74 61		 je	 SHORT $LN6@group_devi

; 1602 :     {
; 1603 :         // Join Group
; 1604 :         dev->group = tmp->group;

  0008e	48 8b 44 24 50	 mov	 rax, QWORD PTR dev$[rsp]
  00093	48 8b 4c 24 28	 mov	 rcx, QWORD PTR tmp$[rsp]
  00098	48 8b 49 60	 mov	 rcx, QWORD PTR [rcx+96]
  0009c	48 89 48 60	 mov	 QWORD PTR [rax+96], rcx

; 1605 :         dev->member = dev->group->acount++;

  000a0	48 8b 44 24 50	 mov	 rax, QWORD PTR dev$[rsp]
  000a5	48 8b 40 60	 mov	 rax, QWORD PTR [rax+96]
  000a9	48 8b 4c 24 50	 mov	 rcx, QWORD PTR dev$[rsp]
  000ae	8b 40 04	 mov	 eax, DWORD PTR [rax+4]
  000b1	89 41 58	 mov	 DWORD PTR [rcx+88], eax
  000b4	48 8b 44 24 50	 mov	 rax, QWORD PTR dev$[rsp]
  000b9	48 8b 40 60	 mov	 rax, QWORD PTR [rax+96]
  000bd	8b 40 04	 mov	 eax, DWORD PTR [rax+4]
  000c0	ff c0		 inc	 eax
  000c2	48 8b 4c 24 50	 mov	 rcx, QWORD PTR dev$[rsp]
  000c7	48 8b 49 60	 mov	 rcx, QWORD PTR [rcx+96]
  000cb	89 41 04	 mov	 DWORD PTR [rcx+4], eax

; 1606 :         dev->group->memdev[dev->member] = dev;

  000ce	48 8b 44 24 50	 mov	 rax, QWORD PTR dev$[rsp]
  000d3	48 8b 40 60	 mov	 rax, QWORD PTR [rax+96]
  000d7	48 8b 4c 24 50	 mov	 rcx, QWORD PTR dev$[rsp]
  000dc	48 63 49 58	 movsxd	 rcx, DWORD PTR [rcx+88]
  000e0	48 8b 54 24 50	 mov	 rdx, QWORD PTR dev$[rsp]
  000e5	48 89 54 c8 10	 mov	 QWORD PTR [rax+rcx*8+16], rdx

; 1607 :     }

  000ea	e9 86 00 00 00	 jmp	 $LN7@group_devi
$LN6@group_devi:

; 1608 :     else if(members)

  000ef	83 7c 24 58 00	 cmp	 DWORD PTR members$[rsp], 0
  000f4	74 7f		 je	 SHORT $LN8@group_devi

; 1609 :     {
; 1610 :         // Allocate a new Group when requested
; 1611 :         size_t size = sizeof(DEVGRP) + (members * sizeof(DEVBLK*));

  000f6	48 63 44 24 58	 movsxd	 rax, DWORD PTR members$[rsp]
  000fb	48 8d 04 c5 10
	00 00 00	 lea	 rax, QWORD PTR [rax*8+16]
  00103	48 89 44 24 30	 mov	 QWORD PTR size$1[rsp], rax

; 1612 :         dev->group = malloc( size );

  00108	48 8b 4c 24 30	 mov	 rcx, QWORD PTR size$1[rsp]
  0010d	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_malloc
  00113	48 8b 4c 24 50	 mov	 rcx, QWORD PTR dev$[rsp]
  00118	48 89 41 60	 mov	 QWORD PTR [rcx+96], rax

; 1613 :         memset( dev->group, 0, size );

  0011c	48 8b 44 24 50	 mov	 rax, QWORD PTR dev$[rsp]
  00121	48 8b 78 60	 mov	 rdi, QWORD PTR [rax+96]
  00125	33 c0		 xor	 eax, eax
  00127	48 8b 4c 24 30	 mov	 rcx, QWORD PTR size$1[rsp]
  0012c	f3 aa		 rep stosb

; 1614 :         dev->group->members = members;

  0012e	48 8b 44 24 50	 mov	 rax, QWORD PTR dev$[rsp]
  00133	48 8b 40 60	 mov	 rax, QWORD PTR [rax+96]
  00137	8b 4c 24 58	 mov	 ecx, DWORD PTR members$[rsp]
  0013b	89 08		 mov	 DWORD PTR [rax], ecx

; 1615 :         dev->group->acount = 1;

  0013d	48 8b 44 24 50	 mov	 rax, QWORD PTR dev$[rsp]
  00142	48 8b 40 60	 mov	 rax, QWORD PTR [rax+96]
  00146	c7 40 04 01 00
	00 00		 mov	 DWORD PTR [rax+4], 1

; 1616 :         dev->group->memdev[0] = dev;

  0014d	48 8b 44 24 50	 mov	 rax, QWORD PTR dev$[rsp]
  00152	48 8b 40 60	 mov	 rax, QWORD PTR [rax+96]
  00156	b9 08 00 00 00	 mov	 ecx, 8
  0015b	48 6b c9 00	 imul	 rcx, rcx, 0
  0015f	48 8b 54 24 50	 mov	 rdx, QWORD PTR dev$[rsp]
  00164	48 89 54 08 10	 mov	 QWORD PTR [rax+rcx+16], rdx

; 1617 :         dev->member = 0;

  00169	48 8b 44 24 50	 mov	 rax, QWORD PTR dev$[rsp]
  0016e	c7 40 58 00 00
	00 00		 mov	 DWORD PTR [rax+88], 0
$LN8@group_devi:
$LN7@group_devi:

; 1618 :     }
; 1619 : 
; 1620 :     return (dev->group && (dev->group->members == dev->group->acount));

  00175	48 8b 44 24 50	 mov	 rax, QWORD PTR dev$[rsp]
  0017a	48 83 78 60 00	 cmp	 QWORD PTR [rax+96], 0
  0017f	74 23		 je	 SHORT $LN10@group_devi
  00181	48 8b 44 24 50	 mov	 rax, QWORD PTR dev$[rsp]
  00186	48 8b 40 60	 mov	 rax, QWORD PTR [rax+96]
  0018a	48 8b 4c 24 50	 mov	 rcx, QWORD PTR dev$[rsp]
  0018f	48 8b 49 60	 mov	 rcx, QWORD PTR [rcx+96]
  00193	8b 49 04	 mov	 ecx, DWORD PTR [rcx+4]
  00196	39 08		 cmp	 DWORD PTR [rax], ecx
  00198	75 0a		 jne	 SHORT $LN10@group_devi
  0019a	c7 44 24 20 01
	00 00 00	 mov	 DWORD PTR tv162[rsp], 1
  001a2	eb 08		 jmp	 SHORT $LN11@group_devi
$LN10@group_devi:
  001a4	c7 44 24 20 00
	00 00 00	 mov	 DWORD PTR tv162[rsp], 0
$LN11@group_devi:
  001ac	8b 44 24 20	 mov	 eax, DWORD PTR tv162[rsp]

; 1621 : }

  001b0	48 83 c4 40	 add	 rsp, 64			; 00000040H
  001b4	5f		 pop	 rdi
  001b5	c3		 ret	 0
group_device ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\config.c
_TEXT	SEGMENT
tv72 = 80
tv74 = 84
tv92 = 88
tv94 = 92
dev$ = 96
lcss$ = 128
olddevn$ = 136
newdevn$ = 144
define_device PROC

; 1454 : {

$LN7:
  00000	66 44 89 44 24
	18		 mov	 WORD PTR [rsp+24], r8w
  00006	66 89 54 24 10	 mov	 WORD PTR [rsp+16], dx
  0000b	66 89 4c 24 08	 mov	 WORD PTR [rsp+8], cx
  00010	48 83 ec 78	 sub	 rsp, 120		; 00000078H

; 1455 : DEVBLK *dev;                            /* -> Device block           */
; 1456 : 
; 1457 :     /* Obtain (re)configuration lock */
; 1458 :     obtain_lock(&sysblk.config);

  00014	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  0001b	48 05 80 00 00
	00		 add	 rax, 128		; 00000080H
  00021	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG190586
  00028	48 8b c8	 mov	 rcx, rax
  0002b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_obtain_lock

; 1459 : 
; 1460 :     /* Find the device block */
; 1461 :     dev = find_device_by_devnum (lcss, olddevn);

  00031	0f b7 94 24 88
	00 00 00	 movzx	 edx, WORD PTR olddevn$[rsp]
  00039	0f b7 8c 24 80
	00 00 00	 movzx	 ecx, WORD PTR lcss$[rsp]
  00041	e8 00 00 00 00	 call	 find_device_by_devnum
  00046	48 89 44 24 60	 mov	 QWORD PTR dev$[rsp], rax

; 1462 : 
; 1463 :     if (dev == NULL)

  0004b	48 83 7c 24 60
	00		 cmp	 QWORD PTR dev$[rsp], 0
  00051	0f 85 a2 00 00
	00		 jne	 $LN2@define_dev

; 1464 :     {
; 1465 :         WRMSG (HHC01464, "E", lcss, olddevn, "device");

  00057	0f b7 84 24 88
	00 00 00	 movzx	 eax, WORD PTR olddevn$[rsp]
  0005f	89 44 24 50	 mov	 DWORD PTR tv72[rsp], eax
  00063	0f b7 8c 24 80
	00 00 00	 movzx	 ecx, WORD PTR lcss$[rsp]
  0006b	89 4c 24 54	 mov	 DWORD PTR tv74[rsp], ecx
  0006f	b9 01 00 00 00	 mov	 ecx, 1
  00074	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  0007a	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG190588
  00081	48 89 4c 24 48	 mov	 QWORD PTR [rsp+72], rcx
  00086	8b 4c 24 50	 mov	 ecx, DWORD PTR tv72[rsp]
  0008a	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  0008e	8b 4c 24 54	 mov	 ecx, DWORD PTR tv74[rsp]
  00092	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  00096	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG190589
  0009d	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  000a2	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG190590
  000a9	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  000ae	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  000b3	41 b9 03 00 00
	00		 mov	 r9d, 3
  000b9	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG190591
  000c0	ba b9 05 00 00	 mov	 edx, 1465		; 000005b9H
  000c5	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG190592
  000cc	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 1466 :         release_lock(&sysblk.config);

  000d2	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  000d9	48 05 80 00 00
	00		 add	 rax, 128		; 00000080H
  000df	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG190593
  000e6	48 8b c8	 mov	 rcx, rax
  000e9	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_release_lock

; 1467 :         return 1;

  000ef	b8 01 00 00 00	 mov	 eax, 1
  000f4	e9 bc 01 00 00	 jmp	 $LN1@define_dev
$LN2@define_dev:

; 1468 :     }
; 1469 : 
; 1470 :     /* Check that new device number does not already exist */
; 1471 :     if (find_device_by_devnum(lcss, newdevn) != NULL)

  000f9	0f b7 94 24 90
	00 00 00	 movzx	 edx, WORD PTR newdevn$[rsp]
  00101	0f b7 8c 24 80
	00 00 00	 movzx	 ecx, WORD PTR lcss$[rsp]
  00109	e8 00 00 00 00	 call	 find_device_by_devnum
  0010e	48 85 c0	 test	 rax, rax
  00111	0f 84 96 00 00
	00		 je	 $LN3@define_dev

; 1472 :     {
; 1473 :         WRMSG (HHC01461, "E", lcss, newdevn);

  00117	0f b7 84 24 90
	00 00 00	 movzx	 eax, WORD PTR newdevn$[rsp]
  0011f	89 44 24 58	 mov	 DWORD PTR tv92[rsp], eax
  00123	0f b7 8c 24 80
	00 00 00	 movzx	 ecx, WORD PTR lcss$[rsp]
  0012b	89 4c 24 5c	 mov	 DWORD PTR tv94[rsp], ecx
  0012f	b9 01 00 00 00	 mov	 ecx, 1
  00134	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  0013a	8b 4c 24 58	 mov	 ecx, DWORD PTR tv92[rsp]
  0013e	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  00142	8b 4c 24 5c	 mov	 ecx, DWORD PTR tv94[rsp]
  00146	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  0014a	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG190595
  00151	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  00156	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG190596
  0015d	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00162	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00167	41 b9 03 00 00
	00		 mov	 r9d, 3
  0016d	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG190597
  00174	ba c1 05 00 00	 mov	 edx, 1473		; 000005c1H
  00179	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG190598
  00180	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 1474 :         release_lock(&sysblk.config);

  00186	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  0018d	48 05 80 00 00
	00		 add	 rax, 128		; 00000080H
  00193	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG190599
  0019a	48 8b c8	 mov	 rcx, rax
  0019d	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_release_lock

; 1475 :         return 1;

  001a3	b8 01 00 00 00	 mov	 eax, 1
  001a8	e9 08 01 00 00	 jmp	 $LN1@define_dev
$LN3@define_dev:

; 1476 :     }
; 1477 : 
; 1478 : #ifdef _FEATURE_CHANNEL_SUBSYSTEM
; 1479 :     /* Build Channel Report */
; 1480 : #if defined(_370)
; 1481 :     if (sysblk.arch_mode != ARCH_370_IDX)

  001ad	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  001b4	83 b8 88 00 00
	00 00		 cmp	 DWORD PTR [rax+136], 0
  001bb	74 0a		 je	 SHORT $LN4@define_dev

; 1482 : #endif
; 1483 :         build_detach_chrpt( dev );

  001bd	48 8b 4c 24 60	 mov	 rcx, QWORD PTR dev$[rsp]
  001c2	e8 00 00 00 00	 call	 build_detach_chrpt
$LN4@define_dev:

; 1484 : #endif /*_FEATURE_CHANNEL_SUBSYSTEM*/
; 1485 : 
; 1486 :     /* Obtain the device lock */
; 1487 :     obtain_lock(&dev->lock);

  001c7	48 8b 44 24 60	 mov	 rax, QWORD PTR dev$[rsp]
  001cc	48 83 c0 38	 add	 rax, 56			; 00000038H
  001d0	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG190601
  001d7	48 8b c8	 mov	 rcx, rax
  001da	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_obtain_lock

; 1488 : 
; 1489 :     /* Update the device number in the DEVBLK */
; 1490 :     dev->devnum = newdevn;

  001e0	48 8b 44 24 60	 mov	 rax, QWORD PTR dev$[rsp]
  001e5	0f b7 8c 24 90
	00 00 00	 movzx	 ecx, WORD PTR newdevn$[rsp]
  001ed	66 89 48 48	 mov	 WORD PTR [rax+72], cx

; 1491 : 
; 1492 :     /* Update the device number in the PMCW */
; 1493 :     dev->pmcw.devnum[0] = newdevn >> 8;

  001f1	0f b7 84 24 90
	00 00 00	 movzx	 eax, WORD PTR newdevn$[rsp]
  001f9	c1 f8 08	 sar	 eax, 8
  001fc	b9 01 00 00 00	 mov	 ecx, 1
  00201	48 6b c9 00	 imul	 rcx, rcx, 0
  00205	48 8b 54 24 60	 mov	 rdx, QWORD PTR dev$[rsp]
  0020a	88 84 0a f2 02
	00 00		 mov	 BYTE PTR [rdx+rcx+754], al

; 1494 :     dev->pmcw.devnum[1] = newdevn & 0xFF;

  00211	0f b7 84 24 90
	00 00 00	 movzx	 eax, WORD PTR newdevn$[rsp]
  00219	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  0021e	b9 01 00 00 00	 mov	 ecx, 1
  00223	48 6b c9 01	 imul	 rcx, rcx, 1
  00227	48 8b 54 24 60	 mov	 rdx, QWORD PTR dev$[rsp]
  0022c	88 84 0a f2 02
	00 00		 mov	 BYTE PTR [rdx+rcx+754], al

; 1495 : 
; 1496 :     DelDevnumFastLookup(lcss,olddevn);

  00233	0f b7 94 24 88
	00 00 00	 movzx	 edx, WORD PTR olddevn$[rsp]
  0023b	0f b7 8c 24 80
	00 00 00	 movzx	 ecx, WORD PTR lcss$[rsp]
  00243	e8 00 00 00 00	 call	 DelDevnumFastLookup

; 1497 :     AddDevnumFastLookup(dev,lcss,newdevn);

  00248	44 0f b7 84 24
	90 00 00 00	 movzx	 r8d, WORD PTR newdevn$[rsp]
  00251	0f b7 94 24 80
	00 00 00	 movzx	 edx, WORD PTR lcss$[rsp]
  00259	48 8b 4c 24 60	 mov	 rcx, QWORD PTR dev$[rsp]
  0025e	e8 00 00 00 00	 call	 AddDevnumFastLookup

; 1498 : 
; 1499 :     /* Release device lock */
; 1500 :     release_lock(&dev->lock);

  00263	48 8b 44 24 60	 mov	 rax, QWORD PTR dev$[rsp]
  00268	48 83 c0 38	 add	 rax, 56			; 00000038H
  0026c	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG190602
  00273	48 8b c8	 mov	 rcx, rax
  00276	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_release_lock

; 1501 : 
; 1502 : #ifdef _FEATURE_CHANNEL_SUBSYSTEM
; 1503 :     /* Build Channel Report */
; 1504 : #if defined(_370)
; 1505 :     if (sysblk.arch_mode != ARCH_370_IDX)

  0027c	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00283	83 b8 88 00 00
	00 00		 cmp	 DWORD PTR [rax+136], 0
  0028a	74 0a		 je	 SHORT $LN5@define_dev

; 1506 : #endif
; 1507 :         build_attach_chrpt( dev );

  0028c	48 8b 4c 24 60	 mov	 rcx, QWORD PTR dev$[rsp]
  00291	e8 00 00 00 00	 call	 build_attach_chrpt
$LN5@define_dev:

; 1508 : #endif /*_FEATURE_CHANNEL_SUBSYSTEM*/
; 1509 : 
; 1510 : //    WRMSG (HHC01459, "I", lcss, olddevn, lcss, newdevn);
; 1511 : 
; 1512 :     release_lock(&sysblk.config);

  00296	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  0029d	48 05 80 00 00
	00		 add	 rax, 128		; 00000080H
  002a3	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG190604
  002aa	48 8b c8	 mov	 rcx, rax
  002ad	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_release_lock

; 1513 :     return 0;

  002b3	33 c0		 xor	 eax, eax
$LN1@define_dev:

; 1514 : } /* end function define_device */

  002b5	48 83 c4 78	 add	 rsp, 120		; 00000078H
  002b9	c3		 ret	 0
define_device ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\config.c
_TEXT	SEGMENT
tv69 = 80
tv71 = 84
rc$ = 88
dev$ = 96
str$ = 104
lcss$ = 128
devnum$ = 136
detach_device PROC

; 1423 : {

$LN5:
  00000	66 89 54 24 10	 mov	 WORD PTR [rsp+16], dx
  00005	66 89 4c 24 08	 mov	 WORD PTR [rsp+8], cx
  0000a	48 83 ec 78	 sub	 rsp, 120		; 00000078H

; 1424 : DEVBLK *dev;                            /* -> Device block           */
; 1425 : int    rc;
; 1426 : char* str = "device";

  0000e	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG190566
  00015	48 89 44 24 68	 mov	 QWORD PTR str$[rsp], rax

; 1427 : 
; 1428 :     /* Find the device block */
; 1429 :     dev = find_device_by_devnum (lcss,devnum);

  0001a	0f b7 94 24 88
	00 00 00	 movzx	 edx, WORD PTR devnum$[rsp]
  00022	0f b7 8c 24 80
	00 00 00	 movzx	 ecx, WORD PTR lcss$[rsp]
  0002a	e8 00 00 00 00	 call	 find_device_by_devnum
  0002f	48 89 44 24 60	 mov	 QWORD PTR dev$[rsp], rax

; 1430 : 
; 1431 :     if (dev == NULL)

  00034	48 83 7c 24 60
	00		 cmp	 QWORD PTR dev$[rsp], 0
  0003a	0f 85 80 00 00
	00		 jne	 $LN2@detach_dev

; 1432 :     {
; 1433 :         // "%1d:%04X %s does not exist"
; 1434 :         WRMSG (HHC01464, "E", lcss, devnum, str);

  00040	0f b7 84 24 88
	00 00 00	 movzx	 eax, WORD PTR devnum$[rsp]
  00048	89 44 24 50	 mov	 DWORD PTR tv69[rsp], eax
  0004c	0f b7 8c 24 80
	00 00 00	 movzx	 ecx, WORD PTR lcss$[rsp]
  00054	89 4c 24 54	 mov	 DWORD PTR tv71[rsp], ecx
  00058	b9 01 00 00 00	 mov	 ecx, 1
  0005d	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  00063	48 8b 4c 24 68	 mov	 rcx, QWORD PTR str$[rsp]
  00068	48 89 4c 24 48	 mov	 QWORD PTR [rsp+72], rcx
  0006d	8b 4c 24 50	 mov	 ecx, DWORD PTR tv69[rsp]
  00071	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  00075	8b 4c 24 54	 mov	 ecx, DWORD PTR tv71[rsp]
  00079	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  0007d	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG190568
  00084	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  00089	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG190569
  00090	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00095	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  0009a	41 b9 03 00 00
	00		 mov	 r9d, 3
  000a0	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG190570
  000a7	ba 9a 05 00 00	 mov	 edx, 1434		; 0000059aH
  000ac	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG190571
  000b3	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 1435 :         return 1;

  000b9	b8 01 00 00 00	 mov	 eax, 1
  000be	eb 7c		 jmp	 SHORT $LN1@detach_dev
$LN2@detach_dev:

; 1436 :     }
; 1437 : 
; 1438 :     obtain_lock(&sysblk.config);

  000c0	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  000c7	48 05 80 00 00
	00		 add	 rax, 128		; 00000080H
  000cd	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG190572
  000d4	48 8b c8	 mov	 rcx, rax
  000d7	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_obtain_lock

; 1439 : 
; 1440 :     if (dev->group)

  000dd	48 8b 44 24 60	 mov	 rax, QWORD PTR dev$[rsp]
  000e2	48 83 78 60 00	 cmp	 QWORD PTR [rax+96], 0
  000e7	74 0c		 je	 SHORT $LN3@detach_dev

; 1441 :         str = "group device";

  000e9	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG190574
  000f0	48 89 44 24 68	 mov	 QWORD PTR str$[rsp], rax
$LN3@detach_dev:

; 1442 : 
; 1443 :     rc = detach_devblk( dev, FALSE, str, NULL, dev->group );

  000f5	48 8b 44 24 60	 mov	 rax, QWORD PTR dev$[rsp]
  000fa	48 8b 40 60	 mov	 rax, QWORD PTR [rax+96]
  000fe	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00103	45 33 c9	 xor	 r9d, r9d
  00106	4c 8b 44 24 68	 mov	 r8, QWORD PTR str$[rsp]
  0010b	33 d2		 xor	 edx, edx
  0010d	48 8b 4c 24 60	 mov	 rcx, QWORD PTR dev$[rsp]
  00112	e8 00 00 00 00	 call	 detach_devblk
  00117	89 44 24 58	 mov	 DWORD PTR rc$[rsp], eax

; 1444 : 
; 1445 :     release_lock(&sysblk.config);

  0011b	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00122	48 05 80 00 00
	00		 add	 rax, 128		; 00000080H
  00128	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG190575
  0012f	48 8b c8	 mov	 rcx, rax
  00132	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_release_lock

; 1446 : 
; 1447 :     return rc;

  00138	8b 44 24 58	 mov	 eax, DWORD PTR rc$[rsp]
$LN1@detach_dev:

; 1448 : }

  0013c	48 83 c4 78	 add	 rsp, 120		; 00000078H
  00140	c3		 ret	 0
detach_device ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\config.c
_TEXT	SEGMENT
dev$ = 96
i$ = 104
rc$ = 108
tv71 = 112
tv73 = 116
tv95 = 120
tv129 = 124
tv185 = 128
tv187 = 132
tv239 = 136
tv241 = 140
tv275 = 144
tv278 = 148
tv281 = 152
tv284 = 156
tv91 = 160
tv218 = 168
tv228 = 176
buf$1 = 192
__$ArrayPad$ = 256
lcss$ = 288
devnum$ = 296
type$ = 304
addargc$ = 312
addargv$ = 320
numconfdev$ = 328
attach_device PROC

; 1289 : {

$LN18:
  00000	44 89 4c 24 20	 mov	 DWORD PTR [rsp+32], r9d
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	66 89 54 24 10	 mov	 WORD PTR [rsp+16], dx
  0000f	66 89 4c 24 08	 mov	 WORD PTR [rsp+8], cx
  00014	48 81 ec 18 01
	00 00		 sub	 rsp, 280		; 00000118H
  0001b	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00022	48 33 c4	 xor	 rax, rsp
  00025	48 89 84 24 00
	01 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 1290 : DEVBLK *dev;                            /* -> Device block           */
; 1291 : int     rc;                             /* Return code               */
; 1292 : int     i;                              /* Loop index                */
; 1293 : 
; 1294 :     /* Obtain (re)configuration lock */
; 1295 :     obtain_lock(&sysblk.config);

  0002d	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00034	48 05 80 00 00
	00		 add	 rax, 128		; 00000080H
  0003a	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG190514
  00041	48 8b c8	 mov	 rcx, rax
  00044	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_obtain_lock

; 1296 : 
; 1297 :     /* Check whether device number has already been defined */
; 1298 :     if (find_device_by_devnum(lcss,devnum) != NULL)

  0004a	0f b7 94 24 28
	01 00 00	 movzx	 edx, WORD PTR devnum$[rsp]
  00052	0f b7 8c 24 20
	01 00 00	 movzx	 ecx, WORD PTR lcss$[rsp]
  0005a	e8 00 00 00 00	 call	 find_device_by_devnum
  0005f	48 85 c0	 test	 rax, rax
  00062	0f 84 96 00 00
	00		 je	 $LN5@attach_dev

; 1299 :     {
; 1300 :         // "%1d:%04X device already exists"
; 1301 :         WRMSG (HHC01461, "E", lcss, devnum);

  00068	0f b7 84 24 28
	01 00 00	 movzx	 eax, WORD PTR devnum$[rsp]
  00070	89 44 24 70	 mov	 DWORD PTR tv71[rsp], eax
  00074	0f b7 8c 24 20
	01 00 00	 movzx	 ecx, WORD PTR lcss$[rsp]
  0007c	89 4c 24 74	 mov	 DWORD PTR tv73[rsp], ecx
  00080	b9 01 00 00 00	 mov	 ecx, 1
  00085	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  0008b	8b 4c 24 70	 mov	 ecx, DWORD PTR tv71[rsp]
  0008f	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  00093	8b 4c 24 74	 mov	 ecx, DWORD PTR tv73[rsp]
  00097	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  0009b	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG190516
  000a2	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  000a7	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG190517
  000ae	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  000b3	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  000b8	41 b9 03 00 00
	00		 mov	 r9d, 3
  000be	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG190518
  000c5	ba 15 05 00 00	 mov	 edx, 1301		; 00000515H
  000ca	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG190519
  000d1	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 1302 :         release_lock(&sysblk.config);

  000d7	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  000de	48 05 80 00 00
	00		 add	 rax, 128		; 00000080H
  000e4	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG190520
  000eb	48 8b c8	 mov	 rcx, rax
  000ee	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_release_lock

; 1303 :         return 1;

  000f4	b8 01 00 00 00	 mov	 eax, 1
  000f9	e9 dc 05 00 00	 jmp	 $LN1@attach_dev
$LN5@attach_dev:

; 1304 :     }
; 1305 : 
; 1306 :     /* Obtain device block from our DEVBLK pool and lock the device. */
; 1307 :     dev = get_devblk(lcss, devnum); /* does obtain_lock(&dev->lock); */

  000fe	0f b7 94 24 28
	01 00 00	 movzx	 edx, WORD PTR devnum$[rsp]
  00106	0f b7 8c 24 20
	01 00 00	 movzx	 ecx, WORD PTR lcss$[rsp]
  0010e	e8 00 00 00 00	 call	 get_devblk
  00113	48 89 44 24 60	 mov	 QWORD PTR dev$[rsp], rax

; 1308 : 
; 1309 :     // PROGRAMMING NOTE: the rule is, once a DEVBLK has been obtained
; 1310 :     // from the pool it can be returned back to the pool via a simple
; 1311 :     // call to ret_devblk if the device handler initialization function
; 1312 :     // has NOT yet been called. Once the device handler initialization
; 1313 :     // function has been called however then you MUST use detach_devblk
; 1314 :     // to return it back to the pool so that the entire group is freed.
; 1315 : 
; 1316 :     if(!(dev->hnd = hdl_DEVHND(type)))

  00118	48 8b 8c 24 30
	01 00 00	 mov	 rcx, QWORD PTR type$[rsp]
  00120	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hdl_DEVHND
  00126	48 89 84 24 a0
	00 00 00	 mov	 QWORD PTR tv91[rsp], rax
  0012e	48 8b 44 24 60	 mov	 rax, QWORD PTR dev$[rsp]
  00133	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR tv91[rsp]
  0013b	48 89 88 90 02
	00 00		 mov	 QWORD PTR [rax+656], rcx
  00142	48 83 bc 24 a0
	00 00 00 00	 cmp	 QWORD PTR tv91[rsp], 0
  0014b	0f 85 ad 00 00
	00		 jne	 $LN6@attach_dev

; 1317 :     {
; 1318 :         // "%1d:%04X devtype %s not recognized"
; 1319 :         WRMSG (HHC01462, "E", lcss, devnum, type);

  00151	0f b7 84 24 28
	01 00 00	 movzx	 eax, WORD PTR devnum$[rsp]
  00159	89 44 24 78	 mov	 DWORD PTR tv95[rsp], eax
  0015d	0f b7 8c 24 20
	01 00 00	 movzx	 ecx, WORD PTR lcss$[rsp]
  00165	89 4c 24 7c	 mov	 DWORD PTR tv129[rsp], ecx
  00169	b9 01 00 00 00	 mov	 ecx, 1
  0016e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  00174	48 8b 8c 24 30
	01 00 00	 mov	 rcx, QWORD PTR type$[rsp]
  0017c	48 89 4c 24 48	 mov	 QWORD PTR [rsp+72], rcx
  00181	8b 4c 24 78	 mov	 ecx, DWORD PTR tv95[rsp]
  00185	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  00189	8b 4c 24 7c	 mov	 ecx, DWORD PTR tv129[rsp]
  0018d	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  00191	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG190522
  00198	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  0019d	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG190523
  001a4	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  001a9	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  001ae	41 b9 03 00 00
	00		 mov	 r9d, 3
  001b4	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG190524
  001bb	ba 27 05 00 00	 mov	 edx, 1319		; 00000527H
  001c0	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG190525
  001c7	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 1320 :         ret_devblk(dev); /* also does release_lock(&dev->lock);*/

  001cd	48 8b 4c 24 60	 mov	 rcx, QWORD PTR dev$[rsp]
  001d2	e8 00 00 00 00	 call	 ret_devblk

; 1321 :         release_lock(&sysblk.config);

  001d7	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  001de	48 05 80 00 00
	00		 add	 rax, 128		; 00000080H
  001e4	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG190526
  001eb	48 8b c8	 mov	 rcx, rax
  001ee	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_release_lock

; 1322 :         return 1;

  001f4	b8 01 00 00 00	 mov	 eax, 1
  001f9	e9 dc 04 00 00	 jmp	 $LN1@attach_dev
$LN6@attach_dev:

; 1323 :     }
; 1324 : 
; 1325 :     dev->typname = strdup(type);

  001fe	48 8b 8c 24 30
	01 00 00	 mov	 rcx, QWORD PTR type$[rsp]
  00206	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_strdup
  0020c	48 8b 4c 24 60	 mov	 rcx, QWORD PTR dev$[rsp]
  00211	48 89 41 50	 mov	 QWORD PTR [rcx+80], rax

; 1326 : 
; 1327 :     /* Copy the arguments */
; 1328 :     dev->argc = addargc;

  00215	48 8b 44 24 60	 mov	 rax, QWORD PTR dev$[rsp]
  0021a	8b 8c 24 38 01
	00 00		 mov	 ecx, DWORD PTR addargc$[rsp]
  00221	89 48 68	 mov	 DWORD PTR [rax+104], ecx

; 1329 :     if (addargc)

  00224	83 bc 24 38 01
	00 00 00	 cmp	 DWORD PTR addargc$[rsp], 0
  0022c	0f 84 98 00 00
	00		 je	 $LN7@attach_dev

; 1330 :     {
; 1331 :         dev->argv = malloc ( addargc * sizeof(BYTE *) );

  00232	48 63 84 24 38
	01 00 00	 movsxd	 rax, DWORD PTR addargc$[rsp]
  0023a	48 c1 e0 03	 shl	 rax, 3
  0023e	48 8b c8	 mov	 rcx, rax
  00241	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_malloc
  00247	48 8b 4c 24 60	 mov	 rcx, QWORD PTR dev$[rsp]
  0024c	48 89 41 70	 mov	 QWORD PTR [rcx+112], rax

; 1332 :         for (i = 0; i < addargc; i++)

  00250	c7 44 24 68 00
	00 00 00	 mov	 DWORD PTR i$[rsp], 0
  00258	eb 0a		 jmp	 SHORT $LN4@attach_dev
$LN2@attach_dev:
  0025a	8b 44 24 68	 mov	 eax, DWORD PTR i$[rsp]
  0025e	ff c0		 inc	 eax
  00260	89 44 24 68	 mov	 DWORD PTR i$[rsp], eax
$LN4@attach_dev:
  00264	8b 84 24 38 01
	00 00		 mov	 eax, DWORD PTR addargc$[rsp]
  0026b	39 44 24 68	 cmp	 DWORD PTR i$[rsp], eax
  0026f	7d 57		 jge	 SHORT $LN3@attach_dev

; 1333 :             if (addargv[i])

  00271	48 63 44 24 68	 movsxd	 rax, DWORD PTR i$[rsp]
  00276	48 8b 8c 24 40
	01 00 00	 mov	 rcx, QWORD PTR addargv$[rsp]
  0027e	48 83 3c c1 00	 cmp	 QWORD PTR [rcx+rax*8], 0
  00283	74 2b		 je	 SHORT $LN9@attach_dev

; 1334 :                 dev->argv[i] = strdup(addargv[i]);

  00285	48 63 44 24 68	 movsxd	 rax, DWORD PTR i$[rsp]
  0028a	48 8b 8c 24 40
	01 00 00	 mov	 rcx, QWORD PTR addargv$[rsp]
  00292	48 8b 0c c1	 mov	 rcx, QWORD PTR [rcx+rax*8]
  00296	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_strdup
  0029c	48 63 4c 24 68	 movsxd	 rcx, DWORD PTR i$[rsp]
  002a1	48 8b 54 24 60	 mov	 rdx, QWORD PTR dev$[rsp]
  002a6	48 8b 52 70	 mov	 rdx, QWORD PTR [rdx+112]
  002aa	48 89 04 ca	 mov	 QWORD PTR [rdx+rcx*8], rax
  002ae	eb 16		 jmp	 SHORT $LN10@attach_dev
$LN9@attach_dev:

; 1335 :             else
; 1336 :                 dev->argv[i] = NULL;

  002b0	48 63 44 24 68	 movsxd	 rax, DWORD PTR i$[rsp]
  002b5	48 8b 4c 24 60	 mov	 rcx, QWORD PTR dev$[rsp]
  002ba	48 8b 49 70	 mov	 rcx, QWORD PTR [rcx+112]
  002be	48 c7 04 c1 00
	00 00 00	 mov	 QWORD PTR [rcx+rax*8], 0
$LN10@attach_dev:
  002c6	eb 92		 jmp	 SHORT $LN2@attach_dev
$LN3@attach_dev:

; 1337 :     }

  002c8	eb 0d		 jmp	 SHORT $LN8@attach_dev
$LN7@attach_dev:

; 1338 :     else
; 1339 :         dev->argv = NULL;

  002ca	48 8b 44 24 60	 mov	 rax, QWORD PTR dev$[rsp]
  002cf	48 c7 40 70 00
	00 00 00	 mov	 QWORD PTR [rax+112], 0
$LN8@attach_dev:

; 1340 : 
; 1341 :     /* Set the number of config statement device addresses */
; 1342 :     dev->numconfdev = numconfdev;

  002d7	48 8b 44 24 60	 mov	 rax, QWORD PTR dev$[rsp]
  002dc	8b 8c 24 48 01
	00 00		 mov	 ecx, DWORD PTR numconfdev$[rsp]
  002e3	89 48 78	 mov	 DWORD PTR [rax+120], ecx

; 1343 : 
; 1344 :     /* Call the device handler initialization function */
; 1345 :     rc = (int)(dev->hnd->init)(dev, addargc, addargv);

  002e6	48 8b 44 24 60	 mov	 rax, QWORD PTR dev$[rsp]
  002eb	48 8b 80 90 02
	00 00		 mov	 rax, QWORD PTR [rax+656]
  002f2	4c 8b 84 24 40
	01 00 00	 mov	 r8, QWORD PTR addargv$[rsp]
  002fa	8b 94 24 38 01
	00 00		 mov	 edx, DWORD PTR addargc$[rsp]
  00301	48 8b 4c 24 60	 mov	 rcx, QWORD PTR dev$[rsp]
  00306	ff 10		 call	 QWORD PTR [rax]
  00308	89 44 24 6c	 mov	 DWORD PTR rc$[rsp], eax

; 1346 : 
; 1347 :     if (rc < 0)

  0030c	83 7c 24 6c 00	 cmp	 DWORD PTR rc$[rsp], 0
  00311	0f 8d cb 00 00
	00		 jge	 $LN11@attach_dev

; 1348 :     {
; 1349 :         // "%1d:%04X device initialization failed"
; 1350 :         WRMSG (HHC01463, "E", lcss, devnum);

  00317	0f b7 84 24 28
	01 00 00	 movzx	 eax, WORD PTR devnum$[rsp]
  0031f	89 84 24 80 00
	00 00		 mov	 DWORD PTR tv185[rsp], eax
  00326	0f b7 8c 24 20
	01 00 00	 movzx	 ecx, WORD PTR lcss$[rsp]
  0032e	89 8c 24 84 00
	00 00		 mov	 DWORD PTR tv187[rsp], ecx
  00335	b9 01 00 00 00	 mov	 ecx, 1
  0033a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  00340	8b 8c 24 80 00
	00 00		 mov	 ecx, DWORD PTR tv185[rsp]
  00347	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  0034b	8b 8c 24 84 00
	00 00		 mov	 ecx, DWORD PTR tv187[rsp]
  00352	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  00356	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG190532
  0035d	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  00362	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG190533
  00369	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  0036e	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00373	41 b9 03 00 00
	00		 mov	 r9d, 3
  00379	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG190534
  00380	ba 46 05 00 00	 mov	 edx, 1350		; 00000546H
  00385	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG190535
  0038c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 1351 : 
; 1352 :         /* Detach the device and return it back to the DEVBLK pool */
; 1353 :         detach_devblk( dev, TRUE, "device", dev, dev->group );

  00392	48 8b 44 24 60	 mov	 rax, QWORD PTR dev$[rsp]
  00397	48 8b 40 60	 mov	 rax, QWORD PTR [rax+96]
  0039b	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  003a0	4c 8b 4c 24 60	 mov	 r9, QWORD PTR dev$[rsp]
  003a5	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG190536
  003ac	ba 01 00 00 00	 mov	 edx, 1
  003b1	48 8b 4c 24 60	 mov	 rcx, QWORD PTR dev$[rsp]
  003b6	e8 00 00 00 00	 call	 detach_devblk

; 1354 : 
; 1355 :         release_lock(&sysblk.config);

  003bb	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  003c2	48 05 80 00 00
	00		 add	 rax, 128		; 00000080H
  003c8	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG190537
  003cf	48 8b c8	 mov	 rcx, rax
  003d2	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_release_lock

; 1356 :         return 1;

  003d8	b8 01 00 00 00	 mov	 eax, 1
  003dd	e9 f8 02 00 00	 jmp	 $LN1@attach_dev
$LN11@attach_dev:

; 1357 :     }
; 1358 : 
; 1359 :     /* Obtain device data buffer */
; 1360 :     if (dev->bufsize != 0)

  003e2	48 8b 44 24 60	 mov	 rax, QWORD PTR dev$[rsp]
  003e7	83 b8 d8 01 00
	00 00		 cmp	 DWORD PTR [rax+472], 0
  003ee	0f 84 ba 01 00
	00		 je	 $LN12@attach_dev

; 1361 :     {
; 1362 :         /* PROGRAMMING NOTE: we free the device buffer here, not in
; 1363 :            the 'ret_devblk' function (where you would normally expect
; 1364 :            it to be done) since doing it in 'ret_devblk' might cause
; 1365 :            Hercules to crash due to poorly written device handlers
; 1366 :            that continue accessing the buffer for a brief period even
; 1367 :            though the device has already been detached.
; 1368 :         */
; 1369 :         if (dev->buf && dev->buf == dev->prev_buf)

  003f4	48 8b 44 24 60	 mov	 rax, QWORD PTR dev$[rsp]
  003f9	48 83 b8 c8 01
	00 00 00	 cmp	 QWORD PTR [rax+456], 0
  00401	74 2c		 je	 SHORT $LN13@attach_dev
  00403	48 8b 44 24 60	 mov	 rax, QWORD PTR dev$[rsp]
  00408	48 8b 4c 24 60	 mov	 rcx, QWORD PTR dev$[rsp]
  0040d	48 8b 89 d0 01
	00 00		 mov	 rcx, QWORD PTR [rcx+464]
  00414	48 39 88 c8 01
	00 00		 cmp	 QWORD PTR [rax+456], rcx
  0041b	75 12		 jne	 SHORT $LN13@attach_dev

; 1370 :             free_aligned( dev->buf );

  0041d	48 8b 44 24 60	 mov	 rax, QWORD PTR dev$[rsp]
  00422	48 8b 88 c8 01
	00 00		 mov	 rcx, QWORD PTR [rax+456]
  00429	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__aligned_free
$LN13@attach_dev:

; 1371 : 
; 1372 :         dev->buf = dev->prev_buf = malloc_aligned( dev->bufsize, _4K );

  0042f	48 8b 44 24 60	 mov	 rax, QWORD PTR dev$[rsp]
  00434	48 63 80 d8 01
	00 00		 movsxd	 rax, DWORD PTR [rax+472]
  0043b	ba 00 10 00 00	 mov	 edx, 4096		; 00001000H
  00440	48 8b c8	 mov	 rcx, rax
  00443	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__aligned_malloc
  00449	48 89 84 24 a8
	00 00 00	 mov	 QWORD PTR tv218[rsp], rax
  00451	48 8b 44 24 60	 mov	 rax, QWORD PTR dev$[rsp]
  00456	48 8b 8c 24 a8
	00 00 00	 mov	 rcx, QWORD PTR tv218[rsp]
  0045e	48 89 88 d0 01
	00 00		 mov	 QWORD PTR [rax+464], rcx
  00465	48 8b 44 24 60	 mov	 rax, QWORD PTR dev$[rsp]
  0046a	48 8b 8c 24 a8
	00 00 00	 mov	 rcx, QWORD PTR tv218[rsp]
  00472	48 89 88 c8 01
	00 00		 mov	 QWORD PTR [rax+456], rcx

; 1373 : 
; 1374 :         if (dev->buf == NULL)

  00479	48 8b 44 24 60	 mov	 rax, QWORD PTR dev$[rsp]
  0047e	48 83 b8 c8 01
	00 00 00	 cmp	 QWORD PTR [rax+456], 0
  00486	0f 85 22 01 00
	00		 jne	 $LN14@attach_dev

; 1375 :         {
; 1376 :             char buf[64];
; 1377 :             // "%1d:%04X error in function %s: %s"
; 1378 :             MSGBUF( buf, "malloc(%lu)", (unsigned long) dev->bufsize);

  0048c	48 8b 44 24 60	 mov	 rax, QWORD PTR dev$[rsp]
  00491	44 8b 88 d8 01
	00 00		 mov	 r9d, DWORD PTR [rax+472]
  00498	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG190541
  0049f	ba 40 00 00 00	 mov	 edx, 64			; 00000040H
  004a4	48 8d 8c 24 c0
	00 00 00	 lea	 rcx, QWORD PTR buf$1[rsp]
  004ac	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_snprintf

; 1379 :             WRMSG (HHC01460, "E", lcss, dev->devnum, buf, strerror(errno));

  004b2	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno
  004b8	8b 08		 mov	 ecx, DWORD PTR [rax]
  004ba	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_strerror
  004c0	48 89 84 24 b0
	00 00 00	 mov	 QWORD PTR tv228[rsp], rax
  004c8	48 8b 4c 24 60	 mov	 rcx, QWORD PTR dev$[rsp]
  004cd	0f b7 49 48	 movzx	 ecx, WORD PTR [rcx+72]
  004d1	89 8c 24 88 00
	00 00		 mov	 DWORD PTR tv239[rsp], ecx
  004d8	0f b7 94 24 20
	01 00 00	 movzx	 edx, WORD PTR lcss$[rsp]
  004e0	89 94 24 8c 00
	00 00		 mov	 DWORD PTR tv241[rsp], edx
  004e7	b9 01 00 00 00	 mov	 ecx, 1
  004ec	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  004f2	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR tv228[rsp]
  004fa	48 89 4c 24 50	 mov	 QWORD PTR [rsp+80], rcx
  004ff	48 8d 8c 24 c0
	00 00 00	 lea	 rcx, QWORD PTR buf$1[rsp]
  00507	48 89 4c 24 48	 mov	 QWORD PTR [rsp+72], rcx
  0050c	8b 8c 24 88 00
	00 00		 mov	 ecx, DWORD PTR tv239[rsp]
  00513	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  00517	8b 8c 24 8c 00
	00 00		 mov	 ecx, DWORD PTR tv241[rsp]
  0051e	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  00522	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG190542
  00529	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  0052e	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG190543
  00535	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  0053a	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  0053f	41 b9 03 00 00
	00		 mov	 r9d, 3
  00545	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG190544
  0054c	ba 63 05 00 00	 mov	 edx, 1379		; 00000563H
  00551	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG190545
  00558	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 1380 : 
; 1381 :             /* Detach the device and return it back to the DEVBLK pool */
; 1382 :             detach_devblk( dev, TRUE, "device", dev, dev->group );

  0055e	48 8b 44 24 60	 mov	 rax, QWORD PTR dev$[rsp]
  00563	48 8b 40 60	 mov	 rax, QWORD PTR [rax+96]
  00567	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  0056c	4c 8b 4c 24 60	 mov	 r9, QWORD PTR dev$[rsp]
  00571	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG190546
  00578	ba 01 00 00 00	 mov	 edx, 1
  0057d	48 8b 4c 24 60	 mov	 rcx, QWORD PTR dev$[rsp]
  00582	e8 00 00 00 00	 call	 detach_devblk

; 1383 : 
; 1384 :             release_lock(&sysblk.config);

  00587	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  0058e	48 05 80 00 00
	00		 add	 rax, 128		; 00000080H
  00594	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG190547
  0059b	48 8b c8	 mov	 rcx, rax
  0059e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_release_lock

; 1385 :             return 1;

  005a4	b8 01 00 00 00	 mov	 eax, 1
  005a9	e9 2c 01 00 00	 jmp	 $LN1@attach_dev
$LN14@attach_dev:
$LN12@attach_dev:

; 1386 :         }
; 1387 :     }
; 1388 : 
; 1389 :     /* Release device lock */
; 1390 :     release_lock(&dev->lock);

  005ae	48 8b 44 24 60	 mov	 rax, QWORD PTR dev$[rsp]
  005b3	48 83 c0 38	 add	 rax, 56			; 00000038H
  005b7	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG190548
  005be	48 8b c8	 mov	 rcx, rax
  005c1	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_release_lock

; 1391 : 
; 1392 : #ifdef _FEATURE_CHANNEL_SUBSYSTEM
; 1393 :     /* Build Channel Report */
; 1394 : #if defined(_370)
; 1395 :     if (sysblk.arch_mode != ARCH_370_IDX)

  005c7	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  005ce	83 b8 88 00 00
	00 00		 cmp	 DWORD PTR [rax+136], 0
  005d5	74 0a		 je	 SHORT $LN15@attach_dev

; 1396 : #endif
; 1397 :         build_attach_chrpt( dev );

  005d7	48 8b 4c 24 60	 mov	 rcx, QWORD PTR dev$[rsp]
  005dc	e8 00 00 00 00	 call	 build_attach_chrpt
$LN15@attach_dev:

; 1398 : #endif /*_FEATURE_CHANNEL_SUBSYSTEM*/
; 1399 : 
; 1400 :     /*
; 1401 :     if(lcss!=0 && sysblk.arch_mode==ARCH_370_IDX)
; 1402 :     {
; 1403 :         // "%1d:%04X: only devices on CSS 0 are usable in S/370 mode"
; 1404 :         WRMSG (HHC01458, "W", lcss, devnum);
; 1405 :     }
; 1406 :     */
; 1407 : 
; 1408 :     release_lock(&sysblk.config);

  005e1	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  005e8	48 05 80 00 00
	00		 add	 rax, 128		; 00000080H
  005ee	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG190550
  005f5	48 8b c8	 mov	 rcx, rax
  005f8	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_release_lock

; 1409 : 
; 1410 :     if ( rc == 0 && MLVL(DEBUG) )

  005fe	83 7c 24 6c 00	 cmp	 DWORD PTR rc$[rsp], 0
  00603	0f 85 cf 00 00
	00		 jne	 $LN16@attach_dev
  00609	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00610	8b 80 80 75 01
	00		 mov	 eax, DWORD PTR [rax+95616]
  00616	25 00 00 00 40	 and	 eax, 1073741824		; 40000000H
  0061b	85 c0		 test	 eax, eax
  0061d	0f 84 b5 00 00
	00		 je	 $LN16@attach_dev

; 1411 :     {
; 1412 :         // "Device %04X type %04X subchannel %d:%04X attached"
; 1413 :         WRMSG(HHC02198, "I", dev->devnum, dev->devtype, dev->chanset, dev->subchan);

  00623	48 8b 44 24 60	 mov	 rax, QWORD PTR dev$[rsp]
  00628	0f b7 40 46	 movzx	 eax, WORD PTR [rax+70]
  0062c	89 84 24 90 00
	00 00		 mov	 DWORD PTR tv275[rsp], eax
  00633	48 8b 4c 24 60	 mov	 rcx, QWORD PTR dev$[rsp]
  00638	0f b7 49 4c	 movzx	 ecx, WORD PTR [rcx+76]
  0063c	89 8c 24 94 00
	00 00		 mov	 DWORD PTR tv278[rsp], ecx
  00643	48 8b 54 24 60	 mov	 rdx, QWORD PTR dev$[rsp]
  00648	0f b7 52 4a	 movzx	 edx, WORD PTR [rdx+74]
  0064c	89 94 24 98 00
	00 00		 mov	 DWORD PTR tv281[rsp], edx
  00653	4c 8b 44 24 60	 mov	 r8, QWORD PTR dev$[rsp]
  00658	45 0f b7 40 48	 movzx	 r8d, WORD PTR [r8+72]
  0065d	44 89 84 24 9c
	00 00 00	 mov	 DWORD PTR tv284[rsp], r8d
  00665	b9 01 00 00 00	 mov	 ecx, 1
  0066a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  00670	8b 8c 24 90 00
	00 00		 mov	 ecx, DWORD PTR tv275[rsp]
  00677	89 4c 24 50	 mov	 DWORD PTR [rsp+80], ecx
  0067b	8b 8c 24 94 00
	00 00		 mov	 ecx, DWORD PTR tv278[rsp]
  00682	89 4c 24 48	 mov	 DWORD PTR [rsp+72], ecx
  00686	8b 8c 24 98 00
	00 00		 mov	 ecx, DWORD PTR tv281[rsp]
  0068d	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  00691	8b 8c 24 9c 00
	00 00		 mov	 ecx, DWORD PTR tv284[rsp]
  00698	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  0069c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG190552
  006a3	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  006a8	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG190553
  006af	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  006b4	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  006b9	41 b9 03 00 00
	00		 mov	 r9d, 3
  006bf	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG190554
  006c6	ba 85 05 00 00	 mov	 edx, 1413		; 00000585H
  006cb	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG190555
  006d2	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg
$LN16@attach_dev:

; 1414 :     }
; 1415 : 
; 1416 :     return 0;

  006d8	33 c0		 xor	 eax, eax
$LN1@attach_dev:

; 1417 : } /* end function attach_device */

  006da	48 8b 8c 24 00
	01 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  006e2	48 33 cc	 xor	 rcx, rsp
  006e5	e8 00 00 00 00	 call	 __security_check_cookie
  006ea	48 81 c4 18 01
	00 00		 add	 rsp, 280		; 00000118H
  006f1	c3		 ret	 0
attach_device ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\config.c
_TEXT	SEGMENT
subchan$ = 32
schw$ = 36
dev$ = 40
ioid$ = 64
find_device_by_subchan PROC

; 1699 : {

$LN10:
  00000	89 4c 24 08	 mov	 DWORD PTR [rsp+8], ecx
  00004	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 1700 :     DEVBLK*  dev;
; 1701 :     U16      subchan   = ioid & 0xFFFF;

  00008	8b 44 24 40	 mov	 eax, DWORD PTR ioid$[rsp]
  0000c	25 ff ff 00 00	 and	 eax, 65535		; 0000ffffH
  00011	66 89 44 24 20	 mov	 WORD PTR subchan$[rsp], ax

; 1702 :     unsigned int schw  = ((subchan & 0xff00)>>8) | (IOID_TO_LCSS( ioid ) << 8);

  00016	0f b7 44 24 20	 movzx	 eax, WORD PTR subchan$[rsp]
  0001b	25 00 ff 00 00	 and	 eax, 65280		; 0000ff00H
  00020	c1 f8 08	 sar	 eax, 8
  00023	8b 4c 24 40	 mov	 ecx, DWORD PTR ioid$[rsp]
  00027	c1 e9 11	 shr	 ecx, 17
  0002a	c1 e1 08	 shl	 ecx, 8
  0002d	0b c1		 or	 eax, ecx
  0002f	89 44 24 24	 mov	 DWORD PTR schw$[rsp], eax

; 1703 : 
; 1704 :     if (1
; 1705 :         && sysblk.subchan_fl
; 1706 :         && sysblk.subchan_fl[ schw ]
; 1707 :         && sysblk.subchan_fl[ schw ][ subchan & 0xff ]

  00033	33 c0		 xor	 eax, eax
  00035	83 f8 01	 cmp	 eax, 1
  00038	0f 84 82 00 00
	00		 je	 $LN5@find_devic
  0003e	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00045	48 83 b8 d8 11
	00 00 00	 cmp	 QWORD PTR [rax+4568], 0
  0004d	74 71		 je	 SHORT $LN5@find_devic
  0004f	8b 44 24 24	 mov	 eax, DWORD PTR schw$[rsp]
  00053	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  0005a	48 8b 89 d8 11
	00 00		 mov	 rcx, QWORD PTR [rcx+4568]
  00061	48 83 3c c1 00	 cmp	 QWORD PTR [rcx+rax*8], 0
  00066	74 58		 je	 SHORT $LN5@find_devic
  00068	8b 44 24 24	 mov	 eax, DWORD PTR schw$[rsp]
  0006c	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  00073	48 8b 89 d8 11
	00 00		 mov	 rcx, QWORD PTR [rcx+4568]
  0007a	0f b7 54 24 20	 movzx	 edx, WORD PTR subchan$[rsp]
  0007f	81 e2 ff 00 00
	00		 and	 edx, 255		; 000000ffH
  00085	48 63 d2	 movsxd	 rdx, edx
  00088	48 8b 04 c1	 mov	 rax, QWORD PTR [rcx+rax*8]
  0008c	48 83 3c d0 00	 cmp	 QWORD PTR [rax+rdx*8], 0
  00091	74 2d		 je	 SHORT $LN5@find_devic

; 1708 :     )
; 1709 :         return sysblk.subchan_fl[ schw ][ subchan & 0xff ];

  00093	8b 44 24 24	 mov	 eax, DWORD PTR schw$[rsp]
  00097	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  0009e	48 8b 89 d8 11
	00 00		 mov	 rcx, QWORD PTR [rcx+4568]
  000a5	0f b7 54 24 20	 movzx	 edx, WORD PTR subchan$[rsp]
  000aa	81 e2 ff 00 00
	00		 and	 edx, 255		; 000000ffH
  000b0	48 63 d2	 movsxd	 rdx, edx
  000b3	48 8b 04 c1	 mov	 rax, QWORD PTR [rcx+rax*8]
  000b7	48 8b 04 d0	 mov	 rax, QWORD PTR [rax+rdx*8]
  000bb	e9 92 00 00 00	 jmp	 $LN1@find_devic
$LN5@find_devic:

; 1710 : 
; 1711 :     for (dev = sysblk.firstdev; dev != NULL; dev = dev->nextdev)

  000c0	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  000c7	48 8b 80 c0 11
	00 00		 mov	 rax, QWORD PTR [rax+4544]
  000ce	48 89 44 24 28	 mov	 QWORD PTR dev$[rsp], rax
  000d3	eb 0e		 jmp	 SHORT $LN4@find_devic
$LN2@find_devic:
  000d5	48 8b 44 24 28	 mov	 rax, QWORD PTR dev$[rsp]
  000da	48 8b 40 30	 mov	 rax, QWORD PTR [rax+48]
  000de	48 89 44 24 28	 mov	 QWORD PTR dev$[rsp], rax
$LN4@find_devic:
  000e3	48 83 7c 24 28
	00		 cmp	 QWORD PTR dev$[rsp], 0
  000e9	74 2a		 je	 SHORT $LN3@find_devic

; 1712 :         if (dev->ssid == IOID_TO_SSID( ioid ) && dev->subchan == subchan)

  000eb	48 8b 44 24 28	 mov	 rax, QWORD PTR dev$[rsp]
  000f0	0f b7 40 44	 movzx	 eax, WORD PTR [rax+68]
  000f4	8b 4c 24 40	 mov	 ecx, DWORD PTR ioid$[rsp]
  000f8	c1 e9 10	 shr	 ecx, 16
  000fb	3b c1		 cmp	 eax, ecx
  000fd	75 14		 jne	 SHORT $LN6@find_devic
  000ff	48 8b 44 24 28	 mov	 rax, QWORD PTR dev$[rsp]
  00104	0f b7 40 46	 movzx	 eax, WORD PTR [rax+70]
  00108	0f b7 4c 24 20	 movzx	 ecx, WORD PTR subchan$[rsp]
  0010d	3b c1		 cmp	 eax, ecx
  0010f	75 02		 jne	 SHORT $LN6@find_devic

; 1713 :             break;

  00111	eb 02		 jmp	 SHORT $LN3@find_devic
$LN6@find_devic:
  00113	eb c0		 jmp	 SHORT $LN2@find_devic
$LN3@find_devic:

; 1714 : 
; 1715 :     if (dev)

  00115	48 83 7c 24 28
	00		 cmp	 QWORD PTR dev$[rsp], 0
  0011b	74 1c		 je	 SHORT $LN7@find_devic

; 1716 :         AddSubchanFastLookup( dev, IOID_TO_SSID( ioid ), subchan );

  0011d	8b 44 24 40	 mov	 eax, DWORD PTR ioid$[rsp]
  00121	c1 e8 10	 shr	 eax, 16
  00124	44 0f b7 44 24
	20		 movzx	 r8d, WORD PTR subchan$[rsp]
  0012a	0f b7 d0	 movzx	 edx, ax
  0012d	48 8b 4c 24 28	 mov	 rcx, QWORD PTR dev$[rsp]
  00132	e8 00 00 00 00	 call	 AddSubchanFastLookup
  00137	eb 14		 jmp	 SHORT $LN8@find_devic
$LN7@find_devic:

; 1717 :     else
; 1718 :         DelSubchanFastLookup( IOID_TO_SSID( ioid ), subchan );

  00139	8b 44 24 40	 mov	 eax, DWORD PTR ioid$[rsp]
  0013d	c1 e8 10	 shr	 eax, 16
  00140	0f b7 54 24 20	 movzx	 edx, WORD PTR subchan$[rsp]
  00145	0f b7 c8	 movzx	 ecx, ax
  00148	e8 00 00 00 00	 call	 DelSubchanFastLookup
$LN8@find_devic:

; 1719 : 
; 1720 :     return dev;

  0014d	48 8b 44 24 28	 mov	 rax, QWORD PTR dev$[rsp]
$LN1@find_devic:

; 1721 : }

  00152	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00156	c3		 ret	 0
find_device_by_subchan ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\config.c
_TEXT	SEGMENT
chan$ = 32
dev$ = 40
devtab$ = 48
lcss$ = 80
devnum$ = 88
find_device_by_devnum PROC

; 1659 : {

$LN14:
  00000	66 89 54 24 10	 mov	 WORD PTR [rsp+16], dx
  00005	66 89 4c 24 08	 mov	 WORD PTR [rsp+8], cx
  0000a	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 1660 :     DEVBLK*   dev;
; 1661 :     DEVBLK**  devtab;
; 1662 :     int       chan;
; 1663 : 
; 1664 :     chan = (devnum & 0xff00) >> 8 | ((lcss & (FEATURE_LCSS_MAX-1)) << 8);

  0000e	0f b7 44 24 58	 movzx	 eax, WORD PTR devnum$[rsp]
  00013	25 00 ff 00 00	 and	 eax, 65280		; 0000ff00H
  00018	c1 f8 08	 sar	 eax, 8
  0001b	0f b7 4c 24 50	 movzx	 ecx, WORD PTR lcss$[rsp]
  00020	83 e1 03	 and	 ecx, 3
  00023	c1 e1 08	 shl	 ecx, 8
  00026	0b c1		 or	 eax, ecx
  00028	89 44 24 20	 mov	 DWORD PTR chan$[rsp], eax

; 1665 : 
; 1666 :     if (sysblk.devnum_fl)

  0002c	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00033	48 83 b8 d0 11
	00 00 00	 cmp	 QWORD PTR [rax+4560], 0
  0003b	0f 84 aa 00 00
	00		 je	 $LN5@find_devic

; 1667 :     {
; 1668 :         devtab = sysblk.devnum_fl[ chan ];

  00041	48 63 44 24 20	 movsxd	 rax, DWORD PTR chan$[rsp]
  00046	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  0004d	48 8b 89 d0 11
	00 00		 mov	 rcx, QWORD PTR [rcx+4560]
  00054	48 8b 04 c1	 mov	 rax, QWORD PTR [rcx+rax*8]
  00058	48 89 44 24 30	 mov	 QWORD PTR devtab$[rsp], rax

; 1669 : 
; 1670 :         if (devtab)

  0005d	48 83 7c 24 30
	00		 cmp	 QWORD PTR devtab$[rsp], 0
  00063	0f 84 82 00 00
	00		 je	 $LN6@find_devic

; 1671 :         {
; 1672 :             dev = devtab[ devnum & 0xff ];

  00069	0f b7 44 24 58	 movzx	 eax, WORD PTR devnum$[rsp]
  0006e	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  00073	48 98		 cdqe
  00075	48 8b 4c 24 30	 mov	 rcx, QWORD PTR devtab$[rsp]
  0007a	48 8b 04 c1	 mov	 rax, QWORD PTR [rcx+rax*8]
  0007e	48 89 44 24 28	 mov	 QWORD PTR dev$[rsp], rax

; 1673 : 
; 1674 :             if (dev && IS_DEV( dev ) && dev->devnum == devnum)

  00083	48 83 7c 24 28
	00		 cmp	 QWORD PTR dev$[rsp], 0
  00089	74 51		 je	 SHORT $LN7@find_devic
  0008b	48 8b 44 24 28	 mov	 rax, QWORD PTR dev$[rsp]
  00090	83 78 40 00	 cmp	 DWORD PTR [rax+64], 0
  00094	74 46		 je	 SHORT $LN7@find_devic
  00096	48 8b 44 24 28	 mov	 rax, QWORD PTR dev$[rsp]
  0009b	0f b6 80 f1 02
	00 00		 movzx	 eax, BYTE PTR [rax+753]
  000a2	83 e0 01	 and	 eax, 1
  000a5	85 c0		 test	 eax, eax
  000a7	75 15		 jne	 SHORT $LN9@find_devic
  000a9	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  000b0	48 8b 80 c8 11
	00 00		 mov	 rax, QWORD PTR [rax+4552]
  000b7	48 39 44 24 28	 cmp	 QWORD PTR dev$[rsp], rax
  000bc	75 1e		 jne	 SHORT $LN7@find_devic
$LN9@find_devic:
  000be	48 8b 44 24 28	 mov	 rax, QWORD PTR dev$[rsp]
  000c3	0f b7 40 48	 movzx	 eax, WORD PTR [rax+72]
  000c7	0f b7 4c 24 58	 movzx	 ecx, WORD PTR devnum$[rsp]
  000cc	3b c1		 cmp	 eax, ecx
  000ce	75 0c		 jne	 SHORT $LN7@find_devic

; 1675 :                 return dev;

  000d0	48 8b 44 24 28	 mov	 rax, QWORD PTR dev$[rsp]
  000d5	e9 c2 00 00 00	 jmp	 $LN1@find_devic
  000da	eb 0f		 jmp	 SHORT $LN8@find_devic
$LN7@find_devic:

; 1676 :             else
; 1677 :                 DelDevnumFastLookup( lcss, devnum );

  000dc	0f b7 54 24 58	 movzx	 edx, WORD PTR devnum$[rsp]
  000e1	0f b7 4c 24 50	 movzx	 ecx, WORD PTR lcss$[rsp]
  000e6	e8 00 00 00 00	 call	 DelDevnumFastLookup
$LN8@find_devic:
$LN6@find_devic:
$LN5@find_devic:

; 1678 :         }
; 1679 :     }
; 1680 : 
; 1681 :     for (dev = sysblk.firstdev; dev != NULL; dev = dev->nextdev)

  000eb	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  000f2	48 8b 80 c0 11
	00 00		 mov	 rax, QWORD PTR [rax+4544]
  000f9	48 89 44 24 28	 mov	 QWORD PTR dev$[rsp], rax
  000fe	eb 0e		 jmp	 SHORT $LN4@find_devic
$LN2@find_devic:
  00100	48 8b 44 24 28	 mov	 rax, QWORD PTR dev$[rsp]
  00105	48 8b 40 30	 mov	 rax, QWORD PTR [rax+48]
  00109	48 89 44 24 28	 mov	 QWORD PTR dev$[rsp], rax
$LN4@find_devic:
  0010e	48 83 7c 24 28
	00		 cmp	 QWORD PTR dev$[rsp], 0
  00114	74 64		 je	 SHORT $LN3@find_devic

; 1682 :         if (1
; 1683 :             && IS_DEV( dev )
; 1684 :             && dev->devnum == devnum
; 1685 :             && lcss == SSID_TO_LCSS( dev->ssid )

  00116	33 c0		 xor	 eax, eax
  00118	83 f8 01	 cmp	 eax, 1
  0011b	74 5b		 je	 SHORT $LN10@find_devic
  0011d	48 8b 44 24 28	 mov	 rax, QWORD PTR dev$[rsp]
  00122	83 78 40 00	 cmp	 DWORD PTR [rax+64], 0
  00126	74 50		 je	 SHORT $LN10@find_devic
  00128	48 8b 44 24 28	 mov	 rax, QWORD PTR dev$[rsp]
  0012d	0f b6 80 f1 02
	00 00		 movzx	 eax, BYTE PTR [rax+753]
  00134	83 e0 01	 and	 eax, 1
  00137	85 c0		 test	 eax, eax
  00139	75 15		 jne	 SHORT $LN11@find_devic
  0013b	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00142	48 8b 80 c8 11
	00 00		 mov	 rax, QWORD PTR [rax+4552]
  00149	48 39 44 24 28	 cmp	 QWORD PTR dev$[rsp], rax
  0014e	75 28		 jne	 SHORT $LN10@find_devic
$LN11@find_devic:
  00150	48 8b 44 24 28	 mov	 rax, QWORD PTR dev$[rsp]
  00155	0f b7 40 48	 movzx	 eax, WORD PTR [rax+72]
  00159	0f b7 4c 24 58	 movzx	 ecx, WORD PTR devnum$[rsp]
  0015e	3b c1		 cmp	 eax, ecx
  00160	75 16		 jne	 SHORT $LN10@find_devic
  00162	0f b7 44 24 50	 movzx	 eax, WORD PTR lcss$[rsp]
  00167	48 8b 4c 24 28	 mov	 rcx, QWORD PTR dev$[rsp]
  0016c	0f b7 49 44	 movzx	 ecx, WORD PTR [rcx+68]
  00170	d1 f9		 sar	 ecx, 1
  00172	3b c1		 cmp	 eax, ecx
  00174	75 02		 jne	 SHORT $LN10@find_devic

; 1686 :         )
; 1687 :             break;

  00176	eb 02		 jmp	 SHORT $LN3@find_devic
$LN10@find_devic:
  00178	eb 86		 jmp	 SHORT $LN2@find_devic
$LN3@find_devic:

; 1688 : 
; 1689 :     if (dev)

  0017a	48 83 7c 24 28
	00		 cmp	 QWORD PTR dev$[rsp], 0
  00180	74 15		 je	 SHORT $LN12@find_devic

; 1690 :         AddDevnumFastLookup( dev, lcss, devnum );

  00182	44 0f b7 44 24
	58		 movzx	 r8d, WORD PTR devnum$[rsp]
  00188	0f b7 54 24 50	 movzx	 edx, WORD PTR lcss$[rsp]
  0018d	48 8b 4c 24 28	 mov	 rcx, QWORD PTR dev$[rsp]
  00192	e8 00 00 00 00	 call	 AddDevnumFastLookup
$LN12@find_devic:

; 1691 : 
; 1692 :     return dev;

  00197	48 8b 44 24 28	 mov	 rax, QWORD PTR dev$[rsp]
$LN1@find_devic:

; 1693 : }

  0019c	48 83 c4 48	 add	 rsp, 72			; 00000048H
  001a0	c3		 ret	 0
find_device_by_devnum ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\config.c
_TEXT	SEGMENT
cpu$ = 80
tv130 = 84
tv137 = 88
tv164 = 92
tv184 = 96
dev$ = 104
tv166 = 112
tv186 = 120
arg$ = 144
release_config PROC

; 874  : {

$LN31:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 81 ec 88 00
	00 00		 sub	 rsp, 136		; 00000088H
$LN4@release_co:

; 875  : DEVBLK *dev;
; 876  : int     cpu;
; 877  : 
; 878  :     UNREFERENCED( arg );

  0000c	33 c0		 xor	 eax, eax
  0000e	85 c0		 test	 eax, eax
  00010	75 fa		 jne	 SHORT $LN4@release_co

; 879  : 
; 880  :     /* Deconfigure all CPU's */
; 881  :     OBTAIN_INTLOCK(NULL);

  00012	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG190296
  00019	33 c9		 xor	 ecx, ecx
  0001b	e8 00 00 00 00	 call	 Obtain_Interrupt_Lock

; 882  :     for (cpu = 0; cpu < sysblk.maxcpu; cpu++)

  00020	c7 44 24 50 00
	00 00 00	 mov	 DWORD PTR cpu$[rsp], 0
  00028	eb 0a		 jmp	 SHORT $LN7@release_co
$LN5@release_co:
  0002a	8b 44 24 50	 mov	 eax, DWORD PTR cpu$[rsp]
  0002e	ff c0		 inc	 eax
  00030	89 44 24 50	 mov	 DWORD PTR cpu$[rsp], eax
$LN7@release_co:
  00034	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  0003b	8b 80 00 01 00
	00		 mov	 eax, DWORD PTR [rax+256]
  00041	39 44 24 50	 cmp	 DWORD PTR cpu$[rsp], eax
  00045	7d 22		 jge	 SHORT $LN6@release_co

; 883  :         if(IS_CPU_ONLINE(cpu))

  00047	48 63 44 24 50	 movsxd	 rax, DWORD PTR cpu$[rsp]
  0004c	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  00053	48 83 bc c1 98
	0b 00 00 00	 cmp	 QWORD PTR [rcx+rax*8+2968], 0
  0005c	74 09		 je	 SHORT $LN11@release_co

; 884  :             deconfigure_cpu(cpu);

  0005e	8b 4c 24 50	 mov	 ecx, DWORD PTR cpu$[rsp]
  00062	e8 00 00 00 00	 call	 deconfigure_cpu
$LN11@release_co:
  00067	eb c1		 jmp	 SHORT $LN5@release_co
$LN6@release_co:

; 885  :     RELEASE_INTLOCK(NULL);

  00069	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG190298
  00070	33 c9		 xor	 ecx, ecx
  00072	e8 00 00 00 00	 call	 Release_Interrupt_Lock

; 886  : 
; 887  :     /* Dump trace tables at exit */
; 888  : #if defined( OPTION_SHARED_DEVICES )
; 889  :     if (sysblk.shrddtax)

  00077	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  0007e	0f b6 80 dc 13
	00 00		 movzx	 eax, BYTE PTR [rax+5084]
  00085	85 c0		 test	 eax, eax
  00087	74 06		 je	 SHORT $LN12@release_co

; 890  :         shared_print_trace_table();

  00089	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_shared_print_trace_table
$LN12@release_co:

; 891  : #endif
; 892  :     if (cckd_dtax())

  0008f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_cckd_dtax
  00095	0f b6 c0	 movzx	 eax, al
  00098	85 c0		 test	 eax, eax
  0009a	74 06		 je	 SHORT $LN13@release_co

; 893  :         cckd_print_itrace();

  0009c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_cckd_print_itrace
$LN13@release_co:

; 894  :     if (ptt_dtax())

  000a2	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ptt_dtax
  000a8	0f b6 c0	 movzx	 eax, al
  000ab	85 c0		 test	 eax, eax
  000ad	74 06		 je	 SHORT $LN14@release_co

; 895  :         ptt_pthread_print();

  000af	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ptt_pthread_print
$LN14@release_co:

; 896  : 
; 897  :     /* Detach all devices */
; 898  :     for (dev = sysblk.firstdev; dev != NULL; dev = dev->nextdev)

  000b5	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  000bc	48 8b 80 c0 11
	00 00		 mov	 rax, QWORD PTR [rax+4544]
  000c3	48 89 44 24 68	 mov	 QWORD PTR dev$[rsp], rax
  000c8	eb 0e		 jmp	 SHORT $LN10@release_co
$LN8@release_co:
  000ca	48 8b 44 24 68	 mov	 rax, QWORD PTR dev$[rsp]
  000cf	48 8b 40 30	 mov	 rax, QWORD PTR [rax+48]
  000d3	48 89 44 24 68	 mov	 QWORD PTR dev$[rsp], rax
$LN10@release_co:
  000d8	48 83 7c 24 68
	00		 cmp	 QWORD PTR dev$[rsp], 0
  000de	0f 84 9b 00 00
	00		 je	 $LN9@release_co

; 899  :         if (dev->allocated)

  000e4	48 8b 44 24 68	 mov	 rax, QWORD PTR dev$[rsp]
  000e9	83 78 40 00	 cmp	 DWORD PTR [rax+64], 0
  000ed	0f 84 87 00 00
	00		 je	 $LN15@release_co

; 900  :         {
; 901  :             if (sysblk.arch_mode == ARCH_370_IDX)

  000f3	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  000fa	83 b8 88 00 00
	00 00		 cmp	 DWORD PTR [rax+136], 0
  00101	75 51		 jne	 SHORT $LN16@release_co

; 902  :                 detach_device(LCSS_DEVNUM);

  00103	48 83 7c 24 68
	00		 cmp	 QWORD PTR dev$[rsp], 0
  00109	74 0f		 je	 SHORT $LN19@release_co
  0010b	48 8b 44 24 68	 mov	 rax, QWORD PTR dev$[rsp]
  00110	0f b7 40 48	 movzx	 eax, WORD PTR [rax+72]
  00114	89 44 24 54	 mov	 DWORD PTR tv130[rsp], eax
  00118	eb 08		 jmp	 SHORT $LN20@release_co
$LN19@release_co:
  0011a	c7 44 24 54 00
	00 00 00	 mov	 DWORD PTR tv130[rsp], 0
$LN20@release_co:
  00122	48 83 7c 24 68
	00		 cmp	 QWORD PTR dev$[rsp], 0
  00128	74 11		 je	 SHORT $LN21@release_co
  0012a	48 8b 44 24 68	 mov	 rax, QWORD PTR dev$[rsp]
  0012f	0f b7 40 44	 movzx	 eax, WORD PTR [rax+68]
  00133	d1 f8		 sar	 eax, 1
  00135	89 44 24 58	 mov	 DWORD PTR tv137[rsp], eax
  00139	eb 08		 jmp	 SHORT $LN22@release_co
$LN21@release_co:
  0013b	c7 44 24 58 00
	00 00 00	 mov	 DWORD PTR tv137[rsp], 0
$LN22@release_co:
  00143	0f b7 54 24 54	 movzx	 edx, WORD PTR tv130[rsp]
  00148	0f b7 4c 24 58	 movzx	 ecx, WORD PTR tv137[rsp]
  0014d	e8 00 00 00 00	 call	 detach_device
  00152	eb 26		 jmp	 SHORT $LN17@release_co
$LN16@release_co:

; 903  :             else
; 904  :                 detach_subchan(SSID_TO_LCSS(dev->ssid), dev->subchan, dev->devnum);

  00154	48 8b 44 24 68	 mov	 rax, QWORD PTR dev$[rsp]
  00159	0f b7 40 44	 movzx	 eax, WORD PTR [rax+68]
  0015d	d1 f8		 sar	 eax, 1
  0015f	48 8b 4c 24 68	 mov	 rcx, QWORD PTR dev$[rsp]
  00164	44 0f b7 41 48	 movzx	 r8d, WORD PTR [rcx+72]
  00169	48 8b 4c 24 68	 mov	 rcx, QWORD PTR dev$[rsp]
  0016e	0f b7 51 46	 movzx	 edx, WORD PTR [rcx+70]
  00172	0f b7 c8	 movzx	 ecx, ax
  00175	e8 00 00 00 00	 call	 detach_subchan
$LN17@release_co:
$LN15@release_co:

; 905  :         }

  0017a	e9 4b ff ff ff	 jmp	 $LN8@release_co
$LN9@release_co:

; 906  : 
; 907  :     /* Terminate device threads */
; 908  :     obtain_lock (&sysblk.ioqlock);

  0017f	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00186	48 05 38 12 00
	00		 add	 rax, 4664		; 00001238H
  0018c	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG190305
  00193	48 8b c8	 mov	 rcx, rax
  00196	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_obtain_lock

; 909  :     sysblk.devtwait=0;

  0019c	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  001a3	c7 80 48 12 00
	00 00 00 00 00	 mov	 DWORD PTR [rax+4680], 0

; 910  :     broadcast_condition (&sysblk.ioqcond);

  001ad	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  001b4	48 05 40 12 00
	00		 add	 rax, 4672		; 00001240H
  001ba	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG190306
  001c1	48 8b c8	 mov	 rcx, rax
  001c4	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_broadcast_condition

; 911  :     release_lock (&sysblk.ioqlock);

  001ca	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  001d1	48 05 38 12 00
	00		 add	 rax, 4664		; 00001238H
  001d7	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG190307
  001de	48 8b c8	 mov	 rcx, rax
  001e1	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_release_lock

; 912  : 
; 913  :     /* release storage          */
; 914  :     sysblk.lock_mainstor = 0;

  001e7	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  001ee	8b 80 a8 00 00
	00		 mov	 eax, DWORD PTR [rax+168]
  001f4	83 e0 fe	 and	 eax, -2			; fffffffeH
  001f7	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  001fe	89 81 a8 00 00
	00		 mov	 DWORD PTR [rcx+168], eax

; 915  :     WRMSG( HHC01427, "I", "Main", !configure_storage(~0ULL) ? "" : "not " );

  00204	48 c7 c1 ff ff
	ff ff		 mov	 rcx, -1
  0020b	e8 00 00 00 00	 call	 configure_storage
  00210	85 c0		 test	 eax, eax
  00212	75 0a		 jne	 SHORT $LN23@release_co
  00214	c7 44 24 5c 01
	00 00 00	 mov	 DWORD PTR tv164[rsp], 1
  0021c	eb 08		 jmp	 SHORT $LN24@release_co
$LN23@release_co:
  0021e	c7 44 24 5c 00
	00 00 00	 mov	 DWORD PTR tv164[rsp], 0
$LN24@release_co:
  00226	83 7c 24 5c 00	 cmp	 DWORD PTR tv164[rsp], 0
  0022b	74 0e		 je	 SHORT $LN25@release_co
  0022d	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG190308
  00234	48 89 44 24 70	 mov	 QWORD PTR tv166[rsp], rax
  00239	eb 0c		 jmp	 SHORT $LN26@release_co
$LN25@release_co:
  0023b	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG190309
  00242	48 89 44 24 70	 mov	 QWORD PTR tv166[rsp], rax
$LN26@release_co:
  00247	b9 01 00 00 00	 mov	 ecx, 1
  0024c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  00252	48 8b 4c 24 70	 mov	 rcx, QWORD PTR tv166[rsp]
  00257	48 89 4c 24 40	 mov	 QWORD PTR [rsp+64], rcx
  0025c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG190310
  00263	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  00268	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG190311
  0026f	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  00274	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG190312
  0027b	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00280	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00285	41 b9 03 00 00
	00		 mov	 r9d, 3
  0028b	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG190313
  00292	ba 93 03 00 00	 mov	 edx, 915		; 00000393H
  00297	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG190314
  0029e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 916  : 
; 917  :     /* release expanded storage */
; 918  :     sysblk.lock_xpndstor = 0;

  002a4	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  002ab	8b 80 b8 00 00
	00		 mov	 eax, DWORD PTR [rax+184]
  002b1	83 e0 fe	 and	 eax, -2			; fffffffeH
  002b4	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  002bb	89 81 b8 00 00
	00		 mov	 DWORD PTR [rcx+184], eax

; 919  :     WRMSG( HHC01427, "I", "Expanded", !configure_xstorage(~0ULL) ? "" : "not ");

  002c1	48 c7 c1 ff ff
	ff ff		 mov	 rcx, -1
  002c8	e8 00 00 00 00	 call	 configure_xstorage
  002cd	85 c0		 test	 eax, eax
  002cf	75 0a		 jne	 SHORT $LN27@release_co
  002d1	c7 44 24 60 01
	00 00 00	 mov	 DWORD PTR tv184[rsp], 1
  002d9	eb 08		 jmp	 SHORT $LN28@release_co
$LN27@release_co:
  002db	c7 44 24 60 00
	00 00 00	 mov	 DWORD PTR tv184[rsp], 0
$LN28@release_co:
  002e3	83 7c 24 60 00	 cmp	 DWORD PTR tv184[rsp], 0
  002e8	74 0e		 je	 SHORT $LN29@release_co
  002ea	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG190315
  002f1	48 89 44 24 78	 mov	 QWORD PTR tv186[rsp], rax
  002f6	eb 0c		 jmp	 SHORT $LN30@release_co
$LN29@release_co:
  002f8	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG190316
  002ff	48 89 44 24 78	 mov	 QWORD PTR tv186[rsp], rax
$LN30@release_co:
  00304	b9 01 00 00 00	 mov	 ecx, 1
  00309	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  0030f	48 8b 4c 24 78	 mov	 rcx, QWORD PTR tv186[rsp]
  00314	48 89 4c 24 40	 mov	 QWORD PTR [rsp+64], rcx
  00319	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG190317
  00320	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  00325	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG190318
  0032c	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  00331	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG190319
  00338	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  0033d	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00342	41 b9 03 00 00
	00		 mov	 r9d, 3
  00348	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG190320
  0034f	ba 97 03 00 00	 mov	 edx, 919		; 00000397H
  00354	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG190321
  0035b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 920  : 
; 921  :     WRMSG(HHC01422, "I");

  00361	b9 01 00 00 00	 mov	 ecx, 1
  00366	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  0036c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG190322
  00373	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  00378	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG190323
  0037f	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00384	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00389	41 b9 03 00 00
	00		 mov	 r9d, 3
  0038f	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG190324
  00396	ba 99 03 00 00	 mov	 edx, 921		; 00000399H
  0039b	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG190325
  003a2	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 922  : } /* end function release_config */

  003a8	48 81 c4 88 00
	00 00		 add	 rsp, 136		; 00000088H
  003af	c3		 ret	 0
release_config ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\hmalloc.h
_TEXT	SEGMENT
result$ = 32
size$ = 64
alignment$ = 72
calloc_aligned PROC

; 151  :     {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	57		 push	 rdi
  0000b	48 83 ec 30	 sub	 rsp, 48			; 00000030H

; 152  :         void* result;
; 153  : 
; 154  :         if (!size)

  0000f	48 83 7c 24 40
	00		 cmp	 QWORD PTR size$[rsp], 0
  00015	75 04		 jne	 SHORT $LN2@calloc_ali

; 155  :         {
; 156  :             return (NULL);

  00017	33 c0		 xor	 eax, eax
  00019	eb 30		 jmp	 SHORT $LN1@calloc_ali
$LN2@calloc_ali:

; 157  :         }
; 158  : 
; 159  :         result = _aligned_malloc(size, alignment);

  0001b	48 8b 54 24 48	 mov	 rdx, QWORD PTR alignment$[rsp]
  00020	48 8b 4c 24 40	 mov	 rcx, QWORD PTR size$[rsp]
  00025	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__aligned_malloc
  0002b	48 89 44 24 20	 mov	 QWORD PTR result$[rsp], rax

; 160  : 
; 161  :         if (result != NULL)

  00030	48 83 7c 24 20
	00		 cmp	 QWORD PTR result$[rsp], 0
  00036	74 0e		 je	 SHORT $LN3@calloc_ali

; 162  :         {
; 163  :             memset(result, 0, size);

  00038	48 8b 7c 24 20	 mov	 rdi, QWORD PTR result$[rsp]
  0003d	33 c0		 xor	 eax, eax
  0003f	48 8b 4c 24 40	 mov	 rcx, QWORD PTR size$[rsp]
  00044	f3 aa		 rep stosb
$LN3@calloc_ali:

; 164  :         }
; 165  : 
; 166  :         return (result);

  00046	48 8b 44 24 20	 mov	 rax, QWORD PTR result$[rsp]
$LN1@calloc_ali:

; 167  :     }

  0004b	48 83 c4 30	 add	 rsp, 48			; 00000030H
  0004f	5f		 pop	 rdi
  00050	c3		 ret	 0
calloc_aligned ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\dbgtrace.h
_TEXT	SEGMENT
buffsize$ = 48
rc$ = 52
chunksize$ = 56
buffer$ = 64
args$ = 72
fmt$ = 96
DebuggerTrace PROC

; 94   :   static inline void DebuggerTrace(char* fmt, ...) {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000f	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00014	48 83 ec 58	 sub	 rsp, 88			; 00000058H

; 95   :       const int chunksize = 512;

  00018	c7 44 24 38 00
	02 00 00	 mov	 DWORD PTR chunksize$[rsp], 512 ; 00000200H

; 96   :       int buffsize = 0;

  00020	c7 44 24 30 00
	00 00 00	 mov	 DWORD PTR buffsize$[rsp], 0

; 97   :       char* buffer = NULL;

  00028	48 c7 44 24 40
	00 00 00 00	 mov	 QWORD PTR buffer$[rsp], 0

; 98   :       int rc = -1;

  00031	c7 44 24 34 ff
	ff ff ff	 mov	 DWORD PTR rc$[rsp], -1

; 99   :       va_list args;
; 100  :       va_start( args, fmt );

  00039	48 8d 44 24 68	 lea	 rax, QWORD PTR fmt$[rsp+8]
  0003e	48 89 44 24 48	 mov	 QWORD PTR args$[rsp], rax
$LN9@DebuggerTr:
$LN4@DebuggerTr:

; 101  :       do {
; 102  :           if (buffer) free( buffer );

  00043	48 83 7c 24 40
	00		 cmp	 QWORD PTR buffer$[rsp], 0
  00049	74 0b		 je	 SHORT $LN5@DebuggerTr
  0004b	48 8b 4c 24 40	 mov	 rcx, QWORD PTR buffer$[rsp]
  00050	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free
$LN5@DebuggerTr:

; 103  :           buffsize += chunksize;

  00056	8b 44 24 38	 mov	 eax, DWORD PTR chunksize$[rsp]
  0005a	8b 4c 24 30	 mov	 ecx, DWORD PTR buffsize$[rsp]
  0005e	03 c8		 add	 ecx, eax
  00060	8b c1		 mov	 eax, ecx
  00062	89 44 24 30	 mov	 DWORD PTR buffsize$[rsp], eax

; 104  :           buffer = malloc( buffsize + 1 );

  00066	8b 44 24 30	 mov	 eax, DWORD PTR buffsize$[rsp]
  0006a	ff c0		 inc	 eax
  0006c	48 98		 cdqe
  0006e	48 8b c8	 mov	 rcx, rax
  00071	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_malloc
  00077	48 89 44 24 40	 mov	 QWORD PTR buffer$[rsp], rax

; 105  :           if (!buffer) BREAK_INTO_DEBUGGER();

  0007c	48 83 7c 24 40
	00		 cmp	 QWORD PTR buffer$[rsp], 0
  00082	75 01		 jne	 SHORT $LN6@DebuggerTr
  00084	cc		 int	 3
$LN6@DebuggerTr:

; 106  :           rc = _vsnprintf_s( buffer, buffsize+1, buffsize, fmt, args);

  00085	48 63 44 24 30	 movsxd	 rax, DWORD PTR buffsize$[rsp]
  0008a	8b 4c 24 30	 mov	 ecx, DWORD PTR buffsize$[rsp]
  0008e	ff c1		 inc	 ecx
  00090	48 63 c9	 movsxd	 rcx, ecx
  00093	48 8b 54 24 48	 mov	 rdx, QWORD PTR args$[rsp]
  00098	48 89 54 24 20	 mov	 QWORD PTR [rsp+32], rdx
  0009d	4c 8b 4c 24 60	 mov	 r9, QWORD PTR fmt$[rsp]
  000a2	4c 8b c0	 mov	 r8, rax
  000a5	48 8b d1	 mov	 rdx, rcx
  000a8	48 8b 4c 24 40	 mov	 rcx, QWORD PTR buffer$[rsp]
  000ad	e8 00 00 00 00	 call	 _vsnprintf_s
  000b2	89 44 24 34	 mov	 DWORD PTR rc$[rsp], eax

; 107  :       } while (rc < 0 || rc >= buffsize);

  000b6	83 7c 24 34 00	 cmp	 DWORD PTR rc$[rsp], 0
  000bb	7c 86		 jl	 SHORT $LN4@DebuggerTr
  000bd	8b 44 24 30	 mov	 eax, DWORD PTR buffsize$[rsp]
  000c1	39 44 24 34	 cmp	 DWORD PTR rc$[rsp], eax
  000c5	0f 8d 78 ff ff
	ff		 jge	 $LN9@DebuggerTr

; 108  :       OutputDebugStringA( buffer ); /* send to debugger pane */

  000cb	48 8b 4c 24 40	 mov	 rcx, QWORD PTR buffer$[rsp]
  000d0	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_OutputDebugStringA

; 109  :       if (buffer) free( buffer );

  000d6	48 83 7c 24 40
	00		 cmp	 QWORD PTR buffer$[rsp], 0
  000dc	74 0b		 je	 SHORT $LN7@DebuggerTr
  000de	48 8b 4c 24 40	 mov	 rcx, QWORD PTR buffer$[rsp]
  000e3	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free
$LN7@DebuggerTr:

; 110  :       va_end( args );

  000e9	48 c7 44 24 48
	00 00 00 00	 mov	 QWORD PTR args$[rsp], 0

; 111  :   }

  000f2	48 83 c4 58	 add	 rsp, 88			; 00000058H
  000f6	c3		 ret	 0
DebuggerTrace ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files (x86)\Windows Kits\10\include\10.0.22000.0\ucrt\stdio.h
;	COMDAT _vsnprintf_s
_TEXT	SEGMENT
_Buffer$ = 64
_BufferCount$ = 72
_MaxCount$ = 80
_Format$ = 88
_ArgList$ = 96
_vsnprintf_s PROC					; COMDAT

; 1598 :     {

$LN3:
  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 1599 :         return _vsnprintf_s_l(_Buffer, _BufferCount, _MaxCount, _Format, NULL, _ArgList);

  00018	48 8b 44 24 60	 mov	 rax, QWORD PTR _ArgList$[rsp]
  0001d	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  00022	48 c7 44 24 20
	00 00 00 00	 mov	 QWORD PTR [rsp+32], 0
  0002b	4c 8b 4c 24 58	 mov	 r9, QWORD PTR _Format$[rsp]
  00030	4c 8b 44 24 50	 mov	 r8, QWORD PTR _MaxCount$[rsp]
  00035	48 8b 54 24 48	 mov	 rdx, QWORD PTR _BufferCount$[rsp]
  0003a	48 8b 4c 24 40	 mov	 rcx, QWORD PTR _Buffer$[rsp]
  0003f	e8 00 00 00 00	 call	 _vsnprintf_s_l

; 1600 :     }

  00044	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00048	c3		 ret	 0
_vsnprintf_s ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files (x86)\Windows Kits\10\include\10.0.22000.0\ucrt\stdio.h
;	COMDAT _vsnprintf_s_l
_TEXT	SEGMENT
_Result$ = 64
tv74 = 68
_Buffer$ = 96
_BufferCount$ = 104
_MaxCount$ = 112
_Format$ = 120
_Locale$ = 128
_ArgList$ = 136
_vsnprintf_s_l PROC					; COMDAT

; 1577 :     {

$LN5:
  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	48 83 ec 58	 sub	 rsp, 88			; 00000058H

; 1578 :         int const _Result = __stdio_common_vsnprintf_s(

  00018	e8 00 00 00 00	 call	 __local_stdio_printf_options
  0001d	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR _ArgList$[rsp]
  00025	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  0002a	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR _Locale$[rsp]
  00032	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00037	48 8b 4c 24 78	 mov	 rcx, QWORD PTR _Format$[rsp]
  0003c	48 89 4c 24 20	 mov	 QWORD PTR [rsp+32], rcx
  00041	4c 8b 4c 24 70	 mov	 r9, QWORD PTR _MaxCount$[rsp]
  00046	4c 8b 44 24 68	 mov	 r8, QWORD PTR _BufferCount$[rsp]
  0004b	48 8b 54 24 60	 mov	 rdx, QWORD PTR _Buffer$[rsp]
  00050	48 8b 08	 mov	 rcx, QWORD PTR [rax]
  00053	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___stdio_common_vsnprintf_s
  00059	89 44 24 40	 mov	 DWORD PTR _Result$[rsp], eax

; 1579 :             _CRT_INTERNAL_LOCAL_PRINTF_OPTIONS,
; 1580 :             _Buffer, _BufferCount, _MaxCount, _Format, _Locale, _ArgList);
; 1581 : 
; 1582 :         return _Result < 0 ? -1 : _Result;

  0005d	83 7c 24 40 00	 cmp	 DWORD PTR _Result$[rsp], 0
  00062	7d 0a		 jge	 SHORT $LN3@vsnprintf_
  00064	c7 44 24 44 ff
	ff ff ff	 mov	 DWORD PTR tv74[rsp], -1
  0006c	eb 08		 jmp	 SHORT $LN4@vsnprintf_
$LN3@vsnprintf_:
  0006e	8b 44 24 40	 mov	 eax, DWORD PTR _Result$[rsp]
  00072	89 44 24 44	 mov	 DWORD PTR tv74[rsp], eax
$LN4@vsnprintf_:
  00076	8b 44 24 44	 mov	 eax, DWORD PTR tv74[rsp]

; 1583 :     }

  0007a	48 83 c4 58	 add	 rsp, 88			; 00000058H
  0007e	c3		 ret	 0
_vsnprintf_s_l ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files (x86)\Windows Kits\10\include\10.0.22000.0\ucrt\corecrt_stdio_config.h
;	COMDAT __local_stdio_printf_options
_TEXT	SEGMENT
__local_stdio_printf_options PROC			; COMDAT

; 91   :         static unsigned __int64 _OptionsStorage;
; 92   :         return &_OptionsStorage;

  00000	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:?_OptionsStorage@?1??__local_stdio_printf_options@@9@9 ; `__local_stdio_printf_options'::`2'::_OptionsStorage

; 93   :     }

  00007	c3		 ret	 0
__local_stdio_printf_options ENDP
_TEXT	ENDS
END
