; Listing generated by Microsoft (R) Optimizing Compiler Version 19.34.31937.0 

include listing.inc

INCLUDELIB MSVCRTD
INCLUDELIB OLDNAMES

PUBLIC	twelvehex00
PUBLIC	cvol_low_key
PUBLIC	infolvl
_BSS	SEGMENT
twelvehex00 DB	0cH DUP (?)
_BSS	ENDS
_DATA	SEGMENT
cvol_low_key DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	01H
infolvl	DD	01H
$SG162014 DB	'DUMP', 00H
	ORG $+7
$SG162015 DB	'IMAGELIB', 00H
	ORG $+7
$SG162016 DB	'LINKLIB', 00H
$SG162017 DB	'NUCLEUS', 00H
$SG162018 DB	'PARMLIB', 00H
$SG162019 DB	'PROCLIB', 00H
$SG162020 DB	'SAMPLIB', 00H
$SG162021 DB	'SYSJOBQE', 00H
_DATA	ENDS
CONST	SEGMENT
CKD_ENDTRK DB	0ffH
	DB	0ffH
	DB	0ffH
	DB	0ffH
	DB	0ffH
	DB	0ffH
	DB	0ffH
	DB	0ffH
VOL1_KEYA DB	056H
	DB	04fH
	DB	04cH
	DB	031H
VOL1_KEY DB	0e5H
	DB	0d6H
	DB	0d3H
	DB	0f1H
IPL1_KEY DB	0c9H
	DB	0d7H
	DB	0d3H
	DB	0f1H
IPL2_KEY DB	0c9H
	DB	0d7H
	DB	0d3H
	DB	0f2H
iplpsw	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
iplccw1	DB	06H
	DB	00H
	DB	03aH
	DB	098H
	DB	060H
	DB	00H
	DB	00H
	DB	060H
iplccw2	DB	08H
	DB	00H
	DB	03aH
	DB	098H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
noiplpsw DB	00H
	DB	02H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	0fH
noiplccw1 DB	03H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	01H
noiplccw2 DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
ipl2data DB	07H
	DB	00H
	DB	03aH
	DB	0b8H
	DB	040H
	DB	00H
	DB	00H
	DB	06H
	DB	031H
	DB	00H
	DB	03aH
	DB	0beH
	DB	040H
	DB	00H
	DB	00H
	DB	05H
	DB	08H
	DB	00H
	DB	03aH
	DB	0a0H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	06H
	DB	00H
	DB	00H
	DB	00H
	DB	020H
	DB	00H
	DB	07fH
	DB	0ffH
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	04H
CONST	ENDS
PUBLIC	__local_stdio_printf_options
PUBLIC	__local_stdio_scanf_options
PUBLIC	_vfprintf_l
PUBLIC	vprintf
PUBLIC	printf
PUBLIC	_vsnprintf_l
PUBLIC	_vsprintf_l
PUBLIC	sprintf
PUBLIC	_vsscanf_l
PUBLIC	sscanf
PUBLIC	fetch_hw_noswap
PUBLIC	store_hw_noswap
PUBLIC	store_fw_noswap
PUBLIC	main
EXTRN	__imp_isprint:PROC
EXTRN	__imp__errno:PROC
EXTRN	strcmp:PROC
EXTRN	strcpy:PROC
EXTRN	__imp__stricmp:PROC
EXTRN	strlen:PROC
EXTRN	__imp_strncpy:PROC
EXTRN	__imp_free:PROC
EXTRN	__imp_malloc:PROC
EXTRN	__imp_exit:PROC
EXTRN	_byteswap_ushort:PROC
EXTRN	_byteswap_ulong:PROC
EXTRN	__imp_close:PROC
EXTRN	__imp_read:PROC
EXTRN	__imp___acrt_iob_func:PROC
EXTRN	__imp_feof:PROC
EXTRN	__imp_fgets:PROC
EXTRN	__imp_fopen:PROC
EXTRN	__imp__ftelli64:PROC
EXTRN	__imp___stdio_common_vfprintf:PROC
EXTRN	__imp___stdio_common_vsprintf:PROC
EXTRN	__imp___stdio_common_vsscanf:PROC
EXTRN	__imp__localtime64:PROC
EXTRN	__imp__time64:PROC
EXTRN	__imp__fstat64:PROC
EXTRN	__imp_strlcat:PROC
EXTRN	__imp_initialize_utility:PROC
EXTRN	__imp_rtrim:PROC
EXTRN	__imp_string_to_upper:PROC
EXTRN	__imp_convert_to_ebcdic:PROC
EXTRN	__imp_make_asciiz:PROC
EXTRN	__imp_w32_strerror:PROC
EXTRN	__imp_strtok_r:PROC
EXTRN	__imp_hostpath:PROC
EXTRN	__imp_w32_snprintf:PROC
EXTRN	__imp_w32_fprintf:PROC
EXTRN	__imp_w32_fclose:PROC
EXTRN	__imp_w32_hopen:PROC
EXTRN	__imp_guest_to_host:PROC
EXTRN	__imp_dasd_lookup:PROC
EXTRN	__imp_fwritemsg:PROC
EXTRN	__imp_build_vol1:PROC
EXTRN	__imp_data_dump:PROC
EXTRN	__imp_read_track:PROC
EXTRN	__imp_open_ckd64_image:PROC
EXTRN	__imp_close_ckd_image:PROC
EXTRN	__imp_capacity_calc:PROC
EXTRN	__imp_create_ckd64:PROC
EXTRN	__GSHandlerCheck:PROC
EXTRN	__chkstk:PROC
EXTRN	__security_check_cookie:PROC
EXTRN	memcmp:PROC
EXTRN	__imp_extgui:DWORD
EXTRN	__imp_cckdblk:BYTE
EXTRN	__ImageBase:BYTE
EXTRN	__security_cookie:QWORD
_DATA	SEGMENT
COMM	?_OptionsStorage@?1??__local_stdio_printf_options@@9@9:QWORD							; `__local_stdio_printf_options'::`2'::_OptionsStorage
COMM	?_OptionsStorage@?1??__local_stdio_scanf_options@@9@9:QWORD							; `__local_stdio_scanf_options'::`2'::_OptionsStorage
_DATA	ENDS
_BSS	SEGMENT
$SG160475 DB	01H DUP (?)
	ALIGN	4

?name@?1??dsorg_name@@9@9 DB 08H DUP (?)		; `dsorg_name'::`2'::name
?name@?1??recfm_name@@9@9 DB 08H DUP (?)		; `recfm_name'::`2'::name
$SG161150 DB	01H DUP (?)
	ALIGN	4

$SG161158 DB	01H DUP (?)
	ALIGN	4

$SG161172 DB	01H DUP (?)
	ALIGN	4

?stmtno@?1??read_ctrl_stmt@@9@9 DD 01H DUP (?)		; `read_ctrl_stmt'::`2'::stmtno
$SG162617 DB	01H DUP (?)
_BSS	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$_vfprintf_l DD imagerel $LN3
	DD	imagerel $LN3+68
	DD	imagerel $unwind$_vfprintf_l
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$vprintf DD imagerel $LN3
	DD	imagerel $LN3+51
	DD	imagerel $unwind$vprintf
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$printf DD imagerel $LN3
	DD	imagerel $LN3+88
	DD	imagerel $unwind$printf
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$_vsnprintf_l DD imagerel $LN5
	DD	imagerel $LN5+118
	DD	imagerel $unwind$_vsnprintf_l
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$_vsprintf_l DD imagerel $LN3
	DD	imagerel $LN3+66
	DD	imagerel $unwind$_vsprintf_l
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$sprintf DD imagerel $LN3
	DD	imagerel $LN3+79
	DD	imagerel $unwind$sprintf
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$_vsscanf_l DD imagerel $LN3
	DD	imagerel $LN3+80
	DD	imagerel $unwind$_vsscanf_l
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$sscanf DD imagerel $LN3
	DD	imagerel $LN3+79
	DD	imagerel $unwind$sscanf
pdata	ENDS
pdata	SEGMENT
$pdata$localtime DD imagerel localtime
	DD	imagerel localtime+25
	DD	imagerel $unwind$localtime
$pdata$time DD	imagerel time
	DD	imagerel time+25
	DD	imagerel $unwind$time
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$fetch_hw_noswap DD imagerel $LN3
	DD	imagerel $LN3+30
	DD	imagerel $unwind$fetch_hw_noswap
pdata	ENDS
pdata	SEGMENT
$pdata$argexit DD imagerel argexit
	DD	imagerel argexit+206
	DD	imagerel $unwind$argexit
$pdata$info_msg DD imagerel info_msg
	DD	imagerel info_msg+65
	DD	imagerel $unwind$info_msg
$pdata$make_int DD imagerel make_int
	DD	imagerel make_int+93
	DD	imagerel $unwind$make_int
$pdata$dsorg_name DD imagerel dsorg_name
	DD	imagerel dsorg_name+259
	DD	imagerel $unwind$dsorg_name
$pdata$recfm_name DD imagerel recfm_name
	DD	imagerel recfm_name+393
	DD	imagerel $unwind$recfm_name
$pdata$dasd_name DD imagerel dasd_name
	DD	imagerel dasd_name+356
	DD	imagerel $unwind$dasd_name
$pdata$ucbtype_code DD imagerel ucbtype_code
	DD	imagerel ucbtype_code+329
	DD	imagerel $unwind$ucbtype_code
$pdata$calculate_ttr DD imagerel calculate_ttr
	DD	imagerel calculate_ttr+385
	DD	imagerel $unwind$calculate_ttr
$pdata$read_ipl_text DD imagerel read_ipl_text
	DD	imagerel read_ipl_text+799
	DD	imagerel $unwind$read_ipl_text
$pdata$init_track DD imagerel init_track
	DD	imagerel init_track+268
	DD	imagerel $unwind$init_track
$pdata$write_track DD imagerel write_track
	DD	imagerel write_track+252
	DD	imagerel $unwind$write_track
$pdata$write_block DD imagerel write_block
	DD	imagerel write_block+1468
	DD	imagerel $unwind$write_block
$pdata$write_track_zero DD imagerel write_track_zero
	DD	imagerel write_track_zero+2016
	DD	imagerel $unwind$write_track_zero
$pdata$update_block DD imagerel update_block
	DD	imagerel update_block+1214
	DD	imagerel $unwind$update_block
$pdata$build_format1_dscb DD imagerel build_format1_dscb
	DD	imagerel build_format1_dscb+1131
	DD	imagerel $unwind$build_format1_dscb
$pdata$build_format4_dscb DD imagerel build_format4_dscb
	DD	imagerel build_format4_dscb+1099
	DD	imagerel $unwind$build_format4_dscb
$pdata$build_format5_dscb DD imagerel build_format5_dscb
	DD	imagerel build_format5_dscb+240
	DD	imagerel $unwind$build_format5_dscb
$pdata$write_vtoc DD imagerel write_vtoc
	DD	imagerel write_vtoc+3133
	DD	imagerel $unwind$write_vtoc
$pdata$tu_name DD imagerel tu_name
	DD	imagerel tu_name+726
	DD	imagerel $unwind$tu_name
$pdata$next_tu DD imagerel next_tu
	DD	imagerel next_tu+1196
	DD	imagerel $unwind$next_tu
$pdata$read_xmit_rec DD imagerel read_xmit_rec
	DD	imagerel read_xmit_rec+701
	DD	imagerel $unwind$read_xmit_rec
$pdata$read_vs_rec DD imagerel read_vs_rec
	DD	imagerel read_vs_rec+602
	DD	imagerel $unwind$read_vs_rec
$pdata$process_inmr02 DD imagerel process_inmr02
	DD	imagerel process_inmr02+1618
	DD	imagerel $unwind$process_inmr02
$pdata$process_inmrxx DD imagerel process_inmrxx
	DD	imagerel process_inmrxx+244
	DD	imagerel $unwind$process_inmrxx
$pdata$process_copyr1 DD imagerel process_copyr1
	DD	imagerel process_copyr1+712
	DD	imagerel $unwind$process_copyr1
$pdata$process_copyr2 DD imagerel process_copyr2
	DD	imagerel process_copyr2+839
	DD	imagerel $unwind$process_copyr2
$pdata$process_dirblk DD imagerel process_dirblk
	DD	imagerel process_dirblk+1433
	DD	imagerel $unwind$process_dirblk
$pdata$replace_ttr DD imagerel replace_ttr
	DD	imagerel replace_ttr+516
	DD	imagerel $unwind$replace_ttr
$pdata$update_note_list DD imagerel update_note_list
	DD	imagerel update_note_list+1606
	DD	imagerel $unwind$update_note_list
$pdata$update_dirblk DD imagerel update_dirblk
	DD	imagerel update_dirblk+744
	DD	imagerel $unwind$update_dirblk
$pdata$process_iebcopy_file DD imagerel process_iebcopy_file
	DD	imagerel process_iebcopy_file+4413
	DD	imagerel $unwind$process_iebcopy_file
$pdata$cvol_initialize DD imagerel cvol_initialize
	DD	imagerel cvol_initialize+3465
	DD	imagerel $unwind$cvol_initialize
$pdata$dip_initialize DD imagerel dip_initialize
	DD	imagerel dip_initialize+1940
	DD	imagerel $unwind$dip_initialize
$pdata$seq_initialize DD imagerel seq_initialize
	DD	imagerel seq_initialize+1963
	DD	imagerel $unwind$seq_initialize
$pdata$empty_initialize DD imagerel empty_initialize
	DD	imagerel empty_initialize+1092
	DD	imagerel $unwind$empty_initialize
$pdata$read_ctrl_stmt DD imagerel read_ctrl_stmt
	DD	imagerel read_ctrl_stmt+627
	DD	imagerel $unwind$read_ctrl_stmt
$pdata$parse_ctrl_stmt DD imagerel parse_ctrl_stmt
	DD	imagerel parse_ctrl_stmt+2287
	DD	imagerel $unwind$parse_ctrl_stmt
$pdata$process_control_file DD imagerel process_control_file
	DD	imagerel process_control_file+4132
	DD	imagerel $unwind$process_control_file
$pdata$main DD	imagerel $LN50
	DD	imagerel $LN50+2878
	DD	imagerel $unwind$main
pdata	ENDS
_DATA	SEGMENT
	ORG $+7
$SG160473 DB	'  -z     compress using zlib [default]', 0aH, 00H
$SG160474 DB	'HHC02496I   -bz2   compress using bzip2', 0aH, 00H
	ORG $+3
$SG160478 DB	'I', 00H
	ORG $+2
$SG160477 DB	'HHC02496I   -lfs   create single large output file', 0aH
	DB	00H
	ORG $+4
$SG160479 DB	'HHC02496%s Usage: %s [options] ctlfile outfile [n]', 0aH
	DB	'HHC02496I options:', 0aH, 'HHC02496I   -0     no compression '
	DB	'(default)', 0aH, 'HHC02496I   -a     output disk will include'
	DB	' alternate cylinders', 0aH, 'HHC02496I   -b     make wait PSW'
	DB	' in IPL1 record a BC-mode PSW', 0aH, 'HHC02496I          (def'
	DB	'ault is EC-mode PSW)', 0aH, 'HHC02496I   -m     enable wait P'
	DB	'SW in IPL1 record for machine checks', 0aH, 'HHC02496I       '
	DB	'   (default is disabled for machine checks)', 0aH, 'HHC02496I'
	DB	' %s%s%sHHC02496I', 0aH, 'HHC02496I ctlfile  name of input con'
	DB	'trol file', 0aH, 'HHC02496I outfile  name of DASD image file '
	DB	'to be created', 0aH, 'HHC02496I n        msglevel ''n'' is a '
	DB	'digit 0 - 5 indicating output verbosity', 0aH, 00H
$SG160510 DB	'IS', 00H
	ORG $+1
$SG160480 DB	'argexit', 00H
$SG160481 DB	'dasdload64.c', 00H
	ORG $+3
$SG160513 DB	'PS', 00H
	ORG $+1
$SG160516 DB	'DA', 00H
	ORG $+1
$SG160518 DB	'PO', 00H
	ORG $+1
$SG160520 DB	'U', 00H
	ORG $+2
$SG160532 DB	'V', 00H
	ORG $+2
$SG160534 DB	'F', 00H
	ORG $+2
$SG160536 DB	'U', 00H
	ORG $+2
$SG160538 DB	'??', 00H
	ORG $+1
$SG160540 DB	'T', 00H
	ORG $+2
$SG160542 DB	'B', 00H
	ORG $+2
$SG160544 DB	'S', 00H
	ORG $+2
$SG160546 DB	'A', 00H
	ORG $+2
$SG160548 DB	'M', 00H
	ORG $+2
$SG160556 DB	'????', 00H
	ORG $+3
$SG160558 DB	'2311', 00H
	ORG $+3
$SG160560 DB	'2301', 00H
	ORG $+3
$SG160562 DB	'2303', 00H
	ORG $+3
$SG160566 DB	'2302', 00H
	ORG $+3
$SG160567 DB	'9345', 00H
	ORG $+3
$SG160569 DB	'2321', 00H
	ORG $+3
$SG160571 DB	'2305-1', 00H
	ORG $+1
$SG160573 DB	'2305-2', 00H
	ORG $+1
$SG160575 DB	'2314', 00H
	ORG $+3
$SG160577 DB	'3330', 00H
	ORG $+3
$SG160579 DB	'3340', 00H
	ORG $+3
$SG160581 DB	'3350', 00H
	ORG $+3
$SG160583 DB	'3375', 00H
	ORG $+3
$SG160633 DB	'E', 00H
	ORG $+2
$SG160585 DB	'3330-11', 00H
$SG160587 DB	'3380', 00H
	ORG $+3
$SG160589 DB	'3390', 00H
	ORG $+3
$SG160590 DB	'????', 00H
	ORG $+3
$SG160634 DB	'HHC02505%s CCHH[%04X%04X] not found in extent table', 0aH
	DB	00H
	ORG $+3
$SG160653 DB	'open', 00H
	ORG $+3
$SG160654 DB	'E', 00H
	ORG $+2
$SG160658 DB	'E', 00H
	ORG $+2
$SG160655 DB	'HHC02506%s Cannot %s file %s; error %s', 0aH, 00H
$SG160657 DB	'read', 00H
	ORG $+3
$SG160659 DB	'HHC02506%s Cannot %s file %s; error %s', 0aH, 00H
$SG160661 DB	'E', 00H
	ORG $+2
$SG160664 DB	0c5H, 0d5H, 0c4H, 00H
$SG160662 DB	'HHC02507%s File %s: invalid object file', 0aH, 00H
	ORG $+3
$SG160666 DB	0e3H, 0e7H, 0e3H, 00H
$SG160667 DB	'I', 00H
	ORG $+2
$SG160670 DB	'E', 00H
	ORG $+2
$SG160668 DB	'HHC02522%s IPL text address=%06X length=%04X', 0aH, 00H
	ORG $+2
$SG160671 DB	'HHC02508%s File %s: TXT record has invalid count of %d', 0aH
	DB	00H
$SG160673 DB	'E', 00H
	ORG $+2
$SG160808 DB	'E', 00H
	ORG $+2
$SG160674 DB	'HHC02509%s File %s: IPL text exceeds %d bytes', 0aH, 00H
	ORG $+1
$SG160809 DB	'HHC02510%s Input record CCHHR[%02X%02X%02X%02X%02X] exce'
	DB	'eds output device track size', 0aH, 00H
	ORG $+2
$SG160811 DB	'E', 00H
	ORG $+2
$SG160815 DB	'E', 00H
	ORG $+2
$SG160812 DB	'HHC02511%s Dataset exceeds extent size: reltrk=%d, maxtr'
	DB	'k=%d', 0aH, 00H
	ORG $+2
$SG160816 DB	'HHC02512%s Input record CCHHR[%02X%02X%02X%02X%02X] exce'
	DB	'eds virtual device track size', 0aH, 00H
	ORG $+1
$SG160872 DB	00H, 00H, 00H, 00H, 00H, 01H, 00H
	ORG $+1
$SG160873 DB	00H, 00H, 00H, 01H, 01H, 00H
	ORG $+2
$SG160875 DB	'** HERCULES **', 00H
	ORG $+1
$SG160932 DB	'E', 00H
	ORG $+2
$SG160936 DB	'E', 00H
	ORG $+2
$SG160933 DB	'HHC02513%s File %s: read error at cyl[%04X/%d] head[%04X'
	DB	'/%d]', 0aH, 00H
	ORG $+2
$SG160937 DB	'HHC02514%s File %s: cyl[%04X/%d] head[%04X/%d]; invalid '
	DB	'track header %02X%02X%02X%02X%02X', 0aH, 00H
	ORG $+1
$SG160939 DB	'E', 00H
	ORG $+2
$SG160940 DB	'HHC02515%s File %s: cyl[%04X/%d] head[%04X/%d] rec[%02X/'
	DB	'%d] record not found', 0aH, 00H
	ORG $+2
$SG160944 DB	'E', 00H
	ORG $+2
$SG160947 DB	'E', 00H
	ORG $+2
$SG161007 DB	'HHC02517%s Error obtaining storage for %sDSCB: %s', 0aH, 00H
	ORG $+5
$SG160945 DB	'HHC02516%s File %s: cyl[%04X/%d] head[%04X/%d] rec[%02X/'
	DB	'%d] unmatched KL/DL', 0aH, 00H
	ORG $+3
$SG160948 DB	'HHC02513%s File %s: read error at cyl[%04X/%d] head[%04X'
	DB	'/%d]', 0aH, 00H
	ORG $+2
$SG160949 DB	'I', 00H
	ORG $+2
$SG161006 DB	'E', 00H
	ORG $+2
$SG161055 DB	'HHC02517%s Error obtaining storage for %sDSCB: %s', 0aH, 00H
	ORG $+5
$SG160950 DB	'HHC02523%s Updating cyl[%04X/%d] head[%04X/%d] rec[%02X/'
	DB	'%d]; kl[%d] dl[%d]', 0aH, 00H
$SG161009 DB	'E', 00H
	ORG $+2
$SG161005 DB	'Format 1 ', 00H
	ORG $+2
$SG161054 DB	'E', 00H
	ORG $+2
$SG161010 DB	'HHC02518%s Internal error: DSCB count exceeds MAXDSCB of'
	DB	' %d', 0aH, 00H
	ORG $+3
$SG161011 DB	'HERCULES', 00H
	ORG $+3
$SG161057 DB	'E', 00H
	ORG $+2
$SG161053 DB	'Format 4 ', 00H
	ORG $+2
$SG161074 DB	'E', 00H
	ORG $+2
$SG161058 DB	'HHC02518%s Internal error: DSCB count exceeds MAXDSCB of'
	DB	' %d', 0aH, 00H
	ORG $+3
$SG161073 DB	'Format 5 ', 00H
	ORG $+2
$SG161077 DB	'E', 00H
	ORG $+2
$SG161075 DB	'HHC02517%s Error obtaining storage for %sDSCB: %s', 0aH, 00H
	ORG $+1
$SG161151 DB	's', 00H
	ORG $+2
$SG161078 DB	'HHC02518%s Internal error: DSCB count exceeds MAXDSCB of'
	DB	' %d', 0aH, 00H
	ORG $+3
$SG161152 DB	'E', 00H
	ORG $+6
$SG161153 DB	'HHC02519%s VTOC requires %d track%s; current allocation '
	DB	'is too small', 0aH, 00H
	ORG $+2
$SG161155 DB	'VTOC', 00H
	ORG $+3
$SG161156 DB	'E', 00H
	ORG $+2
$SG161159 DB	's', 00H
	ORG $+2
$SG161157 DB	'HHC02530%s Error reading %s at cyl[%04X/%d] head[%04X/%d'
	DB	']', 0aH, 00H
	ORG $+1
$SG161160 DB	'I', 00H
	ORG $+2
$SG161179 DB	'track', 00H
	ORG $+2
$SG161161 DB	'HHC02524%s VTOC starts at cyl[%04X/%d] head[%04X/%d] and'
	DB	' is %d track%s', 0aH, 00H
$SG161168 DB	'I', 00H
	ORG $+6
$SG161169 DB	'HHC02525%s Format %d DSCB CCHHR[%04X%04X%02X] (TTR[%04X%'
	DB	'02X]) %s', 0aH, 00H
	ORG $+2
$SG161173 DB	'I', 00H
	ORG $+2
$SG161195 DB	'INMDIR', 00H
	ORG $+1
$SG161174 DB	'HHC02525%s Format %d DSCB CCHHR[%04X%04X%02X] (TTR[%04X%'
	DB	'02X]) %s', 0aH, 00H
	ORG $+2
$SG161180 DB	'E', 00H
	ORG $+2
$SG161181 DB	'HHC02530%s Error reading %s at cyl[%04X/%d] head[%04X/%d'
	DB	']', 0aH, 00H
	ORG $+1
$SG161283 DB	'E', 00H
	ORG $+2
$SG161189 DB	'INMDDNAM', 00H
	ORG $+3
$SG161241 DB	'INMFFM', 00H
	ORG $+1
$SG161285 DB	'I', 00H
	ORG $+2
$SG161191 DB	'INMDSNAM', 00H
	ORG $+3
$SG161288 DB	0aH, 00H
	ORG $+2
$SG161193 DB	'INMMEMBR', 00H
	ORG $+3
$SG161289 DB	'E', 00H
	ORG $+2
$SG161197 DB	'INMEXPDT', 00H
	ORG $+3
$SG161292 DB	0aH, 00H
	ORG $+2
$SG161199 DB	'INMTERM', 00H
$SG161201 DB	'INMBLKSZ', 00H
	ORG $+3
$SG161293 DB	'E', 00H
	ORG $+2
$SG161203 DB	'INMDSORG', 00H
	ORG $+3
$SG161296 DB	0aH, 00H
	ORG $+2
$SG161205 DB	'INMLRECL', 00H
	ORG $+3
$SG161297 DB	'E', 00H
	ORG $+2
$SG161207 DB	'INMRECFM', 00H
	ORG $+3
$SG161300 DB	0aH, 09H, 09H, 09H, 09H, ' ', 00H
	ORG $+1
$SG161307 DB	0aH, 00H
	ORG $+2
$SG161209 DB	'INMTNODE', 00H
	ORG $+3
$SG161301 DB	'%04X ', 00H
	ORG $+2
$SG161329 DB	'E', 00H
	ORG $+2
$SG161211 DB	'INMTUID', 00H
$SG161213 DB	'INMFNODE', 00H
	ORG $+3
$SG161304 DB	'%2.2X', 00H
	ORG $+2
$SG161333 DB	'E', 00H
	ORG $+2
$SG161215 DB	'INMFUID', 00H
$SG161217 DB	'INMLREF', 00H
$SG161219 DB	'INMLCHG', 00H
$SG161221 DB	'INMCREAT', 00H
	ORG $+3
$SG161337 DB	'E', 00H
	ORG $+2
$SG161223 DB	'INMFVERS', 00H
	ORG $+3
$SG161341 DB	'E', 00H
	ORG $+2
$SG161225 DB	'INMFTIME', 00H
	ORG $+3
$SG161344 DB	'E', 00H
	ORG $+2
$SG161227 DB	'INMTTIME', 00H
	ORG $+3
$SG161348 DB	'E', 00H
	ORG $+2
$SG161229 DB	'INMFACK', 00H
$SG161231 DB	'INMERRCD', 00H
	ORG $+3
$SG161372 DB	'E', 00H
	ORG $+2
$SG161233 DB	'INMUTILN', 00H
	ORG $+3
$SG161378 DB	'E', 00H
	ORG $+2
$SG161235 DB	'INMUSERP', 00H
	ORG $+3
$SG161383 DB	'E', 00H
	ORG $+2
$SG161237 DB	'INMRECCT', 00H
	ORG $+3
$SG161387 DB	'E', 00H
	ORG $+2
$SG161239 DB	'INMSIZE', 00H
$SG161243 DB	'INMNUMF', 00H
$SG161245 DB	'INMTYPE', 00H
$SG161246 DB	'????????', 00H
	ORG $+3
$SG161440 DB	'I', 00H
	ORG $+2
$SG161284 DB	'HHC02531%s Incomplete text unit', 0aH, 00H
	ORG $+3
$SG161443 DB	'E', 00H
	ORG $+2
$SG161286 DB	'HHC02526%s ', 09H, '+%04X %-8.8s %04X %04X', 00H
	ORG $+1
$SG161458 DB	'I', 00H
	ORG $+2
$SG161290 DB	'HHC02532%s Too many fields in text unit', 0aH, 00H
	ORG $+3
$SG161460 DB	'I', 00H
	ORG $+2
$SG161294 DB	'HHC02531%s Incomplete text unit', 0aH, 00H
	ORG $+3
$SG161478 DB	'E', 00H
	ORG $+2
$SG161298 DB	'HHC02531%s Incomplete text unit', 0aH, 00H
	ORG $+3
$SG161496 DB	'E', 00H
	ORG $+2
$SG161303 DB	'%-16.16s %-8.8s', 0aH, 09H, 09H, 09H, 09H, '      ', 00H
	ORG $+1
$SG161499 DB	0caH, 'm', 0fH, 00H
$SG161306 DB	'%-16.16s %-8.8s', 00H
$SG161328 DB	'Unexpected end of file', 00H
	ORG $+1
$SG161330 DB	'HHC02533%s File %s: read error: %s', 0aH, 00H
$SG161500 DB	'E', 00H
	ORG $+2
$SG161334 DB	'HHC02534%s File %s: invalid segment header: %02X%02X', 0aH
	DB	00H
	ORG $+2
$SG161338 DB	'HHC02535%s File %s: first segment indicator expected', 0aH
	DB	00H
	ORG $+2
$SG161342 DB	'HHC02536%s File %s: first segment indicator not expected'
	DB	0aH, 00H
	ORG $+2
$SG161503 DB	'E', 00H
	ORG $+2
$SG161345 DB	'HHC02537%s File %s: control record indicator mismatch', 0aH
	DB	00H
	ORG $+1
$SG161347 DB	'Unexpected end of file', 00H
	ORG $+1
$SG161349 DB	'HHC02533%s File %s: read error: %s', 0aH, 00H
$SG161505 DB	'I', 00H
	ORG $+2
$SG161371 DB	'Unexpected end of file', 00H
	ORG $+1
$SG161373 DB	'HHC02533%s File %s: read error: %s', 0aH, 00H
$SG161507 DB	'I', 00H
	ORG $+2
$SG161377 DB	'Unexpected end of file', 00H
	ORG $+1
$SG161379 DB	'HHC02533%s File %s: read error: %s', 0aH, 00H
$SG161509 DB	'I', 00H
	ORG $+2
$SG161382 DB	'Unexpected end of file', 00H
	ORG $+1
$SG161384 DB	'HHC02533%s File %s: read error: %s', 0aH, 00H
$SG161528 DB	'E', 00H
	ORG $+2
$SG161386 DB	'Unexpected end of file', 00H
	ORG $+1
$SG161388 DB	'HHC02533%s File %s: read error: %s', 0aH, 00H
$SG161532 DB	'E', 00H
	ORG $+2
$SG161441 DB	'HHC02527%s File number: %d', 0aH, 00H
$SG161534 DB	'I', 00H
	ORG $+2
$SG161444 DB	'HHC02538%s Invalid text unit at offset %04X', 0aH, 00H
	ORG $+3
$SG161457 DB	'IEBCOPY', 00H
$SG161459 DB	'HHC02528%s File[%04u]: DSNAME=%s', 0aH, 00H
	ORG $+6
$SG161479 DB	'HHC02538%s Invalid text unit at offset %04X', 0aH, 00H
	ORG $+3
$SG161501 DB	'HHC02540%s COPYR%d header identifier not correct', 0aH, 00H
	ORG $+6
$SG161461 DB	'HHC02529%s             DSORG=%s RECFM=%s LRECL=%d BLKSIZ'
	DB	'E=%d KEYLEN=%d DIRBLKS=%d', 0aH, 00H
	ORG $+1
$SG161576 DB	'I', 00H
	ORG $+2
$SG161497 DB	'HHC02539%s COPYR%d record length is invalid', 0aH, 00H
	ORG $+3
$SG161504 DB	'HHC02541%s COPYR%d unload format is unsupported', 0aH, 00H
	ORG $+7
$SG161506 DB	'HHC02550%s Original dataset: DSORG=%s RECFM=%s LRECL=%d '
	DB	'BLKSIZE=%d KEYLEN=%d', 0aH, 00H
	ORG $+2
$SG161508 DB	'HHC02551%s Dataset was unloaded from device type %02X%02'
	DB	'X%02X%02X (%s)', 0aH, 00H
$SG161510 DB	'HHC02552%s Original device was cyls[%04X/%d], heads[%04X'
	DB	'/%d]', 0aH, 00H
	ORG $+2
$SG161529 DB	'HHC02539%s COPYR%d record length is invalid', 0aH, 00H
	ORG $+3
$SG161533 DB	'HHC02542%s Invalid number of extents %d', 0aH, 00H
	ORG $+7
$SG161577 DB	'HHC02554%s End of directory', 0aH, 00H
	ORG $+3
$SG161579 DB	'E', 00H
	ORG $+6
$SG161535 DB	'HHC02553%s Extent %d: Begin CCHH[%04X%04X] End CCHH[%04X'
	DB	'%04X] Tracks=[%04X/%d]', 0aH, 00H
$SG161580 DB	'HHC02543%s Invalid directory block record length', 0aH, 00H
	ORG $+2
$SG161584 DB	'E', 00H
	ORG $+2
$SG161582 DB	'malloc()', 00H
	ORG $+3
$SG161587 DB	'E', 00H
	ORG $+2
$SG161583 DB	'a directory block', 00H
	ORG $+2
$SG161591 DB	'E', 00H
	ORG $+2
$SG161585 DB	'HHC02544%s Storage allocation for %s using %s failed: %s'
	DB	0aH, 00H
	ORG $+6
$SG161588 DB	'HHC02545%s Internal error: Number of directory blocks ex'
	DB	'ceeds MAXDBLK of %d', 0aH, 00H
	ORG $+3
$SG161592 DB	'HHC02546%s Invalid directory block byte count', 0aH, 00H
	ORG $+1
$SG161594 DB	' Alias', 00H
	ORG $+1
$SG161595 DB	'Member', 00H
	ORG $+1
$SG161596 DB	'I', 00H
	ORG $+2
$SG161627 DB	'I', 00H
	ORG $+2
$SG161597 DB	'HHC02555%s %s %-8.8s TTR[%02X%02X%02X] ', 00H
$SG161599 DB	'Userdata=', 00H
	ORG $+2
$SG161629 DB	'I', 00H
	ORG $+2
$SG161604 DB	'%-16.16s %-8.8s', 0aH, '  ', 00H
	ORG $+1
$SG161688 DB	'I', 00H
	ORG $+2
$SG161605 DB	'%-16.16s %-16.16s %16.16s %-24.24s', 0aH, '  ', 00H
	ORG $+2
$SG161606 DB	'%2.2X', 00H
	ORG $+2
$SG161610 DB	'%-16.16s %-8.8s', 0aH, 00H
	ORG $+3
$SG161691 DB	'E', 00H
	ORG $+2
$SG161611 DB	'%-16.16s %-16.16s %-16.16s %-24.24s', 0aH, 00H
	ORG $+3
$SG161692 DB	'HHC02547%s File %s: read error at cyl[%04X/%d] head[%04X'
	DB	'/%d]', 0aH, 00H
	ORG $+2
$SG161748 DB	'HHC02546%s Invalid directory block byte count', 0aH, 00H
	ORG $+1
$SG161868 DB	'open()', 00H
	ORG $+1
$SG161628 DB	'HHC02556%s Member %s TTR[%02X%02X%02X] replaced by TTR[%'
	DB	'02X%02X%02X]', 0aH, 00H
	ORG $+2
$SG161630 DB	'HHC02557%s Member %s TTR[%02X%02X%02X] not found in data'
	DB	'set', 0aH, 00H
	ORG $+3
$SG161695 DB	'E', 00H
	ORG $+6
$SG161689 DB	'HHC02558%s Member %s Updating note list for member at TT'
	DB	'R[%04X%02X] CCHHR[%04X%04X%02X]', 0aH, 00H
	ORG $+7
$SG161696 DB	'HHC02548%s File %s: cyl[%04X/%d] head[%04X/%d] invalid t'
	DB	'rack header %02X%02X%02X%02X%02X', 0aH, 00H
	ORG $+2
$SG161698 DB	'E', 00H
	ORG $+2
$SG161699 DB	'HHC02549%s File %s: cyl[%04X/%d] head[%04X/%d] rec[%02X/'
	DB	'%d] note list record not found', 0aH, 00H
$SG161702 DB	'E', 00H
	ORG $+6
$SG161703 DB	'HHC02559%s Member %s Note list at cyl[%04X/%d] head[%04X'
	DB	'/%d] rec[%02X/%d] dlen[%d] is too short for %d TTRs', 0aH, 00H
	ORG $+3
$SG161706 DB	'E', 00H
	ORG $+2
$SG161708 DB	'I', 00H
	ORG $+2
$SG161707 DB	'HHC02547%s File %s: read error at cyl[%04X/%d] head[%04X'
	DB	'/%d]', 0aH, 00H
	ORG $+2
$SG161870 DB	'HHC02468%s File %s; %s error: %s', 0aH, 00H
	ORG $+6
$SG161709 DB	'HHC02523%s Updating cyl[%04X/%d] head[%04X/%d] rec[%02X/'
	DB	'%d]; kl[%d] dl[%d]', 0aH, 00H
$SG161747 DB	'E', 00H
	ORG $+2
$SG161869 DB	'E', 00H
	ORG $+2
$SG161874 DB	'E', 00H
	ORG $+2
$SG161872 DB	'malloc()', 00H
	ORG $+3
$SG161879 DB	'E', 00H
	ORG $+2
$SG161873 DB	'input buffer', 00H
	ORG $+3
$SG161875 DB	'HHC02544%s Storage allocation for %s using %s failed: %s'
	DB	0aH, 00H
	ORG $+2
$SG161884 DB	'E', 00H
	ORG $+2
$SG161877 DB	'malloc()', 00H
	ORG $+3
$SG161886 DB	'I', 00H
	ORG $+2
$SG161878 DB	'directory block array', 00H
	ORG $+2
$SG161880 DB	'HHC02544%s Storage allocation for %s using %s failed: %s'
	DB	0aH, 00H
	ORG $+2
$SG161895 DB	'I', 00H
	ORG $+2
$SG161882 DB	'malloc()', 00H
	ORG $+3
$SG161898 DB	'INMR06', 00H
	ORG $+1
$SG161908 DB	'I', 00H
	ORG $+2
$SG161883 DB	'TTR table', 00H
	ORG $+2
$SG161901 DB	'INMR02', 00H
	ORG $+1
$SG161910 DB	'I', 00H
	ORG $+2
$SG161885 DB	'HHC02544%s Storage allocation for %s using %s failed: %s'
	DB	0aH, 00H
	ORG $+2
$SG161905 DB	'INMR03', 00H
	ORG $+1
$SG161921 DB	'E', 00H
	ORG $+2
$SG161887 DB	'HHC02560%s File %s: Processing', 0aH, 00H
$SG161896 DB	'HHC02561%s Control record: %s len[%d]', 0aH, 00H
	ORG $+1
$SG161906 DB	'(selected)', 00H
	ORG $+1
$SG161923 DB	'I', 00H
	ORG $+2
$SG161907 DB	'(not selected)', 00H
	ORG $+1
$SG161909 DB	'HHC02562%s File number:    %d %s', 0aH, 00H
	ORG $+2
$SG161930 DB	'E', 00H
	ORG $+2
$SG161911 DB	'HHC02563%s Data record:    len[%d]', 0aH, 00H
$SG161933 DB	'W', 00H
	ORG $+2
$SG161920 DB	'write_block()', 00H
	ORG $+2
$SG161922 DB	'HHC02570%s File %s: %s error: input record CCHHR[%04X%04'
	DB	'X%02X] (TTR[%04X%02X]) kl[%d] dl[%d]', 0aH, 00H
	ORG $+2
$SG161924 DB	'HHC02564%s Input record:   CCHHR[%04X%04X%02X] (TTR[%04X'
	DB	'%02X]) kl[%d] dl[%d]', 0aH, 'HHC02564I relocated to:   CCHHR['
	DB	'%04X%04X%02X] (TTR[%04X%02X])', 0aH, 00H
$SG162024 DB	'I', 00H
	ORG $+2
$SG161931 DB	'HHC02571%s Internal error: TTR count exceeds MAXTTR of %'
	DB	'd', 0aH, 00H
	ORG $+5
$SG161934 DB	'HHC02572%s File %s: XMIT utility file is not in IEBCOPY '
	DB	'format; file is not loaded', 0aH, 00H
$SG162022 DB	'SYS1', 00H
	ORG $+7
?sys1name@?1??cvol_initialize@@9@9 DQ FLAT:$SG162014	; `cvol_initialize'::`2'::sys1name
	DQ	FLAT:$SG162015
	DQ	FLAT:$SG162016
	DQ	FLAT:$SG162017
	DQ	FLAT:$SG162018
	DQ	FLAT:$SG162019
	DQ	FLAT:$SG162020
	DQ	FLAT:$SG162021
$SG162025 DB	'HHC02565%s Catalog block:  cyl[%04X/%d] head[%04X/%d] re'
	DB	'c[%02X/%d]', 0aH, 00H
$SG162028 DB	'I', 00H
	ORG $+2
$SG162178 DB	'open()', 00H
	ORG $+1
$SG162029 DB	'HHC02565%s Catalog block:  cyl[%04X/%d] head[%04X/%d] re'
	DB	'c[%02X/%d]', 0aH, 00H
$SG162032 DB	'I', 00H
	ORG $+2
$SG162180 DB	'HHC02468%s File %s; %s error: %s', 0aH, 00H
	ORG $+6
$SG162033 DB	'HHC02565%s Catalog block:  cyl[%04X/%d] head[%04X/%d] re'
	DB	'c[%02X/%d]', 0aH, 00H
$SG162103 DB	'I', 00H
	ORG $+2
$SG162182 DB	'fstat()', 00H
$SG162104 DB	'HHC02566%s DIP complete:   cyl[%04X/%d] head[%04X/%d] re'
	DB	'c[%02X/%d]', 0aH, 00H
$SG162163 DB	'E', 00H
	ORG $+2
$SG162184 DB	'HHC02468%s File %s; %s error: %s', 0aH, 00H
	ORG $+6
$SG162164 DB	'HHC02573%s File %s: invalid dsorg[0x%02X] for SEQ proces'
	DB	'sing; dsorg must be PS or DA', 0aH, 00H
	ORG $+2
$SG162166 DB	'E', 00H
	ORG $+6
$SG162167 DB	'HHC02574%s File %s: invalid recfm[0x%02X] for SEQ proces'
	DB	'sing; recfm must be F or FB', 0aH, 00H
	ORG $+3
$SG162172 DB	'E', 00H
	ORG $+6
$SG162173 DB	'HHC02575%s File %s: invalid lrecl[%d] or blksize[%d] for'
	DB	' SEQ processing', 0aH, 00H
	ORG $+3
$SG162175 DB	'E', 00H
	ORG $+2
$SG162176 DB	'HHC02576%s File %s: invalid keyln[%d] for SEQ processing'
	DB	'; keyln must be 0 for blocked', 0aH, 00H
	ORG $+1
$SG162179 DB	'E', 00H
	ORG $+2
$SG162183 DB	'E', 00H
	ORG $+2
$SG162186 DB	'E', 00H
	ORG $+2
$SG162189 DB	'read()', 00H
	ORG $+1
$SG162190 DB	'E', 00H
	ORG $+2
$SG162187 DB	'HHC02547%s File %s: read error at cyl[%04X/%d] head[%04X'
	DB	'/%d]', 0aH, 00H
	ORG $+2
$SG162191 DB	'HHC02468%s File %s; %s error: %s', 0aH, 00H
	ORG $+2
$SG162277 DB	'E', 00H
	ORG $+2
$SG162276 DB	'line[%d] fgets()', 00H
	ORG $+3
$SG162284 DB	'E', 00H
	ORG $+2
$SG162278 DB	'HHC02468%s File %s; %s error: %s', 0aH, 00H
	ORG $+2
$SG162286 DB	' ', 09H, 0aH, 0bH, 0cH, 0dH, 00H
	ORG $+1
$SG162287 DB	'I', 00H
	ORG $+2
$SG162280 DB	'IPOS=%lld', 0aH, 00H
	ORG $+1
$SG162360 DB	' ', 09H, 00H
	ORG $+1
$SG162285 DB	'HHC02577%s File %s: line[%04d] error: line length is inv'
	DB	'alid', 0aH, 00H
	ORG $+2
$SG162288 DB	'HHC02567%s File %s[%04d]: %s', 0aH, 00H
	ORG $+2
$SG162361 DB	' ', 09H, 00H
	ORG $+1
$SG162365 DB	'DSNAME', 00H
	ORG $+1
$SG162366 DB	'E', 00H
	ORG $+2
$SG162367 DB	'HHC02578%s %s missing', 0aH, 00H
	ORG $+1
$SG162369 DB	'Initialization method', 00H
	ORG $+2
$SG162370 DB	'E', 00H
	ORG $+2
$SG162377 DB	'VS', 00H
	ORG $+1
$SG162371 DB	'HHC02578%s %s missing', 0aH, 00H
	ORG $+1
$SG162374 DB	'XMIT', 00H
	ORG $+3
$SG162380 DB	'EMPTY', 00H
	ORG $+2
$SG162383 DB	'DIP', 00H
$SG162386 DB	'CVOL', 00H
	ORG $+3
$SG162389 DB	'VTOC', 00H
	ORG $+3
$SG162392 DB	'SEQ', 00H
$SG162393 DB	'E', 00H
	ORG $+2
$SG162397 DB	' ', 09H, 00H
	ORG $+1
$SG162394 DB	'HHC02579%s Initialization method %s is invalid', 0aH, 00H
$SG162399 DB	'E', 00H
	ORG $+2
$SG162401 DB	' ', 09H, 00H
	ORG $+1
$SG162400 DB	'HHC02580%s Initialization file name missing', 0aH, 00H
	ORG $+3
$SG162405 DB	'CYL', 00H
$SG162408 DB	'TRK', 00H
$SG162409 DB	'E', 00H
	ORG $+2
$SG162411 DB	' ', 09H, 00H
	ORG $+1
$SG162410 DB	'HHC02581%s Unit of allocation %s is invalid', 0aH, 00H
	ORG $+3
$SG162414 DB	'%u%c', 00H
	ORG $+3
$SG162415 DB	'Primary', 00H
$SG162416 DB	'E', 00H
	ORG $+2
$SG162418 DB	' ', 09H, 00H
	ORG $+1
$SG162417 DB	'HHC02582%s %s allocation of %s %sS is invalid', 0aH, 00H
	ORG $+1
$SG162421 DB	'%u%c', 00H
	ORG $+3
$SG162422 DB	'Secondary', 00H
	ORG $+2
$SG162423 DB	'E', 00H
	ORG $+2
$SG162424 DB	'HHC02582%s %s allocation of %s %sS is invalid', 0aH, 00H
	ORG $+1
$SG162425 DB	' ', 09H, 00H
	ORG $+1
$SG162428 DB	'%u%c', 00H
	ORG $+3
$SG162429 DB	'E', 00H
	ORG $+2
$SG162430 DB	'HHC02583%s Directory space %s is invalid', 0aH, 00H
	ORG $+2
$SG162431 DB	' ', 09H, 00H
	ORG $+1
$SG162435 DB	'IS', 00H
	ORG $+1
$SG162438 DB	'PS', 00H
	ORG $+1
$SG162441 DB	'DA', 00H
	ORG $+1
$SG162444 DB	'PO', 00H
	ORG $+1
$SG162445 DB	'E', 00H
	ORG $+2
$SG162447 DB	' ', 09H, 00H
	ORG $+1
$SG162446 DB	'HHC02584%s Dataset organization (DSORG) %s is invalid', 0aH
	DB	00H
	ORG $+1
$SG162451 DB	'F', 00H
	ORG $+2
$SG162454 DB	'FB', 00H
	ORG $+1
$SG162457 DB	'FBS', 00H
$SG162460 DB	'V', 00H
	ORG $+2
$SG162463 DB	'VB', 00H
	ORG $+1
$SG162466 DB	'VBS', 00H
$SG162469 DB	'U', 00H
	ORG $+2
$SG162470 DB	'E', 00H
	ORG $+2
$SG162471 DB	'HHC02585%s Record format (RECFM) %s is invalid', 0aH, 00H
$SG162472 DB	' ', 09H, 00H
	ORG $+1
$SG162476 DB	'%u%c', 00H
	ORG $+3
$SG162477 DB	'E', 00H
	ORG $+2
$SG162478 DB	'HHC02586%s Logical record length (LRECL) %s is invalid', 0aH
	DB	00H
$SG162479 DB	' ', 09H, 00H
	ORG $+1
$SG162483 DB	'%u%c', 00H
	ORG $+3
$SG162484 DB	'E', 00H
	ORG $+2
$SG162485 DB	'HHC02587%s Block size (BLKSIZE) %s is invalid', 0aH, 00H
	ORG $+1
$SG162486 DB	' ', 09H, 00H
	ORG $+1
$SG162490 DB	'%u%c', 00H
	ORG $+3
$SG162491 DB	'E', 00H
	ORG $+2
$SG162492 DB	'HHC02588%s Key Length (KEYLEN) %s is invalid', 0aH, 00H
	ORG $+2
$SG162587 DB	'malloc()', 00H
	ORG $+3
$SG162589 DB	'E', 00H
	ORG $+2
$SG162588 DB	'DSCB pointer array', 00H
	ORG $+1
$SG162596 DB	'E', 00H
	ORG $+2
$SG162590 DB	'HHC02544%s Storage allocation for %s using %s failed: %s'
	DB	0aH, 00H
	ORG $+2
$SG162599 DB	'I', 00H
	ORG $+2
$SG162597 DB	'HHC02569%s File %s: line[%04d] error: statement is inval'
	DB	'id', 0aH, 00H
$SG162618 DB	's', 00H
	ORG $+2
$SG162626 DB	'****FREE SPACE****', 00H
	ORG $+5
$SG162600 DB	'HHC02568%s Creating dataset %-44s at cyl[%04X/%d] head[%'
	DB	'04X/%d]', 0aH, 00H
	ORG $+3
$SG162619 DB	'I', 00H
	ORG $+2
$SG162620 DB	'HHC02589%s Dataset %-44s contains %d track%s', 0aH, 00H
	ORG $+2
$SG162627 DB	'I', 00H
	ORG $+6
$SG162628 DB	'HHC02568%s Creating dataset %-44s at cyl[%04X/%d] head[%'
	DB	'04X/%d]', 0aH, 00H
	ORG $+3
$SG162634 DB	'W', 00H
	ORG $+2
$SG162631 DB	'OUTCYL=%d', 0aH, 00H
	ORG $+1
$SG162636 DB	'I', 00H
	ORG $+2
$SG162635 DB	'HHC02590%s Volume exceeds %d cylinders', 0aH, 00H
$SG162637 DB	'HHC02591%s File %s: total cylinders written was %d', 0aH
	DB	00H
$SG162638 DB	'I', 00H
	ORG $+2
$SG162639 DB	'HHC02592%s VTOC pointer [%02X%02X%02X%02X%02X] updated', 0aH
	DB	00H
$SG162641 DB	'E', 00H
	ORG $+2
$SG162710 DB	'0', 00H
	ORG $+2
$SG162642 DB	'HHC02593%s VOL1 record not readable or locatable', 0aH, 00H
	ORG $+2
$SG162713 DB	'z', 00H
	ORG $+2
$SG162706 DB	'Build 64-bit DASD from TSO XMIT files', 00H
	ORG $+2
$SG162707 DB	'dasdload64', 00H
	ORG $+1
$SG162716 DB	'bz2', 00H
$SG162719 DB	'a', 00H
	ORG $+2
$SG162722 DB	'lfs', 00H
$SG162725 DB	'b', 00H
	ORG $+2
$SG162728 DB	'm', 00H
	ORG $+2
$SG162738 DB	'%u%c', 00H
	ORG $+3
$SG162739 DB	'r', 00H
	ORG $+2
$SG162742 DB	'E', 00H
	ORG $+2
$SG162741 DB	'fopen()', 00H
$SG162743 DB	'HHC02468%s File %s; %s error: %s', 0aH, 00H
	ORG $+2
$SG162746 DB	'E', 00H
	ORG $+2
$SG162747 DB	'HHC02500%s Volume serial statement missing from %s', 0aH
	DB	00H
$SG162748 DB	' ', 09H, 00H
	ORG $+1
$SG162749 DB	' ', 09H, 00H
	ORG $+1
$SG162750 DB	' ', 09H, 00H
	ORG $+1
$SG162751 DB	' ', 09H, 00H
	ORG $+1
$SG162754 DB	'E', 00H
	ORG $+2
$SG162755 DB	'HHC02501%s Volume serial %s is invalid; %s line %d', 0aH
	DB	00H
$SG162757 DB	'E', 00H
	ORG $+2
$SG162758 DB	'HHC02502%s Device type %s is not recognized; %s line %d', 0aH
	DB	00H
	ORG $+3
$SG162761 DB	'*', 00H
	ORG $+2
$SG162763 DB	'%u%c', 00H
	ORG $+3
$SG162764 DB	'E', 00H
	ORG $+2
$SG162767 DB	'I', 00H
	ORG $+2
$SG162765 DB	'HHC02503%s Cylinder value %s is invalid; %s line %d', 0aH
	DB	00H
	ORG $+3
$SG162768 DB	'HHC02520%s Creating %4.4X volume %s: %u trks/cyl, %u byt'
	DB	'es/track', 0aH, 00H
	ORG $+2
$SG162773 DB	'E', 00H
	ORG $+2
$SG162770 DB	'REQCYLS=%d', 0aH, 00H
$SG162777 DB	'E', 00H
	ORG $+2
$SG162772 DB	'create_ckd64()', 00H
	ORG $+1
$SG162774 DB	'HHC02504%s Cannot create %s; %s failed', 0aH, 00H
$SG162776 DB	'open_ckd64_image()', 00H
	ORG $+1
$SG162780 DB	'E', 00H
	ORG $+2
$SG162778 DB	'HHC02504%s Cannot create %s; %s failed', 0aH, 00H
$SG162781 DB	'HHC02424%s Dasd image file format unsupported or unrecog'
	DB	'nized: %s', 0aH, 00H
	ORG $+1
$SG162783 DB	'I', 00H
	ORG $+2
$SG162784 DB	'HHC02521%s Loading %4.4X volume %s', 0aH, 00H
_DATA	ENDS
voltbl	SEGMENT
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:main
	DD	01aH
	DD	0b26H
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:process_control_file
	DD	027H
	DD	0febH
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:read_ctrl_stmt
	DD	025H
	DD	025bH
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:empty_initialize
	DD	02dH
	DD	042bH
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:seq_initialize
	DD	02dH
	DD	0792H
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:dip_initialize
	DD	02dH
	DD	077bH
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:cvol_initialize
	DD	02dH
	DD	0d70H
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:process_iebcopy_file
	DD	026H
	DD	01125H
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:update_dirblk
	DD	025H
	DD	02d0H
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:update_note_list
	DD	027H
	DD	062cH
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:process_dirblk
	DD	026H
	DD	057fH
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:process_inmrxx
	DD	01aH
	DD	0dcH
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:process_inmr02
	DD	026H
	DD	0638H
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:next_tu
	DD	025H
	DD	0493H
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:write_vtoc
	DD	025H
	DD	0c24H
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:update_block
	DD	027H
	DD	04a4H
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:write_track_zero
	DD	02eH
	DD	07c6H
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:read_ipl_text
	DD	022H
	DD	0305H
voltbl	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$fetch_hw_noswap DD 010901H
	DD	02209H
xdata	ENDS
xdata	SEGMENT
$unwind$localtime DD 010901H
	DD	04209H
$unwind$time DD	010901H
	DD	04209H
$unwind$argexit DD 021001H
	DD	0110110H
$unwind$info_msg DD 011701H
	DD	06217H
$unwind$make_int DD 010d01H
	DD	0220dH
$unwind$dsorg_name DD 010901H
	DD	04209H
$unwind$recfm_name DD 010901H
	DD	06209H
$unwind$dasd_name DD 010901H
	DD	02209H
$unwind$ucbtype_code DD 010901H
	DD	02209H
$unwind$calculate_ttr DD 011601H
	DD	06216H
$unwind$read_ipl_text DD 042a19H
	DD	0390118H
	DD	060107011H
	DD	imagerel __GSHandlerCheck
	DD	01b0H
$unwind$init_track DD 021801H
	DD	070147218H
$unwind$write_track DD 011801H
	DD	06218H
$unwind$write_block DD 041d01H
	DD	015011dH
	DD	060157016H
$unwind$write_track_zero DD 043619H
	DD	0101b0124H
	DD	060167017H
	DD	imagerel __GSHandlerCheck
	DD	080c0H
$unwind$update_block DD 042f19H
	DD	015011dH
	DD	060157016H
	DD	imagerel __GSHandlerCheck
	DD	090H
$unwind$build_format1_dscb DD 021801H
	DD	07014b218H
$unwind$build_format4_dscb DD 031601H
	DD	01a0116H
	DD	0700fH
$unwind$build_format5_dscb DD 020e01H
	DD	0700a720eH
$unwind$write_vtoc DD 032d19H
	DD	040011bH
	DD	07014H
	DD	imagerel __GSHandlerCheck
	DD	01f0H
$unwind$tu_name DD 010901H
	DD	02209H
$unwind$next_tu DD 032d19H
	DD	014011bH
	DD	07014H
	DD	imagerel __GSHandlerCheck
	DD	090H
$unwind$read_xmit_rec DD 011701H
	DD	0c217H
$unwind$read_vs_rec DD 011701H
	DD	0a217H
$unwind$process_inmr02 DD 042e19H
	DD	037011cH
	DD	060147015H
	DD	imagerel __GSHandlerCheck
	DD	01a8H
$unwind$process_inmrxx DD 022219H
	DD	0270110H
	DD	imagerel __GSHandlerCheck
	DD	0128H
$unwind$process_copyr1 DD 010d01H
	DD	0e20dH
$unwind$process_copyr2 DD 011201H
	DD	0c212H
$unwind$process_dirblk DD 042e19H
	DD	01f011cH
	DD	060147015H
	DD	imagerel __GSHandlerCheck
	DD	0e8H
$unwind$replace_ttr DD 031a01H
	DD	07016c21aH
	DD	06015H
$unwind$update_note_list DD 042f19H
	DD	099011dH
	DD	060157016H
	DD	imagerel __GSHandlerCheck
	DD	04b0H
$unwind$update_dirblk DD 022d19H
	DD	015011bH
	DD	imagerel __GSHandlerCheck
	DD	098H
$unwind$process_iebcopy_file DD 022e19H
	DD	063011cH
	DD	imagerel __GSHandlerCheck
	DD	0300H
$unwind$cvol_initialize DD 033519H
	DD	010200123H
	DD	07016H
	DD	imagerel __GSHandlerCheck
	DD	080f0H
$unwind$dip_initialize DD 033519H
	DD	0101e0123H
	DD	07016H
	DD	imagerel __GSHandlerCheck
	DD	080e0H
$unwind$seq_initialize DD 033519H
	DD	010440123H
	DD	07016H
	DD	imagerel __GSHandlerCheck
	DD	08210H
$unwind$empty_initialize DD 033519H
	DD	0101c0123H
	DD	07016H
	DD	imagerel __GSHandlerCheck
	DD	080d0H
$unwind$read_ctrl_stmt DD 022d19H
	DD	013011bH
	DD	imagerel __GSHandlerCheck
	DD	080H
$unwind$parse_ctrl_stmt DD 031c01H
	DD	014011cH
	DD	07015H
$unwind$process_control_file DD 042f19H
	DD	053011dH
	DD	060157016H
	DD	imagerel __GSHandlerCheck
	DD	0280H
$unwind$main DD	022219H
	DD	0690110H
	DD	imagerel __GSHandlerCheck
	DD	0330H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$sscanf DD 011801H
	DD	06218H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$_vsscanf_l DD 011801H
	DD	06218H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$sprintf DD 011801H
	DD	06218H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$_vsprintf_l DD 011801H
	DD	06218H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$_vsnprintf_l DD 011801H
	DD	08218H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$printf DD 011801H
	DD	06218H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$vprintf DD 010e01H
	DD	0420eH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$_vfprintf_l DD 011801H
	DD	06218H
xdata	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\dasdload64.c
_TEXT	SEGMENT
comp$ = 112
devtype$ = 116
rc$ = 120
c$ = 124
outtrklv$ = 128
reqcyls$ = 132
volser$ = 136
outheads$ = 144
cfname$ = 152
stmtno$ = 160
devcyls$ = 164
ofname$ = 168
ckd$ = 176
cif$ = 184
altcylflag$ = 192
tv315 = 196
lfs$ = 200
outmaxdl$ = 204
flagMachinecheck$ = 208
flagECmode$ = 212
pgm$ = 216
strtok_str$ = 224
sdevsz$ = 232
cfp$ = 240
outhead$ = 248
outcyl$ = 252
sdevtp$ = 256
reltrk$ = 264
iplfnm$ = 272
stmt$ = 288
pathname$ = 544
__$ArrayPad$ = 816
argc$ = 848
argv$ = 856
main	PROC

; 4216 : {

$LN50:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	89 4c 24 08	 mov	 DWORD PTR [rsp+8], ecx
  00009	48 81 ec 48 03
	00 00		 sub	 rsp, 840		; 00000348H
  00010	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00017	48 33 c4	 xor	 rax, rsp
  0001a	48 89 84 24 30
	03 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 4217 : char           *pgm;                    /* less any extension (.ext) */
; 4218 : int             rc = 0;                 /* Return code               */

  00022	c7 44 24 78 00
	00 00 00	 mov	 DWORD PTR rc$[rsp], 0

; 4219 : char           *cfname;                 /* -> Control file name      */
; 4220 : char           *ofname;                 /* -> Output file name       */
; 4221 : FILE           *cfp;                    /* Control file pointer      */
; 4222 : CIFBLK         *cif;                    /* -> CKD image block        */
; 4223 : CKDDEV         *ckd;                    /* -> CKD table entry        */
; 4224 : char           *volser;                 /* -> Volume serial (ASCIIZ) */
; 4225 : char           *sdevtp;                 /* -> Device type (ASCIIZ)   */
; 4226 : char           *sdevsz;                 /* -> Device size (ASCIIZ)   */
; 4227 : char           *iplfnm;                 /* -> IPL text file or NULL  */
; 4228 : BYTE            c;                      /* Character work area       */
; 4229 : U16             devtype;                /* Output device type        */
; 4230 : int             devcyls;                /* Default device size (cyls)*/
; 4231 : int             reqcyls;                /* Requested device size (cyls)
; 4232 :                                            or 0 = use minimum size   */
; 4233 : int             outheads;               /* Output device trks/cyl    */
; 4234 : int             outmaxdl;               /* Output device maximum size
; 4235 :                                            record data length value  */
; 4236 : int             outtrklv;               /* Output device track length
; 4237 :                                            of virtual device         */
; 4238 : int             reltrk;                 /* Output track number       */
; 4239 : int             outcyl;                 /* Output cylinder number    */
; 4240 : int             outhead;                /* Output head number        */
; 4241 : char            stmt[256];              /* Control file statement    */
; 4242 : int             stmtno;                 /* Statement number          */
; 4243 : BYTE            comp = 0xff;            /* Compression algoritm      */

  0002a	c6 44 24 70 ff	 mov	 BYTE PTR comp$[rsp], 255 ; 000000ffH

; 4244 : int             altcylflag = 0;         /* Alternate cylinders flag  */

  0002f	c7 84 24 c0 00
	00 00 00 00 00
	00		 mov	 DWORD PTR altcylflag$[rsp], 0

; 4245 : int             flagECmode = 1;         /* IPL PSW mode flag         */

  0003a	c7 84 24 d4 00
	00 00 01 00 00
	00		 mov	 DWORD PTR flagECmode$[rsp], 1

; 4246 : int             flagMachinecheck = 0;   /* IPL PSW machine check flag*/

  00045	c7 84 24 d0 00
	00 00 00 00 00
	00		 mov	 DWORD PTR flagMachinecheck$[rsp], 0

; 4247 : int             lfs = 0;                /* 1 = Large file            */

  00050	c7 84 24 c8 00
	00 00 00 00 00
	00		 mov	 DWORD PTR lfs$[rsp], 0

; 4248 : char            pathname[MAX_PATH];     /* cfname in host path format*/
; 4249 : char           *strtok_str = NULL;      /* last token position       */

  0005b	48 c7 84 24 e0
	00 00 00 00 00
	00 00		 mov	 QWORD PTR strtok_str$[rsp], 0

; 4250 : 
; 4251 :     INITIALIZE_UTILITY( UTILITY_NAME, UTILITY_DESC, &pgm );

  00067	48 8d 84 24 d8
	00 00 00	 lea	 rax, QWORD PTR pgm$[rsp]
  0006f	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00074	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG162706
  0007b	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG162707
  00082	48 8b 94 24 58
	03 00 00	 mov	 rdx, QWORD PTR argv$[rsp]
  0008a	8b 8c 24 50 03
	00 00		 mov	 ecx, DWORD PTR argc$[rsp]
  00091	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_initialize_utility
  00097	89 84 24 50 03
	00 00		 mov	 DWORD PTR argc$[rsp], eax

; 4252 : 
; 4253 :     /* Process optional arguments */
; 4254 :     for ( ; argc > 1 && argv[1][0] == '-'; argv++, argc--)

  0009e	eb 24		 jmp	 SHORT $LN4@main
$LN2@main:
  000a0	48 8b 84 24 58
	03 00 00	 mov	 rax, QWORD PTR argv$[rsp]
  000a8	48 83 c0 08	 add	 rax, 8
  000ac	48 89 84 24 58
	03 00 00	 mov	 QWORD PTR argv$[rsp], rax
  000b4	8b 84 24 50 03
	00 00		 mov	 eax, DWORD PTR argc$[rsp]
  000bb	ff c8		 dec	 eax
  000bd	89 84 24 50 03
	00 00		 mov	 DWORD PTR argc$[rsp], eax
$LN4@main:
  000c4	83 bc 24 50 03
	00 00 01	 cmp	 DWORD PTR argc$[rsp], 1
  000cc	0f 8e 0a 02 00
	00		 jle	 $LN3@main
  000d2	b8 08 00 00 00	 mov	 eax, 8
  000d7	48 6b c0 01	 imul	 rax, rax, 1
  000db	b9 01 00 00 00	 mov	 ecx, 1
  000e0	48 6b c9 00	 imul	 rcx, rcx, 0
  000e4	48 8b 94 24 58
	03 00 00	 mov	 rdx, QWORD PTR argv$[rsp]
  000ec	48 8b 04 02	 mov	 rax, QWORD PTR [rdx+rax]
  000f0	0f be 04 08	 movsx	 eax, BYTE PTR [rax+rcx]
  000f4	83 f8 2d	 cmp	 eax, 45			; 0000002dH
  000f7	0f 85 df 01 00
	00		 jne	 $LN3@main

; 4255 :     {
; 4256 :         if (strcmp("0", &argv[1][1]) == 0)

  000fd	b8 08 00 00 00	 mov	 eax, 8
  00102	48 6b c0 01	 imul	 rax, rax, 1
  00106	b9 01 00 00 00	 mov	 ecx, 1
  0010b	48 6b c9 01	 imul	 rcx, rcx, 1
  0010f	48 8b 94 24 58
	03 00 00	 mov	 rdx, QWORD PTR argv$[rsp]
  00117	48 03 0c 02	 add	 rcx, QWORD PTR [rdx+rax]
  0011b	48 8b c1	 mov	 rax, rcx
  0011e	48 8b d0	 mov	 rdx, rax
  00121	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG162710
  00128	e8 00 00 00 00	 call	 strcmp
  0012d	85 c0		 test	 eax, eax
  0012f	75 0a		 jne	 SHORT $LN8@main

; 4257 :             comp = CCKD_COMPRESS_NONE;

  00131	c6 44 24 70 00	 mov	 BYTE PTR comp$[rsp], 0
  00136	e9 9c 01 00 00	 jmp	 $LN9@main
$LN8@main:

; 4258 : #ifdef CCKD_COMPRESS_ZLIB
; 4259 :         else if (strcmp("z", &argv[1][1]) == 0)

  0013b	b8 08 00 00 00	 mov	 eax, 8
  00140	48 6b c0 01	 imul	 rax, rax, 1
  00144	b9 01 00 00 00	 mov	 ecx, 1
  00149	48 6b c9 01	 imul	 rcx, rcx, 1
  0014d	48 8b 94 24 58
	03 00 00	 mov	 rdx, QWORD PTR argv$[rsp]
  00155	48 03 0c 02	 add	 rcx, QWORD PTR [rdx+rax]
  00159	48 8b c1	 mov	 rax, rcx
  0015c	48 8b d0	 mov	 rdx, rax
  0015f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG162713
  00166	e8 00 00 00 00	 call	 strcmp
  0016b	85 c0		 test	 eax, eax
  0016d	75 0a		 jne	 SHORT $LN10@main

; 4260 :             comp = CCKD_COMPRESS_ZLIB;

  0016f	c6 44 24 70 01	 mov	 BYTE PTR comp$[rsp], 1
  00174	e9 5e 01 00 00	 jmp	 $LN11@main
$LN10@main:

; 4261 : #endif
; 4262 : #ifdef CCKD_COMPRESS_BZIP2
; 4263 :         else if (strcmp("bz2", &argv[1][1]) == 0)

  00179	b8 08 00 00 00	 mov	 eax, 8
  0017e	48 6b c0 01	 imul	 rax, rax, 1
  00182	b9 01 00 00 00	 mov	 ecx, 1
  00187	48 6b c9 01	 imul	 rcx, rcx, 1
  0018b	48 8b 94 24 58
	03 00 00	 mov	 rdx, QWORD PTR argv$[rsp]
  00193	48 03 0c 02	 add	 rcx, QWORD PTR [rdx+rax]
  00197	48 8b c1	 mov	 rax, rcx
  0019a	48 8b d0	 mov	 rdx, rax
  0019d	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG162716
  001a4	e8 00 00 00 00	 call	 strcmp
  001a9	85 c0		 test	 eax, eax
  001ab	75 0a		 jne	 SHORT $LN12@main

; 4264 :             comp = CCKD_COMPRESS_BZIP2;

  001ad	c6 44 24 70 02	 mov	 BYTE PTR comp$[rsp], 2
  001b2	e9 20 01 00 00	 jmp	 $LN13@main
$LN12@main:

; 4265 : #endif
; 4266 :         else if (strcmp("a", &argv[1][1]) == 0)

  001b7	b8 08 00 00 00	 mov	 eax, 8
  001bc	48 6b c0 01	 imul	 rax, rax, 1
  001c0	b9 01 00 00 00	 mov	 ecx, 1
  001c5	48 6b c9 01	 imul	 rcx, rcx, 1
  001c9	48 8b 94 24 58
	03 00 00	 mov	 rdx, QWORD PTR argv$[rsp]
  001d1	48 03 0c 02	 add	 rcx, QWORD PTR [rdx+rax]
  001d5	48 8b c1	 mov	 rax, rcx
  001d8	48 8b d0	 mov	 rdx, rax
  001db	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG162719
  001e2	e8 00 00 00 00	 call	 strcmp
  001e7	85 c0		 test	 eax, eax
  001e9	75 10		 jne	 SHORT $LN14@main

; 4267 :             altcylflag = 1;

  001eb	c7 84 24 c0 00
	00 00 01 00 00
	00		 mov	 DWORD PTR altcylflag$[rsp], 1
  001f6	e9 dc 00 00 00	 jmp	 $LN15@main
$LN14@main:

; 4268 :         else if (strcmp("lfs", &argv[1][1]) == 0 && sizeof(off_t) > 4)

  001fb	b8 08 00 00 00	 mov	 eax, 8
  00200	48 6b c0 01	 imul	 rax, rax, 1
  00204	b9 01 00 00 00	 mov	 ecx, 1
  00209	48 6b c9 01	 imul	 rcx, rcx, 1
  0020d	48 8b 94 24 58
	03 00 00	 mov	 rdx, QWORD PTR argv$[rsp]
  00215	48 03 0c 02	 add	 rcx, QWORD PTR [rdx+rax]
  00219	48 8b c1	 mov	 rax, rcx
  0021c	48 8b d0	 mov	 rdx, rax
  0021f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG162722
  00226	e8 00 00 00 00	 call	 strcmp
  0022b	85 c0		 test	 eax, eax
  0022d	75 17		 jne	 SHORT $LN16@main
  0022f	33 c0		 xor	 eax, eax
  00231	83 f8 01	 cmp	 eax, 1
  00234	74 10		 je	 SHORT $LN16@main

; 4269 :             lfs = 1;

  00236	c7 84 24 c8 00
	00 00 01 00 00
	00		 mov	 DWORD PTR lfs$[rsp], 1
  00241	e9 91 00 00 00	 jmp	 $LN17@main
$LN16@main:

; 4270 :         else if (strcmp("b", &argv[1][1]) == 0)

  00246	b8 08 00 00 00	 mov	 eax, 8
  0024b	48 6b c0 01	 imul	 rax, rax, 1
  0024f	b9 01 00 00 00	 mov	 ecx, 1
  00254	48 6b c9 01	 imul	 rcx, rcx, 1
  00258	48 8b 94 24 58
	03 00 00	 mov	 rdx, QWORD PTR argv$[rsp]
  00260	48 03 0c 02	 add	 rcx, QWORD PTR [rdx+rax]
  00264	48 8b c1	 mov	 rax, rcx
  00267	48 8b d0	 mov	 rdx, rax
  0026a	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG162725
  00271	e8 00 00 00 00	 call	 strcmp
  00276	85 c0		 test	 eax, eax
  00278	75 0d		 jne	 SHORT $LN18@main

; 4271 :             flagECmode = 0;

  0027a	c7 84 24 d4 00
	00 00 00 00 00
	00		 mov	 DWORD PTR flagECmode$[rsp], 0
  00285	eb 50		 jmp	 SHORT $LN19@main
$LN18@main:

; 4272 :         else if (strcmp("m", &argv[1][1]) == 0)

  00287	b8 08 00 00 00	 mov	 eax, 8
  0028c	48 6b c0 01	 imul	 rax, rax, 1
  00290	b9 01 00 00 00	 mov	 ecx, 1
  00295	48 6b c9 01	 imul	 rcx, rcx, 1
  00299	48 8b 94 24 58
	03 00 00	 mov	 rdx, QWORD PTR argv$[rsp]
  002a1	48 03 0c 02	 add	 rcx, QWORD PTR [rdx+rax]
  002a5	48 8b c1	 mov	 rax, rcx
  002a8	48 8b d0	 mov	 rdx, rax
  002ab	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG162728
  002b2	e8 00 00 00 00	 call	 strcmp
  002b7	85 c0		 test	 eax, eax
  002b9	75 0d		 jne	 SHORT $LN20@main

; 4273 :             flagMachinecheck = 1;

  002bb	c7 84 24 d0 00
	00 00 01 00 00
	00		 mov	 DWORD PTR flagMachinecheck$[rsp], 1
  002c6	eb 0f		 jmp	 SHORT $LN21@main
$LN20@main:

; 4274 :         else argexit(0, pgm);

  002c8	48 8b 94 24 d8
	00 00 00	 mov	 rdx, QWORD PTR pgm$[rsp]
  002d0	33 c9		 xor	 ecx, ecx
  002d2	e8 00 00 00 00	 call	 argexit
$LN21@main:
$LN19@main:
$LN17@main:
$LN15@main:
$LN13@main:
$LN11@main:
$LN9@main:

; 4275 :     }

  002d7	e9 c4 fd ff ff	 jmp	 $LN2@main
$LN3@main:

; 4276 : 
; 4277 :     /* Check the number of arguments */
; 4278 :     if (argc < 3 || argc > 4)

  002dc	83 bc 24 50 03
	00 00 03	 cmp	 DWORD PTR argc$[rsp], 3
  002e4	7c 0a		 jl	 SHORT $LN23@main
  002e6	83 bc 24 50 03
	00 00 04	 cmp	 DWORD PTR argc$[rsp], 4
  002ee	7e 12		 jle	 SHORT $LN22@main
$LN23@main:

; 4279 :         argexit(4, pgm);

  002f0	48 8b 94 24 d8
	00 00 00	 mov	 rdx, QWORD PTR pgm$[rsp]
  002f8	b9 04 00 00 00	 mov	 ecx, 4
  002fd	e8 00 00 00 00	 call	 argexit
$LN22@main:

; 4280 : 
; 4281 :     /* The first argument is the control file name */
; 4282 :     cfname = argv[1];

  00302	b8 08 00 00 00	 mov	 eax, 8
  00307	48 6b c0 01	 imul	 rax, rax, 1
  0030b	48 8b 8c 24 58
	03 00 00	 mov	 rcx, QWORD PTR argv$[rsp]
  00313	48 8b 04 01	 mov	 rax, QWORD PTR [rcx+rax]
  00317	48 89 84 24 98
	00 00 00	 mov	 QWORD PTR cfname$[rsp], rax

; 4283 :     if (argv[1] == NULL || strlen(argv[1]) == 0)

  0031f	b8 08 00 00 00	 mov	 eax, 8
  00324	48 6b c0 01	 imul	 rax, rax, 1
  00328	48 8b 8c 24 58
	03 00 00	 mov	 rcx, QWORD PTR argv$[rsp]
  00330	48 83 3c 01 00	 cmp	 QWORD PTR [rcx+rax], 0
  00335	74 1f		 je	 SHORT $LN25@main
  00337	b8 08 00 00 00	 mov	 eax, 8
  0033c	48 6b c0 01	 imul	 rax, rax, 1
  00340	48 8b 8c 24 58
	03 00 00	 mov	 rcx, QWORD PTR argv$[rsp]
  00348	48 8b 0c 01	 mov	 rcx, QWORD PTR [rcx+rax]
  0034c	e8 00 00 00 00	 call	 strlen
  00351	48 85 c0	 test	 rax, rax
  00354	75 12		 jne	 SHORT $LN24@main
$LN25@main:

; 4284 :         argexit(1, pgm);

  00356	48 8b 94 24 d8
	00 00 00	 mov	 rdx, QWORD PTR pgm$[rsp]
  0035e	b9 01 00 00 00	 mov	 ecx, 1
  00363	e8 00 00 00 00	 call	 argexit
$LN24@main:

; 4285 : 
; 4286 :     /* The second argument is the DASD image file name */
; 4287 :     ofname = argv[2];

  00368	b8 08 00 00 00	 mov	 eax, 8
  0036d	48 6b c0 02	 imul	 rax, rax, 2
  00371	48 8b 8c 24 58
	03 00 00	 mov	 rcx, QWORD PTR argv$[rsp]
  00379	48 8b 04 01	 mov	 rax, QWORD PTR [rcx+rax]
  0037d	48 89 84 24 a8
	00 00 00	 mov	 QWORD PTR ofname$[rsp], rax

; 4288 :     if (argv[2] == NULL || strlen(argv[2]) == 0)

  00385	b8 08 00 00 00	 mov	 eax, 8
  0038a	48 6b c0 02	 imul	 rax, rax, 2
  0038e	48 8b 8c 24 58
	03 00 00	 mov	 rcx, QWORD PTR argv$[rsp]
  00396	48 83 3c 01 00	 cmp	 QWORD PTR [rcx+rax], 0
  0039b	74 1f		 je	 SHORT $LN27@main
  0039d	b8 08 00 00 00	 mov	 eax, 8
  003a2	48 6b c0 02	 imul	 rax, rax, 2
  003a6	48 8b 8c 24 58
	03 00 00	 mov	 rcx, QWORD PTR argv$[rsp]
  003ae	48 8b 0c 01	 mov	 rcx, QWORD PTR [rcx+rax]
  003b2	e8 00 00 00 00	 call	 strlen
  003b7	48 85 c0	 test	 rax, rax
  003ba	75 12		 jne	 SHORT $LN26@main
$LN27@main:

; 4289 :         argexit(2, pgm);

  003bc	48 8b 94 24 d8
	00 00 00	 mov	 rdx, QWORD PTR pgm$[rsp]
  003c4	b9 02 00 00 00	 mov	 ecx, 2
  003c9	e8 00 00 00 00	 call	 argexit
$LN26@main:

; 4290 : 
; 4291 :     /* The optional third argument is the message level */
; 4292 :     if (argc > 3 && argv[3] != NULL)

  003ce	83 bc 24 50 03
	00 00 03	 cmp	 DWORD PTR argc$[rsp], 3
  003d6	7e 65		 jle	 SHORT $LN28@main
  003d8	b8 08 00 00 00	 mov	 eax, 8
  003dd	48 6b c0 03	 imul	 rax, rax, 3
  003e1	48 8b 8c 24 58
	03 00 00	 mov	 rcx, QWORD PTR argv$[rsp]
  003e9	48 83 3c 01 00	 cmp	 QWORD PTR [rcx+rax], 0
  003ee	74 4d		 je	 SHORT $LN28@main

; 4293 :     {
; 4294 :         if (sscanf(argv[3], "%u%c", &infolvl, &c) != 1
; 4295 :             || infolvl > 5)

  003f0	b8 08 00 00 00	 mov	 eax, 8
  003f5	48 6b c0 03	 imul	 rax, rax, 3
  003f9	4c 8d 4c 24 7c	 lea	 r9, QWORD PTR c$[rsp]
  003fe	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:infolvl
  00405	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG162738
  0040c	48 8b 8c 24 58
	03 00 00	 mov	 rcx, QWORD PTR argv$[rsp]
  00414	48 8b 0c 01	 mov	 rcx, QWORD PTR [rcx+rax]
  00418	e8 00 00 00 00	 call	 sscanf
  0041d	83 f8 01	 cmp	 eax, 1
  00420	75 09		 jne	 SHORT $LN30@main
  00422	83 3d 00 00 00
	00 05		 cmp	 DWORD PTR infolvl, 5
  00429	7e 12		 jle	 SHORT $LN29@main
$LN30@main:

; 4296 :             argexit(3, pgm);

  0042b	48 8b 94 24 d8
	00 00 00	 mov	 rdx, QWORD PTR pgm$[rsp]
  00433	b9 03 00 00 00	 mov	 ecx, 3
  00438	e8 00 00 00 00	 call	 argexit
$LN29@main:
$LN28@main:

; 4297 :     }
; 4298 : 
; 4299 :     /* Open the control file */
; 4300 :     hostpath(pathname, cfname, sizeof(pathname));

  0043d	41 b8 04 01 00
	00		 mov	 r8d, 260		; 00000104H
  00443	48 8b 94 24 98
	00 00 00	 mov	 rdx, QWORD PTR cfname$[rsp]
  0044b	48 8d 8c 24 20
	02 00 00	 lea	 rcx, QWORD PTR pathname$[rsp]
  00453	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hostpath

; 4301 :     cfp = fopen (pathname, "r");

  00459	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG162739
  00460	48 8d 8c 24 20
	02 00 00	 lea	 rcx, QWORD PTR pathname$[rsp]
  00468	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fopen
  0046e	48 89 84 24 f0
	00 00 00	 mov	 QWORD PTR cfp$[rsp], rax

; 4302 :     if (cfp == NULL)

  00476	48 83 bc 24 f0
	00 00 00 00	 cmp	 QWORD PTR cfp$[rsp], 0
  0047f	75 3f		 jne	 SHORT $LN31@main

; 4303 :     {
; 4304 :         XMERRF ( MSG( HHC02468, "E", cfname, "fopen()", strerror( errno ) ) );

  00481	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno
  00487	8b 08		 mov	 ecx, DWORD PTR [rax]
  00489	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_strerror
  0048f	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00494	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG162741
  0049b	4c 8b 84 24 98
	00 00 00	 mov	 r8, QWORD PTR cfname$[rsp]
  004a3	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG162742
  004aa	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG162743
  004b1	e8 00 00 00 00	 call	 printf

; 4305 :         return -1;

  004b6	b8 ff ff ff ff	 mov	 eax, -1
  004bb	e9 66 06 00 00	 jmp	 $LN1@main
$LN31@main:

; 4306 :     }
; 4307 : 
; 4308 :     /* Read first statement from control file */
; 4309 :     rc = read_ctrl_stmt (cfp, cfname, stmt, sizeof(stmt), &stmtno);

  004c0	48 8d 84 24 a0
	00 00 00	 lea	 rax, QWORD PTR stmtno$[rsp]
  004c8	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  004cd	41 b9 00 01 00
	00		 mov	 r9d, 256		; 00000100H
  004d3	4c 8d 84 24 20
	01 00 00	 lea	 r8, QWORD PTR stmt$[rsp]
  004db	48 8b 94 24 98
	00 00 00	 mov	 rdx, QWORD PTR cfname$[rsp]
  004e3	48 8b 8c 24 f0
	00 00 00	 mov	 rcx, QWORD PTR cfp$[rsp]
  004eb	e8 00 00 00 00	 call	 read_ctrl_stmt
  004f0	89 44 24 78	 mov	 DWORD PTR rc$[rsp], eax

; 4310 :     if (rc < 0) return -1;

  004f4	83 7c 24 78 00	 cmp	 DWORD PTR rc$[rsp], 0
  004f9	7d 0a		 jge	 SHORT $LN32@main
  004fb	b8 ff ff ff ff	 mov	 eax, -1
  00500	e9 21 06 00 00	 jmp	 $LN1@main
$LN32@main:

; 4311 : 
; 4312 :     /* Error if end of file */
; 4313 :     if (rc > 0)

  00505	83 7c 24 78 00	 cmp	 DWORD PTR rc$[rsp], 0
  0050a	7e 25		 jle	 SHORT $LN33@main

; 4314 :     {
; 4315 :         XMERRF ( MSG( HHC02500, "E", cfname ) );

  0050c	4c 8b 84 24 98
	00 00 00	 mov	 r8, QWORD PTR cfname$[rsp]
  00514	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG162746
  0051b	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG162747
  00522	e8 00 00 00 00	 call	 printf

; 4316 :         return -1;

  00527	b8 ff ff ff ff	 mov	 eax, -1
  0052c	e9 f5 05 00 00	 jmp	 $LN1@main
$LN33@main:

; 4317 :     }
; 4318 : 
; 4319 :     /* Parse the volume serial statement */
; 4320 :     volser = strtok_r (stmt, " \t", &strtok_str);

  00531	4c 8d 84 24 e0
	00 00 00	 lea	 r8, QWORD PTR strtok_str$[rsp]
  00539	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG162748
  00540	48 8d 8c 24 20
	01 00 00	 lea	 rcx, QWORD PTR stmt$[rsp]
  00548	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_strtok_r
  0054e	48 89 84 24 88
	00 00 00	 mov	 QWORD PTR volser$[rsp], rax

; 4321 :     sdevtp = strtok_r (NULL, " \t", &strtok_str);

  00556	4c 8d 84 24 e0
	00 00 00	 lea	 r8, QWORD PTR strtok_str$[rsp]
  0055e	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG162749
  00565	33 c9		 xor	 ecx, ecx
  00567	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_strtok_r
  0056d	48 89 84 24 00
	01 00 00	 mov	 QWORD PTR sdevtp$[rsp], rax

; 4322 :     sdevsz = strtok_r (NULL, " \t", &strtok_str);

  00575	4c 8d 84 24 e0
	00 00 00	 lea	 r8, QWORD PTR strtok_str$[rsp]
  0057d	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG162750
  00584	33 c9		 xor	 ecx, ecx
  00586	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_strtok_r
  0058c	48 89 84 24 e8
	00 00 00	 mov	 QWORD PTR sdevsz$[rsp], rax

; 4323 :     iplfnm = strtok_r (NULL, " \t", &strtok_str);

  00594	4c 8d 84 24 e0
	00 00 00	 lea	 r8, QWORD PTR strtok_str$[rsp]
  0059c	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG162751
  005a3	33 c9		 xor	 ecx, ecx
  005a5	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_strtok_r
  005ab	48 89 84 24 10
	01 00 00	 mov	 QWORD PTR iplfnm$[rsp], rax

; 4324 : 
; 4325 :     /* Validate the volume serial number */
; 4326 :     if (volser == NULL || strlen(volser) == 0 || strlen(volser) > 6)

  005b3	48 83 bc 24 88
	00 00 00 00	 cmp	 QWORD PTR volser$[rsp], 0
  005bc	74 25		 je	 SHORT $LN35@main
  005be	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR volser$[rsp]
  005c6	e8 00 00 00 00	 call	 strlen
  005cb	48 85 c0	 test	 rax, rax
  005ce	74 13		 je	 SHORT $LN35@main
  005d0	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR volser$[rsp]
  005d8	e8 00 00 00 00	 call	 strlen
  005dd	48 83 f8 06	 cmp	 rax, 6
  005e1	76 38		 jbe	 SHORT $LN34@main
$LN35@main:

; 4327 :     {
; 4328 :         XMERRF ( MSG( HHC02501, "E", volser, cfname, stmtno ) );

  005e3	8b 84 24 a0 00
	00 00		 mov	 eax, DWORD PTR stmtno$[rsp]
  005ea	89 44 24 20	 mov	 DWORD PTR [rsp+32], eax
  005ee	4c 8b 8c 24 98
	00 00 00	 mov	 r9, QWORD PTR cfname$[rsp]
  005f6	4c 8b 84 24 88
	00 00 00	 mov	 r8, QWORD PTR volser$[rsp]
  005fe	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG162754
  00605	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG162755
  0060c	e8 00 00 00 00	 call	 printf

; 4329 :         return -1;

  00611	b8 ff ff ff ff	 mov	 eax, -1
  00616	e9 0b 05 00 00	 jmp	 $LN1@main
$LN34@main:

; 4330 :     }
; 4331 :     string_to_upper (volser);

  0061b	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR volser$[rsp]
  00623	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_string_to_upper

; 4332 : 
; 4333 :     /* Validate the device type */
; 4334 :     ckd = dasd_lookup (DASD_CKDDEV, sdevtp, 0, 0);

  00629	45 33 c9	 xor	 r9d, r9d
  0062c	45 33 c0	 xor	 r8d, r8d
  0062f	48 8b 94 24 00
	01 00 00	 mov	 rdx, QWORD PTR sdevtp$[rsp]
  00637	b9 01 00 00 00	 mov	 ecx, 1
  0063c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_dasd_lookup
  00642	48 89 84 24 b0
	00 00 00	 mov	 QWORD PTR ckd$[rsp], rax

; 4335 :     if (ckd == NULL)

  0064a	48 83 bc 24 b0
	00 00 00 00	 cmp	 QWORD PTR ckd$[rsp], 0
  00653	75 38		 jne	 SHORT $LN36@main

; 4336 :     {
; 4337 :         XMERRF ( MSG( HHC02502, "E", sdevtp, cfname, stmtno ) );

  00655	8b 84 24 a0 00
	00 00		 mov	 eax, DWORD PTR stmtno$[rsp]
  0065c	89 44 24 20	 mov	 DWORD PTR [rsp+32], eax
  00660	4c 8b 8c 24 98
	00 00 00	 mov	 r9, QWORD PTR cfname$[rsp]
  00668	4c 8b 84 24 00
	01 00 00	 mov	 r8, QWORD PTR sdevtp$[rsp]
  00670	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG162757
  00677	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG162758
  0067e	e8 00 00 00 00	 call	 printf

; 4338 :         return -1;

  00683	b8 ff ff ff ff	 mov	 eax, -1
  00688	e9 99 04 00 00	 jmp	 $LN1@main
$LN36@main:

; 4339 :     }
; 4340 :     devtype = ckd->devt;

  0068d	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR ckd$[rsp]
  00695	0f b7 40 08	 movzx	 eax, WORD PTR [rax+8]
  00699	66 89 44 24 74	 mov	 WORD PTR devtype$[rsp], ax

; 4341 : 
; 4342 :     /* Obtain number of heads per cylinder, maximum data length per
; 4343 :        track, and default number of cylinders per device */
; 4344 :     outheads = ckd->heads;

  0069e	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR ckd$[rsp]
  006a6	0f b7 40 12	 movzx	 eax, WORD PTR [rax+18]
  006aa	89 84 24 90 00
	00 00		 mov	 DWORD PTR outheads$[rsp], eax

; 4345 :     devcyls = ckd->cyls;

  006b1	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR ckd$[rsp]
  006b9	0f b7 40 0e	 movzx	 eax, WORD PTR [rax+14]
  006bd	89 84 24 a4 00
	00 00		 mov	 DWORD PTR devcyls$[rsp], eax

; 4346 :     if (altcylflag) devcyls += ckd->altcyls;

  006c4	83 bc 24 c0 00
	00 00 00	 cmp	 DWORD PTR altcylflag$[rsp], 0
  006cc	74 1e		 je	 SHORT $LN37@main
  006ce	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR ckd$[rsp]
  006d6	0f b7 40 10	 movzx	 eax, WORD PTR [rax+16]
  006da	8b 8c 24 a4 00
	00 00		 mov	 ecx, DWORD PTR devcyls$[rsp]
  006e1	03 c8		 add	 ecx, eax
  006e3	8b c1		 mov	 eax, ecx
  006e5	89 84 24 a4 00
	00 00		 mov	 DWORD PTR devcyls$[rsp], eax
$LN37@main:

; 4347 :     outmaxdl = ckd->r1;

  006ec	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR ckd$[rsp]
  006f4	0f b7 40 16	 movzx	 eax, WORD PTR [rax+22]
  006f8	89 84 24 cc 00
	00 00		 mov	 DWORD PTR outmaxdl$[rsp], eax

; 4348 : 
; 4349 :     /* Use default device size if requested size is omitted or
; 4350 :        is zero or is "*" */
; 4351 :     reqcyls = 0;

  006ff	c7 84 24 84 00
	00 00 00 00 00
	00		 mov	 DWORD PTR reqcyls$[rsp], 0

; 4352 :     if (sdevsz != NULL && strcmp(sdevsz, "*") != 0)

  0070a	48 83 bc 24 e8
	00 00 00 00	 cmp	 QWORD PTR sdevsz$[rsp], 0
  00713	74 76		 je	 SHORT $LN38@main
  00715	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG162761
  0071c	48 8b 8c 24 e8
	00 00 00	 mov	 rcx, QWORD PTR sdevsz$[rsp]
  00724	e8 00 00 00 00	 call	 strcmp
  00729	85 c0		 test	 eax, eax
  0072b	74 5e		 je	 SHORT $LN38@main

; 4353 :     {
; 4354 :         /* Validate the requested device size in cylinders */
; 4355 :         if (sscanf(sdevsz, "%u%c", &reqcyls, &c) != 1)

  0072d	4c 8d 4c 24 7c	 lea	 r9, QWORD PTR c$[rsp]
  00732	4c 8d 84 24 84
	00 00 00	 lea	 r8, QWORD PTR reqcyls$[rsp]
  0073a	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG162763
  00741	48 8b 8c 24 e8
	00 00 00	 mov	 rcx, QWORD PTR sdevsz$[rsp]
  00749	e8 00 00 00 00	 call	 sscanf
  0074e	83 f8 01	 cmp	 eax, 1
  00751	74 38		 je	 SHORT $LN39@main

; 4356 :         {
; 4357 :             XMERRF ( MSG( HHC02503, "E", sdevsz, cfname, stmtno ) );

  00753	8b 84 24 a0 00
	00 00		 mov	 eax, DWORD PTR stmtno$[rsp]
  0075a	89 44 24 20	 mov	 DWORD PTR [rsp+32], eax
  0075e	4c 8b 8c 24 98
	00 00 00	 mov	 r9, QWORD PTR cfname$[rsp]
  00766	4c 8b 84 24 e8
	00 00 00	 mov	 r8, QWORD PTR sdevsz$[rsp]
  0076e	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG162764
  00775	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG162765
  0077c	e8 00 00 00 00	 call	 printf

; 4358 :             return -1;

  00781	b8 ff ff ff ff	 mov	 eax, -1
  00786	e9 9b 03 00 00	 jmp	 $LN1@main
$LN39@main:
$LN38@main:

; 4359 :         }
; 4360 :     }
; 4361 :     if (reqcyls == 0)

  0078b	83 bc 24 84 00
	00 00 00	 cmp	 DWORD PTR reqcyls$[rsp], 0
  00793	75 0e		 jne	 SHORT $LN40@main

; 4362 :         reqcyls = devcyls;

  00795	8b 84 24 a4 00
	00 00		 mov	 eax, DWORD PTR devcyls$[rsp]
  0079c	89 84 24 84 00
	00 00		 mov	 DWORD PTR reqcyls$[rsp], eax
$LN40@main:

; 4363 : 
; 4364 :     /* Calculate the track size of the virtual device */
; 4365 :     outtrklv = CKD_TRKHDR_SIZE

  007a3	48 63 84 24 cc
	00 00 00	 movsxd	 rax, DWORD PTR outmaxdl$[rsp]
  007ab	48 83 c0 25	 add	 rax, 37			; 00000025H
  007af	89 84 24 80 00
	00 00		 mov	 DWORD PTR outtrklv$[rsp], eax

; 4366 :              + CKD_R0_SIZE     + CKD_R0_DLEN
; 4367 :              + CKD_RECHDR_SIZE + outmaxdl
; 4368 :              + CKD_ENDTRK_SIZE;
; 4369 :     outtrklv = ROUND_UP( outtrklv, 512 );

  007b6	83 bc 24 80 00
	00 00 00	 cmp	 DWORD PTR outtrklv$[rsp], 0
  007be	74 27		 je	 SHORT $LN48@main
  007c0	8b 84 24 80 00
	00 00		 mov	 eax, DWORD PTR outtrklv$[rsp]
  007c7	05 ff 01 00 00	 add	 eax, 511		; 000001ffH
  007cc	99		 cdq
  007cd	81 e2 ff 01 00
	00		 and	 edx, 511		; 000001ffH
  007d3	03 c2		 add	 eax, edx
  007d5	c1 f8 09	 sar	 eax, 9
  007d8	69 c0 00 02 00
	00		 imul	 eax, eax, 512		; 00000200H
  007de	89 84 24 c4 00
	00 00		 mov	 DWORD PTR tv315[rsp], eax
  007e5	eb 0b		 jmp	 SHORT $LN49@main
$LN48@main:
  007e7	c7 84 24 c4 00
	00 00 00 02 00
	00		 mov	 DWORD PTR tv315[rsp], 512 ; 00000200H
$LN49@main:
  007f2	8b 84 24 c4 00
	00 00		 mov	 eax, DWORD PTR tv315[rsp]
  007f9	89 84 24 80 00
	00 00		 mov	 DWORD PTR outtrklv$[rsp], eax

; 4370 : 
; 4371 :     /* Display progress message */
; 4372 :     XMINFF (0, MSG( HHC02520, "I", devtype, volser, outheads, outtrklv ) );

  00800	0f b7 44 24 74	 movzx	 eax, WORD PTR devtype$[rsp]
  00805	8b 8c 24 80 00
	00 00		 mov	 ecx, DWORD PTR outtrklv$[rsp]
  0080c	89 4c 24 30	 mov	 DWORD PTR [rsp+48], ecx
  00810	8b 8c 24 90 00
	00 00		 mov	 ecx, DWORD PTR outheads$[rsp]
  00817	89 4c 24 28	 mov	 DWORD PTR [rsp+40], ecx
  0081b	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR volser$[rsp]
  00823	48 89 4c 24 20	 mov	 QWORD PTR [rsp+32], rcx
  00828	44 8b c8	 mov	 r9d, eax
  0082b	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG162767
  00832	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG162768
  00839	33 c9		 xor	 ecx, ecx
  0083b	e8 00 00 00 00	 call	 info_msg
$LN7@main:

; 4373 : 
; 4374 :     /* Create the output file */
; 4375 :     EXTGUIMSG( "REQCYLS=%d\n", reqcyls );

  00840	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_extgui
  00847	83 38 00	 cmp	 DWORD PTR [rax], 0
  0084a	74 23		 je	 SHORT $LN41@main
  0084c	b9 02 00 00 00	 mov	 ecx, 2
  00851	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  00857	44 8b 84 24 84
	00 00 00	 mov	 r8d, DWORD PTR reqcyls$[rsp]
  0085f	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG162770
  00866	48 8b c8	 mov	 rcx, rax
  00869	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_fprintf
$LN41@main:
  0086f	33 c0		 xor	 eax, eax
  00871	85 c0		 test	 eax, eax
  00873	75 cb		 jne	 SHORT $LN7@main

; 4376 :     rc = create_ckd64( ofname, devtype, outheads, outmaxdl, reqcyls,

  00875	c6 44 24 60 00	 mov	 BYTE PTR [rsp+96], 0
  0087a	c6 44 24 58 01	 mov	 BYTE PTR [rsp+88], 1
  0087f	c6 44 24 50 00	 mov	 BYTE PTR [rsp+80], 0
  00884	c6 44 24 48 00	 mov	 BYTE PTR [rsp+72], 0
  00889	c6 44 24 40 00	 mov	 BYTE PTR [rsp+64], 0
  0088e	0f b6 84 24 c8
	00 00 00	 movzx	 eax, BYTE PTR lfs$[rsp]
  00896	88 44 24 38	 mov	 BYTE PTR [rsp+56], al
  0089a	0f b6 44 24 70	 movzx	 eax, BYTE PTR comp$[rsp]
  0089f	88 44 24 30	 mov	 BYTE PTR [rsp+48], al
  008a3	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR volser$[rsp]
  008ab	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  008b0	8b 84 24 84 00
	00 00		 mov	 eax, DWORD PTR reqcyls$[rsp]
  008b7	89 44 24 20	 mov	 DWORD PTR [rsp+32], eax
  008bb	44 8b 8c 24 cc
	00 00 00	 mov	 r9d, DWORD PTR outmaxdl$[rsp]
  008c3	44 8b 84 24 90
	00 00 00	 mov	 r8d, DWORD PTR outheads$[rsp]
  008cb	0f b7 54 24 74	 movzx	 edx, WORD PTR devtype$[rsp]
  008d0	48 8b 8c 24 a8
	00 00 00	 mov	 rcx, QWORD PTR ofname$[rsp]
  008d8	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_create_ckd64
  008de	89 44 24 78	 mov	 DWORD PTR rc$[rsp], eax

; 4377 :                        volser, comp, (BYTE) lfs, 0, 0, 0, 1, 0 );
; 4378 :     if (rc < 0)

  008e2	83 7c 24 78 00	 cmp	 DWORD PTR rc$[rsp], 0
  008e7	7d 2c		 jge	 SHORT $LN42@main

; 4379 :     {
; 4380 :         XMERRF ( MSG( HHC02504, "E", ofname, "create_ckd64()" ) );

  008e9	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG162772
  008f0	4c 8b 84 24 a8
	00 00 00	 mov	 r8, QWORD PTR ofname$[rsp]
  008f8	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG162773
  008ff	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG162774
  00906	e8 00 00 00 00	 call	 printf

; 4381 :         return -1;

  0090b	b8 ff ff ff ff	 mov	 eax, -1
  00910	e9 11 02 00 00	 jmp	 $LN1@main
$LN42@main:

; 4382 :     }
; 4383 : 
; 4384 :     /* Open the output file */
; 4385 :     cif = open_ckd64_image (ofname, NULL, O_RDWR | O_BINARY, IMAGE_OPEN_NORMAL);

  00915	45 33 c9	 xor	 r9d, r9d
  00918	41 b8 02 80 00
	00		 mov	 r8d, 32770		; 00008002H
  0091e	33 d2		 xor	 edx, edx
  00920	48 8b 8c 24 a8
	00 00 00	 mov	 rcx, QWORD PTR ofname$[rsp]
  00928	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_open_ckd64_image
  0092e	48 89 84 24 b8
	00 00 00	 mov	 QWORD PTR cif$[rsp], rax

; 4386 :     if (!cif)

  00936	48 83 bc 24 b8
	00 00 00 00	 cmp	 QWORD PTR cif$[rsp], 0
  0093f	75 2c		 jne	 SHORT $LN43@main

; 4387 :     {
; 4388 :         XMERRF ( MSG( HHC02504, "E", ofname, "open_ckd64_image()" ) );

  00941	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG162776
  00948	4c 8b 84 24 a8
	00 00 00	 mov	 r8, QWORD PTR ofname$[rsp]
  00950	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG162777
  00957	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG162778
  0095e	e8 00 00 00 00	 call	 printf

; 4389 :         return -1;

  00963	b8 ff ff ff ff	 mov	 eax, -1
  00968	e9 b9 01 00 00	 jmp	 $LN1@main
$LN43@main:

; 4390 :     }
; 4391 : 
; 4392 :     if (cif->devblk.cckd64 != 1)

  0096d	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR cif$[rsp]
  00975	0f b6 80 40 13
	00 00		 movzx	 eax, BYTE PTR [rax+4928]
  0097c	24 01		 and	 al, 1
  0097e	0f b6 c0	 movzx	 eax, al
  00981	83 f8 01	 cmp	 eax, 1
  00984	74 25		 je	 SHORT $LN44@main

; 4393 :     {
; 4394 :         // "Dasd image file format unsupported or unrecognized: %s"
; 4395 :         XMERRF ( MSG( HHC02424, "E", ofname ) );

  00986	4c 8b 84 24 a8
	00 00 00	 mov	 r8, QWORD PTR ofname$[rsp]
  0098e	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG162780
  00995	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG162781
  0099c	e8 00 00 00 00	 call	 printf

; 4396 :         return -1;

  009a1	b8 ff ff ff ff	 mov	 eax, -1
  009a6	e9 7b 01 00 00	 jmp	 $LN1@main
$LN44@main:

; 4397 :     }
; 4398 : 
; 4399 :     if (cif->devblk.cckd_ext)        /* have a compressed ckd extension?  */

  009ab	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR cif$[rsp]
  009b3	48 83 b8 38 13
	00 00 00	 cmp	 QWORD PTR [rax+4920], 0
  009bb	74 10		 je	 SHORT $LN45@main

; 4400 :         cckdblk.batchml = infolvl;   /* yes, save message level in cckdblk for cckddasd   */

  009bd	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_cckdblk
  009c4	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR infolvl
  009ca	89 48 18	 mov	 DWORD PTR [rax+24], ecx
$LN45@main:

; 4401 : 
; 4402 :     /* Display progress message */
; 4403 :     XMINFF (0, MSG( HHC02521, "I", devtype, volser ) );

  009cd	0f b7 44 24 74	 movzx	 eax, WORD PTR devtype$[rsp]
  009d2	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR volser$[rsp]
  009da	48 89 4c 24 20	 mov	 QWORD PTR [rsp+32], rcx
  009df	44 8b c8	 mov	 r9d, eax
  009e2	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG162783
  009e9	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG162784
  009f0	33 c9		 xor	 ecx, ecx
  009f2	e8 00 00 00 00	 call	 info_msg

; 4404 : 
; 4405 :     /* Write track zero to the DASD image file */
; 4406 :     rc = write_track_zero (cif, ofname, volser, devtype,

  009f7	8b 84 24 d0 00
	00 00		 mov	 eax, DWORD PTR flagMachinecheck$[rsp]
  009fe	89 44 24 58	 mov	 DWORD PTR [rsp+88], eax
  00a02	8b 84 24 d4 00
	00 00		 mov	 eax, DWORD PTR flagECmode$[rsp]
  00a09	89 44 24 50	 mov	 DWORD PTR [rsp+80], eax
  00a0d	48 8d 84 24 f8
	00 00 00	 lea	 rax, QWORD PTR outhead$[rsp]
  00a15	48 89 44 24 48	 mov	 QWORD PTR [rsp+72], rax
  00a1a	48 8d 84 24 fc
	00 00 00	 lea	 rax, QWORD PTR outcyl$[rsp]
  00a22	48 89 44 24 40	 mov	 QWORD PTR [rsp+64], rax
  00a27	48 8d 84 24 08
	01 00 00	 lea	 rax, QWORD PTR reltrk$[rsp]
  00a2f	48 89 44 24 38	 mov	 QWORD PTR [rsp+56], rax
  00a34	48 8b 84 24 10
	01 00 00	 mov	 rax, QWORD PTR iplfnm$[rsp]
  00a3c	48 89 44 24 30	 mov	 QWORD PTR [rsp+48], rax
  00a41	8b 84 24 80 00
	00 00		 mov	 eax, DWORD PTR outtrklv$[rsp]
  00a48	89 44 24 28	 mov	 DWORD PTR [rsp+40], eax
  00a4c	8b 84 24 90 00
	00 00		 mov	 eax, DWORD PTR outheads$[rsp]
  00a53	89 44 24 20	 mov	 DWORD PTR [rsp+32], eax
  00a57	44 0f b7 4c 24
	74		 movzx	 r9d, WORD PTR devtype$[rsp]
  00a5d	4c 8b 84 24 88
	00 00 00	 mov	 r8, QWORD PTR volser$[rsp]
  00a65	48 8b 94 24 a8
	00 00 00	 mov	 rdx, QWORD PTR ofname$[rsp]
  00a6d	48 8b 8c 24 b8
	00 00 00	 mov	 rcx, QWORD PTR cif$[rsp]
  00a75	e8 00 00 00 00	 call	 write_track_zero
  00a7a	89 44 24 78	 mov	 DWORD PTR rc$[rsp], eax

; 4407 :                         outheads, outtrklv, iplfnm,
; 4408 :                         &reltrk, &outcyl, &outhead,
; 4409 :                         flagECmode, flagMachinecheck);
; 4410 :     if (rc < 0)

  00a7e	83 7c 24 78 00	 cmp	 DWORD PTR rc$[rsp], 0
  00a83	7d 0a		 jge	 SHORT $LN46@main

; 4411 :         return -1;

  00a85	b8 ff ff ff ff	 mov	 eax, -1
  00a8a	e9 97 00 00 00	 jmp	 $LN1@main
$LN46@main:

; 4412 : 
; 4413 :     /* Process the control file to create the datasets */
; 4414 :     rc = process_control_file (cfp, cfname, ofname, cif, volser,

  00a8f	8b 84 24 f8 00
	00 00		 mov	 eax, DWORD PTR outhead$[rsp]
  00a96	89 44 24 50	 mov	 DWORD PTR [rsp+80], eax
  00a9a	8b 84 24 fc 00
	00 00		 mov	 eax, DWORD PTR outcyl$[rsp]
  00aa1	89 44 24 48	 mov	 DWORD PTR [rsp+72], eax
  00aa5	8b 84 24 80 00
	00 00		 mov	 eax, DWORD PTR outtrklv$[rsp]
  00aac	89 44 24 40	 mov	 DWORD PTR [rsp+64], eax
  00ab0	8b 84 24 90 00
	00 00		 mov	 eax, DWORD PTR outheads$[rsp]
  00ab7	89 44 24 38	 mov	 DWORD PTR [rsp+56], eax
  00abb	8b 84 24 84 00
	00 00		 mov	 eax, DWORD PTR reqcyls$[rsp]
  00ac2	89 44 24 30	 mov	 DWORD PTR [rsp+48], eax
  00ac6	0f b7 44 24 74	 movzx	 eax, WORD PTR devtype$[rsp]
  00acb	66 89 44 24 28	 mov	 WORD PTR [rsp+40], ax
  00ad0	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR volser$[rsp]
  00ad8	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00add	4c 8b 8c 24 b8
	00 00 00	 mov	 r9, QWORD PTR cif$[rsp]
  00ae5	4c 8b 84 24 a8
	00 00 00	 mov	 r8, QWORD PTR ofname$[rsp]
  00aed	48 8b 94 24 98
	00 00 00	 mov	 rdx, QWORD PTR cfname$[rsp]
  00af5	48 8b 8c 24 f0
	00 00 00	 mov	 rcx, QWORD PTR cfp$[rsp]
  00afd	e8 00 00 00 00	 call	 process_control_file
  00b02	89 44 24 78	 mov	 DWORD PTR rc$[rsp], eax

; 4415 :                         devtype, reqcyls, outheads, outtrklv,
; 4416 :                         outcyl, outhead);
; 4417 : 
; 4418 :     /* Close files and release buffers */
; 4419 :     fclose (cfp);

  00b06	48 8b 8c 24 f0
	00 00 00	 mov	 rcx, QWORD PTR cfp$[rsp]
  00b0e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_fclose

; 4420 :     close_ckd_image (cif);

  00b14	48 8b 8c 24 b8
	00 00 00	 mov	 rcx, QWORD PTR cif$[rsp]
  00b1c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_close_ckd_image

; 4421 : 
; 4422 :     return rc;

  00b22	8b 44 24 78	 mov	 eax, DWORD PTR rc$[rsp]
$LN1@main:

; 4423 : 
; 4424 : } /* end function main */

  00b26	48 8b 8c 24 30
	03 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  00b2e	48 33 cc	 xor	 rcx, rsp
  00b31	e8 00 00 00 00	 call	 __security_check_cookie
  00b36	48 81 c4 48 03
	00 00		 add	 rsp, 840		; 00000348H
  00b3d	c3		 ret	 0
main	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\dasdload64.c
_TEXT	SEGMENT
rc$ = 176
units$ = 180
dsorg$ = 181
method$ = 182
recfm$ = 183
tracks$ = 184
numdscb$ = 188
mintrks$ = 192
trkbal$ = 196
lastrec$ = 200
outusedv$ = 204
i$ = 208
keyln$ = 212
blksz$ = 216
lrecl$ = 220
dscbtab$ = 224
tv211 = 232
tv213 = 236
n$ = 240
tv345 = 244
tv349 = 248
dirblu$ = 252
vtocext$ = 256
vtoctrk$ = 260
fsflag$ = 264
offset$ = 268
sppri$ = 272
maxtrks$ = 276
spdir$ = 280
ehead$ = 284
ecyl$ = 288
bhead$ = 292
bcyl$ = 296
spsec$ = 300
lasttrk$ = 304
stmtno$ = 308
ifname$ = 312
tv336 = 320
volvtoc$ = 328
dsname$ = 336
stmt$ = 384
__$ArrayPad$ = 640
cfp$ = 688
cfname$ = 696
ofname$ = 704
cif$ = 712
volser$ = 720
devtype$ = 728
reqcyls$ = 736
heads$ = 744
trklen$ = 752
outcyl$ = 760
outhead$ = 768
process_control_file PROC

; 3928 : {

  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	56		 push	 rsi
  00015	57		 push	 rdi
  00016	48 81 ec 98 02
	00 00		 sub	 rsp, 664		; 00000298H
  0001d	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00024	48 33 c4	 xor	 rax, rsp
  00027	48 89 84 24 80
	02 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 3929 : int             rc;                     /* Return code               */
; 3930 : int             i;                      /* Array subscript           */
; 3931 : int             n;                      /* Integer work area         */
; 3932 : char            dsname[45];             /* Dataset name (ASCIIZ)     */
; 3933 : BYTE            method;                 /* Initialization method     */
; 3934 : char           *ifname;                 /* ->Initialization file name*/
; 3935 : BYTE            units;                  /* C=CYL, T=TRK              */
; 3936 : int             sppri;                  /* Primary space quantity    */
; 3937 : int             spsec;                  /* Secondary space quantity  */
; 3938 : int             spdir;                  /* Directory space quantity  */
; 3939 : BYTE            dsorg;                  /* Dataset organization      */
; 3940 : BYTE            recfm;                  /* Record format             */
; 3941 : int             lrecl;                  /* Logical record length     */
; 3942 : int             blksz;                  /* Block size                */
; 3943 : int             keyln;                  /* Key length                */
; 3944 : char            stmt[256];              /* Control file statement    */
; 3945 : int             stmtno;                 /* Statement number          */
; 3946 : int             mintrks;                /* Minimum size of dataset   */
; 3947 : int             maxtrks;                /* Maximum size of dataset   */
; 3948 : int             outusedv;               /* Bytes used in track buffer*/
; 3949 : int             tracks = 0;             /* Tracks used in dataset    */

  0002f	c7 84 24 b8 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tracks$[rsp], 0

; 3950 : int             numdscb = 0;            /* Number of DSCBs           */

  0003a	c7 84 24 bc 00
	00 00 00 00 00
	00		 mov	 DWORD PTR numdscb$[rsp], 0

; 3951 : DATABLK       **dscbtab;                /* -> Array of DSCB pointers */
; 3952 : int             dirblu;                 /* Bytes used in last dirblk */
; 3953 : int             lasttrk;                /* Relative track number of
; 3954 :                                            last used track of dataset*/
; 3955 : int             lastrec;                /* Record number of last used
; 3956 :                                            block of dataset          */
; 3957 : int             trkbal;                 /* Bytes unused on last track*/
; 3958 : int             bcyl;                   /* Dataset begin cylinder    */
; 3959 : int             bhead;                  /* Dataset begin head        */
; 3960 : int             ecyl;                   /* Dataset end cylinder      */
; 3961 : int             ehead;                  /* Dataset end head          */
; 3962 : int             vtoctrk = 0;            /* VTOC start relative track */

  00045	c7 84 24 04 01
	00 00 00 00 00
	00		 mov	 DWORD PTR vtoctrk$[rsp], 0

; 3963 : int             vtocext = 0;            /* VTOC extent size (tracks) */

  00050	c7 84 24 00 01
	00 00 00 00 00
	00		 mov	 DWORD PTR vtocext$[rsp], 0

; 3964 : BYTE            volvtoc[5];             /* VTOC begin CCHHR          */
; 3965 : int             offset = 0;             /* Offset into trkbuf        */

  0005b	c7 84 24 0c 01
	00 00 00 00 00
	00		 mov	 DWORD PTR offset$[rsp], 0

; 3966 : int             fsflag = 0;             /* 1=Free space message sent */

  00066	c7 84 24 08 01
	00 00 00 00 00
	00		 mov	 DWORD PTR fsflag$[rsp], 0

; 3967 : 
; 3968 :     /* Obtain storage for the array of DSCB pointers */
; 3969 :     dscbtab = (DATABLK**)malloc (sizeof(DATABLK*) * MAXDSCB);

  00071	b9 40 1f 00 00	 mov	 ecx, 8000		; 00001f40H
  00076	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_malloc
  0007c	48 89 84 24 e0
	00 00 00	 mov	 QWORD PTR dscbtab$[rsp], rax

; 3970 :     if (dscbtab == NULL)

  00084	48 83 bc 24 e0
	00 00 00 00	 cmp	 QWORD PTR dscbtab$[rsp], 0
  0008d	75 3e		 jne	 SHORT $LN18@process_co

; 3971 :     {
; 3972 :         XMERRF ( MSG( HHC02544, "E", "DSCB pointer array", "malloc()", strerror(errno) ) );

  0008f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno
  00095	8b 08		 mov	 ecx, DWORD PTR [rax]
  00097	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_strerror
  0009d	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  000a2	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG162587
  000a9	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG162588
  000b0	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG162589
  000b7	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG162590
  000be	e8 00 00 00 00	 call	 printf

; 3973 :         return -1;

  000c3	b8 ff ff ff ff	 mov	 eax, -1
  000c8	e9 1e 0f 00 00	 jmp	 $LN1@process_co
$LN18@process_co:

; 3974 :     }
; 3975 : 
; 3976 :     /* Initialize the DSCB array with format 4 and format 5 DSCBs */
; 3977 :     rc = build_format4_dscb (dscbtab, numdscb, cif);

  000cd	4c 8b 84 24 c8
	02 00 00	 mov	 r8, QWORD PTR cif$[rsp]
  000d5	8b 94 24 bc 00
	00 00		 mov	 edx, DWORD PTR numdscb$[rsp]
  000dc	48 8b 8c 24 e0
	00 00 00	 mov	 rcx, QWORD PTR dscbtab$[rsp]
  000e4	e8 00 00 00 00	 call	 build_format4_dscb
  000e9	89 84 24 b0 00
	00 00		 mov	 DWORD PTR rc$[rsp], eax

; 3978 :     if (rc < 0) return -1;

  000f0	83 bc 24 b0 00
	00 00 00	 cmp	 DWORD PTR rc$[rsp], 0
  000f8	7d 0a		 jge	 SHORT $LN19@process_co
  000fa	b8 ff ff ff ff	 mov	 eax, -1
  000ff	e9 e7 0e 00 00	 jmp	 $LN1@process_co
$LN19@process_co:

; 3979 :     numdscb++;

  00104	8b 84 24 bc 00
	00 00		 mov	 eax, DWORD PTR numdscb$[rsp]
  0010b	ff c0		 inc	 eax
  0010d	89 84 24 bc 00
	00 00		 mov	 DWORD PTR numdscb$[rsp], eax

; 3980 : 
; 3981 :     rc = build_format5_dscb (dscbtab, numdscb);

  00114	8b 94 24 bc 00
	00 00		 mov	 edx, DWORD PTR numdscb$[rsp]
  0011b	48 8b 8c 24 e0
	00 00 00	 mov	 rcx, QWORD PTR dscbtab$[rsp]
  00123	e8 00 00 00 00	 call	 build_format5_dscb
  00128	89 84 24 b0 00
	00 00		 mov	 DWORD PTR rc$[rsp], eax

; 3982 :     if (rc < 0) return -1;

  0012f	83 bc 24 b0 00
	00 00 00	 cmp	 DWORD PTR rc$[rsp], 0
  00137	7d 0a		 jge	 SHORT $LN20@process_co
  00139	b8 ff ff ff ff	 mov	 eax, -1
  0013e	e9 a8 0e 00 00	 jmp	 $LN1@process_co
$LN20@process_co:

; 3983 :     numdscb++;

  00143	8b 84 24 bc 00
	00 00		 mov	 eax, DWORD PTR numdscb$[rsp]
  0014a	ff c0		 inc	 eax
  0014c	89 84 24 bc 00
	00 00		 mov	 DWORD PTR numdscb$[rsp], eax
$LN2@process_co:

; 3984 : 
; 3985 :     /* Read dataset statements from control file */
; 3986 :     while (1)

  00153	33 c0		 xor	 eax, eax
  00155	83 f8 01	 cmp	 eax, 1
  00158	0f 84 ae 0a 00
	00		 je	 $LN3@process_co

; 3987 :     {
; 3988 :         /* Read next statement from control file */
; 3989 :         rc = read_ctrl_stmt (cfp, cfname, stmt, sizeof(stmt), &stmtno);

  0015e	48 8d 84 24 34
	01 00 00	 lea	 rax, QWORD PTR stmtno$[rsp]
  00166	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  0016b	41 b9 00 01 00
	00		 mov	 r9d, 256		; 00000100H
  00171	4c 8d 84 24 80
	01 00 00	 lea	 r8, QWORD PTR stmt$[rsp]
  00179	48 8b 94 24 b8
	02 00 00	 mov	 rdx, QWORD PTR cfname$[rsp]
  00181	48 8b 8c 24 b0
	02 00 00	 mov	 rcx, QWORD PTR cfp$[rsp]
  00189	e8 00 00 00 00	 call	 read_ctrl_stmt
  0018e	89 84 24 b0 00
	00 00		 mov	 DWORD PTR rc$[rsp], eax

; 3990 :         if (rc < 0) return -1;

  00195	83 bc 24 b0 00
	00 00 00	 cmp	 DWORD PTR rc$[rsp], 0
  0019d	7d 0a		 jge	 SHORT $LN21@process_co
  0019f	b8 ff ff ff ff	 mov	 eax, -1
  001a4	e9 42 0e 00 00	 jmp	 $LN1@process_co
$LN21@process_co:

; 3991 : 
; 3992 :         /* Exit if end of file */
; 3993 :         if (rc > 0)

  001a9	83 bc 24 b0 00
	00 00 00	 cmp	 DWORD PTR rc$[rsp], 0
  001b1	7e 05		 jle	 SHORT $LN22@process_co

; 3994 :             break;

  001b3	e9 54 0a 00 00	 jmp	 $LN3@process_co
$LN22@process_co:

; 3995 : 
; 3996 :         /* Parse dataset statement from control file */
; 3997 :         rc = parse_ctrl_stmt (stmt, dsname, &method, &ifname,

  001b8	48 8d 84 24 d4
	00 00 00	 lea	 rax, QWORD PTR keyln$[rsp]
  001c0	48 89 44 24 60	 mov	 QWORD PTR [rsp+96], rax
  001c5	48 8d 84 24 d8
	00 00 00	 lea	 rax, QWORD PTR blksz$[rsp]
  001cd	48 89 44 24 58	 mov	 QWORD PTR [rsp+88], rax
  001d2	48 8d 84 24 dc
	00 00 00	 lea	 rax, QWORD PTR lrecl$[rsp]
  001da	48 89 44 24 50	 mov	 QWORD PTR [rsp+80], rax
  001df	48 8d 84 24 b7
	00 00 00	 lea	 rax, QWORD PTR recfm$[rsp]
  001e7	48 89 44 24 48	 mov	 QWORD PTR [rsp+72], rax
  001ec	48 8d 84 24 b5
	00 00 00	 lea	 rax, QWORD PTR dsorg$[rsp]
  001f4	48 89 44 24 40	 mov	 QWORD PTR [rsp+64], rax
  001f9	48 8d 84 24 18
	01 00 00	 lea	 rax, QWORD PTR spdir$[rsp]
  00201	48 89 44 24 38	 mov	 QWORD PTR [rsp+56], rax
  00206	48 8d 84 24 2c
	01 00 00	 lea	 rax, QWORD PTR spsec$[rsp]
  0020e	48 89 44 24 30	 mov	 QWORD PTR [rsp+48], rax
  00213	48 8d 84 24 10
	01 00 00	 lea	 rax, QWORD PTR sppri$[rsp]
  0021b	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  00220	48 8d 84 24 b4
	00 00 00	 lea	 rax, QWORD PTR units$[rsp]
  00228	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  0022d	4c 8d 8c 24 38
	01 00 00	 lea	 r9, QWORD PTR ifname$[rsp]
  00235	4c 8d 84 24 b6
	00 00 00	 lea	 r8, QWORD PTR method$[rsp]
  0023d	48 8d 94 24 50
	01 00 00	 lea	 rdx, QWORD PTR dsname$[rsp]
  00245	48 8d 8c 24 80
	01 00 00	 lea	 rcx, QWORD PTR stmt$[rsp]
  0024d	e8 00 00 00 00	 call	 parse_ctrl_stmt
  00252	89 84 24 b0 00
	00 00		 mov	 DWORD PTR rc$[rsp], eax

; 3998 :                 &units, &sppri, &spsec, &spdir,
; 3999 :                 &dsorg, &recfm, &lrecl, &blksz, &keyln);
; 4000 : 
; 4001 :         /* Exit if error in control file */
; 4002 :         if (rc < 0)

  00259	83 bc 24 b0 00
	00 00 00	 cmp	 DWORD PTR rc$[rsp], 0
  00261	7d 2d		 jge	 SHORT $LN23@process_co

; 4003 :         {
; 4004 :             XMERRF ( MSG( HHC02569, "E", cfname, stmtno ) );

  00263	44 8b 8c 24 34
	01 00 00	 mov	 r9d, DWORD PTR stmtno$[rsp]
  0026b	4c 8b 84 24 b8
	02 00 00	 mov	 r8, QWORD PTR cfname$[rsp]
  00273	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG162596
  0027a	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG162597
  00281	e8 00 00 00 00	 call	 printf

; 4005 :             return -1;

  00286	b8 ff ff ff ff	 mov	 eax, -1
  0028b	e9 5b 0d 00 00	 jmp	 $LN1@process_co
$LN23@process_co:
$LN4@process_co:

; 4006 :         }
; 4007 : 
; 4008 :         /* Write empty tracks if allocation is in cylinders */
; 4009 :         while (units == 'C' && outhead != 0)

  00290	0f b6 84 24 b4
	00 00 00	 movzx	 eax, BYTE PTR units$[rsp]
  00298	83 f8 43	 cmp	 eax, 67			; 00000043H
  0029b	0f 85 b4 00 00
	00		 jne	 $LN5@process_co
  002a1	83 bc 24 00 03
	00 00 00	 cmp	 DWORD PTR outhead$[rsp], 0
  002a9	0f 84 a6 00 00
	00		 je	 $LN5@process_co

; 4010 :         {
; 4011 :             /* Initialize track buffer with empty track */
; 4012 :             init_track (trklen, cif->trkbuf, outcyl, outhead, &outusedv);

  002af	48 8d 84 24 cc
	00 00 00	 lea	 rax, QWORD PTR outusedv$[rsp]
  002b7	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  002bc	44 8b 8c 24 00
	03 00 00	 mov	 r9d, DWORD PTR outhead$[rsp]
  002c4	44 8b 84 24 f8
	02 00 00	 mov	 r8d, DWORD PTR outcyl$[rsp]
  002cc	48 8b 84 24 c8
	02 00 00	 mov	 rax, QWORD PTR cif$[rsp]
  002d4	48 8b 50 10	 mov	 rdx, QWORD PTR [rax+16]
  002d8	8b 8c 24 f0 02
	00 00		 mov	 ecx, DWORD PTR trklen$[rsp]
  002df	e8 00 00 00 00	 call	 init_track

; 4013 : 
; 4014 :             /* Write track to output file */
; 4015 :             rc = write_track (cif, ofname, heads, trklen,

  002e4	48 8d 84 24 00
	03 00 00	 lea	 rax, QWORD PTR outhead$[rsp]
  002ec	48 89 44 24 38	 mov	 QWORD PTR [rsp+56], rax
  002f1	48 8d 84 24 f8
	02 00 00	 lea	 rax, QWORD PTR outcyl$[rsp]
  002f9	48 89 44 24 30	 mov	 QWORD PTR [rsp+48], rax
  002fe	48 8d 84 24 b8
	00 00 00	 lea	 rax, QWORD PTR tracks$[rsp]
  00306	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  0030b	48 8d 84 24 cc
	00 00 00	 lea	 rax, QWORD PTR outusedv$[rsp]
  00313	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00318	44 8b 8c 24 f0
	02 00 00	 mov	 r9d, DWORD PTR trklen$[rsp]
  00320	44 8b 84 24 e8
	02 00 00	 mov	 r8d, DWORD PTR heads$[rsp]
  00328	48 8b 94 24 c0
	02 00 00	 mov	 rdx, QWORD PTR ofname$[rsp]
  00330	48 8b 8c 24 c8
	02 00 00	 mov	 rcx, QWORD PTR cif$[rsp]
  00338	e8 00 00 00 00	 call	 write_track
  0033d	89 84 24 b0 00
	00 00		 mov	 DWORD PTR rc$[rsp], eax

; 4016 :                             &outusedv, &tracks, &outcyl, &outhead);
; 4017 :             if (rc < 0) break;

  00344	83 bc 24 b0 00
	00 00 00	 cmp	 DWORD PTR rc$[rsp], 0
  0034c	7d 02		 jge	 SHORT $LN24@process_co
  0034e	eb 05		 jmp	 SHORT $LN5@process_co
$LN24@process_co:

; 4018 : 
; 4019 :         } /* end while */

  00350	e9 3b ff ff ff	 jmp	 $LN4@process_co
$LN5@process_co:

; 4020 : 
; 4021 :         XMINFF (1, MSG( HHC02568, "I", dsname, outcyl, outcyl, outhead, outhead ) );

  00355	8b 84 24 00 03
	00 00		 mov	 eax, DWORD PTR outhead$[rsp]
  0035c	89 44 24 38	 mov	 DWORD PTR [rsp+56], eax
  00360	8b 84 24 00 03
	00 00		 mov	 eax, DWORD PTR outhead$[rsp]
  00367	89 44 24 30	 mov	 DWORD PTR [rsp+48], eax
  0036b	8b 84 24 f8 02
	00 00		 mov	 eax, DWORD PTR outcyl$[rsp]
  00372	89 44 24 28	 mov	 DWORD PTR [rsp+40], eax
  00376	8b 84 24 f8 02
	00 00		 mov	 eax, DWORD PTR outcyl$[rsp]
  0037d	89 44 24 20	 mov	 DWORD PTR [rsp+32], eax
  00381	4c 8d 8c 24 50
	01 00 00	 lea	 r9, QWORD PTR dsname$[rsp]
  00389	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG162599
  00390	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG162600
  00397	b9 01 00 00 00	 mov	 ecx, 1
  0039c	e8 00 00 00 00	 call	 info_msg

; 4022 :         bcyl = outcyl;

  003a1	8b 84 24 f8 02
	00 00		 mov	 eax, DWORD PTR outcyl$[rsp]
  003a8	89 84 24 28 01
	00 00		 mov	 DWORD PTR bcyl$[rsp], eax

; 4023 :         bhead = outhead;

  003af	8b 84 24 00 03
	00 00		 mov	 eax, DWORD PTR outhead$[rsp]
  003b6	89 84 24 24 01
	00 00		 mov	 DWORD PTR bhead$[rsp], eax

; 4024 : 
; 4025 :         /* Calculate minimum size of dataset in tracks */
; 4026 :         mintrks = (units == 'C' ? sppri * heads : sppri);

  003bd	0f b6 84 24 b4
	00 00 00	 movzx	 eax, BYTE PTR units$[rsp]
  003c5	83 f8 43	 cmp	 eax, 67			; 00000043H
  003c8	75 18		 jne	 SHORT $LN52@process_co
  003ca	8b 84 24 10 01
	00 00		 mov	 eax, DWORD PTR sppri$[rsp]
  003d1	0f af 84 24 e8
	02 00 00	 imul	 eax, DWORD PTR heads$[rsp]
  003d9	89 84 24 e8 00
	00 00		 mov	 DWORD PTR tv211[rsp], eax
  003e0	eb 0e		 jmp	 SHORT $LN53@process_co
$LN52@process_co:
  003e2	8b 84 24 10 01
	00 00		 mov	 eax, DWORD PTR sppri$[rsp]
  003e9	89 84 24 e8 00
	00 00		 mov	 DWORD PTR tv211[rsp], eax
$LN53@process_co:
  003f0	8b 84 24 e8 00
	00 00		 mov	 eax, DWORD PTR tv211[rsp]
  003f7	89 84 24 c0 00
	00 00		 mov	 DWORD PTR mintrks$[rsp], eax

; 4027 : 
; 4028 :         /* Create dataset according to method specified */
; 4029 :         switch (method) {

  003fe	0f b6 84 24 b6
	00 00 00	 movzx	 eax, BYTE PTR method$[rsp]
  00406	89 84 24 ec 00
	00 00		 mov	 DWORD PTR tv213[rsp], eax
  0040d	83 bc 24 ec 00
	00 00 06	 cmp	 DWORD PTR tv213[rsp], 6
  00415	0f 87 0f 04 00
	00		 ja	 $LN35@process_co
  0041b	48 63 84 24 ec
	00 00 00	 movsxd	 rax, DWORD PTR tv213[rsp]
  00423	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__ImageBase
  0042a	8b 84 81 00 00
	00 00		 mov	 eax, DWORD PTR $LN60@process_co[rcx+rax*4]
  00431	48 03 c1	 add	 rax, rcx
  00434	ff e0		 jmp	 rax
$LN25@process_co:
$LN26@process_co:

; 4030 : 
; 4031 :         case METHOD_XMIT:               /* IEBCOPY wrapped in XMIT */
; 4032 :         case METHOD_VS:                 /* "straight" IEBCOPY */
; 4033 :             /* Create dataset using IEBCOPY file as input */
; 4034 :             maxtrks = MAX_TRACKS;

  00436	c7 84 24 14 01
	00 00 ff 7f 00
	00		 mov	 DWORD PTR maxtrks$[rsp], 32767 ; 00007fffH

; 4035 :             rc = process_iebcopy_file (ifname, ofname, cif,

  00441	48 8d 84 24 00
	03 00 00	 lea	 rax, QWORD PTR outhead$[rsp]
  00449	48 89 84 24 a0
	00 00 00	 mov	 QWORD PTR [rsp+160], rax
  00451	48 8d 84 24 f8
	02 00 00	 lea	 rax, QWORD PTR outcyl$[rsp]
  00459	48 89 84 24 98
	00 00 00	 mov	 QWORD PTR [rsp+152], rax
  00461	48 8d 84 24 b8
	00 00 00	 lea	 rax, QWORD PTR tracks$[rsp]
  00469	48 89 84 24 90
	00 00 00	 mov	 QWORD PTR [rsp+144], rax
  00471	48 8d 84 24 c4
	00 00 00	 lea	 rax, QWORD PTR trkbal$[rsp]
  00479	48 89 84 24 88
	00 00 00	 mov	 QWORD PTR [rsp+136], rax
  00481	48 8d 84 24 c8
	00 00 00	 lea	 rax, QWORD PTR lastrec$[rsp]
  00489	48 89 84 24 80
	00 00 00	 mov	 QWORD PTR [rsp+128], rax
  00491	48 8d 84 24 fc
	00 00 00	 lea	 rax, QWORD PTR dirblu$[rsp]
  00499	48 89 44 24 78	 mov	 QWORD PTR [rsp+120], rax
  0049e	48 8d 84 24 d4
	00 00 00	 lea	 rax, QWORD PTR keyln$[rsp]
  004a6	48 89 44 24 70	 mov	 QWORD PTR [rsp+112], rax
  004ab	48 8d 84 24 d8
	00 00 00	 lea	 rax, QWORD PTR blksz$[rsp]
  004b3	48 89 44 24 68	 mov	 QWORD PTR [rsp+104], rax
  004b8	48 8d 84 24 dc
	00 00 00	 lea	 rax, QWORD PTR lrecl$[rsp]
  004c0	48 89 44 24 60	 mov	 QWORD PTR [rsp+96], rax
  004c5	48 8d 84 24 b7
	00 00 00	 lea	 rax, QWORD PTR recfm$[rsp]
  004cd	48 89 44 24 58	 mov	 QWORD PTR [rsp+88], rax
  004d2	48 8d 84 24 b5
	00 00 00	 lea	 rax, QWORD PTR dsorg$[rsp]
  004da	48 89 44 24 50	 mov	 QWORD PTR [rsp+80], rax
  004df	0f b6 84 24 b6
	00 00 00	 movzx	 eax, BYTE PTR method$[rsp]
  004e7	88 44 24 48	 mov	 BYTE PTR [rsp+72], al
  004eb	8b 84 24 14 01
	00 00		 mov	 eax, DWORD PTR maxtrks$[rsp]
  004f2	89 44 24 40	 mov	 DWORD PTR [rsp+64], eax
  004f6	8b 84 24 00 03
	00 00		 mov	 eax, DWORD PTR outhead$[rsp]
  004fd	89 44 24 38	 mov	 DWORD PTR [rsp+56], eax
  00501	8b 84 24 f8 02
	00 00		 mov	 eax, DWORD PTR outcyl$[rsp]
  00508	89 44 24 30	 mov	 DWORD PTR [rsp+48], eax
  0050c	8b 84 24 f0 02
	00 00		 mov	 eax, DWORD PTR trklen$[rsp]
  00513	89 44 24 28	 mov	 DWORD PTR [rsp+40], eax
  00517	8b 84 24 e8 02
	00 00		 mov	 eax, DWORD PTR heads$[rsp]
  0051e	89 44 24 20	 mov	 DWORD PTR [rsp+32], eax
  00522	44 0f b7 8c 24
	d8 02 00 00	 movzx	 r9d, WORD PTR devtype$[rsp]
  0052b	4c 8b 84 24 c8
	02 00 00	 mov	 r8, QWORD PTR cif$[rsp]
  00533	48 8b 94 24 c0
	02 00 00	 mov	 rdx, QWORD PTR ofname$[rsp]
  0053b	48 8b 8c 24 38
	01 00 00	 mov	 rcx, QWORD PTR ifname$[rsp]
  00543	e8 00 00 00 00	 call	 process_iebcopy_file
  00548	89 84 24 b0 00
	00 00		 mov	 DWORD PTR rc$[rsp], eax

; 4036 :                                     devtype, heads, trklen,
; 4037 :                                     outcyl, outhead, maxtrks,
; 4038 :                                     method,
; 4039 :                                     &dsorg, &recfm,
; 4040 :                                     &lrecl, &blksz, &keyln,
; 4041 :                                     &dirblu, &lastrec, &trkbal,
; 4042 :                                     &tracks, &outcyl, &outhead);
; 4043 :             if (rc < 0) return -1;

  0054f	83 bc 24 b0 00
	00 00 00	 cmp	 DWORD PTR rc$[rsp], 0
  00557	7d 0a		 jge	 SHORT $LN27@process_co
  00559	b8 ff ff ff ff	 mov	 eax, -1
  0055e	e9 88 0a 00 00	 jmp	 $LN1@process_co
$LN27@process_co:

; 4044 :             break;

  00563	e9 94 03 00 00	 jmp	 $LN6@process_co
$LN28@process_co:

; 4045 : 
; 4046 :         case METHOD_DIP:
; 4047 :             /* Initialize LOGREC dataset */
; 4048 :             rc = dip_initialize (ofname, cif,

  00568	48 8d 84 24 00
	03 00 00	 lea	 rax, QWORD PTR outhead$[rsp]
  00570	48 89 44 24 60	 mov	 QWORD PTR [rsp+96], rax
  00575	48 8d 84 24 f8
	02 00 00	 lea	 rax, QWORD PTR outcyl$[rsp]
  0057d	48 89 44 24 58	 mov	 QWORD PTR [rsp+88], rax
  00582	48 8d 84 24 b8
	00 00 00	 lea	 rax, QWORD PTR tracks$[rsp]
  0058a	48 89 44 24 50	 mov	 QWORD PTR [rsp+80], rax
  0058f	48 8d 84 24 c4
	00 00 00	 lea	 rax, QWORD PTR trkbal$[rsp]
  00597	48 89 44 24 48	 mov	 QWORD PTR [rsp+72], rax
  0059c	48 8d 84 24 c8
	00 00 00	 lea	 rax, QWORD PTR lastrec$[rsp]
  005a4	48 89 44 24 40	 mov	 QWORD PTR [rsp+64], rax
  005a9	8b 84 24 c0 00
	00 00		 mov	 eax, DWORD PTR mintrks$[rsp]
  005b0	89 44 24 38	 mov	 DWORD PTR [rsp+56], eax
  005b4	8b 84 24 00 03
	00 00		 mov	 eax, DWORD PTR outhead$[rsp]
  005bb	89 44 24 30	 mov	 DWORD PTR [rsp+48], eax
  005bf	8b 84 24 f8 02
	00 00		 mov	 eax, DWORD PTR outcyl$[rsp]
  005c6	89 44 24 28	 mov	 DWORD PTR [rsp+40], eax
  005ca	8b 84 24 f0 02
	00 00		 mov	 eax, DWORD PTR trklen$[rsp]
  005d1	89 44 24 20	 mov	 DWORD PTR [rsp+32], eax
  005d5	44 8b 8c 24 e8
	02 00 00	 mov	 r9d, DWORD PTR heads$[rsp]
  005dd	44 0f b7 84 24
	d8 02 00 00	 movzx	 r8d, WORD PTR devtype$[rsp]
  005e6	48 8b 94 24 c8
	02 00 00	 mov	 rdx, QWORD PTR cif$[rsp]
  005ee	48 8b 8c 24 c0
	02 00 00	 mov	 rcx, QWORD PTR ofname$[rsp]
  005f6	e8 00 00 00 00	 call	 dip_initialize
  005fb	89 84 24 b0 00
	00 00		 mov	 DWORD PTR rc$[rsp], eax

; 4049 :                                     devtype, heads, trklen,
; 4050 :                                     outcyl, outhead, mintrks,
; 4051 :                                     &lastrec, &trkbal,
; 4052 :                                     &tracks, &outcyl, &outhead);
; 4053 :             if (rc < 0) return -1;

  00602	83 bc 24 b0 00
	00 00 00	 cmp	 DWORD PTR rc$[rsp], 0
  0060a	7d 0a		 jge	 SHORT $LN29@process_co
  0060c	b8 ff ff ff ff	 mov	 eax, -1
  00611	e9 d5 09 00 00	 jmp	 $LN1@process_co
$LN29@process_co:

; 4054 :             break;

  00616	e9 e1 02 00 00	 jmp	 $LN6@process_co
$LN30@process_co:

; 4055 : 
; 4056 :         case METHOD_CVOL:
; 4057 :             /* Initialize SYSCTLG dataset */
; 4058 :             rc = cvol_initialize (ofname, cif, volser,

  0061b	48 8d 84 24 00
	03 00 00	 lea	 rax, QWORD PTR outhead$[rsp]
  00623	48 89 44 24 68	 mov	 QWORD PTR [rsp+104], rax
  00628	48 8d 84 24 f8
	02 00 00	 lea	 rax, QWORD PTR outcyl$[rsp]
  00630	48 89 44 24 60	 mov	 QWORD PTR [rsp+96], rax
  00635	48 8d 84 24 b8
	00 00 00	 lea	 rax, QWORD PTR tracks$[rsp]
  0063d	48 89 44 24 58	 mov	 QWORD PTR [rsp+88], rax
  00642	48 8d 84 24 c4
	00 00 00	 lea	 rax, QWORD PTR trkbal$[rsp]
  0064a	48 89 44 24 50	 mov	 QWORD PTR [rsp+80], rax
  0064f	48 8d 84 24 c8
	00 00 00	 lea	 rax, QWORD PTR lastrec$[rsp]
  00657	48 89 44 24 48	 mov	 QWORD PTR [rsp+72], rax
  0065c	8b 84 24 c0 00
	00 00		 mov	 eax, DWORD PTR mintrks$[rsp]
  00663	89 44 24 40	 mov	 DWORD PTR [rsp+64], eax
  00667	8b 84 24 00 03
	00 00		 mov	 eax, DWORD PTR outhead$[rsp]
  0066e	89 44 24 38	 mov	 DWORD PTR [rsp+56], eax
  00672	8b 84 24 f8 02
	00 00		 mov	 eax, DWORD PTR outcyl$[rsp]
  00679	89 44 24 30	 mov	 DWORD PTR [rsp+48], eax
  0067d	8b 84 24 f0 02
	00 00		 mov	 eax, DWORD PTR trklen$[rsp]
  00684	89 44 24 28	 mov	 DWORD PTR [rsp+40], eax
  00688	8b 84 24 e8 02
	00 00		 mov	 eax, DWORD PTR heads$[rsp]
  0068f	89 44 24 20	 mov	 DWORD PTR [rsp+32], eax
  00693	44 0f b7 8c 24
	d8 02 00 00	 movzx	 r9d, WORD PTR devtype$[rsp]
  0069c	4c 8b 84 24 d0
	02 00 00	 mov	 r8, QWORD PTR volser$[rsp]
  006a4	48 8b 94 24 c8
	02 00 00	 mov	 rdx, QWORD PTR cif$[rsp]
  006ac	48 8b 8c 24 c0
	02 00 00	 mov	 rcx, QWORD PTR ofname$[rsp]
  006b4	e8 00 00 00 00	 call	 cvol_initialize
  006b9	89 84 24 b0 00
	00 00		 mov	 DWORD PTR rc$[rsp], eax

; 4059 :                                     devtype, heads, trklen,
; 4060 :                                     outcyl, outhead, mintrks,
; 4061 :                                     &lastrec, &trkbal,
; 4062 :                                     &tracks, &outcyl, &outhead);
; 4063 :             if (rc < 0) return -1;

  006c0	83 bc 24 b0 00
	00 00 00	 cmp	 DWORD PTR rc$[rsp], 0
  006c8	7d 0a		 jge	 SHORT $LN31@process_co
  006ca	b8 ff ff ff ff	 mov	 eax, -1
  006cf	e9 17 09 00 00	 jmp	 $LN1@process_co
$LN31@process_co:

; 4064 :             break;

  006d4	e9 23 02 00 00	 jmp	 $LN6@process_co
$LN32@process_co:

; 4065 : 
; 4066 :         case METHOD_VTOC:
; 4067 :             /* Reserve space for VTOC */
; 4068 :             vtoctrk = (outcyl * heads) + outhead;

  006d9	8b 84 24 f8 02
	00 00		 mov	 eax, DWORD PTR outcyl$[rsp]
  006e0	0f af 84 24 e8
	02 00 00	 imul	 eax, DWORD PTR heads$[rsp]
  006e8	03 84 24 00 03
	00 00		 add	 eax, DWORD PTR outhead$[rsp]
  006ef	89 84 24 04 01
	00 00		 mov	 DWORD PTR vtoctrk$[rsp], eax

; 4069 :             vtocext = mintrks;

  006f6	8b 84 24 c0 00
	00 00		 mov	 eax, DWORD PTR mintrks$[rsp]
  006fd	89 84 24 00 01
	00 00		 mov	 DWORD PTR vtocext$[rsp], eax

; 4070 :             tracks = 0;

  00704	c7 84 24 b8 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tracks$[rsp], 0

; 4071 :             lastrec = 0;

  0070f	c7 84 24 c8 00
	00 00 00 00 00
	00		 mov	 DWORD PTR lastrec$[rsp], 0

; 4072 :             trkbal = 0;

  0071a	c7 84 24 c4 00
	00 00 00 00 00
	00		 mov	 DWORD PTR trkbal$[rsp], 0

; 4073 :             break;

  00725	e9 d2 01 00 00	 jmp	 $LN6@process_co
$LN33@process_co:

; 4074 : 
; 4075 :         case METHOD_SEQ:
; 4076 :             /* Create sequential dataset */
; 4077 :             rc = seq_initialize (ifname, ofname, cif,

  0072a	48 8d 84 24 00
	03 00 00	 lea	 rax, QWORD PTR outhead$[rsp]
  00732	48 89 84 24 90
	00 00 00	 mov	 QWORD PTR [rsp+144], rax
  0073a	48 8d 84 24 f8
	02 00 00	 lea	 rax, QWORD PTR outcyl$[rsp]
  00742	48 89 84 24 88
	00 00 00	 mov	 QWORD PTR [rsp+136], rax
  0074a	48 8d 84 24 b8
	00 00 00	 lea	 rax, QWORD PTR tracks$[rsp]
  00752	48 89 84 24 80
	00 00 00	 mov	 QWORD PTR [rsp+128], rax
  0075a	48 8d 84 24 c4
	00 00 00	 lea	 rax, QWORD PTR trkbal$[rsp]
  00762	48 89 44 24 78	 mov	 QWORD PTR [rsp+120], rax
  00767	48 8d 84 24 c8
	00 00 00	 lea	 rax, QWORD PTR lastrec$[rsp]
  0076f	48 89 44 24 70	 mov	 QWORD PTR [rsp+112], rax
  00774	8b 84 24 d4 00
	00 00		 mov	 eax, DWORD PTR keyln$[rsp]
  0077b	89 44 24 68	 mov	 DWORD PTR [rsp+104], eax
  0077f	8b 84 24 d8 00
	00 00		 mov	 eax, DWORD PTR blksz$[rsp]
  00786	89 44 24 60	 mov	 DWORD PTR [rsp+96], eax
  0078a	8b 84 24 dc 00
	00 00		 mov	 eax, DWORD PTR lrecl$[rsp]
  00791	89 44 24 58	 mov	 DWORD PTR [rsp+88], eax
  00795	0f b6 84 24 b7
	00 00 00	 movzx	 eax, BYTE PTR recfm$[rsp]
  0079d	88 44 24 50	 mov	 BYTE PTR [rsp+80], al
  007a1	0f b6 84 24 b5
	00 00 00	 movzx	 eax, BYTE PTR dsorg$[rsp]
  007a9	88 44 24 48	 mov	 BYTE PTR [rsp+72], al
  007ad	8b 84 24 c0 00
	00 00		 mov	 eax, DWORD PTR mintrks$[rsp]
  007b4	89 44 24 40	 mov	 DWORD PTR [rsp+64], eax
  007b8	8b 84 24 00 03
	00 00		 mov	 eax, DWORD PTR outhead$[rsp]
  007bf	89 44 24 38	 mov	 DWORD PTR [rsp+56], eax
  007c3	8b 84 24 f8 02
	00 00		 mov	 eax, DWORD PTR outcyl$[rsp]
  007ca	89 44 24 30	 mov	 DWORD PTR [rsp+48], eax
  007ce	8b 84 24 f0 02
	00 00		 mov	 eax, DWORD PTR trklen$[rsp]
  007d5	89 44 24 28	 mov	 DWORD PTR [rsp+40], eax
  007d9	8b 84 24 e8 02
	00 00		 mov	 eax, DWORD PTR heads$[rsp]
  007e0	89 44 24 20	 mov	 DWORD PTR [rsp+32], eax
  007e4	44 0f b7 8c 24
	d8 02 00 00	 movzx	 r9d, WORD PTR devtype$[rsp]
  007ed	4c 8b 84 24 c8
	02 00 00	 mov	 r8, QWORD PTR cif$[rsp]
  007f5	48 8b 94 24 c0
	02 00 00	 mov	 rdx, QWORD PTR ofname$[rsp]
  007fd	48 8b 8c 24 38
	01 00 00	 mov	 rcx, QWORD PTR ifname$[rsp]
  00805	e8 00 00 00 00	 call	 seq_initialize
  0080a	89 84 24 b0 00
	00 00		 mov	 DWORD PTR rc$[rsp], eax

; 4078 :                                     devtype, heads, trklen,
; 4079 :                                     outcyl, outhead, mintrks,
; 4080 :                                     dsorg, recfm, lrecl, blksz,
; 4081 :                                     keyln, &lastrec, &trkbal,
; 4082 :                                     &tracks, &outcyl, &outhead);
; 4083 :             if (rc < 0) return -1;

  00811	83 bc 24 b0 00
	00 00 00	 cmp	 DWORD PTR rc$[rsp], 0
  00819	7d 0a		 jge	 SHORT $LN34@process_co
  0081b	b8 ff ff ff ff	 mov	 eax, -1
  00820	e9 c6 07 00 00	 jmp	 $LN1@process_co
$LN34@process_co:

; 4084 :             break;

  00825	e9 d2 00 00 00	 jmp	 $LN6@process_co
$LN35@process_co:
$LN36@process_co:

; 4085 : 
; 4086 :         default:
; 4087 :         case METHOD_EMPTY:
; 4088 :             /* Create empty dataset */
; 4089 :             rc = empty_initialize (ofname, cif,

  0082a	48 8d 84 24 00
	03 00 00	 lea	 rax, QWORD PTR outhead$[rsp]
  00832	48 89 44 24 78	 mov	 QWORD PTR [rsp+120], rax
  00837	48 8d 84 24 f8
	02 00 00	 lea	 rax, QWORD PTR outcyl$[rsp]
  0083f	48 89 44 24 70	 mov	 QWORD PTR [rsp+112], rax
  00844	48 8d 84 24 b8
	00 00 00	 lea	 rax, QWORD PTR tracks$[rsp]
  0084c	48 89 44 24 68	 mov	 QWORD PTR [rsp+104], rax
  00851	48 8d 84 24 c4
	00 00 00	 lea	 rax, QWORD PTR trkbal$[rsp]
  00859	48 89 44 24 60	 mov	 QWORD PTR [rsp+96], rax
  0085e	48 8d 84 24 c8
	00 00 00	 lea	 rax, QWORD PTR lastrec$[rsp]
  00866	48 89 44 24 58	 mov	 QWORD PTR [rsp+88], rax
  0086b	48 8d 84 24 fc
	00 00 00	 lea	 rax, QWORD PTR dirblu$[rsp]
  00873	48 89 44 24 50	 mov	 QWORD PTR [rsp+80], rax
  00878	8b 84 24 18 01
	00 00		 mov	 eax, DWORD PTR spdir$[rsp]
  0087f	89 44 24 48	 mov	 DWORD PTR [rsp+72], eax
  00883	0f b6 84 24 b5
	00 00 00	 movzx	 eax, BYTE PTR dsorg$[rsp]
  0088b	88 44 24 40	 mov	 BYTE PTR [rsp+64], al
  0088f	8b 84 24 c0 00
	00 00		 mov	 eax, DWORD PTR mintrks$[rsp]
  00896	89 44 24 38	 mov	 DWORD PTR [rsp+56], eax
  0089a	8b 84 24 00 03
	00 00		 mov	 eax, DWORD PTR outhead$[rsp]
  008a1	89 44 24 30	 mov	 DWORD PTR [rsp+48], eax
  008a5	8b 84 24 f8 02
	00 00		 mov	 eax, DWORD PTR outcyl$[rsp]
  008ac	89 44 24 28	 mov	 DWORD PTR [rsp+40], eax
  008b0	8b 84 24 f0 02
	00 00		 mov	 eax, DWORD PTR trklen$[rsp]
  008b7	89 44 24 20	 mov	 DWORD PTR [rsp+32], eax
  008bb	44 8b 8c 24 e8
	02 00 00	 mov	 r9d, DWORD PTR heads$[rsp]
  008c3	44 0f b7 84 24
	d8 02 00 00	 movzx	 r8d, WORD PTR devtype$[rsp]
  008cc	48 8b 94 24 c8
	02 00 00	 mov	 rdx, QWORD PTR cif$[rsp]
  008d4	48 8b 8c 24 c0
	02 00 00	 mov	 rcx, QWORD PTR ofname$[rsp]
  008dc	e8 00 00 00 00	 call	 empty_initialize
  008e1	89 84 24 b0 00
	00 00		 mov	 DWORD PTR rc$[rsp], eax

; 4090 :                                     devtype, heads, trklen,
; 4091 :                                     outcyl, outhead, mintrks,
; 4092 :                                     dsorg, spdir,
; 4093 :                                     &dirblu, &lastrec, &trkbal,
; 4094 :                                     &tracks, &outcyl, &outhead);
; 4095 :             if (rc < 0) return -1;

  008e8	83 bc 24 b0 00
	00 00 00	 cmp	 DWORD PTR rc$[rsp], 0
  008f0	7d 0a		 jge	 SHORT $LN37@process_co
  008f2	b8 ff ff ff ff	 mov	 eax, -1
  008f7	e9 ef 06 00 00	 jmp	 $LN1@process_co
$LN37@process_co:
$LN6@process_co:

; 4096 :             break;
; 4097 : 
; 4098 :         } /* end switch(method) */
; 4099 : 
; 4100 :         /* Calculate the relative track number of last used track */
; 4101 :         lasttrk = tracks - 1;

  008fc	8b 84 24 b8 00
	00 00		 mov	 eax, DWORD PTR tracks$[rsp]
  00903	ff c8		 dec	 eax
  00905	89 84 24 30 01
	00 00		 mov	 DWORD PTR lasttrk$[rsp], eax

; 4102 : 
; 4103 :         /* Round up space allocation if allocated in cylinders */
; 4104 :         if (units == 'C')

  0090c	0f b6 84 24 b4
	00 00 00	 movzx	 eax, BYTE PTR units$[rsp]
  00914	83 f8 43	 cmp	 eax, 67			; 00000043H
  00917	75 47		 jne	 SHORT $LN38@process_co

; 4105 :         {
; 4106 :             n = (tracks + heads - 1) / heads * heads;

  00919	8b 84 24 b8 00
	00 00		 mov	 eax, DWORD PTR tracks$[rsp]
  00920	8b 8c 24 e8 02
	00 00		 mov	 ecx, DWORD PTR heads$[rsp]
  00927	8d 44 08 ff	 lea	 eax, DWORD PTR [rax+rcx-1]
  0092b	99		 cdq
  0092c	f7 bc 24 e8 02
	00 00		 idiv	 DWORD PTR heads$[rsp]
  00933	0f af 84 24 e8
	02 00 00	 imul	 eax, DWORD PTR heads$[rsp]
  0093b	89 84 24 f0 00
	00 00		 mov	 DWORD PTR n$[rsp], eax

; 4107 :             if (mintrks < n) mintrks = n;

  00942	8b 84 24 f0 00
	00 00		 mov	 eax, DWORD PTR n$[rsp]
  00949	39 84 24 c0 00
	00 00		 cmp	 DWORD PTR mintrks$[rsp], eax
  00950	7d 0e		 jge	 SHORT $LN39@process_co
  00952	8b 84 24 f0 00
	00 00		 mov	 eax, DWORD PTR n$[rsp]
  00959	89 84 24 c0 00
	00 00		 mov	 DWORD PTR mintrks$[rsp], eax
$LN39@process_co:
$LN38@process_co:
$LN8@process_co:

; 4108 :         }
; 4109 : 
; 4110 :         /* Fill unused space in dataset with empty tracks */
; 4111 :         while (tracks < mintrks)

  00960	8b 84 24 c0 00
	00 00		 mov	 eax, DWORD PTR mintrks$[rsp]
  00967	39 84 24 b8 00
	00 00		 cmp	 DWORD PTR tracks$[rsp], eax
  0096e	0f 8d ae 00 00
	00		 jge	 $LN9@process_co

; 4112 :         {
; 4113 :             /* Initialize track buffer with empty track */
; 4114 :             init_track (trklen, cif->trkbuf, outcyl, outhead, &outusedv);

  00974	48 8d 84 24 cc
	00 00 00	 lea	 rax, QWORD PTR outusedv$[rsp]
  0097c	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00981	44 8b 8c 24 00
	03 00 00	 mov	 r9d, DWORD PTR outhead$[rsp]
  00989	44 8b 84 24 f8
	02 00 00	 mov	 r8d, DWORD PTR outcyl$[rsp]
  00991	48 8b 84 24 c8
	02 00 00	 mov	 rax, QWORD PTR cif$[rsp]
  00999	48 8b 50 10	 mov	 rdx, QWORD PTR [rax+16]
  0099d	8b 8c 24 f0 02
	00 00		 mov	 ecx, DWORD PTR trklen$[rsp]
  009a4	e8 00 00 00 00	 call	 init_track

; 4115 : 
; 4116 :             /* Write track to output file */
; 4117 :             rc = write_track (cif, ofname, heads, trklen,

  009a9	48 8d 84 24 00
	03 00 00	 lea	 rax, QWORD PTR outhead$[rsp]
  009b1	48 89 44 24 38	 mov	 QWORD PTR [rsp+56], rax
  009b6	48 8d 84 24 f8
	02 00 00	 lea	 rax, QWORD PTR outcyl$[rsp]
  009be	48 89 44 24 30	 mov	 QWORD PTR [rsp+48], rax
  009c3	48 8d 84 24 b8
	00 00 00	 lea	 rax, QWORD PTR tracks$[rsp]
  009cb	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  009d0	48 8d 84 24 cc
	00 00 00	 lea	 rax, QWORD PTR outusedv$[rsp]
  009d8	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  009dd	44 8b 8c 24 f0
	02 00 00	 mov	 r9d, DWORD PTR trklen$[rsp]
  009e5	44 8b 84 24 e8
	02 00 00	 mov	 r8d, DWORD PTR heads$[rsp]
  009ed	48 8b 94 24 c0
	02 00 00	 mov	 rdx, QWORD PTR ofname$[rsp]
  009f5	48 8b 8c 24 c8
	02 00 00	 mov	 rcx, QWORD PTR cif$[rsp]
  009fd	e8 00 00 00 00	 call	 write_track
  00a02	89 84 24 b0 00
	00 00		 mov	 DWORD PTR rc$[rsp], eax

; 4118 :                             &outusedv, &tracks, &outcyl, &outhead);
; 4119 :             if (rc < 0) return -1;

  00a09	83 bc 24 b0 00
	00 00 00	 cmp	 DWORD PTR rc$[rsp], 0
  00a11	7d 0a		 jge	 SHORT $LN40@process_co
  00a13	b8 ff ff ff ff	 mov	 eax, -1
  00a18	e9 ce 05 00 00	 jmp	 $LN1@process_co
$LN40@process_co:

; 4120 : 
; 4121 :         } /* end while(tracks) */

  00a1d	e9 3e ff ff ff	 jmp	 $LN8@process_co
$LN9@process_co:

; 4122 : 
; 4123 :         /* Print number of tracks written to dataset */
; 4124 :         XMINFF (2, MSG( HHC02589, "I", dsname, tracks, (tracks == 1 ? "" : "s") ) );

  00a22	83 bc 24 b8 00
	00 00 01	 cmp	 DWORD PTR tracks$[rsp], 1
  00a2a	75 11		 jne	 SHORT $LN54@process_co
  00a2c	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG162617
  00a33	48 89 84 24 40
	01 00 00	 mov	 QWORD PTR tv336[rsp], rax
  00a3b	eb 0f		 jmp	 SHORT $LN55@process_co
$LN54@process_co:
  00a3d	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG162618
  00a44	48 89 84 24 40
	01 00 00	 mov	 QWORD PTR tv336[rsp], rax
$LN55@process_co:
  00a4c	48 8b 84 24 40
	01 00 00	 mov	 rax, QWORD PTR tv336[rsp]
  00a54	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  00a59	8b 84 24 b8 00
	00 00		 mov	 eax, DWORD PTR tracks$[rsp]
  00a60	89 44 24 20	 mov	 DWORD PTR [rsp+32], eax
  00a64	4c 8d 8c 24 50
	01 00 00	 lea	 r9, QWORD PTR dsname$[rsp]
  00a6c	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG162619
  00a73	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG162620
  00a7a	b9 02 00 00 00	 mov	 ecx, 2
  00a7f	e8 00 00 00 00	 call	 info_msg

; 4125 : 
; 4126 :         /* Calculate end of extent cylinder and head */
; 4127 :         ecyl = (outhead > 0 ? outcyl : outcyl - 1);

  00a84	83 bc 24 00 03
	00 00 00	 cmp	 DWORD PTR outhead$[rsp], 0
  00a8c	7e 10		 jle	 SHORT $LN56@process_co
  00a8e	8b 84 24 f8 02
	00 00		 mov	 eax, DWORD PTR outcyl$[rsp]
  00a95	89 84 24 f4 00
	00 00		 mov	 DWORD PTR tv345[rsp], eax
  00a9c	eb 10		 jmp	 SHORT $LN57@process_co
$LN56@process_co:
  00a9e	8b 84 24 f8 02
	00 00		 mov	 eax, DWORD PTR outcyl$[rsp]
  00aa5	ff c8		 dec	 eax
  00aa7	89 84 24 f4 00
	00 00		 mov	 DWORD PTR tv345[rsp], eax
$LN57@process_co:
  00aae	8b 84 24 f4 00
	00 00		 mov	 eax, DWORD PTR tv345[rsp]
  00ab5	89 84 24 20 01
	00 00		 mov	 DWORD PTR ecyl$[rsp], eax

; 4128 :         ehead = (outhead > 0 ? outhead - 1 : heads - 1);

  00abc	83 bc 24 00 03
	00 00 00	 cmp	 DWORD PTR outhead$[rsp], 0
  00ac4	7e 12		 jle	 SHORT $LN58@process_co
  00ac6	8b 84 24 00 03
	00 00		 mov	 eax, DWORD PTR outhead$[rsp]
  00acd	ff c8		 dec	 eax
  00acf	89 84 24 f8 00
	00 00		 mov	 DWORD PTR tv349[rsp], eax
  00ad6	eb 10		 jmp	 SHORT $LN59@process_co
$LN58@process_co:
  00ad8	8b 84 24 e8 02
	00 00		 mov	 eax, DWORD PTR heads$[rsp]
  00adf	ff c8		 dec	 eax
  00ae1	89 84 24 f8 00
	00 00		 mov	 DWORD PTR tv349[rsp], eax
$LN59@process_co:
  00ae8	8b 84 24 f8 00
	00 00		 mov	 eax, DWORD PTR tv349[rsp]
  00aef	89 84 24 1c 01
	00 00		 mov	 DWORD PTR ehead$[rsp], eax

; 4129 : 
; 4130 :         /* Create format 1 DSCB for the dataset */
; 4131 :         if (method != METHOD_VTOC)

  00af6	0f b6 84 24 b6
	00 00 00	 movzx	 eax, BYTE PTR method$[rsp]
  00afe	83 f8 04	 cmp	 eax, 4
  00b01	0f 84 00 01 00
	00		 je	 $LN41@process_co

; 4132 :         {
; 4133 :             rc = build_format1_dscb (dscbtab, numdscb, dsname, volser,

  00b07	8b 84 24 1c 01
	00 00		 mov	 eax, DWORD PTR ehead$[rsp]
  00b0e	89 84 24 90 00
	00 00		 mov	 DWORD PTR [rsp+144], eax
  00b15	8b 84 24 20 01
	00 00		 mov	 eax, DWORD PTR ecyl$[rsp]
  00b1c	89 84 24 88 00
	00 00		 mov	 DWORD PTR [rsp+136], eax
  00b23	8b 84 24 24 01
	00 00		 mov	 eax, DWORD PTR bhead$[rsp]
  00b2a	89 84 24 80 00
	00 00		 mov	 DWORD PTR [rsp+128], eax
  00b31	8b 84 24 28 01
	00 00		 mov	 eax, DWORD PTR bcyl$[rsp]
  00b38	89 44 24 78	 mov	 DWORD PTR [rsp+120], eax
  00b3c	8b 84 24 2c 01
	00 00		 mov	 eax, DWORD PTR spsec$[rsp]
  00b43	89 44 24 70	 mov	 DWORD PTR [rsp+112], eax
  00b47	0f b6 84 24 b4
	00 00 00	 movzx	 eax, BYTE PTR units$[rsp]
  00b4f	88 44 24 68	 mov	 BYTE PTR [rsp+104], al
  00b53	8b 84 24 c4 00
	00 00		 mov	 eax, DWORD PTR trkbal$[rsp]
  00b5a	89 44 24 60	 mov	 DWORD PTR [rsp+96], eax
  00b5e	8b 84 24 c8 00
	00 00		 mov	 eax, DWORD PTR lastrec$[rsp]
  00b65	89 44 24 58	 mov	 DWORD PTR [rsp+88], eax
  00b69	8b 84 24 30 01
	00 00		 mov	 eax, DWORD PTR lasttrk$[rsp]
  00b70	89 44 24 50	 mov	 DWORD PTR [rsp+80], eax
  00b74	8b 84 24 fc 00
	00 00		 mov	 eax, DWORD PTR dirblu$[rsp]
  00b7b	89 44 24 48	 mov	 DWORD PTR [rsp+72], eax
  00b7f	8b 84 24 d4 00
	00 00		 mov	 eax, DWORD PTR keyln$[rsp]
  00b86	89 44 24 40	 mov	 DWORD PTR [rsp+64], eax
  00b8a	8b 84 24 d8 00
	00 00		 mov	 eax, DWORD PTR blksz$[rsp]
  00b91	89 44 24 38	 mov	 DWORD PTR [rsp+56], eax
  00b95	8b 84 24 dc 00
	00 00		 mov	 eax, DWORD PTR lrecl$[rsp]
  00b9c	89 44 24 30	 mov	 DWORD PTR [rsp+48], eax
  00ba0	0f b6 84 24 b7
	00 00 00	 movzx	 eax, BYTE PTR recfm$[rsp]
  00ba8	88 44 24 28	 mov	 BYTE PTR [rsp+40], al
  00bac	0f b6 84 24 b5
	00 00 00	 movzx	 eax, BYTE PTR dsorg$[rsp]
  00bb4	88 44 24 20	 mov	 BYTE PTR [rsp+32], al
  00bb8	4c 8b 8c 24 d0
	02 00 00	 mov	 r9, QWORD PTR volser$[rsp]
  00bc0	4c 8d 84 24 50
	01 00 00	 lea	 r8, QWORD PTR dsname$[rsp]
  00bc8	8b 94 24 bc 00
	00 00		 mov	 edx, DWORD PTR numdscb$[rsp]
  00bcf	48 8b 8c 24 e0
	00 00 00	 mov	 rcx, QWORD PTR dscbtab$[rsp]
  00bd7	e8 00 00 00 00	 call	 build_format1_dscb
  00bdc	89 84 24 b0 00
	00 00		 mov	 DWORD PTR rc$[rsp], eax

; 4134 :                                     dsorg, recfm, lrecl, blksz,
; 4135 :                                     keyln, dirblu, lasttrk, lastrec,
; 4136 :                                     trkbal, units, spsec,
; 4137 :                                     bcyl, bhead, ecyl, ehead);
; 4138 :             if (rc < 0) return -1;

  00be3	83 bc 24 b0 00
	00 00 00	 cmp	 DWORD PTR rc$[rsp], 0
  00beb	7d 0a		 jge	 SHORT $LN42@process_co
  00bed	b8 ff ff ff ff	 mov	 eax, -1
  00bf2	e9 f4 03 00 00	 jmp	 $LN1@process_co
$LN42@process_co:

; 4139 :             numdscb++;

  00bf7	8b 84 24 bc 00
	00 00		 mov	 eax, DWORD PTR numdscb$[rsp]
  00bfe	ff c0		 inc	 eax
  00c00	89 84 24 bc 00
	00 00		 mov	 DWORD PTR numdscb$[rsp], eax
$LN41@process_co:

; 4140 :         }
; 4141 : 
; 4142 :     } /* end while */

  00c07	e9 47 f5 ff ff	 jmp	 $LN2@process_co
$LN3@process_co:

; 4143 : 
; 4144 :     /* Write the VTOC */
; 4145 :     rc = write_vtoc (dscbtab, numdscb, cif, ofname, devtype,

  00c0c	48 8d 84 24 48
	01 00 00	 lea	 rax, QWORD PTR volvtoc$[rsp]
  00c14	48 89 44 24 60	 mov	 QWORD PTR [rsp+96], rax
  00c19	48 8d 84 24 00
	03 00 00	 lea	 rax, QWORD PTR outhead$[rsp]
  00c21	48 89 44 24 58	 mov	 QWORD PTR [rsp+88], rax
  00c26	48 8d 84 24 f8
	02 00 00	 lea	 rax, QWORD PTR outcyl$[rsp]
  00c2e	48 89 44 24 50	 mov	 QWORD PTR [rsp+80], rax
  00c33	8b 84 24 00 01
	00 00		 mov	 eax, DWORD PTR vtocext$[rsp]
  00c3a	89 44 24 48	 mov	 DWORD PTR [rsp+72], eax
  00c3e	8b 84 24 04 01
	00 00		 mov	 eax, DWORD PTR vtoctrk$[rsp]
  00c45	89 44 24 40	 mov	 DWORD PTR [rsp+64], eax
  00c49	8b 84 24 f0 02
	00 00		 mov	 eax, DWORD PTR trklen$[rsp]
  00c50	89 44 24 38	 mov	 DWORD PTR [rsp+56], eax
  00c54	8b 84 24 e8 02
	00 00		 mov	 eax, DWORD PTR heads$[rsp]
  00c5b	89 44 24 30	 mov	 DWORD PTR [rsp+48], eax
  00c5f	8b 84 24 e0 02
	00 00		 mov	 eax, DWORD PTR reqcyls$[rsp]
  00c66	89 44 24 28	 mov	 DWORD PTR [rsp+40], eax
  00c6a	0f b7 84 24 d8
	02 00 00	 movzx	 eax, WORD PTR devtype$[rsp]
  00c72	66 89 44 24 20	 mov	 WORD PTR [rsp+32], ax
  00c77	4c 8b 8c 24 c0
	02 00 00	 mov	 r9, QWORD PTR ofname$[rsp]
  00c7f	4c 8b 84 24 c8
	02 00 00	 mov	 r8, QWORD PTR cif$[rsp]
  00c87	8b 94 24 bc 00
	00 00		 mov	 edx, DWORD PTR numdscb$[rsp]
  00c8e	48 8b 8c 24 e0
	00 00 00	 mov	 rcx, QWORD PTR dscbtab$[rsp]
  00c96	e8 00 00 00 00	 call	 write_vtoc
  00c9b	89 84 24 b0 00
	00 00		 mov	 DWORD PTR rc$[rsp], eax

; 4146 :                     reqcyls, heads, trklen, vtoctrk, vtocext,
; 4147 :                     &outcyl, &outhead, volvtoc);
; 4148 :     if (rc < 0) return -1;

  00ca2	83 bc 24 b0 00
	00 00 00	 cmp	 DWORD PTR rc$[rsp], 0
  00caa	7d 0a		 jge	 SHORT $LN43@process_co
  00cac	b8 ff ff ff ff	 mov	 eax, -1
  00cb1	e9 35 03 00 00	 jmp	 $LN1@process_co
$LN43@process_co:
$LN10@process_co:

; 4149 : 
; 4150 :     /* Write empty tracks up to end of volume */
; 4151 :     while (outhead != 0 || outcyl < reqcyls)

  00cb6	83 bc 24 00 03
	00 00 00	 cmp	 DWORD PTR outhead$[rsp], 0
  00cbe	75 14		 jne	 SHORT $LN44@process_co
  00cc0	8b 84 24 e0 02
	00 00		 mov	 eax, DWORD PTR reqcyls$[rsp]
  00cc7	39 84 24 f8 02
	00 00		 cmp	 DWORD PTR outcyl$[rsp], eax
  00cce	0f 8d 58 01 00
	00		 jge	 $LN11@process_co
$LN44@process_co:

; 4152 :     {
; 4153 :         /* Issue free space information message */
; 4154 :         if (fsflag == 0)

  00cd4	83 bc 24 08 01
	00 00 00	 cmp	 DWORD PTR fsflag$[rsp], 0
  00cdc	75 56		 jne	 SHORT $LN45@process_co

; 4155 :         {
; 4156 :             XMINFF (1, MSG( HHC02568, "I", "****FREE SPACE****", outcyl, outcyl, outhead, outhead ) );

  00cde	8b 84 24 00 03
	00 00		 mov	 eax, DWORD PTR outhead$[rsp]
  00ce5	89 44 24 38	 mov	 DWORD PTR [rsp+56], eax
  00ce9	8b 84 24 00 03
	00 00		 mov	 eax, DWORD PTR outhead$[rsp]
  00cf0	89 44 24 30	 mov	 DWORD PTR [rsp+48], eax
  00cf4	8b 84 24 f8 02
	00 00		 mov	 eax, DWORD PTR outcyl$[rsp]
  00cfb	89 44 24 28	 mov	 DWORD PTR [rsp+40], eax
  00cff	8b 84 24 f8 02
	00 00		 mov	 eax, DWORD PTR outcyl$[rsp]
  00d06	89 44 24 20	 mov	 DWORD PTR [rsp+32], eax
  00d0a	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG162626
  00d11	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG162627
  00d18	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG162628
  00d1f	b9 01 00 00 00	 mov	 ecx, 1
  00d24	e8 00 00 00 00	 call	 info_msg

; 4157 :             fsflag = 1;

  00d29	c7 84 24 08 01
	00 00 01 00 00
	00		 mov	 DWORD PTR fsflag$[rsp], 1
$LN45@process_co:

; 4158 :         }
; 4159 : 
; 4160 :         /* Indicate output file progess */
; 4161 :         if ((outcyl % 10) == 0)

  00d34	8b 84 24 f8 02
	00 00		 mov	 eax, DWORD PTR outcyl$[rsp]
  00d3b	99		 cdq
  00d3c	b9 0a 00 00 00	 mov	 ecx, 10
  00d41	f7 f9		 idiv	 ecx
  00d43	8b c2		 mov	 eax, edx
  00d45	85 c0		 test	 eax, eax
  00d47	75 35		 jne	 SHORT $LN46@process_co
$LN14@process_co:

; 4162 :         {
; 4163 :             EXTGUIMSG( "OUTCYL=%d\n", outcyl );

  00d49	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_extgui
  00d50	83 38 00	 cmp	 DWORD PTR [rax], 0
  00d53	74 23		 je	 SHORT $LN47@process_co
  00d55	b9 02 00 00 00	 mov	 ecx, 2
  00d5a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  00d60	44 8b 84 24 f8
	02 00 00	 mov	 r8d, DWORD PTR outcyl$[rsp]
  00d68	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG162631
  00d6f	48 8b c8	 mov	 rcx, rax
  00d72	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_fprintf
$LN47@process_co:
  00d78	33 c0		 xor	 eax, eax
  00d7a	85 c0		 test	 eax, eax
  00d7c	75 cb		 jne	 SHORT $LN14@process_co
$LN46@process_co:

; 4164 :         }
; 4165 : 
; 4166 :         /* Initialize track buffer with empty track */
; 4167 :         init_track (trklen, cif->trkbuf, outcyl, outhead, &outusedv);

  00d7e	48 8d 84 24 cc
	00 00 00	 lea	 rax, QWORD PTR outusedv$[rsp]
  00d86	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00d8b	44 8b 8c 24 00
	03 00 00	 mov	 r9d, DWORD PTR outhead$[rsp]
  00d93	44 8b 84 24 f8
	02 00 00	 mov	 r8d, DWORD PTR outcyl$[rsp]
  00d9b	48 8b 84 24 c8
	02 00 00	 mov	 rax, QWORD PTR cif$[rsp]
  00da3	48 8b 50 10	 mov	 rdx, QWORD PTR [rax+16]
  00da7	8b 8c 24 f0 02
	00 00		 mov	 ecx, DWORD PTR trklen$[rsp]
  00dae	e8 00 00 00 00	 call	 init_track

; 4168 : 
; 4169 :         /* Write track to output file */
; 4170 :         rc = write_track (cif, ofname, heads, trklen,

  00db3	48 8d 84 24 00
	03 00 00	 lea	 rax, QWORD PTR outhead$[rsp]
  00dbb	48 89 44 24 38	 mov	 QWORD PTR [rsp+56], rax
  00dc0	48 8d 84 24 f8
	02 00 00	 lea	 rax, QWORD PTR outcyl$[rsp]
  00dc8	48 89 44 24 30	 mov	 QWORD PTR [rsp+48], rax
  00dcd	48 8d 84 24 b8
	00 00 00	 lea	 rax, QWORD PTR tracks$[rsp]
  00dd5	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  00dda	48 8d 84 24 cc
	00 00 00	 lea	 rax, QWORD PTR outusedv$[rsp]
  00de2	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00de7	44 8b 8c 24 f0
	02 00 00	 mov	 r9d, DWORD PTR trklen$[rsp]
  00def	44 8b 84 24 e8
	02 00 00	 mov	 r8d, DWORD PTR heads$[rsp]
  00df7	48 8b 94 24 c0
	02 00 00	 mov	 rdx, QWORD PTR ofname$[rsp]
  00dff	48 8b 8c 24 c8
	02 00 00	 mov	 rcx, QWORD PTR cif$[rsp]
  00e07	e8 00 00 00 00	 call	 write_track
  00e0c	89 84 24 b0 00
	00 00		 mov	 DWORD PTR rc$[rsp], eax

; 4171 :                         &outusedv, &tracks, &outcyl, &outhead);
; 4172 :         if (rc < 0) return -1;

  00e13	83 bc 24 b0 00
	00 00 00	 cmp	 DWORD PTR rc$[rsp], 0
  00e1b	7d 0a		 jge	 SHORT $LN48@process_co
  00e1d	b8 ff ff ff ff	 mov	 eax, -1
  00e22	e9 c4 01 00 00	 jmp	 $LN1@process_co
$LN48@process_co:

; 4173 : 
; 4174 :     } /* end while */

  00e27	e9 8a fe ff ff	 jmp	 $LN10@process_co
$LN11@process_co:

; 4175 : 
; 4176 :     if (outcyl > reqcyls && reqcyls != 0)

  00e2c	8b 84 24 e0 02
	00 00		 mov	 eax, DWORD PTR reqcyls$[rsp]
  00e33	39 84 24 f8 02
	00 00		 cmp	 DWORD PTR outcyl$[rsp], eax
  00e3a	7e 27		 jle	 SHORT $LN49@process_co
  00e3c	83 bc 24 e0 02
	00 00 00	 cmp	 DWORD PTR reqcyls$[rsp], 0
  00e44	74 1d		 je	 SHORT $LN49@process_co

; 4177 :     {
; 4178 :         XMINFF (0, MSG( HHC02590, "W", reqcyls ) );

  00e46	44 8b 8c 24 e0
	02 00 00	 mov	 r9d, DWORD PTR reqcyls$[rsp]
  00e4e	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG162634
  00e55	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG162635
  00e5c	33 c9		 xor	 ecx, ecx
  00e5e	e8 00 00 00 00	 call	 info_msg
$LN49@process_co:

; 4179 :     }
; 4180 : 
; 4181 :     XMINFF (0, MSG( HHC02591, "I", ofname, outcyl ) );

  00e63	8b 84 24 f8 02
	00 00		 mov	 eax, DWORD PTR outcyl$[rsp]
  00e6a	89 44 24 20	 mov	 DWORD PTR [rsp+32], eax
  00e6e	4c 8b 8c 24 c0
	02 00 00	 mov	 r9, QWORD PTR ofname$[rsp]
  00e76	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG162636
  00e7d	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG162637
  00e84	33 c9		 xor	 ecx, ecx
  00e86	e8 00 00 00 00	 call	 info_msg

; 4182 : 
; 4183 :     /* Update the VTOC pointer in the volume label */
; 4184 :     offset = CKD_TRKHDR_SIZE + CKD_R0_SIZE + CKD_R0_DLEN

  00e8b	c7 84 24 0c 01
	00 00 ec 00 00
	00		 mov	 DWORD PTR offset$[rsp], 236 ; 000000ecH

; 4185 :            + CKD_RECHDR_SIZE + IPL1_KEYLEN + IPL1_DATALEN
; 4186 :            + CKD_RECHDR_SIZE + IPL2_KEYLEN + IPL2_DATALEN
; 4187 :            + CKD_RECHDR_SIZE + VOL1_KEYLEN + offsetof( VOL1_CKD, vtoc_CC );
; 4188 : 
; 4189 :     XMINFF (5, MSG( HHC02592, "I", volvtoc[0], volvtoc[1], volvtoc[2], volvtoc[3], volvtoc[4] ) );

  00e96	b8 01 00 00 00	 mov	 eax, 1
  00e9b	48 6b c0 04	 imul	 rax, rax, 4
  00e9f	0f b6 84 04 48
	01 00 00	 movzx	 eax, BYTE PTR volvtoc$[rsp+rax]
  00ea7	b9 01 00 00 00	 mov	 ecx, 1
  00eac	48 6b c9 03	 imul	 rcx, rcx, 3
  00eb0	0f b6 8c 0c 48
	01 00 00	 movzx	 ecx, BYTE PTR volvtoc$[rsp+rcx]
  00eb8	ba 01 00 00 00	 mov	 edx, 1
  00ebd	48 6b d2 02	 imul	 rdx, rdx, 2
  00ec1	0f b6 94 14 48
	01 00 00	 movzx	 edx, BYTE PTR volvtoc$[rsp+rdx]
  00ec9	41 b8 01 00 00
	00		 mov	 r8d, 1
  00ecf	4d 6b c0 01	 imul	 r8, r8, 1
  00ed3	46 0f b6 84 04
	48 01 00 00	 movzx	 r8d, BYTE PTR volvtoc$[rsp+r8]
  00edc	41 b9 01 00 00
	00		 mov	 r9d, 1
  00ee2	4d 6b c9 00	 imul	 r9, r9, 0
  00ee6	46 0f b6 8c 0c
	48 01 00 00	 movzx	 r9d, BYTE PTR volvtoc$[rsp+r9]
  00eef	89 44 24 38	 mov	 DWORD PTR [rsp+56], eax
  00ef3	89 4c 24 30	 mov	 DWORD PTR [rsp+48], ecx
  00ef7	89 54 24 28	 mov	 DWORD PTR [rsp+40], edx
  00efb	44 89 44 24 20	 mov	 DWORD PTR [rsp+32], r8d
  00f00	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG162638
  00f07	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG162639
  00f0e	b9 05 00 00 00	 mov	 ecx, 5
  00f13	e8 00 00 00 00	 call	 info_msg

; 4190 : 
; 4191 :     rc = read_track (cif, 0, 0);

  00f18	45 33 c0	 xor	 r8d, r8d
  00f1b	33 d2		 xor	 edx, edx
  00f1d	48 8b 8c 24 c8
	02 00 00	 mov	 rcx, QWORD PTR cif$[rsp]
  00f25	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_read_track
  00f2b	89 84 24 b0 00
	00 00		 mov	 DWORD PTR rc$[rsp], eax

; 4192 :     if (rc < 0)

  00f32	83 bc 24 b0 00
	00 00 00	 cmp	 DWORD PTR rc$[rsp], 0
  00f3a	7d 1d		 jge	 SHORT $LN50@process_co

; 4193 :     {
; 4194 :         XMERR ( MSG( HHC02593, "E" ) );

  00f3c	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG162641
  00f43	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG162642
  00f4a	e8 00 00 00 00	 call	 printf

; 4195 :         return -1;

  00f4f	b8 ff ff ff ff	 mov	 eax, -1
  00f54	e9 92 00 00 00	 jmp	 $LN1@process_co
$LN50@process_co:

; 4196 :     }
; 4197 : 
; 4198 :     memcpy (cif->trkbuf + offset, volvtoc, sizeof(volvtoc));

  00f59	48 63 84 24 0c
	01 00 00	 movsxd	 rax, DWORD PTR offset$[rsp]
  00f61	48 8b 8c 24 c8
	02 00 00	 mov	 rcx, QWORD PTR cif$[rsp]
  00f69	48 8b 49 10	 mov	 rcx, QWORD PTR [rcx+16]
  00f6d	48 8d 94 24 48
	01 00 00	 lea	 rdx, QWORD PTR volvtoc$[rsp]
  00f75	48 8d 3c 01	 lea	 rdi, QWORD PTR [rcx+rax]
  00f79	48 8b f2	 mov	 rsi, rdx
  00f7c	b9 05 00 00 00	 mov	 ecx, 5
  00f81	f3 a4		 rep movsb

; 4199 :     cif->trkmodif = 1;

  00f83	48 8b 84 24 c8
	02 00 00	 mov	 rax, QWORD PTR cif$[rsp]
  00f8b	c7 40 20 01 00
	00 00		 mov	 DWORD PTR [rax+32], 1

; 4200 : 
; 4201 :     /* Release the DSCB buffers */
; 4202 :     for (i = 0; i < numdscb; i++)

  00f92	c7 84 24 d0 00
	00 00 00 00 00
	00		 mov	 DWORD PTR i$[rsp], 0
  00f9d	eb 10		 jmp	 SHORT $LN17@process_co
$LN15@process_co:
  00f9f	8b 84 24 d0 00
	00 00		 mov	 eax, DWORD PTR i$[rsp]
  00fa6	ff c0		 inc	 eax
  00fa8	89 84 24 d0 00
	00 00		 mov	 DWORD PTR i$[rsp], eax
$LN17@process_co:
  00faf	8b 84 24 bc 00
	00 00		 mov	 eax, DWORD PTR numdscb$[rsp]
  00fb6	39 84 24 d0 00
	00 00		 cmp	 DWORD PTR i$[rsp], eax
  00fbd	7d 1c		 jge	 SHORT $LN16@process_co

; 4203 :         free (dscbtab[i]);

  00fbf	48 63 84 24 d0
	00 00 00	 movsxd	 rax, DWORD PTR i$[rsp]
  00fc7	48 8b 8c 24 e0
	00 00 00	 mov	 rcx, QWORD PTR dscbtab$[rsp]
  00fcf	48 8b 0c c1	 mov	 rcx, QWORD PTR [rcx+rax*8]
  00fd3	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free
  00fd9	eb c4		 jmp	 SHORT $LN15@process_co
$LN16@process_co:

; 4204 : 
; 4205 :     /* Release the array of DSCB pointers */
; 4206 :     free (dscbtab);

  00fdb	48 8b 8c 24 e0
	00 00 00	 mov	 rcx, QWORD PTR dscbtab$[rsp]
  00fe3	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free

; 4207 : 
; 4208 :     return 0;

  00fe9	33 c0		 xor	 eax, eax
$LN1@process_co:

; 4209 : 
; 4210 : } /* end function process_control_file */

  00feb	48 8b 8c 24 80
	02 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  00ff3	48 33 cc	 xor	 rcx, rsp
  00ff6	e8 00 00 00 00	 call	 __security_check_cookie
  00ffb	48 81 c4 98 02
	00 00		 add	 rsp, 664		; 00000298H
  01002	5f		 pop	 rdi
  01003	5e		 pop	 rsi
  01004	c3		 ret	 0
  01005	0f 1f 00	 npad	 3
$LN60@process_co:
  01008	00 00 00 00	 DD	 $LN36@process_co
  0100c	00 00 00 00	 DD	 $LN25@process_co
  01010	00 00 00 00	 DD	 $LN28@process_co
  01014	00 00 00 00	 DD	 $LN30@process_co
  01018	00 00 00 00	 DD	 $LN32@process_co
  0101c	00 00 00 00	 DD	 $LN26@process_co
  01020	00 00 00 00	 DD	 $LN33@process_co
process_control_file ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\dasdload64.c
_TEXT	SEGMENT
c$ = 48
strtok_str$ = 56
pimeth$ = 64
precfm$ = 72
punits$ = 80
pdsorg$ = 88
pdsnam$ = 96
psppri$ = 104
pspsec$ = 112
pspdir$ = 120
plrecl$ = 128
pblksz$ = 136
pkeyln$ = 144
pifile$ = 152
stmt$ = 176
dsname$ = 184
method$ = 192
ifptr$ = 200
units$ = 208
sppri$ = 216
spsec$ = 224
spdir$ = 232
dsorg$ = 240
recfm$ = 248
lrecl$ = 256
blksz$ = 264
keyln$ = 272
parse_ctrl_stmt PROC

; 3701 : {

  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	57		 push	 rdi
  00015	48 81 ec a0 00
	00 00		 sub	 rsp, 160		; 000000a0H

; 3702 : char           *pdsnam;                 /* -> dsname in input stmt   */
; 3703 : char           *punits;                 /* -> allocation units       */
; 3704 : char           *psppri;                 /* -> primary space quantity */
; 3705 : char           *pspsec;                 /* -> secondary space qty.   */
; 3706 : char           *pspdir;                 /* -> directory space qty.   */
; 3707 : char           *pdsorg;                 /* -> dataset organization   */
; 3708 : char           *precfm;                 /* -> record format          */
; 3709 : char           *plrecl;                 /* -> logical record length  */
; 3710 : char           *pblksz;                 /* -> block size             */
; 3711 : char           *pkeyln;                 /* -> key length             */
; 3712 : char           *pimeth;                 /* -> initialization method  */
; 3713 : char           *pifile;                 /* -> initialization filename*/
; 3714 : BYTE            c;                      /* Character work area       */
; 3715 : char           *strtok_str = NULL;      /* last token                */

  0001c	48 c7 44 24 38
	00 00 00 00	 mov	 QWORD PTR strtok_str$[rsp], 0

; 3716 : 
; 3717 :     /* Parse the input statement */
; 3718 :     pdsnam = strtok_r (stmt, " \t", &strtok_str);

  00025	4c 8d 44 24 38	 lea	 r8, QWORD PTR strtok_str$[rsp]
  0002a	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG162360
  00031	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR stmt$[rsp]
  00039	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_strtok_r
  0003f	48 89 44 24 60	 mov	 QWORD PTR pdsnam$[rsp], rax

; 3719 :     pimeth = strtok_r (NULL, " \t", &strtok_str);

  00044	4c 8d 44 24 38	 lea	 r8, QWORD PTR strtok_str$[rsp]
  00049	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG162361
  00050	33 c9		 xor	 ecx, ecx
  00052	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_strtok_r
  00058	48 89 44 24 40	 mov	 QWORD PTR pimeth$[rsp], rax

; 3720 : 
; 3721 :     /* Check that all mandatory fields are present */
; 3722 :     if (pdsnam == NULL || pimeth == NULL)

  0005d	48 83 7c 24 60
	00		 cmp	 QWORD PTR pdsnam$[rsp], 0
  00063	74 08		 je	 SHORT $LN3@parse_ctrl
  00065	48 83 7c 24 40
	00		 cmp	 QWORD PTR pimeth$[rsp], 0
  0006b	75 4e		 jne	 SHORT $LN2@parse_ctrl
$LN3@parse_ctrl:

; 3723 :     {
; 3724 :         if (pdsnam == NULL)

  0006d	48 83 7c 24 60
	00		 cmp	 QWORD PTR pdsnam$[rsp], 0
  00073	75 1a		 jne	 SHORT $LN4@parse_ctrl

; 3725 :             XMERR ( MSG(HHC02578, "E", "DSNAME" ) );

  00075	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG162365
  0007c	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG162366
  00083	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG162367
  0008a	e8 00 00 00 00	 call	 printf
$LN4@parse_ctrl:

; 3726 :         if (pimeth == NULL)

  0008f	48 83 7c 24 40
	00		 cmp	 QWORD PTR pimeth$[rsp], 0
  00095	75 1a		 jne	 SHORT $LN5@parse_ctrl

; 3727 :             XMERR ( MSG(HHC02578, "E", "Initialization method" ) );

  00097	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG162369
  0009e	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG162370
  000a5	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG162371
  000ac	e8 00 00 00 00	 call	 printf
$LN5@parse_ctrl:

; 3728 :         return -1;

  000b1	b8 ff ff ff ff	 mov	 eax, -1
  000b6	e9 2b 08 00 00	 jmp	 $LN1@parse_ctrl
$LN2@parse_ctrl:

; 3729 :     }
; 3730 : 
; 3731 :     /* Return the dataset name in EBCDIC and ASCII */
; 3732 :     string_to_upper (pdsnam);

  000bb	48 8b 4c 24 60	 mov	 rcx, QWORD PTR pdsnam$[rsp]
  000c0	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_string_to_upper

; 3733 :     memset (dsname, 0, 45);

  000c6	48 8b bc 24 b8
	00 00 00	 mov	 rdi, QWORD PTR dsname$[rsp]
  000ce	33 c0		 xor	 eax, eax
  000d0	b9 2d 00 00 00	 mov	 ecx, 45			; 0000002dH
  000d5	f3 aa		 rep stosb

; 3734 :     strncpy (dsname, pdsnam, 44);

  000d7	41 b8 2c 00 00
	00		 mov	 r8d, 44			; 0000002cH
  000dd	48 8b 54 24 60	 mov	 rdx, QWORD PTR pdsnam$[rsp]
  000e2	48 8b 8c 24 b8
	00 00 00	 mov	 rcx, QWORD PTR dsname$[rsp]
  000ea	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_strncpy

; 3735 : 
; 3736 :     /* Set default dataset attribute values */
; 3737 :     *units = 'T';

  000f0	48 8b 84 24 d0
	00 00 00	 mov	 rax, QWORD PTR units$[rsp]
  000f8	c6 00 54	 mov	 BYTE PTR [rax], 84	; 00000054H

; 3738 :     *sppri = 1;

  000fb	48 8b 84 24 d8
	00 00 00	 mov	 rax, QWORD PTR sppri$[rsp]
  00103	c7 00 01 00 00
	00		 mov	 DWORD PTR [rax], 1

; 3739 :     *spsec = 0;

  00109	48 8b 84 24 e0
	00 00 00	 mov	 rax, QWORD PTR spsec$[rsp]
  00111	c7 00 00 00 00
	00		 mov	 DWORD PTR [rax], 0

; 3740 :     *spdir = 0;

  00117	48 8b 84 24 e8
	00 00 00	 mov	 rax, QWORD PTR spdir$[rsp]
  0011f	c7 00 00 00 00
	00		 mov	 DWORD PTR [rax], 0

; 3741 :     *dsorg = 0x00;

  00125	48 8b 84 24 f0
	00 00 00	 mov	 rax, QWORD PTR dsorg$[rsp]
  0012d	c6 00 00	 mov	 BYTE PTR [rax], 0

; 3742 :     *recfm = 0x00;

  00130	48 8b 84 24 f8
	00 00 00	 mov	 rax, QWORD PTR recfm$[rsp]
  00138	c6 00 00	 mov	 BYTE PTR [rax], 0

; 3743 :     *lrecl = 0;

  0013b	48 8b 84 24 00
	01 00 00	 mov	 rax, QWORD PTR lrecl$[rsp]
  00143	c7 00 00 00 00
	00		 mov	 DWORD PTR [rax], 0

; 3744 :     *blksz = 0;

  00149	48 8b 84 24 08
	01 00 00	 mov	 rax, QWORD PTR blksz$[rsp]
  00151	c7 00 00 00 00
	00		 mov	 DWORD PTR [rax], 0

; 3745 :     *keyln = 0;

  00157	48 8b 84 24 10
	01 00 00	 mov	 rax, QWORD PTR keyln$[rsp]
  0015f	c7 00 00 00 00
	00		 mov	 DWORD PTR [rax], 0

; 3746 :     *ifptr = NULL;

  00165	48 8b 84 24 c8
	00 00 00	 mov	 rax, QWORD PTR ifptr$[rsp]
  0016d	48 c7 00 00 00
	00 00		 mov	 QWORD PTR [rax], 0

; 3747 : 
; 3748 :     /* Test for valid initialization method */
; 3749 :     if (strcasecmp(pimeth, "XMIT") == 0)

  00174	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG162374
  0017b	48 8b 4c 24 40	 mov	 rcx, QWORD PTR pimeth$[rsp]
  00180	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__stricmp
  00186	85 c0		 test	 eax, eax
  00188	75 10		 jne	 SHORT $LN6@parse_ctrl

; 3750 :         *method = METHOD_XMIT;

  0018a	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR method$[rsp]
  00192	c6 00 01	 mov	 BYTE PTR [rax], 1
  00195	e9 fd 00 00 00	 jmp	 $LN7@parse_ctrl
$LN6@parse_ctrl:

; 3751 :     else if (strcasecmp(pimeth, "VS") == 0)

  0019a	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG162377
  001a1	48 8b 4c 24 40	 mov	 rcx, QWORD PTR pimeth$[rsp]
  001a6	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__stricmp
  001ac	85 c0		 test	 eax, eax
  001ae	75 10		 jne	 SHORT $LN8@parse_ctrl

; 3752 :         *method = METHOD_VS;

  001b0	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR method$[rsp]
  001b8	c6 00 05	 mov	 BYTE PTR [rax], 5
  001bb	e9 d7 00 00 00	 jmp	 $LN9@parse_ctrl
$LN8@parse_ctrl:

; 3753 :     else if (strcasecmp(pimeth, "EMPTY") == 0)

  001c0	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG162380
  001c7	48 8b 4c 24 40	 mov	 rcx, QWORD PTR pimeth$[rsp]
  001cc	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__stricmp
  001d2	85 c0		 test	 eax, eax
  001d4	75 10		 jne	 SHORT $LN10@parse_ctrl

; 3754 :         *method = METHOD_EMPTY;

  001d6	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR method$[rsp]
  001de	c6 00 00	 mov	 BYTE PTR [rax], 0
  001e1	e9 b1 00 00 00	 jmp	 $LN11@parse_ctrl
$LN10@parse_ctrl:

; 3755 :     else if (strcasecmp(pimeth, "DIP") == 0)

  001e6	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG162383
  001ed	48 8b 4c 24 40	 mov	 rcx, QWORD PTR pimeth$[rsp]
  001f2	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__stricmp
  001f8	85 c0		 test	 eax, eax
  001fa	75 10		 jne	 SHORT $LN12@parse_ctrl

; 3756 :         *method = METHOD_DIP;

  001fc	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR method$[rsp]
  00204	c6 00 02	 mov	 BYTE PTR [rax], 2
  00207	e9 8b 00 00 00	 jmp	 $LN13@parse_ctrl
$LN12@parse_ctrl:

; 3757 :     else if (strcasecmp(pimeth, "CVOL") == 0)

  0020c	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG162386
  00213	48 8b 4c 24 40	 mov	 rcx, QWORD PTR pimeth$[rsp]
  00218	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__stricmp
  0021e	85 c0		 test	 eax, eax
  00220	75 0d		 jne	 SHORT $LN14@parse_ctrl

; 3758 :         *method = METHOD_CVOL;

  00222	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR method$[rsp]
  0022a	c6 00 03	 mov	 BYTE PTR [rax], 3
  0022d	eb 68		 jmp	 SHORT $LN15@parse_ctrl
$LN14@parse_ctrl:

; 3759 :     else if (strcasecmp(pimeth, "VTOC") == 0)

  0022f	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG162389
  00236	48 8b 4c 24 40	 mov	 rcx, QWORD PTR pimeth$[rsp]
  0023b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__stricmp
  00241	85 c0		 test	 eax, eax
  00243	75 0d		 jne	 SHORT $LN16@parse_ctrl

; 3760 :         *method = METHOD_VTOC;

  00245	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR method$[rsp]
  0024d	c6 00 04	 mov	 BYTE PTR [rax], 4
  00250	eb 45		 jmp	 SHORT $LN17@parse_ctrl
$LN16@parse_ctrl:

; 3761 :     else if (strcasecmp(pimeth, "SEQ") == 0)

  00252	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG162392
  00259	48 8b 4c 24 40	 mov	 rcx, QWORD PTR pimeth$[rsp]
  0025e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__stricmp
  00264	85 c0		 test	 eax, eax
  00266	75 0d		 jne	 SHORT $LN18@parse_ctrl

; 3762 :         *method = METHOD_SEQ;

  00268	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR method$[rsp]
  00270	c6 00 06	 mov	 BYTE PTR [rax], 6
  00273	eb 22		 jmp	 SHORT $LN19@parse_ctrl
$LN18@parse_ctrl:

; 3763 :     else
; 3764 :     {
; 3765 :         XMERRF ( MSG( HHC02579, "E", pimeth ) );

  00275	4c 8b 44 24 40	 mov	 r8, QWORD PTR pimeth$[rsp]
  0027a	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG162393
  00281	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG162394
  00288	e8 00 00 00 00	 call	 printf

; 3766 :         return -1;

  0028d	b8 ff ff ff ff	 mov	 eax, -1
  00292	e9 4f 06 00 00	 jmp	 $LN1@parse_ctrl
$LN19@parse_ctrl:
$LN17@parse_ctrl:
$LN15@parse_ctrl:
$LN13@parse_ctrl:
$LN11@parse_ctrl:
$LN9@parse_ctrl:
$LN7@parse_ctrl:

; 3767 :     }
; 3768 : 
; 3769 :     /* Locate the initialization file name */
; 3770 :     if (*method == METHOD_XMIT || *method == METHOD_VS || *method == METHOD_SEQ)

  00297	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR method$[rsp]
  0029f	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  002a2	83 f8 01	 cmp	 eax, 1
  002a5	74 20		 je	 SHORT $LN21@parse_ctrl
  002a7	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR method$[rsp]
  002af	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  002b2	83 f8 05	 cmp	 eax, 5
  002b5	74 10		 je	 SHORT $LN21@parse_ctrl
  002b7	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR method$[rsp]
  002bf	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  002c2	83 f8 06	 cmp	 eax, 6
  002c5	75 57		 jne	 SHORT $LN20@parse_ctrl
$LN21@parse_ctrl:

; 3771 :     {
; 3772 :         pifile = strtok_r (NULL, " \t", &strtok_str);

  002c7	4c 8d 44 24 38	 lea	 r8, QWORD PTR strtok_str$[rsp]
  002cc	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG162397
  002d3	33 c9		 xor	 ecx, ecx
  002d5	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_strtok_r
  002db	48 89 84 24 98
	00 00 00	 mov	 QWORD PTR pifile$[rsp], rax

; 3773 :         if (pifile == NULL)

  002e3	48 83 bc 24 98
	00 00 00 00	 cmp	 QWORD PTR pifile$[rsp], 0
  002ec	75 1d		 jne	 SHORT $LN22@parse_ctrl

; 3774 :         {
; 3775 :             XMERR ( MSG( HHC02580, "E" ) );

  002ee	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG162399
  002f5	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG162400
  002fc	e8 00 00 00 00	 call	 printf

; 3776 :             return -1;

  00301	b8 ff ff ff ff	 mov	 eax, -1
  00306	e9 db 05 00 00	 jmp	 $LN1@parse_ctrl
$LN22@parse_ctrl:

; 3777 :         }
; 3778 :         *ifptr = pifile;

  0030b	48 8b 84 24 c8
	00 00 00	 mov	 rax, QWORD PTR ifptr$[rsp]
  00313	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR pifile$[rsp]
  0031b	48 89 08	 mov	 QWORD PTR [rax], rcx
$LN20@parse_ctrl:

; 3779 :     }
; 3780 : 
; 3781 :     /* Determine the space allocation units */
; 3782 :     punits = strtok_r (NULL, " \t", &strtok_str );

  0031e	4c 8d 44 24 38	 lea	 r8, QWORD PTR strtok_str$[rsp]
  00323	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG162401
  0032a	33 c9		 xor	 ecx, ecx
  0032c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_strtok_r
  00332	48 89 44 24 50	 mov	 QWORD PTR punits$[rsp], rax

; 3783 :     if (punits == NULL) return 0;

  00337	48 83 7c 24 50
	00		 cmp	 QWORD PTR punits$[rsp], 0
  0033d	75 07		 jne	 SHORT $LN23@parse_ctrl
  0033f	33 c0		 xor	 eax, eax
  00341	e9 a0 05 00 00	 jmp	 $LN1@parse_ctrl
$LN23@parse_ctrl:

; 3784 : 
; 3785 :     string_to_upper (punits);

  00346	48 8b 4c 24 50	 mov	 rcx, QWORD PTR punits$[rsp]
  0034b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_string_to_upper

; 3786 :     if (strcmp(punits, "CYL") == 0)

  00351	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG162405
  00358	48 8b 4c 24 50	 mov	 rcx, QWORD PTR punits$[rsp]
  0035d	e8 00 00 00 00	 call	 strcmp
  00362	85 c0		 test	 eax, eax
  00364	75 0d		 jne	 SHORT $LN24@parse_ctrl

; 3787 :         *units = 'C';

  00366	48 8b 84 24 d0
	00 00 00	 mov	 rax, QWORD PTR units$[rsp]
  0036e	c6 00 43	 mov	 BYTE PTR [rax], 67	; 00000043H
  00371	eb 44		 jmp	 SHORT $LN25@parse_ctrl
$LN24@parse_ctrl:

; 3788 :     else if (strcmp(punits, "TRK") == 0)

  00373	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG162408
  0037a	48 8b 4c 24 50	 mov	 rcx, QWORD PTR punits$[rsp]
  0037f	e8 00 00 00 00	 call	 strcmp
  00384	85 c0		 test	 eax, eax
  00386	75 0d		 jne	 SHORT $LN26@parse_ctrl

; 3789 :         *units = 'T';

  00388	48 8b 84 24 d0
	00 00 00	 mov	 rax, QWORD PTR units$[rsp]
  00390	c6 00 54	 mov	 BYTE PTR [rax], 84	; 00000054H
  00393	eb 22		 jmp	 SHORT $LN27@parse_ctrl
$LN26@parse_ctrl:

; 3790 :     else
; 3791 :     {
; 3792 :         XMERRF ( MSG( HHC02581, "E", punits ) );

  00395	4c 8b 44 24 50	 mov	 r8, QWORD PTR punits$[rsp]
  0039a	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG162409
  003a1	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG162410
  003a8	e8 00 00 00 00	 call	 printf

; 3793 :         return -1;

  003ad	b8 ff ff ff ff	 mov	 eax, -1
  003b2	e9 2f 05 00 00	 jmp	 $LN1@parse_ctrl
$LN27@parse_ctrl:
$LN25@parse_ctrl:

; 3794 :     }
; 3795 : 
; 3796 :     /* Determine the primary space allocation quantity */
; 3797 :     psppri = strtok_r (NULL, " \t", &strtok_str);

  003b7	4c 8d 44 24 38	 lea	 r8, QWORD PTR strtok_str$[rsp]
  003bc	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG162411
  003c3	33 c9		 xor	 ecx, ecx
  003c5	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_strtok_r
  003cb	48 89 44 24 68	 mov	 QWORD PTR psppri$[rsp], rax

; 3798 :     if (psppri == NULL) return 0;

  003d0	48 83 7c 24 68
	00		 cmp	 QWORD PTR psppri$[rsp], 0
  003d6	75 07		 jne	 SHORT $LN28@parse_ctrl
  003d8	33 c0		 xor	 eax, eax
  003da	e9 07 05 00 00	 jmp	 $LN1@parse_ctrl
$LN28@parse_ctrl:

; 3799 : 
; 3800 :     if (sscanf(psppri, "%u%c", sppri, &c) != 1)

  003df	4c 8d 4c 24 30	 lea	 r9, QWORD PTR c$[rsp]
  003e4	4c 8b 84 24 d8
	00 00 00	 mov	 r8, QWORD PTR sppri$[rsp]
  003ec	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG162414
  003f3	48 8b 4c 24 68	 mov	 rcx, QWORD PTR psppri$[rsp]
  003f8	e8 00 00 00 00	 call	 sscanf
  003fd	83 f8 01	 cmp	 eax, 1
  00400	74 33		 je	 SHORT $LN29@parse_ctrl

; 3801 :     {
; 3802 :         XMERRF ( MSG( HHC02582, "E", "Primary", psppri, punits ) );

  00402	48 8b 44 24 50	 mov	 rax, QWORD PTR punits$[rsp]
  00407	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  0040c	4c 8b 4c 24 68	 mov	 r9, QWORD PTR psppri$[rsp]
  00411	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG162415
  00418	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG162416
  0041f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG162417
  00426	e8 00 00 00 00	 call	 printf

; 3803 :         return -1;

  0042b	b8 ff ff ff ff	 mov	 eax, -1
  00430	e9 b1 04 00 00	 jmp	 $LN1@parse_ctrl
$LN29@parse_ctrl:

; 3804 :     }
; 3805 : 
; 3806 :     /* Determine the secondary space allocation quantity */
; 3807 :     pspsec = strtok_r (NULL, " \t", &strtok_str);

  00435	4c 8d 44 24 38	 lea	 r8, QWORD PTR strtok_str$[rsp]
  0043a	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG162418
  00441	33 c9		 xor	 ecx, ecx
  00443	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_strtok_r
  00449	48 89 44 24 70	 mov	 QWORD PTR pspsec$[rsp], rax

; 3808 :     if (pspsec == NULL) return 0;

  0044e	48 83 7c 24 70
	00		 cmp	 QWORD PTR pspsec$[rsp], 0
  00454	75 07		 jne	 SHORT $LN30@parse_ctrl
  00456	33 c0		 xor	 eax, eax
  00458	e9 89 04 00 00	 jmp	 $LN1@parse_ctrl
$LN30@parse_ctrl:

; 3809 : 
; 3810 :     if (sscanf(pspsec, "%u%c", spsec, &c) != 1)

  0045d	4c 8d 4c 24 30	 lea	 r9, QWORD PTR c$[rsp]
  00462	4c 8b 84 24 e0
	00 00 00	 mov	 r8, QWORD PTR spsec$[rsp]
  0046a	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG162421
  00471	48 8b 4c 24 70	 mov	 rcx, QWORD PTR pspsec$[rsp]
  00476	e8 00 00 00 00	 call	 sscanf
  0047b	83 f8 01	 cmp	 eax, 1
  0047e	74 33		 je	 SHORT $LN31@parse_ctrl

; 3811 :     {
; 3812 :         XMERRF ( MSG( HHC02582, "E", "Secondary", pspsec, punits ) );

  00480	48 8b 44 24 50	 mov	 rax, QWORD PTR punits$[rsp]
  00485	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  0048a	4c 8b 4c 24 70	 mov	 r9, QWORD PTR pspsec$[rsp]
  0048f	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG162422
  00496	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG162423
  0049d	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG162424
  004a4	e8 00 00 00 00	 call	 printf

; 3813 :         return -1;

  004a9	b8 ff ff ff ff	 mov	 eax, -1
  004ae	e9 33 04 00 00	 jmp	 $LN1@parse_ctrl
$LN31@parse_ctrl:

; 3814 :     }
; 3815 : 
; 3816 :     /* Determine the directory space allocation quantity */
; 3817 :     pspdir = strtok_r (NULL, " \t", &strtok_str);

  004b3	4c 8d 44 24 38	 lea	 r8, QWORD PTR strtok_str$[rsp]
  004b8	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG162425
  004bf	33 c9		 xor	 ecx, ecx
  004c1	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_strtok_r
  004c7	48 89 44 24 78	 mov	 QWORD PTR pspdir$[rsp], rax

; 3818 :     if (pspdir == NULL) return 0;

  004cc	48 83 7c 24 78
	00		 cmp	 QWORD PTR pspdir$[rsp], 0
  004d2	75 07		 jne	 SHORT $LN32@parse_ctrl
  004d4	33 c0		 xor	 eax, eax
  004d6	e9 0b 04 00 00	 jmp	 $LN1@parse_ctrl
$LN32@parse_ctrl:

; 3819 : 
; 3820 :     if (sscanf(pspdir, "%u%c", spdir, &c) != 1)

  004db	4c 8d 4c 24 30	 lea	 r9, QWORD PTR c$[rsp]
  004e0	4c 8b 84 24 e8
	00 00 00	 mov	 r8, QWORD PTR spdir$[rsp]
  004e8	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG162428
  004ef	48 8b 4c 24 78	 mov	 rcx, QWORD PTR pspdir$[rsp]
  004f4	e8 00 00 00 00	 call	 sscanf
  004f9	83 f8 01	 cmp	 eax, 1
  004fc	74 22		 je	 SHORT $LN33@parse_ctrl

; 3821 :     {
; 3822 :         XMERRF ( MSG( HHC02583, "E", pspdir ) );

  004fe	4c 8b 44 24 78	 mov	 r8, QWORD PTR pspdir$[rsp]
  00503	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG162429
  0050a	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG162430
  00511	e8 00 00 00 00	 call	 printf

; 3823 :         return -1;

  00516	b8 ff ff ff ff	 mov	 eax, -1
  0051b	e9 c6 03 00 00	 jmp	 $LN1@parse_ctrl
$LN33@parse_ctrl:

; 3824 :     }
; 3825 : 
; 3826 :     /* Determine the dataset organization */
; 3827 :     pdsorg = strtok_r (NULL, " \t", &strtok_str);

  00520	4c 8d 44 24 38	 lea	 r8, QWORD PTR strtok_str$[rsp]
  00525	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG162431
  0052c	33 c9		 xor	 ecx, ecx
  0052e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_strtok_r
  00534	48 89 44 24 58	 mov	 QWORD PTR pdsorg$[rsp], rax

; 3828 :     if (pdsorg == NULL) return 0;

  00539	48 83 7c 24 58
	00		 cmp	 QWORD PTR pdsorg$[rsp], 0
  0053f	75 07		 jne	 SHORT $LN34@parse_ctrl
  00541	33 c0		 xor	 eax, eax
  00543	e9 9e 03 00 00	 jmp	 $LN1@parse_ctrl
$LN34@parse_ctrl:

; 3829 : 
; 3830 :     string_to_upper (pdsorg);

  00548	48 8b 4c 24 58	 mov	 rcx, QWORD PTR pdsorg$[rsp]
  0054d	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_string_to_upper

; 3831 :     if (strcmp(pdsorg, "IS") == 0)

  00553	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG162435
  0055a	48 8b 4c 24 58	 mov	 rcx, QWORD PTR pdsorg$[rsp]
  0055f	e8 00 00 00 00	 call	 strcmp
  00564	85 c0		 test	 eax, eax
  00566	75 10		 jne	 SHORT $LN35@parse_ctrl

; 3832 :         *dsorg = DSORG_IS;

  00568	48 8b 84 24 f0
	00 00 00	 mov	 rax, QWORD PTR dsorg$[rsp]
  00570	c6 00 80	 mov	 BYTE PTR [rax], 128	; 00000080H
  00573	e9 88 00 00 00	 jmp	 $LN36@parse_ctrl
$LN35@parse_ctrl:

; 3833 :     else if (strcmp(pdsorg, "PS") == 0)

  00578	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG162438
  0057f	48 8b 4c 24 58	 mov	 rcx, QWORD PTR pdsorg$[rsp]
  00584	e8 00 00 00 00	 call	 strcmp
  00589	85 c0		 test	 eax, eax
  0058b	75 0d		 jne	 SHORT $LN37@parse_ctrl

; 3834 :         *dsorg = DSORG_PS;

  0058d	48 8b 84 24 f0
	00 00 00	 mov	 rax, QWORD PTR dsorg$[rsp]
  00595	c6 00 40	 mov	 BYTE PTR [rax], 64	; 00000040H
  00598	eb 66		 jmp	 SHORT $LN38@parse_ctrl
$LN37@parse_ctrl:

; 3835 :     else if (strcmp(pdsorg, "DA") == 0)

  0059a	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG162441
  005a1	48 8b 4c 24 58	 mov	 rcx, QWORD PTR pdsorg$[rsp]
  005a6	e8 00 00 00 00	 call	 strcmp
  005ab	85 c0		 test	 eax, eax
  005ad	75 0d		 jne	 SHORT $LN39@parse_ctrl

; 3836 :         *dsorg = DSORG_DA;

  005af	48 8b 84 24 f0
	00 00 00	 mov	 rax, QWORD PTR dsorg$[rsp]
  005b7	c6 00 20	 mov	 BYTE PTR [rax], 32	; 00000020H
  005ba	eb 44		 jmp	 SHORT $LN40@parse_ctrl
$LN39@parse_ctrl:

; 3837 :     else if (strcmp(pdsorg, "PO") == 0)

  005bc	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG162444
  005c3	48 8b 4c 24 58	 mov	 rcx, QWORD PTR pdsorg$[rsp]
  005c8	e8 00 00 00 00	 call	 strcmp
  005cd	85 c0		 test	 eax, eax
  005cf	75 0d		 jne	 SHORT $LN41@parse_ctrl

; 3838 :         *dsorg = DSORG_PO;

  005d1	48 8b 84 24 f0
	00 00 00	 mov	 rax, QWORD PTR dsorg$[rsp]
  005d9	c6 00 02	 mov	 BYTE PTR [rax], 2
  005dc	eb 22		 jmp	 SHORT $LN42@parse_ctrl
$LN41@parse_ctrl:

; 3839 :     else
; 3840 :     {
; 3841 :         XMERRF ( MSG( HHC02584, "E", pdsorg ) );

  005de	4c 8b 44 24 58	 mov	 r8, QWORD PTR pdsorg$[rsp]
  005e3	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG162445
  005ea	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG162446
  005f1	e8 00 00 00 00	 call	 printf

; 3842 :         return -1;

  005f6	b8 ff ff ff ff	 mov	 eax, -1
  005fb	e9 e6 02 00 00	 jmp	 $LN1@parse_ctrl
$LN42@parse_ctrl:
$LN40@parse_ctrl:
$LN38@parse_ctrl:
$LN36@parse_ctrl:

; 3843 :     }
; 3844 : 
; 3845 :     /* Determine the record format */
; 3846 :     precfm = strtok_r (NULL, " \t", &strtok_str);

  00600	4c 8d 44 24 38	 lea	 r8, QWORD PTR strtok_str$[rsp]
  00605	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG162447
  0060c	33 c9		 xor	 ecx, ecx
  0060e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_strtok_r
  00614	48 89 44 24 48	 mov	 QWORD PTR precfm$[rsp], rax

; 3847 :     if (precfm == NULL) return 0;

  00619	48 83 7c 24 48
	00		 cmp	 QWORD PTR precfm$[rsp], 0
  0061f	75 07		 jne	 SHORT $LN43@parse_ctrl
  00621	33 c0		 xor	 eax, eax
  00623	e9 be 02 00 00	 jmp	 $LN1@parse_ctrl
$LN43@parse_ctrl:

; 3848 : 
; 3849 :     string_to_upper (precfm);

  00628	48 8b 4c 24 48	 mov	 rcx, QWORD PTR precfm$[rsp]
  0062d	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_string_to_upper

; 3850 :     if (strcmp(precfm, "F") == 0)

  00633	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG162451
  0063a	48 8b 4c 24 48	 mov	 rcx, QWORD PTR precfm$[rsp]
  0063f	e8 00 00 00 00	 call	 strcmp
  00644	85 c0		 test	 eax, eax
  00646	75 10		 jne	 SHORT $LN44@parse_ctrl

; 3851 :         *recfm = RECFM_FORMAT_F;

  00648	48 8b 84 24 f8
	00 00 00	 mov	 rax, QWORD PTR recfm$[rsp]
  00650	c6 00 80	 mov	 BYTE PTR [rax], 128	; 00000080H
  00653	e9 f7 00 00 00	 jmp	 $LN45@parse_ctrl
$LN44@parse_ctrl:

; 3852 :     else if (strcmp(precfm, "FB") == 0)

  00658	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG162454
  0065f	48 8b 4c 24 48	 mov	 rcx, QWORD PTR precfm$[rsp]
  00664	e8 00 00 00 00	 call	 strcmp
  00669	85 c0		 test	 eax, eax
  0066b	75 10		 jne	 SHORT $LN46@parse_ctrl

; 3853 :         *recfm = RECFM_FORMAT_F | RECFM_BLOCKED;

  0066d	48 8b 84 24 f8
	00 00 00	 mov	 rax, QWORD PTR recfm$[rsp]
  00675	c6 00 90	 mov	 BYTE PTR [rax], 144	; 00000090H
  00678	e9 d2 00 00 00	 jmp	 $LN47@parse_ctrl
$LN46@parse_ctrl:

; 3854 :     else if (strcmp(precfm, "FBS") == 0)

  0067d	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG162457
  00684	48 8b 4c 24 48	 mov	 rcx, QWORD PTR precfm$[rsp]
  00689	e8 00 00 00 00	 call	 strcmp
  0068e	85 c0		 test	 eax, eax
  00690	75 10		 jne	 SHORT $LN48@parse_ctrl

; 3855 :         *recfm = RECFM_FORMAT_F | RECFM_BLOCKED | RECFM_SPANNED;

  00692	48 8b 84 24 f8
	00 00 00	 mov	 rax, QWORD PTR recfm$[rsp]
  0069a	c6 00 98	 mov	 BYTE PTR [rax], 152	; 00000098H
  0069d	e9 ad 00 00 00	 jmp	 $LN49@parse_ctrl
$LN48@parse_ctrl:

; 3856 :     else if (strcmp(precfm, "V") == 0)

  006a2	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG162460
  006a9	48 8b 4c 24 48	 mov	 rcx, QWORD PTR precfm$[rsp]
  006ae	e8 00 00 00 00	 call	 strcmp
  006b3	85 c0		 test	 eax, eax
  006b5	75 10		 jne	 SHORT $LN50@parse_ctrl

; 3857 :         *recfm = RECFM_FORMAT_V;

  006b7	48 8b 84 24 f8
	00 00 00	 mov	 rax, QWORD PTR recfm$[rsp]
  006bf	c6 00 40	 mov	 BYTE PTR [rax], 64	; 00000040H
  006c2	e9 88 00 00 00	 jmp	 $LN51@parse_ctrl
$LN50@parse_ctrl:

; 3858 :     else if (strcmp(precfm, "VB") == 0)

  006c7	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG162463
  006ce	48 8b 4c 24 48	 mov	 rcx, QWORD PTR precfm$[rsp]
  006d3	e8 00 00 00 00	 call	 strcmp
  006d8	85 c0		 test	 eax, eax
  006da	75 0d		 jne	 SHORT $LN52@parse_ctrl

; 3859 :         *recfm = RECFM_FORMAT_V | RECFM_BLOCKED;

  006dc	48 8b 84 24 f8
	00 00 00	 mov	 rax, QWORD PTR recfm$[rsp]
  006e4	c6 00 50	 mov	 BYTE PTR [rax], 80	; 00000050H
  006e7	eb 66		 jmp	 SHORT $LN53@parse_ctrl
$LN52@parse_ctrl:

; 3860 :     else if (strcmp(precfm, "VBS") == 0)

  006e9	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG162466
  006f0	48 8b 4c 24 48	 mov	 rcx, QWORD PTR precfm$[rsp]
  006f5	e8 00 00 00 00	 call	 strcmp
  006fa	85 c0		 test	 eax, eax
  006fc	75 0d		 jne	 SHORT $LN54@parse_ctrl

; 3861 :         *recfm = RECFM_FORMAT_V | RECFM_BLOCKED | RECFM_SPANNED;

  006fe	48 8b 84 24 f8
	00 00 00	 mov	 rax, QWORD PTR recfm$[rsp]
  00706	c6 00 58	 mov	 BYTE PTR [rax], 88	; 00000058H
  00709	eb 44		 jmp	 SHORT $LN55@parse_ctrl
$LN54@parse_ctrl:

; 3862 :     else if (strcmp(precfm, "U") == 0)

  0070b	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG162469
  00712	48 8b 4c 24 48	 mov	 rcx, QWORD PTR precfm$[rsp]
  00717	e8 00 00 00 00	 call	 strcmp
  0071c	85 c0		 test	 eax, eax
  0071e	75 0d		 jne	 SHORT $LN56@parse_ctrl

; 3863 :         *recfm = RECFM_FORMAT_U;

  00720	48 8b 84 24 f8
	00 00 00	 mov	 rax, QWORD PTR recfm$[rsp]
  00728	c6 00 c0	 mov	 BYTE PTR [rax], 192	; 000000c0H
  0072b	eb 22		 jmp	 SHORT $LN57@parse_ctrl
$LN56@parse_ctrl:

; 3864 :     else
; 3865 :     {
; 3866 :         XMERRF ( MSG( HHC02585, "E", precfm ) );

  0072d	4c 8b 44 24 48	 mov	 r8, QWORD PTR precfm$[rsp]
  00732	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG162470
  00739	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG162471
  00740	e8 00 00 00 00	 call	 printf

; 3867 :         return -1;

  00745	b8 ff ff ff ff	 mov	 eax, -1
  0074a	e9 97 01 00 00	 jmp	 $LN1@parse_ctrl
$LN57@parse_ctrl:
$LN55@parse_ctrl:
$LN53@parse_ctrl:
$LN51@parse_ctrl:
$LN49@parse_ctrl:
$LN47@parse_ctrl:
$LN45@parse_ctrl:

; 3868 :     }
; 3869 : 
; 3870 :     /* Determine the logical record length */
; 3871 :     plrecl = strtok_r (NULL, " \t", &strtok_str);

  0074f	4c 8d 44 24 38	 lea	 r8, QWORD PTR strtok_str$[rsp]
  00754	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG162472
  0075b	33 c9		 xor	 ecx, ecx
  0075d	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_strtok_r
  00763	48 89 84 24 80
	00 00 00	 mov	 QWORD PTR plrecl$[rsp], rax

; 3872 :     if (plrecl == NULL) return 0;

  0076b	48 83 bc 24 80
	00 00 00 00	 cmp	 QWORD PTR plrecl$[rsp], 0
  00774	75 07		 jne	 SHORT $LN58@parse_ctrl
  00776	33 c0		 xor	 eax, eax
  00778	e9 69 01 00 00	 jmp	 $LN1@parse_ctrl
$LN58@parse_ctrl:

; 3873 : 
; 3874 :     if (sscanf(plrecl, "%u%c", lrecl, &c) != 1
; 3875 :         || *lrecl > MAX_DATALEN)

  0077d	4c 8d 4c 24 30	 lea	 r9, QWORD PTR c$[rsp]
  00782	4c 8b 84 24 00
	01 00 00	 mov	 r8, QWORD PTR lrecl$[rsp]
  0078a	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG162476
  00791	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR plrecl$[rsp]
  00799	e8 00 00 00 00	 call	 sscanf
  0079e	83 f8 01	 cmp	 eax, 1
  007a1	75 10		 jne	 SHORT $LN60@parse_ctrl
  007a3	48 8b 84 24 00
	01 00 00	 mov	 rax, QWORD PTR lrecl$[rsp]
  007ab	81 38 ff 7f 00
	00		 cmp	 DWORD PTR [rax], 32767	; 00007fffH
  007b1	7e 25		 jle	 SHORT $LN59@parse_ctrl
$LN60@parse_ctrl:

; 3876 :     {
; 3877 :         XMERRF ( MSG( HHC02586, "E", plrecl ) );

  007b3	4c 8b 84 24 80
	00 00 00	 mov	 r8, QWORD PTR plrecl$[rsp]
  007bb	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG162477
  007c2	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG162478
  007c9	e8 00 00 00 00	 call	 printf

; 3878 :         return -1;

  007ce	b8 ff ff ff ff	 mov	 eax, -1
  007d3	e9 0e 01 00 00	 jmp	 $LN1@parse_ctrl
$LN59@parse_ctrl:

; 3879 :     }
; 3880 : 
; 3881 :     /* Determine the block size */
; 3882 :     pblksz = strtok_r (NULL, " \t", &strtok_str);

  007d8	4c 8d 44 24 38	 lea	 r8, QWORD PTR strtok_str$[rsp]
  007dd	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG162479
  007e4	33 c9		 xor	 ecx, ecx
  007e6	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_strtok_r
  007ec	48 89 84 24 88
	00 00 00	 mov	 QWORD PTR pblksz$[rsp], rax

; 3883 :     if (pblksz == NULL) return 0;

  007f4	48 83 bc 24 88
	00 00 00 00	 cmp	 QWORD PTR pblksz$[rsp], 0
  007fd	75 07		 jne	 SHORT $LN61@parse_ctrl
  007ff	33 c0		 xor	 eax, eax
  00801	e9 e0 00 00 00	 jmp	 $LN1@parse_ctrl
$LN61@parse_ctrl:

; 3884 : 
; 3885 :     if (sscanf(pblksz, "%u%c", blksz, &c) != 1
; 3886 :         || *blksz > MAX_DATALEN)

  00806	4c 8d 4c 24 30	 lea	 r9, QWORD PTR c$[rsp]
  0080b	4c 8b 84 24 08
	01 00 00	 mov	 r8, QWORD PTR blksz$[rsp]
  00813	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG162483
  0081a	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR pblksz$[rsp]
  00822	e8 00 00 00 00	 call	 sscanf
  00827	83 f8 01	 cmp	 eax, 1
  0082a	75 10		 jne	 SHORT $LN63@parse_ctrl
  0082c	48 8b 84 24 08
	01 00 00	 mov	 rax, QWORD PTR blksz$[rsp]
  00834	81 38 ff 7f 00
	00		 cmp	 DWORD PTR [rax], 32767	; 00007fffH
  0083a	7e 25		 jle	 SHORT $LN62@parse_ctrl
$LN63@parse_ctrl:

; 3887 :     {
; 3888 :         XMERRF ( MSG( HHC02587, "E", pblksz ) );

  0083c	4c 8b 84 24 88
	00 00 00	 mov	 r8, QWORD PTR pblksz$[rsp]
  00844	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG162484
  0084b	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG162485
  00852	e8 00 00 00 00	 call	 printf

; 3889 :         return -1;

  00857	b8 ff ff ff ff	 mov	 eax, -1
  0085c	e9 85 00 00 00	 jmp	 $LN1@parse_ctrl
$LN62@parse_ctrl:

; 3890 :     }
; 3891 : 
; 3892 :     /* Determine the key length */
; 3893 :     pkeyln = strtok_r (NULL, " \t", &strtok_str);

  00861	4c 8d 44 24 38	 lea	 r8, QWORD PTR strtok_str$[rsp]
  00866	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG162486
  0086d	33 c9		 xor	 ecx, ecx
  0086f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_strtok_r
  00875	48 89 84 24 90
	00 00 00	 mov	 QWORD PTR pkeyln$[rsp], rax

; 3894 :     if (pkeyln == NULL) return 0;

  0087d	48 83 bc 24 90
	00 00 00 00	 cmp	 QWORD PTR pkeyln$[rsp], 0
  00886	75 04		 jne	 SHORT $LN64@parse_ctrl
  00888	33 c0		 xor	 eax, eax
  0088a	eb 5a		 jmp	 SHORT $LN1@parse_ctrl
$LN64@parse_ctrl:

; 3895 : 
; 3896 :     if (sscanf(pkeyln, "%u%c", keyln, &c) != 1
; 3897 :         || *keyln > 255)

  0088c	4c 8d 4c 24 30	 lea	 r9, QWORD PTR c$[rsp]
  00891	4c 8b 84 24 10
	01 00 00	 mov	 r8, QWORD PTR keyln$[rsp]
  00899	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG162490
  008a0	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR pkeyln$[rsp]
  008a8	e8 00 00 00 00	 call	 sscanf
  008ad	83 f8 01	 cmp	 eax, 1
  008b0	75 10		 jne	 SHORT $LN66@parse_ctrl
  008b2	48 8b 84 24 10
	01 00 00	 mov	 rax, QWORD PTR keyln$[rsp]
  008ba	81 38 ff 00 00
	00		 cmp	 DWORD PTR [rax], 255	; 000000ffH
  008c0	7e 22		 jle	 SHORT $LN65@parse_ctrl
$LN66@parse_ctrl:

; 3898 :     {
; 3899 :         XMERRF ( MSG( HHC02588, "E", pkeyln ) );

  008c2	4c 8b 84 24 90
	00 00 00	 mov	 r8, QWORD PTR pkeyln$[rsp]
  008ca	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG162491
  008d1	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG162492
  008d8	e8 00 00 00 00	 call	 printf

; 3900 :         return -1;

  008dd	b8 ff ff ff ff	 mov	 eax, -1
  008e2	eb 02		 jmp	 SHORT $LN1@parse_ctrl
$LN65@parse_ctrl:

; 3901 :     }
; 3902 : 
; 3903 :     return 0;

  008e4	33 c0		 xor	 eax, eax
$LN1@parse_ctrl:

; 3904 : } /* end function parse_ctrl_stmt */

  008e6	48 81 c4 a0 00
	00 00		 add	 rsp, 160		; 000000a0H
  008ed	5f		 pop	 rdi
  008ee	c3		 ret	 0
parse_ctrl_stmt ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\dasdload64.c
_TEXT	SEGMENT
stmtlen$ = 48
tv88 = 56
msgbuf$1 = 64
__$ArrayPad$ = 128
cfp$ = 160
cfname$ = 168
stmt$ = 176
sbuflen$ = 184
pstmtno$ = 192
read_ctrl_stmt PROC

; 3581 : {

  00000	44 89 4c 24 20	 mov	 DWORD PTR [rsp+32], r9d
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	48 81 ec 98 00
	00 00		 sub	 rsp, 152		; 00000098H
  0001b	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00022	48 33 c4	 xor	 rax, rsp
  00025	48 89 84 24 80
	00 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax
$LN2@read_ctrl_:

; 3582 :     int         stmtlen;                /* Length of input statement */
; 3583 :     static int  stmtno = 0;             /* Statement number          */
; 3584 : 
; 3585 :     while (1)

  0002d	33 c0		 xor	 eax, eax
  0002f	83 f8 01	 cmp	 eax, 1
  00032	0f 84 21 02 00
	00		 je	 $LN3@read_ctrl_

; 3586 :     {
; 3587 :         /* Read next record from control file */
; 3588 :         stmtno++;

  00038	8b 05 00 00 00
	00		 mov	 eax, DWORD PTR ?stmtno@?1??read_ctrl_stmt@@9@9
  0003e	ff c0		 inc	 eax
  00040	89 05 00 00 00
	00		 mov	 DWORD PTR ?stmtno@?1??read_ctrl_stmt@@9@9, eax

; 3589 :         *pstmtno = stmtno;

  00046	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR pstmtno$[rsp]
  0004e	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?stmtno@?1??read_ctrl_stmt@@9@9
  00054	89 08		 mov	 DWORD PTR [rax], ecx

; 3590 : 
; 3591 :         if (!fgets( stmt, sbuflen, cfp ))

  00056	4c 8b 84 24 a0
	00 00 00	 mov	 r8, QWORD PTR cfp$[rsp]
  0005e	8b 94 24 b8 00
	00 00		 mov	 edx, DWORD PTR sbuflen$[rsp]
  00065	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR stmt$[rsp]
  0006d	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fgets
  00073	48 85 c0	 test	 rax, rax
  00076	75 77		 jne	 SHORT $LN7@read_ctrl_

; 3592 :         {
; 3593 :             /* Return +1 when end of control file is reached.
; 3594 :                Else return -1 indicating input file error.
; 3595 :             */
; 3596 :             if (feof( cfp ))

  00078	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR cfp$[rsp]
  00080	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_feof
  00086	85 c0		 test	 eax, eax
  00088	74 0a		 je	 SHORT $LN8@read_ctrl_

; 3597 :                 return +1;

  0008a	b8 01 00 00 00	 mov	 eax, 1
  0008f	e9 c7 01 00 00	 jmp	 $LN1@read_ctrl_
$LN8@read_ctrl_:

; 3598 : 
; 3599 :             // (error)
; 3600 :             {
; 3601 :                 char msgbuf[64];
; 3602 : 
; 3603 :                 MSGBUF( msgbuf, "line[%d] fgets()", stmtno );

  00094	44 8b 0d 00 00
	00 00		 mov	 r9d, DWORD PTR ?stmtno@?1??read_ctrl_stmt@@9@9
  0009b	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG162276
  000a2	ba 40 00 00 00	 mov	 edx, 64			; 00000040H
  000a7	48 8d 4c 24 40	 lea	 rcx, QWORD PTR msgbuf$1[rsp]
  000ac	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_snprintf

; 3604 :                 // "File %s; %s error: %s"
; 3605 :                 XMERRF( MSG( HHC02468, "E", cfname, msgbuf, strerror( errno )));

  000b2	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno
  000b8	8b 08		 mov	 ecx, DWORD PTR [rax]
  000ba	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_strerror
  000c0	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  000c5	4c 8d 4c 24 40	 lea	 r9, QWORD PTR msgbuf$1[rsp]
  000ca	4c 8b 84 24 a8
	00 00 00	 mov	 r8, QWORD PTR cfname$[rsp]
  000d2	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG162277
  000d9	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG162278
  000e0	e8 00 00 00 00	 call	 printf

; 3606 :             }
; 3607 :             return -1;

  000e5	b8 ff ff ff ff	 mov	 eax, -1
  000ea	e9 6c 01 00 00	 jmp	 $LN1@read_ctrl_
$LN7@read_ctrl_:
$LN6@read_ctrl_:

; 3608 :         }
; 3609 : 
; 3610 :         /* Indicate input file progess */
; 3611 :         EXTGUIMSG( "IPOS=%"PRId64"\n", (U64) ftell( cfp ));

  000ef	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_extgui
  000f6	83 38 00	 cmp	 DWORD PTR [rax], 0
  000f9	74 36		 je	 SHORT $LN9@read_ctrl_
  000fb	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR cfp$[rsp]
  00103	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__ftelli64
  00109	48 89 44 24 38	 mov	 QWORD PTR tv88[rsp], rax
  0010e	b9 02 00 00 00	 mov	 ecx, 2
  00113	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  00119	48 8b 4c 24 38	 mov	 rcx, QWORD PTR tv88[rsp]
  0011e	4c 8b c1	 mov	 r8, rcx
  00121	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG162280
  00128	48 8b c8	 mov	 rcx, rax
  0012b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_fprintf
$LN9@read_ctrl_:
  00131	33 c0		 xor	 eax, eax
  00133	85 c0		 test	 eax, eax
  00135	75 b8		 jne	 SHORT $LN6@read_ctrl_

; 3612 : 
; 3613 :         /* Check for DOS end of file character */
; 3614 :         if (stmt[0] == '\x1A')

  00137	b8 01 00 00 00	 mov	 eax, 1
  0013c	48 6b c0 00	 imul	 rax, rax, 0
  00140	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR stmt$[rsp]
  00148	0f be 04 01	 movsx	 eax, BYTE PTR [rcx+rax]
  0014c	83 f8 1a	 cmp	 eax, 26
  0014f	75 0a		 jne	 SHORT $LN10@read_ctrl_

; 3615 :             return +1;

  00151	b8 01 00 00 00	 mov	 eax, 1
  00156	e9 00 01 00 00	 jmp	 $LN1@read_ctrl_
$LN10@read_ctrl_:

; 3616 : 
; 3617 :         /* Check that end of statement has been read */
; 3618 :         stmtlen = (int) strlen( stmt );

  0015b	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR stmt$[rsp]
  00163	e8 00 00 00 00	 call	 strlen
  00168	89 44 24 30	 mov	 DWORD PTR stmtlen$[rsp], eax

; 3619 :         if (!stmtlen || stmt[ stmtlen-1 ] != '\n')

  0016c	83 7c 24 30 00	 cmp	 DWORD PTR stmtlen$[rsp], 0
  00171	74 19		 je	 SHORT $LN12@read_ctrl_
  00173	8b 44 24 30	 mov	 eax, DWORD PTR stmtlen$[rsp]
  00177	ff c8		 dec	 eax
  00179	48 98		 cdqe
  0017b	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR stmt$[rsp]
  00183	0f be 04 01	 movsx	 eax, BYTE PTR [rcx+rax]
  00187	83 f8 0a	 cmp	 eax, 10
  0018a	74 2c		 je	 SHORT $LN11@read_ctrl_
$LN12@read_ctrl_:

; 3620 :         {
; 3621 :             // "File %s: line[%04d] error: line length is invalid"
; 3622 :             XMERRF( MSG( HHC02577, "E", cfname, stmtno ));

  0018c	44 8b 0d 00 00
	00 00		 mov	 r9d, DWORD PTR ?stmtno@?1??read_ctrl_stmt@@9@9
  00193	4c 8b 84 24 a8
	00 00 00	 mov	 r8, QWORD PTR cfname$[rsp]
  0019b	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG162284
  001a2	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG162285
  001a9	e8 00 00 00 00	 call	 printf

; 3623 :             return -1;

  001ae	b8 ff ff ff ff	 mov	 eax, -1
  001b3	e9 a3 00 00 00	 jmp	 $LN1@read_ctrl_
$LN11@read_ctrl_:

; 3624 :         }
; 3625 : 
; 3626 :         /* Remove trailing whitespace */
; 3627 :         RTRIM( stmt );

  001b8	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG162286
  001bf	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR stmt$[rsp]
  001c7	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_rtrim

; 3628 :         stmtlen = (int) strlen( stmt );

  001cd	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR stmt$[rsp]
  001d5	e8 00 00 00 00	 call	 strlen
  001da	89 44 24 30	 mov	 DWORD PTR stmtlen$[rsp], eax

; 3629 : 
; 3630 :         /* Print the input statement */
; 3631 :         // "File %s[%04d]: %s"
; 3632 :         XMINFF( 0, MSG( HHC02567, "I", cfname, stmtno, stmt ));

  001de	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR stmt$[rsp]
  001e6	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  001eb	8b 05 00 00 00
	00		 mov	 eax, DWORD PTR ?stmtno@?1??read_ctrl_stmt@@9@9
  001f1	89 44 24 20	 mov	 DWORD PTR [rsp+32], eax
  001f5	4c 8b 8c 24 a8
	00 00 00	 mov	 r9, QWORD PTR cfname$[rsp]
  001fd	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG162287
  00204	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG162288
  0020b	33 c9		 xor	 ecx, ecx
  0020d	e8 00 00 00 00	 call	 info_msg

; 3633 : 
; 3634 :         /* Ignore comment statements */
; 3635 :         if (!stmtlen || stmt[0] == '#' || stmt[0] == '*')

  00212	83 7c 24 30 00	 cmp	 DWORD PTR stmtlen$[rsp], 0
  00217	74 34		 je	 SHORT $LN14@read_ctrl_
  00219	b8 01 00 00 00	 mov	 eax, 1
  0021e	48 6b c0 00	 imul	 rax, rax, 0
  00222	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR stmt$[rsp]
  0022a	0f be 04 01	 movsx	 eax, BYTE PTR [rcx+rax]
  0022e	83 f8 23	 cmp	 eax, 35			; 00000023H
  00231	74 1a		 je	 SHORT $LN14@read_ctrl_
  00233	b8 01 00 00 00	 mov	 eax, 1
  00238	48 6b c0 00	 imul	 rax, rax, 0
  0023c	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR stmt$[rsp]
  00244	0f be 04 01	 movsx	 eax, BYTE PTR [rcx+rax]
  00248	83 f8 2a	 cmp	 eax, 42			; 0000002aH
  0024b	75 05		 jne	 SHORT $LN13@read_ctrl_
$LN14@read_ctrl_:

; 3636 :             continue;

  0024d	e9 db fd ff ff	 jmp	 $LN2@read_ctrl_
$LN13@read_ctrl_:

; 3637 : 
; 3638 :         break;

  00252	eb 05		 jmp	 SHORT $LN3@read_ctrl_

; 3639 :     } /* end while */

  00254	e9 d4 fd ff ff	 jmp	 $LN2@read_ctrl_
$LN3@read_ctrl_:

; 3640 : 
; 3641 :     return 0;

  00259	33 c0		 xor	 eax, eax
$LN1@read_ctrl_:

; 3642 : } /* end function read_ctrl_stmt */

  0025b	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  00263	48 33 cc	 xor	 rcx, rsp
  00266	e8 00 00 00 00	 call	 __security_check_cookie
  0026b	48 81 c4 98 00
	00 00		 add	 rsp, 152		; 00000098H
  00272	c3		 ret	 0
read_ctrl_stmt ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\dasdload64.c
_TEXT	SEGMENT
keylen$ = 128
datalen$ = 132
rc$ = 136
outtrk$ = 140
i$ = 144
outdblu$ = 148
outrec$ = 152
outtrkbr$ = 156
outusedv$ = 160
outusedr$ = 164
tv70 = 168
tv153 = 176
datablk$ = 192
__$ArrayPad$ = 32976
ofname$ = 33008
cif$ = 33016
devtype$ = 33024
heads$ = 33032
trklen$ = 33040
outcyl$ = 33048
outhead$ = 33056
extsize$ = 33064
dsorg$ = 33072
dirblks$ = 33080
dirblu$ = 33088
lastrec$ = 33096
trkbal$ = 33104
numtrks$ = 33112
nxtcyl$ = 33120
nxthead$ = 33128
empty_initialize PROC

; 3491 : {

  00000	44 89 4c 24 20	 mov	 DWORD PTR [rsp+32], r9d
  00005	66 44 89 44 24
	18		 mov	 WORD PTR [rsp+24], r8w
  0000b	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00010	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00015	57		 push	 rdi
  00016	b8 e0 80 00 00	 mov	 eax, 32992		; 000080e0H
  0001b	e8 00 00 00 00	 call	 __chkstk
  00020	48 2b e0	 sub	 rsp, rax
  00023	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  0002a	48 33 c4	 xor	 rax, rsp
  0002d	48 89 84 24 d0
	80 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 3492 : int             rc;                     /* Return code               */
; 3493 : int             i;                      /* Loop counter              */
; 3494 : int             keylen;                 /* Key length of data block  */
; 3495 : int             datalen;                /* Data length of data block */
; 3496 : int             outusedv = 0;           /* Output bytes used on track

  00035	c7 84 24 a0 00
	00 00 00 00 00
	00		 mov	 DWORD PTR outusedv$[rsp], 0

; 3497 :                                            of virtual device         */
; 3498 : int             outusedr = 0;           /* Output bytes used on track

  00040	c7 84 24 a4 00
	00 00 00 00 00
	00		 mov	 DWORD PTR outusedr$[rsp], 0

; 3499 :                                            of real device            */
; 3500 : int             outtrkbr = 0;           /* Output bytes remaining on

  0004b	c7 84 24 9c 00
	00 00 00 00 00
	00		 mov	 DWORD PTR outtrkbr$[rsp], 0

; 3501 :                                            track of real device      */
; 3502 : int             outdblu = 0;            /* Output bytes used in last

  00056	c7 84 24 94 00
	00 00 00 00 00
	00		 mov	 DWORD PTR outdblu$[rsp], 0

; 3503 :                                            directory block           */
; 3504 : int             outtrk = 0;             /* Output relative track     */

  00061	c7 84 24 8c 00
	00 00 00 00 00
	00		 mov	 DWORD PTR outtrk$[rsp], 0

; 3505 : int             outrec = 0;             /* Output record number      */

  0006c	c7 84 24 98 00
	00 00 00 00 00
	00		 mov	 DWORD PTR outrec$[rsp], 0

; 3506 : DATABLK         datablk;                /* Data block                */
; 3507 : 
; 3508 :     /* Initialize the directory if dataset is a PDS */
; 3509 :     if (dsorg & DSORG_PO)

  00077	0f b6 84 24 30
	81 00 00	 movzx	 eax, BYTE PTR dsorg$[rsp]
  0007f	83 e0 02	 and	 eax, 2
  00082	85 c0		 test	 eax, eax
  00084	0f 84 de 01 00
	00		 je	 $LN5@empty_init

; 3510 :     {
; 3511 :         /* Build the first directory block */
; 3512 :         keylen = 8;

  0008a	c7 84 24 80 00
	00 00 08 00 00
	00		 mov	 DWORD PTR keylen$[rsp], 8

; 3513 :         datalen = 256;

  00095	c7 84 24 84 00
	00 00 00 01 00
	00		 mov	 DWORD PTR datalen$[rsp], 256 ; 00000100H

; 3514 :         outdblu = 14;

  000a0	c7 84 24 94 00
	00 00 0e 00 00
	00		 mov	 DWORD PTR outdblu$[rsp], 14

; 3515 :         memset( datablk.kdarea, 0, keylen + datalen);

  000ab	8b 84 24 84 00
	00 00		 mov	 eax, DWORD PTR datalen$[rsp]
  000b2	8b 8c 24 80 00
	00 00		 mov	 ecx, DWORD PTR keylen$[rsp]
  000b9	03 c8		 add	 ecx, eax
  000bb	8b c1		 mov	 eax, ecx
  000bd	48 98		 cdqe
  000bf	48 89 84 24 a8
	00 00 00	 mov	 QWORD PTR tv70[rsp], rax
  000c7	48 8d 8c 24 cc
	00 00 00	 lea	 rcx, QWORD PTR datablk$[rsp+12]
  000cf	48 8b f9	 mov	 rdi, rcx
  000d2	33 c0		 xor	 eax, eax
  000d4	48 8b 8c 24 a8
	00 00 00	 mov	 rcx, QWORD PTR tv70[rsp]
  000dc	f3 aa		 rep stosb

; 3516 :         memcpy( datablk.kdarea, &CKD_ENDTRK, CKD_ENDTRK_SIZE );

  000de	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR CKD_ENDTRK
  000e5	48 89 84 24 cc
	00 00 00	 mov	 QWORD PTR datablk$[rsp+12], rax

; 3517 :         store_hw( &datablk.kdarea[ keylen+0 ], outdblu );

  000ed	0f b7 8c 24 94
	00 00 00	 movzx	 ecx, WORD PTR outdblu$[rsp]
  000f5	e8 00 00 00 00	 call	 _byteswap_ushort
  000fa	8b 8c 24 80 00
	00 00		 mov	 ecx, DWORD PTR keylen$[rsp]
  00101	48 63 c9	 movsxd	 rcx, ecx
  00104	48 8d 8c 0c cc
	00 00 00	 lea	 rcx, QWORD PTR datablk$[rsp+rcx+12]
  0010c	0f b7 d0	 movzx	 edx, ax
  0010f	e8 00 00 00 00	 call	 store_hw_noswap

; 3518 :         memcpy( datablk.kdarea + keylen + 2, &CKD_ENDTRK, CKD_ENDTRK_SIZE );

  00114	48 63 84 24 80
	00 00 00	 movsxd	 rax, DWORD PTR keylen$[rsp]
  0011c	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR CKD_ENDTRK
  00123	48 89 8c 04 ce
	00 00 00	 mov	 QWORD PTR datablk$[rsp+rax+14], rcx

; 3519 : 
; 3520 :         /* Write directory blocks to output dataset */
; 3521 :         for (i = 0; i < dirblks; i++)

  0012b	c7 84 24 90 00
	00 00 00 00 00
	00		 mov	 DWORD PTR i$[rsp], 0
  00136	eb 10		 jmp	 SHORT $LN4@empty_init
$LN2@empty_init:
  00138	8b 84 24 90 00
	00 00		 mov	 eax, DWORD PTR i$[rsp]
  0013f	ff c0		 inc	 eax
  00141	89 84 24 90 00
	00 00		 mov	 DWORD PTR i$[rsp], eax
$LN4@empty_init:
  00148	8b 84 24 38 81
	00 00		 mov	 eax, DWORD PTR dirblks$[rsp]
  0014f	39 84 24 90 00
	00 00		 cmp	 DWORD PTR i$[rsp], eax
  00156	0f 8d 0c 01 00
	00		 jge	 $LN3@empty_init

; 3522 :         {
; 3523 :             /* Write a directory block */
; 3524 :             rc = write_block (cif, ofname, &datablk, keylen, datalen,

  0015c	48 8d 84 24 98
	00 00 00	 lea	 rax, QWORD PTR outrec$[rsp]
  00164	48 89 44 24 78	 mov	 QWORD PTR [rsp+120], rax
  00169	48 8d 84 24 20
	81 00 00	 lea	 rax, QWORD PTR outhead$[rsp]
  00171	48 89 44 24 70	 mov	 QWORD PTR [rsp+112], rax
  00176	48 8d 84 24 18
	81 00 00	 lea	 rax, QWORD PTR outcyl$[rsp]
  0017e	48 89 44 24 68	 mov	 QWORD PTR [rsp+104], rax
  00183	48 8d 84 24 8c
	00 00 00	 lea	 rax, QWORD PTR outtrk$[rsp]
  0018b	48 89 44 24 60	 mov	 QWORD PTR [rsp+96], rax
  00190	48 8d 84 24 9c
	00 00 00	 lea	 rax, QWORD PTR outtrkbr$[rsp]
  00198	48 89 44 24 58	 mov	 QWORD PTR [rsp+88], rax
  0019d	48 8d 84 24 a4
	00 00 00	 lea	 rax, QWORD PTR outusedr$[rsp]
  001a5	48 89 44 24 50	 mov	 QWORD PTR [rsp+80], rax
  001aa	48 8d 84 24 a0
	00 00 00	 lea	 rax, QWORD PTR outusedv$[rsp]
  001b2	48 89 44 24 48	 mov	 QWORD PTR [rsp+72], rax
  001b7	8b 84 24 28 81
	00 00		 mov	 eax, DWORD PTR extsize$[rsp]
  001be	89 44 24 40	 mov	 DWORD PTR [rsp+64], eax
  001c2	8b 84 24 10 81
	00 00		 mov	 eax, DWORD PTR trklen$[rsp]
  001c9	89 44 24 38	 mov	 DWORD PTR [rsp+56], eax
  001cd	8b 84 24 08 81
	00 00		 mov	 eax, DWORD PTR heads$[rsp]
  001d4	89 44 24 30	 mov	 DWORD PTR [rsp+48], eax
  001d8	0f b7 84 24 00
	81 00 00	 movzx	 eax, WORD PTR devtype$[rsp]
  001e0	66 89 44 24 28	 mov	 WORD PTR [rsp+40], ax
  001e5	8b 84 24 84 00
	00 00		 mov	 eax, DWORD PTR datalen$[rsp]
  001ec	89 44 24 20	 mov	 DWORD PTR [rsp+32], eax
  001f0	44 8b 8c 24 80
	00 00 00	 mov	 r9d, DWORD PTR keylen$[rsp]
  001f8	4c 8d 84 24 c0
	00 00 00	 lea	 r8, QWORD PTR datablk$[rsp]
  00200	48 8b 94 24 f0
	80 00 00	 mov	 rdx, QWORD PTR ofname$[rsp]
  00208	48 8b 8c 24 f8
	80 00 00	 mov	 rcx, QWORD PTR cif$[rsp]
  00210	e8 00 00 00 00	 call	 write_block
  00215	89 84 24 88 00
	00 00		 mov	 DWORD PTR rc$[rsp], eax

; 3525 :                         devtype, heads, trklen, extsize,
; 3526 :                         &outusedv, &outusedr, &outtrkbr,
; 3527 :                         &outtrk, &outcyl, &outhead, &outrec);
; 3528 :             if (rc < 0) return -1;

  0021c	83 bc 24 88 00
	00 00 00	 cmp	 DWORD PTR rc$[rsp], 0
  00224	7d 0a		 jge	 SHORT $LN6@empty_init
  00226	b8 ff ff ff ff	 mov	 eax, -1
  0022b	e9 fb 01 00 00	 jmp	 $LN1@empty_init
$LN6@empty_init:

; 3529 : 
; 3530 :             /* Clear subsequent directory blocks to zero */
; 3531 :             memset (datablk.kdarea, 0, keylen + datalen);

  00230	8b 84 24 84 00
	00 00		 mov	 eax, DWORD PTR datalen$[rsp]
  00237	8b 8c 24 80 00
	00 00		 mov	 ecx, DWORD PTR keylen$[rsp]
  0023e	03 c8		 add	 ecx, eax
  00240	8b c1		 mov	 eax, ecx
  00242	48 98		 cdqe
  00244	48 89 84 24 b0
	00 00 00	 mov	 QWORD PTR tv153[rsp], rax
  0024c	48 8d 8c 24 cc
	00 00 00	 lea	 rcx, QWORD PTR datablk$[rsp+12]
  00254	48 8b f9	 mov	 rdi, rcx
  00257	33 c0		 xor	 eax, eax
  00259	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR tv153[rsp]
  00261	f3 aa		 rep stosb

; 3532 : 
; 3533 :         } /* end for(i) */

  00263	e9 d0 fe ff ff	 jmp	 $LN2@empty_init
$LN3@empty_init:
$LN5@empty_init:

; 3534 : 
; 3535 :     } /* end if(DSORG_PO) */
; 3536 : 
; 3537 :     /* Create the end of file record */
; 3538 :     keylen = 0;

  00268	c7 84 24 80 00
	00 00 00 00 00
	00		 mov	 DWORD PTR keylen$[rsp], 0

; 3539 :     datalen = 0;

  00273	c7 84 24 84 00
	00 00 00 00 00
	00		 mov	 DWORD PTR datalen$[rsp], 0

; 3540 :     rc = write_block (cif, ofname, &datablk, keylen, datalen,

  0027e	48 8d 84 24 98
	00 00 00	 lea	 rax, QWORD PTR outrec$[rsp]
  00286	48 89 44 24 78	 mov	 QWORD PTR [rsp+120], rax
  0028b	48 8d 84 24 20
	81 00 00	 lea	 rax, QWORD PTR outhead$[rsp]
  00293	48 89 44 24 70	 mov	 QWORD PTR [rsp+112], rax
  00298	48 8d 84 24 18
	81 00 00	 lea	 rax, QWORD PTR outcyl$[rsp]
  002a0	48 89 44 24 68	 mov	 QWORD PTR [rsp+104], rax
  002a5	48 8d 84 24 8c
	00 00 00	 lea	 rax, QWORD PTR outtrk$[rsp]
  002ad	48 89 44 24 60	 mov	 QWORD PTR [rsp+96], rax
  002b2	48 8d 84 24 9c
	00 00 00	 lea	 rax, QWORD PTR outtrkbr$[rsp]
  002ba	48 89 44 24 58	 mov	 QWORD PTR [rsp+88], rax
  002bf	48 8d 84 24 a4
	00 00 00	 lea	 rax, QWORD PTR outusedr$[rsp]
  002c7	48 89 44 24 50	 mov	 QWORD PTR [rsp+80], rax
  002cc	48 8d 84 24 a0
	00 00 00	 lea	 rax, QWORD PTR outusedv$[rsp]
  002d4	48 89 44 24 48	 mov	 QWORD PTR [rsp+72], rax
  002d9	8b 84 24 28 81
	00 00		 mov	 eax, DWORD PTR extsize$[rsp]
  002e0	89 44 24 40	 mov	 DWORD PTR [rsp+64], eax
  002e4	8b 84 24 10 81
	00 00		 mov	 eax, DWORD PTR trklen$[rsp]
  002eb	89 44 24 38	 mov	 DWORD PTR [rsp+56], eax
  002ef	8b 84 24 08 81
	00 00		 mov	 eax, DWORD PTR heads$[rsp]
  002f6	89 44 24 30	 mov	 DWORD PTR [rsp+48], eax
  002fa	0f b7 84 24 00
	81 00 00	 movzx	 eax, WORD PTR devtype$[rsp]
  00302	66 89 44 24 28	 mov	 WORD PTR [rsp+40], ax
  00307	8b 84 24 84 00
	00 00		 mov	 eax, DWORD PTR datalen$[rsp]
  0030e	89 44 24 20	 mov	 DWORD PTR [rsp+32], eax
  00312	44 8b 8c 24 80
	00 00 00	 mov	 r9d, DWORD PTR keylen$[rsp]
  0031a	4c 8d 84 24 c0
	00 00 00	 lea	 r8, QWORD PTR datablk$[rsp]
  00322	48 8b 94 24 f0
	80 00 00	 mov	 rdx, QWORD PTR ofname$[rsp]
  0032a	48 8b 8c 24 f8
	80 00 00	 mov	 rcx, QWORD PTR cif$[rsp]
  00332	e8 00 00 00 00	 call	 write_block
  00337	89 84 24 88 00
	00 00		 mov	 DWORD PTR rc$[rsp], eax

; 3541 :                 devtype, heads, trklen, extsize,
; 3542 :                 &outusedv, &outusedr, &outtrkbr,
; 3543 :                 &outtrk, &outcyl, &outhead, &outrec);
; 3544 :     if (rc < 0) return -1;

  0033e	83 bc 24 88 00
	00 00 00	 cmp	 DWORD PTR rc$[rsp], 0
  00346	7d 0a		 jge	 SHORT $LN7@empty_init
  00348	b8 ff ff ff ff	 mov	 eax, -1
  0034d	e9 d9 00 00 00	 jmp	 $LN1@empty_init
$LN7@empty_init:

; 3545 : 
; 3546 :     /* Return number of bytes used in last directory block */
; 3547 :     *dirblu = outdblu;

  00352	48 8b 84 24 40
	81 00 00	 mov	 rax, QWORD PTR dirblu$[rsp]
  0035a	8b 8c 24 94 00
	00 00		 mov	 ecx, DWORD PTR outdblu$[rsp]
  00361	89 08		 mov	 DWORD PTR [rax], ecx

; 3548 : 
; 3549 :     /* Return the last record number and track balance */
; 3550 :     *lastrec = outrec;

  00363	48 8b 84 24 48
	81 00 00	 mov	 rax, QWORD PTR lastrec$[rsp]
  0036b	8b 8c 24 98 00
	00 00		 mov	 ecx, DWORD PTR outrec$[rsp]
  00372	89 08		 mov	 DWORD PTR [rax], ecx

; 3551 :     *trkbal = outtrkbr;

  00374	48 8b 84 24 50
	81 00 00	 mov	 rax, QWORD PTR trkbal$[rsp]
  0037c	8b 8c 24 9c 00
	00 00		 mov	 ecx, DWORD PTR outtrkbr$[rsp]
  00383	89 08		 mov	 DWORD PTR [rax], ecx

; 3552 : 
; 3553 :     /* Write data remaining in track buffer */
; 3554 :     rc = write_track (cif, ofname, heads, trklen,

  00385	48 8d 84 24 20
	81 00 00	 lea	 rax, QWORD PTR outhead$[rsp]
  0038d	48 89 44 24 38	 mov	 QWORD PTR [rsp+56], rax
  00392	48 8d 84 24 18
	81 00 00	 lea	 rax, QWORD PTR outcyl$[rsp]
  0039a	48 89 44 24 30	 mov	 QWORD PTR [rsp+48], rax
  0039f	48 8d 84 24 8c
	00 00 00	 lea	 rax, QWORD PTR outtrk$[rsp]
  003a7	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  003ac	48 8d 84 24 a0
	00 00 00	 lea	 rax, QWORD PTR outusedv$[rsp]
  003b4	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  003b9	44 8b 8c 24 10
	81 00 00	 mov	 r9d, DWORD PTR trklen$[rsp]
  003c1	44 8b 84 24 08
	81 00 00	 mov	 r8d, DWORD PTR heads$[rsp]
  003c9	48 8b 94 24 f0
	80 00 00	 mov	 rdx, QWORD PTR ofname$[rsp]
  003d1	48 8b 8c 24 f8
	80 00 00	 mov	 rcx, QWORD PTR cif$[rsp]
  003d9	e8 00 00 00 00	 call	 write_track
  003de	89 84 24 88 00
	00 00		 mov	 DWORD PTR rc$[rsp], eax

; 3555 :                     &outusedv, &outtrk, &outcyl, &outhead);
; 3556 :     if (rc < 0) return -1;

  003e5	83 bc 24 88 00
	00 00 00	 cmp	 DWORD PTR rc$[rsp], 0
  003ed	7d 07		 jge	 SHORT $LN8@empty_init
  003ef	b8 ff ff ff ff	 mov	 eax, -1
  003f4	eb 35		 jmp	 SHORT $LN1@empty_init
$LN8@empty_init:

; 3557 : 
; 3558 :     /* Return number of tracks and starting address of next dataset */
; 3559 :     *numtrks = outtrk;

  003f6	48 8b 84 24 58
	81 00 00	 mov	 rax, QWORD PTR numtrks$[rsp]
  003fe	8b 8c 24 8c 00
	00 00		 mov	 ecx, DWORD PTR outtrk$[rsp]
  00405	89 08		 mov	 DWORD PTR [rax], ecx

; 3560 :     *nxtcyl = outcyl;

  00407	48 8b 84 24 60
	81 00 00	 mov	 rax, QWORD PTR nxtcyl$[rsp]
  0040f	8b 8c 24 18 81
	00 00		 mov	 ecx, DWORD PTR outcyl$[rsp]
  00416	89 08		 mov	 DWORD PTR [rax], ecx

; 3561 :     *nxthead = outhead;

  00418	48 8b 84 24 68
	81 00 00	 mov	 rax, QWORD PTR nxthead$[rsp]
  00420	8b 8c 24 20 81
	00 00		 mov	 ecx, DWORD PTR outhead$[rsp]
  00427	89 08		 mov	 DWORD PTR [rax], ecx

; 3562 :     return 0;

  00429	33 c0		 xor	 eax, eax
$LN1@empty_init:

; 3563 : 
; 3564 : } /* end function empty_initialize */

  0042b	48 8b 8c 24 d0
	80 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  00433	48 33 cc	 xor	 rcx, rsp
  00436	e8 00 00 00 00	 call	 __security_check_cookie
  0043b	48 81 c4 e0 80
	00 00		 add	 rsp, 32992		; 000080e0H
  00442	5f		 pop	 rdi
  00443	c3		 ret	 0
empty_initialize ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\dasdload64.c
_TEXT	SEGMENT
rc$ = 128
sfd$ = 132
size$ = 136
outtrk$ = 140
outrec$ = 144
outtrkbr$ = 148
outusedv$ = 152
tv179 = 156
tv184 = 160
outusedr$ = 164
tv236 = 168
st$ = 176
datablk$ = 240
pathname$ = 33024
__$ArrayPad$ = 33296
sfname$ = 33328
ofname$ = 33336
cif$ = 33344
devtype$ = 33352
heads$ = 33360
trklen$ = 33368
outcyl$ = 33376
outhead$ = 33384
extsize$ = 33392
dsorg$ = 33400
recfm$ = 33408
lrecl$ = 33416
blksz$ = 33424
keyln$ = 33432
lastrec$ = 33440
trkbal$ = 33448
numtrks$ = 33456
nxtcyl$ = 33464
nxthead$ = 33472
seq_initialize PROC

; 3335 : {

  00000	66 44 89 4c 24
	20		 mov	 WORD PTR [rsp+32], r9w
  00006	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000b	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00010	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00015	57		 push	 rdi
  00016	b8 20 82 00 00	 mov	 eax, 33312		; 00008220H
  0001b	e8 00 00 00 00	 call	 __chkstk
  00020	48 2b e0	 sub	 rsp, rax
  00023	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  0002a	48 33 c4	 xor	 rax, rsp
  0002d	48 89 84 24 10
	82 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 3336 : int             rc;                     /* Return code               */
; 3337 : int             sfd;                    /* Input seq file descriptor */
; 3338 : int             size;                   /* Size left in input file   */
; 3339 : int             outusedv = 0;           /* Output bytes used on track

  00035	c7 84 24 98 00
	00 00 00 00 00
	00		 mov	 DWORD PTR outusedv$[rsp], 0

; 3340 :                                            of virtual device         */
; 3341 : int             outusedr = 0;           /* Output bytes used on track

  00040	c7 84 24 a4 00
	00 00 00 00 00
	00		 mov	 DWORD PTR outusedr$[rsp], 0

; 3342 :                                            of real device            */
; 3343 : int             outtrkbr = 0;           /* Output bytes remaining on

  0004b	c7 84 24 94 00
	00 00 00 00 00
	00		 mov	 DWORD PTR outtrkbr$[rsp], 0

; 3344 :                                            track of real device      */
; 3345 : int             outtrk = 0;             /* Output relative track     */

  00056	c7 84 24 8c 00
	00 00 00 00 00
	00		 mov	 DWORD PTR outtrk$[rsp], 0

; 3346 : int             outrec = 0;             /* Output record number      */

  00061	c7 84 24 90 00
	00 00 00 00 00
	00		 mov	 DWORD PTR outrec$[rsp], 0

; 3347 : struct stat     st;                     /* Data area for fstat()     */
; 3348 : DATABLK         datablk;                /* Data block                */
; 3349 : char            pathname[MAX_PATH];     /* sfname in host path format*/
; 3350 : 
; 3351 :     /* Perform some checks */
; 3352 :     if (!(dsorg & DSORG_PS) && !(dsorg & DSORG_DA))

  0006c	0f b6 84 24 78
	82 00 00	 movzx	 eax, BYTE PTR dsorg$[rsp]
  00074	83 e0 40	 and	 eax, 64			; 00000040H
  00077	85 c0		 test	 eax, eax
  00079	75 3f		 jne	 SHORT $LN4@seq_initia
  0007b	0f b6 84 24 78
	82 00 00	 movzx	 eax, BYTE PTR dsorg$[rsp]
  00083	83 e0 20	 and	 eax, 32			; 00000020H
  00086	85 c0		 test	 eax, eax
  00088	75 30		 jne	 SHORT $LN4@seq_initia

; 3353 :     {
; 3354 :         XMERRF ( MSG( HHC02573, "E", sfname, dsorg ) );

  0008a	0f b6 84 24 78
	82 00 00	 movzx	 eax, BYTE PTR dsorg$[rsp]
  00092	44 8b c8	 mov	 r9d, eax
  00095	4c 8b 84 24 30
	82 00 00	 mov	 r8, QWORD PTR sfname$[rsp]
  0009d	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG162163
  000a4	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG162164
  000ab	e8 00 00 00 00	 call	 printf

; 3355 :         return -1;

  000b0	b8 ff ff ff ff	 mov	 eax, -1
  000b5	e9 d8 06 00 00	 jmp	 $LN1@seq_initia
$LN4@seq_initia:

; 3356 :     }
; 3357 :     if (recfm != RECFM_FORMAT_F && recfm != (RECFM_FORMAT_F|RECFM_BLOCKED))

  000ba	0f b6 84 24 80
	82 00 00	 movzx	 eax, BYTE PTR recfm$[rsp]
  000c2	3d 80 00 00 00	 cmp	 eax, 128		; 00000080H
  000c7	74 3f		 je	 SHORT $LN5@seq_initia
  000c9	0f b6 84 24 80
	82 00 00	 movzx	 eax, BYTE PTR recfm$[rsp]
  000d1	3d 90 00 00 00	 cmp	 eax, 144		; 00000090H
  000d6	74 30		 je	 SHORT $LN5@seq_initia

; 3358 :     {
; 3359 :         XMERRF ( MSG( HHC02574, "E", sfname, recfm ) );

  000d8	0f b6 84 24 80
	82 00 00	 movzx	 eax, BYTE PTR recfm$[rsp]
  000e0	44 8b c8	 mov	 r9d, eax
  000e3	4c 8b 84 24 30
	82 00 00	 mov	 r8, QWORD PTR sfname$[rsp]
  000eb	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG162166
  000f2	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG162167
  000f9	e8 00 00 00 00	 call	 printf

; 3360 :         return -1;

  000fe	b8 ff ff ff ff	 mov	 eax, -1
  00103	e9 8a 06 00 00	 jmp	 $LN1@seq_initia
$LN5@seq_initia:

; 3361 :     }
; 3362 :     if (blksz == 0) blksz = lrecl;

  00108	83 bc 24 90 82
	00 00 00	 cmp	 DWORD PTR blksz$[rsp], 0
  00110	75 0e		 jne	 SHORT $LN6@seq_initia
  00112	8b 84 24 88 82
	00 00		 mov	 eax, DWORD PTR lrecl$[rsp]
  00119	89 84 24 90 82
	00 00		 mov	 DWORD PTR blksz$[rsp], eax
$LN6@seq_initia:

; 3363 :     if (lrecl == 0) lrecl = blksz;

  00120	83 bc 24 88 82
	00 00 00	 cmp	 DWORD PTR lrecl$[rsp], 0
  00128	75 0e		 jne	 SHORT $LN7@seq_initia
  0012a	8b 84 24 90 82
	00 00		 mov	 eax, DWORD PTR blksz$[rsp]
  00131	89 84 24 88 82
	00 00		 mov	 DWORD PTR lrecl$[rsp], eax
$LN7@seq_initia:

; 3364 :     if (lrecl == 0 || blksz % lrecl != 0
; 3365 :      || (blksz != lrecl && recfm == RECFM_FORMAT_F))

  00138	83 bc 24 88 82
	00 00 00	 cmp	 DWORD PTR lrecl$[rsp], 0
  00140	74 34		 je	 SHORT $LN9@seq_initia
  00142	8b 84 24 90 82
	00 00		 mov	 eax, DWORD PTR blksz$[rsp]
  00149	99		 cdq
  0014a	f7 bc 24 88 82
	00 00		 idiv	 DWORD PTR lrecl$[rsp]
  00151	8b c2		 mov	 eax, edx
  00153	85 c0		 test	 eax, eax
  00155	75 1f		 jne	 SHORT $LN9@seq_initia
  00157	8b 84 24 88 82
	00 00		 mov	 eax, DWORD PTR lrecl$[rsp]
  0015e	39 84 24 90 82
	00 00		 cmp	 DWORD PTR blksz$[rsp], eax
  00165	74 47		 je	 SHORT $LN8@seq_initia
  00167	0f b6 84 24 80
	82 00 00	 movzx	 eax, BYTE PTR recfm$[rsp]
  0016f	3d 80 00 00 00	 cmp	 eax, 128		; 00000080H
  00174	75 38		 jne	 SHORT $LN8@seq_initia
$LN9@seq_initia:

; 3366 :     {
; 3367 :         XMERRF ( MSG( HHC02575, "E", sfname, lrecl, blksz ) );

  00176	8b 84 24 90 82
	00 00		 mov	 eax, DWORD PTR blksz$[rsp]
  0017d	89 44 24 20	 mov	 DWORD PTR [rsp+32], eax
  00181	44 8b 8c 24 88
	82 00 00	 mov	 r9d, DWORD PTR lrecl$[rsp]
  00189	4c 8b 84 24 30
	82 00 00	 mov	 r8, QWORD PTR sfname$[rsp]
  00191	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG162172
  00198	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG162173
  0019f	e8 00 00 00 00	 call	 printf

; 3368 :         return -1;

  001a4	b8 ff ff ff ff	 mov	 eax, -1
  001a9	e9 e4 05 00 00	 jmp	 $LN1@seq_initia
$LN8@seq_initia:

; 3369 :     }
; 3370 :     if (keyln > 0 && blksz > lrecl)

  001ae	83 bc 24 98 82
	00 00 00	 cmp	 DWORD PTR keyln$[rsp], 0
  001b6	7e 3d		 jle	 SHORT $LN10@seq_initia
  001b8	8b 84 24 88 82
	00 00		 mov	 eax, DWORD PTR lrecl$[rsp]
  001bf	39 84 24 90 82
	00 00		 cmp	 DWORD PTR blksz$[rsp], eax
  001c6	7e 2d		 jle	 SHORT $LN10@seq_initia

; 3371 :     {
; 3372 :         XMERR ( MSG( HHC02576, "E", sfname, keyln ) );

  001c8	44 8b 8c 24 98
	82 00 00	 mov	 r9d, DWORD PTR keyln$[rsp]
  001d0	4c 8b 84 24 30
	82 00 00	 mov	 r8, QWORD PTR sfname$[rsp]
  001d8	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG162175
  001df	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG162176
  001e6	e8 00 00 00 00	 call	 printf

; 3373 :         return -1;

  001eb	b8 ff ff ff ff	 mov	 eax, -1
  001f0	e9 9d 05 00 00	 jmp	 $LN1@seq_initia
$LN10@seq_initia:

; 3374 :     }
; 3375 : 
; 3376 :     /* Open the input file */
; 3377 :     hostpath(pathname, sfname, sizeof(pathname));

  001f5	41 b8 04 01 00
	00		 mov	 r8d, 260		; 00000104H
  001fb	48 8b 94 24 30
	82 00 00	 mov	 rdx, QWORD PTR sfname$[rsp]
  00203	48 8d 8c 24 00
	81 00 00	 lea	 rcx, QWORD PTR pathname$[rsp]
  0020b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hostpath

; 3378 :     sfd = HOPEN (pathname, O_RDONLY|O_BINARY);

  00211	ba 00 80 00 00	 mov	 edx, 32768		; 00008000H
  00216	48 8d 8c 24 00
	81 00 00	 lea	 rcx, QWORD PTR pathname$[rsp]
  0021e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_hopen
  00224	89 84 24 84 00
	00 00		 mov	 DWORD PTR sfd$[rsp], eax

; 3379 :     if (sfd < 0)

  0022b	83 bc 24 84 00
	00 00 00	 cmp	 DWORD PTR sfd$[rsp], 0
  00233	7d 3f		 jge	 SHORT $LN11@seq_initia

; 3380 :     {
; 3381 :         XMERRF ( MSG( HHC02468, "E", sfname, "open()", strerror(errno) ) );

  00235	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno
  0023b	8b 08		 mov	 ecx, DWORD PTR [rax]
  0023d	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_strerror
  00243	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00248	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG162178
  0024f	4c 8b 84 24 30
	82 00 00	 mov	 r8, QWORD PTR sfname$[rsp]
  00257	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG162179
  0025e	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG162180
  00265	e8 00 00 00 00	 call	 printf

; 3382 :         return -1;

  0026a	b8 ff ff ff ff	 mov	 eax, -1
  0026f	e9 1e 05 00 00	 jmp	 $LN1@seq_initia
$LN11@seq_initia:

; 3383 :     }
; 3384 : 
; 3385 :     /* Get input file status */
; 3386 :     rc = fstat(sfd, &st);

  00274	48 8d 94 24 b0
	00 00 00	 lea	 rdx, QWORD PTR st$[rsp]
  0027c	8b 8c 24 84 00
	00 00		 mov	 ecx, DWORD PTR sfd$[rsp]
  00283	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__fstat64
  00289	89 84 24 80 00
	00 00		 mov	 DWORD PTR rc$[rsp], eax

; 3387 :     if (rc < 0)

  00290	83 bc 24 80 00
	00 00 00	 cmp	 DWORD PTR rc$[rsp], 0
  00298	7d 4c		 jge	 SHORT $LN12@seq_initia

; 3388 :     {
; 3389 :         XMERRF ( MSG( HHC02468, "E", sfname, "fstat()", strerror(errno) ) );

  0029a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno
  002a0	8b 08		 mov	 ecx, DWORD PTR [rax]
  002a2	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_strerror
  002a8	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  002ad	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG162182
  002b4	4c 8b 84 24 30
	82 00 00	 mov	 r8, QWORD PTR sfname$[rsp]
  002bc	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG162183
  002c3	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG162184
  002ca	e8 00 00 00 00	 call	 printf

; 3390 :         close (sfd);

  002cf	8b 8c 24 84 00
	00 00		 mov	 ecx, DWORD PTR sfd$[rsp]
  002d6	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_close

; 3391 :         return -1;

  002dc	b8 ff ff ff ff	 mov	 eax, -1
  002e1	e9 ac 04 00 00	 jmp	 $LN1@seq_initia
$LN12@seq_initia:

; 3392 :     }
; 3393 :     size = (int) st.st_size;

  002e6	8b 84 24 c8 00
	00 00		 mov	 eax, DWORD PTR st$[rsp+24]
  002ed	89 84 24 88 00
	00 00		 mov	 DWORD PTR size$[rsp], eax

; 3394 : 
; 3395 :     /* Read the first track */
; 3396 :     rc = read_track( cif, *nxtcyl, (U8) *nxthead );

  002f4	48 8b 84 24 c0
	82 00 00	 mov	 rax, QWORD PTR nxthead$[rsp]
  002fc	44 0f b6 00	 movzx	 r8d, BYTE PTR [rax]
  00300	48 8b 84 24 b8
	82 00 00	 mov	 rax, QWORD PTR nxtcyl$[rsp]
  00308	8b 10		 mov	 edx, DWORD PTR [rax]
  0030a	48 8b 8c 24 40
	82 00 00	 mov	 rcx, QWORD PTR cif$[rsp]
  00312	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_read_track
  00318	89 84 24 80 00
	00 00		 mov	 DWORD PTR rc$[rsp], eax

; 3397 :     if (rc < 0)

  0031f	83 bc 24 80 00
	00 00 00	 cmp	 DWORD PTR rc$[rsp], 0
  00327	7d 67		 jge	 SHORT $LN13@seq_initia

; 3398 :     {
; 3399 :         XMERRF ( MSG( HHC02547, "E", ofname, *nxtcyl, *nxtcyl, *nxthead, *nxthead ) );

  00329	48 8b 84 24 c0
	82 00 00	 mov	 rax, QWORD PTR nxthead$[rsp]
  00331	8b 00		 mov	 eax, DWORD PTR [rax]
  00333	89 44 24 30	 mov	 DWORD PTR [rsp+48], eax
  00337	48 8b 84 24 c0
	82 00 00	 mov	 rax, QWORD PTR nxthead$[rsp]
  0033f	8b 00		 mov	 eax, DWORD PTR [rax]
  00341	89 44 24 28	 mov	 DWORD PTR [rsp+40], eax
  00345	48 8b 84 24 b8
	82 00 00	 mov	 rax, QWORD PTR nxtcyl$[rsp]
  0034d	8b 00		 mov	 eax, DWORD PTR [rax]
  0034f	89 44 24 20	 mov	 DWORD PTR [rsp+32], eax
  00353	48 8b 84 24 b8
	82 00 00	 mov	 rax, QWORD PTR nxtcyl$[rsp]
  0035b	44 8b 08	 mov	 r9d, DWORD PTR [rax]
  0035e	4c 8b 84 24 38
	82 00 00	 mov	 r8, QWORD PTR ofname$[rsp]
  00366	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG162186
  0036d	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG162187
  00374	e8 00 00 00 00	 call	 printf

; 3400 :         close (sfd);

  00379	8b 8c 24 84 00
	00 00		 mov	 ecx, DWORD PTR sfd$[rsp]
  00380	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_close

; 3401 :         return -1;

  00386	b8 ff ff ff ff	 mov	 eax, -1
  0038b	e9 02 04 00 00	 jmp	 $LN1@seq_initia
$LN13@seq_initia:
$LN2@seq_initia:

; 3402 :     }
; 3403 : 
; 3404 :     while (size > 0)

  00390	83 bc 24 88 00
	00 00 00	 cmp	 DWORD PTR size$[rsp], 0
  00398	0f 8e 53 02 00
	00		 jle	 $LN3@seq_initia

; 3405 :     {
; 3406 :         /* Read a block of data from the input file */
; 3407 :         rc = read (sfd, &datablk.kdarea, blksz < size ? blksz : size);

  0039e	8b 84 24 88 00
	00 00		 mov	 eax, DWORD PTR size$[rsp]
  003a5	39 84 24 90 82
	00 00		 cmp	 DWORD PTR blksz$[rsp], eax
  003ac	7d 10		 jge	 SHORT $LN20@seq_initia
  003ae	8b 84 24 90 82
	00 00		 mov	 eax, DWORD PTR blksz$[rsp]
  003b5	89 84 24 9c 00
	00 00		 mov	 DWORD PTR tv179[rsp], eax
  003bc	eb 0e		 jmp	 SHORT $LN21@seq_initia
$LN20@seq_initia:
  003be	8b 84 24 88 00
	00 00		 mov	 eax, DWORD PTR size$[rsp]
  003c5	89 84 24 9c 00
	00 00		 mov	 DWORD PTR tv179[rsp], eax
$LN21@seq_initia:
  003cc	44 8b 84 24 9c
	00 00 00	 mov	 r8d, DWORD PTR tv179[rsp]
  003d4	48 8d 94 24 fc
	00 00 00	 lea	 rdx, QWORD PTR datablk$[rsp+12]
  003dc	8b 8c 24 84 00
	00 00		 mov	 ecx, DWORD PTR sfd$[rsp]
  003e3	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_read
  003e9	89 84 24 80 00
	00 00		 mov	 DWORD PTR rc$[rsp], eax

; 3408 :         if (rc < (blksz < size ? blksz : size))

  003f0	8b 84 24 88 00
	00 00		 mov	 eax, DWORD PTR size$[rsp]
  003f7	39 84 24 90 82
	00 00		 cmp	 DWORD PTR blksz$[rsp], eax
  003fe	7d 10		 jge	 SHORT $LN22@seq_initia
  00400	8b 84 24 90 82
	00 00		 mov	 eax, DWORD PTR blksz$[rsp]
  00407	89 84 24 a0 00
	00 00		 mov	 DWORD PTR tv184[rsp], eax
  0040e	eb 0e		 jmp	 SHORT $LN23@seq_initia
$LN22@seq_initia:
  00410	8b 84 24 88 00
	00 00		 mov	 eax, DWORD PTR size$[rsp]
  00417	89 84 24 a0 00
	00 00		 mov	 DWORD PTR tv184[rsp], eax
$LN23@seq_initia:
  0041e	8b 84 24 a0 00
	00 00		 mov	 eax, DWORD PTR tv184[rsp]
  00425	39 84 24 80 00
	00 00		 cmp	 DWORD PTR rc$[rsp], eax
  0042c	7d 4c		 jge	 SHORT $LN14@seq_initia

; 3409 :         {
; 3410 :             XMERRF ( MSG( HHC02468, "E", sfname, "read()", strerror(errno) ) );

  0042e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno
  00434	8b 08		 mov	 ecx, DWORD PTR [rax]
  00436	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_strerror
  0043c	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00441	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG162189
  00448	4c 8b 84 24 30
	82 00 00	 mov	 r8, QWORD PTR sfname$[rsp]
  00450	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG162190
  00457	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG162191
  0045e	e8 00 00 00 00	 call	 printf

; 3411 :             close (sfd);

  00463	8b 8c 24 84 00
	00 00		 mov	 ecx, DWORD PTR sfd$[rsp]
  0046a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_close

; 3412 :             return -1;

  00470	b8 ff ff ff ff	 mov	 eax, -1
  00475	e9 18 03 00 00	 jmp	 $LN1@seq_initia
$LN14@seq_initia:

; 3413 :         }
; 3414 :         size -= rc;

  0047a	8b 84 24 80 00
	00 00		 mov	 eax, DWORD PTR rc$[rsp]
  00481	8b 8c 24 88 00
	00 00		 mov	 ecx, DWORD PTR size$[rsp]
  00488	2b c8		 sub	 ecx, eax
  0048a	8b c1		 mov	 eax, ecx
  0048c	89 84 24 88 00
	00 00		 mov	 DWORD PTR size$[rsp], eax

; 3415 : 
; 3416 :         /* Pad the block if necessary */
; 3417 :         if (rc < blksz)

  00493	8b 84 24 90 82
	00 00		 mov	 eax, DWORD PTR blksz$[rsp]
  0049a	39 84 24 80 00
	00 00		 cmp	 DWORD PTR rc$[rsp], eax
  004a1	7d 5d		 jge	 SHORT $LN15@seq_initia

; 3418 :         {
; 3419 :             /* Adjust blksize down to next
; 3420 :                highest multiple of lrecl */
; 3421 :             blksz = (((rc-1) / lrecl) + 1) * lrecl;

  004a3	8b 84 24 80 00
	00 00		 mov	 eax, DWORD PTR rc$[rsp]
  004aa	ff c8		 dec	 eax
  004ac	99		 cdq
  004ad	f7 bc 24 88 82
	00 00		 idiv	 DWORD PTR lrecl$[rsp]
  004b4	ff c0		 inc	 eax
  004b6	0f af 84 24 88
	82 00 00	 imul	 eax, DWORD PTR lrecl$[rsp]
  004be	89 84 24 90 82
	00 00		 mov	 DWORD PTR blksz$[rsp], eax

; 3422 :             memset (&datablk.kdarea[rc], 0, blksz - rc);

  004c5	8b 84 24 80 00
	00 00		 mov	 eax, DWORD PTR rc$[rsp]
  004cc	8b 8c 24 90 82
	00 00		 mov	 ecx, DWORD PTR blksz$[rsp]
  004d3	2b c8		 sub	 ecx, eax
  004d5	8b c1		 mov	 eax, ecx
  004d7	48 98		 cdqe
  004d9	48 89 84 24 a8
	00 00 00	 mov	 QWORD PTR tv236[rsp], rax
  004e1	48 63 8c 24 80
	00 00 00	 movsxd	 rcx, DWORD PTR rc$[rsp]
  004e9	48 8d 8c 0c fc
	00 00 00	 lea	 rcx, QWORD PTR datablk$[rsp+rcx+12]
  004f1	48 8b f9	 mov	 rdi, rcx
  004f4	33 c0		 xor	 eax, eax
  004f6	48 8b 8c 24 a8
	00 00 00	 mov	 rcx, QWORD PTR tv236[rsp]
  004fe	f3 aa		 rep stosb
$LN15@seq_initia:

; 3423 :         }
; 3424 : 
; 3425 :         rc = write_block (cif, ofname, &datablk, keyln, blksz - keyln,

  00500	8b 84 24 98 82
	00 00		 mov	 eax, DWORD PTR keyln$[rsp]
  00507	8b 8c 24 90 82
	00 00		 mov	 ecx, DWORD PTR blksz$[rsp]
  0050e	2b c8		 sub	 ecx, eax
  00510	8b c1		 mov	 eax, ecx
  00512	48 8d 8c 24 90
	00 00 00	 lea	 rcx, QWORD PTR outrec$[rsp]
  0051a	48 89 4c 24 78	 mov	 QWORD PTR [rsp+120], rcx
  0051f	48 8d 8c 24 68
	82 00 00	 lea	 rcx, QWORD PTR outhead$[rsp]
  00527	48 89 4c 24 70	 mov	 QWORD PTR [rsp+112], rcx
  0052c	48 8d 8c 24 60
	82 00 00	 lea	 rcx, QWORD PTR outcyl$[rsp]
  00534	48 89 4c 24 68	 mov	 QWORD PTR [rsp+104], rcx
  00539	48 8d 8c 24 8c
	00 00 00	 lea	 rcx, QWORD PTR outtrk$[rsp]
  00541	48 89 4c 24 60	 mov	 QWORD PTR [rsp+96], rcx
  00546	48 8d 8c 24 94
	00 00 00	 lea	 rcx, QWORD PTR outtrkbr$[rsp]
  0054e	48 89 4c 24 58	 mov	 QWORD PTR [rsp+88], rcx
  00553	48 8d 8c 24 a4
	00 00 00	 lea	 rcx, QWORD PTR outusedr$[rsp]
  0055b	48 89 4c 24 50	 mov	 QWORD PTR [rsp+80], rcx
  00560	48 8d 8c 24 98
	00 00 00	 lea	 rcx, QWORD PTR outusedv$[rsp]
  00568	48 89 4c 24 48	 mov	 QWORD PTR [rsp+72], rcx
  0056d	8b 8c 24 70 82
	00 00		 mov	 ecx, DWORD PTR extsize$[rsp]
  00574	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  00578	8b 8c 24 58 82
	00 00		 mov	 ecx, DWORD PTR trklen$[rsp]
  0057f	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  00583	8b 8c 24 50 82
	00 00		 mov	 ecx, DWORD PTR heads$[rsp]
  0058a	89 4c 24 30	 mov	 DWORD PTR [rsp+48], ecx
  0058e	0f b7 8c 24 48
	82 00 00	 movzx	 ecx, WORD PTR devtype$[rsp]
  00596	66 89 4c 24 28	 mov	 WORD PTR [rsp+40], cx
  0059b	89 44 24 20	 mov	 DWORD PTR [rsp+32], eax
  0059f	44 8b 8c 24 98
	82 00 00	 mov	 r9d, DWORD PTR keyln$[rsp]
  005a7	4c 8d 84 24 f0
	00 00 00	 lea	 r8, QWORD PTR datablk$[rsp]
  005af	48 8b 94 24 38
	82 00 00	 mov	 rdx, QWORD PTR ofname$[rsp]
  005b7	48 8b 8c 24 40
	82 00 00	 mov	 rcx, QWORD PTR cif$[rsp]
  005bf	e8 00 00 00 00	 call	 write_block
  005c4	89 84 24 80 00
	00 00		 mov	 DWORD PTR rc$[rsp], eax

; 3426 :                         devtype, heads, trklen, extsize,
; 3427 :                         &outusedv, &outusedr, &outtrkbr,
; 3428 :                         &outtrk, &outcyl, &outhead, &outrec);
; 3429 :         if (rc < 0)

  005cb	83 bc 24 80 00
	00 00 00	 cmp	 DWORD PTR rc$[rsp], 0
  005d3	7d 17		 jge	 SHORT $LN16@seq_initia

; 3430 :         {
; 3431 :             close (sfd);

  005d5	8b 8c 24 84 00
	00 00		 mov	 ecx, DWORD PTR sfd$[rsp]
  005dc	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_close

; 3432 :             return -1;

  005e2	b8 ff ff ff ff	 mov	 eax, -1
  005e7	e9 a6 01 00 00	 jmp	 $LN1@seq_initia
$LN16@seq_initia:

; 3433 :         }
; 3434 :     }

  005ec	e9 9f fd ff ff	 jmp	 $LN2@seq_initia
$LN3@seq_initia:

; 3435 : 
; 3436 :     /* Close the input file */
; 3437 :     close (sfd);

  005f1	8b 8c 24 84 00
	00 00		 mov	 ecx, DWORD PTR sfd$[rsp]
  005f8	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_close

; 3438 : 
; 3439 :     /* Create the end of file record */
; 3440 :     rc = write_block (cif, ofname, &datablk, 0, 0,

  005fe	48 8d 84 24 90
	00 00 00	 lea	 rax, QWORD PTR outrec$[rsp]
  00606	48 89 44 24 78	 mov	 QWORD PTR [rsp+120], rax
  0060b	48 8d 84 24 68
	82 00 00	 lea	 rax, QWORD PTR outhead$[rsp]
  00613	48 89 44 24 70	 mov	 QWORD PTR [rsp+112], rax
  00618	48 8d 84 24 60
	82 00 00	 lea	 rax, QWORD PTR outcyl$[rsp]
  00620	48 89 44 24 68	 mov	 QWORD PTR [rsp+104], rax
  00625	48 8d 84 24 8c
	00 00 00	 lea	 rax, QWORD PTR outtrk$[rsp]
  0062d	48 89 44 24 60	 mov	 QWORD PTR [rsp+96], rax
  00632	48 8d 84 24 94
	00 00 00	 lea	 rax, QWORD PTR outtrkbr$[rsp]
  0063a	48 89 44 24 58	 mov	 QWORD PTR [rsp+88], rax
  0063f	48 8d 84 24 a4
	00 00 00	 lea	 rax, QWORD PTR outusedr$[rsp]
  00647	48 89 44 24 50	 mov	 QWORD PTR [rsp+80], rax
  0064c	48 8d 84 24 98
	00 00 00	 lea	 rax, QWORD PTR outusedv$[rsp]
  00654	48 89 44 24 48	 mov	 QWORD PTR [rsp+72], rax
  00659	8b 84 24 70 82
	00 00		 mov	 eax, DWORD PTR extsize$[rsp]
  00660	89 44 24 40	 mov	 DWORD PTR [rsp+64], eax
  00664	8b 84 24 58 82
	00 00		 mov	 eax, DWORD PTR trklen$[rsp]
  0066b	89 44 24 38	 mov	 DWORD PTR [rsp+56], eax
  0066f	8b 84 24 50 82
	00 00		 mov	 eax, DWORD PTR heads$[rsp]
  00676	89 44 24 30	 mov	 DWORD PTR [rsp+48], eax
  0067a	0f b7 84 24 48
	82 00 00	 movzx	 eax, WORD PTR devtype$[rsp]
  00682	66 89 44 24 28	 mov	 WORD PTR [rsp+40], ax
  00687	c7 44 24 20 00
	00 00 00	 mov	 DWORD PTR [rsp+32], 0
  0068f	45 33 c9	 xor	 r9d, r9d
  00692	4c 8d 84 24 f0
	00 00 00	 lea	 r8, QWORD PTR datablk$[rsp]
  0069a	48 8b 94 24 38
	82 00 00	 mov	 rdx, QWORD PTR ofname$[rsp]
  006a2	48 8b 8c 24 40
	82 00 00	 mov	 rcx, QWORD PTR cif$[rsp]
  006aa	e8 00 00 00 00	 call	 write_block
  006af	89 84 24 80 00
	00 00		 mov	 DWORD PTR rc$[rsp], eax

; 3441 :                 devtype, heads, trklen, extsize,
; 3442 :                 &outusedv, &outusedr, &outtrkbr,
; 3443 :                 &outtrk, &outcyl, &outhead, &outrec);
; 3444 :     if (rc < 0) return -1;

  006b6	83 bc 24 80 00
	00 00 00	 cmp	 DWORD PTR rc$[rsp], 0
  006be	7d 0a		 jge	 SHORT $LN17@seq_initia
  006c0	b8 ff ff ff ff	 mov	 eax, -1
  006c5	e9 c8 00 00 00	 jmp	 $LN1@seq_initia
$LN17@seq_initia:

; 3445 : 
; 3446 :     /* Return the last record number and track balance */
; 3447 :     *lastrec = outrec;

  006ca	48 8b 84 24 a0
	82 00 00	 mov	 rax, QWORD PTR lastrec$[rsp]
  006d2	8b 8c 24 90 00
	00 00		 mov	 ecx, DWORD PTR outrec$[rsp]
  006d9	89 08		 mov	 DWORD PTR [rax], ecx

; 3448 :     *trkbal = outtrkbr;

  006db	48 8b 84 24 a8
	82 00 00	 mov	 rax, QWORD PTR trkbal$[rsp]
  006e3	8b 8c 24 94 00
	00 00		 mov	 ecx, DWORD PTR outtrkbr$[rsp]
  006ea	89 08		 mov	 DWORD PTR [rax], ecx

; 3449 : 
; 3450 :     /* Write data remaining in track buffer */
; 3451 :     rc = write_track (cif, ofname, heads, trklen,

  006ec	48 8d 84 24 68
	82 00 00	 lea	 rax, QWORD PTR outhead$[rsp]
  006f4	48 89 44 24 38	 mov	 QWORD PTR [rsp+56], rax
  006f9	48 8d 84 24 60
	82 00 00	 lea	 rax, QWORD PTR outcyl$[rsp]
  00701	48 89 44 24 30	 mov	 QWORD PTR [rsp+48], rax
  00706	48 8d 84 24 8c
	00 00 00	 lea	 rax, QWORD PTR outtrk$[rsp]
  0070e	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  00713	48 8d 84 24 98
	00 00 00	 lea	 rax, QWORD PTR outusedv$[rsp]
  0071b	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00720	44 8b 8c 24 58
	82 00 00	 mov	 r9d, DWORD PTR trklen$[rsp]
  00728	44 8b 84 24 50
	82 00 00	 mov	 r8d, DWORD PTR heads$[rsp]
  00730	48 8b 94 24 38
	82 00 00	 mov	 rdx, QWORD PTR ofname$[rsp]
  00738	48 8b 8c 24 40
	82 00 00	 mov	 rcx, QWORD PTR cif$[rsp]
  00740	e8 00 00 00 00	 call	 write_track
  00745	89 84 24 80 00
	00 00		 mov	 DWORD PTR rc$[rsp], eax

; 3452 :                     &outusedv, &outtrk, &outcyl, &outhead);
; 3453 :     if (rc < 0) return -1;

  0074c	83 bc 24 80 00
	00 00 00	 cmp	 DWORD PTR rc$[rsp], 0
  00754	7d 07		 jge	 SHORT $LN18@seq_initia
  00756	b8 ff ff ff ff	 mov	 eax, -1
  0075b	eb 35		 jmp	 SHORT $LN1@seq_initia
$LN18@seq_initia:

; 3454 : 
; 3455 :     /* Return number of tracks and starting address of next dataset */
; 3456 :     *numtrks = outtrk;

  0075d	48 8b 84 24 b0
	82 00 00	 mov	 rax, QWORD PTR numtrks$[rsp]
  00765	8b 8c 24 8c 00
	00 00		 mov	 ecx, DWORD PTR outtrk$[rsp]
  0076c	89 08		 mov	 DWORD PTR [rax], ecx

; 3457 :     *nxtcyl = outcyl;

  0076e	48 8b 84 24 b8
	82 00 00	 mov	 rax, QWORD PTR nxtcyl$[rsp]
  00776	8b 8c 24 60 82
	00 00		 mov	 ecx, DWORD PTR outcyl$[rsp]
  0077d	89 08		 mov	 DWORD PTR [rax], ecx

; 3458 :     *nxthead = outhead;

  0077f	48 8b 84 24 c0
	82 00 00	 mov	 rax, QWORD PTR nxthead$[rsp]
  00787	8b 8c 24 68 82
	00 00		 mov	 ecx, DWORD PTR outhead$[rsp]
  0078e	89 08		 mov	 DWORD PTR [rax], ecx

; 3459 :     return 0;

  00790	33 c0		 xor	 eax, eax
$LN1@seq_initia:

; 3460 : 
; 3461 : } /* end function seq_initialize */

  00792	48 8b 8c 24 10
	82 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  0079a	48 33 cc	 xor	 rcx, rsp
  0079d	e8 00 00 00 00	 call	 __security_check_cookie
  007a2	48 81 c4 20 82
	00 00		 add	 rsp, 33312		; 00008220H
  007a9	5f		 pop	 rdi
  007aa	c3		 ret	 0
seq_initialize ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\dasdload64.c
_TEXT	SEGMENT
diphdr$ = 128
head90$ = 136
endhead$ = 140
cyl90$ = 144
outrec$ = 148
reltrk90$ = 152
endcyl$ = 156
physlen$ = 160
rc$ = 164
outtrk$ = 168
trklen90$ = 172
datalen$ = 176
keylen$ = 180
outtrkbr$ = 184
outusedv$ = 188
remlen$ = 192
lasthead$ = 196
outusedr$ = 200
datablk$ = 208
__$ArrayPad$ = 32992
ofname$ = 33024
cif$ = 33032
devtype$ = 33040
heads$ = 33048
trklen$ = 33056
outcyl$ = 33064
outhead$ = 33072
extsize$ = 33080
lastrec$ = 33088
trkbal$ = 33096
numtrks$ = 33104
nxtcyl$ = 33112
nxthead$ = 33120
dip_initialize PROC

; 3185 : {

  00000	44 89 4c 24 20	 mov	 DWORD PTR [rsp+32], r9d
  00005	66 44 89 44 24
	18		 mov	 WORD PTR [rsp+24], r8w
  0000b	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00010	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00015	57		 push	 rdi
  00016	b8 f0 80 00 00	 mov	 eax, 33008		; 000080f0H
  0001b	e8 00 00 00 00	 call	 __chkstk
  00020	48 2b e0	 sub	 rsp, rax
  00023	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  0002a	48 33 c4	 xor	 rax, rsp
  0002d	48 89 84 24 e0
	80 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 3186 : int             rc;                     /* Return code               */
; 3187 : int             keylen;                 /* Key length of data block  */
; 3188 : int             datalen;                /* Data length of data block */
; 3189 : int             outusedv = 0;           /* Output bytes used on track

  00035	c7 84 24 bc 00
	00 00 00 00 00
	00		 mov	 DWORD PTR outusedv$[rsp], 0

; 3190 :                                            of virtual device         */
; 3191 : int             outusedr = 0;           /* Output bytes used on track

  00040	c7 84 24 c8 00
	00 00 00 00 00
	00		 mov	 DWORD PTR outusedr$[rsp], 0

; 3192 :                                            of real device            */
; 3193 : int             outtrkbr = 0;           /* Output bytes remaining on

  0004b	c7 84 24 b8 00
	00 00 00 00 00
	00		 mov	 DWORD PTR outtrkbr$[rsp], 0

; 3194 :                                            track of real device      */
; 3195 : int             outtrk = 0;             /* Output relative track     */

  00056	c7 84 24 a8 00
	00 00 00 00 00
	00		 mov	 DWORD PTR outtrk$[rsp], 0

; 3196 : int             outrec = 0;             /* Output record number      */

  00061	c7 84 24 94 00
	00 00 00 00 00
	00		 mov	 DWORD PTR outrec$[rsp], 0

; 3197 : int             remlen;                 /* Bytes remaining on 1st trk*/
; 3198 : int             physlen;                /* Physical track length     */
; 3199 : int             lasthead;               /* Highest head on cylinder  */
; 3200 : int             endcyl;                 /* Extent end cylinder       */
; 3201 : int             endhead;                /* Extent end head           */
; 3202 : int             trklen90;               /* 90% of track length       */
; 3203 : int             cyl90;                  /* 90% full cylinder number  */
; 3204 : int             head90;                 /* 90% full head number      */
; 3205 : int             reltrk90;               /* 90% full relative track   */
; 3206 : DIPHDR         *diphdr;                 /* -> Record in data block   */
; 3207 : DATABLK         datablk;                /* Data block                */
; 3208 : 
; 3209 :     /* Set the key length and data length for the header record */
; 3210 :     keylen = 0;

  0006c	c7 84 24 b4 00
	00 00 00 00 00
	00		 mov	 DWORD PTR keylen$[rsp], 0

; 3211 :     datalen = sizeof(DIPHDR);

  00077	c7 84 24 b0 00
	00 00 28 00 00
	00		 mov	 DWORD PTR datalen$[rsp], 40 ; 00000028H

; 3212 : 
; 3213 :     /* Obtain the physical track size and the track balance
; 3214 :        remaining on the first track after the header record */
; 3215 :     capacity_calc (cif, 0, keylen, datalen, NULL, &remlen,

  00082	48 c7 44 24 78
	00 00 00 00	 mov	 QWORD PTR [rsp+120], 0
  0008b	48 c7 44 24 70
	00 00 00 00	 mov	 QWORD PTR [rsp+112], 0
  00094	48 c7 44 24 68
	00 00 00 00	 mov	 QWORD PTR [rsp+104], 0
  0009d	48 c7 44 24 60
	00 00 00 00	 mov	 QWORD PTR [rsp+96], 0
  000a6	48 c7 44 24 58
	00 00 00 00	 mov	 QWORD PTR [rsp+88], 0
  000af	48 c7 44 24 50
	00 00 00 00	 mov	 QWORD PTR [rsp+80], 0
  000b8	48 c7 44 24 48
	00 00 00 00	 mov	 QWORD PTR [rsp+72], 0
  000c1	48 c7 44 24 40
	00 00 00 00	 mov	 QWORD PTR [rsp+64], 0
  000ca	48 c7 44 24 38
	00 00 00 00	 mov	 QWORD PTR [rsp+56], 0
  000d3	48 8d 84 24 a0
	00 00 00	 lea	 rax, QWORD PTR physlen$[rsp]
  000db	48 89 44 24 30	 mov	 QWORD PTR [rsp+48], rax
  000e0	48 8d 84 24 c0
	00 00 00	 lea	 rax, QWORD PTR remlen$[rsp]
  000e8	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  000ed	48 c7 44 24 20
	00 00 00 00	 mov	 QWORD PTR [rsp+32], 0
  000f6	44 8b 8c 24 b0
	00 00 00	 mov	 r9d, DWORD PTR datalen$[rsp]
  000fe	44 8b 84 24 b4
	00 00 00	 mov	 r8d, DWORD PTR keylen$[rsp]
  00106	33 d2		 xor	 edx, edx
  00108	48 8b 8c 24 08
	81 00 00	 mov	 rcx, QWORD PTR cif$[rsp]
  00110	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_capacity_calc

; 3216 :                     &physlen, NULL, NULL, NULL, NULL, NULL,
; 3217 :                     NULL, NULL, NULL, NULL);
; 3218 : 
; 3219 :     /* Calculate the end of extent cylinder and head */
; 3220 :     lasthead = heads - 1;

  00116	8b 84 24 18 81
	00 00		 mov	 eax, DWORD PTR heads$[rsp]
  0011d	ff c8		 dec	 eax
  0011f	89 84 24 c4 00
	00 00		 mov	 DWORD PTR lasthead$[rsp], eax

; 3221 :     endcyl = outcyl;

  00126	8b 84 24 28 81
	00 00		 mov	 eax, DWORD PTR outcyl$[rsp]
  0012d	89 84 24 9c 00
	00 00		 mov	 DWORD PTR endcyl$[rsp], eax

; 3222 :     endhead = outhead + extsize - 1;

  00134	8b 84 24 30 81
	00 00		 mov	 eax, DWORD PTR outhead$[rsp]
  0013b	8b 8c 24 38 81
	00 00		 mov	 ecx, DWORD PTR extsize$[rsp]
  00142	8d 44 08 ff	 lea	 eax, DWORD PTR [rax+rcx-1]
  00146	89 84 24 8c 00
	00 00		 mov	 DWORD PTR endhead$[rsp], eax
$LN2@dip_initia:

; 3223 :     while (endhead >= heads)

  0014d	8b 84 24 18 81
	00 00		 mov	 eax, DWORD PTR heads$[rsp]
  00154	39 84 24 8c 00
	00 00		 cmp	 DWORD PTR endhead$[rsp], eax
  0015b	7c 2b		 jl	 SHORT $LN3@dip_initia

; 3224 :     {
; 3225 :         endhead -= heads;

  0015d	8b 84 24 18 81
	00 00		 mov	 eax, DWORD PTR heads$[rsp]
  00164	8b 8c 24 8c 00
	00 00		 mov	 ecx, DWORD PTR endhead$[rsp]
  0016b	2b c8		 sub	 ecx, eax
  0016d	8b c1		 mov	 eax, ecx
  0016f	89 84 24 8c 00
	00 00		 mov	 DWORD PTR endhead$[rsp], eax

; 3226 :         endcyl++;

  00176	8b 84 24 9c 00
	00 00		 mov	 eax, DWORD PTR endcyl$[rsp]
  0017d	ff c0		 inc	 eax
  0017f	89 84 24 9c 00
	00 00		 mov	 DWORD PTR endcyl$[rsp], eax

; 3227 :     }

  00186	eb c5		 jmp	 SHORT $LN2@dip_initia
$LN3@dip_initia:

; 3228 : 
; 3229 :     /* Calculate the 90% full cylinder and head */
; 3230 :     trklen90 = physlen * 9 / 10;

  00188	6b 84 24 a0 00
	00 00 09	 imul	 eax, DWORD PTR physlen$[rsp], 9
  00190	99		 cdq
  00191	b9 0a 00 00 00	 mov	 ecx, 10
  00196	f7 f9		 idiv	 ecx
  00198	89 84 24 ac 00
	00 00		 mov	 DWORD PTR trklen90$[rsp], eax

; 3231 :     reltrk90 = extsize * trklen90 / physlen;

  0019f	8b 84 24 38 81
	00 00		 mov	 eax, DWORD PTR extsize$[rsp]
  001a6	0f af 84 24 ac
	00 00 00	 imul	 eax, DWORD PTR trklen90$[rsp]
  001ae	99		 cdq
  001af	f7 bc 24 a0 00
	00 00		 idiv	 DWORD PTR physlen$[rsp]
  001b6	89 84 24 98 00
	00 00		 mov	 DWORD PTR reltrk90$[rsp], eax

; 3232 :     if (reltrk90 == 0) reltrk90 = 1;

  001bd	83 bc 24 98 00
	00 00 00	 cmp	 DWORD PTR reltrk90$[rsp], 0
  001c5	75 0b		 jne	 SHORT $LN6@dip_initia
  001c7	c7 84 24 98 00
	00 00 01 00 00
	00		 mov	 DWORD PTR reltrk90$[rsp], 1
$LN6@dip_initia:

; 3233 :     cyl90 = outcyl;

  001d2	8b 84 24 28 81
	00 00		 mov	 eax, DWORD PTR outcyl$[rsp]
  001d9	89 84 24 90 00
	00 00		 mov	 DWORD PTR cyl90$[rsp], eax

; 3234 :     head90 = outhead + reltrk90 - 1;

  001e0	8b 84 24 30 81
	00 00		 mov	 eax, DWORD PTR outhead$[rsp]
  001e7	8b 8c 24 98 00
	00 00		 mov	 ecx, DWORD PTR reltrk90$[rsp]
  001ee	8d 44 08 ff	 lea	 eax, DWORD PTR [rax+rcx-1]
  001f2	89 84 24 88 00
	00 00		 mov	 DWORD PTR head90$[rsp], eax
$LN4@dip_initia:

; 3235 :     while (head90 >= heads)

  001f9	8b 84 24 18 81
	00 00		 mov	 eax, DWORD PTR heads$[rsp]
  00200	39 84 24 88 00
	00 00		 cmp	 DWORD PTR head90$[rsp], eax
  00207	7c 2b		 jl	 SHORT $LN5@dip_initia

; 3236 :     {
; 3237 :         head90 -= heads;

  00209	8b 84 24 18 81
	00 00		 mov	 eax, DWORD PTR heads$[rsp]
  00210	8b 8c 24 88 00
	00 00		 mov	 ecx, DWORD PTR head90$[rsp]
  00217	2b c8		 sub	 ecx, eax
  00219	8b c1		 mov	 eax, ecx
  0021b	89 84 24 88 00
	00 00		 mov	 DWORD PTR head90$[rsp], eax

; 3238 :         cyl90++;

  00222	8b 84 24 90 00
	00 00		 mov	 eax, DWORD PTR cyl90$[rsp]
  00229	ff c0		 inc	 eax
  0022b	89 84 24 90 00
	00 00		 mov	 DWORD PTR cyl90$[rsp], eax

; 3239 :     }

  00232	eb c5		 jmp	 SHORT $LN4@dip_initia
$LN5@dip_initia:

; 3240 : 
; 3241 :     /* Initialize the DIP header record */
; 3242 :     diphdr = (DIPHDR*) (datablk.kdarea);

  00234	48 8d 84 24 dc
	00 00 00	 lea	 rax, QWORD PTR datablk$[rsp+12]
  0023c	48 89 84 24 80
	00 00 00	 mov	 QWORD PTR diphdr$[rsp], rax

; 3243 :     memset( diphdr, 0, sizeof( DIPHDR ));

  00244	48 8b bc 24 80
	00 00 00	 mov	 rdi, QWORD PTR diphdr$[rsp]
  0024c	33 c0		 xor	 eax, eax
  0024e	b9 28 00 00 00	 mov	 ecx, 40			; 00000028H
  00253	f3 aa		 rep stosb

; 3244 : 
; 3245 :     store_hw( diphdr->recid, 0xFFFF );

  00255	66 b9 ff ff	 mov	 cx, 65535		; 0000ffffH
  00259	e8 00 00 00 00	 call	 _byteswap_ushort
  0025e	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR diphdr$[rsp]
  00266	0f b7 d0	 movzx	 edx, ax
  00269	e8 00 00 00 00	 call	 store_hw_noswap

; 3246 :     store_hw( diphdr->bcyl, outcyl  );

  0026e	0f b7 8c 24 28
	81 00 00	 movzx	 ecx, WORD PTR outcyl$[rsp]
  00276	e8 00 00 00 00	 call	 _byteswap_ushort
  0027b	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR diphdr$[rsp]
  00283	48 83 c1 02	 add	 rcx, 2
  00287	0f b7 d0	 movzx	 edx, ax
  0028a	e8 00 00 00 00	 call	 store_hw_noswap

; 3247 :     store_hw( diphdr->btrk, outhead );

  0028f	0f b7 8c 24 30
	81 00 00	 movzx	 ecx, WORD PTR outhead$[rsp]
  00297	e8 00 00 00 00	 call	 _byteswap_ushort
  0029c	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR diphdr$[rsp]
  002a4	48 83 c1 04	 add	 rcx, 4
  002a8	0f b7 d0	 movzx	 edx, ax
  002ab	e8 00 00 00 00	 call	 store_hw_noswap

; 3248 :     store_hw( diphdr->ecyl, endcyl  );

  002b0	0f b7 8c 24 9c
	00 00 00	 movzx	 ecx, WORD PTR endcyl$[rsp]
  002b8	e8 00 00 00 00	 call	 _byteswap_ushort
  002bd	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR diphdr$[rsp]
  002c5	48 83 c1 06	 add	 rcx, 6
  002c9	0f b7 d0	 movzx	 edx, ax
  002cc	e8 00 00 00 00	 call	 store_hw_noswap

; 3249 :     store_hw( diphdr->etrk, endhead );

  002d1	0f b7 8c 24 8c
	00 00 00	 movzx	 ecx, WORD PTR endhead$[rsp]
  002d9	e8 00 00 00 00	 call	 _byteswap_ushort
  002de	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR diphdr$[rsp]
  002e6	48 83 c1 08	 add	 rcx, 8
  002ea	0f b7 d0	 movzx	 edx, ax
  002ed	e8 00 00 00 00	 call	 store_hw_noswap

; 3250 : 
; 3251 :     diphdr->restart[2] = (outcyl >> 8) & 0xFF;

  002f2	8b 84 24 28 81
	00 00		 mov	 eax, DWORD PTR outcyl$[rsp]
  002f9	c1 f8 08	 sar	 eax, 8
  002fc	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  00301	b9 01 00 00 00	 mov	 ecx, 1
  00306	48 6b c9 02	 imul	 rcx, rcx, 2
  0030a	48 8b 94 24 80
	00 00 00	 mov	 rdx, QWORD PTR diphdr$[rsp]
  00312	88 44 0a 0b	 mov	 BYTE PTR [rdx+rcx+11], al

; 3252 :     diphdr->restart[3] = outcyl & 0xFF;

  00316	8b 84 24 28 81
	00 00		 mov	 eax, DWORD PTR outcyl$[rsp]
  0031d	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  00322	b9 01 00 00 00	 mov	 ecx, 1
  00327	48 6b c9 03	 imul	 rcx, rcx, 3
  0032b	48 8b 94 24 80
	00 00 00	 mov	 rdx, QWORD PTR diphdr$[rsp]
  00333	88 44 0a 0b	 mov	 BYTE PTR [rdx+rcx+11], al

; 3253 :     diphdr->restart[4] = (outhead >> 8) & 0xFF;

  00337	8b 84 24 30 81
	00 00		 mov	 eax, DWORD PTR outhead$[rsp]
  0033e	c1 f8 08	 sar	 eax, 8
  00341	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  00346	b9 01 00 00 00	 mov	 ecx, 1
  0034b	48 6b c9 04	 imul	 rcx, rcx, 4
  0034f	48 8b 94 24 80
	00 00 00	 mov	 rdx, QWORD PTR diphdr$[rsp]
  00357	88 44 0a 0b	 mov	 BYTE PTR [rdx+rcx+11], al

; 3254 :     diphdr->restart[5] = outhead & 0xFF;

  0035b	8b 84 24 30 81
	00 00		 mov	 eax, DWORD PTR outhead$[rsp]
  00362	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  00367	b9 01 00 00 00	 mov	 ecx, 1
  0036c	48 6b c9 05	 imul	 rcx, rcx, 5
  00370	48 8b 94 24 80
	00 00 00	 mov	 rdx, QWORD PTR diphdr$[rsp]
  00378	88 44 0a 0b	 mov	 BYTE PTR [rdx+rcx+11], al

; 3255 :     diphdr->restart[6] = 1;

  0037c	b8 01 00 00 00	 mov	 eax, 1
  00381	48 6b c0 06	 imul	 rax, rax, 6
  00385	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR diphdr$[rsp]
  0038d	c6 44 01 0b 01	 mov	 BYTE PTR [rcx+rax+11], 1

; 3256 : 
; 3257 :     store_hw( diphdr->trkbal, remlen  );

  00392	0f b7 8c 24 c0
	00 00 00	 movzx	 ecx, WORD PTR remlen$[rsp]
  0039a	e8 00 00 00 00	 call	 _byteswap_ushort
  0039f	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR diphdr$[rsp]
  003a7	48 83 c1 12	 add	 rcx, 18
  003ab	0f b7 d0	 movzx	 edx, ax
  003ae	e8 00 00 00 00	 call	 store_hw_noswap

; 3258 :     store_hw( diphdr->trklen, physlen );

  003b3	0f b7 8c 24 a0
	00 00 00	 movzx	 ecx, WORD PTR physlen$[rsp]
  003bb	e8 00 00 00 00	 call	 _byteswap_ushort
  003c0	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR diphdr$[rsp]
  003c8	48 83 c1 14	 add	 rcx, 20
  003cc	0f b7 d0	 movzx	 edx, ax
  003cf	e8 00 00 00 00	 call	 store_hw_noswap

; 3259 : 
; 3260 :     diphdr->reused[2] = (outcyl >> 8) & 0xFF;

  003d4	8b 84 24 28 81
	00 00		 mov	 eax, DWORD PTR outcyl$[rsp]
  003db	c1 f8 08	 sar	 eax, 8
  003de	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  003e3	b9 01 00 00 00	 mov	 ecx, 1
  003e8	48 6b c9 02	 imul	 rcx, rcx, 2
  003ec	48 8b 94 24 80
	00 00 00	 mov	 rdx, QWORD PTR diphdr$[rsp]
  003f4	88 44 0a 16	 mov	 BYTE PTR [rdx+rcx+22], al

; 3261 :     diphdr->reused[3] = outcyl & 0xFF;

  003f8	8b 84 24 28 81
	00 00		 mov	 eax, DWORD PTR outcyl$[rsp]
  003ff	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  00404	b9 01 00 00 00	 mov	 ecx, 1
  00409	48 6b c9 03	 imul	 rcx, rcx, 3
  0040d	48 8b 94 24 80
	00 00 00	 mov	 rdx, QWORD PTR diphdr$[rsp]
  00415	88 44 0a 16	 mov	 BYTE PTR [rdx+rcx+22], al

; 3262 :     diphdr->reused[4] = (outhead >> 8) & 0xFF;

  00419	8b 84 24 30 81
	00 00		 mov	 eax, DWORD PTR outhead$[rsp]
  00420	c1 f8 08	 sar	 eax, 8
  00423	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  00428	b9 01 00 00 00	 mov	 ecx, 1
  0042d	48 6b c9 04	 imul	 rcx, rcx, 4
  00431	48 8b 94 24 80
	00 00 00	 mov	 rdx, QWORD PTR diphdr$[rsp]
  00439	88 44 0a 16	 mov	 BYTE PTR [rdx+rcx+22], al

; 3263 :     diphdr->reused[5] = outhead & 0xFF;

  0043d	8b 84 24 30 81
	00 00		 mov	 eax, DWORD PTR outhead$[rsp]
  00444	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  00449	b9 01 00 00 00	 mov	 ecx, 1
  0044e	48 6b c9 05	 imul	 rcx, rcx, 5
  00452	48 8b 94 24 80
	00 00 00	 mov	 rdx, QWORD PTR diphdr$[rsp]
  0045a	88 44 0a 16	 mov	 BYTE PTR [rdx+rcx+22], al

; 3264 :     diphdr->reused[6] = 1;

  0045e	b8 01 00 00 00	 mov	 eax, 1
  00463	48 6b c0 06	 imul	 rax, rax, 6
  00467	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR diphdr$[rsp]
  0046f	c6 44 01 16 01	 mov	 BYTE PTR [rcx+rax+22], 1

; 3265 : 
; 3266 :     store_hw( diphdr->lasthead, lasthead );

  00474	0f b7 8c 24 c4
	00 00 00	 movzx	 ecx, WORD PTR lasthead$[rsp]
  0047c	e8 00 00 00 00	 call	 _byteswap_ushort
  00481	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR diphdr$[rsp]
  00489	48 83 c1 1d	 add	 rcx, 29
  0048d	0f b7 d0	 movzx	 edx, ax
  00490	e8 00 00 00 00	 call	 store_hw_noswap

; 3267 :     store_hw( diphdr->trklen90, trklen90 );

  00495	0f b7 8c 24 ac
	00 00 00	 movzx	 ecx, WORD PTR trklen90$[rsp]
  0049d	e8 00 00 00 00	 call	 _byteswap_ushort
  004a2	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR diphdr$[rsp]
  004aa	48 83 c1 1f	 add	 rcx, 31
  004ae	0f b7 d0	 movzx	 edx, ax
  004b1	e8 00 00 00 00	 call	 store_hw_noswap

; 3268 : 
; 3269 :     diphdr->devcode = (ucbtype_code (devtype ) & 0x0F) | 0xF0;

  004b6	0f b7 8c 24 10
	81 00 00	 movzx	 ecx, WORD PTR devtype$[rsp]
  004be	e8 00 00 00 00	 call	 ucbtype_code
  004c3	83 e0 0f	 and	 eax, 15
  004c6	0d f0 00 00 00	 or	 eax, 240		; 000000f0H
  004cb	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR diphdr$[rsp]
  004d3	88 41 21	 mov	 BYTE PTR [rcx+33], al

; 3270 :     diphdr->cchh90[0] = (cyl90  >> 8) & 0xFF;

  004d6	8b 84 24 90 00
	00 00		 mov	 eax, DWORD PTR cyl90$[rsp]
  004dd	c1 f8 08	 sar	 eax, 8
  004e0	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  004e5	b9 01 00 00 00	 mov	 ecx, 1
  004ea	48 6b c9 00	 imul	 rcx, rcx, 0
  004ee	48 8b 94 24 80
	00 00 00	 mov	 rdx, QWORD PTR diphdr$[rsp]
  004f6	88 44 0a 22	 mov	 BYTE PTR [rdx+rcx+34], al

; 3271 :     diphdr->cchh90[1] =  cyl90        & 0xFF;

  004fa	8b 84 24 90 00
	00 00		 mov	 eax, DWORD PTR cyl90$[rsp]
  00501	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  00506	b9 01 00 00 00	 mov	 ecx, 1
  0050b	48 6b c9 01	 imul	 rcx, rcx, 1
  0050f	48 8b 94 24 80
	00 00 00	 mov	 rdx, QWORD PTR diphdr$[rsp]
  00517	88 44 0a 22	 mov	 BYTE PTR [rdx+rcx+34], al

; 3272 :     diphdr->cchh90[2] = (head90 >> 8) & 0xFF;

  0051b	8b 84 24 88 00
	00 00		 mov	 eax, DWORD PTR head90$[rsp]
  00522	c1 f8 08	 sar	 eax, 8
  00525	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  0052a	b9 01 00 00 00	 mov	 ecx, 1
  0052f	48 6b c9 02	 imul	 rcx, rcx, 2
  00533	48 8b 94 24 80
	00 00 00	 mov	 rdx, QWORD PTR diphdr$[rsp]
  0053b	88 44 0a 22	 mov	 BYTE PTR [rdx+rcx+34], al

; 3273 :     diphdr->cchh90[3] =  head90       & 0xFF;

  0053f	8b 84 24 88 00
	00 00		 mov	 eax, DWORD PTR head90$[rsp]
  00546	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  0054b	b9 01 00 00 00	 mov	 ecx, 1
  00550	48 6b c9 03	 imul	 rcx, rcx, 3
  00554	48 8b 94 24 80
	00 00 00	 mov	 rdx, QWORD PTR diphdr$[rsp]
  0055c	88 44 0a 22	 mov	 BYTE PTR [rdx+rcx+34], al

; 3274 :     diphdr->endid = 0xFF;

  00560	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR diphdr$[rsp]
  00568	c6 40 27 ff	 mov	 BYTE PTR [rax+39], 255	; 000000ffH

; 3275 : 
; 3276 :     /* Write the data block to the output file */
; 3277 :     rc = write_block (cif, ofname, &datablk, keylen, datalen,

  0056c	48 8d 84 24 94
	00 00 00	 lea	 rax, QWORD PTR outrec$[rsp]
  00574	48 89 44 24 78	 mov	 QWORD PTR [rsp+120], rax
  00579	48 8d 84 24 30
	81 00 00	 lea	 rax, QWORD PTR outhead$[rsp]
  00581	48 89 44 24 70	 mov	 QWORD PTR [rsp+112], rax
  00586	48 8d 84 24 28
	81 00 00	 lea	 rax, QWORD PTR outcyl$[rsp]
  0058e	48 89 44 24 68	 mov	 QWORD PTR [rsp+104], rax
  00593	48 8d 84 24 a8
	00 00 00	 lea	 rax, QWORD PTR outtrk$[rsp]
  0059b	48 89 44 24 60	 mov	 QWORD PTR [rsp+96], rax
  005a0	48 8d 84 24 b8
	00 00 00	 lea	 rax, QWORD PTR outtrkbr$[rsp]
  005a8	48 89 44 24 58	 mov	 QWORD PTR [rsp+88], rax
  005ad	48 8d 84 24 c8
	00 00 00	 lea	 rax, QWORD PTR outusedr$[rsp]
  005b5	48 89 44 24 50	 mov	 QWORD PTR [rsp+80], rax
  005ba	48 8d 84 24 bc
	00 00 00	 lea	 rax, QWORD PTR outusedv$[rsp]
  005c2	48 89 44 24 48	 mov	 QWORD PTR [rsp+72], rax
  005c7	8b 84 24 38 81
	00 00		 mov	 eax, DWORD PTR extsize$[rsp]
  005ce	89 44 24 40	 mov	 DWORD PTR [rsp+64], eax
  005d2	8b 84 24 20 81
	00 00		 mov	 eax, DWORD PTR trklen$[rsp]
  005d9	89 44 24 38	 mov	 DWORD PTR [rsp+56], eax
  005dd	8b 84 24 18 81
	00 00		 mov	 eax, DWORD PTR heads$[rsp]
  005e4	89 44 24 30	 mov	 DWORD PTR [rsp+48], eax
  005e8	0f b7 84 24 10
	81 00 00	 movzx	 eax, WORD PTR devtype$[rsp]
  005f0	66 89 44 24 28	 mov	 WORD PTR [rsp+40], ax
  005f5	8b 84 24 b0 00
	00 00		 mov	 eax, DWORD PTR datalen$[rsp]
  005fc	89 44 24 20	 mov	 DWORD PTR [rsp+32], eax
  00600	44 8b 8c 24 b4
	00 00 00	 mov	 r9d, DWORD PTR keylen$[rsp]
  00608	4c 8d 84 24 d0
	00 00 00	 lea	 r8, QWORD PTR datablk$[rsp]
  00610	48 8b 94 24 00
	81 00 00	 mov	 rdx, QWORD PTR ofname$[rsp]
  00618	48 8b 8c 24 08
	81 00 00	 mov	 rcx, QWORD PTR cif$[rsp]
  00620	e8 00 00 00 00	 call	 write_block
  00625	89 84 24 a4 00
	00 00		 mov	 DWORD PTR rc$[rsp], eax

; 3278 :                 devtype, heads, trklen, extsize,
; 3279 :                 &outusedv, &outusedr, &outtrkbr,
; 3280 :                 &outtrk, &outcyl, &outhead, &outrec);
; 3281 :     if (rc < 0) return -1;

  0062c	83 bc 24 a4 00
	00 00 00	 cmp	 DWORD PTR rc$[rsp], 0
  00634	7d 0a		 jge	 SHORT $LN7@dip_initia
  00636	b8 ff ff ff ff	 mov	 eax, -1
  0063b	e9 3b 01 00 00	 jmp	 $LN1@dip_initia
$LN7@dip_initia:

; 3282 : 
; 3283 :     XMINFF (3, MSG( HHC02566, "I", outcyl, outcyl, outhead, outhead, outrec, outrec ) );

  00640	8b 84 24 94 00
	00 00		 mov	 eax, DWORD PTR outrec$[rsp]
  00647	89 44 24 40	 mov	 DWORD PTR [rsp+64], eax
  0064b	8b 84 24 94 00
	00 00		 mov	 eax, DWORD PTR outrec$[rsp]
  00652	89 44 24 38	 mov	 DWORD PTR [rsp+56], eax
  00656	8b 84 24 30 81
	00 00		 mov	 eax, DWORD PTR outhead$[rsp]
  0065d	89 44 24 30	 mov	 DWORD PTR [rsp+48], eax
  00661	8b 84 24 30 81
	00 00		 mov	 eax, DWORD PTR outhead$[rsp]
  00668	89 44 24 28	 mov	 DWORD PTR [rsp+40], eax
  0066c	8b 84 24 28 81
	00 00		 mov	 eax, DWORD PTR outcyl$[rsp]
  00673	89 44 24 20	 mov	 DWORD PTR [rsp+32], eax
  00677	44 8b 8c 24 28
	81 00 00	 mov	 r9d, DWORD PTR outcyl$[rsp]
  0067f	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG162103
  00686	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG162104
  0068d	b9 03 00 00 00	 mov	 ecx, 3
  00692	e8 00 00 00 00	 call	 info_msg

; 3284 : 
; 3285 :     if (infolvl >= 5) data_dump (diphdr, sizeof(DIPHDR));

  00697	83 3d 00 00 00
	00 05		 cmp	 DWORD PTR infolvl, 5
  0069e	7c 13		 jl	 SHORT $LN8@dip_initia
  006a0	ba 28 00 00 00	 mov	 edx, 40			; 00000028H
  006a5	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR diphdr$[rsp]
  006ad	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_data_dump
$LN8@dip_initia:

; 3286 : 
; 3287 :     /* Return the last record number and track balance */
; 3288 :     *lastrec = outrec;

  006b3	48 8b 84 24 40
	81 00 00	 mov	 rax, QWORD PTR lastrec$[rsp]
  006bb	8b 8c 24 94 00
	00 00		 mov	 ecx, DWORD PTR outrec$[rsp]
  006c2	89 08		 mov	 DWORD PTR [rax], ecx

; 3289 :     *trkbal = outtrkbr;

  006c4	48 8b 84 24 48
	81 00 00	 mov	 rax, QWORD PTR trkbal$[rsp]
  006cc	8b 8c 24 b8 00
	00 00		 mov	 ecx, DWORD PTR outtrkbr$[rsp]
  006d3	89 08		 mov	 DWORD PTR [rax], ecx

; 3290 : 
; 3291 :     /* Write data remaining in track buffer */
; 3292 :     rc = write_track (cif, ofname, heads, trklen,

  006d5	48 8d 84 24 30
	81 00 00	 lea	 rax, QWORD PTR outhead$[rsp]
  006dd	48 89 44 24 38	 mov	 QWORD PTR [rsp+56], rax
  006e2	48 8d 84 24 28
	81 00 00	 lea	 rax, QWORD PTR outcyl$[rsp]
  006ea	48 89 44 24 30	 mov	 QWORD PTR [rsp+48], rax
  006ef	48 8d 84 24 a8
	00 00 00	 lea	 rax, QWORD PTR outtrk$[rsp]
  006f7	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  006fc	48 8d 84 24 bc
	00 00 00	 lea	 rax, QWORD PTR outusedv$[rsp]
  00704	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00709	44 8b 8c 24 20
	81 00 00	 mov	 r9d, DWORD PTR trklen$[rsp]
  00711	44 8b 84 24 18
	81 00 00	 mov	 r8d, DWORD PTR heads$[rsp]
  00719	48 8b 94 24 00
	81 00 00	 mov	 rdx, QWORD PTR ofname$[rsp]
  00721	48 8b 8c 24 08
	81 00 00	 mov	 rcx, QWORD PTR cif$[rsp]
  00729	e8 00 00 00 00	 call	 write_track
  0072e	89 84 24 a4 00
	00 00		 mov	 DWORD PTR rc$[rsp], eax

; 3293 :                     &outusedv, &outtrk, &outcyl, &outhead);
; 3294 :     if (rc < 0) return -1;

  00735	83 bc 24 a4 00
	00 00 00	 cmp	 DWORD PTR rc$[rsp], 0
  0073d	7d 07		 jge	 SHORT $LN9@dip_initia
  0073f	b8 ff ff ff ff	 mov	 eax, -1
  00744	eb 35		 jmp	 SHORT $LN1@dip_initia
$LN9@dip_initia:

; 3295 : 
; 3296 :     /* Return number of tracks and starting address of next dataset */
; 3297 :     *numtrks = outtrk;

  00746	48 8b 84 24 50
	81 00 00	 mov	 rax, QWORD PTR numtrks$[rsp]
  0074e	8b 8c 24 a8 00
	00 00		 mov	 ecx, DWORD PTR outtrk$[rsp]
  00755	89 08		 mov	 DWORD PTR [rax], ecx

; 3298 :     *nxtcyl = outcyl;

  00757	48 8b 84 24 58
	81 00 00	 mov	 rax, QWORD PTR nxtcyl$[rsp]
  0075f	8b 8c 24 28 81
	00 00		 mov	 ecx, DWORD PTR outcyl$[rsp]
  00766	89 08		 mov	 DWORD PTR [rax], ecx

; 3299 :     *nxthead = outhead;

  00768	48 8b 84 24 60
	81 00 00	 mov	 rax, QWORD PTR nxthead$[rsp]
  00770	8b 8c 24 30 81
	00 00		 mov	 ecx, DWORD PTR outhead$[rsp]
  00777	89 08		 mov	 DWORD PTR [rax], ecx

; 3300 :     return 0;

  00779	33 c0		 xor	 eax, eax
$LN1@dip_initia:

; 3301 : 
; 3302 : } /* end function dip_initialize */

  0077b	48 8b 8c 24 e0
	80 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  00783	48 33 cc	 xor	 rcx, rsp
  00786	e8 00 00 00 00	 call	 __security_check_cookie
  0078b	48 81 c4 f0 80
	00 00		 add	 rsp, 33008		; 000080f0H
  00792	5f		 pop	 rdi
  00793	c3		 ret	 0
dip_initialize ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\dasdload64.c
_TEXT	SEGMENT
catent$ = 128
bytes$ = 136
keylen$ = 140
datalen$ = 144
outrec$ = 148
totblks$ = 152
rc$ = 156
outtrk$ = 160
i$ = 164
ucbtype$ = 168
outtrkbr$ = 172
outusedv$ = 176
outusedr$ = 180
blkptrk$ = 184
tv86 = 192
tv299 = 200
tv361 = 208
tv475 = 216
datablk$ = 224
__$ArrayPad$ = 33008
ofname$ = 33040
cif$ = 33048
volser$ = 33056
devtype$ = 33064
heads$ = 33072
trklen$ = 33080
outcyl$ = 33088
outhead$ = 33096
extsize$ = 33104
lastrec$ = 33112
trkbal$ = 33120
numtrks$ = 33128
nxtcyl$ = 33136
nxthead$ = 33144
cvol_initialize PROC

; 2883 : {

  00000	66 44 89 4c 24
	20		 mov	 WORD PTR [rsp+32], r9w
  00006	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000b	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00010	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00015	57		 push	 rdi
  00016	b8 00 81 00 00	 mov	 eax, 33024		; 00008100H
  0001b	e8 00 00 00 00	 call	 __chkstk
  00020	48 2b e0	 sub	 rsp, rax
  00023	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  0002a	48 33 c4	 xor	 rax, rsp
  0002d	48 89 84 24 f0
	80 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 2884 : int             rc;                     /* Return code               */
; 2885 : int             i;                      /* Array subscript           */
; 2886 : int             keylen;                 /* Key length of data block  */
; 2887 : int             datalen;                /* Data length of data block */
; 2888 : int             outusedv = 0;           /* Output bytes used on track

  00035	c7 84 24 b0 00
	00 00 00 00 00
	00		 mov	 DWORD PTR outusedv$[rsp], 0

; 2889 :                                            of virtual device         */
; 2890 : int             outusedr = 0;           /* Output bytes used on track

  00040	c7 84 24 b4 00
	00 00 00 00 00
	00		 mov	 DWORD PTR outusedr$[rsp], 0

; 2891 :                                            of real device            */
; 2892 : int             outtrkbr = 0;           /* Output bytes remaining on

  0004b	c7 84 24 ac 00
	00 00 00 00 00
	00		 mov	 DWORD PTR outtrkbr$[rsp], 0

; 2893 :                                            track of real device      */
; 2894 : int             outtrk = 0;             /* Output relative track     */

  00056	c7 84 24 a0 00
	00 00 00 00 00
	00		 mov	 DWORD PTR outtrk$[rsp], 0

; 2895 : int             outrec = 0;             /* Output record number      */

  00061	c7 84 24 94 00
	00 00 00 00 00
	00		 mov	 DWORD PTR outrec$[rsp], 0

; 2896 : int             blkptrk;                /* Number of blocks per track*/
; 2897 : int             totblks;                /* Number of blocks in CVOL  */
; 2898 : int             bytes;                  /* Bytes used in this block  */
; 2899 : U32             ucbtype;                /* UCB device type           */
; 2900 : PDSDIR         *catent;                 /* -> Catalog entry          */
; 2901 : DATABLK         datablk;                /* Data block                */
; 2902 : #define NUM_SYS1_DATASETS       8       /* Number of SYS1 datasets   */
; 2903 : static char    *sys1name[NUM_SYS1_DATASETS] =
; 2904 :                 {"DUMP", "IMAGELIB", "LINKLIB", "NUCLEUS",
; 2905 :                 "PARMLIB", "PROCLIB", "SAMPLIB", "SYSJOBQE"};
; 2906 : 
; 2907 :     /* Set the key length and data length for SYSCTLG dataset */
; 2908 :     keylen = 8;

  0006c	c7 84 24 8c 00
	00 00 08 00 00
	00		 mov	 DWORD PTR keylen$[rsp], 8

; 2909 :     datalen = 256;

  00077	c7 84 24 90 00
	00 00 00 01 00
	00		 mov	 DWORD PTR datalen$[rsp], 256 ; 00000100H

; 2910 : 
; 2911 :     /* Obtain the number of blocks which will fit on a track */
; 2912 :     capacity_calc (cif, 0, keylen, datalen, NULL, NULL,

  00082	48 c7 44 24 78
	00 00 00 00	 mov	 QWORD PTR [rsp+120], 0
  0008b	48 c7 44 24 70
	00 00 00 00	 mov	 QWORD PTR [rsp+112], 0
  00094	48 8d 84 24 b8
	00 00 00	 lea	 rax, QWORD PTR blkptrk$[rsp]
  0009c	48 89 44 24 68	 mov	 QWORD PTR [rsp+104], rax
  000a1	48 c7 44 24 60
	00 00 00 00	 mov	 QWORD PTR [rsp+96], 0
  000aa	48 c7 44 24 58
	00 00 00 00	 mov	 QWORD PTR [rsp+88], 0
  000b3	48 c7 44 24 50
	00 00 00 00	 mov	 QWORD PTR [rsp+80], 0
  000bc	48 c7 44 24 48
	00 00 00 00	 mov	 QWORD PTR [rsp+72], 0
  000c5	48 c7 44 24 40
	00 00 00 00	 mov	 QWORD PTR [rsp+64], 0
  000ce	48 c7 44 24 38
	00 00 00 00	 mov	 QWORD PTR [rsp+56], 0
  000d7	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR [rsp+48], 0
  000e0	48 c7 44 24 28
	00 00 00 00	 mov	 QWORD PTR [rsp+40], 0
  000e9	48 c7 44 24 20
	00 00 00 00	 mov	 QWORD PTR [rsp+32], 0
  000f2	44 8b 8c 24 90
	00 00 00	 mov	 r9d, DWORD PTR datalen$[rsp]
  000fa	44 8b 84 24 8c
	00 00 00	 mov	 r8d, DWORD PTR keylen$[rsp]
  00102	33 d2		 xor	 edx, edx
  00104	48 8b 8c 24 18
	81 00 00	 mov	 rcx, QWORD PTR cif$[rsp]
  0010c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_capacity_calc

; 2913 :                     NULL, NULL, NULL, NULL, NULL,
; 2914 :                     NULL, NULL, &blkptrk, NULL, NULL);
; 2915 : 
; 2916 :     /* Calculate the total number of blocks in the catalog */
; 2917 :     totblks = extsize * blkptrk;

  00112	8b 84 24 50 81
	00 00		 mov	 eax, DWORD PTR extsize$[rsp]
  00119	0f af 84 24 b8
	00 00 00	 imul	 eax, DWORD PTR blkptrk$[rsp]
  00121	89 84 24 98 00
	00 00		 mov	 DWORD PTR totblks$[rsp], eax

; 2918 : 
; 2919 :     /* Get the UCB device type */
; 2920 :     ucbtype = ucbtype_code (devtype);

  00128	0f b7 8c 24 28
	81 00 00	 movzx	 ecx, WORD PTR devtype$[rsp]
  00130	e8 00 00 00 00	 call	 ucbtype_code
  00135	89 84 24 a8 00
	00 00		 mov	 DWORD PTR ucbtype$[rsp], eax

; 2921 : 
; 2922 :     /*-----------------------------------*/
; 2923 :     /* Initialize the volume index block */
; 2924 :     /*-----------------------------------*/
; 2925 :     memset (datablk.kdarea, 0, keylen + datalen);

  0013c	8b 84 24 90 00
	00 00		 mov	 eax, DWORD PTR datalen$[rsp]
  00143	8b 8c 24 8c 00
	00 00		 mov	 ecx, DWORD PTR keylen$[rsp]
  0014a	03 c8		 add	 ecx, eax
  0014c	8b c1		 mov	 eax, ecx
  0014e	48 98		 cdqe
  00150	48 89 84 24 c0
	00 00 00	 mov	 QWORD PTR tv86[rsp], rax
  00158	48 8d 8c 24 ec
	00 00 00	 lea	 rcx, QWORD PTR datablk$[rsp+12]
  00160	48 8b f9	 mov	 rdi, rcx
  00163	33 c0		 xor	 eax, eax
  00165	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR tv86[rsp]
  0016d	f3 aa		 rep stosb

; 2926 : 
; 2927 :     /* The key field contains all X'FF' */
; 2928 :     memcpy( datablk.kdarea, &CKD_ENDTRK, CKD_ENDTRK_SIZE );

  0016f	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR CKD_ENDTRK
  00176	48 89 84 24 ec
	00 00 00	 mov	 QWORD PTR datablk$[rsp+12], rax

; 2929 : 
; 2930 :     /* The first entry begins after the 2 byte count field */
; 2931 :     bytes = 2;

  0017e	c7 84 24 88 00
	00 00 02 00 00
	00		 mov	 DWORD PTR bytes$[rsp], 2

; 2932 :     catent = (PDSDIR*)(datablk.kdarea + keylen + bytes);

  00189	48 63 84 24 8c
	00 00 00	 movsxd	 rax, DWORD PTR keylen$[rsp]
  00191	48 8d 84 04 ec
	00 00 00	 lea	 rax, QWORD PTR datablk$[rsp+rax+12]
  00199	48 63 8c 24 88
	00 00 00	 movsxd	 rcx, DWORD PTR bytes$[rsp]
  001a1	48 03 c1	 add	 rax, rcx
  001a4	48 89 84 24 80
	00 00 00	 mov	 QWORD PTR catent$[rsp], rax

; 2933 : 
; 2934 :     /* Build the volume index control entry (VICE) */
; 2935 : 
; 2936 :     /* The VICE name is X'0000000000000001' */
; 2937 :     memcpy (catent->pds2name, cvol_low_key, 8);

  001ac	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR catent$[rsp]
  001b4	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR cvol_low_key
  001bb	48 89 08	 mov	 QWORD PTR [rax], rcx

; 2938 : 
; 2939 :     /* Set TTR to highest block in volume index, i.e. X'000001' */
; 2940 :     catent->pds2ttrp[0] = 0;

  001be	b8 01 00 00 00	 mov	 eax, 1
  001c3	48 6b c0 00	 imul	 rax, rax, 0
  001c7	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR catent$[rsp]
  001cf	c6 44 01 08 00	 mov	 BYTE PTR [rcx+rax+8], 0

; 2941 :     catent->pds2ttrp[1] = 0;

  001d4	b8 01 00 00 00	 mov	 eax, 1
  001d9	48 6b c0 01	 imul	 rax, rax, 1
  001dd	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR catent$[rsp]
  001e5	c6 44 01 08 00	 mov	 BYTE PTR [rcx+rax+8], 0

; 2942 :     catent->pds2ttrp[2] = 1;

  001ea	b8 01 00 00 00	 mov	 eax, 1
  001ef	48 6b c0 02	 imul	 rax, rax, 2
  001f3	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR catent$[rsp]
  001fb	c6 44 01 08 01	 mov	 BYTE PTR [rcx+rax+8], 1

; 2943 : 
; 2944 :     /* Indicator byte X'05' means 5 user halfwords follow, and
; 2945 :        uniquely identifies this catalog entry as a VICE */
; 2946 :     catent->pds2indc = 5;

  00200	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR catent$[rsp]
  00208	c6 40 0b 05	 mov	 BYTE PTR [rax+11], 5

; 2947 : 
; 2948 :     /* Set the TTR of the last block of the catalog */
; 2949 :     catent->pds2usrd[0] = ((extsize - 1) >> 8) & 0xFF;

  0020c	8b 84 24 50 81
	00 00		 mov	 eax, DWORD PTR extsize$[rsp]
  00213	ff c8		 dec	 eax
  00215	c1 f8 08	 sar	 eax, 8
  00218	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  0021d	b9 01 00 00 00	 mov	 ecx, 1
  00222	48 6b c9 00	 imul	 rcx, rcx, 0
  00226	48 8b 94 24 80
	00 00 00	 mov	 rdx, QWORD PTR catent$[rsp]
  0022e	88 44 0a 0c	 mov	 BYTE PTR [rdx+rcx+12], al

; 2950 :     catent->pds2usrd[1] = (extsize - 1) & 0xFF;

  00232	8b 84 24 50 81
	00 00		 mov	 eax, DWORD PTR extsize$[rsp]
  00239	ff c8		 dec	 eax
  0023b	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  00240	b9 01 00 00 00	 mov	 ecx, 1
  00245	48 6b c9 01	 imul	 rcx, rcx, 1
  00249	48 8b 94 24 80
	00 00 00	 mov	 rdx, QWORD PTR catent$[rsp]
  00251	88 44 0a 0c	 mov	 BYTE PTR [rdx+rcx+12], al

; 2951 :     catent->pds2usrd[2] = (BYTE) blkptrk;

  00255	b8 01 00 00 00	 mov	 eax, 1
  0025a	48 6b c0 02	 imul	 rax, rax, 2
  0025e	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR catent$[rsp]
  00266	0f b6 94 24 b8
	00 00 00	 movzx	 edx, BYTE PTR blkptrk$[rsp]
  0026e	88 54 01 0c	 mov	 BYTE PTR [rcx+rax+12], dl

; 2952 :     catent->pds2usrd[3] = 0;

  00272	b8 01 00 00 00	 mov	 eax, 1
  00277	48 6b c0 03	 imul	 rax, rax, 3
  0027b	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR catent$[rsp]
  00283	c6 44 01 0c 00	 mov	 BYTE PTR [rcx+rax+12], 0

; 2953 : 
; 2954 :     /* Set the TTR of the first unused block (X'000003') */
; 2955 :     catent->pds2usrd[4] = 0;

  00288	b8 01 00 00 00	 mov	 eax, 1
  0028d	48 6b c0 04	 imul	 rax, rax, 4
  00291	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR catent$[rsp]
  00299	c6 44 01 0c 00	 mov	 BYTE PTR [rcx+rax+12], 0

; 2956 :     catent->pds2usrd[5] = 0;

  0029e	b8 01 00 00 00	 mov	 eax, 1
  002a3	48 6b c0 05	 imul	 rax, rax, 5
  002a7	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR catent$[rsp]
  002af	c6 44 01 0c 00	 mov	 BYTE PTR [rcx+rax+12], 0

; 2957 :     catent->pds2usrd[6] = 3;

  002b4	b8 01 00 00 00	 mov	 eax, 1
  002b9	48 6b c0 06	 imul	 rax, rax, 6
  002bd	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR catent$[rsp]
  002c5	c6 44 01 0c 03	 mov	 BYTE PTR [rcx+rax+12], 3

; 2958 : 
; 2959 :     /* Remainder of user data is 0 */
; 2960 :     catent->pds2usrd[7] = 0;

  002ca	b8 01 00 00 00	 mov	 eax, 1
  002cf	48 6b c0 07	 imul	 rax, rax, 7
  002d3	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR catent$[rsp]
  002db	c6 44 01 0c 00	 mov	 BYTE PTR [rcx+rax+12], 0

; 2961 :     catent->pds2usrd[8] = 0;

  002e0	b8 01 00 00 00	 mov	 eax, 1
  002e5	48 6b c0 08	 imul	 rax, rax, 8
  002e9	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR catent$[rsp]
  002f1	c6 44 01 0c 00	 mov	 BYTE PTR [rcx+rax+12], 0

; 2962 :     catent->pds2usrd[9] = 0;

  002f6	b8 01 00 00 00	 mov	 eax, 1
  002fb	48 6b c0 09	 imul	 rax, rax, 9
  002ff	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR catent$[rsp]
  00307	c6 44 01 0c 00	 mov	 BYTE PTR [rcx+rax+12], 0

; 2963 : 
; 2964 :     /* Increment bytes used by the length of the VICE */
; 2965 :     bytes += 22;

  0030c	8b 84 24 88 00
	00 00		 mov	 eax, DWORD PTR bytes$[rsp]
  00313	83 c0 16	 add	 eax, 22
  00316	89 84 24 88 00
	00 00		 mov	 DWORD PTR bytes$[rsp], eax

; 2966 :     catent = (PDSDIR*)(datablk.kdarea + keylen + bytes);

  0031d	48 63 84 24 8c
	00 00 00	 movsxd	 rax, DWORD PTR keylen$[rsp]
  00325	48 8d 84 04 ec
	00 00 00	 lea	 rax, QWORD PTR datablk$[rsp+rax+12]
  0032d	48 63 8c 24 88
	00 00 00	 movsxd	 rcx, DWORD PTR bytes$[rsp]
  00335	48 03 c1	 add	 rax, rcx
  00338	48 89 84 24 80
	00 00 00	 mov	 QWORD PTR catent$[rsp], rax

; 2967 : 
; 2968 :     /* Build the index pointer for SYS1 */
; 2969 :     convert_to_ebcdic (catent->pds2name, 8, "SYS1");

  00340	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR catent$[rsp]
  00348	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG162022
  0034f	ba 08 00 00 00	 mov	 edx, 8
  00354	48 8b c8	 mov	 rcx, rax
  00357	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_convert_to_ebcdic

; 2970 : 
; 2971 :     /* Set TTR of the SYS1 index block, i.e. X'000002' */
; 2972 :     catent->pds2ttrp[0] = 0;

  0035d	b8 01 00 00 00	 mov	 eax, 1
  00362	48 6b c0 00	 imul	 rax, rax, 0
  00366	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR catent$[rsp]
  0036e	c6 44 01 08 00	 mov	 BYTE PTR [rcx+rax+8], 0

; 2973 :     catent->pds2ttrp[1] = 0;

  00373	b8 01 00 00 00	 mov	 eax, 1
  00378	48 6b c0 01	 imul	 rax, rax, 1
  0037c	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR catent$[rsp]
  00384	c6 44 01 08 00	 mov	 BYTE PTR [rcx+rax+8], 0

; 2974 :     catent->pds2ttrp[2] = 2;

  00389	b8 01 00 00 00	 mov	 eax, 1
  0038e	48 6b c0 02	 imul	 rax, rax, 2
  00392	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR catent$[rsp]
  0039a	c6 44 01 08 02	 mov	 BYTE PTR [rcx+rax+8], 2

; 2975 : 
; 2976 :     /* Indicator byte X'00' means no user halfwords follow, and
; 2977 :        uniquely identifies this catalog entry as an index pointer */
; 2978 :     catent->pds2indc = 0;

  0039f	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR catent$[rsp]
  003a7	c6 40 0b 00	 mov	 BYTE PTR [rax+11], 0

; 2979 : 
; 2980 :     /* Increment bytes used by the length of the index pointer */
; 2981 :     bytes += 12;

  003ab	8b 84 24 88 00
	00 00		 mov	 eax, DWORD PTR bytes$[rsp]
  003b2	83 c0 0c	 add	 eax, 12
  003b5	89 84 24 88 00
	00 00		 mov	 DWORD PTR bytes$[rsp], eax

; 2982 :     catent = (PDSDIR*)(datablk.kdarea + keylen + bytes);

  003bc	48 63 84 24 8c
	00 00 00	 movsxd	 rax, DWORD PTR keylen$[rsp]
  003c4	48 8d 84 04 ec
	00 00 00	 lea	 rax, QWORD PTR datablk$[rsp+rax+12]
  003cc	48 63 8c 24 88
	00 00 00	 movsxd	 rcx, DWORD PTR bytes$[rsp]
  003d4	48 03 c1	 add	 rax, rcx
  003d7	48 89 84 24 80
	00 00 00	 mov	 QWORD PTR catent$[rsp], rax

; 2983 : 
; 2984 :     /* Set the last entry in block marker */
; 2985 :     memcpy( catent->pds2name, &CKD_ENDTRK, CKD_ENDTRK_SIZE );

  003df	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR catent$[rsp]
  003e7	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR CKD_ENDTRK
  003ee	48 89 08	 mov	 QWORD PTR [rax], rcx

; 2986 : 
; 2987 :     /* Increment bytes used by the last entry marker */
; 2988 :     bytes += 12;

  003f1	8b 84 24 88 00
	00 00		 mov	 eax, DWORD PTR bytes$[rsp]
  003f8	83 c0 0c	 add	 eax, 12
  003fb	89 84 24 88 00
	00 00		 mov	 DWORD PTR bytes$[rsp], eax

; 2989 :     catent = (PDSDIR*)(datablk.kdarea + keylen + bytes);

  00402	48 63 84 24 8c
	00 00 00	 movsxd	 rax, DWORD PTR keylen$[rsp]
  0040a	48 8d 84 04 ec
	00 00 00	 lea	 rax, QWORD PTR datablk$[rsp+rax+12]
  00412	48 63 8c 24 88
	00 00 00	 movsxd	 rcx, DWORD PTR bytes$[rsp]
  0041a	48 03 c1	 add	 rax, rcx
  0041d	48 89 84 24 80
	00 00 00	 mov	 QWORD PTR catent$[rsp], rax

; 2990 : 
; 2991 :     /* Set the number of bytes used in this block */
; 2992 :     store_hw( &datablk.kdarea[ keylen+0 ], bytes );

  00425	0f b7 8c 24 88
	00 00 00	 movzx	 ecx, WORD PTR bytes$[rsp]
  0042d	e8 00 00 00 00	 call	 _byteswap_ushort
  00432	8b 8c 24 8c 00
	00 00		 mov	 ecx, DWORD PTR keylen$[rsp]
  00439	48 63 c9	 movsxd	 rcx, ecx
  0043c	48 8d 8c 0c ec
	00 00 00	 lea	 rcx, QWORD PTR datablk$[rsp+rcx+12]
  00444	0f b7 d0	 movzx	 edx, ax
  00447	e8 00 00 00 00	 call	 store_hw_noswap

; 2993 : 
; 2994 :     /* Write the volume index block to the output file */
; 2995 :     rc = write_block (cif, ofname, &datablk, keylen, datalen,

  0044c	48 8d 84 24 94
	00 00 00	 lea	 rax, QWORD PTR outrec$[rsp]
  00454	48 89 44 24 78	 mov	 QWORD PTR [rsp+120], rax
  00459	48 8d 84 24 48
	81 00 00	 lea	 rax, QWORD PTR outhead$[rsp]
  00461	48 89 44 24 70	 mov	 QWORD PTR [rsp+112], rax
  00466	48 8d 84 24 40
	81 00 00	 lea	 rax, QWORD PTR outcyl$[rsp]
  0046e	48 89 44 24 68	 mov	 QWORD PTR [rsp+104], rax
  00473	48 8d 84 24 a0
	00 00 00	 lea	 rax, QWORD PTR outtrk$[rsp]
  0047b	48 89 44 24 60	 mov	 QWORD PTR [rsp+96], rax
  00480	48 8d 84 24 ac
	00 00 00	 lea	 rax, QWORD PTR outtrkbr$[rsp]
  00488	48 89 44 24 58	 mov	 QWORD PTR [rsp+88], rax
  0048d	48 8d 84 24 b4
	00 00 00	 lea	 rax, QWORD PTR outusedr$[rsp]
  00495	48 89 44 24 50	 mov	 QWORD PTR [rsp+80], rax
  0049a	48 8d 84 24 b0
	00 00 00	 lea	 rax, QWORD PTR outusedv$[rsp]
  004a2	48 89 44 24 48	 mov	 QWORD PTR [rsp+72], rax
  004a7	8b 84 24 50 81
	00 00		 mov	 eax, DWORD PTR extsize$[rsp]
  004ae	89 44 24 40	 mov	 DWORD PTR [rsp+64], eax
  004b2	8b 84 24 38 81
	00 00		 mov	 eax, DWORD PTR trklen$[rsp]
  004b9	89 44 24 38	 mov	 DWORD PTR [rsp+56], eax
  004bd	8b 84 24 30 81
	00 00		 mov	 eax, DWORD PTR heads$[rsp]
  004c4	89 44 24 30	 mov	 DWORD PTR [rsp+48], eax
  004c8	0f b7 84 24 28
	81 00 00	 movzx	 eax, WORD PTR devtype$[rsp]
  004d0	66 89 44 24 28	 mov	 WORD PTR [rsp+40], ax
  004d5	8b 84 24 90 00
	00 00		 mov	 eax, DWORD PTR datalen$[rsp]
  004dc	89 44 24 20	 mov	 DWORD PTR [rsp+32], eax
  004e0	44 8b 8c 24 8c
	00 00 00	 mov	 r9d, DWORD PTR keylen$[rsp]
  004e8	4c 8d 84 24 e0
	00 00 00	 lea	 r8, QWORD PTR datablk$[rsp]
  004f0	48 8b 94 24 10
	81 00 00	 mov	 rdx, QWORD PTR ofname$[rsp]
  004f8	48 8b 8c 24 18
	81 00 00	 mov	 rcx, QWORD PTR cif$[rsp]
  00500	e8 00 00 00 00	 call	 write_block
  00505	89 84 24 9c 00
	00 00		 mov	 DWORD PTR rc$[rsp], eax

; 2996 :                 devtype, heads, trklen, extsize,
; 2997 :                 &outusedv, &outusedr, &outtrkbr,
; 2998 :                 &outtrk, &outcyl, &outhead, &outrec);
; 2999 :     if (rc < 0) return -1;

  0050c	83 bc 24 9c 00
	00 00 00	 cmp	 DWORD PTR rc$[rsp], 0
  00514	7d 0a		 jge	 SHORT $LN7@cvol_initi
  00516	b8 ff ff ff ff	 mov	 eax, -1
  0051b	e9 50 08 00 00	 jmp	 $LN1@cvol_initi
$LN7@cvol_initi:

; 3000 : 
; 3001 :     XMINFF (4, MSG( HHC02565, "I", outcyl, outcyl, outhead, outhead, outrec, outrec ) );

  00520	8b 84 24 94 00
	00 00		 mov	 eax, DWORD PTR outrec$[rsp]
  00527	89 44 24 40	 mov	 DWORD PTR [rsp+64], eax
  0052b	8b 84 24 94 00
	00 00		 mov	 eax, DWORD PTR outrec$[rsp]
  00532	89 44 24 38	 mov	 DWORD PTR [rsp+56], eax
  00536	8b 84 24 48 81
	00 00		 mov	 eax, DWORD PTR outhead$[rsp]
  0053d	89 44 24 30	 mov	 DWORD PTR [rsp+48], eax
  00541	8b 84 24 48 81
	00 00		 mov	 eax, DWORD PTR outhead$[rsp]
  00548	89 44 24 28	 mov	 DWORD PTR [rsp+40], eax
  0054c	8b 84 24 40 81
	00 00		 mov	 eax, DWORD PTR outcyl$[rsp]
  00553	89 44 24 20	 mov	 DWORD PTR [rsp+32], eax
  00557	44 8b 8c 24 40
	81 00 00	 mov	 r9d, DWORD PTR outcyl$[rsp]
  0055f	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG162024
  00566	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG162025
  0056d	b9 04 00 00 00	 mov	 ecx, 4
  00572	e8 00 00 00 00	 call	 info_msg

; 3002 : 
; 3003 :     if (infolvl >= 5)

  00577	83 3d 00 00 00
	00 05		 cmp	 DWORD PTR infolvl, 5
  0057e	7c 22		 jl	 SHORT $LN8@cvol_initi

; 3004 :         data_dump (datablk.kdarea, keylen + datalen);

  00580	8b 84 24 90 00
	00 00		 mov	 eax, DWORD PTR datalen$[rsp]
  00587	8b 8c 24 8c 00
	00 00		 mov	 ecx, DWORD PTR keylen$[rsp]
  0058e	03 c8		 add	 ecx, eax
  00590	8b c1		 mov	 eax, ecx
  00592	8b d0		 mov	 edx, eax
  00594	48 8d 8c 24 ec
	00 00 00	 lea	 rcx, QWORD PTR datablk$[rsp+12]
  0059c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_data_dump
$LN8@cvol_initi:

; 3005 : 
; 3006 :     /* Count number of blocks written */
; 3007 :     totblks--;

  005a2	8b 84 24 98 00
	00 00		 mov	 eax, DWORD PTR totblks$[rsp]
  005a9	ff c8		 dec	 eax
  005ab	89 84 24 98 00
	00 00		 mov	 DWORD PTR totblks$[rsp], eax

; 3008 : 
; 3009 :     /*---------------------------------*/
; 3010 :     /* Initialize the SYS1 index block */
; 3011 :     /*---------------------------------*/
; 3012 :     memset (datablk.kdarea, 0, keylen + datalen);

  005b2	8b 84 24 90 00
	00 00		 mov	 eax, DWORD PTR datalen$[rsp]
  005b9	8b 8c 24 8c 00
	00 00		 mov	 ecx, DWORD PTR keylen$[rsp]
  005c0	03 c8		 add	 ecx, eax
  005c2	8b c1		 mov	 eax, ecx
  005c4	48 98		 cdqe
  005c6	48 89 84 24 c8
	00 00 00	 mov	 QWORD PTR tv299[rsp], rax
  005ce	48 8d 8c 24 ec
	00 00 00	 lea	 rcx, QWORD PTR datablk$[rsp+12]
  005d6	48 8b f9	 mov	 rdi, rcx
  005d9	33 c0		 xor	 eax, eax
  005db	48 8b 8c 24 c8
	00 00 00	 mov	 rcx, QWORD PTR tv299[rsp]
  005e3	f3 aa		 rep stosb

; 3013 : 
; 3014 :     /* The key field contains all X'FF' */
; 3015 :     memcpy( datablk.kdarea, &CKD_ENDTRK, CKD_ENDTRK_SIZE );

  005e5	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR CKD_ENDTRK
  005ec	48 89 84 24 ec
	00 00 00	 mov	 QWORD PTR datablk$[rsp+12], rax

; 3016 : 
; 3017 :     /* The first entry begins after the 2 byte count field */
; 3018 :     bytes = 2;

  005f4	c7 84 24 88 00
	00 00 02 00 00
	00		 mov	 DWORD PTR bytes$[rsp], 2

; 3019 :     catent = (PDSDIR*)(datablk.kdarea + keylen + bytes);

  005ff	48 63 84 24 8c
	00 00 00	 movsxd	 rax, DWORD PTR keylen$[rsp]
  00607	48 8d 84 04 ec
	00 00 00	 lea	 rax, QWORD PTR datablk$[rsp+rax+12]
  0060f	48 63 8c 24 88
	00 00 00	 movsxd	 rcx, DWORD PTR bytes$[rsp]
  00617	48 03 c1	 add	 rax, rcx
  0061a	48 89 84 24 80
	00 00 00	 mov	 QWORD PTR catent$[rsp], rax

; 3020 : 
; 3021 :     /* Build the index control entry (ICE) */
; 3022 : 
; 3023 :     /* The ICE name is X'0000000000000001' */
; 3024 :     memcpy (catent->pds2name, cvol_low_key, 8);

  00622	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR catent$[rsp]
  0062a	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR cvol_low_key
  00631	48 89 08	 mov	 QWORD PTR [rax], rcx

; 3025 : 
; 3026 :     /* Set TTR to highest block in this index, i.e. X'000002' */
; 3027 :     catent->pds2ttrp[0] = 0;

  00634	b8 01 00 00 00	 mov	 eax, 1
  00639	48 6b c0 00	 imul	 rax, rax, 0
  0063d	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR catent$[rsp]
  00645	c6 44 01 08 00	 mov	 BYTE PTR [rcx+rax+8], 0

; 3028 :     catent->pds2ttrp[1] = 0;

  0064a	b8 01 00 00 00	 mov	 eax, 1
  0064f	48 6b c0 01	 imul	 rax, rax, 1
  00653	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR catent$[rsp]
  0065b	c6 44 01 08 00	 mov	 BYTE PTR [rcx+rax+8], 0

; 3029 :     catent->pds2ttrp[2] = 2;

  00660	b8 01 00 00 00	 mov	 eax, 1
  00665	48 6b c0 02	 imul	 rax, rax, 2
  00669	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR catent$[rsp]
  00671	c6 44 01 08 02	 mov	 BYTE PTR [rcx+rax+8], 2

; 3030 : 
; 3031 :     /* Indicator byte X'03' means 3 user halfwords follow, and
; 3032 :        uniquely identifies this catalog entry as an ICE */
; 3033 :     catent->pds2indc = 3;

  00676	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR catent$[rsp]
  0067e	c6 40 0b 03	 mov	 BYTE PTR [rax+11], 3

; 3034 : 
; 3035 :     /* Set the TTR of this block */
; 3036 :     catent->pds2usrd[0] = 0;

  00682	b8 01 00 00 00	 mov	 eax, 1
  00687	48 6b c0 00	 imul	 rax, rax, 0
  0068b	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR catent$[rsp]
  00693	c6 44 01 0c 00	 mov	 BYTE PTR [rcx+rax+12], 0

; 3037 :     catent->pds2usrd[1] = 0;

  00698	b8 01 00 00 00	 mov	 eax, 1
  0069d	48 6b c0 01	 imul	 rax, rax, 1
  006a1	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR catent$[rsp]
  006a9	c6 44 01 0c 00	 mov	 BYTE PTR [rcx+rax+12], 0

; 3038 :     catent->pds2usrd[2] = 2;

  006ae	b8 01 00 00 00	 mov	 eax, 1
  006b3	48 6b c0 02	 imul	 rax, rax, 2
  006b7	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR catent$[rsp]
  006bf	c6 44 01 0c 02	 mov	 BYTE PTR [rcx+rax+12], 2

; 3039 : 
; 3040 :     /* The next byte contains the alias count */
; 3041 :     catent->pds2usrd[3] = 0;

  006c4	b8 01 00 00 00	 mov	 eax, 1
  006c9	48 6b c0 03	 imul	 rax, rax, 3
  006cd	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR catent$[rsp]
  006d5	c6 44 01 0c 00	 mov	 BYTE PTR [rcx+rax+12], 0

; 3042 : 
; 3043 :     /* The remaining 2 bytes of userdata are zeroes */
; 3044 :     catent->pds2usrd[4] = 0;

  006da	b8 01 00 00 00	 mov	 eax, 1
  006df	48 6b c0 04	 imul	 rax, rax, 4
  006e3	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR catent$[rsp]
  006eb	c6 44 01 0c 00	 mov	 BYTE PTR [rcx+rax+12], 0

; 3045 :     catent->pds2usrd[5] = 0;

  006f0	b8 01 00 00 00	 mov	 eax, 1
  006f5	48 6b c0 05	 imul	 rax, rax, 5
  006f9	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR catent$[rsp]
  00701	c6 44 01 0c 00	 mov	 BYTE PTR [rcx+rax+12], 0

; 3046 : 
; 3047 :     /* Increment bytes used by the length of the ICE */
; 3048 :     bytes += 18;

  00706	8b 84 24 88 00
	00 00		 mov	 eax, DWORD PTR bytes$[rsp]
  0070d	83 c0 12	 add	 eax, 18
  00710	89 84 24 88 00
	00 00		 mov	 DWORD PTR bytes$[rsp], eax

; 3049 : 
; 3050 :     /* Build the dataset pointers for SYS1.xxxxxxxx datasets */
; 3051 :     for (i = 0; i < NUM_SYS1_DATASETS; i++)

  00717	c7 84 24 a4 00
	00 00 00 00 00
	00		 mov	 DWORD PTR i$[rsp], 0
  00722	eb 10		 jmp	 SHORT $LN4@cvol_initi
$LN2@cvol_initi:
  00724	8b 84 24 a4 00
	00 00		 mov	 eax, DWORD PTR i$[rsp]
  0072b	ff c0		 inc	 eax
  0072d	89 84 24 a4 00
	00 00		 mov	 DWORD PTR i$[rsp], eax
$LN4@cvol_initi:
  00734	83 bc 24 a4 00
	00 00 08	 cmp	 DWORD PTR i$[rsp], 8
  0073c	0f 8d c7 01 00
	00		 jge	 $LN3@cvol_initi

; 3052 :     {
; 3053 :         /* Point to next dataset pointer entry */
; 3054 :         catent = (PDSDIR*)(datablk.kdarea + keylen + bytes);

  00742	48 63 84 24 8c
	00 00 00	 movsxd	 rax, DWORD PTR keylen$[rsp]
  0074a	48 8d 84 04 ec
	00 00 00	 lea	 rax, QWORD PTR datablk$[rsp+rax+12]
  00752	48 63 8c 24 88
	00 00 00	 movsxd	 rcx, DWORD PTR bytes$[rsp]
  0075a	48 03 c1	 add	 rax, rcx
  0075d	48 89 84 24 80
	00 00 00	 mov	 QWORD PTR catent$[rsp], rax

; 3055 : 
; 3056 :         /* Set the name of the dataset pointer entry */
; 3057 :         convert_to_ebcdic (catent->pds2name, 8, sys1name[i]);

  00765	48 63 84 24 a4
	00 00 00	 movsxd	 rax, DWORD PTR i$[rsp]
  0076d	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:?sys1name@?1??cvol_initialize@@9@9
  00774	48 8b 94 24 80
	00 00 00	 mov	 rdx, QWORD PTR catent$[rsp]
  0077c	48 89 94 24 d0
	00 00 00	 mov	 QWORD PTR tv361[rsp], rdx
  00784	4c 8b 04 c1	 mov	 r8, QWORD PTR [rcx+rax*8]
  00788	ba 08 00 00 00	 mov	 edx, 8
  0078d	48 8b 84 24 d0
	00 00 00	 mov	 rax, QWORD PTR tv361[rsp]
  00795	48 8b c8	 mov	 rcx, rax
  00798	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_convert_to_ebcdic

; 3058 : 
; 3059 :         /* Set the TTR to zero */
; 3060 :         catent->pds2ttrp[0] = 0;

  0079e	b8 01 00 00 00	 mov	 eax, 1
  007a3	48 6b c0 00	 imul	 rax, rax, 0
  007a7	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR catent$[rsp]
  007af	c6 44 01 08 00	 mov	 BYTE PTR [rcx+rax+8], 0

; 3061 :         catent->pds2ttrp[1] = 0;

  007b4	b8 01 00 00 00	 mov	 eax, 1
  007b9	48 6b c0 01	 imul	 rax, rax, 1
  007bd	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR catent$[rsp]
  007c5	c6 44 01 08 00	 mov	 BYTE PTR [rcx+rax+8], 0

; 3062 :         catent->pds2ttrp[2] = 0;

  007ca	b8 01 00 00 00	 mov	 eax, 1
  007cf	48 6b c0 02	 imul	 rax, rax, 2
  007d3	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR catent$[rsp]
  007db	c6 44 01 08 00	 mov	 BYTE PTR [rcx+rax+8], 0

; 3063 : 
; 3064 :         /* Indicator byte X'07' means 7 user halfwords follow, and
; 3065 :            uniquely identifies the entry as a dataset pointer */
; 3066 :         catent->pds2indc = 7;

  007e0	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR catent$[rsp]
  007e8	c6 40 0b 07	 mov	 BYTE PTR [rax+11], 7

; 3067 : 
; 3068 :         /* The next two bytes contain the volume count (X'0001') */
; 3069 :         catent->pds2usrd[0] = 0;

  007ec	b8 01 00 00 00	 mov	 eax, 1
  007f1	48 6b c0 00	 imul	 rax, rax, 0
  007f5	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR catent$[rsp]
  007fd	c6 44 01 0c 00	 mov	 BYTE PTR [rcx+rax+12], 0

; 3070 :         catent->pds2usrd[1] = 1;

  00802	b8 01 00 00 00	 mov	 eax, 1
  00807	48 6b c0 01	 imul	 rax, rax, 1
  0080b	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR catent$[rsp]
  00813	c6 44 01 0c 01	 mov	 BYTE PTR [rcx+rax+12], 1

; 3071 : 
; 3072 :         /* The next four bytes contain the UCB type */
; 3073 :         catent->pds2usrd[2] = (ucbtype >> 24) & 0xFF;

  00818	8b 84 24 a8 00
	00 00		 mov	 eax, DWORD PTR ucbtype$[rsp]
  0081f	c1 e8 18	 shr	 eax, 24
  00822	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  00827	b9 01 00 00 00	 mov	 ecx, 1
  0082c	48 6b c9 02	 imul	 rcx, rcx, 2
  00830	48 8b 94 24 80
	00 00 00	 mov	 rdx, QWORD PTR catent$[rsp]
  00838	88 44 0a 0c	 mov	 BYTE PTR [rdx+rcx+12], al

; 3074 :         catent->pds2usrd[3] = (ucbtype >> 16) & 0xFF;

  0083c	8b 84 24 a8 00
	00 00		 mov	 eax, DWORD PTR ucbtype$[rsp]
  00843	c1 e8 10	 shr	 eax, 16
  00846	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  0084b	b9 01 00 00 00	 mov	 ecx, 1
  00850	48 6b c9 03	 imul	 rcx, rcx, 3
  00854	48 8b 94 24 80
	00 00 00	 mov	 rdx, QWORD PTR catent$[rsp]
  0085c	88 44 0a 0c	 mov	 BYTE PTR [rdx+rcx+12], al

; 3075 :         catent->pds2usrd[4] = (ucbtype >> 8) & 0xFF;

  00860	8b 84 24 a8 00
	00 00		 mov	 eax, DWORD PTR ucbtype$[rsp]
  00867	c1 e8 08	 shr	 eax, 8
  0086a	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  0086f	b9 01 00 00 00	 mov	 ecx, 1
  00874	48 6b c9 04	 imul	 rcx, rcx, 4
  00878	48 8b 94 24 80
	00 00 00	 mov	 rdx, QWORD PTR catent$[rsp]
  00880	88 44 0a 0c	 mov	 BYTE PTR [rdx+rcx+12], al

; 3076 :         catent->pds2usrd[5] = ucbtype & 0xFF;

  00884	8b 84 24 a8 00
	00 00		 mov	 eax, DWORD PTR ucbtype$[rsp]
  0088b	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  00890	b9 01 00 00 00	 mov	 ecx, 1
  00895	48 6b c9 05	 imul	 rcx, rcx, 5
  00899	48 8b 94 24 80
	00 00 00	 mov	 rdx, QWORD PTR catent$[rsp]
  008a1	88 44 0a 0c	 mov	 BYTE PTR [rdx+rcx+12], al

; 3077 : 
; 3078 :         /* The next six bytes contain the volume serial number */
; 3079 :         convert_to_ebcdic (catent->pds2usrd+6, 6, volser);

  008a5	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR catent$[rsp]
  008ad	48 83 c0 12	 add	 rax, 18
  008b1	4c 8b 84 24 20
	81 00 00	 mov	 r8, QWORD PTR volser$[rsp]
  008b9	ba 06 00 00 00	 mov	 edx, 6
  008be	48 8b c8	 mov	 rcx, rax
  008c1	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_convert_to_ebcdic

; 3080 : 
; 3081 :         /* The next two bytes contain the volume seq.no. (X'0000') */
; 3082 :         catent->pds2usrd[12] = 0;

  008c7	b8 01 00 00 00	 mov	 eax, 1
  008cc	48 6b c0 0c	 imul	 rax, rax, 12
  008d0	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR catent$[rsp]
  008d8	c6 44 01 0c 00	 mov	 BYTE PTR [rcx+rax+12], 0

; 3083 :         catent->pds2usrd[13] = 0;

  008dd	b8 01 00 00 00	 mov	 eax, 1
  008e2	48 6b c0 0d	 imul	 rax, rax, 13
  008e6	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR catent$[rsp]
  008ee	c6 44 01 0c 00	 mov	 BYTE PTR [rcx+rax+12], 0

; 3084 : 
; 3085 :         /* Increment bytes used by the length of the dataset pointer */
; 3086 :         bytes += 26;

  008f3	8b 84 24 88 00
	00 00		 mov	 eax, DWORD PTR bytes$[rsp]
  008fa	83 c0 1a	 add	 eax, 26
  008fd	89 84 24 88 00
	00 00		 mov	 DWORD PTR bytes$[rsp], eax

; 3087 : 
; 3088 :     } /* end for(i) */

  00904	e9 1b fe ff ff	 jmp	 $LN2@cvol_initi
$LN3@cvol_initi:

; 3089 : 
; 3090 :     /* Point to last entry in block */
; 3091 :     catent = (PDSDIR*)(datablk.kdarea + keylen + bytes);

  00909	48 63 84 24 8c
	00 00 00	 movsxd	 rax, DWORD PTR keylen$[rsp]
  00911	48 8d 84 04 ec
	00 00 00	 lea	 rax, QWORD PTR datablk$[rsp+rax+12]
  00919	48 63 8c 24 88
	00 00 00	 movsxd	 rcx, DWORD PTR bytes$[rsp]
  00921	48 03 c1	 add	 rax, rcx
  00924	48 89 84 24 80
	00 00 00	 mov	 QWORD PTR catent$[rsp], rax

; 3092 : 
; 3093 :     /* Set the last entry in block marker */
; 3094 :     memcpy( catent->pds2name, &CKD_ENDTRK, CKD_ENDTRK_SIZE );

  0092c	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR catent$[rsp]
  00934	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR CKD_ENDTRK
  0093b	48 89 08	 mov	 QWORD PTR [rax], rcx

; 3095 : 
; 3096 :     /* Increment bytes used by the last entry marker */
; 3097 :     bytes += 12;

  0093e	8b 84 24 88 00
	00 00		 mov	 eax, DWORD PTR bytes$[rsp]
  00945	83 c0 0c	 add	 eax, 12
  00948	89 84 24 88 00
	00 00		 mov	 DWORD PTR bytes$[rsp], eax

; 3098 :     catent = (PDSDIR*)(datablk.kdarea + keylen + bytes);

  0094f	48 63 84 24 8c
	00 00 00	 movsxd	 rax, DWORD PTR keylen$[rsp]
  00957	48 8d 84 04 ec
	00 00 00	 lea	 rax, QWORD PTR datablk$[rsp+rax+12]
  0095f	48 63 8c 24 88
	00 00 00	 movsxd	 rcx, DWORD PTR bytes$[rsp]
  00967	48 03 c1	 add	 rax, rcx
  0096a	48 89 84 24 80
	00 00 00	 mov	 QWORD PTR catent$[rsp], rax

; 3099 : 
; 3100 :     /* Set the number of bytes used in this block */
; 3101 :     store_hw( &datablk.kdarea[ keylen+0 ], bytes );

  00972	0f b7 8c 24 88
	00 00 00	 movzx	 ecx, WORD PTR bytes$[rsp]
  0097a	e8 00 00 00 00	 call	 _byteswap_ushort
  0097f	8b 8c 24 8c 00
	00 00		 mov	 ecx, DWORD PTR keylen$[rsp]
  00986	48 63 c9	 movsxd	 rcx, ecx
  00989	48 8d 8c 0c ec
	00 00 00	 lea	 rcx, QWORD PTR datablk$[rsp+rcx+12]
  00991	0f b7 d0	 movzx	 edx, ax
  00994	e8 00 00 00 00	 call	 store_hw_noswap

; 3102 : 
; 3103 :     /* Write the index block to the output file */
; 3104 :     rc = write_block (cif, ofname, &datablk, keylen, datalen,

  00999	48 8d 84 24 94
	00 00 00	 lea	 rax, QWORD PTR outrec$[rsp]
  009a1	48 89 44 24 78	 mov	 QWORD PTR [rsp+120], rax
  009a6	48 8d 84 24 48
	81 00 00	 lea	 rax, QWORD PTR outhead$[rsp]
  009ae	48 89 44 24 70	 mov	 QWORD PTR [rsp+112], rax
  009b3	48 8d 84 24 40
	81 00 00	 lea	 rax, QWORD PTR outcyl$[rsp]
  009bb	48 89 44 24 68	 mov	 QWORD PTR [rsp+104], rax
  009c0	48 8d 84 24 a0
	00 00 00	 lea	 rax, QWORD PTR outtrk$[rsp]
  009c8	48 89 44 24 60	 mov	 QWORD PTR [rsp+96], rax
  009cd	48 8d 84 24 ac
	00 00 00	 lea	 rax, QWORD PTR outtrkbr$[rsp]
  009d5	48 89 44 24 58	 mov	 QWORD PTR [rsp+88], rax
  009da	48 8d 84 24 b4
	00 00 00	 lea	 rax, QWORD PTR outusedr$[rsp]
  009e2	48 89 44 24 50	 mov	 QWORD PTR [rsp+80], rax
  009e7	48 8d 84 24 b0
	00 00 00	 lea	 rax, QWORD PTR outusedv$[rsp]
  009ef	48 89 44 24 48	 mov	 QWORD PTR [rsp+72], rax
  009f4	8b 84 24 50 81
	00 00		 mov	 eax, DWORD PTR extsize$[rsp]
  009fb	89 44 24 40	 mov	 DWORD PTR [rsp+64], eax
  009ff	8b 84 24 38 81
	00 00		 mov	 eax, DWORD PTR trklen$[rsp]
  00a06	89 44 24 38	 mov	 DWORD PTR [rsp+56], eax
  00a0a	8b 84 24 30 81
	00 00		 mov	 eax, DWORD PTR heads$[rsp]
  00a11	89 44 24 30	 mov	 DWORD PTR [rsp+48], eax
  00a15	0f b7 84 24 28
	81 00 00	 movzx	 eax, WORD PTR devtype$[rsp]
  00a1d	66 89 44 24 28	 mov	 WORD PTR [rsp+40], ax
  00a22	8b 84 24 90 00
	00 00		 mov	 eax, DWORD PTR datalen$[rsp]
  00a29	89 44 24 20	 mov	 DWORD PTR [rsp+32], eax
  00a2d	44 8b 8c 24 8c
	00 00 00	 mov	 r9d, DWORD PTR keylen$[rsp]
  00a35	4c 8d 84 24 e0
	00 00 00	 lea	 r8, QWORD PTR datablk$[rsp]
  00a3d	48 8b 94 24 10
	81 00 00	 mov	 rdx, QWORD PTR ofname$[rsp]
  00a45	48 8b 8c 24 18
	81 00 00	 mov	 rcx, QWORD PTR cif$[rsp]
  00a4d	e8 00 00 00 00	 call	 write_block
  00a52	89 84 24 9c 00
	00 00		 mov	 DWORD PTR rc$[rsp], eax

; 3105 :                 devtype, heads, trklen, extsize,
; 3106 :                 &outusedv, &outusedr, &outtrkbr,
; 3107 :                 &outtrk, &outcyl, &outhead, &outrec);
; 3108 :     if (rc < 0) return -1;

  00a59	83 bc 24 9c 00
	00 00 00	 cmp	 DWORD PTR rc$[rsp], 0
  00a61	7d 0a		 jge	 SHORT $LN9@cvol_initi
  00a63	b8 ff ff ff ff	 mov	 eax, -1
  00a68	e9 03 03 00 00	 jmp	 $LN1@cvol_initi
$LN9@cvol_initi:

; 3109 : 
; 3110 :     XMINFF (4, MSG( HHC02565, "I", outcyl, outcyl, outhead, outhead, outrec, outrec ) );

  00a6d	8b 84 24 94 00
	00 00		 mov	 eax, DWORD PTR outrec$[rsp]
  00a74	89 44 24 40	 mov	 DWORD PTR [rsp+64], eax
  00a78	8b 84 24 94 00
	00 00		 mov	 eax, DWORD PTR outrec$[rsp]
  00a7f	89 44 24 38	 mov	 DWORD PTR [rsp+56], eax
  00a83	8b 84 24 48 81
	00 00		 mov	 eax, DWORD PTR outhead$[rsp]
  00a8a	89 44 24 30	 mov	 DWORD PTR [rsp+48], eax
  00a8e	8b 84 24 48 81
	00 00		 mov	 eax, DWORD PTR outhead$[rsp]
  00a95	89 44 24 28	 mov	 DWORD PTR [rsp+40], eax
  00a99	8b 84 24 40 81
	00 00		 mov	 eax, DWORD PTR outcyl$[rsp]
  00aa0	89 44 24 20	 mov	 DWORD PTR [rsp+32], eax
  00aa4	44 8b 8c 24 40
	81 00 00	 mov	 r9d, DWORD PTR outcyl$[rsp]
  00aac	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG162028
  00ab3	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG162029
  00aba	b9 04 00 00 00	 mov	 ecx, 4
  00abf	e8 00 00 00 00	 call	 info_msg

; 3111 : 
; 3112 :     if (infolvl >= 5) data_dump (datablk.kdarea, keylen + datalen);

  00ac4	83 3d 00 00 00
	00 05		 cmp	 DWORD PTR infolvl, 5
  00acb	7c 22		 jl	 SHORT $LN10@cvol_initi
  00acd	8b 84 24 90 00
	00 00		 mov	 eax, DWORD PTR datalen$[rsp]
  00ad4	8b 8c 24 8c 00
	00 00		 mov	 ecx, DWORD PTR keylen$[rsp]
  00adb	03 c8		 add	 ecx, eax
  00add	8b c1		 mov	 eax, ecx
  00adf	8b d0		 mov	 edx, eax
  00ae1	48 8d 8c 24 ec
	00 00 00	 lea	 rcx, QWORD PTR datablk$[rsp+12]
  00ae9	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_data_dump
$LN10@cvol_initi:

; 3113 : 
; 3114 :     /* Count number of blocks written */
; 3115 :     totblks--;

  00aef	8b 84 24 98 00
	00 00		 mov	 eax, DWORD PTR totblks$[rsp]
  00af6	ff c8		 dec	 eax
  00af8	89 84 24 98 00
	00 00		 mov	 DWORD PTR totblks$[rsp], eax
$LN5@cvol_initi:

; 3116 : 
; 3117 :     /*--------------------------------------------*/
; 3118 :     /* Initialize remaining unused catalog blocks */
; 3119 :     /*--------------------------------------------*/
; 3120 :     while (totblks > 0)

  00aff	83 bc 24 98 00
	00 00 00	 cmp	 DWORD PTR totblks$[rsp], 0
  00b07	0f 8e 9e 01 00
	00		 jle	 $LN6@cvol_initi

; 3121 :     {
; 3122 :         memset (datablk.kdarea, 0, keylen + datalen);

  00b0d	8b 84 24 90 00
	00 00		 mov	 eax, DWORD PTR datalen$[rsp]
  00b14	8b 8c 24 8c 00
	00 00		 mov	 ecx, DWORD PTR keylen$[rsp]
  00b1b	03 c8		 add	 ecx, eax
  00b1d	8b c1		 mov	 eax, ecx
  00b1f	48 98		 cdqe
  00b21	48 89 84 24 d8
	00 00 00	 mov	 QWORD PTR tv475[rsp], rax
  00b29	48 8d 8c 24 ec
	00 00 00	 lea	 rcx, QWORD PTR datablk$[rsp+12]
  00b31	48 8b f9	 mov	 rdi, rcx
  00b34	33 c0		 xor	 eax, eax
  00b36	48 8b 8c 24 d8
	00 00 00	 mov	 rcx, QWORD PTR tv475[rsp]
  00b3e	f3 aa		 rep stosb

; 3123 : 
; 3124 :         /* Write the volume index block to the output file */
; 3125 :         rc = write_block (cif, ofname, &datablk, keylen, datalen,

  00b40	48 8d 84 24 94
	00 00 00	 lea	 rax, QWORD PTR outrec$[rsp]
  00b48	48 89 44 24 78	 mov	 QWORD PTR [rsp+120], rax
  00b4d	48 8d 84 24 48
	81 00 00	 lea	 rax, QWORD PTR outhead$[rsp]
  00b55	48 89 44 24 70	 mov	 QWORD PTR [rsp+112], rax
  00b5a	48 8d 84 24 40
	81 00 00	 lea	 rax, QWORD PTR outcyl$[rsp]
  00b62	48 89 44 24 68	 mov	 QWORD PTR [rsp+104], rax
  00b67	48 8d 84 24 a0
	00 00 00	 lea	 rax, QWORD PTR outtrk$[rsp]
  00b6f	48 89 44 24 60	 mov	 QWORD PTR [rsp+96], rax
  00b74	48 8d 84 24 ac
	00 00 00	 lea	 rax, QWORD PTR outtrkbr$[rsp]
  00b7c	48 89 44 24 58	 mov	 QWORD PTR [rsp+88], rax
  00b81	48 8d 84 24 b4
	00 00 00	 lea	 rax, QWORD PTR outusedr$[rsp]
  00b89	48 89 44 24 50	 mov	 QWORD PTR [rsp+80], rax
  00b8e	48 8d 84 24 b0
	00 00 00	 lea	 rax, QWORD PTR outusedv$[rsp]
  00b96	48 89 44 24 48	 mov	 QWORD PTR [rsp+72], rax
  00b9b	8b 84 24 50 81
	00 00		 mov	 eax, DWORD PTR extsize$[rsp]
  00ba2	89 44 24 40	 mov	 DWORD PTR [rsp+64], eax
  00ba6	8b 84 24 38 81
	00 00		 mov	 eax, DWORD PTR trklen$[rsp]
  00bad	89 44 24 38	 mov	 DWORD PTR [rsp+56], eax
  00bb1	8b 84 24 30 81
	00 00		 mov	 eax, DWORD PTR heads$[rsp]
  00bb8	89 44 24 30	 mov	 DWORD PTR [rsp+48], eax
  00bbc	0f b7 84 24 28
	81 00 00	 movzx	 eax, WORD PTR devtype$[rsp]
  00bc4	66 89 44 24 28	 mov	 WORD PTR [rsp+40], ax
  00bc9	8b 84 24 90 00
	00 00		 mov	 eax, DWORD PTR datalen$[rsp]
  00bd0	89 44 24 20	 mov	 DWORD PTR [rsp+32], eax
  00bd4	44 8b 8c 24 8c
	00 00 00	 mov	 r9d, DWORD PTR keylen$[rsp]
  00bdc	4c 8d 84 24 e0
	00 00 00	 lea	 r8, QWORD PTR datablk$[rsp]
  00be4	48 8b 94 24 10
	81 00 00	 mov	 rdx, QWORD PTR ofname$[rsp]
  00bec	48 8b 8c 24 18
	81 00 00	 mov	 rcx, QWORD PTR cif$[rsp]
  00bf4	e8 00 00 00 00	 call	 write_block
  00bf9	89 84 24 9c 00
	00 00		 mov	 DWORD PTR rc$[rsp], eax

; 3126 :                     devtype, heads, trklen, extsize,
; 3127 :                     &outusedv, &outusedr, &outtrkbr,
; 3128 :                     &outtrk, &outcyl, &outhead, &outrec);
; 3129 :         if (rc < 0) return -1;

  00c00	83 bc 24 9c 00
	00 00 00	 cmp	 DWORD PTR rc$[rsp], 0
  00c08	7d 0a		 jge	 SHORT $LN11@cvol_initi
  00c0a	b8 ff ff ff ff	 mov	 eax, -1
  00c0f	e9 5c 01 00 00	 jmp	 $LN1@cvol_initi
$LN11@cvol_initi:

; 3130 : 
; 3131 :         XMINFF (4, MSG( HHC02565, "I", outcyl, outcyl, outhead, outhead, outrec, outrec ) );

  00c14	8b 84 24 94 00
	00 00		 mov	 eax, DWORD PTR outrec$[rsp]
  00c1b	89 44 24 40	 mov	 DWORD PTR [rsp+64], eax
  00c1f	8b 84 24 94 00
	00 00		 mov	 eax, DWORD PTR outrec$[rsp]
  00c26	89 44 24 38	 mov	 DWORD PTR [rsp+56], eax
  00c2a	8b 84 24 48 81
	00 00		 mov	 eax, DWORD PTR outhead$[rsp]
  00c31	89 44 24 30	 mov	 DWORD PTR [rsp+48], eax
  00c35	8b 84 24 48 81
	00 00		 mov	 eax, DWORD PTR outhead$[rsp]
  00c3c	89 44 24 28	 mov	 DWORD PTR [rsp+40], eax
  00c40	8b 84 24 40 81
	00 00		 mov	 eax, DWORD PTR outcyl$[rsp]
  00c47	89 44 24 20	 mov	 DWORD PTR [rsp+32], eax
  00c4b	44 8b 8c 24 40
	81 00 00	 mov	 r9d, DWORD PTR outcyl$[rsp]
  00c53	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG162032
  00c5a	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG162033
  00c61	b9 04 00 00 00	 mov	 ecx, 4
  00c66	e8 00 00 00 00	 call	 info_msg

; 3132 : 
; 3133 :         if (infolvl >= 5) data_dump (datablk.kdarea, keylen + datalen);

  00c6b	83 3d 00 00 00
	00 05		 cmp	 DWORD PTR infolvl, 5
  00c72	7c 22		 jl	 SHORT $LN12@cvol_initi
  00c74	8b 84 24 90 00
	00 00		 mov	 eax, DWORD PTR datalen$[rsp]
  00c7b	8b 8c 24 8c 00
	00 00		 mov	 ecx, DWORD PTR keylen$[rsp]
  00c82	03 c8		 add	 ecx, eax
  00c84	8b c1		 mov	 eax, ecx
  00c86	8b d0		 mov	 edx, eax
  00c88	48 8d 8c 24 ec
	00 00 00	 lea	 rcx, QWORD PTR datablk$[rsp+12]
  00c90	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_data_dump
$LN12@cvol_initi:

; 3134 : 
; 3135 :         /* Count number of blocks written */
; 3136 :         totblks--;

  00c96	8b 84 24 98 00
	00 00		 mov	 eax, DWORD PTR totblks$[rsp]
  00c9d	ff c8		 dec	 eax
  00c9f	89 84 24 98 00
	00 00		 mov	 DWORD PTR totblks$[rsp], eax

; 3137 : 
; 3138 :     } /* end while(totblks) */

  00ca6	e9 54 fe ff ff	 jmp	 $LN5@cvol_initi
$LN6@cvol_initi:

; 3139 : 
; 3140 :     /* Set the last record number to X'FF' so that OS/360 catalog
; 3141 :        management routines can recognize that the CVOL has been
; 3142 :        initialized by detecting X'FF' at ds1lstar+2 in the VTOC */
; 3143 :     *lastrec = 0xFF;

  00cab	48 8b 84 24 58
	81 00 00	 mov	 rax, QWORD PTR lastrec$[rsp]
  00cb3	c7 00 ff 00 00
	00		 mov	 DWORD PTR [rax], 255	; 000000ffH

; 3144 : 
; 3145 :     /* Return the track balance */
; 3146 :     *trkbal = outtrkbr;

  00cb9	48 8b 84 24 60
	81 00 00	 mov	 rax, QWORD PTR trkbal$[rsp]
  00cc1	8b 8c 24 ac 00
	00 00		 mov	 ecx, DWORD PTR outtrkbr$[rsp]
  00cc8	89 08		 mov	 DWORD PTR [rax], ecx

; 3147 : 
; 3148 :     /* Write data remaining in track buffer */
; 3149 :     rc = write_track (cif, ofname, heads, trklen,

  00cca	48 8d 84 24 48
	81 00 00	 lea	 rax, QWORD PTR outhead$[rsp]
  00cd2	48 89 44 24 38	 mov	 QWORD PTR [rsp+56], rax
  00cd7	48 8d 84 24 40
	81 00 00	 lea	 rax, QWORD PTR outcyl$[rsp]
  00cdf	48 89 44 24 30	 mov	 QWORD PTR [rsp+48], rax
  00ce4	48 8d 84 24 a0
	00 00 00	 lea	 rax, QWORD PTR outtrk$[rsp]
  00cec	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  00cf1	48 8d 84 24 b0
	00 00 00	 lea	 rax, QWORD PTR outusedv$[rsp]
  00cf9	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00cfe	44 8b 8c 24 38
	81 00 00	 mov	 r9d, DWORD PTR trklen$[rsp]
  00d06	44 8b 84 24 30
	81 00 00	 mov	 r8d, DWORD PTR heads$[rsp]
  00d0e	48 8b 94 24 10
	81 00 00	 mov	 rdx, QWORD PTR ofname$[rsp]
  00d16	48 8b 8c 24 18
	81 00 00	 mov	 rcx, QWORD PTR cif$[rsp]
  00d1e	e8 00 00 00 00	 call	 write_track
  00d23	89 84 24 9c 00
	00 00		 mov	 DWORD PTR rc$[rsp], eax

; 3150 :                     &outusedv, &outtrk, &outcyl, &outhead);
; 3151 :     if (rc < 0) return -1;

  00d2a	83 bc 24 9c 00
	00 00 00	 cmp	 DWORD PTR rc$[rsp], 0
  00d32	7d 07		 jge	 SHORT $LN13@cvol_initi
  00d34	b8 ff ff ff ff	 mov	 eax, -1
  00d39	eb 35		 jmp	 SHORT $LN1@cvol_initi
$LN13@cvol_initi:

; 3152 : 
; 3153 :     /* Return number of tracks and starting address of next dataset */
; 3154 :     *numtrks = outtrk;

  00d3b	48 8b 84 24 68
	81 00 00	 mov	 rax, QWORD PTR numtrks$[rsp]
  00d43	8b 8c 24 a0 00
	00 00		 mov	 ecx, DWORD PTR outtrk$[rsp]
  00d4a	89 08		 mov	 DWORD PTR [rax], ecx

; 3155 :     *nxtcyl = outcyl;

  00d4c	48 8b 84 24 70
	81 00 00	 mov	 rax, QWORD PTR nxtcyl$[rsp]
  00d54	8b 8c 24 40 81
	00 00		 mov	 ecx, DWORD PTR outcyl$[rsp]
  00d5b	89 08		 mov	 DWORD PTR [rax], ecx

; 3156 :     *nxthead = outhead;

  00d5d	48 8b 84 24 78
	81 00 00	 mov	 rax, QWORD PTR nxthead$[rsp]
  00d65	8b 8c 24 48 81
	00 00		 mov	 ecx, DWORD PTR outhead$[rsp]
  00d6c	89 08		 mov	 DWORD PTR [rax], ecx

; 3157 :     return 0;

  00d6e	33 c0		 xor	 eax, eax
$LN1@cvol_initi:

; 3158 : 
; 3159 : } /* end function cvol_initialize */

  00d70	48 8b 8c 24 f0
	80 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  00d78	48 33 cc	 xor	 rcx, rsp
  00d7b	e8 00 00 00 00	 call	 __security_check_cookie
  00d80	48 81 c4 00 81
	00 00		 add	 rsp, 33024		; 00008100H
  00d87	5f		 pop	 rdi
  00d88	c3		 ret	 0
cvol_initialize ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\dasdload64.c
_TEXT	SEGMENT
rc$ = 128
dsorg$ = 132
recfm$ = 133
xctl$ = 134
datablk$ = 136
xreclen$ = 144
numttr$ = 148
i$ = 152
lrecl$ = 156
blksz$ = 160
keyln$ = 164
blkrec$ = 168
xfd$ = 172
xbuf$ = 176
datarecn$ = 184
outrec$ = 188
datalen$ = 192
keylen$ = 196
outtrk$ = 200
blkhead$ = 204
blkcyl$ = 208
dirblkn$ = 212
datafiln$ = 216
blktrk$ = 220
copyfiln$ = 224
enddir$ = 228
ttrtab$ = 232
numext$ = 240
origheads$ = 244
blklen$ = 248
copyr1$ = 256
dirblka$ = 264
tv360 = 272
outtrkbr$ = 276
outusedv$ = 280
outusedr$ = 284
dirnm$ = 288
dsstart$ = 292
blkptr$ = 296
tv256 = 304
xarray$ = 320
xrecname$ = 480
pathname$ = 496
__$ArrayPad$ = 768
xfname$ = 800
ofname$ = 808
cif$ = 816
devtype$ = 824
heads$ = 832
trklen$ = 840
outcyl$ = 848
outhead$ = 856
maxtrks$ = 864
method$ = 872
odsorg$ = 880
orecfm$ = 888
olrecl$ = 896
oblksz$ = 904
okeyln$ = 912
dirblu$ = 920
lastrec$ = 928
trkbal$ = 936
numtrks$ = 944
nxtcyl$ = 952
nxthead$ = 960
process_iebcopy_file PROC

; 2536 : {

  00000	66 44 89 4c 24
	20		 mov	 WORD PTR [rsp+32], r9w
  00006	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000b	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00010	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00015	48 81 ec 18 03
	00 00		 sub	 rsp, 792		; 00000318H
  0001c	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00023	48 33 c4	 xor	 rax, rsp
  00026	48 89 84 24 00
	03 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 2537 : int             rc = 0;                 /* Return code               */

  0002e	c7 84 24 80 00
	00 00 00 00 00
	00		 mov	 DWORD PTR rc$[rsp], 0

; 2538 : int             i;                      /* Array subscript           */
; 2539 : int             xfd;                    /* XMIT file descriptor      */
; 2540 : int             dsstart;                /* Relative track number of
; 2541 :                                            start of output dataset   */
; 2542 : BYTE           *xbuf;                   /* -> Logical record buffer  */
; 2543 : int             xreclen;                /* Logical record length     */
; 2544 : BYTE            xctl;                   /* 0x20=Control record       */
; 2545 : char            xrecname[8];            /* XMIT control record name  */
; 2546 : int             datarecn = 0;           /* Data record counter       */

  00039	c7 84 24 b8 00
	00 00 00 00 00
	00		 mov	 DWORD PTR datarecn$[rsp], 0

; 2547 : int             datafiln = 0;           /* Data file counter         */

  00044	c7 84 24 d8 00
	00 00 00 00 00
	00		 mov	 DWORD PTR datafiln$[rsp], 0

; 2548 : int             copyfiln = 0;           /* Seq num of file to copy   */

  0004f	c7 84 24 e0 00
	00 00 00 00 00
	00		 mov	 DWORD PTR copyfiln$[rsp], 0

; 2549 : BYTE            dsorg=0;                /* Dataset organization      */

  0005a	c6 84 24 84 00
	00 00 00	 mov	 BYTE PTR dsorg$[rsp], 0

; 2550 : BYTE            recfm=0;                /* Dataset record format     */

  00062	c6 84 24 85 00
	00 00 00	 mov	 BYTE PTR recfm$[rsp], 0

; 2551 : U16             lrecl=0;                /* Dataset record length     */

  0006a	33 c0		 xor	 eax, eax
  0006c	66 89 84 24 9c
	00 00 00	 mov	 WORD PTR lrecl$[rsp], ax

; 2552 : U16             blksz=0;                /* Dataset block size        */

  00074	33 c0		 xor	 eax, eax
  00076	66 89 84 24 a0
	00 00 00	 mov	 WORD PTR blksz$[rsp], ax

; 2553 : U16             keyln=0;                /* Dataset key length        */

  0007e	33 c0		 xor	 eax, eax
  00080	66 89 84 24 a4
	00 00 00	 mov	 WORD PTR keyln$[rsp], ax

; 2554 : U16             dirnm;                  /* Number of directory blocks*/
; 2555 : int             enddir = 0;             /* 1=End of directory found  */

  00088	c7 84 24 e4 00
	00 00 00 00 00
	00		 mov	 DWORD PTR enddir$[rsp], 0

; 2556 : BYTE           *blkptr;                 /* -> Data block in record   */
; 2557 : DATABLK        *datablk;                /* -> Data block             */
; 2558 : int             blktrk;                 /* Data block relative track */
; 2559 : int             blkcyl;                 /* Data block cylinder number*/
; 2560 : int             blkhead;                /* Data block head number    */
; 2561 : int             blkrec;                 /* Data block record number  */
; 2562 : int             keylen;                 /* Key length of data block  */
; 2563 : int             datalen;                /* Data length of data block */
; 2564 : int             blklen;                 /* Total length of data block*/
; 2565 : int             origheads = 0;          /* Number of tracks/cylinder

  00093	c7 84 24 f4 00
	00 00 00 00 00
	00		 mov	 DWORD PTR origheads$[rsp], 0

; 2566 :                                            on original dataset       */
; 2567 : int             numext = 0;             /* Number of extents         */

  0009e	c7 84 24 f0 00
	00 00 00 00 00
	00		 mov	 DWORD PTR numext$[rsp], 0

; 2568 : EXTDESC         xarray[16];             /* Extent descriptor array   */
; 2569 : DATABLK       **dirblka;                /* -> Directory block array  */
; 2570 : int             dirblkn = 0;            /* #of directory blocks read */

  000a9	c7 84 24 d4 00
	00 00 00 00 00
	00		 mov	 DWORD PTR dirblkn$[rsp], 0

; 2571 : int             outusedv = 0;           /* Output bytes used on track

  000b4	c7 84 24 18 01
	00 00 00 00 00
	00		 mov	 DWORD PTR outusedv$[rsp], 0

; 2572 :                                            of virtual device         */
; 2573 : int             outusedr = 0;           /* Output bytes used on track

  000bf	c7 84 24 1c 01
	00 00 00 00 00
	00		 mov	 DWORD PTR outusedr$[rsp], 0

; 2574 :                                            of real device            */
; 2575 : int             outtrkbr = 0;           /* Output bytes remaining on

  000ca	c7 84 24 14 01
	00 00 00 00 00
	00		 mov	 DWORD PTR outtrkbr$[rsp], 0

; 2576 :                                            track of real device      */
; 2577 : int             outtrk = 0;             /* Output relative track     */

  000d5	c7 84 24 c8 00
	00 00 00 00 00
	00		 mov	 DWORD PTR outtrk$[rsp], 0

; 2578 : int             outrec = 0;             /* Output record number      */

  000e0	c7 84 24 bc 00
	00 00 00 00 00
	00		 mov	 DWORD PTR outrec$[rsp], 0

; 2579 : TTRCONV        *ttrtab;                 /* -> TTR conversion table   */
; 2580 : int             numttr = 0;             /* TTR table array index     */

  000eb	c7 84 24 94 00
	00 00 00 00 00
	00		 mov	 DWORD PTR numttr$[rsp], 0

; 2581 : COPYR1         *copyr1;                 /* -> header record 1        */
; 2582 : char            pathname[MAX_PATH];     /* xfname in host path format*/
; 2583 : 
; 2584 :     /* Open the input file */
; 2585 :     hostpath(pathname, xfname, sizeof(pathname));

  000f6	41 b8 04 01 00
	00		 mov	 r8d, 260		; 00000104H
  000fc	48 8b 94 24 20
	03 00 00	 mov	 rdx, QWORD PTR xfname$[rsp]
  00104	48 8d 8c 24 f0
	01 00 00	 lea	 rcx, QWORD PTR pathname$[rsp]
  0010c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hostpath

; 2586 :     xfd = HOPEN (pathname, O_RDONLY|O_BINARY);

  00112	ba 00 80 00 00	 mov	 edx, 32768		; 00008000H
  00117	48 8d 8c 24 f0
	01 00 00	 lea	 rcx, QWORD PTR pathname$[rsp]
  0011f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_hopen
  00125	89 84 24 ac 00
	00 00		 mov	 DWORD PTR xfd$[rsp], eax

; 2587 :     if (xfd < 0)

  0012c	83 bc 24 ac 00
	00 00 00	 cmp	 DWORD PTR xfd$[rsp], 0
  00134	7d 3f		 jge	 SHORT $LN12@process_ie

; 2588 :     {
; 2589 :         XMERRF ( MSG( HHC02468, "E", xfname, "open()", strerror( errno ) ) );

  00136	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno
  0013c	8b 08		 mov	 ecx, DWORD PTR [rax]
  0013e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_strerror
  00144	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00149	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG161868
  00150	4c 8b 84 24 20
	03 00 00	 mov	 r8, QWORD PTR xfname$[rsp]
  00158	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG161869
  0015f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG161870
  00166	e8 00 00 00 00	 call	 printf

; 2590 :         return -1;

  0016b	b8 ff ff ff ff	 mov	 eax, -1
  00170	e9 b0 0f 00 00	 jmp	 $LN1@process_ie
$LN12@process_ie:

; 2591 :     }
; 2592 : 
; 2593 :     /* Obtain the input logical record buffer */
; 2594 :     xbuf = malloc (65536);

  00175	b9 00 00 01 00	 mov	 ecx, 65536		; 00010000H
  0017a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_malloc
  00180	48 89 84 24 b0
	00 00 00	 mov	 QWORD PTR xbuf$[rsp], rax

; 2595 :     if (xbuf == NULL)

  00188	48 83 bc 24 b0
	00 00 00 00	 cmp	 QWORD PTR xbuf$[rsp], 0
  00191	75 4b		 jne	 SHORT $LN13@process_ie

; 2596 :     {
; 2597 :         XMERRF ( MSG( HHC02544, "E", "input buffer", "malloc()", strerror(errno) ) );

  00193	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno
  00199	8b 08		 mov	 ecx, DWORD PTR [rax]
  0019b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_strerror
  001a1	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  001a6	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG161872
  001ad	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG161873
  001b4	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG161874
  001bb	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG161875
  001c2	e8 00 00 00 00	 call	 printf

; 2598 :         close (xfd);

  001c7	8b 8c 24 ac 00
	00 00		 mov	 ecx, DWORD PTR xfd$[rsp]
  001ce	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_close

; 2599 :         return -1;

  001d4	b8 ff ff ff ff	 mov	 eax, -1
  001d9	e9 47 0f 00 00	 jmp	 $LN1@process_ie
$LN13@process_ie:

; 2600 :     }
; 2601 : 
; 2602 :     /* Obtain storage for the directory block array */
; 2603 :     dirblka = (DATABLK**)malloc (sizeof(DATABLK*) * MAXDBLK);

  001de	b9 80 38 01 00	 mov	 ecx, 80000		; 00013880H
  001e3	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_malloc
  001e9	48 89 84 24 08
	01 00 00	 mov	 QWORD PTR dirblka$[rsp], rax

; 2604 :     if (dirblka == NULL)

  001f1	48 83 bc 24 08
	01 00 00 00	 cmp	 QWORD PTR dirblka$[rsp], 0
  001fa	75 59		 jne	 SHORT $LN14@process_ie

; 2605 :     {
; 2606 :         XMERRF ( MSG( HHC02544, "E", "directory block array", "malloc()", strerror(errno) ) );

  001fc	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno
  00202	8b 08		 mov	 ecx, DWORD PTR [rax]
  00204	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_strerror
  0020a	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  0020f	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG161877
  00216	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG161878
  0021d	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG161879
  00224	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG161880
  0022b	e8 00 00 00 00	 call	 printf

; 2607 :         free (xbuf);

  00230	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR xbuf$[rsp]
  00238	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free

; 2608 :         close (xfd);

  0023e	8b 8c 24 ac 00
	00 00		 mov	 ecx, DWORD PTR xfd$[rsp]
  00245	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_close

; 2609 :         return -1;

  0024b	b8 ff ff ff ff	 mov	 eax, -1
  00250	e9 d0 0e 00 00	 jmp	 $LN1@process_ie
$LN14@process_ie:

; 2610 :     }
; 2611 : 
; 2612 :     /* Obtain storage for the TTR conversion table */
; 2613 :     ttrtab = (TTRCONV*)malloc (sizeof(TTRCONV) * MAXTTR);

  00255	b9 e0 93 04 00	 mov	 ecx, 300000		; 000493e0H
  0025a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_malloc
  00260	48 89 84 24 e8
	00 00 00	 mov	 QWORD PTR ttrtab$[rsp], rax

; 2614 :     if (ttrtab == NULL)

  00268	48 83 bc 24 e8
	00 00 00 00	 cmp	 QWORD PTR ttrtab$[rsp], 0
  00271	75 67		 jne	 SHORT $LN15@process_ie

; 2615 :     {
; 2616 :         XMERRF ( MSG( HHC02544, "E", "TTR table", "malloc()", strerror(errno) ) );

  00273	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno
  00279	8b 08		 mov	 ecx, DWORD PTR [rax]
  0027b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_strerror
  00281	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00286	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG161882
  0028d	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG161883
  00294	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG161884
  0029b	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG161885
  002a2	e8 00 00 00 00	 call	 printf

; 2617 :         free (xbuf);

  002a7	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR xbuf$[rsp]
  002af	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free

; 2618 :         free (dirblka);

  002b5	48 8b 8c 24 08
	01 00 00	 mov	 rcx, QWORD PTR dirblka$[rsp]
  002bd	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free

; 2619 :         close (xfd);

  002c3	8b 8c 24 ac 00
	00 00		 mov	 ecx, DWORD PTR xfd$[rsp]
  002ca	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_close

; 2620 :         return -1;

  002d0	b8 ff ff ff ff	 mov	 eax, -1
  002d5	e9 4b 0e 00 00	 jmp	 $LN1@process_ie
$LN15@process_ie:

; 2621 :     }
; 2622 : 
; 2623 :     /* Calculate the relative track number of the dataset */
; 2624 :     dsstart = (outcyl * heads) + outhead;

  002da	8b 84 24 50 03
	00 00		 mov	 eax, DWORD PTR outcyl$[rsp]
  002e1	0f af 84 24 40
	03 00 00	 imul	 eax, DWORD PTR heads$[rsp]
  002e9	03 84 24 58 03
	00 00		 add	 eax, DWORD PTR outhead$[rsp]
  002f0	89 84 24 24 01
	00 00		 mov	 DWORD PTR dsstart$[rsp], eax

; 2625 : 
; 2626 :     /* Display the file information message */
; 2627 :     XMINFF (1, MSG( HHC02560, "I", xfname ) );

  002f7	4c 8b 8c 24 20
	03 00 00	 mov	 r9, QWORD PTR xfname$[rsp]
  002ff	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG161886
  00306	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG161887
  0030d	b9 01 00 00 00	 mov	 ecx, 1
  00312	e8 00 00 00 00	 call	 info_msg
$LN54@process_ie:
$LN53@process_ie:
$LN52@process_ie:
$LN51@process_ie:
$LN2@process_ie:

; 2628 : 
; 2629 :     /* Read each logical record */
; 2630 :     while (1)

  00317	33 c0		 xor	 eax, eax
  00319	83 f8 01	 cmp	 eax, 1
  0031c	0f 84 1a 0a 00
	00		 je	 $LN3@process_ie

; 2631 :     {
; 2632 :         xctl=0;

  00322	c6 84 24 86 00
	00 00 00	 mov	 BYTE PTR xctl$[rsp], 0

; 2633 :         if (method == METHOD_XMIT)

  0032a	0f b6 84 24 68
	03 00 00	 movzx	 eax, BYTE PTR method$[rsp]
  00332	83 f8 01	 cmp	 eax, 1
  00335	75 2d		 jne	 SHORT $LN16@process_ie

; 2634 :            rc = read_xmit_rec (xfd, xfname, xbuf, &xctl);

  00337	4c 8d 8c 24 86
	00 00 00	 lea	 r9, QWORD PTR xctl$[rsp]
  0033f	4c 8b 84 24 b0
	00 00 00	 mov	 r8, QWORD PTR xbuf$[rsp]
  00347	48 8b 94 24 20
	03 00 00	 mov	 rdx, QWORD PTR xfname$[rsp]
  0034f	8b 8c 24 ac 00
	00 00		 mov	 ecx, DWORD PTR xfd$[rsp]
  00356	e8 00 00 00 00	 call	 read_xmit_rec
  0035b	89 84 24 80 00
	00 00		 mov	 DWORD PTR rc$[rsp], eax
  00362	eb 54		 jmp	 SHORT $LN17@process_ie
$LN16@process_ie:

; 2635 :         else if (method == METHOD_VS) {

  00364	0f b6 84 24 68
	03 00 00	 movzx	 eax, BYTE PTR method$[rsp]
  0036c	83 f8 05	 cmp	 eax, 5
  0036f	75 3c		 jne	 SHORT $LN18@process_ie

; 2636 :            rc = read_vs_rec (xfd, xfname, xbuf, datarecn);

  00371	44 8b 8c 24 b8
	00 00 00	 mov	 r9d, DWORD PTR datarecn$[rsp]
  00379	4c 8b 84 24 b0
	00 00 00	 mov	 r8, QWORD PTR xbuf$[rsp]
  00381	48 8b 94 24 20
	03 00 00	 mov	 rdx, QWORD PTR xfname$[rsp]
  00389	8b 8c 24 ac 00
	00 00		 mov	 ecx, DWORD PTR xfd$[rsp]
  00390	e8 00 00 00 00	 call	 read_vs_rec
  00395	89 84 24 80 00
	00 00		 mov	 DWORD PTR rc$[rsp], eax

; 2637 :            if (rc == 0)                 /* end-of-file */

  0039c	83 bc 24 80 00
	00 00 00	 cmp	 DWORD PTR rc$[rsp], 0
  003a4	75 05		 jne	 SHORT $LN20@process_ie

; 2638 :               break;

  003a6	e9 91 09 00 00	 jmp	 $LN3@process_ie
$LN20@process_ie:

; 2639 :         } else

  003ab	eb 0b		 jmp	 SHORT $LN19@process_ie
$LN18@process_ie:

; 2640 :            rc = -1;

  003ad	c7 84 24 80 00
	00 00 ff ff ff
	ff		 mov	 DWORD PTR rc$[rsp], -1
$LN19@process_ie:
$LN17@process_ie:

; 2641 :         if (rc < 0) return -1;

  003b8	83 bc 24 80 00
	00 00 00	 cmp	 DWORD PTR rc$[rsp], 0
  003c0	7d 0a		 jge	 SHORT $LN21@process_ie
  003c2	b8 ff ff ff ff	 mov	 eax, -1
  003c7	e9 59 0d 00 00	 jmp	 $LN1@process_ie
$LN21@process_ie:

; 2642 :         xreclen = rc;

  003cc	8b 84 24 80 00
	00 00		 mov	 eax, DWORD PTR rc$[rsp]
  003d3	89 84 24 90 00
	00 00		 mov	 DWORD PTR xreclen$[rsp], eax

; 2643 : 
; 2644 :         /* Process control records */
; 2645 :         if (method == METHOD_XMIT && xctl)

  003da	0f b6 84 24 68
	03 00 00	 movzx	 eax, BYTE PTR method$[rsp]
  003e2	83 f8 01	 cmp	 eax, 1
  003e5	0f 85 db 01 00
	00		 jne	 $LN22@process_ie
  003eb	0f b6 84 24 86
	00 00 00	 movzx	 eax, BYTE PTR xctl$[rsp]
  003f3	85 c0		 test	 eax, eax
  003f5	0f 84 cb 01 00
	00		 je	 $LN22@process_ie

; 2646 :         {
; 2647 :             /* Extract the control record name */
; 2648 :             make_asciiz (xrecname, sizeof(xrecname), xbuf, 6);

  003fb	41 b9 06 00 00
	00		 mov	 r9d, 6
  00401	4c 8b 84 24 b0
	00 00 00	 mov	 r8, QWORD PTR xbuf$[rsp]
  00409	ba 08 00 00 00	 mov	 edx, 8
  0040e	48 8d 8c 24 e0
	01 00 00	 lea	 rcx, QWORD PTR xrecname$[rsp]
  00416	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_make_asciiz

; 2649 :             XMINFF (4, MSG( HHC02561, "I", xrecname, xreclen ) );

  0041c	8b 84 24 90 00
	00 00		 mov	 eax, DWORD PTR xreclen$[rsp]
  00423	89 44 24 20	 mov	 DWORD PTR [rsp+32], eax
  00427	4c 8d 8c 24 e0
	01 00 00	 lea	 r9, QWORD PTR xrecname$[rsp]
  0042f	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG161895
  00436	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG161896
  0043d	b9 04 00 00 00	 mov	 ecx, 4
  00442	e8 00 00 00 00	 call	 info_msg

; 2650 : 
; 2651 :             /* Exit if control record is a trailer record */
; 2652 :             if (strcmp(xrecname, "INMR06") == 0)

  00447	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG161898
  0044e	48 8d 8c 24 e0
	01 00 00	 lea	 rcx, QWORD PTR xrecname$[rsp]
  00456	e8 00 00 00 00	 call	 strcmp
  0045b	85 c0		 test	 eax, eax
  0045d	75 05		 jne	 SHORT $LN23@process_ie

; 2653 :                 break;

  0045f	e9 d8 08 00 00	 jmp	 $LN3@process_ie
$LN23@process_ie:

; 2654 : 
; 2655 :             /* Process control record according to type */
; 2656 :             if (strcmp(xrecname, "INMR02") == 0)

  00464	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG161901
  0046b	48 8d 8c 24 e0
	01 00 00	 lea	 rcx, QWORD PTR xrecname$[rsp]
  00473	e8 00 00 00 00	 call	 strcmp
  00478	85 c0		 test	 eax, eax
  0047a	0f 85 82 00 00
	00		 jne	 $LN24@process_ie

; 2657 :             {
; 2658 :                 rc = process_inmr02 (xbuf, xreclen, &copyfiln,

  00480	48 8d 84 24 20
	01 00 00	 lea	 rax, QWORD PTR dirnm$[rsp]
  00488	48 89 44 24 40	 mov	 QWORD PTR [rsp+64], rax
  0048d	48 8d 84 24 a4
	00 00 00	 lea	 rax, QWORD PTR keyln$[rsp]
  00495	48 89 44 24 38	 mov	 QWORD PTR [rsp+56], rax
  0049a	48 8d 84 24 a0
	00 00 00	 lea	 rax, QWORD PTR blksz$[rsp]
  004a2	48 89 44 24 30	 mov	 QWORD PTR [rsp+48], rax
  004a7	48 8d 84 24 9c
	00 00 00	 lea	 rax, QWORD PTR lrecl$[rsp]
  004af	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  004b4	48 8d 84 24 85
	00 00 00	 lea	 rax, QWORD PTR recfm$[rsp]
  004bc	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  004c1	4c 8d 8c 24 84
	00 00 00	 lea	 r9, QWORD PTR dsorg$[rsp]
  004c9	4c 8d 84 24 e0
	00 00 00	 lea	 r8, QWORD PTR copyfiln$[rsp]
  004d1	8b 94 24 90 00
	00 00		 mov	 edx, DWORD PTR xreclen$[rsp]
  004d8	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR xbuf$[rsp]
  004e0	e8 00 00 00 00	 call	 process_inmr02
  004e5	89 84 24 80 00
	00 00		 mov	 DWORD PTR rc$[rsp], eax

; 2659 :                                      &dsorg, &recfm, &lrecl, &blksz,
; 2660 :                                      &keyln, &dirnm);
; 2661 :                 if (rc < 0) return -1;

  004ec	83 bc 24 80 00
	00 00 00	 cmp	 DWORD PTR rc$[rsp], 0
  004f4	7d 0a		 jge	 SHORT $LN26@process_ie
  004f6	b8 ff ff ff ff	 mov	 eax, -1
  004fb	e9 25 0c 00 00	 jmp	 $LN1@process_ie
$LN26@process_ie:

; 2662 :             }

  00500	eb 2f		 jmp	 SHORT $LN25@process_ie
$LN24@process_ie:

; 2663 :             else
; 2664 :             {
; 2665 :                 rc = process_inmrxx (xbuf, xreclen);

  00502	8b 94 24 90 00
	00 00		 mov	 edx, DWORD PTR xreclen$[rsp]
  00509	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR xbuf$[rsp]
  00511	e8 00 00 00 00	 call	 process_inmrxx
  00516	89 84 24 80 00
	00 00		 mov	 DWORD PTR rc$[rsp], eax

; 2666 :                 if (rc < 0) return -1;

  0051d	83 bc 24 80 00
	00 00 00	 cmp	 DWORD PTR rc$[rsp], 0
  00525	7d 0a		 jge	 SHORT $LN27@process_ie
  00527	b8 ff ff ff ff	 mov	 eax, -1
  0052c	e9 f4 0b 00 00	 jmp	 $LN1@process_ie
$LN27@process_ie:
$LN25@process_ie:

; 2667 :             }
; 2668 : 
; 2669 :             /* Reset the data counter if data control record */
; 2670 :             if (strcmp(xrecname, "INMR03") == 0)

  00531	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG161905
  00538	48 8d 8c 24 e0
	01 00 00	 lea	 rcx, QWORD PTR xrecname$[rsp]
  00540	e8 00 00 00 00	 call	 strcmp
  00545	85 c0		 test	 eax, eax
  00547	75 78		 jne	 SHORT $LN28@process_ie

; 2671 :             {
; 2672 :                 datafiln++;

  00549	8b 84 24 d8 00
	00 00		 mov	 eax, DWORD PTR datafiln$[rsp]
  00550	ff c0		 inc	 eax
  00552	89 84 24 d8 00
	00 00		 mov	 DWORD PTR datafiln$[rsp], eax

; 2673 :                 datarecn = 0;

  00559	c7 84 24 b8 00
	00 00 00 00 00
	00		 mov	 DWORD PTR datarecn$[rsp], 0

; 2674 :                 XMINFF (4, MSG( HHC02562, "I", datafiln, datafiln == copyfiln ? "(selected)" : "(not selected)" ) );

  00564	8b 84 24 e0 00
	00 00		 mov	 eax, DWORD PTR copyfiln$[rsp]
  0056b	39 84 24 d8 00
	00 00		 cmp	 DWORD PTR datafiln$[rsp], eax
  00572	75 11		 jne	 SHORT $LN47@process_ie
  00574	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG161906
  0057b	48 89 84 24 30
	01 00 00	 mov	 QWORD PTR tv256[rsp], rax
  00583	eb 0f		 jmp	 SHORT $LN48@process_ie
$LN47@process_ie:
  00585	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG161907
  0058c	48 89 84 24 30
	01 00 00	 mov	 QWORD PTR tv256[rsp], rax
$LN48@process_ie:
  00594	48 8b 84 24 30
	01 00 00	 mov	 rax, QWORD PTR tv256[rsp]
  0059c	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  005a1	44 8b 8c 24 d8
	00 00 00	 mov	 r9d, DWORD PTR datafiln$[rsp]
  005a9	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG161908
  005b0	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG161909
  005b7	b9 04 00 00 00	 mov	 ecx, 4
  005bc	e8 00 00 00 00	 call	 info_msg
$LN28@process_ie:

; 2675 :             }
; 2676 : 
; 2677 :             /* Loop to get next record */
; 2678 :             continue;

  005c1	e9 51 fd ff ff	 jmp	 $LN2@process_ie
$LN22@process_ie:

; 2679 : 
; 2680 :         } /* end if(xctl) */
; 2681 : 
; 2682 :         /* Process data records */
; 2683 :         datarecn++;

  005c6	8b 84 24 b8 00
	00 00		 mov	 eax, DWORD PTR datarecn$[rsp]
  005cd	ff c0		 inc	 eax
  005cf	89 84 24 b8 00
	00 00		 mov	 DWORD PTR datarecn$[rsp], eax

; 2684 :         XMINFF (4, MSG( HHC02563, "I", xreclen ) );

  005d6	44 8b 8c 24 90
	00 00 00	 mov	 r9d, DWORD PTR xreclen$[rsp]
  005de	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG161910
  005e5	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG161911
  005ec	b9 04 00 00 00	 mov	 ecx, 4
  005f1	e8 00 00 00 00	 call	 info_msg

; 2685 :         if (infolvl >= 5) data_dump (xbuf, xreclen);

  005f6	83 3d 00 00 00
	00 05		 cmp	 DWORD PTR infolvl, 5
  005fd	7c 15		 jl	 SHORT $LN29@process_ie
  005ff	8b 94 24 90 00
	00 00		 mov	 edx, DWORD PTR xreclen$[rsp]
  00606	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR xbuf$[rsp]
  0060e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_data_dump
$LN29@process_ie:

; 2686 : 
; 2687 :         /* If this is not the IEBCOPY file then ignore data record */
; 2688 :         if (method == METHOD_XMIT && datafiln != copyfiln)

  00614	0f b6 84 24 68
	03 00 00	 movzx	 eax, BYTE PTR method$[rsp]
  0061c	83 f8 01	 cmp	 eax, 1
  0061f	75 15		 jne	 SHORT $LN30@process_ie
  00621	8b 84 24 e0 00
	00 00		 mov	 eax, DWORD PTR copyfiln$[rsp]
  00628	39 84 24 d8 00
	00 00		 cmp	 DWORD PTR datafiln$[rsp], eax
  0062f	74 05		 je	 SHORT $LN30@process_ie

; 2689 :         {
; 2690 :             continue;

  00631	e9 e1 fc ff ff	 jmp	 $LN51@process_ie
$LN30@process_ie:

; 2691 :         }
; 2692 : 
; 2693 :         /* Process IEBCOPY header record 1 */
; 2694 :         if (datarecn == 1)

  00636	83 bc 24 b8 00
	00 00 01	 cmp	 DWORD PTR datarecn$[rsp], 1
  0063e	0f 85 0c 01 00
	00		 jne	 $LN31@process_ie

; 2695 :         {
; 2696 :             origheads = process_copyr1 (xbuf, xreclen);

  00644	8b 94 24 90 00
	00 00		 mov	 edx, DWORD PTR xreclen$[rsp]
  0064b	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR xbuf$[rsp]
  00653	e8 00 00 00 00	 call	 process_copyr1
  00658	89 84 24 f4 00
	00 00		 mov	 DWORD PTR origheads$[rsp], eax

; 2697 :             if (origheads < 0) exit(1);

  0065f	83 bc 24 f4 00
	00 00 00	 cmp	 DWORD PTR origheads$[rsp], 0
  00667	7d 0b		 jge	 SHORT $LN32@process_ie
  00669	b9 01 00 00 00	 mov	 ecx, 1
  0066e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_exit
$LN32@process_ie:

; 2698 :             if (method == METHOD_VS) {

  00674	0f b6 84 24 68
	03 00 00	 movzx	 eax, BYTE PTR method$[rsp]
  0067c	83 f8 05	 cmp	 eax, 5
  0067f	0f 85 c6 00 00
	00		 jne	 $LN33@process_ie

; 2699 :                copyr1 = (COPYR1 *)xbuf;

  00685	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR xbuf$[rsp]
  0068d	48 89 84 24 00
	01 00 00	 mov	 QWORD PTR copyr1$[rsp], rax

; 2700 :                dsorg = copyr1->ds1dsorg[0];

  00695	b8 01 00 00 00	 mov	 eax, 1
  0069a	48 6b c0 00	 imul	 rax, rax, 0
  0069e	48 8b 8c 24 00
	01 00 00	 mov	 rcx, QWORD PTR copyr1$[rsp]
  006a6	0f b6 44 01 04	 movzx	 eax, BYTE PTR [rcx+rax+4]
  006ab	88 84 24 84 00
	00 00		 mov	 BYTE PTR dsorg$[rsp], al

; 2701 :                recfm = copyr1->ds1recfm;

  006b2	48 8b 84 24 00
	01 00 00	 mov	 rax, QWORD PTR copyr1$[rsp]
  006ba	0f b6 40 0a	 movzx	 eax, BYTE PTR [rax+10]
  006be	88 84 24 85 00
	00 00		 mov	 BYTE PTR recfm$[rsp], al

; 2702 :                lrecl = (copyr1->ds1lrecl[0] << 8) | copyr1->ds1lrecl[1];

  006c5	b8 01 00 00 00	 mov	 eax, 1
  006ca	48 6b c0 00	 imul	 rax, rax, 0
  006ce	48 8b 8c 24 00
	01 00 00	 mov	 rcx, QWORD PTR copyr1$[rsp]
  006d6	0f b6 44 01 08	 movzx	 eax, BYTE PTR [rcx+rax+8]
  006db	c1 e0 08	 shl	 eax, 8
  006de	b9 01 00 00 00	 mov	 ecx, 1
  006e3	48 6b c9 01	 imul	 rcx, rcx, 1
  006e7	48 8b 94 24 00
	01 00 00	 mov	 rdx, QWORD PTR copyr1$[rsp]
  006ef	0f b6 4c 0a 08	 movzx	 ecx, BYTE PTR [rdx+rcx+8]
  006f4	0b c1		 or	 eax, ecx
  006f6	66 89 84 24 9c
	00 00 00	 mov	 WORD PTR lrecl$[rsp], ax

; 2703 :                blksz = (copyr1->ds1blkl[0] << 8) | copyr1->ds1blkl[1];

  006fe	b8 01 00 00 00	 mov	 eax, 1
  00703	48 6b c0 00	 imul	 rax, rax, 0
  00707	48 8b 8c 24 00
	01 00 00	 mov	 rcx, QWORD PTR copyr1$[rsp]
  0070f	0f b6 44 01 06	 movzx	 eax, BYTE PTR [rcx+rax+6]
  00714	c1 e0 08	 shl	 eax, 8
  00717	b9 01 00 00 00	 mov	 ecx, 1
  0071c	48 6b c9 01	 imul	 rcx, rcx, 1
  00720	48 8b 94 24 00
	01 00 00	 mov	 rdx, QWORD PTR copyr1$[rsp]
  00728	0f b6 4c 0a 06	 movzx	 ecx, BYTE PTR [rdx+rcx+6]
  0072d	0b c1		 or	 eax, ecx
  0072f	66 89 84 24 a0
	00 00 00	 mov	 WORD PTR blksz$[rsp], ax

; 2704 :                keyln = copyr1->ds1keyl;

  00737	48 8b 84 24 00
	01 00 00	 mov	 rax, QWORD PTR copyr1$[rsp]
  0073f	0f b6 40 0b	 movzx	 eax, BYTE PTR [rax+11]
  00743	66 89 84 24 a4
	00 00 00	 mov	 WORD PTR keyln$[rsp], ax
$LN33@process_ie:

; 2705 :             }
; 2706 :             continue;

  0074b	e9 c7 fb ff ff	 jmp	 $LN52@process_ie
$LN31@process_ie:

; 2707 :         }
; 2708 : 
; 2709 :         /* Process IEBCOPY header record 2 */
; 2710 :         if (datarecn == 2)

  00750	83 bc 24 b8 00
	00 00 02	 cmp	 DWORD PTR datarecn$[rsp], 2
  00758	75 3d		 jne	 SHORT $LN34@process_ie

; 2711 :         {
; 2712 :             numext = process_copyr2 (xbuf, xreclen, xarray);

  0075a	4c 8d 84 24 40
	01 00 00	 lea	 r8, QWORD PTR xarray$[rsp]
  00762	8b 94 24 90 00
	00 00		 mov	 edx, DWORD PTR xreclen$[rsp]
  00769	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR xbuf$[rsp]
  00771	e8 00 00 00 00	 call	 process_copyr2
  00776	89 84 24 f0 00
	00 00		 mov	 DWORD PTR numext$[rsp], eax

; 2713 :             if (numext < 0) exit(1);

  0077d	83 bc 24 f0 00
	00 00 00	 cmp	 DWORD PTR numext$[rsp], 0
  00785	7d 0b		 jge	 SHORT $LN35@process_ie
  00787	b9 01 00 00 00	 mov	 ecx, 1
  0078c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_exit
$LN35@process_ie:

; 2714 :             continue;

  00792	e9 80 fb ff ff	 jmp	 $LN53@process_ie
$LN34@process_ie:

; 2715 :         }
; 2716 : 
; 2717 :         /* Process each data block in data record */
; 2718 :         blkptr = xbuf;

  00797	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR xbuf$[rsp]
  0079f	48 89 84 24 28
	01 00 00	 mov	 QWORD PTR blkptr$[rsp], rax
$LN4@process_ie:

; 2719 :         while (xreclen > 0)

  007a7	83 bc 24 90 00
	00 00 00	 cmp	 DWORD PTR xreclen$[rsp], 0
  007af	0f 8e 82 05 00
	00		 jle	 $LN5@process_ie

; 2720 :         {
; 2721 :             /* Compute the length of the block */
; 2722 :             datablk = (DATABLK*)blkptr;

  007b5	48 8b 84 24 28
	01 00 00	 mov	 rax, QWORD PTR blkptr$[rsp]
  007bd	48 89 84 24 88
	00 00 00	 mov	 QWORD PTR datablk$[rsp], rax

; 2723 :             blkcyl = (datablk->cyl[0] << 8)

  007c5	b8 01 00 00 00	 mov	 eax, 1
  007ca	48 6b c0 00	 imul	 rax, rax, 0
  007ce	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR datablk$[rsp]
  007d6	0f b6 44 01 04	 movzx	 eax, BYTE PTR [rcx+rax+4]
  007db	c1 e0 08	 shl	 eax, 8
  007de	b9 01 00 00 00	 mov	 ecx, 1
  007e3	48 6b c9 01	 imul	 rcx, rcx, 1
  007e7	48 8b 94 24 88
	00 00 00	 mov	 rdx, QWORD PTR datablk$[rsp]
  007ef	0f b6 4c 0a 04	 movzx	 ecx, BYTE PTR [rdx+rcx+4]
  007f4	0b c1		 or	 eax, ecx
  007f6	89 84 24 d0 00
	00 00		 mov	 DWORD PTR blkcyl$[rsp], eax

; 2724 :                     | datablk->cyl[1];
; 2725 :             blkhead = (datablk->head[0] << 8)

  007fd	b8 01 00 00 00	 mov	 eax, 1
  00802	48 6b c0 00	 imul	 rax, rax, 0
  00806	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR datablk$[rsp]
  0080e	0f b6 44 01 06	 movzx	 eax, BYTE PTR [rcx+rax+6]
  00813	c1 e0 08	 shl	 eax, 8
  00816	b9 01 00 00 00	 mov	 ecx, 1
  0081b	48 6b c9 01	 imul	 rcx, rcx, 1
  0081f	48 8b 94 24 88
	00 00 00	 mov	 rdx, QWORD PTR datablk$[rsp]
  00827	0f b6 4c 0a 06	 movzx	 ecx, BYTE PTR [rdx+rcx+6]
  0082c	0b c1		 or	 eax, ecx
  0082e	89 84 24 cc 00
	00 00		 mov	 DWORD PTR blkhead$[rsp], eax

; 2726 :                     | datablk->head[1];
; 2727 :             blkrec = datablk->rec;

  00835	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR datablk$[rsp]
  0083d	0f b6 40 08	 movzx	 eax, BYTE PTR [rax+8]
  00841	89 84 24 a8 00
	00 00		 mov	 DWORD PTR blkrec$[rsp], eax

; 2728 :             keylen = datablk->klen;

  00848	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR datablk$[rsp]
  00850	0f b6 40 09	 movzx	 eax, BYTE PTR [rax+9]
  00854	89 84 24 c4 00
	00 00		 mov	 DWORD PTR keylen$[rsp], eax

; 2729 :             datalen = (datablk->dlen[0] << 8)

  0085b	b8 01 00 00 00	 mov	 eax, 1
  00860	48 6b c0 00	 imul	 rax, rax, 0
  00864	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR datablk$[rsp]
  0086c	0f b6 44 01 0a	 movzx	 eax, BYTE PTR [rcx+rax+10]
  00871	c1 e0 08	 shl	 eax, 8
  00874	b9 01 00 00 00	 mov	 ecx, 1
  00879	48 6b c9 01	 imul	 rcx, rcx, 1
  0087d	48 8b 94 24 88
	00 00 00	 mov	 rdx, QWORD PTR datablk$[rsp]
  00885	0f b6 4c 0a 0a	 movzx	 ecx, BYTE PTR [rdx+rcx+10]
  0088a	0b c1		 or	 eax, ecx
  0088c	89 84 24 c0 00
	00 00		 mov	 DWORD PTR datalen$[rsp], eax

; 2730 :                     | datablk->dlen[1];
; 2731 :             blklen = 12 + keylen + datalen;

  00893	8b 84 24 c4 00
	00 00		 mov	 eax, DWORD PTR keylen$[rsp]
  0089a	8b 8c 24 c0 00
	00 00		 mov	 ecx, DWORD PTR datalen$[rsp]
  008a1	8d 44 08 0c	 lea	 eax, DWORD PTR [rax+rcx+12]
  008a5	89 84 24 f8 00
	00 00		 mov	 DWORD PTR blklen$[rsp], eax

; 2732 : 
; 2733 :             /* Calculate the TTR in the original dataset */
; 2734 :             blktrk = (enddir == 0) ? 0 :

  008ac	83 bc 24 e4 00
	00 00 00	 cmp	 DWORD PTR enddir$[rsp], 0
  008b4	75 0d		 jne	 SHORT $LN49@process_ie
  008b6	c7 84 24 10 01
	00 00 00 00 00
	00		 mov	 DWORD PTR tv360[rsp], 0
  008c1	eb 37		 jmp	 SHORT $LN50@process_ie
$LN49@process_ie:
  008c3	48 8d 84 24 40
	01 00 00	 lea	 rax, QWORD PTR xarray$[rsp]
  008cb	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  008d0	44 8b 8c 24 f0
	00 00 00	 mov	 r9d, DWORD PTR numext$[rsp]
  008d8	44 8b 84 24 f4
	00 00 00	 mov	 r8d, DWORD PTR origheads$[rsp]
  008e0	8b 94 24 cc 00
	00 00		 mov	 edx, DWORD PTR blkhead$[rsp]
  008e7	8b 8c 24 d0 00
	00 00		 mov	 ecx, DWORD PTR blkcyl$[rsp]
  008ee	e8 00 00 00 00	 call	 calculate_ttr
  008f3	89 84 24 10 01
	00 00		 mov	 DWORD PTR tv360[rsp], eax
$LN50@process_ie:
  008fa	8b 84 24 10 01
	00 00		 mov	 eax, DWORD PTR tv360[rsp]
  00901	89 84 24 dc 00
	00 00		 mov	 DWORD PTR blktrk$[rsp], eax

; 2735 :                         calculate_ttr (blkcyl, blkhead,
; 2736 :                                 origheads, numext, xarray);
; 2737 : 
; 2738 :             /* Write the data block to the output file */
; 2739 :             rc = write_block (cif, ofname, datablk, keylen, datalen,

  00908	48 8d 84 24 bc
	00 00 00	 lea	 rax, QWORD PTR outrec$[rsp]
  00910	48 89 44 24 78	 mov	 QWORD PTR [rsp+120], rax
  00915	48 8d 84 24 58
	03 00 00	 lea	 rax, QWORD PTR outhead$[rsp]
  0091d	48 89 44 24 70	 mov	 QWORD PTR [rsp+112], rax
  00922	48 8d 84 24 50
	03 00 00	 lea	 rax, QWORD PTR outcyl$[rsp]
  0092a	48 89 44 24 68	 mov	 QWORD PTR [rsp+104], rax
  0092f	48 8d 84 24 c8
	00 00 00	 lea	 rax, QWORD PTR outtrk$[rsp]
  00937	48 89 44 24 60	 mov	 QWORD PTR [rsp+96], rax
  0093c	48 8d 84 24 14
	01 00 00	 lea	 rax, QWORD PTR outtrkbr$[rsp]
  00944	48 89 44 24 58	 mov	 QWORD PTR [rsp+88], rax
  00949	48 8d 84 24 1c
	01 00 00	 lea	 rax, QWORD PTR outusedr$[rsp]
  00951	48 89 44 24 50	 mov	 QWORD PTR [rsp+80], rax
  00956	48 8d 84 24 18
	01 00 00	 lea	 rax, QWORD PTR outusedv$[rsp]
  0095e	48 89 44 24 48	 mov	 QWORD PTR [rsp+72], rax
  00963	8b 84 24 60 03
	00 00		 mov	 eax, DWORD PTR maxtrks$[rsp]
  0096a	89 44 24 40	 mov	 DWORD PTR [rsp+64], eax
  0096e	8b 84 24 48 03
	00 00		 mov	 eax, DWORD PTR trklen$[rsp]
  00975	89 44 24 38	 mov	 DWORD PTR [rsp+56], eax
  00979	8b 84 24 40 03
	00 00		 mov	 eax, DWORD PTR heads$[rsp]
  00980	89 44 24 30	 mov	 DWORD PTR [rsp+48], eax
  00984	0f b7 84 24 38
	03 00 00	 movzx	 eax, WORD PTR devtype$[rsp]
  0098c	66 89 44 24 28	 mov	 WORD PTR [rsp+40], ax
  00991	8b 84 24 c0 00
	00 00		 mov	 eax, DWORD PTR datalen$[rsp]
  00998	89 44 24 20	 mov	 DWORD PTR [rsp+32], eax
  0099c	44 8b 8c 24 c4
	00 00 00	 mov	 r9d, DWORD PTR keylen$[rsp]
  009a4	4c 8b 84 24 88
	00 00 00	 mov	 r8, QWORD PTR datablk$[rsp]
  009ac	48 8b 94 24 28
	03 00 00	 mov	 rdx, QWORD PTR ofname$[rsp]
  009b4	48 8b 8c 24 30
	03 00 00	 mov	 rcx, QWORD PTR cif$[rsp]
  009bc	e8 00 00 00 00	 call	 write_block
  009c1	89 84 24 80 00
	00 00		 mov	 DWORD PTR rc$[rsp], eax

; 2740 :                         devtype, heads, trklen, maxtrks,
; 2741 :                         &outusedv, &outusedr, &outtrkbr,
; 2742 :                         &outtrk, &outcyl, &outhead, &outrec);
; 2743 :             if (rc < 0)

  009c8	83 bc 24 80 00
	00 00 00	 cmp	 DWORD PTR rc$[rsp], 0
  009d0	7d 79		 jge	 SHORT $LN36@process_ie

; 2744 :             {
; 2745 :                 XMERRF ( MSG( HHC02570, "E", ofname, "write_block()",

  009d2	8b 84 24 c0 00
	00 00		 mov	 eax, DWORD PTR datalen$[rsp]
  009d9	89 44 24 50	 mov	 DWORD PTR [rsp+80], eax
  009dd	8b 84 24 c4 00
	00 00		 mov	 eax, DWORD PTR keylen$[rsp]
  009e4	89 44 24 48	 mov	 DWORD PTR [rsp+72], eax
  009e8	8b 84 24 a8 00
	00 00		 mov	 eax, DWORD PTR blkrec$[rsp]
  009ef	89 44 24 40	 mov	 DWORD PTR [rsp+64], eax
  009f3	8b 84 24 dc 00
	00 00		 mov	 eax, DWORD PTR blktrk$[rsp]
  009fa	89 44 24 38	 mov	 DWORD PTR [rsp+56], eax
  009fe	8b 84 24 a8 00
	00 00		 mov	 eax, DWORD PTR blkrec$[rsp]
  00a05	89 44 24 30	 mov	 DWORD PTR [rsp+48], eax
  00a09	8b 84 24 cc 00
	00 00		 mov	 eax, DWORD PTR blkhead$[rsp]
  00a10	89 44 24 28	 mov	 DWORD PTR [rsp+40], eax
  00a14	8b 84 24 d0 00
	00 00		 mov	 eax, DWORD PTR blkcyl$[rsp]
  00a1b	89 44 24 20	 mov	 DWORD PTR [rsp+32], eax
  00a1f	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG161920
  00a26	4c 8b 84 24 28
	03 00 00	 mov	 r8, QWORD PTR ofname$[rsp]
  00a2e	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG161921
  00a35	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG161922
  00a3c	e8 00 00 00 00	 call	 printf

; 2746 :                         blkcyl, blkhead, blkrec,
; 2747 :                         blktrk, blkrec, keylen, datalen ) );
; 2748 :                 return -1;

  00a41	b8 ff ff ff ff	 mov	 eax, -1
  00a46	e9 da 06 00 00	 jmp	 $LN1@process_ie
$LN36@process_ie:

; 2749 :             }
; 2750 : 
; 2751 :             XMINFF (4, MSG( HHC02564, "I", blkcyl, blkhead, blkrec, blktrk, blkrec, keylen, datalen,

  00a4b	8b 84 24 bc 00
	00 00		 mov	 eax, DWORD PTR outrec$[rsp]
  00a52	89 44 24 70	 mov	 DWORD PTR [rsp+112], eax
  00a56	8b 84 24 c8 00
	00 00		 mov	 eax, DWORD PTR outtrk$[rsp]
  00a5d	89 44 24 68	 mov	 DWORD PTR [rsp+104], eax
  00a61	8b 84 24 bc 00
	00 00		 mov	 eax, DWORD PTR outrec$[rsp]
  00a68	89 44 24 60	 mov	 DWORD PTR [rsp+96], eax
  00a6c	8b 84 24 58 03
	00 00		 mov	 eax, DWORD PTR outhead$[rsp]
  00a73	89 44 24 58	 mov	 DWORD PTR [rsp+88], eax
  00a77	8b 84 24 50 03
	00 00		 mov	 eax, DWORD PTR outcyl$[rsp]
  00a7e	89 44 24 50	 mov	 DWORD PTR [rsp+80], eax
  00a82	8b 84 24 c0 00
	00 00		 mov	 eax, DWORD PTR datalen$[rsp]
  00a89	89 44 24 48	 mov	 DWORD PTR [rsp+72], eax
  00a8d	8b 84 24 c4 00
	00 00		 mov	 eax, DWORD PTR keylen$[rsp]
  00a94	89 44 24 40	 mov	 DWORD PTR [rsp+64], eax
  00a98	8b 84 24 a8 00
	00 00		 mov	 eax, DWORD PTR blkrec$[rsp]
  00a9f	89 44 24 38	 mov	 DWORD PTR [rsp+56], eax
  00aa3	8b 84 24 dc 00
	00 00		 mov	 eax, DWORD PTR blktrk$[rsp]
  00aaa	89 44 24 30	 mov	 DWORD PTR [rsp+48], eax
  00aae	8b 84 24 a8 00
	00 00		 mov	 eax, DWORD PTR blkrec$[rsp]
  00ab5	89 44 24 28	 mov	 DWORD PTR [rsp+40], eax
  00ab9	8b 84 24 cc 00
	00 00		 mov	 eax, DWORD PTR blkhead$[rsp]
  00ac0	89 44 24 20	 mov	 DWORD PTR [rsp+32], eax
  00ac4	44 8b 8c 24 d0
	00 00 00	 mov	 r9d, DWORD PTR blkcyl$[rsp]
  00acc	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG161923
  00ad3	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG161924
  00ada	b9 04 00 00 00	 mov	 ecx, 4
  00adf	e8 00 00 00 00	 call	 info_msg

; 2752 :                                            outcyl, outhead, outrec, outtrk, outrec ) );
; 2753 : 
; 2754 :             /* Process directory block or member block */
; 2755 :             if (enddir == 0)

  00ae4	83 bc 24 e4 00
	00 00 00	 cmp	 DWORD PTR enddir$[rsp], 0
  00aec	0f 85 9c 00 00
	00		 jne	 $LN37@process_ie

; 2756 :             {
; 2757 :                 rc = process_dirblk (datablk, blklen,

  00af2	48 8b 84 24 98
	03 00 00	 mov	 rax, QWORD PTR dirblu$[rsp]
  00afa	48 89 44 24 38	 mov	 QWORD PTR [rsp+56], rax
  00aff	8b 84 24 d4 00
	00 00		 mov	 eax, DWORD PTR dirblkn$[rsp]
  00b06	89 44 24 30	 mov	 DWORD PTR [rsp+48], eax
  00b0a	48 8b 84 24 08
	01 00 00	 mov	 rax, QWORD PTR dirblka$[rsp]
  00b12	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  00b17	8b 84 24 bc 00
	00 00		 mov	 eax, DWORD PTR outrec$[rsp]
  00b1e	89 44 24 20	 mov	 DWORD PTR [rsp+32], eax
  00b22	44 8b 8c 24 58
	03 00 00	 mov	 r9d, DWORD PTR outhead$[rsp]
  00b2a	44 8b 84 24 50
	03 00 00	 mov	 r8d, DWORD PTR outcyl$[rsp]
  00b32	8b 94 24 f8 00
	00 00		 mov	 edx, DWORD PTR blklen$[rsp]
  00b39	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR datablk$[rsp]
  00b41	e8 00 00 00 00	 call	 process_dirblk
  00b46	89 84 24 80 00
	00 00		 mov	 DWORD PTR rc$[rsp], eax

; 2758 :                                     outcyl, outhead, outrec,
; 2759 :                                     dirblka, dirblkn, dirblu);
; 2760 :                 if (rc < 0) return -1;

  00b4d	83 bc 24 80 00
	00 00 00	 cmp	 DWORD PTR rc$[rsp], 0
  00b55	7d 0a		 jge	 SHORT $LN39@process_ie
  00b57	b8 ff ff ff ff	 mov	 eax, -1
  00b5c	e9 c4 05 00 00	 jmp	 $LN1@process_ie
$LN39@process_ie:

; 2761 :                 enddir = rc;

  00b61	8b 84 24 80 00
	00 00		 mov	 eax, DWORD PTR rc$[rsp]
  00b68	89 84 24 e4 00
	00 00		 mov	 DWORD PTR enddir$[rsp], eax

; 2762 : 
; 2763 :                 /* Count the number of directory blocks read */
; 2764 :                 if (enddir == 0) dirblkn++;

  00b6f	83 bc 24 e4 00
	00 00 00	 cmp	 DWORD PTR enddir$[rsp], 0
  00b77	75 10		 jne	 SHORT $LN40@process_ie
  00b79	8b 84 24 d4 00
	00 00		 mov	 eax, DWORD PTR dirblkn$[rsp]
  00b80	ff c0		 inc	 eax
  00b82	89 84 24 d4 00
	00 00		 mov	 DWORD PTR dirblkn$[rsp], eax
$LN40@process_ie:

; 2765 :             }

  00b89	e9 6d 01 00 00	 jmp	 $LN38@process_ie
$LN37@process_ie:

; 2766 :             else /* Not a directory block */
; 2767 :             {
; 2768 :                 /* Check that TTR conversion table is not full */
; 2769 :                 if (numttr >= MAXTTR)

  00b8e	81 bc 24 94 00
	00 00 50 c3 00
	00		 cmp	 DWORD PTR numttr$[rsp], 50000 ; 0000c350H
  00b99	7c 23		 jl	 SHORT $LN41@process_ie

; 2770 :                 {
; 2771 :                     XMERRF ( MSG( HHC02571, "E", MAXTTR ) );

  00b9b	41 b8 50 c3 00
	00		 mov	 r8d, 50000		; 0000c350H
  00ba1	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG161930
  00ba8	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG161931
  00baf	e8 00 00 00 00	 call	 printf

; 2772 :                     return -1;

  00bb4	b8 ff ff ff ff	 mov	 eax, -1
  00bb9	e9 67 05 00 00	 jmp	 $LN1@process_ie
$LN41@process_ie:

; 2773 :                 }
; 2774 : 
; 2775 :                 /* Add an entry to the TTR conversion table */
; 2776 :                 ttrtab[numttr].origttr[0] = (blktrk >> 8) & 0xFF;

  00bbe	8b 84 24 dc 00
	00 00		 mov	 eax, DWORD PTR blktrk$[rsp]
  00bc5	c1 f8 08	 sar	 eax, 8
  00bc8	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  00bcd	48 63 8c 24 94
	00 00 00	 movsxd	 rcx, DWORD PTR numttr$[rsp]
  00bd5	48 6b c9 06	 imul	 rcx, rcx, 6
  00bd9	48 8b 94 24 e8
	00 00 00	 mov	 rdx, QWORD PTR ttrtab$[rsp]
  00be1	48 03 d1	 add	 rdx, rcx
  00be4	48 8b ca	 mov	 rcx, rdx
  00be7	ba 01 00 00 00	 mov	 edx, 1
  00bec	48 6b d2 00	 imul	 rdx, rdx, 0
  00bf0	88 04 11	 mov	 BYTE PTR [rcx+rdx], al

; 2777 :                 ttrtab[numttr].origttr[1] = blktrk & 0xFF;

  00bf3	8b 84 24 dc 00
	00 00		 mov	 eax, DWORD PTR blktrk$[rsp]
  00bfa	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  00bff	48 63 8c 24 94
	00 00 00	 movsxd	 rcx, DWORD PTR numttr$[rsp]
  00c07	48 6b c9 06	 imul	 rcx, rcx, 6
  00c0b	48 8b 94 24 e8
	00 00 00	 mov	 rdx, QWORD PTR ttrtab$[rsp]
  00c13	48 03 d1	 add	 rdx, rcx
  00c16	48 8b ca	 mov	 rcx, rdx
  00c19	ba 01 00 00 00	 mov	 edx, 1
  00c1e	48 6b d2 01	 imul	 rdx, rdx, 1
  00c22	88 04 11	 mov	 BYTE PTR [rcx+rdx], al

; 2778 :                 ttrtab[numttr].origttr[2] = (BYTE) blkrec;

  00c25	48 63 84 24 94
	00 00 00	 movsxd	 rax, DWORD PTR numttr$[rsp]
  00c2d	48 6b c0 06	 imul	 rax, rax, 6
  00c31	48 8b 8c 24 e8
	00 00 00	 mov	 rcx, QWORD PTR ttrtab$[rsp]
  00c39	48 03 c8	 add	 rcx, rax
  00c3c	48 8b c1	 mov	 rax, rcx
  00c3f	b9 01 00 00 00	 mov	 ecx, 1
  00c44	48 6b c9 02	 imul	 rcx, rcx, 2
  00c48	0f b6 94 24 a8
	00 00 00	 movzx	 edx, BYTE PTR blkrec$[rsp]
  00c50	88 14 08	 mov	 BYTE PTR [rax+rcx], dl

; 2779 :                 ttrtab[numttr].outpttr[0] = (outtrk >> 8) & 0xFF;

  00c53	8b 84 24 c8 00
	00 00		 mov	 eax, DWORD PTR outtrk$[rsp]
  00c5a	c1 f8 08	 sar	 eax, 8
  00c5d	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  00c62	48 63 8c 24 94
	00 00 00	 movsxd	 rcx, DWORD PTR numttr$[rsp]
  00c6a	48 6b c9 06	 imul	 rcx, rcx, 6
  00c6e	48 8b 94 24 e8
	00 00 00	 mov	 rdx, QWORD PTR ttrtab$[rsp]
  00c76	48 03 d1	 add	 rdx, rcx
  00c79	48 8b ca	 mov	 rcx, rdx
  00c7c	ba 01 00 00 00	 mov	 edx, 1
  00c81	48 6b d2 00	 imul	 rdx, rdx, 0
  00c85	88 44 11 03	 mov	 BYTE PTR [rcx+rdx+3], al

; 2780 :                 ttrtab[numttr].outpttr[1] = outtrk & 0xFF;

  00c89	8b 84 24 c8 00
	00 00		 mov	 eax, DWORD PTR outtrk$[rsp]
  00c90	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  00c95	48 63 8c 24 94
	00 00 00	 movsxd	 rcx, DWORD PTR numttr$[rsp]
  00c9d	48 6b c9 06	 imul	 rcx, rcx, 6
  00ca1	48 8b 94 24 e8
	00 00 00	 mov	 rdx, QWORD PTR ttrtab$[rsp]
  00ca9	48 03 d1	 add	 rdx, rcx
  00cac	48 8b ca	 mov	 rcx, rdx
  00caf	ba 01 00 00 00	 mov	 edx, 1
  00cb4	48 6b d2 01	 imul	 rdx, rdx, 1
  00cb8	88 44 11 03	 mov	 BYTE PTR [rcx+rdx+3], al

; 2781 :                 ttrtab[numttr].outpttr[2] = (BYTE) outrec;

  00cbc	48 63 84 24 94
	00 00 00	 movsxd	 rax, DWORD PTR numttr$[rsp]
  00cc4	48 6b c0 06	 imul	 rax, rax, 6
  00cc8	48 8b 8c 24 e8
	00 00 00	 mov	 rcx, QWORD PTR ttrtab$[rsp]
  00cd0	48 03 c8	 add	 rcx, rax
  00cd3	48 8b c1	 mov	 rax, rcx
  00cd6	b9 01 00 00 00	 mov	 ecx, 1
  00cdb	48 6b c9 02	 imul	 rcx, rcx, 2
  00cdf	0f b6 94 24 bc
	00 00 00	 movzx	 edx, BYTE PTR outrec$[rsp]
  00ce7	88 54 08 03	 mov	 BYTE PTR [rax+rcx+3], dl

; 2782 :                 numttr++;

  00ceb	8b 84 24 94 00
	00 00		 mov	 eax, DWORD PTR numttr$[rsp]
  00cf2	ff c0		 inc	 eax
  00cf4	89 84 24 94 00
	00 00		 mov	 DWORD PTR numttr$[rsp], eax
$LN38@process_ie:

; 2783 :             }
; 2784 : 
; 2785 :             /* Point to next data block in data record */
; 2786 :             xreclen -= blklen;

  00cfb	8b 84 24 f8 00
	00 00		 mov	 eax, DWORD PTR blklen$[rsp]
  00d02	8b 8c 24 90 00
	00 00		 mov	 ecx, DWORD PTR xreclen$[rsp]
  00d09	2b c8		 sub	 ecx, eax
  00d0b	8b c1		 mov	 eax, ecx
  00d0d	89 84 24 90 00
	00 00		 mov	 DWORD PTR xreclen$[rsp], eax

; 2787 :             blkptr += blklen;

  00d14	48 63 84 24 f8
	00 00 00	 movsxd	 rax, DWORD PTR blklen$[rsp]
  00d1c	48 8b 8c 24 28
	01 00 00	 mov	 rcx, QWORD PTR blkptr$[rsp]
  00d24	48 03 c8	 add	 rcx, rax
  00d27	48 8b c1	 mov	 rax, rcx
  00d2a	48 89 84 24 28
	01 00 00	 mov	 QWORD PTR blkptr$[rsp], rax

; 2788 : 
; 2789 :         } /* end while(xreclen) */

  00d32	e9 70 fa ff ff	 jmp	 $LN4@process_ie
$LN5@process_ie:

; 2790 : 
; 2791 :     } /* end while(1) */

  00d37	e9 db f5 ff ff	 jmp	 $LN54@process_ie
$LN3@process_ie:

; 2792 : 
; 2793 :     /* Check for unsupported xmit utility */
; 2794 :     if (method == METHOD_XMIT && copyfiln == 0)

  00d3c	0f b6 84 24 68
	03 00 00	 movzx	 eax, BYTE PTR method$[rsp]
  00d44	83 f8 01	 cmp	 eax, 1
  00d47	75 25		 jne	 SHORT $LN42@process_ie
  00d49	83 bc 24 e0 00
	00 00 00	 cmp	 DWORD PTR copyfiln$[rsp], 0
  00d51	75 1b		 jne	 SHORT $LN42@process_ie

; 2795 :     {
; 2796 :         XMERRF ( MSG( HHC02572, "W", xfname ) );

  00d53	4c 8b 84 24 20
	03 00 00	 mov	 r8, QWORD PTR xfname$[rsp]
  00d5b	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG161933
  00d62	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG161934
  00d69	e8 00 00 00 00	 call	 printf
$LN42@process_ie:

; 2797 :     }
; 2798 : 
; 2799 :     /* Return the last record number and track balance */
; 2800 :     *lastrec = outrec;

  00d6e	48 8b 84 24 a0
	03 00 00	 mov	 rax, QWORD PTR lastrec$[rsp]
  00d76	8b 8c 24 bc 00
	00 00		 mov	 ecx, DWORD PTR outrec$[rsp]
  00d7d	89 08		 mov	 DWORD PTR [rax], ecx

; 2801 :     *trkbal = outtrkbr;

  00d7f	48 8b 84 24 a8
	03 00 00	 mov	 rax, QWORD PTR trkbal$[rsp]
  00d87	8b 8c 24 14 01
	00 00		 mov	 ecx, DWORD PTR outtrkbr$[rsp]
  00d8e	89 08		 mov	 DWORD PTR [rax], ecx

; 2802 : 
; 2803 :     /* Write any data remaining in track buffer */
; 2804 :     rc = write_track (cif, ofname, heads, trklen,

  00d90	48 8d 84 24 58
	03 00 00	 lea	 rax, QWORD PTR outhead$[rsp]
  00d98	48 89 44 24 38	 mov	 QWORD PTR [rsp+56], rax
  00d9d	48 8d 84 24 50
	03 00 00	 lea	 rax, QWORD PTR outcyl$[rsp]
  00da5	48 89 44 24 30	 mov	 QWORD PTR [rsp+48], rax
  00daa	48 8d 84 24 c8
	00 00 00	 lea	 rax, QWORD PTR outtrk$[rsp]
  00db2	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  00db7	48 8d 84 24 18
	01 00 00	 lea	 rax, QWORD PTR outusedv$[rsp]
  00dbf	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00dc4	44 8b 8c 24 48
	03 00 00	 mov	 r9d, DWORD PTR trklen$[rsp]
  00dcc	44 8b 84 24 40
	03 00 00	 mov	 r8d, DWORD PTR heads$[rsp]
  00dd4	48 8b 94 24 28
	03 00 00	 mov	 rdx, QWORD PTR ofname$[rsp]
  00ddc	48 8b 8c 24 30
	03 00 00	 mov	 rcx, QWORD PTR cif$[rsp]
  00de4	e8 00 00 00 00	 call	 write_track
  00de9	89 84 24 80 00
	00 00		 mov	 DWORD PTR rc$[rsp], eax

; 2805 :                     &outusedv, &outtrk, &outcyl, &outhead);
; 2806 :     if (rc < 0) return -1;

  00df0	83 bc 24 80 00
	00 00 00	 cmp	 DWORD PTR rc$[rsp], 0
  00df8	7d 0a		 jge	 SHORT $LN43@process_ie
  00dfa	b8 ff ff ff ff	 mov	 eax, -1
  00dff	e9 21 03 00 00	 jmp	 $LN1@process_ie
$LN43@process_ie:

; 2807 : 
; 2808 :     /* Update the directory and rewrite to output file */
; 2809 :     for (i = 0; i < dirblkn; i++)

  00e04	c7 84 24 98 00
	00 00 00 00 00
	00		 mov	 DWORD PTR i$[rsp], 0
  00e0f	eb 10		 jmp	 SHORT $LN8@process_ie
$LN6@process_ie:
  00e11	8b 84 24 98 00
	00 00		 mov	 eax, DWORD PTR i$[rsp]
  00e18	ff c0		 inc	 eax
  00e1a	89 84 24 98 00
	00 00		 mov	 DWORD PTR i$[rsp], eax
$LN8@process_ie:
  00e21	8b 84 24 d4 00
	00 00		 mov	 eax, DWORD PTR dirblkn$[rsp]
  00e28	39 84 24 98 00
	00 00		 cmp	 DWORD PTR i$[rsp], eax
  00e2f	0f 8d e1 01 00
	00		 jge	 $LN7@process_ie

; 2810 :     {
; 2811 :         /* Obtain the directory block pointer from the array */
; 2812 :         datablk = dirblka[i];

  00e35	48 63 84 24 98
	00 00 00	 movsxd	 rax, DWORD PTR i$[rsp]
  00e3d	48 8b 8c 24 08
	01 00 00	 mov	 rcx, QWORD PTR dirblka$[rsp]
  00e45	48 8b 04 c1	 mov	 rax, QWORD PTR [rcx+rax*8]
  00e49	48 89 84 24 88
	00 00 00	 mov	 QWORD PTR datablk$[rsp], rax

; 2813 : 
; 2814 :         /* Update TTR pointers in this directory block */
; 2815 :         rc = update_dirblk (cif, ofname, heads, trklen, dsstart,

  00e51	8b 84 24 94 00
	00 00		 mov	 eax, DWORD PTR numttr$[rsp]
  00e58	89 44 24 38	 mov	 DWORD PTR [rsp+56], eax
  00e5c	48 8b 84 24 e8
	00 00 00	 mov	 rax, QWORD PTR ttrtab$[rsp]
  00e64	48 89 44 24 30	 mov	 QWORD PTR [rsp+48], rax
  00e69	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR datablk$[rsp]
  00e71	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  00e76	8b 84 24 24 01
	00 00		 mov	 eax, DWORD PTR dsstart$[rsp]
  00e7d	89 44 24 20	 mov	 DWORD PTR [rsp+32], eax
  00e81	44 8b 8c 24 48
	03 00 00	 mov	 r9d, DWORD PTR trklen$[rsp]
  00e89	44 8b 84 24 40
	03 00 00	 mov	 r8d, DWORD PTR heads$[rsp]
  00e91	48 8b 94 24 28
	03 00 00	 mov	 rdx, QWORD PTR ofname$[rsp]
  00e99	48 8b 8c 24 30
	03 00 00	 mov	 rcx, QWORD PTR cif$[rsp]
  00ea1	e8 00 00 00 00	 call	 update_dirblk
  00ea6	89 84 24 80 00
	00 00		 mov	 DWORD PTR rc$[rsp], eax

; 2816 :                             datablk, ttrtab, numttr);
; 2817 :         if (rc < 0) return -1;

  00ead	83 bc 24 80 00
	00 00 00	 cmp	 DWORD PTR rc$[rsp], 0
  00eb5	7d 0a		 jge	 SHORT $LN44@process_ie
  00eb7	b8 ff ff ff ff	 mov	 eax, -1
  00ebc	e9 64 02 00 00	 jmp	 $LN1@process_ie
$LN44@process_ie:

; 2818 : 
; 2819 :         /* Rewrite the updated directory block */
; 2820 :         blkcyl = (datablk->cyl[0] << 8) | datablk->cyl[1];

  00ec1	b8 01 00 00 00	 mov	 eax, 1
  00ec6	48 6b c0 00	 imul	 rax, rax, 0
  00eca	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR datablk$[rsp]
  00ed2	0f b6 44 01 04	 movzx	 eax, BYTE PTR [rcx+rax+4]
  00ed7	c1 e0 08	 shl	 eax, 8
  00eda	b9 01 00 00 00	 mov	 ecx, 1
  00edf	48 6b c9 01	 imul	 rcx, rcx, 1
  00ee3	48 8b 94 24 88
	00 00 00	 mov	 rdx, QWORD PTR datablk$[rsp]
  00eeb	0f b6 4c 0a 04	 movzx	 ecx, BYTE PTR [rdx+rcx+4]
  00ef0	0b c1		 or	 eax, ecx
  00ef2	89 84 24 d0 00
	00 00		 mov	 DWORD PTR blkcyl$[rsp], eax

; 2821 :         blkhead = (datablk->head[0] << 8) | datablk->head[1];

  00ef9	b8 01 00 00 00	 mov	 eax, 1
  00efe	48 6b c0 00	 imul	 rax, rax, 0
  00f02	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR datablk$[rsp]
  00f0a	0f b6 44 01 06	 movzx	 eax, BYTE PTR [rcx+rax+6]
  00f0f	c1 e0 08	 shl	 eax, 8
  00f12	b9 01 00 00 00	 mov	 ecx, 1
  00f17	48 6b c9 01	 imul	 rcx, rcx, 1
  00f1b	48 8b 94 24 88
	00 00 00	 mov	 rdx, QWORD PTR datablk$[rsp]
  00f23	0f b6 4c 0a 06	 movzx	 ecx, BYTE PTR [rdx+rcx+6]
  00f28	0b c1		 or	 eax, ecx
  00f2a	89 84 24 cc 00
	00 00		 mov	 DWORD PTR blkhead$[rsp], eax

; 2822 :         blkrec = datablk->rec;

  00f31	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR datablk$[rsp]
  00f39	0f b6 40 08	 movzx	 eax, BYTE PTR [rax+8]
  00f3d	89 84 24 a8 00
	00 00		 mov	 DWORD PTR blkrec$[rsp], eax

; 2823 :         keylen = datablk->klen;

  00f44	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR datablk$[rsp]
  00f4c	0f b6 40 09	 movzx	 eax, BYTE PTR [rax+9]
  00f50	89 84 24 c4 00
	00 00		 mov	 DWORD PTR keylen$[rsp], eax

; 2824 :         datalen = (datablk->dlen[0] << 8) | datablk->dlen[1];

  00f57	b8 01 00 00 00	 mov	 eax, 1
  00f5c	48 6b c0 00	 imul	 rax, rax, 0
  00f60	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR datablk$[rsp]
  00f68	0f b6 44 01 0a	 movzx	 eax, BYTE PTR [rcx+rax+10]
  00f6d	c1 e0 08	 shl	 eax, 8
  00f70	b9 01 00 00 00	 mov	 ecx, 1
  00f75	48 6b c9 01	 imul	 rcx, rcx, 1
  00f79	48 8b 94 24 88
	00 00 00	 mov	 rdx, QWORD PTR datablk$[rsp]
  00f81	0f b6 4c 0a 0a	 movzx	 ecx, BYTE PTR [rdx+rcx+10]
  00f86	0b c1		 or	 eax, ecx
  00f88	89 84 24 c0 00
	00 00		 mov	 DWORD PTR datalen$[rsp], eax

; 2825 : 
; 2826 :         rc = update_block (cif, ofname, datablk, blkcyl, blkhead,

  00f8f	8b 84 24 48 03
	00 00		 mov	 eax, DWORD PTR trklen$[rsp]
  00f96	89 44 24 48	 mov	 DWORD PTR [rsp+72], eax
  00f9a	8b 84 24 40 03
	00 00		 mov	 eax, DWORD PTR heads$[rsp]
  00fa1	89 44 24 40	 mov	 DWORD PTR [rsp+64], eax
  00fa5	8b 84 24 c0 00
	00 00		 mov	 eax, DWORD PTR datalen$[rsp]
  00fac	89 44 24 38	 mov	 DWORD PTR [rsp+56], eax
  00fb0	8b 84 24 c4 00
	00 00		 mov	 eax, DWORD PTR keylen$[rsp]
  00fb7	89 44 24 30	 mov	 DWORD PTR [rsp+48], eax
  00fbb	8b 84 24 a8 00
	00 00		 mov	 eax, DWORD PTR blkrec$[rsp]
  00fc2	89 44 24 28	 mov	 DWORD PTR [rsp+40], eax
  00fc6	8b 84 24 cc 00
	00 00		 mov	 eax, DWORD PTR blkhead$[rsp]
  00fcd	89 44 24 20	 mov	 DWORD PTR [rsp+32], eax
  00fd1	44 8b 8c 24 d0
	00 00 00	 mov	 r9d, DWORD PTR blkcyl$[rsp]
  00fd9	4c 8b 84 24 88
	00 00 00	 mov	 r8, QWORD PTR datablk$[rsp]
  00fe1	48 8b 94 24 28
	03 00 00	 mov	 rdx, QWORD PTR ofname$[rsp]
  00fe9	48 8b 8c 24 30
	03 00 00	 mov	 rcx, QWORD PTR cif$[rsp]
  00ff1	e8 00 00 00 00	 call	 update_block
  00ff6	89 84 24 80 00
	00 00		 mov	 DWORD PTR rc$[rsp], eax

; 2827 :                         blkrec, keylen, datalen, heads, trklen);
; 2828 :         if (rc < 0) return -1;

  00ffd	83 bc 24 80 00
	00 00 00	 cmp	 DWORD PTR rc$[rsp], 0
  01005	7d 0a		 jge	 SHORT $LN45@process_ie
  01007	b8 ff ff ff ff	 mov	 eax, -1
  0100c	e9 14 01 00 00	 jmp	 $LN1@process_ie
$LN45@process_ie:

; 2829 : 
; 2830 :     } /* end for(i) */

  01011	e9 fb fd ff ff	 jmp	 $LN6@process_ie
$LN7@process_ie:

; 2831 : 
; 2832 :     /* Close input file and release buffers */
; 2833 :     close (xfd);

  01016	8b 8c 24 ac 00
	00 00		 mov	 ecx, DWORD PTR xfd$[rsp]
  0101d	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_close

; 2834 :     for (i = 0; i < dirblkn; i++)

  01023	c7 84 24 98 00
	00 00 00 00 00
	00		 mov	 DWORD PTR i$[rsp], 0
  0102e	eb 10		 jmp	 SHORT $LN11@process_ie
$LN9@process_ie:
  01030	8b 84 24 98 00
	00 00		 mov	 eax, DWORD PTR i$[rsp]
  01037	ff c0		 inc	 eax
  01039	89 84 24 98 00
	00 00		 mov	 DWORD PTR i$[rsp], eax
$LN11@process_ie:
  01040	8b 84 24 d4 00
	00 00		 mov	 eax, DWORD PTR dirblkn$[rsp]
  01047	39 84 24 98 00
	00 00		 cmp	 DWORD PTR i$[rsp], eax
  0104e	7d 1c		 jge	 SHORT $LN10@process_ie

; 2835 :         free (dirblka[i]);

  01050	48 63 84 24 98
	00 00 00	 movsxd	 rax, DWORD PTR i$[rsp]
  01058	48 8b 8c 24 08
	01 00 00	 mov	 rcx, QWORD PTR dirblka$[rsp]
  01060	48 8b 0c c1	 mov	 rcx, QWORD PTR [rcx+rax*8]
  01064	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free
  0106a	eb c4		 jmp	 SHORT $LN9@process_ie
$LN10@process_ie:

; 2836 :     free (dirblka);

  0106c	48 8b 8c 24 08
	01 00 00	 mov	 rcx, QWORD PTR dirblka$[rsp]
  01074	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free

; 2837 :     free (xbuf);

  0107a	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR xbuf$[rsp]
  01082	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free

; 2838 :     free (ttrtab);

  01088	48 8b 8c 24 e8
	00 00 00	 mov	 rcx, QWORD PTR ttrtab$[rsp]
  01090	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free

; 2839 : 
; 2840 :     /* Return the dataset attributes */
; 2841 :     *odsorg = dsorg;

  01096	48 8b 84 24 70
	03 00 00	 mov	 rax, QWORD PTR odsorg$[rsp]
  0109e	0f b6 8c 24 84
	00 00 00	 movzx	 ecx, BYTE PTR dsorg$[rsp]
  010a6	88 08		 mov	 BYTE PTR [rax], cl

; 2842 :     *orecfm = recfm;

  010a8	48 8b 84 24 78
	03 00 00	 mov	 rax, QWORD PTR orecfm$[rsp]
  010b0	0f b6 8c 24 85
	00 00 00	 movzx	 ecx, BYTE PTR recfm$[rsp]
  010b8	88 08		 mov	 BYTE PTR [rax], cl

; 2843 :     *olrecl = lrecl;

  010ba	0f b7 84 24 9c
	00 00 00	 movzx	 eax, WORD PTR lrecl$[rsp]
  010c2	48 8b 8c 24 80
	03 00 00	 mov	 rcx, QWORD PTR olrecl$[rsp]
  010ca	89 01		 mov	 DWORD PTR [rcx], eax

; 2844 :     *oblksz = blksz;

  010cc	0f b7 84 24 a0
	00 00 00	 movzx	 eax, WORD PTR blksz$[rsp]
  010d4	48 8b 8c 24 88
	03 00 00	 mov	 rcx, QWORD PTR oblksz$[rsp]
  010dc	89 01		 mov	 DWORD PTR [rcx], eax

; 2845 :     *okeyln = keyln;

  010de	0f b7 84 24 a4
	00 00 00	 movzx	 eax, WORD PTR keyln$[rsp]
  010e6	48 8b 8c 24 90
	03 00 00	 mov	 rcx, QWORD PTR okeyln$[rsp]
  010ee	89 01		 mov	 DWORD PTR [rcx], eax

; 2846 : 
; 2847 :     /* Return number of tracks and starting address of next dataset */
; 2848 :     *numtrks = outtrk;

  010f0	48 8b 84 24 b0
	03 00 00	 mov	 rax, QWORD PTR numtrks$[rsp]
  010f8	8b 8c 24 c8 00
	00 00		 mov	 ecx, DWORD PTR outtrk$[rsp]
  010ff	89 08		 mov	 DWORD PTR [rax], ecx

; 2849 :     *nxtcyl = outcyl;

  01101	48 8b 84 24 b8
	03 00 00	 mov	 rax, QWORD PTR nxtcyl$[rsp]
  01109	8b 8c 24 50 03
	00 00		 mov	 ecx, DWORD PTR outcyl$[rsp]
  01110	89 08		 mov	 DWORD PTR [rax], ecx

; 2850 :     *nxthead = outhead;

  01112	48 8b 84 24 c0
	03 00 00	 mov	 rax, QWORD PTR nxthead$[rsp]
  0111a	8b 8c 24 58 03
	00 00		 mov	 ecx, DWORD PTR outhead$[rsp]
  01121	89 08		 mov	 DWORD PTR [rax], ecx

; 2851 :     return 0;

  01123	33 c0		 xor	 eax, eax
$LN1@process_ie:
$LN46@process_ie:

; 2852 : 
; 2853 : } /* end function process_iebcopy_file */

  01125	48 8b 8c 24 00
	03 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  0112d	48 33 cc	 xor	 rcx, rsp
  01130	e8 00 00 00 00	 call	 __security_check_cookie
  01135	48 81 c4 18 03
	00 00		 add	 rsp, 792		; 00000318H
  0113c	c3		 ret	 0
process_iebcopy_file ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\dasdload64.c
_TEXT	SEGMENT
dirrem$ = 80
rc$ = 84
dirent$ = 88
i$ = 96
dirptr$ = 104
n$ = 112
size$ = 116
k$ = 120
ttrptr$ = 128
memname$ = 136
__$ArrayPad$ = 152
cif$ = 176
ofname$ = 184
heads$ = 192
trklen$ = 200
dsstart$ = 208
xbuf$ = 216
ttrtab$ = 224
numttr$ = 232
update_dirblk PROC

; 2425 : {

  00000	44 89 4c 24 20	 mov	 DWORD PTR [rsp+32], r9d
  00005	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	48 81 ec a8 00
	00 00		 sub	 rsp, 168		; 000000a8H
  0001b	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00022	48 33 c4	 xor	 rax, rsp
  00025	48 89 84 24 98
	00 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 2426 : int             rc;                     /* Return code               */
; 2427 : int             size;                   /* Size of directory entry   */
; 2428 : int             k;                      /* Userdata halfword count   */
; 2429 : BYTE           *dirptr;                 /* -> Next byte within block */
; 2430 : int             dirrem;                 /* Number of bytes remaining */
; 2431 : PDSDIR         *dirent;                 /* -> Directory entry        */
; 2432 : BYTE           *ttrptr;                 /* -> User TTR               */
; 2433 : int             n;                      /* Number of user TTRs       */
; 2434 : int             i;                      /* Loop counter              */
; 2435 : char            memname[9];             /* Member name (ASCIIZ)      */
; 2436 : 
; 2437 :     /* Load number of bytes in directory block */
; 2438 :     dirptr = xbuf->kdarea + 8;

  0002d	48 8b 84 24 d8
	00 00 00	 mov	 rax, QWORD PTR xbuf$[rsp]
  00035	48 83 c0 14	 add	 rax, 20
  00039	48 89 44 24 68	 mov	 QWORD PTR dirptr$[rsp], rax

; 2439 :     dirrem = (dirptr[0] << 8) | dirptr[1];

  0003e	b8 01 00 00 00	 mov	 eax, 1
  00043	48 6b c0 00	 imul	 rax, rax, 0
  00047	48 8b 4c 24 68	 mov	 rcx, QWORD PTR dirptr$[rsp]
  0004c	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00050	c1 e0 08	 shl	 eax, 8
  00053	b9 01 00 00 00	 mov	 ecx, 1
  00058	48 6b c9 01	 imul	 rcx, rcx, 1
  0005c	48 8b 54 24 68	 mov	 rdx, QWORD PTR dirptr$[rsp]
  00061	0f b6 0c 0a	 movzx	 ecx, BYTE PTR [rdx+rcx]
  00065	0b c1		 or	 eax, ecx
  00067	89 44 24 50	 mov	 DWORD PTR dirrem$[rsp], eax

; 2440 :     if (dirrem < 2 || dirrem > 256)

  0006b	83 7c 24 50 02	 cmp	 DWORD PTR dirrem$[rsp], 2
  00070	7c 0a		 jl	 SHORT $LN8@update_dir
  00072	81 7c 24 50 00
	01 00 00	 cmp	 DWORD PTR dirrem$[rsp], 256 ; 00000100H
  0007a	7e 1d		 jle	 SHORT $LN7@update_dir
$LN8@update_dir:

; 2441 :     {
; 2442 :         XMERR ( MSG( HHC02546, "E" ) );

  0007c	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG161747
  00083	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG161748
  0008a	e8 00 00 00 00	 call	 printf

; 2443 :         return -1;

  0008f	b8 ff ff ff ff	 mov	 eax, -1
  00094	e9 37 02 00 00	 jmp	 $LN1@update_dir
$LN7@update_dir:

; 2444 :     }
; 2445 : 
; 2446 :     /* Point to first directory entry */
; 2447 :     dirptr += 2;

  00099	48 8b 44 24 68	 mov	 rax, QWORD PTR dirptr$[rsp]
  0009e	48 83 c0 02	 add	 rax, 2
  000a2	48 89 44 24 68	 mov	 QWORD PTR dirptr$[rsp], rax

; 2448 :     dirrem -= 2;

  000a7	8b 44 24 50	 mov	 eax, DWORD PTR dirrem$[rsp]
  000ab	83 e8 02	 sub	 eax, 2
  000ae	89 44 24 50	 mov	 DWORD PTR dirrem$[rsp], eax
$LN2@update_dir:

; 2449 : 
; 2450 :     /* Process each directory entry */
; 2451 :     while (dirrem > 0)

  000b2	83 7c 24 50 00	 cmp	 DWORD PTR dirrem$[rsp], 0
  000b7	0f 8e 11 02 00
	00		 jle	 $LN3@update_dir

; 2452 :     {
; 2453 :         /* Point to next directory entry */
; 2454 :         dirent = (PDSDIR*)dirptr;

  000bd	48 8b 44 24 68	 mov	 rax, QWORD PTR dirptr$[rsp]
  000c2	48 89 44 24 58	 mov	 QWORD PTR dirent$[rsp], rax

; 2455 : 
; 2456 :         /* Test for end of directory */
; 2457 :         if (memcmp( dirent->pds2name, &CKD_ENDTRK, CKD_ENDTRK_SIZE ) == 0)

  000c7	48 8b 44 24 58	 mov	 rax, QWORD PTR dirent$[rsp]
  000cc	41 b8 08 00 00
	00		 mov	 r8d, 8
  000d2	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:CKD_ENDTRK
  000d9	48 8b c8	 mov	 rcx, rax
  000dc	e8 00 00 00 00	 call	 memcmp
  000e1	85 c0		 test	 eax, eax
  000e3	75 05		 jne	 SHORT $LN9@update_dir

; 2458 :             break;

  000e5	e9 e4 01 00 00	 jmp	 $LN3@update_dir
$LN9@update_dir:

; 2459 : 
; 2460 :         /* Extract the member name */
; 2461 :         make_asciiz (memname, sizeof(memname), dirent->pds2name, 8);

  000ea	48 8b 44 24 58	 mov	 rax, QWORD PTR dirent$[rsp]
  000ef	41 b9 08 00 00
	00		 mov	 r9d, 8
  000f5	4c 8b c0	 mov	 r8, rax
  000f8	ba 09 00 00 00	 mov	 edx, 9
  000fd	48 8d 8c 24 88
	00 00 00	 lea	 rcx, QWORD PTR memname$[rsp]
  00105	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_make_asciiz

; 2462 : 
; 2463 :         /* Replace the member TTR */
; 2464 :         rc = replace_ttr (memname, dirent->pds2ttrp, ttrtab, numttr);

  0010b	48 8b 44 24 58	 mov	 rax, QWORD PTR dirent$[rsp]
  00110	48 83 c0 08	 add	 rax, 8
  00114	44 8b 8c 24 e8
	00 00 00	 mov	 r9d, DWORD PTR numttr$[rsp]
  0011c	4c 8b 84 24 e0
	00 00 00	 mov	 r8, QWORD PTR ttrtab$[rsp]
  00124	48 8b d0	 mov	 rdx, rax
  00127	48 8d 8c 24 88
	00 00 00	 lea	 rcx, QWORD PTR memname$[rsp]
  0012f	e8 00 00 00 00	 call	 replace_ttr
  00134	89 44 24 54	 mov	 DWORD PTR rc$[rsp], eax

; 2465 :         if (rc < 0) return -1;

  00138	83 7c 24 54 00	 cmp	 DWORD PTR rc$[rsp], 0
  0013d	7d 0a		 jge	 SHORT $LN10@update_dir
  0013f	b8 ff ff ff ff	 mov	 eax, -1
  00144	e9 87 01 00 00	 jmp	 $LN1@update_dir
$LN10@update_dir:

; 2466 : 
; 2467 :         /* Load the number of user TTRs */
; 2468 :         n = (dirent->pds2indc & PDS2INDC_NTTR) >> PDS2INDC_NTTR_SHIFT;

  00149	48 8b 44 24 58	 mov	 rax, QWORD PTR dirent$[rsp]
  0014e	0f b6 40 0b	 movzx	 eax, BYTE PTR [rax+11]
  00152	83 e0 60	 and	 eax, 96			; 00000060H
  00155	c1 f8 05	 sar	 eax, 5
  00158	89 44 24 70	 mov	 DWORD PTR n$[rsp], eax

; 2469 : 
; 2470 :         /* Replace the user TTRs */
; 2471 :         ttrptr = dirent->pds2usrd;

  0015c	48 8b 44 24 58	 mov	 rax, QWORD PTR dirent$[rsp]
  00161	48 83 c0 0c	 add	 rax, 12
  00165	48 89 84 24 80
	00 00 00	 mov	 QWORD PTR ttrptr$[rsp], rax

; 2472 :         for (i = 0; i < n; i++)

  0016d	c7 44 24 60 00
	00 00 00	 mov	 DWORD PTR i$[rsp], 0
  00175	eb 0a		 jmp	 SHORT $LN6@update_dir
$LN4@update_dir:
  00177	8b 44 24 60	 mov	 eax, DWORD PTR i$[rsp]
  0017b	ff c0		 inc	 eax
  0017d	89 44 24 60	 mov	 DWORD PTR i$[rsp], eax
$LN6@update_dir:
  00181	8b 44 24 70	 mov	 eax, DWORD PTR n$[rsp]
  00185	39 44 24 60	 cmp	 DWORD PTR i$[rsp], eax
  00189	7d 50		 jge	 SHORT $LN5@update_dir

; 2473 :         {
; 2474 :             rc = replace_ttr (memname, ttrptr, ttrtab, numttr);

  0018b	44 8b 8c 24 e8
	00 00 00	 mov	 r9d, DWORD PTR numttr$[rsp]
  00193	4c 8b 84 24 e0
	00 00 00	 mov	 r8, QWORD PTR ttrtab$[rsp]
  0019b	48 8b 94 24 80
	00 00 00	 mov	 rdx, QWORD PTR ttrptr$[rsp]
  001a3	48 8d 8c 24 88
	00 00 00	 lea	 rcx, QWORD PTR memname$[rsp]
  001ab	e8 00 00 00 00	 call	 replace_ttr
  001b0	89 44 24 54	 mov	 DWORD PTR rc$[rsp], eax

; 2475 :             if (rc < 0) return -1;

  001b4	83 7c 24 54 00	 cmp	 DWORD PTR rc$[rsp], 0
  001b9	7d 0a		 jge	 SHORT $LN11@update_dir
  001bb	b8 ff ff ff ff	 mov	 eax, -1
  001c0	e9 0b 01 00 00	 jmp	 $LN1@update_dir
$LN11@update_dir:

; 2476 :             ttrptr += 4;

  001c5	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR ttrptr$[rsp]
  001cd	48 83 c0 04	 add	 rax, 4
  001d1	48 89 84 24 80
	00 00 00	 mov	 QWORD PTR ttrptr$[rsp], rax

; 2477 :         } /* end for(i) */

  001d9	eb 9c		 jmp	 SHORT $LN4@update_dir
$LN5@update_dir:

; 2478 : 
; 2479 :         /* Update the note list record if note list TTRs exist */
; 2480 :         if ((dirent->pds2indc & PDS2INDC_ALIAS) == 0
; 2481 :             && n >= 2 && dirent->pds2usrd[7] != 0)

  001db	48 8b 44 24 58	 mov	 rax, QWORD PTR dirent$[rsp]
  001e0	0f b6 40 0b	 movzx	 eax, BYTE PTR [rax+11]
  001e4	25 80 00 00 00	 and	 eax, 128		; 00000080H
  001e9	85 c0		 test	 eax, eax
  001eb	0f 85 97 00 00
	00		 jne	 $LN12@update_dir
  001f1	83 7c 24 70 02	 cmp	 DWORD PTR n$[rsp], 2
  001f6	0f 8c 8c 00 00
	00		 jl	 $LN12@update_dir
  001fc	b8 01 00 00 00	 mov	 eax, 1
  00201	48 6b c0 07	 imul	 rax, rax, 7
  00205	48 8b 4c 24 58	 mov	 rcx, QWORD PTR dirent$[rsp]
  0020a	0f b6 44 01 0c	 movzx	 eax, BYTE PTR [rcx+rax+12]
  0020f	85 c0		 test	 eax, eax
  00211	74 75		 je	 SHORT $LN12@update_dir

; 2482 :         {
; 2483 :             rc = update_note_list (cif, ofname, heads, trklen,

  00213	48 8b 44 24 58	 mov	 rax, QWORD PTR dirent$[rsp]
  00218	48 83 c0 10	 add	 rax, 16
  0021c	8b 8c 24 e8 00
	00 00		 mov	 ecx, DWORD PTR numttr$[rsp]
  00223	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  00227	48 8b 8c 24 e0
	00 00 00	 mov	 rcx, QWORD PTR ttrtab$[rsp]
  0022f	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  00234	48 89 44 24 30	 mov	 QWORD PTR [rsp+48], rax
  00239	48 8d 84 24 88
	00 00 00	 lea	 rax, QWORD PTR memname$[rsp]
  00241	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  00246	8b 84 24 d0 00
	00 00		 mov	 eax, DWORD PTR dsstart$[rsp]
  0024d	89 44 24 20	 mov	 DWORD PTR [rsp+32], eax
  00251	44 8b 8c 24 c8
	00 00 00	 mov	 r9d, DWORD PTR trklen$[rsp]
  00259	44 8b 84 24 c0
	00 00 00	 mov	 r8d, DWORD PTR heads$[rsp]
  00261	48 8b 94 24 b8
	00 00 00	 mov	 rdx, QWORD PTR ofname$[rsp]
  00269	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR cif$[rsp]
  00271	e8 00 00 00 00	 call	 update_note_list
  00276	89 44 24 54	 mov	 DWORD PTR rc$[rsp], eax

; 2484 :                                 dsstart, memname, dirent->pds2usrd+4,
; 2485 :                                 ttrtab, numttr);
; 2486 :             if (rc < 0) return -1;

  0027a	83 7c 24 54 00	 cmp	 DWORD PTR rc$[rsp], 0
  0027f	7d 07		 jge	 SHORT $LN13@update_dir
  00281	b8 ff ff ff ff	 mov	 eax, -1
  00286	eb 48		 jmp	 SHORT $LN1@update_dir
$LN13@update_dir:
$LN12@update_dir:

; 2487 :         }
; 2488 : 
; 2489 :         /* Load the user data halfword count */
; 2490 :         k = dirent->pds2indc & PDS2INDC_LUSR;

  00288	48 8b 44 24 58	 mov	 rax, QWORD PTR dirent$[rsp]
  0028d	0f b6 40 0b	 movzx	 eax, BYTE PTR [rax+11]
  00291	83 e0 1f	 and	 eax, 31
  00294	89 44 24 78	 mov	 DWORD PTR k$[rsp], eax

; 2491 : 
; 2492 :         /* Point to next directory entry */
; 2493 :         size = 12 + k*2;

  00298	8b 44 24 78	 mov	 eax, DWORD PTR k$[rsp]
  0029c	8d 44 00 0c	 lea	 eax, DWORD PTR [rax+rax+12]
  002a0	89 44 24 74	 mov	 DWORD PTR size$[rsp], eax

; 2494 :         dirptr += size;

  002a4	48 63 44 24 74	 movsxd	 rax, DWORD PTR size$[rsp]
  002a9	48 8b 4c 24 68	 mov	 rcx, QWORD PTR dirptr$[rsp]
  002ae	48 03 c8	 add	 rcx, rax
  002b1	48 8b c1	 mov	 rax, rcx
  002b4	48 89 44 24 68	 mov	 QWORD PTR dirptr$[rsp], rax

; 2495 :         dirrem -= size;

  002b9	8b 44 24 74	 mov	 eax, DWORD PTR size$[rsp]
  002bd	8b 4c 24 50	 mov	 ecx, DWORD PTR dirrem$[rsp]
  002c1	2b c8		 sub	 ecx, eax
  002c3	8b c1		 mov	 eax, ecx
  002c5	89 44 24 50	 mov	 DWORD PTR dirrem$[rsp], eax

; 2496 :     }

  002c9	e9 e4 fd ff ff	 jmp	 $LN2@update_dir
$LN3@update_dir:

; 2497 : 
; 2498 :     return 0;

  002ce	33 c0		 xor	 eax, eax
$LN1@update_dir:

; 2499 : } /* end function update_dirblk */

  002d0	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  002d8	48 33 cc	 xor	 rcx, rsp
  002db	e8 00 00 00 00	 call	 __security_check_cookie
  002e0	48 81 c4 a8 00
	00 00		 add	 rsp, 168		; 000000a8H
  002e7	c3		 ret	 0
update_dirblk ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\dasdload64.c
_TEXT	SEGMENT
head$ = 96
cyl$ = 100
offset$ = 104
rec$ = 108
rc$ = 112
dlen$ = 116
trk$ = 120
numnl$ = 124
i$ = 128
nllen$ = 132
curhead$ = 136
curcyl$ = 140
klen$ = 144
skiplen$ = 148
ttrptr$ = 152
trkhdr$ = 160
rechdr$ = 168
notelist$ = 176
__$ArrayPad$ = 1200
cif$ = 1248
ofname$ = 1256
heads$ = 1264
trklen$ = 1272
dsstart$ = 1280
memname$ = 1288
ttrn$ = 1296
ttrtab$ = 1304
numttr$ = 1312
update_note_list PROC

; 2270 : {

  00000	44 89 4c 24 20	 mov	 DWORD PTR [rsp+32], r9d
  00005	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	56		 push	 rsi
  00015	57		 push	 rdi
  00016	48 81 ec c8 04
	00 00		 sub	 rsp, 1224		; 000004c8H
  0001d	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00024	48 33 c4	 xor	 rax, rsp
  00027	48 89 84 24 b0
	04 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax
$LN4@update_not:

; 2271 : int             rc;                     /* Return code               */
; 2272 : int             i;                      /* Loop counter              */
; 2273 : int             trk;                    /* Relative track number     */
; 2274 : int             cyl;                    /* Cylinder number           */
; 2275 : int             head;                   /* Head number               */
; 2276 : int             rec;                    /* Record number             */
; 2277 : int             klen;                   /* Record key length         */
; 2278 : int             dlen;                   /* Record data length        */
; 2279 : int             numnl;                  /* Number of note list TTRs  */
; 2280 : int             nllen;                  /* Note list length          */
; 2281 : BYTE           *ttrptr;                 /* -> Note list TTR          */
; 2282 : int             curcyl;                 /* Current cylinder          */
; 2283 : int             curhead;                /* Current head              */
; 2284 : int             offset;                 /* Offset into track buffer  */
; 2285 : int             skiplen;                /* Number of bytes to skip   */
; 2286 : CKD_TRKHDR      trkhdr;                 /* Track header              */
; 2287 : CKD_RECHDR      rechdr;                 /* Record header             */
; 2288 : BYTE            notelist[1024];         /* Note list                 */
; 2289 : 
; 2290 :     UNREFERENCED(trklen);

  0002f	33 c0		 xor	 eax, eax
  00031	85 c0		 test	 eax, eax
  00033	75 fa		 jne	 SHORT $LN4@update_not

; 2291 : 
; 2292 :     /* Load the TTR of the note list record */
; 2293 :     trk = (ttrn[0] << 8) | ttrn[1];

  00035	b8 01 00 00 00	 mov	 eax, 1
  0003a	48 6b c0 00	 imul	 rax, rax, 0
  0003e	48 8b 8c 24 10
	05 00 00	 mov	 rcx, QWORD PTR ttrn$[rsp]
  00046	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  0004a	c1 e0 08	 shl	 eax, 8
  0004d	b9 01 00 00 00	 mov	 ecx, 1
  00052	48 6b c9 01	 imul	 rcx, rcx, 1
  00056	48 8b 94 24 10
	05 00 00	 mov	 rdx, QWORD PTR ttrn$[rsp]
  0005e	0f b6 0c 0a	 movzx	 ecx, BYTE PTR [rdx+rcx]
  00062	0b c1		 or	 eax, ecx
  00064	89 44 24 78	 mov	 DWORD PTR trk$[rsp], eax

; 2294 :     rec = ttrn[2];

  00068	b8 01 00 00 00	 mov	 eax, 1
  0006d	48 6b c0 02	 imul	 rax, rax, 2
  00071	48 8b 8c 24 10
	05 00 00	 mov	 rcx, QWORD PTR ttrn$[rsp]
  00079	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  0007d	89 44 24 6c	 mov	 DWORD PTR rec$[rsp], eax

; 2295 : 
; 2296 :     /* Load number of note list TTRs and calculate note list length */
; 2297 :     numnl = ttrn[3];

  00081	b8 01 00 00 00	 mov	 eax, 1
  00086	48 6b c0 03	 imul	 rax, rax, 3
  0008a	48 8b 8c 24 10
	05 00 00	 mov	 rcx, QWORD PTR ttrn$[rsp]
  00092	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00096	89 44 24 7c	 mov	 DWORD PTR numnl$[rsp], eax

; 2298 :     nllen = numnl * 4;

  0009a	8b 44 24 7c	 mov	 eax, DWORD PTR numnl$[rsp]
  0009e	c1 e0 02	 shl	 eax, 2
  000a1	89 84 24 84 00
	00 00		 mov	 DWORD PTR nllen$[rsp], eax

; 2299 : 
; 2300 :     /* Calculate the CCHHR of the note list record */
; 2301 :     cyl = (dsstart + trk) / heads;

  000a8	8b 44 24 78	 mov	 eax, DWORD PTR trk$[rsp]
  000ac	8b 8c 24 00 05
	00 00		 mov	 ecx, DWORD PTR dsstart$[rsp]
  000b3	03 c8		 add	 ecx, eax
  000b5	8b c1		 mov	 eax, ecx
  000b7	99		 cdq
  000b8	f7 bc 24 f0 04
	00 00		 idiv	 DWORD PTR heads$[rsp]
  000bf	89 44 24 64	 mov	 DWORD PTR cyl$[rsp], eax

; 2302 :     head = (dsstart + trk) % heads;

  000c3	8b 44 24 78	 mov	 eax, DWORD PTR trk$[rsp]
  000c7	8b 8c 24 00 05
	00 00		 mov	 ecx, DWORD PTR dsstart$[rsp]
  000ce	03 c8		 add	 ecx, eax
  000d0	8b c1		 mov	 eax, ecx
  000d2	99		 cdq
  000d3	f7 bc 24 f0 04
	00 00		 idiv	 DWORD PTR heads$[rsp]
  000da	8b c2		 mov	 eax, edx
  000dc	89 44 24 60	 mov	 DWORD PTR head$[rsp], eax

; 2303 : 
; 2304 :     XMINFF (4, MSG( HHC02558, "I", memname, trk, rec, cyl, head, rec ) );

  000e0	8b 44 24 6c	 mov	 eax, DWORD PTR rec$[rsp]
  000e4	89 44 24 40	 mov	 DWORD PTR [rsp+64], eax
  000e8	8b 44 24 60	 mov	 eax, DWORD PTR head$[rsp]
  000ec	89 44 24 38	 mov	 DWORD PTR [rsp+56], eax
  000f0	8b 44 24 64	 mov	 eax, DWORD PTR cyl$[rsp]
  000f4	89 44 24 30	 mov	 DWORD PTR [rsp+48], eax
  000f8	8b 44 24 6c	 mov	 eax, DWORD PTR rec$[rsp]
  000fc	89 44 24 28	 mov	 DWORD PTR [rsp+40], eax
  00100	8b 44 24 78	 mov	 eax, DWORD PTR trk$[rsp]
  00104	89 44 24 20	 mov	 DWORD PTR [rsp+32], eax
  00108	4c 8b 8c 24 08
	05 00 00	 mov	 r9, QWORD PTR memname$[rsp]
  00110	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG161688
  00117	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG161689
  0011e	b9 04 00 00 00	 mov	 ecx, 4
  00123	e8 00 00 00 00	 call	 info_msg

; 2305 : 
; 2306 :     /* Save the current position in the output file */
; 2307 :     curcyl = cif->curcyl;

  00128	48 8b 84 24 e0
	04 00 00	 mov	 rax, QWORD PTR cif$[rsp]
  00130	8b 40 18	 mov	 eax, DWORD PTR [rax+24]
  00133	89 84 24 8c 00
	00 00		 mov	 DWORD PTR curcyl$[rsp], eax

; 2308 :     curhead = cif->curhead;

  0013a	48 8b 84 24 e0
	04 00 00	 mov	 rax, QWORD PTR cif$[rsp]
  00142	8b 40 1c	 mov	 eax, DWORD PTR [rax+28]
  00145	89 84 24 88 00
	00 00		 mov	 DWORD PTR curhead$[rsp], eax

; 2309 : 
; 2310 :     /* Seek to start of track header */
; 2311 :     rc = read_track( cif, cyl, (U8) head );

  0014c	44 0f b6 44 24
	60		 movzx	 r8d, BYTE PTR head$[rsp]
  00152	8b 54 24 64	 mov	 edx, DWORD PTR cyl$[rsp]
  00156	48 8b 8c 24 e0
	04 00 00	 mov	 rcx, QWORD PTR cif$[rsp]
  0015e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_read_track
  00164	89 44 24 70	 mov	 DWORD PTR rc$[rsp], eax

; 2312 :     if (rc < 0)

  00168	83 7c 24 70 00	 cmp	 DWORD PTR rc$[rsp], 0
  0016d	7d 42		 jge	 SHORT $LN10@update_not

; 2313 :     {
; 2314 :         XMERRF ( MSG( HHC02547, "E", ofname, cyl, cyl, head, head ) );

  0016f	8b 44 24 60	 mov	 eax, DWORD PTR head$[rsp]
  00173	89 44 24 30	 mov	 DWORD PTR [rsp+48], eax
  00177	8b 44 24 60	 mov	 eax, DWORD PTR head$[rsp]
  0017b	89 44 24 28	 mov	 DWORD PTR [rsp+40], eax
  0017f	8b 44 24 64	 mov	 eax, DWORD PTR cyl$[rsp]
  00183	89 44 24 20	 mov	 DWORD PTR [rsp+32], eax
  00187	44 8b 4c 24 64	 mov	 r9d, DWORD PTR cyl$[rsp]
  0018c	4c 8b 84 24 e8
	04 00 00	 mov	 r8, QWORD PTR ofname$[rsp]
  00194	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG161691
  0019b	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG161692
  001a2	e8 00 00 00 00	 call	 printf

; 2315 :         return -1;

  001a7	b8 ff ff ff ff	 mov	 eax, -1
  001ac	e9 7b 04 00 00	 jmp	 $LN1@update_not
$LN10@update_not:

; 2316 :     }
; 2317 : 
; 2318 :     /* Copy the track header */
; 2319 :     memcpy (&trkhdr, cif->trkbuf, CKD_TRKHDR_SIZE);

  001b1	48 8b 84 24 e0
	04 00 00	 mov	 rax, QWORD PTR cif$[rsp]
  001b9	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  001bd	48 8d 8c 24 a0
	00 00 00	 lea	 rcx, QWORD PTR trkhdr$[rsp]
  001c5	48 8b f9	 mov	 rdi, rcx
  001c8	48 8b f0	 mov	 rsi, rax
  001cb	b9 05 00 00 00	 mov	 ecx, 5
  001d0	f3 a4		 rep movsb

; 2320 :     offset = CKD_TRKHDR_SIZE;

  001d2	c7 44 24 68 05
	00 00 00	 mov	 DWORD PTR offset$[rsp], 5

; 2321 : 
; 2322 :     /* Validate the track header */
; 2323 :     if (0
; 2324 :         ||           trkhdr.bin    != 0
; 2325 :         || fetch_hw( trkhdr.cyl  ) != cyl
; 2326 :         || fetch_hw( trkhdr.head ) != head

  001da	33 c0		 xor	 eax, eax
  001dc	85 c0		 test	 eax, eax
  001de	75 4c		 jne	 SHORT $LN12@update_not
  001e0	0f b6 84 24 a0
	00 00 00	 movzx	 eax, BYTE PTR trkhdr$[rsp]
  001e8	85 c0		 test	 eax, eax
  001ea	75 40		 jne	 SHORT $LN12@update_not
  001ec	48 8d 8c 24 a1
	00 00 00	 lea	 rcx, QWORD PTR trkhdr$[rsp+1]
  001f4	e8 00 00 00 00	 call	 fetch_hw_noswap
  001f9	0f b7 c8	 movzx	 ecx, ax
  001fc	e8 00 00 00 00	 call	 _byteswap_ushort
  00201	0f b7 c0	 movzx	 eax, ax
  00204	3b 44 24 64	 cmp	 eax, DWORD PTR cyl$[rsp]
  00208	75 22		 jne	 SHORT $LN12@update_not
  0020a	48 8d 8c 24 a3
	00 00 00	 lea	 rcx, QWORD PTR trkhdr$[rsp+3]
  00212	e8 00 00 00 00	 call	 fetch_hw_noswap
  00217	0f b7 c8	 movzx	 ecx, ax
  0021a	e8 00 00 00 00	 call	 _byteswap_ushort
  0021f	0f b7 c0	 movzx	 eax, ax
  00222	3b 44 24 60	 cmp	 eax, DWORD PTR head$[rsp]
  00226	0f 84 a2 00 00
	00		 je	 $LN11@update_not
$LN12@update_not:

; 2327 :     )
; 2328 :     {
; 2329 :         XMERRF ( MSG( HHC02548, "E", ofname, cyl, cyl, head, head,

  0022c	b8 01 00 00 00	 mov	 eax, 1
  00231	48 6b c0 01	 imul	 rax, rax, 1
  00235	0f b6 84 04 a3
	00 00 00	 movzx	 eax, BYTE PTR trkhdr$[rsp+rax+3]
  0023d	b9 01 00 00 00	 mov	 ecx, 1
  00242	48 6b c9 00	 imul	 rcx, rcx, 0
  00246	0f b6 8c 0c a3
	00 00 00	 movzx	 ecx, BYTE PTR trkhdr$[rsp+rcx+3]
  0024e	ba 01 00 00 00	 mov	 edx, 1
  00253	48 6b d2 01	 imul	 rdx, rdx, 1
  00257	0f b6 94 14 a1
	00 00 00	 movzx	 edx, BYTE PTR trkhdr$[rsp+rdx+1]
  0025f	bf 01 00 00 00	 mov	 edi, 1
  00264	48 6b ff 00	 imul	 rdi, rdi, 0
  00268	0f b6 bc 3c a1
	00 00 00	 movzx	 edi, BYTE PTR trkhdr$[rsp+rdi+1]
  00270	0f b6 b4 24 a0
	00 00 00	 movzx	 esi, BYTE PTR trkhdr$[rsp]
  00278	89 44 24 58	 mov	 DWORD PTR [rsp+88], eax
  0027c	89 4c 24 50	 mov	 DWORD PTR [rsp+80], ecx
  00280	89 54 24 48	 mov	 DWORD PTR [rsp+72], edx
  00284	89 7c 24 40	 mov	 DWORD PTR [rsp+64], edi
  00288	89 74 24 38	 mov	 DWORD PTR [rsp+56], esi
  0028c	8b 44 24 60	 mov	 eax, DWORD PTR head$[rsp]
  00290	89 44 24 30	 mov	 DWORD PTR [rsp+48], eax
  00294	8b 44 24 60	 mov	 eax, DWORD PTR head$[rsp]
  00298	89 44 24 28	 mov	 DWORD PTR [rsp+40], eax
  0029c	8b 44 24 64	 mov	 eax, DWORD PTR cyl$[rsp]
  002a0	89 44 24 20	 mov	 DWORD PTR [rsp+32], eax
  002a4	44 8b 4c 24 64	 mov	 r9d, DWORD PTR cyl$[rsp]
  002a9	4c 8b 84 24 e8
	04 00 00	 mov	 r8, QWORD PTR ofname$[rsp]
  002b1	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG161695
  002b8	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG161696
  002bf	e8 00 00 00 00	 call	 printf

; 2330 :                                      trkhdr.bin, trkhdr.cyl[0], trkhdr.cyl[1],
; 2331 :                                      trkhdr.head[0], trkhdr.head[1] ) );
; 2332 :         return -1;

  002c4	b8 ff ff ff ff	 mov	 eax, -1
  002c9	e9 5e 03 00 00	 jmp	 $LN1@update_not
$LN11@update_not:
$LN5@update_not:

; 2333 :     }
; 2334 : 
; 2335 :     /* Search for the note list record */
; 2336 :     while (1)

  002ce	33 c0		 xor	 eax, eax
  002d0	83 f8 01	 cmp	 eax, 1
  002d3	0f 84 12 01 00
	00		 je	 $LN6@update_not

; 2337 :     {
; 2338 :         /* Copy the next record header */
; 2339 :         memcpy (&rechdr, cif->trkbuf + offset, CKD_RECHDR_SIZE);

  002d9	48 63 44 24 68	 movsxd	 rax, DWORD PTR offset$[rsp]
  002de	48 8b 8c 24 e0
	04 00 00	 mov	 rcx, QWORD PTR cif$[rsp]
  002e6	48 8b 49 10	 mov	 rcx, QWORD PTR [rcx+16]
  002ea	48 8b 04 01	 mov	 rax, QWORD PTR [rcx+rax]
  002ee	48 89 84 24 a8
	00 00 00	 mov	 QWORD PTR rechdr$[rsp], rax

; 2340 :         offset += CKD_RECHDR_SIZE;

  002f6	48 63 44 24 68	 movsxd	 rax, DWORD PTR offset$[rsp]
  002fb	48 83 c0 08	 add	 rax, 8
  002ff	89 44 24 68	 mov	 DWORD PTR offset$[rsp], eax

; 2341 : 
; 2342 :         /* Check for end of track */
; 2343 :         if (memcmp( &rechdr, &CKD_ENDTRK, CKD_ENDTRK_SIZE ) == 0)

  00303	41 b8 08 00 00
	00		 mov	 r8d, 8
  00309	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:CKD_ENDTRK
  00310	48 8d 8c 24 a8
	00 00 00	 lea	 rcx, QWORD PTR rechdr$[rsp]
  00318	e8 00 00 00 00	 call	 memcmp
  0031d	85 c0		 test	 eax, eax
  0031f	75 52		 jne	 SHORT $LN13@update_not

; 2344 :         {
; 2345 :             XMERRF ( MSG( HHC02549, "E", ofname, cyl, cyl, head, head, rec, rec ) );

  00321	8b 44 24 6c	 mov	 eax, DWORD PTR rec$[rsp]
  00325	89 44 24 40	 mov	 DWORD PTR [rsp+64], eax
  00329	8b 44 24 6c	 mov	 eax, DWORD PTR rec$[rsp]
  0032d	89 44 24 38	 mov	 DWORD PTR [rsp+56], eax
  00331	8b 44 24 60	 mov	 eax, DWORD PTR head$[rsp]
  00335	89 44 24 30	 mov	 DWORD PTR [rsp+48], eax
  00339	8b 44 24 60	 mov	 eax, DWORD PTR head$[rsp]
  0033d	89 44 24 28	 mov	 DWORD PTR [rsp+40], eax
  00341	8b 44 24 64	 mov	 eax, DWORD PTR cyl$[rsp]
  00345	89 44 24 20	 mov	 DWORD PTR [rsp+32], eax
  00349	44 8b 4c 24 64	 mov	 r9d, DWORD PTR cyl$[rsp]
  0034e	4c 8b 84 24 e8
	04 00 00	 mov	 r8, QWORD PTR ofname$[rsp]
  00356	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG161698
  0035d	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG161699
  00364	e8 00 00 00 00	 call	 printf

; 2346 :             return -1;

  00369	b8 ff ff ff ff	 mov	 eax, -1
  0036e	e9 b9 02 00 00	 jmp	 $LN1@update_not
$LN13@update_not:

; 2347 :         }
; 2348 : 
; 2349 :         /* Extract record key length and data length */
; 2350 :         klen = rechdr.klen;

  00373	0f b6 84 24 ad
	00 00 00	 movzx	 eax, BYTE PTR rechdr$[rsp+5]
  0037b	89 84 24 90 00
	00 00		 mov	 DWORD PTR klen$[rsp], eax

; 2351 :         dlen = (rechdr.dlen[0] << 8) | rechdr.dlen[1];

  00382	b8 01 00 00 00	 mov	 eax, 1
  00387	48 6b c0 00	 imul	 rax, rax, 0
  0038b	0f b6 84 04 ae
	00 00 00	 movzx	 eax, BYTE PTR rechdr$[rsp+rax+6]
  00393	c1 e0 08	 shl	 eax, 8
  00396	b9 01 00 00 00	 mov	 ecx, 1
  0039b	48 6b c9 01	 imul	 rcx, rcx, 1
  0039f	0f b6 8c 0c ae
	00 00 00	 movzx	 ecx, BYTE PTR rechdr$[rsp+rcx+6]
  003a7	0b c1		 or	 eax, ecx
  003a9	89 44 24 74	 mov	 DWORD PTR dlen$[rsp], eax

; 2352 : 
; 2353 :         /* Exit loop if matching record number */
; 2354 :         if (rechdr.rec == rec)

  003ad	0f b6 84 24 ac
	00 00 00	 movzx	 eax, BYTE PTR rechdr$[rsp+4]
  003b5	3b 44 24 6c	 cmp	 eax, DWORD PTR rec$[rsp]
  003b9	75 02		 jne	 SHORT $LN14@update_not

; 2355 :             break;

  003bb	eb 2e		 jmp	 SHORT $LN6@update_not
$LN14@update_not:

; 2356 : 
; 2357 :         /* Skip the key and data areas */
; 2358 :         skiplen = klen + dlen;

  003bd	8b 44 24 74	 mov	 eax, DWORD PTR dlen$[rsp]
  003c1	8b 8c 24 90 00
	00 00		 mov	 ecx, DWORD PTR klen$[rsp]
  003c8	03 c8		 add	 ecx, eax
  003ca	8b c1		 mov	 eax, ecx
  003cc	89 84 24 94 00
	00 00		 mov	 DWORD PTR skiplen$[rsp], eax

; 2359 :         offset += skiplen;

  003d3	8b 84 24 94 00
	00 00		 mov	 eax, DWORD PTR skiplen$[rsp]
  003da	8b 4c 24 68	 mov	 ecx, DWORD PTR offset$[rsp]
  003de	03 c8		 add	 ecx, eax
  003e0	8b c1		 mov	 eax, ecx
  003e2	89 44 24 68	 mov	 DWORD PTR offset$[rsp], eax

; 2360 :     } /* end while */

  003e6	e9 e3 fe ff ff	 jmp	 $LN5@update_not
$LN6@update_not:

; 2361 : 
; 2362 :     /* Check that the data length is sufficient */
; 2363 :     if (dlen < nllen)

  003eb	8b 84 24 84 00
	00 00		 mov	 eax, DWORD PTR nllen$[rsp]
  003f2	39 44 24 74	 cmp	 DWORD PTR dlen$[rsp], eax
  003f6	7d 62		 jge	 SHORT $LN15@update_not

; 2364 :     {
; 2365 :         XMERRF ( MSG( HHC02559, "E", memname, cyl, cyl, head, head, rec, rec, dlen, numnl ) );

  003f8	8b 44 24 7c	 mov	 eax, DWORD PTR numnl$[rsp]
  003fc	89 44 24 50	 mov	 DWORD PTR [rsp+80], eax
  00400	8b 44 24 74	 mov	 eax, DWORD PTR dlen$[rsp]
  00404	89 44 24 48	 mov	 DWORD PTR [rsp+72], eax
  00408	8b 44 24 6c	 mov	 eax, DWORD PTR rec$[rsp]
  0040c	89 44 24 40	 mov	 DWORD PTR [rsp+64], eax
  00410	8b 44 24 6c	 mov	 eax, DWORD PTR rec$[rsp]
  00414	89 44 24 38	 mov	 DWORD PTR [rsp+56], eax
  00418	8b 44 24 60	 mov	 eax, DWORD PTR head$[rsp]
  0041c	89 44 24 30	 mov	 DWORD PTR [rsp+48], eax
  00420	8b 44 24 60	 mov	 eax, DWORD PTR head$[rsp]
  00424	89 44 24 28	 mov	 DWORD PTR [rsp+40], eax
  00428	8b 44 24 64	 mov	 eax, DWORD PTR cyl$[rsp]
  0042c	89 44 24 20	 mov	 DWORD PTR [rsp+32], eax
  00430	44 8b 4c 24 64	 mov	 r9d, DWORD PTR cyl$[rsp]
  00435	4c 8b 84 24 08
	05 00 00	 mov	 r8, QWORD PTR memname$[rsp]
  0043d	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG161702
  00444	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG161703
  0044b	e8 00 00 00 00	 call	 printf

; 2366 :         return -1;

  00450	b8 ff ff ff ff	 mov	 eax, -1
  00455	e9 d2 01 00 00	 jmp	 $LN1@update_not
$LN15@update_not:

; 2367 :     }
; 2368 : 
; 2369 :     /* Skip the key area if present */
; 2370 :     offset += klen;

  0045a	8b 84 24 90 00
	00 00		 mov	 eax, DWORD PTR klen$[rsp]
  00461	8b 4c 24 68	 mov	 ecx, DWORD PTR offset$[rsp]
  00465	03 c8		 add	 ecx, eax
  00467	8b c1		 mov	 eax, ecx
  00469	89 44 24 68	 mov	 DWORD PTR offset$[rsp], eax

; 2371 : 
; 2372 :     /* Copy the note list from the data area */
; 2373 :     memcpy (&notelist, cif->trkbuf + offset, nllen);

  0046d	48 63 84 24 84
	00 00 00	 movsxd	 rax, DWORD PTR nllen$[rsp]
  00475	48 63 4c 24 68	 movsxd	 rcx, DWORD PTR offset$[rsp]
  0047a	48 8b 94 24 e0
	04 00 00	 mov	 rdx, QWORD PTR cif$[rsp]
  00482	48 03 4a 10	 add	 rcx, QWORD PTR [rdx+16]
  00486	48 8d 94 24 b0
	00 00 00	 lea	 rdx, QWORD PTR notelist$[rsp]
  0048e	48 8b fa	 mov	 rdi, rdx
  00491	48 8b f1	 mov	 rsi, rcx
  00494	48 8b c8	 mov	 rcx, rax
  00497	f3 a4		 rep movsb

; 2374 : 
; 2375 :     /* Replace the TTRs in the note list record */
; 2376 :     ttrptr = notelist;

  00499	48 8d 84 24 b0
	00 00 00	 lea	 rax, QWORD PTR notelist$[rsp]
  004a1	48 89 84 24 98
	00 00 00	 mov	 QWORD PTR ttrptr$[rsp], rax

; 2377 :     for (i = 0; i < numnl; i++)

  004a9	c7 84 24 80 00
	00 00 00 00 00
	00		 mov	 DWORD PTR i$[rsp], 0
  004b4	eb 10		 jmp	 SHORT $LN9@update_not
$LN7@update_not:
  004b6	8b 84 24 80 00
	00 00		 mov	 eax, DWORD PTR i$[rsp]
  004bd	ff c0		 inc	 eax
  004bf	89 84 24 80 00
	00 00		 mov	 DWORD PTR i$[rsp], eax
$LN9@update_not:
  004c6	8b 44 24 7c	 mov	 eax, DWORD PTR numnl$[rsp]
  004ca	39 84 24 80 00
	00 00		 cmp	 DWORD PTR i$[rsp], eax
  004d1	7d 50		 jge	 SHORT $LN8@update_not

; 2378 :     {
; 2379 :         rc = replace_ttr (memname, ttrptr, ttrtab, numttr);

  004d3	44 8b 8c 24 20
	05 00 00	 mov	 r9d, DWORD PTR numttr$[rsp]
  004db	4c 8b 84 24 18
	05 00 00	 mov	 r8, QWORD PTR ttrtab$[rsp]
  004e3	48 8b 94 24 98
	00 00 00	 mov	 rdx, QWORD PTR ttrptr$[rsp]
  004eb	48 8b 8c 24 08
	05 00 00	 mov	 rcx, QWORD PTR memname$[rsp]
  004f3	e8 00 00 00 00	 call	 replace_ttr
  004f8	89 44 24 70	 mov	 DWORD PTR rc$[rsp], eax

; 2380 :         if (rc < 0) return -1;

  004fc	83 7c 24 70 00	 cmp	 DWORD PTR rc$[rsp], 0
  00501	7d 0a		 jge	 SHORT $LN16@update_not
  00503	b8 ff ff ff ff	 mov	 eax, -1
  00508	e9 1f 01 00 00	 jmp	 $LN1@update_not
$LN16@update_not:

; 2381 :         ttrptr += 4;

  0050d	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR ttrptr$[rsp]
  00515	48 83 c0 04	 add	 rax, 4
  00519	48 89 84 24 98
	00 00 00	 mov	 QWORD PTR ttrptr$[rsp], rax

; 2382 :     } /* end for(i) */

  00521	eb 93		 jmp	 SHORT $LN7@update_not
$LN8@update_not:

; 2383 : 
; 2384 :     /* Copy the updated note list to the buffer */
; 2385 :     memcpy (cif->trkbuf + offset, &notelist, nllen);

  00523	48 63 84 24 84
	00 00 00	 movsxd	 rax, DWORD PTR nllen$[rsp]
  0052b	48 63 4c 24 68	 movsxd	 rcx, DWORD PTR offset$[rsp]
  00530	48 8b 94 24 e0
	04 00 00	 mov	 rdx, QWORD PTR cif$[rsp]
  00538	48 03 4a 10	 add	 rcx, QWORD PTR [rdx+16]
  0053c	48 8d 94 24 b0
	00 00 00	 lea	 rdx, QWORD PTR notelist$[rsp]
  00544	48 8b f9	 mov	 rdi, rcx
  00547	48 8b f2	 mov	 rsi, rdx
  0054a	48 8b c8	 mov	 rcx, rax
  0054d	f3 a4		 rep movsb

; 2386 :     cif->trkmodif = 1;

  0054f	48 8b 84 24 e0
	04 00 00	 mov	 rax, QWORD PTR cif$[rsp]
  00557	c7 40 20 01 00
	00 00		 mov	 DWORD PTR [rax+32], 1

; 2387 : 
; 2388 :     /* Restore original file position */
; 2389 :     rc = read_track( cif, curcyl, (U8) curhead );

  0055e	44 0f b6 84 24
	88 00 00 00	 movzx	 r8d, BYTE PTR curhead$[rsp]
  00567	8b 94 24 8c 00
	00 00		 mov	 edx, DWORD PTR curcyl$[rsp]
  0056e	48 8b 8c 24 e0
	04 00 00	 mov	 rcx, QWORD PTR cif$[rsp]
  00576	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_read_track
  0057c	89 44 24 70	 mov	 DWORD PTR rc$[rsp], eax

; 2390 :     if (rc < 0)

  00580	83 7c 24 70 00	 cmp	 DWORD PTR rc$[rsp], 0
  00585	7d 4b		 jge	 SHORT $LN17@update_not

; 2391 :     {
; 2392 :         XMERRF ( MSG( HHC02547, "E", ofname, curcyl, curcyl, curhead, curhead ) );

  00587	8b 84 24 88 00
	00 00		 mov	 eax, DWORD PTR curhead$[rsp]
  0058e	89 44 24 30	 mov	 DWORD PTR [rsp+48], eax
  00592	8b 84 24 88 00
	00 00		 mov	 eax, DWORD PTR curhead$[rsp]
  00599	89 44 24 28	 mov	 DWORD PTR [rsp+40], eax
  0059d	8b 84 24 8c 00
	00 00		 mov	 eax, DWORD PTR curcyl$[rsp]
  005a4	89 44 24 20	 mov	 DWORD PTR [rsp+32], eax
  005a8	44 8b 8c 24 8c
	00 00 00	 mov	 r9d, DWORD PTR curcyl$[rsp]
  005b0	4c 8b 84 24 e8
	04 00 00	 mov	 r8, QWORD PTR ofname$[rsp]
  005b8	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG161706
  005bf	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG161707
  005c6	e8 00 00 00 00	 call	 printf

; 2393 :         return -1;

  005cb	b8 ff ff ff ff	 mov	 eax, -1
  005d0	eb 5a		 jmp	 SHORT $LN1@update_not
$LN17@update_not:

; 2394 :     }
; 2395 : 
; 2396 :     XMINFF (4, MSG( HHC02523, "I", cyl, cyl, head, head, rec, rec, klen, dlen ) );

  005d2	8b 44 24 74	 mov	 eax, DWORD PTR dlen$[rsp]
  005d6	89 44 24 50	 mov	 DWORD PTR [rsp+80], eax
  005da	8b 84 24 90 00
	00 00		 mov	 eax, DWORD PTR klen$[rsp]
  005e1	89 44 24 48	 mov	 DWORD PTR [rsp+72], eax
  005e5	8b 44 24 6c	 mov	 eax, DWORD PTR rec$[rsp]
  005e9	89 44 24 40	 mov	 DWORD PTR [rsp+64], eax
  005ed	8b 44 24 6c	 mov	 eax, DWORD PTR rec$[rsp]
  005f1	89 44 24 38	 mov	 DWORD PTR [rsp+56], eax
  005f5	8b 44 24 60	 mov	 eax, DWORD PTR head$[rsp]
  005f9	89 44 24 30	 mov	 DWORD PTR [rsp+48], eax
  005fd	8b 44 24 60	 mov	 eax, DWORD PTR head$[rsp]
  00601	89 44 24 28	 mov	 DWORD PTR [rsp+40], eax
  00605	8b 44 24 64	 mov	 eax, DWORD PTR cyl$[rsp]
  00609	89 44 24 20	 mov	 DWORD PTR [rsp+32], eax
  0060d	44 8b 4c 24 64	 mov	 r9d, DWORD PTR cyl$[rsp]
  00612	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG161708
  00619	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG161709
  00620	b9 04 00 00 00	 mov	 ecx, 4
  00625	e8 00 00 00 00	 call	 info_msg

; 2397 : 
; 2398 :     return 0;

  0062a	33 c0		 xor	 eax, eax
$LN1@update_not:

; 2399 : } /* end function update_note_list */

  0062c	48 8b 8c 24 b0
	04 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  00634	48 33 cc	 xor	 rcx, rsp
  00637	e8 00 00 00 00	 call	 __security_check_cookie
  0063c	48 81 c4 c8 04
	00 00		 add	 rsp, 1224		; 000004c8H
  00643	5f		 pop	 rdi
  00644	5e		 pop	 rsi
  00645	c3		 ret	 0
update_note_list ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\dasdload64.c
_TEXT	SEGMENT
i$ = 80
memname$ = 128
ttrptr$ = 136
ttrtab$ = 144
numttr$ = 152
replace_ttr PROC

; 2226 : {

  00000	44 89 4c 24 20	 mov	 DWORD PTR [rsp+32], r9d
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	56		 push	 rsi
  00015	57		 push	 rdi
  00016	48 83 ec 68	 sub	 rsp, 104		; 00000068H

; 2227 : int             i;                      /* Array subscript           */
; 2228 : 
; 2229 :     /* Search for the TTR in the conversion table */
; 2230 :     for (i = 0; i < numttr; i++)

  0001a	c7 44 24 50 00
	00 00 00	 mov	 DWORD PTR i$[rsp], 0
  00022	eb 0a		 jmp	 SHORT $LN4@replace_tt
$LN2@replace_tt:
  00024	8b 44 24 50	 mov	 eax, DWORD PTR i$[rsp]
  00028	ff c0		 inc	 eax
  0002a	89 44 24 50	 mov	 DWORD PTR i$[rsp], eax
$LN4@replace_tt:
  0002e	8b 84 24 98 00
	00 00		 mov	 eax, DWORD PTR numttr$[rsp]
  00035	39 44 24 50	 cmp	 DWORD PTR i$[rsp], eax
  00039	0f 8d 54 01 00
	00		 jge	 $LN3@replace_tt

; 2231 :     {
; 2232 :         if (memcmp(ttrptr, ttrtab[i].origttr, 3) == 0)

  0003f	48 63 44 24 50	 movsxd	 rax, DWORD PTR i$[rsp]
  00044	48 6b c0 06	 imul	 rax, rax, 6
  00048	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR ttrtab$[rsp]
  00050	48 03 c8	 add	 rcx, rax
  00053	48 8b c1	 mov	 rax, rcx
  00056	41 b8 03 00 00
	00		 mov	 r8d, 3
  0005c	48 8b d0	 mov	 rdx, rax
  0005f	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR ttrptr$[rsp]
  00067	e8 00 00 00 00	 call	 memcmp
  0006c	85 c0		 test	 eax, eax
  0006e	0f 85 1a 01 00
	00		 jne	 $LN5@replace_tt

; 2233 :         {
; 2234 :             XMINFF (4, MSG( HHC02556, "I", memname, ttrptr[0], ttrptr[1], ttrptr[2],

  00074	48 63 44 24 50	 movsxd	 rax, DWORD PTR i$[rsp]
  00079	48 6b c0 06	 imul	 rax, rax, 6
  0007d	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR ttrtab$[rsp]
  00085	48 03 c8	 add	 rcx, rax
  00088	48 8b c1	 mov	 rax, rcx
  0008b	b9 01 00 00 00	 mov	 ecx, 1
  00090	48 6b c9 02	 imul	 rcx, rcx, 2
  00094	0f b6 44 08 03	 movzx	 eax, BYTE PTR [rax+rcx+3]
  00099	48 63 4c 24 50	 movsxd	 rcx, DWORD PTR i$[rsp]
  0009e	48 6b c9 06	 imul	 rcx, rcx, 6
  000a2	48 8b 94 24 90
	00 00 00	 mov	 rdx, QWORD PTR ttrtab$[rsp]
  000aa	48 03 d1	 add	 rdx, rcx
  000ad	48 8b ca	 mov	 rcx, rdx
  000b0	ba 01 00 00 00	 mov	 edx, 1
  000b5	48 6b d2 01	 imul	 rdx, rdx, 1
  000b9	0f b6 4c 11 03	 movzx	 ecx, BYTE PTR [rcx+rdx+3]
  000be	48 63 54 24 50	 movsxd	 rdx, DWORD PTR i$[rsp]
  000c3	48 6b d2 06	 imul	 rdx, rdx, 6
  000c7	4c 8b 84 24 90
	00 00 00	 mov	 r8, QWORD PTR ttrtab$[rsp]
  000cf	4c 03 c2	 add	 r8, rdx
  000d2	49 8b d0	 mov	 rdx, r8
  000d5	41 b8 01 00 00
	00		 mov	 r8d, 1
  000db	4d 6b c0 00	 imul	 r8, r8, 0
  000df	42 0f b6 54 02
	03		 movzx	 edx, BYTE PTR [rdx+r8+3]
  000e5	41 b8 01 00 00
	00		 mov	 r8d, 1
  000eb	4d 6b c0 02	 imul	 r8, r8, 2
  000ef	4c 8b 8c 24 88
	00 00 00	 mov	 r9, QWORD PTR ttrptr$[rsp]
  000f7	47 0f b6 04 01	 movzx	 r8d, BYTE PTR [r9+r8]
  000fc	41 b9 01 00 00
	00		 mov	 r9d, 1
  00102	4d 6b c9 01	 imul	 r9, r9, 1
  00106	4c 8b 94 24 88
	00 00 00	 mov	 r10, QWORD PTR ttrptr$[rsp]
  0010e	47 0f b6 0c 0a	 movzx	 r9d, BYTE PTR [r10+r9]
  00113	41 ba 01 00 00
	00		 mov	 r10d, 1
  00119	4d 6b d2 00	 imul	 r10, r10, 0
  0011d	4c 8b 9c 24 88
	00 00 00	 mov	 r11, QWORD PTR ttrptr$[rsp]
  00125	47 0f b6 14 13	 movzx	 r10d, BYTE PTR [r11+r10]
  0012a	89 44 24 48	 mov	 DWORD PTR [rsp+72], eax
  0012e	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  00132	89 54 24 38	 mov	 DWORD PTR [rsp+56], edx
  00136	44 89 44 24 30	 mov	 DWORD PTR [rsp+48], r8d
  0013b	44 89 4c 24 28	 mov	 DWORD PTR [rsp+40], r9d
  00140	44 89 54 24 20	 mov	 DWORD PTR [rsp+32], r10d
  00145	4c 8b 8c 24 80
	00 00 00	 mov	 r9, QWORD PTR memname$[rsp]
  0014d	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG161627
  00154	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG161628
  0015b	b9 04 00 00 00	 mov	 ecx, 4
  00160	e8 00 00 00 00	 call	 info_msg

; 2235 :                     ttrtab[i].outpttr[0], ttrtab[i].outpttr[1],
; 2236 :                     ttrtab[i].outpttr[2] ) );
; 2237 :             memcpy (ttrptr, ttrtab[i].outpttr, 3);

  00165	48 63 44 24 50	 movsxd	 rax, DWORD PTR i$[rsp]
  0016a	48 6b c0 06	 imul	 rax, rax, 6
  0016e	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR ttrtab$[rsp]
  00176	48 8b bc 24 88
	00 00 00	 mov	 rdi, QWORD PTR ttrptr$[rsp]
  0017e	48 8d 74 01 03	 lea	 rsi, QWORD PTR [rcx+rax+3]
  00183	b9 03 00 00 00	 mov	 ecx, 3
  00188	f3 a4		 rep movsb

; 2238 :             return 0;

  0018a	33 c0		 xor	 eax, eax
  0018c	eb 6f		 jmp	 SHORT $LN1@replace_tt
$LN5@replace_tt:

; 2239 :         }
; 2240 :     }

  0018e	e9 91 fe ff ff	 jmp	 $LN2@replace_tt
$LN3@replace_tt:

; 2241 : 
; 2242 :     /* Return error if TTR not found in conversion table */
; 2243 :     XMERRF ( MSG( HHC02557, "I", memname, ttrptr[0], ttrptr[1], ttrptr[2] ) );

  00193	b8 01 00 00 00	 mov	 eax, 1
  00198	48 6b c0 02	 imul	 rax, rax, 2
  0019c	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR ttrptr$[rsp]
  001a4	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  001a8	b9 01 00 00 00	 mov	 ecx, 1
  001ad	48 6b c9 01	 imul	 rcx, rcx, 1
  001b1	48 8b 94 24 88
	00 00 00	 mov	 rdx, QWORD PTR ttrptr$[rsp]
  001b9	0f b6 0c 0a	 movzx	 ecx, BYTE PTR [rdx+rcx]
  001bd	ba 01 00 00 00	 mov	 edx, 1
  001c2	48 6b d2 00	 imul	 rdx, rdx, 0
  001c6	48 8b bc 24 88
	00 00 00	 mov	 rdi, QWORD PTR ttrptr$[rsp]
  001ce	0f b6 14 17	 movzx	 edx, BYTE PTR [rdi+rdx]
  001d2	89 44 24 28	 mov	 DWORD PTR [rsp+40], eax
  001d6	89 4c 24 20	 mov	 DWORD PTR [rsp+32], ecx
  001da	44 8b ca	 mov	 r9d, edx
  001dd	4c 8b 84 24 80
	00 00 00	 mov	 r8, QWORD PTR memname$[rsp]
  001e5	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG161629
  001ec	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG161630
  001f3	e8 00 00 00 00	 call	 printf

; 2244 :     return -1;

  001f8	b8 ff ff ff ff	 mov	 eax, -1
$LN1@replace_tt:

; 2245 : 
; 2246 : } /* end function replace_ttr */

  001fd	48 83 c4 68	 add	 rsp, 104		; 00000068H
  00201	5f		 pop	 rdi
  00202	5e		 pop	 rsi
  00203	c3		 ret	 0
replace_ttr ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\dasdload64.c
_TEXT	SEGMENT
c$ = 64
i$ = 68
dirrem$ = 72
j$ = 76
dirent$ = 80
k$ = 88
dirptr$ = 96
blkp$ = 104
size$ = 112
tv199 = 120
chars$ = 128
hex$ = 160
memname$ = 216
__$ArrayPad$ = 232
xbuf$ = 272
blklen$ = 280
cyl$ = 288
head$ = 296
rec$ = 304
dirblka$ = 312
dirblkn$ = 320
dirblu$ = 328
process_dirblk PROC

; 2084 : {

  00000	44 89 4c 24 20	 mov	 DWORD PTR [rsp+32], r9d
  00005	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  0000a	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  0000e	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00013	56		 push	 rsi
  00014	57		 push	 rdi
  00015	48 81 ec f8 00
	00 00		 sub	 rsp, 248		; 000000f8H
  0001c	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00023	48 33 c4	 xor	 rax, rsp
  00026	48 89 84 24 e8
	00 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 2085 : int             size;                   /* Size of directory entry   */
; 2086 : int             i, j;                   /* Array subscripts          */
; 2087 : int             k;                      /* Userdata halfword count   */
; 2088 : DATABLK        *blkp;                   /* -> Copy of directory block*/
; 2089 : BYTE           *dirptr;                 /* -> Next byte within block */
; 2090 : int             dirrem;                 /* Number of bytes remaining */
; 2091 : PDSDIR         *dirent;                 /* -> Directory entry        */
; 2092 : char            memname[9];             /* Member name (ASCIIZ)      */
; 2093 : BYTE            c, chars[25];           /* Character work areas      */
; 2094 : char            hex[49];                /* Character work areas      */
; 2095 : 
; 2096 :     /* Check for end of directory */
; 2097 :     if (blklen == 12 && memcmp(xbuf, twelvehex00, 12) == 0)

  0002e	83 bc 24 18 01
	00 00 0c	 cmp	 DWORD PTR blklen$[rsp], 12
  00036	75 40		 jne	 SHORT $LN7@process_di
  00038	41 b8 0c 00 00
	00		 mov	 r8d, 12
  0003e	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:twelvehex00
  00045	48 8b 8c 24 10
	01 00 00	 mov	 rcx, QWORD PTR xbuf$[rsp]
  0004d	e8 00 00 00 00	 call	 memcmp
  00052	85 c0		 test	 eax, eax
  00054	75 22		 jne	 SHORT $LN7@process_di

; 2098 :     {
; 2099 :         XMINF (3, MSG( HHC02554, "I" ) );

  00056	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG161576
  0005d	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG161577
  00064	b9 03 00 00 00	 mov	 ecx, 3
  00069	e8 00 00 00 00	 call	 info_msg

; 2100 :         return 1;

  0006e	b8 01 00 00 00	 mov	 eax, 1
  00073	e9 07 05 00 00	 jmp	 $LN1@process_di
$LN7@process_di:

; 2101 :     }
; 2102 : 
; 2103 :     /* Check directory block record for correct length */
; 2104 :     if (blklen != 276)

  00078	81 bc 24 18 01
	00 00 14 01 00
	00		 cmp	 DWORD PTR blklen$[rsp], 276 ; 00000114H
  00083	74 1d		 je	 SHORT $LN8@process_di

; 2105 :     {
; 2106 :         XMERR ( MSG( HHC02543, "E" ) );

  00085	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG161579
  0008c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG161580
  00093	e8 00 00 00 00	 call	 printf

; 2107 :         return -1;

  00098	b8 ff ff ff ff	 mov	 eax, -1
  0009d	e9 dd 04 00 00	 jmp	 $LN1@process_di
$LN8@process_di:

; 2108 :     }
; 2109 : 
; 2110 :     /* Obtain storage for a copy of the directory block */
; 2111 :     blkp = (DATABLK*)malloc(blklen);

  000a2	48 63 84 24 18
	01 00 00	 movsxd	 rax, DWORD PTR blklen$[rsp]
  000aa	48 8b c8	 mov	 rcx, rax
  000ad	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_malloc
  000b3	48 89 44 24 68	 mov	 QWORD PTR blkp$[rsp], rax

; 2112 :     if (blkp == NULL)

  000b8	48 83 7c 24 68
	00		 cmp	 QWORD PTR blkp$[rsp], 0
  000be	75 3e		 jne	 SHORT $LN9@process_di

; 2113 :     {
; 2114 : 
; 2115 :         XMERRF ( MSG( HHC02544, "E", "a directory block", "malloc()", strerror( errno ) ) );

  000c0	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno
  000c6	8b 08		 mov	 ecx, DWORD PTR [rax]
  000c8	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_strerror
  000ce	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  000d3	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG161582
  000da	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG161583
  000e1	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG161584
  000e8	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG161585
  000ef	e8 00 00 00 00	 call	 printf

; 2116 :         return -1;

  000f4	b8 ff ff ff ff	 mov	 eax, -1
  000f9	e9 81 04 00 00	 jmp	 $LN1@process_di
$LN9@process_di:

; 2117 :     }
; 2118 : 
; 2119 :     /* Copy the directory block */
; 2120 :     memcpy (blkp, xbuf, blklen);

  000fe	48 63 84 24 18
	01 00 00	 movsxd	 rax, DWORD PTR blklen$[rsp]
  00106	48 8b 7c 24 68	 mov	 rdi, QWORD PTR blkp$[rsp]
  0010b	48 8b b4 24 10
	01 00 00	 mov	 rsi, QWORD PTR xbuf$[rsp]
  00113	48 8b c8	 mov	 rcx, rax
  00116	f3 a4		 rep movsb

; 2121 : 
; 2122 :     /* Check that there is room in the directory block pointer array */
; 2123 :     if (dirblkn >= MAXDBLK)

  00118	81 bc 24 40 01
	00 00 10 27 00
	00		 cmp	 DWORD PTR dirblkn$[rsp], 10000 ; 00002710H
  00123	7c 23		 jl	 SHORT $LN10@process_di

; 2124 :     {
; 2125 :         XMERRF ( MSG( HHC02545, "E", MAXDBLK ) );

  00125	41 b8 10 27 00
	00		 mov	 r8d, 10000		; 00002710H
  0012b	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG161587
  00132	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG161588
  00139	e8 00 00 00 00	 call	 printf

; 2126 :         return -1;

  0013e	b8 ff ff ff ff	 mov	 eax, -1
  00143	e9 37 04 00 00	 jmp	 $LN1@process_di
$LN10@process_di:

; 2127 :     }
; 2128 : 
; 2129 :     /* Add the directory block to the pointer array */
; 2130 :     dirblka[dirblkn] = blkp;

  00148	48 63 84 24 40
	01 00 00	 movsxd	 rax, DWORD PTR dirblkn$[rsp]
  00150	48 8b 8c 24 38
	01 00 00	 mov	 rcx, QWORD PTR dirblka$[rsp]
  00158	48 8b 54 24 68	 mov	 rdx, QWORD PTR blkp$[rsp]
  0015d	48 89 14 c1	 mov	 QWORD PTR [rcx+rax*8], rdx

; 2131 : 
; 2132 :     /* Update the CCHHR in the copy of the directory block */
; 2133 :     store_hw( blkp->cyl,  cyl  );

  00161	0f b7 8c 24 20
	01 00 00	 movzx	 ecx, WORD PTR cyl$[rsp]
  00169	e8 00 00 00 00	 call	 _byteswap_ushort
  0016e	48 8b 4c 24 68	 mov	 rcx, QWORD PTR blkp$[rsp]
  00173	48 83 c1 04	 add	 rcx, 4
  00177	0f b7 d0	 movzx	 edx, ax
  0017a	e8 00 00 00 00	 call	 store_hw_noswap

; 2134 :     store_hw( blkp->head, head );

  0017f	0f b7 8c 24 28
	01 00 00	 movzx	 ecx, WORD PTR head$[rsp]
  00187	e8 00 00 00 00	 call	 _byteswap_ushort
  0018c	48 8b 4c 24 68	 mov	 rcx, QWORD PTR blkp$[rsp]
  00191	48 83 c1 06	 add	 rcx, 6
  00195	0f b7 d0	 movzx	 edx, ax
  00198	e8 00 00 00 00	 call	 store_hw_noswap

; 2135 :               blkp->rec = rec;

  0019d	48 8b 44 24 68	 mov	 rax, QWORD PTR blkp$[rsp]
  001a2	0f b6 8c 24 30
	01 00 00	 movzx	 ecx, BYTE PTR rec$[rsp]
  001aa	88 48 08	 mov	 BYTE PTR [rax+8], cl

; 2136 : 
; 2137 :     /* Load number of bytes in directory block */
; 2138 :     dirptr = xbuf->kdarea + 8;

  001ad	48 8b 84 24 10
	01 00 00	 mov	 rax, QWORD PTR xbuf$[rsp]
  001b5	48 83 c0 14	 add	 rax, 20
  001b9	48 89 44 24 60	 mov	 QWORD PTR dirptr$[rsp], rax

; 2139 :     dirrem = (dirptr[0] << 8) | dirptr[1];

  001be	b8 01 00 00 00	 mov	 eax, 1
  001c3	48 6b c0 00	 imul	 rax, rax, 0
  001c7	48 8b 4c 24 60	 mov	 rcx, QWORD PTR dirptr$[rsp]
  001cc	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  001d0	c1 e0 08	 shl	 eax, 8
  001d3	b9 01 00 00 00	 mov	 ecx, 1
  001d8	48 6b c9 01	 imul	 rcx, rcx, 1
  001dc	48 8b 54 24 60	 mov	 rdx, QWORD PTR dirptr$[rsp]
  001e1	0f b6 0c 0a	 movzx	 ecx, BYTE PTR [rdx+rcx]
  001e5	0b c1		 or	 eax, ecx
  001e7	89 44 24 48	 mov	 DWORD PTR dirrem$[rsp], eax

; 2140 :     if (dirrem < 2 || dirrem > 256)

  001eb	83 7c 24 48 02	 cmp	 DWORD PTR dirrem$[rsp], 2
  001f0	7c 0a		 jl	 SHORT $LN12@process_di
  001f2	81 7c 24 48 00
	01 00 00	 cmp	 DWORD PTR dirrem$[rsp], 256 ; 00000100H
  001fa	7e 1d		 jle	 SHORT $LN11@process_di
$LN12@process_di:

; 2141 :     {
; 2142 :         XMERR (MSG( HHC02546, "E" ) );

  001fc	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG161591
  00203	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG161592
  0020a	e8 00 00 00 00	 call	 printf

; 2143 :         return -1;

  0020f	b8 ff ff ff ff	 mov	 eax, -1
  00214	e9 66 03 00 00	 jmp	 $LN1@process_di
$LN11@process_di:

; 2144 :     }
; 2145 : 
; 2146 :     /* Return number of bytes used in directory block */
; 2147 :     *dirblu = dirrem;

  00219	48 8b 84 24 48
	01 00 00	 mov	 rax, QWORD PTR dirblu$[rsp]
  00221	8b 4c 24 48	 mov	 ecx, DWORD PTR dirrem$[rsp]
  00225	89 08		 mov	 DWORD PTR [rax], ecx

; 2148 : 
; 2149 :     /* Point to first directory entry */
; 2150 :     dirptr += 2;

  00227	48 8b 44 24 60	 mov	 rax, QWORD PTR dirptr$[rsp]
  0022c	48 83 c0 02	 add	 rax, 2
  00230	48 89 44 24 60	 mov	 QWORD PTR dirptr$[rsp], rax

; 2151 :     dirrem -= 2;

  00235	8b 44 24 48	 mov	 eax, DWORD PTR dirrem$[rsp]
  00239	83 e8 02	 sub	 eax, 2
  0023c	89 44 24 48	 mov	 DWORD PTR dirrem$[rsp], eax
$LN2@process_di:

; 2152 : 
; 2153 :     /* Process each directory entry */
; 2154 :     while (dirrem > 0)

  00240	83 7c 24 48 00	 cmp	 DWORD PTR dirrem$[rsp], 0
  00245	0f 8e 32 03 00
	00		 jle	 $LN3@process_di

; 2155 :     {
; 2156 :         /* Point to next directory entry */
; 2157 :         dirent = (PDSDIR*)dirptr;

  0024b	48 8b 44 24 60	 mov	 rax, QWORD PTR dirptr$[rsp]
  00250	48 89 44 24 50	 mov	 QWORD PTR dirent$[rsp], rax

; 2158 : 
; 2159 :         /* Test for end of directory */
; 2160 :         if (memcmp( dirent->pds2name, &CKD_ENDTRK, CKD_ENDTRK_SIZE ) == 0)

  00255	48 8b 44 24 50	 mov	 rax, QWORD PTR dirent$[rsp]
  0025a	41 b8 08 00 00
	00		 mov	 r8d, 8
  00260	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:CKD_ENDTRK
  00267	48 8b c8	 mov	 rcx, rax
  0026a	e8 00 00 00 00	 call	 memcmp
  0026f	85 c0		 test	 eax, eax
  00271	75 05		 jne	 SHORT $LN13@process_di

; 2161 :             break;

  00273	e9 05 03 00 00	 jmp	 $LN3@process_di
$LN13@process_di:

; 2162 : 
; 2163 :         /* Extract the member name */
; 2164 :         make_asciiz (memname, sizeof(memname), dirent->pds2name, 8);

  00278	48 8b 44 24 50	 mov	 rax, QWORD PTR dirent$[rsp]
  0027d	41 b9 08 00 00
	00		 mov	 r9d, 8
  00283	4c 8b c0	 mov	 r8, rax
  00286	ba 09 00 00 00	 mov	 edx, 9
  0028b	48 8d 8c 24 d8
	00 00 00	 lea	 rcx, QWORD PTR memname$[rsp]
  00293	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_make_asciiz

; 2165 : 
; 2166 :         /* Display the directory entry */
; 2167 :         XMINFF (3, MSG_C( HHC02555, "I", (dirent->pds2indc & PDS2INDC_ALIAS) ? " Alias" : "Member",

  00299	48 8b 44 24 50	 mov	 rax, QWORD PTR dirent$[rsp]
  0029e	0f b6 40 0b	 movzx	 eax, BYTE PTR [rax+11]
  002a2	25 80 00 00 00	 and	 eax, 128		; 00000080H
  002a7	85 c0		 test	 eax, eax
  002a9	74 0e		 je	 SHORT $LN23@process_di
  002ab	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG161594
  002b2	48 89 44 24 78	 mov	 QWORD PTR tv199[rsp], rax
  002b7	eb 0c		 jmp	 SHORT $LN24@process_di
$LN23@process_di:
  002b9	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG161595
  002c0	48 89 44 24 78	 mov	 QWORD PTR tv199[rsp], rax
$LN24@process_di:
  002c5	b8 01 00 00 00	 mov	 eax, 1
  002ca	48 6b c0 02	 imul	 rax, rax, 2
  002ce	48 8b 4c 24 50	 mov	 rcx, QWORD PTR dirent$[rsp]
  002d3	0f b6 44 01 08	 movzx	 eax, BYTE PTR [rcx+rax+8]
  002d8	b9 01 00 00 00	 mov	 ecx, 1
  002dd	48 6b c9 01	 imul	 rcx, rcx, 1
  002e1	48 8b 54 24 50	 mov	 rdx, QWORD PTR dirent$[rsp]
  002e6	0f b6 4c 0a 08	 movzx	 ecx, BYTE PTR [rdx+rcx+8]
  002eb	ba 01 00 00 00	 mov	 edx, 1
  002f0	48 6b d2 00	 imul	 rdx, rdx, 0
  002f4	48 8b 7c 24 50	 mov	 rdi, QWORD PTR dirent$[rsp]
  002f9	0f b6 54 17 08	 movzx	 edx, BYTE PTR [rdi+rdx+8]
  002fe	89 44 24 38	 mov	 DWORD PTR [rsp+56], eax
  00302	89 4c 24 30	 mov	 DWORD PTR [rsp+48], ecx
  00306	89 54 24 28	 mov	 DWORD PTR [rsp+40], edx
  0030a	48 8d 84 24 d8
	00 00 00	 lea	 rax, QWORD PTR memname$[rsp]
  00312	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00317	4c 8b 4c 24 78	 mov	 r9, QWORD PTR tv199[rsp]
  0031c	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG161596
  00323	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG161597
  0032a	b9 03 00 00 00	 mov	 ecx, 3
  0032f	e8 00 00 00 00	 call	 info_msg

; 2168 :                                         memname, dirent->pds2ttrp[0],
; 2169 :                                         dirent->pds2ttrp[1], dirent->pds2ttrp[2] ) );
; 2170 : 
; 2171 :         /* Load the user data halfword count */
; 2172 :         k = dirent->pds2indc & PDS2INDC_LUSR;

  00334	48 8b 44 24 50	 mov	 rax, QWORD PTR dirent$[rsp]
  00339	0f b6 40 0b	 movzx	 eax, BYTE PTR [rax+11]
  0033d	83 e0 1f	 and	 eax, 31
  00340	89 44 24 58	 mov	 DWORD PTR k$[rsp], eax

; 2173 : 
; 2174 :         /* Print the user data */
; 2175 :         if (k > 0) XMINF (3, "Userdata=");

  00344	83 7c 24 58 00	 cmp	 DWORD PTR k$[rsp], 0
  00349	7e 11		 jle	 SHORT $LN14@process_di
  0034b	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG161599
  00352	b9 03 00 00 00	 mov	 ecx, 3
  00357	e8 00 00 00 00	 call	 info_msg
$LN14@process_di:

; 2176 :         memset (hex, 0, sizeof(hex));

  0035c	48 8d 84 24 a0
	00 00 00	 lea	 rax, QWORD PTR hex$[rsp]
  00364	48 8b f8	 mov	 rdi, rax
  00367	33 c0		 xor	 eax, eax
  00369	b9 31 00 00 00	 mov	 ecx, 49			; 00000031H
  0036e	f3 aa		 rep stosb

; 2177 :         memset (chars, 0, sizeof(chars));

  00370	48 8d 84 24 80
	00 00 00	 lea	 rax, QWORD PTR chars$[rsp]
  00378	48 8b f8	 mov	 rdi, rax
  0037b	33 c0		 xor	 eax, eax
  0037d	b9 19 00 00 00	 mov	 ecx, 25
  00382	f3 aa		 rep stosb

; 2178 :         for (i = 0, j = 0; i < k*2; i++, j++)

  00384	c7 44 24 44 00
	00 00 00	 mov	 DWORD PTR i$[rsp], 0
  0038c	c7 44 24 4c 00
	00 00 00	 mov	 DWORD PTR j$[rsp], 0
  00394	eb 14		 jmp	 SHORT $LN6@process_di
$LN4@process_di:
  00396	8b 44 24 44	 mov	 eax, DWORD PTR i$[rsp]
  0039a	ff c0		 inc	 eax
  0039c	89 44 24 44	 mov	 DWORD PTR i$[rsp], eax
  003a0	8b 44 24 4c	 mov	 eax, DWORD PTR j$[rsp]
  003a4	ff c0		 inc	 eax
  003a6	89 44 24 4c	 mov	 DWORD PTR j$[rsp], eax
$LN6@process_di:
  003aa	8b 44 24 58	 mov	 eax, DWORD PTR k$[rsp]
  003ae	03 c0		 add	 eax, eax
  003b0	39 44 24 44	 cmp	 DWORD PTR i$[rsp], eax
  003b4	0f 8d 25 01 00
	00		 jge	 $LN5@process_di

; 2179 :         {
; 2180 :             if (i == 8 || i == 32 || i == 56)

  003ba	83 7c 24 44 08	 cmp	 DWORD PTR i$[rsp], 8
  003bf	74 12		 je	 SHORT $LN16@process_di
  003c1	83 7c 24 44 20	 cmp	 DWORD PTR i$[rsp], 32	; 00000020H
  003c6	74 0b		 je	 SHORT $LN16@process_di
  003c8	83 7c 24 44 38	 cmp	 DWORD PTR i$[rsp], 56	; 00000038H
  003cd	0f 85 98 00 00
	00		 jne	 $LN15@process_di
$LN16@process_di:

; 2181 :             {
; 2182 :                 if (i == 8)

  003d3	83 7c 24 44 08	 cmp	 DWORD PTR i$[rsp], 8
  003d8	75 23		 jne	 SHORT $LN17@process_di

; 2183 :                     XMINFF (3, "%-16.16s %-8.8s\n  ", hex, chars);

  003da	4c 8d 8c 24 80
	00 00 00	 lea	 r9, QWORD PTR chars$[rsp]
  003e2	4c 8d 84 24 a0
	00 00 00	 lea	 r8, QWORD PTR hex$[rsp]
  003ea	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG161604
  003f1	b9 03 00 00 00	 mov	 ecx, 3
  003f6	e8 00 00 00 00	 call	 info_msg
  003fb	eb 3e		 jmp	 SHORT $LN18@process_di
$LN17@process_di:

; 2184 :                 else
; 2185 :                     XMINFF (3, "%-16.16s %-16.16s %16.16s %-24.24s\n  ",

  003fd	48 8d 84 24 c0
	00 00 00	 lea	 rax, QWORD PTR hex$[rsp+32]
  00405	48 8d 8c 24 b0
	00 00 00	 lea	 rcx, QWORD PTR hex$[rsp+16]
  0040d	48 8d 94 24 80
	00 00 00	 lea	 rdx, QWORD PTR chars$[rsp]
  00415	48 89 54 24 28	 mov	 QWORD PTR [rsp+40], rdx
  0041a	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  0041f	4c 8b c9	 mov	 r9, rcx
  00422	4c 8d 84 24 a0
	00 00 00	 lea	 r8, QWORD PTR hex$[rsp]
  0042a	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG161605
  00431	b9 03 00 00 00	 mov	 ecx, 3
  00436	e8 00 00 00 00	 call	 info_msg
$LN18@process_di:

; 2186 :                         hex, hex+16, hex+32, chars);
; 2187 :                 memset (hex, 0, sizeof(hex));

  0043b	48 8d 84 24 a0
	00 00 00	 lea	 rax, QWORD PTR hex$[rsp]
  00443	48 8b f8	 mov	 rdi, rax
  00446	33 c0		 xor	 eax, eax
  00448	b9 31 00 00 00	 mov	 ecx, 49			; 00000031H
  0044d	f3 aa		 rep stosb

; 2188 :                 memset (chars, 0, sizeof(chars));

  0044f	48 8d 84 24 80
	00 00 00	 lea	 rax, QWORD PTR chars$[rsp]
  00457	48 8b f8	 mov	 rdi, rax
  0045a	33 c0		 xor	 eax, eax
  0045c	b9 19 00 00 00	 mov	 ecx, 25
  00461	f3 aa		 rep stosb

; 2189 :                 j = 0;

  00463	c7 44 24 4c 00
	00 00 00	 mov	 DWORD PTR j$[rsp], 0
$LN15@process_di:

; 2190 :             }
; 2191 :             sprintf(hex+2*j, "%2.2X", dirent->pds2usrd[i]);

  0046b	48 63 44 24 44	 movsxd	 rax, DWORD PTR i$[rsp]
  00470	48 8b 4c 24 50	 mov	 rcx, QWORD PTR dirent$[rsp]
  00475	0f b6 44 01 0c	 movzx	 eax, BYTE PTR [rcx+rax+12]
  0047a	8b 4c 24 4c	 mov	 ecx, DWORD PTR j$[rsp]
  0047e	d1 e1		 shl	 ecx, 1
  00480	48 63 c9	 movsxd	 rcx, ecx
  00483	48 8d 8c 0c a0
	00 00 00	 lea	 rcx, QWORD PTR hex$[rsp+rcx]
  0048b	44 8b c0	 mov	 r8d, eax
  0048e	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG161606
  00495	e8 00 00 00 00	 call	 sprintf

; 2192 :             c = guest_to_host(dirent->pds2usrd[i]);

  0049a	48 63 44 24 44	 movsxd	 rax, DWORD PTR i$[rsp]
  0049f	48 8b 4c 24 50	 mov	 rcx, QWORD PTR dirent$[rsp]
  004a4	0f b6 4c 01 0c	 movzx	 ecx, BYTE PTR [rcx+rax+12]
  004a9	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_guest_to_host
  004af	88 44 24 40	 mov	 BYTE PTR c$[rsp], al

; 2193 :             if (!isprint(c)) c = '.';

  004b3	0f b6 44 24 40	 movzx	 eax, BYTE PTR c$[rsp]
  004b8	8b c8		 mov	 ecx, eax
  004ba	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_isprint
  004c0	85 c0		 test	 eax, eax
  004c2	75 05		 jne	 SHORT $LN19@process_di
  004c4	c6 44 24 40 2e	 mov	 BYTE PTR c$[rsp], 46	; 0000002eH
$LN19@process_di:

; 2194 :             chars[j] = c;

  004c9	48 63 44 24 4c	 movsxd	 rax, DWORD PTR j$[rsp]
  004ce	0f b6 4c 24 40	 movzx	 ecx, BYTE PTR c$[rsp]
  004d3	88 8c 04 80 00
	00 00		 mov	 BYTE PTR chars$[rsp+rax], cl

; 2195 :         } /* end for(i) */

  004da	e9 b7 fe ff ff	 jmp	 $LN4@process_di
$LN5@process_di:

; 2196 :         if (i <= 8)

  004df	83 7c 24 44 08	 cmp	 DWORD PTR i$[rsp], 8
  004e4	7f 23		 jg	 SHORT $LN20@process_di

; 2197 :             XMINFF (3, "%-16.16s %-8.8s\n", hex, chars);

  004e6	4c 8d 8c 24 80
	00 00 00	 lea	 r9, QWORD PTR chars$[rsp]
  004ee	4c 8d 84 24 a0
	00 00 00	 lea	 r8, QWORD PTR hex$[rsp]
  004f6	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG161610
  004fd	b9 03 00 00 00	 mov	 ecx, 3
  00502	e8 00 00 00 00	 call	 info_msg
  00507	eb 3e		 jmp	 SHORT $LN21@process_di
$LN20@process_di:

; 2198 :         else
; 2199 :             XMINFF (3, "%-16.16s %-16.16s %-16.16s %-24.24s\n",

  00509	48 8d 84 24 c0
	00 00 00	 lea	 rax, QWORD PTR hex$[rsp+32]
  00511	48 8d 8c 24 b0
	00 00 00	 lea	 rcx, QWORD PTR hex$[rsp+16]
  00519	48 8d 94 24 80
	00 00 00	 lea	 rdx, QWORD PTR chars$[rsp]
  00521	48 89 54 24 28	 mov	 QWORD PTR [rsp+40], rdx
  00526	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  0052b	4c 8b c9	 mov	 r9, rcx
  0052e	4c 8d 84 24 a0
	00 00 00	 lea	 r8, QWORD PTR hex$[rsp]
  00536	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG161611
  0053d	b9 03 00 00 00	 mov	 ecx, 3
  00542	e8 00 00 00 00	 call	 info_msg
$LN21@process_di:

; 2200 :                 hex, hex+16, hex+32, chars);
; 2201 : 
; 2202 :         /* Point to next directory entry */
; 2203 :         size = 12 + k*2;

  00547	8b 44 24 58	 mov	 eax, DWORD PTR k$[rsp]
  0054b	8d 44 00 0c	 lea	 eax, DWORD PTR [rax+rax+12]
  0054f	89 44 24 70	 mov	 DWORD PTR size$[rsp], eax

; 2204 :         dirptr += size;

  00553	48 63 44 24 70	 movsxd	 rax, DWORD PTR size$[rsp]
  00558	48 8b 4c 24 60	 mov	 rcx, QWORD PTR dirptr$[rsp]
  0055d	48 03 c8	 add	 rcx, rax
  00560	48 8b c1	 mov	 rax, rcx
  00563	48 89 44 24 60	 mov	 QWORD PTR dirptr$[rsp], rax

; 2205 :         dirrem -= size;

  00568	8b 44 24 70	 mov	 eax, DWORD PTR size$[rsp]
  0056c	8b 4c 24 48	 mov	 ecx, DWORD PTR dirrem$[rsp]
  00570	2b c8		 sub	 ecx, eax
  00572	8b c1		 mov	 eax, ecx
  00574	89 44 24 48	 mov	 DWORD PTR dirrem$[rsp], eax

; 2206 :     }

  00578	e9 c3 fc ff ff	 jmp	 $LN2@process_di
$LN3@process_di:

; 2207 : 
; 2208 :     return 0;

  0057d	33 c0		 xor	 eax, eax
$LN1@process_di:

; 2209 : } /* end function process_dirblk */

  0057f	48 8b 8c 24 e8
	00 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  00587	48 33 cc	 xor	 rcx, rsp
  0058a	e8 00 00 00 00	 call	 __security_check_cookie
  0058f	48 81 c4 f8 00
	00 00		 add	 rsp, 248		; 000000f8H
  00596	5f		 pop	 rdi
  00597	5e		 pop	 rsi
  00598	c3		 ret	 0
process_dirblk ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\dasdload64.c
_TEXT	SEGMENT
i$ = 80
numext$ = 84
copyr2$ = 88
xbuf$ = 112
xreclen$ = 120
xarray$ = 128
process_copyr2 PROC

; 2017 : {

  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00009	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000e	48 83 ec 68	 sub	 rsp, 104		; 00000068H

; 2018 : COPYR2 *copyr2 = (COPYR2*)xbuf;         /* -> COPYR2 header record   */

  00012	48 8b 44 24 70	 mov	 rax, QWORD PTR xbuf$[rsp]
  00017	48 89 44 24 58	 mov	 QWORD PTR copyr2$[rsp], rax

; 2019 : int     numext;                         /* Number of extents         */
; 2020 : int     i;                              /* Array subscript           */
; 2021 : 
; 2022 :     /* Check COPYR2 record for correct length */
; 2023 :     if (xreclen != sizeof(COPYR2))

  0001c	48 63 44 24 78	 movsxd	 rax, DWORD PTR xreclen$[rsp]
  00021	48 3d 14 01 00
	00		 cmp	 rax, 276		; 00000114H
  00027	74 23		 je	 SHORT $LN5@process_co

; 2024 :     {
; 2025 :         XMERR ( MSG( HHC02539, "E", 2 ) );

  00029	41 b8 02 00 00
	00		 mov	 r8d, 2
  0002f	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG161528
  00036	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG161529
  0003d	e8 00 00 00 00	 call	 printf

; 2026 :         return -1;

  00042	b8 ff ff ff ff	 mov	 eax, -1
  00047	e9 f6 02 00 00	 jmp	 $LN1@process_co
$LN5@process_co:

; 2027 :     }
; 2028 : 
; 2029 :     /* Get number of extents from DEB basic section */
; 2030 :     numext = copyr2->debbasic[0];

  0004c	b8 01 00 00 00	 mov	 eax, 1
  00051	48 6b c0 00	 imul	 rax, rax, 0
  00055	48 8b 4c 24 58	 mov	 rcx, QWORD PTR copyr2$[rsp]
  0005a	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  0005e	89 44 24 54	 mov	 DWORD PTR numext$[rsp], eax

; 2031 :     if (numext < 1 || numext > 16)

  00062	83 7c 24 54 01	 cmp	 DWORD PTR numext$[rsp], 1
  00067	7c 07		 jl	 SHORT $LN7@process_co
  00069	83 7c 24 54 10	 cmp	 DWORD PTR numext$[rsp], 16
  0006e	7e 22		 jle	 SHORT $LN6@process_co
$LN7@process_co:

; 2032 :     {
; 2033 :         XMERRF ( MSG( HHC02542, "E", numext ) );

  00070	44 8b 44 24 54	 mov	 r8d, DWORD PTR numext$[rsp]
  00075	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG161532
  0007c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG161533
  00083	e8 00 00 00 00	 call	 printf

; 2034 :         return -1;

  00088	b8 ff ff ff ff	 mov	 eax, -1
  0008d	e9 b0 02 00 00	 jmp	 $LN1@process_co
$LN6@process_co:

; 2035 :     }
; 2036 : 
; 2037 :     /* Copy each extent descriptor into the array */
; 2038 :     for (i = 0; i < numext; i++)

  00092	c7 44 24 50 00
	00 00 00	 mov	 DWORD PTR i$[rsp], 0
  0009a	eb 0a		 jmp	 SHORT $LN4@process_co
$LN2@process_co:
  0009c	8b 44 24 50	 mov	 eax, DWORD PTR i$[rsp]
  000a0	ff c0		 inc	 eax
  000a2	89 44 24 50	 mov	 DWORD PTR i$[rsp], eax
$LN4@process_co:
  000a6	8b 44 24 54	 mov	 eax, DWORD PTR numext$[rsp]
  000aa	39 44 24 50	 cmp	 DWORD PTR i$[rsp], eax
  000ae	0f 8d 8a 02 00
	00		 jge	 $LN3@process_co

; 2039 :     {
; 2040 :         xarray[i].bcyl = (copyr2->debxtent[i][6] << 8)

  000b4	48 63 44 24 50	 movsxd	 rax, DWORD PTR i$[rsp]
  000b9	48 6b c0 10	 imul	 rax, rax, 16
  000bd	48 8b 4c 24 58	 mov	 rcx, QWORD PTR copyr2$[rsp]
  000c2	48 8d 44 01 10	 lea	 rax, QWORD PTR [rcx+rax+16]
  000c7	b9 01 00 00 00	 mov	 ecx, 1
  000cc	48 6b c9 06	 imul	 rcx, rcx, 6
  000d0	0f b6 04 08	 movzx	 eax, BYTE PTR [rax+rcx]
  000d4	c1 e0 08	 shl	 eax, 8
  000d7	48 63 4c 24 50	 movsxd	 rcx, DWORD PTR i$[rsp]
  000dc	48 6b c9 10	 imul	 rcx, rcx, 16
  000e0	48 8b 54 24 58	 mov	 rdx, QWORD PTR copyr2$[rsp]
  000e5	48 8d 4c 0a 10	 lea	 rcx, QWORD PTR [rdx+rcx+16]
  000ea	ba 01 00 00 00	 mov	 edx, 1
  000ef	48 6b d2 07	 imul	 rdx, rdx, 7
  000f3	0f b6 0c 11	 movzx	 ecx, BYTE PTR [rcx+rdx]
  000f7	0b c1		 or	 eax, ecx
  000f9	48 63 4c 24 50	 movsxd	 rcx, DWORD PTR i$[rsp]
  000fe	48 6b c9 0a	 imul	 rcx, rcx, 10
  00102	48 8b 94 24 80
	00 00 00	 mov	 rdx, QWORD PTR xarray$[rsp]
  0010a	66 89 04 0a	 mov	 WORD PTR [rdx+rcx], ax

; 2041 :                         | copyr2->debxtent[i][7];
; 2042 :         xarray[i].btrk = (copyr2->debxtent[i][8] << 8)

  0010e	48 63 44 24 50	 movsxd	 rax, DWORD PTR i$[rsp]
  00113	48 6b c0 10	 imul	 rax, rax, 16
  00117	48 8b 4c 24 58	 mov	 rcx, QWORD PTR copyr2$[rsp]
  0011c	48 8d 44 01 10	 lea	 rax, QWORD PTR [rcx+rax+16]
  00121	b9 01 00 00 00	 mov	 ecx, 1
  00126	48 6b c9 08	 imul	 rcx, rcx, 8
  0012a	0f b6 04 08	 movzx	 eax, BYTE PTR [rax+rcx]
  0012e	c1 e0 08	 shl	 eax, 8
  00131	48 63 4c 24 50	 movsxd	 rcx, DWORD PTR i$[rsp]
  00136	48 6b c9 10	 imul	 rcx, rcx, 16
  0013a	48 8b 54 24 58	 mov	 rdx, QWORD PTR copyr2$[rsp]
  0013f	48 8d 4c 0a 10	 lea	 rcx, QWORD PTR [rdx+rcx+16]
  00144	ba 01 00 00 00	 mov	 edx, 1
  00149	48 6b d2 09	 imul	 rdx, rdx, 9
  0014d	0f b6 0c 11	 movzx	 ecx, BYTE PTR [rcx+rdx]
  00151	0b c1		 or	 eax, ecx
  00153	48 63 4c 24 50	 movsxd	 rcx, DWORD PTR i$[rsp]
  00158	48 6b c9 0a	 imul	 rcx, rcx, 10
  0015c	48 8b 94 24 80
	00 00 00	 mov	 rdx, QWORD PTR xarray$[rsp]
  00164	66 89 44 0a 02	 mov	 WORD PTR [rdx+rcx+2], ax

; 2043 :                         | copyr2->debxtent[i][9];
; 2044 :         xarray[i].ecyl = (copyr2->debxtent[i][10] << 8)

  00169	48 63 44 24 50	 movsxd	 rax, DWORD PTR i$[rsp]
  0016e	48 6b c0 10	 imul	 rax, rax, 16
  00172	48 8b 4c 24 58	 mov	 rcx, QWORD PTR copyr2$[rsp]
  00177	48 8d 44 01 10	 lea	 rax, QWORD PTR [rcx+rax+16]
  0017c	b9 01 00 00 00	 mov	 ecx, 1
  00181	48 6b c9 0a	 imul	 rcx, rcx, 10
  00185	0f b6 04 08	 movzx	 eax, BYTE PTR [rax+rcx]
  00189	c1 e0 08	 shl	 eax, 8
  0018c	48 63 4c 24 50	 movsxd	 rcx, DWORD PTR i$[rsp]
  00191	48 6b c9 10	 imul	 rcx, rcx, 16
  00195	48 8b 54 24 58	 mov	 rdx, QWORD PTR copyr2$[rsp]
  0019a	48 8d 4c 0a 10	 lea	 rcx, QWORD PTR [rdx+rcx+16]
  0019f	ba 01 00 00 00	 mov	 edx, 1
  001a4	48 6b d2 0b	 imul	 rdx, rdx, 11
  001a8	0f b6 0c 11	 movzx	 ecx, BYTE PTR [rcx+rdx]
  001ac	0b c1		 or	 eax, ecx
  001ae	48 63 4c 24 50	 movsxd	 rcx, DWORD PTR i$[rsp]
  001b3	48 6b c9 0a	 imul	 rcx, rcx, 10
  001b7	48 8b 94 24 80
	00 00 00	 mov	 rdx, QWORD PTR xarray$[rsp]
  001bf	66 89 44 0a 04	 mov	 WORD PTR [rdx+rcx+4], ax

; 2045 :                         | copyr2->debxtent[i][11];
; 2046 :         xarray[i].etrk = (copyr2->debxtent[i][12] << 8)

  001c4	48 63 44 24 50	 movsxd	 rax, DWORD PTR i$[rsp]
  001c9	48 6b c0 10	 imul	 rax, rax, 16
  001cd	48 8b 4c 24 58	 mov	 rcx, QWORD PTR copyr2$[rsp]
  001d2	48 8d 44 01 10	 lea	 rax, QWORD PTR [rcx+rax+16]
  001d7	b9 01 00 00 00	 mov	 ecx, 1
  001dc	48 6b c9 0c	 imul	 rcx, rcx, 12
  001e0	0f b6 04 08	 movzx	 eax, BYTE PTR [rax+rcx]
  001e4	c1 e0 08	 shl	 eax, 8
  001e7	48 63 4c 24 50	 movsxd	 rcx, DWORD PTR i$[rsp]
  001ec	48 6b c9 10	 imul	 rcx, rcx, 16
  001f0	48 8b 54 24 58	 mov	 rdx, QWORD PTR copyr2$[rsp]
  001f5	48 8d 4c 0a 10	 lea	 rcx, QWORD PTR [rdx+rcx+16]
  001fa	ba 01 00 00 00	 mov	 edx, 1
  001ff	48 6b d2 0d	 imul	 rdx, rdx, 13
  00203	0f b6 0c 11	 movzx	 ecx, BYTE PTR [rcx+rdx]
  00207	0b c1		 or	 eax, ecx
  00209	48 63 4c 24 50	 movsxd	 rcx, DWORD PTR i$[rsp]
  0020e	48 6b c9 0a	 imul	 rcx, rcx, 10
  00212	48 8b 94 24 80
	00 00 00	 mov	 rdx, QWORD PTR xarray$[rsp]
  0021a	66 89 44 0a 06	 mov	 WORD PTR [rdx+rcx+6], ax

; 2047 :                         | copyr2->debxtent[i][13];
; 2048 :         xarray[i].ntrk = (copyr2->debxtent[i][14] << 8)

  0021f	48 63 44 24 50	 movsxd	 rax, DWORD PTR i$[rsp]
  00224	48 6b c0 10	 imul	 rax, rax, 16
  00228	48 8b 4c 24 58	 mov	 rcx, QWORD PTR copyr2$[rsp]
  0022d	48 8d 44 01 10	 lea	 rax, QWORD PTR [rcx+rax+16]
  00232	b9 01 00 00 00	 mov	 ecx, 1
  00237	48 6b c9 0e	 imul	 rcx, rcx, 14
  0023b	0f b6 04 08	 movzx	 eax, BYTE PTR [rax+rcx]
  0023f	c1 e0 08	 shl	 eax, 8
  00242	48 63 4c 24 50	 movsxd	 rcx, DWORD PTR i$[rsp]
  00247	48 6b c9 10	 imul	 rcx, rcx, 16
  0024b	48 8b 54 24 58	 mov	 rdx, QWORD PTR copyr2$[rsp]
  00250	48 8d 4c 0a 10	 lea	 rcx, QWORD PTR [rdx+rcx+16]
  00255	ba 01 00 00 00	 mov	 edx, 1
  0025a	48 6b d2 0f	 imul	 rdx, rdx, 15
  0025e	0f b6 0c 11	 movzx	 ecx, BYTE PTR [rcx+rdx]
  00262	0b c1		 or	 eax, ecx
  00264	48 63 4c 24 50	 movsxd	 rcx, DWORD PTR i$[rsp]
  00269	48 6b c9 0a	 imul	 rcx, rcx, 10
  0026d	48 8b 94 24 80
	00 00 00	 mov	 rdx, QWORD PTR xarray$[rsp]
  00275	66 89 44 0a 08	 mov	 WORD PTR [rdx+rcx+8], ax

; 2049 :                         | copyr2->debxtent[i][15];
; 2050 : 
; 2051 :         XMINFF (4, MSG( HHC02553, "I", i, xarray[i].bcyl, xarray[i].btrk,

  0027a	48 63 44 24 50	 movsxd	 rax, DWORD PTR i$[rsp]
  0027f	48 6b c0 0a	 imul	 rax, rax, 10
  00283	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR xarray$[rsp]
  0028b	0f b7 44 01 08	 movzx	 eax, WORD PTR [rcx+rax+8]
  00290	48 63 4c 24 50	 movsxd	 rcx, DWORD PTR i$[rsp]
  00295	48 6b c9 0a	 imul	 rcx, rcx, 10
  00299	48 8b 94 24 80
	00 00 00	 mov	 rdx, QWORD PTR xarray$[rsp]
  002a1	0f b7 4c 0a 08	 movzx	 ecx, WORD PTR [rdx+rcx+8]
  002a6	48 63 54 24 50	 movsxd	 rdx, DWORD PTR i$[rsp]
  002ab	48 6b d2 0a	 imul	 rdx, rdx, 10
  002af	4c 8b 84 24 80
	00 00 00	 mov	 r8, QWORD PTR xarray$[rsp]
  002b7	41 0f b7 54 10
	06		 movzx	 edx, WORD PTR [r8+rdx+6]
  002bd	4c 63 44 24 50	 movsxd	 r8, DWORD PTR i$[rsp]
  002c2	4d 6b c0 0a	 imul	 r8, r8, 10
  002c6	4c 8b 8c 24 80
	00 00 00	 mov	 r9, QWORD PTR xarray$[rsp]
  002ce	47 0f b7 44 01
	04		 movzx	 r8d, WORD PTR [r9+r8+4]
  002d4	4c 63 4c 24 50	 movsxd	 r9, DWORD PTR i$[rsp]
  002d9	4d 6b c9 0a	 imul	 r9, r9, 10
  002dd	4c 8b 94 24 80
	00 00 00	 mov	 r10, QWORD PTR xarray$[rsp]
  002e5	47 0f b7 4c 0a
	02		 movzx	 r9d, WORD PTR [r10+r9+2]
  002eb	4c 63 54 24 50	 movsxd	 r10, DWORD PTR i$[rsp]
  002f0	4d 6b d2 0a	 imul	 r10, r10, 10
  002f4	4c 8b 9c 24 80
	00 00 00	 mov	 r11, QWORD PTR xarray$[rsp]
  002fc	47 0f b7 14 13	 movzx	 r10d, WORD PTR [r11+r10]
  00301	89 44 24 48	 mov	 DWORD PTR [rsp+72], eax
  00305	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  00309	89 54 24 38	 mov	 DWORD PTR [rsp+56], edx
  0030d	44 89 44 24 30	 mov	 DWORD PTR [rsp+48], r8d
  00312	44 89 4c 24 28	 mov	 DWORD PTR [rsp+40], r9d
  00317	44 89 54 24 20	 mov	 DWORD PTR [rsp+32], r10d
  0031c	44 8b 4c 24 50	 mov	 r9d, DWORD PTR i$[rsp]
  00321	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG161534
  00328	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG161535
  0032f	b9 04 00 00 00	 mov	 ecx, 4
  00334	e8 00 00 00 00	 call	 info_msg

; 2052 :                                           xarray[i].ecyl, xarray[i].etrk,
; 2053 :                                           xarray[i].ntrk, xarray[i].ntrk ) );
; 2054 : 
; 2055 :     } /* end for(i) */

  00339	e9 5e fd ff ff	 jmp	 $LN2@process_co
$LN3@process_co:

; 2056 : 
; 2057 :     /* Return number of extents */
; 2058 :     return numext;

  0033e	8b 44 24 54	 mov	 eax, DWORD PTR numext$[rsp]
$LN1@process_co:

; 2059 : } /* end function process_copyr2 */

  00342	48 83 c4 68	 add	 rsp, 104		; 00000068H
  00346	c3		 ret	 0
process_copyr2 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\dasdload64.c
_TEXT	SEGMENT
copyr1$ = 64
keylen$ = 72
heads$ = 76
cyls$ = 80
blksize$ = 84
lrecl$ = 88
tv144 = 92
tv146 = 96
tv148 = 100
tv150 = 104
xbuf$ = 128
xreclen$ = 136
process_copyr1 PROC

; 1949 : {

  00000	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00004	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00009	48 83 ec 78	 sub	 rsp, 120		; 00000078H

; 1950 : COPYR1 *copyr1 = (COPYR1*)xbuf;         /* -> COPYR1 header record   */

  0000d	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR xbuf$[rsp]
  00015	48 89 44 24 40	 mov	 QWORD PTR copyr1$[rsp], rax

; 1951 : U16     blksize;                        /* Block size                */
; 1952 : U16     lrecl;                          /* Logical record length     */
; 1953 : BYTE    keylen;                         /* Key length                */
; 1954 : U16     cyls;                           /* Number of cylinders       */
; 1955 : U16     heads;                          /* Number of tracks/cylinder */
; 1956 : 
; 1957 :     /* Check COPYR1 record for correct length */
; 1958 :     if (xreclen != sizeof(COPYR1)
; 1959 :         && xreclen != sizeof(COPYR1) - 4)

  0001a	48 63 84 24 88
	00 00 00	 movsxd	 rax, DWORD PTR xreclen$[rsp]
  00022	48 83 f8 38	 cmp	 rax, 56			; 00000038H
  00026	74 31		 je	 SHORT $LN2@process_co
  00028	48 63 84 24 88
	00 00 00	 movsxd	 rax, DWORD PTR xreclen$[rsp]
  00030	48 83 f8 34	 cmp	 rax, 52			; 00000034H
  00034	74 23		 je	 SHORT $LN2@process_co

; 1960 :     {
; 1961 :         XMERR ( MSG( HHC02539, "E", 1 ) );

  00036	41 b8 01 00 00
	00		 mov	 r8d, 1
  0003c	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG161496
  00043	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG161497
  0004a	e8 00 00 00 00	 call	 printf

; 1962 :         return -1;

  0004f	b8 ff ff ff ff	 mov	 eax, -1
  00054	e9 6a 02 00 00	 jmp	 $LN1@process_co
$LN2@process_co:

; 1963 :     }
; 1964 : 
; 1965 :     /* Check that COPYR1 header identifier is correct */
; 1966 :     if (memcmp(copyr1->hdrid, COPYR1_HDRID, 3) != 0)

  00059	48 8b 44 24 40	 mov	 rax, QWORD PTR copyr1$[rsp]
  0005e	48 ff c0	 inc	 rax
  00061	41 b8 03 00 00
	00		 mov	 r8d, 3
  00067	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG161499
  0006e	48 8b c8	 mov	 rcx, rax
  00071	e8 00 00 00 00	 call	 memcmp
  00076	85 c0		 test	 eax, eax
  00078	74 23		 je	 SHORT $LN3@process_co

; 1967 :     {
; 1968 :         XMERR ( MSG( HHC02540, "E", 1 ) );

  0007a	41 b8 01 00 00
	00		 mov	 r8d, 1
  00080	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG161500
  00087	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG161501
  0008e	e8 00 00 00 00	 call	 printf

; 1969 :         return -1;

  00093	b8 ff ff ff ff	 mov	 eax, -1
  00098	e9 26 02 00 00	 jmp	 $LN1@process_co
$LN3@process_co:

; 1970 :     }
; 1971 : 
; 1972 :     /* Check that the dataset is an old format unload */
; 1973 :     if ((copyr1->uldfmt & COPYR1_ULD_FORMAT)
; 1974 :             != COPYR1_ULD_FORMAT_OLD)

  0009d	48 8b 44 24 40	 mov	 rax, QWORD PTR copyr1$[rsp]
  000a2	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  000a5	25 c0 00 00 00	 and	 eax, 192		; 000000c0H
  000aa	85 c0		 test	 eax, eax
  000ac	74 23		 je	 SHORT $LN4@process_co

; 1975 :     {
; 1976 :         XMERR ( MSG( HHC02541, "E", 1 ) );

  000ae	41 b8 01 00 00
	00		 mov	 r8d, 1
  000b4	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG161503
  000bb	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG161504
  000c2	e8 00 00 00 00	 call	 printf

; 1977 :         return -1;

  000c7	b8 ff ff ff ff	 mov	 eax, -1
  000cc	e9 f2 01 00 00	 jmp	 $LN1@process_co
$LN4@process_co:

; 1978 :     }
; 1979 : 
; 1980 :     blksize = (copyr1->ds1blkl[0] << 8) | copyr1->ds1blkl[1];

  000d1	b8 01 00 00 00	 mov	 eax, 1
  000d6	48 6b c0 00	 imul	 rax, rax, 0
  000da	48 8b 4c 24 40	 mov	 rcx, QWORD PTR copyr1$[rsp]
  000df	0f b6 44 01 06	 movzx	 eax, BYTE PTR [rcx+rax+6]
  000e4	c1 e0 08	 shl	 eax, 8
  000e7	b9 01 00 00 00	 mov	 ecx, 1
  000ec	48 6b c9 01	 imul	 rcx, rcx, 1
  000f0	48 8b 54 24 40	 mov	 rdx, QWORD PTR copyr1$[rsp]
  000f5	0f b6 4c 0a 06	 movzx	 ecx, BYTE PTR [rdx+rcx+6]
  000fa	0b c1		 or	 eax, ecx
  000fc	66 89 44 24 54	 mov	 WORD PTR blksize$[rsp], ax

; 1981 :     lrecl = (copyr1->ds1lrecl[0] << 8) | copyr1->ds1lrecl[1];

  00101	b8 01 00 00 00	 mov	 eax, 1
  00106	48 6b c0 00	 imul	 rax, rax, 0
  0010a	48 8b 4c 24 40	 mov	 rcx, QWORD PTR copyr1$[rsp]
  0010f	0f b6 44 01 08	 movzx	 eax, BYTE PTR [rcx+rax+8]
  00114	c1 e0 08	 shl	 eax, 8
  00117	b9 01 00 00 00	 mov	 ecx, 1
  0011c	48 6b c9 01	 imul	 rcx, rcx, 1
  00120	48 8b 54 24 40	 mov	 rdx, QWORD PTR copyr1$[rsp]
  00125	0f b6 4c 0a 08	 movzx	 ecx, BYTE PTR [rdx+rcx+8]
  0012a	0b c1		 or	 eax, ecx
  0012c	66 89 44 24 58	 mov	 WORD PTR lrecl$[rsp], ax

; 1982 :     keylen = copyr1->ds1keyl;

  00131	48 8b 44 24 40	 mov	 rax, QWORD PTR copyr1$[rsp]
  00136	0f b6 40 0b	 movzx	 eax, BYTE PTR [rax+11]
  0013a	88 44 24 48	 mov	 BYTE PTR keylen$[rsp], al

; 1983 : 
; 1984 :     /* Display original dataset information */
; 1985 :     XMINFF (2, MSG( HHC02550, "I",

  0013e	0f b6 44 24 48	 movzx	 eax, BYTE PTR keylen$[rsp]
  00143	89 44 24 5c	 mov	 DWORD PTR tv144[rsp], eax
  00147	0f b7 4c 24 54	 movzx	 ecx, WORD PTR blksize$[rsp]
  0014c	89 4c 24 60	 mov	 DWORD PTR tv146[rsp], ecx
  00150	0f b7 54 24 58	 movzx	 edx, WORD PTR lrecl$[rsp]
  00155	89 54 24 64	 mov	 DWORD PTR tv148[rsp], edx
  00159	4c 8b 44 24 40	 mov	 r8, QWORD PTR copyr1$[rsp]
  0015e	49 83 c0 0a	 add	 r8, 10
  00162	49 8b c8	 mov	 rcx, r8
  00165	e8 00 00 00 00	 call	 recfm_name
  0016a	48 89 44 24 68	 mov	 QWORD PTR tv150[rsp], rax
  0016f	48 8b 4c 24 40	 mov	 rcx, QWORD PTR copyr1$[rsp]
  00174	48 83 c1 04	 add	 rcx, 4
  00178	e8 00 00 00 00	 call	 dsorg_name
  0017d	8b 4c 24 5c	 mov	 ecx, DWORD PTR tv144[rsp]
  00181	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  00185	8b 4c 24 60	 mov	 ecx, DWORD PTR tv146[rsp]
  00189	89 4c 24 30	 mov	 DWORD PTR [rsp+48], ecx
  0018d	8b 4c 24 64	 mov	 ecx, DWORD PTR tv148[rsp]
  00191	89 4c 24 28	 mov	 DWORD PTR [rsp+40], ecx
  00195	48 8b 4c 24 68	 mov	 rcx, QWORD PTR tv150[rsp]
  0019a	48 89 4c 24 20	 mov	 QWORD PTR [rsp+32], rcx
  0019f	4c 8b c8	 mov	 r9, rax
  001a2	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG161505
  001a9	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG161506
  001b0	b9 02 00 00 00	 mov	 ecx, 2
  001b5	e8 00 00 00 00	 call	 info_msg

; 1986 :             dsorg_name(copyr1->ds1dsorg),
; 1987 :             recfm_name(&copyr1->ds1recfm),
; 1988 :             lrecl, blksize, keylen ) );
; 1989 : 
; 1990 :     XMINFF (2, MSG( HHC02551, "I",

  001ba	48 8b 44 24 40	 mov	 rax, QWORD PTR copyr1$[rsp]
  001bf	48 83 c0 10	 add	 rax, 16
  001c3	48 8b c8	 mov	 rcx, rax
  001c6	e8 00 00 00 00	 call	 dasd_name
  001cb	b9 01 00 00 00	 mov	 ecx, 1
  001d0	48 6b c9 03	 imul	 rcx, rcx, 3
  001d4	48 8b 54 24 40	 mov	 rdx, QWORD PTR copyr1$[rsp]
  001d9	0f b6 4c 0a 10	 movzx	 ecx, BYTE PTR [rdx+rcx+16]
  001de	ba 01 00 00 00	 mov	 edx, 1
  001e3	48 6b d2 02	 imul	 rdx, rdx, 2
  001e7	4c 8b 44 24 40	 mov	 r8, QWORD PTR copyr1$[rsp]
  001ec	41 0f b6 54 10
	10		 movzx	 edx, BYTE PTR [r8+rdx+16]
  001f2	41 b8 01 00 00
	00		 mov	 r8d, 1
  001f8	4d 6b c0 01	 imul	 r8, r8, 1
  001fc	4c 8b 4c 24 40	 mov	 r9, QWORD PTR copyr1$[rsp]
  00201	47 0f b6 44 01
	10		 movzx	 r8d, BYTE PTR [r9+r8+16]
  00207	41 b9 01 00 00
	00		 mov	 r9d, 1
  0020d	4d 6b c9 00	 imul	 r9, r9, 0
  00211	4c 8b 54 24 40	 mov	 r10, QWORD PTR copyr1$[rsp]
  00216	47 0f b6 4c 0a
	10		 movzx	 r9d, BYTE PTR [r10+r9+16]
  0021c	48 89 44 24 38	 mov	 QWORD PTR [rsp+56], rax
  00221	89 4c 24 30	 mov	 DWORD PTR [rsp+48], ecx
  00225	89 54 24 28	 mov	 DWORD PTR [rsp+40], edx
  00229	44 89 44 24 20	 mov	 DWORD PTR [rsp+32], r8d
  0022e	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG161507
  00235	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG161508
  0023c	b9 02 00 00 00	 mov	 ecx, 2
  00241	e8 00 00 00 00	 call	 info_msg

; 1991 :             copyr1->ucbtype[0], copyr1->ucbtype[1],
; 1992 :             copyr1->ucbtype[2], copyr1->ucbtype[3],
; 1993 :             dasd_name(copyr1->ucbtype) ) );
; 1994 : 
; 1995 :     cyls  = fetch_hw( copyr1->cyls  );

  00246	48 8b 44 24 40	 mov	 rax, QWORD PTR copyr1$[rsp]
  0024b	48 83 c0 18	 add	 rax, 24
  0024f	48 8b c8	 mov	 rcx, rax
  00252	e8 00 00 00 00	 call	 fetch_hw_noswap
  00257	0f b7 c8	 movzx	 ecx, ax
  0025a	e8 00 00 00 00	 call	 _byteswap_ushort
  0025f	66 89 44 24 50	 mov	 WORD PTR cyls$[rsp], ax

; 1996 :     heads = fetch_hw( copyr1->heads );

  00264	48 8b 44 24 40	 mov	 rax, QWORD PTR copyr1$[rsp]
  00269	48 83 c0 1a	 add	 rax, 26
  0026d	48 8b c8	 mov	 rcx, rax
  00270	e8 00 00 00 00	 call	 fetch_hw_noswap
  00275	0f b7 c8	 movzx	 ecx, ax
  00278	e8 00 00 00 00	 call	 _byteswap_ushort
  0027d	66 89 44 24 4c	 mov	 WORD PTR heads$[rsp], ax

; 1997 : 
; 1998 :     XMINFF (2, MSG( HHC02552, "I", cyls, cyls, heads, heads ) );

  00282	0f b7 44 24 4c	 movzx	 eax, WORD PTR heads$[rsp]
  00287	0f b7 4c 24 4c	 movzx	 ecx, WORD PTR heads$[rsp]
  0028c	0f b7 54 24 50	 movzx	 edx, WORD PTR cyls$[rsp]
  00291	44 0f b7 44 24
	50		 movzx	 r8d, WORD PTR cyls$[rsp]
  00297	89 44 24 30	 mov	 DWORD PTR [rsp+48], eax
  0029b	89 4c 24 28	 mov	 DWORD PTR [rsp+40], ecx
  0029f	89 54 24 20	 mov	 DWORD PTR [rsp+32], edx
  002a3	45 8b c8	 mov	 r9d, r8d
  002a6	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG161509
  002ad	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG161510
  002b4	b9 02 00 00 00	 mov	 ecx, 2
  002b9	e8 00 00 00 00	 call	 info_msg

; 1999 : 
; 2000 :     return heads;

  002be	0f b7 44 24 4c	 movzx	 eax, WORD PTR heads$[rsp]
$LN1@process_co:

; 2001 : } /* end function process_copyr1 */

  002c3	48 83 c4 78	 add	 rsp, 120		; 00000078H
  002c7	c3		 ret	 0
process_copyr1 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\dasdload64.c
_TEXT	SEGMENT
bufpos$ = 64
bufrem$ = 68
rc$ = 72
tunum$ = 76
tukey$ = 80
fieldptr$ = 96
fieldlen$ = 256
__$ArrayPad$ = 296
xbuf$ = 320
xreclen$ = 328
process_inmrxx PROC

; 1904 : {

  00000	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00004	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00009	48 81 ec 38 01
	00 00		 sub	 rsp, 312		; 00000138H
  00010	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00017	48 33 c4	 xor	 rax, rsp
  0001a	48 89 84 24 28
	01 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 1905 : int             rc;                     /* Return code               */
; 1906 : int             bufpos;                 /* Position of TU in buffer  */
; 1907 : int             bufrem;                 /* Bytes remaining in buffer */
; 1908 : U16             tukey;                  /* Text unit key             */
; 1909 : U16             tunum;                  /* Number of text unit fields*/
; 1910 : #define MAXNUM  20                      /* Maximum number of fields  */
; 1911 : U16             fieldlen[MAXNUM];       /* Array of field lengths    */
; 1912 : BYTE           *fieldptr[MAXNUM];       /* Array of field pointers   */
; 1913 : 
; 1914 :     /* Point to the first text unit */
; 1915 :     bufpos = 6;

  00022	c7 44 24 40 06
	00 00 00	 mov	 DWORD PTR bufpos$[rsp], 6

; 1916 :     bufrem = xreclen-6;

  0002a	8b 84 24 48 01
	00 00		 mov	 eax, DWORD PTR xreclen$[rsp]
  00031	83 e8 06	 sub	 eax, 6
  00034	89 44 24 44	 mov	 DWORD PTR bufrem$[rsp], eax
$LN2@process_in:

; 1917 : 
; 1918 :     /* Process each text unit */
; 1919 :     while (bufrem > 0)

  00038	83 7c 24 44 00	 cmp	 DWORD PTR bufrem$[rsp], 0
  0003d	0f 8e 97 00 00
	00		 jle	 $LN3@process_in

; 1920 :     {
; 1921 :         /* Extract the next text unit */
; 1922 :         rc = next_tu (xbuf, bufpos, bufrem, &tukey, &tunum,

  00043	48 8d 44 24 60	 lea	 rax, QWORD PTR fieldptr$[rsp]
  00048	48 89 44 24 38	 mov	 QWORD PTR [rsp+56], rax
  0004d	48 8d 84 24 00
	01 00 00	 lea	 rax, QWORD PTR fieldlen$[rsp]
  00055	48 89 44 24 30	 mov	 QWORD PTR [rsp+48], rax
  0005a	66 c7 44 24 28
	14 00		 mov	 WORD PTR [rsp+40], 20
  00061	48 8d 44 24 4c	 lea	 rax, QWORD PTR tunum$[rsp]
  00066	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  0006b	4c 8d 4c 24 50	 lea	 r9, QWORD PTR tukey$[rsp]
  00070	44 8b 44 24 44	 mov	 r8d, DWORD PTR bufrem$[rsp]
  00075	8b 54 24 40	 mov	 edx, DWORD PTR bufpos$[rsp]
  00079	48 8b 8c 24 40
	01 00 00	 mov	 rcx, QWORD PTR xbuf$[rsp]
  00081	e8 00 00 00 00	 call	 next_tu
  00086	89 44 24 48	 mov	 DWORD PTR rc$[rsp], eax

; 1923 :                 MAXNUM, fieldlen, fieldptr);
; 1924 :         if (rc < 0)

  0008a	83 7c 24 48 00	 cmp	 DWORD PTR rc$[rsp], 0
  0008f	7d 24		 jge	 SHORT $LN4@process_in

; 1925 :         {
; 1926 :             XMERRF ( MSG( HHC02538, "E", bufpos + 2 ) );

  00091	8b 44 24 40	 mov	 eax, DWORD PTR bufpos$[rsp]
  00095	83 c0 02	 add	 eax, 2
  00098	44 8b c0	 mov	 r8d, eax
  0009b	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG161478
  000a2	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG161479
  000a9	e8 00 00 00 00	 call	 printf

; 1927 :             return -1;

  000ae	b8 ff ff ff ff	 mov	 eax, -1
  000b3	eb 27		 jmp	 SHORT $LN1@process_in
$LN4@process_in:

; 1928 :         }
; 1929 : 
; 1930 :         bufpos += rc;

  000b5	8b 44 24 48	 mov	 eax, DWORD PTR rc$[rsp]
  000b9	8b 4c 24 40	 mov	 ecx, DWORD PTR bufpos$[rsp]
  000bd	03 c8		 add	 ecx, eax
  000bf	8b c1		 mov	 eax, ecx
  000c1	89 44 24 40	 mov	 DWORD PTR bufpos$[rsp], eax

; 1931 :         bufrem -= rc;

  000c5	8b 44 24 48	 mov	 eax, DWORD PTR rc$[rsp]
  000c9	8b 4c 24 44	 mov	 ecx, DWORD PTR bufrem$[rsp]
  000cd	2b c8		 sub	 ecx, eax
  000cf	8b c1		 mov	 eax, ecx
  000d1	89 44 24 44	 mov	 DWORD PTR bufrem$[rsp], eax

; 1932 : 
; 1933 :     } /* end while(bufrem) */

  000d5	e9 5e ff ff ff	 jmp	 $LN2@process_in
$LN3@process_in:

; 1934 : 
; 1935 :     return 0;

  000da	33 c0		 xor	 eax, eax
$LN1@process_in:

; 1936 : } /* end function process_inmrxx */

  000dc	48 8b 8c 24 28
	01 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  000e4	48 33 cc	 xor	 rcx, rsp
  000e7	e8 00 00 00 00	 call	 __security_check_cookie
  000ec	48 81 c4 38 01
	00 00		 add	 rsp, 312		; 00000138H
  000f3	c3		 ret	 0
process_inmrxx ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\dasdload64.c
_TEXT	SEGMENT
tukeyln$ = 80
tv153 = 84
tudsorg$ = 88
turecfm$ = 92
tulrecl$ = 96
tublksz$ = 100
i$ = 104
len$ = 108
bufpos$ = 112
bufrem$ = 116
tukey$ = 120
tunum$ = 124
rc$ = 128
filenum$ = 132
tudirct$ = 136
tv281 = 140
tv283 = 144
tv285 = 148
tv287 = 152
fieldptr$ = 160
tuutiln$ = 320
fieldlen$ = 336
tudsnam$ = 376
__$ArrayPad$ = 424
xbuf$ = 464
xreclen$ = 472
filen$ = 480
dsorg$ = 488
recfm$ = 496
lrecl$ = 504
blksz$ = 512
keyln$ = 520
dirnm$ = 528
process_inmr02 PROC

; 1777 : {

  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  0000e	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00013	56		 push	 rsi
  00014	57		 push	 rdi
  00015	48 81 ec b8 01
	00 00		 sub	 rsp, 440		; 000001b8H
  0001c	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00023	48 33 c4	 xor	 rax, rsp
  00026	48 89 84 24 a8
	01 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 1778 : int             rc;                     /* Return code               */
; 1779 : int             i;                      /* Array subscript           */
; 1780 : int             len;                    /* String length             */
; 1781 : U32             filenum;                /* File number               */
; 1782 : int             bufpos;                 /* Position of TU in buffer  */
; 1783 : int             bufrem;                 /* Bytes remaining in buffer */
; 1784 : char            tuutiln[9];             /* Utility name              */
; 1785 : BYTE            tukeyln;                /* Key length                */
; 1786 : HWORD           tudsorg;                /* Data set organization     */
; 1787 : HWORD           turecfm;                /* Record format             */
; 1788 : U16             tulrecl;                /* Logical record length     */
; 1789 : U16             tublksz;                /* Block size                */
; 1790 : int             tudirct;                /* Number of directory blocks*/
; 1791 : U16             tukey;                  /* Text unit key             */
; 1792 : U16             tunum;                  /* Number of text unit fields*/
; 1793 : char            tudsnam[45];            /* Data set name             */
; 1794 : #define MAXNUM  20                      /* Maximum number of fields  */
; 1795 : U16             fieldlen[MAXNUM];       /* Array of field lengths    */
; 1796 : BYTE           *fieldptr[MAXNUM];       /* Array of field pointers   */
; 1797 : 
; 1798 :     /* Extract the file number which follows the record name */
; 1799 :     filenum = (xbuf[6] << 24) | (xbuf[7] << 16)

  0002e	b8 01 00 00 00	 mov	 eax, 1
  00033	48 6b c0 06	 imul	 rax, rax, 6
  00037	48 8b 8c 24 d0
	01 00 00	 mov	 rcx, QWORD PTR xbuf$[rsp]
  0003f	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00043	c1 e0 18	 shl	 eax, 24
  00046	b9 01 00 00 00	 mov	 ecx, 1
  0004b	48 6b c9 07	 imul	 rcx, rcx, 7
  0004f	48 8b 94 24 d0
	01 00 00	 mov	 rdx, QWORD PTR xbuf$[rsp]
  00057	0f b6 0c 0a	 movzx	 ecx, BYTE PTR [rdx+rcx]
  0005b	c1 e1 10	 shl	 ecx, 16
  0005e	0b c1		 or	 eax, ecx
  00060	b9 01 00 00 00	 mov	 ecx, 1
  00065	48 6b c9 08	 imul	 rcx, rcx, 8
  00069	48 8b 94 24 d0
	01 00 00	 mov	 rdx, QWORD PTR xbuf$[rsp]
  00071	0f b6 0c 0a	 movzx	 ecx, BYTE PTR [rdx+rcx]
  00075	c1 e1 08	 shl	 ecx, 8
  00078	0b c1		 or	 eax, ecx
  0007a	b9 01 00 00 00	 mov	 ecx, 1
  0007f	48 6b c9 09	 imul	 rcx, rcx, 9
  00083	48 8b 94 24 d0
	01 00 00	 mov	 rdx, QWORD PTR xbuf$[rsp]
  0008b	0f b6 0c 0a	 movzx	 ecx, BYTE PTR [rdx+rcx]
  0008f	0b c1		 or	 eax, ecx
  00091	89 84 24 84 00
	00 00		 mov	 DWORD PTR filenum$[rsp], eax

; 1800 :             | (xbuf[8] << 8) | xbuf[9];
; 1801 :     XMINFF (4, MSG( HHC02527, "I", filenum ) );

  00098	44 8b 8c 24 84
	00 00 00	 mov	 r9d, DWORD PTR filenum$[rsp]
  000a0	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG161440
  000a7	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG161441
  000ae	b9 04 00 00 00	 mov	 ecx, 4
  000b3	e8 00 00 00 00	 call	 info_msg

; 1802 : 
; 1803 :     /* Point to the first text unit */
; 1804 :     bufpos = 10;

  000b8	c7 44 24 70 0a
	00 00 00	 mov	 DWORD PTR bufpos$[rsp], 10

; 1805 :     bufrem = xreclen-10;

  000c0	8b 84 24 d8 01
	00 00		 mov	 eax, DWORD PTR xreclen$[rsp]
  000c7	83 e8 0a	 sub	 eax, 10
  000ca	89 44 24 74	 mov	 DWORD PTR bufrem$[rsp], eax

; 1806 : 
; 1807 :     /* Clear values to be loaded from text units */
; 1808 :     memset (tudsnam, 0, sizeof(tudsnam));

  000ce	48 8d 84 24 78
	01 00 00	 lea	 rax, QWORD PTR tudsnam$[rsp]
  000d6	48 8b f8	 mov	 rdi, rax
  000d9	33 c0		 xor	 eax, eax
  000db	b9 2d 00 00 00	 mov	 ecx, 45			; 0000002dH
  000e0	f3 aa		 rep stosb

; 1809 :     memset (tuutiln, 0, sizeof(tuutiln));

  000e2	48 8d 84 24 40
	01 00 00	 lea	 rax, QWORD PTR tuutiln$[rsp]
  000ea	48 8b f8	 mov	 rdi, rax
  000ed	33 c0		 xor	 eax, eax
  000ef	b9 09 00 00 00	 mov	 ecx, 9
  000f4	f3 aa		 rep stosb

; 1810 :     memset (tudsorg, 0, sizeof(tudsorg));

  000f6	48 8d 44 24 58	 lea	 rax, QWORD PTR tudsorg$[rsp]
  000fb	48 8b f8	 mov	 rdi, rax
  000fe	33 c0		 xor	 eax, eax
  00100	b9 02 00 00 00	 mov	 ecx, 2
  00105	f3 aa		 rep stosb

; 1811 :     memset (turecfm, 0, sizeof(turecfm));

  00107	48 8d 44 24 5c	 lea	 rax, QWORD PTR turecfm$[rsp]
  0010c	48 8b f8	 mov	 rdi, rax
  0010f	33 c0		 xor	 eax, eax
  00111	b9 02 00 00 00	 mov	 ecx, 2
  00116	f3 aa		 rep stosb

; 1812 :     tulrecl = 0;

  00118	33 c0		 xor	 eax, eax
  0011a	66 89 44 24 60	 mov	 WORD PTR tulrecl$[rsp], ax

; 1813 :     tublksz = 0;

  0011f	33 c0		 xor	 eax, eax
  00121	66 89 44 24 64	 mov	 WORD PTR tublksz$[rsp], ax

; 1814 :     tukeyln = 0;

  00126	c6 44 24 50 00	 mov	 BYTE PTR tukeyln$[rsp], 0

; 1815 :     tudirct = 0;

  0012b	c7 84 24 88 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tudirct$[rsp], 0
$LN2@process_in:

; 1816 : 
; 1817 :     /* Process each text unit */
; 1818 :     while (bufrem > 0)

  00136	83 7c 24 74 00	 cmp	 DWORD PTR bufrem$[rsp], 0
  0013b	0f 8e 94 03 00
	00		 jle	 $LN3@process_in

; 1819 :     {
; 1820 :         /* Extract the next text unit */
; 1821 :         rc = next_tu (xbuf, bufpos, bufrem, &tukey, &tunum,

  00141	48 8d 84 24 a0
	00 00 00	 lea	 rax, QWORD PTR fieldptr$[rsp]
  00149	48 89 44 24 38	 mov	 QWORD PTR [rsp+56], rax
  0014e	48 8d 84 24 50
	01 00 00	 lea	 rax, QWORD PTR fieldlen$[rsp]
  00156	48 89 44 24 30	 mov	 QWORD PTR [rsp+48], rax
  0015b	66 c7 44 24 28
	14 00		 mov	 WORD PTR [rsp+40], 20
  00162	48 8d 44 24 7c	 lea	 rax, QWORD PTR tunum$[rsp]
  00167	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  0016c	4c 8d 4c 24 78	 lea	 r9, QWORD PTR tukey$[rsp]
  00171	44 8b 44 24 74	 mov	 r8d, DWORD PTR bufrem$[rsp]
  00176	8b 54 24 70	 mov	 edx, DWORD PTR bufpos$[rsp]
  0017a	48 8b 8c 24 d0
	01 00 00	 mov	 rcx, QWORD PTR xbuf$[rsp]
  00182	e8 00 00 00 00	 call	 next_tu
  00187	89 84 24 80 00
	00 00		 mov	 DWORD PTR rc$[rsp], eax

; 1822 :                 MAXNUM, fieldlen, fieldptr);
; 1823 :         if (rc < 0)

  0018e	83 bc 24 80 00
	00 00 00	 cmp	 DWORD PTR rc$[rsp], 0
  00196	7d 27		 jge	 SHORT $LN9@process_in

; 1824 :         {
; 1825 :             XMERRF ( MSG( HHC02538, "E", bufpos + 2 ) );

  00198	8b 44 24 70	 mov	 eax, DWORD PTR bufpos$[rsp]
  0019c	83 c0 02	 add	 eax, 2
  0019f	44 8b c0	 mov	 r8d, eax
  001a2	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG161443
  001a9	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG161444
  001b0	e8 00 00 00 00	 call	 printf

; 1826 :             return -1;

  001b5	b8 ff ff ff ff	 mov	 eax, -1
  001ba	e9 79 04 00 00	 jmp	 $LN1@process_in
$LN9@process_in:

; 1827 :         }
; 1828 :         bufpos += rc;

  001bf	8b 84 24 80 00
	00 00		 mov	 eax, DWORD PTR rc$[rsp]
  001c6	8b 4c 24 70	 mov	 ecx, DWORD PTR bufpos$[rsp]
  001ca	03 c8		 add	 ecx, eax
  001cc	8b c1		 mov	 eax, ecx
  001ce	89 44 24 70	 mov	 DWORD PTR bufpos$[rsp], eax

; 1829 :         bufrem -= rc;

  001d2	8b 84 24 80 00
	00 00		 mov	 eax, DWORD PTR rc$[rsp]
  001d9	8b 4c 24 74	 mov	 ecx, DWORD PTR bufrem$[rsp]
  001dd	2b c8		 sub	 ecx, eax
  001df	8b c1		 mov	 eax, ecx
  001e1	89 44 24 74	 mov	 DWORD PTR bufrem$[rsp], eax

; 1830 : 
; 1831 :         /* Save the values from selected text units */
; 1832 :         switch (tukey) {

  001e5	0f b7 44 24 78	 movzx	 eax, WORD PTR tukey$[rsp]
  001ea	89 44 24 54	 mov	 DWORD PTR tv153[rsp], eax
  001ee	83 7c 24 54 42	 cmp	 DWORD PTR tv153[rsp], 66 ; 00000042H
  001f3	7f 38		 jg	 SHORT $LN23@process_in
  001f5	83 7c 24 54 42	 cmp	 DWORD PTR tv153[rsp], 66 ; 00000042H
  001fa	0f 84 52 01 00
	00		 je	 $LN15@process_in
  00200	83 7c 24 54 02	 cmp	 DWORD PTR tv153[rsp], 2
  00205	0f 84 14 02 00
	00		 je	 $LN19@process_in
  0020b	83 7c 24 54 0c	 cmp	 DWORD PTR tv153[rsp], 12
  00210	0f 84 d4 01 00
	00		 je	 $LN18@process_in
  00216	83 7c 24 54 30	 cmp	 DWORD PTR tv153[rsp], 48 ; 00000030H
  0021b	0f 84 64 01 00
	00		 je	 $LN16@process_in
  00221	83 7c 24 54 3c	 cmp	 DWORD PTR tv153[rsp], 60 ; 0000003cH
  00226	74 6a		 je	 SHORT $LN11@process_in
  00228	e9 a3 02 00 00	 jmp	 $LN4@process_in
$LN23@process_in:
  0022d	83 7c 24 54 49	 cmp	 DWORD PTR tv153[rsp], 73 ; 00000049H
  00232	0f 84 ba 00 00
	00		 je	 $LN13@process_in
  00238	81 7c 24 54 28
	10 00 00	 cmp	 DWORD PTR tv153[rsp], 4136 ; 00001028H
  00240	74 13		 je	 SHORT $LN10@process_in
  00242	81 7c 24 54 12
	80 00 00	 cmp	 DWORD PTR tv153[rsp], 32786 ; 00008012H
  0024a	0f 84 68 01 00
	00		 je	 $LN17@process_in
  00250	e9 7b 02 00 00	 jmp	 $LN4@process_in
$LN10@process_in:

; 1833 :         case INMUTILN:
; 1834 :             make_asciiz (tuutiln, sizeof(tuutiln),

  00255	b8 02 00 00 00	 mov	 eax, 2
  0025a	48 6b c0 00	 imul	 rax, rax, 0
  0025e	0f b7 84 04 50
	01 00 00	 movzx	 eax, WORD PTR fieldlen$[rsp+rax]
  00266	b9 08 00 00 00	 mov	 ecx, 8
  0026b	48 6b c9 00	 imul	 rcx, rcx, 0
  0026f	44 8b c8	 mov	 r9d, eax
  00272	4c 8b 84 0c a0
	00 00 00	 mov	 r8, QWORD PTR fieldptr$[rsp+rcx]
  0027a	ba 09 00 00 00	 mov	 edx, 9
  0027f	48 8d 8c 24 40
	01 00 00	 lea	 rcx, QWORD PTR tuutiln$[rsp]
  00287	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_make_asciiz

; 1835 :                         fieldptr[0], fieldlen[0]);
; 1836 :             break;

  0028d	e9 3e 02 00 00	 jmp	 $LN4@process_in
$LN11@process_in:

; 1837 :         case INMDSORG:
; 1838 :             if (fieldlen[0] > sizeof(tudsorg))

  00292	b8 02 00 00 00	 mov	 eax, 2
  00297	48 6b c0 00	 imul	 rax, rax, 0
  0029b	0f b7 84 04 50
	01 00 00	 movzx	 eax, WORD PTR fieldlen$[rsp+rax]
  002a3	48 83 f8 02	 cmp	 rax, 2
  002a7	76 16		 jbe	 SHORT $LN12@process_in

; 1839 :                 fieldlen[0] = sizeof(tudsorg);

  002a9	b8 02 00 00 00	 mov	 eax, 2
  002ae	48 6b c0 00	 imul	 rax, rax, 0
  002b2	b9 02 00 00 00	 mov	 ecx, 2
  002b7	66 89 8c 04 50
	01 00 00	 mov	 WORD PTR fieldlen$[rsp+rax], cx
$LN12@process_in:

; 1840 :             memcpy (tudsorg, fieldptr[0], fieldlen[0]);

  002bf	b8 02 00 00 00	 mov	 eax, 2
  002c4	48 6b c0 00	 imul	 rax, rax, 0
  002c8	0f b7 84 04 50
	01 00 00	 movzx	 eax, WORD PTR fieldlen$[rsp+rax]
  002d0	b9 08 00 00 00	 mov	 ecx, 8
  002d5	48 6b c9 00	 imul	 rcx, rcx, 0
  002d9	48 8d 54 24 58	 lea	 rdx, QWORD PTR tudsorg$[rsp]
  002de	48 8b fa	 mov	 rdi, rdx
  002e1	48 8b b4 0c a0
	00 00 00	 mov	 rsi, QWORD PTR fieldptr$[rsp+rcx]
  002e9	8b c8		 mov	 ecx, eax
  002eb	f3 a4		 rep movsb

; 1841 :             break;

  002ed	e9 de 01 00 00	 jmp	 $LN4@process_in
$LN13@process_in:

; 1842 :         case INMRECFM:
; 1843 :             if (fieldlen[0] > sizeof(turecfm))

  002f2	b8 02 00 00 00	 mov	 eax, 2
  002f7	48 6b c0 00	 imul	 rax, rax, 0
  002fb	0f b7 84 04 50
	01 00 00	 movzx	 eax, WORD PTR fieldlen$[rsp+rax]
  00303	48 83 f8 02	 cmp	 rax, 2
  00307	76 16		 jbe	 SHORT $LN14@process_in

; 1844 :                 fieldlen[0] = sizeof(turecfm);

  00309	b8 02 00 00 00	 mov	 eax, 2
  0030e	48 6b c0 00	 imul	 rax, rax, 0
  00312	b9 02 00 00 00	 mov	 ecx, 2
  00317	66 89 8c 04 50
	01 00 00	 mov	 WORD PTR fieldlen$[rsp+rax], cx
$LN14@process_in:

; 1845 :             memcpy (turecfm, fieldptr[0], fieldlen[0]);

  0031f	b8 02 00 00 00	 mov	 eax, 2
  00324	48 6b c0 00	 imul	 rax, rax, 0
  00328	0f b7 84 04 50
	01 00 00	 movzx	 eax, WORD PTR fieldlen$[rsp+rax]
  00330	b9 08 00 00 00	 mov	 ecx, 8
  00335	48 6b c9 00	 imul	 rcx, rcx, 0
  00339	48 8d 54 24 5c	 lea	 rdx, QWORD PTR turecfm$[rsp]
  0033e	48 8b fa	 mov	 rdi, rdx
  00341	48 8b b4 0c a0
	00 00 00	 mov	 rsi, QWORD PTR fieldptr$[rsp+rcx]
  00349	8b c8		 mov	 ecx, eax
  0034b	f3 a4		 rep movsb

; 1846 :             break;

  0034d	e9 7e 01 00 00	 jmp	 $LN4@process_in
$LN15@process_in:

; 1847 :         case INMLRECL:
; 1848 :             tulrecl = (U16) make_int (fieldptr[0], fieldlen[0]);

  00352	b8 02 00 00 00	 mov	 eax, 2
  00357	48 6b c0 00	 imul	 rax, rax, 0
  0035b	0f b7 84 04 50
	01 00 00	 movzx	 eax, WORD PTR fieldlen$[rsp+rax]
  00363	b9 08 00 00 00	 mov	 ecx, 8
  00368	48 6b c9 00	 imul	 rcx, rcx, 0
  0036c	8b d0		 mov	 edx, eax
  0036e	48 8b 8c 0c a0
	00 00 00	 mov	 rcx, QWORD PTR fieldptr$[rsp+rcx]
  00376	e8 00 00 00 00	 call	 make_int
  0037b	66 89 44 24 60	 mov	 WORD PTR tulrecl$[rsp], ax

; 1849 :             break;

  00380	e9 4b 01 00 00	 jmp	 $LN4@process_in
$LN16@process_in:

; 1850 :         case INMBLKSZ:
; 1851 :             tublksz = (U16) make_int (fieldptr[0], fieldlen[0]);

  00385	b8 02 00 00 00	 mov	 eax, 2
  0038a	48 6b c0 00	 imul	 rax, rax, 0
  0038e	0f b7 84 04 50
	01 00 00	 movzx	 eax, WORD PTR fieldlen$[rsp+rax]
  00396	b9 08 00 00 00	 mov	 ecx, 8
  0039b	48 6b c9 00	 imul	 rcx, rcx, 0
  0039f	8b d0		 mov	 edx, eax
  003a1	48 8b 8c 0c a0
	00 00 00	 mov	 rcx, QWORD PTR fieldptr$[rsp+rcx]
  003a9	e8 00 00 00 00	 call	 make_int
  003ae	66 89 44 24 64	 mov	 WORD PTR tublksz$[rsp], ax

; 1852 :             break;

  003b3	e9 18 01 00 00	 jmp	 $LN4@process_in
$LN17@process_in:

; 1853 :         case INMTYPE:
; 1854 :             tukeyln = (BYTE) make_int (fieldptr[0], fieldlen[0]);

  003b8	b8 02 00 00 00	 mov	 eax, 2
  003bd	48 6b c0 00	 imul	 rax, rax, 0
  003c1	0f b7 84 04 50
	01 00 00	 movzx	 eax, WORD PTR fieldlen$[rsp+rax]
  003c9	b9 08 00 00 00	 mov	 ecx, 8
  003ce	48 6b c9 00	 imul	 rcx, rcx, 0
  003d2	8b d0		 mov	 edx, eax
  003d4	48 8b 8c 0c a0
	00 00 00	 mov	 rcx, QWORD PTR fieldptr$[rsp+rcx]
  003dc	e8 00 00 00 00	 call	 make_int
  003e1	88 44 24 50	 mov	 BYTE PTR tukeyln$[rsp], al

; 1855 :             break;

  003e5	e9 e6 00 00 00	 jmp	 $LN4@process_in
$LN18@process_in:

; 1856 :         case INMDIR:
; 1857 :             tudirct = make_int (fieldptr[0], fieldlen[0]);

  003ea	b8 02 00 00 00	 mov	 eax, 2
  003ef	48 6b c0 00	 imul	 rax, rax, 0
  003f3	0f b7 84 04 50
	01 00 00	 movzx	 eax, WORD PTR fieldlen$[rsp+rax]
  003fb	b9 08 00 00 00	 mov	 ecx, 8
  00400	48 6b c9 00	 imul	 rcx, rcx, 0
  00404	8b d0		 mov	 edx, eax
  00406	48 8b 8c 0c a0
	00 00 00	 mov	 rcx, QWORD PTR fieldptr$[rsp+rcx]
  0040e	e8 00 00 00 00	 call	 make_int
  00413	89 84 24 88 00
	00 00		 mov	 DWORD PTR tudirct$[rsp], eax

; 1858 :             break;

  0041a	e9 b1 00 00 00	 jmp	 $LN4@process_in
$LN19@process_in:

; 1859 :         case INMDSNAM:
; 1860 :             memset (tudsnam, 0, sizeof(tudsnam));

  0041f	48 8d 84 24 78
	01 00 00	 lea	 rax, QWORD PTR tudsnam$[rsp]
  00427	48 8b f8	 mov	 rdi, rax
  0042a	33 c0		 xor	 eax, eax
  0042c	b9 2d 00 00 00	 mov	 ecx, 45			; 0000002dH
  00431	f3 aa		 rep stosb

; 1861 :             for (i = 0; i < tunum; i++)

  00433	c7 44 24 68 00
	00 00 00	 mov	 DWORD PTR i$[rsp], 0
  0043b	eb 0a		 jmp	 SHORT $LN8@process_in
$LN6@process_in:
  0043d	8b 44 24 68	 mov	 eax, DWORD PTR i$[rsp]
  00441	ff c0		 inc	 eax
  00443	89 44 24 68	 mov	 DWORD PTR i$[rsp], eax
$LN8@process_in:
  00447	0f b7 44 24 7c	 movzx	 eax, WORD PTR tunum$[rsp]
  0044c	39 44 24 68	 cmp	 DWORD PTR i$[rsp], eax
  00450	7d 7e		 jge	 SHORT $LN7@process_in

; 1862 :             {
; 1863 : #if defined( _MSVC_ )
; 1864 :                 len = (int)strlen(tudsnam);

  00452	48 8d 8c 24 78
	01 00 00	 lea	 rcx, QWORD PTR tudsnam$[rsp]
  0045a	e8 00 00 00 00	 call	 strlen
  0045f	89 44 24 6c	 mov	 DWORD PTR len$[rsp], eax

; 1865 : #else
; 1866 :                 len = strlen(tudsnam);
; 1867 : #endif
; 1868 :                 if (i > 0 && len < (int)(sizeof(tudsnam) - 1))

  00463	83 7c 24 68 00	 cmp	 DWORD PTR i$[rsp], 0
  00468	7e 1e		 jle	 SHORT $LN20@process_in
  0046a	83 7c 24 6c 2c	 cmp	 DWORD PTR len$[rsp], 44	; 0000002cH
  0046f	7d 17		 jge	 SHORT $LN20@process_in

; 1869 :                     tudsnam[len++] = '.';

  00471	48 63 44 24 6c	 movsxd	 rax, DWORD PTR len$[rsp]
  00476	c6 84 04 78 01
	00 00 2e	 mov	 BYTE PTR tudsnam$[rsp+rax], 46 ; 0000002eH
  0047e	8b 44 24 6c	 mov	 eax, DWORD PTR len$[rsp]
  00482	ff c0		 inc	 eax
  00484	89 44 24 6c	 mov	 DWORD PTR len$[rsp], eax
$LN20@process_in:

; 1870 :                 make_asciiz (tudsnam + len, sizeof(tudsnam) - len,

  00488	48 63 44 24 68	 movsxd	 rax, DWORD PTR i$[rsp]
  0048d	0f b7 84 44 50
	01 00 00	 movzx	 eax, WORD PTR fieldlen$[rsp+rax*2]
  00495	48 63 4c 24 68	 movsxd	 rcx, DWORD PTR i$[rsp]
  0049a	48 63 54 24 6c	 movsxd	 rdx, DWORD PTR len$[rsp]
  0049f	bf 2d 00 00 00	 mov	 edi, 45			; 0000002dH
  004a4	48 2b fa	 sub	 rdi, rdx
  004a7	48 8b d7	 mov	 rdx, rdi
  004aa	48 63 7c 24 6c	 movsxd	 rdi, DWORD PTR len$[rsp]
  004af	48 8d bc 3c 78
	01 00 00	 lea	 rdi, QWORD PTR tudsnam$[rsp+rdi]
  004b7	44 8b c8	 mov	 r9d, eax
  004ba	4c 8b 84 cc a0
	00 00 00	 mov	 r8, QWORD PTR fieldptr$[rsp+rcx*8]
  004c2	48 8b cf	 mov	 rcx, rdi
  004c5	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_make_asciiz

; 1871 :                                 fieldptr[i], fieldlen[i]);
; 1872 :             } /* end for(i) */

  004cb	e9 6d ff ff ff	 jmp	 $LN6@process_in
$LN7@process_in:
$LN4@process_in:

; 1873 :         } /* end switch(tukey) */
; 1874 :     } /* end while(bufrem) */

  004d0	e9 61 fc ff ff	 jmp	 $LN2@process_in
$LN3@process_in:

; 1875 : 
; 1876 :     /* Return the dataset values if this is the IEBCOPY record */
; 1877 :     if (strcmp(tuutiln, "IEBCOPY") == 0)

  004d5	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG161457
  004dc	48 8d 8c 24 40
	01 00 00	 lea	 rcx, QWORD PTR tuutiln$[rsp]
  004e4	e8 00 00 00 00	 call	 strcmp
  004e9	85 c0		 test	 eax, eax
  004eb	0f 85 45 01 00
	00		 jne	 $LN21@process_in

; 1878 :     {
; 1879 :         XMINFF (2, MSG( HHC02528, "I", filenum, tudsnam ) );

  004f1	48 8d 84 24 78
	01 00 00	 lea	 rax, QWORD PTR tudsnam$[rsp]
  004f9	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  004fe	44 8b 8c 24 84
	00 00 00	 mov	 r9d, DWORD PTR filenum$[rsp]
  00506	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG161458
  0050d	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG161459
  00514	b9 02 00 00 00	 mov	 ecx, 2
  00519	e8 00 00 00 00	 call	 info_msg

; 1880 :         XMINFF (2, MSG( HHC02529, "I", dsorg_name(tudsorg), recfm_name(turecfm),

  0051e	0f b6 44 24 50	 movzx	 eax, BYTE PTR tukeyln$[rsp]
  00523	89 84 24 8c 00
	00 00		 mov	 DWORD PTR tv281[rsp], eax
  0052a	0f b7 4c 24 64	 movzx	 ecx, WORD PTR tublksz$[rsp]
  0052f	89 8c 24 90 00
	00 00		 mov	 DWORD PTR tv283[rsp], ecx
  00536	0f b7 54 24 60	 movzx	 edx, WORD PTR tulrecl$[rsp]
  0053b	89 94 24 94 00
	00 00		 mov	 DWORD PTR tv285[rsp], edx
  00542	48 8d 4c 24 5c	 lea	 rcx, QWORD PTR turecfm$[rsp]
  00547	e8 00 00 00 00	 call	 recfm_name
  0054c	48 89 84 24 98
	00 00 00	 mov	 QWORD PTR tv287[rsp], rax
  00554	48 8d 4c 24 58	 lea	 rcx, QWORD PTR tudsorg$[rsp]
  00559	e8 00 00 00 00	 call	 dsorg_name
  0055e	8b 8c 24 88 00
	00 00		 mov	 ecx, DWORD PTR tudirct$[rsp]
  00565	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  00569	8b 8c 24 8c 00
	00 00		 mov	 ecx, DWORD PTR tv281[rsp]
  00570	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  00574	8b 8c 24 90 00
	00 00		 mov	 ecx, DWORD PTR tv283[rsp]
  0057b	89 4c 24 30	 mov	 DWORD PTR [rsp+48], ecx
  0057f	8b 8c 24 94 00
	00 00		 mov	 ecx, DWORD PTR tv285[rsp]
  00586	89 4c 24 28	 mov	 DWORD PTR [rsp+40], ecx
  0058a	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR tv287[rsp]
  00592	48 89 4c 24 20	 mov	 QWORD PTR [rsp+32], rcx
  00597	4c 8b c8	 mov	 r9, rax
  0059a	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG161460
  005a1	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG161461
  005a8	b9 02 00 00 00	 mov	 ecx, 2
  005ad	e8 00 00 00 00	 call	 info_msg

; 1881 :                                        tulrecl, tublksz, tukeyln, tudirct ) );
; 1882 :         *filen = filenum;

  005b2	48 8b 84 24 e0
	01 00 00	 mov	 rax, QWORD PTR filen$[rsp]
  005ba	8b 8c 24 84 00
	00 00		 mov	 ecx, DWORD PTR filenum$[rsp]
  005c1	89 08		 mov	 DWORD PTR [rax], ecx

; 1883 :         *dsorg = tudsorg[0];

  005c3	b8 01 00 00 00	 mov	 eax, 1
  005c8	48 6b c0 00	 imul	 rax, rax, 0
  005cc	48 8b 8c 24 e8
	01 00 00	 mov	 rcx, QWORD PTR dsorg$[rsp]
  005d4	0f b6 44 04 58	 movzx	 eax, BYTE PTR tudsorg$[rsp+rax]
  005d9	88 01		 mov	 BYTE PTR [rcx], al

; 1884 :         *recfm = turecfm[0];

  005db	b8 01 00 00 00	 mov	 eax, 1
  005e0	48 6b c0 00	 imul	 rax, rax, 0
  005e4	48 8b 8c 24 f0
	01 00 00	 mov	 rcx, QWORD PTR recfm$[rsp]
  005ec	0f b6 44 04 5c	 movzx	 eax, BYTE PTR turecfm$[rsp+rax]
  005f1	88 01		 mov	 BYTE PTR [rcx], al

; 1885 :         *lrecl = tulrecl;

  005f3	48 8b 84 24 f8
	01 00 00	 mov	 rax, QWORD PTR lrecl$[rsp]
  005fb	0f b7 4c 24 60	 movzx	 ecx, WORD PTR tulrecl$[rsp]
  00600	66 89 08	 mov	 WORD PTR [rax], cx

; 1886 :         *blksz = tublksz;

  00603	48 8b 84 24 00
	02 00 00	 mov	 rax, QWORD PTR blksz$[rsp]
  0060b	0f b7 4c 24 64	 movzx	 ecx, WORD PTR tublksz$[rsp]
  00610	66 89 08	 mov	 WORD PTR [rax], cx

; 1887 :         *keyln = tukeyln;

  00613	0f b6 44 24 50	 movzx	 eax, BYTE PTR tukeyln$[rsp]
  00618	48 8b 8c 24 08
	02 00 00	 mov	 rcx, QWORD PTR keyln$[rsp]
  00620	66 89 01	 mov	 WORD PTR [rcx], ax

; 1888 :         *dirnm = (U16) tudirct;

  00623	48 8b 84 24 10
	02 00 00	 mov	 rax, QWORD PTR dirnm$[rsp]
  0062b	0f b7 8c 24 88
	00 00 00	 movzx	 ecx, WORD PTR tudirct$[rsp]
  00633	66 89 08	 mov	 WORD PTR [rax], cx
$LN21@process_in:

; 1889 :     }
; 1890 : 
; 1891 :     return 0;

  00636	33 c0		 xor	 eax, eax
$LN1@process_in:

; 1892 : } /* end function process_inmr02 */

  00638	48 8b 8c 24 a8
	01 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  00640	48 33 cc	 xor	 rcx, rsp
  00643	e8 00 00 00 00	 call	 __security_check_cookie
  00648	48 81 c4 b8 01
	00 00		 add	 rsp, 440		; 000001b8H
  0064f	5f		 pop	 rdi
  00650	5e		 pop	 rsi
  00651	c3		 ret	 0
process_inmr02 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\dasdload64.c
_TEXT	SEGMENT
xreclen$ = 32
rc$ = 36
datablk$ = 40
tv75 = 48
tv90 = 56
tv137 = 64
tv165 = 72
xfd$ = 96
xfname$ = 104
xbuf$ = 112
recnum$ = 120
read_vs_rec PROC

; 1703 : {

  00000	44 89 4c 24 20	 mov	 DWORD PTR [rsp+32], r9d
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	89 4c 24 08	 mov	 DWORD PTR [rsp+8], ecx
  00013	48 83 ec 58	 sub	 rsp, 88			; 00000058H

; 1704 : int             rc;                     /* Return code               */
; 1705 : int             xreclen;                /* Cumulative record length  */
; 1706 : DATABLK        *datablk;                /* Data block                */
; 1707 : 
; 1708 :     if (recnum == 0) {

  00017	83 7c 24 78 00	 cmp	 DWORD PTR recnum$[rsp], 0
  0001c	75 74		 jne	 SHORT $LN2@read_vs_re

; 1709 :        xreclen = read(xfd, xbuf, 56);   /* read COPYR1 plus some extras */

  0001e	41 b8 38 00 00
	00		 mov	 r8d, 56			; 00000038H
  00024	48 8b 54 24 70	 mov	 rdx, QWORD PTR xbuf$[rsp]
  00029	8b 4c 24 60	 mov	 ecx, DWORD PTR xfd$[rsp]
  0002d	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_read
  00033	89 44 24 20	 mov	 DWORD PTR xreclen$[rsp], eax

; 1710 :        if (xreclen < 56)

  00037	83 7c 24 20 38	 cmp	 DWORD PTR xreclen$[rsp], 56 ; 00000038H
  0003c	7d 4f		 jge	 SHORT $LN4@read_vs_re

; 1711 :         {
; 1712 :             XMERRF ( MSG( HHC02533, "E", xfname, xreclen < 0 ? strerror(errno) : "Unexpected end of file" ) );

  0003e	83 7c 24 20 00	 cmp	 DWORD PTR xreclen$[rsp], 0
  00043	7d 15		 jge	 SHORT $LN12@read_vs_re
  00045	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno
  0004b	8b 08		 mov	 ecx, DWORD PTR [rax]
  0004d	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_strerror
  00053	48 89 44 24 30	 mov	 QWORD PTR tv75[rsp], rax
  00058	eb 0c		 jmp	 SHORT $LN13@read_vs_re
$LN12@read_vs_re:
  0005a	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG161371
  00061	48 89 44 24 30	 mov	 QWORD PTR tv75[rsp], rax
$LN13@read_vs_re:
  00066	4c 8b 4c 24 30	 mov	 r9, QWORD PTR tv75[rsp]
  0006b	4c 8b 44 24 68	 mov	 r8, QWORD PTR xfname$[rsp]
  00070	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG161372
  00077	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG161373
  0007e	e8 00 00 00 00	 call	 printf

; 1713 :             return -1;

  00083	b8 ff ff ff ff	 mov	 eax, -1
  00088	e9 c8 01 00 00	 jmp	 $LN1@read_vs_re
$LN4@read_vs_re:

; 1714 :         }
; 1715 :      }

  0008d	e9 bf 01 00 00	 jmp	 $LN3@read_vs_re
$LN2@read_vs_re:

; 1716 : 
; 1717 :     else if (recnum == 1) {

  00092	83 7c 24 78 01	 cmp	 DWORD PTR recnum$[rsp], 1
  00097	75 77		 jne	 SHORT $LN5@read_vs_re

; 1718 :        xreclen = read(xfd, xbuf, sizeof(COPYR2));  /* read COPYR2 */

  00099	41 b8 14 01 00
	00		 mov	 r8d, 276		; 00000114H
  0009f	48 8b 54 24 70	 mov	 rdx, QWORD PTR xbuf$[rsp]
  000a4	8b 4c 24 60	 mov	 ecx, DWORD PTR xfd$[rsp]
  000a8	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_read
  000ae	89 44 24 20	 mov	 DWORD PTR xreclen$[rsp], eax

; 1719 :        if (xreclen < (int)sizeof(COPYR2))

  000b2	81 7c 24 20 14
	01 00 00	 cmp	 DWORD PTR xreclen$[rsp], 276 ; 00000114H
  000ba	7d 4f		 jge	 SHORT $LN7@read_vs_re

; 1720 :         {
; 1721 :             XMERRF ( MSG( HHC02533, "E", xfname, xreclen < 0 ? strerror(errno) : "Unexpected end of file" ) );

  000bc	83 7c 24 20 00	 cmp	 DWORD PTR xreclen$[rsp], 0
  000c1	7d 15		 jge	 SHORT $LN14@read_vs_re
  000c3	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno
  000c9	8b 08		 mov	 ecx, DWORD PTR [rax]
  000cb	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_strerror
  000d1	48 89 44 24 38	 mov	 QWORD PTR tv90[rsp], rax
  000d6	eb 0c		 jmp	 SHORT $LN15@read_vs_re
$LN14@read_vs_re:
  000d8	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG161377
  000df	48 89 44 24 38	 mov	 QWORD PTR tv90[rsp], rax
$LN15@read_vs_re:
  000e4	4c 8b 4c 24 38	 mov	 r9, QWORD PTR tv90[rsp]
  000e9	4c 8b 44 24 68	 mov	 r8, QWORD PTR xfname$[rsp]
  000ee	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG161378
  000f5	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG161379
  000fc	e8 00 00 00 00	 call	 printf

; 1722 :             return -1;

  00101	b8 ff ff ff ff	 mov	 eax, -1
  00106	e9 4a 01 00 00	 jmp	 $LN1@read_vs_re
$LN7@read_vs_re:

; 1723 :         }
; 1724 :      }

  0010b	e9 41 01 00 00	 jmp	 $LN6@read_vs_re
$LN5@read_vs_re:

; 1725 : 
; 1726 :     else {
; 1727 :        rc = read(xfd, xbuf, 12);        /* read header of DATABLK */

  00110	41 b8 0c 00 00
	00		 mov	 r8d, 12
  00116	48 8b 54 24 70	 mov	 rdx, QWORD PTR xbuf$[rsp]
  0011b	8b 4c 24 60	 mov	 ecx, DWORD PTR xfd$[rsp]
  0011f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_read
  00125	89 44 24 24	 mov	 DWORD PTR rc$[rsp], eax

; 1728 :        if (rc == 0)                     /* read nothing? */

  00129	83 7c 24 24 00	 cmp	 DWORD PTR rc$[rsp], 0
  0012e	75 07		 jne	 SHORT $LN8@read_vs_re

; 1729 :           return 0;

  00130	33 c0		 xor	 eax, eax
  00132	e9 1e 01 00 00	 jmp	 $LN1@read_vs_re
$LN8@read_vs_re:

; 1730 :        if (rc < 12)

  00137	83 7c 24 24 0c	 cmp	 DWORD PTR rc$[rsp], 12
  0013c	7d 4f		 jge	 SHORT $LN9@read_vs_re

; 1731 :         {
; 1732 :             XMERRF ( MSG( HHC02533, "E", xfname, rc < 0 ? strerror(errno) : "Unexpected end of file" ) );

  0013e	83 7c 24 24 00	 cmp	 DWORD PTR rc$[rsp], 0
  00143	7d 15		 jge	 SHORT $LN16@read_vs_re
  00145	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno
  0014b	8b 08		 mov	 ecx, DWORD PTR [rax]
  0014d	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_strerror
  00153	48 89 44 24 40	 mov	 QWORD PTR tv137[rsp], rax
  00158	eb 0c		 jmp	 SHORT $LN17@read_vs_re
$LN16@read_vs_re:
  0015a	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG161382
  00161	48 89 44 24 40	 mov	 QWORD PTR tv137[rsp], rax
$LN17@read_vs_re:
  00166	4c 8b 4c 24 40	 mov	 r9, QWORD PTR tv137[rsp]
  0016b	4c 8b 44 24 68	 mov	 r8, QWORD PTR xfname$[rsp]
  00170	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG161383
  00177	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG161384
  0017e	e8 00 00 00 00	 call	 printf

; 1733 :             return -1;

  00183	b8 ff ff ff ff	 mov	 eax, -1
  00188	e9 c8 00 00 00	 jmp	 $LN1@read_vs_re
$LN9@read_vs_re:

; 1734 :         }
; 1735 :        datablk = (DATABLK *)xbuf;

  0018d	48 8b 44 24 70	 mov	 rax, QWORD PTR xbuf$[rsp]
  00192	48 89 44 24 28	 mov	 QWORD PTR datablk$[rsp], rax

; 1736 :        xreclen = ((datablk->dlen[0] << 8) | datablk->dlen[1])

  00197	b8 01 00 00 00	 mov	 eax, 1
  0019c	48 6b c0 00	 imul	 rax, rax, 0
  001a0	48 8b 4c 24 28	 mov	 rcx, QWORD PTR datablk$[rsp]
  001a5	0f b6 44 01 0a	 movzx	 eax, BYTE PTR [rcx+rax+10]
  001aa	c1 e0 08	 shl	 eax, 8
  001ad	b9 01 00 00 00	 mov	 ecx, 1
  001b2	48 6b c9 01	 imul	 rcx, rcx, 1
  001b6	48 8b 54 24 28	 mov	 rdx, QWORD PTR datablk$[rsp]
  001bb	0f b6 4c 0a 0a	 movzx	 ecx, BYTE PTR [rdx+rcx+10]
  001c0	0b c1		 or	 eax, ecx
  001c2	48 8b 4c 24 28	 mov	 rcx, QWORD PTR datablk$[rsp]
  001c7	0f b6 49 09	 movzx	 ecx, BYTE PTR [rcx+9]
  001cb	03 c1		 add	 eax, ecx
  001cd	89 44 24 20	 mov	 DWORD PTR xreclen$[rsp], eax

; 1737 :                + datablk->klen;
; 1738 :        rc = read(xfd, xbuf + 12, xreclen);  /* read kdarea of DATABLK */

  001d1	48 8b 44 24 70	 mov	 rax, QWORD PTR xbuf$[rsp]
  001d6	48 83 c0 0c	 add	 rax, 12
  001da	44 8b 44 24 20	 mov	 r8d, DWORD PTR xreclen$[rsp]
  001df	48 8b d0	 mov	 rdx, rax
  001e2	8b 4c 24 60	 mov	 ecx, DWORD PTR xfd$[rsp]
  001e6	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_read
  001ec	89 44 24 24	 mov	 DWORD PTR rc$[rsp], eax

; 1739 :        if (rc < xreclen)

  001f0	8b 44 24 20	 mov	 eax, DWORD PTR xreclen$[rsp]
  001f4	39 44 24 24	 cmp	 DWORD PTR rc$[rsp], eax
  001f8	7d 4c		 jge	 SHORT $LN10@read_vs_re

; 1740 :         {
; 1741 :             XMERRF ( MSG( HHC02533, "E", xfname, rc < 0 ? strerror(errno) : "Unexpected end of file" ) );

  001fa	83 7c 24 24 00	 cmp	 DWORD PTR rc$[rsp], 0
  001ff	7d 15		 jge	 SHORT $LN18@read_vs_re
  00201	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno
  00207	8b 08		 mov	 ecx, DWORD PTR [rax]
  00209	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_strerror
  0020f	48 89 44 24 48	 mov	 QWORD PTR tv165[rsp], rax
  00214	eb 0c		 jmp	 SHORT $LN19@read_vs_re
$LN18@read_vs_re:
  00216	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG161386
  0021d	48 89 44 24 48	 mov	 QWORD PTR tv165[rsp], rax
$LN19@read_vs_re:
  00222	4c 8b 4c 24 48	 mov	 r9, QWORD PTR tv165[rsp]
  00227	4c 8b 44 24 68	 mov	 r8, QWORD PTR xfname$[rsp]
  0022c	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG161387
  00233	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG161388
  0023a	e8 00 00 00 00	 call	 printf

; 1742 :             return -1;

  0023f	b8 ff ff ff ff	 mov	 eax, -1
  00244	eb 0f		 jmp	 SHORT $LN1@read_vs_re
$LN10@read_vs_re:

; 1743 :         }
; 1744 :        xreclen += 12;                   /* also count the header */

  00246	8b 44 24 20	 mov	 eax, DWORD PTR xreclen$[rsp]
  0024a	83 c0 0c	 add	 eax, 12
  0024d	89 44 24 20	 mov	 DWORD PTR xreclen$[rsp], eax
$LN6@read_vs_re:
$LN3@read_vs_re:

; 1745 :     }
; 1746 : 
; 1747 :     /* Return record length */
; 1748 :     return xreclen;

  00251	8b 44 24 20	 mov	 eax, DWORD PTR xreclen$[rsp]
$LN1@read_vs_re:

; 1749 : 
; 1750 : } /* end function read_vs_rec */

  00255	48 83 c4 58	 add	 rsp, 88			; 00000058H
  00259	c3		 ret	 0
read_vs_rec ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\dasdload64.c
_TEXT	SEGMENT
ctlind$ = 48
seghdr$ = 52
rc$ = 56
segnum$ = 60
xreclen$ = 64
seglen$ = 68
tv75 = 72
tv179 = 80
xfd$ = 112
xfname$ = 120
xbuf$ = 128
ctl$ = 136
read_xmit_rec PROC

; 1609 : {

  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	89 4c 24 08	 mov	 DWORD PTR [rsp+8], ecx
  00013	48 83 ec 68	 sub	 rsp, 104		; 00000068H

; 1610 : int             rc;                     /* Return code               */
; 1611 : int             xreclen = 0;            /* Cumulative record length  */

  00017	c7 44 24 40 00
	00 00 00	 mov	 DWORD PTR xreclen$[rsp], 0

; 1612 : int             segnum;                 /* Segment counter           */
; 1613 : int             seglen;                 /* Segment data length       */
; 1614 : BYTE            ctlind = 0x00;          /* 0x20=Control record       */

  0001f	c6 44 24 30 00	 mov	 BYTE PTR ctlind$[rsp], 0

; 1615 : BYTE            seghdr[2];              /* Segment length and flags  */
; 1616 : 
; 1617 :     for (segnum = 0; ; segnum++)

  00024	c7 44 24 3c 00
	00 00 00	 mov	 DWORD PTR segnum$[rsp], 0
  0002c	eb 0a		 jmp	 SHORT $LN4@read_xmit_
$LN2@read_xmit_:
  0002e	8b 44 24 3c	 mov	 eax, DWORD PTR segnum$[rsp]
  00032	ff c0		 inc	 eax
  00034	89 44 24 3c	 mov	 DWORD PTR segnum$[rsp], eax
$LN4@read_xmit_:

; 1618 :     {
; 1619 :         /* Read the segment length and flags */
; 1620 :         rc = read (xfd, seghdr, 2);

  00038	41 b8 02 00 00
	00		 mov	 r8d, 2
  0003e	48 8d 54 24 34	 lea	 rdx, QWORD PTR seghdr$[rsp]
  00043	8b 4c 24 70	 mov	 ecx, DWORD PTR xfd$[rsp]
  00047	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_read
  0004d	89 44 24 38	 mov	 DWORD PTR rc$[rsp], eax

; 1621 :         if (rc < 2)

  00051	83 7c 24 38 02	 cmp	 DWORD PTR rc$[rsp], 2
  00056	7d 4f		 jge	 SHORT $LN5@read_xmit_

; 1622 :         {
; 1623 :             XMERRF ( MSG( HHC02533, "E", xfname, rc < 0 ? strerror(errno) : "Unexpected end of file" ) );

  00058	83 7c 24 38 00	 cmp	 DWORD PTR rc$[rsp], 0
  0005d	7d 15		 jge	 SHORT $LN16@read_xmit_
  0005f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno
  00065	8b 08		 mov	 ecx, DWORD PTR [rax]
  00067	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_strerror
  0006d	48 89 44 24 48	 mov	 QWORD PTR tv75[rsp], rax
  00072	eb 0c		 jmp	 SHORT $LN17@read_xmit_
$LN16@read_xmit_:
  00074	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG161328
  0007b	48 89 44 24 48	 mov	 QWORD PTR tv75[rsp], rax
$LN17@read_xmit_:
  00080	4c 8b 4c 24 48	 mov	 r9, QWORD PTR tv75[rsp]
  00085	4c 8b 44 24 78	 mov	 r8, QWORD PTR xfname$[rsp]
  0008a	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG161329
  00091	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG161330
  00098	e8 00 00 00 00	 call	 printf

; 1624 :             return -1;

  0009d	b8 ff ff ff ff	 mov	 eax, -1
  000a2	e9 11 02 00 00	 jmp	 $LN1@read_xmit_
$LN5@read_xmit_:

; 1625 :         }
; 1626 : 
; 1627 :         /* Check for valid segment header */
; 1628 :         if (seghdr[0] < 2 || (seghdr[1] & 0x1F) != 0)

  000a7	b8 01 00 00 00	 mov	 eax, 1
  000ac	48 6b c0 00	 imul	 rax, rax, 0
  000b0	0f b6 44 04 34	 movzx	 eax, BYTE PTR seghdr$[rsp+rax]
  000b5	83 f8 02	 cmp	 eax, 2
  000b8	7c 15		 jl	 SHORT $LN7@read_xmit_
  000ba	b8 01 00 00 00	 mov	 eax, 1
  000bf	48 6b c0 01	 imul	 rax, rax, 1
  000c3	0f b6 44 04 34	 movzx	 eax, BYTE PTR seghdr$[rsp+rax]
  000c8	83 e0 1f	 and	 eax, 31
  000cb	85 c0		 test	 eax, eax
  000cd	74 45		 je	 SHORT $LN6@read_xmit_
$LN7@read_xmit_:

; 1629 :         {
; 1630 :             XMERRF ( MSG( HHC02534, "E", xfname, seghdr[0], seghdr[1] ) );

  000cf	b8 01 00 00 00	 mov	 eax, 1
  000d4	48 6b c0 01	 imul	 rax, rax, 1
  000d8	0f b6 44 04 34	 movzx	 eax, BYTE PTR seghdr$[rsp+rax]
  000dd	b9 01 00 00 00	 mov	 ecx, 1
  000e2	48 6b c9 00	 imul	 rcx, rcx, 0
  000e6	0f b6 4c 0c 34	 movzx	 ecx, BYTE PTR seghdr$[rsp+rcx]
  000eb	89 44 24 20	 mov	 DWORD PTR [rsp+32], eax
  000ef	44 8b c9	 mov	 r9d, ecx
  000f2	4c 8b 44 24 78	 mov	 r8, QWORD PTR xfname$[rsp]
  000f7	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG161333
  000fe	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG161334
  00105	e8 00 00 00 00	 call	 printf

; 1631 :             return -1;

  0010a	b8 ff ff ff ff	 mov	 eax, -1
  0010f	e9 a4 01 00 00	 jmp	 $LN1@read_xmit_
$LN6@read_xmit_:

; 1632 :         }
; 1633 : 
; 1634 :         /* Check flags for first segment */
; 1635 :         if (segnum == 0)

  00114	83 7c 24 3c 00	 cmp	 DWORD PTR segnum$[rsp], 0
  00119	75 4e		 jne	 SHORT $LN8@read_xmit_

; 1636 :         {
; 1637 :             /* Check that first segment indicator is set */
; 1638 :             if ((seghdr[1] & 0x80) == 0)

  0011b	b8 01 00 00 00	 mov	 eax, 1
  00120	48 6b c0 01	 imul	 rax, rax, 1
  00124	0f b6 44 04 34	 movzx	 eax, BYTE PTR seghdr$[rsp+rax]
  00129	25 80 00 00 00	 and	 eax, 128		; 00000080H
  0012e	85 c0		 test	 eax, eax
  00130	75 22		 jne	 SHORT $LN9@read_xmit_

; 1639 :             {
; 1640 :                 XMERRF ( MSG( HHC02535, "E", xfname ) );

  00132	4c 8b 44 24 78	 mov	 r8, QWORD PTR xfname$[rsp]
  00137	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG161337
  0013e	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG161338
  00145	e8 00 00 00 00	 call	 printf

; 1641 :                 return -1;

  0014a	b8 ff ff ff ff	 mov	 eax, -1
  0014f	e9 64 01 00 00	 jmp	 $LN1@read_xmit_
$LN9@read_xmit_:

; 1642 :             }
; 1643 : 
; 1644 :             /* Save the control record indicator */
; 1645 :             ctlind = (seghdr[1] & 0x20);

  00154	b8 01 00 00 00	 mov	 eax, 1
  00159	48 6b c0 01	 imul	 rax, rax, 1
  0015d	0f b6 44 04 34	 movzx	 eax, BYTE PTR seghdr$[rsp+rax]
  00162	83 e0 20	 and	 eax, 32			; 00000020H
  00165	88 44 24 30	 mov	 BYTE PTR ctlind$[rsp], al
$LN8@read_xmit_:

; 1646 :         }
; 1647 : 
; 1648 :         /* Check flags for subsequent segments */
; 1649 :         if (segnum > 0)

  00169	83 7c 24 3c 00	 cmp	 DWORD PTR segnum$[rsp], 0
  0016e	7e 75		 jle	 SHORT $LN10@read_xmit_

; 1650 :         {
; 1651 :             /* Check that first segment indicator is not set */
; 1652 :             if (seghdr[1] & 0x80)

  00170	b8 01 00 00 00	 mov	 eax, 1
  00175	48 6b c0 01	 imul	 rax, rax, 1
  00179	0f b6 44 04 34	 movzx	 eax, BYTE PTR seghdr$[rsp+rax]
  0017e	25 80 00 00 00	 and	 eax, 128		; 00000080H
  00183	85 c0		 test	 eax, eax
  00185	74 22		 je	 SHORT $LN11@read_xmit_

; 1653 :             {
; 1654 :                 XMERRF ( MSG( HHC02536, "E", xfname ) );

  00187	4c 8b 44 24 78	 mov	 r8, QWORD PTR xfname$[rsp]
  0018c	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG161341
  00193	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG161342
  0019a	e8 00 00 00 00	 call	 printf

; 1655 :                 return -1;

  0019f	b8 ff ff ff ff	 mov	 eax, -1
  001a4	e9 0f 01 00 00	 jmp	 $LN1@read_xmit_
$LN11@read_xmit_:

; 1656 :             }
; 1657 : 
; 1658 :             /* Check if ctlrec indicator matches first segment */
; 1659 :             if ((seghdr[1] & 0x20) != ctlind)

  001a9	b8 01 00 00 00	 mov	 eax, 1
  001ae	48 6b c0 01	 imul	 rax, rax, 1
  001b2	0f b6 44 04 34	 movzx	 eax, BYTE PTR seghdr$[rsp+rax]
  001b7	83 e0 20	 and	 eax, 32			; 00000020H
  001ba	0f b6 4c 24 30	 movzx	 ecx, BYTE PTR ctlind$[rsp]
  001bf	3b c1		 cmp	 eax, ecx
  001c1	74 22		 je	 SHORT $LN12@read_xmit_

; 1660 :             {
; 1661 :                 XMERRF ( MSG( HHC02537, "E", xfname ) );

  001c3	4c 8b 44 24 78	 mov	 r8, QWORD PTR xfname$[rsp]
  001c8	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG161344
  001cf	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG161345
  001d6	e8 00 00 00 00	 call	 printf

; 1662 :                 return -1;

  001db	b8 ff ff ff ff	 mov	 eax, -1
  001e0	e9 d3 00 00 00	 jmp	 $LN1@read_xmit_
$LN12@read_xmit_:
$LN10@read_xmit_:

; 1663 :             }
; 1664 :         }
; 1665 : 
; 1666 :         /* Read segment data into buffer */
; 1667 :         seglen = seghdr[0] - 2;

  001e5	b8 01 00 00 00	 mov	 eax, 1
  001ea	48 6b c0 00	 imul	 rax, rax, 0
  001ee	0f b6 44 04 34	 movzx	 eax, BYTE PTR seghdr$[rsp+rax]
  001f3	83 e8 02	 sub	 eax, 2
  001f6	89 44 24 44	 mov	 DWORD PTR seglen$[rsp], eax

; 1668 :         rc = read (xfd, xbuf + xreclen, seglen);

  001fa	48 63 44 24 40	 movsxd	 rax, DWORD PTR xreclen$[rsp]
  001ff	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR xbuf$[rsp]
  00207	48 03 c8	 add	 rcx, rax
  0020a	48 8b c1	 mov	 rax, rcx
  0020d	44 8b 44 24 44	 mov	 r8d, DWORD PTR seglen$[rsp]
  00212	48 8b d0	 mov	 rdx, rax
  00215	8b 4c 24 70	 mov	 ecx, DWORD PTR xfd$[rsp]
  00219	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_read
  0021f	89 44 24 38	 mov	 DWORD PTR rc$[rsp], eax

; 1669 :         if (rc < seglen)

  00223	8b 44 24 44	 mov	 eax, DWORD PTR seglen$[rsp]
  00227	39 44 24 38	 cmp	 DWORD PTR rc$[rsp], eax
  0022b	7d 4c		 jge	 SHORT $LN13@read_xmit_

; 1670 :         {
; 1671 :             XMERRF ( MSG( HHC02533, "E", xfname, rc < 0 ? strerror(errno) : "Unexpected end of file" ) );

  0022d	83 7c 24 38 00	 cmp	 DWORD PTR rc$[rsp], 0
  00232	7d 15		 jge	 SHORT $LN18@read_xmit_
  00234	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno
  0023a	8b 08		 mov	 ecx, DWORD PTR [rax]
  0023c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_strerror
  00242	48 89 44 24 50	 mov	 QWORD PTR tv179[rsp], rax
  00247	eb 0c		 jmp	 SHORT $LN19@read_xmit_
$LN18@read_xmit_:
  00249	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG161347
  00250	48 89 44 24 50	 mov	 QWORD PTR tv179[rsp], rax
$LN19@read_xmit_:
  00255	4c 8b 4c 24 50	 mov	 r9, QWORD PTR tv179[rsp]
  0025a	4c 8b 44 24 78	 mov	 r8, QWORD PTR xfname$[rsp]
  0025f	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG161348
  00266	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG161349
  0026d	e8 00 00 00 00	 call	 printf

; 1672 :             return -1;

  00272	b8 ff ff ff ff	 mov	 eax, -1
  00277	eb 3f		 jmp	 SHORT $LN1@read_xmit_
$LN13@read_xmit_:

; 1673 :         }
; 1674 : 
; 1675 :         /* Accumulate total record length */
; 1676 :         xreclen += seglen;

  00279	8b 44 24 44	 mov	 eax, DWORD PTR seglen$[rsp]
  0027d	8b 4c 24 40	 mov	 ecx, DWORD PTR xreclen$[rsp]
  00281	03 c8		 add	 ecx, eax
  00283	8b c1		 mov	 eax, ecx
  00285	89 44 24 40	 mov	 DWORD PTR xreclen$[rsp], eax

; 1677 : 
; 1678 :         /* Exit if last segment of record */
; 1679 :         if (seghdr[1] & 0x40)

  00289	b8 01 00 00 00	 mov	 eax, 1
  0028e	48 6b c0 01	 imul	 rax, rax, 1
  00292	0f b6 44 04 34	 movzx	 eax, BYTE PTR seghdr$[rsp+rax]
  00297	83 e0 40	 and	 eax, 64			; 00000040H
  0029a	85 c0		 test	 eax, eax
  0029c	74 02		 je	 SHORT $LN14@read_xmit_

; 1680 :             break;

  0029e	eb 05		 jmp	 SHORT $LN3@read_xmit_
$LN14@read_xmit_:

; 1681 : 
; 1682 :     } /* end for(segnum) */

  002a0	e9 89 fd ff ff	 jmp	 $LN2@read_xmit_
$LN3@read_xmit_:

; 1683 : 
; 1684 :     /* Return record length and control indicator */
; 1685 :     *ctl = ctlind;

  002a5	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR ctl$[rsp]
  002ad	0f b6 4c 24 30	 movzx	 ecx, BYTE PTR ctlind$[rsp]
  002b2	88 08		 mov	 BYTE PTR [rax], cl

; 1686 :     return xreclen;

  002b4	8b 44 24 40	 mov	 eax, DWORD PTR xreclen$[rsp]
$LN1@read_xmit_:

; 1687 : 
; 1688 : } /* end function read_xmit_rec */

  002b8	48 83 c4 68	 add	 rsp, 104		; 00000068H
  002bc	c3		 ret	 0
read_xmit_rec ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\dasdload64.c
_TEXT	SEGMENT
c$ = 64
len$ = 68
offset$ = 72
num$ = 76
key$ = 80
i$ = 84
field$ = 88
j$ = 92
name$ = 96
chars$ = 104
hex$ = 120
__$ArrayPad$ = 144
xbuf$ = 176
bufpos$ = 184
bufrem$ = 192
pkey$ = 200
pnum$ = 208
maxnum$ = 216
plen$ = 224
pdata$ = 232
next_tu	PROC

; 1491 : {

  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  0000a	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  0000e	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00013	57		 push	 rdi
  00014	48 81 ec a0 00
	00 00		 sub	 rsp, 160		; 000000a0H
  0001b	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00022	48 33 c4	 xor	 rax, rsp
  00025	48 89 84 24 90
	00 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 1492 : int     i, j;                           /* Array subscripts          */
; 1493 : U16     key, num;                       /* Text unit header          */
; 1494 : int     field;                          /* Field number              */
; 1495 : int     offset;                         /* Offset into text unit     */
; 1496 : U16     len;                            /* Field length              */
; 1497 : char   *name;                           /* Text unit name            */
; 1498 : BYTE    c, chars[9];                    /* Character work areas      */
; 1499 : char    hex[17];                        /* Character work areas      */
; 1500 : 
; 1501 :     /* Error if remaining length is insufficient for header */
; 1502 :     if (bufrem < 4)

  0002d	83 bc 24 c0 00
	00 00 04	 cmp	 DWORD PTR bufrem$[rsp], 4
  00035	7d 1d		 jge	 SHORT $LN8@next_tu

; 1503 :     {
; 1504 :         XMERR ( MSG( HHC02531, "E" ) );

  00037	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG161283
  0003e	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG161284
  00045	e8 00 00 00 00	 call	 printf

; 1505 :         return -1;

  0004a	b8 ff ff ff ff	 mov	 eax, -1
  0004f	e9 3f 04 00 00	 jmp	 $LN1@next_tu
$LN8@next_tu:

; 1506 :     }
; 1507 : 
; 1508 :     /* Load the key and field count from the first 4 bytes */
; 1509 :     key = (xbuf[bufpos] << 8) | xbuf[bufpos+1];

  00054	48 63 84 24 b8
	00 00 00	 movsxd	 rax, DWORD PTR bufpos$[rsp]
  0005c	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR xbuf$[rsp]
  00064	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00068	c1 e0 08	 shl	 eax, 8
  0006b	8b 8c 24 b8 00
	00 00		 mov	 ecx, DWORD PTR bufpos$[rsp]
  00072	ff c1		 inc	 ecx
  00074	48 63 c9	 movsxd	 rcx, ecx
  00077	48 8b 94 24 b0
	00 00 00	 mov	 rdx, QWORD PTR xbuf$[rsp]
  0007f	0f b6 0c 0a	 movzx	 ecx, BYTE PTR [rdx+rcx]
  00083	0b c1		 or	 eax, ecx
  00085	66 89 44 24 50	 mov	 WORD PTR key$[rsp], ax

; 1510 :     num = (xbuf[bufpos+2] << 8) | xbuf[bufpos+3];

  0008a	8b 84 24 b8 00
	00 00		 mov	 eax, DWORD PTR bufpos$[rsp]
  00091	83 c0 02	 add	 eax, 2
  00094	48 98		 cdqe
  00096	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR xbuf$[rsp]
  0009e	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  000a2	c1 e0 08	 shl	 eax, 8
  000a5	8b 8c 24 b8 00
	00 00		 mov	 ecx, DWORD PTR bufpos$[rsp]
  000ac	83 c1 03	 add	 ecx, 3
  000af	48 63 c9	 movsxd	 rcx, ecx
  000b2	48 8b 94 24 b0
	00 00 00	 mov	 rdx, QWORD PTR xbuf$[rsp]
  000ba	0f b6 0c 0a	 movzx	 ecx, BYTE PTR [rdx+rcx]
  000be	0b c1		 or	 eax, ecx
  000c0	66 89 44 24 4c	 mov	 WORD PTR num$[rsp], ax

; 1511 : 
; 1512 :     /* Obtain the text unit name */
; 1513 :     name = tu_name(key);

  000c5	0f b7 4c 24 50	 movzx	 ecx, WORD PTR key$[rsp]
  000ca	e8 00 00 00 00	 call	 tu_name
  000cf	48 89 44 24 60	 mov	 QWORD PTR name$[rsp], rax

; 1514 : 
; 1515 :     /* Print the text unit name and field count */
; 1516 :     XMINFF (4, MSG_C( HHC02526, "I", bufpos, name, key, num ) );

  000d4	0f b7 44 24 4c	 movzx	 eax, WORD PTR num$[rsp]
  000d9	0f b7 4c 24 50	 movzx	 ecx, WORD PTR key$[rsp]
  000de	89 44 24 30	 mov	 DWORD PTR [rsp+48], eax
  000e2	89 4c 24 28	 mov	 DWORD PTR [rsp+40], ecx
  000e6	48 8b 44 24 60	 mov	 rax, QWORD PTR name$[rsp]
  000eb	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  000f0	44 8b 8c 24 b8
	00 00 00	 mov	 r9d, DWORD PTR bufpos$[rsp]
  000f8	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG161285
  000ff	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG161286
  00106	b9 04 00 00 00	 mov	 ecx, 4
  0010b	e8 00 00 00 00	 call	 info_msg

; 1517 : 
; 1518 :     /* Error if number of fields exceeds maximum */
; 1519 :     if (num > maxnum)

  00110	0f b7 44 24 4c	 movzx	 eax, WORD PTR num$[rsp]
  00115	0f b7 8c 24 d8
	00 00 00	 movzx	 ecx, WORD PTR maxnum$[rsp]
  0011d	3b c1		 cmp	 eax, ecx
  0011f	7e 2e		 jle	 SHORT $LN9@next_tu

; 1520 :     {
; 1521 :         XMINF (4, "\n");

  00121	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG161288
  00128	b9 04 00 00 00	 mov	 ecx, 4
  0012d	e8 00 00 00 00	 call	 info_msg

; 1522 :         XMERR ( MSG( HHC02532, "E" ) );

  00132	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG161289
  00139	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG161290
  00140	e8 00 00 00 00	 call	 printf

; 1523 :         return -1;

  00145	b8 ff ff ff ff	 mov	 eax, -1
  0014a	e9 44 03 00 00	 jmp	 $LN1@next_tu
$LN9@next_tu:

; 1524 :     }
; 1525 : 
; 1526 :     /* Point to first field */
; 1527 :     offset = 4;

  0014f	c7 44 24 48 04
	00 00 00	 mov	 DWORD PTR offset$[rsp], 4

; 1528 :     bufrem -= 4;

  00157	8b 84 24 c0 00
	00 00		 mov	 eax, DWORD PTR bufrem$[rsp]
  0015e	83 e8 04	 sub	 eax, 4
  00161	89 84 24 c0 00
	00 00		 mov	 DWORD PTR bufrem$[rsp], eax

; 1529 : 
; 1530 :     /* Process each field in text unit */
; 1531 :     for (field = 0; field < num; field++)

  00168	c7 44 24 58 00
	00 00 00	 mov	 DWORD PTR field$[rsp], 0
  00170	eb 0a		 jmp	 SHORT $LN4@next_tu
$LN2@next_tu:
  00172	8b 44 24 58	 mov	 eax, DWORD PTR field$[rsp]
  00176	ff c0		 inc	 eax
  00178	89 44 24 58	 mov	 DWORD PTR field$[rsp], eax
$LN4@next_tu:
  0017c	0f b7 44 24 4c	 movzx	 eax, WORD PTR num$[rsp]
  00181	39 44 24 58	 cmp	 DWORD PTR field$[rsp], eax
  00185	0f 8d d3 02 00
	00		 jge	 $LN3@next_tu

; 1532 :     {
; 1533 :         /* Error if remaining length is insufficient for length */
; 1534 :         if (bufrem < 2)

  0018b	83 bc 24 c0 00
	00 00 02	 cmp	 DWORD PTR bufrem$[rsp], 2
  00193	7d 2e		 jge	 SHORT $LN10@next_tu

; 1535 :         {
; 1536 :             XMINF (4, "\n");

  00195	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG161292
  0019c	b9 04 00 00 00	 mov	 ecx, 4
  001a1	e8 00 00 00 00	 call	 info_msg

; 1537 :             XMERR ( MSG( HHC02531, "E" ) );

  001a6	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG161293
  001ad	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG161294
  001b4	e8 00 00 00 00	 call	 printf

; 1538 :             return -1;

  001b9	b8 ff ff ff ff	 mov	 eax, -1
  001be	e9 d0 02 00 00	 jmp	 $LN1@next_tu
$LN10@next_tu:

; 1539 :         }
; 1540 : 
; 1541 :         /* Load field length from next 2 bytes */
; 1542 :         len = (xbuf[bufpos+offset] << 8) | xbuf[bufpos+offset+1];

  001c3	8b 44 24 48	 mov	 eax, DWORD PTR offset$[rsp]
  001c7	8b 8c 24 b8 00
	00 00		 mov	 ecx, DWORD PTR bufpos$[rsp]
  001ce	03 c8		 add	 ecx, eax
  001d0	8b c1		 mov	 eax, ecx
  001d2	48 98		 cdqe
  001d4	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR xbuf$[rsp]
  001dc	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  001e0	c1 e0 08	 shl	 eax, 8
  001e3	8b 8c 24 b8 00
	00 00		 mov	 ecx, DWORD PTR bufpos$[rsp]
  001ea	8b 54 24 48	 mov	 edx, DWORD PTR offset$[rsp]
  001ee	8d 4c 11 01	 lea	 ecx, DWORD PTR [rcx+rdx+1]
  001f2	48 63 c9	 movsxd	 rcx, ecx
  001f5	48 8b 94 24 b0
	00 00 00	 mov	 rdx, QWORD PTR xbuf$[rsp]
  001fd	0f b6 0c 0a	 movzx	 ecx, BYTE PTR [rdx+rcx]
  00201	0b c1		 or	 eax, ecx
  00203	66 89 44 24 44	 mov	 WORD PTR len$[rsp], ax

; 1543 :         offset += 2;

  00208	8b 44 24 48	 mov	 eax, DWORD PTR offset$[rsp]
  0020c	83 c0 02	 add	 eax, 2
  0020f	89 44 24 48	 mov	 DWORD PTR offset$[rsp], eax

; 1544 :         bufrem -= 2;

  00213	8b 84 24 c0 00
	00 00		 mov	 eax, DWORD PTR bufrem$[rsp]
  0021a	83 e8 02	 sub	 eax, 2
  0021d	89 84 24 c0 00
	00 00		 mov	 DWORD PTR bufrem$[rsp], eax

; 1545 : 
; 1546 :         /* Error if remaining length is insufficient for data */
; 1547 :         if (bufrem < len)

  00224	0f b7 44 24 44	 movzx	 eax, WORD PTR len$[rsp]
  00229	39 84 24 c0 00
	00 00		 cmp	 DWORD PTR bufrem$[rsp], eax
  00230	7d 2e		 jge	 SHORT $LN11@next_tu

; 1548 :         {
; 1549 :             XMINF (4, "\n");

  00232	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG161296
  00239	b9 04 00 00 00	 mov	 ecx, 4
  0023e	e8 00 00 00 00	 call	 info_msg

; 1550 :             XMERR ( MSG( HHC02531, "E" ) );

  00243	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG161297
  0024a	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG161298
  00251	e8 00 00 00 00	 call	 printf

; 1551 :             return -1;

  00256	b8 ff ff ff ff	 mov	 eax, -1
  0025b	e9 33 02 00 00	 jmp	 $LN1@next_tu
$LN11@next_tu:

; 1552 :         }
; 1553 : 
; 1554 :         /* Print field length and data */
; 1555 :         if (field > 0) XMINF (4, "\n\t\t\t\t ");

  00260	83 7c 24 58 00	 cmp	 DWORD PTR field$[rsp], 0
  00265	7e 11		 jle	 SHORT $LN12@next_tu
  00267	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG161300
  0026e	b9 04 00 00 00	 mov	 ecx, 4
  00273	e8 00 00 00 00	 call	 info_msg
$LN12@next_tu:

; 1556 :         XMINFF (4, "%04X ", len);

  00278	0f b7 44 24 44	 movzx	 eax, WORD PTR len$[rsp]
  0027d	44 8b c0	 mov	 r8d, eax
  00280	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG161301
  00287	b9 04 00 00 00	 mov	 ecx, 4
  0028c	e8 00 00 00 00	 call	 info_msg

; 1557 :         memset (hex, 0, sizeof(hex));

  00291	48 8d 44 24 78	 lea	 rax, QWORD PTR hex$[rsp]
  00296	48 8b f8	 mov	 rdi, rax
  00299	33 c0		 xor	 eax, eax
  0029b	b9 11 00 00 00	 mov	 ecx, 17
  002a0	f3 aa		 rep stosb

; 1558 :         memset (chars, 0, sizeof(chars));

  002a2	48 8d 44 24 68	 lea	 rax, QWORD PTR chars$[rsp]
  002a7	48 8b f8	 mov	 rdi, rax
  002aa	33 c0		 xor	 eax, eax
  002ac	b9 09 00 00 00	 mov	 ecx, 9
  002b1	f3 aa		 rep stosb

; 1559 :         for (i = 0, j = 0; i < len; i++, j++)

  002b3	c7 44 24 54 00
	00 00 00	 mov	 DWORD PTR i$[rsp], 0
  002bb	c7 44 24 5c 00
	00 00 00	 mov	 DWORD PTR j$[rsp], 0
  002c3	eb 14		 jmp	 SHORT $LN7@next_tu
$LN5@next_tu:
  002c5	8b 44 24 54	 mov	 eax, DWORD PTR i$[rsp]
  002c9	ff c0		 inc	 eax
  002cb	89 44 24 54	 mov	 DWORD PTR i$[rsp], eax
  002cf	8b 44 24 5c	 mov	 eax, DWORD PTR j$[rsp]
  002d3	ff c0		 inc	 eax
  002d5	89 44 24 5c	 mov	 DWORD PTR j$[rsp], eax
$LN7@next_tu:
  002d9	0f b7 44 24 44	 movzx	 eax, WORD PTR len$[rsp]
  002de	39 44 24 54	 cmp	 DWORD PTR i$[rsp], eax
  002e2	0f 8d e9 00 00
	00		 jge	 $LN6@next_tu

; 1560 :         {
; 1561 :             if (i > 0 && (i & 0x07) == 0)

  002e8	83 7c 24 54 00	 cmp	 DWORD PTR i$[rsp], 0
  002ed	7e 50		 jle	 SHORT $LN13@next_tu
  002ef	8b 44 24 54	 mov	 eax, DWORD PTR i$[rsp]
  002f3	83 e0 07	 and	 eax, 7
  002f6	85 c0		 test	 eax, eax
  002f8	75 45		 jne	 SHORT $LN13@next_tu

; 1562 :             {
; 1563 :                 XMINFF (4, "%-16.16s %-8.8s\n\t\t\t\t      ",

  002fa	4c 8d 4c 24 68	 lea	 r9, QWORD PTR chars$[rsp]
  002ff	4c 8d 44 24 78	 lea	 r8, QWORD PTR hex$[rsp]
  00304	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG161303
  0030b	b9 04 00 00 00	 mov	 ecx, 4
  00310	e8 00 00 00 00	 call	 info_msg

; 1564 :                     hex, chars);
; 1565 :                 memset (hex, 0, sizeof(hex));

  00315	48 8d 44 24 78	 lea	 rax, QWORD PTR hex$[rsp]
  0031a	48 8b f8	 mov	 rdi, rax
  0031d	33 c0		 xor	 eax, eax
  0031f	b9 11 00 00 00	 mov	 ecx, 17
  00324	f3 aa		 rep stosb

; 1566 :                 memset (chars, 0, sizeof(chars));

  00326	48 8d 44 24 68	 lea	 rax, QWORD PTR chars$[rsp]
  0032b	48 8b f8	 mov	 rdi, rax
  0032e	33 c0		 xor	 eax, eax
  00330	b9 09 00 00 00	 mov	 ecx, 9
  00335	f3 aa		 rep stosb

; 1567 :                 j = 0;

  00337	c7 44 24 5c 00
	00 00 00	 mov	 DWORD PTR j$[rsp], 0
$LN13@next_tu:

; 1568 :             }
; 1569 :             sprintf(hex+2*j, "%2.2X", xbuf[bufpos+offset+i]);

  0033f	8b 44 24 48	 mov	 eax, DWORD PTR offset$[rsp]
  00343	8b 8c 24 b8 00
	00 00		 mov	 ecx, DWORD PTR bufpos$[rsp]
  0034a	03 c8		 add	 ecx, eax
  0034c	8b c1		 mov	 eax, ecx
  0034e	03 44 24 54	 add	 eax, DWORD PTR i$[rsp]
  00352	48 98		 cdqe
  00354	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR xbuf$[rsp]
  0035c	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00360	8b 4c 24 5c	 mov	 ecx, DWORD PTR j$[rsp]
  00364	d1 e1		 shl	 ecx, 1
  00366	48 63 c9	 movsxd	 rcx, ecx
  00369	48 8d 4c 0c 78	 lea	 rcx, QWORD PTR hex$[rsp+rcx]
  0036e	44 8b c0	 mov	 r8d, eax
  00371	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG161304
  00378	e8 00 00 00 00	 call	 sprintf

; 1570 :             c = guest_to_host(xbuf[bufpos+offset+i]);

  0037d	8b 44 24 48	 mov	 eax, DWORD PTR offset$[rsp]
  00381	8b 8c 24 b8 00
	00 00		 mov	 ecx, DWORD PTR bufpos$[rsp]
  00388	03 c8		 add	 ecx, eax
  0038a	8b c1		 mov	 eax, ecx
  0038c	03 44 24 54	 add	 eax, DWORD PTR i$[rsp]
  00390	48 98		 cdqe
  00392	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR xbuf$[rsp]
  0039a	0f b6 0c 01	 movzx	 ecx, BYTE PTR [rcx+rax]
  0039e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_guest_to_host
  003a4	88 44 24 40	 mov	 BYTE PTR c$[rsp], al

; 1571 :             if (!isprint(c)) c = '.';

  003a8	0f b6 44 24 40	 movzx	 eax, BYTE PTR c$[rsp]
  003ad	8b c8		 mov	 ecx, eax
  003af	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_isprint
  003b5	85 c0		 test	 eax, eax
  003b7	75 05		 jne	 SHORT $LN14@next_tu
  003b9	c6 44 24 40 2e	 mov	 BYTE PTR c$[rsp], 46	; 0000002eH
$LN14@next_tu:

; 1572 :             chars[j] = c;

  003be	48 63 44 24 5c	 movsxd	 rax, DWORD PTR j$[rsp]
  003c3	0f b6 4c 24 40	 movzx	 ecx, BYTE PTR c$[rsp]
  003c8	88 4c 04 68	 mov	 BYTE PTR chars$[rsp+rax], cl

; 1573 :         } /* end for(i) */

  003cc	e9 f4 fe ff ff	 jmp	 $LN5@next_tu
$LN6@next_tu:

; 1574 :         XMINFF (4, "%-16.16s %-8.8s", hex, chars);

  003d1	4c 8d 4c 24 68	 lea	 r9, QWORD PTR chars$[rsp]
  003d6	4c 8d 44 24 78	 lea	 r8, QWORD PTR hex$[rsp]
  003db	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG161306
  003e2	b9 04 00 00 00	 mov	 ecx, 4
  003e7	e8 00 00 00 00	 call	 info_msg

; 1575 : 
; 1576 :         /* Save field length and pointer in array */
; 1577 :         plen[field] = len;

  003ec	48 63 44 24 58	 movsxd	 rax, DWORD PTR field$[rsp]
  003f1	48 8b 8c 24 e0
	00 00 00	 mov	 rcx, QWORD PTR plen$[rsp]
  003f9	0f b7 54 24 44	 movzx	 edx, WORD PTR len$[rsp]
  003fe	66 89 14 41	 mov	 WORD PTR [rcx+rax*2], dx

; 1578 :         pdata[field] = xbuf + bufpos + offset;

  00402	48 63 84 24 b8
	00 00 00	 movsxd	 rax, DWORD PTR bufpos$[rsp]
  0040a	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR xbuf$[rsp]
  00412	48 03 c8	 add	 rcx, rax
  00415	48 8b c1	 mov	 rax, rcx
  00418	48 63 4c 24 48	 movsxd	 rcx, DWORD PTR offset$[rsp]
  0041d	48 03 c1	 add	 rax, rcx
  00420	48 63 4c 24 58	 movsxd	 rcx, DWORD PTR field$[rsp]
  00425	48 8b 94 24 e8
	00 00 00	 mov	 rdx, QWORD PTR pdata$[rsp]
  0042d	48 89 04 ca	 mov	 QWORD PTR [rdx+rcx*8], rax

; 1579 : 
; 1580 :         /* Get offset of next field in text unit */
; 1581 :         offset += len;

  00431	0f b7 44 24 44	 movzx	 eax, WORD PTR len$[rsp]
  00436	8b 4c 24 48	 mov	 ecx, DWORD PTR offset$[rsp]
  0043a	03 c8		 add	 ecx, eax
  0043c	8b c1		 mov	 eax, ecx
  0043e	89 44 24 48	 mov	 DWORD PTR offset$[rsp], eax

; 1582 :         bufrem -= len;

  00442	0f b7 44 24 44	 movzx	 eax, WORD PTR len$[rsp]
  00447	8b 8c 24 c0 00
	00 00		 mov	 ecx, DWORD PTR bufrem$[rsp]
  0044e	2b c8		 sub	 ecx, eax
  00450	8b c1		 mov	 eax, ecx
  00452	89 84 24 c0 00
	00 00		 mov	 DWORD PTR bufrem$[rsp], eax

; 1583 : 
; 1584 :     } /* end for */

  00459	e9 14 fd ff ff	 jmp	 $LN2@next_tu
$LN3@next_tu:

; 1585 : 
; 1586 :     /* Print newline at end of text unit */
; 1587 :     XMINF (4, "\n");

  0045e	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG161307
  00465	b9 04 00 00 00	 mov	 ecx, 4
  0046a	e8 00 00 00 00	 call	 info_msg

; 1588 : 
; 1589 :     /* Return key, number of fields, and total length */
; 1590 :     *pkey = key;

  0046f	48 8b 84 24 c8
	00 00 00	 mov	 rax, QWORD PTR pkey$[rsp]
  00477	0f b7 4c 24 50	 movzx	 ecx, WORD PTR key$[rsp]
  0047c	66 89 08	 mov	 WORD PTR [rax], cx

; 1591 :     *pnum = num;

  0047f	48 8b 84 24 d0
	00 00 00	 mov	 rax, QWORD PTR pnum$[rsp]
  00487	0f b7 4c 24 4c	 movzx	 ecx, WORD PTR num$[rsp]
  0048c	66 89 08	 mov	 WORD PTR [rax], cx

; 1592 :     return offset;

  0048f	8b 44 24 48	 mov	 eax, DWORD PTR offset$[rsp]
$LN1@next_tu:

; 1593 : 
; 1594 : } /* end function next_tu */

  00493	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  0049b	48 33 cc	 xor	 rcx, rsp
  0049e	e8 00 00 00 00	 call	 __security_check_cookie
  004a3	48 81 c4 a0 00
	00 00		 add	 rsp, 160		; 000000a0H
  004aa	5f		 pop	 rdi
  004ab	c3		 ret	 0
next_tu	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\dasdload64.c
_TEXT	SEGMENT
tv65 = 0
key$ = 32
tu_name	PROC

; 1434 : {

  00000	66 89 4c 24 08	 mov	 WORD PTR [rsp+8], cx
  00005	48 83 ec 18	 sub	 rsp, 24

; 1435 :     switch (key) {

  00009	0f b7 44 24 20	 movzx	 eax, WORD PTR key$[rsp]
  0000e	89 04 24	 mov	 DWORD PTR tv65[rsp], eax
  00011	81 3c 24 01 10
	00 00		 cmp	 DWORD PTR tv65[rsp], 4097 ; 00001001H
  00018	7f 3e		 jg	 SHORT $LN34@tu_name
  0001a	81 3c 24 01 10
	00 00		 cmp	 DWORD PTR tv65[rsp], 4097 ; 00001001H
  00021	0f 84 f8 00 00
	00		 je	 $LN14@tu_name
  00027	8b 04 24	 mov	 eax, DWORD PTR tv65[rsp]
  0002a	ff c8		 dec	 eax
  0002c	89 04 24	 mov	 DWORD PTR tv65[rsp], eax
  0002f	83 3c 24 48	 cmp	 DWORD PTR tv65[rsp], 72	; 00000048H
  00033	0f 87 a0 01 00
	00		 ja	 $LN2@tu_name
  00039	48 63 04 24	 movsxd	 rax, DWORD PTR tv65[rsp]
  0003d	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__ImageBase
  00044	0f b6 84 01 00
	00 00 00	 movzx	 eax, BYTE PTR $LN38@tu_name[rcx+rax]
  0004c	8b 84 81 00 00
	00 00		 mov	 eax, DWORD PTR $LN39@tu_name[rcx+rax*4]
  00053	48 03 c1	 add	 rax, rcx
  00056	ff e0		 jmp	 rax
$LN34@tu_name:
  00058	81 3c 24 12 80
	00 00		 cmp	 DWORD PTR tv65[rsp], 32786 ; 00008012H
  0005f	7f 41		 jg	 SHORT $LN35@tu_name
  00061	81 3c 24 12 80
	00 00		 cmp	 DWORD PTR tv65[rsp], 32786 ; 00008012H
  00068	0f 84 62 01 00
	00		 je	 $LN32@tu_name
  0006e	8b 04 24	 mov	 eax, DWORD PTR tv65[rsp]
  00071	2d 02 10 00 00	 sub	 eax, 4098		; 00001002H
  00076	89 04 24	 mov	 DWORD PTR tv65[rsp], eax
  00079	83 3c 24 2d	 cmp	 DWORD PTR tv65[rsp], 45	; 0000002dH
  0007d	0f 87 56 01 00
	00		 ja	 $LN2@tu_name
  00083	48 63 04 24	 movsxd	 rax, DWORD PTR tv65[rsp]
  00087	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__ImageBase
  0008e	0f b6 84 01 00
	00 00 00	 movzx	 eax, BYTE PTR $LN36@tu_name[rcx+rax]
  00096	8b 84 81 00 00
	00 00		 mov	 eax, DWORD PTR $LN37@tu_name[rcx+rax*4]
  0009d	48 03 c1	 add	 rax, rcx
  000a0	ff e0		 jmp	 rax
$LN35@tu_name:
  000a2	e9 32 01 00 00	 jmp	 $LN2@tu_name
$LN4@tu_name:

; 1436 :     CASERET(INMDDNAM);

  000a7	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG161189
  000ae	e9 2d 01 00 00	 jmp	 $LN1@tu_name
$LN5@tu_name:

; 1437 :     CASERET(INMDSNAM);

  000b3	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG161191
  000ba	e9 21 01 00 00	 jmp	 $LN1@tu_name
$LN6@tu_name:

; 1438 :     CASERET(INMMEMBR);

  000bf	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG161193
  000c6	e9 15 01 00 00	 jmp	 $LN1@tu_name
$LN7@tu_name:

; 1439 :     CASERET(INMDIR  );

  000cb	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG161195
  000d2	e9 09 01 00 00	 jmp	 $LN1@tu_name
$LN8@tu_name:

; 1440 :     CASERET(INMEXPDT);

  000d7	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG161197
  000de	e9 fd 00 00 00	 jmp	 $LN1@tu_name
$LN9@tu_name:

; 1441 :     CASERET(INMTERM );

  000e3	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG161199
  000ea	e9 f1 00 00 00	 jmp	 $LN1@tu_name
$LN10@tu_name:

; 1442 :     CASERET(INMBLKSZ);

  000ef	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG161201
  000f6	e9 e5 00 00 00	 jmp	 $LN1@tu_name
$LN11@tu_name:

; 1443 :     CASERET(INMDSORG);

  000fb	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG161203
  00102	e9 d9 00 00 00	 jmp	 $LN1@tu_name
$LN12@tu_name:

; 1444 :     CASERET(INMLRECL);

  00107	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG161205
  0010e	e9 cd 00 00 00	 jmp	 $LN1@tu_name
$LN13@tu_name:

; 1445 :     CASERET(INMRECFM);

  00113	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG161207
  0011a	e9 c1 00 00 00	 jmp	 $LN1@tu_name
$LN14@tu_name:

; 1446 :     CASERET(INMTNODE);

  0011f	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG161209
  00126	e9 b5 00 00 00	 jmp	 $LN1@tu_name
$LN15@tu_name:

; 1447 :     CASERET(INMTUID );

  0012b	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG161211
  00132	e9 a9 00 00 00	 jmp	 $LN1@tu_name
$LN16@tu_name:

; 1448 :     CASERET(INMFNODE);

  00137	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG161213
  0013e	e9 9d 00 00 00	 jmp	 $LN1@tu_name
$LN17@tu_name:

; 1449 :     CASERET(INMFUID );

  00143	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG161215
  0014a	e9 91 00 00 00	 jmp	 $LN1@tu_name
$LN18@tu_name:

; 1450 :     CASERET(INMLREF );

  0014f	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG161217
  00156	e9 85 00 00 00	 jmp	 $LN1@tu_name
$LN19@tu_name:

; 1451 :     CASERET(INMLCHG );

  0015b	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG161219
  00162	eb 7c		 jmp	 SHORT $LN1@tu_name
$LN20@tu_name:

; 1452 :     CASERET(INMCREAT);

  00164	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG161221
  0016b	eb 73		 jmp	 SHORT $LN1@tu_name
$LN21@tu_name:

; 1453 :     CASERET(INMFVERS);

  0016d	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG161223
  00174	eb 6a		 jmp	 SHORT $LN1@tu_name
$LN22@tu_name:

; 1454 :     CASERET(INMFTIME);

  00176	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG161225
  0017d	eb 61		 jmp	 SHORT $LN1@tu_name
$LN23@tu_name:

; 1455 :     CASERET(INMTTIME);

  0017f	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG161227
  00186	eb 58		 jmp	 SHORT $LN1@tu_name
$LN24@tu_name:

; 1456 :     CASERET(INMFACK );

  00188	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG161229
  0018f	eb 4f		 jmp	 SHORT $LN1@tu_name
$LN25@tu_name:

; 1457 :     CASERET(INMERRCD);

  00191	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG161231
  00198	eb 46		 jmp	 SHORT $LN1@tu_name
$LN26@tu_name:

; 1458 :     CASERET(INMUTILN);

  0019a	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG161233
  001a1	eb 3d		 jmp	 SHORT $LN1@tu_name
$LN27@tu_name:

; 1459 :     CASERET(INMUSERP);

  001a3	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG161235
  001aa	eb 34		 jmp	 SHORT $LN1@tu_name
$LN28@tu_name:

; 1460 :     CASERET(INMRECCT);

  001ac	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG161237
  001b3	eb 2b		 jmp	 SHORT $LN1@tu_name
$LN29@tu_name:

; 1461 :     CASERET(INMSIZE );

  001b5	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG161239
  001bc	eb 22		 jmp	 SHORT $LN1@tu_name
$LN30@tu_name:

; 1462 :     CASERET(INMFFM  );

  001be	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG161241
  001c5	eb 19		 jmp	 SHORT $LN1@tu_name
$LN31@tu_name:

; 1463 :     CASERET(INMNUMF );

  001c7	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG161243
  001ce	eb 10		 jmp	 SHORT $LN1@tu_name
$LN32@tu_name:

; 1464 :     CASERET(INMTYPE );

  001d0	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG161245
  001d7	eb 07		 jmp	 SHORT $LN1@tu_name
$LN2@tu_name:

; 1465 :     } /* end switch(key) */
; 1466 : 
; 1467 :     return "????????";

  001d9	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG161246
$LN1@tu_name:

; 1468 : 
; 1469 : } /* end function tu_name */

  001e0	48 83 c4 18	 add	 rsp, 24
  001e4	c3		 ret	 0
  001e5	0f 1f 00	 npad	 3
$LN39@tu_name:
  001e8	00 00 00 00	 DD	 $LN4@tu_name
  001ec	00 00 00 00	 DD	 $LN5@tu_name
  001f0	00 00 00 00	 DD	 $LN6@tu_name
  001f4	00 00 00 00	 DD	 $LN7@tu_name
  001f8	00 00 00 00	 DD	 $LN8@tu_name
  001fc	00 00 00 00	 DD	 $LN9@tu_name
  00200	00 00 00 00	 DD	 $LN10@tu_name
  00204	00 00 00 00	 DD	 $LN11@tu_name
  00208	00 00 00 00	 DD	 $LN12@tu_name
  0020c	00 00 00 00	 DD	 $LN13@tu_name
  00210	00 00 00 00	 DD	 $LN2@tu_name
$LN38@tu_name:
  00214	00		 DB	 0
  00215	01		 DB	 1
  00216	02		 DB	 2
  00217	0a		 DB	 10
  00218	0a		 DB	 10
  00219	0a		 DB	 10
  0021a	0a		 DB	 10
  0021b	0a		 DB	 10
  0021c	0a		 DB	 10
  0021d	0a		 DB	 10
  0021e	0a		 DB	 10
  0021f	03		 DB	 3
  00220	0a		 DB	 10
  00221	0a		 DB	 10
  00222	0a		 DB	 10
  00223	0a		 DB	 10
  00224	0a		 DB	 10
  00225	0a		 DB	 10
  00226	0a		 DB	 10
  00227	0a		 DB	 10
  00228	0a		 DB	 10
  00229	0a		 DB	 10
  0022a	0a		 DB	 10
  0022b	0a		 DB	 10
  0022c	0a		 DB	 10
  0022d	0a		 DB	 10
  0022e	0a		 DB	 10
  0022f	0a		 DB	 10
  00230	0a		 DB	 10
  00231	0a		 DB	 10
  00232	0a		 DB	 10
  00233	0a		 DB	 10
  00234	0a		 DB	 10
  00235	04		 DB	 4
  00236	0a		 DB	 10
  00237	0a		 DB	 10
  00238	0a		 DB	 10
  00239	0a		 DB	 10
  0023a	0a		 DB	 10
  0023b	05		 DB	 5
  0023c	0a		 DB	 10
  0023d	0a		 DB	 10
  0023e	0a		 DB	 10
  0023f	0a		 DB	 10
  00240	0a		 DB	 10
  00241	0a		 DB	 10
  00242	0a		 DB	 10
  00243	06		 DB	 6
  00244	0a		 DB	 10
  00245	0a		 DB	 10
  00246	0a		 DB	 10
  00247	0a		 DB	 10
  00248	0a		 DB	 10
  00249	0a		 DB	 10
  0024a	0a		 DB	 10
  0024b	0a		 DB	 10
  0024c	0a		 DB	 10
  0024d	0a		 DB	 10
  0024e	0a		 DB	 10
  0024f	07		 DB	 7
  00250	0a		 DB	 10
  00251	0a		 DB	 10
  00252	0a		 DB	 10
  00253	0a		 DB	 10
  00254	0a		 DB	 10
  00255	08		 DB	 8
  00256	0a		 DB	 10
  00257	0a		 DB	 10
  00258	0a		 DB	 10
  00259	0a		 DB	 10
  0025a	0a		 DB	 10
  0025b	0a		 DB	 10
  0025c	09		 DB	 9
  0025d	0f 1f 00	 npad	 3
$LN37@tu_name:
  00260	00 00 00 00	 DD	 $LN15@tu_name
  00264	00 00 00 00	 DD	 $LN16@tu_name
  00268	00 00 00 00	 DD	 $LN17@tu_name
  0026c	00 00 00 00	 DD	 $LN18@tu_name
  00270	00 00 00 00	 DD	 $LN19@tu_name
  00274	00 00 00 00	 DD	 $LN20@tu_name
  00278	00 00 00 00	 DD	 $LN21@tu_name
  0027c	00 00 00 00	 DD	 $LN22@tu_name
  00280	00 00 00 00	 DD	 $LN23@tu_name
  00284	00 00 00 00	 DD	 $LN24@tu_name
  00288	00 00 00 00	 DD	 $LN25@tu_name
  0028c	00 00 00 00	 DD	 $LN26@tu_name
  00290	00 00 00 00	 DD	 $LN27@tu_name
  00294	00 00 00 00	 DD	 $LN28@tu_name
  00298	00 00 00 00	 DD	 $LN29@tu_name
  0029c	00 00 00 00	 DD	 $LN30@tu_name
  002a0	00 00 00 00	 DD	 $LN31@tu_name
  002a4	00 00 00 00	 DD	 $LN2@tu_name
$LN36@tu_name:
  002a8	00		 DB	 0
  002a9	11		 DB	 17
  002aa	11		 DB	 17
  002ab	11		 DB	 17
  002ac	11		 DB	 17
  002ad	11		 DB	 17
  002ae	11		 DB	 17
  002af	11		 DB	 17
  002b0	11		 DB	 17
  002b1	11		 DB	 17
  002b2	11		 DB	 17
  002b3	11		 DB	 17
  002b4	11		 DB	 17
  002b5	11		 DB	 17
  002b6	11		 DB	 17
  002b7	01		 DB	 1
  002b8	02		 DB	 2
  002b9	11		 DB	 17
  002ba	11		 DB	 17
  002bb	11		 DB	 17
  002bc	11		 DB	 17
  002bd	11		 DB	 17
  002be	11		 DB	 17
  002bf	11		 DB	 17
  002c0	11		 DB	 17
  002c1	11		 DB	 17
  002c2	11		 DB	 17
  002c3	11		 DB	 17
  002c4	11		 DB	 17
  002c5	11		 DB	 17
  002c6	03		 DB	 3
  002c7	04		 DB	 4
  002c8	05		 DB	 5
  002c9	06		 DB	 6
  002ca	07		 DB	 7
  002cb	08		 DB	 8
  002cc	09		 DB	 9
  002cd	0a		 DB	 10
  002ce	0b		 DB	 11
  002cf	0c		 DB	 12
  002d0	0d		 DB	 13
  002d1	11		 DB	 17
  002d2	0e		 DB	 14
  002d3	0f		 DB	 15
  002d4	11		 DB	 17
  002d5	10		 DB	 16
tu_name	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\dasdload64.c
_TEXT	SEGMENT
outcyl$ = 128
outhead$ = 132
abstrk$ = 136
rc$ = 140
i$ = 144
numtrks$ = 148
numcyls$ = 152
f4dscb$ = 160
outrec$ = 168
mintrks$ = 172
outtrk$ = 176
dscbpertrk$ = 180
outusedv$ = 184
prealloc$ = 188
curhead$ = 192
curcyl$ = 196
datablk$ = 200
highhead$ = 208
tv244 = 212
endhead$ = 216
endcyl$ = 220
tv342 = 224
tv343 = 228
numf0dscb$ = 232
outusedr$ = 236
tv66 = 240
highcyl$ = 244
highrec$ = 248
outtrkbr$ = 252
tv83 = 256
tv218 = 264
f1dscb$ = 272
dsnama$ = 280
blankblk$ = 336
__$ArrayPad$ = 496
dscbtab$ = 528
numdscb$ = 536
cif$ = 544
ofname$ = 552
devtype$ = 560
reqcyls$ = 568
heads$ = 576
trklen$ = 584
vtoctrk$ = 592
vtocext$ = 600
nxtcyl$ = 608
nxthead$ = 616
volvtoc$ = 624
write_vtoc PROC

; 1210 : {

  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  0000e	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00013	57		 push	 rdi
  00014	48 81 ec 00 02
	00 00		 sub	 rsp, 512		; 00000200H
  0001b	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00022	48 33 c4	 xor	 rax, rsp
  00025	48 89 84 24 f0
	01 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 1211 : int             rc;                     /* Return code               */
; 1212 : int             i;                      /* Array subscript           */
; 1213 : DATABLK        *datablk;                /* -> Data block structure   */
; 1214 : FORMAT1_DSCB   *f1dscb;                 /* -> Format 1 DSCB          */
; 1215 : FORMAT4_DSCB   *f4dscb;                 /* -> Format 4 DSCB          */
; 1216 : int             dscbpertrk;             /* Number of DSCBs per track */
; 1217 : int             mintrks;                /* Minimum VTOC size (tracks)*/
; 1218 : int             numtrks;                /* Actual VTOC size (tracks) */
; 1219 : int             highcyl;                /* Last used cylinder number */
; 1220 : int             highhead;               /* Last used head number     */
; 1221 : int             highrec;                /* Last used record number   */
; 1222 : int             numf0dscb;              /* Number of unused DSCBs    */
; 1223 : int             abstrk;                 /* Absolute track number     */
; 1224 : int             endcyl;                 /* VTOC end cylinder number  */
; 1225 : int             endhead;                /* VTOC end head number      */
; 1226 : int             numcyls;                /* Volume size in cylinders  */
; 1227 : int             outusedv = 0;           /* Bytes used in track buffer*/

  0002d	c7 84 24 b8 00
	00 00 00 00 00
	00		 mov	 DWORD PTR outusedv$[rsp], 0

; 1228 : int             outusedr = 0;           /* Bytes used on real track  */

  00038	c7 84 24 ec 00
	00 00 00 00 00
	00		 mov	 DWORD PTR outusedr$[rsp], 0

; 1229 : int             outtrkbr;               /* Bytes left on real track  */
; 1230 : int             outcyl;                 /* Output cylinder number    */
; 1231 : int             outhead;                /* Output head number        */
; 1232 : int             outtrk = 0;             /* Relative track number     */

  00043	c7 84 24 b0 00
	00 00 00 00 00
	00		 mov	 DWORD PTR outtrk$[rsp], 0

; 1233 : int             outrec = 0;             /* Output record number      */

  0004e	c7 84 24 a8 00
	00 00 00 00 00
	00		 mov	 DWORD PTR outrec$[rsp], 0

; 1234 : int             prealloc = 0;           /* 1=VTOC is preallocated    */

  00059	c7 84 24 bc 00
	00 00 00 00 00
	00		 mov	 DWORD PTR prealloc$[rsp], 0

; 1235 : BYTE            blankblk[152];          /* Data block for blank DSCB */
; 1236 : int             curcyl;                 /* Current cylinder in file  */
; 1237 : int             curhead;                /* Current head in file      */
; 1238 : char            dsnama[45];             /* Dataset name (ASCIIZ)     */
; 1239 : 
; 1240 :     /* Determine if the VTOC is preallocated */
; 1241 :     prealloc = (vtoctrk != 0 && vtocext != 0);

  00064	83 bc 24 50 02
	00 00 00	 cmp	 DWORD PTR vtoctrk$[rsp], 0
  0006c	74 17		 je	 SHORT $LN25@write_vtoc
  0006e	83 bc 24 58 02
	00 00 00	 cmp	 DWORD PTR vtocext$[rsp], 0
  00076	74 0d		 je	 SHORT $LN25@write_vtoc
  00078	c7 84 24 f0 00
	00 00 01 00 00
	00		 mov	 DWORD PTR tv66[rsp], 1
  00083	eb 0b		 jmp	 SHORT $LN26@write_vtoc
$LN25@write_vtoc:
  00085	c7 84 24 f0 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv66[rsp], 0
$LN26@write_vtoc:
  00090	8b 84 24 f0 00
	00 00		 mov	 eax, DWORD PTR tv66[rsp]
  00097	89 84 24 bc 00
	00 00		 mov	 DWORD PTR prealloc$[rsp], eax

; 1242 : 
; 1243 :     /* Point to the format 4 DSCB within the first data block */
; 1244 :     f4dscb = (FORMAT4_DSCB*)(dscbtab[0]->kdarea);

  0009e	b8 08 00 00 00	 mov	 eax, 8
  000a3	48 6b c0 00	 imul	 rax, rax, 0
  000a7	48 8b 8c 24 10
	02 00 00	 mov	 rcx, QWORD PTR dscbtab$[rsp]
  000af	48 8b 04 01	 mov	 rax, QWORD PTR [rcx+rax]
  000b3	48 83 c0 0c	 add	 rax, 12
  000b7	48 89 84 24 a0
	00 00 00	 mov	 QWORD PTR f4dscb$[rsp], rax

; 1245 : 
; 1246 :     /* Calculate the minimum number of tracks required for the VTOC */
; 1247 :     dscbpertrk = f4dscb->ds4devdt;

  000bf	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR f4dscb$[rsp]
  000c7	0f b6 40 4a	 movzx	 eax, BYTE PTR [rax+74]
  000cb	89 84 24 b4 00
	00 00		 mov	 DWORD PTR dscbpertrk$[rsp], eax

; 1248 :     mintrks = (numdscb + dscbpertrk - 1) / dscbpertrk;

  000d2	8b 84 24 18 02
	00 00		 mov	 eax, DWORD PTR numdscb$[rsp]
  000d9	8b 8c 24 b4 00
	00 00		 mov	 ecx, DWORD PTR dscbpertrk$[rsp]
  000e0	8d 44 08 ff	 lea	 eax, DWORD PTR [rax+rcx-1]
  000e4	99		 cdq
  000e5	f7 bc 24 b4 00
	00 00		 idiv	 DWORD PTR dscbpertrk$[rsp]
  000ec	89 84 24 ac 00
	00 00		 mov	 DWORD PTR mintrks$[rsp], eax

; 1249 : 
; 1250 :     /* Save the current position in the output file */
; 1251 :     curcyl = cif->curcyl;

  000f3	48 8b 84 24 20
	02 00 00	 mov	 rax, QWORD PTR cif$[rsp]
  000fb	8b 40 18	 mov	 eax, DWORD PTR [rax+24]
  000fe	89 84 24 c4 00
	00 00		 mov	 DWORD PTR curcyl$[rsp], eax

; 1252 :     curhead = cif->curhead;

  00105	48 8b 84 24 20
	02 00 00	 mov	 rax, QWORD PTR cif$[rsp]
  0010d	8b 40 1c	 mov	 eax, DWORD PTR [rax+28]
  00110	89 84 24 c0 00
	00 00		 mov	 DWORD PTR curhead$[rsp], eax

; 1253 : 
; 1254 :     /* Obtain the VTOC starting location and size */
; 1255 :     if (prealloc)

  00117	83 bc 24 bc 00
	00 00 00	 cmp	 DWORD PTR prealloc$[rsp], 0
  0011f	74 3e		 je	 SHORT $LN8@write_vtoc

; 1256 :     {
; 1257 :         /* Use preallocated VTOC location */
; 1258 :         outcyl = vtoctrk / heads;

  00121	8b 84 24 50 02
	00 00		 mov	 eax, DWORD PTR vtoctrk$[rsp]
  00128	99		 cdq
  00129	f7 bc 24 40 02
	00 00		 idiv	 DWORD PTR heads$[rsp]
  00130	89 84 24 80 00
	00 00		 mov	 DWORD PTR outcyl$[rsp], eax

; 1259 :         outhead = vtoctrk % heads;

  00137	8b 84 24 50 02
	00 00		 mov	 eax, DWORD PTR vtoctrk$[rsp]
  0013e	99		 cdq
  0013f	f7 bc 24 40 02
	00 00		 idiv	 DWORD PTR heads$[rsp]
  00146	8b c2		 mov	 eax, edx
  00148	89 84 24 84 00
	00 00		 mov	 DWORD PTR outhead$[rsp], eax

; 1260 :         numtrks = vtocext;

  0014f	8b 84 24 58 02
	00 00		 mov	 eax, DWORD PTR vtocext$[rsp]
  00156	89 84 24 94 00
	00 00		 mov	 DWORD PTR numtrks$[rsp], eax

; 1261 :     }

  0015d	eb 30		 jmp	 SHORT $LN9@write_vtoc
$LN8@write_vtoc:

; 1262 :     else
; 1263 :     {
; 1264 :         /* Use next available dataset location for VTOC */
; 1265 :         outcyl = *nxtcyl;

  0015f	48 8b 84 24 60
	02 00 00	 mov	 rax, QWORD PTR nxtcyl$[rsp]
  00167	8b 00		 mov	 eax, DWORD PTR [rax]
  00169	89 84 24 80 00
	00 00		 mov	 DWORD PTR outcyl$[rsp], eax

; 1266 :         outhead = *nxthead;

  00170	48 8b 84 24 68
	02 00 00	 mov	 rax, QWORD PTR nxthead$[rsp]
  00178	8b 00		 mov	 eax, DWORD PTR [rax]
  0017a	89 84 24 84 00
	00 00		 mov	 DWORD PTR outhead$[rsp], eax

; 1267 :         numtrks = mintrks;

  00181	8b 84 24 ac 00
	00 00		 mov	 eax, DWORD PTR mintrks$[rsp]
  00188	89 84 24 94 00
	00 00		 mov	 DWORD PTR numtrks$[rsp], eax
$LN9@write_vtoc:

; 1268 :     }
; 1269 : 
; 1270 :     /* Check that VTOC extent size is sufficient */
; 1271 :     if (numtrks < mintrks)

  0018f	8b 84 24 ac 00
	00 00		 mov	 eax, DWORD PTR mintrks$[rsp]
  00196	39 84 24 94 00
	00 00		 cmp	 DWORD PTR numtrks$[rsp], eax
  0019d	7d 57		 jge	 SHORT $LN10@write_vtoc

; 1272 :     {
; 1273 :         XMERRF ( MSG( HHC02519, "E", mintrks, mintrks == 1 ? "" : "s" ) );

  0019f	83 bc 24 ac 00
	00 00 01	 cmp	 DWORD PTR mintrks$[rsp], 1
  001a7	75 11		 jne	 SHORT $LN27@write_vtoc
  001a9	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG161150
  001b0	48 89 84 24 00
	01 00 00	 mov	 QWORD PTR tv83[rsp], rax
  001b8	eb 0f		 jmp	 SHORT $LN28@write_vtoc
$LN27@write_vtoc:
  001ba	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG161151
  001c1	48 89 84 24 00
	01 00 00	 mov	 QWORD PTR tv83[rsp], rax
$LN28@write_vtoc:
  001c9	4c 8b 8c 24 00
	01 00 00	 mov	 r9, QWORD PTR tv83[rsp]
  001d1	44 8b 84 24 ac
	00 00 00	 mov	 r8d, DWORD PTR mintrks$[rsp]
  001d9	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG161152
  001e0	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG161153
  001e7	e8 00 00 00 00	 call	 printf

; 1274 :         return -1;

  001ec	b8 ff ff ff ff	 mov	 eax, -1
  001f1	e9 2e 0a 00 00	 jmp	 $LN1@write_vtoc
$LN10@write_vtoc:

; 1275 :     }
; 1276 : 
; 1277 :     /* Read the first track of the VTOC */
; 1278 :     rc = read_track( cif, outcyl, (U8) outhead );

  001f6	44 0f b6 84 24
	84 00 00 00	 movzx	 r8d, BYTE PTR outhead$[rsp]
  001ff	8b 94 24 80 00
	00 00		 mov	 edx, DWORD PTR outcyl$[rsp]
  00206	48 8b 8c 24 20
	02 00 00	 mov	 rcx, QWORD PTR cif$[rsp]
  0020e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_read_track
  00214	89 84 24 8c 00
	00 00		 mov	 DWORD PTR rc$[rsp], eax

; 1279 :     if (rc < 0)

  0021b	83 bc 24 8c 00
	00 00 00	 cmp	 DWORD PTR rc$[rsp], 0
  00223	7d 4d		 jge	 SHORT $LN11@write_vtoc

; 1280 :     {
; 1281 :         XMERRF ( MSG( HHC02530, "E", "VTOC", outcyl, outcyl, outhead, outhead ) );

  00225	8b 84 24 84 00
	00 00		 mov	 eax, DWORD PTR outhead$[rsp]
  0022c	89 44 24 30	 mov	 DWORD PTR [rsp+48], eax
  00230	8b 84 24 84 00
	00 00		 mov	 eax, DWORD PTR outhead$[rsp]
  00237	89 44 24 28	 mov	 DWORD PTR [rsp+40], eax
  0023b	8b 84 24 80 00
	00 00		 mov	 eax, DWORD PTR outcyl$[rsp]
  00242	89 44 24 20	 mov	 DWORD PTR [rsp+32], eax
  00246	44 8b 8c 24 80
	00 00 00	 mov	 r9d, DWORD PTR outcyl$[rsp]
  0024e	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG161155
  00255	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG161156
  0025c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG161157
  00263	e8 00 00 00 00	 call	 printf

; 1282 :         return -1;

  00268	b8 ff ff ff ff	 mov	 eax, -1
  0026d	e9 b2 09 00 00	 jmp	 $LN1@write_vtoc
$LN11@write_vtoc:

; 1283 :     }
; 1284 : 
; 1285 :     /* Calculate the CCHHR of the last format 1 DSCB */
; 1286 :     abstrk = (outcyl * heads) + outhead;

  00272	8b 84 24 80 00
	00 00		 mov	 eax, DWORD PTR outcyl$[rsp]
  00279	0f af 84 24 40
	02 00 00	 imul	 eax, DWORD PTR heads$[rsp]
  00281	03 84 24 84 00
	00 00		 add	 eax, DWORD PTR outhead$[rsp]
  00288	89 84 24 88 00
	00 00		 mov	 DWORD PTR abstrk$[rsp], eax

; 1287 :     abstrk += mintrks - 1;

  0028f	8b 84 24 88 00
	00 00		 mov	 eax, DWORD PTR abstrk$[rsp]
  00296	8b 8c 24 ac 00
	00 00		 mov	 ecx, DWORD PTR mintrks$[rsp]
  0029d	8d 44 08 ff	 lea	 eax, DWORD PTR [rax+rcx-1]
  002a1	89 84 24 88 00
	00 00		 mov	 DWORD PTR abstrk$[rsp], eax

; 1288 :     highcyl = abstrk / heads;

  002a8	8b 84 24 88 00
	00 00		 mov	 eax, DWORD PTR abstrk$[rsp]
  002af	99		 cdq
  002b0	f7 bc 24 40 02
	00 00		 idiv	 DWORD PTR heads$[rsp]
  002b7	89 84 24 f4 00
	00 00		 mov	 DWORD PTR highcyl$[rsp], eax

; 1289 :     highhead = abstrk % heads;

  002be	8b 84 24 88 00
	00 00		 mov	 eax, DWORD PTR abstrk$[rsp]
  002c5	99		 cdq
  002c6	f7 bc 24 40 02
	00 00		 idiv	 DWORD PTR heads$[rsp]
  002cd	8b c2		 mov	 eax, edx
  002cf	89 84 24 d0 00
	00 00		 mov	 DWORD PTR highhead$[rsp], eax

; 1290 :     highrec = ((numdscb - 1) % dscbpertrk) + 1;

  002d6	8b 84 24 18 02
	00 00		 mov	 eax, DWORD PTR numdscb$[rsp]
  002dd	ff c8		 dec	 eax
  002df	99		 cdq
  002e0	f7 bc 24 b4 00
	00 00		 idiv	 DWORD PTR dscbpertrk$[rsp]
  002e7	8b c2		 mov	 eax, edx
  002e9	ff c0		 inc	 eax
  002eb	89 84 24 f8 00
	00 00		 mov	 DWORD PTR highrec$[rsp], eax

; 1291 : 
; 1292 :     /* Update the last format 1 CCHHR in the format 4 DSCB */
; 1293 :     f4dscb->ds4hpchr[0] = (highcyl >> 8) & 0xFF;

  002f2	8b 84 24 f4 00
	00 00		 mov	 eax, DWORD PTR highcyl$[rsp]
  002f9	c1 f8 08	 sar	 eax, 8
  002fc	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  00301	b9 01 00 00 00	 mov	 ecx, 1
  00306	48 6b c9 00	 imul	 rcx, rcx, 0
  0030a	48 8b 94 24 a0
	00 00 00	 mov	 rdx, QWORD PTR f4dscb$[rsp]
  00312	88 44 0a 2d	 mov	 BYTE PTR [rdx+rcx+45], al

; 1294 :     f4dscb->ds4hpchr[1] = highcyl & 0xFF;

  00316	8b 84 24 f4 00
	00 00		 mov	 eax, DWORD PTR highcyl$[rsp]
  0031d	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  00322	b9 01 00 00 00	 mov	 ecx, 1
  00327	48 6b c9 01	 imul	 rcx, rcx, 1
  0032b	48 8b 94 24 a0
	00 00 00	 mov	 rdx, QWORD PTR f4dscb$[rsp]
  00333	88 44 0a 2d	 mov	 BYTE PTR [rdx+rcx+45], al

; 1295 :     f4dscb->ds4hpchr[2] = (highhead >> 8) & 0xFF;

  00337	8b 84 24 d0 00
	00 00		 mov	 eax, DWORD PTR highhead$[rsp]
  0033e	c1 f8 08	 sar	 eax, 8
  00341	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  00346	b9 01 00 00 00	 mov	 ecx, 1
  0034b	48 6b c9 02	 imul	 rcx, rcx, 2
  0034f	48 8b 94 24 a0
	00 00 00	 mov	 rdx, QWORD PTR f4dscb$[rsp]
  00357	88 44 0a 2d	 mov	 BYTE PTR [rdx+rcx+45], al

; 1296 :     f4dscb->ds4hpchr[3] = highhead & 0xFF;

  0035b	8b 84 24 d0 00
	00 00		 mov	 eax, DWORD PTR highhead$[rsp]
  00362	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  00367	b9 01 00 00 00	 mov	 ecx, 1
  0036c	48 6b c9 03	 imul	 rcx, rcx, 3
  00370	48 8b 94 24 a0
	00 00 00	 mov	 rdx, QWORD PTR f4dscb$[rsp]
  00378	88 44 0a 2d	 mov	 BYTE PTR [rdx+rcx+45], al

; 1297 :     f4dscb->ds4hpchr[4] = (BYTE) highrec;

  0037c	b8 01 00 00 00	 mov	 eax, 1
  00381	48 6b c0 04	 imul	 rax, rax, 4
  00385	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR f4dscb$[rsp]
  0038d	0f b6 94 24 f8
	00 00 00	 movzx	 edx, BYTE PTR highrec$[rsp]
  00395	88 54 01 2d	 mov	 BYTE PTR [rcx+rax+45], dl

; 1298 : 
; 1299 :     /* Build the VTOC start CCHHR */
; 1300 :     volvtoc[0] = (outcyl >> 8) & 0xFF;

  00399	8b 84 24 80 00
	00 00		 mov	 eax, DWORD PTR outcyl$[rsp]
  003a0	c1 f8 08	 sar	 eax, 8
  003a3	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  003a8	b9 01 00 00 00	 mov	 ecx, 1
  003ad	48 6b c9 00	 imul	 rcx, rcx, 0
  003b1	48 8b 94 24 70
	02 00 00	 mov	 rdx, QWORD PTR volvtoc$[rsp]
  003b9	88 04 0a	 mov	 BYTE PTR [rdx+rcx], al

; 1301 :     volvtoc[1] = outcyl & 0xFF;

  003bc	8b 84 24 80 00
	00 00		 mov	 eax, DWORD PTR outcyl$[rsp]
  003c3	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  003c8	b9 01 00 00 00	 mov	 ecx, 1
  003cd	48 6b c9 01	 imul	 rcx, rcx, 1
  003d1	48 8b 94 24 70
	02 00 00	 mov	 rdx, QWORD PTR volvtoc$[rsp]
  003d9	88 04 0a	 mov	 BYTE PTR [rdx+rcx], al

; 1302 :     volvtoc[2] = (outhead >> 8) & 0xFF;

  003dc	8b 84 24 84 00
	00 00		 mov	 eax, DWORD PTR outhead$[rsp]
  003e3	c1 f8 08	 sar	 eax, 8
  003e6	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  003eb	b9 01 00 00 00	 mov	 ecx, 1
  003f0	48 6b c9 02	 imul	 rcx, rcx, 2
  003f4	48 8b 94 24 70
	02 00 00	 mov	 rdx, QWORD PTR volvtoc$[rsp]
  003fc	88 04 0a	 mov	 BYTE PTR [rdx+rcx], al

; 1303 :     volvtoc[3] = outhead & 0xFF;

  003ff	8b 84 24 84 00
	00 00		 mov	 eax, DWORD PTR outhead$[rsp]
  00406	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  0040b	b9 01 00 00 00	 mov	 ecx, 1
  00410	48 6b c9 03	 imul	 rcx, rcx, 3
  00414	48 8b 94 24 70
	02 00 00	 mov	 rdx, QWORD PTR volvtoc$[rsp]
  0041c	88 04 0a	 mov	 BYTE PTR [rdx+rcx], al

; 1304 :     volvtoc[4] = 1;

  0041f	b8 01 00 00 00	 mov	 eax, 1
  00424	48 6b c0 04	 imul	 rax, rax, 4
  00428	48 8b 8c 24 70
	02 00 00	 mov	 rcx, QWORD PTR volvtoc$[rsp]
  00430	c6 04 01 01	 mov	 BYTE PTR [rcx+rax], 1

; 1305 : 
; 1306 :     XMINFF (1, MSG( HHC02524, "I", outcyl, outcyl, outhead, outhead, numtrks, numtrks == 1 ? "" : "s" ) );

  00434	83 bc 24 94 00
	00 00 01	 cmp	 DWORD PTR numtrks$[rsp], 1
  0043c	75 11		 jne	 SHORT $LN29@write_vtoc
  0043e	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG161158
  00445	48 89 84 24 08
	01 00 00	 mov	 QWORD PTR tv218[rsp], rax
  0044d	eb 0f		 jmp	 SHORT $LN30@write_vtoc
$LN29@write_vtoc:
  0044f	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG161159
  00456	48 89 84 24 08
	01 00 00	 mov	 QWORD PTR tv218[rsp], rax
$LN30@write_vtoc:
  0045e	48 8b 84 24 08
	01 00 00	 mov	 rax, QWORD PTR tv218[rsp]
  00466	48 89 44 24 40	 mov	 QWORD PTR [rsp+64], rax
  0046b	8b 84 24 94 00
	00 00		 mov	 eax, DWORD PTR numtrks$[rsp]
  00472	89 44 24 38	 mov	 DWORD PTR [rsp+56], eax
  00476	8b 84 24 84 00
	00 00		 mov	 eax, DWORD PTR outhead$[rsp]
  0047d	89 44 24 30	 mov	 DWORD PTR [rsp+48], eax
  00481	8b 84 24 84 00
	00 00		 mov	 eax, DWORD PTR outhead$[rsp]
  00488	89 44 24 28	 mov	 DWORD PTR [rsp+40], eax
  0048c	8b 84 24 80 00
	00 00		 mov	 eax, DWORD PTR outcyl$[rsp]
  00493	89 44 24 20	 mov	 DWORD PTR [rsp+32], eax
  00497	44 8b 8c 24 80
	00 00 00	 mov	 r9d, DWORD PTR outcyl$[rsp]
  0049f	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG161160
  004a6	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG161161
  004ad	b9 01 00 00 00	 mov	 ecx, 1
  004b2	e8 00 00 00 00	 call	 info_msg

; 1307 : 
; 1308 :     /* Calculate the number of format 0 DSCBs required to
; 1309 :        fill out the unused space at the end of the VTOC */
; 1310 :     numf0dscb = (numtrks * dscbpertrk) - numdscb;

  004b7	8b 84 24 94 00
	00 00		 mov	 eax, DWORD PTR numtrks$[rsp]
  004be	0f af 84 24 b4
	00 00 00	 imul	 eax, DWORD PTR dscbpertrk$[rsp]
  004c6	2b 84 24 18 02
	00 00		 sub	 eax, DWORD PTR numdscb$[rsp]
  004cd	89 84 24 e8 00
	00 00		 mov	 DWORD PTR numf0dscb$[rsp], eax

; 1311 : 
; 1312 :     /* Update the format 0 DSCB count in the format 4 DSCB */
; 1313 :     store_hw( f4dscb->ds4dsrec, numf0dscb );

  004d4	0f b7 8c 24 e8
	00 00 00	 movzx	 ecx, WORD PTR numf0dscb$[rsp]
  004dc	e8 00 00 00 00	 call	 _byteswap_ushort
  004e1	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR f4dscb$[rsp]
  004e9	48 83 c1 32	 add	 rcx, 50			; 00000032H
  004ed	0f b7 d0	 movzx	 edx, ax
  004f0	e8 00 00 00 00	 call	 store_hw_noswap

; 1314 : 
; 1315 :     /* Calculate the CCHH of the last track of the VTOC */
; 1316 :     abstrk = (outcyl * heads) + outhead;

  004f5	8b 84 24 80 00
	00 00		 mov	 eax, DWORD PTR outcyl$[rsp]
  004fc	0f af 84 24 40
	02 00 00	 imul	 eax, DWORD PTR heads$[rsp]
  00504	03 84 24 84 00
	00 00		 add	 eax, DWORD PTR outhead$[rsp]
  0050b	89 84 24 88 00
	00 00		 mov	 DWORD PTR abstrk$[rsp], eax

; 1317 :     abstrk += numtrks - 1;

  00512	8b 84 24 88 00
	00 00		 mov	 eax, DWORD PTR abstrk$[rsp]
  00519	8b 8c 24 94 00
	00 00		 mov	 ecx, DWORD PTR numtrks$[rsp]
  00520	8d 44 08 ff	 lea	 eax, DWORD PTR [rax+rcx-1]
  00524	89 84 24 88 00
	00 00		 mov	 DWORD PTR abstrk$[rsp], eax

; 1318 :     endcyl = abstrk / heads;

  0052b	8b 84 24 88 00
	00 00		 mov	 eax, DWORD PTR abstrk$[rsp]
  00532	99		 cdq
  00533	f7 bc 24 40 02
	00 00		 idiv	 DWORD PTR heads$[rsp]
  0053a	89 84 24 dc 00
	00 00		 mov	 DWORD PTR endcyl$[rsp], eax

; 1319 :     endhead = abstrk % heads;

  00541	8b 84 24 88 00
	00 00		 mov	 eax, DWORD PTR abstrk$[rsp]
  00548	99		 cdq
  00549	f7 bc 24 40 02
	00 00		 idiv	 DWORD PTR heads$[rsp]
  00550	8b c2		 mov	 eax, edx
  00552	89 84 24 d8 00
	00 00		 mov	 DWORD PTR endhead$[rsp], eax

; 1320 : 
; 1321 :     /* Update the VTOC extent descriptor in the format 4 DSCB */
; 1322 :     f4dscb->ds4vtoce.xttype =

  00559	8b 84 24 40 02
	00 00		 mov	 eax, DWORD PTR heads$[rsp]
  00560	ff c8		 dec	 eax
  00562	39 84 24 d8 00
	00 00		 cmp	 DWORD PTR endhead$[rsp], eax
  00569	75 0d		 jne	 SHORT $LN31@write_vtoc
  0056b	c7 84 24 d4 00
	00 00 81 00 00
	00		 mov	 DWORD PTR tv244[rsp], 129 ; 00000081H
  00576	eb 0b		 jmp	 SHORT $LN32@write_vtoc
$LN31@write_vtoc:
  00578	c7 84 24 d4 00
	00 00 01 00 00
	00		 mov	 DWORD PTR tv244[rsp], 1
$LN32@write_vtoc:
  00583	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR f4dscb$[rsp]
  0058b	0f b6 8c 24 d4
	00 00 00	 movzx	 ecx, BYTE PTR tv244[rsp]
  00593	88 48 69	 mov	 BYTE PTR [rax+105], cl

; 1323 :         (endhead == heads - 1 ? XTTYPE_CYLBOUND : XTTYPE_DATA);
; 1324 :     f4dscb->ds4vtoce.xtseqn = 0;

  00596	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR f4dscb$[rsp]
  0059e	c6 40 6a 00	 mov	 BYTE PTR [rax+106], 0

; 1325 :     store_hw( f4dscb->ds4vtoce.xtbcyl, outcyl );

  005a2	0f b7 8c 24 80
	00 00 00	 movzx	 ecx, WORD PTR outcyl$[rsp]
  005aa	e8 00 00 00 00	 call	 _byteswap_ushort
  005af	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR f4dscb$[rsp]
  005b7	48 83 c1 6b	 add	 rcx, 107		; 0000006bH
  005bb	0f b7 d0	 movzx	 edx, ax
  005be	e8 00 00 00 00	 call	 store_hw_noswap

; 1326 :     store_hw( f4dscb->ds4vtoce.xtbtrk, outhead );

  005c3	0f b7 8c 24 84
	00 00 00	 movzx	 ecx, WORD PTR outhead$[rsp]
  005cb	e8 00 00 00 00	 call	 _byteswap_ushort
  005d0	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR f4dscb$[rsp]
  005d8	48 83 c1 6d	 add	 rcx, 109		; 0000006dH
  005dc	0f b7 d0	 movzx	 edx, ax
  005df	e8 00 00 00 00	 call	 store_hw_noswap

; 1327 :     store_hw( f4dscb->ds4vtoce.xtecyl, endcyl );

  005e4	0f b7 8c 24 dc
	00 00 00	 movzx	 ecx, WORD PTR endcyl$[rsp]
  005ec	e8 00 00 00 00	 call	 _byteswap_ushort
  005f1	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR f4dscb$[rsp]
  005f9	48 83 c1 6f	 add	 rcx, 111		; 0000006fH
  005fd	0f b7 d0	 movzx	 edx, ax
  00600	e8 00 00 00 00	 call	 store_hw_noswap

; 1328 :     store_hw( f4dscb->ds4vtoce.xtetrk, endhead );

  00605	0f b7 8c 24 d8
	00 00 00	 movzx	 ecx, WORD PTR endhead$[rsp]
  0060d	e8 00 00 00 00	 call	 _byteswap_ushort
  00612	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR f4dscb$[rsp]
  0061a	48 83 c1 71	 add	 rcx, 113		; 00000071H
  0061e	0f b7 d0	 movzx	 edx, ax
  00621	e8 00 00 00 00	 call	 store_hw_noswap

; 1329 : 
; 1330 :     /* Calculate the mimimum volume size */
; 1331 :     if (prealloc)

  00626	83 bc 24 bc 00
	00 00 00	 cmp	 DWORD PTR prealloc$[rsp], 0
  0062e	74 30		 je	 SHORT $LN12@write_vtoc

; 1332 :     {
; 1333 :         /* The VTOC was preallocated, so the minimum volume
; 1334 :            size equals the next available cylinder number */
; 1335 :         numcyls = *nxtcyl;

  00630	48 8b 84 24 60
	02 00 00	 mov	 rax, QWORD PTR nxtcyl$[rsp]
  00638	8b 00		 mov	 eax, DWORD PTR [rax]
  0063a	89 84 24 98 00
	00 00		 mov	 DWORD PTR numcyls$[rsp], eax

; 1336 :         if (*nxthead != 0) numcyls++;

  00641	48 8b 84 24 68
	02 00 00	 mov	 rax, QWORD PTR nxthead$[rsp]
  00649	83 38 00	 cmp	 DWORD PTR [rax], 0
  0064c	74 10		 je	 SHORT $LN14@write_vtoc
  0064e	8b 84 24 98 00
	00 00		 mov	 eax, DWORD PTR numcyls$[rsp]
  00655	ff c0		 inc	 eax
  00657	89 84 24 98 00
	00 00		 mov	 DWORD PTR numcyls$[rsp], eax
$LN14@write_vtoc:

; 1337 :     }

  0065e	eb 10		 jmp	 SHORT $LN13@write_vtoc
$LN12@write_vtoc:

; 1338 :     else
; 1339 :     {
; 1340 :         /* The VTOC will be written into the available space,
; 1341 :            so the minimum volume size is one more than the
; 1342 :            ending cylinder number of the VTOC */
; 1343 :         numcyls = endcyl + 1;

  00660	8b 84 24 dc 00
	00 00		 mov	 eax, DWORD PTR endcyl$[rsp]
  00667	ff c0		 inc	 eax
  00669	89 84 24 98 00
	00 00		 mov	 DWORD PTR numcyls$[rsp], eax
$LN13@write_vtoc:

; 1344 :     }
; 1345 : 
; 1346 :     /* If the minimum volume size is less than the requested
; 1347 :        size then use the requested size as the actual size */
; 1348 :     if (numcyls < reqcyls) numcyls = reqcyls;

  00670	8b 84 24 38 02
	00 00		 mov	 eax, DWORD PTR reqcyls$[rsp]
  00677	39 84 24 98 00
	00 00		 cmp	 DWORD PTR numcyls$[rsp], eax
  0067e	7d 0e		 jge	 SHORT $LN15@write_vtoc
  00680	8b 84 24 38 02
	00 00		 mov	 eax, DWORD PTR reqcyls$[rsp]
  00687	89 84 24 98 00
	00 00		 mov	 DWORD PTR numcyls$[rsp], eax
$LN15@write_vtoc:

; 1349 : 
; 1350 :     /* Update the volume size in cylinders in the format 4 DSCB */
; 1351 :     f4dscb->ds4devsz[0] = (numcyls >> 8) & 0xFF;

  0068e	8b 84 24 98 00
	00 00		 mov	 eax, DWORD PTR numcyls$[rsp]
  00695	c1 f8 08	 sar	 eax, 8
  00698	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  0069d	b9 01 00 00 00	 mov	 ecx, 1
  006a2	48 6b c9 00	 imul	 rcx, rcx, 0
  006a6	48 8b 94 24 a0
	00 00 00	 mov	 rdx, QWORD PTR f4dscb$[rsp]
  006ae	88 44 0a 3e	 mov	 BYTE PTR [rdx+rcx+62], al

; 1352 :     f4dscb->ds4devsz[1] = numcyls & 0xFF;

  006b2	8b 84 24 98 00
	00 00		 mov	 eax, DWORD PTR numcyls$[rsp]
  006b9	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  006be	b9 01 00 00 00	 mov	 ecx, 1
  006c3	48 6b c9 01	 imul	 rcx, rcx, 1
  006c7	48 8b 94 24 a0
	00 00 00	 mov	 rdx, QWORD PTR f4dscb$[rsp]
  006cf	88 44 0a 3e	 mov	 BYTE PTR [rdx+rcx+62], al

; 1353 : 
; 1354 :     /* Format the track buffer */
; 1355 :     init_track (trklen, cif->trkbuf, outcyl, outhead, &outusedv);

  006d3	48 8d 84 24 b8
	00 00 00	 lea	 rax, QWORD PTR outusedv$[rsp]
  006db	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  006e0	44 8b 8c 24 84
	00 00 00	 mov	 r9d, DWORD PTR outhead$[rsp]
  006e8	44 8b 84 24 80
	00 00 00	 mov	 r8d, DWORD PTR outcyl$[rsp]
  006f0	48 8b 84 24 20
	02 00 00	 mov	 rax, QWORD PTR cif$[rsp]
  006f8	48 8b 50 10	 mov	 rdx, QWORD PTR [rax+16]
  006fc	8b 8c 24 48 02
	00 00		 mov	 ecx, DWORD PTR trklen$[rsp]
  00703	e8 00 00 00 00	 call	 init_track

; 1356 :     cif->trkmodif = 1;

  00708	48 8b 84 24 20
	02 00 00	 mov	 rax, QWORD PTR cif$[rsp]
  00710	c7 40 20 01 00
	00 00		 mov	 DWORD PTR [rax+32], 1

; 1357 : 
; 1358 :     /* Write the format 4, format 5, and format 1 DSCBs to the VTOC */
; 1359 :     for (i = 0; i < numdscb; i++)

  00717	c7 84 24 90 00
	00 00 00 00 00
	00		 mov	 DWORD PTR i$[rsp], 0
  00722	eb 10		 jmp	 SHORT $LN4@write_vtoc
$LN2@write_vtoc:
  00724	8b 84 24 90 00
	00 00		 mov	 eax, DWORD PTR i$[rsp]
  0072b	ff c0		 inc	 eax
  0072d	89 84 24 90 00
	00 00		 mov	 DWORD PTR i$[rsp], eax
$LN4@write_vtoc:
  00734	8b 84 24 18 02
	00 00		 mov	 eax, DWORD PTR numdscb$[rsp]
  0073b	39 84 24 90 00
	00 00		 cmp	 DWORD PTR i$[rsp], eax
  00742	0f 8d 38 02 00
	00		 jge	 $LN3@write_vtoc

; 1360 :     {
; 1361 :         /* Load the data block pointer from the DSCB table */
; 1362 :         datablk = dscbtab[i];

  00748	48 63 84 24 90
	00 00 00	 movsxd	 rax, DWORD PTR i$[rsp]
  00750	48 8b 8c 24 10
	02 00 00	 mov	 rcx, QWORD PTR dscbtab$[rsp]
  00758	48 8b 04 c1	 mov	 rax, QWORD PTR [rcx+rax*8]
  0075c	48 89 84 24 c8
	00 00 00	 mov	 QWORD PTR datablk$[rsp], rax

; 1363 : 
; 1364 :         /* Extract the dataset name from the format 1 DSCB */
; 1365 :         memset (dsnama, 0, sizeof(dsnama));

  00764	48 8d 84 24 18
	01 00 00	 lea	 rax, QWORD PTR dsnama$[rsp]
  0076c	48 8b f8	 mov	 rdi, rax
  0076f	33 c0		 xor	 eax, eax
  00771	b9 2d 00 00 00	 mov	 ecx, 45			; 0000002dH
  00776	f3 aa		 rep stosb

; 1366 :         f1dscb = (FORMAT1_DSCB*)(datablk->kdarea);

  00778	48 8b 84 24 c8
	00 00 00	 mov	 rax, QWORD PTR datablk$[rsp]
  00780	48 83 c0 0c	 add	 rax, 12
  00784	48 89 84 24 10
	01 00 00	 mov	 QWORD PTR f1dscb$[rsp], rax

; 1367 :         if (f1dscb->ds1fmtid == 0xF1)

  0078c	48 8b 84 24 10
	01 00 00	 mov	 rax, QWORD PTR f1dscb$[rsp]
  00794	0f b6 40 2c	 movzx	 eax, BYTE PTR [rax+44]
  00798	3d f1 00 00 00	 cmp	 eax, 241		; 000000f1H
  0079d	75 24		 jne	 SHORT $LN16@write_vtoc

; 1368 :         {
; 1369 :             make_asciiz (dsnama, sizeof(dsnama), f1dscb->ds1dsnam,

  0079f	48 8b 84 24 10
	01 00 00	 mov	 rax, QWORD PTR f1dscb$[rsp]
  007a7	41 b9 2c 00 00
	00		 mov	 r9d, 44			; 0000002cH
  007ad	4c 8b c0	 mov	 r8, rax
  007b0	ba 2d 00 00 00	 mov	 edx, 45			; 0000002dH
  007b5	48 8d 8c 24 18
	01 00 00	 lea	 rcx, QWORD PTR dsnama$[rsp]
  007bd	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_make_asciiz
$LN16@write_vtoc:

; 1370 :                         sizeof(f1dscb->ds1dsnam));
; 1371 :         }
; 1372 : 
; 1373 :         /* Add next DSCB to the track buffer */
; 1374 :         rc = write_block (cif, ofname, datablk, 44, 96,

  007c3	48 8d 84 24 a8
	00 00 00	 lea	 rax, QWORD PTR outrec$[rsp]
  007cb	48 89 44 24 78	 mov	 QWORD PTR [rsp+120], rax
  007d0	48 8d 84 24 84
	00 00 00	 lea	 rax, QWORD PTR outhead$[rsp]
  007d8	48 89 44 24 70	 mov	 QWORD PTR [rsp+112], rax
  007dd	48 8d 84 24 80
	00 00 00	 lea	 rax, QWORD PTR outcyl$[rsp]
  007e5	48 89 44 24 68	 mov	 QWORD PTR [rsp+104], rax
  007ea	48 8d 84 24 b0
	00 00 00	 lea	 rax, QWORD PTR outtrk$[rsp]
  007f2	48 89 44 24 60	 mov	 QWORD PTR [rsp+96], rax
  007f7	48 8d 84 24 fc
	00 00 00	 lea	 rax, QWORD PTR outtrkbr$[rsp]
  007ff	48 89 44 24 58	 mov	 QWORD PTR [rsp+88], rax
  00804	48 8d 84 24 ec
	00 00 00	 lea	 rax, QWORD PTR outusedr$[rsp]
  0080c	48 89 44 24 50	 mov	 QWORD PTR [rsp+80], rax
  00811	48 8d 84 24 b8
	00 00 00	 lea	 rax, QWORD PTR outusedv$[rsp]
  00819	48 89 44 24 48	 mov	 QWORD PTR [rsp+72], rax
  0081e	8b 84 24 94 00
	00 00		 mov	 eax, DWORD PTR numtrks$[rsp]
  00825	89 44 24 40	 mov	 DWORD PTR [rsp+64], eax
  00829	8b 84 24 48 02
	00 00		 mov	 eax, DWORD PTR trklen$[rsp]
  00830	89 44 24 38	 mov	 DWORD PTR [rsp+56], eax
  00834	8b 84 24 40 02
	00 00		 mov	 eax, DWORD PTR heads$[rsp]
  0083b	89 44 24 30	 mov	 DWORD PTR [rsp+48], eax
  0083f	0f b7 84 24 30
	02 00 00	 movzx	 eax, WORD PTR devtype$[rsp]
  00847	66 89 44 24 28	 mov	 WORD PTR [rsp+40], ax
  0084c	c7 44 24 20 60
	00 00 00	 mov	 DWORD PTR [rsp+32], 96	; 00000060H
  00854	41 b9 2c 00 00
	00		 mov	 r9d, 44			; 0000002cH
  0085a	4c 8b 84 24 c8
	00 00 00	 mov	 r8, QWORD PTR datablk$[rsp]
  00862	48 8b 94 24 28
	02 00 00	 mov	 rdx, QWORD PTR ofname$[rsp]
  0086a	48 8b 8c 24 20
	02 00 00	 mov	 rcx, QWORD PTR cif$[rsp]
  00872	e8 00 00 00 00	 call	 write_block
  00877	89 84 24 8c 00
	00 00		 mov	 DWORD PTR rc$[rsp], eax

; 1375 :                     devtype, heads, trklen, numtrks,
; 1376 :                     &outusedv, &outusedr, &outtrkbr,
; 1377 :                     &outtrk, &outcyl, &outhead, &outrec);
; 1378 :         if (rc < 0) return -1;

  0087e	83 bc 24 8c 00
	00 00 00	 cmp	 DWORD PTR rc$[rsp], 0
  00886	7d 0a		 jge	 SHORT $LN17@write_vtoc
  00888	b8 ff ff ff ff	 mov	 eax, -1
  0088d	e9 92 03 00 00	 jmp	 $LN1@write_vtoc
$LN17@write_vtoc:

; 1379 : 
; 1380 :         XMINFF (4, MSG( HHC02525, "I", datablk->kdarea[0] == 0x04 ? 4 :

  00892	b8 01 00 00 00	 mov	 eax, 1
  00897	48 6b c0 00	 imul	 rax, rax, 0
  0089b	48 8b 8c 24 c8
	00 00 00	 mov	 rcx, QWORD PTR datablk$[rsp]
  008a3	0f b6 44 01 0c	 movzx	 eax, BYTE PTR [rcx+rax+12]
  008a8	83 f8 04	 cmp	 eax, 4
  008ab	75 0d		 jne	 SHORT $LN35@write_vtoc
  008ad	c7 84 24 e4 00
	00 00 04 00 00
	00		 mov	 DWORD PTR tv343[rsp], 4
  008b8	eb 41		 jmp	 SHORT $LN36@write_vtoc
$LN35@write_vtoc:
  008ba	b8 01 00 00 00	 mov	 eax, 1
  008bf	48 6b c0 00	 imul	 rax, rax, 0
  008c3	48 8b 8c 24 c8
	00 00 00	 mov	 rcx, QWORD PTR datablk$[rsp]
  008cb	0f b6 44 01 0c	 movzx	 eax, BYTE PTR [rcx+rax+12]
  008d0	83 f8 05	 cmp	 eax, 5
  008d3	75 0d		 jne	 SHORT $LN33@write_vtoc
  008d5	c7 84 24 e0 00
	00 00 05 00 00
	00		 mov	 DWORD PTR tv342[rsp], 5
  008e0	eb 0b		 jmp	 SHORT $LN34@write_vtoc
$LN33@write_vtoc:
  008e2	c7 84 24 e0 00
	00 00 01 00 00
	00		 mov	 DWORD PTR tv342[rsp], 1
$LN34@write_vtoc:
  008ed	8b 84 24 e0 00
	00 00		 mov	 eax, DWORD PTR tv342[rsp]
  008f4	89 84 24 e4 00
	00 00		 mov	 DWORD PTR tv343[rsp], eax
$LN36@write_vtoc:
  008fb	48 8d 84 24 18
	01 00 00	 lea	 rax, QWORD PTR dsnama$[rsp]
  00903	48 89 44 24 48	 mov	 QWORD PTR [rsp+72], rax
  00908	8b 84 24 a8 00
	00 00		 mov	 eax, DWORD PTR outrec$[rsp]
  0090f	89 44 24 40	 mov	 DWORD PTR [rsp+64], eax
  00913	8b 84 24 b0 00
	00 00		 mov	 eax, DWORD PTR outtrk$[rsp]
  0091a	89 44 24 38	 mov	 DWORD PTR [rsp+56], eax
  0091e	8b 84 24 a8 00
	00 00		 mov	 eax, DWORD PTR outrec$[rsp]
  00925	89 44 24 30	 mov	 DWORD PTR [rsp+48], eax
  00929	8b 84 24 84 00
	00 00		 mov	 eax, DWORD PTR outhead$[rsp]
  00930	89 44 24 28	 mov	 DWORD PTR [rsp+40], eax
  00934	8b 84 24 80 00
	00 00		 mov	 eax, DWORD PTR outcyl$[rsp]
  0093b	89 44 24 20	 mov	 DWORD PTR [rsp+32], eax
  0093f	44 8b 8c 24 e4
	00 00 00	 mov	 r9d, DWORD PTR tv343[rsp]
  00947	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG161168
  0094e	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG161169
  00955	b9 04 00 00 00	 mov	 ecx, 4
  0095a	e8 00 00 00 00	 call	 info_msg

; 1381 :                                        datablk->kdarea[0] == 0x05 ? 5 : 1,
; 1382 :                                        outcyl, outhead, outrec, outtrk, outrec, dsnama ) );
; 1383 :         if (infolvl >= 5) data_dump (datablk, 152);

  0095f	83 3d 00 00 00
	00 05		 cmp	 DWORD PTR infolvl, 5
  00966	7c 13		 jl	 SHORT $LN18@write_vtoc
  00968	ba 98 00 00 00	 mov	 edx, 152		; 00000098H
  0096d	48 8b 8c 24 c8
	00 00 00	 mov	 rcx, QWORD PTR datablk$[rsp]
  00975	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_data_dump
$LN18@write_vtoc:

; 1384 : 
; 1385 :     } /* end for(i) */

  0097b	e9 a4 fd ff ff	 jmp	 $LN2@write_vtoc
$LN3@write_vtoc:

; 1386 : 
; 1387 :     /* Fill the remainder of the VTOC with format 0 DSCBs */
; 1388 :     for (i = 0; i < numf0dscb; i++)

  00980	c7 84 24 90 00
	00 00 00 00 00
	00		 mov	 DWORD PTR i$[rsp], 0
  0098b	eb 10		 jmp	 SHORT $LN7@write_vtoc
$LN5@write_vtoc:
  0098d	8b 84 24 90 00
	00 00		 mov	 eax, DWORD PTR i$[rsp]
  00994	ff c0		 inc	 eax
  00996	89 84 24 90 00
	00 00		 mov	 DWORD PTR i$[rsp], eax
$LN7@write_vtoc:
  0099d	8b 84 24 e8 00
	00 00		 mov	 eax, DWORD PTR numf0dscb$[rsp]
  009a4	39 84 24 90 00
	00 00		 cmp	 DWORD PTR i$[rsp], eax
  009ab	0f 8d 56 01 00
	00		 jge	 $LN6@write_vtoc

; 1389 :     {
; 1390 :         /* Add a format 0 DSCB to the track buffer */
; 1391 :         memset (blankblk, 0, sizeof(blankblk));

  009b1	48 8d 84 24 50
	01 00 00	 lea	 rax, QWORD PTR blankblk$[rsp]
  009b9	48 8b f8	 mov	 rdi, rax
  009bc	33 c0		 xor	 eax, eax
  009be	b9 98 00 00 00	 mov	 ecx, 152		; 00000098H
  009c3	f3 aa		 rep stosb

; 1392 :         datablk = (DATABLK*)blankblk;

  009c5	48 8d 84 24 50
	01 00 00	 lea	 rax, QWORD PTR blankblk$[rsp]
  009cd	48 89 84 24 c8
	00 00 00	 mov	 QWORD PTR datablk$[rsp], rax

; 1393 :         rc = write_block (cif, ofname, datablk, 44, 96,

  009d5	48 8d 84 24 a8
	00 00 00	 lea	 rax, QWORD PTR outrec$[rsp]
  009dd	48 89 44 24 78	 mov	 QWORD PTR [rsp+120], rax
  009e2	48 8d 84 24 84
	00 00 00	 lea	 rax, QWORD PTR outhead$[rsp]
  009ea	48 89 44 24 70	 mov	 QWORD PTR [rsp+112], rax
  009ef	48 8d 84 24 80
	00 00 00	 lea	 rax, QWORD PTR outcyl$[rsp]
  009f7	48 89 44 24 68	 mov	 QWORD PTR [rsp+104], rax
  009fc	48 8d 84 24 b0
	00 00 00	 lea	 rax, QWORD PTR outtrk$[rsp]
  00a04	48 89 44 24 60	 mov	 QWORD PTR [rsp+96], rax
  00a09	48 8d 84 24 fc
	00 00 00	 lea	 rax, QWORD PTR outtrkbr$[rsp]
  00a11	48 89 44 24 58	 mov	 QWORD PTR [rsp+88], rax
  00a16	48 8d 84 24 ec
	00 00 00	 lea	 rax, QWORD PTR outusedr$[rsp]
  00a1e	48 89 44 24 50	 mov	 QWORD PTR [rsp+80], rax
  00a23	48 8d 84 24 b8
	00 00 00	 lea	 rax, QWORD PTR outusedv$[rsp]
  00a2b	48 89 44 24 48	 mov	 QWORD PTR [rsp+72], rax
  00a30	8b 84 24 94 00
	00 00		 mov	 eax, DWORD PTR numtrks$[rsp]
  00a37	89 44 24 40	 mov	 DWORD PTR [rsp+64], eax
  00a3b	8b 84 24 48 02
	00 00		 mov	 eax, DWORD PTR trklen$[rsp]
  00a42	89 44 24 38	 mov	 DWORD PTR [rsp+56], eax
  00a46	8b 84 24 40 02
	00 00		 mov	 eax, DWORD PTR heads$[rsp]
  00a4d	89 44 24 30	 mov	 DWORD PTR [rsp+48], eax
  00a51	0f b7 84 24 30
	02 00 00	 movzx	 eax, WORD PTR devtype$[rsp]
  00a59	66 89 44 24 28	 mov	 WORD PTR [rsp+40], ax
  00a5e	c7 44 24 20 60
	00 00 00	 mov	 DWORD PTR [rsp+32], 96	; 00000060H
  00a66	41 b9 2c 00 00
	00		 mov	 r9d, 44			; 0000002cH
  00a6c	4c 8b 84 24 c8
	00 00 00	 mov	 r8, QWORD PTR datablk$[rsp]
  00a74	48 8b 94 24 28
	02 00 00	 mov	 rdx, QWORD PTR ofname$[rsp]
  00a7c	48 8b 8c 24 20
	02 00 00	 mov	 rcx, QWORD PTR cif$[rsp]
  00a84	e8 00 00 00 00	 call	 write_block
  00a89	89 84 24 8c 00
	00 00		 mov	 DWORD PTR rc$[rsp], eax

; 1394 :                     devtype, heads, trklen, numtrks,
; 1395 :                     &outusedv, &outusedr, &outtrkbr,
; 1396 :                     &outtrk, &outcyl, &outhead, &outrec);
; 1397 :         if (rc < 0) return -1;

  00a90	83 bc 24 8c 00
	00 00 00	 cmp	 DWORD PTR rc$[rsp], 0
  00a98	7d 0a		 jge	 SHORT $LN19@write_vtoc
  00a9a	b8 ff ff ff ff	 mov	 eax, -1
  00a9f	e9 80 01 00 00	 jmp	 $LN1@write_vtoc
$LN19@write_vtoc:

; 1398 : 
; 1399 :         XMINFF (4,  MSG( HHC02525, "I", 0, outcyl, outhead, outrec, outtrk, outrec, "" ) );

  00aa4	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG161172
  00aab	48 89 44 24 48	 mov	 QWORD PTR [rsp+72], rax
  00ab0	8b 84 24 a8 00
	00 00		 mov	 eax, DWORD PTR outrec$[rsp]
  00ab7	89 44 24 40	 mov	 DWORD PTR [rsp+64], eax
  00abb	8b 84 24 b0 00
	00 00		 mov	 eax, DWORD PTR outtrk$[rsp]
  00ac2	89 44 24 38	 mov	 DWORD PTR [rsp+56], eax
  00ac6	8b 84 24 a8 00
	00 00		 mov	 eax, DWORD PTR outrec$[rsp]
  00acd	89 44 24 30	 mov	 DWORD PTR [rsp+48], eax
  00ad1	8b 84 24 84 00
	00 00		 mov	 eax, DWORD PTR outhead$[rsp]
  00ad8	89 44 24 28	 mov	 DWORD PTR [rsp+40], eax
  00adc	8b 84 24 80 00
	00 00		 mov	 eax, DWORD PTR outcyl$[rsp]
  00ae3	89 44 24 20	 mov	 DWORD PTR [rsp+32], eax
  00ae7	45 33 c9	 xor	 r9d, r9d
  00aea	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG161173
  00af1	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG161174
  00af8	b9 04 00 00 00	 mov	 ecx, 4
  00afd	e8 00 00 00 00	 call	 info_msg

; 1400 : 
; 1401 :     } /* end for(i) */

  00b02	e9 86 fe ff ff	 jmp	 $LN5@write_vtoc
$LN6@write_vtoc:

; 1402 : 
; 1403 :     /* Write data remaining in last track buffer */
; 1404 :     rc = write_track (cif, ofname, heads, trklen,

  00b07	48 8d 84 24 84
	00 00 00	 lea	 rax, QWORD PTR outhead$[rsp]
  00b0f	48 89 44 24 38	 mov	 QWORD PTR [rsp+56], rax
  00b14	48 8d 84 24 80
	00 00 00	 lea	 rax, QWORD PTR outcyl$[rsp]
  00b1c	48 89 44 24 30	 mov	 QWORD PTR [rsp+48], rax
  00b21	48 8d 84 24 b0
	00 00 00	 lea	 rax, QWORD PTR outtrk$[rsp]
  00b29	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  00b2e	48 8d 84 24 b8
	00 00 00	 lea	 rax, QWORD PTR outusedv$[rsp]
  00b36	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00b3b	44 8b 8c 24 48
	02 00 00	 mov	 r9d, DWORD PTR trklen$[rsp]
  00b43	44 8b 84 24 40
	02 00 00	 mov	 r8d, DWORD PTR heads$[rsp]
  00b4b	48 8b 94 24 28
	02 00 00	 mov	 rdx, QWORD PTR ofname$[rsp]
  00b53	48 8b 8c 24 20
	02 00 00	 mov	 rcx, QWORD PTR cif$[rsp]
  00b5b	e8 00 00 00 00	 call	 write_track
  00b60	89 84 24 8c 00
	00 00		 mov	 DWORD PTR rc$[rsp], eax

; 1405 :                     &outusedv, &outtrk, &outcyl, &outhead);
; 1406 :     if (rc < 0) return -1;

  00b67	83 bc 24 8c 00
	00 00 00	 cmp	 DWORD PTR rc$[rsp], 0
  00b6f	7d 0a		 jge	 SHORT $LN20@write_vtoc
  00b71	b8 ff ff ff ff	 mov	 eax, -1
  00b76	e9 a9 00 00 00	 jmp	 $LN1@write_vtoc
$LN20@write_vtoc:

; 1407 : 
; 1408 :     /* Restore original file position if VTOC was preallocated */
; 1409 :     if (prealloc)

  00b7b	83 bc 24 bc 00
	00 00 00	 cmp	 DWORD PTR prealloc$[rsp], 0
  00b83	74 7b		 je	 SHORT $LN21@write_vtoc

; 1410 :     {
; 1411 :         /* Read the original track again */
; 1412 :         rc = read_track( cif, curcyl, (U8) curhead );

  00b85	44 0f b6 84 24
	c0 00 00 00	 movzx	 r8d, BYTE PTR curhead$[rsp]
  00b8e	8b 94 24 c4 00
	00 00		 mov	 edx, DWORD PTR curcyl$[rsp]
  00b95	48 8b 8c 24 20
	02 00 00	 mov	 rcx, QWORD PTR cif$[rsp]
  00b9d	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_read_track
  00ba3	89 84 24 8c 00
	00 00		 mov	 DWORD PTR rc$[rsp], eax

; 1413 :         if (rc < 0)

  00baa	83 bc 24 8c 00
	00 00 00	 cmp	 DWORD PTR rc$[rsp], 0
  00bb2	7d 4a		 jge	 SHORT $LN23@write_vtoc

; 1414 :         {
; 1415 :             XMERRF ( MSG( HHC02530, "E", "track", curcyl, curcyl, curhead, curhead ) );

  00bb4	8b 84 24 c0 00
	00 00		 mov	 eax, DWORD PTR curhead$[rsp]
  00bbb	89 44 24 30	 mov	 DWORD PTR [rsp+48], eax
  00bbf	8b 84 24 c0 00
	00 00		 mov	 eax, DWORD PTR curhead$[rsp]
  00bc6	89 44 24 28	 mov	 DWORD PTR [rsp+40], eax
  00bca	8b 84 24 c4 00
	00 00		 mov	 eax, DWORD PTR curcyl$[rsp]
  00bd1	89 44 24 20	 mov	 DWORD PTR [rsp+32], eax
  00bd5	44 8b 8c 24 c4
	00 00 00	 mov	 r9d, DWORD PTR curcyl$[rsp]
  00bdd	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG161179
  00be4	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG161180
  00beb	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG161181
  00bf2	e8 00 00 00 00	 call	 printf

; 1416 :             return -1;

  00bf7	b8 ff ff ff ff	 mov	 eax, -1
  00bfc	eb 26		 jmp	 SHORT $LN1@write_vtoc
$LN23@write_vtoc:

; 1417 :         }
; 1418 :     }

  00bfe	eb 22		 jmp	 SHORT $LN22@write_vtoc
$LN21@write_vtoc:

; 1419 :     else
; 1420 :     {
; 1421 :         /* Update next cyl and head if VTOC not preallocated */
; 1422 :         *nxtcyl = outcyl;

  00c00	48 8b 84 24 60
	02 00 00	 mov	 rax, QWORD PTR nxtcyl$[rsp]
  00c08	8b 8c 24 80 00
	00 00		 mov	 ecx, DWORD PTR outcyl$[rsp]
  00c0f	89 08		 mov	 DWORD PTR [rax], ecx

; 1423 :         *nxthead = outhead;

  00c11	48 8b 84 24 68
	02 00 00	 mov	 rax, QWORD PTR nxthead$[rsp]
  00c19	8b 8c 24 84 00
	00 00		 mov	 ecx, DWORD PTR outhead$[rsp]
  00c20	89 08		 mov	 DWORD PTR [rax], ecx
$LN22@write_vtoc:

; 1424 :     }
; 1425 : 
; 1426 :     return 0;

  00c22	33 c0		 xor	 eax, eax
$LN1@write_vtoc:

; 1427 : } /* end function write_vtoc */

  00c24	48 8b 8c 24 f0
	01 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  00c2c	48 33 cc	 xor	 rcx, rsp
  00c2f	e8 00 00 00 00	 call	 __security_check_cookie
  00c34	48 81 c4 00 02
	00 00		 add	 rsp, 512		; 00000200H
  00c3b	5f		 pop	 rdi
  00c3c	c3		 ret	 0
write_vtoc ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\dasdload64.c
_TEXT	SEGMENT
blklen$ = 32
datablk$ = 40
f5dscb$ = 48
tv84 = 56
dscbtab$ = 80
dscbnum$ = 88
build_format5_dscb PROC

; 1144 : {

  00000	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00004	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00009	57		 push	 rdi
  0000a	48 83 ec 40	 sub	 rsp, 64			; 00000040H

; 1145 : DATABLK        *datablk;                /* -> Data block structure   */
; 1146 : FORMAT5_DSCB   *f5dscb;                 /* -> DSCB within data block */
; 1147 : int             blklen;                 /* Size of data block        */
; 1148 : 
; 1149 :     /* Allocate storage for a DATABLK structure */
; 1150 :     blklen = 12 + sizeof(FORMAT5_DSCB);

  0000e	c7 44 24 20 98
	00 00 00	 mov	 DWORD PTR blklen$[rsp], 152 ; 00000098H

; 1151 :     datablk = (DATABLK*)malloc(blklen);

  00016	48 63 44 24 20	 movsxd	 rax, DWORD PTR blklen$[rsp]
  0001b	48 8b c8	 mov	 rcx, rax
  0001e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_malloc
  00024	48 89 44 24 28	 mov	 QWORD PTR datablk$[rsp], rax

; 1152 :     if (datablk == NULL)

  00029	48 83 7c 24 28
	00		 cmp	 QWORD PTR datablk$[rsp], 0
  0002f	75 35		 jne	 SHORT $LN2@build_form

; 1153 :     {
; 1154 :         XMERRF ( MSG( HHC02517, "E", "Format 5 ", strerror(errno) ) );

  00031	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno
  00037	8b 08		 mov	 ecx, DWORD PTR [rax]
  00039	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_strerror
  0003f	4c 8b c8	 mov	 r9, rax
  00042	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG161073
  00049	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG161074
  00050	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG161075
  00057	e8 00 00 00 00	 call	 printf

; 1155 :         return -1;

  0005c	b8 ff ff ff ff	 mov	 eax, -1
  00061	e9 84 00 00 00	 jmp	 $LN1@build_form
$LN2@build_form:

; 1156 :     }
; 1157 : 
; 1158 :     /* Check that there is room in the DSCB pointer array */
; 1159 :     if (dscbnum >= MAXDSCB)

  00066	81 7c 24 58 e8
	03 00 00	 cmp	 DWORD PTR dscbnum$[rsp], 1000 ; 000003e8H
  0006e	7c 20		 jl	 SHORT $LN3@build_form

; 1160 :     {
; 1161 :         XMERRF ( MSG( HHC02518, "E", MAXDSCB ) );

  00070	41 b8 e8 03 00
	00		 mov	 r8d, 1000		; 000003e8H
  00076	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG161077
  0007d	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG161078
  00084	e8 00 00 00 00	 call	 printf

; 1162 :         return -1;

  00089	b8 ff ff ff ff	 mov	 eax, -1
  0008e	eb 5a		 jmp	 SHORT $LN1@build_form
$LN3@build_form:

; 1163 :     }
; 1164 : 
; 1165 :     /* Clear the data block and save its address in the DSCB array */
; 1166 :     memset (datablk, 0, blklen);

  00090	48 63 44 24 20	 movsxd	 rax, DWORD PTR blklen$[rsp]
  00095	48 89 44 24 38	 mov	 QWORD PTR tv84[rsp], rax
  0009a	48 8b 7c 24 28	 mov	 rdi, QWORD PTR datablk$[rsp]
  0009f	33 c0		 xor	 eax, eax
  000a1	48 8b 4c 24 38	 mov	 rcx, QWORD PTR tv84[rsp]
  000a6	f3 aa		 rep stosb

; 1167 :     dscbtab[dscbnum] = datablk;

  000a8	48 63 44 24 58	 movsxd	 rax, DWORD PTR dscbnum$[rsp]
  000ad	48 8b 4c 24 50	 mov	 rcx, QWORD PTR dscbtab$[rsp]
  000b2	48 8b 54 24 28	 mov	 rdx, QWORD PTR datablk$[rsp]
  000b7	48 89 14 c1	 mov	 QWORD PTR [rcx+rax*8], rdx

; 1168 : 
; 1169 :     /* Point to the DSCB within the data block */
; 1170 :     f5dscb = (FORMAT5_DSCB*)(datablk->kdarea);

  000bb	48 8b 44 24 28	 mov	 rax, QWORD PTR datablk$[rsp]
  000c0	48 83 c0 0c	 add	 rax, 12
  000c4	48 89 44 24 30	 mov	 QWORD PTR f5dscb$[rsp], rax

; 1171 : 
; 1172 :     /* Build the format 5 DSCB */
; 1173 :     memset (f5dscb->ds5keyid, 0x05, 4);

  000c9	48 8b 44 24 30	 mov	 rax, QWORD PTR f5dscb$[rsp]
  000ce	48 8b 7c 24 30	 mov	 rdi, QWORD PTR f5dscb$[rsp]
  000d3	b8 05 00 00 00	 mov	 eax, 5
  000d8	b9 04 00 00 00	 mov	 ecx, 4
  000dd	f3 aa		 rep stosb

; 1174 :     f5dscb->ds5fmtid = 0xF5;

  000df	48 8b 44 24 30	 mov	 rax, QWORD PTR f5dscb$[rsp]
  000e4	c6 40 2c f5	 mov	 BYTE PTR [rax+44], 245	; 000000f5H

; 1175 : 
; 1176 :     return 0;

  000e8	33 c0		 xor	 eax, eax
$LN1@build_form:

; 1177 : } /* end function build_format5_dscb */

  000ea	48 83 c4 40	 add	 rsp, 64			; 00000040H
  000ee	5f		 pop	 rdi
  000ef	c3		 ret	 0
build_format5_dscb ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\dasdload64.c
_TEXT	SEGMENT
f4dscb$ = 128
devflag$ = 136
numcyls$ = 140
blklen$ = 144
numheads$ = 148
datablk$ = 152
physlen$ = 160
kbconst$ = 164
lbconst$ = 168
nkconst$ = 172
tolfact$ = 176
numdscb$ = 180
numdblk$ = 184
tv148 = 192
dscbtab$ = 224
dscbnum$ = 232
cif$ = 240
build_format4_dscb PROC

; 1053 : {

  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00009	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000e	57		 push	 rdi
  0000f	48 81 ec d0 00
	00 00		 sub	 rsp, 208		; 000000d0H

; 1054 : DATABLK        *datablk;                /* -> Data block structure   */
; 1055 : FORMAT4_DSCB   *f4dscb;                 /* -> DSCB within data block */
; 1056 : int             blklen;                 /* Size of data block        */
; 1057 : int             numdscb;                /* Number of DSCBs per track */
; 1058 : int             numdblk;                /* Number of dir blks/track  */
; 1059 : int             physlen;                /* Physical track length     */
; 1060 : int             numcyls;                /* Device size in cylinders  */
; 1061 : int             numheads;               /* Number of heads/cylinder  */
; 1062 : int             kbconst;                /* Keyed block constant      */
; 1063 : int             lbconst;                /* Last keyed block constant */
; 1064 : int             nkconst;                /* Non-keyed block constant  */
; 1065 : BYTE            devflag;                /* Device flags for VTOC     */
; 1066 : int             tolfact;                /* Device tolerance          */
; 1067 : 
; 1068 :     /* Calculate the physical track length, block overheads, device
; 1069 :        size, and the number of DSCBs and directory blocks per track */
; 1070 :     capacity_calc (cif, 0, 44, 96, NULL, NULL, &physlen, &kbconst,

  00016	48 8d 84 24 8c
	00 00 00	 lea	 rax, QWORD PTR numcyls$[rsp]
  0001e	48 89 44 24 78	 mov	 QWORD PTR [rsp+120], rax
  00023	48 8d 84 24 94
	00 00 00	 lea	 rax, QWORD PTR numheads$[rsp]
  0002b	48 89 44 24 70	 mov	 QWORD PTR [rsp+112], rax
  00030	48 8d 84 24 b4
	00 00 00	 lea	 rax, QWORD PTR numdscb$[rsp]
  00038	48 89 44 24 68	 mov	 QWORD PTR [rsp+104], rax
  0003d	48 c7 44 24 60
	00 00 00 00	 mov	 QWORD PTR [rsp+96], 0
  00046	48 8d 84 24 b0
	00 00 00	 lea	 rax, QWORD PTR tolfact$[rsp]
  0004e	48 89 44 24 58	 mov	 QWORD PTR [rsp+88], rax
  00053	48 8d 84 24 88
	00 00 00	 lea	 rax, QWORD PTR devflag$[rsp]
  0005b	48 89 44 24 50	 mov	 QWORD PTR [rsp+80], rax
  00060	48 8d 84 24 ac
	00 00 00	 lea	 rax, QWORD PTR nkconst$[rsp]
  00068	48 89 44 24 48	 mov	 QWORD PTR [rsp+72], rax
  0006d	48 8d 84 24 a8
	00 00 00	 lea	 rax, QWORD PTR lbconst$[rsp]
  00075	48 89 44 24 40	 mov	 QWORD PTR [rsp+64], rax
  0007a	48 8d 84 24 a4
	00 00 00	 lea	 rax, QWORD PTR kbconst$[rsp]
  00082	48 89 44 24 38	 mov	 QWORD PTR [rsp+56], rax
  00087	48 8d 84 24 a0
	00 00 00	 lea	 rax, QWORD PTR physlen$[rsp]
  0008f	48 89 44 24 30	 mov	 QWORD PTR [rsp+48], rax
  00094	48 c7 44 24 28
	00 00 00 00	 mov	 QWORD PTR [rsp+40], 0
  0009d	48 c7 44 24 20
	00 00 00 00	 mov	 QWORD PTR [rsp+32], 0
  000a6	41 b9 60 00 00
	00		 mov	 r9d, 96			; 00000060H
  000ac	41 b8 2c 00 00
	00		 mov	 r8d, 44			; 0000002cH
  000b2	33 d2		 xor	 edx, edx
  000b4	48 8b 8c 24 f0
	00 00 00	 mov	 rcx, QWORD PTR cif$[rsp]
  000bc	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_capacity_calc

; 1071 :                     &lbconst, &nkconst, &devflag, &tolfact, NULL,
; 1072 :                     &numdscb, &numheads, &numcyls);
; 1073 :     capacity_calc (cif, 0, 8, 256, NULL, NULL, NULL,

  000c2	48 c7 44 24 78
	00 00 00 00	 mov	 QWORD PTR [rsp+120], 0
  000cb	48 c7 44 24 70
	00 00 00 00	 mov	 QWORD PTR [rsp+112], 0
  000d4	48 8d 84 24 b8
	00 00 00	 lea	 rax, QWORD PTR numdblk$[rsp]
  000dc	48 89 44 24 68	 mov	 QWORD PTR [rsp+104], rax
  000e1	48 c7 44 24 60
	00 00 00 00	 mov	 QWORD PTR [rsp+96], 0
  000ea	48 c7 44 24 58
	00 00 00 00	 mov	 QWORD PTR [rsp+88], 0
  000f3	48 c7 44 24 50
	00 00 00 00	 mov	 QWORD PTR [rsp+80], 0
  000fc	48 c7 44 24 48
	00 00 00 00	 mov	 QWORD PTR [rsp+72], 0
  00105	48 c7 44 24 40
	00 00 00 00	 mov	 QWORD PTR [rsp+64], 0
  0010e	48 c7 44 24 38
	00 00 00 00	 mov	 QWORD PTR [rsp+56], 0
  00117	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR [rsp+48], 0
  00120	48 c7 44 24 28
	00 00 00 00	 mov	 QWORD PTR [rsp+40], 0
  00129	48 c7 44 24 20
	00 00 00 00	 mov	 QWORD PTR [rsp+32], 0
  00132	41 b9 00 01 00
	00		 mov	 r9d, 256		; 00000100H
  00138	41 b8 08 00 00
	00		 mov	 r8d, 8
  0013e	33 d2		 xor	 edx, edx
  00140	48 8b 8c 24 f0
	00 00 00	 mov	 rcx, QWORD PTR cif$[rsp]
  00148	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_capacity_calc

; 1074 :                     NULL, NULL, NULL, NULL, NULL, NULL,
; 1075 :                     &numdblk, NULL, NULL);
; 1076 : 
; 1077 :     /* Allocate storage for a DATABLK structure */
; 1078 :     blklen = 12 + sizeof(FORMAT4_DSCB);

  0014e	c7 84 24 90 00
	00 00 98 00 00
	00		 mov	 DWORD PTR blklen$[rsp], 152 ; 00000098H

; 1079 :     datablk = (DATABLK*)malloc(blklen);

  00159	48 63 84 24 90
	00 00 00	 movsxd	 rax, DWORD PTR blklen$[rsp]
  00161	48 8b c8	 mov	 rcx, rax
  00164	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_malloc
  0016a	48 89 84 24 98
	00 00 00	 mov	 QWORD PTR datablk$[rsp], rax

; 1080 :     if (datablk == NULL)

  00172	48 83 bc 24 98
	00 00 00 00	 cmp	 QWORD PTR datablk$[rsp], 0
  0017b	75 35		 jne	 SHORT $LN2@build_form

; 1081 :     {
; 1082 :         XMERRF ( MSG( HHC02517, "E", "Format 4 ", strerror(errno) ) );

  0017d	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno
  00183	8b 08		 mov	 ecx, DWORD PTR [rax]
  00185	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_strerror
  0018b	4c 8b c8	 mov	 r9, rax
  0018e	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG161053
  00195	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG161054
  0019c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG161055
  001a3	e8 00 00 00 00	 call	 printf

; 1083 :         return -1;

  001a8	b8 ff ff ff ff	 mov	 eax, -1
  001ad	e9 90 02 00 00	 jmp	 $LN1@build_form
$LN2@build_form:

; 1084 :     }
; 1085 : 
; 1086 :     /* Check that there is room in the DSCB pointer array */
; 1087 :     if (dscbnum >= MAXDSCB)

  001b2	81 bc 24 e8 00
	00 00 e8 03 00
	00		 cmp	 DWORD PTR dscbnum$[rsp], 1000 ; 000003e8H
  001bd	7c 23		 jl	 SHORT $LN3@build_form

; 1088 :     {
; 1089 :         XMERRF ( MSG( HHC02518, "E", MAXDSCB ) );

  001bf	41 b8 e8 03 00
	00		 mov	 r8d, 1000		; 000003e8H
  001c5	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG161057
  001cc	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG161058
  001d3	e8 00 00 00 00	 call	 printf

; 1090 :         return -1;

  001d8	b8 ff ff ff ff	 mov	 eax, -1
  001dd	e9 60 02 00 00	 jmp	 $LN1@build_form
$LN3@build_form:

; 1091 :     }
; 1092 : 
; 1093 :     /* Clear the data block and save its address in the DSCB array */
; 1094 :     memset (datablk, 0, blklen);

  001e2	48 63 84 24 90
	00 00 00	 movsxd	 rax, DWORD PTR blklen$[rsp]
  001ea	48 89 84 24 c0
	00 00 00	 mov	 QWORD PTR tv148[rsp], rax
  001f2	48 8b bc 24 98
	00 00 00	 mov	 rdi, QWORD PTR datablk$[rsp]
  001fa	33 c0		 xor	 eax, eax
  001fc	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR tv148[rsp]
  00204	f3 aa		 rep stosb

; 1095 :     dscbtab[dscbnum] = datablk;

  00206	48 63 84 24 e8
	00 00 00	 movsxd	 rax, DWORD PTR dscbnum$[rsp]
  0020e	48 8b 8c 24 e0
	00 00 00	 mov	 rcx, QWORD PTR dscbtab$[rsp]
  00216	48 8b 94 24 98
	00 00 00	 mov	 rdx, QWORD PTR datablk$[rsp]
  0021e	48 89 14 c1	 mov	 QWORD PTR [rcx+rax*8], rdx

; 1096 : 
; 1097 :     /* Point to the DSCB within the data block */
; 1098 :     f4dscb = (FORMAT4_DSCB*)(datablk->kdarea);

  00222	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR datablk$[rsp]
  0022a	48 83 c0 0c	 add	 rax, 12
  0022e	48 89 84 24 80
	00 00 00	 mov	 QWORD PTR f4dscb$[rsp], rax

; 1099 : 
; 1100 :     /* Build the format 4 DSCB */
; 1101 :     memset (f4dscb->ds4keyid, 0x04, 44);

  00236	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR f4dscb$[rsp]
  0023e	48 8b bc 24 80
	00 00 00	 mov	 rdi, QWORD PTR f4dscb$[rsp]
  00246	b8 04 00 00 00	 mov	 eax, 4
  0024b	b9 2c 00 00 00	 mov	 ecx, 44			; 0000002cH
  00250	f3 aa		 rep stosb

; 1102 :     f4dscb->ds4fmtid = 0xF4;

  00252	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR f4dscb$[rsp]
  0025a	c6 40 2c f4	 mov	 BYTE PTR [rax+44], 244	; 000000f4H

; 1103 :     f4dscb->ds4hcchh[0] = (numcyls >> 8) & 0xFF;

  0025e	8b 84 24 8c 00
	00 00		 mov	 eax, DWORD PTR numcyls$[rsp]
  00265	c1 f8 08	 sar	 eax, 8
  00268	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  0026d	b9 01 00 00 00	 mov	 ecx, 1
  00272	48 6b c9 00	 imul	 rcx, rcx, 0
  00276	48 8b 94 24 80
	00 00 00	 mov	 rdx, QWORD PTR f4dscb$[rsp]
  0027e	88 44 0a 34	 mov	 BYTE PTR [rdx+rcx+52], al

; 1104 :     f4dscb->ds4hcchh[1] = numcyls & 0xFF;

  00282	8b 84 24 8c 00
	00 00		 mov	 eax, DWORD PTR numcyls$[rsp]
  00289	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  0028e	b9 01 00 00 00	 mov	 ecx, 1
  00293	48 6b c9 01	 imul	 rcx, rcx, 1
  00297	48 8b 94 24 80
	00 00 00	 mov	 rdx, QWORD PTR f4dscb$[rsp]
  0029f	88 44 0a 34	 mov	 BYTE PTR [rdx+rcx+52], al

; 1105 :     f4dscb->ds4hcchh[2] = 0;

  002a3	b8 01 00 00 00	 mov	 eax, 1
  002a8	48 6b c0 02	 imul	 rax, rax, 2
  002ac	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR f4dscb$[rsp]
  002b4	c6 44 01 34 00	 mov	 BYTE PTR [rcx+rax+52], 0

; 1106 :     f4dscb->ds4hcchh[3] = 0;

  002b9	b8 01 00 00 00	 mov	 eax, 1
  002be	48 6b c0 03	 imul	 rax, rax, 3
  002c2	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR f4dscb$[rsp]
  002ca	c6 44 01 34 00	 mov	 BYTE PTR [rcx+rax+52], 0

; 1107 :     store_hw( f4dscb->ds4noatk, 0 );

  002cf	33 c9		 xor	 ecx, ecx
  002d1	e8 00 00 00 00	 call	 _byteswap_ushort
  002d6	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR f4dscb$[rsp]
  002de	48 83 c1 38	 add	 rcx, 56			; 00000038H
  002e2	0f b7 d0	 movzx	 edx, ax
  002e5	e8 00 00 00 00	 call	 store_hw_noswap

; 1108 :     f4dscb->ds4vtoci = DS4VTOCI_DOS;

  002ea	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR f4dscb$[rsp]
  002f2	c6 40 3a 80	 mov	 BYTE PTR [rax+58], 128	; 00000080H

; 1109 :     f4dscb->ds4noext = 1;

  002f6	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR f4dscb$[rsp]
  002fe	c6 40 3b 01	 mov	 BYTE PTR [rax+59], 1

; 1110 :     f4dscb->ds4devsz[0] = (numcyls >> 8) & 0xFF;

  00302	8b 84 24 8c 00
	00 00		 mov	 eax, DWORD PTR numcyls$[rsp]
  00309	c1 f8 08	 sar	 eax, 8
  0030c	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  00311	b9 01 00 00 00	 mov	 ecx, 1
  00316	48 6b c9 00	 imul	 rcx, rcx, 0
  0031a	48 8b 94 24 80
	00 00 00	 mov	 rdx, QWORD PTR f4dscb$[rsp]
  00322	88 44 0a 3e	 mov	 BYTE PTR [rdx+rcx+62], al

; 1111 :     f4dscb->ds4devsz[1] = numcyls & 0xFF;

  00326	8b 84 24 8c 00
	00 00		 mov	 eax, DWORD PTR numcyls$[rsp]
  0032d	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  00332	b9 01 00 00 00	 mov	 ecx, 1
  00337	48 6b c9 01	 imul	 rcx, rcx, 1
  0033b	48 8b 94 24 80
	00 00 00	 mov	 rdx, QWORD PTR f4dscb$[rsp]
  00343	88 44 0a 3e	 mov	 BYTE PTR [rdx+rcx+62], al

; 1112 :     f4dscb->ds4devsz[2] = (numheads >> 8) & 0xFF;

  00347	8b 84 24 94 00
	00 00		 mov	 eax, DWORD PTR numheads$[rsp]
  0034e	c1 f8 08	 sar	 eax, 8
  00351	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  00356	b9 01 00 00 00	 mov	 ecx, 1
  0035b	48 6b c9 02	 imul	 rcx, rcx, 2
  0035f	48 8b 94 24 80
	00 00 00	 mov	 rdx, QWORD PTR f4dscb$[rsp]
  00367	88 44 0a 3e	 mov	 BYTE PTR [rdx+rcx+62], al

; 1113 :     f4dscb->ds4devsz[3] = numheads & 0xFF;

  0036b	8b 84 24 94 00
	00 00		 mov	 eax, DWORD PTR numheads$[rsp]
  00372	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  00377	b9 01 00 00 00	 mov	 ecx, 1
  0037c	48 6b c9 03	 imul	 rcx, rcx, 3
  00380	48 8b 94 24 80
	00 00 00	 mov	 rdx, QWORD PTR f4dscb$[rsp]
  00388	88 44 0a 3e	 mov	 BYTE PTR [rdx+rcx+62], al

; 1114 :     store_hw( f4dscb->ds4devtk, physlen );

  0038c	0f b7 8c 24 a0
	00 00 00	 movzx	 ecx, WORD PTR physlen$[rsp]
  00394	e8 00 00 00 00	 call	 _byteswap_ushort
  00399	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR f4dscb$[rsp]
  003a1	48 83 c1 42	 add	 rcx, 66			; 00000042H
  003a5	0f b7 d0	 movzx	 edx, ax
  003a8	e8 00 00 00 00	 call	 store_hw_noswap

; 1115 :     f4dscb->ds4devi = kbconst;

  003ad	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR f4dscb$[rsp]
  003b5	0f b6 8c 24 a4
	00 00 00	 movzx	 ecx, BYTE PTR kbconst$[rsp]
  003bd	88 48 44	 mov	 BYTE PTR [rax+68], cl

; 1116 :     f4dscb->ds4devl = lbconst;

  003c0	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR f4dscb$[rsp]
  003c8	0f b6 8c 24 a8
	00 00 00	 movzx	 ecx, BYTE PTR lbconst$[rsp]
  003d0	88 48 45	 mov	 BYTE PTR [rax+69], cl

; 1117 :     f4dscb->ds4devk = nkconst;

  003d3	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR f4dscb$[rsp]
  003db	0f b6 8c 24 ac
	00 00 00	 movzx	 ecx, BYTE PTR nkconst$[rsp]
  003e3	88 48 46	 mov	 BYTE PTR [rax+70], cl

; 1118 :     f4dscb->ds4devfg = devflag;

  003e6	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR f4dscb$[rsp]
  003ee	0f b6 8c 24 88
	00 00 00	 movzx	 ecx, BYTE PTR devflag$[rsp]
  003f6	88 48 47	 mov	 BYTE PTR [rax+71], cl

; 1119 :     store_hw( f4dscb->ds4devtl, tolfact );

  003f9	0f b7 8c 24 b0
	00 00 00	 movzx	 ecx, WORD PTR tolfact$[rsp]
  00401	e8 00 00 00 00	 call	 _byteswap_ushort
  00406	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR f4dscb$[rsp]
  0040e	48 83 c1 48	 add	 rcx, 72			; 00000048H
  00412	0f b7 d0	 movzx	 edx, ax
  00415	e8 00 00 00 00	 call	 store_hw_noswap

; 1120 :     f4dscb->ds4devdt = numdscb;

  0041a	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR f4dscb$[rsp]
  00422	0f b6 8c 24 b4
	00 00 00	 movzx	 ecx, BYTE PTR numdscb$[rsp]
  0042a	88 48 4a	 mov	 BYTE PTR [rax+74], cl

; 1121 :     f4dscb->ds4devdb = numdblk;

  0042d	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR f4dscb$[rsp]
  00435	0f b6 8c 24 b8
	00 00 00	 movzx	 ecx, BYTE PTR numdblk$[rsp]
  0043d	88 48 4b	 mov	 BYTE PTR [rax+75], cl

; 1122 : 
; 1123 :     return 0;

  00440	33 c0		 xor	 eax, eax
$LN1@build_form:

; 1124 : } /* end function build_format4_dscb */

  00442	48 81 c4 d0 00
	00 00		 add	 rsp, 208		; 000000d0H
  00449	5f		 pop	 rdi
  0044a	c3		 ret	 0
build_format4_dscb ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\dasdload64.c
_TEXT	SEGMENT
blklen$ = 32
tv214 = 36
tv238 = 40
f1dscb$ = 48
datablk$ = 56
tmptr$ = 64
timeval$ = 72
tv87 = 80
dscbtab$ = 112
dscbnum$ = 120
dsname$ = 128
volser$ = 136
dsorg$ = 144
recfm$ = 152
lrecl$ = 160
blksz$ = 168
keyln$ = 176
dirblu$ = 184
lasttrk$ = 192
lastrec$ = 200
trkbal$ = 208
units$ = 216
spsec$ = 224
bcyl$ = 232
bhead$ = 240
ecyl$ = 248
ehead$ = 256
build_format1_dscb PROC

; 956  : {

  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  0000e	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00013	57		 push	 rdi
  00014	48 83 ec 60	 sub	 rsp, 96			; 00000060H

; 957  : DATABLK        *datablk;                /* -> Data block structure   */
; 958  : FORMAT1_DSCB   *f1dscb;                 /* -> DSCB within data block */
; 959  : int             blklen;                 /* Size of data block        */
; 960  : struct tm      *tmptr;                  /* -> Date and time structure*/
; 961  : time_t          timeval;                /* Current time value        */
; 962  : 
; 963  :     /* Obtain the current time */
; 964  :     time(&timeval);

  00018	48 8d 4c 24 48	 lea	 rcx, QWORD PTR timeval$[rsp]
  0001d	e8 00 00 00 00	 call	 time

; 965  :     tmptr = localtime(&timeval);

  00022	48 8d 4c 24 48	 lea	 rcx, QWORD PTR timeval$[rsp]
  00027	e8 00 00 00 00	 call	 localtime
  0002c	48 89 44 24 40	 mov	 QWORD PTR tmptr$[rsp], rax

; 966  : 
; 967  :     /* Allocate storage for a DATABLK structure */
; 968  :     blklen = 12 + sizeof(FORMAT1_DSCB);

  00031	c7 44 24 20 98
	00 00 00	 mov	 DWORD PTR blklen$[rsp], 152 ; 00000098H

; 969  :     datablk = (DATABLK*)malloc(blklen);

  00039	48 63 44 24 20	 movsxd	 rax, DWORD PTR blklen$[rsp]
  0003e	48 8b c8	 mov	 rcx, rax
  00041	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_malloc
  00047	48 89 44 24 38	 mov	 QWORD PTR datablk$[rsp], rax

; 970  :     if (datablk == NULL)

  0004c	48 83 7c 24 38
	00		 cmp	 QWORD PTR datablk$[rsp], 0
  00052	75 35		 jne	 SHORT $LN2@build_form

; 971  :     {
; 972  :         XMERRF ( MSG( HHC02517, "E", "Format 1 ", strerror(errno) ) );

  00054	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno
  0005a	8b 08		 mov	 ecx, DWORD PTR [rax]
  0005c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_strerror
  00062	4c 8b c8	 mov	 r9, rax
  00065	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG161005
  0006c	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG161006
  00073	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG161007
  0007a	e8 00 00 00 00	 call	 printf

; 973  :         return -1;

  0007f	b8 ff ff ff ff	 mov	 eax, -1
  00084	e9 dc 03 00 00	 jmp	 $LN1@build_form
$LN2@build_form:

; 974  :     }
; 975  : 
; 976  :     /* Check that there is room in the DSCB pointer array */
; 977  :     if (dscbnum >= MAXDSCB)

  00089	81 7c 24 78 e8
	03 00 00	 cmp	 DWORD PTR dscbnum$[rsp], 1000 ; 000003e8H
  00091	7c 23		 jl	 SHORT $LN3@build_form

; 978  :     {
; 979  :         XMERRF ( MSG( HHC02518, "E", MAXDSCB ) );

  00093	41 b8 e8 03 00
	00		 mov	 r8d, 1000		; 000003e8H
  00099	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG161009
  000a0	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG161010
  000a7	e8 00 00 00 00	 call	 printf

; 980  :         return -1;

  000ac	b8 ff ff ff ff	 mov	 eax, -1
  000b1	e9 af 03 00 00	 jmp	 $LN1@build_form
$LN3@build_form:

; 981  :     }
; 982  : 
; 983  :     /* Clear the data block and save its address in the DSCB array */
; 984  :     memset (datablk, 0, blklen);

  000b6	48 63 44 24 20	 movsxd	 rax, DWORD PTR blklen$[rsp]
  000bb	48 89 44 24 50	 mov	 QWORD PTR tv87[rsp], rax
  000c0	48 8b 7c 24 38	 mov	 rdi, QWORD PTR datablk$[rsp]
  000c5	33 c0		 xor	 eax, eax
  000c7	48 8b 4c 24 50	 mov	 rcx, QWORD PTR tv87[rsp]
  000cc	f3 aa		 rep stosb

; 985  :     dscbtab[dscbnum] = datablk;

  000ce	48 63 44 24 78	 movsxd	 rax, DWORD PTR dscbnum$[rsp]
  000d3	48 8b 4c 24 70	 mov	 rcx, QWORD PTR dscbtab$[rsp]
  000d8	48 8b 54 24 38	 mov	 rdx, QWORD PTR datablk$[rsp]
  000dd	48 89 14 c1	 mov	 QWORD PTR [rcx+rax*8], rdx

; 986  : 
; 987  :     /* Point to the DSCB within the data block */
; 988  :     f1dscb = (FORMAT1_DSCB*)(datablk->kdarea);

  000e1	48 8b 44 24 38	 mov	 rax, QWORD PTR datablk$[rsp]
  000e6	48 83 c0 0c	 add	 rax, 12
  000ea	48 89 44 24 30	 mov	 QWORD PTR f1dscb$[rsp], rax

; 989  : 
; 990  :     /* Build the format 1 DSCB */
; 991  :     convert_to_ebcdic (f1dscb->ds1dsnam, 44, dsname);

  000ef	48 8b 44 24 30	 mov	 rax, QWORD PTR f1dscb$[rsp]
  000f4	4c 8b 84 24 80
	00 00 00	 mov	 r8, QWORD PTR dsname$[rsp]
  000fc	ba 2c 00 00 00	 mov	 edx, 44			; 0000002cH
  00101	48 8b c8	 mov	 rcx, rax
  00104	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_convert_to_ebcdic

; 992  :     f1dscb->ds1fmtid = 0xF1;

  0010a	48 8b 44 24 30	 mov	 rax, QWORD PTR f1dscb$[rsp]
  0010f	c6 40 2c f1	 mov	 BYTE PTR [rax+44], 241	; 000000f1H

; 993  :     convert_to_ebcdic (f1dscb->ds1dssn, 6, volser);

  00113	48 8b 44 24 30	 mov	 rax, QWORD PTR f1dscb$[rsp]
  00118	48 83 c0 2d	 add	 rax, 45			; 0000002dH
  0011c	4c 8b 84 24 88
	00 00 00	 mov	 r8, QWORD PTR volser$[rsp]
  00124	ba 06 00 00 00	 mov	 edx, 6
  00129	48 8b c8	 mov	 rcx, rax
  0012c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_convert_to_ebcdic

; 994  :     store_hw( f1dscb->ds1volsq, 1 );

  00132	66 b9 01 00	 mov	 cx, 1
  00136	e8 00 00 00 00	 call	 _byteswap_ushort
  0013b	48 8b 4c 24 30	 mov	 rcx, QWORD PTR f1dscb$[rsp]
  00140	48 83 c1 33	 add	 rcx, 51			; 00000033H
  00144	0f b7 d0	 movzx	 edx, ax
  00147	e8 00 00 00 00	 call	 store_hw_noswap

; 995  :     f1dscb->ds1credt[0] = (BYTE) tmptr->tm_year;

  0014c	b8 01 00 00 00	 mov	 eax, 1
  00151	48 6b c0 00	 imul	 rax, rax, 0
  00155	48 8b 4c 24 30	 mov	 rcx, QWORD PTR f1dscb$[rsp]
  0015a	48 8b 54 24 40	 mov	 rdx, QWORD PTR tmptr$[rsp]
  0015f	0f b6 52 14	 movzx	 edx, BYTE PTR [rdx+20]
  00163	88 54 01 35	 mov	 BYTE PTR [rcx+rax+53], dl

; 996  :     f1dscb->ds1credt[1] = (tmptr->tm_yday >> 8) & 0xFF;

  00167	48 8b 44 24 40	 mov	 rax, QWORD PTR tmptr$[rsp]
  0016c	8b 40 1c	 mov	 eax, DWORD PTR [rax+28]
  0016f	c1 f8 08	 sar	 eax, 8
  00172	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  00177	b9 01 00 00 00	 mov	 ecx, 1
  0017c	48 6b c9 01	 imul	 rcx, rcx, 1
  00180	48 8b 54 24 30	 mov	 rdx, QWORD PTR f1dscb$[rsp]
  00185	88 44 0a 35	 mov	 BYTE PTR [rdx+rcx+53], al

; 997  :     f1dscb->ds1credt[2] = tmptr->tm_yday & 0xFF;

  00189	48 8b 44 24 40	 mov	 rax, QWORD PTR tmptr$[rsp]
  0018e	8b 40 1c	 mov	 eax, DWORD PTR [rax+28]
  00191	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  00196	b9 01 00 00 00	 mov	 ecx, 1
  0019b	48 6b c9 02	 imul	 rcx, rcx, 2
  0019f	48 8b 54 24 30	 mov	 rdx, QWORD PTR f1dscb$[rsp]
  001a4	88 44 0a 35	 mov	 BYTE PTR [rdx+rcx+53], al

; 998  :     f1dscb->ds1expdt[0] = 0;

  001a8	b8 01 00 00 00	 mov	 eax, 1
  001ad	48 6b c0 00	 imul	 rax, rax, 0
  001b1	48 8b 4c 24 30	 mov	 rcx, QWORD PTR f1dscb$[rsp]
  001b6	c6 44 01 38 00	 mov	 BYTE PTR [rcx+rax+56], 0

; 999  :     f1dscb->ds1expdt[1] = 0;

  001bb	b8 01 00 00 00	 mov	 eax, 1
  001c0	48 6b c0 01	 imul	 rax, rax, 1
  001c4	48 8b 4c 24 30	 mov	 rcx, QWORD PTR f1dscb$[rsp]
  001c9	c6 44 01 38 00	 mov	 BYTE PTR [rcx+rax+56], 0

; 1000 :     f1dscb->ds1expdt[2] = 0;

  001ce	b8 01 00 00 00	 mov	 eax, 1
  001d3	48 6b c0 02	 imul	 rax, rax, 2
  001d7	48 8b 4c 24 30	 mov	 rcx, QWORD PTR f1dscb$[rsp]
  001dc	c6 44 01 38 00	 mov	 BYTE PTR [rcx+rax+56], 0

; 1001 :     f1dscb->ds1noepv = 1;

  001e1	48 8b 44 24 30	 mov	 rax, QWORD PTR f1dscb$[rsp]
  001e6	c6 40 3b 01	 mov	 BYTE PTR [rax+59], 1

; 1002 :     f1dscb->ds1bodbd = (BYTE) dirblu;

  001ea	48 8b 44 24 30	 mov	 rax, QWORD PTR f1dscb$[rsp]
  001ef	0f b6 8c 24 b8
	00 00 00	 movzx	 ecx, BYTE PTR dirblu$[rsp]
  001f7	88 48 3c	 mov	 BYTE PTR [rax+60], cl

; 1003 :     convert_to_ebcdic (f1dscb->ds1syscd, 13, "HERCULES");

  001fa	48 8b 44 24 30	 mov	 rax, QWORD PTR f1dscb$[rsp]
  001ff	48 83 c0 3e	 add	 rax, 62			; 0000003eH
  00203	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG161011
  0020a	ba 0d 00 00 00	 mov	 edx, 13
  0020f	48 8b c8	 mov	 rcx, rax
  00212	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_convert_to_ebcdic

; 1004 :     f1dscb->ds1dsorg[0] = dsorg;

  00218	b8 01 00 00 00	 mov	 eax, 1
  0021d	48 6b c0 00	 imul	 rax, rax, 0
  00221	48 8b 4c 24 30	 mov	 rcx, QWORD PTR f1dscb$[rsp]
  00226	0f b6 94 24 90
	00 00 00	 movzx	 edx, BYTE PTR dsorg$[rsp]
  0022e	88 54 01 52	 mov	 BYTE PTR [rcx+rax+82], dl

; 1005 :     f1dscb->ds1dsorg[1] = 0;

  00232	b8 01 00 00 00	 mov	 eax, 1
  00237	48 6b c0 01	 imul	 rax, rax, 1
  0023b	48 8b 4c 24 30	 mov	 rcx, QWORD PTR f1dscb$[rsp]
  00240	c6 44 01 52 00	 mov	 BYTE PTR [rcx+rax+82], 0

; 1006 :     f1dscb->ds1recfm = recfm;

  00245	48 8b 44 24 30	 mov	 rax, QWORD PTR f1dscb$[rsp]
  0024a	0f b6 8c 24 98
	00 00 00	 movzx	 ecx, BYTE PTR recfm$[rsp]
  00252	88 48 54	 mov	 BYTE PTR [rax+84], cl

; 1007 :     f1dscb->ds1optcd = 0;

  00255	48 8b 44 24 30	 mov	 rax, QWORD PTR f1dscb$[rsp]
  0025a	c6 40 55 00	 mov	 BYTE PTR [rax+85], 0

; 1008 :     store_hw( f1dscb->ds1blkl,  blksz );

  0025e	0f b7 8c 24 a8
	00 00 00	 movzx	 ecx, WORD PTR blksz$[rsp]
  00266	e8 00 00 00 00	 call	 _byteswap_ushort
  0026b	48 8b 4c 24 30	 mov	 rcx, QWORD PTR f1dscb$[rsp]
  00270	48 83 c1 56	 add	 rcx, 86			; 00000056H
  00274	0f b7 d0	 movzx	 edx, ax
  00277	e8 00 00 00 00	 call	 store_hw_noswap

; 1009 :     store_hw( f1dscb->ds1lrecl, lrecl );

  0027c	0f b7 8c 24 a0
	00 00 00	 movzx	 ecx, WORD PTR lrecl$[rsp]
  00284	e8 00 00 00 00	 call	 _byteswap_ushort
  00289	48 8b 4c 24 30	 mov	 rcx, QWORD PTR f1dscb$[rsp]
  0028e	48 83 c1 58	 add	 rcx, 88			; 00000058H
  00292	0f b7 d0	 movzx	 edx, ax
  00295	e8 00 00 00 00	 call	 store_hw_noswap

; 1010 :     f1dscb->ds1keyl = (BYTE) keyln;

  0029a	48 8b 44 24 30	 mov	 rax, QWORD PTR f1dscb$[rsp]
  0029f	0f b6 8c 24 b0
	00 00 00	 movzx	 ecx, BYTE PTR keyln$[rsp]
  002a7	88 48 5a	 mov	 BYTE PTR [rax+90], cl

; 1011 :     store_hw( f1dscb->ds1rkp, 0 );

  002aa	33 c9		 xor	 ecx, ecx
  002ac	e8 00 00 00 00	 call	 _byteswap_ushort
  002b1	48 8b 4c 24 30	 mov	 rcx, QWORD PTR f1dscb$[rsp]
  002b6	48 83 c1 5b	 add	 rcx, 91			; 0000005bH
  002ba	0f b7 d0	 movzx	 edx, ax
  002bd	e8 00 00 00 00	 call	 store_hw_noswap

; 1012 :     f1dscb->ds1dsind = DS1DSIND_LASTVOL;

  002c2	48 8b 44 24 30	 mov	 rax, QWORD PTR f1dscb$[rsp]
  002c7	c6 40 5d 80	 mov	 BYTE PTR [rax+93], 128	; 00000080H

; 1013 :     if ((blksz & 0x07) == 0)

  002cb	8b 84 24 a8 00
	00 00		 mov	 eax, DWORD PTR blksz$[rsp]
  002d2	83 e0 07	 and	 eax, 7
  002d5	85 c0		 test	 eax, eax
  002d7	75 14		 jne	 SHORT $LN4@build_form

; 1014 :         f1dscb->ds1dsind |= DS1DSIND_BLKSIZ8;

  002d9	48 8b 44 24 30	 mov	 rax, QWORD PTR f1dscb$[rsp]
  002de	0f b6 40 5d	 movzx	 eax, BYTE PTR [rax+93]
  002e2	83 c8 20	 or	 eax, 32			; 00000020H
  002e5	48 8b 4c 24 30	 mov	 rcx, QWORD PTR f1dscb$[rsp]
  002ea	88 41 5d	 mov	 BYTE PTR [rcx+93], al
$LN4@build_form:

; 1015 :     store_fw( f1dscb->ds1scalo, spsec );

  002ed	8b 8c 24 e0 00
	00 00		 mov	 ecx, DWORD PTR spsec$[rsp]
  002f4	e8 00 00 00 00	 call	 _byteswap_ulong
  002f9	48 8b 4c 24 30	 mov	 rcx, QWORD PTR f1dscb$[rsp]
  002fe	48 83 c1 5e	 add	 rcx, 94			; 0000005eH
  00302	8b d0		 mov	 edx, eax
  00304	e8 00 00 00 00	 call	 store_fw_noswap

; 1016 :     f1dscb->ds1scalo[0] =

  00309	0f b6 84 24 d8
	00 00 00	 movzx	 eax, BYTE PTR units$[rsp]
  00311	83 f8 43	 cmp	 eax, 67			; 00000043H
  00314	75 0a		 jne	 SHORT $LN6@build_form
  00316	c7 44 24 24 c0
	00 00 00	 mov	 DWORD PTR tv214[rsp], 192 ; 000000c0H
  0031e	eb 08		 jmp	 SHORT $LN7@build_form
$LN6@build_form:
  00320	c7 44 24 24 80
	00 00 00	 mov	 DWORD PTR tv214[rsp], 128 ; 00000080H
$LN7@build_form:
  00328	b8 01 00 00 00	 mov	 eax, 1
  0032d	48 6b c0 00	 imul	 rax, rax, 0
  00331	48 8b 4c 24 30	 mov	 rcx, QWORD PTR f1dscb$[rsp]
  00336	0f b6 54 24 24	 movzx	 edx, BYTE PTR tv214[rsp]
  0033b	88 54 01 5e	 mov	 BYTE PTR [rcx+rax+94], dl

; 1017 :         (units == 'C' ? DS1SCALO_UNITS_CYL : DS1SCALO_UNITS_TRK);
; 1018 :     f1dscb->ds1lstar[0] = (lasttrk >> 8) & 0xFF;

  0033f	8b 84 24 c0 00
	00 00		 mov	 eax, DWORD PTR lasttrk$[rsp]
  00346	c1 f8 08	 sar	 eax, 8
  00349	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  0034e	b9 01 00 00 00	 mov	 ecx, 1
  00353	48 6b c9 00	 imul	 rcx, rcx, 0
  00357	48 8b 54 24 30	 mov	 rdx, QWORD PTR f1dscb$[rsp]
  0035c	88 44 0a 62	 mov	 BYTE PTR [rdx+rcx+98], al

; 1019 :     f1dscb->ds1lstar[1] = lasttrk & 0xFF;

  00360	8b 84 24 c0 00
	00 00		 mov	 eax, DWORD PTR lasttrk$[rsp]
  00367	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  0036c	b9 01 00 00 00	 mov	 ecx, 1
  00371	48 6b c9 01	 imul	 rcx, rcx, 1
  00375	48 8b 54 24 30	 mov	 rdx, QWORD PTR f1dscb$[rsp]
  0037a	88 44 0a 62	 mov	 BYTE PTR [rdx+rcx+98], al

; 1020 :     f1dscb->ds1lstar[2] = (BYTE) lastrec;

  0037e	b8 01 00 00 00	 mov	 eax, 1
  00383	48 6b c0 02	 imul	 rax, rax, 2
  00387	48 8b 4c 24 30	 mov	 rcx, QWORD PTR f1dscb$[rsp]
  0038c	0f b6 94 24 c8
	00 00 00	 movzx	 edx, BYTE PTR lastrec$[rsp]
  00394	88 54 01 62	 mov	 BYTE PTR [rcx+rax+98], dl

; 1021 :     store_hw( f1dscb->ds1trbal, trkbal );

  00398	0f b7 8c 24 d0
	00 00 00	 movzx	 ecx, WORD PTR trkbal$[rsp]
  003a0	e8 00 00 00 00	 call	 _byteswap_ushort
  003a5	48 8b 4c 24 30	 mov	 rcx, QWORD PTR f1dscb$[rsp]
  003aa	48 83 c1 65	 add	 rcx, 101		; 00000065H
  003ae	0f b7 d0	 movzx	 edx, ax
  003b1	e8 00 00 00 00	 call	 store_hw_noswap

; 1022 :     f1dscb->ds1ext1.xttype =

  003b6	0f b6 84 24 d8
	00 00 00	 movzx	 eax, BYTE PTR units$[rsp]
  003be	83 f8 43	 cmp	 eax, 67			; 00000043H
  003c1	75 0a		 jne	 SHORT $LN8@build_form
  003c3	c7 44 24 28 81
	00 00 00	 mov	 DWORD PTR tv238[rsp], 129 ; 00000081H
  003cb	eb 08		 jmp	 SHORT $LN9@build_form
$LN8@build_form:
  003cd	c7 44 24 28 01
	00 00 00	 mov	 DWORD PTR tv238[rsp], 1
$LN9@build_form:
  003d5	48 8b 44 24 30	 mov	 rax, QWORD PTR f1dscb$[rsp]
  003da	0f b6 4c 24 28	 movzx	 ecx, BYTE PTR tv238[rsp]
  003df	88 48 69	 mov	 BYTE PTR [rax+105], cl

; 1023 :         (units == 'C' ? XTTYPE_CYLBOUND : XTTYPE_DATA);
; 1024 :     f1dscb->ds1ext1.xtseqn = 0;

  003e2	48 8b 44 24 30	 mov	 rax, QWORD PTR f1dscb$[rsp]
  003e7	c6 40 6a 00	 mov	 BYTE PTR [rax+106], 0

; 1025 :     store_hw( f1dscb->ds1ext1.xtbcyl, bcyl );

  003eb	0f b7 8c 24 e8
	00 00 00	 movzx	 ecx, WORD PTR bcyl$[rsp]
  003f3	e8 00 00 00 00	 call	 _byteswap_ushort
  003f8	48 8b 4c 24 30	 mov	 rcx, QWORD PTR f1dscb$[rsp]
  003fd	48 83 c1 6b	 add	 rcx, 107		; 0000006bH
  00401	0f b7 d0	 movzx	 edx, ax
  00404	e8 00 00 00 00	 call	 store_hw_noswap

; 1026 :     store_hw( f1dscb->ds1ext1.xtbtrk, bhead );

  00409	0f b7 8c 24 f0
	00 00 00	 movzx	 ecx, WORD PTR bhead$[rsp]
  00411	e8 00 00 00 00	 call	 _byteswap_ushort
  00416	48 8b 4c 24 30	 mov	 rcx, QWORD PTR f1dscb$[rsp]
  0041b	48 83 c1 6d	 add	 rcx, 109		; 0000006dH
  0041f	0f b7 d0	 movzx	 edx, ax
  00422	e8 00 00 00 00	 call	 store_hw_noswap

; 1027 :     store_hw( f1dscb->ds1ext1.xtecyl, ecyl );

  00427	0f b7 8c 24 f8
	00 00 00	 movzx	 ecx, WORD PTR ecyl$[rsp]
  0042f	e8 00 00 00 00	 call	 _byteswap_ushort
  00434	48 8b 4c 24 30	 mov	 rcx, QWORD PTR f1dscb$[rsp]
  00439	48 83 c1 6f	 add	 rcx, 111		; 0000006fH
  0043d	0f b7 d0	 movzx	 edx, ax
  00440	e8 00 00 00 00	 call	 store_hw_noswap

; 1028 :     store_hw( f1dscb->ds1ext1.xtetrk, ehead );

  00445	0f b7 8c 24 00
	01 00 00	 movzx	 ecx, WORD PTR ehead$[rsp]
  0044d	e8 00 00 00 00	 call	 _byteswap_ushort
  00452	48 8b 4c 24 30	 mov	 rcx, QWORD PTR f1dscb$[rsp]
  00457	48 83 c1 71	 add	 rcx, 113		; 00000071H
  0045b	0f b7 d0	 movzx	 edx, ax
  0045e	e8 00 00 00 00	 call	 store_hw_noswap

; 1029 :     return 0;

  00463	33 c0		 xor	 eax, eax
$LN1@build_form:

; 1030 : } /* end function build_format1_dscb */

  00465	48 83 c4 60	 add	 rsp, 96			; 00000060H
  00469	5f		 pop	 rdi
  0046a	c3		 ret	 0
build_format1_dscb ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\dasdload64.c
_TEXT	SEGMENT
offset$ = 96
rc$ = 100
curhead$ = 104
curcyl$ = 108
klen$ = 112
dlen$ = 116
skiplen$ = 120
trkhdr$ = 124
rechdr$ = 136
__$ArrayPad$ = 144
cif$ = 192
ofname$ = 200
blk$ = 208
cyl$ = 216
head$ = 224
rec$ = 232
keylen$ = 240
datalen$ = 248
heads$ = 256
trklen$ = 264
update_block PROC

; 827  : {

  00000	44 89 4c 24 20	 mov	 DWORD PTR [rsp+32], r9d
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	56		 push	 rsi
  00015	57		 push	 rdi
  00016	48 81 ec a8 00
	00 00		 sub	 rsp, 168		; 000000a8H
  0001d	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00024	48 33 c4	 xor	 rax, rsp
  00027	48 89 84 24 90
	00 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax
$LN4@update_blo:

; 828  : int             rc;                     /* Return code               */
; 829  : int             curcyl;                 /* Original cylinder         */
; 830  : int             curhead;                /* Original head             */
; 831  : int             klen;                   /* Record key length         */
; 832  : int             dlen;                   /* Record data length        */
; 833  : int             skiplen;                /* Number of bytes to skip   */
; 834  : int             offset;                 /* Offset into trkbuf        */
; 835  : CKD_TRKHDR      trkhdr;                 /* Track header              */
; 836  : CKD_RECHDR      rechdr;                 /* Record header             */
; 837  : 
; 838  :     UNREFERENCED(heads);

  0002f	33 c0		 xor	 eax, eax
  00031	85 c0		 test	 eax, eax
  00033	75 fa		 jne	 SHORT $LN4@update_blo
$LN7@update_blo:

; 839  :     UNREFERENCED(trklen);

  00035	33 c0		 xor	 eax, eax
  00037	85 c0		 test	 eax, eax
  00039	75 fa		 jne	 SHORT $LN7@update_blo

; 840  : 
; 841  :     /* Save the current position in the output file */
; 842  :     curcyl = cif->curcyl;

  0003b	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR cif$[rsp]
  00043	8b 40 18	 mov	 eax, DWORD PTR [rax+24]
  00046	89 44 24 6c	 mov	 DWORD PTR curcyl$[rsp], eax

; 843  :     curhead = cif->curhead;

  0004a	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR cif$[rsp]
  00052	8b 40 1c	 mov	 eax, DWORD PTR [rax+28]
  00055	89 44 24 68	 mov	 DWORD PTR curhead$[rsp], eax

; 844  : 
; 845  :     /* Read the requested track */
; 846  :     rc = read_track( cif, cyl, (U8) head );

  00059	44 0f b6 84 24
	e0 00 00 00	 movzx	 r8d, BYTE PTR head$[rsp]
  00062	8b 94 24 d8 00
	00 00		 mov	 edx, DWORD PTR cyl$[rsp]
  00069	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR cif$[rsp]
  00071	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_read_track
  00077	89 44 24 64	 mov	 DWORD PTR rc$[rsp], eax

; 847  :     if (rc < 0)

  0007b	83 7c 24 64 00	 cmp	 DWORD PTR rc$[rsp], 0
  00080	7d 4e		 jge	 SHORT $LN10@update_blo

; 848  :     {
; 849  :         XMERRF ( MSG( HHC02513, "E", ofname, cyl, cyl, head, head ) );

  00082	8b 84 24 e0 00
	00 00		 mov	 eax, DWORD PTR head$[rsp]
  00089	89 44 24 30	 mov	 DWORD PTR [rsp+48], eax
  0008d	8b 84 24 e0 00
	00 00		 mov	 eax, DWORD PTR head$[rsp]
  00094	89 44 24 28	 mov	 DWORD PTR [rsp+40], eax
  00098	8b 84 24 d8 00
	00 00		 mov	 eax, DWORD PTR cyl$[rsp]
  0009f	89 44 24 20	 mov	 DWORD PTR [rsp+32], eax
  000a3	44 8b 8c 24 d8
	00 00 00	 mov	 r9d, DWORD PTR cyl$[rsp]
  000ab	4c 8b 84 24 c8
	00 00 00	 mov	 r8, QWORD PTR ofname$[rsp]
  000b3	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG160932
  000ba	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG160933
  000c1	e8 00 00 00 00	 call	 printf

; 850  :         return -1;

  000c6	b8 ff ff ff ff	 mov	 eax, -1
  000cb	e9 d4 03 00 00	 jmp	 $LN1@update_blo
$LN10@update_blo:

; 851  :     }
; 852  : 
; 853  :     /* Copy the track header */
; 854  :     memcpy (&trkhdr, cif->trkbuf, CKD_TRKHDR_SIZE);

  000d0	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR cif$[rsp]
  000d8	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  000dc	48 8d 4c 24 7c	 lea	 rcx, QWORD PTR trkhdr$[rsp]
  000e1	48 8b f9	 mov	 rdi, rcx
  000e4	48 8b f0	 mov	 rsi, rax
  000e7	b9 05 00 00 00	 mov	 ecx, 5
  000ec	f3 a4		 rep movsb

; 855  :     offset = CKD_TRKHDR_SIZE;

  000ee	c7 44 24 60 05
	00 00 00	 mov	 DWORD PTR offset$[rsp], 5

; 856  : 
; 857  :     /* Validate the track header */
; 858  :     if (0
; 859  :         ||           trkhdr.bin    != 0
; 860  :         || fetch_hw( trkhdr.cyl  ) != cyl
; 861  :         || fetch_hw( trkhdr.head ) != head

  000f6	33 c0		 xor	 eax, eax
  000f8	85 c0		 test	 eax, eax
  000fa	75 49		 jne	 SHORT $LN12@update_blo
  000fc	0f b6 44 24 7c	 movzx	 eax, BYTE PTR trkhdr$[rsp]
  00101	85 c0		 test	 eax, eax
  00103	75 40		 jne	 SHORT $LN12@update_blo
  00105	48 8d 4c 24 7d	 lea	 rcx, QWORD PTR trkhdr$[rsp+1]
  0010a	e8 00 00 00 00	 call	 fetch_hw_noswap
  0010f	0f b7 c8	 movzx	 ecx, ax
  00112	e8 00 00 00 00	 call	 _byteswap_ushort
  00117	0f b7 c0	 movzx	 eax, ax
  0011a	3b 84 24 d8 00
	00 00		 cmp	 eax, DWORD PTR cyl$[rsp]
  00121	75 22		 jne	 SHORT $LN12@update_blo
  00123	48 8d 4c 24 7f	 lea	 rcx, QWORD PTR trkhdr$[rsp+3]
  00128	e8 00 00 00 00	 call	 fetch_hw_noswap
  0012d	0f b7 c8	 movzx	 ecx, ax
  00130	e8 00 00 00 00	 call	 _byteswap_ushort
  00135	0f b7 c0	 movzx	 eax, ax
  00138	3b 84 24 e0 00
	00 00		 cmp	 eax, DWORD PTR head$[rsp]
  0013f	0f 84 9f 00 00
	00		 je	 $LN11@update_blo
$LN12@update_blo:

; 862  :     )
; 863  :     {
; 864  :         XMERRF ( MSG( HHC02514, "E", ofname, cyl, cyl, head, head,

  00145	b8 01 00 00 00	 mov	 eax, 1
  0014a	48 6b c0 01	 imul	 rax, rax, 1
  0014e	0f b6 44 04 7f	 movzx	 eax, BYTE PTR trkhdr$[rsp+rax+3]
  00153	b9 01 00 00 00	 mov	 ecx, 1
  00158	48 6b c9 00	 imul	 rcx, rcx, 0
  0015c	0f b6 4c 0c 7f	 movzx	 ecx, BYTE PTR trkhdr$[rsp+rcx+3]
  00161	ba 01 00 00 00	 mov	 edx, 1
  00166	48 6b d2 01	 imul	 rdx, rdx, 1
  0016a	0f b6 54 14 7d	 movzx	 edx, BYTE PTR trkhdr$[rsp+rdx+1]
  0016f	bf 01 00 00 00	 mov	 edi, 1
  00174	48 6b ff 00	 imul	 rdi, rdi, 0
  00178	0f b6 7c 3c 7d	 movzx	 edi, BYTE PTR trkhdr$[rsp+rdi+1]
  0017d	0f b6 74 24 7c	 movzx	 esi, BYTE PTR trkhdr$[rsp]
  00182	89 44 24 58	 mov	 DWORD PTR [rsp+88], eax
  00186	89 4c 24 50	 mov	 DWORD PTR [rsp+80], ecx
  0018a	89 54 24 48	 mov	 DWORD PTR [rsp+72], edx
  0018e	89 7c 24 40	 mov	 DWORD PTR [rsp+64], edi
  00192	89 74 24 38	 mov	 DWORD PTR [rsp+56], esi
  00196	8b 84 24 e0 00
	00 00		 mov	 eax, DWORD PTR head$[rsp]
  0019d	89 44 24 30	 mov	 DWORD PTR [rsp+48], eax
  001a1	8b 84 24 e0 00
	00 00		 mov	 eax, DWORD PTR head$[rsp]
  001a8	89 44 24 28	 mov	 DWORD PTR [rsp+40], eax
  001ac	8b 84 24 d8 00
	00 00		 mov	 eax, DWORD PTR cyl$[rsp]
  001b3	89 44 24 20	 mov	 DWORD PTR [rsp+32], eax
  001b7	44 8b 8c 24 d8
	00 00 00	 mov	 r9d, DWORD PTR cyl$[rsp]
  001bf	4c 8b 84 24 c8
	00 00 00	 mov	 r8, QWORD PTR ofname$[rsp]
  001c7	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG160936
  001ce	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG160937
  001d5	e8 00 00 00 00	 call	 printf

; 865  :                                      trkhdr.bin, trkhdr.cyl[0], trkhdr.cyl[1],
; 866  :                                      trkhdr.head[0], trkhdr.head[1] ) );
; 867  :         return -1;

  001da	b8 ff ff ff ff	 mov	 eax, -1
  001df	e9 c0 02 00 00	 jmp	 $LN1@update_blo
$LN11@update_blo:
$LN8@update_blo:

; 868  :     }
; 869  : 
; 870  :     /* Search for the record to be updated */
; 871  :     while (1)

  001e4	33 c0		 xor	 eax, eax
  001e6	83 f8 01	 cmp	 eax, 1
  001e9	0f 84 1b 01 00
	00		 je	 $LN9@update_blo

; 872  :     {
; 873  :         /* Copy the next record header */
; 874  :         memcpy (&rechdr, cif->trkbuf + offset, CKD_RECHDR_SIZE);

  001ef	48 63 44 24 60	 movsxd	 rax, DWORD PTR offset$[rsp]
  001f4	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR cif$[rsp]
  001fc	48 8b 49 10	 mov	 rcx, QWORD PTR [rcx+16]
  00200	48 8b 04 01	 mov	 rax, QWORD PTR [rcx+rax]
  00204	48 89 84 24 88
	00 00 00	 mov	 QWORD PTR rechdr$[rsp], rax

; 875  :         offset += CKD_RECHDR_SIZE;

  0020c	48 63 44 24 60	 movsxd	 rax, DWORD PTR offset$[rsp]
  00211	48 83 c0 08	 add	 rax, 8
  00215	89 44 24 60	 mov	 DWORD PTR offset$[rsp], eax

; 876  : 
; 877  :         /* Check for end of track */
; 878  :         if (memcmp( &rechdr, &CKD_ENDTRK, CKD_ENDTRK_SIZE ) == 0)

  00219	41 b8 08 00 00
	00		 mov	 r8d, 8
  0021f	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:CKD_ENDTRK
  00226	48 8d 8c 24 88
	00 00 00	 lea	 rcx, QWORD PTR rechdr$[rsp]
  0022e	e8 00 00 00 00	 call	 memcmp
  00233	85 c0		 test	 eax, eax
  00235	75 64		 jne	 SHORT $LN13@update_blo

; 879  :         {
; 880  :             XMERRF ( MSG( HHC02515, "E", ofname, cyl, cyl, head, head, rec, rec ) );

  00237	8b 84 24 e8 00
	00 00		 mov	 eax, DWORD PTR rec$[rsp]
  0023e	89 44 24 40	 mov	 DWORD PTR [rsp+64], eax
  00242	8b 84 24 e8 00
	00 00		 mov	 eax, DWORD PTR rec$[rsp]
  00249	89 44 24 38	 mov	 DWORD PTR [rsp+56], eax
  0024d	8b 84 24 e0 00
	00 00		 mov	 eax, DWORD PTR head$[rsp]
  00254	89 44 24 30	 mov	 DWORD PTR [rsp+48], eax
  00258	8b 84 24 e0 00
	00 00		 mov	 eax, DWORD PTR head$[rsp]
  0025f	89 44 24 28	 mov	 DWORD PTR [rsp+40], eax
  00263	8b 84 24 d8 00
	00 00		 mov	 eax, DWORD PTR cyl$[rsp]
  0026a	89 44 24 20	 mov	 DWORD PTR [rsp+32], eax
  0026e	44 8b 8c 24 d8
	00 00 00	 mov	 r9d, DWORD PTR cyl$[rsp]
  00276	4c 8b 84 24 c8
	00 00 00	 mov	 r8, QWORD PTR ofname$[rsp]
  0027e	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG160939
  00285	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG160940
  0028c	e8 00 00 00 00	 call	 printf

; 881  :             return -1;

  00291	b8 ff ff ff ff	 mov	 eax, -1
  00296	e9 09 02 00 00	 jmp	 $LN1@update_blo
$LN13@update_blo:

; 882  :         }
; 883  : 
; 884  :         /* Extract record key length and data length */
; 885  :         klen = rechdr.klen;

  0029b	0f b6 84 24 8d
	00 00 00	 movzx	 eax, BYTE PTR rechdr$[rsp+5]
  002a3	89 44 24 70	 mov	 DWORD PTR klen$[rsp], eax

; 886  :         dlen = (rechdr.dlen[0] << 8) | rechdr.dlen[1];

  002a7	b8 01 00 00 00	 mov	 eax, 1
  002ac	48 6b c0 00	 imul	 rax, rax, 0
  002b0	0f b6 84 04 8e
	00 00 00	 movzx	 eax, BYTE PTR rechdr$[rsp+rax+6]
  002b8	c1 e0 08	 shl	 eax, 8
  002bb	b9 01 00 00 00	 mov	 ecx, 1
  002c0	48 6b c9 01	 imul	 rcx, rcx, 1
  002c4	0f b6 8c 0c 8e
	00 00 00	 movzx	 ecx, BYTE PTR rechdr$[rsp+rcx+6]
  002cc	0b c1		 or	 eax, ecx
  002ce	89 44 24 74	 mov	 DWORD PTR dlen$[rsp], eax

; 887  : 
; 888  :         /* Exit loop if matching record number */
; 889  :         if (rechdr.rec == rec)

  002d2	0f b6 84 24 8c
	00 00 00	 movzx	 eax, BYTE PTR rechdr$[rsp+4]
  002da	3b 84 24 e8 00
	00 00		 cmp	 eax, DWORD PTR rec$[rsp]
  002e1	75 02		 jne	 SHORT $LN14@update_blo

; 890  :             break;

  002e3	eb 25		 jmp	 SHORT $LN9@update_blo
$LN14@update_blo:

; 891  : 
; 892  :         /* Skip the key and data areas */
; 893  :         skiplen = klen + dlen;

  002e5	8b 44 24 74	 mov	 eax, DWORD PTR dlen$[rsp]
  002e9	8b 4c 24 70	 mov	 ecx, DWORD PTR klen$[rsp]
  002ed	03 c8		 add	 ecx, eax
  002ef	8b c1		 mov	 eax, ecx
  002f1	89 44 24 78	 mov	 DWORD PTR skiplen$[rsp], eax

; 894  :         offset += skiplen;

  002f5	8b 44 24 78	 mov	 eax, DWORD PTR skiplen$[rsp]
  002f9	8b 4c 24 60	 mov	 ecx, DWORD PTR offset$[rsp]
  002fd	03 c8		 add	 ecx, eax
  002ff	8b c1		 mov	 eax, ecx
  00301	89 44 24 60	 mov	 DWORD PTR offset$[rsp], eax

; 895  :     } /* end while */

  00305	e9 da fe ff ff	 jmp	 $LN8@update_blo
$LN9@update_blo:

; 896  : 
; 897  :     /* Check for attempt to change key length or data length */
; 898  :     if (keylen != klen || datalen != dlen)

  0030a	8b 44 24 70	 mov	 eax, DWORD PTR klen$[rsp]
  0030e	39 84 24 f0 00
	00 00		 cmp	 DWORD PTR keylen$[rsp], eax
  00315	75 0d		 jne	 SHORT $LN16@update_blo
  00317	8b 44 24 74	 mov	 eax, DWORD PTR dlen$[rsp]
  0031b	39 84 24 f8 00
	00 00		 cmp	 DWORD PTR datalen$[rsp], eax
  00322	74 64		 je	 SHORT $LN15@update_blo
$LN16@update_blo:

; 899  :     {
; 900  :         XMERRF ( MSG( HHC02516, "E", ofname, cyl, cyl, head, head, rec, rec ) );

  00324	8b 84 24 e8 00
	00 00		 mov	 eax, DWORD PTR rec$[rsp]
  0032b	89 44 24 40	 mov	 DWORD PTR [rsp+64], eax
  0032f	8b 84 24 e8 00
	00 00		 mov	 eax, DWORD PTR rec$[rsp]
  00336	89 44 24 38	 mov	 DWORD PTR [rsp+56], eax
  0033a	8b 84 24 e0 00
	00 00		 mov	 eax, DWORD PTR head$[rsp]
  00341	89 44 24 30	 mov	 DWORD PTR [rsp+48], eax
  00345	8b 84 24 e0 00
	00 00		 mov	 eax, DWORD PTR head$[rsp]
  0034c	89 44 24 28	 mov	 DWORD PTR [rsp+40], eax
  00350	8b 84 24 d8 00
	00 00		 mov	 eax, DWORD PTR cyl$[rsp]
  00357	89 44 24 20	 mov	 DWORD PTR [rsp+32], eax
  0035b	44 8b 8c 24 d8
	00 00 00	 mov	 r9d, DWORD PTR cyl$[rsp]
  00363	4c 8b 84 24 c8
	00 00 00	 mov	 r8, QWORD PTR ofname$[rsp]
  0036b	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG160944
  00372	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG160945
  00379	e8 00 00 00 00	 call	 printf

; 901  :         return -1;

  0037e	b8 ff ff ff ff	 mov	 eax, -1
  00383	e9 1c 01 00 00	 jmp	 $LN1@update_blo
$LN15@update_blo:

; 902  :     }
; 903  : 
; 904  :     /* Copy the updated block to the trkbuf */
; 905  :     memcpy (cif->trkbuf + offset, blk->kdarea, keylen + datalen);

  00388	8b 84 24 f8 00
	00 00		 mov	 eax, DWORD PTR datalen$[rsp]
  0038f	8b 8c 24 f0 00
	00 00		 mov	 ecx, DWORD PTR keylen$[rsp]
  00396	03 c8		 add	 ecx, eax
  00398	8b c1		 mov	 eax, ecx
  0039a	48 98		 cdqe
  0039c	48 8b 8c 24 d0
	00 00 00	 mov	 rcx, QWORD PTR blk$[rsp]
  003a4	48 83 c1 0c	 add	 rcx, 12
  003a8	48 63 54 24 60	 movsxd	 rdx, DWORD PTR offset$[rsp]
  003ad	48 8b bc 24 c0
	00 00 00	 mov	 rdi, QWORD PTR cif$[rsp]
  003b5	48 03 57 10	 add	 rdx, QWORD PTR [rdi+16]
  003b9	48 8b fa	 mov	 rdi, rdx
  003bc	48 8b f1	 mov	 rsi, rcx
  003bf	48 8b c8	 mov	 rcx, rax
  003c2	f3 a4		 rep movsb

; 906  :     cif->trkmodif = 1;

  003c4	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR cif$[rsp]
  003cc	c7 40 20 01 00
	00 00		 mov	 DWORD PTR [rax+32], 1

; 907  : 
; 908  :     /* Restore original track */
; 909  :     rc = read_track( cif, curcyl, (U8) curhead );

  003d3	44 0f b6 44 24
	68		 movzx	 r8d, BYTE PTR curhead$[rsp]
  003d9	8b 54 24 6c	 mov	 edx, DWORD PTR curcyl$[rsp]
  003dd	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR cif$[rsp]
  003e5	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_read_track
  003eb	89 44 24 64	 mov	 DWORD PTR rc$[rsp], eax

; 910  :     if (rc < 0)

  003ef	83 7c 24 64 00	 cmp	 DWORD PTR rc$[rsp], 0
  003f4	7d 3f		 jge	 SHORT $LN17@update_blo

; 911  :     {
; 912  :         XMERRF ( MSG( HHC02513, "E", ofname, curcyl, curcyl, curhead, curhead ) );

  003f6	8b 44 24 68	 mov	 eax, DWORD PTR curhead$[rsp]
  003fa	89 44 24 30	 mov	 DWORD PTR [rsp+48], eax
  003fe	8b 44 24 68	 mov	 eax, DWORD PTR curhead$[rsp]
  00402	89 44 24 28	 mov	 DWORD PTR [rsp+40], eax
  00406	8b 44 24 6c	 mov	 eax, DWORD PTR curcyl$[rsp]
  0040a	89 44 24 20	 mov	 DWORD PTR [rsp+32], eax
  0040e	44 8b 4c 24 6c	 mov	 r9d, DWORD PTR curcyl$[rsp]
  00413	4c 8b 84 24 c8
	00 00 00	 mov	 r8, QWORD PTR ofname$[rsp]
  0041b	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG160947
  00422	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG160948
  00429	e8 00 00 00 00	 call	 printf

; 913  :         return -1;

  0042e	b8 ff ff ff ff	 mov	 eax, -1
  00433	eb 6f		 jmp	 SHORT $LN1@update_blo
$LN17@update_blo:

; 914  :     }
; 915  : 
; 916  :     XMINFF (4, MSG( HHC02523, "I", cyl, cyl, head, head, rec, rec, keylen, datalen ) );

  00435	8b 84 24 f8 00
	00 00		 mov	 eax, DWORD PTR datalen$[rsp]
  0043c	89 44 24 50	 mov	 DWORD PTR [rsp+80], eax
  00440	8b 84 24 f0 00
	00 00		 mov	 eax, DWORD PTR keylen$[rsp]
  00447	89 44 24 48	 mov	 DWORD PTR [rsp+72], eax
  0044b	8b 84 24 e8 00
	00 00		 mov	 eax, DWORD PTR rec$[rsp]
  00452	89 44 24 40	 mov	 DWORD PTR [rsp+64], eax
  00456	8b 84 24 e8 00
	00 00		 mov	 eax, DWORD PTR rec$[rsp]
  0045d	89 44 24 38	 mov	 DWORD PTR [rsp+56], eax
  00461	8b 84 24 e0 00
	00 00		 mov	 eax, DWORD PTR head$[rsp]
  00468	89 44 24 30	 mov	 DWORD PTR [rsp+48], eax
  0046c	8b 84 24 e0 00
	00 00		 mov	 eax, DWORD PTR head$[rsp]
  00473	89 44 24 28	 mov	 DWORD PTR [rsp+40], eax
  00477	8b 84 24 d8 00
	00 00		 mov	 eax, DWORD PTR cyl$[rsp]
  0047e	89 44 24 20	 mov	 DWORD PTR [rsp+32], eax
  00482	44 8b 8c 24 d8
	00 00 00	 mov	 r9d, DWORD PTR cyl$[rsp]
  0048a	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG160949
  00491	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG160950
  00498	b9 04 00 00 00	 mov	 ecx, 4
  0049d	e8 00 00 00 00	 call	 info_msg

; 917  : 
; 918  :     return 0;

  004a2	33 c0		 xor	 eax, eax
$LN1@update_blo:

; 919  : } /* end function update_block */

  004a4	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  004ac	48 33 cc	 xor	 rcx, rsp
  004af	e8 00 00 00 00	 call	 __security_check_cookie
  004b4	48 81 c4 a8 00
	00 00		 add	 rsp, 168		; 000000a8H
  004bb	5f		 pop	 rdi
  004bc	5e		 pop	 rsi
  004bd	c3		 ret	 0
update_block ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\dasdload64.c
_TEXT	SEGMENT
datablk$ = 128
rc$ = 136
datalen$ = 140
keylen$ = 144
outusedv$ = 148
maxtrks$ = 152
outrec$ = 156
outtrk$ = 160
outtrkbr$ = 164
outusedr$ = 168
buf$ = 176
__$ArrayPad$ = 32960
cif$ = 33008
ofname$ = 33016
volser$ = 33024
devtype$ = 33032
heads$ = 33040
trklen$ = 33048
iplfnm$ = 33056
reltrk$ = 33064
outcyl$ = 33072
outhead$ = 33080
flagECmode$ = 33088
flagMachinecheck$ = 33096
write_track_zero PROC

; 671  : {

  00000	66 44 89 4c 24
	20		 mov	 WORD PTR [rsp+32], r9w
  00006	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000b	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00010	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00015	56		 push	 rsi
  00016	57		 push	 rdi
  00017	b8 d8 80 00 00	 mov	 eax, 32984		; 000080d8H
  0001c	e8 00 00 00 00	 call	 __chkstk
  00021	48 2b e0	 sub	 rsp, rax
  00024	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  0002b	48 33 c4	 xor	 rax, rsp
  0002e	48 89 84 24 c0
	80 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 672  : int             rc;                     /* Return code               */
; 673  : int             outusedv = 0;           /* Output bytes used on track

  00036	c7 84 24 94 00
	00 00 00 00 00
	00		 mov	 DWORD PTR outusedv$[rsp], 0

; 674  :                                            of virtual device         */
; 675  : int             outusedr = 0;           /* Output bytes used on track

  00041	c7 84 24 a8 00
	00 00 00 00 00
	00		 mov	 DWORD PTR outusedr$[rsp], 0

; 676  :                                            of real device            */
; 677  : int             outtrkbr = 0;           /* Output bytes remaining on

  0004c	c7 84 24 a4 00
	00 00 00 00 00
	00		 mov	 DWORD PTR outtrkbr$[rsp], 0

; 678  :                                            track of real device      */
; 679  : int             outtrk = 0;             /* Output relative track     */

  00057	c7 84 24 a0 00
	00 00 00 00 00
	00		 mov	 DWORD PTR outtrk$[rsp], 0

; 680  : int             outrec = 0;             /* Output record number      */

  00062	c7 84 24 9c 00
	00 00 00 00 00
	00		 mov	 DWORD PTR outrec$[rsp], 0

; 681  : int             keylen;                 /* Key length                */
; 682  : int             datalen;                /* Data length               */
; 683  : int             maxtrks = 1;            /* Maximum track count       */

  0006d	c7 84 24 98 00
	00 00 01 00 00
	00		 mov	 DWORD PTR maxtrks$[rsp], 1

; 684  : DATABLK        *datablk;                /* -> data block             */
; 685  : BYTE            buf[sizeof(DATABLK)];   /* Buffer for data block     */
; 686  : 
; 687  :     /* For 2311, the complete IPL text doesn't fit on track 0 record 4
; 688  :        so the IPL2 text is adjusted further below to load from track 1
; 689  :        record 1 thus requiring us to use 2 tracks instead of just 1. */
; 690  :     if (devtype == 0x2311)

  00078	0f b7 84 24 08
	81 00 00	 movzx	 eax, WORD PTR devtype$[rsp]
  00080	3d 11 23 00 00	 cmp	 eax, 8977		; 00002311H
  00085	75 0b		 jne	 SHORT $LN2@write_trac

; 691  :         maxtrks = 2;

  00087	c7 84 24 98 00
	00 00 02 00 00
	00		 mov	 DWORD PTR maxtrks$[rsp], 2
$LN2@write_trac:

; 692  : 
; 693  :     /* Read track 0 */
; 694  :     rc = read_track( cif, 0, 0 );

  00092	45 33 c0	 xor	 r8d, r8d
  00095	33 d2		 xor	 edx, edx
  00097	48 8b 8c 24 f0
	80 00 00	 mov	 rcx, QWORD PTR cif$[rsp]
  0009f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_read_track
  000a5	89 84 24 88 00
	00 00		 mov	 DWORD PTR rc$[rsp], eax

; 695  :     if (rc < 0) return -1;

  000ac	83 bc 24 88 00
	00 00 00	 cmp	 DWORD PTR rc$[rsp], 0
  000b4	7d 0a		 jge	 SHORT $LN3@write_trac
  000b6	b8 ff ff ff ff	 mov	 eax, -1
  000bb	e9 06 07 00 00	 jmp	 $LN1@write_trac
$LN3@write_trac:

; 696  : 
; 697  :     /* Initialize the track buffer */
; 698  :     *outcyl = 0; *outhead = 0;

  000c0	48 8b 84 24 30
	81 00 00	 mov	 rax, QWORD PTR outcyl$[rsp]
  000c8	c7 00 00 00 00
	00		 mov	 DWORD PTR [rax], 0
  000ce	48 8b 84 24 38
	81 00 00	 mov	 rax, QWORD PTR outhead$[rsp]
  000d6	c7 00 00 00 00
	00		 mov	 DWORD PTR [rax], 0

; 699  :     init_track( trklen, cif->trkbuf, *outcyl, *outhead, &outusedv );

  000dc	48 8d 84 24 94
	00 00 00	 lea	 rax, QWORD PTR outusedv$[rsp]
  000e4	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  000e9	48 8b 84 24 38
	81 00 00	 mov	 rax, QWORD PTR outhead$[rsp]
  000f1	44 8b 08	 mov	 r9d, DWORD PTR [rax]
  000f4	48 8b 84 24 30
	81 00 00	 mov	 rax, QWORD PTR outcyl$[rsp]
  000fc	44 8b 00	 mov	 r8d, DWORD PTR [rax]
  000ff	48 8b 84 24 f0
	80 00 00	 mov	 rax, QWORD PTR cif$[rsp]
  00107	48 8b 50 10	 mov	 rdx, QWORD PTR [rax+16]
  0010b	8b 8c 24 18 81
	00 00		 mov	 ecx, DWORD PTR trklen$[rsp]
  00112	e8 00 00 00 00	 call	 init_track

; 700  :     cif->trkmodif = 1;

  00117	48 8b 84 24 f0
	80 00 00	 mov	 rax, QWORD PTR cif$[rsp]
  0011f	c7 40 20 01 00
	00 00		 mov	 DWORD PTR [rax+32], 1

; 701  : 
; 702  :     /* Build the IPL1 record */
; 703  :     memset( buf, 0, sizeof( buf ));

  00126	48 8d 84 24 b0
	00 00 00	 lea	 rax, QWORD PTR buf$[rsp]
  0012e	48 8b f8	 mov	 rdi, rax
  00131	33 c0		 xor	 eax, eax
  00133	b9 0b 80 00 00	 mov	 ecx, 32779		; 0000800bH
  00138	f3 aa		 rep stosb

; 704  :     datablk = (DATABLK*) buf;

  0013a	48 8d 84 24 b0
	00 00 00	 lea	 rax, QWORD PTR buf$[rsp]
  00142	48 89 84 24 80
	00 00 00	 mov	 QWORD PTR datablk$[rsp], rax

; 705  :     memcpy( datablk->kdarea, IPL1_KEY, IPL1_KEYLEN ); // "IPL1"

  0014a	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR datablk$[rsp]
  00152	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR IPL1_KEY
  00158	89 48 0c	 mov	 DWORD PTR [rax+12], ecx

; 706  : 
; 707  :     /* Build IPL PSW and CCWs in IPL1 record */
; 708  :     if (iplfnm != NULL)

  0015b	48 83 bc 24 20
	81 00 00 00	 cmp	 QWORD PTR iplfnm$[rsp], 0
  00164	74 3e		 je	 SHORT $LN4@write_trac

; 709  :     {
; 710  :         /* Copy model IPL PSW and CCWs for IPLable volume */
; 711  :         memcpy( datablk->kdarea +  4, iplpsw,  8 );

  00166	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR datablk$[rsp]
  0016e	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR iplpsw
  00175	48 89 48 10	 mov	 QWORD PTR [rax+16], rcx

; 712  :         memcpy( datablk->kdarea + 12, iplccw1, 8 );

  00179	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR datablk$[rsp]
  00181	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR iplccw1
  00188	48 89 48 18	 mov	 QWORD PTR [rax+24], rcx

; 713  :         memcpy( datablk->kdarea + 20, iplccw2, 8 );

  0018c	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR datablk$[rsp]
  00194	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR iplccw2
  0019b	48 89 48 20	 mov	 QWORD PTR [rax+32], rcx

; 714  :     }

  0019f	e9 81 00 00 00	 jmp	 $LN5@write_trac
$LN4@write_trac:

; 715  :     else
; 716  :     {
; 717  :         /* Copy model IPL PSW and CCWs for non-IPLable volume */
; 718  :         memcpy( datablk->kdarea +  4, noiplpsw,  8 );

  001a4	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR datablk$[rsp]
  001ac	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR noiplpsw
  001b3	48 89 48 10	 mov	 QWORD PTR [rax+16], rcx

; 719  :         memcpy( datablk->kdarea + 12, noiplccw1, 8 );

  001b7	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR datablk$[rsp]
  001bf	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR noiplccw1
  001c6	48 89 48 18	 mov	 QWORD PTR [rax+24], rcx

; 720  :         memcpy( datablk->kdarea + 20, noiplccw2, 8 );

  001ca	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR datablk$[rsp]
  001d2	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR noiplccw2
  001d9	48 89 48 20	 mov	 QWORD PTR [rax+32], rcx

; 721  : 
; 722  :         /* Set EC mode flag in wait PSW if requested */
; 723  :         if (flagECmode)

  001dd	83 bc 24 40 81
	00 00 00	 cmp	 DWORD PTR flagECmode$[rsp], 0
  001e5	74 1a		 je	 SHORT $LN6@write_trac

; 724  :             *(datablk->kdarea+5) = 0x08 | *(datablk->kdarea+5);

  001e7	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR datablk$[rsp]
  001ef	0f b6 40 11	 movzx	 eax, BYTE PTR [rax+17]
  001f3	83 c8 08	 or	 eax, 8
  001f6	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR datablk$[rsp]
  001fe	88 41 11	 mov	 BYTE PTR [rcx+17], al
$LN6@write_trac:

; 725  : 
; 726  :         /* Set machine-check-enabled mask in PSW if requested */
; 727  :         if (flagMachinecheck)

  00201	83 bc 24 48 81
	00 00 00	 cmp	 DWORD PTR flagMachinecheck$[rsp], 0
  00209	74 1a		 je	 SHORT $LN7@write_trac

; 728  :             *(datablk->kdarea+5) = 0x04 | *(datablk->kdarea+5);

  0020b	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR datablk$[rsp]
  00213	0f b6 40 11	 movzx	 eax, BYTE PTR [rax+17]
  00217	83 c8 04	 or	 eax, 4
  0021a	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR datablk$[rsp]
  00222	88 41 11	 mov	 BYTE PTR [rcx+17], al
$LN7@write_trac:
$LN5@write_trac:

; 729  :     }
; 730  : 
; 731  :     keylen  = IPL1_KEYLEN;

  00225	c7 84 24 90 00
	00 00 04 00 00
	00		 mov	 DWORD PTR keylen$[rsp], 4

; 732  :     datalen = IPL1_DATALEN;

  00230	c7 84 24 8c 00
	00 00 18 00 00
	00		 mov	 DWORD PTR datalen$[rsp], 24

; 733  : 
; 734  :     rc = write_block( cif, ofname, datablk, keylen, datalen,

  0023b	48 8d 84 24 9c
	00 00 00	 lea	 rax, QWORD PTR outrec$[rsp]
  00243	48 89 44 24 78	 mov	 QWORD PTR [rsp+120], rax
  00248	48 8b 84 24 38
	81 00 00	 mov	 rax, QWORD PTR outhead$[rsp]
  00250	48 89 44 24 70	 mov	 QWORD PTR [rsp+112], rax
  00255	48 8b 84 24 30
	81 00 00	 mov	 rax, QWORD PTR outcyl$[rsp]
  0025d	48 89 44 24 68	 mov	 QWORD PTR [rsp+104], rax
  00262	48 8d 84 24 a0
	00 00 00	 lea	 rax, QWORD PTR outtrk$[rsp]
  0026a	48 89 44 24 60	 mov	 QWORD PTR [rsp+96], rax
  0026f	48 8d 84 24 a4
	00 00 00	 lea	 rax, QWORD PTR outtrkbr$[rsp]
  00277	48 89 44 24 58	 mov	 QWORD PTR [rsp+88], rax
  0027c	48 8d 84 24 a8
	00 00 00	 lea	 rax, QWORD PTR outusedr$[rsp]
  00284	48 89 44 24 50	 mov	 QWORD PTR [rsp+80], rax
  00289	48 8d 84 24 94
	00 00 00	 lea	 rax, QWORD PTR outusedv$[rsp]
  00291	48 89 44 24 48	 mov	 QWORD PTR [rsp+72], rax
  00296	8b 84 24 98 00
	00 00		 mov	 eax, DWORD PTR maxtrks$[rsp]
  0029d	89 44 24 40	 mov	 DWORD PTR [rsp+64], eax
  002a1	8b 84 24 18 81
	00 00		 mov	 eax, DWORD PTR trklen$[rsp]
  002a8	89 44 24 38	 mov	 DWORD PTR [rsp+56], eax
  002ac	8b 84 24 10 81
	00 00		 mov	 eax, DWORD PTR heads$[rsp]
  002b3	89 44 24 30	 mov	 DWORD PTR [rsp+48], eax
  002b7	0f b7 84 24 08
	81 00 00	 movzx	 eax, WORD PTR devtype$[rsp]
  002bf	66 89 44 24 28	 mov	 WORD PTR [rsp+40], ax
  002c4	8b 84 24 8c 00
	00 00		 mov	 eax, DWORD PTR datalen$[rsp]
  002cb	89 44 24 20	 mov	 DWORD PTR [rsp+32], eax
  002cf	44 8b 8c 24 90
	00 00 00	 mov	 r9d, DWORD PTR keylen$[rsp]
  002d7	4c 8b 84 24 80
	00 00 00	 mov	 r8, QWORD PTR datablk$[rsp]
  002df	48 8b 94 24 f8
	80 00 00	 mov	 rdx, QWORD PTR ofname$[rsp]
  002e7	48 8b 8c 24 f0
	80 00 00	 mov	 rcx, QWORD PTR cif$[rsp]
  002ef	e8 00 00 00 00	 call	 write_block
  002f4	89 84 24 88 00
	00 00		 mov	 DWORD PTR rc$[rsp], eax

; 735  :                 devtype, heads, trklen, maxtrks,
; 736  :                 &outusedv, &outusedr, &outtrkbr,
; 737  :                 &outtrk, outcyl, outhead, &outrec );
; 738  :     if (rc < 0) return -1;

  002fb	83 bc 24 88 00
	00 00 00	 cmp	 DWORD PTR rc$[rsp], 0
  00303	7d 0a		 jge	 SHORT $LN8@write_trac
  00305	b8 ff ff ff ff	 mov	 eax, -1
  0030a	e9 b7 04 00 00	 jmp	 $LN1@write_trac
$LN8@write_trac:

; 739  : 
; 740  :     /* Build the IPL2 record */
; 741  :     memset (buf, 0, sizeof(buf));

  0030f	48 8d 84 24 b0
	00 00 00	 lea	 rax, QWORD PTR buf$[rsp]
  00317	48 8b f8	 mov	 rdi, rax
  0031a	33 c0		 xor	 eax, eax
  0031c	b9 0b 80 00 00	 mov	 ecx, 32779		; 0000800bH
  00321	f3 aa		 rep stosb

; 742  :     datablk = (DATABLK*)buf;

  00323	48 8d 84 24 b0
	00 00 00	 lea	 rax, QWORD PTR buf$[rsp]
  0032b	48 89 84 24 80
	00 00 00	 mov	 QWORD PTR datablk$[rsp], rax

; 743  :     memcpy( datablk->kdarea, IPL2_KEY, IPL2_KEYLEN ); // "IPL2"

  00333	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR datablk$[rsp]
  0033b	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR IPL2_KEY
  00341	89 48 0c	 mov	 DWORD PTR [rax+12], ecx

; 744  : 
; 745  :     if (iplfnm != NULL)

  00344	48 83 bc 24 20
	81 00 00 00	 cmp	 QWORD PTR iplfnm$[rsp], 0
  0034d	0f 84 85 00 00
	00		 je	 $LN9@write_trac

; 746  :     {
; 747  :         /* For 2311 the IPL text won't fit on only track 0 record 4,
; 748  :            so adjust the IPL2 so that it loads from track 1 record 1 */
; 749  :         if (devtype == 0x2311)

  00353	0f b7 84 24 08
	81 00 00	 movzx	 eax, WORD PTR devtype$[rsp]
  0035b	3d 11 23 00 00	 cmp	 eax, 8977		; 00002311H
  00360	75 59		 jne	 SHORT $LN10@write_trac

; 750  :         {
; 751  :             memcpy( datablk->kdarea + IPL2_KEYLEN, ipl2data, 32 );

  00362	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR datablk$[rsp]
  0036a	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:ipl2data
  00371	48 8d 78 10	 lea	 rdi, QWORD PTR [rax+16]
  00375	48 8b f1	 mov	 rsi, rcx
  00378	b9 20 00 00 00	 mov	 ecx, 32			; 00000020H
  0037d	f3 a4		 rep movsb

; 752  :             memcpy( datablk->kdarea + IPL2_KEYLEN + 32, "\x00\x00\x00\x00\x00\x01", 6 ); // BBCCHH

  0037f	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR datablk$[rsp]
  00387	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG160872
  0038e	48 8d 78 30	 lea	 rdi, QWORD PTR [rax+48]
  00392	48 8b f1	 mov	 rsi, rcx
  00395	b9 06 00 00 00	 mov	 ecx, 6
  0039a	f3 a4		 rep movsb

; 753  :             memcpy( datablk->kdarea + IPL2_KEYLEN + 38, "\x00\x00\x00\x01\x01",     5 ); // CCHHR

  0039c	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR datablk$[rsp]
  003a4	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG160873
  003ab	48 8d 78 36	 lea	 rdi, QWORD PTR [rax+54]
  003af	48 8b f1	 mov	 rsi, rcx
  003b2	b9 05 00 00 00	 mov	 ecx, 5
  003b7	f3 a4		 rep movsb

; 754  :         }

  003b9	eb 1d		 jmp	 SHORT $LN11@write_trac
$LN10@write_trac:

; 755  :         else
; 756  :             memcpy( datablk->kdarea + IPL2_KEYLEN, ipl2data, 43 );

  003bb	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR datablk$[rsp]
  003c3	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:ipl2data
  003ca	48 8d 78 10	 lea	 rdi, QWORD PTR [rax+16]
  003ce	48 8b f1	 mov	 rsi, rcx
  003d1	b9 2b 00 00 00	 mov	 ecx, 43			; 0000002bH
  003d6	f3 a4		 rep movsb
$LN11@write_trac:
$LN9@write_trac:

; 757  :     }
; 758  : 
; 759  :     keylen  = IPL2_KEYLEN;

  003d8	c7 84 24 90 00
	00 00 04 00 00
	00		 mov	 DWORD PTR keylen$[rsp], 4

; 760  :     datalen = IPL2_DATALEN;

  003e3	c7 84 24 8c 00
	00 00 90 00 00
	00		 mov	 DWORD PTR datalen$[rsp], 144 ; 00000090H

; 761  : 
; 762  :     rc = write_block (cif, ofname, datablk, keylen, datalen,

  003ee	48 8d 84 24 9c
	00 00 00	 lea	 rax, QWORD PTR outrec$[rsp]
  003f6	48 89 44 24 78	 mov	 QWORD PTR [rsp+120], rax
  003fb	48 8b 84 24 38
	81 00 00	 mov	 rax, QWORD PTR outhead$[rsp]
  00403	48 89 44 24 70	 mov	 QWORD PTR [rsp+112], rax
  00408	48 8b 84 24 30
	81 00 00	 mov	 rax, QWORD PTR outcyl$[rsp]
  00410	48 89 44 24 68	 mov	 QWORD PTR [rsp+104], rax
  00415	48 8d 84 24 a0
	00 00 00	 lea	 rax, QWORD PTR outtrk$[rsp]
  0041d	48 89 44 24 60	 mov	 QWORD PTR [rsp+96], rax
  00422	48 8d 84 24 a4
	00 00 00	 lea	 rax, QWORD PTR outtrkbr$[rsp]
  0042a	48 89 44 24 58	 mov	 QWORD PTR [rsp+88], rax
  0042f	48 8d 84 24 a8
	00 00 00	 lea	 rax, QWORD PTR outusedr$[rsp]
  00437	48 89 44 24 50	 mov	 QWORD PTR [rsp+80], rax
  0043c	48 8d 84 24 94
	00 00 00	 lea	 rax, QWORD PTR outusedv$[rsp]
  00444	48 89 44 24 48	 mov	 QWORD PTR [rsp+72], rax
  00449	8b 84 24 98 00
	00 00		 mov	 eax, DWORD PTR maxtrks$[rsp]
  00450	89 44 24 40	 mov	 DWORD PTR [rsp+64], eax
  00454	8b 84 24 18 81
	00 00		 mov	 eax, DWORD PTR trklen$[rsp]
  0045b	89 44 24 38	 mov	 DWORD PTR [rsp+56], eax
  0045f	8b 84 24 10 81
	00 00		 mov	 eax, DWORD PTR heads$[rsp]
  00466	89 44 24 30	 mov	 DWORD PTR [rsp+48], eax
  0046a	0f b7 84 24 08
	81 00 00	 movzx	 eax, WORD PTR devtype$[rsp]
  00472	66 89 44 24 28	 mov	 WORD PTR [rsp+40], ax
  00477	8b 84 24 8c 00
	00 00		 mov	 eax, DWORD PTR datalen$[rsp]
  0047e	89 44 24 20	 mov	 DWORD PTR [rsp+32], eax
  00482	44 8b 8c 24 90
	00 00 00	 mov	 r9d, DWORD PTR keylen$[rsp]
  0048a	4c 8b 84 24 80
	00 00 00	 mov	 r8, QWORD PTR datablk$[rsp]
  00492	48 8b 94 24 f8
	80 00 00	 mov	 rdx, QWORD PTR ofname$[rsp]
  0049a	48 8b 8c 24 f0
	80 00 00	 mov	 rcx, QWORD PTR cif$[rsp]
  004a2	e8 00 00 00 00	 call	 write_block
  004a7	89 84 24 88 00
	00 00		 mov	 DWORD PTR rc$[rsp], eax

; 763  :                 devtype, heads, trklen, maxtrks,
; 764  :                 &outusedv, &outusedr, &outtrkbr,
; 765  :                 &outtrk, outcyl, outhead, &outrec);
; 766  :     if (rc < 0) return -1;

  004ae	83 bc 24 88 00
	00 00 00	 cmp	 DWORD PTR rc$[rsp], 0
  004b6	7d 0a		 jge	 SHORT $LN12@write_trac
  004b8	b8 ff ff ff ff	 mov	 eax, -1
  004bd	e9 04 03 00 00	 jmp	 $LN1@write_trac
$LN12@write_trac:

; 767  : 
; 768  :     /* Build the VOL1 record */
; 769  :     memset( buf, 0x40, sizeof( buf ));

  004c2	48 8d 84 24 b0
	00 00 00	 lea	 rax, QWORD PTR buf$[rsp]
  004ca	48 8b f8	 mov	 rdi, rax
  004cd	b8 40 00 00 00	 mov	 eax, 64			; 00000040H
  004d2	b9 0b 80 00 00	 mov	 ecx, 32779		; 0000800bH
  004d7	f3 aa		 rep stosb

; 770  :     datablk = (DATABLK*) buf;

  004d9	48 8d 84 24 b0
	00 00 00	 lea	 rax, QWORD PTR buf$[rsp]
  004e1	48 89 84 24 80
	00 00 00	 mov	 QWORD PTR datablk$[rsp], rax

; 771  :     memcpy( datablk->kdarea, VOL1_KEY, VOL1_KEYLEN );

  004e9	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR datablk$[rsp]
  004f1	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR VOL1_KEY
  004f7	89 48 0c	 mov	 DWORD PTR [rax+12], ecx

; 772  :     build_vol1( datablk->kdarea + VOL1_KEYLEN, volser, HERC_OWNERA, true );

  004fa	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR datablk$[rsp]
  00502	48 83 c0 10	 add	 rax, 16
  00506	41 b1 01	 mov	 r9b, 1
  00509	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG160875
  00510	48 8b 94 24 00
	81 00 00	 mov	 rdx, QWORD PTR volser$[rsp]
  00518	48 8b c8	 mov	 rcx, rax
  0051b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_build_vol1

; 773  : 
; 774  :     keylen  = VOL1_KEYLEN;

  00521	c7 84 24 90 00
	00 00 04 00 00
	00		 mov	 DWORD PTR keylen$[rsp], 4

; 775  :     datalen = VOL1_DATALEN;

  0052c	c7 84 24 8c 00
	00 00 50 00 00
	00		 mov	 DWORD PTR datalen$[rsp], 80 ; 00000050H

; 776  : 
; 777  :     rc = write_block( cif, ofname, datablk, keylen, datalen,

  00537	48 8d 84 24 9c
	00 00 00	 lea	 rax, QWORD PTR outrec$[rsp]
  0053f	48 89 44 24 78	 mov	 QWORD PTR [rsp+120], rax
  00544	48 8b 84 24 38
	81 00 00	 mov	 rax, QWORD PTR outhead$[rsp]
  0054c	48 89 44 24 70	 mov	 QWORD PTR [rsp+112], rax
  00551	48 8b 84 24 30
	81 00 00	 mov	 rax, QWORD PTR outcyl$[rsp]
  00559	48 89 44 24 68	 mov	 QWORD PTR [rsp+104], rax
  0055e	48 8d 84 24 a0
	00 00 00	 lea	 rax, QWORD PTR outtrk$[rsp]
  00566	48 89 44 24 60	 mov	 QWORD PTR [rsp+96], rax
  0056b	48 8d 84 24 a4
	00 00 00	 lea	 rax, QWORD PTR outtrkbr$[rsp]
  00573	48 89 44 24 58	 mov	 QWORD PTR [rsp+88], rax
  00578	48 8d 84 24 a8
	00 00 00	 lea	 rax, QWORD PTR outusedr$[rsp]
  00580	48 89 44 24 50	 mov	 QWORD PTR [rsp+80], rax
  00585	48 8d 84 24 94
	00 00 00	 lea	 rax, QWORD PTR outusedv$[rsp]
  0058d	48 89 44 24 48	 mov	 QWORD PTR [rsp+72], rax
  00592	8b 84 24 98 00
	00 00		 mov	 eax, DWORD PTR maxtrks$[rsp]
  00599	89 44 24 40	 mov	 DWORD PTR [rsp+64], eax
  0059d	8b 84 24 18 81
	00 00		 mov	 eax, DWORD PTR trklen$[rsp]
  005a4	89 44 24 38	 mov	 DWORD PTR [rsp+56], eax
  005a8	8b 84 24 10 81
	00 00		 mov	 eax, DWORD PTR heads$[rsp]
  005af	89 44 24 30	 mov	 DWORD PTR [rsp+48], eax
  005b3	0f b7 84 24 08
	81 00 00	 movzx	 eax, WORD PTR devtype$[rsp]
  005bb	66 89 44 24 28	 mov	 WORD PTR [rsp+40], ax
  005c0	8b 84 24 8c 00
	00 00		 mov	 eax, DWORD PTR datalen$[rsp]
  005c7	89 44 24 20	 mov	 DWORD PTR [rsp+32], eax
  005cb	44 8b 8c 24 90
	00 00 00	 mov	 r9d, DWORD PTR keylen$[rsp]
  005d3	4c 8b 84 24 80
	00 00 00	 mov	 r8, QWORD PTR datablk$[rsp]
  005db	48 8b 94 24 f8
	80 00 00	 mov	 rdx, QWORD PTR ofname$[rsp]
  005e3	48 8b 8c 24 f0
	80 00 00	 mov	 rcx, QWORD PTR cif$[rsp]
  005eb	e8 00 00 00 00	 call	 write_block
  005f0	89 84 24 88 00
	00 00		 mov	 DWORD PTR rc$[rsp], eax

; 778  :                 devtype, heads, trklen, maxtrks,
; 779  :                 &outusedv, &outusedr, &outtrkbr,
; 780  :                 &outtrk, outcyl, outhead, &outrec );
; 781  :     if (rc < 0) return -1;

  005f7	83 bc 24 88 00
	00 00 00	 cmp	 DWORD PTR rc$[rsp], 0
  005ff	7d 0a		 jge	 SHORT $LN13@write_trac
  00601	b8 ff ff ff ff	 mov	 eax, -1
  00606	e9 bb 01 00 00	 jmp	 $LN1@write_trac
$LN13@write_trac:

; 782  : 
; 783  :     /* Build the IPL text from the object file */
; 784  :     if (iplfnm != NULL)

  0060b	48 83 bc 24 20
	81 00 00 00	 cmp	 QWORD PTR iplfnm$[rsp], 0
  00614	0f 84 39 01 00
	00		 je	 $LN14@write_trac

; 785  :     {
; 786  :         memset( buf, 0, sizeof( buf ));

  0061a	48 8d 84 24 b0
	00 00 00	 lea	 rax, QWORD PTR buf$[rsp]
  00622	48 8b f8	 mov	 rdi, rax
  00625	33 c0		 xor	 eax, eax
  00627	b9 0b 80 00 00	 mov	 ecx, 32779		; 0000800bH
  0062c	f3 aa		 rep stosb

; 787  :         datalen = read_ipl_text( iplfnm, buf + 12, sizeof( buf ) - 12 );

  0062e	48 8d 84 24 bc
	00 00 00	 lea	 rax, QWORD PTR buf$[rsp+12]
  00636	41 b8 ff 7f 00
	00		 mov	 r8d, 32767		; 00007fffH
  0063c	48 8b d0	 mov	 rdx, rax
  0063f	48 8b 8c 24 20
	81 00 00	 mov	 rcx, QWORD PTR iplfnm$[rsp]
  00647	e8 00 00 00 00	 call	 read_ipl_text
  0064c	89 84 24 8c 00
	00 00		 mov	 DWORD PTR datalen$[rsp], eax

; 788  :         if (datalen < 0) return -1;

  00653	83 bc 24 8c 00
	00 00 00	 cmp	 DWORD PTR datalen$[rsp], 0
  0065b	7d 0a		 jge	 SHORT $LN15@write_trac
  0065d	b8 ff ff ff ff	 mov	 eax, -1
  00662	e9 5f 01 00 00	 jmp	 $LN1@write_trac
$LN15@write_trac:

; 789  : 
; 790  :         datablk = (DATABLK*) buf;

  00667	48 8d 84 24 b0
	00 00 00	 lea	 rax, QWORD PTR buf$[rsp]
  0066f	48 89 84 24 80
	00 00 00	 mov	 QWORD PTR datablk$[rsp], rax

; 791  :         keylen = 0;

  00677	c7 84 24 90 00
	00 00 00 00 00
	00		 mov	 DWORD PTR keylen$[rsp], 0

; 792  : 
; 793  :         rc = write_block( cif, ofname, datablk, keylen, datalen,

  00682	48 8d 84 24 9c
	00 00 00	 lea	 rax, QWORD PTR outrec$[rsp]
  0068a	48 89 44 24 78	 mov	 QWORD PTR [rsp+120], rax
  0068f	48 8b 84 24 38
	81 00 00	 mov	 rax, QWORD PTR outhead$[rsp]
  00697	48 89 44 24 70	 mov	 QWORD PTR [rsp+112], rax
  0069c	48 8b 84 24 30
	81 00 00	 mov	 rax, QWORD PTR outcyl$[rsp]
  006a4	48 89 44 24 68	 mov	 QWORD PTR [rsp+104], rax
  006a9	48 8d 84 24 a0
	00 00 00	 lea	 rax, QWORD PTR outtrk$[rsp]
  006b1	48 89 44 24 60	 mov	 QWORD PTR [rsp+96], rax
  006b6	48 8d 84 24 a4
	00 00 00	 lea	 rax, QWORD PTR outtrkbr$[rsp]
  006be	48 89 44 24 58	 mov	 QWORD PTR [rsp+88], rax
  006c3	48 8d 84 24 a8
	00 00 00	 lea	 rax, QWORD PTR outusedr$[rsp]
  006cb	48 89 44 24 50	 mov	 QWORD PTR [rsp+80], rax
  006d0	48 8d 84 24 94
	00 00 00	 lea	 rax, QWORD PTR outusedv$[rsp]
  006d8	48 89 44 24 48	 mov	 QWORD PTR [rsp+72], rax
  006dd	8b 84 24 98 00
	00 00		 mov	 eax, DWORD PTR maxtrks$[rsp]
  006e4	89 44 24 40	 mov	 DWORD PTR [rsp+64], eax
  006e8	8b 84 24 18 81
	00 00		 mov	 eax, DWORD PTR trklen$[rsp]
  006ef	89 44 24 38	 mov	 DWORD PTR [rsp+56], eax
  006f3	8b 84 24 10 81
	00 00		 mov	 eax, DWORD PTR heads$[rsp]
  006fa	89 44 24 30	 mov	 DWORD PTR [rsp+48], eax
  006fe	0f b7 84 24 08
	81 00 00	 movzx	 eax, WORD PTR devtype$[rsp]
  00706	66 89 44 24 28	 mov	 WORD PTR [rsp+40], ax
  0070b	8b 84 24 8c 00
	00 00		 mov	 eax, DWORD PTR datalen$[rsp]
  00712	89 44 24 20	 mov	 DWORD PTR [rsp+32], eax
  00716	44 8b 8c 24 90
	00 00 00	 mov	 r9d, DWORD PTR keylen$[rsp]
  0071e	4c 8b 84 24 80
	00 00 00	 mov	 r8, QWORD PTR datablk$[rsp]
  00726	48 8b 94 24 f8
	80 00 00	 mov	 rdx, QWORD PTR ofname$[rsp]
  0072e	48 8b 8c 24 f0
	80 00 00	 mov	 rcx, QWORD PTR cif$[rsp]
  00736	e8 00 00 00 00	 call	 write_block
  0073b	89 84 24 88 00
	00 00		 mov	 DWORD PTR rc$[rsp], eax

; 794  :                     devtype, heads, trklen, maxtrks,
; 795  :                     &outusedv, &outusedr, &outtrkbr,
; 796  :                     &outtrk, outcyl, outhead, &outrec );
; 797  :         if (rc < 0) return -1;

  00742	83 bc 24 88 00
	00 00 00	 cmp	 DWORD PTR rc$[rsp], 0
  0074a	7d 07		 jge	 SHORT $LN16@write_trac
  0074c	b8 ff ff ff ff	 mov	 eax, -1
  00751	eb 73		 jmp	 SHORT $LN1@write_trac
$LN16@write_trac:
$LN14@write_trac:

; 798  :     }
; 799  : 
; 800  :     /* Write track zero to the output file */
; 801  :     rc = write_track( cif, ofname, heads, trklen,

  00753	48 8b 84 24 38
	81 00 00	 mov	 rax, QWORD PTR outhead$[rsp]
  0075b	48 89 44 24 38	 mov	 QWORD PTR [rsp+56], rax
  00760	48 8b 84 24 30
	81 00 00	 mov	 rax, QWORD PTR outcyl$[rsp]
  00768	48 89 44 24 30	 mov	 QWORD PTR [rsp+48], rax
  0076d	48 8b 84 24 28
	81 00 00	 mov	 rax, QWORD PTR reltrk$[rsp]
  00775	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  0077a	48 8d 84 24 94
	00 00 00	 lea	 rax, QWORD PTR outusedv$[rsp]
  00782	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00787	44 8b 8c 24 18
	81 00 00	 mov	 r9d, DWORD PTR trklen$[rsp]
  0078f	44 8b 84 24 10
	81 00 00	 mov	 r8d, DWORD PTR heads$[rsp]
  00797	48 8b 94 24 f8
	80 00 00	 mov	 rdx, QWORD PTR ofname$[rsp]
  0079f	48 8b 8c 24 f0
	80 00 00	 mov	 rcx, QWORD PTR cif$[rsp]
  007a7	e8 00 00 00 00	 call	 write_track
  007ac	89 84 24 88 00
	00 00		 mov	 DWORD PTR rc$[rsp], eax

; 802  :                     &outusedv, reltrk, outcyl, outhead );
; 803  :     if (rc < 0) return -1;

  007b3	83 bc 24 88 00
	00 00 00	 cmp	 DWORD PTR rc$[rsp], 0
  007bb	7d 07		 jge	 SHORT $LN17@write_trac
  007bd	b8 ff ff ff ff	 mov	 eax, -1
  007c2	eb 02		 jmp	 SHORT $LN1@write_trac
$LN17@write_trac:

; 804  : 
; 805  :     return 0;

  007c4	33 c0		 xor	 eax, eax
$LN1@write_trac:

; 806  : } /* end function write_track_zero */

  007c6	48 8b 8c 24 c0
	80 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  007ce	48 33 cc	 xor	 rcx, rsp
  007d1	e8 00 00 00 00	 call	 __security_check_cookie
  007d6	48 81 c4 d8 80
	00 00		 add	 rsp, 32984		; 000080d8H
  007dd	5f		 pop	 rdi
  007de	5e		 pop	 rsi
  007df	c3		 ret	 0
write_track_zero ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\dasdload64.c
_TEXT	SEGMENT
cc$ = 128
rc$ = 132
tv168 = 136
tv214 = 140
rechdr$ = 144
cif$ = 192
ofname$ = 200
blk$ = 208
keylen$ = 216
datalen$ = 224
devtype$ = 232
heads$ = 240
trklen$ = 248
maxtrk$ = 256
usedv$ = 264
usedr$ = 272
trkbal$ = 280
reltrk$ = 288
cyl$ = 296
head$ = 304
rec$ = 312
write_block PROC

; 568  : {

  00000	44 89 4c 24 20	 mov	 DWORD PTR [rsp+32], r9d
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	56		 push	 rsi
  00015	57		 push	 rdi
  00016	48 81 ec a8 00
	00 00		 sub	 rsp, 168		; 000000a8H
$LN4@write_bloc:

; 569  : int             rc;                     /* Return code               */
; 570  : int             cc;                     /* Capacity calculation code */
; 571  : CKD_RECHDR     *rechdr;                 /* -> Record header          */
; 572  : 
; 573  :     UNREFERENCED(devtype);

  0001d	33 c0		 xor	 eax, eax
  0001f	85 c0		 test	 eax, eax
  00021	75 fa		 jne	 SHORT $LN4@write_bloc

; 574  : 
; 575  :     /* Determine whether record will fit on current track */
; 576  :     cc = capacity_calc( cif, *usedr, keylen, datalen,

  00023	48 c7 44 24 78
	00 00 00 00	 mov	 QWORD PTR [rsp+120], 0
  0002c	48 c7 44 24 70
	00 00 00 00	 mov	 QWORD PTR [rsp+112], 0
  00035	48 c7 44 24 68
	00 00 00 00	 mov	 QWORD PTR [rsp+104], 0
  0003e	48 c7 44 24 60
	00 00 00 00	 mov	 QWORD PTR [rsp+96], 0
  00047	48 c7 44 24 58
	00 00 00 00	 mov	 QWORD PTR [rsp+88], 0
  00050	48 c7 44 24 50
	00 00 00 00	 mov	 QWORD PTR [rsp+80], 0
  00059	48 c7 44 24 48
	00 00 00 00	 mov	 QWORD PTR [rsp+72], 0
  00062	48 c7 44 24 40
	00 00 00 00	 mov	 QWORD PTR [rsp+64], 0
  0006b	48 c7 44 24 38
	00 00 00 00	 mov	 QWORD PTR [rsp+56], 0
  00074	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR [rsp+48], 0
  0007d	48 8b 84 24 18
	01 00 00	 mov	 rax, QWORD PTR trkbal$[rsp]
  00085	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  0008a	48 8b 84 24 10
	01 00 00	 mov	 rax, QWORD PTR usedr$[rsp]
  00092	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00097	44 8b 8c 24 e0
	00 00 00	 mov	 r9d, DWORD PTR datalen$[rsp]
  0009f	44 8b 84 24 d8
	00 00 00	 mov	 r8d, DWORD PTR keylen$[rsp]
  000a7	48 8b 84 24 10
	01 00 00	 mov	 rax, QWORD PTR usedr$[rsp]
  000af	8b 10		 mov	 edx, DWORD PTR [rax]
  000b1	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR cif$[rsp]
  000b9	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_capacity_calc
  000bf	89 84 24 80 00
	00 00		 mov	 DWORD PTR cc$[rsp], eax

; 577  :                         usedr, trkbal, NULL, NULL, NULL, NULL, NULL,
; 578  :                         NULL, NULL, NULL, NULL, NULL );
; 579  :     if (cc < 0) return -1;

  000c6	83 bc 24 80 00
	00 00 00	 cmp	 DWORD PTR cc$[rsp], 0
  000ce	7d 0a		 jge	 SHORT $LN5@write_bloc
  000d0	b8 ff ff ff ff	 mov	 eax, -1
  000d5	e9 d8 04 00 00	 jmp	 $LN1@write_bloc
$LN5@write_bloc:

; 580  : 
; 581  :     /* Move to next track if record will not fit */
; 582  :     if (cc > 0 && *usedr > 0)

  000da	83 bc 24 80 00
	00 00 00	 cmp	 DWORD PTR cc$[rsp], 0
  000e2	0f 8e 58 01 00
	00		 jle	 $LN6@write_bloc
  000e8	48 8b 84 24 10
	01 00 00	 mov	 rax, QWORD PTR usedr$[rsp]
  000f0	83 38 00	 cmp	 DWORD PTR [rax], 0
  000f3	0f 8e 47 01 00
	00		 jle	 $LN6@write_bloc

; 583  :     {
; 584  :         /* Write current track to output file */
; 585  :         rc = write_track( cif, ofname, heads, trklen,

  000f9	48 8b 84 24 30
	01 00 00	 mov	 rax, QWORD PTR head$[rsp]
  00101	48 89 44 24 38	 mov	 QWORD PTR [rsp+56], rax
  00106	48 8b 84 24 28
	01 00 00	 mov	 rax, QWORD PTR cyl$[rsp]
  0010e	48 89 44 24 30	 mov	 QWORD PTR [rsp+48], rax
  00113	48 8b 84 24 20
	01 00 00	 mov	 rax, QWORD PTR reltrk$[rsp]
  0011b	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  00120	48 8b 84 24 08
	01 00 00	 mov	 rax, QWORD PTR usedv$[rsp]
  00128	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  0012d	44 8b 8c 24 f8
	00 00 00	 mov	 r9d, DWORD PTR trklen$[rsp]
  00135	44 8b 84 24 f0
	00 00 00	 mov	 r8d, DWORD PTR heads$[rsp]
  0013d	48 8b 94 24 c8
	00 00 00	 mov	 rdx, QWORD PTR ofname$[rsp]
  00145	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR cif$[rsp]
  0014d	e8 00 00 00 00	 call	 write_track
  00152	89 84 24 84 00
	00 00		 mov	 DWORD PTR rc$[rsp], eax

; 586  :                           usedv, reltrk, cyl, head );
; 587  :         if (rc < 0) return -1;

  00159	83 bc 24 84 00
	00 00 00	 cmp	 DWORD PTR rc$[rsp], 0
  00161	7d 0a		 jge	 SHORT $LN7@write_bloc
  00163	b8 ff ff ff ff	 mov	 eax, -1
  00168	e9 45 04 00 00	 jmp	 $LN1@write_bloc
$LN7@write_bloc:

; 588  : 
; 589  :         /* Clear bytes used and record number for new track */
; 590  :         *usedr = 0;

  0016d	48 8b 84 24 10
	01 00 00	 mov	 rax, QWORD PTR usedr$[rsp]
  00175	c7 00 00 00 00
	00		 mov	 DWORD PTR [rax], 0

; 591  :         *rec = 0;

  0017b	48 8b 84 24 38
	01 00 00	 mov	 rax, QWORD PTR rec$[rsp]
  00183	c7 00 00 00 00
	00		 mov	 DWORD PTR [rax], 0

; 592  : 
; 593  :         /* Determine whether record will fit on new track */
; 594  :         cc = capacity_calc( cif, *usedr, keylen, datalen,

  00189	48 c7 44 24 78
	00 00 00 00	 mov	 QWORD PTR [rsp+120], 0
  00192	48 c7 44 24 70
	00 00 00 00	 mov	 QWORD PTR [rsp+112], 0
  0019b	48 c7 44 24 68
	00 00 00 00	 mov	 QWORD PTR [rsp+104], 0
  001a4	48 c7 44 24 60
	00 00 00 00	 mov	 QWORD PTR [rsp+96], 0
  001ad	48 c7 44 24 58
	00 00 00 00	 mov	 QWORD PTR [rsp+88], 0
  001b6	48 c7 44 24 50
	00 00 00 00	 mov	 QWORD PTR [rsp+80], 0
  001bf	48 c7 44 24 48
	00 00 00 00	 mov	 QWORD PTR [rsp+72], 0
  001c8	48 c7 44 24 40
	00 00 00 00	 mov	 QWORD PTR [rsp+64], 0
  001d1	48 c7 44 24 38
	00 00 00 00	 mov	 QWORD PTR [rsp+56], 0
  001da	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR [rsp+48], 0
  001e3	48 8b 84 24 18
	01 00 00	 mov	 rax, QWORD PTR trkbal$[rsp]
  001eb	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  001f0	48 8b 84 24 10
	01 00 00	 mov	 rax, QWORD PTR usedr$[rsp]
  001f8	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  001fd	44 8b 8c 24 e0
	00 00 00	 mov	 r9d, DWORD PTR datalen$[rsp]
  00205	44 8b 84 24 d8
	00 00 00	 mov	 r8d, DWORD PTR keylen$[rsp]
  0020d	48 8b 84 24 10
	01 00 00	 mov	 rax, QWORD PTR usedr$[rsp]
  00215	8b 10		 mov	 edx, DWORD PTR [rax]
  00217	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR cif$[rsp]
  0021f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_capacity_calc
  00225	89 84 24 80 00
	00 00		 mov	 DWORD PTR cc$[rsp], eax

; 595  :                             usedr, trkbal, NULL, NULL, NULL, NULL,
; 596  :                             NULL, NULL, NULL, NULL, NULL, NULL );
; 597  :         if (cc < 0) return -1;

  0022c	83 bc 24 80 00
	00 00 00	 cmp	 DWORD PTR cc$[rsp], 0
  00234	7d 0a		 jge	 SHORT $LN8@write_bloc
  00236	b8 ff ff ff ff	 mov	 eax, -1
  0023b	e9 72 03 00 00	 jmp	 $LN1@write_bloc
$LN8@write_bloc:
$LN6@write_bloc:

; 598  : 
; 599  :     } /* end if */
; 600  : 
; 601  :     /* Error if record will not even fit on an empty track */
; 602  :     if (cc > 0)

  00240	83 bc 24 80 00
	00 00 00	 cmp	 DWORD PTR cc$[rsp], 0
  00248	0f 8e a7 00 00
	00		 jle	 $LN9@write_bloc

; 603  :     {
; 604  :         XMERRF ( MSG( HHC02510, "E", blk->cyl[0], blk->cyl[1],

  0024e	48 8b 84 24 d0
	00 00 00	 mov	 rax, QWORD PTR blk$[rsp]
  00256	0f b6 40 08	 movzx	 eax, BYTE PTR [rax+8]
  0025a	b9 01 00 00 00	 mov	 ecx, 1
  0025f	48 6b c9 01	 imul	 rcx, rcx, 1
  00263	48 8b 94 24 d0
	00 00 00	 mov	 rdx, QWORD PTR blk$[rsp]
  0026b	0f b6 4c 0a 06	 movzx	 ecx, BYTE PTR [rdx+rcx+6]
  00270	ba 01 00 00 00	 mov	 edx, 1
  00275	48 6b d2 00	 imul	 rdx, rdx, 0
  00279	4c 8b 84 24 d0
	00 00 00	 mov	 r8, QWORD PTR blk$[rsp]
  00281	41 0f b6 54 10
	06		 movzx	 edx, BYTE PTR [r8+rdx+6]
  00287	41 b8 01 00 00
	00		 mov	 r8d, 1
  0028d	4d 6b c0 01	 imul	 r8, r8, 1
  00291	4c 8b 8c 24 d0
	00 00 00	 mov	 r9, QWORD PTR blk$[rsp]
  00299	47 0f b6 44 01
	04		 movzx	 r8d, BYTE PTR [r9+r8+4]
  0029f	41 b9 01 00 00
	00		 mov	 r9d, 1
  002a5	4d 6b c9 00	 imul	 r9, r9, 0
  002a9	4c 8b 94 24 d0
	00 00 00	 mov	 r10, QWORD PTR blk$[rsp]
  002b1	47 0f b6 4c 0a
	04		 movzx	 r9d, BYTE PTR [r10+r9+4]
  002b7	44 89 8c 24 88
	00 00 00	 mov	 DWORD PTR tv168[rsp], r9d
  002bf	89 44 24 30	 mov	 DWORD PTR [rsp+48], eax
  002c3	89 4c 24 28	 mov	 DWORD PTR [rsp+40], ecx
  002c7	89 54 24 20	 mov	 DWORD PTR [rsp+32], edx
  002cb	45 8b c8	 mov	 r9d, r8d
  002ce	8b 84 24 88 00
	00 00		 mov	 eax, DWORD PTR tv168[rsp]
  002d5	44 8b c0	 mov	 r8d, eax
  002d8	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG160808
  002df	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG160809
  002e6	e8 00 00 00 00	 call	 printf

; 605  :                 blk->head[0], blk->head[1], blk->rec ) );
; 606  :         return -1;

  002eb	b8 ff ff ff ff	 mov	 eax, -1
  002f0	e9 bd 02 00 00	 jmp	 $LN1@write_bloc
$LN9@write_bloc:

; 607  :     }
; 608  : 
; 609  :     /* Determine whether end of extent has been reached */
; 610  :     if (*reltrk >= maxtrk)

  002f5	48 8b 84 24 20
	01 00 00	 mov	 rax, QWORD PTR reltrk$[rsp]
  002fd	8b 8c 24 00 01
	00 00		 mov	 ecx, DWORD PTR maxtrk$[rsp]
  00304	39 08		 cmp	 DWORD PTR [rax], ecx
  00306	7c 30		 jl	 SHORT $LN10@write_bloc

; 611  :     {
; 612  :         XMERRF ( MSG( HHC02511, "E", *reltrk, maxtrk ) );

  00308	44 8b 8c 24 00
	01 00 00	 mov	 r9d, DWORD PTR maxtrk$[rsp]
  00310	48 8b 84 24 20
	01 00 00	 mov	 rax, QWORD PTR reltrk$[rsp]
  00318	44 8b 00	 mov	 r8d, DWORD PTR [rax]
  0031b	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG160811
  00322	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG160812
  00329	e8 00 00 00 00	 call	 printf

; 613  :         return -1;

  0032e	b8 ff ff ff ff	 mov	 eax, -1
  00333	e9 7a 02 00 00	 jmp	 $LN1@write_bloc
$LN10@write_bloc:

; 614  :     }
; 615  : 
; 616  :     /* Build home address and record 0 if new track */
; 617  :     if (*usedv == 0)

  00338	48 8b 84 24 08
	01 00 00	 mov	 rax, QWORD PTR usedv$[rsp]
  00340	83 38 00	 cmp	 DWORD PTR [rax], 0
  00343	75 3b		 jne	 SHORT $LN11@write_bloc

; 618  :         init_track( trklen, cif->trkbuf, *cyl, *head, usedv );

  00345	48 8b 84 24 08
	01 00 00	 mov	 rax, QWORD PTR usedv$[rsp]
  0034d	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00352	48 8b 84 24 30
	01 00 00	 mov	 rax, QWORD PTR head$[rsp]
  0035a	44 8b 08	 mov	 r9d, DWORD PTR [rax]
  0035d	48 8b 84 24 28
	01 00 00	 mov	 rax, QWORD PTR cyl$[rsp]
  00365	44 8b 00	 mov	 r8d, DWORD PTR [rax]
  00368	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR cif$[rsp]
  00370	48 8b 50 10	 mov	 rdx, QWORD PTR [rax+16]
  00374	8b 8c 24 f8 00
	00 00		 mov	 ecx, DWORD PTR trklen$[rsp]
  0037b	e8 00 00 00 00	 call	 init_track
$LN11@write_bloc:

; 619  : 
; 620  :     /* Double check that record will not exceed virtual track size */
; 621  :     if (*usedv + CKD_RECHDR_SIZE + keylen + datalen + 8 > trklen)

  00380	48 8b 84 24 08
	01 00 00	 mov	 rax, QWORD PTR usedv$[rsp]
  00388	48 63 00	 movsxd	 rax, DWORD PTR [rax]
  0038b	48 63 8c 24 d8
	00 00 00	 movsxd	 rcx, DWORD PTR keylen$[rsp]
  00393	48 8d 44 08 08	 lea	 rax, QWORD PTR [rax+rcx+8]
  00398	48 63 8c 24 e0
	00 00 00	 movsxd	 rcx, DWORD PTR datalen$[rsp]
  003a0	48 8d 44 08 08	 lea	 rax, QWORD PTR [rax+rcx+8]
  003a5	48 63 8c 24 f8
	00 00 00	 movsxd	 rcx, DWORD PTR trklen$[rsp]
  003ad	48 3b c1	 cmp	 rax, rcx
  003b0	0f 8e a7 00 00
	00		 jle	 $LN12@write_bloc

; 622  :     {
; 623  :         XMERRF ( MSG( HHC02512, "E", blk->cyl[0], blk->cyl[1],

  003b6	48 8b 84 24 d0
	00 00 00	 mov	 rax, QWORD PTR blk$[rsp]
  003be	0f b6 40 08	 movzx	 eax, BYTE PTR [rax+8]
  003c2	b9 01 00 00 00	 mov	 ecx, 1
  003c7	48 6b c9 01	 imul	 rcx, rcx, 1
  003cb	48 8b 94 24 d0
	00 00 00	 mov	 rdx, QWORD PTR blk$[rsp]
  003d3	0f b6 4c 0a 06	 movzx	 ecx, BYTE PTR [rdx+rcx+6]
  003d8	ba 01 00 00 00	 mov	 edx, 1
  003dd	48 6b d2 00	 imul	 rdx, rdx, 0
  003e1	4c 8b 84 24 d0
	00 00 00	 mov	 r8, QWORD PTR blk$[rsp]
  003e9	41 0f b6 54 10
	06		 movzx	 edx, BYTE PTR [r8+rdx+6]
  003ef	41 b8 01 00 00
	00		 mov	 r8d, 1
  003f5	4d 6b c0 01	 imul	 r8, r8, 1
  003f9	4c 8b 8c 24 d0
	00 00 00	 mov	 r9, QWORD PTR blk$[rsp]
  00401	47 0f b6 44 01
	04		 movzx	 r8d, BYTE PTR [r9+r8+4]
  00407	41 b9 01 00 00
	00		 mov	 r9d, 1
  0040d	4d 6b c9 00	 imul	 r9, r9, 0
  00411	4c 8b 94 24 d0
	00 00 00	 mov	 r10, QWORD PTR blk$[rsp]
  00419	47 0f b6 4c 0a
	04		 movzx	 r9d, BYTE PTR [r10+r9+4]
  0041f	44 89 8c 24 8c
	00 00 00	 mov	 DWORD PTR tv214[rsp], r9d
  00427	89 44 24 30	 mov	 DWORD PTR [rsp+48], eax
  0042b	89 4c 24 28	 mov	 DWORD PTR [rsp+40], ecx
  0042f	89 54 24 20	 mov	 DWORD PTR [rsp+32], edx
  00433	45 8b c8	 mov	 r9d, r8d
  00436	8b 84 24 8c 00
	00 00		 mov	 eax, DWORD PTR tv214[rsp]
  0043d	44 8b c0	 mov	 r8d, eax
  00440	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG160815
  00447	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG160816
  0044e	e8 00 00 00 00	 call	 printf

; 624  :                 blk->head[0], blk->head[1], blk->rec ) );
; 625  :         return -1;

  00453	b8 ff ff ff ff	 mov	 eax, -1
  00458	e9 55 01 00 00	 jmp	 $LN1@write_bloc
$LN12@write_bloc:

; 626  :     }
; 627  : 
; 628  :     /* Add data block to virtual track buffer */
; 629  :     (*rec)++;

  0045d	48 8b 84 24 38
	01 00 00	 mov	 rax, QWORD PTR rec$[rsp]
  00465	8b 00		 mov	 eax, DWORD PTR [rax]
  00467	ff c0		 inc	 eax
  00469	48 8b 8c 24 38
	01 00 00	 mov	 rcx, QWORD PTR rec$[rsp]
  00471	89 01		 mov	 DWORD PTR [rcx], eax

; 630  :     rechdr = (CKD_RECHDR*)(cif->trkbuf + *usedv);

  00473	48 8b 84 24 08
	01 00 00	 mov	 rax, QWORD PTR usedv$[rsp]
  0047b	48 63 00	 movsxd	 rax, DWORD PTR [rax]
  0047e	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR cif$[rsp]
  00486	48 03 41 10	 add	 rax, QWORD PTR [rcx+16]
  0048a	48 89 84 24 90
	00 00 00	 mov	 QWORD PTR rechdr$[rsp], rax

; 631  :     store_hw( rechdr->cyl,   (U16)  *cyl  );

  00492	48 8b 84 24 28
	01 00 00	 mov	 rax, QWORD PTR cyl$[rsp]
  0049a	0f b7 08	 movzx	 ecx, WORD PTR [rax]
  0049d	e8 00 00 00 00	 call	 _byteswap_ushort
  004a2	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR rechdr$[rsp]
  004aa	0f b7 d0	 movzx	 edx, ax
  004ad	e8 00 00 00 00	 call	 store_hw_noswap

; 632  :     store_hw( rechdr->head,  (U16)  *head );

  004b2	48 8b 84 24 30
	01 00 00	 mov	 rax, QWORD PTR head$[rsp]
  004ba	0f b7 08	 movzx	 ecx, WORD PTR [rax]
  004bd	e8 00 00 00 00	 call	 _byteswap_ushort
  004c2	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR rechdr$[rsp]
  004ca	48 83 c1 02	 add	 rcx, 2
  004ce	0f b7 d0	 movzx	 edx, ax
  004d1	e8 00 00 00 00	 call	 store_hw_noswap

; 633  :               rechdr->rec  = (BYTE) *rec;

  004d6	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR rechdr$[rsp]
  004de	48 8b 8c 24 38
	01 00 00	 mov	 rcx, QWORD PTR rec$[rsp]
  004e6	0f b6 09	 movzx	 ecx, BYTE PTR [rcx]
  004e9	88 48 04	 mov	 BYTE PTR [rax+4], cl

; 634  :               rechdr->klen = (BYTE)  keylen;

  004ec	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR rechdr$[rsp]
  004f4	0f b6 8c 24 d8
	00 00 00	 movzx	 ecx, BYTE PTR keylen$[rsp]
  004fc	88 48 05	 mov	 BYTE PTR [rax+5], cl

; 635  :     store_hw( rechdr->dlen,  (U16)   datalen );

  004ff	0f b7 8c 24 e0
	00 00 00	 movzx	 ecx, WORD PTR datalen$[rsp]
  00507	e8 00 00 00 00	 call	 _byteswap_ushort
  0050c	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR rechdr$[rsp]
  00514	48 83 c1 06	 add	 rcx, 6
  00518	0f b7 d0	 movzx	 edx, ax
  0051b	e8 00 00 00 00	 call	 store_hw_noswap

; 636  :     *usedv += CKD_RECHDR_SIZE;

  00520	48 8b 84 24 08
	01 00 00	 mov	 rax, QWORD PTR usedv$[rsp]
  00528	48 63 00	 movsxd	 rax, DWORD PTR [rax]
  0052b	48 83 c0 08	 add	 rax, 8
  0052f	48 8b 8c 24 08
	01 00 00	 mov	 rcx, QWORD PTR usedv$[rsp]
  00537	89 01		 mov	 DWORD PTR [rcx], eax

; 637  :     memcpy( cif->trkbuf + *usedv, blk->kdarea, keylen + datalen );

  00539	8b 84 24 e0 00
	00 00		 mov	 eax, DWORD PTR datalen$[rsp]
  00540	8b 8c 24 d8 00
	00 00		 mov	 ecx, DWORD PTR keylen$[rsp]
  00547	03 c8		 add	 ecx, eax
  00549	8b c1		 mov	 eax, ecx
  0054b	48 98		 cdqe
  0054d	48 8b 8c 24 d0
	00 00 00	 mov	 rcx, QWORD PTR blk$[rsp]
  00555	48 83 c1 0c	 add	 rcx, 12
  00559	48 8b 94 24 08
	01 00 00	 mov	 rdx, QWORD PTR usedv$[rsp]
  00561	48 63 12	 movsxd	 rdx, DWORD PTR [rdx]
  00564	4c 8b 84 24 c0
	00 00 00	 mov	 r8, QWORD PTR cif$[rsp]
  0056c	49 03 50 10	 add	 rdx, QWORD PTR [r8+16]
  00570	48 8b fa	 mov	 rdi, rdx
  00573	48 8b f1	 mov	 rsi, rcx
  00576	48 8b c8	 mov	 rcx, rax
  00579	f3 a4		 rep movsb

; 638  :     *usedv += keylen + datalen;

  0057b	8b 84 24 e0 00
	00 00		 mov	 eax, DWORD PTR datalen$[rsp]
  00582	8b 8c 24 d8 00
	00 00		 mov	 ecx, DWORD PTR keylen$[rsp]
  00589	03 c8		 add	 ecx, eax
  0058b	8b c1		 mov	 eax, ecx
  0058d	48 8b 8c 24 08
	01 00 00	 mov	 rcx, QWORD PTR usedv$[rsp]
  00595	03 01		 add	 eax, DWORD PTR [rcx]
  00597	48 8b 8c 24 08
	01 00 00	 mov	 rcx, QWORD PTR usedv$[rsp]
  0059f	89 01		 mov	 DWORD PTR [rcx], eax

; 639  :     cif->trkmodif = 1;

  005a1	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR cif$[rsp]
  005a9	c7 40 20 01 00
	00 00		 mov	 DWORD PTR [rax+32], 1

; 640  : 
; 641  :     return 0;

  005b0	33 c0		 xor	 eax, eax
$LN1@write_bloc:

; 642  : } /* end function write_block */

  005b2	48 81 c4 a8 00
	00 00		 add	 rsp, 168		; 000000a8H
  005b9	5f		 pop	 rdi
  005ba	5e		 pop	 rsi
  005bb	c3		 ret	 0
write_block ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\dasdload64.c
_TEXT	SEGMENT
rc$ = 32
cif$ = 64
ofname$ = 72
heads$ = 80
trklen$ = 88
usedv$ = 96
reltrk$ = 104
cyl$ = 112
head$ = 120
write_track PROC

; 504  : {

  00000	44 89 4c 24 20	 mov	 DWORD PTR [rsp+32], r9d
  00005	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	48 83 ec 38	 sub	 rsp, 56			; 00000038H
$LN4@write_trac:

; 505  : int             rc;                     /* Return code               */
; 506  : 
; 507  :     UNREFERENCED(ofname);

  00018	33 c0		 xor	 eax, eax
  0001a	85 c0		 test	 eax, eax
  0001c	75 fa		 jne	 SHORT $LN4@write_trac
$LN7@write_trac:

; 508  :     UNREFERENCED(trklen);

  0001e	33 c0		 xor	 eax, eax
  00020	85 c0		 test	 eax, eax
  00022	75 fa		 jne	 SHORT $LN7@write_trac

; 509  : 
; 510  :     /* Don't overwrite HA */
; 511  :     if (*usedv == 0)

  00024	48 8b 44 24 60	 mov	 rax, QWORD PTR usedv$[rsp]
  00029	83 38 00	 cmp	 DWORD PTR [rax], 0
  0002c	75 0b		 jne	 SHORT $LN8@write_trac

; 512  :         *usedv = CKD_TRKHDR_SIZE;

  0002e	48 8b 44 24 60	 mov	 rax, QWORD PTR usedv$[rsp]
  00033	c7 00 05 00 00
	00		 mov	 DWORD PTR [rax], 5
$LN8@write_trac:

; 513  : 
; 514  :     /* Build end of track marker at end of buffer */
; 515  :     memcpy( cif->trkbuf + *usedv, &CKD_ENDTRK, CKD_ENDTRK_SIZE );

  00039	48 8b 44 24 60	 mov	 rax, QWORD PTR usedv$[rsp]
  0003e	48 63 00	 movsxd	 rax, DWORD PTR [rax]
  00041	48 8b 4c 24 40	 mov	 rcx, QWORD PTR cif$[rsp]
  00046	48 8b 49 10	 mov	 rcx, QWORD PTR [rcx+16]
  0004a	48 8b 15 00 00
	00 00		 mov	 rdx, QWORD PTR CKD_ENDTRK
  00051	48 89 14 01	 mov	 QWORD PTR [rcx+rax], rdx

; 516  :     cif->trkmodif = 1;

  00055	48 8b 44 24 40	 mov	 rax, QWORD PTR cif$[rsp]
  0005a	c7 40 20 01 00
	00 00		 mov	 DWORD PTR [rax+32], 1

; 517  : 
; 518  :     /* Reset values for next track */
; 519  :     (*reltrk)++;

  00061	48 8b 44 24 68	 mov	 rax, QWORD PTR reltrk$[rsp]
  00066	8b 00		 mov	 eax, DWORD PTR [rax]
  00068	ff c0		 inc	 eax
  0006a	48 8b 4c 24 68	 mov	 rcx, QWORD PTR reltrk$[rsp]
  0006f	89 01		 mov	 DWORD PTR [rcx], eax

; 520  :     (*head)++;

  00071	48 8b 44 24 78	 mov	 rax, QWORD PTR head$[rsp]
  00076	8b 00		 mov	 eax, DWORD PTR [rax]
  00078	ff c0		 inc	 eax
  0007a	48 8b 4c 24 78	 mov	 rcx, QWORD PTR head$[rsp]
  0007f	89 01		 mov	 DWORD PTR [rcx], eax

; 521  :     if (*head >= heads)

  00081	48 8b 44 24 78	 mov	 rax, QWORD PTR head$[rsp]
  00086	8b 4c 24 50	 mov	 ecx, DWORD PTR heads$[rsp]
  0008a	39 08		 cmp	 DWORD PTR [rax], ecx
  0008c	7c 1b		 jl	 SHORT $LN9@write_trac

; 522  :     {
; 523  :         (*cyl)++;

  0008e	48 8b 44 24 70	 mov	 rax, QWORD PTR cyl$[rsp]
  00093	8b 00		 mov	 eax, DWORD PTR [rax]
  00095	ff c0		 inc	 eax
  00097	48 8b 4c 24 70	 mov	 rcx, QWORD PTR cyl$[rsp]
  0009c	89 01		 mov	 DWORD PTR [rcx], eax

; 524  :         *head = 0;

  0009e	48 8b 44 24 78	 mov	 rax, QWORD PTR head$[rsp]
  000a3	c7 00 00 00 00
	00		 mov	 DWORD PTR [rax], 0
$LN9@write_trac:

; 525  :     }
; 526  :     *usedv = 0;

  000a9	48 8b 44 24 60	 mov	 rax, QWORD PTR usedv$[rsp]
  000ae	c7 00 00 00 00
	00		 mov	 DWORD PTR [rax], 0

; 527  : 
; 528  :     /* Read the next track */
; 529  :     if (*cyl < (int)cif->devblk.ckdcyls)

  000b4	48 8b 44 24 70	 mov	 rax, QWORD PTR cyl$[rsp]
  000b9	48 8b 4c 24 40	 mov	 rcx, QWORD PTR cif$[rsp]
  000be	8b 89 e8 12 00
	00		 mov	 ecx, DWORD PTR [rcx+4840]
  000c4	39 08		 cmp	 DWORD PTR [rax], ecx
  000c6	7d 2d		 jge	 SHORT $LN10@write_trac

; 530  :     {
; 531  :         rc = read_track( cif, *cyl, (U8) *head );

  000c8	48 8b 44 24 78	 mov	 rax, QWORD PTR head$[rsp]
  000cd	44 0f b6 00	 movzx	 r8d, BYTE PTR [rax]
  000d1	48 8b 44 24 70	 mov	 rax, QWORD PTR cyl$[rsp]
  000d6	8b 10		 mov	 edx, DWORD PTR [rax]
  000d8	48 8b 4c 24 40	 mov	 rcx, QWORD PTR cif$[rsp]
  000dd	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_read_track
  000e3	89 44 24 20	 mov	 DWORD PTR rc$[rsp], eax

; 532  :         if (rc < 0) return -1;

  000e7	83 7c 24 20 00	 cmp	 DWORD PTR rc$[rsp], 0
  000ec	7d 07		 jge	 SHORT $LN11@write_trac
  000ee	b8 ff ff ff ff	 mov	 eax, -1
  000f3	eb 02		 jmp	 SHORT $LN1@write_trac
$LN11@write_trac:
$LN10@write_trac:

; 533  :     }
; 534  : 
; 535  :     return 0;

  000f5	33 c0		 xor	 eax, eax
$LN1@write_trac:

; 536  : } /* end function write_track */

  000f7	48 83 c4 38	 add	 rsp, 56			; 00000038H
  000fb	c3		 ret	 0
write_track ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\dasdload64.c
_TEXT	SEGMENT
rechdr$ = 32
trkhdr$ = 40
tv66 = 48
trklen$ = 80
trkbuf$ = 88
cyl$ = 96
head$ = 104
usedv$ = 112
init_track PROC

; 457  : {

  00000	44 89 4c 24 20	 mov	 DWORD PTR [rsp+32], r9d
  00005	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	89 4c 24 08	 mov	 DWORD PTR [rsp+8], ecx
  00013	57		 push	 rdi
  00014	48 83 ec 40	 sub	 rsp, 64			; 00000040H

; 458  :     CKD_TRKHDR *trkhdr;                 /* -> Track header           */
; 459  :     CKD_RECHDR *rechdr;                 /* -> Record header          */
; 460  : 
; 461  :     /* Clear the track buffer to zeroes */
; 462  :     memset (trkbuf, 0, trklen);

  00018	48 63 44 24 50	 movsxd	 rax, DWORD PTR trklen$[rsp]
  0001d	48 89 44 24 30	 mov	 QWORD PTR tv66[rsp], rax
  00022	48 8b 7c 24 58	 mov	 rdi, QWORD PTR trkbuf$[rsp]
  00027	33 c0		 xor	 eax, eax
  00029	48 8b 4c 24 30	 mov	 rcx, QWORD PTR tv66[rsp]
  0002e	f3 aa		 rep stosb

; 463  : 
; 464  :     /* Build the home address in the track buffer */
; 465  :     trkhdr = (CKD_TRKHDR*) trkbuf;

  00030	48 8b 44 24 58	 mov	 rax, QWORD PTR trkbuf$[rsp]
  00035	48 89 44 24 28	 mov	 QWORD PTR trkhdr$[rsp], rax

; 466  :     trkhdr->bin = 0;

  0003a	48 8b 44 24 28	 mov	 rax, QWORD PTR trkhdr$[rsp]
  0003f	c6 00 00	 mov	 BYTE PTR [rax], 0

; 467  :     store_hw( trkhdr->cyl,  cyl  );

  00042	0f b7 4c 24 60	 movzx	 ecx, WORD PTR cyl$[rsp]
  00047	e8 00 00 00 00	 call	 _byteswap_ushort
  0004c	48 8b 4c 24 28	 mov	 rcx, QWORD PTR trkhdr$[rsp]
  00051	48 ff c1	 inc	 rcx
  00054	0f b7 d0	 movzx	 edx, ax
  00057	e8 00 00 00 00	 call	 store_hw_noswap

; 468  :     store_hw( trkhdr->head, head );

  0005c	0f b7 4c 24 68	 movzx	 ecx, WORD PTR head$[rsp]
  00061	e8 00 00 00 00	 call	 _byteswap_ushort
  00066	48 8b 4c 24 28	 mov	 rcx, QWORD PTR trkhdr$[rsp]
  0006b	48 83 c1 03	 add	 rcx, 3
  0006f	0f b7 d0	 movzx	 edx, ax
  00072	e8 00 00 00 00	 call	 store_hw_noswap

; 469  : 
; 470  :     /* Build a standard record zero in the track buffer */
; 471  :     rechdr = (CKD_RECHDR*) (trkbuf + CKD_TRKHDR_SIZE);

  00077	48 8b 44 24 58	 mov	 rax, QWORD PTR trkbuf$[rsp]
  0007c	48 83 c0 05	 add	 rax, 5
  00080	48 89 44 24 20	 mov	 QWORD PTR rechdr$[rsp], rax

; 472  :     store_hw( rechdr->cyl,  cyl  );

  00085	0f b7 4c 24 60	 movzx	 ecx, WORD PTR cyl$[rsp]
  0008a	e8 00 00 00 00	 call	 _byteswap_ushort
  0008f	48 8b 4c 24 20	 mov	 rcx, QWORD PTR rechdr$[rsp]
  00094	0f b7 d0	 movzx	 edx, ax
  00097	e8 00 00 00 00	 call	 store_hw_noswap

; 473  :     store_hw( rechdr->head, head );

  0009c	0f b7 4c 24 68	 movzx	 ecx, WORD PTR head$[rsp]
  000a1	e8 00 00 00 00	 call	 _byteswap_ushort
  000a6	48 8b 4c 24 20	 mov	 rcx, QWORD PTR rechdr$[rsp]
  000ab	48 83 c1 02	 add	 rcx, 2
  000af	0f b7 d0	 movzx	 edx, ax
  000b2	e8 00 00 00 00	 call	 store_hw_noswap

; 474  :               rechdr->rec  = 0;

  000b7	48 8b 44 24 20	 mov	 rax, QWORD PTR rechdr$[rsp]
  000bc	c6 40 04 00	 mov	 BYTE PTR [rax+4], 0

; 475  :               rechdr->klen = 0;

  000c0	48 8b 44 24 20	 mov	 rax, QWORD PTR rechdr$[rsp]
  000c5	c6 40 05 00	 mov	 BYTE PTR [rax+5], 0

; 476  :     store_hw( rechdr->dlen, CKD_R0_DLEN );

  000c9	66 b9 08 00	 mov	 cx, 8
  000cd	e8 00 00 00 00	 call	 _byteswap_ushort
  000d2	48 8b 4c 24 20	 mov	 rcx, QWORD PTR rechdr$[rsp]
  000d7	48 83 c1 06	 add	 rcx, 6
  000db	0f b7 d0	 movzx	 edx, ax
  000de	e8 00 00 00 00	 call	 store_hw_noswap

; 477  : 
; 478  :     /* Set number of bytes used in track buffer */
; 479  :     *usedv = CKD_TRKHDR_SIZE + CKD_RECHDR_SIZE + CKD_R0_DLEN;

  000e3	48 8b 44 24 70	 mov	 rax, QWORD PTR usedv$[rsp]
  000e8	c7 00 15 00 00
	00		 mov	 DWORD PTR [rax], 21

; 480  : 
; 481  :     /* Build end of track marker at end of buffer */
; 482  :     memcpy( trkbuf + *usedv, &CKD_ENDTRK, CKD_ENDTRK_SIZE );

  000ee	48 8b 44 24 70	 mov	 rax, QWORD PTR usedv$[rsp]
  000f3	48 63 00	 movsxd	 rax, DWORD PTR [rax]
  000f6	48 8b 4c 24 58	 mov	 rcx, QWORD PTR trkbuf$[rsp]
  000fb	48 8b 15 00 00
	00 00		 mov	 rdx, QWORD PTR CKD_ENDTRK
  00102	48 89 14 01	 mov	 QWORD PTR [rcx+rax], rdx

; 483  : 
; 484  : } /* end function init_track */

  00106	48 83 c4 40	 add	 rsp, 64			; 00000040H
  0010a	5f		 pop	 rdi
  0010b	c3		 ret	 0
init_track ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\dasdload64.c
_TEXT	SEGMENT
txtlen$ = 48
tfd$ = 52
txtadr$ = 56
ipllen$ = 60
rc$ = 64
objrec$ = 80
pathname$ = 160
__$ArrayPad$ = 432
iplfnm$ = 480
iplbuf$ = 488
buflen$ = 496
read_ipl_text PROC

; 363  : {

  00000	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	56		 push	 rsi
  00010	57		 push	 rdi
  00011	48 81 ec c8 01
	00 00		 sub	 rsp, 456		; 000001c8H
  00018	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  0001f	48 33 c4	 xor	 rax, rsp
  00022	48 89 84 24 b0
	01 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 364  : int             rc;                     /* Return code               */
; 365  : int             ipllen = 0;             /* Length of IPL text        */

  0002a	c7 44 24 3c 00
	00 00 00	 mov	 DWORD PTR ipllen$[rsp], 0

; 366  : int             txtlen;                 /* Byte count from TXT card  */
; 367  : int             txtadr;                 /* Address from TXT card     */
; 368  : int             tfd;                    /* Object file descriptor    */
; 369  : BYTE            objrec[80];             /* Object card image         */
; 370  : char            pathname[MAX_PATH];     /* iplfnm in host path format*/
; 371  : 
; 372  :     /* Open the object file */
; 373  :     hostpath(pathname, iplfnm, sizeof(pathname));

  00032	41 b8 04 01 00
	00		 mov	 r8d, 260		; 00000104H
  00038	48 8b 94 24 e0
	01 00 00	 mov	 rdx, QWORD PTR iplfnm$[rsp]
  00040	48 8d 8c 24 a0
	00 00 00	 lea	 rcx, QWORD PTR pathname$[rsp]
  00048	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hostpath

; 374  :     tfd = HOPEN (pathname, O_RDONLY|O_BINARY);

  0004e	ba 00 80 00 00	 mov	 edx, 32768		; 00008000H
  00053	48 8d 8c 24 a0
	00 00 00	 lea	 rcx, QWORD PTR pathname$[rsp]
  0005b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_hopen
  00061	89 44 24 34	 mov	 DWORD PTR tfd$[rsp], eax

; 375  :     if (tfd < 0)

  00065	83 7c 24 34 00	 cmp	 DWORD PTR tfd$[rsp], 0
  0006a	7d 3f		 jge	 SHORT $LN4@read_ipl_t

; 376  :     {
; 377  :         XMERRF ( MSG( HHC02506, "E", "open", iplfnm, strerror( errno ) ) );

  0006c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno
  00072	8b 08		 mov	 ecx, DWORD PTR [rax]
  00074	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_strerror
  0007a	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  0007f	4c 8b 8c 24 e0
	01 00 00	 mov	 r9, QWORD PTR iplfnm$[rsp]
  00087	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG160653
  0008e	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG160654
  00095	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG160655
  0009c	e8 00 00 00 00	 call	 printf

; 378  :         return -1;

  000a1	b8 ff ff ff ff	 mov	 eax, -1
  000a6	e9 5a 02 00 00	 jmp	 $LN1@read_ipl_t
$LN4@read_ipl_t:
$LN13@read_ipl_t:
$LN2@read_ipl_t:

; 379  :     }
; 380  : 
; 381  :     /* Read the object file */
; 382  :     while (1)

  000ab	33 c0		 xor	 eax, eax
  000ad	83 f8 01	 cmp	 eax, 1
  000b0	0f 84 4b 02 00
	00		 je	 $LN3@read_ipl_t

; 383  :     {
; 384  :         /* Read a card image from the object file */
; 385  :         rc = read (tfd, objrec, 80);

  000b6	41 b8 50 00 00
	00		 mov	 r8d, 80			; 00000050H
  000bc	48 8d 54 24 50	 lea	 rdx, QWORD PTR objrec$[rsp]
  000c1	8b 4c 24 34	 mov	 ecx, DWORD PTR tfd$[rsp]
  000c5	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_read
  000cb	89 44 24 40	 mov	 DWORD PTR rc$[rsp], eax

; 386  :         if (rc < 80)

  000cf	83 7c 24 40 50	 cmp	 DWORD PTR rc$[rsp], 80	; 00000050H
  000d4	7d 49		 jge	 SHORT $LN5@read_ipl_t

; 387  :         {
; 388  :             XMERRF ( MSG( HHC02506, "E", "read", iplfnm, strerror( errno ) ) );

  000d6	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno
  000dc	8b 08		 mov	 ecx, DWORD PTR [rax]
  000de	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_strerror
  000e4	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  000e9	4c 8b 8c 24 e0
	01 00 00	 mov	 r9, QWORD PTR iplfnm$[rsp]
  000f1	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG160657
  000f8	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG160658
  000ff	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG160659
  00106	e8 00 00 00 00	 call	 printf

; 389  :             close (tfd);

  0010b	8b 4c 24 34	 mov	 ecx, DWORD PTR tfd$[rsp]
  0010f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_close

; 390  :             return -1;

  00115	b8 ff ff ff ff	 mov	 eax, -1
  0011a	e9 e6 01 00 00	 jmp	 $LN1@read_ipl_t
$LN5@read_ipl_t:

; 391  :         }
; 392  : 
; 393  :         /* Column 1 of each object card must contain X'02' */
; 394  :         if (objrec[0] != 0x02)

  0011f	b8 01 00 00 00	 mov	 eax, 1
  00124	48 6b c0 00	 imul	 rax, rax, 0
  00128	0f b6 44 04 50	 movzx	 eax, BYTE PTR objrec$[rsp+rax]
  0012d	83 f8 02	 cmp	 eax, 2
  00130	74 2f		 je	 SHORT $LN6@read_ipl_t

; 395  :         {
; 396  :             XMERRF ( MSG( HHC02507, "E", iplfnm ) );

  00132	4c 8b 84 24 e0
	01 00 00	 mov	 r8, QWORD PTR iplfnm$[rsp]
  0013a	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG160661
  00141	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG160662
  00148	e8 00 00 00 00	 call	 printf

; 397  :             close (tfd);

  0014d	8b 4c 24 34	 mov	 ecx, DWORD PTR tfd$[rsp]
  00151	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_close

; 398  :             return -1;

  00157	b8 ff ff ff ff	 mov	 eax, -1
  0015c	e9 a4 01 00 00	 jmp	 $LN1@read_ipl_t
$LN6@read_ipl_t:

; 399  :         }
; 400  : 
; 401  :         /* Exit if END card has been read */
; 402  :         if (memcmp(objrec+1, EBCDIC_END, 3) == 0)

  00161	48 8d 44 24 51	 lea	 rax, QWORD PTR objrec$[rsp+1]
  00166	41 b8 03 00 00
	00		 mov	 r8d, 3
  0016c	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG160664
  00173	48 8b c8	 mov	 rcx, rax
  00176	e8 00 00 00 00	 call	 memcmp
  0017b	85 c0		 test	 eax, eax
  0017d	75 05		 jne	 SHORT $LN7@read_ipl_t

; 403  :             break;

  0017f	e9 7d 01 00 00	 jmp	 $LN3@read_ipl_t
$LN7@read_ipl_t:

; 404  : 
; 405  :         /* Ignore any cards which are not TXT cards */
; 406  :         if (memcmp(objrec+1, EBCDIC_TXT, 3) != 0)

  00184	48 8d 44 24 51	 lea	 rax, QWORD PTR objrec$[rsp+1]
  00189	41 b8 03 00 00
	00		 mov	 r8d, 3
  0018f	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG160666
  00196	48 8b c8	 mov	 rcx, rax
  00199	e8 00 00 00 00	 call	 memcmp
  0019e	85 c0		 test	 eax, eax
  001a0	74 05		 je	 SHORT $LN8@read_ipl_t

; 407  :             continue;

  001a2	e9 04 ff ff ff	 jmp	 $LN2@read_ipl_t
$LN8@read_ipl_t:

; 408  : 
; 409  :         /* Load the address from TXT card columns 6-8 */
; 410  :         txtadr = (objrec[5] << 16) | (objrec[6] << 8) | objrec[7];

  001a7	b8 01 00 00 00	 mov	 eax, 1
  001ac	48 6b c0 05	 imul	 rax, rax, 5
  001b0	0f b6 44 04 50	 movzx	 eax, BYTE PTR objrec$[rsp+rax]
  001b5	c1 e0 10	 shl	 eax, 16
  001b8	b9 01 00 00 00	 mov	 ecx, 1
  001bd	48 6b c9 06	 imul	 rcx, rcx, 6
  001c1	0f b6 4c 0c 50	 movzx	 ecx, BYTE PTR objrec$[rsp+rcx]
  001c6	c1 e1 08	 shl	 ecx, 8
  001c9	0b c1		 or	 eax, ecx
  001cb	b9 01 00 00 00	 mov	 ecx, 1
  001d0	48 6b c9 07	 imul	 rcx, rcx, 7
  001d4	0f b6 4c 0c 50	 movzx	 ecx, BYTE PTR objrec$[rsp+rcx]
  001d9	0b c1		 or	 eax, ecx
  001db	89 44 24 38	 mov	 DWORD PTR txtadr$[rsp], eax

; 411  : 
; 412  :         /* Load the byte count from TXT card columns 11-12 */
; 413  :         txtlen = (objrec[10] << 8) | objrec[11];

  001df	b8 01 00 00 00	 mov	 eax, 1
  001e4	48 6b c0 0a	 imul	 rax, rax, 10
  001e8	0f b6 44 04 50	 movzx	 eax, BYTE PTR objrec$[rsp+rax]
  001ed	c1 e0 08	 shl	 eax, 8
  001f0	b9 01 00 00 00	 mov	 ecx, 1
  001f5	48 6b c9 0b	 imul	 rcx, rcx, 11
  001f9	0f b6 4c 0c 50	 movzx	 ecx, BYTE PTR objrec$[rsp+rcx]
  001fe	0b c1		 or	 eax, ecx
  00200	89 44 24 30	 mov	 DWORD PTR txtlen$[rsp], eax

; 414  : 
; 415  :         XMINFF (5, MSG( HHC02522, "I", txtadr, txtlen ) );

  00204	8b 44 24 30	 mov	 eax, DWORD PTR txtlen$[rsp]
  00208	89 44 24 20	 mov	 DWORD PTR [rsp+32], eax
  0020c	44 8b 4c 24 38	 mov	 r9d, DWORD PTR txtadr$[rsp]
  00211	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG160667
  00218	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG160668
  0021f	b9 05 00 00 00	 mov	 ecx, 5
  00224	e8 00 00 00 00	 call	 info_msg

; 416  : 
; 417  :         /* Check that the byte count is valid */
; 418  :         if (txtlen > 56)

  00229	83 7c 24 30 38	 cmp	 DWORD PTR txtlen$[rsp], 56 ; 00000038H
  0022e	7e 34		 jle	 SHORT $LN9@read_ipl_t

; 419  :         {
; 420  :             XMERRF ( MSG( HHC02508, "E", iplfnm, txtlen ) );

  00230	44 8b 4c 24 30	 mov	 r9d, DWORD PTR txtlen$[rsp]
  00235	4c 8b 84 24 e0
	01 00 00	 mov	 r8, QWORD PTR iplfnm$[rsp]
  0023d	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG160670
  00244	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG160671
  0024b	e8 00 00 00 00	 call	 printf

; 421  :             close (tfd);

  00250	8b 4c 24 34	 mov	 ecx, DWORD PTR tfd$[rsp]
  00254	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_close

; 422  :             return -1;

  0025a	b8 ff ff ff ff	 mov	 eax, -1
  0025f	e9 a1 00 00 00	 jmp	 $LN1@read_ipl_t
$LN9@read_ipl_t:

; 423  :         }
; 424  : 
; 425  :         /* Check that the text falls within the buffer */
; 426  :         if (txtadr + txtlen > buflen)

  00264	8b 44 24 30	 mov	 eax, DWORD PTR txtlen$[rsp]
  00268	8b 4c 24 38	 mov	 ecx, DWORD PTR txtadr$[rsp]
  0026c	03 c8		 add	 ecx, eax
  0026e	8b c1		 mov	 eax, ecx
  00270	3b 84 24 f0 01
	00 00		 cmp	 eax, DWORD PTR buflen$[rsp]
  00277	7e 34		 jle	 SHORT $LN10@read_ipl_t

; 427  :         {
; 428  :             XMERRF ( MSG( HHC02509, "E", iplfnm, buflen ) );

  00279	44 8b 8c 24 f0
	01 00 00	 mov	 r9d, DWORD PTR buflen$[rsp]
  00281	4c 8b 84 24 e0
	01 00 00	 mov	 r8, QWORD PTR iplfnm$[rsp]
  00289	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG160673
  00290	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG160674
  00297	e8 00 00 00 00	 call	 printf

; 429  :             close (tfd);

  0029c	8b 4c 24 34	 mov	 ecx, DWORD PTR tfd$[rsp]
  002a0	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_close

; 430  :             return -1;

  002a6	b8 ff ff ff ff	 mov	 eax, -1
  002ab	eb 58		 jmp	 SHORT $LN1@read_ipl_t
$LN10@read_ipl_t:

; 431  :         }
; 432  : 
; 433  :         /* Copy the IPL text to the buffer */
; 434  :         memcpy (iplbuf + txtadr, objrec+16, txtlen);

  002ad	48 63 44 24 30	 movsxd	 rax, DWORD PTR txtlen$[rsp]
  002b2	48 8d 4c 24 60	 lea	 rcx, QWORD PTR objrec$[rsp+16]
  002b7	48 63 4c 24 38	 movsxd	 rcx, DWORD PTR txtadr$[rsp]
  002bc	48 8b 94 24 e8
	01 00 00	 mov	 rdx, QWORD PTR iplbuf$[rsp]
  002c4	48 03 d1	 add	 rdx, rcx
  002c7	48 8b ca	 mov	 rcx, rdx
  002ca	48 8d 54 24 60	 lea	 rdx, QWORD PTR objrec$[rsp+16]
  002cf	48 8b f9	 mov	 rdi, rcx
  002d2	48 8b f2	 mov	 rsi, rdx
  002d5	48 8b c8	 mov	 rcx, rax
  002d8	f3 a4		 rep movsb

; 435  : 
; 436  :         /* Update the total size of the IPL text */
; 437  :         if (txtadr + txtlen > ipllen)

  002da	8b 44 24 30	 mov	 eax, DWORD PTR txtlen$[rsp]
  002de	8b 4c 24 38	 mov	 ecx, DWORD PTR txtadr$[rsp]
  002e2	03 c8		 add	 ecx, eax
  002e4	8b c1		 mov	 eax, ecx
  002e6	3b 44 24 3c	 cmp	 eax, DWORD PTR ipllen$[rsp]
  002ea	7e 10		 jle	 SHORT $LN11@read_ipl_t

; 438  :             ipllen = txtadr + txtlen;

  002ec	8b 44 24 30	 mov	 eax, DWORD PTR txtlen$[rsp]
  002f0	8b 4c 24 38	 mov	 ecx, DWORD PTR txtadr$[rsp]
  002f4	03 c8		 add	 ecx, eax
  002f6	8b c1		 mov	 eax, ecx
  002f8	89 44 24 3c	 mov	 DWORD PTR ipllen$[rsp], eax
$LN11@read_ipl_t:

; 439  : 
; 440  :     } /* end while */

  002fc	e9 aa fd ff ff	 jmp	 $LN13@read_ipl_t
$LN3@read_ipl_t:

; 441  : 
; 442  :     return ipllen;

  00301	8b 44 24 3c	 mov	 eax, DWORD PTR ipllen$[rsp]
$LN1@read_ipl_t:

; 443  : } /* end function read_ipl_text */

  00305	48 8b 8c 24 b0
	01 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  0030d	48 33 cc	 xor	 rcx, rsp
  00310	e8 00 00 00 00	 call	 __security_check_cookie
  00315	48 81 c4 c8 01
	00 00		 add	 rsp, 456		; 000001c8H
  0031c	5f		 pop	 rdi
  0031d	5e		 pop	 rsi
  0031e	c3		 ret	 0
read_ipl_text ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\dasdload64.c
_TEXT	SEGMENT
i$ = 32
track$ = 36
cyl$ = 64
head$ = 72
heads$ = 80
numext$ = 88
xarray$ = 96
calculate_ttr PROC

; 315  : {

  00000	44 89 4c 24 20	 mov	 DWORD PTR [rsp+32], r9d
  00005	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  0000a	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  0000e	89 4c 24 08	 mov	 DWORD PTR [rsp+8], ecx
  00012	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 316  : int     i;                              /* Array subscript           */
; 317  : int     track;                          /* Relative track number     */
; 318  : 
; 319  :     /* Search the extent descriptor array */
; 320  :     for (i = 0, track = 0; i < numext; track += xarray[i++].ntrk)

  00016	c7 44 24 20 00
	00 00 00	 mov	 DWORD PTR i$[rsp], 0
  0001e	c7 44 24 24 00
	00 00 00	 mov	 DWORD PTR track$[rsp], 0
  00026	eb 29		 jmp	 SHORT $LN4@calculate_
$LN2@calculate_:
  00028	48 63 44 24 20	 movsxd	 rax, DWORD PTR i$[rsp]
  0002d	48 6b c0 0a	 imul	 rax, rax, 10
  00031	48 8b 4c 24 60	 mov	 rcx, QWORD PTR xarray$[rsp]
  00036	0f b7 44 01 08	 movzx	 eax, WORD PTR [rcx+rax+8]
  0003b	8b 4c 24 24	 mov	 ecx, DWORD PTR track$[rsp]
  0003f	03 c8		 add	 ecx, eax
  00041	8b c1		 mov	 eax, ecx
  00043	89 44 24 24	 mov	 DWORD PTR track$[rsp], eax
  00047	8b 44 24 20	 mov	 eax, DWORD PTR i$[rsp]
  0004b	ff c0		 inc	 eax
  0004d	89 44 24 20	 mov	 DWORD PTR i$[rsp], eax
$LN4@calculate_:
  00051	8b 44 24 58	 mov	 eax, DWORD PTR numext$[rsp]
  00055	39 44 24 20	 cmp	 DWORD PTR i$[rsp], eax
  00059	0f 8d eb 00 00
	00		 jge	 $LN3@calculate_

; 321  :     {
; 322  :         if (cyl < xarray[i].bcyl || cyl > xarray[i].ecyl)

  0005f	48 63 44 24 20	 movsxd	 rax, DWORD PTR i$[rsp]
  00064	48 6b c0 0a	 imul	 rax, rax, 10
  00068	48 8b 4c 24 60	 mov	 rcx, QWORD PTR xarray$[rsp]
  0006d	0f b7 04 01	 movzx	 eax, WORD PTR [rcx+rax]
  00071	39 44 24 40	 cmp	 DWORD PTR cyl$[rsp], eax
  00075	7c 19		 jl	 SHORT $LN6@calculate_
  00077	48 63 44 24 20	 movsxd	 rax, DWORD PTR i$[rsp]
  0007c	48 6b c0 0a	 imul	 rax, rax, 10
  00080	48 8b 4c 24 60	 mov	 rcx, QWORD PTR xarray$[rsp]
  00085	0f b7 44 01 04	 movzx	 eax, WORD PTR [rcx+rax+4]
  0008a	39 44 24 40	 cmp	 DWORD PTR cyl$[rsp], eax
  0008e	7e 02		 jle	 SHORT $LN5@calculate_
$LN6@calculate_:

; 323  :             continue;

  00090	eb 96		 jmp	 SHORT $LN2@calculate_
$LN5@calculate_:

; 324  : 
; 325  :         if (cyl == xarray[i].bcyl && head < xarray[i].btrk)

  00092	48 63 44 24 20	 movsxd	 rax, DWORD PTR i$[rsp]
  00097	48 6b c0 0a	 imul	 rax, rax, 10
  0009b	48 8b 4c 24 60	 mov	 rcx, QWORD PTR xarray$[rsp]
  000a0	0f b7 04 01	 movzx	 eax, WORD PTR [rcx+rax]
  000a4	39 44 24 40	 cmp	 DWORD PTR cyl$[rsp], eax
  000a8	75 1e		 jne	 SHORT $LN7@calculate_
  000aa	48 63 44 24 20	 movsxd	 rax, DWORD PTR i$[rsp]
  000af	48 6b c0 0a	 imul	 rax, rax, 10
  000b3	48 8b 4c 24 60	 mov	 rcx, QWORD PTR xarray$[rsp]
  000b8	0f b7 44 01 02	 movzx	 eax, WORD PTR [rcx+rax+2]
  000bd	39 44 24 48	 cmp	 DWORD PTR head$[rsp], eax
  000c1	7d 05		 jge	 SHORT $LN7@calculate_

; 326  :             continue;

  000c3	e9 60 ff ff ff	 jmp	 $LN2@calculate_
$LN7@calculate_:

; 327  : 
; 328  :         if (cyl == xarray[i].ecyl && head > xarray[i].etrk)

  000c8	48 63 44 24 20	 movsxd	 rax, DWORD PTR i$[rsp]
  000cd	48 6b c0 0a	 imul	 rax, rax, 10
  000d1	48 8b 4c 24 60	 mov	 rcx, QWORD PTR xarray$[rsp]
  000d6	0f b7 44 01 04	 movzx	 eax, WORD PTR [rcx+rax+4]
  000db	39 44 24 40	 cmp	 DWORD PTR cyl$[rsp], eax
  000df	75 1e		 jne	 SHORT $LN8@calculate_
  000e1	48 63 44 24 20	 movsxd	 rax, DWORD PTR i$[rsp]
  000e6	48 6b c0 0a	 imul	 rax, rax, 10
  000ea	48 8b 4c 24 60	 mov	 rcx, QWORD PTR xarray$[rsp]
  000ef	0f b7 44 01 06	 movzx	 eax, WORD PTR [rcx+rax+6]
  000f4	39 44 24 48	 cmp	 DWORD PTR head$[rsp], eax
  000f8	7e 05		 jle	 SHORT $LN8@calculate_

; 329  :             continue;

  000fa	e9 29 ff ff ff	 jmp	 $LN2@calculate_
$LN8@calculate_:

; 330  : 
; 331  :         track += (cyl - xarray[i].bcyl) * heads

  000ff	48 63 44 24 20	 movsxd	 rax, DWORD PTR i$[rsp]
  00104	48 6b c0 0a	 imul	 rax, rax, 10
  00108	48 8b 4c 24 60	 mov	 rcx, QWORD PTR xarray$[rsp]
  0010d	0f b7 04 01	 movzx	 eax, WORD PTR [rcx+rax]
  00111	8b 4c 24 40	 mov	 ecx, DWORD PTR cyl$[rsp]
  00115	2b c8		 sub	 ecx, eax
  00117	8b c1		 mov	 eax, ecx
  00119	0f af 44 24 50	 imul	 eax, DWORD PTR heads$[rsp]
  0011e	48 63 4c 24 20	 movsxd	 rcx, DWORD PTR i$[rsp]
  00123	48 6b c9 0a	 imul	 rcx, rcx, 10
  00127	48 8b 54 24 60	 mov	 rdx, QWORD PTR xarray$[rsp]
  0012c	0f b7 4c 0a 02	 movzx	 ecx, WORD PTR [rdx+rcx+2]
  00131	2b c1		 sub	 eax, ecx
  00133	03 44 24 48	 add	 eax, DWORD PTR head$[rsp]
  00137	8b 4c 24 24	 mov	 ecx, DWORD PTR track$[rsp]
  0013b	03 c8		 add	 ecx, eax
  0013d	8b c1		 mov	 eax, ecx
  0013f	89 44 24 24	 mov	 DWORD PTR track$[rsp], eax

; 332  :                 - xarray[i].btrk + head;
; 333  :         break;

  00143	eb 05		 jmp	 SHORT $LN3@calculate_

; 334  :     } /* end for(i) */

  00145	e9 de fe ff ff	 jmp	 $LN2@calculate_
$LN3@calculate_:

; 335  : 
; 336  :     /* Error if track was not found in extent table */
; 337  :     if (i == numext)

  0014a	8b 44 24 58	 mov	 eax, DWORD PTR numext$[rsp]
  0014e	39 44 24 20	 cmp	 DWORD PTR i$[rsp], eax
  00152	75 24		 jne	 SHORT $LN9@calculate_

; 338  :     {
; 339  :         XMERRF ( MSG( HHC02505, "E", cyl, head ) );

  00154	44 8b 4c 24 48	 mov	 r9d, DWORD PTR head$[rsp]
  00159	44 8b 44 24 40	 mov	 r8d, DWORD PTR cyl$[rsp]
  0015e	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG160633
  00165	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG160634
  0016c	e8 00 00 00 00	 call	 printf

; 340  :         return -1;

  00171	b8 ff ff ff ff	 mov	 eax, -1
  00176	eb 04		 jmp	 SHORT $LN1@calculate_
$LN9@calculate_:

; 341  :     }
; 342  : 
; 343  :     /* Return relative track number */
; 344  :     return track;

  00178	8b 44 24 24	 mov	 eax, DWORD PTR track$[rsp]
$LN1@calculate_:

; 345  : } /* end function calculate_ttr */

  0017c	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00180	c3		 ret	 0
calculate_ttr ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\dasdload64.c
_TEXT	SEGMENT
tv65 = 0
devtype$ = 32
ucbtype_code PROC

; 278  : {

  00000	66 89 4c 24 08	 mov	 WORD PTR [rsp+8], cx
  00005	48 83 ec 18	 sub	 rsp, 24

; 279  :     switch (devtype) {

  00009	0f b7 44 24 20	 movzx	 eax, WORD PTR devtype$[rsp]
  0000e	89 04 24	 mov	 DWORD PTR tv65[rsp], eax
  00011	81 3c 24 30 33
	00 00		 cmp	 DWORD PTR tv65[rsp], 13104 ; 00003330H
  00018	7f 41		 jg	 SHORT $LN19@ucbtype_co
  0001a	81 3c 24 30 33
	00 00		 cmp	 DWORD PTR tv65[rsp], 13104 ; 00003330H
  00021	0f 84 a8 00 00
	00		 je	 $LN11@ucbtype_co
  00027	8b 04 24	 mov	 eax, DWORD PTR tv65[rsp]
  0002a	2d 01 23 00 00	 sub	 eax, 8961		; 00002301H
  0002f	89 04 24	 mov	 DWORD PTR tv65[rsp], eax
  00032	83 3c 24 20	 cmp	 DWORD PTR tv65[rsp], 32	; 00000020H
  00036	0f 87 c4 00 00
	00		 ja	 $LN2@ucbtype_co
  0003c	48 63 04 24	 movsxd	 rax, DWORD PTR tv65[rsp]
  00040	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__ImageBase
  00047	0f b6 84 01 00
	00 00 00	 movzx	 eax, BYTE PTR $LN21@ucbtype_co[rcx+rax]
  0004f	8b 84 81 00 00
	00 00		 mov	 eax, DWORD PTR $LN22@ucbtype_co[rcx+rax*4]
  00056	48 03 c1	 add	 rax, rcx
  00059	ff e0		 jmp	 rax
$LN19@ucbtype_co:
  0005b	81 3c 24 80 33
	00 00		 cmp	 DWORD PTR tv65[rsp], 13184 ; 00003380H
  00062	7f 26		 jg	 SHORT $LN20@ucbtype_co
  00064	81 3c 24 80 33
	00 00		 cmp	 DWORD PTR tv65[rsp], 13184 ; 00003380H
  0006b	74 7e		 je	 SHORT $LN15@ucbtype_co
  0006d	81 3c 24 40 33
	00 00		 cmp	 DWORD PTR tv65[rsp], 13120 ; 00003340H
  00074	74 60		 je	 SHORT $LN12@ucbtype_co
  00076	81 3c 24 50 33
	00 00		 cmp	 DWORD PTR tv65[rsp], 13136 ; 00003350H
  0007d	74 5e		 je	 SHORT $LN13@ucbtype_co
  0007f	81 3c 24 75 33
	00 00		 cmp	 DWORD PTR tv65[rsp], 13173 ; 00003375H
  00086	74 5c		 je	 SHORT $LN14@ucbtype_co
  00088	eb 76		 jmp	 SHORT $LN2@ucbtype_co
$LN20@ucbtype_co:
  0008a	81 3c 24 90 33
	00 00		 cmp	 DWORD PTR tv65[rsp], 13200 ; 00003390H
  00091	74 5f		 je	 SHORT $LN16@ucbtype_co
  00093	81 3c 24 45 93
	00 00		 cmp	 DWORD PTR tv65[rsp], 37701 ; 00009345H
  0009a	74 5d		 je	 SHORT $LN17@ucbtype_co
  0009c	eb 62		 jmp	 SHORT $LN2@ucbtype_co
$LN4@ucbtype_co:

; 280  :     case 0x2311: return 0x30002001;

  0009e	b8 01 20 00 30	 mov	 eax, 805314561		; 30002001H
  000a3	eb 5d		 jmp	 SHORT $LN1@ucbtype_co
$LN5@ucbtype_co:

; 281  :     case 0x2301: return 0x30402002;

  000a5	b8 02 20 40 30	 mov	 eax, 809508866		; 30402002H
  000aa	eb 56		 jmp	 SHORT $LN1@ucbtype_co
$LN6@ucbtype_co:

; 282  :     case 0x2303: return 0x30002003;

  000ac	b8 03 20 00 30	 mov	 eax, 805314563		; 30002003H
  000b1	eb 4f		 jmp	 SHORT $LN1@ucbtype_co
$LN7@ucbtype_co:

; 283  :     case 0x2302: return 0x30002004;

  000b3	b8 04 20 00 30	 mov	 eax, 805314564		; 30002004H
  000b8	eb 48		 jmp	 SHORT $LN1@ucbtype_co
$LN8@ucbtype_co:

; 284  :     case 0x2321: return 0x30002005;

  000ba	b8 05 20 00 30	 mov	 eax, 805314565		; 30002005H
  000bf	eb 41		 jmp	 SHORT $LN1@ucbtype_co
$LN9@ucbtype_co:

; 285  :     case 0x2305: return 0x30002006;

  000c1	b8 06 20 00 30	 mov	 eax, 805314566		; 30002006H
  000c6	eb 3a		 jmp	 SHORT $LN1@ucbtype_co
$LN10@ucbtype_co:

; 286  :     case 0x2314: return 0x30C02008;

  000c8	b8 08 20 c0 30	 mov	 eax, 817897480		; 30c02008H
  000cd	eb 33		 jmp	 SHORT $LN1@ucbtype_co
$LN11@ucbtype_co:

; 287  :     case 0x3330: return 0x30502009;

  000cf	b8 09 20 50 30	 mov	 eax, 810557449		; 30502009H
  000d4	eb 2c		 jmp	 SHORT $LN1@ucbtype_co
$LN12@ucbtype_co:

; 288  :     case 0x3340: return 0x3050200A;

  000d6	b8 0a 20 50 30	 mov	 eax, 810557450		; 3050200aH
  000db	eb 25		 jmp	 SHORT $LN1@ucbtype_co
$LN13@ucbtype_co:

; 289  :     case 0x3350: return 0x3050200B;

  000dd	b8 0b 20 50 30	 mov	 eax, 810557451		; 3050200bH
  000e2	eb 1e		 jmp	 SHORT $LN1@ucbtype_co
$LN14@ucbtype_co:

; 290  :     case 0x3375: return 0x3050200C;

  000e4	b8 0c 20 50 30	 mov	 eax, 810557452		; 3050200cH
  000e9	eb 17		 jmp	 SHORT $LN1@ucbtype_co
$LN15@ucbtype_co:

; 291  :     case 0x3380: return 0x3050200E;

  000eb	b8 0e 20 50 30	 mov	 eax, 810557454		; 3050200eH
  000f0	eb 10		 jmp	 SHORT $LN1@ucbtype_co
$LN16@ucbtype_co:

; 292  :     case 0x3390: return 0x3050200F;

  000f2	b8 0f 20 50 30	 mov	 eax, 810557455		; 3050200fH
  000f7	eb 09		 jmp	 SHORT $LN1@ucbtype_co
$LN17@ucbtype_co:

; 293  :     case 0x9345: return 0x30502004;

  000f9	b8 04 20 50 30	 mov	 eax, 810557444		; 30502004H
  000fe	eb 02		 jmp	 SHORT $LN1@ucbtype_co
$LN2@ucbtype_co:

; 294  :     } /* end switch(key) */
; 295  : 
; 296  :     return 0;

  00100	33 c0		 xor	 eax, eax
$LN1@ucbtype_co:

; 297  : 
; 298  : } /* end function ucbtype_code */

  00102	48 83 c4 18	 add	 rsp, 24
  00106	c3		 ret	 0
  00107	90		 npad	 1
$LN22@ucbtype_co:
  00108	00 00 00 00	 DD	 $LN5@ucbtype_co
  0010c	00 00 00 00	 DD	 $LN7@ucbtype_co
  00110	00 00 00 00	 DD	 $LN6@ucbtype_co
  00114	00 00 00 00	 DD	 $LN9@ucbtype_co
  00118	00 00 00 00	 DD	 $LN4@ucbtype_co
  0011c	00 00 00 00	 DD	 $LN10@ucbtype_co
  00120	00 00 00 00	 DD	 $LN8@ucbtype_co
  00124	00 00 00 00	 DD	 $LN2@ucbtype_co
$LN21@ucbtype_co:
  00128	00		 DB	 0
  00129	01		 DB	 1
  0012a	02		 DB	 2
  0012b	07		 DB	 7
  0012c	03		 DB	 3
  0012d	07		 DB	 7
  0012e	07		 DB	 7
  0012f	07		 DB	 7
  00130	07		 DB	 7
  00131	07		 DB	 7
  00132	07		 DB	 7
  00133	07		 DB	 7
  00134	07		 DB	 7
  00135	07		 DB	 7
  00136	07		 DB	 7
  00137	07		 DB	 7
  00138	04		 DB	 4
  00139	07		 DB	 7
  0013a	07		 DB	 7
  0013b	05		 DB	 5
  0013c	07		 DB	 7
  0013d	07		 DB	 7
  0013e	07		 DB	 7
  0013f	07		 DB	 7
  00140	07		 DB	 7
  00141	07		 DB	 7
  00142	07		 DB	 7
  00143	07		 DB	 7
  00144	07		 DB	 7
  00145	07		 DB	 7
  00146	07		 DB	 7
  00147	07		 DB	 7
  00148	06		 DB	 6
ucbtype_code ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\dasdload64.c
_TEXT	SEGMENT
tv71 = 0
ucbtype$ = 32
dasd_name PROC

; 247  : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 18	 sub	 rsp, 24

; 248  :     if (ucbtype[2] != 0x20) return "????";

  00009	b8 01 00 00 00	 mov	 eax, 1
  0000e	48 6b c0 02	 imul	 rax, rax, 2
  00012	48 8b 4c 24 20	 mov	 rcx, QWORD PTR ucbtype$[rsp]
  00017	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  0001b	83 f8 20	 cmp	 eax, 32			; 00000020H
  0001e	74 0c		 je	 SHORT $LN4@dasd_name
  00020	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG160556
  00027	e9 f6 00 00 00	 jmp	 $LN1@dasd_name
$LN4@dasd_name:

; 249  : 
; 250  :     switch (ucbtype[3]) {

  0002c	b8 01 00 00 00	 mov	 eax, 1
  00031	48 6b c0 03	 imul	 rax, rax, 3
  00035	48 8b 4c 24 20	 mov	 rcx, QWORD PTR ucbtype$[rsp]
  0003a	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  0003e	89 04 24	 mov	 DWORD PTR tv71[rsp], eax
  00041	8b 04 24	 mov	 eax, DWORD PTR tv71[rsp]
  00044	ff c8		 dec	 eax
  00046	89 04 24	 mov	 DWORD PTR tv71[rsp], eax
  00049	83 3c 24 0e	 cmp	 DWORD PTR tv71[rsp], 14
  0004d	0f 87 c8 00 00
	00		 ja	 $LN2@dasd_name
  00053	48 63 04 24	 movsxd	 rax, DWORD PTR tv71[rsp]
  00057	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__ImageBase
  0005e	8b 84 81 00 00
	00 00		 mov	 eax, DWORD PTR $LN23@dasd_name[rcx+rax*4]
  00065	48 03 c1	 add	 rax, rcx
  00068	ff e0		 jmp	 rax
$LN5@dasd_name:

; 251  :     case 0x01: return "2311";

  0006a	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG160558
  00071	e9 ac 00 00 00	 jmp	 $LN1@dasd_name
$LN6@dasd_name:

; 252  :     case 0x02: return "2301";

  00076	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG160560
  0007d	e9 a0 00 00 00	 jmp	 $LN1@dasd_name
$LN7@dasd_name:

; 253  :     case 0x03: return "2303";

  00082	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG160562
  00089	e9 94 00 00 00	 jmp	 $LN1@dasd_name
$LN8@dasd_name:

; 254  :     case 0x04: if (ucbtype[1] == 0x00) return "2302";

  0008e	b8 01 00 00 00	 mov	 eax, 1
  00093	48 6b c0 01	 imul	 rax, rax, 1
  00097	48 8b 4c 24 20	 mov	 rcx, QWORD PTR ucbtype$[rsp]
  0009c	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  000a0	85 c0		 test	 eax, eax
  000a2	75 0b		 jne	 SHORT $LN9@dasd_name
  000a4	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG160566
  000ab	eb 75		 jmp	 SHORT $LN1@dasd_name
  000ad	eb 09		 jmp	 SHORT $LN10@dasd_name
$LN9@dasd_name:

; 255  :                else return "9345";

  000af	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG160567
  000b6	eb 6a		 jmp	 SHORT $LN1@dasd_name
$LN10@dasd_name:
$LN11@dasd_name:

; 256  :     case 0x05: return "2321";

  000b8	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG160569
  000bf	eb 61		 jmp	 SHORT $LN1@dasd_name
$LN12@dasd_name:

; 257  :     case 0x06: return "2305-1";

  000c1	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG160571
  000c8	eb 58		 jmp	 SHORT $LN1@dasd_name
$LN13@dasd_name:

; 258  :     case 0x07: return "2305-2";

  000ca	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG160573
  000d1	eb 4f		 jmp	 SHORT $LN1@dasd_name
$LN14@dasd_name:

; 259  :     case 0x08: return "2314";

  000d3	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG160575
  000da	eb 46		 jmp	 SHORT $LN1@dasd_name
$LN15@dasd_name:

; 260  :     case 0x09: return "3330";

  000dc	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG160577
  000e3	eb 3d		 jmp	 SHORT $LN1@dasd_name
$LN16@dasd_name:

; 261  :     case 0x0A: return "3340";

  000e5	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG160579
  000ec	eb 34		 jmp	 SHORT $LN1@dasd_name
$LN17@dasd_name:

; 262  :     case 0x0B: return "3350";

  000ee	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG160581
  000f5	eb 2b		 jmp	 SHORT $LN1@dasd_name
$LN18@dasd_name:

; 263  :     case 0x0C: return "3375";

  000f7	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG160583
  000fe	eb 22		 jmp	 SHORT $LN1@dasd_name
$LN19@dasd_name:

; 264  :     case 0x0D: return "3330-11";

  00100	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG160585
  00107	eb 19		 jmp	 SHORT $LN1@dasd_name
$LN20@dasd_name:

; 265  :     case 0x0E: return "3380";

  00109	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG160587
  00110	eb 10		 jmp	 SHORT $LN1@dasd_name
$LN21@dasd_name:

; 266  :     case 0x0F: return "3390";

  00112	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG160589
  00119	eb 07		 jmp	 SHORT $LN1@dasd_name
$LN2@dasd_name:

; 267  :     } /* end switch(key) */
; 268  : 
; 269  :     return "????";

  0011b	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG160590
$LN1@dasd_name:

; 270  : 
; 271  : } /* end function dasd_name */

  00122	48 83 c4 18	 add	 rsp, 24
  00126	c3		 ret	 0
  00127	90		 npad	 1
$LN23@dasd_name:
  00128	00 00 00 00	 DD	 $LN5@dasd_name
  0012c	00 00 00 00	 DD	 $LN6@dasd_name
  00130	00 00 00 00	 DD	 $LN7@dasd_name
  00134	00 00 00 00	 DD	 $LN8@dasd_name
  00138	00 00 00 00	 DD	 $LN11@dasd_name
  0013c	00 00 00 00	 DD	 $LN12@dasd_name
  00140	00 00 00 00	 DD	 $LN13@dasd_name
  00144	00 00 00 00	 DD	 $LN14@dasd_name
  00148	00 00 00 00	 DD	 $LN15@dasd_name
  0014c	00 00 00 00	 DD	 $LN16@dasd_name
  00150	00 00 00 00	 DD	 $LN17@dasd_name
  00154	00 00 00 00	 DD	 $LN18@dasd_name
  00158	00 00 00 00	 DD	 $LN19@dasd_name
  0015c	00 00 00 00	 DD	 $LN20@dasd_name
  00160	00 00 00 00	 DD	 $LN21@dasd_name
dasd_name ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\dasdload64.c
_TEXT	SEGMENT
tv68 = 32
tv140 = 36
recfm$ = 64
recfm_name PROC

; 214  : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 215  : static char     name[8];                /* Name of record format     */
; 216  : 
; 217  :     switch (recfm[0] & RECFM_FORMAT) {

  00009	b8 01 00 00 00	 mov	 eax, 1
  0000e	48 6b c0 00	 imul	 rax, rax, 0
  00012	48 8b 4c 24 40	 mov	 rcx, QWORD PTR recfm$[rsp]
  00017	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  0001b	25 c0 00 00 00	 and	 eax, 192		; 000000c0H
  00020	89 44 24 20	 mov	 DWORD PTR tv68[rsp], eax
  00024	83 7c 24 20 40	 cmp	 DWORD PTR tv68[rsp], 64	; 00000040H
  00029	74 16		 je	 SHORT $LN6@recfm_name
  0002b	81 7c 24 20 80
	00 00 00	 cmp	 DWORD PTR tv68[rsp], 128 ; 00000080H
  00033	74 21		 je	 SHORT $LN7@recfm_name
  00035	81 7c 24 20 c0
	00 00 00	 cmp	 DWORD PTR tv68[rsp], 192 ; 000000c0H
  0003d	74 2c		 je	 SHORT $LN8@recfm_name
  0003f	eb 3f		 jmp	 SHORT $LN9@recfm_name
$LN6@recfm_name:

; 218  :     case RECFM_FORMAT_V:
; 219  :         strcpy (name, "V"); break;

  00041	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG160532
  00048	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:?name@?1??recfm_name@@9@9
  0004f	e8 00 00 00 00	 call	 strcpy
  00054	eb 3d		 jmp	 SHORT $LN2@recfm_name
$LN7@recfm_name:

; 220  :     case RECFM_FORMAT_F:
; 221  :         strcpy (name, "F"); break;

  00056	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG160534
  0005d	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:?name@?1??recfm_name@@9@9
  00064	e8 00 00 00 00	 call	 strcpy
  00069	eb 28		 jmp	 SHORT $LN2@recfm_name
$LN8@recfm_name:

; 222  :     case RECFM_FORMAT_U:
; 223  :         strcpy (name, "U"); break;

  0006b	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG160536
  00072	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:?name@?1??recfm_name@@9@9
  00079	e8 00 00 00 00	 call	 strcpy
  0007e	eb 13		 jmp	 SHORT $LN2@recfm_name
$LN9@recfm_name:

; 224  :     default:
; 225  :         strcpy (name,"??");

  00080	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG160538
  00087	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:?name@?1??recfm_name@@9@9
  0008e	e8 00 00 00 00	 call	 strcpy
$LN2@recfm_name:

; 226  :     } /* end switch */
; 227  : 
; 228  :     if (recfm[0] & RECFM_TRKOFLOW) STRLCAT( name, "T" );

  00093	b8 01 00 00 00	 mov	 eax, 1
  00098	48 6b c0 00	 imul	 rax, rax, 0
  0009c	48 8b 4c 24 40	 mov	 rcx, QWORD PTR recfm$[rsp]
  000a1	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  000a5	83 e0 20	 and	 eax, 32			; 00000020H
  000a8	85 c0		 test	 eax, eax
  000aa	74 1a		 je	 SHORT $LN10@recfm_name
  000ac	41 b8 08 00 00
	00		 mov	 r8d, 8
  000b2	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG160540
  000b9	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:?name@?1??recfm_name@@9@9
  000c0	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_strlcat
$LN10@recfm_name:

; 229  :     if (recfm[0] & RECFM_BLOCKED)  STRLCAT( name, "B" );

  000c6	b8 01 00 00 00	 mov	 eax, 1
  000cb	48 6b c0 00	 imul	 rax, rax, 0
  000cf	48 8b 4c 24 40	 mov	 rcx, QWORD PTR recfm$[rsp]
  000d4	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  000d8	83 e0 10	 and	 eax, 16
  000db	85 c0		 test	 eax, eax
  000dd	74 1a		 je	 SHORT $LN11@recfm_name
  000df	41 b8 08 00 00
	00		 mov	 r8d, 8
  000e5	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG160542
  000ec	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:?name@?1??recfm_name@@9@9
  000f3	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_strlcat
$LN11@recfm_name:

; 230  :     if (recfm[0] & RECFM_SPANNED)  STRLCAT( name, "S" );

  000f9	b8 01 00 00 00	 mov	 eax, 1
  000fe	48 6b c0 00	 imul	 rax, rax, 0
  00102	48 8b 4c 24 40	 mov	 rcx, QWORD PTR recfm$[rsp]
  00107	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  0010b	83 e0 08	 and	 eax, 8
  0010e	85 c0		 test	 eax, eax
  00110	74 1a		 je	 SHORT $LN12@recfm_name
  00112	41 b8 08 00 00
	00		 mov	 r8d, 8
  00118	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG160544
  0011f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:?name@?1??recfm_name@@9@9
  00126	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_strlcat
$LN12@recfm_name:

; 231  : 
; 232  :     switch (recfm[0] & RECFM_CTLCHAR) {

  0012c	b8 01 00 00 00	 mov	 eax, 1
  00131	48 6b c0 00	 imul	 rax, rax, 0
  00135	48 8b 4c 24 40	 mov	 rcx, QWORD PTR recfm$[rsp]
  0013a	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  0013e	83 e0 06	 and	 eax, 6
  00141	89 44 24 24	 mov	 DWORD PTR tv140[rsp], eax
  00145	83 7c 24 24 02	 cmp	 DWORD PTR tv140[rsp], 2
  0014a	74 1e		 je	 SHORT $LN14@recfm_name
  0014c	83 7c 24 24 04	 cmp	 DWORD PTR tv140[rsp], 4
  00151	74 02		 je	 SHORT $LN13@recfm_name
  00153	eb 28		 jmp	 SHORT $LN4@recfm_name
$LN13@recfm_name:

; 233  :     case RECFM_CTLCHAR_A:
; 234  :         strcpy (name, "A"); break;

  00155	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG160546
  0015c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:?name@?1??recfm_name@@9@9
  00163	e8 00 00 00 00	 call	 strcpy
  00168	eb 13		 jmp	 SHORT $LN4@recfm_name
$LN14@recfm_name:

; 235  :     case RECFM_CTLCHAR_M:
; 236  :         strcpy (name, "M"); break;

  0016a	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG160548
  00171	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:?name@?1??recfm_name@@9@9
  00178	e8 00 00 00 00	 call	 strcpy
$LN4@recfm_name:

; 237  :     } /* end switch */
; 238  : 
; 239  :     return name;

  0017d	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:?name@?1??recfm_name@@9@9

; 240  : } /* end function recfm_name */

  00184	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00188	c3		 ret	 0
recfm_name ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\dasdload64.c
_TEXT	SEGMENT
dsorg$ = 48
dsorg_name PROC

; 192  : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 193  : static char     name[8];                /* Name of dsorg             */
; 194  : 
; 195  :     if (dsorg[0] & DSORG_IS)

  00009	b8 01 00 00 00	 mov	 eax, 1
  0000e	48 6b c0 00	 imul	 rax, rax, 0
  00012	48 8b 4c 24 30	 mov	 rcx, QWORD PTR dsorg$[rsp]
  00017	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  0001b	25 80 00 00 00	 and	 eax, 128		; 00000080H
  00020	85 c0		 test	 eax, eax
  00022	74 18		 je	 SHORT $LN2@dsorg_name

; 196  :         strcpy (name, "IS");

  00024	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG160510
  0002b	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:?name@?1??dsorg_name@@9@9
  00032	e8 00 00 00 00	 call	 strcpy
  00037	e9 88 00 00 00	 jmp	 $LN3@dsorg_name
$LN2@dsorg_name:

; 197  :     else if (dsorg[0] & DSORG_PS)

  0003c	b8 01 00 00 00	 mov	 eax, 1
  00041	48 6b c0 00	 imul	 rax, rax, 0
  00045	48 8b 4c 24 30	 mov	 rcx, QWORD PTR dsorg$[rsp]
  0004a	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  0004e	83 e0 40	 and	 eax, 64			; 00000040H
  00051	85 c0		 test	 eax, eax
  00053	74 15		 je	 SHORT $LN4@dsorg_name

; 198  :         strcpy (name, "PS");

  00055	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG160513
  0005c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:?name@?1??dsorg_name@@9@9
  00063	e8 00 00 00 00	 call	 strcpy
  00068	eb 5a		 jmp	 SHORT $LN5@dsorg_name
$LN4@dsorg_name:

; 199  :     else if (dsorg[0] & DSORG_DA)

  0006a	b8 01 00 00 00	 mov	 eax, 1
  0006f	48 6b c0 00	 imul	 rax, rax, 0
  00073	48 8b 4c 24 30	 mov	 rcx, QWORD PTR dsorg$[rsp]
  00078	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  0007c	83 e0 20	 and	 eax, 32			; 00000020H
  0007f	85 c0		 test	 eax, eax
  00081	74 15		 je	 SHORT $LN6@dsorg_name

; 200  :         strcpy (name, "DA");

  00083	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG160516
  0008a	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:?name@?1??dsorg_name@@9@9
  00091	e8 00 00 00 00	 call	 strcpy
  00096	eb 2c		 jmp	 SHORT $LN7@dsorg_name
$LN6@dsorg_name:

; 201  :     else if (dsorg[0] & DSORG_PO)

  00098	b8 01 00 00 00	 mov	 eax, 1
  0009d	48 6b c0 00	 imul	 rax, rax, 0
  000a1	48 8b 4c 24 30	 mov	 rcx, QWORD PTR dsorg$[rsp]
  000a6	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  000aa	83 e0 02	 and	 eax, 2
  000ad	85 c0		 test	 eax, eax
  000af	74 13		 je	 SHORT $LN8@dsorg_name

; 202  :         strcpy (name, "PO");

  000b1	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG160518
  000b8	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:?name@?1??dsorg_name@@9@9
  000bf	e8 00 00 00 00	 call	 strcpy
$LN8@dsorg_name:
$LN7@dsorg_name:
$LN5@dsorg_name:
$LN3@dsorg_name:

; 203  : 
; 204  :     if (dsorg[0] & DSORG_U) STRLCAT( name, "U" );

  000c4	b8 01 00 00 00	 mov	 eax, 1
  000c9	48 6b c0 00	 imul	 rax, rax, 0
  000cd	48 8b 4c 24 30	 mov	 rcx, QWORD PTR dsorg$[rsp]
  000d2	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  000d6	83 e0 01	 and	 eax, 1
  000d9	85 c0		 test	 eax, eax
  000db	74 1a		 je	 SHORT $LN9@dsorg_name
  000dd	41 b8 08 00 00
	00		 mov	 r8d, 8
  000e3	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG160520
  000ea	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:?name@?1??dsorg_name@@9@9
  000f1	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_strlcat
$LN9@dsorg_name:

; 205  : 
; 206  :     return name;

  000f7	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:?name@?1??dsorg_name@@9@9

; 207  : } /* end function dsorg_name */

  000fe	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00102	c3		 ret	 0
dsorg_name ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\dasdload64.c
_TEXT	SEGMENT
result$ = 0
i$ = 4
src$ = 32
srclen$ = 40
make_int PROC

; 173  : {

  00000	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00004	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00009	48 83 ec 18	 sub	 rsp, 24

; 174  : int             result = 0;             /* Result accumulator        */

  0000d	c7 04 24 00 00
	00 00		 mov	 DWORD PTR result$[rsp], 0

; 175  : int             i;                      /* Array subscript           */
; 176  : 
; 177  :     for (i=0; i < srclen; i++)

  00014	c7 44 24 04 00
	00 00 00	 mov	 DWORD PTR i$[rsp], 0
  0001c	eb 0a		 jmp	 SHORT $LN4@make_int
$LN2@make_int:
  0001e	8b 44 24 04	 mov	 eax, DWORD PTR i$[rsp]
  00022	ff c0		 inc	 eax
  00024	89 44 24 04	 mov	 DWORD PTR i$[rsp], eax
$LN4@make_int:
  00028	8b 44 24 28	 mov	 eax, DWORD PTR srclen$[rsp]
  0002c	39 44 24 04	 cmp	 DWORD PTR i$[rsp], eax
  00030	7d 23		 jge	 SHORT $LN3@make_int

; 178  :     {
; 179  :         result <<= 8;

  00032	8b 04 24	 mov	 eax, DWORD PTR result$[rsp]
  00035	c1 e0 08	 shl	 eax, 8
  00038	89 04 24	 mov	 DWORD PTR result$[rsp], eax

; 180  :         result |= src[i];

  0003b	48 63 44 24 04	 movsxd	 rax, DWORD PTR i$[rsp]
  00040	48 8b 4c 24 20	 mov	 rcx, QWORD PTR src$[rsp]
  00045	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00049	8b 0c 24	 mov	 ecx, DWORD PTR result$[rsp]
  0004c	0b c8		 or	 ecx, eax
  0004e	8b c1		 mov	 eax, ecx
  00050	89 04 24	 mov	 DWORD PTR result$[rsp], eax

; 181  :     }

  00053	eb c9		 jmp	 SHORT $LN2@make_int
$LN3@make_int:

; 182  : 
; 183  :     return result;

  00055	8b 04 24	 mov	 eax, DWORD PTR result$[rsp]

; 184  : 
; 185  : } /* end function make_int */

  00058	48 83 c4 18	 add	 rsp, 24
  0005c	c3		 ret	 0
make_int ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\dasdload64.c
_TEXT	SEGMENT
vl$ = 32
lvl$ = 64
msg$ = 72
info_msg PROC

; 158  : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	89 4c 24 08	 mov	 DWORD PTR [rsp+8], ecx
  00009	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000e	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00013	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 159  : va_list vl;
; 160  : 
; 161  :     if (infolvl >= lvl)

  00017	8b 44 24 40	 mov	 eax, DWORD PTR lvl$[rsp]
  0001b	39 05 00 00 00
	00		 cmp	 DWORD PTR infolvl, eax
  00021	7c 19		 jl	 SHORT $LN2@info_msg

; 162  :     {
; 163  :         va_start(vl, msg);

  00023	48 8d 44 24 50	 lea	 rax, QWORD PTR msg$[rsp+8]
  00028	48 89 44 24 20	 mov	 QWORD PTR vl$[rsp], rax

; 164  :         vprintf (msg, vl);

  0002d	48 8b 54 24 20	 mov	 rdx, QWORD PTR vl$[rsp]
  00032	48 8b 4c 24 48	 mov	 rcx, QWORD PTR msg$[rsp]
  00037	e8 00 00 00 00	 call	 vprintf
$LN2@info_msg:

; 165  :     }
; 166  : } /* end function info_msg */

  0003c	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00040	c3		 ret	 0
info_msg ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\dasdload64.c
_TEXT	SEGMENT
buflfs$ = 96
bufbz$ = 104
bufz$ = 112
code$ = 144
pgm$ = 152
argexit	PROC

; 118  : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	89 4c 24 08	 mov	 DWORD PTR [rsp+8], ecx
  00009	48 81 ec 88 00
	00 00		 sub	 rsp, 136		; 00000088H

; 119  :     // "HHC02496I Usage: ..."
; 120  : 
; 121  : #ifdef CCKD_COMPRESS_ZLIB
; 122  :     char *bufz =  "  -z     compress using zlib [default]\n";

  00010	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG160473
  00017	48 89 44 24 70	 mov	 QWORD PTR bufz$[rsp], rax

; 123  : #else
; 124  :     char *bufz = "";
; 125  : #endif
; 126  : 
; 127  : #define MSG_NUM     "HHC02496I "
; 128  : 
; 129  : #ifdef CCKD_COMPRESS_BZIP2
; 130  :   #ifdef CCKD_COMPRESS_ZLIB
; 131  :     char *bufbz = MSG_NUM "  -bz2   compress using bzip2\n";

  0001c	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG160474
  00023	48 89 44 24 68	 mov	 QWORD PTR bufbz$[rsp], rax

; 132  :   #else
; 133  :     char *bufbz =         "  -bz2   compress using bzip2\n";
; 134  :   #endif
; 135  : #else
; 136  :     char *bufbz = "";
; 137  : #endif
; 138  : 
; 139  :     char*  buflfs = "";

  00028	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG160475
  0002f	48 89 44 24 60	 mov	 QWORD PTR buflfs$[rsp], rax

; 140  : 
; 141  :     if (sizeof(off_t) > 4)

  00034	33 c0		 xor	 eax, eax
  00036	83 f8 01	 cmp	 eax, 1
  00039	74 0c		 je	 SHORT $LN2@argexit

; 142  : #if defined( CCKD_COMPRESS_ZLIB ) || defined( CCKD_COMPRESS_BZIP2 )
; 143  :         buflfs = MSG_NUM "  -lfs   create single large output file\n";

  0003b	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG160477
  00042	48 89 44 24 60	 mov	 QWORD PTR buflfs$[rsp], rax
$LN2@argexit:

; 144  : #else
; 145  :         buflfs =         "  -lfs   create single large output file\n";
; 146  : #endif
; 147  : 
; 148  :     FWRMSG( stderr, HHC02496, "I", pgm, bufz, bufbz, buflfs );

  00047	b9 02 00 00 00	 mov	 ecx, 2
  0004c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  00052	48 8b 4c 24 60	 mov	 rcx, QWORD PTR buflfs$[rsp]
  00057	48 89 4c 24 50	 mov	 QWORD PTR [rsp+80], rcx
  0005c	48 8b 4c 24 68	 mov	 rcx, QWORD PTR bufbz$[rsp]
  00061	48 89 4c 24 48	 mov	 QWORD PTR [rsp+72], rcx
  00066	48 8b 4c 24 70	 mov	 rcx, QWORD PTR bufz$[rsp]
  0006b	48 89 4c 24 40	 mov	 QWORD PTR [rsp+64], rcx
  00070	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR pgm$[rsp]
  00078	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  0007d	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG160478
  00084	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  00089	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG160479
  00090	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00095	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  0009a	41 b9 03 00 00
	00		 mov	 r9d, 3
  000a0	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG160480
  000a7	ba 94 00 00 00	 mov	 edx, 148		; 00000094H
  000ac	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG160481
  000b3	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 149  : 
; 150  :     exit(code);

  000b9	8b 8c 24 90 00
	00 00		 mov	 ecx, DWORD PTR code$[rsp]
  000c0	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_exit
$LN3@argexit:

; 151  : } /* end function argexit */

  000c6	48 81 c4 88 00
	00 00		 add	 rsp, 136		; 00000088H
  000cd	c3		 ret	 0
argexit	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\machdep.h
;	COMDAT store_fw_noswap
_TEXT	SEGMENT
ptr$ = 8
value$ = 16
store_fw_noswap PROC					; COMDAT

; 764  :     inline void store_fw_noswap(void *ptr, U32 value) {

  00000	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00004	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx

; 765  :       memcpy((BYTE *)ptr, (BYTE *)&value, 4);

  00009	48 8b 44 24 08	 mov	 rax, QWORD PTR ptr$[rsp]
  0000e	8b 4c 24 10	 mov	 ecx, DWORD PTR value$[rsp]
  00012	89 08		 mov	 DWORD PTR [rax], ecx

; 766  :     }

  00014	c3		 ret	 0
store_fw_noswap ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\machdep.h
;	COMDAT store_hw_noswap
_TEXT	SEGMENT
ptr$ = 8
value$ = 16
store_hw_noswap PROC					; COMDAT

; 730  :     inline void store_hw_noswap(void *ptr, U16 value) {

  00000	66 89 54 24 10	 mov	 WORD PTR [rsp+16], dx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx

; 731  :       memcpy((BYTE *)ptr, (BYTE *)&value, 2);

  0000a	48 8b 44 24 08	 mov	 rax, QWORD PTR ptr$[rsp]
  0000f	0f b7 4c 24 10	 movzx	 ecx, WORD PTR value$[rsp]
  00014	66 89 08	 mov	 WORD PTR [rax], cx

; 732  :     }

  00017	c3		 ret	 0
store_hw_noswap ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\machdep.h
;	COMDAT fetch_hw_noswap
_TEXT	SEGMENT
value$ = 0
ptr$ = 32
fetch_hw_noswap PROC					; COMDAT

; 712  :     inline U16 fetch_hw_noswap(const void *ptr) {

$LN3:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 18	 sub	 rsp, 24

; 713  :       U16 value;
; 714  :       memcpy(&value, (BYTE *)ptr, 2);

  00009	48 8b 44 24 20	 mov	 rax, QWORD PTR ptr$[rsp]
  0000e	0f b7 00	 movzx	 eax, WORD PTR [rax]
  00011	66 89 04 24	 mov	 WORD PTR value$[rsp], ax

; 715  :       return value;

  00015	0f b7 04 24	 movzx	 eax, WORD PTR value$[rsp]

; 716  :     }

  00019	48 83 c4 18	 add	 rsp, 24
  0001d	c3		 ret	 0
fetch_hw_noswap ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files (x86)\Windows Kits\10\include\10.0.22000.0\ucrt\time.h
_TEXT	SEGMENT
_Time$ = 48
time	PROC

; 521  :         {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 522  :             return _time64(_Time);

  00009	48 8b 4c 24 30	 mov	 rcx, QWORD PTR _Time$[rsp]
  0000e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__time64

; 523  :         }

  00014	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00018	c3		 ret	 0
time	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files (x86)\Windows Kits\10\include\10.0.22000.0\ucrt\time.h
_TEXT	SEGMENT
_Time$ = 48
localtime PROC

; 498  :         {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 499  :             return _localtime64(_Time);

  00009	48 8b 4c 24 30	 mov	 rcx, QWORD PTR _Time$[rsp]
  0000e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__localtime64

; 500  :         }

  00014	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00018	c3		 ret	 0
localtime ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files (x86)\Windows Kits\10\include\10.0.22000.0\ucrt\stdio.h
;	COMDAT sscanf
_TEXT	SEGMENT
_Result$ = 32
_ArgList$ = 40
_Buffer$ = 64
_Format$ = 72
sscanf	PROC						; COMDAT

; 2247 :     {

$LN3:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000f	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00014	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 2248 :         int _Result;
; 2249 :         va_list _ArgList;
; 2250 :         __crt_va_start(_ArgList, _Format);

  00018	48 8d 44 24 50	 lea	 rax, QWORD PTR _Format$[rsp+8]
  0001d	48 89 44 24 28	 mov	 QWORD PTR _ArgList$[rsp], rax

; 2251 :         _Result = _vsscanf_l(_Buffer, _Format, NULL, _ArgList);

  00022	4c 8b 4c 24 28	 mov	 r9, QWORD PTR _ArgList$[rsp]
  00027	45 33 c0	 xor	 r8d, r8d
  0002a	48 8b 54 24 48	 mov	 rdx, QWORD PTR _Format$[rsp]
  0002f	48 8b 4c 24 40	 mov	 rcx, QWORD PTR _Buffer$[rsp]
  00034	e8 00 00 00 00	 call	 _vsscanf_l
  00039	89 44 24 20	 mov	 DWORD PTR _Result$[rsp], eax

; 2252 :         __crt_va_end(_ArgList);

  0003d	48 c7 44 24 28
	00 00 00 00	 mov	 QWORD PTR _ArgList$[rsp], 0

; 2253 :         return _Result;

  00046	8b 44 24 20	 mov	 eax, DWORD PTR _Result$[rsp]

; 2254 :     }

  0004a	48 83 c4 38	 add	 rsp, 56			; 00000038H
  0004e	c3		 ret	 0
sscanf	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files (x86)\Windows Kits\10\include\10.0.22000.0\ucrt\stdio.h
;	COMDAT _vsscanf_l
_TEXT	SEGMENT
_Buffer$ = 64
_Format$ = 72
_Locale$ = 80
_ArgList$ = 88
_vsscanf_l PROC						; COMDAT

; 2152 :     {

$LN3:
  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 2153 :         return __stdio_common_vsscanf(

  00018	e8 00 00 00 00	 call	 __local_stdio_scanf_options
  0001d	48 8b 4c 24 58	 mov	 rcx, QWORD PTR _ArgList$[rsp]
  00022	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00027	48 8b 4c 24 50	 mov	 rcx, QWORD PTR _Locale$[rsp]
  0002c	48 89 4c 24 20	 mov	 QWORD PTR [rsp+32], rcx
  00031	4c 8b 4c 24 48	 mov	 r9, QWORD PTR _Format$[rsp]
  00036	49 c7 c0 ff ff
	ff ff		 mov	 r8, -1
  0003d	48 8b 54 24 40	 mov	 rdx, QWORD PTR _Buffer$[rsp]
  00042	48 8b 08	 mov	 rcx, QWORD PTR [rax]
  00045	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___stdio_common_vsscanf

; 2154 :             _CRT_INTERNAL_LOCAL_SCANF_OPTIONS,
; 2155 :             _Buffer, (size_t)-1, _Format, _Locale, _ArgList);
; 2156 :     }

  0004b	48 83 c4 38	 add	 rsp, 56			; 00000038H
  0004f	c3		 ret	 0
_vsscanf_l ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files (x86)\Windows Kits\10\include\10.0.22000.0\ucrt\stdio.h
;	COMDAT sprintf
_TEXT	SEGMENT
_Result$ = 32
_ArgList$ = 40
_Buffer$ = 64
_Format$ = 72
sprintf	PROC						; COMDAT

; 1771 :     {

$LN3:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000f	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00014	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 1772 :         int _Result;
; 1773 :         va_list _ArgList;
; 1774 :         __crt_va_start(_ArgList, _Format);

  00018	48 8d 44 24 50	 lea	 rax, QWORD PTR _Format$[rsp+8]
  0001d	48 89 44 24 28	 mov	 QWORD PTR _ArgList$[rsp], rax

; 1775 : 
; 1776 :         _Result = _vsprintf_l(_Buffer, _Format, NULL, _ArgList);

  00022	4c 8b 4c 24 28	 mov	 r9, QWORD PTR _ArgList$[rsp]
  00027	45 33 c0	 xor	 r8d, r8d
  0002a	48 8b 54 24 48	 mov	 rdx, QWORD PTR _Format$[rsp]
  0002f	48 8b 4c 24 40	 mov	 rcx, QWORD PTR _Buffer$[rsp]
  00034	e8 00 00 00 00	 call	 _vsprintf_l
  00039	89 44 24 20	 mov	 DWORD PTR _Result$[rsp], eax

; 1777 : 
; 1778 :         __crt_va_end(_ArgList);

  0003d	48 c7 44 24 28
	00 00 00 00	 mov	 QWORD PTR _ArgList$[rsp], 0

; 1779 :         return _Result;

  00046	8b 44 24 20	 mov	 eax, DWORD PTR _Result$[rsp]

; 1780 :     }

  0004a	48 83 c4 38	 add	 rsp, 56			; 00000038H
  0004e	c3		 ret	 0
sprintf	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files (x86)\Windows Kits\10\include\10.0.22000.0\ucrt\stdio.h
;	COMDAT _vsprintf_l
_TEXT	SEGMENT
_Buffer$ = 64
_Format$ = 72
_Locale$ = 80
_ArgList$ = 88
_vsprintf_l PROC					; COMDAT

; 1458 :     {

$LN3:
  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 1459 :         return _vsnprintf_l(_Buffer, (size_t)-1, _Format, _Locale, _ArgList);

  00018	48 8b 44 24 58	 mov	 rax, QWORD PTR _ArgList$[rsp]
  0001d	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00022	4c 8b 4c 24 50	 mov	 r9, QWORD PTR _Locale$[rsp]
  00027	4c 8b 44 24 48	 mov	 r8, QWORD PTR _Format$[rsp]
  0002c	48 c7 c2 ff ff
	ff ff		 mov	 rdx, -1
  00033	48 8b 4c 24 40	 mov	 rcx, QWORD PTR _Buffer$[rsp]
  00038	e8 00 00 00 00	 call	 _vsnprintf_l

; 1460 :     }

  0003d	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00041	c3		 ret	 0
_vsprintf_l ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files (x86)\Windows Kits\10\include\10.0.22000.0\ucrt\stdio.h
;	COMDAT _vsnprintf_l
_TEXT	SEGMENT
_Result$ = 48
tv74 = 52
_Buffer$ = 80
_BufferCount$ = 88
_Format$ = 96
_Locale$ = 104
_ArgList$ = 112
_vsnprintf_l PROC					; COMDAT

; 1391 :     {

$LN5:
  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 1392 :         int const _Result = __stdio_common_vsprintf(

  00018	e8 00 00 00 00	 call	 __local_stdio_printf_options
  0001d	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00020	48 83 c8 01	 or	 rax, 1
  00024	48 8b 4c 24 70	 mov	 rcx, QWORD PTR _ArgList$[rsp]
  00029	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  0002e	48 8b 4c 24 68	 mov	 rcx, QWORD PTR _Locale$[rsp]
  00033	48 89 4c 24 20	 mov	 QWORD PTR [rsp+32], rcx
  00038	4c 8b 4c 24 60	 mov	 r9, QWORD PTR _Format$[rsp]
  0003d	4c 8b 44 24 58	 mov	 r8, QWORD PTR _BufferCount$[rsp]
  00042	48 8b 54 24 50	 mov	 rdx, QWORD PTR _Buffer$[rsp]
  00047	48 8b c8	 mov	 rcx, rax
  0004a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___stdio_common_vsprintf
  00050	89 44 24 30	 mov	 DWORD PTR _Result$[rsp], eax

; 1393 :             _CRT_INTERNAL_LOCAL_PRINTF_OPTIONS | _CRT_INTERNAL_PRINTF_LEGACY_VSPRINTF_NULL_TERMINATION,
; 1394 :             _Buffer, _BufferCount, _Format, _Locale, _ArgList);
; 1395 : 
; 1396 :         return _Result < 0 ? -1 : _Result;

  00054	83 7c 24 30 00	 cmp	 DWORD PTR _Result$[rsp], 0
  00059	7d 0a		 jge	 SHORT $LN3@vsnprintf_
  0005b	c7 44 24 34 ff
	ff ff ff	 mov	 DWORD PTR tv74[rsp], -1
  00063	eb 08		 jmp	 SHORT $LN4@vsnprintf_
$LN3@vsnprintf_:
  00065	8b 44 24 30	 mov	 eax, DWORD PTR _Result$[rsp]
  00069	89 44 24 34	 mov	 DWORD PTR tv74[rsp], eax
$LN4@vsnprintf_:
  0006d	8b 44 24 34	 mov	 eax, DWORD PTR tv74[rsp]

; 1397 :     }

  00071	48 83 c4 48	 add	 rsp, 72			; 00000048H
  00075	c3		 ret	 0
_vsnprintf_l ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files (x86)\Windows Kits\10\include\10.0.22000.0\ucrt\stdio.h
;	COMDAT printf
_TEXT	SEGMENT
_Result$ = 32
_ArgList$ = 40
_Format$ = 64
printf	PROC						; COMDAT

; 956  :     {

$LN3:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000f	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00014	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 957  :         int _Result;
; 958  :         va_list _ArgList;
; 959  :         __crt_va_start(_ArgList, _Format);

  00018	48 8d 44 24 48	 lea	 rax, QWORD PTR _Format$[rsp+8]
  0001d	48 89 44 24 28	 mov	 QWORD PTR _ArgList$[rsp], rax

; 960  :         _Result = _vfprintf_l(stdout, _Format, NULL, _ArgList);

  00022	b9 01 00 00 00	 mov	 ecx, 1
  00027	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  0002d	4c 8b 4c 24 28	 mov	 r9, QWORD PTR _ArgList$[rsp]
  00032	45 33 c0	 xor	 r8d, r8d
  00035	48 8b 54 24 40	 mov	 rdx, QWORD PTR _Format$[rsp]
  0003a	48 8b c8	 mov	 rcx, rax
  0003d	e8 00 00 00 00	 call	 _vfprintf_l
  00042	89 44 24 20	 mov	 DWORD PTR _Result$[rsp], eax

; 961  :         __crt_va_end(_ArgList);

  00046	48 c7 44 24 28
	00 00 00 00	 mov	 QWORD PTR _ArgList$[rsp], 0

; 962  :         return _Result;

  0004f	8b 44 24 20	 mov	 eax, DWORD PTR _Result$[rsp]

; 963  :     }

  00053	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00057	c3		 ret	 0
printf	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files (x86)\Windows Kits\10\include\10.0.22000.0\ucrt\stdio.h
;	COMDAT vprintf
_TEXT	SEGMENT
_Format$ = 48
_ArgList$ = 56
vprintf	PROC						; COMDAT

; 747  :     {

$LN3:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 748  :         return _vfprintf_l(stdout, _Format, NULL, _ArgList);

  0000e	b9 01 00 00 00	 mov	 ecx, 1
  00013	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  00019	4c 8b 4c 24 38	 mov	 r9, QWORD PTR _ArgList$[rsp]
  0001e	45 33 c0	 xor	 r8d, r8d
  00021	48 8b 54 24 30	 mov	 rdx, QWORD PTR _Format$[rsp]
  00026	48 8b c8	 mov	 rcx, rax
  00029	e8 00 00 00 00	 call	 _vfprintf_l

; 749  :     }

  0002e	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00032	c3		 ret	 0
vprintf	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files (x86)\Windows Kits\10\include\10.0.22000.0\ucrt\stdio.h
;	COMDAT _vfprintf_l
_TEXT	SEGMENT
_Stream$ = 64
_Format$ = 72
_Locale$ = 80
_ArgList$ = 88
_vfprintf_l PROC					; COMDAT

; 644  :     {

$LN3:
  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 645  :         return __stdio_common_vfprintf(_CRT_INTERNAL_LOCAL_PRINTF_OPTIONS, _Stream, _Format, _Locale, _ArgList);

  00018	e8 00 00 00 00	 call	 __local_stdio_printf_options
  0001d	48 8b 4c 24 58	 mov	 rcx, QWORD PTR _ArgList$[rsp]
  00022	48 89 4c 24 20	 mov	 QWORD PTR [rsp+32], rcx
  00027	4c 8b 4c 24 50	 mov	 r9, QWORD PTR _Locale$[rsp]
  0002c	4c 8b 44 24 48	 mov	 r8, QWORD PTR _Format$[rsp]
  00031	48 8b 54 24 40	 mov	 rdx, QWORD PTR _Stream$[rsp]
  00036	48 8b 08	 mov	 rcx, QWORD PTR [rax]
  00039	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___stdio_common_vfprintf

; 646  :     }

  0003f	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00043	c3		 ret	 0
_vfprintf_l ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files (x86)\Windows Kits\10\include\10.0.22000.0\ucrt\corecrt_stdio_config.h
;	COMDAT __local_stdio_scanf_options
_TEXT	SEGMENT
__local_stdio_scanf_options PROC			; COMDAT

; 101  :         static unsigned __int64 _OptionsStorage;
; 102  :         return &_OptionsStorage;

  00000	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:?_OptionsStorage@?1??__local_stdio_scanf_options@@9@9 ; `__local_stdio_scanf_options'::`2'::_OptionsStorage

; 103  :     }

  00007	c3		 ret	 0
__local_stdio_scanf_options ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files (x86)\Windows Kits\10\include\10.0.22000.0\ucrt\corecrt_stdio_config.h
;	COMDAT __local_stdio_printf_options
_TEXT	SEGMENT
__local_stdio_printf_options PROC			; COMDAT

; 91   :         static unsigned __int64 _OptionsStorage;
; 92   :         return &_OptionsStorage;

  00000	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:?_OptionsStorage@?1??__local_stdio_printf_options@@9@9 ; `__local_stdio_printf_options'::`2'::_OptionsStorage

; 93   :     }

  00007	c3		 ret	 0
__local_stdio_printf_options ENDP
_TEXT	ENDS
END
