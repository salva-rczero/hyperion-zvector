; Listing generated by Microsoft (R) Optimizing Compiler Version 19.34.31937.0 

include listing.inc

INCLUDELIB MSVCRTD
INCLUDELIB OLDNAMES

_DATA	SEGMENT
con1052_immed DB 00H
	DB	00H
	DB	00H
	DB	01H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	01H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
_DATA	ENDS
CONST	SEGMENT
CKD_ENDTRK DB	0ffH
	DB	0ffH
	DB	0ffH
	DB	0ffH
	DB	0ffH
	DB	0ffH
	DB	0ffH
	DB	0ffH
default_pfxs DB	02fH
	DB	060H
	DB	03dH
	DB	07eH
	DB	040H
	DB	024H
	DB	025H
	DB	05eH
	DB	026H
	DB	05fH
	DB	03aH
	DB	03fH
	DB	030H
	DB	031H
	DB	032H
	DB	033H
	DB	034H
	DB	035H
	DB	036H
	DB	037H
	DB	038H
	DB	039H
CONST	ENDS
PUBLIC	__local_stdio_scanf_options
PUBLIC	_vsscanf_l
PUBLIC	sscanf
PUBLIC	hdl_check_depends_ep
PUBLIC	hdl_define_devtypes_ep
PUBLIC	hdl_register_symbols_ep
EXTRN	__report_rangecheckfailure:PROC
EXTRN	__imp_isprint:PROC
EXTRN	memchr:PROC
EXTRN	memmove:PROC
EXTRN	strchr:PROC
EXTRN	strcmp:PROC
EXTRN	__imp__stricmp:PROC
EXTRN	strlen:PROC
EXTRN	__imp_strncmp:PROC
EXTRN	__imp__strnicmp:PROC
EXTRN	__imp___acrt_iob_func:PROC
EXTRN	__imp___stdio_common_vsscanf:PROC
EXTRN	__imp_hthread_obtain_lock:PROC
EXTRN	__imp_hthread_release_lock:PROC
EXTRN	__imp_hthread_signal_condition:PROC
EXTRN	__imp_hthread_wait_condition:PROC
EXTRN	__imp_strlcpy:PROC
EXTRN	__imp_w32_snprintf:PROC
EXTRN	__imp_w32_basename:PROC
EXTRN	__imp_host_to_guest:PROC
EXTRN	__imp_guest_to_host:PROC
EXTRN	__imp_hdl_next:PROC
EXTRN	__imp_device_attention:PROC
EXTRN	__imp_fwritemsg:PROC
EXTRN	__GSHandlerCheck:PROC
EXTRN	__security_check_cookie:PROC
EXTRN	__imp_sysblk:BYTE
EXTRN	__ImageBase:BYTE
EXTRN	__security_cookie:QWORD
_DATA	SEGMENT
COMM	?_OptionsStorage@?1??__local_stdio_scanf_options@@9@9:QWORD							; `__local_stdio_scanf_options'::`2'::_OptionsStorage
_DATA	ENDS
_BSS	SEGMENT
used_pfxs DB	016H DUP (?)
	ALIGN	4

$SG177518 DB	01H DUP (?)
	ALIGN	4

$SG177545 DB	01H DUP (?)
	ALIGN	4

$SG177584 DB	01H DUP (?)
_BSS	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$_vsscanf_l DD imagerel $LN3
	DD	imagerel $LN3+80
	DD	imagerel $unwind$_vsscanf_l
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$sscanf DD imagerel $LN3
	DD	imagerel $LN3+79
	DD	imagerel $unwind$sscanf
pdata	ENDS
pdata	SEGMENT
$pdata$con1052_close_device DD imagerel con1052_close_device
	DD	imagerel con1052_close_device+135
	DD	imagerel $unwind$con1052_close_device
$pdata$con1052_query_device DD imagerel con1052_query_device
	DD	imagerel con1052_query_device+453
	DD	imagerel $unwind$con1052_query_device
$pdata$con1052_init_handler DD imagerel con1052_init_handler
	DD	imagerel con1052_init_handler+1733
	DD	imagerel $unwind$con1052_init_handler
$pdata$con1052_panel_command DD imagerel con1052_panel_command
	DD	imagerel con1052_panel_command+657
	DD	imagerel $unwind$con1052_panel_command
$pdata$con1052_execute_ccw DD imagerel con1052_execute_ccw
	DD	imagerel con1052_execute_ccw+2152
	DD	imagerel $unwind$con1052_execute_ccw
$pdata$hdl_check_depends_ep DD imagerel $LN15
	DD	imagerel $LN15+152
	DD	imagerel $unwind$hdl_check_depends_ep
$pdata$hdl_define_devtypes_ep DD imagerel $LN3
	DD	imagerel $LN3+50
	DD	imagerel $unwind$hdl_define_devtypes_ep
$pdata$hdl_register_symbols_ep DD imagerel $LN3
	DD	imagerel $LN3+32
	DD	imagerel $unwind$hdl_register_symbols_ep
pdata	ENDS
_DATA	SEGMENT
con1052_device_hndinfo DQ FLAT:con1052_init_handler
	DQ	FLAT:con1052_execute_ccw
	DQ	FLAT:con1052_close_device
	DQ	FLAT:con1052_query_device
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	FLAT:con1052_immed
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
$SG177510 DB	'CON', 00H
$SG177516 DB	'.', 00H
	ORG $+2
$SG177517 DB	' noprompt', 00H
	ORG $+2
$SG177547 DB	'%hx', 00H
$SG177519 DB	'*syscons cmdpref(%s)%s IO[%llu]', 00H
$SG177550 DB	'noprompt', 00H
	ORG $+3
$SG177553 DB	'E', 00H
	ORG $+2
$SG177554 DB	'HHC01085%s %1d:%04X COMM: default command prefixes exhau'
	DB	'sted', 0aH, 00H
	ORG $+2
$SG177555 DB	'con1052_init_handler', 00H
	ORG $+3
$SG177556 DB	'con1052c.c', 00H
	ORG $+1
$SG177559 DB	'E', 00H
	ORG $+2
$SG177561 DB	'con1052_init_handler', 00H
	ORG $+3
$SG177560 DB	'HHC01086%s %1d:%04X COMM: device %1d:%04X already using '
	DB	'prefix %s', 0aH, 00H
	ORG $+1
$SG177655 DB	'A', 00H
	ORG $+2
$SG177562 DB	'con1052c.c', 00H
	ORG $+1
$SG177585 DB	'%s%s', 0aH, 00H
	ORG $+2
$SG177666 DB	'I', 00H
	ORG $+2
$SG177586 DB	'con1052_panel_command', 00H
	ORG $+2
$SG177587 DB	'con1052c.c', 00H
	ORG $+5
$SG177588 DB	'con1052c.c:323', 00H
	ORG $+1
$SG177591 DB	'con1052c.c:327', 00H
	ORG $+1
$SG177592 DB	'con1052c.c:328', 00H
	ORG $+1
$SG177593 DB	'con1052c.c:332', 00H
	ORG $+1
$SG177648 DB	'%s%s', 0aH, 00H
	ORG $+2
$SG177649 DB	'con1052_execute_ccw', 00H
	ORG $+4
$SG177650 DB	'con1052c.c', 00H
	ORG $+5
$SG177656 DB	'HHC00010%s Enter input for console %1d:%04X', 0aH, 00H
	ORG $+3
$SG177657 DB	'con1052_execute_ccw', 00H
	ORG $+4
$SG177658 DB	'con1052c.c', 00H
	ORG $+5
$SG177659 DB	'con1052c.c:455', 00H
	ORG $+1
$SG177660 DB	'con1052c.c:458', 00H
	ORG $+1
$SG177661 DB	'con1052c.c:461', 00H
	ORG $+1
$SG177667 DB	'HHC00009%s RRR...RING...GGG!', 07H, 0aH, 00H
	ORG $+1
$SG177668 DB	'con1052_execute_ccw', 00H
	ORG $+4
$SG177669 DB	'con1052c.c', 00H
	ORG $+5
$SG177712 DB	'SDL 4.60', 00H
	ORG $+3
$SG177716 DB	'DEVBLK', 00H
	ORG $+5
$SG177713 DB	'HERCULES', 00H
	ORG $+3
$SG177719 DB	'SYSBLK', 00H
	ORG $+5
$SG177715 DB	'SDL 4.00', 00H
	ORG $+3
$SG177724 DB	'1052-C', 00H
	ORG $+5
$SG177718 DB	'SDL 4.2', 00H
$SG177725 DB	'3215-C', 00H
	ORG $+1
$SG177731 DB	'panel_command', 00H
_DATA	ENDS
voltbl	SEGMENT
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:con1052_query_device
	DD	025H
	DD	01adH
voltbl	ENDS
xdata	SEGMENT
$unwind$con1052_close_device DD 010901H
	DD	08209H
$unwind$con1052_query_device DD 022d19H
	DD	02f011bH
	DD	imagerel __GSHandlerCheck
	DD	0160H
$unwind$con1052_init_handler DD 021501H
	DD	01b0115H
$unwind$con1052_panel_command DD 010901H
	DD	0e209H
$unwind$con1052_execute_ccw DD 041c01H
	DD	013011cH
	DD	060147015H
$unwind$hdl_check_depends_ep DD 010901H
	DD	06209H
$unwind$hdl_define_devtypes_ep DD 010901H
	DD	04209H
$unwind$hdl_register_symbols_ep DD 010901H
	DD	04209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$sscanf DD 011801H
	DD	06218H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$_vsscanf_l DD 011801H
	DD	06218H
xdata	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\con1052c.c
_TEXT	SEGMENT
regsym$ = 48
hdl_register_symbols_ep PROC

; 622  : HDL_REGISTER_SECTION;

$LN3:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 623  : {
; 624  :    HDL_REGISTER( panel_command, con1052_panel_command );

  00009	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:con1052_panel_command
  00010	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG177731
  00017	ff 54 24 30	 call	 QWORD PTR regsym$[rsp]

; 625  : }
; 626  : END_REGISTER_SECTION

  0001b	48 83 c4 28	 add	 rsp, 40			; 00000028H
  0001f	c3		 ret	 0
hdl_register_symbols_ep ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\con1052c.c
_TEXT	SEGMENT
defdev$ = 48
hdl_define_devtypes_ep PROC

; 614  : HDL_DEVICE_SECTION;

$LN3:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 615  : {
; 616  :     HDL_DEVICE( 1052-C, con1052_device_hndinfo );

  00009	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:con1052_device_hndinfo
  00010	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG177724
  00017	ff 54 24 30	 call	 QWORD PTR defdev$[rsp]

; 617  :     HDL_DEVICE( 3215-C, con1052_device_hndinfo );

  0001b	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:con1052_device_hndinfo
  00022	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG177725
  00029	ff 54 24 30	 call	 QWORD PTR defdev$[rsp]

; 618  : }
; 619  : END_DEVICE_SECTION

  0002d	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00031	c3		 ret	 0
hdl_define_devtypes_ep ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\con1052c.c
_TEXT	SEGMENT
depchk_rc$ = 32
depchk$ = 64
hdl_check_depends_ep PROC

; 596  : HDL_DEPENDENCY_SECTION;

$LN15:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 38	 sub	 rsp, 56			; 00000038H
  00009	c7 44 24 20 00
	00 00 00	 mov	 DWORD PTR depchk_rc$[rsp], 0
$LN4@hdl_check_:

; 597  : {
; 598  :      HDL_DEPENDENCY( HERCULES );

  00011	41 b8 08 00 00
	00		 mov	 r8d, 8
  00017	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG177712
  0001e	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG177713
  00025	ff 54 24 40	 call	 QWORD PTR depchk$[rsp]
  00029	85 c0		 test	 eax, eax
  0002b	74 08		 je	 SHORT $LN11@hdl_check_
  0002d	c7 44 24 20 01
	00 00 00	 mov	 DWORD PTR depchk_rc$[rsp], 1
$LN11@hdl_check_:
  00035	33 c0		 xor	 eax, eax
  00037	85 c0		 test	 eax, eax
  00039	75 d6		 jne	 SHORT $LN4@hdl_check_
$LN7@hdl_check_:

; 599  :      HDL_DEPENDENCY( DEVBLK );

  0003b	41 b8 a0 1b 00
	00		 mov	 r8d, 7072		; 00001ba0H
  00041	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG177715
  00048	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG177716
  0004f	ff 54 24 40	 call	 QWORD PTR depchk$[rsp]
  00053	85 c0		 test	 eax, eax
  00055	74 08		 je	 SHORT $LN12@hdl_check_
  00057	c7 44 24 20 01
	00 00 00	 mov	 DWORD PTR depchk_rc$[rsp], 1
$LN12@hdl_check_:
  0005f	33 c0		 xor	 eax, eax
  00061	85 c0		 test	 eax, eax
  00063	75 d6		 jne	 SHORT $LN7@hdl_check_
$LN10@hdl_check_:

; 600  :      HDL_DEPENDENCY( SYSBLK );

  00065	41 b8 00 76 01
	00		 mov	 r8d, 95744		; 00017600H
  0006b	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG177718
  00072	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG177719
  00079	ff 54 24 40	 call	 QWORD PTR depchk$[rsp]
  0007d	85 c0		 test	 eax, eax
  0007f	74 08		 je	 SHORT $LN13@hdl_check_
  00081	c7 44 24 20 01
	00 00 00	 mov	 DWORD PTR depchk_rc$[rsp], 1
$LN13@hdl_check_:
  00089	33 c0		 xor	 eax, eax
  0008b	85 c0		 test	 eax, eax
  0008d	75 d6		 jne	 SHORT $LN10@hdl_check_

; 601  : }
; 602  : END_DEPENDENCY_SECTION

  0008f	8b 44 24 20	 mov	 eax, DWORD PTR depchk_rc$[rsp]
  00093	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00097	c3		 ret	 0
hdl_check_depends_ep ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\con1052c.c
_TEXT	SEGMENT
c$ = 80
len$ = 84
num$ = 88
tv78 = 92
tv80 = 96
tv173 = 100
tv179 = 104
tv211 = 108
tv249 = 112
tv268 = 116
nl$1 = 120
str$2 = 128
tv154 = 136
dev$ = 176
code$ = 184
flags$ = 192
chained$ = 200
count$ = 208
prevcode$ = 216
ccwseq$ = 224
iobuf$ = 232
more$ = 240
unitstat$ = 248
residual$ = 256
con1052_execute_ccw PROC

; 356  : {

  00000	44 88 4c 24 20	 mov	 BYTE PTR [rsp+32], r9b
  00005	44 88 44 24 18	 mov	 BYTE PTR [rsp+24], r8b
  0000a	88 54 24 10	 mov	 BYTE PTR [rsp+16], dl
  0000e	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00013	56		 push	 rsi
  00014	57		 push	 rdi
  00015	48 81 ec 98 00
	00 00		 sub	 rsp, 152		; 00000098H
$LN4@con1052_ex:

; 357  : U32     len;                            /* Length of data            */
; 358  : U32     num;                            /* Number of bytes to move   */
; 359  : BYTE    c;                              /* Print character           */
; 360  : 
; 361  :     UNREFERENCED( chained );

  0001c	33 c0		 xor	 eax, eax
  0001e	85 c0		 test	 eax, eax
  00020	75 fa		 jne	 SHORT $LN4@con1052_ex
$LN7@con1052_ex:

; 362  :     UNREFERENCED( prevcode );

  00022	33 c0		 xor	 eax, eax
  00024	85 c0		 test	 eax, eax
  00026	75 fa		 jne	 SHORT $LN7@con1052_ex
$LN10@con1052_ex:

; 363  :     UNREFERENCED( ccwseq );

  00028	33 c0		 xor	 eax, eax
  0002a	85 c0		 test	 eax, eax
  0002c	75 fa		 jne	 SHORT $LN10@con1052_ex

; 364  : 
; 365  :     /* Unit check with intervention required if no client connected */
; 366  :     if (dev->connected == 0 && !IS_CCW_SENSE( code ))

  0002e	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00036	8b 80 f8 05 00
	00		 mov	 eax, DWORD PTR [rax+1528]
  0003c	c1 e8 05	 shr	 eax, 5
  0003f	83 e0 01	 and	 eax, 1
  00042	85 c0		 test	 eax, eax
  00044	75 39		 jne	 SHORT $LN18@con1052_ex
  00046	0f b6 84 24 b8
	00 00 00	 movzx	 eax, BYTE PTR code$[rsp]
  0004e	83 e0 0f	 and	 eax, 15
  00051	83 f8 04	 cmp	 eax, 4
  00054	74 29		 je	 SHORT $LN18@con1052_ex

; 367  :     {
; 368  :         dev->sense[0] = SENSE_IR;

  00056	b8 01 00 00 00	 mov	 eax, 1
  0005b	48 6b c0 00	 imul	 rax, rax, 0
  0005f	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  00067	c6 84 01 64 03
	00 00 40	 mov	 BYTE PTR [rcx+rax+868], 64 ; 00000040H

; 369  :         *unitstat = CSW_UC;

  0006f	48 8b 84 24 f8
	00 00 00	 mov	 rax, QWORD PTR unitstat$[rsp]
  00077	c6 00 02	 mov	 BYTE PTR [rax], 2

; 370  :         return;

  0007a	e9 d8 06 00 00	 jmp	 $LN1@con1052_ex
$LN18@con1052_ex:

; 371  :     }
; 372  : 
; 373  :     /* Process depending on CCW opcode */
; 374  :     switch (code) {

  0007f	0f b6 84 24 b8
	00 00 00	 movzx	 eax, BYTE PTR code$[rsp]
  00087	89 44 24 5c	 mov	 DWORD PTR tv78[rsp], eax
  0008b	8b 44 24 5c	 mov	 eax, DWORD PTR tv78[rsp]
  0008f	ff c8		 dec	 eax
  00091	89 44 24 5c	 mov	 DWORD PTR tv78[rsp], eax
  00095	81 7c 24 5c e3
	00 00 00	 cmp	 DWORD PTR tv78[rsp], 227 ; 000000e3H
  0009d	0f 87 90 06 00
	00		 ja	 $LN37@con1052_ex
  000a3	48 63 44 24 5c	 movsxd	 rax, DWORD PTR tv78[rsp]
  000a8	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__ImageBase
  000af	0f b6 84 01 00
	00 00 00	 movzx	 eax, BYTE PTR $LN51@con1052_ex[rcx+rax]
  000b7	8b 84 81 00 00
	00 00		 mov	 eax, DWORD PTR $LN52@con1052_ex[rcx+rax*4]
  000be	48 03 c1	 add	 rax, rcx
  000c1	ff e0		 jmp	 rax
$LN19@con1052_ex:
$LN20@con1052_ex:

; 375  : 
; 376  :     case 0x01:
; 377  :     /*---------------------------------------------------------------*/
; 378  :     /* WRITE, NO CARRIER RETURN                                      */
; 379  :     /*---------------------------------------------------------------*/
; 380  : 
; 381  :     case 0x09:
; 382  :     /*---------------------------------------------------------------*/
; 383  :     /* WRITE, AUTO CARRIER RETURN                                    */
; 384  :     /*---------------------------------------------------------------*/
; 385  : 
; 386  :         /* Calculate number of bytes to write and set residual count */
; 387  :         num = (count < BUFLEN_1052) ? count : BUFLEN_1052;

  000c3	81 bc 24 d0 00
	00 00 96 00 00
	00		 cmp	 DWORD PTR count$[rsp], 150 ; 00000096H
  000ce	73 0d		 jae	 SHORT $LN39@con1052_ex
  000d0	8b 84 24 d0 00
	00 00		 mov	 eax, DWORD PTR count$[rsp]
  000d7	89 44 24 60	 mov	 DWORD PTR tv80[rsp], eax
  000db	eb 08		 jmp	 SHORT $LN40@con1052_ex
$LN39@con1052_ex:
  000dd	c7 44 24 60 96
	00 00 00	 mov	 DWORD PTR tv80[rsp], 150 ; 00000096H
$LN40@con1052_ex:
  000e5	8b 44 24 60	 mov	 eax, DWORD PTR tv80[rsp]
  000e9	89 44 24 58	 mov	 DWORD PTR num$[rsp], eax

; 388  :         *residual = count - num;

  000ed	8b 44 24 58	 mov	 eax, DWORD PTR num$[rsp]
  000f1	8b 8c 24 d0 00
	00 00		 mov	 ecx, DWORD PTR count$[rsp]
  000f8	2b c8		 sub	 ecx, eax
  000fa	8b c1		 mov	 eax, ecx
  000fc	48 8b 8c 24 00
	01 00 00	 mov	 rcx, QWORD PTR residual$[rsp]
  00104	89 01		 mov	 DWORD PTR [rcx], eax

; 389  : 
; 390  :         /* Translate channel buffer data to ASCII */
; 391  :         for (len = 0; len < num; len++)

  00106	c7 44 24 54 00
	00 00 00	 mov	 DWORD PTR len$[rsp], 0
  0010e	eb 0a		 jmp	 SHORT $LN15@con1052_ex
$LN13@con1052_ex:
  00110	8b 44 24 54	 mov	 eax, DWORD PTR len$[rsp]
  00114	ff c0		 inc	 eax
  00116	89 44 24 54	 mov	 DWORD PTR len$[rsp], eax
$LN15@con1052_ex:
  0011a	8b 44 24 58	 mov	 eax, DWORD PTR num$[rsp]
  0011e	39 44 24 54	 cmp	 DWORD PTR len$[rsp], eax
  00122	73 61		 jae	 SHORT $LN14@con1052_ex

; 392  :         {
; 393  :             c = guest_to_host( iobuf[len] );

  00124	8b 44 24 54	 mov	 eax, DWORD PTR len$[rsp]
  00128	48 8b 8c 24 e8
	00 00 00	 mov	 rcx, QWORD PTR iobuf$[rsp]
  00130	0f b6 0c 01	 movzx	 ecx, BYTE PTR [rcx+rax]
  00134	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_guest_to_host
  0013a	88 44 24 50	 mov	 BYTE PTR c$[rsp], al

; 394  :             if (1
; 395  :                 && c != 0x0d
; 396  :                 && c != 0x0a
; 397  :                 && !isprint(c)

  0013e	33 c0		 xor	 eax, eax
  00140	83 f8 01	 cmp	 eax, 1
  00143	74 2a		 je	 SHORT $LN21@con1052_ex
  00145	0f b6 44 24 50	 movzx	 eax, BYTE PTR c$[rsp]
  0014a	83 f8 0d	 cmp	 eax, 13
  0014d	74 20		 je	 SHORT $LN21@con1052_ex
  0014f	0f b6 44 24 50	 movzx	 eax, BYTE PTR c$[rsp]
  00154	83 f8 0a	 cmp	 eax, 10
  00157	74 16		 je	 SHORT $LN21@con1052_ex
  00159	0f b6 44 24 50	 movzx	 eax, BYTE PTR c$[rsp]
  0015e	8b c8		 mov	 ecx, eax
  00160	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_isprint
  00166	85 c0		 test	 eax, eax
  00168	75 05		 jne	 SHORT $LN21@con1052_ex

; 398  :             )
; 399  :                 c = ' ';

  0016a	c6 44 24 50 20	 mov	 BYTE PTR c$[rsp], 32	; 00000020H
$LN21@con1052_ex:

; 400  :             iobuf[len] = c;

  0016f	8b 44 24 54	 mov	 eax, DWORD PTR len$[rsp]
  00173	48 8b 8c 24 e8
	00 00 00	 mov	 rcx, QWORD PTR iobuf$[rsp]
  0017b	0f b6 54 24 50	 movzx	 edx, BYTE PTR c$[rsp]
  00180	88 14 01	 mov	 BYTE PTR [rcx+rax], dl

; 401  :         }

  00183	eb 8b		 jmp	 SHORT $LN13@con1052_ex
$LN14@con1052_ex:

; 402  : 
; 403  :         /* Perform end of record processing if not data-chaining */
; 404  :         if ((flags & CCW_FLAGS_CD) == 0)

  00185	0f b6 84 24 c0
	00 00 00	 movzx	 eax, BYTE PTR flags$[rsp]
  0018d	25 80 00 00 00	 and	 eax, 128		; 00000080H
  00192	85 c0		 test	 eax, eax
  00194	75 27		 jne	 SHORT $LN22@con1052_ex

; 405  :         {
; 406  :             /* CCW opcode == Write, Auto Carrier Return? */
; 407  :             if (code == 0x09)

  00196	0f b6 84 24 b8
	00 00 00	 movzx	 eax, BYTE PTR code$[rsp]
  0019e	83 f8 09	 cmp	 eax, 9
  001a1	75 1a		 jne	 SHORT $LN23@con1052_ex

; 408  :                 iobuf[len++] = '\n';

  001a3	8b 44 24 54	 mov	 eax, DWORD PTR len$[rsp]
  001a7	48 8b 8c 24 e8
	00 00 00	 mov	 rcx, QWORD PTR iobuf$[rsp]
  001af	c6 04 01 0a	 mov	 BYTE PTR [rcx+rax], 10
  001b3	8b 44 24 54	 mov	 eax, DWORD PTR len$[rsp]
  001b7	ff c0		 inc	 eax
  001b9	89 44 24 54	 mov	 DWORD PTR len$[rsp], eax
$LN23@con1052_ex:
$LN22@con1052_ex:

; 409  :         }
; 410  : 
; 411  :         /* Append string terminator */
; 412  :         iobuf[len] = '\0';

  001bd	8b 44 24 54	 mov	 eax, DWORD PTR len$[rsp]
  001c1	48 8b 8c 24 e8
	00 00 00	 mov	 rcx, QWORD PTR iobuf$[rsp]
  001c9	c6 04 01 00	 mov	 BYTE PTR [rcx+rax], 0

; 413  : 
; 414  :         /* Process multiline messages */
; 415  :         {
; 416  :             char* str = (char*) iobuf;

  001cd	48 8b 84 24 e8
	00 00 00	 mov	 rax, QWORD PTR iobuf$[rsp]
  001d5	48 89 84 24 80
	00 00 00	 mov	 QWORD PTR str$2[rsp], rax
$LN16@con1052_ex:

; 417  :             char* nl;
; 418  : 
; 419  :             while (str && *str)

  001dd	48 83 bc 24 80
	00 00 00 00	 cmp	 QWORD PTR str$2[rsp], 0
  001e6	0f 84 c4 00 00
	00		 je	 $LN17@con1052_ex
  001ec	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR str$2[rsp]
  001f4	0f be 00	 movsx	 eax, BYTE PTR [rax]
  001f7	85 c0		 test	 eax, eax
  001f9	0f 84 b1 00 00
	00		 je	 $LN17@con1052_ex

; 420  :             {
; 421  :                 nl = strchr( str, '\n' );

  001ff	ba 0a 00 00 00	 mov	 edx, 10
  00204	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR str$2[rsp]
  0020c	e8 00 00 00 00	 call	 strchr
  00211	48 89 44 24 78	 mov	 QWORD PTR nl$1[rsp], rax

; 422  : 
; 423  :                 if (nl) *nl++ = 0;

  00216	48 83 7c 24 78
	00		 cmp	 QWORD PTR nl$1[rsp], 0
  0021c	74 15		 je	 SHORT $LN24@con1052_ex
  0021e	48 8b 44 24 78	 mov	 rax, QWORD PTR nl$1[rsp]
  00223	c6 00 00	 mov	 BYTE PTR [rax], 0
  00226	48 8b 44 24 78	 mov	 rax, QWORD PTR nl$1[rsp]
  0022b	48 ff c0	 inc	 rax
  0022e	48 89 44 24 78	 mov	 QWORD PTR nl$1[rsp], rax
$LN24@con1052_ex:

; 424  : 
; 425  :                 LOGMSG( "%s%s\n", dev->filename, str );

  00233	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  0023b	48 05 a4 00 00
	00		 add	 rax, 164		; 000000a4H
  00241	48 89 84 24 88
	00 00 00	 mov	 QWORD PTR tv154[rsp], rax
  00249	b9 01 00 00 00	 mov	 ecx, 1
  0024e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  00254	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR str$2[rsp]
  0025c	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  00261	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR tv154[rsp]
  00269	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  0026e	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG177648
  00275	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  0027a	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  0027f	41 b9 03 00 00
	00		 mov	 r9d, 3
  00285	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG177649
  0028c	ba a9 01 00 00	 mov	 edx, 425		; 000001a9H
  00291	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG177650
  00298	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 426  : 
; 427  :                 str = nl;

  0029e	48 8b 44 24 78	 mov	 rax, QWORD PTR nl$1[rsp]
  002a3	48 89 84 24 80
	00 00 00	 mov	 QWORD PTR str$2[rsp], rax

; 428  :             }

  002ab	e9 2d ff ff ff	 jmp	 $LN16@con1052_ex
$LN17@con1052_ex:

; 429  :         }
; 430  : 
; 431  :         /* Return normal status */
; 432  :         *unitstat = CSW_CE | CSW_DE;

  002b0	48 8b 84 24 f8
	00 00 00	 mov	 rax, QWORD PTR unitstat$[rsp]
  002b8	c6 00 0c	 mov	 BYTE PTR [rax], 12

; 433  :         break;

  002bb	e9 97 04 00 00	 jmp	 $LN11@con1052_ex
$LN25@con1052_ex:

; 434  : 
; 435  :     case 0x03:
; 436  :     /*---------------------------------------------------------------*/
; 437  :     /* CONTROL NO-OPERATION                                          */
; 438  :     /*---------------------------------------------------------------*/
; 439  :         *unitstat = CSW_CE | CSW_DE;

  002c0	48 8b 84 24 f8
	00 00 00	 mov	 rax, QWORD PTR unitstat$[rsp]
  002c8	c6 00 0c	 mov	 BYTE PTR [rax], 12

; 440  :         break;

  002cb	e9 87 04 00 00	 jmp	 $LN11@con1052_ex
$LN26@con1052_ex:

; 441  : 
; 442  :     case 0x0A:
; 443  :     /*---------------------------------------------------------------*/
; 444  :     /* READ INQUIRY                                                  */
; 445  :     /*---------------------------------------------------------------*/
; 446  : 
; 447  :         /* Solicit console input if no data in the device buffer */
; 448  :         if (!dev->keybdrem)

  002d0	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  002d8	83 b8 c0 06 00
	00 00		 cmp	 DWORD PTR [rax+1728], 0
  002df	0f 85 5e 01 00
	00		 jne	 $LN27@con1052_ex

; 449  :         {
; 450  :             /* Display prompting message on console if allowed */
; 451  :             if (dev->prompt1052)

  002e5	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  002ed	8b 80 d4 06 00
	00		 mov	 eax, DWORD PTR [rax+1748]
  002f3	c1 e8 02	 shr	 eax, 2
  002f6	83 e0 01	 and	 eax, 1
  002f9	85 c0		 test	 eax, eax
  002fb	0f 84 a3 00 00
	00		 je	 $LN28@con1052_ex

; 452  :                 // "Enter input for console %1d:%04X"
; 453  :                 WRMSG( HHC00010, "A", LCSS_DEVNUM );

  00301	48 83 bc 24 b0
	00 00 00 00	 cmp	 QWORD PTR dev$[rsp], 0
  0030a	74 12		 je	 SHORT $LN41@con1052_ex
  0030c	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00314	0f b7 40 48	 movzx	 eax, WORD PTR [rax+72]
  00318	89 44 24 64	 mov	 DWORD PTR tv173[rsp], eax
  0031c	eb 08		 jmp	 SHORT $LN42@con1052_ex
$LN41@con1052_ex:
  0031e	c7 44 24 64 00
	00 00 00	 mov	 DWORD PTR tv173[rsp], 0
$LN42@con1052_ex:
  00326	48 83 bc 24 b0
	00 00 00 00	 cmp	 QWORD PTR dev$[rsp], 0
  0032f	74 14		 je	 SHORT $LN43@con1052_ex
  00331	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00339	0f b7 40 44	 movzx	 eax, WORD PTR [rax+68]
  0033d	d1 f8		 sar	 eax, 1
  0033f	89 44 24 68	 mov	 DWORD PTR tv179[rsp], eax
  00343	eb 08		 jmp	 SHORT $LN44@con1052_ex
$LN43@con1052_ex:
  00345	c7 44 24 68 00
	00 00 00	 mov	 DWORD PTR tv179[rsp], 0
$LN44@con1052_ex:
  0034d	b9 01 00 00 00	 mov	 ecx, 1
  00352	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  00358	8b 4c 24 64	 mov	 ecx, DWORD PTR tv173[rsp]
  0035c	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  00360	8b 4c 24 68	 mov	 ecx, DWORD PTR tv179[rsp]
  00364	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  00368	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG177655
  0036f	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  00374	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG177656
  0037b	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00380	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00385	41 b9 03 00 00
	00		 mov	 r9d, 3
  0038b	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG177657
  00392	ba c5 01 00 00	 mov	 edx, 453		; 000001c5H
  00397	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG177658
  0039e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg
$LN28@con1052_ex:

; 454  : 
; 455  :             obtain_lock( &dev->lock );

  003a4	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  003ac	48 83 c0 38	 add	 rax, 56			; 00000038H
  003b0	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG177659
  003b7	48 8b c8	 mov	 rcx, rax
  003ba	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_obtain_lock

; 456  :             {
; 457  :                 dev->kbwaiters++;

  003c0	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  003c8	8b 80 d0 06 00
	00		 mov	 eax, DWORD PTR [rax+1744]
  003ce	ff c0		 inc	 eax
  003d0	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  003d8	89 81 d0 06 00
	00		 mov	 DWORD PTR [rcx+1744], eax

; 458  :                 wait_condition( &dev->kbcond, &dev->lock );

  003de	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  003e6	48 83 c0 38	 add	 rax, 56			; 00000038H
  003ea	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  003f2	48 81 c1 c8 06
	00 00		 add	 rcx, 1736		; 000006c8H
  003f9	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG177660
  00400	48 8b d0	 mov	 rdx, rax
  00403	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_wait_condition

; 459  :                 dev->kbwaiters--;

  00409	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00411	8b 80 d0 06 00
	00		 mov	 eax, DWORD PTR [rax+1744]
  00417	ff c8		 dec	 eax
  00419	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  00421	89 81 d0 06 00
	00		 mov	 DWORD PTR [rcx+1744], eax

; 460  :             }
; 461  :             release_lock( &dev->lock );

  00427	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  0042f	48 83 c0 38	 add	 rax, 56			; 00000038H
  00433	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG177661
  0043a	48 8b c8	 mov	 rcx, rax
  0043d	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_release_lock
$LN27@con1052_ex:

; 462  :         }
; 463  : 
; 464  :         /* Calculate number of bytes to move and residual byte count */
; 465  :         len = dev->keybdrem;

  00443	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  0044b	8b 80 c0 06 00
	00		 mov	 eax, DWORD PTR [rax+1728]
  00451	89 44 24 54	 mov	 DWORD PTR len$[rsp], eax

; 466  :         num = (count < len) ? count : len;

  00455	8b 44 24 54	 mov	 eax, DWORD PTR len$[rsp]
  00459	39 84 24 d0 00
	00 00		 cmp	 DWORD PTR count$[rsp], eax
  00460	73 0d		 jae	 SHORT $LN45@con1052_ex
  00462	8b 84 24 d0 00
	00 00		 mov	 eax, DWORD PTR count$[rsp]
  00469	89 44 24 6c	 mov	 DWORD PTR tv211[rsp], eax
  0046d	eb 08		 jmp	 SHORT $LN46@con1052_ex
$LN45@con1052_ex:
  0046f	8b 44 24 54	 mov	 eax, DWORD PTR len$[rsp]
  00473	89 44 24 6c	 mov	 DWORD PTR tv211[rsp], eax
$LN46@con1052_ex:
  00477	8b 44 24 6c	 mov	 eax, DWORD PTR tv211[rsp]
  0047b	89 44 24 58	 mov	 DWORD PTR num$[rsp], eax

; 467  :         *residual = count - num;

  0047f	8b 44 24 58	 mov	 eax, DWORD PTR num$[rsp]
  00483	8b 8c 24 d0 00
	00 00		 mov	 ecx, DWORD PTR count$[rsp]
  0048a	2b c8		 sub	 ecx, eax
  0048c	8b c1		 mov	 eax, ecx
  0048e	48 8b 8c 24 00
	01 00 00	 mov	 rcx, QWORD PTR residual$[rsp]
  00496	89 01		 mov	 DWORD PTR [rcx], eax

; 468  :         if (count < len) *more = 1;

  00498	8b 44 24 54	 mov	 eax, DWORD PTR len$[rsp]
  0049c	39 84 24 d0 00
	00 00		 cmp	 DWORD PTR count$[rsp], eax
  004a3	73 0b		 jae	 SHORT $LN29@con1052_ex
  004a5	48 8b 84 24 f0
	00 00 00	 mov	 rax, QWORD PTR more$[rsp]
  004ad	c6 00 01	 mov	 BYTE PTR [rax], 1
$LN29@con1052_ex:

; 469  : 
; 470  :         /* Copy data from device buffer to channel buffer */
; 471  :         memcpy( iobuf, dev->buf, num );

  004b0	8b 44 24 58	 mov	 eax, DWORD PTR num$[rsp]
  004b4	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  004bc	48 8b bc 24 e8
	00 00 00	 mov	 rdi, QWORD PTR iobuf$[rsp]
  004c4	48 8b b1 c8 01
	00 00		 mov	 rsi, QWORD PTR [rcx+456]
  004cb	8b c8		 mov	 ecx, eax
  004cd	f3 a4		 rep movsb

; 472  : 
; 473  :         /* If data chaining is specified, save remaining data */
; 474  :         if ((flags & CCW_FLAGS_CD) && len > count)

  004cf	0f b6 84 24 c0
	00 00 00	 movzx	 eax, BYTE PTR flags$[rsp]
  004d7	25 80 00 00 00	 and	 eax, 128		; 00000080H
  004dc	85 c0		 test	 eax, eax
  004de	74 6d		 je	 SHORT $LN30@con1052_ex
  004e0	8b 84 24 d0 00
	00 00		 mov	 eax, DWORD PTR count$[rsp]
  004e7	39 44 24 54	 cmp	 DWORD PTR len$[rsp], eax
  004eb	76 60		 jbe	 SHORT $LN30@con1052_ex

; 475  :         {
; 476  :             memmove( dev->buf, dev->buf + count, len - count );

  004ed	8b 84 24 d0 00
	00 00		 mov	 eax, DWORD PTR count$[rsp]
  004f4	8b 4c 24 54	 mov	 ecx, DWORD PTR len$[rsp]
  004f8	2b c8		 sub	 ecx, eax
  004fa	8b c1		 mov	 eax, ecx
  004fc	8b c0		 mov	 eax, eax
  004fe	8b 8c 24 d0 00
	00 00		 mov	 ecx, DWORD PTR count$[rsp]
  00505	48 8b 94 24 b0
	00 00 00	 mov	 rdx, QWORD PTR dev$[rsp]
  0050d	48 03 8a c8 01
	00 00		 add	 rcx, QWORD PTR [rdx+456]
  00514	44 8b c0	 mov	 r8d, eax
  00517	48 8b d1	 mov	 rdx, rcx
  0051a	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00522	48 8b 88 c8 01
	00 00		 mov	 rcx, QWORD PTR [rax+456]
  00529	e8 00 00 00 00	 call	 memmove

; 477  :             dev->keybdrem = len - count;

  0052e	8b 84 24 d0 00
	00 00		 mov	 eax, DWORD PTR count$[rsp]
  00535	8b 4c 24 54	 mov	 ecx, DWORD PTR len$[rsp]
  00539	2b c8		 sub	 ecx, eax
  0053b	8b c1		 mov	 eax, ecx
  0053d	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  00545	89 81 c0 06 00
	00		 mov	 DWORD PTR [rcx+1728], eax

; 478  :         }

  0054b	eb 12		 jmp	 SHORT $LN31@con1052_ex
$LN30@con1052_ex:

; 479  :         else
; 480  :         {
; 481  :             dev->keybdrem = 0;

  0054d	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00555	c7 80 c0 06 00
	00 00 00 00 00	 mov	 DWORD PTR [rax+1728], 0
$LN31@con1052_ex:

; 482  :         }
; 483  : 
; 484  :         /* Return normal status */
; 485  :         *unitstat = CSW_CE | CSW_DE;

  0055f	48 8b 84 24 f8
	00 00 00	 mov	 rax, QWORD PTR unitstat$[rsp]
  00567	c6 00 0c	 mov	 BYTE PTR [rax], 12

; 486  :         break;

  0056a	e9 e8 01 00 00	 jmp	 $LN11@con1052_ex
$LN32@con1052_ex:

; 487  : 
; 488  :     case 0x0B:
; 489  :     /*---------------------------------------------------------------*/
; 490  :     /* AUDIBLE ALARM                                                 */
; 491  :     /*---------------------------------------------------------------*/
; 492  :         // "RRR...RING...GGG!\a"
; 493  :         WRMSG( HHC00009, "I" );

  0056f	b9 01 00 00 00	 mov	 ecx, 1
  00574	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  0057a	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG177666
  00581	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  00586	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG177667
  0058d	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00592	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00597	41 b9 03 00 00
	00		 mov	 r9d, 3
  0059d	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG177668
  005a4	ba ed 01 00 00	 mov	 edx, 493		; 000001edH
  005a9	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG177669
  005b0	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 494  : 
; 495  :         // *residual = 0;
; 496  : 
; 497  :         *unitstat = CSW_CE | CSW_DE;

  005b6	48 8b 84 24 f8
	00 00 00	 mov	 rax, QWORD PTR unitstat$[rsp]
  005be	c6 00 0c	 mov	 BYTE PTR [rax], 12

; 498  :         break;

  005c1	e9 91 01 00 00	 jmp	 $LN11@con1052_ex
$LN33@con1052_ex:

; 499  : 
; 500  :     case 0x04:
; 501  :     /*---------------------------------------------------------------*/
; 502  :     /* SENSE                                                         */
; 503  :     /*---------------------------------------------------------------*/
; 504  :         /* Calculate residual byte count */
; 505  :         num = (count < dev->numsense) ? count : dev->numsense;

  005c6	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  005ce	8b 80 60 03 00
	00		 mov	 eax, DWORD PTR [rax+864]
  005d4	39 84 24 d0 00
	00 00		 cmp	 DWORD PTR count$[rsp], eax
  005db	73 0d		 jae	 SHORT $LN47@con1052_ex
  005dd	8b 84 24 d0 00
	00 00		 mov	 eax, DWORD PTR count$[rsp]
  005e4	89 44 24 70	 mov	 DWORD PTR tv249[rsp], eax
  005e8	eb 12		 jmp	 SHORT $LN48@con1052_ex
$LN47@con1052_ex:
  005ea	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  005f2	8b 80 60 03 00
	00		 mov	 eax, DWORD PTR [rax+864]
  005f8	89 44 24 70	 mov	 DWORD PTR tv249[rsp], eax
$LN48@con1052_ex:
  005fc	8b 44 24 70	 mov	 eax, DWORD PTR tv249[rsp]
  00600	89 44 24 58	 mov	 DWORD PTR num$[rsp], eax

; 506  :         *residual = count - num;

  00604	8b 44 24 58	 mov	 eax, DWORD PTR num$[rsp]
  00608	8b 8c 24 d0 00
	00 00		 mov	 ecx, DWORD PTR count$[rsp]
  0060f	2b c8		 sub	 ecx, eax
  00611	8b c1		 mov	 eax, ecx
  00613	48 8b 8c 24 00
	01 00 00	 mov	 rcx, QWORD PTR residual$[rsp]
  0061b	89 01		 mov	 DWORD PTR [rcx], eax

; 507  :         if (count < dev->numsense) *more = 1;

  0061d	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00625	8b 80 60 03 00
	00		 mov	 eax, DWORD PTR [rax+864]
  0062b	39 84 24 d0 00
	00 00		 cmp	 DWORD PTR count$[rsp], eax
  00632	73 0b		 jae	 SHORT $LN34@con1052_ex
  00634	48 8b 84 24 f0
	00 00 00	 mov	 rax, QWORD PTR more$[rsp]
  0063c	c6 00 01	 mov	 BYTE PTR [rax], 1
$LN34@con1052_ex:

; 508  : 
; 509  :         /* Copy device sense bytes to channel I/O buffer */
; 510  :         memcpy( iobuf, dev->sense, num );

  0063f	8b 44 24 58	 mov	 eax, DWORD PTR num$[rsp]
  00643	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  0064b	48 81 c1 64 03
	00 00		 add	 rcx, 868		; 00000364H
  00652	48 8b bc 24 e8
	00 00 00	 mov	 rdi, QWORD PTR iobuf$[rsp]
  0065a	48 8b f1	 mov	 rsi, rcx
  0065d	8b c8		 mov	 ecx, eax
  0065f	f3 a4		 rep movsb

; 511  : 
; 512  :         /* Clear the device sense bytes */
; 513  :         memset( dev->sense, 0, sizeof( dev->sense ));

  00661	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00669	48 05 64 03 00
	00		 add	 rax, 868		; 00000364H
  0066f	48 8b f8	 mov	 rdi, rax
  00672	33 c0		 xor	 eax, eax
  00674	b9 00 01 00 00	 mov	 ecx, 256		; 00000100H
  00679	f3 aa		 rep stosb

; 514  : 
; 515  :         /* Return unit status */
; 516  :         *unitstat = CSW_CE | CSW_DE;

  0067b	48 8b 84 24 f8
	00 00 00	 mov	 rax, QWORD PTR unitstat$[rsp]
  00683	c6 00 0c	 mov	 BYTE PTR [rax], 12

; 517  :         break;

  00686	e9 cc 00 00 00	 jmp	 $LN11@con1052_ex
$LN35@con1052_ex:

; 518  : 
; 519  :     case 0xE4:
; 520  :     /*---------------------------------------------------------------*/
; 521  :     /* SENSE ID                                                      */
; 522  :     /*---------------------------------------------------------------*/
; 523  :         /* Calculate residual byte count */
; 524  :         num = (count < dev->numdevid) ? count : dev->numdevid;

  0068b	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00693	8b 80 64 04 00
	00		 mov	 eax, DWORD PTR [rax+1124]
  00699	39 84 24 d0 00
	00 00		 cmp	 DWORD PTR count$[rsp], eax
  006a0	73 0d		 jae	 SHORT $LN49@con1052_ex
  006a2	8b 84 24 d0 00
	00 00		 mov	 eax, DWORD PTR count$[rsp]
  006a9	89 44 24 74	 mov	 DWORD PTR tv268[rsp], eax
  006ad	eb 12		 jmp	 SHORT $LN50@con1052_ex
$LN49@con1052_ex:
  006af	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  006b7	8b 80 64 04 00
	00		 mov	 eax, DWORD PTR [rax+1124]
  006bd	89 44 24 74	 mov	 DWORD PTR tv268[rsp], eax
$LN50@con1052_ex:
  006c1	8b 44 24 74	 mov	 eax, DWORD PTR tv268[rsp]
  006c5	89 44 24 58	 mov	 DWORD PTR num$[rsp], eax

; 525  :         *residual = count - num;

  006c9	8b 44 24 58	 mov	 eax, DWORD PTR num$[rsp]
  006cd	8b 8c 24 d0 00
	00 00		 mov	 ecx, DWORD PTR count$[rsp]
  006d4	2b c8		 sub	 ecx, eax
  006d6	8b c1		 mov	 eax, ecx
  006d8	48 8b 8c 24 00
	01 00 00	 mov	 rcx, QWORD PTR residual$[rsp]
  006e0	89 01		 mov	 DWORD PTR [rcx], eax

; 526  :         if (count < dev->numdevid) *more = 1;

  006e2	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  006ea	8b 80 64 04 00
	00		 mov	 eax, DWORD PTR [rax+1124]
  006f0	39 84 24 d0 00
	00 00		 cmp	 DWORD PTR count$[rsp], eax
  006f7	73 0b		 jae	 SHORT $LN36@con1052_ex
  006f9	48 8b 84 24 f0
	00 00 00	 mov	 rax, QWORD PTR more$[rsp]
  00701	c6 00 01	 mov	 BYTE PTR [rax], 1
$LN36@con1052_ex:

; 527  : 
; 528  :         /* Copy device identifier bytes to channel I/O buffer */
; 529  :         memcpy( iobuf, dev->devid, num );

  00704	8b 44 24 58	 mov	 eax, DWORD PTR num$[rsp]
  00708	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  00710	48 81 c1 68 04
	00 00		 add	 rcx, 1128		; 00000468H
  00717	48 8b bc 24 e8
	00 00 00	 mov	 rdi, QWORD PTR iobuf$[rsp]
  0071f	48 8b f1	 mov	 rsi, rcx
  00722	8b c8		 mov	 ecx, eax
  00724	f3 a4		 rep movsb

; 530  : 
; 531  :         /* Return unit status */
; 532  :         *unitstat = CSW_CE | CSW_DE;

  00726	48 8b 84 24 f8
	00 00 00	 mov	 rax, QWORD PTR unitstat$[rsp]
  0072e	c6 00 0c	 mov	 BYTE PTR [rax], 12

; 533  :         break;

  00731	eb 24		 jmp	 SHORT $LN11@con1052_ex
$LN37@con1052_ex:

; 534  : 
; 535  :     default:
; 536  :     /*---------------------------------------------------------------*/
; 537  :     /* INVALID OPERATION                                             */
; 538  :     /*---------------------------------------------------------------*/
; 539  :         /* Set command reject sense byte, and unit check status */
; 540  :         dev->sense[0] = SENSE_CR;

  00733	b8 01 00 00 00	 mov	 eax, 1
  00738	48 6b c0 00	 imul	 rax, rax, 0
  0073c	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  00744	c6 84 01 64 03
	00 00 80	 mov	 BYTE PTR [rcx+rax+868], 128 ; 00000080H

; 541  :         *unitstat = CSW_CE | CSW_DE | CSW_UC;

  0074c	48 8b 84 24 f8
	00 00 00	 mov	 rax, QWORD PTR unitstat$[rsp]
  00754	c6 00 0e	 mov	 BYTE PTR [rax], 14
$LN11@con1052_ex:
$LN1@con1052_ex:

; 542  : 
; 543  :     } /* end switch(code) */
; 544  : 
; 545  : } /* end function con1052_execute_ccw */

  00757	48 81 c4 98 00
	00 00		 add	 rsp, 152		; 00000098H
  0075e	5f		 pop	 rdi
  0075f	5e		 pop	 rsi
  00760	c3		 ret	 0
  00761	0f 1f 00	 npad	 3
$LN52@con1052_ex:
  00764	00 00 00 00	 DD	 $LN19@con1052_ex
  00768	00 00 00 00	 DD	 $LN25@con1052_ex
  0076c	00 00 00 00	 DD	 $LN33@con1052_ex
  00770	00 00 00 00	 DD	 $LN20@con1052_ex
  00774	00 00 00 00	 DD	 $LN26@con1052_ex
  00778	00 00 00 00	 DD	 $LN32@con1052_ex
  0077c	00 00 00 00	 DD	 $LN35@con1052_ex
  00780	00 00 00 00	 DD	 $LN37@con1052_ex
$LN51@con1052_ex:
  00784	00		 DB	 0
  00785	07		 DB	 7
  00786	01		 DB	 1
  00787	02		 DB	 2
  00788	07		 DB	 7
  00789	07		 DB	 7
  0078a	07		 DB	 7
  0078b	07		 DB	 7
  0078c	03		 DB	 3
  0078d	04		 DB	 4
  0078e	05		 DB	 5
  0078f	07		 DB	 7
  00790	07		 DB	 7
  00791	07		 DB	 7
  00792	07		 DB	 7
  00793	07		 DB	 7
  00794	07		 DB	 7
  00795	07		 DB	 7
  00796	07		 DB	 7
  00797	07		 DB	 7
  00798	07		 DB	 7
  00799	07		 DB	 7
  0079a	07		 DB	 7
  0079b	07		 DB	 7
  0079c	07		 DB	 7
  0079d	07		 DB	 7
  0079e	07		 DB	 7
  0079f	07		 DB	 7
  007a0	07		 DB	 7
  007a1	07		 DB	 7
  007a2	07		 DB	 7
  007a3	07		 DB	 7
  007a4	07		 DB	 7
  007a5	07		 DB	 7
  007a6	07		 DB	 7
  007a7	07		 DB	 7
  007a8	07		 DB	 7
  007a9	07		 DB	 7
  007aa	07		 DB	 7
  007ab	07		 DB	 7
  007ac	07		 DB	 7
  007ad	07		 DB	 7
  007ae	07		 DB	 7
  007af	07		 DB	 7
  007b0	07		 DB	 7
  007b1	07		 DB	 7
  007b2	07		 DB	 7
  007b3	07		 DB	 7
  007b4	07		 DB	 7
  007b5	07		 DB	 7
  007b6	07		 DB	 7
  007b7	07		 DB	 7
  007b8	07		 DB	 7
  007b9	07		 DB	 7
  007ba	07		 DB	 7
  007bb	07		 DB	 7
  007bc	07		 DB	 7
  007bd	07		 DB	 7
  007be	07		 DB	 7
  007bf	07		 DB	 7
  007c0	07		 DB	 7
  007c1	07		 DB	 7
  007c2	07		 DB	 7
  007c3	07		 DB	 7
  007c4	07		 DB	 7
  007c5	07		 DB	 7
  007c6	07		 DB	 7
  007c7	07		 DB	 7
  007c8	07		 DB	 7
  007c9	07		 DB	 7
  007ca	07		 DB	 7
  007cb	07		 DB	 7
  007cc	07		 DB	 7
  007cd	07		 DB	 7
  007ce	07		 DB	 7
  007cf	07		 DB	 7
  007d0	07		 DB	 7
  007d1	07		 DB	 7
  007d2	07		 DB	 7
  007d3	07		 DB	 7
  007d4	07		 DB	 7
  007d5	07		 DB	 7
  007d6	07		 DB	 7
  007d7	07		 DB	 7
  007d8	07		 DB	 7
  007d9	07		 DB	 7
  007da	07		 DB	 7
  007db	07		 DB	 7
  007dc	07		 DB	 7
  007dd	07		 DB	 7
  007de	07		 DB	 7
  007df	07		 DB	 7
  007e0	07		 DB	 7
  007e1	07		 DB	 7
  007e2	07		 DB	 7
  007e3	07		 DB	 7
  007e4	07		 DB	 7
  007e5	07		 DB	 7
  007e6	07		 DB	 7
  007e7	07		 DB	 7
  007e8	07		 DB	 7
  007e9	07		 DB	 7
  007ea	07		 DB	 7
  007eb	07		 DB	 7
  007ec	07		 DB	 7
  007ed	07		 DB	 7
  007ee	07		 DB	 7
  007ef	07		 DB	 7
  007f0	07		 DB	 7
  007f1	07		 DB	 7
  007f2	07		 DB	 7
  007f3	07		 DB	 7
  007f4	07		 DB	 7
  007f5	07		 DB	 7
  007f6	07		 DB	 7
  007f7	07		 DB	 7
  007f8	07		 DB	 7
  007f9	07		 DB	 7
  007fa	07		 DB	 7
  007fb	07		 DB	 7
  007fc	07		 DB	 7
  007fd	07		 DB	 7
  007fe	07		 DB	 7
  007ff	07		 DB	 7
  00800	07		 DB	 7
  00801	07		 DB	 7
  00802	07		 DB	 7
  00803	07		 DB	 7
  00804	07		 DB	 7
  00805	07		 DB	 7
  00806	07		 DB	 7
  00807	07		 DB	 7
  00808	07		 DB	 7
  00809	07		 DB	 7
  0080a	07		 DB	 7
  0080b	07		 DB	 7
  0080c	07		 DB	 7
  0080d	07		 DB	 7
  0080e	07		 DB	 7
  0080f	07		 DB	 7
  00810	07		 DB	 7
  00811	07		 DB	 7
  00812	07		 DB	 7
  00813	07		 DB	 7
  00814	07		 DB	 7
  00815	07		 DB	 7
  00816	07		 DB	 7
  00817	07		 DB	 7
  00818	07		 DB	 7
  00819	07		 DB	 7
  0081a	07		 DB	 7
  0081b	07		 DB	 7
  0081c	07		 DB	 7
  0081d	07		 DB	 7
  0081e	07		 DB	 7
  0081f	07		 DB	 7
  00820	07		 DB	 7
  00821	07		 DB	 7
  00822	07		 DB	 7
  00823	07		 DB	 7
  00824	07		 DB	 7
  00825	07		 DB	 7
  00826	07		 DB	 7
  00827	07		 DB	 7
  00828	07		 DB	 7
  00829	07		 DB	 7
  0082a	07		 DB	 7
  0082b	07		 DB	 7
  0082c	07		 DB	 7
  0082d	07		 DB	 7
  0082e	07		 DB	 7
  0082f	07		 DB	 7
  00830	07		 DB	 7
  00831	07		 DB	 7
  00832	07		 DB	 7
  00833	07		 DB	 7
  00834	07		 DB	 7
  00835	07		 DB	 7
  00836	07		 DB	 7
  00837	07		 DB	 7
  00838	07		 DB	 7
  00839	07		 DB	 7
  0083a	07		 DB	 7
  0083b	07		 DB	 7
  0083c	07		 DB	 7
  0083d	07		 DB	 7
  0083e	07		 DB	 7
  0083f	07		 DB	 7
  00840	07		 DB	 7
  00841	07		 DB	 7
  00842	07		 DB	 7
  00843	07		 DB	 7
  00844	07		 DB	 7
  00845	07		 DB	 7
  00846	07		 DB	 7
  00847	07		 DB	 7
  00848	07		 DB	 7
  00849	07		 DB	 7
  0084a	07		 DB	 7
  0084b	07		 DB	 7
  0084c	07		 DB	 7
  0084d	07		 DB	 7
  0084e	07		 DB	 7
  0084f	07		 DB	 7
  00850	07		 DB	 7
  00851	07		 DB	 7
  00852	07		 DB	 7
  00853	07		 DB	 7
  00854	07		 DB	 7
  00855	07		 DB	 7
  00856	07		 DB	 7
  00857	07		 DB	 7
  00858	07		 DB	 7
  00859	07		 DB	 7
  0085a	07		 DB	 7
  0085b	07		 DB	 7
  0085c	07		 DB	 7
  0085d	07		 DB	 7
  0085e	07		 DB	 7
  0085f	07		 DB	 7
  00860	07		 DB	 7
  00861	07		 DB	 7
  00862	07		 DB	 7
  00863	07		 DB	 7
  00864	07		 DB	 7
  00865	07		 DB	 7
  00866	07		 DB	 7
  00867	06		 DB	 6
con1052_execute_ccw ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\con1052c.c
_TEXT	SEGMENT
i$ = 64
tv150 = 68
dev$ = 72
pfxlen$ = 80
input$ = 88
next_panel_command_handler$ = 96
cmd$ = 128
con1052_panel_command PROC

; 285  : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 78	 sub	 rsp, 120		; 00000078H

; 286  :     DEVBLK  *dev;
; 287  :     char    *input;
; 288  :     int      i;
; 289  :     size_t   pfxlen;
; 290  : 
; 291  :     void* (*next_panel_command_handler)( char *cmd );
; 292  : 
; 293  :     /* Scan device chain looking for integrated console printer keyboard
; 294  :        devices whose command prefix string (kept in dev->filename field)
; 295  :        matches the command prefix used in the command that was entered.
; 296  :     */
; 297  :     for (dev = sysblk.firstdev; dev; dev = dev->nextdev)

  00009	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00010	48 8b 80 c0 11
	00 00		 mov	 rax, QWORD PTR [rax+4544]
  00017	48 89 44 24 48	 mov	 QWORD PTR dev$[rsp], rax
  0001c	eb 0e		 jmp	 SHORT $LN4@con1052_pa
$LN2@con1052_pa:
  0001e	48 8b 44 24 48	 mov	 rax, QWORD PTR dev$[rsp]
  00023	48 8b 40 30	 mov	 rax, QWORD PTR [rax+48]
  00027	48 89 44 24 48	 mov	 QWORD PTR dev$[rsp], rax
$LN4@con1052_pa:
  0002c	48 83 7c 24 48
	00		 cmp	 QWORD PTR dev$[rsp], 0
  00032	0f 84 2a 02 00
	00		 je	 $LN3@con1052_pa

; 298  :     {
; 299  :         if (1
; 300  :             && dev->allocated
; 301  :             && dev->hnd == &con1052_device_hndinfo
; 302  :             && (pfxlen = strlen( dev->filename )) > 0
; 303  :             && strncasecmp( cmd, dev->filename, pfxlen ) == 0

  00038	33 c0		 xor	 eax, eax
  0003a	83 f8 01	 cmp	 eax, 1
  0003d	0f 84 1a 02 00
	00		 je	 $LN8@con1052_pa
  00043	48 8b 44 24 48	 mov	 rax, QWORD PTR dev$[rsp]
  00048	83 78 40 00	 cmp	 DWORD PTR [rax+64], 0
  0004c	0f 84 0b 02 00
	00		 je	 $LN8@con1052_pa
  00052	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:con1052_device_hndinfo
  00059	48 8b 4c 24 48	 mov	 rcx, QWORD PTR dev$[rsp]
  0005e	48 39 81 90 02
	00 00		 cmp	 QWORD PTR [rcx+656], rax
  00065	0f 85 f2 01 00
	00		 jne	 $LN8@con1052_pa
  0006b	48 8b 44 24 48	 mov	 rax, QWORD PTR dev$[rsp]
  00070	48 05 a4 00 00
	00		 add	 rax, 164		; 000000a4H
  00076	48 8b c8	 mov	 rcx, rax
  00079	e8 00 00 00 00	 call	 strlen
  0007e	48 89 44 24 50	 mov	 QWORD PTR pfxlen$[rsp], rax
  00083	48 83 7c 24 50
	00		 cmp	 QWORD PTR pfxlen$[rsp], 0
  00089	0f 86 ce 01 00
	00		 jbe	 $LN8@con1052_pa
  0008f	48 8b 44 24 48	 mov	 rax, QWORD PTR dev$[rsp]
  00094	48 05 a4 00 00
	00		 add	 rax, 164		; 000000a4H
  0009a	4c 8b 44 24 50	 mov	 r8, QWORD PTR pfxlen$[rsp]
  0009f	48 8b d0	 mov	 rdx, rax
  000a2	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR cmd$[rsp]
  000aa	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__strnicmp
  000b0	85 c0		 test	 eax, eax
  000b2	0f 85 a5 01 00
	00		 jne	 $LN8@con1052_pa

; 304  :         )
; 305  :         {
; 306  :             /* Echo that they typed to the Hercules console */
; 307  :             LOGMSG( "%s%s\n", "", cmd );

  000b8	b9 01 00 00 00	 mov	 ecx, 1
  000bd	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  000c3	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR cmd$[rsp]
  000cb	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  000d0	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG177584
  000d7	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  000dc	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG177585
  000e3	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  000e8	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  000ed	41 b9 03 00 00
	00		 mov	 r9d, 3
  000f3	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG177586
  000fa	ba 33 01 00 00	 mov	 edx, 307		; 00000133H
  000ff	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG177587
  00106	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 308  : 
; 309  :             /* Convert ASCII input to EBCDIC */
; 310  :             input = cmd + pfxlen;

  0010c	48 8b 44 24 50	 mov	 rax, QWORD PTR pfxlen$[rsp]
  00111	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR cmd$[rsp]
  00119	48 03 c8	 add	 rcx, rax
  0011c	48 8b c1	 mov	 rax, rcx
  0011f	48 89 44 24 58	 mov	 QWORD PTR input$[rsp], rax

; 311  : 
; 312  :             for (i=0; i < dev->bufsize && input[i] != '\0'; i++)

  00124	c7 44 24 40 00
	00 00 00	 mov	 DWORD PTR i$[rsp], 0
  0012c	eb 0a		 jmp	 SHORT $LN7@con1052_pa
$LN5@con1052_pa:
  0012e	8b 44 24 40	 mov	 eax, DWORD PTR i$[rsp]
  00132	ff c0		 inc	 eax
  00134	89 44 24 40	 mov	 DWORD PTR i$[rsp], eax
$LN7@con1052_pa:
  00138	48 8b 44 24 48	 mov	 rax, QWORD PTR dev$[rsp]
  0013d	8b 80 d8 01 00
	00		 mov	 eax, DWORD PTR [rax+472]
  00143	39 44 24 40	 cmp	 DWORD PTR i$[rsp], eax
  00147	7d 6f		 jge	 SHORT $LN6@con1052_pa
  00149	48 63 44 24 40	 movsxd	 rax, DWORD PTR i$[rsp]
  0014e	48 8b 4c 24 58	 mov	 rcx, QWORD PTR input$[rsp]
  00153	0f be 04 01	 movsx	 eax, BYTE PTR [rcx+rax]
  00157	85 c0		 test	 eax, eax
  00159	74 5d		 je	 SHORT $LN6@con1052_pa

; 313  :                 dev->buf[i] = isprint( input[i] ) ?

  0015b	48 63 44 24 40	 movsxd	 rax, DWORD PTR i$[rsp]
  00160	48 8b 4c 24 58	 mov	 rcx, QWORD PTR input$[rsp]
  00165	0f be 04 01	 movsx	 eax, BYTE PTR [rcx+rax]
  00169	8b c8		 mov	 ecx, eax
  0016b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_isprint
  00171	85 c0		 test	 eax, eax
  00173	74 1d		 je	 SHORT $LN13@con1052_pa
  00175	48 63 44 24 40	 movsxd	 rax, DWORD PTR i$[rsp]
  0017a	48 8b 4c 24 58	 mov	 rcx, QWORD PTR input$[rsp]
  0017f	0f b6 0c 01	 movzx	 ecx, BYTE PTR [rcx+rax]
  00183	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_host_to_guest
  00189	0f b6 c0	 movzx	 eax, al
  0018c	89 44 24 44	 mov	 DWORD PTR tv150[rsp], eax
  00190	eb 08		 jmp	 SHORT $LN14@con1052_pa
$LN13@con1052_pa:
  00192	c7 44 24 44 20
	00 00 00	 mov	 DWORD PTR tv150[rsp], 32 ; 00000020H
$LN14@con1052_pa:
  0019a	48 63 44 24 40	 movsxd	 rax, DWORD PTR i$[rsp]
  0019f	48 8b 4c 24 48	 mov	 rcx, QWORD PTR dev$[rsp]
  001a4	48 8b 89 c8 01
	00 00		 mov	 rcx, QWORD PTR [rcx+456]
  001ab	0f b6 54 24 44	 movzx	 edx, BYTE PTR tv150[rsp]
  001b0	88 14 01	 mov	 BYTE PTR [rcx+rax], dl
  001b3	e9 76 ff ff ff	 jmp	 $LN5@con1052_pa
$LN6@con1052_pa:

; 314  :                         host_to_guest( input[i] ) : ' ';
; 315  : 
; 316  :             /* Update number of bytes in keyboard buffer */
; 317  :             dev->keybdrem = i;

  001b8	48 8b 44 24 48	 mov	 rax, QWORD PTR dev$[rsp]
  001bd	8b 4c 24 40	 mov	 ecx, DWORD PTR i$[rsp]
  001c1	89 88 c0 06 00
	00		 mov	 DWORD PTR [rax+1728], ecx

; 318  :             dev->buflen   = i;

  001c7	48 8b 44 24 48	 mov	 rax, QWORD PTR dev$[rsp]
  001cc	8b 4c 24 40	 mov	 ecx, DWORD PTR i$[rsp]
  001d0	89 88 dc 01 00
	00		 mov	 DWORD PTR [rax+476], ecx

; 319  : 
; 320  :             /* Wakup the channel if it's waiting for input
; 321  :                or present unsolicited attention interrupt.
; 322  :             */
; 323  :             obtain_lock( &dev->lock );

  001d6	48 8b 44 24 48	 mov	 rax, QWORD PTR dev$[rsp]
  001db	48 83 c0 38	 add	 rax, 56			; 00000038H
  001df	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG177588
  001e6	48 8b c8	 mov	 rcx, rax
  001e9	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_obtain_lock

; 324  : 
; 325  :             if (dev->kbwaiters)

  001ef	48 8b 44 24 48	 mov	 rax, QWORD PTR dev$[rsp]
  001f4	83 b8 d0 06 00
	00 00		 cmp	 DWORD PTR [rax+1744], 0
  001fb	74 36		 je	 SHORT $LN9@con1052_pa

; 326  :             {
; 327  :                 signal_condition( &dev->kbcond );

  001fd	48 8b 44 24 48	 mov	 rax, QWORD PTR dev$[rsp]
  00202	48 05 c8 06 00
	00		 add	 rax, 1736		; 000006c8H
  00208	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG177591
  0020f	48 8b c8	 mov	 rcx, rax
  00212	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_signal_condition

; 328  :                 release_lock( &dev->lock );

  00218	48 8b 44 24 48	 mov	 rax, QWORD PTR dev$[rsp]
  0021d	48 83 c0 38	 add	 rax, 56			; 00000038H
  00221	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG177592
  00228	48 8b c8	 mov	 rcx, rax
  0022b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_release_lock

; 329  :             }

  00231	eb 26		 jmp	 SHORT $LN10@con1052_pa
$LN9@con1052_pa:

; 330  :             else
; 331  :             {
; 332  :                 release_lock( &dev->lock );

  00233	48 8b 44 24 48	 mov	 rax, QWORD PTR dev$[rsp]
  00238	48 83 c0 38	 add	 rax, 56			; 00000038H
  0023c	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG177593
  00243	48 8b c8	 mov	 rcx, rax
  00246	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_release_lock

; 333  :                 device_attention( dev, CSW_ATTN );

  0024c	b2 80		 mov	 dl, 128			; 00000080H
  0024e	48 8b 4c 24 48	 mov	 rcx, QWORD PTR dev$[rsp]
  00253	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_device_attention
$LN10@con1052_pa:

; 334  :             }
; 335  :             return NULL;

  00259	33 c0		 xor	 eax, eax
  0025b	eb 2f		 jmp	 SHORT $LN1@con1052_pa
$LN8@con1052_pa:

; 336  :         }
; 337  :     }

  0025d	e9 bc fd ff ff	 jmp	 $LN2@con1052_pa
$LN3@con1052_pa:

; 338  : 
; 339  :     /* The entered command wasn't meant for us. Pass it
; 340  :        on to the next command handler, if there is one.
; 341  :     */
; 342  :     next_panel_command_handler = hdl_next( &con1052_panel_command );

  00262	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:con1052_panel_command
  00269	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hdl_next
  0026f	48 89 44 24 60	 mov	 QWORD PTR next_panel_command_handler$[rsp], rax

; 343  : 
; 344  :     if (next_panel_command_handler)

  00274	48 83 7c 24 60
	00		 cmp	 QWORD PTR next_panel_command_handler$[rsp], 0
  0027a	74 0e		 je	 SHORT $LN11@con1052_pa

; 345  :         return next_panel_command_handler( cmd );

  0027c	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR cmd$[rsp]
  00284	ff 54 24 60	 call	 QWORD PTR next_panel_command_handler$[rsp]
  00288	eb 02		 jmp	 SHORT $LN1@con1052_pa
$LN11@con1052_pa:

; 346  : 
; 347  :     return NULL;

  0028a	33 c0		 xor	 eax, eax
$LN1@con1052_pa:

; 348  : }

  0028c	48 83 c4 78	 add	 rsp, 120		; 00000078H
  00290	c3		 ret	 0
con1052_panel_command ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\con1052c.c
_TEXT	SEGMENT
ac$ = 96
their_dev$ = 104
tv194 = 112
tv200 = 116
p$ = 120
our_dev$ = 128
i$ = 136
tv246 = 144
tv250 = 148
tv253 = 152
tv257 = 156
their_pfx$ = 160
our_pfx$ = 168
their_pfxlen$ = 176
our_pfxlen$ = 184
tv238 = 192
shorter_pfxlen$ = 200
dev$ = 224
argc$ = 232
argv$ = 240
con1052_init_handler PROC

; 150  : {

  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00009	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000e	48 81 ec d8 00
	00 00		 sub	 rsp, 216		; 000000d8H

; 151  :     int      ac;
; 152  :     DEVBLK  *our_dev, *their_dev;
; 153  :     char    *our_pfx, *their_pfx, *p;
; 154  :     size_t   our_pfxlen, their_pfxlen, shorter_pfxlen, i;
; 155  : 
; 156  :     /* For re-initialisation, close the existing file, if any */
; 157  :     if (dev->fd >= 0)

  00015	48 8b 84 24 e0
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  0001d	83 b8 ac 01 00
	00 00		 cmp	 DWORD PTR [rax+428], 0
  00024	7c 1a		 jl	 SHORT $LN8@con1052_in

; 158  :         (dev->hnd->close)( dev );

  00026	48 8b 84 24 e0
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  0002e	48 8b 80 90 02
	00 00		 mov	 rax, QWORD PTR [rax+656]
  00035	48 8b 8c 24 e0
	00 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  0003d	ff 50 10	 call	 QWORD PTR [rax+16]
$LN8@con1052_in:

; 159  : 
; 160  :     /* reset excp count */
; 161  :     dev->excps = 0;

  00040	48 8b 84 24 e0
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00048	48 c7 80 00 06
	00 00 00 00 00
	00		 mov	 QWORD PTR [rax+1536], 0

; 162  : 
; 163  :     /* Integrated console is always connected */
; 164  :     dev->connected = 1;

  00053	48 8b 84 24 e0
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  0005b	8b 80 f8 05 00
	00		 mov	 eax, DWORD PTR [rax+1528]
  00061	83 c8 20	 or	 eax, 32			; 00000020H
  00064	48 8b 8c 24 e0
	00 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  0006c	89 81 f8 05 00
	00		 mov	 DWORD PTR [rcx+1528], eax

; 165  : 
; 166  :     /* Set number of sense bytes */
; 167  :     dev->numsense = 1;

  00072	48 8b 84 24 e0
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  0007a	c7 80 60 03 00
	00 01 00 00 00	 mov	 DWORD PTR [rax+864], 1

; 168  : 
; 169  :     /* Initialize device dependent fields */
; 170  :     dev->keybdrem = 0;

  00084	48 8b 84 24 e0
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  0008c	c7 80 c0 06 00
	00 00 00 00 00	 mov	 DWORD PTR [rax+1728], 0

; 171  : 
; 172  :     /* Set length of console buffer reserving extra room for
; 173  :        possible newline character and null string terminator.
; 174  :     */
; 175  :     dev->bufsize = BUFLEN_1052 +1 +1;

  00096	48 8b 84 24 e0
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  0009e	c7 80 d8 01 00
	00 98 00 00 00	 mov	 DWORD PTR [rax+472], 152 ; 00000098H

; 176  : 
; 177  :     /* Assume we want to prompt */
; 178  :     dev->prompt1052 = 1;

  000a8	48 8b 84 24 e0
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  000b0	8b 80 d4 06 00
	00		 mov	 eax, DWORD PTR [rax+1748]
  000b6	83 c8 04	 or	 eax, 4
  000b9	48 8b 8c 24 e0
	00 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  000c1	89 81 d4 06 00
	00		 mov	 DWORD PTR [rcx+1748], eax

; 179  : 
; 180  :     /* Initialize command prefix string to undefined */
; 181  :     STRLCPY( dev->filename, "" );

  000c7	48 8b 84 24 e0
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  000cf	48 05 a4 00 00
	00		 add	 rax, 164		; 000000a4H
  000d5	41 b8 05 01 00
	00		 mov	 r8d, 261		; 00000105H
  000db	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG177545
  000e2	48 8b c8	 mov	 rcx, rax
  000e5	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_strlcpy

; 182  : 
; 183  :     /* Determine device type. Default to 1052 */
; 184  :     if (!sscanf( dev->typname, "%hx", &dev->devtype))

  000eb	48 8b 84 24 e0
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  000f3	48 83 c0 4a	 add	 rax, 74			; 0000004aH
  000f7	4c 8b c0	 mov	 r8, rax
  000fa	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG177547
  00101	48 8b 84 24 e0
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00109	48 8b 48 50	 mov	 rcx, QWORD PTR [rax+80]
  0010d	e8 00 00 00 00	 call	 sscanf
  00112	85 c0		 test	 eax, eax
  00114	75 11		 jne	 SHORT $LN9@con1052_in

; 185  :         dev->devtype = 0x1052;

  00116	b8 52 10 00 00	 mov	 eax, 4178		; 00001052H
  0011b	48 8b 8c 24 e0
	00 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  00123	66 89 41 4a	 mov	 WORD PTR [rcx+74], ax
$LN9@con1052_in:

; 186  : 
; 187  :     /* Initialize the device identifier bytes */
; 188  :     dev->devid[0] = 0xFF;

  00127	b8 01 00 00 00	 mov	 eax, 1
  0012c	48 6b c0 00	 imul	 rax, rax, 0
  00130	48 8b 8c 24 e0
	00 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  00138	c6 84 01 68 04
	00 00 ff	 mov	 BYTE PTR [rcx+rax+1128], 255 ; 000000ffH

; 189  :     dev->devid[1] = dev->devtype >> 8;

  00140	48 8b 84 24 e0
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00148	0f b7 40 4a	 movzx	 eax, WORD PTR [rax+74]
  0014c	c1 f8 08	 sar	 eax, 8
  0014f	b9 01 00 00 00	 mov	 ecx, 1
  00154	48 6b c9 01	 imul	 rcx, rcx, 1
  00158	48 8b 94 24 e0
	00 00 00	 mov	 rdx, QWORD PTR dev$[rsp]
  00160	88 84 0a 68 04
	00 00		 mov	 BYTE PTR [rdx+rcx+1128], al

; 190  :     dev->devid[2] = dev->devtype & 0xFF;

  00167	48 8b 84 24 e0
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  0016f	0f b7 40 4a	 movzx	 eax, WORD PTR [rax+74]
  00173	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  00178	b9 01 00 00 00	 mov	 ecx, 1
  0017d	48 6b c9 02	 imul	 rcx, rcx, 2
  00181	48 8b 94 24 e0
	00 00 00	 mov	 rdx, QWORD PTR dev$[rsp]
  00189	88 84 0a 68 04
	00 00		 mov	 BYTE PTR [rdx+rcx+1128], al

; 191  :     dev->devid[3] = 0x00;

  00190	b8 01 00 00 00	 mov	 eax, 1
  00195	48 6b c0 03	 imul	 rax, rax, 3
  00199	48 8b 8c 24 e0
	00 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  001a1	c6 84 01 68 04
	00 00 00	 mov	 BYTE PTR [rcx+rax+1128], 0

; 192  :     dev->devid[4] = dev->devtype >> 8;

  001a9	48 8b 84 24 e0
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  001b1	0f b7 40 4a	 movzx	 eax, WORD PTR [rax+74]
  001b5	c1 f8 08	 sar	 eax, 8
  001b8	b9 01 00 00 00	 mov	 ecx, 1
  001bd	48 6b c9 04	 imul	 rcx, rcx, 4
  001c1	48 8b 94 24 e0
	00 00 00	 mov	 rdx, QWORD PTR dev$[rsp]
  001c9	88 84 0a 68 04
	00 00		 mov	 BYTE PTR [rdx+rcx+1128], al

; 193  :     dev->devid[5] = dev->devtype & 0xFF;

  001d0	48 8b 84 24 e0
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  001d8	0f b7 40 4a	 movzx	 eax, WORD PTR [rax+74]
  001dc	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  001e1	b9 01 00 00 00	 mov	 ecx, 1
  001e6	48 6b c9 05	 imul	 rcx, rcx, 5
  001ea	48 8b 94 24 e0
	00 00 00	 mov	 rdx, QWORD PTR dev$[rsp]
  001f2	88 84 0a 68 04
	00 00		 mov	 BYTE PTR [rdx+rcx+1128], al

; 194  :     dev->devid[6] = 0x00;

  001f9	b8 01 00 00 00	 mov	 eax, 1
  001fe	48 6b c0 06	 imul	 rax, rax, 6
  00202	48 8b 8c 24 e0
	00 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  0020a	c6 84 01 68 04
	00 00 00	 mov	 BYTE PTR [rcx+rax+1128], 0

; 195  :     dev->numdevid = 7;

  00212	48 8b 84 24 e0
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  0021a	c7 80 64 04 00
	00 07 00 00 00	 mov	 DWORD PTR [rax+1124], 7

; 196  : 
; 197  :     /* Process optional arguments */
; 198  :     for (ac=0; argc > 0; ac++, argc--)

  00224	c7 44 24 60 00
	00 00 00	 mov	 DWORD PTR ac$[rsp], 0
  0022c	eb 1a		 jmp	 SHORT $LN4@con1052_in
$LN2@con1052_in:
  0022e	8b 44 24 60	 mov	 eax, DWORD PTR ac$[rsp]
  00232	ff c0		 inc	 eax
  00234	89 44 24 60	 mov	 DWORD PTR ac$[rsp], eax
  00238	8b 84 24 e8 00
	00 00		 mov	 eax, DWORD PTR argc$[rsp]
  0023f	ff c8		 dec	 eax
  00241	89 84 24 e8 00
	00 00		 mov	 DWORD PTR argc$[rsp], eax
$LN4@con1052_in:
  00248	83 bc 24 e8 00
	00 00 00	 cmp	 DWORD PTR argc$[rsp], 0
  00250	7e 74		 jle	 SHORT $LN3@con1052_in

; 199  :     {
; 200  :         if (strcasecmp( argv[ac], "noprompt" ) == 0)

  00252	48 63 44 24 60	 movsxd	 rax, DWORD PTR ac$[rsp]
  00257	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG177550
  0025e	48 8b 8c 24 f0
	00 00 00	 mov	 rcx, QWORD PTR argv$[rsp]
  00266	48 8b 0c c1	 mov	 rcx, QWORD PTR [rcx+rax*8]
  0026a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__stricmp
  00270	85 c0		 test	 eax, eax
  00272	75 21		 jne	 SHORT $LN10@con1052_in

; 201  :             dev->prompt1052 = 0;

  00274	48 8b 84 24 e0
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  0027c	8b 80 d4 06 00
	00		 mov	 eax, DWORD PTR [rax+1748]
  00282	83 e0 fb	 and	 eax, -5			; fffffffbH
  00285	48 8b 8c 24 e0
	00 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  0028d	89 81 d4 06 00
	00		 mov	 DWORD PTR [rcx+1748], eax
  00293	eb 2c		 jmp	 SHORT $LN11@con1052_in
$LN10@con1052_in:

; 202  :         else
; 203  :             STRLCPY( dev->filename, argv[ac] );

  00295	48 63 44 24 60	 movsxd	 rax, DWORD PTR ac$[rsp]
  0029a	48 8b 8c 24 e0
	00 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  002a2	48 81 c1 a4 00
	00 00		 add	 rcx, 164		; 000000a4H
  002a9	41 b8 05 01 00
	00		 mov	 r8d, 261		; 00000105H
  002af	48 8b 94 24 f0
	00 00 00	 mov	 rdx, QWORD PTR argv$[rsp]
  002b7	48 8b 14 c2	 mov	 rdx, QWORD PTR [rdx+rax*8]
  002bb	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_strlcpy
$LN11@con1052_in:

; 204  :     }

  002c1	e9 68 ff ff ff	 jmp	 $LN2@con1052_in
$LN3@con1052_in:

; 205  : 
; 206  :     /* Set default command prefix if one wasn't specified */
; 207  :     if (!dev->filename[0])

  002c6	b8 01 00 00 00	 mov	 eax, 1
  002cb	48 6b c0 00	 imul	 rax, rax, 0
  002cf	48 8b 8c 24 e0
	00 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  002d7	0f be 84 01 a4
	00 00 00	 movsx	 eax, BYTE PTR [rcx+rax+164]
  002df	85 c0		 test	 eax, eax
  002e1	0f 85 44 01 00
	00		 jne	 $LN12@con1052_in

; 208  :     {
; 209  :         p = memchr( used_pfxs, 0, sizeof( used_pfxs ));

  002e7	41 b8 16 00 00
	00		 mov	 r8d, 22
  002ed	33 d2		 xor	 edx, edx
  002ef	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:used_pfxs
  002f6	e8 00 00 00 00	 call	 memchr
  002fb	48 89 44 24 78	 mov	 QWORD PTR p$[rsp], rax

; 210  : 
; 211  :         if (!p)

  00300	48 83 7c 24 78
	00		 cmp	 QWORD PTR p$[rsp], 0
  00306	0f 85 ad 00 00
	00		 jne	 $LN13@con1052_in

; 212  :         {
; 213  :             // "%1d:%04X COMM: default command prefixes exhausted"
; 214  :             WRMSG( HHC01085, "E", LCSS_DEVNUM );

  0030c	48 83 bc 24 e0
	00 00 00 00	 cmp	 QWORD PTR dev$[rsp], 0
  00315	74 12		 je	 SHORT $LN18@con1052_in
  00317	48 8b 84 24 e0
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  0031f	0f b7 40 48	 movzx	 eax, WORD PTR [rax+72]
  00323	89 44 24 70	 mov	 DWORD PTR tv194[rsp], eax
  00327	eb 08		 jmp	 SHORT $LN19@con1052_in
$LN18@con1052_in:
  00329	c7 44 24 70 00
	00 00 00	 mov	 DWORD PTR tv194[rsp], 0
$LN19@con1052_in:
  00331	48 83 bc 24 e0
	00 00 00 00	 cmp	 QWORD PTR dev$[rsp], 0
  0033a	74 14		 je	 SHORT $LN20@con1052_in
  0033c	48 8b 84 24 e0
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00344	0f b7 40 44	 movzx	 eax, WORD PTR [rax+68]
  00348	d1 f8		 sar	 eax, 1
  0034a	89 44 24 74	 mov	 DWORD PTR tv200[rsp], eax
  0034e	eb 08		 jmp	 SHORT $LN21@con1052_in
$LN20@con1052_in:
  00350	c7 44 24 74 00
	00 00 00	 mov	 DWORD PTR tv200[rsp], 0
$LN21@con1052_in:
  00358	b9 01 00 00 00	 mov	 ecx, 1
  0035d	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  00363	8b 4c 24 70	 mov	 ecx, DWORD PTR tv194[rsp]
  00367	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  0036b	8b 4c 24 74	 mov	 ecx, DWORD PTR tv200[rsp]
  0036f	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  00373	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG177553
  0037a	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  0037f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG177554
  00386	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  0038b	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00390	41 b9 03 00 00
	00		 mov	 r9d, 3
  00396	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG177555
  0039d	ba d6 00 00 00	 mov	 edx, 214		; 000000d6H
  003a2	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG177556
  003a9	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 215  :             return -1;

  003af	b8 ff ff ff ff	 mov	 eax, -1
  003b4	e9 04 03 00 00	 jmp	 $LN1@con1052_in
$LN13@con1052_in:

; 216  :         }
; 217  : 
; 218  :         i = (p - used_pfxs);

  003b9	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:used_pfxs
  003c0	48 8b 4c 24 78	 mov	 rcx, QWORD PTR p$[rsp]
  003c5	48 2b c8	 sub	 rcx, rax
  003c8	48 8b c1	 mov	 rax, rcx
  003cb	48 89 84 24 88
	00 00 00	 mov	 QWORD PTR i$[rsp], rax

; 219  :         used_pfxs[i] = TRUE;

  003d3	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:used_pfxs
  003da	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR i$[rsp]
  003e2	c6 04 08 01	 mov	 BYTE PTR [rax+rcx], 1

; 220  :         dev->filename[0] = default_pfxs[i];

  003e6	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:default_pfxs
  003ed	b9 01 00 00 00	 mov	 ecx, 1
  003f2	48 6b c9 00	 imul	 rcx, rcx, 0
  003f6	48 8b 94 24 e0
	00 00 00	 mov	 rdx, QWORD PTR dev$[rsp]
  003fe	4c 8b 84 24 88
	00 00 00	 mov	 r8, QWORD PTR i$[rsp]
  00406	42 0f b6 04 00	 movzx	 eax, BYTE PTR [rax+r8]
  0040b	88 84 0a a4 00
	00 00		 mov	 BYTE PTR [rdx+rcx+164], al

; 221  :         dev->filename[1] = 0;

  00412	b8 01 00 00 00	 mov	 eax, 1
  00417	48 6b c0 01	 imul	 rax, rax, 1
  0041b	48 8b 8c 24 e0
	00 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  00423	c6 84 01 a4 00
	00 00 00	 mov	 BYTE PTR [rcx+rax+164], 0
$LN12@con1052_in:

; 222  :     }
; 223  : 
; 224  :     /* Check if valid command prefix: cannot be a subset or superset
; 225  :        of any other console printer keyboard device's command prefix.
; 226  :     */
; 227  :     our_dev     = dev;

  0042b	48 8b 84 24 e0
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00433	48 89 84 24 80
	00 00 00	 mov	 QWORD PTR our_dev$[rsp], rax

; 228  :     our_pfx     = our_dev->filename;

  0043b	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR our_dev$[rsp]
  00443	48 05 a4 00 00
	00		 add	 rax, 164		; 000000a4H
  00449	48 89 84 24 a8
	00 00 00	 mov	 QWORD PTR our_pfx$[rsp], rax

; 229  :     our_pfxlen  = strlen( our_pfx );

  00451	48 8b 8c 24 a8
	00 00 00	 mov	 rcx, QWORD PTR our_pfx$[rsp]
  00459	e8 00 00 00 00	 call	 strlen
  0045e	48 89 84 24 b8
	00 00 00	 mov	 QWORD PTR our_pfxlen$[rsp], rax

; 230  : 
; 231  :     for (their_dev = sysblk.firstdev; their_dev; their_dev = their_dev->nextdev)

  00466	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  0046d	48 8b 80 c0 11
	00 00		 mov	 rax, QWORD PTR [rax+4544]
  00474	48 89 44 24 68	 mov	 QWORD PTR their_dev$[rsp], rax
  00479	eb 0e		 jmp	 SHORT $LN7@con1052_in
$LN5@con1052_in:
  0047b	48 8b 44 24 68	 mov	 rax, QWORD PTR their_dev$[rsp]
  00480	48 8b 40 30	 mov	 rax, QWORD PTR [rax+48]
  00484	48 89 44 24 68	 mov	 QWORD PTR their_dev$[rsp], rax
$LN7@con1052_in:
  00489	48 83 7c 24 68
	00		 cmp	 QWORD PTR their_dev$[rsp], 0
  0048f	0f 84 b1 01 00
	00		 je	 $LN6@con1052_in

; 232  :     {
; 233  :         if (1
; 234  :             && their_dev != our_dev
; 235  :             && their_dev->allocated
; 236  :             && their_dev->hnd == &con1052_device_hndinfo

  00495	33 c0		 xor	 eax, eax
  00497	83 f8 01	 cmp	 eax, 1
  0049a	0f 84 a1 01 00
	00		 je	 $LN14@con1052_in
  004a0	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR our_dev$[rsp]
  004a8	48 39 44 24 68	 cmp	 QWORD PTR their_dev$[rsp], rax
  004ad	0f 84 8e 01 00
	00		 je	 $LN14@con1052_in
  004b3	48 8b 44 24 68	 mov	 rax, QWORD PTR their_dev$[rsp]
  004b8	83 78 40 00	 cmp	 DWORD PTR [rax+64], 0
  004bc	0f 84 7f 01 00
	00		 je	 $LN14@con1052_in
  004c2	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:con1052_device_hndinfo
  004c9	48 8b 4c 24 68	 mov	 rcx, QWORD PTR their_dev$[rsp]
  004ce	48 39 81 90 02
	00 00		 cmp	 QWORD PTR [rcx+656], rax
  004d5	0f 85 66 01 00
	00		 jne	 $LN14@con1052_in

; 237  :         )
; 238  :         {
; 239  :             their_pfx      = their_dev->filename;

  004db	48 8b 44 24 68	 mov	 rax, QWORD PTR their_dev$[rsp]
  004e0	48 05 a4 00 00
	00		 add	 rax, 164		; 000000a4H
  004e6	48 89 84 24 a0
	00 00 00	 mov	 QWORD PTR their_pfx$[rsp], rax

; 240  :             their_pfxlen   = strlen( their_pfx );

  004ee	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR their_pfx$[rsp]
  004f6	e8 00 00 00 00	 call	 strlen
  004fb	48 89 84 24 b0
	00 00 00	 mov	 QWORD PTR their_pfxlen$[rsp], rax

; 241  :             shorter_pfxlen = min( their_pfxlen, our_pfxlen );

  00503	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR our_pfxlen$[rsp]
  0050b	48 39 84 24 b0
	00 00 00	 cmp	 QWORD PTR their_pfxlen$[rsp], rax
  00513	73 12		 jae	 SHORT $LN22@con1052_in
  00515	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR their_pfxlen$[rsp]
  0051d	48 89 84 24 c0
	00 00 00	 mov	 QWORD PTR tv238[rsp], rax
  00525	eb 10		 jmp	 SHORT $LN23@con1052_in
$LN22@con1052_in:
  00527	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR our_pfxlen$[rsp]
  0052f	48 89 84 24 c0
	00 00 00	 mov	 QWORD PTR tv238[rsp], rax
$LN23@con1052_in:
  00537	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR tv238[rsp]
  0053f	48 89 84 24 c8
	00 00 00	 mov	 QWORD PTR shorter_pfxlen$[rsp], rax

; 242  : 
; 243  :             if (strncmp( our_pfx, their_pfx, shorter_pfxlen ) == 0)

  00547	4c 8b 84 24 c8
	00 00 00	 mov	 r8, QWORD PTR shorter_pfxlen$[rsp]
  0054f	48 8b 94 24 a0
	00 00 00	 mov	 rdx, QWORD PTR their_pfx$[rsp]
  00557	48 8b 8c 24 a8
	00 00 00	 mov	 rcx, QWORD PTR our_pfx$[rsp]
  0055f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_strncmp
  00565	85 c0		 test	 eax, eax
  00567	0f 85 d4 00 00
	00		 jne	 $LN15@con1052_in

; 244  :             {
; 245  :                 // "%1d:%04X COMM: device %1d:%04X already using prefix %s"
; 246  :                 WRMSG( HHC01086, "E",

  0056d	48 8b 44 24 68	 mov	 rax, QWORD PTR their_dev$[rsp]
  00572	0f b7 40 48	 movzx	 eax, WORD PTR [rax+72]
  00576	89 84 24 90 00
	00 00		 mov	 DWORD PTR tv246[rsp], eax
  0057d	48 8b 4c 24 68	 mov	 rcx, QWORD PTR their_dev$[rsp]
  00582	0f b7 49 44	 movzx	 ecx, WORD PTR [rcx+68]
  00586	d1 f9		 sar	 ecx, 1
  00588	89 8c 24 94 00
	00 00		 mov	 DWORD PTR tv250[rsp], ecx
  0058f	48 8b 94 24 80
	00 00 00	 mov	 rdx, QWORD PTR our_dev$[rsp]
  00597	0f b7 52 48	 movzx	 edx, WORD PTR [rdx+72]
  0059b	89 94 24 98 00
	00 00		 mov	 DWORD PTR tv253[rsp], edx
  005a2	4c 8b 84 24 80
	00 00 00	 mov	 r8, QWORD PTR our_dev$[rsp]
  005aa	45 0f b7 40 44	 movzx	 r8d, WORD PTR [r8+68]
  005af	41 d1 f8	 sar	 r8d, 1
  005b2	44 89 84 24 9c
	00 00 00	 mov	 DWORD PTR tv257[rsp], r8d
  005ba	b9 01 00 00 00	 mov	 ecx, 1
  005bf	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  005c5	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR their_pfx$[rsp]
  005cd	48 89 4c 24 58	 mov	 QWORD PTR [rsp+88], rcx
  005d2	8b 8c 24 90 00
	00 00		 mov	 ecx, DWORD PTR tv246[rsp]
  005d9	89 4c 24 50	 mov	 DWORD PTR [rsp+80], ecx
  005dd	8b 8c 24 94 00
	00 00		 mov	 ecx, DWORD PTR tv250[rsp]
  005e4	89 4c 24 48	 mov	 DWORD PTR [rsp+72], ecx
  005e8	8b 8c 24 98 00
	00 00		 mov	 ecx, DWORD PTR tv253[rsp]
  005ef	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  005f3	8b 8c 24 9c 00
	00 00		 mov	 ecx, DWORD PTR tv257[rsp]
  005fa	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  005fe	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG177559
  00605	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  0060a	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG177560
  00611	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00616	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  0061b	41 b9 03 00 00
	00		 mov	 r9d, 3
  00621	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG177561
  00628	ba fa 00 00 00	 mov	 edx, 250		; 000000faH
  0062d	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG177562
  00634	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 247  :                     SSID_TO_LCSS( our_dev   -> ssid ), our_dev   -> devnum,
; 248  :                     SSID_TO_LCSS( their_dev -> ssid ), their_dev -> devnum,
; 249  :                     their_pfx
; 250  :                 );
; 251  :                 return -1;

  0063a	b8 ff ff ff ff	 mov	 eax, -1
  0063f	eb 7c		 jmp	 SHORT $LN1@con1052_in
$LN15@con1052_in:
$LN14@con1052_in:

; 252  :             }
; 253  :         }
; 254  :     }

  00641	e9 35 fe ff ff	 jmp	 $LN5@con1052_in
$LN6@con1052_in:

; 255  : 
; 256  :     /* If the first character of our command prefix matches
; 257  :        one of the characters in our list of default command
; 258  :        prefixes, then mark that command prefix character as
; 259  :        being used and no longer available for use.
; 260  :     */
; 261  :     p = memchr( default_pfxs, our_pfx[0], sizeof( default_pfxs ));

  00646	b8 01 00 00 00	 mov	 eax, 1
  0064b	48 6b c0 00	 imul	 rax, rax, 0
  0064f	48 8b 8c 24 a8
	00 00 00	 mov	 rcx, QWORD PTR our_pfx$[rsp]
  00657	0f be 04 01	 movsx	 eax, BYTE PTR [rcx+rax]
  0065b	41 b8 16 00 00
	00		 mov	 r8d, 22
  00661	8b d0		 mov	 edx, eax
  00663	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:default_pfxs
  0066a	e8 00 00 00 00	 call	 memchr
  0066f	48 89 44 24 78	 mov	 QWORD PTR p$[rsp], rax

; 262  : 
; 263  :     if (p)

  00674	48 83 7c 24 78
	00		 cmp	 QWORD PTR p$[rsp], 0
  0067a	74 2d		 je	 SHORT $LN16@con1052_in

; 264  :     {
; 265  :         i = (p - default_pfxs);

  0067c	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:default_pfxs
  00683	48 8b 4c 24 78	 mov	 rcx, QWORD PTR p$[rsp]
  00688	48 2b c8	 sub	 rcx, rax
  0068b	48 8b c1	 mov	 rax, rcx
  0068e	48 89 84 24 88
	00 00 00	 mov	 QWORD PTR i$[rsp], rax

; 266  :         used_pfxs[i] = TRUE;

  00696	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:used_pfxs
  0069d	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR i$[rsp]
  006a5	c6 04 08 01	 mov	 BYTE PTR [rax+rcx], 1
$LN16@con1052_in:

; 267  :     }
; 268  : 
; 269  :     /* PROGRAMMING NOTE: it is CRITICAL that we set our file
; 270  :        descriptor integer to a non-zero value greater than 2
; 271  :        (even though we'll never use it) in order to force the
; 272  :        config.c "detach_devblk" function to call our 'close'
; 273  :        function so we can mark our prefix as being once again
; 274  :        available for reuse.
; 275  :     */
; 276  :     dev->fd = 999;  /* CRITICAL! See above Programming Note */

  006a9	48 8b 84 24 e0
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  006b1	c7 80 ac 01 00
	00 e7 03 00 00	 mov	 DWORD PTR [rax+428], 999 ; 000003e7H

; 277  : 
; 278  :     return 0;

  006bb	33 c0		 xor	 eax, eax
$LN1@con1052_in:

; 279  : }

  006bd	48 81 c4 d8 00
	00 00		 add	 rsp, 216		; 000000d8H
  006c4	c3		 ret	 0
con1052_init_handler ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\con1052c.c
_TEXT	SEGMENT
tv129 = 48
$T1 = 56
tv131 = 64
filename$ = 80
__$ArrayPad$ = 352
dev$ = 384
devclass$ = 392
buflen$ = 400
buffer$ = 408
con1052_query_device PROC

; 136  : {

  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	48 81 ec 78 01
	00 00		 sub	 rsp, 376		; 00000178H
  0001b	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00022	48 33 c4	 xor	 rax, rsp
  00025	48 89 84 24 60
	01 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 137  :     char  filename[ PATH_MAX + 1 ];     /* full path or just name    */
; 138  : 
; 139  :     BEGIN_DEVICE_CLASS_QUERY( "CON", dev, devclass, buflen, buffer );

  0002d	48 83 bc 24 88
	01 00 00 00	 cmp	 QWORD PTR devclass$[rsp], 0
  00036	74 12		 je	 SHORT $LN2@con1052_qu
  00038	48 8b 84 24 88
	01 00 00	 mov	 rax, QWORD PTR devclass$[rsp]
  00040	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG177510
  00047	48 89 08	 mov	 QWORD PTR [rax], rcx
$LN2@con1052_qu:
  0004a	48 83 bc 24 80
	01 00 00 00	 cmp	 QWORD PTR dev$[rsp], 0
  00053	74 20		 je	 SHORT $LN4@con1052_qu
  00055	48 83 bc 24 88
	01 00 00 00	 cmp	 QWORD PTR devclass$[rsp], 0
  0005e	74 15		 je	 SHORT $LN4@con1052_qu
  00060	83 bc 24 90 01
	00 00 00	 cmp	 DWORD PTR buflen$[rsp], 0
  00068	74 0b		 je	 SHORT $LN4@con1052_qu
  0006a	48 83 bc 24 98
	01 00 00 00	 cmp	 QWORD PTR buffer$[rsp], 0
  00073	75 05		 jne	 SHORT $LN3@con1052_qu
$LN4@con1052_qu:
  00075	e9 33 01 00 00	 jmp	 $LN1@con1052_qu
$LN3@con1052_qu:
  0007a	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00081	8b 80 94 12 00
	00		 mov	 eax, DWORD PTR [rax+4756]
  00087	c1 e8 1a	 shr	 eax, 26
  0008a	83 e0 01	 and	 eax, 1
  0008d	85 c0		 test	 eax, eax
  0008f	74 6c		 je	 SHORT $LN5@con1052_qu
  00091	48 8b 84 24 80
	01 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00099	48 05 a4 00 00
	00		 add	 rax, 164		; 000000a4H
  0009f	48 8b c8	 mov	 rcx, rax
  000a2	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_basename
  000a8	41 b8 05 01 00
	00		 mov	 r8d, 261		; 00000105H
  000ae	48 8b d0	 mov	 rdx, rax
  000b1	48 8d 4c 24 50	 lea	 rcx, QWORD PTR filename$[rsp]
  000b6	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_strlcpy
  000bc	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG177516
  000c3	48 8d 4c 24 50	 lea	 rcx, QWORD PTR filename$[rsp]
  000c8	e8 00 00 00 00	 call	 strcmp
  000cd	85 c0		 test	 eax, eax
  000cf	75 2a		 jne	 SHORT $LN7@con1052_qu
  000d1	b8 01 00 00 00	 mov	 eax, 1
  000d6	48 6b c0 00	 imul	 rax, rax, 0
  000da	48 89 44 24 38	 mov	 QWORD PTR $T1[rsp], rax
  000df	48 81 7c 24 38
	05 01 00 00	 cmp	 QWORD PTR $T1[rsp], 261	; 00000105H
  000e8	73 02		 jae	 SHORT $LN9@con1052_qu
  000ea	eb 05		 jmp	 SHORT $LN10@con1052_qu
$LN9@con1052_qu:
  000ec	e8 00 00 00 00	 call	 __report_rangecheckfailure
$LN10@con1052_qu:
  000f1	48 8b 44 24 38	 mov	 rax, QWORD PTR $T1[rsp]
  000f6	c6 44 04 50 00	 mov	 BYTE PTR filename$[rsp+rax], 0
$LN7@con1052_qu:
  000fb	eb 22		 jmp	 SHORT $LN6@con1052_qu
$LN5@con1052_qu:
  000fd	48 8b 84 24 80
	01 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00105	48 05 a4 00 00
	00		 add	 rax, 164		; 000000a4H
  0010b	41 b8 05 01 00
	00		 mov	 r8d, 261		; 00000105H
  00111	48 8b d0	 mov	 rdx, rax
  00114	48 8d 4c 24 50	 lea	 rcx, QWORD PTR filename$[rsp]
  00119	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_strlcpy
$LN6@con1052_qu:

; 140  : 
; 141  :     snprintf( buffer, buflen, "*syscons cmdpref(%s)%s IO[%"PRIu64"]",

  0011f	48 8b 84 24 80
	01 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00127	8b 80 d4 06 00
	00		 mov	 eax, DWORD PTR [rax+1748]
  0012d	c1 e8 02	 shr	 eax, 2
  00130	83 e0 01	 and	 eax, 1
  00133	85 c0		 test	 eax, eax
  00135	75 0a		 jne	 SHORT $LN11@con1052_qu
  00137	c7 44 24 30 01
	00 00 00	 mov	 DWORD PTR tv129[rsp], 1
  0013f	eb 08		 jmp	 SHORT $LN12@con1052_qu
$LN11@con1052_qu:
  00141	c7 44 24 30 00
	00 00 00	 mov	 DWORD PTR tv129[rsp], 0
$LN12@con1052_qu:
  00149	83 7c 24 30 00	 cmp	 DWORD PTR tv129[rsp], 0
  0014e	74 0e		 je	 SHORT $LN13@con1052_qu
  00150	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG177517
  00157	48 89 44 24 40	 mov	 QWORD PTR tv131[rsp], rax
  0015c	eb 0c		 jmp	 SHORT $LN14@con1052_qu
$LN13@con1052_qu:
  0015e	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG177518
  00165	48 89 44 24 40	 mov	 QWORD PTR tv131[rsp], rax
$LN14@con1052_qu:
  0016a	48 63 84 24 90
	01 00 00	 movsxd	 rax, DWORD PTR buflen$[rsp]
  00172	48 8b 8c 24 80
	01 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  0017a	48 8b 89 00 06
	00 00		 mov	 rcx, QWORD PTR [rcx+1536]
  00181	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00186	48 8b 4c 24 40	 mov	 rcx, QWORD PTR tv131[rsp]
  0018b	48 89 4c 24 20	 mov	 QWORD PTR [rsp+32], rcx
  00190	4c 8d 4c 24 50	 lea	 r9, QWORD PTR filename$[rsp]
  00195	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG177519
  0019c	48 8b d0	 mov	 rdx, rax
  0019f	48 8b 8c 24 98
	01 00 00	 mov	 rcx, QWORD PTR buffer$[rsp]
  001a7	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_snprintf
$LN1@con1052_qu:
$LN8@con1052_qu:

; 142  :         filename, !dev->prompt1052 ? " noprompt" : "", dev->excps );
; 143  : 
; 144  : }

  001ad	48 8b 8c 24 60
	01 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  001b5	48 33 cc	 xor	 rcx, rsp
  001b8	e8 00 00 00 00	 call	 __security_check_cookie
  001bd	48 81 c4 78 01
	00 00		 add	 rsp, 376		; 00000178H
  001c4	c3		 ret	 0
con1052_query_device ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\con1052c.c
_TEXT	SEGMENT
p$ = 32
$T1 = 40
i$ = 48
dev$ = 80
con1052_close_device PROC

; 111  : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 112  :     /* If the first character of our command prefix matches
; 113  :        one of the characters in our list of default command
; 114  :        prefixes, then mark that command prefix character as
; 115  :        being unused and once again available for reuse.
; 116  :     */
; 117  :     char* p;
; 118  :     size_t i;
; 119  : 
; 120  :     p = memchr( default_pfxs, dev->filename[0], sizeof( default_pfxs ));

  00009	b8 01 00 00 00	 mov	 eax, 1
  0000e	48 6b c0 00	 imul	 rax, rax, 0
  00012	48 8b 4c 24 50	 mov	 rcx, QWORD PTR dev$[rsp]
  00017	0f be 84 01 a4
	00 00 00	 movsx	 eax, BYTE PTR [rcx+rax+164]
  0001f	41 b8 16 00 00
	00		 mov	 r8d, 22
  00025	8b d0		 mov	 edx, eax
  00027	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:default_pfxs
  0002e	e8 00 00 00 00	 call	 memchr
  00033	48 89 44 24 20	 mov	 QWORD PTR p$[rsp], rax

; 121  : 
; 122  :     if (p)

  00038	48 83 7c 24 20
	00		 cmp	 QWORD PTR p$[rsp], 0
  0003e	74 40		 je	 SHORT $LN2@con1052_cl

; 123  :     {
; 124  :         i = (p - default_pfxs);

  00040	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:default_pfxs
  00047	48 8b 4c 24 20	 mov	 rcx, QWORD PTR p$[rsp]
  0004c	48 2b c8	 sub	 rcx, rax
  0004f	48 8b c1	 mov	 rax, rcx
  00052	48 89 44 24 30	 mov	 QWORD PTR i$[rsp], rax

; 125  :         used_pfxs[i] = FALSE;

  00057	48 8b 44 24 30	 mov	 rax, QWORD PTR i$[rsp]
  0005c	48 89 44 24 28	 mov	 QWORD PTR $T1[rsp], rax
  00061	48 83 7c 24 28
	16		 cmp	 QWORD PTR $T1[rsp], 22
  00067	73 02		 jae	 SHORT $LN4@con1052_cl
  00069	eb 05		 jmp	 SHORT $LN5@con1052_cl
$LN4@con1052_cl:
  0006b	e8 00 00 00 00	 call	 __report_rangecheckfailure
$LN5@con1052_cl:
  00070	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:used_pfxs
  00077	48 8b 4c 24 28	 mov	 rcx, QWORD PTR $T1[rsp]
  0007c	c6 04 08 00	 mov	 BYTE PTR [rax+rcx], 0
$LN2@con1052_cl:

; 126  :     }
; 127  : 
; 128  :     return 0;

  00080	33 c0		 xor	 eax, eax
$LN3@con1052_cl:

; 129  : }

  00082	48 83 c4 48	 add	 rsp, 72			; 00000048H
  00086	c3		 ret	 0
con1052_close_device ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files (x86)\Windows Kits\10\include\10.0.22000.0\ucrt\stdio.h
;	COMDAT sscanf
_TEXT	SEGMENT
_Result$ = 32
_ArgList$ = 40
_Buffer$ = 64
_Format$ = 72
sscanf	PROC						; COMDAT

; 2247 :     {

$LN3:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000f	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00014	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 2248 :         int _Result;
; 2249 :         va_list _ArgList;
; 2250 :         __crt_va_start(_ArgList, _Format);

  00018	48 8d 44 24 50	 lea	 rax, QWORD PTR _Format$[rsp+8]
  0001d	48 89 44 24 28	 mov	 QWORD PTR _ArgList$[rsp], rax

; 2251 :         _Result = _vsscanf_l(_Buffer, _Format, NULL, _ArgList);

  00022	4c 8b 4c 24 28	 mov	 r9, QWORD PTR _ArgList$[rsp]
  00027	45 33 c0	 xor	 r8d, r8d
  0002a	48 8b 54 24 48	 mov	 rdx, QWORD PTR _Format$[rsp]
  0002f	48 8b 4c 24 40	 mov	 rcx, QWORD PTR _Buffer$[rsp]
  00034	e8 00 00 00 00	 call	 _vsscanf_l
  00039	89 44 24 20	 mov	 DWORD PTR _Result$[rsp], eax

; 2252 :         __crt_va_end(_ArgList);

  0003d	48 c7 44 24 28
	00 00 00 00	 mov	 QWORD PTR _ArgList$[rsp], 0

; 2253 :         return _Result;

  00046	8b 44 24 20	 mov	 eax, DWORD PTR _Result$[rsp]

; 2254 :     }

  0004a	48 83 c4 38	 add	 rsp, 56			; 00000038H
  0004e	c3		 ret	 0
sscanf	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files (x86)\Windows Kits\10\include\10.0.22000.0\ucrt\stdio.h
;	COMDAT _vsscanf_l
_TEXT	SEGMENT
_Buffer$ = 64
_Format$ = 72
_Locale$ = 80
_ArgList$ = 88
_vsscanf_l PROC						; COMDAT

; 2152 :     {

$LN3:
  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 2153 :         return __stdio_common_vsscanf(

  00018	e8 00 00 00 00	 call	 __local_stdio_scanf_options
  0001d	48 8b 4c 24 58	 mov	 rcx, QWORD PTR _ArgList$[rsp]
  00022	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00027	48 8b 4c 24 50	 mov	 rcx, QWORD PTR _Locale$[rsp]
  0002c	48 89 4c 24 20	 mov	 QWORD PTR [rsp+32], rcx
  00031	4c 8b 4c 24 48	 mov	 r9, QWORD PTR _Format$[rsp]
  00036	49 c7 c0 ff ff
	ff ff		 mov	 r8, -1
  0003d	48 8b 54 24 40	 mov	 rdx, QWORD PTR _Buffer$[rsp]
  00042	48 8b 08	 mov	 rcx, QWORD PTR [rax]
  00045	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___stdio_common_vsscanf

; 2154 :             _CRT_INTERNAL_LOCAL_SCANF_OPTIONS,
; 2155 :             _Buffer, (size_t)-1, _Format, _Locale, _ArgList);
; 2156 :     }

  0004b	48 83 c4 38	 add	 rsp, 56			; 00000038H
  0004f	c3		 ret	 0
_vsscanf_l ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files (x86)\Windows Kits\10\include\10.0.22000.0\ucrt\corecrt_stdio_config.h
;	COMDAT __local_stdio_scanf_options
_TEXT	SEGMENT
__local_stdio_scanf_options PROC			; COMDAT

; 101  :         static unsigned __int64 _OptionsStorage;
; 102  :         return &_OptionsStorage;

  00000	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:?_OptionsStorage@?1??__local_stdio_scanf_options@@9@9 ; `__local_stdio_scanf_options'::`2'::_OptionsStorage

; 103  :     }

  00007	c3		 ret	 0
__local_stdio_scanf_options ENDP
_TEXT	ENDS
END
