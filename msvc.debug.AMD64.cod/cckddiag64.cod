; Listing generated by Microsoft (R) Optimizing Compiler Version 19.34.31937.0 

include listing.inc

INCLUDELIB MSVCRTD
INCLUDELIB OLDNAMES

CONST	SEGMENT
CKD_ENDTRK DB	0ffH
	DB	0ffH
	DB	0ffH
	DB	0ffH
	DB	0ffH
	DB	0ffH
	DB	0ffH
	DB	0ffH
VOL1_KEYA DB	056H
	DB	04fH
	DB	04cH
	DB	031H
VOL1_KEY DB	0e5H
	DB	0d6H
	DB	0d3H
	DB	0f1H
IPL1_KEY DB	0c9H
	DB	0d7H
	DB	0d3H
	DB	0f1H
IPL2_KEY DB	0c9H
	DB	0d7H
	DB	0d3H
	DB	0f2H
iplpsw	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
iplccw1	DB	06H
	DB	00H
	DB	03aH
	DB	098H
	DB	060H
	DB	00H
	DB	00H
	DB	060H
iplccw2	DB	08H
	DB	00H
	DB	03aH
	DB	098H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
noiplpsw DB	00H
	DB	02H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	0fH
noiplccw1 DB	03H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	01H
noiplccw2 DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
ipl2data DB	07H
	DB	00H
	DB	03aH
	DB	0b8H
	DB	040H
	DB	00H
	DB	00H
	DB	06H
	DB	031H
	DB	00H
	DB	03aH
	DB	0beH
	DB	040H
	DB	00H
	DB	00H
	DB	05H
	DB	08H
	DB	00H
	DB	03aH
	DB	0a0H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	06H
	DB	00H
	DB	00H
	DB	00H
	DB	020H
	DB	00H
	DB	07fH
	DB	0ffH
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	04H
	ORG $+5
?xd@?1??offtify@@9@9 DB '0123456789abcdefABCDEF', 00H	; `offtify'::`2'::xd
	ORG $+1
?xv@?1??offtify@@9@9 DB 00H				; `offtify'::`2'::xv
	DB	01H
	DB	02H
	DB	03H
	DB	04H
	DB	05H
	DB	06H
	DB	07H
	DB	08H
	DB	09H
	DB	0aH
	DB	0bH
	DB	0cH
	DB	0dH
	DB	0eH
	DB	0fH
	DB	0aH
	DB	0bH
	DB	0cH
	DB	0dH
	DB	0eH
	DB	0fH
CONST	ENDS
PUBLIC	__local_stdio_printf_options
PUBLIC	_vfprintf_l
PUBLIC	printf
PUBLIC	fetch_fw_noswap
PUBLIC	main
EXTRN	__imp_isxdigit:PROC
EXTRN	__imp__errno:PROC
EXTRN	strchr:PROC
EXTRN	__imp_free:PROC
EXTRN	__imp_malloc:PROC
EXTRN	__imp_exit:PROC
EXTRN	_byteswap_ulong:PROC
EXTRN	_byteswap_uint64:PROC
EXTRN	__imp__atoi64:PROC
EXTRN	__imp__lseeki64:PROC
EXTRN	__imp_close:PROC
EXTRN	__imp_read:PROC
EXTRN	__imp___acrt_iob_func:PROC
EXTRN	__imp_getc:PROC
EXTRN	__imp___stdio_common_vfprintf:PROC
EXTRN	__imp_initialize_utility:PROC
EXTRN	__imp_w32_strerror:PROC
EXTRN	__imp_hostpath:PROC
EXTRN	__imp_w32_hopen:PROC
EXTRN	__imp_dasd_lookup:PROC
EXTRN	__imp_cckd_def_opt_bigend:PROC
EXTRN	__imp_fwritemsg:PROC
EXTRN	__imp_data_dump:PROC
EXTRN	__imp_data_dump_ascii:PROC
EXTRN	__imp_data_dump_offset:PROC
EXTRN	__imp_is_dh_devid_typ:PROC
EXTRN	__GSHandlerCheck:PROC
EXTRN	__chkstk:PROC
EXTRN	__security_check_cookie:PROC
EXTRN	memcmp:PROC
EXTRN	__ImageBase:BYTE
EXTRN	__security_cookie:QWORD
_DATA	SEGMENT
COMM	?_OptionsStorage@?1??__local_stdio_printf_options@@9@9:QWORD							; `__local_stdio_printf_options'::`2'::_OptionsStorage
_DATA	ENDS
_BSS	SEGMENT
L1tab	DQ	01H DUP (?)
L2tab	DQ	01H DUP (?)
tbuf	DQ	01H DUP (?)
bulk	DQ	01H DUP (?)
fd	DD	01H DUP (?)
debug	DD	01H DUP (?)
pausesnap DD	01H DUP (?)
$SG160032 DB	01H DUP (?)
	ALIGN	4

$SG160073 DB	01H DUP (?)
	ALIGN	4

$SG160130 DB	01H DUP (?)
_BSS	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$_vfprintf_l DD imagerel $LN3
	DD	imagerel $LN3+68
	DD	imagerel $unwind$_vfprintf_l
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$printf DD imagerel $LN3
	DD	imagerel $LN3+88
	DD	imagerel $unwind$printf
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$fetch_fw_noswap DD imagerel $LN3
	DD	imagerel $LN3+27
	DD	imagerel $unwind$fetch_fw_noswap
pdata	ENDS
pdata	SEGMENT
$pdata$ErrExit DD imagerel ErrExit
	DD	imagerel ErrExit+23
	DD	imagerel $unwind$ErrExit
$pdata$syntax DD imagerel syntax
	DD	imagerel syntax+105
	DD	imagerel $unwind$syntax
$pdata$clean DD	imagerel clean
	DD	imagerel clean+73
	DD	imagerel $unwind$clean
$pdata$makbuf DD imagerel makbuf
	DD	imagerel makbuf+274
	DD	imagerel $unwind$makbuf
$pdata$readpos DD imagerel readpos
	DD	imagerel readpos+800
	DD	imagerel $unwind$readpos
$pdata$decomptrk DD imagerel decomptrk
	DD	imagerel decomptrk+172
	DD	imagerel $unwind$decomptrk
$pdata$show_ckd_count DD imagerel show_ckd_count
	DD	imagerel show_ckd_count+426
	DD	imagerel $unwind$show_ckd_count
$pdata$show_ckd_key DD imagerel show_ckd_key
	DD	imagerel show_ckd_key+309
	DD	imagerel $unwind$show_ckd_key
$pdata$show_ckd_data DD imagerel show_ckd_data
	DD	imagerel show_ckd_data+320
	DD	imagerel $unwind$show_ckd_data
$pdata$show_fba_block DD imagerel show_fba_block
	DD	imagerel show_fba_block+139
	DD	imagerel $unwind$show_fba_block
$pdata$snap DD	imagerel snap
	DD	imagerel snap+544
	DD	imagerel $unwind$snap
$pdata$showtrkorblk DD imagerel showtrkorblk
	DD	imagerel showtrkorblk+682
	DD	imagerel $unwind$showtrkorblk
$pdata$offtify DD imagerel offtify
	DD	imagerel offtify+491
	DD	imagerel $unwind$offtify
$pdata$main DD	imagerel $LN86
	DD	imagerel $LN86+6104
	DD	imagerel $unwind$main
pdata	ENDS
_DATA	SEGMENT
$SG159593 DB	'I', 00H
	ORG $+14
$SG159594 DB	'HHC02600%s Usage: %s [options] file', 0aH, 'HHC02600I   '
	DB	'file      name of CCKD/CFBA file', 0aH, 'HHC02600I Options:', 0aH
	DB	'HHC02600I   -d        display DEVHDR', 0aH, 'HHC02600I   -c  '
	DB	'      display CDEVHDR', 0aH, 'HHC02600I   -1        display L'
	DB	'1TAB (numeric one)', 0aH, 'HHC02600I   -g        enable debug'
	DB	' output', 0aH, 'HHC02600I CKD track and FBA block related opt'
	DB	'ions:', 0aH, 'HHC02600I   -a cc hh  display absolute CCHH tra'
	DB	'ck data', 0aH, 'HHC02600I   -r nnnnn  display relative track/'
	DB	'block data', 0aH, 'HHC02600I   -2        display L2TAB relate'
	DB	'd to -a or -r', 0aH, 'HHC02600I   -t        display track/blo'
	DB	'ck data', 0aH, 'HHC02600I   -x        hex display track key a'
	DB	'nd/or block data', 0aH, 'HHC02600I Offset option:', 0aH, 'HHC'
	DB	'02600I   -o oo ll  hex display data at offset oo of length ll'
	DB	0aH, 00H
	ORG $+3
$SG159595 DB	'syntax', 00H
	ORG $+1
$SG159596 DB	'cckddiag64.c', 00H
	ORG $+3
$SG159611 DB	'malloc()', 00H
	ORG $+3
$SG159612 DB	'S', 00H
	ORG $+2
$SG159614 DB	'makbuf', 00H
	ORG $+1
$SG159613 DB	'HHC02602%s From %s: Storage allocation of size %d using '
	DB	'%s failed', 0aH, 00H
	ORG $+1
$SG159617 DB	'D', 00H
	ORG $+2
$SG159615 DB	'cckddiag64.c', 00H
	ORG $+3
$SG159618 DB	'HHC90400%s MAKBUF() malloc %s buffer of %d bytes at %p', 0aH
	DB	00H
$SG159619 DB	'makbuf', 00H
	ORG $+1
$SG159620 DB	'cckddiag64.c', 00H
	ORG $+3
$SG159634 DB	'D', 00H
	ORG $+2
$SG159639 DB	'S', 00H
	ORG $+2
$SG159635 DB	'HHC90401%s READPOS seeking %lld (0x%16.16llX)', 0aH, 00H
	ORG $+1
$SG159636 DB	'readpos', 00H
$SG159637 DB	'cckddiag64.c', 00H
	ORG $+3
$SG159640 DB	'HHC02603%s lseek() to pos 0x%16.16llx error: %s', 0aH, 00H
	ORG $+3
$SG159644 DB	'D', 00H
	ORG $+2
$SG159641 DB	'readpos', 00H
$SG159642 DB	'cckddiag64.c', 00H
	ORG $+3
$SG159645 DB	'HHC90402%s READPOS reading buf addr %p length %d (0x%X)', 0aH
	DB	00H
	ORG $+3
$SG159652 DB	'S', 00H
	ORG $+2
$SG159646 DB	'readpos', 00H
$SG159647 DB	'cckddiag64.c', 00H
	ORG $+3
$SG159651 DB	'read() error: ', 00H
	ORG $+1
$SG159653 DB	'HHC02604%s %s%s', 0aH, 00H
	ORG $+3
$SG159660 DB	'S', 00H
	ORG $+2
$SG159654 DB	'readpos', 00H
$SG159655 DB	'cckddiag64.c', 00H
	ORG $+3
$SG159658 DB	'unexpected EOF', 00H
	ORG $+1
$SG159659 DB	'read() error: ', 00H
	ORG $+1
$SG159661 DB	'HHC02604%s %s%s', 0aH, 00H
	ORG $+3
$SG159666 DB	'S', 00H
	ORG $+2
$SG159662 DB	'readpos', 00H
$SG159663 DB	'cckddiag64.c', 00H
	ORG $+3
$SG159664 DB	'short block', 00H
$SG159715 DB	'I', 00H
	ORG $+2
$SG159665 DB	'read() error: ', 00H
	ORG $+1
$SG159667 DB	'HHC02604%s %s%s', 0aH, 00H
	ORG $+3
$SG159731 DB	0aH, 00H
	ORG $+2
$SG159668 DB	'readpos', 00H
$SG159669 DB	'cckddiag64.c', 00H
	ORG $+3
$SG159716 DB	'HHC02605%s Track %d COUNT cyl[%04X/%d] head[%04X/%d] rec'
	DB	'[%02X/%d] kl[%d] dl[%d]', 0aH, 00H
	ORG $+3
$SG159732 DB	'kl', 00H
	ORG $+1
$SG159717 DB	'show_ckd_count', 00H
	ORG $+1
$SG159718 DB	'cckddiag64.c', 00H
	ORG $+3
$SG159733 DB	'I', 00H
	ORG $+2
$SG159737 DB	0aH, 00H
	ORG $+2
$SG159734 DB	'HHC02606%s Track %d rec[%02X/%d] %s[%d]:', 0aH, 00H
	ORG $+2
$SG159750 DB	0aH, 00H
	ORG $+2
$SG159735 DB	'show_ckd_key', 00H
	ORG $+3
$SG159736 DB	'cckddiag64.c', 00H
	ORG $+3
$SG159751 DB	'dl', 00H
	ORG $+1
$SG159752 DB	'I', 00H
	ORG $+2
$SG159753 DB	'HHC02606%s Track %d rec[%02X/%d] %s[%d]:', 0aH, 00H
	ORG $+2
$SG159756 DB	0aH, 00H
	ORG $+2
$SG159754 DB	'show_ckd_data', 00H
	ORG $+2
$SG159755 DB	'cckddiag64.c', 00H
	ORG $+3
$SG159766 DB	'I', 00H
	ORG $+2
$SG159770 DB	0aH, 00H
	ORG $+2
$SG159767 DB	'HHC02616%s Block %d:', 0aH, 00H
	ORG $+2
$SG159768 DB	'show_fba_block', 00H
	ORG $+1
$SG159769 DB	'cckddiag64.c', 00H
	ORG $+3
$SG159783 DB	'track', 00H
	ORG $+2
$SG159784 DB	'block group', 00H
$SG159785 DB	'TRK', 00H
$SG159786 DB	'BKG', 00H
$SG159787 DB	'D', 00H
	ORG $+2
$SG159788 DB	'HHC90403%s SHOW%s Compressed %s header and data:', 0aH, 00H
	ORG $+2
$SG159789 DB	'snap', 00H
	ORG $+3
$SG159791 DB	'track', 00H
	ORG $+2
$SG159793 DB	'TRK', 00H
$SG159790 DB	'cckddiag64.c', 00H
	ORG $+3
$SG159792 DB	'block group', 00H
$SG159794 DB	'BKG', 00H
$SG159795 DB	'D', 00H
	ORG $+2
$SG159800 DB	0aH, 00H
	ORG $+2
$SG159796 DB	'HHC90404%s SHOW%s Decompressed %s header and data:', 0aH
	DB	00H
$SG159797 DB	'snap', 00H
	ORG $+3
$SG159802 DB	'A', 00H
	ORG $+2
$SG159798 DB	'cckddiag64.c', 00H
	ORG $+3
$SG159801 DB	'Press enter to continue', 00H
$SG159803 DB	'HHC02601%s %s', 0aH, 00H
	ORG $+1
$SG159804 DB	'snap', 00H
	ORG $+3
$SG159805 DB	'cckddiag64.c', 00H
	ORG $+3
$SG159836 DB	0aH, 00H
	ORG $+2
$SG159838 DB	0aH, 00H
	ORG $+2
$SG159842 DB	'End of track', 00H
	ORG $+3
$SG159843 DB	'I', 00H
	ORG $+2
$SG159864 DB	'D', 00H
	ORG $+2
$SG159844 DB	'HHC02601%s %s', 0aH, 00H
	ORG $+1
$SG159845 DB	'showtrkorblk', 00H
	ORG $+3
$SG159846 DB	'cckddiag64.c', 00H
	ORG $+3
$SG159865 DB	'HHC90405%s OFFTIFY hex string ''%s'' = 0x%16.16llX, dec '
	DB	'%lld.', 0aH, 00H
	ORG $+3
$SG159866 DB	'offtify', 00H
$SG159867 DB	'cckddiag64.c', 00H
	ORG $+3
$SG159869 DB	0aH, 00H
	ORG $+2
$SG159870 DB	'D', 00H
	ORG $+2
$SG159871 DB	'HHC90406%s OFFTIFY dec string ''%s'' = 0x%16.16llX, dec '
	DB	'%lld.', 0aH, 00H
	ORG $+3
$SG159872 DB	'offtify', 00H
$SG159873 DB	'cckddiag64.c', 00H
	ORG $+3
$SG159977 DB	'CCKD64/CFBA64 diagnostic program', 00H
	ORG $+3
$SG160004 DB	0aH, 00H
	ORG $+2
$SG159978 DB	'cckddiag64', 00H
	ORG $+1
$SG160006 DB	'E', 00H
	ORG $+2
$SG160007 DB	'HHC02607%s error opening file %s: %s', 0aH, 00H
	ORG $+2
$SG160008 DB	'main', 00H
	ORG $+3
$SG160009 DB	'cckddiag64.c', 00H
	ORG $+3
$SG160011 DB	0aH, 00H
	ORG $+2
$SG160012 DB	'DEVHDR', 00H
	ORG $+1
$SG160013 DB	'I', 00H
	ORG $+2
$SG160014 DB	'HHC02614%s %s - %d (decimal) bytes:', 0aH, 00H
	ORG $+3
$SG160015 DB	'main', 00H
	ORG $+3
$SG160016 DB	'cckddiag64.c', 00H
	ORG $+3
$SG160017 DB	0aH, 00H
	ORG $+2
$SG160021 DB	'S', 00H
	ORG $+2
$SG160022 DB	'HHC02608%s DASD table entry not found for devtype 0x%2.2'
	DB	'X', 0aH, 00H
	ORG $+1
$SG160023 DB	'main', 00H
	ORG $+3
$SG160028 DB	'S', 00H
	ORG $+2
$SG160024 DB	'cckddiag64.c', 00H
	ORG $+3
$SG160029 DB	'HHC02608%s DASD table entry not found for devtype 0x%2.2'
	DB	'X', 0aH, 00H
	ORG $+1
$SG160030 DB	'main', 00H
	ORG $+3
$SG160034 DB	'E', 00H
	ORG $+2
$SG160031 DB	'cckddiag64.c', 00H
	ORG $+3
$SG160033 DB	'incorrect header id', 00H
$SG160040 DB	'D', 00H
	ORG $+2
$SG160035 DB	'HHC02604%s %s%s', 0aH, 00H
	ORG $+3
$SG160036 DB	'main', 00H
	ORG $+3
$SG160045 DB	0aH, 00H
	ORG $+2
$SG160037 DB	'cckddiag64.c', 00H
	ORG $+3
$SG160041 DB	'HHC90407%s %s device has %d heads/cylinder', 0aH, 00H
$SG160042 DB	'main', 00H
	ORG $+3
$SG160047 DB	'I', 00H
	ORG $+2
$SG160043 DB	'cckddiag64.c', 00H
	ORG $+3
$SG160046 DB	'CDEVHDR', 00H
$SG160048 DB	'HHC02614%s %s - %d (decimal) bytes:', 0aH, 00H
	ORG $+3
$SG160049 DB	'main', 00H
	ORG $+3
$SG160050 DB	'cckddiag64.c', 00H
	ORG $+3
$SG160051 DB	0aH, 00H
	ORG $+2
$SG160055 DB	0aH, 00H
	ORG $+2
$SG160053 DB	'L1TAB64', 00H
$SG160056 DB	'L1TAB', 00H
	ORG $+2
$SG160057 DB	'I', 00H
	ORG $+2
$SG160061 DB	0aH, 00H
	ORG $+2
$SG160058 DB	'HHC02614%s %s - %d (decimal) bytes:', 0aH, 00H
	ORG $+3
$SG160059 DB	'main', 00H
	ORG $+3
$SG160060 DB	'cckddiag64.c', 00H
	ORG $+3
$SG160063 DB	'BULK', 00H
	ORG $+3
$SG160064 DB	0aH, 00H
	ORG $+2
$SG160065 DB	':', 00H
	ORG $+2
$SG160066 DB	'IMAGE', 00H
	ORG $+2
$SG160067 DB	'I', 00H
	ORG $+2
$SG160069 DB	'main', 00H
	ORG $+7
$SG160068 DB	'HHC02613%s %s offset %lld (0x%16.16llX); length %d (0x%8'
	DB	'.8X) bytes%s', 0aH, 00H
	ORG $+2
$SG160070 DB	'cckddiag64.c', 00H
	ORG $+3
$SG160071 DB	0aH, 00H
	ORG $+2
$SG160075 DB	'S', 00H
	ORG $+2
$SG160074 DB	'CCHH not supported for FBA', 00H
	ORG $+1
$SG160086 DB	'S', 00H
	ORG $+2
$SG160076 DB	'HHC02604%s %s%s', 0aH, 00H
	ORG $+3
$SG160077 DB	'main', 00H
	ORG $+3
$SG160084 DB	'Track', 00H
	ORG $+2
$SG160095 DB	'I', 00H
	ORG $+2
$SG160078 DB	'cckddiag64.c', 00H
	ORG $+3
$SG160085 DB	'Block', 00H
	ORG $+2
$SG160087 DB	'HHC02617%s %s %d does not exist on this device', 0aH, 00H
$SG160088 DB	'main', 00H
	ORG $+3
$SG160089 DB	'cckddiag64.c', 00H
	ORG $+3
$SG160097 DB	'main', 00H
	ORG $+3
$SG160096 DB	'HHC02609%s CC %d HH %d = reltrk %d; L1 index = %d, L2 in'
	DB	'dex = %d', 0aH, 00H
	ORG $+2
$SG160099 DB	'I', 00H
	ORG $+2
$SG160098 DB	'cckddiag64.c', 00H
	ORG $+3
$SG160100 DB	'HHC02615%s Block %d; L1 index = %d, L2 index = %d', 0aH, 00H
	ORG $+1
$SG160101 DB	'main', 00H
	ORG $+3
$SG160103 DB	'I', 00H
	ORG $+2
$SG160102 DB	'cckddiag64.c', 00H
	ORG $+3
$SG160104 DB	'HHC02610%s L1 index %d = L2TAB offset %lld (0x%16.16llX)'
	DB	0aH, 00H
	ORG $+2
$SG160105 DB	'main', 00H
	ORG $+3
$SG160109 DB	'track', 00H
	ORG $+2
$SG160111 DB	'S', 00H
	ORG $+2
$SG160106 DB	'cckddiag64.c', 00H
	ORG $+3
$SG160110 DB	'block', 00H
	ORG $+2
$SG160112 DB	'HHC02618%s L2tab for %s %d not found', 0aH, 00H
	ORG $+2
$SG160113 DB	'main', 00H
	ORG $+3
$SG160114 DB	'cckddiag64.c', 00H
	ORG $+3
$SG160115 DB	'L2TAB64', 00H
$SG160117 DB	0aH, 00H
	ORG $+2
$SG160118 DB	'L2TAB', 00H
	ORG $+2
$SG160119 DB	'I', 00H
	ORG $+2
$SG160120 DB	'HHC02614%s %s - %d (decimal) bytes:', 0aH, 00H
	ORG $+3
$SG160121 DB	'main', 00H
	ORG $+3
$SG160122 DB	'cckddiag64.c', 00H
	ORG $+3
$SG160123 DB	0aH, 00H
	ORG $+2
$SG160124 DB	'I', 00H
	ORG $+2
$SG160125 DB	'HHC02611%s L2 index %d = L2TAB entry: %d bytes:', 0aH, 00H
	ORG $+3
$SG160126 DB	'main', 00H
	ORG $+3
$SG160128 DB	0aH, 00H
	ORG $+2
$SG160127 DB	'cckddiag64.c', 00H
	ORG $+3
$SG160131 DB	'TRKHDR', 00H
	ORG $+1
$SG160132 DB	'BKGHDR', 00H
	ORG $+1
$SG160133 DB	'I', 00H
	ORG $+2
$SG160135 DB	'main', 00H
	ORG $+7
$SG160134 DB	'HHC02613%s %s offset %lld (0x%16.16llX); length %d (0x%8'
	DB	'.8X) bytes%s', 0aH, 00H
	ORG $+2
$SG160136 DB	'cckddiag64.c', 00H
	ORG $+3
$SG160139 DB	'Track', 00H
	ORG $+2
$SG160140 DB	'Block', 00H
	ORG $+2
$SG160141 DB	'S', 00H
	ORG $+2
$SG160149 DB	'TRK', 00H
$SG160142 DB	'HHC02619%s %s %d not found', 0aH, 00H
$SG160143 DB	'main', 00H
	ORG $+3
$SG160147 DB	'track', 00H
	ORG $+2
$SG160150 DB	'BKG', 00H
$SG160144 DB	'cckddiag64.c', 00H
	ORG $+3
$SG160145 DB	'TRKHDR+DATA', 00H
$SG160151 DB	'I', 00H
	ORG $+2
$SG160146 DB	'BKGHDR+DATA', 00H
$SG160148 DB	'block', 00H
	ORG $+2
$SG160155 DB	0aH, 00H
	ORG $+2
$SG160152 DB	'HHC02612%s %sHDR %s %d:', 0aH, 00H
	ORG $+3
$SG160153 DB	'main', 00H
	ORG $+7
$SG160154 DB	'cckddiag64.c', 00H
_DATA	ENDS
voltbl	SEGMENT
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:main
	DD	01aH
	DD	01747H
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:showtrkorblk
	DD	02aH
	DD	0292H
voltbl	ENDS
xdata	SEGMENT
$unwind$ErrExit DD 010801H
	DD	04208H
$unwind$syntax DD 010901H
	DD	08209H
$unwind$clean DD 010401H
	DD	04204H
$unwind$makbuf DD 010d01H
	DD	0c20dH
$unwind$readpos DD 011701H
	DD	0e217H
$unwind$decomptrk DD 031901H
	DD	070154219H
	DD	06014H
$unwind$show_ckd_count DD 021001H
	DD	0150110H
$unwind$show_ckd_key DD 011801H
	DD	0e218H
$unwind$show_ckd_data DD 011801H
	DD	0e218H
$unwind$show_fba_block DD 011201H
	DD	08212H
$unwind$snap DD	011701H
	DD	0e217H
$unwind$showtrkorblk DD 023219H
	DD	0201d0120H
	DD	imagerel __GSHandlerCheck
	DD	0100d0H
$unwind$offtify DD 010901H
	DD	0e209H
$unwind$main DD	022219H
	DD	0d10110H
	DD	imagerel __GSHandlerCheck
	DD	0670H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$fetch_fw_noswap DD 010901H
	DD	02209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$printf DD 011801H
	DD	06218H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$_vfprintf_l DD 011801H
	DD	06218H
xdata	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\cckddiag64.c
_TEXT	SEGMENT
ckddasd$ = 112
cmd_tt$ = 113
swapend$ = 114
cmd_cchh$ = 115
cmd_trkdata$ = 116
trk$ = 120
cmd_devhdr$ = 124
cmd_cdevhdr$ = 125
cmd_l1tab$ = 126
cmd_offset$ = 127
cmd_l2tab$ = 128
cmd_hexdump$ = 129
imglen$ = 132
L2ndx$ = 136
num_L1tab$ = 140
L1ndx$ = 144
op_length$ = 148
pgm$ = 152
heads$ = 160
tv81 = 164
op_hh$ = 168
op_cc$ = 172
L2taboff$ = 176
op_tt$ = 184
trkhdroff$ = 192
blkgrp$1 = 200
tv444 = 204
tv442 = 208
tv446 = 212
op_offset$ = 216
tv317 = 224
cckd_diag_rc$ = 228
ckd$ = 232
fn$ = 240
p$2 = 248
fba$ = 256
tv586 = 264
tv654 = 272
tv773 = 280
tv789 = 288
tv804 = 296
tv814 = 304
tv818 = 312
tv233 = 320
tv469 = 328
tv683 = 336
cdevhdr$ = 352
devhdr$ = 864
pathname$ = 1376
__$ArrayPad$ = 1648
argc$ = 1680
argv$ = 1688
main	PROC

; 507  : {

$LN86:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	89 4c 24 08	 mov	 DWORD PTR [rsp+8], ecx
  00009	48 81 ec 88 06
	00 00		 sub	 rsp, 1672		; 00000688H
  00010	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00017	48 33 c4	 xor	 rax, rsp
  0001a	48 89 84 24 70
	06 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 508  : int             cckd_diag_rc = 0;       /* Program return code       */

  00022	c7 84 24 e4 00
	00 00 00 00 00
	00		 mov	 DWORD PTR cckd_diag_rc$[rsp], 0

; 509  : 
; 510  : char*           pgm;                    /* less any extension (.ext) */
; 511  : char*           fn;                     /* File name                 */
; 512  : 
; 513  : CKD_DEVHDR      devhdr;                 /* CKD device hdr            */
; 514  : CCKD64_DEVHDR   cdevhdr;                /* Compressed CKD device hdr */
; 515  : 
; 516  : CKDDEV*         ckd          = NULL;    /* CKD DASD table entry      */

  0002d	48 c7 84 24 e8
	00 00 00 00 00
	00 00		 mov	 QWORD PTR ckd$[rsp], 0

; 517  : FBADEV*         fba          = NULL;    /* FBA DASD table entry      */

  00039	48 c7 84 24 00
	01 00 00 00 00
	00 00		 mov	 QWORD PTR fba$[rsp], 0

; 518  : 
; 519  : bool            cmd_devhdr   = false;   /* display DEVHDR            */

  00045	c6 44 24 7c 00	 mov	 BYTE PTR cmd_devhdr$[rsp], 0

; 520  : bool            cmd_cdevhdr  = false;   /* display CDEVHDR           */

  0004a	c6 44 24 7d 00	 mov	 BYTE PTR cmd_cdevhdr$[rsp], 0

; 521  : bool            cmd_l1tab    = false;   /* display L1TAB             */

  0004f	c6 44 24 7e 00	 mov	 BYTE PTR cmd_l1tab$[rsp], 0

; 522  : bool            cmd_l2tab    = false;   /* display L2TAB             */

  00054	c6 84 24 80 00
	00 00 00	 mov	 BYTE PTR cmd_l2tab$[rsp], 0

; 523  : bool            cmd_trkdata  = false;   /* display track data        */

  0005c	c6 44 24 74 00	 mov	 BYTE PTR cmd_trkdata$[rsp], 0

; 524  : bool            cmd_hexdump  = false;   /* display track data (hex)  */

  00061	c6 84 24 81 00
	00 00 00	 mov	 BYTE PTR cmd_hexdump$[rsp], 0

; 525  : 
; 526  : bool            cmd_offset   = false;   /* true = display data at    */

  00069	c6 44 24 7f 00	 mov	 BYTE PTR cmd_offset$[rsp], 0

; 527  : U64             op_offset    = 0;       /* op_offset of length       */

  0006e	48 c7 84 24 d8
	00 00 00 00 00
	00 00		 mov	 QWORD PTR op_offset$[rsp], 0

; 528  : int             op_length    = 0;       /* op_length                 */

  0007a	c7 84 24 94 00
	00 00 00 00 00
	00		 mov	 DWORD PTR op_length$[rsp], 0

; 529  : 
; 530  : bool            cmd_cchh     = false;   /* true = display CCHH data  */

  00085	c6 44 24 73 00	 mov	 BYTE PTR cmd_cchh$[rsp], 0

; 531  : int             op_cc        = 0;       /* CC = cylinder             */

  0008a	c7 84 24 ac 00
	00 00 00 00 00
	00		 mov	 DWORD PTR op_cc$[rsp], 0

; 532  : int             op_hh        = 0;       /* HH = head                 */

  00095	c7 84 24 a8 00
	00 00 00 00 00
	00		 mov	 DWORD PTR op_hh$[rsp], 0

; 533  : 
; 534  : bool            cmd_tt       = false;   /* true = display TT data    */

  000a0	c6 44 24 71 00	 mov	 BYTE PTR cmd_tt$[rsp], 0

; 535  : int             op_tt        = 0;       /* relative track/block #    */

  000a5	c7 84 24 b8 00
	00 00 00 00 00
	00		 mov	 DWORD PTR op_tt$[rsp], 0

; 536  : 
; 537  : int             heads        = 0;       /* Heads per cylinder        */

  000b0	c7 84 24 a0 00
	00 00 00 00 00
	00		 mov	 DWORD PTR heads$[rsp], 0

; 538  : int             trk          = 0;       /* Track or block number     */

  000bb	c7 44 24 78 00
	00 00 00	 mov	 DWORD PTR trk$[rsp], 0

; 539  : int             imglen       = 0;       /* track length              */

  000c3	c7 84 24 84 00
	00 00 00 00 00
	00		 mov	 DWORD PTR imglen$[rsp], 0

; 540  : 
; 541  : int             L1ndx        = 0;       /* Index into Level 1 table  */

  000ce	c7 84 24 90 00
	00 00 00 00 00
	00		 mov	 DWORD PTR L1ndx$[rsp], 0

; 542  : int             L2ndx        = 0;       /* Index into Level 2 table  */

  000d9	c7 84 24 88 00
	00 00 00 00 00
	00		 mov	 DWORD PTR L2ndx$[rsp], 0

; 543  : 
; 544  : U64             L2taboff     = 0;       /* offset to assoc. L2 table */

  000e4	48 c7 84 24 b0
	00 00 00 00 00
	00 00		 mov	 QWORD PTR L2taboff$[rsp], 0

; 545  : U64             trkhdroff    = 0;       /* offset to assoc. trk hdr  */

  000f0	48 c7 84 24 c0
	00 00 00 00 00
	00 00		 mov	 QWORD PTR trkhdroff$[rsp], 0

; 546  : 
; 547  : bool            ckddasd = false;        /* true=CKD dasd, false=FBA  */

  000fc	c6 44 24 70 00	 mov	 BYTE PTR ckddasd$[rsp], 0

; 548  : bool            swapend = false;        /* 1 = New endianness doesn't

  00101	c6 44 24 72 00	 mov	 BYTE PTR swapend$[rsp], 0

; 549  :                                             match machine endianness */
; 550  : int             num_L1tab;              /* Number of L1tab entries   */
; 551  : char            pathname[ MAX_PATH ];   /* file path in host format  */
; 552  : 
; 553  :     INITIALIZE_UTILITY( UTILITY_NAME, UTILITY_DESC, &pgm );

  00106	48 8d 84 24 98
	00 00 00	 lea	 rax, QWORD PTR pgm$[rsp]
  0010e	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00113	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG159977
  0011a	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG159978
  00121	48 8b 94 24 98
	06 00 00	 mov	 rdx, QWORD PTR argv$[rsp]
  00129	8b 8c 24 90 06
	00 00		 mov	 ecx, DWORD PTR argc$[rsp]
  00130	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_initialize_utility
  00136	89 84 24 90 06
	00 00		 mov	 DWORD PTR argc$[rsp], eax

; 554  : 
; 555  :     /* parse the arguments */
; 556  : 
; 557  :     argc--; argv++;

  0013d	8b 84 24 90 06
	00 00		 mov	 eax, DWORD PTR argc$[rsp]
  00144	ff c8		 dec	 eax
  00146	89 84 24 90 06
	00 00		 mov	 DWORD PTR argc$[rsp], eax
  0014d	48 8b 84 24 98
	06 00 00	 mov	 rax, QWORD PTR argv$[rsp]
  00155	48 83 c0 08	 add	 rax, 8
  00159	48 89 84 24 98
	06 00 00	 mov	 QWORD PTR argv$[rsp], rax
$LN2@main:

; 558  : 
; 559  :     while (argc > 0)

  00161	83 bc 24 90 06
	00 00 00	 cmp	 DWORD PTR argc$[rsp], 0
  00169	0f 8e 8c 04 00
	00		 jle	 $LN3@main

; 560  :     {
; 561  :         if (**argv != '-')

  0016f	48 8b 84 24 98
	06 00 00	 mov	 rax, QWORD PTR argv$[rsp]
  00177	48 8b 00	 mov	 rax, QWORD PTR [rax]
  0017a	0f be 00	 movsx	 eax, BYTE PTR [rax]
  0017d	83 f8 2d	 cmp	 eax, 45			; 0000002dH
  00180	74 05		 je	 SHORT $LN6@main

; 562  :             break;

  00182	e9 74 04 00 00	 jmp	 $LN3@main
$LN6@main:

; 563  : 
; 564  :         switch(argv[0][1])

  00187	b8 08 00 00 00	 mov	 eax, 8
  0018c	48 6b c0 00	 imul	 rax, rax, 0
  00190	b9 01 00 00 00	 mov	 ecx, 1
  00195	48 6b c9 01	 imul	 rcx, rcx, 1
  00199	48 8b 94 24 98
	06 00 00	 mov	 rdx, QWORD PTR argv$[rsp]
  001a1	48 8b 04 02	 mov	 rax, QWORD PTR [rdx+rax]
  001a5	0f be 04 08	 movsx	 eax, BYTE PTR [rax+rcx]
  001a9	89 84 24 a4 00
	00 00		 mov	 DWORD PTR tv81[rsp], eax
  001b0	8b 84 24 a4 00
	00 00		 mov	 eax, DWORD PTR tv81[rsp]
  001b7	83 e8 31	 sub	 eax, 49			; 00000031H
  001ba	89 84 24 a4 00
	00 00		 mov	 DWORD PTR tv81[rsp], eax
  001c1	83 bc 24 a4 00
	00 00 47	 cmp	 DWORD PTR tv81[rsp], 71	; 00000047H
  001c9	0f 87 f6 03 00
	00		 ja	 $LN29@main
  001cf	48 63 84 24 a4
	00 00 00	 movsxd	 rax, DWORD PTR tv81[rsp]
  001d7	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__ImageBase
  001de	0f b6 84 01 00
	00 00 00	 movzx	 eax, BYTE PTR $LN84@main[rcx+rax]
  001e6	8b 84 81 00 00
	00 00		 mov	 eax, DWORD PTR $LN85@main[rcx+rax*4]
  001ed	48 03 c1	 add	 rax, rcx
  001f0	ff e0		 jmp	 rax
$LN7@main:

; 565  :         {
; 566  :             case 'v':
; 567  :                     if (argv[0][2] != '\0')

  001f2	b8 08 00 00 00	 mov	 eax, 8
  001f7	48 6b c0 00	 imul	 rax, rax, 0
  001fb	b9 01 00 00 00	 mov	 ecx, 1
  00200	48 6b c9 02	 imul	 rcx, rcx, 2
  00204	48 8b 94 24 98
	06 00 00	 mov	 rdx, QWORD PTR argv$[rsp]
  0020c	48 8b 04 02	 mov	 rax, QWORD PTR [rdx+rax]
  00210	0f be 04 08	 movsx	 eax, BYTE PTR [rax+rcx]
  00214	85 c0		 test	 eax, eax
  00216	74 0d		 je	 SHORT $LN8@main

; 568  :                     {
; 569  :                         syntax (pgm);

  00218	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR pgm$[rsp]
  00220	e8 00 00 00 00	 call	 syntax
$LN8@main:

; 570  :                     }
; 571  :                     ErrExit( EXIT_NORMAL_SUCCESS );

  00225	33 c9		 xor	 ecx, ecx
  00227	e8 00 00 00 00	 call	 ErrExit

; 572  :                     break;  /* Useless but prevents warning */

  0022c	e9 a1 03 00 00	 jmp	 $LN4@main
$LN9@main:

; 573  : 
; 574  :             case 'd':  if (argv[0][2] != '\0') syntax (pgm);

  00231	b8 08 00 00 00	 mov	 eax, 8
  00236	48 6b c0 00	 imul	 rax, rax, 0
  0023a	b9 01 00 00 00	 mov	 ecx, 1
  0023f	48 6b c9 02	 imul	 rcx, rcx, 2
  00243	48 8b 94 24 98
	06 00 00	 mov	 rdx, QWORD PTR argv$[rsp]
  0024b	48 8b 04 02	 mov	 rax, QWORD PTR [rdx+rax]
  0024f	0f be 04 08	 movsx	 eax, BYTE PTR [rax+rcx]
  00253	85 c0		 test	 eax, eax
  00255	74 0d		 je	 SHORT $LN10@main
  00257	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR pgm$[rsp]
  0025f	e8 00 00 00 00	 call	 syntax
$LN10@main:

; 575  :                        cmd_devhdr = true;

  00264	c6 44 24 7c 01	 mov	 BYTE PTR cmd_devhdr$[rsp], 1

; 576  :                        break;

  00269	e9 64 03 00 00	 jmp	 $LN4@main
$LN11@main:

; 577  : 
; 578  :             case 'c':  if (argv[0][2] != '\0') syntax (pgm);

  0026e	b8 08 00 00 00	 mov	 eax, 8
  00273	48 6b c0 00	 imul	 rax, rax, 0
  00277	b9 01 00 00 00	 mov	 ecx, 1
  0027c	48 6b c9 02	 imul	 rcx, rcx, 2
  00280	48 8b 94 24 98
	06 00 00	 mov	 rdx, QWORD PTR argv$[rsp]
  00288	48 8b 04 02	 mov	 rax, QWORD PTR [rdx+rax]
  0028c	0f be 04 08	 movsx	 eax, BYTE PTR [rax+rcx]
  00290	85 c0		 test	 eax, eax
  00292	74 0d		 je	 SHORT $LN12@main
  00294	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR pgm$[rsp]
  0029c	e8 00 00 00 00	 call	 syntax
$LN12@main:

; 579  :                        cmd_cdevhdr = true;

  002a1	c6 44 24 7d 01	 mov	 BYTE PTR cmd_cdevhdr$[rsp], 1

; 580  :                        break;

  002a6	e9 27 03 00 00	 jmp	 $LN4@main
$LN13@main:

; 581  : 
; 582  :             case '1':  if (argv[0][2] != '\0') syntax (pgm);

  002ab	b8 08 00 00 00	 mov	 eax, 8
  002b0	48 6b c0 00	 imul	 rax, rax, 0
  002b4	b9 01 00 00 00	 mov	 ecx, 1
  002b9	48 6b c9 02	 imul	 rcx, rcx, 2
  002bd	48 8b 94 24 98
	06 00 00	 mov	 rdx, QWORD PTR argv$[rsp]
  002c5	48 8b 04 02	 mov	 rax, QWORD PTR [rdx+rax]
  002c9	0f be 04 08	 movsx	 eax, BYTE PTR [rax+rcx]
  002cd	85 c0		 test	 eax, eax
  002cf	74 0d		 je	 SHORT $LN14@main
  002d1	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR pgm$[rsp]
  002d9	e8 00 00 00 00	 call	 syntax
$LN14@main:

; 583  :                        cmd_l1tab = true;

  002de	c6 44 24 7e 01	 mov	 BYTE PTR cmd_l1tab$[rsp], 1

; 584  :                        break;

  002e3	e9 ea 02 00 00	 jmp	 $LN4@main
$LN15@main:

; 585  : 
; 586  :             case '2':  if (argv[0][2] != '\0') syntax (pgm);

  002e8	b8 08 00 00 00	 mov	 eax, 8
  002ed	48 6b c0 00	 imul	 rax, rax, 0
  002f1	b9 01 00 00 00	 mov	 ecx, 1
  002f6	48 6b c9 02	 imul	 rcx, rcx, 2
  002fa	48 8b 94 24 98
	06 00 00	 mov	 rdx, QWORD PTR argv$[rsp]
  00302	48 8b 04 02	 mov	 rax, QWORD PTR [rdx+rax]
  00306	0f be 04 08	 movsx	 eax, BYTE PTR [rax+rcx]
  0030a	85 c0		 test	 eax, eax
  0030c	74 0d		 je	 SHORT $LN16@main
  0030e	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR pgm$[rsp]
  00316	e8 00 00 00 00	 call	 syntax
$LN16@main:

; 587  :                        cmd_l2tab = true;

  0031b	c6 84 24 80 00
	00 00 01	 mov	 BYTE PTR cmd_l2tab$[rsp], 1

; 588  :                        break;

  00323	e9 aa 02 00 00	 jmp	 $LN4@main
$LN17@main:

; 589  : 
; 590  :             case 'a':  if (argv[0][2] != '\0') syntax (pgm);

  00328	b8 08 00 00 00	 mov	 eax, 8
  0032d	48 6b c0 00	 imul	 rax, rax, 0
  00331	b9 01 00 00 00	 mov	 ecx, 1
  00336	48 6b c9 02	 imul	 rcx, rcx, 2
  0033a	48 8b 94 24 98
	06 00 00	 mov	 rdx, QWORD PTR argv$[rsp]
  00342	48 8b 04 02	 mov	 rax, QWORD PTR [rdx+rax]
  00346	0f be 04 08	 movsx	 eax, BYTE PTR [rax+rcx]
  0034a	85 c0		 test	 eax, eax
  0034c	74 0d		 je	 SHORT $LN18@main
  0034e	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR pgm$[rsp]
  00356	e8 00 00 00 00	 call	 syntax
$LN18@main:

; 591  :                        cmd_cchh = true;

  0035b	c6 44 24 73 01	 mov	 BYTE PTR cmd_cchh$[rsp], 1

; 592  : 
; 593  :                        argc--; argv++;

  00360	8b 84 24 90 06
	00 00		 mov	 eax, DWORD PTR argc$[rsp]
  00367	ff c8		 dec	 eax
  00369	89 84 24 90 06
	00 00		 mov	 DWORD PTR argc$[rsp], eax
  00370	48 8b 84 24 98
	06 00 00	 mov	 rax, QWORD PTR argv$[rsp]
  00378	48 83 c0 08	 add	 rax, 8
  0037c	48 89 84 24 98
	06 00 00	 mov	 QWORD PTR argv$[rsp], rax

; 594  :                        op_cc = (int) offtify(*argv);

  00384	48 8b 84 24 98
	06 00 00	 mov	 rax, QWORD PTR argv$[rsp]
  0038c	48 8b 08	 mov	 rcx, QWORD PTR [rax]
  0038f	e8 00 00 00 00	 call	 offtify
  00394	89 84 24 ac 00
	00 00		 mov	 DWORD PTR op_cc$[rsp], eax

; 595  : 
; 596  :                        argc--; argv++;

  0039b	8b 84 24 90 06
	00 00		 mov	 eax, DWORD PTR argc$[rsp]
  003a2	ff c8		 dec	 eax
  003a4	89 84 24 90 06
	00 00		 mov	 DWORD PTR argc$[rsp], eax
  003ab	48 8b 84 24 98
	06 00 00	 mov	 rax, QWORD PTR argv$[rsp]
  003b3	48 83 c0 08	 add	 rax, 8
  003b7	48 89 84 24 98
	06 00 00	 mov	 QWORD PTR argv$[rsp], rax

; 597  :                        op_hh = (int) offtify(*argv);

  003bf	48 8b 84 24 98
	06 00 00	 mov	 rax, QWORD PTR argv$[rsp]
  003c7	48 8b 08	 mov	 rcx, QWORD PTR [rax]
  003ca	e8 00 00 00 00	 call	 offtify
  003cf	89 84 24 a8 00
	00 00		 mov	 DWORD PTR op_hh$[rsp], eax

; 598  :                        break;

  003d6	e9 f7 01 00 00	 jmp	 $LN4@main
$LN19@main:

; 599  : 
; 600  :             case 'r':  if (argv[0][2] != '\0') syntax (pgm);

  003db	b8 08 00 00 00	 mov	 eax, 8
  003e0	48 6b c0 00	 imul	 rax, rax, 0
  003e4	b9 01 00 00 00	 mov	 ecx, 1
  003e9	48 6b c9 02	 imul	 rcx, rcx, 2
  003ed	48 8b 94 24 98
	06 00 00	 mov	 rdx, QWORD PTR argv$[rsp]
  003f5	48 8b 04 02	 mov	 rax, QWORD PTR [rdx+rax]
  003f9	0f be 04 08	 movsx	 eax, BYTE PTR [rax+rcx]
  003fd	85 c0		 test	 eax, eax
  003ff	74 0d		 je	 SHORT $LN20@main
  00401	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR pgm$[rsp]
  00409	e8 00 00 00 00	 call	 syntax
$LN20@main:

; 601  :                        cmd_tt = true;

  0040e	c6 44 24 71 01	 mov	 BYTE PTR cmd_tt$[rsp], 1

; 602  : 
; 603  :                        argc--; argv++;

  00413	8b 84 24 90 06
	00 00		 mov	 eax, DWORD PTR argc$[rsp]
  0041a	ff c8		 dec	 eax
  0041c	89 84 24 90 06
	00 00		 mov	 DWORD PTR argc$[rsp], eax
  00423	48 8b 84 24 98
	06 00 00	 mov	 rax, QWORD PTR argv$[rsp]
  0042b	48 83 c0 08	 add	 rax, 8
  0042f	48 89 84 24 98
	06 00 00	 mov	 QWORD PTR argv$[rsp], rax

; 604  :                        op_tt = (int) offtify(*argv);

  00437	48 8b 84 24 98
	06 00 00	 mov	 rax, QWORD PTR argv$[rsp]
  0043f	48 8b 08	 mov	 rcx, QWORD PTR [rax]
  00442	e8 00 00 00 00	 call	 offtify
  00447	89 84 24 b8 00
	00 00		 mov	 DWORD PTR op_tt$[rsp], eax

; 605  :                        break;

  0044e	e9 7f 01 00 00	 jmp	 $LN4@main
$LN21@main:

; 606  : 
; 607  :             case 'o':  if (argv[0][2] != '\0') syntax (pgm);

  00453	b8 08 00 00 00	 mov	 eax, 8
  00458	48 6b c0 00	 imul	 rax, rax, 0
  0045c	b9 01 00 00 00	 mov	 ecx, 1
  00461	48 6b c9 02	 imul	 rcx, rcx, 2
  00465	48 8b 94 24 98
	06 00 00	 mov	 rdx, QWORD PTR argv$[rsp]
  0046d	48 8b 04 02	 mov	 rax, QWORD PTR [rdx+rax]
  00471	0f be 04 08	 movsx	 eax, BYTE PTR [rax+rcx]
  00475	85 c0		 test	 eax, eax
  00477	74 0d		 je	 SHORT $LN22@main
  00479	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR pgm$[rsp]
  00481	e8 00 00 00 00	 call	 syntax
$LN22@main:

; 608  :                        cmd_offset = true;

  00486	c6 44 24 7f 01	 mov	 BYTE PTR cmd_offset$[rsp], 1

; 609  : 
; 610  :                        argc--; argv++;

  0048b	8b 84 24 90 06
	00 00		 mov	 eax, DWORD PTR argc$[rsp]
  00492	ff c8		 dec	 eax
  00494	89 84 24 90 06
	00 00		 mov	 DWORD PTR argc$[rsp], eax
  0049b	48 8b 84 24 98
	06 00 00	 mov	 rax, QWORD PTR argv$[rsp]
  004a3	48 83 c0 08	 add	 rax, 8
  004a7	48 89 84 24 98
	06 00 00	 mov	 QWORD PTR argv$[rsp], rax

; 611  :                        op_offset = (U64) offtify(*argv);

  004af	48 8b 84 24 98
	06 00 00	 mov	 rax, QWORD PTR argv$[rsp]
  004b7	48 8b 08	 mov	 rcx, QWORD PTR [rax]
  004ba	e8 00 00 00 00	 call	 offtify
  004bf	48 89 84 24 d8
	00 00 00	 mov	 QWORD PTR op_offset$[rsp], rax

; 612  : 
; 613  :                        argc--; argv++;

  004c7	8b 84 24 90 06
	00 00		 mov	 eax, DWORD PTR argc$[rsp]
  004ce	ff c8		 dec	 eax
  004d0	89 84 24 90 06
	00 00		 mov	 DWORD PTR argc$[rsp], eax
  004d7	48 8b 84 24 98
	06 00 00	 mov	 rax, QWORD PTR argv$[rsp]
  004df	48 83 c0 08	 add	 rax, 8
  004e3	48 89 84 24 98
	06 00 00	 mov	 QWORD PTR argv$[rsp], rax

; 614  :                        op_length = (int) offtify(*argv);

  004eb	48 8b 84 24 98
	06 00 00	 mov	 rax, QWORD PTR argv$[rsp]
  004f3	48 8b 08	 mov	 rcx, QWORD PTR [rax]
  004f6	e8 00 00 00 00	 call	 offtify
  004fb	89 84 24 94 00
	00 00		 mov	 DWORD PTR op_length$[rsp], eax

; 615  :                        break;

  00502	e9 cb 00 00 00	 jmp	 $LN4@main
$LN23@main:

; 616  : 
; 617  :             case 't':  if (argv[0][2] != '\0') syntax (pgm);

  00507	b8 08 00 00 00	 mov	 eax, 8
  0050c	48 6b c0 00	 imul	 rax, rax, 0
  00510	b9 01 00 00 00	 mov	 ecx, 1
  00515	48 6b c9 02	 imul	 rcx, rcx, 2
  00519	48 8b 94 24 98
	06 00 00	 mov	 rdx, QWORD PTR argv$[rsp]
  00521	48 8b 04 02	 mov	 rax, QWORD PTR [rdx+rax]
  00525	0f be 04 08	 movsx	 eax, BYTE PTR [rax+rcx]
  00529	85 c0		 test	 eax, eax
  0052b	74 0d		 je	 SHORT $LN24@main
  0052d	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR pgm$[rsp]
  00535	e8 00 00 00 00	 call	 syntax
$LN24@main:

; 618  :                        cmd_trkdata = true;

  0053a	c6 44 24 74 01	 mov	 BYTE PTR cmd_trkdata$[rsp], 1

; 619  :                        break;

  0053f	e9 8e 00 00 00	 jmp	 $LN4@main
$LN25@main:

; 620  : 
; 621  :             case 'x':  if (argv[0][2] != '\0') syntax (pgm);

  00544	b8 08 00 00 00	 mov	 eax, 8
  00549	48 6b c0 00	 imul	 rax, rax, 0
  0054d	b9 01 00 00 00	 mov	 ecx, 1
  00552	48 6b c9 02	 imul	 rcx, rcx, 2
  00556	48 8b 94 24 98
	06 00 00	 mov	 rdx, QWORD PTR argv$[rsp]
  0055e	48 8b 04 02	 mov	 rax, QWORD PTR [rdx+rax]
  00562	0f be 04 08	 movsx	 eax, BYTE PTR [rax+rcx]
  00566	85 c0		 test	 eax, eax
  00568	74 0d		 je	 SHORT $LN26@main
  0056a	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR pgm$[rsp]
  00572	e8 00 00 00 00	 call	 syntax
$LN26@main:

; 622  :                        cmd_hexdump = true;

  00577	c6 84 24 81 00
	00 00 01	 mov	 BYTE PTR cmd_hexdump$[rsp], 1

; 623  :                        cmd_trkdata = true;

  0057f	c6 44 24 74 01	 mov	 BYTE PTR cmd_trkdata$[rsp], 1

; 624  :                        break;

  00584	eb 4c		 jmp	 SHORT $LN4@main
$LN27@main:

; 625  : 
; 626  :             case 'g':  if (argv[0][2] != '\0') syntax (pgm);

  00586	b8 08 00 00 00	 mov	 eax, 8
  0058b	48 6b c0 00	 imul	 rax, rax, 0
  0058f	b9 01 00 00 00	 mov	 ecx, 1
  00594	48 6b c9 02	 imul	 rcx, rcx, 2
  00598	48 8b 94 24 98
	06 00 00	 mov	 rdx, QWORD PTR argv$[rsp]
  005a0	48 8b 04 02	 mov	 rax, QWORD PTR [rdx+rax]
  005a4	0f be 04 08	 movsx	 eax, BYTE PTR [rax+rcx]
  005a8	85 c0		 test	 eax, eax
  005aa	74 0d		 je	 SHORT $LN28@main
  005ac	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR pgm$[rsp]
  005b4	e8 00 00 00 00	 call	 syntax
$LN28@main:

; 627  :                        debug = 1;

  005b9	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR debug, 1

; 628  :                        break;

  005c3	eb 0d		 jmp	 SHORT $LN4@main
$LN29@main:

; 629  : 
; 630  :             default:   syntax (pgm);

  005c5	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR pgm$[rsp]
  005cd	e8 00 00 00 00	 call	 syntax
$LN4@main:

; 631  :         }
; 632  : 
; 633  :         argc--; argv++;

  005d2	8b 84 24 90 06
	00 00		 mov	 eax, DWORD PTR argc$[rsp]
  005d9	ff c8		 dec	 eax
  005db	89 84 24 90 06
	00 00		 mov	 DWORD PTR argc$[rsp], eax
  005e2	48 8b 84 24 98
	06 00 00	 mov	 rax, QWORD PTR argv$[rsp]
  005ea	48 83 c0 08	 add	 rax, 8
  005ee	48 89 84 24 98
	06 00 00	 mov	 QWORD PTR argv$[rsp], rax

; 634  :     }

  005f6	e9 66 fb ff ff	 jmp	 $LN2@main
$LN3@main:

; 635  : 
; 636  :     if (argc != 1)

  005fb	83 bc 24 90 06
	00 00 01	 cmp	 DWORD PTR argc$[rsp], 1
  00603	74 0d		 je	 SHORT $LN30@main

; 637  :         syntax (pgm);

  00605	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR pgm$[rsp]
  0060d	e8 00 00 00 00	 call	 syntax
$LN30@main:

; 638  : 
; 639  :     printf("\n");

  00612	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG160004
  00619	e8 00 00 00 00	 call	 printf

; 640  : 
; 641  :     fn = argv[0];

  0061e	b8 08 00 00 00	 mov	 eax, 8
  00623	48 6b c0 00	 imul	 rax, rax, 0
  00627	48 8b 8c 24 98
	06 00 00	 mov	 rcx, QWORD PTR argv$[rsp]
  0062f	48 8b 04 01	 mov	 rax, QWORD PTR [rcx+rax]
  00633	48 89 84 24 f0
	00 00 00	 mov	 QWORD PTR fn$[rsp], rax

; 642  : 
; 643  :     /* open the file */
; 644  :     hostpath( pathname, fn, sizeof( pathname ));

  0063b	41 b8 04 01 00
	00		 mov	 r8d, 260		; 00000104H
  00641	48 8b 94 24 f0
	00 00 00	 mov	 rdx, QWORD PTR fn$[rsp]
  00649	48 8d 8c 24 60
	05 00 00	 lea	 rcx, QWORD PTR pathname$[rsp]
  00651	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hostpath

; 645  :     fd = HOPEN( pathname, O_RDONLY | O_BINARY );

  00657	ba 00 80 00 00	 mov	 edx, 32768		; 00008000H
  0065c	48 8d 8c 24 60
	05 00 00	 lea	 rcx, QWORD PTR pathname$[rsp]
  00664	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_hopen
  0066a	89 05 00 00 00
	00		 mov	 DWORD PTR fd, eax

; 646  : 
; 647  :     if (fd < 0)

  00670	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR fd, 0
  00677	0f 8d 81 00 00
	00		 jge	 $LN31@main

; 648  :     {
; 649  :         // "error opening file %s: %s"
; 650  :         FWRMSG( stderr, HHC02607, "E", fn, strerror( errno ));

  0067d	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno
  00683	8b 08		 mov	 ecx, DWORD PTR [rax]
  00685	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_strerror
  0068b	48 89 84 24 40
	01 00 00	 mov	 QWORD PTR tv233[rsp], rax
  00693	b9 02 00 00 00	 mov	 ecx, 2
  00698	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  0069e	48 8b 8c 24 40
	01 00 00	 mov	 rcx, QWORD PTR tv233[rsp]
  006a6	48 89 4c 24 40	 mov	 QWORD PTR [rsp+64], rcx
  006ab	48 8b 8c 24 f0
	00 00 00	 mov	 rcx, QWORD PTR fn$[rsp]
  006b3	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  006b8	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG160006
  006bf	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  006c4	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG160007
  006cb	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  006d0	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  006d5	41 b9 03 00 00
	00		 mov	 r9d, 3
  006db	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG160008
  006e2	ba 8a 02 00 00	 mov	 edx, 650		; 0000028aH
  006e7	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG160009
  006ee	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 651  :         ErrExit( EXIT_OPEN_ERROR );

  006f4	b9 08 00 00 00	 mov	 ecx, 8
  006f9	e8 00 00 00 00	 call	 ErrExit
$LN31@main:

; 652  :     }
; 653  : 
; 654  :     /*---------------------------------------------------------------*/
; 655  :     /* display DEVHDR - first 512 bytes of dasd image                */
; 656  :     /*---------------------------------------------------------------*/
; 657  :     readpos( fd, &devhdr, 0, CKD_DEVHDR_SIZE );

  006fe	41 b9 00 02 00
	00		 mov	 r9d, 512		; 00000200H
  00704	45 33 c0	 xor	 r8d, r8d
  00707	48 8d 94 24 60
	03 00 00	 lea	 rdx, QWORD PTR devhdr$[rsp]
  0070f	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR fd
  00715	e8 00 00 00 00	 call	 readpos

; 658  : 
; 659  :     if (cmd_devhdr)

  0071a	0f b6 44 24 7c	 movzx	 eax, BYTE PTR cmd_devhdr$[rsp]
  0071f	85 c0		 test	 eax, eax
  00721	0f 84 b6 00 00
	00		 je	 $LN32@main

; 660  :     {
; 661  :         BYTE* p = (BYTE*) &devhdr;

  00727	48 8d 84 24 60
	03 00 00	 lea	 rax, QWORD PTR devhdr$[rsp]
  0072f	48 89 84 24 f8
	00 00 00	 mov	 QWORD PTR p$2[rsp], rax

; 662  : 
; 663  :         // "%s - %d (decimal) bytes:"
; 664  :         printf("\n");

  00737	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG160011
  0073e	e8 00 00 00 00	 call	 printf

; 665  :         WRMSG( HHC02614, "I", "DEVHDR", (int) CKD_DEVHDR_SIZE );

  00743	b9 01 00 00 00	 mov	 ecx, 1
  00748	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  0074e	c7 44 24 40 00
	02 00 00	 mov	 DWORD PTR [rsp+64], 512	; 00000200H
  00756	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG160012
  0075d	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  00762	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG160013
  00769	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  0076e	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG160014
  00775	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  0077a	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  0077f	41 b9 03 00 00
	00		 mov	 r9d, 3
  00785	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG160015
  0078c	ba 99 02 00 00	 mov	 edx, 665		; 00000299H
  00791	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG160016
  00798	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 666  : 
; 667  :         // Note: first 8 bytes of DEVHDR is in ASCII, but
; 668  :         // the data_dump function dumps 16 bytes per line.
; 669  :         data_dump_ascii ( p,                       16 );

  0079e	ba 10 00 00 00	 mov	 edx, 16
  007a3	48 8b 8c 24 f8
	00 00 00	 mov	 rcx, QWORD PTR p$2[rsp]
  007ab	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_data_dump_ascii

; 670  :         data_dump_offset( p + 16, CKD_DEVHDR_SIZE, 16 );

  007b1	48 8b 84 24 f8
	00 00 00	 mov	 rax, QWORD PTR p$2[rsp]
  007b9	48 83 c0 10	 add	 rax, 16
  007bd	41 b8 10 00 00
	00		 mov	 r8d, 16
  007c3	ba 00 02 00 00	 mov	 edx, 512		; 00000200H
  007c8	48 8b c8	 mov	 rcx, rax
  007cb	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_data_dump_offset

; 671  : 
; 672  :         printf("\n");

  007d1	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG160017
  007d8	e8 00 00 00 00	 call	 printf
$LN32@main:

; 673  :     }
; 674  : 
; 675  :     /*---------------------------------------------------------------*/
; 676  :     /* Determine CKD or FBA device type                              */
; 677  :     /*---------------------------------------------------------------*/
; 678  :     if (is_dh_devid_typ( devhdr.dh_devid, CKD64_CMP_OR_SF_TYP ))

  007dd	ba 00 00 60 00	 mov	 edx, 6291456		; 00600000H
  007e2	48 8d 8c 24 60
	03 00 00	 lea	 rcx, QWORD PTR devhdr$[rsp]
  007ea	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_is_dh_devid_typ
  007f0	0f b6 c0	 movzx	 eax, al
  007f3	85 c0		 test	 eax, eax
  007f5	0f 84 a8 00 00
	00		 je	 $LN33@main

; 679  :     {
; 680  :         ckddasd = true;

  007fb	c6 44 24 70 01	 mov	 BYTE PTR ckddasd$[rsp], 1

; 681  : 
; 682  :         ckd = dasd_lookup( DASD_CKDDEV, NULL, devhdr.dh_devtyp, 0 );

  00800	0f b6 84 24 70
	03 00 00	 movzx	 eax, BYTE PTR devhdr$[rsp+16]
  00808	45 33 c9	 xor	 r9d, r9d
  0080b	44 8b c0	 mov	 r8d, eax
  0080e	33 d2		 xor	 edx, edx
  00810	b9 01 00 00 00	 mov	 ecx, 1
  00815	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_dasd_lookup
  0081b	48 89 84 24 e8
	00 00 00	 mov	 QWORD PTR ckd$[rsp], rax

; 683  : 
; 684  :         if (!ckd)

  00823	48 83 bc 24 e8
	00 00 00 00	 cmp	 QWORD PTR ckd$[rsp], 0
  0082c	75 70		 jne	 SHORT $LN35@main

; 685  :         {
; 686  :             // "DASD table entry not found for devtype 0x%2.2X"
; 687  :             FWRMSG( stderr, HHC02608, "S", devhdr.dh_devtyp );

  0082e	0f b6 84 24 70
	03 00 00	 movzx	 eax, BYTE PTR devhdr$[rsp+16]
  00836	89 84 24 e0 00
	00 00		 mov	 DWORD PTR tv317[rsp], eax
  0083d	b9 02 00 00 00	 mov	 ecx, 2
  00842	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  00848	8b 8c 24 e0 00
	00 00		 mov	 ecx, DWORD PTR tv317[rsp]
  0084f	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  00853	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG160021
  0085a	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  0085f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG160022
  00866	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  0086b	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00870	41 b9 03 00 00
	00		 mov	 r9d, 3
  00876	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG160023
  0087d	ba af 02 00 00	 mov	 edx, 687		; 000002afH
  00882	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG160024
  00889	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 688  :             clean();

  0088f	e8 00 00 00 00	 call	 clean

; 689  :             ErrExit( EXIT_NO_CKD_DASDTAB );

  00894	b9 05 00 00 00	 mov	 ecx, 5
  00899	e8 00 00 00 00	 call	 ErrExit
$LN35@main:

; 690  :         }
; 691  :     }

  0089e	e9 1f 01 00 00	 jmp	 $LN34@main
$LN33@main:

; 692  :     else if (is_dh_devid_typ( devhdr.dh_devid, FBA64_CMP_OR_SF_TYP ))

  008a3	ba 60 00 00 00	 mov	 edx, 96			; 00000060H
  008a8	48 8d 8c 24 60
	03 00 00	 lea	 rcx, QWORD PTR devhdr$[rsp]
  008b0	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_is_dh_devid_typ
  008b6	0f b6 c0	 movzx	 eax, al
  008b9	85 c0		 test	 eax, eax
  008bb	0f 84 93 00 00
	00		 je	 $LN36@main

; 693  :     {
; 694  :         ckddasd = false;

  008c1	c6 44 24 70 00	 mov	 BYTE PTR ckddasd$[rsp], 0

; 695  : 
; 696  :         fba = dasd_lookup( DASD_FBADEV, NULL, devhdr.dh_devtyp, 0 );

  008c6	0f b6 84 24 70
	03 00 00	 movzx	 eax, BYTE PTR devhdr$[rsp+16]
  008ce	45 33 c9	 xor	 r9d, r9d
  008d1	44 8b c0	 mov	 r8d, eax
  008d4	33 d2		 xor	 edx, edx
  008d6	b9 03 00 00 00	 mov	 ecx, 3
  008db	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_dasd_lookup
  008e1	48 89 84 24 00
	01 00 00	 mov	 QWORD PTR fba$[rsp], rax

; 697  : 
; 698  :         if (!fba)

  008e9	48 83 bc 24 00
	01 00 00 00	 cmp	 QWORD PTR fba$[rsp], 0
  008f2	75 5e		 jne	 SHORT $LN38@main

; 699  :         {
; 700  :             // "DASD table entry not found for devtype 0x%2.2X"
; 701  :             FWRMSG( stderr, HHC02608, "S", DEFAULT_FBA_TYPE );

  008f4	b9 02 00 00 00	 mov	 ecx, 2
  008f9	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  008ff	c7 44 24 38 70
	33 00 00	 mov	 DWORD PTR [rsp+56], 13168 ; 00003370H
  00907	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG160028
  0090e	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  00913	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG160029
  0091a	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  0091f	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00924	41 b9 03 00 00
	00		 mov	 r9d, 3
  0092a	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG160030
  00931	ba bd 02 00 00	 mov	 edx, 701		; 000002bdH
  00936	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG160031
  0093d	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 702  :             clean();

  00943	e8 00 00 00 00	 call	 clean

; 703  :             ErrExit( EXIT_NO_FBA_DASDTAB );

  00948	b9 06 00 00 00	 mov	 ecx, 6
  0094d	e8 00 00 00 00	 call	 ErrExit
$LN38@main:

; 704  :         }
; 705  :     }

  00952	eb 6e		 jmp	 SHORT $LN37@main
$LN36@main:

; 706  :     else
; 707  :     {
; 708  :         // "%s%s"
; 709  :         FWRMSG( stderr, HHC02604, "E", "incorrect header id", "" );

  00954	b9 02 00 00 00	 mov	 ecx, 2
  00959	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  0095f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG160032
  00966	48 89 4c 24 40	 mov	 QWORD PTR [rsp+64], rcx
  0096b	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG160033
  00972	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  00977	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG160034
  0097e	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  00983	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG160035
  0098a	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  0098f	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00994	41 b9 03 00 00
	00		 mov	 r9d, 3
  0099a	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG160036
  009a1	ba c5 02 00 00	 mov	 edx, 709		; 000002c5H
  009a6	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG160037
  009ad	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 710  :         clean();

  009b3	e8 00 00 00 00	 call	 clean

; 711  :         ErrExit( EXIT_WRONG_CCKD_TYPE );

  009b8	b9 09 00 00 00	 mov	 ecx, 9
  009bd	e8 00 00 00 00	 call	 ErrExit
$LN37@main:
$LN34@main:

; 712  :     }
; 713  : 
; 714  :     /*---------------------------------------------------------------*/
; 715  :     /* Set up device characteristics                                 */
; 716  :     /*---------------------------------------------------------------*/
; 717  :     if (ckddasd)

  009c2	0f b6 44 24 70	 movzx	 eax, BYTE PTR ckddasd$[rsp]
  009c7	85 c0		 test	 eax, eax
  009c9	0f 84 8d 00 00
	00		 je	 $LN39@main

; 718  :     {
; 719  :         FETCH_LE_FW( heads, devhdr.dh_heads );

  009cf	48 8d 8c 24 68
	03 00 00	 lea	 rcx, QWORD PTR devhdr$[rsp+8]
  009d7	e8 00 00 00 00	 call	 fetch_fw_noswap
  009dc	8b c8		 mov	 ecx, eax
  009de	e8 00 00 00 00	 call	 _byteswap_ulong
  009e3	8b c8		 mov	 ecx, eax
  009e5	e8 00 00 00 00	 call	 _byteswap_ulong
  009ea	89 84 24 a0 00
	00 00		 mov	 DWORD PTR heads$[rsp], eax

; 720  : 
; 721  :         if (debug)

  009f1	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR debug, 0
  009f8	74 62		 je	 SHORT $LN40@main

; 722  :         {
; 723  :             // "%s device has %d heads/cylinder"
; 724  :             WRMSG( HHC90407, "D", ckd->name, heads);

  009fa	b9 01 00 00 00	 mov	 ecx, 1
  009ff	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  00a05	8b 8c 24 a0 00
	00 00		 mov	 ecx, DWORD PTR heads$[rsp]
  00a0c	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  00a10	48 8b 8c 24 e8
	00 00 00	 mov	 rcx, QWORD PTR ckd$[rsp]
  00a18	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  00a1b	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  00a20	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG160040
  00a27	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  00a2c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG160041
  00a33	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00a38	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00a3d	41 b9 03 00 00
	00		 mov	 r9d, 3
  00a43	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG160042
  00a4a	ba d4 02 00 00	 mov	 edx, 724		; 000002d4H
  00a4f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG160043
  00a56	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg
$LN40@main:
$LN39@main:

; 725  :         }
; 726  :     }
; 727  : 
; 728  :     /*---------------------------------------------------------------*/
; 729  :     /* display CDEVHDR - follows DEVHDR                              */
; 730  :     /*---------------------------------------------------------------*/
; 731  :     readpos( fd, &cdevhdr, CKD_DEVHDR_SIZE, sizeof( cdevhdr ));

  00a5c	41 b9 00 02 00
	00		 mov	 r9d, 512		; 00000200H
  00a62	41 b8 00 02 00
	00		 mov	 r8d, 512		; 00000200H
  00a68	48 8d 94 24 60
	01 00 00	 lea	 rdx, QWORD PTR cdevhdr$[rsp]
  00a70	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR fd
  00a76	e8 00 00 00 00	 call	 readpos

; 732  : 
; 733  :     if (cmd_cdevhdr)

  00a7b	0f b6 44 24 7d	 movzx	 eax, BYTE PTR cmd_cdevhdr$[rsp]
  00a80	85 c0		 test	 eax, eax
  00a82	0f 84 86 00 00
	00		 je	 $LN41@main

; 734  :     {
; 735  :         // "%s - %d (decimal) bytes:"
; 736  :         printf("\n");

  00a88	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG160045
  00a8f	e8 00 00 00 00	 call	 printf

; 737  :         WRMSG( HHC02614, "I", "CDEVHDR", (int) sizeof( cdevhdr ));

  00a94	b9 01 00 00 00	 mov	 ecx, 1
  00a99	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  00a9f	c7 44 24 40 00
	02 00 00	 mov	 DWORD PTR [rsp+64], 512	; 00000200H
  00aa7	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG160046
  00aae	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  00ab3	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG160047
  00aba	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  00abf	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG160048
  00ac6	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00acb	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00ad0	41 b9 03 00 00
	00		 mov	 r9d, 3
  00ad6	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG160049
  00add	ba e1 02 00 00	 mov	 edx, 737		; 000002e1H
  00ae2	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG160050
  00ae9	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 738  :         data_dump( &cdevhdr, sizeof( cdevhdr ));

  00aef	ba 00 02 00 00	 mov	 edx, 512		; 00000200H
  00af4	48 8d 8c 24 60
	01 00 00	 lea	 rcx, QWORD PTR cdevhdr$[rsp]
  00afc	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_data_dump

; 739  :         printf("\n");

  00b02	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG160051
  00b09	e8 00 00 00 00	 call	 printf
$LN41@main:

; 740  :     }
; 741  : 
; 742  :     /*---------------------------------------------------------------*/
; 743  :     /* Find machine endian-ness                                      */
; 744  :     /* cckd_def_opt_bigend() returns 1 for big-endian machines       */
; 745  :     /*---------------------------------------------------------------*/
; 746  :     swapend = (cckd_def_opt_bigend() !=

  00b0e	0f b6 84 24 63
	01 00 00	 movzx	 eax, BYTE PTR cdevhdr$[rsp+3]
  00b16	83 e0 02	 and	 eax, 2
  00b19	85 c0		 test	 eax, eax
  00b1b	74 0d		 je	 SHORT $LN64@main
  00b1d	c7 84 24 d0 00
	00 00 01 00 00
	00		 mov	 DWORD PTR tv442[rsp], 1
  00b28	eb 0b		 jmp	 SHORT $LN65@main
$LN64@main:
  00b2a	c7 84 24 d0 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv442[rsp], 0
$LN65@main:
  00b35	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_cckd_def_opt_bigend
  00b3b	3b 84 24 d0 00
	00 00		 cmp	 eax, DWORD PTR tv442[rsp]
  00b42	74 0d		 je	 SHORT $LN66@main
  00b44	c7 84 24 cc 00
	00 00 01 00 00
	00		 mov	 DWORD PTR tv444[rsp], 1
  00b4f	eb 0b		 jmp	 SHORT $LN67@main
$LN66@main:
  00b51	c7 84 24 cc 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv444[rsp], 0
$LN67@main:
  00b5c	83 bc 24 cc 00
	00 00 00	 cmp	 DWORD PTR tv444[rsp], 0
  00b64	75 0d		 jne	 SHORT $LN68@main
  00b66	c7 84 24 d4 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv446[rsp], 0
  00b71	eb 0b		 jmp	 SHORT $LN69@main
$LN68@main:
  00b73	c7 84 24 d4 00
	00 00 01 00 00
	00		 mov	 DWORD PTR tv446[rsp], 1
$LN69@main:
  00b7e	0f b6 84 24 d4
	00 00 00	 movzx	 eax, BYTE PTR tv446[rsp]
  00b86	88 44 24 72	 mov	 BYTE PTR swapend$[rsp], al

; 747  :                ((cdevhdr.cdh_opts & CCKD_OPT_BIGEND) != 0));
; 748  : 
; 749  :     /*---------------------------------------------------------------*/
; 750  :     /* display L1TAB - follows CDEVHDR                               */
; 751  :     /*---------------------------------------------------------------*/
; 752  : 
; 753  :     /* swap num_L1tab if needed */
; 754  :     num_L1tab = cdevhdr.num_L1tab;

  00b8a	8b 84 24 64 01
	00 00		 mov	 eax, DWORD PTR cdevhdr$[rsp+4]
  00b91	89 84 24 8c 00
	00 00		 mov	 DWORD PTR num_L1tab$[rsp], eax

; 755  :     if (swapend)

  00b98	0f b6 44 24 72	 movzx	 eax, BYTE PTR swapend$[rsp]
  00b9d	85 c0		 test	 eax, eax
  00b9f	74 13		 je	 SHORT $LN42@main

; 756  :         num_L1tab = SWAP32( num_L1tab );

  00ba1	8b 8c 24 8c 00
	00 00		 mov	 ecx, DWORD PTR num_L1tab$[rsp]
  00ba8	e8 00 00 00 00	 call	 _byteswap_ulong
  00bad	89 84 24 8c 00
	00 00		 mov	 DWORD PTR num_L1tab$[rsp], eax
$LN42@main:

; 757  : 
; 758  :     L1tab = makbuf(                       num_L1tab * CCKD64_L1ENT_SIZE, "L1TAB64" );

  00bb4	48 63 84 24 8c
	00 00 00	 movsxd	 rax, DWORD PTR num_L1tab$[rsp]
  00bbc	48 c1 e0 03	 shl	 rax, 3
  00bc0	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG160053
  00bc7	8b c8		 mov	 ecx, eax
  00bc9	e8 00 00 00 00	 call	 makbuf
  00bce	48 89 05 00 00
	00 00		 mov	 QWORD PTR L1tab, rax

; 759  :     readpos( fd, L1tab, CCKD64_L1TAB_POS, num_L1tab * CCKD64_L1ENT_SIZE );

  00bd5	48 63 84 24 8c
	00 00 00	 movsxd	 rax, DWORD PTR num_L1tab$[rsp]
  00bdd	48 c1 e0 03	 shl	 rax, 3
  00be1	44 8b c8	 mov	 r9d, eax
  00be4	41 b8 00 04 00
	00		 mov	 r8d, 1024		; 00000400H
  00bea	48 8b 15 00 00
	00 00		 mov	 rdx, QWORD PTR L1tab
  00bf1	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR fd
  00bf7	e8 00 00 00 00	 call	 readpos

; 760  : 
; 761  :     /* L1TAB itself is NOT adjusted for endian-ness */
; 762  :     if (cmd_l1tab)

  00bfc	0f b6 44 24 7e	 movzx	 eax, BYTE PTR cmd_l1tab$[rsp]
  00c01	85 c0		 test	 eax, eax
  00c03	0f 84 a6 00 00
	00		 je	 $LN43@main

; 763  :     {
; 764  :         // "%s - %d (decimal) bytes:"
; 765  :         printf("\n");

  00c09	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG160055
  00c10	e8 00 00 00 00	 call	 printf

; 766  :         WRMSG( HHC02614, "I", "L1TAB", (int) (num_L1tab * CCKD64_L1ENT_SIZE) );

  00c15	48 63 84 24 8c
	00 00 00	 movsxd	 rax, DWORD PTR num_L1tab$[rsp]
  00c1d	48 c1 e0 03	 shl	 rax, 3
  00c21	48 89 84 24 48
	01 00 00	 mov	 QWORD PTR tv469[rsp], rax
  00c29	b9 01 00 00 00	 mov	 ecx, 1
  00c2e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  00c34	48 8b 8c 24 48
	01 00 00	 mov	 rcx, QWORD PTR tv469[rsp]
  00c3c	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  00c40	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG160056
  00c47	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  00c4c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG160057
  00c53	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  00c58	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG160058
  00c5f	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00c64	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00c69	41 b9 03 00 00
	00		 mov	 r9d, 3
  00c6f	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG160059
  00c76	ba fe 02 00 00	 mov	 edx, 766		; 000002feH
  00c7b	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG160060
  00c82	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 767  :         data_dump( L1tab, num_L1tab * CCKD64_L1ENT_SIZE );

  00c88	48 63 84 24 8c
	00 00 00	 movsxd	 rax, DWORD PTR num_L1tab$[rsp]
  00c90	48 c1 e0 03	 shl	 rax, 3
  00c94	8b d0		 mov	 edx, eax
  00c96	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR L1tab
  00c9d	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_data_dump

; 768  :         printf("\n");

  00ca3	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG160061
  00caa	e8 00 00 00 00	 call	 printf
$LN43@main:

; 769  :     }
; 770  : 
; 771  :     /*---------------------------------------------------------------*/
; 772  :     /* display OFFSET, LENGTH data                                   */
; 773  :     /*---------------------------------------------------------------*/
; 774  :     if (cmd_offset)

  00caf	0f b6 44 24 7f	 movzx	 eax, BYTE PTR cmd_offset$[rsp]
  00cb4	85 c0		 test	 eax, eax
  00cb6	0f 84 0f 01 00
	00		 je	 $LN44@main

; 775  :     {
; 776  :         bulk = makbuf(op_length, "BULK");

  00cbc	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG160063
  00cc3	8b 8c 24 94 00
	00 00		 mov	 ecx, DWORD PTR op_length$[rsp]
  00cca	e8 00 00 00 00	 call	 makbuf
  00ccf	48 89 05 00 00
	00 00		 mov	 QWORD PTR bulk, rax

; 777  : 
; 778  :         readpos(fd, bulk, op_offset, op_length);

  00cd6	44 8b 8c 24 94
	00 00 00	 mov	 r9d, DWORD PTR op_length$[rsp]
  00cde	4c 8b 84 24 d8
	00 00 00	 mov	 r8, QWORD PTR op_offset$[rsp]
  00ce6	48 8b 15 00 00
	00 00		 mov	 rdx, QWORD PTR bulk
  00ced	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR fd
  00cf3	e8 00 00 00 00	 call	 readpos

; 779  : 
; 780  :         // "%s offset %"PRId64" (0x%16.16"PRIX64"); length %d (0x%8.8X) bytes%s"
; 781  :         printf("\n");

  00cf8	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG160064
  00cff	e8 00 00 00 00	 call	 printf

; 782  :         WRMSG( HHC02613, "I", "IMAGE",

  00d04	b9 01 00 00 00	 mov	 ecx, 1
  00d09	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  00d0f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG160065
  00d16	48 89 4c 24 60	 mov	 QWORD PTR [rsp+96], rcx
  00d1b	8b 8c 24 94 00
	00 00		 mov	 ecx, DWORD PTR op_length$[rsp]
  00d22	89 4c 24 58	 mov	 DWORD PTR [rsp+88], ecx
  00d26	8b 8c 24 94 00
	00 00		 mov	 ecx, DWORD PTR op_length$[rsp]
  00d2d	89 4c 24 50	 mov	 DWORD PTR [rsp+80], ecx
  00d31	48 8b 8c 24 d8
	00 00 00	 mov	 rcx, QWORD PTR op_offset$[rsp]
  00d39	48 89 4c 24 48	 mov	 QWORD PTR [rsp+72], rcx
  00d3e	48 8b 8c 24 d8
	00 00 00	 mov	 rcx, QWORD PTR op_offset$[rsp]
  00d46	48 89 4c 24 40	 mov	 QWORD PTR [rsp+64], rcx
  00d4b	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG160066
  00d52	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  00d57	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG160067
  00d5e	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  00d63	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG160068
  00d6a	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00d6f	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00d74	41 b9 03 00 00
	00		 mov	 r9d, 3
  00d7a	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG160069
  00d81	ba 0f 03 00 00	 mov	 edx, 783		; 0000030fH
  00d86	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG160070
  00d8d	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 783  :             op_offset, op_offset, op_length, op_length, ":" );
; 784  :         data_dump( bulk, op_length );

  00d93	8b 94 24 94 00
	00 00		 mov	 edx, DWORD PTR op_length$[rsp]
  00d9a	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR bulk
  00da1	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_data_dump

; 785  :         printf("\n");

  00da7	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG160071
  00dae	e8 00 00 00 00	 call	 printf

; 786  : 
; 787  :         free(bulk);

  00db3	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR bulk
  00dba	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free

; 788  :         bulk = NULL;

  00dc0	48 c7 05 00 00
	00 00 00 00 00
	00		 mov	 QWORD PTR bulk, 0
$LN44@main:

; 789  :     }
; 790  : 
; 791  :     /*---------------------------------------------------------------*/
; 792  :     /* FBA devices don't have cylinders or heads                     */
; 793  :     /*---------------------------------------------------------------*/
; 794  :     if (!ckddasd && cmd_cchh)

  00dcb	0f b6 44 24 70	 movzx	 eax, BYTE PTR ckddasd$[rsp]
  00dd0	85 c0		 test	 eax, eax
  00dd2	75 77		 jne	 SHORT $LN45@main
  00dd4	0f b6 44 24 73	 movzx	 eax, BYTE PTR cmd_cchh$[rsp]
  00dd9	85 c0		 test	 eax, eax
  00ddb	74 6e		 je	 SHORT $LN45@main

; 795  :     {
; 796  :         // "%s%s"
; 797  :         FWRMSG( stderr, HHC02604, "S", "CCHH not supported for FBA", "" );

  00ddd	b9 02 00 00 00	 mov	 ecx, 2
  00de2	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  00de8	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG160073
  00def	48 89 4c 24 40	 mov	 QWORD PTR [rsp+64], rcx
  00df4	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG160074
  00dfb	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  00e00	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG160075
  00e07	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  00e0c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG160076
  00e13	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00e18	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00e1d	41 b9 03 00 00
	00		 mov	 r9d, 3
  00e23	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG160077
  00e2a	ba 1d 03 00 00	 mov	 edx, 797		; 0000031dH
  00e2f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG160078
  00e36	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 798  :         clean();

  00e3c	e8 00 00 00 00	 call	 clean

; 799  :         ErrExit( EXIT_NO_FBA_CCHH );

  00e41	b9 03 00 00 00	 mov	 ecx, 3
  00e46	e8 00 00 00 00	 call	 ErrExit
$LN45@main:

; 800  :     }
; 801  : 
; 802  :     /*---------------------------------------------------------------*/
; 803  :     /* Setup CCHH or relative track request                          */
; 804  :     /*---------------------------------------------------------------*/
; 805  :     if (ckddasd)

  00e4b	0f b6 44 24 70	 movzx	 eax, BYTE PTR ckddasd$[rsp]
  00e50	85 c0		 test	 eax, eax
  00e52	0f 84 80 00 00
	00		 je	 $LN46@main

; 806  :     {
; 807  :         if (cmd_tt)

  00e58	0f b6 44 24 71	 movzx	 eax, BYTE PTR cmd_tt$[rsp]
  00e5d	85 c0		 test	 eax, eax
  00e5f	74 35		 je	 SHORT $LN47@main

; 808  :         {
; 809  :             trk = op_tt;

  00e61	8b 84 24 b8 00
	00 00		 mov	 eax, DWORD PTR op_tt$[rsp]
  00e68	89 44 24 78	 mov	 DWORD PTR trk$[rsp], eax

; 810  :             op_cc = trk / heads;

  00e6c	8b 44 24 78	 mov	 eax, DWORD PTR trk$[rsp]
  00e70	99		 cdq
  00e71	f7 bc 24 a0 00
	00 00		 idiv	 DWORD PTR heads$[rsp]
  00e78	89 84 24 ac 00
	00 00		 mov	 DWORD PTR op_cc$[rsp], eax

; 811  :             op_hh = trk % heads;

  00e7f	8b 44 24 78	 mov	 eax, DWORD PTR trk$[rsp]
  00e83	99		 cdq
  00e84	f7 bc 24 a0 00
	00 00		 idiv	 DWORD PTR heads$[rsp]
  00e8b	8b c2		 mov	 eax, edx
  00e8d	89 84 24 a8 00
	00 00		 mov	 DWORD PTR op_hh$[rsp], eax

; 812  :         }

  00e94	eb 1a		 jmp	 SHORT $LN48@main
$LN47@main:

; 813  :         else
; 814  :         {
; 815  :             trk = (op_cc * heads) + op_hh;

  00e96	8b 84 24 ac 00
	00 00		 mov	 eax, DWORD PTR op_cc$[rsp]
  00e9d	0f af 84 24 a0
	00 00 00	 imul	 eax, DWORD PTR heads$[rsp]
  00ea5	03 84 24 a8 00
	00 00		 add	 eax, DWORD PTR op_hh$[rsp]
  00eac	89 44 24 78	 mov	 DWORD PTR trk$[rsp], eax
$LN48@main:

; 816  :         }
; 817  : 
; 818  :         L1ndx = trk / cdevhdr.num_L2tab;

  00eb0	8b 44 24 78	 mov	 eax, DWORD PTR trk$[rsp]
  00eb4	99		 cdq
  00eb5	f7 bc 24 68 01
	00 00		 idiv	 DWORD PTR cdevhdr$[rsp+8]
  00ebc	89 84 24 90 00
	00 00		 mov	 DWORD PTR L1ndx$[rsp], eax

; 819  :         L2ndx = trk % cdevhdr.num_L2tab;

  00ec3	8b 44 24 78	 mov	 eax, DWORD PTR trk$[rsp]
  00ec7	99		 cdq
  00ec8	f7 bc 24 68 01
	00 00		 idiv	 DWORD PTR cdevhdr$[rsp+8]
  00ecf	8b c2		 mov	 eax, edx
  00ed1	89 84 24 88 00
	00 00		 mov	 DWORD PTR L2ndx$[rsp], eax
$LN46@main:

; 820  :     }
; 821  : 
; 822  :     /*---------------------------------------------------------------*/
; 823  :     /* For FBA devices a relative track is treated as a block number */
; 824  :     /*---------------------------------------------------------------*/
; 825  :     if (!ckddasd && cmd_tt)

  00ed8	0f b6 44 24 70	 movzx	 eax, BYTE PTR ckddasd$[rsp]
  00edd	85 c0		 test	 eax, eax
  00edf	75 55		 jne	 SHORT $LN49@main
  00ee1	0f b6 44 24 71	 movzx	 eax, BYTE PTR cmd_tt$[rsp]
  00ee6	85 c0		 test	 eax, eax
  00ee8	74 4c		 je	 SHORT $LN49@main

; 826  :     {
; 827  :         int blkgrp = (trk = op_tt) / CFBA_BLKS_PER_GRP;

  00eea	8b 84 24 b8 00
	00 00		 mov	 eax, DWORD PTR op_tt$[rsp]
  00ef1	89 44 24 78	 mov	 DWORD PTR trk$[rsp], eax
  00ef5	8b 44 24 78	 mov	 eax, DWORD PTR trk$[rsp]
  00ef9	99		 cdq
  00efa	b9 78 00 00 00	 mov	 ecx, 120		; 00000078H
  00eff	f7 f9		 idiv	 ecx
  00f01	89 84 24 c8 00
	00 00		 mov	 DWORD PTR blkgrp$1[rsp], eax

; 828  : 
; 829  :         L1ndx = blkgrp / cdevhdr.num_L2tab;

  00f08	8b 84 24 c8 00
	00 00		 mov	 eax, DWORD PTR blkgrp$1[rsp]
  00f0f	99		 cdq
  00f10	f7 bc 24 68 01
	00 00		 idiv	 DWORD PTR cdevhdr$[rsp+8]
  00f17	89 84 24 90 00
	00 00		 mov	 DWORD PTR L1ndx$[rsp], eax

; 830  :         L2ndx = blkgrp % cdevhdr.num_L2tab;

  00f1e	8b 84 24 c8 00
	00 00		 mov	 eax, DWORD PTR blkgrp$1[rsp]
  00f25	99		 cdq
  00f26	f7 bc 24 68 01
	00 00		 idiv	 DWORD PTR cdevhdr$[rsp+8]
  00f2d	8b c2		 mov	 eax, edx
  00f2f	89 84 24 88 00
	00 00		 mov	 DWORD PTR L2ndx$[rsp], eax
$LN49@main:

; 831  :     }
; 832  : 
; 833  :     /*---------------------------------------------------------------*/
; 834  :     /* Verify device is large enough for the request                 */
; 835  :     /*---------------------------------------------------------------*/
; 836  :     if (L1ndx >= num_L1tab)

  00f36	8b 84 24 8c 00
	00 00		 mov	 eax, DWORD PTR num_L1tab$[rsp]
  00f3d	39 84 24 90 00
	00 00		 cmp	 DWORD PTR L1ndx$[rsp], eax
  00f44	0f 8c 94 00 00
	00		 jl	 $LN50@main

; 837  :     {
; 838  :         // "%s %d does not exist on this device"
; 839  :         FWRMSG( stderr, HHC02617, "S", ckddasd ? "Track" : "Block", trk );

  00f4a	0f b6 44 24 70	 movzx	 eax, BYTE PTR ckddasd$[rsp]
  00f4f	85 c0		 test	 eax, eax
  00f51	74 11		 je	 SHORT $LN70@main
  00f53	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG160084
  00f5a	48 89 84 24 08
	01 00 00	 mov	 QWORD PTR tv586[rsp], rax
  00f62	eb 0f		 jmp	 SHORT $LN71@main
$LN70@main:
  00f64	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG160085
  00f6b	48 89 84 24 08
	01 00 00	 mov	 QWORD PTR tv586[rsp], rax
$LN71@main:
  00f73	b9 02 00 00 00	 mov	 ecx, 2
  00f78	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  00f7e	8b 4c 24 78	 mov	 ecx, DWORD PTR trk$[rsp]
  00f82	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  00f86	48 8b 8c 24 08
	01 00 00	 mov	 rcx, QWORD PTR tv586[rsp]
  00f8e	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  00f93	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG160086
  00f9a	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  00f9f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG160087
  00fa6	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00fab	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00fb0	41 b9 03 00 00
	00		 mov	 r9d, 3
  00fb6	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG160088
  00fbd	ba 47 03 00 00	 mov	 edx, 839		; 00000347H
  00fc2	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG160089
  00fc9	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 840  :         clean();

  00fcf	e8 00 00 00 00	 call	 clean

; 841  :         ErrExit( EXIT_DATA_NOTFOUND );

  00fd4	b9 07 00 00 00	 mov	 ecx, 7
  00fd9	e8 00 00 00 00	 call	 ErrExit
$LN50@main:

; 842  :     }
; 843  : 
; 844  :     L2taboff = L1tab[ L1ndx ];

  00fde	48 63 84 24 90
	00 00 00	 movsxd	 rax, DWORD PTR L1ndx$[rsp]
  00fe6	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR L1tab
  00fed	48 8b 04 c1	 mov	 rax, QWORD PTR [rcx+rax*8]
  00ff1	48 89 84 24 b0
	00 00 00	 mov	 QWORD PTR L2taboff$[rsp], rax

; 845  : 
; 846  :     if (swapend)

  00ff9	0f b6 44 24 72	 movzx	 eax, BYTE PTR swapend$[rsp]
  00ffe	85 c0		 test	 eax, eax
  01000	74 15		 je	 SHORT $LN51@main

; 847  :         L2taboff = SWAP_OFF_T( L2taboff );

  01002	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR L2taboff$[rsp]
  0100a	e8 00 00 00 00	 call	 _byteswap_uint64
  0100f	48 89 84 24 b0
	00 00 00	 mov	 QWORD PTR L2taboff$[rsp], rax
$LN51@main:

; 848  : 
; 849  :     /*---------------------------------------------------------------*/
; 850  :     /* Display CKD CCHH or relative track or FBA relative block data */
; 851  :     /*---------------------------------------------------------------*/
; 852  :     if ((cmd_cchh) || (cmd_tt))

  01017	0f b6 44 24 73	 movzx	 eax, BYTE PTR cmd_cchh$[rsp]
  0101c	85 c0		 test	 eax, eax
  0101e	75 0d		 jne	 SHORT $LN53@main
  01020	0f b6 44 24 71	 movzx	 eax, BYTE PTR cmd_tt$[rsp]
  01025	85 c0		 test	 eax, eax
  01027	0f 84 09 07 00
	00		 je	 $LN52@main
$LN53@main:

; 853  :     {
; 854  :         if (ckddasd)

  0102d	0f b6 44 24 70	 movzx	 eax, BYTE PTR ckddasd$[rsp]
  01032	85 c0		 test	 eax, eax
  01034	74 7d		 je	 SHORT $LN54@main

; 855  :             // "CC %d HH %d = reltrk %d; L1 index = %d, L2 index = %d"
; 856  :             WRMSG( HHC02609, "I", op_cc, op_hh, trk, L1ndx, L2ndx );

  01036	b9 01 00 00 00	 mov	 ecx, 1
  0103b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  01041	8b 8c 24 88 00
	00 00		 mov	 ecx, DWORD PTR L2ndx$[rsp]
  01048	89 4c 24 58	 mov	 DWORD PTR [rsp+88], ecx
  0104c	8b 8c 24 90 00
	00 00		 mov	 ecx, DWORD PTR L1ndx$[rsp]
  01053	89 4c 24 50	 mov	 DWORD PTR [rsp+80], ecx
  01057	8b 4c 24 78	 mov	 ecx, DWORD PTR trk$[rsp]
  0105b	89 4c 24 48	 mov	 DWORD PTR [rsp+72], ecx
  0105f	8b 8c 24 a8 00
	00 00		 mov	 ecx, DWORD PTR op_hh$[rsp]
  01066	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  0106a	8b 8c 24 ac 00
	00 00		 mov	 ecx, DWORD PTR op_cc$[rsp]
  01071	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  01075	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG160095
  0107c	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  01081	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG160096
  01088	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  0108d	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  01092	41 b9 03 00 00
	00		 mov	 r9d, 3
  01098	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG160097
  0109f	ba 58 03 00 00	 mov	 edx, 856		; 00000358H
  010a4	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG160098
  010ab	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg
  010b1	eb 65		 jmp	 SHORT $LN55@main
$LN54@main:

; 857  :         else
; 858  :             // "Block %d; L1 index = %d, L2 index = %d"
; 859  :             WRMSG( HHC02615, "I", trk, L1ndx, L2ndx );

  010b3	b9 01 00 00 00	 mov	 ecx, 1
  010b8	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  010be	8b 8c 24 88 00
	00 00		 mov	 ecx, DWORD PTR L2ndx$[rsp]
  010c5	89 4c 24 48	 mov	 DWORD PTR [rsp+72], ecx
  010c9	8b 8c 24 90 00
	00 00		 mov	 ecx, DWORD PTR L1ndx$[rsp]
  010d0	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  010d4	8b 4c 24 78	 mov	 ecx, DWORD PTR trk$[rsp]
  010d8	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  010dc	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG160099
  010e3	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  010e8	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG160100
  010ef	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  010f4	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  010f9	41 b9 03 00 00
	00		 mov	 r9d, 3
  010ff	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG160101
  01106	ba 5b 03 00 00	 mov	 edx, 859		; 0000035bH
  0110b	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG160102
  01112	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg
$LN55@main:

; 860  : 
; 861  :         // "L1 index %d = L2TAB offset %"PRId64" (0x%16.16"PRIX64")"
; 862  :         WRMSG( HHC02610, "I", L1ndx, L2taboff, L2taboff );

  01118	b9 01 00 00 00	 mov	 ecx, 1
  0111d	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  01123	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR L2taboff$[rsp]
  0112b	48 89 4c 24 48	 mov	 QWORD PTR [rsp+72], rcx
  01130	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR L2taboff$[rsp]
  01138	48 89 4c 24 40	 mov	 QWORD PTR [rsp+64], rcx
  0113d	8b 8c 24 90 00
	00 00		 mov	 ecx, DWORD PTR L1ndx$[rsp]
  01144	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  01148	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG160103
  0114f	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  01154	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG160104
  0115b	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  01160	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  01165	41 b9 03 00 00
	00		 mov	 r9d, 3
  0116b	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG160105
  01172	ba 5e 03 00 00	 mov	 edx, 862		; 0000035eH
  01177	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG160106
  0117e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 863  : 
; 864  :         // PROGRAMMING NOTE: for whatever reason, base dasd image files
; 865  :         // use a L2_trkoff value of zero in their L1tab entry for non-
; 866  :         // existent tracks, whereas shadow files use a value of -1, so
; 867  :         // we need to check for both.
; 868  : 
; 869  :         if (!L2taboff || L2taboff == CCKD64_MAXSIZE)

  01184	48 83 bc 24 b0
	00 00 00 00	 cmp	 QWORD PTR L2taboff$[rsp], 0
  0118d	74 0f		 je	 SHORT $LN57@main
  0118f	48 83 bc 24 b0
	00 00 00 ff	 cmp	 QWORD PTR L2taboff$[rsp], -1
  01198	0f 85 94 00 00
	00		 jne	 $LN56@main
$LN57@main:

; 870  :         {
; 871  :             // "L2tab for %s %d not found"
; 872  :             FWRMSG( stderr, HHC02618, "S", ckddasd ? "track" : "block", trk );

  0119e	0f b6 44 24 70	 movzx	 eax, BYTE PTR ckddasd$[rsp]
  011a3	85 c0		 test	 eax, eax
  011a5	74 11		 je	 SHORT $LN72@main
  011a7	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG160109
  011ae	48 89 84 24 10
	01 00 00	 mov	 QWORD PTR tv654[rsp], rax
  011b6	eb 0f		 jmp	 SHORT $LN73@main
$LN72@main:
  011b8	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG160110
  011bf	48 89 84 24 10
	01 00 00	 mov	 QWORD PTR tv654[rsp], rax
$LN73@main:
  011c7	b9 02 00 00 00	 mov	 ecx, 2
  011cc	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  011d2	8b 4c 24 78	 mov	 ecx, DWORD PTR trk$[rsp]
  011d6	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  011da	48 8b 8c 24 10
	01 00 00	 mov	 rcx, QWORD PTR tv654[rsp]
  011e2	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  011e7	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG160111
  011ee	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  011f3	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG160112
  011fa	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  011ff	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  01204	41 b9 03 00 00
	00		 mov	 r9d, 3
  0120a	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG160113
  01211	ba 68 03 00 00	 mov	 edx, 872		; 00000368H
  01216	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG160114
  0121d	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 873  :             clean();

  01223	e8 00 00 00 00	 call	 clean

; 874  :             ErrExit( EXIT_DATA_NOTFOUND );

  01228	b9 07 00 00 00	 mov	 ecx, 7
  0122d	e8 00 00 00 00	 call	 ErrExit
$LN56@main:

; 875  :         }
; 876  : 
; 877  :         L2tab = makbuf(               cdevhdr.num_L2tab * CCKD64_L2ENT_SIZE, "L2TAB64" );

  01232	48 63 84 24 68
	01 00 00	 movsxd	 rax, DWORD PTR cdevhdr$[rsp+8]
  0123a	48 6b c0 10	 imul	 rax, rax, 16
  0123e	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG160115
  01245	8b c8		 mov	 ecx, eax
  01247	e8 00 00 00 00	 call	 makbuf
  0124c	48 89 05 00 00
	00 00		 mov	 QWORD PTR L2tab, rax

; 878  :         readpos( fd, L2tab, L2taboff, cdevhdr.num_L2tab * CCKD64_L2ENT_SIZE );

  01253	48 63 84 24 68
	01 00 00	 movsxd	 rax, DWORD PTR cdevhdr$[rsp+8]
  0125b	48 6b c0 10	 imul	 rax, rax, 16
  0125f	44 8b c8	 mov	 r9d, eax
  01262	4c 8b 84 24 b0
	00 00 00	 mov	 r8, QWORD PTR L2taboff$[rsp]
  0126a	48 8b 15 00 00
	00 00		 mov	 rdx, QWORD PTR L2tab
  01271	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR fd
  01277	e8 00 00 00 00	 call	 readpos

; 879  : 
; 880  :         if (cmd_l2tab)

  0127c	0f b6 84 24 80
	00 00 00	 movzx	 eax, BYTE PTR cmd_l2tab$[rsp]
  01284	85 c0		 test	 eax, eax
  01286	0f 84 9a 00 00
	00		 je	 $LN58@main

; 881  :         {
; 882  :             // "%s - %d (decimal) bytes:"
; 883  :             printf("\n");

  0128c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG160117
  01293	e8 00 00 00 00	 call	 printf

; 884  :             WRMSG( HHC02614, "I", "L2TAB",

  01298	48 63 84 24 68
	01 00 00	 movsxd	 rax, DWORD PTR cdevhdr$[rsp+8]
  012a0	48 6b c0 10	 imul	 rax, rax, 16
  012a4	48 89 84 24 50
	01 00 00	 mov	 QWORD PTR tv683[rsp], rax
  012ac	b9 01 00 00 00	 mov	 ecx, 1
  012b1	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  012b7	48 8b 8c 24 50
	01 00 00	 mov	 rcx, QWORD PTR tv683[rsp]
  012bf	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  012c3	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG160118
  012ca	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  012cf	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG160119
  012d6	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  012db	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG160120
  012e2	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  012e7	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  012ec	41 b9 03 00 00
	00		 mov	 r9d, 3
  012f2	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG160121
  012f9	ba 75 03 00 00	 mov	 edx, 885		; 00000375H
  012fe	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG160122
  01305	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 885  :                 (int)         (cdevhdr.num_L2tab * CCKD64_L2ENT_SIZE));
; 886  :             data_dump( L2tab, (cdevhdr.num_L2tab * CCKD64_L2ENT_SIZE));

  0130b	48 63 84 24 68
	01 00 00	 movsxd	 rax, DWORD PTR cdevhdr$[rsp+8]
  01313	48 6b c0 10	 imul	 rax, rax, 16
  01317	8b d0		 mov	 edx, eax
  01319	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR L2tab
  01320	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_data_dump
$LN58@main:

; 887  :         }
; 888  : 
; 889  :         // "L2 index %d = L2TAB entry: %d bytes:"
; 890  :         printf("\n");

  01326	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG160123
  0132d	e8 00 00 00 00	 call	 printf

; 891  :         WRMSG( HHC02611, "I", L2ndx, (int) CCKD64_L2ENT_SIZE);

  01332	b9 01 00 00 00	 mov	 ecx, 1
  01337	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  0133d	c7 44 24 40 10
	00 00 00	 mov	 DWORD PTR [rsp+64], 16
  01345	8b 8c 24 88 00
	00 00		 mov	 ecx, DWORD PTR L2ndx$[rsp]
  0134c	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  01350	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG160124
  01357	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  0135c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG160125
  01363	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  01368	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  0136d	41 b9 03 00 00
	00		 mov	 r9d, 3
  01373	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG160126
  0137a	ba 7b 03 00 00	 mov	 edx, 891		; 0000037bH
  0137f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG160127
  01386	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 892  :         data_dump( &L2tab[ L2ndx ],        CCKD64_L2ENT_SIZE);

  0138c	48 63 84 24 88
	00 00 00	 movsxd	 rax, DWORD PTR L2ndx$[rsp]
  01394	48 6b c0 10	 imul	 rax, rax, 16
  01398	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR L2tab
  0139f	48 03 c8	 add	 rcx, rax
  013a2	48 8b c1	 mov	 rax, rcx
  013a5	ba 10 00 00 00	 mov	 edx, 16
  013aa	48 8b c8	 mov	 rcx, rax
  013ad	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_data_dump

; 893  :         printf("\n");

  013b3	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG160128
  013ba	e8 00 00 00 00	 call	 printf

; 894  : 
; 895  :         trkhdroff = L2tab[ L2ndx ].L2_trkoff;

  013bf	48 63 84 24 88
	00 00 00	 movsxd	 rax, DWORD PTR L2ndx$[rsp]
  013c7	48 6b c0 10	 imul	 rax, rax, 16
  013cb	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR L2tab
  013d2	48 8b 04 01	 mov	 rax, QWORD PTR [rcx+rax]
  013d6	48 89 84 24 c0
	00 00 00	 mov	 QWORD PTR trkhdroff$[rsp], rax

; 896  :         imglen    = L2tab[ L2ndx ].L2_len;

  013de	48 63 84 24 88
	00 00 00	 movsxd	 rax, DWORD PTR L2ndx$[rsp]
  013e6	48 6b c0 10	 imul	 rax, rax, 16
  013ea	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR L2tab
  013f1	0f b7 44 01 08	 movzx	 eax, WORD PTR [rcx+rax+8]
  013f6	89 84 24 84 00
	00 00		 mov	 DWORD PTR imglen$[rsp], eax

; 897  : 
; 898  :         if (swapend)

  013fd	0f b6 44 24 72	 movzx	 eax, BYTE PTR swapend$[rsp]
  01402	85 c0		 test	 eax, eax
  01404	74 28		 je	 SHORT $LN59@main

; 899  :         {
; 900  :             trkhdroff = SWAP_OFF_T( trkhdroff );

  01406	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR trkhdroff$[rsp]
  0140e	e8 00 00 00 00	 call	 _byteswap_uint64
  01413	48 89 84 24 c0
	00 00 00	 mov	 QWORD PTR trkhdroff$[rsp], rax

; 901  :             imglen    = SWAP32( imglen );

  0141b	8b 8c 24 84 00
	00 00		 mov	 ecx, DWORD PTR imglen$[rsp]
  01422	e8 00 00 00 00	 call	 _byteswap_ulong
  01427	89 84 24 84 00
	00 00		 mov	 DWORD PTR imglen$[rsp], eax
$LN59@main:

; 902  :         }
; 903  : 
; 904  :         // "%s offset %"PRId64" (0x%16.16"PRIX64"); length %d (0x%8.8X) bytes%s"
; 905  :         WRMSG( HHC02613, "I", ckddasd ? "TRKHDR" : "BKGHDR",

  0142e	0f b6 44 24 70	 movzx	 eax, BYTE PTR ckddasd$[rsp]
  01433	85 c0		 test	 eax, eax
  01435	74 11		 je	 SHORT $LN74@main
  01437	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG160131
  0143e	48 89 84 24 18
	01 00 00	 mov	 QWORD PTR tv773[rsp], rax
  01446	eb 0f		 jmp	 SHORT $LN75@main
$LN74@main:
  01448	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG160132
  0144f	48 89 84 24 18
	01 00 00	 mov	 QWORD PTR tv773[rsp], rax
$LN75@main:
  01457	b9 01 00 00 00	 mov	 ecx, 1
  0145c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  01462	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG160130
  01469	48 89 4c 24 60	 mov	 QWORD PTR [rsp+96], rcx
  0146e	8b 8c 24 84 00
	00 00		 mov	 ecx, DWORD PTR imglen$[rsp]
  01475	89 4c 24 58	 mov	 DWORD PTR [rsp+88], ecx
  01479	8b 8c 24 84 00
	00 00		 mov	 ecx, DWORD PTR imglen$[rsp]
  01480	89 4c 24 50	 mov	 DWORD PTR [rsp+80], ecx
  01484	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR trkhdroff$[rsp]
  0148c	48 89 4c 24 48	 mov	 QWORD PTR [rsp+72], rcx
  01491	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR trkhdroff$[rsp]
  01499	48 89 4c 24 40	 mov	 QWORD PTR [rsp+64], rcx
  0149e	48 8b 8c 24 18
	01 00 00	 mov	 rcx, QWORD PTR tv773[rsp]
  014a6	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  014ab	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG160133
  014b2	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  014b7	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG160134
  014be	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  014c3	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  014c8	41 b9 03 00 00
	00		 mov	 r9d, 3
  014ce	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG160135
  014d5	ba 8a 03 00 00	 mov	 edx, 906		; 0000038aH
  014da	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG160136
  014e1	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 906  :             trkhdroff, trkhdroff, imglen, imglen, "" );
; 907  : 
; 908  :         /* Verify device contains the requested track/block */
; 909  :         if (!trkhdroff || !imglen)

  014e7	48 83 bc 24 c0
	00 00 00 00	 cmp	 QWORD PTR trkhdroff$[rsp], 0
  014f0	74 0e		 je	 SHORT $LN61@main
  014f2	83 bc 24 84 00
	00 00 00	 cmp	 DWORD PTR imglen$[rsp], 0
  014fa	0f 85 94 00 00
	00		 jne	 $LN60@main
$LN61@main:

; 910  :         {
; 911  :             // "%s %d not found"
; 912  :             FWRMSG( stderr, HHC02619, "S", ckddasd ? "Track" : "Block", trk );

  01500	0f b6 44 24 70	 movzx	 eax, BYTE PTR ckddasd$[rsp]
  01505	85 c0		 test	 eax, eax
  01507	74 11		 je	 SHORT $LN76@main
  01509	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG160139
  01510	48 89 84 24 20
	01 00 00	 mov	 QWORD PTR tv789[rsp], rax
  01518	eb 0f		 jmp	 SHORT $LN77@main
$LN76@main:
  0151a	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG160140
  01521	48 89 84 24 20
	01 00 00	 mov	 QWORD PTR tv789[rsp], rax
$LN77@main:
  01529	b9 02 00 00 00	 mov	 ecx, 2
  0152e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  01534	8b 4c 24 78	 mov	 ecx, DWORD PTR trk$[rsp]
  01538	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  0153c	48 8b 8c 24 20
	01 00 00	 mov	 rcx, QWORD PTR tv789[rsp]
  01544	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  01549	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG160141
  01550	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  01555	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG160142
  0155c	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  01561	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  01566	41 b9 03 00 00
	00		 mov	 r9d, 3
  0156c	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG160143
  01573	ba 90 03 00 00	 mov	 edx, 912		; 00000390H
  01578	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG160144
  0157f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 913  :             clean();

  01585	e8 00 00 00 00	 call	 clean

; 914  :             ErrExit( EXIT_DATA_NOTFOUND );

  0158a	b9 07 00 00 00	 mov	 ecx, 7
  0158f	e8 00 00 00 00	 call	 ErrExit
$LN60@main:

; 915  :         }
; 916  : 
; 917  :         tbuf = makbuf(imglen, ckddasd ? "TRKHDR+DATA" : "BKGHDR+DATA");

  01594	0f b6 44 24 70	 movzx	 eax, BYTE PTR ckddasd$[rsp]
  01599	85 c0		 test	 eax, eax
  0159b	74 11		 je	 SHORT $LN78@main
  0159d	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG160145
  015a4	48 89 84 24 28
	01 00 00	 mov	 QWORD PTR tv804[rsp], rax
  015ac	eb 0f		 jmp	 SHORT $LN79@main
$LN78@main:
  015ae	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG160146
  015b5	48 89 84 24 28
	01 00 00	 mov	 QWORD PTR tv804[rsp], rax
$LN79@main:
  015bd	48 8b 94 24 28
	01 00 00	 mov	 rdx, QWORD PTR tv804[rsp]
  015c5	8b 8c 24 84 00
	00 00		 mov	 ecx, DWORD PTR imglen$[rsp]
  015cc	e8 00 00 00 00	 call	 makbuf
  015d1	48 89 05 00 00
	00 00		 mov	 QWORD PTR tbuf, rax

; 918  :         readpos(fd, tbuf, trkhdroff, imglen);

  015d8	44 8b 8c 24 84
	00 00 00	 mov	 r9d, DWORD PTR imglen$[rsp]
  015e0	4c 8b 84 24 c0
	00 00 00	 mov	 r8, QWORD PTR trkhdroff$[rsp]
  015e8	48 8b 15 00 00
	00 00		 mov	 rdx, QWORD PTR tbuf
  015ef	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR fd
  015f5	e8 00 00 00 00	 call	 readpos

; 919  : 
; 920  :         // "%sHDR %s %d:"
; 921  :         WRMSG( HHC02612, "I", ckddasd ? "TRK"   : "BKG",

  015fa	0f b6 44 24 70	 movzx	 eax, BYTE PTR ckddasd$[rsp]
  015ff	85 c0		 test	 eax, eax
  01601	74 11		 je	 SHORT $LN80@main
  01603	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG160147
  0160a	48 89 84 24 30
	01 00 00	 mov	 QWORD PTR tv814[rsp], rax
  01612	eb 0f		 jmp	 SHORT $LN81@main
$LN80@main:
  01614	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG160148
  0161b	48 89 84 24 30
	01 00 00	 mov	 QWORD PTR tv814[rsp], rax
$LN81@main:
  01623	0f b6 44 24 70	 movzx	 eax, BYTE PTR ckddasd$[rsp]
  01628	85 c0		 test	 eax, eax
  0162a	74 11		 je	 SHORT $LN82@main
  0162c	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG160149
  01633	48 89 84 24 38
	01 00 00	 mov	 QWORD PTR tv818[rsp], rax
  0163b	eb 0f		 jmp	 SHORT $LN83@main
$LN82@main:
  0163d	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG160150
  01644	48 89 84 24 38
	01 00 00	 mov	 QWORD PTR tv818[rsp], rax
$LN83@main:
  0164c	b9 01 00 00 00	 mov	 ecx, 1
  01651	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  01657	8b 4c 24 78	 mov	 ecx, DWORD PTR trk$[rsp]
  0165b	89 4c 24 48	 mov	 DWORD PTR [rsp+72], ecx
  0165f	48 8b 8c 24 30
	01 00 00	 mov	 rcx, QWORD PTR tv814[rsp]
  01667	48 89 4c 24 40	 mov	 QWORD PTR [rsp+64], rcx
  0166c	48 8b 8c 24 38
	01 00 00	 mov	 rcx, QWORD PTR tv818[rsp]
  01674	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  01679	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG160151
  01680	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  01685	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG160152
  0168c	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  01691	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  01696	41 b9 03 00 00
	00		 mov	 r9d, 3
  0169c	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG160153
  016a3	ba 9a 03 00 00	 mov	 edx, 922		; 0000039aH
  016a8	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG160154
  016af	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 922  :                               ckddasd ? "track" : "block", trk );
; 923  :         data_dump( tbuf, CKD_TRKHDR_SIZE);

  016b5	ba 05 00 00 00	 mov	 edx, 5
  016ba	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR tbuf
  016c1	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_data_dump

; 924  :         printf("\n");

  016c7	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG160155
  016ce	e8 00 00 00 00	 call	 printf

; 925  : 
; 926  :         if (cmd_trkdata)

  016d3	0f b6 44 24 74	 movzx	 eax, BYTE PTR cmd_trkdata$[rsp]
  016d8	85 c0		 test	 eax, eax
  016da	74 2a		 je	 SHORT $LN62@main

; 927  :             showtrkorblk( tbuf, imglen, trk, ckddasd, cmd_hexdump );

  016dc	0f b6 84 24 81
	00 00 00	 movzx	 eax, BYTE PTR cmd_hexdump$[rsp]
  016e4	88 44 24 20	 mov	 BYTE PTR [rsp+32], al
  016e8	44 0f b6 4c 24
	70		 movzx	 r9d, BYTE PTR ckddasd$[rsp]
  016ee	44 8b 44 24 78	 mov	 r8d, DWORD PTR trk$[rsp]
  016f3	8b 94 24 84 00
	00 00		 mov	 edx, DWORD PTR imglen$[rsp]
  016fa	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR tbuf
  01701	e8 00 00 00 00	 call	 showtrkorblk
$LN62@main:

; 928  : 
; 929  :         free(L2tab);

  01706	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR L2tab
  0170d	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free

; 930  :         free(tbuf);

  01713	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR tbuf
  0171a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free

; 931  : 
; 932  :         L2tab = NULL;

  01720	48 c7 05 00 00
	00 00 00 00 00
	00		 mov	 QWORD PTR L2tab, 0

; 933  :         tbuf = NULL;

  0172b	48 c7 05 00 00
	00 00 00 00 00
	00		 mov	 QWORD PTR tbuf, 0
$LN52@main:

; 934  :     }
; 935  : 
; 936  :     /* Close file, exit */
; 937  :     clean();

  01736	e8 00 00 00 00	 call	 clean

; 938  :     ErrExit( cckd_diag_rc );

  0173b	8b 8c 24 e4 00
	00 00		 mov	 ecx, DWORD PTR cckd_diag_rc$[rsp]
  01742	e8 00 00 00 00	 call	 ErrExit
$LN63@main:

; 939  :     UNREACHABLE_CODE( return EXIT_ERROR_LOGIC_ERROR );
; 940  : }

  01747	48 8b 8c 24 70
	06 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  0174f	48 33 cc	 xor	 rcx, rsp
  01752	e8 00 00 00 00	 call	 __security_check_cookie
  01757	48 81 c4 88 06
	00 00		 add	 rsp, 1672		; 00000688H
  0175e	c3		 ret	 0
  0175f	90		 npad	 1
$LN85@main:
  01760	00 00 00 00	 DD	 $LN13@main
  01764	00 00 00 00	 DD	 $LN15@main
  01768	00 00 00 00	 DD	 $LN17@main
  0176c	00 00 00 00	 DD	 $LN11@main
  01770	00 00 00 00	 DD	 $LN9@main
  01774	00 00 00 00	 DD	 $LN27@main
  01778	00 00 00 00	 DD	 $LN21@main
  0177c	00 00 00 00	 DD	 $LN19@main
  01780	00 00 00 00	 DD	 $LN23@main
  01784	00 00 00 00	 DD	 $LN7@main
  01788	00 00 00 00	 DD	 $LN25@main
  0178c	00 00 00 00	 DD	 $LN29@main
$LN84@main:
  01790	00		 DB	 0
  01791	01		 DB	 1
  01792	0b		 DB	 11
  01793	0b		 DB	 11
  01794	0b		 DB	 11
  01795	0b		 DB	 11
  01796	0b		 DB	 11
  01797	0b		 DB	 11
  01798	0b		 DB	 11
  01799	0b		 DB	 11
  0179a	0b		 DB	 11
  0179b	0b		 DB	 11
  0179c	0b		 DB	 11
  0179d	0b		 DB	 11
  0179e	0b		 DB	 11
  0179f	0b		 DB	 11
  017a0	0b		 DB	 11
  017a1	0b		 DB	 11
  017a2	0b		 DB	 11
  017a3	0b		 DB	 11
  017a4	0b		 DB	 11
  017a5	0b		 DB	 11
  017a6	0b		 DB	 11
  017a7	0b		 DB	 11
  017a8	0b		 DB	 11
  017a9	0b		 DB	 11
  017aa	0b		 DB	 11
  017ab	0b		 DB	 11
  017ac	0b		 DB	 11
  017ad	0b		 DB	 11
  017ae	0b		 DB	 11
  017af	0b		 DB	 11
  017b0	0b		 DB	 11
  017b1	0b		 DB	 11
  017b2	0b		 DB	 11
  017b3	0b		 DB	 11
  017b4	0b		 DB	 11
  017b5	0b		 DB	 11
  017b6	0b		 DB	 11
  017b7	0b		 DB	 11
  017b8	0b		 DB	 11
  017b9	0b		 DB	 11
  017ba	0b		 DB	 11
  017bb	0b		 DB	 11
  017bc	0b		 DB	 11
  017bd	0b		 DB	 11
  017be	0b		 DB	 11
  017bf	0b		 DB	 11
  017c0	02		 DB	 2
  017c1	0b		 DB	 11
  017c2	03		 DB	 3
  017c3	04		 DB	 4
  017c4	0b		 DB	 11
  017c5	0b		 DB	 11
  017c6	05		 DB	 5
  017c7	0b		 DB	 11
  017c8	0b		 DB	 11
  017c9	0b		 DB	 11
  017ca	0b		 DB	 11
  017cb	0b		 DB	 11
  017cc	0b		 DB	 11
  017cd	0b		 DB	 11
  017ce	06		 DB	 6
  017cf	0b		 DB	 11
  017d0	0b		 DB	 11
  017d1	07		 DB	 7
  017d2	0b		 DB	 11
  017d3	08		 DB	 8
  017d4	0b		 DB	 11
  017d5	09		 DB	 9
  017d6	0b		 DB	 11
  017d7	0a		 DB	 10
main	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\cckddiag64.c
_TEXT	SEGMENT
v$ = 80
p$ = 88
tv75 = 96
s$ = 128
offtify	PROC

; 466  : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 78	 sub	 rsp, 120		; 00000078H

; 467  :     static const char  xd[]  = { "0123456789abcdefABCDEF" };
; 468  :     static const char  xv[]  = { 0, 1, 2, 3, 4, 5, 6, 7, 8, 9,
; 469  :                                 10, 11, 12, 13, 14, 15,
; 470  :                                 10, 11, 12, 13, 14, 15 };
; 471  :     U64     v;
; 472  :     char*   p;
; 473  : 
; 474  :     p = s;

  00009	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR s$[rsp]
  00011	48 89 44 24 58	 mov	 QWORD PTR p$[rsp], rax

; 475  :     if ( (*s == '0') && (*(s+1) == 'x') )

  00016	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR s$[rsp]
  0001e	0f be 00	 movsx	 eax, BYTE PTR [rax]
  00021	83 f8 30	 cmp	 eax, 48			; 00000030H
  00024	0f 85 2a 01 00
	00		 jne	 $LN5@offtify
  0002a	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR s$[rsp]
  00032	0f be 40 01	 movsx	 eax, BYTE PTR [rax+1]
  00036	83 f8 78	 cmp	 eax, 120		; 00000078H
  00039	0f 85 15 01 00
	00		 jne	 $LN5@offtify

; 476  :     {
; 477  :         s = s + 2;

  0003f	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR s$[rsp]
  00047	48 83 c0 02	 add	 rax, 2
  0004b	48 89 84 24 80
	00 00 00	 mov	 QWORD PTR s$[rsp], rax

; 478  : 
; 479  :         for (v = 0; isxdigit(*s); ++s)

  00053	48 c7 44 24 50
	00 00 00 00	 mov	 QWORD PTR v$[rsp], 0
  0005c	eb 13		 jmp	 SHORT $LN4@offtify
$LN2@offtify:
  0005e	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR s$[rsp]
  00066	48 ff c0	 inc	 rax
  00069	48 89 84 24 80
	00 00 00	 mov	 QWORD PTR s$[rsp], rax
$LN4@offtify:
  00071	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR s$[rsp]
  00079	0f be 00	 movsx	 eax, BYTE PTR [rax]
  0007c	8b c8		 mov	 ecx, eax
  0007e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_isxdigit
  00084	85 c0		 test	 eax, eax
  00086	74 4f		 je	 SHORT $LN3@offtify

; 480  :             v = (v << 4) + xv[ strchr( xd, *s ) - xd ];

  00088	48 8b 44 24 50	 mov	 rax, QWORD PTR v$[rsp]
  0008d	48 c1 e0 04	 shl	 rax, 4
  00091	48 89 44 24 60	 mov	 QWORD PTR tv75[rsp], rax
  00096	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  0009e	0f be 09	 movsx	 ecx, BYTE PTR [rcx]
  000a1	8b d1		 mov	 edx, ecx
  000a3	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:?xd@?1??offtify@@9@9
  000aa	e8 00 00 00 00	 call	 strchr
  000af	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:?xd@?1??offtify@@9@9
  000b6	48 2b c1	 sub	 rax, rcx
  000b9	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:?xv@?1??offtify@@9@9
  000c0	48 0f be 04 01	 movsx	 rax, BYTE PTR [rcx+rax]
  000c5	48 8b 4c 24 60	 mov	 rcx, QWORD PTR tv75[rsp]
  000ca	48 03 c8	 add	 rcx, rax
  000cd	48 8b c1	 mov	 rax, rcx
  000d0	48 89 44 24 50	 mov	 QWORD PTR v$[rsp], rax
  000d5	eb 87		 jmp	 SHORT $LN2@offtify
$LN3@offtify:

; 481  : 
; 482  :         if (debug)

  000d7	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR debug, 0
  000de	74 65		 je	 SHORT $LN7@offtify

; 483  :         {
; 484  :             // "OFFTIFY hex string '%s' = 0x%16.16"PRIX64", dec %"PRId64"."
; 485  :             WRMSG( HHC90405, "D", p, v, v );

  000e0	b9 01 00 00 00	 mov	 ecx, 1
  000e5	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  000eb	48 8b 4c 24 50	 mov	 rcx, QWORD PTR v$[rsp]
  000f0	48 89 4c 24 48	 mov	 QWORD PTR [rsp+72], rcx
  000f5	48 8b 4c 24 50	 mov	 rcx, QWORD PTR v$[rsp]
  000fa	48 89 4c 24 40	 mov	 QWORD PTR [rsp+64], rcx
  000ff	48 8b 4c 24 58	 mov	 rcx, QWORD PTR p$[rsp]
  00104	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  00109	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159864
  00110	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  00115	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159865
  0011c	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00121	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00126	41 b9 03 00 00
	00		 mov	 r9d, 3
  0012c	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG159866
  00133	ba e5 01 00 00	 mov	 edx, 485		; 000001e5H
  00138	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159867
  0013f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg
$LN7@offtify:

; 486  :         }
; 487  :         return v;

  00145	48 8b 44 24 50	 mov	 rax, QWORD PTR v$[rsp]
  0014a	e9 97 00 00 00	 jmp	 $LN1@offtify

; 488  :     }

  0014f	e9 92 00 00 00	 jmp	 $LN6@offtify
$LN5@offtify:

; 489  :     else /* decimal input */
; 490  :     {
; 491  :         v = (U64) atoll(s);

  00154	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  0015c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__atoi64
  00162	48 89 44 24 50	 mov	 QWORD PTR v$[rsp], rax

; 492  : 
; 493  :         if (debug)

  00167	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR debug, 0
  0016e	74 71		 je	 SHORT $LN8@offtify

; 494  :         {
; 495  :             // "OFFTIFY dec string '%s' = 0x%16.16"PRIX64", dec %"PRId64"."
; 496  :             printf("\n");

  00170	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159869
  00177	e8 00 00 00 00	 call	 printf

; 497  :             WRMSG( HHC90406, "D", p, v, v );

  0017c	b9 01 00 00 00	 mov	 ecx, 1
  00181	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  00187	48 8b 4c 24 50	 mov	 rcx, QWORD PTR v$[rsp]
  0018c	48 89 4c 24 48	 mov	 QWORD PTR [rsp+72], rcx
  00191	48 8b 4c 24 50	 mov	 rcx, QWORD PTR v$[rsp]
  00196	48 89 4c 24 40	 mov	 QWORD PTR [rsp+64], rcx
  0019b	48 8b 4c 24 58	 mov	 rcx, QWORD PTR p$[rsp]
  001a0	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  001a5	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159870
  001ac	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  001b1	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159871
  001b8	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  001bd	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  001c2	41 b9 03 00 00
	00		 mov	 r9d, 3
  001c8	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG159872
  001cf	ba f1 01 00 00	 mov	 edx, 497		; 000001f1H
  001d4	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159873
  001db	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg
$LN8@offtify:

; 498  :         }
; 499  :         return v;

  001e1	48 8b 44 24 50	 mov	 rax, QWORD PTR v$[rsp]
$LN6@offtify:
$LN1@offtify:

; 500  :     }
; 501  : }

  001e6	48 83 c4 78	 add	 rsp, 120		; 00000078H
  001ea	c3		 ret	 0
offtify	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\cckddiag64.c
_TEXT	SEGMENT
bufp$ = 64
tv75 = 72
rh$ = 80
len$ = 88
blknum$1 = 92
grpblk$2 = 96
blkghdr$3 = 104
msg$ = 112
buf2$ = 208
__$ArrayPad$ = 65744
buf$ = 65776
imglen$ = 65784
trk$ = 65792
ckddasd$ = 65800
hexdump$ = 65808
showtrkorblk PROC

; 389  : {

  00000	44 88 4c 24 20	 mov	 BYTE PTR [rsp+32], r9b
  00005	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  0000a	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  0000e	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00013	b8 e8 00 01 00	 mov	 eax, 65768		; 000100e8H
  00018	e8 00 00 00 00	 call	 __chkstk
  0001d	48 2b e0	 sub	 rsp, rax
  00020	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00027	48 33 c4	 xor	 rax, rsp
  0002a	48 89 84 24 d0
	00 01 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 390  :     BYTE             buf2[64*1024];     /* max uncompressed buffer   */
; 391  :     char             msg[81];           /* error message buffer      */
; 392  :     CKD_RECHDR*      rh;                /* CCKD COUNT field          */
; 393  :     BYTE*            bufp;              /* Decompressed data pointer */
; 394  :     int              len;               /* Decompressed data length  */
; 395  : 
; 396  :     if (debug)

  00032	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR debug, 0
  00039	74 2f		 je	 SHORT $LN4@showtrkorb

; 397  :     {
; 398  :         snap( COMPRESSED, buf, imglen, ckddasd );

  0003b	44 0f b6 8c 24
	08 01 01 00	 movzx	 r9d, BYTE PTR ckddasd$[rsp]
  00044	44 8b 84 24 f8
	00 01 00	 mov	 r8d, DWORD PTR imglen$[rsp]
  0004c	48 8b 94 24 f0
	00 01 00	 mov	 rdx, QWORD PTR buf$[rsp]
  00054	b9 01 00 00 00	 mov	 ecx, 1
  00059	e8 00 00 00 00	 call	 snap

; 399  :         printf("\n");

  0005e	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159836
  00065	e8 00 00 00 00	 call	 printf
$LN4@showtrkorb:

; 400  :     }
; 401  : 
; 402  :     /* Expand (decompress) the CKD track or FBA block group */
; 403  :     len = decomptrk

  0006a	0f b6 84 24 08
	01 01 00	 movzx	 eax, BYTE PTR ckddasd$[rsp]
  00072	85 c0		 test	 eax, eax
  00074	74 0a		 je	 SHORT $LN10@showtrkorb
  00076	c7 44 24 48 01
	00 00 00	 mov	 DWORD PTR tv75[rsp], 1
  0007e	eb 08		 jmp	 SHORT $LN11@showtrkorb
$LN10@showtrkorb:
  00080	c7 44 24 48 ff
	ff ff ff	 mov	 DWORD PTR tv75[rsp], -1
$LN11@showtrkorb:
  00088	48 8d 44 24 70	 lea	 rax, QWORD PTR msg$[rsp]
  0008d	48 89 44 24 30	 mov	 QWORD PTR [rsp+48], rax
  00092	8b 84 24 00 01
	01 00		 mov	 eax, DWORD PTR trk$[rsp]
  00099	89 44 24 28	 mov	 DWORD PTR [rsp+40], eax
  0009d	8b 44 24 48	 mov	 eax, DWORD PTR tv75[rsp]
  000a1	89 44 24 20	 mov	 DWORD PTR [rsp+32], eax
  000a5	41 b9 00 00 01
	00		 mov	 r9d, 65536		; 00010000H
  000ab	4c 8d 84 24 d0
	00 00 00	 lea	 r8, QWORD PTR buf2$[rsp]
  000b3	8b 94 24 f8 00
	01 00		 mov	 edx, DWORD PTR imglen$[rsp]
  000ba	48 8b 8c 24 f0
	00 01 00	 mov	 rcx, QWORD PTR buf$[rsp]
  000c2	e8 00 00 00 00	 call	 decomptrk
  000c7	89 44 24 58	 mov	 DWORD PTR len$[rsp], eax

; 404  :     (
; 405  :         (BYTE *)buf,        /* input buffer address            */
; 406  :         imglen,             /* input buffer length             */
; 407  :         buf2,               /* output buffer address           */
; 408  :         sizeof(buf2),       /* output buffer length            */
; 409  :         ckddasd ? +1 : -1,  /* >=0 means CKD, else FBA         */
; 410  :         trk,                /* relative track or block number  */
; 411  :         msg                 /* addr of message buffer          */
; 412  :     );
; 413  : 
; 414  :     if (debug)

  000cb	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR debug, 0
  000d2	74 29		 je	 SHORT $LN5@showtrkorb

; 415  :     {
; 416  :         snap( EXPANDED, buf2, len, ckddasd );

  000d4	44 0f b6 8c 24
	08 01 01 00	 movzx	 r9d, BYTE PTR ckddasd$[rsp]
  000dd	44 8b 44 24 58	 mov	 r8d, DWORD PTR len$[rsp]
  000e2	48 8d 94 24 d0
	00 00 00	 lea	 rdx, QWORD PTR buf2$[rsp]
  000ea	33 c9		 xor	 ecx, ecx
  000ec	e8 00 00 00 00	 call	 snap

; 417  :         printf("\n");

  000f1	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159838
  000f8	e8 00 00 00 00	 call	 printf
$LN5@showtrkorb:

; 418  :     }
; 419  : 
; 420  :     bufp = &buf2[ CKD_TRKHDR_SIZE];

  000fd	b8 01 00 00 00	 mov	 eax, 1
  00102	48 6b c0 05	 imul	 rax, rax, 5
  00106	48 8d 84 04 d0
	00 00 00	 lea	 rax, QWORD PTR buf2$[rsp+rax]
  0010e	48 89 44 24 40	 mov	 QWORD PTR bufp$[rsp], rax

; 421  : 
; 422  :     if (ckddasd)

  00113	0f b6 84 24 08
	01 01 00	 movzx	 eax, BYTE PTR ckddasd$[rsp]
  0011b	85 c0		 test	 eax, eax
  0011d	0f 84 00 01 00
	00		 je	 $LN6@showtrkorb
$LN2@showtrkorb:

; 423  :     {
; 424  :         while (bufp < &buf2[ sizeof( buf2 )])

  00123	b8 01 00 00 00	 mov	 eax, 1
  00128	48 69 c0 00 00
	01 00		 imul	 rax, rax, 65536		; 00010000H
  0012f	48 8d 84 04 d0
	00 00 00	 lea	 rax, QWORD PTR buf2$[rsp+rax]
  00137	48 39 44 24 40	 cmp	 QWORD PTR bufp$[rsp], rax
  0013c	0f 83 df 00 00
	00		 jae	 $LN3@showtrkorb

; 425  :         {
; 426  :             rh = (CKD_RECHDR*) bufp;

  00142	48 8b 44 24 40	 mov	 rax, QWORD PTR bufp$[rsp]
  00147	48 89 44 24 50	 mov	 QWORD PTR rh$[rsp], rax

; 427  : 
; 428  :             if (memcmp( (BYTE*) rh, &CKD_ENDTRK, CKD_ENDTRK_SIZE ) == 0)

  0014c	41 b8 08 00 00
	00		 mov	 r8d, 8
  00152	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:CKD_ENDTRK
  00159	48 8b 4c 24 50	 mov	 rcx, QWORD PTR rh$[rsp]
  0015e	e8 00 00 00 00	 call	 memcmp
  00163	85 c0		 test	 eax, eax
  00165	75 55		 jne	 SHORT $LN8@showtrkorb

; 429  :             {
; 430  :                 // "%s"
; 431  :                 WRMSG( HHC02601, "I", "End of track" );

  00167	b9 01 00 00 00	 mov	 ecx, 1
  0016c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  00172	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159842
  00179	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  0017e	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159843
  00185	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  0018a	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159844
  00191	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00196	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  0019b	41 b9 03 00 00
	00		 mov	 r9d, 3
  001a1	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG159845
  001a8	ba af 01 00 00	 mov	 edx, 431		; 000001afH
  001ad	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159846
  001b4	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 432  :                 break;

  001ba	eb 65		 jmp	 SHORT $LN3@showtrkorb
$LN8@showtrkorb:

; 433  :             }
; 434  : 
; 435  :             bufp = show_ckd_count ( rh, trk);

  001bc	8b 94 24 00 01
	01 00		 mov	 edx, DWORD PTR trk$[rsp]
  001c3	48 8b 4c 24 50	 mov	 rcx, QWORD PTR rh$[rsp]
  001c8	e8 00 00 00 00	 call	 show_ckd_count
  001cd	48 89 44 24 40	 mov	 QWORD PTR bufp$[rsp], rax

; 436  :             bufp = show_ckd_key   ( rh, bufp, trk, hexdump );

  001d2	44 0f b6 8c 24
	10 01 01 00	 movzx	 r9d, BYTE PTR hexdump$[rsp]
  001db	44 8b 84 24 00
	01 01 00	 mov	 r8d, DWORD PTR trk$[rsp]
  001e3	48 8b 54 24 40	 mov	 rdx, QWORD PTR bufp$[rsp]
  001e8	48 8b 4c 24 50	 mov	 rcx, QWORD PTR rh$[rsp]
  001ed	e8 00 00 00 00	 call	 show_ckd_key
  001f2	48 89 44 24 40	 mov	 QWORD PTR bufp$[rsp], rax

; 437  :             bufp = show_ckd_data  ( rh, bufp, trk, hexdump );

  001f7	44 0f b6 8c 24
	10 01 01 00	 movzx	 r9d, BYTE PTR hexdump$[rsp]
  00200	44 8b 84 24 00
	01 01 00	 mov	 r8d, DWORD PTR trk$[rsp]
  00208	48 8b 54 24 40	 mov	 rdx, QWORD PTR bufp$[rsp]
  0020d	48 8b 4c 24 50	 mov	 rcx, QWORD PTR rh$[rsp]
  00212	e8 00 00 00 00	 call	 show_ckd_data
  00217	48 89 44 24 40	 mov	 QWORD PTR bufp$[rsp], rax

; 438  :         }

  0021c	e9 02 ff ff ff	 jmp	 $LN2@showtrkorb
$LN3@showtrkorb:

; 439  :     }

  00221	eb 6f		 jmp	 SHORT $LN7@showtrkorb
$LN6@showtrkorb:

; 440  :     else // FBA
; 441  :     {
; 442  :         /* Extract block number of first block in block group */
; 443  :         FBA_BKGHDR* blkghdr = (FBA_BKGHDR*) buf;

  00223	48 8b 84 24 f0
	00 01 00	 mov	 rax, QWORD PTR buf$[rsp]
  0022b	48 89 44 24 68	 mov	 QWORD PTR blkghdr$3[rsp], rax

; 444  :         U32 blknum = fetch_fw( blkghdr->blknum );

  00230	48 8b 44 24 68	 mov	 rax, QWORD PTR blkghdr$3[rsp]
  00235	48 ff c0	 inc	 rax
  00238	48 8b c8	 mov	 rcx, rax
  0023b	e8 00 00 00 00	 call	 fetch_fw_noswap
  00240	8b c8		 mov	 ecx, eax
  00242	e8 00 00 00 00	 call	 _byteswap_ulong
  00247	89 44 24 5c	 mov	 DWORD PTR blknum$1[rsp], eax

; 445  : 
; 446  :         /* Calculate relative block number within block group */
; 447  :         U32 grpblk = (trk - blknum);

  0024b	8b 44 24 5c	 mov	 eax, DWORD PTR blknum$1[rsp]
  0024f	8b 8c 24 00 01
	01 00		 mov	 ecx, DWORD PTR trk$[rsp]
  00256	2b c8		 sub	 ecx, eax
  00258	8b c1		 mov	 eax, ecx
  0025a	89 44 24 60	 mov	 DWORD PTR grpblk$2[rsp], eax

; 448  : 
; 449  :         /* Index to desired block within expanded block group */
; 450  :         bufp += grpblk * 512;

  0025e	69 44 24 60 00
	02 00 00	 imul	 eax, DWORD PTR grpblk$2[rsp], 512 ; 00000200H
  00266	8b c0		 mov	 eax, eax
  00268	48 8b 4c 24 40	 mov	 rcx, QWORD PTR bufp$[rsp]
  0026d	48 03 c8	 add	 rcx, rax
  00270	48 8b c1	 mov	 rax, rcx
  00273	48 89 44 24 40	 mov	 QWORD PTR bufp$[rsp], rax

; 451  : 
; 452  :         /* Show desired block data */
; 453  :         show_fba_block( bufp, trk, hexdump );

  00278	44 0f b6 84 24
	10 01 01 00	 movzx	 r8d, BYTE PTR hexdump$[rsp]
  00281	8b 94 24 00 01
	01 00		 mov	 edx, DWORD PTR trk$[rsp]
  00288	48 8b 4c 24 40	 mov	 rcx, QWORD PTR bufp$[rsp]
  0028d	e8 00 00 00 00	 call	 show_fba_block
$LN7@showtrkorb:

; 454  :     }
; 455  : }

  00292	48 8b 8c 24 d0
	00 01 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  0029a	48 33 cc	 xor	 rcx, rsp
  0029d	e8 00 00 00 00	 call	 __security_check_cookie
  002a2	48 81 c4 e8 00
	01 00		 add	 rsp, 65768		; 000100e8H
  002a9	c3		 ret	 0
showtrkorblk ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\cckddiag64.c
_TEXT	SEGMENT
tv67 = 80
tv71 = 88
tv86 = 96
tv90 = 104
comp$ = 128
data$ = 136
len$ = 144
ckddasd$ = 152
snap	PROC

; 350  : {

  00000	44 88 4c 24 20	 mov	 BYTE PTR [rsp+32], r9b
  00005	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	89 4c 24 08	 mov	 DWORD PTR [rsp+8], ecx
  00013	48 83 ec 78	 sub	 rsp, 120		; 00000078H

; 351  :     if (comp)

  00017	83 bc 24 80 00
	00 00 00	 cmp	 DWORD PTR comp$[rsp], 0
  0001f	0f 84 c1 00 00
	00		 je	 $LN2@snap

; 352  :     {
; 353  :         // "SHOW%s Compressed %s header and data:"
; 354  :         WRMSG( HHC90403, "D",

  00025	0f b6 84 24 98
	00 00 00	 movzx	 eax, BYTE PTR ckddasd$[rsp]
  0002d	85 c0		 test	 eax, eax
  0002f	74 0e		 je	 SHORT $LN6@snap
  00031	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG159783
  00038	48 89 44 24 50	 mov	 QWORD PTR tv67[rsp], rax
  0003d	eb 0c		 jmp	 SHORT $LN7@snap
$LN6@snap:
  0003f	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG159784
  00046	48 89 44 24 50	 mov	 QWORD PTR tv67[rsp], rax
$LN7@snap:
  0004b	0f b6 84 24 98
	00 00 00	 movzx	 eax, BYTE PTR ckddasd$[rsp]
  00053	85 c0		 test	 eax, eax
  00055	74 0e		 je	 SHORT $LN8@snap
  00057	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG159785
  0005e	48 89 44 24 58	 mov	 QWORD PTR tv71[rsp], rax
  00063	eb 0c		 jmp	 SHORT $LN9@snap
$LN8@snap:
  00065	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG159786
  0006c	48 89 44 24 58	 mov	 QWORD PTR tv71[rsp], rax
$LN9@snap:
  00071	b9 01 00 00 00	 mov	 ecx, 1
  00076	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  0007c	48 8b 4c 24 50	 mov	 rcx, QWORD PTR tv67[rsp]
  00081	48 89 4c 24 40	 mov	 QWORD PTR [rsp+64], rcx
  00086	48 8b 4c 24 58	 mov	 rcx, QWORD PTR tv71[rsp]
  0008b	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  00090	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159787
  00097	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  0009c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159788
  000a3	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  000a8	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  000ad	41 b9 03 00 00
	00		 mov	 r9d, 3
  000b3	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG159789
  000ba	ba 64 01 00 00	 mov	 edx, 356		; 00000164H
  000bf	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159790
  000c6	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 355  :             ckddasd ? "TRK"   : "BKG",
; 356  :             ckddasd ? "track" : "block group" );
; 357  :         data_dump( data, len );

  000cc	8b 94 24 90 00
	00 00		 mov	 edx, DWORD PTR len$[rsp]
  000d3	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR data$[rsp]
  000db	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_data_dump

; 358  :     }

  000e1	e9 bc 00 00 00	 jmp	 $LN3@snap
$LN2@snap:

; 359  :     else // EXPANDED
; 360  :     {
; 361  :         // "SHOW%s Decompressed %s header and data:"
; 362  :         WRMSG( HHC90404, "D",

  000e6	0f b6 84 24 98
	00 00 00	 movzx	 eax, BYTE PTR ckddasd$[rsp]
  000ee	85 c0		 test	 eax, eax
  000f0	74 0e		 je	 SHORT $LN10@snap
  000f2	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG159791
  000f9	48 89 44 24 60	 mov	 QWORD PTR tv86[rsp], rax
  000fe	eb 0c		 jmp	 SHORT $LN11@snap
$LN10@snap:
  00100	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG159792
  00107	48 89 44 24 60	 mov	 QWORD PTR tv86[rsp], rax
$LN11@snap:
  0010c	0f b6 84 24 98
	00 00 00	 movzx	 eax, BYTE PTR ckddasd$[rsp]
  00114	85 c0		 test	 eax, eax
  00116	74 0e		 je	 SHORT $LN12@snap
  00118	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG159793
  0011f	48 89 44 24 68	 mov	 QWORD PTR tv90[rsp], rax
  00124	eb 0c		 jmp	 SHORT $LN13@snap
$LN12@snap:
  00126	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG159794
  0012d	48 89 44 24 68	 mov	 QWORD PTR tv90[rsp], rax
$LN13@snap:
  00132	b9 01 00 00 00	 mov	 ecx, 1
  00137	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  0013d	48 8b 4c 24 60	 mov	 rcx, QWORD PTR tv86[rsp]
  00142	48 89 4c 24 40	 mov	 QWORD PTR [rsp+64], rcx
  00147	48 8b 4c 24 68	 mov	 rcx, QWORD PTR tv90[rsp]
  0014c	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  00151	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159795
  00158	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  0015d	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159796
  00164	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00169	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  0016e	41 b9 03 00 00
	00		 mov	 r9d, 3
  00174	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG159797
  0017b	ba 6c 01 00 00	 mov	 edx, 364		; 0000016cH
  00180	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159798
  00187	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 363  :             ckddasd ? "TRK"   : "BKG",
; 364  :             ckddasd ? "track" : "block group" );
; 365  :         data_dump( data, len );

  0018d	8b 94 24 90 00
	00 00		 mov	 edx, DWORD PTR len$[rsp]
  00194	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR data$[rsp]
  0019c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_data_dump
$LN3@snap:

; 366  :     }
; 367  : 
; 368  :     if (pausesnap)

  001a2	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR pausesnap, 0
  001a9	74 70		 je	 SHORT $LN4@snap

; 369  :     {
; 370  :         // "%s"
; 371  :         printf("\n");

  001ab	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159800
  001b2	e8 00 00 00 00	 call	 printf

; 372  :         WRMSG( HHC02601, "A", "Press enter to continue" );

  001b7	b9 01 00 00 00	 mov	 ecx, 1
  001bc	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  001c2	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159801
  001c9	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  001ce	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159802
  001d5	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  001da	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159803
  001e1	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  001e6	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  001eb	41 b9 03 00 00
	00		 mov	 r9d, 3
  001f1	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG159804
  001f8	ba 74 01 00 00	 mov	 edx, 372		; 00000174H
  001fd	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159805
  00204	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 373  :         getc( stdin );

  0020a	33 c9		 xor	 ecx, ecx
  0020c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  00212	48 8b c8	 mov	 rcx, rax
  00215	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_getc
$LN4@snap:

; 374  :     }
; 375  : }

  0021b	48 83 c4 78	 add	 rsp, 120		; 00000078H
  0021f	c3		 ret	 0
snap	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\cckddiag64.c
_TEXT	SEGMENT
buf$ = 80
blk$ = 88
hexdump$ = 96
show_fba_block PROC

; 334  : {

  00000	44 88 44 24 18	 mov	 BYTE PTR [rsp+24], r8b
  00005	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00009	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000e	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 335  :     if (hexdump)

  00012	0f b6 44 24 60	 movzx	 eax, BYTE PTR hexdump$[rsp]
  00017	85 c0		 test	 eax, eax
  00019	74 6b		 je	 SHORT $LN2@show_fba_b

; 336  :     {
; 337  :         // "Block %d:"
; 338  :         WRMSG( HHC02616, "I", blk );

  0001b	b9 01 00 00 00	 mov	 ecx, 1
  00020	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  00026	8b 4c 24 58	 mov	 ecx, DWORD PTR blk$[rsp]
  0002a	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  0002e	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159766
  00035	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  0003a	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159767
  00041	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00046	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  0004b	41 b9 03 00 00
	00		 mov	 r9d, 3
  00051	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG159768
  00058	ba 52 01 00 00	 mov	 edx, 338		; 00000152H
  0005d	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159769
  00064	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 339  :         data_dump( buf, 512 );

  0006a	ba 00 02 00 00	 mov	 edx, 512		; 00000200H
  0006f	48 8b 4c 24 50	 mov	 rcx, QWORD PTR buf$[rsp]
  00074	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_data_dump

; 340  :         printf("\n");

  0007a	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159770
  00081	e8 00 00 00 00	 call	 printf
$LN2@show_fba_b:

; 341  :     }
; 342  : }

  00086	48 83 c4 48	 add	 rsp, 72			; 00000048H
  0008a	c3		 ret	 0
show_fba_block ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\cckddiag64.c
_TEXT	SEGMENT
dl$ = 96
tv81 = 100
tv84 = 104
rh$ = 128
buf$ = 136
trk$ = 144
hexdump$ = 152
show_ckd_data PROC

; 314  : {

  00000	44 88 4c 24 20	 mov	 BYTE PTR [rsp+32], r9b
  00005	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	48 83 ec 78	 sub	 rsp, 120		; 00000078H

; 315  :     int dl;
; 316  : 
; 317  :     dl = (rh->dlen[0] << 8) | (rh->dlen[1]);

  00018	b8 01 00 00 00	 mov	 eax, 1
  0001d	48 6b c0 00	 imul	 rax, rax, 0
  00021	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR rh$[rsp]
  00029	0f b6 44 01 06	 movzx	 eax, BYTE PTR [rcx+rax+6]
  0002e	c1 e0 08	 shl	 eax, 8
  00031	b9 01 00 00 00	 mov	 ecx, 1
  00036	48 6b c9 01	 imul	 rcx, rcx, 1
  0003a	48 8b 94 24 80
	00 00 00	 mov	 rdx, QWORD PTR rh$[rsp]
  00042	0f b6 4c 0a 06	 movzx	 ecx, BYTE PTR [rdx+rcx+6]
  00047	0b c1		 or	 eax, ecx
  00049	89 44 24 60	 mov	 DWORD PTR dl$[rsp], eax

; 318  : 
; 319  :     if (hexdump && dl)

  0004d	0f b6 84 24 98
	00 00 00	 movzx	 eax, BYTE PTR hexdump$[rsp]
  00055	85 c0		 test	 eax, eax
  00057	0f 84 cb 00 00
	00		 je	 $LN2@show_ckd_d
  0005d	83 7c 24 60 00	 cmp	 DWORD PTR dl$[rsp], 0
  00062	0f 84 c0 00 00
	00		 je	 $LN2@show_ckd_d

; 320  :     {
; 321  :         // "Track %d rec[%02X/%d] %s[%d]:"
; 322  :         printf("\n");

  00068	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159750
  0006f	e8 00 00 00 00	 call	 printf

; 323  :         WRMSG( HHC02606, "I", trk, rh->rec, rh->rec, "dl", dl );

  00074	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR rh$[rsp]
  0007c	0f b6 40 04	 movzx	 eax, BYTE PTR [rax+4]
  00080	89 44 24 64	 mov	 DWORD PTR tv81[rsp], eax
  00084	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR rh$[rsp]
  0008c	0f b6 49 04	 movzx	 ecx, BYTE PTR [rcx+4]
  00090	89 4c 24 68	 mov	 DWORD PTR tv84[rsp], ecx
  00094	b9 01 00 00 00	 mov	 ecx, 1
  00099	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  0009f	8b 4c 24 60	 mov	 ecx, DWORD PTR dl$[rsp]
  000a3	89 4c 24 58	 mov	 DWORD PTR [rsp+88], ecx
  000a7	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159751
  000ae	48 89 4c 24 50	 mov	 QWORD PTR [rsp+80], rcx
  000b3	8b 4c 24 64	 mov	 ecx, DWORD PTR tv81[rsp]
  000b7	89 4c 24 48	 mov	 DWORD PTR [rsp+72], ecx
  000bb	8b 4c 24 68	 mov	 ecx, DWORD PTR tv84[rsp]
  000bf	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  000c3	8b 8c 24 90 00
	00 00		 mov	 ecx, DWORD PTR trk$[rsp]
  000ca	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  000ce	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159752
  000d5	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  000da	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159753
  000e1	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  000e6	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  000eb	41 b9 03 00 00
	00		 mov	 r9d, 3
  000f1	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG159754
  000f8	ba 43 01 00 00	 mov	 edx, 323		; 00000143H
  000fd	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159755
  00104	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 324  :         data_dump( buf, dl );

  0010a	8b 54 24 60	 mov	 edx, DWORD PTR dl$[rsp]
  0010e	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR buf$[rsp]
  00116	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_data_dump

; 325  :         printf("\n");

  0011c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159756
  00123	e8 00 00 00 00	 call	 printf
$LN2@show_ckd_d:

; 326  :     }
; 327  :     return buf + dl;   /* skip past DATA field */

  00128	48 63 44 24 60	 movsxd	 rax, DWORD PTR dl$[rsp]
  0012d	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR buf$[rsp]
  00135	48 03 c8	 add	 rcx, rax
  00138	48 8b c1	 mov	 rax, rcx

; 328  : }

  0013b	48 83 c4 78	 add	 rsp, 120		; 00000078H
  0013f	c3		 ret	 0
show_ckd_data ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\cckddiag64.c
_TEXT	SEGMENT
tv71 = 96
tv75 = 100
tv78 = 104
rh$ = 128
buf$ = 136
trk$ = 144
hexdump$ = 152
show_ckd_key PROC

; 298  : {

  00000	44 88 4c 24 20	 mov	 BYTE PTR [rsp+32], r9b
  00005	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	48 83 ec 78	 sub	 rsp, 120		; 00000078H

; 299  :     if (hexdump && rh->klen)

  00018	0f b6 84 24 98
	00 00 00	 movzx	 eax, BYTE PTR hexdump$[rsp]
  00020	85 c0		 test	 eax, eax
  00022	0f 84 ee 00 00
	00		 je	 $LN2@show_ckd_k
  00028	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR rh$[rsp]
  00030	0f b6 40 05	 movzx	 eax, BYTE PTR [rax+5]
  00034	85 c0		 test	 eax, eax
  00036	0f 84 da 00 00
	00		 je	 $LN2@show_ckd_k

; 300  :     {
; 301  :         // "Track %d rec[%02X/%d] %s[%d]:"
; 302  :         printf("\n");

  0003c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159731
  00043	e8 00 00 00 00	 call	 printf

; 303  :         WRMSG( HHC02606, "I", trk, rh->rec, rh->rec, "kl", rh->klen );

  00048	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR rh$[rsp]
  00050	0f b6 40 05	 movzx	 eax, BYTE PTR [rax+5]
  00054	89 44 24 60	 mov	 DWORD PTR tv71[rsp], eax
  00058	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR rh$[rsp]
  00060	0f b6 49 04	 movzx	 ecx, BYTE PTR [rcx+4]
  00064	89 4c 24 64	 mov	 DWORD PTR tv75[rsp], ecx
  00068	48 8b 94 24 80
	00 00 00	 mov	 rdx, QWORD PTR rh$[rsp]
  00070	0f b6 52 04	 movzx	 edx, BYTE PTR [rdx+4]
  00074	89 54 24 68	 mov	 DWORD PTR tv78[rsp], edx
  00078	b9 01 00 00 00	 mov	 ecx, 1
  0007d	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  00083	8b 4c 24 60	 mov	 ecx, DWORD PTR tv71[rsp]
  00087	89 4c 24 58	 mov	 DWORD PTR [rsp+88], ecx
  0008b	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159732
  00092	48 89 4c 24 50	 mov	 QWORD PTR [rsp+80], rcx
  00097	8b 4c 24 64	 mov	 ecx, DWORD PTR tv75[rsp]
  0009b	89 4c 24 48	 mov	 DWORD PTR [rsp+72], ecx
  0009f	8b 4c 24 68	 mov	 ecx, DWORD PTR tv78[rsp]
  000a3	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  000a7	8b 8c 24 90 00
	00 00		 mov	 ecx, DWORD PTR trk$[rsp]
  000ae	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  000b2	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159733
  000b9	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  000be	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159734
  000c5	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  000ca	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  000cf	41 b9 03 00 00
	00		 mov	 r9d, 3
  000d5	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG159735
  000dc	ba 2f 01 00 00	 mov	 edx, 303		; 0000012fH
  000e1	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159736
  000e8	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 304  :         data_dump( buf, rh->klen );

  000ee	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR rh$[rsp]
  000f6	0f b6 40 05	 movzx	 eax, BYTE PTR [rax+5]
  000fa	8b d0		 mov	 edx, eax
  000fc	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR buf$[rsp]
  00104	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_data_dump

; 305  :         printf("\n");

  0010a	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159737
  00111	e8 00 00 00 00	 call	 printf
$LN2@show_ckd_k:

; 306  :     }
; 307  :     return (BYTE *)buf + rh->klen;   /* skip past KEY field */

  00116	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR rh$[rsp]
  0011e	0f b6 40 05	 movzx	 eax, BYTE PTR [rax+5]
  00122	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR buf$[rsp]
  0012a	48 03 c8	 add	 rcx, rax
  0012d	48 8b c1	 mov	 rax, rcx

; 308  : }

  00130	48 83 c4 78	 add	 rsp, 120		; 00000078H
  00134	c3		 ret	 0
show_ckd_key ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\cckddiag64.c
_TEXT	SEGMENT
r$ = 128
hh$ = 132
cc$ = 136
dl$ = 140
kl$ = 144
past$ = 152
rh$ = 176
trk$ = 184
show_ckd_count PROC

; 277  : {

  00000	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00004	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00009	48 81 ec a8 00
	00 00		 sub	 rsp, 168		; 000000a8H

; 278  : int     cc, hh, r, kl, dl;
; 279  : BYTE    *past;
; 280  : 
; 281  :     cc = (rh->cyl[0] << 8) | (rh->cyl[1]);

  00010	b8 01 00 00 00	 mov	 eax, 1
  00015	48 6b c0 00	 imul	 rax, rax, 0
  00019	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR rh$[rsp]
  00021	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00025	c1 e0 08	 shl	 eax, 8
  00028	b9 01 00 00 00	 mov	 ecx, 1
  0002d	48 6b c9 01	 imul	 rcx, rcx, 1
  00031	48 8b 94 24 b0
	00 00 00	 mov	 rdx, QWORD PTR rh$[rsp]
  00039	0f b6 0c 0a	 movzx	 ecx, BYTE PTR [rdx+rcx]
  0003d	0b c1		 or	 eax, ecx
  0003f	89 84 24 88 00
	00 00		 mov	 DWORD PTR cc$[rsp], eax

; 282  :     hh = (rh->head[0] << 8) | (rh->head[1]);

  00046	b8 01 00 00 00	 mov	 eax, 1
  0004b	48 6b c0 00	 imul	 rax, rax, 0
  0004f	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR rh$[rsp]
  00057	0f b6 44 01 02	 movzx	 eax, BYTE PTR [rcx+rax+2]
  0005c	c1 e0 08	 shl	 eax, 8
  0005f	b9 01 00 00 00	 mov	 ecx, 1
  00064	48 6b c9 01	 imul	 rcx, rcx, 1
  00068	48 8b 94 24 b0
	00 00 00	 mov	 rdx, QWORD PTR rh$[rsp]
  00070	0f b6 4c 0a 02	 movzx	 ecx, BYTE PTR [rdx+rcx+2]
  00075	0b c1		 or	 eax, ecx
  00077	89 84 24 84 00
	00 00		 mov	 DWORD PTR hh$[rsp], eax

; 283  :     r  = rh->rec;

  0007e	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR rh$[rsp]
  00086	0f b6 40 04	 movzx	 eax, BYTE PTR [rax+4]
  0008a	89 84 24 80 00
	00 00		 mov	 DWORD PTR r$[rsp], eax

; 284  :     kl = rh->klen;

  00091	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR rh$[rsp]
  00099	0f b6 40 05	 movzx	 eax, BYTE PTR [rax+5]
  0009d	89 84 24 90 00
	00 00		 mov	 DWORD PTR kl$[rsp], eax

; 285  :     dl = (rh->dlen[0] << 8) | (rh->dlen[1]);

  000a4	b8 01 00 00 00	 mov	 eax, 1
  000a9	48 6b c0 00	 imul	 rax, rax, 0
  000ad	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR rh$[rsp]
  000b5	0f b6 44 01 06	 movzx	 eax, BYTE PTR [rcx+rax+6]
  000ba	c1 e0 08	 shl	 eax, 8
  000bd	b9 01 00 00 00	 mov	 ecx, 1
  000c2	48 6b c9 01	 imul	 rcx, rcx, 1
  000c6	48 8b 94 24 b0
	00 00 00	 mov	 rdx, QWORD PTR rh$[rsp]
  000ce	0f b6 4c 0a 06	 movzx	 ecx, BYTE PTR [rdx+rcx+6]
  000d3	0b c1		 or	 eax, ecx
  000d5	89 84 24 8c 00
	00 00		 mov	 DWORD PTR dl$[rsp], eax

; 286  : 
; 287  :     // "Track %d COUNT cyl[%04X/%d] head[%04X/%d] rec[%02X/%d] kl[%d] dl[%d]"
; 288  :     WRMSG( HHC02605, "I", trk, cc, cc, hh, hh, r, r, kl, dl );

  000dc	b9 01 00 00 00	 mov	 ecx, 1
  000e1	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  000e7	8b 8c 24 8c 00
	00 00		 mov	 ecx, DWORD PTR dl$[rsp]
  000ee	89 4c 24 78	 mov	 DWORD PTR [rsp+120], ecx
  000f2	8b 8c 24 90 00
	00 00		 mov	 ecx, DWORD PTR kl$[rsp]
  000f9	89 4c 24 70	 mov	 DWORD PTR [rsp+112], ecx
  000fd	8b 8c 24 80 00
	00 00		 mov	 ecx, DWORD PTR r$[rsp]
  00104	89 4c 24 68	 mov	 DWORD PTR [rsp+104], ecx
  00108	8b 8c 24 80 00
	00 00		 mov	 ecx, DWORD PTR r$[rsp]
  0010f	89 4c 24 60	 mov	 DWORD PTR [rsp+96], ecx
  00113	8b 8c 24 84 00
	00 00		 mov	 ecx, DWORD PTR hh$[rsp]
  0011a	89 4c 24 58	 mov	 DWORD PTR [rsp+88], ecx
  0011e	8b 8c 24 84 00
	00 00		 mov	 ecx, DWORD PTR hh$[rsp]
  00125	89 4c 24 50	 mov	 DWORD PTR [rsp+80], ecx
  00129	8b 8c 24 88 00
	00 00		 mov	 ecx, DWORD PTR cc$[rsp]
  00130	89 4c 24 48	 mov	 DWORD PTR [rsp+72], ecx
  00134	8b 8c 24 88 00
	00 00		 mov	 ecx, DWORD PTR cc$[rsp]
  0013b	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  0013f	8b 8c 24 b8 00
	00 00		 mov	 ecx, DWORD PTR trk$[rsp]
  00146	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  0014a	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159715
  00151	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  00156	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159716
  0015d	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00162	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00167	41 b9 03 00 00
	00		 mov	 r9d, 3
  0016d	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG159717
  00174	ba 20 01 00 00	 mov	 edx, 288		; 00000120H
  00179	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159718
  00180	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 289  : 
; 290  :     past = (BYTE *)rh + CKD_RECHDR_SIZE;

  00186	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR rh$[rsp]
  0018e	48 83 c0 08	 add	 rax, 8
  00192	48 89 84 24 98
	00 00 00	 mov	 QWORD PTR past$[rsp], rax

; 291  :     return past;

  0019a	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR past$[rsp]

; 292  : }

  001a2	48 81 c4 a8 00
	00 00		 add	 rsp, 168		; 000000a8H
  001a9	c3		 ret	 0
show_ckd_count ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\cckddiag64.c
_TEXT	SEGMENT
tv78 = 0
bufl$ = 4
tv76 = 8
tv69 = 16
ibuf$ = 64
ibuflen$ = 72
obuf$ = 80
obuflen$ = 88
heads$ = 96
trk$ = 104
emsg$ = 112
decomptrk PROC

; 183  : {

  00000	44 89 4c 24 20	 mov	 DWORD PTR [rsp+32], r9d
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  0000e	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00013	56		 push	 rsi
  00014	57		 push	 rdi
  00015	48 83 ec 28	 sub	 rsp, 40			; 00000028H
$LN4@decomptrk:

; 184  : #if defined( HAVE_ZLIB ) || defined( CCKD_BZIP2 )
; 185  :     int             rc;         /* Return code                       */
; 186  : #endif
; 187  :     unsigned int    bufl;       /* Buffer length                     */
; 188  : #if defined( CCKD_BZIP2 )
; 189  :     unsigned int    ubufl;      /* when U64 != unsigned int          */
; 190  : #endif
; 191  : 
; 192  : #if !defined( HAVE_ZLIB ) && !defined( CCKD_BZIP2 )
; 193  :     UNREFERENCED(heads);

  00019	33 c0		 xor	 eax, eax
  0001b	85 c0		 test	 eax, eax
  0001d	75 fa		 jne	 SHORT $LN4@decomptrk
$LN7@decomptrk:

; 194  :     UNREFERENCED(trk);

  0001f	33 c0		 xor	 eax, eax
  00021	85 c0		 test	 eax, eax
  00023	75 fa		 jne	 SHORT $LN7@decomptrk
$LN10@decomptrk:

; 195  :     UNREFERENCED(emsg);

  00025	33 c0		 xor	 eax, eax
  00027	85 c0		 test	 eax, eax
  00029	75 fa		 jne	 SHORT $LN10@decomptrk

; 196  : #endif
; 197  : 
; 198  :     memset(obuf, 0, obuflen);

  0002b	48 63 44 24 58	 movsxd	 rax, DWORD PTR obuflen$[rsp]
  00030	48 89 44 24 10	 mov	 QWORD PTR tv69[rsp], rax
  00035	48 8b 7c 24 50	 mov	 rdi, QWORD PTR obuf$[rsp]
  0003a	33 c0		 xor	 eax, eax
  0003c	48 8b 4c 24 10	 mov	 rcx, QWORD PTR tv69[rsp]
  00041	f3 aa		 rep stosb

; 199  : 
; 200  :     /* Uncompress the track/block image */
; 201  :     switch (ibuf[0] & CCKD_COMPRESS_MASK)

  00043	b8 01 00 00 00	 mov	 eax, 1
  00048	48 6b c0 00	 imul	 rax, rax, 0
  0004c	48 8b 4c 24 40	 mov	 rcx, QWORD PTR ibuf$[rsp]
  00051	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00055	83 e0 03	 and	 eax, 3
  00058	89 44 24 08	 mov	 DWORD PTR tv76[rsp], eax
  0005c	83 7c 24 08 00	 cmp	 DWORD PTR tv76[rsp], 0
  00061	74 02		 je	 SHORT $LN13@decomptrk
  00063	eb 35		 jmp	 SHORT $LN14@decomptrk
$LN13@decomptrk:

; 202  :     {
; 203  : 
; 204  :     case CCKD_COMPRESS_NONE:
; 205  :         bufl = (ibuflen < obuflen) ? ibuflen : obuflen;

  00065	8b 44 24 58	 mov	 eax, DWORD PTR obuflen$[rsp]
  00069	39 44 24 48	 cmp	 DWORD PTR ibuflen$[rsp], eax
  0006d	7d 09		 jge	 SHORT $LN16@decomptrk
  0006f	8b 44 24 48	 mov	 eax, DWORD PTR ibuflen$[rsp]
  00073	89 04 24	 mov	 DWORD PTR tv78[rsp], eax
  00076	eb 07		 jmp	 SHORT $LN17@decomptrk
$LN16@decomptrk:
  00078	8b 44 24 58	 mov	 eax, DWORD PTR obuflen$[rsp]
  0007c	89 04 24	 mov	 DWORD PTR tv78[rsp], eax
$LN17@decomptrk:
  0007f	8b 04 24	 mov	 eax, DWORD PTR tv78[rsp]
  00082	89 44 24 04	 mov	 DWORD PTR bufl$[rsp], eax

; 206  :         memcpy (obuf, ibuf, bufl);

  00086	8b 44 24 04	 mov	 eax, DWORD PTR bufl$[rsp]
  0008a	48 8b 7c 24 50	 mov	 rdi, QWORD PTR obuf$[rsp]
  0008f	48 8b 74 24 40	 mov	 rsi, QWORD PTR ibuf$[rsp]
  00094	8b c8		 mov	 ecx, eax
  00096	f3 a4		 rep movsb

; 207  :         break;

  00098	eb 07		 jmp	 SHORT $LN11@decomptrk
$LN14@decomptrk:

; 208  : 
; 209  : #if defined( HAVE_ZLIB )
; 210  :     case CCKD_COMPRESS_ZLIB:
; 211  :         memcpy (obuf, ibuf, CKD_TRKHDR_SIZE);
; 212  :         bufl = obuflen - CKD_TRKHDR_SIZE;
; 213  :         rc = uncompress(&obuf[ CKD_TRKHDR_SIZE ],
; 214  :                          (void *)&bufl,
; 215  :                          &ibuf[ CKD_TRKHDR_SIZE ],
; 216  :                          ibuflen);
; 217  :         if (rc != Z_OK)
; 218  :         {
; 219  :             if (emsg)
; 220  :             {
; 221  :                 char msg[81];
; 222  : 
; 223  :                 MSGBUF(msg, "%s %d uncompress error, rc=%d;"
; 224  :                          "%2.2x%2.2x%2.2x%2.2x%2.2x",
; 225  :                          heads >= 0 ? "trk" : "blk", trk, rc,
; 226  :                          ibuf[0], ibuf[1], ibuf[2], ibuf[3], ibuf[4]);
; 227  :                 memcpy(emsg, msg, 81);
; 228  :             }
; 229  :             return -1;
; 230  :         }
; 231  :         bufl += CKD_TRKHDR_SIZE;
; 232  :         break;
; 233  : #endif
; 234  : 
; 235  : #if defined( CCKD_BZIP2 )
; 236  :     case CCKD_COMPRESS_BZIP2:
; 237  :         memcpy(obuf, ibuf, CKD_TRKHDR_SIZE);
; 238  :         ubufl = obuflen - CKD_TRKHDR_SIZE;
; 239  :         rc = BZ2_bzBuffToBuffDecompress
; 240  :         (
; 241  :             (char *)&obuf[ CKD_TRKHDR_SIZE ],
; 242  :             &ubufl,
; 243  :             (char *)&ibuf[ CKD_TRKHDR_SIZE ],
; 244  :             ibuflen, 0, 0
; 245  :         );
; 246  :         if (rc != BZ_OK)
; 247  :         {
; 248  :             if (emsg)
; 249  :             {
; 250  :                 char msg[81];
; 251  : 
; 252  :                 MSGBUF(msg, "%s %d decompress error, rc=%d;"
; 253  :                          "%2.2x%2.2x%2.2x%2.2x%2.2x",
; 254  :                          heads >= 0 ? "trk" : "blk", trk, rc,
; 255  :                          ibuf[0], ibuf[1], ibuf[2], ibuf[3], ibuf[4]);
; 256  :                 memcpy(emsg, msg, 81);
; 257  :             }
; 258  :             return -1;
; 259  :         }
; 260  :         bufl=ubufl;
; 261  :         bufl += CKD_TRKHDR_SIZE;
; 262  :         break;
; 263  : #endif
; 264  : 
; 265  :     default:
; 266  :         return -1;

  0009a	b8 ff ff ff ff	 mov	 eax, -1
  0009f	eb 04		 jmp	 SHORT $LN1@decomptrk
$LN11@decomptrk:

; 267  : 
; 268  :     } /* switch (buf[0] & CCKD_COMPRESS_MASK) */
; 269  :     return bufl;

  000a1	8b 44 24 04	 mov	 eax, DWORD PTR bufl$[rsp]
$LN1@decomptrk:

; 270  : }

  000a5	48 83 c4 28	 add	 rsp, 40			; 00000028H
  000a9	5f		 pop	 rdi
  000aa	5e		 pop	 rsi
  000ab	c3		 ret	 0
decomptrk ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\cckddiag64.c
_TEXT	SEGMENT
rc$ = 80
tv81 = 88
tv147 = 96
fd$ = 128
buf$ = 136
offset$ = 144
len$ = 152
readpos	PROC

; 113  : {

  00000	44 89 4c 24 20	 mov	 DWORD PTR [rsp+32], r9d
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	89 4c 24 08	 mov	 DWORD PTR [rsp+8], ecx
  00013	48 83 ec 78	 sub	 rsp, 120		; 00000078H

; 114  :     int rc;
; 115  : 
; 116  :     if (debug)

  00017	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR debug, 0
  0001e	74 61		 je	 SHORT $LN2@readpos

; 117  :     {
; 118  :         // "READPOS seeking %"PRId64" (0x%16.16"PRIX64")"
; 119  :         WRMSG( HHC90401, "D", offset, offset );

  00020	b9 01 00 00 00	 mov	 ecx, 1
  00025	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  0002b	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR offset$[rsp]
  00033	48 89 4c 24 40	 mov	 QWORD PTR [rsp+64], rcx
  00038	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR offset$[rsp]
  00040	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  00045	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159634
  0004c	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  00051	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159635
  00058	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  0005d	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00062	41 b9 03 00 00
	00		 mov	 r9d, 3
  00068	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG159636
  0006f	ba 77 00 00 00	 mov	 edx, 119		; 00000077H
  00074	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159637
  0007b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg
$LN2@readpos:

; 120  :     }
; 121  :     if (lseek( fd, offset, SEEK_SET ) < 0)

  00081	45 33 c0	 xor	 r8d, r8d
  00084	48 8b 94 24 90
	00 00 00	 mov	 rdx, QWORD PTR offset$[rsp]
  0008c	8b 8c 24 80 00
	00 00		 mov	 ecx, DWORD PTR fd$[rsp]
  00093	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__lseeki64
  00099	48 85 c0	 test	 rax, rax
  0009c	0f 8d 80 00 00
	00		 jge	 $LN3@readpos

; 122  :     {
; 123  :         // "lseek() to pos 0x%16.16"PRIx64" error: %s"
; 124  :         FWRMSG( stderr, HHC02603, "S",

  000a2	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno
  000a8	8b 08		 mov	 ecx, DWORD PTR [rax]
  000aa	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_strerror
  000b0	48 89 44 24 58	 mov	 QWORD PTR tv81[rsp], rax
  000b5	b9 02 00 00 00	 mov	 ecx, 2
  000ba	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  000c0	48 8b 4c 24 58	 mov	 rcx, QWORD PTR tv81[rsp]
  000c5	48 89 4c 24 40	 mov	 QWORD PTR [rsp+64], rcx
  000ca	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR offset$[rsp]
  000d2	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  000d7	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159639
  000de	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  000e3	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159640
  000ea	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  000ef	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  000f4	41 b9 03 00 00
	00		 mov	 r9d, 3
  000fa	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG159641
  00101	ba 7d 00 00 00	 mov	 edx, 125		; 0000007dH
  00106	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159642
  0010d	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 125  :             offset, strerror( errno ));
; 126  :         clean();

  00113	e8 00 00 00 00	 call	 clean

; 127  :         ErrExit( EXIT_SEEK_ERROR );

  00118	b9 01 00 00 00	 mov	 ecx, 1
  0011d	e8 00 00 00 00	 call	 ErrExit
$LN3@readpos:

; 128  :     }
; 129  : 
; 130  :     if (debug)

  00122	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR debug, 0
  00129	74 6a		 je	 SHORT $LN4@readpos

; 131  :     {
; 132  :         // "READPOS reading buf addr %p length %d (0x%X)"
; 133  :         WRMSG( HHC90402, "D", buf, len, len);

  0012b	b9 01 00 00 00	 mov	 ecx, 1
  00130	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  00136	8b 8c 24 98 00
	00 00		 mov	 ecx, DWORD PTR len$[rsp]
  0013d	89 4c 24 48	 mov	 DWORD PTR [rsp+72], ecx
  00141	8b 8c 24 98 00
	00 00		 mov	 ecx, DWORD PTR len$[rsp]
  00148	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  0014c	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR buf$[rsp]
  00154	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  00159	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159644
  00160	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  00165	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159645
  0016c	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00171	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00176	41 b9 03 00 00
	00		 mov	 r9d, 3
  0017c	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG159646
  00183	ba 85 00 00 00	 mov	 edx, 133		; 00000085H
  00188	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159647
  0018f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg
$LN4@readpos:

; 134  :     }
; 135  : 
; 136  :     rc = read( fd, buf, len);

  00195	44 8b 84 24 98
	00 00 00	 mov	 r8d, DWORD PTR len$[rsp]
  0019d	48 8b 94 24 88
	00 00 00	 mov	 rdx, QWORD PTR buf$[rsp]
  001a5	8b 8c 24 80 00
	00 00		 mov	 ecx, DWORD PTR fd$[rsp]
  001ac	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_read
  001b2	89 44 24 50	 mov	 DWORD PTR rc$[rsp], eax

; 137  : 
; 138  :     if (rc < (int) len )

  001b6	8b 84 24 98 00
	00 00		 mov	 eax, DWORD PTR len$[rsp]
  001bd	39 44 24 50	 cmp	 DWORD PTR rc$[rsp], eax
  001c1	0f 8d 52 01 00
	00		 jge	 $LN5@readpos

; 139  :     {
; 140  :         if (rc < 0)

  001c7	83 7c 24 50 00	 cmp	 DWORD PTR rc$[rsp], 0
  001cc	7d 75		 jge	 SHORT $LN6@readpos

; 141  :         {
; 142  :             // "%s%s"
; 143  :             FWRMSG( stderr, HHC02604, "S", "read() error: ", strerror( errno ));

  001ce	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno
  001d4	8b 08		 mov	 ecx, DWORD PTR [rax]
  001d6	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_strerror
  001dc	48 89 44 24 60	 mov	 QWORD PTR tv147[rsp], rax
  001e1	b9 02 00 00 00	 mov	 ecx, 2
  001e6	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  001ec	48 8b 4c 24 60	 mov	 rcx, QWORD PTR tv147[rsp]
  001f1	48 89 4c 24 40	 mov	 QWORD PTR [rsp+64], rcx
  001f6	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159651
  001fd	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  00202	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159652
  00209	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  0020e	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159653
  00215	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  0021a	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  0021f	41 b9 03 00 00
	00		 mov	 r9d, 3
  00225	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG159654
  0022c	ba 8f 00 00 00	 mov	 edx, 143		; 0000008fH
  00231	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159655
  00238	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 144  :         }

  0023e	e9 c7 00 00 00	 jmp	 $LN7@readpos
$LN6@readpos:

; 145  :         else if (rc == 0)

  00243	83 7c 24 50 00	 cmp	 DWORD PTR rc$[rsp], 0
  00248	75 61		 jne	 SHORT $LN8@readpos

; 146  :         {
; 147  :             // "%s%s"
; 148  :             FWRMSG( stderr, HHC02604, "S", "read() error: ", "unexpected EOF" );

  0024a	b9 02 00 00 00	 mov	 ecx, 2
  0024f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  00255	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159658
  0025c	48 89 4c 24 40	 mov	 QWORD PTR [rsp+64], rcx
  00261	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159659
  00268	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  0026d	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159660
  00274	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  00279	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159661
  00280	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00285	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  0028a	41 b9 03 00 00
	00		 mov	 r9d, 3
  00290	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG159662
  00297	ba 94 00 00 00	 mov	 edx, 148		; 00000094H
  0029c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159663
  002a3	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 149  :         }

  002a9	eb 5f		 jmp	 SHORT $LN9@readpos
$LN8@readpos:

; 150  :         else
; 151  :         {
; 152  :             // "%s%s"
; 153  :             FWRMSG( stderr, HHC02604, "S", "read() error: ", "short block" );

  002ab	b9 02 00 00 00	 mov	 ecx, 2
  002b0	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  002b6	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159664
  002bd	48 89 4c 24 40	 mov	 QWORD PTR [rsp+64], rcx
  002c2	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159665
  002c9	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  002ce	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159666
  002d5	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  002da	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159667
  002e1	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  002e6	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  002eb	41 b9 03 00 00
	00		 mov	 r9d, 3
  002f1	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG159668
  002f8	ba 99 00 00 00	 mov	 edx, 153		; 00000099H
  002fd	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159669
  00304	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg
$LN9@readpos:
$LN7@readpos:

; 154  :         }
; 155  : 
; 156  :         clean();

  0030a	e8 00 00 00 00	 call	 clean

; 157  :         ErrExit( EXIT_READ_ERROR );

  0030f	b9 02 00 00 00	 mov	 ecx, 2
  00314	e8 00 00 00 00	 call	 ErrExit
$LN5@readpos:

; 158  :     }
; 159  :     return 0;

  00319	33 c0		 xor	 eax, eax

; 160  : }

  0031b	48 83 c4 78	 add	 rsp, 120		; 00000078H
  0031f	c3		 ret	 0
readpos	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\cckddiag64.c
_TEXT	SEGMENT
p$ = 80
len$ = 112
label$ = 120
makbuf	PROC

; 84   : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	89 4c 24 08	 mov	 DWORD PTR [rsp+8], ecx
  00009	48 83 ec 68	 sub	 rsp, 104		; 00000068H

; 85   :     void *p;
; 86   : 
; 87   :     if (!(p = malloc( len )))

  0000d	48 63 44 24 70	 movsxd	 rax, DWORD PTR len$[rsp]
  00012	48 8b c8	 mov	 rcx, rax
  00015	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_malloc
  0001b	48 89 44 24 50	 mov	 QWORD PTR p$[rsp], rax
  00020	48 83 7c 24 50
	00		 cmp	 QWORD PTR p$[rsp], 0
  00026	75 74		 jne	 SHORT $LN2@makbuf

; 88   :     {
; 89   :         // "From %s: Storage allocation of size %d using %s failed"
; 90   :         FWRMSG( stderr, HHC02602, "S", label, len, "malloc()" );

  00028	b9 02 00 00 00	 mov	 ecx, 2
  0002d	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  00033	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159611
  0003a	48 89 4c 24 48	 mov	 QWORD PTR [rsp+72], rcx
  0003f	8b 4c 24 70	 mov	 ecx, DWORD PTR len$[rsp]
  00043	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  00047	48 8b 4c 24 78	 mov	 rcx, QWORD PTR label$[rsp]
  0004c	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  00051	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159612
  00058	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  0005d	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159613
  00064	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00069	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  0006e	41 b9 03 00 00
	00		 mov	 r9d, 3
  00074	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG159614
  0007b	ba 5a 00 00 00	 mov	 edx, 90			; 0000005aH
  00080	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159615
  00087	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 91   :         clean();

  0008d	e8 00 00 00 00	 call	 clean

; 92   :         ErrExit( EXIT_MALLOC_FAILED );

  00092	b9 04 00 00 00	 mov	 ecx, 4
  00097	e8 00 00 00 00	 call	 ErrExit
$LN2@makbuf:

; 93   :     }
; 94   :     if (debug)

  0009c	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR debug, 0
  000a3	74 63		 je	 SHORT $LN3@makbuf

; 95   :     {
; 96   :         // "MAKBUF() malloc %s buffer of %d bytes at %p"
; 97   :         WRMSG( HHC90400, "D", label, len, p);

  000a5	b9 01 00 00 00	 mov	 ecx, 1
  000aa	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  000b0	48 8b 4c 24 50	 mov	 rcx, QWORD PTR p$[rsp]
  000b5	48 89 4c 24 48	 mov	 QWORD PTR [rsp+72], rcx
  000ba	8b 4c 24 70	 mov	 ecx, DWORD PTR len$[rsp]
  000be	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  000c2	48 8b 4c 24 78	 mov	 rcx, QWORD PTR label$[rsp]
  000c7	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  000cc	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159617
  000d3	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  000d8	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159618
  000df	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  000e4	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  000e9	41 b9 03 00 00
	00		 mov	 r9d, 3
  000ef	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG159619
  000f6	ba 61 00 00 00	 mov	 edx, 97			; 00000061H
  000fb	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159620
  00102	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg
$LN3@makbuf:

; 98   :     }
; 99   :     return p;

  00108	48 8b 44 24 50	 mov	 rax, QWORD PTR p$[rsp]

; 100  : }

  0010d	48 83 c4 68	 add	 rsp, 104		; 00000068H
  00111	c3		 ret	 0
makbuf	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\cckddiag64.c
_TEXT	SEGMENT
clean	PROC

; 72   : {

  00000	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 73   :     close(fd);

  00004	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR fd
  0000a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_close

; 74   :     free(L1tab);                       /* L1TAB buffer               */

  00010	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR L1tab
  00017	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free

; 75   :     free(L2tab);                       /* L2TAB buffer               */

  0001d	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR L2tab
  00024	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free

; 76   :     free(tbuf);                        /* track and header buffer    */

  0002a	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR tbuf
  00031	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free

; 77   :     free(bulk);                        /* offset data buffer         */

  00037	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR bulk
  0003e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free

; 78   : }

  00044	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00048	c3		 ret	 0
clean	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\cckddiag64.c
_TEXT	SEGMENT
pgm$ = 80
syntax	PROC

; 62   : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 63   :     // "Usage: %s ...
; 64   :     WRMSG( HHC02600, "I", pgm );

  00009	b9 01 00 00 00	 mov	 ecx, 1
  0000e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  00014	48 8b 4c 24 50	 mov	 rcx, QWORD PTR pgm$[rsp]
  00019	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  0001e	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159593
  00025	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  0002a	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159594
  00031	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00036	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  0003b	41 b9 03 00 00
	00		 mov	 r9d, 3
  00041	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG159595
  00048	ba 40 00 00 00	 mov	 edx, 64			; 00000040H
  0004d	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159596
  00054	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 65   :     ErrExit( EXIT_ERROR_SYNTAX );

  0005a	b9 ff ff ff ff	 mov	 ecx, -1
  0005f	e8 00 00 00 00	 call	 ErrExit

; 66   : }

  00064	48 83 c4 48	 add	 rsp, 72			; 00000048H
  00068	c3		 ret	 0
syntax	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\cckddiag64.c
_TEXT	SEGMENT
rc$ = 48
ErrExit	PROC

; 54   : {

  00000	89 4c 24 08	 mov	 DWORD PTR [rsp+8], ecx
  00004	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 55   :     exit( rc );     // common breakpoint location

  00008	8b 4c 24 30	 mov	 ecx, DWORD PTR rc$[rsp]
  0000c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_exit
$LN2@ErrExit:

; 56   : }

  00012	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00016	c3		 ret	 0
ErrExit	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\machdep.h
;	COMDAT fetch_fw_noswap
_TEXT	SEGMENT
value$ = 0
ptr$ = 32
fetch_fw_noswap PROC					; COMDAT

; 746  :     inline U32 fetch_fw_noswap(const void *ptr) {

$LN3:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 18	 sub	 rsp, 24

; 747  :       U32 value;
; 748  :       memcpy(&value, (BYTE *)ptr, 4);

  00009	48 8b 44 24 20	 mov	 rax, QWORD PTR ptr$[rsp]
  0000e	8b 00		 mov	 eax, DWORD PTR [rax]
  00010	89 04 24	 mov	 DWORD PTR value$[rsp], eax

; 749  :       return value;

  00013	8b 04 24	 mov	 eax, DWORD PTR value$[rsp]

; 750  :     }

  00016	48 83 c4 18	 add	 rsp, 24
  0001a	c3		 ret	 0
fetch_fw_noswap ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files (x86)\Windows Kits\10\include\10.0.22000.0\ucrt\stdio.h
;	COMDAT printf
_TEXT	SEGMENT
_Result$ = 32
_ArgList$ = 40
_Format$ = 64
printf	PROC						; COMDAT

; 956  :     {

$LN3:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000f	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00014	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 957  :         int _Result;
; 958  :         va_list _ArgList;
; 959  :         __crt_va_start(_ArgList, _Format);

  00018	48 8d 44 24 48	 lea	 rax, QWORD PTR _Format$[rsp+8]
  0001d	48 89 44 24 28	 mov	 QWORD PTR _ArgList$[rsp], rax

; 960  :         _Result = _vfprintf_l(stdout, _Format, NULL, _ArgList);

  00022	b9 01 00 00 00	 mov	 ecx, 1
  00027	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  0002d	4c 8b 4c 24 28	 mov	 r9, QWORD PTR _ArgList$[rsp]
  00032	45 33 c0	 xor	 r8d, r8d
  00035	48 8b 54 24 40	 mov	 rdx, QWORD PTR _Format$[rsp]
  0003a	48 8b c8	 mov	 rcx, rax
  0003d	e8 00 00 00 00	 call	 _vfprintf_l
  00042	89 44 24 20	 mov	 DWORD PTR _Result$[rsp], eax

; 961  :         __crt_va_end(_ArgList);

  00046	48 c7 44 24 28
	00 00 00 00	 mov	 QWORD PTR _ArgList$[rsp], 0

; 962  :         return _Result;

  0004f	8b 44 24 20	 mov	 eax, DWORD PTR _Result$[rsp]

; 963  :     }

  00053	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00057	c3		 ret	 0
printf	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files (x86)\Windows Kits\10\include\10.0.22000.0\ucrt\stdio.h
;	COMDAT _vfprintf_l
_TEXT	SEGMENT
_Stream$ = 64
_Format$ = 72
_Locale$ = 80
_ArgList$ = 88
_vfprintf_l PROC					; COMDAT

; 644  :     {

$LN3:
  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 645  :         return __stdio_common_vfprintf(_CRT_INTERNAL_LOCAL_PRINTF_OPTIONS, _Stream, _Format, _Locale, _ArgList);

  00018	e8 00 00 00 00	 call	 __local_stdio_printf_options
  0001d	48 8b 4c 24 58	 mov	 rcx, QWORD PTR _ArgList$[rsp]
  00022	48 89 4c 24 20	 mov	 QWORD PTR [rsp+32], rcx
  00027	4c 8b 4c 24 50	 mov	 r9, QWORD PTR _Locale$[rsp]
  0002c	4c 8b 44 24 48	 mov	 r8, QWORD PTR _Format$[rsp]
  00031	48 8b 54 24 40	 mov	 rdx, QWORD PTR _Stream$[rsp]
  00036	48 8b 08	 mov	 rcx, QWORD PTR [rax]
  00039	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___stdio_common_vfprintf

; 646  :     }

  0003f	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00043	c3		 ret	 0
_vfprintf_l ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files (x86)\Windows Kits\10\include\10.0.22000.0\ucrt\corecrt_stdio_config.h
;	COMDAT __local_stdio_printf_options
_TEXT	SEGMENT
__local_stdio_printf_options PROC			; COMDAT

; 91   :         static unsigned __int64 _OptionsStorage;
; 92   :         return &_OptionsStorage;

  00000	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:?_OptionsStorage@?1??__local_stdio_printf_options@@9@9 ; `__local_stdio_printf_options'::`2'::_OptionsStorage

; 93   :     }

  00007	c3		 ret	 0
__local_stdio_printf_options ENDP
_TEXT	ENDS
END
