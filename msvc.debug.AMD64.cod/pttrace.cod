; Listing generated by Microsoft (R) Optimizing Compiler Version 19.34.31937.0 

include listing.inc

INCLUDELIB MSVCRTD
INCLUDELIB OLDNAMES

PUBLIC	pttracen
PUBLIC	pttracex
PUBLIC	pttrace
PUBLIC	pttnolock
PUBLIC	pttnotod
PUBLIC	pttnowrap
PUBLIC	pttdtax
PUBLIC	pttto
PUBLIC	pttcltab
PUBLIC	pttclass
_DATA	SEGMENT
COMM	pttlock:QWORD
_DATA	ENDS
_BSS	SEGMENT
pttracen DD	01H DUP (?)
pttracex DD	01H DUP (?)
pttrace	DQ	01H DUP (?)
pttnolock DD	01H DUP (?)
pttnotod DD	01H DUP (?)
pttnowrap DD	01H DUP (?)
pttdtax	DB	01H DUP (?)
	ALIGN	4

pttto	DD	01H DUP (?)
_BSS	ENDS
_DATA	SEGMENT
COMM	ptttocond:QWORD
COMM	ptttolock:QWORD
COMM	ptttotid:DWORD
_DATA	ENDS
_BSS	SEGMENT
	ALIGN	8

pttclass DQ	01H DUP (?)
_BSS	ENDS
_DATA	SEGMENT
pttcltab DQ	FLAT:$SG159080
	DQ	0000000000000001H
	DD	00H
	ORG $+4
	DQ	FLAT:$SG159081
	DQ	0000000000000002H
	DD	00H
	ORG $+4
	DQ	FLAT:$SG159082
	DQ	0000000000000004H
	DD	00H
	ORG $+4
	DQ	FLAT:$SG159083
	DQ	0000000000000008H
	DD	00H
	ORG $+4
	DQ	FLAT:$SG159084
	DQ	0000000000000010H
	DD	00H
	ORG $+4
	DQ	FLAT:$SG159085
	DQ	0000000000000020H
	DD	00H
	ORG $+4
	DQ	FLAT:$SG159086
	DQ	0000000000000040H
	DD	00H
	ORG $+4
	DQ	FLAT:$SG159087
	DQ	0000000000000080H
	DD	00H
	ORG $+4
	DQ	FLAT:$SG159088
	DQ	0000000000000100H
	DD	00H
	ORG $+4
	DQ	FLAT:$SG159089
	DQ	0000000000000200H
	DD	00H
	ORG $+4
	DQ	FLAT:$SG159090
	DQ	0000000000000400H
	DD	00H
	ORG $+4
	DQ	FLAT:$SG159091
	DQ	0000000000010000H
	DD	00H
	ORG $+4
	DQ	FLAT:$SG159092
	DQ	0000000000020000H
	DD	00H
	ORG $+4
	DQ	FLAT:$SG159093
	DQ	0000000000040000H
	DD	00H
	ORG $+4
	DQ	FLAT:$SG159094
	DQ	0000000000080000H
	DD	00H
	ORG $+4
	DQ	FLAT:$SG159095
	DQ	0000000000000001H
	DD	01H
	ORG $+4
	DQ	FLAT:$SG159096
	DQ	0000000000000002H
	DD	01H
	ORG $+4
	DQ	FLAT:$SG159097
	DQ	0000000000000004H
	DD	01H
	ORG $+4
	DQ	FLAT:$SG159098
	DQ	0000000000000008H
	DD	01H
	ORG $+4
	DQ	FLAT:$SG159099
	DQ	0000000000000010H
	DD	01H
	ORG $+4
	DQ	FLAT:$SG159100
	DQ	0000000000000020H
	DD	01H
	ORG $+4
	DQ	FLAT:$SG159101
	DQ	0000000000000040H
	DD	01H
	ORG $+4
	DQ	FLAT:$SG159102
	DQ	0000000000000100H
	DD	01H
	ORG $+4
$SG159080 DB	'log', 00H
$SG159081 DB	'tmr', 00H
$SG159082 DB	'thr', 00H
$SG159083 DB	'inf', 00H
$SG159084 DB	'err', 00H
$SG159085 DB	'pgm', 00H
$SG159086 DB	'csf', 00H
$SG159087 DB	'sie', 00H
$SG159088 DB	'sig', 00H
$SG159089 DB	'io', 00H
	ORG $+1
$SG159090 DB	'txf', 00H
$SG159091 DB	'lcs1', 00H
	ORG $+3
$SG159092 DB	'lcs2', 00H
	ORG $+3
$SG159093 DB	'qeth', 00H
	ORG $+3
$SG159094 DB	'xxx', 00H
$SG159095 DB	'logger', 00H
	ORG $+1
$SG159096 DB	'timer', 00H
	ORG $+2
$SG159097 DB	'threads', 00H
$SG159098 DB	'control', 00H
$SG159099 DB	'error', 00H
	ORG $+2
$SG159100 DB	'prog', 00H
	ORG $+3
$SG159101 DB	'inter', 00H
	ORG $+2
$SG159102 DB	'signal', 00H
	ORG $+1
$SG159175 DB	'ptt_timeout', 00H
_DATA	ENDS
CONST	SEGMENT
CKD_ENDTRK DB	0ffH
	DB	0ffH
	DB	0ffH
	DB	0ffH
	DB	0ffH
	DB	0ffH
	DB	0ffH
	DB	0ffH
CONST	ENDS
PUBLIC	__local_stdio_scanf_options
PUBLIC	_vsscanf_l
PUBLIC	sscanf
PUBLIC	ptt_trace_init
PUBLIC	ptt_cmd
PUBLIC	ptt_pthread_trace
PUBLIC	ptt_pthread_print
PUBLIC	ptt_dtax
EXTRN	__report_rangecheckfailure:PROC
EXTRN	__imp__stricmp:PROC
EXTRN	strlen:PROC
EXTRN	__imp__strnicmp:PROC
EXTRN	__imp_GetCurrentThreadId:PROC
EXTRN	__imp_calloc:PROC
EXTRN	__imp_free:PROC
EXTRN	__imp_malloc:PROC
EXTRN	__imp_realloc:PROC
EXTRN	__imp___acrt_iob_func:PROC
EXTRN	__imp___stdio_common_vsscanf:PROC
EXTRN	fthread_create:PROC
EXTRN	fthread_self:PROC
EXTRN	fthread_equal:PROC
EXTRN	fthread_mutex_init:PROC
EXTRN	fthread_mutex_lock:PROC
EXTRN	fthread_mutex_unlock:PROC
EXTRN	fthread_cond_init:PROC
EXTRN	fthread_cond_signal:PROC
EXTRN	fthread_cond_timedwait:PROC
EXTRN	fthread_mutexattr_init:PROC
EXTRN	fthread_mutexattr_destroy:PROC
EXTRN	fthread_mutexattr_settype:PROC
EXTRN	hthread_get_thread_prio:PROC
EXTRN	hthread_get_lock_name:PROC
EXTRN	hthread_set_thread_name:PROC
EXTRN	hthread_get_thread_name:PROC
EXTRN	strlcat:PROC
EXTRN	trimloc:PROC
EXTRN	FormatTIMEVAL:PROC
EXTRN	w32_strerror:PROC
EXTRN	gettimeofday:PROC
EXTRN	usleep:PROC
EXTRN	w32_snprintf:PROC
EXTRN	w32_set_thread_name:PROC
EXTRN	fwritemsg:PROC
EXTRN	__GSHandlerCheck:PROC
EXTRN	__security_check_cookie:PROC
EXTRN	__security_cookie:QWORD
_DATA	SEGMENT
COMM	?_OptionsStorage@?1??__local_stdio_scanf_options@@9@9:QWORD							; `__local_stdio_scanf_options'::`2'::_OptionsStorage
_DATA	ENDS
_BSS	SEGMENT
$SG159423 DB	01H DUP (?)
	ALIGN	4

$SG159425 DB	01H DUP (?)
_BSS	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$_vsscanf_l DD imagerel $LN3
	DD	imagerel $LN3+80
	DD	imagerel $unwind$_vsscanf_l
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$sscanf DD imagerel $LN3
	DD	imagerel $LN3+79
	DD	imagerel $unwind$sscanf
pdata	ENDS
pdata	SEGMENT
$pdata$ptt_trace_init DD imagerel $LN14
	DD	imagerel $LN14+325
	DD	imagerel $unwind$ptt_trace_init
$pdata$ptt_cmd DD imagerel $LN73
	DD	imagerel $LN73+1868
	DD	imagerel $unwind$ptt_cmd
$pdata$ptt_pthread_trace DD imagerel $LN31
	DD	imagerel $LN31+777
	DD	imagerel $unwind$ptt_pthread_trace
$pdata$ptt_pthread_print DD imagerel $LN32
	DD	imagerel $LN32+1371
	DD	imagerel $unwind$ptt_pthread_print
$pdata$pttcl_byname DD imagerel pttcl_byname
	DD	imagerel pttcl_byname+205
	DD	imagerel $unwind$pttcl_byname
$pdata$pttcl_all DD imagerel pttcl_all
	DD	imagerel pttcl_all+382
	DD	imagerel $unwind$pttcl_all
$pdata$ptt_showparms DD imagerel ptt_showparms
	DD	imagerel ptt_showparms+407
	DD	imagerel $unwind$ptt_showparms
$pdata$ptt_timeout DD imagerel ptt_timeout
	DD	imagerel ptt_timeout+516
	DD	imagerel $unwind$ptt_timeout
pdata	ENDS
_DATA	SEGMENT
$SG159114 DB	'no', 00H
	ORG $+1
$SG159136 DB	' ', 00H
	ORG $+2
$SG159143 DB	'nodtax', 00H
	ORG $+1
$SG159144 DB	'dtax', 00H
	ORG $+3
$SG159145 DB	'nowrap', 00H
	ORG $+1
$SG159146 DB	'wrap', 00H
	ORG $+3
$SG159147 DB	'notod', 00H
	ORG $+2
$SG159148 DB	'tod', 00H
$SG159149 DB	'nolock', 00H
	ORG $+1
$SG159150 DB	'lock', 00H
	ORG $+3
$SG159151 DB	'D', 00H
	ORG $+2
$SG159177 DB	'I', 00H
	ORG $+2
$SG159152 DB	'HHC90012%s Pttrace: %s %s %s %s %s to=%d %d', 0aH, 00H
	ORG $+3
$SG159153 DB	'ptt_showparms', 00H
	ORG $+2
$SG159154 DB	'pttrace.c', 00H
	ORG $+2
$SG159184 DB	'I', 00H
	ORG $+2
?thread_name@?1??ptt_timeout@@9@9 DQ FLAT:$SG159175	; `ptt_timeout'::`2'::thread_name
$SG159176 DB	'pttrace.c:219', 00H
	ORG $+2
$SG159178 DB	'HHC00100%s Thread id %8.8x, prio %d, name ''%s'' started'
	DB	0aH, 00H
$SG159179 DB	'ptt_timeout', 00H
$SG159246 DB	'?', 00H
	ORG $+2
$SG159180 DB	'pttrace.c', 00H
	ORG $+2
$SG159252 DB	'nodtax', 00H
	ORG $+1
$SG159261 DB	'tod', 00H
$SG159183 DB	'pttrace.c:243', 00H
	ORG $+2
$SG159185 DB	'HHC00101%s Thread id %8.8x, prio %d, name ''%s'' ended', 0aH
	DB	00H
	ORG $+2
$SG159186 DB	'ptt_timeout', 00H
$SG159273 DB	'to=', 00H
$SG159187 DB	'pttrace.c', 00H
	ORG $+2
$SG159239 DB	'opts', 00H
	ORG $+3
$SG159249 DB	'dtax', 00H
	ORG $+3
$SG159255 DB	'lock', 00H
	ORG $+3
$SG159258 DB	'nolock', 00H
	ORG $+1
$SG159264 DB	'notod', 00H
	ORG $+2
$SG159267 DB	'wrap', 00H
	ORG $+3
$SG159270 DB	'nowrap', 00H
	ORG $+1
$SG159274 DB	'%d%c', 00H
	ORG $+3
$SG159277 DB	'%d%c', 00H
	ORG $+3
$SG159285 DB	'E', 00H
	ORG $+2
$SG159286 DB	'HHC90010%s Pttrace: trace is busy', 0aH, 00H
	ORG $+1
$SG159296 DB	'E', 00H
	ORG $+2
$SG159287 DB	'ptt_cmd', 00H
$SG159288 DB	'pttrace.c', 00H
	ORG $+2
$SG159303 DB	'E', 00H
	ORG $+2
$SG159297 DB	'HHC90011%s Pttrace: invalid argument %s', 0aH, 00H
	ORG $+3
$SG159424 DB	' ', 00H
	ORG $+2
$SG159298 DB	'ptt_cmd', 00H
$SG159299 DB	'pttrace.c', 00H
	ORG $+2
$SG159428 DB	'D', 00H
	ORG $+2
$SG159304 DB	'HHC00102%s Error in function create_thread(): %s', 0aH, 00H
	ORG $+6
$SG159305 DB	'ptt_cmd', 00H
$SG159306 DB	'pttrace.c', 00H
	ORG $+6
$SG159364 DB	'timer.c:', 00H
	ORG $+7
$SG159366 DB	'clock.c:', 00H
	ORG $+7
$SG159368 DB	'logger.c:', 00H
	ORG $+6
$SG159370 DB	'logmsg.c:', 00H
	ORG $+2
$SG159421 DB	'%lld', 00H
	ORG $+7
$SG159422 DB	'%16.16llx', 00H
	ORG $+2
$SG159426 DB	'%s%s', 00H
	ORG $+7
$SG159430 DB	'ptt_pthread_print', 00H
	ORG $+6
$SG159429 DB	'HHC90021%s %s %8.8x %-15.15s %-18.18s %-18.18s%16.16llx '
	DB	'%16.16llx %s%s', 0aH, 00H
$SG159431 DB	'pttrace.c', 00H
_DATA	ENDS
voltbl	SEGMENT
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:ptt_timeout
	DD	016H
	DD	01efH
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:ptt_pthread_print
	DD	013H
	DD	0542H
voltbl	ENDS
xdata	SEGMENT
$unwind$ptt_trace_init DD 010c01H
	DD	0620cH
$unwind$ptt_cmd DD 021501H
	DD	0130115H
$unwind$ptt_pthread_trace DD 011801H
	DD	08218H
$unwind$ptt_pthread_print DD 031b19H
	DD	02e0109H
	DD	07002H
	DD	imagerel __GSHandlerCheck
	DD	0168H
$unwind$pttcl_byname DD 010e01H
	DD	0620eH
$unwind$pttcl_all DD 010e01H
	DD	0820eH
$unwind$ptt_showparms DD 020701H
	DD	0150107H
$unwind$ptt_timeout DD 021b19H
	DD	011010cH
	DD	imagerel __GSHandlerCheck
	DD	078H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$sscanf DD 011801H
	DD	06218H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$_vsscanf_l DD 011801H
	DD	06218H
xdata	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\pttrace.c
_TEXT	SEGMENT
tv73 = 80
tv78 = 84
tv139 = 88
tv144 = 92
now$ = 96
tm$ = 104
__$ArrayPad$ = 120
arg$ = 144
ptt_timeout PROC

; 209  : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 81 ec 88 00
	00 00		 sub	 rsp, 136		; 00000088H
  0000c	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00013	48 33 c4	 xor	 rax, rsp
  00016	48 89 44 24 78	 mov	 QWORD PTR __$ArrayPad$[rsp], rax
$LN4@ptt_timeou:

; 210  :     static const char* thread_name = "ptt_timeout";
; 211  :     struct timeval  now;
; 212  :     struct timespec tm;
; 213  : 
; 214  :     UNREFERENCED( arg );

  0001b	33 c0		 xor	 eax, eax
  0001d	85 c0		 test	 eax, eax
  0001f	75 fa		 jne	 SHORT $LN4@ptt_timeou
$LN7@ptt_timeou:

; 215  : 
; 216  :     SET_THREAD_NAME( thread_name );

  00021	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_GetCurrentThreadId
  00027	48 8b 15 00 00
	00 00		 mov	 rdx, QWORD PTR ?thread_name@?1??ptt_timeout@@9@9
  0002e	8b c8		 mov	 ecx, eax
  00030	e8 00 00 00 00	 call	 w32_set_thread_name
  00035	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_GetCurrentThreadId
  0003b	48 8b 15 00 00
	00 00		 mov	 rdx, QWORD PTR ?thread_name@?1??ptt_timeout@@9@9
  00042	8b c8		 mov	 ecx, eax
  00044	e8 00 00 00 00	 call	 hthread_set_thread_name
  00049	33 c0		 xor	 eax, eax
  0004b	85 c0		 test	 eax, eax
  0004d	75 d2		 jne	 SHORT $LN7@ptt_timeou

; 217  : 
; 218  :     // "Thread id "TIDPAT", prio %2d, name %s started"
; 219  :     LOG_THREAD_BEGIN( thread_name  );

  0004f	e8 00 00 00 00	 call	 fthread_self
  00054	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG159176
  0005b	8b c8		 mov	 ecx, eax
  0005d	e8 00 00 00 00	 call	 hthread_get_thread_prio
  00062	89 44 24 50	 mov	 DWORD PTR tv73[rsp], eax
  00066	e8 00 00 00 00	 call	 fthread_self
  0006b	89 44 24 54	 mov	 DWORD PTR tv78[rsp], eax
  0006f	b9 01 00 00 00	 mov	 ecx, 1
  00074	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  0007a	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR ?thread_name@?1??ptt_timeout@@9@9
  00081	48 89 4c 24 48	 mov	 QWORD PTR [rsp+72], rcx
  00086	8b 4c 24 50	 mov	 ecx, DWORD PTR tv73[rsp]
  0008a	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  0008e	8b 4c 24 54	 mov	 ecx, DWORD PTR tv78[rsp]
  00092	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  00096	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159177
  0009d	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  000a2	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159178
  000a9	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  000ae	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  000b3	41 b9 03 00 00
	00		 mov	 r9d, 3
  000b9	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG159179
  000c0	ba db 00 00 00	 mov	 edx, 219		; 000000dbH
  000c5	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159180
  000cc	e8 00 00 00 00	 call	 fwritemsg

; 220  : 
; 221  :     hthread_mutex_lock( &ptttolock );

  000d1	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:ptttolock
  000d8	e8 00 00 00 00	 call	 fthread_mutex_lock

; 222  : 
; 223  :     /* Wait for timeout period to expire */
; 224  :     gettimeofday( &now, NULL );

  000dd	33 d2		 xor	 edx, edx
  000df	48 8d 4c 24 60	 lea	 rcx, QWORD PTR now$[rsp]
  000e4	e8 00 00 00 00	 call	 gettimeofday

; 225  :     tm.tv_sec = now.tv_sec + pttto;

  000e9	8b 05 00 00 00
	00		 mov	 eax, DWORD PTR pttto
  000ef	8b 4c 24 60	 mov	 ecx, DWORD PTR now$[rsp]
  000f3	03 c8		 add	 ecx, eax
  000f5	8b c1		 mov	 eax, ecx
  000f7	48 98		 cdqe
  000f9	48 89 44 24 68	 mov	 QWORD PTR tm$[rsp], rax

; 226  :     tm.tv_nsec = now.tv_usec * 1000;

  000fe	69 44 24 64 e8
	03 00 00	 imul	 eax, DWORD PTR now$[rsp+4], 1000 ; 000003e8H
  00106	89 44 24 70	 mov	 DWORD PTR tm$[rsp+8], eax

; 227  :     hthread_cond_timedwait( &ptttocond, &ptttolock, &tm );

  0010a	4c 8d 44 24 68	 lea	 r8, QWORD PTR tm$[rsp]
  0010f	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:ptttolock
  00116	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:ptttocond
  0011d	e8 00 00 00 00	 call	 fthread_cond_timedwait

; 228  : 
; 229  :     /* Print the trace table automatically */
; 230  :     if (hthread_equal( thread_id(), ptttotid ))

  00122	e8 00 00 00 00	 call	 fthread_self
  00127	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ptttotid
  0012d	8b c8		 mov	 ecx, eax
  0012f	e8 00 00 00 00	 call	 fthread_equal
  00134	85 c0		 test	 eax, eax
  00136	74 27		 je	 SHORT $LN8@ptt_timeou

; 231  :     {
; 232  :         /* Show the parameters both before and after the table dump */
; 233  :         ptt_showparms();

  00138	e8 00 00 00 00	 call	 ptt_showparms

; 234  :         if (ptt_pthread_print() > 0)

  0013d	e8 00 00 00 00	 call	 ptt_pthread_print
  00142	85 c0		 test	 eax, eax
  00144	7e 05		 jle	 SHORT $LN9@ptt_timeou

; 235  :             ptt_showparms();

  00146	e8 00 00 00 00	 call	 ptt_showparms
$LN9@ptt_timeou:

; 236  :         pttto = 0;

  0014b	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR pttto, 0

; 237  :         ptttotid = 0;

  00155	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR ptttotid, 0
$LN8@ptt_timeou:

; 238  :     }
; 239  : 
; 240  :     hthread_mutex_unlock( &ptttolock );

  0015f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:ptttolock
  00166	e8 00 00 00 00	 call	 fthread_mutex_unlock

; 241  : 
; 242  :     // "Thread id "TIDPAT", prio %2d, name %s ended"
; 243  :     LOG_THREAD_END( thread_name  );

  0016b	e8 00 00 00 00	 call	 fthread_self
  00170	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG159183
  00177	8b c8		 mov	 ecx, eax
  00179	e8 00 00 00 00	 call	 hthread_get_thread_prio
  0017e	89 44 24 58	 mov	 DWORD PTR tv139[rsp], eax
  00182	e8 00 00 00 00	 call	 fthread_self
  00187	89 44 24 5c	 mov	 DWORD PTR tv144[rsp], eax
  0018b	b9 01 00 00 00	 mov	 ecx, 1
  00190	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  00196	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR ?thread_name@?1??ptt_timeout@@9@9
  0019d	48 89 4c 24 48	 mov	 QWORD PTR [rsp+72], rcx
  001a2	8b 4c 24 58	 mov	 ecx, DWORD PTR tv139[rsp]
  001a6	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  001aa	8b 4c 24 5c	 mov	 ecx, DWORD PTR tv144[rsp]
  001ae	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  001b2	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159184
  001b9	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  001be	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159185
  001c5	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  001ca	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  001cf	41 b9 03 00 00
	00		 mov	 r9d, 3
  001d5	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG159186
  001dc	ba f3 00 00 00	 mov	 edx, 243		; 000000f3H
  001e1	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159187
  001e8	e8 00 00 00 00	 call	 fwritemsg

; 244  : 
; 245  :     return NULL;

  001ed	33 c0		 xor	 eax, eax

; 246  : }

  001ef	48 8b 4c 24 78	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  001f4	48 33 cc	 xor	 rcx, rsp
  001f7	e8 00 00 00 00	 call	 __security_check_cookie
  001fc	48 81 c4 88 00
	00 00		 add	 rsp, 136		; 00000088H
  00203	c3		 ret	 0
ptt_timeout ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\pttrace.c
_TEXT	SEGMENT
tv71 = 112
str$ = 120
tv73 = 128
tv76 = 136
tv79 = 144
tv82 = 152
ptt_showparms PROC

; 181  : {

  00000	48 81 ec a8 00
	00 00		 sub	 rsp, 168		; 000000a8H

; 182  :     char* str = NULL;   /* PTT trace classes that are active. */

  00007	48 c7 44 24 78
	00 00 00 00	 mov	 QWORD PTR str$[rsp], 0

; 183  : 
; 184  :     /* Build string identifying trace classes that are active */
; 185  :     pttcl_all( pttclass, &str );

  00010	48 8d 54 24 78	 lea	 rdx, QWORD PTR str$[rsp]
  00015	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR pttclass
  0001c	e8 00 00 00 00	 call	 pttcl_all

; 186  : 
; 187  :     if (str)

  00021	48 83 7c 24 78
	00		 cmp	 QWORD PTR str$[rsp], 0
  00027	0f 84 62 01 00
	00		 je	 $LN2@ptt_showpa

; 188  :     {
; 189  :         // "Pttrace: %s %s %s %s %s to=%d %d"
; 190  :         WRMSG

  0002d	0f b6 05 00 00
	00 00		 movzx	 eax, BYTE PTR pttdtax
  00034	85 c0		 test	 eax, eax
  00036	75 0a		 jne	 SHORT $LN4@ptt_showpa
  00038	c7 44 24 70 01
	00 00 00	 mov	 DWORD PTR tv71[rsp], 1
  00040	eb 08		 jmp	 SHORT $LN5@ptt_showpa
$LN4@ptt_showpa:
  00042	c7 44 24 70 00
	00 00 00	 mov	 DWORD PTR tv71[rsp], 0
$LN5@ptt_showpa:
  0004a	83 7c 24 70 00	 cmp	 DWORD PTR tv71[rsp], 0
  0004f	74 11		 je	 SHORT $LN6@ptt_showpa
  00051	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG159143
  00058	48 89 84 24 80
	00 00 00	 mov	 QWORD PTR tv73[rsp], rax
  00060	eb 0f		 jmp	 SHORT $LN7@ptt_showpa
$LN6@ptt_showpa:
  00062	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG159144
  00069	48 89 84 24 80
	00 00 00	 mov	 QWORD PTR tv73[rsp], rax
$LN7@ptt_showpa:
  00071	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR pttnowrap, 0
  00078	74 11		 je	 SHORT $LN8@ptt_showpa
  0007a	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG159145
  00081	48 89 84 24 88
	00 00 00	 mov	 QWORD PTR tv76[rsp], rax
  00089	eb 0f		 jmp	 SHORT $LN9@ptt_showpa
$LN8@ptt_showpa:
  0008b	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG159146
  00092	48 89 84 24 88
	00 00 00	 mov	 QWORD PTR tv76[rsp], rax
$LN9@ptt_showpa:
  0009a	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR pttnotod, 0
  000a1	74 11		 je	 SHORT $LN10@ptt_showpa
  000a3	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG159147
  000aa	48 89 84 24 90
	00 00 00	 mov	 QWORD PTR tv79[rsp], rax
  000b2	eb 0f		 jmp	 SHORT $LN11@ptt_showpa
$LN10@ptt_showpa:
  000b4	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG159148
  000bb	48 89 84 24 90
	00 00 00	 mov	 QWORD PTR tv79[rsp], rax
$LN11@ptt_showpa:
  000c3	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR pttnolock, 0
  000ca	74 11		 je	 SHORT $LN12@ptt_showpa
  000cc	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG159149
  000d3	48 89 84 24 98
	00 00 00	 mov	 QWORD PTR tv82[rsp], rax
  000db	eb 0f		 jmp	 SHORT $LN13@ptt_showpa
$LN12@ptt_showpa:
  000dd	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG159150
  000e4	48 89 84 24 98
	00 00 00	 mov	 QWORD PTR tv82[rsp], rax
$LN13@ptt_showpa:
  000ec	b9 01 00 00 00	 mov	 ecx, 1
  000f1	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  000f7	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR pttracen
  000fd	89 4c 24 68	 mov	 DWORD PTR [rsp+104], ecx
  00101	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR pttto
  00107	89 4c 24 60	 mov	 DWORD PTR [rsp+96], ecx
  0010b	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR tv73[rsp]
  00113	48 89 4c 24 58	 mov	 QWORD PTR [rsp+88], rcx
  00118	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR tv76[rsp]
  00120	48 89 4c 24 50	 mov	 QWORD PTR [rsp+80], rcx
  00125	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR tv79[rsp]
  0012d	48 89 4c 24 48	 mov	 QWORD PTR [rsp+72], rcx
  00132	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR tv82[rsp]
  0013a	48 89 4c 24 40	 mov	 QWORD PTR [rsp+64], rcx
  0013f	48 8b 4c 24 78	 mov	 rcx, QWORD PTR str$[rsp]
  00144	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  00149	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159151
  00150	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  00155	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159152
  0015c	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00161	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00166	41 b9 03 00 00
	00		 mov	 r9d, 3
  0016c	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG159153
  00173	ba c8 00 00 00	 mov	 edx, 200		; 000000c8H
  00178	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159154
  0017f	e8 00 00 00 00	 call	 fwritemsg

; 191  :         (
; 192  :             HHC90012, "D",
; 193  :             str,
; 194  :             pttnolock ? "nolock" : "lock",
; 195  :             pttnotod  ? "notod"  : "tod",
; 196  :             pttnowrap ? "nowrap" : "wrap",
; 197  :             !pttdtax  ? "nodtax" : "dtax",
; 198  :             pttto,
; 199  :             pttracen
; 200  :         );
; 201  :         free( str );

  00184	48 8b 4c 24 78	 mov	 rcx, QWORD PTR str$[rsp]
  00189	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free
$LN2@ptt_showpa:

; 202  :     }
; 203  : }

  0018f	48 81 c4 a8 00
	00 00		 add	 rsp, 168		; 000000a8H
  00196	c3		 ret	 0
ptt_showparms ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\pttrace.c
_TEXT	SEGMENT
i$ = 32
bufsz$ = 40
sep$ = 48
trcl$ = 80
ppStr$ = 88
pttcl_all PROC

; 151  : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 152  :     /* Return string of class names corresponding to trcl. */
; 153  :     /* Bits are examined right to left (low order to high) */
; 154  :     /* Bits corresponding to unassigned classes ignored.   */
; 155  :     /* CALLER responsible for freeing returned *ppStr buf. */
; 156  :     size_t i, sep = 0, bufsz = 1;

  0000e	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR sep$[rsp], 0
  00017	48 c7 44 24 28
	01 00 00 00	 mov	 QWORD PTR bufsz$[rsp], 1

; 157  :     if (*ppStr) free(*ppStr);

  00020	48 8b 44 24 58	 mov	 rax, QWORD PTR ppStr$[rsp]
  00025	48 83 38 00	 cmp	 QWORD PTR [rax], 0
  00029	74 0e		 je	 SHORT $LN5@pttcl_all
  0002b	48 8b 44 24 58	 mov	 rax, QWORD PTR ppStr$[rsp]
  00030	48 8b 08	 mov	 rcx, QWORD PTR [rax]
  00033	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free
$LN5@pttcl_all:

; 158  :     if ((*ppStr = malloc( bufsz )) != NULL)

  00039	48 8b 4c 24 28	 mov	 rcx, QWORD PTR bufsz$[rsp]
  0003e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_malloc
  00044	48 8b 4c 24 58	 mov	 rcx, QWORD PTR ppStr$[rsp]
  00049	48 89 01	 mov	 QWORD PTR [rcx], rax
  0004c	48 8b 44 24 58	 mov	 rax, QWORD PTR ppStr$[rsp]
  00051	48 83 38 00	 cmp	 QWORD PTR [rax], 0
  00055	0f 84 16 01 00
	00		 je	 $LN6@pttcl_all

; 159  :     {
; 160  :         **ppStr = 0; /* start with empty string */

  0005b	48 8b 44 24 58	 mov	 rax, QWORD PTR ppStr$[rsp]
  00060	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00063	c6 00 00	 mov	 BYTE PTR [rax], 0

; 161  :         for (i=0; i < _countof( pttcltab ) && !pttcltab[i].alias; i++)

  00066	48 c7 44 24 20
	00 00 00 00	 mov	 QWORD PTR i$[rsp], 0
  0006f	eb 0d		 jmp	 SHORT $LN4@pttcl_all
$LN2@pttcl_all:
  00071	48 8b 44 24 20	 mov	 rax, QWORD PTR i$[rsp]
  00076	48 ff c0	 inc	 rax
  00079	48 89 44 24 20	 mov	 QWORD PTR i$[rsp], rax
$LN4@pttcl_all:
  0007e	48 83 7c 24 20
	17		 cmp	 QWORD PTR i$[rsp], 23
  00084	0f 83 e7 00 00
	00		 jae	 $LN3@pttcl_all
  0008a	48 6b 44 24 20
	18		 imul	 rax, QWORD PTR i$[rsp], 24
  00090	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:pttcltab
  00097	83 7c 01 10 00	 cmp	 DWORD PTR [rcx+rax+16], 0
  0009c	0f 85 cf 00 00
	00		 jne	 $LN3@pttcl_all

; 162  :         {
; 163  :             if (!(trcl & pttcltab[i].trcl))

  000a2	48 6b 44 24 20
	18		 imul	 rax, QWORD PTR i$[rsp], 24
  000a8	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:pttcltab
  000af	48 8b 44 01 08	 mov	 rax, QWORD PTR [rcx+rax+8]
  000b4	48 8b 4c 24 50	 mov	 rcx, QWORD PTR trcl$[rsp]
  000b9	48 23 c8	 and	 rcx, rax
  000bc	48 8b c1	 mov	 rax, rcx
  000bf	48 85 c0	 test	 rax, rax
  000c2	75 02		 jne	 SHORT $LN7@pttcl_all

; 164  :                 continue;

  000c4	eb ab		 jmp	 SHORT $LN2@pttcl_all
$LN7@pttcl_all:

; 165  :             bufsz += sep + strlen( pttcltab[i].name );

  000c6	48 6b 44 24 20
	18		 imul	 rax, QWORD PTR i$[rsp], 24
  000cc	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:pttcltab
  000d3	48 8b 0c 01	 mov	 rcx, QWORD PTR [rcx+rax]
  000d7	e8 00 00 00 00	 call	 strlen
  000dc	48 8b 4c 24 30	 mov	 rcx, QWORD PTR sep$[rsp]
  000e1	48 03 c8	 add	 rcx, rax
  000e4	48 8b c1	 mov	 rax, rcx
  000e7	48 8b 4c 24 28	 mov	 rcx, QWORD PTR bufsz$[rsp]
  000ec	48 03 c8	 add	 rcx, rax
  000ef	48 8b c1	 mov	 rax, rcx
  000f2	48 89 44 24 28	 mov	 QWORD PTR bufsz$[rsp], rax

; 166  :             if (!(*ppStr = realloc( *ppStr, bufsz )))

  000f7	48 8b 54 24 28	 mov	 rdx, QWORD PTR bufsz$[rsp]
  000fc	48 8b 44 24 58	 mov	 rax, QWORD PTR ppStr$[rsp]
  00101	48 8b 08	 mov	 rcx, QWORD PTR [rax]
  00104	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_realloc
  0010a	48 8b 4c 24 58	 mov	 rcx, QWORD PTR ppStr$[rsp]
  0010f	48 89 01	 mov	 QWORD PTR [rcx], rax
  00112	48 8b 44 24 58	 mov	 rax, QWORD PTR ppStr$[rsp]
  00117	48 83 38 00	 cmp	 QWORD PTR [rax], 0
  0011b	75 02		 jne	 SHORT $LN8@pttcl_all

; 167  :                 break;

  0011d	eb 52		 jmp	 SHORT $LN3@pttcl_all
$LN8@pttcl_all:

; 168  :             if (sep)

  0011f	48 83 7c 24 30
	00		 cmp	 QWORD PTR sep$[rsp], 0
  00125	74 19		 je	 SHORT $LN9@pttcl_all

; 169  :                 strlcat( *ppStr, " ", bufsz );

  00127	4c 8b 44 24 28	 mov	 r8, QWORD PTR bufsz$[rsp]
  0012c	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG159136
  00133	48 8b 44 24 58	 mov	 rax, QWORD PTR ppStr$[rsp]
  00138	48 8b 08	 mov	 rcx, QWORD PTR [rax]
  0013b	e8 00 00 00 00	 call	 strlcat
$LN9@pttcl_all:

; 170  :             strlcat( *ppStr, pttcltab[i].name, bufsz );

  00140	48 6b 44 24 20
	18		 imul	 rax, QWORD PTR i$[rsp], 24
  00146	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:pttcltab
  0014d	4c 8b 44 24 28	 mov	 r8, QWORD PTR bufsz$[rsp]
  00152	48 8b 14 01	 mov	 rdx, QWORD PTR [rcx+rax]
  00156	48 8b 44 24 58	 mov	 rax, QWORD PTR ppStr$[rsp]
  0015b	48 8b 08	 mov	 rcx, QWORD PTR [rax]
  0015e	e8 00 00 00 00	 call	 strlcat

; 171  :             sep = 1;

  00163	48 c7 44 24 30
	01 00 00 00	 mov	 QWORD PTR sep$[rsp], 1

; 172  :         }

  0016c	e9 00 ff ff ff	 jmp	 $LN2@pttcl_all
$LN3@pttcl_all:
$LN6@pttcl_all:

; 173  :     }
; 174  :     return *ppStr;

  00171	48 8b 44 24 58	 mov	 rax, QWORD PTR ppStr$[rsp]
  00176	48 8b 00	 mov	 rax, QWORD PTR [rax]

; 175  : }

  00179	48 83 c4 48	 add	 rsp, 72			; 00000048H
  0017d	c3		 ret	 0
pttcl_all ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\pttrace.c
_TEXT	SEGMENT
tv72 = 32
i$ = 40
name$ = 64
no$ = 72
pttcl_byname PROC

; 123  : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 124  :     /* Return class table entry matching "[no]name" or NULL. */
; 125  :     /* "no" flag set on return indicates match on "[no]name" */
; 126  :     size_t i;
; 127  :     *no = (strlen(name) > 2 && strncasecmp(name, "no", 2) == 0);

  0000e	48 8b 4c 24 40	 mov	 rcx, QWORD PTR name$[rsp]
  00013	e8 00 00 00 00	 call	 strlen
  00018	48 83 f8 02	 cmp	 rax, 2
  0001c	76 26		 jbe	 SHORT $LN8@pttcl_byna
  0001e	41 b8 02 00 00
	00		 mov	 r8d, 2
  00024	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG159114
  0002b	48 8b 4c 24 40	 mov	 rcx, QWORD PTR name$[rsp]
  00030	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__strnicmp
  00036	85 c0		 test	 eax, eax
  00038	75 0a		 jne	 SHORT $LN8@pttcl_byna
  0003a	c7 44 24 20 01
	00 00 00	 mov	 DWORD PTR tv72[rsp], 1
  00042	eb 08		 jmp	 SHORT $LN9@pttcl_byna
$LN8@pttcl_byna:
  00044	c7 44 24 20 00
	00 00 00	 mov	 DWORD PTR tv72[rsp], 0
$LN9@pttcl_byna:
  0004c	48 8b 44 24 48	 mov	 rax, QWORD PTR no$[rsp]
  00051	8b 4c 24 20	 mov	 ecx, DWORD PTR tv72[rsp]
  00055	89 08		 mov	 DWORD PTR [rax], ecx

; 128  :     if (*no) name += 2;

  00057	48 8b 44 24 48	 mov	 rax, QWORD PTR no$[rsp]
  0005c	83 38 00	 cmp	 DWORD PTR [rax], 0
  0005f	74 0e		 je	 SHORT $LN5@pttcl_byna
  00061	48 8b 44 24 40	 mov	 rax, QWORD PTR name$[rsp]
  00066	48 83 c0 02	 add	 rax, 2
  0006a	48 89 44 24 40	 mov	 QWORD PTR name$[rsp], rax
$LN5@pttcl_byna:

; 129  :     for (i=0; i < _countof( pttcltab ); i++)

  0006f	48 c7 44 24 28
	00 00 00 00	 mov	 QWORD PTR i$[rsp], 0
  00078	eb 0d		 jmp	 SHORT $LN4@pttcl_byna
$LN2@pttcl_byna:
  0007a	48 8b 44 24 28	 mov	 rax, QWORD PTR i$[rsp]
  0007f	48 ff c0	 inc	 rax
  00082	48 89 44 24 28	 mov	 QWORD PTR i$[rsp], rax
$LN4@pttcl_byna:
  00087	48 83 7c 24 28
	17		 cmp	 QWORD PTR i$[rsp], 23
  0008d	73 37		 jae	 SHORT $LN3@pttcl_byna

; 130  :         if (strcasecmp( pttcltab[i].name, name ) == 0)

  0008f	48 6b 44 24 28
	18		 imul	 rax, QWORD PTR i$[rsp], 24
  00095	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:pttcltab
  0009c	48 8b 54 24 40	 mov	 rdx, QWORD PTR name$[rsp]
  000a1	48 8b 0c 01	 mov	 rcx, QWORD PTR [rcx+rax]
  000a5	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__stricmp
  000ab	85 c0		 test	 eax, eax
  000ad	75 15		 jne	 SHORT $LN6@pttcl_byna

; 131  :             return &pttcltab[i];

  000af	48 6b 44 24 28
	18		 imul	 rax, QWORD PTR i$[rsp], 24
  000b5	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:pttcltab
  000bc	48 03 c8	 add	 rcx, rax
  000bf	48 8b c1	 mov	 rax, rcx
  000c2	eb 04		 jmp	 SHORT $LN1@pttcl_byna
$LN6@pttcl_byna:
  000c4	eb b4		 jmp	 SHORT $LN2@pttcl_byna
$LN3@pttcl_byna:

; 132  :     return NULL;

  000c6	33 c0		 xor	 eax, eax
$LN1@pttcl_byna:

; 133  : }

  000c8	48 83 c4 38	 add	 rsp, 56			; 00000038H
  000cc	c3		 ret	 0
pttcl_byname ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\pttrace.c
_TEXT	SEGMENT
ptt_dtax PROC

; 253  :     return pttdtax; // Dump Table At Exit

  00000	0f b6 05 00 00
	00 00		 movzx	 eax, BYTE PTR pttdtax

; 254  : }

  00007	c3		 ret	 0
ptt_dtax ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\pttrace.c
_TEXT	SEGMENT
i$ = 128
n$ = 132
count$ = 136
rc$1 = 140
rc$2 = 144
$T3 = 152
tv168 = 160
lname$4 = 168
tv175 = 176
$T5 = 184
tv194 = 192
tv199 = 200
tv204 = 208
tv209 = 216
tv215 = 224
tv220 = 232
tv238 = 240
retcode$ = 248
threadname$6 = 280
lockname$7 = 296
tod$ = 328
__$ArrayPad$ = 360
ptt_pthread_print PROC

; 511  : {

$LN32:
  00000	40 57		 push	 rdi
  00002	48 81 ec 70 01
	00 00		 sub	 rsp, 368		; 00000170H
  00009	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00010	48 33 c4	 xor	 rax, rsp
  00013	48 89 84 24 68
	01 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 512  : int   i, n, count = 0;

  0001b	c7 84 24 88 00
	00 00 00 00 00
	00		 mov	 DWORD PTR count$[rsp], 0

; 513  : char  retcode[32]; // (retcode is 'int'; if x64, 19 digits or more!)
; 514  : char  tod[27];     // "YYYY-MM-DD HH:MM:SS.uuuuuu"
; 515  : 
; 516  :     if (pttrace && pttracen)

  00026	48 83 3d 00 00
	00 00 00	 cmp	 QWORD PTR pttrace, 0
  0002e	0f 84 07 05 00
	00		 je	 $LN11@ptt_pthrea
  00034	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR pttracen, 0
  0003b	0f 84 fa 04 00
	00		 je	 $LN11@ptt_pthrea
$LN4@ptt_pthrea:

; 517  :     {
; 518  :         /* Temporarily disable tracing by indicating an empty table */
; 519  :         OBTAIN_PTTLOCK;

  00041	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR pttnolock, 0
  00048	75 1e		 jne	 SHORT $LN12@ptt_pthrea
  0004a	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:pttlock
  00051	e8 00 00 00 00	 call	 fthread_mutex_lock
  00056	89 84 24 8c 00
	00 00		 mov	 DWORD PTR rc$1[rsp], eax
  0005d	83 bc 24 8c 00
	00 00 00	 cmp	 DWORD PTR rc$1[rsp], 0
  00065	74 01		 je	 SHORT $LN13@ptt_pthrea
  00067	cc		 int	 3
$LN13@ptt_pthrea:
$LN12@ptt_pthrea:
  00068	33 c0		 xor	 eax, eax
  0006a	85 c0		 test	 eax, eax
  0006c	75 d3		 jne	 SHORT $LN4@ptt_pthrea

; 520  :         n = pttracen;       /* save number of trace table entries   */

  0006e	8b 05 00 00 00
	00		 mov	 eax, DWORD PTR pttracen
  00074	89 84 24 84 00
	00 00		 mov	 DWORD PTR n$[rsp], eax

; 521  :         pttracen = 0;       /* indicate empty table to stop tracing */

  0007b	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR pttracen, 0
$LN7@ptt_pthrea:

; 522  :         RELEASE_PTTLOCK;

  00085	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR pttnolock, 0
  0008c	75 1e		 jne	 SHORT $LN14@ptt_pthrea
  0008e	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:pttlock
  00095	e8 00 00 00 00	 call	 fthread_mutex_unlock
  0009a	89 84 24 90 00
	00 00		 mov	 DWORD PTR rc$2[rsp], eax
  000a1	83 bc 24 90 00
	00 00 00	 cmp	 DWORD PTR rc$2[rsp], 0
  000a9	74 01		 je	 SHORT $LN15@ptt_pthrea
  000ab	cc		 int	 3
$LN15@ptt_pthrea:
$LN14@ptt_pthrea:
  000ac	33 c0		 xor	 eax, eax
  000ae	85 c0		 test	 eax, eax
  000b0	75 d3		 jne	 SHORT $LN7@ptt_pthrea

; 523  : 
; 524  :         /* Print the trace table */
; 525  :         i = pttracex;

  000b2	8b 05 00 00 00
	00		 mov	 eax, DWORD PTR pttracex
  000b8	89 84 24 80 00
	00 00		 mov	 DWORD PTR i$[rsp], eax
$LN10@ptt_pthrea:

; 526  :         do
; 527  :         {
; 528  :             if (pttrace[i].tid)

  000bf	48 63 84 24 80
	00 00 00	 movsxd	 rax, DWORD PTR i$[rsp]
  000c7	48 6b c0 40	 imul	 rax, rax, 64		; 00000040H
  000cb	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR pttrace
  000d2	83 3c 01 00	 cmp	 DWORD PTR [rcx+rax], 0
  000d6	0f 84 e3 03 00
	00		 je	 $LN16@ptt_pthrea

; 529  :             {
; 530  :                 char threadname[16];
; 531  :                 char lockname[32];
; 532  :                 const char* lname;
; 533  : 
; 534  :                 FormatTIMEVAL( &pttrace[i].tv, tod, sizeof( tod ));

  000dc	48 63 84 24 80
	00 00 00	 movsxd	 rax, DWORD PTR i$[rsp]
  000e4	48 6b c0 40	 imul	 rax, rax, 64		; 00000040H
  000e8	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR pttrace
  000ef	48 8d 44 01 30	 lea	 rax, QWORD PTR [rcx+rax+48]
  000f4	41 b8 1b 00 00
	00		 mov	 r8d, 27
  000fa	48 8d 94 24 48
	01 00 00	 lea	 rdx, QWORD PTR tod$[rsp]
  00102	48 8b c8	 mov	 rcx, rax
  00105	e8 00 00 00 00	 call	 FormatTIMEVAL

; 535  :                 get_thread_name( pttrace[i].tid, threadname );

  0010a	48 63 84 24 80
	00 00 00	 movsxd	 rax, DWORD PTR i$[rsp]
  00112	48 6b c0 40	 imul	 rax, rax, 64		; 00000040H
  00116	48 8d 94 24 18
	01 00 00	 lea	 rdx, QWORD PTR threadname$6[rsp]
  0011e	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR pttrace
  00125	8b 0c 01	 mov	 ecx, DWORD PTR [rcx+rax]
  00128	e8 00 00 00 00	 call	 hthread_get_thread_name

; 536  : 
; 537  :                 if (pttrace[i].trclass & PTT_CL_THR)

  0012d	48 63 84 24 80
	00 00 00	 movsxd	 rax, DWORD PTR i$[rsp]
  00135	48 6b c0 40	 imul	 rax, rax, 64		; 00000040H
  00139	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR pttrace
  00140	48 8b 44 01 08	 mov	 rax, QWORD PTR [rcx+rax+8]
  00145	48 83 e0 04	 and	 rax, 4
  00149	48 85 c0	 test	 rax, rax
  0014c	0f 84 83 00 00
	00		 je	 $LN17@ptt_pthrea

; 538  :                 {
; 539  :                     /* For the thread class, an 'rc' of PTT_MAGIC
; 540  :                        indicates its value is uninteresting to us,
; 541  :                        so we don't bother showing it. Otherwise we
; 542  :                        format it as a +/- decimal value.
; 543  :                     */
; 544  :                     if (pttrace[i].rc == PTT_MAGIC)

  00152	48 63 84 24 80
	00 00 00	 movsxd	 rax, DWORD PTR i$[rsp]
  0015a	48 6b c0 40	 imul	 rax, rax, 64		; 00000040H
  0015e	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR pttrace
  00165	48 83 7c 01 38
	9d		 cmp	 QWORD PTR [rcx+rax+56], -99 ; ffffffffffffff9dH
  0016b	75 35		 jne	 SHORT $LN19@ptt_pthrea

; 545  :                         retcode[0] = 0;

  0016d	b8 01 00 00 00	 mov	 eax, 1
  00172	48 6b c0 00	 imul	 rax, rax, 0
  00176	48 89 84 24 98
	00 00 00	 mov	 QWORD PTR $T3[rsp], rax
  0017e	48 83 bc 24 98
	00 00 00 20	 cmp	 QWORD PTR $T3[rsp], 32	; 00000020H
  00187	73 02		 jae	 SHORT $LN24@ptt_pthrea
  00189	eb 05		 jmp	 SHORT $LN25@ptt_pthrea
$LN24@ptt_pthrea:
  0018b	e8 00 00 00 00	 call	 __report_rangecheckfailure
$LN25@ptt_pthrea:
  00190	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR $T3[rsp]
  00198	c6 84 04 f8 00
	00 00 00	 mov	 BYTE PTR retcode$[rsp+rax], 0
  001a0	eb 31		 jmp	 SHORT $LN20@ptt_pthrea
$LN19@ptt_pthrea:

; 546  :                     else
; 547  :                         MSGBUF( retcode, "%"PRId64, pttrace[i].rc );

  001a2	48 63 84 24 80
	00 00 00	 movsxd	 rax, DWORD PTR i$[rsp]
  001aa	48 6b c0 40	 imul	 rax, rax, 64		; 00000040H
  001ae	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR pttrace
  001b5	4c 8b 4c 01 38	 mov	 r9, QWORD PTR [rcx+rax+56]
  001ba	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG159421
  001c1	ba 20 00 00 00	 mov	 edx, 32			; 00000020H
  001c6	48 8d 8c 24 f8
	00 00 00	 lea	 rcx, QWORD PTR retcode$[rsp]
  001ce	e8 00 00 00 00	 call	 w32_snprintf
$LN20@ptt_pthrea:

; 548  :                 }

  001d3	eb 31		 jmp	 SHORT $LN18@ptt_pthrea
$LN17@ptt_pthrea:

; 549  :                 else
; 550  :                 {
; 551  :                     /* Not thread class: format return code
; 552  :                        as just another 64-bit hex value.
; 553  :                     */
; 554  :                     MSGBUF( retcode, "%16.16"PRIx64, pttrace[i].rc );

  001d5	48 63 84 24 80
	00 00 00	 movsxd	 rax, DWORD PTR i$[rsp]
  001dd	48 6b c0 40	 imul	 rax, rax, 64		; 00000040H
  001e1	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR pttrace
  001e8	4c 8b 4c 01 38	 mov	 r9, QWORD PTR [rcx+rax+56]
  001ed	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG159422
  001f4	ba 20 00 00 00	 mov	 edx, 32			; 00000020H
  001f9	48 8d 8c 24 f8
	00 00 00	 lea	 rcx, QWORD PTR retcode$[rsp]
  00201	e8 00 00 00 00	 call	 w32_snprintf
$LN18@ptt_pthrea:

; 555  :                 }
; 556  : 
; 557  :                 /* If this is the thread class we know the data1 value
; 558  :                    is USUALLY the address of the lock identifying which
; 559  :                    lock was being obtained/released, so as a courtesy
; 560  :                    we display its name after the message.  This might
; 561  :                    not always work as the data1 value for SOME thread
; 562  :                    trace entries might be NULL or be some other value.
; 563  :                 */
; 564  :                 lname = (pttrace[i].trclass & PTT_CL_THR) ?

  00206	48 63 84 24 80
	00 00 00	 movsxd	 rax, DWORD PTR i$[rsp]
  0020e	48 6b c0 40	 imul	 rax, rax, 64		; 00000040H
  00212	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR pttrace
  00219	48 8b 44 01 08	 mov	 rax, QWORD PTR [rcx+rax+8]
  0021e	48 83 e0 04	 and	 rax, 4
  00222	48 85 c0	 test	 rax, rax
  00225	74 27		 je	 SHORT $LN26@ptt_pthrea
  00227	48 63 84 24 80
	00 00 00	 movsxd	 rax, DWORD PTR i$[rsp]
  0022f	48 6b c0 40	 imul	 rax, rax, 64		; 00000040H
  00233	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR pttrace
  0023a	48 8b 4c 01 18	 mov	 rcx, QWORD PTR [rcx+rax+24]
  0023f	e8 00 00 00 00	 call	 hthread_get_lock_name
  00244	48 89 84 24 a0
	00 00 00	 mov	 QWORD PTR tv168[rsp], rax
  0024c	eb 0f		 jmp	 SHORT $LN27@ptt_pthrea
$LN26@ptt_pthrea:
  0024e	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG159423
  00255	48 89 84 24 a0
	00 00 00	 mov	 QWORD PTR tv168[rsp], rax
$LN27@ptt_pthrea:
  0025d	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR tv168[rsp]
  00265	48 89 84 24 a8
	00 00 00	 mov	 QWORD PTR lname$4[rsp], rax

; 565  :                     get_lock_name( (LOCK*) pttrace[i].data1 ) : "";
; 566  : 
; 567  :                 MSGBUF( lockname, "%s%s", lname[0] ? " " : "", lname );

  0026d	b8 01 00 00 00	 mov	 eax, 1
  00272	48 6b c0 00	 imul	 rax, rax, 0
  00276	48 8b 8c 24 a8
	00 00 00	 mov	 rcx, QWORD PTR lname$4[rsp]
  0027e	0f be 04 01	 movsx	 eax, BYTE PTR [rcx+rax]
  00282	85 c0		 test	 eax, eax
  00284	74 11		 je	 SHORT $LN28@ptt_pthrea
  00286	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG159424
  0028d	48 89 84 24 b0
	00 00 00	 mov	 QWORD PTR tv175[rsp], rax
  00295	eb 0f		 jmp	 SHORT $LN29@ptt_pthrea
$LN28@ptt_pthrea:
  00297	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG159425
  0029e	48 89 84 24 b0
	00 00 00	 mov	 QWORD PTR tv175[rsp], rax
$LN29@ptt_pthrea:
  002a6	48 8b 84 24 a8
	00 00 00	 mov	 rax, QWORD PTR lname$4[rsp]
  002ae	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  002b3	4c 8b 8c 24 b0
	00 00 00	 mov	 r9, QWORD PTR tv175[rsp]
  002bb	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG159426
  002c2	ba 20 00 00 00	 mov	 edx, 32			; 00000020H
  002c7	48 8d 8c 24 28
	01 00 00	 lea	 rcx, QWORD PTR lockname$7[rsp]
  002cf	e8 00 00 00 00	 call	 w32_snprintf

; 568  : 
; 569  :                 if (lockname[0] && !retcode[0])

  002d4	b8 01 00 00 00	 mov	 eax, 1
  002d9	48 6b c0 00	 imul	 rax, rax, 0
  002dd	0f be 84 04 28
	01 00 00	 movsx	 eax, BYTE PTR lockname$7[rsp+rax]
  002e5	85 c0		 test	 eax, eax
  002e7	74 54		 je	 SHORT $LN21@ptt_pthrea
  002e9	b8 01 00 00 00	 mov	 eax, 1
  002ee	48 6b c0 00	 imul	 rax, rax, 0
  002f2	0f be 84 04 f8
	00 00 00	 movsx	 eax, BYTE PTR retcode$[rsp+rax]
  002fa	85 c0		 test	 eax, eax
  002fc	75 3f		 jne	 SHORT $LN21@ptt_pthrea

; 570  :                     retcode[0] = ' ', retcode[1] = 0;

  002fe	b8 01 00 00 00	 mov	 eax, 1
  00303	48 6b c0 00	 imul	 rax, rax, 0
  00307	c6 84 04 f8 00
	00 00 20	 mov	 BYTE PTR retcode$[rsp+rax], 32 ; 00000020H
  0030f	48 c7 84 24 b8
	00 00 00 01 00
	00 00		 mov	 QWORD PTR $T5[rsp], 1
  0031b	48 83 bc 24 b8
	00 00 00 20	 cmp	 QWORD PTR $T5[rsp], 32	; 00000020H
  00324	73 02		 jae	 SHORT $LN30@ptt_pthrea
  00326	eb 05		 jmp	 SHORT $LN31@ptt_pthrea
$LN30@ptt_pthrea:
  00328	e8 00 00 00 00	 call	 __report_rangecheckfailure
$LN31@ptt_pthrea:
  0032d	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR $T5[rsp]
  00335	c6 84 04 f8 00
	00 00 00	 mov	 BYTE PTR retcode$[rsp+rax], 0
$LN21@ptt_pthrea:

; 571  : 
; 572  :                 // "%s "TIDPAT" %-15.15s %-18.18s %-18.18s"PTR_FMTx" "PTR_FMTx" %s%s"
; 573  :                 WRMSG( HHC90021, "D"

  0033d	48 63 84 24 80
	00 00 00	 movsxd	 rax, DWORD PTR i$[rsp]
  00345	48 6b c0 40	 imul	 rax, rax, 64		; 00000040H
  00349	48 89 84 24 c0
	00 00 00	 mov	 QWORD PTR tv194[rsp], rax
  00351	48 63 8c 24 80
	00 00 00	 movsxd	 rcx, DWORD PTR i$[rsp]
  00359	48 6b c9 40	 imul	 rcx, rcx, 64		; 00000040H
  0035d	48 89 8c 24 c8
	00 00 00	 mov	 QWORD PTR tv199[rsp], rcx
  00365	48 63 94 24 80
	00 00 00	 movsxd	 rdx, DWORD PTR i$[rsp]
  0036d	48 6b d2 40	 imul	 rdx, rdx, 64		; 00000040H
  00371	48 89 94 24 d0
	00 00 00	 mov	 QWORD PTR tv204[rsp], rdx
  00379	4c 63 84 24 80
	00 00 00	 movsxd	 r8, DWORD PTR i$[rsp]
  00381	4d 6b c0 40	 imul	 r8, r8, 64		; 00000040H
  00385	4c 89 84 24 d8
	00 00 00	 mov	 QWORD PTR tv209[rsp], r8
  0038d	4c 63 8c 24 80
	00 00 00	 movsxd	 r9, DWORD PTR i$[rsp]
  00395	4d 6b c9 40	 imul	 r9, r9, 64		; 00000040H
  00399	4c 89 8c 24 e0
	00 00 00	 mov	 QWORD PTR tv215[rsp], r9
  003a1	41 ba 01 00 00
	00		 mov	 r10d, 1
  003a7	4d 6b d2 0b	 imul	 r10, r10, 11
  003ab	4e 8d 94 14 48
	01 00 00	 lea	 r10, QWORD PTR tod$[rsp+r10]
  003b3	4c 89 94 24 e8
	00 00 00	 mov	 QWORD PTR tv220[rsp], r10
  003bb	b9 01 00 00 00	 mov	 ecx, 1
  003c0	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  003c6	48 8d 8c 24 28
	01 00 00	 lea	 rcx, QWORD PTR lockname$7[rsp]
  003ce	48 89 4c 24 78	 mov	 QWORD PTR [rsp+120], rcx
  003d3	48 8d 8c 24 f8
	00 00 00	 lea	 rcx, QWORD PTR retcode$[rsp]
  003db	48 89 4c 24 70	 mov	 QWORD PTR [rsp+112], rcx
  003e0	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR pttrace
  003e7	48 8b 94 24 c0
	00 00 00	 mov	 rdx, QWORD PTR tv194[rsp]
  003ef	48 8b 4c 11 20	 mov	 rcx, QWORD PTR [rcx+rdx+32]
  003f4	48 89 4c 24 68	 mov	 QWORD PTR [rsp+104], rcx
  003f9	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR pttrace
  00400	48 8b 94 24 c8
	00 00 00	 mov	 rdx, QWORD PTR tv199[rsp]
  00408	48 8b 4c 11 18	 mov	 rcx, QWORD PTR [rcx+rdx+24]
  0040d	48 89 4c 24 60	 mov	 QWORD PTR [rsp+96], rcx
  00412	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR pttrace
  00419	48 8b 94 24 d0
	00 00 00	 mov	 rdx, QWORD PTR tv204[rsp]
  00421	48 8b 4c 11 10	 mov	 rcx, QWORD PTR [rcx+rdx+16]
  00426	48 89 4c 24 58	 mov	 QWORD PTR [rsp+88], rcx
  0042b	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR pttrace
  00432	48 8b 94 24 d8
	00 00 00	 mov	 rdx, QWORD PTR tv209[rsp]
  0043a	48 8b 4c 11 28	 mov	 rcx, QWORD PTR [rcx+rdx+40]
  0043f	48 89 4c 24 50	 mov	 QWORD PTR [rsp+80], rcx
  00444	48 8d 8c 24 18
	01 00 00	 lea	 rcx, QWORD PTR threadname$6[rsp]
  0044c	48 89 4c 24 48	 mov	 QWORD PTR [rsp+72], rcx
  00451	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR pttrace
  00458	48 8b 94 24 e0
	00 00 00	 mov	 rdx, QWORD PTR tv215[rsp]
  00460	8b 0c 11	 mov	 ecx, DWORD PTR [rcx+rdx]
  00463	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  00467	48 8b 8c 24 e8
	00 00 00	 mov	 rcx, QWORD PTR tv220[rsp]
  0046f	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  00474	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159428
  0047b	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  00480	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159429
  00487	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  0048c	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00491	41 b9 03 00 00
	00		 mov	 r9d, 3
  00497	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG159430
  0049e	ba 47 02 00 00	 mov	 edx, 583		; 00000247H
  004a3	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159431
  004aa	e8 00 00 00 00	 call	 fwritemsg

; 574  :                     , &tod[11]                          // Time of day (HH:MM:SS.usecs)
; 575  :                     , TID_CAST( pttrace[i].tid )        // Thread id
; 576  :                     , threadname                        // Thread name
; 577  :                     , pttrace[i].loc                    // File name (string; 18 chars)
; 578  :                     , pttrace[i].msg                    // Trace message (string; 18 chars)
; 579  :                     , PTR_CAST( pttrace[i].data1 )      // Data value 1
; 580  :                     , PTR_CAST( pttrace[i].data2 )      // Data value 2
; 581  :                     , retcode                           // Return code (or empty string)
; 582  :                     , lockname                          // Lock name   (or empty string)
; 583  :                 );
; 584  : 
; 585  :                 count++;

  004af	8b 84 24 88 00
	00 00		 mov	 eax, DWORD PTR count$[rsp]
  004b6	ff c0		 inc	 eax
  004b8	89 84 24 88 00
	00 00		 mov	 DWORD PTR count$[rsp], eax
$LN16@ptt_pthrea:

; 586  :             }
; 587  :             if (++i >= n) i = 0;

  004bf	8b 84 24 80 00
	00 00		 mov	 eax, DWORD PTR i$[rsp]
  004c6	ff c0		 inc	 eax
  004c8	89 84 24 80 00
	00 00		 mov	 DWORD PTR i$[rsp], eax
  004cf	8b 84 24 84 00
	00 00		 mov	 eax, DWORD PTR n$[rsp]
  004d6	39 84 24 80 00
	00 00		 cmp	 DWORD PTR i$[rsp], eax
  004dd	7c 0b		 jl	 SHORT $LN22@ptt_pthrea
  004df	c7 84 24 80 00
	00 00 00 00 00
	00		 mov	 DWORD PTR i$[rsp], 0
$LN22@ptt_pthrea:

; 588  :         } while (i != pttracex);

  004ea	8b 05 00 00 00
	00		 mov	 eax, DWORD PTR pttracex
  004f0	39 84 24 80 00
	00 00		 cmp	 DWORD PTR i$[rsp], eax
  004f7	0f 85 c2 fb ff
	ff		 jne	 $LN10@ptt_pthrea

; 589  : 
; 590  :         /* Clear all the table entries we just printed and
; 591  :            enable tracing again starting at entry number 0.
; 592  :            NOTE: there is no need to obtain the lock since:
; 593  :            a) pttracex is never accessed unless pttracen is
; 594  :            non-zero, b) because pttracen is an int, setting
; 595  :            it to non-zero again should be atomic.
; 596  :         */
; 597  :         memset( pttrace, 0, PTT_TRACE_SIZE * n );

  004fd	48 63 84 24 84
	00 00 00	 movsxd	 rax, DWORD PTR n$[rsp]
  00505	48 6b c0 40	 imul	 rax, rax, 64		; 00000040H
  00509	48 89 84 24 f0
	00 00 00	 mov	 QWORD PTR tv238[rsp], rax
  00511	48 8b 3d 00 00
	00 00		 mov	 rdi, QWORD PTR pttrace
  00518	33 c0		 xor	 eax, eax
  0051a	48 8b 8c 24 f0
	00 00 00	 mov	 rcx, QWORD PTR tv238[rsp]
  00522	f3 aa		 rep stosb

; 598  :         pttracex = 0;

  00524	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR pttracex, 0

; 599  :         pttracen = n;

  0052e	8b 84 24 84 00
	00 00		 mov	 eax, DWORD PTR n$[rsp]
  00535	89 05 00 00 00
	00		 mov	 DWORD PTR pttracen, eax
$LN11@ptt_pthrea:

; 600  :     }
; 601  : 
; 602  :     return count;

  0053b	8b 84 24 88 00
	00 00		 mov	 eax, DWORD PTR count$[rsp]
$LN23@ptt_pthrea:

; 603  : }

  00542	48 8b 8c 24 68
	01 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  0054a	48 33 cc	 xor	 rcx, rsp
  0054d	e8 00 00 00 00	 call	 __security_check_cookie
  00552	48 81 c4 70 01
	00 00		 add	 rsp, 368		; 00000170H
  00559	5f		 pop	 rdi
  0055a	c3		 ret	 0
ptt_pthread_print ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\pttrace.c
_TEXT	SEGMENT
i$ = 32
n$ = 36
rc$1 = 40
rc$2 = 44
rc$3 = 48
trclass$ = 80
msg$ = 88
data1$ = 96
data2$ = 104
loc$ = 112
rc$ = 120
pTV$ = 128
ptt_pthread_trace PROC

; 459  : {

$LN31:
  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 460  : int i, n;
; 461  : 
; 462  :     if (pttrace == NULL || pttracen == 0 || !(pttclass & trclass)) return;

  00018	48 83 3d 00 00
	00 00 00	 cmp	 QWORD PTR pttrace, 0
  00020	74 20		 je	 SHORT $LN12@ptt_pthrea
  00022	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR pttracen, 0
  00029	74 17		 je	 SHORT $LN12@ptt_pthrea
  0002b	48 8b 44 24 50	 mov	 rax, QWORD PTR trclass$[rsp]
  00030	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR pttclass
  00037	48 23 c8	 and	 rcx, rax
  0003a	48 8b c1	 mov	 rax, rcx
  0003d	48 85 c0	 test	 rax, rax
  00040	75 05		 jne	 SHORT $LN11@ptt_pthrea
$LN12@ptt_pthrea:
  00042	e9 bd 02 00 00	 jmp	 $LN1@ptt_pthrea
$LN11@ptt_pthrea:

; 463  :     /*
; 464  :      * Messages from timer.c, clock.c and/or logger.c are not usually
; 465  :      * that interesting and take up table space.  Check the flags to
; 466  :      * see if we want to trace them.
; 467  :      */
; 468  :     loc = TRIMLOC( loc );

  00047	48 8b 4c 24 70	 mov	 rcx, QWORD PTR loc$[rsp]
  0004c	e8 00 00 00 00	 call	 trimloc
  00051	48 89 44 24 70	 mov	 QWORD PTR loc$[rsp], rax

; 469  :     if (!(pttclass & PTT_CL_TMR) && !strncasecmp( loc, "timer.c:",  8)) return;

  00056	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR pttclass
  0005d	48 83 e0 02	 and	 rax, 2
  00061	48 85 c0	 test	 rax, rax
  00064	75 21		 jne	 SHORT $LN13@ptt_pthrea
  00066	41 b8 08 00 00
	00		 mov	 r8d, 8
  0006c	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG159364
  00073	48 8b 4c 24 70	 mov	 rcx, QWORD PTR loc$[rsp]
  00078	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__strnicmp
  0007e	85 c0		 test	 eax, eax
  00080	75 05		 jne	 SHORT $LN13@ptt_pthrea
  00082	e9 7d 02 00 00	 jmp	 $LN1@ptt_pthrea
$LN13@ptt_pthrea:

; 470  :     if (!(pttclass & PTT_CL_TMR) && !strncasecmp( loc, "clock.c:",  8)) return;

  00087	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR pttclass
  0008e	48 83 e0 02	 and	 rax, 2
  00092	48 85 c0	 test	 rax, rax
  00095	75 21		 jne	 SHORT $LN14@ptt_pthrea
  00097	41 b8 08 00 00
	00		 mov	 r8d, 8
  0009d	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG159366
  000a4	48 8b 4c 24 70	 mov	 rcx, QWORD PTR loc$[rsp]
  000a9	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__strnicmp
  000af	85 c0		 test	 eax, eax
  000b1	75 05		 jne	 SHORT $LN14@ptt_pthrea
  000b3	e9 4c 02 00 00	 jmp	 $LN1@ptt_pthrea
$LN14@ptt_pthrea:

; 471  :     if (!(pttclass & PTT_CL_LOG) && !strncasecmp( loc, "logger.c:", 9)) return;

  000b8	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR pttclass
  000bf	48 83 e0 01	 and	 rax, 1
  000c3	48 85 c0	 test	 rax, rax
  000c6	75 21		 jne	 SHORT $LN15@ptt_pthrea
  000c8	41 b8 09 00 00
	00		 mov	 r8d, 9
  000ce	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG159368
  000d5	48 8b 4c 24 70	 mov	 rcx, QWORD PTR loc$[rsp]
  000da	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__strnicmp
  000e0	85 c0		 test	 eax, eax
  000e2	75 05		 jne	 SHORT $LN15@ptt_pthrea
  000e4	e9 1b 02 00 00	 jmp	 $LN1@ptt_pthrea
$LN15@ptt_pthrea:

; 472  :     if (!(pttclass & PTT_CL_LOG) && !strncasecmp( loc, "logmsg.c:", 9)) return;

  000e9	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR pttclass
  000f0	48 83 e0 01	 and	 rax, 1
  000f4	48 85 c0	 test	 rax, rax
  000f7	75 21		 jne	 SHORT $LN16@ptt_pthrea
  000f9	41 b8 09 00 00
	00		 mov	 r8d, 9
  000ff	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG159370
  00106	48 8b 4c 24 70	 mov	 rcx, QWORD PTR loc$[rsp]
  0010b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__strnicmp
  00111	85 c0		 test	 eax, eax
  00113	75 05		 jne	 SHORT $LN16@ptt_pthrea
  00115	e9 ea 01 00 00	 jmp	 $LN1@ptt_pthrea
$LN16@ptt_pthrea:

; 473  : 
; 474  :     /* Check for 'nowrap' */
; 475  :     if (pttnowrap && pttracex + 1 >= pttracen) return;

  0011a	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR pttnowrap, 0
  00121	74 15		 je	 SHORT $LN17@ptt_pthrea
  00123	8b 05 00 00 00
	00		 mov	 eax, DWORD PTR pttracex
  00129	ff c0		 inc	 eax
  0012b	3b 05 00 00 00
	00		 cmp	 eax, DWORD PTR pttracen
  00131	7c 05		 jl	 SHORT $LN17@ptt_pthrea
  00133	e9 cc 01 00 00	 jmp	 $LN1@ptt_pthrea
$LN17@ptt_pthrea:
$LN4@ptt_pthrea:

; 476  : 
; 477  :     /* Consume another trace table entry */
; 478  :     OBTAIN_PTTLOCK;

  00138	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR pttnolock, 0
  0013f	75 18		 jne	 SHORT $LN18@ptt_pthrea
  00141	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:pttlock
  00148	e8 00 00 00 00	 call	 fthread_mutex_lock
  0014d	89 44 24 28	 mov	 DWORD PTR rc$1[rsp], eax
  00151	83 7c 24 28 00	 cmp	 DWORD PTR rc$1[rsp], 0
  00156	74 01		 je	 SHORT $LN19@ptt_pthrea
  00158	cc		 int	 3
$LN19@ptt_pthrea:
$LN18@ptt_pthrea:
  00159	33 c0		 xor	 eax, eax
  0015b	85 c0		 test	 eax, eax
  0015d	75 d9		 jne	 SHORT $LN4@ptt_pthrea

; 479  :     if (pttrace == NULL || (n = pttracen) == 0)

  0015f	48 83 3d 00 00
	00 00 00	 cmp	 QWORD PTR pttrace, 0
  00167	74 11		 je	 SHORT $LN21@ptt_pthrea
  00169	8b 05 00 00 00
	00		 mov	 eax, DWORD PTR pttracen
  0016f	89 44 24 24	 mov	 DWORD PTR n$[rsp], eax
  00173	83 7c 24 24 00	 cmp	 DWORD PTR n$[rsp], 0
  00178	75 2c		 jne	 SHORT $LN20@ptt_pthrea
$LN21@ptt_pthrea:
$LN7@ptt_pthrea:

; 480  :     {
; 481  :         RELEASE_PTTLOCK;

  0017a	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR pttnolock, 0
  00181	75 18		 jne	 SHORT $LN22@ptt_pthrea
  00183	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:pttlock
  0018a	e8 00 00 00 00	 call	 fthread_mutex_unlock
  0018f	89 44 24 2c	 mov	 DWORD PTR rc$2[rsp], eax
  00193	83 7c 24 2c 00	 cmp	 DWORD PTR rc$2[rsp], 0
  00198	74 01		 je	 SHORT $LN23@ptt_pthrea
  0019a	cc		 int	 3
$LN23@ptt_pthrea:
$LN22@ptt_pthrea:
  0019b	33 c0		 xor	 eax, eax
  0019d	85 c0		 test	 eax, eax
  0019f	75 d9		 jne	 SHORT $LN7@ptt_pthrea

; 482  :         return;

  001a1	e9 5e 01 00 00	 jmp	 $LN1@ptt_pthrea
$LN20@ptt_pthrea:

; 483  :     }
; 484  :     i = pttracex++;

  001a6	8b 05 00 00 00
	00		 mov	 eax, DWORD PTR pttracex
  001ac	89 44 24 20	 mov	 DWORD PTR i$[rsp], eax
  001b0	8b 05 00 00 00
	00		 mov	 eax, DWORD PTR pttracex
  001b6	ff c0		 inc	 eax
  001b8	89 05 00 00 00
	00		 mov	 DWORD PTR pttracex, eax

; 485  :     if (pttracex >= n)

  001be	8b 44 24 24	 mov	 eax, DWORD PTR n$[rsp]
  001c2	39 05 00 00 00
	00		 cmp	 DWORD PTR pttracex, eax
  001c8	7c 0a		 jl	 SHORT $LN24@ptt_pthrea

; 486  :         pttracex = 0;

  001ca	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR pttracex, 0
$LN24@ptt_pthrea:
$LN10@ptt_pthrea:

; 487  :     RELEASE_PTTLOCK;

  001d4	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR pttnolock, 0
  001db	75 18		 jne	 SHORT $LN25@ptt_pthrea
  001dd	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:pttlock
  001e4	e8 00 00 00 00	 call	 fthread_mutex_unlock
  001e9	89 44 24 30	 mov	 DWORD PTR rc$3[rsp], eax
  001ed	83 7c 24 30 00	 cmp	 DWORD PTR rc$3[rsp], 0
  001f2	74 01		 je	 SHORT $LN26@ptt_pthrea
  001f4	cc		 int	 3
$LN26@ptt_pthrea:
$LN25@ptt_pthrea:
  001f5	33 c0		 xor	 eax, eax
  001f7	85 c0		 test	 eax, eax
  001f9	75 d9		 jne	 SHORT $LN10@ptt_pthrea

; 488  : 
; 489  :     /* Fill in the trace table entry */
; 490  :     if (pttnotod == 0)

  001fb	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR pttnotod, 0
  00202	75 4c		 jne	 SHORT $LN27@ptt_pthrea

; 491  :     {
; 492  :         if (pTV)

  00204	48 83 bc 24 80
	00 00 00 00	 cmp	 QWORD PTR pTV$[rsp], 0
  0020d	74 22		 je	 SHORT $LN28@ptt_pthrea

; 493  :             memcpy( &pttrace[i].tv, pTV, sizeof( TIMEVAL ));

  0020f	48 63 44 24 20	 movsxd	 rax, DWORD PTR i$[rsp]
  00214	48 6b c0 40	 imul	 rax, rax, 64		; 00000040H
  00218	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR pttrace
  0021f	48 8b 94 24 80
	00 00 00	 mov	 rdx, QWORD PTR pTV$[rsp]
  00227	48 8b 12	 mov	 rdx, QWORD PTR [rdx]
  0022a	48 89 54 01 30	 mov	 QWORD PTR [rcx+rax+48], rdx
  0022f	eb 1f		 jmp	 SHORT $LN29@ptt_pthrea
$LN28@ptt_pthrea:

; 494  :         else
; 495  :             gettimeofday( &pttrace[i].tv, NULL );

  00231	48 63 44 24 20	 movsxd	 rax, DWORD PTR i$[rsp]
  00236	48 6b c0 40	 imul	 rax, rax, 64		; 00000040H
  0023a	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR pttrace
  00241	48 8d 44 01 30	 lea	 rax, QWORD PTR [rcx+rax+48]
  00246	33 d2		 xor	 edx, edx
  00248	48 8b c8	 mov	 rcx, rax
  0024b	e8 00 00 00 00	 call	 gettimeofday
$LN29@ptt_pthrea:
$LN27@ptt_pthrea:

; 496  :     }
; 497  :     pttrace[i].tid     = thread_id();

  00250	e8 00 00 00 00	 call	 fthread_self
  00255	48 63 4c 24 20	 movsxd	 rcx, DWORD PTR i$[rsp]
  0025a	48 6b c9 40	 imul	 rcx, rcx, 64		; 00000040H
  0025e	48 8b 15 00 00
	00 00		 mov	 rdx, QWORD PTR pttrace
  00265	89 04 0a	 mov	 DWORD PTR [rdx+rcx], eax

; 498  :     pttrace[i].trclass = trclass;

  00268	48 63 44 24 20	 movsxd	 rax, DWORD PTR i$[rsp]
  0026d	48 6b c0 40	 imul	 rax, rax, 64		; 00000040H
  00271	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR pttrace
  00278	48 8b 54 24 50	 mov	 rdx, QWORD PTR trclass$[rsp]
  0027d	48 89 54 01 08	 mov	 QWORD PTR [rcx+rax+8], rdx

; 499  :     pttrace[i].msg     = msg;

  00282	48 63 44 24 20	 movsxd	 rax, DWORD PTR i$[rsp]
  00287	48 6b c0 40	 imul	 rax, rax, 64		; 00000040H
  0028b	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR pttrace
  00292	48 8b 54 24 58	 mov	 rdx, QWORD PTR msg$[rsp]
  00297	48 89 54 01 10	 mov	 QWORD PTR [rcx+rax+16], rdx

; 500  :     pttrace[i].data1   = data1;

  0029c	48 63 44 24 20	 movsxd	 rax, DWORD PTR i$[rsp]
  002a1	48 6b c0 40	 imul	 rax, rax, 64		; 00000040H
  002a5	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR pttrace
  002ac	48 8b 54 24 60	 mov	 rdx, QWORD PTR data1$[rsp]
  002b1	48 89 54 01 18	 mov	 QWORD PTR [rcx+rax+24], rdx

; 501  :     pttrace[i].data2   = data2;

  002b6	48 63 44 24 20	 movsxd	 rax, DWORD PTR i$[rsp]
  002bb	48 6b c0 40	 imul	 rax, rax, 64		; 00000040H
  002bf	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR pttrace
  002c6	48 8b 54 24 68	 mov	 rdx, QWORD PTR data2$[rsp]
  002cb	48 89 54 01 20	 mov	 QWORD PTR [rcx+rax+32], rdx

; 502  :     pttrace[i].loc     = loc;

  002d0	48 63 44 24 20	 movsxd	 rax, DWORD PTR i$[rsp]
  002d5	48 6b c0 40	 imul	 rax, rax, 64		; 00000040H
  002d9	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR pttrace
  002e0	48 8b 54 24 70	 mov	 rdx, QWORD PTR loc$[rsp]
  002e5	48 89 54 01 28	 mov	 QWORD PTR [rcx+rax+40], rdx

; 503  :     pttrace[i].rc      = rc;

  002ea	48 63 44 24 20	 movsxd	 rax, DWORD PTR i$[rsp]
  002ef	48 6b c0 40	 imul	 rax, rax, 64		; 00000040H
  002f3	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR pttrace
  002fa	48 8b 54 24 78	 mov	 rdx, QWORD PTR rc$[rsp]
  002ff	48 89 54 01 38	 mov	 QWORD PTR [rcx+rax+56], rdx
$LN1@ptt_pthrea:

; 504  : }

  00304	48 83 c4 48	 add	 rsp, 72			; 00000048H
  00308	c3		 ret	 0
ptt_pthread_trace ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\pttrace.c
_TEXT	SEGMENT
c$ = 64
to$ = 68
rc$ = 72
n$ = 76
showparms$1 = 80
no$ = 84
rc$2 = 88
rc$3 = 92
rc$4 = 96
rc$5 = 100
rc$6 = 104
pPTTCL$ = 112
trcl$7 = 120
tv248 = 128
tv273 = 136
argc$ = 160
argv$ = 168
cmdline$ = 176
ptt_cmd	PROC

; 260  : {

$LN73:
  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	89 4c 24 08	 mov	 DWORD PTR [rsp+8], ecx
  0000e	48 81 ec 98 00
	00 00		 sub	 rsp, 152		; 00000098H

; 261  :     int  rc = 0;

  00015	c7 44 24 48 00
	00 00 00	 mov	 DWORD PTR rc$[rsp], 0

; 262  :     int  n, to = -1;

  0001d	c7 44 24 44 ff
	ff ff ff	 mov	 DWORD PTR to$[rsp], -1
$LN4@ptt_cmd:

; 263  :     char c;
; 264  :     PTTCL* pPTTCL;
; 265  :     int no;
; 266  : 
; 267  :     UNREFERENCED( cmdline );

  00025	33 c0		 xor	 eax, eax
  00027	85 c0		 test	 eax, eax
  00029	75 fa		 jne	 SHORT $LN4@ptt_cmd

; 268  : 
; 269  :     if (argc > 1)

  0002b	83 bc 24 a0 00
	00 00 01	 cmp	 DWORD PTR argc$[rsp], 1
  00033	0f 8e eb 06 00
	00		 jle	 $LN23@ptt_cmd

; 270  :     {
; 271  :         int showparms = 0;

  00039	c7 44 24 50 00
	00 00 00	 mov	 DWORD PTR showparms$1[rsp], 0

; 272  : 
; 273  :         /* process arguments; last arg can be trace table size */
; 274  :         for (--argc, argv++; argc; --argc, ++argv)

  00041	8b 84 24 a0 00
	00 00		 mov	 eax, DWORD PTR argc$[rsp]
  00048	ff c8		 dec	 eax
  0004a	89 84 24 a0 00
	00 00		 mov	 DWORD PTR argc$[rsp], eax
  00051	48 8b 84 24 a8
	00 00 00	 mov	 rax, QWORD PTR argv$[rsp]
  00059	48 83 c0 08	 add	 rax, 8
  0005d	48 89 84 24 a8
	00 00 00	 mov	 QWORD PTR argv$[rsp], rax
  00065	eb 24		 jmp	 SHORT $LN7@ptt_cmd
$LN5@ptt_cmd:
  00067	8b 84 24 a0 00
	00 00		 mov	 eax, DWORD PTR argc$[rsp]
  0006e	ff c8		 dec	 eax
  00070	89 84 24 a0 00
	00 00		 mov	 DWORD PTR argc$[rsp], eax
  00077	48 8b 84 24 a8
	00 00 00	 mov	 rax, QWORD PTR argv$[rsp]
  0007f	48 83 c0 08	 add	 rax, 8
  00083	48 89 84 24 a8
	00 00 00	 mov	 QWORD PTR argv$[rsp], rax
$LN7@ptt_cmd:
  0008b	83 bc 24 a0 00
	00 00 00	 cmp	 DWORD PTR argc$[rsp], 0
  00093	0f 84 8b 05 00
	00		 je	 $LN6@ptt_cmd

; 275  :         {
; 276  :             if (strcasecmp("opts", argv[0]) == 0)

  00099	b8 08 00 00 00	 mov	 eax, 8
  0009e	48 6b c0 00	 imul	 rax, rax, 0
  000a2	48 8b 8c 24 a8
	00 00 00	 mov	 rcx, QWORD PTR argv$[rsp]
  000aa	48 8b 14 01	 mov	 rdx, QWORD PTR [rcx+rax]
  000ae	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159239
  000b5	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__stricmp
  000bb	85 c0		 test	 eax, eax
  000bd	75 02		 jne	 SHORT $LN25@ptt_cmd

; 277  :                 continue;

  000bf	eb a6		 jmp	 SHORT $LN5@ptt_cmd
$LN25@ptt_cmd:

; 278  : 
; 279  :             /* Try to find this trace class in our table */
; 280  :             pPTTCL = pttcl_byname( argv[0], &no );

  000c1	b8 08 00 00 00	 mov	 eax, 8
  000c6	48 6b c0 00	 imul	 rax, rax, 0
  000ca	48 8d 54 24 54	 lea	 rdx, QWORD PTR no$[rsp]
  000cf	48 8b 8c 24 a8
	00 00 00	 mov	 rcx, QWORD PTR argv$[rsp]
  000d7	48 8b 0c 01	 mov	 rcx, QWORD PTR [rcx+rax]
  000db	e8 00 00 00 00	 call	 pttcl_byname
  000e0	48 89 44 24 70	 mov	 QWORD PTR pPTTCL$[rsp], rax

; 281  : 
; 282  :             /* Enable/disable tracing for class if found */
; 283  :             if (pPTTCL)

  000e5	48 83 7c 24 70
	00		 cmp	 QWORD PTR pPTTCL$[rsp], 0
  000eb	74 56		 je	 SHORT $LN26@ptt_cmd

; 284  :             {
; 285  :                 U64 trcl = pPTTCL->trcl;

  000ed	48 8b 44 24 70	 mov	 rax, QWORD PTR pPTTCL$[rsp]
  000f2	48 8b 40 08	 mov	 rax, QWORD PTR [rax+8]
  000f6	48 89 44 24 78	 mov	 QWORD PTR trcl$7[rsp], rax

; 286  :                 if (no)

  000fb	83 7c 24 54 00	 cmp	 DWORD PTR no$[rsp], 0
  00100	74 1e		 je	 SHORT $LN28@ptt_cmd

; 287  :                     pttclass &= ~trcl;

  00102	48 8b 44 24 78	 mov	 rax, QWORD PTR trcl$7[rsp]
  00107	48 f7 d0	 not	 rax
  0010a	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR pttclass
  00111	48 23 c8	 and	 rcx, rax
  00114	48 8b c1	 mov	 rax, rcx
  00117	48 89 05 00 00
	00 00		 mov	 QWORD PTR pttclass, rax
  0011e	eb 19		 jmp	 SHORT $LN29@ptt_cmd
$LN28@ptt_cmd:

; 288  :                 else
; 289  :                     pttclass |=  trcl;

  00120	48 8b 44 24 78	 mov	 rax, QWORD PTR trcl$7[rsp]
  00125	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR pttclass
  0012c	48 0b c8	 or	 rcx, rax
  0012f	48 8b c1	 mov	 rax, rcx
  00132	48 89 05 00 00
	00 00		 mov	 QWORD PTR pttclass, rax
$LN29@ptt_cmd:

; 290  :                 continue;

  00139	e9 29 ff ff ff	 jmp	 $LN5@ptt_cmd

; 291  :             }

  0013e	e9 dc 04 00 00	 jmp	 $LN27@ptt_cmd
$LN26@ptt_cmd:

; 292  :             /* Check if other valid PTT command argument */
; 293  :             else if (strcasecmp("?", argv[0]) == 0)

  00143	b8 08 00 00 00	 mov	 eax, 8
  00148	48 6b c0 00	 imul	 rax, rax, 0
  0014c	48 8b 8c 24 a8
	00 00 00	 mov	 rcx, QWORD PTR argv$[rsp]
  00154	48 8b 14 01	 mov	 rdx, QWORD PTR [rcx+rax]
  00158	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159246
  0015f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__stricmp
  00165	85 c0		 test	 eax, eax
  00167	75 0d		 jne	 SHORT $LN30@ptt_cmd

; 294  :             {
; 295  :                 showparms = 1;

  00169	c7 44 24 50 01
	00 00 00	 mov	 DWORD PTR showparms$1[rsp], 1

; 296  :             }

  00171	e9 a9 04 00 00	 jmp	 $LN31@ptt_cmd
$LN30@ptt_cmd:

; 297  :             else if (strcasecmp("dtax", argv[0]) == 0)

  00176	b8 08 00 00 00	 mov	 eax, 8
  0017b	48 6b c0 00	 imul	 rax, rax, 0
  0017f	48 8b 8c 24 a8
	00 00 00	 mov	 rcx, QWORD PTR argv$[rsp]
  00187	48 8b 14 01	 mov	 rdx, QWORD PTR [rcx+rax]
  0018b	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159249
  00192	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__stricmp
  00198	85 c0		 test	 eax, eax
  0019a	75 11		 jne	 SHORT $LN32@ptt_cmd

; 298  :             {
; 299  :                 pttdtax = true;

  0019c	c6 05 00 00 00
	00 01		 mov	 BYTE PTR pttdtax, 1

; 300  :                 continue;

  001a3	e9 bf fe ff ff	 jmp	 $LN5@ptt_cmd

; 301  :             }

  001a8	e9 72 04 00 00	 jmp	 $LN33@ptt_cmd
$LN32@ptt_cmd:

; 302  :             else if (strcasecmp("nodtax", argv[0]) == 0)

  001ad	b8 08 00 00 00	 mov	 eax, 8
  001b2	48 6b c0 00	 imul	 rax, rax, 0
  001b6	48 8b 8c 24 a8
	00 00 00	 mov	 rcx, QWORD PTR argv$[rsp]
  001be	48 8b 14 01	 mov	 rdx, QWORD PTR [rcx+rax]
  001c2	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159252
  001c9	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__stricmp
  001cf	85 c0		 test	 eax, eax
  001d1	75 11		 jne	 SHORT $LN34@ptt_cmd

; 303  :             {
; 304  :                 pttdtax = false;

  001d3	c6 05 00 00 00
	00 00		 mov	 BYTE PTR pttdtax, 0

; 305  :                 continue;

  001da	e9 88 fe ff ff	 jmp	 $LN5@ptt_cmd

; 306  :             }

  001df	e9 3b 04 00 00	 jmp	 $LN35@ptt_cmd
$LN34@ptt_cmd:

; 307  :             else if (strcasecmp("lock", argv[0]) == 0)

  001e4	b8 08 00 00 00	 mov	 eax, 8
  001e9	48 6b c0 00	 imul	 rax, rax, 0
  001ed	48 8b 8c 24 a8
	00 00 00	 mov	 rcx, QWORD PTR argv$[rsp]
  001f5	48 8b 14 01	 mov	 rdx, QWORD PTR [rcx+rax]
  001f9	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159255
  00200	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__stricmp
  00206	85 c0		 test	 eax, eax
  00208	75 14		 jne	 SHORT $LN36@ptt_cmd

; 308  :             {
; 309  :                 pttnolock = 0;

  0020a	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR pttnolock, 0

; 310  :                 continue;

  00214	e9 4e fe ff ff	 jmp	 $LN5@ptt_cmd

; 311  :             }

  00219	e9 01 04 00 00	 jmp	 $LN37@ptt_cmd
$LN36@ptt_cmd:

; 312  :             else if (strcasecmp("nolock", argv[0]) == 0)

  0021e	b8 08 00 00 00	 mov	 eax, 8
  00223	48 6b c0 00	 imul	 rax, rax, 0
  00227	48 8b 8c 24 a8
	00 00 00	 mov	 rcx, QWORD PTR argv$[rsp]
  0022f	48 8b 14 01	 mov	 rdx, QWORD PTR [rcx+rax]
  00233	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159258
  0023a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__stricmp
  00240	85 c0		 test	 eax, eax
  00242	75 14		 jne	 SHORT $LN38@ptt_cmd

; 313  :             {
; 314  :                 pttnolock = 1;

  00244	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR pttnolock, 1

; 315  :                 continue;

  0024e	e9 14 fe ff ff	 jmp	 $LN5@ptt_cmd

; 316  :             }

  00253	e9 c7 03 00 00	 jmp	 $LN39@ptt_cmd
$LN38@ptt_cmd:

; 317  :             else if (strcasecmp("tod", argv[0]) == 0)

  00258	b8 08 00 00 00	 mov	 eax, 8
  0025d	48 6b c0 00	 imul	 rax, rax, 0
  00261	48 8b 8c 24 a8
	00 00 00	 mov	 rcx, QWORD PTR argv$[rsp]
  00269	48 8b 14 01	 mov	 rdx, QWORD PTR [rcx+rax]
  0026d	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159261
  00274	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__stricmp
  0027a	85 c0		 test	 eax, eax
  0027c	75 14		 jne	 SHORT $LN40@ptt_cmd

; 318  :             {
; 319  :                 pttnotod = 0;

  0027e	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR pttnotod, 0

; 320  :                 continue;

  00288	e9 da fd ff ff	 jmp	 $LN5@ptt_cmd

; 321  :             }

  0028d	e9 8d 03 00 00	 jmp	 $LN41@ptt_cmd
$LN40@ptt_cmd:

; 322  :             else if (strcasecmp("notod", argv[0]) == 0)

  00292	b8 08 00 00 00	 mov	 eax, 8
  00297	48 6b c0 00	 imul	 rax, rax, 0
  0029b	48 8b 8c 24 a8
	00 00 00	 mov	 rcx, QWORD PTR argv$[rsp]
  002a3	48 8b 14 01	 mov	 rdx, QWORD PTR [rcx+rax]
  002a7	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159264
  002ae	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__stricmp
  002b4	85 c0		 test	 eax, eax
  002b6	75 14		 jne	 SHORT $LN42@ptt_cmd

; 323  :             {
; 324  :                 pttnotod = 1;

  002b8	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR pttnotod, 1

; 325  :                 continue;

  002c2	e9 a0 fd ff ff	 jmp	 $LN5@ptt_cmd

; 326  :             }

  002c7	e9 53 03 00 00	 jmp	 $LN43@ptt_cmd
$LN42@ptt_cmd:

; 327  :             else if (strcasecmp("wrap", argv[0]) == 0)

  002cc	b8 08 00 00 00	 mov	 eax, 8
  002d1	48 6b c0 00	 imul	 rax, rax, 0
  002d5	48 8b 8c 24 a8
	00 00 00	 mov	 rcx, QWORD PTR argv$[rsp]
  002dd	48 8b 14 01	 mov	 rdx, QWORD PTR [rcx+rax]
  002e1	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159267
  002e8	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__stricmp
  002ee	85 c0		 test	 eax, eax
  002f0	75 14		 jne	 SHORT $LN44@ptt_cmd

; 328  :             {
; 329  :                 pttnowrap = 0;

  002f2	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR pttnowrap, 0

; 330  :                 continue;

  002fc	e9 66 fd ff ff	 jmp	 $LN5@ptt_cmd

; 331  :             }

  00301	e9 19 03 00 00	 jmp	 $LN45@ptt_cmd
$LN44@ptt_cmd:

; 332  :             else if (strcasecmp("nowrap", argv[0]) == 0)

  00306	b8 08 00 00 00	 mov	 eax, 8
  0030b	48 6b c0 00	 imul	 rax, rax, 0
  0030f	48 8b 8c 24 a8
	00 00 00	 mov	 rcx, QWORD PTR argv$[rsp]
  00317	48 8b 14 01	 mov	 rdx, QWORD PTR [rcx+rax]
  0031b	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159270
  00322	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__stricmp
  00328	85 c0		 test	 eax, eax
  0032a	75 14		 jne	 SHORT $LN46@ptt_cmd

; 333  :             {
; 334  :                 pttnowrap = 1;

  0032c	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR pttnowrap, 1

; 335  :                 continue;

  00336	e9 2c fd ff ff	 jmp	 $LN5@ptt_cmd

; 336  :             }

  0033b	e9 df 02 00 00	 jmp	 $LN47@ptt_cmd
$LN46@ptt_cmd:

; 337  :             else if (strncasecmp("to=", argv[0], 3) == 0 && strlen(argv[0]) > 3
; 338  :                   && (sscanf(&argv[0][3], "%d%c", &to, &c) == 1 && to >= 0))

  00340	b8 08 00 00 00	 mov	 eax, 8
  00345	48 6b c0 00	 imul	 rax, rax, 0
  00349	41 b8 03 00 00
	00		 mov	 r8d, 3
  0034f	48 8b 8c 24 a8
	00 00 00	 mov	 rcx, QWORD PTR argv$[rsp]
  00357	48 8b 14 01	 mov	 rdx, QWORD PTR [rcx+rax]
  0035b	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159273
  00362	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__strnicmp
  00368	85 c0		 test	 eax, eax
  0036a	75 7a		 jne	 SHORT $LN48@ptt_cmd
  0036c	b8 08 00 00 00	 mov	 eax, 8
  00371	48 6b c0 00	 imul	 rax, rax, 0
  00375	48 8b 8c 24 a8
	00 00 00	 mov	 rcx, QWORD PTR argv$[rsp]
  0037d	48 8b 0c 01	 mov	 rcx, QWORD PTR [rcx+rax]
  00381	e8 00 00 00 00	 call	 strlen
  00386	48 83 f8 03	 cmp	 rax, 3
  0038a	76 5a		 jbe	 SHORT $LN48@ptt_cmd
  0038c	b8 08 00 00 00	 mov	 eax, 8
  00391	48 6b c0 00	 imul	 rax, rax, 0
  00395	b9 01 00 00 00	 mov	 ecx, 1
  0039a	48 6b c9 03	 imul	 rcx, rcx, 3
  0039e	48 8b 94 24 a8
	00 00 00	 mov	 rdx, QWORD PTR argv$[rsp]
  003a6	48 03 0c 02	 add	 rcx, QWORD PTR [rdx+rax]
  003aa	48 8b c1	 mov	 rax, rcx
  003ad	4c 8d 4c 24 40	 lea	 r9, QWORD PTR c$[rsp]
  003b2	4c 8d 44 24 44	 lea	 r8, QWORD PTR to$[rsp]
  003b7	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG159274
  003be	48 8b c8	 mov	 rcx, rax
  003c1	e8 00 00 00 00	 call	 sscanf
  003c6	83 f8 01	 cmp	 eax, 1
  003c9	75 1b		 jne	 SHORT $LN48@ptt_cmd
  003cb	83 7c 24 44 00	 cmp	 DWORD PTR to$[rsp], 0
  003d0	7c 14		 jl	 SHORT $LN48@ptt_cmd

; 339  :             {
; 340  :                 pttto = to;

  003d2	8b 44 24 44	 mov	 eax, DWORD PTR to$[rsp]
  003d6	89 05 00 00 00
	00		 mov	 DWORD PTR pttto, eax

; 341  :                 continue;

  003dc	e9 86 fc ff ff	 jmp	 $LN5@ptt_cmd

; 342  :             }

  003e1	e9 39 02 00 00	 jmp	 $LN49@ptt_cmd
$LN48@ptt_cmd:

; 343  :             else if (argc == 1 && sscanf(argv[0], "%d%c", &n, &c) == 1 && n >= 0)

  003e6	83 bc 24 a0 00
	00 00 01	 cmp	 DWORD PTR argc$[rsp], 1
  003ee	0f 85 b1 01 00
	00		 jne	 $LN50@ptt_cmd
  003f4	b8 08 00 00 00	 mov	 eax, 8
  003f9	48 6b c0 00	 imul	 rax, rax, 0
  003fd	4c 8d 4c 24 40	 lea	 r9, QWORD PTR c$[rsp]
  00402	4c 8d 44 24 4c	 lea	 r8, QWORD PTR n$[rsp]
  00407	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG159277
  0040e	48 8b 8c 24 a8
	00 00 00	 mov	 rcx, QWORD PTR argv$[rsp]
  00416	48 8b 0c 01	 mov	 rcx, QWORD PTR [rcx+rax]
  0041a	e8 00 00 00 00	 call	 sscanf
  0041f	83 f8 01	 cmp	 eax, 1
  00422	0f 85 7d 01 00
	00		 jne	 $LN50@ptt_cmd
  00428	83 7c 24 4c 00	 cmp	 DWORD PTR n$[rsp], 0
  0042d	0f 8c 72 01 00
	00		 jl	 $LN50@ptt_cmd
$LN10@ptt_cmd:

; 344  :             {
; 345  :                 OBTAIN_PTTLOCK;

  00433	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR pttnolock, 0
  0043a	75 18		 jne	 SHORT $LN52@ptt_cmd
  0043c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:pttlock
  00443	e8 00 00 00 00	 call	 fthread_mutex_lock
  00448	89 44 24 58	 mov	 DWORD PTR rc$2[rsp], eax
  0044c	83 7c 24 58 00	 cmp	 DWORD PTR rc$2[rsp], 0
  00451	74 01		 je	 SHORT $LN53@ptt_cmd
  00453	cc		 int	 3
$LN53@ptt_cmd:
$LN52@ptt_cmd:
  00454	33 c0		 xor	 eax, eax
  00456	85 c0		 test	 eax, eax
  00458	75 d9		 jne	 SHORT $LN10@ptt_cmd

; 346  :                 if (pttracen == 0)

  0045a	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR pttracen, 0
  00461	0f 85 86 00 00
	00		 jne	 $LN54@ptt_cmd

; 347  :                 {
; 348  :                     if (pttrace != NULL)

  00467	48 83 3d 00 00
	00 00 00	 cmp	 QWORD PTR pttrace, 0
  0046f	74 77		 je	 SHORT $LN56@ptt_cmd
$LN13@ptt_cmd:

; 349  :                     {
; 350  :                         RELEASE_PTTLOCK;

  00471	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR pttnolock, 0
  00478	75 18		 jne	 SHORT $LN57@ptt_cmd
  0047a	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:pttlock
  00481	e8 00 00 00 00	 call	 fthread_mutex_unlock
  00486	89 44 24 5c	 mov	 DWORD PTR rc$3[rsp], eax
  0048a	83 7c 24 5c 00	 cmp	 DWORD PTR rc$3[rsp], 0
  0048f	74 01		 je	 SHORT $LN58@ptt_cmd
  00491	cc		 int	 3
$LN58@ptt_cmd:
$LN57@ptt_cmd:
  00492	33 c0		 xor	 eax, eax
  00494	85 c0		 test	 eax, eax
  00496	75 d9		 jne	 SHORT $LN13@ptt_cmd

; 351  :                         // "Pttrace: trace is busy"
; 352  :                         WRMSG(HHC90010, "E");

  00498	b9 01 00 00 00	 mov	 ecx, 1
  0049d	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  004a3	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159285
  004aa	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  004af	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159286
  004b6	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  004bb	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  004c0	41 b9 03 00 00
	00		 mov	 r9d, 3
  004c6	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG159287
  004cd	ba 60 01 00 00	 mov	 edx, 352		; 00000160H
  004d2	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159288
  004d9	e8 00 00 00 00	 call	 fwritemsg

; 353  :                         return -1;

  004de	b8 ff ff ff ff	 mov	 eax, -1
  004e3	e9 5c 02 00 00	 jmp	 $LN1@ptt_cmd
$LN56@ptt_cmd:

; 354  :                     }
; 355  :                 }

  004e8	e9 84 00 00 00	 jmp	 $LN55@ptt_cmd
$LN54@ptt_cmd:

; 356  :                 else if (pttrace)

  004ed	48 83 3d 00 00
	00 00 00	 cmp	 QWORD PTR pttrace, 0
  004f5	74 7a		 je	 SHORT $LN59@ptt_cmd

; 357  :                 {
; 358  :                     pttracen = 0;

  004f7	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR pttracen, 0
$LN16@ptt_cmd:

; 359  :                     RELEASE_PTTLOCK;

  00501	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR pttnolock, 0
  00508	75 18		 jne	 SHORT $LN60@ptt_cmd
  0050a	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:pttlock
  00511	e8 00 00 00 00	 call	 fthread_mutex_unlock
  00516	89 44 24 60	 mov	 DWORD PTR rc$4[rsp], eax
  0051a	83 7c 24 60 00	 cmp	 DWORD PTR rc$4[rsp], 0
  0051f	74 01		 je	 SHORT $LN61@ptt_cmd
  00521	cc		 int	 3
$LN61@ptt_cmd:
$LN60@ptt_cmd:
  00522	33 c0		 xor	 eax, eax
  00524	85 c0		 test	 eax, eax
  00526	75 d9		 jne	 SHORT $LN16@ptt_cmd

; 360  :                     usleep(1000);

  00528	b9 e8 03 00 00	 mov	 ecx, 1000		; 000003e8H
  0052d	e8 00 00 00 00	 call	 usleep
$LN19@ptt_cmd:

; 361  :                     OBTAIN_PTTLOCK;

  00532	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR pttnolock, 0
  00539	75 18		 jne	 SHORT $LN62@ptt_cmd
  0053b	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:pttlock
  00542	e8 00 00 00 00	 call	 fthread_mutex_lock
  00547	89 44 24 64	 mov	 DWORD PTR rc$5[rsp], eax
  0054b	83 7c 24 64 00	 cmp	 DWORD PTR rc$5[rsp], 0
  00550	74 01		 je	 SHORT $LN63@ptt_cmd
  00552	cc		 int	 3
$LN63@ptt_cmd:
$LN62@ptt_cmd:
  00553	33 c0		 xor	 eax, eax
  00555	85 c0		 test	 eax, eax
  00557	75 d9		 jne	 SHORT $LN19@ptt_cmd

; 362  :                     free (pttrace);

  00559	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR pttrace
  00560	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free

; 363  :                     pttrace = NULL;

  00566	48 c7 05 00 00
	00 00 00 00 00
	00		 mov	 QWORD PTR pttrace, 0
$LN59@ptt_cmd:
$LN55@ptt_cmd:

; 364  :                 }
; 365  :                 ptt_trace_init( n, FALSE );

  00571	33 d2		 xor	 edx, edx
  00573	8b 4c 24 4c	 mov	 ecx, DWORD PTR n$[rsp]
  00577	e8 00 00 00 00	 call	 ptt_trace_init
$LN22@ptt_cmd:

; 366  :                 RELEASE_PTTLOCK;

  0057c	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR pttnolock, 0
  00583	75 18		 jne	 SHORT $LN64@ptt_cmd
  00585	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:pttlock
  0058c	e8 00 00 00 00	 call	 fthread_mutex_unlock
  00591	89 44 24 68	 mov	 DWORD PTR rc$6[rsp], eax
  00595	83 7c 24 68 00	 cmp	 DWORD PTR rc$6[rsp], 0
  0059a	74 01		 je	 SHORT $LN65@ptt_cmd
  0059c	cc		 int	 3
$LN65@ptt_cmd:
$LN64@ptt_cmd:
  0059d	33 c0		 xor	 eax, eax
  0059f	85 c0		 test	 eax, eax
  005a1	75 d9		 jne	 SHORT $LN22@ptt_cmd

; 367  :             }

  005a3	eb 7a		 jmp	 SHORT $LN51@ptt_cmd
$LN50@ptt_cmd:

; 368  :             else
; 369  :             {
; 370  :                 // "Pttrace: invalid argument %s"
; 371  :                 WRMSG(HHC90011, "E", argv[0]);

  005a5	b8 08 00 00 00	 mov	 eax, 8
  005aa	48 6b c0 00	 imul	 rax, rax, 0
  005ae	48 89 84 24 80
	00 00 00	 mov	 QWORD PTR tv248[rsp], rax
  005b6	b9 01 00 00 00	 mov	 ecx, 1
  005bb	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  005c1	48 8b 8c 24 a8
	00 00 00	 mov	 rcx, QWORD PTR argv$[rsp]
  005c9	48 8b 94 24 80
	00 00 00	 mov	 rdx, QWORD PTR tv248[rsp]
  005d1	48 8b 0c 11	 mov	 rcx, QWORD PTR [rcx+rdx]
  005d5	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  005da	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159296
  005e1	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  005e6	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159297
  005ed	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  005f2	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  005f7	41 b9 03 00 00
	00		 mov	 r9d, 3
  005fd	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG159298
  00604	ba 73 01 00 00	 mov	 edx, 371		; 00000173H
  00609	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159299
  00610	e8 00 00 00 00	 call	 fwritemsg

; 372  :                 rc = -1;

  00615	c7 44 24 48 ff
	ff ff ff	 mov	 DWORD PTR rc$[rsp], -1

; 373  :                 break;

  0061d	eb 05		 jmp	 SHORT $LN6@ptt_cmd
$LN51@ptt_cmd:
$LN49@ptt_cmd:
$LN47@ptt_cmd:
$LN45@ptt_cmd:
$LN43@ptt_cmd:
$LN41@ptt_cmd:
$LN39@ptt_cmd:
$LN37@ptt_cmd:
$LN35@ptt_cmd:
$LN33@ptt_cmd:
$LN31@ptt_cmd:
$LN27@ptt_cmd:

; 374  :             }
; 375  :         } /* for each ptt argument */

  0061f	e9 43 fa ff ff	 jmp	 $LN5@ptt_cmd
$LN6@ptt_cmd:

; 376  : 
; 377  :         /* wakeup timeout thread if to= specified */
; 378  :         if (to >= 0 && ptttotid)

  00624	83 7c 24 44 00	 cmp	 DWORD PTR to$[rsp], 0
  00629	7c 37		 jl	 SHORT $LN66@ptt_cmd
  0062b	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ptttotid, 0
  00632	74 2e		 je	 SHORT $LN66@ptt_cmd

; 379  :         {
; 380  :             hthread_mutex_lock (&ptttolock);

  00634	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:ptttolock
  0063b	e8 00 00 00 00	 call	 fthread_mutex_lock

; 381  :             ptttotid = 0;

  00640	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR ptttotid, 0

; 382  :             hthread_cond_signal (&ptttocond);

  0064a	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:ptttocond
  00651	e8 00 00 00 00	 call	 fthread_cond_signal

; 383  :             hthread_mutex_unlock (&ptttolock);

  00656	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:ptttolock
  0065d	e8 00 00 00 00	 call	 fthread_mutex_unlock
$LN66@ptt_cmd:

; 384  :         }
; 385  : 
; 386  :         /* start timeout thread if positive to= specified */
; 387  :         if (to > 0)

  00662	83 7c 24 44 00	 cmp	 DWORD PTR to$[rsp], 0
  00667	0f 8e a9 00 00
	00		 jle	 $LN67@ptt_cmd

; 388  :         {
; 389  :             hthread_mutex_lock( &ptttolock );

  0066d	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:ptttolock
  00674	e8 00 00 00 00	 call	 fthread_mutex_lock

; 390  :             ptttotid = 0;

  00679	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR ptttotid, 0

; 391  :             rc = hthread_create( &ptttotid, NULL, ptt_timeout, NULL );

  00683	45 33 c9	 xor	 r9d, r9d
  00686	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:ptt_timeout
  0068d	33 d2		 xor	 edx, edx
  0068f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:ptttotid
  00696	e8 00 00 00 00	 call	 fthread_create
  0069b	89 44 24 48	 mov	 DWORD PTR rc$[rsp], eax

; 392  :             if (rc)

  0069f	83 7c 24 48 00	 cmp	 DWORD PTR rc$[rsp], 0
  006a4	74 64		 je	 SHORT $LN68@ptt_cmd

; 393  :                 // "Error in function create_thread(): %s"
; 394  :                 WRMSG( HHC00102, "E", strerror( rc ));

  006a6	8b 4c 24 48	 mov	 ecx, DWORD PTR rc$[rsp]
  006aa	e8 00 00 00 00	 call	 w32_strerror
  006af	48 89 84 24 88
	00 00 00	 mov	 QWORD PTR tv273[rsp], rax
  006b7	b9 01 00 00 00	 mov	 ecx, 1
  006bc	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  006c2	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR tv273[rsp]
  006ca	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  006cf	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159303
  006d6	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  006db	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159304
  006e2	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  006e7	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  006ec	41 b9 03 00 00
	00		 mov	 r9d, 3
  006f2	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG159305
  006f9	ba 8a 01 00 00	 mov	 edx, 394		; 0000018aH
  006fe	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159306
  00705	e8 00 00 00 00	 call	 fwritemsg
$LN68@ptt_cmd:

; 395  :             hthread_mutex_unlock( &ptttolock );

  0070a	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:ptttolock
  00711	e8 00 00 00 00	 call	 fthread_mutex_unlock
$LN67@ptt_cmd:

; 396  :         }
; 397  : 
; 398  :         if (showparms)

  00716	83 7c 24 50 00	 cmp	 DWORD PTR showparms$1[rsp], 0
  0071b	74 05		 je	 SHORT $LN69@ptt_cmd

; 399  :             ptt_showparms();

  0071d	e8 00 00 00 00	 call	 ptt_showparms
$LN69@ptt_cmd:

; 400  :     }

  00722	eb 1c		 jmp	 SHORT $LN24@ptt_cmd
$LN23@ptt_cmd:

; 401  :     else /* No arguments. Dump the table. */
; 402  :     {
; 403  :         /* Dump table when tracing is active (number of entries > 0) */
; 404  :         if (pttracen)

  00724	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR pttracen, 0
  0072b	74 13		 je	 SHORT $LN70@ptt_cmd

; 405  :         {
; 406  :             /* Show parameters both before and after the table dump  */
; 407  :             ptt_showparms();

  0072d	e8 00 00 00 00	 call	 ptt_showparms

; 408  :             if (ptt_pthread_print() > 0)

  00732	e8 00 00 00 00	 call	 ptt_pthread_print
  00737	85 c0		 test	 eax, eax
  00739	7e 05		 jle	 SHORT $LN71@ptt_cmd

; 409  :                 ptt_showparms();

  0073b	e8 00 00 00 00	 call	 ptt_showparms
$LN71@ptt_cmd:
$LN70@ptt_cmd:
$LN24@ptt_cmd:

; 410  :         }
; 411  :     }
; 412  : 
; 413  :     return rc;

  00740	8b 44 24 48	 mov	 eax, DWORD PTR rc$[rsp]
$LN1@ptt_cmd:

; 414  : }

  00744	48 81 c4 98 00
	00 00		 add	 rsp, 152		; 00000098H
  0074b	c3		 ret	 0
ptt_cmd	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\pttrace.c
_TEXT	SEGMENT
rc$1 = 32
attr$2 = 36
tv73 = 40
nTableSize$ = 64
init$ = 72
ptt_trace_init PROC

; 420  : {

$LN14:
  00000	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00004	89 4c 24 08	 mov	 DWORD PTR [rsp+8], ecx
  00008	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 421  :     if (nTableSize > 0)

  0000c	83 7c 24 40 00	 cmp	 DWORD PTR nTableSize$[rsp], 0
  00011	7e 1c		 jle	 SHORT $LN2@ptt_trace_

; 422  :         pttrace = calloc( nTableSize, PTT_TRACE_SIZE );

  00013	48 63 44 24 40	 movsxd	 rax, DWORD PTR nTableSize$[rsp]
  00018	ba 40 00 00 00	 mov	 edx, 64			; 00000040H
  0001d	48 8b c8	 mov	 rcx, rax
  00020	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_calloc
  00026	48 89 05 00 00
	00 00		 mov	 QWORD PTR pttrace, rax
  0002d	eb 0b		 jmp	 SHORT $LN3@ptt_trace_
$LN2@ptt_trace_:

; 423  :     else
; 424  :         pttrace = NULL;

  0002f	48 c7 05 00 00
	00 00 00 00 00
	00		 mov	 QWORD PTR pttrace, 0
$LN3@ptt_trace_:

; 425  : 
; 426  :     pttracen = pttrace ? nTableSize : 0;

  0003a	48 83 3d 00 00
	00 00 00	 cmp	 QWORD PTR pttrace, 0
  00042	74 0a		 je	 SHORT $LN12@ptt_trace_
  00044	8b 44 24 40	 mov	 eax, DWORD PTR nTableSize$[rsp]
  00048	89 44 24 28	 mov	 DWORD PTR tv73[rsp], eax
  0004c	eb 08		 jmp	 SHORT $LN13@ptt_trace_
$LN12@ptt_trace_:
  0004e	c7 44 24 28 00
	00 00 00	 mov	 DWORD PTR tv73[rsp], 0
$LN13@ptt_trace_:
  00056	8b 44 24 28	 mov	 eax, DWORD PTR tv73[rsp]
  0005a	89 05 00 00 00
	00		 mov	 DWORD PTR pttracen, eax

; 427  :     pttracex = 0;

  00060	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR pttracex, 0

; 428  : 
; 429  :     if (init)       /* First time? */

  0006a	83 7c 24 48 00	 cmp	 DWORD PTR init$[rsp], 0
  0006f	0f 84 cb 00 00
	00		 je	 $LN4@ptt_trace_

; 430  :     {
; 431  :         int rc;
; 432  :         MATTR attr;
; 433  :         if ((rc = hthread_mutexattr_init( &attr )) != 0)

  00075	48 8d 4c 24 24	 lea	 rcx, QWORD PTR attr$2[rsp]
  0007a	e8 00 00 00 00	 call	 fthread_mutexattr_init
  0007f	89 44 24 20	 mov	 DWORD PTR rc$1[rsp], eax
  00083	83 7c 24 20 00	 cmp	 DWORD PTR rc$1[rsp], 0
  00088	74 01		 je	 SHORT $LN5@ptt_trace_

; 434  :             BREAK_INTO_DEBUGGER();

  0008a	cc		 int	 3
$LN5@ptt_trace_:

; 435  :         if ((rc = hthread_mutexattr_settype( &attr, HTHREAD_MUTEX_DEFAULT )) != 0)

  0008b	ba 65 63 6e 4f	 mov	 edx, 1332634469		; 4f6e6365H
  00090	48 8d 4c 24 24	 lea	 rcx, QWORD PTR attr$2[rsp]
  00095	e8 00 00 00 00	 call	 fthread_mutexattr_settype
  0009a	89 44 24 20	 mov	 DWORD PTR rc$1[rsp], eax
  0009e	83 7c 24 20 00	 cmp	 DWORD PTR rc$1[rsp], 0
  000a3	74 01		 je	 SHORT $LN6@ptt_trace_

; 436  :             BREAK_INTO_DEBUGGER();

  000a5	cc		 int	 3
$LN6@ptt_trace_:

; 437  :         if ((rc = hthread_mutex_init( &pttlock, &attr )) != 0)

  000a6	48 8d 54 24 24	 lea	 rdx, QWORD PTR attr$2[rsp]
  000ab	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:pttlock
  000b2	e8 00 00 00 00	 call	 fthread_mutex_init
  000b7	89 44 24 20	 mov	 DWORD PTR rc$1[rsp], eax
  000bb	83 7c 24 20 00	 cmp	 DWORD PTR rc$1[rsp], 0
  000c0	74 01		 je	 SHORT $LN7@ptt_trace_

; 438  :             BREAK_INTO_DEBUGGER();

  000c2	cc		 int	 3
$LN7@ptt_trace_:

; 439  :         if ((rc = hthread_mutex_init( &ptttolock, &attr )) != 0)

  000c3	48 8d 54 24 24	 lea	 rdx, QWORD PTR attr$2[rsp]
  000c8	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:ptttolock
  000cf	e8 00 00 00 00	 call	 fthread_mutex_init
  000d4	89 44 24 20	 mov	 DWORD PTR rc$1[rsp], eax
  000d8	83 7c 24 20 00	 cmp	 DWORD PTR rc$1[rsp], 0
  000dd	74 01		 je	 SHORT $LN8@ptt_trace_

; 440  :             BREAK_INTO_DEBUGGER();

  000df	cc		 int	 3
$LN8@ptt_trace_:

; 441  :         if ((rc = hthread_cond_init( &ptttocond )) != 0)

  000e0	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:ptttocond
  000e7	e8 00 00 00 00	 call	 fthread_cond_init
  000ec	89 44 24 20	 mov	 DWORD PTR rc$1[rsp], eax
  000f0	83 7c 24 20 00	 cmp	 DWORD PTR rc$1[rsp], 0
  000f5	74 01		 je	 SHORT $LN9@ptt_trace_

; 442  :             BREAK_INTO_DEBUGGER();

  000f7	cc		 int	 3
$LN9@ptt_trace_:

; 443  :         if ((rc = hthread_mutexattr_destroy( &attr )) != 0)

  000f8	48 8d 4c 24 24	 lea	 rcx, QWORD PTR attr$2[rsp]
  000fd	e8 00 00 00 00	 call	 fthread_mutexattr_destroy
  00102	89 44 24 20	 mov	 DWORD PTR rc$1[rsp], eax
  00106	83 7c 24 20 00	 cmp	 DWORD PTR rc$1[rsp], 0
  0010b	74 01		 je	 SHORT $LN10@ptt_trace_

; 444  :             BREAK_INTO_DEBUGGER();

  0010d	cc		 int	 3
$LN10@ptt_trace_:

; 445  :         pttnolock = 0;

  0010e	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR pttnolock, 0

; 446  :         pttnotod  = 0;

  00118	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR pttnotod, 0

; 447  :         pttnowrap = 0;

  00122	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR pttnowrap, 0

; 448  :         pttto     = 0;

  0012c	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR pttto, 0

; 449  :         ptttotid  = 0;

  00136	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR ptttotid, 0
$LN4@ptt_trace_:

; 450  :     }
; 451  : }

  00140	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00144	c3		 ret	 0
ptt_trace_init ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files (x86)\Windows Kits\10\include\10.0.22000.0\ucrt\stdio.h
;	COMDAT sscanf
_TEXT	SEGMENT
_Result$ = 32
_ArgList$ = 40
_Buffer$ = 64
_Format$ = 72
sscanf	PROC						; COMDAT

; 2247 :     {

$LN3:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000f	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00014	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 2248 :         int _Result;
; 2249 :         va_list _ArgList;
; 2250 :         __crt_va_start(_ArgList, _Format);

  00018	48 8d 44 24 50	 lea	 rax, QWORD PTR _Format$[rsp+8]
  0001d	48 89 44 24 28	 mov	 QWORD PTR _ArgList$[rsp], rax

; 2251 :         _Result = _vsscanf_l(_Buffer, _Format, NULL, _ArgList);

  00022	4c 8b 4c 24 28	 mov	 r9, QWORD PTR _ArgList$[rsp]
  00027	45 33 c0	 xor	 r8d, r8d
  0002a	48 8b 54 24 48	 mov	 rdx, QWORD PTR _Format$[rsp]
  0002f	48 8b 4c 24 40	 mov	 rcx, QWORD PTR _Buffer$[rsp]
  00034	e8 00 00 00 00	 call	 _vsscanf_l
  00039	89 44 24 20	 mov	 DWORD PTR _Result$[rsp], eax

; 2252 :         __crt_va_end(_ArgList);

  0003d	48 c7 44 24 28
	00 00 00 00	 mov	 QWORD PTR _ArgList$[rsp], 0

; 2253 :         return _Result;

  00046	8b 44 24 20	 mov	 eax, DWORD PTR _Result$[rsp]

; 2254 :     }

  0004a	48 83 c4 38	 add	 rsp, 56			; 00000038H
  0004e	c3		 ret	 0
sscanf	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files (x86)\Windows Kits\10\include\10.0.22000.0\ucrt\stdio.h
;	COMDAT _vsscanf_l
_TEXT	SEGMENT
_Buffer$ = 64
_Format$ = 72
_Locale$ = 80
_ArgList$ = 88
_vsscanf_l PROC						; COMDAT

; 2152 :     {

$LN3:
  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 2153 :         return __stdio_common_vsscanf(

  00018	e8 00 00 00 00	 call	 __local_stdio_scanf_options
  0001d	48 8b 4c 24 58	 mov	 rcx, QWORD PTR _ArgList$[rsp]
  00022	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00027	48 8b 4c 24 50	 mov	 rcx, QWORD PTR _Locale$[rsp]
  0002c	48 89 4c 24 20	 mov	 QWORD PTR [rsp+32], rcx
  00031	4c 8b 4c 24 48	 mov	 r9, QWORD PTR _Format$[rsp]
  00036	49 c7 c0 ff ff
	ff ff		 mov	 r8, -1
  0003d	48 8b 54 24 40	 mov	 rdx, QWORD PTR _Buffer$[rsp]
  00042	48 8b 08	 mov	 rcx, QWORD PTR [rax]
  00045	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___stdio_common_vsscanf

; 2154 :             _CRT_INTERNAL_LOCAL_SCANF_OPTIONS,
; 2155 :             _Buffer, (size_t)-1, _Format, _Locale, _ArgList);
; 2156 :     }

  0004b	48 83 c4 38	 add	 rsp, 56			; 00000038H
  0004f	c3		 ret	 0
_vsscanf_l ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files (x86)\Windows Kits\10\include\10.0.22000.0\ucrt\corecrt_stdio_config.h
;	COMDAT __local_stdio_scanf_options
_TEXT	SEGMENT
__local_stdio_scanf_options PROC			; COMDAT

; 101  :         static unsigned __int64 _OptionsStorage;
; 102  :         return &_OptionsStorage;

  00000	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:?_OptionsStorage@?1??__local_stdio_scanf_options@@9@9 ; `__local_stdio_scanf_options'::`2'::_OptionsStorage

; 103  :     }

  00007	c3		 ret	 0
__local_stdio_scanf_options ENDP
_TEXT	ENDS
END
