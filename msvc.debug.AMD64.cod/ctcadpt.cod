; Listing generated by Microsoft (R) Optimizing Compiler Version 19.34.31937.0 

include listing.inc

INCLUDELIB MSVCRTD
INCLUDELIB OLDNAMES

PUBLIC	ctct_device_hndinfo
PUBLIC	ctce_device_hndinfo
PUBLIC	CTCX_Close
PUBLIC	CTCX_Query
PUBLIC	CTCX_ExecuteCCW
PUBLIC	CTCE_Close
PUBLIC	CTCE_Query
_DATA	SEGMENT
ctct_device_hndinfo DQ FLAT:CTCT_Init
	DQ	FLAT:CTCX_ExecuteCCW
	DQ	FLAT:CTCX_Close
	DQ	FLAT:CTCX_Query
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
$SG169191 DB	'PRE', 00H
$SG169192 DB	'CTL', 00H
ctce_device_hndinfo DQ FLAT:CTCE_Init
	DQ	FLAT:CTCE_ExecuteCCW
	DQ	FLAT:CTCE_Close
	DQ	FLAT:CTCE_Query
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	FLAT:CTCE_Reset
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	FLAT:CTCE_immed_commands
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
$SG169193 DB	'RED', 00H
$SG169194 DB	'WRT', 00H
$SG169195 DB	'SCB', 00H
$SG169196 DB	'???', 00H
$SG169197 DB	'RBK', 00H
$SG169198 DB	'WEF', 00H
$SG169199 DB	'NOP', 00H
$SG169200 DB	'SEM', 00H
$SG169201 DB	'SAS', 00H
$SG169202 DB	'SID', 00H
$SG169203 DB	'RCD', 00H
$SG169204 DB	'INV', 00H
$SG169205 DB	'RST', 00H
$SG169206 DB	'SBM', 00H
$SG169209 DB	'P', 00H
	ORG $+2
$SG169210 DB	'C', 00H
	ORG $+2
$SG169211 DB	'R', 00H
	ORG $+2
$SG169212 DB	'W', 00H
	ORG $+2
$SG169213 DB	'A', 00H
	ORG $+2
$SG169214 DB	'N', 00H
	ORG $+2
$SG169215 DB	'X', 00H
	ORG $+2
$SG169216 DB	'I', 00H
	ORG $+2
CTCE_immed_commands DB 00H
	DB	00H
	DB	00H
	DB	01H
	DB	00H
	DB	00H
	DB	00H
	DB	01H
	DB	00H
	DB	00H
	DB	00H
	DB	01H
	DB	00H
	DB	00H
	DB	00H
	DB	01H
	DB	00H
	DB	00H
	DB	00H
	DB	01H
	DB	00H
	DB	00H
	DB	00H
	DB	01H
	DB	00H
	DB	00H
	DB	00H
	DB	01H
	DB	00H
	DB	00H
	DB	00H
	DB	01H
	DB	00H
	DB	00H
	DB	00H
	DB	01H
	DB	00H
	DB	00H
	DB	00H
	DB	01H
	DB	00H
	DB	00H
	DB	00H
	DB	01H
	DB	00H
	DB	00H
	DB	00H
	DB	01H
	DB	00H
	DB	00H
	DB	00H
	DB	01H
	DB	00H
	DB	00H
	DB	00H
	DB	01H
	DB	00H
	DB	00H
	DB	00H
	DB	01H
	DB	00H
	DB	00H
	DB	00H
	DB	01H
	DB	00H
	DB	00H
	DB	00H
	DB	01H
	DB	00H
	DB	00H
	DB	00H
	DB	01H
	DB	00H
	DB	00H
	DB	00H
	DB	01H
	DB	00H
	DB	00H
	DB	00H
	DB	01H
	DB	00H
	DB	00H
	DB	00H
	DB	01H
	DB	00H
	DB	00H
	DB	00H
	DB	01H
	DB	00H
	DB	00H
	DB	00H
	DB	01H
	DB	00H
	DB	00H
	DB	00H
	DB	01H
	DB	00H
	DB	00H
	DB	00H
	DB	01H
	DB	00H
	DB	00H
	DB	00H
	DB	01H
	DB	00H
	DB	00H
	DB	00H
	DB	01H
	DB	00H
	DB	00H
	DB	00H
	DB	01H
	DB	00H
	DB	00H
	DB	00H
	DB	01H
	DB	00H
	DB	00H
	DB	00H
	DB	01H
	DB	00H
	DB	00H
	DB	00H
	DB	01H
	DB	00H
	DB	00H
	DB	00H
	DB	01H
	DB	00H
	DB	00H
	DB	00H
	DB	01H
	DB	00H
	DB	00H
	DB	00H
	DB	01H
	DB	00H
	DB	00H
	DB	00H
	DB	01H
	DB	00H
	DB	00H
	DB	00H
	DB	01H
	DB	00H
	DB	00H
	DB	00H
	DB	01H
	DB	00H
	DB	00H
	DB	00H
	DB	01H
	DB	00H
	DB	00H
	DB	00H
	DB	01H
	DB	00H
	DB	00H
	DB	00H
	DB	01H
	DB	00H
	DB	00H
	DB	00H
	DB	01H
	DB	00H
	DB	00H
	DB	00H
	DB	01H
	DB	00H
	DB	00H
	DB	00H
	DB	01H
	DB	00H
	DB	00H
	DB	00H
	DB	01H
	DB	00H
	DB	00H
	DB	00H
	DB	01H
	DB	00H
	DB	00H
	DB	00H
	DB	01H
	DB	00H
	DB	00H
	DB	00H
	DB	01H
	DB	00H
	DB	00H
	DB	00H
	DB	01H
	DB	00H
	DB	00H
	DB	00H
	DB	01H
	DB	00H
	DB	00H
	DB	00H
	DB	01H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	01H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	01H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	01H
	DB	00H
	DB	00H
	DB	00H
	DB	01H
	DB	00H
	DB	00H
	DB	00H
	DB	01H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	01H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	01H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	01H
$SG170230 DB	'--', 00H
	ORG $+1
$SG170231 DB	'->', 00H
	ORG $+1
$SG170232 DB	'<-', 00H
	ORG $+1
$SG170233 DB	'-|', 00H
	ORG $+1
$SG170234 DB	'||', 00H
_DATA	ENDS
CONST	SEGMENT
CKD_ENDTRK DB	0ffH
	DB	0ffH
	DB	0ffH
	DB	0ffH
	DB	0ffH
	DB	0ffH
	DB	0ffH
	DB	0ffH
	ORG $+8
CTCE_Fsm DB	04H
	DB	0cH
	DB	00H
	DB	048H
	DB	0ffH
	DB	0cH
	DB	00H
	DB	00H
	DB	0ffH
	DB	0cH
	DB	00H
	DB	00H
	DB	0ffH
	DB	0cH
	DB	00H
	DB	00H
	DB	00H
	DB	08H
	DB	00H
	DB	060H
	DB	04H
	DB	02H
	DB	00H
	DB	040H
	DB	0ffH
	DB	010H
	DB	00H
	DB	00H
	DB	0ffH
	DB	010H
	DB	00H
	DB	00H
	DB	01H
	DB	08H
	DB	00H
	DB	068H
	DB	0ffH
	DB	090H
	DB	00H
	DB	00H
	DB	0ffH
	DB	090H
	DB	00H
	DB	00H
	DB	0ffH
	DB	090H
	DB	00H
	DB	00H
	DB	01H
	DB	00H
	DB	00H
	DB	070H
	DB	04H
	DB	02H
	DB	00H
	DB	040H
	DB	0ffH
	DB	010H
	DB	00H
	DB	00H
	DB	0ffH
	DB	010H
	DB	00H
	DB	00H
	DB	02H
	DB	00H
	DB	00H
	DB	068H
	DB	0ffH
	DB	090H
	DB	00H
	DB	00H
	DB	0ffH
	DB	090H
	DB	00H
	DB	00H
	DB	04H
	DB	0cH
	DB	00H
	DB	048H
	DB	02H
	DB	00H
	DB	00H
	DB	070H
	DB	04H
	DB	02H
	DB	00H
	DB	040H
	DB	0ffH
	DB	010H
	DB	00H
	DB	00H
	DB	0ffH
	DB	010H
	DB	00H
	DB	00H
	DB	03H
	DB	00H
	DB	00H
	DB	068H
	DB	0ffH
	DB	090H
	DB	00H
	DB	00H
	DB	04H
	DB	0cH
	DB	00H
	DB	048H
	DB	0ffH
	DB	090H
	DB	00H
	DB	00H
	DB	03H
	DB	00H
	DB	00H
	DB	070H
	DB	04H
	DB	02H
	DB	00H
	DB	040H
	DB	0ffH
	DB	010H
	DB	00H
	DB	00H
	DB	0ffH
	DB	010H
	DB	00H
	DB	00H
	DB	0ffH
	DB	0cH
	DB	00H
	DB	00H
	DB	04H
	DB	0cH
	DB	00H
	DB	048H
	DB	0ffH
	DB	0cH
	DB	00H
	DB	00H
	DB	0ffH
	DB	0cH
	DB	00H
	DB	00H
	DB	0ffH
	DB	0cH
	DB	00H
	DB	00H
	DB	04H
	DB	02H
	DB	00H
	DB	040H
	DB	0ffH
	DB	010H
	DB	00H
	DB	00H
	DB	0ffH
	DB	010H
	DB	00H
	DB	00H
	DB	0ffH
	DB	02H
	DB	00H
	DB	00H
	DB	0ffH
	DB	02H
	DB	00H
	DB	00H
	DB	0ffH
	DB	02H
	DB	00H
	DB	00H
	DB	0ffH
	DB	02H
	DB	00H
	DB	00H
	DB	0ffH
	DB	02H
	DB	00H
	DB	00H
	DB	0ffH
	DB	02H
	DB	00H
	DB	00H
	DB	0ffH
	DB	010H
	DB	00H
	DB	00H
	DB	0ffH
	DB	010H
	DB	00H
	DB	00H
	DB	02H
	DB	00H
	DB	00H
	DB	068H
	DB	0ffH
	DB	090H
	DB	00H
	DB	00H
	DB	0ffH
	DB	090H
	DB	00H
	DB	00H
	DB	04H
	DB	0cH
	DB	00H
	DB	048H
	DB	02H
	DB	00H
	DB	00H
	DB	070H
	DB	04H
	DB	02H
	DB	00H
	DB	040H
	DB	0ffH
	DB	010H
	DB	00H
	DB	00H
	DB	0ffH
	DB	010H
	DB	00H
	DB	00H
	DB	0ffH
	DB	0cH
	DB	00H
	DB	040H
	DB	0ffH
	DB	090H
	DB	00H
	DB	00H
	DB	04H
	DB	0cH
	DB	00H
	DB	048H
	DB	0ffH
	DB	090H
	DB	00H
	DB	00H
	DB	0ffH
	DB	0cH
	DB	00H
	DB	040H
	DB	04H
	DB	02H
	DB	00H
	DB	040H
	DB	0ffH
	DB	010H
	DB	00H
	DB	00H
	DB	0ffH
	DB	010H
	DB	00H
	DB	00H
	DB	0ffH
	DB	0cH
	DB	00H
	DB	040H
	DB	0ffH
	DB	090H
	DB	00H
	DB	00H
	DB	0ffH
	DB	090H
	DB	00H
	DB	00H
	DB	0ffH
	DB	090H
	DB	00H
	DB	00H
	DB	04H
	DB	0cH
	DB	00H
	DB	040H
	DB	04H
	DB	02H
	DB	00H
	DB	040H
	DB	0ffH
	DB	010H
	DB	00H
	DB	00H
	DB	0ffH
	DB	010H
	DB	00H
	DB	00H
	DB	0ffH
	DB	0cH
	DB	00H
	DB	040H
	DB	0ffH
	DB	090H
	DB	00H
	DB	00H
	DB	0ffH
	DB	090H
	DB	00H
	DB	00H
	DB	0ffH
	DB	090H
	DB	00H
	DB	00H
	DB	04H
	DB	0cH
	DB	00H
	DB	040H
	DB	04H
	DB	02H
	DB	00H
	DB	040H
	DB	0ffH
	DB	010H
	DB	00H
	DB	00H
	DB	0ffH
	DB	010H
	DB	00H
	DB	00H
	DB	0ffH
	DB	0cH
	DB	00H
	DB	00H
	DB	0ffH
	DB	0cH
	DB	00H
	DB	00H
	DB	0ffH
	DB	0cH
	DB	00H
	DB	00H
	DB	0ffH
	DB	0cH
	DB	00H
	DB	00H
	DB	0ffH
	DB	0cH
	DB	00H
	DB	00H
	DB	0ffH
	DB	0cH
	DB	00H
	DB	00H
	DB	0ffH
	DB	010H
	DB	00H
	DB	00H
	DB	0ffH
	DB	010H
	DB	00H
	DB	00H
	DB	0ffH
	DB	0cH
	DB	00H
	DB	00H
	DB	0ffH
	DB	0cH
	DB	00H
	DB	00H
	DB	0ffH
	DB	0cH
	DB	00H
	DB	00H
	DB	0ffH
	DB	0cH
	DB	00H
	DB	00H
	DB	0ffH
	DB	0cH
	DB	00H
	DB	00H
	DB	0ffH
	DB	0cH
	DB	00H
	DB	00H
	DB	0ffH
	DB	010H
	DB	00H
	DB	00H
	DB	0ffH
	DB	010H
	DB	00H
	DB	00H
	DB	0ffH
	DB	0cH
	DB	00H
	DB	00H
	DB	0ffH
	DB	0cH
	DB	00H
	DB	00H
	DB	0ffH
	DB	0cH
	DB	00H
	DB	00H
	DB	0ffH
	DB	0cH
	DB	00H
	DB	00H
	DB	0ffH
	DB	0cH
	DB	00H
	DB	00H
	DB	0ffH
	DB	0cH
	DB	00H
	DB	00H
	DB	0ffH
	DB	010H
	DB	00H
	DB	00H
	DB	0ffH
	DB	010H
	DB	00H
	DB	00H
	DB	0ffH
	DB	02H
	DB	00H
	DB	00H
	DB	0ffH
	DB	02H
	DB	00H
	DB	00H
	DB	0ffH
	DB	02H
	DB	00H
	DB	00H
	DB	0ffH
	DB	02H
	DB	00H
	DB	00H
	DB	0ffH
	DB	02H
	DB	00H
	DB	00H
	DB	0ffH
	DB	02H
	DB	00H
	DB	00H
	DB	0ffH
	DB	010H
	DB	00H
	DB	00H
	DB	0ffH
	DB	010H
	DB	00H
	DB	00H
	DB	05H
	DB	0eH
	DB	00H
	DB	048H
	DB	05H
	DB	0eH
	DB	00H
	DB	048H
	DB	05H
	DB	0eH
	DB	00H
	DB	048H
	DB	05H
	DB	0eH
	DB	00H
	DB	048H
	DB	05H
	DB	00H
	DB	00H
	DB	040H
	DB	05H
	DB	00H
	DB	00H
	DB	040H
	DB	05H
	DB	0eH
	DB	00H
	DB	040H
	DB	05H
	DB	0eH
	DB	00H
	DB	040H
	DB	0ffH
	DB	0cH
	DB	00H
	DB	040H
	DB	0ffH
	DB	090H
	DB	00H
	DB	00H
	DB	0ffH
	DB	090H
	DB	00H
	DB	00H
	DB	0ffH
	DB	090H
	DB	00H
	DB	00H
	DB	04H
	DB	0cH
	DB	00H
	DB	040H
	DB	04H
	DB	02H
	DB	00H
	DB	040H
	DB	0ffH
	DB	010H
	DB	00H
	DB	00H
	DB	0ffH
	DB	010H
	DB	00H
	DB	00H
?cfgdata@?1??CTCE_Build_RCD@@9@9 DB 0c8H		; `CTCE_Build_RCD'::`2'::cfgdata
	DB	01H
	DB	09H
	DB	00H
	DB	0f0H
	DB	0f0H
	DB	0f3H
	DB	0f0H
	DB	0f8H
	DB	0f8H
	DB	0c3H
	DB	0e3H
	DB	0c3H
	DB	0c8H
	DB	0d9H
	DB	0c3H
	DB	0e9H
	DB	0e9H
	DB	0f0H
	DB	0f0H
	DB	0f0H
	DB	0f0H
	DB	0c1H
	DB	0f0H
	DB	0f0H
	DB	0f0H
	DB	0f0H
	DB	0f0H
	DB	0f0H
	DB	0f0H
	DB	00H
	DB	00H
	DB	040H
	DB	00H
	DB	00H
	DB	00H
	DB	0f0H
	DB	0f0H
	DB	0f3H
	DB	0f0H
	DB	0f8H
	DB	0f8H
	DB	0c3H
	DB	0e3H
	DB	0c3H
	DB	0c8H
	DB	0d9H
	DB	0c3H
	DB	0e9H
	DB	0e9H
	DB	0f0H
	DB	0f0H
	DB	0f0H
	DB	0f0H
	DB	0c2H
	DB	0f0H
	DB	0f0H
	DB	0f0H
	DB	0f0H
	DB	0f0H
	DB	0f0H
	DB	0f0H
	DB	00H
	DB	00H
	DB	0e8H
	DB	01H
	DB	09H
	DB	00H
	DB	0f0H
	DB	0f0H
	DB	0f2H
	DB	0f8H
	DB	0f1H
	DB	0f7H
	DB	0c3H
	DB	0e3H
	DB	0c3H
	DB	0c8H
	DB	0d9H
	DB	0c3H
	DB	0e9H
	DB	0e9H
	DB	0f0H
	DB	0f0H
	DB	0f0H
	DB	0f0H
	DB	0f0H
	DB	0f0H
	DB	0f0H
	DB	0f0H
	DB	0f0H
	DB	0f0H
	DB	0f0H
	DB	0f0H
	DB	00H
	DB	0e1H
	DB	080H
	DB	00H
	DB	00H
	DB	01H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
CONST	ENDS
PUBLIC	__local_stdio_scanf_options
PUBLIC	_vsscanf_l
PUBLIC	sscanf
PUBLIC	fetch_hw_noswap
PUBLIC	store_hw_noswap
PUBLIC	fetch_fw_noswap
EXTRN	__report_rangecheckfailure:PROC
EXTRN	strchr:PROC
EXTRN	strcmp:PROC
EXTRN	strcpy:PROC
EXTRN	__imp__stricmp:PROC
EXTRN	strlen:PROC
EXTRN	__imp_free:PROC
EXTRN	__imp_malloc:PROC
EXTRN	_byteswap_ushort:PROC
EXTRN	_byteswap_ulong:PROC
EXTRN	__imp_strtoul:PROC
EXTRN	__imp_bind:PROC
EXTRN	__imp_connect:PROC
EXTRN	__imp_getsockname:PROC
EXTRN	__imp_htonl:PROC
EXTRN	__imp_htons:PROC
EXTRN	__imp_inet_ntoa:PROC
EXTRN	__imp_listen:PROC
EXTRN	__imp_ntohs:PROC
EXTRN	__imp_setsockopt:PROC
EXTRN	__imp_shutdown:PROC
EXTRN	__imp_gethostbyname:PROC
EXTRN	__imp_WSAGetLastError:PROC
EXTRN	__imp_close:PROC
EXTRN	__imp___acrt_iob_func:PROC
EXTRN	__imp___stdio_common_vsscanf:PROC
EXTRN	__imp_fthread_self:PROC
EXTRN	__imp_hthread_initialize_lock:PROC
EXTRN	__imp_hthread_obtain_lock:PROC
EXTRN	__imp_hthread_release_lock:PROC
EXTRN	__imp_hthread_initialize_condition:PROC
EXTRN	__imp_hthread_signal_condition:PROC
EXTRN	__imp_hthread_create_thread:PROC
EXTRN	__imp_strlcpy:PROC
EXTRN	__imp_strlcat:PROC
EXTRN	__imp_timed_wait_condition_relative_usecs_impl:PROC
EXTRN	__imp_w32_strerror:PROC
EXTRN	__imp_usleep:PROC
EXTRN	__imp_inet_aton:PROC
EXTRN	__imp_socket_is_socket:PROC
EXTRN	__imp_set_socket_keepalive:PROC
EXTRN	__imp_w32_socket:PROC
EXTRN	__imp_w32_accept:PROC
EXTRN	__imp_w32_close_socket:PROC
EXTRN	__imp_w32_FD_SET:PROC
EXTRN	__imp_w32_select:PROC
EXTRN	__imp_w32_snprintf:PROC
EXTRN	__imp_w32_basename:PROC
EXTRN	__imp_guest_to_host:PROC
EXTRN	__imp_read_socket:PROC
EXTRN	__imp_write_socket:PROC
EXTRN	devinit_cmd:PROC
EXTRN	device_attention:PROC
EXTRN	__imp_fwritemsg:PROC
EXTRN	packet_trace:PROC
EXTRN	net_data_trace:PROC
EXTRN	__GSHandlerCheck:PROC
EXTRN	__chkstk:PROC
EXTRN	__security_check_cookie:PROC
EXTRN	__imp_sysblk:BYTE
EXTRN	__ImageBase:BYTE
EXTRN	__security_cookie:QWORD
_DATA	SEGMENT
COMM	?_OptionsStorage@?1??__local_stdio_scanf_options@@9@9:QWORD							; `__local_stdio_scanf_options'::`2'::_OptionsStorage
_DATA	ENDS
_BSS	SEGMENT
$SG169399 DB	01H DUP (?)
	ALIGN	8

?tv@?1??CTCT_Read@@9@9 DQ 01H DUP (?)			; `CTCT_Read'::`2'::tv
$SG169631 DB	01H DUP (?)
	ALIGN	4

$SG169795 DB	01H DUP (?)
	ALIGN	4

$SG169961 DB	01H DUP (?)
	ALIGN	4

$SG170307 DB	01H DUP (?)
	ALIGN	4

$SG170309 DB	01H DUP (?)
	ALIGN	4

$SG170311 DB	01H DUP (?)
	ALIGN	4

$SG170313 DB	01H DUP (?)
	ALIGN	4

$SG170359 DB	01H DUP (?)
	ALIGN	4

$SG170374 DB	01H DUP (?)
_BSS	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$_vsscanf_l DD imagerel $LN3
	DD	imagerel $LN3+80
	DD	imagerel $unwind$_vsscanf_l
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$sscanf DD imagerel $LN3
	DD	imagerel $LN3+79
	DD	imagerel $unwind$sscanf
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$fetch_hw_noswap DD imagerel $LN3
	DD	imagerel $LN3+30
	DD	imagerel $unwind$fetch_hw_noswap
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$fetch_fw_noswap DD imagerel $LN3
	DD	imagerel $LN3+27
	DD	imagerel $unwind$fetch_fw_noswap
pdata	ENDS
pdata	SEGMENT
$pdata$CTCX_Close DD imagerel $LN6
	DD	imagerel $LN6+102
	DD	imagerel $unwind$CTCX_Close
$pdata$CTCX_Query DD imagerel $LN11
	DD	imagerel $LN11+368
	DD	imagerel $unwind$CTCX_Query
$pdata$CTCX_ExecuteCCW DD imagerel $LN64
	DD	imagerel $LN64+1556
	DD	imagerel $unwind$CTCX_ExecuteCCW
$pdata$CTCE_Close DD imagerel $LN5
	DD	imagerel $LN5+160
	DD	imagerel $unwind$CTCE_Close
$pdata$CTCE_Query DD imagerel $LN17
	DD	imagerel $LN17+569
	DD	imagerel $unwind$CTCE_Query
$pdata$SetSIDInfo DD imagerel SetSIDInfo
	DD	imagerel SetSIDInfo+269
	DD	imagerel $unwind$SetSIDInfo
$pdata$SetCIWInfo DD imagerel SetCIWInfo
	DD	imagerel SetCIWInfo+256
	DD	imagerel $unwind$SetCIWInfo
$pdata$CTCT_Init DD imagerel CTCT_Init
	DD	imagerel CTCT_Init+3890
	DD	imagerel $unwind$CTCT_Init
$pdata$CTCT_Read DD imagerel CTCT_Read
	DD	imagerel CTCT_Read+1479
	DD	imagerel $unwind$CTCT_Read
$pdata$CTCT_Write DD imagerel CTCT_Write
	DD	imagerel CTCT_Write+2020
	DD	imagerel $unwind$CTCT_Write
$pdata$CTCT_ListenThread DD imagerel CTCT_ListenThread
	DD	imagerel CTCT_ListenThread+443
	DD	imagerel $unwind$CTCT_ListenThread
$pdata$CTCE_ExecuteCCW DD imagerel CTCE_ExecuteCCW
	DD	imagerel CTCE_ExecuteCCW+5600
	DD	imagerel $unwind$CTCE_ExecuteCCW
$pdata$CTCE_Init DD imagerel CTCE_Init
	DD	imagerel CTCE_Init+3627
	DD	imagerel $unwind$CTCE_Init
$pdata$CTCE_Start_Listen_Connect_Threads DD imagerel CTCE_Start_Listen_Connect_Threads
	DD	imagerel CTCE_Start_Listen_Connect_Threads+1481
	DD	imagerel $unwind$CTCE_Start_Listen_Connect_Threads
$pdata$CTCE_Start_ConnectThread DD imagerel CTCE_Start_ConnectThread
	DD	imagerel CTCE_Start_ConnectThread+956
	DD	imagerel $unwind$CTCE_Start_ConnectThread
$pdata$CTCE_Send DD imagerel CTCE_Send
	DD	imagerel CTCE_Send+2776
	DD	imagerel $unwind$CTCE_Send
$pdata$CTCE_RecvThread DD imagerel CTCE_RecvThread
	DD	imagerel CTCE_RecvThread+6445
	DD	imagerel $unwind$CTCE_RecvThread
$pdata$CTCE_ListenThread DD imagerel CTCE_ListenThread
	DD	imagerel CTCE_ListenThread+2916
	DD	imagerel $unwind$CTCE_ListenThread
$pdata$CTCE_Reset DD imagerel CTCE_Reset
	DD	imagerel CTCE_Reset+3621
	DD	imagerel $unwind$CTCE_Reset
$pdata$CTCE_ChkSum DD imagerel CTCE_ChkSum
	DD	imagerel CTCE_ChkSum+160
	DD	imagerel $unwind$CTCE_ChkSum
$pdata$CTCE_Trace DD imagerel CTCE_Trace
	DD	imagerel CTCE_Trace+6927
	DD	imagerel $unwind$CTCE_Trace
$pdata$CTCE_ConnectThread DD imagerel CTCE_ConnectThread
	DD	imagerel CTCE_ConnectThread+2013
	DD	imagerel $unwind$CTCE_ConnectThread
$pdata$CTCE_Get_Socket DD imagerel CTCE_Get_Socket
	DD	imagerel CTCE_Get_Socket+1775
	DD	imagerel $unwind$CTCE_Get_Socket
$pdata$CTCE_Write_Init DD imagerel CTCE_Write_Init
	DD	imagerel CTCE_Write_Init+722
	DD	imagerel $unwind$CTCE_Write_Init
$pdata$CTCE_Recovery DD imagerel CTCE_Recovery
	DD	imagerel CTCE_Recovery+414
	DD	imagerel $unwind$CTCE_Recovery
$pdata$CTCE_Build_RCD DD imagerel CTCE_Build_RCD
	DD	imagerel CTCE_Build_RCD+351
	DD	imagerel $unwind$CTCE_Build_RCD
pdata	ENDS
_DATA	SEGMENT
	ORG $+13
CTCE_CmdStr DQ	FLAT:$SG169191
	DQ	FLAT:$SG169192
	DQ	FLAT:$SG169193
	DQ	FLAT:$SG169194
	DQ	FLAT:$SG169195
	DQ	FLAT:$SG169196
	DQ	FLAT:$SG169197
	DQ	FLAT:$SG169198
	DQ	FLAT:$SG169199
	DQ	FLAT:$SG169200
	DQ	FLAT:$SG169201
	DQ	FLAT:$SG169202
	DQ	FLAT:$SG169203
	DQ	FLAT:$SG169204
	DQ	FLAT:$SG169205
	DQ	FLAT:$SG169206
CTCE_command DB	0eH
	DB	03H
	DB	02H
	DB	08H
	DB	0aH
	DB	03H
	DB	02H
	DB	01H
	DB	0dH
	DB	03H
	DB	02H
	DB	08H
	DB	06H
	DB	03H
	DB	02H
	DB	01H
	DB	0dH
	DB	03H
	DB	02H
	DB	08H
	DB	04H
	DB	03H
	DB	02H
	DB	01H
	DB	0dH
	DB	03H
	DB	02H
	DB	08H
	DB	06H
	DB	03H
	DB	02H
	DB	01H
	DB	0dH
	DB	03H
	DB	02H
	DB	08H
	DB	0dH
	DB	03H
	DB	02H
	DB	01H
	DB	0dH
	DB	03H
	DB	02H
	DB	08H
	DB	06H
	DB	03H
	DB	02H
	DB	01H
	DB	0dH
	DB	03H
	DB	02H
	DB	08H
	DB	04H
	DB	03H
	DB	02H
	DB	01H
	DB	0dH
	DB	03H
	DB	02H
	DB	08H
	DB	06H
	DB	03H
	DB	02H
	DB	01H
	DB	0dH
	DB	03H
	DB	02H
	DB	0fH
	DB	0dH
	DB	03H
	DB	02H
	DB	01H
	DB	0dH
	DB	03H
	DB	02H
	DB	0fH
	DB	06H
	DB	03H
	DB	02H
	DB	01H
	DB	0dH
	DB	03H
	DB	02H
	DB	0fH
	DB	04H
	DB	03H
	DB	02H
	DB	01H
	DB	0dH
	DB	03H
	DB	02H
	DB	0fH
	DB	06H
	DB	03H
	DB	02H
	DB	01H
	DB	0dH
	DB	03H
	DB	02H
	DB	0fH
	DB	0dH
	DB	03H
	DB	02H
	DB	01H
	DB	0dH
	DB	03H
	DB	02H
	DB	0fH
	DB	06H
	DB	03H
	DB	02H
	DB	01H
	DB	0dH
	DB	03H
	DB	02H
	DB	0fH
	DB	04H
	DB	03H
	DB	02H
	DB	01H
	DB	0dH
	DB	03H
	DB	02H
	DB	0fH
	DB	06H
	DB	03H
	DB	02H
	DB	01H
	DB	0dH
	DB	07H
	DB	02H
	DB	08H
	DB	0dH
	DB	07H
	DB	02H
	DB	01H
	DB	0dH
	DB	07H
	DB	02H
	DB	08H
	DB	06H
	DB	07H
	DB	02H
	DB	01H
	DB	0dH
	DB	07H
	DB	02H
	DB	08H
	DB	04H
	DB	07H
	DB	02H
	DB	01H
	DB	0dH
	DB	07H
	DB	02H
	DB	08H
	DB	06H
	DB	07H
	DB	02H
	DB	01H
	DB	0dH
	DB	07H
	DB	02H
	DB	08H
	DB	0dH
	DB	07H
	DB	02H
	DB	01H
	DB	0dH
	DB	07H
	DB	02H
	DB	08H
	DB	06H
	DB	07H
	DB	02H
	DB	01H
	DB	0dH
	DB	07H
	DB	02H
	DB	08H
	DB	04H
	DB	07H
	DB	02H
	DB	01H
	DB	0dH
	DB	07H
	DB	02H
	DB	08H
	DB	06H
	DB	07H
	DB	02H
	DB	01H
	DB	0dH
	DB	07H
	DB	02H
	DB	09H
	DB	0cH
	DB	07H
	DB	02H
	DB	01H
	DB	0dH
	DB	07H
	DB	02H
	DB	0dH
	DB	06H
	DB	07H
	DB	02H
	DB	01H
	DB	0dH
	DB	07H
	DB	02H
	DB	0dH
	DB	04H
	DB	07H
	DB	02H
	DB	01H
	DB	0dH
	DB	07H
	DB	02H
	DB	0dH
	DB	06H
	DB	07H
	DB	02H
	DB	01H
	DB	0dH
	DB	07H
	DB	02H
	DB	00H
	DB	0bH
	DB	07H
	DB	02H
	DB	01H
	DB	0dH
	DB	07H
	DB	02H
	DB	0dH
	DB	06H
	DB	07H
	DB	02H
	DB	01H
	DB	0dH
	DB	07H
	DB	02H
	DB	0dH
	DB	04H
	DB	07H
	DB	02H
	DB	01H
	DB	0dH
	DB	07H
	DB	02H
	DB	0dH
	DB	06H
	DB	07H
	DB	02H
	DB	01H
CTCE_StaStr DQ	FLAT:$SG169209
	DQ	FLAT:$SG169210
	DQ	FLAT:$SG169211
	DQ	FLAT:$SG169212
	DQ	FLAT:$SG169213
	DQ	FLAT:$SG169214
	DQ	FLAT:$SG169215
	DQ	FLAT:$SG169216
$SG169271 DB	'CTCA', 00H
	ORG $+3
$SG169277 DB	'.', 00H
	ORG $+2
$SG169401 DB	'CTC', 00H
$SG169278 DB	'%s IO[%llu]', 00H
$SG169402 DB	'E', 00H
	ORG $+2
$SG169403 DB	'HHC00915%s %1d:%04X %s: Incorrect number of parameters', 0aH
	DB	00H
$SG169404 DB	'CTCT_Init', 00H
	ORG $+2
$SG169410 DB	'CTC', 00H
$SG169405 DB	'ctcadpt.c', 00H
	ORG $+2
$SG169408 DB	'%u%c', 00H
	ORG $+3
$SG169411 DB	'E', 00H
	ORG $+2
$SG169409 DB	'port number', 00H
$SG169419 DB	'CTC', 00H
$SG169412 DB	'HHC00916%s %1d:%04X %s: Option %s value %s invalid', 0aH
	DB	00H
$SG169420 DB	'E', 00H
	ORG $+2
$SG169413 DB	'CTCT_Init', 00H
	ORG $+2
$SG169428 DB	'CTC', 00H
$SG169414 DB	'ctcadpt.c', 00H
	ORG $+2
$SG169429 DB	'E', 00H
	ORG $+2
$SG169418 DB	'IP address', 00H
	ORG $+1
$SG169437 DB	'CTC', 00H
$SG169421 DB	'HHC00916%s %1d:%04X %s: Option %s value %s invalid', 0aH
	DB	00H
$SG169438 DB	'E', 00H
	ORG $+2
$SG169422 DB	'CTCT_Init', 00H
	ORG $+2
$SG169444 DB	'CTC', 00H
$SG169423 DB	'ctcadpt.c', 00H
	ORG $+2
$SG169426 DB	'%u%c', 00H
	ORG $+3
$SG169445 DB	'E', 00H
	ORG $+2
$SG169427 DB	'port number', 00H
$SG169451 DB	'CTC', 00H
$SG169430 DB	'HHC00916%s %1d:%04X %s: Option %s value %s invalid', 0aH
	DB	00H
$SG169452 DB	'E', 00H
	ORG $+2
$SG169431 DB	'CTCT_Init', 00H
	ORG $+2
$SG169450 DB	'bind()', 00H
	ORG $+1
$SG169458 DB	'I', 00H
	ORG $+2
$SG169432 DB	'ctcadpt.c', 00H
	ORG $+2
$SG169435 DB	'%u%c', 00H
	ORG $+3
$SG169464 DB	'CTC', 00H
$SG169436 DB	'MTU size', 00H
	ORG $+3
$SG169465 DB	'E', 00H
	ORG $+2
$SG169439 DB	'HHC00916%s %1d:%04X %s: Option %s value %s invalid', 0aH
	DB	00H
$SG169471 DB	'CTC', 00H
$SG169440 DB	'CTCT_Init', 00H
	ORG $+2
$SG169470 DB	'bind()', 00H
	ORG $+1
$SG169472 DB	'E', 00H
	ORG $+2
$SG169441 DB	'ctcadpt.c', 00H
	ORG $+2
$SG169478 DB	'CTC', 00H
$SG169443 DB	'socket()', 00H
	ORG $+3
$SG169479 DB	'E', 00H
	ORG $+2
$SG169446 DB	'HHC00900%s %1d:%04X %s: Error in function %s: %s', 0aH, 00H
	ORG $+2
$SG169486 DB	'E', 00H
	ORG $+2
$SG169447 DB	'CTCT_Init', 00H
	ORG $+2
$SG169490 DB	'I', 00H
	ORG $+2
$SG169448 DB	'ctcadpt.c', 00H
	ORG $+2
$SG169537 DB	'E', 00H
	ORG $+2
$SG169453 DB	'HHC00900%s %1d:%04X %s: Error in function %s: %s', 0aH, 00H
	ORG $+2
$SG169542 DB	'I', 00H
	ORG $+2
$SG169454 DB	'CTCT_Init', 00H
	ORG $+2
$SG169548 DB	'E', 00H
	ORG $+2
$SG169455 DB	'ctcadpt.c', 00H
	ORG $+6
$SG169459 DB	'HHC00971%s %1d:%04X CTC: connect to %s:%s failed, starti'
	DB	'ng server', 0aH, 00H
	ORG $+1
$SG169554 DB	'E', 00H
	ORG $+2
$SG169460 DB	'CTCT_Init', 00H
	ORG $+2
$SG169559 DB	'I', 00H
	ORG $+2
$SG169461 DB	'ctcadpt.c', 00H
	ORG $+2
$SG169565 DB	'E', 00H
	ORG $+2
$SG169463 DB	'socket()', 00H
	ORG $+3
$SG169494 DB	'%s:%s', 00H
	ORG $+2
$SG169619 DB	'E', 00H
	ORG $+2
$SG169466 DB	'HHC00900%s %1d:%04X %s: Error in function %s: %s', 0aH, 00H
	ORG $+2
$SG169625 DB	'E', 00H
	ORG $+2
$SG169467 DB	'CTCT_Init', 00H
	ORG $+2
$SG169630 DB	'TUN', 00H
$SG169468 DB	'ctcadpt.c', 00H
	ORG $+2
$SG169632 DB	'CTC', 00H
$SG169473 DB	'HHC00900%s %1d:%04X %s: Error in function %s: %s', 0aH, 00H
	ORG $+2
$SG169633 DB	'I', 00H
	ORG $+2
$SG169474 DB	'CTCT_Init', 00H
	ORG $+2
$SG169655 DB	'E', 00H
	ORG $+2
$SG169475 DB	'ctcadpt.c', 00H
	ORG $+2
$SG169677 DB	'.', 00H
	ORG $+2
$SG169477 DB	'listen()', 00H
	ORG $+3
$SG169652 DB	'%s:%d', 00H
	ORG $+2
$SG169678 DB	'>', 00H
	ORG $+2
$SG169480 DB	'HHC00900%s %1d:%04X %s: Error in function %s: %s', 0aH, 00H
	ORG $+2
$SG169679 DB	'!', 00H
	ORG $+2
$SG169481 DB	'CTCT_Init', 00H
	ORG $+2
$SG169680 DB	'-', 00H
	ORG $+2
$SG169482 DB	'ctcadpt.c', 00H
	ORG $+2
$SG169681 DB	'=', 00H
	ORG $+2
$SG169483 DB	'CTCT %4.4X ListenThread', 00H
$SG169484 DB	'ctcadpt.c:1181', 00H
	ORG $+1
$SG169487 DB	'HHC00102%s Error in function create_thread(): %s', 0aH, 00H
	ORG $+2
$SG169682 DB	'<', 00H
	ORG $+2
$SG169488 DB	'CTCT_Init', 00H
	ORG $+2
$SG169683 DB	'!', 00H
	ORG $+2
$SG169489 DB	'ctcadpt.c', 00H
	ORG $+2
$SG169809 DB	'W', 00H
	ORG $+2
$SG169491 DB	'HHC00972%s %1d:%04X CTC: connected to %s:%s', 0aH, 00H
	ORG $+3
$SG169492 DB	'CTCT_Init', 00H
	ORG $+2
$SG169814 DB	'E', 00H
	ORG $+2
$SG169493 DB	'ctcadpt.c', 00H
	ORG $+2
$SG169824 DB	'E', 00H
	ORG $+2
$SG169538 DB	'HHC00906%s %1d:%04X CTC: write CCW count %u is invalid', 0aH
	DB	00H
$SG169539 DB	'CTCT_Write', 00H
	ORG $+1
$SG169833 DB	'E', 00H
	ORG $+2
$SG169540 DB	'ctcadpt.c', 00H
	ORG $+2
$SG169840 DB	'E', 00H
	ORG $+2
$SG169543 DB	'HHC00907%s %1d:%04X CTC: interface command: %s %8.8X', 0aH
	DB	00H
	ORG $+2
$SG169544 DB	'CTCT_Write', 00H
	ORG $+1
$SG169849 DB	'E', 00H
	ORG $+2
$SG169545 DB	'ctcadpt.c', 00H
	ORG $+6
$SG169549 DB	'HHC00908%s %1d:%04X CTC: incomplete write buffer segment'
	DB	' header at offset %4.4X', 0aH, 00H
	ORG $+3
$SG169801 DB	'FICON', 00H
	ORG $+2
$SG169855 DB	'E', 00H
	ORG $+2
$SG169550 DB	'CTCT_Write', 00H
	ORG $+1
$SG169864 DB	'E', 00H
	ORG $+2
$SG169551 DB	'ctcadpt.c', 00H
	ORG $+6
$SG169555 DB	'HHC00909%s %1d:%04X CTC: invalid write buffer segment le'
	DB	'ngth %u at offset %4.4X', 0aH, 00H
	ORG $+3
$SG169872 DB	'W', 00H
	ORG $+2
$SG169556 DB	'CTCT_Write', 00H
	ORG $+1
$SG169877 DB	'W', 00H
	ORG $+2
$SG169557 DB	'ctcadpt.c', 00H
	ORG $+2
$SG169910 DB	'I', 00H
	ORG $+2
$SG169560 DB	'HHC00934%s %1d:%04X CTC: sending packet to file %s', 0aH
	DB	00H
$SG169914 DB	'E', 00H
	ORG $+2
$SG169561 DB	'CTCT_Write', 00H
	ORG $+1
$SG169918 DB	'E', 00H
	ORG $+2
$SG169562 DB	'ctcadpt.c', 00H
	ORG $+2
$SG169923 DB	'I', 00H
	ORG $+2
$SG169566 DB	'HHC00936%s %1d:%04X CTC: error writing to file %s: %s', 0aH
	DB	00H
	ORG $+1
$SG169567 DB	'CTCT_Write', 00H
	ORG $+1
$SG169987 DB	'E', 00H
	ORG $+2
$SG169568 DB	'ctcadpt.c', 00H
	ORG $+2
$SG169993 DB	'I', 00H
	ORG $+2
$SG169615 DB	'ctcadpt.c', 00H
	ORG $+2
$SG170001 DB	'W', 00H
	ORG $+2
$SG169620 DB	'HHC00973%s %1d:%04X CTC: error reading from file %s: %s', 0aH
	DB	00H
	ORG $+3
$SG170005 DB	'E', 00H
	ORG $+2
$SG169621 DB	'CTCT_Read', 00H
	ORG $+2
$SG170009 DB	'E', 00H
	ORG $+2
$SG169622 DB	'ctcadpt.c', 00H
	ORG $+2
$SG170042 DB	'S', 00H
	ORG $+2
$SG169626 DB	'HHC00973%s %1d:%04X CTC: error reading from file %s: %s', 0aH
	DB	00H
	ORG $+3
$SG170053 DB	'S', 00H
	ORG $+2
$SG169627 DB	'CTCT_Read', 00H
	ORG $+2
$SG170058 DB	'E', 00H
	ORG $+2
$SG169628 DB	'ctcadpt.c', 00H
	ORG $+6
$SG169657 DB	'CTCT_ListenThread', 00H
	ORG $+6
$SG169634 DB	'HHC00913%s %1d:%04X %s: Receive%s packet of size %d byte'
	DB	's from device %s', 0aH, 00H
	ORG $+2
$SG170116 DB	'E', 00H
	ORG $+2
$SG169635 DB	'CTCT_Read', 00H
	ORG $+2
$SG170122 DB	'I', 00H
	ORG $+2
$SG169636 DB	'ctcadpt.c', 00H
	ORG $+6
$SG169656 DB	'HHC00974%s %1d:%04X CTC: incorrect client or config erro'
	DB	'r: config file %s connecting client %s', 0aH, 00H
$SG169658 DB	'ctcadpt.c', 00H
	ORG $+2
$SG169671 DB	'CTCA', 00H
	ORG $+3
$SG170253 DB	' CC=%d', 00H
	ORG $+1
$SG170305 DB	'.', 00H
	ORG $+2
$SG169684 DB	'CTCE %05d/%d %s%s%s %s IO[%llu]', 00H
$SG169735 DB	'ctcadpt.c:1737', 00H
	ORG $+1
$SG169759 DB	'ctcadpt.c:1897', 00H
	ORG $+1
$SG169799 DB	'ctcadpt.c:1930', 00H
	ORG $+1
$SG169800 DB	'ctcadpt.c:1932', 00H
	ORG $+1
$SG169805 DB	'ATTNDELAY', 00H
	ORG $+2
$SG169808 DB	'%u%c', 00H
	ORG $+3
$SG170254 DB	'     ', 00H
	ORG $+2
$SG170259 DB	'->NONE', 00H
	ORG $+1
$SG170314 DB	'I', 00H
	ORG $+2
$SG169810 DB	'HHC05085%s %1d:%04X CTCE: Invalid ATTNDELAY value %s ign'
	DB	'ored', 0aH, 00H
	ORG $+2
$SG169811 DB	'CTCE_Init', 00H
	ORG $+2
$SG170299 DB	' CLEAR', 00H
	ORG $+1
$SG170334 DB	'E', 00H
	ORG $+2
$SG169812 DB	'ctcadpt.c', 00H
	ORG $+6
$SG169815 DB	'HHC05055%s %1d:%04X CTCE: Missing (at least) remote CTCE'
	DB	' IP address parameter', 0aH, 00H
	ORG $+1
$SG169816 DB	'CTCE_Init', 00H
	ORG $+2
$SG170301 DB	' RESET', 00H
	ORG $+1
$SG170369 DB	'I', 00H
	ORG $+2
$SG169817 DB	'ctcadpt.c', 00H
	ORG $+2
$SG169821 DB	'%u%c', 00H
	ORG $+7
$SG169825 DB	'HHC05056%s %1d:%04X CTCE: Local port number outside rang'
	DB	'e 1024-65534: %s', 0aH, 00H
	ORG $+2
$SG170308 DB	' MATCH', 00H
	ORG $+1
$SG170375 DB	'.', 00H
	ORG $+2
$SG169826 DB	'CTCE_Init', 00H
	ORG $+2
$SG170376 DB	'I', 00H
	ORG $+2
$SG169827 DB	'ctcadpt.c', 00H
	ORG $+6
$SG169841 DB	'HHC05058%s %1d:%04X CTCE: Invalid IP address %s', 0aH, 00H
	ORG $+7
$SG169834 DB	'HHC05057%s %1d:%04X CTCE: Remote CCUU address outside ra'
	DB	'nge 0001-FFFF: %4X', 0aH, 00H
$SG170385 DB	'I', 00H
	ORG $+2
$SG169835 DB	'CTCE_Init', 00H
	ORG $+2
$SG170389 DB	'I', 00H
	ORG $+2
$SG169836 DB	'ctcadpt.c', 00H
	ORG $+2
$SG170414 DB	'listen', 00H
	ORG $+1
$SG170416 DB	'E', 00H
	ORG $+2
$SG169842 DB	'CTCE_Init', 00H
	ORG $+2
$SG170421 DB	'listen', 00H
	ORG $+1
$SG170424 DB	'E', 00H
	ORG $+2
$SG169843 DB	'ctcadpt.c', 00H
	ORG $+2
$SG169848 DB	'%u%c', 00H
	ORG $+3
$SG170266 DB	' WEOF', 00H
	ORG $+2
$SG170430 DB	'listen', 00H
	ORG $+1
$SG170433 DB	'E', 00H
	ORG $+2
$SG169850 DB	'HHC05059%s %1d:%04X CTCE: Invalid port number: %s', 0aH, 00H
	ORG $+1
$SG170442 DB	'E', 00H
	ORG $+2
$SG169851 DB	'CTCE_Init', 00H
	ORG $+2
$SG170440 DB	'listen', 00H
	ORG $+1
$SG170451 DB	'E', 00H
	ORG $+2
$SG169852 DB	'ctcadpt.c', 00H
	ORG $+2
$SG169863 DB	'%u%c', 00H
	ORG $+7
$SG169856 DB	'HHC05060%s %1d:%04X CTCE: Both remote listening port and'
	DB	' remote CCUU are missing; at least one is required.', 0aH, 00H
	ORG $+3
$SG169857 DB	'CTCE_Init', 00H
	ORG $+2
$SG170449 DB	'listen', 00H
	ORG $+1
$SG170466 DB	'E', 00H
	ORG $+2
$SG169858 DB	'ctcadpt.c', 00H
	ORG $+2
$SG169871 DB	'%u%c', 00H
	ORG $+7
$SG169865 DB	'HHC05061%s %1d:%04X CTCE: Invalid MTU size %s, allowed r'
	DB	'ange is %d to 65536', 0aH, 00H
	ORG $+3
$SG169866 DB	'CTCE_Init', 00H
	ORG $+2
$SG170481 DB	'I', 00H
	ORG $+2
$SG169867 DB	'ctcadpt.c', 00H
	ORG $+6
$SG169873 DB	'HHC05062%s %1d:%04X CTCE: Invalid Small MTU size %s igno'
	DB	'red', 0aH, 00H
	ORG $+3
$SG169874 DB	'CTCE_Init', 00H
	ORG $+6
$SG169875 DB	'ctcadpt.c', 00H
	ORG $+6
$SG169878 DB	'HHC05064%s %1d:%04X CTCE: Extraneous parameters ignored '
	DB	': %s ...', 0aH, 00H
	ORG $+6
$SG169879 DB	'CTCE_Init', 00H
	ORG $+6
$SG169880 DB	'ctcadpt.c', 00H
	ORG $+6
$SG169899 DB	'%1d:%04X=%s:%d/*', 00H
	ORG $+7
$SG169906 DB	'CTCE %4.4X ListenThread', 00H
$SG169909 DB	'ctcadpt.c:2237', 00H
	ORG $+1
$SG169912 DB	'CTCE_Start_Listen_Connect_Threads', 00H
	ORG $+6
$SG169911 DB	'HHC05063%s %1d:%04X CTCE: Awaiting inbound connection :%'
	DB	'5d <- %s', 0aH, 00H
	ORG $+6
$SG169913 DB	'ctcadpt.c', 00H
	ORG $+6
$SG169915 DB	'HHC05080%s %1d:%04X CTCE: Create listen thread %s error:'
	DB	' %s', 0aH, 00H
	ORG $+3
$SG169916 DB	'CTCE_Start_Listen_Connect_Threads', 00H
	ORG $+6
$SG169917 DB	'ctcadpt.c', 00H
	ORG $+6
$SG169919 DB	'HHC05066%s %1d:%04X CTCE: Error on call to listen (port='
	DB	'%d): %s', 0aH, 00H
	ORG $+7
$SG169920 DB	'CTCE_Start_Listen_Connect_Threads', 00H
	ORG $+6
$SG169921 DB	'ctcadpt.c', 00H
	ORG $+6
$SG169924 DB	'HHC05081%s %1d:%04X CTCE: Already awaiting connection :%'
	DB	'5d <- %s', 0aH, 00H
	ORG $+6
$SG169925 DB	'CTCE_Start_Listen_Connect_Threads', 00H
	ORG $+6
$SG169926 DB	'ctcadpt.c', 00H
	ORG $+6
$SG169969 DB	'ctcadpt.c:2344', 00H
	ORG $+1
$SG169980 DB	'%1d:%04X=%s:%d/%d', 00H
	ORG $+6
$SG169983 DB	'CTCE %04X RecvThread', 00H
	ORG $+3
$SG169986 DB	'ctcadpt.c:2413', 00H
	ORG $+1
$SG169988 DB	'HHC05069%s %1d:%04X CTCE: create_thread %s error: %s', 0aH
	DB	00H
	ORG $+2
$SG169989 DB	'CTCE_ListenThread', 00H
	ORG $+6
$SG169990 DB	'ctcadpt.c', 00H
	ORG $+6
$SG169991 DB	'Renewing', 00H
	ORG $+7
$SG169992 DB	'Accepted', 00H
	ORG $+7
$SG169994 DB	'HHC05070%s %1d:%04X CTCE: %s inbound connection :%5d <- '
	DB	'%1d:%04X=%s:%5d (bufsize=%d,%d)', 0aH, 00H
	ORG $+7
$SG169995 DB	'CTCE_ListenThread', 00H
	ORG $+6
$SG169996 DB	'ctcadpt.c', 00H
	ORG $+6
$SG169998 DB	'ctcadpt.c:2435', 00H
	ORG $+1
$SG170003 DB	'CTCE_ListenThread', 00H
	ORG $+6
$SG170002 DB	'HHC05067%s %1d:%04X CTCE: Ignoring non matching connecti'
	DB	'on from %1d:%04X=%s:%d', 0aH, 00H
$SG170004 DB	'ctcadpt.c', 00H
	ORG $+6
$SG170006 DB	'HHC05068%s %1d:%04X CTCE: TCP_NODELAY error for listenin'
	DB	'g socket %d (port %d): %s', 0aH, 00H
	ORG $+5
$SG170007 DB	'CTCE_ListenThread', 00H
	ORG $+6
$SG170008 DB	'ctcadpt.c', 00H
	ORG $+6
$SG170010 DB	'HHC05083%s %1d:%04X CTCE: Error on accept() for listenin'
	DB	'g socket %d (port %d): %s', 0aH, 00H
	ORG $+5
$SG170011 DB	'CTCE_ListenThread', 00H
	ORG $+6
$SG170012 DB	'ctcadpt.c', 00H
	ORG $+6
$SG170043 DB	'HHC05071%s %1d:%04X CTCE: Internal error, SEND status in'
	DB	'correctly encoded !', 0aH, 00H
	ORG $+3
$SG170044 DB	'CTCE_Send', 00H
	ORG $+6
$SG170045 DB	'ctcadpt.c', 00H
	ORG $+6
$SG170054 DB	'HHC05073%s %1d:%04X CTCE: bufsize parameter %d is too sm'
	DB	'all; increase at least to %d', 0aH, 00H
	ORG $+2
$SG170055 DB	'CTCE_Send', 00H
	ORG $+6
$SG170056 DB	'ctcadpt.c', 00H
	ORG $+6
$SG170059 DB	'HHC05074%s %1d:%04X CTCE: Error writing to %s: %s', 0aH, 00H
	ORG $+5
$SG170060 DB	'CTCE_Send', 00H
	ORG $+6
$SG170061 DB	'ctcadpt.c', 00H
	ORG $+6
$SG170067 DB	'ctcadpt.c:2590', 00H
	ORG $+1
$SG170068 DB	'ctcadpt.c:2591', 00H
	ORG $+1
$SG170069 DB	'ctcadpt.c:2597', 00H
	ORG $+1
$SG170070 DB	'ctcadpt.c:2599', 00H
	ORG $+1
$SG170071 DB	'ctcadpt.c:2600', 00H
	ORG $+1
$SG170110 DB	'ctcadpt.c:2693', 00H
	ORG $+1
$SG170111 DB	'ctcadpt.c:2706', 00H
	ORG $+1
$SG170113 DB	'ctcadpt.c:2727', 00H
	ORG $+1
$SG170117 DB	'HHC05077%s %1d:%04X CTCE: Error reading from %s: %s', 0aH
	DB	00H
	ORG $+3
$SG170118 DB	'CTCE_RecvThread', 00H
$SG170119 DB	'ctcadpt.c', 00H
	ORG $+6
$SG170124 DB	'CTCE_RecvThread', 00H
?CTCE_XfrStr@?1??CTCE_Trace@@9@9 DQ FLAT:$SG170230	; `CTCE_Trace'::`2'::CTCE_XfrStr
	DQ	FLAT:$SG170231
	DQ	FLAT:$SG170232
	DQ	FLAT:$SG170233
	DQ	FLAT:$SG170234
$SG170123 DB	'HHC05076%s %1d:%04X CTCE: Connection closed; %llu MB rec'
	DB	'eived in %llu packets from %s; shutdown=%d', 0aH, 00H
	ORG $+4
$SG170125 DB	'ctcadpt.c', 00H
	ORG $+6
$SG170127 DB	'ctcadpt.c:2759', 00H
	ORG $+1
$SG170134 DB	'ctcadpt.c:2831', 00H
	ORG $+1
$SG170135 DB	'ctcadpt.c:2832', 00H
	ORG $+1
$SG170136 DB	'ctcadpt.c:2833', 00H
	ORG $+1
$SG170148 DB	'ctcadpt.c:2927', 00H
	ORG $+1
$SG170149 DB	'ctcadpt.c:2928', 00H
	ORG $+1
$SG170150 DB	'ctcadpt.c:2929', 00H
	ORG $+1
$SG170152 DB	'ctcadpt.c:2936', 00H
	ORG $+1
$SG170154 DB	'ctcadpt.c:2946', 00H
	ORG $+1
$SG170159 DB	'ctcadpt.c:2980', 00H
	ORG $+1
$SG170165 DB	'ctcadpt.c:3023', 00H
	ORG $+1
$SG170173 DB	'ctcadpt.c:3059', 00H
	ORG $+1
$SG170183 DB	'ctcadpt.c:3096', 00H
	ORG $+1
$SG170184 DB	'ctcadpt.c:3097', 00H
	ORG $+1
$SG170185 DB	'ctcadpt.c:3098', 00H
	ORG $+1
$SG170249 DB	'Stat=%02X', 00H
	ORG $+6
$SG170250 DB	'       ', 00H
$SG170255 DB	' w=%d,r=%d', 00H
	ORG $+5
$SG170261 DB	'->RC=%d', 00H
$SG170263 DB	' DE_READY->RC=%d', 00H
	ORG $+3
$SG170268 DB	'->SET', 00H
	ORG $+2
$SG170270 DB	'->UX', 00H
	ORG $+3
$SG170272 DB	'->CLR', 00H
	ORG $+6
$SG170274 DB	' SCB=%02X=%s', 00H
	ORG $+3
$SG170276 DB	' Busy_Waits=%d', 00H
	ORG $+1
$SG170278 DB	' WAIT->RC=%d', 00H
	ORG $+3
$SG170282 DB	' SENSE=%02X%02X', 00H
$SG170284 DB	' SENSE=%02X%02X', 00H
$SG170287 DB	' CTCE_STATE MISMATCH %s!=%s(:FSM) !', 00H
	ORG $+4
$SG170291 DB	' Stat MISMATCH %02X!=%02X(:FSM) !', 00H
	ORG $+6
$SG170293 DB	' CON_LOSER', 00H
	ORG $+5
$SG170295 DB	' IGNORED / CON_WINNER', 00H
	ORG $+2
$SG170297 DB	' HALT', 00H
	ORG $+2
$SG170306 DB	' ATTN', 00H
	ORG $+2
$SG170310 DB	' WAIT', 00H
	ORG $+2
$SG170312 DB	' WEOF', 00H
	ORG $+2
$SG170315 DB	'HHC05079%s %1d:%04X CTCE: %s %.6s #%04X cmd=%s=%02X xy=%'
	DB	'.2s%s%.2s l=%04X k=%08X %s%s%s%s%s%s', 0aH, 00H
	ORG $+2
$SG170316 DB	'CTCE_Trace', 00H
	ORG $+5
$SG170317 DB	'ctcadpt.c', 00H
	ORG $+6
$SG170319 DB	'%1d:%04X', 00H
	ORG $+7
$SG170328 DB	'ctcadpt.c:3538', 00H
	ORG $+1
$SG170329 DB	'&dev->ctceEventLock', 00H
	ORG $+4
$SG170330 DB	'ctcadpt.c:3539', 00H
	ORG $+1
$SG170331 DB	'CTCE %4.4X ConnectThread', 00H
	ORG $+7
$SG170333 DB	'ctcadpt.c:3567', 00H
	ORG $+1
$SG170335 DB	'HHC05069%s %1d:%04X CTCE: create_thread %s error: %s', 0aH
	DB	00H
	ORG $+2
$SG170336 DB	'CTCE_Start_ConnectThread', 00H
	ORG $+7
$SG170337 DB	'ctcadpt.c', 00H
	ORG $+6
$SG170360 DB	'ctcadpt.c:3605', 00H
	ORG $+1
$SG170362 DB	'ctcadpt.c:3613', 00H
	ORG $+1
$SG170363 DB	'ctcadpt.c:3626', 00H
	ORG $+1
$SG170365 DB	'ctcadpt.c:3633', 00H
	ORG $+1
$SG170370 DB	'HHC05065%s %1d:%04X CTCE: Attempt outbound connection :%'
	DB	'5d -> %1d:%04X=%s:%d', 0aH, 00H
	ORG $+2
$SG170371 DB	'CTCE_ConnectThread', 00H
	ORG $+5
$SG170372 DB	'ctcadpt.c', 00H
	ORG $+6
$SG170378 DB	'CTCE_ConnectThread', 00H
	ORG $+5
$SG170377 DB	'HHC05072%s %1d:%04X CTCE: Still attempting connection :%'
	DB	'5d -> %1d:%04X=%s:%d%s', 0aH, 00H
$SG170379 DB	'ctcadpt.c', 00H
	ORG $+6
$SG170383 DB	'Renewed', 00H
$SG170384 DB	'Started', 00H
$SG170386 DB	'HHC05054%s %1d:%04X CTCE: %s outbound connection :%5d ->'
	DB	' %1d:%04X=%s:%d', 0aH, 00H
	ORG $+7
$SG170387 DB	'CTCE_ConnectThread', 00H
	ORG $+5
$SG170388 DB	'ctcadpt.c', 00H
	ORG $+6
$SG170391 DB	'CTCE_ConnectThread', 00H
	ORG $+5
$SG170390 DB	'HHC05078%s %1d:%04X CTCE: Aborted outbound connection :%'
	DB	'5d -> %1d:%04X=%s:%d', 0aH, 00H
	ORG $+2
$SG170392 DB	'ctcadpt.c', 00H
	ORG $+6
$SG170393 DB	'ctcadpt.c:3686', 00H
	ORG $+1
$SG170415 DB	'connect', 00H
$SG170417 DB	'HHC05050%s %1d:%04X CTCE: Error creating %s socket: %s', 0aH
	DB	00H
$SG170418 DB	'CTCE_Get_Socket', 00H
$SG170419 DB	'ctcadpt.c', 00H
	ORG $+6
$SG170422 DB	'connect', 00H
$SG170423 DB	'SO_REUSEADDR', 00H
	ORG $+3
$SG170426 DB	'CTCE_Get_Socket', 00H
$SG170431 DB	'connect', 00H
$SG170425 DB	'HHC05051%s %1d:%04X CTCE: %s error for %s socket (port %'
	DB	'd): %s', 0aH, 00H
$SG170427 DB	'ctcadpt.c', 00H
	ORG $+6
$SG170432 DB	'TCP_NODELAY', 00H
	ORG $+4
$SG170434 DB	'HHC05051%s %1d:%04X CTCE: %s error for %s socket (port %'
	DB	'd): %s', 0aH, 00H
$SG170435 DB	'CTCE_Get_Socket', 00H
$SG170436 DB	'ctcadpt.c', 00H
	ORG $+6
$SG170441 DB	'connect', 00H
$SG170450 DB	'connect', 00H
$SG170443 DB	'HHC05052%s %1d:%04X CTCE: Error binding to %s socket (po'
	DB	'rt %d): %s', 0aH, 00H
	ORG $+4
$SG170444 DB	'CTCE_Get_Socket', 00H
$SG170445 DB	'ctcadpt.c', 00H
	ORG $+6
$SG170453 DB	'CTCE_Get_Socket', 00H
$SG170479 DB	'DEVINIT', 00H
$SG170452 DB	'HHC05053%s %1d:%04X CTCE: Error on getsockname for %s so'
	DB	'cket (port %d): %s', 0aH, 00H
	ORG $+4
$SG170454 DB	'ctcadpt.c', 00H
	ORG $+6
$SG170467 DB	'HHC05075%s %1d:%04X CTCE: Initial write_socket :%d -> %1'
	DB	'd:%04X=%s:%d ; rc=%d!=%d ; error = %s', 0aH, 00H
	ORG $+1
$SG170468 DB	'CTCE_Write_Init', 00H
$SG170469 DB	'ctcadpt.c', 00H
	ORG $+6
$SG170480 DB	'%1d:%04X', 00H
	ORG $+7
$SG170482 DB	'HHC05086%s %1d:%04X CTCE: Recovery is about to issue Her'
	DB	'cules command: %s %s', 0aH, 00H
	ORG $+2
$SG170483 DB	'CTCE_Recovery', 00H
	ORG $+2
$SG170484 DB	'ctcadpt.c', 00H
	ORG $+6
$SG170485 DB	'ctcadpt.c:3842', 00H
	ORG $+1
$SG170486 DB	'ctcadpt.c:3844', 00H
_DATA	ENDS
voltbl	SEGMENT
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:CTCE_Build_RCD
	DD	022H
	DD	0145H
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:CTCE_Recovery
	DD	016H
	DD	0186H
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:CTCE_Get_Socket
	DD	01bH
	DD	06d6H
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:CTCE_ConnectThread
	DD	017H
	DD	07c4H
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:CTCE_Trace
	DD	02cH
	DD	01aefH
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:CTCE_Reset
	DD	017H
	DD	0e0cH
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:CTCE_ListenThread
	DD	018H
	DD	0b4aH
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:CTCE_RecvThread
	DD	016H
	DD	01915H
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:CTCE_Start_ConnectThread
	DD	016H
	DD	03a4H
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:CTCE_Start_Listen_Connect_Threads
	DD	018H
	DD	05afH
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:CTCE_Init
	DD	021H
	DD	0e11H
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:CTCE_ExecuteCCW
	DD	026H
	DD	01584H
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:CTCT_ListenThread
	DD	018H
	DD	01a1H
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:CTCT_Write
	DD	024H
	DD	07ccH
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:CTCT_Read
	DD	02cH
	DD	05adH
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:CTCT_Init
	DD	021H
	DD	0f18H
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:CTCE_Query
	DD	025H
	DD	0221H
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:CTCX_Query
	DD	025H
	DD	0158H
voltbl	ENDS
xdata	SEGMENT
$unwind$CTCX_Close DD 010901H
	DD	04209H
$unwind$CTCX_Query DD 022d19H
	DD	02d011bH
	DD	imagerel __GSHandlerCheck
	DD	0150H
$unwind$CTCX_ExecuteCCW DD 031901H
	DD	07015a219H
	DD	06014H
$unwind$CTCE_Close DD 010901H
	DD	04209H
$unwind$CTCE_Query DD 022d19H
	DD	033011bH
	DD	imagerel __GSHandlerCheck
	DD	0180H
$unwind$SetSIDInfo DD 021a01H
	DD	07016121aH
$unwind$SetCIWInfo DD 011801H
	DD	02218H
$unwind$CTCT_Init DD 042919H
	DD	03d0117H
	DD	0600f7010H
	DD	imagerel __GSHandlerCheck
	DD	01d0H
$unwind$CTCT_Read DD 043419H
	DD	041f0122H
	DD	060147015H
	DD	imagerel __GSHandlerCheck
	DD	020e0H
$unwind$CTCT_Write DD 022c19H
	DD	023011aH
	DD	imagerel __GSHandlerCheck
	DD	0108H
$unwind$CTCT_ListenThread DD 042019H
	DD	021010eH
	DD	060067007H
	DD	imagerel __GSHandlerCheck
	DD	0f0H
$unwind$CTCE_ExecuteCCW DD 042e19H
	DD	029011cH
	DD	060147015H
	DD	imagerel __GSHandlerCheck
	DD	0138H
$unwind$CTCE_Init DD 042919H
	DD	0290117H
	DD	0600f7010H
	DD	imagerel __GSHandlerCheck
	DD	0130H
$unwind$CTCE_Start_Listen_Connect_Threads DD 042019H
	DD	02f010eH
	DD	060067007H
	DD	imagerel __GSHandlerCheck
	DD	0160H
$unwind$CTCE_Start_ConnectThread DD 021e19H
	DD	01f010cH
	DD	imagerel __GSHandlerCheck
	DD	0e0H
$unwind$CTCE_Send DD 041c01H
	DD	01b011cH
	DD	060147015H
$unwind$CTCE_RecvThread DD 021e19H
	DD	037010cH
	DD	imagerel __GSHandlerCheck
	DD	01a8H
$unwind$CTCE_ListenThread DD 042019H
	DD	03d010eH
	DD	060067007H
	DD	imagerel __GSHandlerCheck
	DD	01d0H
$unwind$CTCE_Reset DD 031f19H
	DD	022010dH
	DD	07006H
	DD	imagerel __GSHandlerCheck
	DD	0100H
$unwind$CTCE_ChkSum DD 010e01H
	DD	0220eH
$unwind$CTCE_Trace DD 083419H
	DD	0830122H
	DD	0e019f01bH
	DD	060167017H
	DD	030145015H
	DD	imagerel __GSHandlerCheck
	DD	0400H
$unwind$CTCE_ConnectThread DD 031f19H
	DD	026010dH
	DD	07006H
	DD	imagerel __GSHandlerCheck
	DD	0128H
$unwind$CTCE_Get_Socket DD 032319H
	DD	0220111H
	DD	0700aH
	DD	imagerel __GSHandlerCheck
	DD	0108H
$unwind$CTCE_Write_Init DD 021001H
	DD	01b0110H
$unwind$CTCE_Recovery DD 021e19H
	DD	015010cH
	DD	imagerel __GSHandlerCheck
	DD	098H
$unwind$CTCE_Build_RCD DD 042a19H
	DD	0170118H
	DD	060107011H
	DD	imagerel __GSHandlerCheck
	DD	0a0H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$fetch_fw_noswap DD 010901H
	DD	02209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$fetch_hw_noswap DD 010901H
	DD	02209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$sscanf DD 011801H
	DD	06218H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$_vsscanf_l DD 011801H
	DD	06218H
xdata	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\ctcadpt.c
_TEXT	SEGMENT
tv140 = 0
RCD_len$ = 4
work$ = 16
__$ArrayPad$ = 160
dev$ = 208
buffer$ = 216
bufsz$ = 224
CTCE_Build_RCD PROC

; 3855 : {

  00000	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	56		 push	 rsi
  00010	57		 push	 rdi
  00011	48 81 ec b8 00
	00 00		 sub	 rsp, 184		; 000000b8H
  00018	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  0001f	48 33 c4	 xor	 rax, rsp
  00022	48 89 84 24 a0
	00 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 3856 : 
; 3857 : /*-------------------------------------------------------------------*/
; 3858 : /* static template/prototype configuration data                      */
; 3859 : /*-------------------------------------------------------------------*/
; 3860 : /*                                                                   */
; 3861 : /*    SB10-7034-05  ESCON and FICON Channel-to-Channel Reference     */
; 3862 : /*                                                                   */
; 3863 : /* Read Configuration Data (X'C4')                                   */
; 3864 : /*                                                                   */
; 3865 : /* A Read Configuration Data command for a CTC device was only ever  */
; 3866 : /* encountered for FICON CTC (FCTC), never for regular CTC Adapters. */
; 3867 : /* (ESCON CTC adapters so far have not been tested yet.)  The RCD    */
; 3868 : /* command was then implemented similar to the code in tapedev.c.    */
; 3869 : /*                                                                   */
; 3870 : /* A Read Configuration Data command for a FCTC causes 132 bytes of  */
; 3871 : /* be transferred from the control unit to the channel.              */
; 3872 : /*                                                                   */
; 3873 : /*-------------------------------------------------------------------*/
; 3874 : static const BYTE cfgdata[] =       // (prototype data)
; 3875 : {
; 3876 : // ---------------- Local NED -----------------------------------------
; 3877 : 0xC8,                               // 0:      NED code
; 3878 : 0x01,                               // 1:      Type  (X'01' = I/O Device)
; 3879 : 0x09,                               // 2:      Class (X'09' = CTCA)
; 3880 : 0x00,                               // 3:      (Reserved)
; 3881 : 0xF0,0xF0,0xF3,0xF0,0xF8,0xF8,      // 4-9:    Type  ('003088')
; 3882 : 0xC3,0xE3,0xC3,                     // 10-12:  Model ('CTC')
; 3883 : 0xC8,0xD9,0xC3,                     // 13-15:  Manufacturer ('HRC' = Hercules)
; 3884 : 0xE9,0xE9,                          // 16-17:  Plant of Manufacture ('ZZ' = Herc)
; 3885 : 0xF0,0xF0,0xF0,0xF0,                // 18-21:  Sequence Number Bytes 0-3
; 3886 : 0xC1,                               // 22:     Sequence Number Byte  4
; 3887 : 0xF0,0xF0,0xF0,0xF0,0xF0,0xF0,0xF0, // 23-29:  Sequence Number Bytes 5-11
; 3888 : 0x00, 0x00,                         // 30-31:  Tag
; 3889 : // ---------------- Specific NED --------------------------------------
; 3890 : 0x40,                               // 32:     Flags
; 3891 : 0x00,0x00,0x00,                     // 33-35:  (Reserved)
; 3892 : 0xF0,0xF0,0xF3,0xF0,0xF8,0xF8,      // 36-41:  Type  ('003088')
; 3893 : 0xC3,0xE3,0xC3,                     // 42-44:  Model ('CTC')
; 3894 : 0xC8,0xD9,0xC3,                     // 45-47:  Manufacturer ('HRC' = Hercules)
; 3895 : 0xE9,0xE9,                          // 48-49:  Plant of Manufacture ('ZZ' = Herc)
; 3896 : 0xF0,0xF0,0xF0,0xF0,                // 50-53:  Sequence Number Bytes 0-3
; 3897 : 0xC2,                               // 54:     Sequence Number Byte  4
; 3898 : 0xF0,0xF0,0xF0,0xF0,0xF0,0xF0,0xF0, // 55-61:  Sequence Number Bytes 5-11
; 3899 : 0x00, 0x00,                         // 62-63:  Tag
; 3900 : // ---------------- Token NED -----------------------------------------
; 3901 : 0xE8,                               // 64:     NED code
; 3902 : 0x01,                               // 65:     Type  (X'01' = I/O Device)
; 3903 : 0x09,                               // 66:     Class (X'09' = CTCA)
; 3904 : 0x00,                               // 67:     (Reserved)
; 3905 : 0xF0,0xF0,0xF2,0xF8,0xF1,0xF7,      // 68-73:  Type  ('002817') (z196)
; 3906 : 0xC3,0xE3,0xC3,                     // 74-76:  Model ('CTC')
; 3907 : 0xC8,0xD9,0xC3,                     // 77-79:  Manufacturer ('HRC' = Hercules)
; 3908 : 0xE9,0xE9,                          // 80-81:  Plant of Manufacture ('ZZ' = Herc)
; 3909 : 0xF0,0xF0,0xF0,0xF0,                // 82-85:  Sequence Number Bytes 0-3
; 3910 : 0xF0,                               // 86:     Sequence Number Byte  4
; 3911 : 0xF0,0xF0,0xF0,0xF0,0xF0,0xF0,0xF0, // 87-93:  Sequence Number Bytes 5-11
; 3912 : 0x00, 0xE1,                         // 94-95:  Tag
; 3913 : // ---------------- General NED ---------------------------------------
; 3914 : 0x80,                               // 96:       NED code
; 3915 : 0x00,                               // 97:       Record Selector
; 3916 : 0x00,0x01,                          // 98-99:    Interface ID
; 3917 :                                     //           x'0001' = local config record
; 3918 :                                     //           x'0002' = remote config record
; 3919 : 0x00,0x00,0x00,0x00,0x00,0x00,0x00, // 100-131:  (Reserved)
; 3920 : 0x00,0x00,0x00,0x00,0x00,0x00,0x00,
; 3921 : 0x00,0x00,0x00,0x00,0x00,0x00,0x00,
; 3922 : 0x00,0x00,0x00,0x00,0x00,0x00,0x00,
; 3923 : 0x00,0x00,0x00,0x00,
; 3924 : };
; 3925 : 
; 3926 : CASSERT( sizeof(cfgdata) == 132, ctcadpt_c );
; 3927 : 
; 3928 :     int   RCD_len;
; 3929 :     BYTE  work[ sizeof( cfgdata ) ];
; 3930 : 
; 3931 :     // Copy prototype Configuration Data to work area.
; 3932 :     memcpy( work, cfgdata, sizeof( work ));

  0002a	48 8d 44 24 10	 lea	 rax, QWORD PTR work$[rsp]
  0002f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:?cfgdata@?1??CTCE_Build_RCD@@9@9
  00036	48 8b f8	 mov	 rdi, rax
  00039	48 8b f1	 mov	 rsi, rcx
  0003c	b9 84 00 00 00	 mov	 ecx, 132		; 00000084H
  00041	f3 a4		 rep movsb

; 3933 : 
; 3934 :     // Fixup values for this particular FICON CTCE device.
; 3935 :     work[19]    = (dev->devnum      & 0x0FF);   // (set Inbound  IID)

  00043	48 8b 84 24 d0
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  0004b	0f b7 40 48	 movzx	 eax, WORD PTR [rax+72]
  0004f	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  00054	b9 01 00 00 00	 mov	 ecx, 1
  00059	48 6b c9 13	 imul	 rcx, rcx, 19
  0005d	88 44 0c 10	 mov	 BYTE PTR work$[rsp+rcx], al

; 3936 :     work[21]    = (dev->ctce_rccuu  & 0x0FF);   // (set Outbound IID)

  00061	48 8b 84 24 d0
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00069	0f b7 80 64 07
	00 00		 movzx	 eax, WORD PTR [rax+1892]
  00070	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  00075	b9 01 00 00 00	 mov	 ecx, 1
  0007a	48 6b c9 15	 imul	 rcx, rcx, 21
  0007e	88 44 0c 10	 mov	 BYTE PTR work$[rsp+rcx], al

; 3937 :     work[31]    = (dev->devnum      & 0x0FF);   // (set Unit Address)

  00082	48 8b 84 24 d0
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  0008a	0f b7 40 48	 movzx	 eax, WORD PTR [rax+72]
  0008e	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  00093	b9 01 00 00 00	 mov	 ecx, 1
  00098	48 6b c9 1f	 imul	 rcx, rcx, 31
  0009c	88 44 0c 10	 mov	 BYTE PTR work$[rsp+rcx], al

; 3938 : 
; 3939 :     work[19+32] = (dev->ctce_rccuu  & 0x0FF);   // (set Inbound  IID)

  000a0	48 8b 84 24 d0
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  000a8	0f b7 80 64 07
	00 00		 movzx	 eax, WORD PTR [rax+1892]
  000af	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  000b4	b9 01 00 00 00	 mov	 ecx, 1
  000b9	48 6b c9 33	 imul	 rcx, rcx, 51		; 00000033H
  000bd	88 44 0c 10	 mov	 BYTE PTR work$[rsp+rcx], al

; 3940 :     work[21+32] = (dev->devnum      & 0x0FF);   // (set Outbound IID)

  000c1	48 8b 84 24 d0
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  000c9	0f b7 40 48	 movzx	 eax, WORD PTR [rax+72]
  000cd	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  000d2	b9 01 00 00 00	 mov	 ecx, 1
  000d7	48 6b c9 35	 imul	 rcx, rcx, 53		; 00000035H
  000db	88 44 0c 10	 mov	 BYTE PTR work$[rsp+rcx], al

; 3941 :     work[31+32] = (dev->ctce_rccuu  & 0x0FF);   // (set Unit Address)

  000df	48 8b 84 24 d0
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  000e7	0f b7 80 64 07
	00 00		 movzx	 eax, WORD PTR [rax+1892]
  000ee	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  000f3	b9 01 00 00 00	 mov	 ecx, 1
  000f8	48 6b c9 3f	 imul	 rcx, rcx, 63		; 0000003fH
  000fc	88 44 0c 10	 mov	 BYTE PTR work$[rsp+rcx], al

; 3942 : 
; 3943 :     // Finally, copy the work area into the caller's buffer.
; 3944 :     RCD_len = bufsz < (int) sizeof( work ) ? bufsz : (int) sizeof( work );

  00100	81 bc 24 e0 00
	00 00 84 00 00
	00		 cmp	 DWORD PTR bufsz$[rsp], 132 ; 00000084H
  0010b	7d 0c		 jge	 SHORT $LN3@CTCE_Build
  0010d	8b 84 24 e0 00
	00 00		 mov	 eax, DWORD PTR bufsz$[rsp]
  00114	89 04 24	 mov	 DWORD PTR tv140[rsp], eax
  00117	eb 07		 jmp	 SHORT $LN4@CTCE_Build
$LN3@CTCE_Build:
  00119	c7 04 24 84 00
	00 00		 mov	 DWORD PTR tv140[rsp], 132 ; 00000084H
$LN4@CTCE_Build:
  00120	8b 04 24	 mov	 eax, DWORD PTR tv140[rsp]
  00123	89 44 24 04	 mov	 DWORD PTR RCD_len$[rsp], eax

; 3945 :     memcpy( buffer, work, RCD_len );

  00127	48 63 44 24 04	 movsxd	 rax, DWORD PTR RCD_len$[rsp]
  0012c	48 8d 4c 24 10	 lea	 rcx, QWORD PTR work$[rsp]
  00131	48 8b bc 24 d8
	00 00 00	 mov	 rdi, QWORD PTR buffer$[rsp]
  00139	48 8b f1	 mov	 rsi, rcx
  0013c	48 8b c8	 mov	 rcx, rax
  0013f	f3 a4		 rep movsb

; 3946 : 
; 3947 :     // Return the number of bytes we provided.
; 3948 :     return RCD_len;

  00141	8b 44 24 04	 mov	 eax, DWORD PTR RCD_len$[rsp]

; 3949 : 
; 3950 : } // CTCE_Build_RCD

  00145	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  0014d	48 33 cc	 xor	 rcx, rsp
  00150	e8 00 00 00 00	 call	 __security_check_cookie
  00155	48 81 c4 b8 00
	00 00		 add	 rsp, 184		; 000000b8H
  0015c	5f		 pop	 rdi
  0015d	5e		 pop	 rsi
  0015e	c3		 ret	 0
CTCE_Build_RCD ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\ctcadpt.c
_TEXT	SEGMENT
tv81 = 96
tv85 = 100
rc$ = 104
argv$ = 112
tv64 = 128
tv77 = 136
devnum$ = 144
__$ArrayPad$ = 152
dev$ = 176
CTCE_Recovery PROC

; 3834 : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 81 ec a8 00
	00 00		 sub	 rsp, 168		; 000000a8H
  0000c	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00013	48 33 c4	 xor	 rax, rsp
  00016	48 89 84 24 98
	00 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 3835 :     char      devnum[7];                                   // devnum to be recovered
; 3836 :     char     *argv[] = { "DEVINIT", ( char* )&devnum };    // to be passed to  devinit_cmd

  0001e	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG170479
  00025	48 89 44 24 70	 mov	 QWORD PTR argv$[rsp], rax
  0002a	48 8d 84 24 90
	00 00 00	 lea	 rax, QWORD PTR devnum$[rsp]
  00032	48 89 44 24 78	 mov	 QWORD PTR argv$[rsp+8], rax

; 3837 :     int       rc;                                          // Return Code from devinit_cmd
; 3838 : 
; 3839 :     MSGBUF( devnum, "%1d:%04X", CTCE_DEVNUM( dev ) );

  00037	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  0003f	0f b7 40 48	 movzx	 eax, WORD PTR [rax+72]
  00043	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  0004b	0f b7 49 44	 movzx	 ecx, WORD PTR [rcx+68]
  0004f	d1 f9		 sar	 ecx, 1
  00051	89 44 24 20	 mov	 DWORD PTR [rsp+32], eax
  00055	44 8b c9	 mov	 r9d, ecx
  00058	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG170480
  0005f	ba 07 00 00 00	 mov	 edx, 7
  00064	48 8d 8c 24 90
	00 00 00	 lea	 rcx, QWORD PTR devnum$[rsp]
  0006c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_snprintf

; 3840 :     WRMSG( HHC05086, "I",  // CTCE: Recovery is about to issue Hercules command: %s %s"

  00072	b8 08 00 00 00	 mov	 eax, 8
  00077	48 6b c0 01	 imul	 rax, rax, 1
  0007b	48 89 84 24 80
	00 00 00	 mov	 QWORD PTR tv64[rsp], rax
  00083	b9 08 00 00 00	 mov	 ecx, 8
  00088	48 6b c9 00	 imul	 rcx, rcx, 0
  0008c	48 89 8c 24 88
	00 00 00	 mov	 QWORD PTR tv77[rsp], rcx
  00094	48 8b 94 24 b0
	00 00 00	 mov	 rdx, QWORD PTR dev$[rsp]
  0009c	0f b7 52 48	 movzx	 edx, WORD PTR [rdx+72]
  000a0	89 54 24 60	 mov	 DWORD PTR tv81[rsp], edx
  000a4	4c 8b 84 24 b0
	00 00 00	 mov	 r8, QWORD PTR dev$[rsp]
  000ac	45 0f b7 40 44	 movzx	 r8d, WORD PTR [r8+68]
  000b1	41 d1 f8	 sar	 r8d, 1
  000b4	44 89 44 24 64	 mov	 DWORD PTR tv85[rsp], r8d
  000b9	b9 01 00 00 00	 mov	 ecx, 1
  000be	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  000c4	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR tv64[rsp]
  000cc	48 8b 4c 0c 70	 mov	 rcx, QWORD PTR argv$[rsp+rcx]
  000d1	48 89 4c 24 50	 mov	 QWORD PTR [rsp+80], rcx
  000d6	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR tv77[rsp]
  000de	48 8b 4c 0c 70	 mov	 rcx, QWORD PTR argv$[rsp+rcx]
  000e3	48 89 4c 24 48	 mov	 QWORD PTR [rsp+72], rcx
  000e8	8b 4c 24 60	 mov	 ecx, DWORD PTR tv81[rsp]
  000ec	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  000f0	8b 4c 24 64	 mov	 ecx, DWORD PTR tv85[rsp]
  000f4	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  000f8	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170481
  000ff	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  00104	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170482
  0010b	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00110	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00115	41 b9 03 00 00
	00		 mov	 r9d, 3
  0011b	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG170483
  00122	ba 01 0f 00 00	 mov	 edx, 3841		; 00000f01H
  00127	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170484
  0012e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 3841 :         CTCX_DEVNUM( dev ), argv[0], argv[1] );
; 3842 :     release_lock( &dev->lock );

  00134	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  0013c	48 83 c0 38	 add	 rax, 56			; 00000038H
  00140	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG170485
  00147	48 8b c8	 mov	 rcx, rax
  0014a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_release_lock

; 3843 :     rc = devinit_cmd( sizeof( argv ) / sizeof( argv[0] ), argv, NULL );

  00150	45 33 c0	 xor	 r8d, r8d
  00153	48 8d 54 24 70	 lea	 rdx, QWORD PTR argv$[rsp]
  00158	b9 02 00 00 00	 mov	 ecx, 2
  0015d	e8 00 00 00 00	 call	 devinit_cmd
  00162	89 44 24 68	 mov	 DWORD PTR rc$[rsp], eax

; 3844 :     obtain_lock( &dev->lock );

  00166	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  0016e	48 83 c0 38	 add	 rax, 56			; 00000038H
  00172	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG170486
  00179	48 8b c8	 mov	 rcx, rax
  0017c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_obtain_lock

; 3845 :     return rc;

  00182	8b 44 24 68	 mov	 eax, DWORD PTR rc$[rsp]

; 3846 : 
; 3847 : } // CTCE_Recovery

  00186	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  0018e	48 33 cc	 xor	 rcx, rsp
  00191	e8 00 00 00 00	 call	 __security_check_cookie
  00196	48 81 c4 a8 00
	00 00		 add	 rsp, 168		; 000000a8H
  0019d	c3		 ret	 0
CTCE_Recovery ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\ctcadpt.c
_TEXT	SEGMENT
rc$ = 144
pSokBuf$ = 152
tv79 = 160
tv128 = 164
tv138 = 168
tv142 = 172
tv147 = 176
tv151 = 180
tv90 = 184
tv133 = 192
dev$ = 224
fd$ = 232
CTCE_Write_Init PROC

; 3801 : {

  00000	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00004	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00009	48 81 ec d8 00
	00 00		 sub	 rsp, 216		; 000000d8H

; 3802 :     int                 rc;                           // Return Code
; 3803 :     CTCE_SOKPFX*        pSokBuf;                      // The buffer to be written
; 3804 : 
; 3805 :     pSokBuf = (CTCE_SOKPFX*) dev->buf;

  00010	48 8b 84 24 e0
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00018	48 8b 80 c8 01
	00 00		 mov	 rax, QWORD PTR [rax+456]
  0001f	48 89 84 24 98
	00 00 00	 mov	 QWORD PTR pSokBuf$[rsp], rax

; 3806 :     pSokBuf->ctce_lport  = dev->ctce_lport;

  00027	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR pSokBuf$[rsp]
  0002f	48 8b 8c 24 e0
	00 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  00037	0f b7 89 50 07
	00 00		 movzx	 ecx, WORD PTR [rcx+1872]
  0003e	66 89 48 02	 mov	 WORD PTR [rax+2], cx

; 3807 :     pSokBuf->ctce_ipaddr = dev->ctce_ipaddr;

  00042	48 8b 84 24 e0
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  0004a	8b 80 5c 07 00
	00		 mov	 eax, DWORD PTR [rax+1884]
  00050	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR pSokBuf$[rsp]
  00058	89 41 04	 mov	 DWORD PTR [rcx+4], eax

; 3808 :     pSokBuf->SndLen      = dev->ctceSndSml;

  0005b	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR pSokBuf$[rsp]
  00063	48 8b 8c 24 e0
	00 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  0006b	0f b7 89 30 07
	00 00		 movzx	 ecx, WORD PTR [rcx+1840]
  00072	66 89 48 08	 mov	 WORD PTR [rax+8], cx

; 3809 :     pSokBuf->devnum      = dev->devnum;

  00076	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR pSokBuf$[rsp]
  0007e	48 8b 8c 24 e0
	00 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  00086	0f b7 49 48	 movzx	 ecx, WORD PTR [rcx+72]
  0008a	66 89 48 0a	 mov	 WORD PTR [rax+10], cx

; 3810 :     pSokBuf->ssid        = dev->ssid;

  0008e	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR pSokBuf$[rsp]
  00096	48 8b 8c 24 e0
	00 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  0009e	0f b7 49 44	 movzx	 ecx, WORD PTR [rcx+68]
  000a2	66 89 48 0c	 mov	 WORD PTR [rax+12], cx

; 3811 :     pSokBuf->ctce_herc   = ( dev->ctcefd > 0 ) ? CTCE_HERC_RECV : 0 ; // 0 = we're not yet receiving

  000a6	48 8b 84 24 e0
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  000ae	83 b8 3c 07 00
	00 00		 cmp	 DWORD PTR [rax+1852], 0
  000b5	7e 0d		 jle	 SHORT $LN5@CTCE_Write
  000b7	c7 84 24 a0 00
	00 00 01 80 00
	00		 mov	 DWORD PTR tv79[rsp], 32769 ; 00008001H
  000c2	eb 0b		 jmp	 SHORT $LN6@CTCE_Write
$LN5@CTCE_Write:
  000c4	c7 84 24 a0 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv79[rsp], 0
$LN6@CTCE_Write:
  000cf	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR pSokBuf$[rsp]
  000d7	0f b7 8c 24 a0
	00 00 00	 movzx	 ecx, WORD PTR tv79[rsp]
  000df	66 89 08	 mov	 WORD PTR [rax], cx

; 3812 :     if ( ( rc = write_socket( fd, pSokBuf, pSokBuf->SndLen ) ) == pSokBuf->SndLen )

  000e2	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR pSokBuf$[rsp]
  000ea	0f b7 40 08	 movzx	 eax, WORD PTR [rax+8]
  000ee	44 8b c0	 mov	 r8d, eax
  000f1	48 8b 94 24 98
	00 00 00	 mov	 rdx, QWORD PTR pSokBuf$[rsp]
  000f9	8b 8c 24 e8 00
	00 00		 mov	 ecx, DWORD PTR fd$[rsp]
  00100	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_write_socket
  00106	89 84 24 90 00
	00 00		 mov	 DWORD PTR rc$[rsp], eax
  0010d	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR pSokBuf$[rsp]
  00115	0f b7 40 08	 movzx	 eax, WORD PTR [rax+8]
  00119	39 84 24 90 00
	00 00		 cmp	 DWORD PTR rc$[rsp], eax
  00120	75 10		 jne	 SHORT $LN2@CTCE_Write

; 3813 :     {
; 3814 :         rc = 0;

  00122	c7 84 24 90 00
	00 00 00 00 00
	00		 mov	 DWORD PTR rc$[rsp], 0

; 3815 :     }

  0012d	e9 91 01 00 00	 jmp	 $LN3@CTCE_Write
$LN2@CTCE_Write:

; 3816 :     else
; 3817 :     {
; 3818 :         close_socket( fd );

  00132	8b 8c 24 e8 00
	00 00		 mov	 ecx, DWORD PTR fd$[rsp]
  00139	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_close_socket

; 3819 :         WRMSG( HHC05075, "E",  // CTCE: Initial write_socket :%d -> %1d:%04X=%s:%d ; rc=%d!=%d ; error = %s"

  0013f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_WSAGetLastError
  00145	8b c8		 mov	 ecx, eax
  00147	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_strerror
  0014d	48 89 84 24 b8
	00 00 00	 mov	 QWORD PTR tv90[rsp], rax
  00155	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR pSokBuf$[rsp]
  0015d	0f b7 49 08	 movzx	 ecx, WORD PTR [rcx+8]
  00161	89 8c 24 a4 00
	00 00		 mov	 DWORD PTR tv128[rsp], ecx
  00168	48 8b 94 24 e0
	00 00 00	 mov	 rdx, QWORD PTR dev$[rsp]
  00170	8b 8a 5c 07 00
	00		 mov	 ecx, DWORD PTR [rdx+1884]
  00176	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_inet_ntoa
  0017c	48 89 84 24 c0
	00 00 00	 mov	 QWORD PTR tv133[rsp], rax
  00184	48 8b 8c 24 e0
	00 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  0018c	0f b7 89 64 07
	00 00		 movzx	 ecx, WORD PTR [rcx+1892]
  00193	89 8c 24 a8 00
	00 00		 mov	 DWORD PTR tv138[rsp], ecx
  0019a	48 8b 94 24 e0
	00 00 00	 mov	 rdx, QWORD PTR dev$[rsp]
  001a2	0f b7 52 44	 movzx	 edx, WORD PTR [rdx+68]
  001a6	d1 fa		 sar	 edx, 1
  001a8	89 94 24 ac 00
	00 00		 mov	 DWORD PTR tv142[rsp], edx
  001af	4c 8b 84 24 e0
	00 00 00	 mov	 r8, QWORD PTR dev$[rsp]
  001b7	45 0f b7 40 48	 movzx	 r8d, WORD PTR [r8+72]
  001bc	44 89 84 24 b0
	00 00 00	 mov	 DWORD PTR tv147[rsp], r8d
  001c4	4c 8b 8c 24 e0
	00 00 00	 mov	 r9, QWORD PTR dev$[rsp]
  001cc	45 0f b7 49 44	 movzx	 r9d, WORD PTR [r9+68]
  001d1	41 d1 f9	 sar	 r9d, 1
  001d4	44 89 8c 24 b4
	00 00 00	 mov	 DWORD PTR tv151[rsp], r9d
  001dc	b9 01 00 00 00	 mov	 ecx, 1
  001e1	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  001e7	48 8b 8c 24 b8
	00 00 00	 mov	 rcx, QWORD PTR tv90[rsp]
  001ef	48 89 8c 24 80
	00 00 00	 mov	 QWORD PTR [rsp+128], rcx
  001f7	8b 8c 24 a4 00
	00 00		 mov	 ecx, DWORD PTR tv128[rsp]
  001fe	89 4c 24 78	 mov	 DWORD PTR [rsp+120], ecx
  00202	8b 8c 24 90 00
	00 00		 mov	 ecx, DWORD PTR rc$[rsp]
  00209	89 4c 24 70	 mov	 DWORD PTR [rsp+112], ecx
  0020d	48 8b 8c 24 e0
	00 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  00215	8b 89 58 07 00
	00		 mov	 ecx, DWORD PTR [rcx+1880]
  0021b	89 4c 24 68	 mov	 DWORD PTR [rsp+104], ecx
  0021f	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR tv133[rsp]
  00227	48 89 4c 24 60	 mov	 QWORD PTR [rsp+96], rcx
  0022c	8b 8c 24 a8 00
	00 00		 mov	 ecx, DWORD PTR tv138[rsp]
  00233	89 4c 24 58	 mov	 DWORD PTR [rsp+88], ecx
  00237	8b 8c 24 ac 00
	00 00		 mov	 ecx, DWORD PTR tv142[rsp]
  0023e	89 4c 24 50	 mov	 DWORD PTR [rsp+80], ecx
  00242	48 8b 8c 24 e0
	00 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  0024a	8b 89 50 07 00
	00		 mov	 ecx, DWORD PTR [rcx+1872]
  00250	89 4c 24 48	 mov	 DWORD PTR [rsp+72], ecx
  00254	8b 8c 24 b0 00
	00 00		 mov	 ecx, DWORD PTR tv147[rsp]
  0025b	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  0025f	8b 8c 24 b4 00
	00 00		 mov	 ecx, DWORD PTR tv151[rsp]
  00266	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  0026a	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170466
  00271	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  00276	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170467
  0027d	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00282	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00287	41 b9 03 00 00
	00		 mov	 r9d, 3
  0028d	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG170468
  00294	ba ed 0e 00 00	 mov	 edx, 3821		; 00000eedH
  00299	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170469
  002a0	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 3820 :             CTCX_DEVNUM( dev ), dev->ctce_lport, SSID_TO_LCSS( dev->ssid ),
; 3821 :             dev->ctce_rccuu, inet_ntoa( dev->ctce_ipaddr ), dev->ctce_rport, rc, pSokBuf->SndLen, strerror( HSO_errno ) );
; 3822 :         rc = -1;

  002a6	c7 84 24 90 00
	00 00 ff ff ff
	ff		 mov	 DWORD PTR rc$[rsp], -1

; 3823 :         CTCE_ERROR_CCWTRACE( dev );

  002b1	48 8b 84 24 e0
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  002b9	c7 80 68 07 00
	00 14 00 00 00	 mov	 DWORD PTR [rax+1896], 20
$LN3@CTCE_Write:

; 3824 :     }
; 3825 :     return rc;

  002c3	8b 84 24 90 00
	00 00		 mov	 eax, DWORD PTR rc$[rsp]

; 3826 : 
; 3827 : } // CTCE_Write_Init

  002ca	48 81 c4 d8 00
	00 00		 add	 rsp, 216		; 000000d8H
  002d1	c3		 ret	 0
CTCE_Write_Init ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\ctcadpt.c
_TEXT	SEGMENT
fd$ = 112
so_value_1$ = 116
addrlen$ = 120
tv77 = 124
tv81 = 128
tv144 = 132
tv148 = 136
tv180 = 140
tv184 = 144
tv224 = 148
tv228 = 152
tv266 = 156
tv270 = 160
tv74 = 168
tv140 = 176
tv176 = 184
tv221 = 192
tv263 = 200
tv69 = 208
tv133 = 216
tv169 = 224
tv214 = 232
tv256 = 240
addr$ = 248
__$ArrayPad$ = 264
dev$ = 288
eCTCE_Sok_Use$ = 296
CTCE_Get_Socket PROC

; 3697 : {

  00000	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00004	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00009	57		 push	 rdi
  0000a	48 81 ec 10 01
	00 00		 sub	 rsp, 272		; 00000110H
  00011	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00018	48 33 c4	 xor	 rax, rsp
  0001b	48 89 84 24 08
	01 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 3698 :     int                 fd;                           // socket file descriptor
; 3699 :     const int           so_value_1 = 1;               // argument for setsockopt

  00023	c7 44 24 74 01
	00 00 00	 mov	 DWORD PTR so_value_1$[rsp], 1

; 3700 :     struct sockaddr_in  addr;                         // socket address info
; 3701 :     socklen_t           addrlen;                      // as needed for getsockname() etc.
; 3702 : 
; 3703 : 
; 3704 :     // Obtain a new socket.
; 3705 :     if( ( fd = socket(AF_INET, SOCK_STREAM, 0) ) < 0 )

  0002b	45 33 c0	 xor	 r8d, r8d
  0002e	ba 01 00 00 00	 mov	 edx, 1
  00033	b9 02 00 00 00	 mov	 ecx, 2
  00038	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_socket
  0003e	89 44 24 70	 mov	 DWORD PTR fd$[rsp], eax
  00042	83 7c 24 70 00	 cmp	 DWORD PTR fd$[rsp], 0
  00047	0f 8d ed 00 00
	00		 jge	 $LN2@CTCE_Get_S

; 3706 :     {
; 3707 :         WRMSG( HHC05050, "E",  // CTCE: Error creating %s socket: %s"

  0004d	83 bc 24 28 01
	00 00 00	 cmp	 DWORD PTR eCTCE_Sok_Use$[rsp], 0
  00055	75 11		 jne	 SHORT $LN13@CTCE_Get_S
  00057	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG170414
  0005e	48 89 84 24 a8
	00 00 00	 mov	 QWORD PTR tv74[rsp], rax
  00066	eb 0f		 jmp	 SHORT $LN14@CTCE_Get_S
$LN13@CTCE_Get_S:
  00068	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG170415
  0006f	48 89 84 24 a8
	00 00 00	 mov	 QWORD PTR tv74[rsp], rax
$LN14@CTCE_Get_S:
  00077	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_WSAGetLastError
  0007d	8b c8		 mov	 ecx, eax
  0007f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_strerror
  00085	48 89 84 24 d0
	00 00 00	 mov	 QWORD PTR tv69[rsp], rax
  0008d	48 8b 8c 24 20
	01 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  00095	0f b7 49 48	 movzx	 ecx, WORD PTR [rcx+72]
  00099	89 4c 24 7c	 mov	 DWORD PTR tv77[rsp], ecx
  0009d	48 8b 94 24 20
	01 00 00	 mov	 rdx, QWORD PTR dev$[rsp]
  000a5	0f b7 52 44	 movzx	 edx, WORD PTR [rdx+68]
  000a9	d1 fa		 sar	 edx, 1
  000ab	89 94 24 80 00
	00 00		 mov	 DWORD PTR tv81[rsp], edx
  000b2	b9 01 00 00 00	 mov	 ecx, 1
  000b7	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  000bd	48 8b 8c 24 d0
	00 00 00	 mov	 rcx, QWORD PTR tv69[rsp]
  000c5	48 89 4c 24 50	 mov	 QWORD PTR [rsp+80], rcx
  000ca	48 8b 8c 24 a8
	00 00 00	 mov	 rcx, QWORD PTR tv74[rsp]
  000d2	48 89 4c 24 48	 mov	 QWORD PTR [rsp+72], rcx
  000d7	8b 4c 24 7c	 mov	 ecx, DWORD PTR tv77[rsp]
  000db	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  000df	8b 8c 24 80 00
	00 00		 mov	 ecx, DWORD PTR tv81[rsp]
  000e6	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  000ea	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170416
  000f1	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  000f6	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170417
  000fd	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00102	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00107	41 b9 03 00 00
	00		 mov	 r9d, 3
  0010d	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG170418
  00114	ba 7d 0e 00 00	 mov	 edx, 3709		; 00000e7dH
  00119	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170419
  00120	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 3708 :             CTCX_DEVNUM( dev ), (eCTCE_Sok_Use == CTCE_SOK_LIS) ? "listen" : "connect",
; 3709 :             strerror( HSO_errno ) );
; 3710 :         close_socket( fd );

  00126	8b 4c 24 70	 mov	 ecx, DWORD PTR fd$[rsp]
  0012a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_close_socket

; 3711 :         return -1;

  00130	b8 ff ff ff ff	 mov	 eax, -1
  00135	e9 9c 05 00 00	 jmp	 $LN1@CTCE_Get_S
$LN2@CTCE_Get_S:

; 3712 :     }
; 3713 : 
; 3714 :     // Allow previous instance of the socket address to be reused.
; 3715 :     if ( setsockopt( fd, SOL_SOCKET, SO_REUSEADDR,
; 3716 :         ( GETSET_SOCKOPT_T* )&so_value_1, sizeof( so_value_1 ) ) < 0 )

  0013a	48 63 44 24 70	 movsxd	 rax, DWORD PTR fd$[rsp]
  0013f	c7 44 24 20 04
	00 00 00	 mov	 DWORD PTR [rsp+32], 4
  00147	4c 8d 4c 24 74	 lea	 r9, QWORD PTR so_value_1$[rsp]
  0014c	41 b8 04 00 00
	00		 mov	 r8d, 4
  00152	ba ff ff 00 00	 mov	 edx, 65535		; 0000ffffH
  00157	48 8b c8	 mov	 rcx, rax
  0015a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_setsockopt
  00160	85 c0		 test	 eax, eax
  00162	0f 8d 11 01 00
	00		 jge	 $LN3@CTCE_Get_S

; 3717 :     {
; 3718 :         WRMSG( HHC05051, "E",  // CTCE: %s error for %s socket (port %d): %s"

  00168	83 bc 24 28 01
	00 00 00	 cmp	 DWORD PTR eCTCE_Sok_Use$[rsp], 0
  00170	75 11		 jne	 SHORT $LN15@CTCE_Get_S
  00172	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG170421
  00179	48 89 84 24 b0
	00 00 00	 mov	 QWORD PTR tv140[rsp], rax
  00181	eb 0f		 jmp	 SHORT $LN16@CTCE_Get_S
$LN15@CTCE_Get_S:
  00183	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG170422
  0018a	48 89 84 24 b0
	00 00 00	 mov	 QWORD PTR tv140[rsp], rax
$LN16@CTCE_Get_S:
  00192	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_WSAGetLastError
  00198	8b c8		 mov	 ecx, eax
  0019a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_strerror
  001a0	48 89 84 24 d8
	00 00 00	 mov	 QWORD PTR tv133[rsp], rax
  001a8	48 8b 8c 24 20
	01 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  001b0	0f b7 49 48	 movzx	 ecx, WORD PTR [rcx+72]
  001b4	89 8c 24 84 00
	00 00		 mov	 DWORD PTR tv144[rsp], ecx
  001bb	48 8b 94 24 20
	01 00 00	 mov	 rdx, QWORD PTR dev$[rsp]
  001c3	0f b7 52 44	 movzx	 edx, WORD PTR [rdx+68]
  001c7	d1 fa		 sar	 edx, 1
  001c9	89 94 24 88 00
	00 00		 mov	 DWORD PTR tv148[rsp], edx
  001d0	b9 01 00 00 00	 mov	 ecx, 1
  001d5	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  001db	48 8b 8c 24 d8
	00 00 00	 mov	 rcx, QWORD PTR tv133[rsp]
  001e3	48 89 4c 24 60	 mov	 QWORD PTR [rsp+96], rcx
  001e8	48 8b 8c 24 20
	01 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  001f0	8b 89 50 07 00
	00		 mov	 ecx, DWORD PTR [rcx+1872]
  001f6	89 4c 24 58	 mov	 DWORD PTR [rsp+88], ecx
  001fa	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR tv140[rsp]
  00202	48 89 4c 24 50	 mov	 QWORD PTR [rsp+80], rcx
  00207	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170423
  0020e	48 89 4c 24 48	 mov	 QWORD PTR [rsp+72], rcx
  00213	8b 8c 24 84 00
	00 00		 mov	 ecx, DWORD PTR tv144[rsp]
  0021a	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  0021e	8b 8c 24 88 00
	00 00		 mov	 ecx, DWORD PTR tv148[rsp]
  00225	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  00229	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170424
  00230	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  00235	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170425
  0023c	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00241	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00246	41 b9 03 00 00
	00		 mov	 r9d, 3
  0024c	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG170426
  00253	ba 89 0e 00 00	 mov	 edx, 3721		; 00000e89H
  00258	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170427
  0025f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 3719 :             CTCX_DEVNUM( dev ), "SO_REUSEADDR",
; 3720 :             (eCTCE_Sok_Use == CTCE_SOK_LIS) ? "listen" : "connect",
; 3721 :             dev->ctce_lport, strerror( HSO_errno ) );
; 3722 :         close_socket( fd );

  00265	8b 4c 24 70	 mov	 ecx, DWORD PTR fd$[rsp]
  00269	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_close_socket

; 3723 :         return -1;

  0026f	b8 ff ff ff ff	 mov	 eax, -1
  00274	e9 5d 04 00 00	 jmp	 $LN1@CTCE_Get_S
$LN3@CTCE_Get_S:

; 3724 :     }
; 3725 : 
; 3726 : #if defined(CTCE_DISABLE_NAGLE)
; 3727 :     if ( eCTCE_Sok_Use == CTCE_SOK_CON )

  00279	83 bc 24 28 01
	00 00 01	 cmp	 DWORD PTR eCTCE_Sok_Use$[rsp], 1
  00281	0f 85 3f 01 00
	00		 jne	 $LN4@CTCE_Get_S

; 3728 :     {
; 3729 : 
; 3730 :         // Disable the NAGLE protocol as we need responsiveness more than throughput.
; 3731 :         if ( setsockopt( fd, IPPROTO_TCP, TCP_NODELAY,
; 3732 :             ( GETSET_SOCKOPT_T* )&so_value_1, sizeof( so_value_1 ) ) < 0 )

  00287	48 63 44 24 70	 movsxd	 rax, DWORD PTR fd$[rsp]
  0028c	c7 44 24 20 04
	00 00 00	 mov	 DWORD PTR [rsp+32], 4
  00294	4c 8d 4c 24 74	 lea	 r9, QWORD PTR so_value_1$[rsp]
  00299	41 b8 01 00 00
	00		 mov	 r8d, 1
  0029f	ba 06 00 00 00	 mov	 edx, 6
  002a4	48 8b c8	 mov	 rcx, rax
  002a7	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_setsockopt
  002ad	85 c0		 test	 eax, eax
  002af	0f 8d 11 01 00
	00		 jge	 $LN5@CTCE_Get_S

; 3733 :         {
; 3734 :             WRMSG( HHC05051, "E",  // CTCE: %s error for %s socket (port %d): %s"

  002b5	83 bc 24 28 01
	00 00 00	 cmp	 DWORD PTR eCTCE_Sok_Use$[rsp], 0
  002bd	75 11		 jne	 SHORT $LN17@CTCE_Get_S
  002bf	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG170430
  002c6	48 89 84 24 b8
	00 00 00	 mov	 QWORD PTR tv176[rsp], rax
  002ce	eb 0f		 jmp	 SHORT $LN18@CTCE_Get_S
$LN17@CTCE_Get_S:
  002d0	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG170431
  002d7	48 89 84 24 b8
	00 00 00	 mov	 QWORD PTR tv176[rsp], rax
$LN18@CTCE_Get_S:
  002df	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_WSAGetLastError
  002e5	8b c8		 mov	 ecx, eax
  002e7	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_strerror
  002ed	48 89 84 24 e0
	00 00 00	 mov	 QWORD PTR tv169[rsp], rax
  002f5	48 8b 8c 24 20
	01 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  002fd	0f b7 49 48	 movzx	 ecx, WORD PTR [rcx+72]
  00301	89 8c 24 8c 00
	00 00		 mov	 DWORD PTR tv180[rsp], ecx
  00308	48 8b 94 24 20
	01 00 00	 mov	 rdx, QWORD PTR dev$[rsp]
  00310	0f b7 52 44	 movzx	 edx, WORD PTR [rdx+68]
  00314	d1 fa		 sar	 edx, 1
  00316	89 94 24 90 00
	00 00		 mov	 DWORD PTR tv184[rsp], edx
  0031d	b9 01 00 00 00	 mov	 ecx, 1
  00322	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  00328	48 8b 8c 24 e0
	00 00 00	 mov	 rcx, QWORD PTR tv169[rsp]
  00330	48 89 4c 24 60	 mov	 QWORD PTR [rsp+96], rcx
  00335	48 8b 8c 24 20
	01 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  0033d	8b 89 50 07 00
	00		 mov	 ecx, DWORD PTR [rcx+1872]
  00343	89 4c 24 58	 mov	 DWORD PTR [rsp+88], ecx
  00347	48 8b 8c 24 b8
	00 00 00	 mov	 rcx, QWORD PTR tv176[rsp]
  0034f	48 89 4c 24 50	 mov	 QWORD PTR [rsp+80], rcx
  00354	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170432
  0035b	48 89 4c 24 48	 mov	 QWORD PTR [rsp+72], rcx
  00360	8b 8c 24 8c 00
	00 00		 mov	 ecx, DWORD PTR tv180[rsp]
  00367	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  0036b	8b 8c 24 90 00
	00 00		 mov	 ecx, DWORD PTR tv184[rsp]
  00372	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  00376	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170433
  0037d	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  00382	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170434
  00389	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  0038e	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00393	41 b9 03 00 00
	00		 mov	 r9d, 3
  00399	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG170435
  003a0	ba 99 0e 00 00	 mov	 edx, 3737		; 00000e99H
  003a5	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170436
  003ac	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 3735 :                 CTCX_DEVNUM( dev ), "TCP_NODELAY",
; 3736 :                 (eCTCE_Sok_Use == CTCE_SOK_LIS) ? "listen" : "connect",
; 3737 :                 dev->ctce_lport, strerror( HSO_errno ) );
; 3738 :             close_socket( fd );

  003b2	8b 4c 24 70	 mov	 ecx, DWORD PTR fd$[rsp]
  003b6	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_close_socket

; 3739 :             return -1;

  003bc	b8 ff ff ff ff	 mov	 eax, -1
  003c1	e9 10 03 00 00	 jmp	 $LN1@CTCE_Get_S
$LN5@CTCE_Get_S:
$LN4@CTCE_Get_S:

; 3740 :         }
; 3741 :     }
; 3742 : #endif
; 3743 : 
; 3744 :     // We bind the socket to a local port, which for a listening port
; 3745 :     // is this CTCE device's receiving port, otherwise we bind to a
; 3746 :     // random port (i.e. = 0).
; 3747 :     memset( &( addr ), 0, sizeof( addr ) );

  003c6	48 8d 84 24 f8
	00 00 00	 lea	 rax, QWORD PTR addr$[rsp]
  003ce	48 8b f8	 mov	 rdi, rax
  003d1	33 c0		 xor	 eax, eax
  003d3	b9 10 00 00 00	 mov	 ecx, 16
  003d8	f3 aa		 rep stosb

; 3748 :     addr.sin_family = AF_INET;

  003da	b8 02 00 00 00	 mov	 eax, 2
  003df	66 89 84 24 f8
	00 00 00	 mov	 WORD PTR addr$[rsp], ax

; 3749 :     if ( eCTCE_Sok_Use == CTCE_SOK_LIS )

  003e7	83 bc 24 28 01
	00 00 00	 cmp	 DWORD PTR eCTCE_Sok_Use$[rsp], 0
  003ef	75 1f		 jne	 SHORT $LN6@CTCE_Get_S

; 3750 :     {
; 3751 :         addr.sin_port = htons( dev->ctce_lport );

  003f1	48 8b 84 24 20
	01 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  003f9	0f b7 88 50 07
	00 00		 movzx	 ecx, WORD PTR [rax+1872]
  00400	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_htons
  00406	66 89 84 24 fa
	00 00 00	 mov	 WORD PTR addr$[rsp+2], ax

; 3752 :     }

  0040e	eb 10		 jmp	 SHORT $LN7@CTCE_Get_S
$LN6@CTCE_Get_S:

; 3753 :     else
; 3754 :     {
; 3755 :         addr.sin_port = htons( 0 );

  00410	33 c9		 xor	 ecx, ecx
  00412	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_htons
  00418	66 89 84 24 fa
	00 00 00	 mov	 WORD PTR addr$[rsp+2], ax
$LN7@CTCE_Get_S:

; 3756 :     }
; 3757 : 
; 3758 :     addr.sin_addr.s_addr = htonl( INADDR_ANY );

  00420	33 c9		 xor	 ecx, ecx
  00422	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_htonl
  00428	89 84 24 fc 00
	00 00		 mov	 DWORD PTR addr$[rsp+4], eax

; 3759 :     if ( bind( fd, ( struct sockaddr * )&addr, sizeof( addr ) ) < 0 )

  0042f	48 63 44 24 70	 movsxd	 rax, DWORD PTR fd$[rsp]
  00434	41 b8 10 00 00
	00		 mov	 r8d, 16
  0043a	48 8d 94 24 f8
	00 00 00	 lea	 rdx, QWORD PTR addr$[rsp]
  00442	48 8b c8	 mov	 rcx, rax
  00445	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_bind
  0044b	85 c0		 test	 eax, eax
  0044d	0f 8d 05 01 00
	00		 jge	 $LN8@CTCE_Get_S

; 3760 :     {
; 3761 :         WRMSG( HHC05052, "E",  // CTCE: Error binding to %s socket (port %d): %s"

  00453	83 bc 24 28 01
	00 00 00	 cmp	 DWORD PTR eCTCE_Sok_Use$[rsp], 0
  0045b	75 11		 jne	 SHORT $LN19@CTCE_Get_S
  0045d	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG170440
  00464	48 89 84 24 c0
	00 00 00	 mov	 QWORD PTR tv221[rsp], rax
  0046c	eb 0f		 jmp	 SHORT $LN20@CTCE_Get_S
$LN19@CTCE_Get_S:
  0046e	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG170441
  00475	48 89 84 24 c0
	00 00 00	 mov	 QWORD PTR tv221[rsp], rax
$LN20@CTCE_Get_S:
  0047d	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_WSAGetLastError
  00483	8b c8		 mov	 ecx, eax
  00485	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_strerror
  0048b	48 89 84 24 e8
	00 00 00	 mov	 QWORD PTR tv214[rsp], rax
  00493	48 8b 8c 24 20
	01 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  0049b	0f b7 49 48	 movzx	 ecx, WORD PTR [rcx+72]
  0049f	89 8c 24 94 00
	00 00		 mov	 DWORD PTR tv224[rsp], ecx
  004a6	48 8b 94 24 20
	01 00 00	 mov	 rdx, QWORD PTR dev$[rsp]
  004ae	0f b7 52 44	 movzx	 edx, WORD PTR [rdx+68]
  004b2	d1 fa		 sar	 edx, 1
  004b4	89 94 24 98 00
	00 00		 mov	 DWORD PTR tv228[rsp], edx
  004bb	b9 01 00 00 00	 mov	 ecx, 1
  004c0	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  004c6	48 8b 8c 24 e8
	00 00 00	 mov	 rcx, QWORD PTR tv214[rsp]
  004ce	48 89 4c 24 58	 mov	 QWORD PTR [rsp+88], rcx
  004d3	48 8b 8c 24 20
	01 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  004db	8b 89 50 07 00
	00		 mov	 ecx, DWORD PTR [rcx+1872]
  004e1	89 4c 24 50	 mov	 DWORD PTR [rsp+80], ecx
  004e5	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR tv221[rsp]
  004ed	48 89 4c 24 48	 mov	 QWORD PTR [rsp+72], rcx
  004f2	8b 8c 24 94 00
	00 00		 mov	 ecx, DWORD PTR tv224[rsp]
  004f9	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  004fd	8b 8c 24 98 00
	00 00		 mov	 ecx, DWORD PTR tv228[rsp]
  00504	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  00508	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170442
  0050f	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  00514	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170443
  0051b	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00520	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00525	41 b9 03 00 00
	00		 mov	 r9d, 3
  0052b	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG170444
  00532	ba b4 0e 00 00	 mov	 edx, 3764		; 00000eb4H
  00537	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170445
  0053e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 3762 :             CTCX_DEVNUM( dev ),
; 3763 :             ( eCTCE_Sok_Use == CTCE_SOK_LIS ) ? "listen" : "connect",
; 3764 :             dev->ctce_lport, strerror( HSO_errno ) );
; 3765 :         close_socket( fd );

  00544	8b 4c 24 70	 mov	 ecx, DWORD PTR fd$[rsp]
  00548	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_close_socket

; 3766 :         return -1;

  0054e	b8 ff ff ff ff	 mov	 eax, -1
  00553	e9 7e 01 00 00	 jmp	 $LN1@CTCE_Get_S
$LN8@CTCE_Get_S:

; 3767 :     }
; 3768 : 
; 3769 :     // A connect socket is always bound to a random lport, which we determine.
; 3770 :     if ( eCTCE_Sok_Use == CTCE_SOK_CON )

  00558	83 bc 24 28 01
	00 00 01	 cmp	 DWORD PTR eCTCE_Sok_Use$[rsp], 1
  00560	0f 85 6c 01 00
	00		 jne	 $LN9@CTCE_Get_S

; 3771 :     {
; 3772 :         addrlen = sizeof( addr );

  00566	c7 44 24 78 10
	00 00 00	 mov	 DWORD PTR addrlen$[rsp], 16

; 3773 :         if ( 1
; 3774 :             && getsockname ( fd, ( struct sockaddr * )&addr, &addrlen ) == 0
; 3775 :             && addr.sin_family == AF_INET
; 3776 :             && addrlen == sizeof( addr ) )

  0056e	33 c0		 xor	 eax, eax
  00570	83 f8 01	 cmp	 eax, 1
  00573	74 5b		 je	 SHORT $LN10@CTCE_Get_S
  00575	48 63 44 24 70	 movsxd	 rax, DWORD PTR fd$[rsp]
  0057a	4c 8d 44 24 78	 lea	 r8, QWORD PTR addrlen$[rsp]
  0057f	48 8d 94 24 f8
	00 00 00	 lea	 rdx, QWORD PTR addr$[rsp]
  00587	48 8b c8	 mov	 rcx, rax
  0058a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_getsockname
  00590	85 c0		 test	 eax, eax
  00592	75 3c		 jne	 SHORT $LN10@CTCE_Get_S
  00594	0f b7 84 24 f8
	00 00 00	 movzx	 eax, WORD PTR addr$[rsp]
  0059c	83 f8 02	 cmp	 eax, 2
  0059f	75 2f		 jne	 SHORT $LN10@CTCE_Get_S
  005a1	48 63 44 24 78	 movsxd	 rax, DWORD PTR addrlen$[rsp]
  005a6	48 83 f8 10	 cmp	 rax, 16
  005aa	75 24		 jne	 SHORT $LN10@CTCE_Get_S

; 3777 :         {
; 3778 :             dev->ctce_connect_lport = ntohs( addr.sin_port );

  005ac	0f b7 8c 24 fa
	00 00 00	 movzx	 ecx, WORD PTR addr$[rsp+2]
  005b4	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ntohs
  005ba	0f b7 c0	 movzx	 eax, ax
  005bd	48 8b 8c 24 20
	01 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  005c5	89 81 54 07 00
	00		 mov	 DWORD PTR [rcx+1876], eax

; 3779 :         }

  005cb	e9 02 01 00 00	 jmp	 $LN11@CTCE_Get_S
$LN10@CTCE_Get_S:

; 3780 :         else
; 3781 :         {
; 3782 :             WRMSG( HHC05053, "E",  // CTCE: Error on getsockname for %s socket (port %d): %s"

  005d0	83 bc 24 28 01
	00 00 00	 cmp	 DWORD PTR eCTCE_Sok_Use$[rsp], 0
  005d8	75 11		 jne	 SHORT $LN21@CTCE_Get_S
  005da	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG170449
  005e1	48 89 84 24 c8
	00 00 00	 mov	 QWORD PTR tv263[rsp], rax
  005e9	eb 0f		 jmp	 SHORT $LN22@CTCE_Get_S
$LN21@CTCE_Get_S:
  005eb	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG170450
  005f2	48 89 84 24 c8
	00 00 00	 mov	 QWORD PTR tv263[rsp], rax
$LN22@CTCE_Get_S:
  005fa	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_WSAGetLastError
  00600	8b c8		 mov	 ecx, eax
  00602	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_strerror
  00608	48 89 84 24 f0
	00 00 00	 mov	 QWORD PTR tv256[rsp], rax
  00610	48 8b 8c 24 20
	01 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  00618	0f b7 49 48	 movzx	 ecx, WORD PTR [rcx+72]
  0061c	89 8c 24 9c 00
	00 00		 mov	 DWORD PTR tv266[rsp], ecx
  00623	48 8b 94 24 20
	01 00 00	 mov	 rdx, QWORD PTR dev$[rsp]
  0062b	0f b7 52 44	 movzx	 edx, WORD PTR [rdx+68]
  0062f	d1 fa		 sar	 edx, 1
  00631	89 94 24 a0 00
	00 00		 mov	 DWORD PTR tv270[rsp], edx
  00638	b9 01 00 00 00	 mov	 ecx, 1
  0063d	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  00643	48 8b 8c 24 f0
	00 00 00	 mov	 rcx, QWORD PTR tv256[rsp]
  0064b	48 89 4c 24 58	 mov	 QWORD PTR [rsp+88], rcx
  00650	48 8b 8c 24 20
	01 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  00658	8b 89 50 07 00
	00		 mov	 ecx, DWORD PTR [rcx+1872]
  0065e	89 4c 24 50	 mov	 DWORD PTR [rsp+80], ecx
  00662	48 8b 8c 24 c8
	00 00 00	 mov	 rcx, QWORD PTR tv263[rsp]
  0066a	48 89 4c 24 48	 mov	 QWORD PTR [rsp+72], rcx
  0066f	8b 8c 24 9c 00
	00 00		 mov	 ecx, DWORD PTR tv266[rsp]
  00676	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  0067a	8b 8c 24 a0 00
	00 00		 mov	 ecx, DWORD PTR tv270[rsp]
  00681	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  00685	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170451
  0068c	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  00691	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170452
  00698	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  0069d	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  006a2	41 b9 03 00 00
	00		 mov	 r9d, 3
  006a8	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG170453
  006af	ba c8 0e 00 00	 mov	 edx, 3784		; 00000ec8H
  006b4	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170454
  006bb	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 3783 :                 CTCX_DEVNUM( dev ), (eCTCE_Sok_Use == CTCE_SOK_LIS) ? "listen" : "connect",
; 3784 :                 dev->ctce_lport, strerror( HSO_errno ) );
; 3785 :             close_socket( fd );

  006c1	8b 4c 24 70	 mov	 ecx, DWORD PTR fd$[rsp]
  006c5	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_close_socket

; 3786 :             return -1;

  006cb	b8 ff ff ff ff	 mov	 eax, -1
  006d0	eb 04		 jmp	 SHORT $LN1@CTCE_Get_S
$LN11@CTCE_Get_S:
$LN9@CTCE_Get_S:

; 3787 :         }
; 3788 :     }
; 3789 : 
; 3790 :     // By now all possible error cases have been reported and acted upon.
; 3791 :     return fd;

  006d2	8b 44 24 70	 mov	 eax, DWORD PTR fd$[rsp]
$LN1@CTCE_Get_S:

; 3792 : 
; 3793 : } // CTCE_Get_Socket

  006d6	48 8b 8c 24 08
	01 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  006de	48 33 cc	 xor	 rcx, rsp
  006e1	e8 00 00 00 00	 call	 __security_check_cookie
  006e6	48 81 c4 10 01
	00 00		 add	 rsp, 272		; 00000110H
  006ed	5f		 pop	 rdi
  006ee	c3		 ret	 0
CTCE_Get_Socket ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\ctcadpt.c
_TEXT	SEGMENT
dev$ = 128
renewed$ = 136
rc$ = 140
fd$ = 144
attempts_counter$ = 148
connect_retry_interval$ = 152
tv154 = 156
attempts_counter_max$ = 160
tv192 = 164
tv230 = 168
remaddr$ = 176
connect_msg_interval$ = 184
tv163 = 188
tv167 = 192
tv172 = 196
tv200 = 200
tv204 = 204
tv209 = 208
tv237 = 212
tv241 = 216
tv250 = 220
tv269 = 224
tv273 = 228
tv278 = 232
tv194 = 240
tv247 = 248
addr$ = 256
address$ = 272
__$ArrayPad$ = 296
argp$ = 320
CTCE_ConnectThread PROC

; 3588 : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	57		 push	 rdi
  00006	48 81 ec 30 01
	00 00		 sub	 rsp, 304		; 00000130H
  0000d	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00014	48 33 c4	 xor	 rax, rsp
  00017	48 89 84 24 28
	01 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 3589 :     DEVBLK             *dev = (DEVBLK*) argp;         // argp is the device block pointer

  0001f	48 8b 84 24 40
	01 00 00	 mov	 rax, QWORD PTR argp$[rsp]
  00027	48 89 84 24 80
	00 00 00	 mov	 QWORD PTR dev$[rsp], rax

; 3590 :     int                 fd;                           // socket file descriptor
; 3591 :     struct sockaddr_in  addr;                         // socket destination address info
; 3592 :     int                 rc = 0;                       // Return Code

  0002f	c7 84 24 8c 00
	00 00 00 00 00
	00		 mov	 DWORD PTR rc$[rsp], 0

; 3593 :     const int           connect_retry_interval = 500; // in msec

  0003a	c7 84 24 98 00
	00 00 f4 01 00
	00		 mov	 DWORD PTR connect_retry_interval$[rsp], 500 ; 000001f4H

; 3594 :     const int           connect_msg_interval = 600;   // in sec, e,g, 10 minutes

  00045	c7 84 24 b8 00
	00 00 58 02 00
	00		 mov	 DWORD PTR connect_msg_interval$[rsp], 600 ; 00000258H

; 3595 :     int                 attempts_counter = 0;         // rotates up to a maximum of ...

  00050	c7 84 24 94 00
	00 00 00 00 00
	00		 mov	 DWORD PTR attempts_counter$[rsp], 0

; 3596 :     const int           attempts_counter_max =        // results in a msg every 10 min

  0005b	69 84 24 b8 00
	00 00 e8 03 00
	00		 imul	 eax, DWORD PTR connect_msg_interval$[rsp], 1000 ; 000003e8H
  00066	99		 cdq
  00067	f7 bc 24 98 00
	00 00		 idiv	 DWORD PTR connect_retry_interval$[rsp]
  0006e	89 84 24 a0 00
	00 00		 mov	 DWORD PTR attempts_counter_max$[rsp], eax

; 3597 :                             connect_msg_interval *
; 3598 :                             1000 / connect_retry_interval;
; 3599 :     BYTE                renewed;                      // When renewing a CTCE connection
; 3600 :     char*               remaddr;                      // Remote IP address
; 3601 :     char                address[20]="";               // temp space for IP address

  00075	0f b6 05 00 00
	00 00		 movzx	 eax, BYTE PTR $SG170359
  0007c	88 84 24 10 01
	00 00		 mov	 BYTE PTR address$[rsp], al
  00083	48 8d 84 24 11
	01 00 00	 lea	 rax, QWORD PTR address$[rsp+1]
  0008b	48 8b f8	 mov	 rdi, rax
  0008e	33 c0		 xor	 eax, eax
  00090	b9 13 00 00 00	 mov	 ecx, 19
  00095	f3 aa		 rep stosb

; 3602 : 
; 3603 : 
; 3604 :     // Obtain a socket to connect to the other end.
; 3605 :     obtain_lock( &dev->lock );

  00097	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  0009f	48 83 c0 38	 add	 rax, 56			; 00000038H
  000a3	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG170360
  000aa	48 8b c8	 mov	 rcx, rax
  000ad	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_obtain_lock
$LN4@CTCE_Conne:

; 3606 : 
; 3607 :     // We must keep on trying to connect until it is successful,
; 3608 :     // which is why we do this in a separate dedicated thread.
; 3609 :     do
; 3610 :     {
; 3611 :         if ( ( fd = CTCE_Get_Socket( dev, CTCE_SOK_CON ) ) < 0 )

  000b3	ba 01 00 00 00	 mov	 edx, 1
  000b8	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  000c0	e8 00 00 00 00	 call	 CTCE_Get_Socket
  000c5	89 84 24 90 00
	00 00		 mov	 DWORD PTR fd$[rsp], eax
  000cc	83 bc 24 90 00
	00 00 00	 cmp	 DWORD PTR fd$[rsp], 0
  000d4	7d 23		 jge	 SHORT $LN5@CTCE_Conne

; 3612 :         {
; 3613 :             release_lock( &dev->lock );

  000d6	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  000de	48 83 c0 38	 add	 rax, 56			; 00000038H
  000e2	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG170362
  000e9	48 8b c8	 mov	 rcx, rax
  000ec	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_release_lock

; 3614 :             return NULL;

  000f2	33 c0		 xor	 eax, eax
  000f4	e9 cb 06 00 00	 jmp	 $LN1@CTCE_Conne
$LN5@CTCE_Conne:

; 3615 :         }
; 3616 : 
; 3617 :         // Initialise the destination IP address.
; 3618 :         strcpy( address, inet_ntoa( dev->ctce_ipaddr ) );

  000f9	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00101	8b 88 5c 07 00
	00		 mov	 ecx, DWORD PTR [rax+1884]
  00107	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_inet_ntoa
  0010d	48 8b d0	 mov	 rdx, rax
  00110	48 8d 8c 24 10
	01 00 00	 lea	 rcx, QWORD PTR address$[rsp]
  00118	e8 00 00 00 00	 call	 strcpy

; 3619 :         remaddr = address;

  0011d	48 8d 84 24 10
	01 00 00	 lea	 rax, QWORD PTR address$[rsp]
  00125	48 89 84 24 b0
	00 00 00	 mov	 QWORD PTR remaddr$[rsp], rax

; 3620 :         memset( &addr, 0, sizeof( addr ) );

  0012d	48 8d 84 24 00
	01 00 00	 lea	 rax, QWORD PTR addr$[rsp]
  00135	48 8b f8	 mov	 rdi, rax
  00138	33 c0		 xor	 eax, eax
  0013a	b9 10 00 00 00	 mov	 ecx, 16
  0013f	f3 aa		 rep stosb

; 3621 :         addr.sin_family = AF_INET;

  00141	b8 02 00 00 00	 mov	 eax, 2
  00146	66 89 84 24 00
	01 00 00	 mov	 WORD PTR addr$[rsp], ax

; 3622 :         addr.sin_addr = dev->ctce_ipaddr;

  0014e	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00156	8b 80 5c 07 00
	00		 mov	 eax, DWORD PTR [rax+1884]
  0015c	89 84 24 04 01
	00 00		 mov	 DWORD PTR addr$[rsp+4], eax

; 3623 :         addr.sin_port = htons( dev->ctce_rport );

  00163	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  0016b	0f b7 88 58 07
	00 00		 movzx	 ecx, WORD PTR [rax+1880]
  00172	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_htons
  00178	66 89 84 24 02
	01 00 00	 mov	 WORD PTR addr$[rsp+2], ax

; 3624 : 
; 3625 :         // During the blocking connect() and a possible retry wait interval we release the device lock.
; 3626 :         release_lock( &dev->lock );

  00180	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00188	48 83 c0 38	 add	 rax, 56			; 00000038H
  0018c	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG170363
  00193	48 8b c8	 mov	 rcx, rax
  00196	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_release_lock

; 3627 :         rc = connect( fd, ( struct sockaddr * )&addr, sizeof( addr ) );

  0019c	48 63 84 24 90
	00 00 00	 movsxd	 rax, DWORD PTR fd$[rsp]
  001a4	41 b8 10 00 00
	00		 mov	 r8d, 16
  001aa	48 8d 94 24 00
	01 00 00	 lea	 rdx, QWORD PTR addr$[rsp]
  001b2	48 8b c8	 mov	 rcx, rax
  001b5	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_connect
  001bb	89 84 24 8c 00
	00 00		 mov	 DWORD PTR rc$[rsp], eax

; 3628 :         if ( rc < 0 )

  001c2	83 bc 24 8c 00
	00 00 00	 cmp	 DWORD PTR rc$[rsp], 0
  001ca	7d 20		 jge	 SHORT $LN6@CTCE_Conne

; 3629 :         {
; 3630 :             close_socket( fd );

  001cc	8b 8c 24 90 00
	00 00		 mov	 ecx, DWORD PTR fd$[rsp]
  001d3	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_close_socket

; 3631 :             usleep(connect_retry_interval * 1000) ;

  001d9	69 84 24 98 00
	00 00 e8 03 00
	00		 imul	 eax, DWORD PTR connect_retry_interval$[rsp], 1000 ; 000003e8H
  001e4	8b c8		 mov	 ecx, eax
  001e6	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_usleep
$LN6@CTCE_Conne:

; 3632 :         }
; 3633 :         obtain_lock( &dev->lock );

  001ec	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  001f4	48 83 c0 38	 add	 rax, 56			; 00000038H
  001f8	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG170365
  001ff	48 8b c8	 mov	 rcx, rax
  00202	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_obtain_lock

; 3634 : 
; 3635 :         // A successful connect() is immediately followed by a initial write.
; 3636 :         if ( rc == 0 )

  00208	83 bc 24 8c 00
	00 00 00	 cmp	 DWORD PTR rc$[rsp], 0
  00210	75 1b		 jne	 SHORT $LN7@CTCE_Conne

; 3637 :         {
; 3638 :             rc = CTCE_Write_Init( dev, fd );

  00212	8b 94 24 90 00
	00 00		 mov	 edx, DWORD PTR fd$[rsp]
  00219	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  00221	e8 00 00 00 00	 call	 CTCE_Write_Init
  00226	89 84 24 8c 00
	00 00		 mov	 DWORD PTR rc$[rsp], eax
$LN7@CTCE_Conne:

; 3639 :         }
; 3640 : 
; 3641 :         // The first message appears just once after (each re-)initialisation,
; 3642 :         // attempt, the second one every connect_message_interval. (= 1200*0.5 sec).
; 3643 :         attempts_counter = ( attempts_counter > attempts_counter_max ) ? 2 : ( attempts_counter + 1 ) ;

  0022d	8b 84 24 a0 00
	00 00		 mov	 eax, DWORD PTR attempts_counter_max$[rsp]
  00234	39 84 24 94 00
	00 00		 cmp	 DWORD PTR attempts_counter$[rsp], eax
  0023b	7e 0d		 jle	 SHORT $LN15@CTCE_Conne
  0023d	c7 84 24 9c 00
	00 00 02 00 00
	00		 mov	 DWORD PTR tv154[rsp], 2
  00248	eb 10		 jmp	 SHORT $LN16@CTCE_Conne
$LN15@CTCE_Conne:
  0024a	8b 84 24 94 00
	00 00		 mov	 eax, DWORD PTR attempts_counter$[rsp]
  00251	ff c0		 inc	 eax
  00253	89 84 24 9c 00
	00 00		 mov	 DWORD PTR tv154[rsp], eax
$LN16@CTCE_Conne:
  0025a	8b 84 24 9c 00
	00 00		 mov	 eax, DWORD PTR tv154[rsp]
  00261	89 84 24 94 00
	00 00		 mov	 DWORD PTR attempts_counter$[rsp], eax

; 3644 :         if( ( attempts_counter == 1 ) && ( dev->fd < 0 ) && ( rc < 0 ) )

  00268	83 bc 24 94 00
	00 00 01	 cmp	 DWORD PTR attempts_counter$[rsp], 1
  00270	0f 85 11 01 00
	00		 jne	 $LN8@CTCE_Conne
  00276	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  0027e	83 b8 ac 01 00
	00 00		 cmp	 DWORD PTR [rax+428], 0
  00285	0f 8d fc 00 00
	00		 jge	 $LN8@CTCE_Conne
  0028b	83 bc 24 8c 00
	00 00 00	 cmp	 DWORD PTR rc$[rsp], 0
  00293	0f 8d ee 00 00
	00		 jge	 $LN8@CTCE_Conne

; 3645 :         {
; 3646 :             WRMSG( HHC05065, "I",  // CTCE: Attempt outbound connection :%5d -> %1d:%04X=%s:%d"

  00299	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  002a1	0f b7 80 64 07
	00 00		 movzx	 eax, WORD PTR [rax+1892]
  002a8	89 84 24 bc 00
	00 00		 mov	 DWORD PTR tv163[rsp], eax
  002af	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  002b7	0f b7 49 44	 movzx	 ecx, WORD PTR [rcx+68]
  002bb	d1 f9		 sar	 ecx, 1
  002bd	89 8c 24 c0 00
	00 00		 mov	 DWORD PTR tv167[rsp], ecx
  002c4	48 8b 94 24 80
	00 00 00	 mov	 rdx, QWORD PTR dev$[rsp]
  002cc	0f b7 52 48	 movzx	 edx, WORD PTR [rdx+72]
  002d0	89 94 24 c4 00
	00 00		 mov	 DWORD PTR tv172[rsp], edx
  002d7	48 8b bc 24 80
	00 00 00	 mov	 rdi, QWORD PTR dev$[rsp]
  002df	0f b7 7f 44	 movzx	 edi, WORD PTR [rdi+68]
  002e3	d1 ff		 sar	 edi, 1
  002e5	b9 01 00 00 00	 mov	 ecx, 1
  002ea	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  002f0	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  002f8	8b 89 58 07 00
	00		 mov	 ecx, DWORD PTR [rcx+1880]
  002fe	89 4c 24 68	 mov	 DWORD PTR [rsp+104], ecx
  00302	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR remaddr$[rsp]
  0030a	48 89 4c 24 60	 mov	 QWORD PTR [rsp+96], rcx
  0030f	8b 8c 24 bc 00
	00 00		 mov	 ecx, DWORD PTR tv163[rsp]
  00316	89 4c 24 58	 mov	 DWORD PTR [rsp+88], ecx
  0031a	8b 8c 24 c0 00
	00 00		 mov	 ecx, DWORD PTR tv167[rsp]
  00321	89 4c 24 50	 mov	 DWORD PTR [rsp+80], ecx
  00325	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  0032d	8b 89 50 07 00
	00		 mov	 ecx, DWORD PTR [rcx+1872]
  00333	89 4c 24 48	 mov	 DWORD PTR [rsp+72], ecx
  00337	8b 8c 24 c4 00
	00 00		 mov	 ecx, DWORD PTR tv172[rsp]
  0033e	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  00342	89 7c 24 38	 mov	 DWORD PTR [rsp+56], edi
  00346	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170369
  0034d	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  00352	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170370
  00359	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  0035e	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00363	41 b9 03 00 00
	00		 mov	 r9d, 3
  00369	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG170371
  00370	ba 40 0e 00 00	 mov	 edx, 3648		; 00000e40H
  00375	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170372
  0037c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 3647 :                 CTCX_DEVNUM( dev ), dev->ctce_lport, SSID_TO_LCSS(dev->ssid),
; 3648 :                 dev->ctce_rccuu, remaddr, dev->ctce_rport );
; 3649 :         }

  00382	e9 75 01 00 00	 jmp	 $LN9@CTCE_Conne
$LN8@CTCE_Conne:

; 3650 :         else if( ( attempts_counter == attempts_counter_max ) && ( dev->ctce_trace_cntr > 0 ) )

  00387	8b 84 24 a0 00
	00 00		 mov	 eax, DWORD PTR attempts_counter_max$[rsp]
  0038e	39 84 24 94 00
	00 00		 cmp	 DWORD PTR attempts_counter$[rsp], eax
  00395	0f 85 61 01 00
	00		 jne	 $LN10@CTCE_Conne
  0039b	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  003a3	83 b8 68 07 00
	00 00		 cmp	 DWORD PTR [rax+1896], 0
  003aa	0f 8e 4c 01 00
	00		 jle	 $LN10@CTCE_Conne

; 3651 :         {
; 3652 :             WRMSG( HHC05072, "I",  // CTCE: Still attempting connection :%5d -> %1d:%04X=%s:%d%s"

  003b0	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  003b8	8b 80 68 07 00
	00		 mov	 eax, DWORD PTR [rax+1896]
  003be	ff c8		 dec	 eax
  003c0	89 84 24 a4 00
	00 00		 mov	 DWORD PTR tv192[rsp], eax
  003c7	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  003cf	8b 8c 24 a4 00
	00 00		 mov	 ecx, DWORD PTR tv192[rsp]
  003d6	89 88 68 07 00
	00		 mov	 DWORD PTR [rax+1896], ecx
  003dc	83 bc 24 a4 00
	00 00 00	 cmp	 DWORD PTR tv192[rsp], 0
  003e4	74 11		 je	 SHORT $LN17@CTCE_Conne
  003e6	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG170374
  003ed	48 89 84 24 f0
	00 00 00	 mov	 QWORD PTR tv194[rsp], rax
  003f5	eb 0f		 jmp	 SHORT $LN18@CTCE_Conne
$LN17@CTCE_Conne:
  003f7	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG170375
  003fe	48 89 84 24 f0
	00 00 00	 mov	 QWORD PTR tv194[rsp], rax
$LN18@CTCE_Conne:
  00406	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  0040e	0f b7 80 64 07
	00 00		 movzx	 eax, WORD PTR [rax+1892]
  00415	89 84 24 c8 00
	00 00		 mov	 DWORD PTR tv200[rsp], eax
  0041c	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  00424	0f b7 49 44	 movzx	 ecx, WORD PTR [rcx+68]
  00428	d1 f9		 sar	 ecx, 1
  0042a	89 8c 24 cc 00
	00 00		 mov	 DWORD PTR tv204[rsp], ecx
  00431	48 8b 94 24 80
	00 00 00	 mov	 rdx, QWORD PTR dev$[rsp]
  00439	0f b7 52 48	 movzx	 edx, WORD PTR [rdx+72]
  0043d	89 94 24 d0 00
	00 00		 mov	 DWORD PTR tv209[rsp], edx
  00444	48 8b bc 24 80
	00 00 00	 mov	 rdi, QWORD PTR dev$[rsp]
  0044c	0f b7 7f 44	 movzx	 edi, WORD PTR [rdi+68]
  00450	d1 ff		 sar	 edi, 1
  00452	b9 01 00 00 00	 mov	 ecx, 1
  00457	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  0045d	48 8b 8c 24 f0
	00 00 00	 mov	 rcx, QWORD PTR tv194[rsp]
  00465	48 89 4c 24 70	 mov	 QWORD PTR [rsp+112], rcx
  0046a	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  00472	8b 89 58 07 00
	00		 mov	 ecx, DWORD PTR [rcx+1880]
  00478	89 4c 24 68	 mov	 DWORD PTR [rsp+104], ecx
  0047c	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR remaddr$[rsp]
  00484	48 89 4c 24 60	 mov	 QWORD PTR [rsp+96], rcx
  00489	8b 8c 24 c8 00
	00 00		 mov	 ecx, DWORD PTR tv200[rsp]
  00490	89 4c 24 58	 mov	 DWORD PTR [rsp+88], ecx
  00494	8b 8c 24 cc 00
	00 00		 mov	 ecx, DWORD PTR tv204[rsp]
  0049b	89 4c 24 50	 mov	 DWORD PTR [rsp+80], ecx
  0049f	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  004a7	8b 89 50 07 00
	00		 mov	 ecx, DWORD PTR [rcx+1872]
  004ad	89 4c 24 48	 mov	 DWORD PTR [rsp+72], ecx
  004b1	8b 8c 24 d0 00
	00 00		 mov	 ecx, DWORD PTR tv209[rsp]
  004b8	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  004bc	89 7c 24 38	 mov	 DWORD PTR [rsp+56], edi
  004c0	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170376
  004c7	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  004cc	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170377
  004d3	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  004d8	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  004dd	41 b9 03 00 00
	00		 mov	 r9d, 3
  004e3	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG170378
  004ea	ba 47 0e 00 00	 mov	 edx, 3655		; 00000e47H
  004ef	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170379
  004f6	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg
$LN10@CTCE_Conne:
$LN9@CTCE_Conne:

; 3653 :                 CTCX_DEVNUM( dev ), dev->ctce_lport, SSID_TO_LCSS(dev->ssid),
; 3654 :                 dev->ctce_rccuu, remaddr, dev->ctce_rport,
; 3655 :                 --dev->ctce_trace_cntr ? "" : "." );
; 3656 :         }
; 3657 : 
; 3658 :     // We connect to the other side, but this will keep on failing
; 3659 :     // until the other side has started listening with accept(),
; 3660 :     // provided no DETACH or DEVINIT command was issued before.
; 3661 :     } while ( ( rc < 0 ) && dev->allocated);

  004fc	83 bc 24 8c 00
	00 00 00	 cmp	 DWORD PTR rc$[rsp], 0
  00504	7d 12		 jge	 SHORT $LN11@CTCE_Conne
  00506	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  0050e	83 78 40 00	 cmp	 DWORD PTR [rax+64], 0
  00512	0f 85 9b fb ff
	ff		 jne	 $LN4@CTCE_Conne
$LN11@CTCE_Conne:

; 3662 : 
; 3663 :     // If we connected OK then send/write socket fd is now known.
; 3664 :     if ( rc == 0 )

  00518	83 bc 24 8c 00
	00 00 00	 cmp	 DWORD PTR rc$[rsp], 0
  00520	0f 85 74 01 00
	00		 jne	 $LN12@CTCE_Conne

; 3665 :     {
; 3666 :         renewed = ( dev->fd != -1 ) ? 1 : 0;

  00526	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  0052e	83 b8 ac 01 00
	00 ff		 cmp	 DWORD PTR [rax+428], -1
  00535	74 0d		 je	 SHORT $LN19@CTCE_Conne
  00537	c7 84 24 a8 00
	00 00 01 00 00
	00		 mov	 DWORD PTR tv230[rsp], 1
  00542	eb 0b		 jmp	 SHORT $LN20@CTCE_Conne
$LN19@CTCE_Conne:
  00544	c7 84 24 a8 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv230[rsp], 0
$LN20@CTCE_Conne:
  0054f	0f b6 84 24 a8
	00 00 00	 movzx	 eax, BYTE PTR tv230[rsp]
  00557	88 84 24 88 00
	00 00		 mov	 BYTE PTR renewed$[rsp], al

; 3667 :         dev->fd = fd;

  0055e	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00566	8b 8c 24 90 00
	00 00		 mov	 ecx, DWORD PTR fd$[rsp]
  0056d	89 88 ac 01 00
	00		 mov	 DWORD PTR [rax+428], ecx

; 3668 : 
; 3669 :         WRMSG( HHC05054, "I",  // CTCE: %s outbound connection :%5d -> %1d:%04X=%s:%d"

  00573	0f b6 84 24 88
	00 00 00	 movzx	 eax, BYTE PTR renewed$[rsp]
  0057b	85 c0		 test	 eax, eax
  0057d	74 11		 je	 SHORT $LN21@CTCE_Conne
  0057f	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG170383
  00586	48 89 84 24 f8
	00 00 00	 mov	 QWORD PTR tv247[rsp], rax
  0058e	eb 0f		 jmp	 SHORT $LN22@CTCE_Conne
$LN21@CTCE_Conne:
  00590	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG170384
  00597	48 89 84 24 f8
	00 00 00	 mov	 QWORD PTR tv247[rsp], rax
$LN22@CTCE_Conne:
  0059f	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  005a7	0f b7 80 64 07
	00 00		 movzx	 eax, WORD PTR [rax+1892]
  005ae	89 84 24 d4 00
	00 00		 mov	 DWORD PTR tv237[rsp], eax
  005b5	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  005bd	0f b7 49 44	 movzx	 ecx, WORD PTR [rcx+68]
  005c1	d1 f9		 sar	 ecx, 1
  005c3	89 8c 24 d8 00
	00 00		 mov	 DWORD PTR tv241[rsp], ecx
  005ca	48 8b 94 24 80
	00 00 00	 mov	 rdx, QWORD PTR dev$[rsp]
  005d2	0f b7 52 48	 movzx	 edx, WORD PTR [rdx+72]
  005d6	89 94 24 dc 00
	00 00		 mov	 DWORD PTR tv250[rsp], edx
  005dd	48 8b bc 24 80
	00 00 00	 mov	 rdi, QWORD PTR dev$[rsp]
  005e5	0f b7 7f 44	 movzx	 edi, WORD PTR [rdi+68]
  005e9	d1 ff		 sar	 edi, 1
  005eb	b9 01 00 00 00	 mov	 ecx, 1
  005f0	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  005f6	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  005fe	8b 89 58 07 00
	00		 mov	 ecx, DWORD PTR [rcx+1880]
  00604	89 4c 24 70	 mov	 DWORD PTR [rsp+112], ecx
  00608	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR remaddr$[rsp]
  00610	48 89 4c 24 68	 mov	 QWORD PTR [rsp+104], rcx
  00615	8b 8c 24 d4 00
	00 00		 mov	 ecx, DWORD PTR tv237[rsp]
  0061c	89 4c 24 60	 mov	 DWORD PTR [rsp+96], ecx
  00620	8b 8c 24 d8 00
	00 00		 mov	 ecx, DWORD PTR tv241[rsp]
  00627	89 4c 24 58	 mov	 DWORD PTR [rsp+88], ecx
  0062b	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  00633	8b 89 54 07 00
	00		 mov	 ecx, DWORD PTR [rcx+1876]
  00639	89 4c 24 50	 mov	 DWORD PTR [rsp+80], ecx
  0063d	48 8b 8c 24 f8
	00 00 00	 mov	 rcx, QWORD PTR tv247[rsp]
  00645	48 89 4c 24 48	 mov	 QWORD PTR [rsp+72], rcx
  0064a	8b 8c 24 dc 00
	00 00		 mov	 ecx, DWORD PTR tv250[rsp]
  00651	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  00655	89 7c 24 38	 mov	 DWORD PTR [rsp+56], edi
  00659	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170385
  00660	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  00665	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170386
  0066c	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00671	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00676	41 b9 03 00 00
	00		 mov	 r9d, 3
  0067c	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG170387
  00683	ba 58 0e 00 00	 mov	 edx, 3672		; 00000e58H
  00688	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170388
  0068f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 3670 :             CTCX_DEVNUM( dev ), ( renewed ? "Renewed" : "Started" ),
; 3671 :             dev->ctce_connect_lport, SSID_TO_LCSS( dev->ssid ),
; 3672 :             dev->ctce_rccuu, remaddr, dev->ctce_rport );
; 3673 :     }

  00695	e9 0c 01 00 00	 jmp	 $LN13@CTCE_Conne
$LN12@CTCE_Conne:

; 3674 : 
; 3675 :     // If the connection was not successful then we either encountered an
; 3676 :     // error, or the user decided to quit before starting the other side.
; 3677 :     else
; 3678 :     {
; 3679 :         WRMSG( HHC05078, "I",  // CTCE: Aborted outbound connection :%5d -> %1d:%04X=%s:%d"

  0069a	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  006a2	0f b7 80 64 07
	00 00		 movzx	 eax, WORD PTR [rax+1892]
  006a9	89 84 24 e0 00
	00 00		 mov	 DWORD PTR tv269[rsp], eax
  006b0	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  006b8	0f b7 49 44	 movzx	 ecx, WORD PTR [rcx+68]
  006bc	d1 f9		 sar	 ecx, 1
  006be	89 8c 24 e4 00
	00 00		 mov	 DWORD PTR tv273[rsp], ecx
  006c5	48 8b 94 24 80
	00 00 00	 mov	 rdx, QWORD PTR dev$[rsp]
  006cd	0f b7 52 48	 movzx	 edx, WORD PTR [rdx+72]
  006d1	89 94 24 e8 00
	00 00		 mov	 DWORD PTR tv278[rsp], edx
  006d8	48 8b bc 24 80
	00 00 00	 mov	 rdi, QWORD PTR dev$[rsp]
  006e0	0f b7 7f 44	 movzx	 edi, WORD PTR [rdi+68]
  006e4	d1 ff		 sar	 edi, 1
  006e6	b9 01 00 00 00	 mov	 ecx, 1
  006eb	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  006f1	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  006f9	8b 89 58 07 00
	00		 mov	 ecx, DWORD PTR [rcx+1880]
  006ff	89 4c 24 68	 mov	 DWORD PTR [rsp+104], ecx
  00703	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR remaddr$[rsp]
  0070b	48 89 4c 24 60	 mov	 QWORD PTR [rsp+96], rcx
  00710	8b 8c 24 e0 00
	00 00		 mov	 ecx, DWORD PTR tv269[rsp]
  00717	89 4c 24 58	 mov	 DWORD PTR [rsp+88], ecx
  0071b	8b 8c 24 e4 00
	00 00		 mov	 ecx, DWORD PTR tv273[rsp]
  00722	89 4c 24 50	 mov	 DWORD PTR [rsp+80], ecx
  00726	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  0072e	8b 89 50 07 00
	00		 mov	 ecx, DWORD PTR [rcx+1872]
  00734	89 4c 24 48	 mov	 DWORD PTR [rsp+72], ecx
  00738	8b 8c 24 e8 00
	00 00		 mov	 ecx, DWORD PTR tv278[rsp]
  0073f	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  00743	89 7c 24 38	 mov	 DWORD PTR [rsp+56], edi
  00747	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170389
  0074e	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  00753	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170390
  0075a	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  0075f	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00764	41 b9 03 00 00
	00		 mov	 r9d, 3
  0076a	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG170391
  00771	ba 61 0e 00 00	 mov	 edx, 3681		; 00000e61H
  00776	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170392
  0077d	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 3680 :             CTCX_DEVNUM( dev ), dev->ctce_lport, SSID_TO_LCSS(dev->ssid),
; 3681 :             dev->ctce_rccuu, remaddr, dev->ctce_rport );
; 3682 :         shutdown( fd, SHUT_RDWR );

  00783	48 63 84 24 90
	00 00 00	 movsxd	 rax, DWORD PTR fd$[rsp]
  0078b	ba 02 00 00 00	 mov	 edx, 2
  00790	48 8b c8	 mov	 rcx, rax
  00793	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_shutdown

; 3683 :         close_socket( fd );

  00799	8b 8c 24 90 00
	00 00		 mov	 ecx, DWORD PTR fd$[rsp]
  007a0	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_close_socket
$LN13@CTCE_Conne:

; 3684 :     }
; 3685 : 
; 3686 :     release_lock( &dev->lock );

  007a6	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  007ae	48 83 c0 38	 add	 rax, 56			; 00000038H
  007b2	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG170393
  007b9	48 8b c8	 mov	 rcx, rax
  007bc	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_release_lock

; 3687 :     return NULL;

  007c2	33 c0		 xor	 eax, eax
$LN1@CTCE_Conne:

; 3688 : 
; 3689 : } // CTCE_ConnectThread

  007c4	48 8b 8c 24 28
	01 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  007cc	48 33 cc	 xor	 rcx, rsp
  007cf	e8 00 00 00 00	 call	 __security_check_cookie
  007d4	48 81 c4 30 01
	00 00		 add	 rsp, 304		; 00000130H
  007db	5f		 pop	 rdi
  007dc	c3		 ret	 0
CTCE_ConnectThread ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\ctcadpt.c
_TEXT	SEGMENT
ctce_Cmd$ = 208
ctce_state_verify$ = 209
ctce_state_r_xy$ = 212
ctce_state_l_xy$ = 216
ctce_PktSeq$ = 220
pSokBuf$ = 224
tv93 = 232
tv95 = 236
tv132 = 240
tv156 = 244
tv157 = 248
tv184 = 252
tv185 = 256
tv219 = 260
tv220 = 264
tv247 = 268
tv248 = 272
tv279 = 276
tv280 = 280
tv307 = 284
tv308 = 288
tv331 = 292
tv338 = 296
tv362 = 300
tv363 = 304
tv390 = 308
tv391 = 312
tv423 = 316
tv424 = 320
tv451 = 324
tv452 = 328
tv481 = 332
tv482 = 336
tv509 = 340
tv510 = 344
tv678 = 348
tv679 = 352
tv796 = 356
tv894 = 360
tv895 = 364
tv1001 = 368
tv1002 = 372
tv1049 = 376
tv92 = 380
tv965 = 384
tv971 = 388
tv979 = 392
tv333 = 396
$T1 = 400
tv912 = 408
tv918 = 416
tv924 = 424
tv962 = 432
tv1091 = 440
tv974 = 448
tv1092 = 456
tv1003 = 464
ctce_devnum$ = 472
ctce_trace_stat$ = 480
ctce_trace_xtra_temp$ = 512
ctce_trace_xtra$ = 768
__$ArrayPad$ = 1024
pDEVBLK$ = 1104
eCTCE_Cmd_Xfr$ = 1112
pCTCE_Info$ = 1120
pUnitStat$ = 1128
CTCE_Trace PROC

; 3181 : {

  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  0000e	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00013	53		 push	 rbx
  00014	55		 push	 rbp
  00015	56		 push	 rsi
  00016	57		 push	 rdi
  00017	41 56		 push	 r14
  00019	41 57		 push	 r15
  0001b	48 81 ec 18 04
	00 00		 sub	 rsp, 1048		; 00000418H
  00022	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00029	48 33 c4	 xor	 rax, rsp
  0002c	48 89 84 24 00
	04 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 3182 :     static char *CTCE_XfrStr[5] = {
; 3183 :         "--" ,  //  0 = CTCE_LCL
; 3184 :         "->" ,  //  1 = CTCE_SND
; 3185 :         "<-" ,  //  2 = CTCE_RCV
; 3186 :         "-|" ,  //  3 = CTCE_SND_NS
; 3187 :         "||"    //  4 = CTCE_SND_NSR
; 3188 :     };
; 3189 :     BYTE           ctce_Cmd;                   // CTCE command being traced
; 3190 :     BYTE           ctce_PktSeq;                // Packet Sequence number traced
; 3191 :     CTCE_SOKPFX   *pSokBuf;                    // overlay for buf inside DEVBLK
; 3192 :     BYTE           ctce_state_verify;          // CTCE state to be verfified
; 3193 :     char           ctce_state_l_xy[2];         // CTCE X+Y states, left
; 3194 :     char           ctce_state_r_xy[2];         // CTCE X+Y stares, right
; 3195 :     char           ctce_trace_stat[24];        // to contain " Stat=.. CC=. w=.,r=."
; 3196 :     char           ctce_trace_xtra[256];       // to contain extra info when tracing
; 3197 :     char           ctce_trace_xtra_temp[256];  // temporary work area for the above
; 3198 :     char           ctce_devnum[8];             // for ccwtrace packet trace information
; 3199 : 
; 3200 :     // The source for reporting dependings on the Command X-fer
; 3201 :     // direction.  The CTCE states are reported in lower case,
; 3202 :     // but a changed state is highlighted in upper case.
; 3203 :     if( eCTCE_Cmd_Xfr == CTCE_RCV )

  00034	83 bc 24 58 04
	00 00 02	 cmp	 DWORD PTR eCTCE_Cmd_Xfr$[rsp], 2
  0003c	0f 85 21 06 00
	00		 jne	 $LN2@CTCE_Trace

; 3204 :     {
; 3205 :         pSokBuf = ( CTCE_SOKPFX* ) ( pDEVBLK->buf +

  00042	48 8b 84 24 50
	04 00 00	 mov	 rax, QWORD PTR pDEVBLK$[rsp]
  0004a	8b 80 18 07 00
	00		 mov	 eax, DWORD PTR [rax+1816]
  00050	83 e0 01	 and	 eax, 1
  00053	85 c0		 test	 eax, eax
  00055	75 75		 jne	 SHORT $LN50@CTCE_Trace
  00057	48 8b 84 24 50
	04 00 00	 mov	 rax, QWORD PTR pDEVBLK$[rsp]
  0005f	8b 80 74 07 00
	00		 mov	 eax, DWORD PTR [rax+1908]
  00065	c1 e8 03	 shr	 eax, 3
  00068	83 e0 01	 and	 eax, 1
  0006b	85 c0		 test	 eax, eax
  0006d	75 5d		 jne	 SHORT $LN50@CTCE_Trace
  0006f	48 8b 84 24 50
	04 00 00	 mov	 rax, QWORD PTR pDEVBLK$[rsp]
  00077	0f b6 80 37 07
	00 00		 movzx	 eax, BYTE PTR [rax+1847]
  0007e	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:CTCE_command
  00085	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00089	83 f8 07	 cmp	 eax, 7
  0008c	75 0d		 jne	 SHORT $LN51@CTCE_Trace
  0008e	c7 84 24 7c 01
	00 00 03 00 00
	00		 mov	 DWORD PTR tv92[rsp], 3
  00099	eb 21		 jmp	 SHORT $LN52@CTCE_Trace
$LN51@CTCE_Trace:
  0009b	48 8b 84 24 50
	04 00 00	 mov	 rax, QWORD PTR pDEVBLK$[rsp]
  000a3	0f b6 80 37 07
	00 00		 movzx	 eax, BYTE PTR [rax+1847]
  000aa	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:CTCE_command
  000b1	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  000b5	89 84 24 7c 01
	00 00		 mov	 DWORD PTR tv92[rsp], eax
$LN52@CTCE_Trace:
  000bc	8b 84 24 7c 01
	00 00		 mov	 eax, DWORD PTR tv92[rsp]
  000c3	89 84 24 e8 00
	00 00		 mov	 DWORD PTR tv93[rsp], eax
  000ca	eb 21		 jmp	 SHORT $LN53@CTCE_Trace
$LN50@CTCE_Trace:
  000cc	48 8b 84 24 50
	04 00 00	 mov	 rax, QWORD PTR pDEVBLK$[rsp]
  000d4	0f b6 80 37 07
	00 00		 movzx	 eax, BYTE PTR [rax+1847]
  000db	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:CTCE_command
  000e2	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  000e6	89 84 24 e8 00
	00 00		 mov	 DWORD PTR tv93[rsp], eax
$LN53@CTCE_Trace:
  000ed	83 bc 24 e8 00
	00 00 03	 cmp	 DWORD PTR tv93[rsp], 3
  000f5	75 0d		 jne	 SHORT $LN54@CTCE_Trace
  000f7	c7 84 24 ec 00
	00 00 01 00 00
	00		 mov	 DWORD PTR tv95[rsp], 1
  00102	eb 0b		 jmp	 SHORT $LN55@CTCE_Trace
$LN54@CTCE_Trace:
  00104	c7 84 24 ec 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv95[rsp], 0
$LN55@CTCE_Trace:
  0010f	48 8b 84 24 50
	04 00 00	 mov	 rax, QWORD PTR pDEVBLK$[rsp]
  00117	8b 80 74 07 00
	00		 mov	 eax, DWORD PTR [rax+1908]
  0011d	c1 e8 06	 shr	 eax, 6
  00120	83 e0 01	 and	 eax, 1
  00123	33 84 24 ec 00
	00 00		 xor	 eax, DWORD PTR tv95[rsp]
  0012a	85 c0		 test	 eax, eax
  0012c	74 0d		 je	 SHORT $LN56@CTCE_Trace
  0012e	c7 84 24 f0 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv132[rsp], 0
  00139	eb 1a		 jmp	 SHORT $LN57@CTCE_Trace
$LN56@CTCE_Trace:
  0013b	48 8b 84 24 50
	04 00 00	 mov	 rax, QWORD PTR pDEVBLK$[rsp]
  00143	8b 80 d8 01 00
	00		 mov	 eax, DWORD PTR [rax+472]
  00149	99		 cdq
  0014a	2b c2		 sub	 eax, edx
  0014c	d1 f8		 sar	 eax, 1
  0014e	89 84 24 f0 00
	00 00		 mov	 DWORD PTR tv132[rsp], eax
$LN57@CTCE_Trace:
  00155	48 63 84 24 f0
	00 00 00	 movsxd	 rax, DWORD PTR tv132[rsp]
  0015d	48 8b 8c 24 50
	04 00 00	 mov	 rcx, QWORD PTR pDEVBLK$[rsp]
  00165	48 03 81 c8 01
	00 00		 add	 rax, QWORD PTR [rcx+456]
  0016c	48 89 84 24 e0
	00 00 00	 mov	 QWORD PTR pSokBuf$[rsp], rax

; 3206 :             ( pDEVBLK->ctce_buf_next_write ^ IS_CTCE_CCW_WRT( pDEVBLK->ctceyCmd )
; 3207 :             ? 0 : pDEVBLK->bufsize / 2 ) );
; 3208 :         ctce_Cmd    = pSokBuf->CmdReg;

  00174	48 8b 84 24 e0
	00 00 00	 mov	 rax, QWORD PTR pSokBuf$[rsp]
  0017c	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  0017f	88 84 24 d0 00
	00 00		 mov	 BYTE PTR ctce_Cmd$[rsp], al

; 3209 :         ctce_PktSeq = pSokBuf->PktSeq;

  00186	48 8b 84 24 e0
	00 00 00	 mov	 rax, QWORD PTR pSokBuf$[rsp]
  0018e	0f b6 40 04	 movzx	 eax, BYTE PTR [rax+4]
  00192	88 84 24 dc 00
	00 00		 mov	 BYTE PTR ctce_PktSeq$[rsp], al

; 3210 :         ctce_state_r_xy[0] = 32 + *CTCE_StaStr[CTCE_STATE( pCTCE_Info->state_x_prev )];

  00199	48 8b 84 24 50
	04 00 00	 mov	 rax, QWORD PTR pDEVBLK$[rsp]
  001a1	8b 80 18 07 00
	00		 mov	 eax, DWORD PTR [rax+1816]
  001a7	83 e0 01	 and	 eax, 1
  001aa	85 c0		 test	 eax, eax
  001ac	75 5f		 jne	 SHORT $LN58@CTCE_Trace
  001ae	48 8b 84 24 50
	04 00 00	 mov	 rax, QWORD PTR pDEVBLK$[rsp]
  001b6	8b 80 74 07 00
	00		 mov	 eax, DWORD PTR [rax+1908]
  001bc	c1 e8 03	 shr	 eax, 3
  001bf	83 e0 01	 and	 eax, 1
  001c2	85 c0		 test	 eax, eax
  001c4	75 47		 jne	 SHORT $LN58@CTCE_Trace
  001c6	48 8b 84 24 60
	04 00 00	 mov	 rax, QWORD PTR pCTCE_Info$[rsp]
  001ce	0f b6 40 04	 movzx	 eax, BYTE PTR [rax+4]
  001d2	83 e0 07	 and	 eax, 7
  001d5	83 f8 05	 cmp	 eax, 5
  001d8	75 0d		 jne	 SHORT $LN59@CTCE_Trace
  001da	c7 84 24 f4 00
	00 00 04 00 00
	00		 mov	 DWORD PTR tv156[rsp], 4
  001e5	eb 16		 jmp	 SHORT $LN60@CTCE_Trace
$LN59@CTCE_Trace:
  001e7	48 8b 84 24 60
	04 00 00	 mov	 rax, QWORD PTR pCTCE_Info$[rsp]
  001ef	0f b6 40 04	 movzx	 eax, BYTE PTR [rax+4]
  001f3	83 e0 07	 and	 eax, 7
  001f6	89 84 24 f4 00
	00 00		 mov	 DWORD PTR tv156[rsp], eax
$LN60@CTCE_Trace:
  001fd	8b 84 24 f4 00
	00 00		 mov	 eax, DWORD PTR tv156[rsp]
  00204	89 84 24 f8 00
	00 00		 mov	 DWORD PTR tv157[rsp], eax
  0020b	eb 16		 jmp	 SHORT $LN61@CTCE_Trace
$LN58@CTCE_Trace:
  0020d	48 8b 84 24 60
	04 00 00	 mov	 rax, QWORD PTR pCTCE_Info$[rsp]
  00215	0f b6 40 04	 movzx	 eax, BYTE PTR [rax+4]
  00219	83 e0 07	 and	 eax, 7
  0021c	89 84 24 f8 00
	00 00		 mov	 DWORD PTR tv157[rsp], eax
$LN61@CTCE_Trace:
  00223	48 63 84 24 f8
	00 00 00	 movsxd	 rax, DWORD PTR tv157[rsp]
  0022b	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:CTCE_StaStr
  00232	48 8b 04 c1	 mov	 rax, QWORD PTR [rcx+rax*8]
  00236	0f be 00	 movsx	 eax, BYTE PTR [rax]
  00239	83 c0 20	 add	 eax, 32			; 00000020H
  0023c	b9 01 00 00 00	 mov	 ecx, 1
  00241	48 6b c9 00	 imul	 rcx, rcx, 0
  00245	88 84 0c d4 00
	00 00		 mov	 BYTE PTR ctce_state_r_xy$[rsp+rcx], al

; 3211 :         ctce_state_r_xy[1] = 32 + *CTCE_StaStr[CTCE_STATE( pCTCE_Info->state_y_prev )];

  0024c	48 8b 84 24 50
	04 00 00	 mov	 rax, QWORD PTR pDEVBLK$[rsp]
  00254	8b 80 18 07 00
	00		 mov	 eax, DWORD PTR [rax+1816]
  0025a	83 e0 01	 and	 eax, 1
  0025d	85 c0		 test	 eax, eax
  0025f	75 5f		 jne	 SHORT $LN62@CTCE_Trace
  00261	48 8b 84 24 50
	04 00 00	 mov	 rax, QWORD PTR pDEVBLK$[rsp]
  00269	8b 80 74 07 00
	00		 mov	 eax, DWORD PTR [rax+1908]
  0026f	c1 e8 03	 shr	 eax, 3
  00272	83 e0 01	 and	 eax, 1
  00275	85 c0		 test	 eax, eax
  00277	75 47		 jne	 SHORT $LN62@CTCE_Trace
  00279	48 8b 84 24 60
	04 00 00	 mov	 rax, QWORD PTR pCTCE_Info$[rsp]
  00281	0f b6 40 05	 movzx	 eax, BYTE PTR [rax+5]
  00285	83 e0 07	 and	 eax, 7
  00288	83 f8 05	 cmp	 eax, 5
  0028b	75 0d		 jne	 SHORT $LN63@CTCE_Trace
  0028d	c7 84 24 fc 00
	00 00 04 00 00
	00		 mov	 DWORD PTR tv184[rsp], 4
  00298	eb 16		 jmp	 SHORT $LN64@CTCE_Trace
$LN63@CTCE_Trace:
  0029a	48 8b 84 24 60
	04 00 00	 mov	 rax, QWORD PTR pCTCE_Info$[rsp]
  002a2	0f b6 40 05	 movzx	 eax, BYTE PTR [rax+5]
  002a6	83 e0 07	 and	 eax, 7
  002a9	89 84 24 fc 00
	00 00		 mov	 DWORD PTR tv184[rsp], eax
$LN64@CTCE_Trace:
  002b0	8b 84 24 fc 00
	00 00		 mov	 eax, DWORD PTR tv184[rsp]
  002b7	89 84 24 00 01
	00 00		 mov	 DWORD PTR tv185[rsp], eax
  002be	eb 16		 jmp	 SHORT $LN65@CTCE_Trace
$LN62@CTCE_Trace:
  002c0	48 8b 84 24 60
	04 00 00	 mov	 rax, QWORD PTR pCTCE_Info$[rsp]
  002c8	0f b6 40 05	 movzx	 eax, BYTE PTR [rax+5]
  002cc	83 e0 07	 and	 eax, 7
  002cf	89 84 24 00 01
	00 00		 mov	 DWORD PTR tv185[rsp], eax
$LN65@CTCE_Trace:
  002d6	48 63 84 24 00
	01 00 00	 movsxd	 rax, DWORD PTR tv185[rsp]
  002de	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:CTCE_StaStr
  002e5	48 8b 04 c1	 mov	 rax, QWORD PTR [rcx+rax*8]
  002e9	0f be 00	 movsx	 eax, BYTE PTR [rax]
  002ec	83 c0 20	 add	 eax, 32			; 00000020H
  002ef	b9 01 00 00 00	 mov	 ecx, 1
  002f4	48 6b c9 01	 imul	 rcx, rcx, 1
  002f8	88 84 0c d4 00
	00 00		 mov	 BYTE PTR ctce_state_r_xy$[rsp+rcx], al

; 3212 :         if( ( pDEVBLK->ctcexState & 0x07 ) == ( pCTCE_Info->state_x_prev & 0x07 ) )

  002ff	48 8b 84 24 50
	04 00 00	 mov	 rax, QWORD PTR pDEVBLK$[rsp]
  00307	0f b6 80 34 07
	00 00		 movzx	 eax, BYTE PTR [rax+1844]
  0030e	83 e0 07	 and	 eax, 7
  00311	48 8b 8c 24 60
	04 00 00	 mov	 rcx, QWORD PTR pCTCE_Info$[rsp]
  00319	0f b6 49 04	 movzx	 ecx, BYTE PTR [rcx+4]
  0031d	83 e1 07	 and	 ecx, 7
  00320	3b c1		 cmp	 eax, ecx
  00322	0f 85 c1 00 00
	00		 jne	 $LN4@CTCE_Trace

; 3213 :         {
; 3214 :             ctce_state_l_xy[0] = 32 + *CTCE_StaStr[CTCE_STATE( pDEVBLK->ctcexState )];

  00328	48 8b 84 24 50
	04 00 00	 mov	 rax, QWORD PTR pDEVBLK$[rsp]
  00330	8b 80 18 07 00
	00		 mov	 eax, DWORD PTR [rax+1816]
  00336	83 e0 01	 and	 eax, 1
  00339	85 c0		 test	 eax, eax
  0033b	75 65		 jne	 SHORT $LN66@CTCE_Trace
  0033d	48 8b 84 24 50
	04 00 00	 mov	 rax, QWORD PTR pDEVBLK$[rsp]
  00345	8b 80 74 07 00
	00		 mov	 eax, DWORD PTR [rax+1908]
  0034b	c1 e8 03	 shr	 eax, 3
  0034e	83 e0 01	 and	 eax, 1
  00351	85 c0		 test	 eax, eax
  00353	75 4d		 jne	 SHORT $LN66@CTCE_Trace
  00355	48 8b 84 24 50
	04 00 00	 mov	 rax, QWORD PTR pDEVBLK$[rsp]
  0035d	0f b6 80 34 07
	00 00		 movzx	 eax, BYTE PTR [rax+1844]
  00364	83 e0 07	 and	 eax, 7
  00367	83 f8 05	 cmp	 eax, 5
  0036a	75 0d		 jne	 SHORT $LN67@CTCE_Trace
  0036c	c7 84 24 04 01
	00 00 04 00 00
	00		 mov	 DWORD PTR tv219[rsp], 4
  00377	eb 19		 jmp	 SHORT $LN68@CTCE_Trace
$LN67@CTCE_Trace:
  00379	48 8b 84 24 50
	04 00 00	 mov	 rax, QWORD PTR pDEVBLK$[rsp]
  00381	0f b6 80 34 07
	00 00		 movzx	 eax, BYTE PTR [rax+1844]
  00388	83 e0 07	 and	 eax, 7
  0038b	89 84 24 04 01
	00 00		 mov	 DWORD PTR tv219[rsp], eax
$LN68@CTCE_Trace:
  00392	8b 84 24 04 01
	00 00		 mov	 eax, DWORD PTR tv219[rsp]
  00399	89 84 24 08 01
	00 00		 mov	 DWORD PTR tv220[rsp], eax
  003a0	eb 19		 jmp	 SHORT $LN69@CTCE_Trace
$LN66@CTCE_Trace:
  003a2	48 8b 84 24 50
	04 00 00	 mov	 rax, QWORD PTR pDEVBLK$[rsp]
  003aa	0f b6 80 34 07
	00 00		 movzx	 eax, BYTE PTR [rax+1844]
  003b1	83 e0 07	 and	 eax, 7
  003b4	89 84 24 08 01
	00 00		 mov	 DWORD PTR tv220[rsp], eax
$LN69@CTCE_Trace:
  003bb	48 63 84 24 08
	01 00 00	 movsxd	 rax, DWORD PTR tv220[rsp]
  003c3	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:CTCE_StaStr
  003ca	48 8b 04 c1	 mov	 rax, QWORD PTR [rcx+rax*8]
  003ce	0f be 00	 movsx	 eax, BYTE PTR [rax]
  003d1	83 c0 20	 add	 eax, 32			; 00000020H
  003d4	b9 01 00 00 00	 mov	 ecx, 1
  003d9	48 6b c9 00	 imul	 rcx, rcx, 0
  003dd	88 84 0c d8 00
	00 00		 mov	 BYTE PTR ctce_state_l_xy$[rsp+rcx], al

; 3215 :         }

  003e4	e9 b9 00 00 00	 jmp	 $LN5@CTCE_Trace
$LN4@CTCE_Trace:

; 3216 :         else
; 3217 :         {
; 3218 :             ctce_state_l_xy[0] = *CTCE_StaStr[CTCE_STATE( pDEVBLK->ctcexState )];

  003e9	48 8b 84 24 50
	04 00 00	 mov	 rax, QWORD PTR pDEVBLK$[rsp]
  003f1	8b 80 18 07 00
	00		 mov	 eax, DWORD PTR [rax+1816]
  003f7	83 e0 01	 and	 eax, 1
  003fa	85 c0		 test	 eax, eax
  003fc	75 65		 jne	 SHORT $LN70@CTCE_Trace
  003fe	48 8b 84 24 50
	04 00 00	 mov	 rax, QWORD PTR pDEVBLK$[rsp]
  00406	8b 80 74 07 00
	00		 mov	 eax, DWORD PTR [rax+1908]
  0040c	c1 e8 03	 shr	 eax, 3
  0040f	83 e0 01	 and	 eax, 1
  00412	85 c0		 test	 eax, eax
  00414	75 4d		 jne	 SHORT $LN70@CTCE_Trace
  00416	48 8b 84 24 50
	04 00 00	 mov	 rax, QWORD PTR pDEVBLK$[rsp]
  0041e	0f b6 80 34 07
	00 00		 movzx	 eax, BYTE PTR [rax+1844]
  00425	83 e0 07	 and	 eax, 7
  00428	83 f8 05	 cmp	 eax, 5
  0042b	75 0d		 jne	 SHORT $LN71@CTCE_Trace
  0042d	c7 84 24 0c 01
	00 00 04 00 00
	00		 mov	 DWORD PTR tv247[rsp], 4
  00438	eb 19		 jmp	 SHORT $LN72@CTCE_Trace
$LN71@CTCE_Trace:
  0043a	48 8b 84 24 50
	04 00 00	 mov	 rax, QWORD PTR pDEVBLK$[rsp]
  00442	0f b6 80 34 07
	00 00		 movzx	 eax, BYTE PTR [rax+1844]
  00449	83 e0 07	 and	 eax, 7
  0044c	89 84 24 0c 01
	00 00		 mov	 DWORD PTR tv247[rsp], eax
$LN72@CTCE_Trace:
  00453	8b 84 24 0c 01
	00 00		 mov	 eax, DWORD PTR tv247[rsp]
  0045a	89 84 24 10 01
	00 00		 mov	 DWORD PTR tv248[rsp], eax
  00461	eb 19		 jmp	 SHORT $LN73@CTCE_Trace
$LN70@CTCE_Trace:
  00463	48 8b 84 24 50
	04 00 00	 mov	 rax, QWORD PTR pDEVBLK$[rsp]
  0046b	0f b6 80 34 07
	00 00		 movzx	 eax, BYTE PTR [rax+1844]
  00472	83 e0 07	 and	 eax, 7
  00475	89 84 24 10 01
	00 00		 mov	 DWORD PTR tv248[rsp], eax
$LN73@CTCE_Trace:
  0047c	48 63 84 24 10
	01 00 00	 movsxd	 rax, DWORD PTR tv248[rsp]
  00484	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:CTCE_StaStr
  0048b	48 8b 04 c1	 mov	 rax, QWORD PTR [rcx+rax*8]
  0048f	b9 01 00 00 00	 mov	 ecx, 1
  00494	48 6b c9 00	 imul	 rcx, rcx, 0
  00498	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  0049b	88 84 0c d8 00
	00 00		 mov	 BYTE PTR ctce_state_l_xy$[rsp+rcx], al
$LN5@CTCE_Trace:

; 3219 :         }
; 3220 :         if( ( pDEVBLK->ctceyState & 0x07 ) == ( pCTCE_Info->state_y_prev & 0x07 ) )

  004a2	48 8b 84 24 50
	04 00 00	 mov	 rax, QWORD PTR pDEVBLK$[rsp]
  004aa	0f b6 80 36 07
	00 00		 movzx	 eax, BYTE PTR [rax+1846]
  004b1	83 e0 07	 and	 eax, 7
  004b4	48 8b 8c 24 60
	04 00 00	 mov	 rcx, QWORD PTR pCTCE_Info$[rsp]
  004bc	0f b6 49 05	 movzx	 ecx, BYTE PTR [rcx+5]
  004c0	83 e1 07	 and	 ecx, 7
  004c3	3b c1		 cmp	 eax, ecx
  004c5	0f 85 c1 00 00
	00		 jne	 $LN6@CTCE_Trace

; 3221 :         {
; 3222 :             ctce_state_l_xy[1] = 32 + *CTCE_StaStr[CTCE_STATE( pDEVBLK->ctceyState )];

  004cb	48 8b 84 24 50
	04 00 00	 mov	 rax, QWORD PTR pDEVBLK$[rsp]
  004d3	8b 80 18 07 00
	00		 mov	 eax, DWORD PTR [rax+1816]
  004d9	83 e0 01	 and	 eax, 1
  004dc	85 c0		 test	 eax, eax
  004de	75 65		 jne	 SHORT $LN74@CTCE_Trace
  004e0	48 8b 84 24 50
	04 00 00	 mov	 rax, QWORD PTR pDEVBLK$[rsp]
  004e8	8b 80 74 07 00
	00		 mov	 eax, DWORD PTR [rax+1908]
  004ee	c1 e8 03	 shr	 eax, 3
  004f1	83 e0 01	 and	 eax, 1
  004f4	85 c0		 test	 eax, eax
  004f6	75 4d		 jne	 SHORT $LN74@CTCE_Trace
  004f8	48 8b 84 24 50
	04 00 00	 mov	 rax, QWORD PTR pDEVBLK$[rsp]
  00500	0f b6 80 36 07
	00 00		 movzx	 eax, BYTE PTR [rax+1846]
  00507	83 e0 07	 and	 eax, 7
  0050a	83 f8 05	 cmp	 eax, 5
  0050d	75 0d		 jne	 SHORT $LN75@CTCE_Trace
  0050f	c7 84 24 14 01
	00 00 04 00 00
	00		 mov	 DWORD PTR tv279[rsp], 4
  0051a	eb 19		 jmp	 SHORT $LN76@CTCE_Trace
$LN75@CTCE_Trace:
  0051c	48 8b 84 24 50
	04 00 00	 mov	 rax, QWORD PTR pDEVBLK$[rsp]
  00524	0f b6 80 36 07
	00 00		 movzx	 eax, BYTE PTR [rax+1846]
  0052b	83 e0 07	 and	 eax, 7
  0052e	89 84 24 14 01
	00 00		 mov	 DWORD PTR tv279[rsp], eax
$LN76@CTCE_Trace:
  00535	8b 84 24 14 01
	00 00		 mov	 eax, DWORD PTR tv279[rsp]
  0053c	89 84 24 18 01
	00 00		 mov	 DWORD PTR tv280[rsp], eax
  00543	eb 19		 jmp	 SHORT $LN77@CTCE_Trace
$LN74@CTCE_Trace:
  00545	48 8b 84 24 50
	04 00 00	 mov	 rax, QWORD PTR pDEVBLK$[rsp]
  0054d	0f b6 80 36 07
	00 00		 movzx	 eax, BYTE PTR [rax+1846]
  00554	83 e0 07	 and	 eax, 7
  00557	89 84 24 18 01
	00 00		 mov	 DWORD PTR tv280[rsp], eax
$LN77@CTCE_Trace:
  0055e	48 63 84 24 18
	01 00 00	 movsxd	 rax, DWORD PTR tv280[rsp]
  00566	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:CTCE_StaStr
  0056d	48 8b 04 c1	 mov	 rax, QWORD PTR [rcx+rax*8]
  00571	0f be 00	 movsx	 eax, BYTE PTR [rax]
  00574	83 c0 20	 add	 eax, 32			; 00000020H
  00577	b9 01 00 00 00	 mov	 ecx, 1
  0057c	48 6b c9 01	 imul	 rcx, rcx, 1
  00580	88 84 0c d8 00
	00 00		 mov	 BYTE PTR ctce_state_l_xy$[rsp+rcx], al

; 3223 :         }

  00587	e9 b9 00 00 00	 jmp	 $LN7@CTCE_Trace
$LN6@CTCE_Trace:

; 3224 :         else
; 3225 :         {
; 3226 :             ctce_state_l_xy[1] = *CTCE_StaStr[CTCE_STATE( pDEVBLK->ctceyState )];

  0058c	48 8b 84 24 50
	04 00 00	 mov	 rax, QWORD PTR pDEVBLK$[rsp]
  00594	8b 80 18 07 00
	00		 mov	 eax, DWORD PTR [rax+1816]
  0059a	83 e0 01	 and	 eax, 1
  0059d	85 c0		 test	 eax, eax
  0059f	75 65		 jne	 SHORT $LN78@CTCE_Trace
  005a1	48 8b 84 24 50
	04 00 00	 mov	 rax, QWORD PTR pDEVBLK$[rsp]
  005a9	8b 80 74 07 00
	00		 mov	 eax, DWORD PTR [rax+1908]
  005af	c1 e8 03	 shr	 eax, 3
  005b2	83 e0 01	 and	 eax, 1
  005b5	85 c0		 test	 eax, eax
  005b7	75 4d		 jne	 SHORT $LN78@CTCE_Trace
  005b9	48 8b 84 24 50
	04 00 00	 mov	 rax, QWORD PTR pDEVBLK$[rsp]
  005c1	0f b6 80 36 07
	00 00		 movzx	 eax, BYTE PTR [rax+1846]
  005c8	83 e0 07	 and	 eax, 7
  005cb	83 f8 05	 cmp	 eax, 5
  005ce	75 0d		 jne	 SHORT $LN79@CTCE_Trace
  005d0	c7 84 24 1c 01
	00 00 04 00 00
	00		 mov	 DWORD PTR tv307[rsp], 4
  005db	eb 19		 jmp	 SHORT $LN80@CTCE_Trace
$LN79@CTCE_Trace:
  005dd	48 8b 84 24 50
	04 00 00	 mov	 rax, QWORD PTR pDEVBLK$[rsp]
  005e5	0f b6 80 36 07
	00 00		 movzx	 eax, BYTE PTR [rax+1846]
  005ec	83 e0 07	 and	 eax, 7
  005ef	89 84 24 1c 01
	00 00		 mov	 DWORD PTR tv307[rsp], eax
$LN80@CTCE_Trace:
  005f6	8b 84 24 1c 01
	00 00		 mov	 eax, DWORD PTR tv307[rsp]
  005fd	89 84 24 20 01
	00 00		 mov	 DWORD PTR tv308[rsp], eax
  00604	eb 19		 jmp	 SHORT $LN81@CTCE_Trace
$LN78@CTCE_Trace:
  00606	48 8b 84 24 50
	04 00 00	 mov	 rax, QWORD PTR pDEVBLK$[rsp]
  0060e	0f b6 80 36 07
	00 00		 movzx	 eax, BYTE PTR [rax+1846]
  00615	83 e0 07	 and	 eax, 7
  00618	89 84 24 20 01
	00 00		 mov	 DWORD PTR tv308[rsp], eax
$LN81@CTCE_Trace:
  0061f	48 63 84 24 20
	01 00 00	 movsxd	 rax, DWORD PTR tv308[rsp]
  00627	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:CTCE_StaStr
  0062e	48 8b 04 c1	 mov	 rax, QWORD PTR [rcx+rax*8]
  00632	b9 01 00 00 00	 mov	 ecx, 1
  00637	48 6b c9 01	 imul	 rcx, rcx, 1
  0063b	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  0063e	88 84 0c d8 00
	00 00		 mov	 BYTE PTR ctce_state_l_xy$[rsp+rcx], al
$LN7@CTCE_Trace:

; 3227 :         }
; 3228 :         ctce_state_verify = pDEVBLK->ctceyState & 0x07;

  00645	48 8b 84 24 50
	04 00 00	 mov	 rax, QWORD PTR pDEVBLK$[rsp]
  0064d	0f b6 80 36 07
	00 00		 movzx	 eax, BYTE PTR [rax+1846]
  00654	83 e0 07	 and	 eax, 7
  00657	88 84 24 d1 00
	00 00		 mov	 BYTE PTR ctce_state_verify$[rsp], al

; 3229 :     }

  0065e	e9 a7 05 00 00	 jmp	 $LN3@CTCE_Trace
$LN2@CTCE_Trace:

; 3230 :     else
; 3231 :     {
; 3232 :         pSokBuf = ( CTCE_SOKPFX* ) ( pDEVBLK->buf +

  00663	48 8b 84 24 50
	04 00 00	 mov	 rax, QWORD PTR pDEVBLK$[rsp]
  0066b	0f b6 80 35 07
	00 00		 movzx	 eax, BYTE PTR [rax+1845]
  00672	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:CTCE_command
  00679	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  0067d	83 f8 02	 cmp	 eax, 2
  00680	75 21		 jne	 SHORT $LN82@CTCE_Trace
  00682	48 8b 84 24 60
	04 00 00	 mov	 rax, QWORD PTR pCTCE_Info$[rsp]
  0068a	0f b6 40 06	 movzx	 eax, BYTE PTR [rax+6]
  0068e	83 e0 20	 and	 eax, 32			; 00000020H
  00691	83 f8 20	 cmp	 eax, 32			; 00000020H
  00694	74 0d		 je	 SHORT $LN82@CTCE_Trace
  00696	c7 84 24 24 01
	00 00 01 00 00
	00		 mov	 DWORD PTR tv331[rsp], 1
  006a1	eb 0b		 jmp	 SHORT $LN83@CTCE_Trace
$LN82@CTCE_Trace:
  006a3	c7 84 24 24 01
	00 00 00 00 00
	00		 mov	 DWORD PTR tv331[rsp], 0
$LN83@CTCE_Trace:
  006ae	48 8b 84 24 50
	04 00 00	 mov	 rax, QWORD PTR pDEVBLK$[rsp]
  006b6	8b 80 74 07 00
	00		 mov	 eax, DWORD PTR [rax+1908]
  006bc	c1 e8 05	 shr	 eax, 5
  006bf	83 e0 01	 and	 eax, 1
  006c2	89 84 24 8c 01
	00 00		 mov	 DWORD PTR tv333[rsp], eax
  006c9	8b 84 24 24 01
	00 00		 mov	 eax, DWORD PTR tv331[rsp]
  006d0	8b 8c 24 8c 01
	00 00		 mov	 ecx, DWORD PTR tv333[rsp]
  006d7	33 c8		 xor	 ecx, eax
  006d9	8b c1		 mov	 eax, ecx
  006db	85 c0		 test	 eax, eax
  006dd	74 1c		 je	 SHORT $LN84@CTCE_Trace
  006df	48 8b 84 24 50
	04 00 00	 mov	 rax, QWORD PTR pDEVBLK$[rsp]
  006e7	8b 80 d8 01 00
	00		 mov	 eax, DWORD PTR [rax+472]
  006ed	99		 cdq
  006ee	2b c2		 sub	 eax, edx
  006f0	d1 f8		 sar	 eax, 1
  006f2	89 84 24 28 01
	00 00		 mov	 DWORD PTR tv338[rsp], eax
  006f9	eb 0b		 jmp	 SHORT $LN85@CTCE_Trace
$LN84@CTCE_Trace:
  006fb	c7 84 24 28 01
	00 00 00 00 00
	00		 mov	 DWORD PTR tv338[rsp], 0
$LN85@CTCE_Trace:
  00706	48 63 84 24 28
	01 00 00	 movsxd	 rax, DWORD PTR tv338[rsp]
  0070e	48 8b 8c 24 50
	04 00 00	 mov	 rcx, QWORD PTR pDEVBLK$[rsp]
  00716	48 03 81 c8 01
	00 00		 add	 rax, QWORD PTR [rcx+456]
  0071d	48 89 84 24 e0
	00 00 00	 mov	 QWORD PTR pSokBuf$[rsp], rax

; 3233 :             ( pDEVBLK->ctce_buf_next_read ^ ( IS_CTCE_CCW_RED( pDEVBLK->ctcexCmd )
; 3234 :             && ( !( IS_CTCE_WAIT( pCTCE_Info->actions ) ) ) )
; 3235 :             ? pDEVBLK->bufsize / 2 : 0 ) );
; 3236 :         ctce_Cmd    = pDEVBLK->ctcexCmd;

  00725	48 8b 84 24 50
	04 00 00	 mov	 rax, QWORD PTR pDEVBLK$[rsp]
  0072d	0f b6 80 35 07
	00 00		 movzx	 eax, BYTE PTR [rax+1845]
  00734	88 84 24 d0 00
	00 00		 mov	 BYTE PTR ctce_Cmd$[rsp], al

; 3237 :         ctce_PktSeq = pDEVBLK->ctcePktSeq;

  0073b	48 8b 84 24 50
	04 00 00	 mov	 rax, QWORD PTR pDEVBLK$[rsp]
  00743	0f b6 80 2e 07
	00 00		 movzx	 eax, BYTE PTR [rax+1838]
  0074a	88 84 24 dc 00
	00 00		 mov	 BYTE PTR ctce_PktSeq$[rsp], al

; 3238 :         ctce_state_l_xy[0] = 32 + *CTCE_StaStr[CTCE_STATE( pCTCE_Info->state_x_prev )];

  00751	48 8b 84 24 50
	04 00 00	 mov	 rax, QWORD PTR pDEVBLK$[rsp]
  00759	8b 80 18 07 00
	00		 mov	 eax, DWORD PTR [rax+1816]
  0075f	83 e0 01	 and	 eax, 1
  00762	85 c0		 test	 eax, eax
  00764	75 5f		 jne	 SHORT $LN86@CTCE_Trace
  00766	48 8b 84 24 50
	04 00 00	 mov	 rax, QWORD PTR pDEVBLK$[rsp]
  0076e	8b 80 74 07 00
	00		 mov	 eax, DWORD PTR [rax+1908]
  00774	c1 e8 03	 shr	 eax, 3
  00777	83 e0 01	 and	 eax, 1
  0077a	85 c0		 test	 eax, eax
  0077c	75 47		 jne	 SHORT $LN86@CTCE_Trace
  0077e	48 8b 84 24 60
	04 00 00	 mov	 rax, QWORD PTR pCTCE_Info$[rsp]
  00786	0f b6 40 04	 movzx	 eax, BYTE PTR [rax+4]
  0078a	83 e0 07	 and	 eax, 7
  0078d	83 f8 05	 cmp	 eax, 5
  00790	75 0d		 jne	 SHORT $LN87@CTCE_Trace
  00792	c7 84 24 2c 01
	00 00 04 00 00
	00		 mov	 DWORD PTR tv362[rsp], 4
  0079d	eb 16		 jmp	 SHORT $LN88@CTCE_Trace
$LN87@CTCE_Trace:
  0079f	48 8b 84 24 60
	04 00 00	 mov	 rax, QWORD PTR pCTCE_Info$[rsp]
  007a7	0f b6 40 04	 movzx	 eax, BYTE PTR [rax+4]
  007ab	83 e0 07	 and	 eax, 7
  007ae	89 84 24 2c 01
	00 00		 mov	 DWORD PTR tv362[rsp], eax
$LN88@CTCE_Trace:
  007b5	8b 84 24 2c 01
	00 00		 mov	 eax, DWORD PTR tv362[rsp]
  007bc	89 84 24 30 01
	00 00		 mov	 DWORD PTR tv363[rsp], eax
  007c3	eb 16		 jmp	 SHORT $LN89@CTCE_Trace
$LN86@CTCE_Trace:
  007c5	48 8b 84 24 60
	04 00 00	 mov	 rax, QWORD PTR pCTCE_Info$[rsp]
  007cd	0f b6 40 04	 movzx	 eax, BYTE PTR [rax+4]
  007d1	83 e0 07	 and	 eax, 7
  007d4	89 84 24 30 01
	00 00		 mov	 DWORD PTR tv363[rsp], eax
$LN89@CTCE_Trace:
  007db	48 63 84 24 30
	01 00 00	 movsxd	 rax, DWORD PTR tv363[rsp]
  007e3	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:CTCE_StaStr
  007ea	48 8b 04 c1	 mov	 rax, QWORD PTR [rcx+rax*8]
  007ee	0f be 00	 movsx	 eax, BYTE PTR [rax]
  007f1	83 c0 20	 add	 eax, 32			; 00000020H
  007f4	b9 01 00 00 00	 mov	 ecx, 1
  007f9	48 6b c9 00	 imul	 rcx, rcx, 0
  007fd	88 84 0c d8 00
	00 00		 mov	 BYTE PTR ctce_state_l_xy$[rsp+rcx], al

; 3239 :         ctce_state_l_xy[1] = 32 + *CTCE_StaStr[CTCE_STATE( pCTCE_Info->state_y_prev )];

  00804	48 8b 84 24 50
	04 00 00	 mov	 rax, QWORD PTR pDEVBLK$[rsp]
  0080c	8b 80 18 07 00
	00		 mov	 eax, DWORD PTR [rax+1816]
  00812	83 e0 01	 and	 eax, 1
  00815	85 c0		 test	 eax, eax
  00817	75 5f		 jne	 SHORT $LN90@CTCE_Trace
  00819	48 8b 84 24 50
	04 00 00	 mov	 rax, QWORD PTR pDEVBLK$[rsp]
  00821	8b 80 74 07 00
	00		 mov	 eax, DWORD PTR [rax+1908]
  00827	c1 e8 03	 shr	 eax, 3
  0082a	83 e0 01	 and	 eax, 1
  0082d	85 c0		 test	 eax, eax
  0082f	75 47		 jne	 SHORT $LN90@CTCE_Trace
  00831	48 8b 84 24 60
	04 00 00	 mov	 rax, QWORD PTR pCTCE_Info$[rsp]
  00839	0f b6 40 05	 movzx	 eax, BYTE PTR [rax+5]
  0083d	83 e0 07	 and	 eax, 7
  00840	83 f8 05	 cmp	 eax, 5
  00843	75 0d		 jne	 SHORT $LN91@CTCE_Trace
  00845	c7 84 24 34 01
	00 00 04 00 00
	00		 mov	 DWORD PTR tv390[rsp], 4
  00850	eb 16		 jmp	 SHORT $LN92@CTCE_Trace
$LN91@CTCE_Trace:
  00852	48 8b 84 24 60
	04 00 00	 mov	 rax, QWORD PTR pCTCE_Info$[rsp]
  0085a	0f b6 40 05	 movzx	 eax, BYTE PTR [rax+5]
  0085e	83 e0 07	 and	 eax, 7
  00861	89 84 24 34 01
	00 00		 mov	 DWORD PTR tv390[rsp], eax
$LN92@CTCE_Trace:
  00868	8b 84 24 34 01
	00 00		 mov	 eax, DWORD PTR tv390[rsp]
  0086f	89 84 24 38 01
	00 00		 mov	 DWORD PTR tv391[rsp], eax
  00876	eb 16		 jmp	 SHORT $LN93@CTCE_Trace
$LN90@CTCE_Trace:
  00878	48 8b 84 24 60
	04 00 00	 mov	 rax, QWORD PTR pCTCE_Info$[rsp]
  00880	0f b6 40 05	 movzx	 eax, BYTE PTR [rax+5]
  00884	83 e0 07	 and	 eax, 7
  00887	89 84 24 38 01
	00 00		 mov	 DWORD PTR tv391[rsp], eax
$LN93@CTCE_Trace:
  0088e	48 63 84 24 38
	01 00 00	 movsxd	 rax, DWORD PTR tv391[rsp]
  00896	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:CTCE_StaStr
  0089d	48 8b 04 c1	 mov	 rax, QWORD PTR [rcx+rax*8]
  008a1	0f be 00	 movsx	 eax, BYTE PTR [rax]
  008a4	83 c0 20	 add	 eax, 32			; 00000020H
  008a7	b9 01 00 00 00	 mov	 ecx, 1
  008ac	48 6b c9 01	 imul	 rcx, rcx, 1
  008b0	88 84 0c d8 00
	00 00		 mov	 BYTE PTR ctce_state_l_xy$[rsp+rcx], al

; 3240 :         if( pDEVBLK->ctcexState == pCTCE_Info->state_x_prev )

  008b7	48 8b 84 24 50
	04 00 00	 mov	 rax, QWORD PTR pDEVBLK$[rsp]
  008bf	0f b6 80 34 07
	00 00		 movzx	 eax, BYTE PTR [rax+1844]
  008c6	48 8b 8c 24 60
	04 00 00	 mov	 rcx, QWORD PTR pCTCE_Info$[rsp]
  008ce	0f b6 49 04	 movzx	 ecx, BYTE PTR [rcx+4]
  008d2	3b c1		 cmp	 eax, ecx
  008d4	0f 85 c1 00 00
	00		 jne	 $LN8@CTCE_Trace

; 3241 :         {
; 3242 :             ctce_state_r_xy[0] = 32 + *CTCE_StaStr[CTCE_STATE( pDEVBLK->ctcexState )];

  008da	48 8b 84 24 50
	04 00 00	 mov	 rax, QWORD PTR pDEVBLK$[rsp]
  008e2	8b 80 18 07 00
	00		 mov	 eax, DWORD PTR [rax+1816]
  008e8	83 e0 01	 and	 eax, 1
  008eb	85 c0		 test	 eax, eax
  008ed	75 65		 jne	 SHORT $LN94@CTCE_Trace
  008ef	48 8b 84 24 50
	04 00 00	 mov	 rax, QWORD PTR pDEVBLK$[rsp]
  008f7	8b 80 74 07 00
	00		 mov	 eax, DWORD PTR [rax+1908]
  008fd	c1 e8 03	 shr	 eax, 3
  00900	83 e0 01	 and	 eax, 1
  00903	85 c0		 test	 eax, eax
  00905	75 4d		 jne	 SHORT $LN94@CTCE_Trace
  00907	48 8b 84 24 50
	04 00 00	 mov	 rax, QWORD PTR pDEVBLK$[rsp]
  0090f	0f b6 80 34 07
	00 00		 movzx	 eax, BYTE PTR [rax+1844]
  00916	83 e0 07	 and	 eax, 7
  00919	83 f8 05	 cmp	 eax, 5
  0091c	75 0d		 jne	 SHORT $LN95@CTCE_Trace
  0091e	c7 84 24 3c 01
	00 00 04 00 00
	00		 mov	 DWORD PTR tv423[rsp], 4
  00929	eb 19		 jmp	 SHORT $LN96@CTCE_Trace
$LN95@CTCE_Trace:
  0092b	48 8b 84 24 50
	04 00 00	 mov	 rax, QWORD PTR pDEVBLK$[rsp]
  00933	0f b6 80 34 07
	00 00		 movzx	 eax, BYTE PTR [rax+1844]
  0093a	83 e0 07	 and	 eax, 7
  0093d	89 84 24 3c 01
	00 00		 mov	 DWORD PTR tv423[rsp], eax
$LN96@CTCE_Trace:
  00944	8b 84 24 3c 01
	00 00		 mov	 eax, DWORD PTR tv423[rsp]
  0094b	89 84 24 40 01
	00 00		 mov	 DWORD PTR tv424[rsp], eax
  00952	eb 19		 jmp	 SHORT $LN97@CTCE_Trace
$LN94@CTCE_Trace:
  00954	48 8b 84 24 50
	04 00 00	 mov	 rax, QWORD PTR pDEVBLK$[rsp]
  0095c	0f b6 80 34 07
	00 00		 movzx	 eax, BYTE PTR [rax+1844]
  00963	83 e0 07	 and	 eax, 7
  00966	89 84 24 40 01
	00 00		 mov	 DWORD PTR tv424[rsp], eax
$LN97@CTCE_Trace:
  0096d	48 63 84 24 40
	01 00 00	 movsxd	 rax, DWORD PTR tv424[rsp]
  00975	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:CTCE_StaStr
  0097c	48 8b 04 c1	 mov	 rax, QWORD PTR [rcx+rax*8]
  00980	0f be 00	 movsx	 eax, BYTE PTR [rax]
  00983	83 c0 20	 add	 eax, 32			; 00000020H
  00986	b9 01 00 00 00	 mov	 ecx, 1
  0098b	48 6b c9 00	 imul	 rcx, rcx, 0
  0098f	88 84 0c d4 00
	00 00		 mov	 BYTE PTR ctce_state_r_xy$[rsp+rcx], al

; 3243 :         }

  00996	e9 b9 00 00 00	 jmp	 $LN9@CTCE_Trace
$LN8@CTCE_Trace:

; 3244 :         else
; 3245 :         {
; 3246 :             ctce_state_r_xy[0] = *CTCE_StaStr[CTCE_STATE( pDEVBLK->ctcexState )];

  0099b	48 8b 84 24 50
	04 00 00	 mov	 rax, QWORD PTR pDEVBLK$[rsp]
  009a3	8b 80 18 07 00
	00		 mov	 eax, DWORD PTR [rax+1816]
  009a9	83 e0 01	 and	 eax, 1
  009ac	85 c0		 test	 eax, eax
  009ae	75 65		 jne	 SHORT $LN98@CTCE_Trace
  009b0	48 8b 84 24 50
	04 00 00	 mov	 rax, QWORD PTR pDEVBLK$[rsp]
  009b8	8b 80 74 07 00
	00		 mov	 eax, DWORD PTR [rax+1908]
  009be	c1 e8 03	 shr	 eax, 3
  009c1	83 e0 01	 and	 eax, 1
  009c4	85 c0		 test	 eax, eax
  009c6	75 4d		 jne	 SHORT $LN98@CTCE_Trace
  009c8	48 8b 84 24 50
	04 00 00	 mov	 rax, QWORD PTR pDEVBLK$[rsp]
  009d0	0f b6 80 34 07
	00 00		 movzx	 eax, BYTE PTR [rax+1844]
  009d7	83 e0 07	 and	 eax, 7
  009da	83 f8 05	 cmp	 eax, 5
  009dd	75 0d		 jne	 SHORT $LN99@CTCE_Trace
  009df	c7 84 24 44 01
	00 00 04 00 00
	00		 mov	 DWORD PTR tv451[rsp], 4
  009ea	eb 19		 jmp	 SHORT $LN100@CTCE_Trace
$LN99@CTCE_Trace:
  009ec	48 8b 84 24 50
	04 00 00	 mov	 rax, QWORD PTR pDEVBLK$[rsp]
  009f4	0f b6 80 34 07
	00 00		 movzx	 eax, BYTE PTR [rax+1844]
  009fb	83 e0 07	 and	 eax, 7
  009fe	89 84 24 44 01
	00 00		 mov	 DWORD PTR tv451[rsp], eax
$LN100@CTCE_Trace:
  00a05	8b 84 24 44 01
	00 00		 mov	 eax, DWORD PTR tv451[rsp]
  00a0c	89 84 24 48 01
	00 00		 mov	 DWORD PTR tv452[rsp], eax
  00a13	eb 19		 jmp	 SHORT $LN101@CTCE_Trace
$LN98@CTCE_Trace:
  00a15	48 8b 84 24 50
	04 00 00	 mov	 rax, QWORD PTR pDEVBLK$[rsp]
  00a1d	0f b6 80 34 07
	00 00		 movzx	 eax, BYTE PTR [rax+1844]
  00a24	83 e0 07	 and	 eax, 7
  00a27	89 84 24 48 01
	00 00		 mov	 DWORD PTR tv452[rsp], eax
$LN101@CTCE_Trace:
  00a2e	48 63 84 24 48
	01 00 00	 movsxd	 rax, DWORD PTR tv452[rsp]
  00a36	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:CTCE_StaStr
  00a3d	48 8b 04 c1	 mov	 rax, QWORD PTR [rcx+rax*8]
  00a41	b9 01 00 00 00	 mov	 ecx, 1
  00a46	48 6b c9 00	 imul	 rcx, rcx, 0
  00a4a	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  00a4d	88 84 0c d4 00
	00 00		 mov	 BYTE PTR ctce_state_r_xy$[rsp+rcx], al
$LN9@CTCE_Trace:

; 3247 :         }
; 3248 :         if( pDEVBLK->ctceyState == pCTCE_Info->state_y_prev )

  00a54	48 8b 84 24 50
	04 00 00	 mov	 rax, QWORD PTR pDEVBLK$[rsp]
  00a5c	0f b6 80 36 07
	00 00		 movzx	 eax, BYTE PTR [rax+1846]
  00a63	48 8b 8c 24 60
	04 00 00	 mov	 rcx, QWORD PTR pCTCE_Info$[rsp]
  00a6b	0f b6 49 05	 movzx	 ecx, BYTE PTR [rcx+5]
  00a6f	3b c1		 cmp	 eax, ecx
  00a71	0f 85 c1 00 00
	00		 jne	 $LN10@CTCE_Trace

; 3249 :         {
; 3250 :             ctce_state_r_xy[1] = 32 + *CTCE_StaStr[CTCE_STATE( pDEVBLK->ctceyState )];

  00a77	48 8b 84 24 50
	04 00 00	 mov	 rax, QWORD PTR pDEVBLK$[rsp]
  00a7f	8b 80 18 07 00
	00		 mov	 eax, DWORD PTR [rax+1816]
  00a85	83 e0 01	 and	 eax, 1
  00a88	85 c0		 test	 eax, eax
  00a8a	75 65		 jne	 SHORT $LN102@CTCE_Trace
  00a8c	48 8b 84 24 50
	04 00 00	 mov	 rax, QWORD PTR pDEVBLK$[rsp]
  00a94	8b 80 74 07 00
	00		 mov	 eax, DWORD PTR [rax+1908]
  00a9a	c1 e8 03	 shr	 eax, 3
  00a9d	83 e0 01	 and	 eax, 1
  00aa0	85 c0		 test	 eax, eax
  00aa2	75 4d		 jne	 SHORT $LN102@CTCE_Trace
  00aa4	48 8b 84 24 50
	04 00 00	 mov	 rax, QWORD PTR pDEVBLK$[rsp]
  00aac	0f b6 80 36 07
	00 00		 movzx	 eax, BYTE PTR [rax+1846]
  00ab3	83 e0 07	 and	 eax, 7
  00ab6	83 f8 05	 cmp	 eax, 5
  00ab9	75 0d		 jne	 SHORT $LN103@CTCE_Trace
  00abb	c7 84 24 4c 01
	00 00 04 00 00
	00		 mov	 DWORD PTR tv481[rsp], 4
  00ac6	eb 19		 jmp	 SHORT $LN104@CTCE_Trace
$LN103@CTCE_Trace:
  00ac8	48 8b 84 24 50
	04 00 00	 mov	 rax, QWORD PTR pDEVBLK$[rsp]
  00ad0	0f b6 80 36 07
	00 00		 movzx	 eax, BYTE PTR [rax+1846]
  00ad7	83 e0 07	 and	 eax, 7
  00ada	89 84 24 4c 01
	00 00		 mov	 DWORD PTR tv481[rsp], eax
$LN104@CTCE_Trace:
  00ae1	8b 84 24 4c 01
	00 00		 mov	 eax, DWORD PTR tv481[rsp]
  00ae8	89 84 24 50 01
	00 00		 mov	 DWORD PTR tv482[rsp], eax
  00aef	eb 19		 jmp	 SHORT $LN105@CTCE_Trace
$LN102@CTCE_Trace:
  00af1	48 8b 84 24 50
	04 00 00	 mov	 rax, QWORD PTR pDEVBLK$[rsp]
  00af9	0f b6 80 36 07
	00 00		 movzx	 eax, BYTE PTR [rax+1846]
  00b00	83 e0 07	 and	 eax, 7
  00b03	89 84 24 50 01
	00 00		 mov	 DWORD PTR tv482[rsp], eax
$LN105@CTCE_Trace:
  00b0a	48 63 84 24 50
	01 00 00	 movsxd	 rax, DWORD PTR tv482[rsp]
  00b12	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:CTCE_StaStr
  00b19	48 8b 04 c1	 mov	 rax, QWORD PTR [rcx+rax*8]
  00b1d	0f be 00	 movsx	 eax, BYTE PTR [rax]
  00b20	83 c0 20	 add	 eax, 32			; 00000020H
  00b23	b9 01 00 00 00	 mov	 ecx, 1
  00b28	48 6b c9 01	 imul	 rcx, rcx, 1
  00b2c	88 84 0c d4 00
	00 00		 mov	 BYTE PTR ctce_state_r_xy$[rsp+rcx], al

; 3251 :         }

  00b33	e9 b9 00 00 00	 jmp	 $LN11@CTCE_Trace
$LN10@CTCE_Trace:

; 3252 :         else
; 3253 :         {
; 3254 :             ctce_state_r_xy[1] = *CTCE_StaStr[CTCE_STATE( pDEVBLK->ctceyState )];

  00b38	48 8b 84 24 50
	04 00 00	 mov	 rax, QWORD PTR pDEVBLK$[rsp]
  00b40	8b 80 18 07 00
	00		 mov	 eax, DWORD PTR [rax+1816]
  00b46	83 e0 01	 and	 eax, 1
  00b49	85 c0		 test	 eax, eax
  00b4b	75 65		 jne	 SHORT $LN106@CTCE_Trace
  00b4d	48 8b 84 24 50
	04 00 00	 mov	 rax, QWORD PTR pDEVBLK$[rsp]
  00b55	8b 80 74 07 00
	00		 mov	 eax, DWORD PTR [rax+1908]
  00b5b	c1 e8 03	 shr	 eax, 3
  00b5e	83 e0 01	 and	 eax, 1
  00b61	85 c0		 test	 eax, eax
  00b63	75 4d		 jne	 SHORT $LN106@CTCE_Trace
  00b65	48 8b 84 24 50
	04 00 00	 mov	 rax, QWORD PTR pDEVBLK$[rsp]
  00b6d	0f b6 80 36 07
	00 00		 movzx	 eax, BYTE PTR [rax+1846]
  00b74	83 e0 07	 and	 eax, 7
  00b77	83 f8 05	 cmp	 eax, 5
  00b7a	75 0d		 jne	 SHORT $LN107@CTCE_Trace
  00b7c	c7 84 24 54 01
	00 00 04 00 00
	00		 mov	 DWORD PTR tv509[rsp], 4
  00b87	eb 19		 jmp	 SHORT $LN108@CTCE_Trace
$LN107@CTCE_Trace:
  00b89	48 8b 84 24 50
	04 00 00	 mov	 rax, QWORD PTR pDEVBLK$[rsp]
  00b91	0f b6 80 36 07
	00 00		 movzx	 eax, BYTE PTR [rax+1846]
  00b98	83 e0 07	 and	 eax, 7
  00b9b	89 84 24 54 01
	00 00		 mov	 DWORD PTR tv509[rsp], eax
$LN108@CTCE_Trace:
  00ba2	8b 84 24 54 01
	00 00		 mov	 eax, DWORD PTR tv509[rsp]
  00ba9	89 84 24 58 01
	00 00		 mov	 DWORD PTR tv510[rsp], eax
  00bb0	eb 19		 jmp	 SHORT $LN109@CTCE_Trace
$LN106@CTCE_Trace:
  00bb2	48 8b 84 24 50
	04 00 00	 mov	 rax, QWORD PTR pDEVBLK$[rsp]
  00bba	0f b6 80 36 07
	00 00		 movzx	 eax, BYTE PTR [rax+1846]
  00bc1	83 e0 07	 and	 eax, 7
  00bc4	89 84 24 58 01
	00 00		 mov	 DWORD PTR tv510[rsp], eax
$LN109@CTCE_Trace:
  00bcb	48 63 84 24 58
	01 00 00	 movsxd	 rax, DWORD PTR tv510[rsp]
  00bd3	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:CTCE_StaStr
  00bda	48 8b 04 c1	 mov	 rax, QWORD PTR [rcx+rax*8]
  00bde	b9 01 00 00 00	 mov	 ecx, 1
  00be3	48 6b c9 01	 imul	 rcx, rcx, 1
  00be7	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  00bea	88 84 0c d4 00
	00 00		 mov	 BYTE PTR ctce_state_r_xy$[rsp+rcx], al
$LN11@CTCE_Trace:

; 3255 :         }
; 3256 :         ctce_state_verify = pDEVBLK->ctcexState & 0x07;

  00bf1	48 8b 84 24 50
	04 00 00	 mov	 rax, QWORD PTR pDEVBLK$[rsp]
  00bf9	0f b6 80 34 07
	00 00		 movzx	 eax, BYTE PTR [rax+1844]
  00c00	83 e0 07	 and	 eax, 7
  00c03	88 84 24 d1 00
	00 00		 mov	 BYTE PTR ctce_state_verify$[rsp], al
$LN3@CTCE_Trace:

; 3257 :     }
; 3258 : 
; 3259 :     // Report on the device status and CCW Command Chaining flag.
; 3260 :     if( 0
; 3261 :         || ( eCTCE_Cmd_Xfr != CTCE_RCV && ( !IS_CTCE_RST( ctce_Cmd ) ) )
; 3262 :         || ( *pUnitStat != 0 )
; 3263 :         || ( IS_CTCE_MATCH( pCTCE_Info->actions ) ) )

  00c0a	33 c0		 xor	 eax, eax
  00c0c	85 c0		 test	 eax, eax
  00c0e	75 45		 jne	 SHORT $LN14@CTCE_Trace
  00c10	83 bc 24 58 04
	00 00 02	 cmp	 DWORD PTR eCTCE_Cmd_Xfr$[rsp], 2
  00c18	74 18		 je	 SHORT $LN15@CTCE_Trace
  00c1a	0f b6 84 24 d0
	00 00 00	 movzx	 eax, BYTE PTR ctce_Cmd$[rsp]
  00c22	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:CTCE_command
  00c29	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00c2d	83 f8 0e	 cmp	 eax, 14
  00c30	75 23		 jne	 SHORT $LN14@CTCE_Trace
$LN15@CTCE_Trace:
  00c32	48 8b 84 24 68
	04 00 00	 mov	 rax, QWORD PTR pUnitStat$[rsp]
  00c3a	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  00c3d	85 c0		 test	 eax, eax
  00c3f	75 14		 jne	 SHORT $LN14@CTCE_Trace
  00c41	48 8b 84 24 60
	04 00 00	 mov	 rax, QWORD PTR pCTCE_Info$[rsp]
  00c49	0f b6 40 06	 movzx	 eax, BYTE PTR [rax+6]
  00c4d	83 e0 08	 and	 eax, 8
  00c50	83 f8 08	 cmp	 eax, 8
  00c53	75 2a		 jne	 SHORT $LN12@CTCE_Trace
$LN14@CTCE_Trace:

; 3264 :     {
; 3265 :         MSGBUF( ctce_trace_stat,

  00c55	48 8b 84 24 68
	04 00 00	 mov	 rax, QWORD PTR pUnitStat$[rsp]
  00c5d	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  00c60	44 8b c8	 mov	 r9d, eax
  00c63	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG170249
  00c6a	ba 18 00 00 00	 mov	 edx, 24
  00c6f	48 8d 8c 24 e0
	01 00 00	 lea	 rcx, QWORD PTR ctce_trace_stat$[rsp]
  00c77	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_snprintf

; 3266 :             "Stat=%02X", *pUnitStat );
; 3267 :     }

  00c7d	eb 1a		 jmp	 SHORT $LN13@CTCE_Trace
$LN12@CTCE_Trace:

; 3268 :     else
; 3269 :     {
; 3270 :         MSGBUF( ctce_trace_stat,

  00c7f	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG170250
  00c86	ba 18 00 00 00	 mov	 edx, 24
  00c8b	48 8d 8c 24 e0
	01 00 00	 lea	 rcx, QWORD PTR ctce_trace_stat$[rsp]
  00c93	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_snprintf
$LN13@CTCE_Trace:

; 3271 :             "       " );
; 3272 :     }
; 3273 :     if( !IS_CTCE_RST( ctce_Cmd ) )

  00c99	0f b6 84 24 d0
	00 00 00	 movzx	 eax, BYTE PTR ctce_Cmd$[rsp]
  00ca1	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:CTCE_command
  00ca8	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00cac	83 f8 0e	 cmp	 eax, 14
  00caf	74 4e		 je	 SHORT $LN16@CTCE_Trace

; 3274 :     {
; 3275 :         MSGBUF( ctce_trace_xtra_temp,

  00cb1	48 8b 84 24 50
	04 00 00	 mov	 rax, QWORD PTR pDEVBLK$[rsp]
  00cb9	8b 80 74 07 00
	00		 mov	 eax, DWORD PTR [rax+1908]
  00cbf	d1 e8		 shr	 eax, 1
  00cc1	83 e0 01	 and	 eax, 1
  00cc4	44 8b c8	 mov	 r9d, eax
  00cc7	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG170253
  00cce	ba 00 01 00 00	 mov	 edx, 256		; 00000100H
  00cd3	48 8d 8c 24 00
	02 00 00	 lea	 rcx, QWORD PTR ctce_trace_xtra_temp$[rsp]
  00cdb	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_snprintf

; 3276 :             " CC=%d", pDEVBLK->ctce_ccw_flags_cc );
; 3277 :         STRLCAT( ctce_trace_stat, ctce_trace_xtra_temp );

  00ce1	41 b8 18 00 00
	00		 mov	 r8d, 24
  00ce7	48 8d 94 24 00
	02 00 00	 lea	 rdx, QWORD PTR ctce_trace_xtra_temp$[rsp]
  00cef	48 8d 8c 24 e0
	01 00 00	 lea	 rcx, QWORD PTR ctce_trace_stat$[rsp]
  00cf7	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_strlcat

; 3278 :     }

  00cfd	eb 1b		 jmp	 SHORT $LN17@CTCE_Trace
$LN16@CTCE_Trace:

; 3279 :     else
; 3280 :     {
; 3281 :         STRLCAT( ctce_trace_stat, "     " );

  00cff	41 b8 18 00 00
	00		 mov	 r8d, 24
  00d05	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG170254
  00d0c	48 8d 8c 24 e0
	01 00 00	 lea	 rcx, QWORD PTR ctce_trace_stat$[rsp]
  00d14	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_strlcat
$LN17@CTCE_Trace:

; 3282 :     }
; 3283 : 
; 3284 :     // Report on the alternating device block buffer usage.
; 3285 :     MSGBUF( ctce_trace_xtra_temp,

  00d1a	48 8b 84 24 50
	04 00 00	 mov	 rax, QWORD PTR pDEVBLK$[rsp]
  00d22	8b 80 74 07 00
	00		 mov	 eax, DWORD PTR [rax+1908]
  00d28	c1 e8 05	 shr	 eax, 5
  00d2b	83 e0 01	 and	 eax, 1
  00d2e	48 8b 8c 24 50
	04 00 00	 mov	 rcx, QWORD PTR pDEVBLK$[rsp]
  00d36	8b 89 74 07 00
	00		 mov	 ecx, DWORD PTR [rcx+1908]
  00d3c	c1 e9 06	 shr	 ecx, 6
  00d3f	83 e1 01	 and	 ecx, 1
  00d42	89 44 24 20	 mov	 DWORD PTR [rsp+32], eax
  00d46	44 8b c9	 mov	 r9d, ecx
  00d49	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG170255
  00d50	ba 00 01 00 00	 mov	 edx, 256		; 00000100H
  00d55	48 8d 8c 24 00
	02 00 00	 lea	 rcx, QWORD PTR ctce_trace_xtra_temp$[rsp]
  00d5d	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_snprintf

; 3286 :         " w=%d,r=%d", pDEVBLK->ctce_buf_next_write, pDEVBLK->ctce_buf_next_read );
; 3287 :     STRLCAT( ctce_trace_stat, ctce_trace_xtra_temp );

  00d63	41 b8 18 00 00
	00		 mov	 r8d, 24
  00d69	48 8d 94 24 00
	02 00 00	 lea	 rdx, QWORD PTR ctce_trace_xtra_temp$[rsp]
  00d71	48 8d 8c 24 e0
	01 00 00	 lea	 rcx, QWORD PTR ctce_trace_stat$[rsp]
  00d79	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_strlcat

; 3288 : 
; 3289 :     ctce_trace_xtra[0] = '\0' ;

  00d7f	b8 01 00 00 00	 mov	 eax, 1
  00d84	48 6b c0 00	 imul	 rax, rax, 0
  00d88	48 89 84 24 90
	01 00 00	 mov	 QWORD PTR $T1[rsp], rax
  00d90	48 81 bc 24 90
	01 00 00 00 01
	00 00		 cmp	 QWORD PTR $T1[rsp], 256	; 00000100H
  00d9c	73 02		 jae	 SHORT $LN110@CTCE_Trace
  00d9e	eb 05		 jmp	 SHORT $LN111@CTCE_Trace
$LN110@CTCE_Trace:
  00da0	e8 00 00 00 00	 call	 __report_rangecheckfailure
$LN111@CTCE_Trace:
  00da5	48 8b 84 24 90
	01 00 00	 mov	 rax, QWORD PTR $T1[rsp]
  00dad	c6 84 04 00 03
	00 00 00	 mov	 BYTE PTR ctce_trace_xtra$[rsp+rax], 0

; 3290 : 
; 3291 :     // The other side's entering a "Working" state may
; 3292 :     // require an Attention or not, which will be shown.
; 3293 :     // Please note that the CTCE_ACTIONS_PRT macro in
; 3294 :     // that case will show "ATTN" at the rightmost end.
; 3295 :     if( IS_CTCE_ATTN( pCTCE_Info->actions ) && ( eCTCE_Cmd_Xfr == CTCE_RCV ) )

  00db5	48 8b 84 24 60
	04 00 00	 mov	 rax, QWORD PTR pCTCE_Info$[rsp]
  00dbd	0f b6 40 06	 movzx	 eax, BYTE PTR [rax+6]
  00dc1	83 e0 10	 and	 eax, 16
  00dc4	83 f8 10	 cmp	 eax, 16
  00dc7	0f 85 8f 00 00
	00		 jne	 $LN18@CTCE_Trace
  00dcd	83 bc 24 58 04
	00 00 02	 cmp	 DWORD PTR eCTCE_Cmd_Xfr$[rsp], 2
  00dd5	0f 85 81 00 00
	00		 jne	 $LN18@CTCE_Trace

; 3296 :     {
; 3297 :         if( pCTCE_Info->attn_can )

  00ddb	48 8b 84 24 60
	04 00 00	 mov	 rax, QWORD PTR pCTCE_Info$[rsp]
  00de3	8b 40 10	 mov	 eax, DWORD PTR [rax+16]
  00de6	d1 e8		 shr	 eax, 1
  00de8	83 e0 01	 and	 eax, 1
  00deb	85 c0		 test	 eax, eax
  00ded	74 1d		 je	 SHORT $LN19@CTCE_Trace

; 3298 :         {
; 3299 :             STRLCAT( ctce_trace_xtra, "->NONE" );

  00def	41 b8 00 01 00
	00		 mov	 r8d, 256		; 00000100H
  00df5	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG170259
  00dfc	48 8d 8c 24 00
	03 00 00	 lea	 rcx, QWORD PTR ctce_trace_xtra$[rsp]
  00e04	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_strlcat

; 3300 :         }

  00e0a	eb 50		 jmp	 SHORT $LN20@CTCE_Trace
$LN19@CTCE_Trace:

; 3301 :         else if( pCTCE_Info->working_attn_rc > -1 )

  00e0c	48 8b 84 24 60
	04 00 00	 mov	 rax, QWORD PTR pCTCE_Info$[rsp]
  00e14	83 78 1c ff	 cmp	 DWORD PTR [rax+28], -1
  00e18	7e 42		 jle	 SHORT $LN21@CTCE_Trace

; 3302 :         {
; 3303 :             MSGBUF( ctce_trace_xtra_temp,

  00e1a	48 8b 84 24 60
	04 00 00	 mov	 rax, QWORD PTR pCTCE_Info$[rsp]
  00e22	44 8b 48 1c	 mov	 r9d, DWORD PTR [rax+28]
  00e26	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG170261
  00e2d	ba 00 01 00 00	 mov	 edx, 256		; 00000100H
  00e32	48 8d 8c 24 00
	02 00 00	 lea	 rcx, QWORD PTR ctce_trace_xtra_temp$[rsp]
  00e3a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_snprintf

; 3304 :                 "->RC=%d", pCTCE_Info->working_attn_rc );
; 3305 :             STRLCAT( ctce_trace_xtra, ctce_trace_xtra_temp );

  00e40	41 b8 00 01 00
	00		 mov	 r8d, 256		; 00000100H
  00e46	48 8d 94 24 00
	02 00 00	 lea	 rdx, QWORD PTR ctce_trace_xtra_temp$[rsp]
  00e4e	48 8d 8c 24 00
	03 00 00	 lea	 rcx, QWORD PTR ctce_trace_xtra$[rsp]
  00e56	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_strlcat
$LN21@CTCE_Trace:
$LN20@CTCE_Trace:
$LN18@CTCE_Trace:

; 3306 :         }
; 3307 :     }
; 3308 : 
; 3309 :     // The other side's "DE Ready" signalling to be shown.
; 3310 :     if( pCTCE_Info->de_ready )

  00e5c	48 8b 84 24 60
	04 00 00	 mov	 rax, QWORD PTR pCTCE_Info$[rsp]
  00e64	0f b6 40 0d	 movzx	 eax, BYTE PTR [rax+13]
  00e68	85 c0		 test	 eax, eax
  00e6a	74 42		 je	 SHORT $LN22@CTCE_Trace

; 3311 :     {
; 3312 :         MSGBUF( ctce_trace_xtra_temp,

  00e6c	48 8b 84 24 60
	04 00 00	 mov	 rax, QWORD PTR pCTCE_Info$[rsp]
  00e74	44 8b 48 18	 mov	 r9d, DWORD PTR [rax+24]
  00e78	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG170263
  00e7f	ba 00 01 00 00	 mov	 edx, 256		; 00000100H
  00e84	48 8d 8c 24 00
	02 00 00	 lea	 rcx, QWORD PTR ctce_trace_xtra_temp$[rsp]
  00e8c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_snprintf

; 3313 :             " DE_READY->RC=%d", pCTCE_Info->de_ready_attn_rc );
; 3314 :         STRLCAT( ctce_trace_xtra, ctce_trace_xtra_temp );

  00e92	41 b8 00 01 00
	00		 mov	 r8d, 256		; 00000100H
  00e98	48 8d 94 24 00
	02 00 00	 lea	 rdx, QWORD PTR ctce_trace_xtra_temp$[rsp]
  00ea0	48 8d 8c 24 00
	03 00 00	 lea	 rcx, QWORD PTR ctce_trace_xtra$[rsp]
  00ea8	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_strlcat
$LN22@CTCE_Trace:

; 3315 :     }
; 3316 : 
; 3317 :     // "WEOF" means that the "Write End of File" bit is or was set.
; 3318 :     // "WEOF->SET" means it just got set right now, in which case
; 3319 :     // "WEOF->SET->UX" means an Unit Exception (UX) will follow because
; 3320 :     // it got set because of a WEOF command matching a Read command
; 3321 :     // (which actually will clear the WEOF immediately thereafter).
; 3322 :     // "WEOF->CLR" indicates the WEOF bit just got reset.
; 3323 :     if(  IS_CTCE_WEOF( pCTCE_Info->state_x_prev ) ||

  00eae	48 8b 84 24 60
	04 00 00	 mov	 rax, QWORD PTR pCTCE_Info$[rsp]
  00eb6	0f b6 40 04	 movzx	 eax, BYTE PTR [rax+4]
  00eba	25 80 00 00 00	 and	 eax, 128		; 00000080H
  00ebf	3d 80 00 00 00	 cmp	 eax, 128		; 00000080H
  00ec4	74 1b		 je	 SHORT $LN24@CTCE_Trace
  00ec6	48 8b 84 24 50
	04 00 00	 mov	 rax, QWORD PTR pDEVBLK$[rsp]
  00ece	0f b6 80 34 07
	00 00		 movzx	 eax, BYTE PTR [rax+1844]
  00ed5	25 80 00 00 00	 and	 eax, 128		; 00000080H
  00eda	3d 80 00 00 00	 cmp	 eax, 128		; 00000080H
  00edf	75 1b		 jne	 SHORT $LN23@CTCE_Trace
$LN24@CTCE_Trace:

; 3324 :          IS_CTCE_WEOF( pDEVBLK->ctcexState      ) )
; 3325 :     {
; 3326 :         STRLCAT( ctce_trace_xtra, " WEOF" );

  00ee1	41 b8 00 01 00
	00		 mov	 r8d, 256		; 00000100H
  00ee7	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG170266
  00eee	48 8d 8c 24 00
	03 00 00	 lea	 rcx, QWORD PTR ctce_trace_xtra$[rsp]
  00ef6	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_strlcat
$LN23@CTCE_Trace:

; 3327 :     }
; 3328 :     if( !IS_CTCE_WEOF( pCTCE_Info->state_x_prev ) &&

  00efc	48 8b 84 24 60
	04 00 00	 mov	 rax, QWORD PTR pCTCE_Info$[rsp]
  00f04	0f b6 40 04	 movzx	 eax, BYTE PTR [rax+4]
  00f08	25 80 00 00 00	 and	 eax, 128		; 00000080H
  00f0d	3d 80 00 00 00	 cmp	 eax, 128		; 00000080H
  00f12	74 65		 je	 SHORT $LN25@CTCE_Trace
  00f14	48 8b 84 24 50
	04 00 00	 mov	 rax, QWORD PTR pDEVBLK$[rsp]
  00f1c	0f b6 80 34 07
	00 00		 movzx	 eax, BYTE PTR [rax+1844]
  00f23	25 80 00 00 00	 and	 eax, 128		; 00000080H
  00f28	3d 80 00 00 00	 cmp	 eax, 128		; 00000080H
  00f2d	75 4a		 jne	 SHORT $LN25@CTCE_Trace

; 3329 :          IS_CTCE_WEOF( pDEVBLK->ctcexState      ) )
; 3330 :     {
; 3331 :         STRLCAT( ctce_trace_xtra, "->SET" );

  00f2f	41 b8 00 01 00
	00		 mov	 r8d, 256		; 00000100H
  00f35	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG170268
  00f3c	48 8d 8c 24 00
	03 00 00	 lea	 rcx, QWORD PTR ctce_trace_xtra$[rsp]
  00f44	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_strlcat

; 3332 :         if( IS_CTCE_MATCH( pCTCE_Info->actions ) )

  00f4a	48 8b 84 24 60
	04 00 00	 mov	 rax, QWORD PTR pCTCE_Info$[rsp]
  00f52	0f b6 40 06	 movzx	 eax, BYTE PTR [rax+6]
  00f56	83 e0 08	 and	 eax, 8
  00f59	83 f8 08	 cmp	 eax, 8
  00f5c	75 1b		 jne	 SHORT $LN26@CTCE_Trace

; 3333 :         {
; 3334 :             STRLCAT( ctce_trace_xtra, "->UX" );

  00f5e	41 b8 00 01 00
	00		 mov	 r8d, 256		; 00000100H
  00f64	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG170270
  00f6b	48 8d 8c 24 00
	03 00 00	 lea	 rcx, QWORD PTR ctce_trace_xtra$[rsp]
  00f73	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_strlcat
$LN26@CTCE_Trace:
$LN25@CTCE_Trace:

; 3335 :         }
; 3336 :     }
; 3337 :     if(  IS_CTCE_WEOF( pCTCE_Info->state_x_prev ) &&

  00f79	48 8b 84 24 60
	04 00 00	 mov	 rax, QWORD PTR pCTCE_Info$[rsp]
  00f81	0f b6 40 04	 movzx	 eax, BYTE PTR [rax+4]
  00f85	25 80 00 00 00	 and	 eax, 128		; 00000080H
  00f8a	3d 80 00 00 00	 cmp	 eax, 128		; 00000080H
  00f8f	75 36		 jne	 SHORT $LN27@CTCE_Trace
  00f91	48 8b 84 24 50
	04 00 00	 mov	 rax, QWORD PTR pDEVBLK$[rsp]
  00f99	0f b6 80 34 07
	00 00		 movzx	 eax, BYTE PTR [rax+1844]
  00fa0	25 80 00 00 00	 and	 eax, 128		; 00000080H
  00fa5	3d 80 00 00 00	 cmp	 eax, 128		; 00000080H
  00faa	74 1b		 je	 SHORT $LN27@CTCE_Trace

; 3338 :         !IS_CTCE_WEOF( pDEVBLK->ctcexState      ) )
; 3339 :     {
; 3340 :         STRLCAT( ctce_trace_xtra, "->CLR" );

  00fac	41 b8 00 01 00
	00		 mov	 r8d, 256		; 00000100H
  00fb2	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG170272
  00fb9	48 8d 8c 24 00
	03 00 00	 lea	 rcx, QWORD PTR ctce_trace_xtra$[rsp]
  00fc1	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_strlcat
$LN27@CTCE_Trace:

; 3341 :     }
; 3342 : 
; 3343 :     // Report on the SCB returned if applicable.
; 3344 :     if( ( eCTCE_Cmd_Xfr != CTCE_RCV ) && IS_CTCE_CCW_SCB( ctce_Cmd ) )

  00fc7	83 bc 24 58 04
	00 00 02	 cmp	 DWORD PTR eCTCE_Cmd_Xfr$[rsp], 2
  00fcf	0f 84 1b 01 00
	00		 je	 $LN28@CTCE_Trace
  00fd5	0f b6 84 24 d0
	00 00 00	 movzx	 eax, BYTE PTR ctce_Cmd$[rsp]
  00fdd	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:CTCE_command
  00fe4	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00fe8	83 f8 04	 cmp	 eax, 4
  00feb	0f 85 ff 00 00
	00		 jne	 $LN28@CTCE_Trace

; 3345 :     {
; 3346 :         MSGBUF( ctce_trace_xtra_temp,

  00ff1	48 8b 84 24 50
	04 00 00	 mov	 rax, QWORD PTR pDEVBLK$[rsp]
  00ff9	8b 80 18 07 00
	00		 mov	 eax, DWORD PTR [rax+1816]
  00fff	83 e0 01	 and	 eax, 1
  01002	85 c0		 test	 eax, eax
  01004	75 6f		 jne	 SHORT $LN112@CTCE_Trace
  01006	48 8b 84 24 50
	04 00 00	 mov	 rax, QWORD PTR pDEVBLK$[rsp]
  0100e	8b 80 74 07 00
	00		 mov	 eax, DWORD PTR [rax+1908]
  01014	c1 e8 03	 shr	 eax, 3
  01017	83 e0 01	 and	 eax, 1
  0101a	85 c0		 test	 eax, eax
  0101c	75 57		 jne	 SHORT $LN112@CTCE_Trace
  0101e	48 8b 84 24 60
	04 00 00	 mov	 rax, QWORD PTR pCTCE_Info$[rsp]
  01026	0f b6 40 09	 movzx	 eax, BYTE PTR [rax+9]
  0102a	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:CTCE_command
  01031	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  01035	83 f8 07	 cmp	 eax, 7
  01038	75 0d		 jne	 SHORT $LN113@CTCE_Trace
  0103a	c7 84 24 5c 01
	00 00 03 00 00
	00		 mov	 DWORD PTR tv678[rsp], 3
  01045	eb 1e		 jmp	 SHORT $LN114@CTCE_Trace
$LN113@CTCE_Trace:
  01047	48 8b 84 24 60
	04 00 00	 mov	 rax, QWORD PTR pCTCE_Info$[rsp]
  0104f	0f b6 40 09	 movzx	 eax, BYTE PTR [rax+9]
  01053	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:CTCE_command
  0105a	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  0105e	89 84 24 5c 01
	00 00		 mov	 DWORD PTR tv678[rsp], eax
$LN114@CTCE_Trace:
  01065	8b 84 24 5c 01
	00 00		 mov	 eax, DWORD PTR tv678[rsp]
  0106c	89 84 24 60 01
	00 00		 mov	 DWORD PTR tv679[rsp], eax
  01073	eb 1e		 jmp	 SHORT $LN115@CTCE_Trace
$LN112@CTCE_Trace:
  01075	48 8b 84 24 60
	04 00 00	 mov	 rax, QWORD PTR pCTCE_Info$[rsp]
  0107d	0f b6 40 09	 movzx	 eax, BYTE PTR [rax+9]
  01081	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:CTCE_command
  01088	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  0108c	89 84 24 60 01
	00 00		 mov	 DWORD PTR tv679[rsp], eax
$LN115@CTCE_Trace:
  01093	48 63 84 24 60
	01 00 00	 movsxd	 rax, DWORD PTR tv679[rsp]
  0109b	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:CTCE_CmdStr
  010a2	48 8b 94 24 60
	04 00 00	 mov	 rdx, QWORD PTR pCTCE_Info$[rsp]
  010aa	0f b6 52 09	 movzx	 edx, BYTE PTR [rdx+9]
  010ae	48 8b 04 c1	 mov	 rax, QWORD PTR [rcx+rax*8]
  010b2	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  010b7	44 8b ca	 mov	 r9d, edx
  010ba	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG170274
  010c1	ba 00 01 00 00	 mov	 edx, 256		; 00000100H
  010c6	48 8d 8c 24 00
	02 00 00	 lea	 rcx, QWORD PTR ctce_trace_xtra_temp$[rsp]
  010ce	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_snprintf

; 3347 :             " SCB=%02X=%s", pCTCE_Info->scb, CTCE_CmdStr[CTCE_CMD( pCTCE_Info->scb )] );
; 3348 :         STRLCAT( ctce_trace_xtra, ctce_trace_xtra_temp );

  010d4	41 b8 00 01 00
	00		 mov	 r8d, 256		; 00000100H
  010da	48 8d 94 24 00
	02 00 00	 lea	 rdx, QWORD PTR ctce_trace_xtra_temp$[rsp]
  010e2	48 8d 8c 24 00
	03 00 00	 lea	 rcx, QWORD PTR ctce_trace_xtra$[rsp]
  010ea	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_strlcat
$LN28@CTCE_Trace:

; 3349 :     }
; 3350 : 
; 3351 :     // Report on the device status.
; 3352 :     if( pCTCE_Info->busy_waits != 0 )

  010f0	48 8b 84 24 60
	04 00 00	 mov	 rax, QWORD PTR pCTCE_Info$[rsp]
  010f8	0f b6 40 0c	 movzx	 eax, BYTE PTR [rax+12]
  010fc	85 c0		 test	 eax, eax
  010fe	74 45		 je	 SHORT $LN29@CTCE_Trace

; 3353 :     {
; 3354 :         MSGBUF( ctce_trace_xtra_temp,

  01100	48 8b 84 24 60
	04 00 00	 mov	 rax, QWORD PTR pCTCE_Info$[rsp]
  01108	0f b6 40 0c	 movzx	 eax, BYTE PTR [rax+12]
  0110c	44 8b c8	 mov	 r9d, eax
  0110f	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG170276
  01116	ba 00 01 00 00	 mov	 edx, 256		; 00000100H
  0111b	48 8d 8c 24 00
	02 00 00	 lea	 rcx, QWORD PTR ctce_trace_xtra_temp$[rsp]
  01123	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_snprintf

; 3355 :             " Busy_Waits=%d", pCTCE_Info->busy_waits );
; 3356 :         STRLCAT( ctce_trace_xtra, ctce_trace_xtra_temp );

  01129	41 b8 00 01 00
	00		 mov	 r8d, 256		; 00000100H
  0112f	48 8d 94 24 00
	02 00 00	 lea	 rdx, QWORD PTR ctce_trace_xtra_temp$[rsp]
  01137	48 8d 8c 24 00
	03 00 00	 lea	 rcx, QWORD PTR ctce_trace_xtra$[rsp]
  0113f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_strlcat
$LN29@CTCE_Trace:

; 3357 :     }
; 3358 : 
; 3359 :     // Report on the WAIT RC if needed.
; 3360 :     if( ( eCTCE_Cmd_Xfr == CTCE_SND ) && ( pCTCE_Info->wait_rc != 0 ) )

  01145	83 bc 24 58 04
	00 00 01	 cmp	 DWORD PTR eCTCE_Cmd_Xfr$[rsp], 1
  0114d	75 50		 jne	 SHORT $LN30@CTCE_Trace
  0114f	48 8b 84 24 60
	04 00 00	 mov	 rax, QWORD PTR pCTCE_Info$[rsp]
  01157	83 78 14 00	 cmp	 DWORD PTR [rax+20], 0
  0115b	74 42		 je	 SHORT $LN30@CTCE_Trace

; 3361 :     {
; 3362 :         MSGBUF( ctce_trace_xtra_temp,

  0115d	48 8b 84 24 60
	04 00 00	 mov	 rax, QWORD PTR pCTCE_Info$[rsp]
  01165	44 8b 48 14	 mov	 r9d, DWORD PTR [rax+20]
  01169	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG170278
  01170	ba 00 01 00 00	 mov	 edx, 256		; 00000100H
  01175	48 8d 8c 24 00
	02 00 00	 lea	 rcx, QWORD PTR ctce_trace_xtra_temp$[rsp]
  0117d	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_snprintf

; 3363 :             " WAIT->RC=%d", pCTCE_Info->wait_rc );
; 3364 :         STRLCAT( ctce_trace_xtra, ctce_trace_xtra_temp );

  01183	41 b8 00 01 00
	00		 mov	 r8d, 256		; 00000100H
  01189	48 8d 94 24 00
	02 00 00	 lea	 rdx, QWORD PTR ctce_trace_xtra_temp$[rsp]
  01191	48 8d 8c 24 00
	03 00 00	 lea	 rcx, QWORD PTR ctce_trace_xtra$[rsp]
  01199	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_strlcat
$LN30@CTCE_Trace:

; 3365 :     }
; 3366 : 
; 3367 :     // Report on the SENSE byte 1 and 2 if needed.
; 3368 :     if( ( pDEVBLK->sense[0] != 0 ) || ( pDEVBLK->sense[1] != 0 ) )

  0119f	b8 01 00 00 00	 mov	 eax, 1
  011a4	48 6b c0 00	 imul	 rax, rax, 0
  011a8	48 8b 8c 24 50
	04 00 00	 mov	 rcx, QWORD PTR pDEVBLK$[rsp]
  011b0	0f b6 84 01 64
	03 00 00	 movzx	 eax, BYTE PTR [rcx+rax+868]
  011b8	85 c0		 test	 eax, eax
  011ba	75 1d		 jne	 SHORT $LN33@CTCE_Trace
  011bc	b8 01 00 00 00	 mov	 eax, 1
  011c1	48 6b c0 01	 imul	 rax, rax, 1
  011c5	48 8b 8c 24 50
	04 00 00	 mov	 rcx, QWORD PTR pDEVBLK$[rsp]
  011cd	0f b6 84 01 64
	03 00 00	 movzx	 eax, BYTE PTR [rcx+rax+868]
  011d5	85 c0		 test	 eax, eax
  011d7	74 74		 je	 SHORT $LN31@CTCE_Trace
$LN33@CTCE_Trace:

; 3369 :     {
; 3370 :         MSGBUF( ctce_trace_xtra_temp,

  011d9	b8 01 00 00 00	 mov	 eax, 1
  011de	48 6b c0 01	 imul	 rax, rax, 1
  011e2	48 8b 8c 24 50
	04 00 00	 mov	 rcx, QWORD PTR pDEVBLK$[rsp]
  011ea	0f b6 84 01 64
	03 00 00	 movzx	 eax, BYTE PTR [rcx+rax+868]
  011f2	b9 01 00 00 00	 mov	 ecx, 1
  011f7	48 6b c9 00	 imul	 rcx, rcx, 0
  011fb	48 8b 94 24 50
	04 00 00	 mov	 rdx, QWORD PTR pDEVBLK$[rsp]
  01203	0f b6 8c 0a 64
	03 00 00	 movzx	 ecx, BYTE PTR [rdx+rcx+868]
  0120b	89 44 24 20	 mov	 DWORD PTR [rsp+32], eax
  0120f	44 8b c9	 mov	 r9d, ecx
  01212	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG170282
  01219	ba 00 01 00 00	 mov	 edx, 256		; 00000100H
  0121e	48 8d 8c 24 00
	02 00 00	 lea	 rcx, QWORD PTR ctce_trace_xtra_temp$[rsp]
  01226	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_snprintf

; 3371 :             " SENSE=%02X%02X", pDEVBLK->sense[0], pDEVBLK->sense[1] );
; 3372 :         STRLCAT( ctce_trace_xtra, ctce_trace_xtra_temp );

  0122c	41 b8 00 01 00
	00		 mov	 r8d, 256		; 00000100H
  01232	48 8d 94 24 00
	02 00 00	 lea	 rdx, QWORD PTR ctce_trace_xtra_temp$[rsp]
  0123a	48 8d 8c 24 00
	03 00 00	 lea	 rcx, QWORD PTR ctce_trace_xtra$[rsp]
  01242	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_strlcat

; 3373 :     }

  01248	e9 81 00 00 00	 jmp	 $LN32@CTCE_Trace
$LN31@CTCE_Trace:

; 3374 :     else if( IS_CTCE_CCW_SAS( ctce_Cmd ) )

  0124d	0f b6 84 24 d0
	00 00 00	 movzx	 eax, BYTE PTR ctce_Cmd$[rsp]
  01255	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:CTCE_command
  0125c	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  01260	83 f8 0a	 cmp	 eax, 10
  01263	75 69		 jne	 SHORT $LN34@CTCE_Trace

; 3375 :     {
; 3376 :         MSGBUF( ctce_trace_xtra_temp,

  01265	b8 01 00 00 00	 mov	 eax, 1
  0126a	48 6b c0 01	 imul	 rax, rax, 1
  0126e	48 8b 8c 24 60
	04 00 00	 mov	 rcx, QWORD PTR pCTCE_Info$[rsp]
  01276	0f b6 44 01 0a	 movzx	 eax, BYTE PTR [rcx+rax+10]
  0127b	b9 01 00 00 00	 mov	 ecx, 1
  01280	48 6b c9 00	 imul	 rcx, rcx, 0
  01284	48 8b 94 24 60
	04 00 00	 mov	 rdx, QWORD PTR pCTCE_Info$[rsp]
  0128c	0f b6 4c 0a 0a	 movzx	 ecx, BYTE PTR [rdx+rcx+10]
  01291	89 44 24 20	 mov	 DWORD PTR [rsp+32], eax
  01295	44 8b c9	 mov	 r9d, ecx
  01298	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG170284
  0129f	ba 00 01 00 00	 mov	 edx, 256		; 00000100H
  012a4	48 8d 8c 24 00
	02 00 00	 lea	 rcx, QWORD PTR ctce_trace_xtra_temp$[rsp]
  012ac	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_snprintf

; 3377 :             " SENSE=%02X%02X", pCTCE_Info->sas[0], pCTCE_Info->sas[1] );
; 3378 :         STRLCAT( ctce_trace_xtra, ctce_trace_xtra_temp );

  012b2	41 b8 00 01 00
	00		 mov	 r8d, 256		; 00000100H
  012b8	48 8d 94 24 00
	02 00 00	 lea	 rdx, QWORD PTR ctce_trace_xtra_temp$[rsp]
  012c0	48 8d 8c 24 00
	03 00 00	 lea	 rcx, QWORD PTR ctce_trace_xtra$[rsp]
  012c8	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_strlcat
$LN34@CTCE_Trace:
$LN32@CTCE_Trace:

; 3379 :     }
; 3380 : 
; 3381 :     // The "state mismatch" was used for debugging purposes
; 3382 :     // which would show logic errors.
; 3383 :     if( ( pCTCE_Info->state_new != ctce_state_verify )
; 3384 :         && !( ( !pCTCE_Info->sent ) && ( IS_CTCE_SEND( pCTCE_Info->actions ) ) ) )

  012ce	48 8b 84 24 60
	04 00 00	 mov	 rax, QWORD PTR pCTCE_Info$[rsp]
  012d6	0f b6 40 07	 movzx	 eax, BYTE PTR [rax+7]
  012da	0f b6 8c 24 d1
	00 00 00	 movzx	 ecx, BYTE PTR ctce_state_verify$[rsp]
  012e2	3b c1		 cmp	 eax, ecx
  012e4	0f 84 8b 00 00
	00		 je	 $LN35@CTCE_Trace
  012ea	48 8b 84 24 60
	04 00 00	 mov	 rax, QWORD PTR pCTCE_Info$[rsp]
  012f2	8b 40 10	 mov	 eax, DWORD PTR [rax+16]
  012f5	83 e0 01	 and	 eax, 1
  012f8	85 c0		 test	 eax, eax
  012fa	75 14		 jne	 SHORT $LN36@CTCE_Trace
  012fc	48 8b 84 24 60
	04 00 00	 mov	 rax, QWORD PTR pCTCE_Info$[rsp]
  01304	0f b6 40 06	 movzx	 eax, BYTE PTR [rax+6]
  01308	83 e0 40	 and	 eax, 64			; 00000040H
  0130b	83 f8 40	 cmp	 eax, 64			; 00000040H
  0130e	74 65		 je	 SHORT $LN35@CTCE_Trace
$LN36@CTCE_Trace:

; 3385 :     {
; 3386 :         MSGBUF( ctce_trace_xtra_temp,

  01310	48 8b 84 24 60
	04 00 00	 mov	 rax, QWORD PTR pCTCE_Info$[rsp]
  01318	0f b6 40 07	 movzx	 eax, BYTE PTR [rax+7]
  0131c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:CTCE_StaStr
  01323	0f b6 94 24 d1
	00 00 00	 movzx	 edx, BYTE PTR ctce_state_verify$[rsp]
  0132b	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:CTCE_StaStr
  01332	48 8b 04 c1	 mov	 rax, QWORD PTR [rcx+rax*8]
  01336	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  0133b	4d 8b 0c d0	 mov	 r9, QWORD PTR [r8+rdx*8]
  0133f	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG170287
  01346	ba 00 01 00 00	 mov	 edx, 256		; 00000100H
  0134b	48 8d 8c 24 00
	02 00 00	 lea	 rcx, QWORD PTR ctce_trace_xtra_temp$[rsp]
  01353	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_snprintf

; 3387 :             " CTCE_STATE MISMATCH %s!=%s(:FSM) !",
; 3388 :             CTCE_StaStr[ctce_state_verify],
; 3389 :             CTCE_StaStr[pCTCE_Info->state_new] );
; 3390 :         STRLCAT( ctce_trace_xtra, ctce_trace_xtra_temp );

  01359	41 b8 00 01 00
	00		 mov	 r8d, 256		; 00000100H
  0135f	48 8d 94 24 00
	02 00 00	 lea	 rdx, QWORD PTR ctce_trace_xtra_temp$[rsp]
  01367	48 8d 8c 24 00
	03 00 00	 lea	 rcx, QWORD PTR ctce_trace_xtra$[rsp]
  0136f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_strlcat
$LN35@CTCE_Trace:

; 3391 :     }
; 3392 : 
; 3393 :     // The unit "State mismatch" was used for debugging purposes
; 3394 :     // which would show logic errors.
; 3395 :     if( ( *pUnitStat !=
; 3396 :         ( ( ( eCTCE_Cmd_Xfr == CTCE_RCV ) && ( IS_CTCE_MATCH( pCTCE_Info->actions ) ) )
; 3397 :         ? ( CSW_CE | CSW_DE ) : ( pCTCE_Info->x_unit_stat ) ) )
; 3398 :         && !( *pUnitStat & ( CSW_UC | CSW_UX | CSW_SM ) )
; 3399 :         && !( ( eCTCE_Cmd_Xfr == CTCE_RCV ) && ( IS_CTCE_WAIT( pCTCE_Info->actions ) ) )
; 3400 :         &&  ( ( eCTCE_Cmd_Xfr != CTCE_RCV ) || ( *pUnitStat != 0 ) )
; 3401 :         && !( pCTCE_Info->de_ready ) )

  01375	83 bc 24 58 04
	00 00 02	 cmp	 DWORD PTR eCTCE_Cmd_Xfr$[rsp], 2
  0137d	75 21		 jne	 SHORT $LN116@CTCE_Trace
  0137f	48 8b 84 24 60
	04 00 00	 mov	 rax, QWORD PTR pCTCE_Info$[rsp]
  01387	0f b6 40 06	 movzx	 eax, BYTE PTR [rax+6]
  0138b	83 e0 08	 and	 eax, 8
  0138e	83 f8 08	 cmp	 eax, 8
  01391	75 0d		 jne	 SHORT $LN116@CTCE_Trace
  01393	c7 84 24 64 01
	00 00 0c 00 00
	00		 mov	 DWORD PTR tv796[rsp], 12
  0139e	eb 13		 jmp	 SHORT $LN117@CTCE_Trace
$LN116@CTCE_Trace:
  013a0	48 8b 84 24 60
	04 00 00	 mov	 rax, QWORD PTR pCTCE_Info$[rsp]
  013a8	0f b6 40 08	 movzx	 eax, BYTE PTR [rax+8]
  013ac	89 84 24 64 01
	00 00		 mov	 DWORD PTR tv796[rsp], eax
$LN117@CTCE_Trace:
  013b3	48 8b 84 24 68
	04 00 00	 mov	 rax, QWORD PTR pUnitStat$[rsp]
  013bb	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  013be	3b 84 24 64 01
	00 00		 cmp	 eax, DWORD PTR tv796[rsp]
  013c5	0f 84 b1 00 00
	00		 je	 $LN37@CTCE_Trace
  013cb	48 8b 84 24 68
	04 00 00	 mov	 rax, QWORD PTR pUnitStat$[rsp]
  013d3	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  013d6	83 e0 43	 and	 eax, 67			; 00000043H
  013d9	85 c0		 test	 eax, eax
  013db	0f 85 9b 00 00
	00		 jne	 $LN37@CTCE_Trace
  013e1	83 bc 24 58 04
	00 00 02	 cmp	 DWORD PTR eCTCE_Cmd_Xfr$[rsp], 2
  013e9	75 14		 jne	 SHORT $LN38@CTCE_Trace
  013eb	48 8b 84 24 60
	04 00 00	 mov	 rax, QWORD PTR pCTCE_Info$[rsp]
  013f3	0f b6 40 06	 movzx	 eax, BYTE PTR [rax+6]
  013f7	83 e0 20	 and	 eax, 32			; 00000020H
  013fa	83 f8 20	 cmp	 eax, 32			; 00000020H
  013fd	74 7d		 je	 SHORT $LN37@CTCE_Trace
$LN38@CTCE_Trace:
  013ff	83 bc 24 58 04
	00 00 02	 cmp	 DWORD PTR eCTCE_Cmd_Xfr$[rsp], 2
  01407	75 0f		 jne	 SHORT $LN39@CTCE_Trace
  01409	48 8b 84 24 68
	04 00 00	 mov	 rax, QWORD PTR pUnitStat$[rsp]
  01411	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  01414	85 c0		 test	 eax, eax
  01416	74 64		 je	 SHORT $LN37@CTCE_Trace
$LN39@CTCE_Trace:
  01418	48 8b 84 24 60
	04 00 00	 mov	 rax, QWORD PTR pCTCE_Info$[rsp]
  01420	0f b6 40 0d	 movzx	 eax, BYTE PTR [rax+13]
  01424	85 c0		 test	 eax, eax
  01426	75 54		 jne	 SHORT $LN37@CTCE_Trace

; 3402 :     {
; 3403 :         MSGBUF( ctce_trace_xtra_temp,

  01428	48 8b 84 24 60
	04 00 00	 mov	 rax, QWORD PTR pCTCE_Info$[rsp]
  01430	0f b6 40 08	 movzx	 eax, BYTE PTR [rax+8]
  01434	48 8b 8c 24 68
	04 00 00	 mov	 rcx, QWORD PTR pUnitStat$[rsp]
  0143c	0f b6 09	 movzx	 ecx, BYTE PTR [rcx]
  0143f	89 44 24 20	 mov	 DWORD PTR [rsp+32], eax
  01443	44 8b c9	 mov	 r9d, ecx
  01446	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG170291
  0144d	ba 00 01 00 00	 mov	 edx, 256		; 00000100H
  01452	48 8d 8c 24 00
	02 00 00	 lea	 rcx, QWORD PTR ctce_trace_xtra_temp$[rsp]
  0145a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_snprintf

; 3404 :             " Stat MISMATCH %02X!=%02X(:FSM) !",
; 3405 :             *pUnitStat, pCTCE_Info->x_unit_stat );
; 3406 :         STRLCAT( ctce_trace_xtra, ctce_trace_xtra_temp );

  01460	41 b8 00 01 00
	00		 mov	 r8d, 256		; 00000100H
  01466	48 8d 94 24 00
	02 00 00	 lea	 rdx, QWORD PTR ctce_trace_xtra_temp$[rsp]
  0146e	48 8d 8c 24 00
	03 00 00	 lea	 rcx, QWORD PTR ctce_trace_xtra$[rsp]
  01476	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_strlcat
$LN37@CTCE_Trace:

; 3407 :     }
; 3408 : 
; 3409 :     // Report a contention loser situation.
; 3410 :     if( pCTCE_Info->con_lost )

  0147c	48 8b 84 24 60
	04 00 00	 mov	 rax, QWORD PTR pCTCE_Info$[rsp]
  01484	8b 40 10	 mov	 eax, DWORD PTR [rax+16]
  01487	c1 e8 02	 shr	 eax, 2
  0148a	83 e0 01	 and	 eax, 1
  0148d	85 c0		 test	 eax, eax
  0148f	74 1b		 je	 SHORT $LN40@CTCE_Trace

; 3411 :     {
; 3412 :         STRLCAT( ctce_trace_xtra, " CON_LOSER" );

  01491	41 b8 00 01 00
	00		 mov	 r8d, 256		; 00000100H
  01497	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG170293
  0149e	48 8d 8c 24 00
	03 00 00	 lea	 rcx, QWORD PTR ctce_trace_xtra$[rsp]
  014a6	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_strlcat
$LN40@CTCE_Trace:

; 3413 :     }
; 3414 : 
; 3415 :     // Report a contention winner situation.
; 3416 :     if( pCTCE_Info->con_won )

  014ac	48 8b 84 24 60
	04 00 00	 mov	 rax, QWORD PTR pCTCE_Info$[rsp]
  014b4	8b 40 10	 mov	 eax, DWORD PTR [rax+16]
  014b7	c1 e8 03	 shr	 eax, 3
  014ba	83 e0 01	 and	 eax, 1
  014bd	85 c0		 test	 eax, eax
  014bf	74 1b		 je	 SHORT $LN41@CTCE_Trace

; 3417 :     {
; 3418 :         STRLCAT( ctce_trace_xtra, " IGNORED / CON_WINNER" );

  014c1	41 b8 00 01 00
	00		 mov	 r8d, 256		; 00000100H
  014c7	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG170295
  014ce	48 8d 8c 24 00
	03 00 00	 lea	 rcx, QWORD PTR ctce_trace_xtra$[rsp]
  014d6	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_strlcat
$LN41@CTCE_Trace:

; 3419 :     }
; 3420 : 
; 3421 :     // Report a Halt or Clear causing a Reset.
; 3422 :     if( pDEVBLK->scsw.flag2 & SCSW2_FC_HALT )

  014dc	48 8b 84 24 50
	04 00 00	 mov	 rax, QWORD PTR pDEVBLK$[rsp]
  014e4	0f b6 80 0a 03
	00 00		 movzx	 eax, BYTE PTR [rax+778]
  014eb	83 e0 20	 and	 eax, 32			; 00000020H
  014ee	85 c0		 test	 eax, eax
  014f0	74 1b		 je	 SHORT $LN42@CTCE_Trace

; 3423 :     {
; 3424 :         STRLCAT( ctce_trace_xtra, " HALT" );

  014f2	41 b8 00 01 00
	00		 mov	 r8d, 256		; 00000100H
  014f8	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG170297
  014ff	48 8d 8c 24 00
	03 00 00	 lea	 rcx, QWORD PTR ctce_trace_xtra$[rsp]
  01507	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_strlcat
$LN42@CTCE_Trace:

; 3425 :     }
; 3426 :     if( pDEVBLK->scsw.flag2 & SCSW2_FC_CLEAR )

  0150d	48 8b 84 24 50
	04 00 00	 mov	 rax, QWORD PTR pDEVBLK$[rsp]
  01515	0f b6 80 0a 03
	00 00		 movzx	 eax, BYTE PTR [rax+778]
  0151c	83 e0 10	 and	 eax, 16
  0151f	85 c0		 test	 eax, eax
  01521	74 1b		 je	 SHORT $LN43@CTCE_Trace

; 3427 :     {
; 3428 :         STRLCAT( ctce_trace_xtra, " CLEAR" );

  01523	41 b8 00 01 00
	00		 mov	 r8d, 256		; 00000100H
  01529	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG170299
  01530	48 8d 8c 24 00
	03 00 00	 lea	 rcx, QWORD PTR ctce_trace_xtra$[rsp]
  01538	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_strlcat
$LN43@CTCE_Trace:

; 3429 :     }
; 3430 :     if( IS_CTCE_RST( ctce_Cmd ) &&

  0153e	0f b6 84 24 d0
	00 00 00	 movzx	 eax, BYTE PTR ctce_Cmd$[rsp]
  01546	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:CTCE_command
  0154d	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  01551	83 f8 0e	 cmp	 eax, 14
  01554	75 31		 jne	 SHORT $LN44@CTCE_Trace
  01556	48 8b 84 24 50
	04 00 00	 mov	 rax, QWORD PTR pDEVBLK$[rsp]
  0155e	0f b6 80 0a 03
	00 00		 movzx	 eax, BYTE PTR [rax+778]
  01565	83 e0 30	 and	 eax, 48			; 00000030H
  01568	85 c0		 test	 eax, eax
  0156a	75 1b		 jne	 SHORT $LN44@CTCE_Trace

; 3431 :        !( pDEVBLK->scsw.flag2 & ( SCSW2_FC_HALT | SCSW2_FC_CLEAR ) ) )
; 3432 :     {
; 3433 :         STRLCAT( ctce_trace_xtra, " RESET" );

  0156c	41 b8 00 01 00
	00		 mov	 r8d, 256		; 00000100H
  01572	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG170301
  01579	48 8d 8c 24 00
	03 00 00	 lea	 rcx, QWORD PTR ctce_trace_xtra$[rsp]
  01581	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_strlcat
$LN44@CTCE_Trace:

; 3434 :     }
; 3435 : 
; 3436 :     // Temporarily triggered trace will end prematureley on a matching
; 3437 :     // Read or Write command.
; 3438 :     if( ( pDEVBLK->ctce_trace_cntr > 0 ) && IS_CTCE_MATCH( pCTCE_Info->actions ) &&

  01587	48 8b 84 24 50
	04 00 00	 mov	 rax, QWORD PTR pDEVBLK$[rsp]
  0158f	83 b8 68 07 00
	00 00		 cmp	 DWORD PTR [rax+1896], 0
  01596	0f 8e e6 00 00
	00		 jle	 $LN45@CTCE_Trace
  0159c	48 8b 84 24 60
	04 00 00	 mov	 rax, QWORD PTR pCTCE_Info$[rsp]
  015a4	0f b6 40 06	 movzx	 eax, BYTE PTR [rax+6]
  015a8	83 e0 08	 and	 eax, 8
  015ab	83 f8 08	 cmp	 eax, 8
  015ae	0f 85 ce 00 00
	00		 jne	 $LN45@CTCE_Trace
  015b4	0f b6 84 24 d0
	00 00 00	 movzx	 eax, BYTE PTR ctce_Cmd$[rsp]
  015bc	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:CTCE_command
  015c3	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  015c7	83 f8 02	 cmp	 eax, 2
  015ca	0f 84 a0 00 00
	00		 je	 $LN46@CTCE_Trace
  015d0	48 8b 84 24 50
	04 00 00	 mov	 rax, QWORD PTR pDEVBLK$[rsp]
  015d8	8b 80 18 07 00
	00		 mov	 eax, DWORD PTR [rax+1816]
  015de	83 e0 01	 and	 eax, 1
  015e1	85 c0		 test	 eax, eax
  015e3	75 67		 jne	 SHORT $LN118@CTCE_Trace
  015e5	48 8b 84 24 50
	04 00 00	 mov	 rax, QWORD PTR pDEVBLK$[rsp]
  015ed	8b 80 74 07 00
	00		 mov	 eax, DWORD PTR [rax+1908]
  015f3	c1 e8 03	 shr	 eax, 3
  015f6	83 e0 01	 and	 eax, 1
  015f9	85 c0		 test	 eax, eax
  015fb	75 4f		 jne	 SHORT $LN118@CTCE_Trace
  015fd	0f b6 84 24 d0
	00 00 00	 movzx	 eax, BYTE PTR ctce_Cmd$[rsp]
  01605	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:CTCE_command
  0160c	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  01610	83 f8 07	 cmp	 eax, 7
  01613	75 0d		 jne	 SHORT $LN119@CTCE_Trace
  01615	c7 84 24 68 01
	00 00 03 00 00
	00		 mov	 DWORD PTR tv894[rsp], 3
  01620	eb 1a		 jmp	 SHORT $LN120@CTCE_Trace
$LN119@CTCE_Trace:
  01622	0f b6 84 24 d0
	00 00 00	 movzx	 eax, BYTE PTR ctce_Cmd$[rsp]
  0162a	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:CTCE_command
  01631	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  01635	89 84 24 68 01
	00 00		 mov	 DWORD PTR tv894[rsp], eax
$LN120@CTCE_Trace:
  0163c	8b 84 24 68 01
	00 00		 mov	 eax, DWORD PTR tv894[rsp]
  01643	89 84 24 6c 01
	00 00		 mov	 DWORD PTR tv895[rsp], eax
  0164a	eb 1a		 jmp	 SHORT $LN121@CTCE_Trace
$LN118@CTCE_Trace:
  0164c	0f b6 84 24 d0
	00 00 00	 movzx	 eax, BYTE PTR ctce_Cmd$[rsp]
  01654	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:CTCE_command
  0165b	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  0165f	89 84 24 6c 01
	00 00		 mov	 DWORD PTR tv895[rsp], eax
$LN121@CTCE_Trace:
  01666	83 bc 24 6c 01
	00 00 03	 cmp	 DWORD PTR tv895[rsp], 3
  0166e	75 12		 jne	 SHORT $LN45@CTCE_Trace
$LN46@CTCE_Trace:

; 3439 :         ( IS_CTCE_CCW_RED( ctce_Cmd ) || IS_CTCE_CCW_WRT( ctce_Cmd ) ) )
; 3440 :     {
; 3441 :         pDEVBLK->ctce_trace_cntr = 0;

  01670	48 8b 84 24 50
	04 00 00	 mov	 rax, QWORD PTR pDEVBLK$[rsp]
  01678	c7 80 68 07 00
	00 00 00 00 00	 mov	 DWORD PTR [rax+1896], 0
$LN45@CTCE_Trace:

; 3442 :     }
; 3443 : 
; 3444 :     // Add an ending dot if this ends a temporarily triggered trace.
; 3445 :     if( !pDEVBLK->ccwtrace && ( pDEVBLK->ctce_trace_cntr == 0 ) )

  01682	48 8b 84 24 50
	04 00 00	 mov	 rax, QWORD PTR pDEVBLK$[rsp]
  0168a	8b 80 f8 05 00
	00		 mov	 eax, DWORD PTR [rax+1528]
  01690	c1 e8 0f	 shr	 eax, 15
  01693	83 e0 01	 and	 eax, 1
  01696	85 c0		 test	 eax, eax
  01698	75 2c		 jne	 SHORT $LN47@CTCE_Trace
  0169a	48 8b 84 24 50
	04 00 00	 mov	 rax, QWORD PTR pDEVBLK$[rsp]
  016a2	83 b8 68 07 00
	00 00		 cmp	 DWORD PTR [rax+1896], 0
  016a9	75 1b		 jne	 SHORT $LN47@CTCE_Trace

; 3446 :     {
; 3447 :         STRLCAT( ctce_trace_xtra, "." );

  016ab	41 b8 00 01 00
	00		 mov	 r8d, 256		; 00000100H
  016b1	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG170305
  016b8	48 8d 8c 24 00
	03 00 00	 lea	 rcx, QWORD PTR ctce_trace_xtra$[rsp]
  016c0	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_strlcat
$LN47@CTCE_Trace:

; 3448 :     }
; 3449 : 
; 3450 : /*
; 3451 : 
; 3452 : HHC05079I <src_dev> CTCE: <direction> <dst_dev> <seq#> cmd=<cmd>=<cmd_hex>
; 3453 :           xy=<x_src><y_src><direction><x_dst><y_dst> l=<length> k=<chksum>
; 3454 :           Stat=<stat> <extra_msgs>
; 3455 : 
; 3456 : Explanation
; 3457 :         The CTCE device <local_dev> processes a <cmd> (hex value <cmd_hex>).
; 3458 :         The <direction> shows whether it originates locally (the x-side),
; 3459 :         and if it needs to be sent (->) to the remote <remote_dev> device
; 3460 :         (the y-side), or if the command was received (<-) from the y-side.
; 3461 :         The command causes a state transition shown in <x_local><y_local>
; 3462 :         <direction> <x_remote><y_remote>, using single-letter presentations
; 3463 :         for these (p, c, r, w, a, n); the change is highlighted in uppercase.
; 3464 :         (p=Prepare, c=Control, r=Read, w=Write, a=Available, n=Not-Ready).
; 3465 :         The resulting unit device status is shown in hex <stat>.  Extra
; 3466 :         action indications are given in <extra_msgs>, .e.g. WAIT for a
; 3467 :         matching command from the other y-side, raise ATTN at the other
; 3468 :         side which results in ATTN->RC=rc or is canceled ATTN->NONE,
; 3469 :         DE_READY->RC=rc showing DE singalling READY from the other side,
; 3470 :         and End-of-File being set (WEOF->SET) or cleared (WEOF->CLR) or
; 3471 :         just found to be set (WEOF).  WEOF->UX shows when it generates a
; 3472 :         device Unit Exception.  Other <extra_msgs> may appear.
; 3473 : 
; 3474 : Action
; 3475 :         None.
; 3476 : 
; 3477 : */
; 3478 : 
; 3479 :     WRMSG( HHC05079, "I",  // CTCE: %s %.6s #%04X cmd=%s=%02X xy=%.2s%s%.2s l=%04X k=%08X %s%s%s%s%s%s

  016c6	48 8b 84 24 60
	04 00 00	 mov	 rax, QWORD PTR pCTCE_Info$[rsp]
  016ce	0f b6 40 06	 movzx	 eax, BYTE PTR [rax+6]
  016d2	83 e0 10	 and	 eax, 16
  016d5	83 f8 10	 cmp	 eax, 16
  016d8	75 11		 jne	 SHORT $LN122@CTCE_Trace
  016da	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG170306
  016e1	48 89 84 24 98
	01 00 00	 mov	 QWORD PTR tv912[rsp], rax
  016e9	eb 0f		 jmp	 SHORT $LN123@CTCE_Trace
$LN122@CTCE_Trace:
  016eb	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG170307
  016f2	48 89 84 24 98
	01 00 00	 mov	 QWORD PTR tv912[rsp], rax
$LN123@CTCE_Trace:
  016fa	48 8b 84 24 60
	04 00 00	 mov	 rax, QWORD PTR pCTCE_Info$[rsp]
  01702	0f b6 40 06	 movzx	 eax, BYTE PTR [rax+6]
  01706	83 e0 08	 and	 eax, 8
  01709	83 f8 08	 cmp	 eax, 8
  0170c	75 11		 jne	 SHORT $LN124@CTCE_Trace
  0170e	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG170308
  01715	48 89 84 24 a0
	01 00 00	 mov	 QWORD PTR tv918[rsp], rax
  0171d	eb 0f		 jmp	 SHORT $LN125@CTCE_Trace
$LN124@CTCE_Trace:
  0171f	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG170309
  01726	48 89 84 24 a0
	01 00 00	 mov	 QWORD PTR tv918[rsp], rax
$LN125@CTCE_Trace:
  0172e	48 8b 84 24 60
	04 00 00	 mov	 rax, QWORD PTR pCTCE_Info$[rsp]
  01736	0f b6 40 06	 movzx	 eax, BYTE PTR [rax+6]
  0173a	83 e0 20	 and	 eax, 32			; 00000020H
  0173d	83 f8 20	 cmp	 eax, 32			; 00000020H
  01740	75 11		 jne	 SHORT $LN126@CTCE_Trace
  01742	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG170310
  01749	48 89 84 24 a8
	01 00 00	 mov	 QWORD PTR tv924[rsp], rax
  01751	eb 0f		 jmp	 SHORT $LN127@CTCE_Trace
$LN126@CTCE_Trace:
  01753	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG170311
  0175a	48 89 84 24 a8
	01 00 00	 mov	 QWORD PTR tv924[rsp], rax
$LN127@CTCE_Trace:
  01762	48 8b 84 24 60
	04 00 00	 mov	 rax, QWORD PTR pCTCE_Info$[rsp]
  0176a	0f b6 40 06	 movzx	 eax, BYTE PTR [rax+6]
  0176e	25 80 00 00 00	 and	 eax, 128		; 00000080H
  01773	3d 80 00 00 00	 cmp	 eax, 128		; 00000080H
  01778	75 11		 jne	 SHORT $LN128@CTCE_Trace
  0177a	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG170312
  01781	48 89 84 24 b0
	01 00 00	 mov	 QWORD PTR tv962[rsp], rax
  01789	eb 0f		 jmp	 SHORT $LN129@CTCE_Trace
$LN128@CTCE_Trace:
  0178b	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG170313
  01792	48 89 84 24 b0
	01 00 00	 mov	 QWORD PTR tv962[rsp], rax
$LN129@CTCE_Trace:
  0179a	48 8b 84 24 50
	04 00 00	 mov	 rax, QWORD PTR pDEVBLK$[rsp]
  017a2	8b 80 18 07 00
	00		 mov	 eax, DWORD PTR [rax+1816]
  017a8	83 e0 01	 and	 eax, 1
  017ab	85 c0		 test	 eax, eax
  017ad	75 67		 jne	 SHORT $LN130@CTCE_Trace
  017af	48 8b 84 24 50
	04 00 00	 mov	 rax, QWORD PTR pDEVBLK$[rsp]
  017b7	8b 80 74 07 00
	00		 mov	 eax, DWORD PTR [rax+1908]
  017bd	c1 e8 03	 shr	 eax, 3
  017c0	83 e0 01	 and	 eax, 1
  017c3	85 c0		 test	 eax, eax
  017c5	75 4f		 jne	 SHORT $LN130@CTCE_Trace
  017c7	0f b6 84 24 d0
	00 00 00	 movzx	 eax, BYTE PTR ctce_Cmd$[rsp]
  017cf	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:CTCE_command
  017d6	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  017da	83 f8 07	 cmp	 eax, 7
  017dd	75 0d		 jne	 SHORT $LN131@CTCE_Trace
  017df	c7 84 24 70 01
	00 00 03 00 00
	00		 mov	 DWORD PTR tv1001[rsp], 3
  017ea	eb 1a		 jmp	 SHORT $LN132@CTCE_Trace
$LN131@CTCE_Trace:
  017ec	0f b6 84 24 d0
	00 00 00	 movzx	 eax, BYTE PTR ctce_Cmd$[rsp]
  017f4	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:CTCE_command
  017fb	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  017ff	89 84 24 70 01
	00 00		 mov	 DWORD PTR tv1001[rsp], eax
$LN132@CTCE_Trace:
  01806	8b 84 24 70 01
	00 00		 mov	 eax, DWORD PTR tv1001[rsp]
  0180d	89 84 24 74 01
	00 00		 mov	 DWORD PTR tv1002[rsp], eax
  01814	eb 1a		 jmp	 SHORT $LN133@CTCE_Trace
$LN130@CTCE_Trace:
  01816	0f b6 84 24 d0
	00 00 00	 movzx	 eax, BYTE PTR ctce_Cmd$[rsp]
  0181e	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:CTCE_command
  01825	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  01829	89 84 24 74 01
	00 00		 mov	 DWORD PTR tv1002[rsp], eax
$LN133@CTCE_Trace:
  01830	48 8b 84 24 e0
	00 00 00	 mov	 rax, QWORD PTR pSokBuf$[rsp]
  01838	0f b7 50 08	 movzx	 edx, WORD PTR [rax+8]
  0183c	48 8b 8c 24 e0
	00 00 00	 mov	 rcx, QWORD PTR pSokBuf$[rsp]
  01844	e8 00 00 00 00	 call	 CTCE_ChkSum
  01849	89 84 24 80 01
	00 00		 mov	 DWORD PTR tv965[rsp], eax
  01850	48 8b 8c 24 e0
	00 00 00	 mov	 rcx, QWORD PTR pSokBuf$[rsp]
  01858	0f b7 49 02	 movzx	 ecx, WORD PTR [rcx+2]
  0185c	89 8c 24 84 01
	00 00		 mov	 DWORD PTR tv971[rsp], ecx
  01863	48 63 94 24 58
	04 00 00	 movsxd	 rdx, DWORD PTR eCTCE_Cmd_Xfr$[rsp]
  0186b	48 89 94 24 c0
	01 00 00	 mov	 QWORD PTR tv974[rsp], rdx
  01873	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:?CTCE_XfrStr@?1??CTCE_Trace@@9@9
  0187a	4c 89 84 24 b8
	01 00 00	 mov	 QWORD PTR tv1091[rsp], r8
  01882	44 0f b6 8c 24
	d0 00 00 00	 movzx	 r9d, BYTE PTR ctce_Cmd$[rsp]
  0188b	44 89 8c 24 88
	01 00 00	 mov	 DWORD PTR tv979[rsp], r9d
  01893	4c 63 94 24 74
	01 00 00	 movsxd	 r10, DWORD PTR tv1002[rsp]
  0189b	4c 89 94 24 d0
	01 00 00	 mov	 QWORD PTR tv1003[rsp], r10
  018a3	4c 8d 1d 00 00
	00 00		 lea	 r11, OFFSET FLAT:CTCE_CmdStr
  018aa	4c 89 9c 24 c8
	01 00 00	 mov	 QWORD PTR tv1092[rsp], r11
  018b2	0f b6 9c 24 dc
	00 00 00	 movzx	 ebx, BYTE PTR ctce_PktSeq$[rsp]
  018ba	48 8b bc 24 50
	04 00 00	 mov	 rdi, QWORD PTR pDEVBLK$[rsp]
  018c2	48 81 c7 a4 00
	00 00		 add	 rdi, 164		; 000000a4H
  018c9	48 63 b4 24 58
	04 00 00	 movsxd	 rsi, DWORD PTR eCTCE_Cmd_Xfr$[rsp]
  018d1	48 8d 2d 00 00
	00 00		 lea	 rbp, OFFSET FLAT:?CTCE_XfrStr@?1??CTCE_Trace@@9@9
  018d8	4c 8b b4 24 50
	04 00 00	 mov	 r14, QWORD PTR pDEVBLK$[rsp]
  018e0	45 0f b7 76 48	 movzx	 r14d, WORD PTR [r14+72]
  018e5	4c 8b bc 24 50
	04 00 00	 mov	 r15, QWORD PTR pDEVBLK$[rsp]
  018ed	45 0f b7 7f 44	 movzx	 r15d, WORD PTR [r15+68]
  018f2	41 d1 ff	 sar	 r15d, 1
  018f5	b9 01 00 00 00	 mov	 ecx, 1
  018fa	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  01900	48 8d 8c 24 00
	03 00 00	 lea	 rcx, QWORD PTR ctce_trace_xtra$[rsp]
  01908	48 89 8c 24 c0
	00 00 00	 mov	 QWORD PTR [rsp+192], rcx
  01910	48 8b 8c 24 98
	01 00 00	 mov	 rcx, QWORD PTR tv912[rsp]
  01918	48 89 8c 24 b8
	00 00 00	 mov	 QWORD PTR [rsp+184], rcx
  01920	48 8b 8c 24 a0
	01 00 00	 mov	 rcx, QWORD PTR tv918[rsp]
  01928	48 89 8c 24 b0
	00 00 00	 mov	 QWORD PTR [rsp+176], rcx
  01930	48 8b 8c 24 a8
	01 00 00	 mov	 rcx, QWORD PTR tv924[rsp]
  01938	48 89 8c 24 a8
	00 00 00	 mov	 QWORD PTR [rsp+168], rcx
  01940	48 8b 8c 24 b0
	01 00 00	 mov	 rcx, QWORD PTR tv962[rsp]
  01948	48 89 8c 24 a0
	00 00 00	 mov	 QWORD PTR [rsp+160], rcx
  01950	48 8d 8c 24 e0
	01 00 00	 lea	 rcx, QWORD PTR ctce_trace_stat$[rsp]
  01958	48 89 8c 24 98
	00 00 00	 mov	 QWORD PTR [rsp+152], rcx
  01960	8b 8c 24 80 01
	00 00		 mov	 ecx, DWORD PTR tv965[rsp]
  01967	89 8c 24 90 00
	00 00		 mov	 DWORD PTR [rsp+144], ecx
  0196e	8b 8c 24 84 01
	00 00		 mov	 ecx, DWORD PTR tv971[rsp]
  01975	89 8c 24 88 00
	00 00		 mov	 DWORD PTR [rsp+136], ecx
  0197c	48 8d 8c 24 d4
	00 00 00	 lea	 rcx, QWORD PTR ctce_state_r_xy$[rsp]
  01984	48 89 8c 24 80
	00 00 00	 mov	 QWORD PTR [rsp+128], rcx
  0198c	48 8b 94 24 b8
	01 00 00	 mov	 rdx, QWORD PTR tv1091[rsp]
  01994	48 8b 8c 24 c0
	01 00 00	 mov	 rcx, QWORD PTR tv974[rsp]
  0199c	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  019a0	48 89 4c 24 78	 mov	 QWORD PTR [rsp+120], rcx
  019a5	48 8d 8c 24 d8
	00 00 00	 lea	 rcx, QWORD PTR ctce_state_l_xy$[rsp]
  019ad	48 89 4c 24 70	 mov	 QWORD PTR [rsp+112], rcx
  019b2	8b 8c 24 88 01
	00 00		 mov	 ecx, DWORD PTR tv979[rsp]
  019b9	89 4c 24 68	 mov	 DWORD PTR [rsp+104], ecx
  019bd	48 8b 8c 24 c8
	01 00 00	 mov	 rcx, QWORD PTR tv1092[rsp]
  019c5	48 8b 94 24 d0
	01 00 00	 mov	 rdx, QWORD PTR tv1003[rsp]
  019cd	48 8b 0c d1	 mov	 rcx, QWORD PTR [rcx+rdx*8]
  019d1	48 89 4c 24 60	 mov	 QWORD PTR [rsp+96], rcx
  019d6	89 5c 24 58	 mov	 DWORD PTR [rsp+88], ebx
  019da	48 89 7c 24 50	 mov	 QWORD PTR [rsp+80], rdi
  019df	48 8b 4c f5 00	 mov	 rcx, QWORD PTR [rbp+rsi*8]
  019e4	48 89 4c 24 48	 mov	 QWORD PTR [rsp+72], rcx
  019e9	44 89 74 24 40	 mov	 DWORD PTR [rsp+64], r14d
  019ee	44 89 7c 24 38	 mov	 DWORD PTR [rsp+56], r15d
  019f3	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170314
  019fa	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  019ff	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170315
  01a06	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  01a0b	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  01a10	41 b9 03 00 00
	00		 mov	 r9d, 3
  01a16	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG170316
  01a1d	ba a0 0d 00 00	 mov	 edx, 3488		; 00000da0H
  01a22	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170317
  01a29	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 3480 :         CTCX_DEVNUM( pDEVBLK ), CTCE_XfrStr[eCTCE_Cmd_Xfr],
; 3481 :         pDEVBLK->filename, ctce_PktSeq,
; 3482 :         CTCE_CmdStr[CTCE_CMD( ctce_Cmd )], ctce_Cmd,
; 3483 :         ctce_state_l_xy, CTCE_XfrStr[eCTCE_Cmd_Xfr],
; 3484 :         ctce_state_r_xy, pSokBuf->sCount,
; 3485 :         CTCE_ChkSum( ( BYTE * ) pSokBuf, pSokBuf->SndLen ),
; 3486 :         ctce_trace_stat,
; 3487 :         CTCE_ACTIONS_PRT( pCTCE_Info->actions ),
; 3488 :         ctce_trace_xtra );
; 3489 :     if( pDEVBLK->ccwtrace )

  01a2f	48 8b 84 24 50
	04 00 00	 mov	 rax, QWORD PTR pDEVBLK$[rsp]
  01a37	8b 80 f8 05 00
	00		 mov	 eax, DWORD PTR [rax+1528]
  01a3d	c1 e8 0f	 shr	 eax, 15
  01a40	83 e0 01	 and	 eax, 1
  01a43	85 c0		 test	 eax, eax
  01a45	0f 84 a4 00 00
	00		 je	 $LN48@CTCE_Trace

; 3490 :     {
; 3491 :         MSGBUF( ctce_devnum, "%1d:%04X", CTCE_DEVNUM( pDEVBLK ) );

  01a4b	48 8b 84 24 50
	04 00 00	 mov	 rax, QWORD PTR pDEVBLK$[rsp]
  01a53	0f b7 40 48	 movzx	 eax, WORD PTR [rax+72]
  01a57	48 8b 8c 24 50
	04 00 00	 mov	 rcx, QWORD PTR pDEVBLK$[rsp]
  01a5f	0f b7 49 44	 movzx	 ecx, WORD PTR [rcx+68]
  01a63	d1 f9		 sar	 ecx, 1
  01a65	89 44 24 20	 mov	 DWORD PTR [rsp+32], eax
  01a69	44 8b c9	 mov	 r9d, ecx
  01a6c	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG170319
  01a73	ba 08 00 00 00	 mov	 edx, 8
  01a78	48 8d 8c 24 d8
	01 00 00	 lea	 rcx, QWORD PTR ctce_devnum$[rsp]
  01a80	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_snprintf

; 3492 :         net_data_trace( pDEVBLK, ( BYTE * ) pSokBuf, pSokBuf->SndLen ,

  01a86	83 bc 24 58 04
	00 00 02	 cmp	 DWORD PTR eCTCE_Cmd_Xfr$[rsp], 2
  01a8e	75 0d		 jne	 SHORT $LN134@CTCE_Trace
  01a90	c7 84 24 78 01
	00 00 3c 00 00
	00		 mov	 DWORD PTR tv1049[rsp], 60 ; 0000003cH
  01a9b	eb 0b		 jmp	 SHORT $LN135@CTCE_Trace
$LN134@CTCE_Trace:
  01a9d	c7 84 24 78 01
	00 00 3e 00 00
	00		 mov	 DWORD PTR tv1049[rsp], 62 ; 0000003eH
$LN135@CTCE_Trace:
  01aa8	48 8b 84 24 e0
	00 00 00	 mov	 rax, QWORD PTR pSokBuf$[rsp]
  01ab0	0f b7 40 08	 movzx	 eax, WORD PTR [rax+8]
  01ab4	c7 44 24 30 00
	00 00 00	 mov	 DWORD PTR [rsp+48], 0
  01abc	48 8d 8c 24 d8
	01 00 00	 lea	 rcx, QWORD PTR ctce_devnum$[rsp]
  01ac4	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  01ac9	c6 44 24 20 44	 mov	 BYTE PTR [rsp+32], 68	; 00000044H
  01ace	44 0f b6 8c 24
	78 01 00 00	 movzx	 r9d, BYTE PTR tv1049[rsp]
  01ad7	44 8b c0	 mov	 r8d, eax
  01ada	48 8b 94 24 e0
	00 00 00	 mov	 rdx, QWORD PTR pSokBuf$[rsp]
  01ae2	48 8b 8c 24 50
	04 00 00	 mov	 rcx, QWORD PTR pDEVBLK$[rsp]
  01aea	e8 00 00 00 00	 call	 net_data_trace
$LN48@CTCE_Trace:
$LN49@CTCE_Trace:

; 3493 :             ( eCTCE_Cmd_Xfr == CTCE_RCV ) ? '<' : '>', 'D', ctce_devnum, 0 );
; 3494 :     }
; 3495 :     return;
; 3496 : 
; 3497 : } // CTCE_Trace

  01aef	48 8b 8c 24 00
	04 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  01af7	48 33 cc	 xor	 rcx, rsp
  01afa	e8 00 00 00 00	 call	 __security_check_cookie
  01aff	48 81 c4 18 04
	00 00		 add	 rsp, 1048		; 00000418H
  01b06	41 5f		 pop	 r15
  01b08	41 5e		 pop	 r14
  01b0a	5f		 pop	 rdi
  01b0b	5e		 pop	 rsi
  01b0c	5d		 pop	 rbp
  01b0d	5b		 pop	 rbx
  01b0e	c3		 ret	 0
CTCE_Trace ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\ctcadpt.c
_TEXT	SEGMENT
i$ = 0
XORChk$ = 4
pXOR$ = 8
pBuf$ = 32
BufLen$ = 40
CTCE_ChkSum PROC

; 3149 : {

  00000	66 89 54 24 10	 mov	 WORD PTR [rsp+16], dx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 18	 sub	 rsp, 24

; 3150 :     U32            i;
; 3151 :     U32            XORChk = 0;                   // XOR of buffer for checking

  0000e	c7 44 24 04 00
	00 00 00	 mov	 DWORD PTR XORChk$[rsp], 0

; 3152 :     BYTE          *pXOR = (BYTE*)&XORChk;        // -> XORChk

  00016	48 8d 44 24 04	 lea	 rax, QWORD PTR XORChk$[rsp]
  0001b	48 89 44 24 08	 mov	 QWORD PTR pXOR$[rsp], rax

; 3153 : 
; 3154 : 
; 3155 :     // We initialize the result with the buffer length so that
; 3156 :     // different length zero buffers yield a different checksum.
; 3157 :     XORChk = BufLen;

  00020	0f b7 44 24 28	 movzx	 eax, WORD PTR BufLen$[rsp]
  00025	89 44 24 04	 mov	 DWORD PTR XORChk$[rsp], eax

; 3158 :     for(i = 0; i < BufLen; i++)

  00029	c7 04 24 00 00
	00 00		 mov	 DWORD PTR i$[rsp], 0
  00030	eb 08		 jmp	 SHORT $LN4@CTCE_ChkSu
$LN2@CTCE_ChkSu:
  00032	8b 04 24	 mov	 eax, DWORD PTR i$[rsp]
  00035	ff c0		 inc	 eax
  00037	89 04 24	 mov	 DWORD PTR i$[rsp], eax
$LN4@CTCE_ChkSu:
  0003a	0f b7 44 24 28	 movzx	 eax, WORD PTR BufLen$[rsp]
  0003f	39 04 24	 cmp	 DWORD PTR i$[rsp], eax
  00042	73 53		 jae	 SHORT $LN3@CTCE_ChkSu

; 3159 :     {
; 3160 :         if( (i % 4) == 0 )

  00044	33 d2		 xor	 edx, edx
  00046	8b 04 24	 mov	 eax, DWORD PTR i$[rsp]
  00049	b9 04 00 00 00	 mov	 ecx, 4
  0004e	f7 f1		 div	 ecx
  00050	8b c2		 mov	 eax, edx
  00052	85 c0		 test	 eax, eax
  00054	75 0a		 jne	 SHORT $LN5@CTCE_ChkSu

; 3161 :         {
; 3162 :            pXOR = (BYTE*)&XORChk;

  00056	48 8d 44 24 04	 lea	 rax, QWORD PTR XORChk$[rsp]
  0005b	48 89 44 24 08	 mov	 QWORD PTR pXOR$[rsp], rax
$LN5@CTCE_ChkSu:

; 3163 :         }
; 3164 :         *pXOR++ ^= *pBuf++;

  00060	48 8b 44 24 20	 mov	 rax, QWORD PTR pBuf$[rsp]
  00065	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  00068	48 8b 4c 24 08	 mov	 rcx, QWORD PTR pXOR$[rsp]
  0006d	0f b6 09	 movzx	 ecx, BYTE PTR [rcx]
  00070	33 c8		 xor	 ecx, eax
  00072	8b c1		 mov	 eax, ecx
  00074	48 8b 4c 24 08	 mov	 rcx, QWORD PTR pXOR$[rsp]
  00079	88 01		 mov	 BYTE PTR [rcx], al
  0007b	48 8b 44 24 20	 mov	 rax, QWORD PTR pBuf$[rsp]
  00080	48 ff c0	 inc	 rax
  00083	48 89 44 24 20	 mov	 QWORD PTR pBuf$[rsp], rax
  00088	48 8b 44 24 08	 mov	 rax, QWORD PTR pXOR$[rsp]
  0008d	48 ff c0	 inc	 rax
  00090	48 89 44 24 08	 mov	 QWORD PTR pXOR$[rsp], rax

; 3165 :     }

  00095	eb 9b		 jmp	 SHORT $LN2@CTCE_ChkSu
$LN3@CTCE_ChkSu:

; 3166 :     return XORChk;

  00097	8b 44 24 04	 mov	 eax, DWORD PTR XORChk$[rsp]

; 3167 : 
; 3168 : } // CTCE_ChkSum

  0009b	48 83 c4 18	 add	 rsp, 24
  0009f	c3		 ret	 0
CTCE_ChkSum ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\ctcadpt.c
_TEXT	SEGMENT
UnitStat$ = 48
tv88 = 52
tv167 = 56
tv193 = 60
tv194 = 64
tv168 = 68
tv195 = 72
tv217 = 76
tv243 = 80
tv244 = 84
tv218 = 88
tv245 = 92
tv269 = 96
tv295 = 100
tv296 = 104
tv270 = 108
tv297 = 112
tv306 = 116
tv326 = 120
tv352 = 124
tv353 = 128
tv327 = 132
tv354 = 136
tv378 = 140
tv404 = 144
tv405 = 148
tv379 = 152
tv406 = 156
tv415 = 160
tv434 = 164
tv460 = 168
tv461 = 172
tv435 = 176
tv462 = 180
tv484 = 184
tv510 = 188
tv511 = 192
tv485 = 196
tv512 = 200
tv558 = 204
tv560 = 208
Residual$ = 212
tv552 = 216
CTCE_Info$ = 224
__$ArrayPad$ = 256
pDEVBLK$ = 288
CTCE_Reset PROC

; 3069 : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	57		 push	 rdi
  00006	48 81 ec 10 01
	00 00		 sub	 rsp, 272		; 00000110H
  0000d	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00014	48 33 c4	 xor	 rax, rsp
  00017	48 89 84 24 00
	01 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 3070 :     BYTE            UnitStat = 0;           // Only used as CTCE_Send needs it.

  0001f	c6 44 24 30 00	 mov	 BYTE PTR UnitStat$[rsp], 0

; 3071 :     CCWC            Residual = 0;           // Only used as CTCE_Send needs it.

  00024	c7 84 24 d4 00
	00 00 00 00 00
	00		 mov	 DWORD PTR Residual$[rsp], 0

; 3072 :     CTCE_INFO       CTCE_Info = { 0 };      // CTCE information (also for tracing)

  0002f	48 8d 84 24 e0
	00 00 00	 lea	 rax, QWORD PTR CTCE_Info$[rsp]
  00037	48 8b f8	 mov	 rdi, rax
  0003a	33 c0		 xor	 eax, eax
  0003c	b9 20 00 00 00	 mov	 ecx, 32			; 00000020H
  00041	f3 aa		 rep stosb

; 3073 : 
; 3074 :     // The caller already did an obtain_lock( &pDEVBLK->lock ).
; 3075 : 
; 3076 :     // Initialise our CTCE_Info previous x- and y-states for CTCE_Trace.
; 3077 :     CTCE_Info.state_x_prev       = pDEVBLK->ctcexState;

  00043	48 8b 84 24 20
	01 00 00	 mov	 rax, QWORD PTR pDEVBLK$[rsp]
  0004b	0f b6 80 34 07
	00 00		 movzx	 eax, BYTE PTR [rax+1844]
  00052	88 84 24 e4 00
	00 00		 mov	 BYTE PTR CTCE_Info$[rsp+4], al

; 3078 :     CTCE_Info.state_y_prev       = pDEVBLK->ctceyState;

  00059	48 8b 84 24 20
	01 00 00	 mov	 rax, QWORD PTR pDEVBLK$[rsp]
  00061	0f b6 80 36 07
	00 00		 movzx	 eax, BYTE PTR [rax+1846]
  00068	88 84 24 e5 00
	00 00		 mov	 BYTE PTR CTCE_Info$[rsp+5], al

; 3079 : 
; 3080 :     // A system reset at power up initialisation must result in
; 3081 :     // sense byte 0 bit 4 set showing Intervention Required.
; 3082 :     if( pDEVBLK->ctce_system_reset )

  0006f	48 8b 84 24 20
	01 00 00	 mov	 rax, QWORD PTR pDEVBLK$[rsp]
  00077	8b 80 74 07 00
	00		 mov	 eax, DWORD PTR [rax+1908]
  0007d	c1 e8 04	 shr	 eax, 4
  00080	83 e0 01	 and	 eax, 1
  00083	85 c0		 test	 eax, eax
  00085	74 19		 je	 SHORT $LN2@CTCE_Reset

; 3083 :     {
; 3084 :         pDEVBLK->sense[0] = SENSE_IR;

  00087	b8 01 00 00 00	 mov	 eax, 1
  0008c	48 6b c0 00	 imul	 rax, rax, 0
  00090	48 8b 8c 24 20
	01 00 00	 mov	 rcx, QWORD PTR pDEVBLK$[rsp]
  00098	c6 84 01 64 03
	00 00 40	 mov	 BYTE PTR [rcx+rax+868], 64 ; 00000040H
$LN2@CTCE_Reset:

; 3085 :     }
; 3086 : 
; 3087 :     // Reset the y-command register to 0, clear any WEOF state,
; 3088 :     // and reset our (x-)side (only) to initial extended mode.
; 3089 :     pDEVBLK->ctceyCmd = bCode_reset;

  000a0	48 8b 84 24 20
	01 00 00	 mov	 rax, QWORD PTR pDEVBLK$[rsp]
  000a8	c6 80 37 07 00
	00 00		 mov	 BYTE PTR [rax+1847], 0

; 3090 :     CLR_CTCE_WEOF( pDEVBLK->ctcexState );

  000af	48 8b 84 24 20
	01 00 00	 mov	 rax, QWORD PTR pDEVBLK$[rsp]
  000b7	0f b6 80 34 07
	00 00		 movzx	 eax, BYTE PTR [rax+1844]
  000be	0f ba f0 07	 btr	 eax, 7
  000c2	48 8b 8c 24 20
	01 00 00	 mov	 rcx, QWORD PTR pDEVBLK$[rsp]
  000ca	88 81 34 07 00
	00		 mov	 BYTE PTR [rcx+1844], al

; 3091 :     pDEVBLK->ctcxmode = (*(pDEVBLK->devid+6) == 0x00 ) ? 1 : 0 ;

  000d0	48 8b 84 24 20
	01 00 00	 mov	 rax, QWORD PTR pDEVBLK$[rsp]
  000d8	0f b6 80 6e 04
	00 00		 movzx	 eax, BYTE PTR [rax+1134]
  000df	85 c0		 test	 eax, eax
  000e1	75 0a		 jne	 SHORT $LN9@CTCE_Reset
  000e3	c7 44 24 34 01
	00 00 00	 mov	 DWORD PTR tv88[rsp], 1
  000eb	eb 08		 jmp	 SHORT $LN10@CTCE_Reset
$LN9@CTCE_Reset:
  000ed	c7 44 24 34 00
	00 00 00	 mov	 DWORD PTR tv88[rsp], 0
$LN10@CTCE_Reset:
  000f5	8b 44 24 34	 mov	 eax, DWORD PTR tv88[rsp]
  000f9	83 e0 01	 and	 eax, 1
  000fc	48 8b 8c 24 20
	01 00 00	 mov	 rcx, QWORD PTR pDEVBLK$[rsp]
  00104	8b 89 18 07 00
	00		 mov	 ecx, DWORD PTR [rcx+1816]
  0010a	83 e1 fe	 and	 ecx, -2			; fffffffeH
  0010d	0b c8		 or	 ecx, eax
  0010f	8b c1		 mov	 eax, ecx
  00111	48 8b 8c 24 20
	01 00 00	 mov	 rcx, QWORD PTR pDEVBLK$[rsp]
  00119	89 81 18 07 00
	00		 mov	 DWORD PTR [rcx+1816], eax

; 3092 : 
; 3093 :     // We cancel any Working(D) wait state at our (x-)side.
; 3094 :     if( IS_CTCE_YWK( pDEVBLK->ctcexState ) )

  0011f	48 8b 84 24 20
	01 00 00	 mov	 rax, QWORD PTR pDEVBLK$[rsp]
  00127	0f b6 80 34 07
	00 00		 movzx	 eax, BYTE PTR [rax+1844]
  0012e	83 e0 04	 and	 eax, 4
  00131	85 c0		 test	 eax, eax
  00133	75 69		 jne	 SHORT $LN3@CTCE_Reset

; 3095 :     {
; 3096 :         obtain_lock( &pDEVBLK->ctceEventLock );

  00135	48 8b 84 24 20
	01 00 00	 mov	 rax, QWORD PTR pDEVBLK$[rsp]
  0013d	48 05 40 07 00
	00		 add	 rax, 1856		; 00000740H
  00143	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG170183
  0014a	48 8b c8	 mov	 rcx, rax
  0014d	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_obtain_lock

; 3097 :         signal_condition( &pDEVBLK->ctceEvent );

  00153	48 8b 84 24 20
	01 00 00	 mov	 rax, QWORD PTR pDEVBLK$[rsp]
  0015b	48 05 48 07 00
	00		 add	 rax, 1864		; 00000748H
  00161	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG170184
  00168	48 8b c8	 mov	 rcx, rax
  0016b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_signal_condition

; 3098 :         release_lock( &pDEVBLK->ctceEventLock );

  00171	48 8b 84 24 20
	01 00 00	 mov	 rax, QWORD PTR pDEVBLK$[rsp]
  00179	48 05 40 07 00
	00		 add	 rax, 1856		; 00000740H
  0017f	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG170185
  00186	48 8b c8	 mov	 rcx, rax
  00189	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_release_lock

; 3099 : 
; 3100 :         pDEVBLK->ctce_UnitStat = CSW_CE | CSW_DE;

  0018f	48 8b 84 24 20
	01 00 00	 mov	 rax, QWORD PTR pDEVBLK$[rsp]
  00197	c6 80 39 07 00
	00 0c		 mov	 BYTE PTR [rax+1849], 12
$LN3@CTCE_Reset:

; 3101 :     }
; 3102 :     if( IS_CTCE_YWK( pDEVBLK->ctceyState ) )

  0019e	48 8b 84 24 20
	01 00 00	 mov	 rax, QWORD PTR pDEVBLK$[rsp]
  001a6	0f b6 80 36 07
	00 00		 movzx	 eax, BYTE PTR [rax+1846]
  001ad	83 e0 04	 and	 eax, 4
  001b0	85 c0		 test	 eax, eax
  001b2	75 25		 jne	 SHORT $LN4@CTCE_Reset

; 3103 :     {
; 3104 :         SET_CTCE_YAV( pDEVBLK->ctceyState );

  001b4	48 8b 84 24 20
	01 00 00	 mov	 rax, QWORD PTR pDEVBLK$[rsp]
  001bc	0f b6 80 36 07
	00 00		 movzx	 eax, BYTE PTR [rax+1846]
  001c3	25 f8 00 00 00	 and	 eax, 248		; 000000f8H
  001c8	83 c8 04	 or	 eax, 4
  001cb	48 8b 8c 24 20
	01 00 00	 mov	 rcx, QWORD PTR pDEVBLK$[rsp]
  001d3	88 81 36 07 00
	00		 mov	 BYTE PTR [rcx+1846], al
$LN4@CTCE_Reset:

; 3105 :     }
; 3106 : 
; 3107 :     // The CTCE_Reset is being signaled to our (x-)side as the result of
; 3108 :     // a Halt or Clear subchannel instruction.  We procees this using a
; 3109 :     // synthetic reset (RST) command, which is encdoded as CCW command 0x00
; 3110 :     // because that's what the y command register needs to be set to.  This 0x00
; 3111 :     // comamnd however would be an invalid "bCode" argument for CTCE_ExecuteCCW.
; 3112 :     // Our FSM table however caters for (part of) the work to be done :
; 3113 :     pDEVBLK->ctcexCmd = bCode_reset;

  001d9	48 8b 84 24 20
	01 00 00	 mov	 rax, QWORD PTR pDEVBLK$[rsp]
  001e1	c6 80 35 07 00
	00 00		 mov	 BYTE PTR [rax+1845], 0

; 3114 :     CTCE_Info.fsm         = CTCE_Fsm[CTCE_CMD( bCode_reset )][CTCE_X_STATE_FSM_IDX];

  001e8	48 8b 84 24 20
	01 00 00	 mov	 rax, QWORD PTR pDEVBLK$[rsp]
  001f0	8b 80 18 07 00
	00		 mov	 eax, DWORD PTR [rax+1816]
  001f6	83 e0 01	 and	 eax, 1
  001f9	85 c0		 test	 eax, eax
  001fb	75 5d		 jne	 SHORT $LN11@CTCE_Reset
  001fd	48 8b 84 24 20
	01 00 00	 mov	 rax, QWORD PTR pDEVBLK$[rsp]
  00205	8b 80 74 07 00
	00		 mov	 eax, DWORD PTR [rax+1908]
  0020b	c1 e8 03	 shr	 eax, 3
  0020e	83 e0 01	 and	 eax, 1
  00211	85 c0		 test	 eax, eax
  00213	75 45		 jne	 SHORT $LN11@CTCE_Reset
  00215	b8 01 00 00 00	 mov	 eax, 1
  0021a	48 6b c0 00	 imul	 rax, rax, 0
  0021e	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:CTCE_command
  00225	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00229	83 f8 07	 cmp	 eax, 7
  0022c	75 0a		 jne	 SHORT $LN12@CTCE_Reset
  0022e	c7 44 24 38 03
	00 00 00	 mov	 DWORD PTR tv167[rsp], 3
  00236	eb 18		 jmp	 SHORT $LN13@CTCE_Reset
$LN12@CTCE_Reset:
  00238	b8 01 00 00 00	 mov	 eax, 1
  0023d	48 6b c0 00	 imul	 rax, rax, 0
  00241	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:CTCE_command
  00248	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  0024c	89 44 24 38	 mov	 DWORD PTR tv167[rsp], eax
$LN13@CTCE_Reset:
  00250	8b 44 24 38	 mov	 eax, DWORD PTR tv167[rsp]
  00254	89 44 24 44	 mov	 DWORD PTR tv168[rsp], eax
  00258	eb 18		 jmp	 SHORT $LN14@CTCE_Reset
$LN11@CTCE_Reset:
  0025a	b8 01 00 00 00	 mov	 eax, 1
  0025f	48 6b c0 00	 imul	 rax, rax, 0
  00263	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:CTCE_command
  0026a	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  0026e	89 44 24 44	 mov	 DWORD PTR tv168[rsp], eax
$LN14@CTCE_Reset:
  00272	48 8b 84 24 20
	01 00 00	 mov	 rax, QWORD PTR pDEVBLK$[rsp]
  0027a	0f b6 80 34 07
	00 00		 movzx	 eax, BYTE PTR [rax+1844]
  00281	83 e0 04	 and	 eax, 4
  00284	85 c0		 test	 eax, eax
  00286	75 0d		 jne	 SHORT $LN19@CTCE_Reset
  00288	c7 44 24 48 06
	00 00 00	 mov	 DWORD PTR tv195[rsp], 6
  00290	e9 8c 00 00 00	 jmp	 $LN20@CTCE_Reset
$LN19@CTCE_Reset:
  00295	48 8b 84 24 20
	01 00 00	 mov	 rax, QWORD PTR pDEVBLK$[rsp]
  0029d	8b 80 18 07 00
	00		 mov	 eax, DWORD PTR [rax+1816]
  002a3	83 e0 01	 and	 eax, 1
  002a6	85 c0		 test	 eax, eax
  002a8	75 59		 jne	 SHORT $LN15@CTCE_Reset
  002aa	48 8b 84 24 20
	01 00 00	 mov	 rax, QWORD PTR pDEVBLK$[rsp]
  002b2	8b 80 74 07 00
	00		 mov	 eax, DWORD PTR [rax+1908]
  002b8	c1 e8 03	 shr	 eax, 3
  002bb	83 e0 01	 and	 eax, 1
  002be	85 c0		 test	 eax, eax
  002c0	75 41		 jne	 SHORT $LN15@CTCE_Reset
  002c2	48 8b 84 24 20
	01 00 00	 mov	 rax, QWORD PTR pDEVBLK$[rsp]
  002ca	0f b6 80 36 07
	00 00		 movzx	 eax, BYTE PTR [rax+1846]
  002d1	83 e0 07	 and	 eax, 7
  002d4	83 f8 05	 cmp	 eax, 5
  002d7	75 0a		 jne	 SHORT $LN16@CTCE_Reset
  002d9	c7 44 24 3c 04
	00 00 00	 mov	 DWORD PTR tv193[rsp], 4
  002e1	eb 16		 jmp	 SHORT $LN17@CTCE_Reset
$LN16@CTCE_Reset:
  002e3	48 8b 84 24 20
	01 00 00	 mov	 rax, QWORD PTR pDEVBLK$[rsp]
  002eb	0f b6 80 36 07
	00 00		 movzx	 eax, BYTE PTR [rax+1846]
  002f2	83 e0 07	 and	 eax, 7
  002f5	89 44 24 3c	 mov	 DWORD PTR tv193[rsp], eax
$LN17@CTCE_Reset:
  002f9	8b 44 24 3c	 mov	 eax, DWORD PTR tv193[rsp]
  002fd	89 44 24 40	 mov	 DWORD PTR tv194[rsp], eax
  00301	eb 16		 jmp	 SHORT $LN18@CTCE_Reset
$LN15@CTCE_Reset:
  00303	48 8b 84 24 20
	01 00 00	 mov	 rax, QWORD PTR pDEVBLK$[rsp]
  0030b	0f b6 80 36 07
	00 00		 movzx	 eax, BYTE PTR [rax+1846]
  00312	83 e0 07	 and	 eax, 7
  00315	89 44 24 40	 mov	 DWORD PTR tv194[rsp], eax
$LN18@CTCE_Reset:
  00319	8b 44 24 40	 mov	 eax, DWORD PTR tv194[rsp]
  0031d	89 44 24 48	 mov	 DWORD PTR tv195[rsp], eax
$LN20@CTCE_Reset:
  00321	48 63 44 24 44	 movsxd	 rax, DWORD PTR tv168[rsp]
  00326	48 6b c0 20	 imul	 rax, rax, 32		; 00000020H
  0032a	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:CTCE_Fsm
  00331	48 03 c8	 add	 rcx, rax
  00334	48 8b c1	 mov	 rax, rcx
  00337	48 63 4c 24 48	 movsxd	 rcx, DWORD PTR tv195[rsp]
  0033c	8b 04 88	 mov	 eax, DWORD PTR [rax+rcx*4]
  0033f	89 84 24 e0 00
	00 00		 mov	 DWORD PTR CTCE_Info$[rsp], eax

; 3115 : 
; 3116 :     CTCE_Info.state_new   = CTCE_NEW_X_STATE(  bCode_reset ); /* Silly : only need for CTCE_Trace MISMATCH avoidance */

  00346	48 8b 84 24 20
	01 00 00	 mov	 rax, QWORD PTR pDEVBLK$[rsp]
  0034e	8b 80 18 07 00
	00		 mov	 eax, DWORD PTR [rax+1816]
  00354	83 e0 01	 and	 eax, 1
  00357	85 c0		 test	 eax, eax
  00359	75 5d		 jne	 SHORT $LN21@CTCE_Reset
  0035b	48 8b 84 24 20
	01 00 00	 mov	 rax, QWORD PTR pDEVBLK$[rsp]
  00363	8b 80 74 07 00
	00		 mov	 eax, DWORD PTR [rax+1908]
  00369	c1 e8 03	 shr	 eax, 3
  0036c	83 e0 01	 and	 eax, 1
  0036f	85 c0		 test	 eax, eax
  00371	75 45		 jne	 SHORT $LN21@CTCE_Reset
  00373	b8 01 00 00 00	 mov	 eax, 1
  00378	48 6b c0 00	 imul	 rax, rax, 0
  0037c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:CTCE_command
  00383	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00387	83 f8 07	 cmp	 eax, 7
  0038a	75 0a		 jne	 SHORT $LN22@CTCE_Reset
  0038c	c7 44 24 4c 03
	00 00 00	 mov	 DWORD PTR tv217[rsp], 3
  00394	eb 18		 jmp	 SHORT $LN23@CTCE_Reset
$LN22@CTCE_Reset:
  00396	b8 01 00 00 00	 mov	 eax, 1
  0039b	48 6b c0 00	 imul	 rax, rax, 0
  0039f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:CTCE_command
  003a6	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  003aa	89 44 24 4c	 mov	 DWORD PTR tv217[rsp], eax
$LN23@CTCE_Reset:
  003ae	8b 44 24 4c	 mov	 eax, DWORD PTR tv217[rsp]
  003b2	89 44 24 58	 mov	 DWORD PTR tv218[rsp], eax
  003b6	eb 18		 jmp	 SHORT $LN24@CTCE_Reset
$LN21@CTCE_Reset:
  003b8	b8 01 00 00 00	 mov	 eax, 1
  003bd	48 6b c0 00	 imul	 rax, rax, 0
  003c1	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:CTCE_command
  003c8	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  003cc	89 44 24 58	 mov	 DWORD PTR tv218[rsp], eax
$LN24@CTCE_Reset:
  003d0	48 8b 84 24 20
	01 00 00	 mov	 rax, QWORD PTR pDEVBLK$[rsp]
  003d8	0f b6 80 34 07
	00 00		 movzx	 eax, BYTE PTR [rax+1844]
  003df	83 e0 04	 and	 eax, 4
  003e2	85 c0		 test	 eax, eax
  003e4	75 0d		 jne	 SHORT $LN29@CTCE_Reset
  003e6	c7 44 24 5c 06
	00 00 00	 mov	 DWORD PTR tv245[rsp], 6
  003ee	e9 8c 00 00 00	 jmp	 $LN30@CTCE_Reset
$LN29@CTCE_Reset:
  003f3	48 8b 84 24 20
	01 00 00	 mov	 rax, QWORD PTR pDEVBLK$[rsp]
  003fb	8b 80 18 07 00
	00		 mov	 eax, DWORD PTR [rax+1816]
  00401	83 e0 01	 and	 eax, 1
  00404	85 c0		 test	 eax, eax
  00406	75 59		 jne	 SHORT $LN25@CTCE_Reset
  00408	48 8b 84 24 20
	01 00 00	 mov	 rax, QWORD PTR pDEVBLK$[rsp]
  00410	8b 80 74 07 00
	00		 mov	 eax, DWORD PTR [rax+1908]
  00416	c1 e8 03	 shr	 eax, 3
  00419	83 e0 01	 and	 eax, 1
  0041c	85 c0		 test	 eax, eax
  0041e	75 41		 jne	 SHORT $LN25@CTCE_Reset
  00420	48 8b 84 24 20
	01 00 00	 mov	 rax, QWORD PTR pDEVBLK$[rsp]
  00428	0f b6 80 36 07
	00 00		 movzx	 eax, BYTE PTR [rax+1846]
  0042f	83 e0 07	 and	 eax, 7
  00432	83 f8 05	 cmp	 eax, 5
  00435	75 0a		 jne	 SHORT $LN26@CTCE_Reset
  00437	c7 44 24 50 04
	00 00 00	 mov	 DWORD PTR tv243[rsp], 4
  0043f	eb 16		 jmp	 SHORT $LN27@CTCE_Reset
$LN26@CTCE_Reset:
  00441	48 8b 84 24 20
	01 00 00	 mov	 rax, QWORD PTR pDEVBLK$[rsp]
  00449	0f b6 80 36 07
	00 00		 movzx	 eax, BYTE PTR [rax+1846]
  00450	83 e0 07	 and	 eax, 7
  00453	89 44 24 50	 mov	 DWORD PTR tv243[rsp], eax
$LN27@CTCE_Reset:
  00457	8b 44 24 50	 mov	 eax, DWORD PTR tv243[rsp]
  0045b	89 44 24 54	 mov	 DWORD PTR tv244[rsp], eax
  0045f	eb 16		 jmp	 SHORT $LN28@CTCE_Reset
$LN25@CTCE_Reset:
  00461	48 8b 84 24 20
	01 00 00	 mov	 rax, QWORD PTR pDEVBLK$[rsp]
  00469	0f b6 80 36 07
	00 00		 movzx	 eax, BYTE PTR [rax+1846]
  00470	83 e0 07	 and	 eax, 7
  00473	89 44 24 54	 mov	 DWORD PTR tv244[rsp], eax
$LN28@CTCE_Reset:
  00477	8b 44 24 54	 mov	 eax, DWORD PTR tv244[rsp]
  0047b	89 44 24 5c	 mov	 DWORD PTR tv245[rsp], eax
$LN30@CTCE_Reset:
  0047f	48 63 44 24 58	 movsxd	 rax, DWORD PTR tv218[rsp]
  00484	48 6b c0 20	 imul	 rax, rax, 32		; 00000020H
  00488	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:CTCE_Fsm
  0048f	48 03 c8	 add	 rcx, rax
  00492	48 8b c1	 mov	 rax, rcx
  00495	48 63 4c 24 5c	 movsxd	 rcx, DWORD PTR tv245[rsp]
  0049a	0f b6 04 88	 movzx	 eax, BYTE PTR [rax+rcx*4]
  0049e	3d ff 00 00 00	 cmp	 eax, 255		; 000000ffH
  004a3	0f 84 5e 01 00
	00		 je	 $LN41@CTCE_Reset
  004a9	48 8b 84 24 20
	01 00 00	 mov	 rax, QWORD PTR pDEVBLK$[rsp]
  004b1	8b 80 18 07 00
	00		 mov	 eax, DWORD PTR [rax+1816]
  004b7	83 e0 01	 and	 eax, 1
  004ba	85 c0		 test	 eax, eax
  004bc	75 5d		 jne	 SHORT $LN31@CTCE_Reset
  004be	48 8b 84 24 20
	01 00 00	 mov	 rax, QWORD PTR pDEVBLK$[rsp]
  004c6	8b 80 74 07 00
	00		 mov	 eax, DWORD PTR [rax+1908]
  004cc	c1 e8 03	 shr	 eax, 3
  004cf	83 e0 01	 and	 eax, 1
  004d2	85 c0		 test	 eax, eax
  004d4	75 45		 jne	 SHORT $LN31@CTCE_Reset
  004d6	b8 01 00 00 00	 mov	 eax, 1
  004db	48 6b c0 00	 imul	 rax, rax, 0
  004df	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:CTCE_command
  004e6	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  004ea	83 f8 07	 cmp	 eax, 7
  004ed	75 0a		 jne	 SHORT $LN32@CTCE_Reset
  004ef	c7 44 24 60 03
	00 00 00	 mov	 DWORD PTR tv269[rsp], 3
  004f7	eb 18		 jmp	 SHORT $LN33@CTCE_Reset
$LN32@CTCE_Reset:
  004f9	b8 01 00 00 00	 mov	 eax, 1
  004fe	48 6b c0 00	 imul	 rax, rax, 0
  00502	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:CTCE_command
  00509	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  0050d	89 44 24 60	 mov	 DWORD PTR tv269[rsp], eax
$LN33@CTCE_Reset:
  00511	8b 44 24 60	 mov	 eax, DWORD PTR tv269[rsp]
  00515	89 44 24 6c	 mov	 DWORD PTR tv270[rsp], eax
  00519	eb 18		 jmp	 SHORT $LN34@CTCE_Reset
$LN31@CTCE_Reset:
  0051b	b8 01 00 00 00	 mov	 eax, 1
  00520	48 6b c0 00	 imul	 rax, rax, 0
  00524	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:CTCE_command
  0052b	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  0052f	89 44 24 6c	 mov	 DWORD PTR tv270[rsp], eax
$LN34@CTCE_Reset:
  00533	48 8b 84 24 20
	01 00 00	 mov	 rax, QWORD PTR pDEVBLK$[rsp]
  0053b	0f b6 80 34 07
	00 00		 movzx	 eax, BYTE PTR [rax+1844]
  00542	83 e0 04	 and	 eax, 4
  00545	85 c0		 test	 eax, eax
  00547	75 0d		 jne	 SHORT $LN39@CTCE_Reset
  00549	c7 44 24 70 06
	00 00 00	 mov	 DWORD PTR tv297[rsp], 6
  00551	e9 8c 00 00 00	 jmp	 $LN40@CTCE_Reset
$LN39@CTCE_Reset:
  00556	48 8b 84 24 20
	01 00 00	 mov	 rax, QWORD PTR pDEVBLK$[rsp]
  0055e	8b 80 18 07 00
	00		 mov	 eax, DWORD PTR [rax+1816]
  00564	83 e0 01	 and	 eax, 1
  00567	85 c0		 test	 eax, eax
  00569	75 59		 jne	 SHORT $LN35@CTCE_Reset
  0056b	48 8b 84 24 20
	01 00 00	 mov	 rax, QWORD PTR pDEVBLK$[rsp]
  00573	8b 80 74 07 00
	00		 mov	 eax, DWORD PTR [rax+1908]
  00579	c1 e8 03	 shr	 eax, 3
  0057c	83 e0 01	 and	 eax, 1
  0057f	85 c0		 test	 eax, eax
  00581	75 41		 jne	 SHORT $LN35@CTCE_Reset
  00583	48 8b 84 24 20
	01 00 00	 mov	 rax, QWORD PTR pDEVBLK$[rsp]
  0058b	0f b6 80 36 07
	00 00		 movzx	 eax, BYTE PTR [rax+1846]
  00592	83 e0 07	 and	 eax, 7
  00595	83 f8 05	 cmp	 eax, 5
  00598	75 0a		 jne	 SHORT $LN36@CTCE_Reset
  0059a	c7 44 24 64 04
	00 00 00	 mov	 DWORD PTR tv295[rsp], 4
  005a2	eb 16		 jmp	 SHORT $LN37@CTCE_Reset
$LN36@CTCE_Reset:
  005a4	48 8b 84 24 20
	01 00 00	 mov	 rax, QWORD PTR pDEVBLK$[rsp]
  005ac	0f b6 80 36 07
	00 00		 movzx	 eax, BYTE PTR [rax+1846]
  005b3	83 e0 07	 and	 eax, 7
  005b6	89 44 24 64	 mov	 DWORD PTR tv295[rsp], eax
$LN37@CTCE_Reset:
  005ba	8b 44 24 64	 mov	 eax, DWORD PTR tv295[rsp]
  005be	89 44 24 68	 mov	 DWORD PTR tv296[rsp], eax
  005c2	eb 16		 jmp	 SHORT $LN38@CTCE_Reset
$LN35@CTCE_Reset:
  005c4	48 8b 84 24 20
	01 00 00	 mov	 rax, QWORD PTR pDEVBLK$[rsp]
  005cc	0f b6 80 36 07
	00 00		 movzx	 eax, BYTE PTR [rax+1846]
  005d3	83 e0 07	 and	 eax, 7
  005d6	89 44 24 68	 mov	 DWORD PTR tv296[rsp], eax
$LN38@CTCE_Reset:
  005da	8b 44 24 68	 mov	 eax, DWORD PTR tv296[rsp]
  005de	89 44 24 70	 mov	 DWORD PTR tv297[rsp], eax
$LN40@CTCE_Reset:
  005e2	48 63 44 24 6c	 movsxd	 rax, DWORD PTR tv270[rsp]
  005e7	48 6b c0 20	 imul	 rax, rax, 32		; 00000020H
  005eb	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:CTCE_Fsm
  005f2	48 03 c8	 add	 rcx, rax
  005f5	48 8b c1	 mov	 rax, rcx
  005f8	48 63 4c 24 70	 movsxd	 rcx, DWORD PTR tv297[rsp]
  005fd	0f b6 04 88	 movzx	 eax, BYTE PTR [rax+rcx*4]
  00601	89 44 24 74	 mov	 DWORD PTR tv306[rsp], eax
  00605	eb 16		 jmp	 SHORT $LN42@CTCE_Reset
$LN41@CTCE_Reset:
  00607	48 8b 84 24 20
	01 00 00	 mov	 rax, QWORD PTR pDEVBLK$[rsp]
  0060f	0f b6 80 34 07
	00 00		 movzx	 eax, BYTE PTR [rax+1844]
  00616	83 e0 07	 and	 eax, 7
  00619	89 44 24 74	 mov	 DWORD PTR tv306[rsp], eax
$LN42@CTCE_Reset:
  0061d	0f b6 44 24 74	 movzx	 eax, BYTE PTR tv306[rsp]
  00622	88 84 24 e7 00
	00 00		 mov	 BYTE PTR CTCE_Info$[rsp+7], al

; 3117 :     pDEVBLK->ctcexState   = CTCE_NEW_X_STATE(  bCode_reset );

  00629	48 8b 84 24 20
	01 00 00	 mov	 rax, QWORD PTR pDEVBLK$[rsp]
  00631	8b 80 18 07 00
	00		 mov	 eax, DWORD PTR [rax+1816]
  00637	83 e0 01	 and	 eax, 1
  0063a	85 c0		 test	 eax, eax
  0063c	75 60		 jne	 SHORT $LN43@CTCE_Reset
  0063e	48 8b 84 24 20
	01 00 00	 mov	 rax, QWORD PTR pDEVBLK$[rsp]
  00646	8b 80 74 07 00
	00		 mov	 eax, DWORD PTR [rax+1908]
  0064c	c1 e8 03	 shr	 eax, 3
  0064f	83 e0 01	 and	 eax, 1
  00652	85 c0		 test	 eax, eax
  00654	75 48		 jne	 SHORT $LN43@CTCE_Reset
  00656	b8 01 00 00 00	 mov	 eax, 1
  0065b	48 6b c0 00	 imul	 rax, rax, 0
  0065f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:CTCE_command
  00666	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  0066a	83 f8 07	 cmp	 eax, 7
  0066d	75 0a		 jne	 SHORT $LN44@CTCE_Reset
  0066f	c7 44 24 78 03
	00 00 00	 mov	 DWORD PTR tv326[rsp], 3
  00677	eb 18		 jmp	 SHORT $LN45@CTCE_Reset
$LN44@CTCE_Reset:
  00679	b8 01 00 00 00	 mov	 eax, 1
  0067e	48 6b c0 00	 imul	 rax, rax, 0
  00682	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:CTCE_command
  00689	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  0068d	89 44 24 78	 mov	 DWORD PTR tv326[rsp], eax
$LN45@CTCE_Reset:
  00691	8b 44 24 78	 mov	 eax, DWORD PTR tv326[rsp]
  00695	89 84 24 84 00
	00 00		 mov	 DWORD PTR tv327[rsp], eax
  0069c	eb 1b		 jmp	 SHORT $LN46@CTCE_Reset
$LN43@CTCE_Reset:
  0069e	b8 01 00 00 00	 mov	 eax, 1
  006a3	48 6b c0 00	 imul	 rax, rax, 0
  006a7	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:CTCE_command
  006ae	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  006b2	89 84 24 84 00
	00 00		 mov	 DWORD PTR tv327[rsp], eax
$LN46@CTCE_Reset:
  006b9	48 8b 84 24 20
	01 00 00	 mov	 rax, QWORD PTR pDEVBLK$[rsp]
  006c1	0f b6 80 34 07
	00 00		 movzx	 eax, BYTE PTR [rax+1844]
  006c8	83 e0 04	 and	 eax, 4
  006cb	85 c0		 test	 eax, eax
  006cd	75 10		 jne	 SHORT $LN51@CTCE_Reset
  006cf	c7 84 24 88 00
	00 00 06 00 00
	00		 mov	 DWORD PTR tv354[rsp], 6
  006da	e9 98 00 00 00	 jmp	 $LN52@CTCE_Reset
$LN51@CTCE_Reset:
  006df	48 8b 84 24 20
	01 00 00	 mov	 rax, QWORD PTR pDEVBLK$[rsp]
  006e7	8b 80 18 07 00
	00		 mov	 eax, DWORD PTR [rax+1816]
  006ed	83 e0 01	 and	 eax, 1
  006f0	85 c0		 test	 eax, eax
  006f2	75 5c		 jne	 SHORT $LN47@CTCE_Reset
  006f4	48 8b 84 24 20
	01 00 00	 mov	 rax, QWORD PTR pDEVBLK$[rsp]
  006fc	8b 80 74 07 00
	00		 mov	 eax, DWORD PTR [rax+1908]
  00702	c1 e8 03	 shr	 eax, 3
  00705	83 e0 01	 and	 eax, 1
  00708	85 c0		 test	 eax, eax
  0070a	75 44		 jne	 SHORT $LN47@CTCE_Reset
  0070c	48 8b 84 24 20
	01 00 00	 mov	 rax, QWORD PTR pDEVBLK$[rsp]
  00714	0f b6 80 36 07
	00 00		 movzx	 eax, BYTE PTR [rax+1846]
  0071b	83 e0 07	 and	 eax, 7
  0071e	83 f8 05	 cmp	 eax, 5
  00721	75 0a		 jne	 SHORT $LN48@CTCE_Reset
  00723	c7 44 24 7c 04
	00 00 00	 mov	 DWORD PTR tv352[rsp], 4
  0072b	eb 16		 jmp	 SHORT $LN49@CTCE_Reset
$LN48@CTCE_Reset:
  0072d	48 8b 84 24 20
	01 00 00	 mov	 rax, QWORD PTR pDEVBLK$[rsp]
  00735	0f b6 80 36 07
	00 00		 movzx	 eax, BYTE PTR [rax+1846]
  0073c	83 e0 07	 and	 eax, 7
  0073f	89 44 24 7c	 mov	 DWORD PTR tv352[rsp], eax
$LN49@CTCE_Reset:
  00743	8b 44 24 7c	 mov	 eax, DWORD PTR tv352[rsp]
  00747	89 84 24 80 00
	00 00		 mov	 DWORD PTR tv353[rsp], eax
  0074e	eb 19		 jmp	 SHORT $LN50@CTCE_Reset
$LN47@CTCE_Reset:
  00750	48 8b 84 24 20
	01 00 00	 mov	 rax, QWORD PTR pDEVBLK$[rsp]
  00758	0f b6 80 36 07
	00 00		 movzx	 eax, BYTE PTR [rax+1846]
  0075f	83 e0 07	 and	 eax, 7
  00762	89 84 24 80 00
	00 00		 mov	 DWORD PTR tv353[rsp], eax
$LN50@CTCE_Reset:
  00769	8b 84 24 80 00
	00 00		 mov	 eax, DWORD PTR tv353[rsp]
  00770	89 84 24 88 00
	00 00		 mov	 DWORD PTR tv354[rsp], eax
$LN52@CTCE_Reset:
  00777	48 63 84 24 84
	00 00 00	 movsxd	 rax, DWORD PTR tv327[rsp]
  0077f	48 6b c0 20	 imul	 rax, rax, 32		; 00000020H
  00783	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:CTCE_Fsm
  0078a	48 03 c8	 add	 rcx, rax
  0078d	48 8b c1	 mov	 rax, rcx
  00790	48 63 8c 24 88
	00 00 00	 movsxd	 rcx, DWORD PTR tv354[rsp]
  00798	0f b6 04 88	 movzx	 eax, BYTE PTR [rax+rcx*4]
  0079c	3d ff 00 00 00	 cmp	 eax, 255		; 000000ffH
  007a1	0f 84 8e 01 00
	00		 je	 $LN63@CTCE_Reset
  007a7	48 8b 84 24 20
	01 00 00	 mov	 rax, QWORD PTR pDEVBLK$[rsp]
  007af	8b 80 18 07 00
	00		 mov	 eax, DWORD PTR [rax+1816]
  007b5	83 e0 01	 and	 eax, 1
  007b8	85 c0		 test	 eax, eax
  007ba	75 69		 jne	 SHORT $LN53@CTCE_Reset
  007bc	48 8b 84 24 20
	01 00 00	 mov	 rax, QWORD PTR pDEVBLK$[rsp]
  007c4	8b 80 74 07 00
	00		 mov	 eax, DWORD PTR [rax+1908]
  007ca	c1 e8 03	 shr	 eax, 3
  007cd	83 e0 01	 and	 eax, 1
  007d0	85 c0		 test	 eax, eax
  007d2	75 51		 jne	 SHORT $LN53@CTCE_Reset
  007d4	b8 01 00 00 00	 mov	 eax, 1
  007d9	48 6b c0 00	 imul	 rax, rax, 0
  007dd	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:CTCE_command
  007e4	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  007e8	83 f8 07	 cmp	 eax, 7
  007eb	75 0d		 jne	 SHORT $LN54@CTCE_Reset
  007ed	c7 84 24 8c 00
	00 00 03 00 00
	00		 mov	 DWORD PTR tv378[rsp], 3
  007f8	eb 1b		 jmp	 SHORT $LN55@CTCE_Reset
$LN54@CTCE_Reset:
  007fa	b8 01 00 00 00	 mov	 eax, 1
  007ff	48 6b c0 00	 imul	 rax, rax, 0
  00803	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:CTCE_command
  0080a	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  0080e	89 84 24 8c 00
	00 00		 mov	 DWORD PTR tv378[rsp], eax
$LN55@CTCE_Reset:
  00815	8b 84 24 8c 00
	00 00		 mov	 eax, DWORD PTR tv378[rsp]
  0081c	89 84 24 98 00
	00 00		 mov	 DWORD PTR tv379[rsp], eax
  00823	eb 1b		 jmp	 SHORT $LN56@CTCE_Reset
$LN53@CTCE_Reset:
  00825	b8 01 00 00 00	 mov	 eax, 1
  0082a	48 6b c0 00	 imul	 rax, rax, 0
  0082e	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:CTCE_command
  00835	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00839	89 84 24 98 00
	00 00		 mov	 DWORD PTR tv379[rsp], eax
$LN56@CTCE_Reset:
  00840	48 8b 84 24 20
	01 00 00	 mov	 rax, QWORD PTR pDEVBLK$[rsp]
  00848	0f b6 80 34 07
	00 00		 movzx	 eax, BYTE PTR [rax+1844]
  0084f	83 e0 04	 and	 eax, 4
  00852	85 c0		 test	 eax, eax
  00854	75 10		 jne	 SHORT $LN61@CTCE_Reset
  00856	c7 84 24 9c 00
	00 00 06 00 00
	00		 mov	 DWORD PTR tv406[rsp], 6
  00861	e9 a1 00 00 00	 jmp	 $LN62@CTCE_Reset
$LN61@CTCE_Reset:
  00866	48 8b 84 24 20
	01 00 00	 mov	 rax, QWORD PTR pDEVBLK$[rsp]
  0086e	8b 80 18 07 00
	00		 mov	 eax, DWORD PTR [rax+1816]
  00874	83 e0 01	 and	 eax, 1
  00877	85 c0		 test	 eax, eax
  00879	75 65		 jne	 SHORT $LN57@CTCE_Reset
  0087b	48 8b 84 24 20
	01 00 00	 mov	 rax, QWORD PTR pDEVBLK$[rsp]
  00883	8b 80 74 07 00
	00		 mov	 eax, DWORD PTR [rax+1908]
  00889	c1 e8 03	 shr	 eax, 3
  0088c	83 e0 01	 and	 eax, 1
  0088f	85 c0		 test	 eax, eax
  00891	75 4d		 jne	 SHORT $LN57@CTCE_Reset
  00893	48 8b 84 24 20
	01 00 00	 mov	 rax, QWORD PTR pDEVBLK$[rsp]
  0089b	0f b6 80 36 07
	00 00		 movzx	 eax, BYTE PTR [rax+1846]
  008a2	83 e0 07	 and	 eax, 7
  008a5	83 f8 05	 cmp	 eax, 5
  008a8	75 0d		 jne	 SHORT $LN58@CTCE_Reset
  008aa	c7 84 24 90 00
	00 00 04 00 00
	00		 mov	 DWORD PTR tv404[rsp], 4
  008b5	eb 19		 jmp	 SHORT $LN59@CTCE_Reset
$LN58@CTCE_Reset:
  008b7	48 8b 84 24 20
	01 00 00	 mov	 rax, QWORD PTR pDEVBLK$[rsp]
  008bf	0f b6 80 36 07
	00 00		 movzx	 eax, BYTE PTR [rax+1846]
  008c6	83 e0 07	 and	 eax, 7
  008c9	89 84 24 90 00
	00 00		 mov	 DWORD PTR tv404[rsp], eax
$LN59@CTCE_Reset:
  008d0	8b 84 24 90 00
	00 00		 mov	 eax, DWORD PTR tv404[rsp]
  008d7	89 84 24 94 00
	00 00		 mov	 DWORD PTR tv405[rsp], eax
  008de	eb 19		 jmp	 SHORT $LN60@CTCE_Reset
$LN57@CTCE_Reset:
  008e0	48 8b 84 24 20
	01 00 00	 mov	 rax, QWORD PTR pDEVBLK$[rsp]
  008e8	0f b6 80 36 07
	00 00		 movzx	 eax, BYTE PTR [rax+1846]
  008ef	83 e0 07	 and	 eax, 7
  008f2	89 84 24 94 00
	00 00		 mov	 DWORD PTR tv405[rsp], eax
$LN60@CTCE_Reset:
  008f9	8b 84 24 94 00
	00 00		 mov	 eax, DWORD PTR tv405[rsp]
  00900	89 84 24 9c 00
	00 00		 mov	 DWORD PTR tv406[rsp], eax
$LN62@CTCE_Reset:
  00907	48 63 84 24 98
	00 00 00	 movsxd	 rax, DWORD PTR tv379[rsp]
  0090f	48 6b c0 20	 imul	 rax, rax, 32		; 00000020H
  00913	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:CTCE_Fsm
  0091a	48 03 c8	 add	 rcx, rax
  0091d	48 8b c1	 mov	 rax, rcx
  00920	48 63 8c 24 9c
	00 00 00	 movsxd	 rcx, DWORD PTR tv406[rsp]
  00928	0f b6 04 88	 movzx	 eax, BYTE PTR [rax+rcx*4]
  0092c	89 84 24 a0 00
	00 00		 mov	 DWORD PTR tv415[rsp], eax
  00933	eb 19		 jmp	 SHORT $LN64@CTCE_Reset
$LN63@CTCE_Reset:
  00935	48 8b 84 24 20
	01 00 00	 mov	 rax, QWORD PTR pDEVBLK$[rsp]
  0093d	0f b6 80 34 07
	00 00		 movzx	 eax, BYTE PTR [rax+1844]
  00944	83 e0 07	 and	 eax, 7
  00947	89 84 24 a0 00
	00 00		 mov	 DWORD PTR tv415[rsp], eax
$LN64@CTCE_Reset:
  0094e	48 8b 84 24 20
	01 00 00	 mov	 rax, QWORD PTR pDEVBLK$[rsp]
  00956	0f b6 8c 24 a0
	00 00 00	 movzx	 ecx, BYTE PTR tv415[rsp]
  0095e	88 88 34 07 00
	00		 mov	 BYTE PTR [rax+1844], cl

; 3118 : 
; 3119 :     CTCE_Info.actions      = CTCE_Fsm[CTCE_CMD( bCode_reset )][CTCE_X_STATE_FSM_IDX].actions;

  00964	48 8b 84 24 20
	01 00 00	 mov	 rax, QWORD PTR pDEVBLK$[rsp]
  0096c	8b 80 18 07 00
	00		 mov	 eax, DWORD PTR [rax+1816]
  00972	83 e0 01	 and	 eax, 1
  00975	85 c0		 test	 eax, eax
  00977	75 69		 jne	 SHORT $LN65@CTCE_Reset
  00979	48 8b 84 24 20
	01 00 00	 mov	 rax, QWORD PTR pDEVBLK$[rsp]
  00981	8b 80 74 07 00
	00		 mov	 eax, DWORD PTR [rax+1908]
  00987	c1 e8 03	 shr	 eax, 3
  0098a	83 e0 01	 and	 eax, 1
  0098d	85 c0		 test	 eax, eax
  0098f	75 51		 jne	 SHORT $LN65@CTCE_Reset
  00991	b8 01 00 00 00	 mov	 eax, 1
  00996	48 6b c0 00	 imul	 rax, rax, 0
  0099a	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:CTCE_command
  009a1	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  009a5	83 f8 07	 cmp	 eax, 7
  009a8	75 0d		 jne	 SHORT $LN66@CTCE_Reset
  009aa	c7 84 24 a4 00
	00 00 03 00 00
	00		 mov	 DWORD PTR tv434[rsp], 3
  009b5	eb 1b		 jmp	 SHORT $LN67@CTCE_Reset
$LN66@CTCE_Reset:
  009b7	b8 01 00 00 00	 mov	 eax, 1
  009bc	48 6b c0 00	 imul	 rax, rax, 0
  009c0	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:CTCE_command
  009c7	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  009cb	89 84 24 a4 00
	00 00		 mov	 DWORD PTR tv434[rsp], eax
$LN67@CTCE_Reset:
  009d2	8b 84 24 a4 00
	00 00		 mov	 eax, DWORD PTR tv434[rsp]
  009d9	89 84 24 b0 00
	00 00		 mov	 DWORD PTR tv435[rsp], eax
  009e0	eb 1b		 jmp	 SHORT $LN68@CTCE_Reset
$LN65@CTCE_Reset:
  009e2	b8 01 00 00 00	 mov	 eax, 1
  009e7	48 6b c0 00	 imul	 rax, rax, 0
  009eb	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:CTCE_command
  009f2	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  009f6	89 84 24 b0 00
	00 00		 mov	 DWORD PTR tv435[rsp], eax
$LN68@CTCE_Reset:
  009fd	48 8b 84 24 20
	01 00 00	 mov	 rax, QWORD PTR pDEVBLK$[rsp]
  00a05	0f b6 80 34 07
	00 00		 movzx	 eax, BYTE PTR [rax+1844]
  00a0c	83 e0 04	 and	 eax, 4
  00a0f	85 c0		 test	 eax, eax
  00a11	75 10		 jne	 SHORT $LN73@CTCE_Reset
  00a13	c7 84 24 b4 00
	00 00 06 00 00
	00		 mov	 DWORD PTR tv462[rsp], 6
  00a1e	e9 a1 00 00 00	 jmp	 $LN74@CTCE_Reset
$LN73@CTCE_Reset:
  00a23	48 8b 84 24 20
	01 00 00	 mov	 rax, QWORD PTR pDEVBLK$[rsp]
  00a2b	8b 80 18 07 00
	00		 mov	 eax, DWORD PTR [rax+1816]
  00a31	83 e0 01	 and	 eax, 1
  00a34	85 c0		 test	 eax, eax
  00a36	75 65		 jne	 SHORT $LN69@CTCE_Reset
  00a38	48 8b 84 24 20
	01 00 00	 mov	 rax, QWORD PTR pDEVBLK$[rsp]
  00a40	8b 80 74 07 00
	00		 mov	 eax, DWORD PTR [rax+1908]
  00a46	c1 e8 03	 shr	 eax, 3
  00a49	83 e0 01	 and	 eax, 1
  00a4c	85 c0		 test	 eax, eax
  00a4e	75 4d		 jne	 SHORT $LN69@CTCE_Reset
  00a50	48 8b 84 24 20
	01 00 00	 mov	 rax, QWORD PTR pDEVBLK$[rsp]
  00a58	0f b6 80 36 07
	00 00		 movzx	 eax, BYTE PTR [rax+1846]
  00a5f	83 e0 07	 and	 eax, 7
  00a62	83 f8 05	 cmp	 eax, 5
  00a65	75 0d		 jne	 SHORT $LN70@CTCE_Reset
  00a67	c7 84 24 a8 00
	00 00 04 00 00
	00		 mov	 DWORD PTR tv460[rsp], 4
  00a72	eb 19		 jmp	 SHORT $LN71@CTCE_Reset
$LN70@CTCE_Reset:
  00a74	48 8b 84 24 20
	01 00 00	 mov	 rax, QWORD PTR pDEVBLK$[rsp]
  00a7c	0f b6 80 36 07
	00 00		 movzx	 eax, BYTE PTR [rax+1846]
  00a83	83 e0 07	 and	 eax, 7
  00a86	89 84 24 a8 00
	00 00		 mov	 DWORD PTR tv460[rsp], eax
$LN71@CTCE_Reset:
  00a8d	8b 84 24 a8 00
	00 00		 mov	 eax, DWORD PTR tv460[rsp]
  00a94	89 84 24 ac 00
	00 00		 mov	 DWORD PTR tv461[rsp], eax
  00a9b	eb 19		 jmp	 SHORT $LN72@CTCE_Reset
$LN69@CTCE_Reset:
  00a9d	48 8b 84 24 20
	01 00 00	 mov	 rax, QWORD PTR pDEVBLK$[rsp]
  00aa5	0f b6 80 36 07
	00 00		 movzx	 eax, BYTE PTR [rax+1846]
  00aac	83 e0 07	 and	 eax, 7
  00aaf	89 84 24 ac 00
	00 00		 mov	 DWORD PTR tv461[rsp], eax
$LN72@CTCE_Reset:
  00ab6	8b 84 24 ac 00
	00 00		 mov	 eax, DWORD PTR tv461[rsp]
  00abd	89 84 24 b4 00
	00 00		 mov	 DWORD PTR tv462[rsp], eax
$LN74@CTCE_Reset:
  00ac4	48 63 84 24 b0
	00 00 00	 movsxd	 rax, DWORD PTR tv435[rsp]
  00acc	48 6b c0 20	 imul	 rax, rax, 32		; 00000020H
  00ad0	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:CTCE_Fsm
  00ad7	48 03 c8	 add	 rcx, rax
  00ada	48 8b c1	 mov	 rax, rcx
  00add	48 63 8c 24 b4
	00 00 00	 movsxd	 rcx, DWORD PTR tv462[rsp]
  00ae5	0f b6 44 88 03	 movzx	 eax, BYTE PTR [rax+rcx*4+3]
  00aea	88 84 24 e6 00
	00 00		 mov	 BYTE PTR CTCE_Info$[rsp+6], al

; 3120 :     UnitStat               = CTCE_Fsm[CTCE_CMD( bCode_reset )][CTCE_X_STATE_FSM_IDX].x_unit_stat;

  00af1	48 8b 84 24 20
	01 00 00	 mov	 rax, QWORD PTR pDEVBLK$[rsp]
  00af9	8b 80 18 07 00
	00		 mov	 eax, DWORD PTR [rax+1816]
  00aff	83 e0 01	 and	 eax, 1
  00b02	85 c0		 test	 eax, eax
  00b04	75 69		 jne	 SHORT $LN75@CTCE_Reset
  00b06	48 8b 84 24 20
	01 00 00	 mov	 rax, QWORD PTR pDEVBLK$[rsp]
  00b0e	8b 80 74 07 00
	00		 mov	 eax, DWORD PTR [rax+1908]
  00b14	c1 e8 03	 shr	 eax, 3
  00b17	83 e0 01	 and	 eax, 1
  00b1a	85 c0		 test	 eax, eax
  00b1c	75 51		 jne	 SHORT $LN75@CTCE_Reset
  00b1e	b8 01 00 00 00	 mov	 eax, 1
  00b23	48 6b c0 00	 imul	 rax, rax, 0
  00b27	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:CTCE_command
  00b2e	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00b32	83 f8 07	 cmp	 eax, 7
  00b35	75 0d		 jne	 SHORT $LN76@CTCE_Reset
  00b37	c7 84 24 b8 00
	00 00 03 00 00
	00		 mov	 DWORD PTR tv484[rsp], 3
  00b42	eb 1b		 jmp	 SHORT $LN77@CTCE_Reset
$LN76@CTCE_Reset:
  00b44	b8 01 00 00 00	 mov	 eax, 1
  00b49	48 6b c0 00	 imul	 rax, rax, 0
  00b4d	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:CTCE_command
  00b54	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00b58	89 84 24 b8 00
	00 00		 mov	 DWORD PTR tv484[rsp], eax
$LN77@CTCE_Reset:
  00b5f	8b 84 24 b8 00
	00 00		 mov	 eax, DWORD PTR tv484[rsp]
  00b66	89 84 24 c4 00
	00 00		 mov	 DWORD PTR tv485[rsp], eax
  00b6d	eb 1b		 jmp	 SHORT $LN78@CTCE_Reset
$LN75@CTCE_Reset:
  00b6f	b8 01 00 00 00	 mov	 eax, 1
  00b74	48 6b c0 00	 imul	 rax, rax, 0
  00b78	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:CTCE_command
  00b7f	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00b83	89 84 24 c4 00
	00 00		 mov	 DWORD PTR tv485[rsp], eax
$LN78@CTCE_Reset:
  00b8a	48 8b 84 24 20
	01 00 00	 mov	 rax, QWORD PTR pDEVBLK$[rsp]
  00b92	0f b6 80 34 07
	00 00		 movzx	 eax, BYTE PTR [rax+1844]
  00b99	83 e0 04	 and	 eax, 4
  00b9c	85 c0		 test	 eax, eax
  00b9e	75 10		 jne	 SHORT $LN83@CTCE_Reset
  00ba0	c7 84 24 c8 00
	00 00 06 00 00
	00		 mov	 DWORD PTR tv512[rsp], 6
  00bab	e9 a1 00 00 00	 jmp	 $LN84@CTCE_Reset
$LN83@CTCE_Reset:
  00bb0	48 8b 84 24 20
	01 00 00	 mov	 rax, QWORD PTR pDEVBLK$[rsp]
  00bb8	8b 80 18 07 00
	00		 mov	 eax, DWORD PTR [rax+1816]
  00bbe	83 e0 01	 and	 eax, 1
  00bc1	85 c0		 test	 eax, eax
  00bc3	75 65		 jne	 SHORT $LN79@CTCE_Reset
  00bc5	48 8b 84 24 20
	01 00 00	 mov	 rax, QWORD PTR pDEVBLK$[rsp]
  00bcd	8b 80 74 07 00
	00		 mov	 eax, DWORD PTR [rax+1908]
  00bd3	c1 e8 03	 shr	 eax, 3
  00bd6	83 e0 01	 and	 eax, 1
  00bd9	85 c0		 test	 eax, eax
  00bdb	75 4d		 jne	 SHORT $LN79@CTCE_Reset
  00bdd	48 8b 84 24 20
	01 00 00	 mov	 rax, QWORD PTR pDEVBLK$[rsp]
  00be5	0f b6 80 36 07
	00 00		 movzx	 eax, BYTE PTR [rax+1846]
  00bec	83 e0 07	 and	 eax, 7
  00bef	83 f8 05	 cmp	 eax, 5
  00bf2	75 0d		 jne	 SHORT $LN80@CTCE_Reset
  00bf4	c7 84 24 bc 00
	00 00 04 00 00
	00		 mov	 DWORD PTR tv510[rsp], 4
  00bff	eb 19		 jmp	 SHORT $LN81@CTCE_Reset
$LN80@CTCE_Reset:
  00c01	48 8b 84 24 20
	01 00 00	 mov	 rax, QWORD PTR pDEVBLK$[rsp]
  00c09	0f b6 80 36 07
	00 00		 movzx	 eax, BYTE PTR [rax+1846]
  00c10	83 e0 07	 and	 eax, 7
  00c13	89 84 24 bc 00
	00 00		 mov	 DWORD PTR tv510[rsp], eax
$LN81@CTCE_Reset:
  00c1a	8b 84 24 bc 00
	00 00		 mov	 eax, DWORD PTR tv510[rsp]
  00c21	89 84 24 c0 00
	00 00		 mov	 DWORD PTR tv511[rsp], eax
  00c28	eb 19		 jmp	 SHORT $LN82@CTCE_Reset
$LN79@CTCE_Reset:
  00c2a	48 8b 84 24 20
	01 00 00	 mov	 rax, QWORD PTR pDEVBLK$[rsp]
  00c32	0f b6 80 36 07
	00 00		 movzx	 eax, BYTE PTR [rax+1846]
  00c39	83 e0 07	 and	 eax, 7
  00c3c	89 84 24 c0 00
	00 00		 mov	 DWORD PTR tv511[rsp], eax
$LN82@CTCE_Reset:
  00c43	8b 84 24 c0 00
	00 00		 mov	 eax, DWORD PTR tv511[rsp]
  00c4a	89 84 24 c8 00
	00 00		 mov	 DWORD PTR tv512[rsp], eax
$LN84@CTCE_Reset:
  00c51	48 63 84 24 c4
	00 00 00	 movsxd	 rax, DWORD PTR tv485[rsp]
  00c59	48 6b c0 20	 imul	 rax, rax, 32		; 00000020H
  00c5d	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:CTCE_Fsm
  00c64	48 03 c8	 add	 rcx, rax
  00c67	48 8b c1	 mov	 rax, rcx
  00c6a	48 63 8c 24 c8
	00 00 00	 movsxd	 rcx, DWORD PTR tv512[rsp]
  00c72	0f b6 44 88 01	 movzx	 eax, BYTE PTR [rax+rcx*4+1]
  00c77	88 44 24 30	 mov	 BYTE PTR UnitStat$[rsp], al

; 3121 : 
; 3122 :     // Any WRITE data in the reception buffer won't be used anymore.
; 3123 :     pDEVBLK->ctce_buf_next_read = pDEVBLK->ctce_buf_next_write;

  00c7b	48 8b 84 24 20
	01 00 00	 mov	 rax, QWORD PTR pDEVBLK$[rsp]
  00c83	8b 80 74 07 00
	00		 mov	 eax, DWORD PTR [rax+1908]
  00c89	c1 e8 06	 shr	 eax, 6
  00c8c	83 e0 01	 and	 eax, 1
  00c8f	83 e0 01	 and	 eax, 1
  00c92	c1 e0 05	 shl	 eax, 5
  00c95	48 8b 8c 24 20
	01 00 00	 mov	 rcx, QWORD PTR pDEVBLK$[rsp]
  00c9d	8b 89 74 07 00
	00		 mov	 ecx, DWORD PTR [rcx+1908]
  00ca3	83 e1 df	 and	 ecx, -33		; ffffffdfH
  00ca6	0b c8		 or	 ecx, eax
  00ca8	8b c1		 mov	 eax, ecx
  00caa	48 8b 8c 24 20
	01 00 00	 mov	 rcx, QWORD PTR pDEVBLK$[rsp]
  00cb2	89 81 74 07 00
	00		 mov	 DWORD PTR [rcx+1908], eax

; 3124 : 
; 3125 :     // In most cases we need to inform the other (y-)side.
; 3126 :     if( IS_CTCE_SEND( CTCE_Info.actions ) )

  00cb8	0f b6 84 24 e6
	00 00 00	 movzx	 eax, BYTE PTR CTCE_Info$[rsp+6]
  00cc0	83 e0 40	 and	 eax, 64			; 00000040H
  00cc3	83 f8 40	 cmp	 eax, 64			; 00000040H
  00cc6	75 31		 jne	 SHORT $LN5@CTCE_Reset

; 3127 :     {
; 3128 :         CTCE_Send( pDEVBLK, 0, NULL, &UnitStat, &Residual, &CTCE_Info );

  00cc8	48 8d 84 24 e0
	00 00 00	 lea	 rax, QWORD PTR CTCE_Info$[rsp]
  00cd0	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  00cd5	48 8d 84 24 d4
	00 00 00	 lea	 rax, QWORD PTR Residual$[rsp]
  00cdd	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00ce2	4c 8d 4c 24 30	 lea	 r9, QWORD PTR UnitStat$[rsp]
  00ce7	45 33 c0	 xor	 r8d, r8d
  00cea	33 d2		 xor	 edx, edx
  00cec	48 8b 8c 24 20
	01 00 00	 mov	 rcx, QWORD PTR pDEVBLK$[rsp]
  00cf4	e8 00 00 00 00	 call	 CTCE_Send
$LN5@CTCE_Reset:

; 3129 :     }
; 3130 : 
; 3131 :     // We restart startup tracing if applicable.
; 3132 :     CTCE_RESTART_CCWTRACE( pDEVBLK ) ;

  00cf9	48 8b 84 24 20
	01 00 00	 mov	 rax, QWORD PTR pDEVBLK$[rsp]
  00d01	83 b8 68 07 00
	00 00		 cmp	 DWORD PTR [rax+1896], 0
  00d08	7c 14		 jl	 SHORT $LN85@CTCE_Reset
  00d0a	48 8b 84 24 20
	01 00 00	 mov	 rax, QWORD PTR pDEVBLK$[rsp]
  00d12	c7 80 68 07 00
	00 14 00 00 00	 mov	 DWORD PTR [rax+1896], 20
  00d1c	33 c0		 xor	 eax, eax
$LN85@CTCE_Reset:

; 3133 :     if( CTCE_CCWTRACE( pDEVBLK ) )

  00d1e	48 8b 84 24 20
	01 00 00	 mov	 rax, QWORD PTR pDEVBLK$[rsp]
  00d26	8b 80 f8 05 00
	00		 mov	 eax, DWORD PTR [rax+1528]
  00d2c	c1 e8 0f	 shr	 eax, 15
  00d2f	83 e0 01	 and	 eax, 1
  00d32	85 c0		 test	 eax, eax
  00d34	75 63		 jne	 SHORT $LN7@CTCE_Reset
  00d36	48 8b 84 24 20
	01 00 00	 mov	 rax, QWORD PTR pDEVBLK$[rsp]
  00d3e	83 b8 68 07 00
	00 ff		 cmp	 DWORD PTR [rax+1896], -1
  00d45	74 52		 je	 SHORT $LN7@CTCE_Reset
  00d47	48 8b 84 24 20
	01 00 00	 mov	 rax, QWORD PTR pDEVBLK$[rsp]
  00d4f	83 b8 68 07 00
	00 00		 cmp	 DWORD PTR [rax+1896], 0
  00d56	0f 8e b0 00 00
	00		 jle	 $LN6@CTCE_Reset
  00d5c	48 8b 84 24 20
	01 00 00	 mov	 rax, QWORD PTR pDEVBLK$[rsp]
  00d64	8b 80 68 07 00
	00		 mov	 eax, DWORD PTR [rax+1896]
  00d6a	89 84 24 d8 00
	00 00		 mov	 DWORD PTR tv552[rsp], eax
  00d71	48 8b 84 24 20
	01 00 00	 mov	 rax, QWORD PTR pDEVBLK$[rsp]
  00d79	8b 80 68 07 00
	00		 mov	 eax, DWORD PTR [rax+1896]
  00d7f	ff c8		 dec	 eax
  00d81	48 8b 8c 24 20
	01 00 00	 mov	 rcx, QWORD PTR pDEVBLK$[rsp]
  00d89	89 81 68 07 00
	00		 mov	 DWORD PTR [rcx+1896], eax
  00d8f	83 bc 24 d8 00
	00 00 00	 cmp	 DWORD PTR tv552[rsp], 0
  00d97	74 73		 je	 SHORT $LN6@CTCE_Reset
$LN7@CTCE_Reset:

; 3134 :     {
; 3135 :         CTCE_Trace( pDEVBLK, ( CTCE_Info.sent ? CTCE_SND :

  00d99	8b 84 24 f0 00
	00 00		 mov	 eax, DWORD PTR CTCE_Info$[rsp+16]
  00da0	83 e0 01	 and	 eax, 1
  00da3	85 c0		 test	 eax, eax
  00da5	74 0d		 je	 SHORT $LN88@CTCE_Reset
  00da7	c7 84 24 d0 00
	00 00 01 00 00
	00		 mov	 DWORD PTR tv560[rsp], 1
  00db2	eb 37		 jmp	 SHORT $LN89@CTCE_Reset
$LN88@CTCE_Reset:
  00db4	48 8b 84 24 20
	01 00 00	 mov	 rax, QWORD PTR pDEVBLK$[rsp]
  00dbc	83 b8 3c 07 00
	00 00		 cmp	 DWORD PTR [rax+1852], 0
  00dc3	7d 0d		 jge	 SHORT $LN86@CTCE_Reset
  00dc5	c7 84 24 cc 00
	00 00 04 00 00
	00		 mov	 DWORD PTR tv558[rsp], 4
  00dd0	eb 0b		 jmp	 SHORT $LN87@CTCE_Reset
$LN86@CTCE_Reset:
  00dd2	c7 84 24 cc 00
	00 00 03 00 00
	00		 mov	 DWORD PTR tv558[rsp], 3
$LN87@CTCE_Reset:
  00ddd	8b 84 24 cc 00
	00 00		 mov	 eax, DWORD PTR tv558[rsp]
  00de4	89 84 24 d0 00
	00 00		 mov	 DWORD PTR tv560[rsp], eax
$LN89@CTCE_Reset:
  00deb	4c 8d 4c 24 30	 lea	 r9, QWORD PTR UnitStat$[rsp]
  00df0	4c 8d 84 24 e0
	00 00 00	 lea	 r8, QWORD PTR CTCE_Info$[rsp]
  00df8	8b 94 24 d0 00
	00 00		 mov	 edx, DWORD PTR tv560[rsp]
  00dff	48 8b 8c 24 20
	01 00 00	 mov	 rcx, QWORD PTR pDEVBLK$[rsp]
  00e07	e8 00 00 00 00	 call	 CTCE_Trace
$LN6@CTCE_Reset:

; 3136 :             ( ( pDEVBLK->ctcefd < 0 ) ? CTCE_SND_NSR : CTCE_SND_NS ) ),
; 3137 :             &CTCE_Info, &UnitStat );
; 3138 :     }
; 3139 : } // CTCE_Reset

  00e0c	48 8b 8c 24 00
	01 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  00e14	48 33 cc	 xor	 rcx, rsp
  00e17	e8 00 00 00 00	 call	 __security_check_cookie
  00e1c	48 81 c4 10 01
	00 00		 add	 rsp, 272		; 00000110H
  00e23	5f		 pop	 rdi
  00e24	c3		 ret	 0
CTCE_Reset ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\ctcadpt.c
_TEXT	SEGMENT
dev$ = 144
renewing$ = 152
connect_fd$ = 156
pSokBuf$ = 160
pDEVBLK$ = 168
iLength$ = 176
buf$ = 184
tv289 = 192
tv293 = 196
tv297 = 200
tv301 = 204
tv343 = 208
tv349 = 212
tv353 = 216
tv381 = 220
tv385 = 224
tv405 = 228
tv409 = 232
servlen$ = 236
so_value_1$ = 240
tv271 = 244
tv275 = 248
$T1 = 256
remaddr$ = 264
tv307 = 272
rc$ = 280
tid2$ = 284
tv132 = 288
tv265 = 296
tv345 = 304
tv373 = 312
tv396 = 320
parm_listen$ = 328
address$ = 360
str$ = 384
__$ArrayPad$ = 464
argp$ = 512
CTCE_ListenThread PROC

; 2280 : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	56		 push	 rsi
  00006	57		 push	 rdi
  00007	48 81 ec e8 01
	00 00		 sub	 rsp, 488		; 000001e8H
  0000e	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00015	48 33 c4	 xor	 rax, rsp
  00018	48 89 84 24 d0
	01 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 2281 :     DEVBLK        *pDEVBLK;                      // device block pointer
; 2282 :     int            connect_fd;
; 2283 :     int            iLength;                      // length of 1st read_socket
; 2284 :     socklen_t      servlen;
; 2285 :     char           str[80];
; 2286 :     CTCE_PARMBLK   parm_listen;
; 2287 :     TID            tid2;                         // Thread ID for read thread
; 2288 : #if defined( CTCE_DISABLE_NAGLE )
; 2289 :     const int      so_value_1 = 1;               // Argument for setsockopt

  00020	c7 84 24 f0 00
	00 00 01 00 00
	00		 mov	 DWORD PTR so_value_1$[rsp], 1

; 2290 : #endif
; 2291 :     CTCE_SOKPFX   *pSokBuf;                      // Overlay for buf inside DEVBLK
; 2292 :     BYTE          *buf;                          //-> Device 1st recv data buffer
; 2293 :     DEVBLK        *dev;                          // device block pointer to search for
; 2294 :     char*          remaddr;                      // Remote IP address
; 2295 :     char           address[20]="";               // temp space for IP address

  0002b	0f b6 05 00 00
	00 00		 movzx	 eax, BYTE PTR $SG169961
  00032	88 84 24 68 01
	00 00		 mov	 BYTE PTR address$[rsp], al
  00039	48 8d 84 24 69
	01 00 00	 lea	 rax, QWORD PTR address$[rsp+1]
  00041	48 8b f8	 mov	 rdi, rax
  00044	33 c0		 xor	 eax, eax
  00046	b9 13 00 00 00	 mov	 ecx, 19
  0004b	f3 aa		 rep stosb

; 2296 :     BYTE           renewing;                     // When renewing a CTCE connection
; 2297 : #if defined( HAVE_BASIC_KEEPALIVE )
; 2298 :     int            rc;                           // set_socket_keepalive Return Code
; 2299 : #endif // defined( HAVE_BASIC_KEEPALIVE )
; 2300 : 
; 2301 :     // Set up the parameters passed via create_thread.
; 2302 :     parm_listen = *( ( CTCE_PARMBLK* ) argp );

  0004d	48 8d 84 24 48
	01 00 00	 lea	 rax, QWORD PTR parm_listen$[rsp]
  00055	48 8b f8	 mov	 rdi, rax
  00058	48 8b b4 24 00
	02 00 00	 mov	 rsi, QWORD PTR argp$[rsp]
  00060	b9 20 00 00 00	 mov	 ecx, 32			; 00000020H
  00065	f3 a4		 rep movsb

; 2303 :     free( argp );

  00067	48 8b 8c 24 00
	02 00 00	 mov	 rcx, QWORD PTR argp$[rsp]
  0006f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free

; 2304 :     pDEVBLK = parm_listen.dev;

  00075	48 8b 84 24 60
	01 00 00	 mov	 rax, QWORD PTR parm_listen$[rsp+24]
  0007d	48 89 84 24 a8
	00 00 00	 mov	 QWORD PTR pDEVBLK$[rsp], rax

; 2305 :     servlen = sizeof( parm_listen.addr );

  00085	c7 84 24 ec 00
	00 00 10 00 00
	00		 mov	 DWORD PTR servlen$[rsp], 16
$LN2@CTCE_Liste:

; 2306 : 
; 2307 :     // We keep on listening, i.e. waiting to accept() incoming connect's, until shutdown time.
; 2308 :     for( ; ; )
; 2309 :     {
; 2310 :         if ( ( connect_fd = accept( parm_listen.fd,
; 2311 :             ( struct sockaddr * )&parm_listen.addr, &servlen ) ) > -1 )

  00090	4c 8d 84 24 ec
	00 00 00	 lea	 r8, QWORD PTR servlen$[rsp]
  00098	48 8d 94 24 4c
	01 00 00	 lea	 rdx, QWORD PTR parm_listen$[rsp+4]
  000a0	8b 8c 24 48 01
	00 00		 mov	 ecx, DWORD PTR parm_listen$[rsp]
  000a7	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_accept
  000ad	89 84 24 9c 00
	00 00		 mov	 DWORD PTR connect_fd$[rsp], eax
  000b4	83 bc 24 9c 00
	00 00 ff	 cmp	 DWORD PTR connect_fd$[rsp], -1
  000bc	0f 8e b1 09 00
	00		 jle	 $LN8@CTCE_Liste

; 2312 :         {
; 2313 : 
; 2314 :             // A bonafide connect() to us also provides an initial record
; 2315 :             // with a specific length of data for verification purposes.
; 2316 : #if defined( CTCE_DISABLE_NAGLE )
; 2317 :             if ( setsockopt( connect_fd, IPPROTO_TCP, TCP_NODELAY,
; 2318 :                 ( GETSET_SOCKOPT_T* )&so_value_1, sizeof( so_value_1 ) ) > -1 )

  000c2	48 63 84 24 9c
	00 00 00	 movsxd	 rax, DWORD PTR connect_fd$[rsp]
  000ca	c7 44 24 20 04
	00 00 00	 mov	 DWORD PTR [rsp+32], 4
  000d2	4c 8d 8c 24 f0
	00 00 00	 lea	 r9, QWORD PTR so_value_1$[rsp]
  000da	41 b8 01 00 00
	00		 mov	 r8d, 1
  000e0	ba 06 00 00 00	 mov	 edx, 6
  000e5	48 8b c8	 mov	 rcx, rax
  000e8	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_setsockopt
  000ee	83 f8 ff	 cmp	 eax, -1
  000f1	0f 8e a5 08 00
	00		 jle	 $LN10@CTCE_Liste

; 2319 : #endif
; 2320 :             {
; 2321 :                 buf = malloc( pDEVBLK->ctceSndSml );

  000f7	48 8b 84 24 a8
	00 00 00	 mov	 rax, QWORD PTR pDEVBLK$[rsp]
  000ff	48 63 80 30 07
	00 00		 movsxd	 rax, DWORD PTR [rax+1840]
  00106	48 8b c8	 mov	 rcx, rax
  00109	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_malloc
  0010f	48 89 84 24 b8
	00 00 00	 mov	 QWORD PTR buf$[rsp], rax

; 2322 :                 memset( buf, 0, pDEVBLK->ctceSndSml );

  00117	48 8b 84 24 a8
	00 00 00	 mov	 rax, QWORD PTR pDEVBLK$[rsp]
  0011f	48 63 80 30 07
	00 00		 movsxd	 rax, DWORD PTR [rax+1840]
  00126	48 89 84 24 20
	01 00 00	 mov	 QWORD PTR tv132[rsp], rax
  0012e	48 8b bc 24 b8
	00 00 00	 mov	 rdi, QWORD PTR buf$[rsp]
  00136	33 c0		 xor	 eax, eax
  00138	48 8b 8c 24 20
	01 00 00	 mov	 rcx, QWORD PTR tv132[rsp]
  00140	f3 aa		 rep stosb

; 2323 :                 pSokBuf = ( CTCE_SOKPFX* )buf;

  00142	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR buf$[rsp]
  0014a	48 89 84 24 a0
	00 00 00	 mov	 QWORD PTR pSokBuf$[rsp], rax

; 2324 :                 iLength = read_socket( connect_fd, buf, pDEVBLK->ctceSndSml );

  00152	48 8b 84 24 a8
	00 00 00	 mov	 rax, QWORD PTR pDEVBLK$[rsp]
  0015a	44 8b 80 30 07
	00 00		 mov	 r8d, DWORD PTR [rax+1840]
  00161	48 8b 94 24 b8
	00 00 00	 mov	 rdx, QWORD PTR buf$[rsp]
  00169	8b 8c 24 9c 00
	00 00		 mov	 ecx, DWORD PTR connect_fd$[rsp]
  00170	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_read_socket
  00176	89 84 24 b0 00
	00 00		 mov	 DWORD PTR iLength$[rsp], eax

; 2325 :                 if ( iLength == pDEVBLK->ctceSndSml )

  0017d	48 8b 84 24 a8
	00 00 00	 mov	 rax, QWORD PTR pDEVBLK$[rsp]
  00185	8b 80 30 07 00
	00		 mov	 eax, DWORD PTR [rax+1840]
  0018b	39 84 24 b0 00
	00 00		 cmp	 DWORD PTR iLength$[rsp], eax
  00192	0f 85 d2 06 00
	00		 jne	 $LN12@CTCE_Liste

; 2326 :                 {
; 2327 : 
; 2328 :                     // We search the CTCE devices for one with a matching remote IP address,
; 2329 :                     // and either a matching remote CCUU address when one is specified, or
; 2330 :                     // a matching remote listening port number (the CTCE v. 1 case).
; 2331 :                     for ( dev = sysblk.firstdev; dev; dev = dev->nextdev )

  00198	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  0019f	48 8b 80 c0 11
	00 00		 mov	 rax, QWORD PTR [rax+4544]
  001a6	48 89 84 24 90
	00 00 00	 mov	 QWORD PTR dev$[rsp], rax
  001ae	eb 14		 jmp	 SHORT $LN7@CTCE_Liste
$LN5@CTCE_Liste:
  001b0	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  001b8	48 8b 40 30	 mov	 rax, QWORD PTR [rax+48]
  001bc	48 89 84 24 90
	00 00 00	 mov	 QWORD PTR dev$[rsp], rax
$LN7@CTCE_Liste:
  001c4	48 83 bc 24 90
	00 00 00 00	 cmp	 QWORD PTR dev$[rsp], 0
  001cd	0f 84 97 06 00
	00		 je	 $LN6@CTCE_Liste

; 2332 :                     {
; 2333 :                         if  ( 1
; 2334 :                             && dev->allocated
; 2335 :                             && dev->ctctype == CTC_CTCE
; 2336 :                             && dev->ctce_ipaddr.s_addr == parm_listen.addr.sin_addr.s_addr
; 2337 :                             && dev->ctce_rport == pSokBuf->ctce_lport
; 2338 :                             &&  ( 0

  001d3	33 c0		 xor	 eax, eax
  001d5	83 f8 01	 cmp	 eax, 1
  001d8	0f 84 87 06 00
	00		 je	 $LN13@CTCE_Liste
  001de	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  001e6	83 78 40 00	 cmp	 DWORD PTR [rax+64], 0
  001ea	0f 84 75 06 00
	00		 je	 $LN13@CTCE_Liste
  001f0	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  001f8	0f b6 80 1c 07
	00 00		 movzx	 eax, BYTE PTR [rax+1820]
  001ff	83 f8 04	 cmp	 eax, 4
  00202	0f 85 5d 06 00
	00		 jne	 $LN13@CTCE_Liste
  00208	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00210	8b 8c 24 50 01
	00 00		 mov	 ecx, DWORD PTR parm_listen$[rsp+8]
  00217	39 88 5c 07 00
	00		 cmp	 DWORD PTR [rax+1884], ecx
  0021d	0f 85 42 06 00
	00		 jne	 $LN13@CTCE_Liste
  00223	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR pSokBuf$[rsp]
  0022b	0f b7 40 02	 movzx	 eax, WORD PTR [rax+2]
  0022f	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  00237	39 81 58 07 00
	00		 cmp	 DWORD PTR [rcx+1880], eax
  0023d	0f 85 22 06 00
	00		 jne	 $LN13@CTCE_Liste
  00243	33 c0		 xor	 eax, eax
  00245	85 c0		 test	 eax, eax
  00247	75 4d		 jne	 SHORT $LN14@CTCE_Liste
  00249	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00251	0f b7 80 64 07
	00 00		 movzx	 eax, WORD PTR [rax+1892]
  00258	85 c0		 test	 eax, eax
  0025a	74 3a		 je	 SHORT $LN14@CTCE_Liste
  0025c	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00264	0f b7 80 64 07
	00 00		 movzx	 eax, WORD PTR [rax+1892]
  0026b	85 c0		 test	 eax, eax
  0026d	0f 84 f2 05 00
	00		 je	 $LN13@CTCE_Liste
  00273	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  0027b	0f b7 80 64 07
	00 00		 movzx	 eax, WORD PTR [rax+1892]
  00282	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR pSokBuf$[rsp]
  0028a	0f b7 49 0a	 movzx	 ecx, WORD PTR [rcx+10]
  0028e	3b c1		 cmp	 eax, ecx
  00290	0f 85 cf 05 00
	00		 jne	 $LN13@CTCE_Liste
$LN14@CTCE_Liste:

; 2339 :                                 ||   ( dev->ctce_rccuu == 0 )
; 2340 :                                 || ( ( dev->ctce_rccuu != 0 ) && ( dev->ctce_rccuu == pSokBuf->devnum     ) )
; 2341 :                                 )
; 2342 :                             )
; 2343 :                         {
; 2344 :                             obtain_lock( &dev->lock );

  00296	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  0029e	48 83 c0 38	 add	 rax, 56			; 00000038H
  002a2	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG169969
  002a9	48 8b c8	 mov	 rcx, rax
  002ac	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_obtain_lock

; 2345 : 
; 2346 :                             // We might need to re-initialise our TID following a CTCE recovery.
; 2347 :                             dev->ctce_listen_tid = hthread_self();

  002b2	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fthread_self
  002b8	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  002c0	89 81 70 07 00
	00		 mov	 DWORD PTR [rcx+1904], eax

; 2348 : 
; 2349 :                             // At any point in time will one of the two sides of a CTCE link be
; 2350 :                             // the "ctce_contention_loser".  Both sides receiving a dependent
; 2351 :                             // command "simultaneously" may detect this only upon receiving it from
; 2352 :                             // the other side.  The ctce_contention_loser side will retroactively
; 2353 :                             // back out as if the other side was first, so that the winner can ignore
; 2354 :                             // reception of the conflicting command.  Here we merely initialize
; 2355 :                             // the ctce_contention_loser side, so that the side with the highest IP
; 2356 :                             // address or CCUU address will be the initial winner.
; 2357 :                             if      ( pSokBuf->ctce_ipaddr.s_addr > dev->ctce_ipaddr.s_addr )

  002c6	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR pSokBuf$[rsp]
  002ce	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  002d6	8b 89 5c 07 00
	00		 mov	 ecx, DWORD PTR [rcx+1884]
  002dc	39 48 04	 cmp	 DWORD PTR [rax+4], ecx
  002df	76 24		 jbe	 SHORT $LN15@CTCE_Liste

; 2358 :                                 dev->ctce_contention_loser = 0;

  002e1	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  002e9	8b 80 74 07 00
	00		 mov	 eax, DWORD PTR [rax+1908]
  002ef	83 e0 fe	 and	 eax, -2			; fffffffeH
  002f2	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  002fa	89 81 74 07 00
	00		 mov	 DWORD PTR [rcx+1908], eax
  00300	e9 18 01 00 00	 jmp	 $LN16@CTCE_Liste
$LN15@CTCE_Liste:

; 2359 :                             else if ( pSokBuf->ctce_ipaddr.s_addr < dev->ctce_ipaddr.s_addr )

  00305	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR pSokBuf$[rsp]
  0030d	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  00315	8b 89 5c 07 00
	00		 mov	 ecx, DWORD PTR [rcx+1884]
  0031b	39 48 04	 cmp	 DWORD PTR [rax+4], ecx
  0031e	73 24		 jae	 SHORT $LN17@CTCE_Liste

; 2360 :                                 dev->ctce_contention_loser = 1;

  00320	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00328	8b 80 74 07 00
	00		 mov	 eax, DWORD PTR [rax+1908]
  0032e	83 c8 01	 or	 eax, 1
  00331	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  00339	89 81 74 07 00
	00		 mov	 DWORD PTR [rcx+1908], eax
  0033f	e9 d9 00 00 00	 jmp	 $LN18@CTCE_Liste
$LN17@CTCE_Liste:

; 2361 :                             else if ( pSokBuf->ssid               > dev->ssid               )

  00344	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR pSokBuf$[rsp]
  0034c	0f b7 40 0c	 movzx	 eax, WORD PTR [rax+12]
  00350	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  00358	0f b7 49 44	 movzx	 ecx, WORD PTR [rcx+68]
  0035c	3b c1		 cmp	 eax, ecx
  0035e	7e 24		 jle	 SHORT $LN19@CTCE_Liste

; 2362 :                                 dev->ctce_contention_loser = 0;

  00360	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00368	8b 80 74 07 00
	00		 mov	 eax, DWORD PTR [rax+1908]
  0036e	83 e0 fe	 and	 eax, -2			; fffffffeH
  00371	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  00379	89 81 74 07 00
	00		 mov	 DWORD PTR [rcx+1908], eax
  0037f	e9 99 00 00 00	 jmp	 $LN20@CTCE_Liste
$LN19@CTCE_Liste:

; 2363 :                             else if ( pSokBuf->ssid               < dev->ssid               )

  00384	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR pSokBuf$[rsp]
  0038c	0f b7 40 0c	 movzx	 eax, WORD PTR [rax+12]
  00390	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  00398	0f b7 49 44	 movzx	 ecx, WORD PTR [rcx+68]
  0039c	3b c1		 cmp	 eax, ecx
  0039e	7d 21		 jge	 SHORT $LN21@CTCE_Liste

; 2364 :                                 dev->ctce_contention_loser = 1;

  003a0	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  003a8	8b 80 74 07 00
	00		 mov	 eax, DWORD PTR [rax+1908]
  003ae	83 c8 01	 or	 eax, 1
  003b1	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  003b9	89 81 74 07 00
	00		 mov	 DWORD PTR [rcx+1908], eax
  003bf	eb 5c		 jmp	 SHORT $LN22@CTCE_Liste
$LN21@CTCE_Liste:

; 2365 :                             else if ( pSokBuf->devnum             > dev->devnum             )

  003c1	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR pSokBuf$[rsp]
  003c9	0f b7 40 0a	 movzx	 eax, WORD PTR [rax+10]
  003cd	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  003d5	0f b7 49 48	 movzx	 ecx, WORD PTR [rcx+72]
  003d9	3b c1		 cmp	 eax, ecx
  003db	7e 21		 jle	 SHORT $LN23@CTCE_Liste

; 2366 :                                 dev->ctce_contention_loser = 0;

  003dd	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  003e5	8b 80 74 07 00
	00		 mov	 eax, DWORD PTR [rax+1908]
  003eb	83 e0 fe	 and	 eax, -2			; fffffffeH
  003ee	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  003f6	89 81 74 07 00
	00		 mov	 DWORD PTR [rcx+1908], eax
  003fc	eb 1f		 jmp	 SHORT $LN24@CTCE_Liste
$LN23@CTCE_Liste:

; 2367 :                             else // ( pSokBuf->devnum             < dev->devnum             )
; 2368 :                                 dev->ctce_contention_loser = 1;

  003fe	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00406	8b 80 74 07 00
	00		 mov	 eax, DWORD PTR [rax+1908]
  0040c	83 c8 01	 or	 eax, 1
  0040f	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  00417	89 81 74 07 00
	00		 mov	 DWORD PTR [rcx+1908], eax
$LN24@CTCE_Liste:
$LN22@CTCE_Liste:
$LN20@CTCE_Liste:
$LN18@CTCE_Liste:
$LN16@CTCE_Liste:

; 2369 : 
; 2370 :                             // Show the actual remote listening and connecting ports in filename.
; 2371 :                             strcpy( address, inet_ntoa( dev->ctce_ipaddr ) );

  0041d	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00425	8b 88 5c 07 00
	00		 mov	 ecx, DWORD PTR [rax+1884]
  0042b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_inet_ntoa
  00431	48 8b d0	 mov	 rdx, rax
  00434	48 8d 8c 24 68
	01 00 00	 lea	 rcx, QWORD PTR address$[rsp]
  0043c	e8 00 00 00 00	 call	 strcpy

; 2372 :                             remaddr = address;

  00441	48 8d 84 24 68
	01 00 00	 lea	 rax, QWORD PTR address$[rsp]
  00449	48 89 84 24 08
	01 00 00	 mov	 QWORD PTR remaddr$[rsp], rax

; 2373 :                             MSGBUF( dev->filename, "%1d:%04X=%s:%d/%d", CTCE_DEVNUM( pSokBuf ),

  00451	0f b7 8c 24 4e
	01 00 00	 movzx	 ecx, WORD PTR parm_listen$[rsp+6]
  00459	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ntohs
  0045f	0f b7 c0	 movzx	 eax, ax
  00462	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR pSokBuf$[rsp]
  0046a	0f b7 49 02	 movzx	 ecx, WORD PTR [rcx+2]
  0046e	48 8b 94 24 a0
	00 00 00	 mov	 rdx, QWORD PTR pSokBuf$[rsp]
  00476	0f b7 52 0a	 movzx	 edx, WORD PTR [rdx+10]
  0047a	48 8b bc 24 a0
	00 00 00	 mov	 rdi, QWORD PTR pSokBuf$[rsp]
  00482	0f b7 7f 0c	 movzx	 edi, WORD PTR [rdi+12]
  00486	d1 ff		 sar	 edi, 1
  00488	48 8b b4 24 90
	00 00 00	 mov	 rsi, QWORD PTR dev$[rsp]
  00490	48 81 c6 a4 00
	00 00		 add	 rsi, 164		; 000000a4H
  00497	89 44 24 38	 mov	 DWORD PTR [rsp+56], eax
  0049b	89 4c 24 30	 mov	 DWORD PTR [rsp+48], ecx
  0049f	48 8b 84 24 08
	01 00 00	 mov	 rax, QWORD PTR remaddr$[rsp]
  004a7	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  004ac	89 54 24 20	 mov	 DWORD PTR [rsp+32], edx
  004b0	44 8b cf	 mov	 r9d, edi
  004b3	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG169980
  004ba	ba 05 01 00 00	 mov	 edx, 261		; 00000105H
  004bf	48 8b ce	 mov	 rcx, rsi
  004c2	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_snprintf

; 2374 :                                 remaddr, pSokBuf->ctce_lport, ntohs( parm_listen.addr.sin_port ) );
; 2375 : 
; 2376 :                             // In case our side believed we were already connected, the other
; 2377 :                             // side must have issued a re-connect for whatever reason, e.g.
; 2378 :                             // when recovering a lost connection or completely restarting.
; 2379 :                             if( dev->ctcefd > 0 )

  004c8	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  004d0	83 b8 3c 07 00
	00 00		 cmp	 DWORD PTR [rax+1852], 0
  004d7	7e 0a		 jle	 SHORT $LN25@CTCE_Liste

; 2380 :                             {
; 2381 :                                 renewing = 1;

  004d9	c6 84 24 98 00
	00 00 01	 mov	 BYTE PTR renewing$[rsp], 1

; 2382 :                             }

  004e1	eb 08		 jmp	 SHORT $LN26@CTCE_Liste
$LN25@CTCE_Liste:

; 2383 :                             else
; 2384 :                             {
; 2385 :                                 renewing = 0;

  004e3	c6 84 24 98 00
	00 00 00	 mov	 BYTE PTR renewing$[rsp], 0
$LN26@CTCE_Liste:

; 2386 :                             }
; 2387 : 
; 2388 : #if defined( HAVE_BASIC_KEEPALIVE )
; 2389 :                             // We try improving recoverability by enabling TCP keepalives.
; 2390 :                             // We re-use the retry interval and count values from the console values,
; 2391 :                             // (CONKPALV), but the idle interval will be set to 1200 seconds, as
; 2392 :                             // inactivity periods of up to 15 minutes are normal.
; 2393 :                             // We only report failure if the system is expected to support it all.
; 2394 : #define CTCE_KEEPALIVE_IDLE 1200
; 2395 :                             rc = set_socket_keepalive( connect_fd, CTCE_KEEPALIVE_IDLE,

  004eb	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  004f2	44 8b 88 b8 10
	00 00		 mov	 r9d, DWORD PTR [rax+4280]
  004f9	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00500	44 8b 80 b4 10
	00 00		 mov	 r8d, DWORD PTR [rax+4276]
  00507	ba b0 04 00 00	 mov	 edx, 1200		; 000004b0H
  0050c	8b 8c 24 9c 00
	00 00		 mov	 ecx, DWORD PTR connect_fd$[rsp]
  00513	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_set_socket_keepalive
  00519	89 84 24 18 01
	00 00		 mov	 DWORD PTR rc$[rsp], eax

; 2396 :                                                        sysblk.kaintv, sysblk.kacnt );
; 2397 :   #if defined( HAVE_FULL_KEEPALIVE )
; 2398 :                             if( rc != 0 )
; 2399 :                             {
; 2400 :                                 WRMSG( HHC05082, "W",  // CTCE: TCP set_socket_keepalive RC=%d"
; 2401 :                                     CTCX_DEVNUM( dev ), rc);
; 2402 :                             }
; 2403 :   #endif // defined( HAVEHAVE_FULL_KEEPALIVE )
; 2404 : #endif // defined( HAVE_BASIC_KEEPALIVE )
; 2405 : 
; 2406 :                             // The all-important connect socket descriptor is now established.
; 2407 :                             dev->ctcefd = connect_fd;

  00520	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00528	8b 8c 24 9c 00
	00 00		 mov	 ecx, DWORD PTR connect_fd$[rsp]
  0052f	89 88 3c 07 00
	00		 mov	 DWORD PTR [rax+1852], ecx

; 2408 : 
; 2409 :                             // This side is ready to start receiving and sending so we
; 2410 :                             // start a read thread to do the receiving part;
; 2411 :                             MSGBUF( str, "CTCE %04X RecvThread", dev->devnum );

  00535	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  0053d	0f b7 40 48	 movzx	 eax, WORD PTR [rax+72]
  00541	44 8b c8	 mov	 r9d, eax
  00544	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG169983
  0054b	ba 50 00 00 00	 mov	 edx, 80			; 00000050H
  00550	48 8d 8c 24 80
	01 00 00	 lea	 rcx, QWORD PTR str$[rsp]
  00558	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_snprintf

; 2412 :                             str[sizeof( str ) - 1] = 0;

  0055e	b8 01 00 00 00	 mov	 eax, 1
  00563	48 6b c0 4f	 imul	 rax, rax, 79		; 0000004fH
  00567	48 89 84 24 00
	01 00 00	 mov	 QWORD PTR $T1[rsp], rax
  0056f	48 83 bc 24 00
	01 00 00 50	 cmp	 QWORD PTR $T1[rsp], 80	; 00000050H
  00578	73 02		 jae	 SHORT $LN33@CTCE_Liste
  0057a	eb 05		 jmp	 SHORT $LN34@CTCE_Liste
$LN33@CTCE_Liste:
  0057c	e8 00 00 00 00	 call	 __report_rangecheckfailure
$LN34@CTCE_Liste:
  00581	48 8b 84 24 00
	01 00 00	 mov	 rax, QWORD PTR $T1[rsp]
  00589	c6 84 04 80 01
	00 00 00	 mov	 BYTE PTR str$[rsp+rax], 0

; 2413 :                             if( create_thread( &tid2, DETACHED, CTCE_RecvThread, dev, str ) != 0 )

  00591	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00598	48 05 88 10 00
	00		 add	 rax, 4232		; 00001088H
  0059e	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169986
  005a5	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  005aa	48 8d 8c 24 80
	01 00 00	 lea	 rcx, QWORD PTR str$[rsp]
  005b2	48 89 4c 24 20	 mov	 QWORD PTR [rsp+32], rcx
  005b7	4c 8b 8c 24 90
	00 00 00	 mov	 r9, QWORD PTR dev$[rsp]
  005bf	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:CTCE_RecvThread
  005c6	48 8b d0	 mov	 rdx, rax
  005c9	48 8d 8c 24 1c
	01 00 00	 lea	 rcx, QWORD PTR tid2$[rsp]
  005d1	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_create_thread
  005d7	85 c0		 test	 eax, eax
  005d9	0f 84 ba 00 00
	00		 je	 $LN27@CTCE_Liste

; 2414 :                             {
; 2415 :                                 WRMSG( HHC05069, "E",  // CTCE: create_thread %s error: %s"

  005df	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_WSAGetLastError
  005e5	8b c8		 mov	 ecx, eax
  005e7	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_strerror
  005ed	48 89 84 24 28
	01 00 00	 mov	 QWORD PTR tv265[rsp], rax
  005f5	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  005fd	0f b7 49 48	 movzx	 ecx, WORD PTR [rcx+72]
  00601	89 8c 24 f4 00
	00 00		 mov	 DWORD PTR tv271[rsp], ecx
  00608	48 8b 94 24 90
	00 00 00	 mov	 rdx, QWORD PTR dev$[rsp]
  00610	0f b7 52 44	 movzx	 edx, WORD PTR [rdx+68]
  00614	d1 fa		 sar	 edx, 1
  00616	89 94 24 f8 00
	00 00		 mov	 DWORD PTR tv275[rsp], edx
  0061d	b9 01 00 00 00	 mov	 ecx, 1
  00622	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  00628	48 8b 8c 24 28
	01 00 00	 mov	 rcx, QWORD PTR tv265[rsp]
  00630	48 89 4c 24 50	 mov	 QWORD PTR [rsp+80], rcx
  00635	48 8d 8c 24 80
	01 00 00	 lea	 rcx, QWORD PTR str$[rsp]
  0063d	48 89 4c 24 48	 mov	 QWORD PTR [rsp+72], rcx
  00642	8b 8c 24 f4 00
	00 00		 mov	 ecx, DWORD PTR tv271[rsp]
  00649	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  0064d	8b 8c 24 f8 00
	00 00		 mov	 ecx, DWORD PTR tv275[rsp]
  00654	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  00658	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169987
  0065f	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  00664	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169988
  0066b	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00670	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00675	41 b9 03 00 00
	00		 mov	 r9d, 3
  0067b	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG169989
  00682	ba 70 09 00 00	 mov	 edx, 2416		; 00000970H
  00687	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169990
  0068e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 2416 :                                     CTCX_DEVNUM( dev ), str, strerror( HSO_errno ) );
; 2417 :                             }

  00694	e9 5c 01 00 00	 jmp	 $LN28@CTCE_Liste
$LN27@CTCE_Liste:

; 2418 :                             else
; 2419 :                             {
; 2420 :                                 WRMSG( HHC05070, "I",  // CTCE: %s inbound connection :%5d <- %1d:%04X=%s:%5d (bufsize=%d,%d)"

  00699	0f b6 84 24 98
	00 00 00	 movzx	 eax, BYTE PTR renewing$[rsp]
  006a1	85 c0		 test	 eax, eax
  006a3	74 11		 je	 SHORT $LN35@CTCE_Liste
  006a5	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG169991
  006ac	48 89 84 24 10
	01 00 00	 mov	 QWORD PTR tv307[rsp], rax
  006b4	eb 0f		 jmp	 SHORT $LN36@CTCE_Liste
$LN35@CTCE_Liste:
  006b6	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG169992
  006bd	48 89 84 24 10
	01 00 00	 mov	 QWORD PTR tv307[rsp], rax
$LN36@CTCE_Liste:
  006c5	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  006cd	8b 80 d8 01 00
	00		 mov	 eax, DWORD PTR [rax+472]
  006d3	99		 cdq
  006d4	2b c2		 sub	 eax, edx
  006d6	d1 f8		 sar	 eax, 1
  006d8	89 84 24 c0 00
	00 00		 mov	 DWORD PTR tv289[rsp], eax
  006df	0f b7 8c 24 4e
	01 00 00	 movzx	 ecx, WORD PTR parm_listen$[rsp+6]
  006e7	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ntohs
  006ed	0f b7 c0	 movzx	 eax, ax
  006f0	89 84 24 c4 00
	00 00		 mov	 DWORD PTR tv293[rsp], eax
  006f7	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR pSokBuf$[rsp]
  006ff	0f b7 49 0a	 movzx	 ecx, WORD PTR [rcx+10]
  00703	89 8c 24 c8 00
	00 00		 mov	 DWORD PTR tv297[rsp], ecx
  0070a	48 8b 94 24 a0
	00 00 00	 mov	 rdx, QWORD PTR pSokBuf$[rsp]
  00712	0f b7 52 0c	 movzx	 edx, WORD PTR [rdx+12]
  00716	d1 fa		 sar	 edx, 1
  00718	89 94 24 cc 00
	00 00		 mov	 DWORD PTR tv301[rsp], edx
  0071f	48 8b bc 24 90
	00 00 00	 mov	 rdi, QWORD PTR dev$[rsp]
  00727	0f b7 7f 48	 movzx	 edi, WORD PTR [rdi+72]
  0072b	48 8b b4 24 90
	00 00 00	 mov	 rsi, QWORD PTR dev$[rsp]
  00733	0f b7 76 44	 movzx	 esi, WORD PTR [rsi+68]
  00737	d1 fe		 sar	 esi, 1
  00739	b9 01 00 00 00	 mov	 ecx, 1
  0073e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  00744	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  0074c	8b 89 30 07 00
	00		 mov	 ecx, DWORD PTR [rcx+1840]
  00752	89 8c 24 80 00
	00 00		 mov	 DWORD PTR [rsp+128], ecx
  00759	8b 8c 24 c0 00
	00 00		 mov	 ecx, DWORD PTR tv289[rsp]
  00760	89 4c 24 78	 mov	 DWORD PTR [rsp+120], ecx
  00764	8b 8c 24 c4 00
	00 00		 mov	 ecx, DWORD PTR tv293[rsp]
  0076b	89 4c 24 70	 mov	 DWORD PTR [rsp+112], ecx
  0076f	48 8b 8c 24 08
	01 00 00	 mov	 rcx, QWORD PTR remaddr$[rsp]
  00777	48 89 4c 24 68	 mov	 QWORD PTR [rsp+104], rcx
  0077c	8b 8c 24 c8 00
	00 00		 mov	 ecx, DWORD PTR tv297[rsp]
  00783	89 4c 24 60	 mov	 DWORD PTR [rsp+96], ecx
  00787	8b 8c 24 cc 00
	00 00		 mov	 ecx, DWORD PTR tv301[rsp]
  0078e	89 4c 24 58	 mov	 DWORD PTR [rsp+88], ecx
  00792	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  0079a	8b 89 50 07 00
	00		 mov	 ecx, DWORD PTR [rcx+1872]
  007a0	89 4c 24 50	 mov	 DWORD PTR [rsp+80], ecx
  007a4	48 8b 8c 24 10
	01 00 00	 mov	 rcx, QWORD PTR tv307[rsp]
  007ac	48 89 4c 24 48	 mov	 QWORD PTR [rsp+72], rcx
  007b1	89 7c 24 40	 mov	 DWORD PTR [rsp+64], edi
  007b5	89 74 24 38	 mov	 DWORD PTR [rsp+56], esi
  007b9	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169993
  007c0	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  007c5	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169994
  007cc	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  007d1	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  007d6	41 b9 03 00 00
	00		 mov	 r9d, 3
  007dc	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG169995
  007e3	ba 77 09 00 00	 mov	 edx, 2423		; 00000977H
  007e8	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169996
  007ef	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg
$LN28@CTCE_Liste:

; 2421 :                                     CTCX_DEVNUM( dev ), ( renewing ? "Renewing" : "Accepted" ), dev->ctce_lport,
; 2422 :                                     CTCE_DEVNUM( pSokBuf ), remaddr, ntohs( parm_listen.addr.sin_port),
; 2423 :                                     dev->bufsize / 2, dev->ctceSndSml );
; 2424 :                             }
; 2425 : 
; 2426 :                             // If we are not yet or no longer connected to the other side,
; 2427 :                             // then we must re-initiate the CTCE_ConnectThread.
; 2428 :                             if ( ( dev->fd != -1 ) && ( ! ( pSokBuf->ctce_herc & CTCE_HERC_RECV ) ) )

  007f5	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  007fd	83 b8 ac 01 00
	00 ff		 cmp	 DWORD PTR [rax+428], -1
  00804	74 41		 je	 SHORT $LN29@CTCE_Liste
  00806	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR pSokBuf$[rsp]
  0080e	0f b7 00	 movzx	 eax, WORD PTR [rax]
  00811	25 01 80 00 00	 and	 eax, 32769		; 00008001H
  00816	85 c0		 test	 eax, eax
  00818	75 2d		 jne	 SHORT $LN29@CTCE_Liste

; 2429 :                             {
; 2430 :                                 dev->reinit = 1;

  0081a	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00822	8b 80 f8 05 00
	00		 mov	 eax, DWORD PTR [rax+1528]
  00828	0f ba e8 12	 bts	 eax, 18
  0082c	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  00834	89 81 f8 05 00
	00		 mov	 DWORD PTR [rcx+1528], eax

; 2431 :                                 CTCE_Start_ConnectThread( dev ) ;

  0083a	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  00842	e8 00 00 00 00	 call	 CTCE_Start_ConnectThread
$LN29@CTCE_Liste:

; 2432 :                             }
; 2433 : 
; 2434 :                             // We break out of the device search loop.
; 2435 :                             release_lock( &dev->lock );

  00847	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  0084f	48 83 c0 38	 add	 rax, 56			; 00000038H
  00853	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG169998
  0085a	48 8b c8	 mov	 rcx, rax
  0085d	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_release_lock

; 2436 :                             break ;

  00863	eb 05		 jmp	 SHORT $LN6@CTCE_Liste
$LN13@CTCE_Liste:

; 2437 :                         } // matching device found
; 2438 :                     } // device search loop

  00865	e9 46 f9 ff ff	 jmp	 $LN5@CTCE_Liste
$LN6@CTCE_Liste:
$LN12@CTCE_Liste:

; 2439 :                 } // initial read_socket() after connect() completed
; 2440 : 
; 2441 :                 // A TCP connect() which did not match any of our CTCE devices is reported.
; 2442 :                 if ( ( ( iLength != pDEVBLK->ctceSndSml ) || ( !dev ) ) )

  0086a	48 8b 84 24 a8
	00 00 00	 mov	 rax, QWORD PTR pDEVBLK$[rsp]
  00872	8b 80 30 07 00
	00		 mov	 eax, DWORD PTR [rax+1840]
  00878	39 84 24 b0 00
	00 00		 cmp	 DWORD PTR iLength$[rsp], eax
  0087f	75 0f		 jne	 SHORT $LN31@CTCE_Liste
  00881	48 83 bc 24 90
	00 00 00 00	 cmp	 QWORD PTR dev$[rsp], 0
  0088a	0f 85 f9 00 00
	00		 jne	 $LN30@CTCE_Liste
$LN31@CTCE_Liste:

; 2443 :                 {
; 2444 :                     WRMSG( HHC05067, "W",  // CTCE: Ignoring non matching connection from %1d:%04X=%s:%d"

  00890	0f b7 8c 24 4e
	01 00 00	 movzx	 ecx, WORD PTR parm_listen$[rsp+6]
  00898	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ntohs
  0089e	0f b7 c0	 movzx	 eax, ax
  008a1	89 84 24 d0 00
	00 00		 mov	 DWORD PTR tv343[rsp], eax
  008a8	8b 8c 24 50 01
	00 00		 mov	 ecx, DWORD PTR parm_listen$[rsp+8]
  008af	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_inet_ntoa
  008b5	48 89 84 24 30
	01 00 00	 mov	 QWORD PTR tv345[rsp], rax
  008bd	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR pSokBuf$[rsp]
  008c5	0f b7 49 0a	 movzx	 ecx, WORD PTR [rcx+10]
  008c9	89 8c 24 d4 00
	00 00		 mov	 DWORD PTR tv349[rsp], ecx
  008d0	48 8b 94 24 a0
	00 00 00	 mov	 rdx, QWORD PTR pSokBuf$[rsp]
  008d8	0f b7 52 0c	 movzx	 edx, WORD PTR [rdx+12]
  008dc	d1 fa		 sar	 edx, 1
  008de	89 94 24 d8 00
	00 00		 mov	 DWORD PTR tv353[rsp], edx
  008e5	48 8b bc 24 a8
	00 00 00	 mov	 rdi, QWORD PTR pDEVBLK$[rsp]
  008ed	0f b7 7f 48	 movzx	 edi, WORD PTR [rdi+72]
  008f1	48 8b b4 24 a8
	00 00 00	 mov	 rsi, QWORD PTR pDEVBLK$[rsp]
  008f9	0f b7 76 44	 movzx	 esi, WORD PTR [rsi+68]
  008fd	d1 fe		 sar	 esi, 1
  008ff	b9 01 00 00 00	 mov	 ecx, 1
  00904	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  0090a	8b 8c 24 d0 00
	00 00		 mov	 ecx, DWORD PTR tv343[rsp]
  00911	89 4c 24 60	 mov	 DWORD PTR [rsp+96], ecx
  00915	48 8b 8c 24 30
	01 00 00	 mov	 rcx, QWORD PTR tv345[rsp]
  0091d	48 89 4c 24 58	 mov	 QWORD PTR [rsp+88], rcx
  00922	8b 8c 24 d4 00
	00 00		 mov	 ecx, DWORD PTR tv349[rsp]
  00929	89 4c 24 50	 mov	 DWORD PTR [rsp+80], ecx
  0092d	8b 8c 24 d8 00
	00 00		 mov	 ecx, DWORD PTR tv353[rsp]
  00934	89 4c 24 48	 mov	 DWORD PTR [rsp+72], ecx
  00938	89 7c 24 40	 mov	 DWORD PTR [rsp+64], edi
  0093c	89 74 24 38	 mov	 DWORD PTR [rsp+56], esi
  00940	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170001
  00947	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  0094c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170002
  00953	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00958	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  0095d	41 b9 03 00 00
	00		 mov	 r9d, 3
  00963	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG170003
  0096a	ba 8e 09 00 00	 mov	 edx, 2446		; 0000098eH
  0096f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170004
  00976	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 2445 :                          CTCX_DEVNUM( pDEVBLK ), CTCE_DEVNUM( pSokBuf ),
; 2446 :                          inet_ntoa( parm_listen.addr.sin_addr ), ntohs( parm_listen.addr.sin_port ) );
; 2447 :                     close_socket( connect_fd );

  0097c	8b 8c 24 9c 00
	00 00		 mov	 ecx, DWORD PTR connect_fd$[rsp]
  00983	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_close_socket
$LN30@CTCE_Liste:

; 2448 :                 }
; 2449 :                 free ( buf ) ;

  00989	48 8b 8c 24 b8
	00 00 00	 mov	 rcx, QWORD PTR buf$[rsp]
  00991	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free

; 2450 :             }

  00997	e9 d2 00 00 00	 jmp	 $LN11@CTCE_Liste
$LN10@CTCE_Liste:

; 2451 : #if defined( CTCE_DISABLE_NAGLE )
; 2452 :             else
; 2453 :             {
; 2454 :                 WRMSG( HHC05068, "E",  // CTCE: TCP_NODELAY error for listening socket %d (port %d): %s"

  0099c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_WSAGetLastError
  009a2	8b c8		 mov	 ecx, eax
  009a4	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_strerror
  009aa	48 89 84 24 38
	01 00 00	 mov	 QWORD PTR tv373[rsp], rax
  009b2	48 8b 8c 24 a8
	00 00 00	 mov	 rcx, QWORD PTR pDEVBLK$[rsp]
  009ba	0f b7 49 48	 movzx	 ecx, WORD PTR [rcx+72]
  009be	89 8c 24 dc 00
	00 00		 mov	 DWORD PTR tv381[rsp], ecx
  009c5	48 8b 94 24 a8
	00 00 00	 mov	 rdx, QWORD PTR pDEVBLK$[rsp]
  009cd	0f b7 52 44	 movzx	 edx, WORD PTR [rdx+68]
  009d1	d1 fa		 sar	 edx, 1
  009d3	89 94 24 e0 00
	00 00		 mov	 DWORD PTR tv385[rsp], edx
  009da	b9 01 00 00 00	 mov	 ecx, 1
  009df	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  009e5	48 8b 8c 24 38
	01 00 00	 mov	 rcx, QWORD PTR tv373[rsp]
  009ed	48 89 4c 24 58	 mov	 QWORD PTR [rsp+88], rcx
  009f2	48 8b 8c 24 a8
	00 00 00	 mov	 rcx, QWORD PTR pDEVBLK$[rsp]
  009fa	8b 89 50 07 00
	00		 mov	 ecx, DWORD PTR [rcx+1872]
  00a00	89 4c 24 50	 mov	 DWORD PTR [rsp+80], ecx
  00a04	8b 8c 24 9c 00
	00 00		 mov	 ecx, DWORD PTR connect_fd$[rsp]
  00a0b	89 4c 24 48	 mov	 DWORD PTR [rsp+72], ecx
  00a0f	8b 8c 24 dc 00
	00 00		 mov	 ecx, DWORD PTR tv381[rsp]
  00a16	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  00a1a	8b 8c 24 e0 00
	00 00		 mov	 ecx, DWORD PTR tv385[rsp]
  00a21	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  00a25	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170005
  00a2c	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  00a31	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170006
  00a38	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00a3d	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00a42	41 b9 03 00 00
	00		 mov	 r9d, 3
  00a48	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG170007
  00a4f	ba 97 09 00 00	 mov	 edx, 2455		; 00000997H
  00a54	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170008
  00a5b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 2455 :                     CTCX_DEVNUM( pDEVBLK ), connect_fd, pDEVBLK->ctce_lport, strerror( HSO_errno ) );
; 2456 :                 close_socket( connect_fd );

  00a61	8b 8c 24 9c 00
	00 00		 mov	 ecx, DWORD PTR connect_fd$[rsp]
  00a68	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_close_socket
$LN11@CTCE_Liste:

; 2457 :             }
; 2458 : #endif
; 2459 :         }

  00a6e	e9 d2 00 00 00	 jmp	 $LN9@CTCE_Liste
$LN8@CTCE_Liste:

; 2460 :         else
; 2461 :         {
; 2462 :             WRMSG( HHC05083, "E",  // CTCE: Error on accept() for listening socket %d (port %d): %s"

  00a73	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_WSAGetLastError
  00a79	8b c8		 mov	 ecx, eax
  00a7b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_strerror
  00a81	48 89 84 24 40
	01 00 00	 mov	 QWORD PTR tv396[rsp], rax
  00a89	48 8b 8c 24 a8
	00 00 00	 mov	 rcx, QWORD PTR pDEVBLK$[rsp]
  00a91	0f b7 49 48	 movzx	 ecx, WORD PTR [rcx+72]
  00a95	89 8c 24 e4 00
	00 00		 mov	 DWORD PTR tv405[rsp], ecx
  00a9c	48 8b 94 24 a8
	00 00 00	 mov	 rdx, QWORD PTR pDEVBLK$[rsp]
  00aa4	0f b7 52 44	 movzx	 edx, WORD PTR [rdx+68]
  00aa8	d1 fa		 sar	 edx, 1
  00aaa	89 94 24 e8 00
	00 00		 mov	 DWORD PTR tv409[rsp], edx
  00ab1	b9 01 00 00 00	 mov	 ecx, 1
  00ab6	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  00abc	48 8b 8c 24 40
	01 00 00	 mov	 rcx, QWORD PTR tv396[rsp]
  00ac4	48 89 4c 24 58	 mov	 QWORD PTR [rsp+88], rcx
  00ac9	48 8b 8c 24 a8
	00 00 00	 mov	 rcx, QWORD PTR pDEVBLK$[rsp]
  00ad1	8b 89 50 07 00
	00		 mov	 ecx, DWORD PTR [rcx+1872]
  00ad7	89 4c 24 50	 mov	 DWORD PTR [rsp+80], ecx
  00adb	8b 8c 24 9c 00
	00 00		 mov	 ecx, DWORD PTR connect_fd$[rsp]
  00ae2	89 4c 24 48	 mov	 DWORD PTR [rsp+72], ecx
  00ae6	8b 8c 24 e4 00
	00 00		 mov	 ecx, DWORD PTR tv405[rsp]
  00aed	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  00af1	8b 8c 24 e8 00
	00 00		 mov	 ecx, DWORD PTR tv409[rsp]
  00af8	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  00afc	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170009
  00b03	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  00b08	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170010
  00b0f	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00b14	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00b19	41 b9 03 00 00
	00		 mov	 r9d, 3
  00b1f	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG170011
  00b26	ba 9f 09 00 00	 mov	 edx, 2463		; 0000099fH
  00b2b	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170012
  00b32	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 2463 :                 CTCX_DEVNUM( pDEVBLK ), connect_fd, pDEVBLK->ctce_lport, strerror( HSO_errno ) );
; 2464 :             close_socket( connect_fd );

  00b38	8b 8c 24 9c 00
	00 00		 mov	 ecx, DWORD PTR connect_fd$[rsp]
  00b3f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_close_socket
$LN9@CTCE_Liste:

; 2465 :         }
; 2466 :     } // do forever loop until shutdown

  00b45	e9 46 f5 ff ff	 jmp	 $LN2@CTCE_Liste
$LN32@CTCE_Liste:

; 2467 : 
; 2468 :     UNREACHABLE_CODE( return NULL );
; 2469 : 
; 2470 : } // CTCE_ListenThread

  00b4a	48 8b 8c 24 d0
	01 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  00b52	48 33 cc	 xor	 rcx, rsp
  00b55	e8 00 00 00 00	 call	 __security_check_cookie
  00b5a	48 81 c4 e8 01
	00 00		 add	 rsp, 488		; 000001e8H
  00b61	5f		 pop	 rdi
  00b62	5e		 pop	 rsi
  00b63	c3		 ret	 0
CTCE_ListenThread ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\ctcadpt.c
_TEXT	SEGMENT
pDEVBLK$ = 112
ctce_recv_mods_UnitStat$ = 120
pSokBuf$ = 128
iLength$ = 136
i$ = 140
tv304 = 144
tv330 = 148
tv331 = 152
tv305 = 156
tv332 = 160
tv362 = 164
tv363 = 168
tv412 = 172
tv438 = 176
tv439 = 180
tv413 = 184
tv440 = 188
tv470 = 192
tv496 = 196
tv497 = 200
tv471 = 204
tv498 = 208
tv507 = 212
tv532 = 216
tv558 = 220
tv559 = 224
tv533 = 228
tv560 = 232
tv588 = 236
tv614 = 240
tv615 = 244
tv589 = 248
tv616 = 252
tv656 = 256
tv657 = 260
tv676 = 264
tv677 = 268
tv679 = 272
tv708 = 276
tv709 = 280
tv728 = 284
tv754 = 288
tv755 = 292
tv792 = 296
tv793 = 300
tv81 = 304
tv256 = 308
tv178 = 312
tv186 = 316
tv190 = 320
tv871 = 324
tv935 = 328
tv155 = 332
tv159 = 336
ctcePktCnt$ = 344
ctceBytCnt$ = 352
tv148 = 360
tv152 = 368
tv180 = 376
tv183 = 384
CTCE_Info$ = 392
__$ArrayPad$ = 424
argp$ = 448
CTCE_RecvThread PROC

; 2682 : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 81 ec b8 01
	00 00		 sub	 rsp, 440		; 000001b8H
  0000c	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00013	48 33 c4	 xor	 rax, rsp
  00016	48 89 84 24 a8
	01 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 2683 :     DEVBLK        *pDEVBLK = (DEVBLK*) argp;     // argp is the device block pointer

  0001e	48 8b 84 24 c0
	01 00 00	 mov	 rax, QWORD PTR argp$[rsp]
  00026	48 89 44 24 70	 mov	 QWORD PTR pDEVBLK$[rsp], rax

; 2684 :     CTCE_SOKPFX   *pSokBuf;                      // overlay for buf inside DEVBLK
; 2685 :     CTCE_INFO      CTCE_Info;                    // CTCE information (also for tracing)
; 2686 :     int            iLength = 0;

  0002b	c7 84 24 88 00
	00 00 00 00 00
	00		 mov	 DWORD PTR iLength$[rsp], 0

; 2687 :     U64            ctcePktCnt = 0;               // Recvd Packet Count

  00036	48 c7 84 24 58
	01 00 00 00 00
	00 00		 mov	 QWORD PTR ctcePktCnt$[rsp], 0

; 2688 :     U64            ctceBytCnt = 0;               // Recvd Byte Count

  00042	48 c7 84 24 60
	01 00 00 00 00
	00 00		 mov	 QWORD PTR ctceBytCnt$[rsp], 0

; 2689 :     BYTE           ctce_recv_mods_UnitStat;      // UnitStat modifications
; 2690 :     int            i = 0;                        // temporary variable

  0004e	c7 84 24 8c 00
	00 00 00 00 00
	00		 mov	 DWORD PTR i$[rsp], 0

; 2691 : 
; 2692 :     // When the receiver thread is (re-)started, the CTCE devblk is (re-)initialized
; 2693 :     obtain_lock( &pDEVBLK->lock );

  00059	48 8b 44 24 70	 mov	 rax, QWORD PTR pDEVBLK$[rsp]
  0005e	48 83 c0 38	 add	 rax, 56			; 00000038H
  00062	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG170110
  00069	48 8b c8	 mov	 rcx, rax
  0006c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_obtain_lock

; 2694 : 
; 2695 :     // Enhanced CTC adapter intiialization for y-side command register.
; 2696 :     pDEVBLK->ctceyCmd = 0x00;

  00072	48 8b 44 24 70	 mov	 rax, QWORD PTR pDEVBLK$[rsp]
  00077	c6 80 37 07 00
	00 00		 mov	 BYTE PTR [rax+1847], 0

; 2697 : 
; 2698 :     // We initialize the device buffer selector variables.
; 2699 :     pDEVBLK->ctce_buf_next_write = pDEVBLK->ctce_buf_next_read = 0;

  0007e	48 8b 44 24 70	 mov	 rax, QWORD PTR pDEVBLK$[rsp]
  00083	8b 80 74 07 00
	00		 mov	 eax, DWORD PTR [rax+1908]
  00089	83 e0 df	 and	 eax, -33		; ffffffdfH
  0008c	48 8b 4c 24 70	 mov	 rcx, QWORD PTR pDEVBLK$[rsp]
  00091	89 81 74 07 00
	00		 mov	 DWORD PTR [rcx+1908], eax
  00097	48 8b 44 24 70	 mov	 rax, QWORD PTR pDEVBLK$[rsp]
  0009c	8b 80 74 07 00
	00		 mov	 eax, DWORD PTR [rax+1908]
  000a2	83 e0 bf	 and	 eax, -65		; ffffffbfH
  000a5	48 8b 4c 24 70	 mov	 rcx, QWORD PTR pDEVBLK$[rsp]
  000aa	89 81 74 07 00
	00		 mov	 DWORD PTR [rcx+1908], eax

; 2700 : 
; 2701 :     // We select the initial device block buffer used for receiving CTC
; 2702 :     // commands to be different from the one used for sending CTC commands.
; 2703 :     pSokBuf = ( CTCE_SOKPFX* ) ( pDEVBLK->buf + ( pDEVBLK->ctce_buf_next_write ? 0 : pDEVBLK->bufsize / 2 ) );

  000b0	48 8b 44 24 70	 mov	 rax, QWORD PTR pDEVBLK$[rsp]
  000b5	8b 80 74 07 00
	00		 mov	 eax, DWORD PTR [rax+1908]
  000bb	c1 e8 06	 shr	 eax, 6
  000be	83 e0 01	 and	 eax, 1
  000c1	85 c0		 test	 eax, eax
  000c3	74 0d		 je	 SHORT $LN53@CTCE_RecvT
  000c5	c7 84 24 30 01
	00 00 00 00 00
	00		 mov	 DWORD PTR tv81[rsp], 0
  000d0	eb 17		 jmp	 SHORT $LN54@CTCE_RecvT
$LN53@CTCE_RecvT:
  000d2	48 8b 44 24 70	 mov	 rax, QWORD PTR pDEVBLK$[rsp]
  000d7	8b 80 d8 01 00
	00		 mov	 eax, DWORD PTR [rax+472]
  000dd	99		 cdq
  000de	2b c2		 sub	 eax, edx
  000e0	d1 f8		 sar	 eax, 1
  000e2	89 84 24 30 01
	00 00		 mov	 DWORD PTR tv81[rsp], eax
$LN54@CTCE_RecvT:
  000e9	48 63 84 24 30
	01 00 00	 movsxd	 rax, DWORD PTR tv81[rsp]
  000f1	48 8b 4c 24 70	 mov	 rcx, QWORD PTR pDEVBLK$[rsp]
  000f6	48 03 81 c8 01
	00 00		 add	 rax, QWORD PTR [rcx+456]
  000fd	48 89 84 24 80
	00 00 00	 mov	 QWORD PTR pSokBuf$[rsp], rax

; 2704 : 
; 2705 :     // CTCE DEVBLK (re-)initialisation completed.
; 2706 :     release_lock( &pDEVBLK->lock );

  00105	48 8b 44 24 70	 mov	 rax, QWORD PTR pDEVBLK$[rsp]
  0010a	48 83 c0 38	 add	 rax, 56			; 00000038H
  0010e	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG170111
  00115	48 8b c8	 mov	 rcx, rax
  00118	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_release_lock

; 2707 : 
; 2708 :     // Initialise our CTCE_Info as needed.
; 2709 :     CTCE_Info.de_ready_attn_rc   = 0;

  0011e	c7 84 24 a0 01
	00 00 00 00 00
	00		 mov	 DWORD PTR CTCE_Info$[rsp+24], 0

; 2710 :     CTCE_Info.working_attn_rc    = 0;

  00129	c7 84 24 a4 01
	00 00 00 00 00
	00		 mov	 DWORD PTR CTCE_Info$[rsp+28], 0

; 2711 :     CTCE_Info.busy_waits         = 0;

  00134	c6 84 24 94 01
	00 00 00	 mov	 BYTE PTR CTCE_Info$[rsp+12], 0
$LN2@CTCE_RecvT:

; 2712 : 
; 2713 :     // This thread will loop until we receive a zero-length packet caused by CTCE_Close from the other side.
; 2714 :     for( ; ; )
; 2715 :     {
; 2716 :         // We read whatever the other (y-)side of the CTC has sent us,
; 2717 :         // which by now won't block until the complete buffer is received.
; 2718 :         iLength = read_socket( pDEVBLK->ctcefd, ( BYTE * ) pSokBuf, pDEVBLK->ctceSndSml );

  0013c	48 8b 44 24 70	 mov	 rax, QWORD PTR pDEVBLK$[rsp]
  00141	44 8b 80 30 07
	00 00		 mov	 r8d, DWORD PTR [rax+1840]
  00148	48 8b 94 24 80
	00 00 00	 mov	 rdx, QWORD PTR pSokBuf$[rsp]
  00150	48 8b 44 24 70	 mov	 rax, QWORD PTR pDEVBLK$[rsp]
  00155	8b 88 3c 07 00
	00		 mov	 ecx, DWORD PTR [rax+1852]
  0015b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_read_socket
  00161	89 84 24 88 00
	00 00		 mov	 DWORD PTR iLength$[rsp], eax

; 2719 : 
; 2720 :         // Followed by the receiving the rest if the default SndLen was too small.
; 2721 :         if( ( pDEVBLK->ctceSndSml < pSokBuf->SndLen ) && ( iLength != 0 ) )

  00168	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR pSokBuf$[rsp]
  00170	0f b7 40 08	 movzx	 eax, WORD PTR [rax+8]
  00174	48 8b 4c 24 70	 mov	 rcx, QWORD PTR pDEVBLK$[rsp]
  00179	39 81 30 07 00
	00		 cmp	 DWORD PTR [rcx+1840], eax
  0017f	7d 64		 jge	 SHORT $LN11@CTCE_RecvT
  00181	83 bc 24 88 00
	00 00 00	 cmp	 DWORD PTR iLength$[rsp], 0
  00189	74 5a		 je	 SHORT $LN11@CTCE_RecvT

; 2722 :             iLength += read_socket( pDEVBLK->ctcefd, ( BYTE * ) pSokBuf + pDEVBLK->ctceSndSml,

  0018b	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR pSokBuf$[rsp]
  00193	0f b7 40 08	 movzx	 eax, WORD PTR [rax+8]
  00197	48 8b 4c 24 70	 mov	 rcx, QWORD PTR pDEVBLK$[rsp]
  0019c	2b 81 30 07 00
	00		 sub	 eax, DWORD PTR [rcx+1840]
  001a2	48 8b 4c 24 70	 mov	 rcx, QWORD PTR pDEVBLK$[rsp]
  001a7	48 63 89 30 07
	00 00		 movsxd	 rcx, DWORD PTR [rcx+1840]
  001ae	48 8b 94 24 80
	00 00 00	 mov	 rdx, QWORD PTR pSokBuf$[rsp]
  001b6	48 03 d1	 add	 rdx, rcx
  001b9	48 8b ca	 mov	 rcx, rdx
  001bc	44 8b c0	 mov	 r8d, eax
  001bf	48 8b d1	 mov	 rdx, rcx
  001c2	48 8b 44 24 70	 mov	 rax, QWORD PTR pDEVBLK$[rsp]
  001c7	8b 88 3c 07 00
	00		 mov	 ecx, DWORD PTR [rax+1852]
  001cd	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_read_socket
  001d3	8b 8c 24 88 00
	00 00		 mov	 ecx, DWORD PTR iLength$[rsp]
  001da	03 c8		 add	 ecx, eax
  001dc	8b c1		 mov	 eax, ecx
  001de	89 84 24 88 00
	00 00		 mov	 DWORD PTR iLength$[rsp], eax
$LN11@CTCE_RecvT:

; 2723 :                 pSokBuf->SndLen - pDEVBLK->ctceSndSml );
; 2724 : 
; 2725 :         // Commands sent by the other (y-)side most likely cause DEVBLK
; 2726 :         // changes to our (x-)side and thus need to be lock protected.
; 2727 :         obtain_lock( &pDEVBLK->lock );

  001e5	48 8b 44 24 70	 mov	 rax, QWORD PTR pDEVBLK$[rsp]
  001ea	48 83 c0 38	 add	 rax, 56			; 00000038H
  001ee	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG170113
  001f5	48 8b c8	 mov	 rcx, rax
  001f8	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_obtain_lock

; 2728 : 
; 2729 :         // An iLength==0 means the other end has closed down the connection,
; 2730 :         // an iLength<0  means a receive error, which in a non-abnormal case
; 2731 :         // can be caused by a DETACH of the CTCE device.  In both cases we
; 2732 :         // close down this thread.
; 2733 :         if( iLength <= 0 )

  001fe	83 bc 24 88 00
	00 00 00	 cmp	 DWORD PTR iLength$[rsp], 0
  00206	0f 8f 6a 02 00
	00		 jg	 $LN12@CTCE_RecvT

; 2734 :         {
; 2735 :             if( iLength < 0 )

  0020c	83 bc 24 88 00
	00 00 00	 cmp	 DWORD PTR iLength$[rsp], 0
  00214	0f 8d d5 00 00
	00		 jge	 $LN13@CTCE_RecvT

; 2736 :             {
; 2737 :                 WRMSG( HHC05077, "E",  /* CTCE: Error reading from %s: %s */

  0021a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_WSAGetLastError
  00220	8b c8		 mov	 ecx, eax
  00222	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_strerror
  00228	48 89 84 24 68
	01 00 00	 mov	 QWORD PTR tv148[rsp], rax
  00230	48 8b 4c 24 70	 mov	 rcx, QWORD PTR pDEVBLK$[rsp]
  00235	48 81 c1 a4 00
	00 00		 add	 rcx, 164		; 000000a4H
  0023c	48 89 8c 24 70
	01 00 00	 mov	 QWORD PTR tv152[rsp], rcx
  00244	48 8b 54 24 70	 mov	 rdx, QWORD PTR pDEVBLK$[rsp]
  00249	0f b7 52 48	 movzx	 edx, WORD PTR [rdx+72]
  0024d	89 94 24 4c 01
	00 00		 mov	 DWORD PTR tv155[rsp], edx
  00254	4c 8b 44 24 70	 mov	 r8, QWORD PTR pDEVBLK$[rsp]
  00259	45 0f b7 40 44	 movzx	 r8d, WORD PTR [r8+68]
  0025e	41 d1 f8	 sar	 r8d, 1
  00261	44 89 84 24 50
	01 00 00	 mov	 DWORD PTR tv159[rsp], r8d
  00269	b9 01 00 00 00	 mov	 ecx, 1
  0026e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  00274	48 8b 8c 24 68
	01 00 00	 mov	 rcx, QWORD PTR tv148[rsp]
  0027c	48 89 4c 24 50	 mov	 QWORD PTR [rsp+80], rcx
  00281	48 8b 8c 24 70
	01 00 00	 mov	 rcx, QWORD PTR tv152[rsp]
  00289	48 89 4c 24 48	 mov	 QWORD PTR [rsp+72], rcx
  0028e	8b 8c 24 4c 01
	00 00		 mov	 ecx, DWORD PTR tv155[rsp]
  00295	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  00299	8b 8c 24 50 01
	00 00		 mov	 ecx, DWORD PTR tv159[rsp]
  002a0	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  002a4	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170116
  002ab	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  002b0	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170117
  002b7	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  002bc	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  002c1	41 b9 03 00 00
	00		 mov	 r9d, 3
  002c7	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG170118
  002ce	ba b2 0a 00 00	 mov	 edx, 2738		; 00000ab2H
  002d3	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170119
  002da	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 2738 :                     CTCX_DEVNUM( pDEVBLK ), pDEVBLK->filename, strerror ( HSO_errno ) );
; 2739 :                 CTCE_ERROR_CCWTRACE( pDEVBLK );

  002e0	48 8b 44 24 70	 mov	 rax, QWORD PTR pDEVBLK$[rsp]
  002e5	c7 80 68 07 00
	00 14 00 00 00	 mov	 DWORD PTR [rax+1896], 20
$LN13@CTCE_RecvT:

; 2740 :             }
; 2741 : 
; 2742 :             // When this was not caused by a read error, or when shutting down, then we close the CTCE device.
; 2743 :             if( ( iLength == 0 ) || ( sysblk.shutdown ) )

  002ef	83 bc 24 88 00
	00 00 00	 cmp	 DWORD PTR iLength$[rsp], 0
  002f7	74 1b		 je	 SHORT $LN15@CTCE_RecvT
  002f9	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00300	8b 80 94 12 00
	00		 mov	 eax, DWORD PTR [rax+4756]
  00306	c1 e8 0b	 shr	 eax, 11
  00309	83 e0 01	 and	 eax, 1
  0030c	85 c0		 test	 eax, eax
  0030e	0f 84 02 01 00
	00		 je	 $LN14@CTCE_RecvT
$LN15@CTCE_RecvT:

; 2744 :             {
; 2745 :                 // We report some statistics.
; 2746 :                 WRMSG( HHC05076, "I",  // CTCE: Connection closed; %"PRIu64" MB received in %"PRIu64" packets from %s; shutdown=%d"

  00314	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  0031b	8b 80 94 12 00
	00		 mov	 eax, DWORD PTR [rax+4756]
  00321	c1 e8 0b	 shr	 eax, 11
  00324	83 e0 01	 and	 eax, 1
  00327	89 84 24 38 01
	00 00		 mov	 DWORD PTR tv178[rsp], eax
  0032e	48 8b 4c 24 70	 mov	 rcx, QWORD PTR pDEVBLK$[rsp]
  00333	48 81 c1 a4 00
	00 00		 add	 rcx, 164		; 000000a4H
  0033a	48 89 8c 24 78
	01 00 00	 mov	 QWORD PTR tv180[rsp], rcx
  00342	48 8b 94 24 60
	01 00 00	 mov	 rdx, QWORD PTR ctceBytCnt$[rsp]
  0034a	48 c1 ea 14	 shr	 rdx, 20
  0034e	48 89 94 24 80
	01 00 00	 mov	 QWORD PTR tv183[rsp], rdx
  00356	4c 8b 44 24 70	 mov	 r8, QWORD PTR pDEVBLK$[rsp]
  0035b	45 0f b7 40 48	 movzx	 r8d, WORD PTR [r8+72]
  00360	44 89 84 24 3c
	01 00 00	 mov	 DWORD PTR tv186[rsp], r8d
  00368	4c 8b 4c 24 70	 mov	 r9, QWORD PTR pDEVBLK$[rsp]
  0036d	45 0f b7 49 44	 movzx	 r9d, WORD PTR [r9+68]
  00372	41 d1 f9	 sar	 r9d, 1
  00375	44 89 8c 24 40
	01 00 00	 mov	 DWORD PTR tv190[rsp], r9d
  0037d	b9 01 00 00 00	 mov	 ecx, 1
  00382	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  00388	8b 8c 24 38 01
	00 00		 mov	 ecx, DWORD PTR tv178[rsp]
  0038f	89 4c 24 60	 mov	 DWORD PTR [rsp+96], ecx
  00393	48 8b 8c 24 78
	01 00 00	 mov	 rcx, QWORD PTR tv180[rsp]
  0039b	48 89 4c 24 58	 mov	 QWORD PTR [rsp+88], rcx
  003a0	48 8b 8c 24 58
	01 00 00	 mov	 rcx, QWORD PTR ctcePktCnt$[rsp]
  003a8	48 89 4c 24 50	 mov	 QWORD PTR [rsp+80], rcx
  003ad	48 8b 8c 24 80
	01 00 00	 mov	 rcx, QWORD PTR tv183[rsp]
  003b5	48 89 4c 24 48	 mov	 QWORD PTR [rsp+72], rcx
  003ba	8b 8c 24 3c 01
	00 00		 mov	 ecx, DWORD PTR tv186[rsp]
  003c1	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  003c5	8b 8c 24 40 01
	00 00		 mov	 ecx, DWORD PTR tv190[rsp]
  003cc	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  003d0	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170122
  003d7	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  003dc	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170123
  003e3	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  003e8	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  003ed	41 b9 03 00 00
	00		 mov	 r9d, 3
  003f3	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG170124
  003fa	ba bb 0a 00 00	 mov	 edx, 2747		; 00000abbH
  003ff	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170125
  00406	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 2747 :                     CTCX_DEVNUM( pDEVBLK ), ctceBytCnt >> SHIFT_MEGABYTE , ctcePktCnt, pDEVBLK->filename, sysblk.shutdown );
; 2748 : 
; 2749 :                 CTCE_Close( pDEVBLK );

  0040c	48 8b 4c 24 70	 mov	 rcx, QWORD PTR pDEVBLK$[rsp]
  00411	e8 00 00 00 00	 call	 CTCE_Close
$LN14@CTCE_RecvT:

; 2750 :             }
; 2751 : 
; 2752 :             // A CTCE Recovery (i.e. a devinit) is done in either case, error
; 2753 :             // or partner shutdown, as long as we are not shutting down.
; 2754 :             if( !sysblk.shutdown )

  00416	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  0041d	8b 80 94 12 00
	00		 mov	 eax, DWORD PTR [rax+4756]
  00423	c1 e8 0b	 shr	 eax, 11
  00426	83 e0 01	 and	 eax, 1
  00429	85 c0		 test	 eax, eax
  0042b	75 29		 jne	 SHORT $LN16@CTCE_RecvT

; 2755 :             {
; 2756 :                 (void) CTCE_Recovery( pDEVBLK ) ;

  0042d	48 8b 4c 24 70	 mov	 rcx, QWORD PTR pDEVBLK$[rsp]
  00432	e8 00 00 00 00	 call	 CTCE_Recovery

; 2757 :                 CTCE_RESTART_CCWTRACE( pDEVBLK );

  00437	48 8b 44 24 70	 mov	 rax, QWORD PTR pDEVBLK$[rsp]
  0043c	83 b8 68 07 00
	00 00		 cmp	 DWORD PTR [rax+1896], 0
  00443	7c 11		 jl	 SHORT $LN55@CTCE_RecvT
  00445	48 8b 44 24 70	 mov	 rax, QWORD PTR pDEVBLK$[rsp]
  0044a	c7 80 68 07 00
	00 14 00 00 00	 mov	 DWORD PTR [rax+1896], 20
  00454	33 c0		 xor	 eax, eax
$LN55@CTCE_RecvT:
$LN16@CTCE_RecvT:

; 2758 :             }
; 2759 :             release_lock( &pDEVBLK->lock );

  00456	48 8b 44 24 70	 mov	 rax, QWORD PTR pDEVBLK$[rsp]
  0045b	48 83 c0 38	 add	 rax, 56			; 00000038H
  0045f	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG170127
  00466	48 8b c8	 mov	 rcx, rax
  00469	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_release_lock

; 2760 :             return NULL;    // make compiler happy

  0046f	33 c0		 xor	 eax, eax
  00471	e9 9f 14 00 00	 jmp	 $LN1@CTCE_RecvT
$LN12@CTCE_RecvT:

; 2761 :         } // if( iLength <= 0 )
; 2762 : 
; 2763 :         // As CTCE Reset received from the other (y-)side will cause our (x-)side
; 2764 :         // Sense bit 1 (Intervention Required) to be set, and for a selective
; 2765 :         // reset also bit 7 (Interface Discconect / Operation Check).
; 2766 :         if( IS_CTCE_RST( pSokBuf->CmdReg ) )

  00476	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR pSokBuf$[rsp]
  0047e	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  00481	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:CTCE_command
  00488	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  0048c	83 f8 0e	 cmp	 eax, 14
  0048f	0f 85 fb 00 00
	00		 jne	 $LN17@CTCE_RecvT

; 2767 :         {
; 2768 :             pDEVBLK->sense[0] |= SENSE_IR;

  00495	b8 01 00 00 00	 mov	 eax, 1
  0049a	48 6b c0 00	 imul	 rax, rax, 0
  0049e	48 8b 4c 24 70	 mov	 rcx, QWORD PTR pDEVBLK$[rsp]
  004a3	0f b6 84 01 64
	03 00 00	 movzx	 eax, BYTE PTR [rcx+rax+868]
  004ab	83 c8 40	 or	 eax, 64			; 00000040H
  004ae	b9 01 00 00 00	 mov	 ecx, 1
  004b3	48 6b c9 00	 imul	 rcx, rcx, 0
  004b7	48 8b 54 24 70	 mov	 rdx, QWORD PTR pDEVBLK$[rsp]
  004bc	88 84 0a 64 03
	00 00		 mov	 BYTE PTR [rdx+rcx+868], al

; 2769 :             if( !sysblk.shutdown )

  004c3	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  004ca	8b 80 94 12 00
	00		 mov	 eax, DWORD PTR [rax+4756]
  004d0	c1 e8 0b	 shr	 eax, 11
  004d3	83 e0 01	 and	 eax, 1
  004d6	85 c0		 test	 eax, eax
  004d8	75 2e		 jne	 SHORT $LN19@CTCE_RecvT

; 2770 :             {
; 2771 :                 pDEVBLK->sense[0] |= SENSE_OC;

  004da	b8 01 00 00 00	 mov	 eax, 1
  004df	48 6b c0 00	 imul	 rax, rax, 0
  004e3	48 8b 4c 24 70	 mov	 rcx, QWORD PTR pDEVBLK$[rsp]
  004e8	0f b6 84 01 64
	03 00 00	 movzx	 eax, BYTE PTR [rcx+rax+868]
  004f0	83 c8 01	 or	 eax, 1
  004f3	b9 01 00 00 00	 mov	 ecx, 1
  004f8	48 6b c9 00	 imul	 rcx, rcx, 0
  004fc	48 8b 54 24 70	 mov	 rdx, QWORD PTR pDEVBLK$[rsp]
  00501	88 84 0a 64 03
	00 00		 mov	 BYTE PTR [rdx+rcx+868], al
$LN19@CTCE_RecvT:

; 2772 :             }
; 2773 : 
; 2774 :             // Any WRITE data in the reception buffer won't be used anymore.
; 2775 :             pDEVBLK->ctce_buf_next_read = pDEVBLK->ctce_buf_next_write;

  00508	48 8b 44 24 70	 mov	 rax, QWORD PTR pDEVBLK$[rsp]
  0050d	8b 80 74 07 00
	00		 mov	 eax, DWORD PTR [rax+1908]
  00513	c1 e8 06	 shr	 eax, 6
  00516	83 e0 01	 and	 eax, 1
  00519	83 e0 01	 and	 eax, 1
  0051c	c1 e0 05	 shl	 eax, 5
  0051f	48 8b 4c 24 70	 mov	 rcx, QWORD PTR pDEVBLK$[rsp]
  00524	8b 89 74 07 00
	00		 mov	 ecx, DWORD PTR [rcx+1908]
  0052a	83 e1 df	 and	 ecx, -33		; ffffffdfH
  0052d	0b c8		 or	 ecx, eax
  0052f	8b c1		 mov	 eax, ecx
  00531	48 8b 4c 24 70	 mov	 rcx, QWORD PTR pDEVBLK$[rsp]
  00536	89 81 74 07 00
	00		 mov	 DWORD PTR [rcx+1908], eax

; 2776 : 
; 2777 :             // The remote extended mode setting was also reset to its initial value.
; 2778 :             pDEVBLK->ctce_remote_xmode = (*(pDEVBLK->devid+6) == 0x00 ) ? 1 : 0 ;

  0053c	48 8b 44 24 70	 mov	 rax, QWORD PTR pDEVBLK$[rsp]
  00541	0f b6 80 6e 04
	00 00		 movzx	 eax, BYTE PTR [rax+1134]
  00548	85 c0		 test	 eax, eax
  0054a	75 0d		 jne	 SHORT $LN56@CTCE_RecvT
  0054c	c7 84 24 34 01
	00 00 01 00 00
	00		 mov	 DWORD PTR tv256[rsp], 1
  00557	eb 0b		 jmp	 SHORT $LN57@CTCE_RecvT
$LN56@CTCE_RecvT:
  00559	c7 84 24 34 01
	00 00 00 00 00
	00		 mov	 DWORD PTR tv256[rsp], 0
$LN57@CTCE_RecvT:
  00564	8b 84 24 34 01
	00 00		 mov	 eax, DWORD PTR tv256[rsp]
  0056b	83 e0 01	 and	 eax, 1
  0056e	c1 e0 03	 shl	 eax, 3
  00571	48 8b 4c 24 70	 mov	 rcx, QWORD PTR pDEVBLK$[rsp]
  00576	8b 89 74 07 00
	00		 mov	 ecx, DWORD PTR [rcx+1908]
  0057c	83 e1 f7	 and	 ecx, -9			; fffffff7H
  0057f	0b c8		 or	 ecx, eax
  00581	8b c1		 mov	 eax, ecx
  00583	48 8b 4c 24 70	 mov	 rcx, QWORD PTR pDEVBLK$[rsp]
  00588	89 81 74 07 00
	00		 mov	 DWORD PTR [rcx+1908], eax

; 2779 : 
; 2780 :         }

  0058e	eb 47		 jmp	 SHORT $LN18@CTCE_RecvT
$LN17@CTCE_RecvT:

; 2781 : 
; 2782 :         // As SAS / SID commands are never sent accross, anything else we receive
; 2783 :         // from the y-side will cause a reset of sense byte 0 bits 1 and 7.
; 2784 :         else
; 2785 :         {
; 2786 :            pDEVBLK->sense[0] &= ~( SENSE_IR | SENSE_OC );

  00590	b8 01 00 00 00	 mov	 eax, 1
  00595	48 6b c0 00	 imul	 rax, rax, 0
  00599	48 8b 4c 24 70	 mov	 rcx, QWORD PTR pDEVBLK$[rsp]
  0059e	0f b6 84 01 64
	03 00 00	 movzx	 eax, BYTE PTR [rcx+rax+868]
  005a6	83 e0 be	 and	 eax, -66		; ffffffffffffffbeH
  005a9	b9 01 00 00 00	 mov	 ecx, 1
  005ae	48 6b c9 00	 imul	 rcx, rcx, 0
  005b2	48 8b 54 24 70	 mov	 rdx, QWORD PTR pDEVBLK$[rsp]
  005b7	88 84 0a 64 03
	00 00		 mov	 BYTE PTR [rdx+rcx+868], al

; 2787 :            pDEVBLK->ctce_system_reset = 0;

  005be	48 8b 44 24 70	 mov	 rax, QWORD PTR pDEVBLK$[rsp]
  005c3	8b 80 74 07 00
	00		 mov	 eax, DWORD PTR [rax+1908]
  005c9	83 e0 ef	 and	 eax, -17		; ffffffefH
  005cc	48 8b 4c 24 70	 mov	 rcx, QWORD PTR pDEVBLK$[rsp]
  005d1	89 81 74 07 00
	00		 mov	 DWORD PTR [rcx+1908], eax
$LN18@CTCE_RecvT:

; 2788 :         }
; 2789 : 
; 2790 :         // Update the Receive statistics counters.
; 2791 :         ctcePktCnt += 1 ;

  005d7	48 8b 84 24 58
	01 00 00	 mov	 rax, QWORD PTR ctcePktCnt$[rsp]
  005df	48 ff c0	 inc	 rax
  005e2	48 89 84 24 58
	01 00 00	 mov	 QWORD PTR ctcePktCnt$[rsp], rax

; 2792 :         ctceBytCnt += iLength ;

  005ea	48 63 84 24 88
	00 00 00	 movsxd	 rax, DWORD PTR iLength$[rsp]
  005f2	48 8b 8c 24 60
	01 00 00	 mov	 rcx, QWORD PTR ctceBytCnt$[rsp]
  005fa	48 03 c8	 add	 rcx, rax
  005fd	48 8b c1	 mov	 rax, rcx
  00600	48 89 84 24 60
	01 00 00	 mov	 QWORD PTR ctceBytCnt$[rsp], rax

; 2793 : 
; 2794 :         // Initialise the UnitStat modifications.
; 2795 :         ctce_recv_mods_UnitStat = 0;

  00608	c6 44 24 78 00	 mov	 BYTE PTR ctce_recv_mods_UnitStat$[rsp], 0

; 2796 : 
; 2797 :         // Save the previous CTCE states both on
; 2798 :         // our (x-)side as well as the other (y-)side.
; 2799 :         CTCE_Info.state_x_prev = pDEVBLK->ctcexState;

  0060d	48 8b 44 24 70	 mov	 rax, QWORD PTR pDEVBLK$[rsp]
  00612	0f b6 80 34 07
	00 00		 movzx	 eax, BYTE PTR [rax+1844]
  00619	88 84 24 8c 01
	00 00		 mov	 BYTE PTR CTCE_Info$[rsp+4], al

; 2800 :         CTCE_Info.state_y_prev = pDEVBLK->ctceyState;

  00620	48 8b 44 24 70	 mov	 rax, QWORD PTR pDEVBLK$[rsp]
  00625	0f b6 80 36 07
	00 00		 movzx	 eax, BYTE PTR [rax+1846]
  0062c	88 84 24 8d 01
	00 00		 mov	 BYTE PTR CTCE_Info$[rsp+5], al

; 2801 : 
; 2802 :         // Assume no contention loser or winner.
; 2803 :         CTCE_Info.con_lost = 0;

  00633	8b 84 24 98 01
	00 00		 mov	 eax, DWORD PTR CTCE_Info$[rsp+16]
  0063a	83 e0 fb	 and	 eax, -5			; fffffffbH
  0063d	89 84 24 98 01
	00 00		 mov	 DWORD PTR CTCE_Info$[rsp+16], eax

; 2804 :         CTCE_Info.con_won = 0;

  00644	8b 84 24 98 01
	00 00		 mov	 eax, DWORD PTR CTCE_Info$[rsp+16]
  0064b	83 e0 f7	 and	 eax, -9			; fffffff7H
  0064e	89 84 24 98 01
	00 00		 mov	 DWORD PTR CTCE_Info$[rsp+16], eax

; 2805 : 
; 2806 :         // If the other (y-)side sent us a dependent command that would
; 2807 :         // result in a BUSY+ATTN device status, then we have a command
; 2808 :         // collision, caused by the crossing of the transmissions.
; 2809 :         // (Please note that a non-dependent command is just executed,
; 2810 :         // i.e. treated as if it came just ahead of our dependent one.)
; 2811 :         // We use the FSM table to make the decision :
; 2812 :         if( ( CSW_BUSY | CSW_ATTN ) ==  CTCE_Fsm[CTCE_CMD( pSokBuf->CmdReg )]
; 2813 :                                                 [CTCE_Y_STATE_FSM_IDX].x_unit_stat
; 2814 :             && IS_CTCE_CCW_DEP( pSokBuf->CmdReg ) )

  00655	48 8b 44 24 70	 mov	 rax, QWORD PTR pDEVBLK$[rsp]
  0065a	8b 80 18 07 00
	00		 mov	 eax, DWORD PTR [rax+1816]
  00660	83 e0 01	 and	 eax, 1
  00663	85 c0		 test	 eax, eax
  00665	75 6a		 jne	 SHORT $LN58@CTCE_RecvT
  00667	48 8b 44 24 70	 mov	 rax, QWORD PTR pDEVBLK$[rsp]
  0066c	8b 80 74 07 00
	00		 mov	 eax, DWORD PTR [rax+1908]
  00672	c1 e8 03	 shr	 eax, 3
  00675	83 e0 01	 and	 eax, 1
  00678	85 c0		 test	 eax, eax
  0067a	75 55		 jne	 SHORT $LN58@CTCE_RecvT
  0067c	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR pSokBuf$[rsp]
  00684	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  00687	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:CTCE_command
  0068e	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00692	83 f8 07	 cmp	 eax, 7
  00695	75 0d		 jne	 SHORT $LN59@CTCE_RecvT
  00697	c7 84 24 90 00
	00 00 03 00 00
	00		 mov	 DWORD PTR tv304[rsp], 3
  006a2	eb 1d		 jmp	 SHORT $LN60@CTCE_RecvT
$LN59@CTCE_RecvT:
  006a4	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR pSokBuf$[rsp]
  006ac	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  006af	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:CTCE_command
  006b6	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  006ba	89 84 24 90 00
	00 00		 mov	 DWORD PTR tv304[rsp], eax
$LN60@CTCE_RecvT:
  006c1	8b 84 24 90 00
	00 00		 mov	 eax, DWORD PTR tv304[rsp]
  006c8	89 84 24 9c 00
	00 00		 mov	 DWORD PTR tv305[rsp], eax
  006cf	eb 1d		 jmp	 SHORT $LN61@CTCE_RecvT
$LN58@CTCE_RecvT:
  006d1	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR pSokBuf$[rsp]
  006d9	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  006dc	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:CTCE_command
  006e3	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  006e7	89 84 24 9c 00
	00 00		 mov	 DWORD PTR tv305[rsp], eax
$LN61@CTCE_RecvT:
  006ee	48 8b 44 24 70	 mov	 rax, QWORD PTR pDEVBLK$[rsp]
  006f3	0f b6 80 36 07
	00 00		 movzx	 eax, BYTE PTR [rax+1846]
  006fa	83 e0 04	 and	 eax, 4
  006fd	85 c0		 test	 eax, eax
  006ff	75 10		 jne	 SHORT $LN66@CTCE_RecvT
  00701	c7 84 24 a0 00
	00 00 06 00 00
	00		 mov	 DWORD PTR tv332[rsp], 6
  0070c	e9 92 00 00 00	 jmp	 $LN67@CTCE_RecvT
$LN66@CTCE_RecvT:
  00711	48 8b 44 24 70	 mov	 rax, QWORD PTR pDEVBLK$[rsp]
  00716	8b 80 18 07 00
	00		 mov	 eax, DWORD PTR [rax+1816]
  0071c	83 e0 01	 and	 eax, 1
  0071f	85 c0		 test	 eax, eax
  00721	75 5c		 jne	 SHORT $LN62@CTCE_RecvT
  00723	48 8b 44 24 70	 mov	 rax, QWORD PTR pDEVBLK$[rsp]
  00728	8b 80 74 07 00
	00		 mov	 eax, DWORD PTR [rax+1908]
  0072e	c1 e8 03	 shr	 eax, 3
  00731	83 e0 01	 and	 eax, 1
  00734	85 c0		 test	 eax, eax
  00736	75 47		 jne	 SHORT $LN62@CTCE_RecvT
  00738	48 8b 44 24 70	 mov	 rax, QWORD PTR pDEVBLK$[rsp]
  0073d	0f b6 80 34 07
	00 00		 movzx	 eax, BYTE PTR [rax+1844]
  00744	83 e0 07	 and	 eax, 7
  00747	83 f8 05	 cmp	 eax, 5
  0074a	75 0d		 jne	 SHORT $LN63@CTCE_RecvT
  0074c	c7 84 24 94 00
	00 00 04 00 00
	00		 mov	 DWORD PTR tv330[rsp], 4
  00757	eb 16		 jmp	 SHORT $LN64@CTCE_RecvT
$LN63@CTCE_RecvT:
  00759	48 8b 44 24 70	 mov	 rax, QWORD PTR pDEVBLK$[rsp]
  0075e	0f b6 80 34 07
	00 00		 movzx	 eax, BYTE PTR [rax+1844]
  00765	83 e0 07	 and	 eax, 7
  00768	89 84 24 94 00
	00 00		 mov	 DWORD PTR tv330[rsp], eax
$LN64@CTCE_RecvT:
  0076f	8b 84 24 94 00
	00 00		 mov	 eax, DWORD PTR tv330[rsp]
  00776	89 84 24 98 00
	00 00		 mov	 DWORD PTR tv331[rsp], eax
  0077d	eb 16		 jmp	 SHORT $LN65@CTCE_RecvT
$LN62@CTCE_RecvT:
  0077f	48 8b 44 24 70	 mov	 rax, QWORD PTR pDEVBLK$[rsp]
  00784	0f b6 80 34 07
	00 00		 movzx	 eax, BYTE PTR [rax+1844]
  0078b	83 e0 07	 and	 eax, 7
  0078e	89 84 24 98 00
	00 00		 mov	 DWORD PTR tv331[rsp], eax
$LN65@CTCE_RecvT:
  00795	8b 84 24 98 00
	00 00		 mov	 eax, DWORD PTR tv331[rsp]
  0079c	89 84 24 a0 00
	00 00		 mov	 DWORD PTR tv332[rsp], eax
$LN67@CTCE_RecvT:
  007a3	48 63 84 24 9c
	00 00 00	 movsxd	 rax, DWORD PTR tv305[rsp]
  007ab	48 6b c0 20	 imul	 rax, rax, 32		; 00000020H
  007af	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:CTCE_Fsm
  007b6	48 03 c8	 add	 rcx, rax
  007b9	48 8b c1	 mov	 rax, rcx
  007bc	48 63 8c 24 a0
	00 00 00	 movsxd	 rcx, DWORD PTR tv332[rsp]
  007c4	0f b6 44 88 01	 movzx	 eax, BYTE PTR [rax+rcx*4+1]
  007c9	3d 90 00 00 00	 cmp	 eax, 144		; 00000090H
  007ce	0f 85 5d 01 00
	00		 jne	 $LN20@CTCE_RecvT
  007d4	48 8b 44 24 70	 mov	 rax, QWORD PTR pDEVBLK$[rsp]
  007d9	8b 80 18 07 00
	00		 mov	 eax, DWORD PTR [rax+1816]
  007df	83 e0 01	 and	 eax, 1
  007e2	85 c0		 test	 eax, eax
  007e4	75 6a		 jne	 SHORT $LN68@CTCE_RecvT
  007e6	48 8b 44 24 70	 mov	 rax, QWORD PTR pDEVBLK$[rsp]
  007eb	8b 80 74 07 00
	00		 mov	 eax, DWORD PTR [rax+1908]
  007f1	c1 e8 03	 shr	 eax, 3
  007f4	83 e0 01	 and	 eax, 1
  007f7	85 c0		 test	 eax, eax
  007f9	75 55		 jne	 SHORT $LN68@CTCE_RecvT
  007fb	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR pSokBuf$[rsp]
  00803	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  00806	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:CTCE_command
  0080d	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00811	83 f8 07	 cmp	 eax, 7
  00814	75 0d		 jne	 SHORT $LN69@CTCE_RecvT
  00816	c7 84 24 a4 00
	00 00 03 00 00
	00		 mov	 DWORD PTR tv362[rsp], 3
  00821	eb 1d		 jmp	 SHORT $LN70@CTCE_RecvT
$LN69@CTCE_RecvT:
  00823	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR pSokBuf$[rsp]
  0082b	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  0082e	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:CTCE_command
  00835	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00839	89 84 24 a4 00
	00 00		 mov	 DWORD PTR tv362[rsp], eax
$LN70@CTCE_RecvT:
  00840	8b 84 24 a4 00
	00 00		 mov	 eax, DWORD PTR tv362[rsp]
  00847	89 84 24 a8 00
	00 00		 mov	 DWORD PTR tv363[rsp], eax
  0084e	eb 1d		 jmp	 SHORT $LN71@CTCE_RecvT
$LN68@CTCE_RecvT:
  00850	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR pSokBuf$[rsp]
  00858	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  0085b	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:CTCE_command
  00862	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00866	89 84 24 a8 00
	00 00		 mov	 DWORD PTR tv363[rsp], eax
$LN71@CTCE_RecvT:
  0086d	83 bc 24 a8 00
	00 00 07	 cmp	 DWORD PTR tv363[rsp], 7
  00875	0f 8d b6 00 00
	00		 jge	 $LN20@CTCE_RecvT

; 2815 :         {
; 2816 : 
; 2817 :             // We will cancel our (x-)side dependent command provided
; 2818 :             // the (y-)side command was NOT a Write EOF, and that we
; 2819 :             // are currently the contention losing side.  This avoids
; 2820 :             // the deadlock when both sides would wait for a matching
; 2821 :             // command that could never arrive.
; 2822 :             if( pDEVBLK->ctce_contention_loser )

  0087b	48 8b 44 24 70	 mov	 rax, QWORD PTR pDEVBLK$[rsp]
  00880	8b 80 74 07 00
	00		 mov	 eax, DWORD PTR [rax+1908]
  00886	83 e0 01	 and	 eax, 1
  00889	85 c0		 test	 eax, eax
  0088b	0f 84 8f 00 00
	00		 je	 $LN21@CTCE_RecvT

; 2823 :             {
; 2824 : 
; 2825 :                 // This is done by signaling our awaiting (x-)side as
; 2826 :                 // if a matching command was received after having
; 2827 :                 // reset our state to the prior Available state and
; 2828 :                 // and ensuring a resulting BUSY+ATTN device status.
; 2829 :                 SET_CTCE_YAV( pDEVBLK->ctcexState );

  00891	48 8b 44 24 70	 mov	 rax, QWORD PTR pDEVBLK$[rsp]
  00896	0f b6 80 34 07
	00 00		 movzx	 eax, BYTE PTR [rax+1844]
  0089d	25 f8 00 00 00	 and	 eax, 248		; 000000f8H
  008a2	83 c8 04	 or	 eax, 4
  008a5	48 8b 4c 24 70	 mov	 rcx, QWORD PTR pDEVBLK$[rsp]
  008aa	88 81 34 07 00
	00		 mov	 BYTE PTR [rcx+1844], al

; 2830 :                 pDEVBLK->ctce_UnitStat = CSW_BUSY | CSW_ATTN;

  008b0	48 8b 44 24 70	 mov	 rax, QWORD PTR pDEVBLK$[rsp]
  008b5	c6 80 39 07 00
	00 90		 mov	 BYTE PTR [rax+1849], 144 ; 00000090H

; 2831 :                 obtain_lock( &pDEVBLK->ctceEventLock );

  008bc	48 8b 44 24 70	 mov	 rax, QWORD PTR pDEVBLK$[rsp]
  008c1	48 05 40 07 00
	00		 add	 rax, 1856		; 00000740H
  008c7	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG170134
  008ce	48 8b c8	 mov	 rcx, rax
  008d1	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_obtain_lock

; 2832 :                 signal_condition( &pDEVBLK->ctceEvent );

  008d7	48 8b 44 24 70	 mov	 rax, QWORD PTR pDEVBLK$[rsp]
  008dc	48 05 48 07 00
	00		 add	 rax, 1864		; 00000748H
  008e2	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG170135
  008e9	48 8b c8	 mov	 rcx, rax
  008ec	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_signal_condition

; 2833 :                 release_lock( &pDEVBLK->ctceEventLock );

  008f2	48 8b 44 24 70	 mov	 rax, QWORD PTR pDEVBLK$[rsp]
  008f7	48 05 40 07 00
	00		 add	 rax, 1856		; 00000740H
  008fd	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG170136
  00904	48 8b c8	 mov	 rcx, rax
  00907	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_release_lock

; 2834 : 
; 2835 :                 // For CTCE_Trace purposes ...
; 2836 :                 CTCE_Info.con_lost = 1;

  0090d	8b 84 24 98 01
	00 00		 mov	 eax, DWORD PTR CTCE_Info$[rsp+16]
  00914	83 c8 04	 or	 eax, 4
  00917	89 84 24 98 01
	00 00		 mov	 DWORD PTR CTCE_Info$[rsp+16], eax

; 2837 :             }

  0091e	eb 11		 jmp	 SHORT $LN22@CTCE_RecvT
$LN21@CTCE_RecvT:

; 2838 :             else
; 2839 :             {
; 2840 :                 CTCE_Info.con_won = 1;

  00920	8b 84 24 98 01
	00 00		 mov	 eax, DWORD PTR CTCE_Info$[rsp+16]
  00927	83 c8 08	 or	 eax, 8
  0092a	89 84 24 98 01
	00 00		 mov	 DWORD PTR CTCE_Info$[rsp+16], eax
$LN22@CTCE_RecvT:
$LN20@CTCE_RecvT:

; 2841 :             }
; 2842 :         }
; 2843 : 
; 2844 :         // When no command collision occurred or our (x-)side is not the
; 2845 :         // contention winner, the other (y-)side command received will be acted upon.
; 2846 :         if( CTCE_Info.con_won != 1 )

  00931	8b 84 24 98 01
	00 00		 mov	 eax, DWORD PTR CTCE_Info$[rsp+16]
  00938	c1 e8 03	 shr	 eax, 3
  0093b	83 e0 01	 and	 eax, 1
  0093e	83 f8 01	 cmp	 eax, 1
  00941	0f 84 97 0e 00
	00		 je	 $LN23@CTCE_RecvT

; 2847 :         {
; 2848 : 
; 2849 :             // The command received from the other (y-)side may cause a
; 2850 :             // state transition on our (x-)side, as well as some actions.
; 2851 :             // Both depend on our current (x-)side state and are encoded
; 2852 :             // within the FSM table.
; 2853 :             CTCE_Info.state_new = CTCE_NEW_Y_STATE( pSokBuf->CmdReg );

  00947	48 8b 44 24 70	 mov	 rax, QWORD PTR pDEVBLK$[rsp]
  0094c	8b 80 18 07 00
	00		 mov	 eax, DWORD PTR [rax+1816]
  00952	83 e0 01	 and	 eax, 1
  00955	85 c0		 test	 eax, eax
  00957	75 6a		 jne	 SHORT $LN72@CTCE_RecvT
  00959	48 8b 44 24 70	 mov	 rax, QWORD PTR pDEVBLK$[rsp]
  0095e	8b 80 74 07 00
	00		 mov	 eax, DWORD PTR [rax+1908]
  00964	c1 e8 03	 shr	 eax, 3
  00967	83 e0 01	 and	 eax, 1
  0096a	85 c0		 test	 eax, eax
  0096c	75 55		 jne	 SHORT $LN72@CTCE_RecvT
  0096e	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR pSokBuf$[rsp]
  00976	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  00979	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:CTCE_command
  00980	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00984	83 f8 07	 cmp	 eax, 7
  00987	75 0d		 jne	 SHORT $LN73@CTCE_RecvT
  00989	c7 84 24 ac 00
	00 00 03 00 00
	00		 mov	 DWORD PTR tv412[rsp], 3
  00994	eb 1d		 jmp	 SHORT $LN74@CTCE_RecvT
$LN73@CTCE_RecvT:
  00996	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR pSokBuf$[rsp]
  0099e	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  009a1	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:CTCE_command
  009a8	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  009ac	89 84 24 ac 00
	00 00		 mov	 DWORD PTR tv412[rsp], eax
$LN74@CTCE_RecvT:
  009b3	8b 84 24 ac 00
	00 00		 mov	 eax, DWORD PTR tv412[rsp]
  009ba	89 84 24 b8 00
	00 00		 mov	 DWORD PTR tv413[rsp], eax
  009c1	eb 1d		 jmp	 SHORT $LN75@CTCE_RecvT
$LN72@CTCE_RecvT:
  009c3	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR pSokBuf$[rsp]
  009cb	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  009ce	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:CTCE_command
  009d5	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  009d9	89 84 24 b8 00
	00 00		 mov	 DWORD PTR tv413[rsp], eax
$LN75@CTCE_RecvT:
  009e0	48 8b 44 24 70	 mov	 rax, QWORD PTR pDEVBLK$[rsp]
  009e5	0f b6 80 36 07
	00 00		 movzx	 eax, BYTE PTR [rax+1846]
  009ec	83 e0 04	 and	 eax, 4
  009ef	85 c0		 test	 eax, eax
  009f1	75 10		 jne	 SHORT $LN80@CTCE_RecvT
  009f3	c7 84 24 bc 00
	00 00 06 00 00
	00		 mov	 DWORD PTR tv440[rsp], 6
  009fe	e9 92 00 00 00	 jmp	 $LN81@CTCE_RecvT
$LN80@CTCE_RecvT:
  00a03	48 8b 44 24 70	 mov	 rax, QWORD PTR pDEVBLK$[rsp]
  00a08	8b 80 18 07 00
	00		 mov	 eax, DWORD PTR [rax+1816]
  00a0e	83 e0 01	 and	 eax, 1
  00a11	85 c0		 test	 eax, eax
  00a13	75 5c		 jne	 SHORT $LN76@CTCE_RecvT
  00a15	48 8b 44 24 70	 mov	 rax, QWORD PTR pDEVBLK$[rsp]
  00a1a	8b 80 74 07 00
	00		 mov	 eax, DWORD PTR [rax+1908]
  00a20	c1 e8 03	 shr	 eax, 3
  00a23	83 e0 01	 and	 eax, 1
  00a26	85 c0		 test	 eax, eax
  00a28	75 47		 jne	 SHORT $LN76@CTCE_RecvT
  00a2a	48 8b 44 24 70	 mov	 rax, QWORD PTR pDEVBLK$[rsp]
  00a2f	0f b6 80 34 07
	00 00		 movzx	 eax, BYTE PTR [rax+1844]
  00a36	83 e0 07	 and	 eax, 7
  00a39	83 f8 05	 cmp	 eax, 5
  00a3c	75 0d		 jne	 SHORT $LN77@CTCE_RecvT
  00a3e	c7 84 24 b0 00
	00 00 04 00 00
	00		 mov	 DWORD PTR tv438[rsp], 4
  00a49	eb 16		 jmp	 SHORT $LN78@CTCE_RecvT
$LN77@CTCE_RecvT:
  00a4b	48 8b 44 24 70	 mov	 rax, QWORD PTR pDEVBLK$[rsp]
  00a50	0f b6 80 34 07
	00 00		 movzx	 eax, BYTE PTR [rax+1844]
  00a57	83 e0 07	 and	 eax, 7
  00a5a	89 84 24 b0 00
	00 00		 mov	 DWORD PTR tv438[rsp], eax
$LN78@CTCE_RecvT:
  00a61	8b 84 24 b0 00
	00 00		 mov	 eax, DWORD PTR tv438[rsp]
  00a68	89 84 24 b4 00
	00 00		 mov	 DWORD PTR tv439[rsp], eax
  00a6f	eb 16		 jmp	 SHORT $LN79@CTCE_RecvT
$LN76@CTCE_RecvT:
  00a71	48 8b 44 24 70	 mov	 rax, QWORD PTR pDEVBLK$[rsp]
  00a76	0f b6 80 34 07
	00 00		 movzx	 eax, BYTE PTR [rax+1844]
  00a7d	83 e0 07	 and	 eax, 7
  00a80	89 84 24 b4 00
	00 00		 mov	 DWORD PTR tv439[rsp], eax
$LN79@CTCE_RecvT:
  00a87	8b 84 24 b4 00
	00 00		 mov	 eax, DWORD PTR tv439[rsp]
  00a8e	89 84 24 bc 00
	00 00		 mov	 DWORD PTR tv440[rsp], eax
$LN81@CTCE_RecvT:
  00a95	48 63 84 24 b8
	00 00 00	 movsxd	 rax, DWORD PTR tv413[rsp]
  00a9d	48 6b c0 20	 imul	 rax, rax, 32		; 00000020H
  00aa1	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:CTCE_Fsm
  00aa8	48 03 c8	 add	 rcx, rax
  00aab	48 8b c1	 mov	 rax, rcx
  00aae	48 63 8c 24 bc
	00 00 00	 movsxd	 rcx, DWORD PTR tv440[rsp]
  00ab6	0f b6 04 88	 movzx	 eax, BYTE PTR [rax+rcx*4]
  00aba	3d ff 00 00 00	 cmp	 eax, 255		; 000000ffH
  00abf	0f 84 7c 01 00
	00		 je	 $LN92@CTCE_RecvT
  00ac5	48 8b 44 24 70	 mov	 rax, QWORD PTR pDEVBLK$[rsp]
  00aca	8b 80 18 07 00
	00		 mov	 eax, DWORD PTR [rax+1816]
  00ad0	83 e0 01	 and	 eax, 1
  00ad3	85 c0		 test	 eax, eax
  00ad5	75 6a		 jne	 SHORT $LN82@CTCE_RecvT
  00ad7	48 8b 44 24 70	 mov	 rax, QWORD PTR pDEVBLK$[rsp]
  00adc	8b 80 74 07 00
	00		 mov	 eax, DWORD PTR [rax+1908]
  00ae2	c1 e8 03	 shr	 eax, 3
  00ae5	83 e0 01	 and	 eax, 1
  00ae8	85 c0		 test	 eax, eax
  00aea	75 55		 jne	 SHORT $LN82@CTCE_RecvT
  00aec	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR pSokBuf$[rsp]
  00af4	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  00af7	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:CTCE_command
  00afe	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00b02	83 f8 07	 cmp	 eax, 7
  00b05	75 0d		 jne	 SHORT $LN83@CTCE_RecvT
  00b07	c7 84 24 c0 00
	00 00 03 00 00
	00		 mov	 DWORD PTR tv470[rsp], 3
  00b12	eb 1d		 jmp	 SHORT $LN84@CTCE_RecvT
$LN83@CTCE_RecvT:
  00b14	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR pSokBuf$[rsp]
  00b1c	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  00b1f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:CTCE_command
  00b26	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00b2a	89 84 24 c0 00
	00 00		 mov	 DWORD PTR tv470[rsp], eax
$LN84@CTCE_RecvT:
  00b31	8b 84 24 c0 00
	00 00		 mov	 eax, DWORD PTR tv470[rsp]
  00b38	89 84 24 cc 00
	00 00		 mov	 DWORD PTR tv471[rsp], eax
  00b3f	eb 1d		 jmp	 SHORT $LN85@CTCE_RecvT
$LN82@CTCE_RecvT:
  00b41	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR pSokBuf$[rsp]
  00b49	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  00b4c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:CTCE_command
  00b53	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00b57	89 84 24 cc 00
	00 00		 mov	 DWORD PTR tv471[rsp], eax
$LN85@CTCE_RecvT:
  00b5e	48 8b 44 24 70	 mov	 rax, QWORD PTR pDEVBLK$[rsp]
  00b63	0f b6 80 36 07
	00 00		 movzx	 eax, BYTE PTR [rax+1846]
  00b6a	83 e0 04	 and	 eax, 4
  00b6d	85 c0		 test	 eax, eax
  00b6f	75 10		 jne	 SHORT $LN90@CTCE_RecvT
  00b71	c7 84 24 d0 00
	00 00 06 00 00
	00		 mov	 DWORD PTR tv498[rsp], 6
  00b7c	e9 92 00 00 00	 jmp	 $LN91@CTCE_RecvT
$LN90@CTCE_RecvT:
  00b81	48 8b 44 24 70	 mov	 rax, QWORD PTR pDEVBLK$[rsp]
  00b86	8b 80 18 07 00
	00		 mov	 eax, DWORD PTR [rax+1816]
  00b8c	83 e0 01	 and	 eax, 1
  00b8f	85 c0		 test	 eax, eax
  00b91	75 5c		 jne	 SHORT $LN86@CTCE_RecvT
  00b93	48 8b 44 24 70	 mov	 rax, QWORD PTR pDEVBLK$[rsp]
  00b98	8b 80 74 07 00
	00		 mov	 eax, DWORD PTR [rax+1908]
  00b9e	c1 e8 03	 shr	 eax, 3
  00ba1	83 e0 01	 and	 eax, 1
  00ba4	85 c0		 test	 eax, eax
  00ba6	75 47		 jne	 SHORT $LN86@CTCE_RecvT
  00ba8	48 8b 44 24 70	 mov	 rax, QWORD PTR pDEVBLK$[rsp]
  00bad	0f b6 80 34 07
	00 00		 movzx	 eax, BYTE PTR [rax+1844]
  00bb4	83 e0 07	 and	 eax, 7
  00bb7	83 f8 05	 cmp	 eax, 5
  00bba	75 0d		 jne	 SHORT $LN87@CTCE_RecvT
  00bbc	c7 84 24 c4 00
	00 00 04 00 00
	00		 mov	 DWORD PTR tv496[rsp], 4
  00bc7	eb 16		 jmp	 SHORT $LN88@CTCE_RecvT
$LN87@CTCE_RecvT:
  00bc9	48 8b 44 24 70	 mov	 rax, QWORD PTR pDEVBLK$[rsp]
  00bce	0f b6 80 34 07
	00 00		 movzx	 eax, BYTE PTR [rax+1844]
  00bd5	83 e0 07	 and	 eax, 7
  00bd8	89 84 24 c4 00
	00 00		 mov	 DWORD PTR tv496[rsp], eax
$LN88@CTCE_RecvT:
  00bdf	8b 84 24 c4 00
	00 00		 mov	 eax, DWORD PTR tv496[rsp]
  00be6	89 84 24 c8 00
	00 00		 mov	 DWORD PTR tv497[rsp], eax
  00bed	eb 16		 jmp	 SHORT $LN89@CTCE_RecvT
$LN86@CTCE_RecvT:
  00bef	48 8b 44 24 70	 mov	 rax, QWORD PTR pDEVBLK$[rsp]
  00bf4	0f b6 80 34 07
	00 00		 movzx	 eax, BYTE PTR [rax+1844]
  00bfb	83 e0 07	 and	 eax, 7
  00bfe	89 84 24 c8 00
	00 00		 mov	 DWORD PTR tv497[rsp], eax
$LN89@CTCE_RecvT:
  00c05	8b 84 24 c8 00
	00 00		 mov	 eax, DWORD PTR tv497[rsp]
  00c0c	89 84 24 d0 00
	00 00		 mov	 DWORD PTR tv498[rsp], eax
$LN91@CTCE_RecvT:
  00c13	48 63 84 24 cc
	00 00 00	 movsxd	 rax, DWORD PTR tv471[rsp]
  00c1b	48 6b c0 20	 imul	 rax, rax, 32		; 00000020H
  00c1f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:CTCE_Fsm
  00c26	48 03 c8	 add	 rcx, rax
  00c29	48 8b c1	 mov	 rax, rcx
  00c2c	48 63 8c 24 d0
	00 00 00	 movsxd	 rcx, DWORD PTR tv498[rsp]
  00c34	0f b6 04 88	 movzx	 eax, BYTE PTR [rax+rcx*4]
  00c38	89 84 24 d4 00
	00 00		 mov	 DWORD PTR tv507[rsp], eax
  00c3f	eb 16		 jmp	 SHORT $LN93@CTCE_RecvT
$LN92@CTCE_RecvT:
  00c41	48 8b 44 24 70	 mov	 rax, QWORD PTR pDEVBLK$[rsp]
  00c46	0f b6 80 36 07
	00 00		 movzx	 eax, BYTE PTR [rax+1846]
  00c4d	83 e0 07	 and	 eax, 7
  00c50	89 84 24 d4 00
	00 00		 mov	 DWORD PTR tv507[rsp], eax
$LN93@CTCE_RecvT:
  00c57	0f b6 84 24 d4
	00 00 00	 movzx	 eax, BYTE PTR tv507[rsp]
  00c5f	88 84 24 8f 01
	00 00		 mov	 BYTE PTR CTCE_Info$[rsp+7], al

; 2854 :             CTCE_Info.actions     = CTCE_Fsm[CTCE_CMD( pSokBuf->CmdReg )]

  00c66	48 8b 44 24 70	 mov	 rax, QWORD PTR pDEVBLK$[rsp]
  00c6b	8b 80 18 07 00
	00		 mov	 eax, DWORD PTR [rax+1816]
  00c71	83 e0 01	 and	 eax, 1
  00c74	85 c0		 test	 eax, eax
  00c76	75 6a		 jne	 SHORT $LN94@CTCE_RecvT
  00c78	48 8b 44 24 70	 mov	 rax, QWORD PTR pDEVBLK$[rsp]
  00c7d	8b 80 74 07 00
	00		 mov	 eax, DWORD PTR [rax+1908]
  00c83	c1 e8 03	 shr	 eax, 3
  00c86	83 e0 01	 and	 eax, 1
  00c89	85 c0		 test	 eax, eax
  00c8b	75 55		 jne	 SHORT $LN94@CTCE_RecvT
  00c8d	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR pSokBuf$[rsp]
  00c95	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  00c98	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:CTCE_command
  00c9f	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00ca3	83 f8 07	 cmp	 eax, 7
  00ca6	75 0d		 jne	 SHORT $LN95@CTCE_RecvT
  00ca8	c7 84 24 d8 00
	00 00 03 00 00
	00		 mov	 DWORD PTR tv532[rsp], 3
  00cb3	eb 1d		 jmp	 SHORT $LN96@CTCE_RecvT
$LN95@CTCE_RecvT:
  00cb5	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR pSokBuf$[rsp]
  00cbd	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  00cc0	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:CTCE_command
  00cc7	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00ccb	89 84 24 d8 00
	00 00		 mov	 DWORD PTR tv532[rsp], eax
$LN96@CTCE_RecvT:
  00cd2	8b 84 24 d8 00
	00 00		 mov	 eax, DWORD PTR tv532[rsp]
  00cd9	89 84 24 e4 00
	00 00		 mov	 DWORD PTR tv533[rsp], eax
  00ce0	eb 1d		 jmp	 SHORT $LN97@CTCE_RecvT
$LN94@CTCE_RecvT:
  00ce2	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR pSokBuf$[rsp]
  00cea	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  00ced	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:CTCE_command
  00cf4	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00cf8	89 84 24 e4 00
	00 00		 mov	 DWORD PTR tv533[rsp], eax
$LN97@CTCE_RecvT:
  00cff	48 8b 44 24 70	 mov	 rax, QWORD PTR pDEVBLK$[rsp]
  00d04	0f b6 80 36 07
	00 00		 movzx	 eax, BYTE PTR [rax+1846]
  00d0b	83 e0 04	 and	 eax, 4
  00d0e	85 c0		 test	 eax, eax
  00d10	75 10		 jne	 SHORT $LN102@CTCE_RecvT
  00d12	c7 84 24 e8 00
	00 00 06 00 00
	00		 mov	 DWORD PTR tv560[rsp], 6
  00d1d	e9 92 00 00 00	 jmp	 $LN103@CTCE_RecvT
$LN102@CTCE_RecvT:
  00d22	48 8b 44 24 70	 mov	 rax, QWORD PTR pDEVBLK$[rsp]
  00d27	8b 80 18 07 00
	00		 mov	 eax, DWORD PTR [rax+1816]
  00d2d	83 e0 01	 and	 eax, 1
  00d30	85 c0		 test	 eax, eax
  00d32	75 5c		 jne	 SHORT $LN98@CTCE_RecvT
  00d34	48 8b 44 24 70	 mov	 rax, QWORD PTR pDEVBLK$[rsp]
  00d39	8b 80 74 07 00
	00		 mov	 eax, DWORD PTR [rax+1908]
  00d3f	c1 e8 03	 shr	 eax, 3
  00d42	83 e0 01	 and	 eax, 1
  00d45	85 c0		 test	 eax, eax
  00d47	75 47		 jne	 SHORT $LN98@CTCE_RecvT
  00d49	48 8b 44 24 70	 mov	 rax, QWORD PTR pDEVBLK$[rsp]
  00d4e	0f b6 80 34 07
	00 00		 movzx	 eax, BYTE PTR [rax+1844]
  00d55	83 e0 07	 and	 eax, 7
  00d58	83 f8 05	 cmp	 eax, 5
  00d5b	75 0d		 jne	 SHORT $LN99@CTCE_RecvT
  00d5d	c7 84 24 dc 00
	00 00 04 00 00
	00		 mov	 DWORD PTR tv558[rsp], 4
  00d68	eb 16		 jmp	 SHORT $LN100@CTCE_RecvT
$LN99@CTCE_RecvT:
  00d6a	48 8b 44 24 70	 mov	 rax, QWORD PTR pDEVBLK$[rsp]
  00d6f	0f b6 80 34 07
	00 00		 movzx	 eax, BYTE PTR [rax+1844]
  00d76	83 e0 07	 and	 eax, 7
  00d79	89 84 24 dc 00
	00 00		 mov	 DWORD PTR tv558[rsp], eax
$LN100@CTCE_RecvT:
  00d80	8b 84 24 dc 00
	00 00		 mov	 eax, DWORD PTR tv558[rsp]
  00d87	89 84 24 e0 00
	00 00		 mov	 DWORD PTR tv559[rsp], eax
  00d8e	eb 16		 jmp	 SHORT $LN101@CTCE_RecvT
$LN98@CTCE_RecvT:
  00d90	48 8b 44 24 70	 mov	 rax, QWORD PTR pDEVBLK$[rsp]
  00d95	0f b6 80 34 07
	00 00		 movzx	 eax, BYTE PTR [rax+1844]
  00d9c	83 e0 07	 and	 eax, 7
  00d9f	89 84 24 e0 00
	00 00		 mov	 DWORD PTR tv559[rsp], eax
$LN101@CTCE_RecvT:
  00da6	8b 84 24 e0 00
	00 00		 mov	 eax, DWORD PTR tv559[rsp]
  00dad	89 84 24 e8 00
	00 00		 mov	 DWORD PTR tv560[rsp], eax
$LN103@CTCE_RecvT:
  00db4	48 63 84 24 e4
	00 00 00	 movsxd	 rax, DWORD PTR tv533[rsp]
  00dbc	48 6b c0 20	 imul	 rax, rax, 32		; 00000020H
  00dc0	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:CTCE_Fsm
  00dc7	48 03 c8	 add	 rcx, rax
  00dca	48 8b c1	 mov	 rax, rcx
  00dcd	48 63 8c 24 e8
	00 00 00	 movsxd	 rcx, DWORD PTR tv560[rsp]
  00dd5	0f b6 44 88 03	 movzx	 eax, BYTE PTR [rax+rcx*4+3]
  00dda	88 84 24 8e 01
	00 00		 mov	 BYTE PTR CTCE_Info$[rsp+6], al

; 2855 :                                             [CTCE_Y_STATE_FSM_IDX].actions;
; 2856 :             CTCE_Info.x_unit_stat = CTCE_Fsm[CTCE_CMD( pSokBuf->CmdReg )]

  00de1	48 8b 44 24 70	 mov	 rax, QWORD PTR pDEVBLK$[rsp]
  00de6	8b 80 18 07 00
	00		 mov	 eax, DWORD PTR [rax+1816]
  00dec	83 e0 01	 and	 eax, 1
  00def	85 c0		 test	 eax, eax
  00df1	75 6a		 jne	 SHORT $LN104@CTCE_RecvT
  00df3	48 8b 44 24 70	 mov	 rax, QWORD PTR pDEVBLK$[rsp]
  00df8	8b 80 74 07 00
	00		 mov	 eax, DWORD PTR [rax+1908]
  00dfe	c1 e8 03	 shr	 eax, 3
  00e01	83 e0 01	 and	 eax, 1
  00e04	85 c0		 test	 eax, eax
  00e06	75 55		 jne	 SHORT $LN104@CTCE_RecvT
  00e08	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR pSokBuf$[rsp]
  00e10	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  00e13	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:CTCE_command
  00e1a	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00e1e	83 f8 07	 cmp	 eax, 7
  00e21	75 0d		 jne	 SHORT $LN105@CTCE_RecvT
  00e23	c7 84 24 ec 00
	00 00 03 00 00
	00		 mov	 DWORD PTR tv588[rsp], 3
  00e2e	eb 1d		 jmp	 SHORT $LN106@CTCE_RecvT
$LN105@CTCE_RecvT:
  00e30	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR pSokBuf$[rsp]
  00e38	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  00e3b	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:CTCE_command
  00e42	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00e46	89 84 24 ec 00
	00 00		 mov	 DWORD PTR tv588[rsp], eax
$LN106@CTCE_RecvT:
  00e4d	8b 84 24 ec 00
	00 00		 mov	 eax, DWORD PTR tv588[rsp]
  00e54	89 84 24 f8 00
	00 00		 mov	 DWORD PTR tv589[rsp], eax
  00e5b	eb 1d		 jmp	 SHORT $LN107@CTCE_RecvT
$LN104@CTCE_RecvT:
  00e5d	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR pSokBuf$[rsp]
  00e65	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  00e68	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:CTCE_command
  00e6f	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00e73	89 84 24 f8 00
	00 00		 mov	 DWORD PTR tv589[rsp], eax
$LN107@CTCE_RecvT:
  00e7a	48 8b 44 24 70	 mov	 rax, QWORD PTR pDEVBLK$[rsp]
  00e7f	0f b6 80 36 07
	00 00		 movzx	 eax, BYTE PTR [rax+1846]
  00e86	83 e0 04	 and	 eax, 4
  00e89	85 c0		 test	 eax, eax
  00e8b	75 10		 jne	 SHORT $LN112@CTCE_RecvT
  00e8d	c7 84 24 fc 00
	00 00 06 00 00
	00		 mov	 DWORD PTR tv616[rsp], 6
  00e98	e9 92 00 00 00	 jmp	 $LN113@CTCE_RecvT
$LN112@CTCE_RecvT:
  00e9d	48 8b 44 24 70	 mov	 rax, QWORD PTR pDEVBLK$[rsp]
  00ea2	8b 80 18 07 00
	00		 mov	 eax, DWORD PTR [rax+1816]
  00ea8	83 e0 01	 and	 eax, 1
  00eab	85 c0		 test	 eax, eax
  00ead	75 5c		 jne	 SHORT $LN108@CTCE_RecvT
  00eaf	48 8b 44 24 70	 mov	 rax, QWORD PTR pDEVBLK$[rsp]
  00eb4	8b 80 74 07 00
	00		 mov	 eax, DWORD PTR [rax+1908]
  00eba	c1 e8 03	 shr	 eax, 3
  00ebd	83 e0 01	 and	 eax, 1
  00ec0	85 c0		 test	 eax, eax
  00ec2	75 47		 jne	 SHORT $LN108@CTCE_RecvT
  00ec4	48 8b 44 24 70	 mov	 rax, QWORD PTR pDEVBLK$[rsp]
  00ec9	0f b6 80 34 07
	00 00		 movzx	 eax, BYTE PTR [rax+1844]
  00ed0	83 e0 07	 and	 eax, 7
  00ed3	83 f8 05	 cmp	 eax, 5
  00ed6	75 0d		 jne	 SHORT $LN109@CTCE_RecvT
  00ed8	c7 84 24 f0 00
	00 00 04 00 00
	00		 mov	 DWORD PTR tv614[rsp], 4
  00ee3	eb 16		 jmp	 SHORT $LN110@CTCE_RecvT
$LN109@CTCE_RecvT:
  00ee5	48 8b 44 24 70	 mov	 rax, QWORD PTR pDEVBLK$[rsp]
  00eea	0f b6 80 34 07
	00 00		 movzx	 eax, BYTE PTR [rax+1844]
  00ef1	83 e0 07	 and	 eax, 7
  00ef4	89 84 24 f0 00
	00 00		 mov	 DWORD PTR tv614[rsp], eax
$LN110@CTCE_RecvT:
  00efb	8b 84 24 f0 00
	00 00		 mov	 eax, DWORD PTR tv614[rsp]
  00f02	89 84 24 f4 00
	00 00		 mov	 DWORD PTR tv615[rsp], eax
  00f09	eb 16		 jmp	 SHORT $LN111@CTCE_RecvT
$LN108@CTCE_RecvT:
  00f0b	48 8b 44 24 70	 mov	 rax, QWORD PTR pDEVBLK$[rsp]
  00f10	0f b6 80 34 07
	00 00		 movzx	 eax, BYTE PTR [rax+1844]
  00f17	83 e0 07	 and	 eax, 7
  00f1a	89 84 24 f4 00
	00 00		 mov	 DWORD PTR tv615[rsp], eax
$LN111@CTCE_RecvT:
  00f21	8b 84 24 f4 00
	00 00		 mov	 eax, DWORD PTR tv615[rsp]
  00f28	89 84 24 fc 00
	00 00		 mov	 DWORD PTR tv616[rsp], eax
$LN113@CTCE_RecvT:
  00f2f	48 63 84 24 f8
	00 00 00	 movsxd	 rax, DWORD PTR tv589[rsp]
  00f37	48 6b c0 20	 imul	 rax, rax, 32		; 00000020H
  00f3b	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:CTCE_Fsm
  00f42	48 03 c8	 add	 rcx, rax
  00f45	48 8b c1	 mov	 rax, rcx
  00f48	48 63 8c 24 fc
	00 00 00	 movsxd	 rcx, DWORD PTR tv616[rsp]
  00f50	0f b6 44 88 01	 movzx	 eax, BYTE PTR [rax+rcx*4+1]
  00f55	88 84 24 90 01
	00 00		 mov	 BYTE PTR CTCE_Info$[rsp+8], al

; 2857 :                                             [CTCE_Y_STATE_FSM_IDX].x_unit_stat;
; 2858 : 
; 2859 :             // SEM / SBM commands need to be acted upon.
; 2860 :             if( IS_CTCE_CCW_SEM( pSokBuf->CmdReg ) )

  00f5c	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR pSokBuf$[rsp]
  00f64	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  00f67	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:CTCE_command
  00f6e	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00f72	83 f8 09	 cmp	 eax, 9
  00f75	75 1b		 jne	 SHORT $LN24@CTCE_RecvT

; 2861 :             {
; 2862 :                 pDEVBLK->ctce_remote_xmode = 1;

  00f77	48 8b 44 24 70	 mov	 rax, QWORD PTR pDEVBLK$[rsp]
  00f7c	8b 80 74 07 00
	00		 mov	 eax, DWORD PTR [rax+1908]
  00f82	83 c8 08	 or	 eax, 8
  00f85	48 8b 4c 24 70	 mov	 rcx, QWORD PTR pDEVBLK$[rsp]
  00f8a	89 81 74 07 00
	00		 mov	 DWORD PTR [rcx+1908], eax

; 2863 :             }

  00f90	eb 34		 jmp	 SHORT $LN25@CTCE_RecvT
$LN24@CTCE_RecvT:

; 2864 :             else if( IS_CTCE_CCW_SBM( pSokBuf->CmdReg ) )

  00f92	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR pSokBuf$[rsp]
  00f9a	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  00f9d	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:CTCE_command
  00fa4	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00fa8	83 f8 0f	 cmp	 eax, 15
  00fab	75 19		 jne	 SHORT $LN26@CTCE_RecvT

; 2865 :             {
; 2866 :                 pDEVBLK->ctce_remote_xmode = 0;

  00fad	48 8b 44 24 70	 mov	 rax, QWORD PTR pDEVBLK$[rsp]
  00fb2	8b 80 74 07 00
	00		 mov	 eax, DWORD PTR [rax+1908]
  00fb8	83 e0 f7	 and	 eax, -9			; fffffff7H
  00fbb	48 8b 4c 24 70	 mov	 rcx, QWORD PTR pDEVBLK$[rsp]
  00fc0	89 81 74 07 00
	00		 mov	 DWORD PTR [rcx+1908], eax
$LN26@CTCE_RecvT:
$LN25@CTCE_RecvT:

; 2867 :             }
; 2868 : 
; 2869 :             // Device-End status indicating ready will be presented
; 2870 :             // if the y-side has just now become ready.
; 2871 :             CTCE_Info.de_ready = ( IS_CTCE_YNR( pDEVBLK->ctceyState ) &&

  00fc6	48 8b 44 24 70	 mov	 rax, QWORD PTR pDEVBLK$[rsp]
  00fcb	8b 80 18 07 00
	00		 mov	 eax, DWORD PTR [rax+1816]
  00fd1	83 e0 01	 and	 eax, 1
  00fd4	85 c0		 test	 eax, eax
  00fd6	75 5c		 jne	 SHORT $LN114@CTCE_RecvT
  00fd8	48 8b 44 24 70	 mov	 rax, QWORD PTR pDEVBLK$[rsp]
  00fdd	8b 80 74 07 00
	00		 mov	 eax, DWORD PTR [rax+1908]
  00fe3	c1 e8 03	 shr	 eax, 3
  00fe6	83 e0 01	 and	 eax, 1
  00fe9	85 c0		 test	 eax, eax
  00feb	75 47		 jne	 SHORT $LN114@CTCE_RecvT
  00fed	48 8b 44 24 70	 mov	 rax, QWORD PTR pDEVBLK$[rsp]
  00ff2	0f b6 80 36 07
	00 00		 movzx	 eax, BYTE PTR [rax+1846]
  00ff9	83 e0 07	 and	 eax, 7
  00ffc	83 f8 05	 cmp	 eax, 5
  00fff	75 0d		 jne	 SHORT $LN115@CTCE_RecvT
  01001	c7 84 24 00 01
	00 00 04 00 00
	00		 mov	 DWORD PTR tv656[rsp], 4
  0100c	eb 16		 jmp	 SHORT $LN116@CTCE_RecvT
$LN115@CTCE_RecvT:
  0100e	48 8b 44 24 70	 mov	 rax, QWORD PTR pDEVBLK$[rsp]
  01013	0f b6 80 36 07
	00 00		 movzx	 eax, BYTE PTR [rax+1846]
  0101a	83 e0 07	 and	 eax, 7
  0101d	89 84 24 00 01
	00 00		 mov	 DWORD PTR tv656[rsp], eax
$LN116@CTCE_RecvT:
  01024	8b 84 24 00 01
	00 00		 mov	 eax, DWORD PTR tv656[rsp]
  0102b	89 84 24 04 01
	00 00		 mov	 DWORD PTR tv657[rsp], eax
  01032	eb 16		 jmp	 SHORT $LN117@CTCE_RecvT
$LN114@CTCE_RecvT:
  01034	48 8b 44 24 70	 mov	 rax, QWORD PTR pDEVBLK$[rsp]
  01039	0f b6 80 36 07
	00 00		 movzx	 eax, BYTE PTR [rax+1846]
  01040	83 e0 07	 and	 eax, 7
  01043	89 84 24 04 01
	00 00		 mov	 DWORD PTR tv657[rsp], eax
$LN117@CTCE_RecvT:
  0104a	83 bc 24 04 01
	00 00 05	 cmp	 DWORD PTR tv657[rsp], 5
  01052	0f 85 9b 00 00
	00		 jne	 $LN122@CTCE_RecvT
  01058	48 8b 44 24 70	 mov	 rax, QWORD PTR pDEVBLK$[rsp]
  0105d	8b 80 18 07 00
	00		 mov	 eax, DWORD PTR [rax+1816]
  01063	83 e0 01	 and	 eax, 1
  01066	85 c0		 test	 eax, eax
  01068	75 5c		 jne	 SHORT $LN118@CTCE_RecvT
  0106a	48 8b 44 24 70	 mov	 rax, QWORD PTR pDEVBLK$[rsp]
  0106f	8b 80 74 07 00
	00		 mov	 eax, DWORD PTR [rax+1908]
  01075	c1 e8 03	 shr	 eax, 3
  01078	83 e0 01	 and	 eax, 1
  0107b	85 c0		 test	 eax, eax
  0107d	75 47		 jne	 SHORT $LN118@CTCE_RecvT
  0107f	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR pSokBuf$[rsp]
  01087	0f b6 40 01	 movzx	 eax, BYTE PTR [rax+1]
  0108b	83 e0 07	 and	 eax, 7
  0108e	83 f8 05	 cmp	 eax, 5
  01091	75 0d		 jne	 SHORT $LN119@CTCE_RecvT
  01093	c7 84 24 08 01
	00 00 04 00 00
	00		 mov	 DWORD PTR tv676[rsp], 4
  0109e	eb 16		 jmp	 SHORT $LN120@CTCE_RecvT
$LN119@CTCE_RecvT:
  010a0	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR pSokBuf$[rsp]
  010a8	0f b6 40 01	 movzx	 eax, BYTE PTR [rax+1]
  010ac	83 e0 07	 and	 eax, 7
  010af	89 84 24 08 01
	00 00		 mov	 DWORD PTR tv676[rsp], eax
$LN120@CTCE_RecvT:
  010b6	8b 84 24 08 01
	00 00		 mov	 eax, DWORD PTR tv676[rsp]
  010bd	89 84 24 0c 01
	00 00		 mov	 DWORD PTR tv677[rsp], eax
  010c4	eb 16		 jmp	 SHORT $LN121@CTCE_RecvT
$LN118@CTCE_RecvT:
  010c6	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR pSokBuf$[rsp]
  010ce	0f b6 40 01	 movzx	 eax, BYTE PTR [rax+1]
  010d2	83 e0 07	 and	 eax, 7
  010d5	89 84 24 0c 01
	00 00		 mov	 DWORD PTR tv677[rsp], eax
$LN121@CTCE_RecvT:
  010dc	83 bc 24 0c 01
	00 00 05	 cmp	 DWORD PTR tv677[rsp], 5
  010e4	74 0d		 je	 SHORT $LN122@CTCE_RecvT
  010e6	c7 84 24 10 01
	00 00 01 00 00
	00		 mov	 DWORD PTR tv679[rsp], 1
  010f1	eb 0b		 jmp	 SHORT $LN123@CTCE_RecvT
$LN122@CTCE_RecvT:
  010f3	c7 84 24 10 01
	00 00 00 00 00
	00		 mov	 DWORD PTR tv679[rsp], 0
$LN123@CTCE_RecvT:
  010fe	0f b6 84 24 10
	01 00 00	 movzx	 eax, BYTE PTR tv679[rsp]
  01106	88 84 24 95 01
	00 00		 mov	 BYTE PTR CTCE_Info$[rsp+13], al

; 2872 :                                   !IS_CTCE_YNR( pSokBuf->FsmSta ) ) ? 1 : 0;
; 2873 : 
; 2874 :             // Our (x-)side knowledge from the other (y-)side is updated.
; 2875 :             pDEVBLK->ctceyState = pSokBuf->FsmSta;

  0110d	48 8b 44 24 70	 mov	 rax, QWORD PTR pDEVBLK$[rsp]
  01112	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR pSokBuf$[rsp]
  0111a	0f b6 49 01	 movzx	 ecx, BYTE PTR [rcx+1]
  0111e	88 88 36 07 00
	00		 mov	 BYTE PTR [rax+1846], cl

; 2876 :             pDEVBLK->ctceyCmd =  pSokBuf->CmdReg;

  01124	48 8b 44 24 70	 mov	 rax, QWORD PTR pDEVBLK$[rsp]
  01129	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR pSokBuf$[rsp]
  01131	0f b6 09	 movzx	 ecx, BYTE PTR [rcx]
  01134	88 88 37 07 00
	00		 mov	 BYTE PTR [rax+1847], cl

; 2877 : 
; 2878 :             // If the other (y-)side sent us a WRITE command then we
; 2879 :             // retain the device block buffer to be able to pass the
; 2880 :             // transferred data to the matching READ command.  Hence
; 2881 :             // that we switch to the alternate device block buffer.
; 2882 :             if( IS_CTCE_CCW_WRT( pDEVBLK->ctceyCmd ) )

  0113a	48 8b 44 24 70	 mov	 rax, QWORD PTR pDEVBLK$[rsp]
  0113f	8b 80 18 07 00
	00		 mov	 eax, DWORD PTR [rax+1816]
  01145	83 e0 01	 and	 eax, 1
  01148	85 c0		 test	 eax, eax
  0114a	75 6c		 jne	 SHORT $LN124@CTCE_RecvT
  0114c	48 8b 44 24 70	 mov	 rax, QWORD PTR pDEVBLK$[rsp]
  01151	8b 80 74 07 00
	00		 mov	 eax, DWORD PTR [rax+1908]
  01157	c1 e8 03	 shr	 eax, 3
  0115a	83 e0 01	 and	 eax, 1
  0115d	85 c0		 test	 eax, eax
  0115f	75 57		 jne	 SHORT $LN124@CTCE_RecvT
  01161	48 8b 44 24 70	 mov	 rax, QWORD PTR pDEVBLK$[rsp]
  01166	0f b6 80 37 07
	00 00		 movzx	 eax, BYTE PTR [rax+1847]
  0116d	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:CTCE_command
  01174	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  01178	83 f8 07	 cmp	 eax, 7
  0117b	75 0d		 jne	 SHORT $LN125@CTCE_RecvT
  0117d	c7 84 24 14 01
	00 00 03 00 00
	00		 mov	 DWORD PTR tv708[rsp], 3
  01188	eb 1e		 jmp	 SHORT $LN126@CTCE_RecvT
$LN125@CTCE_RecvT:
  0118a	48 8b 44 24 70	 mov	 rax, QWORD PTR pDEVBLK$[rsp]
  0118f	0f b6 80 37 07
	00 00		 movzx	 eax, BYTE PTR [rax+1847]
  01196	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:CTCE_command
  0119d	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  011a1	89 84 24 14 01
	00 00		 mov	 DWORD PTR tv708[rsp], eax
$LN126@CTCE_RecvT:
  011a8	8b 84 24 14 01
	00 00		 mov	 eax, DWORD PTR tv708[rsp]
  011af	89 84 24 18 01
	00 00		 mov	 DWORD PTR tv709[rsp], eax
  011b6	eb 1e		 jmp	 SHORT $LN127@CTCE_RecvT
$LN124@CTCE_RecvT:
  011b8	48 8b 44 24 70	 mov	 rax, QWORD PTR pDEVBLK$[rsp]
  011bd	0f b6 80 37 07
	00 00		 movzx	 eax, BYTE PTR [rax+1847]
  011c4	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:CTCE_command
  011cb	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  011cf	89 84 24 18 01
	00 00		 mov	 DWORD PTR tv709[rsp], eax
$LN127@CTCE_RecvT:
  011d6	83 bc 24 18 01
	00 00 03	 cmp	 DWORD PTR tv709[rsp], 3
  011de	0f 85 91 00 00
	00		 jne	 $LN27@CTCE_RecvT

; 2883 :             {
; 2884 :                 pDEVBLK->ctce_buf_next_write ^= 1;

  011e4	48 8b 44 24 70	 mov	 rax, QWORD PTR pDEVBLK$[rsp]
  011e9	8b 80 74 07 00
	00		 mov	 eax, DWORD PTR [rax+1908]
  011ef	c1 e8 06	 shr	 eax, 6
  011f2	83 e0 01	 and	 eax, 1
  011f5	83 f0 01	 xor	 eax, 1
  011f8	83 e0 01	 and	 eax, 1
  011fb	c1 e0 06	 shl	 eax, 6
  011fe	48 8b 4c 24 70	 mov	 rcx, QWORD PTR pDEVBLK$[rsp]
  01203	8b 89 74 07 00
	00		 mov	 ecx, DWORD PTR [rcx+1908]
  01209	83 e1 bf	 and	 ecx, -65		; ffffffbfH
  0120c	0b c8		 or	 ecx, eax
  0120e	8b c1		 mov	 eax, ecx
  01210	48 8b 4c 24 70	 mov	 rcx, QWORD PTR pDEVBLK$[rsp]
  01215	89 81 74 07 00
	00		 mov	 DWORD PTR [rcx+1908], eax

; 2885 :                 pSokBuf = ( CTCE_SOKPFX* ) ( pDEVBLK->buf +

  0121b	48 8b 44 24 70	 mov	 rax, QWORD PTR pDEVBLK$[rsp]
  01220	8b 80 74 07 00
	00		 mov	 eax, DWORD PTR [rax+1908]
  01226	c1 e8 06	 shr	 eax, 6
  01229	83 e0 01	 and	 eax, 1
  0122c	85 c0		 test	 eax, eax
  0122e	74 0d		 je	 SHORT $LN128@CTCE_RecvT
  01230	c7 84 24 1c 01
	00 00 00 00 00
	00		 mov	 DWORD PTR tv728[rsp], 0
  0123b	eb 17		 jmp	 SHORT $LN129@CTCE_RecvT
$LN128@CTCE_RecvT:
  0123d	48 8b 44 24 70	 mov	 rax, QWORD PTR pDEVBLK$[rsp]
  01242	8b 80 d8 01 00
	00		 mov	 eax, DWORD PTR [rax+472]
  01248	99		 cdq
  01249	2b c2		 sub	 eax, edx
  0124b	d1 f8		 sar	 eax, 1
  0124d	89 84 24 1c 01
	00 00		 mov	 DWORD PTR tv728[rsp], eax
$LN129@CTCE_RecvT:
  01254	48 63 84 24 1c
	01 00 00	 movsxd	 rax, DWORD PTR tv728[rsp]
  0125c	48 8b 4c 24 70	 mov	 rcx, QWORD PTR pDEVBLK$[rsp]
  01261	48 03 81 c8 01
	00 00		 add	 rax, QWORD PTR [rcx+456]
  01268	48 89 84 24 80
	00 00 00	 mov	 QWORD PTR pSokBuf$[rsp], rax

; 2886 :                     ( pDEVBLK->ctce_buf_next_write ? 0 : pDEVBLK->bufsize / 2 ) );
; 2887 :             }

  01270	e9 e4 01 00 00	 jmp	 $LN28@CTCE_RecvT
$LN27@CTCE_RecvT:

; 2888 : 
; 2889 :             // If the other side sent us a WRITE EOF command
; 2890 :             // then we just set the WEOF flag on our side.
; 2891 :             else if( IS_CTCE_CCW_WEF( pDEVBLK->ctceyCmd ) )

  01275	48 8b 44 24 70	 mov	 rax, QWORD PTR pDEVBLK$[rsp]
  0127a	8b 80 18 07 00
	00		 mov	 eax, DWORD PTR [rax+1816]
  01280	83 e0 01	 and	 eax, 1
  01283	85 c0		 test	 eax, eax
  01285	75 6c		 jne	 SHORT $LN130@CTCE_RecvT
  01287	48 8b 44 24 70	 mov	 rax, QWORD PTR pDEVBLK$[rsp]
  0128c	8b 80 74 07 00
	00		 mov	 eax, DWORD PTR [rax+1908]
  01292	c1 e8 03	 shr	 eax, 3
  01295	83 e0 01	 and	 eax, 1
  01298	85 c0		 test	 eax, eax
  0129a	75 57		 jne	 SHORT $LN130@CTCE_RecvT
  0129c	48 8b 44 24 70	 mov	 rax, QWORD PTR pDEVBLK$[rsp]
  012a1	0f b6 80 37 07
	00 00		 movzx	 eax, BYTE PTR [rax+1847]
  012a8	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:CTCE_command
  012af	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  012b3	83 f8 07	 cmp	 eax, 7
  012b6	75 0d		 jne	 SHORT $LN131@CTCE_RecvT
  012b8	c7 84 24 20 01
	00 00 03 00 00
	00		 mov	 DWORD PTR tv754[rsp], 3
  012c3	eb 1e		 jmp	 SHORT $LN132@CTCE_RecvT
$LN131@CTCE_RecvT:
  012c5	48 8b 44 24 70	 mov	 rax, QWORD PTR pDEVBLK$[rsp]
  012ca	0f b6 80 37 07
	00 00		 movzx	 eax, BYTE PTR [rax+1847]
  012d1	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:CTCE_command
  012d8	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  012dc	89 84 24 20 01
	00 00		 mov	 DWORD PTR tv754[rsp], eax
$LN132@CTCE_RecvT:
  012e3	8b 84 24 20 01
	00 00		 mov	 eax, DWORD PTR tv754[rsp]
  012ea	89 84 24 24 01
	00 00		 mov	 DWORD PTR tv755[rsp], eax
  012f1	eb 1e		 jmp	 SHORT $LN133@CTCE_RecvT
$LN130@CTCE_RecvT:
  012f3	48 8b 44 24 70	 mov	 rax, QWORD PTR pDEVBLK$[rsp]
  012f8	0f b6 80 37 07
	00 00		 movzx	 eax, BYTE PTR [rax+1847]
  012ff	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:CTCE_command
  01306	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  0130a	89 84 24 24 01
	00 00		 mov	 DWORD PTR tv755[rsp], eax
$LN133@CTCE_RecvT:
  01311	83 bc 24 24 01
	00 00 07	 cmp	 DWORD PTR tv755[rsp], 7
  01319	75 20		 jne	 SHORT $LN29@CTCE_RecvT

; 2892 :             {
; 2893 :                 SET_CTCE_WEOF( pDEVBLK->ctcexState );

  0131b	48 8b 44 24 70	 mov	 rax, QWORD PTR pDEVBLK$[rsp]
  01320	0f b6 80 34 07
	00 00		 movzx	 eax, BYTE PTR [rax+1844]
  01327	0f ba e8 07	 bts	 eax, 7
  0132b	48 8b 4c 24 70	 mov	 rcx, QWORD PTR pDEVBLK$[rsp]
  01330	88 81 34 07 00
	00		 mov	 BYTE PTR [rcx+1844], al

; 2894 :             }

  01336	e9 1e 01 00 00	 jmp	 $LN30@CTCE_RecvT
$LN29@CTCE_RecvT:

; 2895 : 
; 2896 :             // If the other side sent us a READ or READBK command whilst the
; 2897 :             // previous command at our (x-) side was a WRITE EOF command then
; 2898 :             // the other side will have generated a Unit Exception to the WEOF
; 2899 :             // setting, effectively discarding that READ command.  We therefore
; 2900 :             // ignore this READ command, but we need to set the resulting
; 2901 :             // state to Available.  We clear the Wait + Attention actions.
; 2902 :             else if( IS_CTCE_CCW_RDA( pDEVBLK->ctceyCmd ) &&
; 2903 :                      IS_CTCE_CCW_WEF( pDEVBLK->ctcexCmd ) &&

  0133b	48 8b 44 24 70	 mov	 rax, QWORD PTR pDEVBLK$[rsp]
  01340	0f b6 80 37 07
	00 00		 movzx	 eax, BYTE PTR [rax+1847]
  01347	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:CTCE_command
  0134e	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  01352	25 fb 00 00 00	 and	 eax, 251		; 000000fbH
  01357	83 f8 02	 cmp	 eax, 2
  0135a	0f 85 f9 00 00
	00		 jne	 $LN31@CTCE_RecvT
  01360	48 8b 44 24 70	 mov	 rax, QWORD PTR pDEVBLK$[rsp]
  01365	8b 80 18 07 00
	00		 mov	 eax, DWORD PTR [rax+1816]
  0136b	83 e0 01	 and	 eax, 1
  0136e	85 c0		 test	 eax, eax
  01370	75 6c		 jne	 SHORT $LN134@CTCE_RecvT
  01372	48 8b 44 24 70	 mov	 rax, QWORD PTR pDEVBLK$[rsp]
  01377	8b 80 74 07 00
	00		 mov	 eax, DWORD PTR [rax+1908]
  0137d	c1 e8 03	 shr	 eax, 3
  01380	83 e0 01	 and	 eax, 1
  01383	85 c0		 test	 eax, eax
  01385	75 57		 jne	 SHORT $LN134@CTCE_RecvT
  01387	48 8b 44 24 70	 mov	 rax, QWORD PTR pDEVBLK$[rsp]
  0138c	0f b6 80 35 07
	00 00		 movzx	 eax, BYTE PTR [rax+1845]
  01393	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:CTCE_command
  0139a	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  0139e	83 f8 07	 cmp	 eax, 7
  013a1	75 0d		 jne	 SHORT $LN135@CTCE_RecvT
  013a3	c7 84 24 28 01
	00 00 03 00 00
	00		 mov	 DWORD PTR tv792[rsp], 3
  013ae	eb 1e		 jmp	 SHORT $LN136@CTCE_RecvT
$LN135@CTCE_RecvT:
  013b0	48 8b 44 24 70	 mov	 rax, QWORD PTR pDEVBLK$[rsp]
  013b5	0f b6 80 35 07
	00 00		 movzx	 eax, BYTE PTR [rax+1845]
  013bc	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:CTCE_command
  013c3	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  013c7	89 84 24 28 01
	00 00		 mov	 DWORD PTR tv792[rsp], eax
$LN136@CTCE_RecvT:
  013ce	8b 84 24 28 01
	00 00		 mov	 eax, DWORD PTR tv792[rsp]
  013d5	89 84 24 2c 01
	00 00		 mov	 DWORD PTR tv793[rsp], eax
  013dc	eb 1e		 jmp	 SHORT $LN137@CTCE_RecvT
$LN134@CTCE_RecvT:
  013de	48 8b 44 24 70	 mov	 rax, QWORD PTR pDEVBLK$[rsp]
  013e3	0f b6 80 35 07
	00 00		 movzx	 eax, BYTE PTR [rax+1845]
  013ea	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:CTCE_command
  013f1	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  013f5	89 84 24 2c 01
	00 00		 mov	 DWORD PTR tv793[rsp], eax
$LN137@CTCE_RecvT:
  013fc	83 bc 24 2c 01
	00 00 07	 cmp	 DWORD PTR tv793[rsp], 7
  01404	75 53		 jne	 SHORT $LN31@CTCE_RecvT
  01406	0f b6 84 24 8e
	01 00 00	 movzx	 eax, BYTE PTR CTCE_Info$[rsp+6]
  0140e	83 e0 10	 and	 eax, 16
  01411	83 f8 10	 cmp	 eax, 16
  01414	75 43		 jne	 SHORT $LN31@CTCE_RecvT

; 2904 :                      IS_CTCE_ATTN( CTCE_Info.actions ) )
; 2905 :             {
; 2906 :                 SET_CTCE_YAV( pDEVBLK->ctceyState );

  01416	48 8b 44 24 70	 mov	 rax, QWORD PTR pDEVBLK$[rsp]
  0141b	0f b6 80 36 07
	00 00		 movzx	 eax, BYTE PTR [rax+1846]
  01422	25 f8 00 00 00	 and	 eax, 248		; 000000f8H
  01427	83 c8 04	 or	 eax, 4
  0142a	48 8b 4c 24 70	 mov	 rcx, QWORD PTR pDEVBLK$[rsp]
  0142f	88 81 36 07 00
	00		 mov	 BYTE PTR [rcx+1846], al

; 2907 :                 CLR_CTCE_WAIT( CTCE_Info.actions );

  01435	0f b6 84 24 8e
	01 00 00	 movzx	 eax, BYTE PTR CTCE_Info$[rsp+6]
  0143d	83 e0 df	 and	 eax, -33		; ffffffffffffffdfH
  01440	88 84 24 8e 01
	00 00		 mov	 BYTE PTR CTCE_Info$[rsp+6], al

; 2908 :                 CLR_CTCE_ATTN( CTCE_Info.actions );

  01447	0f b6 84 24 8e
	01 00 00	 movzx	 eax, BYTE PTR CTCE_Info$[rsp+6]
  0144f	83 e0 ef	 and	 eax, -17
  01452	88 84 24 8e 01
	00 00		 mov	 BYTE PTR CTCE_Info$[rsp+6], al
$LN31@CTCE_RecvT:
$LN30@CTCE_RecvT:
$LN28@CTCE_RecvT:

; 2909 :             }
; 2910 : 
; 2911 :             // If the other (y-)side sent us a matching command for our
; 2912 :             // (x-)side Working(D) state, then we need to signal that
; 2913 :             // condition so that CTCE_Send no longer needs to wait.
; 2914 :             if( IS_CTCE_MATCH( CTCE_Info.actions ) )

  01459	0f b6 84 24 8e
	01 00 00	 movzx	 eax, BYTE PTR CTCE_Info$[rsp+6]
  01461	83 e0 08	 and	 eax, 8
  01464	83 f8 08	 cmp	 eax, 8
  01467	0f 85 94 00 00
	00		 jne	 $LN32@CTCE_RecvT

; 2915 :             {
; 2916 : 
; 2917 :                 // Our (x-)side returns to the available state, but the
; 2918 :                 // other (y-)side is decided for via the FSM table entry.
; 2919 :                 SET_CTCE_YAV( pDEVBLK->ctcexState );

  0146d	48 8b 44 24 70	 mov	 rax, QWORD PTR pDEVBLK$[rsp]
  01472	0f b6 80 34 07
	00 00		 movzx	 eax, BYTE PTR [rax+1844]
  01479	25 f8 00 00 00	 and	 eax, 248		; 000000f8H
  0147e	83 c8 04	 or	 eax, 4
  01481	48 8b 4c 24 70	 mov	 rcx, QWORD PTR pDEVBLK$[rsp]
  01486	88 81 34 07 00
	00		 mov	 BYTE PTR [rcx+1844], al

; 2920 :                 pDEVBLK->ctceyState = CTCE_Info.state_new;

  0148c	48 8b 44 24 70	 mov	 rax, QWORD PTR pDEVBLK$[rsp]
  01491	0f b6 8c 24 8f
	01 00 00	 movzx	 ecx, BYTE PTR CTCE_Info$[rsp+7]
  01499	88 88 36 07 00
	00		 mov	 BYTE PTR [rax+1846], cl

; 2921 : 
; 2922 :                 // All matching commands result in a final UnitStat
; 2923 :                 // CE + DE stat at the local device end.
; 2924 :                 ctce_recv_mods_UnitStat = CTCE_Info.x_unit_stat;

  0149f	0f b6 84 24 90
	01 00 00	 movzx	 eax, BYTE PTR CTCE_Info$[rsp+8]
  014a7	88 44 24 78	 mov	 BYTE PTR ctce_recv_mods_UnitStat$[rsp], al

; 2925 : 
; 2926 :                 // We now signal CTCE_Send that the MATCHing command has been received.
; 2927 :                 obtain_lock( &pDEVBLK->ctceEventLock );

  014ab	48 8b 44 24 70	 mov	 rax, QWORD PTR pDEVBLK$[rsp]
  014b0	48 05 40 07 00
	00		 add	 rax, 1856		; 00000740H
  014b6	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG170148
  014bd	48 8b c8	 mov	 rcx, rax
  014c0	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_obtain_lock

; 2928 :                 signal_condition( &pDEVBLK->ctceEvent );

  014c6	48 8b 44 24 70	 mov	 rax, QWORD PTR pDEVBLK$[rsp]
  014cb	48 05 48 07 00
	00		 add	 rax, 1864		; 00000748H
  014d1	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG170149
  014d8	48 8b c8	 mov	 rcx, rax
  014db	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_signal_condition

; 2929 :                 release_lock( &pDEVBLK->ctceEventLock );

  014e1	48 8b 44 24 70	 mov	 rax, QWORD PTR pDEVBLK$[rsp]
  014e6	48 05 40 07 00
	00		 add	 rax, 1856		; 00000740H
  014ec	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG170150
  014f3	48 8b c8	 mov	 rcx, rax
  014f6	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_release_lock

; 2930 :             } // if( IS_CTCE_MATCH( CTCE_Info.actions ) )

  014fc	e9 81 00 00 00	 jmp	 $LN33@CTCE_RecvT
$LN32@CTCE_RecvT:

; 2931 : 
; 2932 :             // If the other (y-)side sent us a Device-End status
; 2933 :             // indicating Ready then this has to be presented on this side.
; 2934 :             else if( CTCE_Info.de_ready )

  01501	0f b6 84 24 95
	01 00 00	 movzx	 eax, BYTE PTR CTCE_Info$[rsp+13]
  01509	85 c0		 test	 eax, eax
  0150b	74 75		 je	 SHORT $LN34@CTCE_RecvT

; 2935 :             {
; 2936 :                 release_lock( &pDEVBLK->lock );

  0150d	48 8b 44 24 70	 mov	 rax, QWORD PTR pDEVBLK$[rsp]
  01512	48 83 c0 38	 add	 rax, 56			; 00000038H
  01516	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG170152
  0151d	48 8b c8	 mov	 rcx, rax
  01520	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_release_lock

; 2937 :                 ctce_recv_mods_UnitStat = CSW_DE;

  01526	c6 44 24 78 04	 mov	 BYTE PTR ctce_recv_mods_UnitStat$[rsp], 4
$LN7@CTCE_RecvT:

; 2938 : 
; 2939 :                 // We may receive a de_ready from the other y-side before
; 2940 :                 // our x-side is ready for it, in which case we retry.
; 2941 :                 do
; 2942 :                 {
; 2943 :                     CTCE_Info.de_ready_attn_rc = device_attention( pDEVBLK, CSW_DE );

  0152b	b2 04		 mov	 dl, 4
  0152d	48 8b 4c 24 70	 mov	 rcx, QWORD PTR pDEVBLK$[rsp]
  01532	e8 00 00 00 00	 call	 device_attention
  01537	89 84 24 a0 01
	00 00		 mov	 DWORD PTR CTCE_Info$[rsp+24], eax

; 2944 :                 } while( ( CTCE_Info.de_ready_attn_rc == 3 ) && ( usleep( 100 ) == 0 ) );

  0153e	83 bc 24 a0 01
	00 00 03	 cmp	 DWORD PTR CTCE_Info$[rsp+24], 3
  01546	75 0f		 jne	 SHORT $LN35@CTCE_RecvT
  01548	b9 64 00 00 00	 mov	 ecx, 100		; 00000064H
  0154d	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_usleep
  01553	85 c0		 test	 eax, eax
  01555	74 d4		 je	 SHORT $LN7@CTCE_RecvT
$LN35@CTCE_RecvT:

; 2945 : 
; 2946 :                 obtain_lock( &pDEVBLK->lock );

  01557	48 8b 44 24 70	 mov	 rax, QWORD PTR pDEVBLK$[rsp]
  0155c	48 83 c0 38	 add	 rax, 56			; 00000038H
  01560	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG170154
  01567	48 8b c8	 mov	 rcx, rax
  0156a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_obtain_lock

; 2947 : 
; 2948 :                 // Another attention would be harmful and is not needed.
; 2949 :                 CLR_CTCE_ATTN( CTCE_Info.actions );

  01570	0f b6 84 24 8e
	01 00 00	 movzx	 eax, BYTE PTR CTCE_Info$[rsp+6]
  01578	83 e0 ef	 and	 eax, -17
  0157b	88 84 24 8e 01
	00 00		 mov	 BYTE PTR CTCE_Info$[rsp+6], al
$LN34@CTCE_RecvT:
$LN33@CTCE_RecvT:

; 2950 :             }
; 2951 : 
; 2952 :             // If the other (y-)side sent us a command that may require
; 2953 :             // us to signal attention then we will do so provided no
; 2954 :             // program chain is in progress (SA22-7203-00, item 2.1.1,
; 2955 :             // second paragraph).  We test for that condition using the
; 2956 :             // Command Chaining flag on the last received CCW.
; 2957 :             CTCE_Info.attn_can = 0;

  01582	8b 84 24 98 01
	00 00		 mov	 eax, DWORD PTR CTCE_Info$[rsp+16]
  01589	83 e0 fd	 and	 eax, -3			; fffffffdH
  0158c	89 84 24 98 01
	00 00		 mov	 DWORD PTR CTCE_Info$[rsp+16], eax

; 2958 :             if( IS_CTCE_ATTN( CTCE_Info.actions )
; 2959 :                 && ( !pDEVBLK->ctce_ccw_flags_cc )
; 2960 :                 && ( CTCE_Info.con_lost == 0 ) )

  01593	0f b6 84 24 8e
	01 00 00	 movzx	 eax, BYTE PTR CTCE_Info$[rsp+6]
  0159b	83 e0 10	 and	 eax, 16
  0159e	83 f8 10	 cmp	 eax, 16
  015a1	0f 85 0e 02 00
	00		 jne	 $LN36@CTCE_RecvT
  015a7	48 8b 44 24 70	 mov	 rax, QWORD PTR pDEVBLK$[rsp]
  015ac	8b 80 74 07 00
	00		 mov	 eax, DWORD PTR [rax+1908]
  015b2	d1 e8		 shr	 eax, 1
  015b4	83 e0 01	 and	 eax, 1
  015b7	85 c0		 test	 eax, eax
  015b9	0f 85 f6 01 00
	00		 jne	 $LN36@CTCE_RecvT
  015bf	8b 84 24 98 01
	00 00		 mov	 eax, DWORD PTR CTCE_Info$[rsp+16]
  015c6	c1 e8 02	 shr	 eax, 2
  015c9	83 e0 01	 and	 eax, 1
  015cc	85 c0		 test	 eax, eax
  015ce	0f 85 e1 01 00
	00		 jne	 $LN36@CTCE_RecvT

; 2961 :             {
; 2962 : 
; 2963 :                 // Produce a CTCE Trace logging if requested.
; 2964 :                 if( CTCE_CCWTRACE( pDEVBLK ) )

  015d4	48 8b 44 24 70	 mov	 rax, QWORD PTR pDEVBLK$[rsp]
  015d9	8b 80 f8 05 00
	00		 mov	 eax, DWORD PTR [rax+1528]
  015df	c1 e8 0f	 shr	 eax, 15
  015e2	83 e0 01	 and	 eax, 1
  015e5	85 c0		 test	 eax, eax
  015e7	75 50		 jne	 SHORT $LN39@CTCE_RecvT
  015e9	48 8b 44 24 70	 mov	 rax, QWORD PTR pDEVBLK$[rsp]
  015ee	83 b8 68 07 00
	00 ff		 cmp	 DWORD PTR [rax+1896], -1
  015f5	74 42		 je	 SHORT $LN39@CTCE_RecvT
  015f7	48 8b 44 24 70	 mov	 rax, QWORD PTR pDEVBLK$[rsp]
  015fc	83 b8 68 07 00
	00 00		 cmp	 DWORD PTR [rax+1896], 0
  01603	7e 5b		 jle	 SHORT $LN38@CTCE_RecvT
  01605	48 8b 44 24 70	 mov	 rax, QWORD PTR pDEVBLK$[rsp]
  0160a	8b 80 68 07 00
	00		 mov	 eax, DWORD PTR [rax+1896]
  01610	89 84 24 44 01
	00 00		 mov	 DWORD PTR tv871[rsp], eax
  01617	48 8b 44 24 70	 mov	 rax, QWORD PTR pDEVBLK$[rsp]
  0161c	8b 80 68 07 00
	00		 mov	 eax, DWORD PTR [rax+1896]
  01622	ff c8		 dec	 eax
  01624	48 8b 4c 24 70	 mov	 rcx, QWORD PTR pDEVBLK$[rsp]
  01629	89 81 68 07 00
	00		 mov	 DWORD PTR [rcx+1896], eax
  0162f	83 bc 24 44 01
	00 00 00	 cmp	 DWORD PTR tv871[rsp], 0
  01637	74 27		 je	 SHORT $LN38@CTCE_RecvT
$LN39@CTCE_RecvT:

; 2965 :                 {
; 2966 : 
; 2967 :                     // Disable ATTN RC reporting this time.
; 2968 :                     CTCE_Info.working_attn_rc = -1;

  01639	c7 84 24 a4 01
	00 00 ff ff ff
	ff		 mov	 DWORD PTR CTCE_Info$[rsp+28], -1

; 2969 :                     CTCE_Trace( pDEVBLK, CTCE_RCV, &CTCE_Info, &ctce_recv_mods_UnitStat );

  01644	4c 8d 4c 24 78	 lea	 r9, QWORD PTR ctce_recv_mods_UnitStat$[rsp]
  01649	4c 8d 84 24 88
	01 00 00	 lea	 r8, QWORD PTR CTCE_Info$[rsp]
  01651	ba 02 00 00 00	 mov	 edx, 2
  01656	48 8b 4c 24 70	 mov	 rcx, QWORD PTR pDEVBLK$[rsp]
  0165b	e8 00 00 00 00	 call	 CTCE_Trace
$LN38@CTCE_RecvT:

; 2970 :                 }
; 2971 : 
; 2972 :                 // The device_attention might not work on the first
; 2973 :                 // attempt due to the fact that we need to release
; 2974 :                 // the device lock around it, merely because that
; 2975 :                 // routine obtains and releases the device lock.
; 2976 :                 // During that short period, one or more commands
; 2977 :                 // may have come in between, causing a device busy
; 2978 :                 // and a possible other (y-)side status update. So
; 2979 :                 // we may need to re-try the ATTN if needed at all.
; 2980 :                 release_lock( &pDEVBLK->lock );

  01660	48 8b 44 24 70	 mov	 rax, QWORD PTR pDEVBLK$[rsp]
  01665	48 83 c0 38	 add	 rax, 56			; 00000038H
  01669	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG170159
  01670	48 8b c8	 mov	 rcx, rax
  01673	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_release_lock

; 2981 :                 CTCE_Info.working_attn_rc = 1;

  01679	c7 84 24 a4 01
	00 00 01 00 00
	00		 mov	 DWORD PTR CTCE_Info$[rsp+28], 1

; 2982 :                 for( CTCE_Info.busy_waits = 0;

  01684	c6 84 24 94 01
	00 00 00	 mov	 BYTE PTR CTCE_Info$[rsp+12], 0
  0168c	eb 11		 jmp	 SHORT $LN10@CTCE_RecvT
$LN8@CTCE_RecvT:

; 2985 :                      ( CTCE_Info.busy_waits <= 20 ) ;
; 2986 :                      CTCE_Info.busy_waits++ )

  0168e	0f b6 84 24 94
	01 00 00	 movzx	 eax, BYTE PTR CTCE_Info$[rsp+12]
  01696	fe c0		 inc	 al
  01698	88 84 24 94 01
	00 00		 mov	 BYTE PTR CTCE_Info$[rsp+12], al
$LN10@CTCE_RecvT:

; 2983 :                      ( CTCE_Info.working_attn_rc == 1 ) &&
; 2984 :                      ( CTCE_Info.attn_can == 0 ) &&

  0169f	83 bc 24 a4 01
	00 00 01	 cmp	 DWORD PTR CTCE_Info$[rsp+28], 1
  016a7	0f 85 cd 00 00
	00		 jne	 $LN9@CTCE_RecvT
  016ad	8b 84 24 98 01
	00 00		 mov	 eax, DWORD PTR CTCE_Info$[rsp+16]
  016b4	d1 e8		 shr	 eax, 1
  016b6	83 e0 01	 and	 eax, 1
  016b9	85 c0		 test	 eax, eax
  016bb	0f 85 b9 00 00
	00		 jne	 $LN9@CTCE_RecvT
  016c1	0f b6 84 24 94
	01 00 00	 movzx	 eax, BYTE PTR CTCE_Info$[rsp+12]
  016c9	83 f8 14	 cmp	 eax, 20
  016cc	0f 8f a8 00 00
	00		 jg	 $LN9@CTCE_RecvT

; 2987 :                 {
; 2988 : 
; 2989 :                     // To circumvent a bug in VM/SP causing SIO timeout errors, we can
; 2990 :                     // insert a 200 msec delay or so allowing the previous CCW to complete,
; 2991 :                     // which needs to be configured using the CTCE option ATTNDELAY <nnn>
; 2992 :                     if( pDEVBLK->ctce_attn_delay && CTCE_Info.busy_waits == 0 )

  016d2	48 8b 44 24 70	 mov	 rax, QWORD PTR pDEVBLK$[rsp]
  016d7	83 b8 6c 07 00
	00 00		 cmp	 DWORD PTR [rax+1900], 0
  016de	74 1d		 je	 SHORT $LN40@CTCE_RecvT
  016e0	0f b6 84 24 94
	01 00 00	 movzx	 eax, BYTE PTR CTCE_Info$[rsp+12]
  016e8	85 c0		 test	 eax, eax
  016ea	75 11		 jne	 SHORT $LN40@CTCE_RecvT

; 2993 :                     {
; 2994 :                         usleep( pDEVBLK->ctce_attn_delay );

  016ec	48 8b 44 24 70	 mov	 rax, QWORD PTR pDEVBLK$[rsp]
  016f1	8b 88 6c 07 00
	00		 mov	 ecx, DWORD PTR [rax+1900]
  016f7	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_usleep
$LN40@CTCE_RecvT:

; 2995 :                     }
; 2996 : 
; 2997 :                     CTCE_Info.working_attn_rc = device_attention( pDEVBLK, CSW_ATTN );

  016fd	b2 80		 mov	 dl, 128			; 00000080H
  016ff	48 8b 4c 24 70	 mov	 rcx, QWORD PTR pDEVBLK$[rsp]
  01704	e8 00 00 00 00	 call	 device_attention
  01709	89 84 24 a4 01
	00 00		 mov	 DWORD PTR CTCE_Info$[rsp+28], eax

; 2998 : 
; 2999 :                     // ATTN RC=1 means a device busy status did
; 3000 :                     // appear so that the signal did not work.
; 3001 :                     // We will retry after some (increasingly)
; 3002 :                     // small amount of time.
; 3003 :                     if( CTCE_Info.working_attn_rc == 1 )

  01710	83 bc 24 a4 01
	00 00 01	 cmp	 DWORD PTR CTCE_Info$[rsp+28], 1
  01718	75 5b		 jne	 SHORT $LN41@CTCE_RecvT

; 3004 :                     {
; 3005 :                         if( CTCE_Info.busy_waits == 0 )

  0171a	0f b6 84 24 94
	01 00 00	 movzx	 eax, BYTE PTR CTCE_Info$[rsp+12]
  01722	85 c0		 test	 eax, eax
  01724	75 0d		 jne	 SHORT $LN42@CTCE_RecvT

; 3006 :                         {
; 3007 :                             i = 10;

  01726	c7 84 24 8c 00
	00 00 0a 00 00
	00		 mov	 DWORD PTR i$[rsp], 10

; 3008 :                         }

  01731	eb 10		 jmp	 SHORT $LN43@CTCE_RecvT
$LN42@CTCE_RecvT:

; 3009 :                         else
; 3010 :                         {
; 3011 :                             i = i * 2;

  01733	8b 84 24 8c 00
	00 00		 mov	 eax, DWORD PTR i$[rsp]
  0173a	d1 e0		 shl	 eax, 1
  0173c	89 84 24 8c 00
	00 00		 mov	 DWORD PTR i$[rsp], eax
$LN43@CTCE_RecvT:

; 3012 :                         }
; 3013 :                         usleep(i);

  01743	8b 8c 24 8c 00
	00 00		 mov	 ecx, DWORD PTR i$[rsp]
  0174a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_usleep

; 3014 : 
; 3015 :                         // Cancel the ATTN in case a CCW program
; 3016 :                         // has started in the mean time.
; 3017 :                         if ( pDEVBLK->ctce_ccw_flags_cc )

  01750	48 8b 44 24 70	 mov	 rax, QWORD PTR pDEVBLK$[rsp]
  01755	8b 80 74 07 00
	00		 mov	 eax, DWORD PTR [rax+1908]
  0175b	d1 e8		 shr	 eax, 1
  0175d	83 e0 01	 and	 eax, 1
  01760	85 c0		 test	 eax, eax
  01762	74 11		 je	 SHORT $LN44@CTCE_RecvT

; 3018 :                         {
; 3019 :                             CTCE_Info.attn_can = 1;

  01764	8b 84 24 98 01
	00 00		 mov	 eax, DWORD PTR CTCE_Info$[rsp+16]
  0176b	83 c8 02	 or	 eax, 2
  0176e	89 84 24 98 01
	00 00		 mov	 DWORD PTR CTCE_Info$[rsp+16], eax
$LN44@CTCE_RecvT:
$LN41@CTCE_RecvT:

; 3020 :                         }
; 3021 :                     }
; 3022 :                 }

  01775	e9 14 ff ff ff	 jmp	 $LN8@CTCE_RecvT
$LN9@CTCE_RecvT:

; 3023 :                 obtain_lock( &pDEVBLK->lock );

  0177a	48 8b 44 24 70	 mov	 rax, QWORD PTR pDEVBLK$[rsp]
  0177f	48 83 c0 38	 add	 rax, 56			; 00000038H
  01783	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG170165
  0178a	48 8b c8	 mov	 rcx, rax
  0178d	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_obtain_lock

; 3024 : 
; 3025 :                 // We will show the ATTN status if it was signalled.
; 3026 :                 if( CTCE_Info.working_attn_rc == 0 )

  01793	83 bc 24 a4 01
	00 00 00	 cmp	 DWORD PTR CTCE_Info$[rsp+28], 0
  0179b	75 05		 jne	 SHORT $LN45@CTCE_RecvT

; 3027 :                 {
; 3028 :                     ctce_recv_mods_UnitStat = CSW_ATTN;

  0179d	c6 44 24 78 80	 mov	 BYTE PTR ctce_recv_mods_UnitStat$[rsp], 128 ; 00000080H
$LN45@CTCE_RecvT:

; 3029 :                 }
; 3030 :                 CTCE_Info.busy_waits -= 1;

  017a2	0f b6 84 24 94
	01 00 00	 movzx	 eax, BYTE PTR CTCE_Info$[rsp+12]
  017aa	ff c8		 dec	 eax
  017ac	88 84 24 94 01
	00 00		 mov	 BYTE PTR CTCE_Info$[rsp+12], al

; 3031 :             } // if( IS_CTCE_ATTN( CTCE_Info.actions ) && ... /* Attention Needed */

  017b3	eb 29		 jmp	 SHORT $LN37@CTCE_RecvT
$LN36@CTCE_RecvT:

; 3032 :             else if( IS_CTCE_ATTN( CTCE_Info.actions ) )

  017b5	0f b6 84 24 8e
	01 00 00	 movzx	 eax, BYTE PTR CTCE_Info$[rsp+6]
  017bd	83 e0 10	 and	 eax, 16
  017c0	83 f8 10	 cmp	 eax, 16
  017c3	75 19		 jne	 SHORT $LN46@CTCE_RecvT

; 3033 :             {
; 3034 :                 CTCE_Info.busy_waits = 0;

  017c5	c6 84 24 94 01
	00 00 00	 mov	 BYTE PTR CTCE_Info$[rsp+12], 0

; 3035 :                 CTCE_Info.attn_can = 1;

  017cd	8b 84 24 98 01
	00 00		 mov	 eax, DWORD PTR CTCE_Info$[rsp+16]
  017d4	83 c8 02	 or	 eax, 2
  017d7	89 84 24 98 01
	00 00		 mov	 DWORD PTR CTCE_Info$[rsp+16], eax
$LN46@CTCE_RecvT:
$LN37@CTCE_RecvT:
$LN23@CTCE_RecvT:

; 3036 :             }
; 3037 :         }
; 3038 : 
; 3039 :         // Merge any UnitStat modifications into the final one.
; 3040 :         pDEVBLK->ctce_UnitStat |= ctce_recv_mods_UnitStat;

  017de	0f b6 44 24 78	 movzx	 eax, BYTE PTR ctce_recv_mods_UnitStat$[rsp]
  017e3	48 8b 4c 24 70	 mov	 rcx, QWORD PTR pDEVBLK$[rsp]
  017e8	0f b6 89 39 07
	00 00		 movzx	 ecx, BYTE PTR [rcx+1849]
  017ef	0b c8		 or	 ecx, eax
  017f1	8b c1		 mov	 eax, ecx
  017f3	48 8b 4c 24 70	 mov	 rcx, QWORD PTR pDEVBLK$[rsp]
  017f8	88 81 39 07 00
	00		 mov	 BYTE PTR [rcx+1849], al

; 3041 : 
; 3042 :         // Produce a CTCE Trace logging if requested.
; 3043 :         if( CTCE_CCWTRACE( pDEVBLK )
; 3044 :             || ( ctce_recv_mods_UnitStat == ( CSW_BUSY | CSW_ATTN ) )
; 3045 :             || ( CTCE_Info.de_ready_attn_rc != 0 )
; 3046 :             || ( ( CTCE_Info.working_attn_rc  != 0 ) && ( CTCE_Info.attn_can == 0 ) )
; 3047 :             || ( CTCE_Info.busy_waits       >= 3 ) )

  017fe	48 8b 44 24 70	 mov	 rax, QWORD PTR pDEVBLK$[rsp]
  01803	8b 80 f8 05 00
	00		 mov	 eax, DWORD PTR [rax+1528]
  01809	c1 e8 0f	 shr	 eax, 15
  0180c	83 e0 01	 and	 eax, 1
  0180f	85 c0		 test	 eax, eax
  01811	0f 85 8d 00 00
	00		 jne	 $LN48@CTCE_RecvT
  01817	48 8b 44 24 70	 mov	 rax, QWORD PTR pDEVBLK$[rsp]
  0181c	83 b8 68 07 00
	00 ff		 cmp	 DWORD PTR [rax+1896], -1
  01823	74 7f		 je	 SHORT $LN48@CTCE_RecvT
  01825	48 8b 44 24 70	 mov	 rax, QWORD PTR pDEVBLK$[rsp]
  0182a	83 b8 68 07 00
	00 00		 cmp	 DWORD PTR [rax+1896], 0
  01831	7e 34		 jle	 SHORT $LN49@CTCE_RecvT
  01833	48 8b 44 24 70	 mov	 rax, QWORD PTR pDEVBLK$[rsp]
  01838	8b 80 68 07 00
	00		 mov	 eax, DWORD PTR [rax+1896]
  0183e	89 84 24 48 01
	00 00		 mov	 DWORD PTR tv935[rsp], eax
  01845	48 8b 44 24 70	 mov	 rax, QWORD PTR pDEVBLK$[rsp]
  0184a	8b 80 68 07 00
	00		 mov	 eax, DWORD PTR [rax+1896]
  01850	ff c8		 dec	 eax
  01852	48 8b 4c 24 70	 mov	 rcx, QWORD PTR pDEVBLK$[rsp]
  01857	89 81 68 07 00
	00		 mov	 DWORD PTR [rcx+1896], eax
  0185d	83 bc 24 48 01
	00 00 00	 cmp	 DWORD PTR tv935[rsp], 0
  01865	75 3d		 jne	 SHORT $LN48@CTCE_RecvT
$LN49@CTCE_RecvT:
  01867	0f b6 44 24 78	 movzx	 eax, BYTE PTR ctce_recv_mods_UnitStat$[rsp]
  0186c	3d 90 00 00 00	 cmp	 eax, 144		; 00000090H
  01871	74 31		 je	 SHORT $LN48@CTCE_RecvT
  01873	83 bc 24 a0 01
	00 00 00	 cmp	 DWORD PTR CTCE_Info$[rsp+24], 0
  0187b	75 27		 jne	 SHORT $LN48@CTCE_RecvT
  0187d	83 bc 24 a4 01
	00 00 00	 cmp	 DWORD PTR CTCE_Info$[rsp+28], 0
  01885	74 10		 je	 SHORT $LN50@CTCE_RecvT
  01887	8b 84 24 98 01
	00 00		 mov	 eax, DWORD PTR CTCE_Info$[rsp+16]
  0188e	d1 e8		 shr	 eax, 1
  01890	83 e0 01	 and	 eax, 1
  01893	85 c0		 test	 eax, eax
  01895	74 0d		 je	 SHORT $LN48@CTCE_RecvT
$LN50@CTCE_RecvT:
  01897	0f b6 84 24 94
	01 00 00	 movzx	 eax, BYTE PTR CTCE_Info$[rsp+12]
  0189f	83 f8 03	 cmp	 eax, 3
  018a2	7c 35		 jl	 SHORT $LN47@CTCE_RecvT
$LN48@CTCE_RecvT:

; 3048 :         {
; 3049 :             if( ctce_recv_mods_UnitStat != 0 )

  018a4	0f b6 44 24 78	 movzx	 eax, BYTE PTR ctce_recv_mods_UnitStat$[rsp]
  018a9	85 c0		 test	 eax, eax
  018ab	74 10		 je	 SHORT $LN51@CTCE_RecvT

; 3050 :             {
; 3051 :                 ctce_recv_mods_UnitStat = pDEVBLK->ctce_UnitStat;

  018ad	48 8b 44 24 70	 mov	 rax, QWORD PTR pDEVBLK$[rsp]
  018b2	0f b6 80 39 07
	00 00		 movzx	 eax, BYTE PTR [rax+1849]
  018b9	88 44 24 78	 mov	 BYTE PTR ctce_recv_mods_UnitStat$[rsp], al
$LN51@CTCE_RecvT:

; 3052 :             }
; 3053 :             CTCE_Trace( pDEVBLK, CTCE_RCV, &CTCE_Info, &ctce_recv_mods_UnitStat );

  018bd	4c 8d 4c 24 78	 lea	 r9, QWORD PTR ctce_recv_mods_UnitStat$[rsp]
  018c2	4c 8d 84 24 88
	01 00 00	 lea	 r8, QWORD PTR CTCE_Info$[rsp]
  018ca	ba 02 00 00 00	 mov	 edx, 2
  018cf	48 8b 4c 24 70	 mov	 rcx, QWORD PTR pDEVBLK$[rsp]
  018d4	e8 00 00 00 00	 call	 CTCE_Trace
$LN47@CTCE_RecvT:

; 3054 :         }
; 3055 :         CTCE_Info.de_ready_attn_rc = 0;

  018d9	c7 84 24 a0 01
	00 00 00 00 00
	00		 mov	 DWORD PTR CTCE_Info$[rsp+24], 0

; 3056 :         CTCE_Info.working_attn_rc  = 0;

  018e4	c7 84 24 a4 01
	00 00 00 00 00
	00		 mov	 DWORD PTR CTCE_Info$[rsp+28], 0

; 3057 :         CTCE_Info.busy_waits       = 0;

  018ef	c6 84 24 94 01
	00 00 00	 mov	 BYTE PTR CTCE_Info$[rsp+12], 0

; 3058 : 
; 3059 :         release_lock( &pDEVBLK->lock );

  018f7	48 8b 44 24 70	 mov	 rax, QWORD PTR pDEVBLK$[rsp]
  018fc	48 83 c0 38	 add	 rax, 56			; 00000038H
  01900	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG170173
  01907	48 8b c8	 mov	 rcx, rax
  0190a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_release_lock

; 3060 :     }

  01910	e9 27 e8 ff ff	 jmp	 $LN2@CTCE_RecvT
$LN1@CTCE_RecvT:

; 3061 : 
; 3062 : } // CTCE_RecvThread

  01915	48 8b 8c 24 a8
	01 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  0191d	48 33 cc	 xor	 rcx, rsp
  01920	e8 00 00 00 00	 call	 __security_check_cookie
  01925	48 81 c4 b8 01
	00 00		 add	 rsp, 440		; 000001b8H
  0192c	c3		 ret	 0
CTCE_RecvThread ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\ctcadpt.c
_TEXT	SEGMENT
pSokBuf$ = 96
tv160 = 104
tv149 = 108
tv190 = 112
tv191 = 116
tv401 = 120
tv412 = 124
tv422 = 128
pSokBuf_written$ = 136
tv69 = 144
tv73 = 148
tv215 = 152
tv218 = 156
tv221 = 160
tv225 = 164
rc$ = 168
tv251 = 172
tv302 = 176
tv359 = 180
tv244 = 184
tv248 = 192
pDEVBLK$ = 240
sCount$ = 248
pIOBuf$ = 256
pUnitStat$ = 264
pResidual$ = 272
pCTCE_Info$ = 280
CTCE_Send PROC

; 2484 : {

  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  0000e	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00013	56		 push	 rsi
  00014	57		 push	 rdi
  00015	48 81 ec d8 00
	00 00		 sub	 rsp, 216		; 000000d8H

; 2485 :     CTCE_SOKPFX   *pSokBuf;                 // overlay for buf in the device block
; 2486 :     CTCE_SOKPFX   *pSokBuf_written;         // ... and the alternate buf in the same
; 2487 :     int            rc;                      // Return code
; 2488 : 
; 2489 :     if( ! IS_CTCE_SEND( pCTCE_Info->actions ) )

  0001c	48 8b 84 24 18
	01 00 00	 mov	 rax, QWORD PTR pCTCE_Info$[rsp]
  00024	0f b6 40 06	 movzx	 eax, BYTE PTR [rax+6]
  00028	83 e0 40	 and	 eax, 64			; 00000040H
  0002b	83 f8 40	 cmp	 eax, 64			; 00000040H
  0002e	0f 84 85 00 00
	00		 je	 $LN2@CTCE_Send

; 2490 :     {
; 2491 :         WRMSG( HHC05071, "S",  // CTCE: Internal error, SEND status incorrectly encoded !

  00034	48 8b 84 24 f0
	00 00 00	 mov	 rax, QWORD PTR pDEVBLK$[rsp]
  0003c	0f b7 40 48	 movzx	 eax, WORD PTR [rax+72]
  00040	89 84 24 90 00
	00 00		 mov	 DWORD PTR tv69[rsp], eax
  00047	48 8b 8c 24 f0
	00 00 00	 mov	 rcx, QWORD PTR pDEVBLK$[rsp]
  0004f	0f b7 49 44	 movzx	 ecx, WORD PTR [rcx+68]
  00053	d1 f9		 sar	 ecx, 1
  00055	89 8c 24 94 00
	00 00		 mov	 DWORD PTR tv73[rsp], ecx
  0005c	b9 01 00 00 00	 mov	 ecx, 1
  00061	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  00067	8b 8c 24 90 00
	00 00		 mov	 ecx, DWORD PTR tv69[rsp]
  0006e	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  00072	8b 8c 24 94 00
	00 00		 mov	 ecx, DWORD PTR tv73[rsp]
  00079	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  0007d	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170042
  00084	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  00089	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170043
  00090	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00095	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  0009a	41 b9 03 00 00
	00		 mov	 r9d, 3
  000a0	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG170044
  000a7	ba bc 09 00 00	 mov	 edx, 2492		; 000009bcH
  000ac	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170045
  000b3	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg
$LN2@CTCE_Send:

; 2492 :             CTCX_DEVNUM( pDEVBLK ) );
; 2493 :     }
; 2494 : 
; 2495 :     // We only ever Send if the sockets are connected.
; 2496 :     if( ( pDEVBLK->fd < 0 ) || ( pDEVBLK->ctcefd < 0 ) )

  000b9	48 8b 84 24 f0
	00 00 00	 mov	 rax, QWORD PTR pDEVBLK$[rsp]
  000c1	83 b8 ac 01 00
	00 00		 cmp	 DWORD PTR [rax+428], 0
  000c8	7c 15		 jl	 SHORT $LN4@CTCE_Send
  000ca	48 8b 84 24 f0
	00 00 00	 mov	 rax, QWORD PTR pDEVBLK$[rsp]
  000d2	83 b8 3c 07 00
	00 00		 cmp	 DWORD PTR [rax+1852], 0
  000d9	0f 8d 8b 00 00
	00		 jge	 $LN3@CTCE_Send
$LN4@CTCE_Send:

; 2497 :     {
; 2498 :         CTCE_RESTART_CCWTRACE( pDEVBLK );

  000df	48 8b 84 24 f0
	00 00 00	 mov	 rax, QWORD PTR pDEVBLK$[rsp]
  000e7	83 b8 68 07 00
	00 00		 cmp	 DWORD PTR [rax+1896], 0
  000ee	7c 14		 jl	 SHORT $LN27@CTCE_Send
  000f0	48 8b 84 24 f0
	00 00 00	 mov	 rax, QWORD PTR pDEVBLK$[rsp]
  000f8	c7 80 68 07 00
	00 14 00 00 00	 mov	 DWORD PTR [rax+1896], 20
  00102	33 c0		 xor	 eax, eax
$LN27@CTCE_Send:

; 2499 : 
; 2500 :         if ( pDEVBLK->filename[1] != '?' )

  00104	b8 01 00 00 00	 mov	 eax, 1
  00109	48 6b c0 01	 imul	 rax, rax, 1
  0010d	48 8b 8c 24 f0
	00 00 00	 mov	 rcx, QWORD PTR pDEVBLK$[rsp]
  00115	0f be 84 01 a4
	00 00 00	 movsx	 eax, BYTE PTR [rcx+rax+164]
  0011d	83 f8 3f	 cmp	 eax, 63			; 0000003fH
  00120	74 19		 je	 SHORT $LN5@CTCE_Send

; 2501 :         {
; 2502 :             pDEVBLK->filename[1] = '?';

  00122	b8 01 00 00 00	 mov	 eax, 1
  00127	48 6b c0 01	 imul	 rax, rax, 1
  0012b	48 8b 8c 24 f0
	00 00 00	 mov	 rcx, QWORD PTR pDEVBLK$[rsp]
  00133	c6 84 01 a4 00
	00 00 3f	 mov	 BYTE PTR [rcx+rax+164], 63 ; 0000003fH
$LN5@CTCE_Send:

; 2503 :         }
; 2504 :         if( !IS_CTCE_CCW_SCB( pDEVBLK->ctcexCmd ) )

  0013b	48 8b 84 24 f0
	00 00 00	 mov	 rax, QWORD PTR pDEVBLK$[rsp]
  00143	0f b6 80 35 07
	00 00		 movzx	 eax, BYTE PTR [rax+1845]
  0014a	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:CTCE_command
  00151	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00155	83 f8 04	 cmp	 eax, 4
  00158	74 0b		 je	 SHORT $LN6@CTCE_Send

; 2505 :         {
; 2506 :             *pUnitStat = 0;

  0015a	48 8b 84 24 08
	01 00 00	 mov	 rax, QWORD PTR pUnitStat$[rsp]
  00162	c6 00 00	 mov	 BYTE PTR [rax], 0
$LN6@CTCE_Send:

; 2507 :         }
; 2508 :         return ;

  00165	e9 64 09 00 00	 jmp	 $LN1@CTCE_Send
$LN3@CTCE_Send:

; 2509 :     }
; 2510 :     pCTCE_Info->sent = 1;

  0016a	48 8b 84 24 18
	01 00 00	 mov	 rax, QWORD PTR pCTCE_Info$[rsp]
  00172	8b 40 10	 mov	 eax, DWORD PTR [rax+16]
  00175	83 c8 01	 or	 eax, 1
  00178	48 8b 8c 24 18
	01 00 00	 mov	 rcx, QWORD PTR pCTCE_Info$[rsp]
  00180	89 41 10	 mov	 DWORD PTR [rcx+16], eax

; 2511 : 
; 2512 :     pDEVBLK->ctce_UnitStat = *pUnitStat;

  00183	48 8b 84 24 f0
	00 00 00	 mov	 rax, QWORD PTR pDEVBLK$[rsp]
  0018b	48 8b 8c 24 08
	01 00 00	 mov	 rcx, QWORD PTR pUnitStat$[rsp]
  00193	0f b6 09	 movzx	 ecx, BYTE PTR [rcx]
  00196	88 88 39 07 00
	00		 mov	 BYTE PTR [rax+1849], cl

; 2513 : 
; 2514 :     // We select the device block buffer used for sending CTC commands
; 2515 :     // to be different from the one used for receiving CTC commands.
; 2516 :     pSokBuf = ( CTCE_SOKPFX* ) ( pDEVBLK->buf + ( pDEVBLK->ctce_buf_next_read ? pDEVBLK->bufsize / 2 : 0 ) );

  0019c	48 8b 84 24 f0
	00 00 00	 mov	 rax, QWORD PTR pDEVBLK$[rsp]
  001a4	8b 80 74 07 00
	00		 mov	 eax, DWORD PTR [rax+1908]
  001aa	c1 e8 05	 shr	 eax, 5
  001ad	83 e0 01	 and	 eax, 1
  001b0	85 c0		 test	 eax, eax
  001b2	74 19		 je	 SHORT $LN28@CTCE_Send
  001b4	48 8b 84 24 f0
	00 00 00	 mov	 rax, QWORD PTR pDEVBLK$[rsp]
  001bc	8b 80 d8 01 00
	00		 mov	 eax, DWORD PTR [rax+472]
  001c2	99		 cdq
  001c3	2b c2		 sub	 eax, edx
  001c5	d1 f8		 sar	 eax, 1
  001c7	89 44 24 6c	 mov	 DWORD PTR tv149[rsp], eax
  001cb	eb 08		 jmp	 SHORT $LN29@CTCE_Send
$LN28@CTCE_Send:
  001cd	c7 44 24 6c 00
	00 00 00	 mov	 DWORD PTR tv149[rsp], 0
$LN29@CTCE_Send:
  001d5	48 63 44 24 6c	 movsxd	 rax, DWORD PTR tv149[rsp]
  001da	48 8b 8c 24 f0
	00 00 00	 mov	 rcx, QWORD PTR pDEVBLK$[rsp]
  001e2	48 03 81 c8 01
	00 00		 add	 rax, QWORD PTR [rcx+456]
  001e9	48 89 44 24 60	 mov	 QWORD PTR pSokBuf$[rsp], rax

; 2517 : 
; 2518 :     pSokBuf->CmdReg = pDEVBLK->ctcexCmd;

  001ee	48 8b 44 24 60	 mov	 rax, QWORD PTR pSokBuf$[rsp]
  001f3	48 8b 8c 24 f0
	00 00 00	 mov	 rcx, QWORD PTR pDEVBLK$[rsp]
  001fb	0f b6 89 35 07
	00 00		 movzx	 ecx, BYTE PTR [rcx+1845]
  00202	88 08		 mov	 BYTE PTR [rax], cl

; 2519 :     pSokBuf->FsmSta = pDEVBLK->ctcexState;

  00204	48 8b 44 24 60	 mov	 rax, QWORD PTR pSokBuf$[rsp]
  00209	48 8b 8c 24 f0
	00 00 00	 mov	 rcx, QWORD PTR pDEVBLK$[rsp]
  00211	0f b6 89 34 07
	00 00		 movzx	 ecx, BYTE PTR [rcx+1844]
  00218	88 48 01	 mov	 BYTE PTR [rax+1], cl

; 2520 :     pSokBuf->sCount = sCount;

  0021b	48 8b 44 24 60	 mov	 rax, QWORD PTR pSokBuf$[rsp]
  00220	0f b7 8c 24 f8
	00 00 00	 movzx	 ecx, WORD PTR sCount$[rsp]
  00228	66 89 48 02	 mov	 WORD PTR [rax+2], cx

; 2521 :     pSokBuf->PktSeq = ++pDEVBLK->ctcePktSeq;

  0022c	48 8b 84 24 f0
	00 00 00	 mov	 rax, QWORD PTR pDEVBLK$[rsp]
  00234	0f b7 80 2e 07
	00 00		 movzx	 eax, WORD PTR [rax+1838]
  0023b	66 ff c0	 inc	 ax
  0023e	66 89 44 24 68	 mov	 WORD PTR tv160[rsp], ax
  00243	48 8b 84 24 f0
	00 00 00	 mov	 rax, QWORD PTR pDEVBLK$[rsp]
  0024b	0f b7 4c 24 68	 movzx	 ecx, WORD PTR tv160[rsp]
  00250	66 89 88 2e 07
	00 00		 mov	 WORD PTR [rax+1838], cx
  00257	48 8b 44 24 60	 mov	 rax, QWORD PTR pSokBuf$[rsp]
  0025c	0f b7 4c 24 68	 movzx	 ecx, WORD PTR tv160[rsp]
  00261	66 89 48 04	 mov	 WORD PTR [rax+4], cx

; 2522 :     pSokBuf->SndLen = pDEVBLK->ctceSndSml;

  00265	48 8b 44 24 60	 mov	 rax, QWORD PTR pSokBuf$[rsp]
  0026a	48 8b 8c 24 f0
	00 00 00	 mov	 rcx, QWORD PTR pDEVBLK$[rsp]
  00272	0f b7 89 30 07
	00 00		 movzx	 ecx, WORD PTR [rcx+1840]
  00279	66 89 48 08	 mov	 WORD PTR [rax+8], cx

; 2523 :     pSokBuf->devnum = pDEVBLK->devnum;

  0027d	48 8b 44 24 60	 mov	 rax, QWORD PTR pSokBuf$[rsp]
  00282	48 8b 8c 24 f0
	00 00 00	 mov	 rcx, QWORD PTR pDEVBLK$[rsp]
  0028a	0f b7 49 48	 movzx	 ecx, WORD PTR [rcx+72]
  0028e	66 89 48 0a	 mov	 WORD PTR [rax+10], cx

; 2524 :     pSokBuf->ssid   = pDEVBLK->ssid;

  00292	48 8b 44 24 60	 mov	 rax, QWORD PTR pSokBuf$[rsp]
  00297	48 8b 8c 24 f0
	00 00 00	 mov	 rcx, QWORD PTR pDEVBLK$[rsp]
  0029f	0f b7 49 44	 movzx	 ecx, WORD PTR [rcx+68]
  002a3	66 89 48 0c	 mov	 WORD PTR [rax+12], cx

; 2525 : 
; 2526 :     // Only a (non-WEOF) write command data includes sending the IOBuf.
; 2527 :     if( IS_CTCE_CCW_WRT( pDEVBLK->ctcexCmd ) )

  002a7	48 8b 84 24 f0
	00 00 00	 mov	 rax, QWORD PTR pDEVBLK$[rsp]
  002af	8b 80 18 07 00
	00		 mov	 eax, DWORD PTR [rax+1816]
  002b5	83 e0 01	 and	 eax, 1
  002b8	85 c0		 test	 eax, eax
  002ba	75 69		 jne	 SHORT $LN30@CTCE_Send
  002bc	48 8b 84 24 f0
	00 00 00	 mov	 rax, QWORD PTR pDEVBLK$[rsp]
  002c4	8b 80 74 07 00
	00		 mov	 eax, DWORD PTR [rax+1908]
  002ca	c1 e8 03	 shr	 eax, 3
  002cd	83 e0 01	 and	 eax, 1
  002d0	85 c0		 test	 eax, eax
  002d2	75 51		 jne	 SHORT $LN30@CTCE_Send
  002d4	48 8b 84 24 f0
	00 00 00	 mov	 rax, QWORD PTR pDEVBLK$[rsp]
  002dc	0f b6 80 35 07
	00 00		 movzx	 eax, BYTE PTR [rax+1845]
  002e3	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:CTCE_command
  002ea	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  002ee	83 f8 07	 cmp	 eax, 7
  002f1	75 0a		 jne	 SHORT $LN31@CTCE_Send
  002f3	c7 44 24 70 03
	00 00 00	 mov	 DWORD PTR tv190[rsp], 3
  002fb	eb 1e		 jmp	 SHORT $LN32@CTCE_Send
$LN31@CTCE_Send:
  002fd	48 8b 84 24 f0
	00 00 00	 mov	 rax, QWORD PTR pDEVBLK$[rsp]
  00305	0f b6 80 35 07
	00 00		 movzx	 eax, BYTE PTR [rax+1845]
  0030c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:CTCE_command
  00313	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00317	89 44 24 70	 mov	 DWORD PTR tv190[rsp], eax
$LN32@CTCE_Send:
  0031b	8b 44 24 70	 mov	 eax, DWORD PTR tv190[rsp]
  0031f	89 44 24 74	 mov	 DWORD PTR tv191[rsp], eax
  00323	eb 1e		 jmp	 SHORT $LN33@CTCE_Send
$LN30@CTCE_Send:
  00325	48 8b 84 24 f0
	00 00 00	 mov	 rax, QWORD PTR pDEVBLK$[rsp]
  0032d	0f b6 80 35 07
	00 00		 movzx	 eax, BYTE PTR [rax+1845]
  00334	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:CTCE_command
  0033b	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  0033f	89 44 24 74	 mov	 DWORD PTR tv191[rsp], eax
$LN33@CTCE_Send:
  00343	83 7c 24 74 03	 cmp	 DWORD PTR tv191[rsp], 3
  00348	0f 85 35 01 00
	00		 jne	 $LN7@CTCE_Send

; 2528 :     {
; 2529 :         memcpy( ( BYTE * ) pSokBuf + sizeof( CTCE_SOKPFX ), pIOBuf, sCount );

  0034e	8b 84 24 f8 00
	00 00		 mov	 eax, DWORD PTR sCount$[rsp]
  00355	48 8b 4c 24 60	 mov	 rcx, QWORD PTR pSokBuf$[rsp]
  0035a	48 83 c1 10	 add	 rcx, 16
  0035e	48 8b f9	 mov	 rdi, rcx
  00361	48 8b b4 24 00
	01 00 00	 mov	 rsi, QWORD PTR pIOBuf$[rsp]
  00369	8b c8		 mov	 ecx, eax
  0036b	f3 a4		 rep movsb

; 2530 : 
; 2531 :         // Increase the SndLen if the sCount is too large.
; 2532 :         if( pSokBuf->SndLen < ( sCount + sizeof( CTCE_SOKPFX ) ) )

  0036d	48 8b 44 24 60	 mov	 rax, QWORD PTR pSokBuf$[rsp]
  00372	0f b7 40 08	 movzx	 eax, WORD PTR [rax+8]
  00376	8b 8c 24 f8 00
	00 00		 mov	 ecx, DWORD PTR sCount$[rsp]
  0037d	48 83 c1 10	 add	 rcx, 16
  00381	48 3b c1	 cmp	 rax, rcx
  00384	73 14		 jae	 SHORT $LN8@CTCE_Send

; 2533 :             pSokBuf->SndLen = ( sCount + sizeof( CTCE_SOKPFX ) );

  00386	8b 84 24 f8 00
	00 00		 mov	 eax, DWORD PTR sCount$[rsp]
  0038d	48 83 c0 10	 add	 rax, 16
  00391	48 8b 4c 24 60	 mov	 rcx, QWORD PTR pSokBuf$[rsp]
  00396	66 89 41 08	 mov	 WORD PTR [rcx+8], ax
$LN8@CTCE_Send:

; 2534 : 
; 2535 :         // If bufsize (init from the MTU parameter) is not large enough
; 2536 :         // then we will have a severe error as the CTC will not connect.
; 2537 :         if( ( pDEVBLK->bufsize / 2 ) < pSokBuf->SndLen )

  0039a	48 8b 84 24 f0
	00 00 00	 mov	 rax, QWORD PTR pDEVBLK$[rsp]
  003a2	8b 80 d8 01 00
	00		 mov	 eax, DWORD PTR [rax+472]
  003a8	99		 cdq
  003a9	2b c2		 sub	 eax, edx
  003ab	d1 f8		 sar	 eax, 1
  003ad	48 8b 4c 24 60	 mov	 rcx, QWORD PTR pSokBuf$[rsp]
  003b2	0f b7 49 08	 movzx	 ecx, WORD PTR [rcx+8]
  003b6	3b c1		 cmp	 eax, ecx
  003b8	0f 8d c5 00 00
	00		 jge	 $LN9@CTCE_Send

; 2538 :         {
; 2539 :             WRMSG( HHC05073, "S",  /* CTCE: bufsize parameter %d is too small; increase at least to %d */

  003be	48 8b 44 24 60	 mov	 rax, QWORD PTR pSokBuf$[rsp]
  003c3	0f b7 40 08	 movzx	 eax, WORD PTR [rax+8]
  003c7	89 84 24 98 00
	00 00		 mov	 DWORD PTR tv215[rsp], eax
  003ce	48 8b 8c 24 f0
	00 00 00	 mov	 rcx, QWORD PTR pDEVBLK$[rsp]
  003d6	8b 81 d8 01 00
	00		 mov	 eax, DWORD PTR [rcx+472]
  003dc	99		 cdq
  003dd	2b c2		 sub	 eax, edx
  003df	d1 f8		 sar	 eax, 1
  003e1	89 84 24 9c 00
	00 00		 mov	 DWORD PTR tv218[rsp], eax
  003e8	48 8b 8c 24 f0
	00 00 00	 mov	 rcx, QWORD PTR pDEVBLK$[rsp]
  003f0	0f b7 49 48	 movzx	 ecx, WORD PTR [rcx+72]
  003f4	89 8c 24 a0 00
	00 00		 mov	 DWORD PTR tv221[rsp], ecx
  003fb	48 8b 94 24 f0
	00 00 00	 mov	 rdx, QWORD PTR pDEVBLK$[rsp]
  00403	0f b7 52 44	 movzx	 edx, WORD PTR [rdx+68]
  00407	d1 fa		 sar	 edx, 1
  00409	89 94 24 a4 00
	00 00		 mov	 DWORD PTR tv225[rsp], edx
  00410	b9 01 00 00 00	 mov	 ecx, 1
  00415	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  0041b	8b 8c 24 98 00
	00 00		 mov	 ecx, DWORD PTR tv215[rsp]
  00422	89 4c 24 50	 mov	 DWORD PTR [rsp+80], ecx
  00426	8b 8c 24 9c 00
	00 00		 mov	 ecx, DWORD PTR tv218[rsp]
  0042d	89 4c 24 48	 mov	 DWORD PTR [rsp+72], ecx
  00431	8b 8c 24 a0 00
	00 00		 mov	 ecx, DWORD PTR tv221[rsp]
  00438	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  0043c	8b 8c 24 a4 00
	00 00		 mov	 ecx, DWORD PTR tv225[rsp]
  00443	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  00447	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170053
  0044e	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  00453	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170054
  0045a	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  0045f	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00464	41 b9 03 00 00
	00		 mov	 r9d, 3
  0046a	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG170055
  00471	ba ec 09 00 00	 mov	 edx, 2540		; 000009ecH
  00476	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170056
  0047d	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg
$LN9@CTCE_Send:
$LN7@CTCE_Send:

; 2540 :                 CTCX_DEVNUM( pDEVBLK ), pDEVBLK->bufsize / 2, pSokBuf->SndLen );
; 2541 :         }
; 2542 :     }
; 2543 : 
; 2544 :     // Write all of this to the other (y-)side.
; 2545 :     rc = write_socket( pDEVBLK->fd, ( BYTE * ) pSokBuf, pSokBuf->SndLen );

  00483	48 8b 44 24 60	 mov	 rax, QWORD PTR pSokBuf$[rsp]
  00488	0f b7 40 08	 movzx	 eax, WORD PTR [rax+8]
  0048c	44 8b c0	 mov	 r8d, eax
  0048f	48 8b 54 24 60	 mov	 rdx, QWORD PTR pSokBuf$[rsp]
  00494	48 8b 84 24 f0
	00 00 00	 mov	 rax, QWORD PTR pDEVBLK$[rsp]
  0049c	8b 88 ac 01 00
	00		 mov	 ecx, DWORD PTR [rax+428]
  004a2	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_write_socket
  004a8	89 84 24 a8 00
	00 00		 mov	 DWORD PTR rc$[rsp], eax

; 2546 : 
; 2547 :     if( rc < 0 )

  004af	83 bc 24 a8 00
	00 00 00	 cmp	 DWORD PTR rc$[rsp], 0
  004b7	0f 8d 1d 01 00
	00		 jge	 $LN10@CTCE_Send

; 2548 :     {
; 2549 :         WRMSG( HHC05074, "E",  /* CTCE: Error writing to %s: %s */

  004bd	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_WSAGetLastError
  004c3	8b c8		 mov	 ecx, eax
  004c5	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_strerror
  004cb	48 89 84 24 b8
	00 00 00	 mov	 QWORD PTR tv244[rsp], rax
  004d3	48 8b 8c 24 f0
	00 00 00	 mov	 rcx, QWORD PTR pDEVBLK$[rsp]
  004db	48 81 c1 a4 00
	00 00		 add	 rcx, 164		; 000000a4H
  004e2	48 89 8c 24 c0
	00 00 00	 mov	 QWORD PTR tv248[rsp], rcx
  004ea	48 8b 94 24 f0
	00 00 00	 mov	 rdx, QWORD PTR pDEVBLK$[rsp]
  004f2	0f b7 52 48	 movzx	 edx, WORD PTR [rdx+72]
  004f6	89 94 24 ac 00
	00 00		 mov	 DWORD PTR tv251[rsp], edx
  004fd	48 8b bc 24 f0
	00 00 00	 mov	 rdi, QWORD PTR pDEVBLK$[rsp]
  00505	0f b7 7f 44	 movzx	 edi, WORD PTR [rdi+68]
  00509	d1 ff		 sar	 edi, 1
  0050b	b9 01 00 00 00	 mov	 ecx, 1
  00510	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  00516	48 8b 8c 24 b8
	00 00 00	 mov	 rcx, QWORD PTR tv244[rsp]
  0051e	48 89 4c 24 50	 mov	 QWORD PTR [rsp+80], rcx
  00523	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR tv248[rsp]
  0052b	48 89 4c 24 48	 mov	 QWORD PTR [rsp+72], rcx
  00530	8b 8c 24 ac 00
	00 00		 mov	 ecx, DWORD PTR tv251[rsp]
  00537	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  0053b	89 7c 24 38	 mov	 DWORD PTR [rsp+56], edi
  0053f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170058
  00546	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  0054b	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170059
  00552	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00557	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  0055c	41 b9 03 00 00
	00		 mov	 r9d, 3
  00562	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG170060
  00569	ba f6 09 00 00	 mov	 edx, 2550		; 000009f6H
  0056e	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170061
  00575	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 2550 :             CTCX_DEVNUM( pDEVBLK ), pDEVBLK->filename, strerror( HSO_errno ) );
; 2551 : 
; 2552 :         CTCE_ERROR_CCWTRACE( pDEVBLK );

  0057b	48 8b 84 24 f0
	00 00 00	 mov	 rax, QWORD PTR pDEVBLK$[rsp]
  00583	c7 80 68 07 00
	00 14 00 00 00	 mov	 DWORD PTR [rax+1896], 20

; 2553 : 
; 2554 :         // We will try a CTCE Recovery in case of the send error when not shutting down.
; 2555 :         if( !sysblk.shutdown )

  0058d	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00594	8b 80 94 12 00
	00		 mov	 eax, DWORD PTR [rax+4756]
  0059a	c1 e8 0b	 shr	 eax, 11
  0059d	83 e0 01	 and	 eax, 1
  005a0	85 c0		 test	 eax, eax
  005a2	75 0d		 jne	 SHORT $LN11@CTCE_Send

; 2556 :         {
; 2557 :             (void) CTCE_Recovery( pDEVBLK ) ;

  005a4	48 8b 8c 24 f0
	00 00 00	 mov	 rcx, QWORD PTR pDEVBLK$[rsp]
  005ac	e8 00 00 00 00	 call	 CTCE_Recovery
$LN11@CTCE_Send:

; 2558 :         }
; 2559 : 
; 2560 :         // This looks like a 'broken connection' situation so we
; 2561 :         // set intervention required.  (An equipment check and
; 2562 :         // returning to the not ready state was found to not work.)
; 2563 :         pDEVBLK->sense[0] = SENSE_IR;

  005b1	b8 01 00 00 00	 mov	 eax, 1
  005b6	48 6b c0 00	 imul	 rax, rax, 0
  005ba	48 8b 8c 24 f0
	00 00 00	 mov	 rcx, QWORD PTR pDEVBLK$[rsp]
  005c2	c6 84 01 64 03
	00 00 40	 mov	 BYTE PTR [rcx+rax+868], 64 ; 00000040H

; 2564 :         *pUnitStat = CSW_CE | CSW_DE | CSW_UC;

  005ca	48 8b 84 24 08
	01 00 00	 mov	 rax, QWORD PTR pUnitStat$[rsp]
  005d2	c6 00 0e	 mov	 BYTE PTR [rax], 14

; 2565 :         return;

  005d5	e9 f4 04 00 00	 jmp	 $LN1@CTCE_Send
$LN10@CTCE_Send:

; 2566 :     }
; 2567 : 
; 2568 :     // If this command is a matching one for the other (y-)side
; 2569 :     // Working(D) state, then that (y-)side becomes available.
; 2570 :     if IS_CTCE_MATCH( pCTCE_Info->actions )

  005da	48 8b 84 24 18
	01 00 00	 mov	 rax, QWORD PTR pCTCE_Info$[rsp]
  005e2	0f b6 40 06	 movzx	 eax, BYTE PTR [rax+6]
  005e6	83 e0 08	 and	 eax, 8
  005e9	83 f8 08	 cmp	 eax, 8
  005ec	75 25		 jne	 SHORT $LN12@CTCE_Send

; 2571 :     {
; 2572 :         SET_CTCE_YAV( pDEVBLK->ctceyState );

  005ee	48 8b 84 24 f0
	00 00 00	 mov	 rax, QWORD PTR pDEVBLK$[rsp]
  005f6	0f b6 80 36 07
	00 00		 movzx	 eax, BYTE PTR [rax+1846]
  005fd	25 f8 00 00 00	 and	 eax, 248		; 000000f8H
  00602	83 c8 04	 or	 eax, 4
  00605	48 8b 8c 24 f0
	00 00 00	 mov	 rcx, QWORD PTR pDEVBLK$[rsp]
  0060d	88 81 36 07 00
	00		 mov	 BYTE PTR [rcx+1846], al
$LN12@CTCE_Send:

; 2573 :     }
; 2574 : 
; 2575 :     // If we received a command that is going to put our (x-)side
; 2576 :     // in a Working(D) state, then we will need to wait until a
; 2577 :     // matching command arrives from the other (y-)side.  The WAIT
; 2578 :     // timeout is chosen to be long enough to not timeout over periods
; 2579 :     // if inactivity; we experienced up to exactly 15 minutes following
; 2580 :     // (non-matching) PREPARE CCW commands, so we set it to 1000 sec.
; 2581 :     if( IS_CTCE_WAIT( pCTCE_Info->actions ) )

  00613	48 8b 84 24 18
	01 00 00	 mov	 rax, QWORD PTR pCTCE_Info$[rsp]
  0061b	0f b6 40 06	 movzx	 eax, BYTE PTR [rax+6]
  0061f	83 e0 20	 and	 eax, 32			; 00000020H
  00622	83 f8 20	 cmp	 eax, 32			; 00000020H
  00625	0f 85 98 02 00
	00		 jne	 $LN13@CTCE_Send

; 2582 :     {
; 2583 : 
; 2584 :         // Produce a CTCE Trace logging if requested.
; 2585 :         if( CTCE_CCWTRACE( pDEVBLK ) )

  0062b	48 8b 84 24 f0
	00 00 00	 mov	 rax, QWORD PTR pDEVBLK$[rsp]
  00633	8b 80 f8 05 00
	00		 mov	 eax, DWORD PTR [rax+1528]
  00639	c1 e8 0f	 shr	 eax, 15
  0063c	83 e0 01	 and	 eax, 1
  0063f	85 c0		 test	 eax, eax
  00641	75 5f		 jne	 SHORT $LN15@CTCE_Send
  00643	48 8b 84 24 f0
	00 00 00	 mov	 rax, QWORD PTR pDEVBLK$[rsp]
  0064b	83 b8 68 07 00
	00 ff		 cmp	 DWORD PTR [rax+1896], -1
  00652	74 4e		 je	 SHORT $LN15@CTCE_Send
  00654	48 8b 84 24 f0
	00 00 00	 mov	 rax, QWORD PTR pDEVBLK$[rsp]
  0065c	83 b8 68 07 00
	00 00		 cmp	 DWORD PTR [rax+1896], 0
  00663	7e 5f		 jle	 SHORT $LN14@CTCE_Send
  00665	48 8b 84 24 f0
	00 00 00	 mov	 rax, QWORD PTR pDEVBLK$[rsp]
  0066d	8b 80 68 07 00
	00		 mov	 eax, DWORD PTR [rax+1896]
  00673	89 84 24 b0 00
	00 00		 mov	 DWORD PTR tv302[rsp], eax
  0067a	48 8b 84 24 f0
	00 00 00	 mov	 rax, QWORD PTR pDEVBLK$[rsp]
  00682	8b 80 68 07 00
	00		 mov	 eax, DWORD PTR [rax+1896]
  00688	ff c8		 dec	 eax
  0068a	48 8b 8c 24 f0
	00 00 00	 mov	 rcx, QWORD PTR pDEVBLK$[rsp]
  00692	89 81 68 07 00
	00		 mov	 DWORD PTR [rcx+1896], eax
  00698	83 bc 24 b0 00
	00 00 00	 cmp	 DWORD PTR tv302[rsp], 0
  006a0	74 22		 je	 SHORT $LN14@CTCE_Send
$LN15@CTCE_Send:

; 2586 :         {
; 2587 :             CTCE_Trace( pDEVBLK, CTCE_SND, pCTCE_Info, pUnitStat );

  006a2	4c 8b 8c 24 08
	01 00 00	 mov	 r9, QWORD PTR pUnitStat$[rsp]
  006aa	4c 8b 84 24 18
	01 00 00	 mov	 r8, QWORD PTR pCTCE_Info$[rsp]
  006b2	ba 01 00 00 00	 mov	 edx, 1
  006b7	48 8b 8c 24 f0
	00 00 00	 mov	 rcx, QWORD PTR pDEVBLK$[rsp]
  006bf	e8 00 00 00 00	 call	 CTCE_Trace
$LN14@CTCE_Send:

; 2588 :         }
; 2589 : 
; 2590 :         obtain_lock( &pDEVBLK->ctceEventLock );

  006c4	48 8b 84 24 f0
	00 00 00	 mov	 rax, QWORD PTR pDEVBLK$[rsp]
  006cc	48 05 40 07 00
	00		 add	 rax, 1856		; 00000740H
  006d2	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG170067
  006d9	48 8b c8	 mov	 rcx, rax
  006dc	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_obtain_lock

; 2591 :         release_lock( &pDEVBLK->lock );

  006e2	48 8b 84 24 f0
	00 00 00	 mov	 rax, QWORD PTR pDEVBLK$[rsp]
  006ea	48 83 c0 38	 add	 rax, 56			; 00000038H
  006ee	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG170068
  006f5	48 8b c8	 mov	 rcx, rax
  006f8	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_release_lock

; 2592 : 
; 2593 :         pCTCE_Info->wait_rc = timed_wait_condition_relative_usecs(

  006fe	48 8b 84 24 f0
	00 00 00	 mov	 rax, QWORD PTR pDEVBLK$[rsp]
  00706	48 05 40 07 00
	00		 add	 rax, 1856		; 00000740H
  0070c	48 8b 8c 24 f0
	00 00 00	 mov	 rcx, QWORD PTR pDEVBLK$[rsp]
  00714	48 81 c1 48 07
	00 00		 add	 rcx, 1864		; 00000748H
  0071b	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG170069
  00722	48 89 54 24 20	 mov	 QWORD PTR [rsp+32], rdx
  00727	45 33 c9	 xor	 r9d, r9d
  0072a	41 b8 00 ca 9a
	3b		 mov	 r8d, 1000000000		; 3b9aca00H
  00730	48 8b d0	 mov	 rdx, rax
  00733	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_timed_wait_condition_relative_usecs_impl
  00739	48 8b 8c 24 18
	01 00 00	 mov	 rcx, QWORD PTR pCTCE_Info$[rsp]
  00741	89 41 14	 mov	 DWORD PTR [rcx+20], eax

; 2594 :             &pDEVBLK->ctceEvent,
; 2595 :             &pDEVBLK->ctceEventLock,
; 2596 :             1000000000,
; 2597 :             NULL );
; 2598 : 
; 2599 :         obtain_lock( &pDEVBLK->lock );

  00744	48 8b 84 24 f0
	00 00 00	 mov	 rax, QWORD PTR pDEVBLK$[rsp]
  0074c	48 83 c0 38	 add	 rax, 56			; 00000038H
  00750	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG170070
  00757	48 8b c8	 mov	 rcx, rax
  0075a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_obtain_lock

; 2600 :         release_lock( &pDEVBLK->ctceEventLock );

  00760	48 8b 84 24 f0
	00 00 00	 mov	 rax, QWORD PTR pDEVBLK$[rsp]
  00768	48 05 40 07 00
	00		 add	 rax, 1856		; 00000740H
  0076e	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG170071
  00775	48 8b c8	 mov	 rcx, rax
  00778	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_release_lock

; 2601 : 
; 2602 :         // Trace the non-zero WAIT RC (e.g. timeout, RC=138 (windows) or 110 (unix)).
; 2603 :         if( pCTCE_Info->wait_rc != 0 )

  0077e	48 8b 84 24 18
	01 00 00	 mov	 rax, QWORD PTR pCTCE_Info$[rsp]
  00786	83 78 14 00	 cmp	 DWORD PTR [rax+20], 0
  0078a	74 39		 je	 SHORT $LN16@CTCE_Send

; 2604 :         {
; 2605 :             CTCE_ERROR_CCWTRACE( pDEVBLK );

  0078c	48 8b 84 24 f0
	00 00 00	 mov	 rax, QWORD PTR pDEVBLK$[rsp]
  00794	c7 80 68 07 00
	00 14 00 00 00	 mov	 DWORD PTR [rax+1896], 20

; 2606 :             CTCE_Trace( pDEVBLK, CTCE_SND, pCTCE_Info, pUnitStat );

  0079e	4c 8b 8c 24 08
	01 00 00	 mov	 r9, QWORD PTR pUnitStat$[rsp]
  007a6	4c 8b 84 24 18
	01 00 00	 mov	 r8, QWORD PTR pCTCE_Info$[rsp]
  007ae	ba 01 00 00 00	 mov	 edx, 1
  007b3	48 8b 8c 24 f0
	00 00 00	 mov	 rcx, QWORD PTR pDEVBLK$[rsp]
  007bb	e8 00 00 00 00	 call	 CTCE_Trace

; 2607 :         }

  007c0	e9 fe 00 00 00	 jmp	 $LN17@CTCE_Send
$LN16@CTCE_Send:

; 2608 : 
; 2609 :         // A WRITE EOF command from the other side will have resulted
; 2610 :         // in the WEOF flag being set.  If this was a matching command
; 2611 :         // for a READ then unit exception needs to be included.
; 2612 :         else if( IS_CTCE_WEOF( pDEVBLK->ctcexState ) &&

  007c5	48 8b 84 24 f0
	00 00 00	 mov	 rax, QWORD PTR pDEVBLK$[rsp]
  007cd	0f b6 80 34 07
	00 00		 movzx	 eax, BYTE PTR [rax+1844]
  007d4	25 80 00 00 00	 and	 eax, 128		; 00000080H
  007d9	3d 80 00 00 00	 cmp	 eax, 128		; 00000080H
  007de	0f 85 df 00 00
	00		 jne	 $LN18@CTCE_Send
  007e4	48 8b 84 24 f0
	00 00 00	 mov	 rax, QWORD PTR pDEVBLK$[rsp]
  007ec	0f b6 80 35 07
	00 00		 movzx	 eax, BYTE PTR [rax+1845]
  007f3	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:CTCE_command
  007fa	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  007fe	25 fb 00 00 00	 and	 eax, 251		; 000000fbH
  00803	83 f8 02	 cmp	 eax, 2
  00806	0f 85 b7 00 00
	00		 jne	 $LN18@CTCE_Send

; 2613 :                  IS_CTCE_CCW_RDA( pDEVBLK->ctcexCmd ) )
; 2614 :         {
; 2615 :             *pResidual = 0;

  0080c	48 8b 84 24 10
	01 00 00	 mov	 rax, QWORD PTR pResidual$[rsp]
  00814	c7 00 00 00 00
	00		 mov	 DWORD PTR [rax], 0

; 2616 :             *pUnitStat  = CSW_CE | CSW_DE | CSW_UX;

  0081a	48 8b 84 24 08
	01 00 00	 mov	 rax, QWORD PTR pUnitStat$[rsp]
  00822	c6 00 0d	 mov	 BYTE PTR [rax], 13

; 2617 : 
; 2618 :             // Produce a trace logging if requested.
; 2619 :             if( CTCE_CCWTRACE( pDEVBLK ) )

  00825	48 8b 84 24 f0
	00 00 00	 mov	 rax, QWORD PTR pDEVBLK$[rsp]
  0082d	8b 80 f8 05 00
	00		 mov	 eax, DWORD PTR [rax+1528]
  00833	c1 e8 0f	 shr	 eax, 15
  00836	83 e0 01	 and	 eax, 1
  00839	85 c0		 test	 eax, eax
  0083b	75 5f		 jne	 SHORT $LN20@CTCE_Send
  0083d	48 8b 84 24 f0
	00 00 00	 mov	 rax, QWORD PTR pDEVBLK$[rsp]
  00845	83 b8 68 07 00
	00 ff		 cmp	 DWORD PTR [rax+1896], -1
  0084c	74 4e		 je	 SHORT $LN20@CTCE_Send
  0084e	48 8b 84 24 f0
	00 00 00	 mov	 rax, QWORD PTR pDEVBLK$[rsp]
  00856	83 b8 68 07 00
	00 00		 cmp	 DWORD PTR [rax+1896], 0
  0085d	7e 5f		 jle	 SHORT $LN19@CTCE_Send
  0085f	48 8b 84 24 f0
	00 00 00	 mov	 rax, QWORD PTR pDEVBLK$[rsp]
  00867	8b 80 68 07 00
	00		 mov	 eax, DWORD PTR [rax+1896]
  0086d	89 84 24 b4 00
	00 00		 mov	 DWORD PTR tv359[rsp], eax
  00874	48 8b 84 24 f0
	00 00 00	 mov	 rax, QWORD PTR pDEVBLK$[rsp]
  0087c	8b 80 68 07 00
	00		 mov	 eax, DWORD PTR [rax+1896]
  00882	ff c8		 dec	 eax
  00884	48 8b 8c 24 f0
	00 00 00	 mov	 rcx, QWORD PTR pDEVBLK$[rsp]
  0088c	89 81 68 07 00
	00		 mov	 DWORD PTR [rcx+1896], eax
  00892	83 bc 24 b4 00
	00 00 00	 cmp	 DWORD PTR tv359[rsp], 0
  0089a	74 22		 je	 SHORT $LN19@CTCE_Send
$LN20@CTCE_Send:

; 2620 :             {
; 2621 :                 CTCE_Trace( pDEVBLK, CTCE_SND, pCTCE_Info, pUnitStat );

  0089c	4c 8b 8c 24 08
	01 00 00	 mov	 r9, QWORD PTR pUnitStat$[rsp]
  008a4	4c 8b 84 24 18
	01 00 00	 mov	 r8, QWORD PTR pCTCE_Info$[rsp]
  008ac	ba 01 00 00 00	 mov	 edx, 1
  008b1	48 8b 8c 24 f0
	00 00 00	 mov	 rcx, QWORD PTR pDEVBLK$[rsp]
  008b9	e8 00 00 00 00	 call	 CTCE_Trace
$LN19@CTCE_Send:

; 2622 :             }
; 2623 :             return;

  008be	e9 0b 02 00 00	 jmp	 $LN1@CTCE_Send
$LN18@CTCE_Send:
$LN17@CTCE_Send:
$LN13@CTCE_Send:

; 2624 :         }
; 2625 :     } // if( IS_CTCE_WAIT( pCTCE_Info->actions ) )
; 2626 : 
; 2627 :     // Command collisions or resets (CSW_UC) never return data.
; 2628 :     if( 0
; 2629 :         || ( pDEVBLK->ctce_UnitStat == (CSW_BUSY | CSW_ATTN) )
; 2630 :         || IS_CTCE_RST( pDEVBLK->ctceyCmd )
; 2631 :         || ( pDEVBLK->ctce_UnitStat & CSW_UC ) )

  008c3	33 c0		 xor	 eax, eax
  008c5	85 c0		 test	 eax, eax
  008c7	75 4b		 jne	 SHORT $LN23@CTCE_Send
  008c9	48 8b 84 24 f0
	00 00 00	 mov	 rax, QWORD PTR pDEVBLK$[rsp]
  008d1	0f b6 80 39 07
	00 00		 movzx	 eax, BYTE PTR [rax+1849]
  008d8	3d 90 00 00 00	 cmp	 eax, 144		; 00000090H
  008dd	74 35		 je	 SHORT $LN23@CTCE_Send
  008df	48 8b 84 24 f0
	00 00 00	 mov	 rax, QWORD PTR pDEVBLK$[rsp]
  008e7	0f b6 80 37 07
	00 00		 movzx	 eax, BYTE PTR [rax+1847]
  008ee	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:CTCE_command
  008f5	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  008f9	83 f8 0e	 cmp	 eax, 14
  008fc	74 16		 je	 SHORT $LN23@CTCE_Send
  008fe	48 8b 84 24 f0
	00 00 00	 mov	 rax, QWORD PTR pDEVBLK$[rsp]
  00906	0f b6 80 39 07
	00 00		 movzx	 eax, BYTE PTR [rax+1849]
  0090d	83 e0 02	 and	 eax, 2
  00910	85 c0		 test	 eax, eax
  00912	74 16		 je	 SHORT $LN21@CTCE_Send
$LN23@CTCE_Send:

; 2632 :     {
; 2633 :         *pResidual = sCount;

  00914	48 8b 84 24 10
	01 00 00	 mov	 rax, QWORD PTR pResidual$[rsp]
  0091c	8b 8c 24 f8 00
	00 00		 mov	 ecx, DWORD PTR sCount$[rsp]
  00923	89 08		 mov	 DWORD PTR [rax], ecx

; 2634 :     }

  00925	e9 6d 01 00 00	 jmp	 $LN22@CTCE_Send
$LN21@CTCE_Send:

; 2635 : 
; 2636 :     // If the command (by now matched) was a READ command, then the
; 2637 :     // other (y-)side data is available in the alternate device
; 2638 :     // buffer.  We copy that data into the IO buffer, but only
; 2639 :     // transfer the minimum of the current READ sCount and the
; 2640 :     // original WRITE sCount we received from the other (y-)side.
; 2641 :     else if( IS_CTCE_CCW_RED( pDEVBLK->ctcexCmd ) )

  0092a	48 8b 84 24 f0
	00 00 00	 mov	 rax, QWORD PTR pDEVBLK$[rsp]
  00932	0f b6 80 35 07
	00 00		 movzx	 eax, BYTE PTR [rax+1845]
  00939	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:CTCE_command
  00940	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00944	83 f8 02	 cmp	 eax, 2
  00947	0f 85 3c 01 00
	00		 jne	 $LN24@CTCE_Send

; 2642 :     {
; 2643 : 
; 2644 :         // We switch to the alternate device block buffer for the
; 2645 :         // next CTCE_Send to use; CTCE_Recv already did this.
; 2646 :         pDEVBLK->ctce_buf_next_read ^= 1;

  0094d	48 8b 84 24 f0
	00 00 00	 mov	 rax, QWORD PTR pDEVBLK$[rsp]
  00955	8b 80 74 07 00
	00		 mov	 eax, DWORD PTR [rax+1908]
  0095b	c1 e8 05	 shr	 eax, 5
  0095e	83 e0 01	 and	 eax, 1
  00961	83 f0 01	 xor	 eax, 1
  00964	83 e0 01	 and	 eax, 1
  00967	c1 e0 05	 shl	 eax, 5
  0096a	48 8b 8c 24 f0
	00 00 00	 mov	 rcx, QWORD PTR pDEVBLK$[rsp]
  00972	8b 89 74 07 00
	00		 mov	 ecx, DWORD PTR [rcx+1908]
  00978	83 e1 df	 and	 ecx, -33		; ffffffdfH
  0097b	0b c8		 or	 ecx, eax
  0097d	8b c1		 mov	 eax, ecx
  0097f	48 8b 8c 24 f0
	00 00 00	 mov	 rcx, QWORD PTR pDEVBLK$[rsp]
  00987	89 81 74 07 00
	00		 mov	 DWORD PTR [rcx+1908], eax

; 2647 : 
; 2648 :         // We point to the device block buffer holding the matching
; 2649 :         // WRITE command data which CTCE_Recv received.
; 2650 :         pSokBuf_written = ( CTCE_SOKPFX* ) ( pDEVBLK->buf +

  0098d	48 8b 84 24 f0
	00 00 00	 mov	 rax, QWORD PTR pDEVBLK$[rsp]
  00995	8b 80 74 07 00
	00		 mov	 eax, DWORD PTR [rax+1908]
  0099b	c1 e8 05	 shr	 eax, 5
  0099e	83 e0 01	 and	 eax, 1
  009a1	85 c0		 test	 eax, eax
  009a3	74 19		 je	 SHORT $LN34@CTCE_Send
  009a5	48 8b 84 24 f0
	00 00 00	 mov	 rax, QWORD PTR pDEVBLK$[rsp]
  009ad	8b 80 d8 01 00
	00		 mov	 eax, DWORD PTR [rax+472]
  009b3	99		 cdq
  009b4	2b c2		 sub	 eax, edx
  009b6	d1 f8		 sar	 eax, 1
  009b8	89 44 24 78	 mov	 DWORD PTR tv401[rsp], eax
  009bc	eb 08		 jmp	 SHORT $LN35@CTCE_Send
$LN34@CTCE_Send:
  009be	c7 44 24 78 00
	00 00 00	 mov	 DWORD PTR tv401[rsp], 0
$LN35@CTCE_Send:
  009c6	48 63 44 24 78	 movsxd	 rax, DWORD PTR tv401[rsp]
  009cb	48 8b 8c 24 f0
	00 00 00	 mov	 rcx, QWORD PTR pDEVBLK$[rsp]
  009d3	48 03 81 c8 01
	00 00		 add	 rax, QWORD PTR [rcx+456]
  009da	48 89 84 24 88
	00 00 00	 mov	 QWORD PTR pSokBuf_written$[rsp], rax

; 2651 :             ( pDEVBLK->ctce_buf_next_read ? pDEVBLK->bufsize / 2 : 0 ) );
; 2652 : 
; 2653 :         // We copy the correct amount of WRITE command data from the
; 2654 :         // device block buffer to the IO buffer and compute Residual.
; 2655 :         memcpy( pIOBuf, ( BYTE * ) pSokBuf_written + sizeof(CTCE_SOKPFX),

  009e2	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR pSokBuf_written$[rsp]
  009ea	0f b7 40 02	 movzx	 eax, WORD PTR [rax+2]
  009ee	39 84 24 f8 00
	00 00		 cmp	 DWORD PTR sCount$[rsp], eax
  009f5	77 0d		 ja	 SHORT $LN36@CTCE_Send
  009f7	8b 84 24 f8 00
	00 00		 mov	 eax, DWORD PTR sCount$[rsp]
  009fe	89 44 24 7c	 mov	 DWORD PTR tv412[rsp], eax
  00a02	eb 10		 jmp	 SHORT $LN37@CTCE_Send
$LN36@CTCE_Send:
  00a04	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR pSokBuf_written$[rsp]
  00a0c	0f b7 40 02	 movzx	 eax, WORD PTR [rax+2]
  00a10	89 44 24 7c	 mov	 DWORD PTR tv412[rsp], eax
$LN37@CTCE_Send:
  00a14	8b 44 24 7c	 mov	 eax, DWORD PTR tv412[rsp]
  00a18	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR pSokBuf_written$[rsp]
  00a20	48 83 c1 10	 add	 rcx, 16
  00a24	48 8b bc 24 00
	01 00 00	 mov	 rdi, QWORD PTR pIOBuf$[rsp]
  00a2c	48 8b f1	 mov	 rsi, rcx
  00a2f	8b c8		 mov	 ecx, eax
  00a31	f3 a4		 rep movsb

; 2656 :             ( sCount <= pSokBuf_written->sCount )
; 2657 :             ? sCount :  pSokBuf_written->sCount );
; 2658 :         *pResidual = sCount - (

  00a33	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR pSokBuf_written$[rsp]
  00a3b	0f b7 40 02	 movzx	 eax, WORD PTR [rax+2]
  00a3f	39 84 24 f8 00
	00 00		 cmp	 DWORD PTR sCount$[rsp], eax
  00a46	77 10		 ja	 SHORT $LN38@CTCE_Send
  00a48	8b 84 24 f8 00
	00 00		 mov	 eax, DWORD PTR sCount$[rsp]
  00a4f	89 84 24 80 00
	00 00		 mov	 DWORD PTR tv422[rsp], eax
  00a56	eb 13		 jmp	 SHORT $LN39@CTCE_Send
$LN38@CTCE_Send:
  00a58	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR pSokBuf_written$[rsp]
  00a60	0f b7 40 02	 movzx	 eax, WORD PTR [rax+2]
  00a64	89 84 24 80 00
	00 00		 mov	 DWORD PTR tv422[rsp], eax
$LN39@CTCE_Send:
  00a6b	8b 84 24 80 00
	00 00		 mov	 eax, DWORD PTR tv422[rsp]
  00a72	8b 8c 24 f8 00
	00 00		 mov	 ecx, DWORD PTR sCount$[rsp]
  00a79	2b c8		 sub	 ecx, eax
  00a7b	8b c1		 mov	 eax, ecx
  00a7d	48 8b 8c 24 10
	01 00 00	 mov	 rcx, QWORD PTR pResidual$[rsp]
  00a85	89 01		 mov	 DWORD PTR [rcx], eax

; 2659 :             ( sCount <= pSokBuf_written->sCount )
; 2660 :             ? sCount :  pSokBuf_written->sCount );
; 2661 :     }

  00a87	eb 0e		 jmp	 SHORT $LN25@CTCE_Send
$LN24@CTCE_Send:

; 2662 :     else
; 2663 :     {
; 2664 :         *pResidual = 0;

  00a89	48 8b 84 24 10
	01 00 00	 mov	 rax, QWORD PTR pResidual$[rsp]
  00a91	c7 00 00 00 00
	00		 mov	 DWORD PTR [rax], 0
$LN25@CTCE_Send:
$LN22@CTCE_Send:

; 2665 :     }
; 2666 : 
; 2667 :     // The final UnitStat may have been amended by CTCE_Recv like when
; 2668 :     // it received a matching command (typically resulting in CE + DE).
; 2669 :     // We need to merge this.
; 2670 :     *pUnitStat |= pDEVBLK->ctce_UnitStat;

  00a97	48 8b 84 24 f0
	00 00 00	 mov	 rax, QWORD PTR pDEVBLK$[rsp]
  00a9f	0f b6 80 39 07
	00 00		 movzx	 eax, BYTE PTR [rax+1849]
  00aa6	48 8b 8c 24 08
	01 00 00	 mov	 rcx, QWORD PTR pUnitStat$[rsp]
  00aae	0f b6 09	 movzx	 ecx, BYTE PTR [rcx]
  00ab1	0b c8		 or	 ecx, eax
  00ab3	8b c1		 mov	 eax, ecx
  00ab5	48 8b 8c 24 08
	01 00 00	 mov	 rcx, QWORD PTR pUnitStat$[rsp]
  00abd	88 01		 mov	 BYTE PTR [rcx], al

; 2671 :     pDEVBLK->ctce_UnitStat = 0;

  00abf	48 8b 84 24 f0
	00 00 00	 mov	 rax, QWORD PTR pDEVBLK$[rsp]
  00ac7	c6 80 39 07 00
	00 00		 mov	 BYTE PTR [rax+1849], 0
$LN1@CTCE_Send:

; 2672 : 
; 2673 :     return;
; 2674 : 
; 2675 : } // CTCE_Send

  00ace	48 81 c4 d8 00
	00 00		 add	 rsp, 216		; 000000d8H
  00ad5	5f		 pop	 rdi
  00ad6	5e		 pop	 rsi
  00ad7	c3		 ret	 0
CTCE_Send ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\ctcadpt.c
_TEXT	SEGMENT
tv73 = 96
tv191 = 100
tv195 = 104
$T1 = 112
tid_connect$ = 120
tv185 = 128
str_connect$ = 144
__$ArrayPad$ = 224
dev$ = 256
CTCE_Start_ConnectThread PROC

; 3504 : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 81 ec f8 00
	00 00		 sub	 rsp, 248		; 000000f8H
  0000c	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00013	48 33 c4	 xor	 rax, rsp
  00016	48 89 84 24 e0
	00 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 3505 :     char           str_connect[80];    // Thread name for client
; 3506 :     TID            tid_connect;        // Thread ID for client
; 3507 : 
; 3508 :     // The other (y-)side will only be initialised in case of regular
; 3509 :     // initialisations, not so for recovery-style re-initializations.
; 3510 :     if( !dev->reinit )

  0001e	48 8b 84 24 00
	01 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00026	8b 80 f8 05 00
	00		 mov	 eax, DWORD PTR [rax+1528]
  0002c	c1 e8 12	 shr	 eax, 18
  0002f	83 e0 01	 and	 eax, 1
  00032	85 c0		 test	 eax, eax
  00034	0f 85 6b 01 00
	00		 jne	 $LN2@CTCE_Start

; 3511 :     {
; 3512 : 
; 3513 :         // The initial CTCA Extended Mode setting can be derived from the SetSIDInfo
; 3514 :         // DevMod byte setting (for both sides), which ended up in dev->devid+6 :
; 3515 :         dev->ctcxmode = (*(dev->devid+6) == 0x00 ) ? 1 : 0 ;

  0003a	48 8b 84 24 00
	01 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00042	0f b6 80 6e 04
	00 00		 movzx	 eax, BYTE PTR [rax+1134]
  00049	85 c0		 test	 eax, eax
  0004b	75 0a		 jne	 SHORT $LN5@CTCE_Start
  0004d	c7 44 24 60 01
	00 00 00	 mov	 DWORD PTR tv73[rsp], 1
  00055	eb 08		 jmp	 SHORT $LN6@CTCE_Start
$LN5@CTCE_Start:
  00057	c7 44 24 60 00
	00 00 00	 mov	 DWORD PTR tv73[rsp], 0
$LN6@CTCE_Start:
  0005f	8b 44 24 60	 mov	 eax, DWORD PTR tv73[rsp]
  00063	83 e0 01	 and	 eax, 1
  00066	48 8b 8c 24 00
	01 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  0006e	8b 89 18 07 00
	00		 mov	 ecx, DWORD PTR [rcx+1816]
  00074	83 e1 fe	 and	 ecx, -2			; fffffffeH
  00077	0b c8		 or	 ecx, eax
  00079	8b c1		 mov	 eax, ecx
  0007b	48 8b 8c 24 00
	01 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  00083	89 81 18 07 00
	00		 mov	 DWORD PTR [rcx+1816], eax

; 3516 :         dev->ctce_remote_xmode = dev->ctcxmode;

  00089	48 8b 84 24 00
	01 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00091	8b 80 18 07 00
	00		 mov	 eax, DWORD PTR [rax+1816]
  00097	83 e0 01	 and	 eax, 1
  0009a	83 e0 01	 and	 eax, 1
  0009d	c1 e0 03	 shl	 eax, 3
  000a0	48 8b 8c 24 00
	01 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  000a8	8b 89 74 07 00
	00		 mov	 ecx, DWORD PTR [rcx+1908]
  000ae	83 e1 f7	 and	 ecx, -9			; fffffff7H
  000b1	0b c8		 or	 ecx, eax
  000b3	8b c1		 mov	 eax, ecx
  000b5	48 8b 8c 24 00
	01 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  000bd	89 81 74 07 00
	00		 mov	 DWORD PTR [rcx+1908], eax

; 3517 : 
; 3518 :         // Enhanced CTC adapter intiialization for y-side command register.
; 3519 :         dev->ctceyCmd = 0x00;

  000c3	48 8b 84 24 00
	01 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  000cb	c6 80 37 07 00
	00 00		 mov	 BYTE PTR [rax+1847], 0

; 3520 : 
; 3521 :         // Enhanced CTC adapter sides are state-aware, with initial
; 3522 :         // state (1) "Available" and (2) "Not Ready" as in column 6 in
; 3523 :         // the table 2.13 in SA22-7203-00, i.e. we consider both
; 3524 :         // sides being in state YNR. ALL Flags are cleared.
; 3525 :         CLR_CTCE_ALLF( dev->ctceyState );

  000d2	48 8b 84 24 00
	01 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  000da	0f b6 80 36 07
	00 00		 movzx	 eax, BYTE PTR [rax+1846]
  000e1	0f ba f0 07	 btr	 eax, 7
  000e5	48 8b 8c 24 00
	01 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  000ed	88 81 36 07 00
	00		 mov	 BYTE PTR [rcx+1846], al

; 3526 :         SET_CTCE_YNR ( dev->ctceyState );

  000f3	48 8b 84 24 00
	01 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  000fb	0f b6 80 36 07
	00 00		 movzx	 eax, BYTE PTR [rax+1846]
  00102	25 f8 00 00 00	 and	 eax, 248		; 000000f8H
  00107	83 c8 05	 or	 eax, 5
  0010a	48 8b 8c 24 00
	01 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  00112	88 81 36 07 00
	00		 mov	 BYTE PTR [rcx+1846], al

; 3527 : 
; 3528 :         // Until we are successfully contacted by the other side,
; 3529 :         // we need to mark the "other side Intervention Required".
; 3530 :         // However, device reset actions in "channel.c" will zero the
; 3531 :         // sense bytes, hence that we set dev->ctce_system_reset here
; 3532 :         // which we use in CTCE_Reset afterwards to correct that.
; 3533 :         dev->ctce_system_reset = 1;

  00118	48 8b 84 24 00
	01 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00120	8b 80 74 07 00
	00		 mov	 eax, DWORD PTR [rax+1908]
  00126	83 c8 10	 or	 eax, 16
  00129	48 8b 8c 24 00
	01 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  00131	89 81 74 07 00
	00		 mov	 DWORD PTR [rcx+1908], eax

; 3534 :         dev->sense[0] = SENSE_IR;

  00137	b8 01 00 00 00	 mov	 eax, 1
  0013c	48 6b c0 00	 imul	 rax, rax, 0
  00140	48 8b 8c 24 00
	01 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  00148	c6 84 01 64 03
	00 00 40	 mov	 BYTE PTR [rcx+rax+868], 64 ; 00000040H

; 3535 : 
; 3536 :         // Initialize the CTC lock and condition used to signal
; 3537 :         // reception of a command matching the dependent one.
; 3538 :         initialize_lock( &dev->ctceEventLock );

  00150	48 8b 84 24 00
	01 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00158	48 05 40 07 00
	00		 add	 rax, 1856		; 00000740H
  0015e	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG170328
  00165	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG170329
  0016c	48 8b c8	 mov	 rcx, rax
  0016f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_initialize_lock

; 3539 :         initialize_condition( &dev->ctceEvent );

  00175	48 8b 84 24 00
	01 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  0017d	48 05 48 07 00
	00		 add	 rax, 1864		; 00000748H
  00183	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG170330
  0018a	48 8b c8	 mov	 rcx, rax
  0018d	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_initialize_condition

; 3540 : 
; 3541 :         // Initialize the CTCE Trace counter for no tracing at all.
; 3542 :         // Use "ctc debug { on | off startup } <devnum>" to change this.
; 3543 :         dev->ctce_trace_cntr = CTCE_TRACE_OFF;

  00193	48 8b 84 24 00
	01 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  0019b	c7 80 68 07 00
	00 fe ff ff ff	 mov	 DWORD PTR [rax+1896], -2
$LN2@CTCE_Start:

; 3544 :     }
; 3545 : 
; 3546 : 
; 3547 :     // Enhanced CTC adapter intiialization for command register and CB.
; 3548 :     dev->ctcexCmd = 0x00;

  001a5	48 8b 84 24 00
	01 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  001ad	c6 80 35 07 00
	00 00		 mov	 BYTE PTR [rax+1845], 0

; 3549 : 
; 3550 :     // Enhanced CTC adapter sides are state-aware, with initial
; 3551 :     // state (1) "Available" and (2) "Not Ready" as in column 6 in
; 3552 :     // the table 2.13 in SA22-7203-00, i.e. we consider both
; 3553 :     // sides being in state YNR. ALL Flags are cleared.
; 3554 :     CLR_CTCE_ALLF( dev->ctcexState );

  001b4	48 8b 84 24 00
	01 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  001bc	0f b6 80 34 07
	00 00		 movzx	 eax, BYTE PTR [rax+1844]
  001c3	0f ba f0 07	 btr	 eax, 7
  001c7	48 8b 8c 24 00
	01 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  001cf	88 81 34 07 00
	00		 mov	 BYTE PTR [rcx+1844], al

; 3555 :     SET_CTCE_YNR ( dev->ctcexState );

  001d5	48 8b 84 24 00
	01 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  001dd	0f b6 80 34 07
	00 00		 movzx	 eax, BYTE PTR [rax+1844]
  001e4	25 f8 00 00 00	 and	 eax, 248		; 000000f8H
  001e9	83 c8 05	 or	 eax, 5
  001ec	48 8b 8c 24 00
	01 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  001f4	88 81 34 07 00
	00		 mov	 BYTE PTR [rcx+1844], al

; 3556 : 
; 3557 :     // Initialize the 12 bits Send->Recv packet sequence ID with
; 3558 :     // bits 13-12 of the CCUU devnum in bits 15-14, and
; 3559 :     // bits 01-00 of the CCUU devnum in bits 13-12.  This helps
; 3560 :     // distinguishing same-host traffic if the Send-Recv side
; 3561 :     // CCUU's are sufficiently different (e.g. when under VM).
; 3562 :     dev->ctcePktSeq = ((dev->devnum <<  2) & 0xC000) |

  001fa	48 8b 84 24 00
	01 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00202	0f b7 40 48	 movzx	 eax, WORD PTR [rax+72]
  00206	c1 e0 02	 shl	 eax, 2
  00209	25 00 c0 00 00	 and	 eax, 49152		; 0000c000H
  0020e	48 8b 8c 24 00
	01 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  00216	0f b7 49 48	 movzx	 ecx, WORD PTR [rcx+72]
  0021a	c1 e1 0c	 shl	 ecx, 12
  0021d	81 e1 00 30 00
	00		 and	 ecx, 12288		; 00003000H
  00223	0b c1		 or	 eax, ecx
  00225	48 8b 8c 24 00
	01 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  0022d	66 89 81 2e 07
	00 00		 mov	 WORD PTR [rcx+1838], ax

; 3563 :                       ((dev->devnum << 12) & 0x3000) ;
; 3564 : 
; 3565 :     MSGBUF( str_connect, "CTCE %4.4X ConnectThread", dev->devnum);

  00234	48 8b 84 24 00
	01 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  0023c	0f b7 40 48	 movzx	 eax, WORD PTR [rax+72]
  00240	44 8b c8	 mov	 r9d, eax
  00243	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG170331
  0024a	ba 50 00 00 00	 mov	 edx, 80			; 00000050H
  0024f	48 8d 8c 24 90
	00 00 00	 lea	 rcx, QWORD PTR str_connect$[rsp]
  00257	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_snprintf

; 3566 :     str_connect[sizeof( str_connect )-1]=0;

  0025d	b8 01 00 00 00	 mov	 eax, 1
  00262	48 6b c0 4f	 imul	 rax, rax, 79		; 0000004fH
  00266	48 89 44 24 70	 mov	 QWORD PTR $T1[rsp], rax
  0026b	48 83 7c 24 70
	50		 cmp	 QWORD PTR $T1[rsp], 80	; 00000050H
  00271	73 02		 jae	 SHORT $LN7@CTCE_Start
  00273	eb 05		 jmp	 SHORT $LN8@CTCE_Start
$LN7@CTCE_Start:
  00275	e8 00 00 00 00	 call	 __report_rangecheckfailure
$LN8@CTCE_Start:
  0027a	48 8b 44 24 70	 mov	 rax, QWORD PTR $T1[rsp]
  0027f	c6 84 04 90 00
	00 00 00	 mov	 BYTE PTR str_connect$[rsp+rax], 0

; 3567 :     if( create_thread( &tid_connect, DETACHED, CTCE_ConnectThread, dev, str_connect ) != 0 )

  00287	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  0028e	48 05 88 10 00
	00		 add	 rax, 4232		; 00001088H
  00294	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170333
  0029b	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  002a0	48 8d 8c 24 90
	00 00 00	 lea	 rcx, QWORD PTR str_connect$[rsp]
  002a8	48 89 4c 24 20	 mov	 QWORD PTR [rsp+32], rcx
  002ad	4c 8b 8c 24 00
	01 00 00	 mov	 r9, QWORD PTR dev$[rsp]
  002b5	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:CTCE_ConnectThread
  002bc	48 8b d0	 mov	 rdx, rax
  002bf	48 8d 4c 24 78	 lea	 rcx, QWORD PTR tid_connect$[rsp]
  002c4	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_create_thread
  002ca	85 c0		 test	 eax, eax
  002cc	0f 84 b0 00 00
	00		 je	 $LN3@CTCE_Start

; 3568 :     {
; 3569 :         WRMSG( HHC05069, "E",  // CTCE: create_thread %s error: %s"

  002d2	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_WSAGetLastError
  002d8	8b c8		 mov	 ecx, eax
  002da	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_strerror
  002e0	48 89 84 24 80
	00 00 00	 mov	 QWORD PTR tv185[rsp], rax
  002e8	48 8b 8c 24 00
	01 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  002f0	0f b7 49 48	 movzx	 ecx, WORD PTR [rcx+72]
  002f4	89 4c 24 64	 mov	 DWORD PTR tv191[rsp], ecx
  002f8	48 8b 94 24 00
	01 00 00	 mov	 rdx, QWORD PTR dev$[rsp]
  00300	0f b7 52 44	 movzx	 edx, WORD PTR [rdx+68]
  00304	d1 fa		 sar	 edx, 1
  00306	89 54 24 68	 mov	 DWORD PTR tv195[rsp], edx
  0030a	b9 01 00 00 00	 mov	 ecx, 1
  0030f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  00315	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR tv185[rsp]
  0031d	48 89 4c 24 50	 mov	 QWORD PTR [rsp+80], rcx
  00322	48 8d 8c 24 90
	00 00 00	 lea	 rcx, QWORD PTR str_connect$[rsp]
  0032a	48 89 4c 24 48	 mov	 QWORD PTR [rsp+72], rcx
  0032f	8b 4c 24 64	 mov	 ecx, DWORD PTR tv191[rsp]
  00333	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  00337	8b 4c 24 68	 mov	 ecx, DWORD PTR tv195[rsp]
  0033b	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  0033f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170334
  00346	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  0034b	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170335
  00352	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00357	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  0035c	41 b9 03 00 00
	00		 mov	 r9d, 3
  00362	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG170336
  00369	ba f2 0d 00 00	 mov	 edx, 3570		; 00000df2H
  0036e	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170337
  00375	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 3570 :             CTCX_DEVNUM( dev ), str_connect, strerror( HSO_errno ) );
; 3571 : 
; 3572 :         return -1;

  0037b	b8 ff ff ff ff	 mov	 eax, -1
  00380	eb 22		 jmp	 SHORT $LN1@CTCE_Start
$LN3@CTCE_Start:

; 3573 :     }
; 3574 : 
; 3575 :     // This completes the CTCE initialisation, which might have been a
; 3576 :     // recovery-style re-initialisation, which we can now mrk as done.
; 3577 :     dev->reinit = 0;

  00382	48 8b 84 24 00
	01 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  0038a	8b 80 f8 05 00
	00		 mov	 eax, DWORD PTR [rax+1528]
  00390	0f ba f0 12	 btr	 eax, 18
  00394	48 8b 8c 24 00
	01 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  0039c	89 81 f8 05 00
	00		 mov	 DWORD PTR [rcx+1528], eax

; 3578 : 
; 3579 :     return 0;

  003a2	33 c0		 xor	 eax, eax
$LN1@CTCE_Start:
$LN4@CTCE_Start:

; 3580 : 
; 3581 : } // CTCE_Start_ConnectThread

  003a4	48 8b 8c 24 e0
	00 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  003ac	48 33 cc	 xor	 rcx, rsp
  003af	e8 00 00 00 00	 call	 __security_check_cookie
  003b4	48 81 c4 f8 00
	00 00		 add	 rsp, 248		; 000000f8H
  003bb	c3		 ret	 0
CTCE_Start_ConnectThread ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\ctcadpt.c
_TEXT	SEGMENT
dev_srch$ = 96
tv184 = 104
tv188 = 108
tv205 = 112
tv209 = 116
tv227 = 120
tv231 = 124
tv248 = 128
tv252 = 132
arg$ = 136
$T1 = 144
remaddr$ = 152
tv199 = 160
tv220 = 168
parm_listen$ = 176
rccuu_addr_rport$ = 208
address$ = 240
str$ = 272
__$ArrayPad$ = 352
dev$ = 400
CTCE_Start_Listen_Connect_Threads PROC

; 2178 : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	56		 push	 rsi
  00006	57		 push	 rdi
  00007	48 81 ec 78 01
	00 00		 sub	 rsp, 376		; 00000178H
  0000e	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00015	48 33 c4	 xor	 rax, rsp
  00018	48 89 84 24 60
	01 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 2179 :     char           str[80];                 // Temp string
; 2180 :     CTCE_PARMBLK   parm_listen;             // Parameters for the server
; 2181 :     CTCE_PARMBLK*  arg;                     // used to pass parameters to the server thread
; 2182 :     char*          remaddr;                 // Remote IP address
; 2183 :     char           address[20];             // String for IP address
; 2184 :     char           rccuu_addr_rport[30];    // String for rcuu and IP address
; 2185 :     DEVBLK*        dev_srch;                // Device block being searched
; 2186 : 
; 2187 :     // for cosmetics, since we are successfully serving,
; 2188 :     // fill in some details for the panel.
; 2189 :     strcpy( address, inet_ntoa( dev->ctce_ipaddr ) );

  00020	48 8b 84 24 90
	01 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00028	8b 88 5c 07 00
	00		 mov	 ecx, DWORD PTR [rax+1884]
  0002e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_inet_ntoa
  00034	48 8b d0	 mov	 rdx, rax
  00037	48 8d 8c 24 f0
	00 00 00	 lea	 rcx, QWORD PTR address$[rsp]
  0003f	e8 00 00 00 00	 call	 strcpy

; 2190 :     remaddr = address;

  00044	48 8d 84 24 f0
	00 00 00	 lea	 rax, QWORD PTR address$[rsp]
  0004c	48 89 84 24 98
	00 00 00	 mov	 QWORD PTR remaddr$[rsp], rax

; 2191 :     MSGBUF( rccuu_addr_rport, "%1d:%04X=%s:%d/*",

  00054	48 8b 84 24 90
	01 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  0005c	0f b7 80 64 07
	00 00		 movzx	 eax, WORD PTR [rax+1892]
  00063	48 8b 8c 24 90
	01 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  0006b	0f b7 49 44	 movzx	 ecx, WORD PTR [rcx+68]
  0006f	d1 f9		 sar	 ecx, 1
  00071	48 8b 94 24 90
	01 00 00	 mov	 rdx, QWORD PTR dev$[rsp]
  00079	8b 92 58 07 00
	00		 mov	 edx, DWORD PTR [rdx+1880]
  0007f	89 54 24 30	 mov	 DWORD PTR [rsp+48], edx
  00083	48 8b 94 24 98
	00 00 00	 mov	 rdx, QWORD PTR remaddr$[rsp]
  0008b	48 89 54 24 28	 mov	 QWORD PTR [rsp+40], rdx
  00090	89 44 24 20	 mov	 DWORD PTR [rsp+32], eax
  00094	44 8b c9	 mov	 r9d, ecx
  00097	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG169899
  0009e	ba 1e 00 00 00	 mov	 edx, 30
  000a3	48 8d 8c 24 d0
	00 00 00	 lea	 rcx, QWORD PTR rccuu_addr_rport$[rsp]
  000ab	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_snprintf

; 2192 :         SSID_TO_LCSS( dev->ssid ), dev->ctce_rccuu, remaddr, dev->ctce_rport );
; 2193 :     strcpy(  dev->filename, rccuu_addr_rport );

  000b1	48 8b 84 24 90
	01 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  000b9	48 05 a4 00 00
	00		 add	 rax, 164		; 000000a4H
  000bf	48 8d 94 24 d0
	00 00 00	 lea	 rdx, QWORD PTR rccuu_addr_rport$[rsp]
  000c7	48 8b c8	 mov	 rcx, rax
  000ca	e8 00 00 00 00	 call	 strcpy

; 2194 : 
; 2195 :     // We only need to start a listen thread provided no such thread
; 2196 :     // listening on that port number is already running.  We search
; 2197 :     // the device blocks to see if none has been started yet.
; 2198 :     for ( dev_srch = sysblk.firstdev; dev_srch; dev_srch = dev_srch->nextdev )

  000cf	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  000d6	48 8b 80 c0 11
	00 00		 mov	 rax, QWORD PTR [rax+4544]
  000dd	48 89 44 24 60	 mov	 QWORD PTR dev_srch$[rsp], rax
  000e2	eb 0e		 jmp	 SHORT $LN4@CTCE_Start
$LN2@CTCE_Start:
  000e4	48 8b 44 24 60	 mov	 rax, QWORD PTR dev_srch$[rsp]
  000e9	48 8b 40 30	 mov	 rax, QWORD PTR [rax+48]
  000ed	48 89 44 24 60	 mov	 QWORD PTR dev_srch$[rsp], rax
$LN4@CTCE_Start:
  000f2	48 83 7c 24 60
	00		 cmp	 QWORD PTR dev_srch$[rsp], 0
  000f8	74 45		 je	 SHORT $LN3@CTCE_Start

; 2199 :     {
; 2200 :         if ( 1
; 2201 :             && dev_srch->ctctype == CTC_CTCE
; 2202 :             && dev_srch->ctce_listen_tid != 0
; 2203 :             && dev_srch->ctce_lport ==  dev->ctce_lport

  000fa	33 c0		 xor	 eax, eax
  000fc	83 f8 01	 cmp	 eax, 1
  000ff	74 3c		 je	 SHORT $LN5@CTCE_Start
  00101	48 8b 44 24 60	 mov	 rax, QWORD PTR dev_srch$[rsp]
  00106	0f b6 80 1c 07
	00 00		 movzx	 eax, BYTE PTR [rax+1820]
  0010d	83 f8 04	 cmp	 eax, 4
  00110	75 2b		 jne	 SHORT $LN5@CTCE_Start
  00112	48 8b 44 24 60	 mov	 rax, QWORD PTR dev_srch$[rsp]
  00117	83 b8 70 07 00
	00 00		 cmp	 DWORD PTR [rax+1904], 0
  0011e	74 1d		 je	 SHORT $LN5@CTCE_Start
  00120	48 8b 44 24 60	 mov	 rax, QWORD PTR dev_srch$[rsp]
  00125	48 8b 8c 24 90
	01 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  0012d	8b 89 50 07 00
	00		 mov	 ecx, DWORD PTR [rcx+1872]
  00133	39 88 50 07 00
	00		 cmp	 DWORD PTR [rax+1872], ecx
  00139	75 02		 jne	 SHORT $LN5@CTCE_Start

; 2204 :         )
; 2205 :         {
; 2206 :             break;

  0013b	eb 02		 jmp	 SHORT $LN3@CTCE_Start
$LN5@CTCE_Start:

; 2207 :         }
; 2208 :     }

  0013d	eb a5		 jmp	 SHORT $LN2@CTCE_Start
$LN3@CTCE_Start:

; 2209 : 
; 2210 :     // OK if none has been started yet.
; 2211 :     if ( !dev_srch )

  0013f	48 83 7c 24 60
	00		 cmp	 QWORD PTR dev_srch$[rsp], 0
  00145	0f 85 a7 03 00
	00		 jne	 $LN6@CTCE_Start

; 2212 :     {
; 2213 : 
; 2214 :         // Get a socket for the listening port.
; 2215 :         memset( &(parm_listen.addr), 0, sizeof( parm_listen.addr ) );

  0014b	48 8d 84 24 b4
	00 00 00	 lea	 rax, QWORD PTR parm_listen$[rsp+4]
  00153	48 8b f8	 mov	 rdi, rax
  00156	33 c0		 xor	 eax, eax
  00158	b9 10 00 00 00	 mov	 ecx, 16
  0015d	f3 aa		 rep stosb

; 2216 :         parm_listen.addr.sin_family      = AF_INET;

  0015f	b8 02 00 00 00	 mov	 eax, 2
  00164	66 89 84 24 b4
	00 00 00	 mov	 WORD PTR parm_listen$[rsp+4], ax

; 2217 :         parm_listen.addr.sin_port        = htons( dev->ctce_lport );

  0016c	48 8b 84 24 90
	01 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00174	0f b7 88 50 07
	00 00		 movzx	 ecx, WORD PTR [rax+1872]
  0017b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_htons
  00181	66 89 84 24 b6
	00 00 00	 mov	 WORD PTR parm_listen$[rsp+6], ax

; 2218 :         parm_listen.addr.sin_addr.s_addr = htonl( INADDR_ANY );

  00189	33 c9		 xor	 ecx, ecx
  0018b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_htonl
  00191	89 84 24 b8 00
	00 00		 mov	 DWORD PTR parm_listen$[rsp+8], eax

; 2219 :         if ( ( parm_listen.fd = CTCE_Get_Socket( dev, CTCE_SOK_LIS ) ) < 0 )

  00198	33 d2		 xor	 edx, edx
  0019a	48 8b 8c 24 90
	01 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  001a2	e8 00 00 00 00	 call	 CTCE_Get_Socket
  001a7	89 84 24 b0 00
	00 00		 mov	 DWORD PTR parm_listen$[rsp], eax
  001ae	83 bc 24 b0 00
	00 00 00	 cmp	 DWORD PTR parm_listen$[rsp], 0
  001b6	7d 0f		 jge	 SHORT $LN7@CTCE_Start

; 2220 :         {
; 2221 :             return -1;

  001b8	b8 ff ff ff ff	 mov	 eax, -1
  001bd	e9 ed 03 00 00	 jmp	 $LN1@CTCE_Start

; 2222 :         }

  001c2	e9 2b 03 00 00	 jmp	 $LN8@CTCE_Start
$LN7@CTCE_Start:

; 2223 :         else
; 2224 :         {
; 2225 : 
; 2226 :             // The backlog parameter is set to 128 to avoid connection refused
; 2227 :             // situations when high numbers of CTCE devices are defined.
; 2228 :             if ( listen( parm_listen.fd, 128 ) > -1 )

  001c7	48 63 84 24 b0
	00 00 00	 movsxd	 rax, DWORD PTR parm_listen$[rsp]
  001cf	ba 80 00 00 00	 mov	 edx, 128		; 00000080H
  001d4	48 8b c8	 mov	 rcx, rax
  001d7	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_listen
  001dd	83 f8 ff	 cmp	 eax, -1
  001e0	0f 8e 47 02 00
	00		 jle	 $LN9@CTCE_Start

; 2229 :             {
; 2230 : 
; 2231 :                 // We are listening, so create a thread to accept connections.
; 2232 :                 arg = malloc( sizeof( CTCE_PARMBLK ) );

  001e6	b9 20 00 00 00	 mov	 ecx, 32			; 00000020H
  001eb	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_malloc
  001f1	48 89 84 24 88
	00 00 00	 mov	 QWORD PTR arg$[rsp], rax

; 2233 :                 memcpy( arg, &parm_listen, sizeof( parm_listen ) );

  001f9	48 8d 84 24 b0
	00 00 00	 lea	 rax, QWORD PTR parm_listen$[rsp]
  00201	48 8b bc 24 88
	00 00 00	 mov	 rdi, QWORD PTR arg$[rsp]
  00209	48 8b f0	 mov	 rsi, rax
  0020c	b9 20 00 00 00	 mov	 ecx, 32			; 00000020H
  00211	f3 a4		 rep movsb

; 2234 :                 arg->dev = dev;

  00213	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR arg$[rsp]
  0021b	48 8b 8c 24 90
	01 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  00223	48 89 48 18	 mov	 QWORD PTR [rax+24], rcx

; 2235 :                 MSGBUF( str, "CTCE %4.4X ListenThread", dev->devnum );

  00227	48 8b 84 24 90
	01 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  0022f	0f b7 40 48	 movzx	 eax, WORD PTR [rax+72]
  00233	44 8b c8	 mov	 r9d, eax
  00236	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG169906
  0023d	ba 50 00 00 00	 mov	 edx, 80			; 00000050H
  00242	48 8d 8c 24 10
	01 00 00	 lea	 rcx, QWORD PTR str$[rsp]
  0024a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_snprintf

; 2236 :                 str[sizeof( str ) - 1] = 0;

  00250	b8 01 00 00 00	 mov	 eax, 1
  00255	48 6b c0 4f	 imul	 rax, rax, 79		; 0000004fH
  00259	48 89 84 24 90
	00 00 00	 mov	 QWORD PTR $T1[rsp], rax
  00261	48 83 bc 24 90
	00 00 00 50	 cmp	 QWORD PTR $T1[rsp], 80	; 00000050H
  0026a	73 02		 jae	 SHORT $LN15@CTCE_Start
  0026c	eb 05		 jmp	 SHORT $LN16@CTCE_Start
$LN15@CTCE_Start:
  0026e	e8 00 00 00 00	 call	 __report_rangecheckfailure
$LN16@CTCE_Start:
  00273	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR $T1[rsp]
  0027b	c6 84 04 10 01
	00 00 00	 mov	 BYTE PTR str$[rsp+rax], 0

; 2237 :                 if ( create_thread( &dev->ctce_listen_tid, DETACHED, CTCE_ListenThread, arg, str ) == 0 )

  00283	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  0028a	48 05 88 10 00
	00		 add	 rax, 4232		; 00001088H
  00290	48 8b 8c 24 90
	01 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  00298	48 81 c1 70 07
	00 00		 add	 rcx, 1904		; 00000770H
  0029f	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG169909
  002a6	48 89 54 24 28	 mov	 QWORD PTR [rsp+40], rdx
  002ab	48 8d 94 24 10
	01 00 00	 lea	 rdx, QWORD PTR str$[rsp]
  002b3	48 89 54 24 20	 mov	 QWORD PTR [rsp+32], rdx
  002b8	4c 8b 8c 24 88
	00 00 00	 mov	 r9, QWORD PTR arg$[rsp]
  002c0	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:CTCE_ListenThread
  002c7	48 8b d0	 mov	 rdx, rax
  002ca	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_create_thread
  002d0	85 c0		 test	 eax, eax
  002d2	0f 85 9d 00 00
	00		 jne	 $LN11@CTCE_Start

; 2238 :                 {
; 2239 :                     WRMSG( HHC05063, "I",  // CTCE: Awaiting inbound connection :%5d <- %s"

  002d8	48 8b 84 24 90
	01 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  002e0	0f b7 40 48	 movzx	 eax, WORD PTR [rax+72]
  002e4	89 44 24 68	 mov	 DWORD PTR tv184[rsp], eax
  002e8	48 8b 8c 24 90
	01 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  002f0	0f b7 49 44	 movzx	 ecx, WORD PTR [rcx+68]
  002f4	d1 f9		 sar	 ecx, 1
  002f6	89 4c 24 6c	 mov	 DWORD PTR tv188[rsp], ecx
  002fa	b9 01 00 00 00	 mov	 ecx, 1
  002ff	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  00305	48 8d 8c 24 d0
	00 00 00	 lea	 rcx, QWORD PTR rccuu_addr_rport$[rsp]
  0030d	48 89 4c 24 50	 mov	 QWORD PTR [rsp+80], rcx
  00312	48 8b 8c 24 90
	01 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  0031a	8b 89 50 07 00
	00		 mov	 ecx, DWORD PTR [rcx+1872]
  00320	89 4c 24 48	 mov	 DWORD PTR [rsp+72], ecx
  00324	8b 4c 24 68	 mov	 ecx, DWORD PTR tv184[rsp]
  00328	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  0032c	8b 4c 24 6c	 mov	 ecx, DWORD PTR tv188[rsp]
  00330	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  00334	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169910
  0033b	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  00340	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169911
  00347	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  0034c	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00351	41 b9 03 00 00
	00		 mov	 r9d, 3
  00357	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG169912
  0035e	ba c0 08 00 00	 mov	 edx, 2240		; 000008c0H
  00363	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169913
  0036a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 2240 :                         CTCX_DEVNUM( dev ), dev->ctce_lport, rccuu_addr_rport );
; 2241 :                 }

  00370	e9 b3 00 00 00	 jmp	 $LN12@CTCE_Start
$LN11@CTCE_Start:

; 2242 :                 else
; 2243 :                 {
; 2244 :                     WRMSG( HHC05080, "E",  // CTCE: create listen thread %s error: %s"

  00375	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_WSAGetLastError
  0037b	8b c8		 mov	 ecx, eax
  0037d	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_strerror
  00383	48 89 84 24 a0
	00 00 00	 mov	 QWORD PTR tv199[rsp], rax
  0038b	48 8b 8c 24 90
	01 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  00393	0f b7 49 48	 movzx	 ecx, WORD PTR [rcx+72]
  00397	89 4c 24 70	 mov	 DWORD PTR tv205[rsp], ecx
  0039b	48 8b 94 24 90
	01 00 00	 mov	 rdx, QWORD PTR dev$[rsp]
  003a3	0f b7 52 44	 movzx	 edx, WORD PTR [rdx+68]
  003a7	d1 fa		 sar	 edx, 1
  003a9	89 54 24 74	 mov	 DWORD PTR tv209[rsp], edx
  003ad	b9 01 00 00 00	 mov	 ecx, 1
  003b2	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  003b8	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR tv199[rsp]
  003c0	48 89 4c 24 50	 mov	 QWORD PTR [rsp+80], rcx
  003c5	48 8d 8c 24 10
	01 00 00	 lea	 rcx, QWORD PTR str$[rsp]
  003cd	48 89 4c 24 48	 mov	 QWORD PTR [rsp+72], rcx
  003d2	8b 4c 24 70	 mov	 ecx, DWORD PTR tv205[rsp]
  003d6	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  003da	8b 4c 24 74	 mov	 ecx, DWORD PTR tv209[rsp]
  003de	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  003e2	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169914
  003e9	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  003ee	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169915
  003f5	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  003fa	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  003ff	41 b9 03 00 00
	00		 mov	 r9d, 3
  00405	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG169916
  0040c	ba c5 08 00 00	 mov	 edx, 2245		; 000008c5H
  00411	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169917
  00418	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 2245 :                         CTCX_DEVNUM( dev ), str, strerror( HSO_errno ) );
; 2246 :                     return -1;

  0041e	b8 ff ff ff ff	 mov	 eax, -1
  00423	e9 87 01 00 00	 jmp	 $LN1@CTCE_Start
$LN12@CTCE_Start:

; 2247 :                 }
; 2248 :             }

  00428	e9 c5 00 00 00	 jmp	 $LN10@CTCE_Start
$LN9@CTCE_Start:

; 2249 :             else
; 2250 :             {
; 2251 :                 WRMSG( HHC05066, "E",  /* CTCE: Error on call to listen (port=%d): %s */

  0042d	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_WSAGetLastError
  00433	8b c8		 mov	 ecx, eax
  00435	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_strerror
  0043b	48 89 84 24 a8
	00 00 00	 mov	 QWORD PTR tv220[rsp], rax
  00443	48 8b 8c 24 90
	01 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  0044b	0f b7 49 48	 movzx	 ecx, WORD PTR [rcx+72]
  0044f	89 4c 24 78	 mov	 DWORD PTR tv227[rsp], ecx
  00453	48 8b 94 24 90
	01 00 00	 mov	 rdx, QWORD PTR dev$[rsp]
  0045b	0f b7 52 44	 movzx	 edx, WORD PTR [rdx+68]
  0045f	d1 fa		 sar	 edx, 1
  00461	89 54 24 7c	 mov	 DWORD PTR tv231[rsp], edx
  00465	b9 01 00 00 00	 mov	 ecx, 1
  0046a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  00470	48 8b 8c 24 a8
	00 00 00	 mov	 rcx, QWORD PTR tv220[rsp]
  00478	48 89 4c 24 50	 mov	 QWORD PTR [rsp+80], rcx
  0047d	48 8b 8c 24 90
	01 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  00485	8b 89 50 07 00
	00		 mov	 ecx, DWORD PTR [rcx+1872]
  0048b	89 4c 24 48	 mov	 DWORD PTR [rsp+72], ecx
  0048f	8b 4c 24 78	 mov	 ecx, DWORD PTR tv227[rsp]
  00493	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  00497	8b 4c 24 7c	 mov	 ecx, DWORD PTR tv231[rsp]
  0049b	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  0049f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169918
  004a6	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  004ab	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169919
  004b2	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  004b7	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  004bc	41 b9 03 00 00
	00		 mov	 r9d, 3
  004c2	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG169920
  004c9	ba cc 08 00 00	 mov	 edx, 2252		; 000008ccH
  004ce	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169921
  004d5	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 2252 :                     CTCX_DEVNUM( dev ), dev->ctce_lport, strerror( HSO_errno ) );
; 2253 :                 close_socket( parm_listen.fd );

  004db	8b 8c 24 b0 00
	00 00		 mov	 ecx, DWORD PTR parm_listen$[rsp]
  004e2	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_close_socket

; 2254 :                 return -1;

  004e8	b8 ff ff ff ff	 mov	 eax, -1
  004ed	e9 bd 00 00 00	 jmp	 $LN1@CTCE_Start
$LN10@CTCE_Start:
$LN8@CTCE_Start:
$LN6@CTCE_Start:

; 2255 :             }
; 2256 :         }
; 2257 :     }
; 2258 : 
; 2259 :     // If we did not have to start a CTCE_ListenThread, then we report that.
; 2260 :     if ( dev_srch )

  004f2	48 83 7c 24 60
	00		 cmp	 QWORD PTR dev_srch$[rsp], 0
  004f8	0f 84 a4 00 00
	00		 je	 $LN13@CTCE_Start

; 2261 :     {
; 2262 :         WRMSG( HHC05081, "I",  // CTCE: Already awaiting connection :%5d <- %s"

  004fe	48 8b 84 24 90
	01 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00506	0f b7 40 48	 movzx	 eax, WORD PTR [rax+72]
  0050a	89 84 24 80 00
	00 00		 mov	 DWORD PTR tv248[rsp], eax
  00511	48 8b 8c 24 90
	01 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  00519	0f b7 49 44	 movzx	 ecx, WORD PTR [rcx+68]
  0051d	d1 f9		 sar	 ecx, 1
  0051f	89 8c 24 84 00
	00 00		 mov	 DWORD PTR tv252[rsp], ecx
  00526	b9 01 00 00 00	 mov	 ecx, 1
  0052b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  00531	48 8d 8c 24 d0
	00 00 00	 lea	 rcx, QWORD PTR rccuu_addr_rport$[rsp]
  00539	48 89 4c 24 50	 mov	 QWORD PTR [rsp+80], rcx
  0053e	48 8b 8c 24 90
	01 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  00546	8b 89 50 07 00
	00		 mov	 ecx, DWORD PTR [rcx+1872]
  0054c	89 4c 24 48	 mov	 DWORD PTR [rsp+72], ecx
  00550	8b 8c 24 80 00
	00 00		 mov	 ecx, DWORD PTR tv248[rsp]
  00557	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  0055b	8b 8c 24 84 00
	00 00		 mov	 ecx, DWORD PTR tv252[rsp]
  00562	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  00566	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169923
  0056d	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  00572	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169924
  00579	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  0057e	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00583	41 b9 03 00 00
	00		 mov	 r9d, 3
  00589	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG169925
  00590	ba d7 08 00 00	 mov	 edx, 2263		; 000008d7H
  00595	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169926
  0059c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg
$LN13@CTCE_Start:

; 2263 :             CTCX_DEVNUM( dev ), dev->ctce_lport, rccuu_addr_rport );
; 2264 :     }
; 2265 : 
; 2266 :     // We're now ready to start the Connect thread to
; 2267 :     // asynchronously connect to the partner CTCE when present.
; 2268 :     return CTCE_Start_ConnectThread( dev );

  005a2	48 8b 8c 24 90
	01 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  005aa	e8 00 00 00 00	 call	 CTCE_Start_ConnectThread
$LN1@CTCE_Start:
$LN14@CTCE_Start:

; 2269 : 
; 2270 : } // CTCE_Start_Listen_Connect_Threads

  005af	48 8b 8c 24 60
	01 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  005b7	48 33 cc	 xor	 rcx, rsp
  005ba	e8 00 00 00 00	 call	 __security_check_cookie
  005bf	48 81 c4 78 01
	00 00		 add	 rsp, 376		; 00000178H
  005c6	5f		 pop	 rdi
  005c7	5e		 pop	 rsi
  005c8	c3		 ret	 0
CTCE_Start_Listen_Connect_Threads ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\ctcadpt.c
_TEXT	SEGMENT
next_arg$ = 96
c$ = 100
argc_updated$ = 104
mtu$ = 108
ctceSmlBin$ = 112
remaddr$ = 120
tv143 = 128
tv198 = 132
tv215 = 136
tv219 = 140
tv251 = 144
tv255 = 148
tv287 = 152
tv290 = 156
tv294 = 160
tv347 = 164
tv351 = 168
tv383 = 172
tv387 = 176
tv402 = 180
tv406 = 184
tv469 = 188
tv473 = 192
tv504 = 196
tv508 = 200
tv528 = 204
tv532 = 208
tv194 = 212
attndelay$ = 216
listenp$ = 224
equal_sign$ = 232
hp$1 = 240
remotep$ = 248
mtusize$ = 256
ctceSmlChr$ = 264
tv525 = 272
address$ = 280
__$ArrayPad$ = 304
dev$ = 352
argc$ = 360
argv$ = 368
CTCE_Init PROC

; 1906 : {

  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00009	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000e	56		 push	 rsi
  0000f	57		 push	 rdi
  00010	48 81 ec 48 01
	00 00		 sub	 rsp, 328		; 00000148H
  00017	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  0001e	48 33 c4	 xor	 rax, rsp
  00021	48 89 84 24 30
	01 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 1907 :     int            mtu;                // MTU size (binary)
; 1908 :     char*          listenp;            // Listening port number
; 1909 :     char*          remotep;            // Destination port number
; 1910 :     char*          mtusize;            // MTU size (characters)
; 1911 :     char*          remaddr;            // Remote IP address
; 1912 :     BYTE           c;                  // Character work area
; 1913 :     int            ctceSmlBin;         // Small size (binary)
; 1914 :     char*          ctceSmlChr;         // Small size (characters)
; 1915 :     char           address[20]="";     // temp space for IP address

  00029	0f b6 05 00 00
	00 00		 movzx	 eax, BYTE PTR $SG169795
  00030	88 84 24 18 01
	00 00		 mov	 BYTE PTR address$[rsp], al
  00037	48 8d 84 24 19
	01 00 00	 lea	 rax, QWORD PTR address$[rsp+1]
  0003f	48 8b f8	 mov	 rdi, rax
  00042	33 c0		 xor	 eax, eax
  00044	b9 13 00 00 00	 mov	 ecx, 19
  00049	f3 aa		 rep stosb

; 1916 :     int            next_arg = 0;       // Proceeds upto argc - 1

  0004b	c7 44 24 60 00
	00 00 00	 mov	 DWORD PTR next_arg$[rsp], 0

; 1917 :     char*          equal_sign;         // CCUU - IP address separator
; 1918 :     int            argc_updated = argc;

  00053	8b 84 24 68 01
	00 00		 mov	 eax, DWORD PTR argc$[rsp]
  0005a	89 44 24 68	 mov	 DWORD PTR argc_updated$[rsp], eax

; 1919 :     char*          attndelay;          // Optional ATTNDELAY parm keyword
; 1920 : 
; 1921 :     // In case of a "devinit" command prior to a CTCE connection,
; 1922 :     // we want to close down the connect() thread.  We simulate a
; 1923 :     // "detach" command followed by a 0.7 sec sleep during which
; 1924 :     // we unlock the device to accomplish this.
; 1925 :     if( dev->reinit )

  0005e	48 8b 84 24 60
	01 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00066	8b 80 f8 05 00
	00		 mov	 eax, DWORD PTR [rax+1528]
  0006c	c1 e8 12	 shr	 eax, 18
  0006f	83 e0 01	 and	 eax, 1
  00072	85 c0		 test	 eax, eax
  00074	0f 84 81 00 00
	00		 je	 $LN2@CTCE_Init

; 1926 :     {
; 1927 :         if( dev->fd < 0 )

  0007a	48 8b 84 24 60
	01 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00082	83 b8 ac 01 00
	00 00		 cmp	 DWORD PTR [rax+428], 0
  00089	7d 63		 jge	 SHORT $LN3@CTCE_Init

; 1928 :         {
; 1929 :             dev->allocated = 0;

  0008b	48 8b 84 24 60
	01 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00093	c7 40 40 00 00
	00 00		 mov	 DWORD PTR [rax+64], 0

; 1930 :             release_lock( &dev->lock );

  0009a	48 8b 84 24 60
	01 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  000a2	48 83 c0 38	 add	 rax, 56			; 00000038H
  000a6	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG169799
  000ad	48 8b c8	 mov	 rcx, rax
  000b0	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_release_lock

; 1931 :             usleep(700000);

  000b6	b9 60 ae 0a 00	 mov	 ecx, 700000		; 000aae60H
  000bb	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_usleep

; 1932 :             obtain_lock( &dev->lock );

  000c1	48 8b 84 24 60
	01 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  000c9	48 83 c0 38	 add	 rax, 56			; 00000038H
  000cd	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG169800
  000d4	48 8b c8	 mov	 rcx, rax
  000d7	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_obtain_lock

; 1933 :             dev->allocated = 1;

  000dd	48 8b 84 24 60
	01 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  000e5	c7 40 40 01 00
	00 00		 mov	 DWORD PTR [rax+64], 1

; 1934 :         }

  000ec	eb 0d		 jmp	 SHORT $LN4@CTCE_Init
$LN3@CTCE_Init:

; 1935 :         else
; 1936 :         {
; 1937 : 
; 1938 :             // Otherwise "devinit" closes the CTCE connection.
; 1939 :             CTCE_Close( dev );

  000ee	48 8b 8c 24 60
	01 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  000f6	e8 00 00 00 00	 call	 CTCE_Close
$LN4@CTCE_Init:
$LN2@CTCE_Init:

; 1940 :         }
; 1941 :     }
; 1942 : 
; 1943 :     dev->devtype = 0x3088;

  000fb	b8 88 30 00 00	 mov	 eax, 12424		; 00003088H
  00100	48 8b 8c 24 60
	01 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  00108	66 89 41 4a	 mov	 WORD PTR [rcx+74], ax

; 1944 : 
; 1945 :     dev->ctctype = CTC_CTCE;

  0010c	48 8b 84 24 60
	01 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00114	c6 80 1c 07 00
	00 04		 mov	 BYTE PTR [rax+1820], 4

; 1946 : 
; 1947 : //  SetSIDInfo( dev, 0x3088, 0x08, 0x0000, 0x00 ); CTCA, Extended Mode
; 1948 : //  SetSIDInfo( dev, 0x3088, 0x08, 0x0000, 0x01 ); CTCA, Basic    Mode
; 1949 : //  SetSIDInfo( dev, 0x3088, 0x1F, 0x0000, 0x00 ); ESCON CTC, Extended Mode, i.e. SCTC
; 1950 : //  SetSIDInfo( dev, 0x3088, 0x1F, 0x0000, 0x01 ); ESCON CTC, Basic    Mode, i.e. BCTC
; 1951 : //  SetSIDInfo( dev, 0x3088, 0x1E, 0x0000, 0x00 ); FICON CTC
; 1952 : //  SetSIDInfo( dev, 0x3088, 0x01, ...          ); P390 OSA emulation
; 1953 : //  SetSIDInfo( dev, 0x3088, 0x60, ...          ); OSA/2 adapter
; 1954 : //  SetSIDInfo( dev, 0x3088, 0x61, ...          ); CISCO 7206 CLAW protocol ESCON connected
; 1955 : //  SetSIDInfo( dev, 0x3088, 0x62, ...          ); OSA/D device
; 1956 : //  But the orignal CTCX_init had this :
; 1957 :     SetSIDInfo( dev, 0x3088, 0x08, 0x3088, 0x01 );

  0011b	c6 44 24 20 01	 mov	 BYTE PTR [rsp+32], 1
  00120	66 41 b9 88 30	 mov	 r9w, 12424		; 00003088H
  00125	41 b0 08	 mov	 r8b, 8
  00128	66 ba 88 30	 mov	 dx, 12424		; 00003088H
  0012c	48 8b 8c 24 60
	01 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  00134	e8 00 00 00 00	 call	 SetSIDInfo

; 1958 : 
; 1959 :     dev->numsense = 2;

  00139	48 8b 84 24 60
	01 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00141	c7 80 60 03 00
	00 02 00 00 00	 mov	 DWORD PTR [rax+864], 2

; 1960 :     // A version 4 only feature ...
; 1961 :     dev->excps = 0;

  0014b	48 8b 84 24 60
	01 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00153	48 c7 80 00 06
	00 00 00 00 00
	00		 mov	 QWORD PTR [rax+1536], 0

; 1962 : 
; 1963 :     // The halt_device exit is established; in version 4 this is in DEVHND in the ctce_device_hndinfo.
; 1964 : //  dev->halt_device = &CTCE_Reset;
; 1965 : 
; 1966 :     // Mark both socket file descriptors as not yet connected.
; 1967 :     dev->fd = -1;       // For send / write to the other (y-) side

  0015e	48 8b 84 24 60
	01 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00166	c7 80 ac 01 00
	00 ff ff ff ff	 mov	 DWORD PTR [rax+428], -1

; 1968 :     dev->ctcefd = -1;   // For receive / read from the other (y-)side

  00170	48 8b 84 24 60
	01 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00178	c7 80 3c 07 00
	00 ff ff ff ff	 mov	 DWORD PTR [rax+1852], -1

; 1969 : 
; 1970 :     // We begin by checking the trailing parameter for the optional keyword FICON.
; 1971 :     // FCTC's support for the RCD command must be supplied via Sense ID.
; 1972 :     dev->ctce_ficon = ( strcasecmp( argv[argc - 1], "FICON" ) == 0 );

  00182	8b 84 24 68 01
	00 00		 mov	 eax, DWORD PTR argc$[rsp]
  00189	ff c8		 dec	 eax
  0018b	48 98		 cdqe
  0018d	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG169801
  00194	48 8b 8c 24 70
	01 00 00	 mov	 rcx, QWORD PTR argv$[rsp]
  0019c	48 8b 0c c1	 mov	 rcx, QWORD PTR [rcx+rax*8]
  001a0	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__stricmp
  001a6	85 c0		 test	 eax, eax
  001a8	75 0d		 jne	 SHORT $LN39@CTCE_Init
  001aa	c7 84 24 80 00
	00 00 01 00 00
	00		 mov	 DWORD PTR tv143[rsp], 1
  001b5	eb 0b		 jmp	 SHORT $LN40@CTCE_Init
$LN39@CTCE_Init:
  001b7	c7 84 24 80 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv143[rsp], 0
$LN40@CTCE_Init:
  001c2	8b 84 24 80 00
	00 00		 mov	 eax, DWORD PTR tv143[rsp]
  001c9	83 e0 01	 and	 eax, 1
  001cc	c1 e0 02	 shl	 eax, 2
  001cf	48 8b 8c 24 60
	01 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  001d7	8b 89 74 07 00
	00		 mov	 ecx, DWORD PTR [rcx+1908]
  001dd	83 e1 fb	 and	 ecx, -5			; fffffffbH
  001e0	0b c8		 or	 ecx, eax
  001e2	8b c1		 mov	 eax, ecx
  001e4	48 8b 8c 24 60
	01 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  001ec	89 81 74 07 00
	00		 mov	 DWORD PTR [rcx+1908], eax

; 1973 :     argc_updated = argc - dev->ctce_ficon;

  001f2	48 8b 84 24 60
	01 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  001fa	8b 80 74 07 00
	00		 mov	 eax, DWORD PTR [rax+1908]
  00200	c1 e8 02	 shr	 eax, 2
  00203	83 e0 01	 and	 eax, 1
  00206	8b 8c 24 68 01
	00 00		 mov	 ecx, DWORD PTR argc$[rsp]
  0020d	2b c8		 sub	 ecx, eax
  0020f	8b c1		 mov	 eax, ecx
  00211	89 44 24 68	 mov	 DWORD PTR argc_updated$[rsp], eax

; 1974 :     if ( dev->ctce_ficon )

  00215	48 8b 84 24 60
	01 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  0021d	8b 80 74 07 00
	00		 mov	 eax, DWORD PTR [rax+1908]
  00223	c1 e8 02	 shr	 eax, 2
  00226	83 e0 01	 and	 eax, 1
  00229	85 c0		 test	 eax, eax
  0022b	74 38		 je	 SHORT $LN5@CTCE_Init

; 1975 :     {
; 1976 :         SetSIDInfo( dev, 0x3088, 0x1E, 0x0000, 0x00 );

  0022d	c6 44 24 20 00	 mov	 BYTE PTR [rsp+32], 0
  00232	45 33 c9	 xor	 r9d, r9d
  00235	41 b0 1e	 mov	 r8b, 30
  00238	66 ba 88 30	 mov	 dx, 12424		; 00003088H
  0023c	48 8b 8c 24 60
	01 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  00244	e8 00 00 00 00	 call	 SetSIDInfo

; 1977 :         SetCIWInfo( dev, 0, 0, 0xC4, 0x0080 );

  00249	66 c7 44 24 20
	80 00		 mov	 WORD PTR [rsp+32], 128	; 00000080H
  00250	41 b1 c4	 mov	 r9b, 196		; 000000c4H
  00253	45 33 c0	 xor	 r8d, r8d
  00256	33 d2		 xor	 edx, edx
  00258	48 8b 8c 24 60
	01 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  00260	e8 00 00 00 00	 call	 SetCIWInfo
$LN5@CTCE_Init:

; 1978 :     }
; 1979 : 
; 1980 :     // We check for the next trailing optional parameter ATTNDELAY <nnn> which
; 1981 :     // can be used to insert a delay of <nnn> msec prior to ATTN interrupts.
; 1982 :     // This was found to be needed for circumventing a probable VM/SP VTAM 3 bug.
; 1983 :     dev->ctce_attn_delay = 0;                    // Defaults to 0

  00265	48 8b 84 24 60
	01 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  0026d	c7 80 6c 07 00
	00 00 00 00 00	 mov	 DWORD PTR [rax+1900], 0

; 1984 :     if ( argc_updated > 2 )

  00277	83 7c 24 68 02	 cmp	 DWORD PTR argc_updated$[rsp], 2
  0027c	0f 8e 3b 01 00
	00		 jle	 $LN6@CTCE_Init

; 1985 :     {
; 1986 :         if ( strcasecmp( argv[argc_updated - 2], "ATTNDELAY" ) == 0 )

  00282	8b 44 24 68	 mov	 eax, DWORD PTR argc_updated$[rsp]
  00286	83 e8 02	 sub	 eax, 2
  00289	48 98		 cdqe
  0028b	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG169805
  00292	48 8b 8c 24 70
	01 00 00	 mov	 rcx, QWORD PTR argv$[rsp]
  0029a	48 8b 0c c1	 mov	 rcx, QWORD PTR [rcx+rax*8]
  0029e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__stricmp
  002a4	85 c0		 test	 eax, eax
  002a6	0f 85 11 01 00
	00		 jne	 $LN7@CTCE_Init

; 1987 :         {
; 1988 :             attndelay = argv[argc_updated - 1];

  002ac	8b 44 24 68	 mov	 eax, DWORD PTR argc_updated$[rsp]
  002b0	ff c8		 dec	 eax
  002b2	48 98		 cdqe
  002b4	48 8b 8c 24 70
	01 00 00	 mov	 rcx, QWORD PTR argv$[rsp]
  002bc	48 8b 04 c1	 mov	 rax, QWORD PTR [rcx+rax*8]
  002c0	48 89 84 24 d8
	00 00 00	 mov	 QWORD PTR attndelay$[rsp], rax

; 1989 :             if ( strlen( attndelay ) > 3 ||

  002c8	48 8b 8c 24 d8
	00 00 00	 mov	 rcx, QWORD PTR attndelay$[rsp]
  002d0	e8 00 00 00 00	 call	 strlen
  002d5	48 83 f8 03	 cmp	 rax, 3
  002d9	77 33		 ja	 SHORT $LN9@CTCE_Init
  002db	48 8b 84 24 60
	01 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  002e3	48 05 6c 07 00
	00		 add	 rax, 1900		; 0000076cH
  002e9	4c 8d 4c 24 64	 lea	 r9, QWORD PTR c$[rsp]
  002ee	4c 8b c0	 mov	 r8, rax
  002f1	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG169808
  002f8	48 8b 8c 24 d8
	00 00 00	 mov	 rcx, QWORD PTR attndelay$[rsp]
  00300	e8 00 00 00 00	 call	 sscanf
  00305	83 f8 01	 cmp	 eax, 1
  00308	0f 84 a4 00 00
	00		 je	 $LN8@CTCE_Init
$LN9@CTCE_Init:

; 1990 :                 sscanf( attndelay, "%u%c", &dev->ctce_attn_delay, &c ) != 1 )
; 1991 :             {
; 1992 :                 dev->ctce_attn_delay = 0;        // Defaults to 0

  0030e	48 8b 84 24 60
	01 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00316	c7 80 6c 07 00
	00 00 00 00 00	 mov	 DWORD PTR [rax+1900], 0

; 1993 :                 WRMSG( HHC05085, "W",  // CTCE: Invalid ATTNDELAY value %s ignored"

  00320	48 8b 84 24 60
	01 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00328	0f b7 40 48	 movzx	 eax, WORD PTR [rax+72]
  0032c	89 84 24 d4 00
	00 00		 mov	 DWORD PTR tv194[rsp], eax
  00333	48 8b 8c 24 60
	01 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  0033b	0f b7 49 44	 movzx	 ecx, WORD PTR [rcx+68]
  0033f	d1 f9		 sar	 ecx, 1
  00341	89 8c 24 84 00
	00 00		 mov	 DWORD PTR tv198[rsp], ecx
  00348	b9 01 00 00 00	 mov	 ecx, 1
  0034d	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  00353	48 8b 8c 24 d8
	00 00 00	 mov	 rcx, QWORD PTR attndelay$[rsp]
  0035b	48 89 4c 24 48	 mov	 QWORD PTR [rsp+72], rcx
  00360	8b 8c 24 d4 00
	00 00		 mov	 ecx, DWORD PTR tv194[rsp]
  00367	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  0036b	8b 8c 24 84 00
	00 00		 mov	 ecx, DWORD PTR tv198[rsp]
  00372	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  00376	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169809
  0037d	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  00382	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169810
  00389	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  0038e	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00393	41 b9 03 00 00
	00		 mov	 r9d, 3
  00399	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG169811
  003a0	ba ca 07 00 00	 mov	 edx, 1994		; 000007caH
  003a5	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169812
  003ac	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg
$LN8@CTCE_Init:

; 1994 :                     CTCX_DEVNUM( dev ), attndelay );
; 1995 :             }
; 1996 :             argc_updated -= 2;

  003b2	8b 44 24 68	 mov	 eax, DWORD PTR argc_updated$[rsp]
  003b6	83 e8 02	 sub	 eax, 2
  003b9	89 44 24 68	 mov	 DWORD PTR argc_updated$[rsp], eax
$LN7@CTCE_Init:
$LN6@CTCE_Init:

; 1997 :         }
; 1998 :     }
; 1999 :     dev->ctce_attn_delay *= 1000;                // msec -> micro seconds

  003bd	48 8b 84 24 60
	01 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  003c5	69 80 6c 07 00
	00 e8 03 00 00	 imul	 eax, DWORD PTR [rax+1900], 1000 ; 000003e8H
  003cf	48 8b 8c 24 60
	01 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  003d7	89 81 6c 07 00
	00		 mov	 DWORD PTR [rcx+1900], eax

; 2000 : 
; 2001 :     // At least the remote CTCE IP address needs to be specified.
; 2002 :     if ( argc_updated < 1 )

  003dd	83 7c 24 68 01	 cmp	 DWORD PTR argc_updated$[rsp], 1
  003e2	0f 8d 8f 00 00
	00		 jge	 $LN10@CTCE_Init

; 2003 :     {
; 2004 :         WRMSG( HHC05055, "E",  // CTCE: Missing (at least) remote CTCE IP address parameter"

  003e8	48 8b 84 24 60
	01 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  003f0	0f b7 40 48	 movzx	 eax, WORD PTR [rax+72]
  003f4	89 84 24 88 00
	00 00		 mov	 DWORD PTR tv215[rsp], eax
  003fb	48 8b 8c 24 60
	01 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  00403	0f b7 49 44	 movzx	 ecx, WORD PTR [rcx+68]
  00407	d1 f9		 sar	 ecx, 1
  00409	89 8c 24 8c 00
	00 00		 mov	 DWORD PTR tv219[rsp], ecx
  00410	b9 01 00 00 00	 mov	 ecx, 1
  00415	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  0041b	8b 8c 24 88 00
	00 00		 mov	 ecx, DWORD PTR tv215[rsp]
  00422	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  00426	8b 8c 24 8c 00
	00 00		 mov	 ecx, DWORD PTR tv219[rsp]
  0042d	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  00431	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169814
  00438	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  0043d	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169815
  00444	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00449	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  0044e	41 b9 03 00 00
	00		 mov	 r9d, 3
  00454	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG169816
  0045b	ba d5 07 00 00	 mov	 edx, 2005		; 000007d5H
  00460	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169817
  00467	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 2005 :             CTCX_DEVNUM( dev ) );
; 2006 :         return -1;

  0046d	b8 ff ff ff ff	 mov	 eax, -1
  00472	e9 9a 09 00 00	 jmp	 $LN1@CTCE_Init
$LN10@CTCE_Init:

; 2007 :     }
; 2008 : 
; 2009 :     // The first argument is the listening port number, which is now optional.
; 2010 :     listenp = argv[next_arg];

  00477	48 63 44 24 60	 movsxd	 rax, DWORD PTR next_arg$[rsp]
  0047c	48 8b 8c 24 70
	01 00 00	 mov	 rcx, QWORD PTR argv$[rsp]
  00484	48 8b 04 c1	 mov	 rax, QWORD PTR [rcx+rax*8]
  00488	48 89 84 24 e0
	00 00 00	 mov	 QWORD PTR listenp$[rsp], rax

; 2011 :     if ( strlen( listenp ) > 5 ||

  00490	48 8b 8c 24 e0
	00 00 00	 mov	 rcx, QWORD PTR listenp$[rsp]
  00498	e8 00 00 00 00	 call	 strlen
  0049d	48 83 f8 05	 cmp	 rax, 5
  004a1	77 2f		 ja	 SHORT $LN13@CTCE_Init
  004a3	48 8b 84 24 60
	01 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  004ab	48 05 50 07 00
	00		 add	 rax, 1872		; 00000750H
  004b1	4c 8d 4c 24 64	 lea	 r9, QWORD PTR c$[rsp]
  004b6	4c 8b c0	 mov	 r8, rax
  004b9	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG169821
  004c0	48 8b 8c 24 e0
	00 00 00	 mov	 rcx, QWORD PTR listenp$[rsp]
  004c8	e8 00 00 00 00	 call	 sscanf
  004cd	83 f8 01	 cmp	 eax, 1
  004d0	74 17		 je	 SHORT $LN11@CTCE_Init
$LN13@CTCE_Init:

; 2012 :         sscanf( listenp, "%u%c", &dev->ctce_lport, &c ) != 1 )
; 2013 :     {
; 2014 :         dev->ctce_lport = CTCE_DEFAULT_LISTEN_PORT;

  004d2	48 8b 84 24 60
	01 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  004da	c7 80 50 07 00
	00 10 0c 00 00	 mov	 DWORD PTR [rax+1872], 3088 ; 00000c10H

; 2015 :     }

  004e4	e9 d2 00 00 00	 jmp	 $LN12@CTCE_Init
$LN11@CTCE_Init:

; 2016 :     else
; 2017 :     {
; 2018 :         next_arg++;

  004e9	8b 44 24 60	 mov	 eax, DWORD PTR next_arg$[rsp]
  004ed	ff c0		 inc	 eax
  004ef	89 44 24 60	 mov	 DWORD PTR next_arg$[rsp], eax

; 2019 :         if (dev->ctce_lport < 1024 || dev->ctce_lport > 65534 )

  004f3	48 8b 84 24 60
	01 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  004fb	81 b8 50 07 00
	00 00 04 00 00	 cmp	 DWORD PTR [rax+1872], 1024 ; 00000400H
  00505	7c 18		 jl	 SHORT $LN15@CTCE_Init
  00507	48 8b 84 24 60
	01 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  0050f	81 b8 50 07 00
	00 fe ff 00 00	 cmp	 DWORD PTR [rax+1872], 65534 ; 0000fffeH
  00519	0f 8e 9c 00 00
	00		 jle	 $LN14@CTCE_Init
$LN15@CTCE_Init:

; 2020 :         {
; 2021 :             WRMSG( HHC05056, "E",  // CTCE: Local port number outside range 1024-65534: %s"

  0051f	48 8b 84 24 60
	01 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00527	0f b7 40 48	 movzx	 eax, WORD PTR [rax+72]
  0052b	89 84 24 90 00
	00 00		 mov	 DWORD PTR tv251[rsp], eax
  00532	48 8b 8c 24 60
	01 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  0053a	0f b7 49 44	 movzx	 ecx, WORD PTR [rcx+68]
  0053e	d1 f9		 sar	 ecx, 1
  00540	89 8c 24 94 00
	00 00		 mov	 DWORD PTR tv255[rsp], ecx
  00547	b9 01 00 00 00	 mov	 ecx, 1
  0054c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  00552	48 8b 8c 24 e0
	00 00 00	 mov	 rcx, QWORD PTR listenp$[rsp]
  0055a	48 89 4c 24 48	 mov	 QWORD PTR [rsp+72], rcx
  0055f	8b 8c 24 90 00
	00 00		 mov	 ecx, DWORD PTR tv251[rsp]
  00566	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  0056a	8b 8c 24 94 00
	00 00		 mov	 ecx, DWORD PTR tv255[rsp]
  00571	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  00575	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169824
  0057c	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  00581	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169825
  00588	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  0058d	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00592	41 b9 03 00 00
	00		 mov	 r9d, 3
  00598	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG169826
  0059f	ba e6 07 00 00	 mov	 edx, 2022		; 000007e6H
  005a4	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169827
  005ab	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 2022 :                 CTCX_DEVNUM( dev ), listenp );
; 2023 :             return -1;

  005b1	b8 ff ff ff ff	 mov	 eax, -1
  005b6	e9 56 08 00 00	 jmp	 $LN1@CTCE_Init
$LN14@CTCE_Init:
$LN12@CTCE_Init:

; 2024 :         }
; 2025 :     }
; 2026 : 
; 2027 :     // The next argument is the IP address or hostname of the
; 2028 :     // remote side of the point-to-point link
; 2029 :     remaddr = argv[next_arg++];

  005bb	48 63 44 24 60	 movsxd	 rax, DWORD PTR next_arg$[rsp]
  005c0	48 8b 8c 24 70
	01 00 00	 mov	 rcx, QWORD PTR argv$[rsp]
  005c8	48 8b 04 c1	 mov	 rax, QWORD PTR [rcx+rax*8]
  005cc	48 89 44 24 78	 mov	 QWORD PTR remaddr$[rsp], rax
  005d1	8b 44 24 60	 mov	 eax, DWORD PTR next_arg$[rsp]
  005d5	ff c0		 inc	 eax
  005d7	89 44 24 60	 mov	 DWORD PTR next_arg$[rsp], eax

; 2030 : 
; 2031 :     // The remote IP address can be optionally preceeded by the
; 2032 :     // CCUU address of the CTCE at the remote side followed by an
; 2033 :     // equal sign without intervening blanks, e.g. 0C40=192.168.1.230
; 2034 :     if ( ( equal_sign = strchr( remaddr, '=' ) ) )

  005db	ba 3d 00 00 00	 mov	 edx, 61			; 0000003dH
  005e0	48 8b 4c 24 78	 mov	 rcx, QWORD PTR remaddr$[rsp]
  005e5	e8 00 00 00 00	 call	 strchr
  005ea	48 89 84 24 e8
	00 00 00	 mov	 QWORD PTR equal_sign$[rsp], rax
  005f2	48 83 bc 24 e8
	00 00 00 00	 cmp	 QWORD PTR equal_sign$[rsp], 0
  005fb	0f 84 79 01 00
	00		 je	 $LN16@CTCE_Init

; 2035 :     {
; 2036 :         dev->ctce_rccuu = strtoul( remaddr, &equal_sign, 16 );

  00601	41 b8 10 00 00
	00		 mov	 r8d, 16
  00607	48 8d 94 24 e8
	00 00 00	 lea	 rdx, QWORD PTR equal_sign$[rsp]
  0060f	48 8b 4c 24 78	 mov	 rcx, QWORD PTR remaddr$[rsp]
  00614	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_strtoul
  0061a	48 8b 8c 24 60
	01 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  00622	66 89 81 64 07
	00 00		 mov	 WORD PTR [rcx+1892], ax

; 2037 :         if ( dev->ctce_rccuu > 255 )

  00629	48 8b 84 24 60
	01 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00631	0f b7 80 64 07
	00 00		 movzx	 eax, WORD PTR [rax+1892]
  00638	3d ff 00 00 00	 cmp	 eax, 255		; 000000ffH
  0063d	0f 8e f9 00 00
	00		 jle	 $LN18@CTCE_Init

; 2038 :         {
; 2039 :             if ( dev->ctce_rccuu > 65534 )

  00643	48 8b 84 24 60
	01 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  0064b	0f b7 80 64 07
	00 00		 movzx	 eax, WORD PTR [rax+1892]
  00652	3d fe ff 00 00	 cmp	 eax, 65534		; 0000fffeH
  00657	0f 8e b0 00 00
	00		 jle	 $LN20@CTCE_Init

; 2040 :             {
; 2041 :                 WRMSG( HHC05057, "E",  // CTCE: Remote CCUU address outside range 0001-FFFF: %4X"

  0065d	48 8b 84 24 60
	01 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00665	0f b7 80 64 07
	00 00		 movzx	 eax, WORD PTR [rax+1892]
  0066c	89 84 24 98 00
	00 00		 mov	 DWORD PTR tv287[rsp], eax
  00673	48 8b 8c 24 60
	01 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  0067b	0f b7 49 48	 movzx	 ecx, WORD PTR [rcx+72]
  0067f	89 8c 24 9c 00
	00 00		 mov	 DWORD PTR tv290[rsp], ecx
  00686	48 8b 94 24 60
	01 00 00	 mov	 rdx, QWORD PTR dev$[rsp]
  0068e	0f b7 52 44	 movzx	 edx, WORD PTR [rdx+68]
  00692	d1 fa		 sar	 edx, 1
  00694	89 94 24 a0 00
	00 00		 mov	 DWORD PTR tv294[rsp], edx
  0069b	b9 01 00 00 00	 mov	 ecx, 1
  006a0	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  006a6	8b 8c 24 98 00
	00 00		 mov	 ecx, DWORD PTR tv287[rsp]
  006ad	89 4c 24 48	 mov	 DWORD PTR [rsp+72], ecx
  006b1	8b 8c 24 9c 00
	00 00		 mov	 ecx, DWORD PTR tv290[rsp]
  006b8	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  006bc	8b 8c 24 a0 00
	00 00		 mov	 ecx, DWORD PTR tv294[rsp]
  006c3	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  006c7	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169833
  006ce	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  006d3	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169834
  006da	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  006df	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  006e4	41 b9 03 00 00
	00		 mov	 r9d, 3
  006ea	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG169835
  006f1	ba fa 07 00 00	 mov	 edx, 2042		; 000007faH
  006f6	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169836
  006fd	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 2042 :                     CTCX_DEVNUM( dev ), dev->ctce_rccuu );
; 2043 :                 return -1;

  00703	b8 ff ff ff ff	 mov	 eax, -1
  00708	e9 04 07 00 00	 jmp	 $LN1@CTCE_Init
$LN20@CTCE_Init:

; 2044 :             }
; 2045 :             dev->ctce_rccuu += dev->numconfdev - 1;

  0070d	48 8b 84 24 60
	01 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00715	8b 40 78	 mov	 eax, DWORD PTR [rax+120]
  00718	48 8b 8c 24 60
	01 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  00720	0f b7 89 64 07
	00 00		 movzx	 ecx, WORD PTR [rcx+1892]
  00727	8d 44 01 ff	 lea	 eax, DWORD PTR [rcx+rax-1]
  0072b	48 8b 8c 24 60
	01 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  00733	66 89 81 64 07
	00 00		 mov	 WORD PTR [rcx+1892], ax

; 2046 :         }

  0073a	eb 2c		 jmp	 SHORT $LN19@CTCE_Init
$LN18@CTCE_Init:

; 2047 : 
; 2048 :         // Remote CCUU addresses < 256 are not supported, but such values
; 2049 :         // are used to compute the actual remote CCUU address from the
; 2050 :         // local CCUU address by flipping certain bits in it.  The special
; 2051 :         // interesting values are 0, 1, 3, 5 and 9.  0 yields remote equal
; 2052 :         // local.  1 flips the least signigicant bit so that local / remote
; 2053 :         // are always odd / even (or vice versa), as do values 3, 5, and 9,
; 2054 :         // except that another bit in the least significant hex digit is
; 2055 :         // flipped as well.  This may be useful when defining multiple
; 2056 :         // CTCE devices, e.g. : 0C40.16 CTCE 9=192.168.100.10
; 2057 :         else
; 2058 :         {
; 2059 :             dev->ctce_rccuu = dev->devnum ^ dev->ctce_rccuu;

  0073c	48 8b 84 24 60
	01 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00744	0f b7 40 48	 movzx	 eax, WORD PTR [rax+72]
  00748	48 8b 8c 24 60
	01 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  00750	0f b7 89 64 07
	00 00		 movzx	 ecx, WORD PTR [rcx+1892]
  00757	33 c1		 xor	 eax, ecx
  00759	48 8b 8c 24 60
	01 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  00761	66 89 81 64 07
	00 00		 mov	 WORD PTR [rcx+1892], ax
$LN19@CTCE_Init:

; 2060 :         }
; 2061 : 
; 2062 :         remaddr = equal_sign + 1;

  00768	48 8b 84 24 e8
	00 00 00	 mov	 rax, QWORD PTR equal_sign$[rsp]
  00770	48 ff c0	 inc	 rax
  00773	48 89 44 24 78	 mov	 QWORD PTR remaddr$[rsp], rax

; 2063 :     }

  00778	eb 11		 jmp	 SHORT $LN17@CTCE_Init
$LN16@CTCE_Init:

; 2064 :     else
; 2065 :     {
; 2066 :         dev->ctce_rccuu = 0;

  0077a	33 c0		 xor	 eax, eax
  0077c	48 8b 8c 24 60
	01 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  00784	66 89 81 64 07
	00 00		 mov	 WORD PTR [rcx+1892], ax
$LN17@CTCE_Init:

; 2067 :     }
; 2068 : 
; 2069 :     if ( !inet_aton( remaddr, &dev->ctce_ipaddr ) )

  0078b	48 8b 84 24 60
	01 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00793	48 05 5c 07 00
	00		 add	 rax, 1884		; 0000075cH
  00799	48 8b d0	 mov	 rdx, rax
  0079c	48 8b 4c 24 78	 mov	 rcx, QWORD PTR remaddr$[rsp]
  007a1	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_inet_aton
  007a7	85 c0		 test	 eax, eax
  007a9	0f 85 27 01 00
	00		 jne	 $LN21@CTCE_Init

; 2070 :     {
; 2071 :         struct hostent *hp;
; 2072 : 
; 2073 :         if ( ( hp = gethostbyname( remaddr ) ) != NULL )

  007af	48 8b 4c 24 78	 mov	 rcx, QWORD PTR remaddr$[rsp]
  007b4	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_gethostbyname
  007ba	48 89 84 24 f0
	00 00 00	 mov	 QWORD PTR hp$1[rsp], rax
  007c2	48 83 bc 24 f0
	00 00 00 00	 cmp	 QWORD PTR hp$1[rsp], 0
  007cb	74 70		 je	 SHORT $LN22@CTCE_Init

; 2074 :         {
; 2075 :             memcpy( &dev->ctce_ipaddr, hp->h_addr, hp->h_length );

  007cd	48 8b 84 24 f0
	00 00 00	 mov	 rax, QWORD PTR hp$1[rsp]
  007d5	48 0f bf 40 12	 movsx	 rax, WORD PTR [rax+18]
  007da	b9 08 00 00 00	 mov	 ecx, 8
  007df	48 6b c9 00	 imul	 rcx, rcx, 0
  007e3	48 8b 94 24 f0
	00 00 00	 mov	 rdx, QWORD PTR hp$1[rsp]
  007eb	48 8b 52 18	 mov	 rdx, QWORD PTR [rdx+24]
  007ef	48 8b bc 24 60
	01 00 00	 mov	 rdi, QWORD PTR dev$[rsp]
  007f7	48 81 c7 5c 07
	00 00		 add	 rdi, 1884		; 0000075cH
  007fe	48 8b 34 0a	 mov	 rsi, QWORD PTR [rdx+rcx]
  00802	48 8b c8	 mov	 rcx, rax
  00805	f3 a4		 rep movsb

; 2076 :             strcpy( address, inet_ntoa( dev->ctce_ipaddr ) );

  00807	48 8b 84 24 60
	01 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  0080f	8b 88 5c 07 00
	00		 mov	 ecx, DWORD PTR [rax+1884]
  00815	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_inet_ntoa
  0081b	48 8b d0	 mov	 rdx, rax
  0081e	48 8d 8c 24 18
	01 00 00	 lea	 rcx, QWORD PTR address$[rsp]
  00826	e8 00 00 00 00	 call	 strcpy

; 2077 :             remaddr = address;

  0082b	48 8d 84 24 18
	01 00 00	 lea	 rax, QWORD PTR address$[rsp]
  00833	48 89 44 24 78	 mov	 QWORD PTR remaddr$[rsp], rax

; 2078 :         }

  00838	e9 99 00 00 00	 jmp	 $LN23@CTCE_Init
$LN22@CTCE_Init:

; 2079 :         else
; 2080 :         {
; 2081 :             WRMSG( HHC05058, "E",  // CTCE: Invalid IP address %s

  0083d	48 8b 84 24 60
	01 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00845	0f b7 40 48	 movzx	 eax, WORD PTR [rax+72]
  00849	89 84 24 a4 00
	00 00		 mov	 DWORD PTR tv347[rsp], eax
  00850	48 8b 8c 24 60
	01 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  00858	0f b7 49 44	 movzx	 ecx, WORD PTR [rcx+68]
  0085c	d1 f9		 sar	 ecx, 1
  0085e	89 8c 24 a8 00
	00 00		 mov	 DWORD PTR tv351[rsp], ecx
  00865	b9 01 00 00 00	 mov	 ecx, 1
  0086a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  00870	48 8b 4c 24 78	 mov	 rcx, QWORD PTR remaddr$[rsp]
  00875	48 89 4c 24 48	 mov	 QWORD PTR [rsp+72], rcx
  0087a	8b 8c 24 a4 00
	00 00		 mov	 ecx, DWORD PTR tv347[rsp]
  00881	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  00885	8b 8c 24 a8 00
	00 00		 mov	 ecx, DWORD PTR tv351[rsp]
  0088c	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  00890	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169840
  00897	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  0089c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169841
  008a3	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  008a8	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  008ad	41 b9 03 00 00
	00		 mov	 r9d, 3
  008b3	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG169842
  008ba	ba 22 08 00 00	 mov	 edx, 2082		; 00000822H
  008bf	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169843
  008c6	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 2082 :                 CTCX_DEVNUM( dev ), remaddr );
; 2083 :             return -1;

  008cc	b8 ff ff ff ff	 mov	 eax, -1
  008d1	e9 3b 05 00 00	 jmp	 $LN1@CTCE_Init
$LN23@CTCE_Init:
$LN21@CTCE_Init:

; 2084 :         }
; 2085 :     }
; 2086 : 
; 2087 :     // The next argument is the remote destination port number.
; 2088 :     if ( next_arg < argc_updated )

  008d6	8b 44 24 68	 mov	 eax, DWORD PTR argc_updated$[rsp]
  008da	39 44 24 60	 cmp	 DWORD PTR next_arg$[rsp], eax
  008de	0f 8d 32 01 00
	00		 jge	 $LN24@CTCE_Init

; 2089 :     {
; 2090 :         remotep = argv[next_arg++];

  008e4	48 63 44 24 60	 movsxd	 rax, DWORD PTR next_arg$[rsp]
  008e9	48 8b 8c 24 70
	01 00 00	 mov	 rcx, QWORD PTR argv$[rsp]
  008f1	48 8b 04 c1	 mov	 rax, QWORD PTR [rcx+rax*8]
  008f5	48 89 84 24 f8
	00 00 00	 mov	 QWORD PTR remotep$[rsp], rax
  008fd	8b 44 24 60	 mov	 eax, DWORD PTR next_arg$[rsp]
  00901	ff c0		 inc	 eax
  00903	89 44 24 60	 mov	 DWORD PTR next_arg$[rsp], eax

; 2091 :         if ( strlen( remotep ) > 5 ||
; 2092 :             sscanf( remotep, "%u%c", &dev->ctce_rport, &c ) != 1 ||
; 2093 :             dev->ctce_rport < 1024 || dev->ctce_rport > 65534 )

  00907	48 8b 8c 24 f8
	00 00 00	 mov	 rcx, QWORD PTR remotep$[rsp]
  0090f	e8 00 00 00 00	 call	 strlen
  00914	48 83 f8 05	 cmp	 rax, 5
  00918	77 5b		 ja	 SHORT $LN27@CTCE_Init
  0091a	48 8b 84 24 60
	01 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00922	48 05 58 07 00
	00		 add	 rax, 1880		; 00000758H
  00928	4c 8d 4c 24 64	 lea	 r9, QWORD PTR c$[rsp]
  0092d	4c 8b c0	 mov	 r8, rax
  00930	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG169848
  00937	48 8b 8c 24 f8
	00 00 00	 mov	 rcx, QWORD PTR remotep$[rsp]
  0093f	e8 00 00 00 00	 call	 sscanf
  00944	83 f8 01	 cmp	 eax, 1
  00947	75 2c		 jne	 SHORT $LN27@CTCE_Init
  00949	48 8b 84 24 60
	01 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00951	81 b8 58 07 00
	00 00 04 00 00	 cmp	 DWORD PTR [rax+1880], 1024 ; 00000400H
  0095b	7c 18		 jl	 SHORT $LN27@CTCE_Init
  0095d	48 8b 84 24 60
	01 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00965	81 b8 58 07 00
	00 fe ff 00 00	 cmp	 DWORD PTR [rax+1880], 65534 ; 0000fffeH
  0096f	0f 8e 9c 00 00
	00		 jle	 $LN26@CTCE_Init
$LN27@CTCE_Init:

; 2094 :         {
; 2095 :             WRMSG( HHC05059, "E",  // CTCE: Invalid port number: %s"

  00975	48 8b 84 24 60
	01 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  0097d	0f b7 40 48	 movzx	 eax, WORD PTR [rax+72]
  00981	89 84 24 ac 00
	00 00		 mov	 DWORD PTR tv383[rsp], eax
  00988	48 8b 8c 24 60
	01 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  00990	0f b7 49 44	 movzx	 ecx, WORD PTR [rcx+68]
  00994	d1 f9		 sar	 ecx, 1
  00996	89 8c 24 b0 00
	00 00		 mov	 DWORD PTR tv387[rsp], ecx
  0099d	b9 01 00 00 00	 mov	 ecx, 1
  009a2	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  009a8	48 8b 8c 24 f8
	00 00 00	 mov	 rcx, QWORD PTR remotep$[rsp]
  009b0	48 89 4c 24 48	 mov	 QWORD PTR [rsp+72], rcx
  009b5	8b 8c 24 ac 00
	00 00		 mov	 ecx, DWORD PTR tv383[rsp]
  009bc	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  009c0	8b 8c 24 b0 00
	00 00		 mov	 ecx, DWORD PTR tv387[rsp]
  009c7	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  009cb	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169849
  009d2	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  009d7	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169850
  009de	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  009e3	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  009e8	41 b9 03 00 00
	00		 mov	 r9d, 3
  009ee	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG169851
  009f5	ba 30 08 00 00	 mov	 edx, 2096		; 00000830H
  009fa	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169852
  00a01	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 2096 :                 CTCX_DEVNUM( dev ), remotep );
; 2097 :             return -1;

  00a07	b8 ff ff ff ff	 mov	 eax, -1
  00a0c	e9 00 04 00 00	 jmp	 $LN1@CTCE_Init
$LN26@CTCE_Init:

; 2098 :         }
; 2099 :     }

  00a11	e9 ba 00 00 00	 jmp	 $LN25@CTCE_Init
$LN24@CTCE_Init:

; 2100 : 
; 2101 :     // Please note that the default for this optional parm is 3088,
; 2102 :     // but it is only optional in case the remote CCUU is specified.
; 2103 :     else
; 2104 :     {
; 2105 :         if ( dev->ctce_rccuu == 0 )

  00a16	48 8b 84 24 60
	01 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00a1e	0f b7 80 64 07
	00 00		 movzx	 eax, WORD PTR [rax+1892]
  00a25	85 c0		 test	 eax, eax
  00a27	0f 85 91 00 00
	00		 jne	 $LN28@CTCE_Init

; 2106 :         {
; 2107 :             WRMSG( HHC05060, "E",  // CTCE: Both remote listening port and remote CCUU are missing; at least one is required."

  00a2d	48 8b 84 24 60
	01 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00a35	0f b7 40 48	 movzx	 eax, WORD PTR [rax+72]
  00a39	89 84 24 b4 00
	00 00		 mov	 DWORD PTR tv402[rsp], eax
  00a40	48 8b 8c 24 60
	01 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  00a48	0f b7 49 44	 movzx	 ecx, WORD PTR [rcx+68]
  00a4c	d1 f9		 sar	 ecx, 1
  00a4e	89 8c 24 b8 00
	00 00		 mov	 DWORD PTR tv406[rsp], ecx
  00a55	b9 01 00 00 00	 mov	 ecx, 1
  00a5a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  00a60	8b 8c 24 b4 00
	00 00		 mov	 ecx, DWORD PTR tv402[rsp]
  00a67	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  00a6b	8b 8c 24 b8 00
	00 00		 mov	 ecx, DWORD PTR tv406[rsp]
  00a72	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  00a76	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169855
  00a7d	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  00a82	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169856
  00a89	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00a8e	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00a93	41 b9 03 00 00
	00		 mov	 r9d, 3
  00a99	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG169857
  00aa0	ba 3c 08 00 00	 mov	 edx, 2108		; 0000083cH
  00aa5	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169858
  00aac	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 2108 :                 CTCX_DEVNUM( dev ) );
; 2109 :             return -1;

  00ab2	b8 ff ff ff ff	 mov	 eax, -1
  00ab7	e9 55 03 00 00	 jmp	 $LN1@CTCE_Init

; 2110 :         }

  00abc	eb 12		 jmp	 SHORT $LN29@CTCE_Init
$LN28@CTCE_Init:

; 2111 :         else
; 2112 :         {
; 2113 :             dev->ctce_rport = CTCE_DEFAULT_RPORT;

  00abe	48 8b 84 24 60
	01 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00ac6	c7 80 58 07 00
	00 10 0c 00 00	 mov	 DWORD PTR [rax+1880], 3088 ; 00000c10H
$LN29@CTCE_Init:
$LN25@CTCE_Init:

; 2114 :         }
; 2115 :     }
; 2116 : 
; 2117 :     // Enhanced CTC default MTU bufsize is CTCE_MTU_MIN.
; 2118 :     if ( next_arg < argc_updated )

  00ad0	8b 44 24 68	 mov	 eax, DWORD PTR argc_updated$[rsp]
  00ad4	39 44 24 60	 cmp	 DWORD PTR next_arg$[rsp], eax
  00ad8	0f 8d 17 01 00
	00		 jge	 $LN30@CTCE_Init

; 2119 :     {
; 2120 :         mtusize = argv[next_arg++];

  00ade	48 63 44 24 60	 movsxd	 rax, DWORD PTR next_arg$[rsp]
  00ae3	48 8b 8c 24 70
	01 00 00	 mov	 rcx, QWORD PTR argv$[rsp]
  00aeb	48 8b 04 c1	 mov	 rax, QWORD PTR [rcx+rax*8]
  00aef	48 89 84 24 00
	01 00 00	 mov	 QWORD PTR mtusize$[rsp], rax
  00af7	8b 44 24 60	 mov	 eax, DWORD PTR next_arg$[rsp]
  00afb	ff c0		 inc	 eax
  00afd	89 44 24 60	 mov	 DWORD PTR next_arg$[rsp], eax

; 2121 :         // The next argument is the maximum transmission unit (MTU) size
; 2122 :         if ( strlen( mtusize ) > 5 ||
; 2123 :             sscanf( mtusize, "%u%c", &mtu, &c ) != 1 ||
; 2124 :             mtu < CTCE_MTU_MIN || mtu > 65536 )

  00b01	48 8b 8c 24 00
	01 00 00	 mov	 rcx, QWORD PTR mtusize$[rsp]
  00b09	e8 00 00 00 00	 call	 strlen
  00b0e	48 83 f8 05	 cmp	 rax, 5
  00b12	77 3b		 ja	 SHORT $LN33@CTCE_Init
  00b14	4c 8d 4c 24 64	 lea	 r9, QWORD PTR c$[rsp]
  00b19	4c 8d 44 24 6c	 lea	 r8, QWORD PTR mtu$[rsp]
  00b1e	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG169863
  00b25	48 8b 8c 24 00
	01 00 00	 mov	 rcx, QWORD PTR mtusize$[rsp]
  00b2d	e8 00 00 00 00	 call	 sscanf
  00b32	83 f8 01	 cmp	 eax, 1
  00b35	75 18		 jne	 SHORT $LN33@CTCE_Init
  00b37	81 7c 24 6c 58
	f4 00 00	 cmp	 DWORD PTR mtu$[rsp], 62552 ; 0000f458H
  00b3f	7c 0e		 jl	 SHORT $LN33@CTCE_Init
  00b41	81 7c 24 6c 00
	00 01 00	 cmp	 DWORD PTR mtu$[rsp], 65536 ; 00010000H
  00b49	0f 8e a4 00 00
	00		 jle	 $LN32@CTCE_Init
$LN33@CTCE_Init:

; 2125 :         {
; 2126 :             WRMSG( HHC05061, "E",  // CTCE: Invalid MTU size %s, allowed range is %d to 65536"

  00b4f	48 8b 84 24 60
	01 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00b57	0f b7 40 48	 movzx	 eax, WORD PTR [rax+72]
  00b5b	89 84 24 bc 00
	00 00		 mov	 DWORD PTR tv469[rsp], eax
  00b62	48 8b 8c 24 60
	01 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  00b6a	0f b7 49 44	 movzx	 ecx, WORD PTR [rcx+68]
  00b6e	d1 f9		 sar	 ecx, 1
  00b70	89 8c 24 c0 00
	00 00		 mov	 DWORD PTR tv473[rsp], ecx
  00b77	b9 01 00 00 00	 mov	 ecx, 1
  00b7c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  00b82	c7 44 24 50 58
	f4 00 00	 mov	 DWORD PTR [rsp+80], 62552 ; 0000f458H
  00b8a	48 8b 8c 24 00
	01 00 00	 mov	 rcx, QWORD PTR mtusize$[rsp]
  00b92	48 89 4c 24 48	 mov	 QWORD PTR [rsp+72], rcx
  00b97	8b 8c 24 bc 00
	00 00		 mov	 ecx, DWORD PTR tv469[rsp]
  00b9e	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  00ba2	8b 8c 24 c0 00
	00 00		 mov	 ecx, DWORD PTR tv473[rsp]
  00ba9	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  00bad	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169864
  00bb4	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  00bb9	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169865
  00bc0	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00bc5	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00bca	41 b9 03 00 00
	00		 mov	 r9d, 3
  00bd0	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG169866
  00bd7	ba 4f 08 00 00	 mov	 edx, 2127		; 0000084fH
  00bdc	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169867
  00be3	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 2127 :                 CTCX_DEVNUM( dev ), mtusize, CTCE_MTU_MIN );
; 2128 :             return -1;

  00be9	b8 ff ff ff ff	 mov	 eax, -1
  00bee	e9 1e 02 00 00	 jmp	 $LN1@CTCE_Init
$LN32@CTCE_Init:

; 2129 :         }
; 2130 :     }

  00bf3	eb 08		 jmp	 SHORT $LN31@CTCE_Init
$LN30@CTCE_Init:

; 2131 :     else
; 2132 :     {
; 2133 :         mtu = CTCE_MTU_MIN;

  00bf5	c7 44 24 6c 58
	f4 00 00	 mov	 DWORD PTR mtu$[rsp], 62552 ; 0000f458H
$LN31@CTCE_Init:

; 2134 :     }
; 2135 : 
; 2136 :     // Set the device buffer size equal to the MTU size times 2, as
; 2137 :     // 2 such buffers are needed in parallel to cater for receiving
; 2138 :     // WRITE commands data prior to matching them with READ commands.
; 2139 :     // (Please see CTCE_RecvThread and CTCE_Send for more details.)
; 2140 :     dev->bufsize = mtu * 2;

  00bfd	8b 44 24 6c	 mov	 eax, DWORD PTR mtu$[rsp]
  00c01	d1 e0		 shl	 eax, 1
  00c03	48 8b 8c 24 60
	01 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  00c0b	89 81 d8 01 00
	00		 mov	 DWORD PTR [rcx+472], eax

; 2141 : 
; 2142 :     // Enhanced CTC only supports an optional extra parameter,
; 2143 :     // the Small MTU size, which defaults to the minimum size
; 2144 :     // of the TCP/IP packets exchanged: CTCE_SOKPFX.
; 2145 :     ctceSmlBin = sizeof(CTCE_SOKPFX);

  00c11	c7 44 24 70 10
	00 00 00	 mov	 DWORD PTR ctceSmlBin$[rsp], 16

; 2146 :     if ( next_arg < argc_updated )

  00c19	8b 44 24 68	 mov	 eax, DWORD PTR argc_updated$[rsp]
  00c1d	39 44 24 60	 cmp	 DWORD PTR next_arg$[rsp], eax
  00c21	0f 8d 08 01 00
	00		 jge	 $LN34@CTCE_Init

; 2147 :     {
; 2148 :         ctceSmlChr = argv[next_arg++];

  00c27	48 63 44 24 60	 movsxd	 rax, DWORD PTR next_arg$[rsp]
  00c2c	48 8b 8c 24 70
	01 00 00	 mov	 rcx, QWORD PTR argv$[rsp]
  00c34	48 8b 04 c1	 mov	 rax, QWORD PTR [rcx+rax*8]
  00c38	48 89 84 24 08
	01 00 00	 mov	 QWORD PTR ctceSmlChr$[rsp], rax
  00c40	8b 44 24 60	 mov	 eax, DWORD PTR next_arg$[rsp]
  00c44	ff c0		 inc	 eax
  00c46	89 44 24 60	 mov	 DWORD PTR next_arg$[rsp], eax

; 2149 :         if ( strlen( ctceSmlChr ) > 5 ||
; 2150 :             sscanf( ctceSmlChr, "%u%c", &ctceSmlBin, &c ) != 1 ||
; 2151 :             ctceSmlBin < (int)sizeof(CTCE_SOKPFX) || ctceSmlBin > mtu )

  00c4a	48 8b 8c 24 08
	01 00 00	 mov	 rcx, QWORD PTR ctceSmlChr$[rsp]
  00c52	e8 00 00 00 00	 call	 strlen
  00c57	48 83 f8 05	 cmp	 rax, 5
  00c5b	77 38		 ja	 SHORT $LN36@CTCE_Init
  00c5d	4c 8d 4c 24 64	 lea	 r9, QWORD PTR c$[rsp]
  00c62	4c 8d 44 24 70	 lea	 r8, QWORD PTR ctceSmlBin$[rsp]
  00c67	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG169871
  00c6e	48 8b 8c 24 08
	01 00 00	 mov	 rcx, QWORD PTR ctceSmlChr$[rsp]
  00c76	e8 00 00 00 00	 call	 sscanf
  00c7b	83 f8 01	 cmp	 eax, 1
  00c7e	75 15		 jne	 SHORT $LN36@CTCE_Init
  00c80	83 7c 24 70 10	 cmp	 DWORD PTR ctceSmlBin$[rsp], 16
  00c85	7c 0e		 jl	 SHORT $LN36@CTCE_Init
  00c87	8b 44 24 6c	 mov	 eax, DWORD PTR mtu$[rsp]
  00c8b	39 44 24 70	 cmp	 DWORD PTR ctceSmlBin$[rsp], eax
  00c8f	0f 8e 9a 00 00
	00		 jle	 $LN35@CTCE_Init
$LN36@CTCE_Init:

; 2152 :         {
; 2153 :             ctceSmlBin = sizeof(CTCE_SOKPFX);

  00c95	c7 44 24 70 10
	00 00 00	 mov	 DWORD PTR ctceSmlBin$[rsp], 16

; 2154 :             WRMSG( HHC05062, "W",  // CTCE: Invalid Small MTU size %s ignored"

  00c9d	48 8b 84 24 60
	01 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00ca5	0f b7 40 48	 movzx	 eax, WORD PTR [rax+72]
  00ca9	89 84 24 c4 00
	00 00		 mov	 DWORD PTR tv504[rsp], eax
  00cb0	48 8b 8c 24 60
	01 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  00cb8	0f b7 49 44	 movzx	 ecx, WORD PTR [rcx+68]
  00cbc	d1 f9		 sar	 ecx, 1
  00cbe	89 8c 24 c8 00
	00 00		 mov	 DWORD PTR tv508[rsp], ecx
  00cc5	b9 01 00 00 00	 mov	 ecx, 1
  00cca	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  00cd0	48 8b 8c 24 08
	01 00 00	 mov	 rcx, QWORD PTR ctceSmlChr$[rsp]
  00cd8	48 89 4c 24 48	 mov	 QWORD PTR [rsp+72], rcx
  00cdd	8b 8c 24 c4 00
	00 00		 mov	 ecx, DWORD PTR tv504[rsp]
  00ce4	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  00ce8	8b 8c 24 c8 00
	00 00		 mov	 ecx, DWORD PTR tv508[rsp]
  00cef	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  00cf3	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169872
  00cfa	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  00cff	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169873
  00d06	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00d0b	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00d10	41 b9 03 00 00
	00		 mov	 r9d, 3
  00d16	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG169874
  00d1d	ba 6b 08 00 00	 mov	 edx, 2155		; 0000086bH
  00d22	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169875
  00d29	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg
$LN35@CTCE_Init:
$LN34@CTCE_Init:

; 2155 :                 CTCX_DEVNUM( dev ), ctceSmlChr );
; 2156 :         }
; 2157 :     }
; 2158 :     dev->ctceSndSml = ctceSmlBin;

  00d2f	48 8b 84 24 60
	01 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00d37	8b 4c 24 70	 mov	 ecx, DWORD PTR ctceSmlBin$[rsp]
  00d3b	89 88 30 07 00
	00		 mov	 DWORD PTR [rax+1840], ecx

; 2159 : 
; 2160 :     // Check if there are any extraneous parameters to ignore.
; 2161 :     if ( next_arg < argc_updated )

  00d41	8b 44 24 68	 mov	 eax, DWORD PTR argc_updated$[rsp]
  00d45	39 44 24 60	 cmp	 DWORD PTR next_arg$[rsp], eax
  00d49	0f 8d b5 00 00
	00		 jge	 $LN37@CTCE_Init

; 2162 :     {
; 2163 :         WRMSG( HHC05064, "W",  // CTCE: Extraneous parameters ignored : %s ..."

  00d4f	48 63 44 24 60	 movsxd	 rax, DWORD PTR next_arg$[rsp]
  00d54	48 8b 8c 24 70
	01 00 00	 mov	 rcx, QWORD PTR argv$[rsp]
  00d5c	48 8b 04 c1	 mov	 rax, QWORD PTR [rcx+rax*8]
  00d60	48 89 84 24 10
	01 00 00	 mov	 QWORD PTR tv525[rsp], rax
  00d68	48 8b 84 24 60
	01 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00d70	0f b7 40 48	 movzx	 eax, WORD PTR [rax+72]
  00d74	89 84 24 cc 00
	00 00		 mov	 DWORD PTR tv528[rsp], eax
  00d7b	48 8b 8c 24 60
	01 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  00d83	0f b7 49 44	 movzx	 ecx, WORD PTR [rcx+68]
  00d87	d1 f9		 sar	 ecx, 1
  00d89	89 8c 24 d0 00
	00 00		 mov	 DWORD PTR tv532[rsp], ecx
  00d90	b9 01 00 00 00	 mov	 ecx, 1
  00d95	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  00d9b	48 8b 8c 24 10
	01 00 00	 mov	 rcx, QWORD PTR tv525[rsp]
  00da3	48 89 4c 24 48	 mov	 QWORD PTR [rsp+72], rcx
  00da8	8b 8c 24 cc 00
	00 00		 mov	 ecx, DWORD PTR tv528[rsp]
  00daf	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  00db3	8b 8c 24 d0 00
	00 00		 mov	 ecx, DWORD PTR tv532[rsp]
  00dba	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  00dbe	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169877
  00dc5	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  00dca	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169878
  00dd1	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00dd6	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00ddb	41 b9 03 00 00
	00		 mov	 r9d, 3
  00de1	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG169879
  00de8	ba 74 08 00 00	 mov	 edx, 2164		; 00000874H
  00ded	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169880
  00df4	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg
  00dfa	8b 44 24 60	 mov	 eax, DWORD PTR next_arg$[rsp]
  00dfe	ff c0		 inc	 eax
  00e00	89 44 24 60	 mov	 DWORD PTR next_arg$[rsp], eax
$LN37@CTCE_Init:

; 2164 :             CTCX_DEVNUM( dev ), argv[next_arg++] );
; 2165 :     }
; 2166 : 
; 2167 :     // We're now ready to start the Listen and Connect threads to
; 2168 :     // asynchronously connect to the partner CTCE when present.
; 2169 :     return CTCE_Start_Listen_Connect_Threads( dev );

  00e04	48 8b 8c 24 60
	01 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  00e0c	e8 00 00 00 00	 call	 CTCE_Start_Listen_Connect_Threads
$LN1@CTCE_Init:

; 2170 : 
; 2171 : } // CTCE_Init

  00e11	48 8b 8c 24 30
	01 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  00e19	48 33 cc	 xor	 rcx, rsp
  00e1c	e8 00 00 00 00	 call	 __security_check_cookie
  00e21	48 81 c4 48 01
	00 00		 add	 rsp, 328		; 00000148H
  00e28	5f		 pop	 rdi
  00e29	5e		 pop	 rsi
  00e2a	c3		 ret	 0
CTCE_Init ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\ctcadpt.c
_TEXT	SEGMENT
iNum$ = 48
tv141 = 52
tv151 = 56
tv161 = 60
tv186 = 64
tv212 = 68
tv213 = 72
tv187 = 76
tv214 = 80
tv244 = 84
tv270 = 88
tv271 = 92
tv245 = 96
tv272 = 100
tv281 = 104
tv306 = 108
tv332 = 112
tv333 = 116
tv307 = 120
tv334 = 124
tv362 = 128
tv388 = 132
tv389 = 136
tv363 = 140
tv390 = 144
tv418 = 148
tv444 = 152
tv445 = 156
tv419 = 160
tv446 = 164
tv499 = 168
tv525 = 172
tv526 = 176
tv500 = 180
tv527 = 184
tv557 = 188
tv583 = 192
tv584 = 196
tv558 = 200
tv585 = 204
tv594 = 208
tv619 = 212
tv620 = 216
tv621 = 220
tv645 = 224
tv646 = 228
tv650 = 232
tv656 = 236
tv681 = 240
tv753 = 244
tv754 = 248
tv789 = 252
tv793 = 256
tv795 = 260
tv797 = 264
tv136 = 268
tv778 = 272
CTCE_Info$ = 280
__$ArrayPad$ = 312
pDEVBLK$ = 352
bCode$ = 360
bFlags$ = 368
bChained$ = 376
sCount$ = 384
bPrevCode$ = 392
iCCWSeq$ = 400
pIOBuf$ = 408
pMore$ = 416
pUnitStat$ = 424
pResidual$ = 432
CTCE_ExecuteCCW PROC

; 1702 : {

  00000	44 88 4c 24 20	 mov	 BYTE PTR [rsp+32], r9b
  00005	44 88 44 24 18	 mov	 BYTE PTR [rsp+24], r8b
  0000a	88 54 24 10	 mov	 BYTE PTR [rsp+16], dl
  0000e	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00013	56		 push	 rsi
  00014	57		 push	 rdi
  00015	48 81 ec 48 01
	00 00		 sub	 rsp, 328		; 00000148H
  0001c	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00023	48 33 c4	 xor	 rax, rsp
  00026	48 89 84 24 38
	01 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 1703 :     int             iNum;               // Number of bytes to move
; 1704 :     CTCE_INFO       CTCE_Info = { 0 };  // CTCE information (also for tracing)

  0002e	48 8d 84 24 18
	01 00 00	 lea	 rax, QWORD PTR CTCE_Info$[rsp]
  00036	48 8b f8	 mov	 rdi, rax
  00039	33 c0		 xor	 eax, eax
  0003b	b9 20 00 00 00	 mov	 ecx, 32			; 00000020H
  00040	f3 aa		 rep stosb
$LN4@CTCE_Execu:

; 1705 : 
; 1706 :     UNREFERENCED( bChained  );

  00042	33 c0		 xor	 eax, eax
  00044	85 c0		 test	 eax, eax
  00046	75 fa		 jne	 SHORT $LN4@CTCE_Execu
$LN7@CTCE_Execu:

; 1707 :     UNREFERENCED( bPrevCode );

  00048	33 c0		 xor	 eax, eax
  0004a	85 c0		 test	 eax, eax
  0004c	75 fa		 jne	 SHORT $LN7@CTCE_Execu
$LN10@CTCE_Execu:

; 1708 :     UNREFERENCED( iCCWSeq   );

  0004e	33 c0		 xor	 eax, eax
  00050	85 c0		 test	 eax, eax
  00052	75 fa		 jne	 SHORT $LN10@CTCE_Execu
$LN13@CTCE_Execu:

; 1709 :     UNREFERENCED( pMore     );

  00054	33 c0		 xor	 eax, eax
  00056	85 c0		 test	 eax, eax
  00058	75 fa		 jne	 SHORT $LN13@CTCE_Execu

; 1710 : 
; 1711 :     // Initialise our CTCE_Info previous x- and y-states.
; 1712 :     CTCE_Info.state_x_prev = pDEVBLK->ctcexState;

  0005a	48 8b 84 24 60
	01 00 00	 mov	 rax, QWORD PTR pDEVBLK$[rsp]
  00062	0f b6 80 34 07
	00 00		 movzx	 eax, BYTE PTR [rax+1844]
  00069	88 84 24 1c 01
	00 00		 mov	 BYTE PTR CTCE_Info$[rsp+4], al

; 1713 :     CTCE_Info.state_y_prev = pDEVBLK->ctceyState;

  00070	48 8b 84 24 60
	01 00 00	 mov	 rax, QWORD PTR pDEVBLK$[rsp]
  00078	0f b6 80 36 07
	00 00		 movzx	 eax, BYTE PTR [rax+1846]
  0007f	88 84 24 1d 01
	00 00		 mov	 BYTE PTR CTCE_Info$[rsp+5], al

; 1714 : 
; 1715 :     // Intervention required if the device file is not open
; 1716 :     if( ( pDEVBLK->fd < 0 ) || ( pDEVBLK->ctcefd < 0 ) )

  00086	48 8b 84 24 60
	01 00 00	 mov	 rax, QWORD PTR pDEVBLK$[rsp]
  0008e	83 b8 ac 01 00
	00 00		 cmp	 DWORD PTR [rax+428], 0
  00095	7c 15		 jl	 SHORT $LN17@CTCE_Execu
  00097	48 8b 84 24 60
	01 00 00	 mov	 rax, QWORD PTR pDEVBLK$[rsp]
  0009f	83 b8 3c 07 00
	00 00		 cmp	 DWORD PTR [rax+1852], 0
  000a6	0f 8d 35 01 00
	00		 jge	 $LN16@CTCE_Execu
$LN17@CTCE_Execu:

; 1717 :     {
; 1718 :         if( !IS_CCW_SENSE( bCode ) &&

  000ac	0f b6 84 24 68
	01 00 00	 movzx	 eax, BYTE PTR bCode$[rsp]
  000b4	83 e0 0f	 and	 eax, 15
  000b7	83 f8 04	 cmp	 eax, 4
  000ba	0f 84 21 01 00
	00		 je	 $LN18@CTCE_Execu
  000c0	0f b6 84 24 68
	01 00 00	 movzx	 eax, BYTE PTR bCode$[rsp]
  000c8	83 e0 03	 and	 eax, 3
  000cb	83 f8 03	 cmp	 eax, 3
  000ce	0f 84 0d 01 00
	00		 je	 $LN18@CTCE_Execu

; 1719 :             !IS_CCW_CONTROL( bCode ) )
; 1720 :         {
; 1721 :             pDEVBLK->sense[0] = SENSE_IR;

  000d4	b8 01 00 00 00	 mov	 eax, 1
  000d9	48 6b c0 00	 imul	 rax, rax, 0
  000dd	48 8b 8c 24 60
	01 00 00	 mov	 rcx, QWORD PTR pDEVBLK$[rsp]
  000e5	c6 84 01 64 03
	00 00 40	 mov	 BYTE PTR [rcx+rax+868], 64 ; 00000040H

; 1722 :             *pUnitStat = CSW_CE | CSW_DE | CSW_UC;

  000ed	48 8b 84 24 a8
	01 00 00	 mov	 rax, QWORD PTR pUnitStat$[rsp]
  000f5	c6 00 0e	 mov	 BYTE PTR [rax], 14

; 1723 : 
; 1724 :             // Produce a CTCE Trace logging if requested.
; 1725 :             CTCE_RESTART_CCWTRACE( pDEVBLK ) ;

  000f8	48 8b 84 24 60
	01 00 00	 mov	 rax, QWORD PTR pDEVBLK$[rsp]
  00100	83 b8 68 07 00
	00 00		 cmp	 DWORD PTR [rax+1896], 0
  00107	7c 14		 jl	 SHORT $LN45@CTCE_Execu
  00109	48 8b 84 24 60
	01 00 00	 mov	 rax, QWORD PTR pDEVBLK$[rsp]
  00111	c7 80 68 07 00
	00 14 00 00 00	 mov	 DWORD PTR [rax+1896], 20
  0011b	33 c0		 xor	 eax, eax
$LN45@CTCE_Execu:

; 1726 :             if( CTCE_CCWTRACE( pDEVBLK ) )

  0011d	48 8b 84 24 60
	01 00 00	 mov	 rax, QWORD PTR pDEVBLK$[rsp]
  00125	8b 80 f8 05 00
	00		 mov	 eax, DWORD PTR [rax+1528]
  0012b	c1 e8 0f	 shr	 eax, 15
  0012e	83 e0 01	 and	 eax, 1
  00131	85 c0		 test	 eax, eax
  00133	75 63		 jne	 SHORT $LN20@CTCE_Execu
  00135	48 8b 84 24 60
	01 00 00	 mov	 rax, QWORD PTR pDEVBLK$[rsp]
  0013d	83 b8 68 07 00
	00 ff		 cmp	 DWORD PTR [rax+1896], -1
  00144	74 52		 je	 SHORT $LN20@CTCE_Execu
  00146	48 8b 84 24 60
	01 00 00	 mov	 rax, QWORD PTR pDEVBLK$[rsp]
  0014e	83 b8 68 07 00
	00 00		 cmp	 DWORD PTR [rax+1896], 0
  00155	0f 8e 81 00 00
	00		 jle	 $LN19@CTCE_Execu
  0015b	48 8b 84 24 60
	01 00 00	 mov	 rax, QWORD PTR pDEVBLK$[rsp]
  00163	8b 80 68 07 00
	00		 mov	 eax, DWORD PTR [rax+1896]
  00169	89 84 24 0c 01
	00 00		 mov	 DWORD PTR tv136[rsp], eax
  00170	48 8b 84 24 60
	01 00 00	 mov	 rax, QWORD PTR pDEVBLK$[rsp]
  00178	8b 80 68 07 00
	00		 mov	 eax, DWORD PTR [rax+1896]
  0017e	ff c8		 dec	 eax
  00180	48 8b 8c 24 60
	01 00 00	 mov	 rcx, QWORD PTR pDEVBLK$[rsp]
  00188	89 81 68 07 00
	00		 mov	 DWORD PTR [rcx+1896], eax
  0018e	83 bc 24 0c 01
	00 00 00	 cmp	 DWORD PTR tv136[rsp], 0
  00196	74 44		 je	 SHORT $LN19@CTCE_Execu
$LN20@CTCE_Execu:

; 1727 :             {
; 1728 :                 CTCE_Trace( pDEVBLK, ( pDEVBLK->ctcefd < 0 ) ?

  00198	48 8b 84 24 60
	01 00 00	 mov	 rax, QWORD PTR pDEVBLK$[rsp]
  001a0	83 b8 3c 07 00
	00 00		 cmp	 DWORD PTR [rax+1852], 0
  001a7	7d 0a		 jge	 SHORT $LN46@CTCE_Execu
  001a9	c7 44 24 34 04
	00 00 00	 mov	 DWORD PTR tv141[rsp], 4
  001b1	eb 08		 jmp	 SHORT $LN47@CTCE_Execu
$LN46@CTCE_Execu:
  001b3	c7 44 24 34 03
	00 00 00	 mov	 DWORD PTR tv141[rsp], 3
$LN47@CTCE_Execu:
  001bb	4c 8b 8c 24 a8
	01 00 00	 mov	 r9, QWORD PTR pUnitStat$[rsp]
  001c3	4c 8d 84 24 18
	01 00 00	 lea	 r8, QWORD PTR CTCE_Info$[rsp]
  001cb	8b 54 24 34	 mov	 edx, DWORD PTR tv141[rsp]
  001cf	48 8b 8c 24 60
	01 00 00	 mov	 rcx, QWORD PTR pDEVBLK$[rsp]
  001d7	e8 00 00 00 00	 call	 CTCE_Trace
$LN19@CTCE_Execu:

; 1729 :                     CTCE_SND_NSR : CTCE_SND_NS,  &CTCE_Info, pUnitStat );
; 1730 :             }
; 1731 :             return;

  001dc	e9 a3 13 00 00	 jmp	 $LN1@CTCE_Execu
$LN18@CTCE_Execu:
$LN16@CTCE_Execu:

; 1732 :         }
; 1733 :     }
; 1734 : 
; 1735 :     // Changes to DEVBLK are lock protected as the CTCE_RecvThread
; 1736 :     // might update as well.
; 1737 :     obtain_lock( &pDEVBLK->lock );

  001e1	48 8b 84 24 60
	01 00 00	 mov	 rax, QWORD PTR pDEVBLK$[rsp]
  001e9	48 83 c0 38	 add	 rax, 56			; 00000038H
  001ed	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG169735
  001f4	48 8b c8	 mov	 rcx, rax
  001f7	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_obtain_lock

; 1738 : 
; 1739 :     // The CCW Flags Command Chaining indicator being set indicates
; 1740 :     // that a CCW Program is in progress.  The last CCW in the chain
; 1741 :     // has this flag turned off.
; 1742 :     pDEVBLK->ctce_ccw_flags_cc = ( ( bFlags & CCW_FLAGS_CC ) != 0 );

  001fd	0f b6 84 24 70
	01 00 00	 movzx	 eax, BYTE PTR bFlags$[rsp]
  00205	83 e0 40	 and	 eax, 64			; 00000040H
  00208	85 c0		 test	 eax, eax
  0020a	74 0a		 je	 SHORT $LN48@CTCE_Execu
  0020c	c7 44 24 38 01
	00 00 00	 mov	 DWORD PTR tv151[rsp], 1
  00214	eb 08		 jmp	 SHORT $LN49@CTCE_Execu
$LN48@CTCE_Execu:
  00216	c7 44 24 38 00
	00 00 00	 mov	 DWORD PTR tv151[rsp], 0
$LN49@CTCE_Execu:
  0021e	8b 44 24 38	 mov	 eax, DWORD PTR tv151[rsp]
  00222	83 e0 01	 and	 eax, 1
  00225	d1 e0		 shl	 eax, 1
  00227	48 8b 8c 24 60
	01 00 00	 mov	 rcx, QWORD PTR pDEVBLK$[rsp]
  0022f	8b 89 74 07 00
	00		 mov	 ecx, DWORD PTR [rcx+1908]
  00235	83 e1 fd	 and	 ecx, -3			; fffffffdH
  00238	0b c8		 or	 ecx, eax
  0023a	8b c1		 mov	 eax, ecx
  0023c	48 8b 8c 24 60
	01 00 00	 mov	 rcx, QWORD PTR pDEVBLK$[rsp]
  00244	89 81 74 07 00
	00		 mov	 DWORD PTR [rcx+1908], eax

; 1743 : 
; 1744 :     // Copy control command byte in x command register
; 1745 :     pDEVBLK->ctcexCmd = ( bCode == 0 ) ? bCode_invalid : bCode;

  0024a	0f b6 84 24 68
	01 00 00	 movzx	 eax, BYTE PTR bCode$[rsp]
  00252	85 c0		 test	 eax, eax
  00254	75 0a		 jne	 SHORT $LN50@CTCE_Execu
  00256	c7 44 24 3c 08
	00 00 00	 mov	 DWORD PTR tv161[rsp], 8
  0025e	eb 0c		 jmp	 SHORT $LN51@CTCE_Execu
$LN50@CTCE_Execu:
  00260	0f b6 84 24 68
	01 00 00	 movzx	 eax, BYTE PTR bCode$[rsp]
  00268	89 44 24 3c	 mov	 DWORD PTR tv161[rsp], eax
$LN51@CTCE_Execu:
  0026c	48 8b 84 24 60
	01 00 00	 mov	 rax, QWORD PTR pDEVBLK$[rsp]
  00274	0f b6 4c 24 3c	 movzx	 ecx, BYTE PTR tv161[rsp]
  00279	88 88 35 07 00
	00		 mov	 BYTE PTR [rax+1845], cl

; 1746 : 
; 1747 :     // The new X-state and transition actions are derived from the FSM table.
; 1748 : 
; 1749 :     CTCE_Info.state_new   = CTCE_NEW_X_STATE( pDEVBLK->ctcexCmd );

  0027f	48 8b 84 24 60
	01 00 00	 mov	 rax, QWORD PTR pDEVBLK$[rsp]
  00287	8b 80 18 07 00
	00		 mov	 eax, DWORD PTR [rax+1816]
  0028d	83 e0 01	 and	 eax, 1
  00290	85 c0		 test	 eax, eax
  00292	75 69		 jne	 SHORT $LN52@CTCE_Execu
  00294	48 8b 84 24 60
	01 00 00	 mov	 rax, QWORD PTR pDEVBLK$[rsp]
  0029c	8b 80 74 07 00
	00		 mov	 eax, DWORD PTR [rax+1908]
  002a2	c1 e8 03	 shr	 eax, 3
  002a5	83 e0 01	 and	 eax, 1
  002a8	85 c0		 test	 eax, eax
  002aa	75 51		 jne	 SHORT $LN52@CTCE_Execu
  002ac	48 8b 84 24 60
	01 00 00	 mov	 rax, QWORD PTR pDEVBLK$[rsp]
  002b4	0f b6 80 35 07
	00 00		 movzx	 eax, BYTE PTR [rax+1845]
  002bb	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:CTCE_command
  002c2	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  002c6	83 f8 07	 cmp	 eax, 7
  002c9	75 0a		 jne	 SHORT $LN53@CTCE_Execu
  002cb	c7 44 24 40 03
	00 00 00	 mov	 DWORD PTR tv186[rsp], 3
  002d3	eb 1e		 jmp	 SHORT $LN54@CTCE_Execu
$LN53@CTCE_Execu:
  002d5	48 8b 84 24 60
	01 00 00	 mov	 rax, QWORD PTR pDEVBLK$[rsp]
  002dd	0f b6 80 35 07
	00 00		 movzx	 eax, BYTE PTR [rax+1845]
  002e4	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:CTCE_command
  002eb	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  002ef	89 44 24 40	 mov	 DWORD PTR tv186[rsp], eax
$LN54@CTCE_Execu:
  002f3	8b 44 24 40	 mov	 eax, DWORD PTR tv186[rsp]
  002f7	89 44 24 4c	 mov	 DWORD PTR tv187[rsp], eax
  002fb	eb 1e		 jmp	 SHORT $LN55@CTCE_Execu
$LN52@CTCE_Execu:
  002fd	48 8b 84 24 60
	01 00 00	 mov	 rax, QWORD PTR pDEVBLK$[rsp]
  00305	0f b6 80 35 07
	00 00		 movzx	 eax, BYTE PTR [rax+1845]
  0030c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:CTCE_command
  00313	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00317	89 44 24 4c	 mov	 DWORD PTR tv187[rsp], eax
$LN55@CTCE_Execu:
  0031b	48 8b 84 24 60
	01 00 00	 mov	 rax, QWORD PTR pDEVBLK$[rsp]
  00323	0f b6 80 34 07
	00 00		 movzx	 eax, BYTE PTR [rax+1844]
  0032a	83 e0 04	 and	 eax, 4
  0032d	85 c0		 test	 eax, eax
  0032f	75 0d		 jne	 SHORT $LN60@CTCE_Execu
  00331	c7 44 24 50 06
	00 00 00	 mov	 DWORD PTR tv214[rsp], 6
  00339	e9 8c 00 00 00	 jmp	 $LN61@CTCE_Execu
$LN60@CTCE_Execu:
  0033e	48 8b 84 24 60
	01 00 00	 mov	 rax, QWORD PTR pDEVBLK$[rsp]
  00346	8b 80 18 07 00
	00		 mov	 eax, DWORD PTR [rax+1816]
  0034c	83 e0 01	 and	 eax, 1
  0034f	85 c0		 test	 eax, eax
  00351	75 59		 jne	 SHORT $LN56@CTCE_Execu
  00353	48 8b 84 24 60
	01 00 00	 mov	 rax, QWORD PTR pDEVBLK$[rsp]
  0035b	8b 80 74 07 00
	00		 mov	 eax, DWORD PTR [rax+1908]
  00361	c1 e8 03	 shr	 eax, 3
  00364	83 e0 01	 and	 eax, 1
  00367	85 c0		 test	 eax, eax
  00369	75 41		 jne	 SHORT $LN56@CTCE_Execu
  0036b	48 8b 84 24 60
	01 00 00	 mov	 rax, QWORD PTR pDEVBLK$[rsp]
  00373	0f b6 80 36 07
	00 00		 movzx	 eax, BYTE PTR [rax+1846]
  0037a	83 e0 07	 and	 eax, 7
  0037d	83 f8 05	 cmp	 eax, 5
  00380	75 0a		 jne	 SHORT $LN57@CTCE_Execu
  00382	c7 44 24 44 04
	00 00 00	 mov	 DWORD PTR tv212[rsp], 4
  0038a	eb 16		 jmp	 SHORT $LN58@CTCE_Execu
$LN57@CTCE_Execu:
  0038c	48 8b 84 24 60
	01 00 00	 mov	 rax, QWORD PTR pDEVBLK$[rsp]
  00394	0f b6 80 36 07
	00 00		 movzx	 eax, BYTE PTR [rax+1846]
  0039b	83 e0 07	 and	 eax, 7
  0039e	89 44 24 44	 mov	 DWORD PTR tv212[rsp], eax
$LN58@CTCE_Execu:
  003a2	8b 44 24 44	 mov	 eax, DWORD PTR tv212[rsp]
  003a6	89 44 24 48	 mov	 DWORD PTR tv213[rsp], eax
  003aa	eb 16		 jmp	 SHORT $LN59@CTCE_Execu
$LN56@CTCE_Execu:
  003ac	48 8b 84 24 60
	01 00 00	 mov	 rax, QWORD PTR pDEVBLK$[rsp]
  003b4	0f b6 80 36 07
	00 00		 movzx	 eax, BYTE PTR [rax+1846]
  003bb	83 e0 07	 and	 eax, 7
  003be	89 44 24 48	 mov	 DWORD PTR tv213[rsp], eax
$LN59@CTCE_Execu:
  003c2	8b 44 24 48	 mov	 eax, DWORD PTR tv213[rsp]
  003c6	89 44 24 50	 mov	 DWORD PTR tv214[rsp], eax
$LN61@CTCE_Execu:
  003ca	48 63 44 24 4c	 movsxd	 rax, DWORD PTR tv187[rsp]
  003cf	48 6b c0 20	 imul	 rax, rax, 32		; 00000020H
  003d3	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:CTCE_Fsm
  003da	48 03 c8	 add	 rcx, rax
  003dd	48 8b c1	 mov	 rax, rcx
  003e0	48 63 4c 24 50	 movsxd	 rcx, DWORD PTR tv214[rsp]
  003e5	0f b6 04 88	 movzx	 eax, BYTE PTR [rax+rcx*4]
  003e9	3d ff 00 00 00	 cmp	 eax, 255		; 000000ffH
  003ee	0f 84 70 01 00
	00		 je	 $LN72@CTCE_Execu
  003f4	48 8b 84 24 60
	01 00 00	 mov	 rax, QWORD PTR pDEVBLK$[rsp]
  003fc	8b 80 18 07 00
	00		 mov	 eax, DWORD PTR [rax+1816]
  00402	83 e0 01	 and	 eax, 1
  00405	85 c0		 test	 eax, eax
  00407	75 69		 jne	 SHORT $LN62@CTCE_Execu
  00409	48 8b 84 24 60
	01 00 00	 mov	 rax, QWORD PTR pDEVBLK$[rsp]
  00411	8b 80 74 07 00
	00		 mov	 eax, DWORD PTR [rax+1908]
  00417	c1 e8 03	 shr	 eax, 3
  0041a	83 e0 01	 and	 eax, 1
  0041d	85 c0		 test	 eax, eax
  0041f	75 51		 jne	 SHORT $LN62@CTCE_Execu
  00421	48 8b 84 24 60
	01 00 00	 mov	 rax, QWORD PTR pDEVBLK$[rsp]
  00429	0f b6 80 35 07
	00 00		 movzx	 eax, BYTE PTR [rax+1845]
  00430	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:CTCE_command
  00437	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  0043b	83 f8 07	 cmp	 eax, 7
  0043e	75 0a		 jne	 SHORT $LN63@CTCE_Execu
  00440	c7 44 24 54 03
	00 00 00	 mov	 DWORD PTR tv244[rsp], 3
  00448	eb 1e		 jmp	 SHORT $LN64@CTCE_Execu
$LN63@CTCE_Execu:
  0044a	48 8b 84 24 60
	01 00 00	 mov	 rax, QWORD PTR pDEVBLK$[rsp]
  00452	0f b6 80 35 07
	00 00		 movzx	 eax, BYTE PTR [rax+1845]
  00459	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:CTCE_command
  00460	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00464	89 44 24 54	 mov	 DWORD PTR tv244[rsp], eax
$LN64@CTCE_Execu:
  00468	8b 44 24 54	 mov	 eax, DWORD PTR tv244[rsp]
  0046c	89 44 24 60	 mov	 DWORD PTR tv245[rsp], eax
  00470	eb 1e		 jmp	 SHORT $LN65@CTCE_Execu
$LN62@CTCE_Execu:
  00472	48 8b 84 24 60
	01 00 00	 mov	 rax, QWORD PTR pDEVBLK$[rsp]
  0047a	0f b6 80 35 07
	00 00		 movzx	 eax, BYTE PTR [rax+1845]
  00481	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:CTCE_command
  00488	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  0048c	89 44 24 60	 mov	 DWORD PTR tv245[rsp], eax
$LN65@CTCE_Execu:
  00490	48 8b 84 24 60
	01 00 00	 mov	 rax, QWORD PTR pDEVBLK$[rsp]
  00498	0f b6 80 34 07
	00 00		 movzx	 eax, BYTE PTR [rax+1844]
  0049f	83 e0 04	 and	 eax, 4
  004a2	85 c0		 test	 eax, eax
  004a4	75 0d		 jne	 SHORT $LN70@CTCE_Execu
  004a6	c7 44 24 64 06
	00 00 00	 mov	 DWORD PTR tv272[rsp], 6
  004ae	e9 8c 00 00 00	 jmp	 $LN71@CTCE_Execu
$LN70@CTCE_Execu:
  004b3	48 8b 84 24 60
	01 00 00	 mov	 rax, QWORD PTR pDEVBLK$[rsp]
  004bb	8b 80 18 07 00
	00		 mov	 eax, DWORD PTR [rax+1816]
  004c1	83 e0 01	 and	 eax, 1
  004c4	85 c0		 test	 eax, eax
  004c6	75 59		 jne	 SHORT $LN66@CTCE_Execu
  004c8	48 8b 84 24 60
	01 00 00	 mov	 rax, QWORD PTR pDEVBLK$[rsp]
  004d0	8b 80 74 07 00
	00		 mov	 eax, DWORD PTR [rax+1908]
  004d6	c1 e8 03	 shr	 eax, 3
  004d9	83 e0 01	 and	 eax, 1
  004dc	85 c0		 test	 eax, eax
  004de	75 41		 jne	 SHORT $LN66@CTCE_Execu
  004e0	48 8b 84 24 60
	01 00 00	 mov	 rax, QWORD PTR pDEVBLK$[rsp]
  004e8	0f b6 80 36 07
	00 00		 movzx	 eax, BYTE PTR [rax+1846]
  004ef	83 e0 07	 and	 eax, 7
  004f2	83 f8 05	 cmp	 eax, 5
  004f5	75 0a		 jne	 SHORT $LN67@CTCE_Execu
  004f7	c7 44 24 58 04
	00 00 00	 mov	 DWORD PTR tv270[rsp], 4
  004ff	eb 16		 jmp	 SHORT $LN68@CTCE_Execu
$LN67@CTCE_Execu:
  00501	48 8b 84 24 60
	01 00 00	 mov	 rax, QWORD PTR pDEVBLK$[rsp]
  00509	0f b6 80 36 07
	00 00		 movzx	 eax, BYTE PTR [rax+1846]
  00510	83 e0 07	 and	 eax, 7
  00513	89 44 24 58	 mov	 DWORD PTR tv270[rsp], eax
$LN68@CTCE_Execu:
  00517	8b 44 24 58	 mov	 eax, DWORD PTR tv270[rsp]
  0051b	89 44 24 5c	 mov	 DWORD PTR tv271[rsp], eax
  0051f	eb 16		 jmp	 SHORT $LN69@CTCE_Execu
$LN66@CTCE_Execu:
  00521	48 8b 84 24 60
	01 00 00	 mov	 rax, QWORD PTR pDEVBLK$[rsp]
  00529	0f b6 80 36 07
	00 00		 movzx	 eax, BYTE PTR [rax+1846]
  00530	83 e0 07	 and	 eax, 7
  00533	89 44 24 5c	 mov	 DWORD PTR tv271[rsp], eax
$LN69@CTCE_Execu:
  00537	8b 44 24 5c	 mov	 eax, DWORD PTR tv271[rsp]
  0053b	89 44 24 64	 mov	 DWORD PTR tv272[rsp], eax
$LN71@CTCE_Execu:
  0053f	48 63 44 24 60	 movsxd	 rax, DWORD PTR tv245[rsp]
  00544	48 6b c0 20	 imul	 rax, rax, 32		; 00000020H
  00548	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:CTCE_Fsm
  0054f	48 03 c8	 add	 rcx, rax
  00552	48 8b c1	 mov	 rax, rcx
  00555	48 63 4c 24 64	 movsxd	 rcx, DWORD PTR tv272[rsp]
  0055a	0f b6 04 88	 movzx	 eax, BYTE PTR [rax+rcx*4]
  0055e	89 44 24 68	 mov	 DWORD PTR tv281[rsp], eax
  00562	eb 16		 jmp	 SHORT $LN73@CTCE_Execu
$LN72@CTCE_Execu:
  00564	48 8b 84 24 60
	01 00 00	 mov	 rax, QWORD PTR pDEVBLK$[rsp]
  0056c	0f b6 80 34 07
	00 00		 movzx	 eax, BYTE PTR [rax+1844]
  00573	83 e0 07	 and	 eax, 7
  00576	89 44 24 68	 mov	 DWORD PTR tv281[rsp], eax
$LN73@CTCE_Execu:
  0057a	0f b6 44 24 68	 movzx	 eax, BYTE PTR tv281[rsp]
  0057f	88 84 24 1f 01
	00 00		 mov	 BYTE PTR CTCE_Info$[rsp+7], al

; 1750 :     CTCE_Info.actions     = CTCE_Fsm[CTCE_CMD( pDEVBLK->ctcexCmd )][CTCE_X_STATE_FSM_IDX].actions;

  00586	48 8b 84 24 60
	01 00 00	 mov	 rax, QWORD PTR pDEVBLK$[rsp]
  0058e	8b 80 18 07 00
	00		 mov	 eax, DWORD PTR [rax+1816]
  00594	83 e0 01	 and	 eax, 1
  00597	85 c0		 test	 eax, eax
  00599	75 69		 jne	 SHORT $LN74@CTCE_Execu
  0059b	48 8b 84 24 60
	01 00 00	 mov	 rax, QWORD PTR pDEVBLK$[rsp]
  005a3	8b 80 74 07 00
	00		 mov	 eax, DWORD PTR [rax+1908]
  005a9	c1 e8 03	 shr	 eax, 3
  005ac	83 e0 01	 and	 eax, 1
  005af	85 c0		 test	 eax, eax
  005b1	75 51		 jne	 SHORT $LN74@CTCE_Execu
  005b3	48 8b 84 24 60
	01 00 00	 mov	 rax, QWORD PTR pDEVBLK$[rsp]
  005bb	0f b6 80 35 07
	00 00		 movzx	 eax, BYTE PTR [rax+1845]
  005c2	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:CTCE_command
  005c9	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  005cd	83 f8 07	 cmp	 eax, 7
  005d0	75 0a		 jne	 SHORT $LN75@CTCE_Execu
  005d2	c7 44 24 6c 03
	00 00 00	 mov	 DWORD PTR tv306[rsp], 3
  005da	eb 1e		 jmp	 SHORT $LN76@CTCE_Execu
$LN75@CTCE_Execu:
  005dc	48 8b 84 24 60
	01 00 00	 mov	 rax, QWORD PTR pDEVBLK$[rsp]
  005e4	0f b6 80 35 07
	00 00		 movzx	 eax, BYTE PTR [rax+1845]
  005eb	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:CTCE_command
  005f2	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  005f6	89 44 24 6c	 mov	 DWORD PTR tv306[rsp], eax
$LN76@CTCE_Execu:
  005fa	8b 44 24 6c	 mov	 eax, DWORD PTR tv306[rsp]
  005fe	89 44 24 78	 mov	 DWORD PTR tv307[rsp], eax
  00602	eb 1e		 jmp	 SHORT $LN77@CTCE_Execu
$LN74@CTCE_Execu:
  00604	48 8b 84 24 60
	01 00 00	 mov	 rax, QWORD PTR pDEVBLK$[rsp]
  0060c	0f b6 80 35 07
	00 00		 movzx	 eax, BYTE PTR [rax+1845]
  00613	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:CTCE_command
  0061a	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  0061e	89 44 24 78	 mov	 DWORD PTR tv307[rsp], eax
$LN77@CTCE_Execu:
  00622	48 8b 84 24 60
	01 00 00	 mov	 rax, QWORD PTR pDEVBLK$[rsp]
  0062a	0f b6 80 34 07
	00 00		 movzx	 eax, BYTE PTR [rax+1844]
  00631	83 e0 04	 and	 eax, 4
  00634	85 c0		 test	 eax, eax
  00636	75 0d		 jne	 SHORT $LN82@CTCE_Execu
  00638	c7 44 24 7c 06
	00 00 00	 mov	 DWORD PTR tv334[rsp], 6
  00640	e9 8c 00 00 00	 jmp	 $LN83@CTCE_Execu
$LN82@CTCE_Execu:
  00645	48 8b 84 24 60
	01 00 00	 mov	 rax, QWORD PTR pDEVBLK$[rsp]
  0064d	8b 80 18 07 00
	00		 mov	 eax, DWORD PTR [rax+1816]
  00653	83 e0 01	 and	 eax, 1
  00656	85 c0		 test	 eax, eax
  00658	75 59		 jne	 SHORT $LN78@CTCE_Execu
  0065a	48 8b 84 24 60
	01 00 00	 mov	 rax, QWORD PTR pDEVBLK$[rsp]
  00662	8b 80 74 07 00
	00		 mov	 eax, DWORD PTR [rax+1908]
  00668	c1 e8 03	 shr	 eax, 3
  0066b	83 e0 01	 and	 eax, 1
  0066e	85 c0		 test	 eax, eax
  00670	75 41		 jne	 SHORT $LN78@CTCE_Execu
  00672	48 8b 84 24 60
	01 00 00	 mov	 rax, QWORD PTR pDEVBLK$[rsp]
  0067a	0f b6 80 36 07
	00 00		 movzx	 eax, BYTE PTR [rax+1846]
  00681	83 e0 07	 and	 eax, 7
  00684	83 f8 05	 cmp	 eax, 5
  00687	75 0a		 jne	 SHORT $LN79@CTCE_Execu
  00689	c7 44 24 70 04
	00 00 00	 mov	 DWORD PTR tv332[rsp], 4
  00691	eb 16		 jmp	 SHORT $LN80@CTCE_Execu
$LN79@CTCE_Execu:
  00693	48 8b 84 24 60
	01 00 00	 mov	 rax, QWORD PTR pDEVBLK$[rsp]
  0069b	0f b6 80 36 07
	00 00		 movzx	 eax, BYTE PTR [rax+1846]
  006a2	83 e0 07	 and	 eax, 7
  006a5	89 44 24 70	 mov	 DWORD PTR tv332[rsp], eax
$LN80@CTCE_Execu:
  006a9	8b 44 24 70	 mov	 eax, DWORD PTR tv332[rsp]
  006ad	89 44 24 74	 mov	 DWORD PTR tv333[rsp], eax
  006b1	eb 16		 jmp	 SHORT $LN81@CTCE_Execu
$LN78@CTCE_Execu:
  006b3	48 8b 84 24 60
	01 00 00	 mov	 rax, QWORD PTR pDEVBLK$[rsp]
  006bb	0f b6 80 36 07
	00 00		 movzx	 eax, BYTE PTR [rax+1846]
  006c2	83 e0 07	 and	 eax, 7
  006c5	89 44 24 74	 mov	 DWORD PTR tv333[rsp], eax
$LN81@CTCE_Execu:
  006c9	8b 44 24 74	 mov	 eax, DWORD PTR tv333[rsp]
  006cd	89 44 24 7c	 mov	 DWORD PTR tv334[rsp], eax
$LN83@CTCE_Execu:
  006d1	48 63 44 24 78	 movsxd	 rax, DWORD PTR tv307[rsp]
  006d6	48 6b c0 20	 imul	 rax, rax, 32		; 00000020H
  006da	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:CTCE_Fsm
  006e1	48 03 c8	 add	 rcx, rax
  006e4	48 8b c1	 mov	 rax, rcx
  006e7	48 63 4c 24 7c	 movsxd	 rcx, DWORD PTR tv334[rsp]
  006ec	0f b6 44 88 03	 movzx	 eax, BYTE PTR [rax+rcx*4+3]
  006f1	88 84 24 1e 01
	00 00		 mov	 BYTE PTR CTCE_Info$[rsp+6], al

; 1751 :     CTCE_Info.x_unit_stat = CTCE_Fsm[CTCE_CMD( pDEVBLK->ctcexCmd )][CTCE_X_STATE_FSM_IDX].x_unit_stat;

  006f8	48 8b 84 24 60
	01 00 00	 mov	 rax, QWORD PTR pDEVBLK$[rsp]
  00700	8b 80 18 07 00
	00		 mov	 eax, DWORD PTR [rax+1816]
  00706	83 e0 01	 and	 eax, 1
  00709	85 c0		 test	 eax, eax
  0070b	75 75		 jne	 SHORT $LN84@CTCE_Execu
  0070d	48 8b 84 24 60
	01 00 00	 mov	 rax, QWORD PTR pDEVBLK$[rsp]
  00715	8b 80 74 07 00
	00		 mov	 eax, DWORD PTR [rax+1908]
  0071b	c1 e8 03	 shr	 eax, 3
  0071e	83 e0 01	 and	 eax, 1
  00721	85 c0		 test	 eax, eax
  00723	75 5d		 jne	 SHORT $LN84@CTCE_Execu
  00725	48 8b 84 24 60
	01 00 00	 mov	 rax, QWORD PTR pDEVBLK$[rsp]
  0072d	0f b6 80 35 07
	00 00		 movzx	 eax, BYTE PTR [rax+1845]
  00734	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:CTCE_command
  0073b	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  0073f	83 f8 07	 cmp	 eax, 7
  00742	75 0d		 jne	 SHORT $LN85@CTCE_Execu
  00744	c7 84 24 80 00
	00 00 03 00 00
	00		 mov	 DWORD PTR tv362[rsp], 3
  0074f	eb 21		 jmp	 SHORT $LN86@CTCE_Execu
$LN85@CTCE_Execu:
  00751	48 8b 84 24 60
	01 00 00	 mov	 rax, QWORD PTR pDEVBLK$[rsp]
  00759	0f b6 80 35 07
	00 00		 movzx	 eax, BYTE PTR [rax+1845]
  00760	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:CTCE_command
  00767	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  0076b	89 84 24 80 00
	00 00		 mov	 DWORD PTR tv362[rsp], eax
$LN86@CTCE_Execu:
  00772	8b 84 24 80 00
	00 00		 mov	 eax, DWORD PTR tv362[rsp]
  00779	89 84 24 8c 00
	00 00		 mov	 DWORD PTR tv363[rsp], eax
  00780	eb 21		 jmp	 SHORT $LN87@CTCE_Execu
$LN84@CTCE_Execu:
  00782	48 8b 84 24 60
	01 00 00	 mov	 rax, QWORD PTR pDEVBLK$[rsp]
  0078a	0f b6 80 35 07
	00 00		 movzx	 eax, BYTE PTR [rax+1845]
  00791	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:CTCE_command
  00798	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  0079c	89 84 24 8c 00
	00 00		 mov	 DWORD PTR tv363[rsp], eax
$LN87@CTCE_Execu:
  007a3	48 8b 84 24 60
	01 00 00	 mov	 rax, QWORD PTR pDEVBLK$[rsp]
  007ab	0f b6 80 34 07
	00 00		 movzx	 eax, BYTE PTR [rax+1844]
  007b2	83 e0 04	 and	 eax, 4
  007b5	85 c0		 test	 eax, eax
  007b7	75 10		 jne	 SHORT $LN92@CTCE_Execu
  007b9	c7 84 24 90 00
	00 00 06 00 00
	00		 mov	 DWORD PTR tv390[rsp], 6
  007c4	e9 a1 00 00 00	 jmp	 $LN93@CTCE_Execu
$LN92@CTCE_Execu:
  007c9	48 8b 84 24 60
	01 00 00	 mov	 rax, QWORD PTR pDEVBLK$[rsp]
  007d1	8b 80 18 07 00
	00		 mov	 eax, DWORD PTR [rax+1816]
  007d7	83 e0 01	 and	 eax, 1
  007da	85 c0		 test	 eax, eax
  007dc	75 65		 jne	 SHORT $LN88@CTCE_Execu
  007de	48 8b 84 24 60
	01 00 00	 mov	 rax, QWORD PTR pDEVBLK$[rsp]
  007e6	8b 80 74 07 00
	00		 mov	 eax, DWORD PTR [rax+1908]
  007ec	c1 e8 03	 shr	 eax, 3
  007ef	83 e0 01	 and	 eax, 1
  007f2	85 c0		 test	 eax, eax
  007f4	75 4d		 jne	 SHORT $LN88@CTCE_Execu
  007f6	48 8b 84 24 60
	01 00 00	 mov	 rax, QWORD PTR pDEVBLK$[rsp]
  007fe	0f b6 80 36 07
	00 00		 movzx	 eax, BYTE PTR [rax+1846]
  00805	83 e0 07	 and	 eax, 7
  00808	83 f8 05	 cmp	 eax, 5
  0080b	75 0d		 jne	 SHORT $LN89@CTCE_Execu
  0080d	c7 84 24 84 00
	00 00 04 00 00
	00		 mov	 DWORD PTR tv388[rsp], 4
  00818	eb 19		 jmp	 SHORT $LN90@CTCE_Execu
$LN89@CTCE_Execu:
  0081a	48 8b 84 24 60
	01 00 00	 mov	 rax, QWORD PTR pDEVBLK$[rsp]
  00822	0f b6 80 36 07
	00 00		 movzx	 eax, BYTE PTR [rax+1846]
  00829	83 e0 07	 and	 eax, 7
  0082c	89 84 24 84 00
	00 00		 mov	 DWORD PTR tv388[rsp], eax
$LN90@CTCE_Execu:
  00833	8b 84 24 84 00
	00 00		 mov	 eax, DWORD PTR tv388[rsp]
  0083a	89 84 24 88 00
	00 00		 mov	 DWORD PTR tv389[rsp], eax
  00841	eb 19		 jmp	 SHORT $LN91@CTCE_Execu
$LN88@CTCE_Execu:
  00843	48 8b 84 24 60
	01 00 00	 mov	 rax, QWORD PTR pDEVBLK$[rsp]
  0084b	0f b6 80 36 07
	00 00		 movzx	 eax, BYTE PTR [rax+1846]
  00852	83 e0 07	 and	 eax, 7
  00855	89 84 24 88 00
	00 00		 mov	 DWORD PTR tv389[rsp], eax
$LN91@CTCE_Execu:
  0085c	8b 84 24 88 00
	00 00		 mov	 eax, DWORD PTR tv389[rsp]
  00863	89 84 24 90 00
	00 00		 mov	 DWORD PTR tv390[rsp], eax
$LN93@CTCE_Execu:
  0086a	48 63 84 24 8c
	00 00 00	 movsxd	 rax, DWORD PTR tv363[rsp]
  00872	48 6b c0 20	 imul	 rax, rax, 32		; 00000020H
  00876	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:CTCE_Fsm
  0087d	48 03 c8	 add	 rcx, rax
  00880	48 8b c1	 mov	 rax, rcx
  00883	48 63 8c 24 90
	00 00 00	 movsxd	 rcx, DWORD PTR tv390[rsp]
  0088b	0f b6 44 88 01	 movzx	 eax, BYTE PTR [rax+rcx*4+1]
  00890	88 84 24 20 01
	00 00		 mov	 BYTE PTR CTCE_Info$[rsp+8], al

; 1752 : 
; 1753 :     *pUnitStat            = CTCE_Fsm[CTCE_CMD( pDEVBLK->ctcexCmd )][CTCE_X_STATE_FSM_IDX].x_unit_stat;

  00897	48 8b 84 24 60
	01 00 00	 mov	 rax, QWORD PTR pDEVBLK$[rsp]
  0089f	8b 80 18 07 00
	00		 mov	 eax, DWORD PTR [rax+1816]
  008a5	83 e0 01	 and	 eax, 1
  008a8	85 c0		 test	 eax, eax
  008aa	75 75		 jne	 SHORT $LN94@CTCE_Execu
  008ac	48 8b 84 24 60
	01 00 00	 mov	 rax, QWORD PTR pDEVBLK$[rsp]
  008b4	8b 80 74 07 00
	00		 mov	 eax, DWORD PTR [rax+1908]
  008ba	c1 e8 03	 shr	 eax, 3
  008bd	83 e0 01	 and	 eax, 1
  008c0	85 c0		 test	 eax, eax
  008c2	75 5d		 jne	 SHORT $LN94@CTCE_Execu
  008c4	48 8b 84 24 60
	01 00 00	 mov	 rax, QWORD PTR pDEVBLK$[rsp]
  008cc	0f b6 80 35 07
	00 00		 movzx	 eax, BYTE PTR [rax+1845]
  008d3	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:CTCE_command
  008da	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  008de	83 f8 07	 cmp	 eax, 7
  008e1	75 0d		 jne	 SHORT $LN95@CTCE_Execu
  008e3	c7 84 24 94 00
	00 00 03 00 00
	00		 mov	 DWORD PTR tv418[rsp], 3
  008ee	eb 21		 jmp	 SHORT $LN96@CTCE_Execu
$LN95@CTCE_Execu:
  008f0	48 8b 84 24 60
	01 00 00	 mov	 rax, QWORD PTR pDEVBLK$[rsp]
  008f8	0f b6 80 35 07
	00 00		 movzx	 eax, BYTE PTR [rax+1845]
  008ff	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:CTCE_command
  00906	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  0090a	89 84 24 94 00
	00 00		 mov	 DWORD PTR tv418[rsp], eax
$LN96@CTCE_Execu:
  00911	8b 84 24 94 00
	00 00		 mov	 eax, DWORD PTR tv418[rsp]
  00918	89 84 24 a0 00
	00 00		 mov	 DWORD PTR tv419[rsp], eax
  0091f	eb 21		 jmp	 SHORT $LN97@CTCE_Execu
$LN94@CTCE_Execu:
  00921	48 8b 84 24 60
	01 00 00	 mov	 rax, QWORD PTR pDEVBLK$[rsp]
  00929	0f b6 80 35 07
	00 00		 movzx	 eax, BYTE PTR [rax+1845]
  00930	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:CTCE_command
  00937	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  0093b	89 84 24 a0 00
	00 00		 mov	 DWORD PTR tv419[rsp], eax
$LN97@CTCE_Execu:
  00942	48 8b 84 24 60
	01 00 00	 mov	 rax, QWORD PTR pDEVBLK$[rsp]
  0094a	0f b6 80 34 07
	00 00		 movzx	 eax, BYTE PTR [rax+1844]
  00951	83 e0 04	 and	 eax, 4
  00954	85 c0		 test	 eax, eax
  00956	75 10		 jne	 SHORT $LN102@CTCE_Execu
  00958	c7 84 24 a4 00
	00 00 06 00 00
	00		 mov	 DWORD PTR tv446[rsp], 6
  00963	e9 a1 00 00 00	 jmp	 $LN103@CTCE_Execu
$LN102@CTCE_Execu:
  00968	48 8b 84 24 60
	01 00 00	 mov	 rax, QWORD PTR pDEVBLK$[rsp]
  00970	8b 80 18 07 00
	00		 mov	 eax, DWORD PTR [rax+1816]
  00976	83 e0 01	 and	 eax, 1
  00979	85 c0		 test	 eax, eax
  0097b	75 65		 jne	 SHORT $LN98@CTCE_Execu
  0097d	48 8b 84 24 60
	01 00 00	 mov	 rax, QWORD PTR pDEVBLK$[rsp]
  00985	8b 80 74 07 00
	00		 mov	 eax, DWORD PTR [rax+1908]
  0098b	c1 e8 03	 shr	 eax, 3
  0098e	83 e0 01	 and	 eax, 1
  00991	85 c0		 test	 eax, eax
  00993	75 4d		 jne	 SHORT $LN98@CTCE_Execu
  00995	48 8b 84 24 60
	01 00 00	 mov	 rax, QWORD PTR pDEVBLK$[rsp]
  0099d	0f b6 80 36 07
	00 00		 movzx	 eax, BYTE PTR [rax+1846]
  009a4	83 e0 07	 and	 eax, 7
  009a7	83 f8 05	 cmp	 eax, 5
  009aa	75 0d		 jne	 SHORT $LN99@CTCE_Execu
  009ac	c7 84 24 98 00
	00 00 04 00 00
	00		 mov	 DWORD PTR tv444[rsp], 4
  009b7	eb 19		 jmp	 SHORT $LN100@CTCE_Execu
$LN99@CTCE_Execu:
  009b9	48 8b 84 24 60
	01 00 00	 mov	 rax, QWORD PTR pDEVBLK$[rsp]
  009c1	0f b6 80 36 07
	00 00		 movzx	 eax, BYTE PTR [rax+1846]
  009c8	83 e0 07	 and	 eax, 7
  009cb	89 84 24 98 00
	00 00		 mov	 DWORD PTR tv444[rsp], eax
$LN100@CTCE_Execu:
  009d2	8b 84 24 98 00
	00 00		 mov	 eax, DWORD PTR tv444[rsp]
  009d9	89 84 24 9c 00
	00 00		 mov	 DWORD PTR tv445[rsp], eax
  009e0	eb 19		 jmp	 SHORT $LN101@CTCE_Execu
$LN98@CTCE_Execu:
  009e2	48 8b 84 24 60
	01 00 00	 mov	 rax, QWORD PTR pDEVBLK$[rsp]
  009ea	0f b6 80 36 07
	00 00		 movzx	 eax, BYTE PTR [rax+1846]
  009f1	83 e0 07	 and	 eax, 7
  009f4	89 84 24 9c 00
	00 00		 mov	 DWORD PTR tv445[rsp], eax
$LN101@CTCE_Execu:
  009fb	8b 84 24 9c 00
	00 00		 mov	 eax, DWORD PTR tv445[rsp]
  00a02	89 84 24 a4 00
	00 00		 mov	 DWORD PTR tv446[rsp], eax
$LN103@CTCE_Execu:
  00a09	48 63 84 24 a0
	00 00 00	 movsxd	 rax, DWORD PTR tv419[rsp]
  00a11	48 6b c0 20	 imul	 rax, rax, 32		; 00000020H
  00a15	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:CTCE_Fsm
  00a1c	48 03 c8	 add	 rcx, rax
  00a1f	48 8b c1	 mov	 rax, rcx
  00a22	48 63 8c 24 a4
	00 00 00	 movsxd	 rcx, DWORD PTR tv446[rsp]
  00a2a	48 8b 94 24 a8
	01 00 00	 mov	 rdx, QWORD PTR pUnitStat$[rsp]
  00a32	0f b6 44 88 01	 movzx	 eax, BYTE PTR [rax+rcx*4+1]
  00a37	88 02		 mov	 BYTE PTR [rdx], al

; 1754 : 
; 1755 :     // If a READ or READ_BACKWARD command is received whilst the WEOF
; 1756 :     // bit is set then the sole case for a Unit Exception applies.
; 1757 :     if( IS_CTCE_WEOF( pDEVBLK->ctcexState ) &&

  00a39	48 8b 84 24 60
	01 00 00	 mov	 rax, QWORD PTR pDEVBLK$[rsp]
  00a41	0f b6 80 34 07
	00 00		 movzx	 eax, BYTE PTR [rax+1844]
  00a48	25 80 00 00 00	 and	 eax, 128		; 00000080H
  00a4d	3d 80 00 00 00	 cmp	 eax, 128		; 00000080H
  00a52	75 63		 jne	 SHORT $LN21@CTCE_Execu
  00a54	48 8b 84 24 60
	01 00 00	 mov	 rax, QWORD PTR pDEVBLK$[rsp]
  00a5c	0f b6 80 35 07
	00 00		 movzx	 eax, BYTE PTR [rax+1845]
  00a63	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:CTCE_command
  00a6a	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00a6e	25 fb 00 00 00	 and	 eax, 251		; 000000fbH
  00a73	83 f8 02	 cmp	 eax, 2
  00a76	75 3f		 jne	 SHORT $LN21@CTCE_Execu

; 1758 :         IS_CTCE_CCW_RDA( pDEVBLK->ctcexCmd ) )
; 1759 :     {
; 1760 :         CLR_CTCE_WEOF( pDEVBLK->ctcexState );

  00a78	48 8b 84 24 60
	01 00 00	 mov	 rax, QWORD PTR pDEVBLK$[rsp]
  00a80	0f b6 80 34 07
	00 00		 movzx	 eax, BYTE PTR [rax+1844]
  00a87	0f ba f0 07	 btr	 eax, 7
  00a8b	48 8b 8c 24 60
	01 00 00	 mov	 rcx, QWORD PTR pDEVBLK$[rsp]
  00a93	88 81 34 07 00
	00		 mov	 BYTE PTR [rcx+1844], al

; 1761 :         *pResidual = 0;

  00a99	48 8b 84 24 b0
	01 00 00	 mov	 rax, QWORD PTR pResidual$[rsp]
  00aa1	c7 00 00 00 00
	00		 mov	 DWORD PTR [rax], 0

; 1762 :         *pUnitStat = CSW_CE | CSW_DE | CSW_UX;

  00aa7	48 8b 84 24 a8
	01 00 00	 mov	 rax, QWORD PTR pUnitStat$[rsp]
  00aaf	c6 00 0d	 mov	 BYTE PTR [rax], 13

; 1763 :     }

  00ab2	e9 39 08 00 00	 jmp	 $LN22@CTCE_Execu
$LN21@CTCE_Execu:

; 1764 : 
; 1765 :     // Otherwise in case the CTCE device is not busy actions may result.
; 1766 :     else if( !( CTCE_Info.x_unit_stat & CSW_BUSY ) )

  00ab7	0f b6 84 24 20
	01 00 00	 movzx	 eax, BYTE PTR CTCE_Info$[rsp+8]
  00abf	83 e0 10	 and	 eax, 16
  00ac2	85 c0		 test	 eax, eax
  00ac4	0f 85 26 08 00
	00		 jne	 $LN23@CTCE_Execu

; 1767 :     {
; 1768 :         CLR_CTCE_WEOF( pDEVBLK->ctcexState );

  00aca	48 8b 84 24 60
	01 00 00	 mov	 rax, QWORD PTR pDEVBLK$[rsp]
  00ad2	0f b6 80 34 07
	00 00		 movzx	 eax, BYTE PTR [rax+1844]
  00ad9	0f ba f0 07	 btr	 eax, 7
  00add	48 8b 8c 24 60
	01 00 00	 mov	 rcx, QWORD PTR pDEVBLK$[rsp]
  00ae5	88 81 34 07 00
	00		 mov	 BYTE PTR [rcx+1844], al

; 1769 :         pDEVBLK->ctcexState = CTCE_NEW_X_STATE( pDEVBLK->ctcexCmd );

  00aeb	48 8b 84 24 60
	01 00 00	 mov	 rax, QWORD PTR pDEVBLK$[rsp]
  00af3	8b 80 18 07 00
	00		 mov	 eax, DWORD PTR [rax+1816]
  00af9	83 e0 01	 and	 eax, 1
  00afc	85 c0		 test	 eax, eax
  00afe	75 75		 jne	 SHORT $LN104@CTCE_Execu
  00b00	48 8b 84 24 60
	01 00 00	 mov	 rax, QWORD PTR pDEVBLK$[rsp]
  00b08	8b 80 74 07 00
	00		 mov	 eax, DWORD PTR [rax+1908]
  00b0e	c1 e8 03	 shr	 eax, 3
  00b11	83 e0 01	 and	 eax, 1
  00b14	85 c0		 test	 eax, eax
  00b16	75 5d		 jne	 SHORT $LN104@CTCE_Execu
  00b18	48 8b 84 24 60
	01 00 00	 mov	 rax, QWORD PTR pDEVBLK$[rsp]
  00b20	0f b6 80 35 07
	00 00		 movzx	 eax, BYTE PTR [rax+1845]
  00b27	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:CTCE_command
  00b2e	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00b32	83 f8 07	 cmp	 eax, 7
  00b35	75 0d		 jne	 SHORT $LN105@CTCE_Execu
  00b37	c7 84 24 a8 00
	00 00 03 00 00
	00		 mov	 DWORD PTR tv499[rsp], 3
  00b42	eb 21		 jmp	 SHORT $LN106@CTCE_Execu
$LN105@CTCE_Execu:
  00b44	48 8b 84 24 60
	01 00 00	 mov	 rax, QWORD PTR pDEVBLK$[rsp]
  00b4c	0f b6 80 35 07
	00 00		 movzx	 eax, BYTE PTR [rax+1845]
  00b53	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:CTCE_command
  00b5a	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00b5e	89 84 24 a8 00
	00 00		 mov	 DWORD PTR tv499[rsp], eax
$LN106@CTCE_Execu:
  00b65	8b 84 24 a8 00
	00 00		 mov	 eax, DWORD PTR tv499[rsp]
  00b6c	89 84 24 b4 00
	00 00		 mov	 DWORD PTR tv500[rsp], eax
  00b73	eb 21		 jmp	 SHORT $LN107@CTCE_Execu
$LN104@CTCE_Execu:
  00b75	48 8b 84 24 60
	01 00 00	 mov	 rax, QWORD PTR pDEVBLK$[rsp]
  00b7d	0f b6 80 35 07
	00 00		 movzx	 eax, BYTE PTR [rax+1845]
  00b84	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:CTCE_command
  00b8b	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00b8f	89 84 24 b4 00
	00 00		 mov	 DWORD PTR tv500[rsp], eax
$LN107@CTCE_Execu:
  00b96	48 8b 84 24 60
	01 00 00	 mov	 rax, QWORD PTR pDEVBLK$[rsp]
  00b9e	0f b6 80 34 07
	00 00		 movzx	 eax, BYTE PTR [rax+1844]
  00ba5	83 e0 04	 and	 eax, 4
  00ba8	85 c0		 test	 eax, eax
  00baa	75 10		 jne	 SHORT $LN112@CTCE_Execu
  00bac	c7 84 24 b8 00
	00 00 06 00 00
	00		 mov	 DWORD PTR tv527[rsp], 6
  00bb7	e9 a1 00 00 00	 jmp	 $LN113@CTCE_Execu
$LN112@CTCE_Execu:
  00bbc	48 8b 84 24 60
	01 00 00	 mov	 rax, QWORD PTR pDEVBLK$[rsp]
  00bc4	8b 80 18 07 00
	00		 mov	 eax, DWORD PTR [rax+1816]
  00bca	83 e0 01	 and	 eax, 1
  00bcd	85 c0		 test	 eax, eax
  00bcf	75 65		 jne	 SHORT $LN108@CTCE_Execu
  00bd1	48 8b 84 24 60
	01 00 00	 mov	 rax, QWORD PTR pDEVBLK$[rsp]
  00bd9	8b 80 74 07 00
	00		 mov	 eax, DWORD PTR [rax+1908]
  00bdf	c1 e8 03	 shr	 eax, 3
  00be2	83 e0 01	 and	 eax, 1
  00be5	85 c0		 test	 eax, eax
  00be7	75 4d		 jne	 SHORT $LN108@CTCE_Execu
  00be9	48 8b 84 24 60
	01 00 00	 mov	 rax, QWORD PTR pDEVBLK$[rsp]
  00bf1	0f b6 80 36 07
	00 00		 movzx	 eax, BYTE PTR [rax+1846]
  00bf8	83 e0 07	 and	 eax, 7
  00bfb	83 f8 05	 cmp	 eax, 5
  00bfe	75 0d		 jne	 SHORT $LN109@CTCE_Execu
  00c00	c7 84 24 ac 00
	00 00 04 00 00
	00		 mov	 DWORD PTR tv525[rsp], 4
  00c0b	eb 19		 jmp	 SHORT $LN110@CTCE_Execu
$LN109@CTCE_Execu:
  00c0d	48 8b 84 24 60
	01 00 00	 mov	 rax, QWORD PTR pDEVBLK$[rsp]
  00c15	0f b6 80 36 07
	00 00		 movzx	 eax, BYTE PTR [rax+1846]
  00c1c	83 e0 07	 and	 eax, 7
  00c1f	89 84 24 ac 00
	00 00		 mov	 DWORD PTR tv525[rsp], eax
$LN110@CTCE_Execu:
  00c26	8b 84 24 ac 00
	00 00		 mov	 eax, DWORD PTR tv525[rsp]
  00c2d	89 84 24 b0 00
	00 00		 mov	 DWORD PTR tv526[rsp], eax
  00c34	eb 19		 jmp	 SHORT $LN111@CTCE_Execu
$LN108@CTCE_Execu:
  00c36	48 8b 84 24 60
	01 00 00	 mov	 rax, QWORD PTR pDEVBLK$[rsp]
  00c3e	0f b6 80 36 07
	00 00		 movzx	 eax, BYTE PTR [rax+1846]
  00c45	83 e0 07	 and	 eax, 7
  00c48	89 84 24 b0 00
	00 00		 mov	 DWORD PTR tv526[rsp], eax
$LN111@CTCE_Execu:
  00c4f	8b 84 24 b0 00
	00 00		 mov	 eax, DWORD PTR tv526[rsp]
  00c56	89 84 24 b8 00
	00 00		 mov	 DWORD PTR tv527[rsp], eax
$LN113@CTCE_Execu:
  00c5d	48 63 84 24 b4
	00 00 00	 movsxd	 rax, DWORD PTR tv500[rsp]
  00c65	48 6b c0 20	 imul	 rax, rax, 32		; 00000020H
  00c69	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:CTCE_Fsm
  00c70	48 03 c8	 add	 rcx, rax
  00c73	48 8b c1	 mov	 rax, rcx
  00c76	48 63 8c 24 b8
	00 00 00	 movsxd	 rcx, DWORD PTR tv527[rsp]
  00c7e	0f b6 04 88	 movzx	 eax, BYTE PTR [rax+rcx*4]
  00c82	3d ff 00 00 00	 cmp	 eax, 255		; 000000ffH
  00c87	0f 84 a0 01 00
	00		 je	 $LN124@CTCE_Execu
  00c8d	48 8b 84 24 60
	01 00 00	 mov	 rax, QWORD PTR pDEVBLK$[rsp]
  00c95	8b 80 18 07 00
	00		 mov	 eax, DWORD PTR [rax+1816]
  00c9b	83 e0 01	 and	 eax, 1
  00c9e	85 c0		 test	 eax, eax
  00ca0	75 75		 jne	 SHORT $LN114@CTCE_Execu
  00ca2	48 8b 84 24 60
	01 00 00	 mov	 rax, QWORD PTR pDEVBLK$[rsp]
  00caa	8b 80 74 07 00
	00		 mov	 eax, DWORD PTR [rax+1908]
  00cb0	c1 e8 03	 shr	 eax, 3
  00cb3	83 e0 01	 and	 eax, 1
  00cb6	85 c0		 test	 eax, eax
  00cb8	75 5d		 jne	 SHORT $LN114@CTCE_Execu
  00cba	48 8b 84 24 60
	01 00 00	 mov	 rax, QWORD PTR pDEVBLK$[rsp]
  00cc2	0f b6 80 35 07
	00 00		 movzx	 eax, BYTE PTR [rax+1845]
  00cc9	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:CTCE_command
  00cd0	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00cd4	83 f8 07	 cmp	 eax, 7
  00cd7	75 0d		 jne	 SHORT $LN115@CTCE_Execu
  00cd9	c7 84 24 bc 00
	00 00 03 00 00
	00		 mov	 DWORD PTR tv557[rsp], 3
  00ce4	eb 21		 jmp	 SHORT $LN116@CTCE_Execu
$LN115@CTCE_Execu:
  00ce6	48 8b 84 24 60
	01 00 00	 mov	 rax, QWORD PTR pDEVBLK$[rsp]
  00cee	0f b6 80 35 07
	00 00		 movzx	 eax, BYTE PTR [rax+1845]
  00cf5	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:CTCE_command
  00cfc	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00d00	89 84 24 bc 00
	00 00		 mov	 DWORD PTR tv557[rsp], eax
$LN116@CTCE_Execu:
  00d07	8b 84 24 bc 00
	00 00		 mov	 eax, DWORD PTR tv557[rsp]
  00d0e	89 84 24 c8 00
	00 00		 mov	 DWORD PTR tv558[rsp], eax
  00d15	eb 21		 jmp	 SHORT $LN117@CTCE_Execu
$LN114@CTCE_Execu:
  00d17	48 8b 84 24 60
	01 00 00	 mov	 rax, QWORD PTR pDEVBLK$[rsp]
  00d1f	0f b6 80 35 07
	00 00		 movzx	 eax, BYTE PTR [rax+1845]
  00d26	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:CTCE_command
  00d2d	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00d31	89 84 24 c8 00
	00 00		 mov	 DWORD PTR tv558[rsp], eax
$LN117@CTCE_Execu:
  00d38	48 8b 84 24 60
	01 00 00	 mov	 rax, QWORD PTR pDEVBLK$[rsp]
  00d40	0f b6 80 34 07
	00 00		 movzx	 eax, BYTE PTR [rax+1844]
  00d47	83 e0 04	 and	 eax, 4
  00d4a	85 c0		 test	 eax, eax
  00d4c	75 10		 jne	 SHORT $LN122@CTCE_Execu
  00d4e	c7 84 24 cc 00
	00 00 06 00 00
	00		 mov	 DWORD PTR tv585[rsp], 6
  00d59	e9 a1 00 00 00	 jmp	 $LN123@CTCE_Execu
$LN122@CTCE_Execu:
  00d5e	48 8b 84 24 60
	01 00 00	 mov	 rax, QWORD PTR pDEVBLK$[rsp]
  00d66	8b 80 18 07 00
	00		 mov	 eax, DWORD PTR [rax+1816]
  00d6c	83 e0 01	 and	 eax, 1
  00d6f	85 c0		 test	 eax, eax
  00d71	75 65		 jne	 SHORT $LN118@CTCE_Execu
  00d73	48 8b 84 24 60
	01 00 00	 mov	 rax, QWORD PTR pDEVBLK$[rsp]
  00d7b	8b 80 74 07 00
	00		 mov	 eax, DWORD PTR [rax+1908]
  00d81	c1 e8 03	 shr	 eax, 3
  00d84	83 e0 01	 and	 eax, 1
  00d87	85 c0		 test	 eax, eax
  00d89	75 4d		 jne	 SHORT $LN118@CTCE_Execu
  00d8b	48 8b 84 24 60
	01 00 00	 mov	 rax, QWORD PTR pDEVBLK$[rsp]
  00d93	0f b6 80 36 07
	00 00		 movzx	 eax, BYTE PTR [rax+1846]
  00d9a	83 e0 07	 and	 eax, 7
  00d9d	83 f8 05	 cmp	 eax, 5
  00da0	75 0d		 jne	 SHORT $LN119@CTCE_Execu
  00da2	c7 84 24 c0 00
	00 00 04 00 00
	00		 mov	 DWORD PTR tv583[rsp], 4
  00dad	eb 19		 jmp	 SHORT $LN120@CTCE_Execu
$LN119@CTCE_Execu:
  00daf	48 8b 84 24 60
	01 00 00	 mov	 rax, QWORD PTR pDEVBLK$[rsp]
  00db7	0f b6 80 36 07
	00 00		 movzx	 eax, BYTE PTR [rax+1846]
  00dbe	83 e0 07	 and	 eax, 7
  00dc1	89 84 24 c0 00
	00 00		 mov	 DWORD PTR tv583[rsp], eax
$LN120@CTCE_Execu:
  00dc8	8b 84 24 c0 00
	00 00		 mov	 eax, DWORD PTR tv583[rsp]
  00dcf	89 84 24 c4 00
	00 00		 mov	 DWORD PTR tv584[rsp], eax
  00dd6	eb 19		 jmp	 SHORT $LN121@CTCE_Execu
$LN118@CTCE_Execu:
  00dd8	48 8b 84 24 60
	01 00 00	 mov	 rax, QWORD PTR pDEVBLK$[rsp]
  00de0	0f b6 80 36 07
	00 00		 movzx	 eax, BYTE PTR [rax+1846]
  00de7	83 e0 07	 and	 eax, 7
  00dea	89 84 24 c4 00
	00 00		 mov	 DWORD PTR tv584[rsp], eax
$LN121@CTCE_Execu:
  00df1	8b 84 24 c4 00
	00 00		 mov	 eax, DWORD PTR tv584[rsp]
  00df8	89 84 24 cc 00
	00 00		 mov	 DWORD PTR tv585[rsp], eax
$LN123@CTCE_Execu:
  00dff	48 63 84 24 c8
	00 00 00	 movsxd	 rax, DWORD PTR tv558[rsp]
  00e07	48 6b c0 20	 imul	 rax, rax, 32		; 00000020H
  00e0b	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:CTCE_Fsm
  00e12	48 03 c8	 add	 rcx, rax
  00e15	48 8b c1	 mov	 rax, rcx
  00e18	48 63 8c 24 cc
	00 00 00	 movsxd	 rcx, DWORD PTR tv585[rsp]
  00e20	0f b6 04 88	 movzx	 eax, BYTE PTR [rax+rcx*4]
  00e24	89 84 24 d0 00
	00 00		 mov	 DWORD PTR tv594[rsp], eax
  00e2b	eb 19		 jmp	 SHORT $LN125@CTCE_Execu
$LN124@CTCE_Execu:
  00e2d	48 8b 84 24 60
	01 00 00	 mov	 rax, QWORD PTR pDEVBLK$[rsp]
  00e35	0f b6 80 34 07
	00 00		 movzx	 eax, BYTE PTR [rax+1844]
  00e3c	83 e0 07	 and	 eax, 7
  00e3f	89 84 24 d0 00
	00 00		 mov	 DWORD PTR tv594[rsp], eax
$LN125@CTCE_Execu:
  00e46	48 8b 84 24 60
	01 00 00	 mov	 rax, QWORD PTR pDEVBLK$[rsp]
  00e4e	0f b6 8c 24 d0
	00 00 00	 movzx	 ecx, BYTE PTR tv594[rsp]
  00e56	88 88 34 07 00
	00		 mov	 BYTE PTR [rax+1844], cl

; 1770 : 
; 1771 :         // Process depending on the CCW command.
; 1772 :         switch ( CTCE_CMD( pDEVBLK->ctcexCmd ) )

  00e5c	48 8b 84 24 60
	01 00 00	 mov	 rax, QWORD PTR pDEVBLK$[rsp]
  00e64	8b 80 18 07 00
	00		 mov	 eax, DWORD PTR [rax+1816]
  00e6a	83 e0 01	 and	 eax, 1
  00e6d	85 c0		 test	 eax, eax
  00e6f	75 75		 jne	 SHORT $LN126@CTCE_Execu
  00e71	48 8b 84 24 60
	01 00 00	 mov	 rax, QWORD PTR pDEVBLK$[rsp]
  00e79	8b 80 74 07 00
	00		 mov	 eax, DWORD PTR [rax+1908]
  00e7f	c1 e8 03	 shr	 eax, 3
  00e82	83 e0 01	 and	 eax, 1
  00e85	85 c0		 test	 eax, eax
  00e87	75 5d		 jne	 SHORT $LN126@CTCE_Execu
  00e89	48 8b 84 24 60
	01 00 00	 mov	 rax, QWORD PTR pDEVBLK$[rsp]
  00e91	0f b6 80 35 07
	00 00		 movzx	 eax, BYTE PTR [rax+1845]
  00e98	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:CTCE_command
  00e9f	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00ea3	83 f8 07	 cmp	 eax, 7
  00ea6	75 0d		 jne	 SHORT $LN127@CTCE_Execu
  00ea8	c7 84 24 d4 00
	00 00 03 00 00
	00		 mov	 DWORD PTR tv619[rsp], 3
  00eb3	eb 21		 jmp	 SHORT $LN128@CTCE_Execu
$LN127@CTCE_Execu:
  00eb5	48 8b 84 24 60
	01 00 00	 mov	 rax, QWORD PTR pDEVBLK$[rsp]
  00ebd	0f b6 80 35 07
	00 00		 movzx	 eax, BYTE PTR [rax+1845]
  00ec4	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:CTCE_command
  00ecb	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00ecf	89 84 24 d4 00
	00 00		 mov	 DWORD PTR tv619[rsp], eax
$LN128@CTCE_Execu:
  00ed6	8b 84 24 d4 00
	00 00		 mov	 eax, DWORD PTR tv619[rsp]
  00edd	89 84 24 d8 00
	00 00		 mov	 DWORD PTR tv620[rsp], eax
  00ee4	eb 21		 jmp	 SHORT $LN129@CTCE_Execu
$LN126@CTCE_Execu:
  00ee6	48 8b 84 24 60
	01 00 00	 mov	 rax, QWORD PTR pDEVBLK$[rsp]
  00eee	0f b6 80 35 07
	00 00		 movzx	 eax, BYTE PTR [rax+1845]
  00ef5	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:CTCE_command
  00efc	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00f00	89 84 24 d8 00
	00 00		 mov	 DWORD PTR tv620[rsp], eax
$LN129@CTCE_Execu:
  00f07	8b 84 24 d8 00
	00 00		 mov	 eax, DWORD PTR tv620[rsp]
  00f0e	89 84 24 dc 00
	00 00		 mov	 DWORD PTR tv621[rsp], eax
  00f15	83 bc 24 dc 00
	00 00 0f	 cmp	 DWORD PTR tv621[rsp], 15
  00f1d	0f 87 5b 03 00
	00		 ja	 $LN38@CTCE_Execu
  00f23	48 63 84 24 dc
	00 00 00	 movsxd	 rax, DWORD PTR tv621[rsp]
  00f2b	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__ImageBase
  00f32	8b 84 81 00 00
	00 00		 mov	 eax, DWORD PTR $LN152@CTCE_Execu[rcx+rax*4]
  00f39	48 03 c1	 add	 rax, rcx
  00f3c	ff e0		 jmp	 rax
$LN24@CTCE_Execu:
$LN25@CTCE_Execu:
$LN26@CTCE_Execu:
$LN27@CTCE_Execu:
$LN28@CTCE_Execu:
$LN29@CTCE_Execu:
$LN30@CTCE_Execu:

; 1773 :         {
; 1774 : 
; 1775 :         // Most of the CTCE commands processing (if any at all) takes
; 1776 :         // place in CTCE_Send and CTCE_RECV down below, except this :
; 1777 :         case CTCE_PREPARE:
; 1778 :         case CTCE_CONTROL:
; 1779 :         case CTCE_READ:
; 1780 :         case CTCE_WRITE:
; 1781 :         case CTCE_READ_BACKWARD:
; 1782 :         case CTCE_WRITE_END_OF_FILE:
; 1783 :         case CTCE_NO_OPERATION:
; 1784 :             break;

  00f3e	e9 5f 03 00 00	 jmp	 $LN14@CTCE_Execu
$LN31@CTCE_Execu:

; 1785 : 
; 1786 :         case CTCE_SET_EXTENDED_MODE:
; 1787 :             pDEVBLK->ctcxmode = 1;

  00f43	48 8b 84 24 60
	01 00 00	 mov	 rax, QWORD PTR pDEVBLK$[rsp]
  00f4b	8b 80 18 07 00
	00		 mov	 eax, DWORD PTR [rax+1816]
  00f51	83 c8 01	 or	 eax, 1
  00f54	48 8b 8c 24 60
	01 00 00	 mov	 rcx, QWORD PTR pDEVBLK$[rsp]
  00f5c	89 81 18 07 00
	00		 mov	 DWORD PTR [rcx+1816], eax

; 1788 :             break;

  00f62	e9 3b 03 00 00	 jmp	 $LN14@CTCE_Execu
$LN32@CTCE_Execu:

; 1789 : 
; 1790 :         case CTCE_SET_BASIC_MODE:
; 1791 :             pDEVBLK->ctcxmode = 0;

  00f67	48 8b 84 24 60
	01 00 00	 mov	 rax, QWORD PTR pDEVBLK$[rsp]
  00f6f	8b 80 18 07 00
	00		 mov	 eax, DWORD PTR [rax+1816]
  00f75	83 e0 fe	 and	 eax, -2			; fffffffeH
  00f78	48 8b 8c 24 60
	01 00 00	 mov	 rcx, QWORD PTR pDEVBLK$[rsp]
  00f80	89 81 18 07 00
	00		 mov	 DWORD PTR [rcx+1816], eax

; 1792 :             break;

  00f86	e9 17 03 00 00	 jmp	 $LN14@CTCE_Execu
$LN33@CTCE_Execu:

; 1793 : 
; 1794 :         case CTCE_SENSE_COMMAND_BYTE:
; 1795 : 
; 1796 :             // In y-state available we return 0 otherwise the last y-side command.
; 1797 :             *pIOBuf = ( IS_CTCE_YAV( pDEVBLK->ctceyState ) ) ?

  00f8b	48 8b 84 24 60
	01 00 00	 mov	 rax, QWORD PTR pDEVBLK$[rsp]
  00f93	8b 80 18 07 00
	00		 mov	 eax, DWORD PTR [rax+1816]
  00f99	83 e0 01	 and	 eax, 1
  00f9c	85 c0		 test	 eax, eax
  00f9e	75 65		 jne	 SHORT $LN130@CTCE_Execu
  00fa0	48 8b 84 24 60
	01 00 00	 mov	 rax, QWORD PTR pDEVBLK$[rsp]
  00fa8	8b 80 74 07 00
	00		 mov	 eax, DWORD PTR [rax+1908]
  00fae	c1 e8 03	 shr	 eax, 3
  00fb1	83 e0 01	 and	 eax, 1
  00fb4	85 c0		 test	 eax, eax
  00fb6	75 4d		 jne	 SHORT $LN130@CTCE_Execu
  00fb8	48 8b 84 24 60
	01 00 00	 mov	 rax, QWORD PTR pDEVBLK$[rsp]
  00fc0	0f b6 80 36 07
	00 00		 movzx	 eax, BYTE PTR [rax+1846]
  00fc7	83 e0 07	 and	 eax, 7
  00fca	83 f8 05	 cmp	 eax, 5
  00fcd	75 0d		 jne	 SHORT $LN131@CTCE_Execu
  00fcf	c7 84 24 e0 00
	00 00 04 00 00
	00		 mov	 DWORD PTR tv645[rsp], 4
  00fda	eb 19		 jmp	 SHORT $LN132@CTCE_Execu
$LN131@CTCE_Execu:
  00fdc	48 8b 84 24 60
	01 00 00	 mov	 rax, QWORD PTR pDEVBLK$[rsp]
  00fe4	0f b6 80 36 07
	00 00		 movzx	 eax, BYTE PTR [rax+1846]
  00feb	83 e0 07	 and	 eax, 7
  00fee	89 84 24 e0 00
	00 00		 mov	 DWORD PTR tv645[rsp], eax
$LN132@CTCE_Execu:
  00ff5	8b 84 24 e0 00
	00 00		 mov	 eax, DWORD PTR tv645[rsp]
  00ffc	89 84 24 e4 00
	00 00		 mov	 DWORD PTR tv646[rsp], eax
  01003	eb 19		 jmp	 SHORT $LN133@CTCE_Execu
$LN130@CTCE_Execu:
  01005	48 8b 84 24 60
	01 00 00	 mov	 rax, QWORD PTR pDEVBLK$[rsp]
  0100d	0f b6 80 36 07
	00 00		 movzx	 eax, BYTE PTR [rax+1846]
  01014	83 e0 07	 and	 eax, 7
  01017	89 84 24 e4 00
	00 00		 mov	 DWORD PTR tv646[rsp], eax
$LN133@CTCE_Execu:
  0101e	83 bc 24 e4 00
	00 00 04	 cmp	 DWORD PTR tv646[rsp], 4
  01026	75 0d		 jne	 SHORT $LN134@CTCE_Execu
  01028	c7 84 24 e8 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv650[rsp], 0
  01033	eb 16		 jmp	 SHORT $LN135@CTCE_Execu
$LN134@CTCE_Execu:
  01035	48 8b 84 24 60
	01 00 00	 mov	 rax, QWORD PTR pDEVBLK$[rsp]
  0103d	0f b6 80 37 07
	00 00		 movzx	 eax, BYTE PTR [rax+1847]
  01044	89 84 24 e8 00
	00 00		 mov	 DWORD PTR tv650[rsp], eax
$LN135@CTCE_Execu:
  0104b	48 8b 84 24 98
	01 00 00	 mov	 rax, QWORD PTR pIOBuf$[rsp]
  01053	0f b6 8c 24 e8
	00 00 00	 movzx	 ecx, BYTE PTR tv650[rsp]
  0105b	88 08		 mov	 BYTE PTR [rax], cl

; 1798 :                 0 : pDEVBLK->ctceyCmd;
; 1799 :             CTCE_Info.scb = *pIOBuf;

  0105d	48 8b 84 24 98
	01 00 00	 mov	 rax, QWORD PTR pIOBuf$[rsp]
  01065	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  01068	88 84 24 21 01
	00 00		 mov	 BYTE PTR CTCE_Info$[rsp+9], al

; 1800 :             *pResidual = sCount - 1;

  0106f	8b 84 24 80 01
	00 00		 mov	 eax, DWORD PTR sCount$[rsp]
  01076	ff c8		 dec	 eax
  01078	48 8b 8c 24 b0
	01 00 00	 mov	 rcx, QWORD PTR pResidual$[rsp]
  01080	89 01		 mov	 DWORD PTR [rcx], eax

; 1801 :             break;

  01082	e9 1b 02 00 00	 jmp	 $LN14@CTCE_Execu
$LN34@CTCE_Execu:

; 1802 : 
; 1803 :         case CTCE_SENSE_ADAPTER_STATE:
; 1804 : 
; 1805 :             // Calculate residual byte count
; 1806 :             iNum = ( sCount < pDEVBLK->numsense ) ?

  01087	48 8b 84 24 60
	01 00 00	 mov	 rax, QWORD PTR pDEVBLK$[rsp]
  0108f	8b 80 60 03 00
	00		 mov	 eax, DWORD PTR [rax+864]
  01095	39 84 24 80 01
	00 00		 cmp	 DWORD PTR sCount$[rsp], eax
  0109c	73 10		 jae	 SHORT $LN136@CTCE_Execu
  0109e	8b 84 24 80 01
	00 00		 mov	 eax, DWORD PTR sCount$[rsp]
  010a5	89 84 24 ec 00
	00 00		 mov	 DWORD PTR tv656[rsp], eax
  010ac	eb 15		 jmp	 SHORT $LN137@CTCE_Execu
$LN136@CTCE_Execu:
  010ae	48 8b 84 24 60
	01 00 00	 mov	 rax, QWORD PTR pDEVBLK$[rsp]
  010b6	8b 80 60 03 00
	00		 mov	 eax, DWORD PTR [rax+864]
  010bc	89 84 24 ec 00
	00 00		 mov	 DWORD PTR tv656[rsp], eax
$LN137@CTCE_Execu:
  010c3	8b 84 24 ec 00
	00 00		 mov	 eax, DWORD PTR tv656[rsp]
  010ca	89 44 24 30	 mov	 DWORD PTR iNum$[rsp], eax

; 1807 :                 sCount : pDEVBLK->numsense;
; 1808 :             *pResidual = sCount - iNum;

  010ce	8b 44 24 30	 mov	 eax, DWORD PTR iNum$[rsp]
  010d2	8b 8c 24 80 01
	00 00		 mov	 ecx, DWORD PTR sCount$[rsp]
  010d9	2b c8		 sub	 ecx, eax
  010db	8b c1		 mov	 eax, ecx
  010dd	48 8b 8c 24 b0
	01 00 00	 mov	 rcx, QWORD PTR pResidual$[rsp]
  010e5	89 01		 mov	 DWORD PTR [rcx], eax

; 1809 : 
; 1810 :             // Copy device sense bytes to channel I/O buffer
; 1811 :             memcpy( pIOBuf, pDEVBLK->sense, iNum );

  010e7	48 63 44 24 30	 movsxd	 rax, DWORD PTR iNum$[rsp]
  010ec	48 8b 8c 24 60
	01 00 00	 mov	 rcx, QWORD PTR pDEVBLK$[rsp]
  010f4	48 81 c1 64 03
	00 00		 add	 rcx, 868		; 00000364H
  010fb	48 8b bc 24 98
	01 00 00	 mov	 rdi, QWORD PTR pIOBuf$[rsp]
  01103	48 8b f1	 mov	 rsi, rcx
  01106	48 8b c8	 mov	 rcx, rax
  01109	f3 a4		 rep movsb

; 1812 :             memcpy( &CTCE_Info.sas, pDEVBLK->sense, 2 );

  0110b	48 8b 84 24 60
	01 00 00	 mov	 rax, QWORD PTR pDEVBLK$[rsp]
  01113	0f b7 80 64 03
	00 00		 movzx	 eax, WORD PTR [rax+868]
  0111a	66 89 84 24 22
	01 00 00	 mov	 WORD PTR CTCE_Info$[rsp+10], ax

; 1813 : 
; 1814 :             // Clear the device sense bytes
; 1815 :             memset( pDEVBLK->sense, 0, sizeof( pDEVBLK->sense ) );

  01122	48 8b 84 24 60
	01 00 00	 mov	 rax, QWORD PTR pDEVBLK$[rsp]
  0112a	48 05 64 03 00
	00		 add	 rax, 868		; 00000364H
  01130	48 8b f8	 mov	 rdi, rax
  01133	33 c0		 xor	 eax, eax
  01135	b9 00 01 00 00	 mov	 ecx, 256		; 00000100H
  0113a	f3 aa		 rep stosb

; 1816 :             break;

  0113c	e9 61 01 00 00	 jmp	 $LN14@CTCE_Execu
$LN35@CTCE_Execu:

; 1817 : 
; 1818 :         case CTCE_SENSE_ID:
; 1819 : 
; 1820 :             // Calculate residual byte count
; 1821 :             iNum = ( sCount < pDEVBLK->numdevid ) ?

  01141	48 8b 84 24 60
	01 00 00	 mov	 rax, QWORD PTR pDEVBLK$[rsp]
  01149	8b 80 64 04 00
	00		 mov	 eax, DWORD PTR [rax+1124]
  0114f	39 84 24 80 01
	00 00		 cmp	 DWORD PTR sCount$[rsp], eax
  01156	73 10		 jae	 SHORT $LN138@CTCE_Execu
  01158	8b 84 24 80 01
	00 00		 mov	 eax, DWORD PTR sCount$[rsp]
  0115f	89 84 24 f0 00
	00 00		 mov	 DWORD PTR tv681[rsp], eax
  01166	eb 15		 jmp	 SHORT $LN139@CTCE_Execu
$LN138@CTCE_Execu:
  01168	48 8b 84 24 60
	01 00 00	 mov	 rax, QWORD PTR pDEVBLK$[rsp]
  01170	8b 80 64 04 00
	00		 mov	 eax, DWORD PTR [rax+1124]
  01176	89 84 24 f0 00
	00 00		 mov	 DWORD PTR tv681[rsp], eax
$LN139@CTCE_Execu:
  0117d	8b 84 24 f0 00
	00 00		 mov	 eax, DWORD PTR tv681[rsp]
  01184	89 44 24 30	 mov	 DWORD PTR iNum$[rsp], eax

; 1822 :                 sCount : pDEVBLK->numdevid;
; 1823 :             *pResidual = sCount - iNum;

  01188	8b 44 24 30	 mov	 eax, DWORD PTR iNum$[rsp]
  0118c	8b 8c 24 80 01
	00 00		 mov	 ecx, DWORD PTR sCount$[rsp]
  01193	2b c8		 sub	 ecx, eax
  01195	8b c1		 mov	 eax, ecx
  01197	48 8b 8c 24 b0
	01 00 00	 mov	 rcx, QWORD PTR pResidual$[rsp]
  0119f	89 01		 mov	 DWORD PTR [rcx], eax

; 1824 : 
; 1825 :             // Copy device identifier bytes to channel I/O buffer
; 1826 :             memcpy( pIOBuf, pDEVBLK->devid, iNum );

  011a1	48 63 44 24 30	 movsxd	 rax, DWORD PTR iNum$[rsp]
  011a6	48 8b 8c 24 60
	01 00 00	 mov	 rcx, QWORD PTR pDEVBLK$[rsp]
  011ae	48 81 c1 68 04
	00 00		 add	 rcx, 1128		; 00000468H
  011b5	48 8b bc 24 98
	01 00 00	 mov	 rdi, QWORD PTR pIOBuf$[rsp]
  011bd	48 8b f1	 mov	 rsi, rcx
  011c0	48 8b c8	 mov	 rcx, rax
  011c3	f3 a4		 rep movsb

; 1827 :             break;

  011c5	e9 d8 00 00 00	 jmp	 $LN14@CTCE_Execu
$LN36@CTCE_Execu:

; 1828 : 
; 1829 :         case CTCE_READ_CONFIG_DATA:
; 1830 : 
; 1831 :             // Build the RCD bytes into the devid.
; 1832 :             iNum = CTCE_Build_RCD( pDEVBLK,

  011ca	48 8b 84 24 60
	01 00 00	 mov	 rax, QWORD PTR pDEVBLK$[rsp]
  011d2	8b 80 64 04 00
	00		 mov	 eax, DWORD PTR [rax+1124]
  011d8	b9 00 01 00 00	 mov	 ecx, 256		; 00000100H
  011dd	48 2b c8	 sub	 rcx, rax
  011e0	48 8b c1	 mov	 rax, rcx
  011e3	48 8b 8c 24 60
	01 00 00	 mov	 rcx, QWORD PTR pDEVBLK$[rsp]
  011eb	8b 89 64 04 00
	00		 mov	 ecx, DWORD PTR [rcx+1124]
  011f1	48 8b 94 24 60
	01 00 00	 mov	 rdx, QWORD PTR pDEVBLK$[rsp]
  011f9	48 8d 8c 0a 68
	04 00 00	 lea	 rcx, QWORD PTR [rdx+rcx+1128]
  01201	44 8b c0	 mov	 r8d, eax
  01204	48 8b d1	 mov	 rdx, rcx
  01207	48 8b 8c 24 60
	01 00 00	 mov	 rcx, QWORD PTR pDEVBLK$[rsp]
  0120f	e8 00 00 00 00	 call	 CTCE_Build_RCD
  01214	89 44 24 30	 mov	 DWORD PTR iNum$[rsp], eax

; 1833 :                 pDEVBLK->devid + pDEVBLK->numdevid,
; 1834 :                 sizeof( pDEVBLK->devid ) - pDEVBLK->numdevid );
; 1835 :             if ( (int) sCount < iNum )

  01218	8b 44 24 30	 mov	 eax, DWORD PTR iNum$[rsp]
  0121c	39 84 24 80 01
	00 00		 cmp	 DWORD PTR sCount$[rsp], eax
  01223	7d 0b		 jge	 SHORT $LN37@CTCE_Execu

; 1836 :             {
; 1837 :                 iNum = sCount;

  01225	8b 84 24 80 01
	00 00		 mov	 eax, DWORD PTR sCount$[rsp]
  0122c	89 44 24 30	 mov	 DWORD PTR iNum$[rsp], eax
$LN37@CTCE_Execu:

; 1838 :             }
; 1839 :             *pResidual = sCount - iNum;

  01230	8b 44 24 30	 mov	 eax, DWORD PTR iNum$[rsp]
  01234	8b 8c 24 80 01
	00 00		 mov	 ecx, DWORD PTR sCount$[rsp]
  0123b	2b c8		 sub	 ecx, eax
  0123d	8b c1		 mov	 eax, ecx
  0123f	48 8b 8c 24 b0
	01 00 00	 mov	 rcx, QWORD PTR pResidual$[rsp]
  01247	89 01		 mov	 DWORD PTR [rcx], eax

; 1840 : 
; 1841 :             // Copy the RCD bytes now in devid to the channel I/O buffer.
; 1842 :             memcpy( pIOBuf, pDEVBLK->devid + pDEVBLK->numdevid, iNum );

  01249	48 63 44 24 30	 movsxd	 rax, DWORD PTR iNum$[rsp]
  0124e	48 8b 8c 24 60
	01 00 00	 mov	 rcx, QWORD PTR pDEVBLK$[rsp]
  01256	8b 89 64 04 00
	00		 mov	 ecx, DWORD PTR [rcx+1124]
  0125c	48 8b 94 24 60
	01 00 00	 mov	 rdx, QWORD PTR pDEVBLK$[rsp]
  01264	48 8d 8c 0a 68
	04 00 00	 lea	 rcx, QWORD PTR [rdx+rcx+1128]
  0126c	48 8b bc 24 98
	01 00 00	 mov	 rdi, QWORD PTR pIOBuf$[rsp]
  01274	48 8b f1	 mov	 rsi, rcx
  01277	48 8b c8	 mov	 rcx, rax
  0127a	f3 a4		 rep movsb

; 1843 :             break;

  0127c	eb 24		 jmp	 SHORT $LN14@CTCE_Execu
$LN38@CTCE_Execu:

; 1844 : 
; 1845 :         // Invalid commands
; 1846 :         // (or never experienced / tested / supported ones)
; 1847 :         default:
; 1848 : 
; 1849 :             // Signalling invalid commands using Unit Check with a
; 1850 :             // Command Reject sense code for this CTCE device failed.
; 1851 :             // (MVS results were a WAIT 064 RSN 9 during NIP.)
; 1852 :             // An Interface Control Check would probably be needed but
; 1853 :             // we do not know how to generate that, so we use SENSE_EC.
; 1854 :             //
; 1855 :             //    pDEVBLK->sense[0] = SENSE_CR;
; 1856 : 
; 1857 :             pDEVBLK->sense[0] = SENSE_EC;

  0127e	b8 01 00 00 00	 mov	 eax, 1
  01283	48 6b c0 00	 imul	 rax, rax, 0
  01287	48 8b 8c 24 60
	01 00 00	 mov	 rcx, QWORD PTR pDEVBLK$[rsp]
  0128f	c6 84 01 64 03
	00 00 10	 mov	 BYTE PTR [rcx+rax+868], 16

; 1858 :             *pUnitStat        = CSW_CE | CSW_DE | CSW_UC;

  01297	48 8b 84 24 a8
	01 00 00	 mov	 rax, QWORD PTR pUnitStat$[rsp]
  0129f	c6 00 0e	 mov	 BYTE PTR [rax], 14
$LN14@CTCE_Execu:

; 1859 : 
; 1860 :         } // switch ( CTCE_CMD( pDEVBLK->ctcexCMD ) )
; 1861 : 
; 1862 :         // In most cases we need to inform the other (y-)side so we SEND
; 1863 :         // our command (and data) to the other side.  During this process
; 1864 :         // and any response received, all other actions take place.
; 1865 :         if( IS_CTCE_SEND( CTCE_Info.actions ) )

  012a2	0f b6 84 24 1e
	01 00 00	 movzx	 eax, BYTE PTR CTCE_Info$[rsp+6]
  012aa	83 e0 40	 and	 eax, 64			; 00000040H
  012ad	83 f8 40	 cmp	 eax, 64			; 00000040H
  012b0	75 3e		 jne	 SHORT $LN39@CTCE_Execu

; 1866 :         {
; 1867 :             CTCE_Send( pDEVBLK, sCount, pIOBuf, pUnitStat, pResidual, &CTCE_Info );

  012b2	48 8d 84 24 18
	01 00 00	 lea	 rax, QWORD PTR CTCE_Info$[rsp]
  012ba	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  012bf	48 8b 84 24 b0
	01 00 00	 mov	 rax, QWORD PTR pResidual$[rsp]
  012c7	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  012cc	4c 8b 8c 24 a8
	01 00 00	 mov	 r9, QWORD PTR pUnitStat$[rsp]
  012d4	4c 8b 84 24 98
	01 00 00	 mov	 r8, QWORD PTR pIOBuf$[rsp]
  012dc	8b 94 24 80 01
	00 00		 mov	 edx, DWORD PTR sCount$[rsp]
  012e3	48 8b 8c 24 60
	01 00 00	 mov	 rcx, QWORD PTR pDEVBLK$[rsp]
  012eb	e8 00 00 00 00	 call	 CTCE_Send
$LN39@CTCE_Execu:
$LN23@CTCE_Execu:
$LN22@CTCE_Execu:

; 1868 :         }
; 1869 : 
; 1870 :     } // if( !( CTCE_Info.x_unit_stat & CSW_BUSY ) )
; 1871 : 
; 1872 :     // Sense byte 0 bits 2 thru 6 are reset, effectively all but 1 and 7.
; 1873 :     pDEVBLK->sense[0] &= ( SENSE_IR | SENSE_OC );

  012f0	b8 01 00 00 00	 mov	 eax, 1
  012f5	48 6b c0 00	 imul	 rax, rax, 0
  012f9	48 8b 8c 24 60
	01 00 00	 mov	 rcx, QWORD PTR pDEVBLK$[rsp]
  01301	0f b6 84 01 64
	03 00 00	 movzx	 eax, BYTE PTR [rcx+rax+868]
  01309	83 e0 41	 and	 eax, 65			; 00000041H
  0130c	b9 01 00 00 00	 mov	 ecx, 1
  01311	48 6b c9 00	 imul	 rcx, rcx, 0
  01315	48 8b 94 24 60
	01 00 00	 mov	 rdx, QWORD PTR pDEVBLK$[rsp]
  0131d	88 84 0a 64 03
	00 00		 mov	 BYTE PTR [rdx+rcx+868], al

; 1874 : 
; 1875 :     // We merge a Unit Check in case the Y state is Not Ready.
; 1876 :     // But only when pUnitStat is still 0 or Unit Check or Busy (no Attn).
; 1877 :     // SENSE bit 1 for Intervention Required will be set as well.
; 1878 :     if( IS_CTCE_YNR( pDEVBLK -> ctceyState ) &&

  01324	48 8b 84 24 60
	01 00 00	 mov	 rax, QWORD PTR pDEVBLK$[rsp]
  0132c	8b 80 18 07 00
	00		 mov	 eax, DWORD PTR [rax+1816]
  01332	83 e0 01	 and	 eax, 1
  01335	85 c0		 test	 eax, eax
  01337	75 65		 jne	 SHORT $LN140@CTCE_Execu
  01339	48 8b 84 24 60
	01 00 00	 mov	 rax, QWORD PTR pDEVBLK$[rsp]
  01341	8b 80 74 07 00
	00		 mov	 eax, DWORD PTR [rax+1908]
  01347	c1 e8 03	 shr	 eax, 3
  0134a	83 e0 01	 and	 eax, 1
  0134d	85 c0		 test	 eax, eax
  0134f	75 4d		 jne	 SHORT $LN140@CTCE_Execu
  01351	48 8b 84 24 60
	01 00 00	 mov	 rax, QWORD PTR pDEVBLK$[rsp]
  01359	0f b6 80 36 07
	00 00		 movzx	 eax, BYTE PTR [rax+1846]
  01360	83 e0 07	 and	 eax, 7
  01363	83 f8 05	 cmp	 eax, 5
  01366	75 0d		 jne	 SHORT $LN141@CTCE_Execu
  01368	c7 84 24 f4 00
	00 00 04 00 00
	00		 mov	 DWORD PTR tv753[rsp], 4
  01373	eb 19		 jmp	 SHORT $LN142@CTCE_Execu
$LN141@CTCE_Execu:
  01375	48 8b 84 24 60
	01 00 00	 mov	 rax, QWORD PTR pDEVBLK$[rsp]
  0137d	0f b6 80 36 07
	00 00		 movzx	 eax, BYTE PTR [rax+1846]
  01384	83 e0 07	 and	 eax, 7
  01387	89 84 24 f4 00
	00 00		 mov	 DWORD PTR tv753[rsp], eax
$LN142@CTCE_Execu:
  0138e	8b 84 24 f4 00
	00 00		 mov	 eax, DWORD PTR tv753[rsp]
  01395	89 84 24 f8 00
	00 00		 mov	 DWORD PTR tv754[rsp], eax
  0139c	eb 19		 jmp	 SHORT $LN143@CTCE_Execu
$LN140@CTCE_Execu:
  0139e	48 8b 84 24 60
	01 00 00	 mov	 rax, QWORD PTR pDEVBLK$[rsp]
  013a6	0f b6 80 36 07
	00 00		 movzx	 eax, BYTE PTR [rax+1846]
  013ad	83 e0 07	 and	 eax, 7
  013b0	89 84 24 f8 00
	00 00		 mov	 DWORD PTR tv754[rsp], eax
$LN143@CTCE_Execu:
  013b7	83 bc 24 f8 00
	00 00 05	 cmp	 DWORD PTR tv754[rsp], 5
  013bf	75 43		 jne	 SHORT $LN40@CTCE_Execu
  013c1	48 8b 84 24 a8
	01 00 00	 mov	 rax, QWORD PTR pUnitStat$[rsp]
  013c9	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  013cc	83 e0 ed	 and	 eax, -19
  013cf	85 c0		 test	 eax, eax
  013d1	75 31		 jne	 SHORT $LN40@CTCE_Execu

; 1879 :         ( ( *pUnitStat & (~ ( CSW_BUSY | CSW_UC ) ) ) == 0 ) )
; 1880 :     {
; 1881 :         *pUnitStat |= CSW_UC;

  013d3	48 8b 84 24 a8
	01 00 00	 mov	 rax, QWORD PTR pUnitStat$[rsp]
  013db	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  013de	83 c8 02	 or	 eax, 2
  013e1	48 8b 8c 24 a8
	01 00 00	 mov	 rcx, QWORD PTR pUnitStat$[rsp]
  013e9	88 01		 mov	 BYTE PTR [rcx], al

; 1882 :         pDEVBLK->sense[0] = SENSE_IR;

  013eb	b8 01 00 00 00	 mov	 eax, 1
  013f0	48 6b c0 00	 imul	 rax, rax, 0
  013f4	48 8b 8c 24 60
	01 00 00	 mov	 rcx, QWORD PTR pDEVBLK$[rsp]
  013fc	c6 84 01 64 03
	00 00 40	 mov	 BYTE PTR [rcx+rax+868], 64 ; 00000040H
$LN40@CTCE_Execu:

; 1883 :     }
; 1884 : 
; 1885 :     // Produce a CTCE Trace logging if requested, noting that for the
; 1886 :     // IS_CTCE_WAIT cases such a logging is produced prior to the WAIT,
; 1887 :     // and CTCE_Recv will produce a logging for the matching command.
; 1888 :     if( ( CTCE_CCWTRACE( pDEVBLK ) ) &&

  01404	48 8b 84 24 60
	01 00 00	 mov	 rax, QWORD PTR pDEVBLK$[rsp]
  0140c	8b 80 f8 05 00
	00		 mov	 eax, DWORD PTR [rax+1528]
  01412	c1 e8 0f	 shr	 eax, 15
  01415	83 e0 01	 and	 eax, 1
  01418	85 c0		 test	 eax, eax
  0141a	75 67		 jne	 SHORT $LN42@CTCE_Execu
  0141c	48 8b 84 24 60
	01 00 00	 mov	 rax, QWORD PTR pDEVBLK$[rsp]
  01424	83 b8 68 07 00
	00 ff		 cmp	 DWORD PTR [rax+1896], -1
  0142b	74 56		 je	 SHORT $LN42@CTCE_Execu
  0142d	48 8b 84 24 60
	01 00 00	 mov	 rax, QWORD PTR pDEVBLK$[rsp]
  01435	83 b8 68 07 00
	00 00		 cmp	 DWORD PTR [rax+1896], 0
  0143c	0f 8e 26 01 00
	00		 jle	 $LN41@CTCE_Execu
  01442	48 8b 84 24 60
	01 00 00	 mov	 rax, QWORD PTR pDEVBLK$[rsp]
  0144a	8b 80 68 07 00
	00		 mov	 eax, DWORD PTR [rax+1896]
  01450	89 84 24 10 01
	00 00		 mov	 DWORD PTR tv778[rsp], eax
  01457	48 8b 84 24 60
	01 00 00	 mov	 rax, QWORD PTR pDEVBLK$[rsp]
  0145f	8b 80 68 07 00
	00		 mov	 eax, DWORD PTR [rax+1896]
  01465	ff c8		 dec	 eax
  01467	48 8b 8c 24 60
	01 00 00	 mov	 rcx, QWORD PTR pDEVBLK$[rsp]
  0146f	89 81 68 07 00
	00		 mov	 DWORD PTR [rcx+1896], eax
  01475	83 bc 24 10 01
	00 00 00	 cmp	 DWORD PTR tv778[rsp], 0
  0147d	0f 84 e5 00 00
	00		 je	 $LN41@CTCE_Execu
$LN42@CTCE_Execu:
  01483	0f b6 84 24 1e
	01 00 00	 movzx	 eax, BYTE PTR CTCE_Info$[rsp+6]
  0148b	83 e0 20	 and	 eax, 32			; 00000020H
  0148e	83 f8 20	 cmp	 eax, 32			; 00000020H
  01491	75 12		 jne	 SHORT $LN43@CTCE_Execu
  01493	8b 84 24 28 01
	00 00		 mov	 eax, DWORD PTR CTCE_Info$[rsp+16]
  0149a	83 e0 01	 and	 eax, 1
  0149d	85 c0		 test	 eax, eax
  0149f	0f 85 c3 00 00
	00		 jne	 $LN41@CTCE_Execu
$LN43@CTCE_Execu:

; 1889 :         ( !( IS_CTCE_WAIT( CTCE_Info.actions ) ) ||
; 1890 :           !CTCE_Info.sent ) )
; 1891 :     {
; 1892 :         CTCE_Trace( pDEVBLK, ( ( !IS_CTCE_SEND( CTCE_Info.actions ) ) ? CTCE_LCL :

  014a5	0f b6 84 24 1e
	01 00 00	 movzx	 eax, BYTE PTR CTCE_Info$[rsp+6]
  014ad	83 e0 40	 and	 eax, 64			; 00000040H
  014b0	83 f8 40	 cmp	 eax, 64			; 00000040H
  014b3	74 0d		 je	 SHORT $LN144@CTCE_Execu
  014b5	c7 84 24 fc 00
	00 00 01 00 00
	00		 mov	 DWORD PTR tv789[rsp], 1
  014c0	eb 0b		 jmp	 SHORT $LN145@CTCE_Execu
$LN144@CTCE_Execu:
  014c2	c7 84 24 fc 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv789[rsp], 0
$LN145@CTCE_Execu:
  014cd	83 bc 24 fc 00
	00 00 00	 cmp	 DWORD PTR tv789[rsp], 0
  014d5	74 0d		 je	 SHORT $LN150@CTCE_Execu
  014d7	c7 84 24 08 01
	00 00 00 00 00
	00		 mov	 DWORD PTR tv797[rsp], 0
  014e2	eb 60		 jmp	 SHORT $LN151@CTCE_Execu
$LN150@CTCE_Execu:
  014e4	8b 84 24 28 01
	00 00		 mov	 eax, DWORD PTR CTCE_Info$[rsp+16]
  014eb	83 e0 01	 and	 eax, 1
  014ee	85 c0		 test	 eax, eax
  014f0	74 0d		 je	 SHORT $LN148@CTCE_Execu
  014f2	c7 84 24 04 01
	00 00 01 00 00
	00		 mov	 DWORD PTR tv795[rsp], 1
  014fd	eb 37		 jmp	 SHORT $LN149@CTCE_Execu
$LN148@CTCE_Execu:
  014ff	48 8b 84 24 60
	01 00 00	 mov	 rax, QWORD PTR pDEVBLK$[rsp]
  01507	83 b8 3c 07 00
	00 00		 cmp	 DWORD PTR [rax+1852], 0
  0150e	7d 0d		 jge	 SHORT $LN146@CTCE_Execu
  01510	c7 84 24 00 01
	00 00 04 00 00
	00		 mov	 DWORD PTR tv793[rsp], 4
  0151b	eb 0b		 jmp	 SHORT $LN147@CTCE_Execu
$LN146@CTCE_Execu:
  0151d	c7 84 24 00 01
	00 00 03 00 00
	00		 mov	 DWORD PTR tv793[rsp], 3
$LN147@CTCE_Execu:
  01528	8b 84 24 00 01
	00 00		 mov	 eax, DWORD PTR tv793[rsp]
  0152f	89 84 24 04 01
	00 00		 mov	 DWORD PTR tv795[rsp], eax
$LN149@CTCE_Execu:
  01536	8b 84 24 04 01
	00 00		 mov	 eax, DWORD PTR tv795[rsp]
  0153d	89 84 24 08 01
	00 00		 mov	 DWORD PTR tv797[rsp], eax
$LN151@CTCE_Execu:
  01544	4c 8b 8c 24 a8
	01 00 00	 mov	 r9, QWORD PTR pUnitStat$[rsp]
  0154c	4c 8d 84 24 18
	01 00 00	 lea	 r8, QWORD PTR CTCE_Info$[rsp]
  01554	8b 94 24 08 01
	00 00		 mov	 edx, DWORD PTR tv797[rsp]
  0155b	48 8b 8c 24 60
	01 00 00	 mov	 rcx, QWORD PTR pDEVBLK$[rsp]
  01563	e8 00 00 00 00	 call	 CTCE_Trace
$LN41@CTCE_Execu:

; 1893 :             ( CTCE_Info.sent ? CTCE_SND : ( ( pDEVBLK->ctcefd < 0 ) ? CTCE_SND_NSR :
; 1894 :             CTCE_SND_NS ) ) ), &CTCE_Info, pUnitStat );
; 1895 :     }
; 1896 : 
; 1897 :     release_lock( &pDEVBLK->lock );

  01568	48 8b 84 24 60
	01 00 00	 mov	 rax, QWORD PTR pDEVBLK$[rsp]
  01570	48 83 c0 38	 add	 rax, 56			; 00000038H
  01574	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG169759
  0157b	48 8b c8	 mov	 rcx, rax
  0157e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_release_lock
$LN1@CTCE_Execu:

; 1898 : 
; 1899 : } // CTCE_ExecuteCCW

  01584	48 8b 8c 24 38
	01 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  0158c	48 33 cc	 xor	 rcx, rsp
  0158f	e8 00 00 00 00	 call	 __security_check_cookie
  01594	48 81 c4 48 01
	00 00		 add	 rsp, 328		; 00000148H
  0159b	5f		 pop	 rdi
  0159c	5e		 pop	 rsi
  0159d	c3		 ret	 0
  0159e	66 90		 npad	 2
$LN152@CTCE_Execu:
  015a0	00 00 00 00	 DD	 $LN24@CTCE_Execu
  015a4	00 00 00 00	 DD	 $LN25@CTCE_Execu
  015a8	00 00 00 00	 DD	 $LN26@CTCE_Execu
  015ac	00 00 00 00	 DD	 $LN27@CTCE_Execu
  015b0	00 00 00 00	 DD	 $LN33@CTCE_Execu
  015b4	00 00 00 00	 DD	 $LN38@CTCE_Execu
  015b8	00 00 00 00	 DD	 $LN28@CTCE_Execu
  015bc	00 00 00 00	 DD	 $LN29@CTCE_Execu
  015c0	00 00 00 00	 DD	 $LN30@CTCE_Execu
  015c4	00 00 00 00	 DD	 $LN31@CTCE_Execu
  015c8	00 00 00 00	 DD	 $LN34@CTCE_Execu
  015cc	00 00 00 00	 DD	 $LN35@CTCE_Execu
  015d0	00 00 00 00	 DD	 $LN36@CTCE_Execu
  015d4	00 00 00 00	 DD	 $LN38@CTCE_Execu
  015d8	00 00 00 00	 DD	 $LN38@CTCE_Execu
  015dc	00 00 00 00	 DD	 $LN32@CTCE_Execu
CTCE_ExecuteCCW ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\ctcadpt.c
_TEXT	SEGMENT
connfd$ = 96
servlen$ = 100
tv73 = 104
tv89 = 108
tv93 = 112
tv86 = 120
parm$ = 128
str$ = 160
__$ArrayPad$ = 240
argp$ = 288
CTCT_ListenThread PROC

; 1464 : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	56		 push	 rsi
  00006	57		 push	 rdi
  00007	48 81 ec 08 01
	00 00		 sub	 rsp, 264		; 00000108H
  0000e	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00015	48 33 c4	 xor	 rax, rsp
  00018	48 89 84 24 f0
	00 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 1465 :     int          connfd;
; 1466 :     socklen_t    servlen;
; 1467 :     char         str[80];
; 1468 :     CTCG_PARMBLK parm;
; 1469 : 
; 1470 :     // set up the parameters passed via create_thread
; 1471 :     parm = *((CTCG_PARMBLK*) argp);

  00020	48 8d 84 24 80
	00 00 00	 lea	 rax, QWORD PTR parm$[rsp]
  00028	48 8b f8	 mov	 rdi, rax
  0002b	48 8b b4 24 20
	01 00 00	 mov	 rsi, QWORD PTR argp$[rsp]
  00033	b9 20 00 00 00	 mov	 ecx, 32			; 00000020H
  00038	f3 a4		 rep movsb

; 1472 :     free( argp );

  0003a	48 8b 8c 24 20
	01 00 00	 mov	 rcx, QWORD PTR argp$[rsp]
  00042	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free
$LN2@CTCT_Liste:

; 1473 : 
; 1474 :     for( ; ; )
; 1475 :     {
; 1476 :         servlen = sizeof(parm.addr);

  00048	c7 44 24 64 10
	00 00 00	 mov	 DWORD PTR servlen$[rsp], 16

; 1477 : 
; 1478 :         // await a connection
; 1479 :         connfd = accept( parm.listenfd,

  00050	4c 8d 44 24 64	 lea	 r8, QWORD PTR servlen$[rsp]
  00055	48 8d 94 24 84
	00 00 00	 lea	 rdx, QWORD PTR parm$[rsp+4]
  0005d	8b 8c 24 80 00
	00 00		 mov	 ecx, DWORD PTR parm$[rsp]
  00064	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_accept
  0006a	89 44 24 60	 mov	 DWORD PTR connfd$[rsp], eax

; 1480 :                          (struct sockaddr *)&parm.addr,
; 1481 :                          &servlen );
; 1482 : 
; 1483 :         MSGBUF( str, "%s:%d",

  0006e	0f b7 8c 24 86
	00 00 00	 movzx	 ecx, WORD PTR parm$[rsp+6]
  00076	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ntohs
  0007c	0f b7 c0	 movzx	 eax, ax
  0007f	89 44 24 68	 mov	 DWORD PTR tv73[rsp], eax
  00083	8b 8c 24 88 00
	00 00		 mov	 ecx, DWORD PTR parm$[rsp+8]
  0008a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_inet_ntoa
  00090	8b 4c 24 68	 mov	 ecx, DWORD PTR tv73[rsp]
  00094	89 4c 24 20	 mov	 DWORD PTR [rsp+32], ecx
  00098	4c 8b c8	 mov	 r9, rax
  0009b	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG169652
  000a2	ba 50 00 00 00	 mov	 edx, 80			; 00000050H
  000a7	48 8d 8c 24 a0
	00 00 00	 lea	 rcx, QWORD PTR str$[rsp]
  000af	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_snprintf

; 1484 :                  inet_ntoa( parm.addr.sin_addr ),
; 1485 :                  ntohs( parm.addr.sin_port ) );
; 1486 : 
; 1487 :         if( strcmp( str, parm.dev->filename ) != 0 )

  000b5	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR parm$[rsp+24]
  000bd	48 05 a4 00 00
	00		 add	 rax, 164		; 000000a4H
  000c3	48 8b d0	 mov	 rdx, rax
  000c6	48 8d 8c 24 a0
	00 00 00	 lea	 rcx, QWORD PTR str$[rsp]
  000ce	e8 00 00 00 00	 call	 strcmp
  000d3	85 c0		 test	 eax, eax
  000d5	0f 84 af 00 00
	00		 je	 $LN5@CTCT_Liste

; 1488 :         {
; 1489 :             WRMSG(HHC00974, "E", SSID_TO_LCSS(parm.dev->ssid), parm.dev->devnum,

  000db	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR parm$[rsp+24]
  000e3	48 05 a4 00 00
	00		 add	 rax, 164		; 000000a4H
  000e9	48 89 44 24 78	 mov	 QWORD PTR tv86[rsp], rax
  000ee	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR parm$[rsp+24]
  000f6	0f b7 49 48	 movzx	 ecx, WORD PTR [rcx+72]
  000fa	89 4c 24 6c	 mov	 DWORD PTR tv89[rsp], ecx
  000fe	48 8b 94 24 98
	00 00 00	 mov	 rdx, QWORD PTR parm$[rsp+24]
  00106	0f b7 52 44	 movzx	 edx, WORD PTR [rdx+68]
  0010a	d1 fa		 sar	 edx, 1
  0010c	89 54 24 70	 mov	 DWORD PTR tv93[rsp], edx
  00110	b9 01 00 00 00	 mov	 ecx, 1
  00115	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  0011b	48 8d 8c 24 a0
	00 00 00	 lea	 rcx, QWORD PTR str$[rsp]
  00123	48 89 4c 24 50	 mov	 QWORD PTR [rsp+80], rcx
  00128	48 8b 4c 24 78	 mov	 rcx, QWORD PTR tv86[rsp]
  0012d	48 89 4c 24 48	 mov	 QWORD PTR [rsp+72], rcx
  00132	8b 4c 24 6c	 mov	 ecx, DWORD PTR tv89[rsp]
  00136	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  0013a	8b 4c 24 70	 mov	 ecx, DWORD PTR tv93[rsp]
  0013e	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  00142	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169655
  00149	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  0014e	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169656
  00155	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  0015a	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  0015f	41 b9 03 00 00
	00		 mov	 r9d, 3
  00165	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG169657
  0016c	ba d2 05 00 00	 mov	 edx, 1490		; 000005d2H
  00171	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169658
  00178	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 1490 :                     parm.dev->filename, str);
; 1491 :             close_socket( connfd );

  0017e	8b 4c 24 60	 mov	 ecx, DWORD PTR connfd$[rsp]
  00182	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_close_socket

; 1492 :         }

  00188	eb 12		 jmp	 SHORT $LN6@CTCT_Liste
$LN5@CTCT_Liste:

; 1493 :         else
; 1494 :         {
; 1495 :             parm.dev->fd = connfd;

  0018a	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR parm$[rsp+24]
  00192	8b 4c 24 60	 mov	 ecx, DWORD PTR connfd$[rsp]
  00196	89 88 ac 01 00
	00		 mov	 DWORD PTR [rax+428], ecx
$LN6@CTCT_Liste:

; 1496 :         }
; 1497 : 
; 1498 :         // Ok, so having done that we're going to loop back to the
; 1499 :         // accept().  This was meant to handle the connection failing
; 1500 :         // at the other end; this end will be ready to accept another
; 1501 :         // connection.  Although this will happen, I'm sure you can
; 1502 :         // see the possibility for bad things to occur (eg if another
; 1503 :         // Hercules tries to connect).  This will also be fixed RSN.
; 1504 :     }

  0019c	e9 a7 fe ff ff	 jmp	 $LN2@CTCT_Liste
$LN7@CTCT_Liste:

; 1505 : 
; 1506 :     UNREACHABLE_CODE( return NULL );
; 1507 : }

  001a1	48 8b 8c 24 f0
	00 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  001a9	48 33 cc	 xor	 rcx, rsp
  001ac	e8 00 00 00 00	 call	 __security_check_cookie
  001b1	48 81 c4 08 01
	00 00		 add	 rsp, 264		; 00000108H
  001b8	5f		 pop	 rdi
  001b9	5e		 pop	 rsi
  001ba	c3		 ret	 0
CTCT_ListenThread ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\ctcadpt.c
_TEXT	SEGMENT
sSegLen$ = 96
i$ = 100
sOffset$ = 104
iPos$ = 108
sDataLen$ = 112
tv68 = 116
tv72 = 120
iStackCmd$ = 124
tv154 = 128
tv158 = 132
tv184 = 136
tv188 = 140
tv219 = 144
tv222 = 148
tv226 = 152
tv250 = 156
tv254 = 160
rc$ = 164
tv289 = 168
tv293 = 172
pSegment$ = 176
$T1 = 184
pFrame$ = 192
tv247 = 200
tv282 = 208
tv286 = 216
szStackID$ = 224
__$ArrayPad$ = 264
pDEVBLK$ = 288
sCount$ = 296
pIOBuf$ = 304
pUnitStat$ = 312
pResidual$ = 320
CTCT_Write PROC

; 1205 : {

  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  0000e	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00013	48 81 ec 18 01
	00 00		 sub	 rsp, 280		; 00000118H
  0001a	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00021	48 33 c4	 xor	 rax, rsp
  00024	48 89 84 24 08
	01 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 1206 :     PCTCIHDR   pFrame;                  // -> Frame header
; 1207 :     PCTCISEG   pSegment;                // -> Segment in buffer
; 1208 :     U16        sOffset;                 // Offset of next frame
; 1209 :     U16        sSegLen;                 // Current segment length
; 1210 :     U16        sDataLen;                // Length of IP Frame data
; 1211 :     int        iPos;                    // Offset into buffer
; 1212 :     U16        i;                       // Array subscript
; 1213 :     int        rc;                      // Return code
; 1214 :     BYTE       szStackID[33];           // VSE IP stack identity
; 1215 :     U32        iStackCmd;               // VSE IP stack command
; 1216 : 
; 1217 :     // Check that CCW count is sufficient to contain block header
; 1218 :     if( sCount < sizeof( CTCIHDR ) )

  0002c	8b 84 24 28 01
	00 00		 mov	 eax, DWORD PTR sCount$[rsp]
  00033	48 83 f8 02	 cmp	 rax, 2
  00037	0f 83 ad 00 00
	00		 jae	 $LN8@CTCT_Write

; 1219 :     {
; 1220 :         WRMSG(HHC00906, "E", SSID_TO_LCSS(pDEVBLK->ssid), pDEVBLK->devnum, sCount );

  0003d	48 8b 84 24 20
	01 00 00	 mov	 rax, QWORD PTR pDEVBLK$[rsp]
  00045	0f b7 40 48	 movzx	 eax, WORD PTR [rax+72]
  00049	89 44 24 74	 mov	 DWORD PTR tv68[rsp], eax
  0004d	48 8b 8c 24 20
	01 00 00	 mov	 rcx, QWORD PTR pDEVBLK$[rsp]
  00055	0f b7 49 44	 movzx	 ecx, WORD PTR [rcx+68]
  00059	d1 f9		 sar	 ecx, 1
  0005b	89 4c 24 78	 mov	 DWORD PTR tv72[rsp], ecx
  0005f	b9 01 00 00 00	 mov	 ecx, 1
  00064	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  0006a	8b 8c 24 28 01
	00 00		 mov	 ecx, DWORD PTR sCount$[rsp]
  00071	89 4c 24 48	 mov	 DWORD PTR [rsp+72], ecx
  00075	8b 4c 24 74	 mov	 ecx, DWORD PTR tv68[rsp]
  00079	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  0007d	8b 4c 24 78	 mov	 ecx, DWORD PTR tv72[rsp]
  00081	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  00085	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169537
  0008c	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  00091	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169538
  00098	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  0009d	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  000a2	41 b9 03 00 00
	00		 mov	 r9d, 3
  000a8	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG169539
  000af	ba c4 04 00 00	 mov	 edx, 1220		; 000004c4H
  000b4	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169540
  000bb	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 1221 : 
; 1222 :         pDEVBLK->sense[0] = SENSE_DC;

  000c1	b8 01 00 00 00	 mov	 eax, 1
  000c6	48 6b c0 00	 imul	 rax, rax, 0
  000ca	48 8b 8c 24 20
	01 00 00	 mov	 rcx, QWORD PTR pDEVBLK$[rsp]
  000d2	c6 84 01 64 03
	00 00 08	 mov	 BYTE PTR [rcx+rax+868], 8

; 1223 :         *pUnitStat        = CSW_CE | CSW_DE | CSW_UC;

  000da	48 8b 84 24 38
	01 00 00	 mov	 rax, QWORD PTR pUnitStat$[rsp]
  000e2	c6 00 0e	 mov	 BYTE PTR [rax], 14

; 1224 :         return;

  000e5	e9 e2 06 00 00	 jmp	 $LN1@CTCT_Write
$LN8@CTCT_Write:

; 1225 :     }
; 1226 : 
; 1227 :     // Fix-up frame pointer
; 1228 :     pFrame = (PCTCIHDR)pIOBuf;

  000ea	48 8b 84 24 30
	01 00 00	 mov	 rax, QWORD PTR pIOBuf$[rsp]
  000f2	48 89 84 24 c0
	00 00 00	 mov	 QWORD PTR pFrame$[rsp], rax

; 1229 : 
; 1230 :     // Extract the frame length from the header
; 1231 :     FETCH_HW( sOffset, pFrame->hwOffset );

  000fa	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR pFrame$[rsp]
  00102	48 8b c8	 mov	 rcx, rax
  00105	e8 00 00 00 00	 call	 fetch_hw_noswap
  0010a	0f b7 c8	 movzx	 ecx, ax
  0010d	e8 00 00 00 00	 call	 _byteswap_ushort
  00112	66 89 44 24 68	 mov	 WORD PTR sOffset$[rsp], ax

; 1232 : 
; 1233 : 
; 1234 :     // Check for special VSE TCP/IP stack command packet
; 1235 :     if( sOffset == 0 && sCount == 40 )

  00117	0f b7 44 24 68	 movzx	 eax, WORD PTR sOffset$[rsp]
  0011c	85 c0		 test	 eax, eax
  0011e	0f 85 7d 01 00
	00		 jne	 $LN9@CTCT_Write
  00124	83 bc 24 28 01
	00 00 28	 cmp	 DWORD PTR sCount$[rsp], 40 ; 00000028H
  0012c	0f 85 6f 01 00
	00		 jne	 $LN9@CTCT_Write

; 1236 :     {
; 1237 :         // Extract the 32-byte stack identity string
; 1238 :         for( i = 0;

  00132	33 c0		 xor	 eax, eax
  00134	66 89 44 24 64	 mov	 WORD PTR i$[rsp], ax
  00139	eb 0d		 jmp	 SHORT $LN4@CTCT_Write
$LN2@CTCT_Write:

; 1240 :              i++)

  0013b	0f b7 44 24 64	 movzx	 eax, WORD PTR i$[rsp]
  00140	66 ff c0	 inc	 ax
  00143	66 89 44 24 64	 mov	 WORD PTR i$[rsp], ax
$LN4@CTCT_Write:

; 1239 :              i < sizeof( szStackID ) - 1 && i < sCount - 4;

  00148	0f b7 44 24 64	 movzx	 eax, WORD PTR i$[rsp]
  0014d	48 83 f8 20	 cmp	 rax, 32			; 00000020H
  00151	73 3d		 jae	 SHORT $LN3@CTCT_Write
  00153	0f b7 44 24 64	 movzx	 eax, WORD PTR i$[rsp]
  00158	8b 8c 24 28 01
	00 00		 mov	 ecx, DWORD PTR sCount$[rsp]
  0015f	83 e9 04	 sub	 ecx, 4
  00162	3b c1		 cmp	 eax, ecx
  00164	73 2a		 jae	 SHORT $LN3@CTCT_Write

; 1241 :             szStackID[i] = guest_to_host( pIOBuf[i+4] );

  00166	0f b7 44 24 64	 movzx	 eax, WORD PTR i$[rsp]
  0016b	83 c0 04	 add	 eax, 4
  0016e	48 98		 cdqe
  00170	48 8b 8c 24 30
	01 00 00	 mov	 rcx, QWORD PTR pIOBuf$[rsp]
  00178	0f b6 0c 01	 movzx	 ecx, BYTE PTR [rcx+rax]
  0017c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_guest_to_host
  00182	0f b7 4c 24 64	 movzx	 ecx, WORD PTR i$[rsp]
  00187	88 84 0c e0 00
	00 00		 mov	 BYTE PTR szStackID$[rsp+rcx], al
  0018e	eb ab		 jmp	 SHORT $LN2@CTCT_Write
$LN3@CTCT_Write:

; 1242 : 
; 1243 :         szStackID[i] = '\0';

  00190	0f b7 44 24 64	 movzx	 eax, WORD PTR i$[rsp]
  00195	48 89 84 24 b8
	00 00 00	 mov	 QWORD PTR $T1[rsp], rax
  0019d	48 83 bc 24 b8
	00 00 00 21	 cmp	 QWORD PTR $T1[rsp], 33	; 00000021H
  001a6	73 02		 jae	 SHORT $LN19@CTCT_Write
  001a8	eb 05		 jmp	 SHORT $LN20@CTCT_Write
$LN19@CTCT_Write:
  001aa	e8 00 00 00 00	 call	 __report_rangecheckfailure
$LN20@CTCT_Write:
  001af	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR $T1[rsp]
  001b7	c6 84 04 e0 00
	00 00 00	 mov	 BYTE PTR szStackID$[rsp+rax], 0

; 1244 : 
; 1245 :         // Extract the stack command word
; 1246 :         FETCH_FW( iStackCmd, *((FWORD*)&pIOBuf[36]) );

  001bf	b8 01 00 00 00	 mov	 eax, 1
  001c4	48 6b c0 24	 imul	 rax, rax, 36		; 00000024H
  001c8	48 8b 8c 24 30
	01 00 00	 mov	 rcx, QWORD PTR pIOBuf$[rsp]
  001d0	48 03 c8	 add	 rcx, rax
  001d3	48 8b c1	 mov	 rax, rcx
  001d6	48 8b c8	 mov	 rcx, rax
  001d9	e8 00 00 00 00	 call	 fetch_fw_noswap
  001de	8b c8		 mov	 ecx, eax
  001e0	e8 00 00 00 00	 call	 _byteswap_ulong
  001e5	89 44 24 7c	 mov	 DWORD PTR iStackCmd$[rsp], eax

; 1247 : 
; 1248 :         // Display stack command and discard the packet
; 1249 :         WRMSG(HHC00907, "I", SSID_TO_LCSS(pDEVBLK->ssid), pDEVBLK->devnum, szStackID, iStackCmd );

  001e9	48 8b 84 24 20
	01 00 00	 mov	 rax, QWORD PTR pDEVBLK$[rsp]
  001f1	0f b7 40 48	 movzx	 eax, WORD PTR [rax+72]
  001f5	89 84 24 80 00
	00 00		 mov	 DWORD PTR tv154[rsp], eax
  001fc	48 8b 8c 24 20
	01 00 00	 mov	 rcx, QWORD PTR pDEVBLK$[rsp]
  00204	0f b7 49 44	 movzx	 ecx, WORD PTR [rcx+68]
  00208	d1 f9		 sar	 ecx, 1
  0020a	89 8c 24 84 00
	00 00		 mov	 DWORD PTR tv158[rsp], ecx
  00211	b9 01 00 00 00	 mov	 ecx, 1
  00216	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  0021c	8b 4c 24 7c	 mov	 ecx, DWORD PTR iStackCmd$[rsp]
  00220	89 4c 24 50	 mov	 DWORD PTR [rsp+80], ecx
  00224	48 8d 8c 24 e0
	00 00 00	 lea	 rcx, QWORD PTR szStackID$[rsp]
  0022c	48 89 4c 24 48	 mov	 QWORD PTR [rsp+72], rcx
  00231	8b 8c 24 80 00
	00 00		 mov	 ecx, DWORD PTR tv154[rsp]
  00238	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  0023c	8b 8c 24 84 00
	00 00		 mov	 ecx, DWORD PTR tv158[rsp]
  00243	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  00247	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169542
  0024e	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  00253	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169543
  0025a	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  0025f	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00264	41 b9 03 00 00
	00		 mov	 r9d, 3
  0026a	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG169544
  00271	ba e1 04 00 00	 mov	 edx, 1249		; 000004e1H
  00276	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169545
  0027d	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 1250 : 
; 1251 :         *pUnitStat = CSW_CE | CSW_DE;

  00283	48 8b 84 24 38
	01 00 00	 mov	 rax, QWORD PTR pUnitStat$[rsp]
  0028b	c6 00 0c	 mov	 BYTE PTR [rax], 12

; 1252 :         *pResidual = 0;

  0028e	48 8b 84 24 40
	01 00 00	 mov	 rax, QWORD PTR pResidual$[rsp]
  00296	c7 00 00 00 00
	00		 mov	 DWORD PTR [rax], 0

; 1253 :         return;

  0029c	e9 2b 05 00 00	 jmp	 $LN1@CTCT_Write
$LN9@CTCT_Write:

; 1254 :     }
; 1255 : 
; 1256 :     // Check for special L/390 initialization packet
; 1257 :     if( sOffset == 0 )

  002a1	0f b7 44 24 68	 movzx	 eax, WORD PTR sOffset$[rsp]
  002a6	85 c0		 test	 eax, eax
  002a8	75 1e		 jne	 SHORT $LN10@CTCT_Write

; 1258 :     {
; 1259 :         // Return normal status and discard the packet
; 1260 :         *pUnitStat = CSW_CE | CSW_DE;

  002aa	48 8b 84 24 38
	01 00 00	 mov	 rax, QWORD PTR pUnitStat$[rsp]
  002b2	c6 00 0c	 mov	 BYTE PTR [rax], 12

; 1261 :         *pResidual = 0;

  002b5	48 8b 84 24 40
	01 00 00	 mov	 rax, QWORD PTR pResidual$[rsp]
  002bd	c7 00 00 00 00
	00		 mov	 DWORD PTR [rax], 0

; 1262 :         return;

  002c3	e9 04 05 00 00	 jmp	 $LN1@CTCT_Write
$LN10@CTCT_Write:

; 1263 :     }
; 1264 : 
; 1265 :     // Adjust the residual byte count
; 1266 :     *pResidual -= sizeof( CTCIHDR );

  002c8	48 8b 84 24 40
	01 00 00	 mov	 rax, QWORD PTR pResidual$[rsp]
  002d0	8b 00		 mov	 eax, DWORD PTR [rax]
  002d2	48 83 e8 02	 sub	 rax, 2
  002d6	48 8b 8c 24 40
	01 00 00	 mov	 rcx, QWORD PTR pResidual$[rsp]
  002de	89 01		 mov	 DWORD PTR [rcx], eax

; 1267 : 
; 1268 :     // Process each segment in the buffer
; 1269 :     for( iPos  = sizeof( CTCIHDR );

  002e0	c7 44 24 6c 02
	00 00 00	 mov	 DWORD PTR iPos$[rsp], 2
  002e8	eb 11		 jmp	 SHORT $LN7@CTCT_Write
$LN5@CTCT_Write:

; 1271 :          iPos += sSegLen )

  002ea	0f b7 44 24 60	 movzx	 eax, WORD PTR sSegLen$[rsp]
  002ef	8b 4c 24 6c	 mov	 ecx, DWORD PTR iPos$[rsp]
  002f3	03 c8		 add	 ecx, eax
  002f5	8b c1		 mov	 eax, ecx
  002f7	89 44 24 6c	 mov	 DWORD PTR iPos$[rsp], eax
$LN7@CTCT_Write:

; 1270 :          iPos  < sOffset;

  002fb	0f b7 44 24 68	 movzx	 eax, WORD PTR sOffset$[rsp]
  00300	39 44 24 6c	 cmp	 DWORD PTR iPos$[rsp], eax
  00304	0f 8d a9 04 00
	00		 jge	 $LN6@CTCT_Write

; 1272 :     {
; 1273 :         // Check that the segment is fully contained within the block
; 1274 :         if( iPos + sizeof( CTCISEG ) > sOffset )

  0030a	48 63 44 24 6c	 movsxd	 rax, DWORD PTR iPos$[rsp]
  0030f	48 83 c0 06	 add	 rax, 6
  00313	0f b7 4c 24 68	 movzx	 ecx, WORD PTR sOffset$[rsp]
  00318	48 3b c1	 cmp	 rax, rcx
  0031b	0f 86 b6 00 00
	00		 jbe	 $LN11@CTCT_Write

; 1275 :         {
; 1276 :             WRMSG(HHC00908, "E", SSID_TO_LCSS(pDEVBLK->ssid), pDEVBLK->devnum, iPos );

  00321	48 8b 84 24 20
	01 00 00	 mov	 rax, QWORD PTR pDEVBLK$[rsp]
  00329	0f b7 40 48	 movzx	 eax, WORD PTR [rax+72]
  0032d	89 84 24 88 00
	00 00		 mov	 DWORD PTR tv184[rsp], eax
  00334	48 8b 8c 24 20
	01 00 00	 mov	 rcx, QWORD PTR pDEVBLK$[rsp]
  0033c	0f b7 49 44	 movzx	 ecx, WORD PTR [rcx+68]
  00340	d1 f9		 sar	 ecx, 1
  00342	89 8c 24 8c 00
	00 00		 mov	 DWORD PTR tv188[rsp], ecx
  00349	b9 01 00 00 00	 mov	 ecx, 1
  0034e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  00354	8b 4c 24 6c	 mov	 ecx, DWORD PTR iPos$[rsp]
  00358	89 4c 24 48	 mov	 DWORD PTR [rsp+72], ecx
  0035c	8b 8c 24 88 00
	00 00		 mov	 ecx, DWORD PTR tv184[rsp]
  00363	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  00367	8b 8c 24 8c 00
	00 00		 mov	 ecx, DWORD PTR tv188[rsp]
  0036e	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  00372	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169548
  00379	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  0037e	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169549
  00385	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  0038a	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  0038f	41 b9 03 00 00
	00		 mov	 r9d, 3
  00395	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG169550
  0039c	ba fc 04 00 00	 mov	 edx, 1276		; 000004fcH
  003a1	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169551
  003a8	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 1277 : 
; 1278 :             pDEVBLK->sense[0] = SENSE_DC;

  003ae	b8 01 00 00 00	 mov	 eax, 1
  003b3	48 6b c0 00	 imul	 rax, rax, 0
  003b7	48 8b 8c 24 20
	01 00 00	 mov	 rcx, QWORD PTR pDEVBLK$[rsp]
  003bf	c6 84 01 64 03
	00 00 08	 mov	 BYTE PTR [rcx+rax+868], 8

; 1279 :             *pUnitStat        = CSW_CE | CSW_DE | CSW_UC;

  003c7	48 8b 84 24 38
	01 00 00	 mov	 rax, QWORD PTR pUnitStat$[rsp]
  003cf	c6 00 0e	 mov	 BYTE PTR [rax], 14

; 1280 :             return;

  003d2	e9 f5 03 00 00	 jmp	 $LN1@CTCT_Write
$LN11@CTCT_Write:

; 1281 :         }
; 1282 : 
; 1283 :         // Fix-up segment header in the I/O buffer
; 1284 :         pSegment = (PCTCISEG)(pIOBuf + iPos);

  003d7	48 63 44 24 6c	 movsxd	 rax, DWORD PTR iPos$[rsp]
  003dc	48 8b 8c 24 30
	01 00 00	 mov	 rcx, QWORD PTR pIOBuf$[rsp]
  003e4	48 03 c8	 add	 rcx, rax
  003e7	48 8b c1	 mov	 rax, rcx
  003ea	48 89 84 24 b0
	00 00 00	 mov	 QWORD PTR pSegment$[rsp], rax

; 1285 : 
; 1286 :         // Extract the segment length from the segment header
; 1287 :         FETCH_HW( sSegLen, pSegment->hwLength );

  003f2	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR pSegment$[rsp]
  003fa	48 8b c8	 mov	 rcx, rax
  003fd	e8 00 00 00 00	 call	 fetch_hw_noswap
  00402	0f b7 c8	 movzx	 ecx, ax
  00405	e8 00 00 00 00	 call	 _byteswap_ushort
  0040a	66 89 44 24 60	 mov	 WORD PTR sSegLen$[rsp], ax

; 1288 : 
; 1289 :         // Check that the segment length is valid
; 1290 :         if( ( sSegLen        < sizeof( CTCISEG ) ) ||
; 1291 :             ( (U32)iPos + sSegLen > sOffset      ) ||

  0040f	0f b7 44 24 60	 movzx	 eax, WORD PTR sSegLen$[rsp]
  00414	48 83 f8 06	 cmp	 rax, 6
  00418	72 30		 jb	 SHORT $LN13@CTCT_Write
  0041a	0f b7 44 24 60	 movzx	 eax, WORD PTR sSegLen$[rsp]
  0041f	8b 4c 24 6c	 mov	 ecx, DWORD PTR iPos$[rsp]
  00423	03 c8		 add	 ecx, eax
  00425	8b c1		 mov	 eax, ecx
  00427	0f b7 4c 24 68	 movzx	 ecx, WORD PTR sOffset$[rsp]
  0042c	3b c1		 cmp	 eax, ecx
  0042e	77 1a		 ja	 SHORT $LN13@CTCT_Write
  00430	0f b7 44 24 60	 movzx	 eax, WORD PTR sSegLen$[rsp]
  00435	8b 4c 24 6c	 mov	 ecx, DWORD PTR iPos$[rsp]
  00439	03 c8		 add	 ecx, eax
  0043b	8b c1		 mov	 eax, ecx
  0043d	3b 84 24 28 01
	00 00		 cmp	 eax, DWORD PTR sCount$[rsp]
  00444	0f 86 cd 00 00
	00		 jbe	 $LN12@CTCT_Write
$LN13@CTCT_Write:

; 1292 :             ( (U32)iPos + sSegLen > sCount       ) )
; 1293 :         {
; 1294 :             WRMSG(HHC00909, "E", SSID_TO_LCSS(pDEVBLK->ssid), pDEVBLK->devnum, sSegLen, iPos );

  0044a	0f b7 44 24 60	 movzx	 eax, WORD PTR sSegLen$[rsp]
  0044f	89 84 24 90 00
	00 00		 mov	 DWORD PTR tv219[rsp], eax
  00456	48 8b 8c 24 20
	01 00 00	 mov	 rcx, QWORD PTR pDEVBLK$[rsp]
  0045e	0f b7 49 48	 movzx	 ecx, WORD PTR [rcx+72]
  00462	89 8c 24 94 00
	00 00		 mov	 DWORD PTR tv222[rsp], ecx
  00469	48 8b 94 24 20
	01 00 00	 mov	 rdx, QWORD PTR pDEVBLK$[rsp]
  00471	0f b7 52 44	 movzx	 edx, WORD PTR [rdx+68]
  00475	d1 fa		 sar	 edx, 1
  00477	89 94 24 98 00
	00 00		 mov	 DWORD PTR tv226[rsp], edx
  0047e	b9 01 00 00 00	 mov	 ecx, 1
  00483	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  00489	8b 4c 24 6c	 mov	 ecx, DWORD PTR iPos$[rsp]
  0048d	89 4c 24 50	 mov	 DWORD PTR [rsp+80], ecx
  00491	8b 8c 24 90 00
	00 00		 mov	 ecx, DWORD PTR tv219[rsp]
  00498	89 4c 24 48	 mov	 DWORD PTR [rsp+72], ecx
  0049c	8b 8c 24 94 00
	00 00		 mov	 ecx, DWORD PTR tv222[rsp]
  004a3	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  004a7	8b 8c 24 98 00
	00 00		 mov	 ecx, DWORD PTR tv226[rsp]
  004ae	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  004b2	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169554
  004b9	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  004be	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169555
  004c5	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  004ca	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  004cf	41 b9 03 00 00
	00		 mov	 r9d, 3
  004d5	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG169556
  004dc	ba 0e 05 00 00	 mov	 edx, 1294		; 0000050eH
  004e1	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169557
  004e8	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 1295 : 
; 1296 :             pDEVBLK->sense[0] = SENSE_DC;

  004ee	b8 01 00 00 00	 mov	 eax, 1
  004f3	48 6b c0 00	 imul	 rax, rax, 0
  004f7	48 8b 8c 24 20
	01 00 00	 mov	 rcx, QWORD PTR pDEVBLK$[rsp]
  004ff	c6 84 01 64 03
	00 00 08	 mov	 BYTE PTR [rcx+rax+868], 8

; 1297 :             *pUnitStat        = CSW_CE | CSW_DE | CSW_UC;

  00507	48 8b 84 24 38
	01 00 00	 mov	 rax, QWORD PTR pUnitStat$[rsp]
  0050f	c6 00 0e	 mov	 BYTE PTR [rax], 14

; 1298 :             return;

  00512	e9 b5 02 00 00	 jmp	 $LN1@CTCT_Write
$LN12@CTCT_Write:

; 1299 :         }
; 1300 : 
; 1301 :         // Calculate length of IP frame data
; 1302 :         sDataLen = sSegLen - sizeof( CTCISEG );

  00517	0f b7 44 24 60	 movzx	 eax, WORD PTR sSegLen$[rsp]
  0051c	48 83 e8 06	 sub	 rax, 6
  00520	66 89 44 24 70	 mov	 WORD PTR sDataLen$[rsp], ax

; 1303 : 
; 1304 :         // Trace the IP packet before sending
; 1305 :         if (pDEVBLK->ccwtrace)

  00525	48 8b 84 24 20
	01 00 00	 mov	 rax, QWORD PTR pDEVBLK$[rsp]
  0052d	8b 80 f8 05 00
	00		 mov	 eax, DWORD PTR [rax+1528]
  00533	c1 e8 0f	 shr	 eax, 15
  00536	83 e0 01	 and	 eax, 1
  00539	85 c0		 test	 eax, eax
  0053b	0f 84 db 00 00
	00		 je	 $LN14@CTCT_Write

; 1306 :         {
; 1307 :             WRMSG(HHC00934, "I", SSID_TO_LCSS(pDEVBLK->ssid), pDEVBLK->devnum, pDEVBLK->filename );

  00541	48 8b 84 24 20
	01 00 00	 mov	 rax, QWORD PTR pDEVBLK$[rsp]
  00549	48 05 a4 00 00
	00		 add	 rax, 164		; 000000a4H
  0054f	48 89 84 24 c8
	00 00 00	 mov	 QWORD PTR tv247[rsp], rax
  00557	48 8b 8c 24 20
	01 00 00	 mov	 rcx, QWORD PTR pDEVBLK$[rsp]
  0055f	0f b7 49 48	 movzx	 ecx, WORD PTR [rcx+72]
  00563	89 8c 24 9c 00
	00 00		 mov	 DWORD PTR tv250[rsp], ecx
  0056a	48 8b 94 24 20
	01 00 00	 mov	 rdx, QWORD PTR pDEVBLK$[rsp]
  00572	0f b7 52 44	 movzx	 edx, WORD PTR [rdx+68]
  00576	d1 fa		 sar	 edx, 1
  00578	89 94 24 a0 00
	00 00		 mov	 DWORD PTR tv254[rsp], edx
  0057f	b9 01 00 00 00	 mov	 ecx, 1
  00584	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  0058a	48 8b 8c 24 c8
	00 00 00	 mov	 rcx, QWORD PTR tv247[rsp]
  00592	48 89 4c 24 48	 mov	 QWORD PTR [rsp+72], rcx
  00597	8b 8c 24 9c 00
	00 00		 mov	 ecx, DWORD PTR tv250[rsp]
  0059e	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  005a2	8b 8c 24 a0 00
	00 00		 mov	 ecx, DWORD PTR tv254[rsp]
  005a9	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  005ad	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169559
  005b4	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  005b9	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169560
  005c0	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  005c5	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  005ca	41 b9 03 00 00
	00		 mov	 r9d, 3
  005d0	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG169561
  005d7	ba 1b 05 00 00	 mov	 edx, 1307		; 0000051bH
  005dc	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169562
  005e3	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 1308 :             if( pDEVBLK->ccwtrace )

  005e9	48 8b 84 24 20
	01 00 00	 mov	 rax, QWORD PTR pDEVBLK$[rsp]
  005f1	8b 80 f8 05 00
	00		 mov	 eax, DWORD PTR [rax+1528]
  005f7	c1 e8 0f	 shr	 eax, 15
  005fa	83 e0 01	 and	 eax, 1
  005fd	85 c0		 test	 eax, eax
  005ff	74 1b		 je	 SHORT $LN15@CTCT_Write

; 1309 :                 packet_trace( pSegment->bData, sDataLen, '>' );

  00601	0f b7 44 24 70	 movzx	 eax, WORD PTR sDataLen$[rsp]
  00606	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR pSegment$[rsp]
  0060e	48 83 c1 06	 add	 rcx, 6
  00612	41 b0 3e	 mov	 r8b, 62			; 0000003eH
  00615	8b d0		 mov	 edx, eax
  00617	e8 00 00 00 00	 call	 packet_trace
$LN15@CTCT_Write:
$LN14@CTCT_Write:

; 1310 :         }
; 1311 : 
; 1312 :         // Write the IP packet
; 1313 :         rc = write_socket( pDEVBLK->fd, pSegment->bData, sDataLen );

  0061c	0f b7 44 24 70	 movzx	 eax, WORD PTR sDataLen$[rsp]
  00621	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR pSegment$[rsp]
  00629	48 83 c1 06	 add	 rcx, 6
  0062d	44 8b c0	 mov	 r8d, eax
  00630	48 8b d1	 mov	 rdx, rcx
  00633	48 8b 84 24 20
	01 00 00	 mov	 rax, QWORD PTR pDEVBLK$[rsp]
  0063b	8b 88 ac 01 00
	00		 mov	 ecx, DWORD PTR [rax+428]
  00641	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_write_socket
  00647	89 84 24 a4 00
	00 00		 mov	 DWORD PTR rc$[rsp], eax

; 1314 : 
; 1315 :         if( rc < 0 )

  0064e	83 bc 24 a4 00
	00 00 00	 cmp	 DWORD PTR rc$[rsp], 0
  00656	0f 8d f5 00 00
	00		 jge	 $LN16@CTCT_Write

; 1316 :         {
; 1317 :             WRMSG(HHC00936, "E", SSID_TO_LCSS(pDEVBLK->ssid), pDEVBLK->devnum, pDEVBLK->filename,

  0065c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_WSAGetLastError
  00662	8b c8		 mov	 ecx, eax
  00664	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_strerror
  0066a	48 89 84 24 d0
	00 00 00	 mov	 QWORD PTR tv282[rsp], rax
  00672	48 8b 8c 24 20
	01 00 00	 mov	 rcx, QWORD PTR pDEVBLK$[rsp]
  0067a	48 81 c1 a4 00
	00 00		 add	 rcx, 164		; 000000a4H
  00681	48 89 8c 24 d8
	00 00 00	 mov	 QWORD PTR tv286[rsp], rcx
  00689	48 8b 94 24 20
	01 00 00	 mov	 rdx, QWORD PTR pDEVBLK$[rsp]
  00691	0f b7 52 48	 movzx	 edx, WORD PTR [rdx+72]
  00695	89 94 24 a8 00
	00 00		 mov	 DWORD PTR tv289[rsp], edx
  0069c	4c 8b 84 24 20
	01 00 00	 mov	 r8, QWORD PTR pDEVBLK$[rsp]
  006a4	45 0f b7 40 44	 movzx	 r8d, WORD PTR [r8+68]
  006a9	41 d1 f8	 sar	 r8d, 1
  006ac	44 89 84 24 ac
	00 00 00	 mov	 DWORD PTR tv293[rsp], r8d
  006b4	b9 01 00 00 00	 mov	 ecx, 1
  006b9	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  006bf	48 8b 8c 24 d0
	00 00 00	 mov	 rcx, QWORD PTR tv282[rsp]
  006c7	48 89 4c 24 50	 mov	 QWORD PTR [rsp+80], rcx
  006cc	48 8b 8c 24 d8
	00 00 00	 mov	 rcx, QWORD PTR tv286[rsp]
  006d4	48 89 4c 24 48	 mov	 QWORD PTR [rsp+72], rcx
  006d9	8b 8c 24 a8 00
	00 00		 mov	 ecx, DWORD PTR tv289[rsp]
  006e0	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  006e4	8b 8c 24 ac 00
	00 00		 mov	 ecx, DWORD PTR tv293[rsp]
  006eb	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  006ef	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169565
  006f6	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  006fb	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169566
  00702	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00707	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  0070c	41 b9 03 00 00
	00		 mov	 r9d, 3
  00712	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG169567
  00719	ba 26 05 00 00	 mov	 edx, 1318		; 00000526H
  0071e	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169568
  00725	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 1318 :                     strerror( HSO_errno ) );
; 1319 : 
; 1320 :             pDEVBLK->sense[0] = SENSE_EC;

  0072b	b8 01 00 00 00	 mov	 eax, 1
  00730	48 6b c0 00	 imul	 rax, rax, 0
  00734	48 8b 8c 24 20
	01 00 00	 mov	 rcx, QWORD PTR pDEVBLK$[rsp]
  0073c	c6 84 01 64 03
	00 00 10	 mov	 BYTE PTR [rcx+rax+868], 16

; 1321 :             *pUnitStat        = CSW_CE | CSW_DE | CSW_UC;

  00744	48 8b 84 24 38
	01 00 00	 mov	 rax, QWORD PTR pUnitStat$[rsp]
  0074c	c6 00 0e	 mov	 BYTE PTR [rax], 14

; 1322 :             return;

  0074f	eb 7b		 jmp	 SHORT $LN1@CTCT_Write
$LN16@CTCT_Write:

; 1323 :         }
; 1324 : 
; 1325 :         // Adjust the residual byte count
; 1326 :         *pResidual -= sSegLen;

  00751	0f b7 44 24 60	 movzx	 eax, WORD PTR sSegLen$[rsp]
  00756	48 8b 8c 24 40
	01 00 00	 mov	 rcx, QWORD PTR pResidual$[rsp]
  0075e	8b 09		 mov	 ecx, DWORD PTR [rcx]
  00760	2b c8		 sub	 ecx, eax
  00762	8b c1		 mov	 eax, ecx
  00764	48 8b 8c 24 40
	01 00 00	 mov	 rcx, QWORD PTR pResidual$[rsp]
  0076c	89 01		 mov	 DWORD PTR [rcx], eax

; 1327 : 
; 1328 :         // We are done if current segment satisfies CCW count
; 1329 :         if( (U32)iPos + sSegLen == sCount )

  0076e	0f b7 44 24 60	 movzx	 eax, WORD PTR sSegLen$[rsp]
  00773	8b 4c 24 6c	 mov	 ecx, DWORD PTR iPos$[rsp]
  00777	03 c8		 add	 ecx, eax
  00779	8b c1		 mov	 eax, ecx
  0077b	3b 84 24 28 01
	00 00		 cmp	 eax, DWORD PTR sCount$[rsp]
  00782	75 2a		 jne	 SHORT $LN17@CTCT_Write

; 1330 :         {
; 1331 :             *pResidual -= sSegLen;

  00784	0f b7 44 24 60	 movzx	 eax, WORD PTR sSegLen$[rsp]
  00789	48 8b 8c 24 40
	01 00 00	 mov	 rcx, QWORD PTR pResidual$[rsp]
  00791	8b 09		 mov	 ecx, DWORD PTR [rcx]
  00793	2b c8		 sub	 ecx, eax
  00795	8b c1		 mov	 eax, ecx
  00797	48 8b 8c 24 40
	01 00 00	 mov	 rcx, QWORD PTR pResidual$[rsp]
  0079f	89 01		 mov	 DWORD PTR [rcx], eax

; 1332 :             *pUnitStat = CSW_CE | CSW_DE;

  007a1	48 8b 84 24 38
	01 00 00	 mov	 rax, QWORD PTR pUnitStat$[rsp]
  007a9	c6 00 0c	 mov	 BYTE PTR [rax], 12

; 1333 :             return;

  007ac	eb 1e		 jmp	 SHORT $LN1@CTCT_Write
$LN17@CTCT_Write:

; 1334 :         }
; 1335 :     }

  007ae	e9 37 fb ff ff	 jmp	 $LN5@CTCT_Write
$LN6@CTCT_Write:

; 1336 : 
; 1337 :     // Set unit status and residual byte count
; 1338 :     *pUnitStat = CSW_CE | CSW_DE;

  007b3	48 8b 84 24 38
	01 00 00	 mov	 rax, QWORD PTR pUnitStat$[rsp]
  007bb	c6 00 0c	 mov	 BYTE PTR [rax], 12

; 1339 :     *pResidual = 0;

  007be	48 8b 84 24 40
	01 00 00	 mov	 rax, QWORD PTR pResidual$[rsp]
  007c6	c7 00 00 00 00
	00		 mov	 DWORD PTR [rax], 0
$LN1@CTCT_Write:
$LN18@CTCT_Write:

; 1340 : }

  007cc	48 8b 8c 24 08
	01 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  007d4	48 33 cc	 xor	 rcx, rsp
  007d7	e8 00 00 00 00	 call	 __security_check_cookie
  007dc	48 81 c4 18 01
	00 00		 add	 rsp, 280		; 00000118H
  007e3	c3		 ret	 0
CTCT_Write ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\ctcadpt.c
_TEXT	SEGMENT
iLength$ = 112
tv77 = 116
pSegment$ = 120
pFrame$ = 128
iRetVal$ = 136
tv90 = 140
tv94 = 144
tv157 = 148
tv161 = 152
tv184 = 156
tv188 = 160
tv83 = 168
tv87 = 176
tv150 = 184
tv154 = 192
tv207 = 200
rfds$ = 208
__$ArrayPad$ = 8416
pDEVBLK$ = 8464
sCount$ = 8472
pIOBuf$ = 8480
pUnitStat$ = 8488
pResidual$ = 8496
pMore$ = 8504
CTCT_Read PROC

; 1349 : {

  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  0000e	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00013	56		 push	 rsi
  00014	57		 push	 rdi
  00015	b8 f8 20 00 00	 mov	 eax, 8440		; 000020f8H
  0001a	e8 00 00 00 00	 call	 __chkstk
  0001f	48 2b e0	 sub	 rsp, rax
  00022	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00029	48 33 c4	 xor	 rax, rsp
  0002c	48 89 84 24 e0
	20 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 1350 :     PCTCIHDR    pFrame   = NULL;       // -> Frame header

  00034	48 c7 84 24 80
	00 00 00 00 00
	00 00		 mov	 QWORD PTR pFrame$[rsp], 0

; 1351 :     PCTCISEG    pSegment = NULL;       // -> Segment in buffer

  00040	48 c7 44 24 78
	00 00 00 00	 mov	 QWORD PTR pSegment$[rsp], 0

; 1352 :     fd_set      rfds;                  // Read FD_SET
; 1353 :     int         iRetVal;               // Return code from 'select'
; 1354 :     int         iLength  = 0;

  00049	c7 44 24 70 00
	00 00 00	 mov	 DWORD PTR iLength$[rsp], 0

; 1355 : 
; 1356 :     static struct timeval tv;          // Timeout time for 'select'
; 1357 : 
; 1358 : 
; 1359 :     // Limit how long we should wait for data to come in
; 1360 :     FD_ZERO( &rfds );

  00051	c7 84 24 d0 00
	00 00 00 00 00
	00		 mov	 DWORD PTR rfds$[rsp], 0

; 1361 :     FD_SET( pDEVBLK->fd, &rfds );

  0005c	48 8d 94 24 d0
	00 00 00	 lea	 rdx, QWORD PTR rfds$[rsp]
  00064	48 8b 84 24 10
	21 00 00	 mov	 rax, QWORD PTR pDEVBLK$[rsp]
  0006c	8b 88 ac 01 00
	00		 mov	 ecx, DWORD PTR [rax+428]
  00072	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_FD_SET

; 1362 : 
; 1363 :     tv.tv_sec  = DEF_NET_READ_TIMEOUT_SECS;

  00078	c7 05 00 00 00
	00 05 00 00 00	 mov	 DWORD PTR ?tv@?1??CTCT_Read@@9@9, 5

; 1364 :     tv.tv_usec = 0;

  00082	c7 05 04 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?tv@?1??CTCT_Read@@9@9+4, 0

; 1365 : 
; 1366 :     iRetVal = select( pDEVBLK->fd + 1, &rfds, NULL, NULL, &tv );

  0008c	48 8b 84 24 10
	21 00 00	 mov	 rax, QWORD PTR pDEVBLK$[rsp]
  00094	8b 80 ac 01 00
	00		 mov	 eax, DWORD PTR [rax+428]
  0009a	ff c0		 inc	 eax
  0009c	c7 44 24 30 56
	05 00 00	 mov	 DWORD PTR [rsp+48], 1366 ; 00000556H
  000a4	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169615
  000ab	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  000b0	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:?tv@?1??CTCT_Read@@9@9
  000b7	48 89 4c 24 20	 mov	 QWORD PTR [rsp+32], rcx
  000bc	45 33 c9	 xor	 r9d, r9d
  000bf	45 33 c0	 xor	 r8d, r8d
  000c2	48 8d 94 24 d0
	00 00 00	 lea	 rdx, QWORD PTR rfds$[rsp]
  000ca	8b c8		 mov	 ecx, eax
  000cc	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_select
  000d2	89 84 24 88 00
	00 00		 mov	 DWORD PTR iRetVal$[rsp], eax

; 1367 : 
; 1368 :     switch( iRetVal )

  000d9	8b 84 24 88 00
	00 00		 mov	 eax, DWORD PTR iRetVal$[rsp]
  000e0	89 44 24 74	 mov	 DWORD PTR tv77[rsp], eax
  000e4	83 7c 24 74 ff	 cmp	 DWORD PTR tv77[rsp], -1
  000e9	74 35		 je	 SHORT $LN5@CTCT_Read
  000eb	83 7c 24 74 00	 cmp	 DWORD PTR tv77[rsp], 0
  000f0	74 05		 je	 SHORT $LN4@CTCT_Read
  000f2	e9 33 01 00 00	 jmp	 $LN7@CTCT_Read
$LN4@CTCT_Read:

; 1369 :     {
; 1370 :     case 0:
; 1371 :         *pUnitStat = CSW_CE | CSW_DE | CSW_UC | CSW_SM;

  000f7	48 8b 84 24 28
	21 00 00	 mov	 rax, QWORD PTR pUnitStat$[rsp]
  000ff	c6 00 4e	 mov	 BYTE PTR [rax], 78	; 0000004eH

; 1372 :         pDEVBLK->sense[0] = 0;

  00102	b8 01 00 00 00	 mov	 eax, 1
  00107	48 6b c0 00	 imul	 rax, rax, 0
  0010b	48 8b 8c 24 10
	21 00 00	 mov	 rcx, QWORD PTR pDEVBLK$[rsp]
  00113	c6 84 01 64 03
	00 00 00	 mov	 BYTE PTR [rcx+rax+868], 0

; 1373 :         return;

  0011b	e9 8d 04 00 00	 jmp	 $LN1@CTCT_Read
$LN5@CTCT_Read:

; 1374 : 
; 1375 :     case -1:
; 1376 :         if( HSO_errno == HSO_EINTR )

  00120	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_WSAGetLastError
  00126	3d 14 27 00 00	 cmp	 eax, 10004		; 00002714H
  0012b	75 05		 jne	 SHORT $LN6@CTCT_Read

; 1377 :             return;

  0012d	e9 7b 04 00 00	 jmp	 $LN1@CTCT_Read
$LN6@CTCT_Read:

; 1378 : 
; 1379 :         WRMSG(HHC00973, "E", SSID_TO_LCSS(pDEVBLK->ssid), pDEVBLK->devnum, pDEVBLK->filename,

  00132	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_WSAGetLastError
  00138	8b c8		 mov	 ecx, eax
  0013a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_strerror
  00140	48 89 84 24 a8
	00 00 00	 mov	 QWORD PTR tv83[rsp], rax
  00148	48 8b 8c 24 10
	21 00 00	 mov	 rcx, QWORD PTR pDEVBLK$[rsp]
  00150	48 81 c1 a4 00
	00 00		 add	 rcx, 164		; 000000a4H
  00157	48 89 8c 24 b0
	00 00 00	 mov	 QWORD PTR tv87[rsp], rcx
  0015f	48 8b 94 24 10
	21 00 00	 mov	 rdx, QWORD PTR pDEVBLK$[rsp]
  00167	0f b7 52 48	 movzx	 edx, WORD PTR [rdx+72]
  0016b	89 94 24 8c 00
	00 00		 mov	 DWORD PTR tv90[rsp], edx
  00172	4c 8b 84 24 10
	21 00 00	 mov	 r8, QWORD PTR pDEVBLK$[rsp]
  0017a	45 0f b7 40 44	 movzx	 r8d, WORD PTR [r8+68]
  0017f	41 d1 f8	 sar	 r8d, 1
  00182	44 89 84 24 90
	00 00 00	 mov	 DWORD PTR tv94[rsp], r8d
  0018a	b9 01 00 00 00	 mov	 ecx, 1
  0018f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  00195	48 8b 8c 24 a8
	00 00 00	 mov	 rcx, QWORD PTR tv83[rsp]
  0019d	48 89 4c 24 50	 mov	 QWORD PTR [rsp+80], rcx
  001a2	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR tv87[rsp]
  001aa	48 89 4c 24 48	 mov	 QWORD PTR [rsp+72], rcx
  001af	8b 8c 24 8c 00
	00 00		 mov	 ecx, DWORD PTR tv90[rsp]
  001b6	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  001ba	8b 8c 24 90 00
	00 00		 mov	 ecx, DWORD PTR tv94[rsp]
  001c1	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  001c5	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169619
  001cc	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  001d1	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169620
  001d8	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  001dd	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  001e2	41 b9 03 00 00
	00		 mov	 r9d, 3
  001e8	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG169621
  001ef	ba 64 05 00 00	 mov	 edx, 1380		; 00000564H
  001f4	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169622
  001fb	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 1380 :               strerror( HSO_errno ) );
; 1381 : 
; 1382 :         pDEVBLK->sense[0] = SENSE_EC;

  00201	b8 01 00 00 00	 mov	 eax, 1
  00206	48 6b c0 00	 imul	 rax, rax, 0
  0020a	48 8b 8c 24 10
	21 00 00	 mov	 rcx, QWORD PTR pDEVBLK$[rsp]
  00212	c6 84 01 64 03
	00 00 10	 mov	 BYTE PTR [rcx+rax+868], 16

; 1383 :         *pUnitStat = CSW_CE | CSW_DE | CSW_UC;

  0021a	48 8b 84 24 28
	21 00 00	 mov	 rax, QWORD PTR pUnitStat$[rsp]
  00222	c6 00 0e	 mov	 BYTE PTR [rax], 14

; 1384 :         return;

  00225	e9 83 03 00 00	 jmp	 $LN1@CTCT_Read
$LN7@CTCT_Read:

; 1385 : 
; 1386 :     default:
; 1387 :         break;
; 1388 :     }
; 1389 : 
; 1390 :     // Read an IP packet from the TUN device
; 1391 :     iLength = read_socket( pDEVBLK->fd, pDEVBLK->buf, pDEVBLK->bufsize );

  0022a	48 8b 84 24 10
	21 00 00	 mov	 rax, QWORD PTR pDEVBLK$[rsp]
  00232	44 8b 80 d8 01
	00 00		 mov	 r8d, DWORD PTR [rax+472]
  00239	48 8b 84 24 10
	21 00 00	 mov	 rax, QWORD PTR pDEVBLK$[rsp]
  00241	48 8b 90 c8 01
	00 00		 mov	 rdx, QWORD PTR [rax+456]
  00248	48 8b 84 24 10
	21 00 00	 mov	 rax, QWORD PTR pDEVBLK$[rsp]
  00250	8b 88 ac 01 00
	00		 mov	 ecx, DWORD PTR [rax+428]
  00256	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_read_socket
  0025c	89 44 24 70	 mov	 DWORD PTR iLength$[rsp], eax

; 1392 : 
; 1393 :     // Check for other error condition
; 1394 :     if( iLength < 0 )

  00260	83 7c 24 70 00	 cmp	 DWORD PTR iLength$[rsp], 0
  00265	0f 8d f8 00 00
	00		 jge	 $LN8@CTCT_Read

; 1395 :     {
; 1396 :         WRMSG(HHC00973, "E", SSID_TO_LCSS(pDEVBLK->ssid), pDEVBLK->devnum, pDEVBLK->filename,

  0026b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_WSAGetLastError
  00271	8b c8		 mov	 ecx, eax
  00273	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_strerror
  00279	48 89 84 24 b8
	00 00 00	 mov	 QWORD PTR tv150[rsp], rax
  00281	48 8b 8c 24 10
	21 00 00	 mov	 rcx, QWORD PTR pDEVBLK$[rsp]
  00289	48 81 c1 a4 00
	00 00		 add	 rcx, 164		; 000000a4H
  00290	48 89 8c 24 c0
	00 00 00	 mov	 QWORD PTR tv154[rsp], rcx
  00298	48 8b 94 24 10
	21 00 00	 mov	 rdx, QWORD PTR pDEVBLK$[rsp]
  002a0	0f b7 52 48	 movzx	 edx, WORD PTR [rdx+72]
  002a4	89 94 24 94 00
	00 00		 mov	 DWORD PTR tv157[rsp], edx
  002ab	4c 8b 84 24 10
	21 00 00	 mov	 r8, QWORD PTR pDEVBLK$[rsp]
  002b3	45 0f b7 40 44	 movzx	 r8d, WORD PTR [r8+68]
  002b8	41 d1 f8	 sar	 r8d, 1
  002bb	44 89 84 24 98
	00 00 00	 mov	 DWORD PTR tv161[rsp], r8d
  002c3	b9 01 00 00 00	 mov	 ecx, 1
  002c8	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  002ce	48 8b 8c 24 b8
	00 00 00	 mov	 rcx, QWORD PTR tv150[rsp]
  002d6	48 89 4c 24 50	 mov	 QWORD PTR [rsp+80], rcx
  002db	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR tv154[rsp]
  002e3	48 89 4c 24 48	 mov	 QWORD PTR [rsp+72], rcx
  002e8	8b 8c 24 94 00
	00 00		 mov	 ecx, DWORD PTR tv157[rsp]
  002ef	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  002f3	8b 8c 24 98 00
	00 00		 mov	 ecx, DWORD PTR tv161[rsp]
  002fa	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  002fe	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169625
  00305	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  0030a	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169626
  00311	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00316	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  0031b	41 b9 03 00 00
	00		 mov	 r9d, 3
  00321	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG169627
  00328	ba 75 05 00 00	 mov	 edx, 1397		; 00000575H
  0032d	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169628
  00334	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 1397 :               strerror( HSO_errno ) );
; 1398 :         pDEVBLK->sense[0] = SENSE_EC;

  0033a	b8 01 00 00 00	 mov	 eax, 1
  0033f	48 6b c0 00	 imul	 rax, rax, 0
  00343	48 8b 8c 24 10
	21 00 00	 mov	 rcx, QWORD PTR pDEVBLK$[rsp]
  0034b	c6 84 01 64 03
	00 00 10	 mov	 BYTE PTR [rcx+rax+868], 16

; 1399 :         *pUnitStat = CSW_CE | CSW_DE | CSW_UC;

  00353	48 8b 84 24 28
	21 00 00	 mov	 rax, QWORD PTR pUnitStat$[rsp]
  0035b	c6 00 0e	 mov	 BYTE PTR [rax], 14

; 1400 :         return;

  0035e	e9 4a 02 00 00	 jmp	 $LN1@CTCT_Read
$LN8@CTCT_Read:

; 1401 :     }
; 1402 : 
; 1403 :     // Trace the packet received from the TUN device
; 1404 :     if (pDEVBLK->ccwtrace)

  00363	48 8b 84 24 10
	21 00 00	 mov	 rax, QWORD PTR pDEVBLK$[rsp]
  0036b	8b 80 f8 05 00
	00		 mov	 eax, DWORD PTR [rax+1528]
  00371	c1 e8 0f	 shr	 eax, 15
  00374	83 e0 01	 and	 eax, 1
  00377	85 c0		 test	 eax, eax
  00379	0f 84 cc 00 00
	00		 je	 $LN9@CTCT_Read

; 1405 :     {
; 1406 :         // "%1d:%04X %s: receive%s packet of size %d bytes from device %s"
; 1407 :         WRMSG(HHC00913, "I", SSID_TO_LCSS(pDEVBLK->ssid), pDEVBLK->devnum, "CTC",

  0037f	48 8b 84 24 10
	21 00 00	 mov	 rax, QWORD PTR pDEVBLK$[rsp]
  00387	0f b7 40 48	 movzx	 eax, WORD PTR [rax+72]
  0038b	89 84 24 9c 00
	00 00		 mov	 DWORD PTR tv184[rsp], eax
  00392	48 8b 8c 24 10
	21 00 00	 mov	 rcx, QWORD PTR pDEVBLK$[rsp]
  0039a	0f b7 49 44	 movzx	 ecx, WORD PTR [rcx+68]
  0039e	d1 f9		 sar	 ecx, 1
  003a0	89 8c 24 a0 00
	00 00		 mov	 DWORD PTR tv188[rsp], ecx
  003a7	b9 01 00 00 00	 mov	 ecx, 1
  003ac	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  003b2	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169630
  003b9	48 89 4c 24 60	 mov	 QWORD PTR [rsp+96], rcx
  003be	8b 4c 24 70	 mov	 ecx, DWORD PTR iLength$[rsp]
  003c2	89 4c 24 58	 mov	 DWORD PTR [rsp+88], ecx
  003c6	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169631
  003cd	48 89 4c 24 50	 mov	 QWORD PTR [rsp+80], rcx
  003d2	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169632
  003d9	48 89 4c 24 48	 mov	 QWORD PTR [rsp+72], rcx
  003de	8b 8c 24 9c 00
	00 00		 mov	 ecx, DWORD PTR tv184[rsp]
  003e5	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  003e9	8b 8c 24 a0 00
	00 00		 mov	 ecx, DWORD PTR tv188[rsp]
  003f0	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  003f4	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169633
  003fb	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  00400	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169634
  00407	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  0040c	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00411	41 b9 03 00 00
	00		 mov	 r9d, 3
  00417	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG169635
  0041e	ba 80 05 00 00	 mov	 edx, 1408		; 00000580H
  00423	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169636
  0042a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 1408 :                              "", iLength, "TUN" );
; 1409 :         packet_trace( pDEVBLK->buf, iLength, '<' );

  00430	41 b0 3c	 mov	 r8b, 60			; 0000003cH
  00433	8b 54 24 70	 mov	 edx, DWORD PTR iLength$[rsp]
  00437	48 8b 84 24 10
	21 00 00	 mov	 rax, QWORD PTR pDEVBLK$[rsp]
  0043f	48 8b 88 c8 01
	00 00		 mov	 rcx, QWORD PTR [rax+456]
  00446	e8 00 00 00 00	 call	 packet_trace
$LN9@CTCT_Read:

; 1410 :     }
; 1411 : 
; 1412 :     // Fix-up Frame pointer
; 1413 :     pFrame = (PCTCIHDR)pIOBuf;

  0044b	48 8b 84 24 20
	21 00 00	 mov	 rax, QWORD PTR pIOBuf$[rsp]
  00453	48 89 84 24 80
	00 00 00	 mov	 QWORD PTR pFrame$[rsp], rax

; 1414 : 
; 1415 :     // Fix-up Segment pointer
; 1416 :     pSegment = (PCTCISEG)( pIOBuf + sizeof( CTCIHDR ) );

  0045b	48 8b 84 24 20
	21 00 00	 mov	 rax, QWORD PTR pIOBuf$[rsp]
  00463	48 83 c0 02	 add	 rax, 2
  00467	48 89 44 24 78	 mov	 QWORD PTR pSegment$[rsp], rax

; 1417 : 
; 1418 :     // Initialize segment
; 1419 :     memset( pSegment, 0, iLength + sizeof( CTCISEG ) );

  0046c	48 63 44 24 70	 movsxd	 rax, DWORD PTR iLength$[rsp]
  00471	48 83 c0 06	 add	 rax, 6
  00475	48 89 84 24 c8
	00 00 00	 mov	 QWORD PTR tv207[rsp], rax
  0047d	48 8b 7c 24 78	 mov	 rdi, QWORD PTR pSegment$[rsp]
  00482	33 c0		 xor	 eax, eax
  00484	48 8b 8c 24 c8
	00 00 00	 mov	 rcx, QWORD PTR tv207[rsp]
  0048c	f3 aa		 rep stosb

; 1420 : 
; 1421 :     // Update next frame offset
; 1422 :     STORE_HW( pFrame->hwOffset,

  0048e	48 63 44 24 70	 movsxd	 rax, DWORD PTR iLength$[rsp]
  00493	48 83 c0 08	 add	 rax, 8
  00497	0f b7 c8	 movzx	 ecx, ax
  0049a	e8 00 00 00 00	 call	 _byteswap_ushort
  0049f	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR pFrame$[rsp]
  004a7	0f b7 d0	 movzx	 edx, ax
  004aa	e8 00 00 00 00	 call	 store_hw_noswap

; 1423 :               (U16)(iLength + sizeof( CTCIHDR ) + sizeof( CTCISEG )) );
; 1424 : 
; 1425 :     // Store segment length
; 1426 :     STORE_HW( pSegment->hwLength, (U16)(iLength + sizeof( CTCISEG )) );

  004af	48 63 44 24 70	 movsxd	 rax, DWORD PTR iLength$[rsp]
  004b4	48 83 c0 06	 add	 rax, 6
  004b8	0f b7 c8	 movzx	 ecx, ax
  004bb	e8 00 00 00 00	 call	 _byteswap_ushort
  004c0	48 8b 4c 24 78	 mov	 rcx, QWORD PTR pSegment$[rsp]
  004c5	0f b7 d0	 movzx	 edx, ax
  004c8	e8 00 00 00 00	 call	 store_hw_noswap

; 1427 : 
; 1428 :     // Store Frame type
; 1429 :     STORE_HW( pSegment->hwType, ETH_TYPE_IP );

  004cd	66 b9 00 08	 mov	 cx, 2048		; 00000800H
  004d1	e8 00 00 00 00	 call	 _byteswap_ushort
  004d6	48 8b 4c 24 78	 mov	 rcx, QWORD PTR pSegment$[rsp]
  004db	48 83 c1 02	 add	 rcx, 2
  004df	0f b7 d0	 movzx	 edx, ax
  004e2	e8 00 00 00 00	 call	 store_hw_noswap

; 1430 : 
; 1431 :     // Copy data
; 1432 :     memcpy( pSegment->bData, pDEVBLK->buf, iLength );

  004e7	48 63 44 24 70	 movsxd	 rax, DWORD PTR iLength$[rsp]
  004ec	48 8b 4c 24 78	 mov	 rcx, QWORD PTR pSegment$[rsp]
  004f1	48 83 c1 06	 add	 rcx, 6
  004f5	48 8b 94 24 10
	21 00 00	 mov	 rdx, QWORD PTR pDEVBLK$[rsp]
  004fd	48 8b f9	 mov	 rdi, rcx
  00500	48 8b b2 c8 01
	00 00		 mov	 rsi, QWORD PTR [rdx+456]
  00507	48 8b c8	 mov	 rcx, rax
  0050a	f3 a4		 rep movsb

; 1433 : 
; 1434 :     // Fix-up frame pointer and terminate block
; 1435 :     pFrame = (PCTCIHDR)( pIOBuf + sizeof( CTCIHDR ) +

  0050c	48 63 44 24 70	 movsxd	 rax, DWORD PTR iLength$[rsp]
  00511	48 8b 8c 24 20
	21 00 00	 mov	 rcx, QWORD PTR pIOBuf$[rsp]
  00519	48 8d 44 01 08	 lea	 rax, QWORD PTR [rcx+rax+8]
  0051e	48 89 84 24 80
	00 00 00	 mov	 QWORD PTR pFrame$[rsp], rax

; 1436 :                          sizeof( CTCISEG ) + iLength );
; 1437 :     STORE_HW( pFrame->hwOffset, 0x0000 );

  00526	33 c9		 xor	 ecx, ecx
  00528	e8 00 00 00 00	 call	 _byteswap_ushort
  0052d	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR pFrame$[rsp]
  00535	0f b7 d0	 movzx	 edx, ax
  00538	e8 00 00 00 00	 call	 store_hw_noswap

; 1438 : 
; 1439 :     // Calculate #of bytes returned including two slack bytes
; 1440 :     iLength += sizeof( CTCIHDR ) + sizeof( CTCISEG ) + 2;

  0053d	48 63 44 24 70	 movsxd	 rax, DWORD PTR iLength$[rsp]
  00542	48 83 c0 0a	 add	 rax, 10
  00546	89 44 24 70	 mov	 DWORD PTR iLength$[rsp], eax

; 1441 : 
; 1442 :     if( sCount < (U32)iLength )

  0054a	8b 44 24 70	 mov	 eax, DWORD PTR iLength$[rsp]
  0054e	39 84 24 18 21
	00 00		 cmp	 DWORD PTR sCount$[rsp], eax
  00555	73 26		 jae	 SHORT $LN10@CTCT_Read

; 1443 :     {
; 1444 :         *pMore     = 1;

  00557	48 8b 84 24 38
	21 00 00	 mov	 rax, QWORD PTR pMore$[rsp]
  0055f	c6 00 01	 mov	 BYTE PTR [rax], 1

; 1445 :         *pResidual = 0;

  00562	48 8b 84 24 30
	21 00 00	 mov	 rax, QWORD PTR pResidual$[rsp]
  0056a	c7 00 00 00 00
	00		 mov	 DWORD PTR [rax], 0

; 1446 : 
; 1447 :         iLength    = sCount;

  00570	8b 84 24 18 21
	00 00		 mov	 eax, DWORD PTR sCount$[rsp]
  00577	89 44 24 70	 mov	 DWORD PTR iLength$[rsp], eax

; 1448 :     }

  0057b	eb 25		 jmp	 SHORT $LN11@CTCT_Read
$LN10@CTCT_Read:

; 1449 :     else
; 1450 :     {
; 1451 :         *pMore      = 0;

  0057d	48 8b 84 24 38
	21 00 00	 mov	 rax, QWORD PTR pMore$[rsp]
  00585	c6 00 00	 mov	 BYTE PTR [rax], 0

; 1452 :         *pResidual -= iLength;

  00588	48 8b 84 24 30
	21 00 00	 mov	 rax, QWORD PTR pResidual$[rsp]
  00590	8b 4c 24 70	 mov	 ecx, DWORD PTR iLength$[rsp]
  00594	8b 00		 mov	 eax, DWORD PTR [rax]
  00596	2b c1		 sub	 eax, ecx
  00598	48 8b 8c 24 30
	21 00 00	 mov	 rcx, QWORD PTR pResidual$[rsp]
  005a0	89 01		 mov	 DWORD PTR [rcx], eax
$LN11@CTCT_Read:

; 1453 :     }
; 1454 : 
; 1455 :     // Set unit status
; 1456 :     *pUnitStat = CSW_CE | CSW_DE;

  005a2	48 8b 84 24 28
	21 00 00	 mov	 rax, QWORD PTR pUnitStat$[rsp]
  005aa	c6 00 0c	 mov	 BYTE PTR [rax], 12
$LN1@CTCT_Read:

; 1457 : }

  005ad	48 8b 8c 24 e0
	20 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  005b5	48 33 cc	 xor	 rcx, rsp
  005b8	e8 00 00 00 00	 call	 __security_check_cookie
  005bd	48 81 c4 f8 20
	00 00		 add	 rsp, 8440		; 000020f8H
  005c4	5f		 pop	 rdi
  005c5	5e		 pop	 rsi
  005c6	c3		 ret	 0
CTCT_Read ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\ctcadpt.c
_TEXT	SEGMENT
c$ = 96
rc$ = 100
lport$ = 104
mtu$ = 108
rport$ = 112
ipaddr$ = 116
remaddr$ = 120
remotep$ = 128
tv149 = 136
tv153 = 140
tv191 = 144
tv195 = 148
tv222 = 152
tv226 = 156
tv252 = 160
tv256 = 164
tv280 = 168
tv284 = 172
tv349 = 176
tv353 = 180
tv380 = 184
tv384 = 188
tv408 = 192
tv412 = 196
tv445 = 200
tv449 = 204
tv473 = 208
tv477 = 212
tv567 = 216
tv571 = 220
tv86 = 224
tv90 = 228
listenp$ = 232
hp$1 = 240
mtusize$ = 248
arg$2 = 256
$T3 = 264
tid$ = 272
tv273 = 280
tv342 = 288
tv401 = 296
tv438 = 304
tv466 = 312
tv552 = 320
parm$ = 328
address$ = 360
str$ = 384
__$ArrayPad$ = 464
dev$ = 512
argc$ = 520
argv$ = 528
CTCT_Init PROC

; 998  : {

  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00009	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000e	56		 push	 rsi
  0000f	57		 push	 rdi
  00010	48 81 ec e8 01
	00 00		 sub	 rsp, 488		; 000001e8H
  00017	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  0001e	48 33 c4	 xor	 rax, rsp
  00021	48 89 84 24 d0
	01 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 999  :     char           str[80];            // Thread name
; 1000 :     int            rc;                 // Return code
; 1001 :     int            mtu;                // MTU size (binary)
; 1002 :     int            lport;              // Listen port (binary)
; 1003 :     int            rport;              // Destination port (binary)
; 1004 :     char*          listenp;            // Listening port number
; 1005 :     char*          remotep;            // Destination port number
; 1006 :     char*          mtusize;            // MTU size (characters)
; 1007 :     char*          remaddr;            // Remote IP address
; 1008 :     struct in_addr ipaddr;             // Work area for IP address
; 1009 :     BYTE           c;                  // Character work area
; 1010 :     TID            tid;                // Thread ID for server
; 1011 :     CTCG_PARMBLK   parm;               // Parameters for the server
; 1012 :     char           address[20]="";     // temp space for IP address

  00029	0f b6 05 00 00
	00 00		 movzx	 eax, BYTE PTR $SG169399
  00030	88 84 24 68 01
	00 00		 mov	 BYTE PTR address$[rsp], al
  00037	48 8d 84 24 69
	01 00 00	 lea	 rax, QWORD PTR address$[rsp+1]
  0003f	48 8b f8	 mov	 rdi, rax
  00042	33 c0		 xor	 eax, eax
  00044	b9 13 00 00 00	 mov	 ecx, 19
  00049	f3 aa		 rep stosb

; 1013 : 
; 1014 :     dev->devtype = 0x3088;

  0004b	b8 88 30 00 00	 mov	 eax, 12424		; 00003088H
  00050	48 8b 8c 24 00
	02 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  00058	66 89 41 4a	 mov	 WORD PTR [rcx+74], ax

; 1015 : 
; 1016 :     dev->excps = 0;

  0005c	48 8b 84 24 00
	02 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00064	48 c7 80 00 06
	00 00 00 00 00
	00		 mov	 QWORD PTR [rax+1536], 0

; 1017 : 
; 1018 :     dev->ctctype = CTC_CTCT;

  0006f	48 8b 84 24 00
	02 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00077	c6 80 1c 07 00
	00 06		 mov	 BYTE PTR [rax+1820], 6

; 1019 : 
; 1020 :     SetSIDInfo( dev, 0x3088, 0x08, 0x3088, 0x01 );

  0007e	c6 44 24 20 01	 mov	 BYTE PTR [rsp+32], 1
  00083	66 41 b9 88 30	 mov	 r9w, 12424		; 00003088H
  00088	41 b0 08	 mov	 r8b, 8
  0008b	66 ba 88 30	 mov	 dx, 12424		; 00003088H
  0008f	48 8b 8c 24 00
	02 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  00097	e8 00 00 00 00	 call	 SetSIDInfo

; 1021 : 
; 1022 :     // Check for correct number of arguments
; 1023 :     if (argc != 4)

  0009c	83 bc 24 08 02
	00 00 04	 cmp	 DWORD PTR argc$[rsp], 4
  000a4	0f 84 9b 00 00
	00		 je	 $LN2@CTCT_Init

; 1024 :     {
; 1025 :         WRMSG (HHC00915, "E", SSID_TO_LCSS(dev->ssid), dev->devnum, "CTC");

  000aa	48 8b 84 24 00
	02 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  000b2	0f b7 40 48	 movzx	 eax, WORD PTR [rax+72]
  000b6	89 84 24 e0 00
	00 00		 mov	 DWORD PTR tv86[rsp], eax
  000bd	48 8b 8c 24 00
	02 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  000c5	0f b7 49 44	 movzx	 ecx, WORD PTR [rcx+68]
  000c9	d1 f9		 sar	 ecx, 1
  000cb	89 8c 24 e4 00
	00 00		 mov	 DWORD PTR tv90[rsp], ecx
  000d2	b9 01 00 00 00	 mov	 ecx, 1
  000d7	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  000dd	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169401
  000e4	48 89 4c 24 48	 mov	 QWORD PTR [rsp+72], rcx
  000e9	8b 8c 24 e0 00
	00 00		 mov	 ecx, DWORD PTR tv86[rsp]
  000f0	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  000f4	8b 8c 24 e4 00
	00 00		 mov	 ecx, DWORD PTR tv90[rsp]
  000fb	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  000ff	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169402
  00106	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  0010b	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169403
  00112	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00117	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  0011c	41 b9 03 00 00
	00		 mov	 r9d, 3
  00122	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG169404
  00129	ba 01 04 00 00	 mov	 edx, 1025		; 00000401H
  0012e	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169405
  00135	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 1026 :         return -1;

  0013b	b8 ff ff ff ff	 mov	 eax, -1
  00140	e9 d3 0d 00 00	 jmp	 $LN1@CTCT_Init
$LN2@CTCT_Init:

; 1027 :     }
; 1028 : 
; 1029 :     // The first argument is the listening port number
; 1030 :     listenp = *argv++;

  00145	48 8b 84 24 10
	02 00 00	 mov	 rax, QWORD PTR argv$[rsp]
  0014d	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00150	48 89 84 24 e8
	00 00 00	 mov	 QWORD PTR listenp$[rsp], rax
  00158	48 8b 84 24 10
	02 00 00	 mov	 rax, QWORD PTR argv$[rsp]
  00160	48 83 c0 08	 add	 rax, 8
  00164	48 89 84 24 10
	02 00 00	 mov	 QWORD PTR argv$[rsp], rax

; 1031 : 
; 1032 :     if( strlen( listenp ) > 5 ||
; 1033 :         sscanf( listenp, "%u%c", &lport, &c ) != 1 ||
; 1034 :         lport < 1024 || lport > 65534 )

  0016c	48 8b 8c 24 e8
	00 00 00	 mov	 rcx, QWORD PTR listenp$[rsp]
  00174	e8 00 00 00 00	 call	 strlen
  00179	48 83 f8 05	 cmp	 rax, 5
  0017d	77 3b		 ja	 SHORT $LN4@CTCT_Init
  0017f	4c 8d 4c 24 60	 lea	 r9, QWORD PTR c$[rsp]
  00184	4c 8d 44 24 68	 lea	 r8, QWORD PTR lport$[rsp]
  00189	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG169408
  00190	48 8b 8c 24 e8
	00 00 00	 mov	 rcx, QWORD PTR listenp$[rsp]
  00198	e8 00 00 00 00	 call	 sscanf
  0019d	83 f8 01	 cmp	 eax, 1
  001a0	75 18		 jne	 SHORT $LN4@CTCT_Init
  001a2	81 7c 24 68 00
	04 00 00	 cmp	 DWORD PTR lport$[rsp], 1024 ; 00000400H
  001aa	7c 0e		 jl	 SHORT $LN4@CTCT_Init
  001ac	81 7c 24 68 fe
	ff 00 00	 cmp	 DWORD PTR lport$[rsp], 65534 ; 0000fffeH
  001b4	0f 8e b4 00 00
	00		 jle	 $LN3@CTCT_Init
$LN4@CTCT_Init:

; 1035 :     {
; 1036 :         WRMSG(HHC00916, "E", SSID_TO_LCSS(dev->ssid), dev->devnum, "CTC", "port number", listenp);

  001ba	48 8b 84 24 00
	02 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  001c2	0f b7 40 48	 movzx	 eax, WORD PTR [rax+72]
  001c6	89 84 24 88 00
	00 00		 mov	 DWORD PTR tv149[rsp], eax
  001cd	48 8b 8c 24 00
	02 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  001d5	0f b7 49 44	 movzx	 ecx, WORD PTR [rcx+68]
  001d9	d1 f9		 sar	 ecx, 1
  001db	89 8c 24 8c 00
	00 00		 mov	 DWORD PTR tv153[rsp], ecx
  001e2	b9 01 00 00 00	 mov	 ecx, 1
  001e7	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  001ed	48 8b 8c 24 e8
	00 00 00	 mov	 rcx, QWORD PTR listenp$[rsp]
  001f5	48 89 4c 24 58	 mov	 QWORD PTR [rsp+88], rcx
  001fa	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169409
  00201	48 89 4c 24 50	 mov	 QWORD PTR [rsp+80], rcx
  00206	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169410
  0020d	48 89 4c 24 48	 mov	 QWORD PTR [rsp+72], rcx
  00212	8b 8c 24 88 00
	00 00		 mov	 ecx, DWORD PTR tv149[rsp]
  00219	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  0021d	8b 8c 24 8c 00
	00 00		 mov	 ecx, DWORD PTR tv153[rsp]
  00224	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  00228	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169411
  0022f	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  00234	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169412
  0023b	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00240	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00245	41 b9 03 00 00
	00		 mov	 r9d, 3
  0024b	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG169413
  00252	ba 0c 04 00 00	 mov	 edx, 1036		; 0000040cH
  00257	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169414
  0025e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 1037 :         return -1;

  00264	b8 ff ff ff ff	 mov	 eax, -1
  00269	e9 aa 0c 00 00	 jmp	 $LN1@CTCT_Init
$LN3@CTCT_Init:

; 1038 :     }
; 1039 : 
; 1040 :     // The second argument is the IP address or hostname of the
; 1041 :     // remote side of the point-to-point link
; 1042 :     remaddr = *argv++;

  0026e	48 8b 84 24 10
	02 00 00	 mov	 rax, QWORD PTR argv$[rsp]
  00276	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00279	48 89 44 24 78	 mov	 QWORD PTR remaddr$[rsp], rax
  0027e	48 8b 84 24 10
	02 00 00	 mov	 rax, QWORD PTR argv$[rsp]
  00286	48 83 c0 08	 add	 rax, 8
  0028a	48 89 84 24 10
	02 00 00	 mov	 QWORD PTR argv$[rsp], rax

; 1043 : 
; 1044 :     if (!inet_aton( remaddr, &ipaddr ))

  00292	48 8d 54 24 74	 lea	 rdx, QWORD PTR ipaddr$[rsp]
  00297	48 8b 4c 24 78	 mov	 rcx, QWORD PTR remaddr$[rsp]
  0029c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_inet_aton
  002a2	85 c0		 test	 eax, eax
  002a4	0f 85 32 01 00
	00		 jne	 $LN5@CTCT_Init

; 1045 :     {
; 1046 :         struct hostent *hp;
; 1047 : 
; 1048 :         if( ( hp = gethostbyname( remaddr ) ) != NULL )

  002aa	48 8b 4c 24 78	 mov	 rcx, QWORD PTR remaddr$[rsp]
  002af	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_gethostbyname
  002b5	48 89 84 24 f0
	00 00 00	 mov	 QWORD PTR hp$1[rsp], rax
  002bd	48 83 bc 24 f0
	00 00 00 00	 cmp	 QWORD PTR hp$1[rsp], 0
  002c6	74 63		 je	 SHORT $LN6@CTCT_Init

; 1049 :         {
; 1050 :             memcpy( &ipaddr, hp->h_addr, hp->h_length );

  002c8	48 8b 84 24 f0
	00 00 00	 mov	 rax, QWORD PTR hp$1[rsp]
  002d0	48 0f bf 40 12	 movsx	 rax, WORD PTR [rax+18]
  002d5	b9 08 00 00 00	 mov	 ecx, 8
  002da	48 6b c9 00	 imul	 rcx, rcx, 0
  002de	48 8b 94 24 f0
	00 00 00	 mov	 rdx, QWORD PTR hp$1[rsp]
  002e6	48 8b 52 18	 mov	 rdx, QWORD PTR [rdx+24]
  002ea	48 8d 7c 24 74	 lea	 rdi, QWORD PTR ipaddr$[rsp]
  002ef	48 8b 34 0a	 mov	 rsi, QWORD PTR [rdx+rcx]
  002f3	48 8b c8	 mov	 rcx, rax
  002f6	f3 a4		 rep movsb

; 1051 :             STRLCPY( address, inet_ntoa( ipaddr ) );

  002f8	8b 4c 24 74	 mov	 ecx, DWORD PTR ipaddr$[rsp]
  002fc	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_inet_ntoa
  00302	41 b8 14 00 00
	00		 mov	 r8d, 20
  00308	48 8b d0	 mov	 rdx, rax
  0030b	48 8d 8c 24 68
	01 00 00	 lea	 rcx, QWORD PTR address$[rsp]
  00313	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_strlcpy

; 1052 :             remaddr = address;

  00319	48 8d 84 24 68
	01 00 00	 lea	 rax, QWORD PTR address$[rsp]
  00321	48 89 44 24 78	 mov	 QWORD PTR remaddr$[rsp], rax

; 1053 :         }

  00326	e9 b1 00 00 00	 jmp	 $LN7@CTCT_Init
$LN6@CTCT_Init:

; 1054 :         else
; 1055 :         {
; 1056 :             WRMSG(HHC00916, "E", SSID_TO_LCSS(dev->ssid), dev->devnum, "CTC", "IP address", remaddr);

  0032b	48 8b 84 24 00
	02 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00333	0f b7 40 48	 movzx	 eax, WORD PTR [rax+72]
  00337	89 84 24 90 00
	00 00		 mov	 DWORD PTR tv191[rsp], eax
  0033e	48 8b 8c 24 00
	02 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  00346	0f b7 49 44	 movzx	 ecx, WORD PTR [rcx+68]
  0034a	d1 f9		 sar	 ecx, 1
  0034c	89 8c 24 94 00
	00 00		 mov	 DWORD PTR tv195[rsp], ecx
  00353	b9 01 00 00 00	 mov	 ecx, 1
  00358	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  0035e	48 8b 4c 24 78	 mov	 rcx, QWORD PTR remaddr$[rsp]
  00363	48 89 4c 24 58	 mov	 QWORD PTR [rsp+88], rcx
  00368	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169418
  0036f	48 89 4c 24 50	 mov	 QWORD PTR [rsp+80], rcx
  00374	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169419
  0037b	48 89 4c 24 48	 mov	 QWORD PTR [rsp+72], rcx
  00380	8b 8c 24 90 00
	00 00		 mov	 ecx, DWORD PTR tv191[rsp]
  00387	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  0038b	8b 8c 24 94 00
	00 00		 mov	 ecx, DWORD PTR tv195[rsp]
  00392	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  00396	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169420
  0039d	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  003a2	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169421
  003a9	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  003ae	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  003b3	41 b9 03 00 00
	00		 mov	 r9d, 3
  003b9	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG169422
  003c0	ba 20 04 00 00	 mov	 edx, 1056		; 00000420H
  003c5	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169423
  003cc	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 1057 :             return -1;

  003d2	b8 ff ff ff ff	 mov	 eax, -1
  003d7	e9 3c 0b 00 00	 jmp	 $LN1@CTCT_Init
$LN7@CTCT_Init:
$LN5@CTCT_Init:

; 1058 :         }
; 1059 :     }
; 1060 : 
; 1061 :     // The third argument is the destination port number
; 1062 :     remotep = *argv++;

  003dc	48 8b 84 24 10
	02 00 00	 mov	 rax, QWORD PTR argv$[rsp]
  003e4	48 8b 00	 mov	 rax, QWORD PTR [rax]
  003e7	48 89 84 24 80
	00 00 00	 mov	 QWORD PTR remotep$[rsp], rax
  003ef	48 8b 84 24 10
	02 00 00	 mov	 rax, QWORD PTR argv$[rsp]
  003f7	48 83 c0 08	 add	 rax, 8
  003fb	48 89 84 24 10
	02 00 00	 mov	 QWORD PTR argv$[rsp], rax

; 1063 : 
; 1064 :     if( strlen( remotep ) > 5 ||
; 1065 :         sscanf( remotep, "%u%c", &rport, &c ) != 1 ||
; 1066 :         rport < 1024 || rport > 65534 )

  00403	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR remotep$[rsp]
  0040b	e8 00 00 00 00	 call	 strlen
  00410	48 83 f8 05	 cmp	 rax, 5
  00414	77 3b		 ja	 SHORT $LN9@CTCT_Init
  00416	4c 8d 4c 24 60	 lea	 r9, QWORD PTR c$[rsp]
  0041b	4c 8d 44 24 70	 lea	 r8, QWORD PTR rport$[rsp]
  00420	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG169426
  00427	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR remotep$[rsp]
  0042f	e8 00 00 00 00	 call	 sscanf
  00434	83 f8 01	 cmp	 eax, 1
  00437	75 18		 jne	 SHORT $LN9@CTCT_Init
  00439	81 7c 24 70 00
	04 00 00	 cmp	 DWORD PTR rport$[rsp], 1024 ; 00000400H
  00441	7c 0e		 jl	 SHORT $LN9@CTCT_Init
  00443	81 7c 24 70 fe
	ff 00 00	 cmp	 DWORD PTR rport$[rsp], 65534 ; 0000fffeH
  0044b	0f 8e b4 00 00
	00		 jle	 $LN8@CTCT_Init
$LN9@CTCT_Init:

; 1067 :     {
; 1068 :         WRMSG(HHC00916, "E", SSID_TO_LCSS(dev->ssid), dev->devnum, "CTC", "port number", remotep);

  00451	48 8b 84 24 00
	02 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00459	0f b7 40 48	 movzx	 eax, WORD PTR [rax+72]
  0045d	89 84 24 98 00
	00 00		 mov	 DWORD PTR tv222[rsp], eax
  00464	48 8b 8c 24 00
	02 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  0046c	0f b7 49 44	 movzx	 ecx, WORD PTR [rcx+68]
  00470	d1 f9		 sar	 ecx, 1
  00472	89 8c 24 9c 00
	00 00		 mov	 DWORD PTR tv226[rsp], ecx
  00479	b9 01 00 00 00	 mov	 ecx, 1
  0047e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  00484	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR remotep$[rsp]
  0048c	48 89 4c 24 58	 mov	 QWORD PTR [rsp+88], rcx
  00491	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169427
  00498	48 89 4c 24 50	 mov	 QWORD PTR [rsp+80], rcx
  0049d	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169428
  004a4	48 89 4c 24 48	 mov	 QWORD PTR [rsp+72], rcx
  004a9	8b 8c 24 98 00
	00 00		 mov	 ecx, DWORD PTR tv222[rsp]
  004b0	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  004b4	8b 8c 24 9c 00
	00 00		 mov	 ecx, DWORD PTR tv226[rsp]
  004bb	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  004bf	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169429
  004c6	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  004cb	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169430
  004d2	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  004d7	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  004dc	41 b9 03 00 00
	00		 mov	 r9d, 3
  004e2	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG169431
  004e9	ba 2c 04 00 00	 mov	 edx, 1068		; 0000042cH
  004ee	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169432
  004f5	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 1069 :         return -1;

  004fb	b8 ff ff ff ff	 mov	 eax, -1
  00500	e9 13 0a 00 00	 jmp	 $LN1@CTCT_Init
$LN8@CTCT_Init:

; 1070 :     }
; 1071 : 
; 1072 :     // The fourth argument is the maximum transmission unit (MTU) size
; 1073 :     mtusize = *argv;

  00505	48 8b 84 24 10
	02 00 00	 mov	 rax, QWORD PTR argv$[rsp]
  0050d	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00510	48 89 84 24 f8
	00 00 00	 mov	 QWORD PTR mtusize$[rsp], rax

; 1074 : 
; 1075 :     if( strlen( mtusize ) > 5 ||
; 1076 :         sscanf( mtusize, "%u%c", &mtu, &c ) != 1 ||
; 1077 :         mtu < 46 || mtu > 65536 )

  00518	48 8b 8c 24 f8
	00 00 00	 mov	 rcx, QWORD PTR mtusize$[rsp]
  00520	e8 00 00 00 00	 call	 strlen
  00525	48 83 f8 05	 cmp	 rax, 5
  00529	77 38		 ja	 SHORT $LN11@CTCT_Init
  0052b	4c 8d 4c 24 60	 lea	 r9, QWORD PTR c$[rsp]
  00530	4c 8d 44 24 6c	 lea	 r8, QWORD PTR mtu$[rsp]
  00535	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG169435
  0053c	48 8b 8c 24 f8
	00 00 00	 mov	 rcx, QWORD PTR mtusize$[rsp]
  00544	e8 00 00 00 00	 call	 sscanf
  00549	83 f8 01	 cmp	 eax, 1
  0054c	75 15		 jne	 SHORT $LN11@CTCT_Init
  0054e	83 7c 24 6c 2e	 cmp	 DWORD PTR mtu$[rsp], 46	; 0000002eH
  00553	7c 0e		 jl	 SHORT $LN11@CTCT_Init
  00555	81 7c 24 6c 00
	00 01 00	 cmp	 DWORD PTR mtu$[rsp], 65536 ; 00010000H
  0055d	0f 8e b4 00 00
	00		 jle	 $LN10@CTCT_Init
$LN11@CTCT_Init:

; 1078 :     {
; 1079 :         WRMSG(HHC00916, "E", SSID_TO_LCSS(dev->ssid), dev->devnum, "CTC", "MTU size", mtusize);

  00563	48 8b 84 24 00
	02 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  0056b	0f b7 40 48	 movzx	 eax, WORD PTR [rax+72]
  0056f	89 84 24 a0 00
	00 00		 mov	 DWORD PTR tv252[rsp], eax
  00576	48 8b 8c 24 00
	02 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  0057e	0f b7 49 44	 movzx	 ecx, WORD PTR [rcx+68]
  00582	d1 f9		 sar	 ecx, 1
  00584	89 8c 24 a4 00
	00 00		 mov	 DWORD PTR tv256[rsp], ecx
  0058b	b9 01 00 00 00	 mov	 ecx, 1
  00590	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  00596	48 8b 8c 24 f8
	00 00 00	 mov	 rcx, QWORD PTR mtusize$[rsp]
  0059e	48 89 4c 24 58	 mov	 QWORD PTR [rsp+88], rcx
  005a3	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169436
  005aa	48 89 4c 24 50	 mov	 QWORD PTR [rsp+80], rcx
  005af	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169437
  005b6	48 89 4c 24 48	 mov	 QWORD PTR [rsp+72], rcx
  005bb	8b 8c 24 a0 00
	00 00		 mov	 ecx, DWORD PTR tv252[rsp]
  005c2	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  005c6	8b 8c 24 a4 00
	00 00		 mov	 ecx, DWORD PTR tv256[rsp]
  005cd	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  005d1	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169438
  005d8	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  005dd	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169439
  005e4	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  005e9	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  005ee	41 b9 03 00 00
	00		 mov	 r9d, 3
  005f4	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG169440
  005fb	ba 37 04 00 00	 mov	 edx, 1079		; 00000437H
  00600	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169441
  00607	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 1080 :         return -1;

  0060d	b8 ff ff ff ff	 mov	 eax, -1
  00612	e9 01 09 00 00	 jmp	 $LN1@CTCT_Init
$LN10@CTCT_Init:

; 1081 :     }
; 1082 : 
; 1083 :     // Set the device buffer size equal to the MTU size
; 1084 :     dev->bufsize = mtu;

  00617	48 8b 84 24 00
	02 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  0061f	8b 4c 24 6c	 mov	 ecx, DWORD PTR mtu$[rsp]
  00623	89 88 d8 01 00
	00		 mov	 DWORD PTR [rax+472], ecx

; 1085 : 
; 1086 :     // Initialize the file descriptor for the socket connection
; 1087 : 
; 1088 :     // It's a little confusing, but we're using a couple of the
; 1089 :     // members of the server paramter structure to initiate the
; 1090 :     // outgoing connection.  Saves a couple of variable declarations,
; 1091 :     // though.  If we feel strongly about it, we can declare separate
; 1092 :     // variables...
; 1093 : 
; 1094 :     // make a TCP socket
; 1095 :     parm.listenfd = socket( AF_INET, SOCK_STREAM, 0 );

  00629	45 33 c0	 xor	 r8d, r8d
  0062c	ba 01 00 00 00	 mov	 edx, 1
  00631	b9 02 00 00 00	 mov	 ecx, 2
  00636	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_socket
  0063c	89 84 24 48 01
	00 00		 mov	 DWORD PTR parm$[rsp], eax

; 1096 : 
; 1097 :     if( parm.listenfd < 0 )

  00643	83 bc 24 48 01
	00 00 00	 cmp	 DWORD PTR parm$[rsp], 0
  0064b	0f 8d d7 00 00
	00		 jge	 $LN12@CTCT_Init

; 1098 :     {
; 1099 :         WRMSG (HHC00900, "E", SSID_TO_LCSS(dev->ssid), dev->devnum, "CTC", "socket()", strerror( HSO_errno ) );

  00651	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_WSAGetLastError
  00657	8b c8		 mov	 ecx, eax
  00659	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_strerror
  0065f	48 89 84 24 18
	01 00 00	 mov	 QWORD PTR tv273[rsp], rax
  00667	48 8b 8c 24 00
	02 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  0066f	0f b7 49 48	 movzx	 ecx, WORD PTR [rcx+72]
  00673	89 8c 24 a8 00
	00 00		 mov	 DWORD PTR tv280[rsp], ecx
  0067a	48 8b 94 24 00
	02 00 00	 mov	 rdx, QWORD PTR dev$[rsp]
  00682	0f b7 52 44	 movzx	 edx, WORD PTR [rdx+68]
  00686	d1 fa		 sar	 edx, 1
  00688	89 94 24 ac 00
	00 00		 mov	 DWORD PTR tv284[rsp], edx
  0068f	b9 01 00 00 00	 mov	 ecx, 1
  00694	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  0069a	48 8b 8c 24 18
	01 00 00	 mov	 rcx, QWORD PTR tv273[rsp]
  006a2	48 89 4c 24 58	 mov	 QWORD PTR [rsp+88], rcx
  006a7	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169443
  006ae	48 89 4c 24 50	 mov	 QWORD PTR [rsp+80], rcx
  006b3	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169444
  006ba	48 89 4c 24 48	 mov	 QWORD PTR [rsp+72], rcx
  006bf	8b 8c 24 a8 00
	00 00		 mov	 ecx, DWORD PTR tv280[rsp]
  006c6	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  006ca	8b 8c 24 ac 00
	00 00		 mov	 ecx, DWORD PTR tv284[rsp]
  006d1	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  006d5	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169445
  006dc	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  006e1	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169446
  006e8	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  006ed	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  006f2	41 b9 03 00 00
	00		 mov	 r9d, 3
  006f8	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG169447
  006ff	ba 4b 04 00 00	 mov	 edx, 1099		; 0000044bH
  00704	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169448
  0070b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 1100 :         CTCX_Close( dev );

  00711	48 8b 8c 24 00
	02 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  00719	e8 00 00 00 00	 call	 CTCX_Close

; 1101 :         return -1;

  0071e	b8 ff ff ff ff	 mov	 eax, -1
  00723	e9 f0 07 00 00	 jmp	 $LN1@CTCT_Init
$LN12@CTCT_Init:

; 1102 :     }
; 1103 : 
; 1104 :     // bind socket to our local port
; 1105 :     // (might seem like overkill, and usually isn't done, but doing this
; 1106 :     // bind() to the local port we configure gives the other end a chance
; 1107 :     // at validating the connection request)
; 1108 :     memset( &(parm.addr), 0, sizeof( parm.addr ) );

  00728	48 8d 84 24 4c
	01 00 00	 lea	 rax, QWORD PTR parm$[rsp+4]
  00730	48 8b f8	 mov	 rdi, rax
  00733	33 c0		 xor	 eax, eax
  00735	b9 10 00 00 00	 mov	 ecx, 16
  0073a	f3 aa		 rep stosb

; 1109 :     parm.addr.sin_family      = AF_INET;

  0073c	b8 02 00 00 00	 mov	 eax, 2
  00741	66 89 84 24 4c
	01 00 00	 mov	 WORD PTR parm$[rsp+4], ax

; 1110 :     parm.addr.sin_port        = htons(lport);

  00749	0f b7 4c 24 68	 movzx	 ecx, WORD PTR lport$[rsp]
  0074e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_htons
  00754	66 89 84 24 4e
	01 00 00	 mov	 WORD PTR parm$[rsp+6], ax

; 1111 :     parm.addr.sin_addr.s_addr = htonl(INADDR_ANY);

  0075c	33 c9		 xor	 ecx, ecx
  0075e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_htonl
  00764	89 84 24 50 01
	00 00		 mov	 DWORD PTR parm$[rsp+8], eax

; 1112 : 
; 1113 :     rc = bind( parm.listenfd,

  0076b	48 63 84 24 48
	01 00 00	 movsxd	 rax, DWORD PTR parm$[rsp]
  00773	41 b8 10 00 00
	00		 mov	 r8d, 16
  00779	48 8d 94 24 4c
	01 00 00	 lea	 rdx, QWORD PTR parm$[rsp+4]
  00781	48 8b c8	 mov	 rcx, rax
  00784	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_bind
  0078a	89 44 24 64	 mov	 DWORD PTR rc$[rsp], eax

; 1114 :                (struct sockaddr *)&parm.addr,
; 1115 :                sizeof( parm.addr ) );
; 1116 :     if( rc < 0 )

  0078e	83 7c 24 64 00	 cmp	 DWORD PTR rc$[rsp], 0
  00793	0f 8d d7 00 00
	00		 jge	 $LN13@CTCT_Init

; 1117 :     {
; 1118 :         WRMSG( HHC00900, "E", SSID_TO_LCSS(dev->ssid), dev->devnum, "CTC", "bind()", strerror( HSO_errno ) );

  00799	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_WSAGetLastError
  0079f	8b c8		 mov	 ecx, eax
  007a1	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_strerror
  007a7	48 89 84 24 20
	01 00 00	 mov	 QWORD PTR tv342[rsp], rax
  007af	48 8b 8c 24 00
	02 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  007b7	0f b7 49 48	 movzx	 ecx, WORD PTR [rcx+72]
  007bb	89 8c 24 b0 00
	00 00		 mov	 DWORD PTR tv349[rsp], ecx
  007c2	48 8b 94 24 00
	02 00 00	 mov	 rdx, QWORD PTR dev$[rsp]
  007ca	0f b7 52 44	 movzx	 edx, WORD PTR [rdx+68]
  007ce	d1 fa		 sar	 edx, 1
  007d0	89 94 24 b4 00
	00 00		 mov	 DWORD PTR tv353[rsp], edx
  007d7	b9 01 00 00 00	 mov	 ecx, 1
  007dc	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  007e2	48 8b 8c 24 20
	01 00 00	 mov	 rcx, QWORD PTR tv342[rsp]
  007ea	48 89 4c 24 58	 mov	 QWORD PTR [rsp+88], rcx
  007ef	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169450
  007f6	48 89 4c 24 50	 mov	 QWORD PTR [rsp+80], rcx
  007fb	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169451
  00802	48 89 4c 24 48	 mov	 QWORD PTR [rsp+72], rcx
  00807	8b 8c 24 b0 00
	00 00		 mov	 ecx, DWORD PTR tv349[rsp]
  0080e	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  00812	8b 8c 24 b4 00
	00 00		 mov	 ecx, DWORD PTR tv353[rsp]
  00819	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  0081d	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169452
  00824	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  00829	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169453
  00830	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00835	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  0083a	41 b9 03 00 00
	00		 mov	 r9d, 3
  00840	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG169454
  00847	ba 5e 04 00 00	 mov	 edx, 1118		; 0000045eH
  0084c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169455
  00853	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 1119 :         CTCX_Close( dev );

  00859	48 8b 8c 24 00
	02 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  00861	e8 00 00 00 00	 call	 CTCX_Close

; 1120 :         return -1;

  00866	b8 ff ff ff ff	 mov	 eax, -1
  0086b	e9 a8 06 00 00	 jmp	 $LN1@CTCT_Init
$LN13@CTCT_Init:

; 1121 :     }
; 1122 : 
; 1123 :     // initiate a connection to the other end
; 1124 :     memset( &(parm.addr), 0, sizeof( parm.addr ) );

  00870	48 8d 84 24 4c
	01 00 00	 lea	 rax, QWORD PTR parm$[rsp+4]
  00878	48 8b f8	 mov	 rdi, rax
  0087b	33 c0		 xor	 eax, eax
  0087d	b9 10 00 00 00	 mov	 ecx, 16
  00882	f3 aa		 rep stosb

; 1125 :     parm.addr.sin_family = AF_INET;

  00884	b8 02 00 00 00	 mov	 eax, 2
  00889	66 89 84 24 4c
	01 00 00	 mov	 WORD PTR parm$[rsp+4], ax

; 1126 :     parm.addr.sin_port   = htons(rport);

  00891	0f b7 4c 24 70	 movzx	 ecx, WORD PTR rport$[rsp]
  00896	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_htons
  0089c	66 89 84 24 4e
	01 00 00	 mov	 WORD PTR parm$[rsp+6], ax

; 1127 :     parm.addr.sin_addr   = ipaddr;

  008a4	8b 44 24 74	 mov	 eax, DWORD PTR ipaddr$[rsp]
  008a8	89 84 24 50 01
	00 00		 mov	 DWORD PTR parm$[rsp+8], eax

; 1128 :     rc = connect( parm.listenfd,

  008af	48 63 84 24 48
	01 00 00	 movsxd	 rax, DWORD PTR parm$[rsp]
  008b7	41 b8 10 00 00
	00		 mov	 r8d, 16
  008bd	48 8d 94 24 4c
	01 00 00	 lea	 rdx, QWORD PTR parm$[rsp+4]
  008c5	48 8b c8	 mov	 rcx, rax
  008c8	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_connect
  008ce	89 44 24 64	 mov	 DWORD PTR rc$[rsp], eax

; 1129 :                   (struct sockaddr *)&parm.addr,
; 1130 :                   sizeof( parm.addr ) );
; 1131 : 
; 1132 :     // if connection was not successful, start a server
; 1133 :     if( rc < 0 )

  008d2	83 7c 24 64 00	 cmp	 DWORD PTR rc$[rsp], 0
  008d7	0f 8d 37 05 00
	00		 jge	 $LN14@CTCT_Init

; 1134 :     {
; 1135 :         // used to pass parameters to the server thread
; 1136 :         CTCG_PARMBLK* arg;
; 1137 : 
; 1138 :         WRMSG(HHC00971, "I", SSID_TO_LCSS(dev->ssid), dev->devnum, remaddr, remotep );

  008dd	48 8b 84 24 00
	02 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  008e5	0f b7 40 48	 movzx	 eax, WORD PTR [rax+72]
  008e9	89 84 24 b8 00
	00 00		 mov	 DWORD PTR tv380[rsp], eax
  008f0	48 8b 8c 24 00
	02 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  008f8	0f b7 49 44	 movzx	 ecx, WORD PTR [rcx+68]
  008fc	d1 f9		 sar	 ecx, 1
  008fe	89 8c 24 bc 00
	00 00		 mov	 DWORD PTR tv384[rsp], ecx
  00905	b9 01 00 00 00	 mov	 ecx, 1
  0090a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  00910	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR remotep$[rsp]
  00918	48 89 4c 24 50	 mov	 QWORD PTR [rsp+80], rcx
  0091d	48 8b 4c 24 78	 mov	 rcx, QWORD PTR remaddr$[rsp]
  00922	48 89 4c 24 48	 mov	 QWORD PTR [rsp+72], rcx
  00927	8b 8c 24 b8 00
	00 00		 mov	 ecx, DWORD PTR tv380[rsp]
  0092e	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  00932	8b 8c 24 bc 00
	00 00		 mov	 ecx, DWORD PTR tv384[rsp]
  00939	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  0093d	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169458
  00944	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  00949	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169459
  00950	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00955	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  0095a	41 b9 03 00 00
	00		 mov	 r9d, 3
  00960	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG169460
  00967	ba 72 04 00 00	 mov	 edx, 1138		; 00000472H
  0096c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169461
  00973	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 1139 : 
; 1140 :         // probably don't need to do this, not sure...
; 1141 :         close_socket( parm.listenfd );

  00979	8b 8c 24 48 01
	00 00		 mov	 ecx, DWORD PTR parm$[rsp]
  00980	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_close_socket

; 1142 : 
; 1143 :         parm.listenfd = socket( AF_INET, SOCK_STREAM, 0 );

  00986	45 33 c0	 xor	 r8d, r8d
  00989	ba 01 00 00 00	 mov	 edx, 1
  0098e	b9 02 00 00 00	 mov	 ecx, 2
  00993	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_socket
  00999	89 84 24 48 01
	00 00		 mov	 DWORD PTR parm$[rsp], eax

; 1144 : 
; 1145 :         if( parm.listenfd < 0 )

  009a0	83 bc 24 48 01
	00 00 00	 cmp	 DWORD PTR parm$[rsp], 0
  009a8	0f 8d d7 00 00
	00		 jge	 $LN16@CTCT_Init

; 1146 :         {
; 1147 :             WRMSG(HHC00900, "E", SSID_TO_LCSS(dev->ssid), dev->devnum, "CTC", "socket()", strerror( HSO_errno ) );

  009ae	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_WSAGetLastError
  009b4	8b c8		 mov	 ecx, eax
  009b6	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_strerror
  009bc	48 89 84 24 28
	01 00 00	 mov	 QWORD PTR tv401[rsp], rax
  009c4	48 8b 8c 24 00
	02 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  009cc	0f b7 49 48	 movzx	 ecx, WORD PTR [rcx+72]
  009d0	89 8c 24 c0 00
	00 00		 mov	 DWORD PTR tv408[rsp], ecx
  009d7	48 8b 94 24 00
	02 00 00	 mov	 rdx, QWORD PTR dev$[rsp]
  009df	0f b7 52 44	 movzx	 edx, WORD PTR [rdx+68]
  009e3	d1 fa		 sar	 edx, 1
  009e5	89 94 24 c4 00
	00 00		 mov	 DWORD PTR tv412[rsp], edx
  009ec	b9 01 00 00 00	 mov	 ecx, 1
  009f1	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  009f7	48 8b 8c 24 28
	01 00 00	 mov	 rcx, QWORD PTR tv401[rsp]
  009ff	48 89 4c 24 58	 mov	 QWORD PTR [rsp+88], rcx
  00a04	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169463
  00a0b	48 89 4c 24 50	 mov	 QWORD PTR [rsp+80], rcx
  00a10	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169464
  00a17	48 89 4c 24 48	 mov	 QWORD PTR [rsp+72], rcx
  00a1c	8b 8c 24 c0 00
	00 00		 mov	 ecx, DWORD PTR tv408[rsp]
  00a23	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  00a27	8b 8c 24 c4 00
	00 00		 mov	 ecx, DWORD PTR tv412[rsp]
  00a2e	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  00a32	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169465
  00a39	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  00a3e	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169466
  00a45	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00a4a	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00a4f	41 b9 03 00 00
	00		 mov	 r9d, 3
  00a55	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG169467
  00a5c	ba 7b 04 00 00	 mov	 edx, 1147		; 0000047bH
  00a61	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169468
  00a68	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 1148 :             CTCX_Close( dev );

  00a6e	48 8b 8c 24 00
	02 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  00a76	e8 00 00 00 00	 call	 CTCX_Close

; 1149 :             return -1;

  00a7b	b8 ff ff ff ff	 mov	 eax, -1
  00a80	e9 93 04 00 00	 jmp	 $LN1@CTCT_Init
$LN16@CTCT_Init:

; 1150 :         }
; 1151 : 
; 1152 :         // set up the listening port
; 1153 :         memset( &(parm.addr), 0, sizeof( parm.addr ) );

  00a85	48 8d 84 24 4c
	01 00 00	 lea	 rax, QWORD PTR parm$[rsp+4]
  00a8d	48 8b f8	 mov	 rdi, rax
  00a90	33 c0		 xor	 eax, eax
  00a92	b9 10 00 00 00	 mov	 ecx, 16
  00a97	f3 aa		 rep stosb

; 1154 : 
; 1155 :         parm.addr.sin_family      = AF_INET;

  00a99	b8 02 00 00 00	 mov	 eax, 2
  00a9e	66 89 84 24 4c
	01 00 00	 mov	 WORD PTR parm$[rsp+4], ax

; 1156 :         parm.addr.sin_port        = htons(lport);

  00aa6	0f b7 4c 24 68	 movzx	 ecx, WORD PTR lport$[rsp]
  00aab	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_htons
  00ab1	66 89 84 24 4e
	01 00 00	 mov	 WORD PTR parm$[rsp+6], ax

; 1157 :         parm.addr.sin_addr.s_addr = htonl(INADDR_ANY);

  00ab9	33 c9		 xor	 ecx, ecx
  00abb	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_htonl
  00ac1	89 84 24 50 01
	00 00		 mov	 DWORD PTR parm$[rsp+8], eax

; 1158 : 
; 1159 :         if( bind( parm.listenfd,
; 1160 :                   (struct sockaddr *)&parm.addr,
; 1161 :                   sizeof( parm.addr ) ) < 0 )

  00ac8	48 63 84 24 48
	01 00 00	 movsxd	 rax, DWORD PTR parm$[rsp]
  00ad0	41 b8 10 00 00
	00		 mov	 r8d, 16
  00ad6	48 8d 94 24 4c
	01 00 00	 lea	 rdx, QWORD PTR parm$[rsp+4]
  00ade	48 8b c8	 mov	 rcx, rax
  00ae1	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_bind
  00ae7	85 c0		 test	 eax, eax
  00ae9	0f 8d d7 00 00
	00		 jge	 $LN17@CTCT_Init

; 1162 :         {
; 1163 :             WRMSG(HHC00900, "E", SSID_TO_LCSS(dev->ssid), dev->devnum, "CTC", "bind()", strerror( HSO_errno ) );

  00aef	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_WSAGetLastError
  00af5	8b c8		 mov	 ecx, eax
  00af7	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_strerror
  00afd	48 89 84 24 30
	01 00 00	 mov	 QWORD PTR tv438[rsp], rax
  00b05	48 8b 8c 24 00
	02 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  00b0d	0f b7 49 48	 movzx	 ecx, WORD PTR [rcx+72]
  00b11	89 8c 24 c8 00
	00 00		 mov	 DWORD PTR tv445[rsp], ecx
  00b18	48 8b 94 24 00
	02 00 00	 mov	 rdx, QWORD PTR dev$[rsp]
  00b20	0f b7 52 44	 movzx	 edx, WORD PTR [rdx+68]
  00b24	d1 fa		 sar	 edx, 1
  00b26	89 94 24 cc 00
	00 00		 mov	 DWORD PTR tv449[rsp], edx
  00b2d	b9 01 00 00 00	 mov	 ecx, 1
  00b32	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  00b38	48 8b 8c 24 30
	01 00 00	 mov	 rcx, QWORD PTR tv438[rsp]
  00b40	48 89 4c 24 58	 mov	 QWORD PTR [rsp+88], rcx
  00b45	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169470
  00b4c	48 89 4c 24 50	 mov	 QWORD PTR [rsp+80], rcx
  00b51	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169471
  00b58	48 89 4c 24 48	 mov	 QWORD PTR [rsp+72], rcx
  00b5d	8b 8c 24 c8 00
	00 00		 mov	 ecx, DWORD PTR tv445[rsp]
  00b64	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  00b68	8b 8c 24 cc 00
	00 00		 mov	 ecx, DWORD PTR tv449[rsp]
  00b6f	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  00b73	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169472
  00b7a	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  00b7f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169473
  00b86	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00b8b	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00b90	41 b9 03 00 00
	00		 mov	 r9d, 3
  00b96	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG169474
  00b9d	ba 8b 04 00 00	 mov	 edx, 1163		; 0000048bH
  00ba2	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169475
  00ba9	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 1164 :             CTCX_Close( dev );

  00baf	48 8b 8c 24 00
	02 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  00bb7	e8 00 00 00 00	 call	 CTCX_Close

; 1165 :             return -1;

  00bbc	b8 ff ff ff ff	 mov	 eax, -1
  00bc1	e9 52 03 00 00	 jmp	 $LN1@CTCT_Init
$LN17@CTCT_Init:

; 1166 :         }
; 1167 : 
; 1168 :         if( listen( parm.listenfd, 1 ) < 0 )

  00bc6	48 63 84 24 48
	01 00 00	 movsxd	 rax, DWORD PTR parm$[rsp]
  00bce	ba 01 00 00 00	 mov	 edx, 1
  00bd3	48 8b c8	 mov	 rcx, rax
  00bd6	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_listen
  00bdc	85 c0		 test	 eax, eax
  00bde	0f 8d d7 00 00
	00		 jge	 $LN18@CTCT_Init

; 1169 :         {
; 1170 :             WRMSG(HHC00900, "E", SSID_TO_LCSS(dev->ssid), dev->devnum, "CTC", "listen()", strerror( HSO_errno ) );

  00be4	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_WSAGetLastError
  00bea	8b c8		 mov	 ecx, eax
  00bec	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_strerror
  00bf2	48 89 84 24 38
	01 00 00	 mov	 QWORD PTR tv466[rsp], rax
  00bfa	48 8b 8c 24 00
	02 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  00c02	0f b7 49 48	 movzx	 ecx, WORD PTR [rcx+72]
  00c06	89 8c 24 d0 00
	00 00		 mov	 DWORD PTR tv473[rsp], ecx
  00c0d	48 8b 94 24 00
	02 00 00	 mov	 rdx, QWORD PTR dev$[rsp]
  00c15	0f b7 52 44	 movzx	 edx, WORD PTR [rdx+68]
  00c19	d1 fa		 sar	 edx, 1
  00c1b	89 94 24 d4 00
	00 00		 mov	 DWORD PTR tv477[rsp], edx
  00c22	b9 01 00 00 00	 mov	 ecx, 1
  00c27	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  00c2d	48 8b 8c 24 38
	01 00 00	 mov	 rcx, QWORD PTR tv466[rsp]
  00c35	48 89 4c 24 58	 mov	 QWORD PTR [rsp+88], rcx
  00c3a	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169477
  00c41	48 89 4c 24 50	 mov	 QWORD PTR [rsp+80], rcx
  00c46	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169478
  00c4d	48 89 4c 24 48	 mov	 QWORD PTR [rsp+72], rcx
  00c52	8b 8c 24 d0 00
	00 00		 mov	 ecx, DWORD PTR tv473[rsp]
  00c59	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  00c5d	8b 8c 24 d4 00
	00 00		 mov	 ecx, DWORD PTR tv477[rsp]
  00c64	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  00c68	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169479
  00c6f	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  00c74	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169480
  00c7b	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00c80	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00c85	41 b9 03 00 00
	00		 mov	 r9d, 3
  00c8b	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG169481
  00c92	ba 92 04 00 00	 mov	 edx, 1170		; 00000492H
  00c97	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169482
  00c9e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 1171 :             CTCX_Close( dev );

  00ca4	48 8b 8c 24 00
	02 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  00cac	e8 00 00 00 00	 call	 CTCX_Close

; 1172 :             return -1;

  00cb1	b8 ff ff ff ff	 mov	 eax, -1
  00cb6	e9 5d 02 00 00	 jmp	 $LN1@CTCT_Init
$LN18@CTCT_Init:

; 1173 :         }
; 1174 : 
; 1175 :         // we are listening, so create a thread to accept connection
; 1176 :         arg = malloc( sizeof( CTCG_PARMBLK ) );

  00cbb	b9 20 00 00 00	 mov	 ecx, 32			; 00000020H
  00cc0	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_malloc
  00cc6	48 89 84 24 00
	01 00 00	 mov	 QWORD PTR arg$2[rsp], rax

; 1177 :         memcpy( arg, &parm, sizeof( parm ) );

  00cce	48 8d 84 24 48
	01 00 00	 lea	 rax, QWORD PTR parm$[rsp]
  00cd6	48 8b bc 24 00
	01 00 00	 mov	 rdi, QWORD PTR arg$2[rsp]
  00cde	48 8b f0	 mov	 rsi, rax
  00ce1	b9 20 00 00 00	 mov	 ecx, 32			; 00000020H
  00ce6	f3 a4		 rep movsb

; 1178 :         arg->dev = dev;

  00ce8	48 8b 84 24 00
	01 00 00	 mov	 rax, QWORD PTR arg$2[rsp]
  00cf0	48 8b 8c 24 00
	02 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  00cf8	48 89 48 18	 mov	 QWORD PTR [rax+24], rcx

; 1179 :         MSGBUF(str, "CTCT %4.4X ListenThread",dev->devnum);

  00cfc	48 8b 84 24 00
	02 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00d04	0f b7 40 48	 movzx	 eax, WORD PTR [rax+72]
  00d08	44 8b c8	 mov	 r9d, eax
  00d0b	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG169483
  00d12	ba 50 00 00 00	 mov	 edx, 80			; 00000050H
  00d17	48 8d 8c 24 80
	01 00 00	 lea	 rcx, QWORD PTR str$[rsp]
  00d1f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_snprintf

; 1180 :         str[sizeof(str)-1]=0;

  00d25	b8 01 00 00 00	 mov	 eax, 1
  00d2a	48 6b c0 4f	 imul	 rax, rax, 79		; 0000004fH
  00d2e	48 89 84 24 08
	01 00 00	 mov	 QWORD PTR $T3[rsp], rax
  00d36	48 83 bc 24 08
	01 00 00 50	 cmp	 QWORD PTR $T3[rsp], 80	; 00000050H
  00d3f	73 02		 jae	 SHORT $LN21@CTCT_Init
  00d41	eb 05		 jmp	 SHORT $LN22@CTCT_Init
$LN21@CTCT_Init:
  00d43	e8 00 00 00 00	 call	 __report_rangecheckfailure
$LN22@CTCT_Init:
  00d48	48 8b 84 24 08
	01 00 00	 mov	 rax, QWORD PTR $T3[rsp]
  00d50	c6 84 04 80 01
	00 00 00	 mov	 BYTE PTR str$[rsp+rax], 0

; 1181 :         rc = create_thread( &tid, JOINABLE, CTCT_ListenThread, arg, str );

  00d58	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00d5f	48 05 98 10 00
	00		 add	 rax, 4248		; 00001098H
  00d65	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169484
  00d6c	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00d71	48 8d 8c 24 80
	01 00 00	 lea	 rcx, QWORD PTR str$[rsp]
  00d79	48 89 4c 24 20	 mov	 QWORD PTR [rsp+32], rcx
  00d7e	4c 8b 8c 24 00
	01 00 00	 mov	 r9, QWORD PTR arg$2[rsp]
  00d86	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:CTCT_ListenThread
  00d8d	48 8b d0	 mov	 rdx, rax
  00d90	48 8d 8c 24 10
	01 00 00	 lea	 rcx, QWORD PTR tid$[rsp]
  00d98	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_create_thread
  00d9e	89 44 24 64	 mov	 DWORD PTR rc$[rsp], eax

; 1182 :         if(rc)

  00da2	83 7c 24 64 00	 cmp	 DWORD PTR rc$[rsp], 0
  00da7	74 66		 je	 SHORT $LN19@CTCT_Init

; 1183 :            WRMSG(HHC00102, "E", strerror(rc));

  00da9	8b 4c 24 64	 mov	 ecx, DWORD PTR rc$[rsp]
  00dad	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_strerror
  00db3	48 89 84 24 40
	01 00 00	 mov	 QWORD PTR tv552[rsp], rax
  00dbb	b9 01 00 00 00	 mov	 ecx, 1
  00dc0	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  00dc6	48 8b 8c 24 40
	01 00 00	 mov	 rcx, QWORD PTR tv552[rsp]
  00dce	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  00dd3	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169486
  00dda	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  00ddf	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169487
  00de6	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00deb	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00df0	41 b9 03 00 00
	00		 mov	 r9d, 3
  00df6	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG169488
  00dfd	ba 9f 04 00 00	 mov	 edx, 1183		; 0000049fH
  00e02	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169489
  00e09	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg
$LN19@CTCT_Init:

; 1184 :     }

  00e0f	e9 b1 00 00 00	 jmp	 $LN15@CTCT_Init
$LN14@CTCT_Init:

; 1185 :     else  // successfully connected (outbound) to the other end
; 1186 :     {
; 1187 :         WRMSG(HHC00972, "I", SSID_TO_LCSS(dev->ssid), dev->devnum, remaddr, remotep );

  00e14	48 8b 84 24 00
	02 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00e1c	0f b7 40 48	 movzx	 eax, WORD PTR [rax+72]
  00e20	89 84 24 d8 00
	00 00		 mov	 DWORD PTR tv567[rsp], eax
  00e27	48 8b 8c 24 00
	02 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  00e2f	0f b7 49 44	 movzx	 ecx, WORD PTR [rcx+68]
  00e33	d1 f9		 sar	 ecx, 1
  00e35	89 8c 24 dc 00
	00 00		 mov	 DWORD PTR tv571[rsp], ecx
  00e3c	b9 01 00 00 00	 mov	 ecx, 1
  00e41	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  00e47	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR remotep$[rsp]
  00e4f	48 89 4c 24 50	 mov	 QWORD PTR [rsp+80], rcx
  00e54	48 8b 4c 24 78	 mov	 rcx, QWORD PTR remaddr$[rsp]
  00e59	48 89 4c 24 48	 mov	 QWORD PTR [rsp+72], rcx
  00e5e	8b 8c 24 d8 00
	00 00		 mov	 ecx, DWORD PTR tv567[rsp]
  00e65	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  00e69	8b 8c 24 dc 00
	00 00		 mov	 ecx, DWORD PTR tv571[rsp]
  00e70	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  00e74	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169490
  00e7b	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  00e80	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169491
  00e87	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00e8c	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00e91	41 b9 03 00 00
	00		 mov	 r9d, 3
  00e97	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG169492
  00e9e	ba a3 04 00 00	 mov	 edx, 1187		; 000004a3H
  00ea3	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169493
  00eaa	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 1188 :         dev->fd = parm.listenfd;

  00eb0	48 8b 84 24 00
	02 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00eb8	8b 8c 24 48 01
	00 00		 mov	 ecx, DWORD PTR parm$[rsp]
  00ebf	89 88 ac 01 00
	00		 mov	 DWORD PTR [rax+428], ecx
$LN15@CTCT_Init:

; 1189 :     }
; 1190 : 
; 1191 :     // for cosmetics, since we are successfully connected or serving,
; 1192 :     // fill in some details for the panel.
; 1193 :     MSGBUF( dev->filename, "%s:%s", remaddr, remotep );

  00ec5	48 8b 84 24 00
	02 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00ecd	48 05 a4 00 00
	00		 add	 rax, 164		; 000000a4H
  00ed3	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR remotep$[rsp]
  00edb	48 89 4c 24 20	 mov	 QWORD PTR [rsp+32], rcx
  00ee0	4c 8b 4c 24 78	 mov	 r9, QWORD PTR remaddr$[rsp]
  00ee5	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG169494
  00eec	ba 05 01 00 00	 mov	 edx, 261		; 00000105H
  00ef1	48 8b c8	 mov	 rcx, rax
  00ef4	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_snprintf

; 1194 :     dev->filename[sizeof(dev->filename)-1] = '\0';

  00efa	b8 01 00 00 00	 mov	 eax, 1
  00eff	48 69 c0 04 01
	00 00		 imul	 rax, rax, 260		; 00000104H
  00f06	48 8b 8c 24 00
	02 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  00f0e	c6 84 01 a4 00
	00 00 00	 mov	 BYTE PTR [rcx+rax+164], 0

; 1195 :     return 0;

  00f16	33 c0		 xor	 eax, eax
$LN1@CTCT_Init:
$LN20@CTCT_Init:

; 1196 : }

  00f18	48 8b 8c 24 d0
	01 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  00f20	48 33 cc	 xor	 rcx, rsp
  00f23	e8 00 00 00 00	 call	 __security_check_cookie
  00f28	48 81 c4 e8 01
	00 00		 add	 rsp, 488		; 000001e8H
  00f2f	5f		 pop	 rdi
  00f30	5e		 pop	 rsi
  00f31	c3		 ret	 0
CTCT_Init ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\ctcadpt.h
_TEXT	SEGMENT
tv87 = 0
pSIDInfo$ = 8
pDEVBLK$ = 32
bOffset$ = 40
bCIWType$ = 48
bCIWOp$ = 56
wCIWCount$ = 64
SetCIWInfo PROC

; 1370 : {

  00000	44 88 4c 24 20	 mov	 BYTE PTR [rsp+32], r9b
  00005	44 88 44 24 18	 mov	 BYTE PTR [rsp+24], r8b
  0000a	66 89 54 24 10	 mov	 WORD PTR [rsp+16], dx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	48 83 ec 18	 sub	 rsp, 24

; 1371 :     BYTE* pSIDInfo = pDEVBLK->devid;

  00018	48 8b 44 24 20	 mov	 rax, QWORD PTR pDEVBLK$[rsp]
  0001d	48 05 68 04 00
	00		 add	 rax, 1128		; 00000468H
  00023	48 89 44 24 08	 mov	 QWORD PTR pSIDInfo$[rsp], rax

; 1372 : 
; 1373 :     pSIDInfo += 8;

  00028	48 8b 44 24 08	 mov	 rax, QWORD PTR pSIDInfo$[rsp]
  0002d	48 83 c0 08	 add	 rax, 8
  00031	48 89 44 24 08	 mov	 QWORD PTR pSIDInfo$[rsp], rax

; 1374 :     pSIDInfo += ( bOffset * 4 );

  00036	0f b7 44 24 28	 movzx	 eax, WORD PTR bOffset$[rsp]
  0003b	c1 e0 02	 shl	 eax, 2
  0003e	48 98		 cdqe
  00040	48 8b 4c 24 08	 mov	 rcx, QWORD PTR pSIDInfo$[rsp]
  00045	48 03 c8	 add	 rcx, rax
  00048	48 8b c1	 mov	 rax, rcx
  0004b	48 89 44 24 08	 mov	 QWORD PTR pSIDInfo$[rsp], rax

; 1375 : 
; 1376 :     *pSIDInfo++ = bCIWType | 0x40;

  00050	0f b6 44 24 30	 movzx	 eax, BYTE PTR bCIWType$[rsp]
  00055	83 c8 40	 or	 eax, 64			; 00000040H
  00058	48 8b 4c 24 08	 mov	 rcx, QWORD PTR pSIDInfo$[rsp]
  0005d	88 01		 mov	 BYTE PTR [rcx], al
  0005f	48 8b 44 24 08	 mov	 rax, QWORD PTR pSIDInfo$[rsp]
  00064	48 ff c0	 inc	 rax
  00067	48 89 44 24 08	 mov	 QWORD PTR pSIDInfo$[rsp], rax

; 1377 :     *pSIDInfo++ = bCIWOp;

  0006c	48 8b 44 24 08	 mov	 rax, QWORD PTR pSIDInfo$[rsp]
  00071	0f b6 4c 24 38	 movzx	 ecx, BYTE PTR bCIWOp$[rsp]
  00076	88 08		 mov	 BYTE PTR [rax], cl
  00078	48 8b 44 24 08	 mov	 rax, QWORD PTR pSIDInfo$[rsp]
  0007d	48 ff c0	 inc	 rax
  00080	48 89 44 24 08	 mov	 QWORD PTR pSIDInfo$[rsp], rax

; 1378 :     *pSIDInfo++ = (BYTE)(( wCIWCount >> 8 ) & 0x00FF );

  00085	0f b7 44 24 40	 movzx	 eax, WORD PTR wCIWCount$[rsp]
  0008a	c1 f8 08	 sar	 eax, 8
  0008d	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  00092	48 8b 4c 24 08	 mov	 rcx, QWORD PTR pSIDInfo$[rsp]
  00097	88 01		 mov	 BYTE PTR [rcx], al
  00099	48 8b 44 24 08	 mov	 rax, QWORD PTR pSIDInfo$[rsp]
  0009e	48 ff c0	 inc	 rax
  000a1	48 89 44 24 08	 mov	 QWORD PTR pSIDInfo$[rsp], rax

; 1379 :     *pSIDInfo++ = (BYTE)( wCIWCount & 0x00FF );

  000a6	0f b7 44 24 40	 movzx	 eax, WORD PTR wCIWCount$[rsp]
  000ab	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  000b0	48 8b 4c 24 08	 mov	 rcx, QWORD PTR pSIDInfo$[rsp]
  000b5	88 01		 mov	 BYTE PTR [rcx], al
  000b7	48 8b 44 24 08	 mov	 rax, QWORD PTR pSIDInfo$[rsp]
  000bc	48 ff c0	 inc	 rax
  000bf	48 89 44 24 08	 mov	 QWORD PTR pSIDInfo$[rsp], rax

; 1380 : 
; 1381 :     pDEVBLK->numdevid += pDEVBLK->numdevid == 7 ? 5 : 4;

  000c4	48 8b 44 24 20	 mov	 rax, QWORD PTR pDEVBLK$[rsp]
  000c9	83 b8 64 04 00
	00 07		 cmp	 DWORD PTR [rax+1124], 7
  000d0	75 09		 jne	 SHORT $LN3@SetCIWInfo
  000d2	c7 04 24 05 00
	00 00		 mov	 DWORD PTR tv87[rsp], 5
  000d9	eb 07		 jmp	 SHORT $LN4@SetCIWInfo
$LN3@SetCIWInfo:
  000db	c7 04 24 04 00
	00 00		 mov	 DWORD PTR tv87[rsp], 4
$LN4@SetCIWInfo:
  000e2	48 8b 44 24 20	 mov	 rax, QWORD PTR pDEVBLK$[rsp]
  000e7	8b 80 64 04 00
	00		 mov	 eax, DWORD PTR [rax+1124]
  000ed	03 04 24	 add	 eax, DWORD PTR tv87[rsp]
  000f0	48 8b 4c 24 20	 mov	 rcx, QWORD PTR pDEVBLK$[rsp]
  000f5	89 81 64 04 00
	00		 mov	 DWORD PTR [rcx+1124], eax

; 1382 : }

  000fb	48 83 c4 18	 add	 rsp, 24
  000ff	c3		 ret	 0
SetCIWInfo ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\ctcadpt.h
_TEXT	SEGMENT
pSIDInfo$ = 0
pDEVBLK$ = 32
wCUType$ = 40
bCUMod$ = 48
wDevType$ = 56
bDevMod$ = 64
SetSIDInfo PROC

; 1343 : {

  00000	66 44 89 4c 24
	20		 mov	 WORD PTR [rsp+32], r9w
  00006	44 88 44 24 18	 mov	 BYTE PTR [rsp+24], r8b
  0000b	66 89 54 24 10	 mov	 WORD PTR [rsp+16], dx
  00010	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00015	57		 push	 rdi
  00016	48 83 ec 10	 sub	 rsp, 16

; 1344 :     BYTE* pSIDInfo = pDEVBLK->devid;

  0001a	48 8b 44 24 20	 mov	 rax, QWORD PTR pDEVBLK$[rsp]
  0001f	48 05 68 04 00
	00		 add	 rax, 1128		; 00000468H
  00025	48 89 04 24	 mov	 QWORD PTR pSIDInfo$[rsp], rax

; 1345 : 
; 1346 :     memset( pSIDInfo, 0, sizeof(pDEVBLK->devid) );

  00029	48 8b 3c 24	 mov	 rdi, QWORD PTR pSIDInfo$[rsp]
  0002d	33 c0		 xor	 eax, eax
  0002f	b9 00 01 00 00	 mov	 ecx, 256		; 00000100H
  00034	f3 aa		 rep stosb

; 1347 : 
; 1348 :     *pSIDInfo++ = 0x0FF;

  00036	48 8b 04 24	 mov	 rax, QWORD PTR pSIDInfo$[rsp]
  0003a	c6 00 ff	 mov	 BYTE PTR [rax], 255	; 000000ffH
  0003d	48 8b 04 24	 mov	 rax, QWORD PTR pSIDInfo$[rsp]
  00041	48 ff c0	 inc	 rax
  00044	48 89 04 24	 mov	 QWORD PTR pSIDInfo$[rsp], rax

; 1349 :     *pSIDInfo++ = (BYTE)(( wCUType >> 8 ) & 0x00FF );

  00048	0f b7 44 24 28	 movzx	 eax, WORD PTR wCUType$[rsp]
  0004d	c1 f8 08	 sar	 eax, 8
  00050	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  00055	48 8b 0c 24	 mov	 rcx, QWORD PTR pSIDInfo$[rsp]
  00059	88 01		 mov	 BYTE PTR [rcx], al
  0005b	48 8b 04 24	 mov	 rax, QWORD PTR pSIDInfo$[rsp]
  0005f	48 ff c0	 inc	 rax
  00062	48 89 04 24	 mov	 QWORD PTR pSIDInfo$[rsp], rax

; 1350 :     *pSIDInfo++ = (BYTE)( wCUType & 0x00FF );

  00066	0f b7 44 24 28	 movzx	 eax, WORD PTR wCUType$[rsp]
  0006b	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  00070	48 8b 0c 24	 mov	 rcx, QWORD PTR pSIDInfo$[rsp]
  00074	88 01		 mov	 BYTE PTR [rcx], al
  00076	48 8b 04 24	 mov	 rax, QWORD PTR pSIDInfo$[rsp]
  0007a	48 ff c0	 inc	 rax
  0007d	48 89 04 24	 mov	 QWORD PTR pSIDInfo$[rsp], rax

; 1351 :     *pSIDInfo++ = bCUMod;

  00081	48 8b 04 24	 mov	 rax, QWORD PTR pSIDInfo$[rsp]
  00085	0f b6 4c 24 30	 movzx	 ecx, BYTE PTR bCUMod$[rsp]
  0008a	88 08		 mov	 BYTE PTR [rax], cl
  0008c	48 8b 04 24	 mov	 rax, QWORD PTR pSIDInfo$[rsp]
  00090	48 ff c0	 inc	 rax
  00093	48 89 04 24	 mov	 QWORD PTR pSIDInfo$[rsp], rax

; 1352 :     *pSIDInfo++ = (BYTE)(( wDevType >> 8 ) & 0x00FF );

  00097	0f b7 44 24 38	 movzx	 eax, WORD PTR wDevType$[rsp]
  0009c	c1 f8 08	 sar	 eax, 8
  0009f	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  000a4	48 8b 0c 24	 mov	 rcx, QWORD PTR pSIDInfo$[rsp]
  000a8	88 01		 mov	 BYTE PTR [rcx], al
  000aa	48 8b 04 24	 mov	 rax, QWORD PTR pSIDInfo$[rsp]
  000ae	48 ff c0	 inc	 rax
  000b1	48 89 04 24	 mov	 QWORD PTR pSIDInfo$[rsp], rax

; 1353 :     *pSIDInfo++ = (BYTE)( wDevType & 0x00FF );

  000b5	0f b7 44 24 38	 movzx	 eax, WORD PTR wDevType$[rsp]
  000ba	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  000bf	48 8b 0c 24	 mov	 rcx, QWORD PTR pSIDInfo$[rsp]
  000c3	88 01		 mov	 BYTE PTR [rcx], al
  000c5	48 8b 04 24	 mov	 rax, QWORD PTR pSIDInfo$[rsp]
  000c9	48 ff c0	 inc	 rax
  000cc	48 89 04 24	 mov	 QWORD PTR pSIDInfo$[rsp], rax

; 1354 :     *pSIDInfo++ = bDevMod;

  000d0	48 8b 04 24	 mov	 rax, QWORD PTR pSIDInfo$[rsp]
  000d4	0f b6 4c 24 40	 movzx	 ecx, BYTE PTR bDevMod$[rsp]
  000d9	88 08		 mov	 BYTE PTR [rax], cl
  000db	48 8b 04 24	 mov	 rax, QWORD PTR pSIDInfo$[rsp]
  000df	48 ff c0	 inc	 rax
  000e2	48 89 04 24	 mov	 QWORD PTR pSIDInfo$[rsp], rax

; 1355 :     *pSIDInfo++ = 0x00;

  000e6	48 8b 04 24	 mov	 rax, QWORD PTR pSIDInfo$[rsp]
  000ea	c6 00 00	 mov	 BYTE PTR [rax], 0
  000ed	48 8b 04 24	 mov	 rax, QWORD PTR pSIDInfo$[rsp]
  000f1	48 ff c0	 inc	 rax
  000f4	48 89 04 24	 mov	 QWORD PTR pSIDInfo$[rsp], rax

; 1356 : 
; 1357 :     pDEVBLK->numdevid = 7;

  000f8	48 8b 44 24 20	 mov	 rax, QWORD PTR pDEVBLK$[rsp]
  000fd	c7 80 64 04 00
	00 07 00 00 00	 mov	 DWORD PTR [rax+1124], 7

; 1358 : }

  00107	48 83 c4 10	 add	 rsp, 16
  0010b	5f		 pop	 rdi
  0010c	c3		 ret	 0
SetSIDInfo ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\ctcadpt.c
_TEXT	SEGMENT
$T1 = 80
tv128 = 88
tv133 = 96
tv137 = 104
filename$ = 112
__$ArrayPad$ = 384
pDEVBLK$ = 416
ppszClass$ = 424
iBufLen$ = 432
pBuffer$ = 440
CTCE_Query PROC

; 1516 : {

$LN17:
  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	48 81 ec 98 01
	00 00		 sub	 rsp, 408		; 00000198H
  0001b	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00022	48 33 c4	 xor	 rax, rsp
  00025	48 89 84 24 80
	01 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 1517 : 
; 1518 :     char  filename[ PATH_MAX + 1 ];     /* full path or just name    */
; 1519 : 
; 1520 :     BEGIN_DEVICE_CLASS_QUERY( "CTCA", pDEVBLK, ppszClass, iBufLen, pBuffer );

  0002d	48 83 bc 24 a8
	01 00 00 00	 cmp	 QWORD PTR ppszClass$[rsp], 0
  00036	74 12		 je	 SHORT $LN2@CTCE_Query
  00038	48 8b 84 24 a8
	01 00 00	 mov	 rax, QWORD PTR ppszClass$[rsp]
  00040	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169671
  00047	48 89 08	 mov	 QWORD PTR [rax], rcx
$LN2@CTCE_Query:
  0004a	48 83 bc 24 a0
	01 00 00 00	 cmp	 QWORD PTR pDEVBLK$[rsp], 0
  00053	74 20		 je	 SHORT $LN4@CTCE_Query
  00055	48 83 bc 24 a8
	01 00 00 00	 cmp	 QWORD PTR ppszClass$[rsp], 0
  0005e	74 15		 je	 SHORT $LN4@CTCE_Query
  00060	83 bc 24 b0 01
	00 00 00	 cmp	 DWORD PTR iBufLen$[rsp], 0
  00068	74 0b		 je	 SHORT $LN4@CTCE_Query
  0006a	48 83 bc 24 b8
	01 00 00 00	 cmp	 QWORD PTR pBuffer$[rsp], 0
  00073	75 05		 jne	 SHORT $LN3@CTCE_Query
$LN4@CTCE_Query:
  00075	e9 a7 01 00 00	 jmp	 $LN1@CTCE_Query
$LN3@CTCE_Query:
  0007a	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00081	8b 80 94 12 00
	00		 mov	 eax, DWORD PTR [rax+4756]
  00087	c1 e8 1a	 shr	 eax, 26
  0008a	83 e0 01	 and	 eax, 1
  0008d	85 c0		 test	 eax, eax
  0008f	74 6c		 je	 SHORT $LN5@CTCE_Query
  00091	48 8b 84 24 a0
	01 00 00	 mov	 rax, QWORD PTR pDEVBLK$[rsp]
  00099	48 05 a4 00 00
	00		 add	 rax, 164		; 000000a4H
  0009f	48 8b c8	 mov	 rcx, rax
  000a2	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_basename
  000a8	41 b8 05 01 00
	00		 mov	 r8d, 261		; 00000105H
  000ae	48 8b d0	 mov	 rdx, rax
  000b1	48 8d 4c 24 70	 lea	 rcx, QWORD PTR filename$[rsp]
  000b6	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_strlcpy
  000bc	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG169677
  000c3	48 8d 4c 24 70	 lea	 rcx, QWORD PTR filename$[rsp]
  000c8	e8 00 00 00 00	 call	 strcmp
  000cd	85 c0		 test	 eax, eax
  000cf	75 2a		 jne	 SHORT $LN7@CTCE_Query
  000d1	b8 01 00 00 00	 mov	 eax, 1
  000d6	48 6b c0 00	 imul	 rax, rax, 0
  000da	48 89 44 24 50	 mov	 QWORD PTR $T1[rsp], rax
  000df	48 81 7c 24 50
	05 01 00 00	 cmp	 QWORD PTR $T1[rsp], 261	; 00000105H
  000e8	73 02		 jae	 SHORT $LN9@CTCE_Query
  000ea	eb 05		 jmp	 SHORT $LN10@CTCE_Query
$LN9@CTCE_Query:
  000ec	e8 00 00 00 00	 call	 __report_rangecheckfailure
$LN10@CTCE_Query:
  000f1	48 8b 44 24 50	 mov	 rax, QWORD PTR $T1[rsp]
  000f6	c6 44 04 70 00	 mov	 BYTE PTR filename$[rsp+rax], 0
$LN7@CTCE_Query:
  000fb	eb 22		 jmp	 SHORT $LN6@CTCE_Query
$LN5@CTCE_Query:
  000fd	48 8b 84 24 a0
	01 00 00	 mov	 rax, QWORD PTR pDEVBLK$[rsp]
  00105	48 05 a4 00 00
	00		 add	 rax, 164		; 000000a4H
  0010b	41 b8 05 01 00
	00		 mov	 r8d, 261		; 00000105H
  00111	48 8b d0	 mov	 rdx, rax
  00114	48 8d 4c 24 70	 lea	 rcx, QWORD PTR filename$[rsp]
  00119	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_strlcpy
$LN6@CTCE_Query:

; 1521 : 
; 1522 :     snprintf( pBuffer, iBufLen, "CTCE %05d/%d %s%s%s %s IO[%"PRIu64"]",

  0011f	48 8b 84 24 a0
	01 00 00	 mov	 rax, QWORD PTR pDEVBLK$[rsp]
  00127	83 b8 ac 01 00
	00 00		 cmp	 DWORD PTR [rax+428], 0
  0012e	7e 0e		 jle	 SHORT $LN11@CTCE_Query
  00130	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG169678
  00137	48 89 44 24 58	 mov	 QWORD PTR tv128[rsp], rax
  0013c	eb 0c		 jmp	 SHORT $LN12@CTCE_Query
$LN11@CTCE_Query:
  0013e	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG169679
  00145	48 89 44 24 58	 mov	 QWORD PTR tv128[rsp], rax
$LN12@CTCE_Query:
  0014a	48 8b 84 24 a0
	01 00 00	 mov	 rax, QWORD PTR pDEVBLK$[rsp]
  00152	8b 80 74 07 00
	00		 mov	 eax, DWORD PTR [rax+1908]
  00158	83 e0 01	 and	 eax, 1
  0015b	85 c0		 test	 eax, eax
  0015d	74 0e		 je	 SHORT $LN13@CTCE_Query
  0015f	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG169680
  00166	48 89 44 24 60	 mov	 QWORD PTR tv133[rsp], rax
  0016b	eb 0c		 jmp	 SHORT $LN14@CTCE_Query
$LN13@CTCE_Query:
  0016d	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG169681
  00174	48 89 44 24 60	 mov	 QWORD PTR tv133[rsp], rax
$LN14@CTCE_Query:
  00179	48 8b 84 24 a0
	01 00 00	 mov	 rax, QWORD PTR pDEVBLK$[rsp]
  00181	83 b8 3c 07 00
	00 00		 cmp	 DWORD PTR [rax+1852], 0
  00188	7e 0e		 jle	 SHORT $LN15@CTCE_Query
  0018a	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG169682
  00191	48 89 44 24 68	 mov	 QWORD PTR tv137[rsp], rax
  00196	eb 0c		 jmp	 SHORT $LN16@CTCE_Query
$LN15@CTCE_Query:
  00198	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG169683
  0019f	48 89 44 24 68	 mov	 QWORD PTR tv137[rsp], rax
$LN16@CTCE_Query:
  001a4	48 63 84 24 b0
	01 00 00	 movsxd	 rax, DWORD PTR iBufLen$[rsp]
  001ac	48 8b 8c 24 a0
	01 00 00	 mov	 rcx, QWORD PTR pDEVBLK$[rsp]
  001b4	48 8b 89 00 06
	00 00		 mov	 rcx, QWORD PTR [rcx+1536]
  001bb	48 89 4c 24 48	 mov	 QWORD PTR [rsp+72], rcx
  001c0	48 8d 4c 24 70	 lea	 rcx, QWORD PTR filename$[rsp]
  001c5	48 89 4c 24 40	 mov	 QWORD PTR [rsp+64], rcx
  001ca	48 8b 4c 24 58	 mov	 rcx, QWORD PTR tv128[rsp]
  001cf	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  001d4	48 8b 4c 24 60	 mov	 rcx, QWORD PTR tv133[rsp]
  001d9	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  001de	48 8b 4c 24 68	 mov	 rcx, QWORD PTR tv137[rsp]
  001e3	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  001e8	48 8b 8c 24 a0
	01 00 00	 mov	 rcx, QWORD PTR pDEVBLK$[rsp]
  001f0	8b 89 54 07 00
	00		 mov	 ecx, DWORD PTR [rcx+1876]
  001f6	89 4c 24 20	 mov	 DWORD PTR [rsp+32], ecx
  001fa	48 8b 8c 24 a0
	01 00 00	 mov	 rcx, QWORD PTR pDEVBLK$[rsp]
  00202	44 8b 89 50 07
	00 00		 mov	 r9d, DWORD PTR [rcx+1872]
  00209	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG169684
  00210	48 8b d0	 mov	 rdx, rax
  00213	48 8b 8c 24 b8
	01 00 00	 mov	 rcx, QWORD PTR pBuffer$[rsp]
  0021b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_snprintf
$LN1@CTCE_Query:
$LN8@CTCE_Query:

; 1523 :         pDEVBLK->ctce_lport, pDEVBLK->ctce_connect_lport,
; 1524 :         ( pDEVBLK->ctcefd > 0           ) ? "<" : "!",
; 1525 :         ( pDEVBLK->ctce_contention_loser) ? "-" : "=",
; 1526 :         ( pDEVBLK->fd     > 0           ) ? ">" : "!",
; 1527 :         filename     , pDEVBLK->excps );
; 1528 : }

  00221	48 8b 8c 24 80
	01 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  00229	48 33 cc	 xor	 rcx, rsp
  0022c	e8 00 00 00 00	 call	 __security_check_cookie
  00231	48 81 c4 98 01
	00 00		 add	 rsp, 408		; 00000198H
  00238	c3		 ret	 0
CTCE_Query ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\ctcadpt.c
_TEXT	SEGMENT
pDEVBLK$ = 48
CTCE_Close PROC

; 1535 : {

$LN5:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 1536 : 
; 1537 :     // Close the device file (if not already closed)
; 1538 :     if ( pDEVBLK->fd >= 0 )

  00009	48 8b 44 24 30	 mov	 rax, QWORD PTR pDEVBLK$[rsp]
  0000e	83 b8 ac 01 00
	00 00		 cmp	 DWORD PTR [rax+428], 0
  00015	7c 3a		 jl	 SHORT $LN2@CTCE_Close

; 1539 :     {
; 1540 :         {
; 1541 :             shutdown( pDEVBLK->fd, SHUT_RDWR );

  00017	48 8b 44 24 30	 mov	 rax, QWORD PTR pDEVBLK$[rsp]
  0001c	48 63 80 ac 01
	00 00		 movsxd	 rax, DWORD PTR [rax+428]
  00023	ba 02 00 00 00	 mov	 edx, 2
  00028	48 8b c8	 mov	 rcx, rax
  0002b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_shutdown

; 1542 :             close_socket( pDEVBLK->fd );

  00031	48 8b 44 24 30	 mov	 rax, QWORD PTR pDEVBLK$[rsp]
  00036	8b 88 ac 01 00
	00		 mov	 ecx, DWORD PTR [rax+428]
  0003c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_close_socket

; 1543 :         }
; 1544 :         pDEVBLK->fd = -1;           // indicate we're now closed

  00042	48 8b 44 24 30	 mov	 rax, QWORD PTR pDEVBLK$[rsp]
  00047	c7 80 ac 01 00
	00 ff ff ff ff	 mov	 DWORD PTR [rax+428], -1
$LN2@CTCE_Close:

; 1545 :     }
; 1546 : 
; 1547 :     // And the same for the receiving socket read device file
; 1548 :     if ( pDEVBLK->ctcefd >= 0 )

  00051	48 8b 44 24 30	 mov	 rax, QWORD PTR pDEVBLK$[rsp]
  00056	83 b8 3c 07 00
	00 00		 cmp	 DWORD PTR [rax+1852], 0
  0005d	7c 3a		 jl	 SHORT $LN3@CTCE_Close

; 1549 :     {
; 1550 :         {
; 1551 :             shutdown( pDEVBLK->ctcefd, SHUT_RDWR );

  0005f	48 8b 44 24 30	 mov	 rax, QWORD PTR pDEVBLK$[rsp]
  00064	48 63 80 3c 07
	00 00		 movsxd	 rax, DWORD PTR [rax+1852]
  0006b	ba 02 00 00 00	 mov	 edx, 2
  00070	48 8b c8	 mov	 rcx, rax
  00073	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_shutdown

; 1552 :             close_socket( pDEVBLK->ctcefd );

  00079	48 8b 44 24 30	 mov	 rax, QWORD PTR pDEVBLK$[rsp]
  0007e	8b 88 3c 07 00
	00		 mov	 ecx, DWORD PTR [rax+1852]
  00084	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_close_socket

; 1553 :         }
; 1554 :         pDEVBLK->ctcefd = -1;

  0008a	48 8b 44 24 30	 mov	 rax, QWORD PTR pDEVBLK$[rsp]
  0008f	c7 80 3c 07 00
	00 ff ff ff ff	 mov	 DWORD PTR [rax+1852], -1
$LN3@CTCE_Close:

; 1555 :     }
; 1556 : 
; 1557 :     return 0;

  00099	33 c0		 xor	 eax, eax

; 1558 : }

  0009b	48 83 c4 28	 add	 rsp, 40			; 00000028H
  0009f	c3		 ret	 0
CTCE_Close ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\ctcadpt.c
_TEXT	SEGMENT
bOpCode$ = 48
iNum$ = 52
tv140 = 56
tv128 = 60
tv186 = 64
tv205 = 68
tv144 = 72
tv155 = 76
pDEVBLK$ = 112
bCode$ = 120
bFlags$ = 128
bChained$ = 136
sCount$ = 144
bPrevCode$ = 152
iCCWSeq$ = 160
pIOBuf$ = 168
pMore$ = 176
pUnitStat$ = 184
pResidual$ = 192
CTCX_ExecuteCCW PROC

; 770  : {

$LN64:
  00000	44 88 4c 24 20	 mov	 BYTE PTR [rsp+32], r9b
  00005	44 88 44 24 18	 mov	 BYTE PTR [rsp+24], r8b
  0000a	88 54 24 10	 mov	 BYTE PTR [rsp+16], dl
  0000e	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00013	56		 push	 rsi
  00014	57		 push	 rdi
  00015	48 83 ec 58	 sub	 rsp, 88			; 00000058H
$LN4@CTCX_Execu:

; 771  :     int             iNum;               // Number of bytes to move
; 772  :     BYTE            bOpCode;            // CCW opcode with modifier
; 773  :                                         //   bits masked off
; 774  : 
; 775  :     UNREFERENCED( bFlags    );

  00019	33 c0		 xor	 eax, eax
  0001b	85 c0		 test	 eax, eax
  0001d	75 fa		 jne	 SHORT $LN4@CTCX_Execu
$LN7@CTCX_Execu:

; 776  :     UNREFERENCED( bChained  );

  0001f	33 c0		 xor	 eax, eax
  00021	85 c0		 test	 eax, eax
  00023	75 fa		 jne	 SHORT $LN7@CTCX_Execu
$LN10@CTCX_Execu:

; 777  :     UNREFERENCED( bPrevCode );

  00025	33 c0		 xor	 eax, eax
  00027	85 c0		 test	 eax, eax
  00029	75 fa		 jne	 SHORT $LN10@CTCX_Execu
$LN13@CTCX_Execu:

; 778  :     UNREFERENCED( iCCWSeq   );

  0002b	33 c0		 xor	 eax, eax
  0002d	85 c0		 test	 eax, eax
  0002f	75 fa		 jne	 SHORT $LN13@CTCX_Execu

; 779  : 
; 780  :     // Intervention required if the device file is not open
; 781  :     if( pDEVBLK->fd < 0 &&
; 782  :         !IS_CCW_SENSE( bCode ) &&

  00031	48 8b 44 24 70	 mov	 rax, QWORD PTR pDEVBLK$[rsp]
  00036	83 b8 ac 01 00
	00 00		 cmp	 DWORD PTR [rax+428], 0
  0003d	7d 40		 jge	 SHORT $LN20@CTCX_Execu
  0003f	0f b6 44 24 78	 movzx	 eax, BYTE PTR bCode$[rsp]
  00044	83 e0 0f	 and	 eax, 15
  00047	83 f8 04	 cmp	 eax, 4
  0004a	74 33		 je	 SHORT $LN20@CTCX_Execu
  0004c	0f b6 44 24 78	 movzx	 eax, BYTE PTR bCode$[rsp]
  00051	83 e0 03	 and	 eax, 3
  00054	83 f8 03	 cmp	 eax, 3
  00057	74 26		 je	 SHORT $LN20@CTCX_Execu

; 783  :         !IS_CCW_CONTROL( bCode ) )
; 784  :     {
; 785  :         pDEVBLK->sense[0] = SENSE_IR;

  00059	b8 01 00 00 00	 mov	 eax, 1
  0005e	48 6b c0 00	 imul	 rax, rax, 0
  00062	48 8b 4c 24 70	 mov	 rcx, QWORD PTR pDEVBLK$[rsp]
  00067	c6 84 01 64 03
	00 00 40	 mov	 BYTE PTR [rcx+rax+868], 64 ; 00000040H

; 786  :         *pUnitStat = CSW_CE | CSW_DE | CSW_UC;

  0006f	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR pUnitStat$[rsp]
  00077	c6 00 0e	 mov	 BYTE PTR [rax], 14

; 787  :         return;

  0007a	e9 73 04 00 00	 jmp	 $LN1@CTCX_Execu
$LN20@CTCX_Execu:

; 788  :     }
; 789  : 
; 790  :     // Mask off the modifier bits in the CCW bOpCode
; 791  :     if( ( bCode & 0x07 ) == 0x07 )

  0007f	0f b6 44 24 78	 movzx	 eax, BYTE PTR bCode$[rsp]
  00084	83 e0 07	 and	 eax, 7
  00087	83 f8 07	 cmp	 eax, 7
  0008a	75 0a		 jne	 SHORT $LN21@CTCX_Execu

; 792  :         bOpCode = 0x07;

  0008c	c6 44 24 30 07	 mov	 BYTE PTR bOpCode$[rsp], 7
  00091	e9 b7 00 00 00	 jmp	 $LN22@CTCX_Execu
$LN21@CTCX_Execu:

; 793  :     else if( ( bCode & 0x03 ) == 0x02 )

  00096	0f b6 44 24 78	 movzx	 eax, BYTE PTR bCode$[rsp]
  0009b	83 e0 03	 and	 eax, 3
  0009e	83 f8 02	 cmp	 eax, 2
  000a1	75 0a		 jne	 SHORT $LN23@CTCX_Execu

; 794  :         bOpCode = 0x02;

  000a3	c6 44 24 30 02	 mov	 BYTE PTR bOpCode$[rsp], 2
  000a8	e9 a0 00 00 00	 jmp	 $LN24@CTCX_Execu
$LN23@CTCX_Execu:

; 795  :     else if( ( bCode & 0x0F ) == 0x0C )

  000ad	0f b6 44 24 78	 movzx	 eax, BYTE PTR bCode$[rsp]
  000b2	83 e0 0f	 and	 eax, 15
  000b5	83 f8 0c	 cmp	 eax, 12
  000b8	75 0a		 jne	 SHORT $LN25@CTCX_Execu

; 796  :         bOpCode = 0x0C;

  000ba	c6 44 24 30 0c	 mov	 BYTE PTR bOpCode$[rsp], 12
  000bf	e9 89 00 00 00	 jmp	 $LN26@CTCX_Execu
$LN25@CTCX_Execu:

; 797  :     else if( ( bCode & 0x03 ) == 0x01 )

  000c4	0f b6 44 24 78	 movzx	 eax, BYTE PTR bCode$[rsp]
  000c9	83 e0 03	 and	 eax, 3
  000cc	83 f8 01	 cmp	 eax, 1
  000cf	75 35		 jne	 SHORT $LN27@CTCX_Execu

; 798  :         bOpCode = pDEVBLK->ctcxmode ? ( bCode & 0x83 ) : 0x01;

  000d1	48 8b 44 24 70	 mov	 rax, QWORD PTR pDEVBLK$[rsp]
  000d6	8b 80 18 07 00
	00		 mov	 eax, DWORD PTR [rax+1816]
  000dc	83 e0 01	 and	 eax, 1
  000df	85 c0		 test	 eax, eax
  000e1	74 10		 je	 SHORT $LN56@CTCX_Execu
  000e3	0f b6 44 24 78	 movzx	 eax, BYTE PTR bCode$[rsp]
  000e8	25 83 00 00 00	 and	 eax, 131		; 00000083H
  000ed	89 44 24 3c	 mov	 DWORD PTR tv128[rsp], eax
  000f1	eb 08		 jmp	 SHORT $LN57@CTCX_Execu
$LN56@CTCX_Execu:
  000f3	c7 44 24 3c 01
	00 00 00	 mov	 DWORD PTR tv128[rsp], 1
$LN57@CTCX_Execu:
  000fb	0f b6 44 24 3c	 movzx	 eax, BYTE PTR tv128[rsp]
  00100	88 44 24 30	 mov	 BYTE PTR bOpCode$[rsp], al
  00104	eb 47		 jmp	 SHORT $LN28@CTCX_Execu
$LN27@CTCX_Execu:

; 799  :     else if( ( bCode & 0x1F ) == 0x14 )

  00106	0f b6 44 24 78	 movzx	 eax, BYTE PTR bCode$[rsp]
  0010b	83 e0 1f	 and	 eax, 31
  0010e	83 f8 14	 cmp	 eax, 20
  00111	75 07		 jne	 SHORT $LN29@CTCX_Execu

; 800  :         bOpCode = 0x14;

  00113	c6 44 24 30 14	 mov	 BYTE PTR bOpCode$[rsp], 20
  00118	eb 33		 jmp	 SHORT $LN30@CTCX_Execu
$LN29@CTCX_Execu:

; 801  :     else if( ( bCode & 0x47 ) == 0x03 )

  0011a	0f b6 44 24 78	 movzx	 eax, BYTE PTR bCode$[rsp]
  0011f	83 e0 47	 and	 eax, 71			; 00000047H
  00122	83 f8 03	 cmp	 eax, 3
  00125	75 07		 jne	 SHORT $LN31@CTCX_Execu

; 802  :         bOpCode = 0x03;

  00127	c6 44 24 30 03	 mov	 BYTE PTR bOpCode$[rsp], 3
  0012c	eb 1f		 jmp	 SHORT $LN32@CTCX_Execu
$LN31@CTCX_Execu:

; 803  :     else if( ( bCode & 0xC7 ) == 0x43 )

  0012e	0f b6 44 24 78	 movzx	 eax, BYTE PTR bCode$[rsp]
  00133	25 c7 00 00 00	 and	 eax, 199		; 000000c7H
  00138	83 f8 43	 cmp	 eax, 67			; 00000043H
  0013b	75 07		 jne	 SHORT $LN33@CTCX_Execu

; 804  :         bOpCode = 0x43;

  0013d	c6 44 24 30 43	 mov	 BYTE PTR bOpCode$[rsp], 67 ; 00000043H
  00142	eb 09		 jmp	 SHORT $LN34@CTCX_Execu
$LN33@CTCX_Execu:

; 805  :     else
; 806  :         bOpCode = bCode;

  00144	0f b6 44 24 78	 movzx	 eax, BYTE PTR bCode$[rsp]
  00149	88 44 24 30	 mov	 BYTE PTR bOpCode$[rsp], al
$LN34@CTCX_Execu:
$LN32@CTCX_Execu:
$LN30@CTCX_Execu:
$LN28@CTCX_Execu:
$LN26@CTCX_Execu:
$LN24@CTCX_Execu:
$LN22@CTCX_Execu:

; 807  : 
; 808  :     // Process depending on CCW bOpCode
; 809  :     switch (bOpCode)

  0014d	0f b6 44 24 30	 movzx	 eax, BYTE PTR bOpCode$[rsp]
  00152	89 44 24 38	 mov	 DWORD PTR tv140[rsp], eax
  00156	8b 44 24 38	 mov	 eax, DWORD PTR tv140[rsp]
  0015a	ff c8		 dec	 eax
  0015c	89 44 24 38	 mov	 DWORD PTR tv140[rsp], eax
  00160	81 7c 24 38 e3
	00 00 00	 cmp	 DWORD PTR tv140[rsp], 227 ; 000000e3H
  00168	0f 87 63 03 00
	00		 ja	 $LN54@CTCX_Execu
  0016e	48 63 44 24 38	 movsxd	 rax, DWORD PTR tv140[rsp]
  00173	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__ImageBase
  0017a	0f b6 84 01 00
	00 00 00	 movzx	 eax, BYTE PTR $LN62@CTCX_Execu[rcx+rax]
  00182	8b 84 81 00 00
	00 00		 mov	 eax, DWORD PTR $LN63@CTCX_Execu[rcx+rax*4]
  00189	48 03 c1	 add	 rax, rcx
  0018c	ff e0		 jmp	 rax
$LN35@CTCX_Execu:

; 810  :     {
; 811  :     case 0x01:  // 0MMMMM01  WRITE
; 812  :         //------------------------------------------------------------
; 813  :         // WRITE
; 814  :         //------------------------------------------------------------
; 815  : 
; 816  :         // Return normal status if CCW count is zero
; 817  :         if( sCount == 0 )

  0018e	83 bc 24 90 00
	00 00 00	 cmp	 DWORD PTR sCount$[rsp], 0
  00196	75 10		 jne	 SHORT $LN36@CTCX_Execu

; 818  :         {
; 819  :             *pUnitStat = CSW_CE | CSW_DE;

  00198	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR pUnitStat$[rsp]
  001a0	c6 00 0c	 mov	 BYTE PTR [rax], 12

; 820  :             break;

  001a3	e9 4a 03 00 00	 jmp	 $LN14@CTCX_Execu
$LN36@CTCX_Execu:

; 821  :         }
; 822  : 
; 823  :         // Write data and set unit status and residual byte count
; 824  :         switch( pDEVBLK->ctctype )

  001a8	48 8b 44 24 70	 mov	 rax, QWORD PTR pDEVBLK$[rsp]
  001ad	0f b6 80 1c 07
	00 00		 movzx	 eax, BYTE PTR [rax+1820]
  001b4	88 44 24 48	 mov	 BYTE PTR tv144[rsp], al
  001b8	80 7c 24 48 06	 cmp	 BYTE PTR tv144[rsp], 6
  001bd	74 02		 je	 SHORT $LN37@CTCX_Execu
  001bf	eb 2e		 jmp	 SHORT $LN16@CTCX_Execu
$LN37@CTCX_Execu:

; 825  :         {
; 826  :         case CTC_CTCT:
; 827  :             CTCT_Write( pDEVBLK, sCount, pIOBuf, pUnitStat, pResidual );

  001c1	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR pResidual$[rsp]
  001c9	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  001ce	4c 8b 8c 24 b8
	00 00 00	 mov	 r9, QWORD PTR pUnitStat$[rsp]
  001d6	4c 8b 84 24 a8
	00 00 00	 mov	 r8, QWORD PTR pIOBuf$[rsp]
  001de	8b 94 24 90 00
	00 00		 mov	 edx, DWORD PTR sCount$[rsp]
  001e5	48 8b 4c 24 70	 mov	 rcx, QWORD PTR pDEVBLK$[rsp]
  001ea	e8 00 00 00 00	 call	 CTCT_Write
$LN16@CTCX_Execu:

; 828  :             break;
; 829  :         }
; 830  :         break;

  001ef	e9 fe 02 00 00	 jmp	 $LN14@CTCX_Execu
$LN38@CTCX_Execu:

; 831  : 
; 832  :     case 0x81:  // 1MMMMM01  WEOF
; 833  :         //------------------------------------------------------------
; 834  :         // WRITE EOF
; 835  :         //------------------------------------------------------------
; 836  : 
; 837  :         // Return normal status
; 838  :         *pUnitStat = CSW_CE | CSW_DE;

  001f4	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR pUnitStat$[rsp]
  001fc	c6 00 0c	 mov	 BYTE PTR [rax], 12

; 839  :         break;

  001ff	e9 ee 02 00 00	 jmp	 $LN14@CTCX_Execu
$LN39@CTCX_Execu:
$LN40@CTCX_Execu:

; 840  : 
; 841  :     case 0x02:  // MMMMMM10  READ
; 842  :     case 0x0C:  // MMMM1100  RDBACK
; 843  :         // -----------------------------------------------------------
; 844  :         // READ & READ BACKWARDS
; 845  :         // -----------------------------------------------------------
; 846  : 
; 847  :         // Read data and set unit status and residual byte count
; 848  :         switch( pDEVBLK->ctctype )

  00204	48 8b 44 24 70	 mov	 rax, QWORD PTR pDEVBLK$[rsp]
  00209	0f b6 80 1c 07
	00 00		 movzx	 eax, BYTE PTR [rax+1820]
  00210	88 44 24 4c	 mov	 BYTE PTR tv155[rsp], al
  00214	80 7c 24 4c 06	 cmp	 BYTE PTR tv155[rsp], 6
  00219	74 02		 je	 SHORT $LN41@CTCX_Execu
  0021b	eb 3b		 jmp	 SHORT $LN18@CTCX_Execu
$LN41@CTCX_Execu:

; 849  :         {
; 850  :         case CTC_CTCT:
; 851  :             CTCT_Read( pDEVBLK, sCount, pIOBuf, pUnitStat, pResidual, pMore );

  0021d	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR pMore$[rsp]
  00225	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  0022a	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR pResidual$[rsp]
  00232	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00237	4c 8b 8c 24 b8
	00 00 00	 mov	 r9, QWORD PTR pUnitStat$[rsp]
  0023f	4c 8b 84 24 a8
	00 00 00	 mov	 r8, QWORD PTR pIOBuf$[rsp]
  00247	8b 94 24 90 00
	00 00		 mov	 edx, DWORD PTR sCount$[rsp]
  0024e	48 8b 4c 24 70	 mov	 rcx, QWORD PTR pDEVBLK$[rsp]
  00253	e8 00 00 00 00	 call	 CTCT_Read
$LN18@CTCX_Execu:

; 852  :             break;
; 853  :         }
; 854  :         break;

  00258	e9 95 02 00 00	 jmp	 $LN14@CTCX_Execu
$LN42@CTCX_Execu:

; 855  : 
; 856  :     case 0x07:  // MMMMM111  CTL
; 857  :         // -----------------------------------------------------------
; 858  :         // CONTROL
; 859  :         // -----------------------------------------------------------
; 860  : 
; 861  :         *pUnitStat = CSW_CE | CSW_DE;

  0025d	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR pUnitStat$[rsp]
  00265	c6 00 0c	 mov	 BYTE PTR [rax], 12

; 862  :         break;

  00268	e9 85 02 00 00	 jmp	 $LN14@CTCX_Execu
$LN43@CTCX_Execu:

; 863  : 
; 864  :     case 0x03:  // M0MMM011  NOP
; 865  :         // -----------------------------------------------------------
; 866  :         // CONTROL NO-OPERATON
; 867  :         // -----------------------------------------------------------
; 868  : 
; 869  :         *pUnitStat = CSW_CE | CSW_DE;

  0026d	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR pUnitStat$[rsp]
  00275	c6 00 0c	 mov	 BYTE PTR [rax], 12

; 870  :         break;

  00278	e9 75 02 00 00	 jmp	 $LN14@CTCX_Execu
$LN44@CTCX_Execu:

; 871  : 
; 872  :     case 0x43:  // 00XXX011  SBM
; 873  :         // -----------------------------------------------------------
; 874  :         // SET BASIC MODE
; 875  :         // -----------------------------------------------------------
; 876  : 
; 877  :         // Command reject if in basic mode
; 878  :         if( pDEVBLK->ctcxmode == 0 )

  0027d	48 8b 44 24 70	 mov	 rax, QWORD PTR pDEVBLK$[rsp]
  00282	8b 80 18 07 00
	00		 mov	 eax, DWORD PTR [rax+1816]
  00288	83 e0 01	 and	 eax, 1
  0028b	85 c0		 test	 eax, eax
  0028d	75 26		 jne	 SHORT $LN45@CTCX_Execu

; 879  :         {
; 880  :             pDEVBLK->sense[0] = SENSE_CR;

  0028f	b8 01 00 00 00	 mov	 eax, 1
  00294	48 6b c0 00	 imul	 rax, rax, 0
  00298	48 8b 4c 24 70	 mov	 rcx, QWORD PTR pDEVBLK$[rsp]
  0029d	c6 84 01 64 03
	00 00 80	 mov	 BYTE PTR [rcx+rax+868], 128 ; 00000080H

; 881  :             *pUnitStat        = CSW_CE | CSW_DE | CSW_UC;

  002a5	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR pUnitStat$[rsp]
  002ad	c6 00 0e	 mov	 BYTE PTR [rax], 14

; 882  : 
; 883  :             break;

  002b0	e9 3d 02 00 00	 jmp	 $LN14@CTCX_Execu
$LN45@CTCX_Execu:

; 884  :         }
; 885  : 
; 886  :         // Reset extended mode and return normal status
; 887  :         pDEVBLK->ctcxmode = 0;

  002b5	48 8b 44 24 70	 mov	 rax, QWORD PTR pDEVBLK$[rsp]
  002ba	8b 80 18 07 00
	00		 mov	 eax, DWORD PTR [rax+1816]
  002c0	83 e0 fe	 and	 eax, -2			; fffffffeH
  002c3	48 8b 4c 24 70	 mov	 rcx, QWORD PTR pDEVBLK$[rsp]
  002c8	89 81 18 07 00
	00		 mov	 DWORD PTR [rcx+1816], eax

; 888  : 
; 889  :         *pResidual = 0;

  002ce	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR pResidual$[rsp]
  002d6	c7 00 00 00 00
	00		 mov	 DWORD PTR [rax], 0

; 890  :         *pUnitStat = CSW_CE | CSW_DE;

  002dc	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR pUnitStat$[rsp]
  002e4	c6 00 0c	 mov	 BYTE PTR [rax], 12

; 891  : 
; 892  :         break;

  002e7	e9 06 02 00 00	 jmp	 $LN14@CTCX_Execu
$LN46@CTCX_Execu:

; 893  : 
; 894  :     case 0xC3:  // 11000011  SEM
; 895  :         // -----------------------------------------------------------
; 896  :         // SET EXTENDED MODE
; 897  :         // -----------------------------------------------------------
; 898  : 
; 899  :         pDEVBLK->ctcxmode = 1;

  002ec	48 8b 44 24 70	 mov	 rax, QWORD PTR pDEVBLK$[rsp]
  002f1	8b 80 18 07 00
	00		 mov	 eax, DWORD PTR [rax+1816]
  002f7	83 c8 01	 or	 eax, 1
  002fa	48 8b 4c 24 70	 mov	 rcx, QWORD PTR pDEVBLK$[rsp]
  002ff	89 81 18 07 00
	00		 mov	 DWORD PTR [rcx+1816], eax

; 900  : 
; 901  :         *pResidual = 0;

  00305	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR pResidual$[rsp]
  0030d	c7 00 00 00 00
	00		 mov	 DWORD PTR [rax], 0

; 902  :         *pUnitStat = CSW_CE | CSW_DE;

  00313	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR pUnitStat$[rsp]
  0031b	c6 00 0c	 mov	 BYTE PTR [rax], 12

; 903  : 
; 904  :         break;

  0031e	e9 cf 01 00 00	 jmp	 $LN14@CTCX_Execu
$LN47@CTCX_Execu:

; 905  : 
; 906  :     case 0xE3:  // 11100011
; 907  :         // -----------------------------------------------------------
; 908  :         // PREPARE (PREP)
; 909  :         // -----------------------------------------------------------
; 910  : 
; 911  :         *pUnitStat = CSW_CE | CSW_DE;

  00323	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR pUnitStat$[rsp]
  0032b	c6 00 0c	 mov	 BYTE PTR [rax], 12

; 912  : 
; 913  :         break;

  0032e	e9 bf 01 00 00	 jmp	 $LN14@CTCX_Execu
$LN48@CTCX_Execu:

; 914  : 
; 915  :     case 0x14:  // XXX10100  SCB
; 916  :         // -----------------------------------------------------------
; 917  :         // SENSE COMMAND BYTE
; 918  :         // -----------------------------------------------------------
; 919  : 
; 920  :         *pUnitStat = CSW_CE | CSW_DE;

  00333	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR pUnitStat$[rsp]
  0033b	c6 00 0c	 mov	 BYTE PTR [rax], 12

; 921  :         break;

  0033e	e9 af 01 00 00	 jmp	 $LN14@CTCX_Execu
$LN49@CTCX_Execu:

; 922  : 
; 923  :     case 0x04:  // 00000100  SENSE
; 924  :       // -----------------------------------------------------------
; 925  :       // SENSE
; 926  :       // -----------------------------------------------------------
; 927  : 
; 928  :         // Command reject if in basic mode
; 929  :         if( pDEVBLK->ctcxmode == 0 )

  00343	48 8b 44 24 70	 mov	 rax, QWORD PTR pDEVBLK$[rsp]
  00348	8b 80 18 07 00
	00		 mov	 eax, DWORD PTR [rax+1816]
  0034e	83 e0 01	 and	 eax, 1
  00351	85 c0		 test	 eax, eax
  00353	75 26		 jne	 SHORT $LN50@CTCX_Execu

; 930  :         {
; 931  :             pDEVBLK->sense[0] = SENSE_CR;

  00355	b8 01 00 00 00	 mov	 eax, 1
  0035a	48 6b c0 00	 imul	 rax, rax, 0
  0035e	48 8b 4c 24 70	 mov	 rcx, QWORD PTR pDEVBLK$[rsp]
  00363	c6 84 01 64 03
	00 00 80	 mov	 BYTE PTR [rcx+rax+868], 128 ; 00000080H

; 932  :             *pUnitStat        = CSW_CE | CSW_DE | CSW_UC;

  0036b	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR pUnitStat$[rsp]
  00373	c6 00 0e	 mov	 BYTE PTR [rax], 14

; 933  :             break;

  00376	e9 77 01 00 00	 jmp	 $LN14@CTCX_Execu
$LN50@CTCX_Execu:

; 934  :         }
; 935  : 
; 936  :         // Calculate residual byte count
; 937  :         iNum = ( sCount < pDEVBLK->numsense ) ?

  0037b	48 8b 44 24 70	 mov	 rax, QWORD PTR pDEVBLK$[rsp]
  00380	8b 80 60 03 00
	00		 mov	 eax, DWORD PTR [rax+864]
  00386	39 84 24 90 00
	00 00		 cmp	 DWORD PTR sCount$[rsp], eax
  0038d	73 0d		 jae	 SHORT $LN58@CTCX_Execu
  0038f	8b 84 24 90 00
	00 00		 mov	 eax, DWORD PTR sCount$[rsp]
  00396	89 44 24 40	 mov	 DWORD PTR tv186[rsp], eax
  0039a	eb 0f		 jmp	 SHORT $LN59@CTCX_Execu
$LN58@CTCX_Execu:
  0039c	48 8b 44 24 70	 mov	 rax, QWORD PTR pDEVBLK$[rsp]
  003a1	8b 80 60 03 00
	00		 mov	 eax, DWORD PTR [rax+864]
  003a7	89 44 24 40	 mov	 DWORD PTR tv186[rsp], eax
$LN59@CTCX_Execu:
  003ab	8b 44 24 40	 mov	 eax, DWORD PTR tv186[rsp]
  003af	89 44 24 34	 mov	 DWORD PTR iNum$[rsp], eax

; 938  :             sCount : pDEVBLK->numsense;
; 939  : 
; 940  :         *pResidual = sCount - iNum;

  003b3	8b 44 24 34	 mov	 eax, DWORD PTR iNum$[rsp]
  003b7	8b 8c 24 90 00
	00 00		 mov	 ecx, DWORD PTR sCount$[rsp]
  003be	2b c8		 sub	 ecx, eax
  003c0	8b c1		 mov	 eax, ecx
  003c2	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR pResidual$[rsp]
  003ca	89 01		 mov	 DWORD PTR [rcx], eax

; 941  : 
; 942  :         if( sCount < pDEVBLK->numsense )

  003cc	48 8b 44 24 70	 mov	 rax, QWORD PTR pDEVBLK$[rsp]
  003d1	8b 80 60 03 00
	00		 mov	 eax, DWORD PTR [rax+864]
  003d7	39 84 24 90 00
	00 00		 cmp	 DWORD PTR sCount$[rsp], eax
  003de	73 0b		 jae	 SHORT $LN51@CTCX_Execu

; 943  :             *pMore = 1;

  003e0	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR pMore$[rsp]
  003e8	c6 00 01	 mov	 BYTE PTR [rax], 1
$LN51@CTCX_Execu:

; 944  : 
; 945  :         // Copy device sense bytes to channel I/O buffer
; 946  :         memcpy( pIOBuf, pDEVBLK->sense, iNum );

  003eb	48 63 44 24 34	 movsxd	 rax, DWORD PTR iNum$[rsp]
  003f0	48 8b 4c 24 70	 mov	 rcx, QWORD PTR pDEVBLK$[rsp]
  003f5	48 81 c1 64 03
	00 00		 add	 rcx, 868		; 00000364H
  003fc	48 8b bc 24 a8
	00 00 00	 mov	 rdi, QWORD PTR pIOBuf$[rsp]
  00404	48 8b f1	 mov	 rsi, rcx
  00407	48 8b c8	 mov	 rcx, rax
  0040a	f3 a4		 rep movsb

; 947  : 
; 948  :         // Clear the device sense bytes
; 949  :         memset( pDEVBLK->sense, 0, sizeof( pDEVBLK->sense ) );

  0040c	48 8b 44 24 70	 mov	 rax, QWORD PTR pDEVBLK$[rsp]
  00411	48 05 64 03 00
	00		 add	 rax, 868		; 00000364H
  00417	48 8b f8	 mov	 rdi, rax
  0041a	33 c0		 xor	 eax, eax
  0041c	b9 00 01 00 00	 mov	 ecx, 256		; 00000100H
  00421	f3 aa		 rep stosb

; 950  : 
; 951  :         // Return unit status
; 952  :         *pUnitStat = CSW_CE | CSW_DE;

  00423	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR pUnitStat$[rsp]
  0042b	c6 00 0c	 mov	 BYTE PTR [rax], 12

; 953  : 
; 954  :         break;

  0042e	e9 bf 00 00 00	 jmp	 $LN14@CTCX_Execu
$LN52@CTCX_Execu:

; 955  : 
; 956  :     case 0xE4:  //  11100100  SID
; 957  :         // -----------------------------------------------------------
; 958  :         // SENSE ID
; 959  :         // -----------------------------------------------------------
; 960  : 
; 961  :         // Calculate residual byte count
; 962  :         iNum = ( sCount < pDEVBLK->numdevid ) ?

  00433	48 8b 44 24 70	 mov	 rax, QWORD PTR pDEVBLK$[rsp]
  00438	8b 80 64 04 00
	00		 mov	 eax, DWORD PTR [rax+1124]
  0043e	39 84 24 90 00
	00 00		 cmp	 DWORD PTR sCount$[rsp], eax
  00445	73 0d		 jae	 SHORT $LN60@CTCX_Execu
  00447	8b 84 24 90 00
	00 00		 mov	 eax, DWORD PTR sCount$[rsp]
  0044e	89 44 24 44	 mov	 DWORD PTR tv205[rsp], eax
  00452	eb 0f		 jmp	 SHORT $LN61@CTCX_Execu
$LN60@CTCX_Execu:
  00454	48 8b 44 24 70	 mov	 rax, QWORD PTR pDEVBLK$[rsp]
  00459	8b 80 64 04 00
	00		 mov	 eax, DWORD PTR [rax+1124]
  0045f	89 44 24 44	 mov	 DWORD PTR tv205[rsp], eax
$LN61@CTCX_Execu:
  00463	8b 44 24 44	 mov	 eax, DWORD PTR tv205[rsp]
  00467	89 44 24 34	 mov	 DWORD PTR iNum$[rsp], eax

; 963  :             sCount : pDEVBLK->numdevid;
; 964  : 
; 965  :         *pResidual = sCount - iNum;

  0046b	8b 44 24 34	 mov	 eax, DWORD PTR iNum$[rsp]
  0046f	8b 8c 24 90 00
	00 00		 mov	 ecx, DWORD PTR sCount$[rsp]
  00476	2b c8		 sub	 ecx, eax
  00478	8b c1		 mov	 eax, ecx
  0047a	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR pResidual$[rsp]
  00482	89 01		 mov	 DWORD PTR [rcx], eax

; 966  : 
; 967  :         if( sCount < pDEVBLK->numdevid )

  00484	48 8b 44 24 70	 mov	 rax, QWORD PTR pDEVBLK$[rsp]
  00489	8b 80 64 04 00
	00		 mov	 eax, DWORD PTR [rax+1124]
  0048f	39 84 24 90 00
	00 00		 cmp	 DWORD PTR sCount$[rsp], eax
  00496	73 0b		 jae	 SHORT $LN53@CTCX_Execu

; 968  :             *pMore = 1;

  00498	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR pMore$[rsp]
  004a0	c6 00 01	 mov	 BYTE PTR [rax], 1
$LN53@CTCX_Execu:

; 969  : 
; 970  :         // Copy device identifier bytes to channel I/O buffer
; 971  :         memcpy( pIOBuf, pDEVBLK->devid, iNum );

  004a3	48 63 44 24 34	 movsxd	 rax, DWORD PTR iNum$[rsp]
  004a8	48 8b 4c 24 70	 mov	 rcx, QWORD PTR pDEVBLK$[rsp]
  004ad	48 81 c1 68 04
	00 00		 add	 rcx, 1128		; 00000468H
  004b4	48 8b bc 24 a8
	00 00 00	 mov	 rdi, QWORD PTR pIOBuf$[rsp]
  004bc	48 8b f1	 mov	 rsi, rcx
  004bf	48 8b c8	 mov	 rcx, rax
  004c2	f3 a4		 rep movsb

; 972  : 
; 973  :         // Return unit status
; 974  :         *pUnitStat = CSW_CE | CSW_DE;

  004c4	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR pUnitStat$[rsp]
  004cc	c6 00 0c	 mov	 BYTE PTR [rax], 12

; 975  : 
; 976  :         break;

  004cf	eb 21		 jmp	 SHORT $LN14@CTCX_Execu
$LN54@CTCX_Execu:

; 977  : 
; 978  :     default:
; 979  :         // ------------------------------------------------------------
; 980  :         // INVALID OPERATION
; 981  :         // ------------------------------------------------------------
; 982  : 
; 983  :         // Set command reject sense byte, and unit check status
; 984  :         pDEVBLK->sense[0] = SENSE_CR;

  004d1	b8 01 00 00 00	 mov	 eax, 1
  004d6	48 6b c0 00	 imul	 rax, rax, 0
  004da	48 8b 4c 24 70	 mov	 rcx, QWORD PTR pDEVBLK$[rsp]
  004df	c6 84 01 64 03
	00 00 80	 mov	 BYTE PTR [rcx+rax+868], 128 ; 00000080H

; 985  :         *pUnitStat        = CSW_CE | CSW_DE | CSW_UC;

  004e7	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR pUnitStat$[rsp]
  004ef	c6 00 0e	 mov	 BYTE PTR [rax], 14
$LN14@CTCX_Execu:
$LN1@CTCX_Execu:

; 986  :     }
; 987  : }

  004f2	48 83 c4 58	 add	 rsp, 88			; 00000058H
  004f6	5f		 pop	 rdi
  004f7	5e		 pop	 rsi
  004f8	c3		 ret	 0
  004f9	0f 1f 00	 npad	 3
$LN63@CTCX_Execu:
  004fc	00 00 00 00	 DD	 $LN35@CTCX_Execu
  00500	00 00 00 00	 DD	 $LN39@CTCX_Execu
  00504	00 00 00 00	 DD	 $LN43@CTCX_Execu
  00508	00 00 00 00	 DD	 $LN49@CTCX_Execu
  0050c	00 00 00 00	 DD	 $LN42@CTCX_Execu
  00510	00 00 00 00	 DD	 $LN40@CTCX_Execu
  00514	00 00 00 00	 DD	 $LN48@CTCX_Execu
  00518	00 00 00 00	 DD	 $LN44@CTCX_Execu
  0051c	00 00 00 00	 DD	 $LN38@CTCX_Execu
  00520	00 00 00 00	 DD	 $LN46@CTCX_Execu
  00524	00 00 00 00	 DD	 $LN47@CTCX_Execu
  00528	00 00 00 00	 DD	 $LN52@CTCX_Execu
  0052c	00 00 00 00	 DD	 $LN54@CTCX_Execu
$LN62@CTCX_Execu:
  00530	00		 DB	 0
  00531	01		 DB	 1
  00532	02		 DB	 2
  00533	03		 DB	 3
  00534	0c		 DB	 12
  00535	0c		 DB	 12
  00536	04		 DB	 4
  00537	0c		 DB	 12
  00538	0c		 DB	 12
  00539	0c		 DB	 12
  0053a	0c		 DB	 12
  0053b	05		 DB	 5
  0053c	0c		 DB	 12
  0053d	0c		 DB	 12
  0053e	0c		 DB	 12
  0053f	0c		 DB	 12
  00540	0c		 DB	 12
  00541	0c		 DB	 12
  00542	0c		 DB	 12
  00543	06		 DB	 6
  00544	0c		 DB	 12
  00545	0c		 DB	 12
  00546	0c		 DB	 12
  00547	0c		 DB	 12
  00548	0c		 DB	 12
  00549	0c		 DB	 12
  0054a	0c		 DB	 12
  0054b	0c		 DB	 12
  0054c	0c		 DB	 12
  0054d	0c		 DB	 12
  0054e	0c		 DB	 12
  0054f	0c		 DB	 12
  00550	0c		 DB	 12
  00551	0c		 DB	 12
  00552	0c		 DB	 12
  00553	0c		 DB	 12
  00554	0c		 DB	 12
  00555	0c		 DB	 12
  00556	0c		 DB	 12
  00557	0c		 DB	 12
  00558	0c		 DB	 12
  00559	0c		 DB	 12
  0055a	0c		 DB	 12
  0055b	0c		 DB	 12
  0055c	0c		 DB	 12
  0055d	0c		 DB	 12
  0055e	0c		 DB	 12
  0055f	0c		 DB	 12
  00560	0c		 DB	 12
  00561	0c		 DB	 12
  00562	0c		 DB	 12
  00563	0c		 DB	 12
  00564	0c		 DB	 12
  00565	0c		 DB	 12
  00566	0c		 DB	 12
  00567	0c		 DB	 12
  00568	0c		 DB	 12
  00569	0c		 DB	 12
  0056a	0c		 DB	 12
  0056b	0c		 DB	 12
  0056c	0c		 DB	 12
  0056d	0c		 DB	 12
  0056e	0c		 DB	 12
  0056f	0c		 DB	 12
  00570	0c		 DB	 12
  00571	0c		 DB	 12
  00572	07		 DB	 7
  00573	0c		 DB	 12
  00574	0c		 DB	 12
  00575	0c		 DB	 12
  00576	0c		 DB	 12
  00577	0c		 DB	 12
  00578	0c		 DB	 12
  00579	0c		 DB	 12
  0057a	0c		 DB	 12
  0057b	0c		 DB	 12
  0057c	0c		 DB	 12
  0057d	0c		 DB	 12
  0057e	0c		 DB	 12
  0057f	0c		 DB	 12
  00580	0c		 DB	 12
  00581	0c		 DB	 12
  00582	0c		 DB	 12
  00583	0c		 DB	 12
  00584	0c		 DB	 12
  00585	0c		 DB	 12
  00586	0c		 DB	 12
  00587	0c		 DB	 12
  00588	0c		 DB	 12
  00589	0c		 DB	 12
  0058a	0c		 DB	 12
  0058b	0c		 DB	 12
  0058c	0c		 DB	 12
  0058d	0c		 DB	 12
  0058e	0c		 DB	 12
  0058f	0c		 DB	 12
  00590	0c		 DB	 12
  00591	0c		 DB	 12
  00592	0c		 DB	 12
  00593	0c		 DB	 12
  00594	0c		 DB	 12
  00595	0c		 DB	 12
  00596	0c		 DB	 12
  00597	0c		 DB	 12
  00598	0c		 DB	 12
  00599	0c		 DB	 12
  0059a	0c		 DB	 12
  0059b	0c		 DB	 12
  0059c	0c		 DB	 12
  0059d	0c		 DB	 12
  0059e	0c		 DB	 12
  0059f	0c		 DB	 12
  005a0	0c		 DB	 12
  005a1	0c		 DB	 12
  005a2	0c		 DB	 12
  005a3	0c		 DB	 12
  005a4	0c		 DB	 12
  005a5	0c		 DB	 12
  005a6	0c		 DB	 12
  005a7	0c		 DB	 12
  005a8	0c		 DB	 12
  005a9	0c		 DB	 12
  005aa	0c		 DB	 12
  005ab	0c		 DB	 12
  005ac	0c		 DB	 12
  005ad	0c		 DB	 12
  005ae	0c		 DB	 12
  005af	0c		 DB	 12
  005b0	08		 DB	 8
  005b1	0c		 DB	 12
  005b2	0c		 DB	 12
  005b3	0c		 DB	 12
  005b4	0c		 DB	 12
  005b5	0c		 DB	 12
  005b6	0c		 DB	 12
  005b7	0c		 DB	 12
  005b8	0c		 DB	 12
  005b9	0c		 DB	 12
  005ba	0c		 DB	 12
  005bb	0c		 DB	 12
  005bc	0c		 DB	 12
  005bd	0c		 DB	 12
  005be	0c		 DB	 12
  005bf	0c		 DB	 12
  005c0	0c		 DB	 12
  005c1	0c		 DB	 12
  005c2	0c		 DB	 12
  005c3	0c		 DB	 12
  005c4	0c		 DB	 12
  005c5	0c		 DB	 12
  005c6	0c		 DB	 12
  005c7	0c		 DB	 12
  005c8	0c		 DB	 12
  005c9	0c		 DB	 12
  005ca	0c		 DB	 12
  005cb	0c		 DB	 12
  005cc	0c		 DB	 12
  005cd	0c		 DB	 12
  005ce	0c		 DB	 12
  005cf	0c		 DB	 12
  005d0	0c		 DB	 12
  005d1	0c		 DB	 12
  005d2	0c		 DB	 12
  005d3	0c		 DB	 12
  005d4	0c		 DB	 12
  005d5	0c		 DB	 12
  005d6	0c		 DB	 12
  005d7	0c		 DB	 12
  005d8	0c		 DB	 12
  005d9	0c		 DB	 12
  005da	0c		 DB	 12
  005db	0c		 DB	 12
  005dc	0c		 DB	 12
  005dd	0c		 DB	 12
  005de	0c		 DB	 12
  005df	0c		 DB	 12
  005e0	0c		 DB	 12
  005e1	0c		 DB	 12
  005e2	0c		 DB	 12
  005e3	0c		 DB	 12
  005e4	0c		 DB	 12
  005e5	0c		 DB	 12
  005e6	0c		 DB	 12
  005e7	0c		 DB	 12
  005e8	0c		 DB	 12
  005e9	0c		 DB	 12
  005ea	0c		 DB	 12
  005eb	0c		 DB	 12
  005ec	0c		 DB	 12
  005ed	0c		 DB	 12
  005ee	0c		 DB	 12
  005ef	0c		 DB	 12
  005f0	0c		 DB	 12
  005f1	0c		 DB	 12
  005f2	09		 DB	 9
  005f3	0c		 DB	 12
  005f4	0c		 DB	 12
  005f5	0c		 DB	 12
  005f6	0c		 DB	 12
  005f7	0c		 DB	 12
  005f8	0c		 DB	 12
  005f9	0c		 DB	 12
  005fa	0c		 DB	 12
  005fb	0c		 DB	 12
  005fc	0c		 DB	 12
  005fd	0c		 DB	 12
  005fe	0c		 DB	 12
  005ff	0c		 DB	 12
  00600	0c		 DB	 12
  00601	0c		 DB	 12
  00602	0c		 DB	 12
  00603	0c		 DB	 12
  00604	0c		 DB	 12
  00605	0c		 DB	 12
  00606	0c		 DB	 12
  00607	0c		 DB	 12
  00608	0c		 DB	 12
  00609	0c		 DB	 12
  0060a	0c		 DB	 12
  0060b	0c		 DB	 12
  0060c	0c		 DB	 12
  0060d	0c		 DB	 12
  0060e	0c		 DB	 12
  0060f	0c		 DB	 12
  00610	0c		 DB	 12
  00611	0c		 DB	 12
  00612	0a		 DB	 10
  00613	0b		 DB	 11
CTCX_ExecuteCCW ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\ctcadpt.c
_TEXT	SEGMENT
$T1 = 48
filename$ = 64
__$ArrayPad$ = 336
pDEVBLK$ = 368
ppszClass$ = 376
iBufLen$ = 384
pBuffer$ = 392
CTCX_Query PROC

; 733  : {

$LN11:
  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	48 81 ec 68 01
	00 00		 sub	 rsp, 360		; 00000168H
  0001b	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00022	48 33 c4	 xor	 rax, rsp
  00025	48 89 84 24 50
	01 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 734  :     char  filename[ PATH_MAX + 1 ];     /* full path or just name    */
; 735  : 
; 736  :     BEGIN_DEVICE_CLASS_QUERY( "CTCA", pDEVBLK, ppszClass, iBufLen, pBuffer );

  0002d	48 83 bc 24 78
	01 00 00 00	 cmp	 QWORD PTR ppszClass$[rsp], 0
  00036	74 12		 je	 SHORT $LN2@CTCX_Query
  00038	48 8b 84 24 78
	01 00 00	 mov	 rax, QWORD PTR ppszClass$[rsp]
  00040	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169271
  00047	48 89 08	 mov	 QWORD PTR [rax], rcx
$LN2@CTCX_Query:
  0004a	48 83 bc 24 70
	01 00 00 00	 cmp	 QWORD PTR pDEVBLK$[rsp], 0
  00053	74 20		 je	 SHORT $LN4@CTCX_Query
  00055	48 83 bc 24 78
	01 00 00 00	 cmp	 QWORD PTR ppszClass$[rsp], 0
  0005e	74 15		 je	 SHORT $LN4@CTCX_Query
  00060	83 bc 24 80 01
	00 00 00	 cmp	 DWORD PTR iBufLen$[rsp], 0
  00068	74 0b		 je	 SHORT $LN4@CTCX_Query
  0006a	48 83 bc 24 88
	01 00 00 00	 cmp	 QWORD PTR pBuffer$[rsp], 0
  00073	75 05		 jne	 SHORT $LN3@CTCX_Query
$LN4@CTCX_Query:
  00075	e9 de 00 00 00	 jmp	 $LN1@CTCX_Query
$LN3@CTCX_Query:
  0007a	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00081	8b 80 94 12 00
	00		 mov	 eax, DWORD PTR [rax+4756]
  00087	c1 e8 1a	 shr	 eax, 26
  0008a	83 e0 01	 and	 eax, 1
  0008d	85 c0		 test	 eax, eax
  0008f	74 6c		 je	 SHORT $LN5@CTCX_Query
  00091	48 8b 84 24 70
	01 00 00	 mov	 rax, QWORD PTR pDEVBLK$[rsp]
  00099	48 05 a4 00 00
	00		 add	 rax, 164		; 000000a4H
  0009f	48 8b c8	 mov	 rcx, rax
  000a2	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_basename
  000a8	41 b8 05 01 00
	00		 mov	 r8d, 261		; 00000105H
  000ae	48 8b d0	 mov	 rdx, rax
  000b1	48 8d 4c 24 40	 lea	 rcx, QWORD PTR filename$[rsp]
  000b6	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_strlcpy
  000bc	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG169277
  000c3	48 8d 4c 24 40	 lea	 rcx, QWORD PTR filename$[rsp]
  000c8	e8 00 00 00 00	 call	 strcmp
  000cd	85 c0		 test	 eax, eax
  000cf	75 2a		 jne	 SHORT $LN7@CTCX_Query
  000d1	b8 01 00 00 00	 mov	 eax, 1
  000d6	48 6b c0 00	 imul	 rax, rax, 0
  000da	48 89 44 24 30	 mov	 QWORD PTR $T1[rsp], rax
  000df	48 81 7c 24 30
	05 01 00 00	 cmp	 QWORD PTR $T1[rsp], 261	; 00000105H
  000e8	73 02		 jae	 SHORT $LN9@CTCX_Query
  000ea	eb 05		 jmp	 SHORT $LN10@CTCX_Query
$LN9@CTCX_Query:
  000ec	e8 00 00 00 00	 call	 __report_rangecheckfailure
$LN10@CTCX_Query:
  000f1	48 8b 44 24 30	 mov	 rax, QWORD PTR $T1[rsp]
  000f6	c6 44 04 40 00	 mov	 BYTE PTR filename$[rsp+rax], 0
$LN7@CTCX_Query:
  000fb	eb 22		 jmp	 SHORT $LN6@CTCX_Query
$LN5@CTCX_Query:
  000fd	48 8b 84 24 70
	01 00 00	 mov	 rax, QWORD PTR pDEVBLK$[rsp]
  00105	48 05 a4 00 00
	00		 add	 rax, 164		; 000000a4H
  0010b	41 b8 05 01 00
	00		 mov	 r8d, 261		; 00000105H
  00111	48 8b d0	 mov	 rdx, rax
  00114	48 8d 4c 24 40	 lea	 rcx, QWORD PTR filename$[rsp]
  00119	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_strlcpy
$LN6@CTCX_Query:

; 737  : 
; 738  :     snprintf( pBuffer, iBufLen, "%s IO[%"PRIu64"]", filename, pDEVBLK->excps );

  0011f	48 63 84 24 80
	01 00 00	 movsxd	 rax, DWORD PTR iBufLen$[rsp]
  00127	48 8b 8c 24 70
	01 00 00	 mov	 rcx, QWORD PTR pDEVBLK$[rsp]
  0012f	48 8b 89 00 06
	00 00		 mov	 rcx, QWORD PTR [rcx+1536]
  00136	48 89 4c 24 20	 mov	 QWORD PTR [rsp+32], rcx
  0013b	4c 8d 4c 24 40	 lea	 r9, QWORD PTR filename$[rsp]
  00140	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG169278
  00147	48 8b d0	 mov	 rdx, rax
  0014a	48 8b 8c 24 88
	01 00 00	 mov	 rcx, QWORD PTR pBuffer$[rsp]
  00152	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_snprintf
$LN1@CTCX_Query:
$LN8@CTCX_Query:

; 739  : }

  00158	48 8b 8c 24 50
	01 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  00160	48 33 cc	 xor	 rcx, rsp
  00163	e8 00 00 00 00	 call	 __security_check_cookie
  00168	48 81 c4 68 01
	00 00		 add	 rsp, 360		; 00000168H
  0016f	c3		 ret	 0
CTCX_Query ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\ctcadpt.c
_TEXT	SEGMENT
pDEVBLK$ = 48
CTCX_Close PROC

; 746  : {

$LN6:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 747  : 
; 748  :     // Close the device file (if not already closed)
; 749  :     if( pDEVBLK->fd >= 0 )

  00009	48 8b 44 24 30	 mov	 rax, QWORD PTR pDEVBLK$[rsp]
  0000e	83 b8 ac 01 00
	00 00		 cmp	 DWORD PTR [rax+428], 0
  00015	7c 48		 jl	 SHORT $LN2@CTCX_Close

; 750  :     {
; 751  :         if (socket_is_socket( pDEVBLK->fd ))

  00017	48 8b 44 24 30	 mov	 rax, QWORD PTR pDEVBLK$[rsp]
  0001c	8b 88 ac 01 00
	00		 mov	 ecx, DWORD PTR [rax+428]
  00022	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_socket_is_socket
  00028	85 c0		 test	 eax, eax
  0002a	74 13		 je	 SHORT $LN3@CTCX_Close

; 752  :             close_socket( pDEVBLK->fd );

  0002c	48 8b 44 24 30	 mov	 rax, QWORD PTR pDEVBLK$[rsp]
  00031	8b 88 ac 01 00
	00		 mov	 ecx, DWORD PTR [rax+428]
  00037	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_close_socket
  0003d	eb 11		 jmp	 SHORT $LN4@CTCX_Close
$LN3@CTCX_Close:

; 753  :         else
; 754  :             close( pDEVBLK->fd );

  0003f	48 8b 44 24 30	 mov	 rax, QWORD PTR pDEVBLK$[rsp]
  00044	8b 88 ac 01 00
	00		 mov	 ecx, DWORD PTR [rax+428]
  0004a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_close
$LN4@CTCX_Close:

; 755  :         pDEVBLK->fd = -1;           // indicate we're now closed

  00050	48 8b 44 24 30	 mov	 rax, QWORD PTR pDEVBLK$[rsp]
  00055	c7 80 ac 01 00
	00 ff ff ff ff	 mov	 DWORD PTR [rax+428], -1
$LN2@CTCX_Close:

; 756  :     }
; 757  :     return 0;

  0005f	33 c0		 xor	 eax, eax

; 758  : }

  00061	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00065	c3		 ret	 0
CTCX_Close ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\machdep.h
;	COMDAT fetch_fw_noswap
_TEXT	SEGMENT
value$ = 0
ptr$ = 32
fetch_fw_noswap PROC					; COMDAT

; 746  :     inline U32 fetch_fw_noswap(const void *ptr) {

$LN3:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 18	 sub	 rsp, 24

; 747  :       U32 value;
; 748  :       memcpy(&value, (BYTE *)ptr, 4);

  00009	48 8b 44 24 20	 mov	 rax, QWORD PTR ptr$[rsp]
  0000e	8b 00		 mov	 eax, DWORD PTR [rax]
  00010	89 04 24	 mov	 DWORD PTR value$[rsp], eax

; 749  :       return value;

  00013	8b 04 24	 mov	 eax, DWORD PTR value$[rsp]

; 750  :     }

  00016	48 83 c4 18	 add	 rsp, 24
  0001a	c3		 ret	 0
fetch_fw_noswap ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\machdep.h
;	COMDAT store_hw_noswap
_TEXT	SEGMENT
ptr$ = 8
value$ = 16
store_hw_noswap PROC					; COMDAT

; 730  :     inline void store_hw_noswap(void *ptr, U16 value) {

  00000	66 89 54 24 10	 mov	 WORD PTR [rsp+16], dx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx

; 731  :       memcpy((BYTE *)ptr, (BYTE *)&value, 2);

  0000a	48 8b 44 24 08	 mov	 rax, QWORD PTR ptr$[rsp]
  0000f	0f b7 4c 24 10	 movzx	 ecx, WORD PTR value$[rsp]
  00014	66 89 08	 mov	 WORD PTR [rax], cx

; 732  :     }

  00017	c3		 ret	 0
store_hw_noswap ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\machdep.h
;	COMDAT fetch_hw_noswap
_TEXT	SEGMENT
value$ = 0
ptr$ = 32
fetch_hw_noswap PROC					; COMDAT

; 712  :     inline U16 fetch_hw_noswap(const void *ptr) {

$LN3:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 18	 sub	 rsp, 24

; 713  :       U16 value;
; 714  :       memcpy(&value, (BYTE *)ptr, 2);

  00009	48 8b 44 24 20	 mov	 rax, QWORD PTR ptr$[rsp]
  0000e	0f b7 00	 movzx	 eax, WORD PTR [rax]
  00011	66 89 04 24	 mov	 WORD PTR value$[rsp], ax

; 715  :       return value;

  00015	0f b7 04 24	 movzx	 eax, WORD PTR value$[rsp]

; 716  :     }

  00019	48 83 c4 18	 add	 rsp, 24
  0001d	c3		 ret	 0
fetch_hw_noswap ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files (x86)\Windows Kits\10\include\10.0.22000.0\ucrt\stdio.h
;	COMDAT sscanf
_TEXT	SEGMENT
_Result$ = 32
_ArgList$ = 40
_Buffer$ = 64
_Format$ = 72
sscanf	PROC						; COMDAT

; 2247 :     {

$LN3:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000f	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00014	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 2248 :         int _Result;
; 2249 :         va_list _ArgList;
; 2250 :         __crt_va_start(_ArgList, _Format);

  00018	48 8d 44 24 50	 lea	 rax, QWORD PTR _Format$[rsp+8]
  0001d	48 89 44 24 28	 mov	 QWORD PTR _ArgList$[rsp], rax

; 2251 :         _Result = _vsscanf_l(_Buffer, _Format, NULL, _ArgList);

  00022	4c 8b 4c 24 28	 mov	 r9, QWORD PTR _ArgList$[rsp]
  00027	45 33 c0	 xor	 r8d, r8d
  0002a	48 8b 54 24 48	 mov	 rdx, QWORD PTR _Format$[rsp]
  0002f	48 8b 4c 24 40	 mov	 rcx, QWORD PTR _Buffer$[rsp]
  00034	e8 00 00 00 00	 call	 _vsscanf_l
  00039	89 44 24 20	 mov	 DWORD PTR _Result$[rsp], eax

; 2252 :         __crt_va_end(_ArgList);

  0003d	48 c7 44 24 28
	00 00 00 00	 mov	 QWORD PTR _ArgList$[rsp], 0

; 2253 :         return _Result;

  00046	8b 44 24 20	 mov	 eax, DWORD PTR _Result$[rsp]

; 2254 :     }

  0004a	48 83 c4 38	 add	 rsp, 56			; 00000038H
  0004e	c3		 ret	 0
sscanf	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files (x86)\Windows Kits\10\include\10.0.22000.0\ucrt\stdio.h
;	COMDAT _vsscanf_l
_TEXT	SEGMENT
_Buffer$ = 64
_Format$ = 72
_Locale$ = 80
_ArgList$ = 88
_vsscanf_l PROC						; COMDAT

; 2152 :     {

$LN3:
  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 2153 :         return __stdio_common_vsscanf(

  00018	e8 00 00 00 00	 call	 __local_stdio_scanf_options
  0001d	48 8b 4c 24 58	 mov	 rcx, QWORD PTR _ArgList$[rsp]
  00022	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00027	48 8b 4c 24 50	 mov	 rcx, QWORD PTR _Locale$[rsp]
  0002c	48 89 4c 24 20	 mov	 QWORD PTR [rsp+32], rcx
  00031	4c 8b 4c 24 48	 mov	 r9, QWORD PTR _Format$[rsp]
  00036	49 c7 c0 ff ff
	ff ff		 mov	 r8, -1
  0003d	48 8b 54 24 40	 mov	 rdx, QWORD PTR _Buffer$[rsp]
  00042	48 8b 08	 mov	 rcx, QWORD PTR [rax]
  00045	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___stdio_common_vsscanf

; 2154 :             _CRT_INTERNAL_LOCAL_SCANF_OPTIONS,
; 2155 :             _Buffer, (size_t)-1, _Format, _Locale, _ArgList);
; 2156 :     }

  0004b	48 83 c4 38	 add	 rsp, 56			; 00000038H
  0004f	c3		 ret	 0
_vsscanf_l ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files (x86)\Windows Kits\10\include\10.0.22000.0\ucrt\corecrt_stdio_config.h
;	COMDAT __local_stdio_scanf_options
_TEXT	SEGMENT
__local_stdio_scanf_options PROC			; COMDAT

; 101  :         static unsigned __int64 _OptionsStorage;
; 102  :         return &_OptionsStorage;

  00000	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:?_OptionsStorage@?1??__local_stdio_scanf_options@@9@9 ; `__local_stdio_scanf_options'::`2'::_OptionsStorage

; 103  :     }

  00007	c3		 ret	 0
__local_stdio_scanf_options ENDP
_TEXT	ENDS
END
