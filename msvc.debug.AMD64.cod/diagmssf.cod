; Listing generated by Microsoft (R) Optimizing Compiler Version 19.34.31937.0 

include listing.inc

INCLUDELIB MSVCRTD
INCLUDELIB OLDNAMES

CONST	SEGMENT
CKD_ENDTRK DB	0ffH
	DB	0ffH
	DB	0ffH
	DB	0ffH
	DB	0ffH
	DB	0ffH
	DB	0ffH
	DB	0ffH
CONST	ENDS
PUBLIC	s370_scpend_call
PUBLIC	s370_diag204_call
PUBLIC	s370_diag224_call
PUBLIC	fetch_hw_noswap
PUBLIC	store_hw_noswap
PUBLIC	store_dw_noswap
PUBLIC	_get_storekey_ptr
PUBLIC	_get_storekey1_ptr
PUBLIC	_get_storekey2_ptr
PUBLIC	s370__or_storage_key
PUBLIC	s370_or_2K_storage_key
PUBLIC	s370_or_storage_key
PUBLIC	s390_scpend_call
PUBLIC	s390_mssf_call
PUBLIC	s390_diag204_call
PUBLIC	s390_diag224_call
PUBLIC	s390__or_storage_key
PUBLIC	s390_or_4K_storage_key
PUBLIC	s390_or_storage_key
PUBLIC	z900_scpend_call
PUBLIC	z900_diag204_call
PUBLIC	z900_diag224_call
PUBLIC	z900__or_storage_key
PUBLIC	z900_or_4K_storage_key
PUBLIC	z900_or_storage_key
PUBLIC	z900_maddr_l
EXTRN	_byteswap_ushort:PROC
EXTRN	_byteswap_uint64:PROC
EXTRN	__imp_hthread_obtain_lock:PROC
EXTRN	__imp_hthread_release_lock:PROC
EXTRN	__imp_hthread_signal_condition:PROC
EXTRN	__imp_hthread_wait_condition:PROC
EXTRN	__imp_ptt_pthread_trace:PROC
EXTRN	__imp_ptyp2long:PROC
EXTRN	__imp_clock_gettime:PROC
EXTRN	__imp_sched_yield:PROC
EXTRN	etod_clock:PROC
EXTRN	__imp_host_to_guest:PROC
EXTRN	get_loadparm:PROC
EXTRN	get_lparname:PROC
EXTRN	get_sysname:PROC
EXTRN	get_systype:PROC
EXTRN	get_sysplex:PROC
EXTRN	txf_maddr_l:PROC
EXTRN	s370_program_interrupt:PROC
EXTRN	s390_program_interrupt:PROC
EXTRN	z900_program_interrupt:PROC
EXTRN	z900_logical_to_main_l:PROC
EXTRN	__GSHandlerCheck:PROC
EXTRN	__security_check_cookie:PROC
EXTRN	__imp_pttclass:QWORD
EXTRN	__imp_hostinfo:BYTE
EXTRN	__imp_sysblk:BYTE
EXTRN	__security_cookie:QWORD
pdata	SEGMENT
$pdata$timespec2usecs DD imagerel timespec2usecs
	DD	imagerel timespec2usecs+66
	DD	imagerel $unwind$timespec2usecs
$pdata$s370_scpend_call DD imagerel $LN3
	DD	imagerel $LN3+15
	DD	imagerel $unwind$s370_scpend_call
$pdata$s370_diag204_call DD imagerel $LN24
	DD	imagerel $LN24+1365
	DD	imagerel $unwind$s370_diag204_call
$pdata$s370_diag224_call DD imagerel $LN17
	DD	imagerel $LN17+433
	DD	imagerel $unwind$s370_diag224_call
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$fetch_hw_noswap DD imagerel $LN3
	DD	imagerel $LN3+30
	DD	imagerel $unwind$fetch_hw_noswap
pdata	ENDS
pdata	SEGMENT
$pdata$Interrupt_Lock_Obtained DD imagerel Interrupt_Lock_Obtained
	DD	imagerel Interrupt_Lock_Obtained+269
	DD	imagerel $unwind$Interrupt_Lock_Obtained
$pdata$Obtain_Interrupt_Lock DD imagerel Obtain_Interrupt_Lock
	DD	imagerel Obtain_Interrupt_Lock+88
	DD	imagerel $unwind$Obtain_Interrupt_Lock
$pdata$Release_Interrupt_Lock DD imagerel Release_Interrupt_Lock
	DD	imagerel Release_Interrupt_Lock+71
	DD	imagerel $unwind$Release_Interrupt_Lock
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$_get_storekey_ptr DD imagerel $LN5
	DD	imagerel $LN5+104
	DD	imagerel $unwind$_get_storekey_ptr
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$s370__or_storage_key DD imagerel $LN8
	DD	imagerel $LN8+170
	DD	imagerel $unwind$s370__or_storage_key
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$s370_or_2K_storage_key DD imagerel $LN3
	DD	imagerel $LN3+42
	DD	imagerel $unwind$s370_or_2K_storage_key
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$s370_or_storage_key DD imagerel $LN3
	DD	imagerel $LN3+33
	DD	imagerel $unwind$s370_or_storage_key
pdata	ENDS
pdata	SEGMENT
$pdata$s390_scpend_call DD imagerel $LN3
	DD	imagerel $LN3+15
	DD	imagerel $unwind$s390_scpend_call
$pdata$s390_mssf_call DD imagerel $LN42
	DD	imagerel $LN42+2323
	DD	imagerel $unwind$s390_mssf_call
$pdata$s390_diag204_call DD imagerel $LN24
	DD	imagerel $LN24+1365
	DD	imagerel $unwind$s390_diag204_call
$pdata$s390_diag224_call DD imagerel $LN17
	DD	imagerel $LN17+433
	DD	imagerel $unwind$s390_diag224_call
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$s390__or_storage_key DD imagerel $LN8
	DD	imagerel $LN8+159
	DD	imagerel $unwind$s390__or_storage_key
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$s390_or_4K_storage_key DD imagerel $LN3
	DD	imagerel $LN3+42
	DD	imagerel $unwind$s390_or_4K_storage_key
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$s390_or_storage_key DD imagerel $LN3
	DD	imagerel $LN3+33
	DD	imagerel $unwind$s390_or_storage_key
pdata	ENDS
pdata	SEGMENT
$pdata$z900_scpend_call DD imagerel $LN3
	DD	imagerel $LN3+15
	DD	imagerel $unwind$z900_scpend_call
$pdata$z900_diag204_call DD imagerel $LN47
	DD	imagerel $LN47+3335
	DD	imagerel $unwind$z900_diag204_call
$pdata$z900_diag224_call DD imagerel $LN17
	DD	imagerel $LN17+463
	DD	imagerel $unwind$z900_diag224_call
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$z900__or_storage_key DD imagerel $LN8
	DD	imagerel $LN8+159
	DD	imagerel $unwind$z900__or_storage_key
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$z900_or_4K_storage_key DD imagerel $LN3
	DD	imagerel $LN3+42
	DD	imagerel $unwind$z900_or_4K_storage_key
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$z900_or_storage_key DD imagerel $LN3
	DD	imagerel $LN3+33
	DD	imagerel $unwind$z900_or_storage_key
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$z900_maddr_l DD imagerel $LN18
	DD	imagerel $LN18+657
	DD	imagerel $unwind$z900_maddr_l
pdata	ENDS
_DATA	SEGMENT
$SG169690 DB	'diagmssf.c:723', 00H
	ORG $+1
$SG169691 DB	'*DIAG204', 00H
	ORG $+7
$SG179813 DB	'C:\papa\MyGit\hyperion-zvector\diagmssf.c:318', 00H
	ORG $+2
$SG179815 DB	'C:\papa\MyGit\hyperion-zvector\diagmssf.c:322', 00H
	ORG $+2
$SG179825 DB	'C:\papa\MyGit\hyperion-zvector\diagmssf.c:420', 00H
	ORG $+2
$SG179826 DB	'*DIAG080', 00H
	ORG $+7
$SG179831 DB	'C:\papa\MyGit\hyperion-zvector\diagmssf.c:438', 00H
	ORG $+2
$SG179885 DB	'C:\papa\MyGit\hyperion-zvector\diagmssf.c:723', 00H
	ORG $+2
$SG179886 DB	'*DIAG204', 00H
	ORG $+7
$SG192895 DB	'C:\papa\MyGit\hyperion-zvector\diagmssf.c:723', 00H
	ORG $+2
$SG192896 DB	'*DIAG204', 00H
_DATA	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$z900_maddr_l DD 011801H
	DD	0a218H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$z900_or_storage_key DD 010d01H
	DD	0420dH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$z900_or_4K_storage_key DD 010d01H
	DD	0420dH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$z900__or_storage_key DD 011201H
	DD	08212H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$s390_or_storage_key DD 010d01H
	DD	0420dH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$s390_or_4K_storage_key DD 010d01H
	DD	0420dH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$s390__or_storage_key DD 011201H
	DD	08212H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$s370_or_storage_key DD 010d01H
	DD	0420dH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$s370_or_2K_storage_key DD 010d01H
	DD	0420dH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$s370__or_storage_key DD 011201H
	DD	08212H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$_get_storekey_ptr DD 010d01H
	DD	0220dH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$fetch_hw_noswap DD 010901H
	DD	02209H
xdata	ENDS
voltbl	SEGMENT
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:z900_diag204_call
	DD	020H
	DD	0cedH
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:s390_diag204_call
	DD	020H
	DD	053bH
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:s370_diag204_call
	DD	020H
	DD	053bH
voltbl	ENDS
xdata	SEGMENT
$unwind$timespec2usecs DD 010901H
	DD	02209H
$unwind$s370_scpend_call DD 010401H
	DD	04204H
$unwind$s370_diag204_call DD 042819H
	DD	0990116H
	DD	0600e700fH
	DD	imagerel __GSHandlerCheck
	DD	04b0H
$unwind$s370_diag224_call DD 031301H
	DD	0700f8213H
	DD	0600eH
$unwind$Interrupt_Lock_Obtained DD 010e01H
	DD	0420eH
$unwind$Obtain_Interrupt_Lock DD 010e01H
	DD	0420eH
$unwind$Release_Interrupt_Lock DD 010e01H
	DD	0420eH
$unwind$s390_scpend_call DD 010401H
	DD	04204H
$unwind$s390_mssf_call DD 031501H
	DD	01a0115H
	DD	0700eH
$unwind$s390_diag204_call DD 042819H
	DD	0990116H
	DD	0600e700fH
	DD	imagerel __GSHandlerCheck
	DD	04b0H
$unwind$s390_diag224_call DD 031301H
	DD	0700f8213H
	DD	0600eH
$unwind$z900_scpend_call DD 010401H
	DD	04204H
$unwind$z900_diag204_call DD 042819H
	DD	01230116H
	DD	0600e700fH
	DD	imagerel __GSHandlerCheck
	DD	0900H
$unwind$z900_diag224_call DD 031301H
	DD	0700fa213H
	DD	0600eH
xdata	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\dat.h
;	COMDAT z900_maddr_l
_TEXT	SEGMENT
tlbix$ = 48
aea_crn$ = 52
tv70 = 56
maddr$ = 64
addr$ = 96
len$ = 104
arn$ = 112
regs$ = 120
acctype$ = 128
akey$ = 136
z900_maddr_l PROC					; COMDAT

; 307  : {

$LN18:
  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	48 83 ec 58	 sub	 rsp, 88			; 00000058H

; 308  :     /* Note: ALL of the below conditions must be true for a TLB hit
; 309  :        to occur.  If ANY of them are false, then it's a TLB miss,
; 310  :        requiring us to then perform a full DAT address translation.
; 311  : 
; 312  :        Note too that on the grand scheme of things the order/sequence
; 313  :        of the below tests (if statements) is completely unimportant
; 314  :        since ALL conditions must be checked anyway in order for a hit
; 315  :        to occur, and it doesn't matter that a miss tests a few extra
; 316  :        conditions since it's going to do a full translation anyway!
; 317  :        (which is many, many instructions)
; 318  :     */
; 319  : 
; 320  :     int  aea_crn  = (arn >= USE_ARMODE) ? 0 : regs->AEA_AR( arn );

  00018	83 7c 24 70 10	 cmp	 DWORD PTR arn$[rsp], 16
  0001d	7c 0a		 jl	 SHORT $LN16@z900_maddr
  0001f	c7 44 24 38 00
	00 00 00	 mov	 DWORD PTR tv70[rsp], 0
  00027	eb 19		 jmp	 SHORT $LN17@z900_maddr
$LN16@z900_maddr:
  00029	8b 44 24 70	 mov	 eax, DWORD PTR arn$[rsp]
  0002d	83 c0 05	 add	 eax, 5
  00030	48 98		 cdqe
  00032	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  00037	8b 84 81 94 0c
	00 00		 mov	 eax, DWORD PTR [rcx+rax*4+3220]
  0003e	89 44 24 38	 mov	 DWORD PTR tv70[rsp], eax
$LN17@z900_maddr:
  00042	8b 44 24 38	 mov	 eax, DWORD PTR tv70[rsp]
  00046	89 44 24 34	 mov	 DWORD PTR aea_crn$[rsp], eax

; 321  :     U16  tlbix    = TLBIX( addr );

  0004a	48 8b 44 24 60	 mov	 rax, QWORD PTR addr$[rsp]
  0004f	48 c1 e8 0c	 shr	 rax, 12
  00053	48 25 ff 03 00
	00		 and	 rax, 1023		; 000003ffH
  00059	66 89 44 24 30	 mov	 WORD PTR tlbix$[rsp], ax

; 322  :     BYTE *maddr   = NULL;

  0005e	48 c7 44 24 40
	00 00 00 00	 mov	 QWORD PTR maddr$[rsp], 0

; 323  : 
; 324  :     /* Non-zero AEA Control Register number? */
; 325  :     if (aea_crn)

  00067	83 7c 24 34 00	 cmp	 DWORD PTR aea_crn$[rsp], 0
  0006c	0f 84 2d 01 00
	00		 je	 $LN2@z900_maddr

; 326  :     {
; 327  :         /* Same Addess Space Designator as before? */
; 328  :         /* Or if not, is address in a common segment? */
; 329  :         if (0
; 330  :             || (regs->CR( aea_crn ) == regs->tlb.TLB_ASD( tlbix ))
; 331  :             || (regs->AEA_COMMON( aea_crn ) & regs->tlb.common[ tlbix ])

  00072	33 c0		 xor	 eax, eax
  00074	85 c0		 test	 eax, eax
  00076	75 5a		 jne	 SHORT $LN4@z900_maddr
  00078	8b 44 24 34	 mov	 eax, DWORD PTR aea_crn$[rsp]
  0007c	ff c0		 inc	 eax
  0007e	48 98		 cdqe
  00080	0f b7 4c 24 30	 movzx	 ecx, WORD PTR tlbix$[rsp]
  00085	48 8b 54 24 78	 mov	 rdx, QWORD PTR regs$[rsp]
  0008a	4c 8b 44 24 78	 mov	 r8, QWORD PTR regs$[rsp]
  0008f	49 8b 8c c8 60
	b0 00 00	 mov	 rcx, QWORD PTR [r8+rcx*8+45152]
  00097	48 39 8c c2 00
	06 00 00	 cmp	 QWORD PTR [rdx+rax*8+1536], rcx
  0009f	74 31		 je	 SHORT $LN4@z900_maddr
  000a1	8b 44 24 34	 mov	 eax, DWORD PTR aea_crn$[rsp]
  000a5	ff c0		 inc	 eax
  000a7	48 98		 cdqe
  000a9	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  000ae	0f b6 84 01 e8
	0c 00 00	 movzx	 eax, BYTE PTR [rcx+rax+3304]
  000b6	0f b7 4c 24 30	 movzx	 ecx, WORD PTR tlbix$[rsp]
  000bb	48 8b 54 24 78	 mov	 rdx, QWORD PTR regs$[rsp]
  000c0	0f b6 8c 0a 60
	54 01 00	 movzx	 ecx, BYTE PTR [rdx+rcx+87136]
  000c8	23 c1		 and	 eax, ecx
  000ca	85 c0		 test	 eax, eax
  000cc	0f 84 cd 00 00
	00		 je	 $LN3@z900_maddr
$LN4@z900_maddr:

; 332  :         )
; 333  :         {
; 334  :             /* Storage Key zero? */
; 335  :             /* Or if not, same Storage Key as before? */
; 336  :             if (0
; 337  :                 || akey == 0
; 338  :                 || akey == regs->tlb.skey[ tlbix ]

  000d2	33 c0		 xor	 eax, eax
  000d4	85 c0		 test	 eax, eax
  000d6	75 2e		 jne	 SHORT $LN6@z900_maddr
  000d8	0f b6 84 24 88
	00 00 00	 movzx	 eax, BYTE PTR akey$[rsp]
  000e0	85 c0		 test	 eax, eax
  000e2	74 22		 je	 SHORT $LN6@z900_maddr
  000e4	0f b6 84 24 88
	00 00 00	 movzx	 eax, BYTE PTR akey$[rsp]
  000ec	0f b7 4c 24 30	 movzx	 ecx, WORD PTR tlbix$[rsp]
  000f1	48 8b 54 24 78	 mov	 rdx, QWORD PTR regs$[rsp]
  000f6	0f b6 8c 0a 60
	50 01 00	 movzx	 ecx, BYTE PTR [rdx+rcx+86112]
  000fe	3b c1		 cmp	 eax, ecx
  00100	0f 85 99 00 00
	00		 jne	 $LN5@z900_maddr
$LN6@z900_maddr:

; 339  :             )
; 340  :             {
; 341  :                 /* Does the page address match the one in the TLB? */
; 342  :                 /* (does a TLB entry exist for this page address?) */
; 343  :                 if (
; 344  :                     ((addr & TLBID_PAGEMASK) | regs->tlbID)
; 345  :                     ==

  00106	48 8b 44 24 60	 mov	 rax, QWORD PTR addr$[rsp]
  0010b	48 25 00 00 c0
	ff		 and	 rax, -4194304		; ffffffffffc00000H
  00111	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  00116	8b 89 58 b0 00
	00		 mov	 ecx, DWORD PTR [rcx+45144]
  0011c	48 0b c1	 or	 rax, rcx
  0011f	0f b7 4c 24 30	 movzx	 ecx, WORD PTR tlbix$[rsp]
  00124	48 8b 54 24 78	 mov	 rdx, QWORD PTR regs$[rsp]
  00129	48 3b 84 ca 60
	d0 00 00	 cmp	 rax, QWORD PTR [rdx+rcx*8+53344]
  00131	75 6c		 jne	 SHORT $LN7@z900_maddr

; 346  :                     regs->tlb.TLB_VADDR( tlbix )
; 347  :                 )
; 348  :                 {
; 349  :                     /* Is storage being accessed same way as before? */
; 350  :                     if (acctype & regs->tlb.acc[ tlbix ])

  00133	0f b7 44 24 30	 movzx	 eax, WORD PTR tlbix$[rsp]
  00138	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  0013d	0f b6 84 01 60
	5c 01 00	 movzx	 eax, BYTE PTR [rcx+rax+89184]
  00145	8b 8c 24 80 00
	00 00		 mov	 ecx, DWORD PTR acctype$[rsp]
  0014c	23 c8		 and	 ecx, eax
  0014e	8b c1		 mov	 eax, ecx
  00150	85 c0		 test	 eax, eax
  00152	74 4b		 je	 SHORT $LN8@z900_maddr

; 351  :                     {
; 352  :                         /*------------------------------------------*/
; 353  :                         /* TLB hit: use previously translated value */
; 354  :                         /*------------------------------------------*/
; 355  : 
; 356  :                         if (acctype & ACC_CHECK)

  00154	8b 84 24 80 00
	00 00		 mov	 eax, DWORD PTR acctype$[rsp]
  0015b	83 e0 01	 and	 eax, 1
  0015e	85 c0		 test	 eax, eax
  00160	74 1e		 je	 SHORT $LN9@z900_maddr

; 357  :                             regs->dat.storkey = regs->tlb.storkey[ tlbix ];

  00162	0f b7 44 24 30	 movzx	 eax, WORD PTR tlbix$[rsp]
  00167	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  0016c	48 8b 54 24 78	 mov	 rdx, QWORD PTR regs$[rsp]
  00171	48 8b 84 c2 60
	30 01 00	 mov	 rax, QWORD PTR [rdx+rax*8+77920]
  00179	48 89 81 28 08
	00 00		 mov	 QWORD PTR [rcx+2088], rax
$LN9@z900_maddr:

; 358  : 
; 359  :                         maddr = MAINADDR( regs->tlb.main[tlbix], addr );

  00180	0f b7 44 24 30	 movzx	 eax, WORD PTR tlbix$[rsp]
  00185	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  0018a	48 8b 54 24 60	 mov	 rdx, QWORD PTR addr$[rsp]
  0018f	48 8b 84 c1 60
	10 01 00	 mov	 rax, QWORD PTR [rcx+rax*8+69728]
  00197	48 33 c2	 xor	 rax, rdx
  0019a	48 89 44 24 40	 mov	 QWORD PTR maddr$[rsp], rax
$LN8@z900_maddr:
$LN7@z900_maddr:
$LN5@z900_maddr:
$LN3@z900_maddr:
$LN2@z900_maddr:

; 360  :                     }
; 361  :                 }
; 362  :             }
; 363  :         }
; 364  :     }
; 365  : 
; 366  :     /*---------------------------------------*/
; 367  :     /* TLB miss: do full address translation */
; 368  :     /*---------------------------------------*/
; 369  :     if (!maddr)

  0019f	48 83 7c 24 40
	00		 cmp	 QWORD PTR maddr$[rsp], 0
  001a5	75 36		 jne	 SHORT $LN10@z900_maddr

; 370  :         maddr = ARCH_DEP( logical_to_main_l )( addr, arn, regs, acctype, akey, len );

  001a7	48 8b 44 24 68	 mov	 rax, QWORD PTR len$[rsp]
  001ac	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  001b1	0f b6 84 24 88
	00 00 00	 movzx	 eax, BYTE PTR akey$[rsp]
  001b9	88 44 24 20	 mov	 BYTE PTR [rsp+32], al
  001bd	44 8b 8c 24 80
	00 00 00	 mov	 r9d, DWORD PTR acctype$[rsp]
  001c5	4c 8b 44 24 78	 mov	 r8, QWORD PTR regs$[rsp]
  001ca	8b 54 24 70	 mov	 edx, DWORD PTR arn$[rsp]
  001ce	48 8b 4c 24 60	 mov	 rcx, QWORD PTR addr$[rsp]
  001d3	e8 00 00 00 00	 call	 z900_logical_to_main_l
  001d8	48 89 44 24 40	 mov	 QWORD PTR maddr$[rsp], rax
$LN10@z900_maddr:

; 371  : 
; 372  : #if defined( FEATURE_073_TRANSACT_EXEC_FACILITY )
; 373  :     if (FACILITY_ENABLED( 073_TRANSACT_EXEC, regs ))

  001dd	b8 01 00 00 00	 mov	 eax, 1
  001e2	48 6b c0 09	 imul	 rax, rax, 9
  001e6	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  001eb	0f b6 84 01 28
	0d 00 00	 movzx	 eax, BYTE PTR [rcx+rax+3368]
  001f3	83 e0 40	 and	 eax, 64			; 00000040H
  001f6	85 c0		 test	 eax, eax
  001f8	0f 84 89 00 00
	00		 je	 $LN11@z900_maddr

; 374  :     {
; 375  :         /* SA22-7832-12 Principles of Operation, page 5-99:
; 376  : 
; 377  :              "Storage accesses for instruction and DAT- and ART-
; 378  :               table fetches follow the non-transactional rules."
; 379  :         */
; 380  :         if (0
; 381  :             || !regs
; 382  :             || !regs->txf_tnd
; 383  :             || arn == USE_INST_SPACE    /* Instruction fetching */
; 384  :             || arn == USE_REAL_ADDR     /* Address translation  */

  001fe	33 c0		 xor	 eax, eax
  00200	85 c0		 test	 eax, eax
  00202	75 26		 jne	 SHORT $LN13@z900_maddr
  00204	48 83 7c 24 78
	00		 cmp	 QWORD PTR regs$[rsp], 0
  0020a	74 1e		 je	 SHORT $LN13@z900_maddr
  0020c	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  00211	0f b6 80 58 0e
	00 00		 movzx	 eax, BYTE PTR [rax+3672]
  00218	85 c0		 test	 eax, eax
  0021a	74 0e		 je	 SHORT $LN13@z900_maddr
  0021c	83 7c 24 70 ff	 cmp	 DWORD PTR arn$[rsp], -1
  00221	74 07		 je	 SHORT $LN13@z900_maddr
  00223	83 7c 24 70 fe	 cmp	 DWORD PTR arn$[rsp], -2
  00228	75 07		 jne	 SHORT $LN12@z900_maddr
$LN13@z900_maddr:

; 385  :         )
; 386  :             return maddr;

  0022a	48 8b 44 24 40	 mov	 rax, QWORD PTR maddr$[rsp]
  0022f	eb 5b		 jmp	 SHORT $LN1@z900_maddr
$LN12@z900_maddr:

; 387  : 
; 388  :         /* Quick exit if NTSTG call */
; 389  :         if (regs->txf_NTSTG)

  00231	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  00236	0f b6 80 4b 0e
	00 00		 movzx	 eax, BYTE PTR [rax+3659]
  0023d	85 c0		 test	 eax, eax
  0023f	74 13		 je	 SHORT $LN14@z900_maddr

; 390  :         {
; 391  :             regs->txf_NTSTG = false;

  00241	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  00246	c6 80 4b 0e 00
	00 00		 mov	 BYTE PTR [rax+3659], 0

; 392  :             return maddr;

  0024d	48 8b 44 24 40	 mov	 rax, QWORD PTR maddr$[rsp]
  00252	eb 38		 jmp	 SHORT $LN1@z900_maddr
$LN14@z900_maddr:

; 393  :         }
; 394  : 
; 395  :         /* Translate to alternate TXF address */
; 396  :         maddr = TXF_MADDRL( addr, len, arn, regs, acctype, maddr );

  00254	48 8b 44 24 40	 mov	 rax, QWORD PTR maddr$[rsp]
  00259	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  0025e	8b 84 24 80 00
	00 00		 mov	 eax, DWORD PTR acctype$[rsp]
  00265	89 44 24 20	 mov	 DWORD PTR [rsp+32], eax
  00269	4c 8b 4c 24 78	 mov	 r9, QWORD PTR regs$[rsp]
  0026e	44 8b 44 24 70	 mov	 r8d, DWORD PTR arn$[rsp]
  00273	48 8b 54 24 68	 mov	 rdx, QWORD PTR len$[rsp]
  00278	48 8b 4c 24 60	 mov	 rcx, QWORD PTR addr$[rsp]
  0027d	e8 00 00 00 00	 call	 txf_maddr_l
  00282	48 89 44 24 40	 mov	 QWORD PTR maddr$[rsp], rax
$LN11@z900_maddr:

; 397  :     }
; 398  : #endif
; 399  : 
; 400  :     return maddr;

  00287	48 8b 44 24 40	 mov	 rax, QWORD PTR maddr$[rsp]
$LN1@z900_maddr:

; 401  : }

  0028c	48 83 c4 58	 add	 rsp, 88			; 00000058H
  00290	c3		 ret	 0
z900_maddr_l ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\skey.h
;	COMDAT z900_or_storage_key
_TEXT	SEGMENT
abs$ = 48
bits$ = 56
z900_or_storage_key PROC				; COMDAT

; 290  : {

$LN3:
  00000	88 54 24 10	 mov	 BYTE PTR [rsp+16], dl
  00004	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00009	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 291  : #if defined( FEATURE_2K_STORAGE_KEYS )
; 292  :     ARCH_DEP( or_2K_storage_key )( abs, bits );
; 293  : #else
; 294  :     ARCH_DEP( or_4K_storage_key )( abs, bits );

  0000d	0f b6 54 24 38	 movzx	 edx, BYTE PTR bits$[rsp]
  00012	48 8b 4c 24 30	 mov	 rcx, QWORD PTR abs$[rsp]
  00017	e8 00 00 00 00	 call	 z900_or_4K_storage_key

; 295  : #endif
; 296  : }

  0001c	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00020	c3		 ret	 0
z900_or_storage_key ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\skey.h
;	COMDAT z900_or_4K_storage_key
_TEXT	SEGMENT
abs$ = 48
bits$ = 56
z900_or_4K_storage_key PROC				; COMDAT

; 242  :   inline void  ARCH_DEP( or_4K_storage_key )      (              U64 abs, BYTE bits ) {        ARCH_DEP( _or_storage_key      )(      abs, bits & ~STORKEY_BADFRM, 4 ); }

$LN3:
  00000	88 54 24 10	 mov	 BYTE PTR [rsp+16], dl
  00004	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00009	48 83 ec 28	 sub	 rsp, 40			; 00000028H
  0000d	0f b6 44 24 38	 movzx	 eax, BYTE PTR bits$[rsp]
  00012	83 e0 fe	 and	 eax, -2
  00015	41 b0 04	 mov	 r8b, 4
  00018	0f b6 d0	 movzx	 edx, al
  0001b	48 8b 4c 24 30	 mov	 rcx, QWORD PTR abs$[rsp]
  00020	e8 00 00 00 00	 call	 z900__or_storage_key
  00025	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00029	c3		 ret	 0
z900_or_4K_storage_key ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\skey.h
;	COMDAT z900__or_storage_key
_TEXT	SEGMENT
skey1_ptr$1 = 32
skey2_ptr$2 = 40
skey_ptr$3 = 48
abs$ = 80
bits$ = 88
K$ = 96
z900__or_storage_key PROC				; COMDAT

; 189  : {

$LN8:
  00000	44 88 44 24 18	 mov	 BYTE PTR [rsp+24], r8b
  00005	88 54 24 10	 mov	 BYTE PTR [rsp+16], dl
  00009	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000e	48 83 ec 48	 sub	 rsp, 72			; 00000048H
$LN4@z900__or_s:

; 190  :     UNREFERENCED( K ); // (for FEATURE_4K_STORAGE_KEYS case)

  00012	33 c0		 xor	 eax, eax
  00014	85 c0		 test	 eax, eax
  00016	75 fa		 jne	 SHORT $LN4@z900__or_s

; 191  :     if (IS_DOUBLE_KEYED_4K_BYTE_BLOCK( K ))

  00018	33 c0		 xor	 eax, eax
  0001a	85 c0		 test	 eax, eax
  0001c	74 50		 je	 SHORT $LN5@z900__or_s

; 192  :     {
; 193  :         BYTE* skey1_ptr = _get_storekey1_ptr( abs );

  0001e	48 8b 4c 24 50	 mov	 rcx, QWORD PTR abs$[rsp]
  00023	e8 00 00 00 00	 call	 _get_storekey1_ptr
  00028	48 89 44 24 20	 mov	 QWORD PTR skey1_ptr$1[rsp], rax

; 194  :         BYTE* skey2_ptr = _get_storekey2_ptr( abs );

  0002d	48 8b 4c 24 50	 mov	 rcx, QWORD PTR abs$[rsp]
  00032	e8 00 00 00 00	 call	 _get_storekey2_ptr
  00037	48 89 44 24 28	 mov	 QWORD PTR skey2_ptr$2[rsp], rax

; 195  :         OR_SKEY( skey1_ptr, bits );

  0003c	0f b6 44 24 58	 movzx	 eax, BYTE PTR bits$[rsp]
  00041	48 8b 4c 24 20	 mov	 rcx, QWORD PTR skey1_ptr$1[rsp]
  00046	0f b6 09	 movzx	 ecx, BYTE PTR [rcx]
  00049	0b c8		 or	 ecx, eax
  0004b	8b c1		 mov	 eax, ecx
  0004d	48 8b 4c 24 20	 mov	 rcx, QWORD PTR skey1_ptr$1[rsp]
  00052	88 01		 mov	 BYTE PTR [rcx], al

; 196  :         OR_SKEY( skey2_ptr, bits );

  00054	0f b6 44 24 58	 movzx	 eax, BYTE PTR bits$[rsp]
  00059	48 8b 4c 24 28	 mov	 rcx, QWORD PTR skey2_ptr$2[rsp]
  0005e	0f b6 09	 movzx	 ecx, BYTE PTR [rcx]
  00061	0b c8		 or	 ecx, eax
  00063	8b c1		 mov	 eax, ecx
  00065	48 8b 4c 24 28	 mov	 rcx, QWORD PTR skey2_ptr$2[rsp]
  0006a	88 01		 mov	 BYTE PTR [rcx], al

; 197  :     }

  0006c	eb 2c		 jmp	 SHORT $LN6@z900__or_s
$LN5@z900__or_s:

; 198  :     else
; 199  :     {
; 200  :         BYTE* skey_ptr  = _get_storekey_ptr( abs, K );

  0006e	0f b6 54 24 60	 movzx	 edx, BYTE PTR K$[rsp]
  00073	48 8b 4c 24 50	 mov	 rcx, QWORD PTR abs$[rsp]
  00078	e8 00 00 00 00	 call	 _get_storekey_ptr
  0007d	48 89 44 24 30	 mov	 QWORD PTR skey_ptr$3[rsp], rax

; 201  :         OR_SKEY( skey_ptr, bits );

  00082	0f b6 44 24 58	 movzx	 eax, BYTE PTR bits$[rsp]
  00087	48 8b 4c 24 30	 mov	 rcx, QWORD PTR skey_ptr$3[rsp]
  0008c	0f b6 09	 movzx	 ecx, BYTE PTR [rcx]
  0008f	0b c8		 or	 ecx, eax
  00091	8b c1		 mov	 eax, ecx
  00093	48 8b 4c 24 30	 mov	 rcx, QWORD PTR skey_ptr$3[rsp]
  00098	88 01		 mov	 BYTE PTR [rcx], al
$LN6@z900__or_s:

; 202  :     }
; 203  : }

  0009a	48 83 c4 48	 add	 rsp, 72			; 00000048H
  0009e	c3		 ret	 0
z900__or_storage_key ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\diagmssf.c
_TEXT	SEGMENT
i$ = 32
ptyp$ = 36
len$ = 40
p$ = 48
abs$ = 56
tv128 = 64
r1$ = 112
r2$ = 120
regs$ = 128
z900_diag224_call PROC

; 735  : {

$LN17:
  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00009	89 4c 24 08	 mov	 DWORD PTR [rsp+8], ecx
  0000d	56		 push	 rsi
  0000e	57		 push	 rdi
  0000f	48 83 ec 58	 sub	 rsp, 88			; 00000058H
$LN4@z900_diag2:

; 736  : RADR              abs;                 /* abs addr of data area      */
; 737  : BYTE             *p;                   /* pointer to the data area   */
; 738  : unsigned int      len, ptyp, i;        /* work                       */
; 739  : 
; 740  :     // FIXME:  This function is probably incomplete.
; 741  :     //         See linux/arch/s390/hypfs/hypfs_diag.c
; 742  : 
; 743  :     UNREFERENCED( r1 );

  00013	33 c0		 xor	 eax, eax
  00015	85 c0		 test	 eax, eax
  00017	75 fa		 jne	 SHORT $LN4@z900_diag2

; 744  : 
; 745  :     abs = APPLY_PREFIXING( regs->GR_L( r2 ), regs->PX );

  00019	48 63 44 24 78	 movsxd	 rax, DWORD PTR r2$[rsp]
  0001e	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00026	8b 84 c1 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax*8+640]
  0002d	48 25 00 e0 ff
	ff		 and	 rax, -8192		; ffffffffffffe000H
  00033	48 85 c0	 test	 rax, rax
  00036	74 43		 je	 SHORT $LN15@z900_diag2
  00038	48 63 44 24 78	 movsxd	 rax, DWORD PTR r2$[rsp]
  0003d	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00045	8b 84 c1 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax*8+640]
  0004c	48 25 00 e0 ff
	ff		 and	 rax, -8192		; ffffffffffffe000H
  00052	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0005a	48 3b 41 70	 cmp	 rax, QWORD PTR [rcx+112]
  0005e	74 1b		 je	 SHORT $LN15@z900_diag2
  00060	48 63 44 24 78	 movsxd	 rax, DWORD PTR r2$[rsp]
  00065	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0006d	8b 84 c1 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax*8+640]
  00074	48 89 44 24 40	 mov	 QWORD PTR tv128[rsp], rax
  00079	eb 25		 jmp	 SHORT $LN16@z900_diag2
$LN15@z900_diag2:
  0007b	48 63 44 24 78	 movsxd	 rax, DWORD PTR r2$[rsp]
  00080	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00088	8b 84 c1 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax*8+640]
  0008f	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00097	48 33 41 70	 xor	 rax, QWORD PTR [rcx+112]
  0009b	48 89 44 24 40	 mov	 QWORD PTR tv128[rsp], rax
$LN16@z900_diag2:
  000a0	48 8b 44 24 40	 mov	 rax, QWORD PTR tv128[rsp]
  000a5	48 89 44 24 38	 mov	 QWORD PTR abs$[rsp], rax

; 746  : 
; 747  :     /* Program check if data area is not on a page boundary */
; 748  :     if ((abs & PAGEFRAME_BYTEMASK) != 0)

  000aa	48 8b 44 24 38	 mov	 rax, QWORD PTR abs$[rsp]
  000af	48 25 ff 0f 00
	00		 and	 rax, 4095		; 00000fffH
  000b5	48 85 c0	 test	 rax, rax
  000b8	74 12		 je	 SHORT $LN11@z900_diag2

; 749  :         ARCH_DEP( program_interrupt )( regs, PGM_SPECIFICATION_EXCEPTION );

  000ba	ba 06 00 00 00	 mov	 edx, 6
  000bf	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  000c7	e8 00 00 00 00	 call	 z900_program_interrupt
$LN11@z900_diag2:

; 750  : 
; 751  :     /* Calculate length of data to be stored */
; 752  :     len = 16 + ((MAX_SCCB_PTYP + 1) * 16);

  000cc	c7 44 24 28 70
	00 00 00	 mov	 DWORD PTR len$[rsp], 112 ; 00000070H

; 753  : 
; 754  :     /* Program check if data area is outside main storage */
; 755  :     if (abs > regs->mainlim || len > PAGEFRAME_PAGESIZE)

  000d4	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  000dc	48 8b 80 58 08
	00 00		 mov	 rax, QWORD PTR [rax+2136]
  000e3	48 39 44 24 38	 cmp	 QWORD PTR abs$[rsp], rax
  000e8	77 0a		 ja	 SHORT $LN13@z900_diag2
  000ea	81 7c 24 28 00
	10 00 00	 cmp	 DWORD PTR len$[rsp], 4096 ; 00001000H
  000f2	76 12		 jbe	 SHORT $LN12@z900_diag2
$LN13@z900_diag2:

; 756  :         ARCH_DEP( program_interrupt )( regs, PGM_ADDRESSING_EXCEPTION );

  000f4	ba 05 00 00 00	 mov	 edx, 5
  000f9	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00101	e8 00 00 00 00	 call	 z900_program_interrupt
$LN12@z900_diag2:

; 757  : 
; 758  :     /* Mark page referenced */
; 759  :     ARCH_DEP( or_storage_key )( abs, (STORKEY_REF | STORKEY_CHANGE) );

  00106	b2 06		 mov	 dl, 6
  00108	48 8b 4c 24 38	 mov	 rcx, QWORD PTR abs$[rsp]
  0010d	e8 00 00 00 00	 call	 z900_or_storage_key

; 760  : 
; 761  :     /* Point to DIAG 224 return area */
; 762  :     p = regs->mainstor + abs;

  00112	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0011a	48 8b 80 48 08
	00 00		 mov	 rax, QWORD PTR [rax+2120]
  00121	48 03 44 24 38	 add	 rax, QWORD PTR abs$[rsp]
  00126	48 89 44 24 30	 mov	 QWORD PTR p$[rsp], rax

; 763  : 
; 764  :     /*
; 765  :     ** The first byte of the first 16-byte entry contains the total number
; 766  :     ** of 16-byte entries minus 1 that immediately follows the first entry.
; 767  :     ** The remaining 15 bytes of the first 16-byte entry are binary zeros.
; 768  :     ** Each of the remaining entries following the first one contains the
; 769  :     ** EBCDIC name of each processor type.
; 770  :     */
; 771  : 
; 772  :     *p = MAX_SCCB_PTYP;         /* (number of entries which follows-1) */

  0012b	48 8b 44 24 30	 mov	 rax, QWORD PTR p$[rsp]
  00130	c6 00 05	 mov	 BYTE PTR [rax], 5

; 773  :     memset( p+1, 0, 16-1 );     /* (pad first entry with binary zeros) */

  00133	48 8b 44 24 30	 mov	 rax, QWORD PTR p$[rsp]
  00138	48 ff c0	 inc	 rax
  0013b	48 8b f8	 mov	 rdi, rax
  0013e	33 c0		 xor	 eax, eax
  00140	b9 0f 00 00 00	 mov	 ecx, 15
  00145	f3 aa		 rep stosb

; 774  : 
; 775  :     for (ptyp=0; ptyp <= MAX_SCCB_PTYP; ptyp++)

  00147	c7 44 24 24 00
	00 00 00	 mov	 DWORD PTR ptyp$[rsp], 0
  0014f	eb 0a		 jmp	 SHORT $LN7@z900_diag2
$LN5@z900_diag2:
  00151	8b 44 24 24	 mov	 eax, DWORD PTR ptyp$[rsp]
  00155	ff c0		 inc	 eax
  00157	89 44 24 24	 mov	 DWORD PTR ptyp$[rsp], eax
$LN7@z900_diag2:
  0015b	83 7c 24 24 05	 cmp	 DWORD PTR ptyp$[rsp], 5
  00160	77 66		 ja	 SHORT $LN6@z900_diag2

; 776  :     {
; 777  :         p += 16;                              /* point to next entry   */

  00162	48 8b 44 24 30	 mov	 rax, QWORD PTR p$[rsp]
  00167	48 83 c0 10	 add	 rax, 16
  0016b	48 89 44 24 30	 mov	 QWORD PTR p$[rsp], rax

; 778  :         memcpy( p, ptyp2long( ptyp ), 16 );   /* move in ASCII value   */

  00170	0f b6 4c 24 24	 movzx	 ecx, BYTE PTR ptyp$[rsp]
  00175	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ptyp2long
  0017b	48 8b 7c 24 30	 mov	 rdi, QWORD PTR p$[rsp]
  00180	48 8b f0	 mov	 rsi, rax
  00183	b9 10 00 00 00	 mov	 ecx, 16
  00188	f3 a4		 rep movsb

; 779  :         for (i=0; i < 16; i++)

  0018a	c7 44 24 20 00
	00 00 00	 mov	 DWORD PTR i$[rsp], 0
  00192	eb 0a		 jmp	 SHORT $LN10@z900_diag2
$LN8@z900_diag2:
  00194	8b 44 24 20	 mov	 eax, DWORD PTR i$[rsp]
  00198	ff c0		 inc	 eax
  0019a	89 44 24 20	 mov	 DWORD PTR i$[rsp], eax
$LN10@z900_diag2:
  0019e	83 7c 24 20 10	 cmp	 DWORD PTR i$[rsp], 16
  001a3	73 21		 jae	 SHORT $LN9@z900_diag2

; 780  :             p[i] = host_to_guest( p[i] );     /* convert it to EBCDIC  */

  001a5	8b 44 24 20	 mov	 eax, DWORD PTR i$[rsp]
  001a9	48 8b 4c 24 30	 mov	 rcx, QWORD PTR p$[rsp]
  001ae	0f b6 0c 01	 movzx	 ecx, BYTE PTR [rcx+rax]
  001b2	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_host_to_guest
  001b8	8b 4c 24 20	 mov	 ecx, DWORD PTR i$[rsp]
  001bc	48 8b 54 24 30	 mov	 rdx, QWORD PTR p$[rsp]
  001c1	88 04 0a	 mov	 BYTE PTR [rdx+rcx], al
  001c4	eb ce		 jmp	 SHORT $LN8@z900_diag2
$LN9@z900_diag2:

; 781  :     }

  001c6	eb 89		 jmp	 SHORT $LN5@z900_diag2
$LN6@z900_diag2:

; 782  : 
; 783  : } /* end function diag224_call */

  001c8	48 83 c4 58	 add	 rsp, 88			; 00000058H
  001cc	5f		 pop	 rdi
  001cd	5e		 pop	 rsi
  001ce	c3		 ret	 0
z900_diag224_call ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\diagmssf.c
_TEXT	SEGMENT
i$ = 64
cpuxinfo$ = 72
partxinfo$ = 80
tv69 = 88
cpuinfo$ = 96
hdrxinfo$ = 104
hdrinfo$ = 112
partinfo$ = 120
abs$ = 128
tv84 = 136
tv133 = 144
tv168 = 152
tv151 = 160
tv169 = 168
tv366 = 176
tv209 = 184
tv407 = 192
$T1 = 208
ETOD$ = 224
cputime$ = 240
uCPU$ = 256
tCPU$ = 768
oCPU$ = 1280
wCPU$ = 1792
__$ArrayPad$ = 2304
r1$ = 2352
r2$ = 2360
regs$ = 2368
z900_diag204_call PROC

; 450  : {

$LN47:
  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00009	89 4c 24 08	 mov	 DWORD PTR [rsp+8], ecx
  0000d	56		 push	 rsi
  0000e	57		 push	 rdi
  0000f	48 81 ec 18 09
	00 00		 sub	 rsp, 2328		; 00000918H
  00016	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  0001d	48 33 c4	 xor	 rax, rsp
  00020	48 89 84 24 00
	09 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 451  : DIAG204_HDR       *hdrinfo;            /* Header                     */
; 452  : DIAG204_PART      *partinfo;           /* Partition info             */
; 453  : DIAG204_PART_CPU  *cpuinfo;            /* CPU info                   */
; 454  : 
; 455  : #if defined( FEATURE_EXTENDED_DIAG204 )
; 456  : DIAG204_X_HDR       *hdrxinfo;         /* Header                     */
; 457  : DIAG204_X_PART      *partxinfo;        /* Partition info             */
; 458  : DIAG204_X_PART_CPU  *cpuxinfo;         /* CPU info                   */
; 459  : #endif
; 460  : 
; 461  : RADR             abs;                  /* abs addr of data area      */
; 462  : int              i;                    /* loop counter               */
; 463  : struct timespec  cputime;              /* to obtain thread time data */
; 464  : ETOD             ETOD;                 /* Extended TOD clock         */
; 465  : U64              uCPU[ MAX_CPU_ENGS ]; /* User CPU time    (usecs)   */
; 466  : U64              tCPU[ MAX_CPU_ENGS ]; /* Total CPU time   (usecs)   */
; 467  : 
; 468  : #if defined( FEATURE_PHYSICAL_DIAG204 )
; 469  : static BYTE       physical[8] =
; 470  :               {0xD7,0xC8,0xE8,0xE2,0xC9,0xC3,0xC1,0xD3}; /* PHYSICAL */
; 471  : #endif
; 472  : 
; 473  : #if defined( FEATURE_EXTENDED_DIAG204 )
; 474  : U64              oCPU[ MAX_CPU_ENGS ];  /* Online CPU time  (usecs)  */
; 475  : U64              wCPU[ MAX_CPU_ENGS ];  /* Wait CPU time    (usecs)  */
; 476  : #endif
; 477  : 
; 478  :     /* Test DIAG204 command word */
; 479  :     switch (regs->GR_L(r2)) {

  00028	48 63 84 24 38
	09 00 00	 movsxd	 rax, DWORD PTR r2$[rsp]
  00030	48 8b 8c 24 40
	09 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00038	8b 84 c1 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax*8+640]
  0003f	89 44 24 58	 mov	 DWORD PTR tv69[rsp], eax
  00043	83 7c 24 58 04	 cmp	 DWORD PTR tv69[rsp], 4
  00048	74 2f		 je	 SHORT $LN19@z900_diag2
  0004a	81 7c 24 58 05
	00 01 00	 cmp	 DWORD PTR tv69[rsp], 65541 ; 00010005H
  00052	0f 84 ab 05 00
	00		 je	 $LN25@z900_diag2
  00058	81 7c 24 58 06
	00 01 00	 cmp	 DWORD PTR tv69[rsp], 65542 ; 00010006H
  00060	0f 84 0b 06 00
	00		 je	 $LN26@z900_diag2
  00066	81 7c 24 58 07
	00 01 00	 cmp	 DWORD PTR tv69[rsp], 65543 ; 00010007H
  0006e	0f 84 fd 05 00
	00		 je	 $LN27@z900_diag2
  00074	e9 ce 0b 00 00	 jmp	 $LN32@z900_diag2
$LN19@z900_diag2:

; 480  : 
; 481  :     case 0x04:
; 482  : 
; 483  :         abs = APPLY_PREFIXING (GR_A(r1,regs), regs->PX);

  00079	48 8b 84 24 40
	09 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00081	8b 80 80 00 00
	00		 mov	 eax, DWORD PTR [rax+128]
  00087	83 e0 01	 and	 eax, 1
  0008a	85 c0		 test	 eax, eax
  0008c	74 22		 je	 SHORT $LN35@z900_diag2
  0008e	48 63 84 24 30
	09 00 00	 movsxd	 rax, DWORD PTR r1$[rsp]
  00096	48 8b 8c 24 40
	09 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0009e	48 8b 84 c1 80
	02 00 00	 mov	 rax, QWORD PTR [rcx+rax*8+640]
  000a6	48 89 84 24 88
	00 00 00	 mov	 QWORD PTR tv84[rsp], rax
  000ae	eb 1f		 jmp	 SHORT $LN36@z900_diag2
$LN35@z900_diag2:
  000b0	48 63 84 24 30
	09 00 00	 movsxd	 rax, DWORD PTR r1$[rsp]
  000b8	48 8b 8c 24 40
	09 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  000c0	8b 84 c1 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax*8+640]
  000c7	48 89 84 24 88
	00 00 00	 mov	 QWORD PTR tv84[rsp], rax
$LN36@z900_diag2:
  000cf	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR tv84[rsp]
  000d7	48 25 00 e0 ff
	ff		 and	 rax, -8192		; ffffffffffffe000H
  000dd	48 85 c0	 test	 rax, rax
  000e0	0f 84 da 00 00
	00		 je	 $LN39@z900_diag2
  000e6	48 8b 84 24 40
	09 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  000ee	8b 80 80 00 00
	00		 mov	 eax, DWORD PTR [rax+128]
  000f4	83 e0 01	 and	 eax, 1
  000f7	85 c0		 test	 eax, eax
  000f9	74 22		 je	 SHORT $LN37@z900_diag2
  000fb	48 63 84 24 30
	09 00 00	 movsxd	 rax, DWORD PTR r1$[rsp]
  00103	48 8b 8c 24 40
	09 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0010b	48 8b 84 c1 80
	02 00 00	 mov	 rax, QWORD PTR [rcx+rax*8+640]
  00113	48 89 84 24 90
	00 00 00	 mov	 QWORD PTR tv133[rsp], rax
  0011b	eb 1f		 jmp	 SHORT $LN38@z900_diag2
$LN37@z900_diag2:
  0011d	48 63 84 24 30
	09 00 00	 movsxd	 rax, DWORD PTR r1$[rsp]
  00125	48 8b 8c 24 40
	09 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0012d	8b 84 c1 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax*8+640]
  00134	48 89 84 24 90
	00 00 00	 mov	 QWORD PTR tv133[rsp], rax
$LN38@z900_diag2:
  0013c	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR tv133[rsp]
  00144	48 25 00 e0 ff
	ff		 and	 rax, -8192		; ffffffffffffe000H
  0014a	48 8b 8c 24 40
	09 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00152	48 3b 41 70	 cmp	 rax, QWORD PTR [rcx+112]
  00156	74 68		 je	 SHORT $LN39@z900_diag2
  00158	48 8b 84 24 40
	09 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00160	8b 80 80 00 00
	00		 mov	 eax, DWORD PTR [rax+128]
  00166	83 e0 01	 and	 eax, 1
  00169	85 c0		 test	 eax, eax
  0016b	74 22		 je	 SHORT $LN42@z900_diag2
  0016d	48 63 84 24 30
	09 00 00	 movsxd	 rax, DWORD PTR r1$[rsp]
  00175	48 8b 8c 24 40
	09 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0017d	48 8b 84 c1 80
	02 00 00	 mov	 rax, QWORD PTR [rcx+rax*8+640]
  00185	48 89 84 24 98
	00 00 00	 mov	 QWORD PTR tv168[rsp], rax
  0018d	eb 1f		 jmp	 SHORT $LN43@z900_diag2
$LN42@z900_diag2:
  0018f	48 63 84 24 30
	09 00 00	 movsxd	 rax, DWORD PTR r1$[rsp]
  00197	48 8b 8c 24 40
	09 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0019f	8b 84 c1 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax*8+640]
  001a6	48 89 84 24 98
	00 00 00	 mov	 QWORD PTR tv168[rsp], rax
$LN43@z900_diag2:
  001ae	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR tv168[rsp]
  001b6	48 89 84 24 a8
	00 00 00	 mov	 QWORD PTR tv169[rsp], rax
  001be	eb 78		 jmp	 SHORT $LN44@z900_diag2
$LN39@z900_diag2:
  001c0	48 8b 84 24 40
	09 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  001c8	8b 80 80 00 00
	00		 mov	 eax, DWORD PTR [rax+128]
  001ce	83 e0 01	 and	 eax, 1
  001d1	85 c0		 test	 eax, eax
  001d3	74 22		 je	 SHORT $LN40@z900_diag2
  001d5	48 63 84 24 30
	09 00 00	 movsxd	 rax, DWORD PTR r1$[rsp]
  001dd	48 8b 8c 24 40
	09 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  001e5	48 8b 84 c1 80
	02 00 00	 mov	 rax, QWORD PTR [rcx+rax*8+640]
  001ed	48 89 84 24 a0
	00 00 00	 mov	 QWORD PTR tv151[rsp], rax
  001f5	eb 1f		 jmp	 SHORT $LN41@z900_diag2
$LN40@z900_diag2:
  001f7	48 63 84 24 30
	09 00 00	 movsxd	 rax, DWORD PTR r1$[rsp]
  001ff	48 8b 8c 24 40
	09 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00207	8b 84 c1 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax*8+640]
  0020e	48 89 84 24 a0
	00 00 00	 mov	 QWORD PTR tv151[rsp], rax
$LN41@z900_diag2:
  00216	48 8b 84 24 40
	09 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0021e	48 8b 40 70	 mov	 rax, QWORD PTR [rax+112]
  00222	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR tv151[rsp]
  0022a	48 33 c8	 xor	 rcx, rax
  0022d	48 8b c1	 mov	 rax, rcx
  00230	48 89 84 24 a8
	00 00 00	 mov	 QWORD PTR tv169[rsp], rax
$LN44@z900_diag2:
  00238	48 8b 84 24 a8
	00 00 00	 mov	 rax, QWORD PTR tv169[rsp]
  00240	48 89 84 24 80
	00 00 00	 mov	 QWORD PTR abs$[rsp], rax

; 484  : 
; 485  :         /* Program check if RMF data is not on a page boundary */
; 486  :         if ( (abs & PAGEFRAME_BYTEMASK) != 0x000)

  00248	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR abs$[rsp]
  00250	48 25 ff 0f 00
	00		 and	 rax, 4095		; 00000fffH
  00256	48 85 c0	 test	 rax, rax
  00259	74 12		 je	 SHORT $LN20@z900_diag2

; 487  :             ARCH_DEP(program_interrupt) (regs, PGM_SPECIFICATION_EXCEPTION);

  0025b	ba 06 00 00 00	 mov	 edx, 6
  00260	48 8b 8c 24 40
	09 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00268	e8 00 00 00 00	 call	 z900_program_interrupt
$LN20@z900_diag2:

; 488  : 
; 489  :         /* Program check if RMF data area is outside main storage */
; 490  :         if ( abs > regs->mainlim )

  0026d	48 8b 84 24 40
	09 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00275	48 8b 80 58 08
	00 00		 mov	 rax, QWORD PTR [rax+2136]
  0027c	48 39 84 24 80
	00 00 00	 cmp	 QWORD PTR abs$[rsp], rax
  00284	76 12		 jbe	 SHORT $LN21@z900_diag2

; 491  :             ARCH_DEP(program_interrupt) (regs, PGM_ADDRESSING_EXCEPTION);

  00286	ba 05 00 00 00	 mov	 edx, 5
  0028b	48 8b 8c 24 40
	09 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00293	e8 00 00 00 00	 call	 z900_program_interrupt
$LN21@z900_diag2:

; 492  : 
; 493  :         /* Point to DIAG 204 data area */
; 494  :         hdrinfo = (DIAG204_HDR*)(regs->mainstor + abs);

  00298	48 8b 84 24 40
	09 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  002a0	48 8b 80 48 08
	00 00		 mov	 rax, QWORD PTR [rax+2120]
  002a7	48 03 84 24 80
	00 00 00	 add	 rax, QWORD PTR abs$[rsp]
  002af	48 89 44 24 70	 mov	 QWORD PTR hdrinfo$[rsp], rax

; 495  : 
; 496  :         /* Mark page referenced */
; 497  :         ARCH_DEP( or_storage_key )( abs, STORKEY_REF | STORKEY_CHANGE );

  002b4	b2 06		 mov	 dl, 6
  002b6	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR abs$[rsp]
  002be	e8 00 00 00 00	 call	 z900_or_storage_key

; 498  : 
; 499  :         /* Retrieve the TOD clock value */
; 500  :         etod_clock(regs, &ETOD, ETOD_extended);

  002c3	41 b8 03 00 00
	00		 mov	 r8d, 3
  002c9	48 8d 94 24 e0
	00 00 00	 lea	 rdx, QWORD PTR ETOD$[rsp]
  002d1	48 8b 8c 24 40
	09 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  002d9	e8 00 00 00 00	 call	 etod_clock

; 501  : 
; 502  :         /* Get processor time(s) and leave out non-CPU processes and
; 503  :          * threads
; 504  :          */
; 505  :         for(i = 0; i < sysblk.maxcpu; ++i)

  002de	c7 44 24 40 00
	00 00 00	 mov	 DWORD PTR i$[rsp], 0
  002e6	eb 0a		 jmp	 SHORT $LN6@z900_diag2
$LN4@z900_diag2:
  002e8	8b 44 24 40	 mov	 eax, DWORD PTR i$[rsp]
  002ec	ff c0		 inc	 eax
  002ee	89 44 24 40	 mov	 DWORD PTR i$[rsp], eax
$LN6@z900_diag2:
  002f2	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  002f9	8b 80 00 01 00
	00		 mov	 eax, DWORD PTR [rax+256]
  002ff	39 44 24 40	 cmp	 DWORD PTR i$[rsp], eax
  00303	0f 8d c4 00 00
	00		 jge	 $LN5@z900_diag2

; 506  :         {
; 507  :             if (IS_CPU_ONLINE(i))

  00309	48 63 44 24 40	 movsxd	 rax, DWORD PTR i$[rsp]
  0030e	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  00315	48 83 bc c1 98
	0b 00 00 00	 cmp	 QWORD PTR [rcx+rax*8+2968], 0
  0031e	0f 84 a4 00 00
	00		 je	 $LN22@z900_diag2

; 508  :             {
; 509  :                 /* Get CPU times in microseconds */
; 510  :                 if( clock_gettime(sysblk.cpuclockid[i], &cputime) == 0 )

  00324	48 63 44 24 40	 movsxd	 rax, DWORD PTR i$[rsp]
  00329	48 8d 94 24 f0
	00 00 00	 lea	 rdx, QWORD PTR cputime$[rsp]
  00331	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  00338	8b 8c 81 48 0a
	00 00		 mov	 ecx, DWORD PTR [rcx+rax*4+2632]
  0033f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_clock_gettime
  00345	85 c0		 test	 eax, eax
  00347	75 7f		 jne	 SHORT $LN23@z900_diag2

; 511  :                 {
; 512  :                     uCPU[i] = timespec2usecs(&cputime);

  00349	48 8d 8c 24 f0
	00 00 00	 lea	 rcx, QWORD PTR cputime$[rsp]
  00351	e8 00 00 00 00	 call	 timespec2usecs
  00356	48 63 4c 24 40	 movsxd	 rcx, DWORD PTR i$[rsp]
  0035b	48 89 84 cc 00
	01 00 00	 mov	 QWORD PTR uCPU$[rsp+rcx*8], rax

; 513  :                     tCPU[i] = uCPU[i] + ETOD_high64_to_usecs(sysblk.regs[i]->waittime_accumulated

  00363	48 63 44 24 40	 movsxd	 rax, DWORD PTR i$[rsp]
  00368	48 89 84 24 b8
	00 00 00	 mov	 QWORD PTR tv209[rsp], rax
  00370	48 63 4c 24 40	 movsxd	 rcx, DWORD PTR i$[rsp]
  00375	48 8b 15 00 00
	00 00		 mov	 rdx, QWORD PTR __imp_sysblk
  0037c	48 8b 8c ca 98
	0b 00 00	 mov	 rcx, QWORD PTR [rdx+rcx*8+2968]
  00384	48 63 54 24 40	 movsxd	 rdx, DWORD PTR i$[rsp]
  00389	4c 8b 05 00 00
	00 00		 mov	 r8, QWORD PTR __imp_sysblk
  00390	49 8b 94 d0 98
	0b 00 00	 mov	 rdx, QWORD PTR [r8+rdx*8+2968]
  00398	48 8b 89 c8 07
	00 00		 mov	 rcx, QWORD PTR [rcx+1992]
  0039f	48 03 8a c0 07
	00 00		 add	 rcx, QWORD PTR [rdx+1984]
  003a6	e8 00 00 00 00	 call	 ETOD_high64_to_usecs
  003ab	48 8b 8c 24 b8
	00 00 00	 mov	 rcx, QWORD PTR tv209[rsp]
  003b3	48 03 84 cc 00
	01 00 00	 add	 rax, QWORD PTR uCPU$[rsp+rcx*8]
  003bb	48 63 4c 24 40	 movsxd	 rcx, DWORD PTR i$[rsp]
  003c0	48 89 84 cc 00
	03 00 00	 mov	 QWORD PTR tCPU$[rsp+rcx*8], rax
$LN23@z900_diag2:
$LN22@z900_diag2:

; 514  :                                               + sysblk.regs[i]->waittime ) ;
; 515  :                 }
; 516  :             }
; 517  :         }

  003c8	e9 1b ff ff ff	 jmp	 $LN4@z900_diag2
$LN5@z900_diag2:

; 518  : 
; 519  :         memset(hdrinfo, 0, sizeof(DIAG204_HDR));

  003cd	48 8b 7c 24 70	 mov	 rdi, QWORD PTR hdrinfo$[rsp]
  003d2	33 c0		 xor	 eax, eax
  003d4	b9 10 00 00 00	 mov	 ecx, 16
  003d9	f3 aa		 rep stosb

; 520  :         hdrinfo->numpart = 1;

  003db	48 8b 44 24 70	 mov	 rax, QWORD PTR hdrinfo$[rsp]
  003e0	c6 00 01	 mov	 BYTE PTR [rax], 1

; 521  : #if defined(FEATURE_PHYSICAL_DIAG204)
; 522  :         hdrinfo->flags = DIAG204_PHYSICAL_PRESENT;
; 523  : #endif /*defined(FEATURE_PHYSICAL_DIAG204)*/
; 524  :         STORE_HW(hdrinfo->physcpu,sysblk.cpus);

  003e3	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  003ea	0f b7 88 04 01
	00 00		 movzx	 ecx, WORD PTR [rax+260]
  003f1	e8 00 00 00 00	 call	 _byteswap_ushort
  003f6	48 8b 4c 24 70	 mov	 rcx, QWORD PTR hdrinfo$[rsp]
  003fb	48 83 c1 04	 add	 rcx, 4
  003ff	0f b7 d0	 movzx	 edx, ax
  00402	e8 00 00 00 00	 call	 store_hw_noswap

; 525  :         STORE_HW(hdrinfo->offown,sizeof(DIAG204_HDR));

  00407	66 b9 10 00	 mov	 cx, 16
  0040b	e8 00 00 00 00	 call	 _byteswap_ushort
  00410	48 8b 4c 24 70	 mov	 rcx, QWORD PTR hdrinfo$[rsp]
  00415	48 83 c1 06	 add	 rcx, 6
  00419	0f b7 d0	 movzx	 edx, ax
  0041c	e8 00 00 00 00	 call	 store_hw_noswap

; 526  :         STORE_DW(hdrinfo->diagstck,ETOD2TOD(ETOD));

  00421	48 8d 84 24 d0
	00 00 00	 lea	 rax, QWORD PTR $T1[rsp]
  00429	48 8d 8c 24 e0
	00 00 00	 lea	 rcx, QWORD PTR ETOD$[rsp]
  00431	48 8b f8	 mov	 rdi, rax
  00434	48 8b f1	 mov	 rsi, rcx
  00437	b9 10 00 00 00	 mov	 ecx, 16
  0043c	f3 a4		 rep movsb
  0043e	48 8d 8c 24 d0
	00 00 00	 lea	 rcx, QWORD PTR $T1[rsp]
  00446	e8 00 00 00 00	 call	 ETOD2TOD
  0044b	48 8b c8	 mov	 rcx, rax
  0044e	e8 00 00 00 00	 call	 _byteswap_uint64
  00453	48 8b 4c 24 70	 mov	 rcx, QWORD PTR hdrinfo$[rsp]
  00458	48 83 c1 08	 add	 rcx, 8
  0045c	48 8b d0	 mov	 rdx, rax
  0045f	e8 00 00 00 00	 call	 store_dw_noswap

; 527  : 
; 528  :         /* hercules partition */
; 529  :         partinfo = (DIAG204_PART*)(hdrinfo + 1);

  00464	48 8b 44 24 70	 mov	 rax, QWORD PTR hdrinfo$[rsp]
  00469	48 83 c0 10	 add	 rax, 16
  0046d	48 89 44 24 78	 mov	 QWORD PTR partinfo$[rsp], rax

; 530  :         memset(partinfo, 0, sizeof(DIAG204_PART));

  00472	48 8b 7c 24 78	 mov	 rdi, QWORD PTR partinfo$[rsp]
  00477	33 c0		 xor	 eax, eax
  00479	b9 10 00 00 00	 mov	 ecx, 16
  0047e	f3 aa		 rep stosb

; 531  :         partinfo->partnum = sysblk.lparnum;     /* Hercules partition */

  00480	48 8b 44 24 78	 mov	 rax, QWORD PTR partinfo$[rsp]
  00485	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  0048c	0f b6 89 f0 00
	00 00		 movzx	 ecx, BYTE PTR [rcx+240]
  00493	88 08		 mov	 BYTE PTR [rax], cl

; 532  :         partinfo->virtcpu = sysblk.cpus;

  00495	48 8b 44 24 78	 mov	 rax, QWORD PTR partinfo$[rsp]
  0049a	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  004a1	0f b6 89 04 01
	00 00		 movzx	 ecx, BYTE PTR [rcx+260]
  004a8	88 48 01	 mov	 BYTE PTR [rax+1], cl

; 533  :         get_lparname(partinfo->partname);

  004ab	48 8b 44 24 78	 mov	 rax, QWORD PTR partinfo$[rsp]
  004b0	48 83 c0 08	 add	 rax, 8
  004b4	48 8b c8	 mov	 rcx, rax
  004b7	e8 00 00 00 00	 call	 get_lparname

; 534  : 
; 535  :         /* hercules cpu's */
; 536  :         cpuinfo = (DIAG204_PART_CPU*)(partinfo + 1);

  004bc	48 8b 44 24 78	 mov	 rax, QWORD PTR partinfo$[rsp]
  004c1	48 83 c0 10	 add	 rax, 16
  004c5	48 89 44 24 60	 mov	 QWORD PTR cpuinfo$[rsp], rax

; 537  :         for(i = 0; i < sysblk.maxcpu; i++)

  004ca	c7 44 24 40 00
	00 00 00	 mov	 DWORD PTR i$[rsp], 0
  004d2	eb 0a		 jmp	 SHORT $LN9@z900_diag2
$LN7@z900_diag2:
  004d4	8b 44 24 40	 mov	 eax, DWORD PTR i$[rsp]
  004d8	ff c0		 inc	 eax
  004da	89 44 24 40	 mov	 DWORD PTR i$[rsp], eax
$LN9@z900_diag2:
  004de	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  004e5	8b 80 00 01 00
	00		 mov	 eax, DWORD PTR [rax+256]
  004eb	39 44 24 40	 cmp	 DWORD PTR i$[rsp], eax
  004ef	0f 8d ee 00 00
	00		 jge	 $LN8@z900_diag2

; 538  :           if (IS_CPU_ONLINE(i))

  004f5	48 63 44 24 40	 movsxd	 rax, DWORD PTR i$[rsp]
  004fa	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  00501	48 83 bc c1 98
	0b 00 00 00	 cmp	 QWORD PTR [rcx+rax*8+2968], 0
  0050a	0f 84 ce 00 00
	00		 je	 $LN24@z900_diag2

; 539  :           {
; 540  :               memset(cpuinfo, 0, sizeof(DIAG204_PART_CPU));

  00510	48 8b 7c 24 60	 mov	 rdi, QWORD PTR cpuinfo$[rsp]
  00515	33 c0		 xor	 eax, eax
  00517	b9 18 00 00 00	 mov	 ecx, 24
  0051c	f3 aa		 rep stosb

; 541  :               STORE_HW(cpuinfo->cpaddr,sysblk.regs[i]->cpuad);

  0051e	48 63 44 24 40	 movsxd	 rax, DWORD PTR i$[rsp]
  00523	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  0052a	48 8b 84 c1 98
	0b 00 00	 mov	 rax, QWORD PTR [rcx+rax*8+2968]
  00532	0f b7 88 3c 08
	00 00		 movzx	 ecx, WORD PTR [rax+2108]
  00539	e8 00 00 00 00	 call	 _byteswap_ushort
  0053e	48 8b 4c 24 60	 mov	 rcx, QWORD PTR cpuinfo$[rsp]
  00543	0f b7 d0	 movzx	 edx, ax
  00546	e8 00 00 00 00	 call	 store_hw_noswap

; 542  :               cpuinfo->index=sysblk.ptyp[i];

  0054b	48 63 44 24 40	 movsxd	 rax, DWORD PTR i$[rsp]
  00550	48 8b 4c 24 60	 mov	 rcx, QWORD PTR cpuinfo$[rsp]
  00555	48 8b 15 00 00
	00 00		 mov	 rdx, QWORD PTR __imp_sysblk
  0055c	0f b6 84 02 48
	0b 00 00	 movzx	 eax, BYTE PTR [rdx+rax+2888]
  00564	88 41 04	 mov	 BYTE PTR [rcx+4], al

; 543  :               STORE_HW(cpuinfo->weight,100);

  00567	66 b9 64 00	 mov	 cx, 100			; 00000064H
  0056b	e8 00 00 00 00	 call	 _byteswap_ushort
  00570	48 8b 4c 24 60	 mov	 rcx, QWORD PTR cpuinfo$[rsp]
  00575	48 83 c1 06	 add	 rcx, 6
  00579	0f b7 d0	 movzx	 edx, ax
  0057c	e8 00 00 00 00	 call	 store_hw_noswap

; 544  :               STORE_DW(cpuinfo->totdispatch,tCPU[i]);

  00581	48 63 44 24 40	 movsxd	 rax, DWORD PTR i$[rsp]
  00586	48 8b 8c c4 00
	03 00 00	 mov	 rcx, QWORD PTR tCPU$[rsp+rax*8]
  0058e	e8 00 00 00 00	 call	 _byteswap_uint64
  00593	48 8b 4c 24 60	 mov	 rcx, QWORD PTR cpuinfo$[rsp]
  00598	48 83 c1 08	 add	 rcx, 8
  0059c	48 8b d0	 mov	 rdx, rax
  0059f	e8 00 00 00 00	 call	 store_dw_noswap

; 545  :               STORE_DW(cpuinfo->effdispatch, uCPU[i]);

  005a4	48 63 44 24 40	 movsxd	 rax, DWORD PTR i$[rsp]
  005a9	48 8b 8c c4 00
	01 00 00	 mov	 rcx, QWORD PTR uCPU$[rsp+rax*8]
  005b1	e8 00 00 00 00	 call	 _byteswap_uint64
  005b6	48 8b 4c 24 60	 mov	 rcx, QWORD PTR cpuinfo$[rsp]
  005bb	48 83 c1 10	 add	 rcx, 16
  005bf	48 8b d0	 mov	 rdx, rax
  005c2	e8 00 00 00 00	 call	 store_dw_noswap

; 546  :               cpuinfo->cflag=0x20;

  005c7	48 8b 44 24 60	 mov	 rax, QWORD PTR cpuinfo$[rsp]
  005cc	c6 40 05 20	 mov	 BYTE PTR [rax+5], 32	; 00000020H

; 547  :               cpuinfo += 1;

  005d0	48 8b 44 24 60	 mov	 rax, QWORD PTR cpuinfo$[rsp]
  005d5	48 83 c0 18	 add	 rax, 24
  005d9	48 89 44 24 60	 mov	 QWORD PTR cpuinfo$[rsp], rax
$LN24@z900_diag2:

; 548  :           }

  005de	e9 f1 fe ff ff	 jmp	 $LN7@z900_diag2
$LN8@z900_diag2:

; 549  : 
; 550  : #if defined(FEATURE_PHYSICAL_DIAG204)
; 551  :         /* LPAR management */
; 552  :         /* FIXME: This section should report on the real CPUs, appearing
; 553  :          *        and transformed for reporting purposes. This should
; 554  :          *        also be properly reflected in STSI information.
; 555  :          */
; 556  :         partinfo = (DIAG204_PART*)cpuinfo;
; 557  :         memset(partinfo, 0, sizeof(DIAG204_PART));
; 558  :         partinfo->partnum = 0; /* Physical machine */
; 559  :         partinfo->virtcpu = sysblk.cpus;
; 560  :         memcpy(partinfo->partname,physical,sizeof(physical));
; 561  : 
; 562  :         /* report all emulated physical cpu's */
; 563  :         cpuinfo = (DIAG204_PART_CPU*)(partinfo + 1);
; 564  :         for(i = 0; i < sysblk.maxcpu; i++)
; 565  :           if (IS_CPU_ONLINE(i))
; 566  :           {
; 567  :               memset(cpuinfo, 0, sizeof(DIAG204_PART_CPU));
; 568  :               STORE_HW(cpuinfo->cpaddr,sysblk.regs[i]->cpuad);
; 569  :               cpuinfo->index = sysblk.ptyp[i];
; 570  :               STORE_HW(cpuinfo->weight,100);
; 571  :               STORE_DW(cpuinfo->totdispatch, tCPU[i]);
; 572  :               STORE_DW(cpuinfo->effdispatch, uCPU[i]);
; 573  :               cpuinfo += 1;
; 574  :           }
; 575  : #endif /*defined(FEATURE_PHYSICAL_DIAG204)*/
; 576  : 
; 577  :         regs->GR_L(r2) = 0;

  005e3	48 63 84 24 38
	09 00 00	 movsxd	 rax, DWORD PTR r2$[rsp]
  005eb	48 8b 8c 24 40
	09 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  005f3	c7 84 c1 80 02
	00 00 00 00 00
	00		 mov	 DWORD PTR [rcx+rax*8+640], 0

; 578  : 
; 579  :         break;

  005fe	e9 ea 06 00 00	 jmp	 $LN2@z900_diag2
$LN25@z900_diag2:

; 580  : 
; 581  : #if defined(FEATURE_EXTENDED_DIAG204)
; 582  :     /* Extended subcode 5 returns the size of the data areas provided by extended subcodes 6 and 7 */
; 583  :     case 0x00010005:
; 584  :         i = sizeof(DIAG204_X_HDR) + ((sizeof(DIAG204_X_PART) + (sysblk.maxcpu * sizeof(DIAG204_X_PART_CPU))) * 2);

  00603	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  0060a	48 63 80 00 01
	00 00		 movsxd	 rax, DWORD PTR [rax+256]
  00611	48 6b c0 60	 imul	 rax, rax, 96		; 00000060H
  00615	48 8d 84 00 00
	01 00 00	 lea	 rax, QWORD PTR [rax+rax+256]
  0061d	89 44 24 40	 mov	 DWORD PTR i$[rsp], eax

; 585  :         regs->GR_L(r2+1) = (i + PAGEFRAME_BYTEMASK) / PAGEFRAME_PAGESIZE;

  00621	8b 44 24 40	 mov	 eax, DWORD PTR i$[rsp]
  00625	05 ff 0f 00 00	 add	 eax, 4095		; 00000fffH
  0062a	99		 cdq
  0062b	81 e2 ff 0f 00
	00		 and	 edx, 4095		; 00000fffH
  00631	03 c2		 add	 eax, edx
  00633	c1 f8 0c	 sar	 eax, 12
  00636	8b 8c 24 38 09
	00 00		 mov	 ecx, DWORD PTR r2$[rsp]
  0063d	ff c1		 inc	 ecx
  0063f	48 63 c9	 movsxd	 rcx, ecx
  00642	48 8b 94 24 40
	09 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  0064a	89 84 ca 80 02
	00 00		 mov	 DWORD PTR [rdx+rcx*8+640], eax

; 586  :         regs->GR_L(r2) = 0;

  00651	48 63 84 24 38
	09 00 00	 movsxd	 rax, DWORD PTR r2$[rsp]
  00659	48 8b 8c 24 40
	09 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00661	c7 84 c1 80 02
	00 00 00 00 00
	00		 mov	 DWORD PTR [rcx+rax*8+640], 0

; 587  : 
; 588  :         break;

  0066c	e9 7c 06 00 00	 jmp	 $LN2@z900_diag2
$LN26@z900_diag2:
$LN27@z900_diag2:

; 589  : 
; 590  :     /* Provide extended information */
; 591  :     case 0x00010006:
; 592  :         /* We fall through as we do not have any secondary cpus (that we know of) */
; 593  : 
; 594  :     /* Provide extended information, including information about secondary CPUs */
; 595  :     case 0x00010007:
; 596  :         /* Program check if RMF data is not on a page boundary */
; 597  :         if ( (regs->GR_L(r1) & PAGEFRAME_BYTEMASK) != 0x000)

  00671	48 63 84 24 30
	09 00 00	 movsxd	 rax, DWORD PTR r1$[rsp]
  00679	48 8b 8c 24 40
	09 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00681	8b 84 c1 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax*8+640]
  00688	25 ff 0f 00 00	 and	 eax, 4095		; 00000fffH
  0068d	85 c0		 test	 eax, eax
  0068f	74 12		 je	 SHORT $LN28@z900_diag2

; 598  :             ARCH_DEP(program_interrupt) (regs, PGM_SPECIFICATION_EXCEPTION);

  00691	ba 06 00 00 00	 mov	 edx, 6
  00696	48 8b 8c 24 40
	09 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0069e	e8 00 00 00 00	 call	 z900_program_interrupt
$LN28@z900_diag2:

; 599  : 
; 600  :         /* Obtain absolute address of main storage block,
; 601  :            check protection, and set reference and change bits */
; 602  :         hdrxinfo = (DIAG204_X_HDR*)MADDR (GR_A(r1,regs), r1, regs, ACCTYPE_WRITE, regs->psw.pkey);

  006a3	48 8b 84 24 40
	09 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  006ab	8b 80 80 00 00
	00		 mov	 eax, DWORD PTR [rax+128]
  006b1	83 e0 01	 and	 eax, 1
  006b4	85 c0		 test	 eax, eax
  006b6	74 22		 je	 SHORT $LN45@z900_diag2
  006b8	48 63 84 24 30
	09 00 00	 movsxd	 rax, DWORD PTR r1$[rsp]
  006c0	48 8b 8c 24 40
	09 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  006c8	48 8b 84 c1 80
	02 00 00	 mov	 rax, QWORD PTR [rcx+rax*8+640]
  006d0	48 89 84 24 b0
	00 00 00	 mov	 QWORD PTR tv366[rsp], rax
  006d8	eb 1f		 jmp	 SHORT $LN46@z900_diag2
$LN45@z900_diag2:
  006da	48 63 84 24 30
	09 00 00	 movsxd	 rax, DWORD PTR r1$[rsp]
  006e2	48 8b 8c 24 40
	09 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  006ea	8b 84 c1 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax*8+640]
  006f1	48 89 84 24 b0
	00 00 00	 mov	 QWORD PTR tv366[rsp], rax
$LN46@z900_diag2:
  006f9	48 8b 84 24 40
	09 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00701	0f b6 40 79	 movzx	 eax, BYTE PTR [rax+121]
  00705	88 44 24 28	 mov	 BYTE PTR [rsp+40], al
  00709	c7 44 24 20 02
	00 00 00	 mov	 DWORD PTR [rsp+32], 2
  00711	4c 8b 8c 24 40
	09 00 00	 mov	 r9, QWORD PTR regs$[rsp]
  00719	44 8b 84 24 30
	09 00 00	 mov	 r8d, DWORD PTR r1$[rsp]
  00721	ba 01 00 00 00	 mov	 edx, 1
  00726	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR tv366[rsp]
  0072e	e8 00 00 00 00	 call	 z900_maddr_l
  00733	48 89 44 24 68	 mov	 QWORD PTR hdrxinfo$[rsp], rax

; 603  : 
; 604  :         /* Retrieve the TOD clock value */
; 605  :         etod_clock(regs, &ETOD, ETOD_extended);

  00738	41 b8 03 00 00
	00		 mov	 r8d, 3
  0073e	48 8d 94 24 e0
	00 00 00	 lea	 rdx, QWORD PTR ETOD$[rsp]
  00746	48 8b 8c 24 40
	09 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0074e	e8 00 00 00 00	 call	 etod_clock

; 606  : 
; 607  :         /* Get processor time(s) and leave out non-CPU processes and
; 608  :          * threads
; 609  :          */
; 610  :         for(i = 0; i < sysblk.maxcpu; ++i)

  00753	c7 44 24 40 00
	00 00 00	 mov	 DWORD PTR i$[rsp], 0
  0075b	eb 0a		 jmp	 SHORT $LN12@z900_diag2
$LN10@z900_diag2:
  0075d	8b 44 24 40	 mov	 eax, DWORD PTR i$[rsp]
  00761	ff c0		 inc	 eax
  00763	89 44 24 40	 mov	 DWORD PTR i$[rsp], eax
$LN12@z900_diag2:
  00767	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  0076e	8b 80 00 01 00
	00		 mov	 eax, DWORD PTR [rax+256]
  00774	39 44 24 40	 cmp	 DWORD PTR i$[rsp], eax
  00778	0f 8d 34 01 00
	00		 jge	 $LN11@z900_diag2

; 611  :         {
; 612  :             if (IS_CPU_ONLINE(i))

  0077e	48 63 44 24 40	 movsxd	 rax, DWORD PTR i$[rsp]
  00783	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  0078a	48 83 bc c1 98
	0b 00 00 00	 cmp	 QWORD PTR [rcx+rax*8+2968], 0
  00793	0f 84 14 01 00
	00		 je	 $LN29@z900_diag2

; 613  :             {
; 614  :                 oCPU[i] = ETOD_high64_to_usecs(ETOD.high - regs->tod_epoch - sysblk.cpucreateTOD[i]);

  00799	48 8b 84 24 40
	09 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  007a1	48 8b 80 40 07
	00 00		 mov	 rax, QWORD PTR [rax+1856]
  007a8	48 8b 8c 24 e8
	00 00 00	 mov	 rcx, QWORD PTR ETOD$[rsp+8]
  007b0	48 2b c8	 sub	 rcx, rax
  007b3	48 8b c1	 mov	 rax, rcx
  007b6	48 63 4c 24 40	 movsxd	 rcx, DWORD PTR i$[rsp]
  007bb	48 8b 15 00 00
	00 00		 mov	 rdx, QWORD PTR __imp_sysblk
  007c2	48 2b 84 ca 48
	07 00 00	 sub	 rax, QWORD PTR [rdx+rcx*8+1864]
  007ca	48 8b c8	 mov	 rcx, rax
  007cd	e8 00 00 00 00	 call	 ETOD_high64_to_usecs
  007d2	48 63 4c 24 40	 movsxd	 rcx, DWORD PTR i$[rsp]
  007d7	48 89 84 cc 00
	05 00 00	 mov	 QWORD PTR oCPU$[rsp+rcx*8], rax

; 615  :                 /* Get CPU times in microseconds */
; 616  :                 if( clock_gettime(sysblk.cpuclockid[i], &cputime) == 0 )

  007df	48 63 44 24 40	 movsxd	 rax, DWORD PTR i$[rsp]
  007e4	48 8d 94 24 f0
	00 00 00	 lea	 rdx, QWORD PTR cputime$[rsp]
  007ec	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  007f3	8b 8c 81 48 0a
	00 00		 mov	 ecx, DWORD PTR [rcx+rax*4+2632]
  007fa	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_clock_gettime
  00800	85 c0		 test	 eax, eax
  00802	75 7f		 jne	 SHORT $LN30@z900_diag2

; 617  :                 {
; 618  :                     uCPU[i] = timespec2usecs(&cputime);

  00804	48 8d 8c 24 f0
	00 00 00	 lea	 rcx, QWORD PTR cputime$[rsp]
  0080c	e8 00 00 00 00	 call	 timespec2usecs
  00811	48 63 4c 24 40	 movsxd	 rcx, DWORD PTR i$[rsp]
  00816	48 89 84 cc 00
	01 00 00	 mov	 QWORD PTR uCPU$[rsp+rcx*8], rax

; 619  :                     tCPU[i] = uCPU[i] + ETOD_high64_to_usecs(sysblk.regs[i]->waittime_accumulated

  0081e	48 63 44 24 40	 movsxd	 rax, DWORD PTR i$[rsp]
  00823	48 89 84 24 c0
	00 00 00	 mov	 QWORD PTR tv407[rsp], rax
  0082b	48 63 4c 24 40	 movsxd	 rcx, DWORD PTR i$[rsp]
  00830	48 8b 15 00 00
	00 00		 mov	 rdx, QWORD PTR __imp_sysblk
  00837	48 8b 8c ca 98
	0b 00 00	 mov	 rcx, QWORD PTR [rdx+rcx*8+2968]
  0083f	48 63 54 24 40	 movsxd	 rdx, DWORD PTR i$[rsp]
  00844	48 8b 3d 00 00
	00 00		 mov	 rdi, QWORD PTR __imp_sysblk
  0084b	48 8b 94 d7 98
	0b 00 00	 mov	 rdx, QWORD PTR [rdi+rdx*8+2968]
  00853	48 8b 89 c8 07
	00 00		 mov	 rcx, QWORD PTR [rcx+1992]
  0085a	48 03 8a c0 07
	00 00		 add	 rcx, QWORD PTR [rdx+1984]
  00861	e8 00 00 00 00	 call	 ETOD_high64_to_usecs
  00866	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR tv407[rsp]
  0086e	48 03 84 cc 00
	01 00 00	 add	 rax, QWORD PTR uCPU$[rsp+rcx*8]
  00876	48 63 4c 24 40	 movsxd	 rcx, DWORD PTR i$[rsp]
  0087b	48 89 84 cc 00
	03 00 00	 mov	 QWORD PTR tCPU$[rsp+rcx*8], rax
$LN30@z900_diag2:

; 620  :                                               + sysblk.regs[i]->waittime ) ;
; 621  :                 }
; 622  :                 wCPU[i] = tCPU[i] - uCPU[i];

  00883	48 63 44 24 40	 movsxd	 rax, DWORD PTR i$[rsp]
  00888	48 63 4c 24 40	 movsxd	 rcx, DWORD PTR i$[rsp]
  0088d	48 8b 8c cc 00
	01 00 00	 mov	 rcx, QWORD PTR uCPU$[rsp+rcx*8]
  00895	48 8b 84 c4 00
	03 00 00	 mov	 rax, QWORD PTR tCPU$[rsp+rax*8]
  0089d	48 2b c1	 sub	 rax, rcx
  008a0	48 63 4c 24 40	 movsxd	 rcx, DWORD PTR i$[rsp]
  008a5	48 89 84 cc 00
	07 00 00	 mov	 QWORD PTR wCPU$[rsp+rcx*8], rax
$LN29@z900_diag2:

; 623  :             }
; 624  :         }

  008ad	e9 ab fe ff ff	 jmp	 $LN10@z900_diag2
$LN11@z900_diag2:

; 625  : 
; 626  :         memset(hdrxinfo, 0, sizeof(DIAG204_X_HDR));

  008b2	48 8b 7c 24 68	 mov	 rdi, QWORD PTR hdrxinfo$[rsp]
  008b7	33 c0		 xor	 eax, eax
  008b9	b9 40 00 00 00	 mov	 ecx, 64			; 00000040H
  008be	f3 aa		 rep stosb

; 627  :         hdrxinfo->numpart = 1;

  008c0	48 8b 44 24 68	 mov	 rax, QWORD PTR hdrxinfo$[rsp]
  008c5	c6 00 01	 mov	 BYTE PTR [rax], 1

; 628  : #if defined(FEATURE_PHYSICAL_DIAG204)
; 629  :         hdrxinfo->flags = DIAG204_X_PHYSICAL_PRESENT;
; 630  : #endif /*defined(FEATURE_PHYSICAL_DIAG204)*/
; 631  :         STORE_HW(hdrxinfo->physcpu,sysblk.cpus);

  008c8	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  008cf	0f b7 88 04 01
	00 00		 movzx	 ecx, WORD PTR [rax+260]
  008d6	e8 00 00 00 00	 call	 _byteswap_ushort
  008db	48 8b 4c 24 68	 mov	 rcx, QWORD PTR hdrxinfo$[rsp]
  008e0	48 83 c1 04	 add	 rcx, 4
  008e4	0f b7 d0	 movzx	 edx, ax
  008e7	e8 00 00 00 00	 call	 store_hw_noswap

; 632  :         STORE_HW(hdrxinfo->offown,sizeof(DIAG204_X_HDR));

  008ec	66 b9 40 00	 mov	 cx, 64			; 00000040H
  008f0	e8 00 00 00 00	 call	 _byteswap_ushort
  008f5	48 8b 4c 24 68	 mov	 rcx, QWORD PTR hdrxinfo$[rsp]
  008fa	48 83 c1 06	 add	 rcx, 6
  008fe	0f b7 d0	 movzx	 edx, ax
  00901	e8 00 00 00 00	 call	 store_hw_noswap

; 633  :         STORE_DW(hdrxinfo->diagstck1,ETOD.high);

  00906	48 8b 8c 24 e8
	00 00 00	 mov	 rcx, QWORD PTR ETOD$[rsp+8]
  0090e	e8 00 00 00 00	 call	 _byteswap_uint64
  00913	48 8b 4c 24 68	 mov	 rcx, QWORD PTR hdrxinfo$[rsp]
  00918	48 83 c1 08	 add	 rcx, 8
  0091c	48 8b d0	 mov	 rdx, rax
  0091f	e8 00 00 00 00	 call	 store_dw_noswap

; 634  :         STORE_DW(hdrxinfo->diagstck2,ETOD.low);

  00924	48 8b 8c 24 e0
	00 00 00	 mov	 rcx, QWORD PTR ETOD$[rsp]
  0092c	e8 00 00 00 00	 call	 _byteswap_uint64
  00931	48 8b 4c 24 68	 mov	 rcx, QWORD PTR hdrxinfo$[rsp]
  00936	48 83 c1 10	 add	 rcx, 16
  0093a	48 8b d0	 mov	 rdx, rax
  0093d	e8 00 00 00 00	 call	 store_dw_noswap

; 635  : 
; 636  :         /* hercules partition */
; 637  :         partxinfo = (DIAG204_X_PART*)(hdrxinfo + 1);

  00942	48 8b 44 24 68	 mov	 rax, QWORD PTR hdrxinfo$[rsp]
  00947	48 83 c0 40	 add	 rax, 64			; 00000040H
  0094b	48 89 44 24 50	 mov	 QWORD PTR partxinfo$[rsp], rax

; 638  :         memset(partxinfo, 0, sizeof(DIAG204_X_PART));

  00950	48 8b 7c 24 50	 mov	 rdi, QWORD PTR partxinfo$[rsp]
  00955	33 c0		 xor	 eax, eax
  00957	b9 60 00 00 00	 mov	 ecx, 96			; 00000060H
  0095c	f3 aa		 rep stosb

; 639  :         partxinfo->partnum = sysblk.lparnum;    /* Hercules partition */

  0095e	48 8b 44 24 50	 mov	 rax, QWORD PTR partxinfo$[rsp]
  00963	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  0096a	0f b6 89 f0 00
	00 00		 movzx	 ecx, BYTE PTR [rcx+240]
  00971	88 08		 mov	 BYTE PTR [rax], cl

; 640  :         partxinfo->virtcpu = sysblk.cpus;

  00973	48 8b 44 24 50	 mov	 rax, QWORD PTR partxinfo$[rsp]
  00978	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  0097f	0f b6 89 04 01
	00 00		 movzx	 ecx, BYTE PTR [rcx+260]
  00986	88 48 01	 mov	 BYTE PTR [rax+1], cl

; 641  :         partxinfo->realcpu = hostinfo.num_procs;

  00989	48 8b 44 24 50	 mov	 rax, QWORD PTR partxinfo$[rsp]
  0098e	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_hostinfo
  00995	0f b6 89 b8 01
	00 00		 movzx	 ecx, BYTE PTR [rcx+440]
  0099c	88 48 02	 mov	 BYTE PTR [rax+2], cl

; 642  :         get_lparname(partxinfo->partname);

  0099f	48 8b 44 24 50	 mov	 rax, QWORD PTR partxinfo$[rsp]
  009a4	48 83 c0 08	 add	 rax, 8
  009a8	48 8b c8	 mov	 rcx, rax
  009ab	e8 00 00 00 00	 call	 get_lparname

; 643  :         get_sysname(partxinfo->cpcname);

  009b0	48 8b 44 24 50	 mov	 rax, QWORD PTR partxinfo$[rsp]
  009b5	48 83 c0 10	 add	 rax, 16
  009b9	48 8b c8	 mov	 rcx, rax
  009bc	e8 00 00 00 00	 call	 get_sysname

; 644  :         get_systype(partxinfo->osname);

  009c1	48 8b 44 24 50	 mov	 rax, QWORD PTR partxinfo$[rsp]
  009c6	48 83 c0 18	 add	 rax, 24
  009ca	48 8b c8	 mov	 rcx, rax
  009cd	e8 00 00 00 00	 call	 get_systype

; 645  :         STORE_DW( partxinfo->cssize, sysblk.mainsize >> SHIFT_MEGABYTE );

  009d2	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  009d9	48 8b 80 90 00
	00 00		 mov	 rax, QWORD PTR [rax+144]
  009e0	48 c1 e8 14	 shr	 rax, 20
  009e4	48 8b c8	 mov	 rcx, rax
  009e7	e8 00 00 00 00	 call	 _byteswap_uint64
  009ec	48 8b 4c 24 50	 mov	 rcx, QWORD PTR partxinfo$[rsp]
  009f1	48 83 c1 20	 add	 rcx, 32			; 00000020H
  009f5	48 8b d0	 mov	 rdx, rax
  009f8	e8 00 00 00 00	 call	 store_dw_noswap

; 646  :         STORE_DW( partxinfo->essize, sysblk.xpndsize >> SHIFT_MEGABYTE );

  009fd	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00a04	8b 80 ac 00 00
	00		 mov	 eax, DWORD PTR [rax+172]
  00a0a	c1 e8 14	 shr	 eax, 20
  00a0d	8b c0		 mov	 eax, eax
  00a0f	8b c8		 mov	 ecx, eax
  00a11	e8 00 00 00 00	 call	 _byteswap_uint64
  00a16	48 8b 4c 24 50	 mov	 rcx, QWORD PTR partxinfo$[rsp]
  00a1b	48 83 c1 28	 add	 rcx, 40			; 00000028H
  00a1f	48 8b d0	 mov	 rdx, rax
  00a22	e8 00 00 00 00	 call	 store_dw_noswap

; 647  :         get_sysplex(partxinfo->gr_name);

  00a27	48 8b 44 24 50	 mov	 rax, QWORD PTR partxinfo$[rsp]
  00a2c	48 83 c0 38	 add	 rax, 56			; 00000038H
  00a30	48 8b c8	 mov	 rcx, rax
  00a33	e8 00 00 00 00	 call	 get_sysplex

; 648  : 
; 649  :         /* hercules cpu's */
; 650  :         cpuxinfo = (DIAG204_X_PART_CPU*)(partxinfo + 1);

  00a38	48 8b 44 24 50	 mov	 rax, QWORD PTR partxinfo$[rsp]
  00a3d	48 83 c0 60	 add	 rax, 96			; 00000060H
  00a41	48 89 44 24 48	 mov	 QWORD PTR cpuxinfo$[rsp], rax

; 651  :         for(i = 0; i < sysblk.maxcpu; i++)

  00a46	c7 44 24 40 00
	00 00 00	 mov	 DWORD PTR i$[rsp], 0
  00a4e	eb 0a		 jmp	 SHORT $LN15@z900_diag2
$LN13@z900_diag2:
  00a50	8b 44 24 40	 mov	 eax, DWORD PTR i$[rsp]
  00a54	ff c0		 inc	 eax
  00a56	89 44 24 40	 mov	 DWORD PTR i$[rsp], eax
$LN15@z900_diag2:
  00a5a	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00a61	8b 80 00 01 00
	00		 mov	 eax, DWORD PTR [rax+256]
  00a67	39 44 24 40	 cmp	 DWORD PTR i$[rsp], eax
  00a6b	0f 8d b6 01 00
	00		 jge	 $LN14@z900_diag2

; 652  :           if (IS_CPU_ONLINE(i))

  00a71	48 63 44 24 40	 movsxd	 rax, DWORD PTR i$[rsp]
  00a76	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  00a7d	48 83 bc c1 98
	0b 00 00 00	 cmp	 QWORD PTR [rcx+rax*8+2968], 0
  00a86	0f 84 96 01 00
	00		 je	 $LN31@z900_diag2

; 653  :           {
; 654  :               memset(cpuxinfo, 0, sizeof(DIAG204_X_PART_CPU));

  00a8c	48 8b 7c 24 48	 mov	 rdi, QWORD PTR cpuxinfo$[rsp]
  00a91	33 c0		 xor	 eax, eax
  00a93	b9 60 00 00 00	 mov	 ecx, 96			; 00000060H
  00a98	f3 aa		 rep stosb

; 655  :               STORE_HW(cpuxinfo->cpaddr,sysblk.regs[i]->cpuad);

  00a9a	48 63 44 24 40	 movsxd	 rax, DWORD PTR i$[rsp]
  00a9f	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  00aa6	48 8b 84 c1 98
	0b 00 00	 mov	 rax, QWORD PTR [rcx+rax*8+2968]
  00aae	0f b7 88 3c 08
	00 00		 movzx	 ecx, WORD PTR [rax+2108]
  00ab5	e8 00 00 00 00	 call	 _byteswap_ushort
  00aba	48 8b 4c 24 48	 mov	 rcx, QWORD PTR cpuxinfo$[rsp]
  00abf	0f b7 d0	 movzx	 edx, ax
  00ac2	e8 00 00 00 00	 call	 store_hw_noswap

; 656  :               cpuxinfo->index = sysblk.ptyp[i];

  00ac7	48 63 44 24 40	 movsxd	 rax, DWORD PTR i$[rsp]
  00acc	48 8b 4c 24 48	 mov	 rcx, QWORD PTR cpuxinfo$[rsp]
  00ad1	48 8b 15 00 00
	00 00		 mov	 rdx, QWORD PTR __imp_sysblk
  00ad8	0f b6 84 02 48
	0b 00 00	 movzx	 eax, BYTE PTR [rdx+rax+2888]
  00ae0	88 41 04	 mov	 BYTE PTR [rcx+4], al

; 657  :               STORE_HW(cpuxinfo->weight,100);

  00ae3	66 b9 64 00	 mov	 cx, 100			; 00000064H
  00ae7	e8 00 00 00 00	 call	 _byteswap_ushort
  00aec	48 8b 4c 24 48	 mov	 rcx, QWORD PTR cpuxinfo$[rsp]
  00af1	48 83 c1 06	 add	 rcx, 6
  00af5	0f b7 d0	 movzx	 edx, ax
  00af8	e8 00 00 00 00	 call	 store_hw_noswap

; 658  : 
; 659  :               STORE_DW(cpuxinfo->totdispatch, tCPU[i]);

  00afd	48 63 44 24 40	 movsxd	 rax, DWORD PTR i$[rsp]
  00b02	48 8b 8c c4 00
	03 00 00	 mov	 rcx, QWORD PTR tCPU$[rsp+rax*8]
  00b0a	e8 00 00 00 00	 call	 _byteswap_uint64
  00b0f	48 8b 4c 24 48	 mov	 rcx, QWORD PTR cpuxinfo$[rsp]
  00b14	48 83 c1 08	 add	 rcx, 8
  00b18	48 8b d0	 mov	 rdx, rax
  00b1b	e8 00 00 00 00	 call	 store_dw_noswap

; 660  :               STORE_DW(cpuxinfo->effdispatch, uCPU[i]);

  00b20	48 63 44 24 40	 movsxd	 rax, DWORD PTR i$[rsp]
  00b25	48 8b 8c c4 00
	01 00 00	 mov	 rcx, QWORD PTR uCPU$[rsp+rax*8]
  00b2d	e8 00 00 00 00	 call	 _byteswap_uint64
  00b32	48 8b 4c 24 48	 mov	 rcx, QWORD PTR cpuxinfo$[rsp]
  00b37	48 83 c1 10	 add	 rcx, 16
  00b3b	48 8b d0	 mov	 rdx, rax
  00b3e	e8 00 00 00 00	 call	 store_dw_noswap

; 661  : 
; 662  :               STORE_HW(cpuxinfo->minweight,1000);

  00b43	66 b9 e8 03	 mov	 cx, 1000		; 000003e8H
  00b47	e8 00 00 00 00	 call	 _byteswap_ushort
  00b4c	48 8b 4c 24 48	 mov	 rcx, QWORD PTR cpuxinfo$[rsp]
  00b51	48 83 c1 18	 add	 rcx, 24
  00b55	0f b7 d0	 movzx	 edx, ax
  00b58	e8 00 00 00 00	 call	 store_hw_noswap

; 663  :               STORE_HW(cpuxinfo->curweight,1000);

  00b5d	66 b9 e8 03	 mov	 cx, 1000		; 000003e8H
  00b61	e8 00 00 00 00	 call	 _byteswap_ushort
  00b66	48 8b 4c 24 48	 mov	 rcx, QWORD PTR cpuxinfo$[rsp]
  00b6b	48 83 c1 1a	 add	 rcx, 26
  00b6f	0f b7 d0	 movzx	 edx, ax
  00b72	e8 00 00 00 00	 call	 store_hw_noswap

; 664  :               STORE_HW(cpuxinfo->maxweight,1000);

  00b77	66 b9 e8 03	 mov	 cx, 1000		; 000003e8H
  00b7b	e8 00 00 00 00	 call	 _byteswap_ushort
  00b80	48 8b 4c 24 48	 mov	 rcx, QWORD PTR cpuxinfo$[rsp]
  00b85	48 83 c1 1c	 add	 rcx, 28
  00b89	0f b7 d0	 movzx	 edx, ax
  00b8c	e8 00 00 00 00	 call	 store_hw_noswap

; 665  : 
; 666  :               STORE_DW(cpuxinfo->onlinetime, oCPU[i]);

  00b91	48 63 44 24 40	 movsxd	 rax, DWORD PTR i$[rsp]
  00b96	48 8b 8c c4 00
	05 00 00	 mov	 rcx, QWORD PTR oCPU$[rsp+rax*8]
  00b9e	e8 00 00 00 00	 call	 _byteswap_uint64
  00ba3	48 8b 4c 24 48	 mov	 rcx, QWORD PTR cpuxinfo$[rsp]
  00ba8	48 83 c1 20	 add	 rcx, 32			; 00000020H
  00bac	48 8b d0	 mov	 rdx, rax
  00baf	e8 00 00 00 00	 call	 store_dw_noswap

; 667  :               STORE_DW(cpuxinfo->waittime,   wCPU[i]);

  00bb4	48 63 44 24 40	 movsxd	 rax, DWORD PTR i$[rsp]
  00bb9	48 8b 8c c4 00
	07 00 00	 mov	 rcx, QWORD PTR wCPU$[rsp+rax*8]
  00bc1	e8 00 00 00 00	 call	 _byteswap_uint64
  00bc6	48 8b 4c 24 48	 mov	 rcx, QWORD PTR cpuxinfo$[rsp]
  00bcb	48 83 c1 28	 add	 rcx, 40			; 00000028H
  00bcf	48 8b d0	 mov	 rdx, rax
  00bd2	e8 00 00 00 00	 call	 store_dw_noswap

; 668  : 
; 669  :               STORE_HW(cpuxinfo->pmaweight,1000);

  00bd7	66 b9 e8 03	 mov	 cx, 1000		; 000003e8H
  00bdb	e8 00 00 00 00	 call	 _byteswap_ushort
  00be0	48 8b 4c 24 48	 mov	 rcx, QWORD PTR cpuxinfo$[rsp]
  00be5	48 83 c1 30	 add	 rcx, 48			; 00000030H
  00be9	0f b7 d0	 movzx	 edx, ax
  00bec	e8 00 00 00 00	 call	 store_hw_noswap

; 670  :               STORE_HW(cpuxinfo->polarweight,1000);

  00bf1	66 b9 e8 03	 mov	 cx, 1000		; 000003e8H
  00bf5	e8 00 00 00 00	 call	 _byteswap_ushort
  00bfa	48 8b 4c 24 48	 mov	 rcx, QWORD PTR cpuxinfo$[rsp]
  00bff	48 83 c1 34	 add	 rcx, 52			; 00000034H
  00c03	0f b7 d0	 movzx	 edx, ax
  00c06	e8 00 00 00 00	 call	 store_hw_noswap

; 671  :               cpuxinfo->cflag=0x20;

  00c0b	48 8b 44 24 48	 mov	 rax, QWORD PTR cpuxinfo$[rsp]
  00c10	c6 40 05 20	 mov	 BYTE PTR [rax+5], 32	; 00000020H

; 672  : 
; 673  :               cpuxinfo += 1;

  00c14	48 8b 44 24 48	 mov	 rax, QWORD PTR cpuxinfo$[rsp]
  00c19	48 83 c0 60	 add	 rax, 96			; 00000060H
  00c1d	48 89 44 24 48	 mov	 QWORD PTR cpuxinfo$[rsp], rax
$LN31@z900_diag2:

; 674  :           }

  00c22	e9 29 fe ff ff	 jmp	 $LN13@z900_diag2
$LN14@z900_diag2:

; 675  : 
; 676  : 
; 677  : #if defined(FEATURE_PHYSICAL_DIAG204)
; 678  :         /* LPAR management */
; 679  :         /* FIXME: This section should report on the real CPUs, appearing
; 680  :          *        and transformed for reporting purposes. This should
; 681  :          *        also be properly reflected in STSI information.
; 682  :          */
; 683  :         partxinfo = (DIAG204_X_PART*)cpuxinfo;
; 684  :         memset(partxinfo, 0, sizeof(DIAG204_X_PART));
; 685  :         partxinfo->partnum = 0; /* Physical machine */
; 686  :         partxinfo->virtcpu = sysblk.cpus;
; 687  :         partxinfo->realcpu = hostinfo.num_procs;
; 688  :         memcpy(partxinfo->partname,physical,sizeof(physical));
; 689  : 
; 690  :         /* report all emulated physical cpu's */
; 691  :         cpuxinfo = (DIAG204_PART_CPU*)(partinfo + 1);
; 692  :         for(i = 0; i < sysblk.maxcpu; i++)
; 693  :           if (IS_CPU_ONLINE(i))
; 694  :           {
; 695  :               memset(cpuxinfo, 0, sizeof(DIAG204_X_PART_CPU));
; 696  :               STORE_HW(cpuxinfo->cpaddr,sysblk.regs[i]->cpuad);
; 697  :               cpuxinfo->index = sysblk.ptyp[i];
; 698  :               STORE_HW(cpuxinfo->weight,100);
; 699  : 
; 700  :               STORE_DW(cpuxinfo->totdispatch, tCPU[i]);
; 701  :               STORE_DW(cpuxinfo->effdispatch, uCPU[i]);
; 702  : 
; 703  :               STORE_HW(cpuxinfo->minweight,1000);
; 704  :               STORE_HW(cpuxinfo->curweight,1000);
; 705  :               STORE_HW(cpuxinfo->maxweight,1000);
; 706  : 
; 707  :               STORE_DW(cpuxinfo->onlinetime, oCPU[i]);
; 708  :               STORE_DW(cpuxinfo->waittime,   wCPU[i]);
; 709  : 
; 710  :               STORE_HW(cpuxinfo->pmaweight,1000);
; 711  :               STORE_HW(cpuxinfo->polarweight,1000);
; 712  : 
; 713  :               cpuxinfo += 1;
; 714  :           }
; 715  : #endif /*defined(FEATURE_PHYSICAL_DIAG204)*/
; 716  : 
; 717  :         regs->GR_L(r2) = 0;

  00c27	48 63 84 24 38
	09 00 00	 movsxd	 rax, DWORD PTR r2$[rsp]
  00c2f	48 8b 8c 24 40
	09 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00c37	c7 84 c1 80 02
	00 00 00 00 00
	00		 mov	 DWORD PTR [rcx+rax*8+640], 0

; 718  : 
; 719  :         break;

  00c42	e9 a6 00 00 00	 jmp	 $LN2@z900_diag2
$LN32@z900_diag2:
$LN18@z900_diag2:

; 720  : #endif /*defined(FEATURE_EXTENDED_DIAG204)*/
; 721  : 
; 722  :     default:
; 723  :         PTT_ERR("*DIAG204",regs->GR_L(r1),regs->GR_L(r2),regs->psw.IA_L);

  00c47	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_pttclass
  00c4e	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00c51	48 83 e0 10	 and	 rax, 16
  00c55	48 85 c0	 test	 rax, rax
  00c58	74 6e		 je	 SHORT $LN33@z900_diag2
  00c5a	48 8b 84 24 40
	09 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00c62	8b 80 88 00 00
	00		 mov	 eax, DWORD PTR [rax+136]
  00c68	48 63 8c 24 38
	09 00 00	 movsxd	 rcx, DWORD PTR r2$[rsp]
  00c70	48 8b 94 24 40
	09 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  00c78	8b 8c ca 80 02
	00 00		 mov	 ecx, DWORD PTR [rdx+rcx*8+640]
  00c7f	48 63 94 24 30
	09 00 00	 movsxd	 rdx, DWORD PTR r1$[rsp]
  00c87	48 8b bc 24 40
	09 00 00	 mov	 rdi, QWORD PTR regs$[rsp]
  00c8f	8b 94 d7 80 02
	00 00		 mov	 edx, DWORD PTR [rdi+rdx*8+640]
  00c96	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR [rsp+48], 0
  00c9f	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  00ca4	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG192895
  00cab	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00cb0	44 8b c9	 mov	 r9d, ecx
  00cb3	44 8b c2	 mov	 r8d, edx
  00cb6	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG192896
  00cbd	b9 10 00 00 00	 mov	 ecx, 16
  00cc2	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ptt_pthread_trace
$LN33@z900_diag2:
  00cc8	33 c0		 xor	 eax, eax
  00cca	85 c0		 test	 eax, eax
  00ccc	0f 85 75 ff ff
	ff		 jne	 $LN18@z900_diag2

; 724  :         regs->GR_L(r2) = 4;

  00cd2	48 63 84 24 38
	09 00 00	 movsxd	 rax, DWORD PTR r2$[rsp]
  00cda	48 8b 8c 24 40
	09 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00ce2	c7 84 c1 80 02
	00 00 04 00 00
	00		 mov	 DWORD PTR [rcx+rax*8+640], 4
$LN2@z900_diag2:

; 725  : 
; 726  :     } /*switch(regs->GR_L(r2))*/
; 727  : 
; 728  : } /* end function diag204_call */

  00ced	48 8b 8c 24 00
	09 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  00cf5	48 33 cc	 xor	 rcx, rsp
  00cf8	e8 00 00 00 00	 call	 __security_check_cookie
  00cfd	48 81 c4 18 09
	00 00		 add	 rsp, 2328		; 00000918H
  00d04	5f		 pop	 rdi
  00d05	5e		 pop	 rsi
  00d06	c3		 ret	 0
z900_diag204_call ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\diagmssf.c
_TEXT	SEGMENT
z900_scpend_call PROC

; 265  : {

$LN3:
  00000	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 266  :         sched_yield();                  /* Just go to the dispatcher

  00004	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_sched_yield

; 267  :                                            for a minimum delay       */
; 268  : } /* end function scpend_call */

  0000a	48 83 c4 28	 add	 rsp, 40			; 00000028H
  0000e	c3		 ret	 0
z900_scpend_call ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\skey.h
;	COMDAT s390_or_storage_key
_TEXT	SEGMENT
abs$ = 48
bits$ = 56
s390_or_storage_key PROC				; COMDAT

; 290  : {

$LN3:
  00000	88 54 24 10	 mov	 BYTE PTR [rsp+16], dl
  00004	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00009	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 291  : #if defined( FEATURE_2K_STORAGE_KEYS )
; 292  :     ARCH_DEP( or_2K_storage_key )( abs, bits );
; 293  : #else
; 294  :     ARCH_DEP( or_4K_storage_key )( abs, bits );

  0000d	0f b6 54 24 38	 movzx	 edx, BYTE PTR bits$[rsp]
  00012	48 8b 4c 24 30	 mov	 rcx, QWORD PTR abs$[rsp]
  00017	e8 00 00 00 00	 call	 s390_or_4K_storage_key

; 295  : #endif
; 296  : }

  0001c	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00020	c3		 ret	 0
s390_or_storage_key ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\skey.h
;	COMDAT s390_or_4K_storage_key
_TEXT	SEGMENT
abs$ = 48
bits$ = 56
s390_or_4K_storage_key PROC				; COMDAT

; 242  :   inline void  ARCH_DEP( or_4K_storage_key )      (              U64 abs, BYTE bits ) {        ARCH_DEP( _or_storage_key      )(      abs, bits & ~STORKEY_BADFRM, 4 ); }

$LN3:
  00000	88 54 24 10	 mov	 BYTE PTR [rsp+16], dl
  00004	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00009	48 83 ec 28	 sub	 rsp, 40			; 00000028H
  0000d	0f b6 44 24 38	 movzx	 eax, BYTE PTR bits$[rsp]
  00012	83 e0 fe	 and	 eax, -2
  00015	41 b0 04	 mov	 r8b, 4
  00018	0f b6 d0	 movzx	 edx, al
  0001b	48 8b 4c 24 30	 mov	 rcx, QWORD PTR abs$[rsp]
  00020	e8 00 00 00 00	 call	 s390__or_storage_key
  00025	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00029	c3		 ret	 0
s390_or_4K_storage_key ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\skey.h
;	COMDAT s390__or_storage_key
_TEXT	SEGMENT
skey1_ptr$1 = 32
skey2_ptr$2 = 40
skey_ptr$3 = 48
abs$ = 80
bits$ = 88
K$ = 96
s390__or_storage_key PROC				; COMDAT

; 189  : {

$LN8:
  00000	44 88 44 24 18	 mov	 BYTE PTR [rsp+24], r8b
  00005	88 54 24 10	 mov	 BYTE PTR [rsp+16], dl
  00009	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000e	48 83 ec 48	 sub	 rsp, 72			; 00000048H
$LN4@s390__or_s:

; 190  :     UNREFERENCED( K ); // (for FEATURE_4K_STORAGE_KEYS case)

  00012	33 c0		 xor	 eax, eax
  00014	85 c0		 test	 eax, eax
  00016	75 fa		 jne	 SHORT $LN4@s390__or_s

; 191  :     if (IS_DOUBLE_KEYED_4K_BYTE_BLOCK( K ))

  00018	33 c0		 xor	 eax, eax
  0001a	85 c0		 test	 eax, eax
  0001c	74 50		 je	 SHORT $LN5@s390__or_s

; 192  :     {
; 193  :         BYTE* skey1_ptr = _get_storekey1_ptr( abs );

  0001e	48 8b 4c 24 50	 mov	 rcx, QWORD PTR abs$[rsp]
  00023	e8 00 00 00 00	 call	 _get_storekey1_ptr
  00028	48 89 44 24 20	 mov	 QWORD PTR skey1_ptr$1[rsp], rax

; 194  :         BYTE* skey2_ptr = _get_storekey2_ptr( abs );

  0002d	48 8b 4c 24 50	 mov	 rcx, QWORD PTR abs$[rsp]
  00032	e8 00 00 00 00	 call	 _get_storekey2_ptr
  00037	48 89 44 24 28	 mov	 QWORD PTR skey2_ptr$2[rsp], rax

; 195  :         OR_SKEY( skey1_ptr, bits );

  0003c	0f b6 44 24 58	 movzx	 eax, BYTE PTR bits$[rsp]
  00041	48 8b 4c 24 20	 mov	 rcx, QWORD PTR skey1_ptr$1[rsp]
  00046	0f b6 09	 movzx	 ecx, BYTE PTR [rcx]
  00049	0b c8		 or	 ecx, eax
  0004b	8b c1		 mov	 eax, ecx
  0004d	48 8b 4c 24 20	 mov	 rcx, QWORD PTR skey1_ptr$1[rsp]
  00052	88 01		 mov	 BYTE PTR [rcx], al

; 196  :         OR_SKEY( skey2_ptr, bits );

  00054	0f b6 44 24 58	 movzx	 eax, BYTE PTR bits$[rsp]
  00059	48 8b 4c 24 28	 mov	 rcx, QWORD PTR skey2_ptr$2[rsp]
  0005e	0f b6 09	 movzx	 ecx, BYTE PTR [rcx]
  00061	0b c8		 or	 ecx, eax
  00063	8b c1		 mov	 eax, ecx
  00065	48 8b 4c 24 28	 mov	 rcx, QWORD PTR skey2_ptr$2[rsp]
  0006a	88 01		 mov	 BYTE PTR [rcx], al

; 197  :     }

  0006c	eb 2c		 jmp	 SHORT $LN6@s390__or_s
$LN5@s390__or_s:

; 198  :     else
; 199  :     {
; 200  :         BYTE* skey_ptr  = _get_storekey_ptr( abs, K );

  0006e	0f b6 54 24 60	 movzx	 edx, BYTE PTR K$[rsp]
  00073	48 8b 4c 24 50	 mov	 rcx, QWORD PTR abs$[rsp]
  00078	e8 00 00 00 00	 call	 _get_storekey_ptr
  0007d	48 89 44 24 30	 mov	 QWORD PTR skey_ptr$3[rsp], rax

; 201  :         OR_SKEY( skey_ptr, bits );

  00082	0f b6 44 24 58	 movzx	 eax, BYTE PTR bits$[rsp]
  00087	48 8b 4c 24 30	 mov	 rcx, QWORD PTR skey_ptr$3[rsp]
  0008c	0f b6 09	 movzx	 ecx, BYTE PTR [rcx]
  0008f	0b c8		 or	 ecx, eax
  00091	8b c1		 mov	 eax, ecx
  00093	48 8b 4c 24 30	 mov	 rcx, QWORD PTR skey_ptr$3[rsp]
  00098	88 01		 mov	 BYTE PTR [rcx], al
$LN6@s390__or_s:

; 202  :     }
; 203  : }

  0009a	48 83 c4 48	 add	 rsp, 72			; 00000048H
  0009e	c3		 ret	 0
s390__or_storage_key ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\diagmssf.c
_TEXT	SEGMENT
i$ = 32
ptyp$ = 36
tv95 = 40
len$ = 44
p$ = 48
abs$ = 56
r1$ = 96
r2$ = 104
regs$ = 112
s390_diag224_call PROC

; 735  : {

$LN17:
  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00009	89 4c 24 08	 mov	 DWORD PTR [rsp+8], ecx
  0000d	56		 push	 rsi
  0000e	57		 push	 rdi
  0000f	48 83 ec 48	 sub	 rsp, 72			; 00000048H
$LN4@s390_diag2:

; 736  : RADR              abs;                 /* abs addr of data area      */
; 737  : BYTE             *p;                   /* pointer to the data area   */
; 738  : unsigned int      len, ptyp, i;        /* work                       */
; 739  : 
; 740  :     // FIXME:  This function is probably incomplete.
; 741  :     //         See linux/arch/s390/hypfs/hypfs_diag.c
; 742  : 
; 743  :     UNREFERENCED( r1 );

  00013	33 c0		 xor	 eax, eax
  00015	85 c0		 test	 eax, eax
  00017	75 fa		 jne	 SHORT $LN4@s390_diag2

; 744  : 
; 745  :     abs = APPLY_PREFIXING( regs->GR_L( r2 ), regs->PX );

  00019	48 63 44 24 68	 movsxd	 rax, DWORD PTR r2$[rsp]
  0001e	48 8b 4c 24 70	 mov	 rcx, QWORD PTR regs$[rsp]
  00023	8b 84 c1 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax*8+640]
  0002a	48 25 00 f0 ff
	ff		 and	 rax, -4096		; fffffffffffff000H
  00030	48 85 c0	 test	 rax, rax
  00033	74 3b		 je	 SHORT $LN15@s390_diag2
  00035	48 63 44 24 68	 movsxd	 rax, DWORD PTR r2$[rsp]
  0003a	48 8b 4c 24 70	 mov	 rcx, QWORD PTR regs$[rsp]
  0003f	8b 84 c1 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax*8+640]
  00046	48 25 00 f0 ff
	ff		 and	 rax, -4096		; fffffffffffff000H
  0004c	48 8b 4c 24 70	 mov	 rcx, QWORD PTR regs$[rsp]
  00051	8b 49 70	 mov	 ecx, DWORD PTR [rcx+112]
  00054	48 3b c1	 cmp	 rax, rcx
  00057	74 17		 je	 SHORT $LN15@s390_diag2
  00059	48 63 44 24 68	 movsxd	 rax, DWORD PTR r2$[rsp]
  0005e	48 8b 4c 24 70	 mov	 rcx, QWORD PTR regs$[rsp]
  00063	8b 84 c1 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax*8+640]
  0006a	89 44 24 28	 mov	 DWORD PTR tv95[rsp], eax
  0006e	eb 1f		 jmp	 SHORT $LN16@s390_diag2
$LN15@s390_diag2:
  00070	48 63 44 24 68	 movsxd	 rax, DWORD PTR r2$[rsp]
  00075	48 8b 4c 24 70	 mov	 rcx, QWORD PTR regs$[rsp]
  0007a	48 8b 54 24 70	 mov	 rdx, QWORD PTR regs$[rsp]
  0007f	8b 52 70	 mov	 edx, DWORD PTR [rdx+112]
  00082	8b 84 c1 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax*8+640]
  00089	33 c2		 xor	 eax, edx
  0008b	89 44 24 28	 mov	 DWORD PTR tv95[rsp], eax
$LN16@s390_diag2:
  0008f	8b 44 24 28	 mov	 eax, DWORD PTR tv95[rsp]
  00093	48 89 44 24 38	 mov	 QWORD PTR abs$[rsp], rax

; 746  : 
; 747  :     /* Program check if data area is not on a page boundary */
; 748  :     if ((abs & PAGEFRAME_BYTEMASK) != 0)

  00098	48 8b 44 24 38	 mov	 rax, QWORD PTR abs$[rsp]
  0009d	48 25 ff 0f 00
	00		 and	 rax, 4095		; 00000fffH
  000a3	48 85 c0	 test	 rax, rax
  000a6	74 0f		 je	 SHORT $LN11@s390_diag2

; 749  :         ARCH_DEP( program_interrupt )( regs, PGM_SPECIFICATION_EXCEPTION );

  000a8	ba 06 00 00 00	 mov	 edx, 6
  000ad	48 8b 4c 24 70	 mov	 rcx, QWORD PTR regs$[rsp]
  000b2	e8 00 00 00 00	 call	 s390_program_interrupt
$LN11@s390_diag2:

; 750  : 
; 751  :     /* Calculate length of data to be stored */
; 752  :     len = 16 + ((MAX_SCCB_PTYP + 1) * 16);

  000b7	c7 44 24 2c 70
	00 00 00	 mov	 DWORD PTR len$[rsp], 112 ; 00000070H

; 753  : 
; 754  :     /* Program check if data area is outside main storage */
; 755  :     if (abs > regs->mainlim || len > PAGEFRAME_PAGESIZE)

  000bf	48 8b 44 24 70	 mov	 rax, QWORD PTR regs$[rsp]
  000c4	48 8b 80 58 08
	00 00		 mov	 rax, QWORD PTR [rax+2136]
  000cb	48 39 44 24 38	 cmp	 QWORD PTR abs$[rsp], rax
  000d0	77 0a		 ja	 SHORT $LN13@s390_diag2
  000d2	81 7c 24 2c 00
	10 00 00	 cmp	 DWORD PTR len$[rsp], 4096 ; 00001000H
  000da	76 0f		 jbe	 SHORT $LN12@s390_diag2
$LN13@s390_diag2:

; 756  :         ARCH_DEP( program_interrupt )( regs, PGM_ADDRESSING_EXCEPTION );

  000dc	ba 05 00 00 00	 mov	 edx, 5
  000e1	48 8b 4c 24 70	 mov	 rcx, QWORD PTR regs$[rsp]
  000e6	e8 00 00 00 00	 call	 s390_program_interrupt
$LN12@s390_diag2:

; 757  : 
; 758  :     /* Mark page referenced */
; 759  :     ARCH_DEP( or_storage_key )( abs, (STORKEY_REF | STORKEY_CHANGE) );

  000eb	b2 06		 mov	 dl, 6
  000ed	48 8b 4c 24 38	 mov	 rcx, QWORD PTR abs$[rsp]
  000f2	e8 00 00 00 00	 call	 s390_or_storage_key

; 760  : 
; 761  :     /* Point to DIAG 224 return area */
; 762  :     p = regs->mainstor + abs;

  000f7	48 8b 44 24 70	 mov	 rax, QWORD PTR regs$[rsp]
  000fc	48 8b 80 48 08
	00 00		 mov	 rax, QWORD PTR [rax+2120]
  00103	48 03 44 24 38	 add	 rax, QWORD PTR abs$[rsp]
  00108	48 89 44 24 30	 mov	 QWORD PTR p$[rsp], rax

; 763  : 
; 764  :     /*
; 765  :     ** The first byte of the first 16-byte entry contains the total number
; 766  :     ** of 16-byte entries minus 1 that immediately follows the first entry.
; 767  :     ** The remaining 15 bytes of the first 16-byte entry are binary zeros.
; 768  :     ** Each of the remaining entries following the first one contains the
; 769  :     ** EBCDIC name of each processor type.
; 770  :     */
; 771  : 
; 772  :     *p = MAX_SCCB_PTYP;         /* (number of entries which follows-1) */

  0010d	48 8b 44 24 30	 mov	 rax, QWORD PTR p$[rsp]
  00112	c6 00 05	 mov	 BYTE PTR [rax], 5

; 773  :     memset( p+1, 0, 16-1 );     /* (pad first entry with binary zeros) */

  00115	48 8b 44 24 30	 mov	 rax, QWORD PTR p$[rsp]
  0011a	48 ff c0	 inc	 rax
  0011d	48 8b f8	 mov	 rdi, rax
  00120	33 c0		 xor	 eax, eax
  00122	b9 0f 00 00 00	 mov	 ecx, 15
  00127	f3 aa		 rep stosb

; 774  : 
; 775  :     for (ptyp=0; ptyp <= MAX_SCCB_PTYP; ptyp++)

  00129	c7 44 24 24 00
	00 00 00	 mov	 DWORD PTR ptyp$[rsp], 0
  00131	eb 0a		 jmp	 SHORT $LN7@s390_diag2
$LN5@s390_diag2:
  00133	8b 44 24 24	 mov	 eax, DWORD PTR ptyp$[rsp]
  00137	ff c0		 inc	 eax
  00139	89 44 24 24	 mov	 DWORD PTR ptyp$[rsp], eax
$LN7@s390_diag2:
  0013d	83 7c 24 24 05	 cmp	 DWORD PTR ptyp$[rsp], 5
  00142	77 66		 ja	 SHORT $LN6@s390_diag2

; 776  :     {
; 777  :         p += 16;                              /* point to next entry   */

  00144	48 8b 44 24 30	 mov	 rax, QWORD PTR p$[rsp]
  00149	48 83 c0 10	 add	 rax, 16
  0014d	48 89 44 24 30	 mov	 QWORD PTR p$[rsp], rax

; 778  :         memcpy( p, ptyp2long( ptyp ), 16 );   /* move in ASCII value   */

  00152	0f b6 4c 24 24	 movzx	 ecx, BYTE PTR ptyp$[rsp]
  00157	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ptyp2long
  0015d	48 8b 7c 24 30	 mov	 rdi, QWORD PTR p$[rsp]
  00162	48 8b f0	 mov	 rsi, rax
  00165	b9 10 00 00 00	 mov	 ecx, 16
  0016a	f3 a4		 rep movsb

; 779  :         for (i=0; i < 16; i++)

  0016c	c7 44 24 20 00
	00 00 00	 mov	 DWORD PTR i$[rsp], 0
  00174	eb 0a		 jmp	 SHORT $LN10@s390_diag2
$LN8@s390_diag2:
  00176	8b 44 24 20	 mov	 eax, DWORD PTR i$[rsp]
  0017a	ff c0		 inc	 eax
  0017c	89 44 24 20	 mov	 DWORD PTR i$[rsp], eax
$LN10@s390_diag2:
  00180	83 7c 24 20 10	 cmp	 DWORD PTR i$[rsp], 16
  00185	73 21		 jae	 SHORT $LN9@s390_diag2

; 780  :             p[i] = host_to_guest( p[i] );     /* convert it to EBCDIC  */

  00187	8b 44 24 20	 mov	 eax, DWORD PTR i$[rsp]
  0018b	48 8b 4c 24 30	 mov	 rcx, QWORD PTR p$[rsp]
  00190	0f b6 0c 01	 movzx	 ecx, BYTE PTR [rcx+rax]
  00194	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_host_to_guest
  0019a	8b 4c 24 20	 mov	 ecx, DWORD PTR i$[rsp]
  0019e	48 8b 54 24 30	 mov	 rdx, QWORD PTR p$[rsp]
  001a3	88 04 0a	 mov	 BYTE PTR [rdx+rcx], al
  001a6	eb ce		 jmp	 SHORT $LN8@s390_diag2
$LN9@s390_diag2:

; 781  :     }

  001a8	eb 89		 jmp	 SHORT $LN5@s390_diag2
$LN6@s390_diag2:

; 782  : 
; 783  : } /* end function diag224_call */

  001aa	48 83 c4 48	 add	 rsp, 72			; 00000048H
  001ae	5f		 pop	 rdi
  001af	5e		 pop	 rsi
  001b0	c3		 ret	 0
s390_diag224_call ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\diagmssf.c
_TEXT	SEGMENT
i$ = 64
cpuinfo$ = 72
hdrinfo$ = 80
tv132 = 88
partinfo$ = 96
abs$ = 104
tv69 = 112
tv173 = 120
$T1 = 128
cputime$ = 144
ETOD$ = 160
uCPU$ = 176
tCPU$ = 688
__$ArrayPad$ = 1200
r1$ = 1248
r2$ = 1256
regs$ = 1264
s390_diag204_call PROC

; 450  : {

$LN24:
  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00009	89 4c 24 08	 mov	 DWORD PTR [rsp+8], ecx
  0000d	56		 push	 rsi
  0000e	57		 push	 rdi
  0000f	48 81 ec c8 04
	00 00		 sub	 rsp, 1224		; 000004c8H
  00016	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  0001d	48 33 c4	 xor	 rax, rsp
  00020	48 89 84 24 b0
	04 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 451  : DIAG204_HDR       *hdrinfo;            /* Header                     */
; 452  : DIAG204_PART      *partinfo;           /* Partition info             */
; 453  : DIAG204_PART_CPU  *cpuinfo;            /* CPU info                   */
; 454  : 
; 455  : #if defined( FEATURE_EXTENDED_DIAG204 )
; 456  : DIAG204_X_HDR       *hdrxinfo;         /* Header                     */
; 457  : DIAG204_X_PART      *partxinfo;        /* Partition info             */
; 458  : DIAG204_X_PART_CPU  *cpuxinfo;         /* CPU info                   */
; 459  : #endif
; 460  : 
; 461  : RADR             abs;                  /* abs addr of data area      */
; 462  : int              i;                    /* loop counter               */
; 463  : struct timespec  cputime;              /* to obtain thread time data */
; 464  : ETOD             ETOD;                 /* Extended TOD clock         */
; 465  : U64              uCPU[ MAX_CPU_ENGS ]; /* User CPU time    (usecs)   */
; 466  : U64              tCPU[ MAX_CPU_ENGS ]; /* Total CPU time   (usecs)   */
; 467  : 
; 468  : #if defined( FEATURE_PHYSICAL_DIAG204 )
; 469  : static BYTE       physical[8] =
; 470  :               {0xD7,0xC8,0xE8,0xE2,0xC9,0xC3,0xC1,0xD3}; /* PHYSICAL */
; 471  : #endif
; 472  : 
; 473  : #if defined( FEATURE_EXTENDED_DIAG204 )
; 474  : U64              oCPU[ MAX_CPU_ENGS ];  /* Online CPU time  (usecs)  */
; 475  : U64              wCPU[ MAX_CPU_ENGS ];  /* Wait CPU time    (usecs)  */
; 476  : #endif
; 477  : 
; 478  :     /* Test DIAG204 command word */
; 479  :     switch (regs->GR_L(r2)) {

  00028	48 63 84 24 e8
	04 00 00	 movsxd	 rax, DWORD PTR r2$[rsp]
  00030	48 8b 8c 24 f0
	04 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00038	8b 84 c1 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax*8+640]
  0003f	89 44 24 70	 mov	 DWORD PTR tv69[rsp], eax
  00043	83 7c 24 70 04	 cmp	 DWORD PTR tv69[rsp], 4
  00048	74 05		 je	 SHORT $LN13@s390_diag2
  0004a	e9 46 04 00 00	 jmp	 $LN19@s390_diag2
$LN13@s390_diag2:

; 480  : 
; 481  :     case 0x04:
; 482  : 
; 483  :         abs = APPLY_PREFIXING (GR_A(r1,regs), regs->PX);

  0004f	48 63 84 24 e0
	04 00 00	 movsxd	 rax, DWORD PTR r1$[rsp]
  00057	48 8b 8c 24 f0
	04 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0005f	8b 84 c1 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax*8+640]
  00066	48 25 00 f0 ff
	ff		 and	 rax, -4096		; fffffffffffff000H
  0006c	48 85 c0	 test	 rax, rax
  0006f	74 4a		 je	 SHORT $LN22@s390_diag2
  00071	48 63 84 24 e0
	04 00 00	 movsxd	 rax, DWORD PTR r1$[rsp]
  00079	48 8b 8c 24 f0
	04 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00081	8b 84 c1 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax*8+640]
  00088	48 25 00 f0 ff
	ff		 and	 rax, -4096		; fffffffffffff000H
  0008e	48 8b 8c 24 f0
	04 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00096	8b 49 70	 mov	 ecx, DWORD PTR [rcx+112]
  00099	48 3b c1	 cmp	 rax, rcx
  0009c	74 1d		 je	 SHORT $LN22@s390_diag2
  0009e	48 63 84 24 e0
	04 00 00	 movsxd	 rax, DWORD PTR r1$[rsp]
  000a6	48 8b 8c 24 f0
	04 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  000ae	8b 84 c1 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax*8+640]
  000b5	89 44 24 58	 mov	 DWORD PTR tv132[rsp], eax
  000b9	eb 28		 jmp	 SHORT $LN23@s390_diag2
$LN22@s390_diag2:
  000bb	48 63 84 24 e0
	04 00 00	 movsxd	 rax, DWORD PTR r1$[rsp]
  000c3	48 8b 8c 24 f0
	04 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  000cb	48 8b 94 24 f0
	04 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  000d3	8b 52 70	 mov	 edx, DWORD PTR [rdx+112]
  000d6	8b 84 c1 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax*8+640]
  000dd	33 c2		 xor	 eax, edx
  000df	89 44 24 58	 mov	 DWORD PTR tv132[rsp], eax
$LN23@s390_diag2:
  000e3	8b 44 24 58	 mov	 eax, DWORD PTR tv132[rsp]
  000e7	48 89 44 24 68	 mov	 QWORD PTR abs$[rsp], rax

; 484  : 
; 485  :         /* Program check if RMF data is not on a page boundary */
; 486  :         if ( (abs & PAGEFRAME_BYTEMASK) != 0x000)

  000ec	48 8b 44 24 68	 mov	 rax, QWORD PTR abs$[rsp]
  000f1	48 25 ff 0f 00
	00		 and	 rax, 4095		; 00000fffH
  000f7	48 85 c0	 test	 rax, rax
  000fa	74 12		 je	 SHORT $LN14@s390_diag2

; 487  :             ARCH_DEP(program_interrupt) (regs, PGM_SPECIFICATION_EXCEPTION);

  000fc	ba 06 00 00 00	 mov	 edx, 6
  00101	48 8b 8c 24 f0
	04 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00109	e8 00 00 00 00	 call	 s390_program_interrupt
$LN14@s390_diag2:

; 488  : 
; 489  :         /* Program check if RMF data area is outside main storage */
; 490  :         if ( abs > regs->mainlim )

  0010e	48 8b 84 24 f0
	04 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00116	48 8b 80 58 08
	00 00		 mov	 rax, QWORD PTR [rax+2136]
  0011d	48 39 44 24 68	 cmp	 QWORD PTR abs$[rsp], rax
  00122	76 12		 jbe	 SHORT $LN15@s390_diag2

; 491  :             ARCH_DEP(program_interrupt) (regs, PGM_ADDRESSING_EXCEPTION);

  00124	ba 05 00 00 00	 mov	 edx, 5
  00129	48 8b 8c 24 f0
	04 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00131	e8 00 00 00 00	 call	 s390_program_interrupt
$LN15@s390_diag2:

; 492  : 
; 493  :         /* Point to DIAG 204 data area */
; 494  :         hdrinfo = (DIAG204_HDR*)(regs->mainstor + abs);

  00136	48 8b 84 24 f0
	04 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0013e	48 8b 80 48 08
	00 00		 mov	 rax, QWORD PTR [rax+2120]
  00145	48 03 44 24 68	 add	 rax, QWORD PTR abs$[rsp]
  0014a	48 89 44 24 50	 mov	 QWORD PTR hdrinfo$[rsp], rax

; 495  : 
; 496  :         /* Mark page referenced */
; 497  :         ARCH_DEP( or_storage_key )( abs, STORKEY_REF | STORKEY_CHANGE );

  0014f	b2 06		 mov	 dl, 6
  00151	48 8b 4c 24 68	 mov	 rcx, QWORD PTR abs$[rsp]
  00156	e8 00 00 00 00	 call	 s390_or_storage_key

; 498  : 
; 499  :         /* Retrieve the TOD clock value */
; 500  :         etod_clock(regs, &ETOD, ETOD_extended);

  0015b	41 b8 03 00 00
	00		 mov	 r8d, 3
  00161	48 8d 94 24 a0
	00 00 00	 lea	 rdx, QWORD PTR ETOD$[rsp]
  00169	48 8b 8c 24 f0
	04 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00171	e8 00 00 00 00	 call	 etod_clock

; 501  : 
; 502  :         /* Get processor time(s) and leave out non-CPU processes and
; 503  :          * threads
; 504  :          */
; 505  :         for(i = 0; i < sysblk.maxcpu; ++i)

  00176	c7 44 24 40 00
	00 00 00	 mov	 DWORD PTR i$[rsp], 0
  0017e	eb 0a		 jmp	 SHORT $LN6@s390_diag2
$LN4@s390_diag2:
  00180	8b 44 24 40	 mov	 eax, DWORD PTR i$[rsp]
  00184	ff c0		 inc	 eax
  00186	89 44 24 40	 mov	 DWORD PTR i$[rsp], eax
$LN6@s390_diag2:
  0018a	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00191	8b 80 00 01 00
	00		 mov	 eax, DWORD PTR [rax+256]
  00197	39 44 24 40	 cmp	 DWORD PTR i$[rsp], eax
  0019b	0f 8d be 00 00
	00		 jge	 $LN5@s390_diag2

; 506  :         {
; 507  :             if (IS_CPU_ONLINE(i))

  001a1	48 63 44 24 40	 movsxd	 rax, DWORD PTR i$[rsp]
  001a6	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  001ad	48 83 bc c1 98
	0b 00 00 00	 cmp	 QWORD PTR [rcx+rax*8+2968], 0
  001b6	0f 84 9e 00 00
	00		 je	 $LN16@s390_diag2

; 508  :             {
; 509  :                 /* Get CPU times in microseconds */
; 510  :                 if( clock_gettime(sysblk.cpuclockid[i], &cputime) == 0 )

  001bc	48 63 44 24 40	 movsxd	 rax, DWORD PTR i$[rsp]
  001c1	48 8d 94 24 90
	00 00 00	 lea	 rdx, QWORD PTR cputime$[rsp]
  001c9	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  001d0	8b 8c 81 48 0a
	00 00		 mov	 ecx, DWORD PTR [rcx+rax*4+2632]
  001d7	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_clock_gettime
  001dd	85 c0		 test	 eax, eax
  001df	75 79		 jne	 SHORT $LN17@s390_diag2

; 511  :                 {
; 512  :                     uCPU[i] = timespec2usecs(&cputime);

  001e1	48 8d 8c 24 90
	00 00 00	 lea	 rcx, QWORD PTR cputime$[rsp]
  001e9	e8 00 00 00 00	 call	 timespec2usecs
  001ee	48 63 4c 24 40	 movsxd	 rcx, DWORD PTR i$[rsp]
  001f3	48 89 84 cc b0
	00 00 00	 mov	 QWORD PTR uCPU$[rsp+rcx*8], rax

; 513  :                     tCPU[i] = uCPU[i] + ETOD_high64_to_usecs(sysblk.regs[i]->waittime_accumulated

  001fb	48 63 44 24 40	 movsxd	 rax, DWORD PTR i$[rsp]
  00200	48 89 44 24 78	 mov	 QWORD PTR tv173[rsp], rax
  00205	48 63 4c 24 40	 movsxd	 rcx, DWORD PTR i$[rsp]
  0020a	48 8b 15 00 00
	00 00		 mov	 rdx, QWORD PTR __imp_sysblk
  00211	48 8b 8c ca 98
	0b 00 00	 mov	 rcx, QWORD PTR [rdx+rcx*8+2968]
  00219	48 63 54 24 40	 movsxd	 rdx, DWORD PTR i$[rsp]
  0021e	4c 8b 05 00 00
	00 00		 mov	 r8, QWORD PTR __imp_sysblk
  00225	49 8b 94 d0 98
	0b 00 00	 mov	 rdx, QWORD PTR [r8+rdx*8+2968]
  0022d	48 8b 89 c8 07
	00 00		 mov	 rcx, QWORD PTR [rcx+1992]
  00234	48 03 8a c0 07
	00 00		 add	 rcx, QWORD PTR [rdx+1984]
  0023b	e8 00 00 00 00	 call	 ETOD_high64_to_usecs
  00240	48 8b 4c 24 78	 mov	 rcx, QWORD PTR tv173[rsp]
  00245	48 03 84 cc b0
	00 00 00	 add	 rax, QWORD PTR uCPU$[rsp+rcx*8]
  0024d	48 63 4c 24 40	 movsxd	 rcx, DWORD PTR i$[rsp]
  00252	48 89 84 cc b0
	02 00 00	 mov	 QWORD PTR tCPU$[rsp+rcx*8], rax
$LN17@s390_diag2:
$LN16@s390_diag2:

; 514  :                                               + sysblk.regs[i]->waittime ) ;
; 515  :                 }
; 516  :             }
; 517  :         }

  0025a	e9 21 ff ff ff	 jmp	 $LN4@s390_diag2
$LN5@s390_diag2:

; 518  : 
; 519  :         memset(hdrinfo, 0, sizeof(DIAG204_HDR));

  0025f	48 8b 7c 24 50	 mov	 rdi, QWORD PTR hdrinfo$[rsp]
  00264	33 c0		 xor	 eax, eax
  00266	b9 10 00 00 00	 mov	 ecx, 16
  0026b	f3 aa		 rep stosb

; 520  :         hdrinfo->numpart = 1;

  0026d	48 8b 44 24 50	 mov	 rax, QWORD PTR hdrinfo$[rsp]
  00272	c6 00 01	 mov	 BYTE PTR [rax], 1

; 521  : #if defined(FEATURE_PHYSICAL_DIAG204)
; 522  :         hdrinfo->flags = DIAG204_PHYSICAL_PRESENT;
; 523  : #endif /*defined(FEATURE_PHYSICAL_DIAG204)*/
; 524  :         STORE_HW(hdrinfo->physcpu,sysblk.cpus);

  00275	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  0027c	0f b7 88 04 01
	00 00		 movzx	 ecx, WORD PTR [rax+260]
  00283	e8 00 00 00 00	 call	 _byteswap_ushort
  00288	48 8b 4c 24 50	 mov	 rcx, QWORD PTR hdrinfo$[rsp]
  0028d	48 83 c1 04	 add	 rcx, 4
  00291	0f b7 d0	 movzx	 edx, ax
  00294	e8 00 00 00 00	 call	 store_hw_noswap

; 525  :         STORE_HW(hdrinfo->offown,sizeof(DIAG204_HDR));

  00299	66 b9 10 00	 mov	 cx, 16
  0029d	e8 00 00 00 00	 call	 _byteswap_ushort
  002a2	48 8b 4c 24 50	 mov	 rcx, QWORD PTR hdrinfo$[rsp]
  002a7	48 83 c1 06	 add	 rcx, 6
  002ab	0f b7 d0	 movzx	 edx, ax
  002ae	e8 00 00 00 00	 call	 store_hw_noswap

; 526  :         STORE_DW(hdrinfo->diagstck,ETOD2TOD(ETOD));

  002b3	48 8d 84 24 80
	00 00 00	 lea	 rax, QWORD PTR $T1[rsp]
  002bb	48 8d 8c 24 a0
	00 00 00	 lea	 rcx, QWORD PTR ETOD$[rsp]
  002c3	48 8b f8	 mov	 rdi, rax
  002c6	48 8b f1	 mov	 rsi, rcx
  002c9	b9 10 00 00 00	 mov	 ecx, 16
  002ce	f3 a4		 rep movsb
  002d0	48 8d 8c 24 80
	00 00 00	 lea	 rcx, QWORD PTR $T1[rsp]
  002d8	e8 00 00 00 00	 call	 ETOD2TOD
  002dd	48 8b c8	 mov	 rcx, rax
  002e0	e8 00 00 00 00	 call	 _byteswap_uint64
  002e5	48 8b 4c 24 50	 mov	 rcx, QWORD PTR hdrinfo$[rsp]
  002ea	48 83 c1 08	 add	 rcx, 8
  002ee	48 8b d0	 mov	 rdx, rax
  002f1	e8 00 00 00 00	 call	 store_dw_noswap

; 527  : 
; 528  :         /* hercules partition */
; 529  :         partinfo = (DIAG204_PART*)(hdrinfo + 1);

  002f6	48 8b 44 24 50	 mov	 rax, QWORD PTR hdrinfo$[rsp]
  002fb	48 83 c0 10	 add	 rax, 16
  002ff	48 89 44 24 60	 mov	 QWORD PTR partinfo$[rsp], rax

; 530  :         memset(partinfo, 0, sizeof(DIAG204_PART));

  00304	48 8b 7c 24 60	 mov	 rdi, QWORD PTR partinfo$[rsp]
  00309	33 c0		 xor	 eax, eax
  0030b	b9 10 00 00 00	 mov	 ecx, 16
  00310	f3 aa		 rep stosb

; 531  :         partinfo->partnum = sysblk.lparnum;     /* Hercules partition */

  00312	48 8b 44 24 60	 mov	 rax, QWORD PTR partinfo$[rsp]
  00317	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  0031e	0f b6 89 f0 00
	00 00		 movzx	 ecx, BYTE PTR [rcx+240]
  00325	88 08		 mov	 BYTE PTR [rax], cl

; 532  :         partinfo->virtcpu = sysblk.cpus;

  00327	48 8b 44 24 60	 mov	 rax, QWORD PTR partinfo$[rsp]
  0032c	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  00333	0f b6 89 04 01
	00 00		 movzx	 ecx, BYTE PTR [rcx+260]
  0033a	88 48 01	 mov	 BYTE PTR [rax+1], cl

; 533  :         get_lparname(partinfo->partname);

  0033d	48 8b 44 24 60	 mov	 rax, QWORD PTR partinfo$[rsp]
  00342	48 83 c0 08	 add	 rax, 8
  00346	48 8b c8	 mov	 rcx, rax
  00349	e8 00 00 00 00	 call	 get_lparname

; 534  : 
; 535  :         /* hercules cpu's */
; 536  :         cpuinfo = (DIAG204_PART_CPU*)(partinfo + 1);

  0034e	48 8b 44 24 60	 mov	 rax, QWORD PTR partinfo$[rsp]
  00353	48 83 c0 10	 add	 rax, 16
  00357	48 89 44 24 48	 mov	 QWORD PTR cpuinfo$[rsp], rax

; 537  :         for(i = 0; i < sysblk.maxcpu; i++)

  0035c	c7 44 24 40 00
	00 00 00	 mov	 DWORD PTR i$[rsp], 0
  00364	eb 0a		 jmp	 SHORT $LN9@s390_diag2
$LN7@s390_diag2:
  00366	8b 44 24 40	 mov	 eax, DWORD PTR i$[rsp]
  0036a	ff c0		 inc	 eax
  0036c	89 44 24 40	 mov	 DWORD PTR i$[rsp], eax
$LN9@s390_diag2:
  00370	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00377	8b 80 00 01 00
	00		 mov	 eax, DWORD PTR [rax+256]
  0037d	39 44 24 40	 cmp	 DWORD PTR i$[rsp], eax
  00381	0f 8d ee 00 00
	00		 jge	 $LN8@s390_diag2

; 538  :           if (IS_CPU_ONLINE(i))

  00387	48 63 44 24 40	 movsxd	 rax, DWORD PTR i$[rsp]
  0038c	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  00393	48 83 bc c1 98
	0b 00 00 00	 cmp	 QWORD PTR [rcx+rax*8+2968], 0
  0039c	0f 84 ce 00 00
	00		 je	 $LN18@s390_diag2

; 539  :           {
; 540  :               memset(cpuinfo, 0, sizeof(DIAG204_PART_CPU));

  003a2	48 8b 7c 24 48	 mov	 rdi, QWORD PTR cpuinfo$[rsp]
  003a7	33 c0		 xor	 eax, eax
  003a9	b9 18 00 00 00	 mov	 ecx, 24
  003ae	f3 aa		 rep stosb

; 541  :               STORE_HW(cpuinfo->cpaddr,sysblk.regs[i]->cpuad);

  003b0	48 63 44 24 40	 movsxd	 rax, DWORD PTR i$[rsp]
  003b5	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  003bc	48 8b 84 c1 98
	0b 00 00	 mov	 rax, QWORD PTR [rcx+rax*8+2968]
  003c4	0f b7 88 3c 08
	00 00		 movzx	 ecx, WORD PTR [rax+2108]
  003cb	e8 00 00 00 00	 call	 _byteswap_ushort
  003d0	48 8b 4c 24 48	 mov	 rcx, QWORD PTR cpuinfo$[rsp]
  003d5	0f b7 d0	 movzx	 edx, ax
  003d8	e8 00 00 00 00	 call	 store_hw_noswap

; 542  :               cpuinfo->index=sysblk.ptyp[i];

  003dd	48 63 44 24 40	 movsxd	 rax, DWORD PTR i$[rsp]
  003e2	48 8b 4c 24 48	 mov	 rcx, QWORD PTR cpuinfo$[rsp]
  003e7	48 8b 15 00 00
	00 00		 mov	 rdx, QWORD PTR __imp_sysblk
  003ee	0f b6 84 02 48
	0b 00 00	 movzx	 eax, BYTE PTR [rdx+rax+2888]
  003f6	88 41 04	 mov	 BYTE PTR [rcx+4], al

; 543  :               STORE_HW(cpuinfo->weight,100);

  003f9	66 b9 64 00	 mov	 cx, 100			; 00000064H
  003fd	e8 00 00 00 00	 call	 _byteswap_ushort
  00402	48 8b 4c 24 48	 mov	 rcx, QWORD PTR cpuinfo$[rsp]
  00407	48 83 c1 06	 add	 rcx, 6
  0040b	0f b7 d0	 movzx	 edx, ax
  0040e	e8 00 00 00 00	 call	 store_hw_noswap

; 544  :               STORE_DW(cpuinfo->totdispatch,tCPU[i]);

  00413	48 63 44 24 40	 movsxd	 rax, DWORD PTR i$[rsp]
  00418	48 8b 8c c4 b0
	02 00 00	 mov	 rcx, QWORD PTR tCPU$[rsp+rax*8]
  00420	e8 00 00 00 00	 call	 _byteswap_uint64
  00425	48 8b 4c 24 48	 mov	 rcx, QWORD PTR cpuinfo$[rsp]
  0042a	48 83 c1 08	 add	 rcx, 8
  0042e	48 8b d0	 mov	 rdx, rax
  00431	e8 00 00 00 00	 call	 store_dw_noswap

; 545  :               STORE_DW(cpuinfo->effdispatch, uCPU[i]);

  00436	48 63 44 24 40	 movsxd	 rax, DWORD PTR i$[rsp]
  0043b	48 8b 8c c4 b0
	00 00 00	 mov	 rcx, QWORD PTR uCPU$[rsp+rax*8]
  00443	e8 00 00 00 00	 call	 _byteswap_uint64
  00448	48 8b 4c 24 48	 mov	 rcx, QWORD PTR cpuinfo$[rsp]
  0044d	48 83 c1 10	 add	 rcx, 16
  00451	48 8b d0	 mov	 rdx, rax
  00454	e8 00 00 00 00	 call	 store_dw_noswap

; 546  :               cpuinfo->cflag=0x20;

  00459	48 8b 44 24 48	 mov	 rax, QWORD PTR cpuinfo$[rsp]
  0045e	c6 40 05 20	 mov	 BYTE PTR [rax+5], 32	; 00000020H

; 547  :               cpuinfo += 1;

  00462	48 8b 44 24 48	 mov	 rax, QWORD PTR cpuinfo$[rsp]
  00467	48 83 c0 18	 add	 rax, 24
  0046b	48 89 44 24 48	 mov	 QWORD PTR cpuinfo$[rsp], rax
$LN18@s390_diag2:

; 548  :           }

  00470	e9 f1 fe ff ff	 jmp	 $LN7@s390_diag2
$LN8@s390_diag2:

; 549  : 
; 550  : #if defined(FEATURE_PHYSICAL_DIAG204)
; 551  :         /* LPAR management */
; 552  :         /* FIXME: This section should report on the real CPUs, appearing
; 553  :          *        and transformed for reporting purposes. This should
; 554  :          *        also be properly reflected in STSI information.
; 555  :          */
; 556  :         partinfo = (DIAG204_PART*)cpuinfo;
; 557  :         memset(partinfo, 0, sizeof(DIAG204_PART));
; 558  :         partinfo->partnum = 0; /* Physical machine */
; 559  :         partinfo->virtcpu = sysblk.cpus;
; 560  :         memcpy(partinfo->partname,physical,sizeof(physical));
; 561  : 
; 562  :         /* report all emulated physical cpu's */
; 563  :         cpuinfo = (DIAG204_PART_CPU*)(partinfo + 1);
; 564  :         for(i = 0; i < sysblk.maxcpu; i++)
; 565  :           if (IS_CPU_ONLINE(i))
; 566  :           {
; 567  :               memset(cpuinfo, 0, sizeof(DIAG204_PART_CPU));
; 568  :               STORE_HW(cpuinfo->cpaddr,sysblk.regs[i]->cpuad);
; 569  :               cpuinfo->index = sysblk.ptyp[i];
; 570  :               STORE_HW(cpuinfo->weight,100);
; 571  :               STORE_DW(cpuinfo->totdispatch, tCPU[i]);
; 572  :               STORE_DW(cpuinfo->effdispatch, uCPU[i]);
; 573  :               cpuinfo += 1;
; 574  :           }
; 575  : #endif /*defined(FEATURE_PHYSICAL_DIAG204)*/
; 576  : 
; 577  :         regs->GR_L(r2) = 0;

  00475	48 63 84 24 e8
	04 00 00	 movsxd	 rax, DWORD PTR r2$[rsp]
  0047d	48 8b 8c 24 f0
	04 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00485	c7 84 c1 80 02
	00 00 00 00 00
	00		 mov	 DWORD PTR [rcx+rax*8+640], 0

; 578  : 
; 579  :         break;

  00490	e9 a6 00 00 00	 jmp	 $LN2@s390_diag2
$LN19@s390_diag2:
$LN12@s390_diag2:

; 580  : 
; 581  : #if defined(FEATURE_EXTENDED_DIAG204)
; 582  :     /* Extended subcode 5 returns the size of the data areas provided by extended subcodes 6 and 7 */
; 583  :     case 0x00010005:
; 584  :         i = sizeof(DIAG204_X_HDR) + ((sizeof(DIAG204_X_PART) + (sysblk.maxcpu * sizeof(DIAG204_X_PART_CPU))) * 2);
; 585  :         regs->GR_L(r2+1) = (i + PAGEFRAME_BYTEMASK) / PAGEFRAME_PAGESIZE;
; 586  :         regs->GR_L(r2) = 0;
; 587  : 
; 588  :         break;
; 589  : 
; 590  :     /* Provide extended information */
; 591  :     case 0x00010006:
; 592  :         /* We fall through as we do not have any secondary cpus (that we know of) */
; 593  : 
; 594  :     /* Provide extended information, including information about secondary CPUs */
; 595  :     case 0x00010007:
; 596  :         /* Program check if RMF data is not on a page boundary */
; 597  :         if ( (regs->GR_L(r1) & PAGEFRAME_BYTEMASK) != 0x000)
; 598  :             ARCH_DEP(program_interrupt) (regs, PGM_SPECIFICATION_EXCEPTION);
; 599  : 
; 600  :         /* Obtain absolute address of main storage block,
; 601  :            check protection, and set reference and change bits */
; 602  :         hdrxinfo = (DIAG204_X_HDR*)MADDR (GR_A(r1,regs), r1, regs, ACCTYPE_WRITE, regs->psw.pkey);
; 603  : 
; 604  :         /* Retrieve the TOD clock value */
; 605  :         etod_clock(regs, &ETOD, ETOD_extended);
; 606  : 
; 607  :         /* Get processor time(s) and leave out non-CPU processes and
; 608  :          * threads
; 609  :          */
; 610  :         for(i = 0; i < sysblk.maxcpu; ++i)
; 611  :         {
; 612  :             if (IS_CPU_ONLINE(i))
; 613  :             {
; 614  :                 oCPU[i] = ETOD_high64_to_usecs(ETOD.high - regs->tod_epoch - sysblk.cpucreateTOD[i]);
; 615  :                 /* Get CPU times in microseconds */
; 616  :                 if( clock_gettime(sysblk.cpuclockid[i], &cputime) == 0 )
; 617  :                 {
; 618  :                     uCPU[i] = timespec2usecs(&cputime);
; 619  :                     tCPU[i] = uCPU[i] + ETOD_high64_to_usecs(sysblk.regs[i]->waittime_accumulated
; 620  :                                               + sysblk.regs[i]->waittime ) ;
; 621  :                 }
; 622  :                 wCPU[i] = tCPU[i] - uCPU[i];
; 623  :             }
; 624  :         }
; 625  : 
; 626  :         memset(hdrxinfo, 0, sizeof(DIAG204_X_HDR));
; 627  :         hdrxinfo->numpart = 1;
; 628  : #if defined(FEATURE_PHYSICAL_DIAG204)
; 629  :         hdrxinfo->flags = DIAG204_X_PHYSICAL_PRESENT;
; 630  : #endif /*defined(FEATURE_PHYSICAL_DIAG204)*/
; 631  :         STORE_HW(hdrxinfo->physcpu,sysblk.cpus);
; 632  :         STORE_HW(hdrxinfo->offown,sizeof(DIAG204_X_HDR));
; 633  :         STORE_DW(hdrxinfo->diagstck1,ETOD.high);
; 634  :         STORE_DW(hdrxinfo->diagstck2,ETOD.low);
; 635  : 
; 636  :         /* hercules partition */
; 637  :         partxinfo = (DIAG204_X_PART*)(hdrxinfo + 1);
; 638  :         memset(partxinfo, 0, sizeof(DIAG204_X_PART));
; 639  :         partxinfo->partnum = sysblk.lparnum;    /* Hercules partition */
; 640  :         partxinfo->virtcpu = sysblk.cpus;
; 641  :         partxinfo->realcpu = hostinfo.num_procs;
; 642  :         get_lparname(partxinfo->partname);
; 643  :         get_sysname(partxinfo->cpcname);
; 644  :         get_systype(partxinfo->osname);
; 645  :         STORE_DW( partxinfo->cssize, sysblk.mainsize >> SHIFT_MEGABYTE );
; 646  :         STORE_DW( partxinfo->essize, sysblk.xpndsize >> SHIFT_MEGABYTE );
; 647  :         get_sysplex(partxinfo->gr_name);
; 648  : 
; 649  :         /* hercules cpu's */
; 650  :         cpuxinfo = (DIAG204_X_PART_CPU*)(partxinfo + 1);
; 651  :         for(i = 0; i < sysblk.maxcpu; i++)
; 652  :           if (IS_CPU_ONLINE(i))
; 653  :           {
; 654  :               memset(cpuxinfo, 0, sizeof(DIAG204_X_PART_CPU));
; 655  :               STORE_HW(cpuxinfo->cpaddr,sysblk.regs[i]->cpuad);
; 656  :               cpuxinfo->index = sysblk.ptyp[i];
; 657  :               STORE_HW(cpuxinfo->weight,100);
; 658  : 
; 659  :               STORE_DW(cpuxinfo->totdispatch, tCPU[i]);
; 660  :               STORE_DW(cpuxinfo->effdispatch, uCPU[i]);
; 661  : 
; 662  :               STORE_HW(cpuxinfo->minweight,1000);
; 663  :               STORE_HW(cpuxinfo->curweight,1000);
; 664  :               STORE_HW(cpuxinfo->maxweight,1000);
; 665  : 
; 666  :               STORE_DW(cpuxinfo->onlinetime, oCPU[i]);
; 667  :               STORE_DW(cpuxinfo->waittime,   wCPU[i]);
; 668  : 
; 669  :               STORE_HW(cpuxinfo->pmaweight,1000);
; 670  :               STORE_HW(cpuxinfo->polarweight,1000);
; 671  :               cpuxinfo->cflag=0x20;
; 672  : 
; 673  :               cpuxinfo += 1;
; 674  :           }
; 675  : 
; 676  : 
; 677  : #if defined(FEATURE_PHYSICAL_DIAG204)
; 678  :         /* LPAR management */
; 679  :         /* FIXME: This section should report on the real CPUs, appearing
; 680  :          *        and transformed for reporting purposes. This should
; 681  :          *        also be properly reflected in STSI information.
; 682  :          */
; 683  :         partxinfo = (DIAG204_X_PART*)cpuxinfo;
; 684  :         memset(partxinfo, 0, sizeof(DIAG204_X_PART));
; 685  :         partxinfo->partnum = 0; /* Physical machine */
; 686  :         partxinfo->virtcpu = sysblk.cpus;
; 687  :         partxinfo->realcpu = hostinfo.num_procs;
; 688  :         memcpy(partxinfo->partname,physical,sizeof(physical));
; 689  : 
; 690  :         /* report all emulated physical cpu's */
; 691  :         cpuxinfo = (DIAG204_PART_CPU*)(partinfo + 1);
; 692  :         for(i = 0; i < sysblk.maxcpu; i++)
; 693  :           if (IS_CPU_ONLINE(i))
; 694  :           {
; 695  :               memset(cpuxinfo, 0, sizeof(DIAG204_X_PART_CPU));
; 696  :               STORE_HW(cpuxinfo->cpaddr,sysblk.regs[i]->cpuad);
; 697  :               cpuxinfo->index = sysblk.ptyp[i];
; 698  :               STORE_HW(cpuxinfo->weight,100);
; 699  : 
; 700  :               STORE_DW(cpuxinfo->totdispatch, tCPU[i]);
; 701  :               STORE_DW(cpuxinfo->effdispatch, uCPU[i]);
; 702  : 
; 703  :               STORE_HW(cpuxinfo->minweight,1000);
; 704  :               STORE_HW(cpuxinfo->curweight,1000);
; 705  :               STORE_HW(cpuxinfo->maxweight,1000);
; 706  : 
; 707  :               STORE_DW(cpuxinfo->onlinetime, oCPU[i]);
; 708  :               STORE_DW(cpuxinfo->waittime,   wCPU[i]);
; 709  : 
; 710  :               STORE_HW(cpuxinfo->pmaweight,1000);
; 711  :               STORE_HW(cpuxinfo->polarweight,1000);
; 712  : 
; 713  :               cpuxinfo += 1;
; 714  :           }
; 715  : #endif /*defined(FEATURE_PHYSICAL_DIAG204)*/
; 716  : 
; 717  :         regs->GR_L(r2) = 0;
; 718  : 
; 719  :         break;
; 720  : #endif /*defined(FEATURE_EXTENDED_DIAG204)*/
; 721  : 
; 722  :     default:
; 723  :         PTT_ERR("*DIAG204",regs->GR_L(r1),regs->GR_L(r2),regs->psw.IA_L);

  00495	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_pttclass
  0049c	48 8b 00	 mov	 rax, QWORD PTR [rax]
  0049f	48 83 e0 10	 and	 rax, 16
  004a3	48 85 c0	 test	 rax, rax
  004a6	74 6e		 je	 SHORT $LN20@s390_diag2
  004a8	48 8b 84 24 f0
	04 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  004b0	8b 80 88 00 00
	00		 mov	 eax, DWORD PTR [rax+136]
  004b6	48 63 8c 24 e8
	04 00 00	 movsxd	 rcx, DWORD PTR r2$[rsp]
  004be	48 8b 94 24 f0
	04 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  004c6	8b 8c ca 80 02
	00 00		 mov	 ecx, DWORD PTR [rdx+rcx*8+640]
  004cd	48 63 94 24 e0
	04 00 00	 movsxd	 rdx, DWORD PTR r1$[rsp]
  004d5	48 8b bc 24 f0
	04 00 00	 mov	 rdi, QWORD PTR regs$[rsp]
  004dd	8b 94 d7 80 02
	00 00		 mov	 edx, DWORD PTR [rdi+rdx*8+640]
  004e4	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR [rsp+48], 0
  004ed	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  004f2	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG179885
  004f9	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  004fe	44 8b c9	 mov	 r9d, ecx
  00501	44 8b c2	 mov	 r8d, edx
  00504	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG179886
  0050b	b9 10 00 00 00	 mov	 ecx, 16
  00510	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ptt_pthread_trace
$LN20@s390_diag2:
  00516	33 c0		 xor	 eax, eax
  00518	85 c0		 test	 eax, eax
  0051a	0f 85 75 ff ff
	ff		 jne	 $LN12@s390_diag2

; 724  :         regs->GR_L(r2) = 4;

  00520	48 63 84 24 e8
	04 00 00	 movsxd	 rax, DWORD PTR r2$[rsp]
  00528	48 8b 8c 24 f0
	04 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00530	c7 84 c1 80 02
	00 00 04 00 00
	00		 mov	 DWORD PTR [rcx+rax*8+640], 4
$LN2@s390_diag2:

; 725  : 
; 726  :     } /*switch(regs->GR_L(r2))*/
; 727  : 
; 728  : } /* end function diag204_call */

  0053b	48 8b 8c 24 b0
	04 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  00543	48 33 cc	 xor	 rcx, rsp
  00546	e8 00 00 00 00	 call	 __security_check_cookie
  0054b	48 81 c4 c8 04
	00 00		 add	 rsp, 1224		; 000004c8H
  00552	5f		 pop	 rdi
  00553	5e		 pop	 rsi
  00554	c3		 ret	 0
s390_diag204_call ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\diagmssf.c
_TEXT	SEGMENT
chpid$1 = 64
i$ = 68
offset$ = 72
spccb_absolute_addr$ = 76
i$2 = 80
spccb$ = 88
spccbconfig$ = 96
spccblen$ = 104
spccbchp$ = 112
tv94 = 120
tv178 = 124
spccbcpu$ = 128
dev$ = 136
mask$3 = 144
mssf_command$ = 152
tv545 = 156
tv554 = 160
tv289 = 164
tv563 = 168
tv307 = 172
tv572 = 176
tv325 = 180
tv276 = 184
tv294 = 192
tv312 = 200
r1$ = 224
r2$ = 232
regs$ = 240
s390_mssf_call PROC

; 275  : {

$LN42:
  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00009	89 4c 24 08	 mov	 DWORD PTR [rsp+8], ecx
  0000d	57		 push	 rdi
  0000e	48 81 ec d0 00
	00 00		 sub	 rsp, 208		; 000000d0H

; 276  : U32     spccb_absolute_addr;            /* Absolute addr of SPCCB    */
; 277  : U32     mssf_command;                   /* MSSF command word         */
; 278  : U32               spccblen;            /* Length of SPCCB            */
; 279  : SPCCB_HEADER      *spccb;              /* -> SPCCB header            */
; 280  : SPCCB_CONFIG_INFO *spccbconfig;        /* -> SPCCB CONFIG info       */
; 281  : SPCCB_CPU_INFO    *spccbcpu;           /* -> SPCCB CPU information   */
; 282  : SPCCB_CHP_STATUS  *spccbchp;           /* -> SPCCB channel path info */
; 283  : U16               offset;              /* Offset from start of SPCCB */
; 284  : int               i;                   /* loop counter               */
; 285  : DEVBLK            *dev;                /* Device block pointer       */
; 286  : 
; 287  :     /* R1 contains the real address of the SPCCB */
; 288  :     spccb_absolute_addr = APPLY_PREFIXING (regs->GR_L(r1), regs->PX);

  00015	48 63 84 24 e0
	00 00 00	 movsxd	 rax, DWORD PTR r1$[rsp]
  0001d	48 8b 8c 24 f0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00025	8b 84 c1 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax*8+640]
  0002c	48 25 00 f0 ff
	ff		 and	 rax, -4096		; fffffffffffff000H
  00032	48 85 c0	 test	 rax, rax
  00035	74 4a		 je	 SHORT $LN40@s390_mssf_
  00037	48 63 84 24 e0
	00 00 00	 movsxd	 rax, DWORD PTR r1$[rsp]
  0003f	48 8b 8c 24 f0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00047	8b 84 c1 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax*8+640]
  0004e	48 25 00 f0 ff
	ff		 and	 rax, -4096		; fffffffffffff000H
  00054	48 8b 8c 24 f0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0005c	8b 49 70	 mov	 ecx, DWORD PTR [rcx+112]
  0005f	48 3b c1	 cmp	 rax, rcx
  00062	74 1d		 je	 SHORT $LN40@s390_mssf_
  00064	48 63 84 24 e0
	00 00 00	 movsxd	 rax, DWORD PTR r1$[rsp]
  0006c	48 8b 8c 24 f0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00074	8b 84 c1 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax*8+640]
  0007b	89 44 24 78	 mov	 DWORD PTR tv94[rsp], eax
  0007f	eb 28		 jmp	 SHORT $LN41@s390_mssf_
$LN40@s390_mssf_:
  00081	48 63 84 24 e0
	00 00 00	 movsxd	 rax, DWORD PTR r1$[rsp]
  00089	48 8b 8c 24 f0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00091	48 8b 94 24 f0
	00 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  00099	8b 52 70	 mov	 edx, DWORD PTR [rdx+112]
  0009c	8b 84 c1 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax*8+640]
  000a3	33 c2		 xor	 eax, edx
  000a5	89 44 24 78	 mov	 DWORD PTR tv94[rsp], eax
$LN41@s390_mssf_:
  000a9	8b 44 24 78	 mov	 eax, DWORD PTR tv94[rsp]
  000ad	89 44 24 4c	 mov	 DWORD PTR spccb_absolute_addr$[rsp], eax

; 289  : 
; 290  :     /* R2 contains the service-processor-command word */
; 291  :     mssf_command = regs->GR_L(r2);

  000b1	48 63 84 24 e8
	00 00 00	 movsxd	 rax, DWORD PTR r2$[rsp]
  000b9	48 8b 8c 24 f0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  000c1	8b 84 c1 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax*8+640]
  000c8	89 84 24 98 00
	00 00		 mov	 DWORD PTR mssf_command$[rsp], eax

; 292  : 
; 293  :     /* Program check if SPCCB is not on a doubleword boundary */
; 294  :     if ( spccb_absolute_addr & 0x00000007 )

  000cf	8b 44 24 4c	 mov	 eax, DWORD PTR spccb_absolute_addr$[rsp]
  000d3	83 e0 07	 and	 eax, 7
  000d6	85 c0		 test	 eax, eax
  000d8	74 12		 je	 SHORT $LN22@s390_mssf_

; 295  :         ARCH_DEP(program_interrupt) (regs, PGM_SPECIFICATION_EXCEPTION);

  000da	ba 06 00 00 00	 mov	 edx, 6
  000df	48 8b 8c 24 f0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  000e7	e8 00 00 00 00	 call	 s390_program_interrupt
$LN22@s390_mssf_:

; 296  : 
; 297  :     /* Program check if SPCCB is outside main storage */
; 298  :     if ( spccb_absolute_addr > regs->mainlim )

  000ec	8b 44 24 4c	 mov	 eax, DWORD PTR spccb_absolute_addr$[rsp]
  000f0	48 8b 8c 24 f0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  000f8	48 3b 81 58 08
	00 00		 cmp	 rax, QWORD PTR [rcx+2136]
  000ff	76 12		 jbe	 SHORT $LN23@s390_mssf_

; 299  :         ARCH_DEP(program_interrupt) (regs, PGM_ADDRESSING_EXCEPTION);

  00101	ba 05 00 00 00	 mov	 edx, 5
  00106	48 8b 8c 24 f0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0010e	e8 00 00 00 00	 call	 s390_program_interrupt
$LN23@s390_mssf_:

; 300  : 
; 301  : //  /*debug*/logmsg("MSSF call %8.8X SPCCB=%8.8X\n",
; 302  : //  /*debug*/       mssf_command, spccb_absolute_addr);
; 303  : 
; 304  :     /* Point to Service Processor Command Control Block */
; 305  :     spccb = (SPCCB_HEADER*)(regs->mainstor + spccb_absolute_addr);

  00113	8b 44 24 4c	 mov	 eax, DWORD PTR spccb_absolute_addr$[rsp]
  00117	48 8b 8c 24 f0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0011f	48 03 81 48 08
	00 00		 add	 rax, QWORD PTR [rcx+2120]
  00126	48 89 44 24 58	 mov	 QWORD PTR spccb$[rsp], rax

; 306  : 
; 307  :     /* Load SPCCB length from header */
; 308  :     FETCH_HW(spccblen,spccb->length);

  0012b	48 8b 44 24 58	 mov	 rax, QWORD PTR spccb$[rsp]
  00130	48 8b c8	 mov	 rcx, rax
  00133	e8 00 00 00 00	 call	 fetch_hw_noswap
  00138	0f b7 c8	 movzx	 ecx, ax
  0013b	e8 00 00 00 00	 call	 _byteswap_ushort
  00140	0f b7 c0	 movzx	 eax, ax
  00143	89 44 24 68	 mov	 DWORD PTR spccblen$[rsp], eax

; 309  : 
; 310  :     /* Mark page referenced */
; 311  :     ARCH_DEP( or_storage_key )( spccb_absolute_addr, STORKEY_REF );

  00147	8b 44 24 4c	 mov	 eax, DWORD PTR spccb_absolute_addr$[rsp]
  0014b	b2 04		 mov	 dl, 4
  0014d	8b c8		 mov	 ecx, eax
  0014f	e8 00 00 00 00	 call	 s390_or_storage_key

; 312  : 
; 313  :     /* Program check if end of SPCCB falls outside main storage */
; 314  :     if ( sysblk.mainsize - spccblen < spccb_absolute_addr )

  00154	8b 44 24 68	 mov	 eax, DWORD PTR spccblen$[rsp]
  00158	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  0015f	48 8b 89 90 00
	00 00		 mov	 rcx, QWORD PTR [rcx+144]
  00166	48 2b c8	 sub	 rcx, rax
  00169	48 8b c1	 mov	 rax, rcx
  0016c	8b 4c 24 4c	 mov	 ecx, DWORD PTR spccb_absolute_addr$[rsp]
  00170	48 3b c1	 cmp	 rax, rcx
  00173	73 12		 jae	 SHORT $LN24@s390_mssf_

; 315  :         ARCH_DEP(program_interrupt) (regs, PGM_ADDRESSING_EXCEPTION);

  00175	ba 05 00 00 00	 mov	 edx, 5
  0017a	48 8b 8c 24 f0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00182	e8 00 00 00 00	 call	 s390_program_interrupt
$LN24@s390_mssf_:

; 316  : 
; 317  :     /* Obtain the interrupt lock */
; 318  :     OBTAIN_INTLOCK(regs);

  00187	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG179813
  0018e	48 8b 8c 24 f0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00196	e8 00 00 00 00	 call	 Obtain_Interrupt_Lock

; 319  : 
; 320  :     /* If a service signal is pending then we cannot process the request */
; 321  :     if( IS_IC_SERVSIG && (sysblk.servparm & SERVSIG_ADDR)) {

  0019b	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  001a2	8b 80 a0 12 00
	00		 mov	 eax, DWORD PTR [rax+4768]
  001a8	25 00 02 00 00	 and	 eax, 512		; 00000200H
  001ad	85 c0		 test	 eax, eax
  001af	74 32		 je	 SHORT $LN25@s390_mssf_
  001b1	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  001b8	8b 80 90 12 00
	00		 mov	 eax, DWORD PTR [rax+4752]
  001be	83 e0 f8	 and	 eax, -8			; fffffff8H
  001c1	85 c0		 test	 eax, eax
  001c3	74 1e		 je	 SHORT $LN25@s390_mssf_

; 322  :         RELEASE_INTLOCK(regs);

  001c5	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG179815
  001cc	48 8b 8c 24 f0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  001d4	e8 00 00 00 00	 call	 Release_Interrupt_Lock

; 323  :         return 2;   /* Service Processor Busy */

  001d9	b8 02 00 00 00	 mov	 eax, 2
  001de	e9 27 07 00 00	 jmp	 $LN1@s390_mssf_
$LN25@s390_mssf_:

; 324  :     }
; 325  : 
; 326  :     if( spccb_absolute_addr & 0x000007FF ) {

  001e3	8b 44 24 4c	 mov	 eax, DWORD PTR spccb_absolute_addr$[rsp]
  001e7	25 ff 07 00 00	 and	 eax, 2047		; 000007ffH
  001ec	85 c0		 test	 eax, eax
  001ee	74 2b		 je	 SHORT $LN26@s390_mssf_

; 327  :         spccb->resp[0] = SPCCB_REAS_NOT2KALIGN;

  001f0	b8 01 00 00 00	 mov	 eax, 1
  001f5	48 6b c0 00	 imul	 rax, rax, 0
  001f9	48 8b 4c 24 58	 mov	 rcx, QWORD PTR spccb$[rsp]
  001fe	c6 44 01 06 01	 mov	 BYTE PTR [rcx+rax+6], 1

; 328  :         spccb->resp[1] = SPCCB_RESP_NOT2KALIGN;

  00203	b8 01 00 00 00	 mov	 eax, 1
  00208	48 6b c0 01	 imul	 rax, rax, 1
  0020c	48 8b 4c 24 58	 mov	 rcx, QWORD PTR spccb$[rsp]
  00211	c6 44 01 06 00	 mov	 BYTE PTR [rcx+rax+6], 0

; 329  :     } else

  00216	e9 60 05 00 00	 jmp	 $LN27@s390_mssf_
$LN26@s390_mssf_:

; 330  :         /* Test MSSF command word */
; 331  :         switch (mssf_command) {

  0021b	8b 84 24 98 00
	00 00		 mov	 eax, DWORD PTR mssf_command$[rsp]
  00222	89 44 24 7c	 mov	 DWORD PTR tv178[rsp], eax
  00226	81 7c 24 7c 01
	00 02 00	 cmp	 DWORD PTR tv178[rsp], 131073 ; 00020001H
  0022e	74 13		 je	 SHORT $LN28@s390_mssf_
  00230	81 7c 24 7c 01
	00 03 00	 cmp	 DWORD PTR tv178[rsp], 196609 ; 00030001H
  00238	0f 84 db 01 00
	00		 je	 $LN30@s390_mssf_
  0023e	e9 87 04 00 00	 jmp	 $LN33@s390_mssf_
$LN28@s390_mssf_:

; 332  : 
; 333  :         case MSSF_READ_CONFIG_INFO:
; 334  : 
; 335  :             /* Set response code X'01F0' if SPCCB length
; 336  :                is insufficient to contain CONFIG info */
; 337  :             if ( spccblen < 64 )

  00243	83 7c 24 68 40	 cmp	 DWORD PTR spccblen$[rsp], 64 ; 00000040H
  00248	73 2b		 jae	 SHORT $LN29@s390_mssf_

; 338  :             {
; 339  :                 spccb->resp[0] = SPCCB_REAS_BADLENGTH;

  0024a	b8 01 00 00 00	 mov	 eax, 1
  0024f	48 6b c0 00	 imul	 rax, rax, 0
  00253	48 8b 4c 24 58	 mov	 rcx, QWORD PTR spccb$[rsp]
  00258	c6 44 01 06 01	 mov	 BYTE PTR [rcx+rax+6], 1

; 340  :                 spccb->resp[1] = SPCCB_RESP_BADLENGTH;

  0025d	b8 01 00 00 00	 mov	 eax, 1
  00262	48 6b c0 01	 imul	 rax, rax, 1
  00266	48 8b 4c 24 58	 mov	 rcx, QWORD PTR spccb$[rsp]
  0026b	c6 44 01 06 f0	 mov	 BYTE PTR [rcx+rax+6], 240 ; 000000f0H

; 341  :             break;

  00270	e9 06 05 00 00	 jmp	 $LN2@s390_mssf_
$LN29@s390_mssf_:

; 342  :             }
; 343  : 
; 344  :             /* Point to SPCCB data area following SPCCB header */
; 345  :             spccbconfig = (SPCCB_CONFIG_INFO*)(spccb+1);

  00275	48 8b 44 24 58	 mov	 rax, QWORD PTR spccb$[rsp]
  0027a	48 83 c0 08	 add	 rax, 8
  0027e	48 89 44 24 60	 mov	 QWORD PTR spccbconfig$[rsp], rax

; 346  :             memset (spccbconfig, 0, sizeof(SPCCB_CONFIG_INFO));

  00283	48 8b 7c 24 60	 mov	 rdi, QWORD PTR spccbconfig$[rsp]
  00288	33 c0		 xor	 eax, eax
  0028a	b9 18 00 00 00	 mov	 ecx, 24
  0028f	f3 aa		 rep stosb

; 347  : 
; 348  :             /* Set main storage size in SPCCB */
; 349  :             spccbconfig->totstori = sysblk.mainsize >> 20;

  00291	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00298	48 8b 80 90 00
	00 00		 mov	 rax, QWORD PTR [rax+144]
  0029f	48 c1 e8 14	 shr	 rax, 20
  002a3	48 8b 4c 24 60	 mov	 rcx, QWORD PTR spccbconfig$[rsp]
  002a8	88 01		 mov	 BYTE PTR [rcx], al

; 350  :             spccbconfig->storisiz = 1;

  002aa	48 8b 44 24 60	 mov	 rax, QWORD PTR spccbconfig$[rsp]
  002af	c6 40 01 01	 mov	 BYTE PTR [rax+1], 1

; 351  :             spccbconfig->hex04 = 0x04;

  002b3	48 8b 44 24 60	 mov	 rax, QWORD PTR spccbconfig$[rsp]
  002b8	c6 40 02 04	 mov	 BYTE PTR [rax+2], 4

; 352  :             spccbconfig->hex01 = 0x01;

  002bc	48 8b 44 24 60	 mov	 rax, QWORD PTR spccbconfig$[rsp]
  002c1	c6 40 03 01	 mov	 BYTE PTR [rax+3], 1

; 353  : 
; 354  :             /* Set CPU array count and offset in SPCCB */
; 355  :             STORE_HW(spccbconfig->toticpu,sysblk.maxcpu);

  002c5	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  002cc	0f b7 88 00 01
	00 00		 movzx	 ecx, WORD PTR [rax+256]
  002d3	e8 00 00 00 00	 call	 _byteswap_ushort
  002d8	48 8b 4c 24 60	 mov	 rcx, QWORD PTR spccbconfig$[rsp]
  002dd	48 83 c1 08	 add	 rcx, 8
  002e1	0f b7 d0	 movzx	 edx, ax
  002e4	e8 00 00 00 00	 call	 store_hw_noswap

; 356  :             offset = sizeof(SPCCB_HEADER) + sizeof(SPCCB_CONFIG_INFO);

  002e9	b8 20 00 00 00	 mov	 eax, 32			; 00000020H
  002ee	66 89 44 24 48	 mov	 WORD PTR offset$[rsp], ax

; 357  :             STORE_HW(spccbconfig->officpu,offset);

  002f3	0f b7 4c 24 48	 movzx	 ecx, WORD PTR offset$[rsp]
  002f8	e8 00 00 00 00	 call	 _byteswap_ushort
  002fd	48 8b 4c 24 60	 mov	 rcx, QWORD PTR spccbconfig$[rsp]
  00302	48 83 c1 0a	 add	 rcx, 10
  00306	0f b7 d0	 movzx	 edx, ax
  00309	e8 00 00 00 00	 call	 store_hw_noswap

; 358  : 
; 359  :             /* Set HSA array count and offset in SPCCB */
; 360  :             STORE_HW(spccbconfig->tothsa,0);

  0030e	33 c9		 xor	 ecx, ecx
  00310	e8 00 00 00 00	 call	 _byteswap_ushort
  00315	48 8b 4c 24 60	 mov	 rcx, QWORD PTR spccbconfig$[rsp]
  0031a	48 83 c1 0c	 add	 rcx, 12
  0031e	0f b7 d0	 movzx	 edx, ax
  00321	e8 00 00 00 00	 call	 store_hw_noswap

; 361  :             offset += (U16)(sizeof(SPCCB_CPU_INFO) * sysblk.maxcpu);

  00326	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  0032d	48 63 80 00 01
	00 00		 movsxd	 rax, DWORD PTR [rax+256]
  00334	48 d1 e0	 shl	 rax, 1
  00337	0f b7 c0	 movzx	 eax, ax
  0033a	0f b7 4c 24 48	 movzx	 ecx, WORD PTR offset$[rsp]
  0033f	03 c8		 add	 ecx, eax
  00341	8b c1		 mov	 eax, ecx
  00343	66 89 44 24 48	 mov	 WORD PTR offset$[rsp], ax

; 362  :             STORE_HW(spccbconfig->offhsa,offset);

  00348	0f b7 4c 24 48	 movzx	 ecx, WORD PTR offset$[rsp]
  0034d	e8 00 00 00 00	 call	 _byteswap_ushort
  00352	48 8b 4c 24 60	 mov	 rcx, QWORD PTR spccbconfig$[rsp]
  00357	48 83 c1 0e	 add	 rcx, 14
  0035b	0f b7 d0	 movzx	 edx, ax
  0035e	e8 00 00 00 00	 call	 store_hw_noswap

; 363  : 
; 364  :             /* Move IPL load parameter to SPCCB */
; 365  :             get_loadparm (spccbconfig->loadparm);

  00363	48 8b 44 24 60	 mov	 rax, QWORD PTR spccbconfig$[rsp]
  00368	48 83 c0 10	 add	 rax, 16
  0036c	48 8b c8	 mov	 rcx, rax
  0036f	e8 00 00 00 00	 call	 get_loadparm

; 366  : 
; 367  :             /* Build the CPU information array after the SCP info */
; 368  :             spccbcpu = (SPCCB_CPU_INFO*)(spccbconfig+1);

  00374	48 8b 44 24 60	 mov	 rax, QWORD PTR spccbconfig$[rsp]
  00379	48 83 c0 18	 add	 rax, 24
  0037d	48 89 84 24 80
	00 00 00	 mov	 QWORD PTR spccbcpu$[rsp], rax

; 369  :             for (i = 0; i < sysblk.maxcpu; i++, spccbcpu++)

  00385	c7 44 24 44 00
	00 00 00	 mov	 DWORD PTR i$[rsp], 0
  0038d	eb 1e		 jmp	 SHORT $LN6@s390_mssf_
$LN4@s390_mssf_:
  0038f	8b 44 24 44	 mov	 eax, DWORD PTR i$[rsp]
  00393	ff c0		 inc	 eax
  00395	89 44 24 44	 mov	 DWORD PTR i$[rsp], eax
  00399	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR spccbcpu$[rsp]
  003a1	48 83 c0 02	 add	 rax, 2
  003a5	48 89 84 24 80
	00 00 00	 mov	 QWORD PTR spccbcpu$[rsp], rax
$LN6@s390_mssf_:
  003ad	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  003b4	8b 80 00 01 00
	00		 mov	 eax, DWORD PTR [rax+256]
  003ba	39 44 24 44	 cmp	 DWORD PTR i$[rsp], eax
  003be	7d 2e		 jge	 SHORT $LN5@s390_mssf_

; 370  :             {
; 371  :                 memset( spccbcpu, 0, sizeof(SPCCB_CPU_INFO) );

  003c0	48 8b bc 24 80
	00 00 00	 mov	 rdi, QWORD PTR spccbcpu$[rsp]
  003c8	33 c0		 xor	 eax, eax
  003ca	b9 02 00 00 00	 mov	 ecx, 2
  003cf	f3 aa		 rep stosb

; 372  :                 spccbcpu->cpuaddr = i;

  003d1	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR spccbcpu$[rsp]
  003d9	0f b6 4c 24 44	 movzx	 ecx, BYTE PTR i$[rsp]
  003de	88 08		 mov	 BYTE PTR [rax], cl

; 373  :                 spccbcpu->todid = 0;

  003e0	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR spccbcpu$[rsp]
  003e8	c6 40 01 00	 mov	 BYTE PTR [rax+1], 0

; 374  :             }

  003ec	eb a1		 jmp	 SHORT $LN4@s390_mssf_
$LN5@s390_mssf_:

; 375  : 
; 376  :             /* Set response code X'0010' in SPCCB header */
; 377  :             spccb->resp[0] = SPCCB_REAS_COMPLETE;

  003ee	b8 01 00 00 00	 mov	 eax, 1
  003f3	48 6b c0 00	 imul	 rax, rax, 0
  003f7	48 8b 4c 24 58	 mov	 rcx, QWORD PTR spccb$[rsp]
  003fc	c6 44 01 06 00	 mov	 BYTE PTR [rcx+rax+6], 0

; 378  :             spccb->resp[1] = SPCCB_RESP_COMPLETE;

  00401	b8 01 00 00 00	 mov	 eax, 1
  00406	48 6b c0 01	 imul	 rax, rax, 1
  0040a	48 8b 4c 24 58	 mov	 rcx, QWORD PTR spccb$[rsp]
  0040f	c6 44 01 06 10	 mov	 BYTE PTR [rcx+rax+6], 16

; 379  : 
; 380  :             break;

  00414	e9 62 03 00 00	 jmp	 $LN2@s390_mssf_
$LN30@s390_mssf_:

; 381  : 
; 382  :         case MSSF_READ_CHP_STATUS:
; 383  : 
; 384  :             /* Set response code X'0300' if SPCCB length
; 385  :                is insufficient to contain channel path info */
; 386  :             if ( spccblen < sizeof(SPCCB_HEADER) + sizeof(SPCCB_CHP_STATUS))

  00419	8b 44 24 68	 mov	 eax, DWORD PTR spccblen$[rsp]
  0041d	48 3d 00 01 00
	00		 cmp	 rax, 256		; 00000100H
  00423	73 2b		 jae	 SHORT $LN31@s390_mssf_

; 387  :             {
; 388  :                 spccb->resp[0] = SPCCB_REAS_BADLENGTH;

  00425	b8 01 00 00 00	 mov	 eax, 1
  0042a	48 6b c0 00	 imul	 rax, rax, 0
  0042e	48 8b 4c 24 58	 mov	 rcx, QWORD PTR spccb$[rsp]
  00433	c6 44 01 06 01	 mov	 BYTE PTR [rcx+rax+6], 1

; 389  :                 spccb->resp[1] = SPCCB_RESP_BADLENGTH;

  00438	b8 01 00 00 00	 mov	 eax, 1
  0043d	48 6b c0 01	 imul	 rax, rax, 1
  00441	48 8b 4c 24 58	 mov	 rcx, QWORD PTR spccb$[rsp]
  00446	c6 44 01 06 f0	 mov	 BYTE PTR [rcx+rax+6], 240 ; 000000f0H

; 390  :                 break;

  0044b	e9 2b 03 00 00	 jmp	 $LN2@s390_mssf_
$LN31@s390_mssf_:

; 391  :             }
; 392  : 
; 393  :             /* Point to SPCCB data area following SPCCB header */
; 394  :             spccbchp = (SPCCB_CHP_STATUS*)(spccb+1);

  00450	48 8b 44 24 58	 mov	 rax, QWORD PTR spccb$[rsp]
  00455	48 83 c0 08	 add	 rax, 8
  00459	48 89 44 24 70	 mov	 QWORD PTR spccbchp$[rsp], rax

; 395  :             memset( spccbchp, 0, sizeof(SPCCB_CHP_STATUS) );

  0045e	48 8b 7c 24 70	 mov	 rdi, QWORD PTR spccbchp$[rsp]
  00463	33 c0		 xor	 eax, eax
  00465	b9 f8 00 00 00	 mov	 ecx, 248		; 000000f8H
  0046a	f3 aa		 rep stosb

; 396  : 
; 397  :             /* Identify CHPIDs used */
; 398  :             for (dev = sysblk.firstdev; dev != NULL; dev = dev->nextdev)

  0046c	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00473	48 8b 80 c0 11
	00 00		 mov	 rax, QWORD PTR [rax+4544]
  0047a	48 89 84 24 88
	00 00 00	 mov	 QWORD PTR dev$[rsp], rax
  00482	eb 14		 jmp	 SHORT $LN9@s390_mssf_
$LN7@s390_mssf_:
  00484	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  0048c	48 8b 40 30	 mov	 rax, QWORD PTR [rax+48]
  00490	48 89 84 24 88
	00 00 00	 mov	 QWORD PTR dev$[rsp], rax
$LN9@s390_mssf_:
  00498	48 83 bc 24 88
	00 00 00 00	 cmp	 QWORD PTR dev$[rsp], 0
  004a1	0f 84 f8 01 00
	00		 je	 $LN8@s390_mssf_

; 399  :             {
; 400  :                 for (i = 0; i < 8; i++)

  004a7	c7 44 24 44 00
	00 00 00	 mov	 DWORD PTR i$[rsp], 0
  004af	eb 0a		 jmp	 SHORT $LN12@s390_mssf_
$LN10@s390_mssf_:
  004b1	8b 44 24 44	 mov	 eax, DWORD PTR i$[rsp]
  004b5	ff c0		 inc	 eax
  004b7	89 44 24 44	 mov	 DWORD PTR i$[rsp], eax
$LN12@s390_mssf_:
  004bb	83 7c 24 44 08	 cmp	 DWORD PTR i$[rsp], 8
  004c0	0f 8d d4 01 00
	00		 jge	 $LN11@s390_mssf_

; 401  :                 {
; 402  :                     if( ((0x80 >> i) & dev->pmcw.pim) )

  004c6	8b 44 24 44	 mov	 eax, DWORD PTR i$[rsp]
  004ca	b9 80 00 00 00	 mov	 ecx, 128		; 00000080H
  004cf	89 8c 24 9c 00
	00 00		 mov	 DWORD PTR tv545[rsp], ecx
  004d6	0f b6 c8	 movzx	 ecx, al
  004d9	8b 84 24 9c 00
	00 00		 mov	 eax, DWORD PTR tv545[rsp]
  004e0	d3 f8		 sar	 eax, cl
  004e2	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  004ea	0f b6 89 f7 02
	00 00		 movzx	 ecx, BYTE PTR [rcx+759]
  004f1	23 c1		 and	 eax, ecx
  004f3	85 c0		 test	 eax, eax
  004f5	0f 84 9a 01 00
	00		 je	 $LN32@s390_mssf_

; 403  :                     {
; 404  :                     BYTE chpid;
; 405  :                         chpid = dev->pmcw.chpid[i];

  004fb	48 63 44 24 44	 movsxd	 rax, DWORD PTR i$[rsp]
  00500	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  00508	0f b6 84 01 fc
	02 00 00	 movzx	 eax, BYTE PTR [rcx+rax+764]
  00510	88 44 24 40	 mov	 BYTE PTR chpid$1[rsp], al

; 406  :                         spccbchp->installed[chpid / 8] |= 0x80 >> (chpid % 8);

  00514	0f b6 44 24 40	 movzx	 eax, BYTE PTR chpid$1[rsp]
  00519	99		 cdq
  0051a	83 e2 07	 and	 edx, 7
  0051d	03 c2		 add	 eax, edx
  0051f	c1 f8 03	 sar	 eax, 3
  00522	48 98		 cdqe
  00524	48 89 84 24 b8
	00 00 00	 mov	 QWORD PTR tv276[rsp], rax
  0052c	0f b6 4c 24 40	 movzx	 ecx, BYTE PTR chpid$1[rsp]
  00531	8b c1		 mov	 eax, ecx
  00533	99		 cdq
  00534	83 e2 07	 and	 edx, 7
  00537	03 c2		 add	 eax, edx
  00539	83 e0 07	 and	 eax, 7
  0053c	2b c2		 sub	 eax, edx
  0053e	b9 80 00 00 00	 mov	 ecx, 128		; 00000080H
  00543	89 8c 24 a0 00
	00 00		 mov	 DWORD PTR tv554[rsp], ecx
  0054a	0f b6 c8	 movzx	 ecx, al
  0054d	8b 84 24 a0 00
	00 00		 mov	 eax, DWORD PTR tv554[rsp]
  00554	d3 f8		 sar	 eax, cl
  00556	48 8b 4c 24 70	 mov	 rcx, QWORD PTR spccbchp$[rsp]
  0055b	48 8b 94 24 b8
	00 00 00	 mov	 rdx, QWORD PTR tv276[rsp]
  00563	0f b6 0c 11	 movzx	 ecx, BYTE PTR [rcx+rdx]
  00567	0b c8		 or	 ecx, eax
  00569	8b c1		 mov	 eax, ecx
  0056b	89 84 24 a4 00
	00 00		 mov	 DWORD PTR tv289[rsp], eax
  00572	0f b6 4c 24 40	 movzx	 ecx, BYTE PTR chpid$1[rsp]
  00577	8b c1		 mov	 eax, ecx
  00579	99		 cdq
  0057a	83 e2 07	 and	 edx, 7
  0057d	03 c2		 add	 eax, edx
  0057f	c1 f8 03	 sar	 eax, 3
  00582	48 98		 cdqe
  00584	48 8b 4c 24 70	 mov	 rcx, QWORD PTR spccbchp$[rsp]
  00589	8b 94 24 a4 00
	00 00		 mov	 edx, DWORD PTR tv289[rsp]
  00590	88 14 01	 mov	 BYTE PTR [rcx+rax], dl

; 407  :                         spccbchp->assigned[chpid / 8] |= 0x80 >> (chpid % 8);

  00593	0f b6 44 24 40	 movzx	 eax, BYTE PTR chpid$1[rsp]
  00598	99		 cdq
  00599	83 e2 07	 and	 edx, 7
  0059c	03 c2		 add	 eax, edx
  0059e	c1 f8 03	 sar	 eax, 3
  005a1	48 98		 cdqe
  005a3	48 89 84 24 c0
	00 00 00	 mov	 QWORD PTR tv294[rsp], rax
  005ab	0f b6 4c 24 40	 movzx	 ecx, BYTE PTR chpid$1[rsp]
  005b0	8b c1		 mov	 eax, ecx
  005b2	99		 cdq
  005b3	83 e2 07	 and	 edx, 7
  005b6	03 c2		 add	 eax, edx
  005b8	83 e0 07	 and	 eax, 7
  005bb	2b c2		 sub	 eax, edx
  005bd	b9 80 00 00 00	 mov	 ecx, 128		; 00000080H
  005c2	89 8c 24 a8 00
	00 00		 mov	 DWORD PTR tv563[rsp], ecx
  005c9	0f b6 c8	 movzx	 ecx, al
  005cc	8b 84 24 a8 00
	00 00		 mov	 eax, DWORD PTR tv563[rsp]
  005d3	d3 f8		 sar	 eax, cl
  005d5	48 8b 4c 24 70	 mov	 rcx, QWORD PTR spccbchp$[rsp]
  005da	48 8b 94 24 c0
	00 00 00	 mov	 rdx, QWORD PTR tv294[rsp]
  005e2	0f b6 4c 11 20	 movzx	 ecx, BYTE PTR [rcx+rdx+32]
  005e7	0b c8		 or	 ecx, eax
  005e9	8b c1		 mov	 eax, ecx
  005eb	89 84 24 ac 00
	00 00		 mov	 DWORD PTR tv307[rsp], eax
  005f2	0f b6 4c 24 40	 movzx	 ecx, BYTE PTR chpid$1[rsp]
  005f7	8b c1		 mov	 eax, ecx
  005f9	99		 cdq
  005fa	83 e2 07	 and	 edx, 7
  005fd	03 c2		 add	 eax, edx
  005ff	c1 f8 03	 sar	 eax, 3
  00602	48 98		 cdqe
  00604	48 8b 4c 24 70	 mov	 rcx, QWORD PTR spccbchp$[rsp]
  00609	8b 94 24 ac 00
	00 00		 mov	 edx, DWORD PTR tv307[rsp]
  00610	88 54 01 20	 mov	 BYTE PTR [rcx+rax+32], dl

; 408  :                         spccbchp->configured[chpid / 8] |= 0x80 >> (chpid % 8);

  00614	0f b6 44 24 40	 movzx	 eax, BYTE PTR chpid$1[rsp]
  00619	99		 cdq
  0061a	83 e2 07	 and	 edx, 7
  0061d	03 c2		 add	 eax, edx
  0061f	c1 f8 03	 sar	 eax, 3
  00622	48 98		 cdqe
  00624	48 89 84 24 c8
	00 00 00	 mov	 QWORD PTR tv312[rsp], rax
  0062c	0f b6 4c 24 40	 movzx	 ecx, BYTE PTR chpid$1[rsp]
  00631	8b c1		 mov	 eax, ecx
  00633	99		 cdq
  00634	83 e2 07	 and	 edx, 7
  00637	03 c2		 add	 eax, edx
  00639	83 e0 07	 and	 eax, 7
  0063c	2b c2		 sub	 eax, edx
  0063e	b9 80 00 00 00	 mov	 ecx, 128		; 00000080H
  00643	89 8c 24 b0 00
	00 00		 mov	 DWORD PTR tv572[rsp], ecx
  0064a	0f b6 c8	 movzx	 ecx, al
  0064d	8b 84 24 b0 00
	00 00		 mov	 eax, DWORD PTR tv572[rsp]
  00654	d3 f8		 sar	 eax, cl
  00656	48 8b 4c 24 70	 mov	 rcx, QWORD PTR spccbchp$[rsp]
  0065b	48 8b 94 24 c8
	00 00 00	 mov	 rdx, QWORD PTR tv312[rsp]
  00663	0f b6 4c 11 40	 movzx	 ecx, BYTE PTR [rcx+rdx+64]
  00668	0b c8		 or	 ecx, eax
  0066a	8b c1		 mov	 eax, ecx
  0066c	89 84 24 b4 00
	00 00		 mov	 DWORD PTR tv325[rsp], eax
  00673	0f b6 4c 24 40	 movzx	 ecx, BYTE PTR chpid$1[rsp]
  00678	8b c1		 mov	 eax, ecx
  0067a	99		 cdq
  0067b	83 e2 07	 and	 edx, 7
  0067e	03 c2		 add	 eax, edx
  00680	c1 f8 03	 sar	 eax, 3
  00683	48 98		 cdqe
  00685	48 8b 4c 24 70	 mov	 rcx, QWORD PTR spccbchp$[rsp]
  0068a	8b 94 24 b4 00
	00 00		 mov	 edx, DWORD PTR tv325[rsp]
  00691	88 54 01 40	 mov	 BYTE PTR [rcx+rax+64], dl
$LN32@s390_mssf_:

; 409  :                     }
; 410  :                }

  00695	e9 17 fe ff ff	 jmp	 $LN10@s390_mssf_
$LN11@s390_mssf_:

; 411  :             }

  0069a	e9 e5 fd ff ff	 jmp	 $LN7@s390_mssf_
$LN8@s390_mssf_:

; 412  : 
; 413  :             /* Set response code X'0010' in SPCCB header */
; 414  :             spccb->resp[0] = SPCCB_REAS_COMPLETE;

  0069f	b8 01 00 00 00	 mov	 eax, 1
  006a4	48 6b c0 00	 imul	 rax, rax, 0
  006a8	48 8b 4c 24 58	 mov	 rcx, QWORD PTR spccb$[rsp]
  006ad	c6 44 01 06 00	 mov	 BYTE PTR [rcx+rax+6], 0

; 415  :             spccb->resp[1] = SPCCB_RESP_COMPLETE;

  006b2	b8 01 00 00 00	 mov	 eax, 1
  006b7	48 6b c0 01	 imul	 rax, rax, 1
  006bb	48 8b 4c 24 58	 mov	 rcx, QWORD PTR spccb$[rsp]
  006c0	c6 44 01 06 10	 mov	 BYTE PTR [rcx+rax+6], 16

; 416  : 
; 417  :             break;

  006c5	e9 b1 00 00 00	 jmp	 $LN2@s390_mssf_
$LN33@s390_mssf_:
$LN15@s390_mssf_:

; 418  : 
; 419  :         default:
; 420  :             PTT_ERR("*DIAG080",regs->GR_L(r1),regs->GR_L(r2),regs->psw.IA_L);

  006ca	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_pttclass
  006d1	48 8b 00	 mov	 rax, QWORD PTR [rax]
  006d4	48 83 e0 10	 and	 rax, 16
  006d8	48 85 c0	 test	 rax, rax
  006db	74 6e		 je	 SHORT $LN34@s390_mssf_
  006dd	48 8b 84 24 f0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  006e5	8b 80 88 00 00
	00		 mov	 eax, DWORD PTR [rax+136]
  006eb	48 63 8c 24 e8
	00 00 00	 movsxd	 rcx, DWORD PTR r2$[rsp]
  006f3	48 8b 94 24 f0
	00 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  006fb	8b 8c ca 80 02
	00 00		 mov	 ecx, DWORD PTR [rdx+rcx*8+640]
  00702	48 63 94 24 e0
	00 00 00	 movsxd	 rdx, DWORD PTR r1$[rsp]
  0070a	48 8b bc 24 f0
	00 00 00	 mov	 rdi, QWORD PTR regs$[rsp]
  00712	8b 94 d7 80 02
	00 00		 mov	 edx, DWORD PTR [rdi+rdx*8+640]
  00719	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR [rsp+48], 0
  00722	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  00727	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG179825
  0072e	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00733	44 8b c9	 mov	 r9d, ecx
  00736	44 8b c2	 mov	 r8d, edx
  00739	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG179826
  00740	b9 10 00 00 00	 mov	 ecx, 16
  00745	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ptt_pthread_trace
$LN34@s390_mssf_:
  0074b	33 c0		 xor	 eax, eax
  0074d	85 c0		 test	 eax, eax
  0074f	0f 85 75 ff ff
	ff		 jne	 $LN15@s390_mssf_

; 421  :             /* Set response code X'06F0' for invalid MSSF command */
; 422  :             spccb->resp[0] = SPCCB_REAS_UNASSIGNED;

  00755	b8 01 00 00 00	 mov	 eax, 1
  0075a	48 6b c0 00	 imul	 rax, rax, 0
  0075e	48 8b 4c 24 58	 mov	 rcx, QWORD PTR spccb$[rsp]
  00763	c6 44 01 06 06	 mov	 BYTE PTR [rcx+rax+6], 6

; 423  :             spccb->resp[1] = SPCCB_RESP_UNASSIGNED;

  00768	b8 01 00 00 00	 mov	 eax, 1
  0076d	48 6b c0 01	 imul	 rax, rax, 1
  00771	48 8b 4c 24 58	 mov	 rcx, QWORD PTR spccb$[rsp]
  00776	c6 44 01 06 f0	 mov	 BYTE PTR [rcx+rax+6], 240 ; 000000f0H
$LN2@s390_mssf_:
$LN27@s390_mssf_:

; 424  : 
; 425  :             break;
; 426  : 
; 427  :         } /* end switch(mssf_command) */
; 428  : 
; 429  :     /* Mark page changed */
; 430  :     ARCH_DEP( or_storage_key )( spccb_absolute_addr, STORKEY_CHANGE );

  0077b	8b 44 24 4c	 mov	 eax, DWORD PTR spccb_absolute_addr$[rsp]
  0077f	b2 02		 mov	 dl, 2
  00781	8b c8		 mov	 ecx, eax
  00783	e8 00 00 00 00	 call	 s390_or_storage_key

; 431  : 
; 432  :     /* Set service signal external interrupt pending */
; 433  :     sysblk.servparm &= ~SERVSIG_ADDR;

  00788	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  0078f	8b 80 90 12 00
	00		 mov	 eax, DWORD PTR [rax+4752]
  00795	83 e0 07	 and	 eax, 7
  00798	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  0079f	89 81 90 12 00
	00		 mov	 DWORD PTR [rcx+4752], eax

; 434  :     sysblk.servparm |= spccb_absolute_addr;

  007a5	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  007ac	8b 4c 24 4c	 mov	 ecx, DWORD PTR spccb_absolute_addr$[rsp]
  007b0	8b 80 90 12 00
	00		 mov	 eax, DWORD PTR [rax+4752]
  007b6	0b c1		 or	 eax, ecx
  007b8	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  007bf	89 81 90 12 00
	00		 mov	 DWORD PTR [rcx+4752], eax
$LN18@s390_mssf_:

; 435  :     ON_IC_SERVSIG;

  007c5	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  007cc	8b 80 a0 12 00
	00		 mov	 eax, DWORD PTR [rax+4768]
  007d2	25 00 02 00 00	 and	 eax, 512		; 00000200H
  007d7	85 c0		 test	 eax, eax
  007d9	0f 85 0b 01 00
	00		 jne	 $LN35@s390_mssf_
  007df	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  007e6	8b 80 a0 12 00
	00		 mov	 eax, DWORD PTR [rax+4768]
  007ec	0f ba e8 09	 bts	 eax, 9
  007f0	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  007f7	89 81 a0 12 00
	00		 mov	 DWORD PTR [rcx+4768], eax
  007fd	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00804	48 8b 80 b0 12
	00 00		 mov	 rax, QWORD PTR [rax+4784]
  0080b	48 89 84 24 90
	00 00 00	 mov	 QWORD PTR mask$3[rsp], rax
  00813	c7 44 24 50 00
	00 00 00	 mov	 DWORD PTR i$2[rsp], 0
  0081b	eb 0a		 jmp	 SHORT $LN21@s390_mssf_
$LN19@s390_mssf_:
  0081d	8b 44 24 50	 mov	 eax, DWORD PTR i$2[rsp]
  00821	ff c0		 inc	 eax
  00823	89 44 24 50	 mov	 DWORD PTR i$2[rsp], eax
$LN21@s390_mssf_:
  00827	48 83 bc 24 90
	00 00 00 00	 cmp	 QWORD PTR mask$3[rsp], 0
  00830	0f 84 b4 00 00
	00		 je	 $LN20@s390_mssf_
  00836	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR mask$3[rsp]
  0083e	48 83 e0 01	 and	 rax, 1
  00842	48 85 c0	 test	 rax, rax
  00845	0f 84 87 00 00
	00		 je	 $LN36@s390_mssf_
  0084b	48 63 44 24 50	 movsxd	 rax, DWORD PTR i$2[rsp]
  00850	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  00857	48 8b 84 c1 98
	0b 00 00	 mov	 rax, QWORD PTR [rcx+rax*8+2968]
  0085f	8b 40 4c	 mov	 eax, DWORD PTR [rax+76]
  00862	25 00 02 00 00	 and	 eax, 512		; 00000200H
  00867	85 c0		 test	 eax, eax
  00869	74 35		 je	 SHORT $LN37@s390_mssf_
  0086b	48 63 44 24 50	 movsxd	 rax, DWORD PTR i$2[rsp]
  00870	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  00877	48 8b 84 c1 98
	0b 00 00	 mov	 rax, QWORD PTR [rcx+rax*8+2968]
  0087f	8b 40 48	 mov	 eax, DWORD PTR [rax+72]
  00882	0d 00 02 00 80	 or	 eax, -2147483136	; 80000200H
  00887	48 63 4c 24 50	 movsxd	 rcx, DWORD PTR i$2[rsp]
  0088c	48 8b 15 00 00
	00 00		 mov	 rdx, QWORD PTR __imp_sysblk
  00893	48 8b 8c ca 98
	0b 00 00	 mov	 rcx, QWORD PTR [rdx+rcx*8+2968]
  0089b	89 41 48	 mov	 DWORD PTR [rcx+72], eax
  0089e	eb 32		 jmp	 SHORT $LN38@s390_mssf_
$LN37@s390_mssf_:
  008a0	48 63 44 24 50	 movsxd	 rax, DWORD PTR i$2[rsp]
  008a5	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  008ac	48 8b 84 c1 98
	0b 00 00	 mov	 rax, QWORD PTR [rcx+rax*8+2968]
  008b4	8b 40 48	 mov	 eax, DWORD PTR [rax+72]
  008b7	0f ba e8 09	 bts	 eax, 9
  008bb	48 63 4c 24 50	 movsxd	 rcx, DWORD PTR i$2[rsp]
  008c0	48 8b 15 00 00
	00 00		 mov	 rdx, QWORD PTR __imp_sysblk
  008c7	48 8b 8c ca 98
	0b 00 00	 mov	 rcx, QWORD PTR [rdx+rcx*8+2968]
  008cf	89 41 48	 mov	 DWORD PTR [rcx+72], eax
$LN38@s390_mssf_:
$LN36@s390_mssf_:
  008d2	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR mask$3[rsp]
  008da	48 d1 e8	 shr	 rax, 1
  008dd	48 89 84 24 90
	00 00 00	 mov	 QWORD PTR mask$3[rsp], rax
  008e5	e9 33 ff ff ff	 jmp	 $LN19@s390_mssf_
$LN20@s390_mssf_:
$LN35@s390_mssf_:
  008ea	33 c0		 xor	 eax, eax
  008ec	85 c0		 test	 eax, eax
  008ee	0f 85 d1 fe ff
	ff		 jne	 $LN18@s390_mssf_

; 436  : 
; 437  :     /* Release the interrupt lock */
; 438  :     RELEASE_INTLOCK(regs);

  008f4	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG179831
  008fb	48 8b 8c 24 f0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00903	e8 00 00 00 00	 call	 Release_Interrupt_Lock

; 439  : 
; 440  :     /* Return condition code 0: Command initiated */
; 441  :     return 0;

  00908	33 c0		 xor	 eax, eax
$LN1@s390_mssf_:

; 442  : 
; 443  : } /* end function mssf_call */

  0090a	48 81 c4 d0 00
	00 00		 add	 rsp, 208		; 000000d0H
  00911	5f		 pop	 rdi
  00912	c3		 ret	 0
s390_mssf_call ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\diagmssf.c
_TEXT	SEGMENT
s390_scpend_call PROC

; 265  : {

$LN3:
  00000	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 266  :         sched_yield();                  /* Just go to the dispatcher

  00004	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_sched_yield

; 267  :                                            for a minimum delay       */
; 268  : } /* end function scpend_call */

  0000a	48 83 c4 28	 add	 rsp, 40			; 00000028H
  0000e	c3		 ret	 0
s390_scpend_call ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\skey.h
;	COMDAT s370_or_storage_key
_TEXT	SEGMENT
abs$ = 48
bits$ = 56
s370_or_storage_key PROC				; COMDAT

; 290  : {

$LN3:
  00000	88 54 24 10	 mov	 BYTE PTR [rsp+16], dl
  00004	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00009	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 291  : #if defined( FEATURE_2K_STORAGE_KEYS )
; 292  :     ARCH_DEP( or_2K_storage_key )( abs, bits );

  0000d	0f b6 54 24 38	 movzx	 edx, BYTE PTR bits$[rsp]
  00012	48 8b 4c 24 30	 mov	 rcx, QWORD PTR abs$[rsp]
  00017	e8 00 00 00 00	 call	 s370_or_2K_storage_key

; 293  : #else
; 294  :     ARCH_DEP( or_4K_storage_key )( abs, bits );
; 295  : #endif
; 296  : }

  0001c	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00020	c3		 ret	 0
s370_or_storage_key ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\skey.h
;	COMDAT s370_or_2K_storage_key
_TEXT	SEGMENT
abs$ = 48
bits$ = 56
s370_or_2K_storage_key PROC				; COMDAT

; 231  :   inline void  ARCH_DEP( or_2K_storage_key )      (              U64 abs, BYTE bits ) {        ARCH_DEP( _or_storage_key      )(      abs, bits & ~STORKEY_BADFRM, 2 ); }

$LN3:
  00000	88 54 24 10	 mov	 BYTE PTR [rsp+16], dl
  00004	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00009	48 83 ec 28	 sub	 rsp, 40			; 00000028H
  0000d	0f b6 44 24 38	 movzx	 eax, BYTE PTR bits$[rsp]
  00012	83 e0 fe	 and	 eax, -2
  00015	41 b0 02	 mov	 r8b, 2
  00018	0f b6 d0	 movzx	 edx, al
  0001b	48 8b 4c 24 30	 mov	 rcx, QWORD PTR abs$[rsp]
  00020	e8 00 00 00 00	 call	 s370__or_storage_key
  00025	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00029	c3		 ret	 0
s370_or_2K_storage_key ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\skey.h
;	COMDAT s370__or_storage_key
_TEXT	SEGMENT
skey1_ptr$1 = 32
skey2_ptr$2 = 40
skey_ptr$3 = 48
abs$ = 80
bits$ = 88
K$ = 96
s370__or_storage_key PROC				; COMDAT

; 189  : {

$LN8:
  00000	44 88 44 24 18	 mov	 BYTE PTR [rsp+24], r8b
  00005	88 54 24 10	 mov	 BYTE PTR [rsp+16], dl
  00009	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000e	48 83 ec 48	 sub	 rsp, 72			; 00000048H
$LN4@s370__or_s:

; 190  :     UNREFERENCED( K ); // (for FEATURE_4K_STORAGE_KEYS case)

  00012	33 c0		 xor	 eax, eax
  00014	85 c0		 test	 eax, eax
  00016	75 fa		 jne	 SHORT $LN4@s370__or_s

; 191  :     if (IS_DOUBLE_KEYED_4K_BYTE_BLOCK( K ))

  00018	0f b6 44 24 60	 movzx	 eax, BYTE PTR K$[rsp]
  0001d	83 f8 04	 cmp	 eax, 4
  00020	75 57		 jne	 SHORT $LN5@s370__or_s
  00022	33 c0		 xor	 eax, eax
  00024	83 f8 01	 cmp	 eax, 1
  00027	74 50		 je	 SHORT $LN5@s370__or_s

; 192  :     {
; 193  :         BYTE* skey1_ptr = _get_storekey1_ptr( abs );

  00029	48 8b 4c 24 50	 mov	 rcx, QWORD PTR abs$[rsp]
  0002e	e8 00 00 00 00	 call	 _get_storekey1_ptr
  00033	48 89 44 24 20	 mov	 QWORD PTR skey1_ptr$1[rsp], rax

; 194  :         BYTE* skey2_ptr = _get_storekey2_ptr( abs );

  00038	48 8b 4c 24 50	 mov	 rcx, QWORD PTR abs$[rsp]
  0003d	e8 00 00 00 00	 call	 _get_storekey2_ptr
  00042	48 89 44 24 28	 mov	 QWORD PTR skey2_ptr$2[rsp], rax

; 195  :         OR_SKEY( skey1_ptr, bits );

  00047	0f b6 44 24 58	 movzx	 eax, BYTE PTR bits$[rsp]
  0004c	48 8b 4c 24 20	 mov	 rcx, QWORD PTR skey1_ptr$1[rsp]
  00051	0f b6 09	 movzx	 ecx, BYTE PTR [rcx]
  00054	0b c8		 or	 ecx, eax
  00056	8b c1		 mov	 eax, ecx
  00058	48 8b 4c 24 20	 mov	 rcx, QWORD PTR skey1_ptr$1[rsp]
  0005d	88 01		 mov	 BYTE PTR [rcx], al

; 196  :         OR_SKEY( skey2_ptr, bits );

  0005f	0f b6 44 24 58	 movzx	 eax, BYTE PTR bits$[rsp]
  00064	48 8b 4c 24 28	 mov	 rcx, QWORD PTR skey2_ptr$2[rsp]
  00069	0f b6 09	 movzx	 ecx, BYTE PTR [rcx]
  0006c	0b c8		 or	 ecx, eax
  0006e	8b c1		 mov	 eax, ecx
  00070	48 8b 4c 24 28	 mov	 rcx, QWORD PTR skey2_ptr$2[rsp]
  00075	88 01		 mov	 BYTE PTR [rcx], al

; 197  :     }

  00077	eb 2c		 jmp	 SHORT $LN6@s370__or_s
$LN5@s370__or_s:

; 198  :     else
; 199  :     {
; 200  :         BYTE* skey_ptr  = _get_storekey_ptr( abs, K );

  00079	0f b6 54 24 60	 movzx	 edx, BYTE PTR K$[rsp]
  0007e	48 8b 4c 24 50	 mov	 rcx, QWORD PTR abs$[rsp]
  00083	e8 00 00 00 00	 call	 _get_storekey_ptr
  00088	48 89 44 24 30	 mov	 QWORD PTR skey_ptr$3[rsp], rax

; 201  :         OR_SKEY( skey_ptr, bits );

  0008d	0f b6 44 24 58	 movzx	 eax, BYTE PTR bits$[rsp]
  00092	48 8b 4c 24 30	 mov	 rcx, QWORD PTR skey_ptr$3[rsp]
  00097	0f b6 09	 movzx	 ecx, BYTE PTR [rcx]
  0009a	0b c8		 or	 ecx, eax
  0009c	8b c1		 mov	 eax, ecx
  0009e	48 8b 4c 24 30	 mov	 rcx, QWORD PTR skey_ptr$3[rsp]
  000a3	88 01		 mov	 BYTE PTR [rcx], al
$LN6@s370__or_s:

; 202  :     }
; 203  : }

  000a5	48 83 c4 48	 add	 rsp, 72			; 00000048H
  000a9	c3		 ret	 0
s370__or_storage_key ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\skey.h
;	COMDAT _get_storekey2_ptr
_TEXT	SEGMENT
abs$ = 8
_get_storekey2_ptr PROC					; COMDAT

; 60   : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx

; 61   :     ABS_CHECK( abs );
; 62   :     return &STOREKEY2( abs, &sysblk );

  00005	48 8b 44 24 08	 mov	 rax, QWORD PTR abs$[rsp]
  0000a	48 c1 e8 0b	 shr	 rax, 11
  0000e	48 83 c8 01	 or	 rax, 1
  00012	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  00019	48 8b 89 a0 00
	00 00		 mov	 rcx, QWORD PTR [rcx+160]
  00020	48 03 c8	 add	 rcx, rax
  00023	48 8b c1	 mov	 rax, rcx

; 63   : }

  00026	c3		 ret	 0
_get_storekey2_ptr ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\skey.h
;	COMDAT _get_storekey1_ptr
_TEXT	SEGMENT
abs$ = 8
_get_storekey1_ptr PROC					; COMDAT

; 54   : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx

; 55   :     ABS_CHECK( abs );
; 56   :     return &STOREKEY1( abs, &sysblk );

  00005	48 8b 44 24 08	 mov	 rax, QWORD PTR abs$[rsp]
  0000a	48 c1 e8 0b	 shr	 rax, 11
  0000e	48 83 e0 fe	 and	 rax, -2
  00012	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  00019	48 8b 89 a0 00
	00 00		 mov	 rcx, QWORD PTR [rcx+160]
  00020	48 03 c8	 add	 rcx, rax
  00023	48 8b c1	 mov	 rax, rcx

; 57   : }

  00026	c3		 ret	 0
_get_storekey1_ptr ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\skey.h
;	COMDAT _get_storekey_ptr
_TEXT	SEGMENT
tv75 = 0
abs$ = 32
K$ = 40
_get_storekey_ptr PROC					; COMDAT

; 40   : {

$LN5:
  00000	88 54 24 10	 mov	 BYTE PTR [rsp+16], dl
  00004	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00009	48 83 ec 18	 sub	 rsp, 24

; 41   :     ABS_CHECK( abs );
; 42   :     return (4 == K) ? &STOREKEY1( abs, &sysblk ) // (see feature.h PROGRAMMING NOTE)

  0000d	0f b6 44 24 28	 movzx	 eax, BYTE PTR K$[rsp]
  00012	83 f8 04	 cmp	 eax, 4
  00015	75 27		 jne	 SHORT $LN3@get_storek
  00017	48 8b 44 24 20	 mov	 rax, QWORD PTR abs$[rsp]
  0001c	48 c1 e8 0b	 shr	 rax, 11
  00020	48 83 e0 fe	 and	 rax, -2
  00024	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  0002b	48 8b 89 a0 00
	00 00		 mov	 rcx, QWORD PTR [rcx+160]
  00032	48 03 c8	 add	 rcx, rax
  00035	48 8b c1	 mov	 rax, rcx
  00038	48 89 04 24	 mov	 QWORD PTR tv75[rsp], rax
  0003c	eb 21		 jmp	 SHORT $LN4@get_storek
$LN3@get_storek:
  0003e	48 8b 44 24 20	 mov	 rax, QWORD PTR abs$[rsp]
  00043	48 c1 e8 0b	 shr	 rax, 11
  00047	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  0004e	48 8b 89 a0 00
	00 00		 mov	 rcx, QWORD PTR [rcx+160]
  00055	48 03 c8	 add	 rcx, rax
  00058	48 8b c1	 mov	 rax, rcx
  0005b	48 89 04 24	 mov	 QWORD PTR tv75[rsp], rax
$LN4@get_storek:
  0005f	48 8b 04 24	 mov	 rax, QWORD PTR tv75[rsp]

; 43   :                     : &STOREKEY(  abs, &sysblk );
; 44   : }

  00063	48 83 c4 18	 add	 rsp, 24
  00067	c3		 ret	 0
_get_storekey_ptr ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\hinlines.h
_TEXT	SEGMENT
regs$ = 48
location$ = 56
Release_Interrupt_Lock PROC

; 403  : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 28	 sub	 rsp, 40			; 00000028H
$LN4@Release_In:

; 404  :     UNREFERENCED( regs );

  0000e	33 c0		 xor	 eax, eax
  00010	85 c0		 test	 eax, eax
  00012	75 fa		 jne	 SHORT $LN4@Release_In

; 405  :     sysblk.intowner = LOCK_OWNER_NONE;

  00014	b8 ff ff 00 00	 mov	 eax, 65535		; 0000ffffH
  00019	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  00020	66 89 81 62 10
	00 00		 mov	 WORD PTR [rcx+4194], ax

; 406  :     hthread_release_lock( &sysblk.intlock, location );

  00027	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  0002e	48 05 70 10 00
	00		 add	 rax, 4208		; 00001070H
  00034	48 8b 54 24 38	 mov	 rdx, QWORD PTR location$[rsp]
  00039	48 8b c8	 mov	 rcx, rax
  0003c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_release_lock

; 407  : }

  00042	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00046	c3		 ret	 0
Release_Interrupt_Lock ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\hinlines.h
_TEXT	SEGMENT
regs$ = 48
location$ = 56
Obtain_Interrupt_Lock PROC

; 379  : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 380  :     if (regs)

  0000e	48 83 7c 24 30
	00		 cmp	 QWORD PTR regs$[rsp], 0
  00014	74 13		 je	 SHORT $LN2@Obtain_Int

; 381  :         HOSTREGS->intwait = true;

  00016	48 8b 44 24 30	 mov	 rax, QWORD PTR regs$[rsp]
  0001b	48 8b 80 68 08
	00 00		 mov	 rax, QWORD PTR [rax+2152]
  00022	c6 80 f0 08 00
	00 01		 mov	 BYTE PTR [rax+2288], 1
$LN2@Obtain_Int:

; 382  :     hthread_obtain_lock( &sysblk.intlock, location );

  00029	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00030	48 05 70 10 00
	00		 add	 rax, 4208		; 00001070H
  00036	48 8b 54 24 38	 mov	 rdx, QWORD PTR location$[rsp]
  0003b	48 8b c8	 mov	 rcx, rax
  0003e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_obtain_lock

; 383  :     Interrupt_Lock_Obtained( regs, location );

  00044	48 8b 54 24 38	 mov	 rdx, QWORD PTR location$[rsp]
  00049	48 8b 4c 24 30	 mov	 rcx, QWORD PTR regs$[rsp]
  0004e	e8 00 00 00 00	 call	 Interrupt_Lock_Obtained

; 384  : }

  00053	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00057	c3		 ret	 0
Obtain_Interrupt_Lock ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\hinlines.h
_TEXT	SEGMENT
regs$ = 48
location$ = 56
Interrupt_Lock_Obtained PROC

; 347  : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 348  :     if (regs)

  0000e	48 83 7c 24 30
	00		 cmp	 QWORD PTR regs$[rsp], 0
  00014	0f 84 db 00 00
	00		 je	 $LN4@Interrupt_
$LN2@Interrupt_:

; 349  :     {
; 350  :         /* Wait for any SYNCHRONIZE_CPUS to finish before proceeding */
; 351  :         while (sysblk.syncing)

  0001a	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00021	0f b6 80 7c 13
	00 00		 movzx	 eax, BYTE PTR [rax+4988]
  00028	85 c0		 test	 eax, eax
  0002a	0f 84 8f 00 00
	00		 je	 $LN3@Interrupt_

; 352  :         {
; 353  :             /* Indicate we have reached the sync point */
; 354  :             sysblk.sync_mask &= ~HOSTREGS->cpubit;

  00030	48 8b 44 24 30	 mov	 rax, QWORD PTR regs$[rsp]
  00035	48 8b 80 68 08
	00 00		 mov	 rax, QWORD PTR [rax+2152]
  0003c	48 8b 40 50	 mov	 rax, QWORD PTR [rax+80]
  00040	48 f7 d0	 not	 rax
  00043	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  0004a	48 8b 89 80 13
	00 00		 mov	 rcx, QWORD PTR [rcx+4992]
  00051	48 23 c8	 and	 rcx, rax
  00054	48 8b c1	 mov	 rax, rcx
  00057	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  0005e	48 89 81 80 13
	00 00		 mov	 QWORD PTR [rcx+4992], rax

; 355  : 
; 356  :             /* If we're the last CPU to reach this sync point,
; 357  :                signal the CPU that requested the sync that it
; 358  :                may now safely proceed with its exclusive logic.
; 359  :             */
; 360  :             if (!sysblk.sync_mask)

  00065	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  0006c	48 83 b8 80 13
	00 00 00	 cmp	 QWORD PTR [rax+4992], 0
  00074	75 1b		 jne	 SHORT $LN6@Interrupt_

; 361  :                 hthread_signal_condition( &sysblk.all_synced_cond, location );

  00076	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  0007d	48 05 88 13 00
	00		 add	 rax, 5000		; 00001388H
  00083	48 8b 54 24 38	 mov	 rdx, QWORD PTR location$[rsp]
  00088	48 8b c8	 mov	 rcx, rax
  0008b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_signal_condition
$LN6@Interrupt_:

; 362  : 
; 363  :             /* Wait for CPU that requested the sync to indicate
; 364  :                it's done and thus is now safe for us to proceed.
; 365  :             */
; 366  :             hthread_wait_condition( &sysblk.sync_done_cond, &sysblk.intlock, location );

  00091	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00098	48 05 70 10 00
	00		 add	 rax, 4208		; 00001070H
  0009e	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  000a5	48 81 c1 90 13
	00 00		 add	 rcx, 5008		; 00001390H
  000ac	4c 8b 44 24 38	 mov	 r8, QWORD PTR location$[rsp]
  000b1	48 8b d0	 mov	 rdx, rax
  000b4	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_wait_condition

; 367  :         }

  000ba	e9 5b ff ff ff	 jmp	 $LN2@Interrupt_
$LN3@Interrupt_:

; 368  : 
; 369  :         HOSTREGS->intwait = false;

  000bf	48 8b 44 24 30	 mov	 rax, QWORD PTR regs$[rsp]
  000c4	48 8b 80 68 08
	00 00		 mov	 rax, QWORD PTR [rax+2152]
  000cb	c6 80 f0 08 00
	00 00		 mov	 BYTE PTR [rax+2288], 0

; 370  :         sysblk.intowner = HOSTREGS->cpuad;

  000d2	48 8b 44 24 30	 mov	 rax, QWORD PTR regs$[rsp]
  000d7	48 8b 80 68 08
	00 00		 mov	 rax, QWORD PTR [rax+2152]
  000de	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  000e5	0f b7 80 3c 08
	00 00		 movzx	 eax, WORD PTR [rax+2108]
  000ec	66 89 81 62 10
	00 00		 mov	 WORD PTR [rcx+4194], ax

; 371  :     }

  000f3	eb 13		 jmp	 SHORT $LN5@Interrupt_
$LN4@Interrupt_:

; 372  :     else
; 373  :         sysblk.intowner = LOCK_OWNER_OTHER;

  000f5	b8 fe ff 00 00	 mov	 eax, 65534		; 0000fffeH
  000fa	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  00101	66 89 81 62 10
	00 00		 mov	 WORD PTR [rcx+4194], ax
$LN5@Interrupt_:

; 374  : }

  00108	48 83 c4 28	 add	 rsp, 40			; 00000028H
  0010c	c3		 ret	 0
Interrupt_Lock_Obtained ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\machdep.h
;	COMDAT store_dw_noswap
_TEXT	SEGMENT
ptr$ = 8
value$ = 16
store_dw_noswap PROC					; COMDAT

; 834  :     inline void store_dw_noswap(void *ptr, U64 value) {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx

; 835  :       memcpy((BYTE *)ptr, (BYTE *)&value, 8);

  0000a	48 8b 44 24 08	 mov	 rax, QWORD PTR ptr$[rsp]
  0000f	48 8b 4c 24 10	 mov	 rcx, QWORD PTR value$[rsp]
  00014	48 89 08	 mov	 QWORD PTR [rax], rcx

; 836  :     }

  00017	c3		 ret	 0
store_dw_noswap ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\machdep.h
;	COMDAT store_hw_noswap
_TEXT	SEGMENT
ptr$ = 8
value$ = 16
store_hw_noswap PROC					; COMDAT

; 730  :     inline void store_hw_noswap(void *ptr, U16 value) {

  00000	66 89 54 24 10	 mov	 WORD PTR [rsp+16], dx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx

; 731  :       memcpy((BYTE *)ptr, (BYTE *)&value, 2);

  0000a	48 8b 44 24 08	 mov	 rax, QWORD PTR ptr$[rsp]
  0000f	0f b7 4c 24 10	 movzx	 ecx, WORD PTR value$[rsp]
  00014	66 89 08	 mov	 WORD PTR [rax], cx

; 732  :     }

  00017	c3		 ret	 0
store_hw_noswap ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\machdep.h
;	COMDAT fetch_hw_noswap
_TEXT	SEGMENT
value$ = 0
ptr$ = 32
fetch_hw_noswap PROC					; COMDAT

; 712  :     inline U16 fetch_hw_noswap(const void *ptr) {

$LN3:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 18	 sub	 rsp, 24

; 713  :       U16 value;
; 714  :       memcpy(&value, (BYTE *)ptr, 2);

  00009	48 8b 44 24 20	 mov	 rax, QWORD PTR ptr$[rsp]
  0000e	0f b7 00	 movzx	 eax, WORD PTR [rax]
  00011	66 89 04 24	 mov	 WORD PTR value$[rsp], ax

; 715  :       return value;

  00015	0f b7 04 24	 movzx	 eax, WORD PTR value$[rsp]

; 716  :     }

  00019	48 83 c4 18	 add	 rsp, 24
  0001d	c3		 ret	 0
fetch_hw_noswap ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\diagmssf.c
_TEXT	SEGMENT
i$ = 32
ptyp$ = 36
tv95 = 40
len$ = 44
p$ = 48
abs$ = 56
r1$ = 96
r2$ = 104
regs$ = 112
s370_diag224_call PROC

; 735  : {

$LN17:
  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00009	89 4c 24 08	 mov	 DWORD PTR [rsp+8], ecx
  0000d	56		 push	 rsi
  0000e	57		 push	 rdi
  0000f	48 83 ec 48	 sub	 rsp, 72			; 00000048H
$LN4@s370_diag2:

; 736  : RADR              abs;                 /* abs addr of data area      */
; 737  : BYTE             *p;                   /* pointer to the data area   */
; 738  : unsigned int      len, ptyp, i;        /* work                       */
; 739  : 
; 740  :     // FIXME:  This function is probably incomplete.
; 741  :     //         See linux/arch/s390/hypfs/hypfs_diag.c
; 742  : 
; 743  :     UNREFERENCED( r1 );

  00013	33 c0		 xor	 eax, eax
  00015	85 c0		 test	 eax, eax
  00017	75 fa		 jne	 SHORT $LN4@s370_diag2

; 744  : 
; 745  :     abs = APPLY_PREFIXING( regs->GR_L( r2 ), regs->PX );

  00019	48 63 44 24 68	 movsxd	 rax, DWORD PTR r2$[rsp]
  0001e	48 8b 4c 24 70	 mov	 rcx, QWORD PTR regs$[rsp]
  00023	8b 84 c1 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax*8+640]
  0002a	48 25 00 f0 ff
	ff		 and	 rax, -4096		; fffffffffffff000H
  00030	48 85 c0	 test	 rax, rax
  00033	74 3b		 je	 SHORT $LN15@s370_diag2
  00035	48 63 44 24 68	 movsxd	 rax, DWORD PTR r2$[rsp]
  0003a	48 8b 4c 24 70	 mov	 rcx, QWORD PTR regs$[rsp]
  0003f	8b 84 c1 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax*8+640]
  00046	48 25 00 f0 ff
	ff		 and	 rax, -4096		; fffffffffffff000H
  0004c	48 8b 4c 24 70	 mov	 rcx, QWORD PTR regs$[rsp]
  00051	8b 49 70	 mov	 ecx, DWORD PTR [rcx+112]
  00054	48 3b c1	 cmp	 rax, rcx
  00057	74 17		 je	 SHORT $LN15@s370_diag2
  00059	48 63 44 24 68	 movsxd	 rax, DWORD PTR r2$[rsp]
  0005e	48 8b 4c 24 70	 mov	 rcx, QWORD PTR regs$[rsp]
  00063	8b 84 c1 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax*8+640]
  0006a	89 44 24 28	 mov	 DWORD PTR tv95[rsp], eax
  0006e	eb 1f		 jmp	 SHORT $LN16@s370_diag2
$LN15@s370_diag2:
  00070	48 63 44 24 68	 movsxd	 rax, DWORD PTR r2$[rsp]
  00075	48 8b 4c 24 70	 mov	 rcx, QWORD PTR regs$[rsp]
  0007a	48 8b 54 24 70	 mov	 rdx, QWORD PTR regs$[rsp]
  0007f	8b 52 70	 mov	 edx, DWORD PTR [rdx+112]
  00082	8b 84 c1 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax*8+640]
  00089	33 c2		 xor	 eax, edx
  0008b	89 44 24 28	 mov	 DWORD PTR tv95[rsp], eax
$LN16@s370_diag2:
  0008f	8b 44 24 28	 mov	 eax, DWORD PTR tv95[rsp]
  00093	48 89 44 24 38	 mov	 QWORD PTR abs$[rsp], rax

; 746  : 
; 747  :     /* Program check if data area is not on a page boundary */
; 748  :     if ((abs & PAGEFRAME_BYTEMASK) != 0)

  00098	48 8b 44 24 38	 mov	 rax, QWORD PTR abs$[rsp]
  0009d	48 25 ff 07 00
	00		 and	 rax, 2047		; 000007ffH
  000a3	48 85 c0	 test	 rax, rax
  000a6	74 0f		 je	 SHORT $LN11@s370_diag2

; 749  :         ARCH_DEP( program_interrupt )( regs, PGM_SPECIFICATION_EXCEPTION );

  000a8	ba 06 00 00 00	 mov	 edx, 6
  000ad	48 8b 4c 24 70	 mov	 rcx, QWORD PTR regs$[rsp]
  000b2	e8 00 00 00 00	 call	 s370_program_interrupt
$LN11@s370_diag2:

; 750  : 
; 751  :     /* Calculate length of data to be stored */
; 752  :     len = 16 + ((MAX_SCCB_PTYP + 1) * 16);

  000b7	c7 44 24 2c 70
	00 00 00	 mov	 DWORD PTR len$[rsp], 112 ; 00000070H

; 753  : 
; 754  :     /* Program check if data area is outside main storage */
; 755  :     if (abs > regs->mainlim || len > PAGEFRAME_PAGESIZE)

  000bf	48 8b 44 24 70	 mov	 rax, QWORD PTR regs$[rsp]
  000c4	48 8b 80 58 08
	00 00		 mov	 rax, QWORD PTR [rax+2136]
  000cb	48 39 44 24 38	 cmp	 QWORD PTR abs$[rsp], rax
  000d0	77 0a		 ja	 SHORT $LN13@s370_diag2
  000d2	81 7c 24 2c 00
	08 00 00	 cmp	 DWORD PTR len$[rsp], 2048 ; 00000800H
  000da	76 0f		 jbe	 SHORT $LN12@s370_diag2
$LN13@s370_diag2:

; 756  :         ARCH_DEP( program_interrupt )( regs, PGM_ADDRESSING_EXCEPTION );

  000dc	ba 05 00 00 00	 mov	 edx, 5
  000e1	48 8b 4c 24 70	 mov	 rcx, QWORD PTR regs$[rsp]
  000e6	e8 00 00 00 00	 call	 s370_program_interrupt
$LN12@s370_diag2:

; 757  : 
; 758  :     /* Mark page referenced */
; 759  :     ARCH_DEP( or_storage_key )( abs, (STORKEY_REF | STORKEY_CHANGE) );

  000eb	b2 06		 mov	 dl, 6
  000ed	48 8b 4c 24 38	 mov	 rcx, QWORD PTR abs$[rsp]
  000f2	e8 00 00 00 00	 call	 s370_or_storage_key

; 760  : 
; 761  :     /* Point to DIAG 224 return area */
; 762  :     p = regs->mainstor + abs;

  000f7	48 8b 44 24 70	 mov	 rax, QWORD PTR regs$[rsp]
  000fc	48 8b 80 48 08
	00 00		 mov	 rax, QWORD PTR [rax+2120]
  00103	48 03 44 24 38	 add	 rax, QWORD PTR abs$[rsp]
  00108	48 89 44 24 30	 mov	 QWORD PTR p$[rsp], rax

; 763  : 
; 764  :     /*
; 765  :     ** The first byte of the first 16-byte entry contains the total number
; 766  :     ** of 16-byte entries minus 1 that immediately follows the first entry.
; 767  :     ** The remaining 15 bytes of the first 16-byte entry are binary zeros.
; 768  :     ** Each of the remaining entries following the first one contains the
; 769  :     ** EBCDIC name of each processor type.
; 770  :     */
; 771  : 
; 772  :     *p = MAX_SCCB_PTYP;         /* (number of entries which follows-1) */

  0010d	48 8b 44 24 30	 mov	 rax, QWORD PTR p$[rsp]
  00112	c6 00 05	 mov	 BYTE PTR [rax], 5

; 773  :     memset( p+1, 0, 16-1 );     /* (pad first entry with binary zeros) */

  00115	48 8b 44 24 30	 mov	 rax, QWORD PTR p$[rsp]
  0011a	48 ff c0	 inc	 rax
  0011d	48 8b f8	 mov	 rdi, rax
  00120	33 c0		 xor	 eax, eax
  00122	b9 0f 00 00 00	 mov	 ecx, 15
  00127	f3 aa		 rep stosb

; 774  : 
; 775  :     for (ptyp=0; ptyp <= MAX_SCCB_PTYP; ptyp++)

  00129	c7 44 24 24 00
	00 00 00	 mov	 DWORD PTR ptyp$[rsp], 0
  00131	eb 0a		 jmp	 SHORT $LN7@s370_diag2
$LN5@s370_diag2:
  00133	8b 44 24 24	 mov	 eax, DWORD PTR ptyp$[rsp]
  00137	ff c0		 inc	 eax
  00139	89 44 24 24	 mov	 DWORD PTR ptyp$[rsp], eax
$LN7@s370_diag2:
  0013d	83 7c 24 24 05	 cmp	 DWORD PTR ptyp$[rsp], 5
  00142	77 66		 ja	 SHORT $LN6@s370_diag2

; 776  :     {
; 777  :         p += 16;                              /* point to next entry   */

  00144	48 8b 44 24 30	 mov	 rax, QWORD PTR p$[rsp]
  00149	48 83 c0 10	 add	 rax, 16
  0014d	48 89 44 24 30	 mov	 QWORD PTR p$[rsp], rax

; 778  :         memcpy( p, ptyp2long( ptyp ), 16 );   /* move in ASCII value   */

  00152	0f b6 4c 24 24	 movzx	 ecx, BYTE PTR ptyp$[rsp]
  00157	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ptyp2long
  0015d	48 8b 7c 24 30	 mov	 rdi, QWORD PTR p$[rsp]
  00162	48 8b f0	 mov	 rsi, rax
  00165	b9 10 00 00 00	 mov	 ecx, 16
  0016a	f3 a4		 rep movsb

; 779  :         for (i=0; i < 16; i++)

  0016c	c7 44 24 20 00
	00 00 00	 mov	 DWORD PTR i$[rsp], 0
  00174	eb 0a		 jmp	 SHORT $LN10@s370_diag2
$LN8@s370_diag2:
  00176	8b 44 24 20	 mov	 eax, DWORD PTR i$[rsp]
  0017a	ff c0		 inc	 eax
  0017c	89 44 24 20	 mov	 DWORD PTR i$[rsp], eax
$LN10@s370_diag2:
  00180	83 7c 24 20 10	 cmp	 DWORD PTR i$[rsp], 16
  00185	73 21		 jae	 SHORT $LN9@s370_diag2

; 780  :             p[i] = host_to_guest( p[i] );     /* convert it to EBCDIC  */

  00187	8b 44 24 20	 mov	 eax, DWORD PTR i$[rsp]
  0018b	48 8b 4c 24 30	 mov	 rcx, QWORD PTR p$[rsp]
  00190	0f b6 0c 01	 movzx	 ecx, BYTE PTR [rcx+rax]
  00194	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_host_to_guest
  0019a	8b 4c 24 20	 mov	 ecx, DWORD PTR i$[rsp]
  0019e	48 8b 54 24 30	 mov	 rdx, QWORD PTR p$[rsp]
  001a3	88 04 0a	 mov	 BYTE PTR [rdx+rcx], al
  001a6	eb ce		 jmp	 SHORT $LN8@s370_diag2
$LN9@s370_diag2:

; 781  :     }

  001a8	eb 89		 jmp	 SHORT $LN5@s370_diag2
$LN6@s370_diag2:

; 782  : 
; 783  : } /* end function diag224_call */

  001aa	48 83 c4 48	 add	 rsp, 72			; 00000048H
  001ae	5f		 pop	 rdi
  001af	5e		 pop	 rsi
  001b0	c3		 ret	 0
s370_diag224_call ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\diagmssf.c
_TEXT	SEGMENT
i$ = 64
cpuinfo$ = 72
hdrinfo$ = 80
tv132 = 88
partinfo$ = 96
abs$ = 104
tv69 = 112
tv173 = 120
$T1 = 128
cputime$ = 144
ETOD$ = 160
uCPU$ = 176
tCPU$ = 688
__$ArrayPad$ = 1200
r1$ = 1248
r2$ = 1256
regs$ = 1264
s370_diag204_call PROC

; 450  : {

$LN24:
  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00009	89 4c 24 08	 mov	 DWORD PTR [rsp+8], ecx
  0000d	56		 push	 rsi
  0000e	57		 push	 rdi
  0000f	48 81 ec c8 04
	00 00		 sub	 rsp, 1224		; 000004c8H
  00016	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  0001d	48 33 c4	 xor	 rax, rsp
  00020	48 89 84 24 b0
	04 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 451  : DIAG204_HDR       *hdrinfo;            /* Header                     */
; 452  : DIAG204_PART      *partinfo;           /* Partition info             */
; 453  : DIAG204_PART_CPU  *cpuinfo;            /* CPU info                   */
; 454  : 
; 455  : #if defined( FEATURE_EXTENDED_DIAG204 )
; 456  : DIAG204_X_HDR       *hdrxinfo;         /* Header                     */
; 457  : DIAG204_X_PART      *partxinfo;        /* Partition info             */
; 458  : DIAG204_X_PART_CPU  *cpuxinfo;         /* CPU info                   */
; 459  : #endif
; 460  : 
; 461  : RADR             abs;                  /* abs addr of data area      */
; 462  : int              i;                    /* loop counter               */
; 463  : struct timespec  cputime;              /* to obtain thread time data */
; 464  : ETOD             ETOD;                 /* Extended TOD clock         */
; 465  : U64              uCPU[ MAX_CPU_ENGS ]; /* User CPU time    (usecs)   */
; 466  : U64              tCPU[ MAX_CPU_ENGS ]; /* Total CPU time   (usecs)   */
; 467  : 
; 468  : #if defined( FEATURE_PHYSICAL_DIAG204 )
; 469  : static BYTE       physical[8] =
; 470  :               {0xD7,0xC8,0xE8,0xE2,0xC9,0xC3,0xC1,0xD3}; /* PHYSICAL */
; 471  : #endif
; 472  : 
; 473  : #if defined( FEATURE_EXTENDED_DIAG204 )
; 474  : U64              oCPU[ MAX_CPU_ENGS ];  /* Online CPU time  (usecs)  */
; 475  : U64              wCPU[ MAX_CPU_ENGS ];  /* Wait CPU time    (usecs)  */
; 476  : #endif
; 477  : 
; 478  :     /* Test DIAG204 command word */
; 479  :     switch (regs->GR_L(r2)) {

  00028	48 63 84 24 e8
	04 00 00	 movsxd	 rax, DWORD PTR r2$[rsp]
  00030	48 8b 8c 24 f0
	04 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00038	8b 84 c1 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax*8+640]
  0003f	89 44 24 70	 mov	 DWORD PTR tv69[rsp], eax
  00043	83 7c 24 70 04	 cmp	 DWORD PTR tv69[rsp], 4
  00048	74 05		 je	 SHORT $LN13@s370_diag2
  0004a	e9 46 04 00 00	 jmp	 $LN19@s370_diag2
$LN13@s370_diag2:

; 480  : 
; 481  :     case 0x04:
; 482  : 
; 483  :         abs = APPLY_PREFIXING (GR_A(r1,regs), regs->PX);

  0004f	48 63 84 24 e0
	04 00 00	 movsxd	 rax, DWORD PTR r1$[rsp]
  00057	48 8b 8c 24 f0
	04 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0005f	8b 84 c1 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax*8+640]
  00066	48 25 00 f0 ff
	ff		 and	 rax, -4096		; fffffffffffff000H
  0006c	48 85 c0	 test	 rax, rax
  0006f	74 4a		 je	 SHORT $LN22@s370_diag2
  00071	48 63 84 24 e0
	04 00 00	 movsxd	 rax, DWORD PTR r1$[rsp]
  00079	48 8b 8c 24 f0
	04 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00081	8b 84 c1 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax*8+640]
  00088	48 25 00 f0 ff
	ff		 and	 rax, -4096		; fffffffffffff000H
  0008e	48 8b 8c 24 f0
	04 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00096	8b 49 70	 mov	 ecx, DWORD PTR [rcx+112]
  00099	48 3b c1	 cmp	 rax, rcx
  0009c	74 1d		 je	 SHORT $LN22@s370_diag2
  0009e	48 63 84 24 e0
	04 00 00	 movsxd	 rax, DWORD PTR r1$[rsp]
  000a6	48 8b 8c 24 f0
	04 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  000ae	8b 84 c1 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax*8+640]
  000b5	89 44 24 58	 mov	 DWORD PTR tv132[rsp], eax
  000b9	eb 28		 jmp	 SHORT $LN23@s370_diag2
$LN22@s370_diag2:
  000bb	48 63 84 24 e0
	04 00 00	 movsxd	 rax, DWORD PTR r1$[rsp]
  000c3	48 8b 8c 24 f0
	04 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  000cb	48 8b 94 24 f0
	04 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  000d3	8b 52 70	 mov	 edx, DWORD PTR [rdx+112]
  000d6	8b 84 c1 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax*8+640]
  000dd	33 c2		 xor	 eax, edx
  000df	89 44 24 58	 mov	 DWORD PTR tv132[rsp], eax
$LN23@s370_diag2:
  000e3	8b 44 24 58	 mov	 eax, DWORD PTR tv132[rsp]
  000e7	48 89 44 24 68	 mov	 QWORD PTR abs$[rsp], rax

; 484  : 
; 485  :         /* Program check if RMF data is not on a page boundary */
; 486  :         if ( (abs & PAGEFRAME_BYTEMASK) != 0x000)

  000ec	48 8b 44 24 68	 mov	 rax, QWORD PTR abs$[rsp]
  000f1	48 25 ff 07 00
	00		 and	 rax, 2047		; 000007ffH
  000f7	48 85 c0	 test	 rax, rax
  000fa	74 12		 je	 SHORT $LN14@s370_diag2

; 487  :             ARCH_DEP(program_interrupt) (regs, PGM_SPECIFICATION_EXCEPTION);

  000fc	ba 06 00 00 00	 mov	 edx, 6
  00101	48 8b 8c 24 f0
	04 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00109	e8 00 00 00 00	 call	 s370_program_interrupt
$LN14@s370_diag2:

; 488  : 
; 489  :         /* Program check if RMF data area is outside main storage */
; 490  :         if ( abs > regs->mainlim )

  0010e	48 8b 84 24 f0
	04 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00116	48 8b 80 58 08
	00 00		 mov	 rax, QWORD PTR [rax+2136]
  0011d	48 39 44 24 68	 cmp	 QWORD PTR abs$[rsp], rax
  00122	76 12		 jbe	 SHORT $LN15@s370_diag2

; 491  :             ARCH_DEP(program_interrupt) (regs, PGM_ADDRESSING_EXCEPTION);

  00124	ba 05 00 00 00	 mov	 edx, 5
  00129	48 8b 8c 24 f0
	04 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00131	e8 00 00 00 00	 call	 s370_program_interrupt
$LN15@s370_diag2:

; 492  : 
; 493  :         /* Point to DIAG 204 data area */
; 494  :         hdrinfo = (DIAG204_HDR*)(regs->mainstor + abs);

  00136	48 8b 84 24 f0
	04 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0013e	48 8b 80 48 08
	00 00		 mov	 rax, QWORD PTR [rax+2120]
  00145	48 03 44 24 68	 add	 rax, QWORD PTR abs$[rsp]
  0014a	48 89 44 24 50	 mov	 QWORD PTR hdrinfo$[rsp], rax

; 495  : 
; 496  :         /* Mark page referenced */
; 497  :         ARCH_DEP( or_storage_key )( abs, STORKEY_REF | STORKEY_CHANGE );

  0014f	b2 06		 mov	 dl, 6
  00151	48 8b 4c 24 68	 mov	 rcx, QWORD PTR abs$[rsp]
  00156	e8 00 00 00 00	 call	 s370_or_storage_key

; 498  : 
; 499  :         /* Retrieve the TOD clock value */
; 500  :         etod_clock(regs, &ETOD, ETOD_extended);

  0015b	41 b8 03 00 00
	00		 mov	 r8d, 3
  00161	48 8d 94 24 a0
	00 00 00	 lea	 rdx, QWORD PTR ETOD$[rsp]
  00169	48 8b 8c 24 f0
	04 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00171	e8 00 00 00 00	 call	 etod_clock

; 501  : 
; 502  :         /* Get processor time(s) and leave out non-CPU processes and
; 503  :          * threads
; 504  :          */
; 505  :         for(i = 0; i < sysblk.maxcpu; ++i)

  00176	c7 44 24 40 00
	00 00 00	 mov	 DWORD PTR i$[rsp], 0
  0017e	eb 0a		 jmp	 SHORT $LN6@s370_diag2
$LN4@s370_diag2:
  00180	8b 44 24 40	 mov	 eax, DWORD PTR i$[rsp]
  00184	ff c0		 inc	 eax
  00186	89 44 24 40	 mov	 DWORD PTR i$[rsp], eax
$LN6@s370_diag2:
  0018a	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00191	8b 80 00 01 00
	00		 mov	 eax, DWORD PTR [rax+256]
  00197	39 44 24 40	 cmp	 DWORD PTR i$[rsp], eax
  0019b	0f 8d be 00 00
	00		 jge	 $LN5@s370_diag2

; 506  :         {
; 507  :             if (IS_CPU_ONLINE(i))

  001a1	48 63 44 24 40	 movsxd	 rax, DWORD PTR i$[rsp]
  001a6	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  001ad	48 83 bc c1 98
	0b 00 00 00	 cmp	 QWORD PTR [rcx+rax*8+2968], 0
  001b6	0f 84 9e 00 00
	00		 je	 $LN16@s370_diag2

; 508  :             {
; 509  :                 /* Get CPU times in microseconds */
; 510  :                 if( clock_gettime(sysblk.cpuclockid[i], &cputime) == 0 )

  001bc	48 63 44 24 40	 movsxd	 rax, DWORD PTR i$[rsp]
  001c1	48 8d 94 24 90
	00 00 00	 lea	 rdx, QWORD PTR cputime$[rsp]
  001c9	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  001d0	8b 8c 81 48 0a
	00 00		 mov	 ecx, DWORD PTR [rcx+rax*4+2632]
  001d7	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_clock_gettime
  001dd	85 c0		 test	 eax, eax
  001df	75 79		 jne	 SHORT $LN17@s370_diag2

; 511  :                 {
; 512  :                     uCPU[i] = timespec2usecs(&cputime);

  001e1	48 8d 8c 24 90
	00 00 00	 lea	 rcx, QWORD PTR cputime$[rsp]
  001e9	e8 00 00 00 00	 call	 timespec2usecs
  001ee	48 63 4c 24 40	 movsxd	 rcx, DWORD PTR i$[rsp]
  001f3	48 89 84 cc b0
	00 00 00	 mov	 QWORD PTR uCPU$[rsp+rcx*8], rax

; 513  :                     tCPU[i] = uCPU[i] + ETOD_high64_to_usecs(sysblk.regs[i]->waittime_accumulated

  001fb	48 63 44 24 40	 movsxd	 rax, DWORD PTR i$[rsp]
  00200	48 89 44 24 78	 mov	 QWORD PTR tv173[rsp], rax
  00205	48 63 4c 24 40	 movsxd	 rcx, DWORD PTR i$[rsp]
  0020a	48 8b 15 00 00
	00 00		 mov	 rdx, QWORD PTR __imp_sysblk
  00211	48 8b 8c ca 98
	0b 00 00	 mov	 rcx, QWORD PTR [rdx+rcx*8+2968]
  00219	48 63 54 24 40	 movsxd	 rdx, DWORD PTR i$[rsp]
  0021e	4c 8b 05 00 00
	00 00		 mov	 r8, QWORD PTR __imp_sysblk
  00225	49 8b 94 d0 98
	0b 00 00	 mov	 rdx, QWORD PTR [r8+rdx*8+2968]
  0022d	48 8b 89 c8 07
	00 00		 mov	 rcx, QWORD PTR [rcx+1992]
  00234	48 03 8a c0 07
	00 00		 add	 rcx, QWORD PTR [rdx+1984]
  0023b	e8 00 00 00 00	 call	 ETOD_high64_to_usecs
  00240	48 8b 4c 24 78	 mov	 rcx, QWORD PTR tv173[rsp]
  00245	48 03 84 cc b0
	00 00 00	 add	 rax, QWORD PTR uCPU$[rsp+rcx*8]
  0024d	48 63 4c 24 40	 movsxd	 rcx, DWORD PTR i$[rsp]
  00252	48 89 84 cc b0
	02 00 00	 mov	 QWORD PTR tCPU$[rsp+rcx*8], rax
$LN17@s370_diag2:
$LN16@s370_diag2:

; 514  :                                               + sysblk.regs[i]->waittime ) ;
; 515  :                 }
; 516  :             }
; 517  :         }

  0025a	e9 21 ff ff ff	 jmp	 $LN4@s370_diag2
$LN5@s370_diag2:

; 518  : 
; 519  :         memset(hdrinfo, 0, sizeof(DIAG204_HDR));

  0025f	48 8b 7c 24 50	 mov	 rdi, QWORD PTR hdrinfo$[rsp]
  00264	33 c0		 xor	 eax, eax
  00266	b9 10 00 00 00	 mov	 ecx, 16
  0026b	f3 aa		 rep stosb

; 520  :         hdrinfo->numpart = 1;

  0026d	48 8b 44 24 50	 mov	 rax, QWORD PTR hdrinfo$[rsp]
  00272	c6 00 01	 mov	 BYTE PTR [rax], 1

; 521  : #if defined(FEATURE_PHYSICAL_DIAG204)
; 522  :         hdrinfo->flags = DIAG204_PHYSICAL_PRESENT;
; 523  : #endif /*defined(FEATURE_PHYSICAL_DIAG204)*/
; 524  :         STORE_HW(hdrinfo->physcpu,sysblk.cpus);

  00275	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  0027c	0f b7 88 04 01
	00 00		 movzx	 ecx, WORD PTR [rax+260]
  00283	e8 00 00 00 00	 call	 _byteswap_ushort
  00288	48 8b 4c 24 50	 mov	 rcx, QWORD PTR hdrinfo$[rsp]
  0028d	48 83 c1 04	 add	 rcx, 4
  00291	0f b7 d0	 movzx	 edx, ax
  00294	e8 00 00 00 00	 call	 store_hw_noswap

; 525  :         STORE_HW(hdrinfo->offown,sizeof(DIAG204_HDR));

  00299	66 b9 10 00	 mov	 cx, 16
  0029d	e8 00 00 00 00	 call	 _byteswap_ushort
  002a2	48 8b 4c 24 50	 mov	 rcx, QWORD PTR hdrinfo$[rsp]
  002a7	48 83 c1 06	 add	 rcx, 6
  002ab	0f b7 d0	 movzx	 edx, ax
  002ae	e8 00 00 00 00	 call	 store_hw_noswap

; 526  :         STORE_DW(hdrinfo->diagstck,ETOD2TOD(ETOD));

  002b3	48 8d 84 24 80
	00 00 00	 lea	 rax, QWORD PTR $T1[rsp]
  002bb	48 8d 8c 24 a0
	00 00 00	 lea	 rcx, QWORD PTR ETOD$[rsp]
  002c3	48 8b f8	 mov	 rdi, rax
  002c6	48 8b f1	 mov	 rsi, rcx
  002c9	b9 10 00 00 00	 mov	 ecx, 16
  002ce	f3 a4		 rep movsb
  002d0	48 8d 8c 24 80
	00 00 00	 lea	 rcx, QWORD PTR $T1[rsp]
  002d8	e8 00 00 00 00	 call	 ETOD2TOD
  002dd	48 8b c8	 mov	 rcx, rax
  002e0	e8 00 00 00 00	 call	 _byteswap_uint64
  002e5	48 8b 4c 24 50	 mov	 rcx, QWORD PTR hdrinfo$[rsp]
  002ea	48 83 c1 08	 add	 rcx, 8
  002ee	48 8b d0	 mov	 rdx, rax
  002f1	e8 00 00 00 00	 call	 store_dw_noswap

; 527  : 
; 528  :         /* hercules partition */
; 529  :         partinfo = (DIAG204_PART*)(hdrinfo + 1);

  002f6	48 8b 44 24 50	 mov	 rax, QWORD PTR hdrinfo$[rsp]
  002fb	48 83 c0 10	 add	 rax, 16
  002ff	48 89 44 24 60	 mov	 QWORD PTR partinfo$[rsp], rax

; 530  :         memset(partinfo, 0, sizeof(DIAG204_PART));

  00304	48 8b 7c 24 60	 mov	 rdi, QWORD PTR partinfo$[rsp]
  00309	33 c0		 xor	 eax, eax
  0030b	b9 10 00 00 00	 mov	 ecx, 16
  00310	f3 aa		 rep stosb

; 531  :         partinfo->partnum = sysblk.lparnum;     /* Hercules partition */

  00312	48 8b 44 24 60	 mov	 rax, QWORD PTR partinfo$[rsp]
  00317	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  0031e	0f b6 89 f0 00
	00 00		 movzx	 ecx, BYTE PTR [rcx+240]
  00325	88 08		 mov	 BYTE PTR [rax], cl

; 532  :         partinfo->virtcpu = sysblk.cpus;

  00327	48 8b 44 24 60	 mov	 rax, QWORD PTR partinfo$[rsp]
  0032c	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  00333	0f b6 89 04 01
	00 00		 movzx	 ecx, BYTE PTR [rcx+260]
  0033a	88 48 01	 mov	 BYTE PTR [rax+1], cl

; 533  :         get_lparname(partinfo->partname);

  0033d	48 8b 44 24 60	 mov	 rax, QWORD PTR partinfo$[rsp]
  00342	48 83 c0 08	 add	 rax, 8
  00346	48 8b c8	 mov	 rcx, rax
  00349	e8 00 00 00 00	 call	 get_lparname

; 534  : 
; 535  :         /* hercules cpu's */
; 536  :         cpuinfo = (DIAG204_PART_CPU*)(partinfo + 1);

  0034e	48 8b 44 24 60	 mov	 rax, QWORD PTR partinfo$[rsp]
  00353	48 83 c0 10	 add	 rax, 16
  00357	48 89 44 24 48	 mov	 QWORD PTR cpuinfo$[rsp], rax

; 537  :         for(i = 0; i < sysblk.maxcpu; i++)

  0035c	c7 44 24 40 00
	00 00 00	 mov	 DWORD PTR i$[rsp], 0
  00364	eb 0a		 jmp	 SHORT $LN9@s370_diag2
$LN7@s370_diag2:
  00366	8b 44 24 40	 mov	 eax, DWORD PTR i$[rsp]
  0036a	ff c0		 inc	 eax
  0036c	89 44 24 40	 mov	 DWORD PTR i$[rsp], eax
$LN9@s370_diag2:
  00370	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00377	8b 80 00 01 00
	00		 mov	 eax, DWORD PTR [rax+256]
  0037d	39 44 24 40	 cmp	 DWORD PTR i$[rsp], eax
  00381	0f 8d ee 00 00
	00		 jge	 $LN8@s370_diag2

; 538  :           if (IS_CPU_ONLINE(i))

  00387	48 63 44 24 40	 movsxd	 rax, DWORD PTR i$[rsp]
  0038c	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  00393	48 83 bc c1 98
	0b 00 00 00	 cmp	 QWORD PTR [rcx+rax*8+2968], 0
  0039c	0f 84 ce 00 00
	00		 je	 $LN18@s370_diag2

; 539  :           {
; 540  :               memset(cpuinfo, 0, sizeof(DIAG204_PART_CPU));

  003a2	48 8b 7c 24 48	 mov	 rdi, QWORD PTR cpuinfo$[rsp]
  003a7	33 c0		 xor	 eax, eax
  003a9	b9 18 00 00 00	 mov	 ecx, 24
  003ae	f3 aa		 rep stosb

; 541  :               STORE_HW(cpuinfo->cpaddr,sysblk.regs[i]->cpuad);

  003b0	48 63 44 24 40	 movsxd	 rax, DWORD PTR i$[rsp]
  003b5	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  003bc	48 8b 84 c1 98
	0b 00 00	 mov	 rax, QWORD PTR [rcx+rax*8+2968]
  003c4	0f b7 88 3c 08
	00 00		 movzx	 ecx, WORD PTR [rax+2108]
  003cb	e8 00 00 00 00	 call	 _byteswap_ushort
  003d0	48 8b 4c 24 48	 mov	 rcx, QWORD PTR cpuinfo$[rsp]
  003d5	0f b7 d0	 movzx	 edx, ax
  003d8	e8 00 00 00 00	 call	 store_hw_noswap

; 542  :               cpuinfo->index=sysblk.ptyp[i];

  003dd	48 63 44 24 40	 movsxd	 rax, DWORD PTR i$[rsp]
  003e2	48 8b 4c 24 48	 mov	 rcx, QWORD PTR cpuinfo$[rsp]
  003e7	48 8b 15 00 00
	00 00		 mov	 rdx, QWORD PTR __imp_sysblk
  003ee	0f b6 84 02 48
	0b 00 00	 movzx	 eax, BYTE PTR [rdx+rax+2888]
  003f6	88 41 04	 mov	 BYTE PTR [rcx+4], al

; 543  :               STORE_HW(cpuinfo->weight,100);

  003f9	66 b9 64 00	 mov	 cx, 100			; 00000064H
  003fd	e8 00 00 00 00	 call	 _byteswap_ushort
  00402	48 8b 4c 24 48	 mov	 rcx, QWORD PTR cpuinfo$[rsp]
  00407	48 83 c1 06	 add	 rcx, 6
  0040b	0f b7 d0	 movzx	 edx, ax
  0040e	e8 00 00 00 00	 call	 store_hw_noswap

; 544  :               STORE_DW(cpuinfo->totdispatch,tCPU[i]);

  00413	48 63 44 24 40	 movsxd	 rax, DWORD PTR i$[rsp]
  00418	48 8b 8c c4 b0
	02 00 00	 mov	 rcx, QWORD PTR tCPU$[rsp+rax*8]
  00420	e8 00 00 00 00	 call	 _byteswap_uint64
  00425	48 8b 4c 24 48	 mov	 rcx, QWORD PTR cpuinfo$[rsp]
  0042a	48 83 c1 08	 add	 rcx, 8
  0042e	48 8b d0	 mov	 rdx, rax
  00431	e8 00 00 00 00	 call	 store_dw_noswap

; 545  :               STORE_DW(cpuinfo->effdispatch, uCPU[i]);

  00436	48 63 44 24 40	 movsxd	 rax, DWORD PTR i$[rsp]
  0043b	48 8b 8c c4 b0
	00 00 00	 mov	 rcx, QWORD PTR uCPU$[rsp+rax*8]
  00443	e8 00 00 00 00	 call	 _byteswap_uint64
  00448	48 8b 4c 24 48	 mov	 rcx, QWORD PTR cpuinfo$[rsp]
  0044d	48 83 c1 10	 add	 rcx, 16
  00451	48 8b d0	 mov	 rdx, rax
  00454	e8 00 00 00 00	 call	 store_dw_noswap

; 546  :               cpuinfo->cflag=0x20;

  00459	48 8b 44 24 48	 mov	 rax, QWORD PTR cpuinfo$[rsp]
  0045e	c6 40 05 20	 mov	 BYTE PTR [rax+5], 32	; 00000020H

; 547  :               cpuinfo += 1;

  00462	48 8b 44 24 48	 mov	 rax, QWORD PTR cpuinfo$[rsp]
  00467	48 83 c0 18	 add	 rax, 24
  0046b	48 89 44 24 48	 mov	 QWORD PTR cpuinfo$[rsp], rax
$LN18@s370_diag2:

; 548  :           }

  00470	e9 f1 fe ff ff	 jmp	 $LN7@s370_diag2
$LN8@s370_diag2:

; 549  : 
; 550  : #if defined(FEATURE_PHYSICAL_DIAG204)
; 551  :         /* LPAR management */
; 552  :         /* FIXME: This section should report on the real CPUs, appearing
; 553  :          *        and transformed for reporting purposes. This should
; 554  :          *        also be properly reflected in STSI information.
; 555  :          */
; 556  :         partinfo = (DIAG204_PART*)cpuinfo;
; 557  :         memset(partinfo, 0, sizeof(DIAG204_PART));
; 558  :         partinfo->partnum = 0; /* Physical machine */
; 559  :         partinfo->virtcpu = sysblk.cpus;
; 560  :         memcpy(partinfo->partname,physical,sizeof(physical));
; 561  : 
; 562  :         /* report all emulated physical cpu's */
; 563  :         cpuinfo = (DIAG204_PART_CPU*)(partinfo + 1);
; 564  :         for(i = 0; i < sysblk.maxcpu; i++)
; 565  :           if (IS_CPU_ONLINE(i))
; 566  :           {
; 567  :               memset(cpuinfo, 0, sizeof(DIAG204_PART_CPU));
; 568  :               STORE_HW(cpuinfo->cpaddr,sysblk.regs[i]->cpuad);
; 569  :               cpuinfo->index = sysblk.ptyp[i];
; 570  :               STORE_HW(cpuinfo->weight,100);
; 571  :               STORE_DW(cpuinfo->totdispatch, tCPU[i]);
; 572  :               STORE_DW(cpuinfo->effdispatch, uCPU[i]);
; 573  :               cpuinfo += 1;
; 574  :           }
; 575  : #endif /*defined(FEATURE_PHYSICAL_DIAG204)*/
; 576  : 
; 577  :         regs->GR_L(r2) = 0;

  00475	48 63 84 24 e8
	04 00 00	 movsxd	 rax, DWORD PTR r2$[rsp]
  0047d	48 8b 8c 24 f0
	04 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00485	c7 84 c1 80 02
	00 00 00 00 00
	00		 mov	 DWORD PTR [rcx+rax*8+640], 0

; 578  : 
; 579  :         break;

  00490	e9 a6 00 00 00	 jmp	 $LN2@s370_diag2
$LN19@s370_diag2:
$LN12@s370_diag2:

; 580  : 
; 581  : #if defined(FEATURE_EXTENDED_DIAG204)
; 582  :     /* Extended subcode 5 returns the size of the data areas provided by extended subcodes 6 and 7 */
; 583  :     case 0x00010005:
; 584  :         i = sizeof(DIAG204_X_HDR) + ((sizeof(DIAG204_X_PART) + (sysblk.maxcpu * sizeof(DIAG204_X_PART_CPU))) * 2);
; 585  :         regs->GR_L(r2+1) = (i + PAGEFRAME_BYTEMASK) / PAGEFRAME_PAGESIZE;
; 586  :         regs->GR_L(r2) = 0;
; 587  : 
; 588  :         break;
; 589  : 
; 590  :     /* Provide extended information */
; 591  :     case 0x00010006:
; 592  :         /* We fall through as we do not have any secondary cpus (that we know of) */
; 593  : 
; 594  :     /* Provide extended information, including information about secondary CPUs */
; 595  :     case 0x00010007:
; 596  :         /* Program check if RMF data is not on a page boundary */
; 597  :         if ( (regs->GR_L(r1) & PAGEFRAME_BYTEMASK) != 0x000)
; 598  :             ARCH_DEP(program_interrupt) (regs, PGM_SPECIFICATION_EXCEPTION);
; 599  : 
; 600  :         /* Obtain absolute address of main storage block,
; 601  :            check protection, and set reference and change bits */
; 602  :         hdrxinfo = (DIAG204_X_HDR*)MADDR (GR_A(r1,regs), r1, regs, ACCTYPE_WRITE, regs->psw.pkey);
; 603  : 
; 604  :         /* Retrieve the TOD clock value */
; 605  :         etod_clock(regs, &ETOD, ETOD_extended);
; 606  : 
; 607  :         /* Get processor time(s) and leave out non-CPU processes and
; 608  :          * threads
; 609  :          */
; 610  :         for(i = 0; i < sysblk.maxcpu; ++i)
; 611  :         {
; 612  :             if (IS_CPU_ONLINE(i))
; 613  :             {
; 614  :                 oCPU[i] = ETOD_high64_to_usecs(ETOD.high - regs->tod_epoch - sysblk.cpucreateTOD[i]);
; 615  :                 /* Get CPU times in microseconds */
; 616  :                 if( clock_gettime(sysblk.cpuclockid[i], &cputime) == 0 )
; 617  :                 {
; 618  :                     uCPU[i] = timespec2usecs(&cputime);
; 619  :                     tCPU[i] = uCPU[i] + ETOD_high64_to_usecs(sysblk.regs[i]->waittime_accumulated
; 620  :                                               + sysblk.regs[i]->waittime ) ;
; 621  :                 }
; 622  :                 wCPU[i] = tCPU[i] - uCPU[i];
; 623  :             }
; 624  :         }
; 625  : 
; 626  :         memset(hdrxinfo, 0, sizeof(DIAG204_X_HDR));
; 627  :         hdrxinfo->numpart = 1;
; 628  : #if defined(FEATURE_PHYSICAL_DIAG204)
; 629  :         hdrxinfo->flags = DIAG204_X_PHYSICAL_PRESENT;
; 630  : #endif /*defined(FEATURE_PHYSICAL_DIAG204)*/
; 631  :         STORE_HW(hdrxinfo->physcpu,sysblk.cpus);
; 632  :         STORE_HW(hdrxinfo->offown,sizeof(DIAG204_X_HDR));
; 633  :         STORE_DW(hdrxinfo->diagstck1,ETOD.high);
; 634  :         STORE_DW(hdrxinfo->diagstck2,ETOD.low);
; 635  : 
; 636  :         /* hercules partition */
; 637  :         partxinfo = (DIAG204_X_PART*)(hdrxinfo + 1);
; 638  :         memset(partxinfo, 0, sizeof(DIAG204_X_PART));
; 639  :         partxinfo->partnum = sysblk.lparnum;    /* Hercules partition */
; 640  :         partxinfo->virtcpu = sysblk.cpus;
; 641  :         partxinfo->realcpu = hostinfo.num_procs;
; 642  :         get_lparname(partxinfo->partname);
; 643  :         get_sysname(partxinfo->cpcname);
; 644  :         get_systype(partxinfo->osname);
; 645  :         STORE_DW( partxinfo->cssize, sysblk.mainsize >> SHIFT_MEGABYTE );
; 646  :         STORE_DW( partxinfo->essize, sysblk.xpndsize >> SHIFT_MEGABYTE );
; 647  :         get_sysplex(partxinfo->gr_name);
; 648  : 
; 649  :         /* hercules cpu's */
; 650  :         cpuxinfo = (DIAG204_X_PART_CPU*)(partxinfo + 1);
; 651  :         for(i = 0; i < sysblk.maxcpu; i++)
; 652  :           if (IS_CPU_ONLINE(i))
; 653  :           {
; 654  :               memset(cpuxinfo, 0, sizeof(DIAG204_X_PART_CPU));
; 655  :               STORE_HW(cpuxinfo->cpaddr,sysblk.regs[i]->cpuad);
; 656  :               cpuxinfo->index = sysblk.ptyp[i];
; 657  :               STORE_HW(cpuxinfo->weight,100);
; 658  : 
; 659  :               STORE_DW(cpuxinfo->totdispatch, tCPU[i]);
; 660  :               STORE_DW(cpuxinfo->effdispatch, uCPU[i]);
; 661  : 
; 662  :               STORE_HW(cpuxinfo->minweight,1000);
; 663  :               STORE_HW(cpuxinfo->curweight,1000);
; 664  :               STORE_HW(cpuxinfo->maxweight,1000);
; 665  : 
; 666  :               STORE_DW(cpuxinfo->onlinetime, oCPU[i]);
; 667  :               STORE_DW(cpuxinfo->waittime,   wCPU[i]);
; 668  : 
; 669  :               STORE_HW(cpuxinfo->pmaweight,1000);
; 670  :               STORE_HW(cpuxinfo->polarweight,1000);
; 671  :               cpuxinfo->cflag=0x20;
; 672  : 
; 673  :               cpuxinfo += 1;
; 674  :           }
; 675  : 
; 676  : 
; 677  : #if defined(FEATURE_PHYSICAL_DIAG204)
; 678  :         /* LPAR management */
; 679  :         /* FIXME: This section should report on the real CPUs, appearing
; 680  :          *        and transformed for reporting purposes. This should
; 681  :          *        also be properly reflected in STSI information.
; 682  :          */
; 683  :         partxinfo = (DIAG204_X_PART*)cpuxinfo;
; 684  :         memset(partxinfo, 0, sizeof(DIAG204_X_PART));
; 685  :         partxinfo->partnum = 0; /* Physical machine */
; 686  :         partxinfo->virtcpu = sysblk.cpus;
; 687  :         partxinfo->realcpu = hostinfo.num_procs;
; 688  :         memcpy(partxinfo->partname,physical,sizeof(physical));
; 689  : 
; 690  :         /* report all emulated physical cpu's */
; 691  :         cpuxinfo = (DIAG204_PART_CPU*)(partinfo + 1);
; 692  :         for(i = 0; i < sysblk.maxcpu; i++)
; 693  :           if (IS_CPU_ONLINE(i))
; 694  :           {
; 695  :               memset(cpuxinfo, 0, sizeof(DIAG204_X_PART_CPU));
; 696  :               STORE_HW(cpuxinfo->cpaddr,sysblk.regs[i]->cpuad);
; 697  :               cpuxinfo->index = sysblk.ptyp[i];
; 698  :               STORE_HW(cpuxinfo->weight,100);
; 699  : 
; 700  :               STORE_DW(cpuxinfo->totdispatch, tCPU[i]);
; 701  :               STORE_DW(cpuxinfo->effdispatch, uCPU[i]);
; 702  : 
; 703  :               STORE_HW(cpuxinfo->minweight,1000);
; 704  :               STORE_HW(cpuxinfo->curweight,1000);
; 705  :               STORE_HW(cpuxinfo->maxweight,1000);
; 706  : 
; 707  :               STORE_DW(cpuxinfo->onlinetime, oCPU[i]);
; 708  :               STORE_DW(cpuxinfo->waittime,   wCPU[i]);
; 709  : 
; 710  :               STORE_HW(cpuxinfo->pmaweight,1000);
; 711  :               STORE_HW(cpuxinfo->polarweight,1000);
; 712  : 
; 713  :               cpuxinfo += 1;
; 714  :           }
; 715  : #endif /*defined(FEATURE_PHYSICAL_DIAG204)*/
; 716  : 
; 717  :         regs->GR_L(r2) = 0;
; 718  : 
; 719  :         break;
; 720  : #endif /*defined(FEATURE_EXTENDED_DIAG204)*/
; 721  : 
; 722  :     default:
; 723  :         PTT_ERR("*DIAG204",regs->GR_L(r1),regs->GR_L(r2),regs->psw.IA_L);

  00495	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_pttclass
  0049c	48 8b 00	 mov	 rax, QWORD PTR [rax]
  0049f	48 83 e0 10	 and	 rax, 16
  004a3	48 85 c0	 test	 rax, rax
  004a6	74 6e		 je	 SHORT $LN20@s370_diag2
  004a8	48 8b 84 24 f0
	04 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  004b0	8b 80 88 00 00
	00		 mov	 eax, DWORD PTR [rax+136]
  004b6	48 63 8c 24 e8
	04 00 00	 movsxd	 rcx, DWORD PTR r2$[rsp]
  004be	48 8b 94 24 f0
	04 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  004c6	8b 8c ca 80 02
	00 00		 mov	 ecx, DWORD PTR [rdx+rcx*8+640]
  004cd	48 63 94 24 e0
	04 00 00	 movsxd	 rdx, DWORD PTR r1$[rsp]
  004d5	48 8b bc 24 f0
	04 00 00	 mov	 rdi, QWORD PTR regs$[rsp]
  004dd	8b 94 d7 80 02
	00 00		 mov	 edx, DWORD PTR [rdi+rdx*8+640]
  004e4	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR [rsp+48], 0
  004ed	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  004f2	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG169690
  004f9	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  004fe	44 8b c9	 mov	 r9d, ecx
  00501	44 8b c2	 mov	 r8d, edx
  00504	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG169691
  0050b	b9 10 00 00 00	 mov	 ecx, 16
  00510	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ptt_pthread_trace
$LN20@s370_diag2:
  00516	33 c0		 xor	 eax, eax
  00518	85 c0		 test	 eax, eax
  0051a	0f 85 75 ff ff
	ff		 jne	 $LN12@s370_diag2

; 724  :         regs->GR_L(r2) = 4;

  00520	48 63 84 24 e8
	04 00 00	 movsxd	 rax, DWORD PTR r2$[rsp]
  00528	48 8b 8c 24 f0
	04 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00530	c7 84 c1 80 02
	00 00 04 00 00
	00		 mov	 DWORD PTR [rcx+rax*8+640], 4
$LN2@s370_diag2:

; 725  : 
; 726  :     } /*switch(regs->GR_L(r2))*/
; 727  : 
; 728  : } /* end function diag204_call */

  0053b	48 8b 8c 24 b0
	04 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  00543	48 33 cc	 xor	 rcx, rsp
  00546	e8 00 00 00 00	 call	 __security_check_cookie
  0054b	48 81 c4 c8 04
	00 00		 add	 rsp, 1224		; 000004c8H
  00552	5f		 pop	 rdi
  00553	5e		 pop	 rsi
  00554	c3		 ret	 0
s370_diag204_call ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\diagmssf.c
_TEXT	SEGMENT
s370_scpend_call PROC

; 265  : {

$LN3:
  00000	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 266  :         sched_yield();                  /* Just go to the dispatcher

  00004	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_sched_yield

; 267  :                                            for a minimum delay       */
; 268  : } /* end function scpend_call */

  0000a	48 83 c4 28	 add	 rsp, 40			; 00000028H
  0000e	c3		 ret	 0
s370_scpend_call ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\clock.h
_TEXT	SEGMENT
tv65 = 0
ts$ = 32
timespec2usecs PROC

; 246  : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 18	 sub	 rsp, 24

; 247  :     return ((ts->tv_sec) * 1000000 + ((ts->tv_nsec + 500) / 1000));

  00009	48 8b 44 24 20	 mov	 rax, QWORD PTR ts$[rsp]
  0000e	48 69 00 40 42
	0f 00		 imul	 rax, QWORD PTR [rax], 1000000 ; 000f4240H
  00015	48 89 04 24	 mov	 QWORD PTR tv65[rsp], rax
  00019	48 8b 4c 24 20	 mov	 rcx, QWORD PTR ts$[rsp]
  0001e	8b 49 08	 mov	 ecx, DWORD PTR [rcx+8]
  00021	81 c1 f4 01 00
	00		 add	 ecx, 500		; 000001f4H
  00027	8b c1		 mov	 eax, ecx
  00029	99		 cdq
  0002a	b9 e8 03 00 00	 mov	 ecx, 1000		; 000003e8H
  0002f	f7 f9		 idiv	 ecx
  00031	48 98		 cdqe
  00033	48 8b 0c 24	 mov	 rcx, QWORD PTR tv65[rsp]
  00037	48 03 c8	 add	 rcx, rax
  0003a	48 8b c1	 mov	 rax, rcx

; 248  : }

  0003d	48 83 c4 18	 add	 rsp, 24
  00041	c3		 ret	 0
timespec2usecs ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\clock.h
_TEXT	SEGMENT
etod$ = 8
ETOD_high64_to_usecs PROC

; 229  : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx

; 230  :     return (etod >> 4);

  00005	48 8b 44 24 08	 mov	 rax, QWORD PTR etod$[rsp]
  0000a	48 c1 f8 04	 sar	 rax, 4

; 231  : }

  0000e	c3		 ret	 0
ETOD_high64_to_usecs ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\clock.h
_TEXT	SEGMENT
ETOD$ = 8
ETOD2TOD PROC

; 205  : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx

; 206  :     return ((ETOD.high << 8) | (ETOD.low >> (64-8)));

  00005	48 8b 44 24 08	 mov	 rax, QWORD PTR ETOD$[rsp]
  0000a	48 8b 40 08	 mov	 rax, QWORD PTR [rax+8]
  0000e	48 c1 e0 08	 shl	 rax, 8
  00012	48 8b 4c 24 08	 mov	 rcx, QWORD PTR ETOD$[rsp]
  00017	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  0001a	48 c1 e9 38	 shr	 rcx, 56			; 00000038H
  0001e	48 0b c1	 or	 rax, rcx

; 207  : }

  00021	c3		 ret	 0
ETOD2TOD ENDP
_TEXT	ENDS
END
