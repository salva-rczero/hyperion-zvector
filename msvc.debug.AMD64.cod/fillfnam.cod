; Listing generated by Microsoft (R) Optimizing Compiler Version 19.34.31937.0 

include listing.inc

INCLUDELIB MSVCRTD
INCLUDELIB OLDNAMES

_DATA	SEGMENT
COMM	filterarray:QWORD
_DATA	ENDS
CONST	SEGMENT
CKD_ENDTRK DB	0ffH
	DB	0ffH
	DB	0ffH
	DB	0ffH
	DB	0ffH
	DB	0ffH
	DB	0ffH
	DB	0ffH
CONST	ENDS
PUBLIC	__local_stdio_printf_options
PUBLIC	_vsnprintf_l
PUBLIC	_vsprintf_l
PUBLIC	sprintf
PUBLIC	tab_pressed
PUBLIC	filter
EXTRN	strrchr:PROC
EXTRN	strlen:PROC
EXTRN	__imp_strncmp:PROC
EXTRN	__imp_strncpy:PROC
EXTRN	__imp_calloc:PROC
EXTRN	__imp_free:PROC
EXTRN	__imp_malloc:PROC
EXTRN	__imp_realloc:PROC
EXTRN	__imp___stdio_common_vsprintf:PROC
EXTRN	__imp__stat64:PROC
EXTRN	__imp_strlcpy:PROC
EXTRN	__imp_strlcat:PROC
EXTRN	__imp_scandir:PROC
EXTRN	__imp_alphasort:PROC
EXTRN	__imp_hostpath:PROC
EXTRN	__imp_w32_snprintf:PROC
EXTRN	__imp_logmsg:PROC
EXTRN	__GSHandlerCheck:PROC
EXTRN	__security_check_cookie:PROC
EXTRN	__security_cookie:QWORD
_DATA	SEGMENT
COMM	?_OptionsStorage@?1??__local_stdio_printf_options@@9@9:QWORD							; `__local_stdio_printf_options'::`2'::_OptionsStorage
_DATA	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$_vsnprintf_l DD imagerel $LN5
	DD	imagerel $LN5+118
	DD	imagerel $unwind$_vsnprintf_l
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$_vsprintf_l DD imagerel $LN3
	DD	imagerel $LN3+66
	DD	imagerel $unwind$_vsprintf_l
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$sprintf DD imagerel $LN3
	DD	imagerel $LN3+79
	DD	imagerel $unwind$sprintf
pdata	ENDS
pdata	SEGMENT
$pdata$tab_pressed DD imagerel $LN54
	DD	imagerel $LN54+2192
	DD	imagerel $unwind$tab_pressed
$pdata$filter DD imagerel $LN5
	DD	imagerel $LN5+81
	DD	imagerel $unwind$filter
pdata	ENDS
_DATA	SEGMENT
$SG159155 DB	'".\', 00H
$SG159156 DB	'.\', 00H
	ORG $+1
$SG159160 DB	'%s%s', 00H
	ORG $+3
$SG159161 DB	'%s', 00H
	ORG $+1
$SG159163 DB	'"', 00H
	ORG $+2
$SG159167 DB	'\', 00H
	ORG $+2
$SG159173 DB	'%s%s', 00H
	ORG $+3
$SG159174 DB	'%s', 00H
	ORG $+1
$SG159175 DB	'%s%s%s', 00H
	ORG $+1
$SG159176 DB	'%s', 0aH, 00H
_DATA	ENDS
voltbl	SEGMENT
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:tab_pressed
	DD	022H
	DD	0876H
voltbl	ENDS
xdata	SEGMENT
$unwind$tab_pressed DD 042a19H
	DD	0eb0118H
	DD	060107011H
	DD	imagerel __GSHandlerCheck
	DD	0740H
$unwind$filter DD 010901H
	DD	04209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$sprintf DD 011801H
	DD	06218H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$_vsprintf_l DD 011801H
	DD	06218H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$_vsnprintf_l DD 011801H
	DD	08218H
xdata	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\fillfnam.c
_TEXT	SEGMENT
ent$ = 48
filter	PROC

; 35   : {

$LN5:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 36   :   if (filterarray == NULL)

  00009	48 83 3d 00 00
	00 00 00	 cmp	 QWORD PTR filterarray, 0
  00011	75 07		 jne	 SHORT $LN2@filter

; 37   :     return(1);

  00013	b8 01 00 00 00	 mov	 eax, 1
  00018	eb 32		 jmp	 SHORT $LN1@filter
$LN2@filter:

; 38   :   if (strncmp(ent->d_name, filterarray, strlen(filterarray)) == 0)

  0001a	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR filterarray
  00021	e8 00 00 00 00	 call	 strlen
  00026	48 8b 4c 24 30	 mov	 rcx, QWORD PTR ent$[rsp]
  0002b	48 83 c1 04	 add	 rcx, 4
  0002f	4c 8b c0	 mov	 r8, rax
  00032	48 8b 15 00 00
	00 00		 mov	 rdx, QWORD PTR filterarray
  00039	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_strncmp
  0003f	85 c0		 test	 eax, eax
  00041	75 07		 jne	 SHORT $LN3@filter

; 39   :     return(1);

  00043	b8 01 00 00 00	 mov	 eax, 1
  00048	eb 02		 jmp	 SHORT $LN1@filter
$LN3@filter:

; 40   :   return(0);

  0004a	33 c0		 xor	 eax, eax
$LN1@filter:

; 41   : }

  0004c	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00050	c3		 ret	 0
filter	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\fillfnam.c
_TEXT	SEGMENT
i$ = 48
len$ = 52
namelist$ = 56
cmdoff$ = 64
within_quoted_string$ = 68
j$ = 72
n$ = 76
part2$ = 80
path$ = 88
buff$ = 96
tmp$ = 104
bl$ = 112
tv74 = 120
len2$ = 124
len1$ = 128
tv310 = 132
filename$ = 136
fullfilename$1 = 144
part1$ = 152
quote_pos$ = 160
pl$ = 168
tv188 = 176
tv185 = 184
tv329 = 192
tv334 = 200
part3$ = 208
tv347 = 216
buf$2 = 224
fullfilename$3 = 288
pathname$ = 560
result$ = 832
__$ArrayPad$ = 1856
cmdlinefull$ = 1904
cmdlinelen$ = 1912
cmdoffset$ = 1920
tab_pressed PROC

; 52   : int tab_pressed(char *cmdlinefull, size_t cmdlinelen, int *cmdoffset) {

$LN54:
  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	56		 push	 rsi
  00010	57		 push	 rdi
  00011	48 81 ec 58 07
	00 00		 sub	 rsp, 1880		; 00000758H
  00018	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  0001f	48 33 c4	 xor	 rax, rsp
  00022	48 89 84 24 40
	07 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 53   :   struct dirent **namelist;
; 54   :   int   n, i, j, len, len1, len2;
; 55   :   int   cmdoff = *(cmdoffset); /* for easy reading of source code */

  0002a	48 8b 84 24 80
	07 00 00	 mov	 rax, QWORD PTR cmdoffset$[rsp]
  00032	8b 00		 mov	 eax, DWORD PTR [rax]
  00034	89 44 24 40	 mov	 DWORD PTR cmdoff$[rsp], eax

; 56   :   char *part1, *part2, *part3;
; 57   :   char *buff;
; 58   :   char *filename, *path, *tmp;
; 59   :   char  result[1024];
; 60   :   char  pathname[MAX_PATH];
; 61   :   size_t    bl, pl;
; 62   : #ifdef _MSVC_
; 63   :   int within_quoted_string = 0;

  00038	c7 44 24 44 00
	00 00 00	 mov	 DWORD PTR within_quoted_string$[rsp], 0

; 64   :   int quote_pos;
; 65   : #endif
; 66   : 
; 67   :   /* part3 goes from cursor position to the end of line */
; 68   :   part3 = cmdlinefull + cmdoff;

  00040	48 63 44 24 40	 movsxd	 rax, DWORD PTR cmdoff$[rsp]
  00045	48 8b 8c 24 70
	07 00 00	 mov	 rcx, QWORD PTR cmdlinefull$[rsp]
  0004d	48 03 c8	 add	 rcx, rax
  00050	48 8b c1	 mov	 rax, rcx
  00053	48 89 84 24 d0
	00 00 00	 mov	 QWORD PTR part3$[rsp], rax

; 69   :   /* looking for ' ','@' or '=' backward, starting from cursor offset
; 70   :      I am not aware of any other delimiters which can be used in hercules */
; 71   :   /* (except for '"' (double quote) for the MSVC version of herc - Fish) */
; 72   : #ifdef _MSVC_
; 73   :   /* determine if tab was pressed within a quoted string */
; 74   :   for (i=0; i < cmdoff; i++)

  0005b	c7 44 24 30 00
	00 00 00	 mov	 DWORD PTR i$[rsp], 0
  00063	eb 0a		 jmp	 SHORT $LN4@tab_presse
$LN2@tab_presse:
  00065	8b 44 24 30	 mov	 eax, DWORD PTR i$[rsp]
  00069	ff c0		 inc	 eax
  0006b	89 44 24 30	 mov	 DWORD PTR i$[rsp], eax
$LN4@tab_presse:
  0006f	8b 44 24 40	 mov	 eax, DWORD PTR cmdoff$[rsp]
  00073	39 44 24 30	 cmp	 DWORD PTR i$[rsp], eax
  00077	7d 44		 jge	 SHORT $LN3@tab_presse

; 75   :       if ('\"' == cmdlinefull[i])

  00079	48 63 44 24 30	 movsxd	 rax, DWORD PTR i$[rsp]
  0007e	48 8b 8c 24 70
	07 00 00	 mov	 rcx, QWORD PTR cmdlinefull$[rsp]
  00086	0f be 04 01	 movsx	 eax, BYTE PTR [rcx+rax]
  0008a	83 f8 22	 cmp	 eax, 34			; 00000022H
  0008d	75 2c		 jne	 SHORT $LN23@tab_presse

; 76   :       {
; 77   :           within_quoted_string = !within_quoted_string;

  0008f	83 7c 24 44 00	 cmp	 DWORD PTR within_quoted_string$[rsp], 0
  00094	75 0a		 jne	 SHORT $LN50@tab_presse
  00096	c7 44 24 78 01
	00 00 00	 mov	 DWORD PTR tv74[rsp], 1
  0009e	eb 08		 jmp	 SHORT $LN51@tab_presse
$LN50@tab_presse:
  000a0	c7 44 24 78 00
	00 00 00	 mov	 DWORD PTR tv74[rsp], 0
$LN51@tab_presse:
  000a8	8b 44 24 78	 mov	 eax, DWORD PTR tv74[rsp]
  000ac	89 44 24 44	 mov	 DWORD PTR within_quoted_string$[rsp], eax

; 78   :           quote_pos = i; /* (save position of quote

  000b0	8b 44 24 30	 mov	 eax, DWORD PTR i$[rsp]
  000b4	89 84 24 a0 00
	00 00		 mov	 DWORD PTR quote_pos$[rsp], eax
$LN23@tab_presse:

; 79   :                          immediately preceding cmdoff) */
; 80   :       }

  000bb	eb a8		 jmp	 SHORT $LN2@tab_presse
$LN3@tab_presse:

; 81   :   if (within_quoted_string)

  000bd	83 7c 24 44 00	 cmp	 DWORD PTR within_quoted_string$[rsp], 0
  000c2	74 0d		 je	 SHORT $LN24@tab_presse

; 82   :     i = quote_pos; /* (the quote is our delimiter) */

  000c4	8b 84 24 a0 00
	00 00		 mov	 eax, DWORD PTR quote_pos$[rsp]
  000cb	89 44 24 30	 mov	 DWORD PTR i$[rsp], eax
  000cf	eb 63		 jmp	 SHORT $LN25@tab_presse
$LN24@tab_presse:

; 83   :   else
; 84   : #endif
; 85   :   for (i = cmdoff-1; i>=0; i--)

  000d1	8b 44 24 40	 mov	 eax, DWORD PTR cmdoff$[rsp]
  000d5	ff c8		 dec	 eax
  000d7	89 44 24 30	 mov	 DWORD PTR i$[rsp], eax
  000db	eb 0a		 jmp	 SHORT $LN7@tab_presse
$LN5@tab_presse:
  000dd	8b 44 24 30	 mov	 eax, DWORD PTR i$[rsp]
  000e1	ff c8		 dec	 eax
  000e3	89 44 24 30	 mov	 DWORD PTR i$[rsp], eax
$LN7@tab_presse:
  000e7	83 7c 24 30 00	 cmp	 DWORD PTR i$[rsp], 0
  000ec	7c 46		 jl	 SHORT $LN6@tab_presse

; 86   :     if (cmdlinefull[i] == ' '
; 87   :        || cmdlinefull[i] == '@'
; 88   :        || cmdlinefull[i] == '=')

  000ee	48 63 44 24 30	 movsxd	 rax, DWORD PTR i$[rsp]
  000f3	48 8b 8c 24 70
	07 00 00	 mov	 rcx, QWORD PTR cmdlinefull$[rsp]
  000fb	0f be 04 01	 movsx	 eax, BYTE PTR [rcx+rax]
  000ff	83 f8 20	 cmp	 eax, 32			; 00000020H
  00102	74 2c		 je	 SHORT $LN27@tab_presse
  00104	48 63 44 24 30	 movsxd	 rax, DWORD PTR i$[rsp]
  00109	48 8b 8c 24 70
	07 00 00	 mov	 rcx, QWORD PTR cmdlinefull$[rsp]
  00111	0f be 04 01	 movsx	 eax, BYTE PTR [rcx+rax]
  00115	83 f8 40	 cmp	 eax, 64			; 00000040H
  00118	74 16		 je	 SHORT $LN27@tab_presse
  0011a	48 63 44 24 30	 movsxd	 rax, DWORD PTR i$[rsp]
  0011f	48 8b 8c 24 70
	07 00 00	 mov	 rcx, QWORD PTR cmdlinefull$[rsp]
  00127	0f be 04 01	 movsx	 eax, BYTE PTR [rcx+rax]
  0012b	83 f8 3d	 cmp	 eax, 61			; 0000003dH
  0012e	75 02		 jne	 SHORT $LN26@tab_presse
$LN27@tab_presse:

; 89   :       break;

  00130	eb 02		 jmp	 SHORT $LN6@tab_presse
$LN26@tab_presse:
  00132	eb a9		 jmp	 SHORT $LN5@tab_presse
$LN6@tab_presse:
$LN25@tab_presse:

; 90   :   /* part1 is from beginning to found delimiter (including delimiter itself) */
; 91   :   part1 = (char*) malloc(i+2);

  00134	8b 44 24 30	 mov	 eax, DWORD PTR i$[rsp]
  00138	83 c0 02	 add	 eax, 2
  0013b	48 98		 cdqe
  0013d	48 8b c8	 mov	 rcx, rax
  00140	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_malloc
  00146	48 89 84 24 98
	00 00 00	 mov	 QWORD PTR part1$[rsp], rax

; 92   :   strncpy(part1, cmdlinefull, i+1);

  0014e	8b 44 24 30	 mov	 eax, DWORD PTR i$[rsp]
  00152	ff c0		 inc	 eax
  00154	48 98		 cdqe
  00156	4c 8b c0	 mov	 r8, rax
  00159	48 8b 94 24 70
	07 00 00	 mov	 rdx, QWORD PTR cmdlinefull$[rsp]
  00161	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR part1$[rsp]
  00169	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_strncpy

; 93   :   part1[i+1]= '\0';

  0016f	8b 44 24 30	 mov	 eax, DWORD PTR i$[rsp]
  00173	ff c0		 inc	 eax
  00175	48 98		 cdqe
  00177	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR part1$[rsp]
  0017f	c6 04 01 00	 mov	 BYTE PTR [rcx+rax], 0

; 94   : 
; 95   :   /* part2 is the interesting one */
; 96   :   part2 = (char*)malloc(cmdoff - i);

  00183	8b 44 24 30	 mov	 eax, DWORD PTR i$[rsp]
  00187	8b 4c 24 40	 mov	 ecx, DWORD PTR cmdoff$[rsp]
  0018b	2b c8		 sub	 ecx, eax
  0018d	8b c1		 mov	 eax, ecx
  0018f	48 98		 cdqe
  00191	48 8b c8	 mov	 rcx, rax
  00194	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_malloc
  0019a	48 89 44 24 50	 mov	 QWORD PTR part2$[rsp], rax

; 97   :   strncpy(part2, cmdlinefull + i + 1, cmdoff - i - 1);

  0019f	8b 44 24 30	 mov	 eax, DWORD PTR i$[rsp]
  001a3	8b 4c 24 40	 mov	 ecx, DWORD PTR cmdoff$[rsp]
  001a7	2b c8		 sub	 ecx, eax
  001a9	8b c1		 mov	 eax, ecx
  001ab	ff c8		 dec	 eax
  001ad	48 98		 cdqe
  001af	48 63 4c 24 30	 movsxd	 rcx, DWORD PTR i$[rsp]
  001b4	48 8b 94 24 70
	07 00 00	 mov	 rdx, QWORD PTR cmdlinefull$[rsp]
  001bc	48 8d 4c 0a 01	 lea	 rcx, QWORD PTR [rdx+rcx+1]
  001c1	4c 8b c0	 mov	 r8, rax
  001c4	48 8b d1	 mov	 rdx, rcx
  001c7	48 8b 4c 24 50	 mov	 rcx, QWORD PTR part2$[rsp]
  001cc	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_strncpy

; 98   :   part2[cmdoff - i - 1] = '\0';

  001d2	8b 44 24 30	 mov	 eax, DWORD PTR i$[rsp]
  001d6	8b 4c 24 40	 mov	 ecx, DWORD PTR cmdoff$[rsp]
  001da	2b c8		 sub	 ecx, eax
  001dc	8b c1		 mov	 eax, ecx
  001de	ff c8		 dec	 eax
  001e0	48 98		 cdqe
  001e2	48 8b 4c 24 50	 mov	 rcx, QWORD PTR part2$[rsp]
  001e7	c6 04 01 00	 mov	 BYTE PTR [rcx+rax], 0

; 99   : 
; 100  :   len = (int)strlen(part2);

  001eb	48 8b 4c 24 50	 mov	 rcx, QWORD PTR part2$[rsp]
  001f0	e8 00 00 00 00	 call	 strlen
  001f5	89 44 24 34	 mov	 DWORD PTR len$[rsp], eax

; 101  :   /* 3 characters minimum needed, for ./\0 in path. */
; 102  :   /* (or 4 chars for MSVC if within quoted string, for \"./\0 - Fish) */
; 103  : #ifdef _MSVC_
; 104  :   if (within_quoted_string)

  001f9	83 7c 24 44 00	 cmp	 DWORD PTR within_quoted_string$[rsp], 0
  001fe	74 11		 je	 SHORT $LN28@tab_presse

; 105  :   {
; 106  :     if (len < 3)

  00200	83 7c 24 34 03	 cmp	 DWORD PTR len$[rsp], 3
  00205	7d 08		 jge	 SHORT $LN30@tab_presse

; 107  :       len = 3;

  00207	c7 44 24 34 03
	00 00 00	 mov	 DWORD PTR len$[rsp], 3
$LN30@tab_presse:

; 108  :   }

  0020f	eb 0f		 jmp	 SHORT $LN29@tab_presse
$LN28@tab_presse:

; 109  :   else
; 110  : #endif
; 111  :   if (len < 2)

  00211	83 7c 24 34 02	 cmp	 DWORD PTR len$[rsp], 2
  00216	7d 08		 jge	 SHORT $LN31@tab_presse

; 112  :     len = 2;

  00218	c7 44 24 34 02
	00 00 00	 mov	 DWORD PTR len$[rsp], 2
$LN31@tab_presse:
$LN29@tab_presse:

; 113  :   pl = len + 1;

  00220	8b 44 24 34	 mov	 eax, DWORD PTR len$[rsp]
  00224	ff c0		 inc	 eax
  00226	48 98		 cdqe
  00228	48 89 84 24 a8
	00 00 00	 mov	 QWORD PTR pl$[rsp], rax

; 114  :   path = (char*)malloc(pl);

  00230	48 8b 8c 24 a8
	00 00 00	 mov	 rcx, QWORD PTR pl$[rsp]
  00238	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_malloc
  0023e	48 89 44 24 58	 mov	 QWORD PTR path$[rsp], rax

; 115  :   *path = '\0';

  00243	48 8b 44 24 58	 mov	 rax, QWORD PTR path$[rsp]
  00248	c6 00 00	 mov	 BYTE PTR [rax], 0

; 116  :   filename = part2;

  0024b	48 8b 44 24 50	 mov	 rax, QWORD PTR part2$[rsp]
  00250	48 89 84 24 88
	00 00 00	 mov	 QWORD PTR filename$[rsp], rax

; 117  :   /* is it pure filename or is there whole path ? */
; 118  : #ifdef _MSVC_
; 119  :   tmp = strrchr(part2, '\\');

  00258	ba 5c 00 00 00	 mov	 edx, 92			; 0000005cH
  0025d	48 8b 4c 24 50	 mov	 rcx, QWORD PTR part2$[rsp]
  00262	e8 00 00 00 00	 call	 strrchr
  00267	48 89 44 24 68	 mov	 QWORD PTR tmp$[rsp], rax

; 120  : #else
; 121  :   tmp = strrchr(part2, '/');
; 122  : #endif
; 123  : #ifdef _MSVC_
; 124  :   if (!tmp) tmp = strrchr(part2, '\\');

  0026c	48 83 7c 24 68
	00		 cmp	 QWORD PTR tmp$[rsp], 0
  00272	75 14		 jne	 SHORT $LN32@tab_presse
  00274	ba 5c 00 00 00	 mov	 edx, 92			; 0000005cH
  00279	48 8b 4c 24 50	 mov	 rcx, QWORD PTR part2$[rsp]
  0027e	e8 00 00 00 00	 call	 strrchr
  00283	48 89 44 24 68	 mov	 QWORD PTR tmp$[rsp], rax
$LN32@tab_presse:

; 125  : #endif
; 126  :   if (tmp != NULL) {

  00288	48 83 7c 24 68
	00		 cmp	 QWORD PTR tmp$[rsp], 0
  0028e	0f 84 96 00 00
	00		 je	 $LN33@tab_presse

; 127  :     filename = tmp + 1;

  00294	48 8b 44 24 68	 mov	 rax, QWORD PTR tmp$[rsp]
  00299	48 ff c0	 inc	 rax
  0029c	48 89 84 24 88
	00 00 00	 mov	 QWORD PTR filename$[rsp], rax

; 128  :     memcpy(path, part2, strlen(part2)-strlen(filename));

  002a4	48 8b 4c 24 50	 mov	 rcx, QWORD PTR part2$[rsp]
  002a9	e8 00 00 00 00	 call	 strlen
  002ae	48 89 84 24 b0
	00 00 00	 mov	 QWORD PTR tv188[rsp], rax
  002b6	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR filename$[rsp]
  002be	e8 00 00 00 00	 call	 strlen
  002c3	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR tv188[rsp]
  002cb	48 2b c8	 sub	 rcx, rax
  002ce	48 8b c1	 mov	 rax, rcx
  002d1	48 8b 7c 24 58	 mov	 rdi, QWORD PTR path$[rsp]
  002d6	48 8b 74 24 50	 mov	 rsi, QWORD PTR part2$[rsp]
  002db	48 8b c8	 mov	 rcx, rax
  002de	f3 a4		 rep movsb

; 129  :     path[strlen(part2)-strlen(filename)] = '\0';

  002e0	48 8b 4c 24 50	 mov	 rcx, QWORD PTR part2$[rsp]
  002e5	e8 00 00 00 00	 call	 strlen
  002ea	48 89 84 24 b8
	00 00 00	 mov	 QWORD PTR tv185[rsp], rax
  002f2	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR filename$[rsp]
  002fa	e8 00 00 00 00	 call	 strlen
  002ff	48 8b 8c 24 b8
	00 00 00	 mov	 rcx, QWORD PTR tv185[rsp]
  00307	48 2b c8	 sub	 rcx, rax
  0030a	48 8b c1	 mov	 rax, rcx
  0030d	48 8b 4c 24 58	 mov	 rcx, QWORD PTR path$[rsp]
  00312	c6 04 01 00	 mov	 BYTE PTR [rcx+rax], 0

; 130  :     tmp[0] = '\0';

  00316	b8 01 00 00 00	 mov	 eax, 1
  0031b	48 6b c0 00	 imul	 rax, rax, 0
  0031f	48 8b 4c 24 68	 mov	 rcx, QWORD PTR tmp$[rsp]
  00324	c6 04 01 00	 mov	 BYTE PTR [rcx+rax], 0

; 131  :   }

  00328	eb 3d		 jmp	 SHORT $LN34@tab_presse
$LN33@tab_presse:

; 132  :   else {
; 133  : #ifdef _MSVC_
; 134  :     if (within_quoted_string)

  0032a	83 7c 24 44 00	 cmp	 DWORD PTR within_quoted_string$[rsp], 0
  0032f	74 1c		 je	 SHORT $LN35@tab_presse

; 135  :         strlcpy(path,"\".\\",pl);

  00331	4c 8b 84 24 a8
	00 00 00	 mov	 r8, QWORD PTR pl$[rsp]
  00339	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG159155
  00340	48 8b 4c 24 58	 mov	 rcx, QWORD PTR path$[rsp]
  00345	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_strlcpy
  0034b	eb 1a		 jmp	 SHORT $LN36@tab_presse
$LN35@tab_presse:

; 136  :     else
; 137  :         strlcpy(path,".\\",pl);

  0034d	4c 8b 84 24 a8
	00 00 00	 mov	 r8, QWORD PTR pl$[rsp]
  00355	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG159156
  0035c	48 8b 4c 24 58	 mov	 rcx, QWORD PTR path$[rsp]
  00361	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_strlcpy
$LN36@tab_presse:
$LN34@tab_presse:

; 138  : #else
; 139  :         strlcpy(path,"./",pl);
; 140  : #endif
; 141  : 
; 142  :   }
; 143  :   /* this is used in filter function to include only relevant filenames */
; 144  :   filterarray = filename;

  00367	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR filename$[rsp]
  0036f	48 89 05 00 00
	00 00		 mov	 QWORD PTR filterarray, rax

; 145  : 
; 146  :   n = scandir(path, &namelist, filter, alphasort);

  00376	4c 8b 0d 00 00
	00 00		 mov	 r9, QWORD PTR __imp_alphasort
  0037d	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:filter
  00384	48 8d 54 24 38	 lea	 rdx, QWORD PTR namelist$[rsp]
  00389	48 8b 4c 24 58	 mov	 rcx, QWORD PTR path$[rsp]
  0038e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_scandir
  00394	89 44 24 4c	 mov	 DWORD PTR n$[rsp], eax

; 147  :   if (n > 0) {

  00398	83 7c 24 4c 00	 cmp	 DWORD PTR n$[rsp], 0
  0039d	0f 8e ad 04 00
	00		 jle	 $LN37@tab_presse

; 148  :     for (i=0; i<n; i++) {

  003a3	c7 44 24 30 00
	00 00 00	 mov	 DWORD PTR i$[rsp], 0
  003ab	eb 0a		 jmp	 SHORT $LN10@tab_presse
$LN8@tab_presse:
  003ad	8b 44 24 30	 mov	 eax, DWORD PTR i$[rsp]
  003b1	ff c0		 inc	 eax
  003b3	89 44 24 30	 mov	 DWORD PTR i$[rsp], eax
$LN10@tab_presse:
  003b7	8b 44 24 4c	 mov	 eax, DWORD PTR n$[rsp]
  003bb	39 44 24 30	 cmp	 DWORD PTR i$[rsp], eax
  003bf	0f 8d 51 01 00
	00		 jge	 $LN9@tab_presse

; 149  :       struct stat buf;
; 150  :       char fullfilename[1+MAX_PATH+1];
; 151  :       /* namelist[i]->d_name contains filtered filenames, check if they are
; 152  :          directories with stat(), before that create whole path */
; 153  :       if (tmp != NULL)

  003c5	48 83 7c 24 68
	00		 cmp	 QWORD PTR tmp$[rsp], 0
  003cb	74 30		 je	 SHORT $LN38@tab_presse

; 154  :          sprintf(fullfilename, "%s%s", path, namelist[i]->d_name);

  003cd	48 63 44 24 30	 movsxd	 rax, DWORD PTR i$[rsp]
  003d2	48 8b 4c 24 38	 mov	 rcx, QWORD PTR namelist$[rsp]
  003d7	48 8b 04 c1	 mov	 rax, QWORD PTR [rcx+rax*8]
  003db	48 83 c0 04	 add	 rax, 4
  003df	4c 8b c8	 mov	 r9, rax
  003e2	4c 8b 44 24 58	 mov	 r8, QWORD PTR path$[rsp]
  003e7	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG159160
  003ee	48 8d 8c 24 20
	01 00 00	 lea	 rcx, QWORD PTR fullfilename$3[rsp]
  003f6	e8 00 00 00 00	 call	 sprintf
  003fb	eb 29		 jmp	 SHORT $LN39@tab_presse
$LN38@tab_presse:

; 155  :       else
; 156  :          sprintf(fullfilename, "%s", namelist[i]->d_name);

  003fd	48 63 44 24 30	 movsxd	 rax, DWORD PTR i$[rsp]
  00402	48 8b 4c 24 38	 mov	 rcx, QWORD PTR namelist$[rsp]
  00407	48 8b 04 c1	 mov	 rax, QWORD PTR [rcx+rax*8]
  0040b	48 83 c0 04	 add	 rax, 4
  0040f	4c 8b c0	 mov	 r8, rax
  00412	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG159161
  00419	48 8d 8c 24 20
	01 00 00	 lea	 rcx, QWORD PTR fullfilename$3[rsp]
  00421	e8 00 00 00 00	 call	 sprintf
$LN39@tab_presse:

; 157  : #ifdef _MSVC_
; 158  :       if (within_quoted_string)

  00426	83 7c 24 44 00	 cmp	 DWORD PTR within_quoted_string$[rsp], 0
  0042b	74 1b		 je	 SHORT $LN40@tab_presse

; 159  :         STRLCAT( fullfilename, "\"" );

  0042d	41 b8 06 01 00
	00		 mov	 r8d, 262		; 00000106H
  00433	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG159163
  0043a	48 8d 8c 24 20
	01 00 00	 lea	 rcx, QWORD PTR fullfilename$3[rsp]
  00442	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_strlcat
$LN40@tab_presse:

; 160  : #endif
; 161  :       /* if it is a directory, add '/' to the end so it can be seen on screen*/
; 162  :       hostpath(pathname, fullfilename, sizeof(pathname));

  00448	41 b8 04 01 00
	00		 mov	 r8d, 260		; 00000104H
  0044e	48 8d 94 24 20
	01 00 00	 lea	 rdx, QWORD PTR fullfilename$3[rsp]
  00456	48 8d 8c 24 30
	02 00 00	 lea	 rcx, QWORD PTR pathname$[rsp]
  0045e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hostpath

; 163  :       if (stat(pathname,&buf) == 0)

  00464	48 8d 94 24 e0
	00 00 00	 lea	 rdx, QWORD PTR buf$2[rsp]
  0046c	48 8d 8c 24 30
	02 00 00	 lea	 rcx, QWORD PTR pathname$[rsp]
  00474	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__stat64
  0047a	85 c0		 test	 eax, eax
  0047c	0f 85 8f 00 00
	00		 jne	 $LN41@tab_presse

; 164  :          if (buf.st_mode & S_IFDIR) {

  00482	0f b7 84 24 e6
	00 00 00	 movzx	 eax, WORD PTR buf$2[rsp+6]
  0048a	25 00 40 00 00	 and	 eax, 16384		; 00004000H
  0048f	85 c0		 test	 eax, eax
  00491	74 7e		 je	 SHORT $LN42@tab_presse

; 165  : //          STRLCAT( namelist[i]->d_name, "/" );
; 166  : // Don't write past end of d_name
; 167  : // Problem debugged by bb5ch39t
; 168  :             namelist[i] = realloc(namelist[i], sizeof(struct dirent)

  00493	48 63 44 24 30	 movsxd	 rax, DWORD PTR i$[rsp]
  00498	48 8b 4c 24 38	 mov	 rcx, QWORD PTR namelist$[rsp]
  0049d	48 8b 04 c1	 mov	 rax, QWORD PTR [rcx+rax*8]
  004a1	48 83 c0 04	 add	 rax, 4
  004a5	48 8b c8	 mov	 rcx, rax
  004a8	e8 00 00 00 00	 call	 strlen
  004ad	48 05 0e 01 00
	00		 add	 rax, 270		; 0000010eH
  004b3	48 63 4c 24 30	 movsxd	 rcx, DWORD PTR i$[rsp]
  004b8	48 8b d0	 mov	 rdx, rax
  004bb	48 8b 44 24 38	 mov	 rax, QWORD PTR namelist$[rsp]
  004c0	48 8b 0c c8	 mov	 rcx, QWORD PTR [rax+rcx*8]
  004c4	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_realloc
  004ca	48 63 4c 24 30	 movsxd	 rcx, DWORD PTR i$[rsp]
  004cf	48 8b 54 24 38	 mov	 rdx, QWORD PTR namelist$[rsp]
  004d4	48 89 04 ca	 mov	 QWORD PTR [rdx+rcx*8], rax

; 169  :                                 + strlen(namelist[i]->d_name) + 2);
; 170  :             if (namelist[i])

  004d8	48 63 44 24 30	 movsxd	 rax, DWORD PTR i$[rsp]
  004dd	48 8b 4c 24 38	 mov	 rcx, QWORD PTR namelist$[rsp]
  004e2	48 83 3c c1 00	 cmp	 QWORD PTR [rcx+rax*8], 0
  004e7	74 28		 je	 SHORT $LN43@tab_presse

; 171  : #ifdef _MSVC_
; 172  :                STRLCAT( namelist[i]->d_name, "\\" );

  004e9	48 63 44 24 30	 movsxd	 rax, DWORD PTR i$[rsp]
  004ee	48 8b 4c 24 38	 mov	 rcx, QWORD PTR namelist$[rsp]
  004f3	48 8b 04 c1	 mov	 rax, QWORD PTR [rcx+rax*8]
  004f7	48 83 c0 04	 add	 rax, 4
  004fb	41 b8 05 01 00
	00		 mov	 r8d, 261		; 00000105H
  00501	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG159167
  00508	48 8b c8	 mov	 rcx, rax
  0050b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_strlcat
$LN43@tab_presse:
$LN42@tab_presse:
$LN41@tab_presse:

; 173  : #else
; 174  :                STRLCAT( namelist[i]->d_name, "/" );
; 175  : #endif
; 176  :          }
; 177  :     }

  00511	e9 97 fe ff ff	 jmp	 $LN8@tab_presse
$LN9@tab_presse:

; 178  :     /* now check, if filenames have something in common, after a cycle buff
; 179  :        contains maximal intersection of names */
; 180  :     bl = (size_t)(strlen(namelist[0]->d_name) + 1);

  00516	b8 08 00 00 00	 mov	 eax, 8
  0051b	48 6b c0 00	 imul	 rax, rax, 0
  0051f	48 8b 4c 24 38	 mov	 rcx, QWORD PTR namelist$[rsp]
  00524	48 8b 04 01	 mov	 rax, QWORD PTR [rcx+rax]
  00528	48 83 c0 04	 add	 rax, 4
  0052c	48 8b c8	 mov	 rcx, rax
  0052f	e8 00 00 00 00	 call	 strlen
  00534	48 ff c0	 inc	 rax
  00537	48 89 44 24 70	 mov	 QWORD PTR bl$[rsp], rax

; 181  :     buff = (char*)malloc(bl); /* first one */

  0053c	48 8b 4c 24 70	 mov	 rcx, QWORD PTR bl$[rsp]
  00541	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_malloc
  00547	48 89 44 24 60	 mov	 QWORD PTR buff$[rsp], rax

; 182  :     strlcpy(buff, namelist[0]->d_name,bl);

  0054c	b8 08 00 00 00	 mov	 eax, 8
  00551	48 6b c0 00	 imul	 rax, rax, 0
  00555	48 8b 4c 24 38	 mov	 rcx, QWORD PTR namelist$[rsp]
  0055a	48 8b 04 01	 mov	 rax, QWORD PTR [rcx+rax]
  0055e	48 83 c0 04	 add	 rax, 4
  00562	4c 8b 44 24 70	 mov	 r8, QWORD PTR bl$[rsp]
  00567	48 8b d0	 mov	 rdx, rax
  0056a	48 8b 4c 24 60	 mov	 rcx, QWORD PTR buff$[rsp]
  0056f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_strlcpy

; 183  :     for (i = 1; i < n; i++) {

  00575	c7 44 24 30 01
	00 00 00	 mov	 DWORD PTR i$[rsp], 1
  0057d	eb 0a		 jmp	 SHORT $LN13@tab_presse
$LN11@tab_presse:
  0057f	8b 44 24 30	 mov	 eax, DWORD PTR i$[rsp]
  00583	ff c0		 inc	 eax
  00585	89 44 24 30	 mov	 DWORD PTR i$[rsp], eax
$LN13@tab_presse:
  00589	8b 44 24 4c	 mov	 eax, DWORD PTR n$[rsp]
  0058d	39 44 24 30	 cmp	 DWORD PTR i$[rsp], eax
  00591	0f 8d c1 00 00
	00		 jge	 $LN12@tab_presse

; 184  :       len1 = (int)strlen(buff);

  00597	48 8b 4c 24 60	 mov	 rcx, QWORD PTR buff$[rsp]
  0059c	e8 00 00 00 00	 call	 strlen
  005a1	89 84 24 80 00
	00 00		 mov	 DWORD PTR len1$[rsp], eax

; 185  :       len2 = (int)strlen(namelist[i]->d_name);

  005a8	48 63 44 24 30	 movsxd	 rax, DWORD PTR i$[rsp]
  005ad	48 8b 4c 24 38	 mov	 rcx, QWORD PTR namelist$[rsp]
  005b2	48 8b 04 c1	 mov	 rax, QWORD PTR [rcx+rax*8]
  005b6	48 83 c0 04	 add	 rax, 4
  005ba	48 8b c8	 mov	 rcx, rax
  005bd	e8 00 00 00 00	 call	 strlen
  005c2	89 44 24 7c	 mov	 DWORD PTR len2$[rsp], eax

; 186  :       /* check number of characters in shorter one */
; 187  :       len = len1 > len2 ? len2 : len1;

  005c6	8b 44 24 7c	 mov	 eax, DWORD PTR len2$[rsp]
  005ca	39 84 24 80 00
	00 00		 cmp	 DWORD PTR len1$[rsp], eax
  005d1	7e 0d		 jle	 SHORT $LN52@tab_presse
  005d3	8b 44 24 7c	 mov	 eax, DWORD PTR len2$[rsp]
  005d7	89 84 24 84 00
	00 00		 mov	 DWORD PTR tv310[rsp], eax
  005de	eb 0e		 jmp	 SHORT $LN53@tab_presse
$LN52@tab_presse:
  005e0	8b 84 24 80 00
	00 00		 mov	 eax, DWORD PTR len1$[rsp]
  005e7	89 84 24 84 00
	00 00		 mov	 DWORD PTR tv310[rsp], eax
$LN53@tab_presse:
  005ee	8b 84 24 84 00
	00 00		 mov	 eax, DWORD PTR tv310[rsp]
  005f5	89 44 24 34	 mov	 DWORD PTR len$[rsp], eax

; 188  :       for (j = 0; j < len; j++)

  005f9	c7 44 24 48 00
	00 00 00	 mov	 DWORD PTR j$[rsp], 0
  00601	eb 0a		 jmp	 SHORT $LN16@tab_presse
$LN14@tab_presse:
  00603	8b 44 24 48	 mov	 eax, DWORD PTR j$[rsp]
  00607	ff c0		 inc	 eax
  00609	89 44 24 48	 mov	 DWORD PTR j$[rsp], eax
$LN16@tab_presse:
  0060d	8b 44 24 34	 mov	 eax, DWORD PTR len$[rsp]
  00611	39 44 24 48	 cmp	 DWORD PTR j$[rsp], eax
  00615	7d 3c		 jge	 SHORT $LN15@tab_presse

; 189  :       if (buff[j] != namelist[i]->d_name[j]) {

  00617	48 63 44 24 48	 movsxd	 rax, DWORD PTR j$[rsp]
  0061c	48 8b 4c 24 60	 mov	 rcx, QWORD PTR buff$[rsp]
  00621	0f be 04 01	 movsx	 eax, BYTE PTR [rcx+rax]
  00625	48 63 4c 24 30	 movsxd	 rcx, DWORD PTR i$[rsp]
  0062a	48 8b 54 24 38	 mov	 rdx, QWORD PTR namelist$[rsp]
  0062f	48 8b 0c ca	 mov	 rcx, QWORD PTR [rdx+rcx*8]
  00633	48 63 54 24 48	 movsxd	 rdx, DWORD PTR j$[rsp]
  00638	0f be 4c 11 04	 movsx	 ecx, BYTE PTR [rcx+rdx+4]
  0063d	3b c1		 cmp	 eax, ecx
  0063f	74 10		 je	 SHORT $LN44@tab_presse

; 190  :         buff[j] = '\0'; /* end the string where characters are not equal */

  00641	48 63 44 24 48	 movsxd	 rax, DWORD PTR j$[rsp]
  00646	48 8b 4c 24 60	 mov	 rcx, QWORD PTR buff$[rsp]
  0064b	c6 04 01 00	 mov	 BYTE PTR [rcx+rax], 0

; 191  :         break;

  0064f	eb 02		 jmp	 SHORT $LN15@tab_presse
$LN44@tab_presse:

; 192  :       }

  00651	eb b0		 jmp	 SHORT $LN14@tab_presse
$LN15@tab_presse:

; 193  :     }

  00653	e9 27 ff ff ff	 jmp	 $LN11@tab_presse
$LN12@tab_presse:

; 194  :     /* if maximal intersection of filenames is longer then original filename */
; 195  :     if (strlen(buff) > strlen(filename)) {

  00658	48 8b 4c 24 60	 mov	 rcx, QWORD PTR buff$[rsp]
  0065d	e8 00 00 00 00	 call	 strlen
  00662	48 89 84 24 c0
	00 00 00	 mov	 QWORD PTR tv329[rsp], rax
  0066a	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR filename$[rsp]
  00672	e8 00 00 00 00	 call	 strlen
  00677	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR tv329[rsp]
  0067f	48 3b c8	 cmp	 rcx, rax
  00682	0f 86 3c 01 00
	00		 jbe	 $LN45@tab_presse

; 196  :       char *fullfilename;
; 197  : 
; 198  :       bl = (size_t)(strlen(path) + strlen(buff) + 2);

  00688	48 8b 4c 24 58	 mov	 rcx, QWORD PTR path$[rsp]
  0068d	e8 00 00 00 00	 call	 strlen
  00692	48 89 84 24 c8
	00 00 00	 mov	 QWORD PTR tv334[rsp], rax
  0069a	48 8b 4c 24 60	 mov	 rcx, QWORD PTR buff$[rsp]
  0069f	e8 00 00 00 00	 call	 strlen
  006a4	48 8b 8c 24 c8
	00 00 00	 mov	 rcx, QWORD PTR tv334[rsp]
  006ac	48 8d 44 01 02	 lea	 rax, QWORD PTR [rcx+rax+2]
  006b1	48 89 44 24 70	 mov	 QWORD PTR bl$[rsp], rax

; 199  :       fullfilename = (char*)calloc(1,bl);

  006b6	48 8b 54 24 70	 mov	 rdx, QWORD PTR bl$[rsp]
  006bb	b9 01 00 00 00	 mov	 ecx, 1
  006c0	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_calloc
  006c6	48 89 84 24 90
	00 00 00	 mov	 QWORD PTR fullfilename$1[rsp], rax

; 200  : 
; 201  :       /* this test is not useless as path contains './' if there was no path
; 202  :          in original filename. it is because of scandir function, which
; 203  :          needs path portion */
; 204  :       if (tmp != NULL)

  006ce	48 83 7c 24 68
	00		 cmp	 QWORD PTR tmp$[rsp], 0
  006d4	74 2b		 je	 SHORT $LN47@tab_presse

; 205  :          snprintf(fullfilename, bl, "%s%s", path, buff);

  006d6	48 8b 44 24 60	 mov	 rax, QWORD PTR buff$[rsp]
  006db	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  006e0	4c 8b 4c 24 58	 mov	 r9, QWORD PTR path$[rsp]
  006e5	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG159173
  006ec	48 8b 54 24 70	 mov	 rdx, QWORD PTR bl$[rsp]
  006f1	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR fullfilename$1[rsp]
  006f9	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_snprintf
  006ff	eb 1f		 jmp	 SHORT $LN48@tab_presse
$LN47@tab_presse:

; 206  :       else
; 207  :          snprintf(fullfilename, bl, "%s", buff);

  00701	4c 8b 4c 24 60	 mov	 r9, QWORD PTR buff$[rsp]
  00706	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG159174
  0070d	48 8b 54 24 70	 mov	 rdx, QWORD PTR bl$[rsp]
  00712	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR fullfilename$1[rsp]
  0071a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_snprintf
$LN48@tab_presse:

; 208  :       /* construct command line */
; 209  :       snprintf(result, sizeof(result), "%s%s%s", part1, fullfilename, part3);

  00720	48 8b 84 24 d0
	00 00 00	 mov	 rax, QWORD PTR part3$[rsp]
  00728	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  0072d	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR fullfilename$1[rsp]
  00735	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  0073a	4c 8b 8c 24 98
	00 00 00	 mov	 r9, QWORD PTR part1$[rsp]
  00742	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG159175
  00749	ba 00 04 00 00	 mov	 edx, 1024		; 00000400H
  0074e	48 8d 8c 24 40
	03 00 00	 lea	 rcx, QWORD PTR result$[rsp]
  00756	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_snprintf

; 210  :       /* move cursor */
; 211  :       *(cmdoffset) = (int)(strlen(part1) + strlen(fullfilename));

  0075c	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR part1$[rsp]
  00764	e8 00 00 00 00	 call	 strlen
  00769	48 89 84 24 d8
	00 00 00	 mov	 QWORD PTR tv347[rsp], rax
  00771	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR fullfilename$1[rsp]
  00779	e8 00 00 00 00	 call	 strlen
  0077e	48 8b 8c 24 d8
	00 00 00	 mov	 rcx, QWORD PTR tv347[rsp]
  00786	48 03 c8	 add	 rcx, rax
  00789	48 8b c1	 mov	 rax, rcx
  0078c	48 8b 8c 24 80
	07 00 00	 mov	 rcx, QWORD PTR cmdoffset$[rsp]
  00794	89 01		 mov	 DWORD PTR [rcx], eax

; 212  :       strlcpy(cmdlinefull, result, cmdlinelen);

  00796	4c 8b 84 24 78
	07 00 00	 mov	 r8, QWORD PTR cmdlinelen$[rsp]
  0079e	48 8d 94 24 40
	03 00 00	 lea	 rdx, QWORD PTR result$[rsp]
  007a6	48 8b 8c 24 70
	07 00 00	 mov	 rcx, QWORD PTR cmdlinefull$[rsp]
  007ae	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_strlcpy

; 213  :       free(fullfilename);

  007b4	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR fullfilename$1[rsp]
  007bc	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free

; 214  :     }

  007c2	eb 42		 jmp	 SHORT $LN46@tab_presse
$LN45@tab_presse:

; 215  :     else
; 216  :     {
; 217  :       /* display all alternatives */
; 218  :       for (i = 0; i< n; i++)

  007c4	c7 44 24 30 00
	00 00 00	 mov	 DWORD PTR i$[rsp], 0
  007cc	eb 0a		 jmp	 SHORT $LN19@tab_presse
$LN17@tab_presse:
  007ce	8b 44 24 30	 mov	 eax, DWORD PTR i$[rsp]
  007d2	ff c0		 inc	 eax
  007d4	89 44 24 30	 mov	 DWORD PTR i$[rsp], eax
$LN19@tab_presse:
  007d8	8b 44 24 4c	 mov	 eax, DWORD PTR n$[rsp]
  007dc	39 44 24 30	 cmp	 DWORD PTR i$[rsp], eax
  007e0	7d 24		 jge	 SHORT $LN18@tab_presse

; 219  :          logmsg("%s\n", namelist[i]->d_name);

  007e2	48 63 44 24 30	 movsxd	 rax, DWORD PTR i$[rsp]
  007e7	48 8b 4c 24 38	 mov	 rcx, QWORD PTR namelist$[rsp]
  007ec	48 8b 04 c1	 mov	 rax, QWORD PTR [rcx+rax*8]
  007f0	48 83 c0 04	 add	 rax, 4
  007f4	48 8b d0	 mov	 rdx, rax
  007f7	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159176
  007fe	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_logmsg
  00804	eb c8		 jmp	 SHORT $LN17@tab_presse
$LN18@tab_presse:
$LN46@tab_presse:

; 220  :     }
; 221  :     /* free everything */
; 222  :     free(buff);

  00806	48 8b 4c 24 60	 mov	 rcx, QWORD PTR buff$[rsp]
  0080b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free

; 223  :     for (i = 0; i< n; i++)

  00811	c7 44 24 30 00
	00 00 00	 mov	 DWORD PTR i$[rsp], 0
  00819	eb 0a		 jmp	 SHORT $LN22@tab_presse
$LN20@tab_presse:
  0081b	8b 44 24 30	 mov	 eax, DWORD PTR i$[rsp]
  0081f	ff c0		 inc	 eax
  00821	89 44 24 30	 mov	 DWORD PTR i$[rsp], eax
$LN22@tab_presse:
  00825	8b 44 24 4c	 mov	 eax, DWORD PTR n$[rsp]
  00829	39 44 24 30	 cmp	 DWORD PTR i$[rsp], eax
  0082d	7d 16		 jge	 SHORT $LN21@tab_presse

; 224  :       free(namelist[i]);

  0082f	48 63 44 24 30	 movsxd	 rax, DWORD PTR i$[rsp]
  00834	48 8b 4c 24 38	 mov	 rcx, QWORD PTR namelist$[rsp]
  00839	48 8b 0c c1	 mov	 rcx, QWORD PTR [rcx+rax*8]
  0083d	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free
  00843	eb d6		 jmp	 SHORT $LN20@tab_presse
$LN21@tab_presse:

; 225  :     free(namelist);

  00845	48 8b 4c 24 38	 mov	 rcx, QWORD PTR namelist$[rsp]
  0084a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free
$LN37@tab_presse:

; 226  : 
; 227  :   }
; 228  :   free(part1);

  00850	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR part1$[rsp]
  00858	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free

; 229  :   free(part2);

  0085e	48 8b 4c 24 50	 mov	 rcx, QWORD PTR part2$[rsp]
  00863	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free

; 230  :   free(path);

  00869	48 8b 4c 24 58	 mov	 rcx, QWORD PTR path$[rsp]
  0086e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free

; 231  :   return(0);

  00874	33 c0		 xor	 eax, eax

; 232  : }

  00876	48 8b 8c 24 40
	07 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  0087e	48 33 cc	 xor	 rcx, rsp
  00881	e8 00 00 00 00	 call	 __security_check_cookie
  00886	48 81 c4 58 07
	00 00		 add	 rsp, 1880		; 00000758H
  0088d	5f		 pop	 rdi
  0088e	5e		 pop	 rsi
  0088f	c3		 ret	 0
tab_pressed ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files (x86)\Windows Kits\10\include\10.0.22000.0\ucrt\stdio.h
;	COMDAT sprintf
_TEXT	SEGMENT
_Result$ = 32
_ArgList$ = 40
_Buffer$ = 64
_Format$ = 72
sprintf	PROC						; COMDAT

; 1771 :     {

$LN3:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000f	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00014	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 1772 :         int _Result;
; 1773 :         va_list _ArgList;
; 1774 :         __crt_va_start(_ArgList, _Format);

  00018	48 8d 44 24 50	 lea	 rax, QWORD PTR _Format$[rsp+8]
  0001d	48 89 44 24 28	 mov	 QWORD PTR _ArgList$[rsp], rax

; 1775 : 
; 1776 :         _Result = _vsprintf_l(_Buffer, _Format, NULL, _ArgList);

  00022	4c 8b 4c 24 28	 mov	 r9, QWORD PTR _ArgList$[rsp]
  00027	45 33 c0	 xor	 r8d, r8d
  0002a	48 8b 54 24 48	 mov	 rdx, QWORD PTR _Format$[rsp]
  0002f	48 8b 4c 24 40	 mov	 rcx, QWORD PTR _Buffer$[rsp]
  00034	e8 00 00 00 00	 call	 _vsprintf_l
  00039	89 44 24 20	 mov	 DWORD PTR _Result$[rsp], eax

; 1777 : 
; 1778 :         __crt_va_end(_ArgList);

  0003d	48 c7 44 24 28
	00 00 00 00	 mov	 QWORD PTR _ArgList$[rsp], 0

; 1779 :         return _Result;

  00046	8b 44 24 20	 mov	 eax, DWORD PTR _Result$[rsp]

; 1780 :     }

  0004a	48 83 c4 38	 add	 rsp, 56			; 00000038H
  0004e	c3		 ret	 0
sprintf	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files (x86)\Windows Kits\10\include\10.0.22000.0\ucrt\stdio.h
;	COMDAT _vsprintf_l
_TEXT	SEGMENT
_Buffer$ = 64
_Format$ = 72
_Locale$ = 80
_ArgList$ = 88
_vsprintf_l PROC					; COMDAT

; 1458 :     {

$LN3:
  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 1459 :         return _vsnprintf_l(_Buffer, (size_t)-1, _Format, _Locale, _ArgList);

  00018	48 8b 44 24 58	 mov	 rax, QWORD PTR _ArgList$[rsp]
  0001d	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00022	4c 8b 4c 24 50	 mov	 r9, QWORD PTR _Locale$[rsp]
  00027	4c 8b 44 24 48	 mov	 r8, QWORD PTR _Format$[rsp]
  0002c	48 c7 c2 ff ff
	ff ff		 mov	 rdx, -1
  00033	48 8b 4c 24 40	 mov	 rcx, QWORD PTR _Buffer$[rsp]
  00038	e8 00 00 00 00	 call	 _vsnprintf_l

; 1460 :     }

  0003d	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00041	c3		 ret	 0
_vsprintf_l ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files (x86)\Windows Kits\10\include\10.0.22000.0\ucrt\stdio.h
;	COMDAT _vsnprintf_l
_TEXT	SEGMENT
_Result$ = 48
tv74 = 52
_Buffer$ = 80
_BufferCount$ = 88
_Format$ = 96
_Locale$ = 104
_ArgList$ = 112
_vsnprintf_l PROC					; COMDAT

; 1391 :     {

$LN5:
  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 1392 :         int const _Result = __stdio_common_vsprintf(

  00018	e8 00 00 00 00	 call	 __local_stdio_printf_options
  0001d	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00020	48 83 c8 01	 or	 rax, 1
  00024	48 8b 4c 24 70	 mov	 rcx, QWORD PTR _ArgList$[rsp]
  00029	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  0002e	48 8b 4c 24 68	 mov	 rcx, QWORD PTR _Locale$[rsp]
  00033	48 89 4c 24 20	 mov	 QWORD PTR [rsp+32], rcx
  00038	4c 8b 4c 24 60	 mov	 r9, QWORD PTR _Format$[rsp]
  0003d	4c 8b 44 24 58	 mov	 r8, QWORD PTR _BufferCount$[rsp]
  00042	48 8b 54 24 50	 mov	 rdx, QWORD PTR _Buffer$[rsp]
  00047	48 8b c8	 mov	 rcx, rax
  0004a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___stdio_common_vsprintf
  00050	89 44 24 30	 mov	 DWORD PTR _Result$[rsp], eax

; 1393 :             _CRT_INTERNAL_LOCAL_PRINTF_OPTIONS | _CRT_INTERNAL_PRINTF_LEGACY_VSPRINTF_NULL_TERMINATION,
; 1394 :             _Buffer, _BufferCount, _Format, _Locale, _ArgList);
; 1395 : 
; 1396 :         return _Result < 0 ? -1 : _Result;

  00054	83 7c 24 30 00	 cmp	 DWORD PTR _Result$[rsp], 0
  00059	7d 0a		 jge	 SHORT $LN3@vsnprintf_
  0005b	c7 44 24 34 ff
	ff ff ff	 mov	 DWORD PTR tv74[rsp], -1
  00063	eb 08		 jmp	 SHORT $LN4@vsnprintf_
$LN3@vsnprintf_:
  00065	8b 44 24 30	 mov	 eax, DWORD PTR _Result$[rsp]
  00069	89 44 24 34	 mov	 DWORD PTR tv74[rsp], eax
$LN4@vsnprintf_:
  0006d	8b 44 24 34	 mov	 eax, DWORD PTR tv74[rsp]

; 1397 :     }

  00071	48 83 c4 48	 add	 rsp, 72			; 00000048H
  00075	c3		 ret	 0
_vsnprintf_l ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files (x86)\Windows Kits\10\include\10.0.22000.0\ucrt\corecrt_stdio_config.h
;	COMDAT __local_stdio_printf_options
_TEXT	SEGMENT
__local_stdio_printf_options PROC			; COMDAT

; 91   :         static unsigned __int64 _OptionsStorage;
; 92   :         return &_OptionsStorage;

  00000	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:?_OptionsStorage@?1??__local_stdio_printf_options@@9@9 ; `__local_stdio_printf_options'::`2'::_OptionsStorage

; 93   :     }

  00007	c3		 ret	 0
__local_stdio_printf_options ENDP
_TEXT	ENDS
END
